head	1.76;
access;
symbols
	OPENBSD_5_8:1.74.0.6
	OPENBSD_5_8_BASE:1.74
	OPENBSD_5_7:1.74.0.2
	OPENBSD_5_7_BASE:1.74
	OPENBSD_5_6:1.71.0.4
	OPENBSD_5_6_BASE:1.71
	OPENBSD_5_5:1.60.0.4
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.51.0.2
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.49.0.2
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.47.0.4
	OPENBSD_5_2_BASE:1.47
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.2
	OPENBSD_5_0:1.45.0.2
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.39.0.2
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.29.0.4
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	AV400_20060509:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.76
date	2015.12.01.07.50.03;	author deraadt;	state dead;
branches;
next	1.75;
commitid	Rh8AZFtVMVCiwPts;

1.75
date	2015.10.21.07.59.17;	author mpi;	state Exp;
branches;
next	1.74;
commitid	XglPgGQ8qaiL0M4l;

1.74
date	2015.02.25.17.41.22;	author miod;	state Exp;
branches;
next	1.73;
commitid	SPD70tGdBh1CAdeU;

1.73
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.72;
commitid	qHQiR2HLROzvZr7B;

1.72
date	2014.09.20.09.28.24;	author kettenis;	state Exp;
branches;
next	1.71;
commitid	IFRB8AkvBMXMTAKW;

1.71
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.70;
commitid	7QO4UJr3EKVAMc8t;

1.70
date	2014.07.13.22.53.38;	author uebayasi;	state Exp;
branches;
next	1.69;
commitid	wsdp3qtXGjMj98oD;

1.69
date	2014.07.13.22.13.06;	author uebayasi;	state Exp;
branches;
next	1.68;
commitid	qYPOd6Qi4aRBKldK;

1.68
date	2014.07.10.21.46.02;	author mpi;	state Exp;
branches;
next	1.67;
commitid	iYq3Z1ZWDKR3sS9G;

1.67
date	2014.07.10.20.15.26;	author uebayasi;	state Exp;
branches;
next	1.66;
commitid	YzvTa4t6mddz7Mh4;

1.66
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.65;
commitid	xpsLTYRIkonFtkr1;

1.65
date	2014.07.10.12.13.48;	author uebayasi;	state Exp;
branches;
next	1.64;
commitid	aofvn6ceiucgjg4N;

1.64
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.63;
commitid	eA4Y0YE1IUzj6hpW;

1.63
date	2014.05.30.13.46.16;	author mpi;	state Exp;
branches;
next	1.62;

1.62
date	2014.05.08.22.17.33;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.60;

1.60
date	2014.01.19.12.45.35;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2013.11.02.23.10.29;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2013.10.17.08.02.15;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2013.10.10.21.24.59;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2013.10.07.19.11.39;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2013.10.07.19.10.40;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2013.10.07.19.09.08;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2013.09.28.19.56.47;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2013.09.28.12.40.29;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2013.06.11.16.42.07;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2013.06.03.16.55.21;	author guenther;	state Exp;
branches;
next	1.49;

1.49
date	2012.12.26.22.32.13;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2012.10.08.21.47.47;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2011.10.09.17.09.27;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2011.10.09.17.01.32;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2011.06.26.22.39.59;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2011.06.05.19.41.06;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2011.05.30.22.25.20;	author oga;	state Exp;
branches;
next	1.42;

1.42
date	2011.01.05.22.20.19;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2011.01.02.13.39.37;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2010.12.31.21.38.07;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.27.12.41.21;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.37;

1.37
date	2010.04.24.18.46.51;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2010.04.24.18.44.25;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2010.04.21.19.33.45;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2010.04.18.18.37.37;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2009.08.11.19.17.16;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.30;

1.30
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.29;

1.29
date	2009.06.15.17.01.25;	author beck;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.03.21.30.19;	author beck;	state Exp;
branches;
next	1.27;

1.27
date	2009.04.19.17.56.12;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2009.03.15.20.39.51;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.27.17.22.14;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2008.01.23.16.37.58;	author jsing;	state Exp;
branches;
next	1.22;

1.22
date	2008.01.13.20.20.27;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2007.12.31.09.23.53;	author martin;	state Exp;
branches;
next	1.20;

1.20
date	2007.12.19.22.05.04;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2007.12.19.21.53.36;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.12.13.18.51.01;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.11.17.05.36.21;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.17.05.32.04;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.15.21.23.14;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.14.23.12.44;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.06.21.42.55;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.13.12.55.20;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.10.15.53.51;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.06.17.15.11;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.29.20.36.47;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.27.17.31.55;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.26.20.26.50;	author pedro;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.12.20.03.22;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.21.12.22.01;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.20.22.40.43;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.20.12.04.51;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.16.23.22.10;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.09.18.09.02;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.05.09.18.09.02;	author miod;	state Exp;
branches;
next	;


desc
@@


1.76
log
@Send Aviion to same place as Nova II
discussed with jsg
@
text
@/*	$OpenBSD: machdep.c,v 1.75 2015/10/21 07:59:17 mpi Exp $	*/
/*
 * Copyright (c) 2007 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice, this permission notice, and the disclaimer below
 * appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 1998, 1999, 2000, 2001 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/malloc.h>
#include <sys/mount.h>
#include <sys/msgbuf.h>
#include <sys/syscallargs.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <sys/errno.h>
#include <sys/extent.h>
#include <sys/core.h>
#include <sys/kcore.h>
#include <sys/device.h>
#include <dev/rndvar.h>

#include <machine/asm.h>
#include <machine/asm_macro.h>
#include <machine/autoconf.h>
#include <machine/avcommon.h>
#include <machine/board.h>
#include <machine/bus.h>
#include <machine/cmmu.h>
#include <machine/cpu.h>
#include <machine/kcore.h>
#include <machine/prom.h>
#include <machine/reg.h>
#include <machine/trap.h>
#ifdef M88100
#include <machine/m88100.h>
#endif

#include <aviion/dev/vmevar.h>

#include <dev/cons.h>

#include <net/if.h>
#include <uvm/uvm.h>

#include "ksyms.h"
#if DDB
#include <machine/db_machdep.h>
#include <ddb/db_extern.h>
#include <ddb/db_interface.h>
#include <ddb/db_var.h>
#endif /* DDB */

void	aviion_bootstrap(void);
void	aviion_identify(void);
void	consinit(void);
void	cpu_hatch_secondary_processors(void);
void	cpu_setup_secondary_processors(void);
__dead void doboot(void);
void	dumpconf(void);
void	dumpsys(void);
void	savectx(struct pcb *);
void	secondary_main(void);
void   *secondary_pre_main(void);

extern void bootstack(void);

int physmem;	  /* available physical memory, in pages */

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

#ifdef MULTIPROCESSOR
__cpu_simple_lock_t cpu_hatch_mutex = __SIMPLELOCK_LOCKED;
__cpu_simple_lock_t cpu_boot_mutex = __SIMPLELOCK_LOCKED;
unsigned int hatch_pending_count;
unsigned int hatch_mask;
#endif

struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 };
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };

/*
 * Info for CTL_HW
 */
char  machine[] = MACHINE;	 /* cpu "architecture" */
char  cpu_model[120];

#if defined(DDB) || NKSYMS > 0
extern vaddr_t esym;
#endif

const char *prom_bootargs;			/* set in locore.S */
char bootargs[256];				/* local copy */

int32_t cpuid;

int cputyp;					/* set in locore.S */
register_t kernel_vbr;				/* set in locore.S */
const struct board *platform;

/* multiplication factor for delay() */
u_int	aviion_delay_const = 33;

vaddr_t first_addr;
vaddr_t last_addr;

extern struct user *proc0paddr;

/*
 * Interrupt masks, one per IPL level.
 */
u_int32_t int_mask_val[NIPLS];
u_int32_t ext_int_mask_val[NIPLS];

/*
 * This is to fake out the console routines, while booting.
 * We could use directly the bugtty console, but we want to be able to
 * configure a kernel without bugtty since we do not necessarily need a
 * full-blown console driver.
 */
cons_decl(boot);

struct consdev bootcons = {
	NULL,
	NULL,
	bootcngetc,
	bootcnputc,
	nullcnpollc,
	NULL,
	makedev(14, 0),
	CN_LOWPRI
};

/*
 * Early console initialization: called early on from main, before vm init.
 * We want to stick to the BUG routines for now, and we'll switch to the
 * real console in cpu_startup().
 */
void
consinit()
{
	cn_tab = NULL;
	cninit();

#if defined(DDB)
	db_machine_init();
	ddb_init();
	if (boothowto & RB_KDB)
		Debugger();
#endif
}

/*
 * Set up real-time clocks.
 * These function pointers are set in dev/clock.c.
 */
void
cpu_initclocks()
{
	platform->init_clocks();
}

void
setstatclockrate(int newhz)
{
	/* function stub */
}


void
cpu_startup()
{
	vaddr_t minaddr, maxaddr;

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf(version);
	printf("real mem = %lu (%luMB)\n", ptoa(physmem),
	    ptoa(physmem)/1024/1024);

	/*
	 * Grab machine dependent memory spaces
	 */
	platform->startup();

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate map for physio.
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, 0, FALSE, NULL);

	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024/1024);

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}

__dead void
doboot()
{

	printf("Rebooting system...\n\n");
	bootstack();
	cmmu_shutdown();
	scm_reboot(NULL);
	/*NOTREACHED*/
	for (;;);		/* appease gcc */
}

__dead void
boot(int howto)
{
	if (curproc && curproc->p_addr)
		savectx(curpcb);

	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0) {
		vfs_shutdown();

		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & RB_DUMP) != 0)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

	if ((howto & RB_HALT) != 0) {
		printf("System halted.\n\n");
		bootstack();
		cmmu_shutdown();
		scm_halt();
	}

	doboot();

	for (;;) ;
	/* NOTREACHED */
}

unsigned dumpmag = 0x8fca0101;	 /* magic number for savecore */
int   dumpsize = 0;	/* also for savecore */
long  dumplo = 0;
cpu_kcore_hdr_t cpu_kcore_hdr;

/*
 * This is called by configure to set dumplo and dumpsize.
 * Dumps always skip the first PAGE_SIZE of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
void
dumpconf(void)
{
	int nblks;	/* size of dump area */

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	dumpsize = physmem;

	/* aviion only uses a single segment. */
	cpu_kcore_hdr.ram_segs[0].start = 0;
	cpu_kcore_hdr.ram_segs[0].size = ptoa(physmem);
	cpu_kcore_hdr.cputype = cputyp;

	/*
	 * Don't dump on the first block
	 * in case the dump device includes a disk label.
	 */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize + 1 > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo) - 1;
	if (dumplo < nblks - ctod(dumpsize) - 1)
		dumplo = nblks - ctod(dumpsize) - 1;
}

/*
 * Doadump comes here after turning off memory management and
 * getting on the dump stack, either when called above, or by
 * the auto-restart code.
 */
void
dumpsys()
{
	int maj;
	int psize;
	daddr_t blkno;	/* current block to write */
				/* dump routine */
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	int pg;			/* page being dumped */
	paddr_t maddr;		/* PA being dumped */
	int error;		/* error code from (*dump)() */
	kcore_seg_t *kseg_p;
	cpu_kcore_hdr_t *chdr_p;
	char dump_hdr[dbtob(1)];	/* XXX assume hdr fits in 1 block */

	extern int msgbufmapped;

	msgbufmapped = 0;

	/* Make sure dump device is valid. */
	if (dumpdev == NODEV)
		return;
	if (dumpsize == 0) {
		dumpconf();
		if (dumpsize == 0)
			return;
	}
	maj = major(dumpdev);
	if (dumplo < 0) {
		printf("\ndump to dev %u,%u not possible\n", maj,
		    minor(dumpdev));
		return;
	}
	dump = bdevsw[maj].d_dump;
	blkno = dumplo;

	printf("\ndumping to dev %u,%u offset %ld\n", maj,
	    minor(dumpdev), dumplo);

	/* Setup the dump header */
	kseg_p = (kcore_seg_t *)dump_hdr;
	chdr_p = (cpu_kcore_hdr_t *)&dump_hdr[ALIGN(sizeof(*kseg_p))];
	bzero(dump_hdr, sizeof(dump_hdr));

	CORE_SETMAGIC(*kseg_p, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	kseg_p->c_size = dbtob(1) - ALIGN(sizeof(*kseg_p));
	*chdr_p = cpu_kcore_hdr;

	printf("dump ");
	psize = (*bdevsw[maj].d_psize)(dumpdev);
	if (psize == -1) {
		printf("area unavailable\n");
		return;
	}

	/* Dump the header. */
	error = (*dump)(dumpdev, blkno++, (caddr_t)dump_hdr, dbtob(1));
	if (error != 0)
		goto abort;

	maddr = (paddr_t)0;
	for (pg = 0; pg < dumpsize; pg++) {
#define NPGMB	(1024 * 1024 / PAGE_SIZE)
		/* print out how many MBs we have dumped */
		if (pg != 0 && (pg % NPGMB) == 0)
			printf("%d ", pg / NPGMB);
#undef NPGMB
		error = (*dump)(dumpdev, blkno, (caddr_t)maddr, PAGE_SIZE);
		if (error == 0) {
			maddr += PAGE_SIZE;
			blkno += btodb(PAGE_SIZE);
		} else
			break;
	}
abort:
	switch (error) {
	case 0:
		printf("succeeded\n");
		break;

	case ENXIO:
		printf("device bad\n");
		break;

	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	case EINTR:
		printf("aborted from console\n");
		break;

	default:
		printf("error %d\n", error);
		break;
	}
}

#ifdef MULTIPROCESSOR

/*
 * Secondary CPU early initialization routine.
 * Determine CPU number and set it, then return the startup stack.
 *
 * Running on a minimal stack here, with interrupts disabled; do nothing fancy.
 */
void *
secondary_pre_main()
{
	struct cpu_info *ci;

	/*
	 * Invoke the CMMU initialization routine as early as possible,
	 * so that we do not risk any memory writes to be lost during
	 * cache setup.
	 */
	cmmu_initialize_cpu(cmmu_cpu_number());

	/*
	 * Now initialize your cpu_info structure.
	 */
	set_cpu_number(cmmu_cpu_number());
	ci = curcpu();
	ci->ci_curproc = &proc0;
	platform->smp_setup(ci);

	splhigh();

	/*
	 * Enable MMU on this processor.
	 */
	pmap_bootstrap_cpu(ci->ci_cpuid);

	if (ci->ci_curpcb == NULL) {
		printf("cpu%d: unable to get startup stack\n", ci->ci_cpuid);
		/*
		 * Release cpu_hatch_mutex to let other secondary processors
		 * have a chance to run.
		 */
		__cpu_simple_unlock(&cpu_hatch_mutex);
		for (;;) ;
	}

	return ci->ci_curpcb;
}

/*
 * Further secondary CPU initialization.
 *
 * We are now running on our startup stack, with proper page tables.
 * There is nothing to do but display some details about the CPU and its CMMUs.
 */
void
secondary_main()
{
	struct cpu_info *ci = curcpu();
	int s;

	cpu_configuration_print(0);
	ncpus++;

	sched_init_cpu(ci);
	nanouptime(&ci->ci_schedstate.spc_runtime);
	ci->ci_curproc = NULL;
	ci->ci_randseed = (arc4random() & 0x7fffffff) + 1;

	/*
	 * Release cpu_hatch_mutex to let other secondary processors
	 * have a chance to run.
	 */
	hatch_pending_count--;
	__cpu_simple_unlock(&cpu_hatch_mutex);

	/* wait for cpu_boot_secondary_processors() */
	__cpu_simple_lock(&cpu_boot_mutex);
	__cpu_simple_unlock(&cpu_boot_mutex);

	spl0();
	SCHED_LOCK(s);
	set_psr(get_psr() & ~PSR_IND);

	SET(ci->ci_flags, CIF_ALIVE);

	cpu_switchto(NULL, sched_chooseproc());
}

#endif	/* MULTIPROCESSOR */

void
nmihand(void *frame)
{
#ifdef DDB
	printf("Abort switch pressed\n");
	if (db_console) {
		/*
		 * We can't use Debugger() here, as we are coming from an
		 * exception, and can't assume anything on the state we are
		 * in. Invoke the post-trap ddb entry directly.
		 */
		extern void m88k_db_trap(int, struct trapframe *);
		m88k_db_trap(T_KDB_ENTRY, (struct trapframe *)frame);
	}
#endif
}

int
sys_sysarch(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
#if 0
	struct sys_sysarch_args	/* {
	   syscallarg(int) op;
	   syscallarg(char *) parm;
	} */ *uap = v;
#endif

	return (ENOSYS);
}

/*
 * machine dependent system variables.
 */

int
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	dev_t consdev;

	/* all sysctl names are this level are terminal */
	if (namelen != 1)
		return (ENOTDIR); /* overloaded */

	switch (name[0]) {
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
	case CPU_CPUTYPE:
		return (sysctl_rdint(oldp, oldlenp, newp, cputyp));
	default:
		return (EOPNOTSUPP);
	}
	/*NOTREACHED*/
}

/*
 * Called from locore.S during boot,
 * this is the first C code that's run.
 */
void
aviion_bootstrap()
{
	extern vaddr_t avail_start;
	extern vaddr_t avail_end;
	extern char *end;
#ifndef MULTIPROCESSOR
	cpuid_t master_cpu;
#endif

	/* Save a copy of our commandline before it gets overwritten. */
	strlcpy(bootargs, prom_bootargs, sizeof bootargs);

	aviion_identify();

	cn_tab = &bootcons;
	aviion_delay_const = platform->bootstrap();
	/* we can use printf() from here. */

	/* Parse the commandline */
	cmdline_parse();

	uvmexp.pagesize = PAGE_SIZE;
	uvm_setpagesize();

#if defined(DDB) || NKSYMS > 0
	if (esym != 0)
		first_addr = esym;
	else
#endif
		first_addr = (vaddr_t)&end;
	first_addr = round_page(first_addr);

	last_addr = platform->memsize();

	setup_board_config();
	master_cpu = cmmu_init();
	set_cpu_number(master_cpu);
#ifdef MULTIPROCESSOR
	platform->smp_setup(curcpu());
#endif
	SET(curcpu()->ci_flags, CIF_ALIVE | CIF_PRIMARY);

#ifdef M88100
	if (CPU_IS88100) {
		m88100_apply_patches();
	}
#endif

#ifdef MULTIPROCESSOR
	/*
	 * We need to start secondary processors while it is still
	 * possible to invoke SCM functions.
	 */
	cpu_hatch_secondary_processors();
#endif

	/*
	 * Now that set_cpu_number() set us with a valid cpu_info pointer,
	 * we need to initialize p_addr and curpcb before autoconf, for the
	 * fault handler to behave properly [except for badaddr() faults,
	 * which can be taken care of without a valid curcpu()].
	 */
	proc0.p_addr = proc0paddr;
	curproc = &proc0;
	curpcb = &proc0paddr->u_pcb;

	avail_start = round_page(first_addr);
	avail_end = last_addr;

	/*
	 * Tell the VM system about available physical memory.
	 * The aviion systems only have one contiguous area.
	 *
	 * XXX However, on series 5000, SRAM overlaps a low memory range,
	 * XXX so we will need to upload two ranges of pages on them.
	 */
	uvm_page_physload(atop(avail_start), atop(avail_end),
	    atop(avail_start), atop(avail_end), 0);

	/*
	 * Initialize message buffer.
	 */
	initmsgbuf((caddr_t)pmap_steal_memory(MSGBUFSIZE, NULL, NULL),
	    MSGBUFSIZE);

	/* ROM work area is on top of physical memory */
	pmap_bootstrap(0, 0);

	/* Initialize the "u-area" pages. */
	bzero((caddr_t)curpcb, USPACE);
}

#ifdef MULTIPROCESSOR
/*
 * Spin processors while we can use the PROM, and have them wait for
 * cpu_hatch_mutex.
 */
void
cpu_hatch_secondary_processors()
{
	struct cpu_info *ci = curcpu();
	cpuid_t cpu;
	int rc;
	extern void secondary_start(void);

	/* we might not have a working SMP implementation on this system. */
	if (platform->send_ipi == NULL)
		return;

	for (cpu = 0; cpu < MAX_CPUS; cpu++) {
		if (cpu != ci->ci_cpuid) {
			hatch_pending_count++;
			rc = scm_jpstart(cpu, (vaddr_t)secondary_start);
			switch (rc) {
			case JPSTART_OK:
				hatch_mask |= 1U << cpu;
				break;
			case JPSTART_SINGLE_JP:
				/* this should never happen, but just in case */
				hatch_pending_count = 0;
				ncpusfound = 1;
				return;
			default:
				printf("CPU%ld failed to start, error %d\n",
				    cpu, rc);
				/* FALLTHROUGH */
			case JPSTART_NO_JP:
				hatch_pending_count--;
				break;
			}
		}
	}
}

/*
 * Release cpu_hatch_mutex to let secondary processors initialize.
 */
void
cpu_setup_secondary_processors()
{
	cpuid_t cpu;

	/*
	 * Allocate UPAGES contiguous pages for the idle stack of every
	 * running secondary processor.
	 */
	for (cpu = 0; cpu < MAX_CPUS; cpu++) {
		if ((hatch_mask & (1U << cpu)) == 0)
			continue;

		m88k_cpus[cpu].ci_curpcb =
		    (void *)uvm_km_zalloc(kernel_map, USPACE);
	}

	__cpu_simple_unlock(&cpu_hatch_mutex);
	while (hatch_pending_count != 0)
		delay(10000);	/* 10ms */
}

/*
 * Release cpu_boot_mutex to let secondary processors start running
 * processes.
 */
void
cpu_boot_secondary_processors()
{
	__cpu_simple_unlock(&cpu_boot_mutex);
}
#endif

/*
 * Boot console routines:
 * Enables printing of boot messages before consinit().
 */
void
bootcnprobe(cp)
	struct consdev *cp;
{
	cp->cn_dev = makedev(0, 0);
	cp->cn_pri = CN_LOWPRI;
}

void
bootcninit(cp)
	struct consdev *cp;
{
	/* Nothing to do */
}

int
bootcngetc(dev)
	dev_t dev;
{
	return (scm_getc());
}

void
bootcnputc(dev, c)
	dev_t dev;
	int c;
{
	if (c == '\n')
		scm_putcrlf();
	else
		scm_putc(c);
}

int
getipl(void)
{
	return (int)platform->getipl();
}

int
setipl(int level)
{
	return (int)platform->setipl((u_int)level);
}

int
raiseipl(int level)
{
	return (int)platform->raiseipl((u_int)level);
}

#ifdef MULTIPROCESSOR
void
m88k_send_ipi(int ipi, cpuid_t cpu)
{
	struct cpu_info *ci;

	ci = &m88k_cpus[cpu];
	if (ISSET(ci->ci_flags, CIF_ALIVE))
		platform->send_ipi(ipi, cpu);
}

void
m88k_broadcast_ipi(int ipi)
{
	struct cpu_info *us = curcpu();
	struct cpu_info *ci;
	CPU_INFO_ITERATOR cii;

	CPU_INFO_FOREACH(cii, ci) {
		if (ci == us)
			continue;

		if (ISSET(ci->ci_flags, CIF_ALIVE))
			platform->send_ipi(ipi, ci->ci_cpuid);
	}
}
#endif

void
intsrc_enable(u_int intsrc, int ipl)
{
	u_int32_t psr;
	u_int32_t intmask = platform->intsrc(intsrc);
	u_int32_t exintmask = platform->exintsrc(intsrc);
	int i;

	psr = get_psr();
	set_psr(psr | PSR_IND);

	for (i = IPL_NONE; i < ipl; i++) {
		int_mask_val[i] |= intmask;
		ext_int_mask_val[i] |= exintmask;
	}
	setipl(getipl());

	set_psr(psr);
}

void
intsrc_disable(u_int intsrc)
{
	u_int32_t psr;
	u_int32_t intmask = platform->intsrc(intsrc);
	u_int32_t exintmask = platform->exintsrc(intsrc);
	int i;

	psr = get_psr();
	set_psr(psr | PSR_IND);

	for (i = 0; i < NIPLS; i++) {
		int_mask_val[i] &= ~intmask;
		ext_int_mask_val[i] &= ~exintmask;
	}
	setipl(getipl());

	set_psr(psr);
}

u_char hostaddr[6];

void
myetheraddr(u_char *cp)
{
	bcopy(hostaddr, cp, 6);
}

/*
 * Attempt to identify which AViiON flavour we are running on.
 */

struct aviion_system {
	int32_t			 cpuid;
	const char		*model;
	const struct board	*platform;
	const char		*kernel_option;
};
static const struct aviion_system aviion_systems[] = {
#define	BOARD_UNSUPPORTED	NULL, NULL
#ifdef AV400
#define	BOARD_AV400		&board_av400, NULL
#else
#define	BOARD_AV400		NULL, "AV400"
#endif
#ifdef AV530
#define	BOARD_AV530		&board_av530, NULL
#else
#define	BOARD_AV530		NULL, "AV530"
#endif
#ifdef AV5000
#define	BOARD_AV5000		&board_av5000, NULL
#else
#define	BOARD_AV5000		BOARD_UNSUPPORTED /* NULL, "AV5000" */
#endif
#ifdef AV6280
#define	BOARD_AV6280		&board_av6280, NULL
#else
#define	BOARD_AV6280		BOARD_UNSUPPORTED /* NULL, "AV6280" */
#endif
	{ AVIION_300_310,		"300/310",	BOARD_AV400 },
	{ AVIION_5100_6100,		"5100/6100",	BOARD_UNSUPPORTED },
	{ AVIION_400_4000,		"400/4000",	BOARD_AV400 },
	{ AVIION_410_4100,		"410/4100",	BOARD_AV400 },
	{ AVIION_300C_310C,		"300C/310C",	BOARD_AV400 },
	{ AVIION_5200_6200,		"5200/6200",	BOARD_AV5000 },
	{ AVIION_5240_6240,		"5240/6240",	BOARD_AV5000 },
	{ AVIION_300CD_310CD,		"300CD/310CD",	BOARD_AV400 },
	{ AVIION_300D_310D,		"300D/310D",	BOARD_AV400 },
	{ AVIION_4600_530,		"4600/530",	BOARD_AV530 },
	{ AVIION_4300_25,		"4300-25",	BOARD_AV400 },
	{ AVIION_4300_20,		"4300-20",	BOARD_AV400 },
	{ AVIION_4300_16,		"4300-16",	BOARD_AV400 },
	{ AVIION_5255_6255,		"5255/6255",	BOARD_AV5000 },
	{ AVIION_350,			"350",		BOARD_UNSUPPORTED },
	{ AVIION_6280,			"6280",		BOARD_AV6280 },
	{ AVIION_8500_9500,		"8500/9500",	BOARD_UNSUPPORTED },
	{ AVIION_9500_HA,		"9500HA",	BOARD_UNSUPPORTED },
	{ AVIION_500,			"500",		BOARD_UNSUPPORTED },
	{ AVIION_5500,			"5500",		BOARD_UNSUPPORTED },
	{ AVIION_450,			"450",		BOARD_UNSUPPORTED },
	{ AVIION_8500_9500_45_1MB,	"8500/9500-45",	BOARD_UNSUPPORTED },
	{ AVIION_10000,			"10000",	BOARD_UNSUPPORTED },
	{ AVIION_10000_QT,		"10000QT",	BOARD_UNSUPPORTED },
	{ AVIION_5500PLUS,		"5500+",	BOARD_UNSUPPORTED },
	{ AVIION_450PLUS,		"450+",		BOARD_UNSUPPORTED },
	{ AVIION_8500_9500_50_1MB,	"8500/9500-50",	BOARD_UNSUPPORTED },
	{ AVIION_8500_9500_50_2MB,	"8500/9500-50d", BOARD_UNSUPPORTED },

	{ AVIION_UNKNOWN1,		"\"Montezuma\"", BOARD_UNSUPPORTED },
	{ AVIION_UNKNOWN2,		"\"Montezuma\"", BOARD_UNSUPPORTED },
	{ AVIION_UNKNOWN3,		"\"Flintstone\"", BOARD_UNSUPPORTED },
	{ AVIION_UNKNOWN1_DIS,		"\"Montezuma-\"", BOARD_UNSUPPORTED },
	{ AVIION_UNKNOWN2_DIS,		"\"Montezuma-\"", BOARD_UNSUPPORTED },

	{ 0 }
#undef	BOARD_AV6280
#undef	BOARD_AV5000
#undef	BOARD_AV530
#undef	BOARD_AV400
};

void
aviion_identify()
{
	const struct aviion_system *system;
	char excuse[512];
	extern char *hw_vendor, *hw_prod;

	cpuid = scm_cpuid();
	hostid = scm_sysid();

	for (system = aviion_systems; ; system++) {
		if (system->cpuid != 0 && system->cpuid != cpuid)
			continue;

		if (system->platform != NULL) {
			hw_vendor = "Data General";
			hw_prod = "AViiON";
			strlcpy(cpu_model, system->model, sizeof cpu_model);
			platform = system->platform;
			return;
		}

		if (system->kernel_option != NULL) {
			/* unconfigured system */
			snprintf(excuse, sizeof excuse, "\n"
			    "Sorry, support for the %s system is not present\n"
			    "in this OpenBSD/" MACHINE " kernel.\n"
			    "Please recompile your kernel with\n"
			    "\toption\t%s\n"
			    "in the kernel configuration file.\n",
			    system->model, system->kernel_option);
		} else if (system->cpuid != 0) {
			/* unsupported system */
			snprintf(excuse, sizeof excuse, "\n"
			    "Sorry, OpenBSD/" MACHINE
			    " does not support the %s system"
			    " (cpuid %04x) yet.\n\n"
			    "Please contact <m88k@@openbsd.org>\n",
			    system->model, cpuid);
		} else {
			/* unrecgonized system */
			snprintf(excuse, sizeof excuse, "\n"
			    "Sorry, OpenBSD/" MACHINE
			    " does not recognize this system (cpuid %04x).\n\n"
			    "Please contact <m88k@@openbsd.org>\n",
			    cpuid);
		}

		scm_printf(excuse);
		scm_halt();
	}
	/* NOTREACHED */
}
@


1.75
log
@Do not call uvm_swap_finicrypt_all() a second time in dumpsys().

ok tedu@@, deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.74 2015/02/25 17:41:22 miod Exp $	*/
@


1.74
log
@Rework secondary processor initialization, in order to allocate their idle
stack from the main processor, instead of from the secondary processors
themselves. This used to work until recent churn in uvm require the kernel
lock to be taken, and cpu_configure() runs with the kernel lock held by the
boot processor.

Allocating the idle stack on the secondary processors themselves was choosen
early on, because there is no easy way, from the boot processor, to know the
assocation between physical cpu number (ci_cpuid) and logical cpu number
(the order they are initialized and reported in), especially on luna88k where
there is no way to get secondary processors parked by the prom.

Regression noticed by aoyama@@. Verified to work on 2 and 4 cpu luna88k systems
and 2 cpu aviion systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.73 2014/12/10 15:29:53 mikeb Exp $	*/
a428 4

#ifdef UVM_SWAP_ENCRYPT
	uvm_swap_finicrypt_all();
#endif
@


1.73
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.72 2014/09/20 09:28:24 kettenis Exp $	*/
d125 1
a125 1
vaddr_t	secondary_pre_main(void);
a134 1
u_int	hatch_pending_count = 0;
d137 2
d505 1
a505 1
 * Determine CPU number and set it, then allocate its startup stack.
d509 1
a509 1
vaddr_t
a512 1
	vaddr_t init_stack;
d536 2
a537 7
	/*
	 * Allocate UPAGES contiguous pages for the startup stack.
	 */
	init_stack = uvm_km_zalloc(kernel_map, USPACE);
	if (init_stack == (vaddr_t)NULL) {
		printf("cpu%d: unable to allocate startup stack\n",
		    ci->ci_cpuid);
d546 1
a546 1
	return (init_stack);
d780 1
d805 14
@


1.72
log
@Use config_suspend_all(9).

ok mpi@@, uebayasi@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.71 2014/07/21 17:25:47 uebayasi Exp $	*/
a325 1
	doshutdownhooks();
@


1.71
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a296 2
	struct device *mainbus;

d327 1
a327 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.70
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d324 1
a324 1
	if (howto & RB_DUMP)
d333 1
a333 1
	if (howto & RB_HALT) {
@


1.69
log
@Cosmetic changes to reduce diffs.
@
text
@d342 2
a343 2
	for (;;);
	/*NOTREACHED*/
@


1.68
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2014/07/10 20:15:26 uebayasi Exp $	*/
d312 1
a312 1
		if ((howto & RB_TIMEBAD) == 0)
d314 1
a314 1
		else
d316 1
d321 1
a321 1
	splhigh();		/* Disable interrupts. */
a323 1
	/* If rebooting and a dump is requested, do it. */
@


1.67
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d321 1
@


1.66
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@a298 1
	/* take a snapshot before clobbering any registers */
a301 1
	/* If system is cold, just halt. */
a302 1
		/* (Unless the user explicitly asked for reboot.) */
@


1.65
log
@boot(): Unify declarations

OK deraadt@@
@
text
@d314 1
a314 5
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
@


1.64
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 2014/05/30 13:46:16 mpi Exp $	*/
d295 1
a295 2
boot(howto)
	int howto;
@


1.63
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 2014/05/08 22:17:33 miod Exp $	*/
a328 1
	cold = 1;
@


1.62
log
@Format string fixes for m88k; remove -Wno-format from the m88k kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 2014/03/13 03:52:55 dlg Exp $	*/
d329 1
@


1.61
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 2014/01/19 12:45:35 deraadt Exp $	*/
d240 1
a240 1
	printf("real mem = %u (%uMB)\n", ptoa(physmem),
d804 1
a804 1
				printf("CPU%d failed to start, error %d\n",
@


1.60
log
@Initialize ci_randseed better using arc4random() + a trick.  Remove the
libkern srandom() API since it is not suitable for this use.
ok kettenis miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.59 2013/11/02 23:10:29 miod Exp $	*/
d298 2
d336 3
a338 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.59
log
@Create the initial page tables in the area between the end of the firmware
data area and the kernel image, whenever possible.

On 88100/88200 systems, use BATC mappings to map the kernel text (and the
kernel data for non-MULTIPROCESSOR kernels). 88110 to follow soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 2013/10/17 08:02:15 deraadt Exp $	*/
d82 1
d581 1
a581 1
	ci->ci_randseed = random();
@


1.58
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 2013/10/10 21:24:59 miod Exp $	*/
d680 1
a680 1
	vaddr_t avail_start;
@


1.57
log
@Better boot device detection code. Board-specific code will now return the
address of a controller only know by its SCM name and number, and the boot
device detection code will now attempt to match the controller first, and
then grandchildren of it (if the boot device is a disk or a tape).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 2013/10/07 19:11:39 miod Exp $	*/
a618 9
}

int
cpu_exec_aout_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
{

	return (ENOEXEC);
@


1.56
log
@Have platform->bootstrap() return the machine speed in MHz, which is used to
set up the delay constant.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.55 2013/10/07 19:10:40 miod Exp $	*/
a153 1
u_int bootdev, bootunit, bootpart;		/* set in locore.S */
@


1.55
log
@Put the kernel VBR page at the beginning of the kernel text, as done on
mvme88k, to be able to unmap the page at address zero in the kernel, and have
the vbr page read-only after being initialized.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2013/10/07 19:09:08 miod Exp $	*/
d703 1
a703 1
	platform->bootstrap();
@


1.54
log
@Split the 64-bit interrupt source mask code into two 32-bit `interrupt' and
`extended interrupt' masks. This is how the hardware works, and this makes the
code simpler than attempting to aggregate them.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.53 2013/09/28 19:56:47 miod Exp $	*/
d159 1
a159 1
int avtyp;
d774 1
a774 3
	/* but we need to make VBR page readable */
	/* XXX relocate VBR as done on mvme88k */
	pmap_bootstrap(0, PAGE_SIZE);
@


1.53
log
@Make sure the stack is 1:1 mapped before attempting to give control back
to the PROM at halt/reboot time; this lets systems reboot again.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2013/09/28 12:40:29 miod Exp $	*/
d932 2
a933 1
	u_int64_t intmask = platform->intsrc(intsrc);
d940 2
a941 2
		int_mask_val[i] |= (u_int32_t)intmask;
		ext_int_mask_val[i] |= (u_int32_t)(intmask >> 32);
d952 2
a953 1
	u_int64_t intmask = platform->intsrc(intsrc);
d960 2
a961 2
		int_mask_val[i] &= ~((u_int32_t)intmask);
		ext_int_mask_val[i] &= ~((u_int32_t)(intmask >> 32));
@


1.52
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 2013/06/11 16:42:07 deraadt Exp $	*/
d126 2
d285 1
d287 1
d339 1
@


1.51
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.50 2013/06/03 16:55:21 guenther Exp $	*/
d330 2
a331 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.50
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 2012/12/26 22:32:13 miod Exp $	*/
d398 1
a398 1
	daddr64_t blkno;	/* current block to write */
d400 1
a400 1
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
@


1.49
log
@Nuke commons.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2012/10/08 21:47:47 deraadt Exp $	*/
d573 1
a573 1
	microuptime(&ci->ci_schedstate.spc_runtime);
@


1.48
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 2011/10/09 17:09:27 miod Exp $	*/
a165 3
vaddr_t avail_start, avail_end;
vaddr_t virtual_avail, virtual_end;

d684 2
@


1.47
log
@Cope with the recent pmap changes to prevent them from accidentally unmap
the VBR page (quick workaround until the VBR page is relocated as has been
done on mvme88k)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2011/10/09 17:01:32 miod Exp $	*/
a331 1
	/* Run any shutdown hooks. */
d333 1
@


1.46
log
@Rework secondary processor initialization. cmmu initialization is now
performed much earlier in the processor startup.
No visible change, paves the way for the much important diff three commits
from here.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2011/06/26 22:39:59 deraadt Exp $	*/
d768 4
a771 1
	pmap_bootstrap(0, 0);	/* ROM image is on top of physical memory */
a970 5
 * The only thing we can do at this point is peek at random addresses and
 * see if they cause bus errors, or not.
 *
 * These heuristics are probably not the best; feel free to come with better
 * ones...
a1056 4
		hw_vendor = "Data General";
		hw_prod = "AViiON";
		strlcpy(cpu_model, system->model, sizeof cpu_model);

d1058 3
d1090 3
d1094 1
a1094 3

	scm_printf(excuse);
	scm_halt();
@


1.45
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2011/06/05 19:41:06 deraadt Exp $	*/
d520 11
a530 1
	set_cpu_number(cmmu_cpu_number()); /* Determine cpu number by CMMU */
d538 1
a538 1
	 * Setup CMMUs and translation tables (shared with the master cpu).
a578 1
	SET(ci->ci_flags, CIF_ALIVE);
d594 3
d791 1
a791 1
	for (cpu = 0; cpu < ncpusfound; cpu++) {
d793 1
a796 3
				hatch_pending_count++;
				break;
			case JPSTART_NO_JP:
d800 1
d806 3
d823 1
a823 1
		delay(100000);
@


1.44
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2011/05/30 22:25:20 oga Exp $	*/
d103 1
d322 1
@


1.43
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2011/01/05 22:20:19 miod Exp $	*/
a134 14

/*
 * Declare these as initialized data so we can patch them.
 */
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

#ifdef	BUFPAGES
int bufpages = BUFPAGES;
#else
int bufpages = 0;
#endif
int bufcachepercent = BUFCACHEPERCENT;
@


1.42
log
@Pass pmap_bootstrap() the memory range used by the PROM/BUG/firmware/whatever,
instead of assuming it is ``everything below the kernel image''.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 2011/01/02 13:39:37 miod Exp $	*/
d760 1
a760 1
	    atop(avail_start), atop(avail_end), VM_FREELIST_DEFAULT);
@


1.41
log
@Fix dump to work with PMAP_DIRECT, as done on mvme88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2010/12/31 21:38:07 miod Exp $	*/
d768 1
a768 1
	pmap_bootstrap();
@


1.40
log
@Massive overhauling of the m88k pmap, though I can't pretend it's a new pmap
since a large part of the structures and logic remains.

Since m88k has separate supervisor/user spaces, we can map physical memory 1:1
in supervisor space, and have the kernel virtual address space start from the
end of physical memory.

This allows us to switch to __HAVE_PMAP_DIRECT. And to get rid of the double
mapped sdt, since now their virtual and physical addresses will always match.

The upper bound of the kernel virtual memory space is now platform dependent,
until the code which relies upon some hardware devices being mapped 1:1 in
supervisor mode is updated to no longer require this (this is mainly a PITA on
luna88k, where onboard devices start at 0x40000000, leaving only 1GB of KVA at
the moment - still much better than the previous 512MB).

Tested on mvme88k only (187, 188, 197LE, 197DP). Other platforms ought to
work, aviion will be checked shortly and fixed if necessary. No known
OpenBSD/luna88k system in working condition at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 2010/06/27 12:41:21 miod Exp $	*/
a247 1
	int i;
d479 1
a479 4
		pmap_enter(pmap_kernel(), (vaddr_t)vmmap, maddr,
		    VM_PROT_READ, VM_PROT_READ|PMAP_WIRED);

		error = (*dump)(dumpdev, blkno, vmmap, PAGE_SIZE);
a686 1
	extern int kernelstart;
@


1.39
log
@Bunch of include adjustements to restore compilability.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 2010/06/27 03:03:48 thib Exp $	*/
a251 10
	 * Initialize error message buffer (at end of core).
	 * avail_end was pre-decremented in aviion_bootstrap() to compensate.
	 */
	for (i = 0; i < atop(MSGBUFSIZE); i++)
		pmap_kenter_pa((paddr_t)msgbufp + i * PAGE_SIZE,
		    avail_end + i * PAGE_SIZE, VM_PROT_READ | VM_PROT_WRITE);
	pmap_update(pmap_kernel());
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));

	/*
a756 4
	/* Steal MSGBUFSIZE at the top of physical memory for msgbuf. */
	avail_end -= round_page(MSGBUFSIZE);
	pmap_bootstrap((vaddr_t)trunc_page((vaddr_t)&kernelstart));

d766 8
@


1.38
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2010/04/24 18:44:25 miod Exp $	*/
d103 1
a103 2
#include <uvm/uvm_extern.h>
#include <uvm/uvm_swap.h>
@


1.37
log
@SMP support for models 4600 and 530, adapted from the MVME188 code. Models
4000 and 4300 will need more work, because they don't have as many distinct
software interrupt sources as required by this implementation, so a
different IPI scheme will be necessary.

Tested on dual-processor 4625 (AV530 family) and single processor 4300
(AV400 family).
@
text
@d151 3
@


1.36
log
@Replace heuristics used to figure out which model we are running on, and
trust the cpuid value returned by the prom itself (verified against
/usr/opt/sdk/include/sys/dg_sys_info.h on a DG-UX filesystem).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 2010/04/21 19:33:45 miod Exp $	*/
d117 2
d132 3
a134 1
__cpu_simple_lock_t cpu_mutex = __SIMPLELOCK_UNLOCKED;
d542 1
d547 1
d563 5
a586 1
	sched_init_cpu(ci);
a587 1
	__cpu_simple_unlock(&cpu_mutex);
d589 1
d592 13
a605 1
	set_psr(get_psr() & ~PSR_IND);
a606 1

d608 1
d733 3
d744 8
d784 4
d789 1
a789 1
cpu_boot_secondary_processors()
d791 1
d796 4
d801 17
a817 4
		if (cpu != curcpu()->ci_cpuid) {
			rc = scm_spincpu(cpu, (vaddr_t)secondary_start);
			if (rc != 0)
				printf("cpu%d: spin_cpu error %d\n", cpu, rc);
d821 21
d898 28
@


1.35
log
@More reworking of interrupt handling and VME support, and rename various
board-specific defines to prevent any risk of collision. This also adds
clock support for AV530 family, and timecounter support (cio code sync'ed
with mvme88k). And various bugs fixed in the process.

This is enough to get models 4600 and 530 to run multiuser with a Hawk
Ethernet VME card (the onboard Ethernet is not supported yet, coming soon).
There is no way to share a disk with DG/UX yet, the kernel (and fdisk(8))
needs to become aware of its ways.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 2010/04/18 18:37:37 miod Exp $	*/
d115 1
a115 4
int	aviion_identify(void);
__dead void unconfigured(const char *);
__dead void unrecognized(void);
__dead void unsupported(const char *);
a119 1
void	identifycpu(void);
d161 1
a161 1
int32_t cpuid, sysid;
a221 6
void
identifycpu()
{
	strlcpy(cpu_model, platform->descr, sizeof cpu_model);
}

a258 1
	identifycpu();
d686 1
a686 36
	avtyp = aviion_identify();

	/* Set up interrupt and fp exception handlers based on the machine. */
	switch (avtyp) {
	case AV_400:
#ifdef AV400
		platform = &board_av400;
#else
		unconfigured("AV400");
#endif
		break;
	case AV_530:
#ifdef AV530
		platform = &board_av530;
#else
		unsupported("AV530");
#endif
		break;
	case AV_5000:
#ifdef AV5000
		platform = &board_av5000;
#else
		unsupported("AV5000");
#endif
		break;
	case AV_6280:
#ifdef AV6280
		platform = &board_av6280;
#else
		unsupported("AV6280");
#endif
		break;
	default:
		unrecognized();
		break;
	};
a876 11
int
aviion_identify()
{
	/*
	 * We don't know anything about 88110-based models.
	 * Note that we can't use CPU_IS81x0 here since these are optimized
	 * if the kernel you're running is compiled for only one processor
	 * type, and we want to check against the real hardware.
	 */
	if (cputyp == CPU_88110)
		return (0);
d878 69
a946 6
	/*
	 * Series 100/200/300/400/3000/4000/4300 do not have the VIRQLV
	 * register at 0xfff85000.
	 */
	if (badaddr(0xfff85000, 4) != 0)
		return (AV_400);
d948 2
a949 22
	/*
	 * Series 5000 and 6000 do not have an RTC counter at 0xfff8f084.
	 */
	if (badaddr(0xfff8f084, 4) != 0)
		return (AV_5000);

	/*
	 * Series 4600/530 have IOFUSEs at 0xfffb0040 and 0xfffb00c0;
	 * the second one may not be present if the I/O expansion board
	 * is missing.
	 */
	if (badaddr(0xfffb0040, 1) == 0 /* && badaddr(0xfffb00c0, 1) == 0 */)
		return (AV_530);

	/*
	 * Series 6280/8000-8 fall here.
	 */
	return (AV_6280);
}

__dead void
unconfigured(const char *model)
d951 1
d953 4
d958 3
a960 9
	snprintf(excuse, sizeof excuse, "\n"
	    "Sorry, support for the %s family is not present\n"
	    "in this OpenBSD/" MACHINE " kernel.\n"
	    "Please recompile your kernel with\n"
	    "\toption\t%s\n"
	    "in the kernel configuration file.\n", model, model);
	scm_printf(excuse);
	scm_halt();
}
d962 3
a964 4
__dead void
unsupported(const char *model)
{
	char excuse[512];
d966 4
a969 7
	snprintf(excuse, sizeof excuse, "\n"
	    "Sorry, OpenBSD/" MACHINE " does not support the %s family "
	    "(cpuid %04x) yet.\n",
	    model, scm_cpuid());
	scm_printf(excuse);
	scm_halt();
}
d971 26
a996 4
__dead void
unrecognized(void)
{
	char excuse[512];
a997 4
	snprintf(excuse, sizeof excuse, "\n"
	    "Sorry, OpenBSD/" MACHINE " does not recognize this system "
	    "(cpuid %04x) yet.\n",
	    scm_cpuid());
@


1.34
log
@Correctly identify a machine of the 530 family even if the expansion I/O board
is missing.

While there, provide more information when the system is not recognized.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 2009/08/11 19:17:16 miod Exp $	*/
d164 2
@


1.33
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 2009/08/11 18:46:32 miod Exp $	*/
d116 3
d699 1
a700 1
	case AV_400:
d702 3
d706 1
a706 1
#endif
a707 1
	case AV_530:
d709 3
d713 1
a713 1
#endif
a714 1
	case AV_5000:
d716 3
d720 1
a720 1
#endif
a721 1
	case AV_6280:
d723 3
a726 1
#endif
d728 1
a728 3
		scm_printf("Sorry, OpenBSD/" MACHINE
		    " does not support this model.\n");
		scm_halt();
d733 1
a735 2
	platform->bootstrap();

d947 3
a949 1
	 * Series 4600/530 have IOFUSEs at 0xfffb0040 and 0xfffb00c0.
d951 1
a951 1
	if (badaddr(0xfffb0040, 1) == 0 && badaddr(0xfffb00c0, 1) == 0)
d958 41
@


1.32
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2009/08/09 10:40:17 blambert Exp $	*/
a271 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.31
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 2009/08/02 16:28:39 beck Exp $	*/
a113 1
caddr_t	allocsys(caddr_t);
d247 1
a247 2
	caddr_t v;
	int sz, i;
a268 11
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	sz = (int)allocsys((caddr_t)0);

	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");
	if (allocsys(v) - v != sz)
		panic("startup: table size inconsistency");

	/*
a311 20
}

/*
 * Allocate space for system data structures.  We are given
 * a starting virtual address and we return a final virtual
 * address; along the way we set each data structure pointer.
 *
 * We call allocsys() with 0 to find out how much space we want,
 * allocate that much and fill it with zeroes, and then call
 * allocsys() again with the correct base virtual address.
 */
caddr_t
allocsys(v)
	caddr_t v;
{

#define	valloc(name, type, num) \
	    v = (caddr_t)(((name) = (type *)v) + (num))

	return v;
@


1.30
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 2009/06/15 17:01:25 beck Exp $	*/
a74 3
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
a342 7

#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.29
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 2009/06/03 21:30:19 beck Exp $	*/
a294 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.28
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 2009/04/19 17:56:12 miod Exp $	*/
d295 6
@


1.27
log
@Rename max_cpus to ncpusfound and compute it regardless of option
MULTIPROCESSOR.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 2009/03/15 20:39:51 miod Exp $	*/
a294 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.26
log
@Generic softinterrupt support for m88k based platforms, adapted from arm
with different locking mechanism. 88110 soft ipi are replaced with an
ipi callback which is checked upon return from exception (it can not be kept
as a softintr, as the generic softinterrupt code doesn't have per-cpu
pending softintr queues).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 2008/06/27 17:22:14 miod Exp $	*/
d850 1
a850 1
	for (cpu = 0; cpu < max_cpus; cpu++) {
@


1.25
log
@Clear swap encryption keys before dumping a kernel image.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 2008/04/09 16:58:10 deraadt Exp $	*/
d17 1
a17 1
/* $OpenBSD: machdep.c,v 1.24 2008/04/09 16:58:10 deraadt Exp $	*/
@


1.24
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 2008/04/09 16:50:27 deraadt Exp $	*/
d17 1
a17 1
/* $OpenBSD: machdep.c,v 1.24 2008/04/09 16:50:27 deraadt Exp $	*/
d107 1
d513 4
@


1.23
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 2007/12/31 09:23:53 martin Exp $	*/
d17 1
a17 1
/* $OpenBSD: machdep.c,v 1.17 2007/11/17 05:36:21 miod Exp $	*/
d402 2
a403 2
	/* Disable interrupts. */
	splhigh();
@


1.22
log
@Add a machdep.cputype sysctl, which returns the processor type (0 for 88100,
1 for 88110), for userland to have an easy way to figure out.
@
text
@d17 1
a17 1
 */
d202 1
a202 1
	CN_NORMAL
d864 1
a864 1
	cp->cn_pri = CN_NORMAL;
@


1.21
log
@replace ctob/btoc by ptoa/atop as done for other architectures
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 2007/12/19 22:05:04 miod Exp $	*/
d719 2
@


1.20
log
@Overhaul interrupt handling, in order to make it (arguably) simpler and
more board design-independent.

The main changes are:
- define logical interrupt sources, which match the on-board devices as
  well as the seven VME interrupt sources. Use these whenever possible
  when registering interrupts in the drivers, so that the actual interrupt
  mask layouts are hidden.
- make the on-board and VME interrupt handlers separate. On-board interrupt
  handlers are not really associated to an interrupt vector, only to a
  given interrupt source, and only one handler can be registered for a
  logical interrupt source. On the other hand, VME interrupts come with a
  vector number, and can be shared. This allows VME devices to really use
  the whole 256 vectors space, starting at vector zero.
- update the real interrupt masks upon interrupt handler registration and
  removal, so that only interrupt sources for which a handler exists may
  be enabled.
- update the VME interrupt allocation logic to allow exclusive vector
  allocation.
- move the Z8536 clock routines to their own file, since they are not
  AV400-specific; while there, calibrate the delay constant upon startup
  for more accurate delay().

The vme driver is the only one left with AV400 tentacles left, to be fixed
very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 2007/12/19 21:53:36 miod Exp $	*/
d258 1
a258 1
	for (i = 0; i < btoc(MSGBUFSIZE); i++)
@


1.19
log
@Use the real physical memory size for physmem, rather than what's left after
the PROM has eaten part of it, so that the reported memory size in dmesg is
a nice round number.
@
text
@d1 17
a17 1
/* $OpenBSD: machdep.c,v 1.18 2007/12/13 18:51:01 miod Exp $	*/
d84 1
d89 1
d91 1
d102 2
a127 2
intrhand_t intr_handlers[NVMEINTR];

a165 1
int cpuspeed = 20;				/* safe guess */
d169 3
d181 6
a226 5
#if 0
	/* XXX FILL ME */
	cpuspeed = getcpuspeed(&brdid);
#endif

a323 6
	 * Set up interrupt handlers.
	 */
	for (i = 0; i < NVMEINTR; i++)
		SLIST_INIT(&intr_handlers[i]);

	/*
a648 36
/*
 * Try to insert ihand in the list of handlers for vector vec.
 */
int
intr_establish(int vec, struct intrhand *ihand, const char *name)
{
	struct intrhand *intr;
	intrhand_t *list;

	if (vec < 0 || vec >= NVMEINTR) {
#ifdef DIAGNOSTIC
		printf("intr_establish: vec (0x%x) not between 0x00 and 0xff\n",
		      vec);
#endif /* DIAGNOSTIC */
		return (EINVAL);
	}

	list = &intr_handlers[vec];
	if (!SLIST_EMPTY(list)) {
		intr = SLIST_FIRST(list);
		if (intr->ih_ipl != ihand->ih_ipl) {
#ifdef DIAGNOSTIC
			printf("intr_establish: there are other handlers with "
			    "vec (0x%x) at ipl %x, but you want it at %x\n",
			    vec, intr->ih_ipl, ihand->ih_ipl);
#endif /* DIAGNOSTIC */
			return (EINVAL);
		}
	}

	evcount_attach(&ihand->ih_count, name, (void *)&ihand->ih_ipl,
	    &evcount_intr);
	SLIST_INSERT_HEAD(list, ihand, ih_link);
	return (0);
}

d906 38
@


1.18
log
@Sync with the mvme188 codebase, various tweaks from the last 18 months which
had not been reported to aviion.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.17 2007/11/17 05:36:21 miod Exp $	*/
a811 1
	physmem = btoc(last_addr);
@


1.17
log
@Replace many ``unsigned'' variables with ``unsigned int'', ``u_int'' or other
appropriate types. No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.16 2007/11/17 05:32:04 miod Exp $	*/
d79 3
d247 2
a248 1
	printf("real mem  = %d\n", ctob(physmem));
d293 2
a294 1
	printf("avail mem = %ld (%d pages)\n", ptoa(uvmexp.free), uvmexp.free);
d436 1
a436 1
	cpu_kcore_hdr.ram_segs[0].size = ctob(physmem);
d819 6
d914 1
a914 6
	u_int curspl, psr;

	disable_interrupt(psr);
	curspl = platform->getipl();
	set_psr(psr);
	return (int)curspl;
d920 1
a920 14
	u_int curspl, psr;

	disable_interrupt(psr);
	curspl = platform->setipl((u_int)level);

	/*
	 * The flush pipeline is required to make sure the above change gets
	 * through the data pipe and to the hardware; otherwise, the next
	 * bunch of instructions could execute at the wrong spl protection.
	 */
	flush_pipeline();

	set_psr(psr);
	return (int)curspl;
d926 1
a926 14
	u_int curspl, psr;

	disable_interrupt(psr);
	curspl = platform->raiseipl((u_int)level);

	/*
	 * The flush pipeline is required to make sure the above change gets
	 * through the data pipe and to the hardware; otherwise, the next
	 * bunch of instructions could execute at the wrong spl protection.
	 */
	flush_pipeline();

	set_psr(psr);
	return (int)curspl;
@


1.16
log
@Rework {get,set,raise}ipl() to minimize psr modification, especially on
boards such as mvme1[89]7 where spl changes can be atomic.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.15 2007/11/15 21:23:14 miod Exp $	*/
d829 1
a829 1
	pmap_bootstrap((vaddr_t)trunc_page((unsigned)&kernelstart));
@


1.15
log
@Stop referring the initial kernel stack as the ``interrupt stack''. It's
been years since it has last been used for that purpose, so name it the
initialization/startup stack.

While there, do not store the initialization stack in cpu_info, and have
secondary_pre_main() return its value so that the bootstrap code does not
need to fetch it from cpu_info.

This might be reconsidered when the startup stacks will be freed after they
are not used anymore, but there are more things to do first.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.14 2007/11/14 23:12:44 miod Exp $	*/
a98 1
u_int	getipl(void);
d900 1
a900 1
u_int
d908 1
a908 1
	return curspl;
d911 2
a912 2
u_int
setipl(u_int level)
d917 1
a917 1
	curspl = platform->setipl(level);
d927 1
a927 1
	return curspl;
d930 2
a931 2
u_int
raiseipl(u_int level)
d936 1
a936 1
	curspl = platform->raiseipl(level);
d946 1
a946 1
	return curspl;
@


1.14
log
@Merge the ci_alive and ci_primary boolean values of struct cpu_info into
a single ci_flags bitfield.

Also, set_cpu_number() will no longer set CIF_PRIMARY on the primary processor,
it's up to the initialization code to do this.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.13 2007/11/06 21:42:55 miod Exp $	*/
d103 1
a103 1
void	secondary_pre_main(void);
d567 1
a567 1
 * Determine CPU number and set it, then allocate the idle pcb (and stack).
d571 1
a571 1
void
d590 2
a591 2
	ci->ci_init_stack = uvm_km_zalloc(kernel_map, USPACE);
	if (ci->ci_init_stack == (vaddr_t)NULL) {
d596 2
d603 1
a603 1
 * We are now running on our idle stack, with proper page tables.
@


1.13
log
@Remove the now unused idle_u, and call the secondary processors startup
stack a startup stack.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.12 2007/10/13 12:55:20 miod Exp $	*/
d811 1
@


1.12
log
@Enable interrupts in secondary processors before invoking cpu_switchto(),
rather the expecting it to do this for us.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.11 2007/10/10 15:53:51 art Exp $	*/
d588 1
a588 1
	 * Allocate UPAGES contiguous pages for the idle PCB and stack.
d590 5
a594 3
	ci->ci_idle_pcb = (struct pcb *)uvm_km_zalloc(kernel_map, USPACE);
	if (ci->ci_idle_pcb == NULL) {
		printf("cpu%d: unable to allocate idle stack\n", ci->ci_cpuid);
@


1.11
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.10 2007/06/06 17:15:11 deraadt Exp $	*/
d615 3
@


1.10
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.9 2007/05/29 20:36:47 deraadt Exp $	*/
a227 2
	vsize_t size;
	int base, residual;
d606 1
d609 1
d616 2
a617 5
	/*
	 * Upon return, the secondary cpu bootstrap code in locore will
	 * enter the idle loop, waiting for some food to process on this
	 * processor.
	 */
@


1.9
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.8 2007/05/27 17:31:55 miod Exp $	*/
d461 1
a461 1
	daddr_t blkno;		/* current block to write */
d463 1
a463 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
@


1.8
log
@Make sure the minaddr hint for uvm_km_suballoc() calls is always initialized.
ok pedro@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.7 2007/05/26 20:26:50 pedro Exp $	*/
d420 1
a420 1
dumpconf()
a422 1
	int maj;
d424 2
a425 1
	if (dumpdev == NODEV)
a426 6
	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdevsw[maj].d_psize == NULL)
		return;
	nblks = (*bdevsw[maj].d_psize)(dumpdev);
@


1.7
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.6 2007/05/12 20:03:22 miod Exp $	*/
d282 1
@


1.6
log
@Increment ncpus when hatching a secondary processor.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.5 2006/05/21 12:22:01 miod Exp $	*/
a118 6
#ifdef	NBUF
int nbuf = NBUF;
#else
int nbuf = 0;
#endif

d266 2
a267 2
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
d269 2
a270 13
	size = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
	    NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE,
	      UVM_PROT_NONE, UVM_INH_NONE, UVM_ADV_NORMAL, 0)))
		panic("cpu_startup: cannot allocate VM for buffers");
	minaddr = (vaddr_t)buffers;

	if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
		/* don't want to alloc more physical mem than needed */
		bufpages = btoc(MAXBSIZE) * nbuf;
	}
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
d272 5
a276 26
	for (i = 0; i < nbuf; i++) {
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;

		/*
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vaddr_t)buffers + (i * MAXBSIZE);
		curbufsize = PAGE_SIZE * ((i < residual) ? (base + 1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for "
				      "buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ | VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
	}
	pmap_update(pmap_kernel());
a291 2
	printf("using %d buffers containing %d bytes of memory\n", nbuf,
	    bufpages * PAGE_SIZE);
a338 28

	/*
	 * Determine how many buffers to allocate.  We use 10% of the
	 * first 2MB of memory, and 5% of the rest, with a minimum of 16
	 * buffers.  We allocate 1/2 as many swap buffer headers as file
	 * i/o buffers.
	 */
	if (bufpages == 0) {
		bufpages = (btoc(2 * 1024 * 1024) + physmem) *
		    bufcachepercent / 100;
	}
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}

	/* Restrict to at most 70% filled kvm */
	if (nbuf >
	    (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	valloc(buf, struct buf, nbuf);
@


1.5
log
@Move common definitions shared by the various 88100-based designs to their
own header file, and slowly make most of the code board-independent. No
functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.4 2006/05/20 22:40:43 miod Exp $	*/
d683 1
@


1.4
log
@Let the bootloader pass esym to the kernel, and let the kernel make good use
of this if it finds out it has not been directly loaded by the PROM; not
tested yet.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.3 2006/05/20 12:04:51 miod Exp $	*/
d143 1
a143 1
extern char *esym;
d153 1
a153 1
struct board *platform;
@


1.3
log
@Introduce a ``struct board'' platform abstraction, to be able to support
more AViiON designs in the future.
Heuristics to tell designs apart in aviion_identify() are likely too weak,
but this is a start and AV400 still gets identified as AV400 (-:
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.2 2006/05/16 23:22:10 miod Exp $	*/
d867 8
a874 1
	first_addr = round_page((vaddr_t)&end);	/* XXX temp until symbols */
@


1.2
log
@Print a final line before asking the PROM to halt or reboot, for the
abruptness of its prompt almost looks like the kernel died horribly.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.1.1.1 2006/05/09 18:09:02 miod Exp $	*/
d72 1
d94 1
d96 1
a103 7
void	doboot(void);

extern void setlevel(unsigned int);

extern void av400_bootstrap(void);
extern vaddr_t av400_memsize(void);
extern void av400_startup(void);
a106 7
/* board dependent pointers */
void	(*md_interrupt_func_ptr)(u_int, struct trapframe *);
void	(*md_init_clocks)(void);
u_int	(*md_getipl)(void);
u_int	(*md_setipl)(u_int);
u_int	(*md_raiseipl)(u_int);

d152 2
d209 1
a209 1
	strlcpy(cpu_model, "AV400 or compatible", sizeof cpu_model);
d219 1
a219 1
	(*md_init_clocks)();
d269 1
a269 1
	av400_startup();	/* XXX should be a function pointer */
d825 1
a825 1
	cn_tab = &bootcons;
d828 1
a828 3
	switch (cputyp) {
#ifdef M88100
	case CPU_88100:
d830 18
a847 8
		/*
		 * Right now, we do not know how to tell 400 designs from
		 * 5000 designs...
		 */
#if 0
		if (badaddr(AV400_VIRQV, 4) != 0)
#else
		if (1)
a848 6
		{
			av400_bootstrap();
			break;
		}
#endif	/* AV400 */
#endif	/* 88100 */
d850 1
a850 1
		printf("Sorry, OpenBSD/" MACHINE
d856 5
d868 1
a868 1
	last_addr = av400_memsize();	/* XXX should be a function pointer */
d967 1
a967 1
	curspl = (*md_getipl)();
d978 1
a978 1
	curspl = (*md_setipl)(level);
d997 1
a997 1
	curspl = (*md_raiseipl)(level);
d1016 45
@


1.1
log
@Enter OpenBSD/aviion, a port to the m88k-based Data General AViiON workstations. Currently restricted to diskless serial console, tested on AV410 only; many thanks to Chris Tribo for documentation and testing.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.177 2006/04/13 21:16:18 miod Exp $	*/
d423 1
d472 1
@


1.1.1.1
log
@Oops, correct import this time.
@
text
@@
