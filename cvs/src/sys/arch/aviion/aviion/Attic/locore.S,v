head	1.22;
access;
symbols
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.17.0.4
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.16.0.4
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.11.0.8
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.10
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.6
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.3.0.6
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.4
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3
	AV400_20060509:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@# @;


1.22
date	2015.12.01.07.50.03;	author deraadt;	state dead;
branches;
next	1.21;
commitid	Rh8AZFtVMVCiwPts;

1.21
date	2015.02.25.17.41.22;	author miod;	state Exp;
branches;
next	1.20;
commitid	SPD70tGdBh1CAdeU;

1.20
date	2013.10.10.21.24.59;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2013.10.07.19.10.40;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2013.09.28.19.56.46;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2013.01.05.11.20.55;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.19.20.40.10;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2011.10.09.17.01.32;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2010.12.23.20.05.07;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.24.18.46.51;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2010.04.18.15.04.51;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.12.22.17.14.36;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.12.20.21.14.06;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2007.12.05.22.12.32;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.04.23.43.52;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2007.12.02.21.28.35;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.15.21.23.14;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.06.21.42.55;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.10.15.53.51;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.20.22.40.43;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.20.11.57.02;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.07.21.32.26;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.05.07.21.32.26;	author miod;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Send Aviion to same place as Nova II
discussed with jsg
@
text
@/*	$OpenBSD: locore.S,v 1.21 2015/02/25 17:41:22 miod Exp $	*/
/*
 * Copyright (c) 2005, Miodrag Vallat.
 * Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include "assym.h"
#include "ksyms.h"

#include <machine/asm.h>
#include <machine/m88100.h>
#include <machine/param.h>
#include <machine/psl.h>
#include <machine/trap.h>
#include <machine/vmparam.h>

#define	BOOT_MAGIC	0x6274ef2e

	.text

GLOBAL(kernelstart)
GLOBAL(kernel_text)
ASGLOBAL(__start)
	/*
	 * A few identical jump instructions to make sure the pipeline is
	 * in a good state. Probably overkill, but it's cheap.
	 */
	br	_ASM_LABEL(main_start)
	br	_ASM_LABEL(main_start)
	br	_ASM_LABEL(main_start)
	br	_ASM_LABEL(main_start)

	/*
	 * Room for the kernel VBR page.
	 * Note this page is in kernel text, in order to be write-protected
	 * by pmap_bootstrap().
	 */
	.balign	PAGE_SIZE

#ifdef M88100
	/*
	 * The 88100 may execute the first instruction of the next trap
	 * handler, as documented in its Errata. Processing trap #511
	 * would then fall into the next page, unless the address computation
	 * wraps, or software traps are exempt from the issue - the Errata
	 * does not provide more detail.
	 * Although the MVME BUG does not add an extra NOP after its VBR page,
	 * it is cheap to add an extra NOP for safety.
	 */
	NOP
#endif

	/*
	 * Startup code for main processor.
	 */
ASLOCAL(main_start)
	/*
	 * Save the arguments passed by the PROM
	 * 	%r2 boot string
	 *	%r3 boot device
	 *	%r4 boot unit number
	 *	%r5 boot partition number
	 *	%r6 magic number if not loaded by the PROM
	 *	%r7 end of loaded binary if not loaded by the PROM
	 */
	or.u	%r13, %r0,  %hi16(_C_LABEL(prom_bootargs))
	st	%r2,  %r13, %lo16(_C_LABEL(prom_bootargs))
	or.u	%r13, %r0,  %hi16(_C_LABEL(bootdev))
	st	%r3,  %r13, %lo16(_C_LABEL(bootdev))
	or.u	%r13, %r0,  %hi16(_C_LABEL(bootunit))
	st	%r4,  %r13, %lo16(_C_LABEL(bootunit))
	or.u	%r13, %r0,  %hi16(_C_LABEL(bootlun))
	st	%r5,  %r13, %lo16(_C_LABEL(bootlun))

	or.u	%r12, %r0,  %hi16(BOOT_MAGIC)
	or	%r12, %r12, %lo16(BOOT_MAGIC)
	cmp	%r2,  %r6,  %r12
	bb1	eq,   %r2,  1f
	addu	%r12, %r12, 1		/* BOOT_MAGIC + 1 */
	cmp	%r2,  %r6,  %r12
	bb1	ne,   %r2,  2f

	/* BOOT_MAGIC + 1 */
	or.u	%r13, %r0,  %hi16(_C_LABEL(bootpart))
	st	%r7,  %r13, %lo16(_C_LABEL(bootpart))
#if defined(DDB) || NKSYMS > 0
	or.u	%r13, %r0,  %hi16(_C_LABEL(esym))
	st	%r8,  %r13, %lo16(_C_LABEL(esym))
#endif
	br	2f

	/* BOOT_MAGIC */
1:
#if defined(DDB) || NKSYMS > 0
	or.u	%r13, %r0,  %hi16(_C_LABEL(esym))
	st	%r7,  %r13, %lo16(_C_LABEL(esym))
#endif

2:
	/* set cputyp */
	ldcr	%r1,  PID
	extu	%r8,  %r1,  8<8>

	or.u	%r13, %r0,  %hi16(_C_LABEL(cputyp))
	bsr.n	_ASM_LABEL(setup_psr)
	 st	%r8,  %r13, %lo16(_C_LABEL(cputyp))

	/* save PROM vbr */
	ldcr	%r12, VBR
	or.u	%r13, %r0,  %hi16(_C_LABEL(prom_vbr))
	st	%r12, %r13, %lo16(_C_LABEL(prom_vbr))

	/*
	 * Have curcpu() point at the dummy cpuinfo structure,
	 * and initialize cr17.
	 * This is necessary for early spl*() usage, as well as
	 * mutex diagnostic code.
	 */
	or.u	%r11, %r0,  %hi16(_ASM_LABEL(dummy_cpu))
	or	%r11, %r11, %lo16(_ASM_LABEL(dummy_cpu))
	stcr	%r11, CPU

#ifdef MULTIPROCESSOR
	/*
	 * SCM PROM idles all secondary MPUs upon startup, so at this point
	 * we do not have to compete with them.
	 */
#endif	/* MULTIPROCESSOR */

	/* Switch to startup stack */
	or.u	%r31, %r0,  %hi16(_ASM_LABEL(initstack_end))
	or	%r31, %r31, %lo16(_ASM_LABEL(initstack_end))

#ifdef M88110
#ifdef M88100
	cmp	%r2, %r8, CPU_88110
	bb1	ne,  %r2, 1f	/* if it's a 'mc88110, use different vectors */
#endif
	or.u	%r3, %r0, %hi16(_C_LABEL(m88110_vector_list))
	br.n	2f
	 or	%r3, %r3, %lo16(_C_LABEL(m88110_vector_list))
1:
#endif /* M88110 */
#ifdef M88100
	or.u	%r3, %r0, %hi16(_C_LABEL(vector_list))
	or	%r3, %r3, %lo16(_C_LABEL(vector_list))
#endif /* M88100 */
2:
	or	%r4, %r0, 1
	or.u	%r2, %r0, %hi16(_ASM_LABEL(__start))
	bsr.n	_C_LABEL(vector_init)
	 or	%r2, %r2, %lo16(_ASM_LABEL(__start))
	stcr	%r2, VBR
	FLUSH_PIPELINE

	or.u	%r3, %r0, %hi16(_C_LABEL(kernel_vbr))
	st	%r2, %r3, %lo16(_C_LABEL(kernel_vbr))

#ifdef MULTIPROCESSOR
	bsr	_C_LABEL(atomic_init)
#endif

	/*
	 * aviion_bootstrap(), among other things, clears proc0's u area.
	 * We are still using the interrupt stack here, thus we are not
	 * affected...
	 */
	bsr	_C_LABEL(aviion_bootstrap)

	/*
	 * ...and we can switch to the u area stack now.
	 */
	ldcr	%r10, CPU
	ld	%r31, %r10, CI_CURPCB

	/* call main() - no arguments although main() still defines one */
	bsr.n	_C_LABEL(main)
	 addu	%r31, %r31, USPACE

#ifdef MULTIPROCESSOR

	/*
	 * Startup code for secondary processors.
	 * Some of these initializations are very close to main_start; refer
	 * to the comments there for details.
	 */
GLOBAL(secondary_start)
	/*
	 * We have been started early, but there is nothing we can do yet.
	 * We'll just spin until we can get the hatching mutex.
	 */
	or.u	%r11, %r0,  %hi16(_C_LABEL(cpu_hatch_mutex))
	or	%r11, %r11, %lo16(_C_LABEL(cpu_hatch_mutex))
1:
	or	%r22, %r0,  1
	xmem	%r22, %r11, %r0	/* if %r22 becomes zero, we own the lock... */
	bcnd	eq0,  %r22, 4f	/* ... but if not, we must wait */
2:
	/* just watch the lock until it clears */
	ld	%r22, %r11, %r0
	bcnd	eq0,  %r22, 1b
	/* wait a bit to avoid overloading the bus */
	or.u	%r2,  %r0,  100
3:
	subu	%r2,  %r2,  1
	bcnd	ne0,  %r2,  3b
	br	2b
4:

	/*
	 * We are now running free with cpu_hatch_mutex held; other
	 * secondary processors (if any) are waiting for the lock,
	 * and the main processor is waiting for us to decrease the
	 * hatch counter, which we'll do later in secondary_main().
	 */

	or.u	%r31, %r0,  %hi16(_ASM_LABEL(slavestack_end))
	bsr.n	_ASM_LABEL(setup_psr)
	 or	%r31, %r31, %lo16(_ASM_LABEL(slavestack_end))

	or.u	%r3,  %r0,  %hi16(_C_LABEL(kernel_vbr))
	ld	%r2,  %r3,  %lo16(_C_LABEL(kernel_vbr))
	stcr	%r2,  VBR
	FLUSH_PIPELINE

	/*
	 * Have curcpu() point at the dummy cpuinfo structure,
	 * and initialize cr17.
	 * This is necessary for early spl*() usage, as well as
	 * mutex diagnostic code.
	 */
	or.u	%r11, %r0,  %hi16(_ASM_LABEL(dummy_cpu))
	or	%r11, %r11, %lo16(_ASM_LABEL(dummy_cpu))
	st	%r0,  %r11, CI_FLAGS			/* reset CIF_PRIMARY */
	stcr	%r11, CPU

	/*
	 * While holding the cpu_mutex, the secondary cpu can use the
	 * slavestack to call secondary_pre_main() to determine its cpu
	 * number. That function will also return the proper stack to
	 * use and we'll switch to it.
	 */

	bsr	_C_LABEL(secondary_pre_main)	/* set cpu number */

	bsr.n	_C_LABEL(secondary_main)
	 addu	%r31, %r2, USPACE		/* switch to idle stack */

	/*
	 * Dummy mp_atomic_begin() and mp_atomic_end() routine, so that
	 * we can interact with ddb if things go wrong very early during
	 * bootstrap. Of course this should never happen (-:
	 */
ASLOCAL(dummy_mplock)
	jmp	%r1

#endif	/* MULTIPROCESSOR */

/* 
 * void delay(int us)
 *
 * The processor loops (busy waits) for the given number of microseconds:
 * Thus, delay(1000000) will delay for one second.
 * (originally from Mach 2.5) 
 */
GLOBAL(delay)
	bcnd	eq0, %r2, 2f
	or.u	%r3, %r0, %hi16(_C_LABEL(aviion_delay_const))
	ld	%r3, %r3, %lo16(_C_LABEL(aviion_delay_const))
	mul	%r4, %r2, %r3
	subu	%r4, %r4, 4	/* overhead of these instructions */

	/* now loop for the given number of cycles */
1: 
	bcnd.n	gt0, %r4, 1b
	 subu	%r4, %r4, 2	/* two cycles per iteration */
2:
	jmp	%r1

/*
 * Switch to a 1:1 mapped stack at shutdown/reboot time.
 */
GLOBAL(bootstack)
	or.u	%r31, %r0,  %hi16(_ASM_LABEL(initstack_end))
	jmp.n	%r1
	 or	%r31, %r31, %lo16(_ASM_LABEL(initstack_end))

/*****************************************************************************/

	.data
	.balign	PAGE_SIZE
GLOBAL(kernel_sdt)		/* SDT (segment descriptor table */
	.space	0x2000		/* 8K - 4K phys, 4K virt*/

	.balign	PAGE_SIZE
ASGLOBAL(initstack)
	.space	USPACE
ASGLOBAL(initstack_end)

#ifdef MULTIPROCESSOR
	.space	PAGE_SIZE	/* 4K, small, interim stack */
ASLOCAL(slavestack_end)
#endif

/*
 * Process 0's u.
 * Should be page aligned.
 */
	.balign	PAGE_SIZE
ASLOCAL(u0)
	.space	USPACE
GLOBAL(proc0paddr)
	.word	_ASM_LABEL(u0)	/*  KVA of proc0 uarea */

/* Dummy cpuinfo structure, for cpu_number() to work early. */
ASLOCAL(dummy_cpu)
	.word	3 /* CIF_PRIMARY | CIF_ALIVE */	/* ci_alive */
	.word	0				/* ci_curproc */
	.word	0				/* ci_curpcb */
	.word	0				/* ci_curpmap */
	.word	0				/* ci_cpuid */
#ifdef MULTIPROCESSOR
	.word	_ASM_LABEL(dummy_mplock)	/* ci_mp_atomic_begin */
	.word	_ASM_LABEL(dummy_mplock)	/* ci_mp_atomic_end */
#else
	.word	0
	.word	0
#endif
	.space	CPU_INFO_SIZEOF - 7 * 4

#if defined(DDB) || NKSYMS > 0
GLOBAL(esym)
	.word 	0
#endif /* DDB || NKSYMS > 0 */
@


1.21
log
@Rework secondary processor initialization, in order to allocate their idle
stack from the main processor, instead of from the secondary processors
themselves. This used to work until recent churn in uvm require the kernel
lock to be taken, and cpu_configure() runs with the kernel lock held by the
boot processor.

Allocating the idle stack on the secondary processors themselves was choosen
early on, because there is no easy way, from the boot processor, to know the
assocation between physical cpu number (ci_cpuid) and logical cpu number
(the order they are initialized and reported in), especially on luna88k where
there is no way to get secondary processors parked by the prom.

Regression noticed by aoyama@@. Verified to work on 2 and 4 cpu luna88k systems
and 2 cpu aviion systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.20 2013/10/10 21:24:59 miod Exp $	*/
@


1.20
log
@Better boot device detection code. Board-specific code will now return the
address of a controller only know by its SCM name and number, and the boot
device detection code will now attempt to match the controller first, and
then grandchildren of it (if the boot device is a disk or a tape).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.19 2013/10/07 19:10:40 miod Exp $	*/
d292 4
a295 4
	 * While holding the cpu_mutex, the secondary cpu can use the slavestack
	 * to call secondary_pre_main() to determine its cpu number.
	 * After that, however, it should allocate its own stack and switch
	 * to it.
a299 3
	ldcr	%r1,  CPU
	st	%r2,  %r1, CI_CURPCB	/* save stack as curpcb for traps */

d301 1
a301 1
	 addu	%r31, %r2, USPACE			/* switch to startup stack */
@


1.19
log
@Put the kernel VBR page at the beginning of the kernel text, as done on
mvme88k, to be able to unmap the page at address zero in the kernel, and have
the vbr page read-only after being initialized.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.18 2013/09/28 19:56:46 miod Exp $	*/
d71 1
a71 1
#define	SYM_MAGIC	0x6274ef2e
d126 12
d139 9
a147 1
	st	%r5,  %r13, %lo16(_C_LABEL(bootpart))
a148 4
	or.u	%r12, %r0,  %hi16(SYM_MAGIC)
	or	%r12, %r12, %lo16(SYM_MAGIC)
	cmp	%r2,  %r6,  %r12
	bb1	ne,   %r2,  1f
a150 1
1:
d153 1
@


1.18
log
@Make sure the stack is 1:1 mapped before attempting to give control back
to the PROM at halt/reboot time; this lets systems reboot again.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.17 2013/01/05 11:20:55 miod Exp $	*/
d88 20
a149 2
	stcr	%r0,  VBR
	FLUSH_PIPELINE
d188 1
d190 6
a195 1
	 ldcr	%r2, VBR
d259 3
a261 1
	stcr	%r0,  VBR	/* set Vector Base Register to 0, ALWAYS! */
@


1.17
log
@Switch m88k ports to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.16 2011/11/19 20:40:10 miod Exp $	*/
d294 8
@


1.16
log
@Make sure %cr17 points to a valid cpu_info struct before attempting to do the
first few printfs (which happen before we have figured out which exact cpu
we are running on). Found the hard way by aoyama@@ on luna88k, and we probably
have just been lucky on other platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.15 2011/10/09 17:01:32 miod Exp $	*/
d73 1
a73 1
	text
d77 1
a77 1
ASGLOBAL(start)
d93 15
a107 15
	 * 	r2 boot string
	 *	r3 boot device
	 *	r4 boot unit number
	 *	r5 boot partition number
	 *	r6 magic number if not loaded by the PROM
	 *	r7 end of loaded binary if not loaded by the PROM
	 */
	or.u	r13, r0,  hi16(_C_LABEL(prom_bootargs))
	st	r2,  r13, lo16(_C_LABEL(prom_bootargs))
	or.u	r13, r0,  hi16(_C_LABEL(bootdev))
	st	r3,  r13, lo16(_C_LABEL(bootdev))
	or.u	r13, r0,  hi16(_C_LABEL(bootunit))
	st	r4,  r13, lo16(_C_LABEL(bootunit))
	or.u	r13, r0,  hi16(_C_LABEL(bootpart))
	st	r5,  r13, lo16(_C_LABEL(bootpart))
d109 6
a114 6
	or.u	r12, r0,  hi16(SYM_MAGIC)
	or	r12, r12, lo16(SYM_MAGIC)
	cmp	r2,  r6,  r12
	bb1	ne,  r2,  1f
	or.u	r13, r0,  hi16(_C_LABEL(esym))
	st	r7,  r13, lo16(_C_LABEL(esym))
d119 2
a120 2
	ldcr	r1,  PID
	extu	r8,  r1,  8<8>
d122 1
a122 1
	or.u	r13, r0,  hi16(_C_LABEL(cputyp))
d124 1
a124 1
	 st	r8,  r13, lo16(_C_LABEL(cputyp))
d127 4
a130 4
	ldcr	r12, VBR
	or.u	r13, r0,  hi16(_C_LABEL(prom_vbr))
	st	r12, r13, lo16(_C_LABEL(prom_vbr))
	stcr	r0,  VBR
d139 3
a141 3
	or.u	r11, r0,  hi16(_ASM_LABEL(dummy_cpu))
	or	r11, r11, lo16(_ASM_LABEL(dummy_cpu))
	stcr	r11, CPU
d151 2
a152 2
	or.u	r31, r0,  hi16(_ASM_LABEL(initstack_end))
	or	r31, r31, lo16(_ASM_LABEL(initstack_end))
d156 2
a157 2
	cmp	r2, r8, CPU_88110
	bb1	ne, r2, 1f	/* if it's a 'mc88110, use different vectors */
d159 1
a159 1
	or.u	r3, r0, hi16(_C_LABEL(m88110_vector_list))
d161 1
a161 1
	 or	r3, r3, lo16(_C_LABEL(m88110_vector_list))
d165 2
a166 2
	or.u	r3, r0, hi16(_C_LABEL(vector_list))
	or	r3, r3, lo16(_C_LABEL(vector_list))
d169 1
a169 1
	or	r4, r0, 1
d171 1
a171 1
	 ldcr	r2, VBR
d187 2
a188 2
	ldcr	r10, CPU
	ld	r31, r10, CI_CURPCB
d192 1
a192 1
	 addu	r31, r31, USPACE
d206 2
a207 2
	or.u	r11, r0,  hi16(_C_LABEL(cpu_hatch_mutex))
	or	r11, r11, lo16(_C_LABEL(cpu_hatch_mutex))
d209 3
a211 3
	or	r22, r0,  1
	xmem	r22, r11, r0	/* if r22 becomes zero, we own the lock... */
	bcnd	eq0, r22, 4f	/* ... but if not, we must wait */
d214 2
a215 2
	ld	r22, r11, r0
	bcnd	eq0, r22, 1b
d217 1
a217 1
	or.u	r2,  r0,  100
d219 2
a220 2
	subu	r2,  r2,  1
	bcnd	ne0, r2,  3b
d231 1
a231 1
	or.u	r31, r0,  hi16(_ASM_LABEL(slavestack_end))
d233 1
a233 1
	 or	r31, r31, lo16(_ASM_LABEL(slavestack_end))
d235 1
a235 1
	stcr	r0,  VBR	/* set Vector Base Register to 0, ALWAYS! */
d244 4
a247 4
	or.u	r11, r0,  hi16(_ASM_LABEL(dummy_cpu))
	or	r11, r11, lo16(_ASM_LABEL(dummy_cpu))
	st	r0,  r11, CI_FLAGS			/* reset CIF_PRIMARY */
	stcr	r11, CPU
d258 2
a259 2
	ldcr	r1, CPU
	st	r2,  r1, CI_CURPCB	/* save stack as curpcb for traps */
d262 1
a262 1
	 addu	r31, r2, USPACE			/* switch to startup stack */
d270 1
a270 1
	jmp	r1
d282 5
a286 5
	bcnd	eq0, r2, 2f
	or.u	r3, r0, hi16(_C_LABEL(aviion_delay_const))
	ld	r3, r3, lo16(_C_LABEL(aviion_delay_const))
	mul	r4, r2, r3
	subu	r4, r4, 4	/* overhead of these instructions */
d290 2
a291 2
	bcnd.n	gt0, r4, 1b
	 subu	r4, r4, 2	/* two cycles per iteration */
d293 1
a293 1
	jmp	r1
d297 2
a298 2
	data
	.align	PAGE_SIZE
d300 1
a300 1
	space	0x2000		/* 8K - 4K phys, 4K virt*/
d302 1
a302 1
	.align	PAGE_SIZE
d304 1
a304 1
	space	USPACE
d308 1
a308 1
	space	PAGE_SIZE	/* 4K, small, interim stack */
d316 1
a316 1
	.align	PAGE_SIZE
d318 1
a318 1
	space	USPACE
d320 1
a320 1
	word	_ASM_LABEL(u0)	/*  KVA of proc0 uarea */
d324 5
a328 5
	word	3 /* CIF_PRIMARY | CIF_ALIVE */	/* ci_alive */
	word	0				/* ci_curproc */
	word	0				/* ci_curpcb */
	word	0				/* ci_curpmap */
	word	0				/* ci_cpuid */
d330 2
a331 2
	word	_ASM_LABEL(dummy_mplock)	/* ci_mp_atomic_begin */
	word	_ASM_LABEL(dummy_mplock)	/* ci_mp_atomic_end */
d333 2
a334 2
	word	0
	word	0
d336 1
a336 1
	space	CPU_INFO_SIZEOF - 7 * 4
d340 1
a340 1
	word 	0
@


1.15
log
@Rework secondary processor initialization. cmmu initialization is now
performed much earlier in the processor startup.
No visible change, paves the way for the much important diff three commits
from here.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.14 2010/12/23 20:05:07 miod Exp $	*/
a132 1
#ifdef MULTIPROCESSOR
d135 3
a137 3
	 * so that cpu_number() does not dereference random memory.
	 * This is necessary for early spl usage, despite the fact that
	 * interrupts are disabled...
d143 1
d240 3
a242 3
	 * so that cpu_number() does not dereference random memory.
	 * This is necessary for early spl usage, despite the fact that
	 * interrupts are disabled...
a321 1
#ifdef MULTIPROCESSOR
d329 1
d332 4
a335 1

a336 1
#endif	/* MULTIPROCESSOR */
@


1.14
log
@The exception vector page on m88k systems has always been the same page as
the one used by the firmware, which (at least on mvme88k) is at address zero.

This is unfortunate, since this means that NULL pointer dereferences in the
kernel are not caught, and writes cause havoc.

This behaviour was necessary to be able to use the PROM system call interface
during early bootstrap, without having to disassemble the VBR page and
update branches - which use pc-relative displacement - if we were to use
a different VBR address.

On mvme88k, change this and actually set up two VBR pages: one, over the PROM
page (except for the system call vectors), and another one in the kernel
image (which will be mapped read-only). We'll run with the PROM page until
the end of autoconf, and then switch to the kernel one, and unmap all the
PROM below it.

As a bonus, the final kernel page can use optimized data access fault
handlers, which do not have to check for faults caused by badaddr(), since
badaddr() is only used during device probe on buses which do not support
hotplug.

There are a few infrastructure collateral damage on aviion and luna88k, but
these ports do not change their behaviour yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.13 2010/04/24 18:46:51 miod Exp $	*/
a193 11
	or.u	r2, r0, hi16(_ASM_LABEL(main_panic))
	bsr.n	_C_LABEL(panic)
	 or	r2, r2, lo16(_ASM_LABEL(main_panic))

	data
	.align	4
ASLOCAL(main_panic)
	string	"main() returned\0"
	text
	.align	8

d213 1
a213 1
	/* just watch the lock until it looks clear */
d217 1
a217 1
	or.u	r2,  r0,  1
d226 3
a228 3
	 * secondary processors are waiting for the lock, and the main
	 * processor is waiting for us to decrease the hatch counter,
	 * which we'll do in secondary_main() later.
d246 1
@


1.13
log
@SMP support for models 4600 and 530, adapted from the MVME188 code. Models
4000 and 4300 will need more work, because they don't have as many distinct
software interrupt sources as required by this implementation, so a
different IPI scheme will be necessary.

Tested on dual-processor 4625 (AV530 family) and single processor 4300
(AV400 family).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.12 2010/04/18 15:04:51 miod Exp $	*/
d123 2
a124 3
	st	r8,  r13, lo16(_C_LABEL(cputyp))

	bsr	_ASM_LABEL(setup_psr)
d131 1
d169 1
d173 4
d243 2
a244 3
	or	r31, r31, lo16(_ASM_LABEL(slavestack_end))

	bsr	_ASM_LABEL(setup_psr)
@


1.12
log
@Fix esym computation logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.11 2007/12/22 17:14:36 miod Exp $	*/
d208 29
a255 23
	 * Since there may be more than one secondary MPU, compete with them
	 * to initialize safely.
	 */
	or.u	r11, r0,  hi16(_C_LABEL(cpu_mutex))
	or	r11, r11, lo16(_C_LABEL(cpu_mutex))
1:
	or	r22, r0,  1
	xmem	r22, r11, r0		/* If r22 gets 0, we have the lock... */
	bcnd	eq0, r22, 4f		/* ...but if not, we must wait */
2:
	/* just watch the lock until it looks clear */
	ld	r22, r11, r0
	bcnd	eq0, r22, 1b
	/* since we can be here with caches off, add a few nops to
	   keep the bus from getting overloaded */
	or	r2,  r0,  lo16(1000)
3:
	subu	r2,  r2,  1
	bcnd	ne0, r2,  3b
	br	1b
4:
	
	/*
d270 8
d334 1
d336 4
@


1.11
log
@Move initial PSR initialization to a separate routine, instead of duplicating
it five times.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.10 2007/12/20 21:14:06 miod Exp $	*/
d112 1
a112 1
	bcnd	ne0, r2,  1f
@


1.10
log
@Do not wait for the end of the universe if delay(0).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.9 2007/12/05 22:12:32 miod Exp $	*/
d125 1
a125 54
	/*
	 * CPU Initialization
	 *
	 * I use r11 and r22 here because they're easy to not
	 * get mixed up -- r10, for example, looks too similar
	 * to r0 when not being careful....
	 *
	 * Ensure that the PSR is as we like:
	 *	supervisor mode
	 *	big-endian byte ordering
	 *	concurrent operation allowed
	 *	carry bit clear (I don't think we really care about this)
	 *	FPU enabled
	 *	misaligned access raises an exception
	 *	interrupts disabled
	 *	shadow registers frozen
	 *
	 * The manual says not to disable interrupts and freeze shadowing
	 * at the same time because interrupts are not actually disabled
	 * until after the next instruction. Well, if an interrupt
	 * occurs now, we're in deep trouble anyway, so I'm going to do
	 * the two together.
	 *
	 * Upon a reset (or poweron, I guess), the PSR indicates:
	 *   supervisor mode
	 *   interrupts, shadowing, FPU, misaligned exception: all disabled
	 *
	 * We'll just construct our own turning on what we want.
	 *
	 *	jfriedl@@omron.co.jp
	 */

	cmp	r2, r8, CPU_88110	/* r8 contains cputyp */
	bb1	eq, r2, 1f	/* if it's a 'mc88110, skip SSBR */
	stcr	r0, SSBR	/* clear this for later */
1:
	stcr	r0, SR1		/* clear the CPU flags */

	set	r11, r0,  1<PSR_SUPERVISOR_MODE_BIT>
	set	r11, r11, 1<PSR_INTERRUPT_DISABLE_BIT>
	set	r11, r11, 1<PSR_GRAPHICS_DISABLE_BIT>
	/*
	 * XXX On 88110 processors, force serial instruction execution for now.
	 * Situation where OoO would break will be hopefully taken care of in
	 * the near future -- miod
	 */
#if 0
	clr	r11, r11, 1<PSR_SERIAL_MODE_BIT>
#else
	set	r11, r11, 1<PSR_SERIAL_MODE_BIT>
#endif
	set	r11, r11, 1<PSR_SERIALIZE_BIT>
	stcr	r11, PSR
	FLUSH_PIPELINE
d130 1
a130 1
	st	r12,  r13, lo16(_C_LABEL(prom_vbr))
d211 1
a211 8
	or.u	r13, r0,  hi16(_C_LABEL(cputyp))
	ld	r8,  r13, lo16(_C_LABEL(cputyp))

	cmp	r2, r8, CPU_88110
	bb1	eq, r2, 1f
	stcr	r0, SSBR
1:
	stcr	r0, SR1
a212 16
	set	r11, r0,  1<PSR_SUPERVISOR_MODE_BIT>
	set	r11, r11, 1<PSR_INTERRUPT_DISABLE_BIT>
	set	r11, r11, 1<PSR_GRAPHICS_DISABLE_BIT>
	/*
	 * XXX On 88110 processors, force serial instruction execution for now.
	 * Situation where OoO would break will be hopefully taken care of in
	 * the near future -- miod
	 */
#if 0
	clr	r11, r11, 1<PSR_SERIAL_MODE_BIT>
#else
	set	r11, r11, 1<PSR_SERIAL_MODE_BIT>
#endif
	set	r11, r11, 1<PSR_SERIALIZE_BIT>
	stcr	r11, PSR
	FLUSH_PIPELINE
@


1.9
log
@Make the CPU_88100 and CPU_88110 constants match the architectural number
field from the processor identification register; this allows .S code which
needs to decide on the cpu type at runtime to check quicker, without needing
to access memory. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.8 2007/12/04 23:43:52 miod Exp $	*/
d350 3
a352 2
	or.u	r3, r0, hi16(_cpuspeed)
	ld	r3, r3, lo16(_cpuspeed)
d360 1
a360 1

@


1.8
log
@Correctly set the stack pointer of a secondary processor to the end
of its initialization stack. Oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.7 2007/12/02 21:28:35 miod Exp $	*/
d120 3
a122 10
	extu	r2,  r1,  8<8>
	bcnd.n	eq0, r2,  1f
	 or.u	r13, r0,  hi16(_C_LABEL(cputyp))
	or.u	r8,  r0,  hi16(CPU_88110)
	br.n	2f
	 or	r8,  r8,  lo16(CPU_88110)
1:
	or.u	r8,  r0,  hi16(CPU_88100)
	or	r8,  r8,  lo16(CPU_88100)
2:
d209 1
a209 1
	cmp	r2, r8, CPU_88110 /* r8 contains cputyp */
@


1.7
log
@Do not pass UPAGES and USPACE (under the name USIZE) in assym.h, code which
needs it includes <machine/param.h> already.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.6 2007/11/15 21:23:14 miod Exp $	*/
d340 4
d345 1
a345 1
	 or	r31, r2, r0			/* switch to startup stack */
@


1.6
log
@Stop referring the initial kernel stack as the ``interrupt stack''. It's
been years since it has last been used for that purpose, so name it the
initialization/startup stack.

While there, do not store the initialization stack in cpu_info, and have
secondary_pre_main() return its value so that the bootstrap code does not
need to fetch it from cpu_info.

This might be reconsidered when the startup stacks will be freed after they
are not used anymore, but there are more things to do first.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.5 2007/11/06 21:42:55 miod Exp $	*/
d247 1
a247 1
	 addu	r31, r31, USIZE
d374 1
a374 1
	space	USIZE
d388 1
a388 1
	space	USIZE
@


1.5
log
@Remove the now unused idle_u, and call the secondary processors startup
stack a startup stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.4 2007/10/10 15:53:51 art Exp $	*/
d210 3
a212 3
	/* Switch to interrupt stack */
	or.u	r31, r0,  hi16(_ASM_LABEL(intstack_end))
	or	r31, r31, lo16(_ASM_LABEL(intstack_end))
a339 3

	ldcr	r2, CPU
	ld	r3, r2, CI_INIT_STACK
d341 1
a341 1
	 addu	r31, r3, USIZE			/* switch to startup stack */
d373 1
a373 1
ASGLOBAL(intstack)
d375 1
a375 1
ASGLOBAL(intstack_end)
d395 4
a398 4
	word	1	/* ci_alive */
	word	0	/* ci_curproc */
	word	0	/* ci_curpcb */
	word	0	/* ci_cpuid */
@


1.4
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.3 2006/05/20 22:40:43 miod Exp $	*/
d342 1
a342 1
	ld	r3, r2, CI_IDLE_PCB
d344 1
a344 1
	 addu	r31, r3, USIZE			/* switch to idle stack */
a383 8

/*
 * Main processor's idle pcb and stack.
 * Should be page aligned.
 */
	.align	PAGE_SIZE
GLOBAL(idle_u)
	space	USIZE
@


1.3
log
@Let the bootloader pass esym to the kernel, and let the kernel make good use
of this if it finds out it has not been directly loaded by the PROM; not
tested yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.2 2006/05/20 11:57:02 miod Exp $	*/
a344 8

	/*
	 * At this point, the CPU has been correctly initialized and has
	 * identified itself on the console.
	 * All it needs now is to jump to the idle loop and wait for work to
	 * be offered.
	 */
	br	_ASM_LABEL(cpu_switch_idle)
@


1.2
log
@Save the PROM VBR on startup, rather than assuming the PROM (and thus its
VBR) will always reside at the same address.
Also, when querying the PROM for the memory size, ask it for the ``user''
size - i.e. with the PROM data area taken out.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.1.1.1 2006/05/07 21:32:26 miod Exp $	*/
d71 2
a72 5
/*
 * The memory looks like:
 *   0x0000 - 0x1000	trap vectors
 *   0x1000 == start	Boot loader jumps here.
 */
d97 2
d108 9
@


1.1
log
@Enter OpenBSD/aviion, a port to the m88k-based Data General AViiON workstations. Currently restricted to diskless serial console, tested on AV410 only; many thanks to Chris Tribo for documentation and testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.46 2005/12/11 21:45:31 miod Exp $	*/
d178 5
@


1.1.1.1
log
@Oops, correct import this time.
@
text
@@
