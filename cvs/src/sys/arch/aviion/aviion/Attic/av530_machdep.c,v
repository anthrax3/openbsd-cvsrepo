head	1.17;
access;
symbols
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.8
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.6
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.4.0.2
	OPENBSD_4_8_BASE:1.4;
locks; strict;
comment	@ * @;


1.17
date	2015.12.01.07.50.03;	author deraadt;	state dead;
branches;
next	1.16;
commitid	Rh8AZFtVMVCiwPts;

1.16
date	2015.05.18.04.06.37;	author miod;	state Exp;
branches;
next	1.15;
commitid	SUgrahEkzVbDqUaz;

1.15
date	2015.04.25.21.15.08;	author miod;	state Exp;
branches;
next	1.14;
commitid	IlXCrCOwBzeeoj9x;

1.14
date	2014.12.16.21.29.05;	author miod;	state Exp;
branches;
next	1.13;
commitid	xJ0cbwFfjtIqyzUC;

1.13
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	yv0ECmCdICvq576h;

1.12
date	2013.10.23.10.07.14;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2013.10.10.21.24.58;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2013.10.09.21.28.33;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.07.19.11.39;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2013.10.07.19.09.08;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2013.02.17.18.07.36;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2011.01.02.13.40.05;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.31.21.38.07;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.24.18.46.51;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2010.04.24.18.44.25;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2010.04.21.19.33.45;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2010.04.18.22.04.37;	author miod;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Send Aviion to same place as Nova II
discussed with jsg
@
text
@/*	$OpenBSD: av530_machdep.c,v 1.16 2015/05/18 04:06:37 miod Exp $	*/
/*
 * Copyright (c) 2006, 2007, 2010 Miodrag Vallat.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/errno.h>

#include <uvm/uvm_extern.h>

#include <machine/asm_macro.h>
#include <machine/board.h>
#include <machine/bus.h>
#include <machine/cmmu.h>
#include <machine/cpu.h>
#include <machine/pmap_table.h>
#include <machine/trap.h>

#include <machine/m88100.h>
#include <machine/m8820x.h>
#include <machine/avcommon.h>
#include <machine/av530.h>
#include <machine/prom.h>

#include <aviion/dev/sysconvar.h>
#include <aviion/dev/vmevar.h>

#ifdef MULTIPROCESSOR
#include <machine/db_machdep.h>
#endif

u_int	av530_safe_level(u_int, u_int, u_int);
void	av530_clock_ipi_handler(struct trapframe *);
void	av530_ipi_handler(struct trapframe *);

const struct pmap_table
av530_ptable[] = {
	{ AV530_PROM,	AV530_PROM_SIZE,	PROT_READ | PROT_WRITE, CACHE_INH },
#if 0	/* mapped by the hardcoded BATC entries */
	{ AV530_UTILITY,AV530_UTILITY_SIZE,	PROT_READ | PROT_WRITE, CACHE_INH },
#endif
	{ 0, (vsize_t)-1, 0, 0 }
};

const struct vme_range vme_av530[] = {
	{ VME_A16,
	  AV530_VME16_START,	AV530_VME16_END,	AV530_VME16_BASE },
	{ VME_A24,
	  AV530_VME24_START,	AV530_VME24_END,	AV530_VME24_BASE },
	{ VME_A32,
	  AV530_VME32_START1,	AV530_VME32_END1,	AV530_VME32_BASE },
	{ VME_A32,
	  AV530_VME32_START2,	AV530_VME32_END2,	AV530_VME32_BASE },
	{ 0 }
};

const struct board board_av530 = {
	av530_bootstrap,
	av530_memsize,
	av530_startup,
	av530_get_boot_device,
	av530_intr,
	rtc_init_clocks,
	av530_getipl,
	av530_setipl,
	av530_raiseipl,
#ifdef MULTIPROCESSOR
	av530_send_ipi,
	m88100_smp_setup,
#endif
	av530_intsrc,
	av530_exintsrc,
	av530_get_vme_ranges,

	av530_ptable
};

/*
 * The AViiON 530 machines have two interrupt arbiter for 32 orthognal
 * interrupt sources each.
 * We fold this model in the 8-level spl model this port uses, enforcing
 * priorities manually with the interrupt masks.
 */

/*
 * Copy of the interrupt enable registers for each CPU.
 */
u_int32_t av530_int_mask_reg[] = { 0, 0, 0, 0 };
u_int32_t av530_ext_int_mask_reg[] = { 0, 0, 0, 0 };

u_int av530_curspl[] = { IPL_HIGH, IPL_HIGH, IPL_HIGH, IPL_HIGH };

#ifdef MULTIPROCESSOR
/*
 * Interrupts allowed on secondary processors.
 */
#define	SLAVE_MASK	0
#define	SLAVE_EXMASK	0
#endif

/*
 * Figure out how much memory is available, by asking the PROM.
 */
vaddr_t
av530_memsize()
{
	vaddr_t memsize0, memsize1;

	memsize0 = scm_memsize(0);
	memsize1 = scm_memsize(1);

	/*
	 * What we got is the ``top of memory'', i.e. the largest addressable
	 * word address, ending in 0xffc. Round up to a multiple of a page.
	 */
	memsize0 = round_page(memsize0);
	memsize1 = round_page(memsize1);

	physmem = atop(memsize0);
	return (memsize1);
}

void
av530_startup()
{
}

u_int
av530_bootstrap()
{
	extern const struct cmmu_p cmmu8820x;
	uint32_t whoami;

	/*
	 * Set up CMMU addresses. We need to access the WHOAMI register
	 * early since addresses differ between the 6:1 and 2:1 designs.
	 */
	cmmu = &cmmu8820x;
	whoami = (*(volatile u_int32_t *)AV_WHOAMI & 0xf0) >> 4;
	switch (whoami) {
	default:	/* 2:1 systems */
		m8820x_cmmu[0].cmmu_regs = (void *)AV530_CMMU_I0;
		m8820x_cmmu[1].cmmu_regs = (void *)AV530_CMMU_D0;
		m8820x_cmmu[2].cmmu_regs = (void *)AV530_CMMU_I1;
		m8820x_cmmu[3].cmmu_regs = (void *)AV530_CMMU_D1;
		break;
	case 3:
	case 7:		/* 6:1 systems */
		m8820x_cmmu[0].cmmu_regs = (void *)AV530_CMMU6_I0;
		m8820x_cmmu[1].cmmu_regs = (void *)AV530_CMMU6_D0;
		m8820x_cmmu[2].cmmu_regs = (void *)AV530_CMMU6_I1;
		m8820x_cmmu[3].cmmu_regs = (void *)AV530_CMMU6_D1;
		m8820x_cmmu[4].cmmu_regs = (void *)AV530_CMMU6_I2;
		m8820x_cmmu[6].cmmu_regs = (void *)AV530_CMMU6_I3;

		m8820x_cmmu[8].cmmu_regs = (void *)AV530_CMMU6_I4;
		m8820x_cmmu[9].cmmu_regs = (void *)AV530_CMMU6_D2;
		m8820x_cmmu[10].cmmu_regs = (void *)AV530_CMMU6_I5;
		m8820x_cmmu[11].cmmu_regs = (void *)AV530_CMMU6_D3;
		m8820x_cmmu[12].cmmu_regs = (void *)AV530_CMMU6_I6;
		m8820x_cmmu[14].cmmu_regs = (void *)AV530_CMMU6_I7;
		break;
	}

	/* clear and disable all interrupts */
	*(volatile u_int32_t *)AV_IENALL = 0;
	*(volatile u_int32_t *)AV_EXIENALL = 0;

	/*
	 * Return the delay const value to use (which matches the CPU speed).
	 */
	return 33;
}

/*
 * Return the address of the boot device, providing the default boot device
 * if none is requested.
 */
paddr_t
av530_get_boot_device(uint32_t *name, u_int unit)
{
	/* default boot device is on-board ncsc() */
	if (*name == 0)
		*name = SCM_NCSC;

	switch (*name) {
	case SCM_DGEN:
		switch (unit) {
		case 0:
			return AV530_LAN1;
		case 1:
			return AV530_LAN2;
		}
		break;
	case SCM_NCSC:
		switch (unit) {
		case 0:
			return AV530_SCSI1;
		case 1:
			return AV530_SCSI2;
		}
		break;
	}

	return 0;
}

/*
 * Return the next ipl >= ``curlevel'' at which we can reenable interrupts
 * while keeping ``mask'' and ``exmask'' masked.
 */
u_int
av530_safe_level(u_int mask, u_int exmask, u_int curlevel)
{
	int i;

#ifdef MULTIPROCESSOR
	if (mask & AV530_CLOCK_IPI_MASK)
		curlevel = max(IPL_CLOCK, curlevel);
	mask &= ~(AV530_IPI_MASK | AV530_CLOCK_IPI_MASK);
#endif
	for (i = curlevel; i < NIPLS; i++)
		if ((int_mask_val[i] & mask) == 0 &&
		    (ext_int_mask_val[i] & exmask) == 0)
			return i;

	return (NIPLS - 1);
}

u_int
av530_getipl(void)
{
	return av530_curspl[cpu_number()];
}

u_int
av530_setipl(u_int level)
{
	u_int32_t mask, exmask, curspl, psr;
	u_int cpu = cpu_number();

	psr = get_psr();
	set_psr(psr | PSR_IND);
	curspl = av530_curspl[cpu];

	mask = int_mask_val[level];
	exmask = ext_int_mask_val[level];
#ifdef MULTIPROCESSOR
	if (cpu != master_cpu) {
		mask &= SLAVE_MASK;
		exmask &= SLAVE_EXMASK;
	}
	mask |= AV530_SWI_IPI_MASK(cpu);
	if (level < IPL_CLOCK)
		mask |= AV530_SWI_CLOCK_IPI_MASK(cpu);
#endif

	av530_curspl[cpu] = level;
	*(u_int32_t *)AV_IEN(cpu) = av530_int_mask_reg[cpu] = mask;
	*(u_int32_t *)AV_EXIEN(cpu) = av530_ext_int_mask_reg[cpu] = exmask;
	/*
	 * We do not flush the pipeline here, because interrupts are disabled,
	 * and set_psr() will synchronize the pipeline.
	 */
	set_psr(psr);

	return curspl;
}

u_int
av530_raiseipl(u_int level)
{
	u_int32_t mask, exmask, curspl, psr;
	u_int cpu = cpu_number();

	psr = get_psr();
	set_psr(psr | PSR_IND);
	curspl = av530_curspl[cpu];
	if (curspl < level) {
		mask = int_mask_val[level];
		exmask = ext_int_mask_val[level];
#ifdef MULTIPROCESSOR
		if (cpu != master_cpu) {
			mask &= SLAVE_MASK;
			exmask &= SLAVE_EXMASK;
		}
		mask |= AV530_SWI_IPI_MASK(cpu);
		if (level < IPL_CLOCK)
			mask |= AV530_SWI_CLOCK_IPI_MASK(cpu);
#endif

		av530_curspl[cpu] = level;
		*(u_int32_t *)AV_IEN(cpu) = av530_int_mask_reg[cpu] = mask;
		*(u_int32_t *)AV_EXIEN(cpu) =
		    av530_ext_int_mask_reg[cpu] = exmask;
	}
	/*
	 * We do not flush the pipeline here, because interrupts are disabled,
	 * and set_psr() will synchronize the pipeline.
	 */
	set_psr(psr);

	return curspl;
}

#ifdef MULTIPROCESSOR

void
av530_send_ipi(int ipi, cpuid_t cpu)
{
	struct cpu_info *ci = &m88k_cpus[cpu];
	uint32_t bits = 0;

	if (ci->ci_ipi & ipi)
		return;

	atomic_setbits_int(&ci->ci_ipi, ipi);
	if (ipi & ~(CI_IPI_HARDCLOCK | CI_IPI_STATCLOCK))
		bits |= AV530_SWI_IPI_BIT(cpu);
	if (ipi & (CI_IPI_HARDCLOCK | CI_IPI_STATCLOCK))
		bits |= AV530_SWI_CLOCK_IPI_BIT(cpu);
	*(volatile u_int32_t *)AV530_SETSWI = bits;
}

/*
 * Process inter-processor interrupts.
 */

/*
 * Unmaskable IPIs - those are processed with interrupts disabled,
 * and no lock held.
 */
void
av530_ipi_handler(struct trapframe *eframe)
{
	struct cpu_info *ci = curcpu();
	int ipi = ci->ci_ipi & (CI_IPI_DDB | CI_IPI_NOTIFY);

	*(volatile u_int32_t *)AV530_CLRSWI = AV530_SWI_IPI_BIT(ci->ci_cpuid);
	atomic_clearbits_int(&ci->ci_ipi, ipi);

	if (ipi & CI_IPI_DDB) {
#ifdef DDB
		/*
		 * Another processor has entered DDB. Spin on the ddb lock
		 * until it is done.
		 */
		extern struct __mp_lock ddb_mp_lock;

		__mp_lock(&ddb_mp_lock);
		__mp_unlock(&ddb_mp_lock);

		/*
		 * If ddb is hoping to us, it's our turn to enter ddb now.
		 */
		if (ci->ci_cpuid == ddb_mp_nextcpu)
			Debugger();
#endif
	}
	if (ipi & CI_IPI_NOTIFY) {
		/* nothing to do */
	}
}

/*
 * Maskable IPIs
 */
void
av530_clock_ipi_handler(struct trapframe *eframe)
{
	struct cpu_info *ci = curcpu();
	int ipi = ci->ci_ipi & (CI_IPI_HARDCLOCK | CI_IPI_STATCLOCK);

	/* clear clock ipi interrupt */
	*(volatile u_int32_t *)AV530_CLRSWI =
	    AV530_SWI_CLOCK_IPI_BIT(ci->ci_cpuid);
	atomic_clearbits_int(&ci->ci_ipi, ipi);

	if (ipi & CI_IPI_HARDCLOCK)
		hardclock((struct clockframe *)eframe);
#if 0	/* no separate statclock yet */
	if (ipi & CI_IPI_STATCLOCK)
		statclock((struct clockframe *)eframe);
#endif
}

#endif

/*
 * Provide the interrupt masks for a given logical interrupt source.
 */
u_int32_t
av530_intsrc(int i)
{
	static const u_int32_t intsrc[] = {
		0,
		AV530_IRQ_ABORT,
		AV530_IRQ_ACF,
		AV530_IRQ_SF,
		0,
		AV530_IRQ_DI,
		0,
		0,
		0,
		0,
		0,
		0,
		AV530_IRQ_VME1,
		AV530_IRQ_VME2,
		AV530_IRQ_VME3,
		AV530_IRQ_VME4,
		AV530_IRQ_VME5,
		AV530_IRQ_VME6,
		AV530_IRQ_VME7
	};

	return intsrc[i];
}

u_int32_t
av530_exintsrc(int i)
{
	static const u_int32_t exintsrc[] = {
		0,
		0,
		0,
		0,
		AV530_EXIRQ_PIT0OF,
		0,
		AV530_EXIRQ_DUART2,
		AV530_EXIRQ_LAN0,
		AV530_EXIRQ_LAN1,
		AV530_EXIRQ_SCSI0,
		AV530_EXIRQ_SCSI1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
	};

	return exintsrc[i];
}

/*
 * Provide the interrupt source for a given interrupt status bit.
 */
static const u_int av530_obio_vec[32] = {
	0,			/* SWI0 */
	0,			/* SWI1 */
	0,			/* SWI2 */
	0,			/* SWI3 */
	INTSRC_VME(1),		/* VME1 */
	0,
	INTSRC_VME(2),		/* VME2 */
	0,			/* SIGLPI */
	0,			/* LMI */
	0,
	INTSRC_VME(3),		/* VME3 */
	0,
	INTSRC_VME(4),		/* VME4 */
	0,
	INTSRC_VME(5),		/* VME5 */
	0,
	0,			/* HPI */
	INTSRC_DUART1,		/* DI */
	0,			/* MEM */
	INTSRC_VME(6),		/* VME6 */
	INTSRC_SYSFAIL,		/* SF */
	0,
	0,			/* KBD */
	INTSRC_VME(7),		/* VME7 */
	0,			/* SWI4 */
	0,			/* SWI5 */
	0,			/* SWI6 */
	0,			/* SWI7 */
	0,			/* DTI */
	0,			/* ARBTO */
	INTSRC_ACFAIL,		/* ACF */
	INTSRC_ABORT		/* ABORT */
};
static const u_int av530_obio_exvec[32] = {
	0,
	0,
	0,
	0,
	0,
	0,			/* PDMA */
	0,			/* IOEXP2 */
	0,
	0,			/* IOEXP1 */
	0,
	0,
	0,
	0,			/* VDMA */
	INTSRC_DUART2,		/* DUART2 */
	0,			/* ZBUF */
	0,			/* VIDEO */
	INTSRC_SCSI2,		/* SCSI1 */
	INTSRC_SCSI1,		/* SCSI0 */
	INTSRC_ETHERNET2,	/* LAN1 */
	INTSRC_ETHERNET1,	/* LAN0 */
	0,			/* SCC */
	0,			/* DMA0C */
	0,			/* DMA1C */
	0,			/* DMA2C */
	0,			/* DMA3C */
	0,			/* DMA4C */
	0,
	INTSRC_CLOCK,		/* PIT0OF */
	0,			/* PIT1OF */
	0,			/* PIT2OF */
	0,			/* PIT3OF */
	0			/* RTCOF */
};

/*
 * Device interrupt handler for AV530
 */

#define VME_VECTOR_MASK		0x1ff 	/* mask into VIACK register */
#define VME_BERR_MASK		0x100 	/* timeout during VME IACK cycle */

#define ISR_GET_CURRENT_MASK(cpu) \
	(*(volatile u_int *)AV_IST & av530_int_mask_reg[cpu])
#define EXISR_GET_CURRENT_MASK(cpu) \
	(*(volatile u_int *)AV_EXIST & av530_ext_int_mask_reg[cpu])

void
av530_intr(struct trapframe *eframe)
{
	int cpu = cpu_number();
	u_int32_t cur_mask, ign_mask;
	u_int32_t cur_exmask, ign_exmask;
	u_int level, old_spl;
	struct intrhand *intr;
	intrhand_t *list;
	int ret, intbit;
	vaddr_t ivec;
	u_int intsrc, vec;
	int unmasked = 0;
	int warn;
#ifdef DIAGNOSTIC
	static int problems = 0;
#endif

	cur_mask = ISR_GET_CURRENT_MASK(cpu);
	cur_exmask = EXISR_GET_CURRENT_MASK(cpu);
	ign_mask = 0;
	ign_exmask = 0;
	old_spl = eframe->tf_mask;

	if (cur_mask == 0 && cur_exmask == 0) {
		/*
		 * Spurious interrupts - may be caused by debug output clearing
		 * DUART interrupts.
		 */
#ifdef MULTIPROCESSOR
		if (cpu != master_cpu) {
			if (++problems >= 10) {
				printf("cpu%d: interrupt pin won't clear, "
				    "disabling processor\n", cpu);
				cpu_emergency_disable();
				/* NOTREACHED */
			}
		}
#endif
		flush_pipeline();
		goto out;
	}

	uvmexp.intrs++;

#ifdef MULTIPROCESSOR
	/*
	 * Handle unmaskable IPIs immediately, so that we can reenable
	 * interrupts before further processing. We rely on the interrupt
	 * mask to make sure that if we get an IPI, it's really for us
	 * and no other processor.
	 */
	if (cur_mask & AV530_IPI_MASK) {
		av530_ipi_handler(eframe);
		cur_mask &= ~AV530_IPI_MASK;
		if (cur_mask == 0 && cur_exmask == 0)
			goto out;
	}
#endif

	/*
	 * We want to service all interrupts marked in the IST register
	 * They are all valid because the mask would have prevented them
	 * from being generated otherwise.  We will service them in order of
	 * priority.
	 */
	for (;;) {
		cur_mask = ISR_GET_CURRENT_MASK(cpu);
#ifdef MULTIPROCESSOR
		cur_mask &= ~AV530_IPI_MASK;
#endif
		cur_exmask = EXISR_GET_CURRENT_MASK(cpu);
		if ((cur_mask & ~ign_mask) == 0 &&
		    (cur_exmask & ~ign_exmask) == 0)
			break;

		level = av530_safe_level(cur_mask, cur_exmask, old_spl);
		av530_setipl(level);

		if (unmasked == 0) {
			set_psr(get_psr() & ~PSR_IND);
			unmasked = 1;
		}

#ifdef MULTIPROCESSOR
		/*
		 * Handle pending maskable IPIs first.
		 */
		if (cur_mask & AV530_CLOCK_IPI_MASK) {
			av530_clock_ipi_handler(eframe);
			cur_mask &= ~AV530_CLOCK_IPI_MASK;
			if ((cur_mask & ~ign_mask) == 0 &&
			    (cur_exmask & ~ign_exmask) == 0)
				break;
		}
#endif

		/* find the first bit set in the current mask */
		warn = 0;
		if (cur_mask != 0) {
			intbit = ff1(cur_mask);
			intsrc = av530_obio_vec[intbit];

			if (intsrc == 0)
				panic("%s: unexpected interrupt source"
				    " (bit %d), level %d, mask 0x%b",
				    __func__, intbit, level,
				    cur_mask, AV530_IST_STRING);
		} else {
			intbit = ff1(cur_exmask);
			intsrc = av530_obio_exvec[intbit];

			if (intsrc == 0)
				panic("%s: unexpected extended interrupt source"
				    " (bit %d), level %d, mask 0x%b",
				    __func__, intbit, level,
				    cur_exmask, AV530_EXIST_STRING);
		}

		if (IS_VME_INTSRC(intsrc)) {
			level = VME_INTSRC_LEVEL(intsrc);
			ivec = AV530_VIRQLV + (level << 2);
			vec = *(volatile u_int32_t *)ivec & VME_VECTOR_MASK;
			if (vec & VME_BERR_MASK) {
				/* no need to dump exmask for vme intr */
				printf("%s: timeout getting VME "
				    "interrupt vector, "
				    "level %d, mask 0x%b\n",
				    __func__, level,
				    cur_mask, AV530_IST_STRING);
				ign_mask |= 1 << intbit;
				continue;
			}
			list = &vmeintr_handlers[vec];
		} else {
			list = &sysconintr_handlers[intsrc];
		}

		if (SLIST_EMPTY(list)) {
			warn = 1;
		} else {
			/*
			 * Walk through all interrupt handlers in the chain
			 * for the given vector, calling each handler in turn,
			 * until some handler returns a value != 0.
			 */
			ret = 0;
			SLIST_FOREACH(intr, list, ih_link) {
#ifdef MULTIPROCESSOR
				if (intr->ih_ipl < IPL_CLOCK)
					__mp_lock(&kernel_lock);
#endif
				if (ISSET(intr->ih_flags, INTR_WANTFRAME))
					ret = (*intr->ih_fn)((void *)eframe);
				else
					ret = (*intr->ih_fn)(intr->ih_arg);
#ifdef MULTIPROCESSOR
				if (intr->ih_ipl < IPL_CLOCK)
					__mp_unlock(&kernel_lock);
#endif
				if (ret != 0) {
					intr->ih_count.ec_count++;
					break;
				}
			}
			if (ret == 0)
				warn = 2;
		}

		if (warn != 0) {
			if (cur_mask != 0)
				ign_mask |= 1 << intbit;
			else
				ign_exmask |= 1 << intbit;

			if (IS_VME_INTSRC(intsrc))
				printf("%s: %s VME interrupt, "
				    "level %d, vec 0x%x, mask 0x%b\n",
				    __func__,
				    warn == 1 ? "spurious" : "unclaimed",
				    level, vec, cur_mask, AV530_IST_STRING);
			else {
				if (cur_mask != 0)
					printf("%s: %s interrupt, "
					    "level %d, bit %d, mask 0x%b\n",
					    __func__,
					    warn == 1 ?
					      "spurious" : "unclaimed",
					    level, intbit,
					    cur_mask, AV530_IST_STRING);
				else
					printf("%s: %s extended interrupt, "
					    "level %d, bit %d, mask 0x%b\n",
					    __func__,
					    warn == 1 ?
					      "spurious" : "unclaimed",
					    level, intbit,
					    cur_exmask, AV530_EXIST_STRING);
			}
		}
	}

#ifdef DIAGNOSTIC
	if (ign_mask != 0 || ign_exmask != 0) {
		if (++problems >= 10)
			panic("%s: broken interrupt behaviour", __func__);
	} else
		problems = 0;
#endif

out:
	/*
	 * process any remaining data access exceptions before
	 * returning to assembler
	 */
	if (eframe->tf_dmt0 & DMT_VALID)
		m88100_trap(T_DATAFLT, eframe);

	/*
	 * Disable interrupts before returning to assembler, the spl will
	 * be restored later.
	 */
	set_psr(get_psr() | PSR_IND);
}

const struct vme_range *
av530_get_vme_ranges()
{
	return vme_av530;
}
@


1.16
log
@Move the logic deciding whether to grab the kernel lock or not, deeper in the
interrupt logic, making sure the lock is not taken for clock interrupts.
Tested on aviion and luna88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: av530_machdep.c,v 1.15 2015/04/25 21:15:08 miod Exp $	*/
@


1.15
log
@Repair boot device detection when booting off the second SCSI controller on
AV530.
@
text
@d1 1
a1 1
/*	$OpenBSD: av530_machdep.c,v 1.14 2014/12/16 21:29:05 miod Exp $	*/
a572 3
#ifdef MULTIPROCESSOR
	int need_lock;
#endif
d705 1
a705 3
				need_lock = intr->ih_ipl < IPL_SCHED &&
				    intr->ih_ipl != IPL_CLOCK;
				if (need_lock)
d713 1
a713 1
				if (need_lock)
@


1.14
log
@Do not grab the kernel lock for clock interrupts, hardclock() will behave
correctly without. Modeled after sparc64 logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: av530_machdep.c,v 1.13 2014/11/16 12:30:56 deraadt Exp $	*/
d224 1
a224 1
			return AV530_SCSI1;
@


1.13
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: av530_machdep.c,v 1.12 2013/10/23 10:07:14 miod Exp $	*/
d573 3
a618 5
#ifdef MULTIPROCESSOR
	if (old_spl < IPL_SCHED)
		__mp_lock(&kernel_lock);
#endif

d707 6
d717 4
a768 5
#endif

#ifdef MULTIPROCESSOR
	if (old_spl < IPL_SCHED)
		__mp_unlock(&kernel_lock);
@


1.12
log
@Checkpoint of work-in-progress DMA support for oaic(4). Not working yet,
probably due to incorrect programming of the system board ``Diagnostic Control
Register'', for which I do not have documentation yet; commited so as not to
lose this work, since the machine I was testing on has apparently commited
suicide and will no longer POST.
@
text
@d1 1
a1 1
/*	$OpenBSD: av530_machdep.c,v 1.11 2013/10/10 21:24:58 miod Exp $	*/
d62 1
a62 1
	{ AV530_PROM,	AV530_PROM_SIZE,	UVM_PROT_RW,	CACHE_INH },
d64 1
a64 1
	{ AV530_UTILITY,AV530_UTILITY_SIZE,	UVM_PROT_RW,	CACHE_INH },
@


1.11
log
@Better boot device detection code. Board-specific code will now return the
address of a controller only know by its SCM name and number, and the boot
device detection code will now attempt to match the controller first, and
then grandchildren of it (if the boot device is a disk or a tape).
@
text
@d1 1
a1 1
/*	$OpenBSD: av530_machdep.c,v 1.10 2013/10/09 21:28:33 miod Exp $	*/
d431 1
d459 1
@


1.10
log
@Quick'n'dirty code to match trivial on-disk boot paths as the boot device.
Needs more work in order to cover all cases, but enough to get internal
disks on the first controller on models 4600 and 530 to get matched.

This makes the aviion port finally self-hosting on aforementioned models,
finally! Next step: bsd.rd...
@
text
@d1 1
a1 1
/*	$OpenBSD: av530_machdep.c,v 1.9 2013/10/07 19:11:39 miod Exp $	*/
d85 1
d99 1
a99 2
	av530_ptable,
	"ncsc"
d197 33
@


1.9
log
@Have platform->bootstrap() return the machine speed in MHz, which is used to
set up the delay constant.
@
text
@d1 1
a1 1
/*	$OpenBSD: av530_machdep.c,v 1.8 2013/10/07 19:09:08 miod Exp $	*/
d98 2
a99 1
	av530_ptable
@


1.8
log
@Split the 64-bit interrupt source mask code into two 32-bit `interrupt' and
`extended interrupt' masks. This is how the hardware works, and this makes the
code simpler than attempting to aggregate them.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: av530_machdep.c,v 1.7 2013/02/17 18:07:36 miod Exp $	*/
d151 1
a151 1
void
a154 3
#if 0
	extern u_char hostaddr[6];
#endif
a191 1
#if 0
d193 1
a193 2
	 * Get all the information we'll need later from the PROM, while
	 * we can still use it.
d195 1
a195 2
	scm_getenaddr(hostaddr);
#endif
@


1.7
log
@Constify struct cmmu.
@
text
@d1 1
a1 1
/*	$OpenBSD: av530_machdep.c,v 1.6 2011/01/02 13:40:05 miod Exp $	*/
d95 1
d102 2
a103 3
 * The MVME188 interrupt arbiter has 25 orthogonal interrupt sources.
 * On the AViiON 530 machines, there are even more interrupt sources in use,
 * requiring the use of two arbiters.
d388 1
a388 1
u_int64_t
d410 9
a418 1
	}, ext_intsrc[] = {
a437 1
	uint64_t isrc;
d439 1
a439 3
	isrc = ext_intsrc[i];
	isrc = (isrc << 32) | intsrc[i];
	return isrc;
@


1.6
log
@Kill pmap_table_t typedef.
@
text
@d1 1
a1 1
/*	$OpenBSD: av530_machdep.c,v 1.5 2010/12/31 21:38:07 miod Exp $	*/
d154 1
a154 1
	extern struct cmmu_p cmmu8820x;
@


1.5
log
@Massive overhauling of the m88k pmap, though I can't pretend it's a new pmap
since a large part of the structures and logic remains.

Since m88k has separate supervisor/user spaces, we can map physical memory 1:1
in supervisor space, and have the kernel virtual address space start from the
end of physical memory.

This allows us to switch to __HAVE_PMAP_DIRECT. And to get rid of the double
mapped sdt, since now their virtual and physical addresses will always match.

The upper bound of the kernel virtual memory space is now platform dependent,
until the code which relies upon some hardware devices being mapped 1:1 in
supervisor mode is updated to no longer require this (this is mainly a PITA on
luna88k, where onboard devices start at 0x40000000, leaving only 1GB of KVA at
the moment - still much better than the previous 512MB).

Tested on mvme88k only (187, 188, 197LE, 197DP). Other platforms ought to
work, aviion will be checked shortly and fixed if necessary. No known
OpenBSD/luna88k system in working condition at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: av530_machdep.c,v 1.4 2010/04/24 18:46:51 miod Exp $	*/
d40 1
d60 2
a61 1
const pmap_table_entry av530_ptable[] = {
d97 1
a97 1
	av530_ptable,
@


1.4
log
@SMP support for models 4600 and 530, adapted from the MVME188 code. Models
4000 and 4300 will need more work, because they don't have as many distinct
software interrupt sources as required by this implementation, so a
different IPI scheme will be necessary.

Tested on dual-processor 4625 (AV530 family) and single processor 4300
(AV400 family).
@
text
@d1 1
a1 1
/*	$OpenBSD: av530_machdep.c,v 1.3 2010/04/24 18:44:25 miod Exp $	*/
d60 1
a60 2
	{ AV530_PROM,	AV530_PROM,	AV530_PROM_SIZE,
	  UVM_PROT_RW,	CACHE_INH },
d62 1
a62 2
	{ AV530_UTILITY,AV530_UTILITY,	AV530_UTILITY_SIZE,
	  UVM_PROT_RW,	CACHE_INH },
d64 1
a64 1
	{ 0, 0, (vsize_t)-1, 0, 0 }
@


1.3
log
@Replace heuristics used to figure out which model we are running on, and
trust the cpuid value returned by the prom itself (verified against
/usr/opt/sdk/include/sys/dg_sys_info.h on a DG-UX filesystem).
@
text
@d1 1
a1 1
/*	$OpenBSD: av530_machdep.c,v 1.2 2010/04/21 19:33:45 miod Exp $	*/
d51 4
d56 2
d90 4
d120 1
a120 1
#define	SLAVE_MASK	0	/* AV530_IRQ_SWI0 | AV530_IRQ_SWI1 */
d213 5
d249 3
d283 3
d302 83
d550 10
d566 20
d594 3
d610 13
d726 5
@


1.2
log
@More reworking of interrupt handling and VME support, and rename various
board-specific defines to prevent any risk of collision. This also adds
clock support for AV530 family, and timecounter support (cio code sync'ed
with mvme88k). And various bugs fixed in the process.

This is enough to get models 4600 and 530 to run multiuser with a Hawk
Ethernet VME card (the onboard Ethernet is not supported yet, coming soon).
There is no way to share a disk with DG/UX yet, the kernel (and fdisk(8))
needs to become aware of its ways.
@
text
@d1 1
a1 1
/*	$OpenBSD: av530_machdep.c,v 1.1 2010/04/18 22:04:37 miod Exp $	*/
a75 1
	"530/4600 series",
d85 1
a87 1
	vme_av530
d185 1
a189 1
#if 0
a191 2
	cpuid = scm_cpuid();
	sysid = scm_sysid();
d591 6
@


1.1
log
@Work in progress support for AViiON models 4600 and 530.
Also features support for {awkw,bast}ard 6:1 CMMU:CPU configurations (4I2D).
Tested on model 4605, which runs up to cpu_initclocks(), which is not written
for this system family yet. No regression on model 4300.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 1
a53 2
const pmap_table_entry
av530_ptable[] = {
d58 1
a58 1
	  UVM_PROT_RW,	CACHE_INHIBIT },
d63 12
d81 1
a81 1
	NULL,			/* XXX need PIT clock code */
d88 1
a88 8

	AV530_VME16_BASE,
		AV530_VME16_START,	AV530_VME16_END,
	AV530_VME24_BASE,
		AV530_VME24_START,	AV530_VME24_END,
	AV530_VME32_BASE,
		AV530_VME32_START1,	AV530_VME32_END1,
		AV530_VME32_START2,	AV530_VME32_END2
a100 2
 * Note that, on the AV530 design, the interrupt enable registers are
 * write-only and read back as 0xffffffff.
d102 2
a103 2
static u_int32_t int_mask_reg[] = { 0, 0, 0, 0 };
static u_int32_t ext_int_mask_reg[] = { 0, 0, 0, 0 };
d111 1
a111 1
#define	SLAVE_MASK	0	/* IRQ_SWI0 | IRQ_SWI1 */
a141 2
int32_t cpuid, sysid;

d146 1
d148 1
d190 1
d192 1
d199 1
a199 1
 * while keeping ``mask'' masked.
d240 2
a241 2
	*(u_int32_t *)AV_IEN(cpu) = int_mask_reg[cpu] = mask;
	*(u_int32_t *)AV_EXIEN(cpu) = ext_int_mask_reg[cpu] = exmask;
d271 3
a273 2
		*(u_int32_t *)AV_IEN(cpu) = int_mask_reg[cpu] = mask;
		*(u_int32_t *)AV_EXIEN(cpu) = ext_int_mask_reg[cpu] = exmask;
d292 5
a296 5
		IRQ_ABORT,
		IRQ_ACF,
		IRQ_SF,
		0,	/* XXX no clock */
		IRQ_DI,
d302 7
a308 7
		IRQ_VME1,
		IRQ_VME2,
		IRQ_VME3,
		IRQ_VME4,
		IRQ_VME5,
		IRQ_VME6,
		IRQ_VME7
d314 1
d316 5
a320 6
		0,
		EXIRQ_DUART2,
		EXIRQ_LAN0,
		EXIRQ_LAN1,
		EXIRQ_SCSI0,
		EXIRQ_SCSI1,
d339 1
a339 1
static const u_int obio_vec[32] = {
d344 1
a344 1
	INTSRC_VME,		/* VME1 */
d346 1
a346 1
	INTSRC_VME,		/* VME2 */
d350 1
a350 1
	INTSRC_VME,		/* VME3 */
d352 1
a352 1
	INTSRC_VME,		/* VME4 */
d354 1
a354 1
	INTSRC_VME,		/* VME5 */
d359 1
a359 1
	INTSRC_VME,		/* VME6 */
d363 1
a363 1
	INTSRC_VME,		/* VME7 */
d373 1
a373 1
static const u_int obio_exvec[32] = {
d401 1
a401 1
	0,			/* PIT0OF */
d415 5
d480 1
a480 1
			intsrc = obio_vec[intbit];
d486 1
a486 1
				    cur_mask, IST_STRING);
d489 1
a489 1
			intsrc = obio_exvec[intbit];
d495 1
a495 1
				    cur_exmask, EXIST_STRING);
d498 2
a499 1
		if (intsrc == INTSRC_VME) {
d508 1
a508 1
				    cur_mask, IST_STRING);
d546 1
a546 1
			if (intsrc == INTSRC_VME)
d551 1
a551 1
				    level, vec, cur_mask, IST_STRING);
d560 1
a560 1
					    cur_mask, IST_STRING);
d568 1
a568 1
					    cur_exmask, EXIST_STRING);
@

