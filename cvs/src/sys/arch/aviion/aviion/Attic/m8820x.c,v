head	1.13;
access;
symbols
	OPENBSD_5_8:1.12.0.10
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.10.0.12
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.10
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.6
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.4
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.4.0.6
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	AV400_20060509:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.12.01.07.50.03;	author deraadt;	state dead;
branches;
next	1.12;
commitid	Rh8AZFtVMVCiwPts;

1.12
date	2013.09.29.14.08.53;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2013.09.26.18.37.07;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.31.21.38.07;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.02.22.01.43;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.25.21.03.51;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2010.04.18.22.04.37;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.19.17.56.12;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2007.12.13.18.51.01;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.21.12.22.01;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.20.11.58.33;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.16.23.23.00;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.08.16.34.47;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.05.08.16.34.47;	author miod;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Send Aviion to same place as Nova II
discussed with jsg
@
text
@/*	$OpenBSD: m8820x.c,v 1.12 2013/09/29 14:08:53 miod Exp $	*/
/*
 * Copyright (c) 2004, 2006, 2010 Miodrag Vallat.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <machine/asm_macro.h>
#include <machine/avcommon.h>
#include <machine/board.h>
#include <machine/cmmu.h>
#include <machine/cpu.h>
#include <machine/m8820x.h>
#include <machine/pmap.h>
#include <machine/prom.h>

extern	u_int32_t pfsr_straight[];
extern	u_int32_t pfsr_double[];
extern	u_int32_t pfsr_six[];

volatile u_int32_t *whoamiptr;

/*
 * This routine sets up the CPU/CMMU configuration.
 */
void
m8820x_setup_board_config()
{
	extern u_int32_t pfsr_save[];
	struct m8820x_cmmu *cmmu;
	struct scm_cpuconfig scc;
	int type, cpu_num, cpu_cmmu_num, cmmu_num, cmmu_per_cpu;
	volatile u_int *cr;
	u_int32_t whoami;
	u_int32_t *m8820x_pfsr;

	/*
	 * Check whether the WHOAMI register exists.
	 * According to documentation, that register is not available
	 * on 100, 200 and 300 models.
	 *
	 * Since it is unknown whether models 100 and 200 share the
	 * 300/310 cpuid, we'd better check whether the register can
	 * be read.
	 */

	switch (cpuid) {
	case AVIION_300_310:
	/* the following for consistency and safety */
	case AVIION_300C_310C:
	case AVIION_300CD_310CD:
	case AVIION_300D_310D:
		break;
	default:
		if (badaddr((vaddr_t)AV_WHOAMI, 4) == 0)
			whoamiptr = (volatile u_int32_t *)AV_WHOAMI;
		break;
	}
	

	/*
	 * First, find if any CPU0 CMMU is a 88204. If so, we can
	 * issue the CPUCONFIG system call to get the configuration
	 * details.
	 * NOTE that this relies upon [0] and [1] to always have
	 * valid CMMU addresses - thankfully this is always the case
	 * on model 530 regardless of the CMMU configuration.
	 */
	if (badaddr((vaddr_t)m8820x_cmmu[0].cmmu_regs, 4) != 0 ||
	    badaddr((vaddr_t)m8820x_cmmu[1].cmmu_regs, 4) != 0) {
		printf("CPU0: missing CMMUs ???\n");
		scm_halt();
		/* NOTREACHED */
	}

	cr = (void *)m8820x_cmmu[0].cmmu_regs;
	type = CMMU_TYPE(cr[CMMU_IDR]);

	if (type != M88204_ID && type != M88200_ID) {
		printf("CPU0: unrecognized CMMU type %d\n", type);
		scm_halt();
		/* NOTREACHED */
	}

	/*
	 * Try and use the CPUCONFIG system call to get all the information
	 * we need. This is theoretically only available on 88204-based
	 * machines, but it can't hurt to give it a try.
	 */
	if (scm_cpuconfig(&scc) == 0 && scc.version == SCM_CPUCONFIG_VERSION)
		goto knowledge;

	/*
	 * XXX Instead of deciding on the CMMU type, we should decide on
	 * XXX the board type instead. But then, I am not sure not all
	 * XXX 88204-based designs have the WHOAMI register... -- miod
	 */
	switch (type) {
	case M88204_ID:
		/*
		 * Probe CMMU addresses to discover which CPU slots are
		 * populated. Actually, we'll simply check how many upper
		 * slots we can ignore, and keep using badaddr() to cope
		 * with unpopulated slots.
		 */
hardprobe:
		/*
		 * First, we'll assume we are in a 2:1 configuration, thus no
		 * CMMU split scheme in use.
		 */
		scc.igang = scc.dgang = 1;
		scc.isplit = scc.dsplit = 0;

		/*
		 * Probe CMMU addresses to discover which CPU slots are
		 * populated. Actually, we'll simply check how many upper
		 * slots we can ignore, and keep using badaddr() to cope
		 * with unpopulated slots.
		 */
		cmmu = m8820x_cmmu + MAX_CMMUS - 1;
		for (max_cmmus = MAX_CMMUS - 1; max_cmmus != 0;
		    max_cmmus--, cmmu--) {
			if (cmmu->cmmu_regs == NULL)
				continue;
			if (badaddr((vaddr_t)cmmu->cmmu_regs, 4) == 0)
				break;
		}
		scc.cpucount = (1 + max_cmmus) >> 1;
		break;

	case M88200_ID:
		/*
		 * Deduce our configuration from the WHOAMI register.
		 */

		if (whoamiptr == NULL)
			whoami = 0x0a;	/* 1 CPU, 2 CMMUs */
		else
			whoami = (*whoamiptr & 0xf0) >> 4;

		switch (whoami) {
		case 0:		/* 4 CPUs, 8 CMMUs */
			scc.cpucount = 4;
			break;
		case 5:		/* 2 CPUs, 4 CMMUs */
			scc.cpucount = 2;
			break;
		case 0x0a:	/* 1 CPU, 2 CMMUs */
			scc.cpucount = 1;
			break;
		case 3:		/* 2 CPUs, 12 CMMUs */
		case 7:		/* 1 CPU, 6 CMMUs */
			/*
			 * Regular logic can't cope with asymmetrical
			 * designs. Report a 4:1 ratio with two missing
			 * data CMMUs.
			 */
			ncpusfound = whoami == 7 ? 1 : 2;
			cmmu_per_cpu = 6;
			cmmu_shift = 3;
			max_cmmus = ncpusfound << cmmu_shift;
#if 0
			scc.igang = 4;
			scc.isplit = (1U << 12) | (1U << 13);
			scc.dgang = 2;
			scc.dsplit = (1U << 12);
#endif
			m8820x_pfsr = pfsr_six;
			goto done;
			break;
		default:
			printf("unrecognized CMMU configuration, whoami %x\n",
			    whoami);
#if 0
			scm_halt();
#else
			goto hardprobe;
#endif
		}
		/*
		 * Oh, and we are in a 2:1 configuration, thus no
		 * CMMU split scheme in use.
		 */
		scc.igang = scc.dgang = 1;
		scc.isplit = scc.dsplit = 0;

		break;
	}

knowledge:
	if (scc.igang != scc.dgang ||
	    scc.igang == 0 || scc.igang > 2) {
		printf("Unsupported CMMU to CPU ratio (%dI/%dD)\n",
		    scc.igang, scc.dgang);
		scm_halt();
		/* NOTREACHED */
	}

	ncpusfound = scc.cpucount;
	if (scc.igang == 1) {
		cmmu_shift = 1;
		m8820x_pfsr = pfsr_straight;
	} else {
		cmmu_shift = 2;
		m8820x_pfsr = pfsr_double;
	}
	max_cmmus = ncpusfound << cmmu_shift;
	cmmu_per_cpu = 1 << cmmu_shift;

done:
	/*
	 * Now that we know which CMMUs are there, report every association
	 */
	for (cpu_num = 0; cpu_num < ncpusfound; cpu_num++) {
		cmmu_num = cpu_num << cmmu_shift;
		cr = m8820x_cmmu[cmmu_num].cmmu_regs;
		if (badaddr((vaddr_t)cr, 4) == 0) {
			type = CMMU_TYPE(m8820x_cmmu[cmmu_num].
			    cmmu_regs[CMMU_IDR]);

			printf("CPU%d is associated to %d MC8820%c CMMUs\n",
			    cpu_num, cmmu_per_cpu,
			    type == M88204_ID ? '4' : '0');
		}
	}

	/*
	 * Now set up addressing limits
	 */
	switch (cmmu_shift) {
	case 3:	/* 6:1 schemes */
		for (cmmu_num = 0, cmmu = m8820x_cmmu; cmmu_num < max_cmmus;
		    cmmu_num++, cmmu++) {
			if (cmmu->cmmu_regs == NULL)
				continue;

			cpu_cmmu_num = cmmu_num >> 1; /* CPU view of the CMMU */

			if (CMMU_MODE(cmmu_num) == INST_CMMU) {
				/* I0, I1, I2, I3: A13:A12 split */
				cmmu->cmmu_addr = (cpu_cmmu_num & 0x03) << 12;
				cmmu->cmmu_addr_mask = (1U << 13) | (1U << 12);
			} else {
				/* D0, D1: A12 split */
				cmmu->cmmu_addr = (cpu_cmmu_num & 0x01) << 12;
				cmmu->cmmu_addr_mask = 1U << 12;
			}
		}
		break;
	case 2:	/* 4:1 schemes */
		for (cmmu_num = 0, cmmu = m8820x_cmmu; cmmu_num < max_cmmus;
		    cmmu_num++, cmmu++) {
			cpu_cmmu_num = cmmu_num >> 1; /* CPU view of the CMMU */

			if (CMMU_MODE(cmmu_num) == INST_CMMU) {
				/* I0, I1 */
				cmmu->cmmu_addr =
				    cpu_cmmu_num < 2 ? 0 : scc.isplit;
				cmmu->cmmu_addr_mask = scc.isplit;
			} else {
				/* D0, D1 */
				cmmu->cmmu_addr =
				    cpu_cmmu_num < 2 ? 0 : scc.dsplit;
				cmmu->cmmu_addr_mask = scc.dsplit;
			}
		}
		break;
	}

	/*
	 * Patch the exception handling code to invoke the correct pfsr
	 * analysis chunk.
	 */
	pfsr_save[0] = 0xc4000000 |
	    (((vaddr_t)m8820x_pfsr + 4 - (vaddr_t)pfsr_save) >> 2);
	pfsr_save[1] = m8820x_pfsr[0];
}

/*
 * Find out the CPU number from accessing CMMU.
 * We access the WHOAMI register, which is in data space;
 * its value will let us know which CPU has been used to perform the read.
 */
cpuid_t
m8820x_cpu_number()
{
	u_int32_t whoami;
	cpuid_t cpu;

	if (whoamiptr == NULL)
		return 0;

	whoami = *whoamiptr;
	switch ((whoami & 0xf0) >> 4) {
	case 0:
	case 3:
	case 5:
		for (cpu = 0; cpu < 4; cpu++)
			if (whoami & (1 << cpu))
				return (cpu);
		break;
	case 7:
	case 0x0a:
		/* for single processors, this field of whoami is undefined */
		return (0);
	}

	panic("m8820x_cpu_number: could not determine my cpu number, whoami %x",
	    whoami);
}
@


1.12
log
@Test whether the WHOAMI register exists before using it. Apparently, models
100/200/300 would lack it. They are single-processor systems anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.11 2013/09/26 18:37:07 miod Exp $	*/
@


1.11
log
@Tinkering with the cache diagnostic registers have told me enough information
to figure out the addressing split scheme used by DG in their 6:1 CMMU designs.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.10 2010/12/31 21:38:07 miod Exp $	*/
d34 1
d45 2
d62 24
d159 6
a164 1
		whoami = (*(volatile u_int32_t *)AV_WHOAMI & 0xf0) >> 4;
d172 1
a172 1
		case 0x0a:	/* 1 CPU, 2 CMMU */
d176 1
a176 1
		case 7:		/* 1 CPU, 6 CMMU */
d314 4
a317 1
	whoami = *(volatile u_int32_t *)AV_WHOAMI;
@


1.10
log
@Massive overhauling of the m88k pmap, though I can't pretend it's a new pmap
since a large part of the structures and logic remains.

Since m88k has separate supervisor/user spaces, we can map physical memory 1:1
in supervisor space, and have the kernel virtual address space start from the
end of physical memory.

This allows us to switch to __HAVE_PMAP_DIRECT. And to get rid of the double
mapped sdt, since now their virtual and physical addresses will always match.

The upper bound of the kernel virtual memory space is now platform dependent,
until the code which relies upon some hardware devices being mapped 1:1 in
supervisor mode is updated to no longer require this (this is mainly a PITA on
luna88k, where onboard devices start at 0x40000000, leaving only 1GB of KVA at
the moment - still much better than the previous 512MB).

Tested on mvme88k only (187, 188, 197LE, 197DP). Other platforms ought to
work, aviion will be checked shortly and fixed if necessary. No known
OpenBSD/luna88k system in working condition at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.9 2010/05/02 22:01:43 miod Exp $	*/
d154 6
a159 1
			scc.isplit = scc.dsplit = 0;	/* XXX unknown */
a218 1

d222 21
a242 1
	if (cmmu_shift > 1) {
d259 1
@


1.9
log
@Precompute the userland process apr cache bits into a global variable.
On AViiON systems with the 6:1 CMMU:CPU configuration, force cached
mappings to be writethrough - this probably hides a bug in the code, but
that's the only way so far to get such a system running stably.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.8 2010/04/25 21:03:51 miod Exp $	*/
a155 9

			/*
			 * We can't use writeback userland mappings until
			 * the CMMU split scheme is known, as the current
			 * pessimistic behaviour is not good enough to
			 * prevent out-of-sync cache lines from occuring.
			 */
			default_apr |= CACHE_WT;

@


1.8
log
@Update various comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.7 2010/04/18 22:04:37 miod Exp $	*/
d37 1
d156 9
@


1.7
log
@Work in progress support for AViiON models 4600 and 530.
Also features support for {awkw,bast}ard 6:1 CMMU:CPU configurations (4I2D).
Tested on model 4605, which runs up to cpu_initclocks(), which is not written
for this system family yet. No regression on model 4300.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.6 2009/04/19 17:56:12 miod Exp $	*/
d86 1
a86 2
	if (scm_cpuconfig(&scc) == 0 &&
	    scc.version == SCM_CPUCONFIG_VERSION)
d145 3
a147 1
			 *
@


1.6
log
@Rename max_cpus to ncpusfound and compute it regardless of option
MULTIPROCESSOR.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.5 2007/12/13 18:51:01 miod Exp $	*/
d3 1
a3 1
 * Copyright (c) 2004, 2006, Miodrag Vallat.
d39 3
a41 2
extern	u_int32_t pfsr_av400_straight[];
extern	u_int32_t pfsr_av400_double[];
d52 1
a52 1
	int type, cpu_num, cmmu_num;
d61 3
d117 5
a121 2
		cmmu = m8820x_cmmu + 7;
		for (max_cmmus = 7; max_cmmus != 0; max_cmmus--, cmmu--) {
d132 2
a133 2
		whoami = *(volatile u_int32_t *)AV_WHOAMI;
		switch ((whoami & 0xf0) >> 4) {
d145 10
a154 4
			printf("MAYDAY, 6:1 CMMU configuration (whoami %x)"
			    " but no CPUCONFIG information\n", whoami);
			scm_halt();
			/* NOTREACHED */
d187 1
a187 1
		m8820x_pfsr = pfsr_av400_straight;
d190 1
a190 1
		m8820x_pfsr = pfsr_av400_double;
d192 2
a193 1
	max_cmmus = ncpusfound << scc.igang;
d195 1
d207 1
a207 1
			    cpu_num, 1 << cmmu_shift,
d219 1
a219 1
			cpu_num = cmmu_num >> 1; /* CPU view of the CMMU */
d221 1
a221 1
			if (cmmu_num & 1) {
d223 2
a224 1
				cmmu->cmmu_addr = cpu_num < 2 ? 0 : scc.isplit;
d228 2
a229 1
				cmmu->cmmu_addr = cpu_num < 2 ? 0 : scc.dsplit;
@


1.5
log
@Sync with the mvme188 codebase, various tweaks from the last 18 months which
had not been reported to aviion.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.4 2006/05/21 12:22:01 miod Exp $	*/
d171 1
a171 1
	max_cpus = scc.cpucount;
d179 1
a179 1
	max_cmmus = max_cpus << scc.igang;
d184 1
a184 1
	for (cpu_num = 0; cpu_num < max_cpus; cpu_num++) {
@


1.4
log
@Move common definitions shared by the various 88100-based designs to their
own header file, and slowly make most of the code board-independent. No
functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.3 2006/05/20 11:58:33 miod Exp $	*/
d39 3
d48 1
d54 1
d172 7
a178 1
	cmmu_shift = scc.igang == 1 ? 1 : 2;
d217 8
@


1.3
log
@Try and use the CPUCONFIG PROM call even if we did not detect 88204 CMMUs,
recent PROM might have it implemented, and for 6:1 processor boards on 530
models, this is the only way we'll get to know the split scheme in use, for
now.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.2 2006/05/16 23:23:00 miod Exp $	*/
d33 1
a38 2
#include <machine/av400.h>

a51 12
	 * These are the fixed assignments on AV400 designs.
	 */
	m8820x_cmmu[0].cmmu_regs = (void *)AV400_CMMU_I0;
	m8820x_cmmu[1].cmmu_regs = (void *)AV400_CMMU_D0;
	m8820x_cmmu[2].cmmu_regs = (void *)AV400_CMMU_I1;
	m8820x_cmmu[3].cmmu_regs = (void *)AV400_CMMU_D1;
	m8820x_cmmu[4].cmmu_regs = (void *)AV400_CMMU_I2;
	m8820x_cmmu[5].cmmu_regs = (void *)AV400_CMMU_D2;
	m8820x_cmmu[6].cmmu_regs = (void *)AV400_CMMU_I3;
	m8820x_cmmu[7].cmmu_regs = (void *)AV400_CMMU_D3;

	/*
d56 2
a57 2
	if (badaddr(AV400_CMMU_I0, 4) != 0 ||
	    badaddr(AV400_CMMU_D0, 4) != 0) {
d63 1
a63 1
	cr = (void *)AV400_CMMU_I0;
d120 1
a120 1
		whoami = *(volatile u_int32_t *)AV400_WHOAMI;
d219 1
a219 1
	whoami = *(volatile u_int32_t *)AV400_WHOAMI;
@


1.2
log
@Recognize braindead 6:1 CMMU to CPU ratio configurations (which we do not
support yet), as found e.g. on some 530 models.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.1.1.1 2006/05/08 16:34:47 miod Exp $	*/
d79 1
a79 2
	switch (type) {
	default:
d83 17
a99 1
		break;
d102 4
a105 12
		 * We can use the CPUCONFIG system call to get all the
		 * information we need.
		 */
		if (scm_cpuconfig(&scc) == 0 &&
		    scc.version == SCM_CPUCONFIG_VERSION)
			break;

		/*
		 * If it fails, we'll need to probe CMU addresses to
		 * discover which CPU slots are populated. Actually,
		 * we'll simply check how many upper slots we can ignore,
		 * and keep using badaddr() to cope with unpopulated slots.
d127 1
a128 1
		break;
d131 1
a131 1
		 * Deduce our configuration from the whoami register.
d170 1
@


1.1
log
@Enter OpenBSD/aviion, a port to the m88k-based Data General AViiON workstations. Currently restricted to diskless serial console, tested on AV410 only; many thanks to Chris Tribo for documentation and testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: m8820x.c,v 1.45 2005/12/04 12:20:19 miod Exp $	*/
d137 7
d227 1
d233 1
@


1.1.1.1
log
@Oops, correct import this time.
@
text
@@
