head	1.29;
access;
symbols
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.26.0.6
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.21.0.4
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.20.0.8
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.6
	OPENBSD_5_0:1.20.0.4
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.5.0.2
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	AV400_20060509:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2015.12.01.07.50.03;	author deraadt;	state dead;
branches;
next	1.28;
commitid	Rh8AZFtVMVCiwPts;

1.28
date	2015.05.18.04.06.37;	author miod;	state Exp;
branches;
next	1.27;
commitid	SUgrahEkzVbDqUaz;

1.27
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	yv0ECmCdICvq576h;

1.26
date	2013.10.23.10.07.14;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2013.10.10.21.24.58;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2013.10.09.21.28.33;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2013.10.07.19.11.39;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2013.10.07.19.09.07;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2013.02.17.18.07.36;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.02.13.40.05;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2010.12.31.21.38.07;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.24.18.46.51;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2010.04.24.18.44.25;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.21.19.33.45;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.18.22.04.37;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.16.22.54.59;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2007.12.27.23.19.12;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2007.12.19.22.05.04;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.12.19.21.53.36;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.12.13.18.51.01;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2007.12.12.20.36.24;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.17.05.37.51;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.17.05.36.21;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.17.05.32.04;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.12.20.02.12;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.21.12.22.01;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.20.12.04.51;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.20.11.57.02;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.09.18.25.34;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.05.09.18.25.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Send Aviion to same place as Nova II
discussed with jsg
@
text
@/*	$OpenBSD: av400_machdep.c,v 1.28 2015/05/18 04:06:37 miod Exp $	*/
/*
 * Copyright (c) 2006, 2007, Miodrag Vallat.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1998, 1999, 2000, 2001 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Copyright (c) 1999 Steve Murphree, Jr.
 * Copyright (c) 1995 Theo de Raadt
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1995 Nivas Madhur
 * Copyright (c) 1994 Gordon W. Ross
 * Copyright (c) 1993 Adam Glass
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)clock.c	8.1 (Berkeley) 6/11/93
 */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/errno.h>

#include <uvm/uvm_extern.h>

#include <machine/asm_macro.h>
#include <machine/board.h>
#include <machine/bus.h>
#include <machine/cmmu.h>
#include <machine/cpu.h>
#include <machine/pmap_table.h>
#include <machine/reg.h>
#include <machine/trap.h>

#include <machine/m88100.h>
#include <machine/m8820x.h>
#include <machine/avcommon.h>
#include <machine/av400.h>
#include <machine/prom.h>

#include <aviion/dev/sysconvar.h>
#include <aviion/dev/vmevar.h>

#ifdef MULTIPROCESSOR0
#include <machine/db_machdep.h>
#endif

u_int	av400_safe_level(u_int, u_int);
void	av400_clock_ipi_handler(struct trapframe *);
void	av400_ipi_handler(struct trapframe *);

const struct pmap_table
av400_ptable[] = {
	{ AV400_PROM,	AV400_PROM_SIZE,	PROT_READ | PROT_WRITE, CACHE_INH },
#if 0	/* mapped by the hardcoded BATC entries */
	{ AV400_UTILITY,AV400_UTILITY_SIZE,	PROT_READ | PROT_WRITE, CACHE_INH },
#endif
	{ 0, (vsize_t)-1, 0, 0 }
};

const struct vme_range vme_av400[] = {
	{ VME_A16,
	  AV400_VME16_START,	AV400_VME16_END,	AV400_VME16_BASE },
	{ VME_A24,
	  AV400_VME24_START,	AV400_VME24_END,	AV400_VME24_BASE },
	{ VME_A32,
	  AV400_VME32_START1,	AV400_VME32_END1,	AV400_VME32_BASE },
	{ VME_A32,
	  AV400_VME32_START2,	AV400_VME32_END2,	AV400_VME32_BASE },
	{ 0 }
};

const struct board board_av400 = {
	av400_bootstrap,
	av400_memsize,
	av400_startup,
	av400_get_boot_device,
	av400_intr,
	cio_init_clocks,
	av400_getipl,
	av400_setipl,
	av400_raiseipl,
#ifdef MULTIPROCESSOR
	NULL,	/* av400_send_ipi, */
	m88100_smp_setup,
#endif
	av400_intsrc,
	av400_exintsrc,
	av400_get_vme_ranges,

	av400_ptable
};

/*
 * The MVME188 interrupt arbiter has 25 orthogonal interrupt sources.
 * On the AViiON machines, there are even more interrupt sources in use,
 * but differences are minimal.
 * We fold this model in the 8-level spl model this port uses, enforcing
 * priorities manually with the interrupt masks.
 */

/*
 * Copy of the interrupt enable register for each CPU.
 * Note that, on the AV400 design, the interrupt enable registers are
 * write-only and read back as 0xffffffff.
 */
u_int32_t av400_int_mask_reg[] = { 0, 0, 0, 0 };

u_int av400_curspl[] = { IPL_HIGH, IPL_HIGH, IPL_HIGH, IPL_HIGH };

#ifdef MULTIPROCESSOR0
/*
 * Interrupts allowed on secondary processors.
 */
#define	SLAVE_MASK	0
#endif

/*
 * Figure out how much memory is available, by asking the PROM.
 */
vaddr_t
av400_memsize()
{
	vaddr_t memsize0, memsize1;

	memsize0 = scm_memsize(0);
	memsize1 = scm_memsize(1);

	/*
	 * What we got is the ``top of memory'', i.e. the largest addressable
	 * word address, ending in 0xffc. Round up to a multiple of a page.
	 */
	memsize0 = round_page(memsize0);
	memsize1 = round_page(memsize1);

	physmem = atop(memsize0);
	return (memsize1);
}

void
av400_startup()
{
}

u_int
av400_bootstrap()
{
	extern const struct cmmu_p cmmu8820x;
	extern u_char hostaddr[6];

	/*
	 * These are the fixed assignments on AV400 designs.
	 */
	cmmu = &cmmu8820x;
	m8820x_cmmu[0].cmmu_regs = (void *)AV400_CMMU_I0;
	m8820x_cmmu[1].cmmu_regs = (void *)AV400_CMMU_D0;
	m8820x_cmmu[2].cmmu_regs = (void *)AV400_CMMU_I1;
	m8820x_cmmu[3].cmmu_regs = (void *)AV400_CMMU_D1;
	m8820x_cmmu[4].cmmu_regs = (void *)AV400_CMMU_I2;
	m8820x_cmmu[5].cmmu_regs = (void *)AV400_CMMU_D2;
	m8820x_cmmu[6].cmmu_regs = (void *)AV400_CMMU_I3;
	m8820x_cmmu[7].cmmu_regs = (void *)AV400_CMMU_D3;

	/* clear and disable all interrupts */
	*(volatile u_int32_t *)AV_IENALL = 0;

	/*
	 * Get all the information we'll need later from the PROM, while
	 * we can still use it.
	 */
	scm_getenaddr(hostaddr);

	/*
	 * Return the delay const value to use (which matches the CPU speed).
	 */
	switch (cputyp) {
	case AVIION_300_310:
	case AVIION_400_4000:
	case AVIION_300C_310C:
	case AVIION_300CD_310CD:
	case AVIION_300D_310D:
	case AVIION_4300_16:
		return 16;
	case AVIION_410_4100:
	case AVIION_4300_20:
		return 20;
	default:
	case AVIION_4300_25:
		return 25;
	}
}

/*
 * Return the address of the boot device, providing the default boot device
 * if none is requested.
 */
paddr_t
av400_get_boot_device(uint32_t *name, u_int unit)
{
	/* default boot device is on-board insc() */
	if (*name == 0)
		*name = SCM_INSC;

	switch (*name) {
	case SCM_INEN:
		if (unit == 0)
			return AV400_LAN;
		break;
	case SCM_INSC:
		if (unit == 0)
			return AV400_SCSI;
		break;
	}

	return 0;
}

/*
 * Return the next ipl >= ``curlevel'' at which we can reenable interrupts
 * while keeping ``mask'' masked.
 */
u_int
av400_safe_level(u_int mask, u_int curlevel)
{
	int i;

#ifdef MULTIPROCESSOR0
	if (mask & AV400_CLOCK_IPI_MASK)
		curlevel = max(IPL_CLOCK, curlevel);
	mask &= ~(AV400_IPI_MASK | AV400_CLOCK_IPI_MASK);
#endif
	for (i = curlevel; i < NIPLS; i++)
		if ((int_mask_val[i] & mask) == 0)
			return i;

	return (NIPLS - 1);
}

u_int
av400_getipl(void)
{
	return av400_curspl[cpu_number()];
}

u_int
av400_setipl(u_int level)
{
	u_int32_t mask, curspl, psr;
	u_int cpu = cpu_number();

	psr = get_psr();
	set_psr(psr | PSR_IND);
	curspl = av400_curspl[cpu];

	mask = int_mask_val[level];
#ifdef MULTIPROCESSOR0
	if (cpu != master_cpu)
		mask &= SLAVE_MASK;
	mask |= AV400_SWI_IPI_MASK(cpu);
	if (level < IPL_CLOCK)
		mask |= AV400_SWI_CLOCK_IPI_MASK(cpu);
#endif

	av400_curspl[cpu] = level;
	*(u_int32_t *)AV_IEN(cpu) = av400_int_mask_reg[cpu] = mask;
	/*
	 * We do not flush the pipeline here, because interrupts are disabled,
	 * and set_psr() will synchronize the pipeline.
	 */
	set_psr(psr);

	return curspl;
}

u_int
av400_raiseipl(u_int level)
{
	u_int32_t mask, curspl, psr;
	u_int cpu = cpu_number();

	psr = get_psr();
	set_psr(psr | PSR_IND);
	curspl = av400_curspl[cpu];
	if (curspl < level) {
		mask = int_mask_val[level];
#ifdef MULTIPROCESSOR0
		if (cpu != master_cpu)
			mask &= SLAVE_MASK;
		mask |= AV400_SWI_IPI_MASK(cpu);
		if (level < IPL_CLOCK)
			mask |= AV400_SWI_CLOCK_IPI_MASK(cpu);
#endif

		av400_curspl[cpu] = level;
		*(u_int32_t *)AV_IEN(cpu) = av400_int_mask_reg[cpu] = mask;
	}
	/*
	 * We do not flush the pipeline here, because interrupts are disabled,
	 * and set_psr() will synchronize the pipeline.
	 */
	set_psr(psr);

	return curspl;
}

#ifdef MULTIPROCESSOR0

void
av400_send_ipi(int ipi, cpuid_t cpu)
{
	struct cpu_info *ci = &m88k_cpus[cpu];
	uint32_t bits = 0;

	if (ci->ci_ipi & ipi)
		return;

	atomic_setbits_int(&ci->ci_ipi, ipi);
	if (ipi & ~(CI_IPI_HARDCLOCK | CI_IPI_STATCLOCK))
		bits |= AV400_SWI_IPI_BIT(cpu);
	if (ipi & (CI_IPI_HARDCLOCK | CI_IPI_STATCLOCK))
		bits |= AV400_SWI_CLOCK_IPI_BIT(cpu);
	*(volatile u_int32_t *)AV400_SETSWI = bits;
}

/*
 * Process inter-processor interrupts.
 */

/*
 * Unmaskable IPIs - those are processed with interrupts disabled,
 * and no lock held.
 */
void
av400_ipi_handler(struct trapframe *eframe)
{
	struct cpu_info *ci = curcpu();
	int ipi = ci->ci_ipi & (CI_IPI_DDB | CI_IPI_NOTIFY);

	*(volatile u_int32_t *)AV400_CLRSWI = AV400_SWI_IPI_BIT(ci->ci_cpuid);
	atomic_clearbits_int(&ci->ci_ipi, ipi);

	if (ipi & CI_IPI_DDB) {
#ifdef DDB
		/*
		 * Another processor has entered DDB. Spin on the ddb lock
		 * until it is done.
		 */
		extern struct __mp_lock ddb_mp_lock;

		__mp_lock(&ddb_mp_lock);
		__mp_unlock(&ddb_mp_lock);

		/*
		 * If ddb is hoping to us, it's our turn to enter ddb now.
		 */
		if (ci->ci_cpuid == ddb_mp_nextcpu)
			Debugger();
#endif
	}
	if (ipi & CI_IPI_NOTIFY) {
		/* nothing to do */
	}
}

/*
 * Maskable IPIs
 */
void
av400_clock_ipi_handler(struct trapframe *eframe)
{
	struct cpu_info *ci = curcpu();
	int ipi = ci->ci_ipi & (CI_IPI_HARDCLOCK | CI_IPI_STATCLOCK);

	/* clear clock ipi interrupt */
	*(volatile u_int32_t *)AV400_CLRSWI =
	    AV400_SWI_CLOCK_IPI_BIT(ci->ci_cpuid);
	atomic_clearbits_int(&ci->ci_ipi, ipi);

	if (ipi & CI_IPI_HARDCLOCK)
		hardclock((struct clockframe *)eframe);
#if 0	/* no separate statclock yet */
	if (ipi & CI_IPI_STATCLOCK)
		statclock((struct clockframe *)eframe);
#endif
}

#endif

/*
 * Provide the interrupt masks for a given logical interrupt source.
 */
u_int32_t
av400_intsrc(int i)
{
	static const u_int32_t intsrc[] = {
		0,
		AV400_IRQ_ABORT,
		AV400_IRQ_ACF,
		AV400_IRQ_SF,
		AV400_IRQ_CIOI,
		AV400_IRQ_DI1,
		AV400_IRQ_DI2,
		AV400_IRQ_ECI,
		0,
		AV400_IRQ_SCI,
		AV400_IRQ_DTC,
		AV400_IRQ_VME1,
		AV400_IRQ_VME2,
		AV400_IRQ_VME3,
		AV400_IRQ_VME4,
		AV400_IRQ_VME5,
		AV400_IRQ_VME6,
		AV400_IRQ_VME7
	};

	return intsrc[i];
}

u_int32_t
av400_exintsrc(int i)
{
	return 0;
}

/*
 * Provide the interrupt source for a given interrupt status bit.
 */
static const u_int av400_obio_vec[32] = {
	0,			/* SWI0 */
	0,			/* SWI1 */
	0,
	0,
	INTSRC_VME(1),		/* VME1 */
	INTSRC_SCSI1,		/* SCI */
	INTSRC_VME(2),		/* VME2 */
	0,
	0,
	0,			/* DVB */
	INTSRC_VME(3),		/* VME3 */
	0,			/* DWP */
	INTSRC_VME(4),		/* VME4 */
	INTSRC_DMA,		/* DTC */
	INTSRC_VME(5),		/* VME5 */
	INTSRC_ETHERNET1,	/* ECI */
	INTSRC_DUART2,		/* DI2 */
	INTSRC_DUART1,		/* DI1 */
	0,			/* PPI */
	INTSRC_VME(6),		/* VME6 */
	INTSRC_SYSFAIL,		/* SF */
	INTSRC_CLOCK,		/* CIOI */
	0,			/* KBD */
	INTSRC_VME(7),		/* VME7 */
	0,			/* PAR */
	0,			/* VID */
	0,			/* ZBUF */
	0,
	0,
	0,			/* ARBTO */
	INTSRC_ACFAIL,		/* ACF */
	INTSRC_ABORT		/* ABORT */
};

/*
 * Device interrupt handler for AV400
 */

#define VME_VECTOR_MASK		0x1ff 	/* mask into VIACK register */
#define VME_BERR_MASK		0x100 	/* timeout during VME IACK cycle */

#define ISR_GET_CURRENT_MASK(cpu) \
	(*(volatile u_int *)AV_IST & av400_int_mask_reg[cpu])

void
av400_intr(struct trapframe *eframe)
{
	u_int cpu = cpu_number();
	u_int32_t cur_mask, ign_mask;
	u_int level, old_spl;
	struct intrhand *intr;
	intrhand_t *list;
	int ret, intbit;
	vaddr_t ivec;
	u_int intsrc, vec;
	int unmasked = 0;
	int warn;
#ifdef DIAGNOSTIC
	static int problems = 0;
#endif

	cur_mask = ISR_GET_CURRENT_MASK(cpu);
	ign_mask = 0;
	old_spl = eframe->tf_mask;

	if (cur_mask == 0) {
		/*
		 * Spurious interrupts - may be caused by debug output clearing
		 * DUART interrupts.
		 */
#ifdef MULTIPROCESSOR0
		if (cpu != master_cpu) {
			if (++problems >= 10) {
				printf("cpu%d: interrupt pin won't clear, "
				    "disabling processor\n", cpu);
				cpu_emergency_disable();
				/* NOTREACHED */
			}
		}
#endif
		flush_pipeline();
		goto out;
	}

	uvmexp.intrs++;

#ifdef MULTIPROCESSOR0
	/*
	 * Handle unmaskable IPIs immediately, so that we can reenable
	 * interrupts before further processing. We rely on the interrupt
	 * mask to make sure that if we get an IPI, it's really for us
	 * and no other processor.
	 */
	if (cur_mask & AV400_IPI_MASK) {
		av400_ipi_handler(eframe);
		cur_mask &= ~AV400_IPI_MASK;
		if (cur_mask == 0)
			goto out;
	}
#endif

	/*
	 * We want to service all interrupts marked in the IST register
	 * They are all valid because the mask would have prevented them
	 * from being generated otherwise.  We will service them in order of
	 * priority.
	 */
	for (;;) {
		cur_mask = ISR_GET_CURRENT_MASK(cpu);
#ifdef MULTIPROCESSOR0
		cur_mask &= ~AV400_IPI_MASK;
#endif
		if ((cur_mask & ~ign_mask) == 0)
			break;

		level = av400_safe_level(cur_mask, old_spl);
		av400_setipl(level);

		if (unmasked == 0) {
			set_psr(get_psr() & ~PSR_IND);
			unmasked = 1;
		}

#ifdef MULTIPROCESSOR0
		/*
		 * Handle pending maskable IPIs first.
		 */
		if (cur_mask & AV400_CLOCK_IPI_MASK) {
			av400_clock_ipi_handler(eframe);
			cur_mask &= ~AV400_CLOCK_IPI_MASK;
			if ((cur_mask & ~ign_mask) == 0)
				break;
		}
#endif

		/* find the first bit set in the current mask */
		warn = 0;
		intbit = ff1(cur_mask);
		intsrc = av400_obio_vec[intbit];

		if (intsrc == 0)
			panic("%s: unexpected interrupt source (bit %d), "
			    "level %d, mask 0x%b",
			    __func__, intbit, level,
			    cur_mask, AV400_IST_STRING);

		if (IS_VME_INTSRC(intsrc)) {
			level = VME_INTSRC_LEVEL(intsrc);
			ivec = AV400_VIRQLV + (level << 2);
			vec = *(volatile u_int32_t *)ivec & VME_VECTOR_MASK;
			if (vec & VME_BERR_MASK) {
				printf("%s: timeout getting VME "
				    "interrupt vector, "
				    "level %d, mask 0x%b\n",
				    __func__, level,
				    cur_mask, AV400_IST_STRING);
				ign_mask |= 1 << intbit;
				continue;
			}
			list = &vmeintr_handlers[vec];
		} else {
			list = &sysconintr_handlers[intsrc];
		}

		if (SLIST_EMPTY(list)) {
			warn = 1;
		} else {
			/*
			 * Walk through all interrupt handlers in the chain
			 * for the given vector, calling each handler in turn,
			 * until some handler returns a value != 0.
			 */
			ret = 0;
			SLIST_FOREACH(intr, list, ih_link) {
#ifdef MULTIPROCESSOR
				if (intr->ih_ipl < IPL_CLOCK)
					__mp_lock(&kernel_lock);
#endif
				if (ISSET(intr->ih_flags, INTR_WANTFRAME))
					ret = (*intr->ih_fn)((void *)eframe);
				else
					ret = (*intr->ih_fn)(intr->ih_arg);
#ifdef MULTIPROCESSOR
				if (intr->ih_ipl < IPL_CLOCK)
					__mp_unlock(&kernel_lock);
#endif
				if (ret != 0) {
					intr->ih_count.ec_count++;
					break;
				}
			}
			if (ret == 0)
				warn = 2;
		}

		if (warn != 0) {
			ign_mask |= 1 << intbit;

			if (IS_VME_INTSRC(intsrc))
				printf("%s: %s VME interrupt, "
				    "level %d, vec 0x%x, mask 0x%b\n",
				    __func__,
				    warn == 1 ? "spurious" : "unclaimed",
				    level, vec,
				    cur_mask, AV400_IST_STRING);
			else
				printf("%s: %s interrupt, "
				    "level %d, bit %d, mask 0x%b\n",
				    __func__,
				    warn == 1 ? "spurious" : "unclaimed",
				    level, intbit, cur_mask, AV400_IST_STRING);
		}
	}

#ifdef DIAGNOSTIC
	if (ign_mask != 0) {
		if (++problems >= 10)
			panic("%s: broken interrupt behaviour", __func__);
	} else
		problems = 0;
#endif

out:
	/*
	 * process any remaining data access exceptions before
	 * returning to assembler
	 */
	if (eframe->tf_dmt0 & DMT_VALID)
		m88100_trap(T_DATAFLT, eframe);

	/*
	 * Disable interrupts before returning to assembler, the spl will
	 * be restored later.
	 */
	set_psr(get_psr() | PSR_IND);
}

const struct vme_range *
av400_get_vme_ranges(void)
{
	/* no VME slots on models 100/200/300 */
	switch (cpuid) {
	case AVIION_300_310:
	case AVIION_300C_310C:
	case AVIION_300CD_310CD:
	case AVIION_300D_310D:
		return NULL;
	default:
		return vme_av400;
	}
}
@


1.28
log
@Move the logic deciding whether to grab the kernel lock or not, deeper in the
interrupt logic, making sure the lock is not taken for clock interrupts.
Tested on aviion and luna88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.27 2014/11/16 12:30:56 deraadt Exp $	*/
@


1.27
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.26 2013/10/23 10:07:14 miod Exp $	*/
a648 5
#ifdef MULTIPROCESSOR
	if (old_spl < IPL_SCHED)
		__mp_lock(&kernel_lock);
#endif

d722 4
d730 4
a767 5
#endif

#ifdef MULTIPROCESSOR
	if (old_spl < IPL_SCHED)
		__mp_unlock(&kernel_lock);
@


1.26
log
@Checkpoint of work-in-progress DMA support for oaic(4). Not working yet,
probably due to incorrect programming of the system board ``Diagnostic Control
Register'', for which I do not have documentation yet; commited so as not to
lose this work, since the machine I was testing on has apparently commited
suicide and will no longer POST.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.25 2013/10/10 21:24:58 miod Exp $	*/
d173 1
a173 1
	{ AV400_PROM,	AV400_PROM_SIZE,	UVM_PROT_RW,	CACHE_INH },
d175 1
a175 1
	{ AV400_UTILITY,AV400_UTILITY_SIZE,	UVM_PROT_RW,	CACHE_INH },
@


1.25
log
@Better boot device detection code. Board-specific code will now return the
address of a controller only know by its SCM name and number, and the boot
device detection code will now attempt to match the controller first, and
then grandchildren of it (if the boot device is a disk or a tape).
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.24 2013/10/09 21:28:33 miod Exp $	*/
d525 1
a525 1
		0,
d561 1
a561 1
	0,			/* DTC */
@


1.24
log
@Quick'n'dirty code to match trivial on-disk boot paths as the boot device.
Needs more work in order to cover all cases, but enough to get internal
disks on the first controller on models 4600 and 530 to get matched.

This makes the aviion port finally self-hosting on aforementioned models,
finally! Next step: bsd.rd...
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.23 2013/10/07 19:11:39 miod Exp $	*/
d196 1
d210 1
a210 2
	av400_ptable,
	"insc"
d310 25
@


1.23
log
@Have platform->bootstrap() return the machine speed in MHz, which is used to
set up the delay constant.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.22 2013/10/07 19:09:07 miod Exp $	*/
d209 2
a210 1
	av400_ptable
@


1.22
log
@Split the 64-bit interrupt source mask code into two 32-bit `interrupt' and
`extended interrupt' masks. This is how the hardware works, and this makes the
code simpler than attempting to aggregate them.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.21 2013/02/17 18:07:36 miod Exp $	*/
d263 1
a263 1
void
d290 19
@


1.21
log
@Constify struct cmmu.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.20 2011/01/02 13:40:05 miod Exp $	*/
d206 1
d466 1
a466 1
u_int64_t
d490 7
a496 1
	return ((u_int64_t)intsrc[i]);
@


1.20
log
@Kill pmap_table_t typedef.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.19 2010/12/31 21:38:07 miod Exp $	*/
d265 1
a265 1
	extern struct cmmu_p cmmu8820x;
@


1.19
log
@Massive overhauling of the m88k pmap, though I can't pretend it's a new pmap
since a large part of the structures and logic remains.

Since m88k has separate supervisor/user spaces, we can map physical memory 1:1
in supervisor space, and have the kernel virtual address space start from the
end of physical memory.

This allows us to switch to __HAVE_PMAP_DIRECT. And to get rid of the double
mapped sdt, since now their virtual and physical addresses will always match.

The upper bound of the kernel virtual memory space is now platform dependent,
until the code which relies upon some hardware devices being mapped 1:1 in
supervisor mode is updated to no longer require this (this is mainly a PITA on
luna88k, where onboard devices start at 0x40000000, leaving only 1GB of KVA at
the moment - still much better than the previous 512MB).

Tested on mvme88k only (187, 188, 197LE, 197DP). Other platforms ought to
work, aviion will be checked shortly and fixed if necessary. No known
OpenBSD/luna88k system in working condition at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.18 2010/04/24 18:46:51 miod Exp $	*/
d150 1
d171 1
a171 1
const pmap_table_entry
d208 1
a208 1
	av400_ptable,
@


1.18
log
@SMP support for models 4600 and 530, adapted from the MVME188 code. Models
4000 and 4300 will need more work, because they don't have as many distinct
software interrupt sources as required by this implementation, so a
different IPI scheme will be necessary.

Tested on dual-processor 4625 (AV530 family) and single processor 4300
(AV400 family).
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.17 2010/04/24 18:44:25 miod Exp $	*/
d172 1
a172 2
	{ AV400_PROM,	AV400_PROM,	AV400_PROM_SIZE,
	  UVM_PROT_RW,	CACHE_INH },
d174 1
a174 2
	{ AV400_UTILITY,AV400_UTILITY,	AV400_UTILITY_SIZE,
	  UVM_PROT_RW,	CACHE_INH },
d176 1
a176 1
	{ 0, 0, (vsize_t)-1, 0, 0 }
@


1.17
log
@Replace heuristics used to figure out which model we are running on, and
trust the cpuid value returned by the prom itself (verified against
/usr/opt/sdk/include/sys/dg_sys_info.h on a DG-UX filesystem).
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.16 2010/04/21 19:33:45 miod Exp $	*/
d162 4
d167 2
d202 4
d229 1
a229 1
#ifdef MULTIPROCESSOR
d233 1
a233 1
#define	SLAVE_MASK	0	/* AV400_IRQ_SWI0 | AV400_IRQ_SWI1 */
d301 5
d330 1
a330 1
#ifdef MULTIPROCESSOR
d333 3
d360 1
a360 1
#ifdef MULTIPROCESSOR
d363 3
d380 83
d544 1
a544 1
	int cpu = cpu_number();
d567 10
d583 20
d609 8
a616 1
	do {
d625 12
d706 1
a706 1
	} while (((cur_mask = ISR_GET_CURRENT_MASK(cpu)) & ~ign_mask) != 0);
d714 5
@


1.16
log
@More reworking of interrupt handling and VME support, and rename various
board-specific defines to prevent any risk of collision. This also adds
clock support for AV530 family, and timecounter support (cio code sync'ed
with mvme88k). And various bugs fixed in the process.

This is enough to get models 4600 and 530 to run multiuser with a Hawk
Ethernet VME card (the onboard Ethernet is not supported yet, coming soon).
There is no way to share a disk with DG/UX yet, the kernel (and fdisk(8))
needs to become aware of its ways.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.15 2010/04/18 22:04:37 miod Exp $	*/
a187 1
	"100/200/300/400/3000/4000/4300 series",
d197 1
a199 1
	vme_av400
a279 2
	cpuid = scm_cpuid();
	sysid = scm_sysid();
d576 15
@


1.15
log
@Work in progress support for AViiON models 4600 and 530.
Also features support for {awkw,bast}ard 6:1 CMMU:CPU configurations (4I2D).
Tested on model 4605, which runs up to cpu_initclocks(), which is not written
for this system family yet. No regression on model 4300.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.14 2009/02/16 22:54:59 miod Exp $	*/
d170 1
a170 1
	  UVM_PROT_RW,	CACHE_INHIBIT },
d175 12
d200 1
a200 8

	AV400_VME16_BASE,
		AV400_VME16_START,	AV400_VME16_END,
	AV400_VME24_BASE,
		AV400_VME24_START,	AV400_VME24_END,
	AV400_VME32_BASE,
		AV400_VME32_START1,	AV400_VME32_END1,
		AV400_VME32_START2,	AV400_VME32_END2
d216 1
a216 1
static u_int32_t int_mask_reg[] = { 0, 0, 0, 0 };
d224 1
a224 1
#define	SLAVE_MASK	0	/* IRQ_SWI0 | IRQ_SWI1 */
a253 2
int32_t cpuid, sysid;

d324 1
a324 1
	*(u_int32_t *)AV_IEN(cpu) = int_mask_reg[cpu] = mask;
d351 1
a351 1
		*(u_int32_t *)AV_IEN(cpu) = int_mask_reg[cpu] = mask;
d370 7
a376 7
		IRQ_ABORT,
		IRQ_ACF,
		IRQ_SF,
		IRQ_CIOI,
		IRQ_DI1,
		IRQ_DI2,
		IRQ_ECI,
d378 1
a378 1
		IRQ_SCI,
d380 7
a386 7
		IRQ_VME1,
		IRQ_VME2,
		IRQ_VME3,
		IRQ_VME4,
		IRQ_VME5,
		IRQ_VME6,
		IRQ_VME7
d395 1
a395 1
static const u_int obio_vec[32] = {
d400 1
a400 1
	INTSRC_VME,		/* VME1 */
d402 1
a402 1
	INTSRC_VME,		/* VME2 */
d406 1
a406 1
	INTSRC_VME,		/* VME3 */
d408 1
a408 1
	INTSRC_VME,		/* VME4 */
d410 1
a410 1
	INTSRC_VME,		/* VME5 */
d415 1
a415 1
	INTSRC_VME,		/* VME6 */
d417 1
a417 1
	INTSRC_CIO,		/* CIOI */
d419 1
a419 1
	INTSRC_VME,		/* VME7 */
d437 3
d490 1
a490 1
		intsrc = obio_vec[intbit];
d495 2
a496 1
			    __func__, intbit, level, cur_mask, IST_STRING);
d498 2
a499 1
		if (intsrc == INTSRC_VME) {
d507 1
a507 1
				    cur_mask, IST_STRING);
d542 1
a542 1
			if (intsrc == INTSRC_VME)
d547 2
a548 1
				    level, vec, cur_mask, IST_STRING);
d554 1
a554 1
				    level, intbit, cur_mask, IST_STRING);
@


1.14
log
@Since NMI are now handled separately, remove the ``interrupt type'' argument
from interrupt() and related function pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.13 2007/12/27 23:19:12 miod Exp $	*/
d162 1
a162 1
u_int	safe_level(u_int mask, u_int curlevel);
d186 10
a195 1
	av400_ptable
d211 1
a211 1
u_int32_t int_mask_reg[] = { 0, 0, 0, 0 };
d287 1
a287 1
safe_level(u_int mask, u_int curlevel)
d392 1
a392 1
const u_int obio_vec[32] = {
d473 1
a473 1
		level = safe_level(cur_mask, old_spl);
@


1.13
log
@Fix the spurious or unclaimed interrupt messages, I swapped them by mistake.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.12 2007/12/19 22:05:04 miod Exp $	*/
d426 1
a426 1
av400_intr(u_int v, struct trapframe *eframe)
@


1.12
log
@Overhaul interrupt handling, in order to make it (arguably) simpler and
more board design-independent.

The main changes are:
- define logical interrupt sources, which match the on-board devices as
  well as the seven VME interrupt sources. Use these whenever possible
  when registering interrupts in the drivers, so that the actual interrupt
  mask layouts are hidden.
- make the on-board and VME interrupt handlers separate. On-board interrupt
  handlers are not really associated to an interrupt vector, only to a
  given interrupt source, and only one handler can be registered for a
  logical interrupt source. On the other hand, VME interrupts come with a
  vector number, and can be shared. This allows VME devices to really use
  the whole 256 vectors space, starting at vector zero.
- update the real interrupt masks upon interrupt handler registration and
  removal, so that only interrupt sources for which a handler exists may
  be enabled.
- update the VME interrupt allocation logic to allow exclusive vector
  allocation.
- move the Z8536 clock routines to their own file, since they are not
  AV400-specific; while there, calibrate the delay constant upon startup
  for more accurate delay().

The vme driver is the only one left with AV400 tentacles left, to be fixed
very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.11 2007/12/19 21:53:36 miod Exp $	*/
d444 1
a444 2
	old_spl = av400_curspl[cpu];
	eframe->tf_mask = old_spl;
a500 1
			ign_mask |= 1 << intbit;
d529 1
a529 1
				    warn > 1 ? "spurious" : "unclaimed",
d535 1
a535 1
				    warn > 1 ? "spurious" : "unclaimed",
@


1.11
log
@Use the real physical memory size for physmem, rather than what's left after
the PROM has eaten part of it, so that the reported memory size in dmesg is
a nice round number.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.10 2007/12/13 18:51:01 miod Exp $	*/
d3 1
a3 1
 * Copyright (c) 2006, Miodrag Vallat.
d140 1
d147 1
d159 2
a160 1
#include <aviion/dev/sysconreg.h>
d181 1
a181 1
	av400_init_clocks,
d185 1
d206 1
d208 1
a208 1
 * external interrupt masks per spl.
d210 2
a211 10
u_int32_t int_mask_val[INT_LEVEL] = {
	MASK_LVL_0 & ~IRQ_CIOI,
	MASK_LVL_1 & ~IRQ_CIOI,
	MASK_LVL_2 & ~IRQ_CIOI,
	MASK_LVL_3 & ~IRQ_CIOI,
	MASK_LVL_4 & ~IRQ_CIOI,
	MASK_LVL_5 & ~IRQ_CIOI,
	MASK_LVL_6 & ~IRQ_CIOI,
	MASK_LVL_7 & ~IRQ_CIOI
};
d282 1
a282 1
	for (i = curlevel; i < INT_LEVEL; i++)
d286 1
a286 1
	return (INT_LEVEL - 1);
d308 1
a308 1
		mask &= ~SLAVE_MASK;
d335 1
a335 1
			mask &= ~SLAVE_MASK;
d351 1
a351 1
 * Device interrupt handler for AV400
d353 26
d381 1
a381 2
 * Hard coded vector table for onboard devices and hardware failure
 * interrupts.
d384 2
a385 2
	0,		/* SWI0 */
	0,		/* SWI1 */
d388 3
a390 3
	0,		/* VME1 */
	SYSCV_SCSI,	/* SCI */
	0,		/* VME2 */
d393 18
a410 18
	0,		/* DVB */
	0,		/* VME3 */
	0,		/* DWP */
	0,		/* VME4 */
	0,		/* DTC */
	0,		/* VME5 */
	SYSCV_LE,	/* ECI */
	SYSCV_SCC2,	/* DI2 */
	SYSCV_SCC,	/* DI1 */
	0,		/* PPI */
	0,		/* VME6 */
	SYSCV_SYSF,	/* SF */
	SYSCV_TIMER2,	/* CIOI */
	0,		/* KBD */
	0,		/* VME7 */
	0,		/* PAR */
	0,		/* VID */
	0,		/* ZBUF */
d413 3
a415 3
	0,		/* ARBTO */	/* no vector, but always masked */
	SYSCV_ACF,	/* ACF */
	SYSCV_ABRT	/* ABORT */
d418 4
d435 1
a435 1
	u_int vec;
d437 1
d474 1
d476 8
a483 15
		if (OBIO_INTERRUPT_MASK & (1 << intbit)) {
			vec = obio_vec[intbit];
			if (vec == 0) {
				panic("unknown onboard interrupt: mask = 0x%b",
				    1 << intbit, IST_STRING);
			}
			vec += SYSCON_VECT;
		} else if (HW_FAILURE_MASK & (1 << intbit)) {
			vec = obio_vec[intbit];
			if (vec == 0) {
				panic("unknown hardware failure: mask = 0x%b",
				    1 << intbit, IST_STRING);
			}
			vec += SYSCON_VECT;
		} else if (VME_INTERRUPT_MASK & (1 << intbit)) {
d495 1
a495 5
			if (vec == 0) {
				panic("%s: invalid VME interrupt vector, "
				    "level %d, mask 0x%b",
				    __func__, level, cur_mask, IST_STRING);
			}
d497 1
a497 3
			panic("%s: unexpected interrupt source, "
			    "level %d, mask 0x%b",
			    __func__, level, cur_mask, IST_STRING);
a499 1
		list = &intr_handlers[vec];
d501 1
a501 3
			printf("%s: spurious interrupt, "
			    "level %d, vec 0x%x, mask 0x%b\n",
			    __func__, level, vec, cur_mask, IST_STRING);
d507 1
a507 1
			 * till some handler returns a value != 0.
d511 1
a511 1
				if (intr->ih_wantframe != 0)
d520 19
a538 7
			if (ret == 0) {
				panic("%s: unclaimed interrupt, "
				    "level %d, vec %x, mask 0x%b"
				    __func__, level, vec, cur_mask, IST_STRING);
				ign_mask |= 1 << intbit;
				break;
			}
a562 173
}

/*
 * Clock routines
 */

void	av400_cio_init(u_int);
u_int	read_cio(int);
void	write_cio(int, u_int);

struct intrhand	clock_ih;

int	av400_clockintr(void *);

struct simplelock av400_cio_lock;

#define	CIO_LOCK	simple_lock(&av400_cio_lock)
#define	CIO_UNLOCK	simple_unlock(&av400_cio_lock)

/*
 * Statistics clock interval and variance, in usec.  Variance must be a
 * power of two.  Since this gives us an even number, not an odd number,
 * we discard one case and compensate.  That is, a variance of 4096 would
 * give us offsets in [0..4095].  Instead, we take offsets in [1..4095].
 * This is symmetric about the point 2048, or statvar/2, and thus averages
 * to that value (assuming uniform random numbers).
 */
int statvar = 8192;
int statmin;			/* statclock interval - 1/2*variance */

/*
 * Notes on the AV400 clock usage:
 *
 * Unlike the MVME188 design, we only have access to three counter/timers
 * in the Zilog Z8536 (since we can not receive the DUART timer interrupts).
 *
 * Clock is run on a Z8536 counter, kept in counter mode and retriggered
 * every interrupt (when using the Z8536 in timer mode, it _seems_ that it
 * resets at 0xffff instead of the initial count value...)
 *
 * It should be possible to run statclock on the Z8536 counter #2, but
 * this would make interrupt handling more tricky, in the case both
 * counters interrupt at the same time...
 */

void
av400_init_clocks(void)
{
	int s;

	simple_lock_init(&av400_cio_lock);

#ifdef DIAGNOSTIC
	if (1000000 % hz) {
		printf("cannot get %d Hz clock; using 100 Hz\n", hz);
		hz = 100;
	}
#endif
	tick = 1000000 / hz;

	av400_cio_init(tick);

	stathz = 0;

	clock_ih.ih_fn = av400_clockintr;
	clock_ih.ih_arg = 0;
	clock_ih.ih_wantframe = 1;
	clock_ih.ih_ipl = IPL_CLOCK;
	sysconintr_establish(SYSCV_TIMER2, &clock_ih, "clock");

	/* unmask CIOI interrupt */
	for (s = IPL_NONE; s < IPL_CLOCK; s++)
		int_mask_val[s] |= IRQ_CIOI;
}

int
av400_clockintr(void *eframe)
{
	CIO_LOCK;
	write_cio(CIO_CSR1, CIO_GCB | CIO_CIP);  /* Ack the interrupt */

	/* restart counter */
	write_cio(CIO_CSR1, CIO_GCB | CIO_TCB | CIO_IE);
	CIO_UNLOCK;

	hardclock(eframe);

	return (1);
}

/* Write CIO register */
void
write_cio(int reg, u_int val)
{
	int s;
	volatile int i;
	volatile u_int32_t * cio_ctrl = (volatile u_int32_t *)CIO_CTRL;

	s = splclock();
	CIO_LOCK;

	i = *cio_ctrl;				/* goto state 1 */
	*cio_ctrl = 0;				/* take CIO out of RESET */
	i = *cio_ctrl;				/* reset CIO state machine */

	*cio_ctrl = (reg & 0xff);		/* select register */
	*cio_ctrl = (val & 0xff);		/* write the value */

	CIO_UNLOCK;
	splx(s);
}

/* Read CIO register */
u_int
read_cio(int reg)
{
	int c, s;
	volatile int i;
	volatile u_int32_t * cio_ctrl = (volatile u_int32_t *)CIO_CTRL;

	s = splclock();
	CIO_LOCK;

	/* select register */
	*cio_ctrl = (reg & 0xff);
	/* delay for a short time to allow 8536 to settle */
	for (i = 0; i < 100; i++)
		;
	/* read the value */
	c = *cio_ctrl;
	CIO_UNLOCK;
	splx(s);
	return (c & 0xff);
}

/*
 * Initialize the CTC (8536)
 * Only the counter/timers are used - the IO ports are un-comitted.
 */
void
av400_cio_init(u_int period)
{
	volatile int i;

	CIO_LOCK;

	/* Start by forcing chip into known state */
	read_cio(CIO_MICR);
	write_cio(CIO_MICR, CIO_MICR_RESET);	/* Reset the CTC */
	for (i = 0; i < 1000; i++)	 	/* Loop to delay */
		;

	/* Clear reset and start init seq. */
	write_cio(CIO_MICR, 0x00);

	/* Wait for chip to come ready */
	while ((read_cio(CIO_MICR) & CIO_MICR_RJA) == 0)
		;

	/* Initialize the 8536 for real */
	write_cio(CIO_MICR,
	    CIO_MICR_MIE /* | CIO_MICR_NV */ | CIO_MICR_RJA | CIO_MICR_DLC);
	write_cio(CIO_CTMS1, CIO_CTMS_CSC);	/* Continuous count */
	write_cio(CIO_PDCB, 0xff);		/* set port B to input */

	period <<= 1;	/* CT#1 runs at PCLK/2, hence 2MHz */
	write_cio(CIO_CT1MSB, period >> 8);
	write_cio(CIO_CT1LSB, period);
	/* enable counter #1 */
	write_cio(CIO_MCCR, CIO_MCCR_CT1E | CIO_MCCR_PBE);
	write_cio(CIO_CSR1, CIO_GCB | CIO_TCB | CIO_IE);

	CIO_UNLOCK;
@


1.10
log
@Sync with the mvme188 codebase, various tweaks from the last 18 months which
had not been reported to aviion.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.9 2007/12/12 20:36:24 miod Exp $	*/
d222 1
a222 1
	vaddr_t memsize;
d224 2
a225 1
	memsize = scm_memsize(1);
d231 2
a232 1
	memsize = round_page(memsize);
d234 2
a235 1
	return (memsize);
@


1.9
log
@Mask the clock interrupts until cpu_initclocks() is invoked.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.8 2007/11/17 05:37:51 miod Exp $	*/
d274 2
a275 1
 * return next safe spl to reenable interrupts.
d311 1
a312 1
	av400_curspl[cpu] = level;
d338 1
a339 1
		av400_curspl[cpu] = level;
d436 1
a436 1
		setipl(level);
d438 1
a438 7
		/*
		 * Do not enable interrupts yet if we know, from cur_mask,
		 * that we have not cleared enough conditions yet.
		 * For now, only the timer interrupt requires its condition
		 * to be cleared before interrupts are enabled.
		 */
		if (unmasked == 0 /* && (cur_mask & whatever) == 0 */) {
a616 2
	hardclock(eframe);

d620 2
@


1.8
log
@The initial ipl on luna/mvme188 like interrupt arbiters is IPL_HIGH, not
IPL_NONE; fixes a false splassert warning on boot.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.7 2007/11/17 05:36:21 miod Exp $	*/
d205 9
a213 9
const u_int32_t int_mask_val[INT_LEVEL] = {
	MASK_LVL_0,
	MASK_LVL_1,
	MASK_LVL_2,
	MASK_LVL_3,
	MASK_LVL_4,
	MASK_LVL_5,
	MASK_LVL_6,
	MASK_LVL_7
d589 1
d610 4
@


1.7
log
@Replace many ``unsigned'' variables with ``unsigned int'', ``u_int'' or other
appropriate types. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.6 2007/11/17 05:32:04 miod Exp $	*/
d200 1
a200 1
u_int av400_curspl[] = { IPL_NONE, IPL_NONE, IPL_NONE, IPL_NONE };
@


1.6
log
@Rework {get,set,raise}ipl() to minimize psr modification, especially on
boards such as mvme1[89]7 where spl changes can be atomic.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.5 2007/05/12 20:02:12 miod Exp $	*/
d198 1
a198 1
unsigned int int_mask_reg[] = { 0, 0, 0, 0 };
d205 1
a205 1
const unsigned int int_mask_val[INT_LEVEL] = {
d357 1
a357 1
const unsigned int obio_vec[32] = {
d399 1
a399 1
	unsigned int cur_mask, ign_mask;
d547 1
a547 1
void	av400_cio_init(unsigned);
d676 1
a676 1
av400_cio_init(unsigned period)
@


1.5
log
@Change the 88100 interrupt handlers to process DAEs with interrupts enabled,
as done for DAEs not occuring during interrupts.

Remove the check for unprocessed DAE on return from trap() in eh_common.S,
since this can't happen. As a result, the return-from-trap code becomes
identical on 88100 and 88110 systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.4 2006/05/21 12:22:01 miod Exp $	*/
d200 1
a200 1
u_int av400_curspl[] = { 0, 0, 0, 0 };
d297 1
a297 1
	u_int32_t mask, curspl;
d300 2
d312 5
d324 1
a324 1
	u_int32_t mask, curspl;
d327 2
d340 6
d400 1
a400 1
	unsigned int level, old_spl;
@


1.4
log
@Move common definitions shared by the various 88100-based designs to their
own header file, and slowly make most of the code board-independent. No
functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.3 2006/05/20 12:04:51 miod Exp $	*/
a419 20

#ifdef DIAGNOSTIC
		if (level != IPL_ABORT && level <= old_spl) {
			int i;

			printf("safe level %d <= old level %d\n", level, old_spl);
			printf("cur_mask = 0x%b\n", cur_mask, IST_STRING);
			for (i = 0; i < 4; i++)
				printf("IEN%d = 0x%b\n", i, int_mask_reg[i], IST_STRING);
			printf("\nCPU0 spl %d  CPU1 spl %d  CPU2 spl %d  CPU3 spl %d\n",
			       av400_curspl[0], av400_curspl[1],
			       av400_curspl[2], av400_curspl[3]);
			for (i = 0; i < INT_LEVEL; i++)
				printf("int_mask[%d] = 0x%08x\n", i, int_mask_val[i]);
			printf("--CPU %d halted--\n", cpu_number());
			setipl(IPL_ABORT);
			for(;;) ;
		}
#endif

d513 1
a517 2
	set_psr(get_psr() | PSR_IND);
out:
d522 2
a523 2
	 * Restore the mask level to what it was when the interrupt
	 * was taken.
d525 1
a525 1
	av400_setipl(eframe->tf_mask);
@


1.3
log
@Introduce a ``struct board'' platform abstraction, to be able to support
more AViiON designs in the future.
Heuristics to tell designs apart in aviion_identify() are likely too weak,
but this is a start and AV400 still gets identified as AV400 (-:
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.2 2006/05/20 11:57:02 miod Exp $	*/
d152 2
d161 12
a172 1
struct board board_av400 = {
d181 2
a182 1
	av400_raiseipl
d248 3
d252 8
d262 1
a262 1
	*(volatile u_int32_t *)AV400_IENALL = 0;
a267 1

d308 1
a308 1
	*(u_int32_t *)AV400_IEN(cpu) = int_mask_reg[cpu] = mask;
d328 1
a328 1
		*(u_int32_t *)AV400_IEN(cpu) = int_mask_reg[cpu] = mask;
d473 7
a479 24
				/*
				 * This could be a self-inflicted interrupt.
				 * Except that we never write to VIRQV, so
				 * such things do not happen.
				 * Moreover, the AV400 design does not
				 * implement this feature.

				u_int src = 0x07 &
				    *(volatile u_int32_t *)AV400_VIRQLV;
				if (src == 0)
					vec = 0xff &
					    *(volatile u_int32_t *)AV400_VIRQV;
				else

				 */
				{
					printf("%s: timeout getting VME "
					    "interrupt vector, "
					    "level %d, mask 0x%b\n",
					    __func__, level,
					    cur_mask, IST_STRING);
					ign_mask |= 1 << intbit;
					continue;
				}
@


1.2
log
@Save the PROM VBR on startup, rather than assuming the PROM (and thus its
VBR) will always reside at the same address.
Also, when querying the PROM for the memory size, ask it for the ``user''
size - i.e. with the PROM data area taken out.
@
text
@d1 1
a1 1
/*	$OpenBSD: av400_machdep.c,v 1.1.1.1 2006/05/09 18:25:34 miod Exp $	*/
d145 1
d159 11
a169 8
void	av400_bootstrap(void);
void	av400_ext_int(u_int, struct trapframe *);
u_int	av400_getipl(void);
void	av400_init_clocks(void);
vaddr_t	av400_memsize(void);
u_int	av400_raiseipl(u_int);
u_int	av400_setipl(u_int);
void	av400_startup(void);
d186 1
a186 1
unsigned int av400_curspl[] = {0, 0, 0, 0};
a201 2
vaddr_t utilva;

a234 5
	md_interrupt_func_ptr = av400_ext_int;
	md_getipl = av400_getipl;
	md_setipl = av400_setipl;
	md_raiseipl = av400_raiseipl;
	md_init_clocks = av400_init_clocks;
d357 1
a357 1
av400_ext_int(u_int v, struct trapframe *eframe)
@


1.1
log
@Enter OpenBSD/aviion, a port to the m88k-based Data General AViiON workstations. Currently restricted to diskless serial console, tested on AV410 only; many thanks to Chris Tribo for documentation and testing.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d208 1
a208 1
	memsize = scm_memsize();
a215 5
	/*
	 * But then the PROM uses at least one full page for its own needs...
	 */
	memsize -= PAGE_SIZE;

a221 11
#if 0
	/*
	 * Supply the self-inflicted vector base. Note that since we don't
	 * use this functionality, this is not really necessary.
	 * Moreover, writing to this register in av400_bootstrap() causes
	 * an exception (and at this point we can not handle it).
	 * This might be a good way to tell 400s from 5000s!
	 */
	/* supply a vector base for av400ih */
	*(volatile u_int8_t *)AV400_VIRQV = AV400_IVEC;
#endif
@


1.1.1.1
log
@Oops, correct import this time.
@
text
@@
