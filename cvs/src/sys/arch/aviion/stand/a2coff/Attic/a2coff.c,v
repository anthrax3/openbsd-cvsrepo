head	1.14;
access;
symbols
	OPENBSD_5_8:1.13.0.8
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.4.0.8
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.16
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.14
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.12
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.8
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.10
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.6
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.2.0.6
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.4
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2
	AV400_20060509:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2015.12.01.07.50.04;	author deraadt;	state dead;
branches;
next	1.13;
commitid	Rh8AZFtVMVCiwPts;

1.13
date	2014.07.12.19.01.49;	author tedu;	state Exp;
branches;
next	1.12;
commitid	oZu656PKSRXbpZyM;

1.12
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.11;
commitid	uKVPYMN2MLxdZxzH;

1.11
date	2014.05.31.21.04.34;	author miod;	state Exp;
branches;
next	1.10;
commitid	O8HChp5psgHhcBj5;

1.10
date	2014.01.19.15.39.51;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2013.11.09.20.17.55;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2013.10.17.15.53.47;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2013.10.11.22.31.24;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2013.10.08.21.49.40;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2013.09.21.21.00.02;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.09.17.10.39;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2008.01.29.13.02.31;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.14.17.49.54;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.09.18.22.59;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.05.09.18.22.59;	author miod;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Send Aviion to same place as Nova II
discussed with jsg
@
text
@/*	$OpenBSD: a2coff.c,v 1.13 2014/07/12 19:01:49 tedu Exp $	*/
/*
 * Copyright (c) 2006, 2013, Miodrag Vallat
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Quick and dirty ELF to 88K BCS ECOFF converter. Will only work for
 * standalone binaries with no relocations, and will drop symbols.
 * Also, bss is merged into the data section to cope with PROMs which
 * do not zero-fill the bss upon loading (sad but true).
 *
 * This should really only be used to build a BSD/aviion bootloader.
 */

#include <unistd.h>
#include <stdlib.h>
#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>

#include <a.out.h>	/* ZMAGIC */
#define	ELFSIZE		32
#include <sys/exec_elf.h>

#define	MINIMAL_ALIGN	8
#define	ECOFF_ALIGN	0x200

/*
 * We can't use the standard ecoff defines, first, because the system
 * we are building this tool on might not have ecoff support at all (thus
 * no <machine/ecoff_machdep.h> file), second, because the common defines
 * do not know about the scnhdr changes for 88K BCS.
 * So we'll provide our own, working, definitions.
 */
struct ecoff_filehdr {
	u_short f_magic;	/* magic number */
	u_short f_nscns;	/* # of sections */
	u_int   f_timdat;	/* time and date stamp */
	u_long  f_symptr;	/* file offset of symbol table */
	u_int   f_nsyms;	/* # of symbol table entries */
	u_short f_opthdr;	/* sizeof the optional header */
	u_short f_flags;	/* flags??? */
};

struct ecoff_aouthdr {
	u_short magic;
	u_short vstamp;
#if 0
	ECOFF_PAD
#endif
	u_long  tsize;
	u_long  dsize;
	u_long  bsize;
	u_long  entry;
	u_long  text_start;
	u_long  data_start;
#if 0	/* not on m88k */
	u_long  bss_start;
	ECOFF_MACHDEP;
#endif
};

struct ecoff_scnhdr {		/* needed for size info */
	char	s_name[8];	/* name */
	u_long  s_paddr;	/* physical addr? for ROMing?*/
	u_long  s_vaddr;	/* virtual addr? */
	u_long  s_size;		/* size */
	u_long  s_scnptr;	/* file offset of raw data */
	u_long  s_relptr;	/* file offset of reloc data */
	u_long  s_lnnoptr;	/* file offset of line data */
#if 0
	u_short s_nreloc;	/* # of relocation entries */
	u_short s_nlnno;	/* # of line entries */
#else
	/* m88k specific changes */
	u_long  s_nreloc;
	union {
	 u_long _s_nlnno;
	 u_long _s_vendor;
	} _s_s;
#define	s_nlnno   _s_s._s_nlnno
#define	s_vendor _s_s._s_vendor 
#endif
	u_long	s_flags;
};

struct ecoff_exechdr {
	struct ecoff_filehdr f;
	struct ecoff_aouthdr a;
};

#define	round(qty, pow2)	(((qty) + (pow2 - 1)) & ~(pow2 - 1UL))

void	convert_elf(const char *, int, int, Elf_Ehdr *);
void	copybits(int, int, u_int32_t);
void	usage(void);
void	zerobits(int, u_int32_t);

int
main(int argc, char *argv[])
{
	Elf_Ehdr head;
	int infd, outfd;
	int n;

	if (argc != 3)
		usage();

	infd = open(argv[1], O_RDONLY);
	if (infd < 0)
		err(1, argv[1]);

	n = read(infd, &head, sizeof(head));
	if (n < sizeof(head))
		err(1, "read");

	if (!IS_ELF(head))
		err(1, "%s: bad magic", argv[1]);

	outfd = open(argv[2], O_WRONLY | O_TRUNC | O_CREAT, 0644);
	if (outfd < 0)
		err(1, argv[2]);

	convert_elf(argv[1], infd, outfd, &head);

	close(infd);
	close(outfd);

	exit(0);
}

char buf[4096];
#define	min(a ,b)	((a) < (b) ? (a) : (b))

void
copybits(int from, int to, u_int32_t count)
{
	int chunk;

	while (count != 0) {
		chunk = min(count, sizeof buf);
		if (read(from, buf, chunk) != chunk)
			err(1, "read");
		if (write(to, buf, chunk) != chunk)
			err(1, "write");
		count -= chunk;
	}
}

void
zerobits(int to, u_int32_t count)
{
	int chunk;

	memset(buf, 0, sizeof buf);
	while (count != 0) {
		chunk = min(count, sizeof buf);
		if (write(to, buf, chunk) != chunk)
			err(1, "write");
		count -= chunk;
	}
}

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s infile outfile\n", __progname);
	exit(1);
}

/*
 * Convert an ELF binary into BCS ECOFF format.
 * We merge all program headers into a single ECOFF section for simplicity.
 * However, PROM version 01.14 on AV4300 will fail to load a BCS binary
 * unless it has a non-empty data section, so we put the smallest possible
 * bunch of zeroes as a second section to appease it.
 */
void
convert_elf(const char *infile, int infd, int outfd, Elf_Ehdr *ehdr)
{
	struct ecoff_exechdr ehead;
	struct ecoff_scnhdr escn[2];
	Elf_Phdr *phdr;
	off_t outpos;
	uint delta, ptload;
	Elf_Addr minaddr, maxaddr;
	int n, last;

	phdr = calloc(ehdr->e_phnum, sizeof(Elf_Phdr));
	if (phdr == NULL)
		err(1, "calloc");

	for (n = 0; n < ehdr->e_phnum; n++) {
		if (lseek(infd, ehdr->e_phoff + n * ehdr->e_phentsize,
		    SEEK_SET) == (off_t) -1)
			err(1, "seek");
		if (read(infd, phdr + n, sizeof *phdr) != sizeof(*phdr))
			err(1, "read");
	}

	ptload = 0;
	for (n = 0; n < ehdr->e_phnum; n++)
		if (phdr[n].p_type == PT_LOAD)
			ptload++;
	if (ptload > 3)
		errx(1, "%s: too many PT_LOAD program headers", infile);

	maxaddr = 0;
	minaddr = (Elf_Addr)-1;

	for (n = 0; n < ehdr->e_phnum; n++) {
		if (phdr[n].p_type != PT_LOAD)
			continue;
		if (phdr[n].p_paddr < minaddr)
			minaddr = phdr[n].p_paddr;
		if (phdr[n].p_paddr + phdr[n].p_memsz > maxaddr)
			maxaddr = phdr[n].p_paddr + phdr[n].p_memsz;
	}
	maxaddr = round(maxaddr, MINIMAL_ALIGN);

	/*
	 * Header
	 */

	memset(&ehead, 0, sizeof ehead);
	memset(&escn, 0, sizeof escn);

	ehead.f.f_magic = 0x016d;		/* MC88OMAGIC */
	ehead.f.f_nscns = 2;
	ehead.f.f_opthdr = sizeof ehead.a;
	ehead.f.f_flags = 0x020f;
		/* F_RELFLG | F_EXEC | F_LNNO | 8 | F_AR16WR */

	ehead.a.magic = ZMAGIC;
	ehead.a.tsize = maxaddr - minaddr;			/* ignored */
	ehead.a.dsize = MINIMAL_ALIGN;				/* ignored */
	ehead.a.bsize = 0;					/* ignored */
	ehead.a.entry = ehdr->e_entry;
	ehead.a.text_start = minaddr;				/* ignored */
	ehead.a.data_start = maxaddr;				/* ignored */

	n = write(outfd, &ehead, sizeof(ehead));
	if (n != sizeof(ehead))
		err(1, "write");

	/*
	 * Sections
	 */

	strncpy(escn[0].s_name, ".text", sizeof escn[0].s_name);
	escn[0].s_paddr = minaddr;		/* ignored, 1:1 mapping */
	escn[0].s_size = maxaddr - minaddr;
	escn[0].s_scnptr = round(sizeof(ehead) + sizeof(escn), MINIMAL_ALIGN);
	escn[0].s_flags = 0x20;	/* STYP_TEXT */

	strncpy(escn[1].s_name, ".data", sizeof escn[1].s_name);
	escn[1].s_paddr = escn[0].s_paddr + escn[0].s_size;
	escn[1].s_size = MINIMAL_ALIGN;
	escn[1].s_scnptr = escn[0].s_scnptr + escn[0].s_size;
	escn[1].s_flags = 0x40;	/* STYP_DATA */

	/* adjust load addresses */
	escn[0].s_vaddr = escn[0].s_paddr;
	escn[1].s_vaddr = escn[1].s_paddr;

	n = write(outfd, &escn, sizeof(escn));
	if (n != sizeof(escn))
		err(1, "write");

	/*
	 * Copy ``text'' section (all PT_LOAD program headers).
	 */

	outpos = escn[0].s_scnptr;
	if (lseek(outfd, outpos, SEEK_SET) == (off_t) -1)
		err(1, "seek");
	for (n = 0, last = -1; n < ehdr->e_phnum; n++) {
		if (phdr[n].p_type != PT_LOAD)
			continue;
		if (last >= 0) {
			delta = (phdr[n].p_paddr - phdr[last].p_paddr) -
			    phdr[last].p_memsz;
			if (delta != 0) {
				zerobits(outfd, delta);
				outpos += delta;
			}
		}
#ifdef DEBUG
		printf("copying %s: source %x dest %llx size %x\n",
		    escn[0].s_name, phdr[n].p_offset, outpos, phdr[n].p_filesz);
#endif
		if (lseek(infd, phdr[n].p_offset, SEEK_SET) == (off_t) -1)
			err(1, "seek");
		copybits(infd, outfd, phdr[n].p_filesz);
		delta = phdr[n].p_memsz - phdr[n].p_filesz;
		if (delta != 0)
			zerobits(outfd, delta);
		outpos += phdr[n].p_memsz;
		last = n;
	}

	free(phdr);

	/*
	 * Fill ``data'' section.
	 */

	zerobits(outfd, escn[1].s_size);
	outpos += escn[1].s_size;

	/*
	 * Round file to a multiple of 512 bytes, since ``recent'' PROM
	 * (such as rev 1.20 on AV530) will reject files not being properly
	 * rounded to a multiple of 512 bytes.
	 */

	if ((outpos % ECOFF_ALIGN) != 0)
		zerobits(outfd, ECOFF_ALIGN - (outpos % ECOFF_ALIGN));
}
@


1.13
log
@revert bogus free changes in not kernel files. got a little trigger happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: a2coff.c,v 1.12 2014/07/12 18:44:41 tedu Exp $	*/
@


1.12
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: a2coff.c,v 1.11 2014/05/31 21:04:34 miod Exp $	*/
d327 1
a327 1
	free(phdr, 0);
@


1.11
log
@Use calloc to make sure the correct size is zeroed; Benjamin Baier
@
text
@d1 1
a1 1
/*	$OpenBSD: a2coff.c,v 1.10 2014/01/19 15:39:51 miod Exp $	*/
d327 1
a327 1
	free(phdr);
@


1.10
log
@Cope with an arbitrary number of ELF program headers, and only copy the
contents of PT_LOAD headers to the output.
@
text
@d1 1
a1 1
/*	$OpenBSD: a2coff.c,v 1.9 2013/11/09 20:17:55 miod Exp $	*/
d214 1
a214 1
	phdr = (Elf_Phdr *)malloc(ehdr->e_phnum * sizeof(Elf_Phdr));
d216 1
a216 1
		err(1, "malloc");
a217 1
	memset(phdr, 0, sizeof phdr);
@


1.9
log
@Cope with the current layout of kernel binaries (three program headers now
that .text, .rodata and .data are aligned on BATC boundaries) and merge
all phdrs into the first BCS section.
@
text
@d1 1
a1 1
/*	$OpenBSD: a2coff.c,v 1.8 2013/10/17 15:53:47 deraadt Exp $	*/
d208 1
a208 1
	Elf_Phdr phdr[3];
d210 1
a210 1
	uint delta;
d212 1
a212 1
	int n;
d214 3
a216 2
	if (ehdr->e_phnum > 3)
		errx(1, "%s: too many program headers", infile);
d223 1
a223 1
		if (read(infd, phdr + n, sizeof phdr[0]) != sizeof(phdr[0]))
d227 7
d238 2
d297 1
a297 1
	 * Copy ``text'' section (all program headers).
d303 6
a308 4
	for (n = 0; n < ehdr->e_phnum; n++) {
		if (n != 0) {
			delta = (phdr[n].p_paddr - phdr[n - 1].p_paddr) -
			    phdr[n - 1].p_memsz;
d325 1
d327 2
@


1.8
log
@the explanation for locally-defined ecoff is even simpler now that
the .h file is missing... so remove the #if 0 chunk
@
text
@d1 1
a1 1
/*	$OpenBSD: a2coff.c,v 1.7 2013/10/11 22:31:24 miod Exp $	*/
d28 1
a28 1
 * Quick and dirty a.out to 88K BCS ECOFF converter. Will only work for
d44 1
a44 7
#include <a.out.h>
/* overwrite __LDPGSZ if not a native binary */
#ifndef	m88k
#undef	__LDPGSZ
#define	__LDPGSZ	0x1000
#endif	/* m88k */

d117 1
a117 2
int	convert_aout(const char *, int, int, struct exec *);
int	convert_elf(const char *, int, int, Elf_Ehdr *);
d125 1
a125 4
	union {
		struct exec aout;
		Elf_Ehdr elf;
	} head;
a127 1
	int rc;
d140 1
a140 1
	if (!IS_ELF(head.elf) && !N_BADMAG(head.aout))
d147 1
a147 4
	if (IS_ELF(head.elf))
		rc = convert_elf(argv[1], infd, outfd, &head.elf);
	else
		rc = convert_aout(argv[1], infd, outfd, &head.aout);
d151 2
a152 1
	exit(rc);
d178 1
a178 1
	bzero(buf, sizeof buf);
d196 8
a203 140
int
convert_aout(const char *infile, int infd, int outfd, struct exec *head)
{
	struct ecoff_exechdr ehead;
	struct ecoff_scnhdr escn[3];
	off_t outpos;
	uint32_t chunk;
	int n;

	if (head->a_trsize || head->a_drsize) {
		printf("%s: has relocations\n", infile);
		return 1;
	}

	/*
	 * Header
	 */

	ehead.f.f_magic = 0x016d;		/* MC88OMAGIC */
	ehead.f.f_nscns = 3;
	ehead.f.f_timdat = 0;			/* ignored */
	ehead.f.f_symptr = 0;			/* ignored */
	ehead.f.f_nsyms = 0;			/* ignored */
	ehead.f.f_opthdr = sizeof ehead.a;
	ehead.f.f_flags = 0x020f;
		/* F_RELFLG | F_EXEC | F_LNNO | 8 | F_AR16WR */

	ehead.a.magic = N_GETMAGIC(*head);	/* ZMAGIC */
	ehead.a.vstamp = 0;			/* ignored */
	ehead.a.tsize = head->a_text;		/* ignored */
	ehead.a.dsize = head->a_data;		/* ignored */
	ehead.a.bsize = head->a_bss;		/* ignored */
	ehead.a.entry = head->a_entry;
	ehead.a.text_start = N_TXTADDR(*head);	/* ignored */
	ehead.a.data_start = N_DATADDR(*head);	/* ignored */

	n = write(outfd, &ehead, sizeof(ehead));
	if (n != sizeof(ehead))
		err(1, "write");

	/*
	 * Sections.
	 * Note that we merge .bss into .data since the PROM will not
	 * clear it and locore does not do this either.
	 */

	strncpy(escn[0].s_name, ".text", sizeof escn[0].s_name);
	escn[0].s_paddr = N_TXTADDR(*head);	/* ignored, 1:1 mapping */
	escn[0].s_size = round(head->a_text, 8);
	escn[0].s_scnptr = round(sizeof(ehead) + sizeof(escn), MINIMAL_ALIGN);
	escn[0].s_relptr = 0;
	escn[0].s_lnnoptr = 0;
	escn[0].s_nlnno = 0;
	escn[0].s_flags = 0x20;	/* STYP_TEXT */

	strncpy(escn[1].s_name, ".data", sizeof escn[1].s_name);
	escn[1].s_paddr = N_DATADDR(*head);	/* ignored, 1:1 mapping */
	escn[1].s_scnptr = escn[0].s_scnptr + escn[0].s_size;
	escn[1].s_size = round(head->a_data + head->a_bss, MINIMAL_ALIGN);
	escn[1].s_relptr = 0;
	escn[1].s_lnnoptr = 0;
	escn[1].s_nlnno = 0;
	escn[1].s_flags = 0x40;	/* STYP_DATA */

	strncpy(escn[2].s_name, ".bss", sizeof escn[2].s_name);
	escn[2].s_paddr = N_BSSADDR(*head) + head->a_bss;
						/* ignored, 1:1 mapping */
	escn[2].s_scnptr = 0;			/* nothing in the file */
	escn[2].s_size = 0;
	escn[2].s_relptr = 0;
	escn[2].s_lnnoptr = 0;
	escn[2].s_nlnno = 0;
	escn[2].s_flags = 0x80;	/* STYP_BSS */

	/* adjust load addresses */
	escn[0].s_paddr += (head->a_entry & ~(__LDPGSZ - 1)) - __LDPGSZ;
	escn[1].s_paddr += (head->a_entry & ~(__LDPGSZ - 1)) - __LDPGSZ;
	escn[2].s_paddr += (head->a_entry & ~(__LDPGSZ - 1)) - __LDPGSZ;
	escn[0].s_vaddr = escn[0].s_paddr;
	escn[1].s_vaddr = escn[1].s_paddr;
	escn[2].s_vaddr = escn[2].s_paddr;

	n = write(outfd, &escn, sizeof(escn));
	if (n != sizeof(escn))
		err(1, "write");

	/*
	 * Copy text section
	 */

#ifdef DEBUG
	printf("copying %s: source %lx dest %lx size %x\n",
	    escn[0].s_name, N_TXTOFF(*head), escn[0].s_scnptr, head->a_text);
#endif
	if (lseek(outfd, escn[0].s_scnptr, SEEK_SET) == (off_t) -1)
		err(1, "seek");
	if (lseek(infd, N_TXTOFF(*head), SEEK_SET) == (off_t) -1)
		err(1, "seek");
	copybits(infd, outfd, head->a_text);

	/*
	 * Copy data section
	 */

#ifdef DEBUG
	printf("copying %s: source %lx dest %lx size %x\n",
	    escn[1].s_name, N_DATOFF(*head), escn[1].s_scnptr, head->a_data);
#endif
	if (lseek(outfd, escn[1].s_scnptr, SEEK_SET) == (off_t) -1)
		err(1, "seek");
	outpos = escn[1].s_scnptr;
	if (lseek(infd, N_DATOFF(*head), SEEK_SET) == (off_t) -1)
		err(1, "seek");
	copybits(infd, outfd, head->a_data);
	outpos += head->a_data;

	/*
	 * ``Copy'' bss section
	 */

#ifdef DEBUG
	printf("copying %s: size %lx\n", escn[2].s_name,
	    round(head->a_data + head->a_bss, MINIMAL_ALIGN) - head->a_data);
#endif
	chunk = round(head->a_data + head->a_bss, MINIMAL_ALIGN) - head->a_data;
	zerobits(outfd, chunk);
	outpos += chunk;

	/*
	 * Round file to a multiple of 512 bytes, since older PROM
	 * (at least rev 1.20 on AV530) will reject files not being
	 * properly rounded.
	 */
	if ((outpos % ECOFF_ALIGN) != 0)
		zerobits(outfd, ECOFF_ALIGN - (outpos % ECOFF_ALIGN));

	return 0;
}

int
d208 1
a208 1
	Elf_Phdr phdr[1];
d210 2
d214 2
a215 4
	if (ehdr->e_phnum != 1) {
		printf("%s: too many program headers\n", infile);
		return 1;
	}
d226 11
d251 1
a251 1
	ehead.a.tsize = round(phdr[0].p_filesz, MINIMAL_ALIGN);	/* ignored */
d255 2
a256 2
	ehead.a.text_start = phdr[0].p_paddr;			/* ignored */
	ehead.a.data_start = phdr[0].p_paddr + ehead.a.tsize;	/* ignored */
d263 1
a263 3
	 * Sections.
	 * Note that we merge .bss into .data since the PROM may not
	 * clear it and locore does not do this either.
d267 2
a268 2
	escn[0].s_paddr = phdr[0].p_paddr;	/* ignored, 1:1 mapping */
	escn[0].s_size = round(phdr[0].p_memsz, MINIMAL_ALIGN);
a271 6
	/*
	 * PROM version 01.14 on AV4300 will fail to load a BCS binary
	 * unless it has a non-empty data section. Declare the smallest
	 * possible bunch of zeroes to appease it.
	 */

d287 1
a287 2
	 * Copy ``text'' section (first program header: text, rodata, and
	 * maybe data and bss if they are contiguous).
d290 12
d303 2
a304 3
	printf("copying %s: source %lx dest %lx size %x\n",
	    escn[0].s_name, phdr[0].p_offset, escn[0].s_scnptr,
	    phdr[0].p_filesz);
d306 8
a313 8
	if (lseek(outfd, escn[0].s_scnptr, SEEK_SET) == (off_t) -1)
		err(1, "seek");
	if (lseek(infd, phdr[0].p_offset, SEEK_SET) == (off_t) -1)
		err(1, "seek");
	copybits(infd, outfd, phdr[0].p_filesz);
	if (escn[0].s_size != phdr[0].p_filesz)
		zerobits(outfd, escn[0].s_size - phdr[0].p_filesz);
	outpos = escn[0].s_scnptr + escn[0].s_size;
a329 2

	return 0;
@


1.7
log
@When converting an ELF file, create a dummy non-empty (8 byte) .data section,
for older PROM will fail to load BCS binaries with only a .text section,
and will also fail to load an empty .data section.

Tested on AV4300.
@
text
@d1 1
a1 1
/*	$OpenBSD: a2coff.c,v 1.6 2013/10/08 21:49:40 miod Exp $	*/
a63 3
#if 0 /* defined(_KERN_DO_ECOFF) */
#include <sys/exec_ecoff.h>
#else
a119 1
#endif
@


1.6
log
@Try to be a bit more cross-compile friendly.
@
text
@d1 1
a1 1
/*	$OpenBSD: a2coff.c,v 1.5 2013/09/21 21:00:02 miod Exp $	*/
d54 1
d262 1
a262 1
	escn[0].s_scnptr = round(sizeof(ehead) + sizeof(escn), 0x10);
d271 1
a271 1
	escn[1].s_size = round(head->a_data + head->a_bss, 8);
d334 2
a335 2
	printf("copying %s: size %lx\n",
	    escn[2].s_name, round(head->a_data + head->a_bss, 8) - head->a_data);
d337 1
a337 1
	chunk = round(head->a_data + head->a_bss, 8) - head->a_data;
d357 1
a357 1
	Elf_Phdr phdr[2];
d361 1
a361 1
	if (ehdr->e_phnum > 2) {
d383 1
a383 1
	ehead.f.f_nscns = ehdr->e_phnum;
d389 3
a391 3
	ehead.a.tsize = phdr[0].p_filesz;	/* ignored */
	ehead.a.dsize = phdr[1].p_filesz;	/* ignored */
	ehead.a.bsize = 0;		/* ignored */
d393 2
a394 2
	ehead.a.text_start = phdr[0].p_paddr;	/* ignored */
	ehead.a.data_start = phdr[1].p_paddr;	/* ignored */
d408 2
a409 2
	escn[0].s_size = round(phdr[0].p_memsz, 8);
	escn[0].s_scnptr = round(sizeof(ehead) + sizeof(escn), 0x10);
d412 11
a422 7
	if (ehdr->e_phnum > 1) {
		strncpy(escn[1].s_name, ".data", sizeof escn[1].s_name);
		escn[1].s_paddr = phdr[1].p_paddr; /* ignored, 1:1 mapping */
		escn[1].s_scnptr = escn[0].s_scnptr + escn[0].s_size;
		escn[1].s_size = round(phdr[1].p_memsz, 8);
		escn[1].s_flags = 0x40;	/* STYP_DATA */
	}
d434 1
a434 1
	 * maybe data and bss if they are contiguous)
d452 1
a452 1
	 * Copy ``data'' section (second program header, if any)
d455 2
a456 15
	if (ehdr->e_phnum > 1) {
#ifdef DEBUG
		printf("copying %s: source %lx dest %lx size %x\n",
		    escn[1].s_name, phdr[1].p_offset, escn[1].s_scnptr,
		    phdr[1].p_filesz);
#endif
		if (lseek(outfd, escn[1].s_scnptr, SEEK_SET) == (off_t) -1)
			err(1, "seek");
		if (lseek(infd, phdr[1].p_offset, SEEK_SET) == (off_t) -1)
			err(1, "seek");
		copybits(infd, outfd, phdr[1].p_filesz);
		if (escn[1].s_size != phdr[1].p_filesz)
			zerobits(outfd, escn[1].s_size - phdr[1].p_filesz);
		outpos = escn[1].s_scnptr + escn[1].s_size;
	}
d459 3
a461 3
	 * Round file to a multiple of 512 bytes, since older PROM
	 * (at least rev 1.20 on AV530) will reject files not being
	 * properly rounded.
d463 1
@


1.5
log
@Grok ELF files. Good enough to netboot kernels on AV530 again.
@
text
@d1 1
a1 1
/*	$OpenBSD: a2coff.c,v 1.4 2011/10/09 17:10:39 miod Exp $	*/
d50 2
@


1.4
log
@Pad the ECOFF output file to a 512 bytes boundary; older AViiON firmware will
reject non-padded files with an irrelevant error message, and newer firmware
won't mind the extra bytes.
@
text
@d1 1
a1 1
/*	$OpenBSD: a2coff.c,v 1.3 2008/01/29 13:02:31 krw Exp $	*/
d3 1
a3 1
 * Copyright (c) 2006, Miodrag Vallat
d33 1
a33 1
 * This should really only be used to build a BSD/dg88k bootloader.
d50 1
d124 2
d133 4
a136 3
	struct exec head;
	struct ecoff_exechdr ehead;
	struct ecoff_scnhdr escn[3];
a137 2
	off_t outpos;
	uint32_t chunk;
d139 1
d148 7
d159 32
a190 3
	n = read(infd, &head, sizeof(head));
	if (n < sizeof(head))
		err(1, "read");
d192 6
a197 3
	if (N_BADMAG(head)) {
		printf("%s: bad magic number\n", argv[1]);
		exit(1);
d199 19
d219 3
a221 3
	if (head.a_trsize || head.a_drsize) {
		printf("%s: has relocations\n", argv[1]);
		exit(1);
d237 1
a237 1
	ehead.a.magic = N_GETMAGIC(head);
d239 6
a244 6
	ehead.a.tsize = head.a_text;		/* ignored */
	ehead.a.dsize = head.a_data;		/* ignored */
	ehead.a.bsize = head.a_bss;		/* ignored */
	ehead.a.entry = head.a_entry;
	ehead.a.text_start = N_TXTADDR(head);	/* ignored */
	ehead.a.data_start = N_DATADDR(head);	/* ignored */
d257 2
a258 2
	escn[0].s_paddr = N_TXTADDR(head);	/* ignored, 1:1 mapping */
	escn[0].s_size = round(head.a_text, 8);
d266 1
a266 1
	escn[1].s_paddr = N_DATADDR(head);		/* ignored, 1:1 mapping */
d268 1
a268 1
	escn[1].s_size = round(head.a_data + head.a_bss, 8);
d275 3
a277 2
	escn[2].s_paddr = N_BSSADDR(head) + head.a_bss;	/* ignored, 1:1 mapping */
	escn[2].s_scnptr = 0;		/* nothing in the file */
d285 3
a287 3
	escn[0].s_paddr += (head.a_entry & ~(__LDPGSZ - 1)) - __LDPGSZ;
	escn[1].s_paddr += (head.a_entry & ~(__LDPGSZ - 1)) - __LDPGSZ;
	escn[2].s_paddr += (head.a_entry & ~(__LDPGSZ - 1)) - __LDPGSZ;
d302 1
a302 1
	    escn[0].s_name, N_TXTOFF(head), escn[0].s_scnptr, head.a_text);
d304 5
a308 3
	lseek(outfd, escn[0].s_scnptr, SEEK_SET);
	lseek(infd, N_TXTOFF(head), SEEK_SET);
	copybits(infd, outfd, head.a_text);
d316 1
a316 1
	    escn[1].s_name, N_DATOFF(head), escn[1].s_scnptr, head.a_data);
d318 2
a319 1
	lseek(outfd, escn[1].s_scnptr, SEEK_SET);
d321 4
a324 3
	lseek(infd, N_DATOFF(head), SEEK_SET);
	copybits(infd, outfd, head.a_data);
	outpos += head.a_data;
d332 1
a332 1
	    escn[2].s_name, round(head.a_data + head.a_bss, 8) - head.a_data);
d334 1
a334 1
	chunk = round(head.a_data + head.a_bss, 8) - head.a_data;
d346 1
a346 3
	close(infd);
	close(outfd);
	exit(0);
d349 8
a356 2
char buf[4096];
#define	min(a ,b)	((a) < (b) ? (a) : (b))
d358 4
a361 4
void
copybits(int from, int to, u_int32_t count)
{
	int chunk;
d363 6
a368 3
	while (count != 0) {
		chunk = min(count, sizeof buf);
		if (read(from, buf, chunk) != chunk)
a369 3
		if (write(to, buf, chunk) != chunk)
			err(1, "write");
		count -= chunk;
a370 1
}
d372 75
a446 4
void
zerobits(int to, u_int32_t count)
{
	int chunk;
d448 14
a461 6
	bzero(buf, sizeof buf);
	while (count != 0) {
		chunk = min(count, sizeof buf);
		if (write(to, buf, chunk) != chunk)
			err(1, "write");
		count -= chunk;
a462 1
}
d464 7
a470 4
__dead void
usage(void)
{
	extern char *__progname;
d472 1
a472 2
	fprintf(stderr, "usage: %s infile outfile\n", __progname);
	exit(1);
@


1.3
log
@More read/write result checking fixes to avoid unsigned comparisons vs
-1.

ok henning@@ beck@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: a2coff.c,v 1.2 2006/05/14 17:49:54 miod Exp $	*/
d51 2
d134 2
d255 1
d258 1
d268 11
a278 1
	zerobits(outfd, round(head.a_data + head.a_bss, 8) - head.a_data);
@


1.2
log
@Deal with arbitrary load addresses. Necessary for upcoming netboot code.
@
text
@d1 1
a1 1
/*	$OpenBSD: a2coff.c,v 1.1.1.1 2006/05/09 18:22:59 miod Exp $	*/
d182 1
a182 1
	if (n < sizeof(ehead))
d227 1
a227 1
	if (n < sizeof(escn))
d279 1
a279 1
		if (read(from, buf, chunk) < chunk)
d281 1
a281 1
		if (write(to, buf, chunk) < chunk)
d295 1
a295 1
		if (write(to, buf, chunk) < chunk)
@


1.1
log
@Enter OpenBSD/aviion, a port to the m88k-based Data General AViiON workstations. Currently restricted to diskless serial console, tested on AV410 only; many thanks to Chris Tribo for documentation and testing.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a192 1
	escn[0].s_vaddr = N_TXTADDR(head);
a201 1
	escn[1].s_vaddr = N_DATADDR(head);
a210 1
	escn[2].s_vaddr = N_BSSADDR(head) + head.a_bss;
d218 8
d234 1
d237 1
d246 1
d249 1
d258 1
d261 1
@


1.1.1.1
log
@Oops, correct import this time.
@
text
@@
