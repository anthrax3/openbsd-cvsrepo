head	1.9;
access;
symbols
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.9
date	2015.12.01.07.50.04;	author deraadt;	state dead;
branches;
next	1.8;
commitid	Rh8AZFtVMVCiwPts;

1.8
date	2015.10.01.16.08.19;	author krw;	state Exp;
branches;
next	1.7;
commitid	43YBo4Ce0DxgFS6N;

1.7
date	2014.07.12.19.01.49;	author tedu;	state Exp;
branches;
next	1.6;
commitid	oZu656PKSRXbpZyM;

1.6
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.5;
commitid	uKVPYMN2MLxdZxzH;

1.5
date	2013.10.16.16.59.34;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2013.10.10.21.22.07;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2013.10.09.20.08.20;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.09.20.03.05;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.08.21.55.21;	author miod;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Send Aviion to same place as Nova II
discussed with jsg
@
text
@/*	$OpenBSD: sd.c,v 1.8 2015/10/01 16:08:19 krw Exp $	*/

/*
 * Copyright (c) 2013 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */


#include <sys/types.h>
#include <sys/param.h>
#include <stand.h>

#include "scsi.h"

int
sdopen(struct open_file *f, const char *ctrlname, int ctrl, int unit, int lun,
    int part)
{
	struct scsi_private *priv;
	struct vdm_label *vdl;
	int rc;
	char buf[DEV_BSIZE];
	char *msg;
	size_t z;

	f->f_devdata = priv = scsi_initialize(ctrlname, ctrl, unit, lun, part);
	if (priv == NULL)
		return ENXIO;

	/* send TUR */
	rc = scsi_tur(priv);
	if (rc != 0)
		return EIO;

	/* read disklabel. We expect a VDM label since this is the only way
	 * we can boot from disk.  */
	rc = scsi_read(priv, VDM_LABEL_SECTOR, sizeof buf, buf, &z);
	if (rc != 0 || z != sizeof buf)
		return EIO;

	vdl = (struct vdm_label *)(buf + VDM_LABEL_OFFSET);
	if (vdl->signature != VDM_LABEL_SIGNATURE)
		vdl = (struct vdm_label *)(buf + VDM_LABEL_OFFSET_ALT);
	if (vdl->signature != VDM_LABEL_SIGNATURE)
		return EINVAL;

	/* XXX ought to search for an OpenBSD vdmpart too. Too lazy for now */
	rc = scsi_read(priv, LABELSECTOR, sizeof buf, buf, &z);
	if (rc != 0 || z != sizeof buf)
		return EIO;

	msg = getdisklabel(buf, &priv->label);
	if (msg != NULL) {
		printf("%s\n", msg);
		return EINVAL;
	}

	return 0;
}

int
sdstrategy(void *devdata, int rw, daddr32_t blk, size_t size, void *buf,
    size_t *rsize)
{
	struct scsi_private *priv = devdata;

	if (rw != F_READ)
		return EROFS;

	blk += priv->label.d_partitions[priv->part].p_offset;

	return scsi_read(priv, blk, size, buf, rsize) != 0 ? EIO : 0;
}

int
sdclose(struct open_file *f)
{
	struct scsi_private *priv;

	if (f->f_devdata != NULL) {
		priv = (struct scsi_private *)f->f_devdata;
		if (priv->scsicookie != NULL)
			(*priv->scsidetach)(priv->scsicookie);
		free(priv, sizeof(struct scsi_private));
		f->f_devdata = NULL;
	}

	return 0;
}
@


1.8
log
@Remove more blinding trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.7 2014/07/12 19:01:49 tedu Exp $	*/
@


1.7
log
@revert bogus free changes in not kernel files. got a little trigger happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.6 2014/07/12 18:44:41 tedu Exp $	*/
d57 1
a57 1
	
@


1.6
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.5 2013/10/16 16:59:34 miod Exp $	*/
d95 1
a95 1
		free(priv, sizeof(struct scsi_private), 0);
@


1.5
log
@Support for oaic in the boot blocks. Cope with older prom putting a \r at
the end of the commandline. Clean up a few stale comments. Crank boot blocks
version to 0.3.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.4 2013/10/10 21:22:07 miod Exp $	*/
d95 1
a95 1
		free(priv, sizeof(struct scsi_private));
@


1.4
log
@Misc cleanups and small fixes. Boot controller/unit/lun information passed
to the kernel will now match the device the kernel is loaded from, not the
device the boot blocks are loaded from (this allows one to netboot the
boot blocks to boot a kernel from a local disk).
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.3 2013/10/09 20:08:20 miod Exp $	*/
a23 1
#include "libsa.h"
d37 2
a38 30
	f->f_devdata = alloc(sizeof(struct scsi_private));
	if (f->f_devdata == NULL)
		return ENOMEM;

	priv = (struct scsi_private *)f->f_devdata;
	memset(priv, 0, sizeof(struct scsi_private));
	priv->part = part;

	/* XXX provide default based upon system type */
	if (*ctrlname == '\0')
		ctrlname = "ncsc";

	if (strcmp(ctrlname, "ncsc") == 0) {
		if (ctrl == 0)
			ctrl = 0xfffb0000;
		else if (ctrl == 1)
			ctrl = 0xfffb0080;
		else
			return ENXIO;

		if (badaddr((void *)ctrl, 4) != 0)
			return ENXIO;

		/* initialize controller */
		priv->scsicookie = oosiop_attach(ctrl, unit, lun);
		priv->scsicmd = oosiop_scsicmd;
		priv->scsidetach = oosiop_detach;
	}

	if (priv->scsicookie == NULL)
@


1.3
log
@Fix build (forgot to rerun make depend)
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.2 2013/10/09 20:03:05 miod Exp $	*/
d24 1
a25 57
#include <scsi/scsi_disk.h>

static int
sdtur(struct scsi_private *priv)
{
	struct scsi_test_unit_ready cmd;
	int i, rc;

	for (i = TEST_READY_RETRIES; i != 0; i--) {
		memset(&cmd, 0, sizeof cmd);
		cmd.opcode = TEST_UNIT_READY;

		rc = (*priv->scsicmd)(priv->scsicookie,
		    &cmd, sizeof cmd, NULL, 0, NULL);
		if (rc == 0)
			break;
	}

	return rc;
}

static int
sdread(struct scsi_private *priv, daddr32_t blk, size_t size, void *buf,
    size_t *rsize)
{
	union {
		struct scsi_rw rw;
		struct scsi_rw_big rw_big;
		struct scsi_rw_12 rw_12;
	} cmd;
	int nsecs;
	size_t cmdlen;

	memset(&cmd, 0, sizeof cmd);
	nsecs = (size + DEV_BSIZE - 1) >> _DEV_BSHIFT;

	/* XXX SDEV_ONLYBIG quirk */
	if ((blk & 0x1fffff) == blk && (nsecs & 0xff) == nsecs) {
		cmd.rw.opcode = READ_COMMAND;
		_lto3b(blk, cmd.rw.addr);
		cmd.rw.length = nsecs;
		cmdlen = sizeof cmd.rw;
	} else if ((nsecs & 0xffff) == nsecs) {
		cmd.rw_big.opcode = READ_BIG;
		_lto4b(blk, cmd.rw_big.addr);
		_lto2b(nsecs, cmd.rw_big.length);
		cmdlen = sizeof cmd.rw_big;
	} else {
		cmd.rw_12.opcode = READ_12;
		_lto4b(blk, cmd.rw_12.addr);
		_lto4b(nsecs, cmd.rw_12.length);
		cmdlen = sizeof cmd.rw_12;
	}

	return (*priv->scsicmd)(priv->scsicookie,
	    &cmd, sizeof cmd, buf, size, rsize);
}
d55 6
d71 1
a71 1
	rc = sdtur(priv);
d77 1
a77 1
	rc = sdread(priv, VDM_LABEL_SECTOR, sizeof buf, buf, &z);
d88 1
a88 1
	rc = sdread(priv, LABELSECTOR, sizeof buf, buf, &z);
d112 1
a112 1
	return sdread(priv, blk, size, buf, rsize) != 0 ? EIO : 0;
@


1.2
log
@Move common SCSI defines and structs to their own header, to eventually allow
SCSI tape support.

Drop sync negotiation from oosiop code, we can run without it.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.1 2013/10/08 21:55:21 miod Exp $	*/
a22 2

#include <sys/disklabel.h>
@


1.1
log
@Early stages of a working disk bootloader for OpenBSD/aviion.
Currently limited to oosiop(4) controllers, and thus models 4600 and 530.
There are some rough edges to polish to avoid manual interaction (kernel
currently can't figure its boot device when booted from disk), but the hard
(and hair-pulling) work is over.
And we can have kernel symbols again!
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a23 5
#include <scsi/scsiconf.h>
#define	TEST_READY_RETRIES 5
#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>

d26 2
a27 13
#include "oosiop.h"

#define paddr_t uint32_t
#define vaddr_t uint32_t
#define vsize_t size_t

struct scsi_private {
	void	*scsicookie;
	int	(*scsicmd)(void *, void *, size_t, void *, size_t, size_t *);
	void	(*scsidetach)(void *);

	struct disklabel label;
};
d102 1
d162 1
a162 1
	blk += priv->label.d_partitions[0 /* XXX part */].p_offset;
@

