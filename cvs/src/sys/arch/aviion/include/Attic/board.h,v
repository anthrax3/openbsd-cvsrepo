head	1.15;
access;
symbols
	OPENBSD_5_8:1.14.0.10
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.6
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.9.0.12
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.8
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.6
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.6
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.2.0.6
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.4
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.15
date	2015.12.01.07.50.04;	author deraadt;	state dead;
branches;
next	1.14;
commitid	Rh8AZFtVMVCiwPts;

1.14
date	2013.10.23.10.07.14;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2013.10.10.21.24.59;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2013.10.09.21.28.33;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2013.10.07.19.11.42;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2013.10.07.19.09.11;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.02.13.40.07;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.24.18.46.55;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2010.04.24.18.44.27;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.21.19.33.47;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2010.04.18.22.04.39;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2009.02.16.22.55.03;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.19.22.05.06;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.21.12.22.03;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.20.12.04.54;	author miod;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Send Aviion to same place as Nova II
discussed with jsg
@
text
@/*	$OpenBSD: board.h,v 1.14 2013/10/23 10:07:14 miod Exp $	*/
/*
 * Copyright (c) 2006, 2007, Miodrag Vallat
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef	_MACHINE_BOARD_H_
#define	_MACHINE_BOARD_H_

#if !defined(_LOCORE)

/*
 * cpuid values
 */

#define	AVIION_300_310		0x7904	/* mono Maverick */
#define	AVIION_5100_6100	0x7906	/* 20MHz Topgun */
#define	AVIION_400_4000		0x7908	/* 16MHz Mav+ */
#define	AVIION_410_4100		0x790c	/* 20MHz Mav+ */
#define	AVIION_300C_310C	0x7910	/* color Maverick */
#define	AVIION_5200_6200	0x7912	/* 25MHz Topgun */
#define	AVIION_5240_6240	0x7918	/* 25MHz Shotgun */
#define	AVIION_300CD_310CD	0x7920	/* dual duart color Maverick */
#define	AVIION_300D_310D	0x7924	/* dual duart mono Maverick */
#define	AVIION_4600_530		0x7930	/* Rolling Rock */
#define	AVIION_4300_25		0x7932	/* 25MHz Terra */
#define	AVIION_4300_20		0x7934	/* 20MHz Terra */
#define	AVIION_4300_16		0x7936	/* 16MHz Terra */
#define	AVIION_5255_6255	0x7942	/* 25MHz Tophat */
#define	AVIION_350		0x7944	/* KME */
#define	AVIION_6280		0x7946	/* High Noon */
#define	AVIION_8500_9500	0x794a	/* Odyssey */
#define	AVIION_9500_HA		0x794c	/* Oz */
#define	AVIION_500		0x794e	/* Robin Hood */
#define	AVIION_5500		0x7950	/* Schooner */
#define	AVIION_450		0x7958	/* Inner Tube */
#define	AVIION_8500_9500_45_1MB	0x795a	/* 45MHz Iliad (1MB L2) */
#define	AVIION_10000		0x7960	/* Sierra */
#define	AVIION_10000_QT		0x7962	/* Sierra QT */
#define	AVIION_5500PLUS		0x7964	/* Schooner+ */
#define	AVIION_450PLUS		0x7966	/* Inner Tube+ */
#define	AVIION_8500_9500_50_1MB	0x7968	/* 50MHz Iliad (1MB L2) */
#define	AVIION_8500_9500_50_2MB	0x796a	/* 50MHz Iliad (2MB L2) */

/* did the following ever hit the market? */
#define	AVIION_UNKNOWN1		0x7926	/* mono Montezuma */
#define	AVIION_UNKNOWN2		0x7928	/* color Montezuma */
#define	AVIION_UNKNOWN3		0x7956	/* Flintstone */
#define	AVIION_UNKNOWN1_DIS	0xfff0	/* mono disabled Montezuma */
#define	AVIION_UNKNOWN2_DIS	0xfff1	/* color disabled Montezuma */

extern int32_t cpuid;

struct pmap_table;
struct vme_range;

struct board {
	u_int		(*bootstrap)(void);
	vaddr_t		(*memsize)(void);
	void		(*startup)(void);
	paddr_t		(*get_boot_device)(uint32_t *, u_int);

	void		(*intr)(struct trapframe *);
	void		(*init_clocks)(void);
	u_int		(*getipl)(void);
	u_int		(*setipl)(u_int);
	u_int		(*raiseipl)(u_int);
#ifdef	MULTIPROCESSOR
	void		(*send_ipi)(int, cpuid_t);
	void		(*smp_setup)(struct cpu_info *);
#endif

	u_int32_t	(*intsrc)(int);
	u_int32_t	(*exintsrc)(int);
	const struct vme_range *(*get_vme_ranges)(void);

	const struct pmap_table *ptable;
};

#define	md_interrupt_func(f)	platform->intr(f)

#define	DECLARE_BOARD(b) \
extern const struct board board_av##b; \
u_int	av##b##_bootstrap(void); \
vaddr_t	av##b##_memsize(void); \
void	av##b##_startup(void); \
paddr_t	av##b##_get_boot_device(uint32_t *, u_int); \
void	av##b##_intr(struct trapframe *); \
void	av##b##_init_clocks(void); \
u_int	av##b##_getipl(void); \
u_int	av##b##_setipl(u_int); \
u_int	av##b##_raiseipl(u_int); \
void	av##b##_send_ipi(int, cpuid_t); \
void	av##b##_smp_setup(struct cpu_info *); \
u_int32_t av##b##_intsrc(int); \
u_int32_t av##b##_exintsrc(int); \
const struct vme_range *av##b##_get_vme_ranges(void);

DECLARE_BOARD(400);
DECLARE_BOARD(530);
DECLARE_BOARD(5000);
DECLARE_BOARD(6280);

extern const struct board *platform;/* just to have people confuse both names */

/*
 * Logical values for interrupt sources.
 * When adding new sources, keep INTSRC_VME as the last item - syscon
 * depends on this.
 */

#define	INTSRC_ABORT		1	/* abort button */
#define	INTSRC_ACFAIL		2	/* AC failure */
#define	INTSRC_SYSFAIL		3	/* system failure */
#define	INTSRC_CLOCK		4	/* clock chip */
#define	INTSRC_DUART1		5	/* console MC68692 */
#define	INTSRC_DUART2		6	/* secondary MC68692 */
#define	INTSRC_ETHERNET1	7	/* first on-board Ethernet */
#define	INTSRC_ETHERNET2	8	/* second on-board Ethernet */
#define	INTSRC_SCSI1		9	/* first on-board SCSI controller */
#define	INTSRC_SCSI2		10	/* second on-board SCSI controller */
#define	INTSRC_DMA		11	/* DMA completion interrupt */
#define	NINTSRC_SYSCON		12	/* total number of non-VME sources */
#define	INTSRC_VME(lvl)	(NINTSRC_SYSCON + (lvl) - 1)	/* seven VME levels */

#define	IS_VME_INTSRC(intsrc)		((intsrc) >= NINTSRC_SYSCON)
#define	VME_INTSRC_LEVEL(intsrc)	((intsrc) - NINTSRC_SYSCON + 1)

void	intsrc_enable(u_int, int);
void	intsrc_disable(u_int);

void cio_init_clocks(void);
void rtc_init_clocks(void);

#endif	/* _LOCORE */
#endif	/* _MACHINE_BOARD_H_ */
@


1.14
log
@Checkpoint of work-in-progress DMA support for oaic(4). Not working yet,
probably due to incorrect programming of the system board ``Diagnostic Control
Register'', for which I do not have documentation yet; commited so as not to
lose this work, since the machine I was testing on has apparently commited
suicide and will no longer POST.
@
text
@d1 1
a1 1
/*	$OpenBSD: board.h,v 1.13 2013/10/10 21:24:59 miod Exp $	*/
@


1.13
log
@Better boot device detection code. Board-specific code will now return the
address of a controller only know by its SCM name and number, and the boot
device detection code will now attempt to match the controller first, and
then grandchildren of it (if the boot device is a disk or a tape).
@
text
@d1 1
a1 1
/*	$OpenBSD: board.h,v 1.12 2013/10/09 21:28:33 miod Exp $	*/
d142 2
a143 1
#define	NINTSRC_SYSCON		11	/* total number of non-VME sources */
@


1.12
log
@Quick'n'dirty code to match trivial on-disk boot paths as the boot device.
Needs more work in order to cover all cases, but enough to get internal
disks on the first controller on models 4600 and 530 to get matched.

This makes the aviion port finally self-hosting on aforementioned models,
finally! Next step: bsd.rd...
@
text
@d1 1
a1 1
/*	$OpenBSD: board.h,v 1.11 2013/10/07 19:11:42 miod Exp $	*/
d81 1
a97 1
	const char	*default_boot;
d107 1
@


1.11
log
@Have platform->bootstrap() return the machine speed in MHz, which is used to
set up the delay constant.
@
text
@d1 1
a1 1
/*	$OpenBSD: board.h,v 1.10 2013/10/07 19:09:11 miod Exp $	*/
d97 1
@


1.10
log
@Split the 64-bit interrupt source mask code into two 32-bit `interrupt' and
`extended interrupt' masks. This is how the hardware works, and this makes the
code simpler than attempting to aggregate them.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: board.h,v 1.9 2011/01/02 13:40:07 miod Exp $	*/
d78 1
a78 1
	void		(*bootstrap)(void);
d103 1
a103 1
void	av##b##_bootstrap(void); \
@


1.9
log
@Kill pmap_table_t typedef.
@
text
@d1 1
a1 1
/*	$OpenBSD: board.h,v 1.8 2010/04/24 18:46:55 miod Exp $	*/
d92 2
a93 1
	u_int64_t	(*intsrc)(int);
d113 2
a114 1
u_int64_t av##b##_intsrc(int); \
@


1.8
log
@SMP support for models 4600 and 530, adapted from the MVME188 code. Models
4000 and 4300 will need more work, because they don't have as many distinct
software interrupt sources as required by this implementation, so a
different IPI scheme will be necessary.

Tested on dual-processor 4625 (AV530 family) and single processor 4300
(AV400 family).
@
text
@d1 1
a1 1
/*	$OpenBSD: board.h,v 1.7 2010/04/24 18:44:27 miod Exp $	*/
d74 1
a74 1
#include <machine/pmap_table.h>
d95 1
a95 1
	pmap_table_t	ptable;
@


1.7
log
@Replace heuristics used to figure out which model we are running on, and
trust the cpuid value returned by the prom itself (verified against
/usr/opt/sdk/include/sys/dg_sys_info.h on a DG-UX filesystem).
@
text
@d1 1
a1 1
/*	$OpenBSD: board.h,v 1.6 2010/04/21 19:33:47 miod Exp $	*/
d87 4
d110 2
@


1.6
log
@More reworking of interrupt handling and VME support, and rename various
board-specific defines to prevent any risk of collision. This also adds
clock support for AV530 family, and timecounter support (cio code sync'ed
with mvme88k). And various bugs fixed in the process.

This is enough to get models 4600 and 530 to run multiuser with a Hawk
Ethernet VME card (the onboard Ethernet is not supported yet, coming soon).
There is no way to share a disk with DG/UX yet, the kernel (and fdisk(8))
needs to become aware of its ways.
@
text
@d1 1
a1 1
/*	$OpenBSD: board.h,v 1.5 2010/04/18 22:04:39 miod Exp $	*/
d32 42
a74 1

a77 1
	const char	*descr;
d89 1
a91 2

	const struct vme_range *vme_ranges;
d106 2
a107 1
u_int64_t av##b##_intsrc(int);
d114 2
a139 3

extern int32_t cpuid, sysid;
extern const struct board *platform;/* just to have people confuse both names */
@


1.5
log
@Work in progress support for AViiON models 4600 and 530.
Also features support for {awkw,bast}ard 6:1 CMMU:CPU configurations (4I2D).
Tested on model 4605, which runs up to cpu_initclocks(), which is not written
for this system family yet. No regression on model 4300.
@
text
@d1 1
a1 1
/*	$OpenBSD: board.h,v 1.4 2009/02/16 22:55:03 miod Exp $	*/
d34 2
d37 16
a52 18
	const char *descr;
	void (*bootstrap)(void);
	vaddr_t (*memsize)(void);
	void (*startup)(void);

	void (*intr)(struct trapframe *);
	void (*init_clocks)(void);
	u_int (*getipl)(void);
	u_int (*setipl)(u_int);
	u_int (*raiseipl)(u_int);

	u_int64_t (*intsrc)(int);

	pmap_table_t ptable;

	vaddr_t	vme16_base, vme16_start, vme16_end;
	vaddr_t vme24_base, vme24_start, vme24_end;
	vaddr_t vme32_base, vme32_start1, vme32_end1, vme32_start2, vme32_end2;
d83 1
a83 1
#define	INTSRC_CIO		4	/* Z8536 */
d90 5
a94 1
#define	INTSRC_VME		11	/* seven VME interrupt levels */
d99 1
d103 1
@


1.4
log
@Since NMI are now handled separately, remove the ``interrupt type'' argument
from interrupt() and related function pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: board.h,v 1.3 2007/12/19 22:05:06 miod Exp $	*/
d49 4
@


1.3
log
@Overhaul interrupt handling, in order to make it (arguably) simpler and
more board design-independent.

The main changes are:
- define logical interrupt sources, which match the on-board devices as
  well as the seven VME interrupt sources. Use these whenever possible
  when registering interrupts in the drivers, so that the actual interrupt
  mask layouts are hidden.
- make the on-board and VME interrupt handlers separate. On-board interrupt
  handlers are not really associated to an interrupt vector, only to a
  given interrupt source, and only one handler can be registered for a
  logical interrupt source. On the other hand, VME interrupts come with a
  vector number, and can be shared. This allows VME devices to really use
  the whole 256 vectors space, starting at vector zero.
- update the real interrupt masks upon interrupt handler registration and
  removal, so that only interrupt sources for which a handler exists may
  be enabled.
- update the VME interrupt allocation logic to allow exclusive vector
  allocation.
- move the Z8536 clock routines to their own file, since they are not
  AV400-specific; while there, calibrate the delay constant upon startup
  for more accurate delay().

The vme driver is the only one left with AV400 tentacles left, to be fixed
very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: board.h,v 1.2 2006/05/21 12:22:03 miod Exp $	*/
d40 1
a40 1
	void (*intr)(u_int, struct trapframe *);
d51 1
a51 1
#define	md_interrupt_func(t, f)	platform->intr(t, f)
d58 1
a58 1
void	av##b##_intr(u_int, struct trapframe *); \
@


1.2
log
@Move common definitions shared by the various 88100-based designs to their
own header file, and slowly make most of the code board-independent. No
functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: board.h,v 1.1 2006/05/20 12:04:54 miod Exp $	*/
d3 1
a3 1
 * Copyright (c) 2006, Miodrag Vallat
d46 2
d62 2
a63 1
u_int	av##b##_raiseipl(u_int);
d70 21
d92 2
@


1.1
log
@Introduce a ``struct board'' platform abstraction, to be able to support
more AViiON designs in the future.
Heuristics to tell designs apart in aviion_identify() are likely too weak,
but this is a start and AV400 still gets identified as AV400 (-:
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 2
d45 2
d52 1
a52 1
extern struct board board_av##b; \
d67 1
a67 1
extern struct board *platform;	/* just to have people confuse both names */
@

