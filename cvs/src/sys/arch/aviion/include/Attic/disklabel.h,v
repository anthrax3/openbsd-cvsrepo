head	1.15;
access;
symbols
	OPENBSD_5_8:1.13.0.10
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.11.0.10
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.8
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.6
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.4
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.4
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.10
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.12
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.8
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.6
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.4
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3
	AV400_20060509:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2015.12.01.07.50.04;	author deraadt;	state dead;
branches;
next	1.14;
commitid	Rh8AZFtVMVCiwPts;

1.14
date	2015.09.30.14.57.03;	author krw;	state Exp;
branches;
next	1.13;
commitid	DqSeHy1IhaIjFHPj;

1.13
date	2013.09.29.12.17.59;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2013.09.28.19.25.25;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2011.03.23.16.54.34;	author pirofti;	state Exp;
branches;
next	1.10;

1.10
date	2010.04.24.20.14.03;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.20.18.15.45;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.17.00.27.26;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.20.23.47.42;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.18.20.09.38;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2006.10.17.23.42.37;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.03.01.37.22;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2006.07.01.16.50.33;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.26.23.11.31;	author krw;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.09.18.32.42;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.05.09.18.32.42;	author miod;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Send Aviion to same place as Nova II
discussed with jsg
@
text
@/*	$OpenBSD: disklabel.h,v 1.14 2015/09/30 14:57:03 krw Exp $	*/

/*
 * Copyright (c) 2010 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef	_MACHINE_DISKLABEL_H_
#define	_MACHINE_DISKLABEL_H_

#define	LABELSECTOR	1	/* sector containing label */
#define	LABELOFFSET	0	/* offset of label in sector */
#define	MAXPARTITIONS	16	/* number of partitions */

/*
 * AViiON native disk identification
 */

#define	VDM_LABEL_SIGNATURE		0x1234abcd

#define	VDM_LABEL_SECTOR		0
#define	VDM_LABEL_OFFSET		0x1c8
#define	VDM_LABEL_OFFSET_ALT		0x1c0

struct vdm_label {
	uint32_t	signature;
	uint32_t	version;
	uint32_t	unused[2];
};

#define	VDM_LABEL_VERSION		0

struct vdm_boot_info {
	uint32_t	padding[6];
	uint32_t	signature;
	uint32_t	boot_start;
	uint32_t	boot_size;
	uint32_t	version;
};

#define	VDM_BOOT_INFO_VERSION		1
#define	VDM_BOOT_DEFAULT_SIZE		500

/*
 * MBR identification information is in <sys/disklabel.h>
 */

/* DG/UX VDM partition type (apparently not used on m88k AViiON) */
#define	DOSPTYP_DGUX_VDM		0xdf

/*
 * DG/UX VDM structures
 */

#define	VDIT_SECTOR			1

struct vdm_self_id {
	union {
		uint8_t			_kind;
		uint32_t		_blkno;
	} u;
	uint32_t			node_number;
} __packed;

#define	VDM_ID_KIND(id)			((id)->u._kind)
#define	VDM_BLKNO_MASK			0x00ffffff	/* low 24 bits */
#define	VDM_ID_BLKNO(id)		(((id)->u._blkno) & VDM_BLKNO_MASK)
#define	VDM_NO_NODE_NUMBER		012345670123
#define	VDM_NO_BLK_NUMBER		0xffffffff

#define	VDIT_BLOCK			0x12
#define	VDIT_PORTION_HEADER_BLOCK	0x13
#define	VDIT_BLOCK_HEAD_BE		0x14
#define	VDIT_BLOCK_HEAD_LE		0x18

struct vdit_block_header {
	struct vdm_self_id		id;
	uint32_t			nextblk;
	uint32_t			timestamp;
	uint32_t			secondary_vdit;
	uint16_t			chunksz;
	uint16_t			padding;
} __packed;

typedef uint32_t vdit_timestamp_t;
typedef uint32_t vdit_id_t;

struct vdit_entry_header {
	uint16_t			type;
	uint16_t			size;
	vdit_timestamp_t		timestamp;
} __packed;

#define	VDIT_ENTRY_SENTINEL		0x00
#define	VDIT_ENTRY_UNUSED		0x01
#define	VDIT_ENTRY_BOOT_INFO		0x02
#define	VDIT_ENTRY_SUBDRIVER_INFO	0x03
#define	VDIT_ENTRY_INSTANCE		0x04

#define	VDIT_NAME_MAX 0x20

struct vdit_instance_id {
	vdit_timestamp_t		generation_timestamp;
	vdit_id_t			system_id;
} __packed;

struct vdit_boot_info_entry {
	uint16_t			version;
	struct vdit_instance_id		default_swap;
	struct vdit_instance_id		default_root;
} __packed;

struct vdit_subdriver_entry {
	uint16_t			version;
	vdit_id_t			subdriver_id;
	char				name[VDIT_NAME_MAX];
} __packed;

#define	VDM_SUBDRIVER_VDMPHYS		"vdmphys"
#define	VDM_SUBDRIVER_VDMPART		"vdmpart"
#define	VDM_SUBDRIVER_VDMAGGR		"vdmaggr"
#define	VDM_SUBDRIVER_VDMREMAP		"vdmremap"

struct vdit_instance_entry {
	uint16_t			version;
	char				name[VDIT_NAME_MAX];
	vdit_id_t			subdriver_id;
	struct vdit_instance_id		instance_id;
	uint8_t				exported;
} __packed;

#define	VDM_INSTANCE_OPENBSD		"OpenBSD"

struct vdit_vdmphys_instance {
	struct vdit_instance_entry	instance;
	uint16_t			version;
	uint16_t			mode;
#define	VDMPHYS_MODE_READONLY	0x00
#define	VDMPHYS_MODE_READWRITE	0x01
} __packed;

struct vdit_vdmpart_instance {
	struct vdit_instance_entry	instance;
	uint16_t			version;
	struct vdit_instance_id		child_instance;
	uint32_t			start_blkno;
	uint32_t			size;
	struct vdit_instance_id		remap_instance;
} __packed;

struct vdit_vdmaggr_instance {
	struct vdit_instance_entry	instance;
	uint16_t			version;
	uint16_t			aggr_count;
	uint32_t			stripe_size;
	struct vdit_instance_id		pieces[0];
} __packed;

struct vdit_vdmremap_instance {
	struct vdit_instance_entry	instance;
	uint16_t			version;
	struct vdit_instance_id		primary_remap_table;
	struct vdit_instance_id		secondary_remap_table;
	struct vdit_instance_id		remap_area;
} __packed;

#endif	/* _MACHINE_DISKLABEL_H_ */
@


1.14
log
@Use consistant whitespace/comments for #define'ing LABELSECTOR,
LABELOFFSET and MAXPARTITIONS. Easier on the eye when scanning
through all these files. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.13 2013/09/29 12:17:59 miod Exp $	*/
@


1.13
log
@Perform more consistency checks when walking the VDIT.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.12 2013/09/28 19:25:25 miod Exp $	*/
d22 3
a24 3
#define	LABELSECTOR	1		/* sector containing label */
#define	LABELOFFSET	0		/* offset of label in sector */
#define	MAXPARTITIONS	16		/* number of partitions */
@


1.12
log
@The first step in being able to share disks with DG/UX: recognize VDM/VDIT
disk layout, and if a vdmpart instance named "OpenBSD" is found (but not a
vdmaggr!!!), assume this is the OpenBSD part of the disk and the native label
is found within it.

Native DG/UX partitions (vdmpart or vdmaggr) will NOT be reported in the
spoofed label of a shared disk.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.11 2011/03/23 16:54:34 pirofti Exp $	*/
d78 1
a78 1
#define	VDM_ID_BLKNO(id)		((id)->u._blkno) & VDM_BLKNO_MASK)
@


1.11
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.10 2010/04/24 20:14:03 miod Exp $	*/
d30 1
a30 1
#define	VDM_SIGNATURE		0x1234abcd
d32 3
a34 3
#define	VDM_DISK_VERIFICATION_SECTOR		0
#define	VDM_DISK_VERIFICATION_OFFSET		0x1c8
#define	VDM_DISK_VERIFICATION_OFFSET_ALT	0x1c0
d36 1
a36 1
struct vdm_disk_verification {
d42 1
a42 1
#define	VDM_DISK_VERSION	0
d52 2
a53 2
#define	VDM_BOOT_INFO_VERSION	1
#define	VDM_BOOT_DEFAULT_SIZE	500
d59 2
a60 2
/* DG/UX VDM partition type */
#define	DOSPTYP_DGUX_VDM	0xdf
d66 1
a66 1
#define	VDIT_SECTOR	1
d80 1
d87 1
a87 1
struct	vdit_block_header {
d96 3
d102 1
a102 1
	uint32_t			timestamp;
d114 2
a115 2
	uint32_t			generation_timestamp;
	uint32_t			system_id;
d126 1
a126 1
	uint32_t			subdriver_id;
d138 1
a138 1
	uint32_t			subdriver_id;
@


1.10
log
@AViiON VDM and VDIT defines, to be used by disksubr.c very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d19 2
a20 2
#ifndef	_AVIION_DISKLABEL_H_
#define	_AVIION_DISKLABEL_H_
d174 1
a174 1
#endif	/* _AVIION_DISKLABEL_H_ */
@


1.9
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.8 2007/06/17 00:27:26 deraadt Exp $	*/
d4 1
a4 3
 * Copyright (c) 1994 Mark Brinicombe.
 * Copyright (c) 1994 Brini.
 * All rights reserved.
d6 3
a8 1
 * This code is derived from software written for Brini by Mark Brinicombe
d10 54
a63 26
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Brini.
 * 4. The name of the company nor the name of the author may be used to
 *    endorse or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY BRINI ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL BRINI OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d66 99
a164 2
#ifndef _AVIION_DISKLABEL_H_
#define _AVIION_DISKLABEL_H_
d166 7
a172 3
#define LABELSECTOR	1		/* sector containing label */
#define LABELOFFSET	0		/* offset of label in sector */
#define MAXPARTITIONS	16		/* number of partitions */
d174 1
a174 1
#endif /* _AVIION_DISKLABEL_H_ */
@


1.8
log
@significantly simplified disklabel infrastructure.  MBR handling becomes MI
to support hotplug media on most architectures.  disklabel setup and
verification done using new helper functions.  Disklabels must *always*
have a correct checksum now.  Same code paths are used to learn on-disk
location disklabels, to avoid new errors sneaking in.  Tested on almost all
cases, testing help from todd, kettenis, krw, otto, dlg, robert, gwk, drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.7 2006/10/20 23:47:42 krw Exp $	*/
a43 3

struct cpu_disklabel {
};
@


1.7
log
@Try again with local variable to avoid alignment issues.

"The dosparts member of cpu_disklabel was not used for any persistant
data. Eliminate it, and just use the data being read in while
processing MBR and EBR records.

Should be no functional change.

ok weingart@@ deraadt@@"
@
text
@d1 1
a1 2
/*	$OpenBSD: disklabel.h,v 1.6 2006/10/18 20:09:38 deraadt Exp $	*/
/*	$NetBSD: disklabel.h,v 1.2 2001/11/25 19:02:03 thorpej Exp $	*/
a35 8
 *
 * RiscBSD kernel project
 *
 * disklabel.h
 *
 * machine specific disk label info
 *
 * Created      : 04/10/94
a43 44
#define RAW_PART	2		/* raw partition: XX?c */

/* MBR partition table */
#define	DOSBBSECTOR	0		/* MBR sector number */
#define	DOSPARTOFF	446		/* Offset of MBR partition table */
#define	NDOSPART	4		/* # of partitions in MBR */
#define	DOSMAGICOFF	510		/* Offset of magic number */
#define	DOSMAGIC	0xaa55		/* Actual magic number */
#define	MBRMAGIC	DOSMAGIC
#define DOSMBR_SIGNATURE MBRMAGIC
#define DOSMBR_SIGNATURE_OFF DOSMAGICOFF
#define	DOSACTIVE	0x80


struct dos_partition {
	u_int8_t	dp_flag;	/* bootstrap flags */
	u_int8_t	dp_shd;		/* starting head */
	u_int8_t	dp_ssect;	/* starting sector */
	u_int8_t	dp_scyl;	/* starting cylinder */
	u_int8_t	dp_typ;		/* partition type (see below) */
	u_int8_t	dp_ehd;		/* end head */
	u_int8_t	dp_esect;	/* end sector */
	u_int8_t	dp_ecyl;	/* end cylinder */
	u_int32_t	dp_start;	/* absolute starting sector number */
	u_int32_t	dp_size;	/* partition size in sectors */
};

/* Known DOS partition types. */
#define	DOSPTYP_UNUSED	0x00		/* Unused partition */
#define DOSPTYP_FAT12	0x01		/* 12-bit FAT */
#define DOSPTYP_FAT16S	0x04		/* 16-bit FAT, less than 32M */
#define DOSPTYP_EXTEND	0x05		/* Extended; contains sub-partitions */
#define DOSPTYP_FAT16B	0x06		/* 16-bit FAT, more than 32M */
#define DOSPTYP_FAT32	0x0b		/* 32-bit FAT */
#define DOSPTYP_FAT32L	0x0c		/* 32-bit FAT, LBA-mapped */
#define DOSPTYP_FAT16L	0x0e		/* 16-bit FAT, LBA-mapped */
#define DOSPTYP_EXTENDL 0x0f		/* Extended, LBA-mapped; contains sub-partitions */
#define DOSPTYP_ONTRACK	0x54
#define	DOSPTYP_LINUX	0x83		/* That other thing */
#define DOSPTYP_OPENBSD	0xa6		/* OpenBSD partition type */

/* Isolate the relevant bits to get sector and cylinder. */
#define	DPSECT(s)	((s) & 0x3f)
#define	DPCYL(c, s)	((c) + (((s) & 0xc0) << 2))
@


1.6
log
@back out disksubr changes ... since they violate strict alignment on
some architectures (kaboom); that will be fixed in the next iteration
hopefully!
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.4 2006/10/03 01:37:22 krw Exp $	*/
a98 1
	struct dos_partition dosparts[NDOSPART];
@


1.5
log
@The dosparts member of cpu_disklabel was not used for any persistant
data. Eliminate it, and just use the data being read in while
processing MBR and EBR records.

Should be no functional change.

ok weingart@@ deraadt@@
@
text
@d99 1
@


1.4
log
@Don't load bad144 bad sector information into disklabels for archs that
don't have wd* in GENERIC, since wd* is the only place such info is
being used. First step of eliminating bad144 bad sector info from all
disklabels.

'go go go' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.3 2006/07/01 16:50:33 krw Exp $	*/
a98 1
	struct dos_partition dosparts[NDOSPART];
@


1.3
log
@Eliminate redundant get_le() in favour of letoh32(). Add letoh32()
calls in alpha, hppa, hppa64 and mips63 when accessing the two DOS MBR
u_int32_t fields dp_size and dp_start.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.2 2006/06/26 23:11:31 krw Exp $	*/
a54 2
#include <sys/dkbad.h>

a99 1
	struct dkbad bad;
@


1.2
log
@Clean up some inconsistancies in definitions around DOS MBR code. No
functional change.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.1.1.1 2006/05/09 18:32:42 miod Exp $	*/
a98 14


static __inline u_int32_t get_le(void *);
static __inline u_int32_t
get_le(void *p)
{
	u_int8_t *_p = (u_int8_t *)p;
	u_int32_t x;
	x = _p[0];
	x |= _p[1] << 8;
	x |= _p[2] << 16;
	x |= _p[3] << 24;
	return x;
}
@


1.1
log
@Enter OpenBSD/aviion, a port to the m88k-based Data General AViiON workstations. Currently restricted to diskless serial console, tested on AV410 only; many thanks to Chris Tribo for documentation and testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.5 2005/11/04 13:33:59 uwe Exp $	*/
d90 1
a90 1
#define DOSPTYP_FAT16C	0x0e		/* 16-bit FAT, CHS-mapped */
d101 1
a101 1
static __inline u_int32_t get_le(void *p);
d106 1
a106 1
	int x;
a113 1
#define NMBRPART 4
d115 1
a115 1
	struct dos_partition dosparts[NMBRPART];
@


1.1.1.1
log
@Oops, correct import this time.
@
text
@@
