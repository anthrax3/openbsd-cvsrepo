head	1.19;
access;
symbols
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.12.0.14
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.10
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.8
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.4.0.8
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.10
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.6
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.3.0.6
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.4
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3
	AV400_20060509:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.12.01.07.50.03;	author deraadt;	state dead;
branches;
next	1.18;
commitid	Rh8AZFtVMVCiwPts;

1.18
date	2015.02.10.22.42.35;	author miod;	state Exp;
branches;
next	1.17;
commitid	QvtEkPTPuIHOys7J;

1.17
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.16;
commitid	C5iGb36LQxjM60Q3;

1.16
date	2014.12.24.22.48.27;	author miod;	state Exp;
branches;
next	1.15;
commitid	UHFXaGA4Bm6J6QN9;

1.15
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	yv0ECmCdICvq576h;

1.14
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.13;
commitid	uKVPYMN2MLxdZxzH;

1.13
date	2014.05.08.22.17.33;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2011.04.07.15.30.15;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.31.21.38.08;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.24.18.44.27;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2010.04.21.19.33.47;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.20.22.53.24;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2010.04.18.22.04.39;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.19.22.05.06;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.21.12.22.02;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.11.19.50.28;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.09.18.14.15;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.05.09.18.14.15;	author miod;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Send Aviion to same place as Nova II
discussed with jsg
@
text
@/*	$OpenBSD: vme.c,v 1.18 2015/02/10 22:42:35 miod Exp $	*/
/*
 * Copyright (c) 2006, 2007, 2010 Miodrag Vallat.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/extent.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/uio.h>

#include <machine/board.h>
#include <machine/bus.h>
#include <machine/conf.h>

#include <uvm/uvm_extern.h>

#include <aviion/dev/vmevar.h>

#include <machine/avcommon.h>

struct vme_softc {
	struct device	sc_dev;

	struct extent	*sc_ext_a16;
	struct extent	*sc_ext_a24;
	struct extent	*sc_ext_a32;

	const struct vme_range *sc_ranges;
};

int	vmematch(struct device *, void *, void *);
void	vmeattach(struct device *, struct device *, void *);

const struct cfattach vme_ca = {
	sizeof(struct vme_softc), vmematch, vmeattach
};

struct cfdriver vme_cd = {
	NULL, "vme", DV_DULL
};

/* minor device number encoding */
#define	AWIDTH_FIELD(minor)	(minor & 0x0f)
#define	AWIDTH(w)		((w) << 3)
#define	DWIDTH_FIELD(minor)	((minor & 0xf0) >> 4)
#define	DWIDTH(w)		((w) << 3)

uint16_t vme_d8_read_2(bus_space_tag_t, bus_space_handle_t, bus_size_t);
void	vme_d8_read_raw_2(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, uint8_t *, bus_size_t);
void	vme_d8_write_2(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    uint16_t);
void	vme_d8_write_raw_2(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, const uint8_t *, bus_size_t);
uint32_t vme_d8_read_4(bus_space_tag_t, bus_space_handle_t, bus_size_t);
void	vme_d8_write_4(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    uint32_t);
void	vme_d8_read_raw_4(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, uint8_t *, bus_size_t);
void	vme_d8_write_raw_4(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, const uint8_t *, bus_size_t);

uint32_t vme_d16_read_4(bus_space_tag_t, bus_space_handle_t, bus_size_t);
void	vme_d16_write_4(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    uint32_t);
void	vme_d16_read_raw_4(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, uint8_t *, bus_size_t);
void	vme_d16_write_raw_4(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, const uint8_t *, bus_size_t);

int	vme_a16_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
void	vme_a16_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);
int	vme_a24_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
void	vme_a24_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);
int	vme_a32_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
void	vme_a32_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);
int	vme_subregion(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    bus_size_t, bus_space_handle_t *);
void *	vme_vaddr(bus_space_tag_t, bus_space_handle_t);

int	vme_map(struct vme_softc *, struct extent *, u_int,
	    bus_addr_t, bus_size_t, int, vaddr_t *);
int	vme_map_r(const struct vme_range *, paddr_t, psize_t, int, vm_prot_t,
	    vaddr_t *);
void	vme_unmap(struct vme_softc *, struct extent *, u_int,
	    vaddr_t, paddr_t, bus_size_t);
int	vmeprint(void *, const char *);
int	vmescan(struct device *, void *, void *);

int	vmerw(struct vme_softc *, int, int, struct uio *, int);

int
vmematch(struct device *parent, void *vcf, void *aux)
{
	return (platform->get_vme_ranges() != NULL && vme_cd.cd_ndevs == 0);
}

void
vmeattach(struct device *parent, struct device *self, void *aux)
{
	struct vme_softc *sc = (struct vme_softc *)self;
	const struct vme_range *r;
	const char *fmt;
	u_int32_t ucsr;
	int i;

	/*
	 * Set up interrupt handlers.
	 */
	for (i = 0; i < NVMEINTR; i++)
		SLIST_INIT(&vmeintr_handlers[i]);

	/*
	 * Initialize extents
	 */
	sc->sc_ext_a16 = extent_create("vme a16", 0, 1 << (16 - PAGE_SHIFT),
	    M_DEVBUF, NULL, 0, EX_NOWAIT);
	if (sc->sc_ext_a16 == NULL)
		goto out1;
	sc->sc_ext_a24 = extent_create("vme a24", 0, 1 << (24 - PAGE_SHIFT),
	    M_DEVBUF, NULL, 0, EX_NOWAIT);
	if (sc->sc_ext_a24 == NULL)
		goto out2;
	sc->sc_ext_a32 = extent_create("vme a32", 0, 1 << (32 - PAGE_SHIFT),
	    M_DEVBUF, NULL, 0, EX_NOWAIT);
	if (sc->sc_ext_a32 == NULL)
		goto out3;

	/*
	 * Force a reasonable timeout for VME data transfers.
	 * We can not disable this, this would cause autoconf to hang
	 * on the first missing device we'll probe.
	 */
	ucsr = *(volatile u_int32_t*)AV_UCSR;
	ucsr = (ucsr & ~VTOSELBITS) | VTO128US;
	*(volatile u_int32_t *)AV_UCSR = ucsr;

	/*
	 * Clear EXTAD to allow VME A24 devices to access the first 16MB
	 * of memory.
	 */
	*(volatile u_int32_t *)AV_EXTAD = 0x00000000;

	/*
	 * Use supervisor data address modifiers for VME accesses.
	 */
	*(volatile u_int32_t *)AV_EXTAM = 0x0d;

	sc->sc_ranges = platform->get_vme_ranges();
	printf("\n");

	/*
	 * Display VME ranges.
	 */
	for (r = sc->sc_ranges; r->vr_width != 0; r++) {
		switch (r->vr_width) {
		default:
		case VME_A32:
			fmt = "%s: A32 %08x-%08x\n";
			break;
		case VME_A24:
			fmt = "%s: A24 %06x-%06x\n";
			break;
		case VME_A16:
			fmt = "%s: A16 %04x-%04x\n";
			break;
		}
		printf(fmt, self->dv_xname, r->vr_start, r->vr_end);
	}

	/* scan for child devices */
	config_search(vmescan, self, aux);
	return;

out3:
	extent_destroy(sc->sc_ext_a24);
out2:
	extent_destroy(sc->sc_ext_a16);
out1:
	printf(": can't allocate memory\n");
}

int
vmescan(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct vme_attach_args vaa;

	bzero(&vaa, sizeof vaa);
	vaa.vaa_addr_a16 = (vme_addr_t)cf->cf_loc[0];
	vaa.vaa_addr_a24 = (vme_addr_t)cf->cf_loc[1];
	vaa.vaa_addr_a32 = (vme_addr_t)cf->cf_loc[2];
	vaa.vaa_ipl = (u_int)cf->cf_loc[3];

	if ((*cf->cf_attach->ca_match)(parent, cf, &vaa) == 0)
		return 0;

	config_attach(parent, cf, &vaa, vmeprint);
	return 1;
}

int
vmeprint(void *aux, const char *pnp)
{
	struct vme_attach_args *vaa = aux;

	if (vaa->vaa_addr_a16 != (vme_addr_t)-1)
		printf(" a16 0x%04x", vaa->vaa_addr_a16);
	if (vaa->vaa_addr_a24 != (vme_addr_t)-1)
		printf(" a24 0x%06x", vaa->vaa_addr_a24);
	if (vaa->vaa_addr_a32 != (vme_addr_t)-1)
		printf(" a32 0x%08x", vaa->vaa_addr_a32);
	if (vaa->vaa_ipl != (u_int)-1)
		printf(" ipl %u", vaa->vaa_ipl);

	return UNCONF;
}

/*
 * Interrupt related code
 */

intrhand_t vmeintr_handlers[NVMEINTR];

int
vmeintr_allocate(u_int count, int flags, int ipl, u_int *array)
{
	u_int vec, v;
	struct intrhand *ih;

	if (count > 1 && ISSET(flags, VMEINTR_CONTIGUOUS)) {
		/*
		 * Try to find a range of count unused vectors first.
		 * If there isn't, it is not possible to provide exclusive
		 * contiguous vectors.
		 */
		for (vec = 0; vec <= NVMEINTR - count; vec++) {
			for (v = count; v != 0; v--)
				if (!SLIST_EMPTY(&vmeintr_handlers[vec + v - 1]))
					break;

			if (v == 0) {
				for (v = 0; v < count; v++)
					*array++ = vec++;
				return (0);
			}
		}
		if (ISSET(flags, VMEINTR_EXCLUSIVE))
			return EPERM;

		/*
		 * Try to find a range of count contiguous vectors,
		 * sharing the level we intend to register at. If there
		 * isn't, it is not possible to provide shared contiguous
		 * vectors.
		 */
		for (vec = 0; vec <= NVMEINTR - count; vec++) {
			for (v = count; v != 0; v--) {
				ih = SLIST_FIRST(&vmeintr_handlers[vec + v - 1]);
				if (ih == NULL)
					continue;
				if (ih->ih_ipl != ipl ||
				    ISSET(ih->ih_flags, INTR_EXCLUSIVE))
					break;
			}

			if (v == 0) {
				for (v = 0; v < count; v++)
					*array++ = vec++;
				return 0;
			}
		}
		return EPERM;
	}

	/*
	 * Pick as many unused vectors as possible.
	 */
	for (vec = 0; vec < NVMEINTR; vec++) {
		if (SLIST_EMPTY(&vmeintr_handlers[vec])) {
			*array++ = vec;
			if (--count == 0)
				return 0;
		}
	}

	/*
	 * There are not enough free vectors, so we'll have to share.
	 */
	for (vec = 0; vec < NVMEINTR; vec++) {
		ih = SLIST_FIRST(&vmeintr_handlers[vec]);
		if (ih->ih_ipl == ipl && !ISSET(ih->ih_flags, INTR_EXCLUSIVE)) {
			*array++ = vec;
			if (--count == 0)
				return 0;
		}
	}

	/*
	 * There are not enough vectors to share.
	 */
	return EPERM;
}

int
vmeintr_establish(u_int vec, struct intrhand *ih, const char *name)
{
	struct intrhand *intr;
	intrhand_t *list;

	list = &vmeintr_handlers[vec];
	intr = SLIST_FIRST(list);
	if (intr != NULL) {
		if (intr->ih_ipl != ih->ih_ipl) {
#ifdef DIAGNOSTIC
			printf("%s: can't use ipl %d for vector %x,"
			    " it uses ipl %d\n",
			    __func__, ih->ih_ipl, vec, intr->ih_ipl);
#endif
			return EINVAL;
		}
		if (ISSET(intr->ih_flags, INTR_EXCLUSIVE) ||
		    ISSET(ih->ih_flags, INTR_EXCLUSIVE))  {
#ifdef DIAGNOSTIC
			printf("%s: can't share vector %x\n", __func__, vec);
#endif
			return EINVAL;
		}
	}

	evcount_attach(&ih->ih_count, name, &ih->ih_ipl);
	SLIST_INSERT_HEAD(list, ih, ih_link);

	/*
	 * Enable VME interrupt source for this level.
	 */
	intsrc_enable(INTSRC_VME(ih->ih_ipl), ih->ih_ipl);

	return 0;
}

void
vmeintr_disestablish(u_int vec, struct intrhand *ih)
{
	struct intrhand *intr;
	intrhand_t *list;

	list = &vmeintr_handlers[vec];
	evcount_detach(&ih->ih_count);
	SLIST_REMOVE(list, ih, intrhand, ih_link);

	if (!SLIST_EMPTY(list))
		return;

	/*
	 * Walk the interrupts table to check if this level needs
	 * to be disabled.
	 */
	for (vec = 0; vec < NVMEINTR; vec++) {
		intr = SLIST_FIRST(&vmeintr_handlers[vec]);
		if (intr != NULL && intr->ih_ipl == ih->ih_ipl)
			break;
	}
	if (vec == NVMEINTR)
		intsrc_disable(INTSRC_VME(ih->ih_ipl));
}

/*
 * bus_space specific functions
 */

int
vme_a16_map(bus_space_tag_t tag, bus_addr_t addr, bus_size_t size, int flags,
    bus_space_handle_t *ret)
{
	struct vme_softc *sc = (void *)vme_cd.cd_devs[0];
	vaddr_t va;
	int rc;

	rc = vme_map(sc, sc->sc_ext_a16, VME_A16, addr, size, flags, &va);
	*ret = (bus_space_handle_t)va;
	return rc;
}

int
vme_a24_map(bus_space_tag_t tag, bus_addr_t addr, bus_size_t size, int flags,
    bus_space_handle_t *ret)
{
	struct vme_softc *sc = (void *)vme_cd.cd_devs[0];
	vaddr_t va;
	int rc;

	rc = vme_map(sc, sc->sc_ext_a24, VME_A24, addr, size, flags, &va);
	*ret = (bus_space_handle_t)va;
	return rc;
}

int
vme_a32_map(bus_space_tag_t tag, bus_addr_t addr, bus_size_t size, int flags,
    bus_space_handle_t *ret)
{
	struct vme_softc *sc = (void *)vme_cd.cd_devs[0];
	vaddr_t va;
	int rc;

	rc = vme_map(sc, sc->sc_ext_a32, VME_A32, addr, size, flags, &va);
	*ret = (bus_space_handle_t)va;
	return rc;
}

int
vme_map(struct vme_softc *sc, struct extent *ext, u_int awidth,
    bus_addr_t addr, bus_size_t size, int flags, vaddr_t *rva)
{
	const struct vme_range *r;
	int rc;
	paddr_t pa;
	psize_t offs, len;

	/*
	 * Since we need to map VME address ranges on demand, we will allocate
	 * with a page granularity.
	 */
	pa = trunc_page(addr);
	offs = addr - pa;
	len = round_page(addr + size) - pa;

	/*
	 * Check that the mapping fits within the available address ranges.
	 */
	for (r = sc->sc_ranges; r->vr_width != 0; r++) {
		if (r->vr_width == awidth &&
		    r->vr_start <= addr && r->vr_end >= addr + size - 1)
			break;
	}
	if (r->vr_width == 0)
		return EINVAL;

	/*
	 * Register this range in the per-width extent.
	 */
	if (ext != NULL) {
		rc = extent_alloc_region(ext, atop(pa), atop(len),
		    EX_NOWAIT | EX_MALLOCOK);
		if (rc != 0)
			return rc;
	}

	/*
	 * Allocate virtual memory for the range and map it.
	 */
	rc = vme_map_r(r, pa, len, flags, PROT_READ | PROT_WRITE, rva);
	if (rc != 0) {
		if (ext != NULL)
			(void)extent_free(ext, atop(pa), atop(len),
			    EX_NOWAIT | EX_MALLOCOK);
		return rc;
	}

	*rva += offs;
	return 0;
}

int
vme_map_r(const struct vme_range *r, paddr_t pa, psize_t len, int flags,
    vm_prot_t prot, vaddr_t *rva)
{
	vaddr_t ova, va;
	u_int pg;

	ova = va = uvm_km_valloc(kernel_map, len);
	if (va == 0)
		return ENOMEM;

	pa += r->vr_base;
	for (pg = atop(len); pg != 0; pg--) {
		pmap_kenter_pa(va, pa, prot);
		va += PAGE_SIZE;
		pa += PAGE_SIZE;
	}
	if (flags & BUS_SPACE_MAP_CACHEABLE)
		pmap_cache_ctrl(ova, ova + len, CACHE_GLOBAL);
	pmap_update(pmap_kernel());

	*rva = ova;

	return 0;
}

void
vme_a16_unmap(bus_space_tag_t tag, bus_space_handle_t handle, bus_size_t size)
{
	struct vme_softc *sc = (void *)vme_cd.cd_devs[0];
	vaddr_t va = (vaddr_t)handle;
	paddr_t pa;

	if (pmap_extract(pmap_kernel(), va, &pa) == FALSE)
		return;

	return vme_unmap(sc, sc->sc_ext_a16, VME_A16, va, pa, size);
}

void
vme_a24_unmap(bus_space_tag_t tag, bus_space_handle_t handle, bus_size_t size)
{
	struct vme_softc *sc = (void *)vme_cd.cd_devs[0];
	vaddr_t va = (vaddr_t)handle;
	paddr_t pa;

	if (pmap_extract(pmap_kernel(), va, &pa) == FALSE)
		return;

	return vme_unmap(sc, sc->sc_ext_a24, VME_A24, va, pa, size);
}

void
vme_a32_unmap(bus_space_tag_t tag, bus_space_handle_t handle, bus_size_t size)
{
	struct vme_softc *sc = (void *)vme_cd.cd_devs[0];
	vaddr_t va = (vaddr_t)handle;
	paddr_t pa;

	if (pmap_extract(pmap_kernel(), va, &pa) == FALSE)
		return;

	return vme_unmap(sc, sc->sc_ext_a32, VME_A32, va, pa, size);
}

void
vme_unmap(struct vme_softc *sc, struct extent *ext, u_int awidth,
    vaddr_t vaddr, paddr_t paddr, bus_size_t size)
{
	const struct vme_range *r;
	vaddr_t va;
	paddr_t pa, addr;
	psize_t len;

	va = trunc_page(vaddr);
	pa = trunc_page(paddr);
	len = round_page(paddr + size) - pa;

	/*
	 * Retrieve the address range this mapping comes from.
	 */
	for (r = sc->sc_ranges; r->vr_width != 0; r++) {
		if (r->vr_width != awidth)
			continue;
		addr = paddr - r->vr_base;
		if (r->vr_width == awidth &&
		    r->vr_start <= addr && r->vr_end >= addr + size - 1)
			break;
	}
	if (r->vr_width == 0) {
#ifdef DIAGNOSTIC
		printf("%s: nonsensical A%d mapping at va 0x%08lx pa 0x%08lx\n",
		    __func__, AWIDTH(awidth), vaddr, paddr);
#endif
		return;
	}

	/*
	 * Undo the mapping.
	 */
	pmap_kremove(va, len);
	pmap_update(pmap_kernel());
	uvm_km_free(kernel_map, va, len);

	/*
	 * Unregister mapping.
	 */
	if (ext != NULL) {
		pa -= r->vr_base;
		extent_free(ext, atop(pa), atop(len), EX_NOWAIT | EX_MALLOCOK);
	}
}

int
vme_subregion(bus_space_tag_t tag, bus_space_handle_t handle, bus_addr_t offset,
    bus_size_t size, bus_space_handle_t *ret)
{
	/* since vme_map produces linear mappings, this is safe */
	/* XXX does not check range overflow */
	*ret = handle + offset;
	return 0;
}

void *
vme_vaddr(bus_space_tag_t tag, bus_space_handle_t handle)
{
	return (void *)handle;
}

/*
 * D8 access routines
 */

uint16_t
vme_d8_read_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
{
	volatile uint8_t *addr = (volatile uint8_t *)(h + o);
	return ((uint16_t)addr[0] << 8) | ((uint16_t)addr[1]);
}

uint32_t
vme_d8_read_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
{
	volatile uint8_t *addr = (volatile uint8_t *)(h + o);
	return ((uint32_t)addr[0] << 24) | ((uint32_t)addr[1] << 16) |
	    ((uint32_t)addr[2] << 8) | ((uint32_t)addr[3]);
}

void
vme_d8_write_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    uint16_t v)
{
	volatile uint8_t *addr = (volatile uint8_t *)(h + o);
	addr[0] = v >> 8;
	addr[1] = v;
}

void
vme_d8_write_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    uint32_t v)
{
	volatile uint8_t *addr = (volatile uint8_t *)(h + o);
	addr[0] = v >> 24;
	addr[1] = v >> 16;
	addr[2] = v >> 8;
	addr[3] = v;
}

void
vme_d8_read_raw_2(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    uint8_t *buf, bus_size_t len)
{
	len >>= 1;
	while (len-- != 0) {
		*(uint16_t *)buf = vme_d8_read_2(t, h, o);
		buf += 2;
	}
}

void
vme_d8_write_raw_2(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    const uint8_t *buf, bus_size_t len)
{
	len >>= 1;
	while (len-- != 0) {
		vme_d8_write_2(t, h, o, *(uint16_t *)buf);
		buf += 2;
	}
}

void
vme_d8_read_raw_4(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    uint8_t *buf, bus_size_t len)
{
	len >>= 2;
	while (len-- != 0) {
		*(uint32_t *)buf = vme_d8_read_4(t, h, o);
		buf += 4;
	}
}

void
vme_d8_write_raw_4(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    const uint8_t *buf, bus_size_t len)
{
	len >>= 2;
	while (len-- != 0) {
		vme_d8_write_4(t, h, o, *(uint32_t *)buf);
		buf += 4;
	}
}
/*
 * D16 access routines
 */

uint32_t
vme_d16_read_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
{
	volatile uint16_t *addr = (volatile uint16_t *)(h + o);
	return ((uint32_t)addr[0] << 16) | ((uint32_t)addr[1]);
}

void
vme_d16_write_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    uint32_t v)
{
	volatile uint16_t *addr = (volatile uint16_t *)(h + o);
	addr[0] = v >> 16;
	addr[1] = v;
}

void
vme_d16_read_raw_4(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    uint8_t *buf, bus_size_t len)
{
	len >>= 2;
	while (len-- != 0) {
		*(uint32_t *)buf = vme_d16_read_4(t, h, o);
		buf += 4;
	}
}

void
vme_d16_write_raw_4(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    const uint8_t *buf, bus_size_t len)
{
	len >>= 2;
	while (len-- != 0) {
		vme_d16_write_4(t, h, o, *(uint32_t *)buf);
		buf += 4;
	}
}

/*
 * Get a bus_space_tag for the requested address and data access modes.
 */
int
vmebus_get_bst(struct device *vsc, u_int aspace, u_int dspace,
    bus_space_tag_t *bst)
{
	struct aviion_bus_space_tag *tag;

	switch (dspace) {
	case VME_D32:
	case VME_D16:
	case VME_D8:
		break;
	default:
		return EINVAL;
	}
	
	switch (aspace) {
	case VME_A32:
	case VME_A24:
	case VME_A16:
		break;
	default:
		return EINVAL;
	}

	tag = (struct aviion_bus_space_tag *)malloc(sizeof *tag, M_DEVBUF,
	    M_NOWAIT);
	if (tag == NULL)
		return ENOMEM;

	switch (aspace) {
	default:
	case VME_A32:
		tag->_space_map = vme_a32_map;
		tag->_space_unmap = vme_a32_unmap;
		break;
	case VME_A24:
		tag->_space_map = vme_a24_map;
		tag->_space_unmap = vme_a24_unmap;
		break;
	case VME_A16:
		tag->_space_map = vme_a16_map;
		tag->_space_unmap = vme_a16_unmap;
		break;
	}

	tag->_space_subregion = vme_subregion;
	tag->_space_vaddr = vme_vaddr;
	tag->_space_read_1 = generic_space_read_1;
	tag->_space_write_1 = generic_space_write_1;

	switch (dspace) {
	default:
	case VME_D32:
		tag->_space_read_2 = generic_space_read_2;
		tag->_space_write_2 = generic_space_write_2;
		tag->_space_read_4 = generic_space_read_4;
		tag->_space_write_4 = generic_space_write_4;
		tag->_space_read_raw_2 = generic_space_read_raw_2;
		tag->_space_write_raw_2 = generic_space_write_raw_2;
		tag->_space_read_raw_4 = generic_space_read_raw_4;
		tag->_space_write_raw_4 = generic_space_write_raw_4;
		break;
	case VME_D16:
		tag->_space_read_2 = generic_space_read_2;
		tag->_space_write_2 = generic_space_write_2;
		tag->_space_read_4 = vme_d16_read_4;
		tag->_space_write_4 = vme_d16_write_4;
		tag->_space_read_raw_2 = generic_space_read_raw_2;
		tag->_space_write_raw_2 = generic_space_write_raw_2;
		tag->_space_read_raw_4 = vme_d16_read_raw_4;
		tag->_space_write_raw_4 = vme_d16_write_raw_4;
		break;
	case VME_D8:
		tag->_space_read_2 = vme_d8_read_2;
		tag->_space_write_2 = vme_d8_write_2;
		tag->_space_read_4 = vme_d8_read_4;
		tag->_space_write_4 = vme_d8_write_4;
		tag->_space_read_raw_2 = vme_d8_read_raw_2;
		tag->_space_write_raw_2 = vme_d8_write_raw_2;
		tag->_space_read_raw_4 = vme_d8_read_raw_4;
		tag->_space_write_raw_4 = vme_d8_write_raw_4;
		break;
	}

	*bst = tag;
	return 0;
}

void
vmebus_release_bst(struct device *vsc, bus_space_tag_t b)
{
	free((void *)b, M_DEVBUF, sizeof(struct aviion_bus_space_tag));
}

/*
 * /dev/vme* access routines
 */

int
vmeopen(dev_t dev, int flags, int type, struct proc *p)
{
	struct vme_softc *sc;

	if (minor(dev) >= vme_cd.cd_ndevs ||
	    (sc = vme_cd.cd_devs[minor(dev)]) == NULL)
		return ENODEV;

	if (sc->sc_ranges == NULL)	/* failed attach */
		return ENODEV;

	switch (AWIDTH_FIELD(minor(dev))) {
	case VME_A32:
	case VME_A24:
	case VME_A16:
		break;
	default:
		return ENODEV;
	}

	switch (DWIDTH_FIELD(minor(dev))) {
	case VME_D32:
	case VME_D16:
	case VME_D8:
		break;
	default:
		return ENODEV;
	}

	return 0;
}

int
vmeclose(dev_t dev, int flags, int type, struct proc *p)
{
	return 0;
}

int
vmeread(dev_t dev, struct uio *uio, int flags)
{
	struct vme_softc *sc;
	int awidth, dwidth;

	sc = vme_cd.cd_devs[minor(dev)];
	awidth = AWIDTH_FIELD(minor(dev));
	dwidth = DWIDTH_FIELD(minor(dev));

	return vmerw(sc, awidth, dwidth, uio, flags);
}

int
vmewrite(dev_t dev, struct uio *uio, int flags)
{
	struct vme_softc *sc;
	int awidth, dwidth;

	sc = vme_cd.cd_devs[minor(dev)];
	awidth = AWIDTH_FIELD(minor(dev));
	dwidth = DWIDTH_FIELD(minor(dev));

	return vmerw(sc, awidth, dwidth, uio, flags);
}

int
vmerw(struct vme_softc *sc, int awidth, int dwidth, struct uio *uio, int flags)
{
	const struct vme_range *r;
	struct iovec *iov;
	psize_t delta, len;
	vaddr_t vmepg;
	int rc = 0;

	while (uio->uio_resid > 0) {
		iov = uio->uio_iov;
		if (iov->iov_len == 0) {
			uio->uio_iov++;
			uio->uio_iovcnt--;
			if (uio->uio_iovcnt < 0)
				panic("bogus uio %p", uio);
			continue;
		}

		/*
		 * Figure out which range we will be working on;
		 * if we hit the end of a range we'll report EFAULT.
		 */
		for (r = sc->sc_ranges; r->vr_width != 0; r++) {
			if (r->vr_width != awidth)
				continue;
			if ((off_t)r->vr_start <= uio->uio_offset &&
			    (off_t)r->vr_end >= uio->uio_offset)
				break;
		}
		if (r->vr_width == 0) {
			rc = EFAULT;	/* outside any valid range */
			break;
		}

		delta = uio->uio_offset & PAGE_MASK;
		len = ulmin(uio->uio_resid, PAGE_SIZE - delta);
		/* len = ulmin(len, (off_t)r->vr_end - uio->uio_offset); */

		rc = vme_map_r(r, trunc_page(uio->uio_offset), PAGE_SIZE, 0,
		    uio->uio_rw == UIO_READ ? PROT_READ : PROT_READ | PROT_WRITE,
		    &vmepg);
		if (rc != 0)
			break;

		/* XXX wrap this because of dwidth */
		rc = uiomove((caddr_t)vmepg + delta, len, uio);

		/* inline vme_unmap */
		pmap_kremove(vmepg, PAGE_SIZE);
		pmap_update(pmap_kernel());
		uvm_km_free(kernel_map, vmepg, PAGE_SIZE);

		if (rc != 0)
			break;

		iov->iov_base += len;
		iov->iov_len -= len;
		uio->uio_offset += len;
		uio->uio_resid -= len;
	}

	return rc;
}

int
vmeioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	switch (cmd) {
	default:
		return ENOTTY;
	}
}

paddr_t
vmemmap(dev_t dev, off_t off, int prot)
{
	struct vme_softc *sc;
	const struct vme_range *r;
	int awidth;

	sc = vme_cd.cd_devs[minor(dev)];
	awidth = AWIDTH_FIELD(minor(dev));

	if ((off & PAGE_MASK) != 0)
		return -1;

	/*
	 * Figure out which range we will be working on.
	 */
	for (r = sc->sc_ranges; r->vr_width != 0; r++) {
		if (r->vr_width != awidth)
			continue;
		if ((off_t)r->vr_start <= off &&
		    (off_t)r->vr_end >= off)
			break;
	}
	if (r->vr_width == 0)
		return -1;

	return r->vr_base + (paddr_t)off;
}
@


1.18
log
@Convert to uiomove().
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.16 2014/12/24 22:48:27 miod Exp $	*/
@


1.17
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d947 2
a948 2
		len = min(uio->uio_resid, PAGE_SIZE - delta);
		/* len = min(len, (off_t)r->vr_end - uio->uio_offset); */
d957 1
a957 1
		rc = uiomovei((caddr_t)vmepg + delta, len, uio);
@


1.16
log
@Pass real sizes to free().
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.15 2014/11/16 12:30:56 deraadt Exp $	*/
d957 1
a957 1
		rc = uiomove((caddr_t)vmepg + delta, len, uio);
@


1.15
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.14 2014/07/12 18:44:41 tedu Exp $	*/
d839 1
a839 1
	free((void *)b, M_DEVBUF, 0);
@


1.14
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.13 2014/05/08 22:17:33 miod Exp $	*/
d480 1
a480 1
	rc = vme_map_r(r, pa, len, flags, UVM_PROT_RW, rva);
d951 2
a952 1
		    uio->uio_rw == UIO_READ ? UVM_PROT_R : UVM_PROT_RW, &vmepg);
@


1.13
log
@Format string fixes for m88k; remove -Wno-format from the m88k kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.12 2011/04/07 15:30:15 miod Exp $	*/
d839 1
a839 1
	free((void *)b, M_DEVBUF);
@


1.12
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.11 2010/12/31 21:38:08 miod Exp $	*/
d208 1
a208 1
	printf(": can't allocate memory\n", self->dv_xname);
d583 1
a583 1
		printf("%s: non-sensical A%d mapping at va %p pa %p\n",
@


1.11
log
@Massive overhauling of the m88k pmap, though I can't pretend it's a new pmap
since a large part of the structures and logic remains.

Since m88k has separate supervisor/user spaces, we can map physical memory 1:1
in supervisor space, and have the kernel virtual address space start from the
end of physical memory.

This allows us to switch to __HAVE_PMAP_DIRECT. And to get rid of the double
mapped sdt, since now their virtual and physical addresses will always match.

The upper bound of the kernel virtual memory space is now platform dependent,
until the code which relies upon some hardware devices being mapped 1:1 in
supervisor mode is updated to no longer require this (this is mainly a PITA on
luna88k, where onboard devices start at 0x40000000, leaving only 1GB of KVA at
the moment - still much better than the previous 512MB).

Tested on mvme88k only (187, 188, 197LE, 197DP). Other platforms ought to
work, aviion will be checked shortly and fixed if necessary. No known
OpenBSD/luna88k system in working condition at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.10 2010/12/26 15:40:59 miod Exp $	*/
d500 1
a500 1
	if (va == NULL)
@


1.10
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.9 2010/09/20 06:33:47 matthew Exp $	*/
d510 1
a510 1
		pmap_cache_ctrl(pmap_kernel(), ova, ova + len, CACHE_GLOBAL);
@


1.9
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.8 2010/04/24 18:44:27 miod Exp $	*/
d1010 1
a1010 1
	return atop(r->vr_base + (paddr_t)off);
@


1.8
log
@Replace heuristics used to figure out which model we are running on, and
trust the cpuid value returned by the prom itself (verified against
/usr/opt/sdk/include/sys/dg_sys_info.h on a DG-UX filesystem).
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.7 2010/04/21 19:33:47 miod Exp $	*/
d359 1
a359 2
	evcount_attach(&ih->ih_count, name, (void *)&ih->ih_ipl,
	    &evcount_intr);
@


1.7
log
@More reworking of interrupt handling and VME support, and rename various
board-specific defines to prevent any risk of collision. This also adds
clock support for AV530 family, and timecounter support (cio code sync'ed
with mvme88k). And various bugs fixed in the process.

This is enough to get models 4600 and 530 to run multiuser with a Hawk
Ethernet VME card (the onboard Ethernet is not supported yet, coming soon).
There is no way to share a disk with DG/UX yet, the kernel (and fdisk(8))
needs to become aware of its ways.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.6 2010/04/20 22:53:24 miod Exp $	*/
d123 1
a123 2
	/* XXX no VME on AV100/AV200/AV300, though */
	return (platform->vme_ranges != NULL && vme_cd.cd_ndevs == 0);
d177 1
a177 1
	sc->sc_ranges = platform->vme_ranges;
@


1.6
log
@Add bus_dma and oosiop(4), as found on the AV530 family. Tested on model 4605.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.5 2010/04/18 22:04:39 miod Exp $	*/
d3 1
a3 1
 * Copyright (c) 2006, 2007, Miodrag Vallat.
a26 4
/*
 * XXX TODO: Finish /dev/vme{a16,a24,a32}{d8,d16,d32} interface.
 */

d46 1
a46 1
struct vmesoftc {
d52 2
d59 2
a60 2
struct cfattach vme_ca = {
	sizeof(struct vmesoftc), vmematch, vmeattach
d67 6
d109 6
a114 3
int	vme_map(struct extent *, paddr_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
void	vme_unmap(struct extent *, vme_addr_t, vaddr_t, bus_size_t);
d118 2
d124 1
a124 1
	return (vme_cd.cd_ndevs == 0);
d130 3
a132 1
	struct vmesoftc *sc = (struct vmesoftc *)self;
a135 2
	printf("\n");

d147 2
d151 2
d155 2
d178 3
d184 15
a198 8
	printf("%s: A32 %08x-%08x\n", self->dv_xname,
	    platform->vme32_start1, platform->vme32_end1);
	printf("%s: A32 %08x-%08x\n", self->dv_xname,
	    platform->vme32_start2, platform->vme32_end2);
	printf("%s: A24 %08x-%08x\n", self->dv_xname,
	    platform->vme24_start, platform->vme24_end);
	printf("%s: A16 %08x-%08x\n", self->dv_xname,
	    platform->vme16_start, platform->vme16_end);
d202 8
d225 1
a225 1
		return (0);
d228 1
a228 1
	return (1);
d245 1
a245 1
	return (UNCONF);
d278 1
a278 1
			return (EPERM);
d299 1
a299 1
				return (0);
d302 1
a302 1
		return (EPERM);
d312 1
a312 1
				return (0);
d324 1
a324 1
				return (0);
d331 1
a331 1
	return (EPERM);
d349 1
a349 1
			return (EINVAL);
d356 1
a356 1
			return (EINVAL);
d367 1
a367 1
	intsrc_enable(INTSRC_VME + (ih->ih_ipl - 1), ih->ih_ipl);
d369 1
a369 1
	return (0);
d395 1
a395 1
		intsrc_disable(INTSRC_VME + (ih->ih_ipl - 1));
a401 8
#define	ISVMEA32(addr) \
	(((addr) >= platform->vme32_start1 && (addr) <= platform->vme32_end1) || \
	 ((addr) >= platform->vme32_start2 && (addr) <= platform->vme32_end2))
#define	ISVMEA24(addr) \
	((addr) >= platform->vme24_start && (addr) <= platform->vme24_end)
#define	ISVMEA16(addr) \
	((addr) >= platform->vme16_start && (addr) <= platform->vme16_end)

d406 3
a408 1
	struct vmesoftc *sc = (void *)vme_cd.cd_devs[0];
d410 3
a412 5
	if (ISVMEA16(addr) && ISVMEA16(addr + size - 1))
		return vme_map(sc->sc_ext_a16, addr + platform->vme16_base,
		    addr, size, flags, ret);

	return EINVAL;
d419 3
a421 1
	struct vmesoftc *sc = (void *)vme_cd.cd_devs[0];
d423 3
a425 5
	if (ISVMEA24(addr) && ISVMEA24(addr + size - 1))
		return vme_map(sc->sc_ext_a24, addr + platform->vme24_base,
		    addr, size, flags, ret);

	return EINVAL;
d432 3
a434 1
	struct vmesoftc *sc = (void *)vme_cd.cd_devs[0];
d436 3
a438 5
	if (ISVMEA32(addr) && ISVMEA32(addr + size - 1))
		return vme_map(sc->sc_ext_a32, addr + platform->vme32_base,
		    addr, size, flags, ret);

	return EINVAL;
d442 2
a443 2
vme_map(struct extent *ext, paddr_t paddr, bus_addr_t addr, bus_size_t size,
    int flags, bus_space_handle_t *ret)
d445 1
d448 9
a456 3
	psize_t len;
	vaddr_t ova, va;
	u_int pg;
d458 10
a467 2
	pa = trunc_page(paddr);
	len = round_page(paddr + size) - pa;
d469 3
d473 1
a473 1
		rc = extent_alloc_region(ext, atop(addr), atop(len),
d476 1
a476 1
			return (rc);
d479 9
a487 4
	ova = va = uvm_km_valloc(kernel_map, len);
	if (va == NULL) {
		rc = ENOMEM;
		goto fail;
d490 14
a503 1
	*ret = (bus_space_handle_t)va;
d505 1
d507 1
a507 1
		pmap_kenter_pa(va, pa, UVM_PROT_RW);
d515 1
a515 1
	return (0);
d517 1
a517 4
fail:
	if (ext != NULL)
		extent_free(ext, atop(addr), atop(len), EX_NOWAIT | EX_MALLOCOK);
	return (rc);
d523 2
a524 1
	struct vmesoftc *sc = (void *)vme_cd.cd_devs[0];
d527 1
a527 1
	if (pmap_extract(pmap_kernel(), (vaddr_t)handle, &pa) == FALSE)
d530 1
a530 2
	pa -= platform->vme16_base;
	return (vme_unmap(sc->sc_ext_a16, pa, (vaddr_t)handle, size));
d536 2
a537 1
	struct vmesoftc *sc = (void *)vme_cd.cd_devs[0];
d540 1
a540 1
	if (pmap_extract(pmap_kernel(), (vaddr_t)handle, &pa) == FALSE)
d543 1
a543 2
	pa -= platform->vme24_base;
	return (vme_unmap(sc->sc_ext_a24, pa, (vaddr_t)handle, size));
d549 2
a550 1
	struct vmesoftc *sc = (void *)vme_cd.cd_devs[0];
d553 1
a553 1
	if (pmap_extract(pmap_kernel(), (vaddr_t)handle, &pa) == FALSE)
d556 1
a556 2
	pa -= platform->vme32_base;
	return (vme_unmap(sc->sc_ext_a32, pa, (vaddr_t)handle, size));
d560 2
a561 1
vme_unmap(struct extent *ext, vme_addr_t addr, vaddr_t vaddr, bus_size_t size)
d563 1
d565 2
a566 1
	vsize_t len;
d569 2
a570 1
	len = round_page(vaddr + size) - va;
d572 22
d598 7
a604 3
	if (ext != NULL)
		extent_free(ext, atop(addr), atop(len),
		    EX_NOWAIT | EX_MALLOCOK);
d612 1
d614 1
a614 1
	return (0);
d620 1
a620 1
	return ((void *)handle);
d624 1
a624 1
 * D8 routines
d628 1
a628 1
vme_d8_space_read_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
d635 1
a635 1
vme_d8_space_read_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
d643 1
a643 1
vme_d8_space_write_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d652 1
a652 1
vme_d8_space_write_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d663 1
a663 1
vme_d8_space_read_raw_2(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
d668 1
a668 1
		*(uint16_t *)buf = vme_d8_space_read_2(t, h, o);
d674 1
a674 1
vme_d8_space_write_raw_2(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
d679 1
a679 1
		vme_d8_space_write_2(t, h, o, *(uint16_t *)buf);
d685 1
a685 1
vme_d8_space_read_raw_4(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
d690 1
a690 1
		*(uint32_t *)buf = vme_d8_space_read_4(t, h, o);
d696 1
a696 1
vme_d8_space_write_raw_4(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
d701 1
a701 1
		vme_d8_space_write_4(t, h, o, *(uint32_t *)buf);
d706 1
a706 1
 * D16 routines
d710 1
a710 1
vme_d16_space_read_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
d717 1
a717 1
vme_d16_space_write_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d726 1
a726 1
vme_d16_space_read_raw_4(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
d731 1
a731 1
		*(uint32_t *)buf = vme_d16_space_read_4(t, h, o);
d737 1
a737 1
vme_d16_space_write_raw_4(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
d742 1
a742 1
		vme_d16_space_write_4(t, h, o, *(uint32_t *)buf);
a748 2
 *
 * On aviion, we do not honour the dspace yet.
d762 1
a762 1
		return (EINVAL);
d771 1
a771 1
		return (EINVAL);
d777 1
a777 1
		return (ENOMEM);
d801 1
d815 2
a816 2
		tag->_space_read_4 = vme_d16_space_read_4;
		tag->_space_write_4 = vme_d16_space_write_4;
d819 2
a820 2
		tag->_space_read_raw_4 = vme_d16_space_read_raw_4;
		tag->_space_write_raw_4 = vme_d16_space_write_raw_4;
d823 8
a830 8
		tag->_space_read_2 = vme_d8_space_read_2;
		tag->_space_write_2 = vme_d8_space_write_2;
		tag->_space_read_4 = vme_d8_space_read_4;
		tag->_space_write_4 = vme_d8_space_write_4;
		tag->_space_read_raw_2 = vme_d8_space_read_raw_2;
		tag->_space_write_raw_2 = vme_d8_space_write_raw_2;
		tag->_space_read_raw_4 = vme_d8_space_read_raw_4;
		tag->_space_write_raw_4 = vme_d8_space_write_raw_4;
d835 1
a835 1
	return (0);
a847 6
/* minor device number encoding */
#define	AWIDTH_FIELD(minor)	(minor & 0x0f)
#define	AWIDTH(w)		((w) << 3)
#define	DWIDTH_FIELD(minor)	((minor & 0xf0) >> 4)
#define	DWIDTH(w)		((w) << 3)

d851 8
a858 2
	if (vme_cd.cd_ndevs == 0 || vme_cd.cd_devs[0] == NULL)
		return (ENODEV);
d866 1
a866 1
		return (ENODEV);
d875 1
a875 1
		return (ENODEV);
d878 1
a878 1
	return (0);
d884 1
a884 1
	return (0);
d890 8
a897 1
	return (EIO);
d903 72
a974 1
	return (EIO);
d982 1
a982 1
		return (ENOTTY);
d989 2
a991 4
	paddr_t pa;

	if ((off & PAGE_MASK) != 0)
		return (-1);
d993 1
d996 2
a997 3
	/* check offset range */
	if (off < 0 || off >= (1ULL << AWIDTH(awidth)))
		return (-1);
d999 9
a1007 18
	pa = (paddr_t)off;

	switch (awidth) {
	case VME_A32:
		if (!ISVMEA32(pa))
			return (-1);
		pa += platform->vme32_base;
		break;
	case VME_A24:
		if (!ISVMEA24(pa))
			return (-1);
		pa += platform->vme24_base;
		break;
	case VME_A16:
		if (!ISVMEA16(pa))
			return (-1);
		pa += platform->vme16_base;
		break;
d1009 2
d1012 1
a1012 1
	return (atop(pa));
@


1.5
log
@Work in progress support for AViiON models 4600 and 530.
Also features support for {awkw,bast}ard 6:1 CMMU:CPU configurations (4I2D).
Tested on model 4605, which runs up to cpu_initclocks(), which is not written
for this system family yet. No regression on model 4300.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.4 2007/12/19 22:05:06 miod Exp $	*/
d69 30
a98 7
int	vme16_map(bus_addr_t, bus_size_t, int, bus_space_handle_t *);
void	vme16_unmap(bus_space_handle_t, bus_size_t);
int	vme24_map(bus_addr_t, bus_size_t, int, bus_space_handle_t *);
void	vme24_unmap(bus_space_handle_t, bus_size_t);
int	vme32_map(bus_addr_t, bus_size_t, int, bus_space_handle_t *);
void	vme32_unmap(bus_space_handle_t, bus_size_t);
int	vme_subregion(bus_space_handle_t, bus_size_t, bus_size_t,
d100 4
a103 1
void *	vme_vaddr(bus_space_handle_t);
d378 2
a379 1
vme16_map(bus_addr_t addr, bus_size_t size, int flags, bus_space_handle_t *ret)
d391 2
a392 1
vme24_map(bus_addr_t addr, bus_size_t size, int flags, bus_space_handle_t *ret)
d404 2
a405 1
vme32_map(bus_addr_t addr, bus_size_t size, int flags, bus_space_handle_t *ret)
d462 1
a462 1
vme16_unmap(bus_space_handle_t handle, bus_size_t size)
d475 1
a475 1
vme24_unmap(bus_space_handle_t handle, bus_size_t size)
d488 1
a488 1
vme32_unmap(bus_space_handle_t handle, bus_size_t size)
d519 2
a520 2
vme_subregion(bus_space_handle_t handle, bus_addr_t offset, bus_size_t size,
    bus_space_handle_t *ret)
d528 1
a528 1
vme_vaddr(bus_space_handle_t handle)
d534 124
d694 2
a695 4
		tag->bs_map = vme32_map;
		tag->bs_unmap = vme32_unmap;
		tag->bs_subregion = vme_subregion;
		tag->bs_vaddr = vme_vaddr;
d698 2
a699 4
		tag->bs_map = vme24_map;
		tag->bs_unmap = vme24_unmap;
		tag->bs_subregion = vme_subregion;
		tag->bs_vaddr = vme_vaddr;
d702 40
a741 4
		tag->bs_map = vme16_map;
		tag->bs_unmap = vme16_unmap;
		tag->bs_subregion = vme_subregion;
		tag->bs_vaddr = vme_vaddr;
@


1.4
log
@Overhaul interrupt handling, in order to make it (arguably) simpler and
more board design-independent.

The main changes are:
- define logical interrupt sources, which match the on-board devices as
  well as the seven VME interrupt sources. Use these whenever possible
  when registering interrupts in the drivers, so that the actual interrupt
  mask layouts are hidden.
- make the on-board and VME interrupt handlers separate. On-board interrupt
  handlers are not really associated to an interrupt vector, only to a
  given interrupt source, and only one handler can be registered for a
  logical interrupt source. On the other hand, VME interrupts come with a
  vector number, and can be shared. This allows VME devices to really use
  the whole 256 vectors space, starting at vector zero.
- update the real interrupt masks upon interrupt handler registration and
  removal, so that only interrupt sources for which a handler exists may
  be enabled.
- update the VME interrupt allocation logic to allow exclusive vector
  allocation.
- move the Z8536 clock routines to their own file, since they are not
  AV400-specific; while there, calibrate the delay constant upon startup
  for more accurate delay().

The vme driver is the only one left with AV400 tentacles left, to be fixed
very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.3 2006/05/21 12:22:02 miod Exp $	*/
a48 1
#include <machine/av400.h>	/* XXX */
d141 1
a141 1
	    AV400_VME32_START1, AV400_VME32_END1);
d143 1
a143 1
	    AV400_VME32_START2, AV400_VME32_END2);
d145 1
a145 1
	    AV400_VME24_START, AV400_VME24_END);
d147 1
a147 1
	    AV400_VME16_START, AV400_VME16_END);
d343 8
d356 5
a360 5
	if (AV400_ISVMEA16(addr) && AV400_ISVMEA16(addr + size - 1))
		return (vme_map(sc->sc_ext_a16, addr + AV400_VME16_BASE, addr,
		    size, flags, ret));
	else
		return (EINVAL);
d368 5
a372 5
	if (AV400_ISVMEA24(addr) && AV400_ISVMEA24(addr + size - 1))
		return (vme_map(sc->sc_ext_a24, addr + AV400_VME24_BASE, addr,
		    size, flags, ret));
	else
		return (EINVAL);
d380 5
a384 5
	if (AV400_ISVMEA32(addr) && AV400_ISVMEA32(addr + size - 1))
		return (vme_map(sc->sc_ext_a32, addr + AV400_VME32_BASE, addr,
		    size, flags, ret));
	else
		return (EINVAL);
d441 1
a441 1
	pa -= AV400_VME16_BASE;
d454 1
a454 1
	pa -= AV400_VME24_BASE;
d467 1
a467 1
	pa -= AV400_VME32_BASE;
d653 1
a653 1
		if (!AV400_ISVMEA32(pa))
d655 1
a655 1
		pa += AV400_VME32_BASE;
d658 1
a658 1
		if (!AV400_ISVMEA24(pa))
d660 1
a660 1
		pa += AV400_VME24_BASE;
d663 1
a663 1
		if (!AV400_ISVMEA16(pa))
d665 1
a665 1
		pa += AV400_VME16_BASE;
@


1.3
log
@Move common definitions shared by the various 88100-based designs to their
own header file, and slowly make most of the code board-independent. No
functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.2 2006/05/11 19:50:28 miod Exp $	*/
d3 1
a3 1
 * Copyright (c) 2006, Miodrag Vallat.
d40 1
d49 1
a49 2
#include <machine/av400.h>
#include <aviion/dev/sysconreg.h>
d63 1
a63 1
        sizeof(struct vmesoftc), vmematch, vmeattach
d67 1
a67 1
        NULL, "vme", DV_DULL
a85 2
u_int	vmevecbase;

d90 1
a90 1
	return (1);
d98 1
d103 6
a117 2
	vmevecbase = 0x80;  /* Hard coded */

d194 2
a195 1
/* allocate interrupt vectors */
d197 1
a197 1
vmeintr_allocate(u_int count, int flags, u_int *array)
d200 12
d213 4
a216 6
	if ((flags & VMEINTR_CONTIGUOUS) == 0) {
		for (vec = vmevecbase; vec <= NVMEINTR - count; vec++) {
			if (SLIST_EMPTY(&intr_handlers[vec])) {
				*array++ = vec;
				if (--count == 0)
					return (0);
d219 16
a234 5
	} else {
		for (vec = vmevecbase; vec <= NVMEINTR - count; vec++) {
			/* do we have count contiguous unassigned vectors? */
			for (v = count; v != 0; v--)
				if (!SLIST_EMPTY(&intr_handlers[vec + v - 1]))
d236 1
d239 2
a240 1
				*array = vec;
d244 24
d270 3
a275 1
/* enable and establish interrupt */
d279 27
d307 1
a307 2
	 * No need to enable the VME interrupt source in the interrupt
	 * controller, as they are enabled by default.
d309 29
a337 1
	return intr_establish(vec, ih, name);
a388 1
	extern vaddr_t pmap_map(vaddr_t, paddr_t, paddr_t, vm_prot_t, u_int);
d408 1
a408 1
	for (pg = atop(len); pg !=0; pg--) {
@


1.2
log
@Fix stupid bugs in mapping and unmapping of VME regions.
@
text
@d1 1
a1 1
/*	$OpenBSD: vme.c,v 1.1.1.1 2006/05/09 18:14:15 miod Exp $	*/
d47 1
d113 1
a113 1
	vmevecbase = 0x80;  /* Hard coded for AV400 */
d120 1
a120 1
	ucsr = *(volatile u_int32_t*)AV400_UCSR;
d122 1
a122 1
	*(volatile u_int32_t *)AV400_UCSR = ucsr;
d128 1
a128 1
	*(volatile u_int32_t *)AV400_EXTAD = 0x00000000;
d133 1
a133 1
	*(volatile u_int32_t *)AV400_EXTAM = 0x0d;
d136 1
a136 1
	 * Display AV400 VME ranges.
d227 1
a227 1
	 * No need to enable the VME interrupt source in the AV400 interrupt
@


1.1
log
@Enter OpenBSD/aviion, a port to the m88k-based Data General AViiON workstations. Currently restricted to diskless serial console, tested on AV410 only; many thanks to Chris Tribo for documentation and testing.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a70 1
void *	vme16_vaddr(bus_space_handle_t);
a72 1
void *	vme24_vaddr(bus_space_handle_t);
a74 1
void *	vme32_vaddr(bus_space_handle_t);
d77 1
d79 1
a79 1
int	vme_map(struct extent *, bus_addr_t, bus_size_t, int,
d81 1
a81 1
void	vme_unmap(struct extent *, bus_space_handle_t, bus_size_t);
d241 3
a243 2
	if (AV400_ISVMEA32(addr) && AV400_ISVMEA32(addr + size - 1))
		return (vme_map(sc->sc_ext_a16, addr, size, flags, ret));
d254 2
a255 1
		return (vme_map(sc->sc_ext_a24, addr, size, flags, ret));
d265 3
a267 2
	if (AV400_ISVMEA16(addr) && AV400_ISVMEA16(addr + size - 1))
		return (vme_map(sc->sc_ext_a32, addr, size, flags, ret));
d273 2
a274 2
vme_map(struct extent *ext, bus_addr_t addr, bus_size_t size, int flags,
    bus_space_handle_t *ret)
d283 2
a284 2
	pa = trunc_page((paddr_t)addr);
	len = round_page((paddr_t)addr + size) - pa;
d287 1
a287 1
		rc = extent_alloc_region(ext, atop(pa), atop(len),
d314 1
a314 1
		extent_free(ext, atop(pa), atop(len), EX_NOWAIT | EX_MALLOCOK);
d322 4
d327 2
a328 1
	return (vme_unmap(sc->sc_ext_a16, handle, size));
d335 1
d337 5
a341 1
	return (vme_unmap(sc->sc_ext_a24, handle, size));
d348 1
d350 5
a354 1
	return (vme_unmap(sc->sc_ext_a32, handle, size));
d358 1
a358 1
vme_unmap(struct extent *ext, bus_space_handle_t handle, bus_size_t size)
d363 2
a364 2
	va = trunc_page((vaddr_t)handle);
	len = round_page((vaddr_t)handle + size) - va;
d371 2
a372 1
		extent_free(ext, atop(va), atop(len), EX_NOWAIT | EX_MALLOCOK);
d385 1
a385 13
vme16_vaddr(bus_space_handle_t handle)
{
	return (void *)(AV400_VME16_START + (vaddr_t)handle);
}

void *
vme24_vaddr(bus_space_handle_t handle)
{
	return (void *)(AV400_VME24_START + (vaddr_t)handle);
}

void *
vme32_vaddr(bus_space_handle_t handle)
d387 1
a387 1
	return (void *)(handle);
d430 1
a430 1
		tag->bs_vaddr = vme32_vaddr;
d436 1
a436 1
		tag->bs_vaddr = vme24_vaddr;
d442 1
a442 1
		tag->bs_vaddr = vme16_vaddr;
d541 1
a543 1
		pa += AV400_VME24_START;
d546 1
a548 1
		pa += AV400_VME16_START;
d551 1
@


1.1.1.1
log
@Oops, correct import this time.
@
text
@@
