head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.24
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.16
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.20
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.18
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.14
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.12
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.10
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.8
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.4
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.2
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.8
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.10
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.6
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.2.0.6
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.4
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2
	AV400_20060509:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.01.07.50.03;	author deraadt;	state dead;
branches;
next	1.4;
commitid	Rh8AZFtVMVCiwPts;

1.4
date	2010.04.21.19.33.47;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.19.22.05.06;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.21.12.22.02;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.09.18.17.37;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.05.09.18.17.37;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Send Aviion to same place as Nova II
discussed with jsg
@
text
@/*	$OpenBSD: vmevar.h,v 1.4 2010/04/21 19:33:47 miod Exp $	*/
/*
 * Copyright (c) 2006, 2007, Miodrag Vallat
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef	_AVIION_VME_H_
#define	_AVIION_VME_H_

typedef	u_int32_t vme_addr_t;

/*
 * VME address and data widths
 */

#define	VME_A32			0x04	/* 100..000 */
#define	VME_A24			0x03	/* 011..000 */
#define	VME_A16			0x02	/* 010..000 */
#define	VME_D32			0x04	/* 100..000 */
#define	VME_D16			0x02	/* 010..000 */
#define	VME_D8			0x01	/* 001..000 */

/*
 * VME address range
 */

struct vme_range {
	u_int		vr_width;
	vme_addr_t	vr_start;
	vme_addr_t	vr_end;
	paddr_t		vr_base;
};

/*
 * Attachment information for VME devices.
 *
 * Drivers are supposed to do their interrupt vector allocation
 * themselves.
 */
struct	vme_attach_args {
	/* address locators */
	vme_addr_t	vaa_addr_a16;
	vme_addr_t	vaa_addr_a24;
	vme_addr_t	vaa_addr_a32;
	/* interrupt level if specified */
	u_int		vaa_ipl;
};

/*
 * There are 256 possible vectors for VME devices.
 * One or more vectors may be allocated by vmeintr_allocate(), and then
 * each vector is setup with vmeintr_establish(). Nothing is done to
 * prevent the vector to be used in-between, so make sure no interrupt
 * can occur between the vector allocation and the interrupt handler
 * registration.
 */
#define	NVMEINTR	256
extern intrhand_t vmeintr_handlers[NVMEINTR];

int	vmeintr_allocate(u_int, int, int, u_int *);
#define	VMEINTR_ANY		0x00	/* any vector will do */
#define	VMEINTR_CONTIGUOUS	0x01	/* allocate a contiguous range */
#define	VMEINTR_SHARED		0x00	/* sharing is ok */
#define	VMEINTR_EXCLUSIVE	0x02	/* do not share this vector */
void	vmeintr_disestablish(u_int, struct intrhand *);
int	vmeintr_establish(u_int, struct intrhand *, const char *);

/*
 * VME device drivers need to obtain their bus_space_tag_t with
 * vmebus_get_bst(), specifying the address and data width to use for
 * bus accesses.
 * Resources associated to the tag can be released with vmebus_release_bst()
 * when bus accesses are no longer necessary.
 */
int	vmebus_get_bst(struct device *, u_int, u_int, bus_space_tag_t *);
void	vmebus_release_bst(struct device *, bus_space_tag_t);

#endif	/* _AVIION_VME_H_ */
@


1.4
log
@More reworking of interrupt handling and VME support, and rename various
board-specific defines to prevent any risk of collision. This also adds
clock support for AV530 family, and timecounter support (cio code sync'ed
with mvme88k). And various bugs fixed in the process.

This is enough to get models 4600 and 530 to run multiuser with a Hawk
Ethernet VME card (the onboard Ethernet is not supported yet, coming soon).
There is no way to share a disk with DG/UX yet, the kernel (and fdisk(8))
needs to become aware of its ways.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmevar.h,v 1.3 2007/12/19 22:05:06 miod Exp $	*/
@


1.3
log
@Overhaul interrupt handling, in order to make it (arguably) simpler and
more board design-independent.

The main changes are:
- define logical interrupt sources, which match the on-board devices as
  well as the seven VME interrupt sources. Use these whenever possible
  when registering interrupts in the drivers, so that the actual interrupt
  mask layouts are hidden.
- make the on-board and VME interrupt handlers separate. On-board interrupt
  handlers are not really associated to an interrupt vector, only to a
  given interrupt source, and only one handler can be registered for a
  logical interrupt source. On the other hand, VME interrupts come with a
  vector number, and can be shared. This allows VME devices to really use
  the whole 256 vectors space, starting at vector zero.
- update the real interrupt masks upon interrupt handler registration and
  removal, so that only interrupt sources for which a handler exists may
  be enabled.
- update the VME interrupt allocation logic to allow exclusive vector
  allocation.
- move the Z8536 clock routines to their own file, since they are not
  AV400-specific; while there, calibrate the delay constant upon startup
  for more accurate delay().

The vme driver is the only one left with AV400 tentacles left, to be fixed
very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmevar.h,v 1.2 2006/05/21 12:22:02 miod Exp $	*/
d33 22
a95 6
#define	VME_A32			0x04	/* 100..000 */
#define	VME_A24			0x03	/* 011..000 */
#define	VME_A16			0x02	/* 010..000 */
#define	VME_D32			0x04	/* 100..000 */
#define	VME_D16			0x02	/* 010..000 */
#define	VME_D8			0x01	/* 001..000 */
@


1.2
log
@Move common definitions shared by the various 88100-based designs to their
own header file, and slowly make most of the code board-independent. No
functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmevar.h,v 1.1.1.1 2006/05/09 18:17:37 miod Exp $	*/
d3 1
a3 1
 * Copyright (c) 2006, Miodrag Vallat
d47 13
a59 2
int	vmeintr_allocate(u_int, int, u_int *);
#define	VMEINTR_ANY		0x00
d61 3
d66 7
@


1.1
log
@Enter OpenBSD/aviion, a port to the m88k-based Data General AViiON workstations. Currently restricted to diskless serial console, tested on AV410 only; many thanks to Chris Tribo for documentation and testing.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d35 1
a35 4
 * The driver is supposed to know in which space it lives if it got an
 * unspecified address (this is to simplify kernel configuration files).
 *
 * Drivers are also supposed to do their interrupt vector allocation
@


1.1.1.1
log
@Oops, correct import this time.
@
text
@@
