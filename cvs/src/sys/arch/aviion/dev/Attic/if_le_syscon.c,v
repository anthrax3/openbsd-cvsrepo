head	1.18;
access;
symbols
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.12.0.10
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.8
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.5.0.4
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.2.0.6
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.4
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2
	AV400_20060509:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2015.12.01.07.50.03;	author deraadt;	state dead;
branches;
next	1.17;
commitid	Rh8AZFtVMVCiwPts;

1.17
date	2014.12.22.02.26.53;	author tedu;	state Exp;
branches;
next	1.16;
commitid	2Ez9mHW0jDzojG4V;

1.16
date	2014.11.16.12.30.56;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	yv0ECmCdICvq576h;

1.15
date	2013.10.23.22.14.22;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2013.09.24.20.14.34;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2013.09.16.16.30.51;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2011.04.07.15.30.15;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.31.21.38.07;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2010.04.24.18.44.27;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.18.15.06.39;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2010.03.31.19.46.27;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2009.04.14.16.01.04;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.19.22.05.06;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.19.21.51.29;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.21.12.22.02;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.09.18.13.40;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.05.09.18.13.40;	author miod;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Send Aviion to same place as Nova II
discussed with jsg
@
text
@/*	$OpenBSD: if_le_syscon.c,v 1.17 2014/12/22 02:26:53 tedu Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Adam Glass and Gordon W. Ross.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>
#include <sys/socket.h>
#include <sys/device.h>

#include <uvm/uvm.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/if_media.h>

#include <machine/autoconf.h>
#include <machine/board.h>
#include <machine/cpu.h>

#ifdef AV400
#include <machine/av400.h>
#endif
#ifdef AV530
#include <machine/av530.h>
#endif

#include <aviion/dev/sysconvar.h>

#include <dev/ic/lancereg.h>
#include <dev/ic/lancevar.h>
#include <dev/ic/am7990reg.h>
#include <dev/ic/am7990var.h>
/* #include <dev/ic/am79900reg.h> */
#include <dev/ic/am79900var.h>

/*
 * LANCE or ILACC registers. Although these are 16 bit registers, on the AV400
 * design, they need to be accessed as 32 bit registers. Bus magic...
 */
struct av_lereg {
	volatile uint32_t	ler1_rdp;	/* data port */
	volatile uint32_t	ler1_rap;	/* register select port */

	/* The following fields are only found on ILACC designs */
	volatile uint32_t	unused[2];
	volatile uint32_t	enaddr[6];
	volatile uint32_t	cksum[2];
};

struct le_softc {
	union {	/* glue to MI code */
		struct	lance_softc	sc_lance;
		struct	am7990_softc	sc_am7990;
		struct	am79900_softc	sc_am79900;
	} u;

	int	sc_ilacc;
	struct	av_lereg *sc_r1;	/* LANCE or ILACC registers */
	struct	intrhand sc_ih;
};

int	le_syscon_match(struct device *, void *, void *);
void	le_syscon_attach(struct device *, struct device *, void *);

struct cfattach le_syscon_ca = {
	sizeof(struct le_softc), le_syscon_match, le_syscon_attach
};

void	le_syscon_hwinit_ilacc(struct lance_softc *);
int	le_syscon_intr_ilacc(void *);
int	le_syscon_intr_lance(void *);
uint16_t le_syscon_rdcsr(struct lance_softc *, uint16_t);
void	le_syscon_wrcsr(struct lance_softc *, uint16_t, uint16_t);
void	le_syscon_wrcsr_interrupt(struct lance_softc *, uint16_t, uint16_t);

int
le_syscon_match(struct device *parent, void *cf, void *aux)
{
	struct confargs *ca = aux;
#ifdef AV530
	paddr_t fuse = 0;
#endif

	switch (cpuid) {
#ifdef AV400
	case AVIION_300_310:
	case AVIION_400_4000:
	case AVIION_410_4100:
	case AVIION_300C_310C:
	case AVIION_300CD_310CD:
	case AVIION_300D_310D:
	case AVIION_4300_25:
	case AVIION_4300_20:
	case AVIION_4300_16:
		switch (ca->ca_paddr) {
		case AV400_LAN:
			break;
		default:
			return 0;
		}
		break;
#endif
#ifdef AV530
	case AVIION_4600_530:
		switch (ca->ca_paddr) {
		case AV530_LAN1:
			fuse = AV530_IOFUSE0;
			break;
		case AV530_LAN2:
			fuse = AV530_IOFUSE1;
			break;
		default:
			return 0;
		}
		break;
#endif
	default:
		return 0;
	}

#ifdef AV530
	if (fuse != 0) {
		/* check IOFUSE register */
		if (badaddr(fuse, 1) != 0)
			return 0;

		/* check fuse status */
		return ISSET(*(volatile uint8_t *)fuse, AV530_IOFUSE_LAN);
	}
#endif

	return 1;
}

void
le_syscon_attach(struct device *parent, struct device *self, void *aux)
{
	struct le_softc *lesc = (struct le_softc *)self;
	struct lance_softc *sc = &lesc->u.sc_lance;
	struct confargs *ca = aux;
	u_int etherpages;
	struct pglist pglist;
	vm_page_t pg;
	int i, rc;
	paddr_t pa, pamask;
	vaddr_t va;
	int intsrc;
	uint8_t *enaddr;

	switch (cpuid) {
#ifdef AV530
	case AVIION_4600_530:
		lesc->sc_ilacc = 1;
		pamask = 0xffffffff;
		intsrc = ca->ca_paddr == AV530_LAN1 ?
		    INTSRC_ETHERNET1 : INTSRC_ETHERNET2;
		break;
#endif
	default:
		lesc->sc_ilacc = 0;
		pamask = 0x00ffffff;
		intsrc = INTSRC_ETHERNET1;
		break;
	}

	/*
	 * Allocate contiguous pages (in the first 16MB if not ILACC)
	 * to use as buffers. We aim towards 256KB, which is as much as
	 * the VME LANCE boards provide.
	 */
	if (physmem >= atop(32 * 1024 * 1024))
		etherpages = atop(256 * 1024);
	else if (physmem >= atop(16 * 1024 * 1024))
		etherpages = atop(128 * 1024);
	else
		etherpages = atop(64 * 1024);
	for (;;) {
		TAILQ_INIT(&pglist);
		rc = uvm_pglistalloc(ptoa(etherpages), 0, pamask,
		    0, 0, &pglist, 1, UVM_PLA_NOWAIT);
		if (rc == 0)
			break;

		etherpages >>= 1;
		if (etherpages <= 2) {
			printf(": no available memory, kernel is too large\n");
			return;
		}
	}

	va = uvm_km_valloc(kernel_map, ptoa(etherpages));
	if (va == 0) {
		printf(": can't map descriptor memory\n");
		uvm_pglistfree(&pglist);
		return;
	}

	pa = VM_PAGE_TO_PHYS(TAILQ_FIRST(&pglist));

	sc->sc_mem = (void *)va;
	sc->sc_addr = (u_long)pa & pamask;
	sc->sc_memsize = ptoa(etherpages);

	TAILQ_FOREACH(pg, &pglist, pageq) {
		pmap_enter(pmap_kernel(), va, pa,
		    PROT_READ | PROT_WRITE,
		    PROT_READ | PROT_WRITE | PMAP_WIRED);
		va += PAGE_SIZE;
		pa += PAGE_SIZE;
	}
	pmap_cache_ctrl((vaddr_t)sc->sc_mem,
	    (vaddr_t)sc->sc_mem + sc->sc_memsize, CACHE_INH);
	pmap_update(pmap_kernel());

	lesc->sc_r1 = (struct av_lereg *)ca->ca_paddr;

	/*
	 * Get the device Ethernet address.
	 */
	enaddr = sc->sc_arpcom.ac_enaddr;
	if (lesc->sc_ilacc) {
		for (i = 0; i < ETHER_ADDR_LEN; i++)
			enaddr[i] = lesc->sc_r1->enaddr[i] >> 24;
		/*
		 * If the checksum is invalid, don't trust the address,
		 * and force a hopefully unique one to be generated with
		 * ether_fakeaddr() at interface attachment time.
		 */
		if ((lesc->sc_r1->cksum[0] >> 24) !=
		    ((enaddr[0] + enaddr[2] + enaddr[4]) & 0xff) ||
		    (lesc->sc_r1->cksum[1] >> 24) !=
		    ((enaddr[1] + enaddr[3] + enaddr[5]) & 0xff))
			enaddr[0] = 0xff;
	} else
		myetheraddr(enaddr);

	sc->sc_conf3 = LE_C3_BSWP;

	sc->sc_copytodesc = lance_copytobuf_contig;
	sc->sc_copyfromdesc = lance_copyfrombuf_contig;
	sc->sc_copytobuf = lance_copytobuf_contig;
	sc->sc_copyfrombuf = lance_copyfrombuf_contig;
	sc->sc_zerobuf = lance_zerobuf_contig;

	sc->sc_rdcsr = le_syscon_rdcsr;
	sc->sc_wrcsr = le_syscon_wrcsr;
	sc->sc_hwreset = NULL;
	if (lesc->sc_ilacc)
		sc->sc_hwinit = le_syscon_hwinit_ilacc;
	else
		sc->sc_hwinit = NULL;

	if (lesc->sc_ilacc) {
		le_syscon_hwinit_ilacc(sc);
		am79900_config(&lesc->u.sc_am79900);
	} else
		am7990_config(&lesc->u.sc_am7990);

	if (lesc->sc_ilacc)
		lesc->sc_ih.ih_fn = le_syscon_intr_ilacc;
	else
		lesc->sc_ih.ih_fn = le_syscon_intr_lance;
	lesc->sc_ih.ih_arg = sc;
	lesc->sc_ih.ih_flags = 0;
	lesc->sc_ih.ih_ipl = IPL_NET;

	sysconintr_establish(intsrc, &lesc->sc_ih, self->dv_xname);
}

void
le_syscon_hwinit_ilacc(struct lance_softc *sc)
{
	le_syscon_wrcsr(sc, LE_CSR4,
	    LE_C4_DMAPLUS | LE_C4_UINT | LE_C4_TXSTRTM);
}

int
le_syscon_intr_ilacc(void *v)
{
	struct le_softc *lesc = (struct le_softc *)v;
	struct lance_softc *sc = &lesc->u.sc_lance;
	uint16_t csr4;

	/* Acknowledge TX start. XXX how to disable this? */
	csr4 = le_syscon_rdcsr(sc, LE_CSR4);
	if (csr4 & LE_C4_TXSTRT) {
		le_syscon_wrcsr(sc, LE_CSR4, csr4 | LE_C4_TXSTRTM);
		return 1;
	}

	return am79900_intr(v);
}

int
le_syscon_intr_lance(void *v)
{
	struct le_softc *lesc = (struct le_softc *)v;
	struct lance_softc *sc = &lesc->u.sc_lance;
	int rc;

	/*
	 * Syscon expects edge interrupts, while LANCE does level
	 * interrupts. To avoid missing interrupts while servicing,
	 * we disable further device interrupts while servicing.
	 *
	 * However, am7990_intr() will flip the interrupt enable bit
	 * itself; we override wrcsr with a specific version during
	 * servicing, so as not to reenable interrupts accidentally...
	 */
	sc->sc_wrcsr = le_syscon_wrcsr_interrupt;

	rc = am7990_intr(v);

	sc->sc_wrcsr = le_syscon_wrcsr;
	/*
	 * ...but we should not forget to reenable interrupts at this point!
	 */
	le_syscon_wrcsr(sc, LE_CSR0, LE_C0_INEA | le_syscon_rdcsr(sc, LE_CSR0));

	return rc;
}

uint16_t
le_syscon_rdcsr(struct lance_softc *sc, uint16_t port)
{
	struct av_lereg *ler1 = ((struct le_softc *)sc)->sc_r1;
	uint16_t val;

	ler1->ler1_rap = port;
	val = ler1->ler1_rdp;
	return val;
}

void
le_syscon_wrcsr(struct lance_softc *sc, uint16_t port, uint16_t val)
{
	struct av_lereg *ler1 = ((struct le_softc *)sc)->sc_r1;

	ler1->ler1_rap = port;
	ler1->ler1_rdp = val;
}

void
le_syscon_wrcsr_interrupt(struct lance_softc *sc, uint16_t port, uint16_t val)
{
	if (port == LE_CSR0)
		val &= ~LE_C0_INEA;

	le_syscon_wrcsr(sc, port, val);
}
@


1.17
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_syscon.c,v 1.16 2014/11/16 12:30:56 deraadt Exp $	*/
@


1.16
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_syscon.c,v 1.15 2013/10/23 22:14:22 miod Exp $	*/
a42 1
#ifdef INET
a44 1
#endif
@


1.15
log
@Add a sc_hwinit callback when running on an ILACC, to make sure CSR4 does
not get lost if the chip is reset. Also try to mask the `TX start' interrupt,
but this doesn't seem to work.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_syscon.c,v 1.14 2013/09/24 20:14:34 miod Exp $	*/
d240 2
a241 1
		    UVM_PROT_RW, UVM_PROT_RW | PMAP_WIRED);
@


1.14
log
@Extend le@@syscon to support the ILACC chips found on-board the AV530 family.
GENERIC.MP on a 2x88100(6:1)@@33 4605 can now make build on local disk and
local net; but it still needs to boot its kernel off the network at the
moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_syscon.c,v 1.13 2013/09/16 16:30:51 miod Exp $	*/
d103 1
d281 4
a284 1
	sc->sc_hwinit = NULL;
d287 1
a287 1
		le_syscon_wrcsr(sc, LE_CSR4, LE_C4_DMAPLUS | LE_C4_UINT);
a288 2
		/* Chip is stopped. Set "software style" to 32-bit. */
		le_syscon_wrcsr(sc, LE_CSR58, 2);
d303 7
d320 1
a320 1
		le_syscon_wrcsr(sc, LE_CSR4, csr4);
@


1.13
log
@Drop the ipl locator from syscon attachments, and have the syscon children
request explicit IPL_xxx levels.

Fix VME Ethernet config stanzas to request IPL_NET.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_syscon.c,v 1.12 2011/04/07 15:30:15 miod Exp $	*/
d54 7
d63 2
d67 2
d71 1
a71 1
 * LANCE registers. Although these are 16 bit registers, on the AV400
a72 1
 * The real stuff is in dev/ic/am7990reg.h
d77 5
d84 6
a89 6
/*
 * Ethernet software status per interface.
 * The real stuff is in dev/ic/am7990var.h
 */
struct	le_softc {
	struct	am7990_softc sc_am7990;	/* glue to MI code */
d91 2
a92 1
	struct	av_lereg *sc_r1;	/* LANCE registers */
d103 5
a107 4
int	le_syscon_intr(void *);
uint16_t le_syscon_rdcsr(struct am7990_softc *, uint16_t);
void	le_syscon_wrcsr(struct am7990_softc *, uint16_t, uint16_t);
void	le_syscon_wrcsr_interrupt(struct am7990_softc *, uint16_t, uint16_t);
d112 5
d118 1
d128 22
a149 1
		return 1;
d153 13
d172 1
a172 1
	struct am7990_softc *sc = &lesc->sc_am7990;
d177 2
a178 2
	int rc;
	paddr_t pa;
d180 18
d200 3
a202 1
	 * Allocate contiguous pages in the first 16MB to use as buffers.
d205 1
a205 1
		etherpages = 64;
d207 1
a207 1
		etherpages = 32;
d209 1
a209 1
		etherpages = 16;
d212 1
a212 1
		rc = uvm_pglistalloc(ptoa(etherpages), 0, (1 << 24) - 1,
d218 1
a218 1
		if (etherpages == 2) {
d234 1
a234 1
	sc->sc_addr = (u_long)pa & 0x00ffffff;
d249 20
d271 5
a275 7
	myetheraddr(sc->sc_arpcom.ac_enaddr);

	sc->sc_copytodesc = am7990_copytobuf_contig;
	sc->sc_copyfromdesc = am7990_copyfrombuf_contig;
	sc->sc_copytobuf = am7990_copytobuf_contig;
	sc->sc_copyfrombuf = am7990_copyfrombuf_contig;
	sc->sc_zerobuf = am7990_zerobuf_contig;
d282 7
a288 1
	am7990_config(sc);
d290 4
a293 1
	lesc->sc_ih.ih_fn = le_syscon_intr;
d298 18
a315 1
	sysconintr_establish(INTSRC_ETHERNET1, &lesc->sc_ih, self->dv_xname);
d319 1
a319 1
le_syscon_intr(void *v)
d322 1
a322 1
	struct am7990_softc *sc = &lesc->sc_am7990;
d326 1
a326 1
	 * Syscon expects edge interrupts, while the LANCE does level
d348 1
a348 1
le_syscon_rdcsr(struct am7990_softc *sc, uint16_t port)
d359 1
a359 1
le_syscon_wrcsr(struct am7990_softc *sc, uint16_t port, uint16_t val)
d368 1
a368 1
le_syscon_wrcsr_interrupt(struct am7990_softc *sc, uint16_t port, uint16_t val)
@


1.12
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_syscon.c,v 1.11 2010/12/31 21:38:07 miod Exp $	*/
d192 1
a192 1
	lesc->sc_ih.ih_ipl = ca->ca_ipl;
@


1.11
log
@Massive overhauling of the m88k pmap, though I can't pretend it's a new pmap
since a large part of the structures and logic remains.

Since m88k has separate supervisor/user spaces, we can map physical memory 1:1
in supervisor space, and have the kernel virtual address space start from the
end of physical memory.

This allows us to switch to __HAVE_PMAP_DIRECT. And to get rid of the double
mapped sdt, since now their virtual and physical addresses will always match.

The upper bound of the kernel virtual memory space is now platform dependent,
until the code which relies upon some hardware devices being mapped 1:1 in
supervisor mode is updated to no longer require this (this is mainly a PITA on
luna88k, where onboard devices start at 0x40000000, leaving only 1GB of KVA at
the moment - still much better than the previous 512MB).

Tested on mvme88k only (187, 188, 197LE, 197DP). Other platforms ought to
work, aviion will be checked shortly and fixed if necessary. No known
OpenBSD/luna88k system in working condition at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_syscon.c,v 1.10 2010/04/24 18:44:27 miod Exp $	*/
d148 1
a148 1
	if (va == NULL) {
@


1.10
log
@Replace heuristics used to figure out which model we are running on, and
trust the cpuid value returned by the prom itself (verified against
/usr/opt/sdk/include/sys/dg_sys_info.h on a DG-UX filesystem).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_syscon.c,v 1.9 2010/04/18 15:06:39 miod Exp $	*/
d166 1
a166 1
	pmap_cache_ctrl(pmap_kernel(), (vaddr_t)sc->sc_mem,
@


1.9
log
@Apply the same interrupt enable bit fiddling protection as done for le@@fwio
on vax, since interrupts on syscon are edge-triggered. Fixes the onboard
lance getting stuck after a while.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_syscon.c,v 1.8 2010/03/31 19:46:27 miod Exp $	*/
d95 12
a106 1
	if (avtyp != AV_400)
d108 1
a108 2

	return 1;
@


1.8
log
@Make sure the boundaries of uvm_pglistalloc() calls are set up with low
being page-aligned, and high being end of page (i.e.
high & PAGE_MASK == PAGE_MASK) everywhere, for consistency. Future code
will depend on this.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_syscon.c,v 1.7 2009/04/14 16:01:04 oga Exp $	*/
d65 2
a66 2
	volatile u_int32_t	ler1_rdp;	/* data port */
	volatile u_int32_t	ler1_rap;	/* register select port */
d87 4
a90 26
void	le_syscon_wrcsr(struct am7990_softc *, u_int16_t, u_int16_t);
u_int16_t le_syscon_rdcsr(struct am7990_softc *, u_int16_t);

void
le_syscon_wrcsr(sc, port, val)
	struct am7990_softc *sc;
	u_int16_t port, val;
{
	struct av_lereg *ler1 = ((struct le_softc *)sc)->sc_r1;

	ler1->ler1_rap = port;
	ler1->ler1_rdp = val;
}

u_int16_t
le_syscon_rdcsr(sc, port)
	struct am7990_softc *sc;
	u_int16_t port;
{
	struct av_lereg *ler1 = ((struct le_softc *)sc)->sc_r1;
	u_int16_t val;

	ler1->ler1_rap = port;
	val = ler1->ler1_rdp;
	return (val);
}
d93 1
a93 3
le_syscon_match(parent, cf, aux)
	struct device *parent;
	void *cf, *aux;
d96 1
a96 1
		return (0);
d98 1
a98 1
	return (1);
d102 1
a102 3
le_syscon_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d179 1
a179 1
	lesc->sc_ih.ih_fn = am7990_intr;
d185 58
@


1.7
log
@Convert the waitok field of uvm_pglistalloc to "flags", more will be added soon.

For the possibility of sleeping, the first two flags are UVM_PLA_WAITOK
and UVM_PLA_NOWAIT. It is an error not to show intention, so assert that
one of the two is provided. Switch over every caller in the tree to
using the appropriate flag.

ok art@@, ariane@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_syscon.c,v 1.6 2009/03/29 21:53:52 sthen Exp $	*/
d151 1
a151 1
		rc = uvm_pglistalloc(ptoa(etherpages), 0, 1 << 24,
@


1.6
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_syscon.c,v 1.5 2008/06/26 05:42:10 ray Exp $	*/
d152 1
a152 1
		    0, 0, &pglist, 1, 0);
@


1.5
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_syscon.c,v 1.4 2007/12/19 22:05:06 miod Exp $	*/
d165 1
a165 1
		printf(": could not map descriptor memory\n");
@


1.4
log
@Overhaul interrupt handling, in order to make it (arguably) simpler and
more board design-independent.

The main changes are:
- define logical interrupt sources, which match the on-board devices as
  well as the seven VME interrupt sources. Use these whenever possible
  when registering interrupts in the drivers, so that the actual interrupt
  mask layouts are hidden.
- make the on-board and VME interrupt handlers separate. On-board interrupt
  handlers are not really associated to an interrupt vector, only to a
  given interrupt source, and only one handler can be registered for a
  logical interrupt source. On the other hand, VME interrupts come with a
  vector number, and can be shared. This allows VME devices to really use
  the whole 256 vectors space, starting at vector zero.
- update the real interrupt masks upon interrupt handler registration and
  removal, so that only interrupt sources for which a handler exists may
  be enabled.
- update the VME interrupt allocation logic to allow exclusive vector
  allocation.
- move the Z8536 clock routines to their own file, since they are not
  AV400-specific; while there, calibrate the delay constant upon startup
  for more accurate delay().

The vme driver is the only one left with AV400 tentacles left, to be fixed
very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_syscon.c,v 1.3 2007/12/19 21:51:29 miod Exp $	*/
a17 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.3
log
@Allocate memory for the onboard le interface using uvm functions, instead of
stealing pages in pmap_bootstrap. While there, use up to four times more
memory for these buffers if the machine has enough physical memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_syscon.c,v 1.2 2006/05/21 12:22:02 miod Exp $	*/
d58 1
d61 1
a61 1
#include <aviion/dev/sysconreg.h>
d214 1
a214 1
	lesc->sc_ih.ih_wantframe = 0;
d217 1
a217 1
	sysconintr_establish(SYSCV_LE, &lesc->sc_ih, self->dv_xname);
@


1.2
log
@Move common definitions shared by the various 88100-based designs to their
own header file, and slowly make most of the code board-independent. No
functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_syscon.c,v 1.1.1.1 2006/05/09 18:13:40 miod Exp $	*/
d46 2
d122 2
a123 2
        struct device *parent;
        void *cf, *aux;
d125 4
a128 1
        return (1);
d133 2
a134 2
        struct device *parent, *self;
        void *aux;
d138 30
a167 3
        struct confargs *ca = aux;
	extern void *etherbuf;
	extern size_t etherlen;
d169 4
a172 2
	if (etherbuf == NULL) {
		printf(": no available memory, kernel is too large\n");
d176 17
a192 1
        lesc->sc_r1 = (struct av_lereg *)ca->ca_paddr;
d194 1
a194 5
        sc->sc_mem = (void *)etherbuf;
	etherbuf = NULL;
        sc->sc_conf3 = LE_C3_BSWP;
        sc->sc_addr = (u_long)sc->sc_mem & 0x00ffffff;
        sc->sc_memsize = etherlen;
@


1.1
log
@Enter OpenBSD/aviion, a port to the m88k-based Data General AViiON workstations. Currently restricted to diskless serial console, tested on AV410 only; many thanks to Chris Tribo for documentation and testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.4 2004/08/30 13:10:32 aoyama Exp $	*/
a57 1
#include <machine/av400.h>
@


1.1.1.1
log
@Oops, correct import this time.
@
text
@@
