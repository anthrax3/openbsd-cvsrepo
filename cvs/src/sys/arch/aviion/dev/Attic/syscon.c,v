head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.8
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.6.0.12
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.10
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.8
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.6
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.8
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.10
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.6
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.3.0.4
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.2
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2
	AV400_20060509:1.1.1.1
	miod:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.01.07.50.03;	author deraadt;	state dead;
branches;
next	1.10;
commitid	Rh8AZFtVMVCiwPts;

1.10
date	2014.05.17.12.20.55;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2014.05.08.22.17.33;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2013.09.26.19.02.06;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2013.09.16.16.30.51;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	2010.04.21.19.33.47;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.19.22.05.06;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.16.23.21.56;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.21.12.22.02;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.09.18.14.07;	author miod;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.05.09.18.14.07;	author miod;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Send Aviion to same place as Nova II
discussed with jsg
@
text
@/*	$OpenBSD: syscon.c,v 1.10 2014/05/17 12:20:55 miod Exp $ */
/*
 * Copyright (c) 2007 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice, this permission notice, and the disclaimer below
 * appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 1999 Steve Murphree, Jr.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/board.h>
#include <machine/cpu.h>

#include <machine/avcommon.h>
#include <aviion/dev/sysconvar.h>

struct sysconsoftc {
	struct device	sc_dev;

	struct intrhand sc_abih;	/* `abort' switch */
	struct intrhand sc_acih;	/* `ac fail' */
	struct intrhand sc_sfih;	/* `sys fail' */
};

void	sysconattach(struct device *, struct device *, void *);
int	sysconmatch(struct device *, void *, void *);

int	syscon_print(void *, const char *);
int	syscon_scan(struct device *, void *, void *);
int	sysconabort(void *);
int	sysconacfail(void *);
int	sysconsysfail(void *);

struct cfattach syscon_ca = {
	sizeof(struct sysconsoftc), sysconmatch, sysconattach
};

struct cfdriver syscon_cd = {
	NULL, "syscon", DV_DULL
};

int
sysconmatch(struct device *parent, void *cf, void *args)
{
	return (syscon_cd.cd_ndevs == 0);
}

void
sysconattach(struct device *parent, struct device *self, void *args)
{
	struct sysconsoftc *sc = (struct sysconsoftc *)self;
	int i;

	printf("\n");

	/*
	 * Set up interrupt handlers.
	 */
	for (i = 0; i < NINTSRC_SYSCON; i++)
		SLIST_INIT(&sysconintr_handlers[i]);

	/*
	 * Clear SYSFAIL if lit.
	 */
	*(volatile u_int32_t *)AV_UCSR |= UCSR_DRVSFBIT;
	*(volatile u_int32_t *)AV_CLRINT = ISTATE_SYSFAIL;

	sc->sc_abih.ih_fn = sysconabort;
	sc->sc_abih.ih_arg = 0;
	sc->sc_abih.ih_flags = INTR_WANTFRAME;
	sc->sc_abih.ih_ipl = IPL_ABORT;

	sc->sc_acih.ih_fn = sysconacfail;
	sc->sc_acih.ih_arg = 0;
	sc->sc_acih.ih_flags = INTR_WANTFRAME;
	sc->sc_acih.ih_ipl = IPL_ABORT;

	sc->sc_sfih.ih_fn = sysconsysfail;
	sc->sc_sfih.ih_arg = 0;
	sc->sc_sfih.ih_flags = INTR_WANTFRAME;
	sc->sc_sfih.ih_ipl = IPL_ABORT;

	sysconintr_establish(INTSRC_ABORT, &sc->sc_abih, "abort");
	sysconintr_establish(INTSRC_ACFAIL, &sc->sc_acih, "acfail");
	sysconintr_establish(INTSRC_SYSFAIL, &sc->sc_sfih, "sysfail");

	config_search(syscon_scan, self, args);
}

int
syscon_scan(struct device *parent, void *child, void *args)
{
	struct cfdata *cf = child;
	struct confargs oca, *ca = args;

	bzero(&oca, sizeof oca);
	oca.ca_iot = ca->ca_iot;
	oca.ca_offset = (paddr_t)cf->cf_loc[0];
	if (oca.ca_offset != (paddr_t)-1)
		oca.ca_paddr = ca->ca_paddr + oca.ca_offset;
	else
		oca.ca_paddr = (paddr_t)-1;

	if ((*cf->cf_attach->ca_match)(parent, cf, &oca) == 0)
		return (0);

	config_attach(parent, cf, &oca, syscon_print);
	return (1);
}

int
syscon_print(void *args, const char *pnp)
{
	struct confargs *ca = args;

	if (ca->ca_offset != (paddr_t)-1)
		printf(" offset 0x%lx", ca->ca_offset);
	return (UNCONF);
}

/*
 * Interrupt related code
 */

intrhand_t sysconintr_handlers[NINTSRC_SYSCON];

int
sysconintr_establish(u_int intsrc, struct intrhand *ih, const char *name)
{
	intrhand_t *list;

	list = &sysconintr_handlers[intsrc];
	if (!SLIST_EMPTY(list)) {
#ifdef DIAGNOSTIC
		printf("%s: interrupt source %u already registered\n",
		    __func__, intsrc);
#endif
		return (EINVAL);
	}

	evcount_attach(&ih->ih_count, name, &ih->ih_ipl);
	SLIST_INSERT_HEAD(list, ih, ih_link);

	intsrc_enable(intsrc, ih->ih_ipl);

	return (0);
}

void
sysconintr_disestablish(u_int intsrc, struct intrhand *ih)
{
	intrhand_t *list;

	list = &sysconintr_handlers[intsrc];
	evcount_detach(&ih->ih_count);
	SLIST_REMOVE(list, ih, intrhand, ih_link);

	intsrc_disable(intsrc);
}

int
sysconabort(void *eframe)
{
	*(volatile u_int32_t *)AV_CLRINT = ISTATE_ABORT;
	nmihand(eframe);
	return (1);
}

int
sysconsysfail(void *eframe)
{
	*(volatile u_int32_t *)AV_CLRINT = ISTATE_SYSFAIL;
	printf("SYSFAIL* ASSERTED\n");
	return (1);
}

int
sysconacfail(void *eframe)
{
	*(volatile u_int32_t *)AV_CLRINT = ISTATE_ACFAIL;
	printf("ACFAIL* ASSERTED\n");
	return (1);
}
@


1.10
log
@Remove "WARNING:" prefix from SYSFAIL and ACFAIL messages, so that, in case
of ACFAIL, what reaches the console is explicit enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.9 2014/05/08 22:17:33 miod Exp $ */
@


1.9
log
@Format string fixes for m88k; remove -Wno-format from the m88k kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.8 2013/09/26 19:02:06 miod Exp $ */
d212 1
a212 1
	printf("WARNING: SYSFAIL* ASSERTED\n");
d220 1
a220 1
	printf("WARNING: ACFAIL* ASSERTED\n");
@


1.8
log
@Clear SYSFAIL upon boot, for real.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.7 2013/09/16 16:30:51 miod Exp $ */
d156 1
a156 1
		printf(" offset 0x%x", ca->ca_offset);
@


1.7
log
@Drop the ipl locator from syscon attachments, and have the syscon children
request explicit IPL_xxx levels.

Fix VME Ethernet config stanzas to request IPL_NET.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.6 2010/09/20 06:33:47 matthew Exp $ */
d105 1
@


1.6
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.5 2010/04/21 19:33:47 miod Exp $ */
a140 1
	oca.ca_ipl = (u_int)cf->cf_loc[1];
a155 2
	if (ca->ca_ipl != (u_int)-1)
		printf(" ipl %u", ca->ca_ipl);
@


1.5
log
@More reworking of interrupt handling and VME support, and rename various
board-specific defines to prevent any risk of collision. This also adds
clock support for AV530 family, and timecounter support (cio code sync'ed
with mvme88k). And various bugs fixed in the process.

This is enough to get models 4600 and 530 to run multiuser with a Hawk
Ethernet VME card (the onboard Ethernet is not supported yet, coming soon).
There is no way to share a disk with DG/UX yet, the kernel (and fdisk(8))
needs to become aware of its ways.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.4 2007/12/19 22:05:06 miod Exp $ */
d182 1
a182 2
	evcount_attach(&ih->ih_count, name, (void *)&ih->ih_ipl,
	    &evcount_intr);
@


1.4
log
@Overhaul interrupt handling, in order to make it (arguably) simpler and
more board design-independent.

The main changes are:
- define logical interrupt sources, which match the on-board devices as
  well as the seven VME interrupt sources. Use these whenever possible
  when registering interrupts in the drivers, so that the actual interrupt
  mask layouts are hidden.
- make the on-board and VME interrupt handlers separate. On-board interrupt
  handlers are not really associated to an interrupt vector, only to a
  given interrupt source, and only one handler can be registered for a
  logical interrupt source. On the other hand, VME interrupts come with a
  vector number, and can be shared. This allows VME devices to really use
  the whole 256 vectors space, starting at vector zero.
- update the real interrupt masks upon interrupt handler registration and
  removal, so that only interrupt sources for which a handler exists may
  be enabled.
- update the VME interrupt allocation logic to allow exclusive vector
  allocation.
- move the Z8536 clock routines to their own file, since they are not
  AV400-specific; while there, calibrate the delay constant upon startup
  for more accurate delay().

The vme driver is the only one left with AV400 tentacles left, to be fixed
very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.3 2006/11/16 23:21:56 miod Exp $ */
d98 1
a98 1
	for (i = 0; i < INTSRC_VME; i++)
d166 1
a166 1
intrhand_t sysconintr_handlers[INTSRC_VME];
@


1.3
log
@Ratibibugle struct frame and <machine/frame.h>
@
text
@d1 17
a17 1
/*	$OpenBSD: syscon.c,v 1.2 2006/05/21 12:22:02 miod Exp $ */
d50 1
d54 1
a54 1
#include <aviion/dev/sysconreg.h>
a71 1
int	sysconav400(void *);
d91 1
d96 6
a105 3
	/*
	 * pseudo driver, abort interrupt handler
	 */
d108 1
a108 1
	sc->sc_abih.ih_wantframe = 1;
d113 1
a113 1
	sc->sc_acih.ih_wantframe = 1;
d118 1
a118 1
	sc->sc_sfih.ih_wantframe = 1;
d121 3
a123 3
	sysconintr_establish(SYSCV_ABRT, &sc->sc_abih, "abort");
	sysconintr_establish(SYSCV_ACF, &sc->sc_acih, "acfail");
	sysconintr_establish(SYSCV_SYSF, &sc->sc_sfih, "sysfail");
d162 6
d169 1
a169 1
sysconintr_establish(u_int vec, struct intrhand *ih, const char *name)
d171 4
d176 3
a178 2
	if (vec < 0 || vec >= SYSCON_NVEC) {
		printf("sysconintr_establish: illegal vector 0x%x\n", vec);
a180 1
#endif
d182 19
a200 1
	return (intr_establish(SYSCON_VECT + vec, ih, name));
@


1.2
log
@Move common definitions shared by the various 88100-based designs to their
own header file, and slowly make most of the code board-independent. No
functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.1.1.1 2006/05/09 18:14:07 miod Exp $ */
a34 1
#include <machine/frame.h>
@


1.1
log
@Enter OpenBSD/aviion, a port to the m88k-based Data General AViiON workstations. Currently restricted to diskless serial console, tested on AV410 only; many thanks to Chris Tribo for documentation and testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscon.c,v 1.25 2006/04/17 18:27:30 miod Exp $ */
d37 1
a37 1
#include <machine/av400.h>
a45 3
#if 0
	struct intrhand sc_av400ih;	/* `av400 interrupt' */
#endif
d82 1
a82 1
	*(volatile u_int32_t *)AV400_UCSR |= UCSR_DRVSFBIT;
a101 7
#if 0
	sc->sc_av400ih.ih_fn = sysconav400;
	sc->sc_av400ih.ih_arg = 0;
	sc->sc_av400ih.ih_wantframe = 1;
	sc->sc_av400ih.ih_ipl = IPL_ABORT;
#endif

a104 3
#if 0
	intr_establish(AV400_IVEC, &sc->sc_av400ih, self->dv_xname);
#endif
d159 1
a159 1
	*(volatile u_int32_t *)AV400_CLRINT = ISTATE_ABORT;
d167 1
a167 1
	*(volatile u_int32_t *)AV400_CLRINT = ISTATE_SYSFAIL;
d175 1
a175 1
	*(volatile u_int32_t *)AV400_CLRINT = ISTATE_ACFAIL;
a178 10

#if 0
int
sysconav400(void *eframe)
{
	/* shouldn't happen! */
	printf("AV400: self-inflicted interrupt\n");
	return (1);
}
#endif
@


1.1.1.1
log
@Oops, correct import this time.
@
text
@@
