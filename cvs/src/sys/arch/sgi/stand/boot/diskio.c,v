head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.7.0.10
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.6
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.4
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.2.0.14
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.12
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.10
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.8
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.6
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.4
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.2
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.10.05.11.55.45;	author visa;	state Exp;
branches;
next	1.10;
commitid	caBYKspBPiC2w13Q;

1.10
date	2015.09.30.22.45.57;	author krw;	state Exp;
branches;
next	1.9;
commitid	Oh9oitLwlzFY6ssl;

1.9
date	2014.07.12.21.03.38;	author tedu;	state Exp;
branches;
next	1.8;
commitid	BPzam5MbotE66TAj;

1.8
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.7;
commitid	uKVPYMN2MLxdZxzH;

1.7
date	2012.03.19.17.38.31;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2011.03.13.00.13.53;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.15.20.34.57;	author martynas;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.09.18.08.59;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2008.03.08.16.52.28;	author jsing;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.16.18.54.48;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.23.14.22.40;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Make the sgi boot blocks read the real OpenBSD disklabel instead of
assuming that the 'a' partition starts at the same location as the
volume header partition #0.

Diff from Miod Vallat
@
text
@/*	$OpenBSD: diskio.c,v 1.10 2015/09/30 22:45:57 krw Exp $ */

/*
 * Copyright (c) 2016 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 2000 Opsycon AB  (www.opsycon.se)
 * Copyright (c) 2000 Rtmx, Inc   (www.rtmx.com)
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for Rtmx, Inc by
 *	Opsycon Open System Consulting AB, Sweden.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <lib/libkern/libkern.h>
#include <stand.h>

#include <sys/disklabel.h>
#include <mips64/arcbios.h>

char	*strstr(char *, const char *);  /* strstr.c */

struct	dio_softc {
	int	sc_fd;			/* PROM file ID */
	int	sc_part;		/* Disk partition number. */
	struct	disklabel sc_label;	/* Disk label for this disk. */
};

int
diostrategy(void *devdata, int rw, daddr32_t bn, size_t reqcnt, void *addr,
    size_t *cnt)
{
	struct dio_softc *sc = (struct dio_softc *)devdata;
	struct partition *pp = &sc->sc_label.d_partitions[sc->sc_part];
	uint64_t blkoffset;
	arc_quad_t offset;
	long result;

	blkoffset = (DL_GETPOFFSET(pp) + bn) * DEV_BSIZE;
	offset.hi = blkoffset >> 32;
	offset.lo = blkoffset;

	if (Bios_Seek(sc->sc_fd, &offset, 0) < 0 ||
	    Bios_Read(sc->sc_fd, addr, reqcnt, &result) < 0)
		return EIO;

	*cnt = result;
	return 0;
}

int
dioopen(struct open_file *f, ...)
{
	char *ctlr;
	int partition;
	struct dio_softc *sc;
	struct disklabel *lp;
	struct sgilabel *sl;
	long fd;
	/* XXX getdisklabel() assumes DEV_BSIZE bytes available */
	char buf[DEV_BSIZE + LABELOFFSET];
	arc_quad_t offset;
	daddr_t native_offset;
	long result;
	va_list ap;
	char rawctlr[1 + MAXPATHLEN];
	char *partptr;

	va_start(ap, f);
	ctlr = va_arg(ap, char *);
	partition = va_arg(ap, int);
	va_end(ap);

	if (partition >= MAXPARTITIONS)
		return ENXIO;

	/*
	 * If booting from disk, `ctlr` is something like
	 *   whatever()partition(0)
	 * or
	 *   dksc(whatever,0)
	 * where 0 is the volume header #0 partition, which is the
	 * OpenBSD area, where the OpenBSD disklabel can be found.
	 *
	 * However, the OpenBSD `a' partition, where the kernel is to be
	 * found, may not start at the same offset.
	 *
	 * In order to be able to correctly load any file from the OpenBSD
	 * partitions, we need to access the volume header partition table
	 * and the OpenBSD label.
	 *
	 * Therefore, make sure we replace `partition(*)' with `partition(10)'
	 * before reaching ARCBios, in order to access the raw disk.
	 *
	 * We could use partition #8 and use the value of SystemPartition in
	 * the environment to avoid doing this, but this would prevent us
	 * from being able to boot from a different disk than the one
	 * pointed to by SystemPartition.
	 */
	
	strlcpy(rawctlr, ctlr, sizeof rawctlr);
	partptr = strstr(rawctlr, "partition(");
	if (partptr != NULL) {
		strlcpy(partptr, "partition(10)",
		    sizeof rawctlr - (partptr - rawctlr));
	} else {
		if ((partptr = strstr(rawctlr, "dksc(")) != NULL) {
			partptr = strstr(partptr, ",0)");
			if (partptr != NULL && partptr[3] == '\0')
				strlcpy(partptr, ",10)",
				    sizeof rawctlr - (partptr - rawctlr));
		}
	}

	sl = NULL;	/* no volume header found yet */
	if (partptr != NULL) {
		if (Bios_Open(rawctlr, 0, &fd) < 0)
			return ENXIO;

		/*
		 * Read the volume header.
		 */
		offset.hi = offset.lo = 0;
		if (Bios_Seek(fd, &offset, 0) < 0 ||
		    Bios_Read(fd, buf, DEV_BSIZE, &result) < 0 ||
		    result != DEV_BSIZE)
			return EIO;

		sl = (struct sgilabel *)buf;
		if (sl->magic != SGILABEL_MAGIC) {
#ifdef DEBUG
			printf("Invalid volume header magic %x\n", sl->magic);
#endif
			Bios_Close(fd);
			sl = NULL;
		}
	}

	if (sl == NULL) {
		if (Bios_Open(ctlr, 0, &fd) < 0)
			return ENXIO;
	}

	sc = alloc(sizeof(struct dio_softc));
	bzero(sc, sizeof(struct dio_softc));
	f->f_devdata = (void *)sc;
	lp = &sc->sc_label;

	sc->sc_fd = fd;
	sc->sc_part = partition;

	if (sl != NULL) {
		native_offset = sl->partitions[0].first;
	} else {
		/*
		 * We could not read the volume header, or there isn't any.
		 * Stick to the device we were given, and assume the
		 * OpenBSD disklabel can be found at the beginning.
		 */
		native_offset = 0;
	}

	/*
	 * Read the native OpenBSD label.
	 */
#ifdef DEBUG
	printf("OpenBSD label @@%lld\n", native_offset + LABELSECTOR);
#endif
	offset.hi = ((native_offset + LABELSECTOR) * DEV_BSIZE) >> 32;
	offset.lo = (native_offset + LABELSECTOR) * DEV_BSIZE;

	if (Bios_Seek(fd, &offset, 0) < 0 ||
	    Bios_Read(fd, buf, DEV_BSIZE, &result) < 0 ||
	    result != DEV_BSIZE)
		return EIO;
	
	if (getdisklabel(buf + LABELOFFSET, lp) == NULL) {
#ifdef DEBUG
		printf("Found native disklabel, "
		    "partition %c starts at %lld\n",
		    'a' + partition,
		    DL_GETPOFFSET(&lp->d_partitions[partition]));
#endif
	} else {
		/*
		 * Assume the OpenBSD partition spans the whole device.
		 */
#ifdef DEBUG
		printf("No native disklabel found\n");
#endif
		lp->d_secsize = DEV_BSIZE;
		lp->d_secpercyl = 1;
		lp->d_npartitions = MAXPARTITIONS;
		DL_SETPOFFSET(&lp->d_partitions[partition], native_offset);
		DL_SETPSIZE(&lp->d_partitions[partition], -1ULL);
	}

	return 0;
}

int
dioclose(struct open_file *f)
{
	Bios_Close(((struct dio_softc *)f->f_devdata)->sc_fd);
	free(f->f_devdata, sizeof(struct dio_softc));
	f->f_devdata = NULL;
	return (0);
}
@


1.10
log
@Nuke a #if 0/#endif block and a related variable. No plans to ever make
this work better than it does now. Eliminates a stray use of LABELSECTOR.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskio.c,v 1.9 2014/07/12 21:03:38 tedu Exp $ */
d4 15
d51 2
d54 1
a54 1
#include <sys/param.h>
d58 2
d72 1
d76 7
a82 6
	offset.hi = 0;
	offset.lo = (pp->p_offset + bn) * DEV_BSIZE;

	if ((Bios_Seek(sc->sc_fd, &offset, 0) < 0) ||
	    (Bios_Read(sc->sc_fd, addr, reqcnt, &result) < 0))
		return (EIO);
d85 1
a85 1
	return (0);
a92 1

d95 1
d97 5
d103 2
d112 1
a112 1
		return (ENXIO);
d114 66
a179 2
	if (Bios_Open(ctlr, 0, &fd) < 0)
		return (ENXIO);
d184 1
d189 45
a233 6
	lp = &sc->sc_label;
	lp->d_secsize = DEV_BSIZE;
	lp->d_secpercyl = 1;
	lp->d_npartitions = MAXPARTITIONS;
	lp->d_partitions[partition].p_offset = 0;
	lp->d_partitions[0].p_size = 0x7fff0000;
d235 1
a235 1
	return (0);
@


1.9
log
@revert a few stragglers hiding out
@
text
@d1 1
a1 1
/*	$OpenBSD: diskio.c,v 1.8 2014/07/12 18:44:42 tedu Exp $ */
a75 1
	daddr32_t labelsector;
a101 17

	labelsector = LABELSECTOR;

#if 0
	/* Try to read disk label and partition table information. */
	i = diostrategy(sc, F_READ, (daddr32_t)labelsector, DEV_BSIZE, buf, &cnt);

	if (i == 0 && cnt == DEV_BSIZE)
		msg = getdisklabel(buf, lp);
	else
		msg = "rd err";

	if (msg) {
		printf("%s: %s\n", ctlr, msg);
		return (ENXIO);
	}
#endif
@


1.8
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskio.c,v 1.7 2012/03/19 17:38:31 miod Exp $ */
d128 1
a128 1
	free(f->f_devdata, sizeof(struct dio_softc), 0);
@


1.7
log
@Teach the bootblocks how to load kernel from tftp (i.e. when OSLoadPartition
is bootp() instead of a disk). Kind of ugly because of the usual `can't seek'
problem causing kernels with symbols to be read from the network twice.

While there, add a 32 bit ECOFF boot block, not hooked to the build yet,
to be used shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskio.c,v 1.6 2011/03/13 00:13:53 deraadt Exp $ */
d128 1
a128 1
	free(f->f_devdata, sizeof(struct dio_softc));
@


1.6
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: diskio.c,v 1.5 2009/07/15 20:34:57 martynas Exp $ */
d48 1
a48 1
diostrategy(void *devdata, int rw, daddr32_t bn, u_int reqcnt, void *addr,
@


1.5
log
@missing va_end in bios_printf & dioopen.  ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskio.c,v 1.4 2009/05/09 18:08:59 miod Exp $ */
d48 1
a48 1
diostrategy(void *devdata, int rw, daddr_t bn, u_int reqcnt, void *addr,
d76 1
a76 1
	daddr_t labelsector;
d108 1
a108 1
	i = diostrategy(sc, F_READ, (daddr_t)labelsector, DEV_BSIZE, buf, &cnt);
@


1.4
log
@Promote types in ARCBios function prototypes from int to long whenever
necessary, to allow the same C code to be used against 32 bit ARCBios, when
compiled in 32 bit mode, or against 64 bit ARCBios, when compiled in native
mode.

Soon to be used by the boot blocks; this commit doesn't introduce any
functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskio.c,v 1.3 2008/03/08 16:52:28 jsing Exp $ */
a79 1

d82 2
@


1.3
log
@Cleanup/style(9) code and comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskio.c,v 1.1 2004/08/23 14:22:40 pefo Exp $ */
d48 2
a49 2
diostrategy(void *devdata, int rw, daddr_t bn, u_int reqcnt, char *addr,
    u_int *cnt)
d53 2
a54 2
	int64_t offset;
	int result;
d56 2
a57 1
	offset = (pp->p_offset + bn) * DEV_BSIZE;
d75 1
a75 1
	int fd;
@


1.2
log
@Update boot with miods ELF64 symtab fixes and my 32 bit compiles
@
text
@a40 1

d42 3
a44 3
	int	sc_fd;			/* PROM file id */
	int	sc_part;		/* disk partition number */
	struct	disklabel sc_label;	/* disk label for this disk */
d48 2
a49 2
diostrategy(void *devdata, int rw, daddr_t bn, u_int reqcnt,
		char *addr, u_int *cnt)
d60 1
a60 1
		return EIO;
d105 1
a105 1
	/* try to read disk label and partition table information */
d115 1
a115 1
		return ENXIO;
d119 1
a119 1
	return 0;
d123 1
a123 2
dioclose(f)
	struct open_file *f;
d128 1
a128 1
	return 0;
@


1.1
log
@disk boot and tools for sgi
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d75 1
a75 4
	int i, fd;
	char *msg = NULL;
	char buf[DEV_BSIZE];
	int cnt;
@

