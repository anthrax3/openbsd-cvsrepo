head	1.20;
access;
symbols
	OPENBSD_6_0:1.20.0.10
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.6
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.8
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.8
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.4
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.17.0.2
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.2
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.4.0.12
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.10
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.8
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.20
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2012.10.18.16.54.35;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2012.09.29.21.40.48;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2012.05.25.11.31.04;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2012.03.19.19.08.37;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2012.03.19.17.38.31;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2011.04.09.20.46.33;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.14.14.28.49;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.22.20.23.44;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.19.17.39.02;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2009.05.30.03.59.27;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2009.05.14.18.57.43;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.09.18.08.59;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2008.03.27.15.11.37;	author jsing;	state Exp;
branches;
next	1.6;

1.6
date	2008.03.08.16.52.28;	author jsing;	state Exp;
branches;
next	1.5;

1.5
date	2008.02.19.13.18.50;	author jsing;	state Exp;
branches;
next	1.4;

1.4
date	2004.10.20.12.49.15;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.16.18.54.48;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.25.18.19.35;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.23.14.22.40;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.20
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@/*	$OpenBSD: arcbios.c,v 1.19 2012/10/18 16:54:35 miod Exp $	*/
/*-
 * Copyright (c) 1996 M. Warner Losh.  All rights reserved.
 * Copyright (c) 1996-2004 Opsycon AB.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <lib/libkern/libkern.h>

#include <mips64/arcbios.h>
#include <mips64/archtype.h>
#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/mnode.h>

#include <stand.h>

#ifdef __LP64__
int	 bios_is_32bit;
#endif
void	*bios_base;
#ifdef __LP64__
u_int	 kl_n_shift = 32;
#endif

int	arcbios_init(void);
const char *boot_get_path_component(const char *, char *, int *);
const char *boot_getnr(const char *, int *);

static const struct systypes {
	char *sys_name;
	int  sys_ip;
} sys_types[] = {
    { "SGI-IP20", 20 },
    { "SGI-IP22", 22 },
    { "SGI-IP26", 26 },
    { "SGI-IP28", 28 },
    { "SGI-IP30", 30 },
    { "SGI-IP32", 32 }
};

#define KNOWNSYSTEMS (nitems(sys_types))

/*
 * ARCBios trampoline code.
 */
#ifdef __LP64__
#define ARC_Call(Name,Offset)	\
__asm__("\n"			\
"	.text\n"		\
"	.ent	" #Name "\n"	\
"	.align	3\n"		\
"	.set	noreorder\n"	\
"	.globl	" #Name "\n"	\
#Name":\n"			\
"	lw	$3, bios_is_32bit\n"\
"	ld	$2, bios_base\n"\
"	beqz	$3, 1f\n"	\
"	 nop\n"			\
"	lw	$3, 0x20($2)\n"	\
"	lw	$2," #Offset "($3)\n"\
"	jr	$2\n"		\
"	 nop\n"			\
"1:\n"				\
"	ld	$3, 2*0x20($2)\n"\
"	ld	$2, 2*" #Offset "($3)\n"\
"	jr	$2\n"		\
"	 nop\n"			\
"	.end	" #Name "\n"	);
#else
#define ARC_Call(Name,Offset)	\
__asm__("\n"			\
"	.text\n"		\
"	.ent	" #Name "\n"	\
"	.align	3\n"		\
"	.set	noreorder\n"	\
"	.globl	" #Name "\n"	\
#Name":\n"			\
"	lw	$2, bios_base\n"\
"	lw	$3, 0x20($2)\n"	\
"	lw	$2," #Offset "($3)\n"\
"	jr	$2\n"		\
"	 nop\n"			\
"	.end	" #Name "\n"	);
#endif

#if 0
ARC_Call(Bios_Load,			0x00);
ARC_Call(Bios_Invoke,			0x04);
ARC_Call(Bios_Execute,			0x08);
#endif
ARC_Call(Bios_Halt,			0x0c);
#if 0
ARC_Call(Bios_PowerDown,		0x10);
ARC_Call(Bios_Restart,			0x14);
ARC_Call(Bios_Reboot,			0x18);
#endif
ARC_Call(Bios_EnterInteractiveMode,	0x1c);
#if 0
ARC_Call(Bios_Unused1,			0x20);
#endif
ARC_Call(Bios_GetPeer,			0x24);
ARC_Call(Bios_GetChild,			0x28);
#if 0
ARC_Call(Bios_GetParent,		0x2c);
ARC_Call(Bios_GetConfigurationData,	0x30);
ARC_Call(Bios_AddChild,			0x34);
ARC_Call(Bios_DeleteComponent,		0x38);
ARC_Call(Bios_GetComponent,		0x3c);
ARC_Call(Bios_SaveConfiguration,	0x40);
#endif
ARC_Call(Bios_GetSystemId,		0x44);
ARC_Call(Bios_GetMemoryDescriptor,	0x48);
#if 0
ARC_Call(Bios_Unused2,			0x4c);
ARC_Call(Bios_GetTime,			0x50);
ARC_Call(Bios_GetRelativeTime,		0x54);
ARC_Call(Bios_GetDirectoryEntry,	0x58);
#endif
ARC_Call(Bios_Open,			0x5c);
ARC_Call(Bios_Close,			0x60);
ARC_Call(Bios_Read,			0x64);
#if 0
ARC_Call(Bios_GetReadStatus,		0x68);
#endif
ARC_Call(Bios_Write,			0x6c);
ARC_Call(Bios_Seek,			0x70);
#if 0
ARC_Call(Bios_Mount,			0x74);
ARC_Call(Bios_GetEnvironmentVariable,	0x78);
ARC_Call(Bios_SetEnvironmentVariable,	0x7c);
ARC_Call(Bios_GetFileInformation,	0x80);
ARC_Call(Bios_SetFileInformation,	0x84);
ARC_Call(Bios_FlushAllCaches,		0x88);
ARC_Call(Bios_TestUnicodeCharacter,	0x8c);
ARC_Call(Bios_GetDisplayStatus,		0x90);
#endif

/*
 * Simple getchar/putchar interface.
 */

#if 0
int
getchar()
{
	char buf[4];
	long cnt;

	if (Bios_Read(0, &buf[0], 1, &cnt) != 0)
		return (-1);

	return (buf[0] & 255);
}
#endif

void
putchar(int c)
{
	char buf[4];
	long cnt;

	if (c == '\n') {
		buf[0] = '\r';
		buf[1] = c;
		cnt = 2;
	} else {
		buf[0] = c;
		cnt = 1;
	}

	Bios_Write(1, &buf[0], cnt, &cnt);
}

/*
 * Identify ARCBios type.
 */
int
arcbios_init()
{
	arc_config_t *cf;
	arc_sid_t *sid;
#ifdef __LP64__
	register_t prid;
#endif
	char *sysid = NULL;
	int sysid_len;
	int i;

	/*
	 * Figure out where ARCBios can be addressed. On R8000, we can not
	 * use compatibility space, but on IP27/IP35, we can not blindly
	 * use XKPHYS due to subspacing, while compatibility space works.
	 * Fortunately we can get the processor ID to tell these apart, even
	 * though 32-bit coprocessor 0 instructions are not supposed to be
	 * supported on the R8000 (they probably misbehave somehow if the
	 * register has bits sets in the upper 32 bits, which is not the
	 * case of the R8000 PrId register).
	 */
#ifdef __LP64__
	__asm__ volatile ("mfc0 %0, $15" /* COP_0_PRID */ : "=r" (prid));
	if ((prid & 0xff00) == (MIPS_R8000 << 8))
		bios_base = (void *)PHYS_TO_XKPHYS(ARCBIOS_BASE, CCA_CACHED);
	else
		bios_base = (void *)PHYS_TO_CKSEG0(ARCBIOS_BASE);
#else
	bios_base = (void *)(int32_t)PHYS_TO_CKSEG0(ARCBIOS_BASE);
#endif

	/*
	 * Figure out if this is an ARCBios machine and if it is, see if we're
	 * dealing with a 32 or 64 bit version.
	 */
#ifdef __LP64__
	if ((ArcBiosBase32->magic == ARC_PARAM_BLK_MAGIC) ||
	    (ArcBiosBase32->magic == ARC_PARAM_BLK_MAGIC_BUG)) {
		bios_is_32bit = 1;
	} else if ((ArcBiosBase64->magic == ARC_PARAM_BLK_MAGIC) ||
	    (ArcBiosBase64->magic == ARC_PARAM_BLK_MAGIC_BUG)) {
		bios_is_32bit = 0;
	}
#endif

	/*
	 * Minimal system identification.
	 */
	sid = (arc_sid_t *)Bios_GetSystemId();
	cf = (arc_config_t *)Bios_GetChild(NULL);
	if (cf != NULL) {
#ifdef __LP64__
		if (bios_is_32bit) {
			sysid = (char *)(long)cf->id;
			sysid_len = cf->id_len;
		} else {
			sysid = (char *)((arc_config64_t *)cf)->id;
			sysid_len = ((arc_config64_t *)cf)->id_len;
		}
#else
		sysid = (char *)(long)cf->id;
		sysid_len = cf->id_len;
#endif

		if (sysid_len > 0 && sysid != NULL) {
			sysid_len--;
			for (i = 0; i < KNOWNSYSTEMS; i++) {
				if (strlen(sys_types[i].sys_name) != sysid_len)
					continue;
				if (strncmp(sys_types[i].sys_name, sysid,
				    sysid_len) != 0)
					continue;
				return sys_types[i].sys_ip;	/* Found it. */
			}
		}
	} else {
#ifdef __LP64__
		if (IP27_KLD_KLCONFIG(0)->magic == IP27_KLDIR_MAGIC) {
			/*
			 * If we find a kldir assume IP27. Boot blocks
			 * do not need to tell IP27 and IP35 apart.
			 */
			return 27;
		}
#endif
	}

	printf("UNRECOGNIZED SYSTEM '%s' VENDOR '%s' PRODUCT '%s'\n",
	    cf == NULL || sysid == NULL ? "(null)" : sysid,
	    sid->vendor, sid->prodid);
	printf("Halting system!\n");
	Bios_Halt();
	printf("Halting failed, use manual reset!\n");
	for (;;) ;
}

/*
 *  Decompose the device pathname and find driver.
 *  Returns pointer to remaining filename path in file.
 */
int
devopen(struct open_file *f, const char *fname, char **file)
{
	const char *cp, *ncp, *ecp;
	struct devsw *dp;
	int partition = 0;
	char namebuf[256];
	char devname[32];
	int rc, i, n, noopen = 0;

	ecp = cp = fname;
	namebuf[0] = '\0';

	/*
	 * Scan the component list and find device and partition.
	 */
	if (strncmp(cp, "bootp()", 7) == 0) {
		strlcpy(devname, "bootp", sizeof(devname));
		strlcpy(namebuf, cp, sizeof(namebuf));
		noopen = 1;
	} else if (strncmp(cp, "dksc(", 5) == 0) {
		strncpy(devname, "scsi", sizeof(devname));
		cp += 5;
		cp = boot_getnr(cp, &i);
		/* i = controller number */
		if (*cp++ == ',') {
			cp = boot_getnr(cp, &i);
			/* i = target id */
			if (*cp++ == ',') {
				memcpy(namebuf, fname, cp - fname);
				namebuf[cp - fname] = '\0';
				strlcat(namebuf, "0)", sizeof namebuf);

				cp = boot_getnr(cp, &i);
				partition = i;
				cp++;	/* skip final ) */
			}
		}
	} else {
		ncp = boot_get_path_component(cp, namebuf, &i);
		while (ncp != NULL) {
			if (strcmp(namebuf, "partition") == 0)
				partition = i;
			ecp = ncp;

			/* XXX Do this with a table if more devs are added. */
			if (strcmp(namebuf, "scsi") == 0)
				strncpy(devname, namebuf, sizeof(devname)); 

			cp = ncp;
			ncp = boot_get_path_component(cp, namebuf, &i);
		}

		memcpy(namebuf, fname, ecp - fname);
		namebuf[ecp - fname] = '\0';
	}

	/*
	 * Dig out the driver.
	 */
	dp = devsw;
	n = ndevs;
	while (n--) {
		if (strcmp(devname, dp->dv_name) == 0) {
			if (noopen)
				rc = 0;
			else
				rc = (dp->dv_open)(f, namebuf, partition, 0);
			if (rc == 0) {
				f->f_dev = dp;
				if (file && *cp != '\0')
					*file = (char *)cp;
			}
			return (rc);
		}
		dp++;
	}
	return (ENXIO);
}

const char *
boot_get_path_component(const char *p, char *comp, int *no)
{
	while (*p && *p != '(')
		*comp++ = *p++;
	*comp = '\0';

	if (*p == '\0')
		return (NULL);

	*no = 0;
	p++;
	while (*p && *p != ')') {
		if (*p >= '0' && *p <= '9')
			*no = *no * 10 + *p++ - '0';
		else
			return (NULL);
	}
	return (++p);
}

const char *
boot_getnr(const char *p, int *no)
{
	*no = 0;
	while (*p >= '0' && *p <= '9')
		*no = *no * 10 + *p++ - '0';
	return p;
}
@


1.19
log
@Put back the kl_n_shift variable, removed by mistake in 1.18, causing the
boot blocks to fail on IP27 and IP35 (IP26, IP30 and 32-bit ARCBios systems
unaffected).

While there, provide a simpler ARC_Call() macro for 32-bit boot blocks, and
put a few more variables and statements within explicit __LP64__ guards.

Crank boot blocks version as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.18 2012/09/29 21:40:48 miod Exp $	*/
d222 1
a222 1
	__asm__ __volatile__ ("mfc0 %0, $15" /* COP_0_PRID */ : "=r" (prid));
@


1.18
log
@Bring the `let decide ARCBios address at runtime' code to the SGI bootblocks,
which allows them to run on IP26 (POWER Indigo2 R8000).

Crank boot blocks version.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.17 2012/05/25 11:31:04 miod Exp $	*/
d39 3
a41 1
int	bios_is_32bit;
d43 3
d68 1
d80 1
a80 1
"	nop\n"			\
d82 1
a82 1
"       lw      $2," #Offset "($3)\n"\
d84 1
a84 1
"	nop\n"			\
d89 1
a89 1
"	nop\n"			\
d91 16
d235 1
d243 1
d251 1
a255 8
#ifndef __LP64__
			/*
			 * Hopeless pointer truncation relying upon sign
			 * extension; we expect 64-bit ARCS to fail to
			 * load 32-bit boot code anyway.
			 */
			sysid = (char *)(int32_t)((arc_config64_t *)cf)->id;
#else
a256 1
#endif
d259 4
@


1.17
log
@Support for the POWER Indigo2 R10000 systems (IP28). Currently running with
ECC checking disabled, which allows the existing Indigo2 drivers to run
unmodified.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.16 2012/03/19 19:08:37 miod Exp $	*/
d40 1
a41 1
u_int	kl_n_shift = 32;
d71 3
a73 2
"	lw	$2, bios_is_32bit\n"\
"	beqz	$2, 1f\n"	\
d75 2
a76 2
"       lw      $2, 0xffffffff80001020\n"\
"       lw      $2," #Offset "($2)\n"\
d80 2
a81 2
"       ld      $2, 0xffffffff80001040\n"\
"	ld	$2, 2*" #Offset "($2)\n"\
d86 1
d90 1
d92 1
d96 1
d98 1
d100 1
d103 1
d110 1
d113 1
d118 1
d122 1
d124 1
d127 1
d136 1
d142 1
d154 1
d182 3
d188 20
@


1.16
log
@Prevent the Ethernet driver to be opened twice when using a bootp() path;
some ARCBios don't like this.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.15 2012/03/19 17:38:31 miod Exp $	*/
d52 2
@


1.15
log
@Teach the bootblocks how to load kernel from tftp (i.e. when OSLoadPartition
is bootp() instead of a disk). Kind of ugly because of the usual `can't seek'
problem causing kernels with symbols to be read from the network twice.

While there, add a 32 bit ECOFF boot block, not hooked to the build yet,
to be used shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.14 2011/04/09 20:46:33 miod Exp $	*/
d246 1
a246 1
	int rc, i, n;
d257 1
d302 4
a305 1
			rc = (dp->dv_open)(f, namebuf, partition, 0);
@


1.14
log
@Make this compile without warnings in all modes, and do not use NULL when
integer zero is intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.13 2010/09/14 14:28:49 marco Exp $	*/
d50 2
d249 1
d254 4
a257 1
	if (strncmp(cp, "dksc(", 5) == 0) {
a265 1

d299 1
a299 1
	while(n--) {
d302 1
a302 1
			if (!rc) {
@


1.13
log
@unstatic variable we need elsewhere, fixes stand build on tezro

ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.12 2009/07/22 20:23:44 miod Exp $	*/
d187 8
d196 1
d316 1
a316 1
	if (*p == NULL)
@


1.12
log
@libsa printf doesn't support sizes in %s specifiers; fix format strings
accordingly.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.11 2009/06/19 17:39:02 miod Exp $	*/
d39 1
a39 1
static int	bios_is_32bit;
@


1.11
log
@Make the 64 bit bootblocks compile again after the <machine/mnode.h> changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.10 2009/05/30 03:59:27 miod Exp $	*/
d214 1
a214 1
	printf("UNRECOGNIZED SYSTEM '%s' VENDOR '%8.8s' PRODUCT '%8.8s'\n",
@


1.10
log
@When booting in `install software' mode from the SGI boot menu, do not try to
load bsd.rd but bsd.rd.IP## matching the IP code of the machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.9 2009/05/14 18:57:43 miod Exp $	*/
d34 1
d41 1
@


1.9
log
@In addition to the existing IP32 boot block, build a real 64 bit boot block
as a relocatable object, suitable for IP27/IP30/IP35.

Boot blocks are now found is /usr/mdec/boot{32,64}, with boot-IP## being
hard links to them for easy boot block pick.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.8 2009/05/09 18:08:59 miod Exp $	*/
d30 1
a30 1
#include <machine/autoconf.h>
d33 3
d40 1
a40 1
void	arcbios_init(void);
d44 10
d154 1
a154 1
void
d157 6
d174 45
@


1.8
log
@Promote types in ARCBios function prototypes from int to long whenever
necessary, to allow the same C code to be used against 32 bit ARCBios, when
compiled in 32 bit mode, or against 64 bit ARCBios, when compiled in native
mode.

Soon to be used by the boot blocks; this commit doesn't introduce any
functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.7 2008/03/27 15:11:37 jsing Exp $	*/
d35 1
a35 1
#define	USE_SGI_PARTITIONS	1
d37 3
a39 30
int	bios_is_32bit;

void	bios_configure_memory(void);
int	bios_get_system_type(void);
const char *bios_get_path_component(const char *, char *, int *);

static struct systypes {
	char *sys_vend;		/* Vendor ID if name is ambiguous. */
	char *sys_name;		/* May be left NULL if name is sufficient. */
	int  sys_type;
} sys_types[] = {
    { NULL,		"PICA-61",			ACER_PICA_61 },
    { NULL,		"NEC-R94",			ACER_PICA_61 },
    { NULL,		"DESKTECH-TYNE",		DESKSTATION_TYNE },
    { NULL,		"DESKTECH-ARCStation I",	DESKSTATION_RPC44 },
    { NULL,		"Microsoft-Jazz",		MAGNUM },
    { NULL,		"RM200PCI",			SNI_RM200 },
    { NULL,		"SGI-IP17",			SGI_CRIMSON },
    { NULL,		"SGI-IP19",			SGI_ONYX },
    { NULL,		"SGI-IP20",			SGI_INDIGO },
    { NULL,		"SGI-IP21",			SGI_POWER },
    { NULL,		"SGI-IP22",			SGI_INDY },
    { NULL,		"SGI-IP25",			SGI_POWER10 },
    { NULL,		"SGI-IP26",			SGI_POWERI },
    { NULL,		"SGI-IP27",			SGI_O200 },
    { NULL,		"SGI-IP30",			SGI_OCTANE },
    { NULL,		"SGI-IP32",			SGI_O2 }
};

#define KNOWNSYSTEMS (sizeof(sys_types) / sizeof(struct systypes))
d52 10
a61 2
"	lw	$2, 0xffffffff80001020\n"\
"	lw	$2," #Offset "($2)\n"\
d139 1
a139 1
 * Identify system type.
d141 2
a142 2
int
bios_get_system_type()
a143 5
	arc_config_t *cf;
	arc_sid_t *sid;
	char *sysid;
	int i, sysid_len;

a150 2
		printf("ARCS32 Firmware Version %d.%d\n",
		    ArcBiosBase32->version, ArcBiosBase32->revision);
a153 39
		printf("ARCS64 Firmware Version %d.%d\n",
		    ArcBiosBase64->version, ArcBiosBase64->revision);
	} else
		return (-1);	/* XXX BAD BAD BAD!!! */

	sid = (arc_sid_t *)Bios_GetSystemId();

	cf = (arc_config_t *)Bios_GetChild(NULL);
	if (cf != NULL) {
		if (bios_is_32bit) {
			sysid = (char *)(long)cf->id;
			sysid_len = cf->id_len;
		} else {
			sysid = (char *)((arc_config64_t *)cf)->id;
			sysid_len = ((arc_config64_t *)cf)->id_len;
		}

		if (sysid_len > 0 && sysid != NULL) {
			sysid_len--;
			for (i = 0; i < KNOWNSYSTEMS; i++) {
				if (strlen(sys_types[i].sys_name) !=sysid_len)
					continue;
				if (strncmp(sys_types[i].sys_name, sysid,
				    sysid_len) != 0)
					continue;
				if (sys_types[i].sys_vend &&
				    strncmp(sys_types[i].sys_vend, sid->vendor,
				      8) != 0)
					continue;
				return (sys_types[i].sys_type);	/* Found it. */
			}
		}
	} else {
#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
		if (IP27_KLD_KLCONFIG(0)->magic == IP27_KLDIR_MAGIC) {
			/* If we find a kldir assume IP27. */
			return (SGI_O200);
		}
#endif
a154 8

	printf("UNRECOGNIZED SYSTEM '%s' VENDOR '%8.8s' PRODUCT '%8.8s'\n",
	    cf == NULL ? "??" : sysid, sid->vendor, sid->prodid);
	printf("See www.openbsd.org for further information.\n");
	printf("Halting system!\n");
	Bios_Halt();
	printf("Halting failed, use manual reset!\n");
	while (1);
d176 24
a199 6
	while ((ncp = bios_get_path_component(cp, namebuf, &i)) != NULL) {
		if (strcmp(namebuf, "partition") == 0) {
			partition = i;
			if (USE_SGI_PARTITIONS)
				ecp = ncp;
		} else
d202 7
a208 3
		/* XXX Do this with a table if more devs are added. */
		if (strcmp(namebuf, "scsi") == 0)
			strncpy(devname, namebuf, sizeof(devname)); 
d210 2
a211 1
		cp = ncp;
a213 3
	memcpy(namebuf, fname, ecp - fname);
	namebuf[ecp - fname] = '\0';

d220 1
a220 1
		if (strcmp (devname, dp->dv_name) == 0) {
d235 1
a235 1
bios_get_path_component(const char *p, char *comp, int *no)
d253 9
@


1.7
log
@Remove unwanted code and sync with mips64/arcbios.c.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.3 2004/09/16 18:54:48 pefo Exp $	*/
d131 1
a131 1
	int cnt;
d143 1
a143 1
	int cnt;
@


1.6
log
@Cleanup/style(9) code and comments.
@
text
@d37 2
a42 2
arc_dsp_stat_t	displayinfo;	/* Save area for display status info. */

d61 2
a148 2
		if (displayinfo.CursorYPosition < displayinfo.CursorMaxYPosition)
			displayinfo.CursorYPosition++;
a156 7
void
bios_putstring(char *s)
{
	while (*s)
		putchar(*s++);
}

d165 2
a166 1
	int i;
d168 16
a183 4
	if ((ArcBiosBase32->magic != ARC_PARAM_BLK_MAGIC) &&
	    (ArcBiosBase32->magic != ARC_PARAM_BLK_MAGIC_BUG)) {
		return (-1);	/* This is not an ARC system. */
	}
d186 1
d188 23
a210 8
	if (cf) {
		for (i = 0; i < KNOWNSYSTEMS; i++) {
			if (strcmp(sys_types[i].sys_name, (char *)cf->id) != 0)
				continue;
			if (sys_types[i].sys_vend &&
			    strncmp(sys_types[i].sys_vend, sid->vendor, 8) != 0)
				continue;
			return (sys_types[i].sys_type);	/* Found it. */
d212 7
d221 6
a226 10
	bios_putstring("UNIDENTIFIED SYSTEM `");
	if (cf)
		bios_putstring((char *)cf->id);
	else
		bios_putstring("????????");
	bios_putstring("' VENDOR `");
	sid->vendor[8] = 0;
	bios_putstring(sid->vendor);
	bios_putstring("'. Please contact OpenBSD (www.openbsd.org).\n");
	bios_putstring("Reset system to restart!\n");
a227 15
}

/*
 * Return geometry of the display. Used by pccons.c to set up the
 * display configuration.
 */
void
bios_display_info(int *xpos, int *ypos, int *xsize, int *ysize)
{
#ifdef __arc__
	*xpos = displayinfo.CursorXPosition;
	*ypos = displayinfo.CursorYPosition;
	*xsize = displayinfo.CursorMaxXPosition;
	*ysize = displayinfo.CursorMaxYPosition;
#endif
@


1.5
log
@Remove duplicate strcmp().

From Iruata Souza <iru.muzgo@@gmail.com>
@
text
@d37 2
a38 2
void bios_configure_memory(void);
int bios_get_system_type(void);
d41 1
a41 1
arc_dsp_stat_t	displayinfo;		/* Save area for display status info. */
d44 2
a45 2
	char *sys_vend;		/* Vendor ID if name is ambigous */
	char *sys_name;		/* May be left NULL if name is sufficient */
d61 1
a61 1
    { NULL,		"SGI-IP32",			SGI_O2 },
d67 1
a67 1
 *	ARC Bios trampoline code.
d122 1
a122 1
 *	Simple getchar/putchar interface.
d129 1
a129 1
	int  cnt;
d132 3
a134 2
		return(-1);
	return(buf[0] & 255);
d138 1
a138 2
putchar(c)
char c;
d141 1
a141 1
	int  cnt;
d149 1
a149 2
	}
	else {
d153 1
d158 1
a158 2
bios_putstring(s)
char *s;
d160 1
a160 1
	while (*s) {
a161 1
	}
d165 1
a165 1
 * Find out system type.
d170 3
a172 3
	arc_config_t	*cf;
	arc_sid_t	*sid;
	int		i;
d176 1
a176 1
		return(-1);	/* This is not an ARC system */
d202 1
a202 1
	while(1);
d210 1
a210 5
bios_display_info(xpos, ypos, xsize, ysize)
    int	*xpos;
    int	*ypos;
    int *xsize;
    int *ysize;
a219 1

d237 1
a237 1
	 *  Scan the component list and find device and partition.
d247 1
a247 1
		/* XXX do this with a table if more devs are added */
d258 1
a258 1
	 *  Dig out the driver.
d274 1
a274 1
	return ENXIO;
d280 1
a280 1
	while (*p && *p != '(') {
a281 1
	}
d285 1
a285 1
		return NULL;
d293 1
a293 1
			return NULL;
d295 1
a295 1
	return ++p;
@


1.4
log
@Fix some 64 bit address problems.
Some function names made more unique.
Other changes for the upcoming Origin 200 support.
@
text
@d247 1
a247 2
		if ((strcmp(namebuf, "partition") == 0) ||
		    (strcmp(namebuf, "partition") == 0)) {
@


1.3
log
@Update boot with miods ELF64 symtab fixes and my 32 bit compiles
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.2 2004/08/25 18:19:35 pefo Exp $	*/
a36 2
arc_param_blk_t *bios_base = ArcBiosBase;

d176 2
a177 2
	if ((bios_base->magic != ARC_PARAM_BLK_MAGIC) &&
	    (bios_base->magic != ARC_PARAM_BLK_MAGIC_BUG)) {
@


1.2
log
@Minor tweaks to make things work in install.
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.1 2004/08/23 14:22:40 pefo Exp $	*/
d187 1
a187 1
			if (strcmp(sys_types[i].sys_name, cf->id) != 0)
d198 1
a198 1
		bios_putstring(cf->id);
d248 1
a248 1
	while (ncp = bios_get_path_component(cp, namebuf, &i)) {
@


1.1
log
@disk boot and tools for sgi
@
text
@d1 1
a1 1
/*	$OpenBSD: arcbios.c,v 1.3 2004/08/10 20:15:47 deraadt Exp $	*/
a269 1
printf("looking: %s, %s, %d\n", devname, namebuf, partition);
@

