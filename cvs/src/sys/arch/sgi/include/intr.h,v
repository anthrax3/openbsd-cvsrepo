head	1.49;
access;
symbols
	OPENBSD_6_2:1.49.0.2
	OPENBSD_6_2_BASE:1.49
	OPENBSD_6_1:1.48.0.4
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.47.0.2
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.43.0.4
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.43.0.8
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.43.0.6
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.43.0.2
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.42.0.10
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.42.0.8
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.6
	OPENBSD_5_0:1.42.0.4
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.41.0.4
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.26.0.2
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.20.0.6
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.49
date	2017.06.11.10.01.23;	author visa;	state Exp;
branches;
next	1.48;
commitid	bPs1aUZZRkMdyaOc;

1.48
date	2017.02.11.03.44.22;	author visa;	state Exp;
branches;
next	1.47;
commitid	xjkuO7IpWLYltL4L;

1.47
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.46;
commitid	cyYKarj4qRTft4gD;

1.46
date	2015.12.25.09.22.00;	author visa;	state Exp;
branches;
next	1.45;
commitid	mo9Cs2HTLrPLm8sR;

1.45
date	2015.09.13.20.38.45;	author kettenis;	state Exp;
branches;
next	1.44;
commitid	MW9yRxgkKFAx03on;

1.44
date	2015.07.08.13.37.31;	author dlg;	state Exp;
branches;
next	1.43;
commitid	Ds9kNjjKbF4CbIsT;

1.43
date	2013.05.17.19.38.52;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2010.12.21.14.56.24;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.18.16.59.23;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2009.12.28.06.55.27;	author syuu;	state Exp;
branches;
next	1.39;

1.39
date	2009.12.02.01.52.28;	author syuu;	state Exp;
branches;
next	1.38;

1.38
date	2009.11.26.23.32.46;	author syuu;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.25.17.39.51;	author syuu;	state Exp;
branches;
next	1.36;

1.36
date	2009.11.25.11.23.30;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.26.20.14.14;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2009.10.22.22.08.54;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.22.20.39.17;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.22.20.10.46;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.22.20.05.28;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.21.20.48.45;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.07.08.35.47;	author syuu;	state Exp;
branches;
next	1.28;

1.28
date	2009.09.15.04.54.31;	author syuu;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.22.02.54.51;	author mk;	state Exp;
branches;
next	1.26;

1.26
date	2009.06.12.19.52.15;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.10.18.05.31;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.05.22.20.37.53;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.05.21.16.08.05;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.03.20.18.41.07;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2009.03.15.19.40.40;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2007.12.06.12.34.39;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.14.18.52.11;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.20.16.50.41;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.07.18.42.13;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.23.21.07.39;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.09.22.10.05;	author mk;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.12.03.14.37;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.19.15.29.48;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.31.21.35.50;	author grange;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.02.19.34.15;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.20.12.49.15;	author pefo;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.27.19.20.49;	author pefo;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.24.14.22.48;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.21.05.51.15;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.20.15.10.35;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.20.10.33.20;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.20.10.31.16;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.19.16.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.10.18.52.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.21.12.19;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Define register_splx_handler() in one place.
@
text
@/*	$OpenBSD: intr.h,v 1.48 2017/02/11 03:44:22 visa Exp $ */

/*
 * Copyright (c) 2001-2004 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#ifndef _MACHINE_INTR_H_
#define _MACHINE_INTR_H_

/*
 * The interrupt level ipl is a logical level; per-platform interrupt
 * code will turn it into the appropriate hardware interrupt masks
 * values.
 *
 * Interrupt sources on the CPU are kept enabled regardless of the
 * current ipl value; individual hardware sources interrupting while
 * logically masked are masked on the fly, remembered as pending, and
 * unmasked at the first splx() opportunity.
 *
 * An exception to this rule is the clock interrupt. Clock interrupts
 * are always allowed to happen, but will (of course!) not be serviced
 * if logically masked.  The reason for this is that clocks usually sit on
 * INT5 and cannot be easily masked if external hardware masking is used.
 */

/* Interrupt priority `levels'; not mutually exclusive. */
#define	IPL_NONE	0	/* nothing */
#define	IPL_SOFTINT	1	/* soft interrupts */
#define	IPL_BIO		2	/* block I/O */
#define IPL_AUDIO	IPL_BIO
#define	IPL_NET		3	/* network */
#define	IPL_TTY		4	/* terminal */
#define	IPL_VM		5	/* memory allocation */
#define	IPL_CLOCK	6	/* clock */
#define	IPL_SCHED	IPL_CLOCK
#define	IPL_HIGH	7	/* everything */
#define	IPL_IPI         8       /* interprocessor interrupt */
#define	NIPLS		9	/* Number of levels */

#define IPL_MPFLOOR	IPL_TTY

/* Interrupt priority 'flags'. */
#define	IPL_MPSAFE	0x100

/* Interrupt sharing types. */
#define	IST_NONE	0	/* none */
#define	IST_PULSE	1	/* pulsed */
#define	IST_EDGE	2	/* edge-triggered */
#define	IST_LEVEL	3	/* level-triggered */

#define	SINTBIT(q)	(q)
#define	SINTMASK(q)	(1 << SINTBIT(q))

/* Soft interrupt masks. */

#define	IPL_SOFT	0
#define	IPL_SOFTCLOCK	1
#define	IPL_SOFTNET	2
#define	IPL_SOFTTTY	3

#define	SI_SOFT		0	/* for IPL_SOFT */
#define	SI_SOFTCLOCK	1	/* for IPL_SOFTCLOCK */
#define	SI_SOFTNET	2	/* for IPL_SOFTNET */
#define	SI_SOFTTTY	3	/* for IPL_SOFTTTY */

#define	SI_NQUEUES	4

#ifndef _LOCORE

#include <machine/mutex.h>
#include <sys/queue.h>

struct soft_intrhand {
	TAILQ_ENTRY(soft_intrhand) sih_list;
	void	(*sih_func)(void *);
	void	*sih_arg;
	struct soft_intrq *sih_siq;
	int	sih_pending;
};

struct soft_intrq {
	TAILQ_HEAD(, soft_intrhand) siq_list;
	int siq_si;
	struct mutex siq_mtx;
};

void	 softintr_disestablish(void *);
void	 softintr_dispatch(int);
void	*softintr_establish(int, void (*)(void *), void *);
void	 softintr_init(void);
void	 softintr_schedule(void *);

#define	splsoft()	splraise(IPL_SOFTINT)
#define splbio()	splraise(IPL_BIO)
#define splnet()	splraise(IPL_NET)
#define spltty()	splraise(IPL_TTY)
#define splaudio()	splraise(IPL_AUDIO)
#define splvm()		splraise(IPL_VM)
#define splclock()	splraise(IPL_CLOCK)
#define splsched()	splraise(IPL_SCHED)
#define splhigh()	splraise(IPL_HIGH)

#define splsoftclock()	splsoft()
#define splsoftnet()	splsoft()
#define splstatclock()	splhigh()

#define spllock()	splhigh()
#define spl0()		spllower(0)

void	splinit(void);

#define	splassert(X)
#define	splsoftassert(X)

void	register_splx_handler(void (*)(int));
int	splraise(int);
void	splx(int);
int	spllower(int);

/*
 * Interrupt control struct used by interrupt dispatchers
 * to hold interrupt handler info.
 */

#include <sys/evcount.h>

struct intrhand {
	struct	intrhand	*ih_next;
	int			(*ih_fun)(void *);
	void			*ih_arg;
	int			 ih_level;
	int			 ih_irq;
	struct evcount		 ih_count;
	int			 ih_flags;
#define	IH_ALLOCATED		0x01
#define	IH_MPSAFE		0x02
};

void	intr_barrier(void *);

/*
 * Low level interrupt dispatcher registration data.
 */

/* Schedule priorities for base interrupts (CPU) */
#define	INTPRI_IPI	0
#define	INTPRI_CLOCK	1
/* other values are system-specific */

#define NLOWINT	16		/* Number of low level registrations possible */

extern uint32_t idle_mask;

struct trapframe;
void	set_intr(int, uint32_t, uint32_t(*)(uint32_t, struct trapframe *));

uint32_t updateimask(uint32_t);
void	dosoftint(void);

#ifdef MULTIPROCESSOR
#if defined (TGT_OCTANE)
#define ENABLEIPI() updateimask(~CR_INT_2) /* enable IPI interrupt level */
#elif defined (TGT_ORIGIN)
#define ENABLEIPI() updateimask(~CR_INT_0) /* enable IPI interrupt level */
#else
#error MULTIPROCESSOR kernel not supported on this configuration
#endif
#endif

#endif /* _LOCORE */

#endif /* _MACHINE_INTR_H_ */
@


1.48
log
@Let MP-safe interrupt handlers run without the kernel lock on sgi.

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.47 2016/03/06 19:42:27 mpi Exp $ */
d137 1
a137 12
/* Inlines */
static __inline void register_splx_handler(void (*)(int));

typedef void (int_f)(int);
extern int_f *splx_hand;

static __inline void
register_splx_handler(void(*handler)(int))
{
	splx_hand = handler;
}

@


1.47
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.46 2015/12/25 09:22:00 visa Exp $ */
d65 1
a65 1
#define	IPL_MPSAFE	0	/* no "mpsafe" interrupts */
d169 1
@


1.46
log
@Add IPI logic. Assign two additional interrupts for inter-processor
signalling as a workaround to a limitation in the hub interrupt code,
to allow four CPUs per node. At the moment, multi-node setups are not
supported.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.45 2015/09/13 20:38:45 kettenis Exp $ */
d186 2
a187 2
struct trap_frame;
void	set_intr(int, uint32_t, uint32_t(*)(uint32_t, struct trap_frame *));
@


1.45
log
@intr_barrier(9) for loongson, octeon and sgi.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.44 2015/07/08 13:37:31 dlg Exp $ */
d195 2
@


1.44
log
@unify the mutex implementations on all the mips64 platforms.

this basically copies the sgi implementation to mips64 and removes
it from the rest. this way they get an optimised UP mutex implementation
and correct asserts on all platforms.

ok miod@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.43 2013/05/17 19:38:52 kettenis Exp $ */
d170 2
@


1.43
log
@Add a dummy IPL_MPSAFE definition.

ok miod@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.42 2010/12/21 14:56:24 claudio Exp $ */
d61 2
@


1.42
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.41 2010/01/18 16:59:23 miod Exp $ */
d61 3
@


1.41
log
@Define IPL_SCHED as IPL_CLOCK, not IPL_HIGH.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.40 2009/12/28 06:55:27 syuu Exp $ */
a108 5

/* XXX For legacy software interrupts. */
extern struct soft_intrhand *softnet_intrhand;

#define	setsoftnet()	softintr_schedule(softnet_intrhand)
@


1.40
log
@MP-safe pmap implemented, enable IPI in interrupt handler to avoid deadlock.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.39 2009/12/02 01:52:28 syuu Exp $ */
d57 1
d120 1
d122 1
a122 1
#define splvm()		splraise(IPL_VM)
a128 1
#define splsched()	splhigh()
@


1.39
log
@IPL_IPI priority raised to IPL_IPI > IPL_HIGH for handling TLB shootdown.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.38 2009/11/26 23:32:46 syuu Exp $ */
d188 8
@


1.38
log
@Now IPI can interrupt to clock interrupt handler.
It prevents deadlock with TLB shootdown and clock interrupt.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.37 2009/11/25 17:39:51 syuu Exp $ */
d57 2
a58 2
#define	IPL_IPI         7       /* ipi */
#define	IPL_HIGH	8	/* everything */
@


1.37
log
@IP30 IPI implementation.
Also few xheart modification for SMP.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.36 2009/11/25 11:23:30 miod Exp $ */
d175 2
a176 1
#define	INTPRI_CLOCK	0
@


1.36
log
@Allow xbow_intr_establish() callers to provide optional storage for the
struct intrhand, instead of having it malloc()'ed.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.35 2009/10/26 20:14:14 miod Exp $ */
d57 3
a59 2
#define	IPL_HIGH	7	/* everything */
#define	NIPLS		8	/* Number of levels */
@


1.35
log
@Get rid of unused `frame' member of struct intrhand; only hardclock() needs
a frame and clock interrupt doesn't need a struct intrhand.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.34 2009/10/22 22:08:54 miod Exp $ */
d165 2
@


1.34
log
@Completely overhaul interrupt handling on sgi. Cpu state now only stores a
logical IPL level, and per-platform (IP27/IP30/IP32) code will from the
necessary hardware mask registers.

This allows the use of more than one interrupt mask register. Also, the
generic (platform independent) interrupt code shrinks a lot, and the actual
interrupt handler chains and masking information is now per-platform private
data.

Interrupt dispatching is generated from a template; more routines will be
added to the template to reduce platform-specific changes and share as much
code as possible.

Tested on IP27, IP30, IP32 and IP35.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.33 2009/10/22 20:39:17 miod Exp $ */
a163 1
	void			*frame;
@


1.33
log
@The recent cleanups make blatantly visible that the pending_int handler
does almost exactly what splx() is doing if ipending is zero, and triggers
soft interrupts as well.

So don't bother checking for ipending in splx, and always invoke pending_int,
which gets renamed as splx_handler for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.32 2009/10/22 20:10:46 miod Exp $ */
d33 3
a35 4
 * The interrupt mask cpl is a mask which is used with an external
 * HW mask register.
 * The CPU mask is never changed from the value it gets when interrupt
 * dispatchers are registered.
d37 7
a43 1
 * Clock interrupts are always allowed to happen but will not be serviced
d45 1
a45 1
 * INT5 and cannot be easily masked if external HW masking is used.
d66 1
a66 1
#define	SINTBIT(q)	(31 - (q))
a68 3
#define	SPL_CLOCK	SINTBIT(SI_NQUEUES)
#define	SPL_CLOCKMASK	SINTMASK(SI_NQUEUES)

a80 2
#define	SINT_ALLMASK	(SINTMASK(SI_SOFT) | SINTMASK(SI_SOFTCLOCK) | \
			 SINTMASK(SI_SOFTNET) | SINTMASK(SI_SOFTTTY))
d113 16
a128 17
#define	splsoft()		splraise(imask[IPL_SOFTINT])
#define splbio()		splraise(imask[IPL_BIO])
#define splnet()		splraise(imask[IPL_NET])
#define spltty()		splraise(imask[IPL_TTY])
#define splaudio()		splraise(imask[IPL_AUDIO])
#define splclock()		splraise(imask[IPL_CLOCK])
#define splvm()			splraise(imask[IPL_VM])
#define splsoftclock()		splraise(SINTMASK(SI_SOFTCLOCK) | \
				    SINTMASK(SI_SOFT))
#define splsoftnet()		splraise(SINTMASK(SI_SOFTNET) | \
				    SINTMASK(SI_SOFTCLOCK) | \
				    SINTMASK(SI_SOFT))
#define splstatclock()		splhigh()
#define splsched()		splhigh()
#define spllock()		splhigh()
#define splhigh()		splraise(-1)
#define spl0()			spllower(0)
a134 12
/*
 *  Schedule prioritys for base interrupts (CPU)
 */
#define	INTPRI_CLOCK	1
#define	INTPRI_MACEIO	2	/* O2 I/O interrupt */
#define	INTPRI_XBOWMUX	2	/* Origin 200/2000 I/O interrupt */
#define	INTPRI_MACEAUX	3

#define	INTMASKSIZE	32

extern uint32_t imask[NIPLS];

d138 1
a138 1
typedef void (int_f) (int);
d159 7
a165 7
	struct	intrhand *ih_next;
	int	(*ih_fun)(void *);
	void	*ih_arg;
	int	ih_level;
	int	ih_irq;
	void	*frame;
	struct evcount ih_count;
a167 2
extern struct intrhand *intrhand[INTMASKSIZE];

d171 5
a177 2
struct trap_frame;

a178 1
extern int last_low_int;
d180 2
a181 1
void set_intr(int, uint32_t, uint32_t(*)(uint32_t, struct trap_frame *));
d183 2
a184 3
void	hw_setintrmask(uint32_t);
u_int32_t updateimask(uint32_t);
void	dosoftint(uint32_t);
@


1.32
log
@unifdef -DIMASK_EXTERNAL to the mips code. Support for interrupt masking at
coprocessor 0 sr level might come back in the future if hardware support
requires it, but at the moment it's getting in the way of larger changes.
``In the Attic, noone can hear you scream''
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.31 2009/10/22 20:05:28 miod Exp $ */
d149 1
a149 1
static __inline void register_pending_int_handler(void (*)(int));
d152 1
a152 1
extern int_f *pending_hand;
d155 1
a155 1
register_pending_int_handler(void(*pending)(int))
d157 1
a157 1
	pending_hand = pending;
@


1.31
log
@Replace intrmask_t with uint32_t. This types only describes interrupt masks
in the coprocessor 0 status register (coupled with ICR on rm7k/rm9k), and
may be completely alien to real hardware interrupt masks, so don't make
things unnecessary confusing.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.30 2009/10/21 20:48:45 miod Exp $ */
d33 4
a36 7
 *  The interrupt mask cpl is a mask which can be used with the
 *  CPU interrupt mask register or an external HW mask register.
 *  If interrupts are masked by the CPU interrupt mask all external
 *  masks should be enabled and any routing set up so that the
 *  interrupt source is routed to the CPU interrupt corresponding
 *  to the interrupts "priority level". In this case the generic
 *  interrupt handler can be used.
d38 3
a40 6
 *  The IMASK_EXTERNAL define is used to select whether the CPU
 *  interrupt mask should be controlled by the cpl mask value
 *  or not. If the mask is external, the CPU mask is never changed
 *  from the value it gets when interrupt dispatchers are registered.
 *  When an external masking register is used dedicated interrupt
 *  handlers must be written as well as ipending handlers.
a41 4
#define	IMASK_EXTERNAL		/* XXX move this to config */

/* This define controls whether splraise is inlined or not */
/* #define INLINE_SPLRAISE */
a147 7
/*
 *  A note on clock interrupts. Clock interrupts are always
 *  allowed to happen but will not be serviced if masked.
 *  The reason for this is that clocks usually sit on INT5
 *  and cannot be easily masked if external HW masking is used.
 */

a176 1
	const char	*ih_what;
d195 1
a195 4
#ifdef IMASK_EXTERNAL
void hw_setintrmask(uint32_t);
#endif

@


1.30
log
@Replace IP32 hw_setintrmask() .S routine with a two line C routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.29 2009/10/07 08:35:47 syuu Exp $ */
d154 1
a154 6
/*
 *   Define a type for interrupt masks. We may need 64 bits here.
 */
typedef u_int32_t intrmask_t;		/* Type of var holding interrupt mask */

#define	INTMASKSIZE	(sizeof(intrmask_t) * 8)
d156 1
a156 1
extern intrmask_t imask[NIPLS];
d208 1
a208 1
extern intrmask_t idle_mask;
d211 1
a211 1
void set_intr(int, intrmask_t, intrmask_t(*)(intrmask_t, struct trap_frame *));
d214 1
a214 1
void hw_setintrmask(intrmask_t);
d217 2
a218 2
u_int32_t updateimask(intrmask_t);
void	dosoftint(intrmask_t);
@


1.29
log
@ipending, cpl moved into cpu_info
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.28 2009/09/15 04:54:31 syuu Exp $ */
a219 1
extern void *hwmask_addr;
@


1.28
log
@cpu status flag, cpuid added to cpu_info.
cpu_info pointer array, cpu_info iterator, cpu_number() implementation added.
constraint modifier fixed in lock.h to output correct assembly.
calling proc_trampoline_mp in exception.S.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.27 2009/08/22 02:54:51 mk Exp $ */
a159 3

extern volatile intrmask_t cpl;
extern volatile intrmask_t ipending;
@


1.27
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.26 2009/06/12 19:52:15 miod Exp $ */
d137 1
@


1.26
log
@Make sure splsoftnet() masks softclock; fallout form switch to generic
soft interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.25 2009/06/10 18:05:31 miod Exp $ */
d201 1
a201 1
	char	*ih_what;
@


1.25
log
@Switch sgi to per-process AST, and move ast() from interrupt.c to trap.c
where it can use userret() instead of duplicating it.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.24 2009/05/22 20:37:53 miod Exp $ */
d130 5
a134 2
#define splsoftclock()		splraise(SINTMASK(SI_SOFTCLOCK))
#define splsoftnet()		splraise(SINTMASK(SI_SOFTNET))
@


1.24
log
@Drop almost unused <machine/psl.h> on sgi; move USERMODE() definition from
there to trap.c which is its only user. This also cleans up multiple
inclusion of <machine/cpu.h> (because <machine/psl.h> includes it) in many
places.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.23 2009/05/21 16:08:05 miod Exp $ */
a158 1
extern volatile intrmask_t astpending;
@


1.23
log
@Make sure splx() reenables hardware interrupt sources, even there aren't
any such interrupts marked as pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.22 2009/03/20 18:41:07 miod Exp $ */
d223 1
@


1.22
log
@Switch sgi to __HAVE_GENERIC_SOFT_INTERRUPTS.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.21 2009/03/15 19:40:40 miod Exp $ */
a171 2
static __inline void splx(int newcpl);
static __inline int spllower(int newcpl);
d173 1
a173 1
typedef void  (int_f) (int);
d182 3
a184 40
/*
 */
#ifdef INLINE_SPLRAISE
static __inline int splraise(int newcpl);
static __inline int
splraise(int newcpl)
{
	int oldcpl;

	__asm__ (" .set noreorder\n");
	oldcpl = cpl;
	cpl = oldcpl | newcpl;
	__asm__ (" sync\n .set reorder\n");
	return (oldcpl);
}
#else
int splraise(int newcpl);
#endif

static __inline void
splx(int newcpl)
{
	if (ipending & ~newcpl)
		(*pending_hand)(newcpl);
	else
		cpl = newcpl;
}

static __inline int
spllower(int newcpl)
{
	int oldcpl;

	oldcpl = cpl;
	if (ipending & ~newcpl)
		(*pending_hand)(newcpl);
	else
		cpl = newcpl;
	return (oldcpl);
}
d201 1
a201 1
	struct evcount  ih_count;
@


1.21
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.20 2007/12/06 12:34:39 jsing Exp $ */
a52 1

d55 2
a56 1
#define	IPL_BIO		1	/* block I/O */
d58 6
a63 6
#define	IPL_NET		2	/* network */
#define	IPL_TTY		3	/* terminal */
#define	IPL_VM		4	/* memory allocation */
#define	IPL_CLOCK	5	/* clock */
#define	IPL_HIGH	6	/* everything */
#define	NIPLS		7	/* Number of levels */
d71 6
d78 14
a91 9
#define	SINT_CLOCK	31
#define	SINT_CLOCKMASK	(1 << SINT_CLOCK)
#define	SINT_NET	30
#define	SINT_NETMASK	((1 << SINT_NET) | SINT_CLOCKMASK)
#define	SINT_TTY	29
#define	SINT_TTYMASK	((1 << SINT_TTY) | SINT_CLOCKMASK)
#define	SINT_ALLMASK	(SINT_CLOCKMASK | SINT_NETMASK | SINT_TTYMASK)
#define	SPL_CLOCK	28
#define	SPL_CLOCKMASK	(1 << SPL_CLOCK)
d95 29
d130 2
a131 3
#define splsoftclock()		splraise(SINT_CLOCKMASK)
#define splsoftnet()		splraise(SINT_NETMASK|SINT_CLOCKMASK)
#define splsofttty()		splraise(SINT_TTYMASK)
a136 6
#include <machine/atomic.h>

#define setsoftclock()  	atomic_setbits_int(&ipending, SINT_CLOCKMASK)
#define setsoftnet()    	atomic_setbits_int(&ipending, SINT_NETMASK)
#define setsofttty()    	atomic_setbits_int(&ipending, SINT_TTYMASK)

d262 1
a262 12
/*
 *  Generic interrupt handling code that can be used for simple
 *  interrupt hardware models. Functions can also be used by
 *  more complex code especially the mask calculation code.
 */

void *generic_intr_establish(void *, u_long, int, int,
	    int (*)(void *), void *, char *);
void generic_intr_disestablish(void *, void *);
void generic_intr_makemasks(void);
void generic_do_pending_int(int);
intrmask_t generic_iointr(intrmask_t, struct trap_frame *);
@


1.20
log
@Fix typos/grammatical error in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.19 2007/10/14 18:52:11 miod Exp $ */
d107 1
@


1.19
log
@registred -> registered
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.18 2007/06/20 16:50:41 miod Exp $ */
d109 1
a109 1
 *  Schedule prioritys for base interrupts (cpu)
d132 2
a133 2
 *  The reason for this is that clocks usually sits on INT5
 *  and can not be easily masked if external HW masking is used.
@


1.18
log
@Make sure IPL_CLOCK blocks device interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.17 2007/05/07 18:42:13 kettenis Exp $ */
d44 1
a44 1
 *  from the value it gets when interrupt dispatchers are registred.
@


1.17
log
@Move sgo to __HAVE_CPUINFO.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.16 2007/03/23 21:07:39 miod Exp $ */
d55 2
a56 1
#define	IPL_BIO		0	/* block I/O */
d58 4
a61 5
#define	IPL_NET		1	/* network */
#define	IPL_TTY		2	/* terminal */
#define	IPL_VM		3	/* memory allocation */
#define	IPL_CLOCK	4	/* clock */
#define	IPL_NONE	5	/* nothing */
d88 1
a88 1
#define splclock()		splraise(SPL_CLOCKMASK|SINT_ALLMASK)
@


1.16
log
@Real atomic_{set,clear}bits_int implementation, and replace similar
{set,clr}_ipending with the above routines.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.15 2006/07/09 22:10:05 mk Exp $ */
d94 1
@


1.15
log
@I don't think we're talking about animals in here, so
s/wether/whether/g.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.14 2006/03/12 03:14:37 brad Exp $ */
a83 1
#if 1
a92 10
#else
#define splbio()		splhigh()
#define splnet()		splhigh()
#define spltty()		splhigh()
#define splclock()		splhigh()
#define splvm()			splhigh()
#define splsoftclock()		splhigh()
#define splsoftnet()		splhigh()
#define splsofttty()		splhigh()
#endif
d97 1
d99 3
a101 3
#define setsoftclock()  set_ipending(SINT_CLOCKMASK);
#define setsoftnet()    set_ipending(SINT_NETMASK);
#define setsofttty()    set_ipending(SINT_TTYMASK);
a121 6
void clearsoftclock(void);
void clearsoftnet(void);
#if 0
void clearsofttty(void);
#endif

a188 6

/*
 *  Atomically update ipending.
 */
void set_ipending(int);
void clr_ipending(int);
@


1.14
log
@remove splimp.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.13 2005/04/19 15:29:48 mickey Exp $ */
d41 1
a41 1
 *  The IMASK_EXTERNAL define is used to select wether the CPU
d50 1
a50 1
/* This define controls wether splraise is inlined or not */
@


1.13
log
@nothing uses spllowersoftclock() anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.12 2005/01/31 21:35:50 grange Exp $ */
a89 1
#define splimp()		splraise(imask[IPL_VM])
a98 1
#define splimp()		splhigh()
@


1.12
log
@Un-__P.

ok pefo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.11 2005/01/02 19:34:15 kettenis Exp $ */
a108 1
#define spllowersoftclock()	spllower(SINT_CLOCKMASK)
@


1.11
log
@Add IPL_AUDIO/splaudio().
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.10 2004/10/20 12:49:15 pefo Exp $ */
d259 1
a259 1
	    int (*) __P((void *)), void *, char *);
@


1.10
log
@Fix some 64 bit address problems.
Some function names made more unique.
Other changes for the upcoming Origin 200 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.9 2004/09/27 19:20:49 pefo Exp $ */
d56 1
d88 1
@


1.9
log
@Rewrite parts of the interrupt system to achive:

o Remove do_pending code and take a real int instead. The performance
  impact seems to be very low and it simplifies the code considerably.

o Allow interrupt nesting at first level. Run softints with HW ints
  enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.8 2004/09/24 14:22:48 deraadt Exp $ */
d122 2
a123 1
#define	INTPRI_MACEIO	2
@


1.8
log
@new style interrupt counters; pefo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.7 2004/09/21 05:51:15 miod Exp $ */
d110 3
a112 3
#define setsoftclock()  set_sint(SINT_CLOCKMASK);
#define setsoftnet()    set_sint(SINT_NETMASK);
#define setsofttty()    set_sint(SINT_TTYMASK);
d152 1
a152 1
static __inline void register_pending_int_handler(void (*)(void));
d156 2
a157 2
typedef void  (void_f) (void);
extern void_f *pending_hand;
d160 1
a160 1
register_pending_int_handler(void(*pending)(void))
d187 4
a190 4
	cpl = newcpl;
	if ((ipending & ~newcpl) && (pending_hand != NULL)) {
		(*pending_hand)();
	}
d199 4
a202 4
	cpl = newcpl;
	if ((ipending & ~newcpl) && (pending_hand != NULL)) {
		(*pending_hand)();
	}
d209 2
a210 1
void set_sint(int pending);
d259 1
a259 1
void generic_do_pending_int(void);
@


1.7
log
@Nuke commons.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.6 2004/09/20 15:10:35 pefo Exp $ */
d216 2
a221 1
	u_long	ih_count;
d226 1
@


1.6
log
@// is not valid in asm. doh...
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.5 2004/09/20 10:33:20 pefo Exp $ */
d138 3
d142 1
a142 4
volatile intrmask_t cpl;
volatile intrmask_t ipending, astpending;

intrmask_t imask[NIPLS];
d157 1
a157 1
void_f *pending_hand;
d227 2
d236 2
a237 7
struct {
	intrmask_t int_mask;
	intrmask_t (*int_hand)(intrmask_t, struct trap_frame *);
} cpu_int_tab[NLOWINT];

intrmask_t idle_mask;
int	last_low_int;
@


1.5
log
@splraise can be inlined or not by define
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4 2004/09/20 10:31:16 pefo Exp $ */
d51 1
a51 1
// #define INLINE_SPLRAISE
@


1.4
log
@Add support for R10K cpu class
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.3 2004/08/10 19:16:18 deraadt Exp $ */
d50 2
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.2 2004/08/10 18:52:58 deraadt Exp $ */
a150 1
static __inline int splraise(int newcpl);
d165 2
d178 3
@


1.2
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.1 2004/08/06 21:12:19 pefo Exp $ */
d175 1
a175 1
	return(oldcpl);
d182 3
a184 3
	if((ipending & ~newcpl) && (pending_hand != NULL)) {
                (*pending_hand)();
        }
d194 2
a195 2
	if((ipending & ~newcpl) && (pending_hand != NULL)) {
                (*pending_hand)();
d197 1
a197 1
	return(oldcpl);
d211 7
a217 7
        struct  intrhand *ih_next;
        int     (*ih_fun)(void *);
        void    *ih_arg;
        u_long  ih_count;
        int     ih_level;
        int     ih_irq;
        char    *ih_what;
d229 2
a230 2
        intrmask_t int_mask;
        intrmask_t (*int_hand)(intrmask_t, struct trap_frame *);
@


1.1
log
@initial sgi import
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 * 
d250 1
a250 1
				int (*) __P((void *)), void *, char *); 
@

