head	1.28;
access;
symbols
	OPENBSD_6_1:1.26.0.14
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.10
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.6
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.8
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.25.0.10
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.6
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.4
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.2
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.6
	OPENBSD_5_0:1.24.0.4
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.15.0.2
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.4.0.6
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.28
date	2017.05.11.15.47.45;	author visa;	state Exp;
branches;
next	1.27;
commitid	3ClMEjcZRCcA0l1P;

1.27
date	2017.05.08.00.27.45;	author dlg;	state Exp;
branches;
next	1.26;
commitid	miRwMNEodfMJO0uz;

1.26
date	2014.03.10.21.32.15;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2012.03.15.18.52.55;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2010.08.23.16.56.15;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2010.04.04.11.24.30;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.12.25.21.02.18;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.30.21.39.15;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.26.18.48.55;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.23.19.24.56;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.22.21.28.41;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.22.20.06.20;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.17.18.06.49;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2009.05.31.17.42.13;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.05.24.17.31.05;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2009.04.20.00.42.06;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2009.04.13.21.17.54;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2008.08.25.14.05.51;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2008.07.30.17.37.44;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2008.03.30.20.14.38;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2008.02.20.19.13.38;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.27.14.11.06;	author jsing;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.21.20.17.12;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.27.00.29.55;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.02.19.33.11;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.19.16.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.10.18.52.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.21.12.18;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.28
log
@The device_to_pa routine really isn't needed. We always have physical
addresses. While there, pave the way for BUS_DMA_64BIT (not working
yet).

Diff from miod@@; OK dlg@@
@
text
@/*	$OpenBSD: bus.h,v 1.27 2017/05/08 00:27:45 dlg Exp $	*/

/*
 * Copyright (c) 2003-2004 Opsycon AB Sweden.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_BUS_H_
#define _MACHINE_BUS_H_

#ifdef __STDC__
#define CAT(a,b)	a##b
#define CAT3(a,b,c)	a##b##c
#else
#define CAT(a,b)	a/**/b
#define CAT3(a,b,c)	a/**/b/**/c
#endif

/*
 * Bus access types.
 */
struct mips_bus_space;
typedef u_long bus_addr_t;
typedef u_long bus_size_t;
typedef u_long bus_space_handle_t;
typedef struct mips_bus_space *bus_space_tag_t;
typedef struct mips_bus_space bus_space_t;

struct mips_bus_space {
	bus_addr_t	bus_base;
	void		*bus_private;
	u_int8_t	(*_space_read_1)(bus_space_tag_t , bus_space_handle_t,
			  bus_size_t);
	void		(*_space_write_1)(bus_space_tag_t , bus_space_handle_t,
			  bus_size_t, u_int8_t);
	u_int16_t	(*_space_read_2)(bus_space_tag_t , bus_space_handle_t,
			  bus_size_t);
	void		(*_space_write_2)(bus_space_tag_t , bus_space_handle_t,
			  bus_size_t, u_int16_t);
	u_int32_t	(*_space_read_4)(bus_space_tag_t , bus_space_handle_t,
			  bus_size_t);
	void		(*_space_write_4)(bus_space_tag_t , bus_space_handle_t,
			  bus_size_t, u_int32_t);
	u_int64_t	(*_space_read_8)(bus_space_tag_t , bus_space_handle_t,
			  bus_size_t);
	void		(*_space_write_8)(bus_space_tag_t , bus_space_handle_t,
			  bus_size_t, u_int64_t);
	void		(*_space_read_raw_2)(bus_space_tag_t, bus_space_handle_t,
			  bus_addr_t, u_int8_t *, bus_size_t);
	void		(*_space_write_raw_2)(bus_space_tag_t, bus_space_handle_t,
			  bus_addr_t, const u_int8_t *, bus_size_t);
	void		(*_space_read_raw_4)(bus_space_tag_t, bus_space_handle_t,
			  bus_addr_t, u_int8_t *, bus_size_t);
	void		(*_space_write_raw_4)(bus_space_tag_t, bus_space_handle_t,
			  bus_addr_t, const u_int8_t *, bus_size_t);
	void		(*_space_read_raw_8)(bus_space_tag_t, bus_space_handle_t,
			  bus_addr_t, u_int8_t *, bus_size_t);
	void		(*_space_write_raw_8)(bus_space_tag_t, bus_space_handle_t,
			  bus_addr_t, const u_int8_t *, bus_size_t);
	int		(*_space_map)(bus_space_tag_t , bus_addr_t,
			  bus_size_t, int, bus_space_handle_t *);
	void		(*_space_unmap)(bus_space_tag_t, bus_space_handle_t,
			  bus_size_t);
	int		(*_space_subregion)(bus_space_tag_t, bus_space_handle_t,
			  bus_size_t, bus_size_t, bus_space_handle_t *);
	void *		(*_space_vaddr)(bus_space_tag_t, bus_space_handle_t);
	void		(*_space_barrier)(bus_space_tag_t, bus_space_handle_t,
			  bus_size_t, bus_size_t, int);
};

#define	bus_space_read_1(t, h, o) (*(t)->_space_read_1)((t), (h), (o))
#define	bus_space_read_2(t, h, o) (*(t)->_space_read_2)((t), (h), (o))
#define	bus_space_read_4(t, h, o) (*(t)->_space_read_4)((t), (h), (o))
#define	bus_space_read_8(t, h, o) (*(t)->_space_read_8)((t), (h), (o))

#define	bus_space_write_1(t, h, o, v) (*(t)->_space_write_1)((t), (h), (o), (v))
#define	bus_space_write_2(t, h, o, v) (*(t)->_space_write_2)((t), (h), (o), (v))
#define	bus_space_write_4(t, h, o, v) (*(t)->_space_write_4)((t), (h), (o), (v))
#define	bus_space_write_8(t, h, o, v) (*(t)->_space_write_8)((t), (h), (o), (v))

#define	bus_space_read_raw_multi_2(t, h, a, b, l) \
	(*(t)->_space_read_raw_2)((t), (h), (a), (b), (l))
#define	bus_space_read_raw_multi_4(t, h, a, b, l) \
	(*(t)->_space_read_raw_4)((t), (h), (a), (b), (l))
#define	bus_space_read_raw_multi_8(t, h, a, b, l) \
	(*(t)->_space_read_raw_8)((t), (h), (a), (b), (l))

#define	bus_space_write_raw_multi_2(t, h, a, b, l) \
	(*(t)->_space_write_raw_2)((t), (h), (a), (b), (l))
#define	bus_space_write_raw_multi_4(t, h, a, b, l) \
	(*(t)->_space_write_raw_4)((t), (h), (a), (b), (l))
#define	bus_space_write_raw_multi_8(t, h, a, b, l) \
	(*(t)->_space_write_raw_8)((t), (h), (a), (b), (l))

#define	bus_space_map(t, o, s, c, p) (*(t)->_space_map)((t), (o), (s), (c), (p))
#define	bus_space_unmap(t, h, s) (*(t)->_space_unmap)((t), (h), (s))
#define	bus_space_subregion(t, h, o, s, p) \
    (*(t)->_space_subregion)((t), (h), (o), (s), (p))

#define	BUS_SPACE_MAP_CACHEABLE		0x01
#define	BUS_SPACE_MAP_LINEAR		0x02
#define	BUS_SPACE_MAP_PREFETCHABLE	0x04

#define	bus_space_vaddr(t, h)	(*(t)->_space_vaddr)((t), (h))

/*----------------------------------------------------------------------------*/
#define bus_space_read_multi(n,m)					      \
static __inline void							      \
CAT(bus_space_read_multi_,n)(bus_space_tag_t bst, bus_space_handle_t bsh,     \
     bus_size_t o, CAT3(u_int,m,_t) *x, size_t cnt)			      \
{									      \
	while (cnt--)							      \
		*x++ = CAT(bus_space_read_,n)(bst, bsh, o);		      \
}

bus_space_read_multi(1,8)
bus_space_read_multi(2,16)
bus_space_read_multi(4,32)
bus_space_read_multi(8,64)

/*----------------------------------------------------------------------------*/
#define bus_space_read_region(n,m)					      \
static __inline void							      \
CAT(bus_space_read_region_,n)(bus_space_tag_t bst, bus_space_handle_t bsh,    \
     bus_addr_t ba, CAT3(u_int,m,_t) *x, size_t cnt)			      \
{									      \
	while (cnt--)							      \
		*x++ = CAT(bus_space_read_,n)(bst, bsh, ba++);		      \
}

bus_space_read_region(1,8)
bus_space_read_region(2,16)
bus_space_read_region(4,32)
bus_space_read_region(8,64)

/*----------------------------------------------------------------------------*/
#define bus_space_read_raw_region(n,m)					      \
static __inline void							      \
CAT(bus_space_read_raw_region_,n)(bus_space_tag_t bst,			      \
     bus_space_handle_t bsh,						      \
     bus_addr_t ba, u_int8_t *x, size_t cnt)				      \
{									      \
	cnt >>= ((n) >> 1);						      \
	while (cnt--) {							      \
		CAT(bus_space_read_raw_multi_,n)(bst, bsh, ba, x, (n));	      \
		ba += (n);						      \
		x += (n);						      \
	}								      \
}

bus_space_read_raw_region(2,16)
bus_space_read_raw_region(4,32)
bus_space_read_raw_region(8,64)

/*----------------------------------------------------------------------------*/
#define bus_space_write_multi(n,m)					      \
static __inline void							      \
CAT(bus_space_write_multi_,n)(bus_space_tag_t bst, bus_space_handle_t bsh,    \
     bus_size_t o, const CAT3(u_int,m,_t) *x, size_t cnt)		      \
{									      \
	while (cnt--) {							      \
		CAT(bus_space_write_,n)(bst, bsh, o, *x++);		      \
	}								      \
}

bus_space_write_multi(1,8)
bus_space_write_multi(2,16)
bus_space_write_multi(4,32)
bus_space_write_multi(8,64)

/*----------------------------------------------------------------------------*/
#define bus_space_write_region(n,m)					      \
static __inline void							      \
CAT(bus_space_write_region_,n)(bus_space_tag_t bst, bus_space_handle_t bsh,   \
     bus_addr_t ba, const CAT3(u_int,m,_t) *x, size_t cnt)		      \
{									      \
	while (cnt--) {							      \
		CAT(bus_space_write_,n)(bst, bsh, ba, *x++);		      \
		ba += sizeof(x);					      \
	}								      \
}

bus_space_write_region(1,8)
bus_space_write_region(2,16)
bus_space_write_region(4,32)
bus_space_write_region(8,64)

/*----------------------------------------------------------------------------*/
#define bus_space_write_raw_region(n,m)					      \
static __inline void							      \
CAT(bus_space_write_raw_region_,n)(bus_space_tag_t bst,			      \
     bus_space_handle_t bsh,						      \
     bus_addr_t ba, const u_int8_t *x, size_t cnt)			      \
{									      \
	cnt >>= ((n) >> 1);						      \
	while (cnt--) {							      \
		CAT(bus_space_write_raw_multi_,n)(bst, bsh, ba, x, (n));      \
		ba += (n);						      \
		x += (n);						      \
	}								      \
}

bus_space_write_raw_region(2,16)
bus_space_write_raw_region(4,32)
bus_space_write_raw_region(8,64)

/*----------------------------------------------------------------------------*/
#define bus_space_set_region(n,m)					      \
static __inline void							      \
CAT(bus_space_set_region_,n)(bus_space_tag_t bst, bus_space_handle_t bsh,     \
     bus_addr_t ba, CAT3(u_int,m,_t) x, size_t cnt)			      \
{									      \
	while (cnt--) {							      \
		CAT(bus_space_write_,n)(bst, bsh, ba, x);		      \
		ba += sizeof(x);					      \
	}								      \
}

bus_space_set_region(1,8)
bus_space_set_region(2,16)
bus_space_set_region(4,32)
bus_space_set_region(8,64)

/*----------------------------------------------------------------------------*/
static __inline void
bus_space_copy_1(void *v, bus_space_handle_t h1, bus_size_t o1,
	bus_space_handle_t h2, bus_size_t o2, bus_size_t c)
{
	char *s = (char *)(h1 + o1);
	char *d = (char *)(h2 + o2);

	while (c--)
		*d++ = *s++;
}


static __inline void
bus_space_copy_2(void *v, bus_space_handle_t h1, bus_size_t o1,
	bus_space_handle_t h2, bus_size_t o2, bus_size_t c)
{
	short *s = (short *)(h1 + o1);
	short *d = (short *)(h2 + o2);

	while (c--)
		*d++ = *s++;
}

static __inline void
bus_space_copy_4(void *v, bus_space_handle_t h1, bus_size_t o1,
	bus_space_handle_t h2, bus_size_t o2, bus_size_t c)
{
	int *s = (int *)(h1 + o1);
	int *d = (int *)(h2 + o2);

	while (c--)
		*d++ = *s++;
}

static __inline void
bus_space_copy_8(void *v, bus_space_handle_t h1, bus_size_t o1,
	bus_space_handle_t h2, bus_size_t o2, bus_size_t c)
{
	int64_t *s = (int64_t *)(h1 + o1);
	int64_t *d = (int64_t *)(h2 + o2);

	while (c--)
		*d++ = *s++;
}

/*----------------------------------------------------------------------------*/
/*
 * Bus read/write barrier methods.
 *
 *	void bus_space_barrier(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    bus_size_t len, int flags);
 *
 */
static __inline void
bus_space_barrier(bus_space_tag_t t, bus_space_handle_t h, bus_size_t offs,
    bus_size_t len, int flags)
{
	(*(t)->_space_barrier)(t, h, offs, len, flags);
}

#define BUS_SPACE_BARRIER_READ  0x01		/* force read barrier */
#define BUS_SPACE_BARRIER_WRITE 0x02		/* force write barrier */

#define	BUS_DMA_WAITOK		0x0000
#define	BUS_DMA_NOWAIT		0x0001
#define	BUS_DMA_ALLOCNOW	0x0002
#define	BUS_DMA_COHERENT	0x0008
#define	BUS_DMA_BUS1		0x0010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x0020
#define	BUS_DMA_BUS3		0x0040
#define	BUS_DMA_BUS4		0x0080
#define	BUS_DMA_READ		0x0100	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x0200	/* mapping is memory -> device only */
#define	BUS_DMA_STREAMING	0x0400	/* hint: sequential, unidirectional */
#define	BUS_DMA_ZERO		0x0800	/* zero memory in dmamem_alloc */
#define	BUS_DMA_NOCACHE		0x1000
#define	BUS_DMA_64BIT		0x2000	/* device handles 64bit dva */

/* Forwards needed by prototypes below. */
struct mbuf;
struct proc;
struct uio;

#define	BUS_DMASYNC_POSTREAD	0x0001
#define BUS_DMASYNC_POSTWRITE	0x0002
#define BUS_DMASYNC_PREREAD	0x0004
#define BUS_DMASYNC_PREWRITE	0x0008

typedef struct machine_bus_dma_tag	*bus_dma_tag_t;
typedef struct machine_bus_dmamap	*bus_dmamap_t;

/*
 *	bus_dma_segment_t
 *
 *	Describes a single contiguous DMA transaction.  Values
 *	are suitable for programming into DMA registers.
 */
struct machine_bus_dma_segment {
	bus_addr_t	ds_addr;	/* DMA address */
	bus_size_t	ds_len;		/* length of transfer */

	paddr_t		_ds_paddr;	/* CPU address */
	vaddr_t		_ds_vaddr;	/* CPU address - only valid after
					   calling bus_dmamap_load*() */
};
typedef struct machine_bus_dma_segment	bus_dma_segment_t;

/*
 *	bus_dma_tag_t
 *
 *	A machine-dependent opaque type describing the implementation of
 *	DMA for a given bus.
 */

struct machine_bus_dma_tag {
	void	*_cookie;		/* cookie used in the guts */

	/*
	 * DMA mapping methods.
	 */
	int	(*_dmamap_create)(bus_dma_tag_t , bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t , bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t , bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t , bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t , bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(bus_dma_tag_t , bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	int	(*_dmamap_load_buffer)(bus_dma_tag_t, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int, paddr_t *, int *, int);
	void	(*_dmamap_unload)(bus_dma_tag_t , bus_dmamap_t);
	void	(*_dmamap_sync)(bus_dma_tag_t , bus_dmamap_t,
		    bus_addr_t, bus_size_t, int);

	/*
	 * DMA memory utility functions.
	 */
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	void	(*_dmamem_free)(bus_dma_tag_t, bus_dma_segment_t *, int);
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int);

	/*
	 * internal memory address translation information.
	 */
	bus_addr_t (*_pa_to_device)(paddr_t, int);
	bus_addr_t _dma_mask;
};

#define	bus_dmamap_create(t, s, n, m, b, f, p)			\
	(*(t)->_dmamap_create)((t), (s), (n), (m), (b), (f), (p))
#define	bus_dmamap_destroy(t, p)				\
	(*(t)->_dmamap_destroy)((t), (p))
#define	bus_dmamap_load(t, m, b, s, p, f)			\
	(*(t)->_dmamap_load)((t), (m), (b), (s), (p), (f))
#define	bus_dmamap_load_mbuf(t, m, b, f)			\
	(*(t)->_dmamap_load_mbuf)((t), (m), (b), (f))
#define	bus_dmamap_load_uio(t, m, u, f)				\
	(*(t)->_dmamap_load_uio)((t), (m), (u), (f))
#define	bus_dmamap_load_raw(t, m, sg, n, s, f)			\
	(*(t)->_dmamap_load_raw)((t), (m), (sg), (n), (s), (f))
#define	bus_dmamap_unload(t, p)					\
	(*(t)->_dmamap_unload)((t), (p))
#define	bus_dmamap_sync(t, p, a, l, o)				\
	(void)((t)->_dmamap_sync ?				\
	    (*(t)->_dmamap_sync)((t), (p), (a), (l), (o)) : (void)0)

#define	bus_dmamem_alloc(t, s, a, b, sg, n, r, f)		\
	(*(t)->_dmamem_alloc)((t), (s), (a), (b), (sg), (n), (r), (f))
#define	bus_dmamem_free(t, sg, n)				\
	(*(t)->_dmamem_free)((t), (sg), (n))
#define	bus_dmamem_map(t, sg, n, s, k, f)			\
	(*(t)->_dmamem_map)((t), (sg), (n), (s), (k), (f))
#define	bus_dmamem_unmap(t, k, s)				\
	(*(t)->_dmamem_unmap)((t), (k), (s))
#define	bus_dmamem_mmap(t, sg, n, o, p, f)			\
	(*(t)->_dmamem_mmap)((t), (sg), (n), (o), (p), (f))

int	_dmamap_create(bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *);
void	_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t, struct mbuf *, int);
int	_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t, struct uio *, int);
int	_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
int	_dmamap_load_buffer(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int, paddr_t *, int *, int);
void	_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int);

int	_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t,
	    bus_size_t, bus_dma_segment_t *, int, int *, int);
void	_dmamem_free(bus_dma_tag_t, bus_dma_segment_t *, int);
int	_dmamem_map(bus_dma_tag_t, bus_dma_segment_t *,
	    int, size_t, caddr_t *, int);
void	_dmamem_unmap(bus_dma_tag_t, caddr_t, size_t);
paddr_t	_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t *, int, off_t, int, int);
int	_dmamem_alloc_range(bus_dma_tag_t, bus_size_t, bus_size_t, bus_size_t,
	    bus_dma_segment_t *, int, int *, int, paddr_t, paddr_t);

/*
 *	bus_dmamap_t
 *
 *	Describes a DMA mapping.
 */
struct machine_bus_dmamap {
	/*
	 * PRIVATE MEMBERS: not for use by machine-independent code.
	 */
	bus_size_t	_dm_size;	/* largest DMA transfer mappable */
	int		_dm_segcnt;	/* number of segs this map can map */
	bus_size_t	_dm_maxsegsz;	/* largest possible segment */
	bus_size_t	_dm_boundary;	/* don't cross this */
	int		_dm_flags;	/* misc. flags */

	void		*_dm_cookie;	/* cookie for bus-specific functions */

	/*
	 * PUBLIC MEMBERS: these are used by machine-independent code.
	 */
	bus_size_t	dm_mapsize;	/* size of the mapping */
	int		dm_nsegs;	/* # valid segments in mapping */
	bus_dma_segment_t dm_segs[1];	/* segments; variable length */
};

#endif /* _MACHINE_BUS_H_ */
@


1.27
log
@add a BUS_DMA_64BIT flag to bus_dma on all our archs.

this is so drivers can advertise that they can handle 64 dma addresses
to the platform. it may choose to handle dmamaps differently based
on this flag.

tweaks and ok tom@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.26 2014/03/10 21:32:15 miod Exp $	*/
d347 2
a348 1
	vaddr_t		_ds_vaddr;	/* CPU address */
d397 1
a397 2
	bus_addr_t (*_pa_to_device)(paddr_t);
	paddr_t	(*_device_to_pa)(bus_addr_t);
@


1.26
log
@Support BUS_DMA_NOCACHE in bus_dma(9). Memory allocations done with
BUS_DMA_NOCACHE (or BUS_DMA_COHERENT if the platform does not have coherent
caches) will use PMAP_NOCACHE when invoking pmap_enter(), to avoid creating
cached mappings, and then evicting them from the cache.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.25 2012/03/15 18:52:55 miod Exp $	*/
d321 1
@


1.25
log
@No longer allow bus_space_barrier() to be a NULL pointer on a given
bus_space_tag on sgi, but rather always provide at least a dummy asm("sync")
flavour. Saves a function pointer test at runtime.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.24 2010/08/23 16:56:15 miod Exp $	*/
d212 1
a212 1
     bus_addr_t ba, const u_int8_t *x, size_t cnt)		              \
d308 13
a320 12
#define	BUS_DMA_WAITOK		0x000
#define	BUS_DMA_NOWAIT		0x001
#define	BUS_DMA_ALLOCNOW	0x002
#define	BUS_DMA_COHERENT	0x008
#define	BUS_DMA_BUS1		0x010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x020
#define	BUS_DMA_BUS3		0x040
#define	BUS_DMA_BUS4		0x080
#define	BUS_DMA_READ		0x100   /* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x200   /* mapping is memory -> device only */
#define	BUS_DMA_STREAMING	0x400   /* hint: sequential, unidirectional */
#define	BUS_DMA_ZERO		0x800	/* zero memory in dmamem_alloc */
d452 1
a452 1
	    bus_dma_segment_t *, int, int *, int, vaddr_t, vaddr_t);
@


1.24
log
@Implement bus_space_barrier() on sgi; on xbridge, this will also flush
the pci write buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.23 2010/04/04 11:24:30 miod Exp $	*/
d302 1
a302 4
	if (t->_space_barrier != NULL)
		(*(t)->_space_barrier)(t, h, offs, len, flags);
	else
		__asm__ __volatile__ ("sync" ::: "memory");
@


1.23
log
@Fix bus_space_{read,write}_raw_region_# operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.22 2009/12/25 21:02:18 miod Exp $	*/
d86 2
d298 10
a307 2
#define bus_space_barrier(t, h, o, l, f)	\
	((void)((void)(t), (void)(h), (void)(o), (void)(l), (void)(f)))
@


1.22
log
@Pass both the virtual address and the physical address of the memory range
when invoking the cache functions. The physical address is needed when
operating on physically-indexed caches, such as the L2 cache on Loongson
processors.

Preprocessor abuse makes sure that the physical address computation gets
compiled out when running on a kernel compiled for virtually-indexed
caches only, such as the sgi kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.21 2009/07/30 21:39:15 miod Exp $	*/
d162 1
a162 1
		CAT(bus_space_read_raw_multi_,n)(bst, bsh, ba, x, 1);	      \
d214 1
a214 1
		CAT(bus_space_write_raw_multi_,n)(bst, bsh, ba, x, 1);	      \
@


1.21
log
@Get rid of the obsolet BUS_BARRIER_xxx constants for bus_space_barrier(), only
provide and use BUS_SPACE_BARRIER_xxx.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.20 2009/07/26 18:48:55 miod Exp $	*/
d337 2
a338 1
	bus_addr_t	_ds_vaddr;	/* CPU address */
@


1.20
log
@Make sure all platforms understand the flags argument of bus_space_map() and
bus_space_alloc() as a bitmask of flags, and not a boolean controlling
cacheability; and make sure the three MI BUS_SPACE_MAP_xxx values documented
in the manual page are defined on all platforms as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.19 2009/07/23 19:24:56 miod Exp $	*/
a299 4

/* Compatibility defines */
#define BUS_BARRIER_READ	BUS_SPACE_BARRIER_READ
#define BUS_BARRIER_WRITE	BUS_SPACE_BARRIER_WRITE
@


1.19
log
@Get rid of bus_mem_add_mapping().
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.18 2009/07/22 21:28:41 miod Exp $	*/
d117 4
a303 3

#define	BUS_SPACE_MAP_CACHEABLE	0x01
#define BUS_SPACE_MAP_LINEAR	0x02
@


1.18
log
@Get rid of bus_space_tag_t now unused bus_extent and bus_reverse fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.17 2009/07/22 20:06:20 miod Exp $	*/
a117 4

/* Helper function in pmap.c */
int bus_mem_add_mapping(bus_addr_t, bus_size_t, int, bus_space_handle_t *);

@


1.17
log
@Define BUS_SPACE_MAP_CACHEABLE.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.16 2009/07/17 18:06:49 miod Exp $	*/
a48 1
	struct extent	*bus_extent;
a50 1
	int32_t		bus_reverse;
@


1.16
log
@Update bus_dma to the better codebase found on almost all other platforms,
where the common part to all bus_dmamap_load*() functions is implemented in
in an internal load_buffer routine.

This allows the xbridge-specific dma code to only provide this function,
instead of three; and this also brings us a working bus_dmamap_load_uio()
on all supported sgi machines, which in turns make crpyto(4) devices really
work. Tested with hifn(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.15 2009/05/31 17:42:13 miod Exp $	*/
d307 1
@


1.15
log
@Remove BUS_DMAMEM_NOSYNC definition. Its name is not consistent with
other BUS_DMA_xxx flag names, and nothing uses it.

ok many@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.14 2009/05/24 17:31:05 miod Exp $	*/
d373 2
d437 2
@


1.14
log
@Revert the memory range restriction code added to _dmamem_alloc(); devices
which require it will provide their own _dmamem_alloc() in their own
bus_dma_tag_t.

While there, rename bus_dma_segment_t ds_vaddr member to _ds_vaddr to make
it clear this is an internal member.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.13 2009/04/20 00:42:06 oga Exp $	*/
a311 1
#define	BUS_DMAMEM_NOSYNC	0x004
@


1.13
log
@Add a BUS_DMA_ZERO flag for bus_dmamem_alloc() to return zeroed memory.

Saves every damned driver calling bzero(), and continues the M_ZERO,
PR_ZERO symmetry.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.12 2009/04/13 21:17:54 miod Exp $	*/
a343 1
	bus_addr_t	ds_vaddr;	/* CPU address */
d345 2
@


1.12
log
@The start of Origin 200 support. Based on some code contributed by pefo@@
some years ago for KL enumeration, building on the existing XBow support
to limit ourselves to a single node for now.

This is a work-in-progress; it currently lacks complete interrupt code,
as well as PCI resource management. And there are likely bugs creeping
inside.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.11 2008/08/25 14:05:51 jsing Exp $	*/
d309 13
a321 12
#define	BUS_DMA_WAITOK		0x00
#define	BUS_DMA_NOWAIT		0x01
#define	BUS_DMA_ALLOCNOW	0x02
#define	BUS_DMAMEM_NOSYNC	0x04
#define	BUS_DMA_COHERENT	0x08
#define	BUS_DMA_BUS1		0x10	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x20
#define	BUS_DMA_BUS3		0x40
#define	BUS_DMA_BUS4		0x80
#define BUS_DMA_READ		0x100   /* mapping is device -> memory only */
#define BUS_DMA_WRITE		0x200   /* mapping is memory -> device only */
#define BUS_DMA_STREAMING	0x400   /* hint: sequential, unidirectional */
@


1.11
log
@Add bus_space_read_raw_region_* and bus_space_write_raw_region_* bus space
accessors to OpenBSD/sgi.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.9 2008/03/30 20:14:38 miod Exp $	*/
d51 1
a51 1
	bus_addr_t	bus_base_dma;
@


1.10
log
@Implement bus_space_{read,write}_raw_mult_[248] correctly, it needs
endianness conversion on pci bridges.
ok deraadt@@ jsing@@
@
text
@d156 19
d206 19
@


1.9
log
@Implement bus_space_*8 and bus_space_vaddr.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.8 2008/02/20 19:13:38 miod Exp $	*/
d69 12
d100 14
a203 28

/*----------------------------------------------------------------------------*/
#define	bus_space_read_raw_multi(n,m,l)					      \
static __inline void							      \
CAT(bus_space_read_raw_multi_,n)(bus_space_tag_t bst, bus_space_handle_t bsh, \
    bus_addr_t ba, u_int8_t *buf, bus_size_t cnt)			      \
{									      \
	CAT(bus_space_read_multi_,n)(bst, bsh, ba, (CAT3(u_int,m,_t) *)buf,   \
	    cnt >> l);							      \
}

bus_space_read_raw_multi(2,16,1)
bus_space_read_raw_multi(4,32,2)
bus_space_read_raw_multi(8,64,3)

/*----------------------------------------------------------------------------*/
#define	bus_space_write_raw_multi(n,m,l)				      \
static __inline void							      \
CAT(bus_space_write_raw_multi_,n)(bus_space_tag_t bst, bus_space_handle_t bsh,\
    bus_addr_t ba, const u_int8_t *buf, bus_size_t cnt)			      \
{									      \
	CAT(bus_space_write_multi_,n)(bst, bsh, ba,			      \
	    (const CAT3(u_int,m,_t) *)buf, cnt >> l);			      \
}

bus_space_write_raw_multi(2,16,1)
bus_space_write_raw_multi(4,32,2)
bus_space_write_raw_multi(8,64,3)
@


1.8
log
@More dead includes and functions noone will mourn.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.7 2007/11/27 14:11:06 jsing Exp $	*/
d75 1
d93 2
d112 1
a112 2

#define	bus_space_read_multi_8	!!! bus_space_read_multi_8 not implemented !!!
d127 1
a127 2

#define	bus_space_read_region_8	!!! bus_space_read_region_8 not implemented !!!
d143 1
a143 2

#define	bus_space_write_multi_8	!!! bus_space_write_multi_8 not implemented !!!
d160 1
a160 3

#define	bus_space_write_region_8					      \
    !!! bus_space_write_region_8 not implemented !!!
d177 1
d191 1
a191 3

#define	bus_space_read_raw_multi_8 \
    !!! bus_space_read_raw_multi_8 not implemented !!!
d205 1
a205 3

#define	bus_space_write_raw_multi_8 \
    !!! bus_space_write_raw_multi_8 not implemented !!!
d242 10
a251 2
#define bus_space_copy_8 \
    !!! bus_space_write_raw_multi_8 not implemented !!!
@


1.7
log
@Add BUS_SPACE_MAP_LINEAR

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.6 2007/06/21 20:17:12 miod Exp $	*/
a28 2

#include <machine/pio.h>
@


1.6
log
@Extent sgi bus_dma to cope with different views of memory: non-contiguous
for the cpu, contiguous from different bases for devices. This allows
memory above 256MB to be used with bus_dma (and we had really been lucky
with the first few large-memory builds).
Information about memory accesses taken from Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.5 2006/05/27 00:29:55 krw Exp $	*/
d265 1
d270 1
@


1.5
log
@Eradicate the type 'bus_dmasync_op_t'. Unused. Sporadically
implemented. Use int.

ok mickey@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.4 2005/01/02 19:33:11 kettenis Exp $	*/
d348 7
a354 1
	paddr_t	dma_offs;
@


1.4
log
@Fix typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.3 2004/08/10 19:16:18 deraadt Exp $	*/
a291 1
typedef int bus_dmasync_op_t;
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.2 2004/08/10 18:52:58 deraadt Exp $	*/
d91 2
a92 1
#define	bus_space_subregion(t, h, o, s, p) (*(t)->_space_map)((t), (h), (o), (s), (p))
@


1.2
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.1 2004/08/06 21:12:18 pefo Exp $	*/
d265 2
a266 2
#define BUS_BARRIER_READ        BUS_SPACE_BARRIER_READ
#define BUS_BARRIER_WRITE       BUS_SPACE_BARRIER_WRITE
d278 3
a280 3
#define BUS_DMA_READ            0x100   /* mapping is device -> memory only */
#define BUS_DMA_WRITE           0x200   /* mapping is memory -> device only */
#define BUS_DMA_STREAMING       0x400   /* hint: sequential, unidirectional */
@


1.1
log
@initial sgi import
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.15 1999/08/11 23:15:21 niklas Exp $	*/
d258 1
a258 1
 * 
d261 2
a262 2
	((void)((void)(t), (void)(h), (void)(o), (void)(l), (void)(f)))  
#define BUS_SPACE_BARRIER_READ  0x01		/* force read barrier */ 
@

