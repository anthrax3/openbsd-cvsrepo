head	1.37;
access;
symbols
	OPENBSD_6_2_BASE:1.37
	OPENBSD_6_1:1.37.0.4
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.36.0.2
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.25.0.4
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.24.0.2
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.10
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.20.0.2
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.37
date	2017.01.22.10.17.37;	author dlg;	state Exp;
branches;
next	1.36;
commitid	VyLWTsbepAOk7VQM;

1.36
date	2016.04.13.11.34.00;	author mpi;	state Exp;
branches;
next	1.35;
commitid	RI1iBTF6Zaycxppg;

1.35
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.34;
commitid	B0kwmVGiD5DVx4kv;

1.34
date	2015.11.24.17.11.38;	author mpi;	state Exp;
branches;
next	1.33;
commitid	5gdEnqVoJuTuwdTu;

1.33
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.32;
commitid	5DvsamK0GblTp8ww;

1.32
date	2015.11.20.03.35.22;	author dlg;	state Exp;
branches;
next	1.31;
commitid	eYnPulzvLjDImPCa;

1.31
date	2015.10.25.13.22.09;	author mpi;	state Exp;
branches;
next	1.30;
commitid	n8mxDftG1cK0Rpp7;

1.30
date	2015.06.24.09.40.53;	author mpi;	state Exp;
branches;
next	1.29;
commitid	MVWrtktB46JRxFWT;

1.29
date	2015.03.11.16.08.54;	author mpi;	state Exp;
branches;
next	1.28;
commitid	bOsxXnTGXxKlmzRd;

1.28
date	2014.12.22.02.26.53;	author tedu;	state Exp;
branches;
next	1.27;
commitid	2Ez9mHW0jDzojG4V;

1.27
date	2014.07.22.10.35.35;	author mpi;	state Exp;
branches;
next	1.26;
commitid	EXpEDqO4x724IPl8;

1.26
date	2013.08.17.15.44.08;	author bluhm;	state Exp;
branches;
next	1.25;

1.25
date	2012.10.03.22.46.09;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2012.05.22.19.24.59;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2010.03.15.18.59.09;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.26.18.00.06;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.10.23.57.40;	author jsing;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.11.14.49.49;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2009.05.18.15.21.31;	author jsing;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2008.10.15.19.12.19;	author blambert;	state Exp;
branches;
next	1.16;

1.16
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2008.02.20.18.46.20;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.21.01.39.25;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.20.16.44.03;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.31.19.10.22;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2007.04.26.17.02.40;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.25.22.41.41;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.09.06.11.42;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.17.19.05.35;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.15.05.24.10;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.29.17.57.35;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.26.13.03.59;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.19.16.17;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.10.13.47.45;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.10.07.30.57;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.37
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_mec.c,v 1.36 2016/04/13 11:34:00 mpi Exp $ */
/*	$NetBSD: if_mec_mace.c,v 1.5 2004/08/01 06:36:36 tsutsui Exp $ */

/*
 * Copyright (c) 2004 Izumi Tsutsui.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 2003 Christopher SEKIYA
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *          This product includes software developed for the
 *          NetBSD Project.  See http://www.NetBSD.org/ for
 *          information about NetBSD.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * MACE MAC-110 Ethernet driver.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>

#include <net/if.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/bus.h>
#include <machine/intr.h>
#include <machine/autoconf.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <mips64/arcbios.h>
#include <sgi/dev/if_mecreg.h>

#include <sgi/localbus/macebusvar.h>

#ifdef MEC_DEBUG
#define MEC_DEBUG_RESET		0x01
#define MEC_DEBUG_START		0x02
#define MEC_DEBUG_STOP		0x04
#define MEC_DEBUG_INTR		0x08
#define MEC_DEBUG_RXINTR	0x10
#define MEC_DEBUG_TXINTR	0x20
uint32_t mec_debug = 0xff;
#define DPRINTF(x, y)	if (mec_debug & (x)) printf y
#else
#define DPRINTF(x, y)	/* nothing */
#endif

/*
 * Transmit descriptor list size.
 */
#define MEC_NTXDESC		64
#define MEC_NTXDESC_MASK	(MEC_NTXDESC - 1)
#define MEC_NEXTTX(x)		(((x) + 1) & MEC_NTXDESC_MASK)

/*
 * Software state for TX.
 */
struct mec_txsoft {
	struct mbuf *txs_mbuf;		/* Head of our mbuf chain. */
	bus_dmamap_t txs_dmamap;	/* Our DMA map. */
	uint32_t txs_flags;
#define MEC_TXS_BUFLEN_MASK	0x0000007f	/* Data len in txd_buf. */
#define MEC_TXS_TXDBUF		0x00000080	/* txd_buf is used. */
#define MEC_TXS_TXDPTR1		0x00000100	/* txd_ptr[0] is used. */
};

/*
 * Transmit buffer descriptor.
 */
#define MEC_TXDESCSIZE		128
#define MEC_NTXPTR		3
#define MEC_TXD_BUFOFFSET	\
	(sizeof(uint64_t) + MEC_NTXPTR * sizeof(uint64_t))
#define MEC_TXD_BUFSIZE		(MEC_TXDESCSIZE - MEC_TXD_BUFOFFSET)
#define MEC_TXD_BUFSTART(len)	(MEC_TXD_BUFSIZE - (len))
#define MEC_TXD_ALIGN		8
#define MEC_TXD_ROUNDUP(addr)	\
	(((addr) + (MEC_TXD_ALIGN - 1)) & ~((uint64_t)MEC_TXD_ALIGN - 1))

struct mec_txdesc {
	volatile uint64_t txd_cmd;
#define MEC_TXCMD_DATALEN	0x000000000000ffff	/* Data length. */
#define MEC_TXCMD_BUFSTART	0x00000000007f0000	/* Start byte offset. */
#define  TXCMD_BUFSTART(x)	((x) << 16)
#define MEC_TXCMD_TERMDMA	0x0000000000800000	/* Stop DMA on abort. */
#define MEC_TXCMD_TXINT		0x0000000001000000	/* INT after TX done. */
#define MEC_TXCMD_PTR1		0x0000000002000000	/* Valid 1st txd_ptr. */
#define MEC_TXCMD_PTR2		0x0000000004000000	/* Valid 2nd txd_ptr. */
#define MEC_TXCMD_PTR3		0x0000000008000000	/* Valid 3rd txd_ptr. */
#define MEC_TXCMD_UNUSED	0xfffffffff0000000ULL	/* Should be zero. */

#define txd_stat	txd_cmd
#define MEC_TXSTAT_LEN		0x000000000000ffff	/* TX length. */
#define MEC_TXSTAT_COLCNT	0x00000000000f0000	/* Collision count. */
#define MEC_TXSTAT_COLCNT_SHIFT	16
#define MEC_TXSTAT_LATE_COL	0x0000000000100000	/* Late collision. */
#define MEC_TXSTAT_CRCERROR	0x0000000000200000	/* */
#define MEC_TXSTAT_DEFERRED	0x0000000000400000	/* */
#define MEC_TXSTAT_SUCCESS	0x0000000000800000	/* TX complete. */
#define MEC_TXSTAT_TOOBIG	0x0000000001000000	/* */
#define MEC_TXSTAT_UNDERRUN	0x0000000002000000	/* */
#define MEC_TXSTAT_COLLISIONS	0x0000000004000000	/* */
#define MEC_TXSTAT_EXDEFERRAL	0x0000000008000000	/* */
#define MEC_TXSTAT_COLLIDED	0x0000000010000000	/* */
#define MEC_TXSTAT_UNUSED	0x7fffffffe0000000ULL	/* Should be zero. */
#define MEC_TXSTAT_SENT		0x8000000000000000ULL	/* Packet sent. */

	uint64_t txd_ptr[MEC_NTXPTR];
#define MEC_TXPTR_UNUSED2	0x0000000000000007	/* Should be zero. */
#define MEC_TXPTR_DMAADDR	0x00000000fffffff8	/* TX DMA address. */
#define MEC_TXPTR_LEN		0x0000ffff00000000ULL	/* Buffer length. */
#define  TXPTR_LEN(x)		((uint64_t)(x) << 32)
#define MEC_TXPTR_UNUSED1	0xffff000000000000ULL	/* Should be zero. */

	uint8_t txd_buf[MEC_TXD_BUFSIZE];
};

/*
 * Receive buffer size.
 */
#define MEC_NRXDESC		16
#define MEC_NRXDESC_MASK	(MEC_NRXDESC - 1)
#define MEC_NEXTRX(x)		(((x) + 1) & MEC_NRXDESC_MASK)

/*
 * Receive buffer description.
 */
#define MEC_RXDESCSIZE		4096	/* Umm, should be 4kbyte aligned. */
#define MEC_RXD_NRXPAD		3
#define MEC_RXD_DMAOFFSET	(1 + MEC_RXD_NRXPAD)
#define MEC_RXD_BUFOFFSET	(MEC_RXD_DMAOFFSET * sizeof(uint64_t))
#define MEC_RXD_BUFSIZE		(MEC_RXDESCSIZE - MEC_RXD_BUFOFFSET)

struct mec_rxdesc {
	volatile uint64_t rxd_stat;
#define MEC_RXSTAT_LEN		0x000000000000ffff	/* Data length. */
#define MEC_RXSTAT_VIOLATION	0x0000000000010000	/* Code violation (?). */
#define MEC_RXSTAT_UNUSED2	0x0000000000020000	/* Unknown (?). */
#define MEC_RXSTAT_CRCERROR	0x0000000000040000	/* CRC error. */
#define MEC_RXSTAT_MULTICAST	0x0000000000080000	/* Multicast packet. */
#define MEC_RXSTAT_BROADCAST	0x0000000000100000	/* Broadcast packet. */
#define MEC_RXSTAT_INVALID	0x0000000000200000	/* Invalid preamble. */
#define MEC_RXSTAT_LONGEVENT	0x0000000000400000	/* Long packet. */
#define MEC_RXSTAT_BADPACKET	0x0000000000800000	/* Bad packet. */
#define MEC_RXSTAT_CAREVENT	0x0000000001000000	/* Carrier event. */
#define MEC_RXSTAT_MATCHMCAST	0x0000000002000000	/* Match multicast. */
#define MEC_RXSTAT_MATCHMAC	0x0000000004000000	/* Match MAC. */
#define MEC_RXSTAT_SEQNUM	0x00000000f8000000	/* Sequence number. */
#define MEC_RXSTAT_CKSUM	0x0000ffff00000000ULL	/* IP checksum. */
#define MEC_RXSTAT_UNUSED1	0x7fff000000000000ULL	/* Should be zero. */
#define MEC_RXSTAT_RECEIVED	0x8000000000000000ULL	/* Set to 1 on RX. */
	uint64_t rxd_pad1[MEC_RXD_NRXPAD];
	uint8_t  rxd_buf[MEC_RXD_BUFSIZE];
};

/*
 * Control structures for DMA ops.
 */
struct mec_control_data {
	/*
	 * TX descriptors and buffers.
	 */
	struct mec_txdesc mcd_txdesc[MEC_NTXDESC];

	/*
	 * RX descriptors and buffers.
	 */
	struct mec_rxdesc mcd_rxdesc[MEC_NRXDESC];
};

/*
 * It _seems_ there are some restrictions on descriptor address:
 *
 * - Base address of txdescs should be 8kbyte aligned
 * - Each txdesc should be 128byte aligned
 * - Each rxdesc should be 4kbyte aligned
 *
 * So we should specify 64k align to allocalte txdescs.
 * In this case, sizeof(struct mec_txdesc) * MEC_NTXDESC is 8192
 * so rxdescs are also allocated at 4kbyte aligned.
 */
#define MEC_CONTROL_DATA_ALIGN	(8 * 1024)

#define MEC_CDOFF(x)	offsetof(struct mec_control_data, x)
#define MEC_CDTXOFF(x)	MEC_CDOFF(mcd_txdesc[(x)])
#define MEC_CDRXOFF(x)	MEC_CDOFF(mcd_rxdesc[(x)])

/*
 * Software state per device.
 */
struct mec_softc {
	struct device sc_dev;		/* Generic device structures. */
	struct arpcom sc_ac;		/* Ethernet common part. */

	bus_space_tag_t sc_st;		/* bus_space tag. */
	bus_space_handle_t sc_sh;	/* bus_space handle. */
	bus_dma_tag_t sc_dmat;		/* bus_dma tag. */

	struct mii_data sc_mii;		/* MII/media information. */
	int sc_phyaddr;			/* MII address. */
	struct timeout sc_tick_ch;	/* Tick timeout. */

	bus_dmamap_t sc_cddmamap;	/* bus_dma map for control data. */
#define sc_cddma	sc_cddmamap->dm_segs[0].ds_addr

	/* Pointer to allocated control data. */
	struct mec_control_data *sc_control_data;
#define sc_txdesc	sc_control_data->mcd_txdesc
#define sc_rxdesc	sc_control_data->mcd_rxdesc

	/* Software state for TX descs. */
	struct mec_txsoft sc_txsoft[MEC_NTXDESC];

	int sc_txpending;		/* Number of TX requests pending. */
	int sc_txdirty;			/* First dirty TX descriptor. */
	int sc_txlast;			/* Last used TX descriptor. */

	int sc_rxptr;			/* Next ready RX buffer. */
};

#define MEC_CDTXADDR(sc, x)	((sc)->sc_cddma + MEC_CDTXOFF(x))
#define MEC_CDRXADDR(sc, x)	((sc)->sc_cddma + MEC_CDRXOFF(x))

#define MEC_TXDESCSYNC(sc, x, ops)					\
	bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_cddmamap,		\
	    MEC_CDTXOFF(x), MEC_TXDESCSIZE, (ops))
#define MEC_TXCMDSYNC(sc, x, ops)					\
	bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_cddmamap,		\
	    MEC_CDTXOFF(x), sizeof(uint64_t), (ops))

#define MEC_RXSTATSYNC(sc, x, ops)					\
	bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_cddmamap,		\
	    MEC_CDRXOFF(x), sizeof(uint64_t), (ops))
#define MEC_RXBUFSYNC(sc, x, len, ops)					\
	bus_dmamap_sync((sc)->sc_dmat, (sc)->sc_cddmamap,		\
	    MEC_CDRXOFF(x) + MEC_RXD_BUFOFFSET,				\
	    ETHER_ALIGN + (len), (ops))

/* XXX these values should be moved to <net/if_ether.h> ? */
#define ETHER_PAD_LEN	(ETHER_MIN_LEN - ETHER_CRC_LEN)

struct cfdriver mec_cd = {
	NULL, "mec", DV_IFNET
};

int	mec_match(struct device *, void *, void *);
void	mec_attach(struct device *, struct device *, void *);

struct cfattach mec_ca = {
	sizeof(struct mec_softc), mec_match, mec_attach
};

int	mec_mii_readreg(struct device *, int, int);
void	mec_mii_writereg(struct device *, int, int, int);
int	mec_mii_wait(struct mec_softc *);
void	mec_statchg(struct device *);
void	mec_mediastatus(struct ifnet *, struct ifmediareq *);
int	mec_mediachange(struct ifnet *);

int	mec_init(struct ifnet * ifp);
void	mec_start(struct ifnet *);
void	mec_watchdog(struct ifnet *);
void	mec_tick(void *);
int	mec_ioctl(struct ifnet *, u_long, caddr_t);
void	mec_reset(struct mec_softc *);
void	mec_iff(struct mec_softc *);
int	mec_intr(void *arg);
void	mec_stop(struct ifnet *);
void	mec_rxintr(struct mec_softc *, uint32_t);
void	mec_txintr(struct mec_softc *, uint32_t);

int
mec_match(struct device *parent, void *match, void *aux)
{
	return (1);
}

void
mec_attach(struct device *parent, struct device *self, void *aux)
{
	struct mec_softc *sc = (void *)self;
	struct macebus_attach_args *maa = aux;
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	uint32_t command;
	struct mii_softc *child;
	bus_dma_segment_t seg;
	int i, err, rseg;

	sc->sc_st = maa->maa_iot;
	if (bus_space_map(sc->sc_st, maa->maa_baseaddr, MEC_NREGS, 0,
	    &sc->sc_sh) != 0) {
		printf(": can't map i/o space\n");
		return;
	}

	/* Set up DMA structures. */
	sc->sc_dmat = maa->maa_dmat;

	/*
	 * Allocate the control data structures, and create and load the
	 * DMA map for it.
	 */
	if ((err = bus_dmamem_alloc(sc->sc_dmat,
	    sizeof(struct mec_control_data), MEC_CONTROL_DATA_ALIGN, 0,
	    &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {
		printf(": unable to allocate control data, error = %d\n", err);
		goto fail_0;
	}

	/*
	 * XXX needs re-think...
	 * control data structures contain whole RX data buffer, so
	 * BUS_DMA_COHERENT (which disables cache) may cause some performance
	 * issue on copying data from the RX buffer to mbuf on normal memory,
	 * though we have to make sure all bus_dmamap_sync(9) ops are called
	 * properly in that case.
	 */
	if ((err = bus_dmamem_map(sc->sc_dmat, &seg, rseg,
	    sizeof(struct mec_control_data),
	    (caddr_t *)&sc->sc_control_data, /*BUS_DMA_COHERENT*/ 0)) != 0) {
		printf(": unable to map control data, error = %d\n", err);
		goto fail_1;
	}
	memset(sc->sc_control_data, 0, sizeof(struct mec_control_data));

	if ((err = bus_dmamap_create(sc->sc_dmat,
	    sizeof(struct mec_control_data), 1,
	    sizeof(struct mec_control_data), 0, 0, &sc->sc_cddmamap)) != 0) {
		printf(": unable to create control data DMA map, error = %d\n",
		    err);
		goto fail_2;
	}
	if ((err = bus_dmamap_load(sc->sc_dmat, sc->sc_cddmamap,
	    sc->sc_control_data, sizeof(struct mec_control_data), NULL,
	    BUS_DMA_NOWAIT)) != 0) {
		printf(": unable to load control data DMA map, error = %d\n",
		    err);
		goto fail_3;
	}

	/* Create TX buffer DMA maps. */
	for (i = 0; i < MEC_NTXDESC; i++) {
		if ((err = bus_dmamap_create(sc->sc_dmat,
		    MCLBYTES, 1, MCLBYTES, 0, 0,
		    &sc->sc_txsoft[i].txs_dmamap)) != 0) {
			printf(": unable to create tx DMA map %d, error = %d\n",
			    i, err);
			goto fail_4;
		}
	}

	timeout_set(&sc->sc_tick_ch, mec_tick, sc);

	/* Use the Ethernet address from the ARCBIOS. */
	enaddr_aton(bios_enaddr, sc->sc_ac.ac_enaddr);

	/* Reset device. */
	mec_reset(sc);

	command = bus_space_read_8(sc->sc_st, sc->sc_sh, MEC_MAC_CONTROL);

	printf(": MAC-110 rev %d, address %s\n",
	    (command & MEC_MAC_REVISION) >> MEC_MAC_REVISION_SHIFT,
	    ether_sprintf(sc->sc_ac.ac_enaddr));

	/* Done, now attach everything. */

	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = mec_mii_readreg;
	sc->sc_mii.mii_writereg = mec_mii_writereg;
	sc->sc_mii.mii_statchg = mec_statchg;

	/* Set up PHY properties. */
	ifmedia_init(&sc->sc_mii.mii_media, 0, mec_mediachange,
	    mec_mediastatus);
	mii_attach(&sc->sc_dev, &sc->sc_mii, 0xffffffff, MII_PHY_ANY,
	    MII_OFFSET_ANY, 0);

	child = LIST_FIRST(&sc->sc_mii.mii_phys);
	if (child == NULL) {
		/* No PHY attached. */
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER | IFM_MANUAL,
		    0, NULL);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER | IFM_MANUAL);
	} else {
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER | IFM_AUTO);
		sc->sc_phyaddr = child->mii_phy;
	}

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = mec_ioctl;
	ifp->if_start = mec_start;
	ifp->if_watchdog = mec_watchdog;

	if_attach(ifp);
	IFQ_SET_MAXLEN(&ifp->if_snd, MEC_NTXDESC - 1);
	ether_ifattach(ifp);

	/* Establish interrupt handler. */
	macebus_intr_establish(maa->maa_intr, maa->maa_mace_intr,
	    IST_EDGE, IPL_NET, mec_intr, sc, sc->sc_dev.dv_xname);

	return;

	/*
	 * Free any resources we've allocated during the failed attach
	 * attempt. Do this in reverse order and fall though.
	 */
 fail_4:
	for (i = 0; i < MEC_NTXDESC; i++) {
		if (sc->sc_txsoft[i].txs_dmamap != NULL)
			bus_dmamap_destroy(sc->sc_dmat,
			    sc->sc_txsoft[i].txs_dmamap);
	}
	bus_dmamap_unload(sc->sc_dmat, sc->sc_cddmamap);
 fail_3:
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_cddmamap);
 fail_2:
	bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_control_data,
	    sizeof(struct mec_control_data));
 fail_1:
	bus_dmamem_free(sc->sc_dmat, &seg, rseg);
 fail_0:
	return;
}

int
mec_mii_readreg(struct device *self, int phy, int reg)
{
	struct mec_softc *sc = (void *)self;
	bus_space_tag_t st = sc->sc_st;
	bus_space_handle_t sh = sc->sc_sh;
	uint32_t val;
	int i;

	if (mec_mii_wait(sc) != 0)
		return 0;

	bus_space_write_4(st, sh, MEC_PHY_ADDRESS,
	    (phy << MEC_PHY_ADDR_DEVSHIFT) | (reg & MEC_PHY_ADDR_REGISTER));
	bus_space_write_8(st, sh, MEC_PHY_READ_INITIATE, 1);
	delay(25);

	for (i = 0; i < 20; i++) {
		delay(30);

		val = bus_space_read_4(st, sh, MEC_PHY_DATA);

		if ((val & MEC_PHY_DATA_BUSY) == 0)
			return val & MEC_PHY_DATA_VALUE;
	}
	return 0;
}

void
mec_mii_writereg(struct device *self, int phy, int reg, int val)
{
	struct mec_softc *sc = (void *)self;
	bus_space_tag_t st = sc->sc_st;
	bus_space_handle_t sh = sc->sc_sh;

	if (mec_mii_wait(sc) != 0) {
		printf("timed out writing %x: %x\n", reg, val);
		return;
	}

	bus_space_write_4(st, sh, MEC_PHY_ADDRESS,
	    (phy << MEC_PHY_ADDR_DEVSHIFT) | (reg & MEC_PHY_ADDR_REGISTER));

	delay(60);

	bus_space_write_4(st, sh, MEC_PHY_DATA, val & MEC_PHY_DATA_VALUE);

	delay(60);

	mec_mii_wait(sc);
}

int
mec_mii_wait(struct mec_softc *sc)
{
	uint32_t busy;
	int i, s;

	for (i = 0; i < 100; i++) {
		delay(30);

		s = splhigh();
		busy = bus_space_read_4(sc->sc_st, sc->sc_sh, MEC_PHY_DATA);
		splx(s);

		if ((busy & MEC_PHY_DATA_BUSY) == 0)
			return 0;
		if (busy == 0xffff) /* XXX ? */
			return 0;
	}

	printf("%s: MII timed out\n", sc->sc_dev.dv_xname);
	return 1;
}

void
mec_statchg(struct device *self)
{
	struct mec_softc *sc = (void *)self;
	bus_space_tag_t st = sc->sc_st;
	bus_space_handle_t sh = sc->sc_sh;
	uint32_t control;

	control = bus_space_read_8(st, sh, MEC_MAC_CONTROL);
	control &= ~(MEC_MAC_IPGT | MEC_MAC_IPGR1 | MEC_MAC_IPGR2 |
	    MEC_MAC_FULL_DUPLEX | MEC_MAC_SPEED_SELECT);

	/* Must also set IPG here for duplex stuff... */
	if ((sc->sc_mii.mii_media_active & IFM_FDX) != 0) {
		control |= MEC_MAC_FULL_DUPLEX;
	} else {
		/* Set IPG. */
		control |= MEC_MAC_IPG_DEFAULT;
	}

	bus_space_write_8(st, sh, MEC_MAC_CONTROL, control);
}

void
mec_mediastatus(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct mec_softc *sc = ifp->if_softc;

	if ((ifp->if_flags & IFF_UP) == 0)
		return;

	mii_pollstat(&sc->sc_mii);
	ifmr->ifm_status = sc->sc_mii.mii_media_status;
	ifmr->ifm_active = sc->sc_mii.mii_media_active;
}

int
mec_mediachange(struct ifnet *ifp)
{
	struct mec_softc *sc = ifp->if_softc;

	if ((ifp->if_flags & IFF_UP) == 0)
		return 0;

	return mii_mediachg(&sc->sc_mii);
}

int
mec_init(struct ifnet *ifp)
{
	struct mec_softc *sc = ifp->if_softc;
	bus_space_tag_t st = sc->sc_st;
	bus_space_handle_t sh = sc->sc_sh;
	struct mec_rxdesc *rxd;
	int i;

	/* Cancel any pending I/O. */
	mec_stop(ifp);

	/* Reset device. */
	mec_reset(sc);

	/* Setup filter for multicast or promisc mode. */
	mec_iff(sc);

	/* Set the TX ring pointer to the base address. */
	bus_space_write_8(st, sh, MEC_TX_RING_BASE, MEC_CDTXADDR(sc, 0));

	sc->sc_txpending = 0;
	sc->sc_txdirty = 0;
	sc->sc_txlast = MEC_NTXDESC - 1;

	/* Put RX buffers into FIFO. */
	for (i = 0; i < MEC_NRXDESC; i++) {
		rxd = &sc->sc_rxdesc[i];
		rxd->rxd_stat = 0;
		MEC_RXSTATSYNC(sc, i, BUS_DMASYNC_PREREAD);
		MEC_RXBUFSYNC(sc, i, ETHER_MAX_LEN, BUS_DMASYNC_PREREAD);
		bus_space_write_8(st, sh, MEC_MCL_RX_FIFO, MEC_CDRXADDR(sc, i));
	}
	sc->sc_rxptr = 0;

#if 0	/* XXX no info */
	bus_space_write_8(st, sh, MEC_TIMER, 0);
#endif

	/*
	 * MEC_DMA_TX_INT_ENABLE will be set later otherwise it causes
	 * spurious interrupts when TX buffers are empty.
	 */
	bus_space_write_8(st, sh, MEC_DMA_CONTROL,
	    (MEC_RXD_DMAOFFSET << MEC_DMA_RX_DMA_OFFSET_SHIFT) |
	    (MEC_NRXDESC << MEC_DMA_RX_INT_THRESH_SHIFT) |
	    MEC_DMA_TX_DMA_ENABLE | /* MEC_DMA_TX_INT_ENABLE | */
	    MEC_DMA_RX_DMA_ENABLE | MEC_DMA_RX_INT_ENABLE);

	timeout_add_sec(&sc->sc_tick_ch, 1);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	mec_start(ifp);

	mii_mediachg(&sc->sc_mii);

	return 0;
}

void
mec_reset(struct mec_softc *sc)
{
	bus_space_tag_t st = sc->sc_st;
	bus_space_handle_t sh = sc->sc_sh;
	uint64_t address;
	int i;

	/* Reset chip. */
	bus_space_write_8(st, sh, MEC_MAC_CONTROL, MEC_MAC_CORE_RESET);
	delay(1000);
	bus_space_write_8(st, sh, MEC_MAC_CONTROL, 0);
	delay(1000);

	/* Set Ethernet address. */
	address = 0;
	for (i = 0; i < ETHER_ADDR_LEN; i++) {
		address = address << 8;
		address += sc->sc_ac.ac_enaddr[i];
	}
	bus_space_write_8(st, sh, MEC_STATION, address);

	/* Default to 100/half and let auto-negotiation work its magic. */
	bus_space_write_8(st, sh, MEC_MAC_CONTROL,
	    MEC_MAC_SPEED_SELECT | MEC_MAC_IPG_DEFAULT);

	bus_space_write_8(st, sh, MEC_DMA_CONTROL, 0);

	DPRINTF(MEC_DEBUG_RESET, ("mec: control now %llx\n",
	    bus_space_read_8(st, sh, MEC_MAC_CONTROL)));
}

void
mec_start(struct ifnet *ifp)
{
	struct mec_softc *sc = ifp->if_softc;
	struct mbuf *m0;
	struct mec_txdesc *txd;
	struct mec_txsoft *txs;
	bus_dmamap_t dmamap;
	bus_space_tag_t st = sc->sc_st;
	bus_space_handle_t sh = sc->sc_sh;
	uint64_t txdaddr;
	int error, firsttx, nexttx, opending;
	int len, bufoff, buflen, unaligned, txdlen;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	/*
	 * Remember the previous txpending and the first transmit descriptor.
	 */
	opending = sc->sc_txpending;
	firsttx = MEC_NEXTTX(sc->sc_txlast);

	DPRINTF(MEC_DEBUG_START,
	    ("mec_start: opending = %d, firsttx = %d\n", opending, firsttx));

	for (;;) {
		/* Grab a packet off the queue. */
		m0 = ifq_deq_begin(&ifp->if_snd);
		if (m0 == NULL)
			break;

		if (sc->sc_txpending == MEC_NTXDESC) {
			ifq_deq_rollback(&ifp->if_snd, m0);
			break;
		}

		/*
		 * Get the next available transmit descriptor.
		 */
		nexttx = MEC_NEXTTX(sc->sc_txlast);
		txd = &sc->sc_txdesc[nexttx];
		txs = &sc->sc_txsoft[nexttx];

		buflen = 0;
		bufoff = 0;
		txdaddr = 0; /* XXX gcc */
		txdlen = 0; /* XXX gcc */

		len = m0->m_pkthdr.len;

		DPRINTF(MEC_DEBUG_START,
		    ("mec_start: len = %d, nexttx = %d\n", len, nexttx));

		ifq_deq_commit(&ifp->if_snd, m0);
		if (len < ETHER_PAD_LEN) {
			/*
			 * I don't know if MEC chip does auto padding,
			 * so if the packet is small enough,
			 * just copy it to the buffer in txdesc.
			 * Maybe this is the simple way.
			 */
			DPRINTF(MEC_DEBUG_START, ("mec_start: short packet\n"));

			bufoff = MEC_TXD_BUFSTART(ETHER_PAD_LEN);
			m_copydata(m0, 0, m0->m_pkthdr.len,
			    txd->txd_buf + bufoff);
			memset(txd->txd_buf + bufoff + len, 0,
			    ETHER_PAD_LEN - len);
			len = buflen = ETHER_PAD_LEN;

			txs->txs_flags = MEC_TXS_TXDBUF | buflen;
		} else {
			/*
			 * If the packet won't fit the buffer in txdesc,
			 * we have to use concatenate pointer to handle it.
			 * While MEC can handle up to three segments to
			 * concatenate, MEC requires that both the second and
			 * third segments have to be 8 byte aligned.
			 * Since it's unlikely for mbuf clusters, we use
			 * only the first concatenate pointer. If the packet
			 * doesn't fit in one DMA segment, allocate new mbuf
			 * and copy the packet to it.
			 *
			 * Besides, if the start address of the first segments
			 * is not 8 byte aligned, such part have to be copied
			 * to the txdesc buffer. (XXX see below comments)
	                 */
			DPRINTF(MEC_DEBUG_START, ("mec_start: long packet\n"));

			dmamap = txs->txs_dmamap;
			if (bus_dmamap_load_mbuf(sc->sc_dmat, dmamap, m0,
			    BUS_DMA_WRITE | BUS_DMA_NOWAIT) != 0) {
				struct mbuf *m;

				DPRINTF(MEC_DEBUG_START,
				    ("mec_start: re-allocating mbuf\n"));
				MGETHDR(m, M_DONTWAIT, MT_DATA);
				if (m == NULL) {
					printf("%s: unable to allocate "
					    "TX mbuf\n", sc->sc_dev.dv_xname);
					break;
				}
				if (len > (MHLEN - ETHER_ALIGN)) {
					MCLGET(m, M_DONTWAIT);
					if ((m->m_flags & M_EXT) == 0) {
						printf("%s: unable to allocate "
						    "TX cluster\n",
						    sc->sc_dev.dv_xname);
						m_freem(m);
						break;
					}
				}
				/*
				 * Each packet has the Ethernet header, so
				 * in many cases the header isn't 4-byte aligned
				 * and data after the header is 4-byte aligned.
				 * Thus adding 2-byte offset before copying to
				 * new mbuf avoids unaligned copy and this may
				 * improve performance.
				 * As noted above, unaligned part has to be
				 * copied to txdesc buffer so this may cause
				 * extra copy ops, but for now MEC always
				 * requires some data in txdesc buffer,
				 * so we always have to copy some data anyway.
				 */
				m->m_data += ETHER_ALIGN;
				m_copydata(m0, 0, len, mtod(m, caddr_t));
				m->m_pkthdr.len = m->m_len = len;
				m_freem(m0);
				m0 = m;
				error = bus_dmamap_load_mbuf(sc->sc_dmat,
				    dmamap, m, BUS_DMA_WRITE | BUS_DMA_NOWAIT);
				if (error) {
					printf("%s: unable to load TX buffer, "
					    "error = %d\n",
					    sc->sc_dev.dv_xname, error);
					m_freem(m);
					break;
				}
			}

			/* Handle unaligned part. */
			txdaddr = MEC_TXD_ROUNDUP(dmamap->dm_segs[0].ds_addr);
			txs->txs_flags = MEC_TXS_TXDPTR1;
			unaligned =
			    dmamap->dm_segs[0].ds_addr & (MEC_TXD_ALIGN - 1);
			DPRINTF(MEC_DEBUG_START,
			    ("mec_start: ds_addr = 0x%x, unaligned = %d\n",
			    (u_int)dmamap->dm_segs[0].ds_addr, unaligned));
			if (unaligned != 0) {
				buflen = MEC_TXD_ALIGN - unaligned;
				bufoff = MEC_TXD_BUFSTART(buflen);
				DPRINTF(MEC_DEBUG_START,
				    ("mec_start: unaligned, "
				    "buflen = %d, bufoff = %d\n",
				    buflen, bufoff));
				memcpy(txd->txd_buf + bufoff,
				    mtod(m0, caddr_t), buflen);
				txs->txs_flags |= MEC_TXS_TXDBUF | buflen;
			}
#if 1
			else {
				/*
				 * XXX needs hardware info XXX
				 * It seems MEC always requires some data
				 * in txd_buf[] even if buffer is
				 * 8-byte aligned otherwise DMA abort error
				 * occurs later...
				 */
				buflen = MEC_TXD_ALIGN;
				bufoff = MEC_TXD_BUFSTART(buflen);
				memcpy(txd->txd_buf + bufoff,
				    mtod(m0, caddr_t), buflen);
				DPRINTF(MEC_DEBUG_START,
				    ("mec_start: aligned, "
				    "buflen = %d, bufoff = %d\n",
				    buflen, bufoff));
				txs->txs_flags |= MEC_TXS_TXDBUF | buflen;
				txdaddr += MEC_TXD_ALIGN;
			}
#endif
			txdlen  = len - buflen;
			DPRINTF(MEC_DEBUG_START,
			    ("mec_start: txdaddr = 0x%llx, txdlen = %d\n",
			    txdaddr, txdlen));

			/*
			 * Sync the DMA map for TX mbuf.
			 *
			 * XXX unaligned part doesn't have to be sync'ed,
			 *     but it's harmless...
			 */
			bus_dmamap_sync(sc->sc_dmat, dmamap, 0,
			    dmamap->dm_mapsize,	BUS_DMASYNC_PREWRITE);
		}

#if NBPFILTER > 0
		/*
		 * Pass packet to bpf if there is a listener.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif

		/*
		 * Setup the transmit descriptor.
		 */

		/* TXINT bit will be set later on the last packet. */
		txd->txd_cmd = (len - 1);
		/* But also set TXINT bit on a half of TXDESC. */
		if (sc->sc_txpending == (MEC_NTXDESC / 2))
			txd->txd_cmd |= MEC_TXCMD_TXINT;

		if (txs->txs_flags & MEC_TXS_TXDBUF)
			txd->txd_cmd |= TXCMD_BUFSTART(MEC_TXDESCSIZE - buflen);
		if (txs->txs_flags & MEC_TXS_TXDPTR1) {
			txd->txd_cmd |= MEC_TXCMD_PTR1;
			txd->txd_ptr[0] = TXPTR_LEN(txdlen - 1) | txdaddr;
			/*
			 * Store a pointer to the packet so we can
			 * free it later.
			 */
			txs->txs_mbuf = m0;
		} else {
			txd->txd_ptr[0] = 0;
			/*
			 * In this case all data are copied to buffer in txdesc,
			 * we can free TX mbuf here.
			 */
			m_freem(m0);
		}

		DPRINTF(MEC_DEBUG_START,
		    ("mec_start: txd_cmd = 0x%llx, txd_ptr = 0x%llx\n",
		    txd->txd_cmd, txd->txd_ptr[0]));
		DPRINTF(MEC_DEBUG_START,
		    ("mec_start: len = %d (0x%04x), buflen = %d (0x%02x)\n",
		    len, len, buflen, buflen));

		/* Sync TX descriptor. */
		MEC_TXDESCSYNC(sc, nexttx,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		/* Advance the TX pointer. */
		sc->sc_txpending++;
		sc->sc_txlast = nexttx;
	}

	if (sc->sc_txpending == MEC_NTXDESC) {
		/* No more slots; notify upper layer. */
		ifq_set_oactive(&ifp->if_snd);
	}

	if (sc->sc_txpending != opending) {
		/*
		 * Cause a TX interrupt to happen on the last packet
		 * we enqueued.
		 */
		sc->sc_txdesc[sc->sc_txlast].txd_cmd |= MEC_TXCMD_TXINT;
		MEC_TXCMDSYNC(sc, sc->sc_txlast,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		/* Start TX. */
		bus_space_write_8(st, sh, MEC_TX_RING_PTR,
		    MEC_NEXTTX(sc->sc_txlast));

		/*
		 * If the transmitter was idle,
		 * reset the txdirty pointer and re-enable TX interrupt.
		 */
		if (opending == 0) {
			sc->sc_txdirty = firsttx;
			bus_space_write_8(st, sh, MEC_TX_ALIAS,
			    MEC_TX_ALIAS_INT_ENABLE);
		}

		/* Set a watchdog timer in case the chip flakes out. */
		ifp->if_timer = 5;
	}
}

void
mec_stop(struct ifnet *ifp)
{
	struct mec_softc *sc = ifp->if_softc;
	struct mec_txsoft *txs;
	int i;

	DPRINTF(MEC_DEBUG_STOP, ("mec_stop\n"));

	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	timeout_del(&sc->sc_tick_ch);
	mii_down(&sc->sc_mii);

	/* Disable DMA. */
	bus_space_write_8(sc->sc_st, sc->sc_sh, MEC_DMA_CONTROL, 0);

	/* Release any TX buffers. */
	for (i = 0; i < MEC_NTXDESC; i++) {
		txs = &sc->sc_txsoft[i];
		if ((txs->txs_flags & MEC_TXS_TXDPTR1) != 0) {
			bus_dmamap_unload(sc->sc_dmat, txs->txs_dmamap);
			m_freem(txs->txs_mbuf);
			txs->txs_mbuf = NULL;
		}
	}
}

int
mec_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct mec_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			mec_init(ifp);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				mec_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				mec_stop(ifp);
		}
		break;

	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_ac, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			mec_iff(sc);
		error = 0;
	}

	splx(s);
	return error;
}

void
mec_watchdog(struct ifnet *ifp)
{
	struct mec_softc *sc = ifp->if_softc;

	printf("%s: device timeout\n", sc->sc_dev.dv_xname);
	ifp->if_oerrors++;

	mec_init(ifp);
}

void
mec_tick(void *arg)
{
	struct mec_softc *sc = arg;
	int s;

	s = splnet();
	mii_tick(&sc->sc_mii);
	splx(s);

	timeout_add_sec(&sc->sc_tick_ch, 1);
}

void
mec_iff(struct mec_softc *sc)
{
	struct arpcom *ac = &sc->sc_ac;
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	struct ether_multi *enm;
	struct ether_multistep step;
	bus_space_tag_t st = sc->sc_st;
	bus_space_handle_t sh = sc->sc_sh;
	uint64_t mchash = 0;
	uint32_t control, hash;

	control = bus_space_read_8(st, sh, MEC_MAC_CONTROL);
	control &= ~MEC_MAC_FILTER_MASK;
	ifp->if_flags &= ~IFF_ALLMULTI;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			control |= MEC_MAC_FILTER_PROMISC;
		else
			control |= MEC_MAC_FILTER_ALLMULTI;
		mchash = 0xffffffffffffffffULL;
	} else {
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			hash = ether_crc32_be(enm->enm_addrlo,
			    ETHER_ADDR_LEN) >> 26;

			mchash |= 1 << hash;

			ETHER_NEXT_MULTI(step, enm);
		}

		if (ac->ac_multicnt > 0)
			control |= MEC_MAC_FILTER_MATCHMULTI;
	}

	bus_space_write_8(st, sh, MEC_MULTICAST, mchash);
	bus_space_write_8(st, sh, MEC_MAC_CONTROL, control);
}

int
mec_intr(void *arg)
{
	struct mec_softc *sc = arg;
	bus_space_tag_t st = sc->sc_st;
	bus_space_handle_t sh = sc->sc_sh;
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	uint32_t statreg, statack, dmac;
	int handled, sent;

	DPRINTF(MEC_DEBUG_INTR, ("mec_intr: called\n"));

	handled = sent = 0;

	for (;;) {
		statreg = bus_space_read_8(st, sh, MEC_INT_STATUS);

		DPRINTF(MEC_DEBUG_INTR,
		    ("mec_intr: INT_STAT = 0x%x\n", statreg));

		statack = statreg & MEC_INT_STATUS_MASK;
		if (statack == 0)
			break;
		bus_space_write_8(st, sh, MEC_INT_STATUS, statack);

		handled = 1;

		if (statack &
		    (MEC_INT_RX_THRESHOLD |
		     MEC_INT_RX_FIFO_UNDERFLOW)) {
			mec_rxintr(sc, statreg);
		}

		dmac = bus_space_read_8(st, sh, MEC_DMA_CONTROL);
		DPRINTF(MEC_DEBUG_INTR,
		    ("mec_intr: DMA_CONT = 0x%x\n", dmac));

		if (statack &
		    (MEC_INT_TX_EMPTY |
		     MEC_INT_TX_PACKET_SENT |
		     MEC_INT_TX_ABORT)) {
			mec_txintr(sc, statreg);
			sent = 1;
		}

		if (statack &
		    (MEC_INT_TX_LINK_FAIL |
		     MEC_INT_TX_MEM_ERROR |
		     MEC_INT_TX_ABORT |
		     MEC_INT_RX_DMA_UNDERFLOW)) {
			printf("%s: mec_intr: interrupt status = 0x%x\n",
			    sc->sc_dev.dv_xname, statreg);
		}
	}

	if (sent) {
		/* Try to get more packets going. */
		mec_start(ifp);
	}

	return handled;
}

void
mec_rxintr(struct mec_softc *sc, uint32_t stat)
{
	bus_space_tag_t st = sc->sc_st;
	bus_space_handle_t sh = sc->sc_sh;
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	struct mec_rxdesc *rxd;
	uint64_t rxstat;
	u_int len;
	int i, last;

	DPRINTF(MEC_DEBUG_RXINTR, ("mec_rxintr: called\n"));

	bus_space_write_8(st, sh, MEC_RX_ALIAS, 0);

	last = (stat & MEC_INT_RX_MCL_FIFO_ALIAS) >> 8;
	/* XXX does alias count mod 32 even if 16 descs are set up? */
	last &= MEC_NRXDESC_MASK;

	if (stat & MEC_INT_RX_FIFO_UNDERFLOW)
		last = (last - 1) & MEC_NRXDESC_MASK;

	DPRINTF(MEC_DEBUG_RXINTR, ("mec_rxintr: rxptr %d last %d\n",
	    sc->sc_rxptr, last));
	for (i = sc->sc_rxptr; i != last; i = MEC_NEXTRX(i)) {

		MEC_RXSTATSYNC(sc, i, BUS_DMASYNC_POSTREAD);
		rxd = &sc->sc_rxdesc[i];
		rxstat = rxd->rxd_stat;

		DPRINTF(MEC_DEBUG_RXINTR,
		    ("mec_rxintr: rxstat = 0x%llx, rxptr = %d\n",
		    rxstat, i));
		DPRINTF(MEC_DEBUG_RXINTR, ("mec_rxintr: rxfifo = 0x%x\n",
		    (u_int)bus_space_read_8(st, sh, MEC_RX_FIFO)));

		if ((rxstat & MEC_RXSTAT_RECEIVED) == 0) {
			/* Status not received but FIFO counted? Drop it! */
			goto dropit;
		}

		len = rxstat & MEC_RXSTAT_LEN;

		if (len < ETHER_MIN_LEN ||
		    len > ETHER_MAX_LEN) {
			/* Invalid length packet; drop it. */
			DPRINTF(MEC_DEBUG_RXINTR,
			    ("mec_rxintr: wrong packet\n"));
 dropit:
			ifp->if_ierrors++;
			rxd->rxd_stat = 0;
			MEC_RXSTATSYNC(sc, i, BUS_DMASYNC_PREREAD);
			bus_space_write_8(st, sh, MEC_MCL_RX_FIFO,
			    MEC_CDRXADDR(sc, i));
			continue;
		}

		if (rxstat &
		    (MEC_RXSTAT_BADPACKET |
		     MEC_RXSTAT_LONGEVENT |
		     MEC_RXSTAT_INVALID   |
		     MEC_RXSTAT_CRCERROR  |
		     MEC_RXSTAT_VIOLATION)) {
			printf("%s: mec_rxintr: status = 0x%llx\n",
			    sc->sc_dev.dv_xname, rxstat);
			goto dropit;
		}

		/*
		 * Now allocate an mbuf (and possibly a cluster) to hold
		 * the received packet.
		 */
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL) {
			printf("%s: unable to allocate RX mbuf\n",
			    sc->sc_dev.dv_xname);
			goto dropit;
		}
		if (len > (MHLEN - ETHER_ALIGN)) {
			MCLGET(m, M_DONTWAIT);
			if ((m->m_flags & M_EXT) == 0) {
				printf("%s: unable to allocate RX cluster\n",
				    sc->sc_dev.dv_xname);
				m_freem(m);
				m = NULL;
				goto dropit;
			}
		}

		/*
		 * Note MEC chip seems to insert 2 byte padding at the start of
		 * RX buffer, but we copy whole buffer to avoid unaligned copy.
		 */
		MEC_RXBUFSYNC(sc, i, len + ETHER_ALIGN, BUS_DMASYNC_POSTREAD);
		memcpy(mtod(m, caddr_t), rxd->rxd_buf,
		    ETHER_ALIGN + len - ETHER_CRC_LEN);
		MEC_RXBUFSYNC(sc, i, ETHER_MAX_LEN, BUS_DMASYNC_PREREAD);
		m->m_data += ETHER_ALIGN;

		/* Put RX buffer into FIFO again. */
		rxd->rxd_stat = 0;
		MEC_RXSTATSYNC(sc, i, BUS_DMASYNC_PREREAD);
		bus_space_write_8(st, sh, MEC_MCL_RX_FIFO, MEC_CDRXADDR(sc, i));

		m->m_pkthdr.len = m->m_len = len - ETHER_CRC_LEN;

		ml_enqueue(&ml, m);
	}

	/* Update RX pointer. */
	sc->sc_rxptr = i;

	bus_space_write_8(st, sh, MEC_RX_ALIAS,
	    (MEC_NRXDESC << MEC_DMA_RX_INT_THRESH_SHIFT) |
	    MEC_DMA_RX_INT_ENABLE);

	if_input(ifp, &ml);
}

void
mec_txintr(struct mec_softc *sc, uint32_t stat)
{
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	struct mec_txdesc *txd;
	struct mec_txsoft *txs;
	bus_dmamap_t dmamap;
	uint64_t txstat;
	int i, last;
	u_int col;

	ifq_clr_oactive(&ifp->if_snd);

	DPRINTF(MEC_DEBUG_TXINTR, ("mec_txintr: called\n"));

	bus_space_write_8(sc->sc_st, sc->sc_sh, MEC_TX_ALIAS, 0);
	last = (stat & MEC_INT_TX_RING_BUFFER_ALIAS) >> 16;

	DPRINTF(MEC_DEBUG_TXINTR, ("mec_txintr: dirty %d last %d\n",
	    sc->sc_txdirty, last));
	for (i = sc->sc_txdirty; i != last && sc->sc_txpending != 0;
	    i = MEC_NEXTTX(i), sc->sc_txpending--) {
		txd = &sc->sc_txdesc[i];

		MEC_TXDESCSYNC(sc, i,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);

		txstat = txd->txd_stat;
		DPRINTF(MEC_DEBUG_TXINTR,
		    ("mec_txintr: dirty = %d, txstat = 0x%llx\n",
		    i, txstat));
		if ((txstat & MEC_TXSTAT_SENT) == 0) {
			MEC_TXCMDSYNC(sc, i, BUS_DMASYNC_PREREAD);
			break;
		}

		txs = &sc->sc_txsoft[i];
		if ((txs->txs_flags & MEC_TXS_TXDPTR1) != 0) {
			dmamap = txs->txs_dmamap;
			bus_dmamap_sync(sc->sc_dmat, dmamap, 0,
			    dmamap->dm_mapsize, BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, dmamap);
			m_freem(txs->txs_mbuf);
			txs->txs_mbuf = NULL;
		}

		if ((txstat & MEC_TXSTAT_SUCCESS) == 0) {
			printf("%s: TX error: txstat = 0x%llx\n",
			    sc->sc_dev.dv_xname, txstat);
			ifp->if_oerrors++;
		} else {
			col = (txstat & MEC_TXSTAT_COLCNT) >>
			    MEC_TXSTAT_COLCNT_SHIFT;
			ifp->if_collisions += col;
		}
	}

	/* Update the dirty TX buffer pointer. */
	sc->sc_txdirty = i;
	DPRINTF(MEC_DEBUG_INTR,
	    ("mec_txintr: sc_txdirty = %2d, sc_txpending = %2d\n",
	    sc->sc_txdirty, sc->sc_txpending));

	/* Cancel the watchdog timer if there are no pending TX packets. */
	if (sc->sc_txpending == 0)
		ifp->if_timer = 0;
	else if (!(stat & MEC_INT_TX_EMPTY))
		bus_space_write_8(sc->sc_st, sc->sc_sh, MEC_TX_ALIAS,
		    MEC_TX_ALIAS_INT_ENABLE);
}
@


1.36
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.35 2015/11/25 03:09:58 dlg Exp $ */
a1373 1
			ifp->if_opackets++;
@


1.35
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.34 2015/11/24 17:11:38 mpi Exp $ */
a462 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.34
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.33 2015/11/24 13:33:18 mpi Exp $ */
d671 1
a671 1
	ifp->if_flags &= ~IFF_OACTIVE;
d725 1
a725 1
	if ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)
d963 1
a963 1
		ifp->if_flags |= IFF_OACTIVE;
d1004 2
a1005 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d1332 1
a1332 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.33
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.32 2015/11/20 03:35:22 dlg Exp $ */
a80 1
#include <net/if_dl.h>
@


1.32
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.31 2015/10/25 13:22:09 mpi Exp $ */
a82 1
#include <net/if_types.h>
@


1.31
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.30 2015/06/24 09:40:53 mpi Exp $ */
d741 1
a741 1
		IFQ_POLL(&ifp->if_snd, m0);
d746 1
d767 1
a767 1
		IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.30
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.29 2015/03/11 16:08:54 mpi Exp $ */
a1028 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a1037 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_ac, ifa);
@


1.29
log
@Convert to if_input(), tested by jasper@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.28 2014/12/22 02:26:53 tedu Exp $ */
a1309 2

		ifp->if_ipackets++;
@


1.28
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.27 2014/07/22 10:35:35 mpi Exp $ */
d1209 1
a1308 1
		m->m_pkthdr.rcvif = ifp;
d1313 1
a1313 11
#if NBPFILTER > 0
		/*
		 * Pass this up to any BPF listeners, but only
		 * pass it up the stack if it is for us.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

		/* Pass it on. */
		ether_input_mbuf(ifp, m);
d1322 2
@


1.27
log
@<netinet/in_systm.h> is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.26 2013/08/17 15:44:08 bluhm Exp $ */
a1038 1
#ifdef INET
a1040 1
#endif
@


1.26
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Remove these include lines from sgi drivers.
test jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.25 2012/10/03 22:46:09 miod Exp $ */
a84 6
#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#endif

d89 1
@


1.25
log
@Don't include <mips64/archtype.h> unless you really need it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.24 2012/05/22 19:24:59 miod Exp $ */
a87 1
#include <netinet/in_var.h>
@


1.24
log
@When setting up the multicast filter, use the ac_multicnt field of the arpcom
struct to know if there are multicast entries, instead of counting the
number of entries in the list. No functional change. From brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.23 2010/03/15 18:59:09 miod Exp $ */
a104 1
#include <mips64/archtype.h>
@


1.23
log
@Do not leak mbuf in the TX path when a TX error occurs; found the hard way
by syuu@@; ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.22 2009/10/26 18:00:06 miod Exp $ */
a1117 1
	int mcnt = 0;
d1135 1
d1137 1
a1137 1
			mcnt++;
d1141 1
a1141 1
		if (mcnt > 0)
@


1.22
log
@Better crime/mace interrupt handling; interrupt information is no longer
specified in the kernel configuration file, but is provided by macebus(4)
as part of the  child device attachment args, and provide both crime and
mace interrupt bitmasks; this allows us to only really enable interrupt
sources we care about, and to avoid invoking interrupt handler we don't need
to for the few mace interrupts multiplexed at the crime level.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.21 2009/08/10 23:57:40 jsing Exp $ */
a1378 7
		if ((txstat & MEC_TXSTAT_SUCCESS) == 0) {
			printf("%s: TX error: txstat = 0x%llx\n",
			    sc->sc_dev.dv_xname, txstat);
			ifp->if_oerrors++;
			continue;
		}

d1389 10
a1398 3
		col = (txstat & MEC_TXSTAT_COLCNT) >> MEC_TXSTAT_COLCNT_SHIFT;
		ifp->if_collisions += col;
		ifp->if_opackets++;
@


1.21
log
@The shutdown hook is no longer required now that we shutdown all interfaces
when rebooting.

ok deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.19 2009/05/18 15:21:31 jsing Exp $ */
d109 1
a109 1
#include <sgi/localbus/macebus.h>
d358 1
a358 1
	struct confargs *ca = aux;
d365 2
a366 2
	sc->sc_st = ca->ca_iot;
	if (bus_space_map(sc->sc_st, ca->ca_baseaddr, MEC_NREGS, 0,
d373 1
a373 1
	sc->sc_dmat = ca->ca_dmat;
d479 2
a480 2
	macebus_intr_establish(NULL, ca->ca_intr, IST_EDGE, IPL_NET,
	    mec_intr, sc, sc->sc_dev.dv_xname);
@


1.20
log
@The MAC multicast filter is set in mec_iff() hence there is need to do this
when resetting the chip.

From Brad.
@
text
@a273 1
	void *sc_sdhook;		/* Shutdown hook. */
a346 1
void	mec_shutdown(void *);
a481 3
	/* Set hook to stop interface on shutdown. */
	sc->sc_sdhook = shutdownhook_establish(mec_shutdown, sc);

a1412 8
}

void
mec_shutdown(void *arg)
{
	struct mec_softc *sc = arg;

	mec_stop(&sc->sc_ac.ac_if);
@


1.19
log
@Cleanup the ioctl and receive filter code for mec(4). This also
significantly reduces the number of times the chip gets wacked at boot.

From brad, tested by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.17 2008/10/15 19:12:19 blambert Exp $ */
d698 1
a698 1
	uint64_t address, control;
d716 2
a717 2
	control = MEC_MAC_SPEED_SELECT | MEC_MAC_FILTER_MATCHMULTI |
	    MEC_MAC_IPG_DEFAULT;
a718 1
	bus_space_write_8(st, sh, MEC_MAC_CONTROL, control);
@


1.18
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d343 1
a343 1
void	mec_setfilter(struct mec_softc *);
d649 1
a649 1
	mec_setfilter(sc);
d1050 2
a1051 2

		switch (ifa->ifa_addr->sa_family) {
d1053 1
a1053 2
		case AF_INET:
			mec_init(ifp);
a1054 1
			break;
a1055 4
		default:
			mec_init(ifp);
			break;
		}
d1059 9
a1067 10
		/*
		 * If interface is marked up and not running, then start it.
		 * If it is marked down and running, stop it.
		 * XXX If it's up then re-initialize it. This is so flags
		 * such as IFF_PROMISC are handled.
		 */
		if (ifp->if_flags & IFF_UP)
			mec_init(ifp);
		else if (ifp->if_flags & IFF_RUNNING)
			mec_stop(ifp);
d1081 1
a1081 1
			mec_init(ifp);
d1114 1
a1114 1
mec_setfilter(struct mec_softc *sc)
d1116 1
a1116 1
	struct arpcom *ec = &sc->sc_ac;
d1122 1
a1122 1
	uint64_t mchash;
d1124 1
a1124 1
	int mcnt;
d1128 1
d1130 5
a1134 13
	if (ifp->if_flags & IFF_PROMISC) {
		control |= MEC_MAC_FILTER_PROMISC;
		bus_space_write_8(st, sh, MEC_MULTICAST, 0xffffffffffffffffULL);
		bus_space_write_8(st, sh, MEC_MAC_CONTROL, control);
		return;
	}

	mcnt = 0;
	mchash = 0;
	ETHER_FIRST_MULTI(step, ec, enm);
	while (enm != NULL) {
		if (memcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			/* Set allmulti for a range of multicast addresses. */
d1136 9
a1144 4
			bus_space_write_8(st, sh, MEC_MULTICAST,
			    0xffffffffffffffffULL);
			bus_space_write_8(st, sh, MEC_MAC_CONTROL, control);
			return;
d1147 2
a1148 6
#define mec_calchash(addr)	(ether_crc32_be((addr), ETHER_ADDR_LEN) >> 26)

		hash = mec_calchash(enm->enm_addrlo);
		mchash |= 1 << hash;
		mcnt++;
		ETHER_NEXT_MULTI(step, enm);
a1149 5

	ifp->if_flags &= ~IFF_ALLMULTI;

	if (mcnt > 0)
		control |= MEC_MAC_FILTER_MATCHMULTI;
@


1.17
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.16 2008/10/02 20:21:13 brad Exp $ */
a1062 6
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN)
			error = EINVAL;
		else if (ifp->if_mtu != ifr->ifr_mtu)
			ifp->if_mtu = ifr->ifr_mtu;
		break;
a1076 17
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_ac) :
		    ether_delmulti(ifr, &sc->sc_ac);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				mec_init(ifp);
			error = 0;
		}
		break;

d1084 6
@


1.16
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.15 2008/02/20 18:46:20 miod Exp $ */
d682 1
a682 1
	timeout_add(&sc->sc_tick_ch, hz);
d1134 1
a1134 1
	timeout_add(&sc->sc_tick_ch, hz);
@


1.15
log
@Completely overhault attachment rules on sgi. No more indirect configuration
inherited from OpenBSD/arc machines with ISA bus; mainbus children match on
device name and other hierarchies match on simplified locators.
As a bonus, attachment lines in dmesg will now print their locators.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.14 2008/01/21 01:39:25 jsing Exp $ */
d1043 1
a1043 1
	int s, error;
a1046 5
	if ((error = ether_ioctl(ifp, &sc->sc_ac, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

d1106 1
a1106 2
		error = ENXIO;
		break;
@


1.14
log
@Fix boot time interrupt storm on mec(4) by disabling DMA when stopping the
interface. Without this we are potentially freeing TX buffers that are in
use, plus we leave DMA enabled when rebooting. This leads to an interrupt
storm at boot time if we were receiving/transmitting network traffic whilst
shutting down.

ok miod@@. Tested by jasper@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.13 2008/01/20 16:44:03 jsing Exp $ */
d109 2
a352 5
	struct confargs *ca = aux;

	if (ca->ca_sys != SGI_O2 || strcmp(ca->ca_name, mec_cd.cd_name))
		return (0);

d481 1
a481 1
	BUS_INTR_ESTABLISH(ca, NULL, ca->ca_intr, IST_EDGE, IPL_NET,
@


1.13
log
@Clean up comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.12 2007/07/31 19:10:22 deraadt Exp $ */
d343 1
a343 1
void	mec_stop(struct ifnet *, int);
d646 1
a646 1
	mec_stop(ifp, 0);
d1012 1
a1012 1
mec_stop(struct ifnet *ifp, int disable)
d1026 3
d1088 1
a1088 1
			mec_stop(ifp, 1);
d1470 1
a1470 1
	mec_stop(&sc->sc_ac.ac_if, 1);
@


1.12
log
@typo fixes from joel@@ionix.com.au
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.11 2007/04/26 17:02:40 miod Exp $ */
d64 1
a64 1
 * MACE MAC-110 Ethernet driver
d123 1
a123 1
 * Transmit descriptor list size
d130 1
a130 1
 * software state for TX
d133 2
a134 2
	struct mbuf *txs_mbuf;		/* head of our mbuf chain */
	bus_dmamap_t txs_dmamap;	/* our DMA map */
d136 3
a138 3
#define MEC_TXS_BUFLEN_MASK	0x0000007f	/* data len in txd_buf */
#define MEC_TXS_TXDBUF		0x00000080	/* txd_buf is used */
#define MEC_TXS_TXDPTR1		0x00000100	/* txd_ptr[0] is used */
d142 1
a142 1
 * Transmit buffer descriptor
d156 2
a157 2
#define MEC_TXCMD_DATALEN	0x000000000000ffff	/* data length */
#define MEC_TXCMD_BUFSTART	0x00000000007f0000	/* start byte offset */
d159 6
a164 6
#define MEC_TXCMD_TERMDMA	0x0000000000800000	/* stop DMA on abort */
#define MEC_TXCMD_TXINT		0x0000000001000000	/* INT after TX done */
#define MEC_TXCMD_PTR1		0x0000000002000000	/* valid 1st txd_ptr */
#define MEC_TXCMD_PTR2		0x0000000004000000	/* valid 2nd txd_ptr */
#define MEC_TXCMD_PTR3		0x0000000008000000	/* valid 3rd txd_ptr */
#define MEC_TXCMD_UNUSED	0xfffffffff0000000ULL	/* should be zero */
d167 2
a168 2
#define MEC_TXSTAT_LEN		0x000000000000ffff	/* TX length */
#define MEC_TXSTAT_COLCNT	0x00000000000f0000	/* collision count */
d170 1
a170 1
#define MEC_TXSTAT_LATE_COL	0x0000000000100000	/* late collision */
d173 1
a173 1
#define MEC_TXSTAT_SUCCESS	0x0000000000800000	/* TX complete */
d179 2
a180 2
#define MEC_TXSTAT_UNUSED	0x7fffffffe0000000ULL	/* should be zero */
#define MEC_TXSTAT_SENT		0x8000000000000000ULL	/* packet sent */
d183 3
a185 3
#define MEC_TXPTR_UNUSED2	0x0000000000000007	/* should be zero */
#define MEC_TXPTR_DMAADDR	0x00000000fffffff8	/* TX DMA address */
#define MEC_TXPTR_LEN		0x0000ffff00000000ULL	/* buffer length */
d187 1
a187 1
#define MEC_TXPTR_UNUSED1	0xffff000000000000ULL	/* should be zero */
d193 1
a193 1
 * Receive buffer size
d200 1
a200 1
 * Receive buffer description
d202 1
a202 1
#define MEC_RXDESCSIZE		4096	/* umm, should be 4kbyte aligned */
d210 16
a225 16
#define MEC_RXSTAT_LEN		0x000000000000ffff	/* data length */
#define MEC_RXSTAT_VIOLATION	0x0000000000010000	/* code violation (?) */
#define MEC_RXSTAT_UNUSED2	0x0000000000020000	/* unknown (?) */
#define MEC_RXSTAT_CRCERROR	0x0000000000040000	/* CRC error */
#define MEC_RXSTAT_MULTICAST	0x0000000000080000	/* multicast packet */
#define MEC_RXSTAT_BROADCAST	0x0000000000100000	/* broadcast packet */
#define MEC_RXSTAT_INVALID	0x0000000000200000	/* invalid preamble */
#define MEC_RXSTAT_LONGEVENT	0x0000000000400000	/* long packet */
#define MEC_RXSTAT_BADPACKET	0x0000000000800000	/* bad packet */
#define MEC_RXSTAT_CAREVENT	0x0000000001000000	/* carrier event */
#define MEC_RXSTAT_MATCHMCAST	0x0000000002000000	/* match multicast */
#define MEC_RXSTAT_MATCHMAC	0x0000000004000000	/* match MAC */
#define MEC_RXSTAT_SEQNUM	0x00000000f8000000	/* sequence number */
#define MEC_RXSTAT_CKSUM	0x0000ffff00000000ULL	/* IP checksum */
#define MEC_RXSTAT_UNUSED1	0x7fff000000000000ULL	/* should be zero */
#define MEC_RXSTAT_RECEIVED	0x8000000000000000ULL	/* set to 1 on RX */
d231 1
a231 1
 * control structures for DMA ops
d235 1
a235 1
	 * TX descriptors and buffers
d240 1
a240 1
	 * RX descriptors and buffers
d263 1
a263 1
 * software state per device
d266 2
a267 2
	struct device sc_dev;		/* generic device structures */
	struct arpcom sc_ac;		/* Ethernet common part */
d269 8
a276 8
	bus_space_tag_t sc_st;		/* bus_space tag */
	bus_space_handle_t sc_sh;	/* bus_space handle */
	bus_dma_tag_t sc_dmat;		/* bus_dma tag */
	void *sc_sdhook;		/* shutdown hook */

	struct mii_data sc_mii;		/* MII/media information */
	int sc_phyaddr;			/* MII address */
	struct timeout sc_tick_ch;	/* tick timeout */
d278 1
a278 1
	bus_dmamap_t sc_cddmamap;	/* bus_dma map for control data */
d281 1
a281 1
	/* pointer to allocated control data */
d286 1
a286 1
	/* software state for TX descs */
d289 3
a291 3
	int sc_txpending;		/* number of TX requests pending */
	int sc_txdirty;			/* first dirty TX descriptor */
	int sc_txlast;			/* last used TX descriptor */
d293 1
a293 1
	int sc_rxptr;			/* next ready RX buffer */
d377 1
a377 1
	/* set up DMA structures */
d422 1
a422 1
	/* create TX buffer DMA maps */
d435 1
a435 1
	/* use Ethernet address from ARCBIOS */
d438 1
a438 1
	/* reset device */
d447 1
a447 1
	/* Done, now attach everything */
d454 1
a454 1
	/* Set up PHY properties */
d462 1
a462 1
		/* No PHY attached */
d483 1
a483 1
	/* establish interrupt */
d487 1
a487 1
	/* set shutdown hook to reset interface on powerdown */
d494 1
a494 1
	 * attempt.  Do this in reverse order and fall though.
d601 1
a601 1
	/* must also set IPG here for duplex stuff ... */
d605 1
a605 1
		/* set IPG */
d645 1
a645 1
	/* cancel any pending I/O */
d648 1
a648 1
	/* reset device */
d651 1
a651 1
	/* setup filter for multicast or promisc mode */
d654 1
a654 1
	/* set the TX ring pointer to the base address */
d661 1
a661 1
	/* put RX buffers into FIFO */
d677 1
a677 1
	 * spurious interrupts when TX buffers are empty
d704 1
a704 1
	/* reset chip */
d710 1
a710 1
	/* set Ethernet address */
d718 1
a718 1
	/* Default to 100/half and let auto-negotiation work its magic */
d843 1
a843 1
				 * in many case the header isn't 4-byte aligned
d847 1
a847 1
				 * improve some performance.
d870 1
a870 1
			/* handle unaligned part */
d916 1
a916 1
			 * sync the DMA map for TX mbuf
d937 1
a937 1
		/* TXINT bit will be set later on the last packet */
d939 1
a939 1
		/* but also set TXINT bit on a half of TXDESC */
d969 1
a969 1
		/* sync TX descriptor */
d973 1
a973 1
		/* advance the TX pointer. */
d992 1
a992 1
		/* start TX */
d1026 1
a1026 1
	/* release any TX buffers */
d1171 1
a1171 1
			/* set allmulti for a range of multicast addresses */
d1252 1
a1252 1
		/* try to get more packets going */
d1297 1
a1297 1
			/* Status not received but fifo counted? Drop it! */
d1305 1
a1305 1
			/* invalid length packet; drop it. */
d1359 1
a1359 1
		/* put RX buffer into FIFO again */
d1372 1
a1372 1
		 * pass it up the stack it is for us.
d1382 1
a1382 1
	/* update RX pointer */
d1448 1
a1448 1
	/* update the dirty TX buffer pointer */
d1454 1
a1454 1
	/* cancel the watchdog timer if there are no pending TX packets */
@


1.11
log
@Do not invoke arcbios routines from the moment our page tables are set up,
to the moment we reboot, for we do not know what it can do behind our back;
this means the built-in ethernet address has to be read from the arcbios
environment earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.10 2006/03/25 22:41:41 djm Exp $ */
d64 1
a64 1
 * MACE MAC-110 ethernet driver
d272 1
a272 1
	void *sc_sdhook;		/* shoutdown hook */
d281 1
a281 1
	/* pointer to allocalted control data */
d397 1
a397 1
	 * proprely in that case.
d435 1
a435 1
	/* use ethernet address from ARCBIOS */
d710 1
a710 1
	/* set ethernet address */
d718 1
a718 1
	/* Default to 100/half and let autonegotiation work its magic */
d803 1
a803 1
			 * we have to use concatinate pointer to handle it.
d805 1
a805 1
			 * concatinate, MEC requires that both the second and
d808 1
a808 1
			 * only the first concatinate pointer. If the packet
d934 1
a934 1
		 * setup the transmit descriptor.
d998 1
a998 1
		 * reset the txdirty pointer and reenable TX interrupt.
d1329 1
a1329 1
		 * now allocate an mbuf (and possibly a cluster) to hold
d1350 1
a1350 1
		 * Note MEC chip seems to insert 2 byte paddingat the start of
d1372 1
a1372 1
		 * pass it up the stack it its for us.
@


1.10
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.9 2005/11/09 06:11:42 brad Exp $ */
a365 1
	char *macaddr;
d435 2
a436 6
	/* get ethernet address from ARCBIOS */
	if ((macaddr = Bios_GetEnvironmentVariable("eaddr")) == NULL) {
		printf(": unable to get MAC address!\n");
		goto fail_4;
	}
	enaddr_aton(macaddr, sc->sc_ac.ac_enaddr);
@


1.9
log
@splimp -> splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.8 2005/02/17 19:05:35 miod Exp $ */
d935 1
a935 1
			bpf_mtap(ifp->if_bpf, m0);
d1380 1
a1380 1
			bpf_mtap(ifp->if_bpf, m);
@


1.8
log
@ehternet -> ethernet
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.7 2005/01/15 05:24:10 brad Exp $ */
d1050 1
a1050 1
	s = splimp();
@


1.7
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.6 2004/09/29 17:57:35 pefo Exp $ */
d436 1
a436 1
	/* get ehternet address from ARCBIOS */
@


1.6
log
@give reset a chance to be active for a short time!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.5 2004/09/23 17:45:16 brad Exp $ */
d1098 1
d1104 2
a1105 1
			mec_init(ifp);
@


1.5
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.4 2004/08/26 13:03:59 pefo Exp $ */
d711 1
@


1.4
log
@Fix a problem where the driver could get stuck in the rx int loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.3 2004/08/10 19:16:17 deraadt Exp $ */
a481 1
	ifp->if_mtu = ETHERMTU;
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mec.c,v 1.2 2004/08/10 13:47:45 pefo Exp $ */
d1279 3
d1300 2
a1301 2
			MEC_RXSTATSYNC(sc, i, BUS_DMASYNC_PREREAD);
			break;
@


1.2
log
@Add O2 built in ethernet.
@
text
@d1 2
a2 2
/* $OpenBSD: if_mec.c,v 1.1 2004/08/10 07:30:57 mickey Exp $ */
/* $NetBSD: if_mec_mace.c,v 1.5 2004/08/01 06:36:36 tsutsui Exp $ */
d947 1
a947 1
			
d996 1
a996 1
		
@


1.1
log
@mac-110 on mace from netbsd
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a108 2
#define MEC_DEBUG

a334 2
static void	enaddr_aton(const char *, uint8_t *);

a639 33
}

/*
 * XXX
 * maybe this function should be moved to common part
 * (sgimips/machdep.c or elsewhere) for all on-board network devices.
 */
static void
enaddr_aton(const char *str, uint8_t *eaddr)
{
	int i;
	char c;

	for (i = 0; i < ETHER_ADDR_LEN; i++) {
		if (*str == ':')
			str++;

		c = *str++;
		if ('0' <= c && c <= '9')
			eaddr[i] = (c - '0');
		else if ('A' <= c && c <= 'F')
			eaddr[i] = c + 10 - 'A';
		else if ('a' <= c && c <= 'f')
			eaddr[i] = c + 10 - 'a';

		c = *str++;
		if ('0' <= c && c <= '9')
			eaddr[i] = (eaddr[i] << 4) | (c - '0');
		else if ('A' <= c && c <= 'F')
			eaddr[i] = (eaddr[i] << 4) | (c + 10 - 'A');
		else if ('a' <= c && c <= 'f')
			eaddr[i] = (eaddr[i] << 4) | (c + 10 - 'a');
	}
@

