head	1.11;
access;
symbols
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.12
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.8
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.6
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.8
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.11
date	2015.02.11.07.05.39;	author dlg;	state Exp;
branches;
next	1.10;
commitid	JTpbkhDknrIuy9pn;

1.10
date	2013.12.29.18.31.50;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2013.12.25.21.01.01;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2012.08.10.17.49.31;	author shadchin;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.03.18.29.56;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.06.19.12.26;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.07.13.44.24;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.18.19.03.27;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.11.15.56.41;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.11.15.54.24;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.10.15.50.09;	author jsing;	state Exp;
branches;
next	;


desc
@@


1.11
log
@no md code wants lockmgr locks, so no md code needs to include sys/lock.h

with and ok miod@@
@
text
@/*	$OpenBSD: iockbc.c,v 1.10 2013/12/29 18:31:50 miod Exp $	*/
/*
 * Copyright (c) 2013, Miodrag Vallat
 * Copyright (c) 2006, 2007, 2009 Joel Sing <jsing@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Derived from sys/dev/ic/pckbc.c under the following terms:
 * $NetBSD: pckbc.c,v 1.5 2000/06/09 04:58:35 soda Exp $ */

/*
 * Copyright (c) 1998
 *	Matthias Drochner.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for IOC3 and IOC4 PS/2 Controllers (iockbc)
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/timeout.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/errno.h>
#include <sys/queue.h>

#include <machine/autoconf.h>
#include <machine/bus.h>

#include <mips64/archtype.h>

#include <sgi/pci/iocreg.h>
#include <sgi/pci/iocvar.h>
#include <sgi/pci/iofreg.h>
#include <sgi/pci/iofvar.h>

#include <dev/ic/i8042reg.h>
#include <dev/ic/pckbcvar.h>
#include <dev/pckbc/pckbdreg.h>
#define KBC_DEVCMD_ACK		KBR_ACK
#define KBC_DEVCMD_RESEND	KBR_RESEND
#include <dev/pckbc/pckbdvar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <sgi/dev/iockbcreg.h>
#include <sgi/dev/iockbcvar.h>

#include "iockbc.h"

const char *iockbc_slot_names[] = { "kbd", "mouse" };

/* #define IOCKBC_DEBUG */
#ifdef IOCKBC_DEBUG
#define DPRINTF(x...)           do { printf(x); } while(0)
#else
#define DPRINTF(x...)
#endif

struct iockbc_reginfo {
	bus_addr_t rx;
	bus_addr_t tx;
	bus_addr_t cs;
	uint32_t busy;
};

struct iockbc_softc {
	struct pckbc_softc		 sc_pckbc;
	bus_space_tag_t			 iot;
	bus_space_handle_t		 ioh;
	const struct iockbc_reginfo	*reginfo;
	int				 console;
};

int	iockbc_match(struct device *, void *, void *);
void	iockbc_ioc_attach(struct device *, struct device *, void *);
void	iockbc_iof_attach(struct device *, struct device *, void *);

#if NIOCKBC_IOC > 0
struct cfattach iockbc_ioc_ca = {
	sizeof(struct iockbc_softc), iockbc_match, iockbc_ioc_attach
};
#endif
#if NIOCKBC_IOF > 0
struct cfattach iockbc_iof_ca = {
	sizeof(struct iockbc_softc), iockbc_match, iockbc_iof_attach
};
#endif

struct cfdriver iockbc_cd = {
	NULL, "iockbc", DV_DULL
};

/* Descriptor for one device command. */
struct pckbc_devcmd {
	TAILQ_ENTRY(pckbc_devcmd) next;
	int flags;
#define KBC_CMDFLAG_SYNC 1 /* Give descriptor back to caller. */
#define KBC_CMDFLAG_SLOW 2
	u_char cmd[4];
	int cmdlen, cmdidx, retries;
	u_char response[4];
	int status, responselen, responseidx;
};

/* Data per slave device. */
struct pckbc_slotdata {
	int polling; /* Don't read data port in interrupt handler. */
	TAILQ_HEAD(, pckbc_devcmd) cmdqueue; /* Active commands. */
	TAILQ_HEAD(, pckbc_devcmd) freequeue; /* Free commands. */
#define NCMD 5
	struct pckbc_devcmd cmds[NCMD];
	int rx_queue[3];
	int rx_index;
	const struct iockbc_reginfo *reginfo;
};

#define CMD_IN_QUEUE(q) (TAILQ_FIRST(&(q)->cmdqueue) != NULL)

enum iockbc_slottype { EMPTY, KBD, MOUSE };

static struct pckbc_internal iockbc_consdata;
static struct pckbc_slotdata iockbc_cons_slotdata;

int	iockbc_is_ioc_console(struct ioc_attach_args *);
int	iockbc_is_iof_console(struct iof_attach_args *);
void	iockbc_attach_common(struct iockbc_softc *, bus_addr_t, int,
	    const struct iockbc_reginfo *, const struct iockbc_reginfo *);
void	iockbc_start(struct pckbc_internal *, pckbc_slot_t);
int	iockbc_attach_slot(struct iockbc_softc *, pckbc_slot_t);
void	iockbc_init_slotdata(struct pckbc_slotdata *,
	    const struct iockbc_reginfo *);
int	iockbc_submatch(struct device *, void *, void *);
int	iockbcprint(void *, const char *);
int	iockbcintr(void *);
int	iockbcintr_internal(struct pckbc_internal *, struct pckbc_softc *);
void	iockbc_cleanqueue(struct pckbc_slotdata *);
void	iockbc_cleanup(void *);
void	iockbc_poll(void *);
int	iockbc_cmdresponse(struct pckbc_internal *, pckbc_slot_t, u_char);
int	iockbc_poll_read(struct pckbc_internal *, pckbc_slot_t);
int	iockbc_poll_write(struct pckbc_internal *, pckbc_slot_t, int);
void	iockbc_process_input(struct pckbc_softc *, struct pckbc_internal *,
	    int, uint);
enum iockbc_slottype
	iockbc_probe_slot(struct pckbc_internal *, pckbc_slot_t);

int
iockbc_match(struct device *parent, void *cf, void *aux)
{
	/*
	 * We expect ioc and iof NOT to attach us if there are no PS/2 ports.
	 */
	return 1;
}

#if NIOCKBC_IOC > 0
/*
 * Register assignments
 */

const struct iockbc_reginfo iockbc_ioc[PCKBC_NSLOTS] = {
	[PCKBC_KBD_SLOT] = {
		.rx = IOC3_KBC_KBD_RX,
		.tx = IOC3_KBC_KBD_TX,
		.cs = IOC3_KBC_CTRL_STATUS,
		.busy = IOC3_KBC_STATUS_KBD_WRITE_PENDING
	},
	[PCKBC_AUX_SLOT] = {
		.rx = IOC3_KBC_AUX_RX,
		.tx = IOC3_KBC_AUX_TX,
		.cs = IOC3_KBC_CTRL_STATUS,
		.busy = IOC3_KBC_STATUS_AUX_WRITE_PENDING
	}
};

const struct iockbc_reginfo iockbc_ioc_inverted[PCKBC_NSLOTS] = {
	[PCKBC_KBD_SLOT] = {
		.rx = IOC3_KBC_AUX_RX,
		.tx = IOC3_KBC_AUX_TX,
		.cs = IOC3_KBC_CTRL_STATUS,
		.busy = IOC3_KBC_STATUS_AUX_WRITE_PENDING
	},
	[PCKBC_AUX_SLOT] = {
		.rx = IOC3_KBC_KBD_RX,
		.tx = IOC3_KBC_KBD_TX,
		.cs = IOC3_KBC_CTRL_STATUS,
		.busy = IOC3_KBC_STATUS_KBD_WRITE_PENDING
	}
};

void
iockbc_ioc_attach(struct device *parent, struct device *self, void *aux)
{
	struct iockbc_softc *isc = (void*)self;
	struct ioc_attach_args *iaa = aux;

	/* Setup bus space mapping. */
	isc->iot = iaa->iaa_memt;
	isc->ioh = iaa->iaa_memh;

	/* Establish interrupt handler. */
	if (ioc_intr_establish(parent, iaa->iaa_dev, IPL_TTY, iockbcintr,
	    (void *)isc, self->dv_xname))
		printf("\n");
	else
		printf(": unable to establish interrupt\n");

	iockbc_attach_common(isc, iaa->iaa_base, iockbc_is_ioc_console(iaa),
	    iockbc_ioc, iockbc_ioc_inverted);
}
#endif

#if NIOCKBC_IOF > 0
/*
 * Register assignments
 */

const struct iockbc_reginfo iockbc_iof[PCKBC_NSLOTS] = {
	[PCKBC_KBD_SLOT] = {
		.rx = IOC4_KBC_KBD_RX,
		.tx = IOC4_KBC_KBD_TX,
		.cs = IOC4_KBC_CTRL_STATUS,
		.busy = IOC3_KBC_STATUS_KBD_WRITE_PENDING
	},
	[PCKBC_AUX_SLOT] = {
		.rx = IOC4_KBC_AUX_RX,
		.tx = IOC4_KBC_AUX_TX,
		.cs = IOC4_KBC_CTRL_STATUS,
		.busy = IOC3_KBC_STATUS_AUX_WRITE_PENDING
	}
};

const struct iockbc_reginfo iockbc_iof_inverted[PCKBC_NSLOTS] = {
	[PCKBC_KBD_SLOT] = {
		.rx = IOC4_KBC_AUX_RX,
		.tx = IOC4_KBC_AUX_TX,
		.cs = IOC4_KBC_CTRL_STATUS,
		.busy = IOC3_KBC_STATUS_AUX_WRITE_PENDING
	},
	[PCKBC_AUX_SLOT] = {
		.rx = IOC4_KBC_KBD_RX,
		.tx = IOC4_KBC_KBD_TX,
		.cs = IOC4_KBC_CTRL_STATUS,
		.busy = IOC3_KBC_STATUS_KBD_WRITE_PENDING
	}
};

void
iockbc_iof_attach(struct device *parent, struct device *self, void *aux)
{
	struct iockbc_softc *isc = (void*)self;
	struct iof_attach_args *iaa = aux;

	/* Setup bus space mapping. */
	isc->iot = iaa->iaa_memt;
	isc->ioh = iaa->iaa_memh;

	/* Establish interrupt handler. */
	if (iof_intr_establish(parent, iaa->iaa_dev, IPL_TTY, iockbcintr,
	    (void *)isc, self->dv_xname))
		printf("\n");
	else
		printf(": unable to establish interrupt\n");

	iockbc_attach_common(isc, iaa->iaa_base, iockbc_is_iof_console(iaa),
	    iockbc_iof, iockbc_iof_inverted);
}
#endif

void
iockbc_init_slotdata(struct pckbc_slotdata *q,
    const struct iockbc_reginfo *reginfo)
{
	int i;
	TAILQ_INIT(&q->cmdqueue);
	TAILQ_INIT(&q->freequeue);

	for (i = 0; i < NCMD; i++)
		TAILQ_INSERT_TAIL(&q->freequeue, &(q->cmds[i]), next);

	q->polling = 0;
	q->rx_index = -1;

	q->reginfo = reginfo;
}

int
iockbcprint(void *aux, const char *pnp)
{
	struct pckbc_attach_args *pa = aux;

	if (!pnp)
		printf(" (%s slot)", iockbc_slot_names[pa->pa_slot]);

	return (QUIET);
}

int
iockbc_submatch(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct pckbc_attach_args *pa = aux;

	if (cf->cf_loc[PCKBCCF_SLOT] != PCKBCCF_SLOT_DEFAULT &&
	    cf->cf_loc[PCKBCCF_SLOT] != pa->pa_slot)
		return (0);

	return ((*cf->cf_attach->ca_match)(parent, cf, pa));
}

/*
 * Figure out what kind of device is connected to the given slot, if any.
 */
enum iockbc_slottype
iockbc_probe_slot(struct pckbc_internal *t, pckbc_slot_t slot)
{
	int rc, i, tries;

	/* reset device */
	pckbc_flush(t, slot);
	for (tries = 0; tries < 5; tries++) {
		rc = iockbc_poll_write(t, slot, KBC_RESET);
		if (rc < 0) {
			DPRINTF(("%s: slot %d write failed\n", __func__, slot));
			return EMPTY;
		}
		for (i = 10; i != 0; i--) {
			rc = iockbc_poll_read(t, slot);
			if (rc >= 0)
				break;
		}
		if (rc < 0) {
			DPRINTF(("%s: slot %d no answer to reset\n",
			    __func__, slot));
			return EMPTY;
		}
		if (rc == KBC_DEVCMD_ACK)
			break;
		if (rc == KBC_DEVCMD_RESEND)
			continue;
		DPRINTF(("%s: slot %d bogus reset ack %02x\n",
		    __func__, slot, rc));
		return EMPTY;
	}

	/* get answer byte */
	for (i = 10; i != 0; i--) {
		rc = iockbc_poll_read(t, slot);
		if (rc >= 0)
			break;
	}
	if (rc < 0) {
		DPRINTF(("%s: slot %d no answer to reset after ack\n",
		    __func__, slot));
		return EMPTY;
	}
	if (rc != KBR_RSTDONE) {
		DPRINTF(("%s: slot %d bogus reset answer %02x\n",
		    __func__, slot, rc));
		return EMPTY;
	}
	/* mice send an extra byte */
	(void)iockbc_poll_read(t, slot);

	/* ask for device id */
	for (tries = 0; tries < 5; tries++) {
		rc = iockbc_poll_write(t, slot, KBC_READID);
		if (rc == -1) {
			DPRINTF(("%s: slot %d write failed\n", __func__, slot));
			return EMPTY;
		}
		for (i = 10; i != 0; i--) {
			rc = iockbc_poll_read(t, slot);
			if (rc >= 0)
				break;
		}
		if (rc < 0) {
			DPRINTF(("%s: slot %d no answer to command\n",
			    __func__, slot));
			return EMPTY;
		}
		if (rc == KBC_DEVCMD_ACK)
			break;
		if (rc == KBC_DEVCMD_RESEND)
			continue;
		DPRINTF(("%s: slot %d bogus command ack %02x\n",
		    __func__, slot, rc));
		return EMPTY;
	}

	/* get first answer byte */
	for (i = 10; i != 0; i--) {
		rc = iockbc_poll_read(t, slot);
		if (rc >= 0)
			break;
	}
	if (rc < 0) {
		DPRINTF(("%s: slot %d no answer to command after ack\n",
		    __func__, slot));
		return EMPTY;
	}

	switch (rc) {
	case KCID_KBD1:		/* keyboard */
		/* get second answer byte */
		rc = iockbc_poll_read(t, slot);
		if (rc < 0) {
			DPRINTF(("%s: slot %d truncated keyboard answer\n",
			    __func__, slot));
			return EMPTY;
		}
		if (rc != KCID_KBD2) {
			DPRINTF(("%s: slot %d unexpected keyboard answer"
			    " 0x%02x 0x%02x\n", __func__, slot, KCID_KBD1, rc));
			/* return EMPTY; */
		}
		return KBD;
	case KCID_MOUSE:	/* mouse */
		return MOUSE;
	default:
		DPRINTF(("%s: slot %d unknown device answer 0x%02x\n",
		    __func__, slot, rc));
		return EMPTY;
	}
}

int
iockbc_attach_slot(struct iockbc_softc *isc, pckbc_slot_t slot)
{
	struct pckbc_softc *sc = &isc->sc_pckbc;
	struct pckbc_internal *t = sc->id;
	struct pckbc_attach_args pa;
	int found;

	iockbc_init_slotdata(t->t_slotdata[slot], &isc->reginfo[slot]);

	pa.pa_tag = t;
	pa.pa_slot = slot;

	found = (config_found_sm((struct device *)sc, &pa,
	    iockbcprint, iockbc_submatch) != NULL);

	return (found);
}

void
iockbc_attach_common(struct iockbc_softc *isc, bus_addr_t addr, int console,
    const struct iockbc_reginfo *reginfo,
    const struct iockbc_reginfo *reginfo_inverted)
{
	struct pckbc_softc *sc = &isc->sc_pckbc;
	struct pckbc_internal *t;
	bus_addr_t cs;
	uint32_t csr;
	pckbc_slot_t slot;

	if (console) {
		iockbc_consdata.t_sc = sc;
		sc->id = t = &iockbc_consdata;
		isc->console = 1;
		if (&reginfo[PCKBC_KBD_SLOT] == iockbc_cons_slotdata.reginfo)
			isc->reginfo = reginfo;
		else
			isc->reginfo = reginfo_inverted;
	} else {
		/*
		 * Setup up controller: do not force pull clock and data lines
		 * low, clamp clocks after one byte received.
		 */
		cs = reginfo[PCKBC_KBD_SLOT].cs;
		csr = bus_space_read_4(isc->iot, isc->ioh, cs);
		csr &= ~(IOC3_KBC_CTRL_KBD_PULL_DATA_LOW |
		    IOC3_KBC_CTRL_KBD_PULL_CLOCK_LOW |
		    IOC3_KBC_CTRL_AUX_PULL_DATA_LOW |
		    IOC3_KBC_CTRL_AUX_PULL_CLOCK_LOW |
		    IOC3_KBC_CTRL_KBD_CLAMP_3 | IOC3_KBC_CTRL_AUX_CLAMP_3);
		csr |= IOC3_KBC_CTRL_KBD_CLAMP_1 | IOC3_KBC_CTRL_AUX_CLAMP_1;
		bus_space_write_4(isc->iot, isc->ioh, cs, csr);

		/* Setup pckbc_internal structure. */
		t = malloc(sizeof(struct pckbc_internal), M_DEVBUF,
		    M_WAITOK | M_ZERO);
		t->t_iot = isc->iot;
		t->t_ioh_d = isc->ioh;
		t->t_ioh_c = isc->ioh;
		t->t_addr = addr;
		t->t_sc = sc;
		sc->id = t;

		timeout_set(&t->t_cleanup, iockbc_cleanup, t);
		timeout_set(&t->t_poll, iockbc_poll, t);

		isc->reginfo = reginfo;
	}

	for (slot = 0; slot < PCKBC_NSLOTS; slot++) {
		if (t->t_slotdata[slot] == NULL) {
			t->t_slotdata[slot] =
			    malloc(sizeof(struct pckbc_slotdata),
			      M_DEVBUF, M_WAITOK);
		}
	}

	if (!console) {
		enum iockbc_slottype slottype;
		int mouse_on_main = 0;

		/*
		 * Probe for a keyboard. If none is found at the regular
		 * keyboard port, but one is found at the mouse port, then
		 * it is likely that this particular system has both ports
		 * inverted (or incorrect labels on the chassis), unless
		 * this is a human error. In any case, try to get the
		 * keyboard to attach to the `keyboard' port and the
		 * pointing device to the `mouse' port.
		 */

		for (slot = 0; slot < PCKBC_NSLOTS; slot++) {
			iockbc_init_slotdata(t->t_slotdata[slot],
			    &isc->reginfo[slot]);
			slottype = iockbc_probe_slot(t, slot);
			if (slottype == KBD)
				break;
			if (slottype == MOUSE)
				mouse_on_main = slot == PCKBC_KBD_SLOT;
		}
		if (slot == PCKBC_NSLOTS) {
			/*
			 * We could not identify a keyboard. Let's assume
			 * none is connected; if a mouse has been found on
			 * the keyboard port and none on the aux port, the
			 * ports are likely to be inverted.
			 */
			if (mouse_on_main)
				slot = PCKBC_AUX_SLOT;
			else
				slot = PCKBC_KBD_SLOT;
		}
		if (slot == PCKBC_AUX_SLOT) {
			/*
			 * Either human error or inverted wiring; use
			 * the inverted port settings.
			 * iockbc_attach_slot() below will call
			 * iockbc_init_slotdata() again.
			 */
			isc->reginfo = reginfo_inverted;
		}
	}

	/*
	 * Attach "slots". 
	 */
	iockbc_attach_slot(isc, PCKBC_KBD_SLOT);
	iockbc_attach_slot(isc, PCKBC_AUX_SLOT);
}

void
iockbc_poll(void *self)
{
	struct pckbc_internal *t = self;
        int s;

	s = spltty();
	(void)iockbcintr_internal(t, t->t_sc);
	timeout_add_sec(&t->t_poll, 1);
	splx(s);
}

int
iockbcintr(void *vsc)
{
	struct iockbc_softc *isc = (struct iockbc_softc *)vsc;
	struct pckbc_softc *sc = &isc->sc_pckbc;
	struct pckbc_internal *t = sc->id;

	return iockbcintr_internal(t, sc);
}

int
iockbcintr_internal(struct pckbc_internal *t, struct pckbc_softc *sc)
{
	pckbc_slot_t slot;
	struct pckbc_slotdata *q;
	int served = 0;
	uint32_t data;
	uint32_t val;

	/* Reschedule timeout further into the idle times. */
	if (timeout_pending(&t->t_poll))
		timeout_add_sec(&t->t_poll, 1);

	/*
	 * Need to check both "slots" since interrupt could be from
	 * either controller.
	 */ 
	for (slot = 0; slot < PCKBC_NSLOTS; slot++) {
		q = t->t_slotdata[slot];

		for (;;) {
			if (!q) {
				DPRINTF("iockbcintr: no slot%d data!\n", slot);
				break;
			}

			if (q->polling) {
				served = 1;
				break; /* pckbc_poll_data() will get it */
			}

			val = bus_space_read_4(t->t_iot, t->t_ioh_d,
			    q->reginfo->rx);
			if ((val & IOC3_KBC_DATA_VALID) == 0)
        	        	break;

			served = 1;

			/* Process received data. */
			if (val & IOC3_KBC_DATA_0_VALID) {
				data = (val & IOC3_KBC_DATA_0_MASK) >>
				    IOC3_KBC_DATA_0_SHIFT;
				iockbc_process_input(sc, t, slot, data);
			}

			if (val & IOC3_KBC_DATA_1_VALID) {
				data = (val & IOC3_KBC_DATA_1_MASK) >>
				    IOC3_KBC_DATA_1_SHIFT;
				iockbc_process_input(sc, t, slot, data);
			}

			if (val & IOC3_KBC_DATA_2_VALID) {
				data = (val & IOC3_KBC_DATA_2_MASK) >>
				    IOC3_KBC_DATA_2_SHIFT;
				iockbc_process_input(sc, t, slot, data);
			}
		}
	}
	
	return (served);
}

void
iockbc_process_input(struct pckbc_softc *sc, struct pckbc_internal *t,
    int slot, uint data)
{
	struct pckbc_slotdata *q;

	q = t->t_slotdata[slot];
	if (CMD_IN_QUEUE(q) && iockbc_cmdresponse(t, slot, data))
		return;

	if (sc->inputhandler[slot])
		(*sc->inputhandler[slot])(sc->inputarg[slot], data);
	else
		DPRINTF("iockbcintr: slot %d lost %d\n", slot, data);
}

int
iockbc_poll_write(struct pckbc_internal *t, pckbc_slot_t slot, int val)
{
	struct pckbc_slotdata *q = t->t_slotdata[slot];
	bus_space_tag_t iot = t->t_iot;
	bus_space_handle_t ioh = t->t_ioh_d;
	u_int64_t stat;
	int timeout = 10000;

	/* Attempt to write a value to the controller. */
	while (timeout--) {
		stat = bus_space_read_4(iot, ioh, q->reginfo->cs);
		if ((stat & q->reginfo->busy) == 0) {
			bus_space_write_4(iot, ioh, q->reginfo->tx, val & 0xff);
			return 0;
		}
		delay(50);
	}

	DPRINTF("iockbc_poll_write: timeout, sts %08x\n", stat);
	return -1;
}

int
iockbc_poll_read(struct pckbc_internal *t, pckbc_slot_t slot)
{
	struct pckbc_slotdata *q = t->t_slotdata[slot];
	int timeout = 10000;
	u_int32_t val;

	/* See if we already have bytes queued. */
	if (q->rx_index >= 0)
		return q->rx_queue[q->rx_index--];

        /* Poll input from controller. */
        while (timeout--) {
		val = bus_space_read_4(t->t_iot, t->t_ioh_d, q->reginfo->rx);
		if (val & IOC3_KBC_DATA_VALID)
                	break;
                delay(50);
        }
	if ((val & IOC3_KBC_DATA_VALID) == 0) {
		DPRINTF("iockbc_poll_read: timeout, wx %08x\n", val);
		return -1;
	}

	/* Process received data. */
	if (val & IOC3_KBC_DATA_2_VALID)
		q->rx_queue[++q->rx_index] =
		    (val & IOC3_KBC_DATA_2_MASK) >> IOC3_KBC_DATA_2_SHIFT;

	if (val & IOC3_KBC_DATA_1_VALID)
		q->rx_queue[++q->rx_index] =
		    (val & IOC3_KBC_DATA_1_MASK) >> IOC3_KBC_DATA_1_SHIFT;

	if (val & IOC3_KBC_DATA_0_VALID)
		q->rx_queue[++q->rx_index] =
		    (val & IOC3_KBC_DATA_0_MASK) >> IOC3_KBC_DATA_0_SHIFT;

	if (q->rx_index >= 0)
		return q->rx_queue[q->rx_index--];
	else 
		return -1;
}

/*
 * Pass command to device, poll for ACK and data.
 * to be called at spltty()
 */
static void
iockbc_poll_cmd(struct pckbc_internal *t, pckbc_slot_t slot, 
    struct pckbc_devcmd *cmd)
{
	int i, c = 0;

	while (cmd->cmdidx < cmd->cmdlen) {
		if (iockbc_poll_write(t, slot, cmd->cmd[cmd->cmdidx]) == -1) {
			DPRINTF("iockbc_poll_cmd: send error\n");
			cmd->status = EIO;
			return;
		}
		for (i = 10; i; i--) { /* 1s ??? */
			c = iockbc_poll_read(t, slot);
			if (c != -1)
				break;
		}
		if (c == KBC_DEVCMD_ACK) {
			cmd->cmdidx++;
			continue;
		}
		if (c == KBC_DEVCMD_RESEND) {
			DPRINTF("iockbc_cmd: RESEND\n");
			if (cmd->retries++ < 5)
				continue;
			else {
				DPRINTF("iockbc: cmd failed\n");
				cmd->status = EIO;
				return;
			}
		}
		if (c == -1) {
			DPRINTF("iockbc_cmd: timeout\n");
			cmd->status = EIO;
			return;
		}
		DPRINTF("iockbc_cmd: lost 0x%x\n", c);
	}

	while (cmd->responseidx < cmd->responselen) {
		if (cmd->flags & KBC_CMDFLAG_SLOW)
			i = 100; /* 10s ??? */
		else
			i = 10; /* 1s ??? */
		while (i--) {
			c = iockbc_poll_read(t, slot);
			if (c != -1)
				break;
		}
		if (c == -1) {
			DPRINTF("iockbc_poll_cmd: no data\n");
			cmd->status = ETIMEDOUT;
			return;
		} else
			cmd->response[cmd->responseidx++] = c;
	}
}

/*
 * Clean up a command queue, throw away everything.
 */
void
iockbc_cleanqueue(struct pckbc_slotdata *q)
{
	struct pckbc_devcmd *cmd;
#ifdef IOCKBC_DEBUG
	int i;
#endif

	while ((cmd = TAILQ_FIRST(&q->cmdqueue))) {
		TAILQ_REMOVE(&q->cmdqueue, cmd, next);
#ifdef IOCKBC_DEBUG
		printf("iockbc_cleanqueue: removing");
		for (i = 0; i < cmd->cmdlen; i++)
			printf(" %02x", cmd->cmd[i]);
		printf("\n");
#endif
		TAILQ_INSERT_TAIL(&q->freequeue, cmd, next);
	}
}

/*
 * Timeout error handler: clean queues and data port.
 * XXX could be less invasive.
 */
void
iockbc_cleanup(void *self)
{
	struct pckbc_internal *t = self;
	int s;

	printf("iockbc: command timeout\n");

	s = spltty();

	if (t->t_slotdata[PCKBC_KBD_SLOT])
		iockbc_cleanqueue(t->t_slotdata[PCKBC_KBD_SLOT]);
	if (t->t_slotdata[PCKBC_AUX_SLOT])
		iockbc_cleanqueue(t->t_slotdata[PCKBC_AUX_SLOT]);

	while (iockbc_poll_read(t, PCKBC_KBD_SLOT) 
	       != -1) ;
	while (iockbc_poll_read(t, PCKBC_AUX_SLOT) 
	       != -1) ;

	/* Reset KBC? */

	splx(s);
}

/*
 * Pass command to device during normal operation.
 * to be called at spltty()
 */
void
iockbc_start(struct pckbc_internal *t, pckbc_slot_t slot)
{
	struct pckbc_slotdata *q = t->t_slotdata[slot];
	struct pckbc_devcmd *cmd = TAILQ_FIRST(&q->cmdqueue);

	if (q->polling) {
		do {
			iockbc_poll_cmd(t, slot, cmd);
			if (cmd->status)
				printf("iockbc_start: command error\n");

			TAILQ_REMOVE(&q->cmdqueue, cmd, next);
			if (cmd->flags & KBC_CMDFLAG_SYNC)
				wakeup(cmd);
			else {
				timeout_del(&t->t_cleanup);
				TAILQ_INSERT_TAIL(&q->freequeue, cmd, next);
			}
			cmd = TAILQ_FIRST(&q->cmdqueue);
		} while (cmd);
		return;
	}

	if (iockbc_poll_write(t, slot, cmd->cmd[cmd->cmdidx])) {
		printf("iockbc_start: send error\n");
		/* XXX what now? */
		return;
	}
}

/*
 * Handle command responses coming in asynchronously,
 * return nonzero if valid response.
 * to be called at spltty()
 */
int
iockbc_cmdresponse(struct pckbc_internal *t, pckbc_slot_t slot, u_char data)
{
	struct pckbc_slotdata *q = t->t_slotdata[slot];
	struct pckbc_devcmd *cmd = TAILQ_FIRST(&q->cmdqueue);
#ifdef DIAGNOSTIC
	if (!cmd)
		panic("iockbc_cmdresponse: no active command");
#endif
	if (cmd->cmdidx < cmd->cmdlen) {
		if (data != KBC_DEVCMD_ACK && data != KBC_DEVCMD_RESEND)
			return (0);

		if (data == KBC_DEVCMD_RESEND) {
			if (cmd->retries++ < 5) {
				/* try again last command */
				goto restart;
			} else {
				DPRINTF("iockbc: cmd failed\n");
				cmd->status = EIO;
				/* dequeue */
			}
		} else {
			if (++cmd->cmdidx < cmd->cmdlen)
				goto restart;
			if (cmd->responselen)
				return (1);
			/* else dequeue */
		}
	} else if (cmd->responseidx < cmd->responselen) {
		cmd->response[cmd->responseidx++] = data;
		if (cmd->responseidx < cmd->responselen)
			return (1);
		/* else dequeue */
	} else
		return (0);

	/* dequeue: */
	TAILQ_REMOVE(&q->cmdqueue, cmd, next);
	if (cmd->flags & KBC_CMDFLAG_SYNC)
		wakeup(cmd);
	else {
		timeout_del(&t->t_cleanup);
		TAILQ_INSERT_TAIL(&q->freequeue, cmd, next);
	}
	if (!CMD_IN_QUEUE(q))
		return (1);
restart:
	iockbc_start(t, slot);
	return (1);
}

/*
 * Interfaces to act like pckbc(4).
 */

int
pckbc_xt_translation(pckbc_tag_t self)
{
	/* Translation isn't supported... */
	return (-1);
}

/* For use in autoconfiguration. */
int
pckbc_poll_cmd(pckbc_tag_t self, pckbc_slot_t slot, u_char *cmd, int len, 
    int responselen, u_char *respbuf, int slow)
{
	struct pckbc_devcmd nc;
	int s;

	if ((len > 4) || (responselen > 4))
		return (EINVAL);

	bzero(&nc, sizeof(nc));
	bcopy(cmd, nc.cmd, len);
	nc.cmdlen = len;
	nc.responselen = responselen;
	nc.flags = (slow ? KBC_CMDFLAG_SLOW : 0);

	s = spltty();
	iockbc_poll_cmd(self, slot, &nc);
	splx(s);

	if (nc.status == 0 && respbuf)
		bcopy(nc.response, respbuf, responselen);

	return (nc.status);
}

void
pckbc_flush(pckbc_tag_t self, pckbc_slot_t slot)
{
	/* Read any data and discard. */
	struct pckbc_internal *t = self;
	(void) iockbc_poll_read(t, slot);
}

/*
 * Put command into the device's command queue, return zero or errno.
 */
int
pckbc_enqueue_cmd(pckbc_tag_t self, pckbc_slot_t slot, u_char *cmd, int len, 
    int responselen, int sync, u_char *respbuf)
{
	struct pckbc_internal *t = self;
	struct pckbc_slotdata *q = t->t_slotdata[slot];
	struct pckbc_devcmd *nc;
	int s, isactive, res = 0;

	if ((len > 4) || (responselen > 4))
		return (EINVAL);
	s = spltty();
	nc = TAILQ_FIRST(&q->freequeue);
	if (nc)
		TAILQ_REMOVE(&q->freequeue, nc, next);
	splx(s);
	if (!nc)
		return (ENOMEM);

	bzero(nc, sizeof(*nc));
	bcopy(cmd, nc->cmd, len);
	nc->cmdlen = len;
	nc->responselen = responselen;
	nc->flags = (sync ? KBC_CMDFLAG_SYNC : 0);

	s = spltty();

	if (q->polling && sync) {
		/*
		 * XXX We should poll until the queue is empty.
		 * But we don't come here normally, so make
		 * it simple and throw away everything.
		 */
		iockbc_cleanqueue(q);
	}

	isactive = CMD_IN_QUEUE(q);
	TAILQ_INSERT_TAIL(&q->cmdqueue, nc, next);
	if (!isactive)
		iockbc_start(t, slot);

	if (q->polling)
		res = (sync ? nc->status : 0);
	else if (sync) {
		if ((res = tsleep(nc, 0, "kbccmd", 1*hz))) {
			TAILQ_REMOVE(&q->cmdqueue, nc, next);
			iockbc_cleanup(t);
		} else
			res = nc->status;
	} else
		timeout_add_sec(&t->t_cleanup, 1);

	if (sync) {
		if (respbuf)
			bcopy(nc->response, respbuf, responselen);
		TAILQ_INSERT_TAIL(&q->freequeue, nc, next);
	}

	splx(s);

	return (res);
}

int
pckbc_poll_data(pckbc_tag_t self, pckbc_slot_t slot)
{
	struct pckbc_internal *t = self;
	struct pckbc_slotdata *q = t->t_slotdata[slot];
	int c;

	c = iockbc_poll_read(t, slot);
	if (c != -1 && q && CMD_IN_QUEUE(q)) {
		/* We jumped into a running command - try to deliver the 
		   response. */
		if (iockbc_cmdresponse(t, slot, c))
			return (-1);
	}
	return (c);
}

void
pckbc_set_inputhandler(pckbc_tag_t self, pckbc_slot_t slot, pckbc_inputfcn func,
    void *arg, char *name)
{
	struct pckbc_internal *t = (struct pckbc_internal *)self;
	struct pckbc_softc *sc = t->t_sc;
	struct iockbc_softc *isc = (struct iockbc_softc *)sc;

	if (slot >= PCKBC_NSLOTS)
		panic("iockbc_set_inputhandler: bad slot %d", slot);

	sc->inputhandler[slot] = func;
	sc->inputarg[slot] = arg;
	sc->subname[slot] = name;

	if ((isc == NULL || isc->console) && slot == PCKBC_KBD_SLOT)
		timeout_add_sec(&t->t_poll, 1);
}

void
pckbc_slot_enable(pckbc_tag_t self, pckbc_slot_t slot, int on)
{
	struct pckbc_internal *t = (struct pckbc_internal *)self;

	if (slot == PCKBC_KBD_SLOT) {
		if (on)
			timeout_add_sec(&t->t_poll, 1);
		else
			timeout_del(&t->t_poll);
	}
}

void
pckbc_set_poll(pckbc_tag_t self, pckbc_slot_t slot, int on)
{
	struct pckbc_internal *t = (struct pckbc_internal *)self;

	t->t_slotdata[slot]->polling = on;

	if (!on) {
		int s;

		/*
		 * If disabling polling on a device that's been configured,
		 * make sure there are no bytes left in the FIFO, holding up
		 * the interrupt line.  Otherwise we won't get any further
		 * interrupts.
		 */
		if (t->t_sc) {
			s = spltty();
			iockbcintr(t->t_sc);
			splx(s);
		}
	}
}

/*
 * Console support.
 */

static int iockbc_console;

int
iockbc_cnattach()
{
	bus_space_tag_t iot = &sys_config.console_io;
	bus_space_handle_t ioh = (bus_space_handle_t)iot->bus_base;
	struct pckbc_internal *t = &iockbc_consdata;
	const struct iockbc_reginfo *reginfo = NULL, *reginfo_inverted;
	enum iockbc_slottype slottype;
	pckbc_slot_t slot;
	uint32_t csr;
	int is_ioc;
	int rc;

	is_ioc = console_input.specific ==
	    PCI_ID_CODE(PCI_VENDOR_SGI, PCI_PRODUCT_SGI_IOC3);
	if (is_ioc) {
#if NIOCKBC_IOC > 0
		reginfo = iockbc_ioc;
		reginfo_inverted = iockbc_ioc_inverted;
#endif
	} else {
#if NIOCKBC_IOF > 0
		reginfo = iockbc_iof;
		reginfo_inverted = iockbc_iof_inverted;
#endif
	}
	if (reginfo == NULL)
		return ENXIO;

	/*
	 * Setup up controller: do not force pull clock and data lines
	 * low, clamp clocks after one byte received.
	 */
	csr = bus_space_read_4(iot, ioh, reginfo->cs);
	csr &= ~(IOC3_KBC_CTRL_KBD_PULL_DATA_LOW |
	    IOC3_KBC_CTRL_KBD_PULL_CLOCK_LOW |
	    IOC3_KBC_CTRL_AUX_PULL_DATA_LOW |
	    IOC3_KBC_CTRL_AUX_PULL_CLOCK_LOW |
	    IOC3_KBC_CTRL_KBD_CLAMP_3 | IOC3_KBC_CTRL_AUX_CLAMP_3);
	csr |= IOC3_KBC_CTRL_KBD_CLAMP_1 | IOC3_KBC_CTRL_AUX_CLAMP_1;
	bus_space_write_4(iot, ioh, reginfo->cs, csr);

	/* Setup pckbc_internal structure. */
	t->t_iot = iot;
	t->t_ioh_d = (bus_space_handle_t)iot->bus_base;
	t->t_addr = 0;	/* unused */

	timeout_set(&t->t_cleanup, iockbc_cleanup, t);
	timeout_set(&t->t_poll, iockbc_poll, t);

	/*
	 * Probe for a keyboard. There must be one connected, for the PROM
	 * would not have advertized glass console if none had been
	 * detected.
	 */

	for (slot = 0; slot < PCKBC_NSLOTS; slot++) {
		iockbc_init_slotdata(&iockbc_cons_slotdata, &reginfo[slot]);
		t->t_slotdata[slot] = &iockbc_cons_slotdata;
		slottype = iockbc_probe_slot(t, slot);
		t->t_slotdata[slot] = NULL;
		if (slottype == KBD)
			break;
	}
	if (slot == PCKBC_NSLOTS) {
		/*
		 * We could not identify a keyboard, but the PROM did;
		 * let's assume it's a fluke and assume it exists and
		 * is connected to the first connector.
		 */
		slot = PCKBC_KBD_SLOT;
		/*
		 * For some reason keyboard and mouse ports are inverted on
		 * Fuel. They also are inverted on some IO9 boards, but
		 * we can't tell both IO9 flavour apart, yet.
		 */
		if (is_ioc && sys_config.system_type == SGI_IP35)
			slot = PCKBC_AUX_SLOT;
	}

	if (slot == PCKBC_AUX_SLOT) {
		/*
		 * Either human error when plugging the keyboard, or the
		 * physical connectors on the chassis are inverted.
		 * Compensate by switching in software (pckbd relies upon
		 * being at PCKBC_KBD_SLOT).
		 */
		reginfo = reginfo_inverted;
	}

	iockbc_init_slotdata(&iockbc_cons_slotdata, &reginfo[PCKBC_KBD_SLOT]);
	t->t_slotdata[PCKBC_KBD_SLOT] = &iockbc_cons_slotdata;

	rc = pckbd_cnattach(t);
	if (rc == 0)
		iockbc_console = 1;

	return rc;
}

#if NIOCKBC_IOC > 0
int
iockbc_is_ioc_console(struct ioc_attach_args *iaa)
{
	if (iockbc_console == 0)
		return 0;

	return location_match(&iaa->iaa_location, &console_input);
}
#endif

#if NIOCKBC_IOF > 0
int
iockbc_is_iof_console(struct iof_attach_args *iaa)
{
	if (iockbc_console == 0)
		return 0;

	return location_match(&iaa->iaa_location, &console_input);
}
#endif
@


1.10
log
@Force clock clamping after one byte received instead of three. There are still
circumstances where the pckbc code gets confused otherwise, on *some*
controllers.
@
text
@d1 1
a1 1
/*	$OpenBSD: iockbc.c,v 1.9 2013/12/25 21:01:01 miod Exp $	*/
a61 1
#include <sys/lock.h>
@


1.9
log
@Instead of deciding which iockbc port is the keyboard port, and which one is the
mouse port, depending upon the system time, match what the prom is doing and
actually probe for a keyboard on both ports, and decide the first port with a
keyboard is the keyboard port.

If no keyboard is found, but a mouse is found, decide the keyboard port is the
empty one.

If no device is found, then we can try and pick the defaults, depending upon
the system we are running on, as this used to be the case (i.e. coping with
Fuel having keyboard on port 1 and mouse on port 0 when connecting devices
according to the chassis' markings).

This is necessary because different IO9 board revisions on Tezro come with
different wirings, and we can not tell these boards apart.

Discussed with "nullnilaki" (nullnilaki on gmail) who is the lucky owner of an
Onyx 350 with correct wiring and a Tezro with inverted wiring. Tested on Octane
and Fuel with all combinations of devices connected (mouse only, keyboard only,
keyboard and mouse) in both ports, glass and serial console.

XXX We probably want to allow for more pckbd attachment flexibility on non-x86
XXX platforms eventually (at least where the PS/2 slots are really independent,
XXX so that we can attach pckbd to any port and better cope with human error
XXX when connecting devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: iockbc.c,v 1.8 2012/08/10 17:49:31 shadchin Exp $	*/
d507 1
a507 1
		 * low, clamp clocks after three bytes received.
d515 2
a516 2
		    IOC3_KBC_CTRL_KBD_CLAMP_1 | IOC3_KBC_CTRL_AUX_CLAMP_1);
		csr |= IOC3_KBC_CTRL_KBD_CLAMP_3 | IOC3_KBC_CTRL_AUX_CLAMP_3;
d1189 1
a1189 1
	 * low, clamp clocks after three bytes received.
d1196 2
a1197 2
	    IOC3_KBC_CTRL_KBD_CLAMP_1 | IOC3_KBC_CTRL_AUX_CLAMP_1);
	csr |= IOC3_KBC_CTRL_KBD_CLAMP_3 | IOC3_KBC_CTRL_AUX_CLAMP_3;
@


1.8
log
@simplify pckbc_xt_translation()
* call only for set translation on (once in /sys/dev/pckbd.c)
  therefore we can delete unused code.
* change behavior (more standard) - return zero on success

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iockbc.c,v 1.7 2010/12/03 18:29:56 shadchin Exp $	*/
d3 1
d74 1
d76 3
a90 3
#define KBC_DEVCMD_ACK 0xfa
#define KBC_DEVCMD_RESEND 0xfe

d158 4
a161 1
struct pckbc_internal iockbc_consdata;
d165 2
a166 1
void	iockbc_attach_common(struct iockbc_softc *, bus_addr_t, int);
d183 2
d200 1
a200 1
const struct iockbc_reginfo iockbc_ioc_normal[PCKBC_NSLOTS] = {
a235 10
	/*
	 * For some reason keyboard and mouse ports are inverted on Fuel.
	 */

	if (ISSET(iaa->iaa_flags, IOC_FLAGS_OBIO) &&
	    sys_config.system_type == SGI_IP35)
		isc->reginfo = iockbc_ioc_inverted;
	else
		isc->reginfo = iockbc_ioc_normal;

d247 2
a248 1
	iockbc_attach_common(isc, iaa->iaa_base, iockbc_is_ioc_console(iaa));
d272 15
a292 2
	isc->reginfo = iockbc_iof;

d304 2
a305 1
	iockbc_attach_common(isc, iaa->iaa_base, iockbc_is_iof_console(iaa));
d347 117
a463 1
	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
d474 1
a474 10
	if (!t->t_slotdata[slot]) {
		t->t_slotdata[slot] = malloc(sizeof(struct pckbc_slotdata),
		    M_DEVBUF, M_NOWAIT);

		if (t->t_slotdata[slot] == NULL) {
			printf("Failed to allocate slot data!\n");
			return 0;
		}
		iockbc_init_slotdata(t->t_slotdata[slot], &isc->reginfo[slot]);
	}
d478 1
d486 3
a488 1
iockbc_attach_common(struct iockbc_softc *isc, bus_addr_t addr, int console)
d494 1
d498 1
a498 1
		sc->id = &iockbc_consdata;
d500 4
d509 1
a509 1
		cs = isc->reginfo[0].cs;
d531 56
a1155 1
static struct pckbc_slotdata iockbc_cons_slotdata;
d1164 3
a1166 1
	const struct iockbc_reginfo *reginfo = NULL;
d1175 2
a1176 4
		if (sys_config.system_type == SGI_IP35)
			reginfo = &iockbc_ioc_inverted[PCKBC_KBD_SLOT];
		else
			reginfo = &iockbc_ioc_normal[PCKBC_KBD_SLOT];
d1180 2
a1181 1
		reginfo = &iockbc_iof[PCKBC_KBD_SLOT];
d1208 41
a1248 1
	iockbc_init_slotdata(&iockbc_cons_slotdata, reginfo);
@


1.7
log
@removed slot argument of function pckbd_cnattach
because it is always PCKBC_KBD_SLOT

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iockbc.c,v 1.6 2010/04/06 19:12:26 miod Exp $	*/
d788 1
a788 1
pckbc_xt_translation(pckbc_tag_t self, pckbc_slot_t slot, int on)
d791 1
a791 1
	return 0;
@


1.6
log
@Obtain struct sgi_device_location for the console input and output devices,
and compare against them when attaching potential console drivers, to figure
out whether they indeed are acting are console devices or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: iockbc.c,v 1.5 2010/03/07 13:44:24 miod Exp $	*/
d976 1
a976 1
iockbc_cnattach(pckbc_slot_t slot)
d991 1
a991 1
			reginfo = &iockbc_ioc_inverted[slot];
d993 1
a993 1
			reginfo = &iockbc_ioc_normal[slot];
d997 1
a997 1
		reginfo = &iockbc_iof[slot];
d1025 1
a1025 1
	t->t_slotdata[slot] = &iockbc_cons_slotdata;
d1027 1
a1027 1
	rc = pckbd_cnattach(t, slot);
@


1.5
log
@Allow iockbc(4) and odysseey(4) to act as console devices and attach early;
this gives us working glass console on Fuel, as well as on Octane systems
with Odyssey graphics.
Joint work with jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iockbc.c,v 1.4 2009/11/18 19:03:27 miod Exp $	*/
a969 4
 *
 * There might multiple IOC3 and/or IOC4 devices in the system; the kernel
 * will currently only use the one the debug serial console would be attached
 * to as the console input device, regardless of the ConsoleIn variable.
a971 5
static int16_t iockbc_console_nasid;
static int iockbc_console_widget;
static int iockbc_console_npci;
static uint32_t iockbc_console_type;

d973 1
d976 1
a976 2
iockbc_cnattach(int16_t nasid, int widget, int npci, uint32_t type,
    pckbc_slot_t slot)
d986 2
a987 1
	is_ioc = type == PCI_ID_CODE(PCI_VENDOR_SGI, PCI_PRODUCT_SGI_IOC3);
d1028 2
a1029 11

	/*
	 * Upon success, remember our configuration to be able to
	 * recognize the console input device during autoconf.
	 */
	if (rc == 0) {
		iockbc_console_nasid = nasid;
		iockbc_console_widget = widget;
		iockbc_console_npci = npci;
		iockbc_console_type = type;
	}
d1038 4
a1041 5
	return iaa->iaa_nasid == iockbc_console_nasid &&
	    iaa->iaa_widget == iockbc_console_widget &&
	    iaa->iaa_npci == iockbc_console_npci &&
	    iockbc_console_type ==
	      PCI_ID_CODE(PCI_VENDOR_SGI, PCI_PRODUCT_SGI_IOC3);
d1049 4
a1052 5
	return iaa->iaa_nasid == iockbc_console_nasid &&
	    iaa->iaa_widget == iockbc_console_widget &&
	    iaa->iaa_npci == iockbc_console_npci &&
	    iockbc_console_type ==
	      PCI_ID_CODE(PCI_VENDOR_SGI, PCI_PRODUCT_SGI_IOC4);
@


1.4
log
@Add glue to attach iockbc(4) to iof(4) as well. Tested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iockbc.c,v 1.3 2009/11/11 15:56:41 miod Exp $	*/
a67 2
#include <sgi/dev/iockbcreg.h>

d76 6
d96 7
d104 5
a108 6
	struct pckbc_softc sc_pckbc;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	bus_addr_t rx[PCKBC_NSLOTS];
	bus_addr_t tx[PCKBC_NSLOTS];
	bus_addr_t cs;
d151 1
d156 1
a156 1
static int iockbc_console;
d158 3
a160 1
void	iockbc_attach_common(struct iockbc_softc *, bus_addr_t);
d163 2
a164 1
void	iockbc_init_slotdata(struct pckbc_slotdata *);
d182 1
a182 1
	 * We expect ioc and iof NOT to attach us on if there are no PS/2 ports.
d188 34
d233 4
a236 12
	    sys_config.system_type == SGI_IP35) {
		isc->rx[PCKBC_KBD_SLOT] = IOC3_KBC_AUX_RX;
		isc->rx[PCKBC_AUX_SLOT] = IOC3_KBC_KBD_RX;
		isc->tx[PCKBC_KBD_SLOT] = IOC3_KBC_AUX_TX;
		isc->tx[PCKBC_AUX_SLOT] = IOC3_KBC_KBD_TX;
	} else {
		isc->rx[PCKBC_KBD_SLOT] = IOC3_KBC_KBD_RX;
		isc->rx[PCKBC_AUX_SLOT] = IOC3_KBC_AUX_RX;
		isc->tx[PCKBC_KBD_SLOT] = IOC3_KBC_KBD_TX;
		isc->tx[PCKBC_AUX_SLOT] = IOC3_KBC_AUX_TX;
	}
	isc->cs = IOC3_KBC_CTRL_STATUS;
d249 1
a249 1
	iockbc_attach_common(isc, iaa->iaa_base);
d254 19
d279 1
a279 5
	isc->rx[PCKBC_KBD_SLOT] = IOC4_KBC_KBD_RX;
	isc->rx[PCKBC_AUX_SLOT] = IOC4_KBC_AUX_RX;
	isc->tx[PCKBC_KBD_SLOT] = IOC4_KBC_KBD_TX;
	isc->tx[PCKBC_AUX_SLOT] = IOC4_KBC_AUX_TX;
	isc->cs = IOC4_KBC_CTRL_STATUS;
d292 1
a292 1
	iockbc_attach_common(isc, iaa->iaa_base);
d297 2
a298 1
iockbc_init_slotdata(struct pckbc_slotdata *q)
d309 2
d338 1
a338 1
iockbc_attach_slot(struct iockbc_softc *sc, pckbc_slot_t slot)
d340 2
a341 2
	struct pckbc_softc *isc = &sc->sc_pckbc;
	struct pckbc_internal *t = isc->id;
d353 1
a353 1
		iockbc_init_slotdata(t->t_slotdata[slot]);
d365 1
a365 1
iockbc_attach_common(struct iockbc_softc *isc, bus_addr_t addr)
d369 1
d372 28
a399 12
	/*
	 * Setup up controller: do not force pull clock and data lines low,
	 * clamp clocks after three bytes received.
	 */
	csr = bus_space_read_4(isc->iot, isc->ioh, isc->cs);
	csr &= ~(IOC3_KBC_CTRL_KBD_PULL_DATA_LOW |
	    IOC3_KBC_CTRL_KBD_PULL_CLOCK_LOW |
	    IOC3_KBC_CTRL_AUX_PULL_DATA_LOW |
	    IOC3_KBC_CTRL_AUX_PULL_CLOCK_LOW |
	    IOC3_KBC_CTRL_KBD_CLAMP_1 | IOC3_KBC_CTRL_AUX_CLAMP_1);
	csr |= IOC3_KBC_CTRL_KBD_CLAMP_3 | IOC3_KBC_CTRL_AUX_CLAMP_3;
	bus_space_write_4(isc->iot, isc->ioh, isc->cs, csr);
d401 3
a403 12
	/* Setup pckbc_internal structure. */
	t = malloc(sizeof(struct pckbc_internal), M_DEVBUF,
	    M_WAITOK | M_ZERO);
	t->t_iot = isc->iot;
	t->t_ioh_d = isc->ioh;
	t->t_ioh_c = isc->ioh;
	t->t_addr = addr;
	t->t_sc = sc;
	sc->id = t;

	timeout_set(&t->t_cleanup, iockbc_cleanup, t);
	timeout_set(&t->t_poll, iockbc_poll, t);
a436 1
	struct iockbc_softc *isc = (void *)sc;
d466 1
a466 1
			    isc->rx[slot]);
d515 1
a515 1
	struct iockbc_softc *isc = (void *)t->t_sc;
d518 1
a518 1
	u_int64_t stat, offset, busy;
a520 4
	offset = isc->tx[slot];
	busy = slot == PCKBC_AUX_SLOT ?  IOC3_KBC_STATUS_AUX_WRITE_PENDING :
	    IOC3_KBC_STATUS_KBD_WRITE_PENDING;

d523 3
a525 3
		stat = bus_space_read_4(iot, ioh, isc->cs);
		if ((stat & busy) == 0) {
			bus_space_write_4(iot, ioh, offset, val & 0xff);
a537 1
	struct iockbc_softc *isc = (void *)t->t_sc;
d548 1
a548 1
		val = bus_space_read_4(t->t_iot, t->t_ioh_d, isc->rx[slot]);
d918 1
d927 1
a927 1
	if (iockbc_console && slot == PCKBC_KBD_SLOT)
d967 107
@


1.3
log
@Let ioc(4) pass the information whether it is an onboard device or not, to its
subdevices; use this on iockbc to only perform the fuel workaround on the
onboard ioc.
@
text
@d1 1
a1 1
/*	$OpenBSD: iockbc.c,v 1.2 2009/11/11 15:54:24 miod Exp $	*/
d48 1
a48 1
 * Driver for IOC3 PS/2 Controllers (iockbc)
d68 2
a69 2
#include <sgi/localbus/crimebus.h>
#include <sgi/localbus/macebus.h>
d72 2
d78 2
d98 1
d102 2
a103 1
void	iockbc_attach(struct device *, struct device *, void *);
d105 8
a112 2
struct cfattach iockbc_ca = {
	sizeof(struct iockbc_softc), iockbc_match, iockbc_attach
d114 1
d147 1
d168 1
a168 1
	 * We expect ioc NOT to attach us on if there are no PS/2 ports.
d173 68
d307 1
a307 1
iockbc_attach(struct device *parent, struct device *self, void *aux)
a308 2
	struct iockbc_softc *isc = (void*)self;
	struct ioc_attach_args *iaa = aux;
d314 2
a315 1
	 * For some reason keyboard and mouse ports are inverted on Fuel.
d317 8
a324 17

	if (ISSET(iaa->iaa_flags, IOC_FLAGS_OBIO) &&
	    sys_config.system_type == SGI_IP35) {
		isc->rx[PCKBC_KBD_SLOT] = IOC3_KBC_AUX_RX;
		isc->rx[PCKBC_AUX_SLOT] = IOC3_KBC_KBD_RX;
		isc->tx[PCKBC_KBD_SLOT] = IOC3_KBC_AUX_TX;
		isc->tx[PCKBC_AUX_SLOT] = IOC3_KBC_KBD_TX;
	} else {
		isc->rx[PCKBC_KBD_SLOT] = IOC3_KBC_KBD_RX;
		isc->rx[PCKBC_AUX_SLOT] = IOC3_KBC_AUX_RX;
		isc->tx[PCKBC_KBD_SLOT] = IOC3_KBC_KBD_TX;
		isc->tx[PCKBC_AUX_SLOT] = IOC3_KBC_AUX_TX;
	}

	/* Setup bus space mapping. */
	isc->iot = iaa->iaa_memt;
	isc->ioh = iaa->iaa_memh;
d332 2
a333 2
	t->t_addr = iaa->iaa_base;
	t->t_sc = (struct pckbc_softc *)sc;
a338 20
	/* Establish interrupt handler. */
	if (ioc_intr_establish(parent, iaa->iaa_dev, IPL_TTY, iockbcintr,
	    (void *)isc, sc->sc_dv.dv_xname))
		printf("\n");
	else
		printf(": unable to establish interrupt\n");

	/*
	 * Setup up controller: do not force pull clock and data lines low,
	 * clamp clocks after three bytes received.
	 */
	csr = bus_space_read_4(isc->iot, isc->ioh, IOC3_KBC_CTRL_STATUS);
	csr &= ~(IOC3_KBC_CTRL_KBD_PULL_DATA_LOW |
	    IOC3_KBC_CTRL_KBD_PULL_CLOCK_LOW |
	    IOC3_KBC_CTRL_AUX_PULL_DATA_LOW |
	    IOC3_KBC_CTRL_AUX_PULL_CLOCK_LOW |
	    IOC3_KBC_CTRL_KBD_CLAMP_1 | IOC3_KBC_CTRL_AUX_CLAMP_1);
	csr |= IOC3_KBC_CTRL_KBD_CLAMP_3 | IOC3_KBC_CTRL_AUX_CLAMP_3;
	bus_space_write_4(isc->iot, isc->ioh, IOC3_KBC_CTRL_STATUS, csr);

d462 1
a462 1
		stat = bus_space_read_4(iot, ioh, IOC3_KBC_CTRL_STATUS);
@


1.2
log
@Perform a bit more kbc initialization, instead of relying upon the prom to
do this for us; PS/2 ports on CADduo boards attach keyboard and mouse now.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iockbc.c,v 1.1 2009/11/10 15:50:09 jsing Exp $	*/
d234 1
a234 2
	 * For some reason keyboard and mouse ports are inverted on
	 * Fuel (and probably Origin 300 as well).
d237 2
a238 1
	if (sys_config.system_type == SGI_IP35) {
@


1.1
log
@Add iockbc(4), a driver for the PS/2 keyboard and mouse interface found on
ioc(4) devices. Joint work with miod@@.

Committed from the glass console on an SGI Fuel.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d231 1
d275 13
d418 1
d441 4
@

