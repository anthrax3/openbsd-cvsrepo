head	1.15;
access;
symbols
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.14
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.10
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.6
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.8
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.14
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.10
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.8
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.6
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.9.0.2
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6;
locks; strict;
comment	@ * @;


1.15
date	2014.07.11.08.18.30;	author guenther;	state Exp;
branches;
next	1.14;
commitid	zJyOCNTjgsYVGLiw;

1.14
date	2011.06.24.19.47.49;	author naddy;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.25.11.23.29;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.26.20.14.42;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.26.18.13.34;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.26.18.00.06;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2009.05.16.16.04.11;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.15.23.02.23;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.16.16.38.25;	author jasper;	state Exp;
branches;
next	1.6;

1.6
date	2008.02.21.11.42.23;	author jsing;	state Exp;
branches;
next	1.5;

1.5
date	2008.02.20.18.46.20;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.27.03.00.51;	author jsing;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.18.09.42.00;	author jasper;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.18.08.48.22;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.18.08.29.02;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.15
log
@It's init as a process that's special, not init's original thread.
Remember initprocess instead of initproc.

ok matthew@@ blambert@@
@
text
@/*	$OpenBSD: power.c,v 1.14 2011/06/24 19:47:49 naddy Exp $	*/

/*
 * Copyright (c) 2007 Jasper Lievisse Adriaanse <jasper@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/signalvar.h>

#include <machine/autoconf.h>
#include <mips64/archtype.h>

#include <dev/ic/ds1687reg.h>
#include <sgi/dev/dsrtcvar.h>

#include "power.h"

/*
 * Power button driver for the SGI O2 and Octane.
 */

int	power_intr(void *);

struct cfdriver power_cd = {
	NULL, "power", DV_DULL
};

#if NPOWER_MACEBUS > 0

#include <sgi/localbus/macebusvar.h>

void	power_macebus_attach(struct device *, struct device *, void *);
int	power_macebus_match(struct device *, void *, void *);

struct cfattach power_macebus_ca = {
	sizeof(struct device), power_macebus_match, power_macebus_attach
};

int
power_macebus_match(struct device *parent, void *match, void *aux)
{
	return (1);
}

void
power_macebus_attach(struct device *parent, struct device *self, void *aux)
{
	struct macebus_attach_args *maa = aux;

	/* Establish interrupt handler. */
	if (macebus_intr_establish(maa->maa_intr, maa->maa_mace_intr,
	    IST_EDGE, IPL_TTY, power_intr, self, self->dv_xname))
		printf("\n");
	else
		printf(": unable to establish interrupt!\n");
}

#endif

#if NPOWER_MAINBUS > 0

#include <sgi/xbow/xbow.h>
#include <sgi/xbow/xheartreg.h>

void	power_mainbus_attach(struct device *, struct device *, void *);
int	power_mainbus_match(struct device *, void *, void *);
int	power_mainbus_intr(void *);

struct cfattach power_mainbus_ca = {
	sizeof(struct device), power_mainbus_match, power_mainbus_attach
};

int
power_mainbus_match(struct device *parent, void *match, void *aux)
{
	struct mainbus_attach_args *maa = aux;

	if (strcmp(maa->maa_name, power_cd.cd_name) != 0)
		return 0;

	return sys_config.system_type == SGI_OCTANE ? 1 : 0;
}

void
power_mainbus_attach(struct device *parent, struct device *self, void *aux)
{
	/* Establish interrupt handler. */
	if (xbow_intr_establish(power_mainbus_intr, self, HEART_ISR_POWER,
	    IPL_TTY, self->dv_xname, NULL) != 0) {
		printf(": unable to establish interrupt!\n");
		return;
	}

	printf("\n");
}

int
power_mainbus_intr(void *v)
{
	/*
	 * Clear interrupt condition; debouncing the kickstart bit will not
	 * suffice.
	 */
	xbow_intr_clear(HEART_ISR_POWER);

	return power_intr(v);
}

#endif

int
power_intr(void *unused)
{
	extern int allowpowerdown;
	int val;

	/* 
	 * Prevent further interrupts by clearing the kickstart flag
	 * in the DS1687's extended control register.
	 */
	val = dsrtc_register_read(DS1687_EXT_CTRL);
	if (val == -1)
		return 1;		/* no rtc attached */

	/* debounce condition */
	dsrtc_register_write(DS1687_EXT_CTRL, val & ~DS1687_KICKSTART);

	if (allowpowerdown == 1) {
		allowpowerdown = 0;
		prsignal(initprocess, SIGUSR2);
	}

	return 1;
}
@


1.14
log
@machdep.kbdreset enables a shutdown by Ctrl-Alt-Del on amd64 and
i386.  Stop abusing it on other archs for controling a shutdown by
pressing the soft power button:

* Add a MI sysctl hw.allowpowerdown; if set to 1 (the default) it
  allows a power button shutdown.
* Make acpi(4)/acpibtn(4) honor hw.allowpowerdown.
* Switch the various power button intercepts on landisk, sgi, sparc64
  and zaurus over to hw.allowpowerdown.
* Garbage collect the machdep.kbdreset sysctl on all archs other than
  amd64 and i386.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.13 2009/11/25 11:23:29 miod Exp $	*/
d145 1
a145 1
		psignal(initproc, SIGUSR2);
@


1.13
log
@Allow xbow_intr_establish() callers to provide optional storage for the
struct intrhand, instead of having it malloc()'ed.
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.12 2009/10/26 20:14:42 miod Exp $	*/
d129 1
a129 1
	extern int kbd_reset;
d143 2
a144 2
	if (kbd_reset == 1) {
		kbd_reset = 0;
@


1.12
log
@Rename struct confargs to struct mainbus_attach_args for consistency and also
to prevent further abuse of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.11 2009/10/26 18:13:34 miod Exp $	*/
d104 1
a104 1
	    IPL_TTY, self->dv_xname) != 0) {
@


1.11
log
@Add support for the Octane power button to power(4). Took me a while to
figure out how the interrupt was routed from xbridge to xheart... (it bypasses
the regular `have xbridge send a xio interrupt packet' mechanism)
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.10 2009/10/26 18:00:06 miod Exp $	*/
d91 1
a91 1
	struct confargs *ca = aux;
d93 1
a93 1
	if (strcmp(ca->ca_name, power_cd.cd_name) != 0)
@


1.10
log
@Better crime/mace interrupt handling; interrupt information is no longer
specified in the kernel configuration file, but is provided by macebus(4)
as part of the  child device attachment args, and provide both crime and
mace interrupt bitmasks; this allows us to only really enable interrupt
sources we care about, and to avoid invoking interrupt handler we don't need
to for the few mace interrupts multiplexed at the crime level.
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.9 2009/05/16 16:04:11 deraadt Exp $	*/
d25 3
a28 2

#include <machine/autoconf.h>
d31 1
a31 2
#include <sgi/localbus/macebus.h>
#include <sgi/localbus/macebusvar.h>
d34 1
a34 1
 * Power button driver for the SGI O2.
a36 8
struct power_softc {
	struct device		sc_dev;
	bus_space_tag_t		sc_st;
	bus_space_handle_t	sc_sh;
};

void	power_attach(struct device *, struct device *, void *);
int	power_match(struct device *, void *, void *);
d43 11
d55 1
a55 1
power_match(struct device *parent, void *match, void *aux)
a59 4
struct cfattach power_ca = {
	sizeof(struct power_softc), power_match, power_attach
};

d61 1
a61 1
power_attach(struct device *parent, struct device *self, void *aux)
a62 1
	struct power_softc *sc = (void *)self;
a63 1
	extern bus_space_handle_t mace_h;
a64 8
	sc->sc_st = maa->maa_iot;

	/* Map subregion to ISA control registers. */
	if (bus_space_subregion(sc->sc_st, mace_h, 0, 0x80, &sc->sc_sh)) {
		printf(": failed to map ISA control registers!\n");
		return;
	}
 	
d67 1
a67 1
	    IST_EDGE, IPL_TTY, power_intr, sc, sc->sc_dev.dv_xname))
d73 53
d139 2
@


1.9
log
@need that include file...
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.8 2009/05/15 23:02:23 miod Exp $	*/
d31 1
a45 1
int	power_intr_macebus(void *);
d65 1
a65 1
	struct confargs *ca = aux;
d68 1
a68 1
	sc->sc_st = ca->ca_iot;
d77 2
a78 2
	if (macebus_intr_establish(NULL, ca->ca_intr, IST_EDGE, IPL_TTY,
	    power_intr_macebus, sc, sc->sc_dev.dv_xname))
a81 14
}

int
power_intr_macebus(void *arg)
{
	struct power_softc *sc = (void *)arg;
	u_int64_t val;

	/* Check to see if this interrupt is for us. */
	val = bus_space_read_8(sc->sc_st, sc->sc_sh, MACE_ISA_INT_STAT);
	if (val & MACE_ISA_INT_RTC)
		return power_intr(arg);

	return 0;
@


1.8
log
@TOD clock support for IOC3 flavours with DS174x chips (which are rebadged
MK48Txx). Entangled with preliminary changes which will hopefully eventually
lead to power(4) attaching on IP30 (but not finished yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.7 2008/09/16 16:38:25 jasper Exp $	*/
d28 1
@


1.7
log
@- remove some unneeded headers

with and ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.6 2008/02/21 11:42:23 jsing Exp $	*/
a38 1
	bus_space_handle_t	sc_isash;
d41 1
d43 2
a44 8
void	power_attach(struct device *, struct device *, void *);
int	power_intr(void *aux);

struct cfattach power_ca = {
	sizeof(struct power_softc),
	power_match,
	power_attach
};
d56 4
a64 1
	extern bus_space_handle_t clock_h;
a68 6
	/* Map subregion to clock address space. */
	if (bus_space_subregion(sc->sc_st, clock_h, 0, 0x50, &sc->sc_sh)) {
		printf(": failed to map clock address space!\n");
		return;
	}

d70 1
a70 1
	if (bus_space_subregion(sc->sc_st, mace_h, 0, 0x80, &sc->sc_isash)) {
d77 1
a77 1
	    power_intr, sc, sc->sc_dev.dv_xname))
d84 1
a84 1
power_intr(void *arg)
a87 1
	extern int kbd_reset;
d90 3
a92 2
	val = bus_space_read_8(sc->sc_st, sc->sc_isash, MACE_ISA_INT_STAT);
	if (val & MACE_ISA_INT_RTC) {
d94 2
a95 12
		/* 
		 * Prevent further interrupts by clearing the kickstart flag
		 * in the DS1687's extended control register.
		 */
		val = bus_space_read_1(sc->sc_st, sc->sc_sh, DS1687_EXT_CTRL);
		bus_space_write_1(sc->sc_st, sc->sc_sh, DS1687_EXT_CTRL,
		    val & ~DS1687_KICKSTART);

		if (kbd_reset == 1) {
			kbd_reset = 0;
			psignal(initproc, SIGUSR2);
		}
d97 18
a114 1
		return (1);
d117 1
a117 1
	return (0);
a118 1

@


1.6
log
@There's no need to print the IRQ now that we have direct configuration.
Cleanup the interrupt establishment code a little whilst we're here.

ok miod@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.4 2007/12/27 03:00:51 jsing Exp $	*/
a18 1
#include <sys/types.h>
a20 1
#include <sys/kernel.h>
a21 1
#include <sys/conf.h>
a26 1
#include <machine/bus.h>
a28 4
#include <mips64/archtype.h>
#include <mips64/dev/clockvar.h>

#include <sgi/localbus/crimebus.h>
@


1.5
log
@Completely overhault attachment rules on sgi. No more indirect configuration
inherited from OpenBSD/arc machines with ISA bus; mainbus children match on
device name and other hierarchies match on simplified locators.
As a bonus, attachment lines in dmesg will now print their locators.

ok jsing@@
@
text
@d40 1
a40 1
 * Power button driver for the SGI O2
a74 1
	int sc_irq;
a76 1
	void *rv = NULL;
a78 3
	sc_irq = ca->ca_intr;

	printf(": ");
d82 1
a82 1
		printf("failed to map clock address space!\n");
d88 1
a88 1
		printf("failed to map ISA control registers!\n");
d92 4
a95 5
	/* Establish the interrupt. */
	rv = macebus_intr_establish(NULL, sc_irq, IST_EDGE, IPL_TTY, power_intr,
	    sc, sc->sc_dev.dv_xname);
	if (rv == NULL)
		printf("unable to establish interrupt\n");
d97 1
a97 1
		printf("using irq %d\n", sc_irq);
@


1.4
log
@power(4) can now make use of the DS1687 register definitions header file.

ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.3 2007/12/18 09:42:00 jasper Exp $	*/
d67 1
a67 7
	struct confargs *ca = aux;

	/* Power button only on SGI_O2, for now that is */
	if (ca->ca_sys == SGI_O2)
		return (1);

	return (0);
@


1.3
log
@move variable declarations where they belong

prodded by and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.2 2007/12/18 08:48:22 jasper Exp $	*/
d28 2
a41 3

#define	DS1687_EXT_CTRL		0x4a
#define	DS1687_KICKSTART	0x01
@


1.2
log
@- powerbutton -> power button
- minor knf nit (suggested by miod@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: power.c,v 1.1 2007/12/18 08:29:02 jasper Exp $	*/
d83 2
a86 2
	printf(": ");

d90 2
a92 1
	extern bus_space_handle_t clock_h;
a98 1
	extern bus_space_handle_t mace_h;
@


1.1
log
@add power(4), a driver for the power button found on SGI O2's.
when machdep.kbdreset is set, and the correct interrupt is fired,
the machine gets shut down.

with help from and ok jsing@@, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
 * Powerbutton driver for the SGI O2
d70 1
a70 1
	/* Powerbutton only on SGI_O2, for now that is */
d137 1
a137 1
		return(1);
d140 1
a140 1
	return(0);
@

