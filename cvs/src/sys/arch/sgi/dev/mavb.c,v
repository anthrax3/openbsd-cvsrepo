head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.4
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.18.0.6
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.13.0.10
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.8
	OPENBSD_5_0:1.13.0.6
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.4
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.8
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.6
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.4
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.20
date	2016.09.19.06.46.43;	author ratchov;	state Exp;
branches;
next	1.19;
commitid	qGgYgJTgEFuAoGj4;

1.19
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.18;
commitid	pi1a9KN0itEngOc4;

1.18
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.17;
commitid	RaOGL5SyOGOZylwx;

1.17
date	2014.05.19.21.18.42;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2013.06.21.09.34.06;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2013.05.15.08.29.23;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2012.10.03.22.46.09;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.12;

1.12
date	2010.07.02.03.24.50;	author blambert;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.18.21.13.17;	author jakemsr;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.26.18.00.06;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.8;

1.8
date	2008.02.20.18.46.20;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.20.14.17.05;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.15.13.05.14;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.24.20.44.37;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.24.20.40.16;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.02.19.25.41;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.02.18.55.56;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.02.00.25.41;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Remove unused getdev() audio driver functions.
@
text
@/*	$OpenBSD: mavb.c,v 1.19 2016/09/14 06:12:19 ratchov Exp $	*/

/*
 * Copyright (c) 2005 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/timeout.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>

#include <sgi/localbus/macebus.h>
#include <sgi/localbus/macebusvar.h>
#include <sgi/dev/mavbreg.h>

#include <dev/ic/ad1843reg.h>

#undef MAVB_DEBUG

#ifdef MAVB_DEBUG
#define DPRINTF(l,x)	do { if (mavb_debug & (l)) printf x; } while (0)
#define MAVB_DEBUG_INTR		0x0100
int mavb_debug = ~MAVB_DEBUG_INTR;
#else
#define DPRINTF(l,x)	/* nothing */
#endif

/* Repeat delays for volume buttons.  */
#define MAVB_VOLUME_BUTTON_REPEAT_DEL1	400	/* 400ms to start repeating */
#define MAVB_VOLUME_BUTTON_REPEAT_DELN  100	/* 100ms between repeats */

/* XXX We need access to some of the MACE ISA registers.  */
#define MAVB_ISA_NREGS				0x20

#define MAVB_ISA_RING_SIZE	0x4000 /* Mace ISA DMA ring size. */
#define MAVB_CHAN_RING_SIZE	0x1000 /* DMA buffer size per channel. */
#define MAVB_CHAN_INTR_SIZE	0x0800 /* Interrupt on 50% buffer transfer. */
#define MAVB_CHAN_CHUNK_SIZE	0x0400 /* Move data in 25% buffer chunks. */


/*
 * AD1843 Mixer.
 */

enum {
	AD1843_RECORD_CLASS,
	AD1843_ADC_SOURCE,	/* ADC Source Select */
	AD1843_ADC_GAIN,	/* ADC Input Gain */
	AD1843_ADC_MIC_GAIN,	/* ADC Mic Input Gain */

	AD1843_INPUT_CLASS,
	AD1843_DAC1_GAIN,	/* DAC1 Analog/Digital Gain/Attenuation */
	AD1843_DAC1_MUTE,	/* DAC1 Analog Mute */
	AD1843_DAC2_GAIN,	/* DAC2 Mix Gain */
	AD1843_AUX1_GAIN,	/* Auxilliary 1 Mix Gain */
	AD1843_AUX2_GAIN,	/* Auxilliary 2 Mix Gain */
	AD1843_AUX3_GAIN,	/* Auxilliary 3 Mix Gain */
	AD1843_MIC_GAIN,	/* Microphone Mix Gain */
	AD1843_MONO_GAIN,	/* Mono Mix Gain */
	AD1843_DAC2_MUTE,	/* DAC2 Mix Mute */
	AD1843_AUX1_MUTE,	/* Auxilliary 1 Mix Mute */
	AD1843_AUX2_MUTE,	/* Auxilliary 2 Mix Mute */
	AD1843_AUX3_MUTE,	/* Auxilliary 3 Mix Mute */
	AD1843_MIC_MUTE,	/* Microphone Mix Mute */
	AD1843_MONO_MUTE,	/* Mono Mix Mute */
	AD1843_SUM_MUTE,	/* Sum Mute */

	AD1843_OUTPUT_CLASS,
	AD1843_MNO_MUTE,	/* Mono Output Mute */
	AD1843_HPO_MUTE		/* Headphone Output Mute */
};

/* ADC Source Select.  The order matches the hardware bits.  */
const char *ad1843_source[] = {
	AudioNline,
	AudioNmicrophone,
	AudioNaux "1",
	AudioNaux "2",
	AudioNaux "3",
	AudioNmono,
	AudioNdac "1",
	AudioNdac "2"
};

/* Mix Control.  The order matches the hardware register numbering.  */
const char *ad1843_input[] = {
	AudioNdac "2",		/* AD1843_DAC2__TO_MIXER */
	AudioNaux "1",
	AudioNaux "2",
	AudioNaux "3",
	AudioNmicrophone,
	AudioNmono		/* AD1843_MISC_SETTINGS */
};

struct mavb_chan {
	caddr_t hw_start;
	caddr_t sw_start;
	caddr_t sw_end;
	caddr_t sw_cur;
	void (*intr)(void *);
	void *intrarg;
	u_long rate;
	u_int format;
	int blksize;
};

struct mavb_softc {
	struct device sc_dev;
	bus_space_tag_t sc_st;
	bus_space_handle_t sc_sh;
	bus_dma_tag_t sc_dmat;
	bus_dmamap_t sc_dmamap;

	/* XXX We need access to some of the MACE ISA registers.  */
	bus_space_handle_t sc_isash;

	caddr_t sc_ring;

	struct mavb_chan play;
	struct mavb_chan rec;

	struct timeout sc_volume_button_to;
};

typedef u_long ad1843_addr_t;

u_int16_t ad1843_reg_read(struct mavb_softc *, ad1843_addr_t);
u_int16_t ad1843_reg_write(struct mavb_softc *, ad1843_addr_t, u_int16_t);
void ad1843_dump_regs(struct mavb_softc *);

int mavb_match(struct device *, void *, void *);
void mavb_attach(struct device *, struct device *, void *);

struct cfattach mavb_ca = {
	sizeof(struct mavb_softc), mavb_match, mavb_attach
};

struct cfdriver mavb_cd = {
	NULL, "mavb", DV_DULL
};

int mavb_open(void *, int);
void mavb_close(void *);
int mavb_set_params(void *, int, int, struct audio_params *,
		    struct audio_params *);
int mavb_round_blocksize(void *hdl, int bs);
int mavb_halt_output(void *);
int mavb_halt_input(void *);
int mavb_set_port(void *, struct mixer_ctrl *);
int mavb_get_port(void *, struct mixer_ctrl *);
int mavb_query_devinfo(void *, struct mixer_devinfo *);
int mavb_get_props(void *);
int mavb_trigger_output(void *, void *, void *, int, void (*)(void *),
			void *, struct audio_params *);
int mavb_trigger_input(void *, void *, void *, int, void (*)(void *),
		       void *, struct audio_params *);

struct audio_hw_if mavb_sa_hw_if = {
	mavb_open,
	mavb_close,
	mavb_set_params,
	mavb_round_blocksize,
	0,
	0,
	0,
	0,
	0,
	mavb_halt_output,
	mavb_halt_input,
	0,
	0,
	mavb_set_port,
	mavb_get_port,
	mavb_query_devinfo,
	0,
	0,
	0,
	mavb_get_props,
	mavb_trigger_output,
	mavb_trigger_input
};

int
mavb_open(void *hdl, int flags)
{
	return (0);
}

void
mavb_close(void *hdl)
{
}

static int
mavb_set_play_rate(struct mavb_softc *sc, u_long sample_rate)
{
	if (sample_rate < 4000 || sample_rate > 48000)
		return (EINVAL);

	if (sc->play.rate != sample_rate) {
		ad1843_reg_write(sc, AD1843_CLOCK2_SAMPLE_RATE, sample_rate);
		sc->play.rate = sample_rate;
	}
	return (0);
}

static int
mavb_set_rec_rate(struct mavb_softc *sc, u_long sample_rate)
{
	if (sample_rate < 4000 || sample_rate > 48000)
		return (EINVAL);

	if (sc->rec.rate != sample_rate) {
		ad1843_reg_write(sc, AD1843_CLOCK1_SAMPLE_RATE, sample_rate);
		sc->rec.rate = sample_rate;
	}
	return (0);
}

static int
mavb_get_format(u_int encoding, u_int *format)
{
	switch(encoding) {
	case AUDIO_ENCODING_ULINEAR_BE:
		*format = AD1843_PCM8;
		break;
	case AUDIO_ENCODING_SLINEAR_BE:
		*format = AD1843_PCM16;
		break;
	case AUDIO_ENCODING_ULAW:
		*format = AD1843_ULAW;
		break;
	case AUDIO_ENCODING_ALAW:
		*format = AD1843_ALAW;
		break;
	default:
		return (EINVAL);
	}
	return (0);
}

static int
mavb_set_play_format(struct mavb_softc *sc, u_int encoding)
{
	u_int16_t value;
	u_int format;
	int err;

	err = mavb_get_format(encoding, &format);
	if (err)
		return (err);

	if (sc->play.format != format) {
		value = ad1843_reg_read(sc, AD1843_SERIAL_INTERFACE);
		value &= ~AD1843_DA1F_MASK;
		value |= (format << AD1843_DA1F_SHIFT);
		ad1843_reg_write(sc, AD1843_SERIAL_INTERFACE, value);
		sc->play.format = format;
	}
	return (0);
}

static int
mavb_set_rec_format(struct mavb_softc *sc, u_int encoding)
{
	u_int16_t value;
	u_int format;
	int err;

	err = mavb_get_format(encoding, &format);
	if (err)
		return (err);

	if (sc->rec.format != format) {
		value = ad1843_reg_read(sc, AD1843_SERIAL_INTERFACE);
		value &= ~(AD1843_ADRF_MASK | AD1843_ADLF_MASK);
		value |= (format << AD1843_ADRF_SHIFT) |
		    (format << AD1843_ADLF_SHIFT);
		ad1843_reg_write(sc, AD1843_SERIAL_INTERFACE, value);
		sc->rec.format = format;
	}
	return (0);
}

int
mavb_set_params(void *hdl, int setmode, int usemode,
    struct audio_params *play, struct audio_params *rec)
{
	struct mavb_softc *sc = (struct mavb_softc *)hdl;
	int error;

	DPRINTF(1, ("%s: mavb_set_params: sample=%ld precision=%d "
	    "channels=%d\n", sc->sc_dev.dv_xname, play->sample_rate,
	    play->precision, play->channels));

	if (setmode & AUMODE_PLAY) {
		play->encoding = AUDIO_ENCODING_SLINEAR_BE;
		play->channels = 2;
		play->precision = 24;
		play->bps = AUDIO_BPS(play->precision);
		play->msb = 0;
		error = mavb_set_play_rate(sc, play->sample_rate);
		if (error)
			return (error);

		error = mavb_set_play_format(sc, play->encoding);
		if (error)
			return (error);

	}

	if (setmode & AUMODE_RECORD) {
		rec->encoding = AUDIO_ENCODING_SLINEAR_BE;
		rec->channels = 2;
		rec->precision = 24;
		rec->bps = AUDIO_BPS(rec->precision);
		rec->msb = 0;

		error = mavb_set_rec_rate(sc, rec->sample_rate);
		if (error)
			return (error);

		error = mavb_set_rec_format(sc, rec->encoding);
		if (error)
			return (error);
	}

	return (0);
}

int
mavb_round_blocksize(void *hdl, int bs)
{
	if (bs == 0)
		bs = MAVB_CHAN_INTR_SIZE;
	else
		bs = (bs + MAVB_CHAN_INTR_SIZE - 1) &
		    ~(MAVB_CHAN_INTR_SIZE - 1);
	return (bs);
}

int
mavb_halt_output(void *hdl)
{
	struct mavb_softc *sc = (struct mavb_softc *)hdl;

	DPRINTF(1, ("%s: mavb_halt_output called\n", sc->sc_dev.dv_xname));
	mtx_enter(&audio_lock);
	bus_space_write_8(sc->sc_st, sc->sc_sh, MAVB_CHANNEL2_CONTROL, 0);
	mtx_leave(&audio_lock);
	return (0);
}

int
mavb_halt_input(void *hdl)
{
	struct mavb_softc *sc = (struct mavb_softc *)hdl;

	DPRINTF(1, ("%s: mavb_halt_input called\n", sc->sc_dev.dv_xname));
	mtx_enter(&audio_lock);
	bus_space_write_8(sc->sc_st, sc->sc_sh, MAVB_CHANNEL1_CONTROL, 0);
	mtx_leave(&audio_lock);
	return (0);
}

int
mavb_set_port(void *hdl, struct mixer_ctrl *mc)
{
	struct mavb_softc *sc = (struct mavb_softc *)hdl;
	u_char left, right;
	ad1843_addr_t reg;
	u_int16_t value;

	DPRINTF(1, ("%s: mavb_set_port: dev=%d\n", sc->sc_dev.dv_xname,
	    mc->dev));

	switch (mc->dev) {
	case AD1843_ADC_SOURCE:
		value = ad1843_reg_read(sc, AD1843_ADC_SOURCE_GAIN);
		value &= ~(AD1843_LSS_MASK | AD1843_RSS_MASK);
		value |= ((mc->un.ord << AD1843_LSS_SHIFT) & AD1843_LSS_MASK);
		value |= ((mc->un.ord << AD1843_RSS_SHIFT) & AD1843_RSS_MASK);
		ad1843_reg_write(sc, AD1843_ADC_SOURCE_GAIN, value);
		break;
	case AD1843_ADC_GAIN:
		left = mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
		right = mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
		value = ad1843_reg_read(sc, AD1843_ADC_SOURCE_GAIN);
		value &= ~(AD1843_LIG_MASK | AD1843_RIG_MASK);
		value |= ((left >> 4) << AD1843_LIG_SHIFT);
		value |= ((right >> 4) << AD1843_RIG_SHIFT);
		ad1843_reg_write(sc, AD1843_ADC_SOURCE_GAIN, value);
		break;
	case AD1843_ADC_MIC_GAIN:
		value = ad1843_reg_read(sc, AD1843_ADC_SOURCE_GAIN);
		if (mc->un.ord == 0)
			value &= ~(AD1843_LMGE | AD1843_RMGE);
		else
			value |= (AD1843_LMGE | AD1843_RMGE);
		ad1843_reg_write(sc, AD1843_ADC_SOURCE_GAIN, value);
		break;

	case AD1843_DAC1_GAIN:
		left = AUDIO_MAX_GAIN -
		    mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
		right = AUDIO_MAX_GAIN -
                    mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
		value = ad1843_reg_read(sc, AD1843_DAC1_ANALOG_GAIN);
		value &= ~(AD1843_LDA1G_MASK | AD1843_RDA1G_MASK);
		value |= ((left >> 2) << AD1843_LDA1G_SHIFT);
		value |= ((right >> 2) << AD1843_RDA1G_SHIFT);
		ad1843_reg_write(sc, AD1843_DAC1_ANALOG_GAIN, value);
		break;
	case AD1843_DAC1_MUTE:
		value = ad1843_reg_read(sc, AD1843_DAC1_ANALOG_GAIN);
		if (mc->un.ord == 0)
			value &= ~(AD1843_LDA1GM | AD1843_RDA1GM);
		else
			value |= (AD1843_LDA1GM | AD1843_RDA1GM);
		ad1843_reg_write(sc, AD1843_DAC1_ANALOG_GAIN, value);
		break;

	case AD1843_DAC2_GAIN:
	case AD1843_AUX1_GAIN:
	case AD1843_AUX2_GAIN:
	case AD1843_AUX3_GAIN:
	case AD1843_MIC_GAIN:
		left = AUDIO_MAX_GAIN -
		    mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
		right = AUDIO_MAX_GAIN -
                    mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
		reg = AD1843_DAC2_TO_MIXER + mc->dev - AD1843_DAC2_GAIN;
		value = ad1843_reg_read(sc, reg);
		value &= ~(AD1843_LD2M_MASK | AD1843_RD2M_MASK);
		value |= ((left >> 3) << AD1843_LD2M_SHIFT);
		value |= ((right >> 3) << AD1843_RD2M_SHIFT);
		ad1843_reg_write(sc, reg, value);
		break;
	case AD1843_MONO_GAIN:
		left = AUDIO_MAX_GAIN -
		    mc->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		value = ad1843_reg_read(sc, AD1843_MISC_SETTINGS);
		value &= ~AD1843_MNM_MASK;
		value |= ((left >> 3) << AD1843_MNM_SHIFT);
		ad1843_reg_write(sc, AD1843_MISC_SETTINGS, value);
		break;
	case AD1843_DAC2_MUTE:
	case AD1843_AUX1_MUTE:
	case AD1843_AUX2_MUTE:
	case AD1843_AUX3_MUTE:
	case AD1843_MIC_MUTE:
	case AD1843_MONO_MUTE:	/* matches left channel */
		reg = AD1843_DAC2_TO_MIXER + mc->dev - AD1843_DAC2_MUTE;
		value = ad1843_reg_read(sc, reg);
		if (mc->un.ord == 0)
			value &= ~(AD1843_LD2MM | AD1843_RD2MM);
		else
			value |= (AD1843_LD2MM | AD1843_RD2MM);
		ad1843_reg_write(sc, reg, value);
		break;

	case AD1843_SUM_MUTE:
		value = ad1843_reg_read(sc, AD1843_MISC_SETTINGS);
		if (mc->un.ord == 0)
			value &= ~AD1843_SUMM;
		else
			value |= AD1843_SUMM;
		ad1843_reg_write(sc, AD1843_MISC_SETTINGS, value);
		break;
		
	case AD1843_MNO_MUTE:
		value = ad1843_reg_read(sc, AD1843_MISC_SETTINGS);
		if (mc->un.ord == 0)
			value &= ~AD1843_MNOM;
		else
			value |= AD1843_MNOM;
		ad1843_reg_write(sc, AD1843_MISC_SETTINGS, value);
		break;
		
	case AD1843_HPO_MUTE:
		value = ad1843_reg_read(sc, AD1843_MISC_SETTINGS);
		if (mc->un.ord == 0)
			value &= ~AD1843_HPOM;
		else
			value |= AD1843_HPOM;
		ad1843_reg_write(sc, AD1843_MISC_SETTINGS, value);
		value = ad1843_reg_read(sc, AD1843_MISC_SETTINGS);
		break;

	default:
		return (EINVAL);
	}

	return (0);
}

int
mavb_get_port(void *hdl, struct mixer_ctrl *mc)
{
	struct mavb_softc *sc = (struct mavb_softc *)hdl;
	u_char left, right;
	ad1843_addr_t reg;
	u_int16_t value;

	DPRINTF(1, ("%s: mavb_get_port: dev=%d\n", sc->sc_dev.dv_xname,
	    mc->dev));

	switch (mc->dev) {
	case AD1843_ADC_SOURCE:
		value = ad1843_reg_read(sc, AD1843_ADC_SOURCE_GAIN);
		mc->un.ord = (value & AD1843_LSS_MASK) >> AD1843_LSS_SHIFT;
		break;
	case AD1843_ADC_GAIN:
		value = ad1843_reg_read(sc, AD1843_ADC_SOURCE_GAIN);
		left = (value & AD1843_LIG_MASK) >> AD1843_LIG_SHIFT;
		right = (value & AD1843_RIG_MASK) >> AD1843_RIG_SHIFT;
		mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
		    (left << 4) | left;
		mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
		    (right << 4) | right;
		break;
	case AD1843_ADC_MIC_GAIN:
		value = ad1843_reg_read(sc, AD1843_ADC_SOURCE_GAIN);
		mc->un.ord = (value & AD1843_LMGE) ? 1 : 0;
		break;

	case AD1843_DAC1_GAIN:
		value = ad1843_reg_read(sc, AD1843_DAC1_ANALOG_GAIN);
		left = (value & AD1843_LDA1G_MASK) >> AD1843_LDA1G_SHIFT;
		right = (value & AD1843_RDA1G_MASK) >> AD1843_RDA1G_SHIFT;
		mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
		    AUDIO_MAX_GAIN - (left << 2);
		mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
		    AUDIO_MAX_GAIN - (right << 2);
		break;
	case AD1843_DAC1_MUTE:
		value = ad1843_reg_read(sc, AD1843_DAC1_ANALOG_GAIN);
		mc->un.ord = (value & AD1843_LDA1GM) ? 1 : 0;
		break;

	case AD1843_DAC2_GAIN:
	case AD1843_AUX1_GAIN:
	case AD1843_AUX2_GAIN:
	case AD1843_AUX3_GAIN:
	case AD1843_MIC_GAIN:
		reg = AD1843_DAC2_TO_MIXER + mc->dev - AD1843_DAC2_GAIN;
		value = ad1843_reg_read(sc, reg);
		left = (value & AD1843_LD2M_MASK) >> AD1843_LD2M_SHIFT;
		right = (value & AD1843_RD2M_MASK) >> AD1843_RD2M_SHIFT;
		mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
		    AUDIO_MAX_GAIN - (left << 3);
		mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
		    AUDIO_MAX_GAIN - (right << 3);
		break;
	case AD1843_MONO_GAIN:
		if (mc->un.value.num_channels != 1)
			return (EINVAL);

		value = ad1843_reg_read(sc, AD1843_MISC_SETTINGS);
		left = (value & AD1843_MNM_MASK) >> AD1843_MNM_SHIFT;
		mc->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
		    AUDIO_MAX_GAIN - (left << 3);
		break;
	case AD1843_DAC2_MUTE:
	case AD1843_AUX1_MUTE:
	case AD1843_AUX2_MUTE:
	case AD1843_AUX3_MUTE:
	case AD1843_MIC_MUTE:
	case AD1843_MONO_MUTE:	/* matches left channel */
		reg = AD1843_DAC2_TO_MIXER + mc->dev - AD1843_DAC2_MUTE;
		value = ad1843_reg_read(sc, reg);
		mc->un.ord = (value & AD1843_LD2MM) ? 1 : 0;
		break;

	case AD1843_SUM_MUTE:
		value = ad1843_reg_read(sc, AD1843_MISC_SETTINGS);
		mc->un.ord = (value & AD1843_SUMM) ? 1 : 0;
		break;
		
	case AD1843_MNO_MUTE:
		value = ad1843_reg_read(sc, AD1843_MISC_SETTINGS);
		mc->un.ord = (value & AD1843_MNOM) ? 1 : 0;
		break;
		
	case AD1843_HPO_MUTE:
		value = ad1843_reg_read(sc, AD1843_MISC_SETTINGS);
		mc->un.ord = (value & AD1843_HPOM) ? 1 : 0;
		break;
		
	default:
		return (EINVAL);
	}

	return (0);
}

int
mavb_query_devinfo(void *hdl, struct mixer_devinfo *di)
{
	int i;

	di->prev = di->next = AUDIO_MIXER_LAST;

	switch (di->index) {
	case AD1843_RECORD_CLASS:
		di->type = AUDIO_MIXER_CLASS;
		di->mixer_class = AD1843_RECORD_CLASS;
		strlcpy(di->label.name, AudioCrecord, sizeof di->label.name);
		break;

	case AD1843_ADC_SOURCE:
		di->type = AUDIO_MIXER_ENUM;
		di->mixer_class = AD1843_RECORD_CLASS;
		di->next = AD1843_ADC_GAIN;
		strlcpy(di->label.name, AudioNsource, sizeof di->label.name);
		di->un.e.num_mem =
			sizeof ad1843_source / sizeof ad1843_source[1];
		for (i = 0; i < di->un.e.num_mem; i++) {
			strlcpy(di->un.e.member[i].label.name,
                            ad1843_source[i],
			    sizeof di->un.e.member[0].label.name);
			di->un.e.member[i].ord = i;
		}
		break;
	case AD1843_ADC_GAIN:
		di->type = AUDIO_MIXER_VALUE;
		di->mixer_class = AD1843_RECORD_CLASS;
		di->prev = AD1843_ADC_SOURCE;
		strlcpy(di->label.name, AudioNvolume, sizeof di->label.name);
		di->un.v.num_channels = 2;
		strlcpy(di->un.v.units.name, AudioNvolume,
		    sizeof di->un.v.units.name);
		break;
	case AD1843_ADC_MIC_GAIN:
		di->type = AUDIO_MIXER_ENUM;
		di->mixer_class = AD1843_RECORD_CLASS;
		strlcpy(di->label.name, AudioNmicrophone "." AudioNpreamp,
		    sizeof di->label.name);
		di->un.e.num_mem = 2;
		strlcpy(di->un.e.member[0].label.name, AudioNoff,
		    sizeof di->un.e.member[0].label.name);
		di->un.e.member[0].ord = 0;
		strlcpy(di->un.e.member[1].label.name, AudioNon,
		    sizeof di->un.e.member[1].label.name);
		di->un.e.member[1].ord = 1;
		break;

	case AD1843_INPUT_CLASS:
		di->type = AUDIO_MIXER_CLASS;
		di->mixer_class = AD1843_INPUT_CLASS;
		strlcpy(di->label.name, AudioCinputs, sizeof di->label.name);
		break;

	case AD1843_DAC1_GAIN:
		di->type = AUDIO_MIXER_VALUE;
		di->mixer_class = AD1843_INPUT_CLASS;
		di->next = AD1843_DAC1_MUTE;
		strlcpy(di->label.name, AudioNdac "1", sizeof di->label.name);
		di->un.v.num_channels = 2;
		strlcpy(di->un.v.units.name, AudioNvolume,
		    sizeof di->un.v.units.name);
		break;
	case AD1843_DAC1_MUTE:
		di->type = AUDIO_MIXER_ENUM;
		di->mixer_class = AD1843_INPUT_CLASS;
		di->prev = AD1843_DAC1_GAIN;
		strlcpy(di->label.name, AudioNmute, sizeof di->label.name);
		di->un.e.num_mem = 2;
		strlcpy(di->un.e.member[0].label.name, AudioNoff,
		    sizeof di->un.e.member[0].label.name);
		di->un.e.member[0].ord = 0;
		strlcpy(di->un.e.member[1].label.name, AudioNon,
		    sizeof di->un.e.member[1].label.name);
		di->un.e.member[1].ord = 1;
		break;

	case AD1843_DAC2_GAIN:
	case AD1843_AUX1_GAIN:
	case AD1843_AUX2_GAIN:
	case AD1843_AUX3_GAIN:
	case AD1843_MIC_GAIN:
	case AD1843_MONO_GAIN:
		di->type = AUDIO_MIXER_VALUE;
		di->mixer_class = AD1843_INPUT_CLASS;
		di->next = di->index + AD1843_DAC2_MUTE - AD1843_DAC2_GAIN;
		strlcpy(di->label.name,
                    ad1843_input[di->index - AD1843_DAC2_GAIN],
		    sizeof di->label.name);
		if (di->index == AD1843_MONO_GAIN)
			di->un.v.num_channels = 1;
		else
			di->un.v.num_channels = 2;
		strlcpy(di->un.v.units.name, AudioNvolume,
		    sizeof di->un.v.units.name);
		break;
	case AD1843_DAC2_MUTE:
	case AD1843_AUX1_MUTE:
	case AD1843_AUX2_MUTE:
	case AD1843_AUX3_MUTE:
	case AD1843_MIC_MUTE:
	case AD1843_MONO_MUTE:
		di->type = AUDIO_MIXER_ENUM;
		di->mixer_class = AD1843_INPUT_CLASS;
		di->prev = di->index + AD1843_DAC2_GAIN - AD1843_DAC2_MUTE;
		strlcpy(di->label.name, AudioNmute, sizeof di->label.name);
		di->un.e.num_mem = 2;
		strlcpy(di->un.e.member[0].label.name, AudioNoff,
		    sizeof di->un.e.member[0].label.name);
		di->un.e.member[0].ord = 0;
		strlcpy(di->un.e.member[1].label.name, AudioNon,
		    sizeof di->un.e.member[1].label.name);
		di->un.e.member[1].ord = 1;
		break;

	case AD1843_SUM_MUTE:
		di->type = AUDIO_MIXER_ENUM;
		di->mixer_class = AD1843_INPUT_CLASS;
		strlcpy(di->label.name, "sum." AudioNmute,
		    sizeof di->label.name);
		di->un.e.num_mem = 2;
		strlcpy(di->un.e.member[0].label.name, AudioNoff,
		    sizeof di->un.e.member[0].label.name);
		di->un.e.member[0].ord = 0;
		strlcpy(di->un.e.member[1].label.name, AudioNon,
		    sizeof di->un.e.member[1].label.name);
		di->un.e.member[1].ord = 1;
		break;

	case AD1843_OUTPUT_CLASS:
		di->type = AUDIO_MIXER_CLASS;
		di->mixer_class = AD1843_OUTPUT_CLASS;
		strlcpy(di->label.name, AudioCoutputs, sizeof di->label.name);
		break;

	case AD1843_MNO_MUTE:
		di->type = AUDIO_MIXER_ENUM;
		di->mixer_class = AD1843_OUTPUT_CLASS;
		strlcpy(di->label.name, AudioNmono "." AudioNmute,
		    sizeof di->label.name);
		di->un.e.num_mem = 2;
		strlcpy(di->un.e.member[0].label.name, AudioNoff,
		    sizeof di->un.e.member[0].label.name);
		di->un.e.member[0].ord = 0;
		strlcpy(di->un.e.member[1].label.name, AudioNon,
		    sizeof di->un.e.member[1].label.name);
		di->un.e.member[1].ord = 1;
		break;

	case AD1843_HPO_MUTE:
		di->type = AUDIO_MIXER_ENUM;
		di->mixer_class = AD1843_OUTPUT_CLASS;
		strlcpy(di->label.name, AudioNheadphone "." AudioNmute,
		    sizeof di->label.name);
		di->un.e.num_mem = 2;
		strlcpy(di->un.e.member[0].label.name, AudioNoff,
		    sizeof di->un.e.member[0].label.name);
		di->un.e.member[0].ord = 0;
		strlcpy(di->un.e.member[1].label.name, AudioNon,
		    sizeof di->un.e.member[1].label.name);
		di->un.e.member[1].ord = 1;
		break;

	default:
		return (EINVAL);
	}

	return (0);
}

int
mavb_get_props(void *hdl)
{
	return (AUDIO_PROP_FULLDUPLEX | AUDIO_PROP_INDEPENDENT);
}

static void
mavb_dma_output(struct mavb_softc *sc)
{
	bus_space_tag_t st = sc->sc_st;
	bus_space_handle_t sh = sc->sc_sh;
	u_int64_t write_ptr;
	caddr_t src, dst, end;
	int count;

	write_ptr = bus_space_read_8(st, sh, MAVB_CHANNEL2_WRITE_PTR);

	end = sc->play.hw_start + MAVB_CHAN_RING_SIZE;
	dst = sc->play.hw_start + write_ptr;
	src = sc->play.sw_cur;

	if (write_ptr % MAVB_CHAN_CHUNK_SIZE) {
		printf("%s: write_ptr=%lld\n", sc->sc_dev.dv_xname, write_ptr);
		return;
	}
	if ((src - sc->play.sw_start) % MAVB_CHAN_CHUNK_SIZE) {
		printf("%s: src=%ld\n", sc->sc_dev.dv_xname,
		    src - sc->play.sw_start);
		return;
	}

	count = MAVB_CHAN_INTR_SIZE / MAVB_CHAN_CHUNK_SIZE;
	while (--count >= 0) {
		memcpy(dst, src, MAVB_CHAN_CHUNK_SIZE);
		dst += MAVB_CHAN_CHUNK_SIZE;
		src += MAVB_CHAN_CHUNK_SIZE;
		if (dst >= end)
			dst = sc->play.hw_start;
		if (src >= sc->play.sw_end)
			src = sc->play.sw_start;
		if (!((src - sc->play.sw_start) % sc->play.blksize)) {
			if (sc->play.intr)
				sc->play.intr(sc->play.intrarg);
		}
	}
	write_ptr = dst - sc->play.hw_start;
	bus_space_write_8(st, sh, MAVB_CHANNEL2_WRITE_PTR, write_ptr);
	sc->play.sw_cur = src;
}

static void
mavb_dma_input(struct mavb_softc *sc)
{
	bus_space_tag_t st = sc->sc_st;
	bus_space_handle_t sh = sc->sc_sh;
	u_int64_t read_ptr;
	caddr_t src, dst, end;
	int count;

	read_ptr = bus_space_read_8(st, sh, MAVB_CHANNEL1_READ_PTR);

	end = sc->rec.hw_start + MAVB_CHAN_RING_SIZE;
	src = sc->rec.hw_start + read_ptr;
	dst = sc->rec.sw_cur;

	if (read_ptr % MAVB_CHAN_CHUNK_SIZE) {
		printf("%s: read_ptr=%lld\n", sc->sc_dev.dv_xname, read_ptr);
		return;
	}
	if ((dst - sc->rec.sw_start) % MAVB_CHAN_CHUNK_SIZE) {
		printf("%s: dst=%ld\n", sc->sc_dev.dv_xname,
		    dst - sc->rec.sw_start);
		return;
	}

	count = MAVB_CHAN_INTR_SIZE / MAVB_CHAN_CHUNK_SIZE;
	while (--count >= 0) {
		memcpy(dst, src, MAVB_CHAN_CHUNK_SIZE);
		dst += MAVB_CHAN_CHUNK_SIZE;
		src += MAVB_CHAN_CHUNK_SIZE;
		if (src >= end)
			src = sc->rec.hw_start;
		if (dst >= sc->rec.sw_end)
			dst = sc->rec.sw_start;
		if (!((dst - sc->rec.sw_start) % sc->rec.blksize)) {
			if (sc->rec.intr)
				sc->rec.intr(sc->rec.intrarg);
		}
	}
	read_ptr = src - sc->rec.hw_start;
	bus_space_write_8(st, sh, MAVB_CHANNEL1_READ_PTR, read_ptr);
	sc->rec.sw_cur = dst;
}

int
mavb_trigger_output(void *hdl, void *start, void *end, int blksize,
    void (*intr)(void *), void *intrarg, struct audio_params *param)
{
	struct mavb_softc *sc = (struct mavb_softc *)hdl;

	DPRINTF(1, ("%s: mavb_trigger_output: start=%p end=%p "
	    "blksize=%d intr=%p(%p)\n", sc->sc_dev.dv_xname,
	    start, end, blksize, intr, intrarg));

	mtx_enter(&audio_lock);
	sc->play.blksize = blksize;
	sc->play.intr = intr;
	sc->play.intrarg = intrarg;

	sc->play.sw_start = sc->play.sw_cur = start;
	sc->play.sw_end = end;

	bus_space_write_8(sc->sc_st, sc->sc_sh, MAVB_CHANNEL2_CONTROL,
	    MAVB_CHANNEL_RESET);
	delay(1000);
	bus_space_write_8(sc->sc_st, sc->sc_sh, MAVB_CHANNEL2_CONTROL, 0);

	/* Fill first 25% of buffer with silence. */
	bzero(sc->play.hw_start, MAVB_CHAN_CHUNK_SIZE);
	bus_space_write_8(sc->sc_st, sc->sc_sh, MAVB_CHANNEL2_WRITE_PTR,
	    MAVB_CHAN_CHUNK_SIZE);

	/* Fill next 50% of buffer with audio data. */
	mavb_dma_output(sc);

	/* The buffer is now 75% full.  Start DMA and get interrupts
	 * when the buffer is 25% full.  The interrupt handler fills
	 * in 50% of the buffer size, putting it back to 75% full.
	 */
	bus_space_write_8(sc->sc_st, sc->sc_sh, MAVB_CHANNEL2_CONTROL,
	    MAVB_CHANNEL_DMA_ENABLE | MAVB_CHANNEL_INT_25);
	mtx_leave(&audio_lock);
	return (0);
}

int
mavb_trigger_input(void *hdl, void *start, void *end, int blksize,
    void (*intr)(void *), void *intrarg, struct audio_params *param)
{
	struct mavb_softc *sc = (struct mavb_softc *)hdl;

	DPRINTF(1, ("%s: mavb_trigger_output: start=%p end=%p "
	    "blksize=%d intr=%p(%p)\n", sc->sc_dev.dv_xname,
	    start, end, blksize, intr, intrarg));

	mtx_enter(&audio_lock);
	sc->rec.blksize = blksize;
	sc->rec.intr = intr;
	sc->rec.intrarg = intrarg;

	sc->rec.sw_start = sc->rec.sw_cur = start;
	sc->rec.sw_end = end;

	bus_space_write_8(sc->sc_st, sc->sc_sh, MAVB_CHANNEL1_CONTROL,
	    MAVB_CHANNEL_RESET);
	delay(1000);
	bus_space_write_8(sc->sc_st, sc->sc_sh, MAVB_CHANNEL1_CONTROL, 0);

	bus_space_write_8(sc->sc_st, sc->sc_sh, MAVB_CHANNEL1_CONTROL,
	    MAVB_CHANNEL_DMA_ENABLE | MAVB_CHANNEL_INT_50);
	mtx_leave(&audio_lock);
	return (0);
}

static void
mavb_button_repeat(void *hdl)
{
	struct mavb_softc *sc = (struct mavb_softc *)hdl;
	u_int64_t intmask, control;
	u_int16_t value, left, right;

	DPRINTF(1, ("%s: mavb_repeat called\n", sc->sc_dev.dv_xname));

#define  MAVB_CONTROL_VOLUME_BUTTONS \
    (MAVB_CONTROL_VOLUME_BUTTON_UP | MAVB_CONTROL_VOLUME_BUTTON_DOWN)

	control = bus_space_read_8(sc->sc_st, sc->sc_sh, MAVB_CONTROL);
	if (control & MAVB_CONTROL_VOLUME_BUTTONS) {
		value = ad1843_reg_read(sc, AD1843_DAC1_ANALOG_GAIN);
		left = (value & AD1843_LDA1G_MASK) >> AD1843_LDA1G_SHIFT;
		right = (value & AD1843_RDA1G_MASK) >> AD1843_RDA1G_SHIFT;
		if (control & MAVB_CONTROL_VOLUME_BUTTON_UP) {
			control &= ~MAVB_CONTROL_VOLUME_BUTTON_UP;
			if (left > 0)
				left--;		/* attenuation! */
			if (right > 0)
				right--;
		}
		if (control & MAVB_CONTROL_VOLUME_BUTTON_DOWN) {
			control &= ~MAVB_CONTROL_VOLUME_BUTTON_DOWN;
			if (left < 63)
				left++;
			if (right < 63)
				right++;
		}
		bus_space_write_8(sc->sc_st, sc->sc_sh, MAVB_CONTROL, control);

		value &= ~(AD1843_LDA1G_MASK | AD1843_RDA1G_MASK);
		value |= (left << AD1843_LDA1G_SHIFT);
		value |= (right << AD1843_RDA1G_SHIFT);
		ad1843_reg_write(sc, AD1843_DAC1_ANALOG_GAIN, value);

		timeout_add_msec(&sc->sc_volume_button_to,
		    MAVB_VOLUME_BUTTON_REPEAT_DELN);
	} else {
		/* Enable volume button interrupts again.  */
		intmask = bus_space_read_8(sc->sc_st, sc->sc_isash,
		     MACE_ISA_INT_MASK);
		bus_space_write_8(sc->sc_st, sc->sc_isash, MACE_ISA_INT_MASK,
		     intmask | MACE_ISA_INT_AUDIO_SC);
	}
}

static int
mavb_intr(void *arg)
{
	struct mavb_softc *sc = arg;
	u_int64_t intstat, intmask;

	mtx_enter(&audio_lock);
	intstat = bus_space_read_8(sc->sc_st, sc->sc_isash, MACE_ISA_INT_STAT);
	DPRINTF(MAVB_DEBUG_INTR, ("%s: mavb_intr: intstat = 0x%lx\n",
            sc->sc_dev.dv_xname, intstat));

	if (intstat & MACE_ISA_INT_AUDIO_SC) {
		/* Disable volume button interrupts.  */
		intmask = bus_space_read_8(sc->sc_st, sc->sc_isash,
		     MACE_ISA_INT_MASK);
		bus_space_write_8(sc->sc_st, sc->sc_isash, MACE_ISA_INT_MASK,
		     intmask & ~MACE_ISA_INT_AUDIO_SC);

		timeout_add_msec(&sc->sc_volume_button_to,
		    MAVB_VOLUME_BUTTON_REPEAT_DEL1);
	}

	if (intstat & MACE_ISA_INT_AUDIO_DMA1)
		mavb_dma_input(sc);

	if (intstat & MACE_ISA_INT_AUDIO_DMA2)
		mavb_dma_output(sc);
	mtx_leave(&audio_lock);
	return 1;
}

int
mavb_match(struct device *parent, void *match, void *aux)
{
	struct macebus_attach_args *maa = aux;
	bus_space_handle_t ioh;
	u_int64_t control;

	if (bus_space_map(maa->maa_iot, maa->maa_baseaddr, MAVB_NREGS, 0,
	    &ioh) != 0)
		return (0);
	control = bus_space_read_8(maa->maa_iot, ioh, MAVB_CONTROL);
	bus_space_unmap(maa->maa_iot, ioh, MAVB_NREGS);

	return ((control & MAVB_CONTROL_CODEC_PRESENT) != 0);
}

void
mavb_attach(struct device *parent, struct device *self, void *aux)
{
	struct mavb_softc *sc = (void *)self;
	struct macebus_attach_args *maa = aux;
	bus_dma_segment_t seg;
	u_int16_t value;
	int rseg;

	sc->sc_st = maa->maa_iot;
	if (bus_space_map(sc->sc_st, maa->maa_baseaddr, MAVB_NREGS, 0,
	    &sc->sc_sh) != 0) {
		printf(": can't map i/o space\n");
		return;
	}

	/* XXX We need access to some of the MACE ISA registers.  */
	extern bus_space_handle_t mace_h;
	bus_space_subregion(sc->sc_st, mace_h, 0, MAVB_ISA_NREGS,
	    &sc->sc_isash);

	/* Set up DMA structures.  */
	sc->sc_dmat = maa->maa_dmat;
	if (bus_dmamap_create(sc->sc_dmat, MAVB_ISA_RING_SIZE, 1,
	    MAVB_ISA_RING_SIZE, 0, 0, &sc->sc_dmamap)) {
		printf(": can't create MACE ISA DMA map\n");
		return;
	}

	if (bus_dmamem_alloc(sc->sc_dmat, MAVB_ISA_RING_SIZE,
	    MACE_ISA_RING_ALIGN, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
		printf(": can't allocate ring buffer\n");
		return;
	}

	if (bus_dmamem_map(sc->sc_dmat, &seg, rseg, MAVB_ISA_RING_SIZE,
	    &sc->sc_ring, BUS_DMA_COHERENT)) {
		printf(": can't map ring buffer\n");
		return;
	}

	if (bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap, sc->sc_ring,
	    MAVB_ISA_RING_SIZE, NULL, BUS_DMA_NOWAIT)) {
		printf(": can't load MACE ISA DMA map\n");
		return;
	}

	sc->rec.hw_start = sc->sc_ring;
	sc->play.hw_start = sc->sc_ring + MAVB_CHAN_RING_SIZE;

	bus_space_write_8(sc->sc_st, sc->sc_isash, MACE_ISA_RING_BASE,
	    sc->sc_dmamap->dm_segs[0].ds_addr);

	/* Establish interrupt.  */
	macebus_intr_establish(maa->maa_intr, maa->maa_mace_intr,
	    IST_EDGE, IPL_AUDIO, mavb_intr, sc, sc->sc_dev.dv_xname);

	/* 2. Assert the RESET signal.  */
	bus_space_write_8(sc->sc_st, sc->sc_sh, MAVB_CONTROL,
	    MAVB_CONTROL_RESET);
	delay(1);		/* at least 100 ns */

	/* 3. Deassert the RESET signal and enter a wait period to
              allow the AD1843 internal clocks and the external
              crystal oscillator to stabilize.  */
	bus_space_write_8(sc->sc_st, sc->sc_sh, MAVB_CONTROL, 0);
	delay(800);		/* typically 400 us to 800 us */
	if (ad1843_reg_read(sc, AD1843_CODEC_STATUS) & AD1843_INIT) {
		printf(": codec not ready\n");
		return;
	}

	/* 4. Put the conversion sources into standby.  */
	value = ad1843_reg_read(sc, AD1843_FUNDAMENTAL_SETTINGS);
	ad1843_reg_write(sc, AD1843_FUNDAMENTAL_SETTINGS,
	    value & ~AD1843_PDNI);
	delay (500000);		/* approximately 474 ms */
	if (ad1843_reg_read(sc, AD1843_CODEC_STATUS) & AD1843_PDNO) {
		printf(": can't power up conversion resources\n");
		return;
	}

	/* 5. Power up the clock generators and enable clock output pins.  */
	value = ad1843_reg_read(sc, AD1843_FUNDAMENTAL_SETTINGS);
	ad1843_reg_write(sc, AD1843_FUNDAMENTAL_SETTINGS,
	    value | AD1843_C1EN | AD1843_C2EN);

	/* 6. Configure conversion resources while they are in standby.  */
	value = ad1843_reg_read(sc, AD1843_SERIAL_INTERFACE);
	ad1843_reg_write(sc, AD1843_SERIAL_INTERFACE, value | AD1843_ADTLK);
	value = ad1843_reg_read(sc, AD1843_CHANNEL_SAMPLE_RATE);
	ad1843_reg_write(sc, AD1843_CHANNEL_SAMPLE_RATE,
	    value | (2 << AD1843_DA1C_SHIFT) |
	    (1 << AD1843_ADRC_SHIFT) | (1 << AD1843_ADLC_SHIFT));

	/* 7. Enable conversion resources.  */
	value = ad1843_reg_read(sc, AD1843_CHANNEL_POWER_DOWN);
	ad1843_reg_write(sc, AD1843_CHANNEL_POWER_DOWN,
	    value | (AD1843_DA1EN | AD1843_ANAEN | AD1843_AAMEN |
	    AD1843_ADREN | AD1843_ADLEN));

	/* 8. Configure conversion resources while they are enabled.  */
	value = ad1843_reg_read(sc, AD1843_DAC1_ANALOG_GAIN);
	ad1843_reg_write(sc, AD1843_DAC1_ANALOG_GAIN,
            value & ~(AD1843_LDA1GM | AD1843_RDA1GM));
	value = ad1843_reg_read(sc, AD1843_DAC1_DIGITAL_GAIN);
	ad1843_reg_write(sc, AD1843_DAC1_DIGITAL_GAIN,
            value & ~(AD1843_LDA1AM | AD1843_RDA1AM));
	value = ad1843_reg_read(sc, AD1843_MISC_SETTINGS);
	ad1843_reg_write(sc, AD1843_MISC_SETTINGS,
            value & ~(AD1843_HPOM | AD1843_MNOM));

	value = ad1843_reg_read(sc, AD1843_CODEC_STATUS);
	printf(": AD1843 rev %d\n", (u_int)value & AD1843_REVISION_MASK);

	sc->play.rate = sc->rec.rate = 48000;
	sc->play.format = sc->rec.format = AD1843_PCM8;

	timeout_set(&sc->sc_volume_button_to, mavb_button_repeat, sc);

	audio_attach_mi(&mavb_sa_hw_if, sc, &sc->sc_dev);

	return;
}

u_int16_t
ad1843_reg_read(struct mavb_softc *sc, ad1843_addr_t addr)
{
	bus_space_write_8(sc->sc_st, sc->sc_sh, MAVB_CODEC_CONTROL,
            (addr & MAVB_CODEC_ADDRESS_MASK) << MAVB_CODEC_ADDRESS_SHIFT |
	    MAVB_CODEC_READ);
	delay(200);
	return bus_space_read_8(sc->sc_st, sc->sc_sh, MAVB_CODEC_STATUS);
}

u_int16_t
ad1843_reg_write(struct mavb_softc *sc, ad1843_addr_t addr, u_int16_t value)
{
	bus_space_write_8(sc->sc_st, sc->sc_sh, MAVB_CODEC_CONTROL,
	    (addr & MAVB_CODEC_ADDRESS_MASK) << MAVB_CODEC_ADDRESS_SHIFT |
	    (value & MAVB_CODEC_WORD_MASK) << MAVB_CODEC_WORD_SHIFT);
	delay(200);
	return bus_space_read_8(sc->sc_st, sc->sc_sh, MAVB_CODEC_STATUS);
}

void
ad1843_dump_regs(struct mavb_softc *sc)
{
	u_int16_t addr;

	for (addr = 0; addr < AD1843_NREGS; addr++)
		printf("%d: 0x%04x\n", addr, ad1843_reg_read(sc, addr));
}
@


1.19
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: mavb.c,v 1.17 2014/05/19 21:18:42 miod Exp $	*/
a167 1
int mavb_getdev(void *, struct audio_device *);
a189 1
	mavb_getdev,
a201 6
struct audio_device mavb_device = {
	"A3",
	"",
	"mavb"
};

a381 7
	return (0);
}

int
mavb_getdev(void *hdl, struct audio_device *ret)
{
	*ret = mavb_device;
@


1.18
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@a162 1
int mavb_query_encoding(void *, struct audio_encoding *);
a176 1
void mavb_get_default_params(void *, int, struct audio_params *);
a180 2
	0,
	mavb_query_encoding,
a198 1
	0,
d201 1
a201 2
	mavb_trigger_input,
	mavb_get_default_params
a218 30
}

int
mavb_query_encoding(void *hdl, struct audio_encoding *ae)
{
	switch (ae->index) {
	case 0:
		/* 24-bit Signed Linear PCM LSB-aligned.  */
		strlcpy(ae->name, AudioEslinear_be, sizeof ae->name);
		ae->encoding = AUDIO_ENCODING_SLINEAR_BE;
		ae->precision = 24;
		ae->flags = 0;
		break;
	default:
		return (EINVAL);
	}
	ae->bps = AUDIO_BPS(ae->precision);
	ae->msb = 0;
	return (0);
}

void
mavb_get_default_params(void *hdl, int mode, struct audio_params *p)
{
	p->sample_rate = 48000;
	p->encoding = AUDIO_ENCODING_SLINEAR_BE;
	p->precision = 24;
	p->bps = 4;
	p->msb = 0;
	p->channels = 2;
@


1.17
log
@Format string fixes and removal of -Wno-format for sgi. Based upon an
initial diff from jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mavb.c,v 1.16 2013/06/21 09:34:06 ratchov Exp $	*/
d232 1
a232 8
		/* 8-bit Unsigned Linear PCM.  */
		strlcpy(ae->name, AudioEulinear, sizeof ae->name);
		ae->encoding = AUDIO_ENCODING_ULINEAR;
		ae->precision = 8;
		ae->flags = 0;
		break;
	case 1:
		/* 16-bit Signed Linear PCM.  */
d235 1
a235 15
		ae->precision = 16;
		ae->flags = 0;
		break;
	case 2:
		/* 8-bit mu-Law Companded.  */
		strlcpy(ae->name, AudioEmulaw, sizeof ae->name);
		ae->encoding = AUDIO_ENCODING_ULAW;
		ae->precision = 8;
		ae->flags = 0;
		break;
	case 3:
		/* 8-bit A-Law Companded.  */
		strlcpy(ae->name, AudioEalaw, sizeof ae->name);
		ae->encoding = AUDIO_ENCODING_ALAW;
		ae->precision = 8;
d242 1
a242 2
	ae->msb = 1;

a245 102
/*
 * For some reason SGI has decided to standardize their sound hardware
 * interfaces on 24-bit PCM even though the AD1843 codec used in the
 * Moosehead A/V Board only supports 16-bit and 8-bit formats.
 * Therefore we must convert everything to 24-bit samples only to have
 * the MACE hardware convert them back into 16-bit samples again.  To
 * complicate matters further, the 24-bit samples are embedded 32-bit
 * integers.  The 8-bit and 16-bit samples are first converted into
 * 24-bit samples by padding them to the right with zeroes.  Then they
 * are sign-extended into 32-bit integers.  This conversion is
 * conveniently done through the software encoding layer of the high
 * level audio driver by using the functions below.  Conversion of
 * mu-law and A-law formats is done by the hardware.
 */

static void
linear16_to_linear24_be(void *hdl, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while ((cc -= 2) >= 0) {
		q -= 4;
		q[3] = 0;
		q[2] = *--p;
		q[1] = *--p;
		q[0] = (*p & 0x80) ? 0xff : 0;
	}
}

static void
linear24_to_linear16_be(void *hdl, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 4) >= 0) {
		*q++ = p[1];
		*q++ = p[2];
		p += 4;
	}
}

static void
ulinear8_to_ulinear24_be(void *hdl, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		q -= 4;
		q[3] = 0;
		q[2] = 0;
		q[1] = *--p;
		q[0] = (*p & 0x80) ? 0xff : 0;
	}
}

static void
ulinear24_to_ulinear8_be(void *hdl, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 4) >= 0) {
		*q++ = p[1];
		p += 4;
	}
}

static void
linear16_to_linear24_be_mts(void *hdl, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while ((cc -= 2) >= 0) {
		q -= 8;
		q[3] = q[7] = 0;
		q[2] = q[6] = *--p;
		q[1] = q[5] = *--p;
		q[0] = q[4] = (*p & 0x80) ? 0xff : 0;
	}
}

static void
ulinear8_to_ulinear24_be_mts(void *hdl, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 8;
	while (--cc >= 0) {
		q -= 8;
		q[3] = q[7] = 0;
		q[2] = q[6] = 0;
		q[1] = q[5] = *--p;
		q[0] = q[4] = (*p & 0x80) ? 0xff : 0;
	}
}

d251 3
a253 3
	p->precision = 16;
	p->bps = 2;
	p->msb = 1;
a254 5
	p->factor = 2;
	if (mode == AUMODE_PLAY)
		p->sw_code = linear16_to_linear24_be;
	else
		p->sw_code = linear24_to_linear16_be;
d360 5
a364 46
		switch (play->encoding) {
		case AUDIO_ENCODING_ULAW:
		case AUDIO_ENCODING_ALAW:
		case AUDIO_ENCODING_ULINEAR_BE:
			if (play->precision != 8)
				return (EINVAL);
			switch (play->channels) {
			case 1:
				play->factor = 8;
				play->sw_code = ulinear8_to_ulinear24_be_mts;
				break;
			case 2:
				play->factor = 4;
				play->sw_code = ulinear8_to_ulinear24_be;
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_SLINEAR_BE:
			if (play->precision == 16) {
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code =
						linear16_to_linear24_be_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code =
						linear16_to_linear24_be;
					break;
				default:
					return (EINVAL);
				}
			} else {
				play->factor = 1;
				play->sw_code = NULL;
				play->channels = 2;
				play->precision = 24;
			}
			break;
		default:
			return (EINVAL);
		}

a372 2
		play->bps = AUDIO_BPS(play->precision);
		play->msb = 0;
d376 1
a376 26
		switch (rec->encoding) {
		case AUDIO_ENCODING_ULAW:
		case AUDIO_ENCODING_ALAW:
		case AUDIO_ENCODING_ULINEAR_BE:
			if (rec->precision != 8)
				return (EINVAL);
			rec->factor = 4;
			rec->sw_code = ulinear24_to_ulinear8_be;
			break;
		case AUDIO_ENCODING_SLINEAR_BE:
			if (rec->precision == 16) {
				rec->factor = 2;
				rec->sw_code = linear24_to_linear16_be;
			} else {
				rec->factor = 1;
				rec->sw_code = NULL;
				rec->channels = 2;
				rec->precision = 24;
				break;
			}
			break;
		default:
			return (EINVAL);
		}

		/* stereo to mono conversions not yet implemented */
d378 3
a388 3

		rec->bps = AUDIO_BPS(rec->precision);
		rec->msb = 0;
@


1.16
log
@enable 24-bit, lsb-aligned encoding, which is the device's
native one. Allows encoding conversions to be handled in
userland
@
text
@d1 1
a1 1
/*	$OpenBSD: mavb.c,v 1.15 2013/05/15 08:29:23 ratchov Exp $	*/
d1059 1
a1059 1
		printf("%s: write_ptr=%d\n", sc->sc_dev.dv_xname, write_ptr);
d1063 1
a1063 1
		printf("%s: src=%d\n", sc->sc_dev.dv_xname,
d1103 1
a1103 1
		printf("%s: read_ptr=%d\n", sc->sc_dev.dv_xname, read_ptr);
d1107 1
a1107 1
		printf("%s: dst=%d\n", sc->sc_dev.dv_xname,
@


1.15
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: mavb.c,v 1.14 2012/10/03 22:46:09 miod Exp $	*/
d525 4
a528 1
				return (EINVAL);
d544 1
a544 1
		play->msb = 1;
d562 5
a566 1
				return (EINVAL);
d585 1
a585 1
		rec->msb = 1;
@


1.14
log
@Don't include <mips64/archtype.h> unless you really need it.
@
text
@d1 1
a1 1
/*	$OpenBSD: mavb.c,v 1.13 2010/07/15 03:43:11 jakemsr Exp $	*/
d601 1
a601 1

d603 1
d613 1
a613 1

d615 1
d1134 1
d1161 1
d1175 1
d1190 1
d1249 1
d1270 1
a1270 1

@


1.13
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mavb.c,v 1.12 2010/07/02 03:24:50 blambert Exp $	*/
a26 1
#include <machine/autoconf.h>
a29 2

#include <mips64/archtype.h>
@


1.12
log
@timeout_add -> timeout_add_msec

ok miod@@ some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: mavb.c,v 1.11 2009/11/18 21:13:17 jakemsr Exp $	*/
d265 2
d379 2
d542 3
d579 3
@


1.11
log
@* always move the same amount of data (256 frames) in the interrupt handler
* round blocksizes to multiples of 256 frames
* fix display of record.source.volume and add record.mic.preamp
mixer controls
* add recording support

ok kettenis@@.  ok ratchov@@ on a slightly different version.
@
text
@d1 1
a1 1
/*	$OpenBSD: mavb.c,v 1.10 2009/10/26 18:00:06 miod Exp $	*/
d1219 2
a1220 2
		timeout_add(&sc->sc_volume_button_to,
		    (hz * MAVB_VOLUME_BUTTON_REPEAT_DELN) / 1000);
d1247 2
a1248 2
		timeout_add(&sc->sc_volume_button_to,
		    (hz * MAVB_VOLUME_BUTTON_REPEAT_DEL1) / 1000);
@


1.10
log
@Better crime/mace interrupt handling; interrupt information is no longer
specified in the kernel configuration file, but is provided by macebus(4)
as part of the  child device attachment args, and provide both crime and
mace interrupt bitmasks; this allows us to only really enable interrupt
sources we care about, and to avoid invoking interrupt handler we don't need
to for the few mace interrupts multiplexed at the crime level.
@
text
@d1 1
a1 1
/*	$OpenBSD: mavb.c,v 1.9 2008/04/21 00:32:42 jakemsr Exp $	*/
d57 6
d71 1
d117 12
a138 1
#define MAVB_ISA_RING_SIZE		0x1000
d141 2
a142 10
	caddr_t sc_start, sc_end;
	int sc_blksize;
	void (*sc_intr)(void *);
	void *sc_intrarg;

	caddr_t sc_get;
	int sc_count;

	u_long sc_play_rate;
	u_int sc_play_format;
d181 1
d210 1
a210 1
	0
d371 14
d391 1
a391 1
	if (sc->sc_play_rate != sample_rate) {
d393 1
a393 1
		sc->sc_play_rate = sample_rate;
d399 1
a399 1
mavb_set_play_format(struct mavb_softc *sc, u_int encoding)
d401 9
a409 2
	u_int16_t value;
	u_int format;
d411 3
d416 1
a416 1
		format = AD1843_PCM8;
d419 1
a419 1
		format = AD1843_PCM16;
d422 1
a422 1
		format = AD1843_ULAW;
d425 1
a425 1
		format = AD1843_ALAW;
d430 9
d440 5
a444 1
	if (sc->sc_play_format != format) {
d449 23
a471 1
		sc->sc_play_format = format;
d561 11
d580 6
a585 2
	/* Block size should be a multiple of 32.  */
	return (bs + 0x1f) & ~0x1f;
d602 5
d645 8
d771 5
a775 1
		    (right << 2) | right;
d885 13
d1033 1
a1033 2
	u_int64_t depth;
	caddr_t src, dst;
a1036 1
	depth = bus_space_read_8(st, sh, MAVB_CHANNEL2_DEPTH);
d1038 3
a1040 2
	dst = sc->sc_ring + write_ptr;
	src = sc->sc_get;
d1042 11
a1052 1
	count = (MAVB_ISA_RING_SIZE - depth - 32);
d1054 10
a1063 9
		*dst++ = *src++;
		if (dst >= sc->sc_ring + MAVB_ISA_RING_SIZE)
			dst = sc->sc_ring;
		if (src >= sc->sc_end)
			src = sc->sc_start;
		if (++sc->sc_count >= sc->sc_blksize) {
			if (sc->sc_intr)
				sc->sc_intr(sc->sc_intrarg);
			sc->sc_count = 0;
d1066 29
d1096 17
a1112 3
	write_ptr = dst - sc->sc_ring;
	bus_space_write_8(st, sh, MAVB_CHANNEL2_WRITE_PTR, write_ptr);
	sc->sc_get = src;
d1117 1
a1117 2
		    void (*intr)(void *), void *intrarg,
		    struct audio_params *param)
d1125 3
a1127 3
	sc->sc_blksize = blksize;
	sc->sc_intr = intr;
	sc->sc_intrarg = intrarg;
d1129 2
a1130 4
	sc->sc_start = sc->sc_get = start;
	sc->sc_end = end;

	sc->sc_count = 0;
d1137 6
d1145 4
d1150 1
a1150 1
	    MAVB_CHANNEL_DMA_ENABLE | MAVB_CHANNEL_INT_50);
d1156 1
a1156 2
		   void (*intr)(void *), void *intrarg,
		   struct audio_params *param)
d1158 20
d1251 3
d1299 2
a1300 2
	if (bus_dmamap_create(sc->sc_dmat, 4 * MAVB_ISA_RING_SIZE, 1,
	    4 * MAVB_ISA_RING_SIZE, 0, 0, &sc->sc_dmamap)) {
d1305 1
a1305 1
	if (bus_dmamem_alloc(sc->sc_dmat, 4 * MAVB_ISA_RING_SIZE,
d1311 1
a1311 1
	if (bus_dmamem_map(sc->sc_dmat, &seg, rseg, 4 * MAVB_ISA_RING_SIZE,
d1318 1
a1318 1
	    4 * MAVB_ISA_RING_SIZE, NULL, BUS_DMA_NOWAIT)) {
d1323 2
a1324 1
	sc->sc_ring += MAVB_ISA_RING_SIZE; /* XXX */
d1360 2
a1361 1
	ad1843_reg_write(sc, AD1843_FUNDAMENTAL_SETTINGS, value | AD1843_C2EN);
d1364 2
d1368 2
a1369 1
	     value | (2 << AD1843_DA1C_SHIFT));
d1374 2
a1375 1
	     value | (AD1843_DA1EN | AD1843_AAMEN));
d1391 2
a1392 2
	sc->sc_play_rate = 48000;
	sc->sc_play_format = AD1843_PCM8;
@


1.9
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mavb.c,v 1.8 2008/02/20 18:46:20 miod Exp $	*/
d35 1
d1066 1
a1066 1
	struct confargs *ca = aux;
d1070 1
a1070 1
	if (bus_space_map(ca->ca_iot, ca->ca_baseaddr, MAVB_NREGS, 0,
d1073 2
a1074 2
	control = bus_space_read_8(ca->ca_iot, ioh, MAVB_CONTROL);
	bus_space_unmap(ca->ca_iot, ioh, MAVB_NREGS);
d1083 1
a1083 1
	struct confargs *ca = aux;
d1088 2
a1089 2
	sc->sc_st = ca->ca_iot;
	if (bus_space_map(sc->sc_st, ca->ca_baseaddr, MAVB_NREGS, 0,
d1101 1
a1101 1
	sc->sc_dmat = ca->ca_dmat;
d1132 2
a1133 2
	macebus_intr_establish(NULL, ca->ca_intr, IST_EDGE, IPL_AUDIO,
	    mavb_intr, sc, sc->sc_dev.dv_xname);
@


1.8
log
@Completely overhault attachment rules on sgi. No more indirect configuration
inherited from OpenBSD/arc machines with ISA bus; mainbus children match on
device name and other hierarchies match on simplified locators.
As a bonus, attachment lines in dmesg will now print their locators.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mavb.c,v 1.7 2007/05/20 14:17:05 miod Exp $	*/
d197 2
a198 1
	mavb_trigger_input
@


1.7
log
@Check for codec presence in match(), and don't attach if none is found.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mavb.c,v 1.6 2005/04/15 13:05:14 mickey Exp $	*/
a1067 3
	if (ca->ca_sys != SGI_O2 || strcmp(ca->ca_name, mavb_cd.cd_name))
		return (0);

d1130 1
a1130 1
	BUS_INTR_ESTABLISH(ca, NULL, ca->ca_intr, IST_EDGE, IPL_AUDIO,
@


1.6
log
@make sure aligment does not return zero block size
@
text
@d1 1
a1 1
/*	$OpenBSD: mavb.c,v 1.5 2005/01/24 20:44:37 kettenis Exp $	*/
d1065 2
d1071 7
a1077 1
	return (1);
a1085 1
	u_int64_t control;
a1134 6

	control = bus_space_read_8(sc->sc_st, sc->sc_sh, MAVB_CONTROL);
	if (!(control & MAVB_CONTROL_CODEC_PRESENT)) {
		printf(": no codec present\n");
		return;
	}
@


1.5
log
@Fix MACE ISA ringbuffer alignment.
@
text
@d1 1
a1 1
/*	$OpenBSD: mavb.c,v 1.4 2005/01/24 20:40:16 kettenis Exp $	*/
d498 1
a498 1
	return bs & ~0x1f;
@


1.4
log
@Tweak mixer label.  Whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: mavb.c,v 1.2 2005/01/02 18:55:56 kettenis Exp $	*/
d1103 1
a1103 1
	    sizeof (u_int64_t), 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
@


1.3
log
@Split out register definitions.
@
text
@d792 1
a792 1
		strlcpy(di->label.name, AudioNmaster, sizeof di->label.name);
d1123 1
a1123 1
	   sc->sc_dmamap->dm_segs[0].ds_addr);
@


1.2
log
@Add OpenBSD tag.  Better mixer support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 2004 Mark Kettenis
d35 3
a52 41
/*
 * MACE registers used by the Moosehead A/V Board.
 */

#define MAVB_CONTROL				0x00
#define  MAVB_CONTROL_RESET			0x0000000000000001
#define  MAVB_CONTROL_CODEC_PRESENT		0x0000000000000002
#define  MAVB_CONTROL_VOLUME_BUTTON_UP		0x0000000001000000
#define  MAVB_CONTROL_VOLUME_BUTTON_DOWN	0x0000000000800000

#define MAVB_CODEC_CONTROL			0x08
#define  MAVB_CODEC_READ			0x0000000000010000
#define  MAVB_CODEC_WORD_SHIFT			0
#define  MAVB_CODEC_WORD_MASK			0x000000000000ffff
#define  MAVB_CODEC_ADDRESS_SHIFT		17
#define  MAVB_CODEC_ADDRESS_MASK		0x000000000000001f

#define MAVB_CODEC_STATUS			0x18
#define MAVB_CHANNEL1_CONTROL			0x20
#define MAVB_CHANNEL2_CONTROL			0x40
#define MAVB_CHANNEL3_CONTROL			0x60
#define  MAVB_CHANNEL_RESET			0x0000000000000400
#define  MAVB_CHANNEL_DMA_ENABLE		0x0000000000000200
#define  MAVB_CHANNEL_INT_DISABLED		0x0000000000000000
#define  MAVB_CHANNEL_INT_25			0x0000000000000020
#define  MAVB_CHANNEL_INT_50			0x0000000000000040
#define  MAVB_CHANNEL_INT_75			0x0000000000000060
#define  MAVB_CHANNEL_INT_EMPTY			0x0000000000000080
#define  MAVB_CHANNEL_INT_NOT_EMPTY		0x00000000000000a0
#define  MAVB_CHANNEL_INT_FULL			0x00000000000000c0
#define  MAVB_CHANNEL_INT_NOT_FULL		0x00000000000000e0

#define MAVB_CHANNEL1_READ_PTR			0x28
#define MAVB_CHANNEL1_WRITE_PTR			0x30
#define MAVB_CHANNEL1_DEPTH			0x38
#define MAVB_CHANNEL2_READ_PTR			0x48
#define MAVB_CHANNEL2_WRITE_PTR			0x50
#define MAVB_CHANNEL2_DEPTH			0x58

#define MAVB_NREGS				0x80

a56 93
 * AD1843 Codec registers & defenitions.
 */

#define AD1843_CODEC_STATUS		0
#define  AD1843_INIT			0x8000
#define  AD1843_PDNO			0x4000
#define  AD1843_REVISION_MASK		0x000f

#define AD1843_ADC_SOURCE_GAIN		2
#define  AD1843_LSS_MASK		0xe000
#define  AD1843_LSS_SHIFT		13
#define  AD1843_RSS_MASK		0x00e0
#define  AD1843_RSS_SHIFT		5
#define  AD1843_LMGE			0x1000
#define  AD1843_RMGE			0x0010
#define  AD1843_LIG_MASK		0x0f00
#define  AD1843_LIG_SHIFT		8
#define  AD1843_RIG_MASK		0x000f
#define  AD1843_RIG_SHIFT		0

#define AD1843_DAC2_TO_MIXER		3
#define  AD1843_LD2MM			0x8000
#define  AD1843_RD2MM			0x0080
#define  AD1843_LD2M_MASK		0x1f00
#define  AD1843_LD2M_SHIFT		8
#define  AD1843_RD2M_MASK		0x001f
#define  AD1843_RD2M_SHIFT		0

#define AD1843_MISC_SETTINGS		8
#define  AD1843_MNMM			0x8000
#define  AD1843_MNM_MASK		0x1f00
#define  AD1843_MNM_SHIFT		8
#define  AD1843_ALLMM			0x0080
#define  AD1843_MNOM			0x0040
#define  AD1843_HPOM			0x0020
#define  AD1843_HPOS			0x0010
#define  AD1843_SUMM			0x0008
#define  AD1843_DAC2T			0x0002
#define  AD1843_DAC1T			0x0001

#define AD1843_DAC1_ANALOG_GAIN		9
#define  AD1843_LDA1GM			0x8000
#define  AD1843_RDA1GM			0x0080
#define  AD1843_LDA1G_MASK		0x3f00
#define  AD1843_LDA1G_SHIFT		8
#define  AD1843_RDA1G_MASK		0x003f
#define  AD1843_RDA1G_SHIFT		0

#define AD1843_DAC1_DIGITAL_GAIN	11
#define  AD1843_LDA1AM			0x8000
#define  AD1843_RDA1AM			0x0080

#define AD1843_CHANNEL_SAMPLE_RATE	15
#define  AD1843_DA1C_SHIFT		8

#define AD1843_CLOCK1_SAMPLE_RATE	17
#define AD1843_CLOCK2_SAMPLE_RATE	20
#define AD1843_CLOCK3_SAMPLE_RATE	13

#define AD1843_SERIAL_INTERFACE		26
#define  AD1843_DA2F_MASK		0x0c00
#define  AD1843_DA2F_SHIFT		10
#define  AD1843_DA1F_MASK		0x0300
#define  AD1843_DA1F_SHIFT		8
#define  AD1843_PCM8			0
#define  AD1843_PCM16			1
#define  AD1843_ULAW			2
#define  AD1843_ALAW			3
#define  AD1843_SCF			0x0080

#define AD1843_CHANNEL_POWER_DOWN	27
#define  AD1843_DFREE			0x8000
#define  AD1843_DDMEN			0x1000
#define  AD1843_DA2EN			0x0200
#define  AD1843_DA1EN			0x0100
#define  AD1843_ANAEN			0x0080
#define  AD1843_HPEN			0x0040
#define  AD1843_AAMEN			0x0010
#define  AD1843_ADREN			0x0002
#define  AD1843_ADLEN			0x0001

#define AD1843_FUNDAMENTAL_SETTINGS	28
#define  AD1843_PDNI			0x8000
#define  AD1843_ACEN			0x4000
#define  AD1843_C3EN			0x2000
#define  AD1843_C2EN			0x1000
#define  AD1843_C1EN			0x0800

#define AD1843_NREGS			32

typedef u_long ad1843_addr_t;

/*
a108 1

d136 6
a151 4

u_int16_t ad1843_reg_read(struct mavb_softc *, ad1843_addr_t);
u_int16_t ad1843_reg_write(struct mavb_softc *, ad1843_addr_t, u_int16_t);
void ad1843_dump_regs(struct mavb_softc *);
@


1.1
log
@Moosehead A/V Board audio driver.
@
text
@d1 2
d103 20
d124 5
a128 1
#define  AD1843_MPOM			0x0040
d130 4
a133 1
#define  AD1843_HSOM			0x0010
d166 2
d170 5
d191 48
a238 2
#define AD1843_OUTPUT_CLASS	0
#define AD1843_MASTER_LVL	1	/* DAC1 Analog Gain/Attenuation */
d660 1
d667 18
a684 1
	case AD1843_MASTER_LVL:
d695 76
d783 1
d790 15
a804 1
	case AD1843_MASTER_LVL:
d813 54
d877 2
d882 111
d999 16
a1014 2
	case AD1843_MASTER_LVL:
		di->type = AUDIO_MIXER_VALUE;
d1016 9
a1024 4
		strlcpy(di->label.name, AudioNmaster, sizeof di->label.name);
		di->un.v.num_channels = 2;
		strlcpy(di->un.v.units.name, AudioNvolume,
			sizeof di->un.v.units.name);
d1301 2
a1302 1
	ad1843_reg_write(sc, AD1843_CHANNEL_POWER_DOWN, value | AD1843_DA1EN);
d1313 1
a1313 1
            value & ~(AD1843_HPOM | AD1843_MPOM));
d1351 1
a1351 1
  u_int16_t addr;
d1353 2
a1354 2
  for (addr = 0; addr < AD1843_NREGS; addr++)
    printf ("%d: 0x%04x\n", (int)addr, ad1843_reg_read(sc, addr));
@

