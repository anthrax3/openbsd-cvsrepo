head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.18
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.16
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.12
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.8
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.10
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.6
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5;
locks; strict;
comment	@ * @;


1.21
date	2013.10.21.10.36.16;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2013.10.20.20.07.24;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2013.05.27.19.37.45;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2012.10.03.22.46.09;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2012.05.29.17.37.09;	author mikeb;	state Exp;
branches;
next	1.15;

1.15
date	2012.04.16.22.17.13;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2012.03.15.18.57.22;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2010.12.26.15.41.00;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2010.03.08.20.54.42;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2010.03.07.13.44.24;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.26.20.14.42;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.26.18.00.06;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2009.02.24.14.37.29;	author jsing;	state Exp;
branches;
next	1.6;

1.6
date	2008.04.07.22.34.21;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2008.02.20.18.46.20;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.31.12.46.14;	author jsing;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.14.16.03.10;	author jsing;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.27.16.08.06;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.27.15.31.00;	author jsing;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@/*	$OpenBSD: gbe.c,v 1.20 2013/10/20 20:07:24 miod Exp $ */

/*
 * Copyright (c) 2007, 2008, 2009 Joel Sing <jsing@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Graphics Back End (GBE) Framebuffer for SGI O2.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/bus.h>

#include <mips64/arcbios.h>

#include <sgi/dev/gl.h>
#include <sgi/localbus/crimebus.h>
#include <sgi/localbus/macebusvar.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

#include "gbereg.h"

/* Amount of memory to allocate for framebuffer. */
#define GBE_FB_SIZE	8 * 1 << 20

/* 
 * Colourmap data.
 */
struct  gbe_cmap {
	u_int8_t cm_red[256];
	u_int8_t cm_green[256];
	u_int8_t cm_blue[256];
};

/*
 * Screen data.
 */
struct gbe_screen {
	struct device *sc;		/* Back pointer. */

	struct rasops_info ri;		/* Screen raster display info. */
	struct rasops_info ri_tile;	/* Raster info for rasops tile. */
	struct gbe_cmap cmap;		/* Display colour map. */

	int fb_size;			/* Size of framebuffer memory. */
	int tm_size;			/* Size of tilemap memory. */

	caddr_t tm;			/* Address of tilemap memory. */
	paddr_t tm_phys;		/* Physical address of tilemap. */
	caddr_t fb;			/* Address of framebuffer memory. */
	paddr_t fb_phys;		/* Physical address of framebuffer. */
	caddr_t ro;			/* Address of rasops tile. */
	paddr_t ro_phys;		/* Physical address of rasops tile. */

	int width;			/* Width in pixels. */
	int height;			/* Height in pixels. */
	int depth;			/* Colour depth in bits. */
	int mode;			/* Display mode. */
	int bufmode;			/* Rendering engine buffer mode. */
	int linebytes;			/* Bytes per line. */
	int ro_curpos;			/* Current position in rasops tile. */
};

/*
 * GBE device data.
 */
struct gbe_softc {
	struct device sc_dev;

	bus_space_tag_t iot;
	bus_space_handle_t ioh;		/* GBE registers. */
	bus_space_handle_t re_ioh;	/* Rendering engine registers. */
	bus_dma_tag_t dmat;

	int rev;			/* Hardware revision. */
	int console;			/* Is this the console? */
	int screens;			/* No of screens allocated. */

	struct gbe_screen *curscr;	/* Current screen. */
};

/*
 * Hardware and device related functions.
 */
void	gbe_init_screen(struct gbe_screen *);
void	gbe_enable(struct gbe_softc *);
void	gbe_disable(struct gbe_softc *);
void	gbe_setup(struct gbe_softc *);
void	gbe_setcolour(struct gbe_softc *, u_int, u_int8_t, u_int8_t, u_int8_t);
void	gbe_wait_re_idle(struct gbe_softc *);

/*
 * Colour map handling for indexed modes.
 */
int	gbe_getcmap(struct gbe_cmap *, struct wsdisplay_cmap *);
int	gbe_putcmap(struct gbe_cmap *, struct wsdisplay_cmap *);
void	gbe_loadcmap(struct gbe_screen *, u_int, u_int);

/* 
 * Interfaces for wscons.
 */
int 	gbe_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t gbe_mmap(void *, off_t, int);
int	gbe_alloc_screen(void *, const struct wsscreen_descr *, void **,
	    int *, int *, long *);
void	gbe_free_screen(void *, void *);
int	gbe_show_screen(void *, void *, int, void (*)(void *, int, int),
	    void *);
int	gbe_load_font(void *, void *, struct wsdisplay_font *);
int	gbe_list_font(void *, struct wsdisplay_font *);

/*
 * Hardware acceleration for rasops.
 */
void	gbe_rop(struct gbe_softc *, int, int, int, int, int);
void	gbe_copyrect(struct gbe_softc *, int, int, int, int, int, int, int);
void	gbe_fillrect(struct gbe_softc *, int, int, int, int, int);
int	gbe_do_cursor(struct rasops_info *);
int	gbe_putchar(void *, int, int, u_int, long);
int	gbe_copycols(void *, int, int, int, int);
int	gbe_erasecols(void *, int, int, int, long);
int	gbe_copyrows(void *, int, int, int);
int	gbe_eraserows(void *, int, int, long);

static struct gbe_screen gbe_consdata;
static int gbe_console;

struct wsscreen_descr gbe_stdscreen = {
	"std",		/* Screen name. */
};

struct wsdisplay_accessops gbe_accessops = {
	.ioctl = gbe_ioctl,
	.mmap = gbe_mmap,
	.alloc_screen = gbe_alloc_screen,
	.free_screen = gbe_free_screen,
	.show_screen = gbe_show_screen,
	.load_font = gbe_load_font,
	.list_font = gbe_list_font
};

const struct wsscreen_descr *gbe_scrlist[] = {
	&gbe_stdscreen
};

struct wsscreen_list gbe_screenlist = {
	sizeof(gbe_scrlist) / sizeof(struct wsscreen_descr *), gbe_scrlist
};

int	gbe_match(struct device *, void *, void *);
void	gbe_attach(struct device *, struct device *, void *);
int	gbe_activate(struct device *, int);

struct cfattach gbe_ca = {
	sizeof (struct gbe_softc), gbe_match, gbe_attach,
	NULL, gbe_activate
};

struct cfdriver gbe_cd = {
	NULL, "gbe", DV_DULL
};

int
gbe_match(struct device *parent, void *cf, void *aux)
{
	struct mainbus_attach_args *maa = aux;

	if (strcmp(maa->maa_name, gbe_cd.cd_name) != 0)
		return 0;

	return 1;
}

void
gbe_attach(struct device *parent, struct device *self, void *aux)
{
	struct gbe_softc *gsc = (void*)self;
	struct gbe_screen *screen;
	struct wsemuldisplaydev_attach_args waa;
	bus_dma_segment_t tm_segs[1];
	bus_dma_segment_t fb_segs[1];
	bus_dma_segment_t ro_segs[1];
	bus_dmamap_t tm_dmamap;
	bus_dmamap_t fb_dmamap;
	bus_dmamap_t ro_dmamap;
	int tm_nsegs;
	int fb_nsegs;
	int ro_nsegs;
	uint32_t val;
	long attr;

	printf(": ");

	/* GBE isn't strictly on the crimebus, but use this for now... */
	gsc->iot = &crimebus_tag;
	gsc->dmat = &mace_bus_dma_tag;
	gsc->console = gbe_console;
	gsc->screens = 0;

	if (gsc->console == 1) {

		/*
		 * We've already been setup via gbe_cnattach().
		 */

		gsc->ioh = PHYS_TO_XKPHYS(GBE_BASE, CCA_NC);
		gsc->re_ioh = PHYS_TO_XKPHYS(RE_BASE, CCA_NC);

		gsc->rev = bus_space_read_4(gsc->iot, gsc->ioh, GBE_CTRL_STAT)
		    & 0xf;

		gsc->curscr = &gbe_consdata;
		gbe_consdata.sc = (void*)self;

		printf("rev %u, %iMB, %dx%d at %d bits\n", gsc->rev,
		    gbe_consdata.fb_size >> 20, gbe_consdata.width,
		    gbe_consdata.height, gbe_consdata.depth);

		waa.console = gsc->console;
		waa.scrdata = &gbe_screenlist;
		waa.accessops = &gbe_accessops;
		waa.accesscookie = &gbe_consdata;
		waa.defaultscreens = 0;
		config_found(self, &waa, wsemuldisplaydevprint);

		return;
	}

	/*
	 * Setup screen data.
	 */
	gsc->curscr = malloc(sizeof(struct gbe_screen), M_DEVBUF, M_NOWAIT);
	if (gsc->curscr == NULL) {
		printf("failed to allocate screen memory!\n");
		return;
	}
	gsc->curscr->sc = (void *)gsc;
	screen = gsc->curscr;

	/* 
	 * Setup bus space mappings.
	 */
	if (bus_space_map(gsc->iot, GBE_BASE - CRIMEBUS_BASE, GBE_REG_SIZE, 
	    BUS_SPACE_MAP_LINEAR, &gsc->ioh)) {
		printf("failed to map framebuffer bus space!\n");
		return;
	}

	if (bus_space_map(gsc->iot, RE_BASE - CRIMEBUS_BASE, RE_REG_SIZE, 
	    BUS_SPACE_MAP_LINEAR, &gsc->re_ioh)) {
		printf("failed to map rendering engine bus space!\n");
		goto fail0;
	}

	/* Determine GBE revision. */
	gsc->rev = bus_space_read_4(gsc->iot, gsc->ioh, GBE_CTRL_STAT) & 0xf;

	/* Determine resolution configured by firmware. */
	val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_VT_HCMAP);
	screen->width = (val >> GBE_VT_HCMAP_ON_SHIFT) & 0xfff;
	val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_VT_VCMAP);
	screen->height = (val >> GBE_VT_VCMAP_ON_SHIFT) & 0xfff;

	if (screen->width == 0 || screen->height == 0) {
		printf("device has not been setup by firmware!\n");
		goto fail1;
	}

	/* Setup screen defaults. */
	screen->fb_size = GBE_FB_SIZE;
	screen->tm_size = GBE_TLB_SIZE * sizeof(uint16_t);
	screen->depth = 8;
	screen->linebytes = screen->width * screen->depth / 8;

	/* 
	 * Setup DMA for tilemap.
	 */
	if (bus_dmamap_create(gsc->dmat, screen->tm_size, 1, screen->tm_size,
	    0, BUS_DMA_NOWAIT, &tm_dmamap)) {
		printf("failed to create DMA map for tilemap!\n");
		goto fail1;
	}

	if (bus_dmamem_alloc(gsc->dmat, screen->tm_size, 65536, 0, tm_segs, 1,
	    &tm_nsegs, BUS_DMA_NOWAIT)) {
		printf("failed to allocate DMA memory for tilemap!\n");
		goto fail2;
	}

	if (bus_dmamem_map(gsc->dmat, tm_segs, tm_nsegs, screen->tm_size,
	    &screen->tm, BUS_DMA_COHERENT)) {
		printf("failed to map DMA memory for tilemap!\n");
		goto fail3;
	}

	if (bus_dmamap_load(gsc->dmat, tm_dmamap, screen->tm, screen->tm_size,
	    NULL, BUS_DMA_NOWAIT)){
		printf("failed to load DMA map for tilemap\n");
		goto fail4;
	}

	/* 
	 * Setup DMA for framebuffer.
	 */
	if (bus_dmamap_create(gsc->dmat, screen->fb_size, 1, screen->fb_size,
	    0, BUS_DMA_NOWAIT, &fb_dmamap)) {
		printf("failed to create DMA map for framebuffer!\n");
		goto fail5;
	}

	if (bus_dmamem_alloc(gsc->dmat, screen->fb_size, 65536, 0, fb_segs, 
	    1, &fb_nsegs, BUS_DMA_NOWAIT)) {
		printf("failed to allocate DMA memory for framebuffer!\n");
		goto fail6;
	}

	if (bus_dmamem_map(gsc->dmat, fb_segs, fb_nsegs, screen->fb_size,
	    &screen->fb, BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) {
		printf("failed to map DMA memory for framebuffer!\n");
		goto fail7;
	}

	if (bus_dmamap_load(gsc->dmat, fb_dmamap, screen->fb, screen->fb_size,
	    NULL, BUS_DMA_NOWAIT)) {
		printf("failed to load DMA map for framebuffer\n");
		goto fail8;
	}

	/* 
	 * Setup DMA for rasops tile.
	 */
	if (bus_dmamap_create(gsc->dmat, GBE_TILE_SIZE, 1, GBE_TILE_SIZE,
	    0, BUS_DMA_NOWAIT, &ro_dmamap)) {
		printf("failed to create DMA map for rasops tile!\n");
		goto fail9;
	}

	if (bus_dmamem_alloc(gsc->dmat, GBE_TILE_SIZE, 65536, 0, ro_segs, 
	    1, &ro_nsegs, BUS_DMA_NOWAIT)) {
		printf("failed to allocate DMA memory for rasops tile!\n");
		goto fail10;
	}

	if (bus_dmamem_map(gsc->dmat, ro_segs, ro_nsegs, GBE_TILE_SIZE,
	    &screen->ro, BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) {
		printf("failed to map DMA memory for rasops tile!\n");
		goto fail11;
	}

	if (bus_dmamap_load(gsc->dmat, ro_dmamap, screen->ro, GBE_TILE_SIZE,
	    NULL, BUS_DMA_NOWAIT)) {
		printf("failed to load DMA map for rasops tile\n");
		goto fail12;
	}

	screen->tm_phys = tm_dmamap->dm_segs[0].ds_addr;
	screen->fb_phys = fb_dmamap->dm_segs[0].ds_addr;
	screen->ro_phys = ro_dmamap->dm_segs[0].ds_addr;

	gbe_init_screen(screen);
	gbe_disable(gsc);
	gbe_setup(gsc);
	gbe_enable(gsc);

	/* Load colourmap if required. */
	if (screen->depth == 8)
		gbe_loadcmap(screen, 0, 255);

	/* Clear framebuffer. */
	gbe_fillrect(gsc, 0, 0, screen->width, screen->height, 0);

	printf("rev %u, %iMB, %dx%d at %d bits\n", gsc->rev,
	    screen->fb_size >> 20, screen->width, screen->height,
	    screen->depth);

	/*
	 * Attach wsdisplay.
	 */

	/* Attach as console if necessary. */
	if (strncmp(bios_console, "video", 5) == 0) {
		screen->ri.ri_ops.alloc_attr(&screen->ri, 0, 0, 0, &attr);
		wsdisplay_cnattach(&gbe_stdscreen, &screen->ri, 0, 0, attr);
		gsc->console = 1;
	}

	waa.console = gsc->console;
	waa.scrdata = &gbe_screenlist;
	waa.accessops = &gbe_accessops;
	waa.accesscookie = screen;
	waa.defaultscreens = 0;
	config_found(self, &waa, wsemuldisplaydevprint);

	return;

fail12:
	bus_dmamem_unmap(gsc->dmat, screen->ro, GBE_TILE_SIZE);
fail11:
	bus_dmamem_free(gsc->dmat, ro_segs, ro_nsegs);
fail10:
	bus_dmamap_destroy(gsc->dmat, ro_dmamap);
fail9:
	bus_dmamap_unload(gsc->dmat, fb_dmamap);
fail8:
	bus_dmamem_unmap(gsc->dmat, screen->fb, screen->fb_size);
fail7:
	bus_dmamem_free(gsc->dmat, fb_segs, fb_nsegs);
fail6:
	bus_dmamap_destroy(gsc->dmat, fb_dmamap);
fail5:
	bus_dmamap_unload(gsc->dmat, tm_dmamap);
fail4:
	bus_dmamem_unmap(gsc->dmat, screen->tm, screen->tm_size);
fail3:
	bus_dmamem_free(gsc->dmat, tm_segs, tm_nsegs);
fail2:
	bus_dmamap_destroy(gsc->dmat, tm_dmamap);
fail1:
	bus_space_unmap(gsc->iot, gsc->re_ioh, RE_REG_SIZE);
fail0:
	bus_space_unmap(gsc->iot, gsc->ioh, GBE_REG_SIZE);
}

int
gbe_activate(struct device *self, int act)
{
	struct gbe_softc *gsc = (struct gbe_softc *)self;
	int ret = 0;

	switch (act) {
	case DVACT_POWERDOWN:
		gbe_disable(gsc);
		break;
	}

	return (ret);
}

/*
 * GBE hardware specific functions.
 */

void
gbe_init_screen(struct gbe_screen *screen)
{
	uint16_t *tm;
	int i;

	/*
	 * Initialise screen.
	 */
	screen->mode = WSDISPLAYIO_MODE_EMUL;

	/* Initialise rasops. */
	memset(&screen->ri, 0, sizeof(struct rasops_info));

	screen->ri.ri_flg = RI_CENTER;
	screen->ri.ri_depth = screen->depth;
	screen->ri.ri_width = screen->width;
	screen->ri.ri_height = screen->height;
	screen->ri.ri_bits = (void *)screen->fb;
	screen->ri.ri_stride = screen->linebytes;

	if (screen->depth == 32) {
		screen->ri.ri_rpos = 24;
		screen->ri.ri_rnum = 8;
		screen->ri.ri_gpos = 16;
		screen->ri.ri_gnum = 8;
		screen->ri.ri_bpos = 8;
		screen->ri.ri_bnum = 8;
	} else if (screen->depth == 16) {
		screen->ri.ri_rpos = 10;
		screen->ri.ri_rnum = 5;
		screen->ri.ri_gpos = 5;
		screen->ri.ri_gnum = 5;
		screen->ri.ri_bpos = 0;
		screen->ri.ri_bnum = 5;
	}

	rasops_init(&screen->ri, screen->height / 8, screen->width / 8);

	/* Create a rasops instance that can draw into a single tile. */
	memcpy(&screen->ri_tile, &screen->ri, sizeof(struct rasops_info));
	screen->ri_tile.ri_flg = 0;
	screen->ri_tile.ri_width = GBE_TILE_WIDTH >> (screen->depth >> 4);
	screen->ri_tile.ri_height = GBE_TILE_HEIGHT;
	screen->ri_tile.ri_stride = screen->ri_tile.ri_width *
	    screen->depth / 8;
	screen->ri_tile.ri_xorigin = 0;
	screen->ri_tile.ri_yorigin = 0;
	screen->ri_tile.ri_bits = screen->ro;
	screen->ri_tile.ri_origbits = screen->ro;
	screen->ro_curpos = 0;

	screen->ri.ri_hw = screen->sc;

	screen->ri.ri_do_cursor = gbe_do_cursor;
	screen->ri.ri_ops.putchar = gbe_putchar;
	screen->ri.ri_ops.copyrows = gbe_copyrows;
	screen->ri.ri_ops.copycols = gbe_copycols;
	screen->ri.ri_ops.eraserows = gbe_eraserows;
	screen->ri.ri_ops.erasecols = gbe_erasecols;

	gbe_stdscreen.ncols = screen->ri.ri_cols;
	gbe_stdscreen.nrows = screen->ri.ri_rows;
	gbe_stdscreen.textops = &screen->ri.ri_ops;
	gbe_stdscreen.fontwidth = screen->ri.ri_font->fontwidth;
	gbe_stdscreen.fontheight = screen->ri.ri_font->fontheight;
	gbe_stdscreen.capabilities = screen->ri.ri_caps;

	/*
	 * Map framebuffer into tilemap. Each entry in the tilemap is 16 bits 
	 * wide. Each tile is 64KB or 2^16 bits, hence the last 16 bits of the 
	 * address will range from 0x0000 to 0xffff. As a result we simply 
	 * discard the lower 16 bits and store bits 17 through 32 as an entry
	 * in the tilemap.
	 */
	tm = (void *)screen->tm;
	for (i = 0; i < (screen->fb_size >> GBE_TILE_SHIFT) &&
	    i < GBE_TLB_SIZE; i++)
		tm[i] = (screen->fb_phys >> GBE_TILE_SHIFT) + i;
}

void
gbe_enable(struct gbe_softc *gsc)
{
	struct gbe_screen *screen = gsc->curscr;
	uint32_t val;
	int i;

	/* Enable dot clock. */
	val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_DOTCLOCK);
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_DOTCLOCK, 
	    val | GBE_DOTCLOCK_RUN);
	for (i = 0; i < 10000; i++) {
		val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_DOTCLOCK);
		if ((val & GBE_DOTCLOCK_RUN) == GBE_DOTCLOCK_RUN)
			break;
		delay(10);
	}
	if (i == 10000)
		printf("timeout enabling dot clock!\n");

	/* Unfreeze pixel counter. */
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_VT_XY, 0);
	for (i = 0; i < 10000; i++) {
		val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_VT_XY);
		if ((val & GBE_VT_XY_FREEZE) == 0)
			break;
		delay(10);
	}
	if (i == 10000)
		printf("timeout unfreezing pixel counter!\n");

	/* Disable sync-on-green. */
	if (strcmp(osloadoptions, "nosog") == 0)
		bus_space_write_4(gsc->iot, gsc->ioh, GBE_VT_FLAGS,
		    GBE_VT_SYNC_LOW);

	/* Provide GBE with address of tilemap and enable DMA. */
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_FB_CTRL, 
	    ((screen->tm_phys >> 9) << 
	    GBE_FB_CTRL_TILE_PTR_SHIFT) | GBE_FB_CTRL_DMA_ENABLE);
}

void
gbe_disable(struct gbe_softc *gsc)
{
	uint32_t val;
	int i;

	/* Nothing to do if the pixel counter is frozen! */
	val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_VT_XY);
	if ((val & GBE_VT_XY_FREEZE) == GBE_VT_XY_FREEZE)
		return;

	/* Enable sync-on-green. */
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_VT_FLAGS, 0);

	val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_DOTCLOCK);
	if ((val & GBE_DOTCLOCK_RUN) == 0) 
		return;

	/* Disable overlay and turn off hardware cursor. */
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_OVERLAY_TILE, 0);
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_CURSOR_CTRL, 0);
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_DID_CTRL, 0);

	/* Disable DMA. */
	val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_OVERLAY_CTRL);
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_OVERLAY_CTRL, 
	    val & ~GBE_OVERLAY_CTRL_DMA_ENABLE);
	val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_FB_CTRL);
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_FB_CTRL, 
	    val & ~GBE_FB_CTRL_DMA_ENABLE);
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_DID_CTRL, 0);
	for (i = 0; i < 100000; i++) {
		if ((bus_space_read_4(gsc->iot, gsc->ioh, GBE_OVERLAY_HW_CTRL)
		    & GBE_OVERLAY_CTRL_DMA_ENABLE) == 0 &&
		    (bus_space_read_4(gsc->iot, gsc->ioh, GBE_FB_HW_CTRL)
		    & GBE_FB_CTRL_DMA_ENABLE) == 0 &&
		    bus_space_read_4(gsc->iot, gsc->ioh, GBE_DID_HW_CTRL) == 0)
			break;
		delay(10);
	}
	if (i == 100000)
		printf("timeout disabling DMA!\n");

	/* Wait for the end of pixel refresh. */
	val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_VT_VPIX)
	    & GBE_VT_VPIX_OFF_MASK;
	for (i = 0; i < 100000; i++) {
		if (((bus_space_read_4(gsc->iot, gsc->ioh, GBE_VT_XY)
		    & GBE_VT_XY_Y_MASK) >> GBE_VT_XY_Y_SHIFT) < val)
			break;
		delay(1);
	}
	if (i == 100000)
		printf("timeout waiting for pixel refresh!\n");
	for (i = 0; i < 100000; i++) {
		if (((bus_space_read_4(gsc->iot, gsc->ioh, GBE_VT_XY)
		    & GBE_VT_XY_Y_MASK) >> GBE_VT_XY_Y_SHIFT) > val)
			break;
		delay(1);
	}
	if (i == 100000)
		printf("timeout waiting for pixel refresh!\n");

	/* Freeze pixel counter. */
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_VT_XY, GBE_VT_XY_FREEZE);
	for (i = 0; i < 100000; i++) {
		val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_VT_XY);
		if ((val & GBE_VT_XY_FREEZE) == GBE_VT_XY_FREEZE)
			break;
		delay(10);
	}
	if (i == 100000)
		printf("timeout freezing pixel counter!\n");

	/* Disable dot clock. */
	val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_DOTCLOCK);
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_DOTCLOCK, 
	    val & ~GBE_DOTCLOCK_RUN);
	for (i = 0; i < 100000; i++) {
		val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_DOTCLOCK);
		if ((val & GBE_DOTCLOCK_RUN) == 0)
			break;
		delay(10);
	}
	if (i == 100000)
		printf("timeout disabling dot clock!\n");

	/* Reset DMA fifo. */
	val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_FB_SIZE_TILE);
	val &= ~(1 << GBE_FB_SIZE_TILE_FIFO_RESET_SHIFT);
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_FB_SIZE_TILE, 
	    val | (1 << GBE_FB_SIZE_TILE_FIFO_RESET_SHIFT));
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_FB_SIZE_TILE, val);
}

void
gbe_setup(struct gbe_softc *gsc)
{
	struct gbe_screen *screen = gsc->curscr;
	int i, t, cmode, tile_width, tiles_x, tiles_y;
	u_char *colour;
	uint16_t *tm;
	uint32_t val;
	uint64_t reg;

	/*
	 * Setup framebuffer.
	 */
	switch (screen->depth) {
	case 32:
		cmode = GBE_CMODE_RGB8;
		screen->bufmode = COLOUR_DEPTH_32 << BUFMODE_BUFDEPTH_SHIFT |
		    PIXEL_TYPE_RGB << BUFMODE_PIXTYPE_SHIFT |
		    COLOUR_DEPTH_32 << BUFMODE_PIXDEPTH_SHIFT;
		break;
	case 16:
		cmode = GBE_CMODE_ARGB5;
		screen->bufmode = COLOUR_DEPTH_16 << BUFMODE_BUFDEPTH_SHIFT |
		    PIXEL_TYPE_RGBA << BUFMODE_PIXTYPE_SHIFT |
		    COLOUR_DEPTH_16 << BUFMODE_PIXDEPTH_SHIFT;
		break;
	case 8:
	default:
		cmode = GBE_CMODE_I8;
		screen->bufmode = COLOUR_DEPTH_8 << BUFMODE_BUFDEPTH_SHIFT |
		    PIXEL_TYPE_CI << BUFMODE_PIXTYPE_SHIFT |
		    COLOUR_DEPTH_8 << BUFMODE_PIXDEPTH_SHIFT;
		break;
	}

	/* Calculate tile width in bytes and screen size in tiles. */
	tile_width = GBE_TILE_WIDTH >> (screen->depth >> 4);
	tiles_x = (screen->width + tile_width - 1) >>
	    (GBE_TILE_WIDTH_SHIFT - (screen->depth >> 4));
	tiles_y = (screen->height + GBE_TILE_HEIGHT - 1) >>
	    GBE_TILE_HEIGHT_SHIFT;

	if (screen->mode != WSDISPLAYIO_MODE_EMUL) {

		/*
		 * Setup the framebuffer in "linear" mode. We trick the
		 * framebuffer into linear mode by telling it that it is one
		 * tile wide and specifying an adjusted framebuffer height.
		 */ 

		bus_space_write_4(gsc->iot, gsc->ioh, GBE_FB_SIZE_TILE,
		    ((screen->depth >> 4) << GBE_FB_SIZE_TILE_DEPTH_SHIFT) |
		    (1 << GBE_FB_SIZE_TILE_WIDTH_SHIFT));

		bus_space_write_4(gsc->iot, gsc->ioh, GBE_FB_SIZE_PIXEL, 
		    (screen->width * screen->height / tile_width) <<
		        GBE_FB_SIZE_PIXEL_HEIGHT_SHIFT);

	} else {

		/*
		 * Setup the framebuffer in tiled mode. Provide the tile
		 * colour depth, screen width in whole and partial tiles,
		 * and the framebuffer height in pixels.
		 */

		bus_space_write_4(gsc->iot, gsc->ioh, GBE_FB_SIZE_TILE,
		    ((screen->depth >> 4) << GBE_FB_SIZE_TILE_DEPTH_SHIFT) |
		    ((screen->width / tile_width) <<
		        GBE_FB_SIZE_TILE_WIDTH_SHIFT) |
		    (((screen->width % tile_width) >> (screen->depth >> 4)) /
		        32));

		bus_space_write_4(gsc->iot, gsc->ioh, GBE_FB_SIZE_PIXEL, 
		    screen->height << GBE_FB_SIZE_PIXEL_HEIGHT_SHIFT);

	}

	/* Set colour mode registers. */
	val = (cmode << GBE_WID_MODE_SHIFT) | GBE_BMODE_BOTH;
	for (i = 0; i < (32 * 4); i += 4)
		bus_space_write_4(gsc->iot, gsc->ioh, GBE_MODE + i, val);

	/*
	 * Initialise colourmap if required.
	 */
	if (screen->depth == 8) {
		for (i = 0; i < 16; i++) {
			colour = (u_char *)&rasops_cmap[i * 3];
			screen->cmap.cm_red[i] = colour[0];
			screen->cmap.cm_green[i] = colour[1];
			screen->cmap.cm_blue[i] = colour[2];
		}
		for (i = 240; i < 256; i++) {
			colour = (u_char *)&rasops_cmap[i * 3];
			screen->cmap.cm_red[i] = colour[0];
			screen->cmap.cm_green[i] = colour[1];
			screen->cmap.cm_blue[i] = colour[2];
		}
	}

	/*
	 * Setup an alpha ramp.
	 */
	for (i = 0; i < GBE_GMAP_ENTRIES; i++)
		bus_space_write_4(gsc->iot, gsc->ioh,
		    GBE_GMAP + i * sizeof(u_int32_t),
		    (i << 24) | (i << 16) | (i << 8));

	/*
	 * Initialise the rendering engine.
	 */
	val = screen->mode | BUF_TYPE_TLB_A << BUFMODE_BUFTYPE_SHIFT;
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_BUFMODE_SRC, val);
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_BUFMODE_DST, val);
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_CLIPMODE, 0);
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_COLOUR_MASK, 0xffffffff);
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_PIXEL_XFER_X_STEP, 1);
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_PIXEL_XFER_Y_STEP, 1);
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_WINOFFSET_DST, 0);
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_WINOFFSET_SRC, 0);

	/*
	 * Load framebuffer tiles into TLB A. Each TLB consists of a 16x16
	 * tile array representing 2048x2048 pixels. Each entry in the TLB
	 * consists of four 16-bit entries which represent bits 17:32 of the
	 * 64KB tile address. As a result, we can make use of the tilemap
	 * which already stores tile entries in the same format.
	 */
	tm = (void *)screen->tm;
	for (i = 0, t = 0; i < GBE_TLB_SIZE; i++) {
		reg <<= 16;
		if (i % 16 < tiles_x)
			reg |= (tm[t++] | 0x8000);
		if (i % 4 == 3)
			bus_space_write_8(gsc->iot, gsc->re_ioh,
			    RE_TLB_A + (i >> 2) * 8, reg);
	}

	/* Load single tile into TLB B for rasops. */
	bus_space_write_8(gsc->iot, gsc->re_ioh,
	    RE_TLB_B, (screen->ro_phys >> 16 | 0x8000) << 48);
}

void
gbe_wait_re_idle(struct gbe_softc *gsc)
{
	int i;

	/* Wait until rendering engine is idle. */
	for (i = 0; i < 100000; i++) {
		if (bus_space_read_4(gsc->iot, gsc->re_ioh, RE_PP_STATUS) &
		    RE_PP_STATUS_IDLE)
			break; 
		delay(1);
	}
	if (i == 100000)
		printf("%s: rendering engine did not become idle!\n",
		    gsc->sc_dev.dv_xname);
}

/*
 * Interfaces for wscons.
 */

int
gbe_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct gbe_screen *screen = (struct gbe_screen *)v;
	int rc, mode;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_GBE;
		break;

	case WSDISPLAYIO_GINFO:
	{
		struct wsdisplay_fbinfo *fb = (struct wsdisplay_fbinfo *)data;

		fb->height = screen->height;
		fb->width = screen->width;
		fb->depth = screen->depth;
		fb->cmsize = screen->depth == 8 ? 256 : 0;
	}
		break;

	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = screen->linebytes;
		break;

	case WSDISPLAYIO_GETCMAP:
		if (screen->depth == 8) {
			struct wsdisplay_cmap *cm =
			    (struct wsdisplay_cmap *)data;

			rc = gbe_getcmap(&screen->cmap, cm);
			if (rc != 0)
				return (rc);
		}
		break;

	case WSDISPLAYIO_PUTCMAP:
		if (screen->depth == 8) {
			struct wsdisplay_cmap *cm =
			    (struct wsdisplay_cmap *)data;

			rc = gbe_putcmap(&screen->cmap, cm);
			if (rc != 0)
				return (rc);
			gbe_loadcmap(screen, cm->index, cm->index + cm->count);
		}
		break;

	case WSDISPLAYIO_GMODE:
		*(u_int *)data = screen->mode;
		break;

	case WSDISPLAYIO_SMODE:
		mode = *(u_int *)data;
		if (mode == WSDISPLAYIO_MODE_EMUL ||
		    mode == WSDISPLAYIO_MODE_MAPPED ||
		    mode == WSDISPLAYIO_MODE_DUMBFB) {

			screen->mode = mode;

			gbe_disable((struct gbe_softc *)screen->sc);
			gbe_setup((struct gbe_softc *)screen->sc);
			gbe_enable((struct gbe_softc *)screen->sc);

			/* Clear framebuffer if entering emulated mode. */
			if (screen->mode == WSDISPLAYIO_MODE_EMUL)
				gbe_fillrect((struct gbe_softc *)screen->sc,
				    0, 0, screen->width, screen->height, 0);
		}
		break;

	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_SVIDEO:
		/* Handled by the upper layer. */
		break;

	default:
		return (-1);
	}

	return (0);
}

paddr_t
gbe_mmap(void *v, off_t offset, int protection)
{
	struct gbe_screen *screen = (void *)v;
	paddr_t pa;

	if (offset >= 0 && offset < screen->fb_size)
		pa = screen->fb_phys + offset;
	else
		pa = -1;

	return (pa);
}

int
gbe_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *attrp)
{
	struct gbe_screen *screen = (struct gbe_screen *)v;
	struct gbe_softc *gsc = (struct gbe_softc *)screen->sc;

	/* We do not allow multiple consoles at the moment. */
	if (gsc->screens > 0)
		return (ENOMEM);

	gsc->screens++;

	/* Return rasops_info via cookie. */
	*cookiep = &screen->ri;

	/* Move cursor to top left of screen. */
	*curxp = 0;
	*curyp = 0;

	/* Correct screen attributes. */
	screen->ri.ri_ops.alloc_attr(&screen->ri, 0, 0, 0, attrp);

	return (0);
}

void
gbe_free_screen(void *v, void *cookie)
{
	/* We do not allow multiple consoles at the moment. */
}

int
gbe_show_screen(void *v, void *cookie, int waitok, void (*cb)(void *, int, int),
    void *cbarg)
{
	/* We do not allow multiple consoles at the moment. */
	return (0);
}

int
gbe_load_font(void *v, void *emulcookie, struct wsdisplay_font *font)
{
	struct gbe_screen *screen = (struct gbe_screen *)v;

	return rasops_load_font(&screen->ri, emulcookie, font);
}

int
gbe_list_font(void *v, struct wsdisplay_font *font)
{
	struct gbe_screen *screen = (struct gbe_screen *)v;

	return rasops_list_font(&screen->ri, font);
}

/*
 * Colour map handling for indexed modes.
 */

void
gbe_setcolour(struct gbe_softc *gsc, u_int index, u_int8_t r, u_int8_t g,
    u_int8_t b)
{
	int i;

	/* Wait until the colourmap FIFO has free space. */
	for (i = 0; i < 10000; i++) {
		if (bus_space_read_4(gsc->iot, gsc->ioh, GBE_CMAP_FIFO)
		    < GBE_CMAP_FIFO_ENTRIES) 
			break;
		delay(10);
	}
	if (i == 10000)
		printf("colourmap FIFO has no free space!\n");

	bus_space_write_4(gsc->iot, gsc->ioh,
	    GBE_CMAP + index * sizeof(u_int32_t),
	    ((u_int)r << 24) | ((u_int)g << 16) | ((u_int)b << 8));
}

int
gbe_getcmap(struct gbe_cmap *cm, struct wsdisplay_cmap *rcm)
{
	u_int index = rcm->index, count = rcm->count;
	int rc;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);

	if ((rc = copyout(&cm->cm_red[index], rcm->red, count)) != 0)
		return (rc);
	if ((rc = copyout(&cm->cm_green[index], rcm->green, count)) != 0)
		return (rc);
	if ((rc = copyout(&cm->cm_blue[index], rcm->blue, count)) != 0)
		return (rc);

	return (0);
}

int
gbe_putcmap(struct gbe_cmap *cm, struct wsdisplay_cmap *rcm)
{
	u_int index = rcm->index, count = rcm->count;
	int rc;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);

	if ((rc = copyin(rcm->red, &cm->cm_red[index], count)) != 0)
		return (rc);
	if ((rc = copyin(rcm->green, &cm->cm_green[index], count)) != 0)
		return (rc);
	if ((rc = copyin(rcm->blue, &cm->cm_blue[index], count)) != 0)
		return (rc);

	return (0);
}

void
gbe_loadcmap(struct gbe_screen *screen, u_int start, u_int end)
{
	struct gbe_softc *gsc = (void *)screen->sc;
	struct gbe_cmap *cm = &screen->cmap;

	for (; start <= end; start++)
		gbe_setcolour(gsc, start,
		    cm->cm_red[start], cm->cm_green[start], cm->cm_blue[start]);
}

/*
 * Hardware accelerated functions for rasops.
 */

void
gbe_rop(struct gbe_softc *gsc, int x, int y, int w, int h, int op)
{
	gbe_wait_re_idle(gsc);

	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_PRIMITIVE,
	    PRIMITIVE_RECTANGLE | PRIMITIVE_LRTB);
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_DRAWMODE,
	    DRAWMODE_BITMASK | DRAWMODE_BYTEMASK | DRAWMODE_PIXEL_XFER |
	    DRAWMODE_LOGIC_OP);
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_LOGIC_OP, op);
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_PIXEL_XFER_SRC,
	    (x << 16) | (y & 0xffff));
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_VERTEX_X_0,
	    (x << 16) | (y & 0xffff));
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_VERTEX_X_1 | RE_START,
	    ((x + w - 1) << 16) | ((y + h - 1) & 0xffff));
}

void
gbe_copyrect(struct gbe_softc *gsc, int src, int sx, int sy, int dx, int dy,
    int w, int h)
{
	int direction, x0, y0, x1, y1;

	if (sx >= dx && sy >= dy) {
		direction = PRIMITIVE_LRTB;
		x0 = dx;
		y0 = dy;
		x1 = dx + w - 1;
		y1 = dy + h - 1;
	} else if (sx >= dx && sy < dy) {
		direction = PRIMITIVE_LRBT;
		sy = sy + h - 1;
		x0 = dx;
		y0 = dy + h - 1;
		x1 = dx + w - 1;
		y1 = dy;
	} else if (sx < dx && sy >= dy) {
		direction = PRIMITIVE_RLTB;
		sx = sx + w - 1;
		x0 = dx + w - 1;
		y0 = dy;
		x1 = dx;
		y1 = dy + h - 1;
	} else if (sx < dx && sy < dy) {
		direction = PRIMITIVE_RLBT;
		sy = sy + h - 1;
		sx = sx + w - 1;
		x0 = dx + w - 1;
		y0 = dy + h - 1;
		x1 = dx;
		y1 = dy;
	}

	gbe_wait_re_idle(gsc);

	if (src != BUF_TYPE_TLB_A) 
		bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_BUFMODE_SRC,
		    gsc->curscr->bufmode | (src << BUFMODE_BUFTYPE_SHIFT));

	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_PRIMITIVE,
	    PRIMITIVE_RECTANGLE | direction);
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_DRAWMODE,
	    DRAWMODE_BITMASK | DRAWMODE_BYTEMASK | DRAWMODE_PIXEL_XFER);
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_PIXEL_XFER_SRC,
	    (sx << 16) | (sy & 0xffff));
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_VERTEX_X_0,
	    (x0 << 16) | (y0 & 0xffff));
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_VERTEX_X_1 | RE_START,
	    (x1 << 16) | (y1 & 0xffff));

	if (src != BUF_TYPE_TLB_A) {
		gbe_wait_re_idle(gsc);
		bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_BUFMODE_SRC,
		    gsc->curscr->bufmode |
		    (BUF_TYPE_TLB_A << BUFMODE_BUFTYPE_SHIFT));
	}
}

void
gbe_fillrect(struct gbe_softc *gsc, int x, int y, int w, int h, int bg)
{

	gbe_wait_re_idle(gsc);

	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_PRIMITIVE,
	    PRIMITIVE_RECTANGLE | PRIMITIVE_LRTB);
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_DRAWMODE,
	    DRAWMODE_BITMASK | DRAWMODE_BYTEMASK);
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_SHADE_FG_COLOUR, bg);
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_VERTEX_X_0,
	    (x << 16) | (y & 0xffff));
	bus_space_write_4(gsc->iot, gsc->re_ioh, RE_PP_VERTEX_X_1 | RE_START,
	    ((x + w - 1) << 16) | ((y + h - 1) & 0xffff));
}

int
gbe_do_cursor(struct rasops_info *ri)
{
	struct gbe_softc *sc = ri->ri_hw;
	int y, x, w, h;

	w = ri->ri_font->fontwidth;
	h = ri->ri_font->fontheight;
	x = ri->ri_xorigin + ri->ri_ccol * w;
	y = ri->ri_yorigin + ri->ri_crow * h;

	gbe_rop(sc, x, y, w, h, OPENGL_LOGIC_OP_COPY_INVERTED);

	return 0;
}

int
gbe_putchar(void *cookie, int row, int col, u_int uc, long attr)
{
	struct rasops_info *ri = cookie;
	struct gbe_softc *gsc = ri->ri_hw;
	struct gbe_screen *screen = gsc->curscr;
	struct rasops_info *ri_tile = &screen->ri_tile;
	int x, y, w, h;

	w = ri->ri_font->fontwidth;
	h = ri->ri_font->fontheight;
	x = ri->ri_xorigin + col * w;
	y = ri->ri_yorigin + row * h;

	ri_tile->ri_ops.putchar(ri_tile, 0, screen->ro_curpos, uc, attr);

	gbe_copyrect(gsc, BUF_TYPE_TLB_B, screen->ro_curpos * w, 0, x, y, w, h);

	screen->ro_curpos++;
	if ((screen->ro_curpos + 1) * w > screen->ri_tile.ri_width)
		screen->ro_curpos = 0;

	return 0;
}

int
gbe_copycols(void *cookie, int row, int src, int dst, int num)
{
	struct rasops_info *ri = cookie;
	struct gbe_softc *sc = ri->ri_hw;

	num *= ri->ri_font->fontwidth;
	src *= ri->ri_font->fontwidth;
	dst *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	gbe_copyrect(sc, BUF_TYPE_TLB_A, ri->ri_xorigin + src,
	    ri->ri_yorigin + row, ri->ri_xorigin + dst, ri->ri_yorigin + row,
	    num, ri->ri_font->fontheight);

	return 0;
}

int
gbe_erasecols(void *cookie, int row, int col, int num, long attr)
{
	struct rasops_info *ri = cookie;
	struct gbe_softc *sc = ri->ri_hw;
	int bg, fg;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);

	row *= ri->ri_font->fontheight;
	col *= ri->ri_font->fontwidth;
	num *= ri->ri_font->fontwidth;

	gbe_fillrect(sc, ri->ri_xorigin + col, ri->ri_yorigin + row,
	    num, ri->ri_font->fontheight, ri->ri_devcmap[bg]);

	return 0;
}

int
gbe_copyrows(void *cookie, int src, int dst, int num)
{
	struct rasops_info *ri = cookie;
	struct gbe_softc *sc = ri->ri_hw;
	
	num *= ri->ri_font->fontheight;
	src *= ri->ri_font->fontheight;
	dst *= ri->ri_font->fontheight;

	gbe_copyrect(sc, BUF_TYPE_TLB_A, ri->ri_xorigin, ri->ri_yorigin + src,
	    ri->ri_xorigin, ri->ri_yorigin + dst, ri->ri_emuwidth, num);

	return 0;
}

int
gbe_eraserows(void *cookie, int row, int num, long attr)
{
	struct rasops_info *ri = cookie;
	struct gbe_softc *sc = ri->ri_hw;
	int x, y, w, bg, fg;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);

	if ((num == ri->ri_rows) && ISSET(ri->ri_flg, RI_FULLCLEAR)) {
		num = ri->ri_height;
		x = y = 0;
		w = ri->ri_width;
	} else {
		num *= ri->ri_font->fontheight;
		x = ri->ri_xorigin;
		y = ri->ri_yorigin + row * ri->ri_font->fontheight;
		w = ri->ri_emuwidth;
	}

	gbe_fillrect(sc, x, y, w, num, ri->ri_devcmap[bg]);

	return 0;
}

/*
 * Console functions for early display.
 */

int
gbe_cnprobe(bus_space_tag_t iot, bus_addr_t addr)
{
	bus_space_handle_t ioh;
	int val, width, height;

	/* Setup bus space mapping. */
	ioh = PHYS_TO_XKPHYS(addr, CCA_NC);

	/* Determine resolution configured by firmware. */
	val = bus_space_read_4(iot, ioh, GBE_VT_HCMAP);
	width = (val >> GBE_VT_HCMAP_ON_SHIFT) & 0xfff;
	val = bus_space_read_4(iot, ioh, GBE_VT_VCMAP);
	height = (val >> GBE_VT_VCMAP_ON_SHIFT) & 0xfff;

	/* Ensure that the firmware has setup the device. */
	if (width != 0 && height != 0)
		return (1);
	else
		return (0);
}

int
gbe_cnattach(bus_space_tag_t iot, bus_addr_t addr)
{
	struct gbe_softc *gsc;
	uint32_t val;
	paddr_t pa;
	vaddr_t va;
	long attr;

	/*
	 * Setup GBE for use as early console.
	 */
	va = pmap_steal_memory(sizeof(struct gbe_softc), NULL, NULL);
	gsc = (struct gbe_softc *)va;
	gsc->curscr = &gbe_consdata;
	gbe_consdata.sc = (struct device *)gsc;
	
	/* Setup bus space mapping. */
	gsc->iot = iot;
	gsc->ioh = PHYS_TO_XKPHYS(addr, CCA_NC);
	gsc->re_ioh = PHYS_TO_XKPHYS(RE_BASE, CCA_NC);

	/* Determine GBE revision. */
	gsc->rev = bus_space_read_4(gsc->iot, gsc->ioh, GBE_CTRL_STAT) & 0xf;

	/* Determine resolution configured by firmware. */
	val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_VT_HCMAP);
	gbe_consdata.width = (val >> GBE_VT_HCMAP_ON_SHIFT) & 0xfff;
	val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_VT_VCMAP);
	gbe_consdata.height = (val >> GBE_VT_VCMAP_ON_SHIFT) & 0xfff;

	/* Ensure that the firmware has setup the device. */
	if (gbe_consdata.width == 0 || gbe_consdata.height == 0)
		return (ENXIO);

	/* Setup screen defaults. */
	gbe_consdata.fb_size = GBE_FB_SIZE;
	gbe_consdata.tm_size = GBE_TLB_SIZE * sizeof(uint16_t);
	gbe_consdata.depth = 8;
	gbe_consdata.linebytes = gbe_consdata.width * gbe_consdata.depth / 8;

	/* 
	 * Steal memory for tilemap - 64KB aligned and coherent.
	 */
	va = pmap_steal_memory(gbe_consdata.tm_size + 65536, NULL, NULL);
	pmap_extract(pmap_kernel(), va, &pa);
	gbe_consdata.tm_phys = ((pa >> 16) + 1) << 16;
	gbe_consdata.tm = (caddr_t)PHYS_TO_XKPHYS(gbe_consdata.tm_phys, CCA_NC);
	
	/* 
	 * Steal memory for framebuffer - 64KB aligned and coherent.
	 */
	va = pmap_steal_memory(gbe_consdata.fb_size + 65536, NULL, NULL);
	pmap_extract(pmap_kernel(), va, &pa);
	gbe_consdata.fb_phys = ((pa >> 16) + 1) << 16;
	gbe_consdata.fb = (caddr_t)PHYS_TO_XKPHYS(gbe_consdata.fb_phys, CCA_NC);

	/* 
	 * Steal memory for rasops tile - 64KB aligned and coherent.
	 */
	va = pmap_steal_memory(GBE_TILE_SIZE + 65536, NULL, NULL);
	pmap_extract(pmap_kernel(), va, &pa);
	gbe_consdata.ro_phys = ((pa >> 16) + 1) << 16;
	gbe_consdata.ro = (caddr_t)PHYS_TO_XKPHYS(gbe_consdata.ro_phys, CCA_NC);

	/*
	 * Setup GBE hardware.
	 */
	gbe_init_screen(&gbe_consdata);
	gbe_disable(gsc);
	gbe_setup(gsc);
	gbe_enable(gsc);

	/* Load colourmap if required. */
	if (gbe_consdata.depth == 8)
		gbe_loadcmap(&gbe_consdata, 0, 255);

	/* Clear framebuffer. */
	gbe_fillrect(gsc, 0, 0, gbe_consdata.width, gbe_consdata.height, 0);

	/*
	 * Attach wsdisplay.
	 */
	gbe_consdata.ri.ri_ops.alloc_attr(&gbe_consdata.ri, 0, 0, 0, &attr);
	wsdisplay_cnattach(&gbe_stdscreen, &gbe_consdata.ri, 0, 0, attr);
	gbe_console = 1;

	return (0);
}
@


1.20
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: gbe.c,v 1.19 2013/05/30 16:15:01 deraadt Exp $ */
d131 2
a132 1
void	gbe_burner(void *, u_int, u_int);
d160 2
a161 1
	.burn_screen = gbe_burner
d986 10
a995 2
void
gbe_burner(void *v, u_int on, u_int flags)
d997 3
@


1.19
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: gbe.c,v 1.18 2013/05/27 19:37:45 miod Exp $ */
d154 6
a159 10
	gbe_ioctl,
	gbe_mmap,
	gbe_alloc_screen,
	gbe_free_screen,
	gbe_show_screen,
	NULL,		/* load_font */
	NULL,		/* scrollback */
	NULL,		/* getchar */
	gbe_burner,
	NULL		/* pollc */
@


1.18
log
@Correctly specify the visible part of the rightmost tile when the current
resolution is not a multiple of the tile size, in emulation (text) mode.
The usual 1280x1024 resolution ended up with the correct value, by chance,
but a width of 1600 would be wrong. (X11 was running fine)

Tested on the 1600x1024 resolution of the 1600SW display. Thanks to Johan
Sanchez for lending me a 1600SW monitor and an adapter board.
@
text
@d1 1
a1 1
/*	$OpenBSD: gbe.c,v 1.17 2012/10/03 22:46:09 miod Exp $ */
d176 1
d179 2
a180 1
	sizeof (struct gbe_softc), gbe_match, gbe_attach
a242 2
		shutdownhook_establish((void(*)(void *))gbe_disable, self);

a383 2
	shutdownhook_establish((void(*)(void *))gbe_disable, self);

d446 15
@


1.17
log
@Don't include <mips64/archtype.h> unless you really need it.
@
text
@d1 1
a1 1
/*	$OpenBSD: gbe.c,v 1.16 2012/05/29 17:37:09 mikeb Exp $ */
d742 2
a743 2
		    ((screen->width % tile_width != 0) ?
		        (screen->height / GBE_TILE_HEIGHT) : 0));
@


1.16
log
@Make it possible to disable the Sync-on-Green signal by setting the
ARCBios environment variable OSLoadOptions to "nosog".  Now everyone
can enjoy running O2 without an SGI monitor and don't turn vegetarian
afterwards.  All the essential bits come from NetBSD's crmfb driver
except they've chosen to use a "SyncOnGreen" variable not saved by
the ARCS.  Pointers and corrections from and ok miod, jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: gbe.c,v 1.15 2012/04/16 22:17:13 miod Exp $ */
a33 1
#include <mips64/archtype.h>
@


1.15
log
@Move OpenGL {logic,raster}ops defines to a separate file, to avoid duplicating
these among frame buffer drivers. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: gbe.c,v 1.14 2012/03/15 18:57:22 miod Exp $ */
d567 5
d588 3
@


1.14
log
@uncached_base was introduced early in IP27 support, since these designs use
subspaces in the CCA_NC uncached memory space. However, being coherent,
there was never a need for bus_dma to use uncached addresses.

This means that, on the only systems where uncached_base was not set to
PHYS_TO_XKPHYS(0, CCA_NC), it was never used.

Remove the variable, and replace PHYS_TO_UNCACHED() with
PHYS_TO_XKPHYS(, CCA_NC). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: gbe.c,v 1.13 2010/12/26 15:41:00 miod Exp $ */
d36 1
a1053 1

d1159 1
a1159 1
	gbe_rop(sc, x, y, w, h, LOGIC_OP_XOR);
@


1.13
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: gbe.c,v 1.12 2010/03/08 20:54:42 miod Exp $ */
d228 2
a229 2
		gsc->ioh = PHYS_TO_UNCACHED(GBE_BASE);
		gsc->re_ioh = PHYS_TO_UNCACHED(RE_BASE);
d1278 1
a1278 1
	ioh = PHYS_TO_UNCACHED(addr);
d1312 2
a1313 2
	gsc->ioh = PHYS_TO_UNCACHED(addr);
	gsc->re_ioh = PHYS_TO_UNCACHED(RE_BASE);
d1340 1
a1340 1
	gbe_consdata.tm = (caddr_t)PHYS_TO_UNCACHED(gbe_consdata.tm_phys);
d1348 1
a1348 1
	gbe_consdata.fb = (caddr_t)PHYS_TO_UNCACHED(gbe_consdata.fb_phys);
d1356 1
a1356 1
	gbe_consdata.ro = (caddr_t)PHYS_TO_UNCACHED(gbe_consdata.ro_phys);
@


1.12
log
@Correctly initialize all members of struct wsemuldisplaydev_attach_args
before attaching wsdisplay; it was turning out harmless but using more
cpu time for nothing than necessary.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gbe.c,v 1.11 2010/03/07 13:44:24 miod Exp $ */
d920 1
a920 1
		pa = atop(screen->fb_phys + offset);
@


1.11
log
@Allow iockbc(4) and odysseey(4) to act as console devices and attach early;
this gives us working glass console on Fuel, as well as on Octane systems
with Odyssey graphics.
Joint work with jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gbe.c,v 1.10 2009/10/26 20:14:42 miod Exp $ */
d247 1
d417 1
@


1.10
log
@Rename struct confargs to struct mainbus_attach_args for consistency and also
to prevent further abuse of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: gbe.c,v 1.9 2009/10/26 18:00:06 miod Exp $ */
d1378 1
a1378 1
	return (1);
@


1.9
log
@Better crime/mace interrupt handling; interrupt information is no longer
specified in the kernel configuration file, but is provided by macebus(4)
as part of the  child device attachment args, and provide both crime and
mace interrupt bitmasks; this allows us to only really enable interrupt
sources we care about, and to avoid invoking interrupt handler we don't need
to for the few mace interrupts multiplexed at the crime level.
@
text
@d1 1
a1 1
/*	$OpenBSD: gbe.c,v 1.8 2009/09/05 14:09:35 miod Exp $ */
d188 1
a188 1
	struct confargs *ca = aux;
d190 1
a190 1
	if (strcmp(ca->ca_name, gbe_cd.cd_name) != 0)
@


1.8
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: gbe.c,v 1.7 2009/02/24 14:37:29 jsing Exp $ */
d37 1
a37 1
#include <sgi/localbus/macebus.h>
@


1.7
log
@Add support for hardware acceleration to gbe(4). This provides an accelerated
framebuffer for the console on SGI O2 workstations. X is still supported via
wsfb(4) by switching back to the unaccelerated linear framebuffer mode.

Some hardware details and magic numbers from NetBSD's crmfb(4) driver.

ok miod@@ jasper@@ "Sure, go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gbe.c,v 1.5 2008/02/20 18:46:20 miod Exp $ */
d139 6
a144 6
void	gbe_do_cursor(struct rasops_info *);
void	gbe_putchar(void *, int, int, u_int, long);
void	gbe_copycols(void *, int, int, int, int);
void	gbe_erasecols(void *, int, int, int, long);
void	gbe_copyrows(void *, int, int, int);
void	gbe_eraserows(void *, int, int, long);
d1146 1
a1146 1
void
d1158 2
d1162 1
a1162 1
void
d1183 2
d1187 1
a1187 1
void
d1201 2
d1205 1
a1205 1
void
d1220 2
d1224 1
a1224 1
void
d1236 2
d1240 1
a1240 1
void
d1261 2
@


1.6
log
@Since uncached virtual addresses will depend upon space identifiers on R1xk
systems, switch to the PHYS_TO_UNCACHED macro to compute proper addresses.
Not really necessary for the O2 which does not implement spaces, but can't
hurt either.
@
text
@d4 1
a4 1
 * Copyright (c) 2007, Joel Sing <jsing@@openbsd.org>
d20 1
a20 1
 * Graphics Back End (GBE) Framebuffer for SGI O2
d63 2
a64 1
	struct rasops_info ri;		/* Raster display info. */
d74 2
d80 2
d83 1
d93 2
a94 1
	bus_space_handle_t ioh;
d112 1
d133 13
d204 1
d207 1
d210 1
d229 2
d264 1
a264 1
	 * Setup bus space mapping.
d268 1
a268 1
		printf("failed to map bus space!\n");
d272 6
d289 1
a289 1
		goto fail0;
d299 1
a299 1
	 * Setup DMA for tile map.
d303 2
a304 2
		printf("failed to create DMA map for tile map!\n");
		goto fail0;
d309 2
a310 2
		printf("failed to allocate DMA memory for tile map!\n");
		goto fail1;
d315 2
a316 2
		printf("failed to map DMA memory for tile map!\n");
		goto fail2;
d322 1
a322 1
		goto fail3;
d331 1
a331 1
		goto fail4;
d337 1
a337 1
		goto fail5;
d343 1
a343 1
		goto fail6;
d349 28
a376 1
		goto fail7;
d381 1
d394 3
d420 10
d431 1
a431 1
	bus_dmamem_unmap(gsc->dmat, screen->fb, screen->fb_size);
d433 1
a433 1
	bus_dmamem_free(gsc->dmat, fb_segs, fb_nsegs);
d435 1
a435 1
	bus_dmamap_destroy(gsc->dmat, fb_dmamap);
d437 1
a437 1
	bus_dmamap_unload(gsc->dmat, tm_dmamap);
d439 1
a439 1
	bus_dmamem_unmap(gsc->dmat, screen->tm, screen->tm_size);
d441 1
a441 1
	bus_dmamem_free(gsc->dmat, tm_segs, tm_nsegs);
d443 1
a443 1
	bus_dmamap_destroy(gsc->dmat, tm_dmamap);
d459 1
a459 1
	 * Initialise rasops.
d461 3
d466 1
a466 1
	screen->ri.ri_flg = RI_CENTER | RI_CLEAR;
d491 22
d521 1
a521 1
	 * Map framebuffer into tile map. Each entry in the tilemap is 16 bits 
d528 3
a530 2
	for (i = 0; i < (screen->fb_size >> GBE_TILE_SHIFT); i++)
	    tm[i] = (screen->fb_phys >> GBE_TILE_SHIFT) + i;
d564 1
a564 1
	/* Provide GBE with address of tile map and enable DMA. */
d666 3
d670 1
a670 2
	int i, cmode;
	u_char *colour;
d678 3
d684 3
d691 3
d697 44
a740 9
	/* Trick framebuffer into linear mode. */
	i = screen->width * screen->height / (512 / (screen->depth >> 3));
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_FB_SIZE_PIXEL, 
	    i << GBE_FB_SIZE_PIXEL_HEIGHT_SHIFT);

	bus_space_write_4(gsc->iot, gsc->ioh, GBE_FB_SIZE_TILE,
	    (1 << GBE_FB_SIZE_TILE_WIDTH_SHIFT) | 
	    ((screen->depth >> 4) << GBE_FB_SIZE_TILE_DEPTH_SHIFT));
	
d771 50
d831 1
a831 1
	int rc;
d876 23
d1045 209
d1282 3
a1284 1
	struct gbe_softc gsc;
a1285 2
	paddr_t pa;
	uint32_t val;
d1291 4
a1294 2
	gsc.curscr = &gbe_consdata;
	gbe_consdata.sc = (void *)&gsc;
d1297 3
a1299 2
	gsc.iot = iot;
	gsc.ioh = PHYS_TO_UNCACHED(addr);
d1302 1
a1302 1
	gsc.rev = bus_space_read_4(gsc.iot, gsc.ioh, GBE_CTRL_STAT) & 0xf;
d1305 1
a1305 1
	val = bus_space_read_4(gsc.iot, gsc.ioh, GBE_VT_HCMAP);
d1307 1
a1307 1
	val = bus_space_read_4(gsc.iot, gsc.ioh, GBE_VT_VCMAP);
d1336 8
d1348 3
a1350 3
	gbe_disable(&gsc);
	gbe_setup(&gsc);
	gbe_enable(&gsc);
d1355 3
@


1.5
log
@Completely overhault attachment rules on sgi. No more indirect configuration
inherited from OpenBSD/arc machines with ISA bus; mainbus children match on
device name and other hierarchies match on simplified locators.
As a bonus, attachment lines in dmesg will now print their locators.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gbe.c,v 1.4 2007/12/31 12:46:14 jsing Exp $ */
d204 1
a204 1
		gsc->ioh = PHYS_TO_XKPHYS(GBE_BASE, CCA_NC);
d837 1
a837 1
	ioh = PHYS_TO_XKPHYS(addr, CCA_NC);
d869 1
a869 1
	gsc.ioh = PHYS_TO_XKPHYS(addr, CCA_NC);
d896 1
a896 1
	gbe_consdata.tm = (caddr_t)PHYS_TO_XKPHYS(gbe_consdata.tm_phys, CCA_NC);
d904 1
a904 1
	gbe_consdata.fb = (caddr_t)PHYS_TO_XKPHYS(gbe_consdata.fb_phys, CCA_NC);
@


1.4
log
@Significantly improve the gbe(4) driver, including:

- Internal restructure to separate code paths.

- Add support for early console. This allows for gbe(4) to takeover were
the ARCBios leaves off (if we should do so).

- Add support for 8bpp and 16bpp colour depths. As a result, we also have
support for colourmaps. We now use 8bpp as the default.

- Add mmap() support, enabling wsfb to operate correctly.

- Correct initial origin problem that occurred occasionally.

ok miod@@. tested by jasper@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d167 1
a167 3
	/* GBE framebuffer only on SGI O2 (for now anyway). */
	if (sys_config.system_type == SGI_O2)
		return 1;
d169 4
a172 1
	return 0;
@


1.3
log
@Have gbe(4) attach as the console if the graphical console is selected via
ARCBIOS. Tested by jasper@@.

ok miod@@
@
text
@d26 3
d45 2
a46 3
struct gbe_softc {
	struct device sc_dev;
	struct rasops_info ri;		/* Raster display info */
d48 8
a55 2
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d57 5
a61 1
	bus_dma_tag_t dmat;
d63 2
a64 2
	bus_dmamap_t tm_dmamap;
	bus_dmamap_t fb_dmamap;
d66 2
a67 2
	bus_dma_segment_t tm_segs[1];
	bus_dma_segment_t fb_segs[1];
d69 10
a78 2
	int tm_nsegs;
	int fb_nsegs;
d80 5
a84 2
	int fb_size;			/* Size of framebuffer memory */
	int tm_size;			/* Size of tilemap memory */
d86 3
a88 2
	caddr_t tilemap;		/* Address of tilemap memory */
	caddr_t fb;			/* Address of framebuffer memory */
d90 1
a90 1
	int rev;			/* Revision */
d92 1
a92 1
	int screens;			/* No of screens allocated */
d94 1
a94 4
	int width;			/* Width in pixels */
	int height;			/* Height in pixels */
	int depth;			/* Colour depth in bits */
	int linebytes;			/* Bytes per line */
d97 5
d103 9
a115 1

d125 3
d129 1
a129 1
	"std",		/* Screen name */
d178 1
d180 6
a185 1
	uint16_t *tm;
a187 1
	int i;
d194 1
a194 1
	gsc->console = 0;
d197 39
d239 1
a239 1
	if (bus_space_map(gsc->iot, GBE_BASE - CRIMEBUS_BASE, 0x100000, 
d250 1
a250 1
	gsc->width = (val >> GBE_VT_HCMAP_ON_SHIFT) & 0xfff;
d252 1
a252 1
	gsc->height = (val >> GBE_VT_VCMAP_ON_SHIFT) & 0xfff;
d254 1
a254 1
	if (gsc->width == 0 || gsc->height == 0) {
d259 5
a263 9
	/* Determine colour depth configured by firmware. */
	val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_FB_SIZE_TILE);
	gsc->depth = 0x8 << ((val >> GBE_FB_SIZE_TILE_DEPTH_SHIFT) & 0x3);

	/* XXX 8MB and 32bpp for now. */
	gsc->fb_size = 8 * 1024 * 1024;
	gsc->tm_size = GBE_TLB_SIZE * sizeof(uint16_t);
	gsc->depth = 32;
	gsc->linebytes = gsc->width * gsc->depth / 8;
d268 2
a269 3

	if (bus_dmamap_create(gsc->dmat, gsc->tm_size, 1, gsc->tm_size, 0,
	    BUS_DMA_NOWAIT, &gsc->tm_dmamap)) {
d274 2
a275 2
	if (bus_dmamem_alloc(gsc->dmat, gsc->tm_size, 65536, 0, gsc->tm_segs, 1,
	    &gsc->tm_nsegs, BUS_DMA_NOWAIT)) {
d280 2
a281 2
	if (bus_dmamem_map(gsc->dmat, gsc->tm_segs, gsc->tm_nsegs, gsc->tm_size,
	    &gsc->tilemap, BUS_DMA_COHERENT)) {
d286 2
a287 2
	if (bus_dmamap_load(gsc->dmat, gsc->tm_dmamap, gsc->tilemap, 
	    gsc->tm_size, NULL, BUS_DMA_NOWAIT)){
d295 2
a296 3

	if (bus_dmamap_create(gsc->dmat, gsc->fb_size, 1, gsc->fb_size, 0, 
	    BUS_DMA_NOWAIT, &gsc->fb_dmamap)) {
d301 2
a302 2
	if (bus_dmamem_alloc(gsc->dmat, gsc->fb_size, 65536, 0, gsc->fb_segs, 
	    1, &gsc->fb_nsegs, BUS_DMA_NOWAIT)) {
d307 2
a308 2
	if (bus_dmamem_map(gsc->dmat, gsc->fb_segs, gsc->fb_nsegs, gsc->fb_size,
	    &gsc->fb, BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) {
d313 1
a313 1
	if (bus_dmamap_load(gsc->dmat, gsc->fb_dmamap, gsc->fb, gsc->fb_size, 
d319 3
d324 13
d338 1
a338 1
	 * Initialise rasops.
a339 1
	memset(&gsc->ri, 0, sizeof(struct rasops_info));
d341 5
a345 14
	gsc->ri.ri_flg = RI_CENTER | RI_CLEAR;
	gsc->ri.ri_depth = gsc->depth;
	gsc->ri.ri_width = gsc->width;
	gsc->ri.ri_height = gsc->height;
	gsc->ri.ri_bits = (void *)gsc->fb;
	gsc->ri.ri_stride = gsc->linebytes;

	if (gsc->depth == 32) {
		gsc->ri.ri_rpos = 24;
		gsc->ri.ri_rnum = 8;
		gsc->ri.ri_gpos = 16;
		gsc->ri.ri_gnum = 8;
		gsc->ri.ri_bpos = 8;
		gsc->ri.ri_bnum = 8;
d348 72
a419 1
	rasops_init(&gsc->ri, gsc->height / 8, gsc->width / 8);
d428 61
a488 3
	tm = (void *)gsc->tilemap;
	for (i = 0; i < (gsc->fb_size >> GBE_TILE_SHIFT); i++)
	    tm[i] = (gsc->fb_dmamap->dm_segs[0].ds_addr >> GBE_TILE_SHIFT) + i;
a493 1
	delay(1000);
a496 1
	delay(1000);
d498 31
a528 1
	delay(1000);
d532 1
a532 2
	delay(10000);
	for (i = 0; i < 10000; i++) {
d538 1
a538 1
	if (i == 10000)
d545 1
a545 2
	delay(10000);
	for (i = 0; i < 10000; i++) {
d551 1
a551 1
	if (i == 10000)
d560 1
d562 23
a584 4
	/* Disable overlay and turn off hardware cursor. */
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_OVERLAY_TILE, 0);
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_CURSOR_CTRL, 0);
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_DID_CTRL, 0);
d587 1
a587 1
	i = gsc->width * gsc->height / (512 / (gsc->depth >> 3));
a590 1
	/* Setup framebuffer - fixed at 32bpp for now. */
d593 3
a595 2
	    (GBE_FB_DEPTH_32 << GBE_FB_SIZE_TILE_DEPTH_SHIFT));
	val = (GBE_CMODE_RGB8 << GBE_WID_MODE_SHIFT) | GBE_BMODE_BOTH;
d599 16
a614 10
	/* Enable dot clock. */
	val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_DOTCLOCK);
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_DOTCLOCK, 
	    val | GBE_DOTCLOCK_RUN);
	delay(10000);
	for (i = 0; i < 10000; i++) {
		val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_DOTCLOCK);
		if ((val & GBE_DOTCLOCK_RUN) == GBE_DOTCLOCK_RUN)
			break;
		delay(10);
a615 22
	if (i == 10000)
		printf("timeout enabling dot clock!\n");

	/* Unfreeze pixel counter. */
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_VT_XY, 0);
	delay(10000);
	for (i = 0; i < 10000; i++) {
		val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_VT_XY);
		if ((val & GBE_VT_XY_FREEZE) == 0)
			break;
		delay(10);
	}
	if (i == 10000)
		printf("timeout unfreezing pixel counter!\n");

	/* Provide GBE with address of tile map and enable DMA. */
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_FB_CTRL, 
	    ((gsc->tm_dmamap->dm_segs[0].ds_addr >> 9) << 
	    GBE_FB_CTRL_TILE_PTR_SHIFT) | GBE_FB_CTRL_DMA_ENABLE);

	printf("rev %u, %iMB, %dx%d at %d bits\n", gsc->rev, gsc->fb_size >> 20,
	    gsc->width, gsc->height, gsc->depth);
d618 1
a618 1
	 * Setup default screen and attach wsdisplay.
d620 4
a624 52
	gbe_stdscreen.ncols = gsc->ri.ri_cols;
	gbe_stdscreen.nrows = gsc->ri.ri_rows;
	gbe_stdscreen.textops = &gsc->ri.ri_ops;
	gbe_stdscreen.fontwidth = gsc->ri.ri_font->fontwidth;
	gbe_stdscreen.fontheight = gsc->ri.ri_font->fontheight;
	gbe_stdscreen.capabilities = gsc->ri.ri_caps;

	/* Attach as console if necessary. */
	if (strncmp(bios_console, "video", 5) == 0) {
		gsc->ri.ri_ops.alloc_attr(&gsc->ri, 0, 0, 0, &attr);
		wsdisplay_cnattach(&gbe_stdscreen, &gsc->ri, 0, 0, attr);
		gsc->console = 1;
	}

	waa.console = gsc->console;
	waa.scrdata = &gbe_screenlist;
	waa.accessops = &gbe_accessops;
	waa.accesscookie = self;
	config_found(self, &waa, wsemuldisplaydevprint);

	return;

fail7:
	bus_dmamem_unmap(gsc->dmat, gsc->fb, gsc->fb_size);
fail6:
	bus_dmamem_free(gsc->dmat, gsc->fb_segs, gsc->fb_nsegs);
fail5:
	bus_dmamap_destroy(gsc->dmat, gsc->fb_dmamap);
fail4:
	bus_dmamap_unload(gsc->dmat, gsc->tm_dmamap);
fail3:
	bus_dmamem_unmap(gsc->dmat, gsc->tilemap, gsc->tm_size);
fail2:
	bus_dmamem_free(gsc->dmat, gsc->tm_segs, gsc->tm_nsegs);
fail1:
	bus_dmamap_destroy(gsc->dmat, gsc->tm_dmamap);
fail0:
	bus_space_unmap(gsc->iot, gsc->ioh, 0x100000);
}

/*
 * GBE hardware specific functions.
 */

void
gbe_disable(struct gbe_softc *gsc)
{
	uint32_t val;

	val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_FB_CTRL);
	bus_space_write_4(gsc->iot, gsc->ioh, GBE_FB_CTRL, 
	    val & ~GBE_FB_CTRL_DMA_ENABLE);
d634 2
a635 1
	struct gbe_softc *gsc = (struct gbe_softc *)v;
d646 4
a649 4
		fb->height = gsc->height;
		fb->width = gsc->width;
		fb->depth = gsc->depth;
		fb->cmsize = gsc->depth == 8 ? 256 : 0;
d654 1
a654 1
		*(u_int *)data = gsc->linebytes;
d658 1
a658 2
		if (gsc->depth == 8) {
#ifdef notyet
d662 1
a662 1
			rc = gbe_getcmap(&scr->scr_cmap, cm);
a664 1
#endif
d669 1
a669 2
		if (gsc->depth == 8) {
#ifdef notyet
d673 1
a673 1
			rc = gbe_putcmap(&scr->scr_cmap, cm);
d676 1
a676 2
			gbe_loadcmap(sc, cm->index, cm->index + cm->count);
#endif
d695 9
a703 2
	/* Not at the moment. */
	return (-1);
d710 2
a711 1
	struct gbe_softc *gsc = (struct gbe_softc *)v;
d720 1
a720 1
	*cookiep = &gsc->ri;
d727 1
a727 1
	gsc->ri.ri_ops.alloc_attr(&gsc->ri, 0, 0, 0, attrp);
d729 1
a729 1
	return 0;
d749 176
@


1.2
log
@add rcs id

"feel free to do so" jsing@@
@
text
@d144 1
a145 3
#ifdef notyet
	char *cp;
#endif
d152 1
a152 1
	gsc->console = 0; /* XXX for now! */
d319 1
a319 1
        val = bus_space_read_4(gsc->iot, gsc->ioh, GBE_FB_SIZE_TILE);
a376 8
#ifdef notyet
	cp = Bios_GetEnvironmentVariable("ConsoleOut");
        if (cp != NULL && strncmp(cp, "video", 5) == 0) {
		wsdisplay_cnattach(&gbe_stdscreen, &gsc->ri, 0, 0, /*defattr*/ 0);
		gsc->console = 1;
        }
#endif

d387 7
@


1.1
log
@Initial support for the SGI Graphics Back End (GBE) frame buffer found in
SGI O2 machines. We currently rely on the video hardware being initialised
by the ARCS firmware and can only use the initial resolution with a colour
depth of 32 bits. This driver is disabled by default.

ok miod@@
@
text
@d1 2
@

