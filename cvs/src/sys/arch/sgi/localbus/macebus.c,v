head	1.65;
access;
symbols
	OPENBSD_6_1:1.65.0.4
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.64.0.2
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.63.0.4
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.63.0.6
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.61.0.8
	OPENBSD_5_5_BASE:1.61
	OPENBSD_5_4:1.61.0.4
	OPENBSD_5_4_BASE:1.61
	OPENBSD_5_3:1.61.0.2
	OPENBSD_5_3_BASE:1.61
	OPENBSD_5_2:1.59.0.2
	OPENBSD_5_2_BASE:1.59
	OPENBSD_5_1_BASE:1.58
	OPENBSD_5_1:1.58.0.6
	OPENBSD_5_0:1.58.0.4
	OPENBSD_5_0_BASE:1.58
	OPENBSD_4_9:1.58.0.2
	OPENBSD_4_9_BASE:1.58
	OPENBSD_4_8:1.56.0.4
	OPENBSD_4_8_BASE:1.56
	OPENBSD_4_7:1.56.0.2
	OPENBSD_4_7_BASE:1.56
	OPENBSD_4_6:1.38.0.2
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.37.0.4
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.37.0.2
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.34.0.2
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.18.0.6
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.65
date	2017.02.11.03.44.22;	author visa;	state Exp;
branches;
next	1.64;
commitid	xjkuO7IpWLYltL4L;

1.64
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.63;
commitid	cyYKarj4qRTft4gD;

1.63
date	2014.09.30.06.51.58;	author jmatthew;	state Exp;
branches;
next	1.62;
commitid	pUEUpP9FlbomZUiI;

1.62
date	2014.05.19.21.18.42;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2012.09.29.18.54.39;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2012.03.15.18.52.56;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	2010.08.23.16.56.18;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2009.11.25.17.39.51;	author syuu;	state Exp;
branches;
next	1.55;

1.55
date	2009.11.12.19.38.53;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2009.11.12.18.10.42;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2009.11.12.17.13.31;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2009.10.26.18.00.06;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2009.10.22.22.08.54;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.22.20.59.24;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2009.10.22.20.51.08;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.22.20.39.17;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.22.20.10.46;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2009.10.22.20.05.28;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.21.20.48.45;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2009.10.07.08.35.47;	author syuu;	state Exp;
branches;
next	1.43;

1.43
date	2009.08.22.02.54.51;	author mk;	state Exp;
branches;
next	1.42;

1.42
date	2009.07.22.21.28.42;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2009.07.22.21.28.08;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2009.07.22.20.08.23;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2009.07.17.18.06.51;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2009.03.20.18.41.07;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2008.07.30.17.37.46;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2008.04.07.22.34.23;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2008.03.30.20.14.40;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2008.02.20.18.46.20;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2007.12.14.16.34.29;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2007.12.14.10.07.12;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.13.12.04.13;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2007.11.11.14.56.41;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2007.10.14.11.18.42;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2007.10.13.06.25.48;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2007.07.09.21.40.24;	author jasper;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.21.20.17.12;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.20.20.47.34;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.20.16.50.43;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.18.20.24.50;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.29.18.10.43;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.03.19.34.01;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2007.03.23.21.07.40;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.04.20.23.07;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.04.20.20.16;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.04.20.18.37;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.20.06.59.27;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.19.21.37.47;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.14.11.02.32;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.18.02.43.25;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.31.21.35.50;	author grange;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.27.19.20.49;	author pefo;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.24.14.22.49;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.21.05.51.15;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.20.10.31.16;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.09.22.11.39;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.11.15.13.35;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.10.19.16.18;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.08.07.35;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.10.07.48.45;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.21.12.19;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.65
log
@Let MP-safe interrupt handlers run without the kernel lock on sgi.

OK miod@@
@
text
@/*	$OpenBSD: macebus.c,v 1.64 2016/03/06 19:42:27 mpi Exp $ */

/*
 * Copyright (c) 2000-2004 Opsycon AB  (www.opsycon.se)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * This is a combined macebus/crimebus driver. It handles configuration of all
 * devices on the processor bus.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/atomic.h>

#include <mips64/archtype.h>
#include <mips64/mips_cpu.h>

#include <machine/autoconf.h>
#include <machine/intr.h>

#include <sgi/localbus/crimebus.h>
#include <sgi/localbus/macebus.h>
#include <sgi/localbus/macebusvar.h>

int	 macebusmatch(struct device *, void *, void *);
void	 macebusattach(struct device *, struct device *, void *);
int	 macebusprint(void *, const char *);
int	 macebussubmatch(struct device *, void *, void *);

void	 macebus_intr_makemasks(void);
void	 macebus_splx(int);
uint32_t macebus_iointr(uint32_t, struct trapframe *);
uint32_t macebus_aux(uint32_t, struct trapframe *);
int	 macebus_iointr_skip(struct intrhand *, uint64_t, uint64_t);
void	 crime_setintrmask(int);

u_int8_t mace_read_1(bus_space_tag_t, bus_space_handle_t, bus_size_t);
u_int16_t mace_read_2(bus_space_tag_t, bus_space_handle_t, bus_size_t);
u_int32_t mace_read_4(bus_space_tag_t, bus_space_handle_t, bus_size_t);
u_int64_t mace_read_8(bus_space_tag_t, bus_space_handle_t, bus_size_t);

void	 mace_write_1(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    u_int8_t);
void	 mace_write_2(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    u_int16_t);
void	 mace_write_4(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    u_int32_t);
void	 mace_write_8(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    u_int64_t);

void	 mace_read_raw_2(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    u_int8_t *, bus_size_t);
void	 mace_write_raw_2(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    const u_int8_t *, bus_size_t);
void	 mace_read_raw_4(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    u_int8_t *, bus_size_t);
void	 mace_write_raw_4(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    const u_int8_t *, bus_size_t);
void	 mace_read_raw_8(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    u_int8_t *, bus_size_t);
void	 mace_write_raw_8(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    const u_int8_t *, bus_size_t);

int	 mace_space_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
void	 mace_space_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);
int	 mace_space_region(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    bus_size_t, bus_space_handle_t *);

void	*mace_space_vaddr(bus_space_tag_t, bus_space_handle_t);
void	 mace_space_barrier(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    bus_size_t, int);

bus_addr_t macebus_pa_to_device(paddr_t);
paddr_t	 macebus_device_to_pa(bus_addr_t);

struct cfattach macebus_ca = {
	sizeof(struct device), macebusmatch, macebusattach
};

struct cfdriver macebus_cd = {
	NULL, "macebus", DV_DULL
};

bus_space_t macebus_tag = {
	PHYS_TO_XKPHYS(MACEBUS_BASE, CCA_NC),
	NULL,
	mace_read_1, mace_write_1,
	mace_read_2, mace_write_2,
	mace_read_4, mace_write_4,
	mace_read_8, mace_write_8,
	mace_read_raw_2, mace_write_raw_2,
	mace_read_raw_4, mace_write_raw_4,
	mace_read_raw_8, mace_write_raw_8,
	mace_space_map, mace_space_unmap, mace_space_region,
	mace_space_vaddr, mace_space_barrier
};

bus_space_t crimebus_tag = {
	PHYS_TO_XKPHYS(CRIMEBUS_BASE, CCA_NC),
	NULL,
	mace_read_1, mace_write_1,
	mace_read_2, mace_write_2,
	mace_read_4, mace_write_4,
	mace_read_8, mace_write_8,
	mace_read_raw_2, mace_write_raw_2,
	mace_read_raw_4, mace_write_raw_4,
	mace_read_raw_8, mace_write_raw_8,
	mace_space_map, mace_space_unmap, mace_space_region,
	mace_space_vaddr, mace_space_barrier
};

bus_space_handle_t crime_h;
bus_space_handle_t mace_h;

struct machine_bus_dma_tag mace_bus_dma_tag = {
	NULL,			/* _cookie */
	_dmamap_create,
	_dmamap_destroy,
	_dmamap_load,
	_dmamap_load_mbuf,
	_dmamap_load_uio,
	_dmamap_load_raw,
	_dmamap_load_buffer,
	_dmamap_unload,
	_dmamap_sync,
	_dmamem_alloc,
	_dmamem_free,
	_dmamem_map,
	_dmamem_unmap,
	_dmamem_mmap,
	macebus_pa_to_device,
	macebus_device_to_pa,
	CRIME_MEMORY_MASK
};

/*
 * CRIME/MACE interrupt handling declarations: 32 CRIME sources, 32 MACE
 * sources (multiplexed by CRIME); 1 level.
 * We define another level for periodic tasks as well.
 */

struct crime_intrhand {
	struct	intrhand	ih;
	uint32_t		mace_irqmask;
};
struct crime_intrhand *crime_intrhand[CRIME_NINTS];

#define	INTPRI_MACEIO	(INTPRI_CLOCK + 1)
#define	INTPRI_MACEAUX	(INTPRI_MACEIO + 1)

uint64_t crime_intem, mace_intem;
uint64_t crime_imask[NIPLS];

/*
 * List of macebus child devices.
 */

#define	MACEBUSDEV(name, addr, i, i2) \
	{ name, &macebus_tag, &macebus_tag, &mace_bus_dma_tag, addr, i, i2 }
struct macebus_attach_args macebus_children[] = {
	MACEBUSDEV("com", MACE_ISA_SER1_OFFS, 4, MACE_ISA_INT_SERIAL_1),
	MACEBUSDEV("com", MACE_ISA_SER2_OFFS, 4, MACE_ISA_INT_SERIAL_2),
	MACEBUSDEV("dsrtc", MACE_ISA_RTC_OFFS, -1, 0),
#if 0
	MACEBUSDEV("lpt", MACE_ISA_EPP_OFFS, 4, MACE_ISA_INT_PARALLEL),
#endif
	MACEBUSDEV("macepcibr", MACE_PCI_OFFS, 7, 0),
	MACEBUSDEV("mavb", MACE_IO_AUDIO_OFFS, 6, MACE_ISA_INT_AUDIO),
	MACEBUSDEV("mec", MACE_ETHERNET_OFFS, 3, 0),
	MACEBUSDEV("mkbc", MACE_IO_KBC_OFFS, 5,
	    MACE_ISA_INT_KBD | MACE_ISA_INT_KBD_POLL |
	    MACE_ISA_INT_MOUSE | MACE_ISA_INT_MOUSE_POLL),
	MACEBUSDEV("power", 0, 5, MACE_ISA_INT_RTC)
};
#undef	MACEBUSDEV

/*
 * Match bus only to targets which have this bus.
 */
int
macebusmatch(struct device *parent, void *match, void *aux)
{
	if (sys_config.system_type == SGI_O2)
		return (1);
	return (0);
}

int
macebusprint(void *aux, const char *macebus)
{
	struct macebus_attach_args *maa = aux;

	if (macebus != NULL)
		printf("%s at %s", maa->maa_name, macebus);

	if (maa->maa_baseaddr != 0)
		printf(" base 0x%08lx", maa->maa_baseaddr);
	if (maa->maa_intr >= 0)
		printf(" irq %d", maa->maa_intr);

	return (UNCONF);
}

int
macebussubmatch(struct device *parent, void *vcf, void *args)
{
	struct cfdata *cf = vcf;
	struct macebus_attach_args *maa = args;

	if (strcmp(cf->cf_driver->cd_name, maa->maa_name) != 0)
		return 0;

	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != (int)maa->maa_baseaddr)
		return 0;

	return (*cf->cf_attach->ca_match)(parent, cf, maa);
}

void
macebusattach(struct device *parent, struct device *self, void *aux)
{
	u_int32_t creg;
	uint i;

	/*
	 * Map and setup CRIME control registers.
	 */
	if (bus_space_map(&crimebus_tag, 0x00000000, 0x400, 0, &crime_h)) {
		printf(": can't map CRIME control registers\n");
		return;
	}

	creg = bus_space_read_8(&crimebus_tag, crime_h, CRIME_REVISION);
	printf(": crime rev %d.%d\n", (creg & 0xf0) >> 4, creg & 0xf);

	bus_space_write_8(&crimebus_tag, crime_h, CRIME_CPU_ERROR_STAT, 0);
	bus_space_write_8(&crimebus_tag, crime_h, CRIME_MEM_ERROR_STAT, 0);

	bus_space_write_8(&crimebus_tag, crime_h, CRIME_INT_MASK, 0);
	bus_space_write_8(&crimebus_tag, crime_h, CRIME_INT_SOFT, 0);
	bus_space_write_8(&crimebus_tag, crime_h, CRIME_INT_HARD, 0);
	bus_space_write_8(&crimebus_tag, crime_h, CRIME_INT_STAT, 0);

	/*
	 * Map and setup MACE ISA control registers.
	 */
	if (bus_space_map(&macebus_tag, MACE_ISA_OFFS, 0x400, 0, &mace_h)) {
		printf("%s: can't map MACE control registers\n",
		    self->dv_xname);
		return;
	}

	bus_space_write_8(&macebus_tag, mace_h, MACE_ISA_INT_MASK, 0);
	bus_space_write_8(&macebus_tag, mace_h, MACE_ISA_INT_STAT, 0);

	/*
	 * On O2 systems all interrupts are handled by the macebus interrupt
	 * handler. Register all except clock.
	 */
	set_intr(INTPRI_MACEIO, CR_INT_0, macebus_iointr);
	register_splx_handler(macebus_splx);

	/* Set up a handler called when clock interrupts go off. */
	set_intr(INTPRI_MACEAUX, CR_INT_5, macebus_aux);

	/*
	 * Attach subdevices.
	 */
	for (i = 0; i < nitems(macebus_children); i++)
		config_found_sm(self, macebus_children + i,
		    macebusprint, macebussubmatch);
}

/*
 * Bus access primitives. These are really ugly...
 */

u_int8_t
mace_read_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
{
	return *(volatile u_int8_t *)(h + (o << 8) + 7);
}

u_int16_t
mace_read_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
{
	panic(__func__);
}

u_int32_t
mace_read_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
{
	return *(volatile u_int32_t *)(h + o);
}

u_int64_t
mace_read_8(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
{
	return *(volatile u_int64_t *)(h + o);
}

void
mace_write_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o, u_int8_t v)
{
	*(volatile u_int8_t *)(h + (o << 8) + 7) = v;
}

void
mace_write_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o, u_int16_t v)
{
	panic(__func__);
}

void
mace_write_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o, u_int32_t v)
{
	*(volatile u_int32_t *)(h + o) = v;
}

void
mace_write_8(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o, u_int64_t v)
{
	*(volatile u_int64_t *)(h + o) = v;
}

void
mace_read_raw_2(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    u_int8_t *buf, bus_size_t len)
{
	panic(__func__);
}

void
mace_write_raw_2(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    const u_int8_t *buf, bus_size_t len)
{
	panic(__func__);
}

void
mace_read_raw_4(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    u_int8_t *buf, bus_size_t len)
{
	volatile u_int32_t *addr = (volatile u_int32_t *)(h + o);
	len >>= 2;
	while (len-- != 0) {
		*(u_int32_t *)buf = *addr;
		buf += 4;
	}
}

void
mace_write_raw_4(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    const u_int8_t *buf, bus_size_t len)
{
	volatile u_int32_t *addr = (volatile u_int32_t *)(h + o);
	len >>= 2;
	while (len-- != 0) {
		*addr = *(u_int32_t *)buf;
		buf += 4;
	}
}

void
mace_read_raw_8(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    u_int8_t *buf, bus_size_t len)
{
	volatile u_int64_t *addr = (volatile u_int64_t *)(h + o);
	len >>= 3;
	while (len-- != 0) {
		*(u_int64_t *)buf = *addr;
		buf += 8;
	}
}

void
mace_write_raw_8(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    const u_int8_t *buf, bus_size_t len)
{
	volatile u_int64_t *addr = (volatile u_int64_t *)(h + o);
	len >>= 3;
	while (len-- != 0) {
		*addr = *(u_int64_t *)buf;
		buf += 8;
	}
}

int
mace_space_map(bus_space_tag_t t, bus_addr_t offs, bus_size_t size,
    int flags, bus_space_handle_t *bshp)
{
	if (ISSET(flags, BUS_SPACE_MAP_CACHEABLE))
		offs +=
		    PHYS_TO_XKPHYS(0, CCA_CACHED) - PHYS_TO_XKPHYS(0, CCA_NC);
	*bshp = t->bus_base + offs;
	return 0;
}

void
mace_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size)
{
}

int
mace_space_region(bus_space_tag_t t, bus_space_handle_t bsh,
    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp)
{
	*nbshp = bsh + offset;
	return (0);
}

void *
mace_space_vaddr(bus_space_tag_t t, bus_space_handle_t h)
{
	return (void *)h;
}

void
mace_space_barrier(bus_space_tag_t t, bus_space_handle_t h, bus_size_t offs,
    bus_size_t len, int flags)
{
	mips_sync();
}

/*
 * Macebus bus_dma helpers.
 * Mace accesses memory contiguously at 0x40000000 onwards.
 */

bus_addr_t
macebus_pa_to_device(paddr_t pa)
{
	return (pa | CRIME_MEMORY_OFFSET);
}

paddr_t
macebus_device_to_pa(bus_addr_t addr)
{
	paddr_t pa = (paddr_t)addr & CRIME_MEMORY_MASK;

	if (pa >= 256 * 1024 * 1024)
		pa |= CRIME_MEMORY_OFFSET;

	return (pa);
}

/*
 * Macebus interrupt handler driver.
 */

/*
 * Establish an interrupt handler called from the dispatcher.
 * The interrupt function established should return zero if there was nothing
 * to serve (no int) and non-zero when an interrupt was serviced.
 *
 * Interrupts are numbered from 1 and up where 1 maps to HW int 0.
 * XXX There is no reason to keep this... except for hardcoded interrupts
 * XXX in kernel configuration files...
 */
void *
macebus_intr_establish(int irq, uint32_t mace_irqmask, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, const char *ih_what)
{
	struct crime_intrhand **p, *q, *ih;
	int s;

	level &= ~IPL_MPSAFE;

#ifdef DIAGNOSTIC
	if (irq >= CRIME_NINTS || irq < 0)
		panic("intr_establish: illegal irq %d", irq);
#endif

	ih = malloc(sizeof *ih, M_DEVBUF, M_NOWAIT);
	if (ih == NULL)
		return NULL;

	ih->ih.ih_next = NULL;
	ih->ih.ih_fun = ih_fun;
	ih->ih.ih_arg = ih_arg;
	ih->ih.ih_level = level;
	ih->ih.ih_irq = irq;
	ih->ih.ih_flags = 0;
	ih->mace_irqmask = mace_irqmask;
	evcount_attach(&ih->ih.ih_count, ih_what, &ih->ih.ih_irq);

	s = splhigh();

	/*
	 * Figure out where to put the handler.
	 * This is O(N^2), but we want to preserve the order, and N is
	 * generally small.
	 */
	for (p = &crime_intrhand[irq]; (q = *p) != NULL;
	    p = (struct crime_intrhand **)&q->ih.ih_next)
		;
	*p = ih;

	crime_intem |= 1UL << irq;
	macebus_intr_makemasks();

	/* enable further MACE sources if necessary */
	if (mace_irqmask != 0) {
		mace_intem |= mace_irqmask;
		bus_space_write_8(&macebus_tag, mace_h, MACE_ISA_INT_MASK,
		    mace_intem);
	}

	splx(s);	/* causes hw mask update */

	return (ih);
}

void
macebus_intr_disestablish(void *ih)
{
	/* XXX */
	panic("%s not implemented", __func__);
}

void
macebus_splx(int newipl)
{
	struct cpu_info *ci = curcpu();

	/* Update masks to new ipl. Order highly important! */
	__asm__ (".set noreorder\n");
	ci->ci_ipl = newipl;
	mips_sync();
	__asm__ (".set reorder\n");
	crime_setintrmask(newipl);
	/* If we still have softints pending trigger processing. */
	if (ci->ci_softpending != 0 && newipl < IPL_SOFTINT)
		setsoftintr0();
}

/*
 * Crime interrupt handler.
 */

#define	INTR_FUNCTIONNAME	macebus_iointr
#define	MASK_FUNCTIONNAME	macebus_intr_makemasks

#define	INTR_LOCAL_DECLS \
	uint64_t mace_isr, mace_imr;
#define	MASK_LOCAL_DECLS
#define	INTR_GETMASKS \
do { \
	isr = bus_space_read_8(&crimebus_tag, crime_h, CRIME_INT_STAT); \
	imr = bus_space_read_8(&crimebus_tag, crime_h, CRIME_INT_MASK); \
	if (((CRIME_INT_SUPER_IO | CRIME_INT_SUB_MISC | CRIME_INT_SUB_AUDIO) & \
	    isr & imr) != 0) { \
		mace_isr = bus_space_read_8(&macebus_tag, mace_h, \
		    MACE_ISA_INT_STAT); \
		mace_imr = bus_space_read_8(&macebus_tag, mace_h, \
		    MACE_ISA_INT_MASK); \
	} else \
		mace_isr = mace_imr = 0; \
	bit = 63; \
} while (0)
#define	INTR_MASKPENDING \
	bus_space_write_8(&crimebus_tag, crime_h, CRIME_INT_MASK, imr & ~isr)
#define	INTR_IMASK(ipl)		crime_imask[ipl]
#define	INTR_HANDLER(bit)	(struct intrhand *)crime_intrhand[bit]
#define	INTR_SPURIOUS(bit) \
do { \
	if (((CRIME_INT_SUPER_IO | CRIME_INT_SUB_MISC | CRIME_INT_SUB_AUDIO) & \
	    (1 << (bit))) != 0) { \
		if ((mace_isr & mace_imr) != 0) \
			printf("spurious crime interrupt %d" \
			    " mace isr %p imr %p\n", \
			    bit, (void *)mace_isr, (void *)mace_imr); \
	} else \
		printf("spurious crime interrupt %d\n", bit); \
} while (0)
#define	INTR_MASKRESTORE \
	bus_space_write_8(&crimebus_tag, crime_h, CRIME_INT_MASK, imr)
#define	INTR_MASKSIZE		CRIME_NINTS

#define	INTR_HANDLER_SKIP(ih) \
	macebus_iointr_skip((void *)ih, mace_isr, mace_imr)

#include <sgi/sgi/intr_template.c>

int
macebus_iointr_skip(struct intrhand *ih, uint64_t mace_isr, uint64_t mace_imr)
{
	struct crime_intrhand *mih = (struct crime_intrhand *)ih;

	/* do not skip pure CRIME interrupts */
	if (mih->mace_irqmask == 0)
		return 0;

	/*
	 * Several CRIME interrupts (such as superio and miscellaneous) are
	 * shared by multiple devices, so narrow the selection with the
	 * MACE interrupt status.
	 */

	if ((mace_isr & mace_imr & mih->mace_irqmask) != 0)
		return 0;

	return 1;
}

/*
 * Macebus auxilary functions run each clock interrupt.
 */
uint32_t
macebus_aux(uint32_t hwpend, struct trapframe *cf)
{
	u_int64_t mask;

	mask = bus_space_read_8(&macebus_tag, mace_h, MACE_ISA_MISC_REG);
	mask |= MACE_ISA_MISC_RLED_OFF | MACE_ISA_MISC_GLED_OFF;

	/* GREEN - Idle */
	/* AMBER - System mode */
	/* RED   - User mode */
	if (cf->sr & SR_KSU_USER) {
		mask &= ~MACE_ISA_MISC_RLED_OFF;
	} else if (curproc == NULL ||
	    curproc == curcpu()->ci_schedstate.spc_idleproc) {
		mask &= ~MACE_ISA_MISC_GLED_OFF;
	} else {
		mask &= ~(MACE_ISA_MISC_RLED_OFF | MACE_ISA_MISC_GLED_OFF);
	}
	bus_space_write_8(&macebus_tag, mace_h, MACE_ISA_MISC_REG, mask);

	return 0;	/* Real clock int handler will claim the interrupt. */
}

void
crime_setintrmask(int level)
{
	*(volatile uint64_t *)(PHYS_TO_XKPHYS(CRIMEBUS_BASE, CCA_NC) +
	    CRIME_INT_MASK) = crime_intem & ~crime_imask[level];
}
@


1.64
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.63 2014/09/30 06:51:58 jmatthew Exp $ */
d496 2
d512 1
@


1.63
log
@implement atomic operations using ll/sc, and convert rw_cas and callers of the
pre-existing atomics to match.

tested on sgi (octane) and octeon (erl)
ok miod@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.62 2014/05/19 21:18:42 miod Exp $ */
d60 2
a61 2
uint32_t macebus_iointr(uint32_t, struct trap_frame *);
uint32_t macebus_aux(uint32_t, struct trap_frame *);
d636 1
a636 1
macebus_aux(uint32_t hwpend, struct trap_frame *cf)
@


1.62
log
@Format string fixes and removal of -Wno-format for sgi. Based upon an
initial diff from jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.61 2012/10/03 11:18:23 miod Exp $ */
d41 1
a47 1
#include <machine/atomic.h>
@


1.61
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.60 2012/09/29 18:54:39 miod Exp $ */
d226 1
a226 1
		printf(" base 0x%08x", maa->maa_baseaddr);
d597 2
a598 1
			    " mace isr %p imr %p\n", bit, mace_isr, mace_imr); \
@


1.60
log
@Proide a mips_sync() macro to wrap asm("sync"), and replace gazillions of
such statements with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.59 2012/03/15 18:52:56 miod Exp $ */
d43 1
@


1.59
log
@No longer allow bus_space_barrier() to be a NULL pointer on a given
bus_space_tag on sgi, but rather always provide at least a dummy asm("sync")
flavour. Saves a function pointer test at runtime.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.58 2010/09/20 06:33:47 matthew Exp $ */
d450 1
a450 1
	__asm__ __volatile__ ("sync" ::: "memory");
d554 2
a555 1
	__asm__ ("sync\n\t.set reorder\n");
@


1.58
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.57 2010/08/23 16:56:18 miod Exp $ */
d98 2
d123 1
a123 2
	mace_space_vaddr,
	NULL
d137 1
a137 2
	mace_space_vaddr,
	NULL
d444 7
@


1.57
log
@Implement bus_space_barrier() on sgi; on xbridge, this will also flush
the pci write buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.56 2009/11/25 17:39:51 syuu Exp $ */
d503 1
a503 2
	evcount_attach(&ih->ih.ih_count, ih_what, (void *)&ih->ih.ih_irq,
	    &evcount_intr);
@


1.56
log
@IP30 IPI implementation.
Also few xheart modification for SMP.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.55 2009/11/12 19:38:53 miod Exp $ */
d121 2
a122 1
	mace_space_vaddr
d136 2
a137 1
	mace_space_vaddr
@


1.55
log
@Oops, I can't even spell `spurious' correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.54 2009/11/12 18:10:42 miod Exp $ */
d562 1
@


1.54
log
@Only read mace interrupt registers once in the interrupt handler; and fix
the spurious interrupt report logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.53 2009/11/12 17:13:31 miod Exp $ */
d588 1
a588 1
		printf("suprious crime interrupt %d\n", bit); \
@


1.53
log
@Move the interrupt makemasks() code to the interrupt template; no functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.52 2009/10/26 18:00:06 miod Exp $ */
d61 1
a61 1
int	 macebus_iointr_skip(struct intrhand *);
d560 2
a561 1
#define	INTR_LOCAL_DECLS
d566 8
d582 7
a588 8
	uint64_t mace_isr, mace_imr; \
	mace_isr = bus_space_read_8(&macebus_tag, mace_h, MACE_ISA_INT_STAT); \
	mace_imr = bus_space_read_8(&macebus_tag, mace_h, MACE_ISA_INT_MASK); \
	/* serial console processing may clear interrupt condition \
	   before it fires */ \
	if (bit != 4 || (mace_isr & mace_imr) != 0) \
		printf("spurious crime interrupt %d mace isr %p imr %p\n", \
		    bit, mace_isr, mace_imr); \
d594 2
a595 1
#define	INTR_HANDLER_SKIP(ih)	macebus_iointr_skip((void *)ih)
d600 1
a600 1
macebus_iointr_skip(struct intrhand *ih)
a602 1
	uint64_t mace_isr, mace_imr;
a613 2
	mace_isr = bus_space_read_8(&macebus_tag, mace_h, MACE_ISA_INT_STAT);
	mace_imr = bus_space_read_8(&macebus_tag, mace_h, MACE_ISA_INT_MASK);
@


1.52
log
@Better crime/mace interrupt handling; interrupt information is no longer
specified in the kernel configuration file, but is provided by macebus(4)
as part of the  child device attachment args, and provide both crime and
mace interrupt bitmasks; this allows us to only really enable interrupt
sources we care about, and to avoid invoking interrupt handler we don't need
to for the few mace interrupts multiplexed at the crime level.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.51 2009/10/22 22:08:54 miod Exp $ */
a537 47
/*
 * Regenerate interrupt masks to reflect reality.
 */
void
macebus_intr_makemasks(void)
{
	int irq, level;
	struct intrhand *q;
	uint intrlevel[CRIME_NINTS];

	/* First, figure out which levels each IRQ uses. */
	for (irq = 0; irq < CRIME_NINTS; irq++) {
		uint levels = 0;
		for (q = (struct intrhand *)crime_intrhand[irq];
		    q != NULL; q = q->ih_next)
			levels |= 1 << q->ih_level;
		intrlevel[irq] = levels;
	}

	/* Then figure out which IRQs use each level. */
	for (level = IPL_NONE; level < IPL_HIGH; level++) {
		uint64_t irqs = 0;
		for (irq = 0; irq < CRIME_NINTS; irq++)
			if (intrlevel[irq] & (1 << level))
				irqs |= 1UL << irq;
		crime_imask[level] = irqs;
	}

	/*
	 * There are tty, network and disk drivers that use free() at interrupt
	 * time, so vm > (tty | net | bio).
	 *
	 * Enforce a hierarchy that gives slow devices a better chance at not
	 * dropping data.
	 */
	crime_imask[IPL_NET] |= crime_imask[IPL_BIO];
	crime_imask[IPL_TTY] |= crime_imask[IPL_NET];
	crime_imask[IPL_VM] |= crime_imask[IPL_TTY];
	crime_imask[IPL_CLOCK] |= crime_imask[IPL_VM];

	/*
	 * These are pseudo-levels.
	 */
	crime_imask[IPL_NONE] = 0;
	crime_imask[IPL_HIGH] = -1UL;
}

d558 2
d584 1
@


1.51
log
@Completely overhaul interrupt handling on sgi. Cpu state now only stores a
logical IPL level, and per-platform (IP27/IP30/IP32) code will from the
necessary hardware mask registers.

This allows the use of more than one interrupt mask register. Also, the
generic (platform independent) interrupt code shrinks a lot, and the actual
interrupt handler chains and masking information is now per-platform private
data.

Interrupt dispatching is generated from a template; more routines will be
added to the template to reduce platform-specific changes and share as much
code as possible.

Tested on IP27, IP30, IP32 and IP35.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.50 2009/10/22 20:59:24 miod Exp $ */
d50 1
d55 1
a55 1
int	 macebussearch(struct device *, void *, void *);
d61 2
a62 1
void	mace_setintrmask(int);
d164 1
a164 1
 * sources (unmanaged); 1 level.
d168 5
a172 1
struct intrhand *mace_intrhand[CRIME_NINTS];
d177 25
a201 2
uint64_t mace_intem;
uint64_t mace_imask[NIPLS];
d217 1
a217 1
	struct confargs *ca = aux;
d220 1
a220 1
		printf("%s at %s", ca->ca_name, macebus);
d222 4
a225 4
	if (ca->ca_baseaddr != 0)
		printf(" base 0x%08x", ca->ca_baseaddr);
	if (ca->ca_intr != 0)
		printf(" irq %d", ca->ca_intr);
d231 1
a231 1
macebussearch(struct device *parent, void *child, void *args)
d233 2
a234 2
	struct cfdata *cf = child;
	struct confargs ca;
d236 2
a237 12
	ca.ca_name = cf->cf_driver->cd_name;
	ca.ca_iot = &macebus_tag;
	ca.ca_memt = &macebus_tag;
	ca.ca_dmat = &mace_bus_dma_tag;
	if (cf->cf_loc[0] == -1)
		ca.ca_baseaddr = 0;
	else
		ca.ca_baseaddr = cf->cf_loc[0];
	if (cf->cf_loc[1] == -1)
		ca.ca_intr = 0;
	else
		ca.ca_intr = cf->cf_loc[1];
d239 2
a240 2
	if ((*cf->cf_attach->ca_match)(parent, cf, &ca) == 0)
		return (0);
d242 1
a242 2
	config_attach(parent, cf, &ca, macebusprint);
	return (1);
d249 1
d279 1
a279 3
	/* Turn on all MACE interrupts except for MACE compare/timer. */
	bus_space_write_8(&macebus_tag, mace_h, MACE_ISA_INT_MASK, 
	    0xffffffff & ~MACE_ISA_INT_TIMER);
d292 6
a297 1
	config_search(macebussearch, self, aux);
d480 1
a480 1
macebus_intr_establish(void *icp, u_long irq, int type, int level,
d483 1
a483 1
	struct intrhand **p, *q, *ih;
d487 1
a487 1
	if (irq > CRIME_NINTS || irq < 1)
a490 2
	irq -= 1;	/* Adjust for 1 being first (0 is no int) */

d495 7
a501 6
	ih->ih_next = NULL;
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_level = level;
	ih->ih_irq = irq + 1;
	evcount_attach(&ih->ih_count, ih_what, (void *)&ih->ih_irq,
d511 2
a512 1
	for (p = &mace_intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
d516 1
a516 1
	mace_intem |= 1UL << irq;
d519 7
d551 2
a552 1
		for (q = mace_intrhand[irq]; q; q = q->ih_next)
d563 1
a563 1
		mace_imask[level] = irqs;
d573 4
a576 4
	mace_imask[IPL_NET] |= mace_imask[IPL_BIO];
	mace_imask[IPL_TTY] |= mace_imask[IPL_NET];
	mace_imask[IPL_VM] |= mace_imask[IPL_TTY];
	mace_imask[IPL_CLOCK] |= mace_imask[IPL_VM];
d581 2
a582 2
	mace_imask[IPL_NONE] = 0;
	mace_imask[IPL_HIGH] = -1UL;
d594 1
a594 1
	mace_setintrmask(newipl);
d614 2
a615 2
#define	INTR_IMASK(ipl)		mace_imask[ipl]
#define	INTR_HANDLER(bit)	mace_intrhand[bit]
d618 8
a625 3
	/* XXX +1 because of -1 in intr_establish() */ \
	if (bit != 4) \
		printf("spurious crime interrupt %d\n", bit + 1); \
d630 2
d634 24
d676 1
a676 1
		mask &= ~MACE_ISA_MISC_GLED_OFF;	
d686 1
a686 1
mace_setintrmask(int level)
d689 1
a689 1
	    CRIME_INT_MASK) = mace_intem & ~mace_imask[level];
@


1.50
log
@With the splx() changes, it is no longer necessary to remember which interrupt
sources were masked and saved in ci_ipending, as splx() will unmask what needs
to be unmasked anyway. ci_ipending only now needs to store pending soft
interrupts, so rename it to ci_softpending.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.49 2009/10/22 20:51:08 miod Exp $ */
d60 1
d161 14
d255 1
a255 1
		printf("%s: can't map MACE ISA control registers\n",
d260 1
a260 1
	/* Turn on all interrupts except for MACE compare/timer. */
a447 8
uint64_t mace_intem = 0x0;
static uint32_t intrtype[INTMASKSIZE];
static uint32_t intrmask[INTMASKSIZE];
static uint32_t intrlevel[INTMASKSIZE];

static int fakeintr(void *);
static int fakeintr(void *a) {return 0;}

d452 1
d454 2
d462 1
a462 9
	static struct intrhand fakehand = {NULL, fakeintr};
	int edge;
	extern int cold;
	static int initialized = 0;

	if (!initialized) {
		/*INIT CODE HERE*/
		initialized = 1;
	}
d464 2
a465 1
	if (irq > SPL_CLOCK || irq < 1) {
d467 2
a468 1
	}
d471 1
a471 2
	/* No point in sleeping unless someone can free memory. */
	ih = malloc(sizeof *ih, M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
d473 1
a473 1
		panic("intr_establish: can't malloc handler info");
d475 7
a481 9
	if (type == IST_NONE || type == IST_PULSE)
		panic("intr_establish: bogus type");

	switch (intrtype[irq]) {
	case IST_EDGE:
	case IST_LEVEL:
		if (type == intrtype[irq])
			break;
	}
d483 1
a483 8
	switch (type) {
	case IST_EDGE:
		edge |= 1 << irq;
		break;
	case IST_LEVEL:
		edge &= ~(1 << irq);
		break;
	}
d490 1
a490 1
	for (p = &intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
d492 1
d494 1
a494 8
	/*
	 * Actually install a fake handler momentarily, since we might be doing
	 * this with interrupts enabled and don't want the real routine called
	 * until masking is set up.
	 */
	fakehand.ih_level = level;
	*p = &fakehand;

d497 1
a497 11
	/*
	 * Poke the real handler in now.
	 */
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_next = NULL;
	ih->ih_level = level;
	ih->ih_irq = irq + 1;
	evcount_attach(&ih->ih_count, ih_what, (void *)&ih->ih_irq,
	    &evcount_intr);
	*p = ih;
d517 1
d520 3
a522 3
	for (irq = 0; irq < INTMASKSIZE; irq++) {
		int levels = 0;
		for (q = intrhand[irq]; q; q = q->ih_next)
d528 3
a530 3
	for (level = IPL_NONE; level < NIPLS; level++) {
		int irqs = 0;
		for (irq = 0; irq < INTMASKSIZE; irq++)
d532 2
a533 4
				irqs |= 1 << irq;
		if (level != IPL_NONE)
			irqs |= SINT_ALLMASK;
		imask[level] = irqs;
d538 1
a538 1
	 * time, so imp > (tty | net | bio).
d543 4
a546 4
	imask[IPL_NET] |= imask[IPL_BIO];
	imask[IPL_TTY] |= imask[IPL_NET];
	imask[IPL_VM] |= imask[IPL_TTY];
	imask[IPL_CLOCK] |= imask[IPL_VM] | SPL_CLOCKMASK;
d551 2
a552 20
	imask[IPL_NONE] = 0;
	imask[IPL_HIGH] = -1;

	/* And eventually calculate the complete masks. */
	for (irq = 0; irq < INTMASKSIZE; irq++) {
		int irqs = 1 << irq;
		for (q = intrhand[irq]; q; q = q->ih_next)
			irqs |= imask[q->ih_level];
		intrmask[irq] = irqs | SINT_ALLMASK;
	}

	/* Lastly, determine which IRQs are actually in use. */
	irq = 0;
	for (level = 0; level < INTMASKSIZE; level++) {
		if (intrhand[level]) {
			irq |= 1 << level;
		}
	}
	mace_intem = irq & 0x0000ffff;
	hw_setintrmask(0);
d556 1
a556 1
macebus_splx(int newcpl)
d560 5
a564 5
	/* Update masks to new cpl. Order highly important! */
	__asm__ (" .set noreorder\n");
	ci->ci_cpl = newcpl;
	__asm__ (" sync\n .set reorder\n");
	hw_setintrmask(newcpl);
d566 1
a566 1
	if (ci->ci_softpending & ~newcpl)
d571 1
a571 1
 * Process interrupts. The parameter pending has non-masked interrupts.
a572 15
uint32_t
macebus_iointr(uint32_t hwpend, struct trap_frame *cf)
{
	struct intrhand *ih;
	uint32_t caught, vm;
	int v;
	uint32_t pending;
	u_int64_t intstat, isastat, mask;
#ifdef DIAGNOSTIC
	static int spurious = 0;
#endif
	struct cpu_info *ci = curcpu();

	intstat = bus_space_read_8(&crimebus_tag, crime_h, CRIME_INT_STAT);
	intstat &= 0xffff;
d574 20
a593 67
	isastat = bus_space_read_8(&macebus_tag, mace_h, MACE_ISA_INT_STAT);
	caught = 0;

	/* Mask off masked interrupts and save them as pending. */
	if (intstat & cf->cpl) {
		mask = bus_space_read_8(&crimebus_tag, crime_h, CRIME_INT_MASK);
		bus_space_write_8(&crimebus_tag, crime_h, CRIME_INT_MASK, mask);
		caught++;
	}

	/* Scan all unmasked. Scan the first 16 for now. */
	pending = intstat & ~cf->cpl;

	for (v = 0, vm = 1; pending != 0 && v < 16 ; v++, vm <<= 1) {
		if (pending & vm) {
			ih = intrhand[v];

			while (ih) {
				ih->frame = cf;
				if ((*ih->ih_fun)(ih->ih_arg)) {
					caught |= vm;
					ih->ih_count.ec_count++;
				}
				ih = ih->ih_next;
			}
		}
	}

	if (caught) {
#ifdef DIAGNOSTIC
		spurious = 0;
#endif
		return CR_INT_0;
	}

#ifdef DIAGNOSTIC
	if (pending != 0) {
		intstat = bus_space_read_8(&crimebus_tag, crime_h,
		    CRIME_INT_STAT) &
		    bus_space_read_8(&crimebus_tag, crime_h, CRIME_INT_MASK);
		isastat = bus_space_read_8(&macebus_tag, mace_h,
		    MACE_ISA_INT_STAT) &
		    bus_space_read_8(&macebus_tag, mace_h, MACE_ISA_INT_MASK);

		if (intstat != 0 || isastat != 0) {
			printf("stray interrupt, mace mask %lx stat %lx\n"
			    "crime mask %lx stat %lx hard %lx "
			    "(pending %lx caught %lx)\n",
			    bus_space_read_8(&macebus_tag, mace_h,
			      MACE_ISA_INT_MASK),
			    bus_space_read_8(&macebus_tag, mace_h,
			      MACE_ISA_INT_STAT),
			    bus_space_read_8(&crimebus_tag, crime_h,
			      CRIME_INT_MASK),
			    bus_space_read_8(&crimebus_tag, crime_h,
			      CRIME_INT_STAT),
			    bus_space_read_8(&crimebus_tag, crime_h,
			      CRIME_INT_HARD),
			    pending, caught);
			if (++spurious >= 10)
				panic("too many stray interrupts");
		}
	}
#endif

	return 0;  /* Not found here. */
}
d595 1
d621 1
a621 1
	return 0; /* Real clock int handler registers. */
d625 1
a625 1
hw_setintrmask(uint32_t m)
d628 1
a628 1
	    CRIME_INT_MASK) = mace_intem & ~((uint64_t)m);
@


1.49
log
@Make macebus_intr_disestablish() signature sane, and update its caller.
Still unimplemented for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.48 2009/10/22 20:39:17 miod Exp $ */
d607 1
a607 1
	if (ci->ci_ipending & SINT_ALLMASK & ~newcpl)
a634 1
		atomic_setbits_int(&ci->ci_ipending, intstat & cf->cpl);
a635 1
		mask &= ~ci->ci_ipending;
a641 1
	atomic_clearbits_int(&ci->ci_ipending, pending);
@


1.48
log
@The recent cleanups make blatantly visible that the pending_int handler
does almost exactly what splx() is doing if ipending is zero, and triggers
soft interrupts as well.

So don't bother checking for ipending in splx, and always invoke pending_int,
which gets renamed as splx_handler for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.47 2009/10/22 20:10:46 miod Exp $ */
d525 1
a525 1
macebus_intr_disestablish(void *p1, void *p2)
d527 2
@


1.47
log
@unifdef -DIMASK_EXTERNAL to the mips code. Support for interrupt masking at
coprocessor 0 sr level might come back in the future if hardware support
requires it, but at the moment it's getting in the way of larger changes.
``In the Attic, noone can hear you scream''
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.46 2009/10/22 20:05:28 miod Exp $ */
d57 1
a57 1
void	 macebus_do_pending_int(int);
d255 1
a255 1
	register_pending_int_handler(macebus_do_pending_int);
d595 1
a595 1
macebus_do_pending_int(int newcpl)
@


1.46
log
@Replace intrmask_t with uint32_t. This types only describes interrupt masks
in the coprocessor 0 status register (coupled with ICR on rm7k/rm9k), and
may be completely alien to real hardware interrupt masks, so don't make
things unnecessary confusing.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.45 2009/10/21 20:48:45 miod Exp $ */
a516 1
	ih->ih_what = ih_what;
@


1.45
log
@Replace IP32 hw_setintrmask() .S routine with a two line C routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.44 2009/10/07 08:35:47 syuu Exp $ */
d58 2
a59 2
intrmask_t macebus_iointr(intrmask_t, struct trap_frame *);
intrmask_t macebus_aux(intrmask_t, struct trap_frame *);
d433 4
a436 4
intrmask_t mace_intem = 0x0;
static intrmask_t intrtype[INTMASKSIZE];
static intrmask_t intrmask[INTMASKSIZE];
static intrmask_t intrlevel[INTMASKSIZE];
d613 2
a614 2
intrmask_t
macebus_iointr(intrmask_t hwpend, struct trap_frame *cf)
d617 1
a617 1
	intrmask_t caught, vm;
d619 1
a619 1
	intrmask_t pending;
d704 2
a705 2
intrmask_t
macebus_aux(intrmask_t hwpend, struct trap_frame *cf)
d729 1
a729 1
hw_setintrmask(intrmask_t m)
d732 1
a732 1
	    CRIME_INT_MASK) = mace_intem & ~m;
@


1.44
log
@ipending, cpl moved into cpu_info
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.43 2009/08/22 02:54:51 mk Exp $ */
a223 2
	hwmask_addr = (void *)
	    (PHYS_TO_XKPHYS(CRIMEBUS_BASE, CCA_NC) + CRIME_INT_MASK);
d726 7
@


1.43
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.42 2009/07/22 21:28:42 miod Exp $ */
d600 2
d604 1
a604 1
	cpl = newcpl;
d608 1
a608 1
	if (ipending & SINT_ALLMASK & ~newcpl)
d626 1
d636 1
a636 1
		atomic_setbits_int(&ipending, intstat & cf->cpl);
d638 1
a638 1
		mask &= ~ipending;
d645 1
a645 1
	atomic_clearbits_int(&ipending, pending);
@


1.42
log
@Get rid of bus_space_tag_t now unused bus_extent and bus_reverse fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.41 2009/07/22 21:28:08 miod Exp $ */
d451 1
a451 1
    int (*ih_fun)(void *), void *ih_arg, char *ih_what)
@


1.41
log
@Use direct mappings in XKPHYS for bus_space, instead of extent and TLB
backed pages.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.40 2009/07/22 20:08:23 miod Exp $ */
a107 1
	NULL,
a109 1
	0,
a121 1
	NULL,
a123 1
	0,
@


1.40
log
@Make sure the irq numbers for the O2 event counters match the interrupt lines
reported in dmesg.
While there, silence the spurious interrupt warning logic if, at the time
it is triggered, there are really no hardware interrupts pending; this can
happen if serial interrupts gets processed e.g. at splx() before the
hardware interrupt routine has a change to run.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.39 2009/07/17 18:06:51 miod Exp $ */
d40 1
a40 9
#include <sys/tty.h>
#include <sys/extent.h>
#include <net/netisr.h>
#include <uvm/uvm_extern.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>

#include <dev/ic/comvar.h>
d51 4
a54 4
int	macebusmatch(struct device *, void *, void *);
void	macebusattach(struct device *, struct device *, void *);
int	macebusprint(void *, const char *);
int	macebussearch(struct device *, void *, void *);
d56 2
a57 2
void	macebus_intr_makemasks(void);
void	macebus_do_pending_int(int);
d66 27
a92 21
void mace_write_1(bus_space_tag_t, bus_space_handle_t, bus_size_t, u_int8_t);
void mace_write_2(bus_space_tag_t, bus_space_handle_t, bus_size_t, u_int16_t);
void mace_write_4(bus_space_tag_t, bus_space_handle_t, bus_size_t, u_int32_t);
void mace_write_8(bus_space_tag_t, bus_space_handle_t, bus_size_t, u_int64_t);

void mace_read_raw_2(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, u_int8_t *, bus_size_t);
void mace_write_raw_2(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, const u_int8_t *, bus_size_t);
void mace_read_raw_4(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, u_int8_t *, bus_size_t);
void mace_write_raw_4(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, const u_int8_t *, bus_size_t);
void mace_read_raw_8(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, u_int8_t *, bus_size_t);
void mace_write_raw_8(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, const u_int8_t *, bus_size_t);

int mace_space_map(bus_space_tag_t, bus_addr_t, bus_size_t, int, bus_space_handle_t *);
void mace_space_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);
int mace_space_region(bus_space_tag_t, bus_space_handle_t, bus_size_t, bus_size_t, bus_space_handle_t *);
d94 1
a94 1
void *mace_space_vaddr(bus_space_tag_t, bus_space_handle_t);
d97 1
a97 3
paddr_t	macebus_device_to_pa(bus_addr_t);

int maceticks;		/* Time tracker for special events. */
d109 1
a109 1
	(bus_addr_t)MACEBUS_BASE,
d125 1
a125 1
	(bus_addr_t)CRIMEBUS_BASE,
a219 12
	u_int64_t mask;

	/*
	 * Create an extent for the localbus control registers.
	 */
	macebus_tag.bus_extent = extent_create("mace_space",
	    macebus_tag.bus_base, macebus_tag.bus_base + 0x00400000,
	    M_DEVBUF, NULL, 0, EX_NOCOALESCE | EX_NOWAIT);

	crimebus_tag.bus_extent = extent_create("crime_space",
	    crimebus_tag.bus_base, crimebus_tag.bus_base + 0x03000000,
	    M_DEVBUF, NULL, 0, EX_NOCOALESCE | EX_NOWAIT);
d225 1
a225 1
		printf(": cannot map CRIME control registers\n");
d228 2
a229 2
	hwmask_addr = (void *)(PHYS_TO_UNCACHED(CRIMEBUS_BASE) +
	    CRIME_INT_MASK);
d237 1
a237 2
	mask = 0;
	bus_space_write_8(&crimebus_tag, crime_h, CRIME_INT_MASK, mask);
a241 1

d246 2
a247 1
		printf("UH-OH! Can't map MACE ISA control registers!\n");
d253 1
a253 1
			  0xffffffff & ~MACE_ISA_INT_TIMER);
d263 1
a263 1
	/* DEBUG: Set up a handler called when clock interrupts go off. */
d282 1
a282 1
	panic("mace_read_2");
d306 1
a306 1
	panic("mace_write_2");
a382 2
extern int extent_malloc_flags;

d385 1
a385 1
    int cacheable, bus_space_handle_t *bshp)
d387 5
a391 28
	bus_addr_t bpa;
	int error;

	bpa = t->bus_base + offs;

	/* Handle special mapping separately. */
	if ((bpa >= (MACEBUS_BASE + MACE_IO_OFFS) &&
	    (bpa + size) < (MACEBUS_BASE + MACE_IO_OFFS + MACE_IO_SIZE))
	    || (bpa >= (MACEBUS_BASE + MACE_ISAX_OFFS) &&
	    (bpa + size) < (MACEBUS_BASE + MACE_ISAX_OFFS + MACE_ISAX_SIZE))) {
		*bshp = PHYS_TO_UNCACHED(bpa);
		return 0;
	}

	if ((error = extent_alloc_region(t->bus_extent, bpa, size,
	    EX_NOWAIT | extent_malloc_flags))) {
		return error;
	}

	if ((error = bus_mem_add_mapping(bpa, size, cacheable, bshp))) {
		if (extent_free(t->bus_extent, bpa, size,
		    EX_NOWAIT | extent_malloc_flags)) {
			printf("bus_space_map: pa %p, size %p\n", bpa, size);
			printf("bus_space_map: can't free region\n");
		}
	}

	return (error);
a396 31
	bus_addr_t sva, paddr;
	bus_size_t off, len;

	/* Should this verify that the proper size is freed? */
	sva = trunc_page(bsh);
	off = bsh - sva;
	len = size+off;

	if (IS_XKPHYS(bsh)) {
		paddr = XKPHYS_TO_PHYS(bsh);
		if ((paddr >= (MACEBUS_BASE + MACE_IO_OFFS) &&
		    (paddr + size) <=
		    (MACEBUS_BASE + MACE_IO_OFFS + MACE_IO_SIZE))
		    || (paddr >= (MACEBUS_BASE + MACE_ISAX_OFFS) &&
		    (paddr + size) <=
		    (MACEBUS_BASE + MACE_ISAX_OFFS + MACE_ISAX_SIZE)))
			return;
	}

	if (pmap_extract(pmap_kernel(), bsh, (void *)&paddr) == 0) {
		printf("bus_space_unmap: no pa for va %p\n", bsh);
		return;
	}

	uvm_km_free(kernel_map, sva, len);

	if (extent_free(t->bus_extent, paddr, size,
	    EX_NOWAIT | extent_malloc_flags)) {
		printf("bus_space_map: pa %p, size %p\n", paddr, size);
		printf("bus_space_map: can't free region\n");
	}
a726 4

	if (maceticks++ > 100*5) {
		maceticks = 0;
	}
@


1.39
log
@Update bus_dma to the better codebase found on almost all other platforms,
where the common part to all bus_dmamap_load*() functions is implemented in
in an internal load_buffer routine.

This allows the xbridge-specific dma code to only provide this function,
instead of three; and this also brings us a working bus_dmamap_load_uio()
on all supported sgi machines, which in turns make crpyto(4) devices really
work. Tested with hifn(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.38 2009/03/20 18:41:07 miod Exp $ */
d541 1
a541 1
	if (irq > 62 || irq < 1) {
d595 1
a595 1
	ih->ih_irq = irq;
d745 25
a769 10
		printf("stray interrupt, mace mask %lx stat %lx\n"
		    "crime mask %lx stat %lx hard %lx (pending %lx caught %lx)\n",
		    bus_space_read_8(&macebus_tag, mace_h, MACE_ISA_INT_MASK),
		    bus_space_read_8(&macebus_tag, mace_h, MACE_ISA_INT_STAT),
		    bus_space_read_8(&crimebus_tag, crime_h, CRIME_INT_MASK),
		    bus_space_read_8(&crimebus_tag, crime_h, CRIME_INT_STAT),
		    bus_space_read_8(&crimebus_tag, crime_h, CRIME_INT_HARD),
		    pending, caught);
		if (++spurious >= 10)
			panic("too many stray interrupts");
@


1.38
log
@Switch sgi to __HAVE_GENERIC_SOFT_INTERRUPTS.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.37 2008/07/30 17:37:46 miod Exp $ */
d154 1
@


1.37
log
@Implement bus_space_{read,write}_raw_mult_[248] correctly, it needs
endianness conversion on pci bridges.
ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.36 2008/04/07 22:34:23 miod Exp $ */
d631 3
a633 1
		imask[level] = irqs | SINT_ALLMASK;
a675 86
#if 0
	struct intrhand *ih;
	int vector;
	intrmask_t hwpend;
	struct trap_frame cf;
	static volatile int processing;

	/* Don't recurse... but change the mask. */
	if (processing) {
		__asm__ (" .set noreorder\n");
		cpl = newcpl;
		__asm__ (" sync\n .set reorder\n");
		return;
	}
	processing = 1;


	/* XXX Fake a trapframe for clock pendings... */
	cf.pc = (int)&macebus_do_pending_int;
	cf.sr = 0;
	cf.cpl = cpl;

	/* Hard mask current cpl so we don't get any new pendings. */
	hw_setintrmask(cpl);

	/* Find out what interrupts we should process. */
	hwpend = ipending & ~newcpl;
	hwpend &= ~SINT_ALLMASK;
	atomic_clearbits_int(&ipending, hwpend);

	/* Enable all non-pending non-masked hardware interrupts. */
	__asm__ (" .set noreorder\n");
	cpl = (cpl & SINT_ALLMASK) | (newcpl & ~SINT_ALLMASK) | hwpend;
	__asm__ (" sync\n .set reorder\n");
	hw_setintrmask(cpl);

	while (hwpend) {
		vector = ffs(hwpend) - 1;
		hwpend &= ~(1L << vector);
		ih = intrhand[vector];
		while (ih) {
			ih->frame = &cf;
			if ((*ih->ih_fun)(ih->ih_arg)) {
				ih->ih_count.ec_count++;
			}
			ih = ih->ih_next;
		}
	}

	/* Enable all processed pending hardware interrupts. */
	__asm__ (" .set noreorder\n");
	cpl &= ~hwpend;
	__asm__ (" sync\n .set reorder\n");
	hw_setintrmask(cpl);

	if ((ipending & SINT_CLOCKMASK) & ~newcpl) {
		atomic_clearbits_int(&ipending, SINT_CLOCKMASK);
		softclock();
	}
	if ((ipending & SINT_NETMASK) & ~newcpl) {
		extern int netisr;
		int isr;

		atomic_clearbits_int(&ipending, SINT_NETMASK);
		while ((isr = netisr) != 0) {
			atomic_clearbits_int(&netisr, isr);
#define	DONETISR(b,f)	if (isr & (1 << (b)))	f();
#include <net/netisr_dispatch.h>
		}
	}

#ifdef notyet
	if ((ipending & SINT_TTYMASK) & ~newcpl) {
		atomic_clearbits_int(&ipending, SINT_TTYMASK);
		compoll(NULL);
	}
#endif

	/* Update masks to new cpl. Order highly important! */
	__asm__ (" .set noreorder\n");
	cpl = newcpl;
	__asm__ (" sync\n .set reorder\n");
	hw_setintrmask(newcpl);

	processing = 0;
#else
a683 1
#endif
@


1.36
log
@Since uncached virtual addresses will depend upon space identifiers on R1xk
systems, switch to the PHYS_TO_UNCACHED macro to compute proper addresses.
Not really necessary for the O2 which does not implement spaces, but can't
hurt either.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.35 2008/03/30 20:14:40 miod Exp $ */
d79 13
d120 3
d136 3
d335 62
@


1.35
log
@Implement bus_space_*8 and bus_space_vaddr.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.34 2008/02/20 18:46:20 miod Exp $ */
d224 1
a224 1
	hwmask_addr = (void *)(PHYS_TO_XKPHYS(CRIMEBUS_BASE, CCA_NC) +
d334 1
a334 1
		*bshp = PHYS_TO_XKPHYS(bpa, CCA_NC);
@


1.34
log
@Completely overhault attachment rules on sgi. No more indirect configuration
inherited from OpenBSD/arc machines with ISA bus; mainbus children match on
device name and other hierarchies match on simplified locators.
As a bonus, attachment lines in dmesg will now print their locators.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.33 2007/12/14 16:34:29 jsing Exp $ */
d69 16
d108 1
d121 1
a290 1
#ifdef __LP64__
a291 3
#else
	return lp32_read8((u_int64_t *)(h + o));
#endif
a314 1
#ifdef __LP64__
a315 3
#else
	lp32_write8((u_int64_t *)(h + o), v);
#endif
d396 6
@


1.33
log
@Cleanup some comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.31 2007/11/13 12:04:13 jsing Exp $ */
d62 1
a62 1
int	macebusscan(struct device *, void *, void *);
a63 3
void   *macebus_intr_establish(void *, u_long, int, int, int (*)(void *),
	    void *, char *);
void	macebus_intr_disestablish(void *, void *);
d79 1
a79 1
	NULL, "macebus", DV_DULL, 1
d143 11
a153 2
/* XXXX print flags */
	return (QUIET);
a155 1

d157 1
a157 1
macebusscan(struct device *parent, void *child, void *args)
d159 2
a160 23
	struct device *dev = child;
	struct cfdata *cf = dev->dv_cfdata;
	struct confargs lba;
	struct abus lbus;

	if (cf->cf_fstate == FSTATE_STAR) {
		printf("macebus '*' devs not allowed!\n");
		return 0;
	}

	lba.ca_sys = cf->cf_loc[0];
	if (cf->cf_loc[1] == -1) {
		lba.ca_baseaddr = 0;
	} else {
		lba.ca_baseaddr = cf->cf_loc[1];
	}
	if (cf->cf_loc[2] == -1) {
		lba.ca_intr = 0;
		lba.ca_nintr = 0;
	} else {
		lba.ca_intr = cf->cf_loc[2];
		lba.ca_nintr = 1;
	}
d162 12
a173 1
	lba.ca_bus = &lbus;
d175 2
a176 8
	/* Fill in members needed for probing. */
	lba.ca_bus->ab_type = BUS_LOCAL;
	lba.ca_bus->ab_matchname = NULL;
	lba.ca_name = cf->cf_driver->cd_name;
	lba.ca_num = dev->dv_unit;
	lba.ca_iot = &macebus_tag;
	lba.ca_memt = &macebus_tag;
	lba.ca_dmat = &mace_bus_dma_tag;
d178 2
a179 1
	return (*cf->cf_attach->ca_match)(parent, cf, &lba);
a184 3
	struct device *dev;
	struct confargs lba;
	struct abus lbus;
a235 12
	 * Now attach all devices to macebus in the proper order.
	 */
	memset(&lba, 0, sizeof(lba));
	memset(&lbus, 0, sizeof(lbus));
	lba.ca_bus = &lbus;
	lba.ca_bus->ab_type = BUS_LOCAL;
	lba.ca_bus->ab_matchname = NULL;
	lba.ca_iot = &macebus_tag;
	lba.ca_memt = &macebus_tag;
	lba.ca_dmat = &mace_bus_dma_tag;

	/*
d239 2
a240 10
	switch (sys_config.system_type) {
	case SGI_O2:
		set_intr(INTPRI_MACEIO, CR_INT_0, macebus_iointr);
		lba.ca_bus->ab_intr_establish = macebus_intr_establish;
		lba.ca_bus->ab_intr_disestablish = macebus_intr_disestablish;
		register_pending_int_handler(macebus_do_pending_int);
		break;
	default:
		panic("macebusscan: unknown macebus type!");
	}
d245 1
a245 22
	while ((dev = config_search(macebusscan, self, aux)) != NULL) {
		struct cfdata *cf;

		cf = dev->dv_cfdata;
		lba.ca_sys = cf->cf_loc[0];
		if (cf->cf_loc[1] == -1)
			lba.ca_baseaddr = 0;
		else
			lba.ca_baseaddr = cf->cf_loc[1];

		if (cf->cf_loc[2] == -1) {
			lba.ca_intr = 0;
			lba.ca_nintr = 0;
		} else {
			lba.ca_intr= cf->cf_loc[2];
			lba.ca_nintr = 1;
		}
		lba.ca_name = cf->cf_driver->cd_name;
		lba.ca_num = dev->dv_unit;

		config_attach(self, dev, &lba, macebusprint);
	}
a246 1

@


1.32
log
@Allow direct access to the MACE IO memory space. This allows IO devices to
operate prior to the bus space extents being created.

ok miod@@
@
text
@d75 1
a75 1
int maceticks;		/* Time tracker for special events */
d133 1
a133 1
 *  Match bus only to targets which have this bus.
d202 1
a202 1
	 *  Create an extent for the localbus control registers.
d213 1
a213 1
	 *  Map and set up CRIME control registers.
d236 1
a236 1
	 *  Map and set up MACE ISA control registers.
d249 1
a249 1
	 *  Now attach all devices to macebus in proper order.
d261 2
a262 2
	 *  On O2 systems all interrupts are handled by the
	 *  macebus interrupt handler. Register all except clock.
d304 1
a304 1
 *  Bus access primitives. These are really ugly...
d466 1
a466 1
 *  Macebus interrupt handler driver.
d478 4
a481 5
 *  Establish an interrupt handler called from the dispatcher.
 *  The interrupt function established should return zero if
 *  there was nothing to serve (no int) and non zero when an
 *  interrupt was serviced.
 *  Interrupts are numbered from 1 and up where 1 maps to HW int 0.
d567 1
a567 1
 *  Regenerate interrupt masks to reflect reality.
d730 1
a730 1
 *  Process interrupts. The parameter pending has non-masked interrupts.
d805 1
a805 1
 *  Macebus auxilary functions run each clock interrupt.
@


1.31
log
@Expose mace_bus_dma_tag and extend the crimebus extent. This allows the
existing bus interfaces to be used to access the GBE hardware found in the
SGI O2.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.30 2007/11/11 14:56:41 jsing Exp $ */
d30 2
a31 2
 *  This is a combined macebus/crimebus driver. It handles
 *  configuration of all devices on the processor bus.
d56 1
a57 1
#include <sgi/localbus/crimebus.h>
d59 10
a68 10
int macebusmatch(struct device *, void *, void *);
void macebusattach(struct device *, struct device *, void *);
int macebusprint(void *, const char *);
int macebusscan(struct device *, void *, void *);

void *macebus_intr_establish(void *, u_long, int, int,
			int (*)(void *), void *, char *);
void macebus_intr_disestablish(void *, void *);
void macebus_intr_makemasks(void);
void macebus_do_pending_int(int);
d375 4
a378 2
	if (bpa >= (MACEBUS_BASE + MACE_ISAX_OFFS) &&
	    (bpa + size) < (MACEBUS_BASE + MACE_ISAX_OFFS + MACE_ISAX_SIZE)) {
d412 4
a415 1
		if (paddr >= (MACEBUS_BASE + MACE_ISAX_OFFS) &&
d417 1
a417 1
		    (MACEBUS_BASE + MACE_ISAX_OFFS + MACE_ISAX_SIZE))
@


1.30
log
@Add spurious interrupt detection to macebus. This allows for the detection
of interrupt storms and enables the user to "boot poweroff" from ddb,
instead of pulling the powercord.

Initial code heavily reworked by miod@@

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.29 2007/10/14 11:18:42 jsing Exp $ */
d209 1
a209 1
	    crimebus_tag.bus_base, crimebus_tag.bus_base + 0x00400000,
@


1.29
log
@Disable timer/compare interrupts on the macebus. This prevents interrupt
storms from occurring on IRQ 6. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.28 2007/10/13 06:25:48 miod Exp $ */
d736 3
d774 4
a777 1
	if (caught)
d779 16
@


1.28
log
@Various typos in comments; Joel Sing
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.27 2007/10/10 15:53:52 art Exp $ */
d243 3
a245 1
	bus_space_write_8(&macebus_tag, mace_h, MACE_ISA_INT_MASK, 0xffffffff);
@


1.27
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.26 2007/07/09 21:40:24 jasper Exp $ */
d180 1
a180 1
	/* Fill in what is needed for probing */
a275 1

d372 1
a372 1
	/* Handle special mapping separately */
d401 1
a401 1
	/* should this verify that the proper size is freed? */
d497 1
a497 1
	/* no point in sleeping unless someone can free memory. */
d633 1
a633 1
	/* Don't recurse... but change the mask */
d648 1
a648 1
	/* Hard mask current cpl so we don't get any new pendings */
d651 1
a651 1
	/* Get what interrupt we should process */
d656 1
a656 1
	/* Enable all non pending non masked hardware interrupts */
d675 1
a675 1
	/* Enable all processed pending hardware interrupts */
d717 1
a717 1
	/* If we still have softints pending trigg processing */
d741 1
a741 1
	/* Mask off masked interrupts and save them as pending */
d750 1
a750 1
	/* Scan all unmasked. Scan the first 16 for now */
d772 1
a772 1
	return 0;  /* Non found here */
d789 1
a789 1
	/* RED   - User Mode */
d804 1
a804 1
	return 0; /* Real clock int handler registers */
@


1.26
log
@change the behaviour of the LED on the O2 so that it's red in user mode
and green when idling.

from Joel Sing <joel at ionix.com.au>

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.25 2007/06/21 20:17:12 miod Exp $ */
a782 1
	extern char idle[], e_idle[];
d793 2
a794 1
	} else if (cf->pc >= (long)idle && cf->pc < (long)e_idle) {
@


1.25
log
@Extent sgi bus_dma to cope with different views of memory: non-contiguous
for the cpu, contiguous from different bases for devices. This allows
memory above 256MB to be used with bus_dma (and we had really been lucky
with the first few large-memory builds).
Information about memory accesses taken from Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.24 2007/06/20 20:47:34 miod Exp $ */
d789 1
a789 1
	/* GREEN - User mode */
d791 1
a791 1
	/* RED   - IDLE */
d793 1
a793 1
		mask &= ~MACE_ISA_MISC_GLED_OFF;
d795 1
a795 1
		mask &= ~MACE_ISA_MISC_RLED_OFF;
@


1.24
log
@Do not hardcode imask[] size when intializing it.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.23 2007/06/20 16:50:43 miod Exp $ */
d72 3
d127 3
a129 1
	NULL
d435 22
@


1.23
log
@Make sure IPL_CLOCK blocks device interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.22 2007/06/18 20:24:50 miod Exp $ */
d552 1
a552 1
	for (level = 0; level < 5; level++) {
@


1.22
log
@Disable instruction reordering around cpl assignments.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.21 2007/05/29 18:10:43 miod Exp $ */
d563 1
a563 4
	 */
	imask[IPL_VM] |= imask[IPL_TTY] | imask[IPL_NET] | imask[IPL_BIO];

	/*
a566 1
	imask[IPL_TTY] |= imask[IPL_NET] | imask[IPL_BIO];
d568 3
@


1.21
log
@Use atomic operations to operate on netisr, instead of clearing it at splhigh.
This changes nothing on legacy architectures, but is a bit faster (and simpler)
on the interesting ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.20 2007/05/03 19:34:01 miod Exp $ */
d601 1
a601 1
#ifdef _USE_SILLY_OVERWORKED_HW_INT_PENDING_HANDLER_
d610 1
d612 1
d632 1
d634 1
d651 1
d653 1
d672 1
a672 1
#ifdef NOTYET
d680 1
d682 1
d688 1
d690 1
d693 1
a693 1
	if (ipending & SINT_ALLMASK & ~cpl)
@


1.20
log
@Enable support for > 512MB of physical memory on mips64 systems, by using
XKPHYS instead of KSEG[01] for direct mappings.

Then, detect memory above 256MB on O2 by poking at the CRIME registers
(ARCbios will not report memory above 256MB, which is mapped above 1GB
physical, to the system), and add it to the UVM managed memory.

Tested on r5k, rm5200 and r10k with and without more than 256MB, matching
hinv reports in all cases. CRIME memory decoding based on a diff from
kettenis@@ in december 2005.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.19 2007/03/23 21:07:40 miod Exp $ */
d656 2
a657 2
		int isr = netisr;
		netisr = 0;
d659 2
d663 1
@


1.19
log
@Real atomic_{set,clear}bits_int implementation, and replace similar
{set,clr}_ipending with the above routines.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.18 2006/01/04 20:23:07 miod Exp $ */
d214 2
a215 1
	hwmask_addr = (void *)(PHYS_TO_KSEG1(CRIMEBUS_BASE)+CRIME_INT_MASK);
d371 1
a371 1
		*bshp = PHYS_TO_KSEG1(bpa);
d402 7
a408 4
	paddr = KSEG1_TO_PHYS(bsh);
	if (paddr >= (MACEBUS_BASE + MACE_ISAX_OFFS) &&
	    (paddr+size) <= (MACEBUS_BASE + MACE_ISAX_OFFS + MACE_ISAX_SIZE))
		return;
@


1.18
log
@Stop abusing phys_map to know if it is safe to use malloc in extent routines;
instead use a global flag, like some other architectures do. No functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.17 2006/01/04 20:20:16 miod Exp $ */
d54 1
d623 1
a623 1
	clr_ipending(hwpend);
d647 1
a647 1
		clr_ipending(SINT_CLOCKMASK);
d654 1
a654 1
		clr_ipending(SINT_NETMASK);
d661 1
a661 1
		clr_ipending(SINT_TTYMASK);
d701 1
a701 1
		set_ipending(intstat & cf->cpl);
d710 1
a710 1
	clr_ipending(pending);
@


1.17
log
@Do not return zero in bus_space_map() on failure (sigh).
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.16 2006/01/04 20:18:37 miod Exp $ */
d355 2
d374 1
a374 1
	    EX_NOWAIT | EX_MALLOCOK))) {
d378 3
a380 3
	if ((error  = bus_mem_add_mapping(bpa, size, cacheable, bshp))) {
		if (extent_free(t->bus_extent, bpa, size, EX_NOWAIT |
		    ((phys_map != NULL) ? EX_MALLOCOK : 0))) {
d410 1
a410 5
	if (phys_map != NULL &&
	    ((sva >= VM_MIN_KERNEL_ADDRESS) && (sva < VM_MAX_KERNEL_ADDRESS))) {
		/* do not free memory which was stolen from the vm system */
		uvm_km_free(kernel_map, sva, len);
	}
d412 2
a413 2
	if (extent_free(t->bus_extent, paddr, size, EX_NOWAIT |
	    ((phys_map != NULL) ? EX_MALLOCOK : 0))) {
@


1.16
log
@Use symbolic constants for the MACE ISA address range in mace_space_unmap()
too!
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.15 2005/12/20 06:59:27 miod Exp $ */
d383 2
a384 1
	return 0;
@


1.15
log
@Remove initial extent storage for crime and mace bus_space. By the time
these extents are created it is safe to use malloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.14 2005/12/19 21:37:47 miod Exp $ */
d398 2
a399 1
	if (paddr >= 0x1f380000 && (paddr+size) <= 0x1f3a0000)
@


1.14
log
@Use MACE ISA constants instead of magic values.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.13 2005/08/14 11:02:32 miod Exp $ */
a70 3
long mace_ext_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof (long)];
long crime_ext_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof (long)];

d200 1
a200 2
	    M_DEVBUF, (caddr_t)mace_ext_storage,
	    sizeof(mace_ext_storage), EX_NOCOALESCE|EX_NOWAIT);
d204 1
a204 2
	    M_DEVBUF, (caddr_t)crime_ext_storage,
	    sizeof(crime_ext_storage), EX_NOCOALESCE|EX_NOWAIT);
@


1.13
log
@catched->caught
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.12 2005/07/18 02:43:25 fgsch Exp $ */
d370 2
a371 1
	if ((bpa >= 0x1f380000 && (bpa+size) <= 0x1f3a0000) ) {
@


1.12
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.11 2005/01/31 21:35:50 grange Exp $ */
d691 1
a691 1
	intrmask_t catched, vm;
d700 1
a700 1
	catched = 0;
d708 1
a708 1
		catched++;
d722 1
a722 1
					catched |= vm;
d730 1
a730 1
	if (catched)
@


1.11
log
@Un-__P.

ok pefo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.10 2004/09/27 19:20:49 pefo Exp $ */
d466 1
a466 1
		panic("intr_establish: illegal irq %d\n", irq);
@


1.10
log
@Rewrite parts of the interrupt system to achive:

o Remove do_pending code and take a real int instead. The performance
  impact seems to be very low and it simplifies the code considerably.

o Allow interrupt nesting at first level. Run softints with HW ints
  enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.9 2004/09/24 14:22:49 deraadt Exp $ */
d440 1
a440 1
static int fakeintr __P((void *));
@


1.9
log
@new style interrupt counters; pefo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.8 2004/09/21 05:51:15 miod Exp $ */
d67 1
a67 1
void macebus_do_pending_int(void);
a75 2
u_int64_t crimestat;

d598 1
a598 1
macebus_do_pending_int(void)
d600 1
a602 1
	intrmask_t pcpl;
d607 3
a609 2
	/* Don't recurse... */
	if (processing)
d611 1
a613 2
	/* XXX interrupt vulnerable when changing ipending */
	pcpl = splhigh();		/* Turn off all */
d618 13
a630 1
	cf.cpl = pcpl;
a631 3
	hwpend = ipending & ~pcpl;	/* Do now unmasked pendings */
	hwpend &= ~(SINT_ALLMASK);
	ipending &= ~hwpend;
d644 7
a650 2
	if ((ipending & SINT_CLOCKMASK) & ~pcpl) {
		ipending &= ~SINT_CLOCKMASK;
d653 1
a653 1
	if ((ipending & SINT_NETMASK) & ~pcpl) {
d657 1
a657 1
		ipending &= ~SINT_NETMASK;
d663 2
a664 2
	if ((ipending & SINT_TTYMASK) & ~pcpl) {
		ipending &= ~SINT_TTYMASK;
d669 3
a671 2
	cpl = pcpl;	/* Don't use splx... we are here already! */
	hw_setintrmask(pcpl);
d674 8
d697 2
a698 2
crimestat=intstat;
	intstat &= 0x0000ffff;
d704 1
a704 1
		ipending |= intstat & cf->cpl;
d711 1
a711 1
	/* Scan the first 16 for now */
d713 1
@


1.8
log
@Nuke commons.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.7 2004/09/20 10:31:16 pefo Exp $ */
a518 1
	ih->ih_count = 0;
d523 2
d632 1
a632 1
				ih->ih_count++;
d701 1
a701 1
					ih->ih_count++;
@


1.7
log
@Add support for R10K cpu class
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.6 2004/09/09 22:11:39 pefo Exp $ */
a440 1
struct intrhand *intrhand[INTMASKSIZE];
@


1.6
log
@Kernel moves to 64 bit. A few more tweaks when binutils is updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.5 2004/08/11 15:13:35 deraadt Exp $ */
d76 2
d676 1
@


1.5
log
@various ansi and spacing issues; pefo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.4 2004/08/10 19:16:18 deraadt Exp $ */
d325 3
d329 1
d353 3
d357 1
d736 1
a736 1
	if (maceticks++ > 100*15) {
@


1.4
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.3 2004/08/10 08:07:35 mickey Exp $ */
d133 1
a133 4
macebusmatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d135 1
a135 1
	if (sys_config.system_type == SGI_O2) {
d137 1
a137 2
	}
	return(0);
d141 1
a141 3
macebusprint(aux, macebus)
	void *aux;
	const char *macebus;
d171 1
a171 1
		lba.ca_intr= cf->cf_loc[2];
d190 1
a190 4
macebusattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d202 3
a204 3
		macebus_tag.bus_base, macebus_tag.bus_base + 0x00400000,
		M_DEVBUF, (caddr_t)mace_ext_storage,
		sizeof(mace_ext_storage), EX_NOCOALESCE|EX_NOWAIT);
d207 3
a209 3
		crimebus_tag.bus_base, crimebus_tag.bus_base + 0x00400000,
		M_DEVBUF, (caddr_t)crime_ext_storage,
		sizeof(crime_ext_storage), EX_NOCOALESCE|EX_NOWAIT);
d215 1
a215 1
		printf("UH-OH! Can't map CRIME control registers!\n");
d221 1
a221 1
	printf(" Crime revision %d.%d\n", (creg & 0xf0) >> 4, creg & 0xf);
d260 1
a260 2
	switch(sys_config.system_type) {

a266 1

d280 1
a280 1
		if (cf->cf_loc[1] == -1) {
d282 1
a282 1
		} else {
d284 1
a284 1
		}
d354 1
a354 1
        int cacheable, bus_space_handle_t *bshp)
d385 2
a386 3
        bus_addr_t sva;
        bus_size_t off, len;
        bus_addr_t paddr;
d417 1
a417 1
	bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp)
d419 2
a420 2
        *nbshp = bsh + offset;
        return (0);
a426 1

d444 2
a445 8
macebus_intr_establish(icp, irq, type, level, ih_fun, ih_arg, ih_what)
	void *icp;
        u_long irq;	/* XXX pci_intr_handle_t compatible XXX */
        int type;
        int level;
        int (*ih_fun) __P((void *));
        void *ih_arg;
        char *ih_what;
d450 2
a451 3
extern int cold;

static int initialized = 0;
d529 1
a529 1
macebus_intr_makemasks()
d590 1
a590 1
macebus_do_pending_int()
d597 1
a597 1
static volatile int processing;
d604 1
a604 1
/* XXX interrupt vulnerable when changing ipending */
d710 1
a711 2
extern char idle[];
extern char e_idle[];
d716 1
a716 1
	/* GREEN - User mode   */
d718 1
a718 1
	/* RED   - IDLE        */
@


1.3
log
@use generic net/netisr_dispatch.h; pefo@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.2 2004/08/10 07:48:45 mickey Exp $ */
d5 1
a5 1
 * 
d49 1
a49 1
 
d112 1
a112 1
	NULL,			/* _cookie */ 
d170 1
a170 1
	} else {    
d176 1
a176 1
	} else {    
d234 1
a234 1
	
d293 1
a293 1
		} else {    
d299 1
a299 1
		} else {    
d456 1
a456 1
void *   
d473 2
a474 2
	if(!initialized) {
/*INIT CODE HERE*/
d478 1
a478 1
	if(irq > 62 || irq < 1) {
d488 1
a488 1
	if(type == IST_NONE || type == IST_PULSE)
d621 1
a621 1
		return;	
d641 1
a641 1
			if((*ih->ih_fun)(ih->ih_arg)) {
@


1.2
log
@give mace some dma; pefo@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: macebus.c,v 1.1 2004/08/06 21:12:19 pefo Exp $ */
d656 2
a657 49
#ifdef  INET
#include "ether.h"
		if (NETHER > 0 && isr & (1 << NETISR_ARP)) {
			arpintr();
		}

		if (isr & (1 << NETISR_IP)) {
			ipintr();
		}
#endif
#ifdef INET6
		if(isr & (1 << NETISR_IPV6)) {
			ip6intr();
		}
#endif
#ifdef NETATALK
		if (isr & (1 << NETISR_ATALK)) {
			atintr();
		}
#endif
#ifdef  IMP
		if (isr & (1 << NETISR_IMP)) {
			impintr();
		}
#endif
#ifdef  NS
		if (isr & (1 << NETISR_NS)) {
			nsintr();
		}
#endif
#ifdef  ISO
		if (isr & (1 << NETISR_ISO)) {
			clnlintr();
		}
#endif
#ifdef  CCITT
		if (isr & (1 << NETISR_CCITT)) {
			ccittintr();
		}
#endif
#include "ppp.h"
		if (NPPP > 0 && isr & (1 << NETISR_PPP)) {
			pppintr();
		}

#include "bridge.h"
		if (NBRIDGE > 0 && isr & (1 << NETISR_BRIDGE)) {
			bridgeintr();
		}
d716 2
a717 1
	if (catched) {
a718 1
	}
@


1.1
log
@initial sgi import
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d111 17
d190 1
d263 1
@

