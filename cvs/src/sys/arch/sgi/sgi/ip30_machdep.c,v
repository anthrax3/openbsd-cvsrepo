head	1.68;
access;
symbols
	OPENBSD_6_1_BASE:1.68
	OPENBSD_6_0:1.65.0.2
	OPENBSD_6_0_BASE:1.65
	OPENBSD_5_9:1.63.0.4
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.63.0.6
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.58.0.4
	OPENBSD_5_5_BASE:1.58
	OPENBSD_5_4:1.57.0.4
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.57.0.2
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.55.0.2
	OPENBSD_5_2_BASE:1.55
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.4
	OPENBSD_5_0:1.47.0.2
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.44.0.2
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.43.0.2
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.8.0.2
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.68
date	2016.10.27.13.19.27;	author visa;	state Exp;
branches;
next	1.67;
commitid	6Ve06RHpI01QGFsX;

1.67
date	2016.10.26.13.42.54;	author visa;	state Exp;
branches;
next	1.66;
commitid	khNYWeTCmYcllpHh;

1.66
date	2016.10.09.11.25.40;	author tom;	state Exp;
branches;
next	1.65;
commitid	DfYvEDcFmu1LY9q1;

1.65
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.64;
commitid	cyYKarj4qRTft4gD;

1.64
date	2016.02.27.13.08.07;	author mpi;	state Exp;
branches;
next	1.63;
commitid	hnv9KfQtxhCytAnd;

1.63
date	2014.12.06.23.20.17;	author krw;	state Exp;
branches;
next	1.62;
commitid	dHu3Jb8ymJQQ9GXS;

1.62
date	2014.07.12.22.37.03;	author uebayasi;	state Exp;
branches;
next	1.61;
commitid	5h3kYJioMDqUXM3V;

1.61
date	2014.07.12.14.12.44;	author uebayasi;	state Exp;
branches;
next	1.60;
commitid	CwxiCWSX4kdxVfoo;

1.60
date	2014.04.03.08.07.16;	author mpi;	state Exp;
branches;
next	1.59;

1.59
date	2014.03.09.10.12.17;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2014.01.06.21.41.15;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2012.09.29.19.11.08;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2012.07.16.16.06.40;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2012.06.28.22.11.33;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2012.06.24.16.26.04;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2012.04.03.21.17.35;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2012.03.28.20.44.23;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2012.03.25.13.52.52;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2012.03.16.15.25.05;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2012.03.15.18.57.22;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2011.05.30.22.25.22;	author oga;	state Exp;
branches;
next	1.46;

1.46
date	2011.04.10.17.16.51;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2011.04.03.22.34.54;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2010.09.09.10.59.02;	author syuu;	state Exp;
branches;
next	1.43;

1.43
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2010.04.28.16.20.28;	author syuu;	state Exp;
branches;
next	1.41;

1.41
date	2010.04.21.14.57.11;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2010.04.06.19.15.29;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2010.04.06.19.02.47;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2010.03.13.21.55.30;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2010.03.07.13.44.26;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2010.02.28.18.01.39;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2010.01.19.19.54.24;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2010.01.14.07.22.31;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2010.01.13.23.24.27;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2010.01.13.22.57.30;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2010.01.09.23.34.29;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.09.20.33.16;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2010.01.05.06.44.58;	author syuu;	state Exp;
branches;
next	1.28;

1.28
date	2009.12.28.06.55.27;	author syuu;	state Exp;
branches;
next	1.27;

1.27
date	2009.12.07.19.05.59;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.02.01.42.14;	author syuu;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.27.10.22.09;	author syuu;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.25.17.39.51;	author syuu;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.24.22.46.59;	author syuu;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.22.22.44.58;	author syuu;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.22.19.41.41;	author syuu;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.22.18.33.48;	author syuu;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.21.20.55.44;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.21.19.39.19;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.19.06.06.51;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.18.19.05.51;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.31.00.20.46;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.30.08.13.57;	author syuu;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.22.22.08.54;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.22.20.05.28;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.16.00.15.49;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.14.20.21.16;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2009.08.18.19.31.56;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.06.22.46.43;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.01.21.56.38;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.18.14.48.08;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.15.18.42.23;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.13.21.17.54;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2009.04.12.17.53.02;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.24.12.52.26;	author jsing;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.07.22.43.45;	author miod;	state Exp;
branches;
next	;


desc
@@


1.68
log
@Revert previous `ncpus' change because the percpu code now works
without it.
@
text
@/*	$OpenBSD: ip30_machdep.c,v 1.67 2016/10/26 13:42:54 visa Exp $	*/

/*
 * Copyright (c) 2008, 2009 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Octane (IP30) specific code.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/tty.h>

#include <mips64/arcbios.h>
#include <mips64/cache.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/memconf.h>

#include <uvm/uvm_extern.h>

#include <sgi/sgi/ip30.h>
#include <sgi/xbow/widget.h>
#include <sgi/xbow/xbow.h>
#include <sgi/xbow/xbowdevs.h>
#include <sgi/xbow/xbridgereg.h>	/* BRIDGE_PCI0_MEM_SPACE_BASE */

#include <sgi/xbow/xheartreg.h>
#include <sgi/pci/iocreg.h>

#include <dev/ic/comvar.h>

extern char *hw_prod;

extern int	mbprint(void *, const char *);

#ifdef MULTIPROCESSOR
extern int      xheart_intr_establish(int (*)(void *), void *, int, int, 
    const char *, struct intrhand *);
extern void     xheart_intr_set(int);
extern void     xheart_intr_clear(int);
extern void	xheart_setintrmask(int);

extern struct	user *proc0paddr;
#endif

uint32_t ip30_lights_frob(uint32_t, struct trapframe *);
paddr_t	ip30_widget_short(int16_t, u_int);
paddr_t	ip30_widget_long(int16_t, u_int);
paddr_t	ip30_widget_map(int16_t, u_int, bus_addr_t *, bus_size_t *);
int	ip30_widget_id(int16_t, u_int, uint32_t *);
static u_long ip30_get_ncpusfound(void);

#ifdef DDB
void	ip30_nmi(void);			/* ip30_nmi.S */
void	ip30_nmi_handler(void);
#endif

static	paddr_t ip30_iocbase;

static const paddr_t mpconf =
    PHYS_TO_XKPHYS(MPCONF_BASE, CCA_COHERENT_EXCLWRITE);

static int ip30_cpu_exists(int);

void
ip30_setup()
{
	paddr_t heart;
	int bank;
	uint32_t memcfg;
	uint64_t start, count, end;
	u_long cpuspeed;
#ifdef DDB
	struct ip30_gda *gda;
#endif

	/*
	 * Scan for memory. ARCBios reports up to 1GB of memory as available,
	 * and anything after is reported as reserved.
	 */
	heart = PHYS_TO_XKPHYS(HEART_PIU_BASE, CCA_NC);
	for (bank = 0; bank < 8; bank++) {
		memcfg = *(volatile uint32_t *)
		    (heart + HEART_MEMORY_STATUS + bank * sizeof(uint32_t));
#ifdef DEBUG
		bios_printf("memory bank %d: %08x\n", bank, memcfg);
#endif

		if (!ISSET(memcfg, HEART_MEMORY_VALID))
			continue;

		count = ((memcfg & HEART_MEMORY_SIZE_MASK) >>
		    HEART_MEMORY_SIZE_SHIFT) + 1;
		start = (memcfg & HEART_MEMORY_ADDR_MASK) >>
		    HEART_MEMORY_ADDR_SHIFT;

		count <<= HEART_MEMORY_UNIT_SHIFT;
		start <<= HEART_MEMORY_UNIT_SHIFT;

		/* Physical memory starts at 512MB */
		start += IP30_MEMORY_BASE;
		end = start + count;
#ifdef DEBUG
		bios_printf("memory from %p to %p\n",
		    start, end);
#endif

		/*
		 * Add memory not obtained through ARCBios.
		 */
		if (start < IP30_MEMORY_BASE + IP30_MEMORY_ARCBIOS_LIMIT)
			start = IP30_MEMORY_BASE + IP30_MEMORY_ARCBIOS_LIMIT;
#if 0
		/*
		 * XXX Temporarily restrict memory to 1.5GB, until the bug
		 * XXX causing low memory corruption is found.
		 */
		if (end > 0x80000000UL)
			end = 0x80000000UL;
#endif
		if (start < end)
			memrange_register(atop(start), atop(end), 0);
	}

	/*
	 * Register DMA-reachable memory constraints.
	 * The xbridge(4) is limited to a 31-bit region (its IOMMU features
	 * are too restricted to be of use).
	 */
	dma_constraint.ucr_low = 0;
	dma_constraint.ucr_high = (1UL << 31) - 1;

	xbow_widget_base = ip30_widget_short;
	xbow_widget_map = ip30_widget_map;
	xbow_widget_id = ip30_widget_id;

	bootcpu_hwinfo.c0prid = cp0_get_prid();
	bootcpu_hwinfo.c1prid = cp1_get_prid();
	cpuspeed = bios_getenvint("cpufreq");
	if (cpuspeed < 100)
		cpuspeed = 175;		/* reasonable default */
	bootcpu_hwinfo.clock = cpuspeed * 1000000;
	bootcpu_hwinfo.tlbsize = 64;	/* R10000 family */
	bootcpu_hwinfo.type = (bootcpu_hwinfo.c0prid >> 8) & 0xff;

	/*
	 * Initialize the early console parameters.
	 * On Octane, the BRIDGE is always widget 15, and IOC3 is always
	 * mapped in memory space at address 0x500000.
	 *
	 * Also, note that by using a direct widget bus_space, there is
	 * no endianness conversion done on the bus addresses. Which is
	 * exactly what we need, since the IOC3 doesn't need any. Some
	 * may consider this an evil abuse of bus_space knowledge, though.
	 */

	xbow_build_bus_space(&sys_config.console_io, 0, IP30_BRIDGE_WIDGET);
	sys_config.console_io.bus_base =
	    ip30_widget_long(0, IP30_BRIDGE_WIDGET) +
	    BRIDGE_PCI0_MEM_SPACE_BASE + 0x500000;

	comconsaddr = IOC3_UARTA_BASE;
	comconsfreq = 22000000 / 3;
	comconsiot = &sys_config.console_io;
	comconsrate = bios_consrate;

#ifdef DDB
	/*
	 * Setup NMI handler.
	 */
	gda = (struct ip30_gda *)PHYS_TO_XKPHYS(GDA_BASE, CCA_CACHED);
	if (gda->magic == GDA_MAGIC)
		gda->nmi_cb = ip30_nmi;
#endif

	/*
	 * Octane and Octane2 can be told apart with a GPIO source bit
	 * in the onboard IOC3.
	 */
	ip30_iocbase = sys_config.console_io.bus_base;
	if (*(volatile uint32_t *)
	    (ip30_iocbase + IOC3_GPPR(IP30_GPIO_CLASSIC)) != 0)
		hw_prod = "Octane";
	else
		hw_prod = "Octane2";

	ncpusfound = ip30_get_ncpusfound();

	_device_register = arcs_device_register;
}

/*
 * Autoconf enumeration
 */

void
ip30_autoconf(struct device *parent)
{
	struct cpu_attach_args caa;
#ifdef MULTIPROCESSOR
	struct cpu_hwinfo hw;
	int cpuid;
#endif

	bzero(&caa, sizeof caa);
	caa.caa_maa.maa_nasid = masternasid;
	caa.caa_maa.maa_name = "cpu";
	caa.caa_hw = &bootcpu_hwinfo;
	config_found(parent, &caa, mbprint);

#ifdef MULTIPROCESSOR
	for (cpuid = 1; cpuid < IP30_MAXCPUS; cpuid++)
		if (ip30_cpu_exists(cpuid)) {
			/*
			 * Attach other processors with the same hardware
			 * information as the boot processor, unless we
			 * can get this information from the MPCONF area;
			 * since Octane processors should be identical
			 * (model, speed and cache), this should be safe.
			 */
			bcopy(&bootcpu_hwinfo, &hw, sizeof(struct cpu_hwinfo));
			hw.c0prid = 
			    *(volatile uint32_t *)(mpconf + MPCONF_PRID(cpuid));
			hw.type = (hw.c0prid >> 8) & 0xff;
			hw.l2size = 1 << *(volatile uint32_t *)
			    (mpconf + MPCONF_SCACHESZ(cpuid));
			caa.caa_hw = &hw;
			config_found(parent, &caa, mbprint);
		}
#endif

	caa.caa_maa.maa_name = "clock";
	config_found(parent, &caa.caa_maa, mbprint);
	caa.caa_maa.maa_name = "xbow";
	config_found(parent, &caa.caa_maa, mbprint);
	caa.caa_maa.maa_name = "power";
	config_found(parent, &caa.caa_maa, mbprint);
}

/*
 * Widget mapping. IP30 only has one processor board node, so the nasid
 * parameter is ignored.
 */

paddr_t
ip30_widget_short(int16_t nasid, u_int widget)
{
	return PHYS_TO_XKPHYS(((uint64_t)widget << 24) | (1ULL << 28), CCA_NC);
}

paddr_t
ip30_widget_long(int16_t nasid, u_int widget)
{
	return PHYS_TO_XKPHYS((uint64_t)(widget) << 36, CCA_NC);
}

paddr_t
ip30_widget_map(int16_t nasid, u_int widget, bus_addr_t *offs, bus_size_t *len)
{
	paddr_t base;

	/*
	 * On Octane, the whole widget space is always accessible.
	 */

	base = ip30_widget_long(nasid, widget);
	*len = (1ULL << 36) - *offs;

	return base + *offs;
}

/*
 * Widget enumeration
 */

int
ip30_widget_id(int16_t nasid, u_int widget, uint32_t *wid)
{
	paddr_t linkpa, wpa;

	if (widget != 0) {
		if (widget < WIDGET_MIN || widget > WIDGET_MAX)
			return EINVAL;

		linkpa = ip30_widget_short(nasid, 0) + XBOW_WIDGET_LINK(widget);
		if (!ISSET(*(uint32_t *)(linkpa + (WIDGET_LINK_STATUS | 4)),
		    WIDGET_STATUS_ALIVE))
			return ENXIO;	/* not connected */
	}

	wpa = ip30_widget_short(nasid, widget);
	if (wid != NULL)
		*wid = *(uint32_t *)(wpa + (WIDGET_ID | 4));

	return 0;
}

/*
 * Figure out which video widget to use.
 *
 * If we are running with glass console, ConsoleOut will be `video(#)' with
 * the optional number being the number of the video device in the ARCBios
 * component tree.
 *
 * Unfortunately, we do not know how to match an ARCBios component to a
 * given widget (the PROM can... it's just not sharing this with us).
 *
 * So simply walk the available widget space and count video devices.
 */

int
ip30_find_video()
{
	uint widid, head;
	uint32_t id, vendor, product;
	char *p;

	if (strncmp(bios_console, "video", 5) != 0)
		return 0;	/* not graphics console */

	p = bios_console + 5;
	switch (*p) {
	case '(':
		/* 8 widgets max -> single digit */
		p++;
		if (*p == ')')
			head = 0;
		else {
			if (*p < '0' || *p > '9')
				return 0;
			head = *p++ - '0';
			if (*p != ')')
				return 0;
		}
		break;
	case '\0':
		head = 0;
		break;
	default:
		return 0;
	}

	for (widid = WIDGET_MAX; widid >= WIDGET_MIN; widid--) {
		if (ip30_widget_id(0, widid, &id) != 0)
			continue;

		vendor = WIDGET_ID_VENDOR(id);
		product = WIDGET_ID_PRODUCT(id);

		if ((vendor == XBOW_VENDOR_SGI2 &&
		    product == XBOW_PRODUCT_SGI2_ODYSSEY) ||
		    (vendor == XBOW_VENDOR_SGI5 &&
		    product == XBOW_PRODUCT_SGI5_IMPACT) ||
		    (vendor == XBOW_VENDOR_SGI5 &&
		    product == XBOW_PRODUCT_SGI5_KONA)) {
			/* found a video device */
			if (head == 0)
				return widid;
			head--;
		}
	}

	return 0;
}

/*
 * Fun with the lightbar
 */
uint32_t
ip30_lights_frob(uint32_t hwpend, struct trapframe *cf)
{
	uint32_t gpioold, gpio;

	/* Light bar status: idle - white, user - red, system - both */

	gpio = gpioold = *(volatile uint32_t *)(ip30_iocbase + IOC3_GPDR);
	gpio &= ~((1 << IP30_GPIO_WHITE_LED) | (1 << IP30_GPIO_RED_LED));

	if (cf->sr & SR_KSU_USER)
		gpio |= (1 << IP30_GPIO_RED_LED);
	else {
		gpio |= (1 << IP30_GPIO_WHITE_LED);

		/* XXX SMP check other CPU is unidle */
		if (curproc != curcpu()->ci_schedstate.spc_idleproc)
			gpio |= (1 << IP30_GPIO_RED_LED);
	}

	if (gpio != gpioold)
		*(volatile uint32_t *)(ip30_iocbase + IOC3_GPDR) = gpio;

	return 0;	/* Real clock int handler will claim the interrupt. */
}

static int
ip30_cpu_exists(int cpuid)
{
	uint32_t magic =
	    *(volatile uint32_t *)(mpconf + MPCONF_MAGIC(cpuid));
	return magic == MPCONF_MAGIC_VAL;
}

u_long
ip30_get_ncpusfound(void)
{
	int i;
	int ncpus = 0;

	for (i = 0; i < IP30_MAXCPUS; i++)
		if (ip30_cpu_exists(i))
			ncpus++;

	return ncpus;
}

#ifdef DDB
void
ip30_nmi_handler()
{
	extern int db_ktrap(int, struct trapframe *);
	extern void stacktrace(struct trapframe *);
	struct trapframe *fr0;
	int s;
#ifdef MULTIPROCESSOR
	struct trapframe *fr1;
	struct cpu_info *ci = curcpu();
#endif

	setsr(getsr() & ~SR_BOOT_EXC_VEC);

	s = splhigh();
#ifdef MULTIPROCESSOR
	ENABLEIPI();

	if (!CPU_IS_PRIMARY(ci)) {
		for (;;)
			continue;
		/* NOTREACHED */
	}
#endif

	printf("NMI\n");

	fr0 = (struct trapframe *)PHYS_TO_XKPHYS(IP30_MEMORY_BASE + 0x4000,
	    CCA_CACHED);
#ifdef MULTIPROCESSOR
	fr1 = (struct trapframe *)PHYS_TO_XKPHYS(IP30_MEMORY_BASE + 0x6000,
	    CCA_CACHED);
#endif

#ifdef MULTIPROCESSOR
	printf("cpu #0 traceback\n");
#endif
	stacktrace(fr0);
#ifdef MULTIPROCESSOR
	printf("cpu #1 traceback\n");
	stacktrace(fr1);
#endif

	db_ktrap(-1, fr0);

	splx(s);
	panic("NMI");
	/* NOTREACHED */
}
#endif

#ifdef MULTIPROCESSOR
void
hw_cpu_boot_secondary(struct cpu_info *ci)
{
	int cpuid =  ci->ci_cpuid;
	vaddr_t kstack;

#ifdef DEBUG
	uint64_t stackaddr =
		*(volatile uint64_t *)(mpconf + MPCONF_STACKADDR(cpuid));
	uint64_t lparam =
		*(volatile uint64_t *)(mpconf + MPCONF_LPARAM(cpuid));
	uint64_t launch =
		*(volatile uint64_t *)(mpconf + MPCONF_LAUNCH(cpuid));
	uint32_t magic =
		*(volatile uint32_t *)(mpconf + MPCONF_MAGIC(cpuid));
	uint32_t prid =
		*(volatile uint32_t *)(mpconf + MPCONF_PRID(cpuid));
	uint32_t physid =
		*(volatile uint32_t *)(mpconf + MPCONF_PHYSID(cpuid));
	uint32_t virtid =
		*(volatile uint32_t *)(mpconf + MPCONF_VIRTID(cpuid));
	uint32_t scachesz =
		*(volatile uint32_t *)(mpconf + MPCONF_SCACHESZ(cpuid));
	uint16_t fanloads =
		*(volatile uint16_t *)(mpconf + MPCONF_FANLOADS(cpuid));
	uint64_t rndvz =
		*(volatile uint64_t *)(mpconf + MPCONF_RNDVZ(cpuid));
	uint64_t rparam =
		*(volatile uint64_t *)(mpconf + MPCONF_RPARAM(cpuid));
	uint32_t idleflag =
		*(volatile uint32_t *)(mpconf + MPCONF_IDLEFLAG(cpuid));

	printf("ci:%p cpuid:%d magic:%x prid:%x physid:%x virtid:%x\n"
	    "scachesz:%u fanloads:%x launch:%llx rndvz:%llx\n"
	    "stackaddr:%llx lparam:%llx rparam:%llx idleflag:%x\n",
	    ci, cpuid, magic, prid, physid, virtid,
	    scachesz, fanloads, launch, rndvz,
	    stackaddr, lparam, rparam, idleflag);
#endif
	kstack = alloc_contiguous_pages(USPACE);
	if (kstack == 0)
		panic("unable to allocate idle stack");
	ci->ci_curprocpaddr = (void *)kstack;

	*(volatile uint64_t *)(mpconf + MPCONF_STACKADDR(cpuid)) =
	    (uint64_t)(kstack + USPACE);
	*(volatile uint64_t *)(mpconf + MPCONF_LPARAM(cpuid)) =
	    (uint64_t)ci;
	*(volatile uint64_t *)(mpconf + MPCONF_LAUNCH(cpuid)) =
	    (uint64_t)hw_cpu_spinup_trampoline;

	while (!cpuset_isset(&cpus_running, ci))
		;
}

void
hw_cpu_hatch(struct cpu_info *ci)
{
	int s;

	/*
	 * Set curcpu address on this processor.
	 */
	setcurcpu(ci);

	/*
	 * Make sure we can access the extended address space.
	 * Note that r10k and later do not allow XUSEG accesses
	 * from kernel mode unless SR_UX is set.
	 */
	setsr(getsr() | SR_KX | SR_UX);

	tlb_init(64);
	tlb_set_pid(0);

	/*
	 * Turn off bootstrap exception vectors.
	 */
	setsr(getsr() & ~SR_BOOT_EXC_VEC);

	/*
	 * Clear out the I and D caches.
	 */
	Mips10k_ConfigCache(ci);
	Mips_SyncCache(ci);

	(*md_startclock)(ci);

	ncpus++;
	cpuset_add(&cpus_running, ci);

	mips64_ipi_init();
	xheart_setintrmask(0);

	spl0();
	(void)updateimask(0);

	SCHED_LOCK(s);
	cpu_switchto(NULL, sched_chooseproc());
}

int
hw_ipi_intr_establish(int (*func)(void *), u_long cpuid)
{
	return xheart_intr_establish(func, (void *)cpuid, HEART_ISR_IPI(cpuid), 
	    IPL_IPI, NULL, &curcpu()->ci_ipiih);
};

void
hw_ipi_intr_set(u_long cpuid)
{
	xheart_intr_set(HEART_ISR_IPI(cpuid));
}

void
hw_ipi_intr_clear(u_long cpuid)
{
	xheart_intr_clear(HEART_ISR_IPI(cpuid));
}
#endif
@


1.67
log
@Increment `ncpus' to its final value already during autoconfiguration so
that percpu data areas get allocated properly on mips64 platforms. It is
too late to set the value during launch of secondary CPUs.

ok jasper@@ kettenis@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.66 2016/10/09 11:25:40 tom Exp $	*/
d576 1
@


1.66
log
@Apply consistency to forever loops with continue and NOTREACHED

Same thought from kettenis@@, ok krw@@ phessler@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.65 2016/03/06 19:42:27 mpi Exp $	*/
a575 1
	ncpus++;
@


1.65
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.64 2016/02/27 13:08:07 mpi Exp $	*/
d455 3
a457 1
		for (;;) ;
@


1.64
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.63 2014/12/06 23:20:17 krw Exp $	*/
d65 1
a65 1
uint32_t ip30_lights_frob(uint32_t, struct trap_frame *);
d389 1
a389 1
ip30_lights_frob(uint32_t hwpend, struct trap_frame *cf)
d439 3
a441 3
	extern int db_ktrap(int, struct trap_frame *);
	extern void stacktrace(struct trap_frame *);
	struct trap_frame *fr0;
d444 1
a444 1
	struct trap_frame *fr1;
d461 1
a461 1
	fr0 = (struct trap_frame *)PHYS_TO_XKPHYS(IP30_MEMORY_BASE + 0x4000,
d464 1
a464 1
	fr1 = (struct trap_frame *)PHYS_TO_XKPHYS(IP30_MEMORY_BASE + 0x6000,
@


1.63
log
@A few last 'easy' #include dedups.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.62 2014/07/12 22:37:03 uebayasi Exp $	*/
d439 1
a439 1
	extern int kdb_trap(int, struct trap_frame *);
d477 1
a477 1
	kdb_trap(-1, fr0);
@


1.62
log
@reboot(9), panic(9): Call panic(9) for unrecoverable MD H/W errors (NMIs)

Some architectures have ability to detect hardware sanity and notify system
(NMI, firmware callback, etc.).  Handle these hardware severe errors, same
as software errors, with panic(9).

According to miod@@, SGI IP27 NMI is triggered by pushing some "hidden" button,
which "usual" users/admins don't know.  Pushing such a button is "RB_USERREQ"
(human-triggered) in that the button is pushed by a human, but not "RB_USERREQ"
in that no user intervention in system (== no command input) is done.  miod@@
agreed that changing these from RB_USERREQ to !RB_USERREQ (== panic(9)) is
not a big problem.

OK miod@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a49 4

#ifdef MULTIPROCESSOR
#include <sgi/xbow/xheartreg.h>
#endif
@


1.61
log
@boot(9), reboot(9): Migrate MD callers of boot(9) to reboot(9)

I have found that some ports call boot(9) from machine-dependent code to
reboot system.  These should be changed to either:

- Sending signal to init(8) to trigger it to shutdown system cleanly, like
  acpi(4) does, in cases where found problems don't prevent system from working
  immediately, or

- Just doing panic(9) if the situation is severely broken.

For now, just rewrite boot() to reboot().  Actual fixes follow.

Discussed with & OK from kettenis@@
@
text
@a26 1
#include <sys/reboot.h>
d484 2
a485 2
	printf("Resetting system...\n");
	reboot(RB_USERREQ);
@


1.60
log
@Moar <uvm/uvm.h> -> <uvm/uvm_extern.h> love.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.59 2014/03/09 10:12:17 miod Exp $	*/
d486 1
a486 1
	boot(RB_USERREQ);
@


1.59
log
@Rework the per-cpu cache information. Use a common struct to store the line
size, the number of sets, and the total size (and the set size, for convenience)
per cache (I$, D$, L2, L3).
This allows cpu.c to print the number of ways (sets) of L2 and L3 caches from
the cache information, rather than hardcoding this from the processor type.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.58 2014/01/06 21:41:15 miod Exp $	*/
d39 1
a39 1
#include <uvm/uvm.h>
@


1.58
log
@Disable the code disabling memory beyond 1.5GB on Octane temporarily, but
hopefully for good; I believe the kernel panics with large memory fast MP
systems have been fixed in mutex.c 1.13
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.57 2012/10/03 11:18:23 miod Exp $	*/
a608 19
}

void
hw_cpu_init_secondary(struct cpu_info *ci)
{
	/*
	 * When attaching secondary processors, cache information is not
	 * available yet.  But since the MP-capable systems we run on
	 * currently all have R10k-style caches, we can quickly compute
	 * the needed values.
	 */
	ci->ci_cacheways = 2;
	ci->ci_l1instcachesize = 32 * 1024;
	ci->ci_l1instcacheline = 64;
	ci->ci_l1datacachesize = 32 * 1024;
	ci->ci_l1datacacheline = 32;
	ci->ci_l2size = ci->ci_hw.l2size;
	ci->ci_l2line = 64;			/* safe default */
	ci->ci_l3size = 0;
@


1.57
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.56 2012/09/29 19:11:08 miod Exp $	*/
d137 1
a137 1
#if 1
@


1.56
log
@Kill the mostly unused VMTLB_xxx and VMNUM_xxx defines. Move all tlb
knowledge to <machine/pte.h>. Add specific routines for tlb handling setup
(at cpu initialization time) and tlb ASID wrap.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.55 2012/07/16 16:06:40 miod Exp $	*/
d36 1
@


1.55
log
@Forgot these files during the recent clock churning.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.54 2012/06/28 22:11:33 miod Exp $	*/
d562 1
a562 5
	tlb_set_page_mask(TLB_PAGE_MASK);
	tlb_set_wired(0);
	tlb_flush(64);
	tlb_set_wired(UPAGES / 2);

@


1.54
log
@Correctly register contiguous memory regions which start within the ARCBios
reported memory but end beyond it, such as > 1GB DIMMs in bank 0.

Also, currently restrict physical memory usage to 1.5GB - there seems to be a
bogus 32 bit truncation happening in the IP30 specific codepath, which in turns
ends up causing the low memory alias region (and thus, the exception vectors
and the NMI handler) to be overwritten, which I can't find from code inspection
(does anyone has 2GB of Octane memory to spare?)

Both issues reported and fix/workaround tested by Florentijn van Kampen,
thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.53 2012/06/24 16:26:04 miod Exp $	*/
d580 1
a580 1
	cpu_startclock(ci);
@


1.53
log
@Add cache operation functions pointers to struct cpu_info; the various
cache lines and sizes are already there, after all.

The ConfigCache cache routine is responsible for filling these function
pointers; cache routine invocation macros are updated to use the cpu_info
fields, but may still be overriden in <machine/cpu.h> on platforms where
only one set of cache routines is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.52 2012/04/03 21:17:35 miod Exp $	*/
d134 11
a144 1
		if (start >= IP30_MEMORY_BASE + IP30_MEMORY_ARCBIOS_LIMIT) {
a145 1
		}
@


1.52
log
@Default DMA-reachable address constraints to the whole address space, and
narrow these in the various ipXX_machdep.c. On IP22-like systems, narrow
them to 28 bit physical addresses, but unpessimize this by extending this
to 32 bit after autoconf, if no 28-bit limited hpc(4) device has been found.
Since physical memory on these systems start at 128MB, this means that Indigo
systems with more than 128MB memory will behave correctly (and so will Indy
systems with E++ boards and more than 128MB memory).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.51 2012/03/28 20:44:23 miod Exp $	*/
d171 3
a173 2
	xbow_build_bus_space(&sys_config.console_io, 0, 15);
	sys_config.console_io.bus_base = ip30_widget_long(0, 15) +
d237 1
a237 1
		           *(volatile uint32_t *)(mpconf + MPCONF_PRID(cpuid));
d262 1
a262 1
	return PHYS_TO_XKPHYS((uint64_t)((widget) << 24) | (1ULL << 28), CCA_NC);
d295 1
a295 2
	if (widget != 0)
	{
d608 6
a613 6
       /*
        * When attaching secondary processors, cache information is not
        * available yet.  But since the MP-capable systems we run on
        * currently all have R10k-style caches, we can quickly compute
        * the needed values.
        */
d618 1
a618 1
	ci->ci_l1datacacheline = 64;
d620 1
@


1.51
log
@Work in progress support for the SGI Indigo, Indigo 2 and Indy systems
(IP20, IP22, IP24) in 64-bit mode, adapated from NetBSD. Currently limited
to headless operation, input and video drivers will get ported soon.

Should work on all R4000, R4440 and R5000 based systems. L2 cache on R5000SC
Indy not supported yet (coming soon), R4600 not supported yet either (coming
soon as well).

Tested to boot multiuser on: Indigo2 R4000SC, Indy R4000PC, Indy R4000SC,
Indy R5000SC, Indigo2 R4400SC. There are still glitches in the Ethernet driver
which are being looked at.

Expansion support is limited to the GIO E++ board; GIO boards with PCI-GIO
bridges not ported yet due to the lack of hardware, and this kind of driver
does not port blindly.

Most of this work comes from NetBSD, polishing and integration work, as well
as putting as many ``R4x00 in 64-bit mode'' erratas as necessary, by yours
truly.

More work is coming, as well as trying to get some easy way to boot install
kernels (as older PROM can only boot ECOFF binaries, which won't do for the
kernel).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.50 2012/03/25 13:52:52 miod Exp $	*/
d38 1
a38 1
#include <uvm/uvm_extern.h>
d139 7
@


1.50
log
@Move cache handling routines related definitions to a dedicated header file,
rather than abusing <machine/cpu.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.49 2012/03/16 15:25:05 deraadt Exp $	*/
d171 1
a171 3
	comconsrate = bios_getenvint("dbaud");
	if (comconsrate < 50 || comconsrate > 115200)
		comconsrate = 9600;
@


1.49
log
@missing bracket; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.48 2012/03/15 18:57:22 miod Exp $	*/
d31 1
@


1.48
log
@uncached_base was introduced early in IP27 support, since these designs use
subspaces in the CCA_NC uncached memory space. However, being coherent,
there was never a need for bus_dma to use uncached addresses.

This means that, on the only systems where uncached_base was not set to
PHYS_TO_XKPHYS(0, CCA_NC), it was never used.

Remove the variable, and replace PHYS_TO_UNCACHED() with
PHYS_TO_XKPHYS(, CCA_NC). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.47 2011/05/30 22:25:22 oga Exp $	*/
d255 1
a255 1
	return PHYS_TO_XKPHYS((uint64_t)(widget) << 24) | (1ULL << 28), CCA_NC);
@


1.47
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.46 2011/04/10 17:16:51 miod Exp $	*/
a99 6
	 * Although being r10k/r12k based, the uncached spaces are
	 * apparently not used in this design.
	 */
	uncached_base = PHYS_TO_XKPHYS(0, CCA_NC);

	/*
d255 1
a255 1
	return ((uint64_t)(widget) << 24) | (1ULL << 28) | uncached_base;
d261 1
a261 1
	return ((uint64_t)(widget) << 36) | uncached_base;
@


1.46
log
@A last few NULL -> 0 corrections.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.45 2011/04/03 22:34:54 miod Exp $	*/
d140 1
a140 2
			memrange_register(atop(start), atop(end),
			    0, VM_FREELIST_DEFAULT);
@


1.45
log
@Enable the use of all the memory found on IP27 and IP30 kernels. Committed
from an IP35 system with half its memory outside the dma_constraint range.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.44 2010/09/09 10:59:02 syuu Exp $	*/
d522 1
a522 1
	if (kstack == NULL)
@


1.44
log
@Move cache settings into hw_cpu_init_secondary() ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.43 2010/08/07 03:50:01 krw Exp $	*/
a139 13
			/*
			 * XXX Temporary until there is a way to cope with
			 * XXX xbridge ATE shortage.
			 */
			if (end > (2UL << 30)) {
#if 0
				physmem += atop(end - (2UL << 30));
#endif
				end = 2UL << 30;
			}
			if (end <= start)
				continue;

@


1.43
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.42 2010/04/28 16:20:28 syuu Exp $	*/
d619 17
@


1.42
log
@Storeing current cpu_info address into LLAddr register, for curcpu().
Instead of previous implementation, we won't use physical cpuid to fetch curcpu().
This requires to implement IP27/35 SMP.
Implemented getcurcpu() and setcurcpu() for it, smp_malloc() renamed alloc_contiguous_pages() because now it only allocate by page.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.41 2010/04/21 14:57:11 deraadt Exp $	*/
d536 1
a536 1
		panic("unable to allocate idle stack\n");
@


1.41
log
@two more proc.h needed
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.40 2010/04/06 19:15:29 miod Exp $	*/
d534 1
a534 1
	kstack = smp_malloc(USPACE);
a536 1
	bzero((char *)kstack, USPACE);
d554 5
@


1.40
log
@Split the device_register() code responsible for boot path recognition into
two distinct sets of routines: one for the ARCBios-compatible path used on
non-KL systems (such as O2 and Octane), and one for the KL system using
dksc() paths.

When trying to match a dksc() path, walk the KL configuration of the whole
system until the dksc controller is found; since the controller numbers are
not assigned sequentially and contiguously, the old code would not work on
complex systems (such as when booting from controller #6 when #3 to #5 are
unaffected).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.39 2010/04/06 19:02:47 miod Exp $	*/
d25 1
@


1.39
log
@Provide WIDGET_ID_FOO() macros to extract parts of the ID register value,
instead of duplicating tedious mask and shift constructs MAXINT times.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.38 2010/03/13 21:55:30 miod Exp $	*/
d214 2
@


1.38
log
@Octane PROM picks highest graphics widget as console, not lowest;
"go ahead" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.37 2010/03/07 13:44:26 miod Exp $	*/
d372 2
a373 4
		vendor = (id & WIDGET_ID_VENDOR_MASK) >>
		    WIDGET_ID_VENDOR_SHIFT;
		product = (id & WIDGET_ID_PRODUCT_MASK) >>
		    WIDGET_ID_PRODUCT_SHIFT;
@


1.37
log
@Allow iockbc(4) and odysseey(4) to act as console devices and attach early;
this gives us working glass console on Fuel, as well as on Octane systems
with Odyssey graphics.
Joint work with jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.36 2010/02/28 18:01:39 miod Exp $	*/
d368 1
a368 1
	for (widid = WIDGET_MIN; widid <= WIDGET_MAX; widid++) {
@


1.36
log
@Pass L2 cache size in struct cpu_hwinfo, so that bootstrap of secondary
processors can display correct data. Now cpu1 on octane is correctly
reported in dmesg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.35 2010/01/19 19:54:24 miod Exp $	*/
d41 1
d173 1
a173 1
	 * On Octane, the BRIDGE is always widet 15, and IOC3 is always
d184 1
a184 1
	    BRIDGE_PCI0_MEM_SPACE_BASE;
d186 1
a186 1
	comconsaddr = 0x500000 + IOC3_UARTA_BASE;
d206 1
a206 1
	ip30_iocbase = sys_config.console_io.bus_base + 0x500000;
d319 70
@


1.35
log
@Compute the right value for hw.ncpusfound sysctl on IP30 regardless of the
value of MAXCPUS.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.34 2010/01/14 07:22:31 miod Exp $	*/
d248 2
@


1.34
log
@Let the nmi handler code compile on non-MULTIPROCESSOR kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.33 2010/01/13 23:24:27 miod Exp $	*/
d235 1
a235 1
	for (cpuid = 1; cpuid < MAXCPUS; cpuid++)
d361 5
a365 3
	for (i = 1; i < MAXCPUS; i++)
		if (!ip30_cpu_exists(i))
			continue;
d367 1
a367 1
	return i;
@


1.33
log
@Freeze the secondary CPU later in the nmi handling, and put it in a better
state from a ddb point of view.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.31 2010/01/09 23:34:29 miod Exp $	*/
d374 4
d379 1
a379 2
	struct trap_frame *fr0, *fr1;
	int s;
d384 1
d390 1
d396 1
d399 1
d401 1
d403 1
d405 1
d408 1
d412 1
@


1.32
log
@Crude handler for the Octane NMI button, for kernels compiled with
option DDB.
@
text
@d374 1
d376 1
d379 8
@


1.31
log
@Move cache information from global variables to per-cpu_info fields; this
allows processors with different cache sizes to be used.

Cache management routines now take a struct cpu_info * as first parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.30 2010/01/09 20:33:16 miod Exp $	*/
d26 1
d73 5
d93 3
d192 9
d352 3
a354 3
       uint32_t magic =
           *(volatile uint32_t *)(mpconf + MPCONF_MAGIC(cpuid));
       return magic == MPCONF_MAGIC_VAL;
d363 1
a363 1
			break;
d368 28
d400 2
a401 2
       int cpuid =  ci->ci_cpuid;
       vaddr_t kstack;
d404 6
a409 6
        uint64_t stackaddr =
               *(volatile uint64_t *)(mpconf + MPCONF_STACKADDR(cpuid));
        uint64_t lparam =
               *(volatile uint64_t *)(mpconf + MPCONF_LPARAM(cpuid));
        uint64_t launch =
               *(volatile uint64_t *)(mpconf + MPCONF_LAUNCH(cpuid));
d411 37
a447 37
               *(volatile uint32_t *)(mpconf + MPCONF_MAGIC(cpuid));
        uint32_t prid =
               *(volatile uint32_t *)(mpconf + MPCONF_PRID(cpuid));
        uint32_t physid =
               *(volatile uint32_t *)(mpconf + MPCONF_PHYSID(cpuid));
        uint32_t virtid =
               *(volatile uint32_t *)(mpconf + MPCONF_VIRTID(cpuid));
        uint32_t scachesz =
               *(volatile uint32_t *)(mpconf + MPCONF_SCACHESZ(cpuid));
        uint16_t fanloads =
               *(volatile uint16_t *)(mpconf + MPCONF_FANLOADS(cpuid));
        uint64_t rndvz =
               *(volatile uint64_t *)(mpconf + MPCONF_RNDVZ(cpuid));
        uint64_t rparam =
               *(volatile uint64_t *)(mpconf + MPCONF_RPARAM(cpuid));
        uint32_t idleflag =
               *(volatile uint32_t *)(mpconf + MPCONF_IDLEFLAG(cpuid));

       printf("ci:%p cpuid:%d magic:%x prid:%x physid:%x virtid:%x\n"
           "scachesz:%u fanloads:%x launch:%llx rndvz:%llx\n"
           "stackaddr:%llx lparam:%llx rparam:%llx idleflag:%x\n",
           ci, cpuid, magic, prid, physid, virtid,
           scachesz, fanloads, launch, rndvz,
           stackaddr, lparam, rparam, idleflag);
#endif
       kstack = smp_malloc(USPACE);
       if (kstack == NULL)
	       panic("unable to allocate idle stack\n");
       bzero((char *)kstack, USPACE);
       ci->ci_curprocpaddr = (void *)kstack;

       *(volatile uint64_t *)(mpconf + MPCONF_STACKADDR(cpuid)) =
           (uint64_t)(kstack + USPACE);
       *(volatile uint64_t *)(mpconf + MPCONF_LPARAM(cpuid)) =
           (uint64_t)ci;
       *(volatile uint64_t *)(mpconf + MPCONF_LAUNCH(cpuid)) =
           (uint64_t)hw_cpu_spinup_trampoline;
d449 2
a450 2
       while(!cpuset_isset(&cpus_running, ci))
	       ;
d456 1
a456 1
       int s;
d458 6
a463 8
       /*
        * Make sure we can access the extended address space.
        * Note that r10k and later do not allow XUSEG accesses
        * from kernel mode unless SR_UX is set.
        */
       setsr(getsr() | SR_KX | SR_UX);

	Mips10k_ConfigCache(ci);
d470 1
a470 1
       tlb_set_pid(0);
d472 4
a475 4
       /*
        * Turn off bootstrap exception vectors.
        */
       setsr(getsr() & ~SR_BOOT_EXC_VEC);
d477 5
a481 4
       /*
        * Clear out the I and D caches.
        */
       Mips_SyncCache(ci);
d483 1
a483 1
       cpu_startclock(ci);
d485 2
a486 2
       ncpus++;
       cpuset_add(&cpus_running, ci);
d488 2
a489 2
       mips64_ipi_init();
       xheart_setintrmask(0);
d491 2
a492 2
       spl0();
       (void)updateimask(0);
d494 2
a495 2
       SCHED_LOCK(s);
       cpu_switchto(NULL, sched_chooseproc());
d498 2
a499 1
int hw_ipi_intr_establish(int (*func)(void *), u_long cpuid)
d505 2
a506 1
void hw_ipi_intr_set(u_long cpuid)
d511 2
a512 1
void hw_ipi_intr_clear(u_long cpuid)
@


1.30
log
@Define struct cpu_hwinfo, to hold hardware specific information about each
processor (instead of sys_config.cpu[]), and pass it in the attach_args
when attaching cpu devices.

This allows per-cpu information to be gathered late in the bootstrap process,
and not be limited by an arbitrary MAX_CPUS limit; this will suit IP27 and
IP35 systems better.

While there, use this information to make sure delay() uses the speed
information from the cpu it is invoked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.29 2010/01/05 06:44:58 syuu Exp $	*/
d419 1
a419 1
       Mips10k_ConfigCache();
d436 1
a436 1
       Mips_SyncCache();
@


1.29
log
@Dynamic allocation for ASID and ASID generation number on struct pmap. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.28 2009/12/28 06:55:27 syuu Exp $	*/
d152 2
d157 3
a159 1
	sys_config.cpu[0].clock = cpuspeed * 1000000;
d204 5
a208 1
	struct mainbus_attach_args maa;
d210 5
a214 4
	bzero(&maa, sizeof maa);
	maa.maa_nasid = masternasid;
	maa.maa_name = "cpu";
	config_found(parent, &maa, mbprint);
d217 16
a232 4
	int cpuid;
	for(cpuid = 1; cpuid < MAXCPUS; cpuid++)
		if (ip30_cpu_exists(cpuid))
			config_found(parent, &maa, mbprint);
d234 7
a240 6
	maa.maa_name = "clock";
	config_found(parent, &maa, mbprint);
	maa.maa_name = "xbow";
	config_found(parent, &maa, mbprint);
	maa.maa_name = "power";
	config_found(parent, &maa, mbprint);
a409 1
       int cpuid = ci->ci_cpuid;
a418 12
       /*
        * Determine system type and set up configuration record data.
        */
       sys_config.cpu[cpuid].clock = sys_config.cpu[0].clock;
       sys_config.cpu[cpuid].type = (cp0_get_prid() >> 8) & 0xff;
       sys_config.cpu[cpuid].vers_maj = (cp0_get_prid() >> 4) & 0x0f;
       sys_config.cpu[cpuid].vers_min = cp0_get_prid() & 0x0f;
       sys_config.cpu[cpuid].fptype = (cp1_get_prid() >> 8) & 0xff;
       sys_config.cpu[cpuid].fpvers_maj = (cp1_get_prid() >> 4) & 0x0f;
       sys_config.cpu[cpuid].fpvers_min = cp1_get_prid() & 0x0f;
       sys_config.cpu[cpuid].tlbsize = 64;

a420 1
       sys_config.cpu[cpuid].tlbwired = UPAGES / 2;
d422 3
a424 3
       tlb_set_wired(0);
       tlb_flush(sys_config.cpu[cpuid].tlbsize);
       tlb_set_wired(sys_config.cpu[cpuid].tlbwired);
d438 2
a441 2

       cpu_startclock(ci);
@


1.28
log
@MP-safe pmap implemented, enable IPI in interrupt handler to avoid deadlock.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.27 2009/12/07 19:05:59 miod Exp $	*/
d70 1
d189 2
d207 1
d210 1
a210 3
		if (ip30_cpu_exists(cpuid) == 0) {
			ncpusfound++;
#ifdef MULTIPROCESSOR
a212 1
		}
d314 12
a325 4
       if (magic == MPCONF_MAGIC_VAL)
               return 0;
       else
               return 1;
@


1.27
log
@Support for 16KB page size kernels; page size is now set in <machine/param.h>
rather than <mips64/param.h>.

For now, kernels are kept at 4KB to give people some time to build 16KB
compatible binaries; this will change before the end of this release cycle.

Use of 16KB page size kernels yields a 18% speedup (which, offset by the
1.6% slowdown caused by the pmap changes, yields a 16.6% overall speedup).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.26 2009/12/02 01:42:14 syuu Exp $	*/
d380 1
d409 1
a409 1
       tlb_set_pid(1);
a431 1
#ifdef notyet
a433 4
#else
       for(;;)
	       ;
#endif
d439 1
a439 1
	    IPL_IPI, NULL, curcpu()->ci_ipiih);
@


1.26
log
@use kstack for curprocpaddr instead of proc0paddr.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.25 2009/11/27 10:22:09 syuu Exp $	*/
d403 1
@


1.25
log
@ci->ci_curprocpaddr must initialized before cpu1 get into cpu_switchto().
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.24 2009/11/25 17:39:51 syuu Exp $	*/
d363 1
a400 2

       ci->ci_curprocpaddr = proc0paddr;
@


1.24
log
@IP30 IPI implementation.
Also few xheart modification for SMP.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.23 2009/11/24 22:46:59 syuu Exp $	*/
d61 2
d400 2
@


1.23
log
@smp_malloc() implemented.
This function allocates memory using malloc or uvm_pglistalloc, then returns XKPHYS address of allocated memory.
It's for avoid using virtual address on secondary cpus in early stage, and also in TLB handler.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.22 2009/11/22 22:44:58 syuu Exp $	*/
d47 4
d55 8
d421 3
d426 1
d435 17
@


1.22
log
@Allocates bootstrap stack by uvm_pglistalloc instead of uvm_km_alloc.
ok miod@@, jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.21 2009/11/22 19:41:41 syuu Exp $	*/
d191 1
a191 1
	for(cpuid = 1; cpuid < MAX_CPUS; cpuid++)
a309 3
       struct pglist mlist;
       struct vm_page *m;
       int error;
d345 2
a346 5

       TAILQ_INIT(&mlist);
       error = uvm_pglistalloc(USPACE, 0, -1L, 0, 0,
           &mlist, 1, UVM_PLA_WAITOK);
       if (error)
a347 3

       m = TAILQ_FIRST(&mlist);
       kstack = (vaddr_t)PHYS_TO_XKPHYS(VM_PAGE_TO_PHYS(m), CCA_CACHED);
@


1.21
log
@ncpus, ncpufound values are corrected.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.20 2009/11/22 18:33:48 syuu Exp $	*/
d310 4
d348 10
a357 6
       vaddr_t kstack;
       kstack = uvm_km_alloc(kernel_map, USPACE);
       if (kstack == 0) {
               panic("prom_boot_secondary: unable to allocate idle stack");
               return;
       }
@


1.20
log
@SMP support on MIPS clock.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.19 2009/11/21 20:55:44 miod Exp $	*/
a58 1
#ifdef MULTIPROCESSOR
a62 1
#endif
d189 1
a189 1
#ifdef MULTIPROCESSOR
d192 3
a194 1
		if (ip30_cpu_exists(cpuid) == 0)
d197 1
a293 1
#ifdef MULTIPROCESSOR
d305 1
d405 1
@


1.19
log
@Yet another stupid typo caught by martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.18 2009/11/21 19:39:19 miod Exp $	*/
d406 11
a416 2
       for (;;)
               ;
@


1.18
log
@Fix registration of memory after 1GB on Octane. Found the hard way by martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.17 2009/11/19 06:06:51 miod Exp $	*/
d129 1
a129 1
			memrange_register(atop(start), atop(count),
@


1.17
log
@Factor triplicated code responsible to add memory information into a
single place.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.16 2009/11/18 19:05:51 miod Exp $	*/
d129 2
a130 1
			memrange_register(start, count, 0, VM_FREELIST_DEFAULT);
@


1.16
log
@Move widget register information apart from xbow software interface, and
update #include needs. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.15 2009/10/31 00:20:46 miod Exp $	*/
a68 1
#if 0
d72 1
a72 2
	uint64_t start, count;
#endif
a80 1
#if 0
d82 2
a83 3
	 * Scan for memory. ARCBios reports at least up to 2GB; if
	 * memory above 2GB isn't reported, we'll need to re-enable this
	 * code and add the unseen areas.
d87 1
a87 1
		memcfg = *(uint32_t *)
d89 1
d91 1
d106 2
d109 22
a130 1
		    ptoa(start), ptoa(start + count));
d132 1
a132 1
#endif
@


1.15
log
@Blinkenlichten on Octane.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.14 2009/10/30 08:13:57 syuu Exp $	*/
d38 1
d40 1
a40 1
#include <sgi/xbow/xbridgereg.h>
@


1.14
log
@Support IP30 secondary cpu bootup. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.13 2009/10/22 22:08:54 miod Exp $	*/
d50 1
d56 2
a73 1
	paddr_t iocbase;
d147 3
a149 2
	iocbase = ip30_widget_short(0, 15) + 0x500000;
	if (*(volatile uint32_t *)(iocbase + IOC3_GPPR(IP30_GPIO_CLASSIC)) != 0)
d239 29
@


1.13
log
@Completely overhaul interrupt handling on sgi. Cpu state now only stores a
logical IPL level, and per-platform (IP27/IP30/IP32) code will from the
necessary hardware mask registers.

This allows the use of more than one interrupt mask register. Also, the
generic (platform independent) interrupt code shrinks a lot, and the actual
interrupt handler chains and masking information is now per-platform private
data.

Interrupt dispatching is generated from a template; more routines will be
added to the template to reduce platform-specific changes and share as much
code as possible.

Tested on IP27, IP30, IP32 and IP35.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.12 2009/10/22 20:05:28 miod Exp $	*/
d48 2
d55 7
d153 27
d237 118
@


1.12
log
@Replace intrmask_t with uint32_t. This types only describes interrupt masks
in the coprocessor 0 status register (coupled with ICR on rm7k/rm9k), and
may be completely alien to real hardware interrupt masks, so don't make
things unnecessary confusing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.11 2009/10/16 00:15:49 miod Exp $	*/
a199 11
}

void
hw_setintrmask(uint32_t m)
{
	extern uint64_t heart_intem;

	paddr_t heart;
	heart = PHYS_TO_XKPHYS(HEART_PIU_BASE, CCA_NC);
	*(volatile uint64_t *)(heart + HEART_IMR(0)) =
	    heart_intem & ~((uint64_t)m);
@


1.11
log
@Get serial console speed from prom, and use it instead of hardcoding 9600 bps,
on all systems but O2 (to catch up soon). Also use the IOC4 MCR register to
figure out the IOC4 clock, instead of checking the widget control register,
to be consistent with iof(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.10 2009/10/14 20:21:16 miod Exp $	*/
d203 1
a203 1
hw_setintrmask(intrmask_t m)
@


1.10
log
@On IP30 and IP35 systems, try harder to figure out exactly what model we are
running on, and report this both as the hw.product sysctl and in dmesg.
Fuel and Origin 350 are no longer reported as being Origin 300 systems!
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.9 2009/08/18 19:31:56 miod Exp $	*/
d63 1
d105 5
d128 3
d136 1
a136 1
	iocbase = ip30_widget_long(0, 15) + 0x500000;
@


1.9
log
@Blind support for SGI PIC PCI-X controller found on Origin 350 and Tezro
systems. PIC was supposed to be mostly XBridge compatible, but a silicon
bug prevents it from working correctly if 32 bit register writes are used,
so the xbridge(4) code now needs to issue 64 bit writes.

In order to make this a bit more transparent, rebase all widget registers to
a 8 byte boundary, and provide a few inline accessors which will do the right
thing if you want 32 bit writes.

Tested to not cause regressions on Octane, Origin 200 and Fuel; covering
Bridge < 4, Bridge >= 4 and XBridge flavours.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.8 2009/07/06 22:46:43 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 2008 Miodrag Vallat.
d46 2
d62 1
d106 2
a107 6
	 * This assumes BRIDGE is on widget 15 and IOC3 is mapped in
	 * memory space at address 0x500000.
	 *
	 * XXX And that 0x500000 should be computed from the first BAR
	 * XXX of the IOC3 in pci configuration space. Joy. I'll get there
	 * XXX eventually.
d114 1
d122 10
@


1.8
log
@Almost rewrite xbridge PCI resource allocation:
- introduce an interface for widget drivers to ask the xbow to map arbitrary
  views of their address space, in addition to the low 16MB. This operation
  may fail or map a subset range of what the caller asked for, depending on
  the platform we're running on.
- use this in xbridge to set up views on the direct memory and i/o spaces,
  to map devices resources when they don't fit in one of the devio small
  ranges (limited to 2MB anyway). These views are only allocated when
  devio can't do the job, so as not to consume too many resources on
  Origin family systems where such views are scarce resources (and
  shared accross the whole crossbow).

This makes pci devices with large resource needs configure correctly.

While there, fix programming of 64 bit memory BAR; this makes bge(4)
work.

Tested on Octane (with Bridge revision < 4 and >= 4), Origin 200 (Bridge >= 4)
and Fuel (XBridge).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.7 2009/07/01 21:56:38 miod Exp $	*/
d117 1
a117 1
	    BRIDGE_PCI_MEM_SPACE_BASE;
d171 1
a171 1
		if (!ISSET(*(uint32_t *)(linkpa + WIDGET_LINK_STATUS),
d178 1
a178 1
		*wid = *(uint32_t *)(wpa + WIDGET_ID);
@


1.7
log
@The widget mapping code has been written back when I was only working on
Octane support. The Octane being a single-node system, address space is
ludicrous enough to allow the whole address space of every widget to be
directly accessible in whole, using the address bits reserved to nasid.

However, on IP27 and IP35, things do not work this way - while we still have
the low 16MB address space of each widget available (the so-called
``short window''), access to other parts of the wiget address space is done
through translation slots (IOTTE) at the Hub I/O space level, on a per-node
basis.

Given the imminent release lock, give up completely on ``large'' mappings
of widgets, and restrict ourselves to short window operation, all the time
(thus reinforcing the use of devio registers to map pci resources on xbridge).
A proper interface to request mappings of specific widget areas, either
directly on Octane, or through IOTTE if available on Origin, will appear
post-release.

No functional change (except from silently repairing Octane support which the
previous xbridge commit silently broke).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.6 2009/04/18 14:48:08 miod Exp $	*/
d48 1
d98 1
d116 2
a117 1
	sys_config.console_io.bus_base = ip30_widget_short(0, 15);
d139 15
@


1.6
log
@Fewer hardcoded values and simpler code in ip30 interrupt handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.5 2009/04/15 18:42:23 miod Exp $	*/
d96 1
a96 2
	xbow_widget_short = ip30_widget_short;
	xbow_widget_long = ip30_widget_long;
d113 2
a114 2
	xbow_build_bus_space(&sys_config.console_io, 0, 15, 1);
	sys_config.console_io.bus_base += BRIDGE_PCI_MEM_SPACE_BASE;
@


1.5
log
@Oops, referenced an include file which I don't plan to commit yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.4 2009/04/13 21:17:54 miod Exp $	*/
d169 1
a169 1
	extern intrmask_t heart_intem;
d173 2
a174 1
	*(volatile uint64_t *)(heart + HEART_IMR(0)) = heart_intem & ~m;
@


1.4
log
@The start of Origin 200 support. Based on some code contributed by pefo@@
some years ago for KL enumeration, building on the existing XBow support
to limit ourselves to a single node for now.

This is a work-in-progress; it currently lacks complete interrupt code,
as well as PCI resource management. And there are likely bugs creeping
inside.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.3 2009/04/12 17:53:02 miod Exp $	*/
a37 1
#include <sgi/xbow/widget.h>
@


1.3
log
@Get com console global variables from <dev/ic/comvar.h> instead of declaring
them manually.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip30_machdep.c,v 1.2 2008/04/24 12:52:26 jsing Exp $	*/
d38 1
d151 1
a151 1
		if (widget < 8 || widget > 15)
d165 10
@


1.2
log
@Unbreak IP30 serial console.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d25 2
d44 2
a48 4

extern bus_addr_t comconsaddr;
extern bus_space_tag_t comconsiot;
extern int comconsfreq;
@


1.1
log
@Platform-specific bits for IP30 (Octane). Based on knowledge extracted from
Linux source code.
@
text
@d46 4
d116 4
a119 3
	sys_config.cons_ioaddr = 0x500000 + IOC3_UARTA_BASE;
	sys_config.cons_baudclk = 22000000 / 3;
	sys_config.cons_iot = &sys_config.console_io;
@

