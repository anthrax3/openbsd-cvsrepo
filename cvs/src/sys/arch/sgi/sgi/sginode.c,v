head	1.32;
access;
symbols
	OPENBSD_6_0:1.32.0.4
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.31.0.6
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.29.0.16
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.14
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.10
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.8
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.6
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.4
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.11.0.2
	OPENBSD_4_6_BASE:1.11;
locks; strict;
comment	@ * @;


1.32
date	2015.12.03.15.38.06;	author visa;	state Exp;
branches;
next	1.31;
commitid	jmiNsLfhVIieiJDL;

1.31
date	2015.02.06.22.12.19;	author miod;	state Exp;
branches;
next	1.30;
commitid	3jdaDtnqG2S5kfCc;

1.30
date	2014.11.24.16.40.29;	author miod;	state Exp;
branches;
next	1.29;
commitid	r5wpGXh4hWvNa7s2;

1.29
date	2011.05.30.22.25.22;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2011.04.23.21.23.52;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2011.04.23.19.52.36;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2011.04.23.19.35.57;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2011.04.21.18.16.57;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2011.04.21.18.09.01;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.17.17.44.24;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2011.04.03.22.34.54;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.17.00.04.30;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.06.19.09.50;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2010.03.21.13.52.05;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2010.03.07.13.42.17;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2010.01.09.20.33.16;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.19.06.06.51;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.07.14.49.01;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.31.12.26.36;	author sobrado;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.16.00.15.49;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.06.22.46.43;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.21.18.04.41;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.17.18.19.03;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.13.16.28.11;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.27.19.00.19;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.14.21.08.49;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.08.18.42.07;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.06.20.08.00;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.02.21.26.05;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2009.04.15.18.47.15;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.13.21.17.54;	author miod;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Let the IP27 kernel build with DEBUG.
@
text
@/*	$OpenBSD: sginode.c,v 1.31 2015/02/06 22:12:19 miod Exp $	*/
/*
 * Copyright (c) 2008, 2009, 2011 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 2004 Opsycon AB.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/memconf.h>
#include <machine/param.h>
#include <machine/autoconf.h>
#include <mips64/arcbios.h>
#include <mips64/archtype.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <machine/mnode.h>
#include <sgi/xbow/hub.h>
#include <sgi/xbow/widget.h>
#include <sgi/xbow/xbow.h>
#include <sgi/xbow/xbowdevs.h>

void	kl_add_memory_ip27(int16_t, int16_t *, unsigned int);
void	kl_add_memory_ip35(int16_t, int16_t *, unsigned int);

int	kl_first_pass_board(lboard_t *, void *);
int	kl_first_pass_comp(klinfo_t *, void *);

#ifdef DEBUG
#define	DB_PRF(x)	bios_printf x
#else
#define	DB_PRF(x)
#endif

/* widget number of the XBow `hub', for each node */
int	kl_hub_widget[GDA_MAXNODES];

int	kl_n_mode = 0;
u_int	kl_n_shift = 32;
klinfo_t *kl_glass_console = NULL;

void
kl_init(int ip35)
{
	kl_config_hdr_t *cfghdr;
	uint64_t val;
	uint64_t nibase = ip35 ? HUBNIBASE_IP35 : HUBNIBASE_IP27;
	size_t gsz;

	/* will be recomputed when processing memory information */
	physmem = 0;

	cfghdr = IP27_KLCONFIG_HDR(0);
	DB_PRF(("config @@%p\n", cfghdr));
	DB_PRF(("magic %#llx version %x\n", cfghdr->magic, cfghdr->version));
	DB_PRF(("console %#lx baud %d\n", cfghdr->cons_info.uart_base,
	    cfghdr->cons_info.baud));

	val = IP27_LHUB_L(nibase | HUBNI_STATUS);
	kl_n_mode = (val & NI_MORENODES) != 0;
	kl_n_shift = (ip35 ? 33 : 32) - kl_n_mode;
        bios_printf("Machine is in %c mode.\n", kl_n_mode + 'M');

	val = IP27_LHUB_L(HUBPI_REGION_PRESENT);
        DB_PRF(("Region present %#llx.\n", val));
	val = IP27_LHUB_L(HUBPI_CALIAS_SIZE);
        DB_PRF(("Calias size %#llx.\n", val));

	/*
	 * Get a grip on the global data area, and figure out how many
	 * theoretical nodes are available.
	 */

	gda = IP27_GDA(0);
	gsz = IP27_GDA_SIZE(0);
	if (gda->magic != GDA_MAGIC || gda->ver < 2) {
		masternasid = 0;
		maxnodes = 0;
	} else {
		masternasid = gda->masternasid;
		maxnodes = (gsz - offsetof(gda_t, nasid)) / sizeof(int16_t);
		if (maxnodes > GDA_MAXNODES)
			maxnodes = GDA_MAXNODES;
		/* in M mode, there can't be more than 64 nodes anyway */
		if (kl_n_mode == 0 && maxnodes > 64)
			maxnodes = 64;
	}

	/*
	 * Scan all nodes configurations to find out CPU and memory
	 * information, starting with the master node.
	 */

	kl_scan_all_nodes(KLBRD_ANY, kl_first_pass_board, &ip35);
}

/*
 * Callback routine for the initial enumeration (boards).
 */
int
kl_first_pass_board(lboard_t *boardinfo, void *arg)
{
	DB_PRF(("%cboard type %x slot %x nasid %x nic %#llx ncomp %d\n",
	    boardinfo->struct_type & LBOARD ? 'l' : 'r',
	    boardinfo->brd_type, boardinfo->brd_slot,
	    boardinfo->brd_nasid, boardinfo->brd_nic,
	    boardinfo->brd_numcompts));

	/*
	 * Assume the worst case of a restricted XBow, as found on
	 * Origin 200 systems. This value will be overridden should a
	 * full-blown XBow be found during component enumeration.
	 *
	 * On Origin 200, widget 0 reports itself as a Bridge, and
	 * interrupt widget is hardwired to #a (which is another facet
	 * of the bridge).
	 */
	if (kl_hub_widget[boardinfo->brd_nasid] == 0)
		kl_hub_widget[boardinfo->brd_nasid] = 0x0a;

	kl_scan_board(boardinfo, KLSTRUCT_ANY, kl_first_pass_comp, arg);

	return 0;
}

#ifdef DEBUG
static const char *klstruct_names[] = {
	"unknown component",
	"cpu",
	"hub",
	"memory",
	"xbow",
	"bridge",
	"ioc3",
	"pci",
	"vme",
	"router",
	"graphics",
	"scsi",
	"fddi",
	"mio",
	"disk",
	"tape",
	"cdrom",
	"hub uart",
	"ioc3 Ethernet",
	"ioc3 uart",
	"component type 20",
	"ioc3 keyboard",
	"rad",
	"hub tty",
	"ioc3 tty",
	"fc",
	"module serialnumber",
	"ioc3 mouse",
	"tpu",
	"gsn main board",
	"gsn aux board",
	"xthd",
	"QLogic fc",
	"firewire",
	"usb",
	"usb keyboard",
	"usb mouse",
	"dual scsi",
	"PE brick",
	"gigabit Ethernet",
	"ide",
	"ioc4",
	"ioc4 uart",
	"ioc4 tty",
	"ioc4 keyboard",
	"ioc4 mouse",
	"ioc4 ATA",
	"pci graphics"
};
#endif

/*
 * Callback routine for the initial enumeration (components).
 * We are interested in cpu and memory information only, but display a few
 * other things if option DEBUG.
 */
int
kl_first_pass_comp(klinfo_t *comp, void *arg)
{
	int ip35 = *(int *)arg;
	klcpu_t *cpucomp;
	klmembnk_m_t *memcomp_m;
	klxbow_t *xbowcomp;
	arc_config64_t *arc;
#ifdef DEBUG
	klmembnk_n_t *memcomp_n;
	klhub_t *hubcomp;
	klscsi_t *scsicomp;
	klscctl_t *scsi2comp;
	int i;
#endif

	arc = (arc_config64_t *)comp->arcs_compt;

#ifdef DEBUG
	if (comp->struct_type < nitems(klstruct_names))
		DB_PRF(("\t%s", klstruct_names[comp->struct_type]));
	else
		DB_PRF(("\tcomponent type %d", comp->struct_type));
	DB_PRF((", widget %x physid 0x%02x virtid %d",
	    comp->widid, comp->physid, comp->virtid));
	if (ip35) {
		DB_PRF((" prt %d bus %d", comp->port, comp->pci_bus_num));
		if (comp->pci_multifunc)
			DB_PRF((" pcifn %d", comp->pci_func_num));
	}
	DB_PRF(("\n"));
#endif

	switch (comp->struct_type) {
	case KLSTRUCT_CPU:
		cpucomp = (klcpu_t *)comp;
		DB_PRF(("\t  type %x/%x %dMHz cache %dMB speed %dMHz\n",
		    cpucomp->cpu_prid, cpucomp->cpu_fpirr,
		    cpucomp->cpu_speed, cpucomp->cpu_scachesz,
		    cpucomp->cpu_scachespeed));
		/*
		 * XXX this assumes the first cpu encountered is the boot
		 * XXX cpu.
		 */
		if (bootcpu_hwinfo.clock == 0) {
			bootcpu_hwinfo.c0prid = cpucomp->cpu_prid;
			bootcpu_hwinfo.c1prid = cpucomp->cpu_prid; /* XXX */
			bootcpu_hwinfo.clock = cpucomp->cpu_speed * 1000000;
			bootcpu_hwinfo.tlbsize = 64;
			bootcpu_hwinfo.type = (cpucomp->cpu_prid >> 8) & 0xff;
		} else
			ncpusfound++;
		break;

	case KLSTRUCT_MEMBNK:
		memcomp_m = (klmembnk_m_t *)comp;
#ifdef DEBUG
		memcomp_n = (klmembnk_n_t *)comp;
		DB_PRF(("\t  %dMB, select %x flags %x\n",
		    memcomp_m->membnk_memsz, memcomp_m->membnk_dimm_select,
		    kl_n_mode ?
		      memcomp_n->membnk_attr : memcomp_m->membnk_attr));

		if (kl_n_mode) {
			for (i = 0; i < MD_MEM_BANKS_N; i++) {
				if (memcomp_n->membnk_bnksz[i] == 0)
					continue;
				DB_PRF(("\t\tbank %d %dMB\n",
				    i + 1, memcomp_n->membnk_bnksz[i]));
			}
		} else {
			for (i = 0; i < MD_MEM_BANKS_M; i++) {
				if (memcomp_m->membnk_bnksz[i] == 0)
					continue;
				DB_PRF(("\t\tbank %d %dMB\n",
				    i + 1, memcomp_m->membnk_bnksz[i]));
			}
		}
#endif
		if (ip35)
			kl_add_memory_ip35(comp->nasid,
			    memcomp_m->membnk_bnksz,
			    kl_n_mode ?  MD_MEM_BANKS_N : MD_MEM_BANKS_M);
		else
			kl_add_memory_ip27(comp->nasid,
			    memcomp_m->membnk_bnksz,
			    kl_n_mode ?  MD_MEM_BANKS_N : MD_MEM_BANKS_M);
		break;

	case KLSTRUCT_GFX:
		/*
		 * We rely upon the PROM setting up a fake ARCBios component
		 * for the graphics console, if there is one.
		 * Of course, the ARCBios structure is only available as long
		 * as we do not tear down the PROM TLB, which is why we check
		 * for this as early as possible and remember the console
		 * component (KL struct are not short-lived).
		 */
		if (arc != NULL &&
		    arc->class != 0 && arc->type == arc_DisplayController &&
		    ISSET(arc->flags, ARCBIOS_DEVFLAGS_CONSOLE_OUTPUT)) {
			DB_PRF(("\t  (console device)\n"));
			/* paranoia */
			if (comp->widid >= WIDGET_MIN &&
			    comp->widid <= WIDGET_MAX)
				kl_glass_console = comp;
		}
		break;

	case KLSTRUCT_XBOW:
		xbowcomp = (klxbow_t *)comp;
		DB_PRF(("\t hub master link %d\n",
		    xbowcomp->xbow_hub_master_link));
		kl_hub_widget[comp->nasid] = xbowcomp->xbow_hub_master_link;
#ifdef DEBUG
		for (i = 0; i < MAX_XBOW_LINKS; i++) {
			if (!ISSET(xbowcomp->xbow_port_info[i].port_flag,
			    XBOW_PORT_ENABLE))
				continue;
			DB_PRF(("\t\twidget %d nasid %d flg %u\n", 8 + i,
			    xbowcomp->xbow_port_info[i].port_nasid,
			    xbowcomp->xbow_port_info[i].port_flag));
		}
#endif
		break;

#ifdef DEBUG
	case KLSTRUCT_HUB:
		hubcomp = (klhub_t *)comp;
		DB_PRF(("\t  port %d flag %d speed %lldMHz\n",
		    hubcomp->hub_port.port_nasid, hubcomp->hub_port.port_flag,
		    hubcomp->hub_speed / 1000000));
		break;

	case KLSTRUCT_SCSI2:
		scsi2comp = (klscctl_t *)comp;
		for (i = 0; i < scsi2comp->scsi_buscnt; i++) {
			scsicomp = (klscsi_t *)scsi2comp->scsi_bus[i];
			if (scsicomp == NULL)
				continue;
			DB_PRF(("\t\tbus %d, physid 0x%02x virtid %d,"
			    " specific %lld, numdevs %d\n",
			    i, scsicomp->scsi_info.physid,
			    scsicomp->scsi_info.virtid,
			    scsicomp->scsi_specific,
			    scsicomp->scsi_numdevs));
		}
		break;
#endif
	}

#ifdef DEBUG
	if (arc != NULL) {
		DB_PRF(("\t[ARCBios component:"
		    " class %d type %d flags %02x key 0x%llx",
		    arc->class, arc->type, arc->flags, arc->key));
		if (arc->id_len != 0)
			DB_PRF((" %.*s]\n",
			    (int)arc->id_len, (const char *)arc->id));
		else
			DB_PRF((" (no name)]\n"));
	}
#endif

	return 0;
}

/*
 * Enumerate the boards of all nodes, and invoke a callback for those
 * matching the given class.
 */
int
kl_scan_all_nodes(uint cls, int (*cb)(lboard_t *, void *), void *cbarg)
{
	uint node;

	if (kl_scan_node(masternasid, cls, cb, cbarg) != 0)
		return 1;
	for (node = 0; node < maxnodes; node++) {
		if (gda->nasid[node] < 0)
			continue;
		if (gda->nasid[node] == masternasid)
			continue;
		if (kl_scan_node(gda->nasid[node], cls, cb, cbarg) != 0)
			return 1;
	}

	return 0;
}

/*
 * Enumerate the boards of a node, and invoke a callback for those matching
 * the given class.
 */
int
kl_scan_node(int nasid, uint clss, int (*cb)(lboard_t *, void *), void *cbarg)
{
	lboard_t *boardinfo;

	for (boardinfo = IP27_KLFIRST_BOARD(nasid); boardinfo != NULL;
	    boardinfo = IP27_KLNEXT_BOARD(nasid, boardinfo)) {
		if (clss == KLBRD_ANY ||
		    (boardinfo->brd_type & IP27_BC_MASK) == clss) {
			if ((*cb)(boardinfo, cbarg) != 0)
				return 1;
		}
		if (boardinfo->brd_next == 0)
			break;
	}

	return 0;
}

/*
 * Enumerate the components of a board, and invoke a callback for those
 * matching the given type.
 */
int
kl_scan_board(lboard_t *boardinfo, uint type, int (*cb)(klinfo_t *, void *),
    void *cbarg)
{
	klinfo_t *comp;
	int i;

	if (!ISSET(boardinfo->struct_type, LBOARD))
		return 0;

	for (i = 0; i < boardinfo->brd_numcompts; i++) {
		comp = IP27_UNCAC_ADDR(klinfo_t *, boardinfo->brd_nasid,
		    boardinfo->brd_compts[i]);

		if (!ISSET(comp->flags, KLINFO_ENABLED) ||
		    ISSET(comp->flags, KLINFO_FAILED))
			continue;

		if (type != KLSTRUCT_ANY && comp->struct_type != type)
			continue;

		if ((*cb)(comp, cbarg) != 0)
			return 1;
	}

	return 0;
}

/*
 * Return the console device information.
 */
console_t *
kl_get_console()
{
	kl_config_hdr_t *cfghdr = IP27_KLCONFIG_HDR(0);

	return &cfghdr->cons_info;
}

/*
 * Process memory bank information.
 * There are two different routines, because IP27 and IP35 do not
 * layout memory the same way.
 */

/*
 * On IP27, access to each DIMM is interleaved, which cause it to map to
 * four banks on 128MB boundaries.
 * DIMMs of 128MB or smaller map everything in the first bank, though --
 * interleaving would be horribly non-optimal.
 */
void
kl_add_memory_ip27(int16_t nasid, int16_t *sizes, unsigned int cnt)
{
	paddr_t basepa;
	uint64_t fp, lp, np;
	unsigned int seg, nmeg;

	basepa = (paddr_t)nasid << kl_n_shift;
	while (cnt-- != 0) {
		nmeg = *sizes++;
		for (seg = 0; seg < 4; basepa += (1 << 27), seg++) {
			if (nmeg <= 128)
				np = seg == 0 ? nmeg : 0;
			else
				np = nmeg / 4;
			if (np == 0)
				continue;

			DB_PRF(("IP27 memory from %#lx to %#llx (%llu MB)\n",
			    basepa, basepa + (np << 20), np));

			np = atop(np << 20);	/* MB to pages */
			fp = atop(basepa);
			lp = fp + np;

			/*
			 * We do not manage the first 32MB, so skip them here
			 * if necessary.
			 */
			if (fp < atop(32 << 20)) {
				fp = atop(32 << 20);
				if (fp >= lp)
					continue;
				np = lp - fp;
				physmem += atop(32 << 20);
			}

			if (memrange_register(fp, lp,
			    ~(atop(1UL << kl_n_shift) - 1)) != 0) {
				/*
				 * We could hijack the smallest segment here.
				 * But is it really worth doing?
				 */
				bios_printf("%lu MB of memory could not be "
				    "managed, increase MAXMEMSEGS\n",
				    ptoa(np) >> 20);
			}
		}
	}
}

/*
 * On IP35, the smallest memory DIMMs are 256MB, and the largest is 1GB.
 * Memory is reported at 1GB intervals.
 */
void
kl_add_memory_ip35(int16_t nasid, int16_t *sizes, unsigned int cnt)
{
	paddr_t basepa;
	uint64_t fp, lp, np;

	basepa = (paddr_t)nasid << kl_n_shift;
	while (cnt-- != 0) {
		np = *sizes++;
		if (np != 0) {
			DB_PRF(("IP35 memory from %#lx to %#llx (%llu MB)\n",
			    basepa, basepa + (np << 20), np));

			fp = atop(basepa);
			np = atop(np << 20);	/* MB to pages */
			lp = fp + np;

			/*
			 * We do not manage the first 64MB, so skip them here
			 * if necessary.
			 */
			if (fp < atop(64 << 20)) {
				fp = atop(64 << 20);
				if (fp >= lp)
					continue;
				np = lp - fp;
				physmem += atop(64 << 20);
			}

			if (memrange_register(fp, lp,
			    ~(atop(1UL << kl_n_shift) - 1)) != 0) {
				/*
				 * We could hijack the smallest segment here.
				 * But is it really worth doing?
				 */
				bios_printf("%lu MB of memory could not be "
				    "managed, increase MAXMEMSEGS\n",
				    ptoa(np) >> 20);
			}
		}
		basepa += 1UL << 30;	/* 1 GB */
	}
}

/*
 * Extract unique device location from a klinfo structure.
 */
void
kl_get_location(klinfo_t *cmp, struct sgi_device_location *sdl)
{
	uint32_t wid;
	int device = cmp->physid;

	/*
	 * If the widget is actually a PIC, we need to compensate
	 * for PCI device numbering.
	 */
	if (xbow_widget_id(cmp->nasid, cmp->widid, &wid) == 0) {
		if (WIDGET_ID_VENDOR(wid) == XBOW_VENDOR_SGI3 &&
		    WIDGET_ID_PRODUCT(wid) == XBOW_PRODUCT_SGI3_PIC)
			device--;
	}

	sdl->nasid = cmp->nasid;
	sdl->widget = cmp->widid;
	if (sys_config.system_type == SGI_IP35) {
		/*
		 * IP35: need to be aware of secondary buses on PIC, and
		 * multifunction PCI cards.
		 */
		sdl->bus = cmp->pci_bus_num;
		sdl->device = device;
		if (cmp->pci_multifunc)
			sdl->fn = cmp->pci_func_num;
		else
			sdl->fn = -1;
		sdl->specific = cmp->port;
	} else {
		/*
		 * IP27: secondary buses and multifunction PCI devices are
		 * not recognized.
		 */
		sdl->bus = 0;
		sdl->device = device;
		sdl->fn = -1;
		sdl->specific = 0;
	}
}

/*
 * Similar to the above, but for the input console device, which information
 * does not come from a klinfo structure.
 */
void
kl_get_console_location(console_t *cons, struct sgi_device_location *sdl)
{
	uint32_t wid;
	int device = cons->npci;

	/*
	 * If the widget is actually a PIC, we need to compensate
	 * for PCI device numbering.
	 */
	if (xbow_widget_id(cons->nasid, cons->wid, &wid) == 0) {
		if (WIDGET_ID_VENDOR(wid) == XBOW_VENDOR_SGI3 &&
		    WIDGET_ID_PRODUCT(wid) == XBOW_PRODUCT_SGI3_PIC)
			device--;
	}

	sdl->nasid = cons->nasid;
	sdl->widget = cons->wid;
	sdl->fn = -1;
	sdl->specific = cons->type;

	/*
	 * This is a disgusting hack. The console structure does not
	 * contain a precise PCI device identification, and will also
	 * not point to the relevant klinfo structure.
	 *
	 * We assume that if the console `type' is not the IOC3 PCI
	 * identifier, then it is an IOC4 device connected to a PIC
	 * bus, therefore we can compute proper PCI location from the
	 * `npci' field.
	 */

	if (cons->type == PCI_ID_CODE(PCI_VENDOR_SGI, PCI_PRODUCT_SGI_IOC3) ||
	    sys_config.system_type != SGI_IP35) {
		sdl->bus = 0;
		sdl->device = device;
	} else {
		sdl->bus = cons->npci & KLINFO_PHYSID_PIC_BUS1 ? 1 : 0;
		sdl->device = device & KLINFO_PHYSID_WIDGET_MASK;
	}
}
@


1.31
log
@Fix bios_printf format specifier in debug code.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.30 2014/11/24 16:40:29 miod Exp $	*/
d96 2
a97 2
	DB_PRF(("magic %p version %x\n", cfghdr->magic, cfghdr->version));
	DB_PRF(("console %p baud %d\n", cfghdr->cons_info.uart_base,
d106 1
a106 1
        DB_PRF(("Region present %p.\n", val));
d108 1
a108 1
        DB_PRF(("Calias size %p.\n", val));
d144 1
a144 1
	DB_PRF(("%cboard type %x slot %x nasid %x nic %p ncomp %d\n",
d354 1
a354 1
		DB_PRF(("\t  port %d flag %d speed %dMHz\n",
d366 1
a366 1
			    " specific %ld, numdevs %d\n",
d379 1
a379 1
		    " class %d type %d flags %02x key 0x%lx",
d511 1
a511 1
			DB_PRF(("IP27 memory from %p to %p (%u MB)\n",
d558 1
a558 1
			DB_PRF(("IP35 memory from %p to %p (%u MB)\n",
@


1.30
log
@Do not attempt to dereference NULL pointers when encountering an empty SCSI
bus on a dual-scsi controller abstraction, while walking the KL component
tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.29 2011/05/30 22:25:22 oga Exp $	*/
d536 1
a536 1
				bios_printf("%u MB of memory could not be "
d583 1
a583 1
				bios_printf("%u MB of memory could not be "
@


1.29
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.28 2011/04/23 21:23:52 miod Exp $	*/
d363 2
@


1.28
log
@Do not set kl_hub_widget[] default value more than once. Found the hard way
by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.27 2011/04/23 19:52:36 miod Exp $	*/
d529 1
a529 3
			    ~(atop(1UL << kl_n_shift) - 1),
			    lp <= atop(2UL << 30) ?
			      VM_FREELIST_DEFAULT : VM_FREELIST_DMA32) != 0) {
d576 1
a576 3
			    ~(atop(1UL << kl_n_shift) - 1),
			    lp <= atop(2UL << 30) ?
			      VM_FREELIST_DEFAULT : VM_FREELIST_DMA32) != 0) {
@


1.27
log
@Move assignment of kl_hub_widget[] outside a #ifdef DEBUG ... #endif block,
giving systems with non-default values a chance to work again. Pass the brown
paper bag, please.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.26 2011/04/23 19:35:57 miod Exp $	*/
d159 2
a160 1
	kl_hub_widget[boardinfo->brd_nasid] = 0x0a;
@


1.26
log
@Partially revert 1.23, by removing the code which tries to pick the best
possible DMA window. This breaks systems which have physical memory contiguous
to the selected DMA window. A fix is in the works, in the meantime the
spice^WDMA should flow.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.25 2011/04/21 18:16:57 miod Exp $	*/
d230 1
a234 1
	klxbow_t *xbowcomp;
a332 8
#ifdef DEBUG
	case KLSTRUCT_HUB:
		hubcomp = (klhub_t *)comp;
		DB_PRF(("\t  port %d flag %d speed %dMHz\n",
		    hubcomp->hub_port.port_nasid, hubcomp->hub_port.port_flag,
		    hubcomp->hub_speed / 1000000));
		break;

d338 1
d347 9
@


1.25
log
@Fix dma_constraint upper limit computation. Logical or is not the same as
arithmetic add.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.24 2011/04/21 18:09:01 miod Exp $	*/
d46 1
a46 1
#include <uvm/uvm.h>
a66 2
void	kl_dma_select(paddr_t, psize_t);

a476 17
 * Pick the given window as the DMAable memory window, if it contains more
 * memory than our former choice. Expects the base address to be aligned on
 * a 2GB boundary.
 */
void
kl_dma_select(paddr_t base, psize_t size)
{
	static psize_t maxsize = 0;

	if (size > maxsize) {
		maxsize = size;
		dma_constraint.ucr_low = base;
		dma_constraint.ucr_high = base + ((1UL << 31) - 1);
	}
}

/*
a479 3
 *
 * This is the opportunity to pick the largest populated 2GB window on a
 * 2GB boundary, as our DMA window.
a493 2
	paddr_t twogseg;
	psize_t twogcnt;
a495 5

	/* note we know kl_n_shift > 31, so 2GB windows can not span nodes */
	twogseg = basepa >> 31;
	twogcnt = 0;

a498 7
			/* did we cross a 2GB boundary? */
			if ((basepa >> 31) != twogseg) {
				kl_dma_select(twogseg << 31, twogcnt);
				twogseg = basepa >> 31;
				twogcnt = 0;
			}

a524 2
			twogcnt += ptoa(lp - fp);

d527 2
a528 1
			    VM_FREELIST_DEFAULT) != 0) {
a538 2

	kl_dma_select(twogseg << 31, twogcnt);
a549 2
	paddr_t twogseg;
	psize_t twogcnt;
a551 5

	/* note we know kl_n_shift > 31, so 2GB windows can not span nodes */
	twogseg = basepa >> 31;
	twogcnt = 0;

a552 7
		/* did we cross a 2GB boundary? */
		if ((basepa >> 31) != twogseg) {
			kl_dma_select(twogseg << 31, twogcnt);
			twogseg = basepa >> 31;
			twogcnt = 0;
		}

a573 2
			twogcnt += ptoa(lp - fp);

d576 2
a577 1
			    VM_FREELIST_DEFAULT) != 0) {
a588 2

	kl_dma_select(twogseg << 31, twogcnt);
@


1.24
log
@Use 64 bit integer types to compute IP35 memory ranges, to give machines
with memory beyond 4GB physical a chance to run. For some reason IP27 was
already correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.23 2011/04/17 17:44:24 miod Exp $	*/
d491 1
a491 1
		dma_constraint.ucr_high = base | ((1UL << 31) - 1);
@


1.23
log
@On IP27 systems, fill the array of node hub widget numbers early, so that all
hubs are known during autoconf. Then, pick the most populated 2GB window
as our DMA memory window. xbridge(4) can thus program the correct settings
regardless of the order in which the xbow(4) attach.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.22 2011/04/07 15:30:16 miod Exp $	*/
d521 1
a521 1
	/* note we know kl_n_shift >> 31, so 2GB windows can not span nodes */
d588 1
a588 1
	uint32_t fp, lp, np;
d594 1
a594 1
	/* note we know kl_n_shift >> 31, so 2GB windows can not span nodes */
@


1.22
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.21 2011/04/03 22:34:54 miod Exp $	*/
d3 1
a3 1
 * Copyright (c) 2008, 2009 Miodrag Vallat.
d45 2
a46 1
#include <uvm/uvm_extern.h>
d67 2
d78 3
d152 11
d164 1
d347 1
d479 17
d499 3
d504 6
d516 2
a518 6
	/*
	 * On IP27, access to each DIMM is interleaved, which cause it to
	 * map to four banks on 128MB boundaries.
	 * DIMMs of 128MB or smaller map everything in the first bank,
	 * though.
	 */
d520 5
d528 7
d561 2
d565 1
a565 2
			    lp <= atop(2UL << 30) ?
			      VM_FREELIST_DEFAULT : VM_FREELIST_DMA32) != 0) {
d576 2
d580 4
d589 2
d592 5
a596 4
	/*
	 * On IP35, the smallest memory DIMMs are 256MB, and the
	 * largest is 1GB. Memory is reported at 1GB intervals.
	 */
a597 1
	basepa = (paddr_t)nasid << kl_n_shift;
d599 7
d627 2
d631 1
a631 2
			    lp <= atop(2UL << 30) ?
			      VM_FREELIST_DEFAULT : VM_FREELIST_DMA32) != 0) {
d643 2
@


1.21
log
@Enable the use of all the memory found on IP27 and IP30 kernels. Committed
from an IP35 system with half its memory outside the dma_constraint range.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.20 2010/09/17 00:04:30 miod Exp $	*/
d409 1
a409 1
		if (boardinfo->brd_next == NULL)
@


1.20
log
@Do not trust the FPU identification register obtained from KL configuration
on IP27 as well; spotted by krw.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.19 2010/04/06 19:09:50 miod Exp $	*/
a507 11
			/*
			 * XXX Temporary until there is a way to cope with
			 * XXX xbridge ATE shortage.
			 */
			if (fp >= atop(2UL << 30)) {
#if 0
				physmem += lp - fp;
#endif
				continue;
			}

a557 11
			/*
			 * XXX Temporary until there is a way to cope with
			 * XXX xbridge ATE shortage.
			 */
			if (fp >= atop(2UL << 30)) {
#if 0
				physmem += lp - fp;
#endif
				goto skip;
			}

a570 1
skip:
@


1.19
log
@Add more KL grovelling routines: one routine to enumerate on all nodes,
and routines to turn a KL console and a KL component structs, respectively,
into struct sgi_device_location for further device identification.

XXX Due to the way PCI devices are numbered on PIC buses, this code is tainted
XXX by knowledge about PIC widgets, to compensate. I have considered changing
XXX xbridge(4) to have our PCI device numbering match KL on PIC-connected
XXX devices, but I expect this to be even uglier. This is not settled yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.18 2010/03/21 13:52:05 miod Exp $	*/
d254 1
a254 4
			if (ip35)
				bootcpu_hwinfo.c1prid = cpucomp->cpu_prid;
			else
				bootcpu_hwinfo.c1prid = cpucomp->cpu_fpirr;
@


1.18
log
@Update KL structure definitions to match IP35 use of previously unused fields.
No functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.17 2010/03/07 13:42:17 miod Exp $	*/
d54 3
d59 1
d61 1
d85 1
a104 1
}
d106 26
a131 4
void
kl_scan_config(int ip35, int16_t nasid)
{
	kl_scan_node(nasid, KLBRD_ANY, kl_first_pass_board, &ip35);
d374 23
d598 91
@


1.17
log
@On Origin-like systems, get glass console information (if any) from the
fake ARCBios component structures associated to the KL configuration.
The ARCBios data tells us if the device is the output console, and the
KL component data tells us its node and widget numbers.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.16 2010/01/09 20:33:16 miod Exp $	*/
d102 1
a102 1
kl_scan_config(int nasid)
d104 1
a104 1
	kl_scan_node(nasid, KLBRD_ANY, kl_first_pass_board, NULL);
d113 1
a113 1
	DB_PRF(("%cboard type %x slot %x nasid %x nic %p components %d\n",
d115 3
a117 2
	    boardinfo->brd_type, boardinfo->brd_slot, boardinfo->brd_nasid,
	    boardinfo->brd_nic, boardinfo->brd_numcompts));
d119 1
a119 1
	kl_scan_board(boardinfo, KLSTRUCT_ANY, kl_first_pass_comp, NULL);
d123 53
d184 1
d189 1
a190 1
	klmembnk_n_t *memcomp_n;
d192 2
d198 16
d217 4
a220 4
		DB_PRF(("\tcpu type %x/%x %dMHz cache %dMB speed %dMHz\n",
		    cpucomp->cpu_prid, cpucomp->cpu_fpirr, cpucomp->cpu_speed,
		    cpucomp->cpu_scachesz, cpucomp->cpu_scachespeed));

d227 4
a230 5
#if 0
			bootcpu_hwinfo.c1prid = cpucomp->cpu_fpirr;
#else
			bootcpu_hwinfo.c1prid = cpucomp->cpu_prid;
#endif
d242 1
a242 1
		DB_PRF(("\tmemory %dMB, select %x flags %x\n",
d263 4
a266 4

		if (sys_config.system_type == SGI_IP27)
			kl_add_memory_ip27(comp->nasid, memcomp_m->membnk_bnksz,
			    kl_n_mode ? MD_MEM_BANKS_N : MD_MEM_BANKS_M);
d268 3
a270 2
			kl_add_memory_ip35(comp->nasid, memcomp_m->membnk_bnksz,
			    kl_n_mode ? MD_MEM_BANKS_N : MD_MEM_BANKS_M);
a273 1
		DB_PRF(("\tgraphics widget %d\n", comp->widid));
d285 1
a285 1
			DB_PRF(("\t(console device)\n"));
d296 3
a298 3
		DB_PRF(("\thub widget %d port %d flag %d speed %dMHz\n",
		    hubcomp->hub_info.widid, hubcomp->hub_port.port_nasid,
		    hubcomp->hub_port.port_flag, hubcomp->hub_speed / 1000000));
d303 1
a303 1
		DB_PRF(("\txbow hub master link %d\n",
d306 6
a311 6
			if (xbowcomp->xbow_port_info[i].port_flag &
			    XBOW_PORT_ENABLE)
				DB_PRF(("\t\twidget %d nasid %d flg %u\n",
				    8 + i,
				    xbowcomp->xbow_port_info[i].port_nasid,
				    xbowcomp->xbow_port_info[i].port_flag));
d315 11
a325 3
	default:
		DB_PRF(("\tcomponent widget %d type %d\n",
		    comp->widid, comp->struct_type));
d329 1
d332 2
a333 1
		DB_PRF(("\tARCBios component: class %d type %d flags %02x key 0x%lx",
d336 1
a336 1
			DB_PRF((" %.*s\n",
d339 1
a339 1
			DB_PRF((" (no name)\n"));
d342 1
d530 1
a530 1
				continue;
d546 1
@


1.16
log
@Define struct cpu_hwinfo, to hold hardware specific information about each
processor (instead of sys_config.cpu[]), and pass it in the attach_args
when attaching cpu devices.

This allows per-cpu information to be gathered late in the bootstrap process,
and not be limited by an arbitrary MAX_CPUS limit; this will suit IP27 and
IP35 systems better.

While there, use this information to make sure delay() uses the speed
information from the cpu it is invoked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.15 2009/11/19 06:06:51 miod Exp $	*/
d56 1
d72 1
d132 1
d140 1
d200 21
d249 11
@


1.15
log
@Factor triplicated code responsible to add memory information into a
single place.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.14 2009/11/07 14:49:01 miod Exp $	*/
a56 2
int nextcpu = 0;

a104 10
void
kl_scan_done()
{
	if (nextcpu > MAX_CPUS) {
		bios_printf("%u processors found, increase MAX_CPUS\n",
		    nextcpu);
	}
	ncpusfound = nextcpu;
}

a127 1
	struct cpuinfo *cpu;
d144 6
a149 6
		if (nextcpu < MAX_CPUS) {
			cpu = &sys_config.cpu[nextcpu];
			cpu->clock = cpucomp->cpu_speed * 1000000;
			cpu->type = (cpucomp->cpu_prid >> 8) & 0xff;
			cpu->vers_maj = (cpucomp->cpu_prid >> 4) & 0x0f;
			cpu->vers_min = cpucomp->cpu_prid & 0x0f;
d151 1
a151 1
			cpu->fptype = (cpucomp->cpu_fpirr >> 8) & 0xff;
d153 1
a153 1
			cpu->fptype = cpu->type;
d155 5
a159 5
			cpu->fpvers_maj = (cpucomp->cpu_fpirr >> 4) & 0x0f;
			cpu->fpvers_min = cpucomp->cpu_fpirr & 0x0f;
			cpu->tlbsize = 64;
		}
		nextcpu++;
@


1.14
log
@Change sgi system identification from a single system type list, to a smaller
system type list (which really is the system family) and a subsystem type.

No functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.13 2009/10/31 12:26:36 sobrado Exp $	*/
d316 2
a317 3
	uint32_t fp, lp, np;
	unsigned int seg, descno, nmeg;
	struct phys_mem_desc *md;
a326 7
		/*
		 * XXX Temporary until there is a way to cope with
		 * XXX xbridge ATE shortage.
		 */
		if (basepa >= (2UL << 30))
			return;

d356 2
a357 10
			 * Walk the existing segment list to find if we
			 * are adjacent to an existing segment, or the
			 * next free segment to use if not (unless doing
			 * this would cross the 2GB boundary we need for
			 * 32 bit DMA memory).
			 *
			 * Note that since we do not know in which order
			 * we'll find our nodes, we have to check for
			 * both boundaries, despite adding a given node's
			 * memory in increasing pa order.
d359 5
a363 36
			for (descno = 0, md = mem_layout; descno < MAXMEMSEGS;
			    descno++, md++) {
				if (md->mem_first_page == 0)
					break;

				/*
				 * Do not try to merge segments if they are
				 * not covering the same node.
				 */
				if ((ptoa(md->mem_first_page) >> kl_n_shift) !=
				    nasid)
					continue;

				if (md->mem_first_page == lp &&
				    lp != atop(2UL << 30)) {
					md->mem_first_page = fp;
					physmem += np;
					md = NULL;
					break;
				}

				if (md->mem_last_page == fp &&
				    fp != atop(2UL << 30)) {
					md->mem_last_page = lp;
					physmem += np;
					md = NULL;
					break;
				}
			}
			if (descno != MAXMEMSEGS && md != NULL) {
				md->mem_first_page = fp;
				md->mem_last_page = lp;
				md->mem_freelist = lp <= atop(2UL << 30) ?
				    VM_FREELIST_DMA32 : VM_FREELIST_DEFAULT;
				physmem += np;
				md = NULL;
d366 4
a369 1
			if (md != NULL) {
d376 1
a376 1
				    atop(np) >> 20);
a386 2
	unsigned int descno;
	struct phys_mem_desc *md;
a394 7
		/*
		 * XXX Temporary until there is a way to cope with
		 * XXX xbridge ATE shortage.
		 */
		if (basepa >= (2UL << 30))
			return;

d417 2
a418 10
			 * Walk the existing segment list to find if we
			 * are adjacent to an existing segment, or the
			 * next free segment to use if not (unless doing
			 * this would cross the 2GB boundary we need for
			 * 32 bit DMA memory).
			 *
			 * Note that since we do not know in which order
			 * we'll find our nodes, we have to check for
			 * both boundaries, despite adding a given node's
			 * memory in increasing pa order.
d420 5
a424 36
			for (descno = 0, md = mem_layout; descno < MAXMEMSEGS;
			    descno++, md++) {
				if (md->mem_first_page == 0)
					break;

				/*
				 * Do not try to merge segments if they are
				 * not covering the same node.
				 */
				if ((ptoa(md->mem_first_page) >> kl_n_shift) !=
				    nasid)
					continue;

				if (md->mem_first_page == lp &&
				    lp != atop(2UL << 30)) {
					md->mem_first_page = fp;
					physmem += np;
					md = NULL;
					break;
				}

				if (md->mem_last_page == fp &&
				    fp != atop(2UL << 30)) {
					md->mem_last_page = lp;
					physmem += np;
					md = NULL;
					break;
				}
			}
			if (descno != MAXMEMSEGS && md != NULL) {
				md->mem_first_page = fp;
				md->mem_last_page = lp;
				md->mem_freelist = lp <= atop(2UL << 30) ?
				    VM_FREELIST_DMA32 : VM_FREELIST_DEFAULT;
				physmem += np;
				md = NULL;
d427 4
a430 1
			if (md != NULL) {
d437 1
a437 1
				    atop(np) >> 20);
@


1.13
log
@s/Mhz/MHz/, MHz is a multiple of the SI unit hertz (whose symbol is Hz).
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.12 2009/10/16 00:15:49 miod Exp $	*/
d201 1
a201 1
		if (sys_config.system_type == SGI_O200)
@


1.12
log
@Get serial console speed from prom, and use it instead of hardcoding 9600 bps,
on all systems but O2 (to catch up soon). Also use the IOC4 MCR register to
figure out the IOC4 clock, instead of checking the widget control register,
to be consistent with iof(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.11 2009/07/06 22:46:43 miod Exp $	*/
d153 1
a153 1
		DB_PRF(("\tcpu type %x/%x %dMhz cache %dMB speed %dMhz\n",
@


1.11
log
@Almost rewrite xbridge PCI resource allocation:
- introduce an interface for widget drivers to ask the xbow to map arbitrary
  views of their address space, in addition to the low 16MB. This operation
  may fail or map a subset range of what the caller asked for, depending on
  the platform we're running on.
- use this in xbridge to set up views on the direct memory and i/o spaces,
  to map devices resources when they don't fit in one of the devio small
  ranges (limited to 2MB anyway). These views are only allocated when
  devio can't do the job, so as not to consume too many resources on
  Origin family systems where such views are scarce resources (and
  shared accross the whole crossbow).

This makes pci devices with large resource needs configure correctly.

While there, fix programming of 64 bit memory BAR; this makes bge(4)
work.

Tested on Octane (with Bridge revision < 4 and >= 4), Origin 200 (Bridge >= 4)
and Fuel (XBridge).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.10 2009/06/21 18:04:41 miod Exp $	*/
d118 1
a118 1
 * Callback routine for the initial enumration (boards).
d296 1
a296 1
 * Return the virtual address of the console device.
d298 2
a299 2
vaddr_t
kl_get_console_base()
d303 1
a303 1
	return (vaddr_t)cfghdr->cons_info.uart_base;
@


1.10
log
@Disable memory above 2GB physical again, as we can end up with an unkillable
process waiting on getblk when all ATE are exhausted, despite the exhaustion
being transient; I fear the only way to skirt this is to use bounce buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.9 2009/06/17 18:19:03 miod Exp $	*/
d75 1
a75 1
kl_init(uint64_t nibase)
d78 2
a79 1
	u_int64_t val;
d92 1
a92 1
	kl_n_shift = 32 - kl_n_mode;
@


1.9
log
@Make sure we do not coalesce memory ranges from different nodes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.8 2009/06/13 16:28:11 miod Exp $	*/
d327 7
d343 1
a343 1
			DB_PRF(("memory from %p to %p (%u MB)\n",
d388 1
a388 1
				    lp != atop(2 << 30)) {
d396 1
a396 1
				    fp != atop(2 << 30)) {
d406 1
a406 1
				md->mem_freelist = lp <= atop(2 << 30) ?
d440 7
d449 1
a449 1
			DB_PRF(("memory from %p to %p (%u MB)\n",
d494 1
a494 1
				    lp != atop(2 << 30)) {
d502 1
a502 1
				    fp != atop(2 << 30)) {
d512 1
a512 1
				md->mem_freelist = lp <= atop(2 << 30) ?
d528 1
a528 1
		basepa += 1 << 30;	/* 1 GB */
@


1.8
log
@Shuffle and rename HUB defines for consistency, no functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.7 2009/05/27 19:00:19 miod Exp $	*/
d372 8
d470 8
@


1.7
log
@Rework KL board and component enumeration, to allow it to be used from
drivers with callback routines. While there, skip disabled or failed
components.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.6 2009/05/14 21:08:49 miod Exp $	*/
d55 1
d59 2
a60 2
void	kl_add_memory_ip27(int16_t *, unsigned int);
void	kl_add_memory_ip35(int16_t *, unsigned int);
d71 3
d75 1
a75 1
kl_init()
d89 3
a91 2
	val = IP27_LHUB_L(NI_STATUS_REV_ID);
	kl_n_mode = (val & NSRI_MORENODES_MASK) != 0;
d94 1
a94 1
	val = IP27_LHUB_L(PI_REGION_PRESENT);
d96 1
a96 1
	val = IP27_LHUB_L(PI_CALIAS_SIZE);
d201 1
a201 1
			kl_add_memory_ip27(memcomp_m->membnk_bnksz,
d204 1
a204 1
			kl_add_memory_ip35(memcomp_m->membnk_bnksz,
d312 1
a312 1
kl_add_memory_ip27(int16_t *sizes, unsigned int cnt)
a313 1
	int16_t nasid = 0;	/* XXX */
d325 1
a325 1
	basepa = nasid << (32 - kl_n_mode);
d411 1
a411 1
kl_add_memory_ip35(int16_t *sizes, unsigned int cnt)
a412 1
	int16_t nasid = 0;	/* XXX */
d423 1
a423 1
	basepa = nasid << (32 - kl_n_mode);
@


1.6
log
@When walking cpu configuration, report fpu type as the cpu type, since
various R14000 (which use R14010 FPC) report different values there.
That's only to get a prettier cpu0 line in dmesg.
@
text
@d1 1
a1 2
#define	DEBUG
/*	$OpenBSD: sginode.c,v 1.5 2009/05/08 18:42:07 miod Exp $	*/
a57 1
void	kl_do_boardinfo(lboard_t *);
d61 3
d65 1
a65 1
#define	DB_PRF(x)	bios_printf x 
d71 1
a71 1
kl_scan_config(int node)
a72 1
	lboard_t *boardinfo;
d76 2
a77 2
	if (node == 0)
		physmem = 0;
d93 1
d95 5
a99 6
	for (boardinfo = IP27_KLFIRST_BOARD(0); boardinfo != NULL;
	    boardinfo = IP27_KLNEXT_BOARD(0, boardinfo)) {
		kl_do_boardinfo(boardinfo);
		if (boardinfo->brd_next == NULL)
			break;
	}
d101 3
d108 16
d126 7
a132 2
void
kl_do_boardinfo(lboard_t *boardinfo)
d134 1
a134 1
	klinfo_t *comp;
d136 2
a138 1
	klmembnk_m_t *memcomp_m;
d141 2
a142 6
	struct cpuinfo *cpu;
	int i, j;

	DB_PRF(("board type %x slot %x nasid %x nic %p components %d\n",
	    boardinfo->brd_type, boardinfo->brd_slot, boardinfo->brd_nasid,
	    boardinfo->brd_nic, boardinfo->brd_numcompts));
d144 13
a156 17
	for (i = 0; i < boardinfo->brd_numcompts; i++) {
		comp = IP27_UNCAC_ADDR(klinfo_t *, 0, boardinfo->brd_compts[i]);

		switch(comp->struct_type) {
		case KLSTRUCT_CPU:
			cpucomp = (klcpu_t *)comp;
			DB_PRF(("\tcpu type %x/%x %dMhz cache %dMB speed %dMhz\n",
			    cpucomp->cpu_prid, cpucomp->cpu_fpirr,
			    cpucomp->cpu_speed,
			    cpucomp->cpu_scachesz, cpucomp->cpu_scachespeed));

			if (nextcpu < MAX_CPUS) {
				cpu = &sys_config.cpu[nextcpu];
				cpu->clock = cpucomp->cpu_speed * 1000000;
				cpu->type = (cpucomp->cpu_prid >> 8) & 0xff;
				cpu->vers_maj = (cpucomp->cpu_prid >> 4) & 0x0f;
				cpu->vers_min = cpucomp->cpu_prid & 0x0f;
d158 1
a158 1
				cpu->fptype = (cpucomp->cpu_fpirr >> 8) & 0xff;
d160 1
a160 1
				cpu->fptype = cpu->type;
d162 29
a190 4
				cpu->fpvers_maj =
				    (cpucomp->cpu_fpirr >> 4) & 0x0f;
				cpu->fpvers_min = cpucomp->cpu_fpirr & 0x0f;
				cpu->tlbsize = 64;
d192 59
a250 1
			nextcpu++;
d252 4
d257 13
a269 35
		case KLSTRUCT_HUB:
			hubcomp = (klhub_t *)comp;
			DB_PRF(("\thub widget %d port %d flag %d speed %dMHz\n",
			    hubcomp->hub_info.widid,
			    hubcomp->hub_port.port_nasid,
			    hubcomp->hub_port.port_flag,
			    hubcomp->hub_speed / 1000000));
			break;
			
		case KLSTRUCT_MEMBNK:
			memcomp_m = (klmembnk_m_t *)comp;
			memcomp_n = (klmembnk_n_t *)comp;
			DB_PRF(("\tmemory %dMB, select %x flags %x\n",
			    memcomp_m->membnk_memsz,
			    memcomp_m->membnk_dimm_select,
			    kl_n_mode ?
			      memcomp_n->membnk_attr : memcomp_m->membnk_attr));

			if (kl_n_mode) {
				for (j = 0; j < MD_MEM_BANKS_N; j++) {
					if (memcomp_n->membnk_bnksz[j] == 0)
						continue;
					DB_PRF(("\t\tbank %d %dMB\n",
					    j + 1,
					    memcomp_n->membnk_bnksz[j]));
				}
			} else {
				for (j = 0; j < MD_MEM_BANKS_M; j++) {
					if (memcomp_m->membnk_bnksz[j] == 0)
						continue;
					DB_PRF(("\t\tbank %d %dMB\n",
					    j + 1,
					    memcomp_m->membnk_bnksz[j]));
				}
			}
d271 3
a273 8
			if (sys_config.system_type == SGI_O200)
				kl_add_memory_ip27(memcomp_m->membnk_bnksz,
				    kl_n_mode ?
				      MD_MEM_BANKS_N : MD_MEM_BANKS_M);
			else
				kl_add_memory_ip35(memcomp_m->membnk_bnksz,
				    kl_n_mode ?
				      MD_MEM_BANKS_N : MD_MEM_BANKS_M);
d275 3
a277 1
			break;
d279 2
a280 13
		case KLSTRUCT_XBOW:
			xbowcomp = (klxbow_t *)comp;
			DB_PRF(("\txbow hub master link %d\n",
			    xbowcomp->xbow_hub_master_link));
			for (j = 0; j < MAX_XBOW_LINKS; j++) {
				if (xbowcomp->xbow_port_info[j].port_flag &
				    XBOW_PORT_ENABLE)
					DB_PRF(("\t\twidget %d nasid %d flg %u\n",
					    j,
					    xbowcomp->xbow_port_info[j].port_nasid,
					    xbowcomp->xbow_port_info[j].port_flag));
			}
			break;
d282 2
a283 4
		default:
			DB_PRF(("\tcomponent widget %d type %d\n",
			    comp->widid, comp->struct_type));
		}
d286 1
@


1.5
log
@Add a new page freelist, to which memory suitable for 32-bit dma on
xbridge(4) is assigned. Then, make bus_dmamem_alloc() allocate from this
range only.

This is transparent on O2, and makes sure the bus_dma memory address
will fit in the 2GB direct map of xbridge(4) chips - this is necessary for
PCI devices which do not handle 64 bit dma addresses.
@
text
@d1 2
a2 1
/*	$OpenBSD: sginode.c,v 1.4 2009/05/06 20:08:00 miod Exp $	*/
d140 1
d142 3
@


1.4
log
@IP27 and IP35 do not layout physical memory the same way, IP35 is much
simpler; use two different routines to register memory depending on the
system type.
@
text
@d1 1
a1 2
#define	DEBUG
/*	$OpenBSD: sginode.c,v 1.3 2009/05/02 21:26:05 miod Exp $	*/
d282 3
a284 1
			 * next free segment to use if not.
d296 2
a297 1
				if (md->mem_first_page == lp) {
d304 2
a305 1
				if (md->mem_last_page == fp) {
d315 2
d374 3
a376 1
			 * next free segment to use if not.
d388 2
a389 1
				if (md->mem_first_page == lp) {
d396 2
a397 1
				if (md->mem_last_page == fp) {
d407 2
@


1.3
log
@More KL configuration structures.
@
text
@d1 2
a2 1
/*	$OpenBSD: sginode.c,v 1.2 2009/04/15 18:47:15 miod Exp $	*/
d60 2
a61 1
void	kl_add_memory(int16_t *, unsigned int);
d161 1
a161 1
			DB_PRF(("\tmemory %dMB, select %x\n",
d163 3
a165 1
			    memcomp_m->membnk_dimm_select));
d185 8
a192 2
			kl_add_memory(memcomp_m->membnk_bnksz,
			     kl_n_mode ? MD_MEM_BANKS_N : MD_MEM_BANKS_M);
d231 2
d234 1
d236 1
a236 1
kl_add_memory(int16_t *sizes, unsigned int cnt)
d245 2
a246 2
	 * Access to each DIMM is interleaved, which cause it to map
	 * to four banks on 128MB boundaries.
d269 2
a270 2
			 * ARCBios provided us with information on the
			 * first 32MB, so skip them here if necessary.
d326 87
@


1.2
log
@Disable DEBUG now, it floods too much information.
@
text
@d1 1
a1 1
/*	$OpenBSD: sginode.c,v 1.1 2009/04/13 21:17:54 miod Exp $	*/
d113 1
d117 1
a117 1
	DB_PRF(("board type %x slot %x nasid %x components %d\n",
d119 1
a119 1
	    boardinfo->brd_numcompts));
d127 3
a129 2
			DB_PRF(("\tcpu type %x %dMhz cache %dMB speed %dMhz\n",
			    cpucomp->cpu_prid, cpucomp->cpu_speed,
d184 14
@


1.1
log
@The start of Origin 200 support. Based on some code contributed by pefo@@
some years ago for KL enumeration, building on the existing XBow support
to limit ourselves to a single node for now.

This is a work-in-progress; it currently lacks complete interrupt code,
as well as PCI resource management. And there are likely bugs creeping
inside.
@
text
@d1 1
a1 2
#define	DEBUG
/*	$OpenBSD$	*/
@

