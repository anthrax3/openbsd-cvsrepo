head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.2
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.17.0.8
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.15.0.14
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.6
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.10
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.8
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.4
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.9.0.2
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.8.0.4
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4;
locks; strict;
comment	@# @;


1.18
date	2017.06.08.11.47.25;	author visa;	state Exp;
branches;
next	1.17;
commitid	QkICkbt6ZtasPvLZ;

1.17
date	2015.12.25.09.02.57;	author visa;	state Exp;
branches;
next	1.16;
commitid	up7cBfv7QqAqYrQj;

1.16
date	2015.12.25.05.52.29;	author visa;	state Exp;
branches;
next	1.15;
commitid	f89xY2823KlPzlNK;

1.15
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2012.09.29.19.02.27;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2012.06.17.12.34.19;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.11.11.29.50;	author syuu;	state Exp;
branches;
next	1.11;

1.11
date	2009.12.07.18.53.33;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.30.08.13.57;	author syuu;	state Exp;
branches;
next	1.9;

1.9
date	2009.05.22.20.37.54;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2008.03.30.20.14.14;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.18.04.32.27;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.24.22.50.31;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.20.12.49.15;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.09.22.11.39;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.19.16.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.09.14.57.26;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.21.12.19;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Split early startup code out of locore.S into locore0.S.  Adjust link
run so that this locore0.o is always at the start of the executable.
But randomize the link order of all other .o files in the kernel, so
that their exec/rodata/data/bss segments land all over the place.

Late during kernel boot, smash the startup code with traps so that
it does not point to the other randomly placed code.  It has be smashed,
because sgi runs in the kseg0 or xkphys space.

As a result, the internal layout of every newly build bsd kernel is
different from past kernels.  Internal relative offsets are not known
to an outside attacker.

Ramdisk kernels cannot be compiled like this, because they are gzip'd.
When the internal pointer references change, the compression dictionary
bloats and results in poorer compression.
@
text
@/*	$OpenBSD: locore.S,v 1.17 2015/12/25 09:02:57 visa Exp $ */

/*
 * Copyright (c) 2001-2004 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#include <sys/errno.h>
#include <sys/syscall.h>

#include <machine/param.h>
#include <machine/asm.h>
#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/regnum.h>
#include <machine/cpustate.h>

#include "assym.h"

	.set	mips3
	.set	noreorder		# Noreorder is default style!

	.globl	locore_start
	.ent	locore_start, 0
locore_start:
	MFC0	v0, COP_0_STATUS_REG
	LI	v1, ~SR_INT_ENAB
	and	v0, v1
	MTC0	v0, COP_0_STATUS_REG		# disable all interrupts
	MTC0_SR_IE_HAZARD
	MTC0	zero, COP_0_CAUSE_REG		# Clear soft interrupts
	MTC0_HAZARD

	/*
	 * Initialize stack and call machine startup.
	 */
	LA	sp, start - FRAMESZ(CF_SZ)
	LA	gp, _gp
	jal	mips_init			# mips_init(argc, argv, envp)
	PTR_S	zero, CF_RA_OFFS(sp)		# Zero out old ra for debugger

	move	sp, v0				# switch to new stack
	jal	main				# main(regs)
	 move	a0, zero
	PANIC("Startup failed!")
	.end	locore_start

#if defined(MULTIPROCESSOR)
LEAF(hw_cpu_spinup_trampoline, 0)
	MFC0	v0, COP_0_STATUS_REG
	LI	v1, ~SR_INT_ENAB
	and	v0, v1
	ori	v0, SR_KX | SR_UX
	MTC0	v0, COP_0_STATUS_REG		# disable all interrupts
	MTC0	zero, COP_0_CAUSE_REG		# Clear soft interrupts
	LA	gp, _gp
	jal	hw_cpu_hatch
	 NOP
END(hw_cpu_spinup_trampoline)

#if defined(TGT_OCTANE)

LEAF(hw_getcurcpu, 0)
	GET_CPU_INFO(v0, v1)
	j	ra
	 NOP
END(hw_getcurcpu)

/*
 * There does not seem to be any fast way to store the curcpu pointer on
 * Octane. We used to abuse the LLAddr register, but this is a 32-bit register,
 * not suitable for allocation over 2GB physical.
 * Instead, we will use an unused field of the MPCONF structure.
 */
LEAF(hw_setcurcpu, 0)
	HW_GET_CPU_PRID(v0, v1)			# get physical processor ID
	LOAD_XKPHYS(v1, CCA_COHERENT_EXCLWRITE)
	PTR_SLL	v0, MPCONF_SHIFT
	PTR_ADD	v0, MPCONF_BASE
	or	v1, v0
	j	ra
	 PTR_S	a0, (MPCONF_LEN - REGSZ)(v1)
END(hw_setcurcpu)

#elif defined(TGT_ORIGIN)

LEAF(hw_getcurcpu, 0)
	GET_CPU_INFO(v0, v1)
	j	ra
	 NOP
END(hw_getcurcpu)

LEAF(hw_setcurcpu, 0)
	DMTC0	a0, COP_0_ERROR_PC
	j	ra
	 NOP
END(hw_setcurcpu)

LEAF(ip27_cpu_spinup_trampoline, 0)
	MFC0	v0, COP_0_STATUS_REG
	LI	v1, ~SR_INT_ENAB
	and	v0, v1
	MTC0	v0, COP_0_STATUS_REG		# Disable all interrupts.
	MTC0	zero, COP_0_CAUSE_REG		# Clear soft interrupts.
	LA	gp, _gp

	/* Wait the turn of this CPU. */
1:	ll	v0, ip27_spinup_turn
	bne	v0, a0, 1b
	 not	v0, zero
	sc	v0, ip27_spinup_turn
	beqz	v0, 1b
	 nop

	LA	v0, ip27_spinup_a0
	ld	a0, 0(v0)
	LA	v0, ip27_spinup_sp
	ld	sp, 0(v0)
	jal	hw_cpu_hatch
	 nop
	PANIC("secondary CPU start failed")
END(ip27_cpu_spinup_trampoline)

#endif /* TGT_ORIGIN */

#endif /* MULTIPROCESSOR */
@


1.17
log
@Add launch logic for secondary CPUs. The PROM's launch entry point address
and function signature are from Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.16 2015/12/25 05:52:29 visa Exp $ */
d43 3
a45 15
	.globl	start
	.globl	kernel_text
kernel_text = start
start:
	/*
	 * On at least the O2, when netbooting the bsd.rd kernel, the
	 * kernel image gets loaded in CKSEG1, which causes the kernel
	 * text to be uncached.  Just to be on the safe side, jump to
	 * our intended execution address.
	 */
	LA	v0, 1f
	jr	v0
	 NOP
1:

d66 1
@


1.16
log
@Use the ErrorEPC register for curcpu() on Origin, for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.15 2012/10/03 11:18:23 miod Exp $ */
d129 25
@


1.15
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.14 2012/09/29 19:02:27 miod Exp $ */
d92 1
a92 1
#ifdef TGT_OCTANE
d115 17
a131 1
#endif
@


1.14
log
@Introduce assembly macros for specific processor hazards: tlb update, status
register update, status register update causing a change to the interrupt
enable flag, and a few other arcane ones. <mips64/asm.h> will provide
(supposedly sane) defaults, and <machine/asm.h> may override these with
better tuned versions.

Use these macros instead of random strings of nop in the various .S files
requiring hazard workarounds.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.13 2012/06/17 12:34:19 miod Exp $ */
d34 1
@


1.13
log
@Using the LLAddr register to store our curcpu() pointer on R10k SMP kernels
was a nice trick, but this register is only 32-bit wide and will be
sign-extended, which requires all cpu_info structs to be allocated within 2GB
physical - something which may not be possible on some configurations.

This diff changes IP30.MP kernels to no longer use LLAddr to store curcpu,
but use unused fields of the MPConf structure in low memory, indexed with the
physical processor id, which can be obtained from the Heart PRID register.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.12 2010/09/11 11:29:50 syuu Exp $ */
d39 1
d54 1
a54 1
	nop
d57 2
a58 2
	mfc0	v0, COP_0_STATUS_REG
	li	v1, ~SR_INT_ENAB
d60 4
a63 2
	mtc0	v0, COP_0_STATUS_REG		# disable all interrupts
	mtc0	zero, COP_0_CAUSE_REG		# Clear soft interrupts
d71 1
a71 1
	sw	zero, CF_RA_OFFS(sp)		# Zero out old ra for debugger
d75 1
a75 1
	move	a0, zero
d80 2
a81 2
	mfc0	v0, COP_0_STATUS_REG
	li	v1, ~SR_INT_ENAB
d84 2
a85 2
	mtc0	v0, COP_0_STATUS_REG		# disable all interrupts
	mtc0	zero, COP_0_CAUSE_REG		# Clear soft interrupts
d88 1
a88 1
	nop
d96 1
a96 1
	nop
@


1.12
log
@move machine dependent GET_CPU_INFO(), getcurcpu(), setcurcpu() to arch/sgi. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.11 2009/12/07 18:53:33 miod Exp $ */
d88 2
d92 1
a92 1
	jr	ra
d96 6
d103 5
a107 1
	mtc0	a0, COP_0_LLADDR
d109 1
a109 1
	nop
d111 1
@


1.11
log
@When netbooting the kernel image from ARCBios, our load address may not be
honoured, and we may end up loaded at an uncached address (e.g. CKSEG1 on
O2). This would cause the kernel to run with instruction cache disabled.

Work around this by simply jumping to the address we really want to run at,
at the beginning of locore.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.10 2009/10/30 08:13:57 syuu Exp $ */
d87 12
@


1.10
log
@Support IP30 secondary cpu bootup. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.9 2009/05/22 20:37:54 miod Exp $ */
d45 12
a56 1
	mfc0    v0, COP_0_STATUS_REG
d59 2
a60 3
	mtc0    v0, COP_0_STATUS_REG    # disable all interrupts

	mtc0	zero, COP_0_CAUSE_REG	# Clear soft interrupts
d62 3
a64 3
/*
 * Initialize stack and call machine startup.
 */
d77 9
a85 9
       mfc0    v0, COP_0_STATUS_REG
       li      v1, ~SR_INT_ENAB
       and     v0, v1
       ori     v0, SR_KX | SR_UX
       mtc0    v0, COP_0_STATUS_REG    # disable all interrupts
       mtc0    zero, COP_0_CAUSE_REG   # Clear soft interrupts
       LA      gp, _gp
       jal     hw_cpu_hatch
       nop
@


1.9
log
@Drop almost unused <machine/psl.h> on sgi; move USERMODE() definition from
there to trap.c which is its only user. This also cleans up multiple
inclusion of <machine/cpu.h> (because <machine/psl.h> includes it) in many
places.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.8 2008/03/30 20:14:14 miod Exp $ */
d64 14
@


1.8
log
@Remove former idle_stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.7 2007/10/18 04:32:27 miod Exp $ */
a31 1
#include <machine/psl.h>
@


1.7
log
@No need to include <machine/pte.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.6 2004/12/24 22:50:31 miod Exp $ */
a40 3

	.globl	idle_stack	# idle stack just below kernel.
idle_stack:
@


1.6
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.5 2004/10/20 12:49:15 pefo Exp $ */
a36 1
#include <machine/pte.h>
@


1.5
log
@Fix some 64 bit address problems.
Some function names made more unique.
Other changes for the upcoming Origin 200 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.4 2004/09/09 22:11:39 pefo Exp $ */
a68 24


/*
 * Interrupt counters for vmstat.
 */
	.data
	.globl intrcnt
	.globl eintrcnt
	.globl intrnames
	.globl eintrnames
intrnames:
	.asciiz	"softclock"
	.asciiz	"softnet"
	.asciiz	"local_dma"
	.asciiz	"local_dev"
	.asciiz	"isa_dev"
	.asciiz	"isa_nmi"
	.asciiz	"clock"
	.asciiz	"statclock"
eintrnames:
	.align	3
intrcnt:
	.word	0,0,0,0,0,0,0,0
eintrcnt:
@


1.4
log
@Kernel moves to 64 bit. A few more tweaks when binutils is updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.3 2004/08/10 19:16:18 deraadt Exp $ */
d50 5
a54 1
	mtc0	zero, COP_0_STATUS_REG	# Disable interrupts
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.2 2004/08/09 14:57:26 pefo Exp $ */
a42 2
#define	ITLBNOPFIX	nop;nop;nop;nop;nop;nop;nop;nop;nop;nop;

d56 2
a57 2
	la	sp, start - FRAMESZ(CF_SZ)
	la	gp, _gp
@


1.2
log
@Big cleanup. Removed some unused obsolete stuff and fixed copyrights
on some files. Arcbios support is now in, thus detects memorysize and cpu
clock frequency.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.1 2004/08/06 21:12:19 pefo Exp $ */
d5 1
a5 1
 * 
@


1.1
log
@initial sgi import
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a63 11
	li	t0, SR_COP_1_BIT		# Disable interrupts and
	mtc0	t0, COP_0_STATUS_REG		#   enable the fp coprocessor
	nop
	nop					# wait for new status to
	nop
	nop
	nop					# wait for new status to
	nop					# to be effective
	nop
	cfc1	t1, FPC_ID			# read FPU ID register
	sw	t1, fpu_id			# save FPU ID register
@

