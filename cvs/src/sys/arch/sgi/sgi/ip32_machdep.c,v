head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.18
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.16
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.12
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.8
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.10
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.6
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.21.0.4
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.18.0.2
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.6.0.2
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.3.0.4
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.22
date	2014.02.08.22.20.15;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2012.10.03.22.46.09;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2012.09.29.19.29.06;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2012.03.28.20.44.23;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2012.03.15.18.57.22;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2011.05.30.22.25.22;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.06.19.15.29;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2010.03.03.12.25.09;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2010.01.09.20.33.16;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.19.20.16.27;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.19.06.06.51;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.26.18.00.06;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.16.14.38.15;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.16.00.15.49;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.14.20.21.16;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.21.16.28.12;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.08.18.42.07;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.12.17.53.02;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.04.12.27.46;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.24.12.29.34;	author jsing;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.07.22.32.46;	author miod;	state Exp;
branches;
next	;


desc
@@


1.22
log
@For some reason (lack of testing being my #1 candidate), IP32 PROM version 4.18
ends up with the CKSEG1 function pointer values being wrong. All of them.
Wrong, as in, off-by-0x60.

Of course, invoking the advertized function pointers leads to interesting
results, from bogus panics to invalid pointer dereferences.

Attempt to identify this revision by:
- checking that all five function pointer values, as set up by bios_ident(),
  match the 4.18 bogus values;
- instructions at said pointer match the 4.18 values.

If the test is positive, then the pointer values are replaced with the correct
values. This allows O2 systems with 4.18 PROM to correctly powerdown, reboot
and halt.

Found the hard way by matthieu@@ after a PROM upgrade, verified on a second
system by me.
@
text
@/*	$OpenBSD: ip32_machdep.c,v 1.21 2012/10/03 22:46:09 miod Exp $ */

/*
 * Copyright (c) 2003-2004 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/extent.h>
#include <sys/tty.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/memconf.h>

#include <mips64/arcbios.h>

#include <sgi/localbus/crimebus.h>
#include <sgi/localbus/macebus.h>
#include <sgi/localbus/macebusvar.h>

#include <dev/ic/comvar.h>

extern char *hw_prod;

void crime_configure_memory(void);

void
crime_configure_memory(void)
{
	volatile u_int64_t *bank_ctrl;
	paddr_t addr;
	psize_t size;
	u_int64_t ctrl0, ctrl;
	u_int64_t first_page, last_page;
	int bank;
#ifdef DEBUG
	int i;
#endif

	bank_ctrl =
	    (void *)PHYS_TO_CKSEG1(CRIMEBUS_BASE + CRIME_MEM_BANK0_CONTROL);
	for (bank = 0; bank < CRIME_MAX_BANKS; bank++) {
		ctrl = bank_ctrl[bank];
		addr = (ctrl & CRIME_MEM_BANK_ADDR) << 25;
		size = (ctrl & CRIME_MEM_BANK_128MB) ? 128 : 32;

		/*
		 * Empty banks are reported as duplicates of bank #0.
		 */
		if (bank == 0)
			ctrl0 = ctrl;
		else if (ctrl == ctrl0)
			continue;

#ifdef DEBUG
		bios_printf("crime: bank %d contains %ld MB at %p\n",
		    bank, size, addr);
#endif

		/*
		 * Do not report memory regions below 256MB, since ARCBIOS
		 * will do.
		 */
		if (addr < 256 * 1024 * 1024)
			continue;

		addr += CRIME_MEMORY_OFFSET;
		size *= 1024 * 1024;
		first_page = atop(addr);
		last_page = atop(addr + size);

		memrange_register(first_page, last_page, 0);
	}

#ifdef DEBUG
	for (i = 0; i < MAXMEMSEGS; i++)
		if (mem_layout[i].mem_last_page != 0)
			bios_printf("MEM %d, %p to %p\n", i,
			    ptoa(mem_layout[i].mem_first_page),
			    ptoa(mem_layout[i].mem_last_page));
#endif
}

void
ip32_setup()
{
	u_long cpuspeed;

	/*
	 * IP32 PROM version 4.18:
	 *	PROM Monitor (BE)
	 *	Tue Oct 22 10:58:00 PDT 2002
	 *	VERSION 4.18
	 *	O2 R5K/R7K/R10K/R12K
	 *	IRIX 6.5.x IP32prom IP32PROM-v4
	 * has incorrect function pointers for all ARCBios calls running in
	 * CKSEG1 (all the reboot/restart routines).
	 *
	 * We attempt to detect this and fix the function pointers here.
	 *
	 * XXX 4.16 and 4.17 might need similar fixes. 4.15 is sane.
	 */

	if ((vaddr_t)bios_halt == RESET_EXC_VEC + 0x161c &&
	    (vaddr_t)bios_powerdown == RESET_EXC_VEC + 0x1648 &&
	    (vaddr_t)bios_restart == RESET_EXC_VEC + 0x1674 &&
	    (vaddr_t)bios_reboot == RESET_EXC_VEC + 0x16a0 &&
	    (vaddr_t)bios_eim == RESET_EXC_VEC + 0x15f0 &&
	    *(uint32_t *)bios_halt == 0xafbf0014 &&
	    *(uint32_t *)bios_powerdown == 0xafbf0014 &&
	    *(uint32_t *)bios_restart == 0xafb1001c &&
	    *(uint32_t *)bios_eim == 0xafbf0014) {
		bios_halt = (void (*)(void))(RESET_EXC_VEC + 0x15bc);
		bios_powerdown = (void (*)(void))(RESET_EXC_VEC + 0x15e8);
		bios_restart = (void (*)(void))(RESET_EXC_VEC + 0x1614);
		bios_reboot = (void (*)(void))(RESET_EXC_VEC + 0x1640);
		bios_eim = (void (*)(void))(RESET_EXC_VEC + 0x1590);
	}

	crime_configure_memory();

	/* R12K O2s must run with DSD on. */
	switch ((cp0_get_prid() >> 8) & 0xff) {
	case MIPS_R12000:
		setsr(getsr() | SR_DSD);
		protosr |= SR_DSD;
		break;
	}

	bootcpu_hwinfo.c0prid = cp0_get_prid();
	bootcpu_hwinfo.c1prid = cp1_get_prid();
	cpuspeed = bios_getenvint("cpufreq");
	if (cpuspeed < 100)
		cpuspeed = 180;		/* reasonable default */
	bootcpu_hwinfo.clock = cpuspeed * 1000000;
	bootcpu_hwinfo.type = (bootcpu_hwinfo.c0prid >> 8) & 0xff;

	/*
	 * Figure out how many TLB are available.
	 */
	switch (bootcpu_hwinfo.type) {
#ifdef CPU_RM7000
	case MIPS_RM7000:
		/*
		 * Rev A (version >= 2) CPU's have 64 TLB entries.
		 *
		 * However, the last 16 are only enabled if one
		 * particular configuration bit (mode bit #24)
		 * is set on cpu reset, so check whether the
		 * extra TLB are really usable.
		 *
		 * If they are disabled, they are nevertheless
		 * writable, but random TLB insert operations
		 * will never use any of them. This can be
		 * checked by inserting dummy entries and check
		 * if any of the last 16 entries have been used.
		 *
		 * Of course, due to the way the random replacement
		 * works (hashing various parts of the TLB data,
		 * such as address bits and ASID), not all the
		 * available TLB will be used; we simply check
		 * the highest valid TLB entry we can find and
		 * see if it is in the upper 16 entries or not.
		 */
		bootcpu_hwinfo.tlbsize = 48;
		if (((bootcpu_hwinfo.c0prid >> 4) & 0x0f) >= 2) {
			struct tlb_entry te;
			int e, lastvalid;

			tlb_set_wired(0);
			tlb_flush(64);
			for (e = 0; e < 64 * 8; e++)
				tlb_update(XKSSEG_BASE + ptoa(2 * e),
				    pfn_to_pad(0) | PG_ROPAGE);
			lastvalid = 0;
			for (e = 0; e < 64; e++) {
				tlb_read(e, &te);
				if ((te.tlb_lo0 & PG_V) != 0)
					lastvalid = e;
			}
			tlb_flush(64);
			if (lastvalid >= 48)
				bootcpu_hwinfo.tlbsize = 64;
		}
		break;
#endif
#ifdef CPU_R10000
	case MIPS_R10000:
	case MIPS_R12000:
	case MIPS_R14000:
		bootcpu_hwinfo.tlbsize = 64;
		break;
#endif
	default:	/* R5000, RM52xx */
		bootcpu_hwinfo.tlbsize = 48;
		break;
	}

	/* Setup serial console if ARCS is telling us not to use video. */
	if (strncmp(bios_console, "video", 5) != 0) {
		comconsaddr = MACE_ISA_SER1_OFFS;
		comconsfreq = 1843200;
		comconsiot = &macebus_tag;
		comconsrate = bios_consrate;
	}

	/* not sure if there is a way to tell O2 and O2+ apart */
	hw_prod = "O2";

	_device_register = arcs_device_register;
}
@


1.21
log
@Don't include <mips64/archtype.h> unless you really need it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.20 2012/10/03 11:18:23 miod Exp $ */
d117 31
@


1.20
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.19 2012/09/29 19:29:06 miod Exp $ */
a44 1
#include <mips64/archtype.h>
@


1.19
log
@Store the base value of coprocessor 0 system register, when running userland,
into a global. This allows R12000 O2 systems to set the DSD bit in once for
all, instead of having to set it every time in setregs().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.18 2012/03/28 20:44:23 miod Exp $ */
d41 1
@


1.18
log
@Work in progress support for the SGI Indigo, Indigo 2 and Indy systems
(IP20, IP22, IP24) in 64-bit mode, adapated from NetBSD. Currently limited
to headless operation, input and video drivers will get ported soon.

Should work on all R4000, R4440 and R5000 based systems. L2 cache on R5000SC
Indy not supported yet (coming soon), R4600 not supported yet either (coming
soon as well).

Tested to boot multiuser on: Indigo2 R4000SC, Indy R4000PC, Indy R4000SC,
Indy R5000SC, Indigo2 R4400SC. There are still glitches in the Ethernet driver
which are being looked at.

Expansion support is limited to the GIO E++ board; GIO boards with PCI-GIO
bridges not ported yet due to the lack of hardware, and this kind of driver
does not port blindly.

Most of this work comes from NetBSD, polishing and integration work, as well
as putting as many ``R4x00 in 64-bit mode'' erratas as necessary, by yours
truly.

More work is coming, as well as trying to get some easy way to boot install
kernels (as older PROM can only boot ECOFF binaries, which won't do for the
kernel).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.17 2012/03/15 18:57:22 miod Exp $ */
d124 1
@


1.17
log
@uncached_base was introduced early in IP27 support, since these designs use
subspaces in the CCA_NC uncached memory space. However, being coherent,
there was never a need for bus_dma to use uncached addresses.

This means that, on the only systems where uncached_base was not set to
PHYS_TO_XKPHYS(0, CCA_NC), it was never used.

Remove the variable, and replace PHYS_TO_UNCACHED() with
PHYS_TO_XKPHYS(, CCA_NC). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.16 2011/05/30 22:25:22 oga Exp $ */
d201 1
a201 3
		comconsrate = bios_getenvint("dbaud");
		if (comconsrate < 50 || comconsrate > 115200)
			comconsrate = 9600;
@


1.16
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.15 2010/04/06 19:15:29 miod Exp $ */
a116 2

	uncached_base = PHYS_TO_XKPHYS(0, CCA_NC);
@


1.15
log
@Split the device_register() code responsible for boot path recognition into
two distinct sets of routines: one for the ARCBios-compatible path used on
non-KL systems (such as O2 and Octane), and one for the KL system using
dksc() paths.

When trying to match a dksc() path, walk the KL configuration of the whole
system until the dksc controller is found; since the controller numbers are
not assigned sequentially and contiguously, the old code would not work on
complex systems (such as when booting from controller #6 when #3 to #5 are
unaffected).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.14 2010/03/03 12:25:09 jsing Exp $ */
d101 1
a101 2
		memrange_register(first_page, last_page, 0,
		    VM_FREELIST_DEFAULT);
@


1.14
log
@Store ARCBios variables before machine specific setup is performed and
make console selection on a per machine basis. Whilst here store the
keyboard layout ('keybd') and graphics state ('gfx') variables for
future use.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.12 2009/11/19 20:16:27 miod Exp $ */
d211 2
@


1.13
log
@Define struct cpu_hwinfo, to hold hardware specific information about each
processor (instead of sys_config.cpu[]), and pass it in the attach_args
when attaching cpu devices.

This allows per-cpu information to be gathered late in the bootstrap process,
and not be limited by an arbitrary MAX_CPUS limit; this will suit IP27 and
IP35 systems better.

While there, use this information to make sure delay() uses the speed
information from the cpu it is invoked on.
@
text
@d199 9
a207 6
	comconsaddr = MACE_ISA_SER1_OFFS;
	comconsfreq = 1843200;
	comconsiot = &macebus_tag;
	comconsrate = bios_getenvint("dbaud");
	if (comconsrate < 50 || comconsrate > 115200)
		comconsrate = 9600;
@


1.12
log
@Rename KSEG* defines to CKSEG* to match their names in 64 bit mode; also
define more 64 bit spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.11 2009/11/19 06:06:51 miod Exp $ */
d130 2
d135 63
a197 1
	sys_config.cpu[0].clock = cpuspeed * 1000000;
@


1.11
log
@Factor triplicated code responsible to add memory information into a
single place.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.10 2009/10/26 18:00:06 miod Exp $ */
d70 1
a70 1
	    (void *)PHYS_TO_KSEG1(CRIMEBUS_BASE + CRIME_MEM_BANK0_CONTROL);
@


1.10
log
@Better crime/mace interrupt handling; interrupt information is no longer
specified in the kernel configuration file, but is provided by macebus(4)
as part of the  child device attachment args, and provide both crime and
mace interrupt bitmasks; this allows us to only really enable interrupt
sources we care about, and to avoid invoking interrupt handler we don't need
to for the few mace interrupts multiplexed at the crime level.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.9 2009/10/16 14:38:15 miod Exp $ */
a58 1
	struct phys_mem_desc *m;
d63 5
a67 2
	u_int32_t first_page, last_page;
	int bank, i;
d69 2
a70 1
	bank_ctrl = (void *)PHYS_TO_KSEG1(CRIMEBUS_BASE + CRIME_MEM_BANK0_CONTROL);
d101 2
a102 25
		/*
		 * Try to coalesce with other memory segments if banks are 
		 * contiguous.
		 */
		m = NULL;
		for (i = 0; i < MAXMEMSEGS; i++) {
			if (mem_layout[i].mem_last_page == 0) {
				if (m == NULL)
					m = &mem_layout[i];
			} else if (last_page == mem_layout[i].mem_first_page) {
				m = &mem_layout[i];
				m->mem_first_page = first_page;
			} else if (mem_layout[i].mem_last_page == first_page) {
				m = &mem_layout[i];
				m->mem_last_page = last_page;
			}
		}
		if (m != NULL) {
			if (m->mem_last_page == 0) {
				m->mem_first_page = first_page;
				m->mem_last_page = last_page;
			}
			m->mem_freelist = VM_FREELIST_DEFAULT;
			physmem += atop(size);
		}
d107 4
a110 4
		if (mem_layout[i].mem_first_page)
			bios_printf("MEM %d, 0x%x to  0x%x\n",i,
				ptoa(mem_layout[i].mem_first_page),
				ptoa(mem_layout[i].mem_last_page));
@


1.9
log
@Honour serial console speed on O2 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.8 2009/10/16 00:15:49 miod Exp $ */
d48 1
@


1.8
log
@Get serial console speed from prom, and use it instead of hardcoding 9600 bps,
on all systems but O2 (to catch up soon). Also use the IOC4 MCR register to
figure out the IOC4 clock, instead of checking the widget control register,
to be consistent with iof(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.7 2009/10/14 20:21:16 miod Exp $ */
d157 3
@


1.7
log
@On IP30 and IP35 systems, try harder to figure out exactly what model we are
running on, and report this both as the hw.product sysctl and in dmesg.
Fuel and Origin 350 are no longer reported as being Origin 300 systems!
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.6 2009/05/21 16:28:12 miod Exp $ */
d136 2
d148 5
@


1.6
log
@Overhaul root device detection; the code will now follow the ARCS bootpath
component by component, from device_register().

IP27 and IP35 systems using the dksc() syntax get their dksc() syntax converted
to an ARCS bootpath, so the same logic will apply.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.5 2009/05/08 18:42:07 miod Exp $ */
d51 2
d150 3
@


1.5
log
@Add a new page freelist, to which memory suitable for 32-bit dma on
xbridge(4) is assigned. Then, make bus_dmamem_alloc() allocate from this
range only.

This is transparent on O2, and makes sure the bus_dma memory address
will fit in the 2GB direct map of xbridge(4) chips - this is necessary for
PCI devices which do not handle 64 bit dma addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.4 2009/04/12 17:53:02 miod Exp $ */
a52 2
extern int bootdriveoffs;

a137 7
	/* R1xK O2s are one disk slot machines. Offset slotno. */
	switch ((cp0_get_prid() >> 8) & 0xff) {
	case MIPS_R10000:
	case MIPS_R12000:
		bootdriveoffs = -1;
		break;
	}
@


1.4
log
@Get com console global variables from <dev/ic/comvar.h> instead of declaring
them manually.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.3 2008/05/04 12:27:46 miod Exp $ */
d119 1
@


1.3
log
@Unpopulated CRIME memory banks (or logically empty due to CRIME merging
contiguous 64MB DIMMs in a single 128MB one) are not reported as memory at
offset zero, but actually as duplicates of the first entry (which always
matches real memory).

If the DIMMs are set up in decreasing sizes, as recommanded by SGI, the
first entry will be configured at offset zero, so the existing code would
run fine.

If, however, you order your DIMMs in a different order, the first entry
might not be at offset zero, so the kernel will mess up its memory
information, which will cause random effects from simply misreported memory
sizes, to the inability to boot.

Fix this by strengthening the check for an empty bank.

Problem reported by Jason Bergstrom (bergie, bergie dot net), analysis
and fix by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.2 2008/04/24 12:29:34 jsing Exp $ */
d32 1
d34 1
d49 2
a53 4

extern bus_addr_t comconsaddr;
extern bus_space_tag_t comconsiot;
extern int comconsfreq;
@


1.2
log
@Cleanup serial console handling and remove some of the MD code from com.c.
Specify the serial configuration from within the MD code, rather than
passing things via macros. This will allow other platforms to more readily
change the serial console configuration.

Committing this so it actually gets tested.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip32_machdep.c,v 1.1 2008/04/07 22:32:46 miod Exp $ */
d62 1
d68 12
a79 2
		addr = (bank_ctrl[bank] & CRIME_MEM_BANK_ADDR) << 25;
		size = (bank_ctrl[bank] & CRIME_MEM_BANK_128MB) ? 128 : 32;
d81 1
a81 1
		bios_printf("crime: bank %d contains %ld MB at 0x%lx\n",
d86 2
a87 2
		 * Do not report memory regions below 256MB, since ARCBIOS will do.
		 * Moreover, empty banks are reported at address zero.
d92 1
a92 1
		addr += 1024 * 1024 * 1024;
d114 6
a119 3
		if (m != NULL && m->mem_last_page == 0) {
			m->mem_first_page = first_page;
			m->mem_last_page = last_page;
a120 2
		if (m != NULL)
			physmem += atop(size);
@


1.1
log
@Unclutter machdep.c by moving the IP32-specific initialization code to its
own file. While there, more dead beef removal in struct sys_rec.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2008/02/20 19:13:38 miod Exp $ */
d51 4
d141 3
a143 3
	sys_config.cons_ioaddr = MACE_ISA_SER1_OFFS;
	sys_config.cons_baudclk = 1843200;		/*XXX*/
	sys_config.cons_iot = &macebus_tag;
@

