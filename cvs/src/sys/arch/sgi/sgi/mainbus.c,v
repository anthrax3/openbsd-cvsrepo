head	1.13;
access;
symbols
	OPENBSD_6_0:1.13.0.16
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.12
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.14
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.6
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.10
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.8
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.4
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.2
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.12.0.2
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.1.0.2
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2012.09.29.21.46.02;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2012.07.18.19.56.02;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2012.07.14.19.53.31;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2012.04.03.21.17.35;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2012.03.28.20.44.23;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2010.01.09.20.33.16;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.07.18.56.55;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2009.11.07.14.49.01;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.30.08.13.57;	author syuu;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.26.20.14.42;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.26.18.13.34;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.14.20.21.16;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.13.21.48.03;	author miod;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Work in progress support for the Power Indigo2 R8000 system (IP26). This is
basically an IP22 system (R4000 Indigo2) with the ECC memory board of IP28,
and a so-called ``streaming'' L2 cache.

IP26 kernels currently boot single-user, but don't live long; I am suspecting
a bug in the tcc cache routines, but am currently not able to find it (come
to think of it, my understanding of how this cache works could be wrong, and
of course there is no documentation for it but what can be gathered from
IRIX' <sys/IP26.h> comments and defines).

Hopefully this situation will improve in the near future; in the meantime I
am commiting this as `work in progress' to make sure this code doesn't get
lost.
@
text
@/*	$OpenBSD: mainbus.c,v 1.12 2012/07/18 19:56:02 miod Exp $ */

/*
 * Copyright (c) 2001-2003 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/reboot.h>

#include <mips64/archtype.h>
#include <machine/autoconf.h>

/* Definition of the mainbus driver. */
int	mbmatch(struct device *, void *, void *);
void	mbattach(struct device *, struct device *, void *);
int	mbprint(void *, const char *);

const struct cfattach mainbus_ca = {
	sizeof(struct device), mbmatch, mbattach
};

struct cfdriver mainbus_cd = {
	NULL, "mainbus", DV_DULL
};

int
mbmatch(struct device *parent, void *cfdata, void *aux)
{
	static int mbattached = 0;

	if (mbattached != 0)
		return 0;

	return mbattached = 1;
}

void
mbattach(struct device *parent, struct device *self, void *aux)
{
	struct cpu_attach_args caa;
	extern char *hw_prod;

	if (hw_prod != NULL)
		printf(": %s", hw_prod);
	printf("\n");

	/*
	 * On multiprocessor capable systems, delegate everything to the
	 * IP-specific code.
	 */
	switch (sys_config.system_type) {
#ifdef TGT_ORIGIN
	case SGI_IP27:
	case SGI_IP35:
		ip27_autoconf(self);
		return;
#endif
#ifdef TGT_OCTANE
	case SGI_OCTANE:
		ip30_autoconf(self);
		return;
#endif
	default:
		break;
	}

	/*
	 * On other systems, attach the CPU, its clock, and the
	 * mainbus here.
	 * XXX Would be worth doing as ipXX_autoconf() too.
	 */

	bzero(&caa, sizeof caa);
	caa.caa_maa.maa_name = "cpu";
	caa.caa_hw = &bootcpu_hwinfo;
	config_found(self, &caa, mbprint);

	switch (sys_config.system_type) {
#if defined(TGT_INDIGO) || defined(TGT_INDY) || defined(TGT_INDIGO2)
	case SGI_IP20:
	case SGI_IP22:
	case SGI_IP26:
	case SGI_IP28:
		/* Interrupt Controller */
		caa.caa_maa.maa_name = "int";
		config_found(self, &caa.caa_maa, mbprint);
#ifdef TGT_INDIGO2
		if (sys_config.system_type == SGI_IP26) {
			/* Streaming Cache Controller */
			caa.caa_maa.maa_name = "tcc";
			config_found(self, &caa.caa_maa, mbprint);
		}
#endif
		/* Memory Controller */
		caa.caa_maa.maa_name = "imc";
		config_found(self, &caa.caa_maa, mbprint);

		if (md_startclock == NULL) {
			caa.caa_maa.maa_name = "clock";
			config_found(self, &caa.caa_maa, mbprint);
		}

		ip22_post_autoconf();

		break;
#endif
#ifdef TGT_O2
	case SGI_O2:
		caa.caa_maa.maa_name = "clock";
		config_found(self, &caa.caa_maa, mbprint);
		caa.caa_maa.maa_name = "macebus";
		config_found(self, &caa.caa_maa, mbprint);
		caa.caa_maa.maa_name = "gbe";
		config_found(self, &caa.caa_maa, mbprint);
		break;
#endif
	default:
		break;
	}
}

int
mbprint(void *aux, const char *pnp)
{
	if (pnp)
		return (QUIET);
	return (UNCONF);
}
@


1.12
log
@According to Linux, and just verified the hard way, the 8254 timer does not
interrupt on Indy; do not use it on such systems. Then, bring back a clock0 at
mainbus attachment to IP22 kernels, and attach it late in the autoconf process
if no other device has claimed the clock yet.

This means R4000 and R4400 based Indy may experience the lost clock interrupt
processor errata again, until a better way to skirt it is found.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.11 2012/07/14 19:53:31 miod Exp $ */
d111 7
@


1.11
log
@A known errata of R4000 and R4400 processors, is that reading the internal
counter register close to a trigger of the counter interrupt, may cause the
interrupt not to be generated. This makes it a bad idea to use the internal
counter both for the scheduling clock and for delay().

Therefore, on IP22 systems (and IP28 because it makes my life easier), use
one of the two 8254 timers connected to the onboard interrupt controller as
the scheduling clock source.

Adapted from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.10 2012/04/03 21:17:35 miod Exp $ */
d114 5
@


1.10
log
@Default DMA-reachable address constraints to the whole address space, and
narrow these in the various ipXX_machdep.c. On IP22-like systems, narrow
them to 28 bit physical addresses, but unpessimize this by extending this
to 32 bit after autoconf, if no 28-bit limited hpc(4) device has been found.
Since physical memory on these systems start at 128MB, this means that Indigo
systems with more than 128MB memory will behave correctly (and so will Indy
systems with E++ boards and more than 128MB memory).
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.9 2012/03/28 20:44:23 miod Exp $ */
a101 3
	caa.caa_maa.maa_name = "clock";
	config_found(self, &caa.caa_maa, mbprint);

d121 2
@


1.9
log
@Work in progress support for the SGI Indigo, Indigo 2 and Indy systems
(IP20, IP22, IP24) in 64-bit mode, adapated from NetBSD. Currently limited
to headless operation, input and video drivers will get ported soon.

Should work on all R4000, R4440 and R5000 based systems. L2 cache on R5000SC
Indy not supported yet (coming soon), R4600 not supported yet either (coming
soon as well).

Tested to boot multiuser on: Indigo2 R4000SC, Indy R4000PC, Indy R4000SC,
Indy R5000SC, Indigo2 R4400SC. There are still glitches in the Ethernet driver
which are being looked at.

Expansion support is limited to the GIO E++ board; GIO boards with PCI-GIO
bridges not ported yet due to the lack of hardware, and this kind of driver
does not port blindly.

Most of this work comes from NetBSD, polishing and integration work, as well
as putting as many ``R4x00 in 64-bit mode'' erratas as necessary, by yours
truly.

More work is coming, as well as trying to get some easy way to boot install
kernels (as older PROM can only boot ECOFF binaries, which won't do for the
kernel).
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.8 2010/01/09 20:33:16 miod Exp $ */
d117 3
@


1.8
log
@Define struct cpu_hwinfo, to hold hardware specific information about each
processor (instead of sys_config.cpu[]), and pass it in the attach_args
when attaching cpu devices.

This allows per-cpu information to be gathered late in the bootstrap process,
and not be limited by an arbitrary MAX_CPUS limit; this will suit IP27 and
IP35 systems better.

While there, use this information to make sure delay() uses the speed
information from the cpu it is invoked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.7 2009/11/07 18:56:55 miod Exp $ */
d92 3
a94 3
	 * On other systems, attach the CPU we are running on early;
	 * other processors, if any, will get attached as they are
	 * discovered.
d106 13
@


1.7
log
@Replace option TGT_ORIGIN200 and TGT_ORIGIN2000 with a single option,
TGT_ORIGIN, which enables support for all IP27 and IP35 systems. The original
two options have always been used together, and go back to when pefo thought
supporting multiple nodes would be significant work. Since an Origin 200
can be a dual-node system, making a distinction between single node and
multiple node systems is a moot point anyway.

Be sure to rerun config(8) before rebuilding a kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.6 2009/11/07 14:49:01 miod Exp $ */
d64 1
a64 1
	struct mainbus_attach_args maa;
d72 2
a73 2
	 * On IP27 and IP35 system, delegate everything to the IP-specific
	 * code.
d97 7
a103 5
	bzero(&maa, sizeof maa);
	maa.maa_name = "cpu";
	config_found(self, &maa, mbprint);
	maa.maa_name = "clock";
	config_found(self, &maa, mbprint);
d108 4
a111 4
		maa.maa_name = "macebus";
		config_found(self, &maa, mbprint);
		maa.maa_name = "gbe";
		config_found(self, &maa, mbprint);
@


1.6
log
@Change sgi system identification from a single system type list, to a smaller
system type list (which really is the system family) and a subsystem type.

No functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.5 2009/10/30 08:13:57 syuu Exp $ */
d76 1
a76 1
#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
@


1.5
log
@Support IP30 secondary cpu bootup. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.4 2009/10/26 20:14:42 miod Exp $ */
d77 2
a78 2
	case SGI_O200:
	case SGI_O300:
@


1.4
log
@Rename struct confargs to struct mainbus_attach_args for consistency and also
to prevent further abuse of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.3 2009/10/26 18:13:34 miod Exp $ */
d82 5
a108 8
		config_found(self, &maa, mbprint);
		break;
#endif
#ifdef TGT_OCTANE
	case SGI_OCTANE:
		maa.maa_name = "xbow";
		config_found(self, &maa, mbprint);
		maa.maa_name = "power";
@


1.3
log
@Add support for the Octane power button to power(4). Took me a while to
figure out how the interrupt was routed from xbridge to xheart... (it bypasses
the regular `have xbridge send a xio interrupt packet' mechanism)
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.2 2009/10/14 20:21:16 miod Exp $ */
d64 1
a64 1
	struct confargs nca;
d92 5
a96 5
	bzero(&nca, sizeof nca);
	nca.ca_name = "cpu";
	config_found(self, &nca, mbprint);
	nca.ca_name = "clock";
	config_found(self, &nca, mbprint);
d101 4
a104 4
		nca.ca_name = "macebus";
		config_found(self, &nca, mbprint);
		nca.ca_name = "gbe";
		config_found(self, &nca, mbprint);
d109 4
a112 4
		nca.ca_name = "xbow";
		config_found(self, &nca, mbprint);
		nca.ca_name = "power";
		config_found(self, &nca, mbprint);
@


1.2
log
@On IP30 and IP35 systems, try harder to figure out exactly what model we are
running on, and report this both as the hw.product sysctl and in dmesg.
Fuel and Origin 350 are no longer reported as being Origin 300 systems!
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.1 2009/06/13 21:48:03 miod Exp $ */
d110 2
@


1.1
log
@Enumerate all available nodes for hardware on IP27/IP35 systems; works to some
extent, but isp(4) on other nodes do not work correctly yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.7 2009/04/19 12:52:33 miod Exp $ */
d65 1
d67 2
@

