head	1.33;
access;
symbols
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.32.0.4
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.30.0.10
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.30.0.6
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.26.0.10
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.8
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.6
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.16.0.2
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.3.0.4
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3;
locks; strict;
comment	@ * @;


1.33
date	2017.02.28.10.49.37;	author natano;	state Exp;
branches;
next	1.32;
commitid	9645cvu5lMcc7gZM;

1.32
date	2016.02.24.18.25.50;	author krw;	state Exp;
branches;
next	1.31;
commitid	49hQIFvRrM4V62Hl;

1.31
date	2015.09.28.15.17.08;	author krw;	state Exp;
branches;
next	1.30;
commitid	F5VKEQmoSNbQb8HV;

1.30
date	2014.01.06.21.00.55;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2013.12.28.23.37.00;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2013.10.23.11.19.32;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2013.10.19.09.32.15;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.10.16.16.08;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.10.04.49.39;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.08.00.08.00;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.16.03.21.15;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.15.14.57.29;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2011.04.06.13.46.50;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2011.02.26.13.07.48;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.23.15.25.20;	author jsing;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.09.04.25.34;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2009.08.13.15.23.11;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.14.00.09.39;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.05.09.12.25;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.04.21.13.02;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2009.05.28.17.05.50;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2009.05.13.01.31.58;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.01.16.28.50;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.01.14.08.25;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2008.08.08.23.49.53;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2008.07.20.13.46.16;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2008.07.20.13.40.27;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.12.06.58.36;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.11.12.35.43;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.10.20.50.23;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2007.07.10.15.44.23;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.20.18.15.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2007.06.18.21.46.41;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Switch geteblks()'s size argument from int to size_t. It's called with
unsigned variables as argument in most places anyway. Decrease the
chance of signedness/range mismatch issues.

ok stefan
@
text
@/*	$OpenBSD: disksubr.c,v 1.32 2016/02/24 18:25:50 krw Exp $	*/

/*
 * Copyright (c) 1999 Michael Shalayeff
 * Copyright (c) 1997 Niklas Hallqvist
 * Copyright (c) 1996 Theo de Raadt
 * Copyright (c) 1982, 1986, 1988 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/syslog.h>
#include <sys/disk.h>

int	readsgilabel(struct buf *, void (*)(struct buf *),
	    struct disklabel *, daddr_t *, int);

/*
 * Attempt to read a disk label from a device
 * using the indicated strategy routine.
 * The label must be partly set up before this:
 * secpercyl, secsize and anything required for a block i/o read
 * operation in the driver's strategy/start routines
 * must be filled in before calling us.
 */
int
readdisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, int spoofonly)
{
	struct buf *bp = NULL;
	int error;

	if ((error = initdisklabel(lp)))
		goto done;
	lp->d_flags |= D_VENDOR;

	/* get a buffer and initialize it */
	bp = geteblk(lp->d_secsize);
	bp->b_dev = dev;

	error = readsgilabel(bp, strat, lp, NULL, spoofonly);
	if (error == 0)
		goto done;

	error = readdoslabel(bp, strat, lp, NULL, spoofonly);
	if (error == 0)
		goto done;

#if defined(CD9660)
	error = iso_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif
#if defined(UDF)
	error = udf_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}

static struct {
	int m;
	int b;
} maptab[] = {
    { 0,	FS_BSDFFS},	{ 1,	FS_SWAP},	{ 10,	FS_BSDFFS},
    { 3,	FS_BSDFFS},	{ 4,	FS_BSDFFS},	{ 5,	FS_BSDFFS},
    { 6,	FS_BSDFFS},	{ 7,	FS_BSDFFS},	{ 15,	FS_OTHER},
    { 9,	FS_BSDFFS},	{ 2,	FS_UNUSED},	{ 11,	FS_BSDFFS},
    { 12,	FS_BSDFFS},	{ 13,	FS_BSDFFS},	{ 14,	FS_BSDFFS},
    { 8,	FS_BSDFFS}
};

int
readsgilabel(struct buf *bp, void (*strat)(struct buf *),
    struct disklabel *lp, daddr_t *partoffp, int spoofonly)
{
	struct sgilabel *dlp;
	int i, *p, cs = 0;
	daddr_t fsoffs, fsend;
	int error, offset;

	/* if successful, locate disk label within block and validate */
	error = readdisksector(bp, strat, lp, 0);
	if (error)
		return (error);

	fsoffs = DL_SECTOBLK(lp, DL_GETBSTART(lp));
	fsend = DL_SECTOBLK(lp, DL_GETBEND(lp));

	dlp = (struct sgilabel *)(bp->b_data + LABELOFFSET);
	if (dlp->magic != htobe32(SGILABEL_MAGIC))
		goto finished;

	if (dlp->partitions[0].blocks == 0)
		return (EINVAL);
	fsoffs = (long long)dlp->partitions[0].first;
	fsend = fsoffs + dlp->partitions[0].blocks;

	/* Only came here to find the offset... */
	if (partoffp) {
		*partoffp = fsoffs;
		goto finished;
	}

	p = (int *)dlp;
	i = sizeof(struct sgilabel) / sizeof(int);
	while (i--)
		cs += *p++;
	if (cs != 0)
		return (EINVAL);	/* sgilabel checksum error */

	/* Spoof info from sgi label, in case there is no OpenBSD label. */
	lp->d_npartitions = MAXPARTITIONS;

	for (i = 0; i < 16; i++) {
		int bsd = maptab[i].m;
		int type = maptab[i].b;

		if (spoofonly && type != FS_UNUSED && type != FS_OTHER)
			continue;

		DL_SETPOFFSET(&lp->d_partitions[bsd],
		    dlp->partitions[i].first);
		DL_SETPSIZE(&lp->d_partitions[bsd],
		    dlp->partitions[i].blocks);
		lp->d_partitions[bsd].p_fstype = type;
		if (type == FS_BSDFFS) {
			lp->d_partitions[bsd].p_fragblock =
			    DISKLABELV1_FFS_FRAGBLOCK(1024, 8);
			lp->d_partitions[bsd].p_cpg = 16;
		}
	}

	DL_SETBSTART(lp, DL_BLKTOSEC(lp, fsoffs));
	DL_SETBEND(lp, DL_BLKTOSEC(lp, fsend));
	lp->d_version = 1;
	lp->d_flags = D_VENDOR;
	lp->d_checksum = 0;
	lp->d_checksum = dkcksum(lp);

finished:
	/* record the OpenBSD partition's placement for the caller */
	if (partoffp)
		*partoffp = fsoffs;
	else {
		DL_SETBSTART(lp, DL_BLKTOSEC(lp, fsoffs));
		DL_SETBEND(lp, DL_BLKTOSEC(lp, fsend));
	}

	/* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
		return (0);

	error = readdisksector(bp, strat, lp, DL_BLKTOSEC(lp, fsoffs +
	    LABELSECTOR));
	if (error)
		return (error);
	offset = DL_BLKOFFSET(lp, fsoffs + LABELSECTOR) + LABELOFFSET;

	error = checkdisklabel(bp->b_data + offset, lp, fsoffs, fsend);
	return (error);
}

/*
 * Write disk label back to device after modification.
 */
int
writedisklabel(dev_t dev, void (*strat)(struct buf *), struct disklabel *lp)
{
	daddr_t partoff = -1;
	int error = EIO;
	int offset;
	struct buf *bp = NULL;
	struct disklabel *dlp;

	/* get a buffer and initialize it */
	bp = geteblk(lp->d_secsize);
	bp->b_dev = dev;

	if (readsgilabel(bp, strat, lp, &partoff, 1) != 0 &&
	    readdoslabel(bp, strat, lp, &partoff, 1) != 0)
		goto done;

	/* Read it in, slap the new label in, and write it back out */
	error = readdisksector(bp, strat, lp, DL_BLKTOSEC(lp, partoff +
	    DOS_LABELSECTOR));
	if (error)
		goto done;
	offset = DL_BLKOFFSET(lp, partoff + DOS_LABELSECTOR);

	dlp = (struct disklabel *)(bp->b_data + offset);
	*dlp = *lp;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_WRITE | B_RAW);
	(*strat)(bp);
	error = biowait(bp);

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}
@


1.32
log
@Restore validity checks for the disklabels read from disk. They
were suppressed in 2011 to address a problem that has since been
solved in a more permanent way. Without the validity check proper
disklabel discovery relied on a particular I/O failure, and the I/O
failure was 'solved' by the introduction of readdisksector().

Fixes problem reading CDROM disklabels discovered by mlarkin@@ while
trying to install hppa.

Compile check/typo discovery and ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.31 2015/09/28 15:17:08 krw Exp $	*/
d66 1
a66 1
	bp = geteblk((int)lp->d_secsize);
d213 1
a213 1
	bp = geteblk((int)lp->d_secsize);
@


1.31
log
@Mechanical changes from manual buf set up to readdisksector().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.30 2014/01/06 21:00:55 miod Exp $	*/
d196 2
a197 9
	/*
	 * Do OpenBSD disklabel validation/adjustment.
	 *
	 * N.B: No matter what the bits are on the disk, we now have the
	 * OpenBSD disklabel for this sgi disk. DO NOT proceed to
	 * readdoslabel(), iso_spooflabel(), etc.
	 */
	checkdisklabel(bp->b_data + offset, lp, fsoffs, fsend);
	return (0);
@


1.30
log
@In readsgilabel(), do not override the driver-provided initial geometry with
the volume header geometry, if one is found. The driver knows better.

This will allow a 2048-byte sector media to use a volume header using fake
512-byte sectors, and still be able to read the native label off it.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.29 2013/12/28 23:37:00 miod Exp $	*/
d116 1
a116 7
	int offset;

	bp->b_blkno = 0;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
d119 3
a121 2
	if (biowait(bp))
		return (bp->b_error);
d190 4
a193 2
	bp->b_blkno = DL_BLKTOSEC(lp, fsoffs + LABELSECTOR) *
	    DL_BLKSPERSEC(lp);
a194 6
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if (biowait(bp))
		return (bp->b_error);
d228 4
a231 2
	bp->b_blkno = DL_BLKTOSEC(lp, partoff + DOS_LABELSECTOR) *
	    DL_BLKSPERSEC(lp);
a232 6
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if ((error = biowait(bp)) != 0)
		goto done;
@


1.29
log
@The mips partition table in the volume header uses 512-byte logical units,
not sectors; don't multiply by the sector size to get the proper disk offsets.

This will let install.iso be built with the OpenBSD label at the expected
location, instead of within the ffs filesystem; we had been lucky enough the
area being overwritten was not in use so far.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.28 2013/10/23 11:19:32 deraadt Exp $	*/
a153 5
	DL_SETDSIZE(lp, (DL_GETDSIZE(lp)*lp->d_secsize) / dlp->dp.dp_secbytes);
	lp->d_secsize = dlp->dp.dp_secbytes;
	lp->d_nsectors = dlp->dp.dp_secs;
	lp->d_ntracks = dlp->dp.dp_trks0;
	lp->d_ncylinders = dlp->dp.dp_cyls;
@


1.28
log
@adapt to new DL_BLKTOSEC(); ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.27 2013/10/19 09:32:15 krw Exp $	*/
d137 2
a138 4
	fsoffs = (long long)dlp->partitions[0].first *
	    (dlp->dp.dp_secbytes / DEV_BSIZE);
	fsend = fsoffs + dlp->partitions[0].blocks *
	    (dlp->dp.dp_secbytes / DEV_BSIZE);
@


1.27
log
@Use daddr_t * instead of int * for the partoffp parameter to
readdoslabel(). Ditto all the MD variables whose addresses are passed
to readdoslabel() via partoffp.

Fix some 512-byte block vs disk sector confusion in hppa and sgi.
All the DL_GETxxxxx() defines return disk sector values. All
DL_SETxxxx() take disk sector values. These changes should be no-ops
until a drive using non-512-byte-sectors is encountered.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.26 2011/07/10 16:16:08 krw Exp $	*/
d182 2
a183 2
	DL_SETBSTART(lp, DL_BLKTOSEC(fsoffs));
	DL_SETBEND(lp, DL_BLKTOSEC(fsend));
d194 2
a195 2
		DL_SETBSTART(lp, DL_BLKTOSEC(fsoffs));
		DL_SETBEND(lp, DL_BLKTOSEC(fsend));
@


1.26
log
@Oops. Copy just the comment about the checkdisklabel() call, not
the checkdisklabel() calls themselves. What's good for hppa/hppa64
is not necessarily good for sgi/macppc.

Spotted by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.25 2011/07/10 04:49:39 krw Exp $	*/
d44 1
a44 1
	    struct disklabel *, int *, int);
d111 1
a111 1
    struct disklabel *lp, int *partoffp, int spoofonly)
d115 1
a115 2
	u_int64_t fsoffs = 0;
	u_int64_t fsend = DL_GETBEND(lp);
d128 3
d137 2
a138 1
	fsoffs = dlp->partitions[0].first * (dlp->dp.dp_secbytes / DEV_BSIZE);
d182 2
a183 2
	DL_SETBSTART(lp, fsoffs);
	DL_SETBEND(lp, fsend);
d194 2
a195 2
		DL_SETBSTART(lp, fsoffs);
		DL_SETBEND(lp, fsend);
d229 2
a230 1
	int error = EIO, partoff = -1;
@


1.25
log
@If there is recognized MD disk partitioning info, use it to determine
where to write the OpenBSD disklabel even if there isn't yet a valid
OpenBSD disklabel at that location.

Alpha/Mac68k/Sparc/Sparc64 to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.24 2011/07/08 00:08:00 krw Exp $	*/
d216 1
a216 2
	checkdisklabel(bp->b_data + LABELOFFSET, lp, openbsdstart,
	    DL_GETDSIZE(lp));
@


1.24
log
@When reading dos labels use DOS_LABELSECTOR and don't use LABELOFFSET. For all these
arch's LABELSECTOR == DOS_LABELSECTOR == 1, and LABELOFFSET == 0. Thus, to quote bob,
"This is a no-op". Makes the expression used when writing label the same as the one
used in readdoslabel().
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.23 2011/04/16 03:21:15 krw Exp $	*/
d209 10
a218 1
	return checkdisklabel(bp->b_data + offset, lp, fsoffs, fsend);
@


1.23
log
@Use 'CLR(<buf>->b_flags, B_READ | B_WRITE | B_DONE)' regardless of
what the previous IO was. Less chance of copy and paste errors.
Suggested by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.22 2011/04/15 14:57:29 krw Exp $	*/
d232 3
a234 2
	bp->b_blkno = DL_BLKTOSEC(lp, partoff+LABELSECTOR) * DL_BLKSPERSEC(lp);
	offset = DL_BLKOFFSET(lp, partoff + LABELSECTOR) + LABELOFFSET;
@


1.22
log
@In days of yore one could arbitrarily whack buffer flags. Those days
are past. Use CLR() and SET() to modify necessary flags while leaving
the flags used by the buffer cache in peace.

Should make bufcache code much less confused about the state of the
bufs used in reading/writing disklabels. Other such flag abuses no
doubt await a visit.

Errors in original diff found by miod@@.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.21 2011/04/06 13:46:50 miod Exp $	*/
d121 1
a121 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d203 1
a203 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d235 1
a235 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d243 1
a243 1
	CLR(bp->b_flags, B_READ | B_DONE);
@


1.21
log
@The various read*label() have stopped returning error strings for quite
some time, and return errnos instead. Fix or remove out-of-date comments
mentioning the error strings, and make their callers check the return value
against zero, not NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.20 2011/02/26 13:07:48 krw Exp $	*/
d121 2
a122 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d203 2
a204 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d235 2
a236 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d243 2
a244 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.20
log
@Force the DUID cache used to generate hw.disknames to be updated
after every disklabel read or write. This keeps the DUID cache more
in sync with the physical world. De-syncing noted by drahn@@ while
zapping disklabels with dd.

ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.19 2010/04/23 15:25:20 jsing Exp $	*/
a52 2
 *
 * Returns null on success and an error string on failure.
d225 2
a226 2
	if (readsgilabel(bp, strat, lp, &partoff, 1) != NULL &&
	    readdoslabel(bp, strat, lp, &partoff, 1) != NULL)
@


1.19
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.17 2009/08/13 15:23:11 deraadt Exp $	*/
d95 1
d251 1
@


1.18
log
@initialize the disk size instead of getting a random value (always 0) off
the stack.  this lets disklabels work on non-sgivol disks.
ok miod
@
text
@a157 1
	lp->d_interleave = dlp->dp.dp_interleave;
@


1.17
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.16 2009/06/14 00:09:39 deraadt Exp $	*/
d116 2
a117 2
	int fsoffs = 0;
	u_int fsend;
@


1.16
log
@Don't mess with the bounds in the lp if *partoffp is non-NULL, since this
indicates that writedisklabel is trying to find the location for writing
the label.  If the lp is messed with, an invalid checksum is written.
done with miod and kettenis, lots of moaning and gnashing of teeth, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.15 2009/06/05 09:12:25 deraadt Exp $	*/
d43 2
a44 2
char   *readsgilabel(struct buf *, void (*)(struct buf *),
    struct disklabel *, int *, int);
d56 1
a56 1
char *
d61 1
a61 1
	char *msg;
d63 1
a63 1
	if ((msg = initdisklabel(lp)))
d71 2
a72 2
	msg = readsgilabel(bp, strat, lp, NULL, spoofonly);
	if (msg == NULL)
d75 2
a76 2
	msg = readdoslabel(bp, strat, lp, NULL, spoofonly);
	if (msg == NULL)
d80 2
a81 2
	if (iso_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a82 1
	}
d85 2
a86 2
	if (udf_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a87 1
	}
d95 1
a95 1
	return (msg);
d110 1
a110 1
char *
a114 1
	char *msg = NULL;
d126 2
a127 4
	if (biowait(bp)) {
		msg = "disk label I/O error";
		goto done;
	}
d133 2
a134 4
	if (dlp->partitions[0].blocks == 0) {
		msg = "no BSD partition";
		goto done;
	}
d136 2
a137 1
	fsend = fsoffs + dlp->partitions[0].blocks * (dlp->dp.dp_secbytes / DEV_BSIZE);
d149 2
a150 4
	if (cs != 0) {
		msg = "sgilabel checksum error";
		goto done;
	}
d198 1
a198 1
		goto done;
d200 2
a201 1
	bp->b_blkno = DL_BLKTOSEC(lp, fsoffs + LABELSECTOR) * DL_BLKSPERSEC(lp);
d206 2
a207 4
	if (biowait(bp)) {
		msg = "disk label I/O error";
		goto done;
	}
a209 3

done:
	return (msg);
@


1.15
log
@use the right accounting for bound edges (i think)
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.14 2009/06/04 21:13:02 deraadt Exp $	*/
a122 3
	if (partoffp)
		*partoffp = fsoffs;

d145 1
a145 4
	/*
	 * If the disklabel is about to be written to disk, don't modify it!
	 * just bail out.
	 */
d196 9
@


1.14
log
@Recycle four ancient fields in the disklabel structure, replacing them with
bounds information, ie. the zone of the disk that OpenBSD can use.  Have each
pre-disklabel parser (MBR, DPME, or per-arch MD disklabel parsers) figure out
this area and pass it up to userland.  Then, delete all the same disk parsing
code from disklabel(8) since the kernel passes it up.  Lots and lots of - signs
in the disklabel(8) code.
Tested on as many platforms as possible, the fallout will be repaired as time
goes on.  To test, use disklabel -d <drive> and validate that the bounds do not
overlap any boot blocks.  This same information is used by disklabel -A...
OK for the concept from krw, miod, and drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.13 2009/05/28 17:05:50 miod Exp $	*/
d120 1
a120 1
	u_int fslen;
d146 1
a146 1
	fslen = dlp->partitions[0].blocks * (dlp->dp.dp_secbytes / DEV_BSIZE);
d194 2
a195 2
	DL_GETBSTART(lp, fsoffs);
	DL_GETBSIZE(lp, fsoffs + fslen);
d215 1
a215 1
	return checkdisklabel(bp->b_data + offset, lp, fsoffs, fsoffs + fslen);
@


1.13
log
@If readsgilabel() is invoked in spoofing mode, only report the whole device
and volume header partitions. This makes DIOCGPDINFO return correct results,
which in turn lets disklabel -A behave as intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.12 2009/05/13 01:31:58 krw Exp $	*/
d120 1
d146 1
d194 2
d215 1
a215 1
	return checkdisklabel(bp->b_data + offset, lp);
@


1.12
log
@Set D_VENDOR when spoofing a label on archs that use D_VENDOR when
reading the native disklabel. This ensures cylinder alignment.

Fix disklabel to do cylinder alignment arithmetic correctly in -A
mode. Worked by accident before, since the code was protected by
D_VENDOR, which wasn't being set.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.11 2008/09/01 16:28:50 krw Exp $	*/
d175 4
d184 2
a185 2
		lp->d_partitions[bsd].p_fstype = maptab[i].b;
		if (lp->d_partitions[bsd].p_fstype == FS_BSDFFS) {
@


1.11
log
@Bring comment into line with reality. We use sgi label info but don't
create just partitions 'i' -> 'l'. jsing@@ had noted same discord.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.10 2008/09/01 14:08:25 krw Exp $	*/
d65 1
@


1.10
log
@Allow sgi to spoof the native label. But don't spoof when just
looking for the place to write the disklabel, i.e. partoffp != NULL.

tested & ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.9 2008/08/08 23:49:53 krw Exp $	*/
d163 1
a163 1
	/* Set up partitions i-l if there is no BSD label. */
@


1.9
log
@Admit b_blkno means block number; a block is DEV_BSIZE (a.k.a.
512) bytes; ffs is inextricably tied to using b_blkno and disklabel
always uses sectorsize units.

Thus use DEV_BSIZE units for all fields describing ffs filesystems
and convert to/from sectors where required. This enables the creation
and use of ffs filesystems on non-512 byte sectorsize devices.

This diff allows i386 and sgi (the two test platforms) to find
disklabels that are not on a sectorsize boundary. Same change to
further archs coming.

This is a no-op on 512-byte sectorsize devices.

This work triggered by jsing@@'s need to create ffs filesystems on
sgi cdroms so we can create cdrom install media for sgi.

sgi testing by jsing@@

ok jsing@@ pedro@@ "looks sane" beck@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.8 2008/07/20 13:46:16 krw Exp $	*/
d121 3
d136 1
a136 2
	if (dlp->magic != htobe32(SGILABEL_MAGIC)) {
		fsoffs = 0;
a137 1
	}
d145 6
a150 1
	if (spoofonly)
d152 1
a192 3
	if (partoffp)
		*partoffp = fsoffs;

@


1.8
log
@Nuke unused readbsdlabel() function.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.7 2008/07/20 13:40:27 krw Exp $	*/
d119 1
d142 1
a142 1
	fsoffs = dlp->partitions[0].first;
d157 1
d192 2
a193 1
	bp->b_blkno = fsoffs + LABELSECTOR;
d202 1
a202 1
	return checkdisklabel(bp->b_data + LABELOFFSET, lp);
d215 1
d228 2
a229 1
	bp->b_blkno = partoff + LABELSECTOR;
d236 1
a236 1
	dlp = (struct disklabel *)(bp->b_data + LABELOFFSET);
@


1.7
log
@Use NULL instead of 0 for pointer parameters.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.6 2008/06/12 06:58:36 deraadt Exp $	*/
a42 2
char   *readbsdlabel(struct buf *, void (*)(struct buf *), int, int,
    int, struct disklabel *, int);
a44 24

/*
 * Try to read a standard BSD disklabel at a certain sector.
 */
char *
readbsdlabel(struct buf *bp, void (*strat)(struct buf *),
    int cyl, int sec, int off, struct disklabel *lp,
    int spoofonly)
{
	/* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
		return (NULL);

	bp->b_blkno = sec;
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ | B_RAW;
	(*strat)(bp);

	/* if successful, locate disk label within block and validate */
	if (biowait(bp))
		return ("disk label I/O error");

	return checkdisklabel(bp->b_data + LABELOFFSET, lp);
}
@


1.6
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.4 2008/06/10 20:50:23 beck Exp $	*/
d96 1
a96 1
	msg = readsgilabel(bp, strat, lp, 0, spoofonly);
d100 1
a100 1
	msg = readdoslabel(bp, strat, lp, 0, spoofonly);
@


1.5
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.3 2007/07/10 15:44:23 miod Exp $	*/
d62 1
a62 1
	bp->b_flags = B_BUSY | B_READ;
d148 1
a148 1
	bp->b_flags = B_BUSY | B_READ;
d218 1
a218 1
	bp->b_flags = B_BUSY | B_READ;
d252 1
a252 1
	bp->b_flags = B_BUSY | B_READ;
d259 1
a259 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.4
log
@Fix buffer cache pending read statistics by ensuring we can identify
biowait() reads that do *not* come from the buffer cache - we use the
B_RAW flag to identify these at art's suggestion - since it makes sense
and the flag was not being used. this just flags all these buffers with
B_RAW - biodone already ignores returned buffers marked B_RAW.
ok art@@
@
text
@d62 1
a62 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d148 1
a148 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d218 1
a218 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d252 1
a252 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d259 1
a259 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.3
log
@Don't brelse() a buf we don't own in readsgilabel() by mistake.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.2 2007/06/20 18:15:46 deraadt Exp $	*/
d62 1
a62 1
	bp->b_flags = B_BUSY | B_READ;
d148 1
a148 1
	bp->b_flags = B_BUSY | B_READ;
d218 1
a218 1
	bp->b_flags = B_BUSY | B_READ;
d252 1
a252 1
	bp->b_flags = B_BUSY | B_READ;
d259 1
a259 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.2
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.1 2007/06/18 21:46:41 deraadt Exp $	*/
a227 4
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
@


1.1
log
@this is the sgi disksubr, not some mythical "all mips64 architectures can use it" balony
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.61 2007/06/18 07:09:25 deraadt Exp $	*/
d46 1
a46 1
    struct disklabel *, struct cpu_disklabel *, int *, int *, int);
a60 1
	bp->b_cylinder = cyl;
d84 1
a84 1
    struct disklabel *lp, struct cpu_disklabel *osdep, int spoofonly)
d96 1
a96 1
	msg = readsgilabel(bp, strat, lp, osdep, 0, 0, spoofonly);
d100 1
a100 1
	msg = readdoslabel(bp, strat, lp, osdep, 0, 0, spoofonly);
d139 1
a139 2
    struct disklabel *lp, struct cpu_disklabel *osdep,
    int *partoffp, int *cylp, int spoofonly)
a146 1
	bp->b_cylinder = 0;
a216 1
	bp->b_cylinder = 0;
d239 1
a239 2
writedisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, struct cpu_disklabel *osdep)
d241 1
a241 1
	int error = EIO, partoff = -1, cyl = 0;
d249 2
a250 2
	if (readsgilabel(bp, strat, lp, osdep, &partoff, &cyl, 1) != NULL &&
	    readdoslabel(bp, strat, lp, osdep, &partoff, &cyl, 1) != NULL)
a254 1
	bp->b_cylinder = cyl;
@

