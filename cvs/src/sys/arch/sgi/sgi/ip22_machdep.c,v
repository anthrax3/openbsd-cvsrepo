head	1.22;
access;
symbols
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.8
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.14.0.8
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.12.0.2
	OPENBSD_5_2_BASE:1.12;
locks; strict;
comment	@ * @;


1.22
date	2016.10.09.11.25.40;	author tom;	state Exp;
branches;
next	1.21;
commitid	DfYvEDcFmu1LY9q1;

1.21
date	2015.09.05.21.14.07;	author miod;	state Exp;
branches;
next	1.20;
commitid	tejzV6F0u2CEtvy0;

1.20
date	2014.07.17.19.51.58;	author miod;	state Exp;
branches;
next	1.19;
commitid	o86FcMSRojJgDsY0;

1.19
date	2014.07.02.17.44.35;	author miod;	state Exp;
branches;
next	1.18;
commitid	TjYmL9K0bGKNWIOi;

1.18
date	2014.05.19.21.18.42;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.03.08.07.16;	author mpi;	state Exp;
branches;
next	1.16;

1.16
date	2014.03.23.00.00.32;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2014.03.09.10.12.17;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2012.09.29.21.46.02;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2012.09.29.18.54.39;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2012.06.24.20.29.46;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2012.05.27.19.13.04;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2012.05.27.14.27.10;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2012.05.27.14.13.00;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2012.05.15.18.17.50;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2012.05.12.16.48.27;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2012.04.16.22.28.14;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2012.04.15.20.39.36;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2012.04.15.20.38.10;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2012.04.06.19.00.49;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2012.04.03.21.17.35;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2012.03.28.20.44.23;	author miod;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Apply consistency to forever loops with continue and NOTREACHED

Same thought from kettenis@@, ok krw@@ phessler@@ millert@@
@
text
@/*	$OpenBSD: ip22_machdep.c,v 1.21 2015/09/05 21:14:07 miod Exp $	*/

/*
 * Copyright (c) 2012 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Specific routines for IP20/22/24/26/28 systems. Yet another case of a
 * file which name no longer matches its original purpose.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/buf.h>
#include <sys/mount.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/memconf.h>

#include <mips64/arcbios.h>
#include <mips64/archtype.h>

#include <sgi/sgi/ip22.h>
#include <sgi/localbus/imcreg.h>
#include <sgi/localbus/imcvar.h>
#include <sgi/hpc/hpcreg.h>
#include <sgi/hpc/iocreg.h>

#include "gio.h"
#include "tcc.h"

#if NGIO > 0
#include <sgi/gio/gioreg.h>
#include <sgi/gio/giovar.h>
#include <sgi/gio/lightreg.h>
#endif
#if NTCC > 0
#include <sgi/localbus/tccreg.h>
#include <sgi/localbus/tccvar.h>
#endif

extern char *hw_prod;

int	hpc_old = 0;
int	bios_year;
int	ip22_ecc = 0;

void	(*ip22_extsync)(struct cpu_info *, paddr_t, size_t, int);

void	ip22_arcbios_walk(void);
int	ip22_arcbios_walk_component(arc_config_t *);
void	ip22_cache_halt(int);
void	ip22_cache_sync(struct cpu_info *, paddr_t, size_t, int);
void	ip22_ecc_halt(int);
void	ip22_ecc_init(int);
void	ip22_fast_mode(void);
void	ip22_memory_setup(void);
void	ip22_slow_mode(void);
void	ip22_video_setup(void);

/*
 * Walk the ARCBios component tree to get hardware information we can't
 * obtain by other means.
 */

#define	IP22_HAS_L2		0x01
#define	IP22_HAS_AUDIO		0x02
#define	IP22_HAS_ENOUGH_FB	0x04
static int ip22_arcwalk_results = 0;

#if NGIO > 0
static char ip22_fb_names[GIO_MAX_FB][64];
#endif

int
ip22_arcbios_walk_component(arc_config_t *cf)
{
	struct cpu_info *ci = curcpu();
	arc_config_t *child;
	arc_config64_t *cf64 = (arc_config64_t *)cf;
#if NGIO > 0
	static int fbidx = 0;
#endif

	/*
	 * Split secondary caches are not supported.
	 * No IP22 processor module uses them anyway.
	 */
	if (cf->class == arc_CacheClass && cf->type == arc_SecondaryCache) {
		uint64_t key;

		if (bios_is_32bit)
			key = cf->key;
		else
			key = cf64->key >> 32;

		/*
		 * Secondary cache information is encoded as WWLLSSSS, where
		 * WW is the number of ways
		 *   (should be 01)
		 * LL is Log2(line size)
		 *   (should be 04 or 05 for IP20/IP22/IP24, 07 for IP26)
		 * SS is Log2(cache size in 4KB units)
		 *   (should be between 0007 and 0009)
		 */
		ci->ci_l2.size = (1 << 12) << (key & 0x0000ffff);
		ci->ci_l2.linesize = 1 << ((key >> 16) & 0xff);
		ci->ci_l2.sets = (key >> 24) & 0xff;
		ci->ci_l2.setsize = ci->ci_l2.size / ci->ci_l2.sets;

		ip22_arcwalk_results |= IP22_HAS_L2;
	}

	if (cf->class == arc_ControllerClass &&
	    cf->type == arc_AudioController) {
		ip22_arcwalk_results |= IP22_HAS_AUDIO;
	}

#if NGIO > 0
	if (cf->class == arc_ControllerClass &&
	    cf->type == arc_DisplayController) {
		if (fbidx >= GIO_MAX_FB) {
			/*
			 * Not worth printing a message. If the system is
			 * configured for glass console, it will get
			 * overwritten anyway.
			 */
			ip22_arcwalk_results |= IP22_HAS_ENOUGH_FB;
		} else {
			const char *id;
			size_t idlen;

			if (bios_is_32bit) {
				idlen = cf->id_len;
				id = (const char *)(vaddr_t)cf->id;
			} else {
				idlen = cf64->id_len;
				id = (const char *)cf64->id;
			}
			if (idlen != 0) {
				/* skip leading spaces */
				while (idlen > 0 && id[0] == ' ') {
					id++;
					idlen--;
				}
				/* skip SGI- prefix */
				if (idlen >= 4 && strncmp(id, "SGI-", 4) == 0) {
					id += 4;
					idlen -= 4;
				}
				if (idlen >= sizeof(ip22_fb_names[0]))
					idlen = sizeof(ip22_fb_names[0]) - 1;
				bcopy(id, ip22_fb_names[fbidx], idlen);
			}
			giofb_names[fbidx] = ip22_fb_names[fbidx];
			fbidx++;
		}
	}
#endif

	if (ip22_arcwalk_results ==
	    (IP22_HAS_L2 | IP22_HAS_AUDIO | IP22_HAS_ENOUGH_FB))
		return 0;	/* abort walk */

	for (child = (arc_config_t *)Bios_GetChild(cf); child != NULL;
	    child = (arc_config_t *)Bios_GetPeer(child)) {
		if (ip22_arcbios_walk_component(child) == 0)
			return 0;
	}

	return 1;	/* continue walk */
}

void
ip22_arcbios_walk()
{
#if NGIO == 0
	ip22_arcwalk_results |= IP22_HAS_ENOUGH_FB;
#endif
	(void)ip22_arcbios_walk_component((arc_config_t *)Bios_GetChild(NULL));
}

/*
 * Parse memory controller settings.
 */

#define	IMC_NREGION	3

void
ip22_memory_setup()
{
	uint i, bank, shift;
	uint32_t memc0, memc1;
	uint32_t memc;
	paddr_t base[IMC_NREGION], size[IMC_NREGION], limit;
	paddr_t start0, end0, start1, end1;
	struct phys_mem_desc *mem;

	/*
	 * Figure out the top of memory, as reported by ARCBios.
	 */

	limit = 0;
	for (i = 0, mem = mem_layout; i < MAXMEMSEGS; i++, mem++) {
		if (mem->mem_last_page > limit)
			limit = mem->mem_last_page;
	}
	limit = ptoa(limit);

	/*
	 * Figure out where the memory controller has put memory.
	 */

	memc0 = imc_read(IMC_MEMCFG0);
	memc1 = imc_read(IMC_MEMCFG1);

	/* Revision D onwards uses larger units, to allow for more memory */
	if ((imc_read(IMC_SYSID) & IMC_SYSID_REVMASK) >= 5)
		shift = IMC_MEMC_LSHIFT_HUGE;
	else
		shift = IMC_MEMC_LSHIFT;

	for (bank = 0; bank < IMC_NREGION; bank++) {
		memc = (bank & 2) ? memc1 : memc0;
		if ((bank & 1) == 0)
			memc >>= IMC_MEMC_BANK_SHIFT;
		memc &= IMC_MEMC_BANK_MASK;

		if ((memc & IMC_MEMC_VALID) == 0) {
			base[bank] = size[bank] = 0;
			continue;
		}

		base[bank] = (memc & IMC_MEMC_ADDR_MASK) >> IMC_MEMC_ADDR_SHIFT;
		base[bank] <<= shift;

		size[bank] = (memc & IMC_MEMC_SIZE_MASK) >> IMC_MEMC_SIZE_SHIFT;
		size[bank]++;
		size[bank] <<= shift;
	}

	/*
	 * Perform sanity checks on the above data..
	 */

	/* memory should not start below 128MB */
	for (bank = 0; bank < IMC_NREGION; bank++)
		if (size[bank] != 0 && base[bank] < (1ULL << 27))
			goto dopanic;

	/* banks should not overlap */
	for (bank = 1; bank < IMC_NREGION; bank++) {
		if (size[bank] == 0)
			continue;
		start0 = base[bank];
		end0 = base[bank] + size[bank];
		for (i = 0; i < bank; i++) {
			if (size[i] == 0)
				continue;
			start1 = base[i];
			end1 = base[i] + size[i];
			if (end0 > start1 && start0 < end1)
				goto dopanic;
		}
	}

	/*
	 * Now register all the memory beyond what ARCBios stopped at.
	 */

	for (bank = 0; bank < IMC_NREGION; bank++) {
		if (size[bank] == 0)
			continue;

		start0 = base[bank];
		end0 = base[bank] + size[bank];
		if (end0 <= limit)
			continue;

		if (start0 < limit)
			start0 = limit;

		memrange_register(atop(start0), atop(end0), 0);
	}

	return;

dopanic:
	bios_printf("** UNEXPECTED MEMORY CONFIGURATION **\n");
	bios_printf("MEMC0 %08x MEMC1 %08x\n", memc0, memc1);
	bios_printf("Please contact <sgi@@openbsd.org>\n"
	    "Halting system.\n");
	Bios_Halt();
	for (;;)
		continue;
	/* NOTREACHED */
}

void
ip22_video_setup()
{
#if NGIO > 0
	/*
	 * According to Linux, the base address of the console device,
	 * if there is a glass console, can be obtained by invoking the
	 * 8th function pointer of the vendor-specific vector table.
	 *
	 * This function returns a pointer to a list of addresses (or
	 * whatever struct it is), which second field is the address we
	 * are looking for.
	 *
	 * However, the address does not point to the base address of the
	 * slot the frame buffer, but to some registers in it. While this
	 * might help identifying the actual frame buffer type, at the
	 * moment we are only interested in the base address.
	 */

	long (*get_gfxinfo)(void);
	vaddr_t fbaddr;
	paddr_t fbphys;

	if (bios_is_32bit) {
		int32_t *vec, *addr;

		vec = (int32_t *)(int64_t)(int32_t)ArcBiosBase32->vendor_vect;
		get_gfxinfo = (long (*)(void))(int64_t)vec[8];
		addr = (int32_t *)(int64_t)(*get_gfxinfo)();
		fbaddr = addr[1];
	} else {
		int64_t *vec, *addr;

		vec = (int64_t *)ArcBiosBase64->vendor_vect;
		get_gfxinfo = (long (*)(void))vec[8];
		addr = (int64_t *)(*get_gfxinfo)();
		fbaddr = addr[1];
	}

	if (fbaddr >= CKSEG1_BASE && fbaddr < CKSSEG_BASE)
		fbphys = CKSEG1_TO_PHYS(fbaddr);
	else if (IS_XKPHYS(fbaddr))
		fbphys = XKPHYS_TO_PHYS(fbaddr);
	else
		return;

	if (!IS_GIO_ADDRESS(fbphys))
		return;

	/*
	 * Try to convert the address to a slot base or, for light(4)
	 * frame buffers, a frame buffer base.
	 *
	 * Verified addresses:
	 * grtwo	slot + 0x00000000
	 * impact	slot + 0x00000000
	 * light	slot + 0x003f0000 (LIGHT_ADDR_0)
	 * newport	slot + 0x000f0000 (NEWPORT_REX3_OFFSET)
	 */

	/* light(4) only exists on IP20 */
	if (sys_config.system_type == SGI_IP20) {
		paddr_t tmp = fbphys & ~((paddr_t)LIGHT_SIZE - 1);
		if (tmp == LIGHT_ADDR_0 || tmp == LIGHT_ADDR_1) {
			giofb_consaddr = tmp;
			return;
		}
	}

	if (fbphys < GIO_ADDR_EXP0)
		giofb_consaddr = GIO_ADDR_GFX;
	else if (fbphys < GIO_ADDR_EXP1)
		giofb_consaddr = GIO_ADDR_EXP0;
	else
		giofb_consaddr = GIO_ADDR_EXP1;
#endif
}

void
ip22_setup()
{
	u_long cpuspeed;
	uint8_t ip22_sysid;

	/*
	 * Get CPU information.
	 */
	bootcpu_hwinfo.c0prid = cp0_get_prid();
	bootcpu_hwinfo.c1prid = cp1_get_prid();
	cpuspeed = bios_getenvint("cpufreq");
	if (sys_config.system_type == SGI_IP20)
		cpuspeed <<= 1;
	switch (sys_config.system_type) {
	default:
		if (cpuspeed < 100)
			cpuspeed = 100;		/* reasonable default */
		break;
	case SGI_IP26:
		if (cpuspeed < 70)
			cpuspeed = 75;		/* reasonable default */
		break;
	}
	bootcpu_hwinfo.clock = cpuspeed * 1000000;
	bootcpu_hwinfo.type = (bootcpu_hwinfo.c0prid >> 8) & 0xff;

	switch (sys_config.system_type) {
	case SGI_IP20:
		ip22_sysid = 0;
		break;
	default:
	case SGI_IP22:
	case SGI_IP26:
	case SGI_IP28:
		ip22_sysid = (uint8_t)*(volatile uint32_t *)
		    PHYS_TO_XKPHYS(HPC_BASE_ADDRESS_0 + IOC_BASE + IOC_SYSID,
		      CCA_NC);
		break;
	}

	/*
	 * Scan ARCBios component list for useful information (L2 cache
	 * configuration, audio device availability)
	 */
	ip22_arcbios_walk();

	/*
	 * Figure out what critter we are running on.
	 */
	switch (sys_config.system_type) {
	case SGI_IP20:
		if (ip22_arcwalk_results & IP22_HAS_AUDIO)
			hw_prod = "Indigo";
		else
			hw_prod = "VME Indigo";
		break;
	case SGI_IP22:
		if (ip22_sysid & 0x01) {
			sys_config.system_subtype = IP22_INDIGO2;
			hw_prod = "Indigo2";
		} else {
			if (ip22_arcwalk_results & IP22_HAS_AUDIO) {
				sys_config.system_subtype = IP22_INDY;
				hw_prod = "Indy";
			} else {
				sys_config.system_subtype = IP22_CHALLS;
				hw_prod = "Challenge S";
			}
		}
		break;
	case SGI_IP26:
		sys_config.system_subtype = IP22_INDIGO2;
		hw_prod = "POWER Indigo2 R8000";
		break;
	case SGI_IP28:
		sys_config.system_subtype = IP22_INDIGO2;
		hw_prod = "POWER Indigo2 R10000";
		break;
	}

	/*
	 * Figure out whether we are running on an Indigo2 system with the
	 * ECC board.
	 */

	switch (sys_config.system_type) {
	default:
		break;
	case SGI_IP26:
		/*
		 * According to IRIX <sys/IP22.h>, earlier IP26 systems
		 * have an incomplete ECC board, and thus run in parity
		 * mode.
		 */
		if (((ip22_sysid & IOC_SYSID_BOARDREV) >>
		     IOC_SYSID_BOARDREV_SHIFT) >=
		    (0x18 >> IOC_SYSID_BOARDREV_SHIFT))
			ip22_ecc = 1;
		break;
	case SGI_IP28:
		/* All IP28 systems use the ECC board */
		ip22_ecc = 1;
		break;
	}

	if (ip22_ecc) {
		ip22_ecc_init(sys_config.system_type);
		md_halt = ip22_ecc_halt;
	}

	/*
	 * Figure out how many TLB entries are available.
	 */
	switch (bootcpu_hwinfo.type) {
	default:
#if defined(CPU_R4000) || defined(CPU_R4600) || defined(CPU_R5000)
	case MIPS_R4000:
	case MIPS_R4600:
	case MIPS_R5000:
		bootcpu_hwinfo.tlbsize = 48;
		break;
#endif
#ifdef CPU_R8000
	case MIPS_R8000:
		bootcpu_hwinfo.tlbsize = 128 * 3;
		break;
#endif
#ifdef CPU_R10000
	case MIPS_R10000:
		bootcpu_hwinfo.tlbsize = 64;
		break;
#endif
	}

	/*
	 * Compute memory layout. ARCBios may not report all memory (on
	 * Indigo, it seems to only report up to 128MB, and on Indigo2,
	 * up to 256MB).
	 */
	ip22_memory_setup();

	/*
	 * Get glass console information, if necessary.
	 */
	ip22_video_setup();

	/*
	 * Register DMA-reachable memory constraints.
	 * hpc(4) revision 1 and 1.5 only use 28-bit address pointers, thus
	 * only 256MB are addressable; unfortunately, since physical memory
	 * starts at 128MB, this enforces a 128MB limit.
	 *
	 * The following logic is pessimistic, as IP24 (Indy) systems have
	 * a revision 3 hpc(4) onboard, but will accept older revisions in
	 * expansion boards.
	 */
	switch (sys_config.system_type) {
	default:
#if defined(TGT_INDY) || defined(TGT_INDIGO2)
		dma_constraint.ucr_low = 0;
		dma_constraint.ucr_high = (1UL << 32) - 1;
		if (sys_config.system_subtype == IP22_INDIGO2)
			break;
		/* FALLTHROUGH */
#endif
	case SGI_IP20:
		dma_constraint.ucr_low = 0;
		dma_constraint.ucr_high = (1UL << 28) - 1;
		break;
	}

	/*
	 * Get ARCBios' current time.
	 */
	bios_year = Bios_GetTime()->Year;

	_device_register = arcs_device_register;
}

void
ip22_post_autoconf()
{
	/*
	 * Clear any pending bus error caused by the device probes.
	 */
#if NTCC > 0
	if (sys_config.system_type == SGI_IP26)
		tcc_bus_reset();
#endif
	imc_bus_reset();

	/*
	 * Relax DMA-reachable memory constraints if no 28-bit hpc(4)
	 * device has attached.
	 */
	if (hpc_old == 0) {
		uint64_t dmapages_before, dmapages;

		dmapages_before = uvm_pagecount(&dma_constraint);
		dma_constraint.ucr_high = (1UL << 32) - 1;
		dmapages = uvm_pagecount(&dma_constraint);
		if (dmapages_before != dmapages) {
			bufadjust(bufcachepercent * dmapages / 100);
			bufhighpages = bufpages;
		}
	}

	if (ip22_ecc) {
		ip22_fast_mode();
	}
}

/*
 * ECC board specific routines
 */

#define ecc_write(o,v) \
	*(volatile uint64_t *)PHYS_TO_XKPHYS(ECC_BASE + (o), CCA_NC) = (v)

static __inline__ uint32_t ip22_ecc_map(void);
static __inline__ void ip22_ecc_unmap(uint32_t);

static int ip22_ecc_mode;	/* 0 if slow mode, 1 if fast mode */

static __inline__ uint32_t
ip22_ecc_map()
{
	register uint32_t omemc1, nmemc1;

	omemc1 = imc_read(IMC_MEMCFG1);
	nmemc1 = omemc1 & ~IMC_MEMC_BANK_MASK;
	nmemc1 |= IMC_MEMC_VALID | (ECC_BASE >> IMC_MEMC_LSHIFT_HUGE);
	imc_write(IMC_MEMCFG1, nmemc1);
	(void)imc_read(IMC_MEMCFG1);
	mips_sync();

	return omemc1;
}

static __inline__ void
ip22_ecc_unmap(uint32_t omemc1)
{
	imc_write(IMC_MEMCFG1, omemc1);
	(void)imc_read(IMC_MEMCFG1);
	mips_sync();
}

void
ip22_fast_mode()
{
	register uint32_t memc1;

	if (ip22_ecc_mode == 0) {
		memc1 = ip22_ecc_map();
		ecc_write(ECC_CTRL, ECC_CTRL_ENABLE);
		mips_sync();
		(void)imc_read(IMC_MEMCFG1);
		imc_write(IMC_CPU_MEMACC, imc_read(IMC_CPU_MEMACC) & ~2);
		ip22_ecc_unmap(memc1);
		ip22_ecc_mode = 1;
#if NTCC > 0
		/* if (sys_config.system_type == SGI_IP26) */
			tcc_prefetch_enable();
#endif
	}
}

void
ip22_slow_mode()
{
	register uint32_t memc1;

	if (ip22_ecc_mode != 0) {
#if NTCC > 0
		/* if (sys_config.system_type == SGI_IP26) */
			tcc_prefetch_disable();
#endif
		memc1 = ip22_ecc_map();
		imc_write(IMC_CPU_MEMACC, imc_read(IMC_CPU_MEMACC) | 2);
		ecc_write(ECC_CTRL, ECC_CTRL_DISABLE);
		mips_sync();
		(void)imc_read(IMC_MEMCFG1);
		ip22_ecc_unmap(memc1);
		ip22_ecc_mode = 0;
	}
}

void
ip22_ecc_init(int system_type)
{
	uint32_t memc1;

	/* setup slow mode */
	memc1 = ip22_ecc_map();
	imc_write(IMC_CPU_MEMACC, imc_read(IMC_CPU_MEMACC) | 2);
	ecc_write(ECC_CTRL, ECC_CTRL_DISABLE);
	mips_sync();
	(void)imc_read(IMC_MEMCFG1);
	/* clear pending errors, if any */
	ecc_write(ECC_CTRL, ECC_CTRL_INT_CLR);
	mips_sync();
	(void)imc_read(IMC_MEMCFG1);

	if (system_type == SGI_IP28) {
		ecc_write(ECC_CTRL, ECC_CTRL_CHK_DISABLE); /* XXX for now */
		mips_sync();
		(void)imc_read(IMC_MEMCFG1);
	}

	ip22_ecc_unmap(memc1);
	ip22_ecc_mode = 0;
}

void
ip22_ecc_halt(int howto)
{
	ip22_slow_mode();
	arcbios_halt(howto);
}

#if (defined(TGT_INDY) || defined(TGT_INDIGO2)) && \
    (defined(CPU_R4600) || defined(CPU_R5000))

/*
 * Cache routines for the secondary cache found on R4600SC and R5000SC
 * systems.
 */

#include <mips64/cache.h>
CACHE_PROTOS(ip22)

#define	IP22_L2_LINE		32UL
#define	IP22_CACHE_TAG_ADDRESS	0x80000000UL

static inline void ip22_l2_disable(void)
{
	/* halfword write: disable entire cache */
	*(volatile uint16_t *)(PHYS_TO_XKPHYS(IP22_CACHE_TAG_ADDRESS, CCA_NC)) =
	    0;
}
static inline void ip22_l2_enable(void)
{
	/* byte write: enable entire cache */
	*(volatile uint8_t *)(PHYS_TO_XKPHYS(IP22_CACHE_TAG_ADDRESS, CCA_NC)) =
	    0;
}

void
ip22_cache_halt(int howto)
{
	ip22_l2_disable();
	arcbios_halt(howto);
}

void
ip22_ConfigCache(struct cpu_info *ci)
{
	struct cache_info l2;

	/*
	 * Note that we are relying upon machdep.c only invoking us if we
	 * are running on an R4600 or R5000 system.
	 */
	if ((ip22_arcwalk_results & IP22_HAS_L2) == 0) {
		Mips5k_ConfigCache(ci);
		return;
	}

	l2 = ci->ci_l2;

	Mips5k_ConfigCache(ci);

	if (l2.linesize != IP22_L2_LINE || l2.sets != 1) {
		/*
		 * This should not happen. Better not try and tame an
		 * unknown beast.
		 */
		return;
	}

	ci->ci_l2 = l2;

	ci->ci_SyncCache = ip22_SyncCache;
	ip22_extsync = ip22_cache_sync;

	md_halt = ip22_cache_halt;
	ip22_l2_enable();
}

void
ip22_SyncCache(struct cpu_info *ci)
{
	vaddr_t sva, eva;

	Mips5k_SyncCache(ci);

	sva = PHYS_TO_XKPHYS(IP22_CACHE_TAG_ADDRESS, CCA_NC);
	eva = sva + ci->ci_l2.size;

	while (sva < eva) {
		*(volatile uint32_t *)sva = 0;
		sva += IP22_L2_LINE;
	}
}

void
ip22_cache_sync(struct cpu_info *ci, paddr_t _pa, size_t _sz, int how)
{
	size_t sz;
	paddr_t pa, tagbase;

	switch (how) {
	default:
	case CACHE_SYNC_W:
		break;
	case CACHE_SYNC_X:
	case CACHE_SYNC_R:
		/* extend the range to integral cache lines */
		pa = _pa & ~(IP22_L2_LINE - 1);
		sz = ((_pa + _sz + IP22_L2_LINE - 1) & ~(IP22_L2_LINE - 1)) -
		    pa;

		pa &= ci->ci_l2.size - 1;
		tagbase = PHYS_TO_XKPHYS(IP22_CACHE_TAG_ADDRESS, CCA_NC);

		while (sz != 0) {
			/* word write: invalidate line */
			*(volatile uint32_t *)(tagbase | pa) = 0;

			pa += IP22_L2_LINE;
			pa &= ci->ci_l2.size - 1;
			sz -= IP22_L2_LINE;
		}
		break;
	}
}

#endif
@


1.21
log
@Do not make ip22_{slow,fast}_mode() public anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.20 2014/07/17 19:51:58 miod Exp $	*/
d311 3
a313 1
	for (;;) ;
@


1.20
log
@Rework management of the external L2 cache on the few Indy/Indigo2 systems
which have it.

Instead of implementing external L2 maintainance at the cache routine level,
let bus_dmamap_sync(9) know about the possible existence of an external L2,
and invoke a dedicated routine to perform the necessary cache operations.

This way, the external L2 dmamap_sync function pointer can get invoked with
the physical address to operate on; this saves the pmap_extract() calls the
previous cache routine had to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.19 2014/07/02 17:44:35 miod Exp $	*/
d73 1
d75 1
d640 1
a640 1
int
a656 1
		return 0;
a657 2

	return 1;
d660 1
a660 1
int
a676 1
		return 1;
a677 8

	return 0;
}

int
ip22_restore_mode(int mode)
{
	return mode ? ip22_fast_mode() : ip22_slow_mode();
@


1.19
log
@On IP28, ignore (as in, do not report) GIO bus errors where the address isn't
actually part of the GIO address range; these obviously come from speculative
R10000 execution and are completely harmless (except for the need to acknowledge
them, which we have to do anyway).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.18 2014/05/19 21:18:42 miod Exp $	*/
d65 2
d70 1
d786 1
a786 1
	ci->ci_IOSyncDCache = ip22_IOSyncDCache;
d809 1
a809 1
ip22_IOSyncDCache(struct cpu_info *ci, vaddr_t _va, size_t _sz, int how)
a810 1
	vaddr_t va;
d812 1
a812 4
	paddr_t pa;

	/* do whatever L1 work is necessary */
	Mips5k_IOSyncDCache(ci, _va, _sz, how);
d821 6
a826 3
		va = _va & ~(IP22_L2_LINE - 1);
		sz = ((_va + _sz + IP22_L2_LINE - 1) & ~(IP22_L2_LINE - 1)) -
		    va;
d829 2
a830 9
			/* get the proper physical address */
			if (pmap_extract(pmap_kernel(), va, &pa) == 0) {
#ifdef DIAGNOSTIC
				panic("%s: invalid va %p",
				    __func__, (void *)va);
#else
				/* should not happen */
#endif
			}
d832 1
d834 1
a834 12
			pa |= PHYS_TO_XKPHYS(IP22_CACHE_TAG_ADDRESS, CCA_NC);

			while (sz != 0) {
				/* word write: invalidate line */
				*(volatile uint32_t *)pa = 0;

				pa += IP22_L2_LINE;
				va += IP22_L2_LINE;
				sz -= IP22_L2_LINE;
				if ((va & PAGE_MASK) == 0)
					break;	/* need pmap_extract() */
			}
@


1.18
log
@Format string fixes and removal of -Wno-format for sgi. Based upon an
initial diff from jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.17 2014/04/03 08:07:16 mpi Exp $	*/
d355 1
a355 1
	if (fbphys < GIO_ADDR_GFX || fbphys >= GIO_ADDR_END)
@


1.17
log
@Moar <uvm/uvm.h> -> <uvm/uvm_extern.h> love.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.16 2014/03/23 00:00:32 miod Exp $	*/
d830 2
a831 1
				panic("%s: invalid va %p", __func__, va);
@


1.16
log
@Repair R5000SC and R4600SC external L2 cache setup, broken in previous
revision.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.15 2014/03/09 10:12:17 miod Exp $	*/
d30 1
a30 1
#include <uvm/uvm.h>
@


1.15
log
@Rework the per-cpu cache information. Use a common struct to store the line
size, the number of sets, and the total size (and the set size, for convenience)
per cache (I$, D$, L2, L3).
This allows cpu.c to print the number of ways (sets) of L2 and L3 caches from
the cache information, rather than hardcoding this from the processor type.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.14 2012/09/29 21:46:02 miod Exp $	*/
d120 2
a121 2
		ci->ci_l2.setsize = ci->ci_l2.size;
		ci->ci_l2.sets = 1;
d365 1
a365 1
	 * light	?
d772 1
a772 1
	if (ci->ci_l2.linesize != IP22_L2_LINE) {
@


1.14
log
@Work in progress support for the Power Indigo2 R8000 system (IP26). This is
basically an IP22 system (R4000 Indigo2) with the ECC memory board of IP28,
and a so-called ``streaming'' L2 cache.

IP26 kernels currently boot single-user, but don't live long; I am suspecting
a bug in the tcc cache routines, but am currently not able to find it (come
to think of it, my understanding of how this cache works could be wrong, and
of course there is no documentation for it but what can be gathered from
IRIX' <sys/IP26.h> comments and defines).

Hopefully this situation will improve in the near future; in the meantime I
am commiting this as `work in progress' to make sure this code doesn't get
lost.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.13 2012/09/29 18:54:39 miod Exp $	*/
d118 4
a121 2
		ci->ci_l2size = (1 << 12) << (key & 0x0000ffff);
		ci->ci_l2line = 1 << ((key >> 16) & 0xff);
d757 1
a757 1
	uint l2line, l2size;
d768 1
a768 2
	l2line = ci->ci_l2line;
	l2size = ci->ci_l2size;
d772 1
a772 1
	if (l2line != IP22_L2_LINE) {
d780 1
a780 2
	ci->ci_l2line = l2line;
	ci->ci_l2size = l2size;
d797 1
a797 1
	eva = sva + ci->ci_l2size;
d836 1
a836 1
			pa &= ci->ci_l2size - 1;
@


1.13
log
@Proide a mips_sync() macro to wrap asm("sync"), and replace gazillions of
such statements with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.12 2012/06/24 20:29:46 miod Exp $	*/
d19 5
d30 1
a30 1
#include <uvm/uvm_extern.h>
a39 2
#include <uvm/uvm.h>

d47 1
d54 4
d69 1
a69 1
void	ip22_ecc_init(void);
d107 1
a107 1
			key = cf64->key;
d111 6
a116 3
		 * WW is the number of ways (should be 01)
		 * LL is Log2(line size) (should be 04 or 05)
		 * SS is Log2(cache size in 4KB units) (should be 0007)
d399 10
a408 2
	if (cpuspeed < 100)
		cpuspeed = 100;		/* reasonable default */
d492 1
a492 1
		ip22_ecc_init();
d500 13
a517 3
	default:	/* R4x00, R5000 */
		bootcpu_hwinfo.tlbsize = 48;
		break;
d544 1
d550 1
d569 9
d613 1
a613 1
	uint32_t omemc1, nmemc1;
d636 1
a636 1
	uint32_t memc1;
d646 4
d659 1
a659 1
	uint32_t memc1;
d662 4
d686 1
a686 1
ip22_ecc_init()
d690 1
d696 1
d700 7
a706 3
	ecc_write(ECC_CTRL, ECC_CTRL_CHK_DISABLE);	/* XXX for now */
	mips_sync();
	(void)imc_read(IMC_MEMCFG1);
@


1.12
log
@Code for the external L2 cache controller on Indy/Indigo2 R4600SC and Indy
R5000SC processor modules; these sport an up to 512KB, physically indexed,
write-through L2 cache which is not connected to the canonical external cache
interface of these processors (hence requiring specific code to drive it).
The cache is enabled early and disabled before returning to ARCBios (for very
nasty things happen otherwise).

Tested on R5000SC, will be tested on R4600SC soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.11 2012/05/27 19:13:04 miod Exp $	*/
a561 3
#define	sync() \
    __asm__ __volatile__ ("sync" ::: "memory");

d580 1
a580 1
	sync();
d590 1
a590 1
	sync();
d601 1
a601 1
		sync();
d621 1
a621 1
		sync();
d645 1
a645 1
	sync();
d648 1
a648 1
	sync();
d651 1
a651 1
	sync();
@


1.11
log
@Add a `L2 cache line size' member to struct cpu_info. This allows R4k code to
stop abusing another field, and will be used by more routines RSN.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.10 2012/05/27 14:27:10 miod Exp $	*/
d59 1
d666 138
@


1.10
log
@Proper support for the so-called `fast mode' of the Indigo2 ECC memory
controller. In this mode, access to physical memory are not allowed to
bypass the cache, and this allows the memory subsystem to run faster.

Of course, some device drivers will require uncached memory access (e.g.
for proper HPC DMA descriptor operation).

New ip22-specific functions to switch between `fast mode' and `slow mode'
are introduced.

hpc(4) now provides read and write routines to fetch a dma descriptor from
uncached memory into a local copy, and update it from said modified copy.
On systems without the ECC MC, these will do nothing and operation will
continue to access the uncached memory directly. On systems with the ECC MC,
they will perform a copy, and the writeback will be done in slow mode.

bus_dmamem_map() requests for DMA memory with BUS_DMA_COHERENT set in flags,
which would return uncached memory, will now always fail on systems with
the ECC memory controller. Drivers which really need uncached memory, and
are aware of this particular setup, will now pass
BUS_DMA_COHERENT | BUS_DMA_BUS1, which will let the request succeed.

sq(4) will use all of the above to work mostly unmodified on ECC MC systems
in fast mode.

Finally, fast mode is enabled after autoconf.

Tested on IP22 and IP28.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.9 2012/05/27 14:13:00 miod Exp $	*/
d107 1
a107 2
		/* L2 line size */
		ci->ci_cacheconfiguration = 1 << ((key >> 16) & 0xff);
@


1.9
log
@Decide once for all whether IP22/IP28 systems are running with the ECC memory
controller or not, and store this in a global variable. This is better than
checking for the IP number everytime, especially since, according to IRIX
header files, not all IP26 use the ECC memory controller (not that it matters
much for us since we do not run on them yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.8 2012/05/15 18:17:50 miod Exp $	*/
d59 2
d472 5
d552 113
@


1.8
log
@revert a chunk introduced in 1.7 which was not supposed to be there yet
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.7 2012/05/12 16:48:27 miod Exp $	*/
d55 1
d125 1
d180 4
a213 1
	shift = IMC_MEMC_LSHIFT;
d217 2
d349 1
a349 1
	 * impact	?
d376 1
a376 1
	volatile uint32_t *sysid;
d391 14
d422 1
a422 4
		sysid = (volatile uint32_t *)
		    PHYS_TO_XKPHYS(HPC_BASE_ADDRESS_0 + IOC_BASE + IOC_SYSID,
		      CCA_NC);
		if (*sysid & 0x01) {
d442 25
@


1.7
log
@Strip trailing space from ARCS frame buffer names.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.6 2012/04/16 22:28:14 miod Exp $	*/
d104 2
a105 1
		ci->ci_l2line = 1 << ((key >> 16) & 0xff);
@


1.6
log
@Improve the way frame buffers are probed to reduce (and hopefully avoid)
false positives.

Do not look for framebuffers past GIO EXP1, there shouldn't be anything there.

Add the console code machinery to attach a glass console on IP22, when the
appropriate drivers will exist.

On multihead systems, get console framebuffer address (well, sort of) from a
completely undocumented interface (knowledge taken from Linux, confirmed to
work on a dual-head Indigo 2 here).

While there, get frame buffer names from ARCBios whenever possible, to be used
in dmesg eventually.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.5 2012/04/15 20:39:36 miod Exp $	*/
d104 1
a104 2
		/* L2 line size */
		ci->ci_cacheconfiguration = 1 << ((key >> 16) & 0xff);
d135 5
@


1.5
log
@If the dma-usable area changes after autoconf, recompute the buffer count and
invoke bufadjust() accordingly. Similar to what sysctl kern.bufcachepercent
does.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.4 2012/04/15 20:38:10 miod Exp $	*/
d43 8
d56 4
a59 3
void ip22_arcbios_walk(void);
int ip22_arcbios_walk_component(arc_config_t *);
void ip22_memory_setup(void);
d66 3
d70 4
a73 2
#define	IP22_HAS_L2	0x01
#define	IP22_HAS_AUDIO	0x02
d80 4
d90 7
d103 1
a103 1
		ci->ci_l2size = (1 << 12) << (cf->key & 0x0000ffff);
d105 1
a105 1
		ci->ci_cacheconfiguration = 1 << ((cf->key >> 16) & 0xff);
d115 38
a152 1
	if (ip22_arcwalk_results == (IP22_HAS_L2 | IP22_HAS_AUDIO))
a154 5
	/*
	 * It is safe to assume we have a 32-bit ARCBios, until
	 * IP26 and IP28 support is added, hence unconditional
	 * use of arc_config_t.
	 */
d167 3
d283 78
d442 5
@


1.4
log
@Tell Indy and Challenge S apart.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.3 2012/04/06 19:00:49 miod Exp $	*/
d22 2
d343 4
a346 1
	if (hpc_old == 0)
d348 6
@


1.3
log
@Rework IP22 RTC year base computation, again. It turns out that different
Indy PROM versions use different year bases - after all, using 1970 instead
of the previously used value of 1940 smelled like a bug, and probably was,
so this eventually got fixed in later PROM versions.

Instead of hardcoding a year base depending upon the system, we will now ask
ARCBios for its current year, and compare it to what can be read from the RTC
registers to figure out what year base is in use by the PROM.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.2 2012/04/03 21:17:35 miod Exp $	*/
d51 2
a52 2
 * Walk the ARCBios component tree to get L2 cache information.
 * This is the only way we can get the L2 cache size.
d55 4
d79 10
a89 1
	}
d240 6
d250 4
a253 1
		hw_prod = "Indigo";
d263 7
a269 2
			sys_config.system_subtype = IP22_INDY;
			hw_prod = "Indy";
a324 5

	/*
	 * Scan ARCBios component list for L2 cache information.
	 */
	ip22_arcbios_walk();
@


1.2
log
@Default DMA-reachable address constraints to the whole address space, and
narrow these in the various ipXX_machdep.c. On IP22-like systems, narrow
them to 28 bit physical addresses, but unpessimize this by extending this
to 32 bit after autoconf, if no 28-bit limited hpc(4) device has been found.
Since physical memory on these systems start at 128MB, this means that Indigo
systems with more than 128MB memory will behave correctly (and so will Indy
systems with E++ boards and more than 128MB memory).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip22_machdep.c,v 1.1 2012/03/28 20:44:23 miod Exp $	*/
d44 1
d130 1
a130 1
        if ((imc_read(IMC_SYSID) & IMC_SYSID_REVMASK) >= 5)
d303 5
@


1.1
log
@Work in progress support for the SGI Indigo, Indigo 2 and Indy systems
(IP20, IP22, IP24) in 64-bit mode, adapated from NetBSD. Currently limited
to headless operation, input and video drivers will get ported soon.

Should work on all R4000, R4440 and R5000 based systems. L2 cache on R5000SC
Indy not supported yet (coming soon), R4600 not supported yet either (coming
soon as well).

Tested to boot multiuser on: Indigo2 R4000SC, Indy R4000PC, Indy R4000SC,
Indy R5000SC, Indigo2 R4400SC. There are still glitches in the Ethernet driver
which are being looked at.

Expansion support is limited to the GIO E++ board; GIO boards with PCI-GIO
bridges not ported yet due to the lack of hardware, and this kind of driver
does not port blindly.

Most of this work comes from NetBSD, polishing and integration work, as well
as putting as many ``R4x00 in 64-bit mode'' erratas as necessary, by yours
truly.

More work is coming, as well as trying to get some easy way to boot install
kernels (as older PROM can only boot ECOFF binaries, which won't do for the
kernel).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 2
d43 2
d276 23
d304 11
@

