head	1.77;
access;
symbols
	OPENBSD_6_2_BASE:1.77
	OPENBSD_6_1:1.77.0.4
	OPENBSD_6_1_BASE:1.77
	OPENBSD_6_0:1.73.0.2
	OPENBSD_6_0_BASE:1.73
	OPENBSD_5_9:1.71.0.2
	OPENBSD_5_9_BASE:1.71
	OPENBSD_5_8:1.65.0.6
	OPENBSD_5_8_BASE:1.65
	OPENBSD_5_7:1.65.0.2
	OPENBSD_5_7_BASE:1.65
	OPENBSD_5_6:1.63.0.4
	OPENBSD_5_6_BASE:1.63
	OPENBSD_5_5:1.57.0.8
	OPENBSD_5_5_BASE:1.57
	OPENBSD_5_4:1.57.0.4
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.57.0.2
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.55.0.2
	OPENBSD_5_2_BASE:1.55
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.4
	OPENBSD_5_0:1.53.0.2
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.52.0.2
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.51.0.2
	OPENBSD_4_8_BASE:1.51
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.16.0.2
	OPENBSD_4_6_BASE:1.16;
locks; strict;
comment	@ * @;


1.77
date	2017.02.11.03.44.22;	author visa;	state Exp;
branches;
next	1.76;
commitid	xjkuO7IpWLYltL4L;

1.76
date	2016.10.27.13.19.27;	author visa;	state Exp;
branches;
next	1.75;
commitid	6Ve06RHpI01QGFsX;

1.75
date	2016.10.26.13.42.54;	author visa;	state Exp;
branches;
next	1.74;
commitid	khNYWeTCmYcllpHh;

1.74
date	2016.10.09.11.25.40;	author tom;	state Exp;
branches;
next	1.73;
commitid	DfYvEDcFmu1LY9q1;

1.73
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.72;
commitid	cyYKarj4qRTft4gD;

1.72
date	2016.02.27.13.08.07;	author mpi;	state Exp;
branches;
next	1.71;
commitid	hnv9KfQtxhCytAnd;

1.71
date	2016.01.02.05.49.36;	author visa;	state Exp;
branches;
next	1.70;
commitid	U9KGIaWU35EclYRl;

1.70
date	2015.12.25.09.22.00;	author visa;	state Exp;
branches;
next	1.69;
commitid	mo9Cs2HTLrPLm8sR;

1.69
date	2015.12.25.09.02.57;	author visa;	state Exp;
branches;
next	1.68;
commitid	up7cBfv7QqAqYrQj;

1.68
date	2015.12.25.08.34.51;	author visa;	state Exp;
branches;
next	1.67;
commitid	mGLOAekfSVArdeBr;

1.67
date	2015.12.25.06.18.50;	author visa;	state Exp;
branches;
next	1.66;
commitid	3iP5dZrT3IkHWgNZ;

1.66
date	2015.09.08.10.21.50;	author deraadt;	state Exp;
branches;
next	1.65;
commitid	PXEPkjFX0KqqXu7Y;

1.65
date	2014.11.25.19.08.42;	author miod;	state Exp;
branches;
next	1.64;
commitid	jlNGoFCojoG6HmlC;

1.64
date	2014.09.30.06.51.58;	author jmatthew;	state Exp;
branches;
next	1.63;
commitid	pUEUpP9FlbomZUiI;

1.63
date	2014.07.13.20.29.05;	author miod;	state Exp;
branches;
next	1.62;
commitid	bwsXAhkNWLURXRqL;

1.62
date	2014.07.12.22.37.03;	author uebayasi;	state Exp;
branches;
next	1.61;
commitid	5h3kYJioMDqUXM3V;

1.61
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.60;
commitid	uKVPYMN2MLxdZxzH;

1.60
date	2014.07.12.14.12.44;	author uebayasi;	state Exp;
branches;
next	1.59;
commitid	CwxiCWSX4kdxVfoo;

1.59
date	2014.05.19.21.18.42;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2014.04.03.08.07.16;	author mpi;	state Exp;
branches;
next	1.57;

1.57
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2012.09.29.18.54.39;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2012.04.03.21.17.35;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2012.03.15.18.57.22;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2011.04.05.14.43.10;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	2010.05.09.18.37.47;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2010.04.21.03.03.26;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2010.04.17.11.05.53;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2010.04.06.19.15.29;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2010.04.06.19.09.50;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2010.03.22.21.22.08;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2010.03.21.13.52.05;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2010.03.20.16.22.55;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2010.03.07.13.44.26;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.09.20.33.16;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2009.12.04.22.48.11;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.29.17.03.53;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.25.22.25.37;	author jsing;	state Exp;
branches;
next	1.38;

1.38
date	2009.11.25.17.39.51;	author syuu;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.25.11.23.30;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2009.11.18.19.05.51;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2009.11.12.17.13.33;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2009.11.07.22.48.37;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2009.11.07.14.49.01;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.11.06.07.37.49;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.26.20.14.42;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.26.18.11.25;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.23.21.19.17;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.22.22.08.54;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.22.20.59.24;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.22.20.39.17;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.22.20.05.28;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.22.18.35.28;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.16.00.15.49;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.14.20.21.16;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.07.08.35.47;	author syuu;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.07.04.17.48;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.18.19.31.56;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.25.19.17.25;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.11.19.56.04;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.06.22.46.43;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.01.21.56.38;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.13.21.48.03;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.13.18.47.30;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.13.16.28.11;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.10.18.04.25;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2009.05.28.18.03.55;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2009.05.28.18.02.43;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.27.19.00.19;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.21.16.25.26;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.15.22.59.07;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.15.06.29.37;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.08.18.36.48;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.02.21.28.08;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2009.04.15.18.46.40;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.13.21.17.54;	author miod;	state Exp;
branches;
next	;


desc
@@


1.77
log
@Let MP-safe interrupt handlers run without the kernel lock on sgi.

OK miod@@
@
text
@/*	$OpenBSD: ip27_machdep.c,v 1.76 2016/10/27 13:19:27 visa Exp $	*/

/*
 * Copyright (c) 2008, 2009 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Origin 200 / Origin 2000 / Onyx 2 (IP27), as well as
 * Origin 300 / Onyx 300 / Origin 350 / Onyx 350 / Onyx 4 / Origin 3000 /
 * Fuel / Tezro (IP35) specific code.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/atomic.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/reboot.h>
#include <sys/timetc.h>
#include <sys/tty.h>

#include <mips64/arcbios.h>
#include <mips64/archtype.h>
#include <mips64/cache.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/memconf.h>
#include <machine/mnode.h>

#include <uvm/uvm_extern.h>

#include <sgi/sgi/ip27.h>
#include <sgi/sgi/l1.h>
#include <sgi/xbow/hub.h>
#include <sgi/xbow/widget.h>
#include <sgi/xbow/xbow.h>

#include <sgi/pci/iofreg.h>
#include <dev/ic/comvar.h>

#include <dev/cons.h>

extern char *hw_prod;

extern void (*md_halt)(int);

paddr_t	ip27_widget_short(int16_t, u_int);
paddr_t	ip27_widget_long(int16_t, u_int);
paddr_t	ip27_widget_map(int16_t, u_int,bus_addr_t *, bus_size_t *);
int	ip27_widget_id(int16_t, u_int, uint32_t *);
int	ip27_widget_id_early(int16_t, u_int, uint32_t *);

void	ip27_halt(int);

unsigned int xbow_long_shift = 29;

static paddr_t io_base;
static int ip35 = 0;
uint	 maxnodes;
gda_t	*gda;

int	ip27_hub_intr_register(int, int, int *);
int	ip27_hub_intr_establish(int (*)(void *), void *, int, int,
	    const char *, struct intrhand *);
void	ip27_hub_intr_disestablish(int);
void	ip27_hub_intr_clear(int);
void	ip27_hub_intr_set(int);
uint32_t hubpi_intr0(uint32_t, struct trapframe *);
uint32_t hubpi_intr1(uint32_t, struct trapframe *);
void	ip27_hub_intr_makemasks0(void);
void	ip27_hub_intr_makemasks1(void);
void	ip27_hub_setintrmask(int);
void	ip27_hub_splx(int);

void	ip27_attach_node(struct device *, int16_t);
int	ip27_print(void *, const char *);
void	ip27_nmi(void *);

#ifdef MULTIPROCESSOR

#define IP27_SLICE_IPI(slice) ((slice) + HUBPI_ISR0_IPI_A)

unsigned int	ip27_ncpus;

int	ip27_kl_launch_cpu(klinfo_t *, void *);
int	ip27_kl_launch_cpu_board(lboard_t *, void *);
int	ip27_kl_attach_cpu(klinfo_t *, void *);
int	ip27_kl_attach_cpu_board(lboard_t *, void *);

uint	ip27_hub_get_timecount(struct timecounter *);

struct timecounter ip27_hub_timecounter = {
	.tc_get_timecount = ip27_hub_get_timecount,
	.tc_poll_pps = NULL,
	.tc_counter_mask = 0xffffffff,	/* truncated to 32 bits. */
	.tc_frequency = 1250000,
	.tc_name = "hubrt",
	.tc_quality = 100
};

volatile uint64_t	ip27_spinup_a0;
volatile uint64_t	ip27_spinup_sp;
volatile uint32_t	ip27_spinup_turn = ~0;

#define SPINUP_TICKET(nasid, slice)	(((nasid) << 8) | (slice))

void ip27_cpu_spinup_trampoline(uint64_t);

#endif /* MULTIPROCESSOR */

/*
 * IP27 interrupt handling declarations: 128 hw sources, plus timers and
 * hub error sources; 5 levels.
 */

struct intrhand *hubpi_intrhand0[HUBPI_NINTS];
struct intrhand *hubpi_intrhand1[HUBPI_NINTS];

#ifdef notyet
#define	INTPRI_XBOW_HUB		(INTPRI_CLOCK + 1)	/* HUB errors */
#define	INTPRI_XBOW_TIMER	(INTPRI_XBOW_HUB + 1)	/* prof timer */
#define	INTPRI_XBOW_CLOCK	(INTPRI_XBOW_TIMER + 1)	/* RTC */
#define	INTPRI_XBOW_HW1		(INTPRI_XBOW_CLOCK + 1)	/* HW level 1 */
#else
#define	INTPRI_XBOW_HW1		(INTPRI_CLOCK + 1)	/* HW level 1 */
#endif
#define	INTPRI_XBOW_HW0		(INTPRI_XBOW_HW1 + 1)	/* HW level 0 */

struct {
	uint64_t hw[2];
} hubpi_intem[MAXCPUS], hubpi_imask[MAXCPUS][NIPLS];

void
ip27_setup()
{
	struct cpu_info *ci = curcpu();
	struct ip27_config *ip27_config;
	uint64_t synergy0_0;
	console_t *cons;
	nmi_t *nmi;
	static char unknown_model[20];

	ci->ci_nasid = masternasid;
	ci->ci_slice = IP27_LHUB_L(HUBPI_CPU_NUMBER);

	io_base = PHYS_TO_XKPHYS_UNCACHED(0, SP_IO);

	ip35 = sys_config.system_type == SGI_IP35;

	if (ip35) {
		/*
		 * Get brick model type.
		 * We need to access the Synergy registers through the remote
		 * HUB interface, local access is protected on some models.
		 * Synergy0 register #0 is a 16 bits identification register.
		 */
		synergy0_0 = IP27_RHSPEC_L(0, HSPEC_SYNERGY(0, 0));
		sys_config.system_subtype = (synergy0_0 & 0xf000) >> 12;
		switch (sys_config.system_subtype) {
		case IP35_O350:	/* Chimera */
			hw_prod = "Origin 350";
			break;
		case IP35_FUEL:	/* Asterix */
			hw_prod = "Fuel";
			break;
		case IP35_O300:	/* Speedo2 */
			hw_prod = "Origin 300";
			break;
		case IP35_CBRICK:
			/* regular C-Brick, must be an Origin 3000 system */
			hw_prod = "Origin 3000";
			break;
		default:
			snprintf(unknown_model, sizeof unknown_model,
			    "Unknown IP35 type %x", sys_config.system_subtype);
			hw_prod = unknown_model;
			break;
		}
	} else {
		ip27_config = (struct ip27_config *)
		    IP27_LHSPEC_ADDR(LBOOTBASE_IP27 + IP27_CONFIG_OFFSET);
		if (ip27_config->magic == IP27_CONFIG_MAGIC)
			sys_config.system_subtype = ip27_config->ip27_subtype;
		else
			sys_config.system_subtype = IP27_UNKNOWN;
		switch (sys_config.system_subtype) {
		case IP27_O2K:
			hw_prod = "Origin 2000";
			break;
		case IP27_O200:
			hw_prod = "Origin 200";
			break;
		default:
			snprintf(unknown_model, sizeof unknown_model,
			    "Unknown IP27 type %x", sys_config.system_subtype);
			hw_prod = unknown_model;
			break;
		}
	}

	/*
	 * Register DMA-reachable memory constraints.
	 * The xbridge(4) is limited to a 31-bit region (its IOMMU features
	 * are too restricted to be of use).
	 */
	dma_constraint.ucr_low = 0;
	dma_constraint.ucr_high = (1UL << 31) - 1;

	xbow_widget_base = ip27_widget_short;
	xbow_widget_map = ip27_widget_map;
	xbow_widget_id = ip27_widget_id_early;

	md_halt = ip27_halt;

	/*
	 * Figure out as early as possibly whether we are running in M
	 * or N mode.
	 */

	kl_init(ip35);
	if (kl_n_mode != 0)
		xbow_long_shift = 28;

#ifdef MULTIPROCESSOR
	/*
	 * Pre-launch secondary CPUs with the help of the PROM. This has to be
	 * done now, before tearing down the PROM TLB and disabling interrupts
	 * on the secondary CPUs. The CPUs will wait in the spinup trampoline
	 * until the system launches them for real.
	 */
	ip27_ncpus = 1;
	kl_scan_all_nodes(IP27_BC_NODE, ip27_kl_launch_cpu_board, NULL);
#endif

	/*
	 * Initialize the early console parameters.
	 * This assumes it is either on IOC3 or IOC4, accessible through
	 * a widget small window.
	 *
	 * Since IOC3 and IOC4 use different clocks, we need to tell them
	 * apart early. We rely on the serial port offset within the IOC
	 * space.
	 */

	cons = kl_get_console();
	xbow_build_bus_space(&sys_config.console_io, 0,
	    8 /* whatever nonzero */);
	/* point to devio base */
	sys_config.console_io.bus_base =
	    cons->uart_base & 0xfffffffffff00000UL;
	comconsaddr = cons->uart_base & 0x00000000000fffffUL;
	comconsrate = cons->baud;
	if (comconsrate < 50 || comconsrate > 115200)
		comconsrate = 9600;
	if ((comconsaddr & 0xfff) < 0x380) {
		/* IOC3 */
		comconsfreq = 22000000 / 3;
	} else {
		/* IOC4 */
		uint32_t ioc4_mcr;
		paddr_t ioc4_base;

		/*
		 * IOC4 clocks are derived from the PCI clock,
		 * so we need to figure out whether this is an 66MHz
		 * or a 33MHz bus.
		 */
		ioc4_base = sys_config.console_io.bus_base;
		ioc4_mcr = *(volatile uint32_t *)(ioc4_base + IOC4_MCR);
		if (ioc4_mcr & IOC4_MCR_PCI_66MHZ)
			comconsfreq = 66666667;
		else
			comconsfreq = 33333333;
	}
	comconsiot = &sys_config.console_io;

	/*
	 * Force widget interrupts to run through us, unless a
	 * better interrupt master widget is found.
	 */

	xbow_intr_widget_intr_register = ip27_hub_intr_register;
	xbow_intr_widget_intr_establish = ip27_hub_intr_establish;
	xbow_intr_widget_intr_disestablish = ip27_hub_intr_disestablish;
	xbow_intr_widget_intr_clear = ip27_hub_intr_clear;
	xbow_intr_widget_intr_set = ip27_hub_intr_set;

	set_intr(INTPRI_XBOW_HW1, CR_INT_1, hubpi_intr1);
	set_intr(INTPRI_XBOW_HW0, CR_INT_0, hubpi_intr0);
	register_splx_handler(ip27_hub_splx);

	/*
	 * Disable all hardware interrupts.
	 */

	IP27_LHUB_S(HUBPI_CPU0_IMR0, 0);
	IP27_LHUB_S(HUBPI_CPU0_IMR1, 0);
	IP27_LHUB_S(HUBPI_CPU1_IMR0, 0);
	IP27_LHUB_S(HUBPI_CPU1_IMR1, 0);
	(void)IP27_LHUB_L(HUBPI_IR0);
	(void)IP27_LHUB_L(HUBPI_IR1);
	if (ip35) {
		IP27_RHUB_PI_S(masternasid, 1, HUBPI_CPU0_IMR0, 0);
		IP27_RHUB_PI_S(masternasid, 1, HUBPI_CPU0_IMR1, 0);
		IP27_RHUB_PI_S(masternasid, 1, HUBPI_CPU1_IMR0, 0);
		IP27_RHUB_PI_S(masternasid, 1, HUBPI_CPU1_IMR1, 0);
		(void)IP27_RHUB_PI_L(masternasid, 1, HUBPI_IR0);
		(void)IP27_RHUB_PI_L(masternasid, 1, HUBPI_IR1);
	}

	/*
	 * Setup NMI handler.
	 */
	nmi = IP27_NMI(0);
	nmi->magic = NMI_MAGIC;
	nmi->cb = (vaddr_t)ip27_nmi;
	nmi->cb_complement = ~nmi->cb;
	nmi->cb_arg = 0;

	/*
	 * Set up Node 0's HUB.
	 */
	IP27_LHUB_S(HUBPI_REGION_PRESENT, 0xffffffffffffffff);
	IP27_LHUB_S(HUBPI_CALIAS_SIZE, PI_CALIAS_SIZE_0);
	if (ip35) {
		IP27_RHUB_PI_S(masternasid, 1,
		    HUBPI_REGION_PRESENT, 0xffffffffffffffff);
		IP27_RHUB_PI_S(masternasid, 1,
		    HUBPI_CALIAS_SIZE, PI_CALIAS_SIZE_0);
	}

	/*
	 * Compute interrupt register address.
	 */
	xbow_intr_address = (1UL << 47) /* XIO I/O space */ |
	    (masternasid << (ip35 ? 39 : 38)) |
	    ((uint64_t)IP27_RHUB_ADDR(0, HUBPI_IR_CHANGE) -
	     IP27_NODE_IO_BASE(0)) /* HUB register offset */;

	_device_register = dksc_device_register;

#ifdef MULTIPROCESSOR
	tc_init(&ip27_hub_timecounter);
#endif
}

/*
 * Autoconf enumeration
 */

void
ip27_autoconf(struct device *parent)
{
	union {
		struct mainbus_attach_args maa;
		struct cpu_attach_args caa;
	} u;
	uint node;

	xbow_widget_id = ip27_widget_id;

	/*
	 * Attach the CPU we are running on early; other processors,
	 * if any, will get attached as they are discovered.
	 */

	bzero(&u, sizeof u);
	u.maa.maa_name = "cpu";
	u.maa.maa_nasid = currentnasid = masternasid;
	u.maa.maa_physid = IP27_LHUB_L(HUBPI_CPU_NUMBER);
	u.caa.caa_hw = &bootcpu_hwinfo;
	config_found(parent, &u, ip27_print);
	u.maa.maa_name = "clock";
	config_found(parent, &u, ip27_print);

	/*
	 * Now attach all nodes' I/O devices.
	 */

#ifdef MULTIPROCESSOR
	ip27_ncpus = 1;
#endif
	ip27_attach_node(parent, masternasid);
	for (node = 0; node < maxnodes; node++) {
		if (gda->nasid[node] < 0)
			continue;
		if (gda->nasid[node] == masternasid)
			continue;
		ip27_attach_node(parent, gda->nasid[node]);
	}
}

void
ip27_attach_node(struct device *parent, int16_t nasid)
{
	union {
		struct mainbus_attach_args maa;
		struct spdmem_attach_args saa;
	} u;
	uint dimm;
	void *match;

	currentnasid = nasid;
	bzero(&u, sizeof u);

	/*
	 * IRIX performs this extra initialization on Origin 200 systems.
	 * This seems to properly initialize on-board devices on the
	 * second node.
	 */
	if (sys_config.system_type == SGI_IP27 &&
	    sys_config.system_subtype == IP27_O200) {
		IP27_RHUB_S(nasid, HUBMDBASE_IP27 | HUBMD_LED0,
		    nasid == masternasid ? 1 : 9);
		IP27_RHUB_S(nasid, HUBMDBASE_IP27 | HUBMD_LED0,
		    nasid == masternasid ? 1 : 9);
	}

#ifdef MULTIPROCESSOR
	kl_scan_node(nasid, IP27_BC_NODE, ip27_kl_attach_cpu_board, parent);
#endif

	if (ip35) {
		l1_display(nasid, TRUE, "OpenBSD/sgi");

		u.maa.maa_name = "spdmem";
		u.maa.maa_nasid = nasid;
		for (dimm = 0; dimm < L1_SPD_DIMM_MAX; dimm++) {
			u.saa.dimm = dimm;
			/*
			 * inline config_found_sm() without printing a message
			 * if match() fails, to avoid getting
			 * ``spdmem not configured'' for empty memory slots.
			 */
			if ((match = config_search(NULL, parent, &u)) != NULL)
				config_attach(parent, match, &u, ip27_print);
		}
	}
	u.maa.maa_name = "xbow";
	u.maa.maa_nasid = nasid;
	config_found(parent, &u, ip27_print);
}

int
ip27_print(void *aux, const char *pnp)
{
	struct mainbus_attach_args *maa = aux;

	if (pnp != NULL)
		printf("%s at %s", maa->maa_name, pnp);
	printf(" nasid %d", maa->maa_nasid);

	return UNCONF;
}

/*
 * Widget mapping.
 */

paddr_t
ip27_widget_short(int16_t nasid, u_int widget)
{
	/*
	 * A hardware bug on the PI side of the Hub chip (at least in
	 * earlier versions) causes accesses to the short window #0
	 * to be unreliable.
	 * The PROM implements a workaround by remapping it to
	 * big window #6 (the last programmable big window).
	 */
	if (widget == 0)
		return ip27_widget_long(nasid, IOTTE_SWIN0);

	return ((uint64_t)(widget) << 24) |
	    ((uint64_t)(nasid) << kl_n_shift) | io_base;
}

paddr_t
ip27_widget_long(int16_t nasid, u_int window)
{
	return ((uint64_t)(window + 1) << xbow_long_shift) |
	    ((uint64_t)(nasid) << kl_n_shift) | io_base;
}

paddr_t
ip27_widget_map(int16_t nasid, u_int widget, bus_addr_t *offs, bus_size_t *len)
{
	uint tte, avail_tte;
	uint64_t iotte;
	paddr_t delta, start, end;
	int s;

	/*
	 * On Origin systems, we can only have partial views of the widget
	 * address space, due to the addressing scheme limiting each node's
	 * address space to 31 to 33 bits.
	 *
	 * The largest window is 256MB or 512MB large, depending on the
	 * mode the system is in (M/N).
	 */

	/*
	 * Round the requested range to a large window boundary.
	 */

	start = *offs;
	end = start + *len;

	start = (start >> xbow_long_shift);
	end = (end + (1 << xbow_long_shift) - 1) >> xbow_long_shift;

	/*
	 * See if an existing IOTTE covers part of the mapping we are asking
	 * for.  If so, reuse it and truncate the caller's range.
	 */

	s = splhigh();	/* XXX or disable interrupts completely? */

	avail_tte = IOTTE_MAX;
	for (tte = 0; tte < IOTTE_MAX; tte++) {
		if (tte == IOTTE_SWIN0)
			continue;

		iotte = IP27_RHUB_L(nasid, HUBIOBASE + HUBIO_IOTTE(tte));
		if (IOTTE_WIDGET(iotte) == 0) {
			if (avail_tte == IOTTE_MAX)
				avail_tte = tte;
			continue;
		}
		if (IOTTE_WIDGET(iotte) != widget)
			continue;

		if (IOTTE_OFFSET(iotte) < start ||
		    (IOTTE_OFFSET(iotte) + 1) >= end)
			continue;

		/*
		 * We found a matching IOTTE (an exact match if we asked for
		 * less than the large window size, a partial match otherwise).
		 * Reuse it (since we never unmap IOTTE at this point, there
		 * is no need to maintain a reference count).
		 */
		break;
	}

	/*
	 * If we found an unused IOTTE while searching above, program it
	 * to map the beginning of the requested range.
	 */

	if (tte == IOTTE_MAX && avail_tte != IOTTE_MAX) {
		tte = avail_tte;

		/* XXX I don't understand why it's not device space. */
		iotte = IOTTE(IOTTE_SPACE_MEMORY, widget, start);
		IP27_RHUB_S(nasid, HUBIOBASE + HUBIO_IOTTE(tte), iotte);
		(void)IP27_RHUB_L(nasid, HUBIOBASE + HUBIO_IOTTE(tte));
	}

	splx(s);

	if (tte != IOTTE_MAX) {
		delta = *offs - (start << xbow_long_shift);
		/* *offs unmodified */
		*len = (1 << xbow_long_shift) - delta;

		return ip27_widget_long(nasid, tte) + delta;
	}

	return 0UL;
}

/*
 * Widget enumeration
 */

int
ip27_widget_id(int16_t nasid, u_int widget, uint32_t *wid)
{
	paddr_t wpa;
	uint32_t id;

	if (widget != 0)
	{
		if (widget < WIDGET_MIN || widget > WIDGET_MAX)
			return EINVAL;
	}

	wpa = ip27_widget_short(nasid, widget);
	if (guarded_read_4(wpa + (WIDGET_ID | 4), &id) != 0)
		return ENXIO;

	if (wid != NULL)
		*wid = id;

	return 0;
}

/*
 * Same as the above, but usable before we can handle faults.
 * Expects the caller to only use valid widget numbers...
 */
int
ip27_widget_id_early(int16_t nasid, u_int widget, uint32_t *wid)
{
	paddr_t wpa;

	if (widget != 0)
	{
		if (widget < WIDGET_MIN || widget > WIDGET_MAX)
			return EINVAL;
	}

	wpa = ip27_widget_short(nasid, widget);
	if (wid != NULL)
		*wid = *(uint32_t *)(wpa + (WIDGET_ID | 4));

	return 0;
}

/*
 * Reboot code
 */

void
ip27_halt(int howto)
{
	uint32_t promop;
	uint node;
	uint64_t nibase, action;

	/*
	 * Even if ARCBios TLB and exception vectors are restored,
	 * returning to ARCBios doesn't work.
	 *
	 * So, instead, send a reset through the network interface
	 * of the Hub space.  Although there seems to be a way to tell
	 * the PROM which action we want it to take afterwards, it
	 * always reboots for me...
	 */

	if (howto & RB_HALT) {
#if 0
		if (howto & RB_POWERDOWN)
			promop = GDA_PROMOP_HALT;
		else
			promop = GDA_PROMOP_EIM;
#else
		if (howto & RB_POWERDOWN) {
			if (ip35) {
				l1_exec_command(masternasid, "* pwr d");
				delay(1000000);
				printf("Powerdown failed, "
				    "please switch off power manually.\n");
			} else {
				printf("Software powerdown not supported, "
				    "please switch off power manually.\n");
			}
			for (;;)
				continue;
			/* NOTREACHED */
		} else {
			printf("System halted.\n"
			    "Press any key to restart\n");
			cngetc();
			promop = GDA_PROMOP_REBOOT;
		}
#endif
	} else
		promop = GDA_PROMOP_REBOOT;

	promop |= GDA_PROMOP_MAGIC | GDA_PROMOP_NO_DIAGS |
	    GDA_PROMOP_NO_MEMINIT;

#if 0
	/*
	 * That's what one would expect, based on the gda layout...
	 */
	gda->promop = promop;
#else
	/*
	 * ...but the magic location is in a different castle.
	 * And it's not even the same between IP27 and IP35.
	 * Laugh, everyone! It's what SGI wants us to.
	 */
	if (ip35)
		IP27_LHUB_S(HUBLBBASE_IP35 + 0x8010, promop);
	else
		IP27_LHUB_S(HUBPIBASE + 0x418, promop);
#endif

	if (ip35) {
		nibase = HUBNIBASE_IP35;
		action = NI_RESET_LOCAL_IP35 | NI_RESET_ACTION_IP35;
	} else {
		nibase = HUBNIBASE_IP27;
		action = NI_RESET_LOCAL_IP27 | NI_RESET_ACTION_IP27;
	}

	/*
	 * Reset all other nodes, if present.
	 */

	for (node = 0; node < maxnodes; node++) {
		if (gda->nasid[node] < 0)
			continue;
		if (gda->nasid[node] == masternasid)
			continue;
		IP27_RHUB_S(gda->nasid[node],
		    nibase + HUBNI_RESET_ENABLE, NI_RESET_ENABLE);
		IP27_RHUB_S(gda->nasid[node],
		    nibase + HUBNI_RESET, action);
	}
	IP27_LHUB_S(nibase + HUBNI_RESET_ENABLE, NI_RESET_ENABLE);
	IP27_LHUB_S(nibase + HUBNI_RESET, action);
}

/*
 * Local HUB interrupt handling routines
 */

/*
 * Find a suitable interrupt bit for the given interrupt.
 */
int
ip27_hub_intr_register(int widget, int level, int *intrbit)
{
	u_long cpuid = cpu_number();
	int bit;

	/*
	 * Try to allocate a bit on hardware level 0 first.
	 */
	for (bit = HUBPI_INTR0_WIDGET_MAX; bit >= HUBPI_INTR0_WIDGET_MIN; bit--)
		if ((hubpi_intem[cpuid].hw[0] & (1UL << bit)) == 0)
			goto found;

	/*
	 * If all level 0 sources are in use, try to allocate a bit on
	 * level 1.
	 */
	for (bit = HUBPI_INTR1_WIDGET_MAX; bit >= HUBPI_INTR1_WIDGET_MIN; bit--)
		if ((hubpi_intem[cpuid].hw[1] & (1UL << bit)) == 0) {
			bit += HUBPI_NINTS;
			goto found;
		}

	return EINVAL;

found:
	*intrbit = bit;
	return 0;
}

/*
 * Register an interrupt handler for a given source, and enable it.
 */
int
ip27_hub_intr_establish(int (*func)(void *), void *arg, int intrbit,
    int level, const char *name, struct intrhand *ihstore)
{
	struct intrhand *ih, **anchor;
	u_long cpuid = cpu_number();
	int flags;
	int s;

#ifdef DIAGNOSTIC
	if (intrbit < 0 || intrbit >= HUBPI_NINTS + HUBPI_NINTS)
		return EINVAL;
#endif

	flags = (level & IPL_MPSAFE) ? IH_MPSAFE : 0;
	level &= ~IPL_MPSAFE;

	/*
	 * Widget interrupts are not supposed to be shared - the interrupt
	 * mask is supposedly large enough for all interrupt sources.
	 *
	 * XXX On systems with many widgets and/or nodes, this assumption
	 * XXX will no longer stand; we'll need to implement interrupt
	 * XXX sharing at some point.
	 */
	if (intrbit >= HUBPI_NINTS)
		anchor = &hubpi_intrhand1[intrbit % HUBPI_NINTS];
	else
		anchor = &hubpi_intrhand0[intrbit];
	if (*anchor != NULL)
		return EEXIST;

	if (ihstore == NULL) {
		ih = malloc(sizeof(*ih), M_DEVBUF, M_NOWAIT);
		if (ih == NULL)
			return ENOMEM;
		flags |= IH_ALLOCATED;
	} else
		ih = ihstore;

	ih->ih_next = NULL;
	ih->ih_fun = func;
	ih->ih_arg = arg;
	ih->ih_level = level;
	ih->ih_irq = intrbit;
	ih->ih_flags = flags;
	if (name != NULL)
		evcount_attach(&ih->ih_count, name, &ih->ih_level);

	s = splhigh();

	*anchor = ih;

	hubpi_intem[cpuid].hw[intrbit / HUBPI_NINTS] |=
	    1UL << (intrbit % HUBPI_NINTS);
	if (intrbit / HUBPI_NINTS != 0)
		ip27_hub_intr_makemasks1();
	else
		ip27_hub_intr_makemasks0();

	splx(s);	/* causes hw mask update */

	return 0;
}

void
ip27_hub_intr_disestablish(int intrbit)
{
	struct intrhand *ih, **anchor;
	u_long cpuid = cpu_number();
	int s;

#ifdef DIAGNOSTIC
	if (intrbit < 0 || intrbit >= HUBPI_NINTS + HUBPI_NINTS)
		return;
#endif

	if (intrbit >= HUBPI_NINTS)
		anchor = &hubpi_intrhand1[intrbit % HUBPI_NINTS];
	else
		anchor = &hubpi_intrhand0[intrbit];

	s = splhigh();

	if ((ih = *anchor) == NULL) {
		splx(s);
		return;
	}

	*anchor = NULL;

	hubpi_intem[cpuid].hw[intrbit / HUBPI_NINTS] &=
	    ~(1UL << (intrbit % HUBPI_NINTS));
	if (intrbit / HUBPI_NINTS != 0)
		ip27_hub_intr_makemasks1();
	else
		ip27_hub_intr_makemasks0();

	splx(s);

	if (ISSET(ih->ih_flags, IH_ALLOCATED))
		free(ih, M_DEVBUF, sizeof *ih);
}

void
ip27_hub_intr_clear(int intrbit)
{
	struct cpu_info *ci = curcpu();

	IP27_RHUB_PI_S(ci->ci_nasid, IP27_SLICE_SUBNODE(ci->ci_slice),
	    HUBPI_IR_CHANGE, PI_IR_CLR | intrbit);
	(void)IP27_RHUB_PI_L(ci->ci_nasid, IP27_SLICE_SUBNODE(ci->ci_slice),
	    HUBPI_IR0);
}

void
ip27_hub_intr_set(int intrbit)
{
	struct cpu_info *ci = curcpu();

	IP27_RHUB_PI_S(ci->ci_nasid, IP27_SLICE_SUBNODE(ci->ci_slice),
	    HUBPI_IR_CHANGE, PI_IR_SET | intrbit);
}

void
ip27_hub_splx(int newipl)
{
	struct cpu_info *ci = curcpu();

	/* Update masks to new ipl. Order highly important! */
	__asm__ (".set noreorder\n");
	ci->ci_ipl = newipl;
	mips_sync();
	__asm__ (".set reorder\n");
	ip27_hub_setintrmask(newipl);

	/* If we still have softints pending trigger processing. */
	if (ci->ci_softpending && newipl < IPL_SOFTINT)
		setsoftintr0();
}

/*
 * Level 0 and level 1 interrupt dispatchers.
 */

#define	INTR_FUNCTIONNAME	hubpi_intr0
#define	MASK_FUNCTIONNAME	ip27_hub_intr_makemasks0
#define	INTR_LOCAL_DECLS
#define	MASK_LOCAL_DECLS \
	struct cpu_info *ci = curcpu();
#define	INTR_GETMASKS \
do { \
	isr = IP27_LHUB_L(HUBPI_IR0); \
	imr = IP27_LHUB_L(IP27_SLICE_LCPU(ci->ci_slice) == 0 ? \
	    HUBPI_CPU0_IMR0 : HUBPI_CPU1_IMR0); \
	bit = HUBPI_INTR0_WIDGET_MAX; \
} while (0)
#define	INTR_MASKPENDING \
do { \
	IP27_LHUB_S(IP27_SLICE_LCPU(ci->ci_slice) == 0 ? \
	    HUBPI_CPU0_IMR0 : HUBPI_CPU1_IMR0, imr & ~isr); \
	(void)IP27_LHUB_L(HUBPI_IR0); \
} while (0)
#define	INTR_IMASK(ipl)		hubpi_imask[ci->ci_cpuid][ipl].hw[0]
#ifdef MULTIPROCESSOR
#define	INTR_IPI_HOOK(ipl) \
do { \
	unsigned long ipibit = IP27_SLICE_IPI(ci->ci_slice); \
	unsigned long ipimask = 1 << ipibit; \
	if ((isr & ipimask) && \
	    !(hubpi_imask[ci->ci_cpuid][ipl].hw[0] & ipimask)) { \
		struct intrhand *ih = hubpi_intrhand0[ipibit]; \
		ih->ih_fun(ih->ih_arg); \
		isr &= ~ipimask; \
	} \
} while (0)
#endif /* MULTIPROCESSOR */
#define	INTR_HANDLER(bit)	hubpi_intrhand0[bit]
#define	INTR_SPURIOUS(bit) \
do { \
	printf("spurious interrupt, source %d\n", bit); \
} while (0)
#define	INTR_MASKRESTORE \
do { \
	IP27_LHUB_S(IP27_SLICE_LCPU(ci->ci_slice) == 0 ? \
	    HUBPI_CPU0_IMR0 : HUBPI_CPU1_IMR0, imr); \
	(void)IP27_LHUB_L(HUBPI_IR0); \
} while (0)
#define	INTR_MASKSIZE	HUBPI_NINTS

#include <sgi/sgi/intr_template.c>

#define	INTR_FUNCTIONNAME	hubpi_intr1
#define	MASK_FUNCTIONNAME	ip27_hub_intr_makemasks1
#define	INTR_LOCAL_DECLS
#define	MASK_LOCAL_DECLS \
	struct cpu_info *ci = curcpu();
#define	INTR_GETMASKS \
do { \
	isr = IP27_LHUB_L(HUBPI_IR1); \
	imr = IP27_LHUB_L(IP27_SLICE_LCPU(ci->ci_slice) == 0 ? \
	    HUBPI_CPU0_IMR1 : HUBPI_CPU1_IMR1); \
	bit = HUBPI_INTR1_WIDGET_MAX; \
} while (0)
#define	INTR_MASKPENDING \
do { \
	IP27_LHUB_S(IP27_SLICE_LCPU(ci->ci_slice) == 0 ? \
	    HUBPI_CPU0_IMR1 : HUBPI_CPU1_IMR1, imr & ~isr); \
	(void)IP27_LHUB_L(HUBPI_IR1); \
} while (0)
#define	INTR_IMASK(ipl)		hubpi_imask[ci->ci_cpuid][ipl].hw[1]
#define	INTR_HANDLER(bit)	hubpi_intrhand1[bit]
#define	INTR_SPURIOUS(bit) \
do { \
	printf("spurious interrupt, source %d\n", bit + HUBPI_NINTS); \
} while (0)
#define	INTR_MASKRESTORE \
do { \
	IP27_LHUB_S(IP27_SLICE_LCPU(ci->ci_slice) == 0 ? \
	    HUBPI_CPU0_IMR1 : HUBPI_CPU1_IMR1, imr); \
	(void)IP27_LHUB_L(HUBPI_IR1); \
} while (0)
#define	INTR_MASKSIZE	HUBPI_NINTS

#include <sgi/sgi/intr_template.c>

void
ip27_hub_setintrmask(int level)
{
	struct cpu_info *ci = curcpu();
	u_long imr0, imr1;

	if (IP27_SLICE_LCPU(ci->ci_slice) == 0) {
		imr0 = HUBPI_CPU0_IMR0;
		imr1 = HUBPI_CPU0_IMR1;
	} else {
		imr0 = HUBPI_CPU1_IMR0;
		imr1 = HUBPI_CPU1_IMR1;
	}

	IP27_LHUB_S(imr0, hubpi_intem[ci->ci_cpuid].hw[0] &
	    ~hubpi_imask[ci->ci_cpuid][level].hw[0]);
	(void)IP27_LHUB_L(HUBPI_IR0);
	IP27_LHUB_S(imr1, hubpi_intem[ci->ci_cpuid].hw[1] &
	    ~hubpi_imask[ci->ci_cpuid][level].hw[1]);
	(void)IP27_LHUB_L(HUBPI_IR1);
}

void
ip27_nmi(void *arg)
{
	vaddr_t regs_offs;
	register_t *regs, epc;
	struct trapframe nmi_frame;
	extern int db_ktrap(int, struct trapframe *);

	/*
	 * Build a ddb frame from the registers saved in the NMI KREGS
	 * area.
	 */

	if (ip35)
		regs_offs = IP35_NMI_KREGS_BASE;	/* XXX assumes cpu0 */
	else
		regs_offs = IP27_NMI_KREGS_BASE;	/* XXX assumes cpu0 */
	regs = IP27_UNCAC_ADDR(register_t *, 0, regs_offs);

	memset(&nmi_frame, 0xff, sizeof nmi_frame);
	
	/* general registers */
	memcpy(&nmi_frame.zero, regs, 32 * sizeof(register_t));
	regs += 32;
	nmi_frame.sr = *regs++;		/* COP_0_STATUS_REG */
	nmi_frame.cause = *regs++;	/* COP_0_CAUSE_REG */
	nmi_frame.pc = *regs++;
	nmi_frame.badvaddr = *regs++;	/* COP_0_BAD_VADDR */
	epc = *regs++;			/* COP_0_EXC_PC */
	regs++;				/* COP_0_CACHE_ERR */
	regs++;				/* NMI COP_0_STATUS_REG */

	setsr(getsr() & ~SR_BOOT_EXC_VEC);
	printf("NMI, PC = %p RA = %p SR = %08lx EPC = %p\n",
	    (void *)nmi_frame.pc, (void *)nmi_frame.ra, nmi_frame.sr,
	    (void *)epc);
#ifdef DDB
	(void)db_ktrap(-1, &nmi_frame);
#endif
	panic("NMI");
	/* NOTREACHED */
}

#ifdef MULTIPROCESSOR

int
ip27_kl_launch_cpu(klinfo_t *comp, void *arg)
{
	struct cpu_info *ci = curcpu();

	/* Skip the running CPU. */
	if (comp->nasid == ci->ci_nasid &&
	    comp->physid == ci->ci_slice)
		return 0;

	/* XXX Skip CPUs on other nodes. */
	if (comp->nasid != ci->ci_nasid)
		return 0;

	if (ip27_ncpus >= MAXCPUS)
		return 0;

	ip27_prom_launch_slave(comp->nasid, comp->physid,
	    ip27_cpu_spinup_trampoline,
	    SPINUP_TICKET(comp->nasid, comp->physid), 0, 0);
	ip27_ncpus++;

	return 0;
}

int
ip27_kl_launch_cpu_board(lboard_t *board, void *arg)
{
	kl_scan_board(board, KLSTRUCT_CPU, ip27_kl_launch_cpu, arg);
	return 0;
}

int
ip27_kl_attach_cpu(klinfo_t *comp, void *arg)
{
	struct cpu_attach_args caa;
	struct cpu_hwinfo hw;
	struct cpu_info *ci = curcpu();
	struct device *parent = arg;
	klcpu_t *cpucomp;

	/* Skip the running CPU. */
	if (comp->nasid == ci->ci_nasid &&
	    comp->physid == ci->ci_slice)
		return 0;

	/* XXX Skip CPUs on other nodes. */
	if (comp->nasid != ci->ci_nasid)
		return 0;

	if (ip27_ncpus >= MAXCPUS)
		return 0;

	cpucomp = (klcpu_t *)comp;

	hw.c0prid = cpucomp->cpu_prid;
	hw.c1prid = cpucomp->cpu_prid;
	hw.clock = cpucomp->cpu_speed * 1000000;
	hw.tlbsize = 64;
	hw.type = (cpucomp->cpu_prid >> 8) & 0xff;

	caa.caa_maa.maa_name = "cpu";
	caa.caa_maa.maa_nasid = comp->nasid;
	caa.caa_maa.maa_physid = comp->physid;
	caa.caa_hw = &hw;
	config_found(parent, &caa, ip27_print);
	ip27_ncpus++;

	return 0;
}

int
ip27_kl_attach_cpu_board(lboard_t *board, void *arg)
{
	kl_scan_board(board, KLSTRUCT_CPU, ip27_kl_attach_cpu, arg);
	return 0;
}

uint
ip27_hub_get_timecount(struct timecounter *tc)
{
	return IP27_RHUB_L(masternasid, HUBPI_RT_COUNT);
}

void
hw_ipi_intr_set(u_long cpuid)
{
	struct cpu_info *ci = get_cpu_info(cpuid);
	int intr;

	intr = IP27_SLICE_IPI(ci->ci_slice);
	IP27_RHUB_PI_S(ci->ci_nasid, IP27_SLICE_SUBNODE(ci->ci_slice),
	    HUBPI_IR_CHANGE, PI_IR_SET | intr);
}

void
hw_ipi_intr_clear(u_long cpuid)
{
	struct cpu_info *ci = get_cpu_info(cpuid);
	int intr;

	intr = IP27_SLICE_IPI(ci->ci_slice);
	IP27_RHUB_PI_S(ci->ci_nasid, IP27_SLICE_SUBNODE(ci->ci_slice),
	    HUBPI_IR_CHANGE, PI_IR_CLR | intr);
	(void)IP27_RHUB_PI_L(ci->ci_nasid, IP27_SLICE_SUBNODE(ci->ci_slice),
	    HUBPI_IR0);
}

int
hw_ipi_intr_establish(int (*func)(void *), u_long cpuid)
{
	struct cpu_info *ci = get_cpu_info(cpuid);
	int intr;

	intr = IP27_SLICE_IPI(ci->ci_slice);
	return ip27_hub_intr_establish(func, (void *)cpuid, intr, IPL_IPI,
	    NULL, &ci->ci_ipiih);
}

void
hw_cpu_hatch(struct cpu_info *ci)
{
	int s;

	setcurcpu(ci);

	/*
	 * Make sure we can access the extended address space.
	 * Note that r10k and later do not allow XUSEG accesses
	 * from kernel mode unless SR_UX is set.
	 */
	setsr(getsr() | SR_KX | SR_UX);

	tlb_init(64);
	tlb_set_pid(0);

	/*
	 * Turn off bootstrap exception vectors.
	 */
	setsr(getsr() & ~SR_BOOT_EXC_VEC);

	/*
	 * Clear out the I and D caches.
	 */
	Mips10k_ConfigCache(ci);
	Mips_SyncCache(ci);

	printf("cpu%lu launched\n", cpu_number());

	(*md_startclock)(ci);

	ncpus++;
	cpuset_add(&cpus_running, ci);

	mips64_ipi_init();
	ip27_hub_setintrmask(0);

	spl0();
	(void)updateimask(0);

	SCHED_LOCK(s);
	cpu_switchto(NULL, sched_chooseproc());
}

void
hw_cpu_boot_secondary(struct cpu_info *ci)
{
	vaddr_t kstack;

	kstack = alloc_contiguous_pages(USPACE);
	if (kstack == 0)
		panic("unable to allocate idle stack\n");

	__asm__ (".set noreorder\n");
	ci->ci_curprocpaddr = (void *)kstack;
	ip27_spinup_a0 = (uint64_t)ci;
	ip27_spinup_sp = (uint64_t)(kstack + USPACE);
	mips_sync();
	__asm__ (".set reorder\n");
	ip27_spinup_turn = SPINUP_TICKET(ci->ci_nasid, ci->ci_slice);

	while (!cpuset_isset(&cpus_running, ci))
		;
}

#endif /* MULTIPROCESSOR */
@


1.76
log
@Revert previous `ncpus' change because the percpu code now works
without it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.75 2016/10/26 13:42:54 visa Exp $	*/
d779 1
d787 3
d809 2
a810 2
		ih->ih_flags = IH_ALLOCATED;
	} else {
a811 2
		ih->ih_flags = 0;
	}
d818 1
@


1.75
log
@Increment `ncpus' to its final value already during autoconfiguration so
that percpu data areas get allocated properly on mips64 platforms. It is
too late to set the value during launch of secondary CPUs.

ok jasper@@ kettenis@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.74 2016/10/09 11:25:40 tom Exp $	*/
d1214 1
@


1.74
log
@Apply consistency to forever loops with continue and NOTREACHED

Same thought from kettenis@@, ok krw@@ phessler@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.73 2016/03/06 19:42:27 mpi Exp $	*/
a1213 1
	ncpus++;
@


1.73
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.72 2016/02/27 13:08:07 mpi Exp $	*/
d674 3
a676 1
			for (;;) ;
@


1.72
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.71 2016/01/02 05:49:36 visa Exp $	*/
d84 2
a85 2
uint32_t hubpi_intr0(uint32_t, struct trap_frame *);
uint32_t hubpi_intr1(uint32_t, struct trap_frame *);
d1021 2
a1022 2
	struct trap_frame nmi_frame;
	extern int db_ktrap(int, struct trap_frame *);
@


1.71
log
@Take the PHY of iec(4) out of reset before attaching the interface.
Otherwise the PHY goes undetected on the slave node of a dual-node
Origin 200. The PHY gets enabled by diagnostic checks but only on the
master node. As the attach code will now do the enabling, the checks can
be disabled on reboot, making reboots faster especially on IP27.

Tested on Origin 200 (IP27), Fuel (IP35 with iec), and Origin 350
(IP35 without iec).

Diff from miod@@, ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.70 2015/12/25 09:22:00 visa Exp $	*/
d1022 1
a1022 1
	extern int kdb_trap(int, struct trap_frame *);
d1053 1
a1053 1
	(void)kdb_trap(-1, &nmi_frame);
@


1.70
log
@Add IPI logic. Assign two additional interrupts for inter-processor
signalling as a workaround to a limitation in the hub interrupt code,
to allow four CPUs per node. At the moment, multi-node setups are not
supported.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.67 2015/12/25 06:18:50 visa Exp $	*/
d422 13
d685 1
a685 1
	promop |= GDA_PROMOP_MAGIC | /* GDA_PROMOP_NO_DIAGS | */
@


1.69
log
@Add launch logic for secondary CPUs. The PROM's launch entry point address
and function signature are from Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.68 2015/12/25 08:34:51 visa Exp $	*/
d97 2
d919 13
d1130 35
@


1.68
log
@Make interrupt masking MP-aware. Linux IP27 and IP35 ports served as a
substitute for hardware documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.67 2015/12/25 06:18:50 visa Exp $	*/
d30 1
d37 1
d97 7
d115 8
d238 11
d394 3
d419 5
d1033 78
d1115 66
@


1.67
log
@Add timecounter for MP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.66 2015/09/08 10:21:50 deraadt Exp $	*/
d128 1
a128 1
} hubpi_intem, hubpi_imask[NIPLS];
d133 1
d140 3
d356 1
d690 1
d697 1
a697 1
		if ((hubpi_intem.hw[0] & (1UL << bit)) == 0)
d705 1
a705 1
		if ((hubpi_intem.hw[1] & (1UL << bit)) == 0) {
d725 1
d770 2
a771 1
	hubpi_intem.hw[intrbit / HUBPI_NINTS] |= 1UL << (intrbit % HUBPI_NINTS);
d786 1
d808 1
a808 1
	hubpi_intem.hw[intrbit / HUBPI_NINTS] &=
d824 6
a829 1
	IP27_RHUB_PI_S(masternasid, 0, HUBPI_IR_CHANGE, PI_IR_CLR | intrbit);
d835 4
a838 1
	IP27_RHUB_PI_S(masternasid, 0, HUBPI_IR_CHANGE, PI_IR_SET | intrbit);
d851 2
a852 2
	if (CPU_IS_PRIMARY(ci))
		ip27_hub_setintrmask(newipl);
d865 2
a866 1
#define	MASK_LOCAL_DECLS
a868 1
	/* XXX this assumes we run on cpu0 */ \
d870 2
a871 1
	imr = IP27_LHUB_L(HUBPI_CPU0_IMR0); \
d876 2
a877 1
	IP27_LHUB_S(HUBPI_CPU0_IMR0, imr & ~isr); \
d880 1
a880 1
#define	INTR_IMASK(ipl)		hubpi_imask[ipl].hw[0]
d888 2
a889 1
	IP27_LHUB_S(HUBPI_CPU0_IMR0, imr); \
d899 2
a900 1
#define	MASK_LOCAL_DECLS
a902 1
	/* XXX this assumes we run on cpu0 */ \
d904 2
a905 1
	imr = IP27_LHUB_L(HUBPI_CPU0_IMR1); \
d910 2
a911 1
	IP27_LHUB_S(HUBPI_CPU0_IMR1, imr & ~isr); \
d914 1
a914 1
#define	INTR_IMASK(ipl)		hubpi_imask[ipl].hw[1]
d922 2
a923 1
	IP27_LHUB_S(HUBPI_CPU0_IMR1, imr); \
d933 13
a945 3
	/* XXX this assumes we run on cpu0 */
	IP27_LHUB_S(HUBPI_CPU0_IMR0,
	    hubpi_intem.hw[0] & ~hubpi_imask[level].hw[0]);
d947 2
a948 2
	IP27_LHUB_S(HUBPI_CPU0_IMR1,
	    hubpi_intem.hw[1] & ~hubpi_imask[level].hw[1]);
@


1.66
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.65 2014/11/25 19:08:42 miod Exp $	*/
d27 1
d31 1
a32 1
#include <sys/atomic.h>
d93 15
d323 4
d961 10
@


1.65
log
@Brag about what OS we are running on the LCD panel, if there is one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.64 2014/09/30 06:51:58 jmatthew Exp $	*/
d789 1
a789 1
		free(ih, M_DEVBUF, 0);
@


1.64
log
@implement atomic operations using ll/sc, and convert rw_cas and callers of the
pre-existing atomics to match.

tested on sgi (octane) and octeon (erl)
ok miod@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.63 2014/07/13 20:29:05 miod Exp $	*/
d364 2
@


1.63
log
@Still needs <sys/reboot.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.62 2014/07/12 22:37:03 uebayasi Exp $	*/
d31 1
a41 1
#include <machine/atomic.h>
@


1.62
log
@reboot(9), panic(9): Call panic(9) for unrecoverable MD H/W errors (NMIs)

Some architectures have ability to detect hardware sanity and notify system
(NMI, firmware callback, etc.).  Handle these hardware severe errors, same
as software errors, with panic(9).

According to miod@@, SGI IP27 NMI is triggered by pushing some "hidden" button,
which "usual" users/admins don't know.  Pushing such a button is "RB_USERREQ"
(human-triggered) in that the button is pushed by a human, but not "RB_USERREQ"
in that no user intervention in system (== no command input) is done.  miod@@
agreed that changing these from RB_USERREQ to !RB_USERREQ (== panic(9)) is
not a big problem.

OK miod@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d29 1
@


1.61
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.60 2014/07/12 14:12:44 uebayasi Exp $	*/
a28 1
#include <sys/reboot.h>
d935 2
a936 2
	printf("Resetting system...\n");
	reboot(RB_USERREQ);
@


1.60
log
@boot(9), reboot(9): Migrate MD callers of boot(9) to reboot(9)

I have found that some ports call boot(9) from machine-dependent code to
reboot system.  These should be changed to either:

- Sending signal to init(8) to trigger it to shutdown system cleanly, like
  acpi(4) does, in cases where found problems don't prevent system from working
  immediately, or

- Just doing panic(9) if the situation is severely broken.

For now, just rewrite boot() to reboot().  Actual fixes follow.

Discussed with & OK from kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d787 1
a787 1
		free(ih, M_DEVBUF);
@


1.59
log
@Format string fixes and removal of -Wno-format for sgi. Based upon an
initial diff from jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.58 2014/04/03 08:07:16 mpi Exp $	*/
d937 1
a937 1
	boot(RB_USERREQ);
@


1.58
log
@Moar <uvm/uvm.h> -> <uvm/uvm_extern.h> love.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.57 2012/10/03 11:18:23 miod Exp $	*/
d930 3
a932 2
	printf("NMI, PC = %p RA = %p SR = %08x EPC = %p\n",
	    nmi_frame.pc, nmi_frame.ra, nmi_frame.sr, epc);
@


1.57
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.56 2012/09/29 18:54:39 miod Exp $	*/
d43 1
a43 1
#include <uvm/uvm.h>
@


1.56
log
@Proide a mips_sync() macro to wrap asm("sync"), and replace gazillions of
such statements with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.55 2012/04/03 21:17:35 miod Exp $	*/
d38 1
@


1.55
log
@Default DMA-reachable address constraints to the whole address space, and
narrow these in the various ipXX_machdep.c. On IP22-like systems, narrow
them to 28 bit physical addresses, but unpessimize this by extending this
to 32 bit after autoconf, if no 28-bit limited hpc(4) device has been found.
Since physical memory on these systems start at 128MB, this means that Indigo
systems with more than 128MB memory will behave correctly (and so will Indy
systems with E++ boards and more than 128MB memory).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.54 2012/03/15 18:57:22 miod Exp $	*/
d809 2
a810 1
	__asm__ ("sync\n\t.set reorder\n");
@


1.54
log
@uncached_base was introduced early in IP27 support, since these designs use
subspaces in the CCA_NC uncached memory space. However, being coherent,
there was never a need for bus_dma to use uncached addresses.

This means that, on the only systems where uncached_base was not set to
PHYS_TO_XKPHYS(0, CCA_NC), it was never used.

Remove the variable, and replace PHYS_TO_UNCACHED() with
PHYS_TO_XKPHYS(, CCA_NC). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.53 2011/04/05 14:43:10 miod Exp $	*/
d42 1
a42 1
#include <uvm/uvm_extern.h>
d176 8
@


1.53
log
@Rename a few xbow global variable names to make them less ambiguous.
Remember the hub widget number of each node, instead of only the master node.
Use this in xbridge to compute the proper direct DMA map configuration
register value (it needs to embed the hub widget number matching the
physical address range).
This should allow us to pick memory from a different node than the one
we booted from, as the DMA window, if wanted.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.52 2010/09/20 06:33:47 matthew Exp $	*/
a121 1
	uncached_base = PHYS_TO_XKPHYS_UNCACHED(0, SP_NC);
@


1.52
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.51 2010/05/09 18:37:47 miod Exp $	*/
d289 8
@


1.51
log
@Proper support for IP35 C-Brick types (i.e. Origin 3000): do not attach
a (missing) second serial port to ioc(4), read spdmem(4) records from the
right index, and query the Ethernet address from the I-Brick eeprom instead
of the C-Brick eeprom.
Tested by Sebastian Reitenbach, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.50 2010/04/21 03:03:26 deraadt Exp $	*/
d719 1
a719 2
		evcount_attach(&ih->ih_count, name, &ih->ih_level,
		    &evcount_intr);
@


1.50
log
@more cleanup to cope with the change that tries to make proc.h not act
like it is everything.h
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.49 2010/04/17 11:05:53 miod Exp $	*/
d145 4
@


1.49
log
@Do not forget to set nasid to the right value when trying to attach spdmem.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.48 2010/04/06 19:15:29 miod Exp $	*/
d40 1
@


1.48
log
@Split the device_register() code responsible for boot path recognition into
two distinct sets of routines: one for the ARCBios-compatible path used on
non-KL systems (such as O2 and Octane), and one for the KL system using
dksc() paths.

When trying to match a dksc() path, walk the KL configuration of the whole
system until the dksc controller is found; since the controller numbers are
not assigned sequentially and contiguously, the old code would not work on
complex systems (such as when booting from controller #6 when #3 to #5 are
unaffected).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.47 2010/04/06 19:09:50 miod Exp $	*/
d340 1
d344 1
d357 1
a357 1
	u.maa.maa_nasid = currentnasid = nasid;
@


1.47
log
@Add more KL grovelling routines: one routine to enumerate on all nodes,
and routines to turn a KL console and a KL component structs, respectively,
into struct sgi_device_location for further device identification.

XXX Due to the way PCI devices are numbered on PIC buses, this code is tainted
XXX by knowledge about PIC widgets, to compensate. I have considered changing
XXX xbridge(4) to have our PCI device numbering match KL on PIC-connected
XXX devices, but I expect this to be even uglier. This is not settled yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.46 2010/03/22 21:22:08 miod Exp $	*/
d284 2
@


1.46
log
@On SGI IP35 systems, get SPD memory records from L1 and attach spdmem to
decode them when available; tested on Fuel and Origin 350.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.45 2010/03/21 13:52:05 miod Exp $	*/
a68 1
static gda_t *gda;
d70 2
a71 1
static uint maxnodes;
a114 2
	size_t gsz;
	uint node;
a186 34

	/*
	 * Get a grip on the global data area, and figure out how many
	 * theoretical nodes are available.
	 */

	gda = IP27_GDA(0);
	gsz = IP27_GDA_SIZE(0);
	if (gda->magic != GDA_MAGIC || gda->ver < 2) {
		masternasid = 0;
		maxnodes = 0;
	} else {
		masternasid = gda->masternasid;
		maxnodes = (gsz - offsetof(gda_t, nasid)) / sizeof(int16_t);
		if (maxnodes > GDA_MAXNODES)
			maxnodes = GDA_MAXNODES;
		/* in M mode, there can't be more than 64 nodes anyway */
		if (kl_n_mode == 0 && maxnodes > 64)
			maxnodes = 64;
	}

	/*
	 * Scan all nodes configurations to find out CPU and memory
	 * information, starting with the master node.
	 */

	kl_scan_config(ip35, masternasid);
	for (node = 0; node < maxnodes; node++) {
		if (gda->nasid[node] < 0)
			continue;
		if (gda->nasid[node] == masternasid)
			continue;
		kl_scan_config(ip35, gda->nasid[node]);
	}
@


1.45
log
@Update KL structure definitions to match IP35 use of previously unused fields.
No functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.44 2010/03/20 16:22:55 miod Exp $	*/
d329 4
a332 1
	struct cpu_attach_args caa;
d342 7
a348 7
	bzero(&caa, sizeof caa);
	caa.caa_maa.maa_name = "cpu";
	caa.caa_maa.maa_nasid = currentnasid = masternasid;
	caa.caa_hw = &bootcpu_hwinfo;
	config_found(parent, &caa, ip27_print);
	caa.caa_maa.maa_name = "clock";
	config_found(parent, &caa.caa_maa, ip27_print);
d367 6
a372 1
	struct mainbus_attach_args maa;
d374 17
a390 4
	bzero(&maa, sizeof maa);
	maa.maa_name = "xbow";
	maa.maa_nasid = currentnasid = nasid;
	config_found(parent, &maa, ip27_print);
d398 2
@


1.44
log
@Add code to tell Origin 200 and Origin 2000 / Onyx 2 apart.
Use this to correctly handle the onboard IOC3 chip configuration on O2k
(two IOC3 chips to be able to provide four serial ports, and the other
 subdevices are split accross the two IOC3 chips).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.43 2010/03/07 13:44:26 miod Exp $	*/
d215 1
a215 1
	kl_scan_config(masternasid);
d221 1
a221 1
		kl_scan_config(gda->nasid[node]);
@


1.43
log
@Allow iockbc(4) and odysseey(4) to act as console devices and attach early;
this gives us working glass console on Fuel, as well as on Octane systems
with Odyssey graphics.
Joint work with jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.42 2010/01/09 20:33:16 miod Exp $	*/
d117 1
d121 1
a147 2
		    {
			static char unknown_model[20];
a150 1
		    }
d154 19
a172 5
		/*
		 * XXX need to look for Sn00 type in LBOOT space to tell
		 * XXX Origin 2000 and Origin 200 apart.
		 */
		hw_prod = "Origin 200";
@


1.42
log
@Define struct cpu_hwinfo, to hold hardware specific information about each
processor (instead of sys_config.cpu[]), and pass it in the attach_args
when attaching cpu devices.

This allows per-cpu information to be gathered late in the bootstrap process,
and not be limited by an arbitrary MAX_CPUS limit; this will suit IP27 and
IP35 systems better.

While there, use this information to make sure delay() uses the speed
information from the cpu it is invoked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.41 2009/12/04 22:48:11 miod Exp $	*/
d32 1
d62 1
d164 1
a164 1
	xbow_widget_id = ip27_widget_id;
d224 1
a224 1
	/* Constrain to the correct window */
d226 2
a227 3
	    cons->uart_base & 0xffffffffff000000UL;

	comconsaddr = cons->uart_base & 0x0000000000ffffffUL;
d240 3
a242 2
		 * IOC4 clocks are derived from the PCI clock, so we need to
		 * figure out whether this is an 66MHz or a 33MHz bus.
d244 1
a244 1
		ioc4_base = cons->uart_base & ~0xfffffUL; /* point to devio */
d319 2
d507 22
@


1.41
log
@Send `* pwr d' instead of `pwr d' on powerdown, to have L1 broadcast the
request to other bricks connected to our node.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.40 2009/11/29 17:03:53 miod Exp $	*/
a207 1
	kl_scan_done();
d314 1
a314 1
	struct mainbus_attach_args maa;
d322 7
a328 6
	bzero(&maa, sizeof maa);
	maa.maa_nasid = currentnasid = masternasid;
	maa.maa_name = "cpu";
	config_found(parent, &maa, ip27_print);
	maa.maa_name = "clock";
	config_found(parent, &maa, ip27_print);
@


1.40
log
@Send a powerdown command to L1 on IP35 if powerdown is requested.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.39 2009/11/25 22:25:37 jsing Exp $	*/
d537 1
a537 1
				l1_exec_command(masternasid, "pwr d");
@


1.39
log
@Unbreak GENERIC-IP27.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.38 2009/11/25 17:39:51 syuu Exp $	*/
d43 1
d51 2
d535 17
a551 5
		if (howto & RB_POWERDOWN)
			printf("Software powerdown not supported, "
			    "please switch off power manually.\n");
		for (;;) ;
		/* NOTREACHED */
@


1.38
log
@IP30 IPI implementation.
Also few xheart modification for SMP.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.37 2009/11/25 11:23:30 miod Exp $	*/
d791 1
@


1.37
log
@Allow xbow_intr_establish() callers to provide optional storage for the
struct intrhand, instead of having it malloc()'ed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.36 2009/11/18 19:05:51 miod Exp $	*/
d760 1
@


1.36
log
@Move widget register information apart from xbow software interface, and
update #include needs. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.35 2009/11/12 17:13:33 miod Exp $	*/
d70 1
a70 1
	    const char *);
d628 1
a628 1
    int level, const char *name)
d653 9
a661 3
	ih = malloc(sizeof(*ih), M_DEVBUF, M_NOWAIT);
	if (ih == NULL)
		return ENOMEM;
d721 2
a722 1
	free(ih, M_DEVBUF);
@


1.35
log
@Move the interrupt makemasks() code to the interrupt template; no functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.34 2009/11/07 22:48:37 miod Exp $	*/
a31 1
#include <mips64/arcbios.h>
d44 1
a45 1
#include <sgi/xbow/xbridgereg.h>
@


1.34
log
@In case an ioc(4) device has lost its NIC component, do not recognize it
as the onboard ioc device, if one has already been found on this node.

Also, on Origin 300, do not attempt to attach the PS/2 controller on the
onboard ioc(4) since PS/2 ports are not wired.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.33 2009/11/07 14:49:01 miod Exp $	*/
d77 2
a78 1
void	ip27_hub_intr_makemasks(void);
d672 4
a675 1
	ip27_hub_intr_makemasks();
d709 4
a712 1
	ip27_hub_intr_makemasks();
a730 64
/*
 * Recompute interrupt masks.
 */
void
ip27_hub_intr_makemasks()
{
	int irq, level, i;
	struct intrhand *q;
	uint intrlevel[HUBPI_NINTS + HUBPI_NINTS];

	/* First, figure out which levels each IRQ uses. */
	for (irq = 0; irq < HUBPI_NINTS; irq++) {
		uint levels = 0;
		for (q = hubpi_intrhand0[irq]; q; q = q->ih_next)
			levels |= 1 << q->ih_level;
		intrlevel[irq] = levels;

		levels = 0;
		for (q = hubpi_intrhand1[irq]; q; q = q->ih_next)
			levels |= 1 << q->ih_level;
		intrlevel[HUBPI_NINTS + irq] = levels;
	}

	/*
	 * Then figure out which IRQs use each level.
	 * Note that we make sure never to overwrite imask[IPL_HIGH], in
	 * case an interrupt occurs during intr_disestablish() and causes
	 * an unfortunate splx() while we are here recomputing the masks.
	 */
	for (level = IPL_NONE; level < IPL_HIGH; level++) {
		uint64_t irqs = 0;
		for (irq = 0; irq < HUBPI_NINTS; irq++)
			if (intrlevel[irq] & (1 << level))
				irqs |= 1UL << irq;
		hubpi_imask[level].hw[0] = irqs;

		irqs = 0;
		for (irq = 0; irq < HUBPI_NINTS; irq++)
			if (intrlevel[HUBPI_NINTS + irq] & (1 << level))
				irqs |= 1UL << irq;
		hubpi_imask[level].hw[1] = irqs;
	}

	/*
	 * There are tty, network and disk drivers that use free() at interrupt
	 * time, so vm > (tty | net | bio).
	 *
	 * Enforce a hierarchy that gives slow devices a better chance at not
	 * dropping data.
	 */
	for (i = 0; i < 2; i++) {
		hubpi_imask[IPL_NET].hw[i] |= hubpi_imask[IPL_BIO].hw[i];
		hubpi_imask[IPL_TTY].hw[i] |= hubpi_imask[IPL_NET].hw[i];
		hubpi_imask[IPL_VM].hw[i] |= hubpi_imask[IPL_TTY].hw[i];
		hubpi_imask[IPL_CLOCK].hw[i] |= hubpi_imask[IPL_VM].hw[i];

		/*
		 * These are pseudo-levels.
		 */
		hubpi_imask[IPL_NONE].hw[i] = 0;
		hubpi_imask[IPL_HIGH].hw[i] = -1;
	}
}

d752 1
d777 1
d782 1
d807 1
@


1.33
log
@Change sgi system identification from a single system type list, to a smaller
system type list (which really is the system family) and a subsystem type.

No functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.32 2009/11/06 07:37:49 miod Exp $	*/
d321 1
a321 1
	maa.maa_nasid = masternasid;
d348 1
a348 1
	maa.maa_nasid = nasid;
@


1.32
log
@When rebooting IP27 or IP35 systems, do not request the prom to skip diagnostics
anymore, as this causes the nsphy connected to the onboard iec to sometimes
disappear after a  warm boot.

Unfortunately this brings back the long reboot times on Origin 200, despite
still asking for no memory test.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.31 2009/10/26 20:14:42 miod Exp $	*/
a112 1
	int brick;
d119 1
a119 1
	ip35 = sys_config.system_type == SGI_O300;
d129 3
a131 3
		brick = (synergy0_0 & 0xf000) >> 12;
		switch (brick) {
		case 0x02:	/* Chimera */
d134 1
a134 1
		case 0x04:	/* Asterix */
d137 1
a137 1
		case 0x08:	/* Speedo2 */
d144 1
a144 1
			    "Unknown IP35 type %x", brick);
@


1.31
log
@Rename struct confargs to struct mainbus_attach_args for consistency and also
to prevent further abuse of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.30 2009/10/26 18:11:25 miod Exp $	*/
d542 1
a542 1
	promop |= GDA_PROMOP_MAGIC | GDA_PROMOP_NO_DIAGS |
@


1.30
log
@Add new xbow routines to explicitely trigger or clear an interrupt source,
instead of embedding that knowledge in xbridge(4); will be used elsewhere
shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.29 2009/10/23 21:19:17 miod Exp $	*/
d313 1
a313 1
	struct confargs nca;
d321 6
a326 6
	bzero(&nca, sizeof nca);
	nca.ca_nasid = masternasid;
	nca.ca_name = "cpu";
	config_found(parent, &nca, ip27_print);
	nca.ca_name = "clock";
	config_found(parent, &nca, ip27_print);
d345 1
a345 1
	struct confargs nca;
d347 4
a350 4
	bzero(&nca, sizeof nca);
	nca.ca_name = "xbow";
	nca.ca_nasid = nasid;
	config_found(parent, &nca, ip27_print);
d356 1
a356 1
	struct confargs *ca = aux;
d358 1
a358 1
	printf(" nasid %d", ca->ca_nasid);
@


1.29
log
@Fix logic in ip27_hub_intr_makemasks() to correctly {un,}mask interrupt
sources on level 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.28 2009/10/22 22:08:54 miod Exp $	*/
d73 2
d258 2
d711 12
@


1.28
log
@Completely overhaul interrupt handling on sgi. Cpu state now only stores a
logical IPL level, and per-platform (IP27/IP30/IP32) code will from the
necessary hardware mask registers.

This allows the use of more than one interrupt mask register. Also, the
generic (platform independent) interrupt code shrinks a lot, and the actual
interrupt handler chains and masking information is now per-platform private
data.

Interrupt dispatching is generated from a template; more routines will be
added to the template to reduce platform-specific changes and share as much
code as possible.

Tested on IP27, IP30, IP32 and IP35.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.27 2009/10/22 20:59:24 miod Exp $	*/
a602 1
#ifdef notyet
a611 1
#endif
d724 3
d729 1
a729 1
		intrlevel[irq] = levels;
@


1.27
log
@With the splx() changes, it is no longer necessary to remember which interrupt
sources were masked and saved in ci_ipending, as splx() will unmask what needs
to be unmasked anyway. ci_ipending only now needs to store pending soft
interrupts, so rename it to ci_softpending.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.26 2009/10/22 20:39:17 miod Exp $	*/
d73 2
a74 1
uint32_t ip27_hub_intr_handler(uint32_t, struct trap_frame *);
d76 1
d83 22
d257 2
a258 1
	set_intr(INTPRI_XBOWMUX, CR_INT_0, ip27_hub_intr_handler);
a587 2
uint64_t ip27_hub_intrmask;

d597 1
a597 4
	 * All interrupts will be serviced at hardware level 0,
	 * so the `level' argument can be ignored.
	 * On HUB, the low 7 bits of the level 0 interrupt register
	 * are reserved.
d599 15
a613 3
	for (bit = SPL_CLOCK - 1; bit >= 7; bit--)
		if ((ip27_hub_intrmask & (1 << bit)) == 0)
			break;
d615 1
a615 2
	if (bit < 7)
		return EINVAL;
d617 1
d629 2
a630 1
	struct intrhand *ih;
d633 1
a633 1
	if (intrbit < 0 || intrbit >= SPL_CLOCK)
d639 5
a643 1
	 * mask is large enough for all widgets.
d645 5
a649 1
	if (intrhand[intrbit] != NULL)
a663 1
	intrhand[intrbit] = ih;
d665 5
a669 1
	ip27_hub_intrmask |= 1UL << intrbit;
d672 1
a672 4
	/* XXX this assumes we run on cpu0 */
	IP27_LHUB_S(HUBPI_CPU0_IMR0,
	    IP27_LHUB_L(HUBPI_CPU0_IMR0) | (1UL << intrbit));
	(void)IP27_LHUB_L(HUBPI_IR0);
d680 1
a680 1
	struct intrhand *ih;
d684 1
a684 1
	if (intrbit < 0 || intrbit >= SPL_CLOCK)
d688 5
d695 1
a695 1
	if ((ih = intrhand[intrbit]) == NULL) {
d700 1
a700 4
	/* XXX this assumes we run on cpu0 */
	IP27_LHUB_S(HUBPI_CPU0_IMR0,
	    IP27_LHUB_L(HUBPI_CPU0_IMR0) & ~(1UL << intrbit));
	(void)IP27_LHUB_L(HUBPI_IR0);
d702 3
a704 1
	intrhand[intrbit] = NULL;
d706 1
a706 2
	ip27_hub_intrmask &= ~(1UL << intrbit);
	ip27_hub_intr_makemasks();
a708 2

	splx(s);
d717 1
a717 1
	int irq, level;
d719 1
a719 1
	uint32_t intrlevel[INTMASKSIZE];
d722 5
a726 3
	for (irq = 0; irq < INTMASKSIZE; irq++) {
		int levels = 0;
		for (q = intrhand[irq]; q; q = q->ih_next)
d731 9
a739 4
	/* Then figure out which IRQs use each level. */
	for (level = IPL_NONE; level < NIPLS; level++) {
		int irqs = 0;
		for (irq = 0; irq < INTMASKSIZE; irq++)
d741 8
a748 4
				irqs |= 1 << irq;
		if (level != IPL_NONE)
			irqs |= SINT_ALLMASK;
		imask[level] = irqs;
d758 5
a762 4
	imask[IPL_NET] |= imask[IPL_BIO];
	imask[IPL_TTY] |= imask[IPL_NET];
	imask[IPL_VM] |= imask[IPL_TTY];
	imask[IPL_CLOCK] |= imask[IPL_VM] | SPL_CLOCKMASK;
d764 6
a769 8
	/*
	 * These are pseudo-levels.
	 */
	imask[IPL_NONE] = 0;
	imask[IPL_HIGH] = -1;

	if(CPU_IS_PRIMARY(curcpu()))
		hw_setintrmask(0);
d773 1
a773 1
ip27_hub_splx(int newcpl)
d777 4
a780 4
	/* Update masks to new cpl. Order highly important! */
	__asm__ (" .set noreorder\n");
	ci->ci_cpl = newcpl;
	__asm__ (" sync\n .set reorder\n");
d782 1
a782 1
		hw_setintrmask(newcpl);
d784 1
a784 1
	if (ci->ci_softpending & ~newcpl)
d788 3
a790 10
uint32_t
ip27_hub_intr_handler(uint32_t hwpend, struct trap_frame *frame)
{
	uint64_t imr, isr;
	int icpl;
	int bit;
	uint32_t mask;
	struct intrhand *ih;
	int rc;
	struct cpu_info *ci = curcpu();
d792 53
a844 3
	/* XXX this assumes we run on cpu0 */
	isr = IP27_LHUB_L(HUBPI_IR0);
	imr = IP27_LHUB_L(HUBPI_CPU0_IMR0);
d846 1
a846 61
	isr &= imr;
	if (isr == 0)
		return 0;	/* not for us */

	/*
	 * Mask all pending interrupts.
	 */
	IP27_LHUB_S(HUBPI_CPU0_IMR0, imr & ~isr);
	(void)IP27_LHUB_L(HUBPI_IR0);

	/*
	 * If interrupts are spl-masked, mark them as pending only.
	 */
	if ((mask = isr & frame->cpl) != 0) {
		isr &= ~mask;
		imr &= ~mask;
	}

	/*
	 * Now process unmasked interrupts.
	 */
	if (isr != 0) {
		__asm__ (" .set noreorder\n");
		icpl = ci->ci_cpl;
		__asm__ (" sync\n .set reorder\n");

		/* XXX Rework this to dispatch in decreasing levels */
		for (bit = SPL_CLOCK - 1, mask = 1 << bit; bit >= 7;
		    bit--, mask >>= 1) {
			if ((isr & mask) == 0)
				continue;

			rc = 0;
			for (ih = intrhand[bit]; ih != NULL; ih = ih->ih_next) {
				splraise(imask[ih->ih_level]);
				ih->frame = frame;
				if ((*ih->ih_fun)(ih->ih_arg) != 0) {
					rc = 1;
					ih->ih_count.ec_count++;
				}
			}
			if (rc == 0)
				printf("spurious interrupt, source %d\n", bit);

			if ((isr ^= mask) == 0)
				break;
		}

		/*
		 * Reenable interrupts which have been serviced.
		 */
		IP27_LHUB_S(HUBPI_CPU0_IMR0, imr);
		(void)IP27_LHUB_L(HUBPI_IR0);
		
		__asm__ (" .set noreorder\n");
		ci->ci_cpl = icpl;
		__asm__ (" sync\n .set reorder\n");
	}

	return CR_INT_0;
}
d849 1
a849 1
hw_setintrmask(uint32_t m)
d851 3
a853 1
	IP27_LHUB_S(HUBPI_CPU0_IMR0, ip27_hub_intrmask & ~((uint64_t)m));
d855 3
@


1.26
log
@The recent cleanups make blatantly visible that the pending_int handler
does almost exactly what splx() is doing if ipending is zero, and triggers
soft interrupts as well.

So don't bother checking for ipending in splx, and always invoke pending_int,
which gets renamed as splx_handler for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.25 2009/10/22 20:05:28 miod Exp $	*/
d732 1
a732 1
	if (ci->ci_ipending & SINT_ALLMASK & ~newcpl)
a764 1
		atomic_setbits_int(&ci->ci_ipending, mask);
a772 2
		atomic_clearbits_int(&ci->ci_ipending, isr);

@


1.25
log
@Replace intrmask_t with uint32_t. This types only describes interrupt masks
in the coprocessor 0 status register (coupled with ICR on rm7k/rm9k), and
may be completely alien to real hardware interrupt masks, so don't make
things unnecessary confusing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.24 2009/10/22 18:35:28 miod Exp $	*/
d75 1
a75 1
void	ip27_hub_do_pending_int(int);
d234 1
a234 1
	register_pending_int_handler(ip27_hub_do_pending_int);
d721 1
a721 1
ip27_hub_do_pending_int(int newcpl)
@


1.24
log
@Correctly initialize the second HUB PI interrupt and calias registers on
IP35 systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.23 2009/10/16 00:15:49 miod Exp $	*/
d73 1
a73 1
intrmask_t ip27_hub_intr_handler(intrmask_t, struct trap_frame *);
d677 1
a677 1
	intrmask_t intrlevel[INTMASKSIZE];
d736 2
a737 2
intrmask_t
ip27_hub_intr_handler(intrmask_t hwpend, struct trap_frame *frame)
d742 1
a742 1
	intrmask_t mask;
d817 1
a817 1
hw_setintrmask(intrmask_t m)
@


1.23
log
@Get serial console speed from prom, and use it instead of hardcoding 9600 bps,
on all systems but O2 (to catch up soon). Also use the IOC4 MCR register to
figure out the IOC4 clock, instead of checking the widget control register,
to be consistent with iof(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.22 2009/10/14 20:21:16 miod Exp $	*/
d246 8
a253 1
	/* XXX do the other two cpus on IP35 */
d269 6
@


1.22
log
@On IP30 and IP35 systems, try harder to figure out exactly what model we are
running on, and report this both as the hw.product sysctl and in dmesg.
Fuel and Origin 350 are no longer reported as being Origin 300 systems!
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.21 2009/10/07 08:35:47 syuu Exp $	*/
d48 1
a85 1
	uint32_t ctrl;
d88 1
d192 1
d197 1
a197 1
	    kl_get_console_base() & 0xffffffffff000000UL;
d199 4
a202 1
	comconsaddr = kl_get_console_base() & 0x0000000000ffffffUL;
a205 1
		bios_printf("IOC3 style console\n");
d208 3
a213 4
		 * Note that this assumes the IOC4 is connected to a Bridge
		 * or PIC widget, and that even if this is a PIC widget,
		 * the common widget register space can be correctly read
		 * with non-doubleword aligned word reads.
d215 6
a220 15
		comconsfreq = 66666667;
		bios_printf("IOC4 style console\n");
		ctrl = *(volatile uint32_t *)
		    ((sys_config.console_io.bus_base + WIDGET_CONTROL) | 4);
		switch (ctrl & BRIDGE_WIDGET_CONTROL_SPEED_MASK) {
		default:
			bios_printf("WARNING! UNRECOGNIZED IOC4 SPEED\n"
			    "ASSUMING 66MHZ\n");
			break;
		case BRIDGE_WIDGET_CONTROL_SPEED_66MHZ:
			break;
		case BRIDGE_WIDGET_CONTROL_SPEED_33MHZ:
			comconsfreq >>= 1;
			break;
		}
@


1.21
log
@ipending, cpl moved into cpu_info
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.20 2009/10/07 04:17:48 miod Exp $	*/
d50 2
d86 2
d95 36
d722 1
a722 1
	if(CPU_IS_PRIMARY(ci))
@


1.20
log
@Small steps towards getting the serial clock correct on IOC4 serial ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.19 2009/08/18 19:31:56 miod Exp $	*/
d669 2
a670 1
	hw_setintrmask(0);
d676 2
d680 1
a680 1
	cpl = newcpl;
d682 2
a683 1
	hw_setintrmask(newcpl);
d685 1
a685 1
	if (ipending & SINT_ALLMASK & ~newcpl)
d698 1
d718 1
a718 1
		atomic_setbits_int(&ipending, mask);
d727 1
a727 1
		atomic_clearbits_int(&ipending, isr);
d730 1
a730 1
		icpl = cpl;
d762 1
a762 1
		cpl = icpl;
@


1.19
log
@Blind support for SGI PIC PCI-X controller found on Origin 350 and Tezro
systems. PIC was supposed to be mostly XBridge compatible, but a silicon
bug prevents it from working correctly if 32 bit register writes are used,
so the xbridge(4) code now needs to issue 64 bit writes.

In order to make this a bit more transparent, rebase all widget registers to
a 8 byte boundary, and provide a few inline accessors which will do the right
thing if you want 32 bit writes.

Tested to not cause regressions on Octane, Origin 200 and Fuel; covering
Bridge < 4, Bridge >= 4 and XBridge flavours.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.18 2009/07/25 19:17:25 miod Exp $	*/
d83 1
d143 6
a148 1
	 * This assumes IOC3 is accessible through a widget small window.
d151 2
a152 1
	xbow_build_bus_space(&sys_config.console_io, 0, 8 /* whatever */);
d158 30
a187 1
	comconsfreq = 22000000 / 3;
@


1.18
log
@On multiple-node systems, be sure to broadcast reboot requests to all nodes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.17 2009/07/11 19:56:04 miod Exp $	*/
d384 1
a384 1
	if (guarded_read_4(wpa + WIDGET_ID, &id) != 0)
@


1.17
log
@When rebooting, pass a request to the PROM for it to skip diagnostics and
memory initialization. This reduces memory test and initialization time
from a "in soviet russia, memory test you" time of over 2 minutes for 1GB
on Origin 200, to a more reasonable 12 seconds (and on a Fuel with 2GB,
time goes down from 6 seconds to under a second).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.16 2009/07/06 22:46:43 miod Exp $	*/
d401 2
d421 5
a425 1
		return;	/* caller will spin */
d451 2
a452 4
		IP27_LHUB_S(HUBNIBASE_IP35 + HUBNI_RESET_ENABLE,
		    NI_RESET_ENABLE);
		IP27_LHUB_S(HUBNIBASE_IP35 + HUBNI_RESET,
		    NI_RESET_LOCAL_IP35 | NI_RESET_ACTION_IP35);
d454 17
a470 4
		IP27_LHUB_S(HUBNIBASE_IP27 + HUBNI_RESET_ENABLE,
		    NI_RESET_ENABLE);
		IP27_LHUB_S(HUBNIBASE_IP27 + HUBNI_RESET,
		    NI_RESET_LOCAL_IP27 | NI_RESET_ACTION_IP27);
d472 2
@


1.16
log
@Almost rewrite xbridge PCI resource allocation:
- introduce an interface for widget drivers to ask the xbow to map arbitrary
  views of their address space, in addition to the low 16MB. This operation
  may fail or map a subset range of what the caller asked for, depending on
  the platform we're running on.
- use this in xbridge to set up views on the direct memory and i/o spaces,
  to map devices resources when they don't fit in one of the devio small
  ranges (limited to 2MB anyway). These views are only allocated when
  devio can't do the job, so as not to consume too many resources on
  Origin family systems where such views are scarce resources (and
  shared accross the whole crossbow).

This makes pci devices with large resource needs configure correctly.

While there, fix programming of 64 bit memory BAR; this makes bge(4)
work.

Tested on Octane (with Bridge revision < 4 and >= 4), Origin 200 (Bridge >= 4)
and Fuel (XBridge).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.15 2009/07/01 21:56:38 miod Exp $	*/
d400 2
d407 3
a409 2
	 * of the Hub space.  Unfortunately there is no known way
	 * to tell the PROM which action we want it to take afterwards.
d412 7
a418 1
	if (howto & RB_HALT)
d420 23
@


1.15
log
@The widget mapping code has been written back when I was only working on
Octane support. The Octane being a single-node system, address space is
ludicrous enough to allow the whole address space of every widget to be
directly accessible in whole, using the address bits reserved to nasid.

However, on IP27 and IP35, things do not work this way - while we still have
the low 16MB address space of each widget available (the so-called
``short window''), access to other parts of the wiget address space is done
through translation slots (IOTTE) at the Hub I/O space level, on a per-node
basis.

Given the imminent release lock, give up completely on ``large'' mappings
of widgets, and restrict ourselves to short window operation, all the time
(thus reinforcing the use of devio registers to map pci resources on xbridge).
A proper interface to request mappings of specific widget areas, either
directly on Octane, or through IOTTE if available on Origin, will appear
post-release.

No functional change (except from silently repairing Octane support which the
previous xbridge commit silently broke).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.14 2009/06/13 21:48:03 miod Exp $	*/
d54 1
d91 1
d101 1
a101 1
	kl_init(ip35 ? HUBNI_IP35 : HUBNI_IP27);
d266 1
a266 1
		return ip27_widget_long(nasid, 6);
d268 2
a269 1
	return ((uint64_t)(widget) << 24) | ((uint64_t)(nasid) << 32) | io_base;
d273 1
a273 1
ip27_widget_long(int16_t nasid, u_int widget)
d275 90
a364 2
	return ((uint64_t)(widget + 1) << xbow_long_shift) |
	    ((uint64_t)(nasid) << 32) | io_base;
d413 4
a416 3
		IP27_LHUB_S(HUBNI_IP35 + HUBNI_RESET_ENABLE, NI_RESET_ENABLE);
		IP27_LHUB_S(HUBNI_IP35 + HUBNI_RESET,
		    NI_RESET_LOCAL | NI_RESET_ACTION);
d418 4
a421 3
		IP27_LHUB_S(HUBNI_IP27 + HUBNI_RESET_ENABLE, NI_RESET_ENABLE);
		IP27_LHUB_S(HUBNI_IP27 + HUBNI_RESET,
		    NI_RESET_LOCAL | NI_RESET_ACTION);
@


1.14
log
@Enumerate all available nodes for hardware on IP27/IP35 systems; works to some
extent, but isp(4) on other nodes do not work correctly yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.13 2009/06/13 18:47:30 miod Exp $	*/
d58 2
d89 1
a89 2
	xbow_widget_short = ip27_widget_short;
	xbow_widget_long = ip27_widget_long;
d143 2
a144 2
	xbow_build_bus_space(&sys_config.console_io, 0, 8 /* whatever */, 0);
	/* Constrain to a short window */
@


1.13
log
@Figure out which nodes are connected, and use all of their memory for now;
other hardware resources will follow shortly.
Tested on a dual-Origin 200 setup.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.12 2009/06/13 16:28:11 miod Exp $	*/
d59 1
d61 1
d71 2
a77 1
	gda_t *gda;
d79 1
a79 1
	uint node, masternode, maxnodes;
d110 1
a110 1
		masternode = 0;
d113 1
a113 1
		masternode = gda->masternasid;
d127 1
a127 1
	kl_scan_config(masternode);
d129 1
a129 1
		if (node == masternode)
d131 1
a131 1
		if (gda->nasid[node] < 0)
d192 57
d317 2
a318 4
	if (howto & RB_HALT) {
		if (howto & RB_POWERDOWN)
			return;	/* caller will spin */
	}
@


1.12
log
@Shuffle and rename HUB defines for consistency, no functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.11 2009/06/10 18:04:25 miod Exp $	*/
d20 3
a22 1
 * Origin 200 / Origin 2000 / Onyx 2 (IP27) specific code.
d74 4
a77 1
	kl_nmi_t *nmi;
d90 5
d100 22
a121 2
	 * Scan this node's configuration to find out CPU and memory
	 * information.
d124 8
a131 1
	kl_scan_config(0);
d175 1
a175 1
	nmi = IP27_KLNMI_HDR(0);
@


1.11
log
@In the NMI handler, always print EPC even if we're going to drop into ddb.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.10 2009/05/28 18:03:55 miod Exp $	*/
d85 1
a85 1
	kl_init();
d127 6
a132 6
	IP27_LHUB_S(HUB_CPU0_IMR0, 0);
	IP27_LHUB_S(HUB_CPU0_IMR1, 0);
	IP27_LHUB_S(HUB_CPU1_IMR0, 0);
	IP27_LHUB_S(HUB_CPU1_IMR1, 0);
	(void)IP27_LHUB_L(HUB_IR0);
	(void)IP27_LHUB_L(HUB_IR1);
d147 2
a148 2
	IP27_LHUB_S(PI_REGION_PRESENT, 1);
	IP27_LHUB_S(PI_CALIAS_SIZE, PI_CALIAS_SIZE_0);
d226 3
a228 3
		IP27_LHUB_S(HUB_NI_IP35 + HUB_NI_RESET_ENABLE, RESET_ENABLE);
		IP27_LHUB_S(HUB_NI_IP35 + HUB_NI_RESET,
		    RESET_LOCAL | RESET_ACTION);
d230 3
a232 3
		IP27_LHUB_S(HUB_NI_IP27 + HUB_NI_RESET_ENABLE, RESET_ENABLE);
		IP27_LHUB_S(HUB_NI_IP27 + HUB_NI_RESET,
		    RESET_LOCAL | RESET_ACTION);
d306 3
a308 3
	IP27_LHUB_S(HUB_CPU0_IMR0,
	    IP27_LHUB_L(HUB_CPU0_IMR0) | (1UL << intrbit));
	(void)IP27_LHUB_L(HUB_IR0);
d332 3
a334 3
	IP27_LHUB_S(HUB_CPU0_IMR0,
	    IP27_LHUB_L(HUB_CPU0_IMR0) & ~(1UL << intrbit));
	(void)IP27_LHUB_L(HUB_IR0);
d420 2
a421 2
	isr = IP27_LHUB_L(HUB_IR0);
	imr = IP27_LHUB_L(HUB_CPU0_IMR0);
d430 2
a431 2
	IP27_LHUB_S(HUB_CPU0_IMR0, imr & ~isr);
	(void)IP27_LHUB_L(HUB_IR0);
d477 2
a478 2
		IP27_LHUB_S(HUB_CPU0_IMR0, imr);
		(void)IP27_LHUB_L(HUB_IR0);
d491 2
a492 2
	IP27_LHUB_S(HUB_CPU0_IMR0, ip27_hub_intrmask & ~((uint64_t)m));
	(void)IP27_LHUB_L(HUB_IR0);
@


1.10
log
@Poor man's reset code for IP27/IP35 where returning through ARCBios doesn't
work, even after restoring TLB and exception code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.9 2009/05/28 18:02:43 miod Exp $	*/
d528 2
a530 1
	printf("NMI\n");
a531 3
#else
	printf("NMI, PC = %p RA = %p SR = %08x EPC = %p\n",
	    nmi_frame.pc, nmi_frame.ra, nmi_frame.sr, epc);
@


1.9
log
@Handle NMI interrupts on IP27/IP35, gives us a change to play with ddb,
and then restart system (NMI on these systems aren't intended to be
recoverable).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.8 2009/05/27 19:00:19 miod Exp $	*/
d48 2
d54 2
d83 2
d202 32
@


1.8
log
@Rework KL board and component enumeration, to allow it to be used from
drivers with callback routines. While there, skip disabled or failed
components.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.7 2009/05/21 16:25:26 miod Exp $	*/
d27 1
d31 1
d41 1
a45 2
#include <sgi/pci/iocreg.h>

d53 1
d63 2
d68 2
d73 2
d128 15
d455 44
@


1.7
log
@If we had interrupts to service and interrupts to mark as pending, after
servicing interrupts, correctly mask the other (marked as pending)
interrupts in imr. Otherwise we get another interrupt immediately for nothing
(which updates imr correctly the second time).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.6 2009/05/15 22:59:07 miod Exp $	*/
d71 4
d79 1
d81 1
a81 3

	if (kl_n_mode != 0)
		xbow_long_shift = 28;
d85 1
a85 7
	 * This assumes BRIDGE is on widget 8 and IOC3 is mapped in
	 * memory space at address 0x600000. Although on IP35 it is
	 * actually widget 15...
	 *
	 * XXX And that 0x600000 should be computed from the first BAR
	 * XXX of the IOC3 in pci configuration space. Joy. I'll get there
	 * XXX eventually.
a86 1
	xbow_build_bus_space(&sys_config.console_io, 0, 8, 0);
d88 1
d101 1
d112 1
d119 1
@


1.6
log
@Don't forget to make sure IMR writes hit the hardware (by reading back
from the Hub) before continuing (this was missing in one place).
Also exit early from the interrupt mask handling loop if all sources have
been serviced.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.5 2009/05/15 06:29:37 miod Exp $	*/
d83 2
a84 1
	 * memory space at address 0x600000.
d378 1
@


1.5
log
@Do not explicitely clear interrupt sources in the interrupt handler, but
ask the Bridge to do this for us; this makes the initial interrupt deadlock
workaround functional again.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.4 2009/05/08 18:36:48 miod Exp $	*/
d406 3
d415 1
@


1.4
log
@Make interrupt handling code closer to IP30 XHeart code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.3 2009/05/02 21:28:08 miod Exp $	*/
a405 3

			IP27_LHUB_S(HUB_IR_CHANGE, HUB_IR_CLR | bit);
			(void)IP27_LHUB_L(HUB_IR0);
@


1.3
log
@Explain why the short window of widget #0 needs to be accessed through a
large window IOTTE.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.2 2009/04/15 18:46:40 miod Exp $	*/
d235 3
a237 1
	evcount_attach(&ih->ih_count, name, &ih->ih_level, &evcount_intr);
d351 1
d355 1
d366 7
a372 2
	 * If interrupts are spl-masked, mark them as pending and mask
	 * them in hardware.
a375 3
		/* XXX this assumes we run on cpu0 */
		IP27_LHUB_S(HUB_CPU0_IMR0, imr & ~mask);
		(void)IP27_LHUB_L(HUB_IR0);
a381 2
	mask = isr & ~frame->cpl;
	atomic_clearbits_int(&ipending, mask);
d383 7
d395 1
d397 4
a400 1
				if ((*ih->ih_fun)(ih->ih_arg) != 0)
d402 1
d404 2
d410 9
@


1.2
log
@A firsh shot at IP27 interrupts; currently the code assumes it runs on
the first cpu on dual-cpu boards; this will be fixed later. Just don't
disable it at the prom.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip27_machdep.c,v 1.1 2009/04/13 21:17:54 miod Exp $	*/
d128 7
d136 1
a136 1
		return ip27_widget_long(nasid, 6);	/* ??? */
@


1.1
log
@The start of Origin 200 support. Based on some code contributed by pefo@@
some years ago for KL enumeration, building on the existing XBow support
to limit ourselves to a single node for now.

This is a work-in-progress; it currently lacks complete interrupt code,
as well as PCI resource management. And there are likely bugs creeping
inside.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 2008 Miodrag Vallat.
d39 1
d54 2
a55 1
int	ip27_hub_intr_establish(int (*)(void *), void *, int, int, const char *);
d109 10
d184 2
a185 3
	 * On HUB, the low 63 bits of the interrupt register
	 * are level 0 sources. However, we'll only consider the
	 * lowest 32 bits for now.
d187 1
a187 1
	for (bit = SPL_CLOCK - 1; bit >= 0; bit--)
d191 1
a191 1
	if (bit < 0)
d213 1
a213 1
	 * HEART interrupts are not supposed to be shared - the interrupt
d234 4
a237 1
	/* TODO frob hardware */
d260 4
a263 1
	/* TODO frob hardware */
a274 2
intrmask_t ip27_hub_intem = 0;

a321 2
	/* Lastly, determine which IRQs are actually in use. */
	ip27_hub_intem = ip27_hub_intrmask & 0x00000000ffffffffL;
d346 3
a348 3
	/* TODO frob hardware */
	isr = 0;
	imr = 0;
d360 3
a362 1
		/* TODO frob hardware */
d371 13
a383 8
	for (bit = SPL_CLOCK - 1, mask = 1 << bit; bit >= 0;
	    bit--, mask >>= 1) {
		if ((isr & mask) == 0)
			continue;

		for (ih = intrhand[bit]; ih != NULL; ih = ih->ih_next) {
			if ((*ih->ih_fun)(ih->ih_arg) != 0)
				ih->ih_count.ec_count++;
d393 2
a394 1
	/* TODO frob hardware */
@

