head	1.154;
access;
symbols
	OPENBSD_6_0:1.151.0.2
	OPENBSD_6_0_BASE:1.151
	OPENBSD_5_9:1.150.0.4
	OPENBSD_5_9_BASE:1.150
	OPENBSD_5_8:1.150.0.6
	OPENBSD_5_8_BASE:1.150
	OPENBSD_5_7:1.150.0.2
	OPENBSD_5_7_BASE:1.150
	OPENBSD_5_6:1.148.0.4
	OPENBSD_5_6_BASE:1.148
	OPENBSD_5_5:1.133.0.4
	OPENBSD_5_5_BASE:1.133
	OPENBSD_5_4:1.132.0.4
	OPENBSD_5_4_BASE:1.132
	OPENBSD_5_3:1.132.0.2
	OPENBSD_5_3_BASE:1.132
	OPENBSD_5_2:1.127.0.2
	OPENBSD_5_2_BASE:1.127
	OPENBSD_5_1_BASE:1.112
	OPENBSD_5_1:1.112.0.4
	OPENBSD_5_0:1.112.0.2
	OPENBSD_5_0_BASE:1.112
	OPENBSD_4_9:1.106.0.2
	OPENBSD_4_9_BASE:1.106
	OPENBSD_4_8:1.105.0.2
	OPENBSD_4_8_BASE:1.105
	OPENBSD_4_7:1.100.0.2
	OPENBSD_4_7_BASE:1.100
	OPENBSD_4_6:1.74.0.2
	OPENBSD_4_6_BASE:1.74
	OPENBSD_4_5:1.61.0.2
	OPENBSD_4_5_BASE:1.61
	OPENBSD_4_4:1.60.0.2
	OPENBSD_4_4_BASE:1.60
	OPENBSD_4_3:1.54.0.2
	OPENBSD_4_3_BASE:1.54
	OPENBSD_4_2:1.47.0.2
	OPENBSD_4_2_BASE:1.47
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10;
locks; strict;
comment	@ * @;


1.154
date	2017.01.06.15.37.44;	author fcambus;	state Exp;
branches;
next	1.153;
commitid	0l7pHJQOGB2InAEV;

1.153
date	2016.10.09.11.25.40;	author tom;	state Exp;
branches;
next	1.152;
commitid	DfYvEDcFmu1LY9q1;

1.152
date	2016.08.16.13.03.58;	author visa;	state Exp;
branches;
next	1.151;
commitid	6TiwRQZbesPVamIE;

1.151
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.150;
commitid	cyYKarj4qRTft4gD;

1.150
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.149;
commitid	qHQiR2HLROzvZr7B;

1.149
date	2014.09.20.09.28.24;	author kettenis;	state Exp;
branches;
next	1.148;
commitid	IFRB8AkvBMXMTAKW;

1.148
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.147;
commitid	7QO4UJr3EKVAMc8t;

1.147
date	2014.07.13.22.53.39;	author uebayasi;	state Exp;
branches;
next	1.146;
commitid	wsdp3qtXGjMj98oD;

1.146
date	2014.07.13.22.13.07;	author uebayasi;	state Exp;
branches;
next	1.145;
commitid	qYPOd6Qi4aRBKldK;

1.145
date	2014.07.11.22.28.05;	author uebayasi;	state Exp;
branches;
next	1.144;
commitid	fOXKrBuMmlMGQdd4;

1.144
date	2014.07.10.21.46.03;	author mpi;	state Exp;
branches;
next	1.143;
commitid	iYq3Z1ZWDKR3sS9G;

1.143
date	2014.07.10.20.15.27;	author uebayasi;	state Exp;
branches;
next	1.142;
commitid	YzvTa4t6mddz7Mh4;

1.142
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.141;
commitid	xpsLTYRIkonFtkr1;

1.141
date	2014.07.10.12.13.49;	author uebayasi;	state Exp;
branches;
next	1.140;
commitid	aofvn6ceiucgjg4N;

1.140
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.139;
commitid	eA4Y0YE1IUzj6hpW;

1.139
date	2014.05.30.13.46.16;	author mpi;	state Exp;
branches;
next	1.138;

1.138
date	2014.05.19.21.18.42;	author miod;	state Exp;
branches;
next	1.137;

1.137
date	2014.04.03.08.07.16;	author mpi;	state Exp;
branches;
next	1.136;

1.136
date	2014.03.22.00.01.04;	author miod;	state Exp;
branches;
next	1.135;

1.135
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.134;

1.134
date	2014.03.09.10.12.17;	author miod;	state Exp;
branches;
next	1.133;

1.133
date	2013.09.28.12.40.31;	author miod;	state Exp;
branches;
next	1.132;

1.132
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.131;

1.131
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.130;

1.130
date	2012.09.29.21.46.02;	author miod;	state Exp;
branches;
next	1.129;

1.129
date	2012.09.29.19.24.31;	author miod;	state Exp;
branches;
next	1.128;

1.128
date	2012.09.29.19.11.08;	author miod;	state Exp;
branches;
next	1.127;

1.127
date	2012.06.24.20.29.46;	author miod;	state Exp;
branches;
next	1.126;

1.126
date	2012.06.24.16.26.04;	author miod;	state Exp;
branches;
next	1.125;

1.125
date	2012.05.29.17.37.09;	author mikeb;	state Exp;
branches;
next	1.124;

1.124
date	2012.05.27.14.27.10;	author miod;	state Exp;
branches;
next	1.123;

1.123
date	2012.05.10.21.28.31;	author miod;	state Exp;
branches;
next	1.122;

1.122
date	2012.04.21.19.38.20;	author miod;	state Exp;
branches;
next	1.121;

1.121
date	2012.04.21.19.19.06;	author miod;	state Exp;
branches;
next	1.120;

1.120
date	2012.04.17.09.23.14;	author landry;	state Exp;
branches;
next	1.119;

1.119
date	2012.04.16.22.23.06;	author miod;	state Exp;
branches;
next	1.118;

1.118
date	2012.04.09.16.54.40;	author miod;	state Exp;
branches;
next	1.117;

1.117
date	2012.04.06.18.24.29;	author miod;	state Exp;
branches;
next	1.116;

1.116
date	2012.04.03.21.17.35;	author miod;	state Exp;
branches;
next	1.115;

1.115
date	2012.03.28.20.44.23;	author miod;	state Exp;
branches;
next	1.114;

1.114
date	2012.03.25.13.52.52;	author miod;	state Exp;
branches;
next	1.113;

1.113
date	2012.03.15.18.57.22;	author miod;	state Exp;
branches;
next	1.112;

1.112
date	2011.06.26.22.40.00;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2011.06.24.19.47.49;	author naddy;	state Exp;
branches;
next	1.110;

1.110
date	2011.06.05.19.41.08;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2011.05.30.22.25.22;	author oga;	state Exp;
branches;
next	1.108;

1.108
date	2011.04.21.18.09.49;	author miod;	state Exp;
branches;
next	1.107;

1.107
date	2011.04.03.22.32.39;	author miod;	state Exp;
branches;
next	1.106;

1.106
date	2010.10.24.15.40.03;	author miod;	state Exp;
branches;
next	1.105;

1.105
date	2010.06.27.13.28.46;	author miod;	state Exp;
branches;
next	1.104;

1.104
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.103;

1.103
date	2010.06.10.17.54.13;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2010.04.28.21.26.47;	author miod;	state Exp;
branches;
next	1.101;

1.101
date	2010.04.28.16.20.28;	author syuu;	state Exp;
branches;
next	1.100;

1.100
date	2010.03.03.12.25.09;	author jsing;	state Exp;
branches;
next	1.99;

1.99
date	2010.02.13.14.07.30;	author miod;	state Exp;
branches;
next	1.98;

1.98
date	2010.01.22.21.45.26;	author miod;	state Exp;
branches;
next	1.97;

1.97
date	2010.01.09.23.34.29;	author miod;	state Exp;
branches;
next	1.96;

1.96
date	2010.01.09.20.33.16;	author miod;	state Exp;
branches;
next	1.95;

1.95
date	2010.01.08.01.35.52;	author syuu;	state Exp;
branches;
next	1.94;

1.94
date	2009.12.12.20.07.10;	author miod;	state Exp;
branches;
next	1.93;

1.93
date	2009.12.07.19.05.59;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2009.12.07.18.51.26;	author miod;	state Exp;
branches;
next	1.91;

1.91
date	2009.12.03.06.02.38;	author miod;	state Exp;
branches;
next	1.90;

1.90
date	2009.11.19.20.16.27;	author miod;	state Exp;
branches;
next	1.89;

1.89
date	2009.11.19.20.13.54;	author miod;	state Exp;
branches;
next	1.88;

1.88
date	2009.11.19.06.06.51;	author miod;	state Exp;
branches;
next	1.87;

1.87
date	2009.11.07.18.56.55;	author miod;	state Exp;
branches;
next	1.86;

1.86
date	2009.11.07.14.49.01;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2009.10.16.00.15.49;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2009.10.14.20.21.16;	author miod;	state Exp;
branches;
next	1.83;

1.83
date	2009.09.30.06.22.00;	author syuu;	state Exp;
branches;
next	1.82;

1.82
date	2009.08.19.12.33.06;	author jasper;	state Exp;
branches;
next	1.81;

1.81
date	2009.08.11.19.17.17;	author miod;	state Exp;
branches;
next	1.80;

1.80
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.79;

1.79
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.78;

1.78
date	2009.08.06.21.06.32;	author miod;	state Exp;
branches;
next	1.77;

1.77
date	2009.08.06.21.05.50;	author miod;	state Exp;
branches;
next	1.76;

1.76
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.75;

1.75
date	2009.07.22.21.29.05;	author miod;	state Exp;
branches;
next	1.74;

1.74
date	2009.06.15.17.01.26;	author beck;	state Exp;
branches;
next	1.73;

1.73
date	2009.06.13.21.48.03;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2009.06.04.16.52.12;	author miod;	state Exp;
branches;
next	1.71;

1.71
date	2009.06.03.21.30.20;	author beck;	state Exp;
branches;
next	1.70;

1.70
date	2009.05.28.18.03.55;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2009.05.28.18.02.43;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2009.05.25.17.10.40;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2009.05.22.20.37.54;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2009.05.21.16.28.12;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2009.05.08.18.42.07;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2009.04.25.20.38.32;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2009.04.22.04.40.29;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2009.04.19.12.52.33;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2008.12.30.05.33.17;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2008.05.18.07.36.10;	author jsing;	state Exp;
branches;
next	1.59;

1.59
date	2008.05.04.09.57.47;	author martin;	state Exp;
branches;
next	1.58;

1.58
date	2008.04.29.12.47.19;	author jsing;	state Exp;
branches;
next	1.57;

1.57
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2008.04.07.22.32.46;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2008.03.23.17.05.41;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2008.02.20.19.13.38;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2008.02.20.18.46.20;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2007.12.18.08.29.02;	author jasper;	state Exp;
branches;
next	1.51;

1.51
date	2007.12.14.10.13.17;	author jsing;	state Exp;
branches;
next	1.50;

1.50
date	2007.12.07.13.07.44;	author jsing;	state Exp;
branches;
next	1.49;

1.49
date	2007.10.22.16.59.56;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2007.10.18.04.32.27;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2007.07.18.20.05.25;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2007.07.16.20.20.09;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.21.20.17.32;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.17.12.59.52;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.29.20.36.48;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.27.17.31.57;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.27.14.26.44;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.23.20.33.47;	author pvalchev;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.03.19.34.01;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2007.04.26.17.04.39;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2007.04.26.17.02.40;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2007.04.10.16.54.46;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2007.02.26.21.30.18;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2006.08.11.08.17.37;	author jasper;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.07.18.58.53;	author robert;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.14.22.42.01;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.04.22.02.47;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.04.20.25.34;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.04.20.23.11;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.04.20.17.12;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.19.21.37.49;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.12.20.58.49;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.06.14.26.52;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.02.20.15.39.04;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.18.15.03.38;	author grange;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.14.09.07.49;	author grange;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.13.15.34.46;	author grange;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.02.19.37.25;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.10.22.10.15.42;	author pefo;	state Exp;
branches;
next	1.17;

1.17
date	2004.10.20.12.49.15;	author pefo;	state Exp;
branches;
next	1.16;

1.16
date	2004.09.27.18.51.18;	author pefo;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.22.08.01.58;	author pefo;	state Exp;
branches;
next	1.14;

1.14
date	2004.09.21.08.55.20;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.21.05.51.15;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.20.10.31.16;	author pefo;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.16.19.38.30;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.09.22.11.39;	author pefo;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.09.10.25.52;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.26.13.30.25;	author pefo;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.23.14.28.39;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.11.17.06.14;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.10.19.16.18;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.10.18.47.22;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.12.32.14;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.09.14.57.26;	author pefo;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.21.12.19;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.154
log
@Ansify cpu_sysctl() on mips64 platforms.

OK patrick@@, visa@@, jasper@@, mpi@@
@
text
@/*	$OpenBSD: machdep.c,v 1.153 2016/10/09 11:25:40 tom Exp $ */

/*
 * Copyright (c) 2003-2004 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/msgbuf.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>
#include <sys/exec_elf.h>
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
#ifdef SYSVSEM
#include <sys/sem.h>
#endif

#include <net/if.h>

#include <uvm/uvm_extern.h>

#include <machine/db_machdep.h>
#include <ddb/db_interface.h>

#include <mips64/cache.h>
#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/frame.h>
#include <machine/autoconf.h>
#include <machine/memconf.h>
#include <machine/regnum.h>
#ifdef TGT_ORIGIN
#include <machine/mnode.h>
#endif
#if defined(TGT_INDY) || defined(TGT_INDIGO2)
CACHE_PROTOS(ip22)
#endif
#ifdef TGT_INDIGO2
CACHE_PROTOS(tcc)
#endif

#include <dev/cons.h>

#include <mips64/arcbios.h>
#include <mips64/archtype.h>
#include <machine/bus.h>

extern char kernel_text[];
extern bus_addr_t comconsaddr;

/* The following is used externally (sysctl_hw) */
char	machine[] = MACHINE;		/* Machine "architecture" */
char	cpu_model[30];

/* will be updated in ipXX_machdep.c whenever necessary */
struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 };
struct uvm_constraint_range *uvm_md_constraints[] = {
	&dma_constraint,
	NULL
};

vm_map_t exec_map;
vm_map_t phys_map;

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = 0;

caddr_t	msgbufbase;

int	physmem;		/* Max supported memory, changes to actual. */
int	rsvdmem;		/* Reserved memory not usable. */
int	ncpu = 1;		/* At least one CPU in the system. */
struct	user *proc0paddr;
int	console_ok;		/* Set when console initialized. */
int16_t	masternasid;

int32_t *environment;
struct sys_rec sys_config;
struct cpu_hwinfo bootcpu_hwinfo;

/* Pointers to the start and end of the symbol table. */
caddr_t	ssym;
caddr_t	esym;
caddr_t	ekern;

struct phys_mem_desc mem_layout[MAXMEMSEGS];

caddr_t	mips_init(int, void *, caddr_t);
void	dumpsys(void);
void	dumpconf(void);

static void dobootopts(int, void *);

boolean_t is_memory_range(paddr_t, psize_t, psize_t);

void	(*md_halt)(int) = arcbios_halt;

int sgi_cpuspeed(int *);

/*
 * Do all the stuff that locore normally does before calling main().
 * Reset mapping and set up mapping to hardware and init "wired" reg.
 */

caddr_t
mips_init(int argc, void *argv, caddr_t boot_esym)
{
	char *cp;
	int i, guessed;
	u_int cpufamily;
	struct cpu_info *ci;
	extern char start[], edata[], end[];
	extern char *hw_vendor;
#ifndef CPU_R8000
	extern char cache_err[], exception[], e_exception[];
	vaddr_t xtlb_handler;
#endif

#ifdef MULTIPROCESSOR
	/*
	 * Set curcpu address on primary processor.
	 */
	setcurcpu(&cpu_info_primary);
#endif

	ci = curcpu();

	/*
	 * Make sure we can access the extended address space.
	 * Note that r10k and later do not allow XUSEG accesses
	 * from kernel mode unless SR_UX is set.
	 */
	setsr(getsr() | SR_KX | SR_UX);

	/*
	 * Clear the compiled BSS segment in OpenBSD code.
	 */
	bzero(edata, end - edata);

	/*
	 * Reserve space for the symbol table, if it exists.
	 */
	ssym = (char *)*(u_int64_t *)end;

	/* Attempt to locate ELF header and symbol table after kernel. */
	if (end[0] == ELFMAG0 && end[1] == ELFMAG1 &&
	    end[2] == ELFMAG2 && end[3] == ELFMAG3 ) {

		/* ELF header exists directly after kernel. */
		ssym = end;
		esym = boot_esym;
		ekern = esym;

	} else if (((long)ssym - (long)end) >= 0 &&
	    ((long)ssym - (long)end) <= 0x1000 &&
	    ssym[0] == ELFMAG0 && ssym[1] == ELFMAG1 &&
	    ssym[2] == ELFMAG2 && ssym[3] == ELFMAG3 ) {

		/* Pointers exist directly after kernel. */
		esym = (char *)*((u_int64_t *)end + 1);
		ekern = esym;

	} else {

		/* Pointers aren't setup either... */
		ssym = NULL;
		esym = NULL;
		ekern = end;
	}

	/*
	 * Initialize the system type and set up memory layout.
	 * Note that some systems have a more complex memory setup.
	 */
	bios_ident();

	/*
	 * Read and store ARCBios variables for future reference.
	 */
	cp = Bios_GetEnvironmentVariable("ConsoleOut");
	if (cp != NULL && *cp != '\0')
		strlcpy(bios_console, cp, sizeof(bios_console));
	cp = Bios_GetEnvironmentVariable("gfx");
	if (cp != NULL && *cp != '\0')
		strlcpy(bios_graphics, cp, sizeof(bios_graphics));
	cp = Bios_GetEnvironmentVariable("keybd");
	if (cp != NULL && *cp != '\0')
		strlcpy(bios_keyboard, cp, sizeof(bios_keyboard));
	/* the following variables may not exist on all systems */
	cp = Bios_GetEnvironmentVariable("eaddr");
	if (cp != NULL && strlen(cp) > 0)
		strlcpy(bios_enaddr, cp, sizeof bios_enaddr);
	bios_consrate = bios_getenvint("dbaud");
	if (bios_consrate < 50 || bios_consrate > 115200)
		bios_consrate = 9600;	/* sane default */
	cp = Bios_GetEnvironmentVariable("OSLoadOptions");
	if (cp != NULL && strlen(cp) > 0)
		strlcpy(osloadoptions, cp, sizeof osloadoptions);

	/*
	 * Determine system type and set up configuration record data.
	 */
	hw_vendor = "SGI";
	switch (sys_config.system_type) {
#ifdef TGT_INDIGO
	case SGI_IP20:
		bios_printf("Found SGI-IP20, setting up.\n");
		/* IP22 is intentional, we use the same kernel */
		strlcpy(cpu_model, "IP22", sizeof(cpu_model));
		ip22_setup();
		break;
#endif
#if defined(TGT_INDY) || defined(TGT_INDIGO2)
	case SGI_IP22:
		bios_printf("Found SGI-IP22, setting up.\n");
		strlcpy(cpu_model, "IP22", sizeof(cpu_model));
		ip22_setup();
		break;
#endif
#ifdef TGT_INDIGO2
	case SGI_IP26:
		bios_printf("Found SGI-IP26, setting up.\n");
		strlcpy(cpu_model, "IP26", sizeof(cpu_model));
		ip22_setup();
		break;
	case SGI_IP28:
		bios_printf("Found SGI-IP28, setting up.\n");
		strlcpy(cpu_model, "IP28", sizeof(cpu_model));
		ip22_setup();
		break;
#endif
#ifdef TGT_O2
	case SGI_O2:
		bios_printf("Found SGI-IP32, setting up.\n");
		strlcpy(cpu_model, "IP32", sizeof(cpu_model));
		ip32_setup();
		break;
#endif
#ifdef TGT_ORIGIN
	case SGI_IP27:
		bios_printf("Found SGI-IP27, setting up.\n");
		strlcpy(cpu_model, "IP27", sizeof(cpu_model));
		ip27_setup();

		break;

	case SGI_IP35:
		bios_printf("Found SGI-IP35, setting up.\n");
		/* IP27 is intentional, we use the same kernel */
		strlcpy(cpu_model, "IP27", sizeof(cpu_model));
		ip27_setup();

		break;
#endif
#ifdef TGT_OCTANE
	case SGI_OCTANE:
		bios_printf("Found SGI-IP30, setting up.\n");
		strlcpy(cpu_model, "IP30", sizeof(cpu_model));
		ip30_setup();
		break;
#endif
	default:
		bios_printf("There is no support for this system type "
		    "(%02x) in this kernel.\n"
		    "Are you sure you have booted the right kernel "
		    "for this machine?\n",
		    sys_config.system_type);
		bios_printf("Halting system.\n");
		Bios_Halt();
		for (;;)
			continue;
		/* NOTREACHED */
	}

	/*
	 * Look at arguments passed to us and compute boothowto.
	 */
	boothowto = RB_AUTOBOOT;
	dobootopts(argc, argv);

	/*
	 * Figure out where we supposedly booted from.
	 */
	cp = Bios_GetEnvironmentVariable("OSLoadPartition");
	if (cp == NULL)
		cp = "unknown";
	if (strlcpy(osloadpartition, cp, sizeof osloadpartition) >=
	    sizeof osloadpartition)
		bios_printf("Value of `OSLoadPartition' is too large.\n"
		 "The kernel might not be able to find out its root device.\n");

	/*
	 * Set pagesize to enable use of page macros and functions.
	 * Commit available memory to UVM system.
	 */
	uvmexp.pagesize = PAGE_SIZE;
	uvm_setpagesize();

	for (i = 0; i < MAXMEMSEGS && mem_layout[i].mem_last_page != 0; i++) {
		uint64_t fp, lp;
		uint64_t firstkernpage, lastkernpage;
		paddr_t firstkernpa, lastkernpa;

		if (IS_XKPHYS((vaddr_t)start))
			firstkernpa = XKPHYS_TO_PHYS((vaddr_t)start);
		else
			firstkernpa = CKSEG0_TO_PHYS((vaddr_t)start);
		if (IS_XKPHYS((vaddr_t)ekern))
			lastkernpa = XKPHYS_TO_PHYS((vaddr_t)ekern);
		else
			lastkernpa = CKSEG0_TO_PHYS((vaddr_t)ekern);

		firstkernpage = atop(trunc_page(firstkernpa));
		lastkernpage = atop(round_page(lastkernpa));

		fp = mem_layout[i].mem_first_page;
		lp = mem_layout[i].mem_last_page;

		/* Account for kernel and kernel symbol table. */
		if (fp >= firstkernpage && lp < lastkernpage)
			continue;	/* In kernel. */

		if (lp < firstkernpage || fp > lastkernpage) {
			uvm_page_physload(fp, lp, fp, lp, 0);
			continue;	/* Outside kernel. */
		}

		if (fp >= firstkernpage)
			fp = lastkernpage;
		else if (lp < lastkernpage)
			lp = firstkernpage;
		else { /* Need to split! */
			uint64_t xp = firstkernpage;
			uvm_page_physload(fp, xp, fp, xp, 0);
			fp = lastkernpage;
		}
		if (lp > fp) {
			uvm_page_physload(fp, lp, fp, lp, 0);
		}
	}

	/*
	 * Configure cache.
	 */
	guessed = 0;
	switch (bootcpu_hwinfo.type) {
#ifdef CPU_R4000
	case MIPS_R4000:
		cpufamily = MIPS_R4000;
		break;
#endif
#ifdef CPU_R4600
	case MIPS_R4600:
		cpufamily = MIPS_R5000;
		break;
#endif
#ifdef CPU_R5000
	case MIPS_R5000:
	case MIPS_RM52X0:
		cpufamily = MIPS_R5000;
		break;
#endif
#ifdef CPU_RM7000
	case MIPS_RM7000:
	case MIPS_RM9000:
		cpufamily = MIPS_R5000;
		break;
#endif
#ifdef CPU_R8000
	case MIPS_R8000:
		cpufamily = MIPS_R8000;
		break;
#endif
#ifdef CPU_R10000
	case MIPS_R10000:
	case MIPS_R12000:
	case MIPS_R14000:
		cpufamily = MIPS_R10000;
		break;
#endif
	default:
		/*
		 * If we can't identify the cpu type, it must be
		 * r10k-compatible on Octane and Origin families, and
		 * it is likely to be r5k-compatible on O2 and
		 * r4k-compatible on Ind{igo*,y}.
		 */
		guessed = 1;
		switch (sys_config.system_type) {
		case SGI_IP20:
		case SGI_IP22:
			bios_printf("Unrecognized processor type %02x, assuming"
			    " R4000 compatible\n", bootcpu_hwinfo.type);
			cpufamily = MIPS_R4000;
			break;
		case SGI_O2:
			bios_printf("Unrecognized processor type %02x, assuming"
			    " R5000 compatible\n", bootcpu_hwinfo.type);
			cpufamily = MIPS_R5000;
			break;
		case SGI_IP26:
			bios_printf("Unrecognized processor type %02x, assuming"
			    " R8000 compatible\n", bootcpu_hwinfo.type);
			cpufamily = MIPS_R8000;
			break;
		default:
		case SGI_IP27:
		case SGI_IP28:
		case SGI_OCTANE:
		case SGI_IP35:
			bios_printf("Unrecognized processor type %02x, assuming"
			    " R10000 compatible\n", bootcpu_hwinfo.type);
			cpufamily = MIPS_R10000;
			break;
		}
		break;
	}
	switch (cpufamily) {
#ifdef CPU_R4000
	case MIPS_R4000:
		Mips4k_ConfigCache(ci);
		break;
#endif
#if defined(CPU_R4600) || defined(CPU_R5000) || defined(CPU_RM7000)
	case MIPS_R5000:
#if defined(TGT_INDY) || defined(TGT_INDIGO2)
		if (sys_config.system_type == SGI_IP22)
			ip22_ConfigCache(ci);
		else
#endif
			Mips5k_ConfigCache(ci);
		break;
#endif
#ifdef CPU_R8000
	case MIPS_R8000:
#ifdef TGT_INDIGO2
		if (sys_config.system_type == SGI_IP26)
			tcc_ConfigCache(ci);
		else
#endif
			tfp_ConfigCache(ci);
		break;
#endif
#ifdef CPU_R10000
	case MIPS_R10000:
		Mips10k_ConfigCache(ci);
		break;
#endif
	default:
		if (guessed) {
			bios_printf("There is no support for this processor "
			    "family in this kernel.\n"
			    "Are you sure you have booted the right kernel "
			    "for this machine?\n");
		} else {
			bios_printf("There is no support for this processor "
			    "family (%02x) in this kernel.\n",
			    bootcpu_hwinfo.type);
		}
		bios_printf("Halting system.\n");
		Bios_Halt();
		for (;;)
			continue;
		/* NOTREACHED */
		break;
	}

	/*
	 * Last chance to call the BIOS. Wiping the TLB means the BIOS' data
	 * areas are demapped on most systems.
	 */
	delay(20*1000);		/* Let any UART FIFO drain... */

	tlb_init(bootcpu_hwinfo.tlbsize);

#ifdef CPU_R8000	/* { */
	/*
	 * Set up TrapBase to point to our own trap vector area.
	 */
	{
		extern char tfp_trapbase[];
		cp0_set_trapbase((vaddr_t)tfp_trapbase);
	}
#else	/* } { */
	/*
	 * Copy down exception vector code.
	 */
	bcopy(exception, (char *)CACHE_ERR_EXC_VEC, e_exception - cache_err);
	bcopy(exception, (char *)GEN_EXC_VEC, e_exception - exception);

	/*
	 * Build proper TLB refill handler trampolines.
	 */
	switch (cpufamily) {
#ifdef CPU_R4000
	case MIPS_R4000:
	    {
		extern void xtlb_miss_err_r4k;
		extern void xtlb_miss_err_r4000SC;

		if (ci->ci_l2.size == 0 ||
		    ((cp0_get_prid() >> 4) & 0x0f) >= 4) /* R4400 */
			xtlb_handler = (vaddr_t)&xtlb_miss_err_r4k;
		else {
			xtlb_handler = (vaddr_t)&xtlb_miss_err_r4000SC;
			xtlb_handler |= CKSEG1_BASE;
		}
	    }
		break;
#endif
#if defined(CPU_R5000) || defined(CPU_RM7000)
	case MIPS_R5000:
	    {
		/*
		 * R5000 processors need a specific chip bug workaround
		 * in their tlb handlers.  Theoretically only revision 1
		 * of the processor need it, but there is evidence
		 * later versions also need it.
		 *
		 * This is also necessary on RM52x0 and most RM7k/RM9k,
		 * and is a documented errata for these chips.
		 */
		extern void xtlb_miss_err_r5k;
		xtlb_handler = (vaddr_t)&xtlb_miss_err_r5k;
	    }
		break;
#endif
	default:
	    {
		extern void xtlb_miss;
		xtlb_handler = (vaddr_t)&xtlb_miss;
	    }
		break;
	}

	build_trampoline(TLB_MISS_EXC_VEC, xtlb_handler);
	build_trampoline(XTLB_MISS_EXC_VEC, xtlb_handler);
#endif	/* } */

#ifdef CPU_R4000
	/*
	 * Enable R4000 EOP errata workaround code if necessary.
	 */
	if (cpufamily == MIPS_R4000 && ((cp0_get_prid() >> 4) & 0x0f) < 3)
		r4000_errata = 1;
#endif

	/*
	 * Allocate U page(s) for proc[0], pm_tlbpid 1.
	 */
	ci->ci_curproc = &proc0;
	proc0.p_cpu = ci;
	proc0.p_addr = proc0paddr = ci->ci_curprocpaddr =
	    (struct user *)pmap_steal_memory(USPACE, NULL, NULL);
	proc0.p_md.md_regs = (struct trapframe *)&proc0paddr->u_pcb.pcb_regs;
	tlb_set_pid(MIN_USER_ASID);

	/*
	 * Get a console, very early but after initial mapping setup
	 * and exception handler setup - console probe code might need
	 * to invoke guarded_read(), and this needs our handlers to be
	 * available.
	 */
	consinit();
	printf("Initial setup done, switching console.\n");

#ifdef DDB
	{
		/*
		 * Early initialize cpu0 so that commands such as `mach tlb'
		 * can work from ddb if ddb is entered before cpu0 attaches.
		 */
		extern struct cpu_info cpu_info_primary;
		bcopy(&bootcpu_hwinfo, &cpu_info_primary.ci_hw,
		    sizeof(struct cpu_hwinfo));
	}
#endif

	/*
	 * Init message buffer.
	 */
	msgbufbase = (caddr_t)pmap_steal_memory(MSGBUFSIZE, NULL, NULL);
	initmsgbuf(msgbufbase, MSGBUFSIZE);

	/*
	 * Bootstrap VM system.
	 */
	pmap_bootstrap();

#ifdef CPU_R8000
	/*
	 * Turn on precise FPU exceptions. This also causes the FS bit in
	 * the FPU status register to be honoured, instead of being forced
	 * to one.
	 */
	setsr(getsr() | SR_SERIALIZE_FPU);

	/*
	 * Turn on sequential memory model. This makes sure that there are
	 * no risks of hitting virtual coherency exceptions, which are not
	 * recoverable on R8000.
	 */
	cp0_set_config((cp0_get_config() & ~CFGR_ICE) | CFGR_SMM);
#else
	/*
	 * Turn off bootstrap exception vectors.
	 */
	setsr(getsr() & ~SR_BOOT_EXC_VEC);
#endif

	proc0.p_md.md_regs->sr = getsr();

	/*
	 * Clear out the I and D caches.
	 */
	Mips_SyncCache(ci);

#ifdef DDB
	db_machine_init();
	if (boothowto & RB_KDB)
		Debugger();
#endif

	/*
	 * Return new stack pointer.
	 */
	return ((caddr_t)proc0paddr + USPACE - 64);
}

/*
 * Decode boot options.
 */
static void
dobootopts(int argc, void *argv)
{
	char *cp;
	int i;

	/* XXX Should this be done differently, eg env vs. args? */
	for (i = 1; i < argc; i++) {
		if (bios_is_32bit)
			cp = (char *)(long)((int32_t *)argv)[i];
		else
			cp = ((char **)argv)[i];
		if (cp == NULL)
			continue;

		/*
		 * Parse PROM options.
		 */
		if (strncmp(cp, "OSLoadOptions=", 14) == 0) {
			if (strcmp(&cp[14], "auto") == 0)
				boothowto &= ~(RB_SINGLE|RB_ASKNAME);
			else if (strcmp(&cp[14], "single") == 0)
				boothowto |= RB_SINGLE;
			else if (strcmp(&cp[14], "debug") == 0)
				boothowto |= RB_KDB;
			continue;
		}

		/*
		 * Parse kernel options.
		 */
		if (*cp == '-') {
			while (*++cp != '\0')
				switch (*cp) {
				case 'a':
					boothowto |= RB_ASKNAME;
					break;
				case 'c':
					boothowto |= RB_CONFIG;
					break;
				case 'd':
					boothowto |= RB_KDB;
					break;
				case 's':
					boothowto |= RB_SINGLE;
					break;
				}
		}
	}
}


/*
 * Console initialization: called early on from mips_init(), before vm init
 * is completed.
 * Do enough configuration to choose and initialize a console.
 */
void
consinit()
{
	if (console_ok)
		return;
	cninit();
	console_ok = 1;
}

/*
 * cpu_startup: allocate memory for variable-sized tables, initialize CPU, and 
 * do auto-configuration.
 */
void
cpu_startup()
{
	vaddr_t minaddr, maxaddr;
#ifdef PMAPDEBUG
	extern int pmapdebug;
	int opmapdebug = pmapdebug;

	pmapdebug = 0;	/* Shut up pmap debug during bootstrap. */
#endif

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf(version);
	printf("real mem = %lu (%luMB)\n", ptoa((psize_t)physmem),
	    ptoa((psize_t)physmem)/1024/1024);
	printf("rsvd mem = %lu (%luMB)\n", ptoa((psize_t)rsvdmem),
	    (ptoa((psize_t)rsvdmem) + 1023 * 1024)/1024/1024);

	/*
	 * Allocate a submap for exec arguments. This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
	/* Allocate a submap for physio. */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, 0, FALSE, NULL);

#ifdef PMAPDEBUG
	pmapdebug = opmapdebug;
#endif
	printf("avail mem = %lu (%luMB)\n", ptoa((psize_t)uvmexp.free),
	    ptoa((psize_t)uvmexp.free)/1024/1024);

	cpu_cpuspeed = sgi_cpuspeed;

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}

/*
 * Machine dependent system variables.
 */
int
cpu_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return ENOTDIR;		/* Overloaded */

	switch (name[0]) {
	default:
		return EOPNOTSUPP;
	}
}

int
sgi_cpuspeed(int *freq)
{
	/*
	 * XXX assumes all CPU have the same frequency
	 */
	*freq = curcpu()->ci_hw.clock / 1000000;
	return (0);
}

int	waittime = -1;

__dead void
boot(int howto)
{
	if (curproc)
		savectx(curproc->p_addr, 0);

	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		waittime = 0;
		vfs_shutdown();

		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & RB_DUMP) != 0)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

	if ((howto & RB_HALT) != 0) {
		if ((howto & RB_POWERDOWN) != 0)
			printf("System Power Down.\n");
		else
			printf("System Halt.\n");
	} else
		printf("System restart.\n");

	delay(1000000);
	md_halt(howto);

	printf("Failed!!! Please reset manually.\n");
	for (;;)
		continue;
	/* NOTREACHED */
}

void
arcbios_halt(int howto)
{
	register_t sr;

	sr = disableintr();

#if 0
	/* restore ARCBios page size... */
	tlb_set_page_mask(PG_SIZE_4K);
#endif

	if (howto & RB_HALT) {
#ifdef TGT_INDIGO
		/* Indigo does not support powerdown */
		if (sys_config.system_type == SGI_IP20)
			howto &= ~RB_POWERDOWN;
#endif
		if (howto & RB_POWERDOWN) {
#ifdef TGT_INDY
			/*
			 * ARCBios needs to use the FPU on Indy during
			 * shutdown.
			 */
			if (sys_config.system_type == SGI_IP22)
				setsr(getsr() | SR_COP_1_BIT);
#endif
			Bios_PowerDown();
		} else
			Bios_EnterInteractiveMode();
	} else
		Bios_Reboot();

	setsr(sr);
}

u_long	dumpmag = 0x8fca0101;	/* Magic number for savecore. */
int	dumpsize = 0;			/* Also for savecore. */
long	dumplo = 0;

void
dumpconf(void)
{
	int nblks;

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	dumpsize = ptoa(physmem);
	if (dumpsize > atop(round_page(dbtob(nblks - dumplo))))
		dumpsize = atop(round_page(dbtob(nblks - dumplo)));
	else if (dumplo == 0)
		dumplo = nblks - btodb(ptoa(physmem));

	/*
	 * Don't dump on the first page in case the dump device includes a 
	 * disk label.
	 */
	if (dumplo < btodb(PAGE_SIZE))
		dumplo = btodb(PAGE_SIZE);
}

/*
 * Doadump comes here after turning off memory management and getting on the
 * dump stack, either when called above, or by the auto-restart code.
 */
void
dumpsys()
{
	extern int msgbufmapped;

	msgbufmapped = 0;
	if (dumpdev == NODEV)
		return;
	/*
	 * For dumps during auto-configuration, if dump device has already
	 * configured...
	 */
	if (dumpsize == 0)
		dumpconf();
	if (dumplo < 0)
		return;
	printf("\ndumping to dev %x, offset %ld\n", dumpdev, dumplo);
	printf("dump not yet implemented\n");
#if 0 /* XXX HAVE TO FIX XXX */
	switch (error = (*bdevsw[major(dumpdev)].d_dump)(dumpdev, dumplo,)) {

	case ENXIO:
		printf("device bad\n");
		break;

	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	default:
		printf("error %d\n", error);
		break;

	case 0:
		printf("succeeded\n");
	}
#endif
}

boolean_t
is_memory_range(paddr_t pa, psize_t len, psize_t limit)
{
	struct phys_mem_desc *seg;
	uint64_t fp, lp;
	int i;

	fp = atop(pa);
	lp = atop(round_page(pa + len));

	if (limit != 0 && lp > atop(limit))
		return FALSE;

	for (i = 0, seg = mem_layout; i < MAXMEMSEGS; i++, seg++)
		if (fp >= seg->mem_first_page && lp <= seg->mem_last_page)
			return TRUE;

	return FALSE;
}
@


1.153
log
@Apply consistency to forever loops with continue and NOTREACHED

Same thought from kettenis@@, ok krw@@ phessler@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.152 2016/08/16 13:03:58 visa Exp $ */
d798 2
a799 8
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
@


1.152
log
@Remove RM7000/RM9000-specific performance counter code. It originates
from PMON2000 and has not been enabled on OpenBSD.

Suggested by and ok miod@@ (after seeing a quad_t cleanup patch of mine)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.151 2016/03/06 19:42:27 mpi Exp $ */
d305 3
a307 1
		for (;;) ;
d497 3
a499 1
		for (;;) ;
d876 2
a877 1
	for (;;) ;
@


1.151
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.150 2014/12/10 15:29:53 mikeb Exp $ */
a73 4
#ifdef CPU_RM7000
#include <mips64/rm7000.h>
#endif

a1010 76

#ifdef CPU_RM7000
#ifdef	RM7K_PERFCNTR
/*
 * RM7000 Performance counter support.
 */
int
rm7k_perfcntr(cmd, arg1, arg2, arg3)
	int cmd;
	long  arg1, arg2, arg3;
{
	int result;
	quad_t cntval;
	struct proc *p = curproc;


	switch(cmd) {
	case PCNT_FNC_SELECT:
		if ((arg1 & 0xff) > PCNT_SRC_MAX ||
		   (arg1 & ~(PCNT_CE|PCNT_UM|PCNT_KM|0xff)) != 0) {
			result = EINVAL;
			break;
		}
#ifdef DEBUG
printf("perfcnt select %x, proc %p\n", arg1, p);
#endif
		p->p_md.md_pc_count = 0;
		p->p_md.md_pc_spill = 0;
		p->p_md.md_pc_ctrl = arg1;
		result = 0;
		break;

	case PCNT_FNC_READ:
		cntval = p->p_md.md_pc_count;
		cntval += (quad_t)p->p_md.md_pc_spill << 31;
		result = copyout(&cntval, (void *)arg1, sizeof(cntval));
		break;

	default:
#ifdef DEBUG
printf("perfcnt error %d\n", cmd);
#endif
		result = -1;
		break;
	}
	return(result);
}

/*
 * Called when the performance counter d31 gets set.
 * Increase spill value and reset d31.
 */
void
rm7k_perfintr(trapframe)
	struct trapframe *trapframe;
{
	struct proc *p = curproc;

#ifdef DEBUG
	printf("perfintr proc %p!\n", p);
#endif
	cp0_setperfcount(cp0_getperfcount() & 0x7fffffff);
	if (p != NULL) {
		p->p_md.md_pc_spill++;
	}
}

int
rm7k_watchintr(trapframe)
	struct trapframe *trapframe;
{
	return(0);
}

#endif	/* RM7K_PERFCNTR */
#endif	/* CPU_RM7000 */
@


1.150
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.149 2014/09/20 09:28:24 kettenis Exp $ */
d590 1
a590 1
	proc0.p_md.md_regs = (struct trap_frame *)&proc0paddr->u_pcb.pcb_regs;
d1069 1
a1069 1
	struct trap_frame *trapframe;
d1084 1
a1084 1
	struct trap_frame *trapframe;
@


1.149
log
@Use config_suspend_all(9).

ok mpi@@, uebayasi@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.148 2014/07/21 17:25:47 uebayasi Exp $ */
a861 1
	doshutdownhooks();
@


1.148
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a831 2
	struct device *mainbus;

d863 1
a863 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.147
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d860 1
a860 1
	if (howto & RB_DUMP)
d869 2
a870 2
	if (howto & RB_HALT) {
		if (howto & RB_POWERDOWN)
@


1.146
log
@Cosmetic changes to reduce diffs.
@
text
@d882 1
a882 1
	/*NOTREACHED*/
@


1.145
log
@boot(9): Undo curproc-overriding hacks

Some (not all) boot(9) implementations have ancient hacks which overrides if
(curproc == NULL).  This was probably made in a hope to forcibly proceed
various clean-shutdown related code, including VFS shutdown.  Let's clarify
that clean-shutdown needs process context; it is impossible to cleanly shutdown
VFS from within e.g. a panic in SPL_HIGH.

OK kettenis@@
@
text
@d857 1
a857 1
	splhigh();		/* Disable interrupts. */
@


1.144
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.143 2014/07/10 20:15:27 uebayasi Exp $ */
a844 4
		extern struct proc proc0;
		/* fill curproc with live object */
		if (curproc == NULL)
			curproc = &proc0;
@


1.143
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d861 2
a862 1
	(void) splhigh();		/* Extreme priority. */
@


1.142
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@a833 1
	/* Take a snapshot before clobbering any registers. */
a837 4
		/*
		 * If the system is cold, just halt, unless the user
		 * explicitly asked for reboot.
		 */
@


1.141
log
@boot(): Unify declarations

OK deraadt@@
@
text
@a853 3
		/*
		 * Synchronize the disks...
		 */
a856 4
		/*
		 * If we've been adjusting the clock, the todr will be out of
		 * sync; adjust it now.
		 */
@


1.140
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.139 2014/05/30 13:46:16 mpi Exp $ */
d829 1
a829 1
void
@


1.139
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.138 2014/05/19 21:18:42 miod Exp $ */
d873 1
a873 2
	splhigh();		/* Disable interrupts. */
	cold = 1;
@


1.138
log
@Format string fixes and removal of -Wno-format for sgi. Based upon an
initial diff from jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.137 2014/04/03 08:07:16 mpi Exp $ */
d873 2
a874 1
	(void) splhigh();		/* Extreme priority. */
@


1.137
log
@Moar <uvm/uvm.h> -> <uvm/uvm_extern.h> love.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.136 2014/03/22 00:01:04 miod Exp $ */
d985 1
a985 1
	printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
@


1.136
log
@Second draft of my attempt to workaround the infamous R4000 end-of-page errata,
affecting R4000 processors revision 2.x and below (found on most R4000 Indigo
and a few R4000 Indy).

Since this errata gets triggered by TLB misses when the code flow crosses a
page boundary, this code attempts to identify code pages prone to trigger the
errata, and force the next page to be mapped for at least as long as the
current pc lies in the troublesome page, by creating wiring extra TLB entries.
These entries get recycled in a lazy-but-aggressive-enough way, either because
of context switches, or because of further tlb exceptions reaching trap().

The errata workaround code is only compiled on R4000-capable kernels (i.e.
sgi GENERIC-IP22 and nothing else), and only enabled on affected processors
(i.e. not on R4000 revision 3, or on R4400).

There is still room for improvemnt in unlucky cases, but in this simple enough
incarnation, this allows my R4000 2.2 Indigo to finally reliably boot multiuser,
even though both /sbin/init and /bin/sh contain code pages which can trigger
the errata.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.135 2014/03/13 03:52:55 dlg Exp $ */
d51 2
a52 1
#include <uvm/uvm.h>
@


1.135
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.134 2014/03/09 10:12:17 miod Exp $ */
d573 8
@


1.134
log
@Rework the per-cpu cache information. Use a common struct to store the line
size, the number of sets, and the total size (and the set size, for convenience)
per cache (I$, D$, L2, L3).
This allows cpu.c to print the number of ways (sets) of L2 and L3 caches from
the cache information, rather than hardcoding this from the processor type.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.133 2013/09/28 12:40:31 miod Exp $ */
d823 1
d871 3
a873 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.133
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.132 2012/10/08 21:47:50 deraadt Exp $ */
d535 1
a535 1
		if (ci->ci_l2size == 0 ||
@


1.132
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.131 2012/10/03 11:18:23 miod Exp $ */
d870 2
a871 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.131
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.130 2012/09/29 21:46:02 miod Exp $ */
d870 1
@


1.130
log
@Work in progress support for the Power Indigo2 R8000 system (IP26). This is
basically an IP22 system (R4000 Indigo2) with the ECC memory board of IP28,
and a so-called ``streaming'' L2 cache.

IP26 kernels currently boot single-user, but don't live long; I am suspecting
a bug in the tcc cache routines, but am currently not able to find it (come
to think of it, my understanding of how this cache works could be wrong, and
of course there is no documentation for it but what can be gathered from
IRIX' <sys/IP26.h> comments and defines).

Hopefully this situation will improve in the near future; in the meantime I
am commiting this as `work in progress' to make sure this code doesn't get
lost.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.129 2012/09/29 19:24:31 miod Exp $ */
d58 1
@


1.129
log
@Handle the coprocessor 0 cause and status registers as a 64 bit value now,
as some odd mips designs need moro than 32 bits in there. This causes a lot
of mechanical changes everywhere getsr() is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.128 2012/09/29 19:11:08 miod Exp $ */
d68 3
a84 4
#ifdef DEBUG
void dump_tlb(void);
#endif

d147 1
a147 2
	u_int cputype;
	vaddr_t xtlb_handler;
d150 2
d153 2
a154 1
	extern char *hw_vendor;
d260 1
a260 2
		/* IP28 is intentional, we will probably use the same kernel */
		strlcpy(cpu_model, "IP28", sizeof(cpu_model));
a381 7
#ifdef CPU_R10000
	case MIPS_R10000:
	case MIPS_R12000:
	case MIPS_R14000:
		cputype = MIPS_R10000;
		break;
#endif
d384 1
a384 1
		cputype = MIPS_R4000;
d389 1
a389 1
		cputype = MIPS_R5000;
d395 1
a395 1
		cputype = MIPS_R5000;
d401 13
a413 1
		cputype = MIPS_R5000;
d427 3
a429 3
			bios_printf("Unrecognized processor type, assuming"
			    " R4000 compatible\n");
			cputype = MIPS_R4000;
d432 3
a434 3
			bios_printf("Unrecognized processor type, assuming"
			    " R5000 compatible\n");
			cputype = MIPS_R5000;
d437 3
a439 3
			bios_printf("Unrecognized processor type, assuming"
			    " R8000 compatible\n");
			cputype = MIPS_R8000;
d446 3
a448 3
			bios_printf("Unrecognized processor type, assuming"
			    " R10000 compatible\n");
			cputype = MIPS_R10000;
d453 1
a453 1
	switch (cputype) {
d469 10
d492 2
a493 1
			    "family (%02x) in this kernel.\n", cputype);
d509 9
d527 1
a527 1
	switch (cputype) {
d571 1
d592 12
d615 15
d634 1
a1096 50

#ifdef DEBUG
/*
 * Dump TLB contents.
 */
void
dump_tlb()
{
char *attr[] = {
	"CWTNA", "CWTA ", "UCBL ", "CWB  ", "RES  ", "RES  ", "UCNB ", "BPASS"
};

	int tlbno, last;
	struct tlb_entry tlb;

	last = 64;

	for (tlbno = 0; tlbno < last; tlbno++) {
		tlb_read(tlbno, &tlb);

		if (tlb.tlb_lo0 & PG_V || tlb.tlb_lo1 & PG_V) {
			bios_printf("%2d v=%p", tlbno, tlb.tlb_hi & 0xffffffffffffff00);
			bios_printf("/%02x ", tlb.tlb_hi & 0xff);

			if (tlb.tlb_lo0 & PG_V) {
				bios_printf("0x%09x ", pfn_to_pad(tlb.tlb_lo0));
				bios_printf("%c", tlb.tlb_lo0 & PG_M ? 'M' : ' ');
				bios_printf("%c", tlb.tlb_lo0 & PG_G ? 'G' : ' ');
				bios_printf(" %s ", attr[(tlb.tlb_lo0 >> 3) & 7]);
			} else {
				bios_printf("invalid             ");
			}

			if (tlb.tlb_lo1 & PG_V) {
				bios_printf("0x%08x ", pfn_to_pad(tlb.tlb_lo1));
				bios_printf("%c", tlb.tlb_lo1 & PG_M ? 'M' : ' ');
				bios_printf("%c", tlb.tlb_lo1 & PG_G ? 'G' : ' ');
				bios_printf(" %s ", attr[(tlb.tlb_lo1 >> 3) & 7]);
			} else {
				bios_printf("invalid             ");
			}
			bios_printf(" sz=%x", tlb.tlb_mask);
		}
		else {
			bios_printf("%2d v=invalid    ", tlbno);
		}
		bios_printf("\n");
	}
}
#endif
@


1.128
log
@Kill the mostly unused VMTLB_xxx and VMNUM_xxx defines. Move all tlb
knowledge to <machine/pte.h>. Add specific routines for tlb handling setup
(at cpu initialization time) and tlb ASID wrap.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.127 2012/06/24 20:29:46 miod Exp $ */
d835 1
a835 1
	uint32_t sr;
@


1.127
log
@Code for the external L2 cache controller on Indy/Indigo2 R4600SC and Indy
R5000SC processor modules; these sport an up to 512KB, physically indexed,
write-through L2 cache which is not connected to the canonical external cache
interface of these processors (hence requiring specific code to drive it).
The cache is enabled early and disabled before returning to ARCBios (for very
nasty things happen otherwise).

Tested on R5000SC, will be tested on R4600SC soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.126 2012/06/24 16:26:04 miod Exp $ */
d491 1
a491 4
	tlb_set_page_mask(TLB_PAGE_MASK);
	tlb_set_wired(0);
	tlb_flush(bootcpu_hwinfo.tlbsize);
	tlb_set_wired(UPAGES / 2);
d555 1
a555 1
	tlb_set_pid(1);
a574 1
	tlb_set_pid(1);
d581 1
@


1.126
log
@Add cache operation functions pointers to struct cpu_info; the various
cache lines and sizes are already there, after all.

The ConfigCache cache routine is responsible for filling these function
pointers; cache routine invocation macros are updated to use the cpu_info
fields, but may still be overriden in <machine/cpu.h> on platforms where
only one set of cache routines is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.125 2012/05/29 17:37:09 mikeb Exp $ */
d65 3
d456 6
a461 1
		Mips5k_ConfigCache(ci);
@


1.125
log
@Make it possible to disable the Sync-on-Green signal by setting the
ARCBios environment variable OSLoadOptions to "nosog".  Now everyone
can enjoy running O2 without an SGI monitor and don't turn vegetarian
afterwards.  All the essential bits come from NetBSD's crmfb driver
except they've chosen to use a "SyncOnGreen" variable not saved by
the ARCS.  Pointers and corrections from and ok miod, jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124 2012/05/27 14:27:10 miod Exp $ */
d448 1
a448 7
		Mips4k_ConfigCache(curcpu());
		sys_config._SyncCache = Mips4k_SyncCache;
		sys_config._InvalidateICache = Mips4k_InvalidateICache;
		sys_config._SyncDCachePage = Mips4k_SyncDCachePage;
		sys_config._HitSyncDCache = Mips4k_HitSyncDCache;
		sys_config._IOSyncDCache = Mips4k_IOSyncDCache;
		sys_config._HitInvalidateDCache = Mips4k_HitInvalidateDCache;
d453 1
a453 7
		Mips5k_ConfigCache(curcpu());
		sys_config._SyncCache = Mips5k_SyncCache;
		sys_config._InvalidateICache = Mips5k_InvalidateICache;
		sys_config._SyncDCachePage = Mips5k_SyncDCachePage;
		sys_config._HitSyncDCache = Mips5k_HitSyncDCache;
		sys_config._IOSyncDCache = Mips5k_IOSyncDCache;
		sys_config._HitInvalidateDCache = Mips5k_HitInvalidateDCache;
d458 1
a458 7
		Mips10k_ConfigCache(curcpu());
		sys_config._SyncCache = Mips10k_SyncCache;
		sys_config._InvalidateICache = Mips10k_InvalidateICache;
		sys_config._SyncDCachePage = Mips10k_SyncDCachePage;
		sys_config._HitSyncDCache = Mips10k_HitSyncDCache;
		sys_config._IOSyncDCache = Mips10k_IOSyncDCache;
		sys_config._HitInvalidateDCache = Mips10k_HitInvalidateDCache;
@


1.124
log
@Proper support for the so-called `fast mode' of the Indigo2 ECC memory
controller. In this mode, access to physical memory are not allowed to
bypass the cache, and this allows the memory subsystem to run faster.

Of course, some device drivers will require uncached memory access (e.g.
for proper HPC DMA descriptor operation).

New ip22-specific functions to switch between `fast mode' and `slow mode'
are introduced.

hpc(4) now provides read and write routines to fetch a dma descriptor from
uncached memory into a local copy, and update it from said modified copy.
On systems without the ECC MC, these will do nothing and operation will
continue to access the uncached memory directly. On systems with the ECC MC,
they will perform a copy, and the writeback will be done in slow mode.

bus_dmamem_map() requests for DMA memory with BUS_DMA_COHERENT set in flags,
which would return uncached memory, will now always fail on systems with
the ECC memory controller. Drivers which really need uncached memory, and
are aware of this particular setup, will now pass
BUS_DMA_COHERENT | BUS_DMA_BUS1, which will let the request succeed.

sq(4) will use all of the above to work mostly unmodified on ECC MC systems
in fast mode.

Finally, fast mode is enabled after autoconf.

Tested on IP22 and IP28.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.123 2012/05/10 21:28:31 miod Exp $ */
d229 3
@


1.123
log
@Initialize more proc0 context before invoking consinit(); this now really
allows probes to fault and correctly recover.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.122 2012/04/21 19:38:20 miod Exp $ */
a128 1
void	arcbios_halt(int);
@


1.122
log
@Fix math in previous. Oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.121 2012/04/21 19:19:06 miod Exp $ */
d148 1
d160 2
d520 1
a520 1
		if (curcpu()->ci_l2size == 0 ||
d561 3
a563 1
	proc0.p_addr = proc0paddr = curcpu()->ci_curprocpaddr =
d598 1
a598 1
	Mips_SyncCache(curcpu());
@


1.121
log
@Round the reserved memory size up when printing it in MB units
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.120 2012/04/17 09:23:14 landry Exp $ */
d698 1
a698 1
	    ptoa((psize_t)rsvdmem + 1023 * 1024)/1024/1024);
@


1.120
log
@Add sgi_cpuspeed() setting HW_CPUSPEED sysctl node. Tested on SGI Fuel.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.119 2012/04/16 22:23:06 miod Exp $ */
d698 1
a698 1
	    ptoa((psize_t)rsvdmem)/1024/1024);
@


1.119
log
@Move proc0 and trap handler setup before consinit(), but still wait for the
initial setup to be complete before switching to our trap handlers.

However, change guarded_{read,write}_* to clear BEV in the coprocessor 0
status register, and restore it afterwards, to use our fault handlers within
these functions. This makes these functions usable from consinit().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.118 2012/04/09 16:54:40 miod Exp $ */
d134 2
d717 2
d757 10
@


1.118
log
@More errata bandaid for the R4000SC is necessary in the tlb handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.117 2012/04/06 18:24:29 miod Exp $ */
a123 1
void	initcpu(void);
a499 25
	 * Get a console, very early but after initial mapping setup.
	 */
	consinit();
	printf("Initial setup done, switching console.\n");

	/*
	 * Init message buffer.
	 */
	msgbufbase = (caddr_t)pmap_steal_memory(MSGBUFSIZE, NULL, NULL);
	initmsgbuf(msgbufbase, MSGBUFSIZE);

	/*
	 * Allocate U page(s) for proc[0], pm_tlbpid 1.
	 */
	proc0.p_addr = proc0paddr = curcpu()->ci_curprocpaddr =
	    (struct user *)pmap_steal_memory(USPACE, NULL, NULL);
	proc0.p_md.md_regs = (struct trap_frame *)&proc0paddr->u_pcb.pcb_regs;
	tlb_set_pid(1);

	/*
	 * Bootstrap VM system.
	 */
	pmap_bootstrap();

	/*
d554 29
d661 2
a662 1
 * Console initialization: called early on from main, before vm init or startup.
d668 1
a668 1
	if (console_ok) {
a669 1
	}
a715 5
	 * Set up CPU-specific registers, cache, etc.
	 */
	initcpu();

	/*
a937 5
}

void
initcpu()
{
@


1.117
log
@Get serial console speed from ARCBios earlier; repairs serial console on Octane
and O2 (other systems unaffected).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.116 2012/04/03 21:17:35 miod Exp $ */
d539 9
a547 1
		xtlb_handler = (vaddr_t)&xtlb_miss_err_r4k;
d839 5
@


1.116
log
@Default DMA-reachable address constraints to the whole address space, and
narrow these in the various ipXX_machdep.c. On IP22-like systems, narrow
them to 28 bit physical addresses, but unpessimize this by extending this
to 32 bit after autoconf, if no 28-bit limited hpc(4) device has been found.
Since physical memory on these systems start at 128MB, this means that Indigo
systems with more than 128MB memory will behave correctly (and so will Indy
systems with E++ boards and more than 128MB memory).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.115 2012/03/28 20:44:23 miod Exp $ */
d219 7
a316 12

	/*
	 * Read platform-specific environment variables from ARCBios.
	 * (Note these may not exist on all systems)
	 */
	/* onboard Ethernet address (does not exist on IP27/IP35) */
	cp = Bios_GetEnvironmentVariable("eaddr");
	if (cp != NULL && strlen(cp) > 0)
		strlcpy(bios_enaddr, cp, sizeof bios_enaddr);
	bios_consrate = bios_getenvint("dbaud");
	if (bios_consrate < 50 || bios_consrate > 115200)
		bios_consrate = 9600;	/* sane default */
@


1.115
log
@Work in progress support for the SGI Indigo, Indigo 2 and Indy systems
(IP20, IP22, IP24) in 64-bit mode, adapated from NetBSD. Currently limited
to headless operation, input and video drivers will get ported soon.

Should work on all R4000, R4440 and R5000 based systems. L2 cache on R5000SC
Indy not supported yet (coming soon), R4600 not supported yet either (coming
soon as well).

Tested to boot multiuser on: Indigo2 R4000SC, Indy R4000PC, Indy R4000SC,
Indy R5000SC, Indigo2 R4400SC. There are still glitches in the Ethernet driver
which are being looked at.

Expansion support is limited to the GIO E++ board; GIO boards with PCI-GIO
bridges not ported yet due to the lack of hardware, and this kind of driver
does not port blindly.

Most of this work comes from NetBSD, polishing and integration work, as well
as putting as many ``R4x00 in 64-bit mode'' erratas as necessary, by yours
truly.

More work is coming, as well as trying to get some easy way to boot install
kernels (as older PROM can only boot ECOFF binaries, which won't do for the
kernel).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.114 2012/03/25 13:52:52 miod Exp $ */
d87 2
a88 2
/* low 32 bits range. */
struct uvm_constraint_range  dma_constraint = { 0x0, 0x7fffffff };
@


1.114
log
@Move cache handling routines related definitions to a dedicated header file,
rather than abusing <machine/cpu.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.113 2012/03/15 18:57:22 miod Exp $ */
d144 1
a144 1
	int i;
d148 1
a148 1
	extern char exception[], e_exception[];
d225 28
d284 5
a288 1
		bios_printf("Kernel doesn't support this system type!\n");
d291 1
a291 1
		while(1);
d312 2
a313 1
	 * Read platform-specific environment variables.
d315 7
a321 12
	switch (sys_config.system_type) {
#ifdef TGT_O2
	case SGI_O2:
		/* Get Ethernet address from ARCBIOS. */
		cp = Bios_GetEnvironmentVariable("eaddr");
		if (cp != NULL && strlen(cp) > 0)
			strlcpy(bios_enaddr, cp, sizeof bios_enaddr);
		break;
#endif
	default:
		break;
	}
d376 1
d385 10
d411 2
a412 1
		 * it is likely to be r5k-compatible on O2.
d414 1
d416 6
d423 2
d427 5
d433 2
a435 1
		case SGI_IP27:
d437 2
d445 12
a456 2
	default:
#if defined(CPU_R5000) || defined(CPU_RM7000)
d478 14
d533 1
a533 1
	bcopy(exception, (char *)CACHE_ERR_EXC_VEC, e_exception - exception);
d540 8
d836 9
a844 1
		if (howto & RB_POWERDOWN)
d846 1
a846 1
		else
@


1.113
log
@uncached_base was introduced early in IP27 support, since these designs use
subspaces in the CCA_NC uncached memory space. However, being coherent,
there was never a need for bus_dma to use uncached addresses.

This means that, on the only systems where uncached_base was not set to
PHYS_TO_XKPHYS(0, CCA_NC), it was never used.

Remove the variable, and replace PHYS_TO_UNCACHED() with
PHYS_TO_XKPHYS(, CCA_NC). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.112 2011/06/26 22:40:00 deraadt Exp $ */
d56 1
@


1.112
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.111 2011/06/24 19:47:49 naddy Exp $ */
a102 1
vaddr_t	uncached_base;
@


1.111
log
@machdep.kbdreset enables a shutdown by Ctrl-Alt-Del on amd64 and
i386.  Stop abusing it on other archs for controling a shutdown by
pressing the soft power button:

* Add a MI sysctl hw.allowpowerdown; if set to 1 (the default) it
  allows a power button shutdown.
* Make acpi(4)/acpibtn(4) honor hw.allowpowerdown.
* Switch the various power button intercepts on landisk, sgi, sparc64
  and zaurus over to hw.allowpowerdown.
* Garbage collect the machdep.kbdreset sysctl on all archs other than
  amd64 and i386.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.110 2011/06/05 19:41:08 deraadt Exp $ */
d50 1
d707 1
@


1.110
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.109 2011/05/30 22:25:22 oga Exp $ */
a108 1
int	kbd_reset;
a658 4
	case CPU_KBDRESET:
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp, kbd_reset));
		return (sysctl_int(oldp, oldlenp, newp, newlen, &kbd_reset));
@


1.109
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.108 2011/04/21 18:09:49 miod Exp $ */
a83 13

/*
 * Declare these as initialized data so we can patch them.
 */
#ifndef	BUFCACHEPERCENT
#define	BUFCACHEPERCENT	5	/* Can be changed in config. */
#endif
#ifndef	BUFPAGES
#define BUFPAGES 0		/* Can be changed in config. */
#endif

int	bufpages = BUFPAGES;
int	bufcachepercent = BUFCACHEPERCENT;
@


1.108
log
@Print memory sizes as longs. Stolen from sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.107 2011/04/03 22:32:39 miod Exp $ */
a317 1
		unsigned int freelist;
a333 1
		freelist = mem_layout[i].mem_freelist;
d340 1
a340 1
			uvm_page_physload(fp, lp, fp, lp, freelist);
d350 1
a350 1
			uvm_page_physload(fp, xp, fp, xp, freelist);
d354 1
a354 1
			uvm_page_physload(fp, lp, fp, lp, freelist);
@


1.107
log
@Make sure dma_constraint is listed in uvm_md_constraints[] when it does not
span the whole physical address space, for the pmemrange magic to operate
correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.106 2010/10/24 15:40:03 miod Exp $ */
d613 4
a616 4
	printf("real mem = %u (%uMB)\n", ptoa(physmem),
	    ptoa(physmem)/1024/1024);
	printf("rsvd mem = %u (%uMB)\n", ptoa(rsvdmem),
	    ptoa(rsvdmem)/1024/1024);
d632 2
a633 2
	printf("avail mem = %u (%uMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024/1024);
@


1.106
log
@Move build_trampoline() and setregs() to a common location for all mips ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.105 2010/06/27 13:28:46 miod Exp $ */
d100 4
a103 1
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };
a244 1

a260 1

a267 1

a278 1

d448 1
a448 1
	msgbufbase = (caddr_t)pmap_steal_memory(MSGBUFSIZE, NULL,NULL);
d548 1
a548 1
					boothowto &= ~(RB_SINGLE|RB_ASKNAME);
d550 1
a550 1
					boothowto |= RB_SINGLE;
d552 1
a552 1
					boothowto |= RB_KDB;
@


1.105
log
@If you include <uvm/uvm.h>, you do not need to include any other <uvm/uvm_foo.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.104 2010/06/27 03:03:48 thib Exp $ */
a140 1
void	build_trampoline(vaddr_t, vaddr_t);
a526 67
 * Build a tlb trampoline
 */
void
build_trampoline(vaddr_t addr, vaddr_t dest)
{
	const uint32_t insns[] = {
		0x3c1a0000,	/* lui k0, imm16 */
		0x675a0000,	/* daddiu k0, k0, imm16 */
		0x001ad438,	/* dsll k0, k0, 0x10 */
		0x675a0000,	/* daddiu k0, k0, imm16 */
		0x001ad438,	/* dsll k0, k0, 0x10 */
		0x675a0000,	/* daddiu k0, k0, imm16 */
		0x03400008,	/* jr k0 */
		0x00000000	/* nop */
	};
	uint32_t *dst = (uint32_t *)addr;
	const uint32_t *src = insns;
	uint32_t a, b, c, d;

	/*
	 * Decompose the handler address in the four components which,
	 * added with sign extension, will produce the correct address.
	 */
	d = dest & 0xffff;
	dest >>= 16;
	if (d & 0x8000)
		dest++;
	c = dest & 0xffff;
	dest >>= 16;
	if (c & 0x8000)
		dest++;
	b = dest & 0xffff;
	dest >>= 16;
	if (b & 0x8000)
		dest++;
	a = dest & 0xffff;

	/*
	 * Build the trampoline, skipping noop computations.
	 */
	*dst++ = *src++ | a;
	if (b != 0)
		*dst++ = *src++ | b;
	else
		src++;
	*dst++ = *src++;
	if (c != 0)
		*dst++ = *src++ | c;
	else
		src++;
	*dst++ = *src++;
	if (d != 0)
		*dst++ = *src++ | d;
	else
		src++;
	*dst++ = *src++;
	*dst++ = *src++;

	/*
	 * Note that we keep the delay slot instruction a nop, instead
	 * of branching to the second instruction of the handler and
	 * having its first instruction in the delay slot, so that the
	 * tlb handler is free to use k0 immediately.
	 */
}

/*
a683 36

/*
 * Set registers on exec for native exec format. For o64/64.
 */
void
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	struct cpu_info *ci = curcpu();

	bzero((caddr_t)p->p_md.md_regs, sizeof(struct trap_frame));
	p->p_md.md_regs->sp = stack;
	p->p_md.md_regs->pc = pack->ep_entry & ~3;
	p->p_md.md_regs->t9 = pack->ep_entry & ~3; /* abicall req */
	p->p_md.md_regs->sr = SR_FR_32 | SR_XX | SR_KSU_USER | SR_KX | SR_UX |
	    SR_EXL | SR_INT_ENAB;
#if defined(CPU_R10000) && !defined(TGT_COHERENT)
	if (ci->ci_hw.type == MIPS_R12000)
		p->p_md.md_regs->sr |= SR_DSD;
#endif
	p->p_md.md_regs->sr |= idle_mask & SR_INT_MASK;
	p->p_md.md_regs->ic = (idle_mask << 8) & IC_INT_MASK;
	p->p_md.md_flags &= ~MDP_FPUSED;
	if (ci->ci_fpuproc == p)
		ci->ci_fpuproc = (struct proc *)0;
	p->p_md.md_ss_addr = 0;
	p->p_md.md_pc_ctrl = 0;
	p->p_md.md_watch_1 = 0;
	p->p_md.md_watch_2 = 0;

	retval[1] = 0;
}

@


1.104
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.102 2010/04/28 21:26:47 miod Exp $ */
a50 1
#include <uvm/uvm_extern.h>
@


1.103
log
@Declare safepri at the MD level on each platform, so that the kern_synch.c
does not have to deal with it as a common.  Some platforms may be missed
by this commit... if you spot one, fix it the same way.
ok miod
@
text
@d50 1
d98 4
@


1.102
log
@Only invoke setcurcpu() #ifdef MULTIPROCESSOR
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.101 2010/04/28 16:20:28 syuu Exp $ */
d100 6
@


1.101
log
@Storeing current cpu_info address into LLAddr register, for curcpu().
Instead of previous implementation, we won't use physical cpuid to fetch curcpu().
This requires to implement IP27/35 SMP.
Implemented getcurcpu() and setcurcpu() for it, smp_malloc() renamed alloc_contiguous_pages() because now it only allocate by page.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.100 2010/03/03 12:25:09 jsing Exp $ */
d152 1
d157 1
@


1.100
log
@Store ARCBios variables before machine specific setup is performed and
make console selection on a per machine basis. Whilst here store the
keyboard layout ('keybd') and graphics state ('gfx') variables for
future use.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.98 2010/01/22 21:45:26 miod Exp $ */
d151 5
@


1.99
log
@Since the TLB handler exception code is now always a trampoline to branch
to the handler code in the kernel, we can use relative branches in it to
make it a bit faster.
Also, get rid of the tlbmiss handler and have both the tlb and xtlb refill
exceptions branch to the xtlbmiss handler.
@
text
@d202 13
a257 11

	/*
	 * Read and store console type.
	 */
	cp = Bios_GetEnvironmentVariable("ConsoleOut");
	if (cp != NULL && *cp != '\0')
		strlcpy(bios_console, cp, sizeof bios_console);

	/* Disable serial console if ARCS is telling us to use video. */
	if (strncmp(bios_console, "video", 5) == 0)
		comconsaddr = 0;
@


1.98
log
@Move is_memory_range() from mips64 mem.c to a per-architecture location; this
allows /dev/kmem to access the 256MB alias of the low memory on loongson, which
in turns makes procmap(8) happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.97 2010/01/09 23:34:29 miod Exp $ */
d147 1
a147 1
	vaddr_t tlb_handler, xtlb_handler;
a468 1
		extern void tlb_miss_err_r5k;
a469 1
		tlb_handler = (vaddr_t)&tlb_miss_err_r5k;
a475 1
		extern void tlb_miss;
a476 1
		tlb_handler = (vaddr_t)&tlb_miss;
d482 1
a482 1
	build_trampoline(TLB_MISS_EXC_VEC, tlb_handler);
@


1.97
log
@Move cache information from global variables to per-cpu_info fields; this
allows processors with different cache sizes to be used.

Cache management routines now take a struct cpu_info * as first parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.96 2010/01/09 20:33:16 miod Exp $ */
d132 1
d948 20
@


1.96
log
@Define struct cpu_hwinfo, to hold hardware specific information about each
processor (instead of sys_config.cpu[]), and pass it in the attach_args
when attaching cpu devices.

This allows per-cpu information to be gathered late in the bootstrap process,
and not be limited by an arbitrary MAX_CPUS limit; this will suit IP27 and
IP35 systems better.

While there, use this information to make sure delay() uses the speed
information from the cpu it is invoked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.95 2010/01/08 01:35:52 syuu Exp $ */
d388 1
a388 1
		Mips5k_ConfigCache();
d399 1
a399 1
		Mips10k_ConfigCache();
d497 1
a497 1
	Mips_SyncCache();
@


1.95
log
@MP-safe FPU handling. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.94 2009/12/12 20:07:10 miod Exp $ */
d114 1
a341 77
	switch (sys_config.system_type) {
#if defined(TGT_O2) || defined(TGT_OCTANE)
	case SGI_O2:
	case SGI_OCTANE:
		sys_config.cpu[0].type = (cp0_get_prid() >> 8) & 0xff;
		sys_config.cpu[0].vers_maj = (cp0_get_prid() >> 4) & 0x0f;
		sys_config.cpu[0].vers_min = cp0_get_prid() & 0x0f;
		sys_config.cpu[0].fptype = (cp1_get_prid() >> 8) & 0xff;
		sys_config.cpu[0].fpvers_maj = (cp1_get_prid() >> 4) & 0x0f;
		sys_config.cpu[0].fpvers_min = cp1_get_prid() & 0x0f;

		/*
		 * Configure TLB.
		 */
		switch(sys_config.cpu[0].type) {
#ifdef CPU_RM7000
		case MIPS_RM7000:
			/*
			 * Rev A (version >= 2) CPU's have 64 TLB entries.
			 *
			 * However, the last 16 are only enabled if one
			 * particular configuration bit (mode bit #24)
			 * is set on cpu reset, so check whether the
			 * extra TLB are really usable.
			 *
			 * If they are disabled, they are nevertheless
			 * writable, but random TLB insert operations
			 * will never use any of them. This can be
			 * checked by inserting dummy entries and check
			 * if any of the last 16 entries have been used.
			 *
			 * Of course, due to the way the random replacement
			 * works (hashing various parts of the TLB data,
			 * such as address bits and ASID), not all the
			 * available TLB will be used; we simply check
			 * the highest valid TLB entry we can find and
			 * see if it is in the upper 16 entries or not.
			 */
			sys_config.cpu[0].tlbsize = 48;
			if (sys_config.cpu[0].vers_maj >= 2) {
				struct tlb_entry te;
				int e, lastvalid;

				tlb_set_wired(0);
				tlb_flush(64);
				for (e = 0; e < 64 * 8; e++)
					tlb_update(XKSSEG_BASE + ptoa(2 * e),
					    pfn_to_pad(0) | PG_ROPAGE);
				lastvalid = 0;
				for (e = 0; e < 64; e++) {
					tlb_read(e, &te);
					if ((te.tlb_lo0 & PG_V) != 0)
						lastvalid = e;
				}
				tlb_flush(64);
				if (lastvalid >= 48)
					sys_config.cpu[0].tlbsize = 64;
			}
			break;
#endif
#ifdef CPU_R10000
		case MIPS_R10000:
		case MIPS_R12000:
		case MIPS_R14000:
			sys_config.cpu[0].tlbsize = 64;
			break;
#endif
		default:
			sys_config.cpu[0].tlbsize = 48;
			break;
		}
		break;
#endif
	default:
		break;
	}

d345 1
a345 1
	switch(sys_config.cpu[0].type) {
a415 1
	sys_config.cpu[0].tlbwired = UPAGES / 2;
d418 2
a419 2
	tlb_flush(sys_config.cpu[0].tlbsize);
	tlb_set_wired(sys_config.cpu[0].tlbwired);
d756 1
a756 1
	if (sys_config.cpu[0].type == MIPS_R12000)
@


1.94
log
@Introduce various CPU_### options to enable cpu-specific code or workarounds;
be sure to rerun config(8) on your kernel configuration files.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.93 2009/12/07 19:05:59 miod Exp $ */
d824 1
a824 1
	extern struct proc *machFPCurProcPtr;
d839 2
a840 2
	if (machFPCurProcPtr == p)
		machFPCurProcPtr = (struct proc *)0;
@


1.93
log
@Support for 16KB page size kernels; page size is now set in <machine/param.h>
rather than <mips64/param.h>.

For now, kernels are kept at 4KB to give people some time to build 16KB
compatible binaries; this will change before the end of this release cycle.

Use of 16KB page size kernels yields a 18% speedup (which, offset by the
1.6% slowdown caused by the pmap changes, yields a 16.6% overall speedup).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.92 2009/12/07 18:51:26 miod Exp $ */
d64 1
d66 1
a148 4
	extern void tlb_miss;
	extern void tlb_miss_err_r5k;
	extern void xtlb_miss;
	extern void xtlb_miss_err_r5k;
d356 1
d400 2
a401 1

d407 1
a407 1

d422 1
d428 2
d431 5
a436 1
	case MIPS_RM52X0:
d440 1
a460 9
	case MIPS_R10000:
		Mips10k_ConfigCache();
		sys_config._SyncCache = Mips10k_SyncCache;
		sys_config._InvalidateICache = Mips10k_InvalidateICache;
		sys_config._SyncDCachePage = Mips10k_SyncDCachePage;
		sys_config._HitSyncDCache = Mips10k_HitSyncDCache;
		sys_config._IOSyncDCache = Mips10k_IOSyncDCache;
		sys_config._HitInvalidateDCache = Mips10k_HitInvalidateDCache;
		break;
d462 1
d472 12
d533 1
d535 1
d545 2
d549 1
d551 1
d553 3
d558 1
d832 1
a832 1
#if !defined(TGT_COHERENT)
d1026 1
a1027 1

d1100 1
@


1.92
log
@When trying to return to ARCBios on a 32 bit ARCBios machine (such as the O2),
disable interrupts and unconditionnaly use proc0 u area as the stack, so that
once ARCBios loses the upper 32 bits of the stack pointer, accessing the
stack does not fault (proc0 u area is allocated in CKSEG0 for this reason).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.91 2009/12/03 06:02:38 miod Exp $ */
d481 1
d528 2
a529 4
		 * This is also necessary on RM52x0; we test on the `rounded'
		 * cputype value instead of sys_config.cpu[0].type; this
		 * causes RM7k and RM9k to be included, just to be on the
		 * safe side.
@


1.91
log
@RM7000 processors with 64 TLB pairs instead of the usual 48 use an external
control bit to enabled use of the extra 16, in order to be able to be used
as drop-in R5000 replacement without modifying RM7000-unaware software.

Because of this, when a 64 TLB RM7000 processor is detected, check that
the upper 16 really will be used before deciding how many TLB the kernel
needs to invalidate whe ASID wraps.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.90 2009/11/19 20:16:27 miod Exp $ */
d900 9
d916 2
@


1.90
log
@Rename KSEG* defines to CKSEG* to match their names in 64 bit mode; also
define more 64 bit spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.89 2009/11/19 20:13:54 miod Exp $ */
a158 10
#ifdef notyet
	/*
	 * Make sure CKSEG0 cacheability match what we intend to use.
	 *
	 * XXX This does not work as expected on IP30. Does ARCBios
	 * XXX depend on this?
	 */
	cp0_setcfg((cp0_getcfg() & ~0x07) | CCA_CACHED);
#endif

d359 40
a398 5
			/* Rev A (version >= 2) CPU's have 64 TLB entries. */
			if (sys_config.cpu[0].vers_maj < 2) {
				sys_config.cpu[0].tlbsize = 48;
			} else {
				sys_config.cpu[0].tlbsize = 64;
@


1.89
log
@Remove code allowing native binaries with O32 ABI to run, there aren't any...
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.88 2009/11/19 06:06:51 miod Exp $ */
d161 1
a161 1
	 * Make sure KSEG0 cacheability match what we intend to use.
d317 1
a317 1
			firstkernpa = KSEG0_TO_PHYS((vaddr_t)start);
d321 1
a321 1
			lastkernpa = KSEG0_TO_PHYS((vaddr_t)ekern);
@


1.88
log
@Factor triplicated code responsible to add memory information into a
single place.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.87 2009/11/07 18:56:55 miod Exp $ */
a778 17
#if 0
/* XXX should check validity of header and perhaps be 32/64 indep. */
	Elf64_Ehdr *eh = pack->ep_hdr;

	if ((((eh->e_flags & EF_MIPS_ABI) != E_MIPS_ABI_NONE) &&
	    ((eh->e_flags & EF_MIPS_ABI) != E_MIPS_ABI_O32)) ||
	    ((eh->e_flags & EF_MIPS_ARCH) >= E_MIPS_ARCH_3) ||
	    (eh->e_ident[EI_CLASS] != ELFCLASS32)) {
		p->p_md.md_flags |= MDP_O32;
	}
#endif

#if !defined(__LP64__)
	p->p_md.md_flags |= MDP_O32;
#else
	p->p_md.md_flags &= ~MDP_O32;
#endif
a783 1
#if defined(__LP64__)
d786 2
a787 2
	if (sys_config.cpu[0].type == MIPS_R12000 &&
	    sys_config.system_type == SGI_O2)
a788 2
#else
	p->p_md.md_regs->sr = SR_KSU_USER|SR_XX|SR_EXL|SR_INT_ENAB;
@


1.87
log
@Replace option TGT_ORIGIN200 and TGT_ORIGIN2000 with a single option,
TGT_ORIGIN, which enables support for all IP27 and IP35 systems. The original
two options have always been used together, and go back to when pefo thought
supporting multiple nodes would be significant work. Since an Origin 200
can be a dual-node system, making a distinction between single node and
multiple node systems is a moot point anyway.

Be sure to rerun config(8) before rebuilding a kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.86 2009/11/07 14:49:01 miod Exp $ */
d308 3
a310 3
	for (i = 0; i < MAXMEMSEGS && mem_layout[i].mem_first_page != 0; i++) {
		u_int32_t fp, lp;
		u_int32_t firstkernpage, lastkernpage;
d344 1
a344 1
			u_int32_t xp = firstkernpage;
d348 1
a348 1
		if (lp > fp)
d350 1
d1046 1
d1048 1
@


1.86
log
@Change sgi system identification from a single system type list, to a smaller
system type list (which really is the system family) and a subsystem type.

No functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.85 2009/10/16 00:15:49 miod Exp $ */
d60 1
a60 1
#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
d216 1
a216 1
#if defined(TGT_O2)
d224 1
a224 1
#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
d241 1
a241 1
#if defined(TGT_OCTANE)
d289 1
a289 1
#if defined(TGT_O2)
@


1.85
log
@Get serial console speed from prom, and use it instead of hardcoding 9600 bps,
on all systems but O2 (to catch up soon). Also use the IOC4 MCR register to
figure out the IOC4 clock, instead of checking the widget control register,
to be consistent with iof(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.84 2009/10/14 20:21:16 miod Exp $ */
d225 1
a225 1
	case SGI_O200:
d232 1
a232 1
	case SGI_O300:
d419 2
a420 2
		case SGI_O200:
		case SGI_O300:
@


1.84
log
@On IP30 and IP35 systems, try harder to figure out exactly what model we are
running on, and report this both as the hw.product sysctl and in dmesg.
Fuel and Origin 350 are no longer reported as being Origin 300 systems!
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.83 2009/09/30 06:22:00 syuu Exp $ */
a125 1
static int atoi(const char *, int, const char **);
a220 6

		sys_config.cpu[0].clock = 180000000;  /* Reasonable default */
		cp = Bios_GetEnvironmentVariable("cpufreq");
		if (cp && atoi(cp, 10, NULL) > 100)
			sys_config.cpu[0].clock = atoi(cp, 10, NULL) * 1000000;

a245 6

		sys_config.cpu[0].clock = 175000000;  /* Reasonable default */
		cp = Bios_GetEnvironmentVariable("cpufreq");
		if (cp && atoi(cp, 10, NULL) > 100)
			sys_config.cpu[0].clock = atoi(cp, 10, NULL) * 1000000;

a985 84
}

/*
 * Convert "xx:xx:xx:xx:xx:xx" string to Ethernet hardware address.
 */
void
enaddr_aton(const char *s, u_int8_t *a)
{
	int i;

	if (s != NULL) {
		for(i = 0; i < 6; i++) {
			a[i] = atoi(s, 16, &s);
			if (*s == ':')
				s++;
		}
	}
}

/*
 * Convert an ASCII string into an integer.
 */
static int
atoi(const char *s, int b, const char **o)
{
	int c;
	unsigned base = b, d;
	int neg = 0, val = 0;

	if (s == NULL || *s == 0) {
		if (o != NULL)
			*o = s;
		return 0;
	}

	/* Skip spaces if any. */
	do {
		c = *s++;
	} while (c == ' ' || c == '\t');

	/* Parse sign, allow more than one (compat). */
	while (c == '-') {
		neg = !neg;
		c = *s++;
	}

	/* Parse base specification, if any. */
	if (c == '0') {
		c = *s++;
		switch (c) {
		case 'X':
		case 'x':
			base = 16;
			c = *s++;
			break;
		case 'B':
		case 'b':
			base = 2;
			c = *s++;
			break;
		default:
			base = 8;
		}
	}

	/* Parse number proper. */
	for (;;) {
		if (c >= '0' && c <= '9')
			d = c - '0';
		else if (c >= 'a' && c <= 'z')
			d = c - 'a' + 10;
		else if (c >= 'A' && c <= 'Z')
			d = c - 'A' + 10;
		else
			break;
		val *= base;
		val += d;
		c = *s++;
	}
	if (neg)
		val = -val;
	if (o != NULL)
		*o = s - 1;
	return val;
@


1.83
log
@curproc, curprocpaddr moved into cpu_info
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.82 2009/08/19 12:33:06 jasper Exp $ */
d147 1
a147 1
	extern char *hw_vendor, *hw_prod;
a219 1
		hw_prod = "O2";
a233 1
		hw_prod = "Origin 200";
a240 1
		hw_prod = "Origin 300";
a250 1
		hw_prod = "Octane";
a363 1

@


1.82
log
@- missing \n

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.81 2009/08/11 19:17:17 miod Exp $ */
a105 1
struct	user *curprocpaddr;
d492 1
a492 1
	proc0.p_addr = proc0paddr = curprocpaddr =
@


1.81
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.80 2009/08/11 18:46:32 miod Exp $ */
d972 1
a972 1
	printf("dump not yet implemented");
@


1.80
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.79 2009/08/09 10:40:17 blambert Exp $ */
a718 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.79
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.78 2009/08/06 21:06:32 miod Exp $ */
a124 1
caddr_t	allocsys(caddr_t);
a143 1
	caddr_t sd;
a498 7
	 * Allocate system data structures.
	 */
	i = (vsize_t)allocsys(NULL);
	sd = (caddr_t)pmap_steal_memory(i, NULL, NULL);
	allocsys(sd);

	/*
a557 16
}

/*
 * Allocate space for system data structures. Doesn't need to be mapped.
 */
caddr_t
allocsys(caddr_t v)
{
	caddr_t start;

	start = v;

#define	valloc(name, type, num) \
	    (name) = (type *)v; v = (caddr_t)((name)+(num))

	return(v);
@


1.78
log
@Remove _InvalidateICachePage cache op, it isn't used by anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.77 2009/08/06 21:05:50 miod Exp $ */
a48 3
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
a580 6
#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.77
log
@Only compile RM7000 performance counter support if defined(RM7K_PERFCNTR).
This code needs to be cleaned up, and made more generic to work with other
processors counters as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.76 2009/08/02 16:28:39 beck Exp $ */
a29 1
#include <sys/signalvar.h>
a35 2
#include <sys/malloc.h>
#include <sys/mbuf.h>
a36 2
#include <sys/ioctl.h>
#include <sys/tty.h>
a42 1
#include <sys/extent.h>
a454 1
		sys_config._InvalidateICachePage = Mips10k_InvalidateICachePage;
a464 1
		sys_config._InvalidateICachePage = Mips5k_InvalidateICachePage;
@


1.76
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.75 2009/07/22 21:29:05 miod Exp $ */
d1140 2
d1210 2
@


1.75
log
@Get rid of now unused extent_malloc_ok variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.74 2009/06/15 17:01:26 beck Exp $ */
a767 6

	/* Restrict to at most 25% filled kvm. */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.74
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.73 2009/06/13 21:48:03 miod Exp $ */
a107 2
int	extent_malloc_flags = 0;

a790 2

	extent_malloc_flags = EX_MALLOCOK;
@


1.73
log
@Enumerate all available nodes for hardware on IP27/IP35 systems; works to some
extent, but isp(4) on other nodes do not work correctly yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.72 2009/06/04 16:52:12 miod Exp $ */
d770 6
@


1.72
log
@Don't bother setting RB_SERCONS in boothowto since this flag is not used
by anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.71 2009/06/03 21:30:20 beck Exp $ */
d120 1
@


1.71
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.70 2009/05/28 18:03:55 miod Exp $ */
a721 4

	/* Catch serial consoles on O2s. */
	if (strncmp(bios_console, "serial", 6) == 0)
		boothowto |= RB_SERCONS;
@


1.70
log
@Poor man's reset code for IP27/IP35 where returning through ARCBios doesn't
work, even after restoring TLB and exception code.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.69 2009/05/28 18:02:43 miod Exp $ */
a772 6

	/* Restrict to at most 25% filled kvm. */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.69
log
@Handle NMI interrupts on IP27/IP35, gives us a change to play with ddb,
and then restart system (NMI on these systems aren't intended to be
recoverable).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.68 2009/05/25 17:10:40 miod Exp $ */
d140 1
d143 2
d957 1
a957 1
		if (howto & RB_POWERDOWN) {
d959 1
a959 3
			delay(1000000);
			Bios_PowerDown();
		} else {
d961 1
a961 5
			delay(1000000);
			Bios_EnterInteractiveMode();
		}
		printf("Didn't want to die!!! Reset manually.\n");
	} else {
d963 5
a967 4
		delay(1000000);
		Bios_Reboot();
		printf("Restart failed!!! Reset manually.\n");
	}
d970 12
@


1.68
log
@Years ago, I fixed an R5000 O2 instability by implementing a workaround for
a chip bug, which was supposed to be fixed in that particular revision of
the die but wasn't (tlbhandler.S 1.16).

Being lazy, I did not write a runtime selection of the appropriate TLB
handler code, although this was on my list.

It turns out that this fix confuses the hell of R10000 processors revision 3
(but not earlier 2.x revisions), to the point of making the Origin 200 here
hang so hard it would not even enter the NMI handler (don't ask me how I
figured this was the cause).

So it's time to choose the appropriate TLB handling flavour at runtime,
building the trampoline code from the fixed exception handler location
jumping to the handler address at runtime. As a bonus, kernels linked in
KSEG0 get the address computation optimized and thus a smaller trampoline
than before.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2009/05/22 20:37:54 miod Exp $ */
a487 11

#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
	/*
	 * If an IP27 or IP35 system set up Node 0's HUB.
	 */
	if (sys_config.system_type == SGI_O200 ||
	    sys_config.system_type == SGI_O300) {
		IP27_LHUB_S(PI_REGION_PRESENT, 1);
		IP27_LHUB_S(PI_CALIAS_SIZE, PI_CALIAS_SIZE_0);
	}
#endif
@


1.67
log
@Drop almost unused <machine/psl.h> on sgi; move USERMODE() definition from
there to trap.c which is its only user. This also cleans up multiple
inclusion of <machine/cpu.h> (because <machine/psl.h> includes it) in many
places.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 2009/05/21 16:28:12 miod Exp $ */
d140 2
d154 1
a155 2
	extern char tlb_miss_tramp[], e_tlb_miss_tramp[];
	extern char xtlb_miss_tramp[], e_xtlb_miss_tramp[];
d158 4
a534 4
	bcopy(tlb_miss_tramp, (char *)TLB_MISS_EXC_VEC,
	    e_tlb_miss_tramp - tlb_miss_tramp);
	bcopy(xtlb_miss_tramp, (char *)XTLB_MISS_EXC_VEC,
	    e_xtlb_miss_tramp - xtlb_miss_tramp);
d539 28
d609 67
@


1.66
log
@Overhaul root device detection; the code will now follow the ARCS bootpath
component by component, from device_register().

IP27 and IP35 systems using the dksc() syntax get their dksc() syntax converted
to an ARCS bootpath, so the same logic will apply.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.65 2009/05/08 18:42:07 miod Exp $ */
a65 1
#include <machine/psl.h>
@


1.65
log
@Add a new page freelist, to which memory suitable for 32-bit dma on
xbridge(4) is assigned. Then, make bus_dmamem_alloc() allocate from this
range only.

This is transparent on O2, and makes sure the bus_dma memory address
will fit in the 2GB direct map of xbridge(4) chips - this is necessary for
PCI devices which do not handle 64 bit dma addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 2009/04/25 20:38:32 miod Exp $ */
a82 2
extern int makebootdev(const char *, int);
extern void stacktrace(void);
a119 1
int	bootdriveoffs = 0;
d132 5
a136 9
void crime_configure_memory(void);

caddr_t mips_init(int, void *, caddr_t);
void initcpu(void);
void dumpsys(void);
void dumpconf(void);
caddr_t allocsys(caddr_t);

void db_command_loop(void);
d298 1
a298 1
	 * Figure out where we booted from.
d303 4
a306 2
	if (makebootdev(cp, bootdriveoffs))
		bios_printf("Boot device unrecognized: '%s'\n", cp);
d476 1
a476 2
	 * areas are demapped on most systems. O2s are okay as they do not have 
	 * mapped BIOS text or data.
a582 1

a825 5

#ifdef DEBUG
	if (panicstr)
		stacktrace();
#endif
@


1.64
log
@Handle unknown processor types as r5k family on O2, and r10k family otherwise.
This will get a chance for r16k cpus to get configured correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 2009/04/22 04:40:29 miod Exp $ */
d339 1
d356 1
d363 1
a363 1
			uvm_page_physload(fp, lp, fp, lp, VM_FREELIST_DEFAULT);
d373 1
a373 1
			uvm_page_physload(fp, xp, fp, xp, VM_FREELIST_DEFAULT);
d377 1
a377 1
			uvm_page_physload(fp, lp, fp, lp, VM_FREELIST_DEFAULT);
@


1.63
log
@Only report the IP number in sysctl hw.model; vendor and machine name are
now reported in hw.vendor and hw.product.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 2009/04/19 12:52:33 miod Exp $ */
d159 1
d426 29
a463 1

d465 1
@


1.62
log
@Add heuristics to tell IP27 and IP35 apart, as they will need to be handled
differently at times.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 2008/12/30 05:33:17 miod Exp $ */
d163 1
d227 1
d232 2
a233 1
		strlcpy(cpu_model, "SGI-O2 (IP32)", sizeof(cpu_model));
d247 2
a248 1
		strlcpy(cpu_model, "SGI-Origin200 (IP27)", sizeof(cpu_model));
d255 3
a257 1
		strlcpy(cpu_model, "SGI-Origin300 (IP35)", sizeof(cpu_model));
d266 2
a267 1
		strlcpy(cpu_model, "SGI-Octane (IP30)", sizeof cpu_model);
@


1.61
log
@savecore(8) wants dumpmag to be an unsigned long.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 2008/05/18 07:36:10 jsing Exp $ */
d248 7
d454 1
a454 1
	 * If an IP27 system set up Node 0's HUB.
d456 2
a457 1
	if (sys_config.system_type == SGI_O200) {
@


1.60
log
@Unbreak glass console on OpenBSD/sgi - if we're supposed to be using the
glass console set comconsaddr to zero so we don't switch to serial when
com* attach.

spotted by jasper@@, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 2008/04/29 12:47:19 jsing Exp $ */
d855 1
a855 1
int	dumpmag = (int)0x8fca0101;	/* Magic number for savecore. */
@


1.59
log
@convert arm and mips64 platforms to ptoa/atop

tested by maja@@
@
text
@d85 1
d277 4
@


1.58
log
@Attempt to locate an ELF header and symbol table directly after the kernel.
If it exists assume that the boot loader has provided a pointer to the end
of the symbol table. If it does not exist fall back to the previous
behaviour and expect that pointers to the symbol table have been provided
directly after the kernel.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 2008/04/09 16:50:29 deraadt Exp $ */
d866 2
a867 2
	if (dumpsize > btoc(dbtob(nblks - dumplo)))
		dumpsize = btoc(dbtob(nblks - dumplo));
d869 1
a869 1
		dumplo = nblks - btodb(ctob(physmem));
@


1.57
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d127 1
a127 2

/* ddb symbol init stuff */
d136 1
a136 1
caddr_t mips_init(int, void *);
d153 1
a153 1
mips_init(int argc, void *argv)
d186 1
a186 1
	 *  Reserve symbol table space. If invalid pointers no table.
d189 22
a210 6
	esym = (char *)*((u_int64_t *)end + 1);
	ekern = esym;
	if (((long)ssym - (long)end) < 0 ||
	    ((long)ssym - (long)end) > 0x1000 ||
	    ssym[0] != ELFMAG0 || ssym[1] != ELFMAG1 ||
	    ssym[2] != ELFMAG2 || ssym[3] != ELFMAG3 ) {
d217 2
a218 2
	 *  Initialize the system type and set up memory layout.
	 *  Note that some systems have a more complex memory setup.
@


1.56
log
@Unclutter machdep.c by moving the IP32-specific initialization code to its
own file. While there, more dead beef removal in struct sys_rec.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.55 2008/03/23 17:05:41 deraadt Exp $ */
d805 1
@


1.55
log
@setroot() is supposed to be safe in all cases, so kill the special cases
for RB_DFLTROOT; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2008/02/20 19:13:38 miod Exp $ */
a81 7
#include <sgi/localbus/crimebus.h>
#include <sgi/localbus/macebus.h>
#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
#include <sgi/localbus/xbowmux.h>
#endif

extern struct consdev *cn_tab;
d113 1
a147 73
#if BYTE_ORDER == BIG_ENDIAN
int	my_endian = 1;
#else
int	my_endian = 0;
#endif

#if defined(TGT_O2)
void
crime_configure_memory(void)
{
	struct phys_mem_desc *m;
	volatile u_int64_t *bank_ctrl;
	paddr_t addr;
	psize_t size;
	u_int32_t first_page, last_page;
	int bank, i;

	bank_ctrl = (void *)PHYS_TO_KSEG1(CRIMEBUS_BASE + CRIME_MEM_BANK0_CONTROL);
	for (bank = 0; bank < CRIME_MAX_BANKS; bank++) {
		addr = (bank_ctrl[bank] & CRIME_MEM_BANK_ADDR) << 25;
		size = (bank_ctrl[bank] & CRIME_MEM_BANK_128MB) ? 128 : 32;
#ifdef DEBUG
		bios_printf("crime: bank %d contains %ld MB at 0x%lx\n",
		    bank, size, addr);
#endif

		/*
		 * Do not report memory regions below 256MB, since ARCBIOS will do.
		 * Moreover, empty banks are reported at address zero.
		 */
		if (addr < 256 * 1024 * 1024)
			continue;

		addr += 1024 * 1024 * 1024;
		size *= 1024 * 1024;
		first_page = atop(addr);
		last_page = atop(addr + size);

		/*
		 * Try to coalesce with other memory segments if banks are 
		 * contiguous.
		 */
		m = NULL;
		for (i = 0; i < MAXMEMSEGS; i++) {
			if (mem_layout[i].mem_last_page == 0) {
				if (m == NULL)
					m = &mem_layout[i];
			} else if (last_page == mem_layout[i].mem_first_page) {
				m = &mem_layout[i];
				m->mem_first_page = first_page;
			} else if (mem_layout[i].mem_last_page == first_page) {
				m = &mem_layout[i];
				m->mem_last_page = last_page;
			}
		}
		if (m != NULL && m->mem_last_page == 0) {
			m->mem_first_page = first_page;
			m->mem_last_page = last_page;
		}
		if (m != NULL)
			physmem += atop(size);
	}

#ifdef DEBUG
	for (i = 0; i < MAXMEMSEGS; i++)
		if (mem_layout[i].mem_first_page)
			bios_printf("MEM %d, 0x%x to  0x%x\n",i,
				ptoa(mem_layout[i].mem_first_page),
				ptoa(mem_layout[i].mem_last_page));
#endif
}
#endif

d171 10
a206 2
bios_printf("SR=%08x\n", getsr()); /* leave this in for now. need to see sr */

d215 1
a215 7
		sys_config.cons_ioaddr[0] = MACE_ISA_SER1_OFFS;
		sys_config.cons_ioaddr[1] = MACE_ISA_SER2_OFFS;
		sys_config.cons_baudclk = 1843200;		/*XXX*/
		sys_config.cons_iot = &macebus_tag;
		sys_config.cpu[0].tlbwired = 2;

		crime_configure_memory();
a221 13
		/* R1xK O2s are one disk slot machines. Offset slotno. */
		switch ((cp0_get_prid() >> 8) & 0xff) {
		case MIPS_R10000:
		case MIPS_R12000:
			bootdriveoffs = -1;
			break;
		}
		/* R12K O2s must run with DSD on. */
		switch ((cp0_get_prid() >> 8) & 0xff) {
		case MIPS_R12000:
			setsr(getsr() | SR_DSD);
			break;
		}
d229 1
d231 13
a243 1
		kl_scan_config(0);
a244 5
		sys_config.cons_ioaddr[0] = kl_get_console_base();
		sys_config.cons_ioaddr[1] = kl_get_console_base() - 8;
		sys_config.cons_baudclk = 22000000 / 3;	/*XXX*/
		sys_config.cons_iot = &xbowbus_tag;
		sys_config.cpu[0].tlbwired = 2;
d339 1
a339 1
		if (lp >= fp)
d345 1
a345 1
#if defined(TGT_O2)
d347 1
d370 1
d391 1
a391 1
		sys_config.cpu[0].cfg_reg = Mips10k_ConfigCache();
d402 1
a402 1
		sys_config.cpu[0].cfg_reg = Mips5k_ConfigCache();
d419 2
a424 34
#if 0
	/* XXX Save the following as an example on how to optimize I/O mapping. */

	/*
	 * Set up some fixed mappings. These are frequently used so faulting
	 * them in will waste too many cycles.
	 */
	if (sys_config.system_type == MOMENTUM_CP7000G ||
	    sys_config.system_type == MOMENTUM_CP7000 ||
	    sys_config.system_type == GALILEO_EV64240) {
		struct tlb tlb;

		tlb.tlb_mask = PG_SIZE_16M;
#if defined(LP64)
		tlb.tlb_hi = vad_to_vpn(0xfffffffffc000000) | 1;
		tlb.tlb_lo0 = vad_to_pfn(0xfffffffff4000000) | PG_IOPAGE;
#else
		tlb.tlb_hi = vad_to_vpn(0xfc000000) | 1;
		tlb.tlb_lo0 = vad_to_pfn(0xf4000000) | PG_IOPAGE;
#endif
		tlb.tlb_lo1 = vad_to_pfn(sys_config.cons_ioaddr[0]) | PG_IOPAGE;
		tlb_write_indexed(2, &tlb);

		if (sys_config.system_type == GALILEO_EV64240) {
			tlb.tlb_mask = PG_SIZE_16M;
			tlb.tlb_hi = vad_to_vpn(0xf8000000) | 1;
			tlb.tlb_lo0 = vad_to_pfn(sys_config.pci_io[0].bus_base) | PG_IOPAGE;
			tlb.tlb_lo1 = vad_to_pfn(sys_config.pci_mem[0].bus_base) | PG_IOPAGE;
			tlb_write_indexed(3, &tlb);
		}
	}
/* XXX */
#endif

a465 1

@


1.54
log
@More dead includes and functions noone will mourn.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.53 2008/02/20 18:46:20 miod Exp $ */
a345 2
	 * Default to AUTOBOOT if no args or SINGLE and DFLTROOT
	 * if this is a ramdisk kernel.
a346 3
#ifdef RAMDISK_HOOKS
	boothowto = RB_SINGLE | RB_DFLTROOT;
#else
a347 1
#endif /* RAMDISK_HOOKS */
@


1.53
log
@Completely overhault attachment rules on sgi. No more indirect configuration
inherited from OpenBSD/arc machines with ISA bus; mainbus children match on
device name and other hierarchies match on simplified locators.
As a bonus, attachment lines in dmesg will now print their locators.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2007/12/18 08:29:02 jasper Exp $ */
a65 1
#include <machine/pio.h>
@


1.52
log
@add power(4), a driver for the power button found on SGI O2's.
when machdep.kbdreset is set, and the correct interrupt is fired,
the machine gets shut down.

with help from and ok jsing@@, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 2007/12/14 10:13:17 jsing Exp $ */
a290 5
		sys_config.local.bus_base = 0x0;		/*XXX*/
		sys_config.pci_io[0].bus_base = 0xffffffff00000000;/*XXX*/
		sys_config.pci_mem[0].bus_base = 0xffffffff00000000;/*XXX*/
		sys_config.pci_mem[0].bus_base_dma = 0x00000000;/*XXX*/
		sys_config.pci_mem[0].bus_reverse = my_endian;
d319 1
a319 1
		strlcpy(cpu_model, "SGI- Origin200 (IP27)", sizeof(cpu_model));
d326 1
a326 6
		sys_config.cons_iot = &xbowmux_tag;
		sys_config.local.bus_base = 0x0;		/*XXX*/
		sys_config.pci_io[0].bus_base = 0xffffffff00000000;/*XXX*/
		sys_config.pci_mem[0].bus_base = 0xffffffff00000000;/*XXX*/
		sys_config.pci_mem[0].bus_base_dma = 0x00000000;/*XXX*/
		sys_config.pci_mem[0].bus_reverse = my_endian;
@


1.51
log
@Store the ARCBIOS ConsoleOut environment variable so that we can refer to
it later on.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.50 2007/12/07 13:07:44 jsing Exp $ */
d129 1
d822 4
@


1.50
log
@Clean up comments - typos, grammatical errors and style(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 2007/10/22 16:59:56 miod Exp $ */
d348 7
d706 1
a706 2
	cp = Bios_GetEnvironmentVariable("ConsoleOut");
	if (cp != NULL && strncmp(cp, "serial", 6) == 0)
@


1.49
log
@Recognize kernel options specified on the "boot" command line (e.g. boot --c),
in addition to the OSLoadOptions variable; and do not default to -a -s if
it is missing or empty.

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2007/10/18 04:32:27 miod Exp $ */
d98 2
a99 2
/* the following is used externally (sysctl_hw) */
char	machine[] = MACHINE;		/* machine "architecture" */
d106 1
a106 1
#define	BUFCACHEPERCENT	5	/* Can be changed in config */
d109 1
a109 1
#define BUFPAGES 0		/* Can be changed in config */
d122 3
a124 3
int	physmem;		/* max supported memory, changes to actual */
int	rsvdmem;		/* reserved memory not usable */
int	ncpu = 1;		/* At least one cpu in the system */
d127 1
a127 1
int	console_ok;		/* set when console initialized */
d181 2
a182 3
		 * Do not report memory regions below 256MB, since
		 * arcbios will do. Moreover, empty banks are reported
		 * at address zero.
d193 2
a194 2
		 * Try to coalesce with other memory segments if banks
		 * are contiguous.
d251 1
a251 1
	 * Clear the compiled BSS segment in OpenBSD code
d271 2
a272 2
	 *  Initialize the system type and set up memory layout
	 *  Note that some systems have more complex memory setup.
d304 1
a304 1
		/* R1xK O2's are one disk slot machines. Offset slotno */
d311 1
a311 1
		/* R12K O2's must run with DSD on */
d361 1
a361 1
	 *  Figure out where we was booted from.
d375 1
a375 1
		/* get ethernet address from ARCBIOS */
d386 2
a387 2
	 *  Set pagesize to enable use of page macros and functions.
	 *  Commit available memory to UVM system
d412 1
a412 1
		/* Account for kernel and kernel symbol table */
d414 1
a414 1
			continue;	/* In kernel */
d418 1
a418 1
			continue;	/* Outside kernel */
d446 1
a446 1
		 *  Configure TLB.
d474 1
a474 1
	 *  Configure Cache.
d503 3
a505 3
	 *  Last chance to call the bios. Wiping the TLB means
	 *  bios data areas are demapped on most systems.
	 *  O2's are OK. Does not have mapped bios text or data.
d507 1
a507 1
	delay(20*1000);		/* Let any uart fifo drain... */
d513 1
a513 1
	/* XXX Save the following as an example on how to optimize I/O mapping */
d516 2
a517 2
	 *  Set up some fixed mappings. These are so frequently
	 *  used so faulting them in will waste to many cycles.
d548 1
a548 1
	 *  If an IP27 system set up Node 0's HUB.
d557 1
a557 1
	 *  Get a console, very early but after initial mapping setup.
d600 1
a600 1
	 *  Turn off bootstrap exception vectors.
d617 1
a617 1
	 *  Return new stack pointer.
d646 1
a646 1
 *  Decode boot options.
d698 1
a698 1
	/* Catch serial consoles on O2's */
d706 2
a707 3
 * Console initialization: called early on from main,
 * before vm init or startup.  Do enough configuration
 * to choose and initialize a console.
d720 2
a721 2
 * cpu_startup: allocate memory for variable-sized tables,
 * initialize cpu, and do autoconfiguration.
d731 1
a731 1
	pmapdebug = 0;	/* Shut up pmap debug during bootstrap */
d750 1
a750 1
	/* Restrict to at most 25% filled kvm */
d757 1
a757 1
	 * Allocate a submap for exec arguments.  This map effectively
d763 1
a763 1
	/* Allocate a submap for physio */
d798 1
a798 1
 * machine dependent system variables.
d810 1
a810 1
	/* all sysctl names at this level are terminal */
d812 1
a812 1
		return ENOTDIR;		/* overloaded */
d882 1
a882 1
	/* take a snap shot before clobbering any registers */
d894 1
a894 1
		 * explicitely asked for reboot.
d908 1
a908 1
		 * Synchronize the disks....
d914 2
a915 2
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now.
d924 1
a924 1
	(void) splhigh();		/* extreme priority */
d953 2
a954 2
int	dumpmag = (int)0x8fca0101;	/* magic number for savecore */
int	dumpsize = 0;		/* also for savecore */
d975 2
a976 2
	 * Don't dump on the first page
	 * in case the dump device includes a disk label.
d983 2
a984 3
 * Doadump comes here after turning off memory management and
 * getting on the dump stack, either when called above, or by
 * the auto-restart code.
d995 2
a996 2
	 * For dumps during autoconfiguration,
	 * if dump device has already configured...
d1039 1
a1039 1
 * Convert "xx:xx:xx:xx:xx:xx" string to ethernet hardware address.
d1071 1
a1071 1
	/* skip spaces if any */
d1076 1
a1076 1
	/* parse sign, allow more than one (compat) */
d1082 1
a1082 1
	/* parse base specification, if any */
d1101 1
a1101 1
	/* parse number proper */
d1123 1
a1123 1
 *  RM7000 Performance counter support.
a1124 1

d1168 2
a1169 2
 *  Called when the performance counter d31 gets set.
 *  Increase spill value and reset d31.
d1193 1
a1193 1
 *	Dump TLB contents.
@


1.48
log
@No need to include <machine/pte.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 2007/07/18 20:05:25 miod Exp $ */
d350 2
a351 2
	 * Default to SINGLE and ASKNAME if no args or
	 * SINGLE and DFLTROOT if this is a ramdisk kernel.
d356 1
a356 1
	boothowto = RB_SINGLE | RB_ASKNAME;
d661 7
a667 1
		if (cp != NULL && strncmp(cp, "OSLoadOptions=", 14) == 0) {
d674 22
@


1.47
log
@Do not bother trying to make the tlb handler fit - they are too large
and the r5000 errata workaround made them non-relocatable, so always copy
trampolines. This will be revisited when the tlb refill code will be selected
at runtime (soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2007/07/16 20:20:09 miod Exp $ */
a63 1
#include <machine/pte.h>
@


1.46
log
@Change idle_mask to be made of the cop0 SR bits unshifted and the cop0 IC bits
shifted, instead of the other way around; this shaves a few instructions.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2007/06/21 20:17:32 miod Exp $ */
a240 2
	extern char tlb_miss[], e_tlb_miss[];
	extern char xtlb_miss[], e_xtlb_miss[];
d592 1
a592 2
	 * Copy down exception vector code. If code is to large
	 * copy down trampolines instead of doing a panic.
d594 4
a597 13
	if (e_tlb_miss - tlb_miss > 0x80) {
		printf("NOTE: TLB code too large, using trampolines\n");
		bcopy(tlb_miss_tramp, (char *)TLB_MISS_EXC_VEC,
		    e_tlb_miss_tramp - tlb_miss_tramp);
		bcopy(xtlb_miss_tramp, (char *)XTLB_MISS_EXC_VEC,
		    e_xtlb_miss_tramp - xtlb_miss_tramp);
	} else {
		bcopy(tlb_miss, (char *)TLB_MISS_EXC_VEC,
		    e_tlb_miss - tlb_miss);
		bcopy(xtlb_miss, (char *)XTLB_MISS_EXC_VEC,
		    e_xtlb_miss - xtlb_miss);
	}

@


1.45
log
@Enable memory above 256MB again now that bus_dma has been fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2007/06/17 12:59:52 miod Exp $ */
d849 2
a850 2
	p->p_md.md_regs->sr |= (idle_mask << 8) & SR_INT_MASK;
	p->p_md.md_regs->ic = idle_mask & IC_INT_MASK;
@


1.44
log
@Disable memory above 256MB for now, it triggers bugs (probably related to
cache operations).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2007/05/29 20:36:48 deraadt Exp $ */
a300 1
#if 0
a301 1
#endif
@


1.43
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2007/05/27 17:31:57 miod Exp $ */
d301 1
d303 1
@


1.42
log
@Make sure the minaddr hint for uvm_km_suballoc() calls is always initialized.
ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 2007/05/27 14:26:44 miod Exp $ */
d945 1
a945 1
dumpconf()
d949 6
d956 5
a960 7
	if (dumpdev != NODEV && bdevsw[major(dumpdev)].d_psize) {
		nblks = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
		if (dumpsize > btoc(dbtob(nblks - dumplo)))
			dumpsize = btoc(dbtob(nblks - dumplo));
		else if (dumplo == 0)
			dumplo = nblks - btodb(ctob(physmem));
	}
@


1.41
log
@Print reserved memory size correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2007/05/26 20:26:51 pedro Exp $ */
d747 1
@


1.40
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 2007/05/23 20:33:47 pvalchev Exp $ */
d728 1
a728 1
	    ptoa(physmem)/1024/1024);
@


1.39
log
@Print real/available memory in MB as well as bytes in dmesg, and unify
architectures to print it the same way.
ok henning, miod; i386 part from tom
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 2007/05/03 19:34:01 miod Exp $ */
a105 3
#ifndef	NBUF
#define NBUF 0			/* Can be changed in config */
#endif
a112 1
int	nbuf = NBUF;
a654 22
	/*
	 * Determine how many buffers to allocate.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}
	/* Restrict to at most 35% filled kvm */
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 20)
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 20;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	valloc(buf, struct buf, nbuf);

a712 2
	unsigned i;
	int base, residual;
a713 1
	vsize_t size;
d731 5
a735 16
	 * Allocate virtual address space for file I/O buffers.
	 * Note they are different than the array of headers, 'buf',
	 * and usually occupy more virtual memory than physical.
	 */
	size = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
			NULL, UVM_UNKNOWN_OFFSET, 0,
			UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
			UVM_ADV_NORMAL, 0)))
		panic("cpu_startup: cannot allocate VM for buffers");
	base = bufpages / nbuf;
	residual = bufpages % nbuf;

	for (i = 0; i < nbuf; i++) {
		vsize_t curbufsize;
		vaddr_t curbuf;
d737 5
a741 9
		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		curbuf = (vaddr_t)buffers + i * MAXBSIZE;
		curbufsize = PAGE_SIZE * (i < residual ? base+1 : base);
a742 11
		while (curbufsize) {
			struct vm_page *pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for"
					" buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
					VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
	}
a757 2
	printf("using %d buffers containing %d bytes of memory\n",
		nbuf, bufpages * PAGE_SIZE);
@


1.38
log
@Enable support for > 512MB of physical memory on mips64 systems, by using
XKPHYS instead of KSEG[01] for direct mappings.

Then, detect memory above 256MB on O2 by poking at the CRIME registers
(ARCbios will not report memory above 256MB, which is mapped above 1GB
physical, to the system), and add it to the UVM managed memory.

Tested on r5k, rm5200 and r10k with and without more than 256MB, matching
hinv reports in all cases. CRIME memory decoding based on a diff from
kettenis@@ in december 2005.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 2007/04/26 17:04:39 miod Exp $ */
d754 4
a757 2
	printf("real mem = %d\n", ptoa(physmem));
	printf("rsvd mem = %d\n", ptoa(rsvdmem));
d811 2
a812 1
	printf("avail mem = %d\n", ptoa(uvmexp.free));
@


1.37
log
@Be more careful when changing cop0 SR value; or flags in instead of setting
the SR value to them, and correctly propagate the SR to userland via proper
proc0 initialization and cpu_fork() care.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2007/04/26 17:02:40 miod Exp $ */
d84 1
d146 2
d165 67
a242 1
	unsigned firstaddr;
d252 7
d261 1
a261 1
	bzero(edata, end-edata);
d305 2
d402 14
a415 4
		u_int32_t firstkernpage =
		    atop(trunc_page(KSEG0_TO_PHYS(start)));
		u_int32_t lastkernpage =
		    atop(round_page(KSEG0_TO_PHYS(ekern)));
d580 1
a580 1
		(struct user *)pmap_steal_memory(USPACE, NULL,NULL);
a581 1
	firstaddr = KSEG0_TO_PHYS(proc0.p_addr);
d894 2
a895 1
	p->p_md.md_regs->sr = SR_FR_32|SR_XX|SR_KSU_USER|SR_UX|SR_EXL|SR_INT_ENAB;
@


1.36
log
@Do not invoke arcbios routines from the moment our page tables are set up,
to the moment we reboot, for we do not know what it can do behind our back;
this means the built-in ethernet address has to be read from the arcbios
environment earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 2007/04/10 16:54:46 miod Exp $ */
d244 1
a244 1
			setsr(SR_DSD);
d534 1
@


1.35
log
@Do not compile unused dump_tlb() unless option DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 2007/02/26 21:30:18 miod Exp $ */
d298 16
@


1.34
log
@Zero rval[1] in setregs.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 2006/08/11 08:17:37 jasper Exp $ */
d94 1
d96 1
d1124 1
d1172 1
@


1.33
log
@no O2's with a R14000 CPU were made, so remove superfluous code.

ok pefo
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 2006/05/07 18:58:53 robert Exp $ */
d804 2
@


1.32
log
@fix pmap debug code and only compile it when PMAPDEBUG is defined.
this change also unbreaks builds with DEBUG defined.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2006/03/14 22:42:01 deraadt Exp $ */
a235 1
		case MIPS_R14000:	/* Anyone seen an O2 with R14K? */
a361 1
		case MIPS_R14000:
@


1.31
log
@no need for an aperture.  we are unlikely to ever allow pci video cards
in these machines, because pci video cards contain too much evil.
if we do support them later, we add it back.  ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 2006/03/04 22:02:47 brad Exp $ */
d639 3
a641 3
#ifdef DEBUG
	extern int pmapdebugflag;
	int opmapdebugflag = pmapdebugflag;
d643 1
a643 1
	pmapdebugflag = 0;	/* Shut up pmap debug during bootstrap */
d702 2
a703 2
#ifdef DEBUG
	pmapdebugflag = opmapdebugflag;
@


1.30
log
@| -> ||

From: Alexey Dobriyan <adobriyan at gmail dot com> on bugs@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 2006/01/04 20:25:34 miod Exp $ */
a98 7
#ifdef APERTURE
#if defined(INSECURE) || defined(DEBUG)
int allowaperture = 1;
#else
int allowaperture = 0;
#endif
#endif
a750 9
	case CPU_ALLOWAPERTURE:
#ifdef APERTURE
	if (securelevel > 0)
		return sysctl_rdint(oldp, oldlenp, newp, allowaperture);
	else
		return sysctl_int(oldp, oldlenp, newp, newlen, &allowaperture);
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
@


1.29
log
@Cut buffers pressure down to 35% of kvm max, since (for now) kvm is
scaringly scarce on mips64. While there, no need to zero memory in
allocsys().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 2006/01/04 20:23:11 miod Exp $ */
d256 1
a256 1
#if defined(TGT_ORIGIN200) | defined(TGT_ORIGIN2000)
d457 1
a457 1
#if defined(TGT_ORIGIN200) | defined(TGT_ORIGIN2000)
@


1.28
log
@Stop abusing phys_map to know if it is safe to use malloc in extent routines;
instead use a global flag, like some other architectures do. No functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 2006/01/04 20:17:12 miod Exp $ */
d572 1
a572 1
	/* Restrict to at most 70% filled kvm */
d574 1
a574 1
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 10)
d576 1
a576 1
		    MAXBSIZE * 7 / 10;
a583 7
	/*
	 * Clear allocated memory.
	 */
	if (start != 0) {
		bzero(start, v - start);
	}

d669 1
a669 1
			UVM_ADV_NORMAL, 0)) != KERN_SUCCESS) {
a670 1
	}
a672 5
	if (base >= MAXBSIZE / PAGE_SIZE) {
		/* don't want to alloc more physical mem than needed */
		base = MAXBSIZE / PAGE_SIZE;
		residual = 0;
	}
@


1.27
log
@Better rounding logic when registering memory regions in uvm; we would lose
a page per region by mistake.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 2005/12/19 21:37:49 miod Exp $ */
d48 1
d127 2
d728 3
@


1.26
log
@Use MACE ISA constants instead of magic values.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 2005/12/12 20:58:49 miod Exp $ */
d309 1
a309 1
	for(i = 0; i < MAXMEMSEGS && mem_layout[i].mem_first_page != 0; i++) {
d311 4
a314 2
		u_int32_t firstkernpage = atop(KSEG0_TO_PHYS(start));
		u_int32_t lastkernpage = atop(KSEG0_TO_PHYS(ekern));
d317 1
a317 1
		lp = mem_layout[i].mem_last_page - 1;
d329 1
a329 1
			fp = lastkernpage + 1;
d331 1
a331 1
			lp = firstkernpage - 1;
d333 1
a333 1
			u_int32_t xp = firstkernpage - 1;
d335 1
a335 1
			fp = lastkernpage + 1;
@


1.25
log
@Correct uvm_km_suballoc() arguments, do not make phys_map pageable.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 2005/08/06 14:26:52 miod Exp $ */
d220 2
a221 2
		sys_config.cons_ioaddr[0] = 0x00390000;	/*XXX*/
		sys_config.cons_ioaddr[1] = 0x00398000;	/*XXX*/
@


1.24
log
@We do not need a char machine_arch[] constant.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 2005/02/20 15:39:04 miod Exp $ */
d47 1
a47 1
#include <sys/exec_olf.h>
a56 3
#ifdef MFS
#include <ufs/mfs/mfs_extern.h>
#endif
d71 1
a71 1
#if defined(TGT_ORIGIN200) | defined(TGT_ORIGIN2000)
d84 1
a84 1
#if defined(TGT_ORIGIN200) | defined(TGT_ORIGIN2000)
d711 2
a712 2
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr, 16 * NCARGS,
					TRUE, FALSE, NULL);
d715 1
a715 1
	    VM_PHYS_SIZE, TRUE, FALSE, NULL);
@


1.23
log
@Feature-sync boot() with other platforms:
- run shutdown hooks.
- do not turn reboot into halt if cold and invoked from ddb.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 2005/01/18 15:03:38 grange Exp $ */
a99 1
char	machine_arch[] = MACHINE_ARCH;	/* cpu "architecture" */
@


1.22
log
@Move rm7000.h file from sgi to mips64.

ok pefo@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 2004/12/14 09:07:49 grange Exp $ */
d849 10
d875 5
a879 1
		resettodr();
d881 1
d884 6
a900 1
		while(1); /* Forever */
a901 2
		if (howto & RB_DUMP)
			dumpsys();
a905 1
		while(1); /* Forever */
d907 1
@


1.21
log
@typos; ok pefo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 2004/12/13 15:34:46 grange Exp $ */
d78 1
a78 1
#include <machine/rm7000.h>
@


1.20
log
@Use PAGE_SIZE instead of hardcoded 4096 value.

ok miod@@ pefo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 2004/12/02 19:37:25 miod Exp $ */
d194 1
a194 1
	 *  Reserve symol table space. If invalid pointers no table.
d505 1
a505 1
		printf("NOTE: TLB code to large, using trampolines\n");
@


1.19
log
@Make BUFCACHEPERCENT adjustable through UKC, like all other arches do.

(This means twice as less buffers on hp300 with unmodified GENERIC kernels
now)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 2004/10/22 10:15:42 pefo Exp $ */
d310 1
a310 1
	uvmexp.pagesize = 4096;
@


1.18
log
@xbowmux not yet
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 2004/10/20 12:49:15 pefo Exp $ */
d116 3
d125 1
a560 4
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

d564 2
a565 3
	if (bufpages == 0) {
		bufpages = (physmem / (100/BUFCACHEPERCENT));
	}
d572 4
a575 3
	if (nbuf > (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 7 / 10) {
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 7 / 10;
	}
d578 1
a578 1
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE) {
a579 1
	}
@


1.17
log
@Fix some 64 bit address problems.
Some function names made more unique.
Other changes for the upcoming Origin 200 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 2004/09/27 18:51:18 pefo Exp $ */
d87 1
d89 1
d210 1
a210 1
bios_printf("SR=%08x\n", getsr());
@


1.16
log
@handle R12K DSD bit on O2's
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 2004/09/22 08:01:58 pefo Exp $ */
d74 3
d87 1
d91 1
a91 1
extern void makebootdev(const char *, int);
d94 2
d145 1
a145 1
caddr_t mips_init(int, int32_t *);
d151 3
a153 1
static void dobootopts(int, int32_t *);
d169 1
a169 1
mips_init(int argc, int32_t *argv)
d177 1
a182 5
	 *  Clean up any mess.
	 */
	Bios_FlushAllCaches();

	/*
d204 1
d208 2
d213 5
a217 3
	if (sys_config.system_type == SGI_O2) {
		bios_putstring("Found SGI-IP32, setting up.\n");
		strlcpy(cpu_model, "SGI O2", sizeof(cpu_model));
a222 1
#if defined(_LP64)
a224 4
#else
		sys_config.pci_io[0].bus_base = 0x00000000;/*XXX*/
		sys_config.pci_mem[0].bus_base = 0x00000000;/*XXX*/
#endif
d228 1
d230 3
d248 27
a274 2
	} else {
		bios_putstring("Unsupported system!!!\n");
d279 3
a281 1
	 *  Use cpufrequency from bios to start with.
d283 16
a298 6
	cp = Bios_GetEnvironmentVariable("cpufreq");
	if (cp) {
		i = atoi(cp, 10, NULL);
		if (i > 100)
			sys_config.cpu[0].clock = i * 1000000;
	}
d324 1
a324 1
		if (fp > firstkernpage)
a336 18
	/*
	 *  Figure out where we was booted from.
	 */
	cp = Bios_GetEnvironmentVariable("OSLoadPartition");
	if (cp == NULL)
		cp = "unknown";
	makebootdev(cp, bootdriveoffs);

	/*
	 * Look at arguments passed to us and compute boothowto.
	 * Default to SINGLE and ASKNAME if no args or
	 * SINGLE and DFLTROOT if this is a ramdisk kernel.
	 */
#ifdef RAMDISK_HOOKS
	boothowto = RB_SINGLE | RB_DFLTROOT;
#else
	boothowto = RB_SINGLE | RB_ASKNAME;
#endif /* RAMDISK_HOOKS */
d338 9
a346 1
	dobootopts(argc, argv);
d348 12
a359 7
	/* Check l3cache size and disable (hard) if non present. */
	if (Bios_GetEnvironmentVariable("l3cache") != 0) {
		i = atoi(Bios_GetEnvironmentVariable("l3cache"), 10, NULL);
		CpuTertiaryCacheSize = 1024 * 1024 * i;
	} else {
		CpuTertiaryCacheSize = 0;
	}
d361 5
a365 6
	sys_config.cpu[0].type = (cp0_get_prid() >> 8) & 0xff;
	sys_config.cpu[0].vers_maj = (cp0_get_prid() >> 4) & 0x0f;
	sys_config.cpu[0].vers_min = cp0_get_prid() & 0x0f;
	sys_config.cpu[0].fptype = (cp1_get_prid() >> 8) & 0xff;
	sys_config.cpu[0].fpvers_maj = (cp1_get_prid() >> 4) & 0x0f;
	sys_config.cpu[0].fpvers_min = cp1_get_prid() & 0x0f;
d367 1
a367 7
	/*
	 *  Configure TLB.
	 */
	switch(sys_config.cpu[0].type) {
	case MIPS_RM7000:
		/* Rev A (version >= 2) CPU's have 64 TLB entries. */
		if (sys_config.cpu[0].vers_maj < 2) {
d369 1
a369 2
		} else {
			sys_config.cpu[0].tlbsize = 64;
d372 1
a372 7

	case MIPS_R10000:
	case MIPS_R12000:
	case MIPS_R14000:
		sys_config.cpu[0].tlbsize = 64;
		break;

a373 1
		sys_config.cpu[0].tlbsize = 48;
d406 6
d450 10
a462 1
	bios_putstring("Initial setup done, switching console.\n\n");
d464 1
d493 1
d499 1
d507 2
d514 10
a530 5
	 * Clear out the I and D caches.
	 */
	Mips_SyncCache();

	/*
d597 1
a597 1
dobootopts(int argc, int32_t *argv)
d604 4
a607 1
		cp = (char *)(long)argv[i];
d618 1
d1126 48
@


1.15
log
@On single SCSI slot O2's the first disk is numbered 2 (the slot number)
by the ARCS Bios. To make the kernel pick up the right sd number offset
the slots if the CPU is a R10K or larger. R10K's and up are those with
single disk slots.

A more correct solution would be to dig down and check the SCSI ID's,
but right now this solutions works OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.14 2004/09/21 08:55:20 miod Exp $ */
d230 1
a230 1
		case MIPS_R14000:
d234 6
d761 3
@


1.14
log
@nswbuf is long dead; also silence debug printf unless option DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.13 2004/09/21 05:51:15 miod Exp $ */
d87 1
a87 1
extern void makebootdev(const char *);
d126 1
d224 10
a233 1
		sys_config.cpu[0].clock = 200000000;  /* Reasonable default */
d292 1
a292 1
	makebootdev(cp);
@


1.13
log
@Nuke commons.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 2004/09/20 10:31:16 pefo Exp $ */
a111 1
int	nswbuf = 0;
a165 1
	struct tlb tlb;
d369 1
d379 2
d401 1
a513 7
	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) &~ 1;	/* even */
		if (nswbuf > 256) {
			nswbuf = 256;
		}
	}

d1006 1
d1008 1
d1022 1
d1024 1
@


1.12
log
@Add support for R10K cpu class
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.11 2004/09/16 19:38:30 miod Exp $ */
a118 1
int	msgbufmapped;		/* set when safe to use msgbuf */
d265 1
a265 1
		if (fp > firstkernpage) 
d857 1
@


1.11
log
@Correctly read the symbol table pointers passed by the boot code.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.10 2004/09/09 22:11:39 pefo Exp $ */
a307 1
	sys_config.cpu[0].cfg_reg = Mips_ConfigCache();
d320 1
d328 6
d336 29
@


1.10
log
@Kernel moves to 64 bit. A few more tweaks when binutils is updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.9 2004/09/09 10:25:52 miod Exp $ */
d188 2
a189 2
	ssym = (char *)(long)*(int *)end;
	esym = (char *)(long)*((int *)end + 1);
@


1.9
log
@Kill mb_map and related defines, we don't need one.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.8 2004/08/26 13:30:25 pefo Exp $ */
d191 2
a192 2
	if (((int)ssym - (int)end) < 0 ||
	    ((int)ssym - (int)end) > 0x1000 ||
d404 1
a404 1
	if (e_tlb_miss - tlb_miss > 0x100) {
d509 1
a509 1
		cp = (char *)argv[i];
d704 1
a704 1
#if !defined(_LP64)
d706 2
d714 2
a715 2
#if 0
	p->p_md.md_regs->sr = SR_FR_32|SR_KSU_USER|SR_UX|SR_EXL|SR_INT_ENAB;
@


1.8
log
@diskboot changes
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.7 2004/08/23 14:28:39 pefo Exp $ */
a116 1
vm_map_t mb_map;
a620 3
	/* Finally, allocate mbuf pool. */
	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				VM_MBUF_SIZE, FALSE, FALSE, NULL);
@


1.7
log
@fix free page commit handling
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.6 2004/08/11 17:06:14 pefo Exp $ */
d87 1
a87 1
extern void makebootdev(char *);
d147 1
a147 1
static void dobootopts(char *cp);
a165 1
	char *arg0;
a174 1
	char xxx[100];
d283 4
a286 8
	if (argc > 1)
		arg0 = (char *)(long)argv[1];
	else
		arg0 = Bios_GetEnvironmentVariable("bootdev");

	if (arg0 == 0)
		arg0 = "unknown";
	makebootdev(arg0);
d299 1
a299 8
	dobootopts(Bios_GetEnvironmentVariable("osloadoptions"));

	/*  Check any extra arguments which override.  */
	for(i = 2; i < argc; i++) {
		if (*((char *)(long)argv[i]) == '-') {
			dobootopts((char *)(long)argv[i] + 1);
		}
	}
d503 2
a504 1
dobootopts(cp)
d506 1
a506 30
{
	while(cp && *cp) {
		switch (*cp++) {
		case 'm': /* multiuser */
			boothowto &= ~RB_SINGLE;
			break;

		case 's': /* singleuser */
			boothowto |= RB_SINGLE;
			break;

		case 'd': /* use compiled in default root */
			boothowto |= RB_DFLTROOT;
			break;

		case 'a': /* ask for names */
			boothowto |= RB_ASKNAME;
			break;

		case 'A': /* don't ask for names */
			boothowto &= ~RB_ASKNAME;
			break;

		case 't': /* use serial console */
			boothowto |= RB_SERCONS;
			break;

		case 'c': /* boot configure */
			boothowto |= RB_CONFIG;
			break;
d508 10
a517 3
		case 'B': /* Enter debugger */
			boothowto |= RB_KDB;
			break;
d519 1
d521 3
a523 1
	}
d736 1
a736 2
boot(howto)
	register int howto;
a988 1
printf("perfcnt read %d:%d -> %p\n", p->p_md.md_pc_count, p->p_md.md_pc_spill, arg1);
@


1.6
log
@no ecoff
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.5 2004/08/10 19:16:18 deraadt Exp $ */
d171 1
a171 1
	extern char edata[], end[];
d176 1
d253 3
a255 2
		vaddr_t fp, lp;
		u_int32_t lastkernpage = atop(ekern);
d260 16
a275 2
		/* Account for expansion from kernel symbol table */
		if (fp < lastkernpage && lp >= lastkernpage)
d277 2
a278 2

		if (fp <= lp)
@


1.5
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.4 2004/08/10 18:47:22 deraadt Exp $ */
a75 2

#include <sys/exec_ecoff.h>
@


1.4
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.3 2004/08/10 12:32:14 pefo Exp $ */
d271 1
a271 1
	if(argc > 1)
d276 1
a276 1
	if(arg0 == 0)
d295 1
a295 1
		if(*((char *)(long)argv[i]) == '-') {
d301 1
a301 1
	if(Bios_GetEnvironmentVariable("l3cache") != 0) {
d321 1
a321 1
		if(sys_config.cpu[0].vers_maj < 2) {
d490 1
a490 1
	if(start != 0) {
d899 1
a899 1
	if(s != NULL) {
d991 1
a991 1
		if((arg1 & 0xff) > PCNT_SRC_MAX ||
d1030 1
a1030 1
	if(p != NULL) {
@


1.3
log
@Don't mess with the msgbuf location when free memory is determined by the bios.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.2 2004/08/09 14:57:26 pefo Exp $ */
d5 1
a5 1
 * 
d75 1
a75 1
#include <machine/rm7000.h> 
d143 1
a143 1
caddr_t mips_init(int, int32_t *);	
d265 1
a265 1
			uvm_page_physload(fp, lp, fp, lp, VM_FREELIST_DEFAULT); 
d336 3
a338 2
	
/* XXX Save the following as an example on how to optimize I/O mapping */
d392 2
a393 2
        sd = (caddr_t)pmap_steal_memory(i, NULL, NULL);
        allocsys(sd);
d478 1
a478 1
	if (nswbuf == 0) { 
d715 1
a715 1
        Elf64_Ehdr *eh = pack->ep_hdr;
d717 4
a720 4
        if ((((eh->e_flags & EF_MIPS_ABI) != E_MIPS_ABI_NONE) &&
            ((eh->e_flags & EF_MIPS_ABI) != E_MIPS_ABI_O32)) ||
            ((eh->e_flags & EF_MIPS_ARCH) >= E_MIPS_ARCH_3) ||
            (eh->e_ident[EI_CLASS] != ELFCLASS32)) {
d722 1
a722 1
        }
d972 1
a972 1
	return val;	
d991 1
a991 1
		if((arg1 & 0xff) > PCNT_SRC_MAX || 
a1032 1
	
@


1.2
log
@Big cleanup. Removed some unused obsolete stuff and fixed copyrights
on some files. Arcbios support is now in, thus detects memorysize and cpu
clock frequency.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.1 2004/08/06 21:12:19 pefo Exp $ */
d122 2
a123 3
#if 0
register_t tlbtrcptr;
#endif
a124 1
int	msgbufmapped;		/* set when safe to use msgbuf */
a132 1
char	eth_hw_addr[6];		/* HW ether addr not stored elsewhere */
d150 1
a150 3
static void get_eth_hw_addr(char *, char *);
static int atoi(char *, int);
char gt_ethaddr[6];
a235 13
#if 0
#if defined(DDB) || defined(DEBUG)
	physmem = atop(1024 * 1024 * 256);
#if defined(_LP64)
	tlbtrcptr = 0xffffffff90000000;
	memset((void *)0xffffffff90000000, 0, 1024*1024);
#else
	tlbtrcptr = 0x90000000;
	memset((void *)0x90000000, 0, 1024*1024);
#endif
#endif
#endif

d241 1
a241 1
		i = atoi(cp, 10);
a290 1
	get_eth_hw_addr(Bios_GetEnvironmentVariable("ethaddr"), eth_hw_addr);
d302 1
a302 1
		i = atoi(Bios_GetEnvironmentVariable("l3cache"), 10);
d337 1
d364 1
d373 6
a427 5
	 * Initialize error message buffer.
	 */
	initmsgbuf((caddr_t)0xffffffff80002000, MSGBUFSIZE);

	/*
d893 2
a894 2
static void
get_eth_hw_addr(char *s, char *a)
d897 1
d900 3
a902 2
			a[i] = atoi(s, 16);
			s += 3;		/* Don't get to fancy here :-) */
d911 1
a911 3
atoi(s, b)
	char *s;
	int   b;
d917 5
a921 2
	if (s == 0 || (c = *s++) == 0)
		goto out;
d924 1
a924 1
	while (c == ' ' || c == '\t')
d926 1
d969 2
a970 1
out:
@


1.1
log
@initial sgi import
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d81 1
d89 2
a90 2
extern void makebootdev __P((char *));
extern void stacktrace __P((void));
d128 1
d144 1
a144 2
struct mem_descriptor mem_layout[MAXMEMSEGS];
vaddr_t     avail_end;      /* PA of last available physical page */
d146 1
a146 1
caddr_t mips_init __P((int, int32_t *, int32_t *));	
a151 1
static char *getenv(char *env);
d170 1
a170 1
mips_init(int argc, int32_t *argv, int32_t *envv)
d185 5
d192 1
a192 1
	bzero(edata, (int)end - (int)edata);
d210 1
a210 1
	 * Point environment for getenv() lookups.
d212 1
a212 1
	environment = envv;
d217 2
a218 5
	sys_config.system_type = -1;
	cp = getenv("systype");
/*XXX*/    cp = "moosehead";
	if(cp && strncasecmp("moosehead", cp, 9) == 0) {
		sys_config.system_type = SGI_O2;
d234 5
a238 11
		sys_config.cpu.tlbwired = 3;
	}

	/*
	 * Determine CPU clock frequency for timer and delay setup
	 */
	if(getenv("cpuclock") != 0) {
		sys_config.cpu.clock = atoi(getenv("cpuclock"), 10);
	}
	else {
		sys_config.cpu.clock = 180000000;  /* Reasonable default */
a240 9
	/*
	 *  Initialize virtual memory system.
         */
	if(getenv("memsize") != 0) {
		physmem = atop(atoi(getenv("memsize"), 10) * 1024 *1024);
	}
	else {
		physmem = atop(1024 * 1024 * 64);  /* Reasonable default */
	}
d254 14
a267 1
	/* Set pagesize to enable use of page macros and functions */
d271 3
a273 7
	/* Build up memory description and commit to UVM system */
	mem_layout[0].mem_start = atop(0x20000);	/* Skip int vectors */
	mem_layout[0].mem_size = atop(KSEG0_TO_PHYS(kernel_text));
	mem_layout[0].mem_size -= mem_layout[0].mem_start;

	mem_layout[1].mem_start = atop(round_page(KSEG0_TO_PHYS((long)ekern)));
	mem_layout[1].mem_size = physmem - mem_layout[1].mem_start;
d275 2
a276 1
	avail_end = ptoa(physmem);
d278 3
a280 2
	for(i = 1; i < MAXMEMSEGS && mem_layout[i].mem_size != 0; i++) {
		vaddr_t fp, lp;
d282 2
a283 3
		fp = mem_layout[i].mem_start;
		lp = mem_layout[i].mem_start + mem_layout[i].mem_size;
		uvm_page_physload(fp, lp, fp, lp, VM_FREELIST_DEFAULT); 
a288 1
argc = 0;
d292 1
a292 1
		arg0 = getenv("bootdev");
d309 2
a310 2
	get_eth_hw_addr(getenv("ethaddr"), eth_hw_addr);
	dobootopts(getenv("osloadoptions"));
d320 2
a321 2
	if(getenv("l3cache") != 0) {
		i = atoi(getenv("l3cache"), 10);
a325 17
	if(CpuTertiaryCacheSize == 0) {
		CpuExternalCacheOn = 0;		/* No L3 detected */
	} else {
		CpuExternalCacheOn = 1;
	}

	cp = getenv("ecache_on");
	if(cp && (*cp == 0 || *cp == 'n' || *cp == 'N')) {
		CpuExternalCacheOn = 0;		/* Override config setting */
	}

	cp = getenv("ocache_on");
	if(cp && (*cp == 0 || *cp == 'n' || *cp == 'N')) {
		CpuOnboardCacheOn = 0;		/* Override HW setting */
	} else {
		CpuOnboardCacheOn = 1;
	}
d327 7
a333 4
	sys_config.cpu.cfg_reg = Mips_ConfigCache();
	sys_config.cpu.type = cpu_id.cpu.cp_imp;
	sys_config.cpu.vers_maj = cpu_id.cpu.cp_majrev;
	sys_config.cpu.vers_min = cpu_id.cpu.cp_minrev;
d338 1
a338 1
	switch(sys_config.cpu.type) {
d340 2
a341 2
		if(sys_config.cpu.vers_maj < 2) {
			sys_config.cpu.tlbsize = 48;
d343 1
a343 1
			sys_config.cpu.tlbsize = 64;
d348 1
a348 1
		sys_config.cpu.tlbsize = 48;
a351 7
	if(getenv("tlbwired")) {
		i = atoi(getenv("tlbwired"), 10);
		if((i < sys_config.cpu.tlbwired) || (i >= sys_config.cpu.tlbsize)) {
		} else {
			sys_config.cpu.tlbwired = i;
		}
	}
d353 2
a354 2
	tlb_flush(sys_config.cpu.tlbsize);
	tlb_set_wired(sys_config.cpu.tlbwired);
d386 1
a388 6
	if (sys_config.system_type < 0) {
		printf("'systype' = '%s' not known!\n", cp ? cp : "NULL");
		panic("unidentified system");
	}


d425 1
a425 7

	/*
	 *  Keep PMON2000 exceptions if requested.
	 */
	if(!getenv("pmonexept")) {
		bcopy(exception, (char *)GEN_EXC_VEC, e_exception - exception);
	}
a513 24
 * Return a pointer to the given environment variable.
 */
static char *
getenv(envname)
	char *envname;
{
	int32_t *env = environment;
	char *envp;
	int i;

return(NULL);
	i = strlen(envname);

	while(*env) {
		envp = (char *)(long)*env;
		if(strncasecmp(envname, envp, i) == 0 && envp[i] == '=') {
			return(&envp[i+1]);
		}
		env++;
	}
	return(NULL);
}

/*
d597 1
d802 8
a809 4
		printf("System halted.\n");
		if(sys_config.system_type == ALGOR_P5064 && howto & RB_POWERDOWN) {
			printf("Shutting off!\n");
			*(int *)(0xffffffffbffa000c) = 1;
d811 1
d813 1
a813 2
	}
	else {
d817 3
a819 5
#if defined(LP64)
		__asm__(" li $2, 0xffffffff80010100; jr $2; nop\n");
#else
		__asm__(" li $2, 0x80010100; jr $2; nop\n");
#endif
@

