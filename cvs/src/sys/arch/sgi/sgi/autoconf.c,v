head	1.42;
access;
symbols
	OPENBSD_6_2:1.42.0.2
	OPENBSD_6_2_BASE:1.42
	OPENBSD_6_1:1.40.0.12
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.40.0.8
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.4
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.6
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.36.0.4
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.36.0.2
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.35.0.2
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.4
	OPENBSD_5_0:1.33.0.2
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.32.0.4
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.2
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.21.0.2
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.11.0.6
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.42
date	2017.06.08.12.02.52;	author visa;	state Exp;
branches;
next	1.41;
commitid	zGzjYZWjWwx4nSCj;

1.41
date	2017.06.08.11.47.25;	author visa;	state Exp;
branches;
next	1.40;
commitid	QkICkbt6ZtasPvLZ;

1.40
date	2015.01.02.22.38.46;	author sebastia;	state Exp;
branches;
next	1.39;
commitid	2Ybjy1BIuB1bzzpD;

1.39
date	2014.11.24.16.40.29;	author miod;	state Exp;
branches;
next	1.38;
commitid	r5wpGXh4hWvNa7s2;

1.38
date	2014.03.21.22.00.59;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2014.02.08.09.35.07;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2012.09.29.21.46.02;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2012.05.29.17.37.09;	author mikeb;	state Exp;
branches;
next	1.34;

1.34
date	2012.03.28.20.44.23;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2011.05.30.22.25.22;	author oga;	state Exp;
branches;
next	1.32;

1.32
date	2010.04.06.19.15.29;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2010.04.06.19.06.07;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.13.22.57.29;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.19.06.06.51;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.07.22.48.37;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.07.18.56.55;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.26.20.14.42;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.22.19.55.45;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.21.19.56.46;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.16.00.15.49;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.24.22.43.10;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.13.21.48.03;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.05.21.16.28.12;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.20.18.41.07;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2008.07.21.04.35.54;	author todd;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.30.22.19.33;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2008.02.29.19.02.34;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.01.19.25.10;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.15.01.56.47;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.04.19.30.55;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.04.03.44.44;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.27.18.31.10;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.19.21.37.10;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.25.23.02.25;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.23.08.21.27;	author mjc;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.20.12.49.15;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.22.08.01.58;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.26.13.30.25;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.10.19.16.18;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.10.18.47.22;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.09.10.11.37;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.21.12.19;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Move loongson/octeon/sgi unmap_startup() under arch/mips64.
@
text
@/*	$OpenBSD: autoconf.c,v 1.41 2017/06/08 11:47:25 visa Exp $	*/
/*
 * Copyright (c) 2009, 2010 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 2003-2004 Opsycon AB  (www.opsycon.se / www.opsycon.com)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
/*
 * Copyright (c) 1996 Per Fogelstrom
 * Copyright (c) 1995 Theo de Raadt
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department and Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Setup the system to run on the current machine.
 *
 * cpu_configure() is called at boot time.  Available
 * devices are determined (from possibilities mentioned in ioconf.c),
 * and the drivers are initialized.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/reboot.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/memconf.h>

#include <mips64/arcbios.h>
#include <mips64/archtype.h>

#include <uvm/uvm_extern.h>

#ifdef TGT_ORIGIN
#include <machine/mnode.h>
#endif
#ifdef TGT_OCTANE
#include <sgi/sgi/ip30.h>
#endif
#include <sgi/xbow/xbow.h>
#include <dev/pci/pcivar.h>
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

extern void dumpconf(void);

static u_long strtoul(const char *, int, const char **);

/*
 * The following several variables are related to
 * the configuration process, and are used in initializing
 * the machine.
 */
int	cold = 1;			/* if 1, still working on cold-start */
struct device *bootdv = NULL;
int16_t	currentnasid = 0;

char	osloadpartition[256];
char	osloadoptions[129];

/*
 *  Configure all devices found that we know about.
 *  This is done at boot time.
 */
void
cpu_configure(void)
{
	(void)splhigh();	/* Set mask to what we intend. */

	softintr_init();

	if (config_rootfound("mainbus", "mainbus") == 0) {
		panic("no mainbus found");
	}

	unmap_startup();

	splinit();		/* Initialized, fire up interrupt system */
	cold = 0;
}

void
diskconf(void)
{
	if (bootdv == NULL)
		printf("boot device: '%s' unrecognized.\n", osloadpartition);
	else
		printf("boot device: %s\n", bootdv->dv_xname);

	setroot(bootdv, 0, RB_USERREQ);
	dumpconf();
}

/*
 * Register a memory region.
 */
int
memrange_register(uint64_t startpfn, uint64_t endpfn, uint64_t bmask)
{
	struct phys_mem_desc *cur, *m = NULL;
	int i;

#ifdef DEBUG
{
	extern int console_ok;

	if (console_ok)
		printf("%s: memory from 0x%lx to 0x%lx\n",
		    __func__, ptoa(startpfn), ptoa(endpfn));
	else
		bios_printf("%s: memory from 0x%lx to 0x%lx\n",
		     __func__, ptoa(startpfn), ptoa(endpfn));
}
#endif
	physmem += endpfn - startpfn;

#ifdef TGT_OCTANE
	/*
	 * On Octane, the second 16KB page is reserved for the NMI handler.
	 */
	if (sys_config.system_type == SGI_OCTANE &&
	    startpfn < atop(IP30_MEMORY_BASE) + 2) {
		startpfn = atop(IP30_MEMORY_BASE) + 2;
		if (startpfn >= endpfn)
			return 0;
	}
#endif

	/*
	 * Prevent use of memory beyond what pmap can support.
	 * PG_FRAME is the highest supported page number.
	 */
	if (startpfn > atop(pfn_to_pad(PG_FRAME)))
		return 0;
	if (endpfn > atop(pfn_to_pad(PG_FRAME)))
		endpfn = 1 + atop(pfn_to_pad(PG_FRAME));
	
	for (i = 0, cur = mem_layout; i < MAXMEMSEGS; i++, cur++) {
		if (cur->mem_last_page == 0) {
			if (m == NULL)
				m = cur;	/* first free segment */
			continue;
		}
		/* merge contiguous areas */
		if (cur->mem_first_page == endpfn &&
		    ((cur->mem_last_page ^ startpfn) & bmask) == 0) {
			cur->mem_first_page = startpfn;
			return 0;
		}
		if (cur->mem_last_page == startpfn &&
		    ((cur->mem_first_page ^ endpfn) & bmask) == 0) {
			cur->mem_last_page = endpfn;
			return 0;
		}
	}

	if (m == NULL)
		return ENOMEM;
	
	m->mem_first_page = startpfn;
	m->mem_last_page = endpfn;
	return 0;
}

void	(*_device_register)(struct device *, void *);

void
device_register(struct device *dev, void *aux)
{
	if (_device_register)
		(*_device_register)(dev, aux);
}

#if defined(TGT_INDIGO) || defined(TGT_INDY) || defined(TGT_INDIGO2) || \
    defined(TGT_O2) || defined(TGT_OCTANE)

/*
 * ARCS boot path traversal
 */

const char *bootpath_get(int *);
void	bootpath_init(void);
void	bootpath_next(void);

static char bootpath_store[sizeof osloadpartition];
static char *bootpath_curpos;
static char *bootpath_lastpos;
static int bootpath_lastunit;

/*
 * Initialize bootpath analysis.
 */
void
bootpath_init()
{
	strlcpy(bootpath_store, osloadpartition, sizeof bootpath_store);
	bootpath_curpos = bootpath_store;
}

/*
 * Extract a component of the boot path, and return its name and unit
 * value.
 */
const char *
bootpath_get(int *u)
{
	char *c;
	int unit;

	/*
	 * If we don't have a value in cache, compute it.
	 */
	if (bootpath_lastpos == NULL) {
		if (bootpath_curpos == NULL)
			bootpath_init();

		unit = 0;
		c = strchr(bootpath_curpos, '(');
		if (c != NULL) {
			for (*c++ = '\0'; *c >= '0' && *c <= '9'; c++)
				unit = 10 * unit + (*c - '0');
			while (*c != ')' && *c != '\0')
				c++;
			if (*c == ')')
				c++;
		} else {
			c = bootpath_curpos + strlen(bootpath_curpos);
		}

		bootpath_lastpos = bootpath_curpos;
		bootpath_lastunit = unit;
		bootpath_curpos = c;
#ifdef DEBUG
		printf("%s: new component %s unit %d remainder %s\n", __func__,
		    bootpath_lastpos, bootpath_lastunit, bootpath_curpos);
#endif
	}

	*u = bootpath_lastunit;
	return bootpath_lastpos;
}

/*
 * Consume the current component of the bootpath, and switch to the next.
 */
void
bootpath_next()
{
	/* force bootpath_get to go forward */
	bootpath_lastpos = NULL;
#ifdef DEBUG
	printf("%s\n", __func__);
#endif
}

void
arcs_device_register(struct device *dev, void *aux)
{
	static struct device *lastparent = NULL;
#if defined(TGT_O2) || defined(TGT_OCTANE)
	static struct device *pciparent = NULL;
#endif
#if defined(TGT_INDIGO) || defined(TGT_INDY) || defined(TGT_INDIGO2)
	static struct device *wdscparent = NULL;
#endif
	static int component_pos = 0;

	struct device *parent = dev->dv_parent;
	struct cfdata *cf = dev->dv_cfdata;
	struct cfdriver *cd = cf->cf_driver;

	const char *component;
	int unit;

	if (parent == NULL)
		return;		/* one of the @@root devices */

	if (bootdv != NULL)
		return;

	component = bootpath_get(&unit);
	if (*component == '\0')
		return;		/* exhausted path */

	/*
	 * The matching rules are as follows:
	 * xio() matches xbow.
	 * pci() matches any pci controller (macepcibr, xbridge), with the
	 *   unit number being ignored on O2 and the widget number of the
	 *   controller elsewhere.
	 * scsi() matches any pci scsi controller, with the unit number
	 *   being the pci device number (minus one on the O2, grr).
	 * disk() and cdrom() match sd and cd, respectively, with the
	 *   unit number being the target number.
	 *
	 * When a disk is found, we stop the parsing; rdisk() and
	 * partition() components are ignored.
	 */

#ifdef TGT_OCTANE
	if (strcmp(component, "xio") == 0) {
		struct mainbus_attach_args *maa = aux;

		if (strcmp(cd->cd_name, "xbow") == 0 && unit == maa->maa_nasid)
			goto found_advance;
	}
#endif

#if defined(TGT_O2) || defined(TGT_OCTANE)
	if (strcmp(component, "pci") == 0) {
		/*
		 * We'll work in two steps. The controller itself will be
		 * recognized with its parent device and attachment
		 * arguments (if necessary).
		 *
		 * Then we'll only advance the bootpath when matching the
		 * pci device.
		 */
		if (strcmp(cd->cd_name, "pci") == 0 &&
		    parent == lastparent) {
			pciparent = dev;
			goto found_advance;
		}

#ifdef TGT_O2
		if (strcmp(cd->cd_name, "macepcibr") == 0)
			goto found;
#endif
#ifdef TGT_OCTANE
		if (strcmp(cd->cd_name, "xbridge") == 0 &&
		    parent == lastparent) {
			struct xbow_attach_args *xaa = aux;

			if (unit == xaa->xaa_widget)
				goto found;
		}
		if (strcmp(cd->cd_name, "xbpci") == 0 &&
		    parent == lastparent) {
			goto found;
		}
#endif
	}
#endif	/* TGT_O2 || TGT_OCTANE */

	if (strcmp(component, "scsi") == 0) {
		/*
		 * We'll work in two steps. The controller itself will be
		 * recognized with its parent device and pci_attach_args
		 * need to match the scsi() unit number.
		 *
		 * Then we'll only advance the bootpath when matching the
		 * scsibus device.
		 */

		if (strcmp(cd->cd_name, "scsibus") == 0) {
			if (parent == lastparent)
				goto found_advance;

			if (component_pos == 0)
			switch (sys_config.system_type) {
#ifdef TGT_O2
			/*
			 * On O2, the pci(0) component may be omitted from
			 * the bootpath, in which case we fake the missing
			 * pci(0) component.
			 */
			case SGI_O2:
				if (parent->dv_parent != NULL &&
				    strcmp(parent->dv_parent->dv_cfdata->cf_driver->cd_name,
				      "pci") == 0) {
					pciparent = parent->dv_parent;
					goto found_advance;
				}
				break;
#endif
#if defined(TGT_INDIGO) || defined(TGT_INDY) || defined(TGT_INDIGO2)
			/*
			 * On Ind{igo,y,igo^2} systems, the bootpath
			 * starts at scsi().
			 */
			case SGI_IP20:
			case SGI_IP22:
			case SGI_IP26:
			case SGI_IP28:
				if (strcmp(parent->dv_cfdata->cf_driver->cd_name,
				    "wdsc") == 0 &&
				    parent->dv_parent != NULL &&
				    strcmp(parent->dv_parent->dv_cfdata->cf_driver->cd_name,
				    "hpc") == 0) {
					wdscparent = parent;
					goto found_advance;
				}
				break;
#endif
			default:
				break;
			}
		}

		if (parent == lastparent) {
#if defined(TGT_O2) || defined(TGT_OCTANE)
			if (parent == pciparent) {
				struct pci_attach_args *paa = aux;

				if (unit == paa->pa_device -
				    (sys_config.system_type == SGI_O2 ? 1 : 0))
					goto found;
			} else
#endif
#if defined(TGT_INDIGO) || defined(TGT_INDY) || defined(TGT_INDIGO2)
			if (parent == wdscparent) {
				/* XXX is there any better information to use
				   XXX than the attachment number? */
				if (unit == parent->dv_unit)
					goto found;
			} else
#endif
			{
				/*
				 * in case scsi() can follow something else then
				 * pci(), write code to handle this here...
				 */
			}
		}
	}

	if ((strcmp(component, "disk") == 0 &&
	     strcmp(cd->cd_name, "sd") == 0) ||
	    (strcmp(component, "cdrom") == 0 &&
	     strcmp(cd->cd_name, "cd") == 0)) {
		if (parent == lastparent) {
			struct scsi_attach_args *saa = aux;

			if (unit == saa->sa_sc_link->target) {
				/*
				 * We found our boot device.
				 * Now get the partition number.
				 */
				bootdv = dev;
#ifdef DEBUG
				printf("%s: boot device is %s\n",
				    __func__, dev->dv_xname);
#endif
				return;
			}
		}
	}

	if (strcmp(component, "bootp") == 0 && cd->cd_class == DV_IFNET) {
#ifdef TGT_OCTANE
		if (strcmp(cd->cd_name, "iec") == 0)
			bootdv = dev;
#endif
#ifdef TGT_O2
		if (strcmp(cd->cd_name, "mec") == 0)
			bootdv = dev;
#endif
#if defined(TGT_INDIGO) || defined(TGT_INDY) || defined(TGT_INDIGO2)
		if (strcmp(cd->cd_name, "sq") == 0)
			bootdv = dev;
#endif
#ifdef DEBUG
		if (bootdv != NULL)
			printf("%s: boot device is %s\n",
			    __func__, dev->dv_xname);
#endif
		return;
	}

	return;

found_advance:
	bootpath_next();
	component_pos++;
found:
	lastparent = dev;
}

#endif	/* IP20/22/24/26/28/30/32 */

#ifdef TGT_ORIGIN

/*
 * Origin (dksc) boot path analysis
 */

void	dksc_init(void);
int	dksc_scan_board(lboard_t *, void *);
int	dksc_scan_cmp(klinfo_t *, void *);

static struct sgi_device_location dksc_device;
static int dksc_ctrl, dksc_unit;
static const char *dksc_devname;

void
dksc_init()
{
	int val[3], idx;
	char *c = NULL;

	if (strncmp(osloadpartition, "dksc(", 5) == 0) {
		c = osloadpartition + 5;
		dksc_devname = "sd";
	} else if (strncmp(osloadpartition, "cdrom(", 6) == 0) {
		c = osloadpartition + 6;
		dksc_devname = "cd";
	}

	if (c == NULL)
		return;

	val[0] = val[1] = val[2] = 0;
	idx = 0;

	for (; *c != '\0'; c++) {
		if (*c == ')')
			break;
		else if (*c == ',') {
			if (++idx == 3)
				break;
		} else if (*c >= '0' && *c <= '9')
			val[idx] = 10 * val[idx] + (*c - '0');
	}

	dksc_ctrl = val[0];
	dksc_unit = val[1];

	/*
	 * Walk kl configuration and try to match the boot controller
	 * with a component.
	 */
	kl_scan_all_nodes(KLBRD_ANY, dksc_scan_board, NULL);
}

int
dksc_scan_board(lboard_t *brd, void *arg)
{
	kl_scan_board(brd, KLSTRUCT_ANY, dksc_scan_cmp, arg);
	return 0;
}

int
dksc_scan_cmp(klinfo_t *cmp, void *arg)
{
	klscctl_t *scsi2comp;
	klscsi_t *scsicomp;
	int i;

	/* bail out quickly if no controller number */
	if (cmp->virtid < 0)
		return 0;

	switch (cmp->struct_type) {
	case KLSTRUCT_SCSI:
	case KLSTRUCT_FIBERCHANNEL:
	case KLSTRUCT_QLFIBRE:
	case KLSTRUCT_FIREWIRE:
#if 0	/* should not get controller numbers anyway */
	case KLSTRUCT_IDE:
	case KLSTRUCT_IOC4_ATA:
#endif
		if (cmp->virtid == dksc_ctrl) {
			kl_get_location(cmp, &dksc_device);
			return 1;
		}
		break;
	case KLSTRUCT_SCSI2:
		/*
		 * Figure out whether one of the two ports matches our
		 * controller number.
		 */
		scsi2comp = (klscctl_t *)cmp;
		for (i = 0; i < scsi2comp->scsi_buscnt; i++) {
			scsicomp = (klscsi_t *)scsi2comp->scsi_bus[i];
			if (scsicomp == NULL)
				continue;
			if (scsicomp->scsi_info.virtid == dksc_ctrl) {
				kl_get_location(cmp, &dksc_device);
				dksc_device.specific = i;	/* port # */
				return 1;
			}
		}
		break;
	}

	return 0;
}

void
dksc_device_register(struct device *dev, void *aux)
{
	static int dksc_state = 0;
	static struct device *controller = NULL;
	static struct device *scsibus = NULL;

	struct device *parent = dev->dv_parent;
	struct cfdata *cf = dev->dv_cfdata;
	struct cfdriver *cd = cf->cf_driver;

	struct sgi_device_location dl;

	if (dksc_state == 0) {
		dksc_state = 1;
		dksc_init();
	}

	if (parent == NULL)
		return;		/* one of the @@root devices */

	if (bootdv != NULL)
		return;

	/*
	 * If we already know our bus, try to match the correct device.
	 */
	if (scsibus != NULL) {
		if (strcmp(cd->cd_name, dksc_devname) == 0) {
			struct scsi_attach_args *saa = aux;
			if (dksc_unit == saa->sa_sc_link->target)
				bootdv = dev;
		}
		return;
	}

	/*
	 * If we already know our controller driver, try to match the
	 * correct scsibus.
	 */
	if (controller != NULL) {
		if (parent == controller &&
		    strcmp(cd->cd_name, "scsibus") == 0) {
			/* only match on the required bus */
			if (dksc_device.specific == 0)
				scsibus = dev;
			else
				dksc_device.specific--;
		}
		return;
	}

	/*
	 * If we are investigating a PCI bus, check whether the current
	 * device may be the controller we are looking for.
	 */

	if (strcmp(parent->dv_cfdata->cf_driver->cd_name, "pci") == 0) {
		struct pci_attach_args *paa = aux;
		if (pci_get_device_location(paa->pa_pc, paa->pa_tag, &dl) &&
		    location_match(&dksc_device, &dl))
			controller = dev;
		return;
	}
}

#endif	/* IP27/35 */

struct nam2blk nam2blk[] = {
	{ "sd",		0 },
	{ "wd",		4 },
	{ "rd",		8 },
	{ "vnd",	2 },
	{ NULL,		-1 }
};

/*
 * Convert "xx:xx:xx:xx:xx:xx" string to Ethernet hardware address.
 */
void
enaddr_aton(const char *s, u_int8_t *a)
{
	int i;

	if (s != NULL) {
		for (i = 0; i < 6; i++) {
			a[i] = strtoul(s, 16, &s);
			if (*s == ':')
				s++;
		}
	}
}

/*
 * Get a numeric environment variable
 */
u_long
bios_getenvint(const char *name)
{
	const char *envvar;
	u_long value;

	envvar = Bios_GetEnvironmentVariable(name);
	if (envvar != NULL) {
		value = strtoul(envvar, 10, &envvar);
		if (*envvar != '\0')
			value = 0;
	} else
		value = 0;

	return value;
}

/*
 * Convert an ASCII string into an integer.
 */
static u_long
strtoul(const char *s, int b, const char **o)
{
	int c;
	unsigned base = b, d;
	int neg = 0;
	u_long val = 0;

	if (s == NULL || *s == 0) {
		if (o != NULL)
			*o = s;
		return 0;
	}

	/* Skip spaces if any. */
	do {
		c = *s++;
	} while (c == ' ' || c == '\t');

	/* Parse sign, allow more than one (compat). */
	while (c == '-') {
		neg = !neg;
		c = *s++;
	}

	/* Parse base specification, if any. */
	if (base == 0 && c == '0') {
		c = *s++;
		switch (c) {
		case 'X':
		case 'x':
			base = 16;
			c = *s++;
			break;
		case 'B':
		case 'b':
			base = 2;
			c = *s++;
			break;
		default:
			base = 8;
		}
	}

	/* Parse number proper. */
	for (;;) {
		if (c >= '0' && c <= '9')
			d = c - '0';
		else if (c >= 'a' && c <= 'z')
			d = c - 'a' + 10;
		else if (c >= 'A' && c <= 'Z')
			d = c - 'A' + 10;
		else
			break;
		if (d >= base)
			break;
		val *= base;
		val += d;
		c = *s++;
	}
	if (neg)
		val = -val;
	if (o != NULL)
		*o = s - 1;
	return val;
}

/*
 * Relaxed comparison of two devices' physical location.
 */
int
location_match(struct sgi_device_location *l1, struct sgi_device_location *l2)
{
	/* must be on the same widget */
	if (l1->nasid != l2->nasid || l1->widget != l2->widget)
		return 0;

	/* must be on the same PCI bus, if applicable */
	if (l1->bus == -1 || l2->bus == -1)
		return 1;
	if (l1->bus != l2->bus)
		return 0;

	/* must be the same PCI device, if applicable */
	if (l1->device == -1 || l2->device == -1)
		return 1;
	if (l1->device != l2->device)
		return 0;

	/* must be the same PCI function, if applicable */
	if (l1->fn == -1 || l2->fn == -1)
		return 1;
	if (l1->fn != l2->fn)
		return 0;

	return 1;
}
@


1.41
log
@Split early startup code out of locore.S into locore0.S.  Adjust link
run so that this locore0.o is always at the start of the executable.
But randomize the link order of all other .o files in the kernel, so
that their exec/rodata/data/bss segments land all over the place.

Late during kernel boot, smash the startup code with traps so that
it does not point to the other randomly placed code.  It has be smashed,
because sgi runs in the kseg0 or xkphys space.

As a result, the internal layout of every newly build bsd kernel is
different from past kernels.  Internal relative offsets are not known
to an outside attacker.

Ramdisk kernels cannot be compiled like this, because they are gzip'd.
When the internal pointer references change, the compression dictionary
bloats and results in poorer compression.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.40 2015/01/02 22:38:46 sebastia Exp $	*/
a130 11

void
unmap_startup(void)
{
	extern uint32_t kernel_text[], endboot[];
	uint32_t *word = kernel_text;

	/* Cannot unmap kseg0 or xkphys; smash with trap. */
	while (word < endboot)
		*word++ = 0x00000034u;	/* TEQ zero, zero */
}
@


1.40
log
@Fix a few format string warnings, allow to build DEBUG kernel on sgi

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.39 2014/11/24 16:40:29 miod Exp $	*/
d132 11
d157 2
@


1.39
log
@Do not attempt to dereference NULL pointers when encountering an empty SCSI
bus on a dual-scsi controller abstraction, while walking the KL component
tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.38 2014/03/21 22:00:59 miod Exp $	*/
d177 1
a177 1
		printf("%s: memory from %p to %p\n",
d180 1
a180 1
		bios_printf("%s: memory from %p to %p\n",
@


1.38
log
@Keep the `clamp memory to what pmap can address' logic unconditional, and
use a <machine/pte.h> define to figure out what the pmap limit is.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.37 2014/02/08 09:35:07 miod Exp $	*/
d644 2
@


1.37
log
@Add option MIPS_PTE64 to IP27/IP35 kernels, and no longer ignore memory
beyond 16GB physical.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.36 2012/09/29 21:46:02 miod Exp $	*/
a197 1
#ifndef MIPS_PTE64
d199 2
a200 2
	 * Prevent use of memory above 16GB physical, until pmap can support
	 * this.
d202 1
a202 1
	if (startpfn >= atop(16UL * 1024 * 1024 * 1024))
d204 2
a205 3
	if (endpfn >= atop(16UL * 1024 * 1024 * 1024))
		endpfn = atop(16UL * 1024 * 1024 * 1024);
#endif
@


1.36
log
@Work in progress support for the Power Indigo2 R8000 system (IP26). This is
basically an IP22 system (R4000 Indigo2) with the ECC memory board of IP28,
and a so-called ``streaming'' L2 cache.

IP26 kernels currently boot single-user, but don't live long; I am suspecting
a bug in the tcc cache routines, but am currently not able to find it (come
to think of it, my understanding of how this cache works could be wrong, and
of course there is no documentation for it but what can be gathered from
IRIX' <sys/IP26.h> comments and defines).

Hopefully this situation will improve in the near future; in the meantime I
am commiting this as `work in progress' to make sure this code doesn't get
lost.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.35 2012/05/29 17:37:09 mikeb Exp $	*/
d197 2
d207 1
d449 1
a449 1
			 * On Ind{igo,y,igo2} systems, the bootpath
@


1.35
log
@Make it possible to disable the Sync-on-Green signal by setting the
ARCBios environment variable OSLoadOptions to "nosog".  Now everyone
can enjoy running O2 without an SGI monitor and don't turn vegetarian
afterwards.  All the essential bits come from NetBSD's crmfb driver
except they've chosen to use a "SyncOnGreen" variable not saved by
the ARCS.  Pointers and corrections from and ok miod, jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.34 2012/03/28 20:44:23 miod Exp $	*/
d328 1
d330 2
d333 1
d368 1
d375 1
d377 1
d393 1
d396 2
d409 1
d411 1
d446 1
a446 1
			 * On Ind{igo,y,i^2} systems, the bootpath
d469 1
d477 2
d484 7
a491 4
			/*
			 * in case scsi() can follow something else then
			 * pci(), write code to handle this here...
			 */
d515 21
@


1.34
log
@Work in progress support for the SGI Indigo, Indigo 2 and Indy systems
(IP20, IP22, IP24) in 64-bit mode, adapated from NetBSD. Currently limited
to headless operation, input and video drivers will get ported soon.

Should work on all R4000, R4440 and R5000 based systems. L2 cache on R5000SC
Indy not supported yet (coming soon), R4600 not supported yet either (coming
soon as well).

Tested to boot multiuser on: Indigo2 R4000SC, Indy R4000PC, Indy R4000SC,
Indy R5000SC, Indigo2 R4400SC. There are still glitches in the Ethernet driver
which are being looked at.

Expansion support is limited to the GIO E++ board; GIO boards with PCI-GIO
bridges not ported yet due to the lack of hardware, and this kind of driver
does not port blindly.

Most of this work comes from NetBSD, polishing and integration work, as well
as putting as many ``R4x00 in 64-bit mode'' erratas as necessary, by yours
truly.

More work is coming, as well as trying to get some easy way to boot install
kernels (as older PROM can only boot ECOFF binaries, which won't do for the
kernel).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33 2011/05/30 22:25:22 oga Exp $	*/
d130 1
@


1.33
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.32 2010/04/06 19:15:29 miod Exp $	*/
d241 2
a242 1
#if defined(TGT_O2) || defined(TGT_OCTANE)
d328 1
d414 2
d422 1
a422 2
			if (sys_config.system_type == SGI_O2 &&
			    component_pos == 0) {
d429 23
a452 1
#endif
d462 6
d507 1
a507 1
#endif	/* defined(TGT_O2) || defined(TGT_OCTANE) */
d681 1
a681 1
#endif
@


1.32
log
@Split the device_register() code responsible for boot path recognition into
two distinct sets of routines: one for the ARCBios-compatible path used on
non-KL systems (such as O2 and Octane), and one for the KL system using
dksc() paths.

When trying to match a dksc() path, walk the KL configuration of the whole
system until the dksc controller is found; since the controller numbers are
not assigned sequentially and contiguously, the old code would not work on
complex systems (such as when booting from controller #6 when #3 to #5 are
unaffected).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.31 2010/04/06 19:06:07 miod Exp $	*/
d166 1
a166 2
memrange_register(uint64_t startpfn, uint64_t endpfn, uint64_t bmask,
    unsigned int freelist)
d211 10
a220 12
		/* merge contiguous areas if on the same freelist */
		if (cur->mem_freelist == freelist) {
			if (cur->mem_first_page == endpfn &&
			    ((cur->mem_last_page ^ startpfn) & bmask) == 0) {
				cur->mem_first_page = startpfn;
				return 0;
			}
			if (cur->mem_last_page == startpfn &&
			    ((cur->mem_first_page ^ endpfn) & bmask) == 0) {
				cur->mem_last_page = endpfn;
				return 0;
			}
a228 1
	m->mem_freelist = freelist;
@


1.31
log
@Introduce struct sgi_device_location to carry enough information to uniquely
identify a given device by its physical connection, and add a lazy compare
routine. This will be used shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30 2010/01/13 22:57:29 miod Exp $	*/
d3 1
a3 1
 * Copyright (c) 2009 Miodrag Vallat.
d105 4
d110 1
d118 1
a118 6
static u_long atoi(const char *, int, const char **);

void	bootpath_convert(void);
const char *bootpath_get(int *);
void	bootpath_init(void);
void	bootpath_next(void);
d236 19
a258 3
#ifdef TGT_ORIGIN
static int dksc_ctrl, dksc_mode;
#endif
a267 55

#ifdef TGT_ORIGIN
	/*
	 * If this is the first time we're ever invoked,
	 * check for a dksc() syntax and rewrite it as
	 * something more friendly to us.
	 */
	if (strncmp(bootpath_store, "dksc(", 5) == 0)
		bootpath_convert();
#endif
}

#ifdef TGT_ORIGIN
/*
 * Convert a `dksc()' bootpath into an ARC-friendly bootpath.
 */
void
bootpath_convert()
{
	int val[3], idx;
	char *c;

	val[0] = val[1] = val[2] = 0;
	idx = 0;

	for (c = bootpath_store + 5; *c != '\0'; c++) {
		if (*c == ')')
			break;
		else if (*c == ',') {
			if (++idx == 3)
				break;
		} else if (*c >= '0' && *c <= '9')
			val[idx] = 10 * val[idx] + (*c - '0');
	}

	/*
	 * We can not convert the dksc() bootpath to an exact ARCS bootpath
	 * without knowing our device tree already.  This is because
	 * the controller number is not an absolute locator, but rather an
	 * occurence number.
	 *
	 * So we convert to an incomplete ARCS bootpath and have explicit
	 * dksc handling in device_register().  This relies on our device
	 * probe order matching ARCS.
	 */

	dksc_ctrl = val[0];
	dksc_mode = 1;
	snprintf(bootpath_store, sizeof bootpath_store,
	    "scsi(%d)disk(%d)rdisk(0)partition(%d)",
	    val[0], val[1], val[2]);
#ifdef DEBUG
	printf("%s: converting %s to %s\n",
	    __func__, osloadpartition, bootpath_store);
#endif
a268 1
#endif
d327 1
a327 1
device_register(struct device *dev, void *aux)
a355 3
	 *   XXX I have no idea how this works when PIC devices are involved
	 *   XXX since they provide two distinct PCI buses...
	 *   XXX ...and our device numbering is off by one in that case.
d357 1
a357 2
	 *   being the pci device number (minus one on the O2, grr),
	 *   or the scsibus number in dksc mode.
d398 1
a398 2
			if (1)	/* how to match the exact bus number? */
				goto found;
a409 3
		 *
		 * With a dksc bootpath, things are a little different:
		 * we need to count scsi controllers, until we find ours.
a411 10
#ifdef TGT_ORIGIN
		if (dksc_mode) {
			if (strcmp(cd->cd_name, "scsibus") == 0 &&
			    dev->dv_unit == dksc_ctrl)
				goto found_advance;

			return;
		}
#endif

d480 176
d674 1
a674 1
			a[i] = atoi(s, 16, &s);
d692 1
a692 1
		value = atoi(envvar, 10, &envvar);
d705 1
a705 1
atoi(const char *s, int b, const char **o)
@


1.30
log
@Crude handler for the Octane NMI button, for kernels compiled with
option DDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.29 2009/11/19 06:06:51 miod Exp $	*/
d651 31
@


1.29
log
@Factor triplicated code responsible to add memory information into a
single place.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.28 2009/11/07 22:48:37 miod Exp $	*/
d105 1
d186 11
@


1.28
log
@In case an ioc(4) device has lost its NIC component, do not recognize it
as the onboard ioc device, if one has already been found on this node.

Also, on Origin 300, do not attempt to attach the PS/2 controller on the
onboard ioc(4) since PS/2 ports are not wired.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.27 2009/11/07 18:56:55 miod Exp $	*/
d98 2
d103 2
d159 63
@


1.27
log
@Replace option TGT_ORIGIN200 and TGT_ORIGIN2000 with a single option,
TGT_ORIGIN, which enables support for all IP27 and IP35 systems. The original
two options have always been used together, and go back to when pefo thought
supporting multiple nodes would be significant work. Since an Origin 200
can be a dual-node system, making a distinction between single node and
multiple node systems is a moot point anyway.

Be sure to rerun config(8) before rebuilding a kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.26 2009/10/26 20:14:42 miod Exp $	*/
d122 1
@


1.26
log
@Rename struct confargs to struct mainbus_attach_args for consistency and also
to prevent further abuse of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.25 2009/10/22 19:55:45 miod Exp $	*/
d160 1
a160 1
#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
d173 1
a173 1
#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
d184 1
a184 1
#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
d380 1
a380 1
#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
d394 1
a394 1
#if defined(TGT_O2)
@


1.25
log
@Introduce a logical xbpci(4) device between xbridge and pci, since more than
one pci bus can attach to an xbridge (if PIC) and both being `bus 0' would
make dmesg confusing.
While there, seize the opportunity of this new dmesg line to display the
bus mode (PCI or PCIX) and speed.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.24 2009/10/21 19:56:46 miod Exp $	*/
d330 1
a330 1
		struct confargs *ca = aux;
d332 1
a332 1
		if (strcmp(cd->cd_name, "xbow") == 0 && unit == ca->ca_nasid)
@


1.24
log
@In atoi(), only check for a base indication iff the string starts with `0'
and no base has been enforced. Otherwise the leading number of the mec(4)
08:00:69:xx:yy:zz Ethernet address would be interpreted as octal base,
followed by an out-of-range `8' which is now rejected but incorrectly
skipped; noticed by maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.23 2009/10/16 00:15:49 miod Exp $	*/
d316 3
d358 5
@


1.23
log
@Get serial console speed from prom, and use it instead of hardcoding 9600 bps,
on all systems but O2 (to catch up soon). Also use the IOC4 MCR register to
figure out the IOC4 clock, instead of checking the widget control register,
to be consistent with iof(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.22 2009/08/24 22:43:10 miod Exp $	*/
d524 1
a524 1
	if (c == '0') {
a551 1
		c = *s++;
d556 1
@


1.22
log
@On O2, the bootpath may omit the pci(0) component and start with scsi(); in
that case, fake the pci(0) part in order to match correctly the onboard scsi
controller.

While there, make sure device_register() returns early for devices attached
to root; without both these changes, an O2 lacking pci(0) in its bootpath
would dereference a NULL pointer when softraid would attach.

Problem found the hard way by Jukka Taimisto (jtaimisto, iki dot fi), thanks
for the report!
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.21 2009/06/13 21:48:03 miod Exp $	*/
d18 25
d98 1
d108 2
d457 107
@


1.21
log
@Enumerate all available nodes for hardware on IP27/IP35 systems; works to some
extent, but isp(4) on other nodes do not work correctly yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.20 2009/05/21 16:28:12 miod Exp $	*/
d263 1
d272 3
d354 21
a374 3
		if (strcmp(cd->cd_name, "scsibus") == 0 &&
		    parent == lastparent)
			goto found_advance;
d417 1
@


1.20
log
@Overhaul root device detection; the code will now follow the ARCS bootpath
component by component, from device_register().

IP27 and IP35 systems using the dksc() syntax get their dksc() syntax converted
to an ARCS bootpath, so the same logic will apply.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 2009/03/20 18:41:07 miod Exp $	*/
d280 1
a280 1
	 * xio() matches xbow (we ignore nasid so far).
d295 3
a297 1
		if (strcmp(cd->cd_name, "xbow") == 0)
@


1.19
log
@Switch sgi to __HAVE_GENERIC_SOFT_INTERRUPTS.
@
text
@d1 16
a16 1
/*	$OpenBSD: autoconf.c,v 1.18 2008/07/21 04:35:54 todd Exp $	*/
a67 1
#include <sys/disklabel.h>
a71 3
#include <uvm/uvm_extern.h>

#include <dev/cons.h>
d75 5
d81 5
a85 15
struct device *getdevunit(char *, int);
const struct devmap *boot_findtype(char *);
int makebootdev(const char *, int);
const char *boot_get_path_component(const char *, char *, int *);
const char *boot_getnr(const char *, int *);

/* Struct translating from ARCS to bsd. */
struct devmap {
	const char	*att;
	const char	*dev;
	int		what;
};
#define	DEVMAP_TYPE	0x01
#define	DEVMAP_UNIT	0x02
#define	DEVMAP_PART	0x04
a92 1
char	bootdev[16] = "unknown";	/* to hold boot dev name */
d95 2
a116 5
device_register(struct device *dev, void *aux)
{
}

void
a118 5
	dev_t tmpdev;

	/* Lookup boot device from boot if not set by configuration */
	if (bootdv == NULL)
		bootdv = parsedisk(bootdev, strlen(bootdev), 0, &tmpdev);
d120 1
a120 1
		printf("boot device: lookup '%s' failed.\n", bootdev);
d128 8
d137 1
a137 1
 * find a device matching "name" and unit number
d139 2
a140 4
struct device *
getdevunit(name, unit)
	char *name;
	int unit;
d142 12
a153 18
	struct device *dev = TAILQ_FIRST(&alldevs);
	char num[10], fullname[16];
	int lunit;

	/* compute length of name and decimal expansion of unit number */
	snprintf(num, sizeof(num), "%d", unit);
	lunit = strlen(num);
	if (strlen(name) + lunit >= sizeof(fullname) - 1)
		panic("config_attach: device name too long");

	strlcpy(fullname, name, sizeof(fullname));
	strlcat(fullname, num, sizeof(fullname));

	while (strcmp(dev->dv_xname, fullname) != 0) {
		if ((dev = TAILQ_NEXT(dev, dv_list)) == NULL)
			return NULL;
	}
	return dev;
d156 6
a161 2
const struct devmap *
boot_findtype(char *s)
d163 2
a164 8
	const struct devmap devmap[] = {
		{ "scsi",	"sd",	DEVMAP_TYPE },
		{ "disk",	"",	DEVMAP_UNIT },
		{ "part",	"",	DEVMAP_PART },
		{ "partition",	"",	DEVMAP_PART },
		{ NULL, NULL }
	};
	const struct devmap *dp = &devmap[0];
d166 5
a170 2
	while (dp->att) {
		if (strcmp (s, dp->att) == 0) {
d172 5
a176 2
		}
		dp++;
d178 21
a198 4
	if (dp->att)
		return dp;
	else
		return NULL;
d200 1
d203 2
a204 4
 * Look at the string 'bp' and decode the boot device.
 * Boot devices look like: 'scsi()disk(n)rdisk()partition(0)'
 *	 		  or
 *			   'dksc(0,1,0)'
d206 2
a207 2
int
makebootdev(const char *bp, int offs)
d209 21
a229 42
	char namebuf[256];
	const char *cp, *ncp, *ecp, *devname;
	int	i, unit, partition;
	const struct devmap *dp;

	if (bp == NULL)
		return -1;

	ecp = cp = bp;
	unit = partition = 0;
	devname = NULL;

	if (strncmp(cp, "dksc(", 5) == 0) {
		devname = "sd";
		cp += 5;
		cp = boot_getnr(cp, &i);
		if (*cp++ == ',') {
			cp = boot_getnr(cp, &i);
			unit = i - 1;
			if (*cp++ == ',') {
				cp = boot_getnr(cp, &i);
				partition = i;
			}
		}
	} else {
		ncp = boot_get_path_component(cp, namebuf, &i);
		while (ncp != NULL) {
			if ((dp = boot_findtype(namebuf)) != NULL) {
				switch(dp->what) {
				case DEVMAP_TYPE:
					devname = dp->dev;
					break;
				case DEVMAP_UNIT:
					unit = i - 1 + offs;
					break;
			case DEVMAP_PART:
					partition = i;
					break;
				}
			}
			cp = ncp;
			ncp = boot_get_path_component(cp, namebuf, &i);
d231 8
d241 3
a243 3
	if (devname == NULL) {
		return -1;
	}
d245 11
a255 3
	snprintf(bootdev, sizeof(bootdev), "%s%d%c", devname, unit,
	    'a' + partition);
	return 0;
d258 2
a259 2
const char *
boot_get_path_component(const char *p, char *comp, int *no)
d261 36
a296 2
	while (*p && *p != '(') {
		*comp++ = *p++;
a297 1
	*comp = '\0';
d299 20
a318 2
	if (*p == NULL)
		return NULL;
d320 45
a364 7
	*no = 0;
	p++;
	while (*p && *p != ')') {
		if (*p >= '0' && *p <= '9')
			*no = *no * 10 + *p++ - '0';
		else
			return NULL;
a365 2
	return ++p;
}
d367 28
a394 7
const char *
boot_getnr(const char *p, int *no)
{
	*no = 0;
	while (*p >= '0' && *p <= '9')
		*no = *no * 10 + *p++ - '0';
	return p;
@


1.18
log
@nam2blk[] needs a "vnd" entry for some things (like softraid)
ok marco@@ no objection miod@@ need this for regress djm@@ no objection krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17 2008/03/30 22:19:33 deraadt Exp $	*/
d98 3
@


1.17
log
@nam2blk[] clearly must contain "rd" ... found by krw
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.16 2008/02/29 19:02:34 miod Exp $	*/
d278 1
@


1.16
log
@Fix dksc() bootpath parsing.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 2007/06/01 19:25:10 deraadt Exp $	*/
d277 1
@


1.15
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 2007/06/01 19:20:46 deraadt Exp $	*/
d205 1
a205 1
		if (*cp == ',') {
d208 1
a208 1
			if (*cp == ',') {
d238 2
a239 1
	snprintf(bootdev, sizeof(bootdev), "%s%d%c", devname, unit, 'a');
@


1.14
log
@kill __HAVE_DEVICE_REGISTER by requiring all architectures to have a
device_register() function -- even if it does nothing.  reduces the
cpp-based blather different between architectures
idea ok'd by miod; tested on all architectures (except a few miod will
need to cleanup because he has them)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.13 2007/05/04 19:30:55 deraadt Exp $	*/
a63 1
void	diskconf(void);
a102 2

	md_diskconf = diskconf;
@


1.13
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.12 2007/05/04 03:44:44 deraadt Exp $	*/
d107 5
@


1.12
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 2005/12/27 18:31:10 miod Exp $	*/
d271 4
a274 6
static struct {
	char	*name;
	int	maj;
} nam2blk[] = {
	{ "sd",	0 },	/* 0 = sd */
	{ "wd",	4 },	/* 4 = wd */
a275 23

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)))
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}
@


1.11
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 2005/12/19 21:37:10 miod Exp $	*/
d58 3
d64 1
a64 3
struct  device *parsedisk(char *, int, int, dev_t *);
void	disk_configure(void);
void    rootconf(void);
a65 2
int findblkmajor(struct device *);
struct device * getdisk(char *, int, int, dev_t *);
d96 1
a96 1
cpu_configure()
d105 1
a105 1
	md_diskconf = disk_configure;
d110 1
a110 37
disk_configure()
{
	rootconf();
	dumpconf();
}

/*
 * the rest of this file was influenced/copied from Theo de Raadt's
 * code in the sparc port to nuke the "options GENERIC" stuff.
 */

const struct nam2blk {
	const char *name;
	int  maj;
} nam2blk[] = {
	{ "sd",	0 },	/* 0 = sd */
	{ "wd",	4 },	/* 4 = wd */
};

int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)) == 0)
			return (nam2blk[i].maj);
	 return (-1);
}

struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
d112 1
a112 80
	struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of:");
		TAILQ_FOREACH(dv, &alldevs, dv_list) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf("\n");
	}
	return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;
	char *cp, c;
	int majdev, part;

	if (len == 0)
		return (NULL);
	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

	TAILQ_FOREACH(dv, &alldevs, dv_list) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
			majdev = findblkmajor(dv);
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, dv->dv_unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 */
void
rootconf()
{
	int  majdev, mindev, unit, part, len;
	dev_t temp;
	struct swdevt *swp;
	struct device *dv;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];

#if defined(NFSCLIENT)
	extern char *nfsbootdevname;
#endif

	if (boothowto & RB_DFLTROOT)
		return;		/* Boot compiled in */
d115 3
a117 4
	if (bootdv == NULL) {
		bootdv = parsedisk(bootdev, strlen(bootdev), 0, &temp);
	}
	if (bootdv == NULL) {
d119 2
a120 5
		boothowto |= RB_ASKNAME; /* Don't Panic :-) */
	}
	else {
		printf("boot device: %s.\n", bootdv->dv_xname);
	}
d122 2
a123 158
	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device ");
			if (bootdv != NULL)
				 printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK
						? 'a' : ' ');
			printf(": ");
			len = getsn(buf, sizeof(buf));
#ifdef DDB
			if (len && strcmp(buf, "ddb") == 0) {
				Debugger();
				continue;
			}
#endif
			if (len == 0 && bootdv != NULL) {
				strlcpy(buf, bootdv->dv_xname, sizeof(buf));
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv != NULL) {
					bootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, 0, &nrootdev);
			if (dv != NULL) {
				bootdv = dv;
				break;
			}
		}
		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (bootdv->dv_class == DV_IFNET) {
			goto gotswap;
		}
		for (;;) {
			printf("swap device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
					bootdv->dv_xname,
					bootdv->dv_class == DV_DISK?'b':' ');
			printf(": ");
			len = getsn(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}

gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else if (mountroot == NULL) {
		/*
		 * `swap generic': Use the device the ROM told us to use.
		 */
		if (bootdv == NULL)
			panic("boot device not known");

		majdev = findblkmajor(bootdv);

		if (majdev >= 0) {
			/*
			 * Root and Swap are on disk.
			 * Boot is always from partition 0.
			 */
			rootdev = MAKEDISKDEV(majdev, bootdv->dv_unit, 0);
			nswapdev = MAKEDISKDEV(majdev, bootdv->dv_unit, 1);
			dumpdev = nswapdev;
		}
		else {
			/*
			 *  Root and Swap are on net.
			 */
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;

	} else {

		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		return;
	}

	switch (bootdv->dv_class) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = bootdv->dv_xname;
		return;
#endif
	case DV_DISK:
		mountroot = dk_mountroot;
		majdev = major(rootdev);
		mindev = minor(rootdev);
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname, part + 'a');
		break;
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * XXX: What is this doing?
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    unit == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device, move
	 * it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
d269 31
@


1.10
log
@Constify.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 2004/12/25 23:02:25 miod Exp $	*/
a63 1
void	swapconf(void);
a113 1
	swapconf();
a114 20
}

/*
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	struct swdevt *swp;
	int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (bdevsw[major(swp->sw_dev)].d_psize) {
			nblks = (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
			if (nblks != -1 && (swp->sw_nblks == 0 || swp->sw_nblks > nblks)) {
				swp->sw_nblks = nblks;
			}
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	}
@


1.9
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.8 2004/10/23 08:21:27 mjc Exp $	*/
d66 2
a67 2
static int findblkmajor(struct device *);
static struct device * getdisk(char *, int, int, dev_t *);
d69 1
a69 1
struct devmap *boot_findtype(char *);
d76 3
a78 3
	char	*att;
	char	*dev;
	int	what;
d144 2
a145 2
static	struct nam2blk {
	char *name;
d152 1
a152 1
static int
d165 1
a165 1
static struct device *
d452 1
a452 1
struct devmap *
d455 1
a455 1
	static struct devmap devmap[] = {
d462 1
a462 1
	struct devmap *dp = &devmap[0];
d471 1
a471 1
		return dp ;
d488 1
a488 1
	struct devmap *dp;
@


1.8
log
@configure() -> cpu_configure()
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7 2004/10/20 12:49:15 pefo Exp $	*/
d175 1
a175 2
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
d208 1
a208 1
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
d432 1
a432 1
	struct device *dev = alldevs.tqh_first;
d446 1
a446 1
		if ((dev = dev->dv_list.tqe_next) == NULL)
@


1.7
log
@Fix some 64 bit address problems.
Some function names made more unique.
Other changes for the upcoming Origin 200 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.6 2004/09/22 08:01:58 pefo Exp $	*/
d45 1
a45 1
 * Configure() is called at boot time.  Available
a63 1
void	configure(void);
@


1.6
log
@On single SCSI slot O2's the first disk is numbered 2 (the slot number)
by the ARCS Bios. To make the kernel pick up the right sd number offset
the slots if the CPU is a R10K or larger. R10K's and up are those with
single disk slots.

A more correct solution would be to dig down and check the SCSI ID's,
but right now this solutions works OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.5 2004/08/26 13:30:25 pefo Exp $	*/
d71 1
a71 1
void makebootdev(const char *, int);
d73 1
d480 3
a482 1
 * Boot names look like: 'scsi()disk(n)rdisk()partition(0)/bsd'
d484 1
a484 1
void
d492 3
d499 23
a521 9
	while ((ncp = boot_get_path_component(cp, namebuf, &i)) != NULL) {
		if ((dp = boot_findtype(namebuf)) != NULL) {
			switch(dp->what) {
			case DEVMAP_TYPE:
				devname = dp->dev;
				break;
			case DEVMAP_UNIT:
				unit = i - 1 + offs;
				break;
d523 3
a525 2
				partition = i;
				break;
d527 2
a529 1
		cp = ncp;
d533 1
a533 2
		printf("Warning: boot device unrecognized: %s\n", bp);
		return;
d537 1
d562 8
@


1.5
log
@diskboot changes
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.4 2004/08/10 19:16:18 deraadt Exp $	*/
d71 1
a71 1
void makebootdev(const char *cp);
d482 1
a482 1
makebootdev(const char *bp)
d500 1
a500 1
				unit = i - 1;
@


1.4
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.3 2004/08/10 18:47:22 deraadt Exp $	*/
d69 14
a82 4
struct device * getdevunit(char *, int);
static struct devmap * findtype(char **);
void makebootdev(char *cp);
int getpno(char **);
d453 2
a454 8
struct devmap {
	char *att;
	char *dev;
};

static struct devmap *
findtype(s)
	char **s;
d457 4
a460 4
		{ "/dev/sd",	"sd" },
		{ "/dev/wd",	"wd" },
		{ "sd",		"sd" },
		{ "wd",		"wd" },
d466 1
a466 2
		if (strncmp (*s, dp->att, strlen(dp->att)) == 0) {
			*s += strlen(dp->att);
d471 4
a474 1
	return(dp);
d479 1
a479 2
 * Boot names look like: '/dev/sd0/bsd'
 *                       '/dev/wd0/bsd
d482 1
a482 2
makebootdev(bp)
	char *bp;
d484 3
a486 2
	int	unit;
	char   *dev, *cp;
d489 19
a507 3
	cp = bp;
	while(*cp && *cp != '/') {
		cp++;
d509 2
a510 2
	dp = findtype(&cp);
	if (!dp->att) {
d515 1
a515 3
	dev = dp->dev;
	unit = getpno(&cp);
	snprintf(bootdev, sizeof(bootdev), "%s%d%c", dev, unit, 'a');
d518 2
a519 3
int
getpno(cp)
	char **cp;
d521 7
a527 2
	int val = 0;
	char *cx = *cp;
d529 7
a535 3
	while(*cx && *cx >= '0' && *cx <= '9') {
		val = val * 10 + *cx - '0';
		cx++;
d537 1
a537 2
	*cp = cx;
	return val;
d539 1
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.2 2004/08/09 10:11:37 miod Exp $	*/
d240 1
a240 1
	if(boothowto & RB_DFLTROOT)
d244 1
a244 1
	if(bootdv == NULL) {
d247 1
a247 1
	if(bootdv == NULL) {
d266 1
a266 1
			if(len && strcmp(buf, "ddb") == 0) {
d335 1
a335 2
	}
	else if(mountroot == NULL) {
@


1.2
log
@maxpartitions 16, so our slices are a-p not a-h.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.1 2004/08/06 21:12:19 pefo Exp $	*/
a39 5
 *
 * from: Utah Hdr: autoconf.c 1.31 91/01/21
 *
 *	from: @@(#)autoconf.c	8.1 (Berkeley) 6/10/93
 *      $Id: autoconf.c,v 1.1 2004/08/06 21:12:19 pefo Exp $
d129 1
a129 1
/*                                                                        
d171 1
a171 1
				printf(" %s", dv->dv_xname); 
d357 1
a357 1
			 */	
@


1.1
log
@initial sgi import
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 1997/05/18 13:45:20 pefo Exp $	*/
d44 1
a44 1
 *      $Id: autoconf.c,v 1.9 1997/05/18 13:45:20 pefo Exp $
d173 1
a173 1
				printf(" %s[a-h]", dv->dv_xname);
@

