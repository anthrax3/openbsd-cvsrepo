head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.2
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.30.0.2
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.27.0.6
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.25.0.8
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.4
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.8.0.2
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.31
date	2017.02.11.03.44.22;	author visa;	state Exp;
branches;
next	1.30;
commitid	xjkuO7IpWLYltL4L;

1.30
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.29;
commitid	cyYKarj4qRTft4gD;

1.29
date	2015.09.26.04.37.18;	author visa;	state Exp;
branches;
next	1.28;
commitid	oJejGCo6YjRWNpQL;

1.28
date	2015.09.08.10.21.50;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	PXEPkjFX0KqqXu7Y;

1.27
date	2014.09.30.06.51.58;	author jmatthew;	state Exp;
branches;
next	1.26;
commitid	pUEUpP9FlbomZUiI;

1.26
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.25;
commitid	uKVPYMN2MLxdZxzH;

1.25
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2012.09.29.18.54.39;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.10.17.48.25;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.17.17.44.24;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2011.04.05.14.43.11;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.26.23.32.46;	author syuu;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.25.17.39.51;	author syuu;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.25.11.23.30;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.12.17.13.35;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.31.00.20.47;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.26.18.11.27;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.22.22.08.54;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.22.20.59.24;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.22.20.39.17;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.22.20.05.28;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.07.08.35.47;	author syuu;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.27.19.06.20;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.08.18.42.07;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.18.14.48.09;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.15.18.45.41;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.12.17.53.26;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.20.18.41.07;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2008.07.28.18.50.59;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.07.22.47.40;	author miod;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Let MP-safe interrupt handlers run without the kernel lock on sgi.

OK miod@@
@
text
@/*	$OpenBSD: xheart.c,v 1.30 2016/03/06 19:42:27 mpi Exp $	*/

/*
 * Copyright (c) 2008 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * IP30 Heart Widget
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/evcount.h>
#include <sys/malloc.h>
#include <sys/timetc.h>
#include <sys/atomic.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/intr.h>

#include <sgi/xbow/xbow.h>
#include <sgi/xbow/xbowdevs.h>
#include <sgi/xbow/xheartreg.h>

#include <dev/onewire/onewirereg.h>
#include <dev/onewire/onewirevar.h>

struct xheart_softc {
	struct device		sc_dev;
	struct onewire_bus	sc_bus;
};

int	xheart_match(struct device *, void *, void *);
void	xheart_attach(struct device *, struct device *, void *);

const struct cfattach xheart_ca = {
	sizeof(struct xheart_softc), xheart_match, xheart_attach,
};

struct cfdriver xheart_cd = {
	NULL, "xheart", DV_DULL,
};

int	xheart_ow_reset(void *);
int	xheart_ow_read_bit(struct xheart_softc *);
int	xheart_ow_send_bit(void *, int);
int	xheart_ow_read_byte(void *);
int	xheart_ow_triplet(void *, int);
int	xheart_ow_pulse(struct xheart_softc *, int, int);

int	xheart_intr_register(int, int, int *);
int	xheart_intr_establish(int (*)(void *), void *, int, int, const char *,
	    struct intrhand *);
void	xheart_intr_disestablish(int);
void	xheart_intr_clear(int);
void	xheart_intr_set(int);
uint32_t xheart_intr_handler(uint32_t, struct trapframe *);
void	xheart_intr_makemasks(void);
void	xheart_setintrmask(int);
void	xheart_splx(int);

u_int	xheart_get_timecount(struct timecounter *);

struct timecounter xheart_timecounter = {
	.tc_get_timecount = xheart_get_timecount,
	.tc_poll_pps = NULL,
	.tc_counter_mask = 0xffffffff,	/* truncate 52-bit counter to 32-bit */
	.tc_frequency = 12500000,
	.tc_name = "heart",
	.tc_quality = 100
};

extern uint32_t ip30_lights_frob(uint32_t, struct trapframe *);

/*
 * HEART interrupt handling declarations: 64 sources; 5 levels.
 */

struct intrhand *xheart_intrhand[HEART_NINTS];

#ifdef notyet
#define	INTPRI_HEART_4	(INTPRI_CLOCK + 1)
#define	INTPRI_HEART_3	(INTPRI_HEART_4 + 1)
#define	INTPRI_HEART_2	(INTPRI_HEART_3 + 1)
#define	INTPRI_HEART_1	(INTPRI_HEART_2 + 1)
#define	INTPRI_HEART_0	(INTPRI_HEART_1 + 1)
#else
#define	INTPRI_HEART_2	(INTPRI_IPI)
#define	INTPRI_HEART_0	(INTPRI_CLOCK + 1)
#endif
#define	INTPRI_HEART_LEDS	(INTPRI_HEART_0 + 1)

uint64_t xheart_intem[MAXCPUS];
uint64_t xheart_imask[MAXCPUS][NIPLS];

int
xheart_match(struct device *parent, void *match, void *aux)
{
	struct xbow_attach_args *xaa = aux;

	if (xaa->xaa_vendor == XBOW_VENDOR_SGI4 &&
	    xaa->xaa_product == XBOW_PRODUCT_SGI4_HEART)
		return 1;

	return 0;
}

void
xheart_attach(struct device *parent, struct device *self, void *aux)
{
	struct xbow_attach_args *xaa = aux;
	struct xheart_softc *sc = (void *)self;
	struct onewirebus_attach_args oba;
	paddr_t heart;

	printf(" revision %d\n", xaa->xaa_revision);

	sc->sc_bus.bus_cookie = sc;
	sc->sc_bus.bus_reset = xheart_ow_reset;
	sc->sc_bus.bus_bit = xheart_ow_send_bit;
	sc->sc_bus.bus_read_byte = xheart_ow_read_byte;
	sc->sc_bus.bus_write_byte = NULL;	/* use default routine */
	sc->sc_bus.bus_read_block = NULL;	/* use default routine */
	sc->sc_bus.bus_write_block = NULL;	/* use default routine */
	sc->sc_bus.bus_triplet = xheart_ow_triplet;
	sc->sc_bus.bus_matchrom = NULL;		/* use default routine */
	sc->sc_bus.bus_search = NULL;		/* use default routine */

	oba.oba_bus = &sc->sc_bus;
	oba.oba_flags = ONEWIRE_SCAN_NOW | ONEWIRE_NO_PERIODIC_SCAN;
	config_found(self, &oba, onewirebus_print);

	xbow_intr_address = 0x80;
	xbow_intr_widget_intr_register = xheart_intr_register;
	xbow_intr_widget_intr_establish = xheart_intr_establish;
	xbow_intr_widget_intr_disestablish = xheart_intr_disestablish;
	xbow_intr_widget_intr_clear = xheart_intr_clear;
	xbow_intr_widget_intr_set = xheart_intr_set;

	/*
	 * Acknowledge and disable all interrupts.
	 */
	heart = PHYS_TO_XKPHYS(HEART_PIU_BASE, CCA_NC);
	*(volatile uint64_t*)(heart + HEART_ISR_CLR) = 0xffffffffffffffffUL;
	*(volatile uint64_t*)(heart + HEART_IMR(0)) = 0UL;
	*(volatile uint64_t*)(heart + HEART_IMR(1)) = 0UL;
	*(volatile uint64_t*)(heart + HEART_IMR(2)) = 0UL;
	*(volatile uint64_t*)(heart + HEART_IMR(3)) = 0UL;

#ifdef notyet
	set_intr(INTPRI_HEART_4, CR_INT_4, xheart_intr_handler);
	set_intr(INTPRI_HEART_3, CR_INT_3, xheart_intr_handler);
#endif
	set_intr(INTPRI_HEART_2, CR_INT_2, xheart_intr_handler);
#ifdef notyet
	set_intr(INTPRI_HEART_1, CR_INT_1, xheart_intr_handler);
#endif
	set_intr(INTPRI_HEART_0, CR_INT_0, xheart_intr_handler);

	set_intr(INTPRI_HEART_LEDS, CR_INT_5, ip30_lights_frob);

	register_splx_handler(xheart_splx);

	tc_init(&xheart_timecounter);
}

/*
 * Number-In-a-Can (1-Wire) interface
 */

int
xheart_ow_reset(void *v)
{
	struct xheart_softc *sc = v;
	return xheart_ow_pulse(sc, 500, 65);
}

int
xheart_ow_read_bit(struct xheart_softc *sc)
{
	return xheart_ow_pulse(sc, 6, 13);
}

int
xheart_ow_send_bit(void *v, int bit)
{
	struct xheart_softc *sc = v;
	int rc;
	
	if (bit != 0)
		rc = xheart_ow_pulse(sc, 6, 110);
	else
		rc = xheart_ow_pulse(sc, 80, 30);
	return rc;
}

int
xheart_ow_read_byte(void *v)
{
	struct xheart_softc *sc = v;
	unsigned int byte = 0;
	int i;

	for (i = 0; i < 8; i++)
		byte |= xheart_ow_read_bit(sc) << i;

	return byte;
}

int
xheart_ow_triplet(void *v, int dir)
{
	struct xheart_softc *sc = v;
	int rc;

	rc = xheart_ow_read_bit(sc);
	rc <<= 1;
	rc |= xheart_ow_read_bit(sc);

	switch (rc) {
	case 0x0:
		xheart_ow_send_bit(v, dir);
		break;
	case 0x1:
		xheart_ow_send_bit(v, 0);
		break;
	default:
		xheart_ow_send_bit(v, 1);
		break;
	}

	return (rc);
}

int
xheart_ow_pulse(struct xheart_softc *sc, int pulse, int data)
{
	uint64_t mcr_value;
	paddr_t heart;

	heart = PHYS_TO_XKPHYS(HEART_PIU_BASE + HEART_MICROLAN, CCA_NC);
	mcr_value = (pulse << 10) | (data << 2);
	*(volatile uint64_t *)heart = mcr_value;
	do {
		mcr_value = *(volatile uint64_t *)heart;
	} while ((mcr_value & 0x00000002) == 0);

	delay(500);

	return (mcr_value & 1);
}

/*
 * HEART interrupt handling routines
 */

/*
 * Find a suitable interrupt bit for the given interrupt.
 */
int
xheart_intr_register(int widget, int level, int *intrbit)
{
	int bit;
	u_long cpuid = cpu_number();

	/*
	 * All interrupts will be serviced at hardware level 0,
	 * so the `level' argument can be ignored.
	 */
	for (bit = HEART_INTR_WIDGET_MAX; bit >= HEART_INTR_WIDGET_MIN; bit--)
		if ((xheart_intem[cpuid] & (1UL << bit)) == 0)
			goto found;

	return EINVAL;

found:
	*intrbit = bit;
	return 0;
}

/*
 * Register an interrupt handler for a given source, and enable it.
 */
int
xheart_intr_establish(int (*func)(void *), void *arg, int intrbit,
    int level, const char *name, struct intrhand *ihstore)
{
	struct intrhand *ih;
	int flags;
	int s;
	u_long cpuid = cpu_number();

#ifdef DIAGNOSTIC
	if (intrbit < 0 || intrbit >= HEART_NINTS)
		return EINVAL;
#endif

	flags = (level & IPL_MPSAFE) ? IH_MPSAFE : 0;
	level &= ~IPL_MPSAFE;

	/*
	 * HEART interrupts are not supposed to be shared - the interrupt
	 * mask is large enough for all widgets.
	 */
	if (xheart_intrhand[intrbit] != NULL)
		return EEXIST;

	if (ihstore == NULL) {
		ih = malloc(sizeof(*ih), M_DEVBUF, M_NOWAIT);
		if (ih == NULL)
			return ENOMEM;
		flags |= IH_ALLOCATED;
	} else
		ih = ihstore;

	ih->ih_next = NULL;
	ih->ih_fun = func;
	ih->ih_arg = arg;
	ih->ih_level = level;
	ih->ih_irq = intrbit;
	ih->ih_flags = flags;
	if (name != NULL)
		evcount_attach(&ih->ih_count, name, &ih->ih_level);

	s = splhigh();

	xheart_intrhand[intrbit] = ih;

	xheart_intem[cpuid] |= 1UL << intrbit;
	xheart_intr_makemasks();

	splx(s);	/* causes hw mask update */

	return 0;
}

void
xheart_intr_disestablish(int intrbit)
{
	struct intrhand *ih;
	int s;
	u_long cpuid = cpu_number();

#ifdef DIAGNOSTIC
	if (intrbit < 0 || intrbit >= HEART_NINTS)
		return;
#endif

	s = splhigh();

	if ((ih = xheart_intrhand[intrbit]) == NULL) {
		splx(s);
		return;
	}

	xheart_intrhand[intrbit] = NULL;

	xheart_intem[cpuid] &= ~(1UL << intrbit);
	xheart_intr_makemasks();

	splx(s);

	if (ISSET(ih->ih_flags, IH_ALLOCATED))
		free(ih, M_DEVBUF, sizeof *ih);
}

void
xheart_intr_clear(int intrbit)
{
	*(volatile uint64_t *)PHYS_TO_XKPHYS(HEART_PIU_BASE + HEART_ISR_CLR,
	    CCA_NC) = 1UL << intrbit;
}

void
xheart_intr_set(int intrbit)
{
	*(volatile uint64_t *)PHYS_TO_XKPHYS(HEART_PIU_BASE + HEART_ISR_SET,
	    CCA_NC) = 1UL << intrbit;
}

void
xheart_splx(int newipl)
{
	struct cpu_info *ci = curcpu();

	/* Update masks to new ipl. Order highly important! */
	__asm__ (".set noreorder\n");
	ci->ci_ipl = newipl;
	mips_sync();
	__asm__ (".set reorder\n");
	xheart_setintrmask(newipl);

	/* If we still have softints pending trigger processing. */
	if (ci->ci_softpending != 0 && newipl < IPL_SOFTINT)
		setsoftintr0();
}

/*
 * Heart interrupt handler. Can be registered at any hardware interrupt level.
 */

#define	INTR_FUNCTIONNAME	xheart_intr_handler
#define	MASK_FUNCTIONNAME	xheart_intr_makemasks
#define	INTR_LOCAL_DECLS \
	paddr_t heart = PHYS_TO_XKPHYS(HEART_PIU_BASE, CCA_NC); \
	u_long cpuid = cpu_number();
#define	MASK_LOCAL_DECLS \
	u_long cpuid = cpu_number();
#define	INTR_GETMASKS \
do { \
	isr = *(volatile uint64_t *)(heart + HEART_ISR); \
	imr = *(volatile uint64_t *)(heart + HEART_IMR(cpuid));	\
	switch (hwpend) { \
	case CR_INT_0: \
		isr &= HEART_ISR_LVL0_MASK; \
		bit = HEART_ISR_LVL0_MAX; \
		break; \
	case CR_INT_1: \
		isr &= HEART_ISR_LVL1_MASK; \
		bit = HEART_ISR_LVL1_MAX; \
		break; \
	case CR_INT_2: \
		isr &= HEART_ISR_LVL2_MASK; \
		bit = HEART_ISR_LVL2_MAX; \
		break; \
	case CR_INT_3: \
		isr &= HEART_ISR_LVL3_MASK; \
		bit = HEART_ISR_LVL3_MAX; \
		break; \
	case CR_INT_4: \
		isr &= HEART_ISR_LVL4_MASK; \
		bit = HEART_ISR_LVL4_MAX; \
		break; \
	default: \
		return 0;	/* can't happen */ \
	} \
} while (0)
#define	INTR_MASKPENDING \
	*(volatile uint64_t *)(heart + HEART_IMR(cpuid)) &= ~isr
#define	INTR_IMASK(ipl)		xheart_imask[cpuid][ipl]
#define	INTR_HANDLER(bit)	xheart_intrhand[bit]
#define	INTR_SPURIOUS(bit) \
do { \
	printf("spurious xheart interrupt %d\n", bit); \
} while (0)
#define	INTR_MASKRESTORE \
	*(volatile uint64_t *)(heart + HEART_IMR(cpuid)) = imr
#define	INTR_MASKSIZE	HEART_NINTS

#include <sgi/sgi/intr_template.c>

void
xheart_setintrmask(int level)
{
	paddr_t heart = PHYS_TO_XKPHYS(HEART_PIU_BASE, CCA_NC);
	u_long cpuid = cpu_number();

	*(volatile uint64_t *)(heart + HEART_IMR(cpuid)) =
		xheart_intem[cpuid] & ~xheart_imask[cpuid][level];
}

/*
 * Timecounter interface.
 */

uint
xheart_get_timecount(struct timecounter *tc)
{
	paddr_t heart = PHYS_TO_XKPHYS(HEART_PIU_BASE, CCA_NC);

	return (u_int)*(volatile uint64_t *)(heart + HEART_CTR_VALUE);
}
@


1.30
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.29 2015/09/26 04:37:18 visa Exp $	*/
d305 1
d314 3
d328 2
a329 2
		ih->ih_flags = IH_ALLOCATED;
	} else {
a330 2
		ih->ih_flags = 0;
	}
d337 1
@


1.29
log
@xheart_splx() has to restore the interrupt mask even on secondary CPUs
because each core has a separate mask. Otherwise the IPI can be left
disabled accidentally on a non-primary CPU when the core uses the
rendezvous mutex:

1. splraise(IPL_IPI) soft-masks the IPI.

2. An IPI hits and the CPU enters the interrupt handler.

3. The handler hard-masks the IPI.

4. The interrupt is not processed because of the CPU's current IPL.
   The IPI is left hard-masked on leaving the handler.

5. splx(s) lowers the IPL below IPL_IPI. However, the interrupt's
   hardware mask is left unchanged because of the CPU_IS_PRIMARY()
   check in xheart_splx().

After this, the system will eventually hang because the CPU does not
respond to IPI requests of other cores.

While here, fix a similar situation with CIU interrupts on octeon.
This might save a few moments of debugging once non-primary CPUs are
allowed to process CIU interrupts.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.28 2015/09/08 10:21:50 deraadt Exp $	*/
d73 1
a73 1
uint32_t xheart_intr_handler(uint32_t, struct trap_frame *);
d89 1
a89 1
extern uint32_t ip30_lights_frob(uint32_t, struct trap_frame *);
@


1.28
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.27 2014/09/30 06:51:58 jmatthew Exp $	*/
d404 1
a404 3

	if (CPU_IS_PRIMARY(ci))
		xheart_setintrmask(newipl);
@


1.27
log
@implement atomic operations using ll/sc, and convert rw_cas and callers of the
pre-existing atomics to match.

tested on sgi (octane) and octeon (erl)
ok miod@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.26 2014/07/12 18:44:42 tedu Exp $	*/
d377 1
a377 1
		free(ih, M_DEVBUF, 0);
@


1.26
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.25 2012/10/03 11:18:23 miod Exp $	*/
d30 1
a31 1
#include <machine/atomic.h>
@


1.25
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.24 2012/09/29 18:54:39 miod Exp $	*/
d377 1
a377 1
		free(ih, M_DEVBUF);
@


1.24
log
@Proide a mips_sync() macro to wrap asm("sync"), and replace gazillions of
such statements with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.23 2011/07/10 17:48:25 miod Exp $	*/
d34 1
@


1.23
log
@Register the Heart clock as a timecounter on Octane systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.22 2011/04/17 17:44:24 miod Exp $	*/
d401 2
a402 1
	__asm__ ("sync\n\t.set reorder\n");
@


1.22
log
@On IP27 systems, fill the array of node hub widget numbers early, so that all
hubs are known during autoconf. Then, pick the most populated 2GB window
as our DMA memory window. xbridge(4) can thus program the correct settings
regardless of the order in which the xbow(4) attach.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.21 2011/04/05 14:43:11 miod Exp $	*/
d29 1
a29 1
#include <sys/queue.h>
d77 11
d159 1
a159 1
	*(volatile uint64_t*)(heart + HEART_ISR_CLR) = 0xffffffffffffffff;
d178 2
d473 12
@


1.21
log
@Rename a few xbow global variable names to make them less ambiguous.
Remember the hub widget number of each node, instead of only the master node.
Use this in xbridge to compute the proper direct DMA map configuration
register value (it needs to embed the hub widget number matching the
physical address range).
This should allow us to pick memory from a different node than the one
we booted from, as the DMA window, if wanted.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.20 2010/09/20 06:33:47 matthew Exp $	*/
a136 1
	xbow_node_hub_widget[0/*xaa->xaa_nasid*/] = xaa->xaa_widget;
@


1.20
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.19 2009/11/26 23:32:46 syuu Exp $	*/
d137 8
d146 1
a146 1
	 * If no other widget has claimed interrupts routing, do it now.
d148 6
a153 19
	if (xbow_intr_widget == 0) {
		xbow_intr_widget = xaa->xaa_widget;
		xbow_intr_widget_register = 0x80;
		xbow_intr_widget_intr_register = xheart_intr_register;
		xbow_intr_widget_intr_establish = xheart_intr_establish;
		xbow_intr_widget_intr_disestablish = xheart_intr_disestablish;
		xbow_intr_widget_intr_clear = xheart_intr_clear;
		xbow_intr_widget_intr_set = xheart_intr_set;

		/*
		 * Acknowledge and disable all interrupts.
		 */
		heart = PHYS_TO_XKPHYS(HEART_PIU_BASE, CCA_NC);
		*(volatile uint64_t*)(heart + HEART_ISR_CLR) =
		    0xffffffffffffffff;
		*(volatile uint64_t*)(heart + HEART_IMR(0)) = 0UL;
		*(volatile uint64_t*)(heart + HEART_IMR(1)) = 0UL;
		*(volatile uint64_t*)(heart + HEART_IMR(2)) = 0UL;
		*(volatile uint64_t*)(heart + HEART_IMR(3)) = 0UL;
d156 2
a157 2
		set_intr(INTPRI_HEART_4, CR_INT_4, xheart_intr_handler);
		set_intr(INTPRI_HEART_3, CR_INT_3, xheart_intr_handler);
d159 1
a159 1
		set_intr(INTPRI_HEART_2, CR_INT_2, xheart_intr_handler);
d161 1
a161 1
		set_intr(INTPRI_HEART_1, CR_INT_1, xheart_intr_handler);
d163 1
a163 1
		set_intr(INTPRI_HEART_0, CR_INT_0, xheart_intr_handler);
d165 1
a165 1
		set_intr(INTPRI_HEART_LEDS, CR_INT_5, ip30_lights_frob);
d167 1
a167 2
		register_splx_handler(xheart_splx);
	}
@


1.19
log
@Now IPI can interrupt to clock interrupt handler.
It prevents deadlock with TLB shootdown and clock interrupt.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.18 2009/11/25 17:39:51 syuu Exp $	*/
d329 1
a329 2
		evcount_attach(&ih->ih_count, name, &ih->ih_level,
		    &evcount_intr);
@


1.18
log
@IP30 IPI implementation.
Also few xheart modification for SMP.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.17 2009/11/25 11:23:30 miod Exp $	*/
d92 2
a93 2
#define	INTPRI_HEART_2	(INTPRI_CLOCK + 1)
#define	INTPRI_HEART_0	(INTPRI_HEART_2 + 1)
@


1.17
log
@Allow xbow_intr_establish() callers to provide optional storage for the
struct intrhand, instead of having it malloc()'ed.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.16 2009/11/12 17:13:35 miod Exp $	*/
d97 2
a98 2
uint64_t xheart_intem;
uint64_t xheart_imask[NIPLS];
a147 1
		xheart_intem = 0;
d273 1
d280 1
a280 1
		if ((xheart_intem & (1UL << bit)) == 0)
d299 1
d336 1
a336 1
	xheart_intem |= 1UL << intrbit;
d349 1
d365 1
a365 1
	xheart_intem &= ~(1UL << intrbit);
d397 1
d400 1
d413 4
a416 1
	paddr_t heart = PHYS_TO_XKPHYS(HEART_PIU_BASE, CCA_NC);
d420 1
a420 1
	imr = *(volatile uint64_t *)(heart + HEART_IMR(0)); \
d447 2
a448 2
	*(volatile uint64_t *)(heart + HEART_IMR(0)) &= ~isr
#define	INTR_IMASK(ipl)		xheart_imask[ipl]
d455 1
a455 1
	*(volatile uint64_t *)(heart + HEART_IMR(0)) = imr
d464 4
a467 2
	*(volatile uint64_t *)(heart + HEART_IMR(0)) =
	    xheart_intem & ~xheart_imask[level];
@


1.16
log
@Move the interrupt makemasks() code to the interrupt template; no functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.15 2009/10/31 00:20:47 miod Exp $	*/
d67 2
a68 1
int	xheart_intr_establish(int (*)(void *), void *, int, int, const char *);
d295 1
a295 1
    int level, const char *name)
d312 9
a320 3
	ih = malloc(sizeof(*ih), M_DEVBUF, M_NOWAIT);
	if (ih == NULL)
		return ENOMEM;
d368 2
a369 1
	free(ih, M_DEVBUF);
@


1.15
log
@Blinkenlichten on Octane.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.14 2009/10/26 18:11:27 miod Exp $	*/
a377 51
/*
 * Recompute interrupt masks.
 */
void
xheart_intr_makemasks()
{
	int irq, level;
	struct intrhand *q;
	uint intrlevel[HEART_NINTS];

	/* First, figure out which levels each IRQ uses. */
	for (irq = 0; irq < HEART_NINTS; irq++) {
		uint levels = 0;
		for (q = xheart_intrhand[irq]; q; q = q->ih_next)
			levels |= 1 << q->ih_level;
		intrlevel[irq] = levels;
	}

	/*
	 * Then figure out which IRQs use each level.
	 * Note that we make sure never to overwrite imask[IPL_HIGH], in
	 * case an interrupt occurs during intr_disestablish() and causes
	 * an unfortunate splx() while we are here recomputing the masks.
	 */
	for (level = IPL_NONE; level < IPL_HIGH; level++) {
		uint64_t irqs = 0;
		for (irq = 0; irq < HEART_NINTS; irq++)
			if (intrlevel[irq] & (1 << level))
				irqs |= 1UL << irq;
		xheart_imask[level] = irqs;
	}

	/*
	 * There are tty, network and disk drivers that use free() at interrupt
	 * time, so vm > (tty | net | bio).
	 *
	 * Enforce a hierarchy that gives slow devices a better chance at not
	 * dropping data.
	 */
	xheart_imask[IPL_NET] |= xheart_imask[IPL_BIO];
	xheart_imask[IPL_TTY] |= xheart_imask[IPL_NET];
	xheart_imask[IPL_VM] |= xheart_imask[IPL_TTY];
	xheart_imask[IPL_CLOCK] |= xheart_imask[IPL_VM];

	/*
	 * These are pseudo-levels.
	 */
	xheart_imask[IPL_NONE] = 0;
	xheart_imask[IPL_HIGH] = -1UL;
}

d399 1
d441 1
@


1.14
log
@Add new xbow routines to explicitely trigger or clear an interrupt source,
instead of embedding that knowledge in xbridge(4); will be used elsewhere
shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.13 2009/10/22 22:08:54 miod Exp $	*/
d76 2
d94 1
d169 3
@


1.13
log
@Completely overhaul interrupt handling on sgi. Cpu state now only stores a
logical IPL level, and per-platform (IP27/IP30/IP32) code will from the
necessary hardware mask registers.

This allows the use of more than one interrupt mask register. Also, the
generic (platform independent) interrupt code shrinks a lot, and the actual
interrupt handler chains and masking information is now per-platform private
data.

Interrupt dispatching is generated from a template; more routines will be
added to the template to reduce platform-specific changes and share as much
code as possible.

Tested on IP27, IP30, IP32 and IP35.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.12 2009/10/22 20:59:24 miod Exp $	*/
d69 2
d142 2
d356 14
@


1.12
log
@With the splx() changes, it is no longer necessary to remember which interrupt
sources were masked and saved in ci_ipending, as splx() will unmask what needs
to be unmasked anyway. ci_ipending only now needs to store pending soft
interrupts, so rename it to ci_softpending.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.11 2009/10/22 20:39:17 miod Exp $	*/
a45 2

	uint64_t		sc_intrmask;
d70 2
a71 1
void	xheart_intr_makemasks(struct xheart_softc *);
d74 20
d140 1
a140 1
		sc->sc_intrmask = 0;
d153 9
a161 1
		set_intr(INTPRI_XBOWMUX, CR_INT_0, xheart_intr_handler);
a261 1
	struct xheart_softc *sc = (void *)xheart_cd.cd_devs[0];
d269 2
a270 2
		if ((sc->sc_intrmask & (1 << bit)) == 0)
			break;
d272 1
a272 2
	if (bit < HEART_INTR_WIDGET_MIN)
		return EINVAL;
d274 1
a285 1
	struct xheart_softc *sc = (void *)xheart_cd.cd_devs[0];
d287 1
a287 1
	paddr_t heart;
d290 1
a290 1
	if (intrbit < HEART_INTR_MIN || intrbit > HEART_INTR_MAX)
d298 1
a298 1
	if (intrhand[intrbit] != NULL)
a312 1
	intrhand[intrbit] = ih;
d314 3
a316 2
	sc->sc_intrmask |= 1UL << intrbit;
	xheart_intr_makemasks(sc);
d318 4
a321 3
	/* XXX this assumes we run on cpu0 */
	heart = PHYS_TO_XKPHYS(HEART_PIU_BASE, CCA_NC);
	*(volatile uint64_t *)(heart + HEART_IMR(0)) |= 1UL << intrbit;
a328 1
	struct xheart_softc *sc = (void *)xheart_cd.cd_devs[0];
a329 1
	paddr_t heart;
d333 1
a333 1
	if (intrbit < HEART_INTR_MIN || intrbit > HEART_INTR_MAX)
d339 1
a339 1
	if ((ih = intrhand[intrbit]) == NULL) {
d344 1
a344 3
	/* XXX this assumes we run on cpu0 */
	heart = PHYS_TO_XKPHYS(HEART_PIU_BASE, CCA_NC);
	*(volatile uint64_t *)(heart + HEART_IMR(0)) &= ~(1UL << intrbit);
d346 2
a347 1
	intrhand[intrbit] = NULL;
d349 1
a349 2
	sc->sc_intrmask &= ~(1UL << intrbit);
	xheart_intr_makemasks(sc);
a351 2

	splx(s);
a354 6
 * Xheart interrupt handler driver.
 */

uint64_t heart_intem = 0;

/*
d358 1
a358 1
xheart_intr_makemasks(struct xheart_softc *sc)
d362 1
a362 1
	uint32_t intrlevel[INTMASKSIZE];
d365 3
a367 3
	for (irq = 0; irq < INTMASKSIZE; irq++) {
		int levels = 0;
		for (q = intrhand[irq]; q; q = q->ih_next)
d372 9
a380 4
	/* Then figure out which IRQs use each level. */
	for (level = IPL_NONE; level < NIPLS; level++) {
		int irqs = 0;
		for (irq = 0; irq < INTMASKSIZE; irq++)
d382 2
a383 4
				irqs |= 1 << irq;
		if (level != IPL_NONE)
			irqs |= SINT_ALLMASK;
		imask[level] = irqs;
d393 4
a396 4
	imask[IPL_NET] |= imask[IPL_BIO];
	imask[IPL_TTY] |= imask[IPL_NET];
	imask[IPL_VM] |= imask[IPL_TTY];
	imask[IPL_CLOCK] |= imask[IPL_VM] | SPL_CLOCKMASK;
d401 2
a402 6
	imask[IPL_NONE] = 0;
	imask[IPL_HIGH] = -1;

	heart_intem = sc->sc_intrmask;
	if(CPU_IS_PRIMARY(curcpu()))
		hw_setintrmask(0);
d406 1
a406 1
xheart_splx(int newcpl)
d410 4
a413 4
	/* Update masks to new cpl. Order highly important! */
	__asm__ (" .set noreorder\n");
	ci->ci_cpl = newcpl;
	__asm__ (" sync\n .set reorder\n");
d415 1
a415 1
		hw_setintrmask(newcpl);
d417 1
a417 1
	if (ci->ci_softpending & ~newcpl)
d421 3
a423 11
uint32_t
xheart_intr_handler(uint32_t hwpend, struct trap_frame *frame)
{
	struct cpu_info *ci = curcpu();
	paddr_t heart;
	uint64_t imr, isr;
	int icpl;
	int bit;
	uint32_t mask;
	struct intrhand *ih;
	int rc;
d425 42
a466 7
	heart = PHYS_TO_XKPHYS(HEART_PIU_BASE, CCA_NC);
	isr = *(volatile uint64_t *)(heart + HEART_ISR);
	imr = *(volatile uint64_t *)(heart + HEART_IMR(0));

	isr &= imr;
	if (isr == 0)
		return 0;	/* not for us */
d468 1
a468 4
	/*
	 * Mask all pending interrupts.
	 */
	*(volatile uint64_t *)(heart + HEART_IMR(0)) &= ~isr;
d470 6
a475 45
	/*
	 * If interrupts are spl-masked, mark them as pending only.
	 */
	if ((mask = isr & frame->cpl) != 0) {
		isr &= ~mask;
	}

	/*
	 * Now process unmasked interrupts.
	 */
	if (isr != 0) {
		__asm__ (" .set noreorder\n");
		icpl = ci->ci_cpl;
		__asm__ (" sync\n .set reorder\n");

		/* XXX Rework this to dispatch in decreasing levels */
		for (bit = HEART_INTR_MAX, mask = 1 << bit;
		    bit >= HEART_INTR_MIN; bit--, mask >>= 1) {
			if ((isr & mask) == 0)
				continue;

			rc = 0;
			for (ih = intrhand[bit]; ih != NULL; ih = ih->ih_next) {
				splraise(imask[ih->ih_level]);
				ih->frame = frame;
				if ((*ih->ih_fun)(ih->ih_arg) != 0) {
					rc = 1;
					ih->ih_count.ec_count++;
				}
			}
			if (rc == 0)
				printf("spurious interrupt, source %d\n", bit);
		}

		/*
		 * Reenable interrupts which have been serviced.
		 */
		*(volatile uint64_t *)(heart + HEART_IMR(0)) |= isr;

		__asm__ (" .set noreorder\n");
		ci->ci_cpl = icpl;
		__asm__ (" sync\n .set reorder\n");
	}

	return CR_INT_0;
@


1.11
log
@The recent cleanups make blatantly visible that the pending_int handler
does almost exactly what splx() is doing if ipending is zero, and triggers
soft interrupts as well.

So don't bother checking for ipending in splx, and always invoke pending_int,
which gets renamed as splx_handler for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.10 2009/10/22 20:05:28 miod Exp $	*/
d404 1
a404 1
	if (ci->ci_ipending & SINT_ALLMASK & ~newcpl)
a436 1
		atomic_setbits_int(&ci->ci_ipending, mask);
a443 2
		atomic_clearbits_int(&ci->ci_ipending, isr);

@


1.10
log
@Replace intrmask_t with uint32_t. This types only describes interrupt masks
in the coprocessor 0 status register (coupled with ICR on rm7k/rm9k), and
may be completely alien to real hardware interrupt masks, so don't make
things unnecessary confusing.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.9 2009/10/07 08:35:47 syuu Exp $	*/
d73 1
a73 1
void	xheart_do_pending_int(int);
d135 1
a135 1
		register_pending_int_handler(xheart_do_pending_int);
d393 1
a393 1
xheart_do_pending_int(int newcpl)
d401 1
a401 1
	if(CPU_IS_PRIMARY(ci))
@


1.9
log
@ipending, cpl moved into cpu_info
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.8 2009/05/27 19:06:20 miod Exp $	*/
d71 1
a71 1
intrmask_t xheart_intr_handler(intrmask_t, struct trap_frame *);
d348 1
a348 1
	intrmask_t intrlevel[INTMASKSIZE];
d408 2
a409 2
intrmask_t
xheart_intr_handler(intrmask_t hwpend, struct trap_frame *frame)
d416 1
a416 1
	intrmask_t mask;
@


1.8
log
@Use the KL enumeration functions to try and figure out what kind of XBow
we have, in order to pick a widget enumeration order matching the PROM.

This is especially important when the boot path is in dksc() syntax.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.7 2009/05/08 18:42:07 miod Exp $	*/
d388 2
a389 1
	hw_setintrmask(0);
d395 2
d399 1
a399 1
	cpl = newcpl;
d401 2
a402 1
	hw_setintrmask(newcpl);
d404 1
a404 1
	if (ipending & SINT_ALLMASK & ~newcpl)
d411 1
d437 1
a437 1
		atomic_setbits_int(&ipending, mask);
d445 1
a445 1
		atomic_clearbits_int(&ipending, isr);
d448 1
a448 1
		icpl = cpl;
d476 1
a476 1
		cpl = icpl;
@


1.7
log
@Add a new page freelist, to which memory suitable for 32-bit dma on
xbridge(4) is assigned. Then, make bus_dmamem_alloc() allocate from this
range only.

This is transparent on O2, and makes sure the bus_dma memory address
will fit in the 2GB direct map of xbridge(4) chips - this is necessary for
PCI devices which do not handle 64 bit dma addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.6 2009/04/18 14:48:09 miod Exp $	*/
d81 2
a82 7
	    xaa->xaa_product == XBOW_PRODUCT_SGI4_HEART) {
		/*
		 * Only match if no interrupt widget has registered yet.
		 * There should be only one Heart in a system anyway.
		 */
		return xbow_intr_widget == 0 ? 20 : 0;
	}
@


1.6
log
@Fewer hardcoded values and simpler code in ip30 interrupt handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.5 2009/04/15 18:45:41 miod Exp $	*/
d290 3
a292 1
	evcount_attach(&ih->ih_count, name, &ih->ih_level, &evcount_intr);
@


1.5
log
@Change the way the widget interrupt register is computed and have it become
a complete physical address. Also add proper cpu pa<->device pa for dma
on Origin 200.

This lets xbridge work and route interrupts correctly on Origin 200.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.4 2009/04/12 17:53:26 miod Exp $	*/
a245 2
	 * On HEART, the low 16 bits of the interrupt register
	 * are level 0 sources.
d247 1
a247 1
	for (bit = 15; bit >= 0; bit--)
d251 1
a251 1
	if (bit < 0)
d270 1
a270 1
	if (intrbit < 0 || intrbit >= 16)
d312 1
a312 1
	if (intrbit < 0 || intrbit >= 16)
d341 1
a341 1
intrmask_t heart_intem = 0;
d390 1
a390 2
	/* Lastly, determine which IRQs are actually in use. */
	heart_intem = sc->sc_intrmask & 0x00000000ffffffffL;
d412 1
d416 1
d427 6
a432 2
	 * If interrupts are spl-masked, mark them as pending and mask
	 * them in hardware.
a435 1
		*(volatile uint64_t *)(heart + HEART_IMR(0)) &= ~mask;
d442 24
a465 9
	mask = isr & ~frame->cpl;
	atomic_clearbits_int(&ipending, mask);
	for (bit = 15, mask = 1 << 15; bit >= 0; bit--, mask >>= 1) {
		if ((isr & mask) == 0)
			continue;

		for (ih = intrhand[bit]; ih != NULL; ih = ih->ih_next) {
			if ((*ih->ih_fun)(ih->ih_arg) != 0)
				ih->ih_count.ec_count++;
d467 9
@


1.4
log
@Needs <machine/atomic.h> to compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.3 2009/03/20 18:41:07 miod Exp $	*/
a452 8
}

void
hw_setintrmask(intrmask_t m)
{
	paddr_t heart;
	heart = PHYS_TO_XKPHYS(HEART_PIU_BASE, CCA_NC);
	*(volatile uint64_t *)(heart + HEART_IMR(0)) = heart_intem & ~m;
@


1.3
log
@Switch sgi to __HAVE_GENERIC_SOFT_INTERRUPTS.
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.2 2008/07/28 18:50:59 miod Exp $	*/
d31 1
d452 1
a452 1
	return CR_INT_0;	/* hwpend */
@


1.2
log
@Put XBOW in the generated constants, not PCI...
@
text
@d1 1
a1 1
/*	$OpenBSD: xheart.c,v 1.1 2008/04/07 22:47:40 miod Exp $	*/
d368 3
a370 1
		imask[level] = irqs | SINT_ALLMASK;
@


1.1
log
@A first cut at XBow bus support, very minimal, limited to a local bus only;
HUB driver (for IP27) is a stub, and interrupt support is a shoot in the dark
and will need some serious debugging until it is sane, but I want to reduce
the weight of these diffs first.

Based on a lot of tinkering and experiments, as well as knowledge extracted
from the Linux source code.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d79 2
a80 2
	if (xaa->xaa_vendor == PCI_VENDOR_SGI4 &&
	    xaa->xaa_product == PCI_PRODUCT_SGI4_HEART) {
@

