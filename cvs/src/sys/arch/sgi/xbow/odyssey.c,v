head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.12
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.10
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.6
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.8
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.8
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.11
date	2014.03.09.10.01.25;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2013.12.23.21.32.30;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.21.10.36.18;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2013.10.20.20.07.24;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2012.04.16.22.17.16;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.07.18.16.03;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2010.04.06.19.12.34;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.06.19.02.57;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.08.20.54.45;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2010.03.07.13.44.26;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2010.03.04.14.50.35;	author jsing;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Replace more magic numbers with OPENGL_xxx constants. No functional change.
@
text
@/*	$OpenBSD: odyssey.c,v 1.10 2013/12/23 21:32:30 miod Exp $ */
/*
 * Copyright (c) 2009, 2010 Joel Sing <jsing@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Driver for the SGI VPro (aka Odyssey) Graphics Card.
 */

/*
 * The details regarding the design and operation of this hardware, along with
 * the necessary magic numbers, are only available thanks to the reverse
 * engineering work undertaken by Stanislaw Skowronek <skylark@@linux-mips.org>.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/types.h>
#include <sys/malloc.h>

#include <machine/autoconf.h>

#include <mips64/arcbios.h>

#include <sgi/dev/gl.h>
#include <sgi/xbow/odysseyreg.h>
#include <sgi/xbow/odysseyvar.h>
#include <sgi/xbow/widget.h>
#include <sgi/xbow/xbow.h>
#include <sgi/xbow/xbowdevs.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

/*
 * Colourmap data.
 */
struct  odyssey_cmap {
	u_int8_t cm_red[256];
	u_int8_t cm_green[256];
	u_int8_t cm_blue[256];
};

/*
 * Screen data.
 */
struct odyssey_screen {
	struct device *sc;		/* Back pointer. */

	struct rasops_info ri;		/* Screen raster display info. */
	struct odyssey_cmap cmap;	/* Display colour map. */
	long attr;			/* Rasops attributes. */

	int width;			/* Width in pixels. */
	int height;			/* Height in pixels. */
	int depth;			/* Colour depth in bits. */
	int linebytes;			/* Bytes per line. */
};

struct odyssey_softc {
	struct device		sc_dev;

	struct mips_bus_space	iot_store;
	bus_space_tag_t		iot;
	bus_space_handle_t	ioh;

	int console;				/* Is this the console? */
	int screens;				/* No of screens allocated. */

	struct odyssey_screen	*curscr;	/* Current screen. */
};

int	odyssey_match(struct device *, void *, void *);
void	odyssey_attach(struct device *, struct device *, void *);

int	odyssey_is_console(struct xbow_attach_args *);

void	odyssey_cmd_wait(struct odyssey_softc *);
void	odyssey_data_wait(struct odyssey_softc *);
void	odyssey_cmd_flush(struct odyssey_softc *, int);

void	odyssey_setup(struct odyssey_softc *);
void	odyssey_init_screen(struct odyssey_screen *);

/*
 * Colour map handling for indexed modes.
 */
int	odyssey_getcmap(struct odyssey_cmap *, struct wsdisplay_cmap *);
int	odyssey_putcmap(struct odyssey_cmap *, struct wsdisplay_cmap *);

/*
 * Hardware acceleration for rasops.
 */
void	odyssey_rop(struct odyssey_softc *, int, int, int, int, int, int);
void	odyssey_copyrect(struct odyssey_softc *, int, int, int, int, int, int);
void	odyssey_fillrect(struct odyssey_softc *, int, int, int, int, u_int);
int	odyssey_do_cursor(struct rasops_info *);
int	odyssey_putchar(void *, int, int, u_int, long);
int	odyssey_copycols(void *, int, int, int, int);
int	odyssey_erasecols(void *, int, int, int, long);
int	odyssey_copyrows(void *, int, int, int);
int	odyssey_eraserows(void *, int, int, long);

u_int32_t ieee754_sp(uint);

/*
 * Interfaces for wscons.
 */
int 	odyssey_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t odyssey_mmap(void *, off_t, int);
int	odyssey_alloc_screen(void *, const struct wsscreen_descr *, void **,
	    int *, int *, long *);
void	odyssey_free_screen(void *, void *);
int	odyssey_show_screen(void *, void *, int, void (*)(void *, int, int),
	    void *);
int	odyssey_load_font(void *, void *, struct wsdisplay_font *);
int	odyssey_list_font(void *, struct wsdisplay_font *);

static struct odyssey_screen odyssey_consdata;
static struct odyssey_softc odyssey_cons_sc;

struct wsscreen_descr odyssey_stdscreen = {
	"std",			/* Screen name. */
};

struct wsdisplay_accessops odyssey_accessops = {
	.ioctl = odyssey_ioctl,
	.mmap = odyssey_mmap,
	.alloc_screen = odyssey_alloc_screen,
	.free_screen = odyssey_free_screen,
	.show_screen = odyssey_show_screen,
	.load_font = odyssey_load_font,
	.list_font = odyssey_list_font
};

const struct wsscreen_descr *odyssey_scrlist[] = {
	&odyssey_stdscreen
};

struct wsscreen_list odyssey_screenlist = {
	nitems(odyssey_scrlist), odyssey_scrlist
};

const struct cfattach odyssey_ca = {
	sizeof(struct odyssey_softc), odyssey_match, odyssey_attach,
};

struct cfdriver odyssey_cd = {
	NULL, "odyssey", DV_DULL,
};

int
odyssey_match(struct device *parent, void *match, void *aux)
{
	struct xbow_attach_args *xaa = aux;

	if (xaa->xaa_vendor == XBOW_VENDOR_SGI2 &&
	    xaa->xaa_product == XBOW_PRODUCT_SGI2_ODYSSEY)
		return 1;

	return 0;
}

void
odyssey_attach(struct device *parent, struct device *self, void *aux)
{
	struct xbow_attach_args *xaa = aux;
	struct wsemuldisplaydev_attach_args waa;
	struct odyssey_softc *sc = (void *)self;
	struct odyssey_screen *screen;

	if (strncmp(bios_graphics, "alive", 5) != 0) {
		printf(" device has not been setup by firmware!\n");
		return;
	}

	printf(" revision %d\n", xaa->xaa_revision);

	/*
	 * Create a copy of the bus space tag.
	 */
	bcopy(xaa->xaa_iot, &sc->iot_store, sizeof(struct mips_bus_space));
	sc->iot = &sc->iot_store;

	/* Setup bus space mappings. */
	if (bus_space_map(sc->iot, ODYSSEY_REG_OFFSET, ODYSSEY_REG_SIZE,
	    BUS_SPACE_MAP_LINEAR, &sc->ioh)) {
		printf("failed to map bus space!\n");
		return;
	}

	if (odyssey_is_console(xaa)) {
		/*
		 * Setup has already been done via odyssey_cnattach().
		 */
		screen = &odyssey_consdata;
       		sc->curscr = screen;
		sc->curscr->sc = (void *)sc;
		sc->console = 1;
	} else {
		/*
		 * Setup screen data.
		 */
		sc->curscr = malloc(sizeof(struct odyssey_screen), M_DEVBUF,
		    M_NOWAIT);
		if (sc->curscr == NULL) {
			printf("failed to allocate screen memory!\n");
			return;
		}
		sc->curscr->sc = (void *)sc;
		screen = sc->curscr;

		/* Setup hardware and clear screen. */
		odyssey_setup(sc);
		odyssey_fillrect(sc, 0, 0, 1280, 1024, 0x000000);
		odyssey_cmd_flush(sc, 0);

		/* Set screen defaults. */
		screen->width = 1280;
		screen->height = 1024;
		screen->depth = 32;
		screen->linebytes = screen->width * screen->depth / 8;

		odyssey_init_screen(screen);
	}

	waa.console = sc->console;
	waa.scrdata = &odyssey_screenlist;
	waa.accessops = &odyssey_accessops;
	waa.accesscookie = screen;
	waa.defaultscreens = 0;
	config_found(self, &waa, wsemuldisplaydevprint);
}

void
odyssey_init_screen(struct odyssey_screen *screen)
{
	u_char *colour;
	int i;

	/*
	 * Initialise screen.
	 */

	/* Initialise rasops. */
	memset(&screen->ri, 0, sizeof(struct rasops_info));

	screen->ri.ri_flg = RI_CENTER;
	screen->ri.ri_depth = screen->depth;
	screen->ri.ri_width = screen->width;
	screen->ri.ri_height = screen->height;
	screen->ri.ri_stride = screen->linebytes;

	if (screen->depth == 32) {
		screen->ri.ri_bpos = 16;
		screen->ri.ri_bnum = 8;
		screen->ri.ri_gpos = 8;
		screen->ri.ri_gnum = 8;
		screen->ri.ri_rpos = 0;
		screen->ri.ri_rnum = 8;
	} else if (screen->depth == 16) {
		screen->ri.ri_rpos = 10;
		screen->ri.ri_rnum = 5;
		screen->ri.ri_gpos = 5;
		screen->ri.ri_gnum = 5;
		screen->ri.ri_bpos = 0;
		screen->ri.ri_bnum = 5;
	}

	rasops_init(&screen->ri, screen->height / 8, screen->width / 8);

	/*
	 * Initialise colourmap, if required.
	 */
	if (screen->depth == 8) {
		for (i = 0; i < 16; i++) {
			colour = (u_char *)&rasops_cmap[i * 3];
			screen->cmap.cm_red[i] = colour[0];
			screen->cmap.cm_green[i] = colour[1];
			screen->cmap.cm_blue[i] = colour[2];
		}
		for (i = 240; i < 256; i++) {
			colour = (u_char *)&rasops_cmap[i * 3];
			screen->cmap.cm_red[i] = colour[0];
			screen->cmap.cm_green[i] = colour[1];
			screen->cmap.cm_blue[i] = colour[2];
		}
	}

	screen->ri.ri_hw = screen->sc;

	screen->ri.ri_ops.putchar = odyssey_putchar;
	screen->ri.ri_do_cursor = odyssey_do_cursor;
	screen->ri.ri_ops.copyrows = odyssey_copyrows;
	screen->ri.ri_ops.copycols = odyssey_copycols;
	screen->ri.ri_ops.eraserows = odyssey_eraserows;
	screen->ri.ri_ops.erasecols = odyssey_erasecols;

	odyssey_stdscreen.ncols = screen->ri.ri_cols;
	odyssey_stdscreen.nrows = screen->ri.ri_rows;
	odyssey_stdscreen.textops = &screen->ri.ri_ops;
	odyssey_stdscreen.fontwidth = screen->ri.ri_font->fontwidth;
	odyssey_stdscreen.fontheight = screen->ri.ri_font->fontheight;
	odyssey_stdscreen.capabilities = screen->ri.ri_caps;
}

/*
 * Hardware initialisation.
 */
void
odyssey_setup(struct odyssey_softc *sc)
{
	u_int64_t val;
	int i;

	/* Initialise Buzz Graphics Engine. */
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x20008003);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x21008010);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x22008000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x23008002);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x2400800c);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x2500800e);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x27008000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x28008000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x290080d6);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x2a0080e0);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x2c0080ea);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x2e008380);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x2f008000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x30008000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x31008000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x32008000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x33008000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x34008000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x35008000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x310081e0);
	odyssey_cmd_flush(sc, 0);

	/* Initialise Buzz X-Form. */
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x9080bda2);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x3f800000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x3f000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0xbf800000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x4e000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x40400000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x4e000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x4d000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x34008000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x9080bdc8);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x3f800000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x3f000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x3f800000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x3f000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x3f800000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x3f800000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x34008010);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x908091df);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x3f800000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x34008000);
	odyssey_cmd_flush(sc, 0);

	/* Initialise Buzz Raster. */
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x0001203b);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00001000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00001000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00001000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00001000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x0001084a);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000080);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000080);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010845);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x000000ff);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x000076ff);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x0001141b);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000001);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00011c16);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x03000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010404);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00011023);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00ff0ff0);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00ff0ff0);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x000000ff);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00011017);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00002000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000050);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x20004950);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x0001204b);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x004ff3ff);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00ffffff);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00ffffff);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00ffffff);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	odyssey_cmd_flush(sc, 0);

	/*
	 * Initalise Pixel Blaster & Jammer.
	 */
	for (i = 0; i < 32; i++) {
		if ((i & 0xf) == 0)
			odyssey_data_wait(sc);

		bus_space_write_8(sc->iot, sc->ioh, ODYSSEY_DATA_FIFO,
		    ((0x30000001ULL | ((0x2900 + i) << 14)) << 32) |
		    0x905215a6);
	}

	odyssey_data_wait(sc);
	bus_space_write_8(sc->iot, sc->ioh, ODYSSEY_DATA_FIFO,
	    ((0x30000001ULL | (0x2581 << 14)) << 32) | 0x0);

	/* Gamma ramp. */
	for (i = 0; i < 0x600; i++) {
		if ((i & 0xf) == 0)
			odyssey_data_wait(sc);

		if (i < 0x200)
			val = i >> 2;
		else if (i < 0x300)
			val = ((i - 0x200) >> 1) + 0x80;
		else
			val = ((i - 0x300) >> 0) + 0x100;

		val = (val << 20) | (val << 10) | val;

		bus_space_write_8(sc->iot, sc->ioh, ODYSSEY_DATA_FIFO,
		    ((0x30000001ULL | ((0x1a00 + i) << 14)) << 32) | val);
	}
}

void
odyssey_cmd_wait(struct odyssey_softc *sc)
{
	u_int32_t val, timeout = 1000000;

	val = bus_space_read_4(sc->iot, sc->ioh, ODYSSEY_STATUS);
	while ((val & ODYSSEY_STATUS_CMD_FIFO_LOW) == 0) {
		delay(1);
		if (--timeout == 0) {
			printf("odyssey: timeout waiting for command fifo!\n");
			return;
		}
		val = bus_space_read_4(sc->iot, sc->ioh, ODYSSEY_STATUS);
	}
}

void
odyssey_data_wait(struct odyssey_softc *sc)
{
	u_int32_t val, timeout = 1000000;

	val = bus_space_read_4(sc->iot, sc->ioh, ODYSSEY_DBE_STATUS);
	while ((val & 0x7f) > 0) {
		delay(1);
		if (--timeout == 0) {
			printf("odyssey: timeout waiting for data fifo!\n");
			return;
		}
		val = bus_space_read_4(sc->iot, sc->ioh, ODYSSEY_DBE_STATUS);
	}
}

void
odyssey_cmd_flush(struct odyssey_softc *sc, int quick)
{

	odyssey_cmd_wait(sc);

	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010443);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x000000fa);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010046);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010046);

	if (quick)
		return;

	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010019);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010443);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000096);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010046);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010046);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010046);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010046);

	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010443);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x000000fa);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010046);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010046);
}

/*
 * Interfaces for wscons.
 */

int
odyssey_ioctl(void *v, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct odyssey_screen *screen = (struct odyssey_screen *)v;
	int rc;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_ODYSSEY;
		break;

	case WSDISPLAYIO_GINFO:
	{
		struct wsdisplay_fbinfo *fb = (struct wsdisplay_fbinfo *)data;

		fb->height = screen->height;
		fb->width = screen->width;
		fb->depth = screen->depth;
		fb->cmsize = screen->depth == 8 ? 256 : 0;
	}
		break;

	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = screen->linebytes;
		break;

	case WSDISPLAYIO_GETCMAP:
		if (screen->depth == 8) {
			struct wsdisplay_cmap *cm =
			    (struct wsdisplay_cmap *)data;

			rc = odyssey_getcmap(&screen->cmap, cm);
			if (rc != 0)
				return (rc);
		}
		break;

	case WSDISPLAYIO_PUTCMAP:
		if (screen->depth == 8) {
			struct wsdisplay_cmap *cm =
			    (struct wsdisplay_cmap *)data;

			rc = odyssey_putcmap(&screen->cmap, cm);
			if (rc != 0)
				return (rc);
		}
		break;

	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_SVIDEO:
		/* Handled by the upper layer. */
		break;

	default:
		return (-1);
	}

	return (0);
}

int
odyssey_getcmap(struct odyssey_cmap *cm, struct wsdisplay_cmap *rcm)
{
	u_int index = rcm->index, count = rcm->count;
	int rc;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);

	if ((rc = copyout(&cm->cm_red[index], rcm->red, count)) != 0)
		return (rc);
	if ((rc = copyout(&cm->cm_green[index], rcm->green, count)) != 0)
		return (rc);
	if ((rc = copyout(&cm->cm_blue[index], rcm->blue, count)) != 0)
		return (rc);

	return (0);
}

int
odyssey_putcmap(struct odyssey_cmap *cm, struct wsdisplay_cmap *rcm)
{
	u_int index = rcm->index, count = rcm->count;
	int rc;

	if (index >= 256 || count > 256 - index)
		return (EINVAL);

	if ((rc = copyin(rcm->red, &cm->cm_red[index], count)) != 0)
		return (rc);
	if ((rc = copyin(rcm->green, &cm->cm_green[index], count)) != 0)
		return (rc);
	if ((rc = copyin(rcm->blue, &cm->cm_blue[index], count)) != 0)
		return (rc);

	return (0);
}

paddr_t
odyssey_mmap(void *v, off_t offset, int protection)
{
	return (-1);
}

int
odyssey_alloc_screen(void *v, const struct wsscreen_descr *type,
    void **cookiep, int *curxp, int *curyp, long *attrp)
{
	struct odyssey_screen *screen = (struct odyssey_screen *)v;
	struct odyssey_softc *sc = (struct odyssey_softc *)screen->sc;

	/* We do not allow multiple consoles at the moment. */
	if (sc->screens > 0)
		return (ENOMEM);

	sc->screens++;

	/* Return rasops_info via cookie. */
	*cookiep = &screen->ri;

	/* Move cursor to top left of screen. */
	*curxp = 0;
	*curyp = 0;

	/* Correct screen attributes. */
	screen->ri.ri_ops.alloc_attr(&screen->ri, 0, 0, 0, attrp);
	screen->attr = *attrp;

	return (0);
}

void
odyssey_free_screen(void *v, void *cookie)
{
	/* We do not allow multiple consoles at the moment. */
}

int
odyssey_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	/* We do not allow multiple consoles at the moment. */
	return (0);
}

int
odyssey_load_font(void *v, void *emulcookie, struct wsdisplay_font *font)
{
	struct odyssey_screen *screen = (struct odyssey_screen *)v;

	return rasops_load_font(&screen->ri, emulcookie, font);
}

int
odyssey_list_font(void *v, struct wsdisplay_font *font)
{
	struct odyssey_screen *screen = (struct odyssey_screen *)v;

	return rasops_list_font(&screen->ri, font);
}

/*
 * Hardware accelerated functions.
 */

void
odyssey_rop(struct odyssey_softc *sc, int x, int y, int w, int h, int op, int c)
{
	/* Setup raster operation. */
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010404);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00100000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, OPENGL_LOGIC_OP);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, op);
	odyssey_cmd_flush(sc, 1);

	odyssey_fillrect(sc, x, y, w, h, c);

	/* Return to copy mode. */
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010404);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00100000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, OPENGL_LOGIC_OP);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO,
	    OPENGL_LOGIC_OP_COPY);
	odyssey_cmd_flush(sc, 1);
}

void
odyssey_copyrect(struct odyssey_softc *sc, int sx, int sy, int dx, int dy,
    int w, int h)
{
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010658);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00120000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00002031);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00002000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, sx | (sy << 16));
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x80502050);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, w | (h << 16));
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x82223042);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00002000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, dx | (dy << 16));
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x3222204b);

	odyssey_cmd_flush(sc, 1);
}

void
odyssey_fillrect(struct odyssey_softc *sc, int x, int y, int w, int h, u_int c)
{
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, OPENGL_BEGIN);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, OPENGL_QUADS);

	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, OPENGL_COLOR_3UB);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, c & 0xff);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, (c >> 8) & 0xff);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, (c >> 16) & 0xff);

	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, OPENGL_VERTEX_2I);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, x);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, y);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, OPENGL_VERTEX_2I);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, x + w);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, y);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, OPENGL_VERTEX_2I);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, x + w);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, y + h);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, OPENGL_VERTEX_2I);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, x);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, y + h);

	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, OPENGL_END);

	odyssey_cmd_flush(sc, 1);
}

int
odyssey_do_cursor(struct rasops_info *ri)
{
	struct odyssey_softc *sc = ri->ri_hw;
	struct odyssey_screen *screen = sc->curscr;
	int y, x, w, h, fg, bg;

	w = ri->ri_font->fontwidth;
	h = ri->ri_font->fontheight;
	x = ri->ri_xorigin + ri->ri_ccol * w;
	y = ri->ri_yorigin + ri->ri_crow * h;

	ri->ri_ops.unpack_attr(ri, screen->attr, &fg, &bg, NULL);

	odyssey_rop(sc, x, y, w, h, OPENGL_LOGIC_OP_XOR, ri->ri_devcmap[fg]);
	odyssey_cmd_flush(sc, 0);

	return 0;
}

int
odyssey_putchar(void *cookie, int row, int col, u_int uc, long attr)
{
	struct rasops_info *ri = cookie;
	struct odyssey_softc *sc = ri->ri_hw;
	struct wsdisplay_font *font = ri->ri_font;
	int bg, fg, ul, i, j, ci, l;
	uint x, y, w, h;
	u_int8_t *fontbitmap;
	u_int chunk;

	w = ri->ri_font->fontwidth;
	h = ri->ri_font->fontheight;
	x = ri->ri_xorigin + col * w;
	y = ri->ri_yorigin + row * h;

	fontbitmap = (u_int8_t *)(font->data + (uc - font->firstchar) *
	    ri->ri_fontscale);
	ri->ri_ops.unpack_attr(ri, attr, &fg, &bg, &ul);

	/* Handle spaces with a single fillrect. */
	if (uc == ' ') {
		odyssey_fillrect(sc, x, y, w, h, ri->ri_devcmap[bg]);
		odyssey_cmd_flush(sc, 0);
		return 0;
	}

	odyssey_fillrect(sc, x, y, w, h, 0xff0000);

	/* Setup pixel painting. */
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010405);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00002400);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, OPENGL_COLOR_3UB);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00011453);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000002);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	odyssey_cmd_flush(sc, 0);

	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x2900812f);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, OPENGL_BEGIN);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x0000000a);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0xcf80a92f);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, ieee754_sp(x));
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, ieee754_sp(y));
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO,
	    ieee754_sp(x + font->fontwidth));
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO,
	    ieee754_sp(y + font->fontheight));
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, OPENGL_VERTEX_2I);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00004570);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x0f00104c);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000071);

	for (i = font->fontheight; i != 0; i--) {

		/* Get bitmap for current line. */
		if (font->fontwidth <= 8)
			chunk = *fontbitmap;
		else
			chunk = *(u_int16_t *)fontbitmap;
		fontbitmap += font->stride;

		/* Handle underline. */
		if (ul && i == 1)
			chunk = 0xffff;

		/* Draw character. */
		bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO,
		    0x00004570);
		bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO,
		    0x0fd1104c);
		bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO,
		    0x00000071);

		w = font->fontwidth;
		l = 0;

		for (j = 0; j < font->fontwidth; j++) {

			if (l == 0) {

				l = (w > 14 ? 14 : w);
				w -= 14;

				/* Number of pixels. */
				bus_space_write_4(sc->iot, sc->ioh,
				    ODYSSEY_CMD_FIFO, (0x00014011 |
				    (l << 10)));

			}

			if (font->fontwidth > 8)
				ci = (chunk & (1 << (16 - j)) ? fg : bg);
			else
				ci = (chunk & (1 << (8 - j)) ? fg : bg);

			bus_space_write_4(sc->iot, sc->ioh,
			    ODYSSEY_CMD_FIFO, ri->ri_devcmap[ci]);

			l--;
		}
	}

	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, OPENGL_END);
	odyssey_cmd_flush(sc, 1);

	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x290080d6);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00011453);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00010405);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00002000);
	odyssey_cmd_flush(sc, 0);

	return 0;
}

int
odyssey_copycols(void *cookie, int row, int src, int dst, int num)
{
	struct rasops_info *ri = cookie;
	struct odyssey_softc *sc = ri->ri_hw;
	int i;

	if (src < dst) {

		/* We cannot control copy direction, so copy col by col. */
		for (i = num - 1; i >= 0; i--)
			odyssey_copyrect(sc,
			    ri->ri_xorigin + (src + i) * ri->ri_font->fontwidth,
			    ri->ri_yorigin + row * ri->ri_font->fontheight,
			    ri->ri_xorigin + (dst + i) * ri->ri_font->fontwidth,
			    ri->ri_yorigin + row * ri->ri_font->fontheight,
			    ri->ri_font->fontwidth, ri->ri_font->fontheight);

	} else {

		odyssey_copyrect(sc,
		    ri->ri_xorigin + src * ri->ri_font->fontwidth,
		    ri->ri_yorigin + row * ri->ri_font->fontheight,
		    ri->ri_xorigin + dst * ri->ri_font->fontwidth,
		    ri->ri_yorigin + row * ri->ri_font->fontheight,
		    num * ri->ri_font->fontwidth, ri->ri_font->fontheight);

	}

	odyssey_cmd_flush(sc, 0);

	return 0;
}

int
odyssey_erasecols(void *cookie, int row, int col, int num, long attr)
{
	struct rasops_info *ri = cookie;
	struct odyssey_softc *sc = ri->ri_hw;
	int bg, fg;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);

	row *= ri->ri_font->fontheight;
	col *= ri->ri_font->fontwidth;
	num *= ri->ri_font->fontwidth;

	odyssey_fillrect(sc, ri->ri_xorigin + col, ri->ri_yorigin + row,
	    num, ri->ri_font->fontheight, ri->ri_devcmap[bg]);
	odyssey_cmd_flush(sc, 0);

	return 0;
}

int
odyssey_copyrows(void *cookie, int src, int dst, int num)
{
	struct rasops_info *ri = cookie;
	struct odyssey_softc *sc = ri->ri_hw;
	int i;

	if (src < dst) {

		/* We cannot control copy direction, so copy row by row. */
		for (i = num - 1; i >= 0; i--)
			odyssey_copyrect(sc, ri->ri_xorigin, ri->ri_yorigin +
			    (src + i) * ri->ri_font->fontheight,
			    ri->ri_xorigin, ri->ri_yorigin +
			    (dst + i) * ri->ri_font->fontheight,
			    ri->ri_emuwidth, ri->ri_font->fontheight);

	} else {

		odyssey_copyrect(sc, ri->ri_xorigin,
		    ri->ri_yorigin + src * ri->ri_font->fontheight,
		    ri->ri_xorigin,
		    ri->ri_yorigin + dst * ri->ri_font->fontheight,
		    ri->ri_emuwidth, num * ri->ri_font->fontheight);

	}

	odyssey_cmd_flush(sc, 0);

	return 0;
}

int
odyssey_eraserows(void *cookie, int row, int num, long attr)
{
	struct rasops_info *ri = cookie;
	struct odyssey_softc *sc = ri->ri_hw;
	int x, y, w, bg, fg;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);

	if ((num == ri->ri_rows) && ISSET(ri->ri_flg, RI_FULLCLEAR)) {
		num = ri->ri_height;
		x = y = 0;
		w = ri->ri_width;
	} else {
		num *= ri->ri_font->fontheight;
		x = ri->ri_xorigin;
		y = ri->ri_yorigin + row * ri->ri_font->fontheight;
		w = ri->ri_emuwidth;
	}

	odyssey_fillrect(sc, x, y, w, num, ri->ri_devcmap[bg]);
	odyssey_cmd_flush(sc, 0);

	return 0;
}

u_int32_t
ieee754_sp(uint v)
{
	u_int8_t exp = 0;
	int i = 12;	/* 0 <= v < 2048 */

	/*
	 * Convert a small integer to IEEE754 single precision floating point:
	 *
	 * 	Sign - 1 bit
	 * 	Exponent - 8 bits (with 2^(8-1)-1 = 127 bias)
	 * 	Fraction - 23 bits
	 */

	/* Determine shift for fraction. */
	while (i && (v & (1 << --i)) == 0);

	if (v != 0)
		exp = 127 + i;

	return (exp << 23) | ((v << (23 - i)) & 0x7fffff);
}

/*
 * Console support.
 */

int
odyssey_cnprobe()
{
	u_int32_t wid, vendor, product;

	/* Probe for Odyssey graphics card. */
	if (xbow_widget_id(console_output.nasid, console_output.widget,
	    &wid) != 0)
		return 0;

	vendor = WIDGET_ID_VENDOR(wid);
	product = WIDGET_ID_PRODUCT(wid);

	if (vendor != XBOW_VENDOR_SGI2 || product != XBOW_PRODUCT_SGI2_ODYSSEY)
		return 0;

	if (strncmp(bios_graphics, "alive", 5) != 0)
		return 0;

	return 1;
}

int
odyssey_cnattach()
{
	struct odyssey_softc *sc;
	struct odyssey_screen *screen;
	int rc;

	sc = &odyssey_cons_sc;
	screen = &odyssey_consdata;
	sc->curscr = screen;
	sc->curscr->sc = (void *)sc;

	/* Build bus space accessor. */
	xbow_build_bus_space(&sc->iot_store, console_output.nasid,
	    console_output.widget);
	sc->iot = &sc->iot_store;

	/* Setup bus space mappings. */
	rc = bus_space_map(sc->iot, ODYSSEY_REG_OFFSET, ODYSSEY_REG_SIZE,
	    BUS_SPACE_MAP_LINEAR, &sc->ioh);
	if (rc != 0)
		return rc;

	/* Setup hardware and clear screen. */
	odyssey_setup(sc);
	odyssey_fillrect(sc, 0, 0, 1280, 1024, 0x000000);
	odyssey_cmd_flush(sc, 0);

	/* Set screen defaults. */
	screen->width = 1280;
	screen->height = 1024;
	screen->depth = 32;
	screen->linebytes = screen->width * screen->depth / 8;

	odyssey_init_screen(screen);

	/*
	 * Attach wsdisplay.
	 */
	screen->ri.ri_ops.alloc_attr(&screen->ri, 0, 0, 0, &screen->attr);
	wsdisplay_cnattach(&odyssey_stdscreen, &screen->ri, 0, 0, screen->attr);

	return 0;
}

int
odyssey_is_console(struct xbow_attach_args *xaa)
{
	return xaa->xaa_nasid == console_output.nasid &&
	    xaa->xaa_widget == console_output.widget;
}
@


1.10
log
@- fix gamma ramp (now white is real white instead of light grey)
- speed-up the integer to single precision float routine by omitting the
  sign check and starting the log2 computation at 12 instead of 32, since
  all the values passed to this routine are actually on-screen coordinates.
@
text
@d1 1
a1 1
/*	$OpenBSD: odyssey.c,v 1.9 2013/10/21 10:36:18 miod Exp $ */
d837 4
a840 4
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0xc580cc08);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
d850 1
a850 1
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00014400);
d865 3
a867 3
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x8080c800);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00000000);
d922 1
a922 1
	bus_space_write_4(sc->iot, sc->ioh, ODYSSEY_CMD_FIFO, 0x00014001);
@


1.9
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@d1 1
a1 1
/*	$OpenBSD: odyssey.c,v 1.8 2013/10/20 20:07:24 miod Exp $ */
a72 1
	int ro_curpos;			/* Current position in rasops tile. */
d119 1
a119 1
u_int32_t ieee754_sp(int32_t);
d478 1
a478 1
			val = ((i - 0x300) >> 1) + 0x100;
d811 2
a812 1
	int x, y, w, h, bg, fg, ul, i, j, ci, l;
d1052 1
a1052 1
ieee754_sp(int32_t v)
d1054 2
a1055 2
	u_int8_t exp = 0, sign = 0;
	int i = 32;
d1058 1
a1058 1
	 * Convert an integer to IEEE754 single precision floating point:
a1064 5
	if (v < 0) {
		sign = 1;
		v = -v;
	}

d1071 1
a1071 1
	return (sign << 31) | (exp << 23) | ((v << (23 - i)) & 0x7fffff);
@


1.8
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: odyssey.c,v 1.7 2012/04/16 22:17:16 miod Exp $ */
d132 2
a133 1
void	odyssey_burner(void *, u_int, u_int);
d148 2
a149 1
	.burn_screen = odyssey_burner
d697 10
a706 2
void
odyssey_burner(void *v, u_int on, u_int flags)
d708 3
@


1.7
log
@Move OpenGL {logic,raster}ops defines to a separate file, to avoid duplicating
these among frame buffer drivers. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: odyssey.c,v 1.6 2010/04/07 18:16:03 miod Exp $ */
d142 6
a147 10
	odyssey_ioctl,
	odyssey_mmap,
	odyssey_alloc_screen,
	odyssey_free_screen,
	odyssey_show_screen,
	NULL,			/* load_font */
	NULL,			/* scrollback */
	NULL,			/* getchar */
	odyssey_burner,
	NULL			/* pollc */
@


1.6
log
@Correctly initialize cursor attribute when this display is a console device;
tested by marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: odyssey.c,v 1.5 2010/04/06 19:12:34 miod Exp $ */
d25 1
a25 1
 * engineering work undertaken by Stanislaw Skowronek <skylark@@linux-mips.org>. 
d39 1
d122 1
a122 1
/* 
d900 1
a900 1
		
d908 1
a908 1
			
@


1.5
log
@Obtain struct sgi_device_location for the console input and output devices,
and compare against them when attaching potential console drivers, to figure
out whether they indeed are acting are console devices or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: odyssey.c,v 1.4 2010/04/06 19:02:57 miod Exp $ */
a1099 1
	long attr;
d1134 2
a1135 4
	odyssey_consdata.ri.ri_ops.alloc_attr(&odyssey_consdata.ri,
	    0, 0, 0, &attr);
	wsdisplay_cnattach(&odyssey_stdscreen, &odyssey_consdata.ri,
	    0, 0, attr);
@


1.4
log
@Provide WIDGET_ID_FOO() macros to extract parts of the ID register value,
instead of duplicating tedious mask and shift constructs MAXINT times.
@
text
@d1 1
a1 1
/*	$OpenBSD: odyssey.c,v 1.3 2010/03/08 20:54:45 miod Exp $ */
a1072 3
static int16_t odyssey_console_nasid;
static int odyssey_console_widget;

d1074 1
a1074 1
odyssey_cnprobe(int16_t nasid, int widget)
d1079 2
a1080 1
	if (xbow_widget_id(nasid, widget, &wid) != 0)
d1096 1
a1096 1
odyssey_cnattach(int16_t nasid, int widget)
d1109 2
a1110 1
	xbow_build_bus_space(&sc->iot_store, nasid, widget);
a1138 2
	odyssey_console_nasid = nasid;
	odyssey_console_widget = widget;
d1146 2
a1147 2
	return xaa->xaa_nasid == odyssey_console_nasid &&
	    xaa->xaa_widget == odyssey_console_widget;
@


1.3
log
@Correctly initialize all members of struct wsemuldisplaydev_attach_args
before attaching wsdisplay; it was turning out harmless but using more
cpu time for nothing than necessary.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: odyssey.c,v 1.2 2010/03/07 13:44:26 miod Exp $ */
d1085 2
a1086 2
	vendor = (wid & WIDGET_ID_VENDOR_MASK) >> WIDGET_ID_VENDOR_SHIFT;
	product = (wid & WIDGET_ID_PRODUCT_MASK) >> WIDGET_ID_PRODUCT_SHIFT;
@


1.2
log
@Allow iockbc(4) and odysseey(4) to act as console devices and attach early;
this gives us working glass console on Fuel, as well as on Octane systems
with Odyssey graphics.
Joint work with jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: odyssey.c,v 1.1 2010/03/04 14:50:35 jsing Exp $ */
d248 1
@


1.1
log
@Introduce odyssey(4), a driver for the SGI VPro (aka Odyssey) graphics
card, which can be found in Octane, Octane2, Fuel, Tezro and Onyx systems.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d39 3
a43 1
#include <sgi/xbow/odysseyreg.h>
d91 2
d133 3
a201 11
	/*
	 * Setup screen data.
	 */
	sc->curscr = malloc(sizeof(struct odyssey_screen), M_DEVBUF, M_NOWAIT);
	if (sc->curscr == NULL) {
		printf("failed to allocate screen memory!\n");
		return;
	}
	sc->curscr->sc = (void *)sc;
	screen = sc->curscr;

d205 1
a205 1
		printf("failed to map framebuffer bus space!\n");
d209 25
a233 4
	/* Setup hardware and clear screen. */
	odyssey_setup(sc);
	odyssey_fillrect(sc, 0, 0, 1280, 1024, 0x000000);
	odyssey_cmd_flush(sc, 0);
d235 5
a239 5
	/* Set screen defaults. */
	screen->width = 1280;
	screen->height = 1024;
	screen->depth = 32;
	screen->linebytes = screen->width * screen->depth / 8;
d241 2
a242 1
	odyssey_init_screen(screen);
d1066 84
@

