head	1.35;
access;
symbols
	OPENBSD_6_1:1.35.0.12
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.35.0.8
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.4
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.6
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.34.0.10
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.8
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.4
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.2
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.33.0.2
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.14.0.2
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.35
date	2014.09.30.06.51.58;	author jmatthew;	state Exp;
branches;
next	1.34;
commitid	pUEUpP9FlbomZUiI;

1.34
date	2012.09.29.18.54.39;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2012.03.15.18.52.57;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.17.17.44.24;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2011.04.05.14.43.11;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2010.08.23.16.56.18;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2010.04.06.19.02.57;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2010.03.21.13.50.59;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2010.03.06.16.29.46;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.25.11.23.30;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.18.19.05.53;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.07.18.56.55;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.07.14.49.02;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.26.20.14.42;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.26.18.11.27;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.08.19.14.23;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.08.19.13.00;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.08.19.11.59;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.26.19.57.12;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.26.18.48.55;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.22.21.28.44;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.06.22.46.43;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.01.21.56.38;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.27.22.21.31;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.27.16.14.03;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.17.18.20.24;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.13.21.48.03;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.13.16.28.11;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.27.19.06.20;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.02.21.30.13;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.19.12.52.33;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.15.18.45.41;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2009.04.13.21.17.54;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2008.07.30.17.37.46;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.07.22.47.40;	author miod;	state Exp;
branches;
next	;


desc
@@


1.35
log
@implement atomic operations using ll/sc, and convert rw_cas and callers of the
pre-existing atomics to match.

tested on sgi (octane) and octeon (erl)
ok miod@@ dlg@@
@
text
@/*	$OpenBSD: xbow.c,v 1.34 2012/09/29 18:54:39 miod Exp $	*/

/*
 * Copyright (c) 2008, 2009, 2011 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 2004 Opsycon AB  (www.opsycon.se)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 *  XBOW is the mux between two nodes and XIO.
 *
 *  A Crossbow (XBOW) connects two nodeboards via their respective
 *  HUB to up to six different I/O controllers in XIO slots. In a
 *  multiprocessor system all processors have access to the XIO
 *  slots but may need to pass traffic via the routers.
 *
 *  To each XIO port on the XBOW a XIO interface is attached. Such
 *  interfaces can be for example PCI bridges which then add another
 *  level to the hierarchy.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/atomic.h>

#include <mips64/archtype.h>

#include <machine/autoconf.h>
#include <machine/intr.h>
#include <machine/mnode.h>

#include <sgi/xbow/hub.h>
#include <sgi/xbow/widget.h>
#include <sgi/xbow/xbow.h>

#include <sgi/xbow/xbowdevs.h>
#include <sgi/xbow/xbowdevs_data.h>

int	xbowmatch(struct device *, void *, void *);
void	xbowattach(struct device *, struct device *, void *);
int	xbowprint(void *, const char *);
int	xbowsubmatch(struct device *, void *, void *);
int	xbow_attach_widget(struct device *, int16_t, int,
	    int (*)(struct device *, void *, void *), cfprint_t);

int	xbow_kl_search_brd(lboard_t *, void *);
int	xbow_kl_search_mplane(klinfo_t *, void *);

uint32_t xbow_read_4(bus_space_tag_t, bus_space_handle_t, bus_size_t);
uint64_t xbow_read_8(bus_space_tag_t, bus_space_handle_t, bus_size_t);
void	xbow_write_4(bus_space_tag_t, bus_space_handle_t, bus_size_t, uint32_t);
void	xbow_write_8(bus_space_tag_t, bus_space_handle_t, bus_size_t, uint64_t);
void	xbow_read_raw_4(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    uint8_t *, bus_size_t);
void	xbow_write_raw_4(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    const uint8_t *, bus_size_t);
void	xbow_read_raw_8(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    uint8_t *, bus_size_t);
void	xbow_write_raw_8(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    const uint8_t *, bus_size_t);

void	xbow_space_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);
int	xbow_space_region(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    bus_size_t, bus_space_handle_t *);
void	*xbow_space_vaddr(bus_space_tag_t, bus_space_handle_t);
void	 xbow_space_barrier(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    bus_size_t, int);

const struct xbow_product *xbow_identify(uint32_t, uint32_t);

struct	xbow_softc {
	struct device	sc_dev;
	int16_t		sc_nasid;
};

const struct cfattach xbow_ca = {
	sizeof(struct xbow_softc), xbowmatch, xbowattach
};

struct cfdriver xbow_cd = {
	NULL, "xbow", DV_DULL
};

static const bus_space_t xbowbus_tag = {
	(bus_addr_t)0,		/* will be modified in widgets bus_space_t */
	NULL,
	xbow_read_1,
	xbow_write_1,
	xbow_read_2,
	xbow_write_2,
	xbow_read_4,
	xbow_write_4,
	xbow_read_8,
	xbow_write_8,
	xbow_read_raw_2,
	xbow_write_raw_2,
	xbow_read_raw_4,
	xbow_write_raw_4,
	xbow_read_raw_8,
	xbow_write_raw_8,
	xbow_space_map,
	xbow_space_unmap,
	xbow_space_region,
	xbow_space_vaddr,
	xbow_space_barrier
};

/*
 * Function pointers to hide widget discovery and mapping differences accross
 * systems.
 */
paddr_t	(*xbow_widget_base)(int16_t, u_int);
paddr_t	(*xbow_widget_map)(int16_t, u_int, bus_addr_t *, bus_size_t *);

int	(*xbow_widget_id)(int16_t, u_int, uint32_t *);

/*
 * Attachment glue.
 */

int
xbowmatch(struct device *parent, void *match, void *aux)
{
	struct mainbus_attach_args *maa = aux;

	if (strcmp(maa->maa_name, xbow_cd.cd_name) != 0)
		return (0);

	switch (sys_config.system_type) {
	case SGI_IP27:
	case SGI_IP35:
	case SGI_OCTANE:
		return (1);
	default:
		return (0);
	}
}

const struct xbow_product *
xbow_identify(uint32_t vendor, uint32_t product)
{
	const struct xbow_product *p;

	for (p = xbow_products; p->productname != NULL; p++)
		if (p->vendor == vendor && p->product == product)
			return p;

	return NULL;
}

int
xbowprint(void *aux, const char *pnp)
{
	struct xbow_attach_args *xaa = aux;
	const struct xbow_product *p;

	p = xbow_identify(xaa->xaa_vendor, xaa->xaa_product);

	if (pnp != NULL) {
		if (p != NULL)
			printf("\"%s\"", p->productname);
		else
			printf("vendor %x product %x",
			    xaa->xaa_vendor, xaa->xaa_product);
		printf(" revision %d at %s",
		    xaa->xaa_revision, pnp);
	}
	printf(" widget %d", xaa->xaa_widget);
	if (pnp == NULL) {
		if (p != NULL)
			printf(": %s", p->productname);
	}

	return (UNCONF);
}

int
xbowsubmatch(struct device *parent, void *vcf, void *aux)
{
	struct xbow_attach_args *xaa = aux;
	struct cfdata *cf = vcf;

	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != xaa->xaa_widget)
		return 0;
	if (cf->cf_loc[1] != -1 && cf->cf_loc[1] != xaa->xaa_vendor)
		return 0;
	if (cf->cf_loc[2] != -1 && cf->cf_loc[2] != xaa->xaa_product)
		return 0;

	return (*cf->cf_attach->ca_match)(parent, vcf, aux);
}

/*
 * Widget probe order for various components
 */

#ifdef TGT_OCTANE
/* Octane: probe Heart first, then onboard devices, then other slots */
const uint8_t xbow_probe_octane[] =
	{ 0x08, 0x0f, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0 };
#endif
#ifdef TGT_ORIGIN
/* Origin 200: probe onboard devices, and there is nothing more */
const uint8_t xbow_probe_singlebridge[] =
	{ 0x08, 0 };
/* Base I/O board: probe onboard devices, then other slots in ascending order */
const uint8_t xbow_probe_baseio[] =
	{ 0x0f, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0 };
/* I-Brick: probe PCI buses first (starting with the onboard devices) */
const uint8_t xbow_probe_ibrick[] =
	{ 0x0f, 0x0e, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0 };
/* P-Brick: all widgets are PCI buses, probe in recommended order */
const uint8_t xbow_probe_pbrick[] =
	{ 0x09, 0x08, 0x0f, 0x0e, 0x0c, 0x0d, 0x0a, 0x0b, 0 };
/* X-Brick: all widgets are XIO devices, probe in recommended order */
const uint8_t xbow_probe_xbrick[] =
	{ 0x08, 0x09, 0x0c, 0x0d, 0x0a, 0x0b, 0x0e, 0x0f, 0 };
#endif

/*
 * Structures used to carry information between KL and attachment code.
 */

struct xbow_config {
	int	valid;
	int	widgets[WIDGET_MAX + 1 - WIDGET_MIN];
};

struct xbow_kl_config {
	const uint8_t *probe_order;
	struct xbow_config *cfg;
};

void
xbowattach(struct device *parent, struct device *self, void *aux)
{
	struct xbow_softc *sc = (struct xbow_softc *)self;
	struct mainbus_attach_args *maa = aux;
	int16_t nasid = maa->maa_nasid;
	uint32_t wid, vendor, product;
	const struct xbow_product *p;
#ifdef TGT_ORIGIN
	struct xbow_config cfg;
#endif
	struct xbow_kl_config klcfg;
	uint widget;

	sc->sc_nasid = nasid;

	/*
	 * This assumes widget 0 is the XBow itself (or an XXBow).
	 * If it isn't - feel free to haunt my bedroom at night.
	 */
	if (xbow_widget_id(nasid, 0, &wid) != 0)
		panic("no xbow");
	vendor = WIDGET_ID_VENDOR(wid);
	product = WIDGET_ID_PRODUCT(wid);
	p = xbow_identify(vendor, product);
	if (p == NULL)
		printf(": unknown xbow (vendor %x product %x)",
		    vendor, product);
	else
		printf(": %s", p->productname);
	printf(" revision %d\n", WIDGET_ID_REV(wid));

	switch (sys_config.system_type) {
	default:
#ifdef TGT_ORIGIN
		memset(&cfg, 0, sizeof cfg);
		klcfg.cfg = &cfg;

		/*
		 * If widget 0 reports itself as a bridge, this is not a
		 * complete XBow, but only a limited topology. This is
		 * found on at least the Origin 200.
		 */
		if (vendor == XBOW_VENDOR_SGI4 &&
		    product == XBOW_PRODUCT_SGI4_BRIDGE) {
			klcfg.probe_order = xbow_probe_singlebridge;
		} else {
			/*
			 * Get crossbow information from the KL configuration.
			 */
			klcfg.probe_order = NULL;
			kl_scan_node(nasid, KLBRD_ANY, xbow_kl_search_brd,
			    &klcfg);
			if (klcfg.probe_order == NULL)
				klcfg.probe_order = xbow_probe_baseio;

			/* should not happen, but I can't help being paranoid */
			if (cfg.valid == 0) {
				printf("%s: no hub\n", self->dv_xname);
				return;
			}
		}
		break;
#endif
#ifdef TGT_OCTANE
	case SGI_OCTANE:
		klcfg.probe_order = xbow_probe_octane;
		break;
#endif
	}

	for (; *klcfg.probe_order != 0; klcfg.probe_order++) {
		widget = *klcfg.probe_order;
#ifdef TGT_ORIGIN
		if (cfg.valid != 0 &&
		    !ISSET(cfg.widgets[widget - WIDGET_MIN], XBOW_PORT_ENABLE))
			continue;
#endif
		(void)xbow_attach_widget(self, nasid, widget, xbowsubmatch,
		    xbowprint);
	}
}

int
xbow_attach_widget(struct device *self, int16_t nasid, int widget,
    int (*sm)(struct device *, void *, void *), cfprint_t print)
{
	struct xbow_attach_args xaa;
	uint32_t wid;
	struct mips_bus_space bs;
	int rc;

	if ((rc = xbow_widget_id(nasid, widget, &wid)) != 0)
		return rc;

	/*
	 * Build a bus_space_t suitable for this widget.
	 */
	xbow_build_bus_space(&bs, nasid, widget);

	xaa.xaa_nasid = nasid;
	xaa.xaa_widget = widget;
	xaa.xaa_vendor = WIDGET_ID_VENDOR(wid);
	xaa.xaa_product = WIDGET_ID_PRODUCT(wid);
	xaa.xaa_revision = WIDGET_ID_REV(wid);
	xaa.xaa_iot = &bs;

	if (config_found_sm(self, &xaa, print, sm) == NULL)
		return ENOENT;

	return 0;
}

#ifdef TGT_ORIGIN

/*
 * These two functions try to figure out the configuration of the XBow
 * on this node.
 *
 * We are looking for two pieces of information:
 * - the Hub widget, to which memory is attached and interrupts are routed.
 * - what kind of Brick we are.
 *
 * The first information can be obtained easily by looking for a MPLANE type
 * board. However there is no easy way to figure the second part, except for
 * checking what kind of boards are reported.
 *
 * A BaseIO board will report itself once, as a single widget. Bricks, on the
 * other hand, appear for each of the widgets they provide.
 */

int
xbow_kl_search_brd(lboard_t *brd, void *arg)
{
	struct xbow_kl_config *cfg = arg;

	switch (brd->brd_type & IP27_BC_MASK) {
	case IP27_BC_MPLANE:
		if (cfg->cfg->valid == 0)
			kl_scan_board(brd, KLSTRUCT_XBOW, xbow_kl_search_mplane,
			    cfg->cfg);
		break;
	case IP27_BC_IO:
		if (cfg->probe_order == NULL)
			cfg->probe_order = xbow_probe_baseio;
		break;
	case IP27_BC_BRICK:
		if (cfg->probe_order == NULL)
			switch (brd->brd_type) {
			case IP27_BRD_IBRICK:
			case IP27_BRD_IXBRICK:
				cfg->probe_order = xbow_probe_ibrick;
				break;
			case IP27_BRD_PBRICK:
			case IP27_BRD_PXBRICK:
				cfg->probe_order = xbow_probe_pbrick;
				break;
			case IP27_BRD_XBRICK:
				cfg->probe_order = xbow_probe_xbrick;
				break;
			default:
				/* other brick */
				break;
			}
		break;
	}

	if (cfg->cfg->valid != 0 && cfg->probe_order != NULL)
		return 1;	/* stop enumeration */

	return 0;
}

int
xbow_kl_search_mplane(klinfo_t *c, void *arg)
{
	klxbow_t *xbow = (klxbow_t *)c;
	struct xbow_config *cfg = arg;
	uint w;

	cfg->valid = 1;
	for (w = WIDGET_MIN; w <= WIDGET_MAX; w++)
		cfg->widgets[w - WIDGET_MIN] =
		    xbow->xbow_port_info[w - WIDGET_MIN].port_flag;

	return 1;
}

#endif

/*
 * Bus access primitives.
 */

void
xbow_build_bus_space(struct mips_bus_space *bs, int nasid, int widget)
{
	bcopy(&xbowbus_tag, bs, sizeof (*bs));
	bs->bus_base = (*xbow_widget_base)(nasid, widget);
}

uint8_t
xbow_read_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
{
	return *(volatile uint8_t *)(h + o);
}

uint16_t
xbow_read_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
{
	return *(volatile uint16_t *)(h + o);
}

uint32_t
xbow_read_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
{
	return *(volatile uint32_t *)(h + o);
}

uint64_t
xbow_read_8(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
{
	return *(volatile uint64_t *)(h + o);
}

void
xbow_write_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o, uint8_t v)
{
	*(volatile uint8_t *)(h + o) = v;
}

void
xbow_write_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o, uint16_t v)
{
	*(volatile uint16_t *)(h + o) = v;
}

void
xbow_write_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o, uint32_t v)
{
	*(volatile uint32_t *)(h + o) = v;
}

void
xbow_write_8(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o, uint64_t v)
{
	*(volatile uint64_t *)(h + o) = v;
}

void
xbow_read_raw_2(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    uint8_t *buf, bus_size_t len)
{
	volatile uint16_t *addr = (volatile uint16_t *)(h + o);
	len >>= 1;
	while (len-- != 0) {
		*(uint16_t *)buf = *addr;
		buf += 2;
	}
}

void
xbow_write_raw_2(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    const uint8_t *buf, bus_size_t len)
{
	volatile uint16_t *addr = (volatile uint16_t *)(h + o);
	len >>= 1;
	while (len-- != 0) {
		*addr = *(uint16_t *)buf;
		buf += 2;
	}
}

void
xbow_read_raw_4(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    uint8_t *buf, bus_size_t len)
{
	volatile uint32_t *addr = (volatile uint32_t *)(h + o);
	len >>= 2;
	while (len-- != 0) {
		*(uint32_t *)buf = *addr;
		buf += 4;
	}
}

void
xbow_write_raw_4(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    const uint8_t *buf, bus_size_t len)
{
	volatile uint32_t *addr = (volatile uint32_t *)(h + o);
	len >>= 2;
	while (len-- != 0) {
		*addr = *(uint32_t *)buf;
		buf += 4;
	}
}

void
xbow_read_raw_8(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    uint8_t *buf, bus_size_t len)
{
	volatile uint64_t *addr = (volatile uint64_t *)(h + o);
	len >>= 3;
	while (len-- != 0) {
		*(uint64_t *)buf = *addr;
		buf += 8;
	}
}

void
xbow_write_raw_8(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    const uint8_t *buf, bus_size_t len)
{
	volatile uint64_t *addr = (volatile uint64_t *)(h + o);
	len >>= 3;
	while (len-- != 0) {
		*addr = *(uint64_t *)buf;
		buf += 8;
	}
}

int
xbow_space_map(bus_space_tag_t t, bus_addr_t offs, bus_size_t size,
    int flags, bus_space_handle_t *bshp)
{
	bus_addr_t bpa;

	bpa = t->bus_base + offs;

#ifdef DIAGNOSTIC
	/* check that this does not overflow the window */
	if (((bpa + size - 1) >> 24) != (t->bus_base >> 24))
		return (EINVAL);
#endif

	*bshp = bpa;
	return 0;
}

void
xbow_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size)
{
}

int
xbow_space_region(bus_space_tag_t t, bus_space_handle_t bsh,
    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp)
{
#ifdef DIAGNOSTIC
	bus_addr_t bpa;

	bpa = (bus_addr_t)bsh - t->bus_base;
	/* check that this does not overflow the window */
	if (((bpa + offset) >> 24) != (t->bus_base >> 24))
		return (EINVAL);
#endif

	*nbshp = bsh + offset;
	return 0;
}

void *
xbow_space_vaddr(bus_space_tag_t t, bus_space_handle_t h)
{
	return (void *)h;
}

void
xbow_space_barrier(bus_space_tag_t t, bus_space_handle_t h, bus_size_t offs,
    bus_size_t len, int flags)
{
	mips_sync();
}

/*
 * Interrupt handling code.
 *
 * Interrupt handling should be done at the Heart/Hub driver level, we only
 * act as a proxy here.
 *
 * Note that, for the time being, interrupt handling is implicitly done at
 * the master nasid; other nodes do not handle interrupts.
 */

uint64_t xbow_intr_address;

int	(*xbow_intr_widget_intr_register)(int, int, int *) = NULL;
int	(*xbow_intr_widget_intr_establish)(int (*)(void *), void *, int, int,
	    const char *, struct intrhand *) = NULL;
void	(*xbow_intr_widget_intr_disestablish)(int) = NULL;
void	(*xbow_intr_widget_intr_set)(int) = NULL;
void	(*xbow_intr_widget_intr_clear)(int) = NULL;

int
xbow_intr_register(int widget, int level, int *intrbit)
{
	if (xbow_intr_widget_intr_register == NULL)
		return EINVAL;

	return (*xbow_intr_widget_intr_register)(widget, level, intrbit);
}

int
xbow_intr_establish(int (*func)(void *), void *arg, int intrbit, int level,
    const char *name, struct intrhand *ihstore)
{
	if (xbow_intr_widget_intr_establish == NULL)
		return EINVAL;

	return (*xbow_intr_widget_intr_establish)(func, arg, intrbit, level,
	    name, ihstore);
}

void
xbow_intr_disestablish(int intrbit)
{
	if (xbow_intr_widget_intr_disestablish == NULL)
		return;

	(*xbow_intr_widget_intr_disestablish)(intrbit);
}

void
xbow_intr_clear(int intrbit)
{
	if (xbow_intr_widget_intr_clear == NULL)
		return;

	(*xbow_intr_widget_intr_clear)(intrbit);
}

void
xbow_intr_set(int intrbit)
{
	if (xbow_intr_widget_intr_set == NULL)
		return;

	(*xbow_intr_widget_intr_set)(intrbit);
}

/*
 * Widget mapping code.
 */

paddr_t
xbow_widget_map_space(struct device *dev, u_int widget, bus_addr_t *offs,
    bus_size_t *len)
{
	struct xbow_softc *sc = (struct xbow_softc *)dev;

	if (xbow_widget_map == NULL)
		return 0UL;

	return (*xbow_widget_map)(sc->sc_nasid, widget, offs, len);
}
@


1.34
log
@Proide a mips_sync() macro to wrap asm("sync"), and replace gazillions of
such statements with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.33 2012/03/15 18:52:57 miod Exp $	*/
d63 1
a66 1
#include <machine/atomic.h>
@


1.33
log
@No longer allow bus_space_barrier() to be a NULL pointer on a given
bus_space_tag on sgi, but rather always provide at least a dummy asm("sync")
flavour. Saves a function pointer test at runtime.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.32 2011/04/17 17:44:24 miod Exp $	*/
d644 1
a644 1
	__asm__ __volatile__ ("sync" ::: "memory");
@


1.32
log
@On IP27 systems, fill the array of node hub widget numbers early, so that all
hubs are known during autoconf. Then, pick the most populated 2GB window
as our DMA memory window. xbridge(4) can thus program the correct settings
regardless of the order in which the xbow(4) attach.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.31 2011/04/05 14:43:11 miod Exp $	*/
d105 2
d144 1
a144 1
	NULL
d638 7
@


1.31
log
@Rename a few xbow global variable names to make them less ambiguous.
Remember the hub widget number of each node, instead of only the master node.
Use this in xbridge to compute the proper direct DMA map configuration
register value (it needs to embed the hub widget number matching the
physical address range).
This should allow us to pick memory from a different node than the one
we booted from, as the DMA window, if wanted.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.30 2010/08/23 16:56:18 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 2008, 2009 Miodrag Vallat.
d234 1
d238 2
d255 1
a262 1
	int	master;
d279 1
d281 1
a302 1
	memset(&cfg, 0, sizeof cfg);
d304 1
a304 3
	case SGI_OCTANE:
		klcfg.probe_order = xbow_probe_octane;
		break;
d306 1
a306 1
	default:
a307 1
		klcfg.probe_order = NULL;
a315 5
			/*
			 * Interrupt widget is hardwired to #a (this is another
			 * facet of this bridge).
			 */
			xbow_node_hub_widget[nasid] = 0x0a;
d321 1
d324 2
d327 5
a331 9
			if (cfg.valid == 0)
				panic("no hub");

			/*
			 * This widget number is actually the Hub part of the
			 * crossbow, and is where memory and interrupt logic
			 * resources are connected to.
			 */
			xbow_node_hub_widget[nasid] = cfg.master;
d335 5
a341 2
	if (klcfg.probe_order == NULL)
		klcfg.probe_order = xbow_probe_baseio;
d344 1
d348 1
a451 1
	cfg->master = xbow->xbow_hub_master_link;
a647 1
int	xbow_node_hub_widget[XBOW_MAX];
@


1.30
log
@Implement bus_space_barrier() on sgi; on xbridge, this will also flush
the pci write buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.29 2010/04/06 19:02:57 miod Exp $	*/
a304 11
		/*
		 * Default value for the interrupt register.
		 */
		if (xbow_intr_widget_register == 0)
			xbow_intr_widget_register =
			    (1UL << 47) /* XIO I/O space */ |
			    (nasid <<
			      (sys_config.system_type == SGI_IP35 ? 39 : 38)) |
			    ((paddr_t)IP27_RHUB_ADDR(0, HUBPI_IR_CHANGE) -
			     IP27_NODE_IO_BASE(0)) /* HUB register offset */;

d319 1
a319 2
			if (xbow_intr_widget == 0)
				xbow_intr_widget = 0x0a;
d336 1
a336 2
			if (xbow_intr_widget == 0)
				xbow_intr_widget = cfg.master;
d649 3
a651 2
int	xbow_intr_widget = 0;
paddr_t	xbow_intr_widget_register;
@


1.29
log
@Provide WIDGET_ID_FOO() macros to extract parts of the ID register value,
instead of duplicating tedious mask and shift constructs MAXINT times.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.28 2010/03/21 13:50:59 miod Exp $	*/
d140 3
a142 2
	xbow_space_region

@


1.28
log
@Fix widget probe order for BASEIO boards and P-Brick.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.27 2010/03/06 16:29:46 jsing Exp $	*/
d287 2
a288 2
	vendor = (wid & WIDGET_ID_VENDOR_MASK) >> WIDGET_ID_VENDOR_SHIFT;
	product = (wid & WIDGET_ID_PRODUCT_MASK) >> WIDGET_ID_PRODUCT_SHIFT;
d295 1
a295 2
	printf(" revision %d\n",
	    (wid & WIDGET_ID_REV_MASK) >> WIDGET_ID_REV_SHIFT);
d385 3
a387 5
	xaa.xaa_vendor = (wid & WIDGET_ID_VENDOR_MASK) >>
	    WIDGET_ID_VENDOR_SHIFT;
	xaa.xaa_product = (wid & WIDGET_ID_PRODUCT_MASK) >>
	    WIDGET_ID_PRODUCT_SHIFT;
	xaa.xaa_revision = (wid & WIDGET_ID_REV_MASK) >> WIDGET_ID_REV_SHIFT;
@


1.27
log
@Fix typos.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.25 2009/11/18 19:05:53 miod Exp $	*/
d239 1
a239 1
/* Base I/O board: probe in ascending order */
d241 1
a241 1
	{ 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0 };
d247 1
a247 1
	{ 0x09, 0x08, 0x0f, 0x0e, 0x0d, 0x0c, 0x0a, 0x0b, 0 };
@


1.26
log
@Allow xbow_intr_establish() callers to provide optional storage for the
struct intrhand, instead of having it malloc()'ed.
@
text
@d47 1
a47 1
 *  A Crossbow (XBOW) connects two nodeboards via their respecive
d53 1
a53 1
 *  interfaces can be for example PCI bridges wich then add another
@


1.25
log
@Move widget register information apart from xbow software interface, and
update #include needs. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.24 2009/11/07 18:56:55 miod Exp $	*/
d668 1
a668 1
	    const char *) = NULL;
d684 1
a684 1
    const char *name)
d690 1
a690 1
	    name);
@


1.24
log
@Replace option TGT_ORIGIN200 and TGT_ORIGIN2000 with a single option,
TGT_ORIGIN, which enables support for all IP27 and IP35 systems. The original
two options have always been used together, and go back to when pefo thought
supporting multiple nodes would be significant work. Since an Origin 200
can be a dual-node system, making a distinction between single node and
multiple node systems is a moot point anyway.

Be sure to rerun config(8) before rebuilding a kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.23 2009/11/07 14:49:02 miod Exp $	*/
d72 1
d74 1
d145 1
a145 1
 * Function pointers to hide widget window mapping differences accross
d253 1
a253 1
 * Structures used to carry information between KL and atatchment code.
@


1.23
log
@Change sgi system identification from a single system type list, to a smaller
system type list (which really is the system family) and a subsystem type.

No functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.22 2009/10/26 20:14:42 miod Exp $	*/
d301 1
a301 1
#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
d397 1
a397 1
#if defined(TGT_ORIGIN200) || defined(TGT_ORIGIN2000)
@


1.22
log
@Rename struct confargs to struct mainbus_attach_args for consistency and also
to prevent further abuse of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.21 2009/10/26 18:11:27 miod Exp $	*/
d164 2
a165 2
	case SGI_O200:
	case SGI_O300:
d310 1
a310 1
			      (sys_config.system_type == SGI_O300 ? 39 : 38)) |
@


1.21
log
@Add new xbow routines to explicitely trigger or clear an interrupt source,
instead of embedding that knowledge in xbridge(4); will be used elsewhere
shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.20 2009/10/08 19:14:23 miod Exp $	*/
d158 1
a158 1
	struct confargs *ca = aux;
d160 1
a160 1
	if (strcmp(ca->ca_name, xbow_cd.cd_name) != 0)
d269 2
a270 2
	struct confargs *ca = aux;
	int16_t nasid = ca->ca_nasid;
@


1.20
log
@Program the widget interrupt address register as a whole 64 bit register
instead of two 32 bit halves, as the supposedly `upper 32 bits' register
ignores writes; makes interrupt on PIC route correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.19 2009/10/08 19:13:00 miod Exp $	*/
d657 3
d668 2
d698 18
@


1.19
log
@Recognize the Bedrock as an XBow instead of reporting it as ``unknown
xbow''; while there report vendor and product id of unknow xbow chips.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.18 2009/10/08 19:11:59 miod Exp $	*/
d309 3
a311 1
			    ((paddr_t)IP27_RHUB_ADDR(nasid, HUBPI_IR_CHANGE) -
@


1.18
log
@Recognize more brick types and probe fooX bricks in the same order as
foo bricks (they differ by having PCI-X bridges instead of PCI bridges
but are otherwise built the same)
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.17 2009/07/26 19:57:12 miod Exp $	*/
d288 6
a293 2
	printf(": %s revision %d\n",
	    p != NULL ? p->productname : "unknown xbow",
@


1.17
log
@Make the bus_space boundary checks #ifdef DIAGNOSTIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.16 2009/07/26 18:48:55 miod Exp $	*/
d428 1
d432 1
d439 1
a439 1
				/* unknown brick */
@


1.16
log
@Make sure all platforms understand the flags argument of bus_space_map() and
bus_space_alloc() as a bitmask of flags, and not a boolean controlling
cacheability; and make sure the three MI BUS_SPACE_MAP_xxx values documented
in the manual page are defined on all platforms as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.15 2009/07/22 21:28:44 miod Exp $	*/
d606 1
d610 1
d625 9
@


1.15
log
@Get rid of bus_space_tag_t now unused bus_extent and bus_reverse fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.14 2009/07/06 22:46:43 miod Exp $	*/
d600 1
a600 1
    int cacheable, bus_space_handle_t *bshp)
@


1.14
log
@Almost rewrite xbridge PCI resource allocation:
- introduce an interface for widget drivers to ask the xbow to map arbitrary
  views of their address space, in addition to the low 16MB. This operation
  may fail or map a subset range of what the caller asked for, depending on
  the platform we're running on.
- use this in xbridge to set up views on the direct memory and i/o spaces,
  to map devices resources when they don't fit in one of the devio small
  ranges (limited to 2MB anyway). These views are only allocated when
  devio can't do the job, so as not to consume too many resources on
  Origin family systems where such views are scarce resources (and
  shared accross the whole crossbow).

This makes pci devices with large resource needs configure correctly.

While there, fix programming of 64 bit memory BAR; this makes bge(4)
work.

Tested on Octane (with Bridge revision < 4 and >= 4), Origin 200 (Bridge >= 4)
and Fuel (XBridge).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.13 2009/07/01 21:56:38 miod Exp $	*/
a119 1
	NULL,
a121 1
	0,
@


1.13
log
@The widget mapping code has been written back when I was only working on
Octane support. The Octane being a single-node system, address space is
ludicrous enough to allow the whole address space of every widget to be
directly accessible in whole, using the address bits reserved to nasid.

However, on IP27 and IP35, things do not work this way - while we still have
the low 16MB address space of each widget available (the so-called
``short window''), access to other parts of the wiget address space is done
through translation slots (IOTTE) at the Hub I/O space level, on a per-node
basis.

Given the imminent release lock, give up completely on ``large'' mappings
of widgets, and restrict ourselves to short window operation, all the time
(thus reinforcing the use of devio registers to map pci resources on xbridge).
A proper interface to request mappings of specific widget areas, either
directly on Octane, or through IOTTE if available on Origin, will appear
post-release.

No functional change (except from silently repairing Octane support which the
previous xbridge commit silently broke).
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.12 2009/06/27 22:21:31 miod Exp $	*/
d106 5
d112 1
a112 1
	sizeof(struct device), xbowmatch, xbowattach
d149 1
d270 1
d279 2
d676 16
@


1.12
log
@In the bus_space_*_raw_* functions, move the invariant computations out of
the loop. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.11 2009/06/27 16:14:03 miod Exp $	*/
a89 4
void	xbow_read_raw_2(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    uint8_t *, bus_size_t);
void	xbow_write_raw_2(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    const uint8_t *, bus_size_t);
a98 2
int	xbow_space_map_long(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
d100 1
a100 3
int	xbow_space_region_short(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    bus_size_t, bus_space_handle_t *);
int	xbow_space_region_long(bus_space_tag_t, bus_space_handle_t, bus_size_t,
d114 1
a114 26
static const bus_space_t xbowbus_short_tag = {
	NULL,
	(bus_addr_t)0,		/* will be modified in widgets bus_space_t */
	NULL,
	0,
	xbow_read_1,
	xbow_write_1,
	xbow_read_2,
	xbow_write_2,
	xbow_read_4,
	xbow_write_4,
	xbow_read_8,
	xbow_write_8,
	xbow_read_raw_2,
	xbow_write_raw_2,
	xbow_read_raw_4,
	xbow_write_raw_4,
	xbow_read_raw_8,
	xbow_write_raw_8,
	xbow_space_map_short,
	xbow_space_unmap,
	xbow_space_region_short

};

static const bus_space_t xbowbus_long_tag = {
d133 1
a133 1
	xbow_space_map_long,
d135 1
a135 1
	xbow_space_region_long
d143 1
a143 3
paddr_t	(*xbow_widget_short)(int16_t, u_int);
paddr_t	(*xbow_widget_long)(int16_t, u_int);
unsigned int xbow_long_shift = 29;
d358 1
a358 1
	struct mips_bus_space *bs, *bl;
d365 1
a365 1
	 * Build a pair of bus_space_t suitable for this widget.
d367 1
a367 11
	bs = malloc(sizeof (*bs), M_DEVBUF, M_NOWAIT);
	if (bs == NULL)
		return ENOMEM;
	bl = malloc(sizeof (*bl), M_DEVBUF, M_NOWAIT);
	if (bl == NULL) {
		free(bs, M_DEVBUF);
		return ENOMEM;
	}

	xbow_build_bus_space(bs, nasid, widget, 0);
	xbow_build_bus_space(bl, nasid, widget, 1);
d376 1
a376 7
	xaa.xaa_short_tag = bs;
	xaa.xaa_long_tag = bl;

	if (config_found_sm(self, &xaa, print, sm) == NULL) {
		/* nothing attached, no need to keep the bus_space */
		free(bs, M_DEVBUF);
		free(bl, M_DEVBUF);
d378 1
a379 1
	}
d465 1
a465 1
xbow_build_bus_space(struct mips_bus_space *bs, int nasid, int widget, int lwin)
d467 2
a468 7
	if (lwin) {
		bcopy(&xbowbus_long_tag, bs, sizeof (*bs));
		bs->bus_base = (*xbow_widget_long)(nasid, widget);
	} else {
		bcopy(&xbowbus_short_tag, bs, sizeof (*bs));
		bs->bus_base = (*xbow_widget_short)(nasid, widget);
	}
d592 1
a592 1
xbow_space_map_short(bus_space_tag_t t, bus_addr_t offs, bus_size_t size,
a606 17
int
xbow_space_map_long(bus_space_tag_t t, bus_addr_t offs, bus_size_t size,
    int cacheable, bus_space_handle_t *bshp)
{
	bus_addr_t bpa;

	bpa = t->bus_base + offs;

	/* check that this does not overflow the window */
	if (((bpa + size - 1) >> xbow_long_shift) !=
	    (t->bus_base >> xbow_long_shift))
		return (EINVAL);

	*bshp = bpa;
	return 0;
}

d613 1
a613 13
xbow_space_region_short(bus_space_tag_t t, bus_space_handle_t bsh,
    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp)
{
	/* check that this does not overflow the window */
	if (((bsh + offset) >> 24) != (bsh >> 24))
		return (EINVAL);

	*nbshp = bsh + offset;
	return 0;
}

int
xbow_space_region_long(bus_space_tag_t t, bus_space_handle_t bsh,
a615 4
	/* check that this does not overflow the window */
	if (((bsh + offset) >> xbow_long_shift) != (bsh >> xbow_long_shift))
		return (EINVAL);

@


1.11
log
@Add an explicit widget locator to xbow children; allows a given widget to
be disabled with some UKC tinkering.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.10 2009/06/17 18:20:24 miod Exp $	*/
d579 1
d582 1
a582 1
		*(uint16_t *)buf = *(volatile uint16_t *)(h + o);
d591 1
d594 1
a594 1
		*(volatile uint16_t *)(h + o) = *(uint16_t *)buf;
d603 1
d606 1
a606 1
		*(uint32_t *)buf = *(volatile uint32_t *)(h + o);
d615 1
d618 1
a618 1
		*(volatile uint32_t *)(h + o) = *(uint32_t *)buf;
d627 1
d630 1
a630 1
		*(uint64_t *)buf = *(volatile uint64_t *)(h + o);
d639 1
d642 1
a642 1
		*(volatile uint64_t *)(h + o) = *(uint64_t *)buf;
@


1.10
log
@Make sure xbowmatch() only matches on xbow stanzas.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.9 2009/06/13 21:48:03 miod Exp $	*/
d248 1
a248 1
	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != xaa->xaa_vendor)
d250 3
a252 1
	if (cf->cf_loc[1] != -1 && cf->cf_loc[1] != xaa->xaa_product)
@


1.9
log
@Enumerate all available nodes for hardware on IP27/IP35 systems; works to some
extent, but isp(4) on other nodes do not work correctly yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.8 2009/06/13 16:28:11 miod Exp $	*/
d189 5
d233 1
a233 1
	printf(" nasid %d widget %d", xaa->xaa_nasid, xaa->xaa_widget);
d265 1
a265 1
	{ 0x08 };
@


1.8
log
@Shuffle and rename HUB defines for consistency, no functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.7 2009/05/27 19:06:20 miod Exp $	*/
d228 1
a228 1
	printf(" widget %d", xaa->xaa_widget);
d292 2
a293 1
	int16_t nasid = 0;	/* XXX for now... */
d323 5
a327 3
		xbow_intr_widget_register = (1UL << 47) /* XIO I/O space */ |
		    ((paddr_t)IP27_RHUB_ADDR(nasid, HUBPI_IR_CHANGE) -
		     IP27_NODE_IO_BASE(0)) /* HUB register offset */;
d343 2
a344 1
			xbow_intr_widget = 0x0a;
d361 2
a362 1
			xbow_intr_widget = cfg.master;
d407 1
@


1.7
log
@Use the KL enumeration functions to try and figure out what kind of XBow
we have, in order to pick a widget enumeration order matching the PROM.

This is especially important when the boot path is in dksc() syntax.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.6 2009/05/02 21:30:13 miod Exp $	*/
d323 1
a323 1
		    ((paddr_t)IP27_RHUB_ADDR(nasid, HUB_IR_CHANGE) -
@


1.6
log
@More progress taming the xbow and the pci bridge; still needs code to write,
but (currently commented out) code makes isp happier on IP27 and IP35, to the
point of seeing disks (but considering them offline so far).
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.5 2009/04/19 12:52:33 miod Exp $	*/
d78 2
a79 4
int	xbowprint_pass1(void *, const char *);
int	xbowprint_pass2(void *, const char *);
int	xbowsubmatch_pass1(struct device *, void *, void *);
int	xbowsubmatch_pass2(struct device *, void *, void *);
d82 3
a84 2
void	xbow_enumerate(struct device *, int16_t, int,
	    int (*)(struct device *, void *, void *), cfprint_t);
d212 1
a212 18
xbowprint_pass1(void *aux, const char *pnp)
{
	struct xbow_attach_args *xaa = aux;
	const struct xbow_product *p;

	p = xbow_identify(xaa->xaa_vendor, xaa->xaa_product);

	if (pnp == NULL) {
		printf(" widget %d", xaa->xaa_widget);
		if (p != NULL)
			printf(": %s", p->productname);
	}

	return (QUIET);
}

int
xbowprint_pass2(void *aux, const char *pnp)
d238 1
a238 16
xbowsubmatch_pass1(struct device *parent, void *vcf, void *aux)
{
	int rc;

	if (xbow_intr_widget != 0)
		return 0;

	rc = xbowsubmatch_pass2(parent, vcf, aux);
	if (rc < 20)
		rc = 0;

	return rc;
}

int
xbowsubmatch_pass2(struct device *parent, void *vcf, void *aux)
d251 38
d295 3
d312 7
a318 14
	/*
	 * Default value for the interrupt register. If this system
	 * has a Heart widget, the Heart code will take care of changing it.
	 */
	xbow_intr_widget_register = (1UL << 47) /* XIO I/O space */ |
	    ((paddr_t)IP27_RHUB_ADDR(nasid, HUB_IR_CHANGE) -
	     IP27_NODE_IO_BASE(0)) /* HUB register offset */;

	/*
	 * If widget 0 reports itself as a bridge, this is not a
	 * complete XBow, but only a limited topology. This is
	 * found on at least the Origin 200.
	 */
	if (vendor == XBOW_VENDOR_SGI4 && product == XBOW_PRODUCT_SGI4_BRIDGE) {
d320 1
a320 2
		 * Interrupt widget is hardwired to #a (this is another
		 * facet of this bridge).
d322 6
a327 1
		xbow_intr_widget = 0x0a;
a328 3
		xbow_attach_widget(self, nasid, WIDGET_MIN,
		    xbowsubmatch_pass2, xbowprint_pass2);
	} else {
d330 3
a332 7
		 * XXX This widget number is actually the Hub part of the
		 * XXX crossbow, and is where memory and interrupt logic
		 * XXX resources are connected to.
		 * XXX The exact widget number ought to be computed from
		 * XXX the KL configuration graph; I'm hardcoding it for
		 * XXX now because I am lazy and we only care about the
		 * XXX first node at the moment. -- miod
d334 6
a339 1
		if (sys_config.system_type != SGI_OCTANE)
d341 20
a360 12

		/*
		 * Enumerate the other widgets.
		 * We'll do two passes - one to give the first Heart or a Hub a
		 * chance to setup interrupt routing, and one to attach all
		 * other widgets.
		 */
		if (xbow_intr_widget == 0)
			xbow_enumerate(self, nasid, 0,
			    xbowsubmatch_pass1, xbowprint_pass1);
		xbow_enumerate(self, nasid, xbow_intr_widget,
		    xbowsubmatch_pass2, xbowprint_pass2);
a361 7
}

void
xbow_enumerate(struct device *self, int16_t nasid, int skip,
    int (*sm)(struct device *, void *, void *), cfprint_t print)
{
	int widget;
d363 6
a368 2
	for (widget = WIDGET_MIN; widget <= WIDGET_MAX; widget++) {
		if (widget == skip)
d370 2
a371 2

		(void)xbow_attach_widget(self, nasid, widget, sm, print);
d422 75
@


1.5
log
@Add heuristics to tell IP27 and IP35 apart, as they will need to be handled
differently at times.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.4 2009/04/15 18:45:41 miod Exp $	*/
d310 1
a310 1
	     IP27_NODE_IO_BASE(nasid)) /* HUB register offset */;
d319 2
a320 2
		 * Interrupt widget is #a (this is another facet of this
		 * bridge).
d328 12
d345 3
a347 2
		xbow_enumerate(self, nasid, 0,
		    xbowsubmatch_pass1, xbowprint_pass1);
@


1.4
log
@Change the way the widget interrupt register is computed and have it become
a complete physical address. Also add proper cpu pa<->device pa for dma
on Origin 200.

This lets xbridge work and route interrupts correctly on Origin 200.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.3 2009/04/13 21:17:54 miod Exp $	*/
d192 1
d305 8
d315 1
a315 1
	 * found on the Origin 200 (but probably not on the Origin 2000).
a322 3
		xbow_intr_widget_register = (1UL << 47) /* XIO I/O space */ |
		    ((paddr_t)IP27_RHUB_ADDR(nasid, HUB_IR_CHANGE) -
		     IP27_NODE_IO_BASE(nasid)) /* HUB register offset */;
@


1.3
log
@The start of Origin 200 support. Based on some code contributed by pefo@@
some years ago for KL enumeration, building on the existing XBow support
to limit ourselves to a single node for now.

This is a work-in-progress; it currently lacks complete interrupt code,
as well as PCI resource management. And there are likely bugs creeping
inside.
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.2 2008/07/30 17:37:46 miod Exp $	*/
d69 1
d71 1
d126 1
a126 1
	(bus_addr_t)0,
d151 1
a151 1
	(bus_addr_t)0,
d308 1
a308 2
	if (vendor == XBOW_VENDOR_SGI4 &&
	    product == XBOW_PRODUCT_SGI4_BRIDGE) {
d314 3
a316 1
		xbow_intr_widget_register = 0x90;
d602 1
a602 1
unsigned int xbow_intr_widget_register = 0;
@


1.2
log
@Implement bus_space_{read,write}_raw_mult_[248] correctly, it needs
endianness conversion on pci bridges.
ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xbow.c,v 1.1 2008/04/07 22:47:40 miod Exp $	*/
d4 1
a4 1
 * Copyright (c) 2008 Miodrag Vallat.
d80 3
a82 1
void	xbow_enumerate(struct device *, int,
a101 2
int	xbow_space_map_short(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
d302 3
a304 4
	 * Enumerate the other widgets.
	 * We'll do two passes - one to give the first Heart or a Hub a
	 * chance to setup interrupt routing, and one to attach all other
	 * widgets.
d306 23
a328 3
	xbow_enumerate(self, 0, xbowsubmatch_pass1, xbowprint_pass1);
	xbow_enumerate(self, xbow_intr_widget, xbowsubmatch_pass2,
	    xbowprint_pass2);
d332 1
a332 1
xbow_enumerate(struct device *self, int skip,
a334 2
	int16_t nasid = 0;	/* XXX for now... */
	struct xbow_attach_args xaa;
a335 4
	uint32_t wid;

	for (widget = 8; widget <= 15; widget++) {
		struct mips_bus_space *bs, *bl;
d337 1
d341 27
a367 2
		if (xbow_widget_id(nasid, widget, &wid) != 0)
			continue;
d369 2
a370 11
		/*
		 * Build a pair of bus_space_t suitable for this widget.
		 */
		bs = malloc(sizeof (*bs), M_DEVBUF, M_NOWAIT);
		if (bs == NULL)
			continue;
		bl = malloc(sizeof (*bl), M_DEVBUF, M_NOWAIT);
		if (bl == NULL) {
			free(bs, M_DEVBUF);
			continue;
		}
d372 13
a384 2
		xbow_build_bus_space(bs, nasid, widget, 0);
		xbow_build_bus_space(bl, nasid, widget, 1);
d386 1
a386 15
		xaa.xaa_widget = widget;
		xaa.xaa_vendor = (wid & WIDGET_ID_VENDOR_MASK) >>
		    WIDGET_ID_VENDOR_SHIFT;
		xaa.xaa_product = (wid & WIDGET_ID_PRODUCT_MASK) >>
		    WIDGET_ID_PRODUCT_SHIFT;
		xaa.xaa_revision = (wid & WIDGET_ID_REV_MASK) >>
		    WIDGET_ID_REV_SHIFT;
		xaa.xaa_short_tag = bs;
		xaa.xaa_long_tag = bl;

		if (config_found_sm(self, &xaa, print, sm) == NULL) {
			/* nothing attached, no need to keep the bus_space */
			free(bs, M_DEVBUF);
			free(bl, M_DEVBUF);
		}
d388 2
@


1.1
log
@A first cut at XBow bus support, very minimal, limited to a local bus only;
HUB driver (for IP27) is a stub, and interrupt support is a shoot in the dark
and will need some serious debugging until it is sane, but I want to reduce
the weight of these diffs first.

Based on a lot of tinkering and experiments, as well as knowledge extracted
from the Linux source code.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d85 15
a99 4
void	xbow_write_4(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    uint32_t);
void	xbow_write_8(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    uint64_t);
d134 6
d159 6
d426 66
@

