head	1.15;
access;
symbols
	OPENBSD_6_1:1.13.0.12
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.8
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.4
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9;
locks; strict;
comment	@ * @;


1.15
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.14;
commitid	2Gtqjzrin9LL2yHk;

1.14
date	2017.04.30.13.04.49;	author mpi;	state Exp;
branches;
next	1.13;
commitid	xDPbcPU6tYP39nZG;

1.13
date	2014.12.07.13.12.05;	author miod;	state Exp;
branches;
next	1.12;
commitid	k03Dl7FZBF2Lkuyz;

1.12
date	2014.05.19.21.18.42;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2013.10.21.12.14.51;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2012.09.29.18.54.39;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2012.05.12.16.47.44;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2012.04.29.09.01.38;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2012.04.29.08.59.12;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2012.04.18.11.30.01;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2012.04.15.20.40.39;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2012.04.05.21.48.37;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2012.04.01.16.37.08;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2012.03.31.20.20.32;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2012.03.28.20.44.23;	author miod;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@/*	$OpenBSD: zs.c,v 1.14 2017/04/30 13:04:49 mpi Exp $	*/
/*	$NetBSD: zs.c,v 1.37 2011/02/20 07:59:50 matt Exp $	*/

/*-
 * Copyright (c) 1996, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Gordon W. Ross and Wayne Knowles
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Zilog Z8530 Dual UART driver (machine-dependent part)
 *
 * Runs two serial lines per chip using slave drivers.
 * Plain tty/async lines use the zstty slave.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/time.h>
#include <sys/syslog.h>

#include <mips64/archtype.h>
#include <mips64/arcbios.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/z8530var.h>

#include <dev/cons.h>

#include <dev/ic/z8530reg.h>

#include <sgi/hpc/hpcvar.h>
#include <sgi/hpc/hpcreg.h>

/*
 * Some warts needed by z8530tty.c -
 * The default parity REALLY needs to be the same as the PROM uses,
 * or you can not see messages done with printf during boot-up...
 */
int zs_def_cflag = (CREAD | CS8 | HUPCL);
int zs_major = 19;

#define PCLK		3672000	 /* PCLK pin input clock rate */

#ifndef ZS_DEFSPEED
#define ZS_DEFSPEED	9600
#endif

/*
 * Define interrupt levels.
 */
#define ZSHARD_PRI 64

/* SGI shouldn't need ZS_DELAY() as recovery time is done in hardware? */
#define ZS_DELAY()	delay(2)

/* The layout of this is hardware-dependent (padding, order). */
struct zschan {
	uint8_t pad1[3];
	volatile uint8_t zc_csr;	/* ctrl,status, and indirect access */
	uint8_t pad2[3];
	volatile uint8_t zc_data;	/* data */
};

struct zsdevice {
	struct	zschan zs_chan_b;
	struct	zschan zs_chan_a;
};

/* Return the byte offset of element within a structure */
#define OFFSET(struct_def, el)		((size_t)&((struct_def *)0)->el)

#define ZS_CHAN_A	OFFSET(struct zsdevice, zs_chan_a)
#define ZS_CHAN_B	OFFSET(struct zsdevice, zs_chan_b)
#define ZS_REG_CSR	3
#define ZS_REG_DATA	7
static int zs_chan_offset[] = {ZS_CHAN_A, ZS_CHAN_B};

cons_decl(zs);
struct consdev zs_cn = {
	zscnprobe,
	zscninit,
	zscngetc,
	zscnputc,
	zscnpollc,
	NULL
};


/* Flags from cninit() */
static int zs_consunit = -1;
static int zs_conschan = -1;

/* Default speed for all channels */
static int zs_defspeed = ZS_DEFSPEED;

static uint8_t zs_init_reg[17] = {
	0,				/* 0: CMD (reset, etc.) */
	0,				/* 1: No interrupts yet. */
	ZSHARD_PRI,			/* 2: IVECT */
	ZSWR3_RX_8 | ZSWR3_RX_ENABLE,
	ZSWR4_CLK_X16 | ZSWR4_ONESB,
	ZSWR5_TX_8 | ZSWR5_TX_ENABLE,
	0,				/* 6: TXSYNC/SYNCLO */
	0,				/* 7: RXSYNC/SYNCHI */
	0,				/* 8: alias for data port */
	ZSWR9_MASTER_IE,
	0,				/*10: Misc. TX/RX control bits */
	ZSWR11_TXCLK_BAUD | ZSWR11_RXCLK_BAUD | ZSWR11_TRXC_OUT_ENA,
	BPS_TO_TCONST(PCLK/16, ZS_DEFSPEED), /*12: BAUDLO (default=9600) */
	0,				/*13: BAUDHI (default=9600) */
	ZSWR14_BAUD_ENA,
	ZSWR15_BREAK_IE,
	ZSWR7P_TX_FIFO			/* 7': TX FIFO interrupt level */
};


/****************************************************************
 * Autoconfig
 ****************************************************************/

/* Definition of the driver for autoconfig. */
int	zs_hpc_match(struct device *, void *, void *);
void	zs_hpc_attach(struct device *, struct device *, void *);
int	zs_print(void *, const char *name);

struct cfdriver zs_cd = {
	NULL, "zs", DV_TTY
};

struct cfattach zs_hpc_ca = {
	sizeof(struct zsc_softc), zs_hpc_match, zs_hpc_attach
};

int		 zshard(void *);
void		 zssoft(void *);
struct zschan	*zs_get_chan_addr(int, int);
int		 zs_getc(void *);
void		 zs_putc(void *, int);

/*
 * Is the zs chip present?
 */
int
zs_hpc_match(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = vcf;
	struct hpc_attach_args *ha = aux;

	if (strcmp(ha->ha_name, cf->cf_driver->cd_name) == 0)
		return (1);

	return (0);
}

/*
 * Attach a found zs.
 *
 * Match slave number to zs unit number, so that misconfiguration will
 * not set up the keyboard as ttya, etc.
 */
void
zs_hpc_attach(struct device *parent, struct device *self, void *aux)
{
	struct zsc_softc *zsc = (void *)self;
	struct cfdata *cf = self->dv_cfdata;
	struct hpc_attach_args *haa = aux;
	struct zsc_attach_args zsc_args;
	struct zs_chanstate *cs;
	struct zs_channel *ch;
	int zs_unit, channel, err, s;
	int has_fifo;

	zsc->zsc_bustag = haa->ha_st;
	if ((err = bus_space_subregion(haa->ha_st, haa->ha_sh,
				       haa->ha_devoff, 0x10,
				       &zsc->zsc_base)) != 0) {
		printf(": unable to map 85c30 registers, error = %d\n",
		    err);
		return;
	}

	zs_unit = zsc->zsc_dev.dv_unit;

	/*
	 * Initialize software state for each channel.
	 *
	 * Done in reverse order of channels since the first serial port
	 * is actually attached to the *second* channel, and vice versa.
	 * Doing it this way should force a 'zstty*' to attach zstty0 to
	 * channel 1 and zstty1 to channel 0.  They couldn't have wired
	 * it up in a more sensible fashion, could they?
	 */
	for (channel = 1; channel >= 0; channel--) {
		zsc_args.channel = channel;
		ch = &zsc->zsc_cs_store[channel];
		cs = zsc->zsc_cs[channel] = (struct zs_chanstate *)ch;

		/*
		 * According to IRIX <sys/z8530.h>, on Indigo, the CTR, DCD,
		 * DTR and RTS bits are inverted.
		 *
		 * That is, inverted when compared to the Indy and Indigo 2
		 * designs. However, it turns out that the Indigo wiring is
		 * the `natural' one, with these pins being inverted from
		 * what one would naively expect, on the other designs.
		 *
		 * Choose wiring logic according to the hardware we run on,
		 * and the device flags.
		 */
		if (sys_config.system_type != SGI_IP20)
			ch->cs_flags |= ZSCFL_INVERT_WIRING;
		if (cf->cf_flags & ZSCFL_INVERT_WIRING)
			ch->cs_flags ^= ZSCFL_INVERT_WIRING;

		cs->cs_reg_csr = NULL;
		cs->cs_reg_data = NULL;
		cs->cs_channel = channel;
		cs->cs_private = NULL;
		cs->cs_ops = &zsops_null;
		cs->cs_brg_clk = PCLK / 16;

		if (bus_space_subregion(zsc->zsc_bustag, zsc->zsc_base,
					zs_chan_offset[channel],
					sizeof(struct zschan),
					&ch->cs_regs) != 0) {
			printf(": cannot map regs\n");
			return;
		}
		ch->cs_bustag = zsc->zsc_bustag;

		/*
		 * Figure out whether this chip is a 8530 or a 85230.
		 */
		if (channel == 1) {
			zs_write_reg(cs, 15, ZSWR15_ENABLE_ENHANCED);
			has_fifo = zs_read_reg(cs, 15) & ZSWR15_ENABLE_ENHANCED;

			if (has_fifo) {
				zs_write_reg(cs, 15, 0);
				printf(": 85230\n");
			} else
				printf(": 8530\n");
		}

		if (has_fifo)
			zs_init_reg[15] |= ZSWR15_ENABLE_ENHANCED;
		else
			zs_init_reg[15] &= ~ZSWR15_ENABLE_ENHANCED;
		memcpy(cs->cs_creg, zs_init_reg, 17);
		memcpy(cs->cs_preg, zs_init_reg, 17);

		/* If console, don't stomp speed, let zstty know */
		if (zs_unit == zs_consunit && channel == zs_conschan) {
			zsc_args.consdev = &zs_cn;
			zsc_args.hwflags = ZS_HWFLAG_CONSOLE;
			cs->cs_defspeed = bios_consrate;
		} else {
			zsc_args.consdev = NULL;
			zsc_args.hwflags = 0;
			cs->cs_defspeed = zs_defspeed;
		}

		cs->cs_defcflag = zs_def_cflag;

		/* Make these correspond to cs_defcflag (-crtscts) */
		cs->cs_rr0_dcd = ZSRR0_DCD;
		cs->cs_rr0_cts = 0;
		cs->cs_wr5_dtr = ZSWR5_DTR | ZSWR5_RTS;
		cs->cs_wr5_rts = 0;

		/*
		 * Clear the master interrupt enable.
		 * The INTENA is common to both channels,
		 * so just do it on the A channel.
		 */
		if (channel == 0) {
			zs_write_reg(cs, 9, 0);
		}
		/*
		 * Look for a child driver for this channel.
		 * The child attach will setup the hardware.
		 */
		if (!config_found(self, (void *)&zsc_args, zs_print)) {
			/* No sub-driver.  Just reset it. */
			uint8_t reset = (channel == 0) ?
				ZSWR9_A_RESET : ZSWR9_B_RESET;

			s = splhigh();
			zs_write_reg(cs, 9, reset);
			splx(s);
		}
	}


	zsc->sc_si = softintr_establish(IPL_SOFTTTY, zssoft, zsc);
	hpc_intr_establish(haa->ha_irq, IPL_TTY, zshard, zsc, self->dv_xname);

	/*
	 * Set the master interrupt enable and interrupt vector.
	 * (common to both channels, do it on A)
	 */
	cs = zsc->zsc_cs[0];
	s = splhigh();
	/* interrupt vector */
	zs_write_reg(cs, 2, zs_init_reg[2]);
	/* master interrupt control (enable) */
	zs_write_reg(cs, 9, zs_init_reg[9]);
	splx(s);
}

int
zs_print(void *aux, const char *name)
{
	struct zsc_attach_args *args = aux;

	if (name != NULL)
		printf("%s:", name);

	if (args->channel != -1)
		printf(" channel %d", args->channel);

	return UNCONF;
}

/*
 * Our ZS chips all share a common, autovectored interrupt,
 * so we have to look at all of them on each interrupt.
 */
int
zshard(void *arg)
{
	struct zsc_softc *zsc = arg;
	int rval;

	rval = zsc_intr_hard(zsc);
	if (rval != 0) {
		if (zsc->zsc_cs[0]->cs_softreq ||
		    zsc->zsc_cs[1]->cs_softreq)
			softintr_schedule(zsc->sc_si);
	}

	return rval;
}

/*
 * Similar scheme as for zshard (look at all of them)
 */
void
zssoft(void *arg)
{
	struct zsc_softc *zsc = arg;
	int s;

	/* Make sure we call the tty layer at spltty. */
	s = spltty();
	(void)zsc_intr_soft(zsc);
	splx(s);
}


/*
 * MD functions for setting the baud rate and control modes.
 */
int
zs_set_speed(struct zs_chanstate *cs, int bps)
{
	int tconst, real_bps;

	if (bps == 0)
		return (0);

#ifdef	DIAGNOSTIC
	if (cs->cs_brg_clk == 0)
		panic("zs_set_speed");
#endif

	tconst = BPS_TO_TCONST(cs->cs_brg_clk, bps);
	if (tconst < 0)
		return (EINVAL);

	/* Convert back to make sure we can do it. */
	real_bps = TCONST_TO_BPS(cs->cs_brg_clk, tconst);

#if 0	/* PCLK is too small, 9600bps really yields 9562 */
	/* XXX - Allow some tolerance here? */
	if (real_bps != bps)
		return (EINVAL);
#endif

	cs->cs_preg[12] = tconst;
	cs->cs_preg[13] = tconst >> 8;

	/* Caller will stuff the pending registers. */
	return (0);
}

int
zs_set_modes(struct zs_chanstate *cs, int cflag)
{
	int s;

	/*
	 * Output hardware flow control on the chip is horrendous:
	 * if carrier detect drops, the receiver is disabled, and if
	 * CTS drops, the transmitter is stoped IN MID CHARACTER!
	 * Therefore, NEVER set the HFC bit, and instead use the
	 * status interrupt to detect CTS changes.
	 */
	s = splzs();
	cs->cs_rr0_pps = 0;
	if ((cflag & (CLOCAL | MDMBUF)) != 0) {
		cs->cs_rr0_dcd = 0;
		if ((cflag & MDMBUF) == 0)
			cs->cs_rr0_pps = ZSRR0_DCD;
	} else
		cs->cs_rr0_dcd = ZSRR0_DCD;
	if ((cflag & CRTSCTS) != 0) {
		cs->cs_wr5_dtr = ZSWR5_DTR;
		cs->cs_wr5_rts = ZSWR5_RTS;
		cs->cs_rr0_cts = ZSRR0_CTS;
	} else if ((cflag & MDMBUF) != 0) {
		cs->cs_wr5_dtr = 0;
		cs->cs_wr5_rts = ZSWR5_DTR;
		cs->cs_rr0_cts = ZSRR0_DCD;
	} else {
		cs->cs_wr5_dtr = ZSWR5_DTR | ZSWR5_RTS;
		cs->cs_wr5_rts = 0;
		cs->cs_rr0_cts = 0;
	}
	splx(s);

	/* Caller will stuff the pending registers. */
	return (0);
}


/*
 * Read or write the chip with suitable delays.
 */

uint8_t
zs_read_reg(struct zs_chanstate *cs, uint8_t reg)
{
	uint8_t val;
	struct zs_channel *zsc = (struct zs_channel *)cs;

	bus_space_write_1(zsc->cs_bustag, zsc->cs_regs, ZS_REG_CSR, reg);
	bus_space_barrier(zsc->cs_bustag, zsc->cs_regs, ZS_REG_CSR, 1,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
	ZS_DELAY();
	val = bus_space_read_1(zsc->cs_bustag, zsc->cs_regs, ZS_REG_CSR);
	ZS_DELAY();

	if ((zsc->cs_flags & ZSCFL_INVERT_WIRING) && reg == 0)
		val ^= ZSRR0_CTS | ZSRR0_DCD;

	return val;
}

void
zs_write_reg(struct zs_chanstate *cs, uint8_t reg, uint8_t val)
{
	struct zs_channel *zsc = (struct zs_channel *)cs;

	if ((zsc->cs_flags & ZSCFL_INVERT_WIRING) && reg == 5)
		val ^= ZSWR5_DTR | ZSWR5_RTS;

	bus_space_write_1(zsc->cs_bustag, zsc->cs_regs, ZS_REG_CSR, reg);
	bus_space_barrier(zsc->cs_bustag, zsc->cs_regs, ZS_REG_CSR, 1,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
	ZS_DELAY();
	bus_space_write_1(zsc->cs_bustag, zsc->cs_regs, ZS_REG_CSR, val);
	bus_space_barrier(zsc->cs_bustag, zsc->cs_regs, ZS_REG_CSR, 1,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
	ZS_DELAY();
}

uint8_t
zs_read_csr(struct zs_chanstate *cs)
{
	struct zs_channel *zsc = (struct zs_channel *)cs;
	uint8_t val;

	val = bus_space_read_1(zsc->cs_bustag, zsc->cs_regs, ZS_REG_CSR);
	ZS_DELAY();

	if (zsc->cs_flags & ZSCFL_INVERT_WIRING)
		val ^= ZSRR0_CTS | ZSRR0_DCD;

	return val;
}

void
zs_write_csr(struct zs_chanstate *cs, uint8_t val)
{
	struct zs_channel *zsc = (struct zs_channel *)cs;

	bus_space_write_1(zsc->cs_bustag, zsc->cs_regs, ZS_REG_CSR, val);
	bus_space_barrier(zsc->cs_bustag, zsc->cs_regs, ZS_REG_CSR, 1,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
	ZS_DELAY();
}

uint8_t
zs_read_data(struct zs_chanstate *cs)
{
	struct zs_channel *zsc = (struct zs_channel *)cs;
	uint8_t val;

	val = bus_space_read_1(zsc->cs_bustag, zsc->cs_regs, ZS_REG_DATA);
	ZS_DELAY();
	return val;
}

void
zs_write_data(struct zs_chanstate *cs, uint8_t val)
{
	struct zs_channel *zsc = (struct zs_channel *)cs;

	bus_space_write_1(zsc->cs_bustag, zsc->cs_regs, ZS_REG_DATA, val);
	bus_space_barrier(zsc->cs_bustag, zsc->cs_regs, ZS_REG_DATA, 1,
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);
	ZS_DELAY();
}

void
zs_abort(struct zs_chanstate *cs)
{
#if defined(DDB)
	db_enter();
#endif
}


/*****************************************************/
/*  Polled character I/O functions for console KGDB  */
/*****************************************************/

struct zschan *
zs_get_chan_addr(int zs_unit, int channel)
{
#if 0
	static int dumped_addr = 0;
#endif
	struct zsdevice *addr = NULL;
	struct zschan *zc;

	switch (sys_config.system_type) {
	case SGI_IP20:
		switch (zs_unit) {
		case 0:
			addr = (struct zsdevice *)
			    PHYS_TO_XKPHYS(0x1fb80d00, CCA_NC);
			break;
		case 1:
			addr = (struct zsdevice *)
			    PHYS_TO_XKPHYS(0x1fb80d10, CCA_NC);
			break;
		}
		break;

	case SGI_IP22:
	case SGI_IP26:
	case SGI_IP28:
		if (zs_unit == 0)
			addr = (struct zsdevice *)
			    PHYS_TO_XKPHYS(0x1fbd9830, CCA_NC);
		break;
	}
	if (addr == NULL)
		panic("zs_get_chan_addr: bad zs_unit %d\n", zs_unit);

	/*
	 * We need to swap serial ports to match reality on
	 * non-keyboard channels.
	 */
	if (sys_config.system_type != SGI_IP20) {
		if (channel == 0)
			zc = &addr->zs_chan_b;
		else
			zc = &addr->zs_chan_a;
	} else {
		if (zs_unit == 0) {
			if (channel == 0)
				zc = &addr->zs_chan_a;
			else
				zc = &addr->zs_chan_b;
		} else {
			if (channel == 0)
				zc = &addr->zs_chan_b;
			else
				zc = &addr->zs_chan_a;
		}
	}

#if 0
	if (dumped_addr == 0) {
		dumped_addr++;
		printf("zs unit %d, channel %d had address %p\n",
		    zs_unit, channel, zc);
	}
#endif

	return (zc);
}

int
zs_getc(void *arg)
{
	register volatile struct zschan *zc = arg;
	register int s, c, rr0;

	s = splzs();
	/* Wait for a character to arrive. */
	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while ((rr0 & ZSRR0_RX_READY) == 0);

	c = zc->zc_data;
	ZS_DELAY();
	splx(s);

	return (c);
}

/*
 * Polled output char.
 */
void
zs_putc(void *arg, int c)
{
	register volatile struct zschan *zc = arg;
	register int s, rr0;

	s = splzs();
	/* Wait for transmitter to become ready. */
	do {
		rr0 = zc->zc_csr;
		ZS_DELAY();
	} while ((rr0 & ZSRR0_TX_READY) == 0);

	zc->zc_data = c;

	/* inline bus_space_barrier() */
	mips_sync();
	if (sys_config.system_type != SGI_IP20) {
		(void)*(volatile uint32_t *)PHYS_TO_XKPHYS(HPC_BASE_ADDRESS_0 +
		    HPC3_INTRSTAT_40, CCA_NC);
	}

	ZS_DELAY();
	splx(s);
}

/***************************************************************/

static int  cons_port;

void
zscnprobe(struct consdev *cp)
{
	cp->cn_dev = makedev(zs_major, 0);
	cp->cn_pri = CN_DEAD;

	switch (sys_config.system_type) {
	case SGI_IP20:
	case SGI_IP22:
	case SGI_IP26:
	case SGI_IP28:
		if (strlen(bios_console) == 9 &&
		    strncmp(bios_console, "serial", 6) == 0)
			cp->cn_pri = CN_FORCED;
		else
			cp->cn_pri = CN_MIDPRI;
		break;
	}
}

void
zscninit(struct consdev *cn)
{
	if (strlen(bios_console) == 9 &&
	    strncmp(bios_console, "serial", 6) != 0)
		cons_port = bios_console[7] - '0';

	/* Mark this unit as the console */
	zs_consunit = 0;

	/* SGI hardware wires serial port 1 to channel B, port 2 to A */
	if (cons_port == 0)
		zs_conschan = 1;
	else
		zs_conschan = 0;
}

int
zscngetc(dev_t dev)
{
	struct zschan *zs;

	switch (sys_config.system_type) {
	case SGI_IP20:
		zs = zs_get_chan_addr(1, cons_port);
		break;
	case SGI_IP22:
	case SGI_IP26:
	case SGI_IP28:
	default:
		zs = zs_get_chan_addr(0, cons_port);
		break;
	}

	return zs_getc(zs);
}

void
zscnputc(dev_t dev, int c)
{
	struct zschan *zs;

	switch (sys_config.system_type) {
	case SGI_IP20:
		zs = zs_get_chan_addr(1, cons_port);
		break;
	case SGI_IP22:
	case SGI_IP26:
	case SGI_IP28:
	default:
		zs = zs_get_chan_addr(0, cons_port);
		break;
	}

	zs_putc(zs, c);
}

void
zscnpollc(dev_t dev, int on)
{
}
@


1.14
log
@Unifdef KGDB.

It doesn't compile und hasn't been working during the last decade.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.13 2014/12/07 13:12:05 miod Exp $	*/
d562 1
a562 1
	Debugger();
@


1.13
log
@Avoid extra space in dmesg
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.12 2014/05/19 21:18:42 miod Exp $	*/
d561 1
a561 3
#if defined(KGDB)
	zskgdb(cs);
#elif defined(DDB)
d567 3
a569 3
/*********************************************************/
/*  Polled character I/O functions for console and KGDB  */
/*********************************************************/
@


1.12
log
@Format string fixes and removal of -Wno-format for sgi. Based upon an
initial diff from jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.11 2013/10/21 12:14:51 miod Exp $	*/
d349 1
a349 1
		printf("%s: ", name);
@


1.11
log
@Fix lies in comments, and apply some KNF and unused or duplicate prototype
removals.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.10 2012/09/29 18:54:39 miod Exp $	*/
d258 1
a258 1
			printf(": cannot map regs\n", self->dv_xname);
@


1.10
log
@Proide a mips_sync() macro to wrap asm("sync"), and replace gazillions of
such statements with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.9 2012/05/12 16:47:44 miod Exp $	*/
d37 1
a37 1
 * Plain tty/async lines use the zs_async slave.
@


1.9
log
@It turns out that, when the IRIX header files mention CTR/DCD/DTR/RTS wiring
is inverted on Indigo, this just means that Indigo does not use the same
values as the later models. It does not mean that the Indigo is using wrong
values, which is how I first read this. In reality, Indigo systems use the
expected values of these signals being active low, while later designs
use active high signals.

So yes, some systems have inverted values - but the ones which need
compensating are not those I thought.

Change the logic to do TRT, but keep the device flags check, to be able to
force the other behaviour if the kernel guesses wrongly. Tested on Indigo,
Indy and Indigo 2.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.8 2012/04/29 09:01:38 miod Exp $	*/
d680 1
a680 1
	__asm__ __volatile__ ("sync" ::: "memory");
@


1.8
log
@Recognize 85230 chips, and take advantage of their FIFOs to reduce the
amount of TX empty interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.7 2012/04/29 08:59:12 miod Exp $	*/
d230 16
a245 3
		/* pick Indigo wiring if requested */
		if (cf->cf_flags & ZSCFL_INDIGO_WIRING)
			ch->cs_flags |= ZSCFL_INDIGO_WIRING;
d486 1
a486 5
	/*
	 * According to IRIX <sys/z8530.h>, on Indigo, the CTS and DCD bits
	 * are inverted.
	 */
	if ((zsc->cs_flags & ZSCFL_INDIGO_WIRING) && reg == 0)
d497 1
a497 5
	/*
	 * According to IRIX <sys/z8530.h>, on Indigo, the RTS and DTR bits
	 * are inverted.
	 */
	if ((zsc->cs_flags & ZSCFL_INDIGO_WIRING) && reg == 5)
d519 1
a519 5
	/*
	 * According to IRIX <sys/z8530.h>, on Indigo, the CTS and DCD bits
	 * are inverted.
	 */
	if (zsc->cs_flags & ZSCFL_INDIGO_WIRING)
@


1.7
log
@I am not sure what the mess with the wiring of carrier lines on Indigo resolves
to, so make this controllable with device flags, and default to non-bogus
wiring.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.6 2012/04/18 11:30:01 miod Exp $	*/
d128 1
a128 1
static uint8_t zs_init_reg[16] = {
d145 1
d202 2
a203 1
	int    zs_unit, channel, err, s;
a214 1
	printf("\n");
d245 1
a245 1
			printf("%s: cannot map regs\n", self->dv_xname);
d250 20
a269 2
		memcpy(cs->cs_creg, zs_init_reg, 16);
		memcpy(cs->cs_preg, zs_init_reg, 16);
d552 1
a552 1
	bus_space_barrier(zsc->cs_bustag, zsc->cs_regs, ZS_REG_CSR, 1,
@


1.6
log
@One more routine needed to cope for CTS and DCD being inverted on IP20.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.5 2012/04/15 20:40:39 miod Exp $	*/
d196 1
d229 4
d458 1
a458 1
	if (sys_config.system_type == SGI_IP20 && reg == 0)
d473 1
a473 1
	if (sys_config.system_type == SGI_IP20 && reg == 5)
d499 1
a499 1
	if (sys_config.system_type == SGI_IP20)
@


1.5
log
@Provide an hpc_intr_establish() function for hpc subdevices, so they don't
need to have knowledge of the underlying interrupt controller. No functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.4 2012/04/05 21:48:37 miod Exp $	*/
d489 8
@


1.4
log
@Lower ZS_DELAY() back to what it was, but issue a bus_space_barrier() after
every register write. Hinted by IRIX' <sys/z8530.h>.

While there, flip the CTS, DCD, RTS and DTR bits in registers #0 and #5.
Aforementioned header says they are inverted due to a hardware bug.

Tested on IP20, IP22 and IP24.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.3 2012/04/01 16:37:08 miod Exp $	*/
a64 1
#include <sgi/localbus/intvar.h>
d291 1
a291 1
	int2_intr_establish(haa->ha_irq, IPL_TTY, zshard, zsc, self->dv_xname);
@


1.3
log
@Increase delay between chip register accesses. Fixes the console freeze during
install seen on IP22 and IP24.
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.2 2012/03/31 20:20:32 miod Exp $	*/
d87 1
a87 1
#define ZS_DELAY()	delay(5)
d444 2
d449 8
d465 7
d473 2
d477 2
d499 2
d521 2
d646 8
a653 1
	__asm__ __volatile__ ("sync" ::: "memory"); /* wbflush(); */
@


1.2
log
@softintr_establish() takes IPL_xxx, not SI_xxx (harmless here since they turned
out to be the same value).
@
text
@d1 1
a1 1
/*	$OpenBSD: zs.c,v 1.1 2012/03/28 20:44:23 miod Exp $	*/
d87 1
a87 1
#define ZS_DELAY()	delay(3)
d329 1
a329 1
	int rr3, rval;
d331 5
a335 3
	rval = 0;
	while ((rr3 = zsc_intr_hard(zsc))) {
		rval |= rr3;
a337 4
	if (zsc->zsc_cs[0]->cs_softreq ||
	    zsc->zsc_cs[1]->cs_softreq)
		softintr_schedule(zsc->sc_si);

d352 1
a352 1
	(void) zsc_intr_soft(zsc);
@


1.1
log
@Work in progress support for the SGI Indigo, Indigo 2 and Indy systems
(IP20, IP22, IP24) in 64-bit mode, adapated from NetBSD. Currently limited
to headless operation, input and video drivers will get ported soon.

Should work on all R4000, R4440 and R5000 based systems. L2 cache on R5000SC
Indy not supported yet (coming soon), R4600 not supported yet either (coming
soon as well).

Tested to boot multiuser on: Indigo2 R4000SC, Indy R4000PC, Indy R4000SC,
Indy R5000SC, Indigo2 R4400SC. There are still glitches in the Ethernet driver
which are being looked at.

Expansion support is limited to the GIO E++ board; GIO boards with PCI-GIO
bridges not ported yet due to the lack of hardware, and this kind of driver
does not port blindly.

Most of this work comes from NetBSD, polishing and integration work, as well
as putting as many ``R4x00 in 64-bit mode'' erratas as necessary, by yours
truly.

More work is coming, as well as trying to get some easy way to boot install
kernels (as older PROM can only boot ECOFF binaries, which won't do for the
kernel).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d291 1
a291 1
	zsc->sc_si = softintr_establish(SI_SOFTTTY, zssoft, zsc);
@

