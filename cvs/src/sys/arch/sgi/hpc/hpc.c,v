head	1.18;
access;
symbols
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.8
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.4
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.16.0.10
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.4
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13;
locks; strict;
comment	@ * @;


1.18
date	2015.09.18.20.50.02;	author miod;	state Exp;
branches;
next	1.17;
commitid	WbAU9whMk9BmFUgM;

1.17
date	2015.09.05.21.13.24;	author miod;	state Exp;
branches;
next	1.16;
commitid	1Tj9UMvH0jts1O49;

1.16
date	2013.09.28.14.00.00;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2012.09.29.19.24.31;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2012.09.29.18.54.38;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2012.05.27.14.27.08;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2012.05.17.19.38.59;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2012.04.30.21.31.03;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2012.04.30.21.30.33;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2012.04.17.15.22.02;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2012.04.15.20.50.32;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2012.04.15.20.40.39;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2012.04.15.20.38.10;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2012.04.08.22.08.25;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2012.04.05.21.46.43;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2012.04.05.21.45.51;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2012.04.03.21.17.35;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2012.03.28.20.44.23;	author miod;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Go back to the previous approach when managing individual HPC DMA descriptors:
provide again an optional storage for a copy of the descriptor in the `sync'
(fetch) function, and use the returned address afterwards.

On IP22 systems (in the broader sense of the term, thus IP20/IP22/IP24),
descriptors will remain in uncached memory and no local copies need to be made.
On IP28 systems, descriptors will remain in cached memory (so as to avoid
switching to `slow mode'), but a local copy will be performed with the necessary
cache eviction work, so that speculative code execution on R10000 will not
touch the real descriptor.

With this in place, all the explicit descriptor cache operations in if_sq,
some of them being redundant or operating on the wrong number of
descriptors, can be removed, with the HPC DMA wrappers taking care of doing
the right thing.

Tested on IP22 and IP28. IP26 still unhappy but no worse than before.
@
text
@/*	$OpenBSD: hpc.c,v 1.17 2015/09/05 21:13:24 miod Exp $	*/
/*	$NetBSD: hpc.c,v 1.66 2011/07/01 18:53:46 dyoung Exp $	*/
/*	$NetBSD: ioc.c,v 1.9 2011/07/01 18:53:47 dyoung Exp $	 */

/*
 * Copyright (c) 2003 Christopher Sekiya
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *          This product includes software developed for the
 *          NetBSD Project.  See http://www.NetBSD.org/ for
 *          information about NetBSD.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 2000 Soren S. Jorvang
 * Copyright (c) 2001 Rafal K. Boni
 * Copyright (c) 2001 Jason R. Thorpe
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *          This product includes software developed for the
 *          NetBSD Project.  See http://www.NetBSD.org/ for
 *          information about NetBSD.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Combined driver for the HPC (High performance Peripheral Controller)
 * and IOC2 (I/O Controller) chips.
 *
 * It would theoretically be better to attach an IOC driver to HPC on
 * IOC systems (IP22/24/26/28), and attach the few onboard devices
 * which attach directly to HPC on IP20, to IOC. But since IOC depends
 * too much on HPC, the complexity this would introduce is not worth
 * the hassle.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/timeout.h>

#include <mips64/archtype.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <mips64/cache.h>
#include <machine/cpu.h>

#include <sgi/gio/gioreg.h>
#include <sgi/gio/giovar.h>

#include <sgi/hpc/hpcreg.h>
#include <sgi/hpc/hpcvar.h>
#include <sgi/localbus/imcvar.h>
#include <sgi/localbus/intreg.h>
#include <sgi/localbus/intvar.h>
#include <sgi/hpc/iocreg.h>
#include <sgi/sgi/ip22.h>

#include <dev/ic/smc93cx6var.h>

struct hpc_device {
	const char *hd_name;
	bus_addr_t hd_base;
	bus_addr_t hd_devoff;
	bus_addr_t hd_dmaoff;
	int hd_irq;
	int hd_sysmask;
};

#define	HPCDEV_IP20		(1U << 1)	/* Indigo R4k */
#define	HPCDEV_IP22		(1U << 2)	/* Indigo2 */
#define	HPCDEV_IP24		(1U << 3)	/* Indy, Challenge S */
#define	HPCDEV_IP24_INDY	(1U << 4)	/* Indy only */

/*
 * On-board HPC1 devices (IP20 only)
 */
static const struct hpc_device hpc1_onboard[] = {
	/* probe order is important for IP20 zs */
	{ "zs",		/* serial 0/1 duart 1 */
	  HPC_BASE_ADDRESS_0,
	  0x0d10, 0,
	  INT2_L0_INTR(INT2_L0_IP20_SERIAL),
	  HPCDEV_IP20 },
	{ "zs",		/* kbd/ms duart 0 */
	  HPC_BASE_ADDRESS_0,
	  0x0d00, 0,
	  INT2_L0_INTR(INT2_L0_IP20_SERIAL),
	  HPCDEV_IP20 },
	{ "sq",		/* onboard Ethernet */
	  HPC_BASE_ADDRESS_0,
	  HPC1_ENET_DEVREGS, HPC1_ENET_REGS,
	  INT2_L0_INTR(INT2_L0_ENET),
	  HPCDEV_IP20 },
	{ "wdsc",	/* onboard SCSI */
	  HPC_BASE_ADDRESS_0,
	  HPC1_SCSI0_DEVREGS, HPC1_SCSI0_REGS,
	  INT2_L0_INTR(INT2_L0_SCSI1),
	  HPCDEV_IP20 },
	{ NULL }
};

/*
 * On-board HPC3 devices (IP22, IP24)
 */
static const struct hpc_device hpc3_onboard[] = {
	{ "zs",		/* serial 0/1 duart 0 */
	  HPC_BASE_ADDRESS_0,
	  IOC_BASE + IOC_SERIAL_REGS, 0,
	  INT2_MAP1_INTR(INT2_MAP_SERIAL),
	  HPCDEV_IP22 | HPCDEV_IP24 },
	{ "pckbc",	/* PS/2 keyboard/mouse controller */
	  HPC_BASE_ADDRESS_0,
	  IOC_BASE + IOC_KB_REGS, 0,
	  INT2_MAP1_INTR(INT2_MAP_PCKBC),
	  HPCDEV_IP22 | HPCDEV_IP24_INDY },
	{ "sq",		/* onboard Ethernet */
	  HPC_BASE_ADDRESS_0,
	  HPC3_ENET_DEVREGS, HPC3_ENET_REGS,
	  INT2_L0_INTR(INT2_L0_ENET),
	  HPCDEV_IP22 | HPCDEV_IP24 },
	{ "wdsc",	/* onboard SCSI */
	  HPC_BASE_ADDRESS_0,
	  HPC3_SCSI0_DEVREGS, HPC3_SCSI0_REGS,
	  INT2_L0_INTR(INT2_L0_IP22_SCSI0),
	  HPCDEV_IP22 | HPCDEV_IP24 },
	{ "wdsc",	/* Indigo2/Challenge M secondary onboard SCSI */
	  HPC_BASE_ADDRESS_0,
	  HPC3_SCSI1_DEVREGS, HPC3_SCSI1_REGS,
	  INT2_L0_INTR(INT2_L0_SCSI1),
	  HPCDEV_IP22 },
	{ "haltwo",	/* onboard audio */
	  HPC_BASE_ADDRESS_0,
	  HPC3_PBUS_CH0_DEVREGS, HPC3_PBUS_DMAREGS,
	  INT2_L1_INTR(INT2_L1_IP22_HPC_DMA),
	  HPCDEV_IP22 | HPCDEV_IP24_INDY },
	{ "pione",	/* onboard parallel port */
	  HPC_BASE_ADDRESS_0,
	  IOC_BASE + IOC_PLP_REGS, 0,
	  INT2_L0_INTR(INT2_L0_IP22_PARALLEL),
	  HPCDEV_IP22 | HPCDEV_IP24 },
	{ "panel",	/* Indy front panel */
	  HPC_BASE_ADDRESS_0,
	  IOC_BASE + IOC_PANEL, 0,
	  INT2_L1_INTR(INT2_L1_IP22_PANEL),
	  HPCDEV_IP22 | HPCDEV_IP24 },
	{ NULL }
};

/*
 * Expansion HPC1 devices
 */
static const struct hpc_device hpc1_devices[] = {
	{ "sq",		/* E++ GIO adapter */
	  0,
	  HPC1_ENET_DEVREGS, HPC1_ENET_REGS,
	  -1,
	  HPCDEV_IP20 | HPCDEV_IP24 },
	{ "wdsc",	/* GIO32 SCSI adapter */
	  0,
	  HPC1_SCSI0_DEVREGS, HPC1_SCSI0_REGS,
	  -1,
	  HPCDEV_IP20 | HPCDEV_IP24 },
	{ NULL }
};

/*
 * Expansion HPC3 devices
 */
static const struct hpc_device hpc3_devices[] = {
	{ "sq",		/* Challenge S IO+ secondary ethernet */
	  HPC_BASE_ADDRESS_1,
	  HPC3_ENET_DEVREGS, HPC3_ENET_REGS,
	  INT2_L0_INTR(INT2_L0_GIO_SLOT0),
	  HPCDEV_IP24 },

	{ NULL }
};

struct hpc_softc {
	struct device		sc_dev;

	bus_addr_t		sc_base;

	bus_space_tag_t		sc_ct;
	bus_space_handle_t	sc_ch;
	bus_dma_tag_t		sc_dmat;

	struct timeout		sc_blink_tmo;
};

static struct hpc_values hpc1_values = {
	.revision =		1,
	.scsi0_regs =		HPC1_SCSI0_REGS,
	.scsi0_regs_size =	HPC1_SCSI0_REGS_SIZE,
	.scsi0_cbp =		HPC1_SCSI0_CBP,
	.scsi0_ndbp = 		HPC1_SCSI0_NDBP,
	.scsi0_bc =		HPC1_SCSI0_BC,
	.scsi0_ctl =		HPC1_SCSI0_CTL,
	.scsi0_gio =		HPC1_SCSI0_GIO,
	.scsi0_dev =		HPC1_SCSI0_DEV,
	.scsi0_dmacfg =		HPC1_SCSI0_DMACFG,
	.scsi0_piocfg =		HPC1_SCSI0_PIOCFG,
	.scsi1_regs =		0,
	.scsi1_regs_size =	0,
	.scsi1_cbp =		0,
	.scsi1_ndbp =		0,
	.scsi1_bc =		0,
	.scsi1_ctl =		0,
	.scsi1_gio =		0,
	.scsi1_dev =		0,
	.scsi1_dmacfg =		0,
	.scsi1_piocfg =		0,
	.enet_regs =		HPC1_ENET_REGS,
	.enet_regs_size =	HPC1_ENET_REGS_SIZE,
	.enet_intdelay =	HPC1_ENET_INTDELAY,
	.enet_intdelayval =	HPC1_ENET_INTDELAY_OFF,
	.enetr_cbp =		HPC1_ENETR_CBP,
	.enetr_ndbp =		HPC1_ENETR_NDBP,
	.enetr_bc =		HPC1_ENETR_BC,
	.enetr_ctl =		HPC1_ENETR_CTL,
	.enetr_ctl_active =	HPC1_ENETR_CTL_ACTIVE,
	.enetr_reset =		HPC1_ENETR_RESET,
	.enetr_dmacfg =		0,
	.enetr_piocfg =		0,
	.enetx_cbp =		HPC1_ENETX_CBP,
	.enetx_ndbp =		HPC1_ENETX_NDBP,
	.enetx_bc =		HPC1_ENETX_BC,
	.enetx_ctl =		HPC1_ENETX_CTL,
	.enetx_ctl_active =	HPC1_ENETX_CTL_ACTIVE,
	.enetx_dev =		0,
	.enetr_fifo =		HPC1_ENETR_FIFO,
	.enetr_fifo_size =	HPC1_ENETR_FIFO_SIZE,
	.enetx_fifo =		HPC1_ENETX_FIFO,
	.enetx_fifo_size =	HPC1_ENETX_FIFO_SIZE,
	.enet_devregs =		HPC1_ENET_DEVREGS,
	.enet_devregs_size =	HPC1_ENET_DEVREGS_SIZE,
	.pbus_fifo =		0,
	.pbus_fifo_size =	0,
	.pbus_bbram =		0,
#define MAX_SCSI_XFER   (roundup(MAXPHYS, PAGE_SIZE))
	.scsi_dma_segs =       (MAX_SCSI_XFER / 4096),
	.scsi_dma_segs_size =	4096,
	.scsi_dma_datain_cmd = (HPC1_SCSI_DMACTL_ACTIVE | HPC1_SCSI_DMACTL_DIR),
	.scsi_dma_dataout_cmd =	HPC1_SCSI_DMACTL_ACTIVE,
	.scsi_dmactl_flush =	HPC1_SCSI_DMACTL_FLUSH,
	.scsi_dmactl_active =	HPC1_SCSI_DMACTL_ACTIVE,
	.scsi_dmactl_reset =	HPC1_SCSI_DMACTL_RESET
};

static struct hpc_values hpc3_values = {
	.revision =		3,
	.scsi0_regs =		HPC3_SCSI0_REGS,
	.scsi0_regs_size =	HPC3_SCSI0_REGS_SIZE,
	.scsi0_cbp =		HPC3_SCSI0_CBP,
	.scsi0_ndbp =		HPC3_SCSI0_NDBP,
	.scsi0_bc =		HPC3_SCSI0_BC,
	.scsi0_ctl =		HPC3_SCSI0_CTL,
	.scsi0_gio =		HPC3_SCSI0_GIO,
	.scsi0_dev =		HPC3_SCSI0_DEV,
	.scsi0_dmacfg =		HPC3_SCSI0_DMACFG,
	.scsi0_piocfg =		HPC3_SCSI0_PIOCFG,
	.scsi1_regs =		HPC3_SCSI1_REGS,
	.scsi1_regs_size =	HPC3_SCSI1_REGS_SIZE,
	.scsi1_cbp =		HPC3_SCSI1_CBP,
	.scsi1_ndbp =		HPC3_SCSI1_NDBP,
	.scsi1_bc =		HPC3_SCSI1_BC,
	.scsi1_ctl =		HPC3_SCSI1_CTL,
	.scsi1_gio =		HPC3_SCSI1_GIO,
	.scsi1_dev =		HPC3_SCSI1_DEV,
	.scsi1_dmacfg =		HPC3_SCSI1_DMACFG,
	.scsi1_piocfg =		HPC3_SCSI1_PIOCFG,
	.enet_regs =		HPC3_ENET_REGS,
	.enet_regs_size =	HPC3_ENET_REGS_SIZE,
	.enet_intdelay =	0,
	.enet_intdelayval =	0,
	.enetr_cbp =		HPC3_ENETR_CBP,
	.enetr_ndbp =		HPC3_ENETR_NDBP,
	.enetr_bc =		HPC3_ENETR_BC,
	.enetr_ctl =		HPC3_ENETR_CTL,
	.enetr_ctl_active =	HPC3_ENETR_CTL_ACTIVE,
	.enetr_reset =		HPC3_ENETR_RESET,
	.enetr_dmacfg =		HPC3_ENETR_DMACFG,
	.enetr_piocfg =		HPC3_ENETR_PIOCFG,
	.enetx_cbp =		HPC3_ENETX_CBP,
	.enetx_ndbp =		HPC3_ENETX_NDBP,
	.enetx_bc =		HPC3_ENETX_BC,
	.enetx_ctl =		HPC3_ENETX_CTL,
	.enetx_ctl_active =	HPC3_ENETX_CTL_ACTIVE,
	.enetx_dev =		HPC3_ENETX_DEV,
	.enetr_fifo =		HPC3_ENETR_FIFO,
	.enetr_fifo_size =	HPC3_ENETR_FIFO_SIZE,
	.enetx_fifo =		HPC3_ENETX_FIFO,
	.enetx_fifo_size =	HPC3_ENETX_FIFO_SIZE,
	.enet_devregs =		HPC3_ENET_DEVREGS,
	.enet_devregs_size =	HPC3_ENET_DEVREGS_SIZE,
	.pbus_fifo =		HPC3_PBUS_FIFO,
	.pbus_fifo_size =	HPC3_PBUS_FIFO_SIZE,
	.pbus_bbram =		HPC3_PBUS_BBRAM,
	.scsi_dma_segs =       (MAX_SCSI_XFER / 8192),
	.scsi_dma_segs_size =	8192,
	.scsi_dma_datain_cmd =	HPC3_SCSI_DMACTL_ACTIVE,
	.scsi_dma_dataout_cmd =(HPC3_SCSI_DMACTL_ACTIVE | HPC3_SCSI_DMACTL_DIR),
	.scsi_dmactl_flush =	HPC3_SCSI_DMACTL_FLUSH,
	.scsi_dmactl_active =	HPC3_SCSI_DMACTL_ACTIVE,
	.scsi_dmactl_reset =	HPC3_SCSI_DMACTL_RESET
};

int	hpc_match(struct device *, void *, void *);
void	hpc_attach(struct device *, struct device *, void *);
int	hpc_print(void *, const char *);

int	hpc_revision(struct hpc_softc *, struct gio_attach_args *);
int	hpc_submatch(struct device *, void *, void *);
int	hpc_power_intr(void *);
void	hpc_blink(void *);
void	hpc_blink_ioc(void *);
int	hpc_read_eeprom(int, bus_space_tag_t, bus_space_handle_t, uint8_t *,
	    size_t);

struct hpc_dma_desc *hpc_sync_dma_desc_par(struct hpc_dma_desc *,
	    struct hpc_dma_desc *);
struct hpc_dma_desc *hpc_sync_dma_desc_ecc(struct hpc_dma_desc *,
	    struct hpc_dma_desc *);
void	hpc_update_dma_desc_par(struct hpc_dma_desc *, struct hpc_dma_desc *);
void	hpc_update_dma_desc_ecc(struct hpc_dma_desc *, struct hpc_dma_desc *);

/* globals since they depend upon the system type, not the hpc version */
struct hpc_dma_desc *(*hpc_sync_dma_desc_fn)(struct hpc_dma_desc *,
	    struct hpc_dma_desc *);
void	(*hpc_update_dma_desc_fn)(struct hpc_dma_desc *, struct hpc_dma_desc *);

const struct cfattach hpc_ca = {
	sizeof(struct hpc_softc), hpc_match, hpc_attach
};

struct cfdriver hpc_cd = {
	NULL, "hpc", DV_DULL
};

void	hpc3_space_barrier(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    bus_size_t, int);

bus_space_t hpc3bus_tag = {
	PHYS_TO_XKPHYS(0, CCA_NC),
	NULL,
	imc_read_1, imc_write_1,
	imc_read_2, imc_write_2,
	imc_read_4, imc_write_4,
	imc_read_8, imc_write_8,
	imc_read_raw_2, imc_write_raw_2,
	imc_read_raw_4, imc_write_raw_4,
	imc_read_raw_8, imc_write_raw_8,
	imc_space_map, imc_space_unmap, imc_space_region,
	imc_space_vaddr, hpc3_space_barrier
};

int
hpc_match(struct device *parent, void *vcf, void *aux)
{
	struct gio_attach_args* ga = aux;
	uint32_t dummy;

	/* Make sure it's actually there and readable */
	if (guarded_read_4(PHYS_TO_XKPHYS(ga->ga_addr, CCA_NC), &dummy) == 0)
		return 1;

	return 0;
}

void
hpc_attach(struct device *parent, struct device *self, void *aux)
{
	struct hpc_softc *sc = (struct hpc_softc *)self;
	struct gio_attach_args* ga = aux;
	struct hpc_attach_args ha;
	const struct hpc_device *hd;
	struct hpc_values *hv;
	uint32_t probe32;
	uint8_t probe8;
	uint32_t hpctype;
	int isonboard;
	int isioplus;
	int giofast;
	int needprobe;
	int sysmask = 0;

	sc->sc_base = ga->ga_addr;
	sc->sc_ct = ga->ga_iot;
	sc->sc_ch = PHYS_TO_XKPHYS(sc->sc_base, CCA_NC);
	sc->sc_dmat = ga->ga_dmat;

	/* setup HPC DMA helpers if not done already */
	if (hpc_sync_dma_desc_fn == NULL) {
		if (ip22_ecc) {
			hpc_sync_dma_desc_fn = hpc_sync_dma_desc_ecc;
			hpc_update_dma_desc_fn = hpc_update_dma_desc_ecc;
		} else {
			hpc_sync_dma_desc_fn = hpc_sync_dma_desc_par;
			hpc_update_dma_desc_fn = hpc_update_dma_desc_par;
		}
	}

	switch (sys_config.system_type) {
	case SGI_IP20:
		sysmask = HPCDEV_IP20;
		break;
	case SGI_IP22:
	case SGI_IP26:
	case SGI_IP28:
		switch (sys_config.system_subtype) {
		default:
		case IP22_INDIGO2:
			sysmask = HPCDEV_IP22;
			break;
		case IP22_CHALLS:
			sysmask = HPCDEV_IP24;
			break;
		case IP22_INDY:
			sysmask = HPCDEV_IP24 | HPCDEV_IP24_INDY;
			break;
		}
		break;
	};

	if ((hpctype = hpc_revision(sc, ga)) == 0) {
		printf(": could not identify HPC revision\n");
		return;
	}

	if (hpctype != 3)
		hpc_old = 1;

	/* force big-endian mode */
	if (hpctype == 15)
		bus_space_write_4(sc->sc_ct, sc->sc_ch, HPC1_BIGENDIAN, 0);

	/*
	 * Select the proper bus_space_tag for child devices. HPC3 need a
	 * specific barrier function.
	 */
	if (hpctype == 3)
		sc->sc_ct = &hpc3bus_tag;

	/*
	 * All machines have only one HPC on the mainboard itself. ''Extra''
	 * HPCs require bus arbiter and other magic to run happily.
	 */
	isonboard = (sc->sc_base == HPC_BASE_ADDRESS_0);
	isioplus = (sc->sc_base == HPC_BASE_ADDRESS_1 && hpctype == 3 &&
	    (sysmask & HPCDEV_IP24) != 0);

	printf(": SGI HPC%d%s (%s)\n", (hpctype ==  3) ? 3 : 1,
	    (hpctype == 15) ? ".5" : "", (isonboard) ? "onboard" :
	    (isioplus) ? "IO+ mezzanine" : "GIO slot");

	/*
	 * Configure the IOC.
	 */
	if (isonboard && sys_config.system_type != SGI_IP20) {
		/* Reset IOC */
		bus_space_write_4(sc->sc_ct, sc->sc_ch, IOC_BASE + IOC_RESET,
		    IOC_RESET_PARALLEL | IOC_RESET_PCKBC | IOC_RESET_EISA |
		    IOC_RESET_ISDN | IOC_RESET_LED_GREEN );

		/*
		 * Set the two serial ports to PC mode.
		 */
		bus_space_write_4(sc->sc_ct, sc->sc_ch, IOC_BASE + IOC_WRITE,
		    bus_space_read_4(sc->sc_ct, sc->sc_ch,
		      IOC_BASE + IOC_WRITE) |
		    IOC_WRITE_PC_UART2 | IOC_WRITE_PC_UART1);

		/* XXX: the firmware should have taken care of this already */
#if 0
		if (sys_config.system_subtype != IP22_INDIGO2) {
			bus_space_write_4(sc->sc_ct, sc->sc_ch,
			    IOC_BASE + IOC_GCSEL, 0xff);
			bus_space_write_4(sc->sc_ct, sc->sc_ch,
			    IOC_BASE + IOC_GCREG, 0xff);
		}
#endif
	}

	/*
	 * Configure the bus arbiter appropriately.
	 *
	 * In the case of Challenge S, we must tell the IO+ board which
	 * DMA channel to use (we steal it from one of the slots). SGI allows
	 * an HPC1.5 in slot 1, in which case IO+ must use EXP0, or any
	 * other DMA-capable board in slot 0, which leaves us to use EXP1. Of
	 * course, this means that only one GIO board may use DMA.
	 *
	 * Note that this never happens on Indigo2.
	 */
	if (isioplus) {
		int arb_slot;

		if (guarded_read_4(PHYS_TO_XKPHYS(HPC_BASE_ADDRESS_2, CCA_NC),
		    &probe32) != 0)
			arb_slot = GIO_SLOT_EXP1;
		else
			arb_slot = GIO_SLOT_EXP0;

		if (gio_arb_config(arb_slot, GIO_ARB_LB | GIO_ARB_MST |
		    GIO_ARB_64BIT | GIO_ARB_HPC2_64BIT)) {
			printf("%s: failed to configure GIO bus arbiter\n",
			    sc->sc_dev.dv_xname);
			return;
		}

		printf("%s: using EXP%d's DMA channel\n",
		    sc->sc_dev.dv_xname,
		    (arb_slot == GIO_SLOT_EXP0) ? 0 : 1);

		bus_space_write_4(sc->sc_ct, sc->sc_ch,
		    HPC3_PBUS_CFGPIO_REGS, 0x0003ffff);

		if (arb_slot == GIO_SLOT_EXP0)
			bus_space_write_4(sc->sc_ct, sc->sc_ch,
			    HPC3_PBUS_CH0_DEVREGS, 0x20202020);
		else
			bus_space_write_4(sc->sc_ct, sc->sc_ch,
			    HPC3_PBUS_CH0_DEVREGS, 0x30303030);
	} else if (!isonboard) {
		int arb_slot;

		arb_slot = (sc->sc_base == HPC_BASE_ADDRESS_1) ?
		    GIO_SLOT_EXP0 : GIO_SLOT_EXP1;

		if (gio_arb_config(arb_slot, GIO_ARB_RT | GIO_ARB_MST)) {
			printf("%s: failed to configure GIO bus arbiter\n",
			    sc->sc_dev.dv_xname);
			return;
		}
	}

	hpc_read_eeprom(hpctype, sc->sc_ct, sc->sc_ch,
	    ha.hpc_eeprom, sizeof(ha.hpc_eeprom));

	if (hpctype == 3) {
		hv = &hpc3_values;
		if (isonboard) {
			hd = hpc3_onboard;
			if (sys_config.system_subtype == IP22_INDIGO2) {
				/* wild guess */
				giofast = 1;
			} else {
				/*
				 * According to IRIX hpc3.h, the fast GIO bit
				 * is active high, but the register value has
				 * been found to be 0xf8 on slow GIO systems
				 * and 0xf1 on fast ones, which tends to prove
				 * the opposite...
				 */
				if (bus_space_read_4(sc->sc_ct, sc->sc_ch,
				    IOC_BASE + IOC_GCREG) & IOC_GCREG_GIO_33MHZ)
					giofast = 0;
				else
					giofast = 1;
			}
		} else {
			hd = hpc3_devices;
			/*
			 * XXX should IO+ Mezzanine use the same settings as
			 * XXX the onboard HPC3?
			 */
			giofast = 0;
		}
		needprobe = 0;
	} else {
		hv = &hpc1_values;
		hv->revision = hpctype;
		giofast = 0;
		if (isonboard) {
			hd = hpc1_onboard;
			needprobe = 0;
		} else {
			hd = hpc1_devices;
			/*
			 * Until a reliable way of telling E++ and GIO32 SCSI
			 * boards apart is found, we will need to do basic
			 * chip existence checks before attempting to attach.
			 */
			needprobe = 1;
		}
	}
	for (; hd->hd_name != NULL; hd++) {
		if ((hd->hd_sysmask & sysmask) == 0 ||
		    (hd->hd_base != 0 && hd->hd_base != sc->sc_base))
			continue;

		ha.ha_name = hd->hd_name;
		ha.ha_base = sc->sc_base;
		ha.ha_devoff = hd->hd_devoff;
		ha.ha_dmaoff = hd->hd_dmaoff;
		/*
		 * Compute the interrupt line for HPC1 expansion boards.
		 * This allows the hpc1_devices[] array to remain compact.
		 */
		if (hd->hd_irq < 0) {
			if (sys_config.system_type == SGI_IP20)
				ha.ha_irq = INT2_L0_INTR(INT2_L0_GIO_LVL1);
			else {
				if (sc->sc_base == HPC_BASE_ADDRESS_1)
					ha.ha_irq =
					    INT2_MAP0_INTR(INT2_MAP_GIO_SLOT0);
				else
					ha.ha_irq =
					    INT2_MAP0_INTR(INT2_MAP_GIO_SLOT1);
			}
		} else
			ha.ha_irq = hd->hd_irq;

		ha.ha_st = sc->sc_ct;
		ha.ha_sh = sc->sc_ch;
		ha.ha_dmat = sc->sc_dmat;
		ha.hpc_regs = hv;
		ha.ha_giofast = giofast;

		/*
		 * On hpc@@gio boards such as the E++, we want to avoid
		 * `wdsc not configured' messages (or sq on SCSI boards).
		 * The following checks are borrowed from the sq(4) and
		 * wdsc(4) respective probes.
		 */
		if (needprobe) {
			paddr_t pa;
			volatile uint32_t *reg;

			if (strcmp(hd->hd_name, "sq") == 0) {
				/*
				 * E++ registers aren't accessible until
				 * the reset register is written to.
				 */
				pa = sc->sc_ch + hd->hd_dmaoff +
				    hv->enetr_reset;
				reg = (volatile uint32_t *)
				    PHYS_TO_XKPHYS(pa, CCA_NC);
				if (guarded_read_4((vaddr_t)reg, &probe32) != 0)
					continue;
				*reg = 0x01;
				delay(20);
				*reg = 0x00;

				pa = sc->sc_ch + hd->hd_devoff +
				    (7 << 2);		/* SEEQ_TXSTAT */
				reg = (volatile uint32_t *)
				    PHYS_TO_XKPHYS(pa, CCA_NC);
				if (guarded_read_4((vaddr_t)reg, &probe32) != 0)
					continue;
				if ((probe32 & 0xff) != 0x80) /*TXSTAT_OLDNEW*/
					continue;
			} else
			/* if (strcmp(hd->hd_name, "wdsc") == 0) */ {
				/*
				 * wdsc registers may not be accessible
				 * until the dma engine is reset.
				 */
				pa = sc->sc_ch + hd->hd_dmaoff +
				    hv->scsi0_ctl;
				reg = (volatile uint32_t *)
				    PHYS_TO_XKPHYS(pa, CCA_NC);
				if (guarded_read_4((vaddr_t)reg, &probe32) != 0)
					continue;
				*reg = hv->scsi_dmactl_reset;
				delay(1000);
				*reg = 0;
				delay(1000);

				pa = sc->sc_ch + hd->hd_devoff + 3;
				if (guarded_read_1(PHYS_TO_XKPHYS(pa, CCA_NC),
				    &probe8) != 0)
					continue;
				if (probe8 == 0xff)
					continue;
			}
		}

		config_found_sm(self, &ha, hpc_print, hpc_submatch);
	}

	/*
	 * Attach the clock chip as well if on hpc0.
	 */
	if (isonboard) {
		if (sys_config.system_type == SGI_IP20) {
			ha.ha_name = "dpclock";
			ha.ha_devoff = HPC1_PBUS_BBRAM;
		} else {
			ha.ha_name = "dsclock";
			ha.ha_devoff = HPC3_PBUS_BBRAM;
		}
		ha.ha_base = sc->sc_base;
		ha.ha_dmaoff = 0;
		ha.ha_irq = -1;
		ha.ha_st = sc->sc_ct;
		ha.ha_sh = sc->sc_ch;
		ha.ha_dmat = sc->sc_dmat;
		ha.hpc_regs = NULL;
		ha.ha_giofast = giofast;

		config_found_sm(self, &ha, hpc_print, hpc_submatch);

		if (sys_config.system_type == SGI_IP20) {
			timeout_set(&sc->sc_blink_tmo, hpc_blink, sc);
			hpc_blink(sc);
		} else {
			timeout_set(&sc->sc_blink_tmo, hpc_blink_ioc, sc);
			hpc_blink_ioc(sc);
		}
	}
}

/*
 * HPC revision detection isn't as simple as it should be. Devices probe
 * differently depending on their slots, but luckily there is only one
 * instance in which we have to decide the major revision (HPC1 vs HPC3).
 *
 * The HPC is found in the following configurations:
 *	o Indigo R4k
 * 		One on-board HPC1 or HPC1.5.
 * 		Up to two additional HPC1.5's in GIO slots 0 and 1.
 *	o Indy
 * 		One on-board HPC3.
 *		Up to two additional HPC1.5's in GIO slots 0 and 1.
 *	o Challenge S
 * 		One on-board HPC3.
 * 		Up to one additional HPC3 on the IO+ board (if installed).
 *		Up to one additional HPC1.5 in slot 1 of the IO+ board.
 *	o Indigo2, Challenge M
 *		One on-board HPC3.
 *
 * All we really have to worry about is the IP24 case.
 */
int
hpc_revision(struct hpc_softc *sc, struct gio_attach_args *ga)
{
	uint32_t reg;

	/* No hardware ever supported the last hpc base address. */
	if (ga->ga_addr == HPC_BASE_ADDRESS_3)
		return 0;

	switch (sys_config.system_type) {
	case SGI_IP20:
		if (guarded_read_4(PHYS_TO_XKPHYS(ga->ga_addr + HPC1_BIGENDIAN,
		    CCA_NC), &reg) != 0) {
			if (((reg >> HPC1_REVSHIFT) & HPC1_REVMASK) ==
			    HPC1_REV15)
				return 15;
			else
				return 1;
		}
		return 1;

	case SGI_IP22:
	case SGI_IP26:
	case SGI_IP28:
		if (ga->ga_addr == HPC_BASE_ADDRESS_0)
			return 3;

		if (sys_config.system_subtype == IP22_INDIGO2)
			return 0;

		/*
		 * If IP24, probe slot 0 to determine if HPC1.5 or HPC3. Slot 1
		 * must be HPC1.5.
		 */

		if (ga->ga_addr == HPC_BASE_ADDRESS_2)
			return 15;

		/*
		 * Probe for it. We use one of the PBUS registers. Note
		 * that this probe succeeds with my E++ adapter in slot 1
		 * (bad), but it appears to always do the right thing in
		 * slot 0 (good!) and we're only worried about that one
		 * anyhow.
		 */
		if (guarded_read_4(PHYS_TO_XKPHYS(ga->ga_addr +
		    HPC3_PBUS_CH7_BP, CCA_NC), &reg) != 0)
			return 15;
		else
			return 3;
	}

	return 0;
}

int
hpc_submatch(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = (struct cfdata *)vcf;
	struct hpc_attach_args *ha = (struct hpc_attach_args *)aux;

	if (cf->cf_loc[0 /*HPCCF_OFFSET*/] != -1 &&
	    (bus_addr_t)cf->cf_loc[0 /*HPCCF_OFFSET*/] != ha->ha_devoff)
		return 0;

	return (*cf->cf_attach->ca_match)(parent, cf, aux);
}

int
hpc_print(void *aux, const char *pnp)
{
	struct hpc_attach_args *ha = aux;

	if (pnp)
		printf("%s at %s", ha->ha_name, pnp);

	printf(" offset 0x%08lx", ha->ha_devoff);
	if (ha->ha_irq >= 0)
		printf(" irq %d", ha->ha_irq);

	return UNCONF;
}

void *
hpc_intr_establish(int irq, int level, int (*handler)(void *), void *arg,
    const char *what)
{
	return int2_intr_establish(irq, level, handler, arg, what);
}

int
hpc_is_intr_pending(int irq)
{
	return int2_is_intr_pending(irq);
}

void
hpc_intr_disable(void *v)
{
	int2_intr_disable(v);
}

void
hpc_intr_enable(void *v)
{
	int2_intr_enable(v);
}

/*
 * bus_space_barrier() function for HPC3 (which have a write buffer)
 */
void
hpc3_space_barrier(bus_space_tag_t t, bus_space_handle_t h, bus_size_t offs,
    bus_size_t sz, int how)
{
	mips_sync();
	/* just read a side-effect free register */
	(void)*(volatile uint32_t *)
	    PHYS_TO_XKPHYS(HPC_BASE_ADDRESS_0 + HPC3_INTRSTAT_40, CCA_NC);
}

void
hpc_blink(void *arg)
{
	struct hpc_softc *sc = arg;

	bus_space_write_1(sc->sc_ct, sc->sc_ch, HPC1_AUX_REGS,
	    bus_space_read_1(sc->sc_ct, sc->sc_ch, HPC1_AUX_REGS) ^
	      HPC1_AUX_CONSLED);

	timeout_add(&sc->sc_blink_tmo,
	    (((averunnable.ldavg[0] + FSCALE) * hz) >> (FSHIFT + 1)));
}

void
hpc_blink_ioc(void *arg)
{
	struct hpc_softc *sc = arg;
	uint32_t value;

	/* This is a bit odd.  To strobe the green LED, we have to toggle the
	   red control bit. */
	value = bus_space_read_4(sc->sc_ct, sc->sc_ch, IOC_BASE + IOC_RESET) &
	    0xff;
	value ^= IOC_RESET_LED_RED;
	bus_space_write_4(sc->sc_ct, sc->sc_ch, IOC_BASE + IOC_RESET, value);

	timeout_add(&sc->sc_blink_tmo,
	    (((averunnable.ldavg[0] + FSCALE) * hz) >> (FSHIFT + 1)));
}

/*
 * Read the eeprom associated with one of the HPC's.
 *
 * NB: An eeprom is not always present, but the HPC should be able to
 *     handle this gracefully. Any consumers should validate the data to
 *     ensure it's reasonable.
 */
int
hpc_read_eeprom(int hpctype, bus_space_tag_t t, bus_space_handle_t h,
    uint8_t *buf, size_t len)
{
	struct seeprom_descriptor sd;
	bus_space_handle_t bsh;
	bus_size_t offset;

	if (!len || len & 0x1)
		return (1);

	offset = (hpctype == 3) ? HPC3_EEPROM_DATA : HPC1_AUX_REGS;

	if (bus_space_subregion(t, h, offset, 1, &bsh) != 0)
		return (1);

	sd.sd_chip = C56_66;
	sd.sd_tag = t;
	sd.sd_bsh = bsh;
	sd.sd_regsize = 1;
	sd.sd_control_offset = 0;
	sd.sd_status_offset = 0;
	sd.sd_dataout_offset = 0;
	sd.sd_DI = 0x10;	/* EEPROM -> CPU */
	sd.sd_DO = 0x08;	/* CPU -> EEPROM */
	sd.sd_CK = 0x04;
	sd.sd_CS = 0x02;
	sd.sd_MS = 0;
	sd.sd_RDY = 0;

	if (read_seeprom(&sd, (uint16_t *)buf, 0, len / 2) != 1)
		return (1);

	bus_space_unmap(t, bsh, 1);

	return 0;
}

/*
 * Routines to update HPC DMA descriptors.
 */

struct hpc_dma_desc *
hpc_sync_dma_desc(struct hpc_dma_desc *desc, struct hpc_dma_desc *store)
{
	return (*hpc_sync_dma_desc_fn)(desc, store);
}

void
hpc_update_dma_desc(struct hpc_dma_desc *desc, struct hpc_dma_desc *store)
{
	(*hpc_update_dma_desc_fn)(desc, store);
}

/*
 * Parity MC flavour: descriptors are in non-cacheable memory, to which
 * accesses are allowed. No cache operation is needed.
 */

struct hpc_dma_desc *
hpc_sync_dma_desc_par(struct hpc_dma_desc *desc, struct hpc_dma_desc *store)
{
	/* nothing to do */
	return desc;
}

void
hpc_update_dma_desc_par(struct hpc_dma_desc *desc, struct hpc_dma_desc *store)
{
	/* nothing to do */
	KDASSERT(desc == store);
}

/*
 * ECC MC flavour: descriptor are in cacheable memory, and need to be
 * evicted from cache before reading, and flushed from cache after updating.
 *
 * In addition, on R1000 systems, an actual copy of the descriptor needs
 * to be performed, to prevent speculative execution from writing to the
 * cached descriptor.
 */

struct hpc_dma_desc *
hpc_sync_dma_desc_ecc(struct hpc_dma_desc *desc, struct hpc_dma_desc *store)
{
	Mips_IOSyncDCache(curcpu(),
	    (vaddr_t)desc, sizeof(struct hpc_dma_desc), CACHE_SYNC_R);

	store->hdd_bufptr = desc->hdd_bufptr;
	store->hdd_ctl = desc->hdd_ctl;
	store->hdd_descptr = desc->hdd_descptr;

	return store;
}

void
hpc_update_dma_desc_ecc(struct hpc_dma_desc *desc, struct hpc_dma_desc *store)
{
	desc->hdd_bufptr = store->hdd_bufptr;
	desc->hdd_ctl = store->hdd_ctl;
	desc->hdd_descptr = store->hdd_descptr;

	Mips_IOSyncDCache(curcpu(),
	    (vaddr_t)desc, sizeof(struct hpc_dma_desc), CACHE_SYNC_X);
}
@


1.17
log
@Give up trying to map DMA descriptor in uncached memory on ECC flavours of the
IP22 motherboard (IP26, IP28). Instead, do not ask for a BUS_DMA_COHERENT
mapping, but perform explicit cache operations.

This removes the need for the memory controller to switch between `fast' and
`slow' mode every time a DMA descriptor is updated.

Tested on IP22 and IP28.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpc.c,v 1.16 2013/09/28 14:00:00 miod Exp $	*/
d91 1
d367 6
a372 4
void	hpc_sync_dma_desc_par(struct hpc_dma_desc *);
void	hpc_sync_dma_desc_ecc(struct hpc_dma_desc *);
void	hpc_update_dma_desc_par(struct hpc_dma_desc *);
void	hpc_update_dma_desc_ecc(struct hpc_dma_desc *);
d375 3
a377 2
void	(*hpc_sync_dma_desc_fn)(struct hpc_dma_desc *);
void	(*hpc_update_dma_desc_fn)(struct hpc_dma_desc *);
d982 2
a983 2
void
hpc_sync_dma_desc(struct hpc_dma_desc *desc)
d985 1
a985 1
	(*hpc_sync_dma_desc_fn)(desc);
d989 1
a989 1
hpc_update_dma_desc(struct hpc_dma_desc *desc)
d991 1
a991 1
	(*hpc_update_dma_desc_fn)(desc);
d999 2
a1000 2
void
hpc_sync_dma_desc_par(struct hpc_dma_desc *desc)
d1003 1
d1007 1
a1007 1
hpc_update_dma_desc_par(struct hpc_dma_desc *desc)
d1010 1
d1016 4
d1022 2
a1023 2
void
hpc_sync_dma_desc_ecc(struct hpc_dma_desc *desc)
d1025 8
a1032 2
	Mips_HitInvalidateDCache(curcpu(),
	    (vaddr_t)desc, sizeof(struct hpc_dma_desc));
d1036 1
a1036 1
hpc_update_dma_desc_ecc(struct hpc_dma_desc *desc)
d1038 6
a1043 2
	Mips_HitSyncDCache(curcpu(),
	    (vaddr_t)desc, sizeof(struct hpc_dma_desc));
@


1.16
log
@Correctly probe for the Ethernet chip on HPC 1.5 expansion boards. Gets rid of
false sq positives ("sq not configured" since rejected by the sq driver) in
dmesg, for SCSI HPC boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpc.c,v 1.15 2012/09/29 19:24:31 miod Exp $	*/
d366 4
a369 6
struct hpc_dma_desc *hpc_read_dma_desc_par(struct hpc_dma_desc *,
	    struct hpc_dma_desc *);
struct hpc_dma_desc *hpc_read_dma_desc_ecc(struct hpc_dma_desc *,
	    struct hpc_dma_desc *);
void	hpc_write_dma_desc_par(struct hpc_dma_desc *, struct hpc_dma_desc *);
void	hpc_write_dma_desc_ecc(struct hpc_dma_desc *, struct hpc_dma_desc *);
d372 2
a373 3
struct hpc_dma_desc *(*hpc_read_dma_desc_fn)(struct hpc_dma_desc *,
	    struct hpc_dma_desc *);
void	(*hpc_write_dma_desc_fn)(struct hpc_dma_desc *, struct hpc_dma_desc *);
d436 1
a436 1
	if (hpc_read_dma_desc_fn == NULL) {
d438 2
a439 2
			hpc_read_dma_desc_fn = hpc_read_dma_desc_ecc;
			hpc_write_dma_desc_fn = hpc_write_dma_desc_ecc;
d441 2
a442 2
			hpc_read_dma_desc_fn = hpc_read_dma_desc_par;
			hpc_write_dma_desc_fn = hpc_write_dma_desc_par;
d975 1
a975 1
 * Routines to copy and update HPC DMA descriptors in uncached memory.
d978 2
a979 2
struct hpc_dma_desc *
hpc_read_dma_desc(struct hpc_dma_desc *src, struct hpc_dma_desc *store)
d981 1
a981 1
	return (*hpc_read_dma_desc_fn)(src, store);
d985 1
a985 1
hpc_write_dma_desc(struct hpc_dma_desc *dst, struct hpc_dma_desc *src)
d987 1
a987 1
	(*hpc_write_dma_desc_fn)(dst, src);
d990 7
a996 3
/* parity MC flavour: no copy */
struct hpc_dma_desc *
hpc_read_dma_desc_par(struct hpc_dma_desc *src, struct hpc_dma_desc *store)
d998 1
a998 1
	return src;
d1002 1
a1002 1
hpc_write_dma_desc_par(struct hpc_dma_desc *dst, struct hpc_dma_desc *src)
d1004 1
d1007 7
a1013 3
/* ECC MC flavour: copy, and update in slow mode */
struct hpc_dma_desc *
hpc_read_dma_desc_ecc(struct hpc_dma_desc *src, struct hpc_dma_desc *store)
d1015 2
a1016 2
	bcopy(src, store, sizeof(struct hpc_dma_desc));
	return store;
d1020 1
a1020 1
hpc_write_dma_desc_ecc(struct hpc_dma_desc *dst, struct hpc_dma_desc *src)
d1022 2
a1023 8
	register_t sr;
	int mode;

	sr = disableintr();
	mode = ip22_slow_mode();
	bcopy(src, dst, sizeof(struct hpc_dma_desc));
	ip22_restore_mode(mode);
	setsr(sr);
@


1.15
log
@Handle the coprocessor 0 cause and status registers as a 64 bit value now,
as some odd mips designs need moro than 32 bits in there. This causes a lot
of mechanical changes everywhere getsr() is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpc.c,v 1.14 2012/09/29 18:54:38 miod Exp $	*/
d521 1
a521 1
		if (sys_config.system_subtype != IP22_INDIGO) {
d691 7
a697 3
				pa = sc->sc_ch + hd->hd_devoff;
				if (guarded_read_4(PHYS_TO_XKPHYS(pa, CCA_NC),
				    &probe32) != 0)
@


1.14
log
@Proide a mips_sync() macro to wrap asm("sync"), and replace gazillions of
such statements with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpc.c,v 1.13 2012/05/27 14:27:08 miod Exp $	*/
d1012 1
a1012 1
	uint32_t sr;
@


1.13
log
@Proper support for the so-called `fast mode' of the Indigo2 ECC memory
controller. In this mode, access to physical memory are not allowed to
bypass the cache, and this allows the memory subsystem to run faster.

Of course, some device drivers will require uncached memory access (e.g.
for proper HPC DMA descriptor operation).

New ip22-specific functions to switch between `fast mode' and `slow mode'
are introduced.

hpc(4) now provides read and write routines to fetch a dma descriptor from
uncached memory into a local copy, and update it from said modified copy.
On systems without the ECC MC, these will do nothing and operation will
continue to access the uncached memory directly. On systems with the ECC MC,
they will perform a copy, and the writeback will be done in slow mode.

bus_dmamem_map() requests for DMA memory with BUS_DMA_COHERENT set in flags,
which would return uncached memory, will now always fail on systems with
the ECC memory controller. Drivers which really need uncached memory, and
are aware of this particular setup, will now pass
BUS_DMA_COHERENT | BUS_DMA_BUS1, which will let the request succeed.

sq(4) will use all of the above to work mostly unmodified on ECC MC systems
in fast mode.

Finally, fast mode is enabled after autoconf.

Tested on IP22 and IP28.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpc.c,v 1.12 2012/05/17 19:38:59 miod Exp $	*/
d892 1
a892 2
	__asm__ __volatile__ ("sync" ::: "memory");

@


1.12
log
@Better probes for sq and wdsc in gio-masqueraded-as-hpc expansion boards.
Previous change was a tad too optimistic. This repairs E++ and GIO SCSI board
operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpc.c,v 1.11 2012/04/30 21:31:03 miod Exp $	*/
d366 12
d438 11
d775 1
a775 1
 * All we really have to worry about is the IP22 case.
d801 6
d808 1
a808 1
		 * If IP22, probe slot 0 to determine if HPC1.5 or HPC3. Slot 1
a810 2
		if (ga->ga_addr == HPC_BASE_ADDRESS_0)
			return 3;
d972 49
@


1.11
log
@Add ifmedia support to sq(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: hpc.c,v 1.10 2012/04/30 21:30:33 miod Exp $	*/
d412 2
a413 1
	uint32_t dummy;
d522 1
a522 1
		    &dummy) != 0)
d616 1
a616 1
		ha.ha_base = hd->hd_base;
d627 1
a627 1
				if (hd->hd_base == HPC_BASE_ADDRESS_1)
d646 2
a647 3
		 * The following check ought to be enough to prevent
		 * false positives. The strange address computation is
		 * necessary to correctly test wdsc(4).
d650 46
a695 3
			if (guarded_read_4(PHYS_TO_XKPHYS((sc->sc_ch +
			    hd->hd_devoff + 3) & ~3, CCA_NC), &dummy) != 0)
				continue;
@


1.10
log
@Pass the base address of the hpc to child devices, to let them be able to
figure out whether they attach to the onboard hpc or to an expansion slot
(or the Challenge S IO+ mezzanine). No functional change (yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: hpc.c,v 1.9 2012/04/17 15:22:02 miod Exp $	*/
d488 1
a488 3
		 * Set the 10BaseT port to use UTP cable, set autoselect mode
		 * for the Ethernet interface (AUI vs. TP), set the two serial
		 * ports to PC mode.
d491 2
a492 1
		    IOC_WRITE_ENET_AUTO | IOC_WRITE_ENET_UTP |
@


1.9
log
@Infrastructure to allow an interrupt handler to request its interrupt to be
temporarily disabled (and then reenabled later). Will be necessary for the
next driver commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpc.c,v 1.8 2012/04/15 20:50:32 miod Exp $	*/
d616 1
d670 1
@


1.8
log
@Overhaul hpc child device attachments:
- break each hpc1/hpc3 child lists into two lists, one for the onboard
  devices, and one for the expansion devices.
- do not try to attach Indy-only devices (pckbc, haltwo) on Challenge S.
- do not duplicate entries for expansion devices, only with different interrupt
  numbers depending on the system, but instead use a single entry with -1 as
  the interrupt level, and have the attachment glue figure out which
  interrupt vector applies, depending upon the system.
- on expansion hpc1 (or 1.5) boards, do a minimal bus check to decide whether
  or not the hardware we are attaching is there, since we currently don't
  know how to tell E++ (sq only) and GIO32 SCSI (wdsc only) boards apart.
  This hopefully will get rid of misleading `device not configured' messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpc.c,v 1.7 2012/04/15 20:40:39 miod Exp $	*/
d115 3
a117 3
#define HPCDEV_IP20		(1U << 1)	/* Indigo R4k */
#define HPCDEV_IP22		(1U << 2)	/* Indigo2 */
#define HPCDEV_IP24		(1U << 3)	/* Indy, Challenge S */
d191 1
a191 1
	  HPCDEV_IP24 },
d794 18
@


1.7
log
@Provide an hpc_intr_establish() function for hpc subdevices, so they don't
need to have knowledge of the underlying interrupt controller. No functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpc.c,v 1.6 2012/04/15 20:38:10 miod Exp $	*/
d115 9
a123 1
static const struct hpc_device hpc1_devices[] = {
d125 1
a125 2

	{ "zs",		/* Indigo serial 0/1 duart 1 */
d128 1
a128 1
	  5,
d130 1
a130 2

	{ "zs",		/* Indigo kbd/ms duart 0 */
d133 1
a133 1
	  5,
d135 1
a135 2

	{ "sq",		/* Indigo onboard ethernet */
d138 1
a138 19
	  3,
	  HPCDEV_IP20 },
	
	{ "sq",		/* E++ GIO adapter slot 0 (Indigo) */
	  HPC_BASE_ADDRESS_1,
	  HPC1_ENET_DEVREGS, HPC1_ENET_REGS,
	  6,
	  HPCDEV_IP20 },

	{ "sq",		/* E++ GIO adapter slot 0 (Indy) */
	  HPC_BASE_ADDRESS_1,
	  HPC1_ENET_DEVREGS, HPC1_ENET_REGS,
	  16 + 6,
	  HPCDEV_IP24 }, 

	{ "sq",		/* E++ GIO adapter slot 1 (Indigo) */
	  HPC_BASE_ADDRESS_2,
	  HPC1_ENET_DEVREGS, HPC1_ENET_REGS,
	  6,
d140 1
a140 8

	{ "sq",		/* E++ GIO adapter slot 1 (Indy/Challenge S) */
	  HPC_BASE_ADDRESS_2,
	  HPC1_ENET_DEVREGS, HPC1_ENET_REGS,
	  16 + 7,
	  HPCDEV_IP24 },

	{ "wdsc",	/* Indigo onboard SCSI */
d143 1
a143 7
	  2,
	  HPCDEV_IP20 },

	{ "wdsc",	/* GIO32 SCSI adapter slot 0 (Indigo) */
	  HPC_BASE_ADDRESS_1,
	  HPC1_SCSI0_DEVREGS, HPC1_SCSI0_REGS,
	  6,
d145 1
a145 25

	{ "wdsc",	/* GIO32 SCSI adapter slot 0 (Indy) */
	  HPC_BASE_ADDRESS_1,
	  HPC1_SCSI0_DEVREGS, HPC1_SCSI0_REGS,
	  16 + 6,
	  HPCDEV_IP24 }, 

	{ "wdsc",	/* GIO32 SCSI adapter slot 1 (Indigo) */
	  HPC_BASE_ADDRESS_2,
	  HPC1_SCSI0_DEVREGS, HPC1_SCSI0_REGS,
	  6,
	  HPCDEV_IP20 },

	{ "wdsc",	/* GIO32 SCSI adapter slot 1 (Indy/Challenge S) */
	  HPC_BASE_ADDRESS_2,
	  HPC1_SCSI0_DEVREGS, HPC1_SCSI0_REGS,
	  16 + 7,
	  HPCDEV_IP24 },

	{ NULL,
	  0,
	  0, 0,
	  0,
	  0
	}
d148 4
a151 1
static const struct hpc_device hpc3_devices[] = {
a153 1
	  /* XXX Magic numbers */
d155 1
a155 1
	  24 + 5,
d157 1
a157 2

	{ "pckbc",	/* Indigo2/Indy ps2 keyboard/mouse controller */
d160 3
a162 4
	  24 + 4,
	  HPCDEV_IP22 | HPCDEV_IP24 },

	{ "sq",		/* Indigo2/Indy/Challenge S/Challenge M onboard enet */
d165 1
a165 1
	  3,
d167 1
a167 8

	{ "sq",		/* Challenge S IOPLUS secondary ethernet */
	  HPC_BASE_ADDRESS_1,
	  HPC3_ENET_DEVREGS, HPC3_ENET_REGS,
	  0,
	  HPCDEV_IP24 },

	{ "wdsc",	/* Indigo2/Indy/Challenge S/Challenge M onboard SCSI */
d170 1
a170 1
	  1,
a171 1

d175 1
a175 1
	  2,
d177 1
a177 2

	{ "haltwo",	/* Indigo2/Indy onboard audio */
d180 3
a182 4
	  8 + 4,	/* really the HPC DMA complete interrupt */
	  HPCDEV_IP22 | HPCDEV_IP24 },

	{ "pione",	/* Indigo2/Indy/Challenge S/Challenge M onboard pport */
d185 1
a185 1
	  5,
a186 1

d190 1
a190 1
	  9,
d192 2
d195 5
a199 1
	{ NULL,
d201 4
a204 1
	  0, 0,
d206 17
a222 2
	  0
	}
a234 2

	struct mips_bus_space	sc_hpc_bus_space;
d283 1
a283 1
	.pbus_fifo =		0,	
d374 1
a374 1
void	hpc_space_barrier(bus_space_tag_t, bus_space_handle_t, bus_size_t,
d377 14
d417 1
d432 3
a434 1
		if (sys_config.system_subtype == IP22_INDIGO2)
d436 2
a437 1
		else
d439 5
d460 7
d476 1
a476 1
	    (isioplus) ? "IOPLUS mezzanine" : "GIO slot");
d510 1
a510 1
	 * In the case of Challenge S, we must tell the IOPLUS board which
d512 1
a512 1
	 * an HPC1.5 in slot 1, in which case IOPLUS must use EXP0, or any
a562 9
	/*
	 * Build a proper bus_space_tag for child devices.
	 * We will inherit the parent bus_space_tag, except for the barrier
	 * function which needs to be implemented differently on HPC3.
	 */
	bcopy(sc->sc_ct, &sc->sc_hpc_bus_space, sizeof(struct mips_bus_space));
	if (hpctype == 3)
		sc->sc_hpc_bus_space._space_barrier = hpc_space_barrier;

a563 1
		hd = hpc3_devices;
a564 1

d566 1
d585 1
d592 1
a593 1
		hd = hpc1_devices;
d597 12
d611 2
a612 1
		if (!(hd->hd_sysmask & sysmask) || hd->hd_base != sc->sc_base)
d618 17
a634 1
		ha.ha_irq = hd->hd_irq;
d636 1
a636 1
		ha.ha_st = &sc->sc_hpc_bus_space;
d643 5
a647 5
		 * XXX On hpc@@gio boards such as the E++, this will cause 
		 * XXX `wdsc not configured' messages (or sq on SCSI
		 * XXX boards. We need to move some device detection
		 * XXX in there, or figure out if there is a way to know
		 * XXX what is really connected.
d649 6
d671 1
a671 1
		ha.ha_st = &sc->sc_hpc_bus_space;
d703 2
a704 2
 * 		Up to one additional HPC3 on the IOPLUS board (if installed).
 *		Up to one additional HPC1.5 in slot 1 of the IOPLUS board.
d800 1
a800 1
hpc_space_barrier(bus_space_tag_t t, bus_space_handle_t h, bus_size_t offs,
@


1.6
log
@Tell Indy and Challenge S apart.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpc.c,v 1.5 2012/04/08 22:08:25 miod Exp $	*/
d96 1
d98 3
a100 1
#include <sgi/hpc/hpcreg.h>
d770 7
@


1.5
log
@Be more careful when reprogramming the sq(4) DMA and PIO timing parameters;
the current logic can be traced back to DaveM's intership at SGI in 1996,
and are adequate for the hardware he had access to.

However, ``recent'' Indigo2 and Indy systems are fit with a faster (33MHz
instead of 25MHz) GIO64 bus, which need different timing parameters, and
guess what? The PROM knows the right values to set.

Since programming these timing registers was apparently only necessary for
the Challenge S second interface:
1) only reprogram those registers on an IP24 (Indy, Challenge S) system.
2) pick proper values depending upon the actual GIO64 bus speed.

Item #1 fixes Ethernet operation on Indigo2 (at least my teal R4400SC).
Item #2 fixes Ethernet operation on my R5000SC Indy.

For the record, programming unoptimal value caused `TX DMA underrun' errors
(documented as `can't happen' in the HPC3 documentation, oh the irony),
which could be reproduced reliably with ypbind(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: hpc.c,v 1.4 2012/04/05 21:46:43 miod Exp $	*/
d478 2
a479 2
	    sysmask == HPCDEV_IP24);
	
d504 1
a504 1
		if (sys_config.system_subtype == IP22_INDY) {
@


1.4
log
@Add an explicit bus_space_barrier() function for revision 3 hpc, which has a
PIO write buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpc.c,v 1.3 2012/04/05 21:45:51 miod Exp $	*/
d199 1
a199 1
	  HPC3_PBUS_CH6_DEVREGS + IOC_SERIAL_REGS, 0,
d205 1
a205 1
	  HPC3_PBUS_CH6_DEVREGS + IOC_KB_REGS, 0,
d241 1
a241 1
	  HPC3_PBUS_CH6_DEVREGS + IOC_PLP_REGS, 0,
d247 1
a247 1
	  HPC3_PBUS_CH6_DEVREGS + IOC_PANEL, 0,
d410 1
a410 1
void	 hpc_space_barrier(bus_space_tag_t, bus_space_handle_t, bus_size_t,
d433 1
d438 1
d578 35
a612 1
	hd = hpctype == 3 ? hpc3_devices : hpc1_devices;
d625 2
a626 5
		if (hpctype == 3)
			ha.hpc_regs = &hpc3_values;
		else
			ha.hpc_regs = &hpc1_values;
		ha.hpc_regs->revision = hpctype;
d655 1
@


1.3
log
@DMA descriptors only need to be aligned on 8-byte boundaries, and the struct
layout is enough to enforce this. Don't request DMA page boundary alignment
when allocating them.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpc.c,v 1.2 2012/04/03 21:17:35 miod Exp $	*/
d269 2
a409 26
uint8_t  hpc_read_1(bus_space_tag_t, bus_space_handle_t, bus_size_t);
uint16_t hpc_read_2(bus_space_tag_t, bus_space_handle_t, bus_size_t);
void	 hpc_read_raw_2(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    uint8_t *, bus_size_t);
void	 hpc_write_1(bus_space_tag_t, bus_space_handle_t, bus_size_t, uint8_t);
void	 hpc_write_2(bus_space_tag_t, bus_space_handle_t, bus_size_t, uint16_t);
void	 hpc_write_raw_2(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    const uint8_t *, bus_size_t);
uint32_t hpc_read_4(bus_space_tag_t, bus_space_handle_t, bus_size_t);
uint64_t hpc_read_8(bus_space_tag_t, bus_space_handle_t, bus_size_t);
void	 hpc_write_4(bus_space_tag_t, bus_space_handle_t, bus_size_t, uint32_t);
void	 hpc_write_8(bus_space_tag_t, bus_space_handle_t, bus_size_t, uint64_t);
void	 hpc_read_raw_4(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    uint8_t *, bus_size_t);
void	 hpc_write_raw_4(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    const uint8_t *, bus_size_t);
void	 hpc_read_raw_8(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    uint8_t *, bus_size_t);
void	 hpc_write_raw_8(bus_space_tag_t, bus_space_handle_t, bus_addr_t,
	    const uint8_t *, bus_size_t);
int	 hpc_space_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
void	 hpc_space_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);
int	 hpc_space_region(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    bus_size_t, bus_space_handle_t *);
void	*hpc_space_vaddr(bus_space_tag_t, bus_space_handle_t);
d567 9
d586 1
a586 1
		ha.ha_st = sc->sc_ct;
d618 1
a618 1
		ha.ha_st = sc->sc_ct;
d733 14
@


1.2
log
@Default DMA-reachable address constraints to the whole address space, and
narrow these in the various ipXX_machdep.c. On IP22-like systems, narrow
them to 28 bit physical addresses, but unpessimize this by extending this
to 32 bit after autoconf, if no 28-bit limited hpc(4) device has been found.
Since physical memory on these systems start at 128MB, this means that Indigo
systems with more than 128MB memory will behave correctly (and so will Indy
systems with E++ boards and more than 128MB memory).
@
text
@d1 1
a1 1
/*	$OpenBSD: hpc.c,v 1.1 2012/03/28 20:44:23 miod Exp $	*/
a314 1
	.enet_dma_boundary =	4096,
a373 1
	.enet_dma_boundary =	8192,
@


1.1
log
@Work in progress support for the SGI Indigo, Indigo 2 and Indy systems
(IP20, IP22, IP24) in 64-bit mode, adapated from NetBSD. Currently limited
to headless operation, input and video drivers will get ported soon.

Should work on all R4000, R4440 and R5000 based systems. L2 cache on R5000SC
Indy not supported yet (coming soon), R4600 not supported yet either (coming
soon as well).

Tested to boot multiuser on: Indigo2 R4000SC, Indy R4000PC, Indy R4000SC,
Indy R5000SC, Indigo2 R4400SC. There are still glitches in the Ethernet driver
which are being looked at.

Expansion support is limited to the GIO E++ board; GIO boards with PCI-GIO
bridges not ported yet due to the lack of hardware, and this kind of driver
does not port blindly.

Most of this work comes from NetBSD, polishing and integration work, as well
as putting as many ``R4x00 in 64-bit mode'' erratas as necessary, by yours
truly.

More work is coming, as well as trying to get some easy way to boot install
kernels (as older PROM can only boot ECOFF binaries, which won't do for the
kernel).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d488 3
@

