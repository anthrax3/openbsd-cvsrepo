head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.12
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.14
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.10
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.6
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.8
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13;
locks; strict;
comment	@ * @;


1.18
date	2014.05.19.21.18.42;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2014.03.27.21.24.22;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2013.09.28.14.03.13;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2013.04.21.17.13.36;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2012.10.26.16.26.13;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2012.07.18.20.56.46;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2012.07.18.20.12.08;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2012.05.25.11.31.04;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2012.05.17.19.46.52;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2012.05.10.21.36.11;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2012.04.28.19.51.46;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2012.04.27.19.20.21;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2012.04.24.20.11.26;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2012.04.18.17.28.24;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2012.04.18.10.59.45;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2012.04.16.22.28.12;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2012.04.15.20.44.51;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2012.03.28.20.44.23;	author miod;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Format string fixes and removal of -Wno-format for sgi. Based upon an
initial diff from jasper@@
@
text
@/*	$OpenBSD: gio.c,v 1.17 2014/03/27 21:24:22 miod Exp $	*/
/*	$NetBSD: gio.c,v 1.32 2011/07/01 18:53:46 dyoung Exp $	*/

/*
 * Copyright (c) 2012 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 2000 Soren S. Jorvang
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *          This product includes software developed for the
 *          NetBSD Project.  See http://www.NetBSD.org/ for
 *          information about NetBSD.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <mips64/archtype.h>

#include <machine/autoconf.h>
#include <machine/bus.h>

#include <sgi/gio/gioreg.h>
#include <sgi/gio/giovar.h>
#include <sgi/gio/giodevs.h>
#include <sgi/gio/giodevs_data.h>

#include <sgi/gio/grtworeg.h>
#include <sgi/gio/lightreg.h>
#include <sgi/gio/newportreg.h>

#include <sgi/localbus/imcvar.h>
#include <sgi/localbus/intreg.h>
#include <sgi/localbus/intvar.h>
#include <sgi/sgi/ip22.h>

#include "grtwo.h"
#include "impact.h"
#include "light.h"
#include "newport.h"

#if NGRTWO > 0
#include <sgi/gio/grtwovar.h>
#endif
#if NIMPACT_GIO > 0
#include <sgi/dev/impactvar.h>
#endif
#if NLIGHT > 0
#include <sgi/gio/lightvar.h>
#endif
#if NNEWPORT > 0
#include <sgi/gio/newportvar.h>
#endif

int	 gio_match(struct device *, void *, void *);
void	 gio_attach(struct device *, struct device *, void *);
int	 gio_print(void *, const char *);
int	 gio_print_fb(void *, const char *);
int	 gio_search(struct device *, void *, void *);
int	 gio_submatch(struct device *, void *, void *);
uint32_t gio_id(vaddr_t, paddr_t, int);
int	 gio_is_framebuffer_id(uint32_t);

struct gio_softc {
	struct device	sc_dev;

	bus_space_tag_t	sc_iot;
	bus_dma_tag_t	sc_dmat;
};

const struct cfattach gio_ca = {
	sizeof(struct gio_softc), gio_match, gio_attach
};

struct cfdriver gio_cd = {
	NULL, "gio", DV_DULL
};

/* Address of the console frame buffer registers, if applicable */
paddr_t		giofb_consaddr;
/* Id of the console frame buffer */
uint32_t	giofb_consid;
/* Names of the frame buffers, as obtained by ARCBios */
const char	*giofb_names[GIO_MAX_FB];

struct gio_probe {
	uint32_t slot;
	uint64_t base;
	uint32_t mach_type;
	uint32_t mach_subtype;
};

/*
 * Expansion Slot Base Addresses
 *
 * IP20 and IP24 have two GIO connectors: GIO_SLOT_EXP0 and
 * GIO_SLOT_EXP1.
 *
 * On IP24 these slots exist on the graphics board or the IOPLUS
 * "mezzanine" on Indy and Challenge S, respectively. The IOPLUS or
 * graphics board connects to the mainboard via a single GIO64 connector.
 *
 * IP22 has either three or four physical connectors, but only two
 * electrically distinct slots: GIO_SLOT_GFX and GIO_SLOT_EXP0.
 *
 * It should also be noted that DMA is (mostly) not supported in Challenge S's
 * GIO_SLOT_EXP1. See gio(4) for the story.
 */
static const struct gio_probe slot_bases[] = {
	/* GFX is only a slot on Indigo 2 */
	{ GIO_SLOT_GFX, GIO_ADDR_GFX, SGI_IP22, IP22_INDIGO2 },

	/* EXP0 is available on all systems */
	{ GIO_SLOT_EXP0, GIO_ADDR_EXP0, SGI_IP20, -1 },
	{ GIO_SLOT_EXP0, GIO_ADDR_EXP0, SGI_IP22, -1 },

	/* EXP1 does not exist on Indigo 2 */
	{ GIO_SLOT_EXP1, GIO_ADDR_EXP1, SGI_IP20, -1 },
	{ GIO_SLOT_EXP1, GIO_ADDR_EXP1, SGI_IP22, IP22_INDY },
	{ GIO_SLOT_EXP1, GIO_ADDR_EXP1, SGI_IP22, IP22_CHALLS },

	{ 0, 0, 0, 0 }
};

/*
 * Graphic Board Base Addresses
 *
 * Graphics boards are not treated like expansion slot cards. Their base
 * addresses do not necessarily correspond to GIO slot addresses and they
 * do not contain product identification words.
 *
 * This list needs to be sorted in address order, to match the descriptions
 * obtained from ARCBios.
 */
static const struct gio_probe gfx_bases[] = {
	{ -1, GIO_ADDR_GFX, SGI_IP20, -1 },
	{ -1, GIO_ADDR_GFX, SGI_IP22, -1 },

	/* IP20 LG1/LG2 */
	{ -1, GIO_ADDR_GFX + 0x003f0000, SGI_IP20, -1 },
	{ -1, GIO_ADDR_GFX + 0x003f8000, SGI_IP20, -1 }, /* second head */

	{ -1, GIO_ADDR_EXP0, SGI_IP22, -1 },
	{ -1, GIO_ADDR_EXP1, SGI_IP22, -1 },

	{ 0, 0, 0, 0 }
};

int
gio_match(struct device *parent, void *match, void *aux)
{
	struct imc_attach_args *iaa = aux;

	if (strcmp(iaa->iaa_name, gio_cd.cd_name) != 0)
		return 0;

	return 1;
}

void
gio_attach(struct device *parent, struct device *self, void *aux)
{
	struct gio_softc *sc = (struct gio_softc *)self;
	struct imc_attach_args *iaa = (struct imc_attach_args *)aux;
	struct gio_attach_args ga;
	uint32_t gfx[GIO_MAX_FB], id;
	uint i, j, ngfx;
	int sys_type;

	printf("\n");

	sc->sc_iot = iaa->iaa_st;
	sc->sc_dmat = iaa->iaa_dmat;

	switch (sys_config.system_type) {
	case SGI_IP20:
		sys_type = SGI_IP20;
		break;
	default:
	case SGI_IP22:
	case SGI_IP26:
	case SGI_IP28:
		sys_type = SGI_IP22;
		break;
	}

	ngfx = 0;
	memset(gfx, 0, sizeof(gfx));

	/*
	 * Try and attach graphics devices first.
	 * Unfortunately, they - not being GIO devices after all (except for
	 * Impact) - do not contain a Product Identification Word, nor have
	 * a slot number.
	 *
	 * Record addresses to which graphics devices attach so that
	 * we do not confuse them with expansion slots, should the
	 * addresses coincide.
	 *
	 * If only the ARCBios component tree would be so kind as to give
	 * us the address of the frame buffer components...
	 */
	if (sys_type != SGI_IP22 ||
	    sys_config.system_subtype != IP22_CHALLS) {
		for (i = 0; gfx_bases[i].base != 0; i++) {
			/* skip slots that don't apply to us */
			if (gfx_bases[i].mach_type != sys_type)
				continue;

			if (gfx_bases[i].mach_subtype != -1 &&
			    gfx_bases[i].mach_subtype !=
			      sys_config.system_subtype)
				continue;

			ga.ga_addr = gfx_bases[i].base;
			ga.ga_ioh = PHYS_TO_XKPHYS(ga.ga_addr, CCA_NC);

			/* no need to probe a glass console again */
			if (ga.ga_addr == giofb_consaddr && giofb_consid != 0)
				id = giofb_consid;
			else {
				id = gio_id(ga.ga_ioh, ga.ga_addr, 1);
				if (!gio_is_framebuffer_id(id))
					continue;
			}

			ga.ga_iot = sc->sc_iot;
			ga.ga_dmat = sc->sc_dmat;
			ga.ga_slot = -1;
			ga.ga_product = id;
			/*
			 * Note that this relies upon ARCBios listing frame
			 * buffers in ascending address order, which seems
			 * to be the case so far on multihead Indigo2 systems.
			 */
			if (ngfx < GIO_MAX_FB)
				ga.ga_descr = giofb_names[ngfx];
			else
				ga.ga_descr = NULL;	/* shouldn't happen */

			if (config_found_sm(self, &ga, gio_print_fb,
			    gio_submatch))
				gfx[ngfx] = gfx_bases[i].base;

			ngfx++;
		}
	}

	/*
	 * Now attach any GIO expansion cards.
	 *
	 * Be sure to skip any addresses to which a graphics device has
	 * already been attached.
	 */
	for (i = 0; slot_bases[i].base != 0; i++) {
		int skip = 0;

		/* skip slots that don't apply to us */
		if (slot_bases[i].mach_type != sys_type)
			continue;

		if (slot_bases[i].mach_subtype != -1 &&
		    slot_bases[i].mach_subtype != sys_config.system_subtype)
			continue;

		for (j = 0; j < ngfx; j++) {
			if (slot_bases[i].base == gfx[j]) {
				skip = 1;
				break;
			}
		}
		if (skip)
			continue;

		ga.ga_addr = slot_bases[i].base;
		ga.ga_iot = sc->sc_iot;
		ga.ga_ioh = PHYS_TO_XKPHYS(ga.ga_addr, CCA_NC);

		id = gio_id(ga.ga_ioh, ga.ga_addr, 0);
		if (id == 0)
			continue;

		ga.ga_dmat = sc->sc_dmat;
		ga.ga_slot = slot_bases[i].slot;
		ga.ga_product = id;
		ga.ga_descr = NULL;

		config_found_sm(self, &ga, gio_print, gio_submatch);
	}

	config_search(gio_search, self, aux);
}

/*
 * Try and figure out whether there is a device at the given slot address.
 */
uint32_t
gio_id(vaddr_t va, paddr_t pa, int maybe_gfx)
{
	uint32_t id32, mystery;
	uint16_t id16 = 0;
	uint8_t id8 = 0;

	/*
	 * First, attempt to read the address with various sizes.
	 *
	 * - GIO32 devices will only support reads from 32-bit aligned
	 *   addresses, in all sizes (at least for the ID register).
	 * - frame buffers will support aligned reads from any size at
	 *   any address, but will actually return the access width if
	 *   the slot is pipelined.
	 */

	if (guarded_read_4(va, &id32) != 0)
		return 0;

	/*
	 * If the address doesn't match a base slot address, then we are
	 * only probing for a light(4) frame buffer.
	 */

	if (pa != GIO_ADDR_GFX && pa != GIO_ADDR_EXP0 && pa != GIO_ADDR_EXP1) {
		if (maybe_gfx == 0)
			return 0;
		else {
			if (pa == LIGHT_ADDR_0 || pa == LIGHT_ADDR_1) {
				if (guarded_read_4(va + REX_PAGE1_SET +
				    REX_P1REG_XYOFFSET, &id32) != 0)
					return 0;
				if (id32 == 0x08000800)
					return GIO_PRODUCT_FAKEID_LIGHT;
			}
			return 0;
		}
	}

	/*
	 * GIO32 devices with a 32-bit ID register will not necessarily
	 * answer to addresses not aligned on 32 bit boundaries.
	 */

	if (guarded_read_2(va | 2, &id16) != 0 ||
	    guarded_read_1(va | 3, &id8) != 0) {
		if (GIO_PRODUCT_32BIT_ID(id32))
			return id32;
		else /* not a frame buffer anyway */
			return GIO_PRODUCT_PRODUCTID(id32);
	}

	/*
	 * Of course, GIO32 devices with a 8-bit ID register can use the
	 * other bytes in the first 32-bit word for other purposes.
	 */

	if ((id32 & 0xffff) == id16 && (id32 & 0xff) == id8) {
		if (GIO_PRODUCT_32BIT_ID(id32))
			return id32;
		else if (!GIO_PRODUCT_32BIT_ID(id8) && id8 != 0x00)
			return /*GIO_PRODUCT_PRODUCTID*/(id8);
	}

	/*
	 * If there is a frame buffer device, then either we have hit a
	 * device register (grtwo), or we did not fault because the slot
	 * is pipelined (newport).
	 * In the latter case, we attempt to probe a known register offset.
	 */

	if (maybe_gfx) {
		/*
		 * On (at least) Indy systems with newport graphics, the
		 * presence of a SCSI Expansion board (030-8133) in either
		 * slot will cause extra bits to be set in the topmost byte
		 * of the 32-bit access to the pipelined slot (i.e. the
		 * value of id32 is 0x18000004, not 0x00000004).
		 *
		 * This would prevent newport from being recognized
		 * properly.
		 *
		 * This behaviour seems to be specific to the SCSI board,
		 * since the E++ board does not trigger it. This would
		 * rule out an HPC1.x-specific cause.
		 * 
		 * We work around this by ignoring the topmost byte of id32
		 * from this point on, but it's ugly and isaish...
		 *
		 * Note that this is not necessary on Indigo 2 since this
		 * troublesome board can not be installed on such a system.
		 * Indigo are probably safe from this issues, for they can't
		 * use newport graphics; but the issue at hand might be
		 * HPC 1.x related, so better play safe.
		 */
		if (sys_config.system_type == SGI_IP20 ||
		    (sys_config.system_type == SGI_IP22 &&
		     sys_config.system_subtype != IP22_INDIGO2))
			id32 &= ~0xff000000;

		if (id32 != 4 || id16 != 2 || id8 != 1) {
			if (guarded_read_4(va + HQ2_MYSTERY, &mystery) == 0 &&
			    mystery == HQ2_MYSTERY_VALUE)
				return GIO_PRODUCT_FAKEID_GRTWO;
			else
				return 0;
		}

		/* could be newport(4) */
		if (pa == GIO_ADDR_GFX || pa == GIO_ADDR_EXP0) {
			va += NEWPORT_REX3_OFFSET;
			if (guarded_read_4(va, &id32) == 0 &&
			    guarded_read_2(va | 2, &id16) == 0 &&
			    guarded_read_1(va | 3, &id8) == 0) {
				if (id32 != 4 || id16 != 2 || id8 != 1)
					return GIO_PRODUCT_FAKEID_NEWPORT;
			}
		}

		return 0;
	}

	return 0;
}

int
gio_print(void *aux, const char *pnp)
{
	struct gio_attach_args *ga = aux;
	const char *descr;
	int product, revision;
	uint i;

	product = GIO_PRODUCT_PRODUCTID(ga->ga_product);
	if (GIO_PRODUCT_32BIT_ID(ga->ga_product))
		revision = GIO_PRODUCT_REVISION(ga->ga_product);
	else
		revision = 0;

	descr = "unknown GIO card";
	for (i = 0; gio_knowndevs[i].productid != 0; i++) {
		if (gio_knowndevs[i].productid == product) {
			descr = gio_knowndevs[i].product;
			break;
		}
	}

	if (pnp != NULL) {
		printf("%s", descr);
		if (ga->ga_product != -1)
			printf(" (product 0x%02x revision 0x%02x)",
			    product, revision);
		printf(" at %s", pnp);
	}

	if (ga->ga_slot != -1)
		printf(" slot %d", ga->ga_slot);
	printf(" addr 0x%llx", ga->ga_addr);

	return UNCONF;
}

int
gio_print_fb(void *aux, const char *pnp)
{
	struct gio_attach_args *ga = aux;
	const char *fbname;

	if (pnp != NULL) {
		switch (ga->ga_product) {
		case GIO_PRODUCT_FAKEID_GRTWO:
			fbname = "grtwo";
			break;
		case GIO_PRODUCT_FAKEID_LIGHT:
			fbname = "light";
			break;
		case GIO_PRODUCT_FAKEID_NEWPORT:
			fbname = "newport";
			break;
		default:
			if (GIO_PRODUCT_32BIT_ID(ga->ga_product) &&
			    GIO_PRODUCT_PRODUCTID(ga->ga_product) ==
			      GIO_PRODUCT_IMPACT)
				fbname = "impact";
			else	/* should never happen */
				fbname = "framebuffer";
			break;
		}
		printf("%s at %s", fbname, pnp);
	}

	printf(" addr 0x%llx", ga->ga_addr);

	return UNCONF;
}

int
gio_search(struct device *parent, void *vcf, void *aux)
{
	struct gio_softc *sc = (struct gio_softc *)parent;
	struct cfdata *cf = (struct cfdata *)vcf;
	struct gio_attach_args ga;

	/* Handled by direct configuration, so skip here */
	if (cf->cf_loc[1 /*GIOCF_ADDR*/] == -1)
		return 0;

	ga.ga_addr = (uint64_t)cf->cf_loc[1 /*GIOCF_ADDR*/];
	ga.ga_iot = sc->sc_iot;
	ga.ga_ioh = PHYS_TO_XKPHYS(ga.ga_addr, CCA_NC);
	ga.ga_dmat = sc->sc_dmat;
	ga.ga_slot = cf->cf_loc[0 /*GIOCF_SLOT*/];
	ga.ga_product = -1;
	ga.ga_descr = NULL;

	if ((*cf->cf_attach->ca_match)(parent, cf, &ga) == 0)
		return 0;

	config_attach(parent, cf, &ga, gio_print);

	return 1;
}

int
gio_submatch(struct device *parent, void *vcf, void *aux)
{
	struct cfdata *cf = (struct cfdata *)vcf;
	struct gio_attach_args *ga = (struct gio_attach_args *)aux;

	if (cf->cf_loc[0 /*GIOCF_SLOT*/] != -1 &&
	    cf->cf_loc[0 /*GIOCF_SLOT*/] != ga->ga_slot)
		return 0;

	if (cf->cf_loc[1 /*GIOCF_ADDR*/] != -1 &&
	    (uint64_t)cf->cf_loc[1 /*GIOCF_ADDR*/] != ga->ga_addr)
		return 0;

	return (*cf->cf_attach->ca_match)(parent, cf, aux);
}

int
giofb_cnprobe()
{
	struct gio_attach_args ga;
	uint32_t id;
	int i;
	int sys_type;

	switch (sys_config.system_type) {
	case SGI_IP20:
		sys_type = SGI_IP20;
		break;
	default:
	case SGI_IP22:
	case SGI_IP26:
	case SGI_IP28:
		sys_type = SGI_IP22;
		break;
	}

	for (i = 0; gfx_bases[i].base != 0; i++) {
		if (giofb_consaddr != 0 &&
		    gfx_bases[i].base != giofb_consaddr)
			continue;

		/* skip bases that don't apply to us */
		if (gfx_bases[i].mach_type != sys_type)
			continue;

		if (gfx_bases[i].mach_subtype != -1 &&
		    gfx_bases[i].mach_subtype != sys_config.system_subtype)
			continue;

		ga.ga_addr = gfx_bases[i].base;
		ga.ga_iot = &imcbus_tag;
		ga.ga_ioh = PHYS_TO_XKPHYS(ga.ga_addr, CCA_NC);
		ga.ga_dmat = &imc_bus_dma_tag;
		ga.ga_slot = -1;
		ga.ga_descr = NULL;

		id = gio_id(ga.ga_ioh, ga.ga_addr, 1);
		if (!gio_is_framebuffer_id(id))
			continue;

		ga.ga_product = giofb_consid = id;
		switch (id) {
		default:
#if NIMPACT_GIO > 0
			if (GIO_PRODUCT_32BIT_ID(id) &&
			    GIO_PRODUCT_PRODUCTID(id) == GIO_PRODUCT_IMPACT) {
				if (impact_gio_cnprobe(&ga) != 0)
					return 0;
			}
#endif
			break;
		case GIO_PRODUCT_FAKEID_GRTWO:
#if NGRTWO > 0
			if (grtwo_cnprobe(&ga) != 0)
				return 0;
#endif
			break;
		case GIO_PRODUCT_FAKEID_LIGHT:
#if NLIGHT > 0
			if (light_cnprobe(&ga) != 0)
				return 0;
#endif
			break;
		case GIO_PRODUCT_FAKEID_NEWPORT:
#if NNEWPORT > 0
			if (newport_cnprobe(&ga) != 0)
				return 0;
#endif
			break;
		}
	}

	return ENXIO;
}

int
giofb_cnattach()
{
	struct gio_attach_args ga;

	ga.ga_addr = giofb_consaddr;
	ga.ga_iot = &imcbus_tag;
	ga.ga_ioh = PHYS_TO_XKPHYS(ga.ga_addr, CCA_NC);
	ga.ga_dmat = &imc_bus_dma_tag;
	ga.ga_slot = -1;
	ga.ga_product = giofb_consid;
	ga.ga_descr = NULL;

	switch (giofb_consid) {
	default:
#if NIMPACT_GIO > 0
		if (GIO_PRODUCT_32BIT_ID(giofb_consid) &&
		    GIO_PRODUCT_PRODUCTID(giofb_consid) == GIO_PRODUCT_IMPACT) {
			if (impact_gio_cnattach(&ga) == 0)
				return 0;
		}
#endif
		break;
	case GIO_PRODUCT_FAKEID_GRTWO:
#if NGRTWO > 0
		if (grtwo_cnattach(&ga) == 0)
			return 0;
#endif
		break;
	case GIO_PRODUCT_FAKEID_LIGHT:
#if NLIGHT > 0
		if (light_cnattach(&ga) == 0)
			return 0;
#endif
		break;
	case GIO_PRODUCT_FAKEID_NEWPORT:
#if NNEWPORT > 0
		if (newport_cnattach(&ga) == 0)
			return 0;
#endif
		break;
	}

	giofb_consaddr = 0;
	return ENXIO;
}

int
gio_is_framebuffer_id(uint32_t id)
{
	switch (id) {
	case GIO_PRODUCT_FAKEID_GRTWO:
	case GIO_PRODUCT_FAKEID_LIGHT:
	case GIO_PRODUCT_FAKEID_NEWPORT:
		return 1;
	default:
		if (GIO_PRODUCT_32BIT_ID(id) &&
		    GIO_PRODUCT_PRODUCTID(id) == GIO_PRODUCT_IMPACT)
			return 1;
		else
			return 0;
	}
}

/*
 * Devices living in the expansion slots must enable or disable some
 * GIO arbiter settings. This is accomplished via imc(4) registers.
 */
int
gio_arb_config(int slot, uint32_t flags)
{
	if (flags == 0)
		return (EINVAL);

	if (flags & ~(GIO_ARB_RT | GIO_ARB_LB | GIO_ARB_MST | GIO_ARB_SLV |
	    GIO_ARB_PIPE | GIO_ARB_NOPIPE | GIO_ARB_32BIT | GIO_ARB_64BIT |
	    GIO_ARB_HPC2_32BIT | GIO_ARB_HPC2_64BIT))
		return (EINVAL);

	if (((flags & GIO_ARB_RT)   && (flags & GIO_ARB_LB))  ||
	    ((flags & GIO_ARB_MST)  && (flags & GIO_ARB_SLV)) ||
	    ((flags & GIO_ARB_PIPE) && (flags & GIO_ARB_NOPIPE)) ||
	    ((flags & GIO_ARB_32BIT) && (flags & GIO_ARB_64BIT)) ||
	    ((flags & GIO_ARB_HPC2_32BIT) && (flags & GIO_ARB_HPC2_64BIT)))
		return (EINVAL);

	return (imc_gio64_arb_config(slot, flags));
}

/*
 * Return the logical interrupt number for an expansion board (not a frame
 * buffer!) in the specified slot.
 *
 * Indy and Challenge S have a single GIO interrupt per GIO slot, but
 * distinct slot interrups. Indigo and Indigo2 have three GIO interrupts per
 * slot, but at a given GIO interrupt level, all slots share the same
 * interrupt on the interrupt controller.
 *
 * Expansion boards appear to always use the intermediate level.
 */
int
gio_intr_map(int slot)
{
	switch (sys_config.system_type) {
	case SGI_IP20:
		if (slot == GIO_SLOT_GFX)
			return -1;
		return INT2_L0_INTR(INT2_L0_GIO_LVL1);
	case SGI_IP22:
	case SGI_IP26:
	case SGI_IP28:
		if (sys_config.system_subtype == IP22_INDIGO2) {
			if (slot == GIO_SLOT_EXP1)
				return -1;
			return INT2_L0_INTR(INT2_L0_GIO_LVL1);
		} else {
			if (slot == GIO_SLOT_GFX)
				return -1;
			return INT2_MAP1_INTR(slot == GIO_SLOT_EXP0 ?
			    INT2_MAP_GIO_SLOT0 : INT2_MAP_GIO_SLOT1);
		}
	default:
		return -1;
	}
}

void *
gio_intr_establish(int intr, int level, int (*func)(void *), void *arg,
    const char *what)
{
	return int2_intr_establish(intr, level, func, arg, what);
}

const char *
gio_product_string(int prid)
{
	int i;

	for (i = 0; gio_knowndevs[i].product != NULL; i++)
		if (gio_knowndevs[i].productid == prid)
			return (gio_knowndevs[i].product);

	return (NULL);
}
@


1.17
log
@{fix,add} comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: gio.c,v 1.16 2013/09/28 14:03:13 miod Exp $	*/
d492 1
a492 1
	printf(" addr 0x%lx", ga->ga_addr);
d526 1
a526 1
	printf(" addr 0x%lx", ga->ga_addr);
@


1.16
log
@Refine the frame buffer probe again, to correctly detect a newport frame buffer
on Indy if an HPC SCSI board is plugged in either expansion slots, as this
somehow affects pipelined reads of the newport space.

The framebuffer detection is slowly becoming an ISA-like mess...

Thanks to Alain Tauch for giving me an HPC SCSI board (wrapped in yet another
Indy)
@
text
@d1 1
a1 1
/*	$OpenBSD: gio.c,v 1.15 2013/04/21 17:13:36 miod Exp $	*/
d229 3
a231 2
	 * Unfortunately, they - not being GIO devices after all - do not
	 * contain a Product Identification Word, nor have a slot number.
@


1.15
log
@Well, it turns out the assumption that boards with a 32-bit ID register
will not accept smaller-than-32-bit accesses to the ID register is wrong with
some boards (such as the Set Eng. fast Ethernet).

Rework the logic introduced in 1.10 to allow matching a board with a 32-bit
ID register and consistent reads at smaller sizes.

Tested to not cause false positive or disappearing devices against newport,
grtwo, impact, Phobos G130/G160, Fore ATM, Cyclone Colorbus, and of course
Set Eng.
@
text
@d1 1
a1 1
/*	$OpenBSD: gio.c,v 1.14 2012/10/26 16:26:13 miod Exp $	*/
d374 1
a374 1
	 * GIO32 devices with a 32-bit ID register will not necesserily
d406 28
@


1.14
log
@Previous revision would prevent grtwo(4) boards from being recognized.
Make sure that what seems to be a 8-bit ID register of value zero does not
match as an expansion board, which it can't be, and continue with the specific
frame buffer test logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: gio.c,v 1.13 2012/07/18 20:56:46 miod Exp $	*/
d374 2
a375 2
	 * GIO32 devices with a 32-bit ID register will not answer to
	 * addresses not aligned on 32 bit boundaries.
d391 6
a396 3
	if ((id32 & 0xffff) == id16 && (id32 & 0xff) == id8 &&
	    !GIO_PRODUCT_32BIT_ID(id8) && id8 != 0x00)
		return /*GIO_PRODUCT_PRODUCTID*/(id8);
@


1.13
log
@Attach non-frame buffer GIO devices with ga_product being the id gathered by
gio_id(), not the whole 32 bit first word. Some boards with a 8-bit only ID
register use the other 24 bits, sadly.
@
text
@d1 1
a1 1
/*	$OpenBSD: gio.c,v 1.12 2012/07/18 20:12:08 miod Exp $	*/
d392 1
a392 1
	    !GIO_PRODUCT_32BIT_ID(id8))
@


1.12
log
@Hopefully correctly recognize GIO boards with a 8-bit only ID register, which
are not frame buffers. Thanks to Martin Boehme for donating such boards!
@
text
@d1 1
a1 1
/*	$OpenBSD: gio.c,v 1.11 2012/05/25 11:31:04 miod Exp $	*/
d315 2
a316 1
		if (gio_id(ga.ga_ioh, ga.ga_addr, 0) == 0)
d321 1
a321 1
		ga.ga_product = bus_space_read_4(ga.ga_iot, ga.ga_ioh, 0);
@


1.11
log
@Support for the POWER Indigo2 R10000 systems (IP28). Currently running with
ECC checking disabled, which allows the existing Indigo2 drivers to run
unmodified.
@
text
@d1 1
a1 1
/*	$OpenBSD: gio.c,v 1.10 2012/05/17 19:46:52 miod Exp $	*/
d373 2
a374 2
	 * GIO32 devices will not answer to addresses not aligned on
	 * 32 bit boundaries.
d381 1
a381 1
		else
d384 9
@


1.10
log
@Yet another rework of the crucial gio_id() function responsible for correctly
recognizing a GIO device or an id-less frame buffer in a GIO slot.

Turns out that GIO32 devices (at least those with a 32-bit ID register, but
likely all of them) do NOT like accesses to the minimal GIO register area
NOT done on 32-bit boundaries. While frame buffers won't mind, especially
if their slots are pipelined.

This makes it a lot easier to tell them apart.

While there, split gio_intr_establish() into gio_intr_map(), which will return
a logical interrupt number out of a GIO slot number, and gio_intr_establish(),
which will now expect a logical interrupt number, instead of a logical slot
number. These two functions are still unused, but upcoming changes depend on
this work. (Yes, I'm too lazy to make two commits for this tonite)
@
text
@d1 1
a1 1
/*	$OpenBSD: gio.c,v 1.9 2012/05/10 21:36:11 miod Exp $	*/
d205 1
d212 12
d239 1
a239 1
	if (sys_config.system_type != SGI_IP22 ||
d243 1
a243 1
			if (gfx_bases[i].mach_type != sys_config.system_type)
d295 1
a295 1
		if (slot_bases[i].mach_type != sys_config.system_type)
d539 13
d559 1
a559 1
		if (gfx_bases[i].mach_type != sys_config.system_type)
@


1.9
log
@GIO devices with a 32-bit device identifier actually do not like halfword and
byte accesses to the ID register; instead of interpreting this is as a lack
of hardware, reconize this as a valid GIO device (if the `has a 32-bit ID'
bit is set, that is).

This allows GIO Impact boards, which use a 32-bit ID, to be recognized
correctly, and to work as a console device.

Commited from an Indigo2 with glass console on the single-board Impact
(MG10) board which arrived in the mail today. Would have been done even
earlier, had I not forgotten to connect the extra power supply cable to
the Impact GIO backplane...
@
text
@d1 1
a1 1
/*	$OpenBSD: gio.c,v 1.8 2012/04/28 19:51:46 miod Exp $	*/
d328 6
a333 3
	 * If the slot is pipelined, and the address does not hit a
	 * device register, we will not fault but read the transfer
	 * width back.
d360 2
a361 5
	 * 32-bit GIO devices may not like subword accesses to the
	 * identification register. Don't bail out if any of these
	 * access fails, it's probably one good sign of real GIO
	 * hardware (as opposed to a non-Impact frame buffer) being
	 * there.
d363 4
a366 3
	if (GIO_PRODUCT_32BIT_ID(id32)) {
		if (guarded_read_2(va | 2, &id16) != 0 ||
		    guarded_read_1(va | 3, &id8) != 0)
d368 2
a369 36
	} else {
		if (guarded_read_2(va | 2, &id16) != 0 ||
		    guarded_read_1(va | 3, &id8) != 0)
			return 0;
	}

	/*
	 * If there is a real GIO device at this address (as opposed to
	 * a graphics card), then the low-order 8 bits of each read need
	 * to be consistent...
	 */

	if (id8 == (id16 & 0xff) && id8 == (id32 & 0xff)) {
		/*
		 * If we are unlucky, this device will actually be a grtwo(4)
		 * frame buffer, and we have read the first word of its
		 * shared memory, which will satisfy the above test.
		 *
		 * Check its so-called mystery register to prevent matching
		 * it as an unknown GIO device.
		 */
		if (guarded_read_4(va + HQ2_MYSTERY, &mystery) == 0 &&
		    mystery == HQ2_MYSTERY_VALUE)
			return maybe_gfx ? GIO_PRODUCT_FAKEID_GRTWO : 0;

		if (GIO_PRODUCT_32BIT_ID(id8)) {
			if (id16 == (id32 & 0xffff))
				return id32;
		} else {
			if (id8 != 0) {
				if (maybe_gfx)
					return id8;
				else
					return 0;
			}
		}
d676 2
a677 2
 * Establish an interrupt handler for expansion boards (not frame buffers!)
 * in the specified slot.
d686 2
a687 3
void *
gio_intr_establish(int slot, int level, int (*func)(void *), void *arg,
    const char *what)
a688 2
	int intr;

d692 2
a693 3
			return NULL;
		intr = INT2_L0_INTR(INT2_L0_GIO_LVL1);
		break;
d699 2
a700 2
				return NULL;
			intr = INT2_L0_INTR(INT2_L0_GIO_LVL1);
d703 2
a704 2
				return NULL;
			intr = INT2_MAP1_INTR(slot == GIO_SLOT_EXP0 ?
a706 1
		break;
d708 1
a708 1
		return NULL;
d710 1
d712 4
@


1.8
log
@Only trust giofb_consid if non-zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: gio.c,v 1.7 2012/04/27 19:20:21 miod Exp $	*/
a334 4
	if (guarded_read_2(va | 2, &id16) != 0)
		return 0;
	if (guarded_read_1(va | 3, &id8) != 0)
		return 0;
d357 17
d397 1
a397 1
				if (id8 != GIO_PRODUCT_IMPACT || maybe_gfx)
a485 3
		case GIO_PRODUCT_IMPACT:
			fbname = "impact";
			break;
d492 7
a498 2
		default:	/* should never happen */
			fbname = "framebuffer";
d586 1
a586 1
		case GIO_PRODUCT_IMPACT:
d588 5
a592 3
			ga.ga_product = GIO_PRODUCT_IMPACT;
			if (impact_gio_cnprobe(&ga) != 0)
				return 0;
d633 1
a633 1
	case GIO_PRODUCT_IMPACT:
d635 5
a639 2
		if (impact_gio_cnattach(&ga) == 0)
			return 0;
a669 1
	case GIO_PRODUCT_IMPACT:
d675 5
a679 1
		return 0;
@


1.7
log
@The new probe logic would pretend light(4) devices always exist on Indigo;
fix this by reinstating the actual probe which got removed by mistake in the
recent gio probe and console code rework.
Found the hard way by sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gio.c,v 1.6 2012/04/24 20:11:26 miod Exp $	*/
d242 1
a242 1
			if (ga.ga_addr == giofb_consaddr)
@


1.6
log
@Pour even more smarts into the GIO device identification code, to the point
that it can now tell ID-less framebuffers apart correctly. Therefore, we can
use direct configuration instead of ugly games. Frame buffer drivers match
routines now only need to check for the fake ID they receive.

Tested on various newport and grtwo setups (including multihead configurations)
@
text
@d1 1
a1 1
/*	$OpenBSD: gio.c,v 1.5 2012/04/18 17:28:24 miod Exp $	*/
d349 8
a356 2
			if (pa == LIGHT_ADDR_0 || pa == LIGHT_ADDR_1)
				return GIO_PRODUCT_FAKEID_LIGHT;
@


1.5
log
@Split the existing impact@@xbow attachment into generic impact routines, and
bus-specific attachment; impactreg.h and impactvar.h move from sgi/xbow/ to
sgi/dev/.

Teach the generic impact code how to code with pre-ImpactSR boards, which have
a slightly different register layout (information obtained from Peter Fuerst's
Linux IP28 patches).

Add an impact@@gio attachment (unfortunately untested, no Impact GIO boards
here). All Indigo 2 graphics options should be supported now (assuming the
Extreme/Ultra will actually work with grtwo(4) out of the box).

Tested not to disturb operation on IP30.

** ATTENTION! If you are building IP27 or IP30 kernels, be sure to rm impact.d
** before building a new kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: gio.c,v 1.4 2012/04/18 10:59:45 miod Exp $	*/
d64 1
d66 2
d99 1
d118 2
a129 3
/* an invalid GIO ID value used to report the device might be a frame buffer */
#define	GIO_FAKE_FB_ID	(0xffffff7f)

d203 1
a203 1
	uint32_t gfx[GIO_MAX_FB];
a222 4
	 * Unfortunately graphics devices for which we have no configured
	 * driver, which address matches a regular slot number, will show
	 * up as rogue devices attached to real slots.
	 *
d242 7
a248 3
			if (ga.ga_addr != giofb_consaddr &&
			    gio_id(ga.ga_ioh, ga.ga_addr, 1) != GIO_FAKE_FB_ID)
				continue;
d253 6
a258 1
			ga.ga_product = -1;
d342 1
a342 1
	 * only probing for a frame buffer.
d345 8
a352 3
	if (pa != GIO_ADDR_GFX && pa != GIO_ADDR_EXP0 && pa != GIO_ADDR_EXP1 &&
	    maybe_gfx == 0)
		return 0;
d371 1
a371 1
			return maybe_gfx ? GIO_FAKE_FB_ID : 0;
d377 6
a382 2
			if (id8 != 0)
				return id8;
d388 3
a390 4
	 * device register (light, grtwo), or we did not fault because
	 * the slot is pipelined (newport).
	 * In the latter case, we attempt to probe a known register
	 * offset.
d394 7
a400 2
		if (id32 != 4 || id16 != 2 || id8 != 1)
			return GIO_FAKE_FB_ID;
d403 8
a410 6
		va += 0xf0000;
		if (guarded_read_4(va, &id32) == 0 &&
		    guarded_read_2(va | 2, &id16) == 0 &&
		    guarded_read_1(va | 3, &id8) == 0) {
			if (id32 != 4 || id16 != 2 || id8 != 1)
				return GIO_FAKE_FB_ID;
d460 1
d462 20
a481 2
	if (pnp != NULL)
		printf("framebuffer at %s", pnp);
d483 1
a483 2
	if (ga->ga_addr != (uint64_t)-1)
		printf(" addr 0x%lx", ga->ga_addr);
d536 1
a556 1
		ga.ga_product = -1;
d559 6
a564 1
		switch (gio_id(ga.ga_ioh, ga.ga_addr, 1)) {
d572 1
a572 1
		case GIO_FAKE_FB_ID:
d577 2
d583 2
a599 1
	int i;
d601 7
a607 20
	for (i = 0; gfx_bases[i].base != 0; i++) {
		if (giofb_consaddr != 0 &&
		    gfx_bases[i].base != giofb_consaddr)
			continue;

		/* skip bases that don't apply to us */
		if (gfx_bases[i].mach_type != sys_config.system_type)
			continue;

		if (gfx_bases[i].mach_subtype != -1 &&
		    gfx_bases[i].mach_subtype != sys_config.system_subtype)
			continue;

		ga.ga_addr = gfx_bases[i].base;
		ga.ga_iot = &imcbus_tag;
		ga.ga_ioh = PHYS_TO_XKPHYS(ga.ga_addr, CCA_NC);
		ga.ga_dmat = &imc_bus_dma_tag;
		ga.ga_slot = -1;
		ga.ga_product = -1;
		ga.ga_descr = NULL;
d609 2
a610 2
		switch (gio_id(ga.ga_ioh, ga.ga_addr, 1)) {
		case GIO_PRODUCT_IMPACT:
d612 2
a613 2
			if (impact_gio_cnattach(&ga) == 0)
				return 0;
d615 2
a616 6
			break;
		case GIO_FAKE_FB_ID:
			/*
			 * We still need to probe before attach since we don't
			 * know the frame buffer type here.
			 */
d618 2
a619 3
			if (grtwo_cnprobe(&ga) != 0 &&
			    grtwo_cnattach(&ga) == 0)
				return 0;
d621 2
d624 2
a625 3
			if (light_cnprobe(&ga) != 0 &&
			    light_cnattach(&ga) == 0)
				return 0;
d627 2
d630 2
a631 3
			if (newport_cnprobe(&ga) != 0 &&
			    newport_cnattach(&ga) == 0)
				return 0;
d633 1
a633 2
			break;
		}
d638 14
@


1.4
log
@Do not mistake GR2 boards for GIO boards, as what could be a GIO product
identifier is actually the first word of the boards' shared ram, and might
have a legit value. Be sure to probe for the signature register before
deciding we have found a GIO board.

While there, if we have a glass console attached, don't bother probing it
again at autoconf time, since we have already identified it.
@
text
@d1 1
a1 1
/*	$OpenBSD: gio.c,v 1.3 2012/04/16 22:28:12 miod Exp $	*/
d62 1
d72 1
d79 3
a280 3
		if (slot_bases[i].base == giofb_consaddr)
			continue;

d372 1
a372 1
	 * the slot is pipelined (impact, newport).
a380 9
		/* could be impact(4) */
		va += 0x70000;
		if (guarded_read_4(va, &id32) == 0 &&
		    guarded_read_2(va | 2, &id16) == 0 &&
		    guarded_read_1(va | 3, &id8) == 0) {
			if (id32 != 4 || id16 != 2 || id8 != 1)
				return GIO_FAKE_FB_ID;
		}

d382 1
a382 1
		va += 0x80000;
d518 9
a526 3
		if (gio_id(ga.ga_ioh, ga.ga_addr, 1) != GIO_FAKE_FB_ID)
			continue;

d528 2
a529 2
		if (grtwo_cnprobe(&ga) != 0)
			return 0;
d532 2
a533 2
		if (light_cnprobe(&ga) != 0)
			return 0;
d536 2
a537 2
		if (newport_cnprobe(&ga) != 0)
			return 0;
d539 2
d573 12
a584 7
		if (gio_id(ga.ga_ioh, ga.ga_addr, 1) != GIO_FAKE_FB_ID)
			continue;

		/*
		 * We still need to probe before attach since we don't
		 * know the frame buffer type here.
		 */
d586 3
a588 3
		if (grtwo_cnprobe(&ga) != 0 &&
		    grtwo_cnattach(&ga) == 0)
			return 0;
d591 3
a593 3
		if (light_cnprobe(&ga) != 0 &&
		    light_cnattach(&ga) == 0)
			return 0;
d596 3
a598 3
		if (newport_cnprobe(&ga) != 0 &&
		    newport_cnattach(&ga) == 0)
			return 0;
d600 2
@


1.3
log
@Improve the way frame buffers are probed to reduce (and hopefully avoid)
false positives.

Do not look for framebuffers past GIO EXP1, there shouldn't be anything there.

Add the console code machinery to attach a glass console on IP22, when the
appropriate drivers will exist.

On multihead systems, get console framebuffer address (well, sort of) from a
completely undocumented interface (knowledge taken from Linux, confirmed to
work on a dual-head Indigo 2 here).

While there, get frame buffer names from ARCBios whenever possible, to be used
in dmesg eventually.
@
text
@d1 1
a1 1
/*	$OpenBSD: gio.c,v 1.2 2012/04/15 20:44:51 miod Exp $	*/
d63 1
d237 3
a239 1
			if (gio_id(ga.ga_ioh, ga.ga_addr, 1) != GIO_FAKE_FB_ID)
d276 3
d312 1
a312 1
	uint32_t id32;
d346 12
d363 1
a363 1
				return id32;
d505 2
a506 1
		if (gfx_bases[i].base != giofb_consaddr)
d552 2
a553 1
		if (gfx_bases[i].base != giofb_consaddr)
d596 1
@


1.2
log
@Define symbolic constants for the interrupt controller pin assignments on
IP20, IP22 and IP24, and provide the necessary macros to compute interrupt
vectors numbers (from the int.c point of view) from given sources.
@
text
@d1 1
a1 1
/*	$OpenBSD: gio.c,v 1.1 2012/03/28 20:44:23 miod Exp $	*/
d5 15
d69 14
d89 1
a89 1
uint32_t gio_id(paddr_t, int);
d106 5
d118 3
d124 1
a124 1
 * IP12, IP20 and IP24 have two GIO connectors: GIO_SLOT_EXP0 and
d138 2
a139 1
	{ GIO_SLOT_GFX,  0x1f000000, SGI_IP22, IP22_INDIGO2 },
d141 8
a148 5
	{ GIO_SLOT_EXP0, 0x1f400000, SGI_IP20, -1 },
	{ GIO_SLOT_EXP0, 0x1f400000, SGI_IP22, -1 },

	{ GIO_SLOT_EXP1, 0x1f600000, SGI_IP20, -1 },
	{ GIO_SLOT_EXP1, 0x1f600000, SGI_IP22, IP22_INDY },
d158 4
a161 1
 * do not contain product identification words. 
d164 2
a165 9
	/* grtwo, and newport on IP22 */
	{ -1, 0x1f000000, SGI_IP20, -1 },
	{ -1, 0x1f000000, SGI_IP22, -1 },

	/* light */
	{ -1, 0x1f3f0000, SGI_IP20, -1 },

	/* light (dual headed) */
	{ -1, 0x1f3f8000, SGI_IP20, -1 },
d167 3
a169 3
	/* grtwo, and newport on IP22 */
	{ -1, 0x1f400000, SGI_IP20, -1 },
	{ -1, 0x1f400000, SGI_IP22, -1 },
d171 2
a172 9
	/* grtwo */
	{ -1, 0x1f600000, SGI_IP20, -1 },
	{ -1, 0x1f600000, SGI_IP22, -1 },

	/* newport */
	{ -1, 0x1f800000, SGI_IP22, IP22_INDIGO2 },

	/* newport */
	{ -1, 0x1fc00000, SGI_IP22, IP22_INDIGO2 },
a176 3
/* maximum number of graphics boards possible (arbitrarily large estimate) */
#define MAXGFX (nitems(gfx_bases) - 1)

d194 1
a194 1
	uint32_t gfx[MAXGFX];
d221 30
a250 15
	for (i = 0; gfx_bases[i].base != 0; i++) {
		/* skip slots that don't apply to us */
		if (gfx_bases[i].mach_type != sys_config.system_type)
			continue;

		if (gfx_bases[i].mach_subtype != -1 &&
		    gfx_bases[i].mach_subtype != sys_config.system_subtype)
			continue;

		ga.ga_slot = -1;
		ga.ga_addr = gfx_bases[i].base;
		ga.ga_iot = sc->sc_iot;
		ga.ga_ioh = PHYS_TO_XKPHYS(ga.ga_addr, CCA_NC);
		ga.ga_dmat = sc->sc_dmat;
		ga.ga_product = -1;
d252 1
a252 5
		if (gio_id(ga.ga_ioh, 1) == 0)
			continue;
		
		if (config_found_sm(self, &ga, gio_print_fb, gio_submatch)) {
			gfx[ngfx++] = gfx_bases[i].base;
a281 1
		ga.ga_slot = slot_bases[i].slot;
a284 1
		ga.ga_dmat = sc->sc_dmat;
d286 1
a286 1
		if (gio_id(ga.ga_ioh, 0) == 0)
d289 2
d292 1
d304 1
a304 1
gio_id(paddr_t pa, int maybe_gfx)
d310 12
a321 1
	if (guarded_read_4(pa, &id32) != 0)
d324 8
a331 4
	id16 = id32 ^ 0xffff;
	(void)guarded_read_2(pa | 2, &id16);
	id8 = id16 ^ 0xff;
	(void)guarded_read_1(pa | 3, &id8);
d338 1
d349 32
a380 2
	if (maybe_gfx)
		return 1;
d425 2
a426 1
#if 0 /* once we can know for sure there really is a frame buffer here */
a433 3
#else
	return QUIET;
#endif
a446 2
	ga.ga_product = -1;
	ga.ga_slot = cf->cf_loc[0 /*GIOCF_SLOT*/];
d451 3
a479 1
#if 0	/* XXX involve wscons_machdep somehow */
d481 1
a481 1
gio_cnattach(void)
a482 2
	extern struct machine_bus_dma_tag imc_bus_dma_tag;	/* XXX */
	extern bus_space_t imcbus_tag;				/* XXX */
a483 1
	uint32_t dummy;
d487 3
d498 4
d503 41
d545 1
a545 1
		ga.ga_iot = &imcbus_tag;			/* XXX */
d547 2
a548 1
		ga.ga_dmat = &imc_bus_dma_tag;			/* XXX */
d550 3
a552 2
		
		if (gio_id(ga.ga_ioh, 1) == 0)
d555 4
d560 2
a561 1
		if (grtwo_cnattach(&ga) == 0)
a563 1

d565 2
a566 1
		if (light_cnattach(&ga) == 0)
a568 1

d570 2
a571 1
		if (newport_cnattach(&ga) == 0)
a573 1

a577 1
#endif
d584 1
a584 1
gio_arb_config(int slot, uint32_t flags) 
@


1.1
log
@Work in progress support for the SGI Indigo, Indigo 2 and Indy systems
(IP20, IP22, IP24) in 64-bit mode, adapated from NetBSD. Currently limited
to headless operation, input and video drivers will get ported soon.

Should work on all R4000, R4440 and R5000 based systems. L2 cache on R5000SC
Indy not supported yet (coming soon), R4600 not supported yet either (coming
soon as well).

Tested to boot multiuser on: Indigo2 R4000SC, Indy R4000PC, Indy R4000SC,
Indy R5000SC, Indigo2 R4400SC. There are still glitches in the Ethernet driver
which are being looked at.

Expansion support is limited to the GIO E++ board; GIO boards with PCI-GIO
bridges not ported yet due to the lack of hardware, and this kind of driver
does not port blindly.

Most of this work comes from NetBSD, polishing and integration work, as well
as putting as many ``R4x00 in 64-bit mode'' erratas as necessary, by yours
truly.

More work is coming, as well as trying to get some easy way to boot install
kernels (as older PROM can only boot ECOFF binaries, which won't do for the
kernel).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 1
d472 2
a473 1
 * Establish an interrupt handler for the specified slot.
d475 6
a480 2
 * Indy and Challenge S have an interrupt per GIO slot. Indigo and Indigo2
 * share a single interrupt, however.
d492 1
a492 1
		intr = 6;
d500 1
a500 1
			intr = 6;
d504 2
a505 1
			intr = (slot == GIO_SLOT_EXP0) ? 22 : 23;
@

