head	1.40;
access;
symbols
	OPENBSD_6_2:1.40.0.6
	OPENBSD_6_2_BASE:1.40
	OPENBSD_6_1:1.40.0.8
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.40.0.4
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.39.0.8
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.39.0.4
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.38.0.10
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.6
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.4
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.2
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.2
	OPENBSD_5_0:1.36.0.4
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.36.0.2
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.18.0.2
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.1.0.4
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.40
date	2016.01.02.05.49.35;	author visa;	state Exp;
branches;
next	1.39;
commitid	U9KGIaWU35EclYRl;

1.39
date	2014.05.19.21.18.42;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2012.05.30.16.43.31;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2011.10.10.19.49.16;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	2010.05.09.18.37.45;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2010.04.06.19.12.34;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2010.03.20.16.22.53;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2010.03.07.13.44.26;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.11.11.15.56.42;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2009.11.11.15.29.29;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.09.16.57.47;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.08.22.44.16;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.08.13.10.03;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.07.22.48.37;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.07.14.49.01;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.02.17.20.47;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.01.19.17.56;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.26.18.13.34;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.18.19.32.47;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.18.19.29.09;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.26.19.58.51;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.01.21.56.37;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.21.18.03.15;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2009.05.27.19.04.45;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2009.05.22.21.21.19;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.05.08.18.36.11;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2009.05.03.19.42.45;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2009.05.02.21.31.21;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2009.04.25.20.37.30;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2009.04.24.18.16.46;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2009.04.19.18.36.07;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2009.04.19.16.10.40;	author jsing;	state Exp;
branches;
next	1.7;

1.7
date	2009.04.19.12.51.44;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.18.14.47.25;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.15.18.41.32;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.13.21.17.54;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2009.04.12.17.56.58;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.07.22.53.00;	author miod;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Take the PHY of iec(4) out of reset before attaching the interface.
Otherwise the PHY goes undetected on the slave node of a dual-node
Origin 200. The PHY gets enabled by diagnostic checks but only on the
master node. As the attach code will now do the enabling, the checks can
be disabled on reboot, making reboots faster especially on IP27.

Tested on Origin 200 (IP27), Fuel (IP35 with iec), and Origin 350
(IP35 without iec).

Diff from miod@@, ok krw@@
@
text
@/*	$OpenBSD: ioc.c,v 1.39 2014/05/19 21:18:42 miod Exp $	*/

/*
 * Copyright (c) 2008 Joel Sing.
 * Copyright (c) 2008, 2009, 2010 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * IOC3 device driver.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <mips64/archtype.h>
#include <machine/autoconf.h>
#include <machine/bus.h>

#ifdef TGT_ORIGIN
#include <sgi/sgi/ip27.h>
#include <sgi/sgi/l1.h>
#endif

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <sgi/pci/iocreg.h>
#include <sgi/pci/iocvar.h>

#include <dev/onewire/onewirereg.h>
#include <dev/onewire/onewirevar.h>

#include <sgi/dev/owmacvar.h>
#include <sgi/dev/owserialvar.h>

int	ioc_match(struct device *, void *, void *);
void	ioc_attach(struct device *, struct device *, void *);

struct ioc_intr {
	struct ioc_softc	*ii_ioc;

	int			 (*ii_func)(void *);
	void			*ii_arg;

	struct evcount		 ii_count;
	int			 ii_level;
};

struct ioc_softc {
	struct device		 sc_dev;

	bus_space_tag_t		 sc_memt;
	bus_space_handle_t	 sc_memh;
	bus_dma_tag_t		 sc_dmat;
	pci_chipset_tag_t	 sc_pc;
	pcitag_t		 sc_tag;

	void			*sc_ih_enet;	/* Ethernet interrupt */
	void			*sc_ih_superio;	/* SuperIO interrupt */
	struct ioc_intr		*sc_intr[IOC_NDEVS];

	struct onewire_bus	 sc_bus;

	struct owmac_softc	*sc_owmac;
	struct owserial_softc	*sc_owserial;

	int			 sc_attach_flags;
};

struct cfattach ioc_ca = {
	sizeof(struct ioc_softc), ioc_match, ioc_attach,
};

struct cfdriver ioc_cd = {
	NULL, "ioc", DV_DULL,
};

void	ioc_attach_child(struct ioc_softc *, const char *, bus_addr_t, int);
int	ioc_search_onewire(struct device *, void *, void *);
int	ioc_search_mundane(struct device *, void *, void *);
int	ioc_print(void *, const char *);

int	ioc_intr_dispatch(struct ioc_softc *, int);
int	ioc_intr_ethernet(void *);
int	ioc_intr_shared(void *);
int	ioc_intr_superio(void *);

int	iocow_reset(void *);
int	iocow_read_bit(struct ioc_softc *);
int	iocow_send_bit(void *, int);
int	iocow_read_byte(void *);
int	iocow_triplet(void *, int);
int	iocow_pulse(struct ioc_softc *, int, int);

#ifdef TGT_ORIGIN
/*
 * A mask of nodes on which an ioc driver has attached.
 * We use this on IP35 systems, to prevent attaching a pci IOC3 card which NIC
 * has failed, as the onboard IOC3.
 * XXX This obviously will not work in N mode... but then IP35 are supposed to
 * XXX always run in M mode.
 */
static	uint64_t ioc_nodemask = 0;
#endif

int
ioc_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SGI &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SGI_IOC3)
		return (1);

	return (0);
}

int
ioc_print(void *aux, const char *iocname)
{
	struct ioc_attach_args *iaa = aux;

	if (iocname != NULL)
		printf("%s at %s", iaa->iaa_name, iocname);

	/* no base for onewire, and don't display it for rtc */
	if ((int)iaa->iaa_base > 0 && (int)iaa->iaa_base < IOC3_BYTEBUS_0)
		printf(" base 0x%lx", iaa->iaa_base);

	return (UNCONF);
}

void
ioc_attach(struct device *parent, struct device *self, void *aux)
{
	struct ioc_softc *sc = (struct ioc_softc *)self;
	struct pci_attach_args *pa = aux;
	pci_intr_handle_t ih_enet, ih_superio;
	bus_space_tag_t memt;
	bus_space_handle_t memh;
	bus_size_t memsize;
	pcireg_t data;
	int has_superio, has_enet, is_obio;
	int subdevice_mask;
	bus_addr_t rtcbase;

	if (pci_mapreg_map(pa, PCI_MAPREG_START, PCI_MAPREG_TYPE_MEM, 0,
	    &memt, &memh, NULL, &memsize, 0)) {
		printf(": can't map mem space\n");
		return;
	}

	sc->sc_pc = pa->pa_pc;
	sc->sc_tag = pa->pa_tag;
	sc->sc_dmat = pa->pa_dmat;

	/*
	 * Initialise IOC3 ASIC. 
	 */
	data = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	data |= PCI_COMMAND_MEM_ENABLE | PCI_COMMAND_PARITY_ENABLE |
	    PCI_COMMAND_SERR_ENABLE;
	data &= ~PCI_COMMAND_INTERRUPT_DISABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, data);

	printf("\n");

	sc->sc_memt = memt;
	sc->sc_memh = memh;

	/*
	 * Attach the 1-Wire bus now, so that we can get our own part
	 * number and deduce which devices are really available on the
	 * board.
	 */

	bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_GPCR_S,
	    IOC3_GPCR_MLAN);
	(void)bus_space_read_4(sc->sc_memt, sc->sc_memh, IOC3_GPCR_S);
	config_search(ioc_search_onewire, self, aux);

	/*
	 * Now figure out what our configuration is.
	 */

	has_superio = has_enet = 0;
	is_obio = 0;
	subdevice_mask = 0;
	if (sc->sc_owserial != NULL) {
		if (strncmp(sc->sc_owserial->sc_product, "030-0873-", 9) == 0) {
			/*
			 * MENET board; these attach as four ioc devices
			 * behind an xbridge. However the fourth one lacks
			 * the superio chip.
			 */
			subdevice_mask = (1 << IOCDEV_EF);
			has_enet = 1;
			if (pa->pa_device != 3) {
				subdevice_mask |= (1 << IOCDEV_SERIAL_A) |
				    (1 << IOCDEV_SERIAL_B);
				has_superio = 1;
			}
		} else
		if (strncmp(sc->sc_owserial->sc_product, "030-0891-", 9) == 0) {
			/* IP30 on-board IOC3 */
			subdevice_mask = (1 << IOCDEV_SERIAL_A) |
			    (1 << IOCDEV_SERIAL_B) | (1 << IOCDEV_LPT) |
			    (1 << IOCDEV_KBC) | (1 << IOCDEV_RTC) |
			    (1 << IOCDEV_EF);
			rtcbase = IOC3_BYTEBUS_1;
			has_superio = has_enet = 1;
			is_obio = 1;
		} else
		if (strncmp(sc->sc_owserial->sc_product, "030-1155-", 9) == 0) {
			/* CADDuo board */
			subdevice_mask = (1 << IOCDEV_KBC) | (1 << IOCDEV_EF);
			has_superio = has_enet = 1;
		} else
		if (strncmp(sc->sc_owserial->sc_product, "030-1657-", 9) == 0 ||
		    strncmp(sc->sc_owserial->sc_product, "030-1664-", 9) == 0) {
			/* PCI_SIO_UFC dual serial board */
			subdevice_mask = (1 << IOCDEV_SERIAL_A) |
			    (1 << IOCDEV_SERIAL_B);
			has_superio = 1;
		} else
			goto unknown;
	} else {
#ifdef TGT_ORIGIN
		/*
		 * If no owserial device has been found, then it is
		 * very likely that we are the on-board IOC3 found
		 * on IP27 and IP35 systems, unless we have already
		 * found an on-board IOC3 on this node.
		 *
		 * Origin 2000 (real IP27) systems are a real annoyance,
		 * because they actually have two IOC3 on their BASEIO
		 * board, with the various devices split accross them
		 * (two IOC3 chips are needed to provide the four serial
		 * ports). We can rely upon the PCI device numbers (2 and 6)
		 * to tell onboard IOC3 from PCI IOC3 devices.
		 */
		switch (sys_config.system_type) {
		case SGI_IP27:
			switch (sys_config.system_subtype) {
			case IP27_O2K:
				if (pci_get_widget(sc->sc_pc) ==
				    IP27_O2K_BRIDGE_WIDGET)
					switch (pa->pa_device) {
					case IP27_IOC_SLOTNO:
						subdevice_mask =
						    (1 << IOCDEV_SERIAL_A) |
						    (1 << IOCDEV_SERIAL_B) |
						    (1 << IOCDEV_RTC) |
						    (1 << IOCDEV_EF);
						break;
					case IP27_IOC2_SLOTNO:
						subdevice_mask =
						    (1 << IOCDEV_SERIAL_A) |
						    (1 << IOCDEV_SERIAL_B) |
						    (1 << IOCDEV_LPT) |
#if 0 /* not worth doing */
						    (1 << IOCDEV_RTC) |
#endif
						    (1 << IOCDEV_KBC);
						break;
					default:
						break;
					}
				break;
			case IP27_O200:
				if (pci_get_widget(sc->sc_pc) ==
				    IP27_O200_BRIDGE_WIDGET)
					switch (pa->pa_device) {
					case IP27_IOC_SLOTNO:
						subdevice_mask =
						    (1 << IOCDEV_SERIAL_A) |
						    (1 << IOCDEV_SERIAL_B) |
						    (1 << IOCDEV_LPT) |
						    (1 << IOCDEV_KBC) |
						    (1 << IOCDEV_RTC) |
						    (1 << IOCDEV_EF);
						break;
					default:
						break;
					}
				break;
			default:
				break;
			}
			break;
		case SGI_IP35:
			if (!ISSET(ioc_nodemask, 1UL << currentnasid)) {
				SET(ioc_nodemask, 1UL << currentnasid);

				switch (sys_config.system_subtype) {
				/*
				 * Origin 300 onboard IOC3 do not have PS/2
				 * ports; since they can only be connected to
				 * other 300 or 350 bricks (the latter using
				 * IOC4 devices), it is safe to do this
				 * regardless of the current nasid.
				 * XXX What about Onyx 300 though???
				 */
				case IP35_O300:
					subdevice_mask =
					    (1 << IOCDEV_SERIAL_A) |
					    (1 << IOCDEV_SERIAL_B) |
					    (1 << IOCDEV_LPT) |
					    (1 << IOCDEV_RTC) |
					    (1 << IOCDEV_EF);
					break;
				/*
				 * Origin 3000 I-Bricks have only one serial
				 * port, and no keyboard or parallel ports.
				 */
				case IP35_CBRICK:
					subdevice_mask =
					    (1 << IOCDEV_SERIAL_A) |
					    (1 << IOCDEV_RTC) |
					    (1 << IOCDEV_EF);
					break;
				default:
					subdevice_mask =
					    (1 << IOCDEV_SERIAL_A) |
					    (1 << IOCDEV_SERIAL_B) |
					    (1 << IOCDEV_LPT) |
					    (1 << IOCDEV_KBC) |
					    (1 << IOCDEV_RTC) |
					    (1 << IOCDEV_EF);
					break;
				}
			}
			break;
		default:
			break;
		}

		if (subdevice_mask != 0) {
			rtcbase = IOC3_BYTEBUS_0;
			has_superio = 1;
			if (ISSET(subdevice_mask, 1 << IOCDEV_EF))
				has_enet = 1;
			is_obio = 1;
		} else
#endif	/* TGT_ORIGIN */
		{
unknown:
			/*
			 * Well, we don't really know what kind of device
			 * we are.  We should probe various registers
			 * to figure out, but for now we'll just
			 * chicken out.
			 */
			printf("%s: unknown flavour\n", self->dv_xname);
			return;
		}
	}

	/*
	 * Acknowledge all pending interrupts, and disable them.
	 * Be careful not all registers may be wired depending on what
	 * devices are actually present.
	 */

	if (has_superio) {
		bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IEC, ~0x0);
		bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IES, 0x0);
		bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IR,
		    bus_space_read_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IR));
	}
	if (has_enet) {
		bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_ENET_IER, 0);
	}

	/*
	 * IOC3 is not a real PCI device - it's a poor wrapper over a set
	 * of convenience chips. And when it is in full-blown configuration,
	 * it actually needs to use two interrupts, one for the superio
	 * chip, and the other for the Ethernet chip.
	 *
	 * This would not be a problem if the device advertized itself
	 * as a multifunction device. But it doesn't...
	 *
	 * Fortunately, the interrupt used are simply interrupt pins A
	 * and B; so with the help of the PCI bridge driver, we can
	 * register the two interrupts and almost pretend things are
	 * as normal as they could be.
	 */

	if (has_enet) {
		pa->pa_intrpin = PCI_INTERRUPT_PIN_A;
		if (pci_intr_map(pa, &ih_enet) != 0) {
			printf("%s: failed to map ethernet interrupt\n",
			    self->dv_xname);
			goto unmap;
		}
	}

	if (has_superio) {
		if (has_enet)
			pa->pa_intrpin =
			    is_obio ? PCI_INTERRUPT_PIN_D : PCI_INTERRUPT_PIN_B;
		else
			pa->pa_intrpin = PCI_INTERRUPT_PIN_A;

		if (pci_intr_map(pa, &ih_superio) != 0) {
			printf("%s: failed to map superio interrupt\n",
			    self->dv_xname);
			goto unmap;
		}
	}

	if (has_enet) {
		sc->sc_ih_enet = pci_intr_establish(sc->sc_pc, ih_enet,
		    IPL_NET, ioc_intr_ethernet, sc, self->dv_xname);
		if (sc->sc_ih_enet == NULL) {
			printf("%s: failed to establish ethernet interrupt "
			    "at %s\n", self->dv_xname,
			    pci_intr_string(sc->sc_pc, ih_enet));
			goto unmap;
		}
	}

	if (has_superio) {
		sc->sc_ih_superio = pci_intr_establish(sc->sc_pc, ih_superio,
		    IPL_TTY, ioc_intr_superio, sc, self->dv_xname);
		if (sc->sc_ih_superio == NULL) {
			printf("%s: failed to establish superio interrupt "
			    "at %s\n", self->dv_xname,
			    pci_intr_string(sc->sc_pc, ih_superio));
			goto unregister;
		}
	}

	if (has_enet)
		printf("%s: ethernet %s\n",
		    self->dv_xname, pci_intr_string(sc->sc_pc, ih_enet));
	if (has_superio)
		printf("%s: superio %s\n",
		    self->dv_xname, pci_intr_string(sc->sc_pc, ih_superio));

	/*
	 * Attach other sub-devices.
	 */

	sc->sc_attach_flags = is_obio ? IOC_FLAGS_OBIO : 0;

	if (ISSET(subdevice_mask, 1 << IOCDEV_SERIAL_A)) {
		/*
		 * Put serial ports in passthrough mode,
		 * to use the MI com(4) 16550 support.
		 */
		bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_UARTA_SSCR, 0);
		bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_UARTB_SSCR, 0);

		bus_space_write_4(sc->sc_memt, sc->sc_memh,
		    IOC3_UARTA_SHADOW, 0);
		bus_space_write_4(sc->sc_memt, sc->sc_memh,
		    IOC3_UARTB_SHADOW, 0);

		ioc_attach_child(sc, "com", IOC3_UARTA_BASE, IOCDEV_SERIAL_A);
		if (ISSET(subdevice_mask, 1 << IOCDEV_SERIAL_B))
			ioc_attach_child(sc, "com", IOC3_UARTB_BASE,
			    IOCDEV_SERIAL_B);
	}
	if (ISSET(subdevice_mask, 1 << IOCDEV_KBC))
		ioc_attach_child(sc, "iockbc", 0, IOCDEV_KBC);
	if (ISSET(subdevice_mask, 1 << IOCDEV_EF)) {
		/*
		 * Make sure the PHY is correctly reset before attaching
		 * the interface.
		 */
		bus_space_write_4(sc->sc_memt, sc->sc_memh,
		    IOC3_GPPR(5), 0);
		bus_space_write_4(sc->sc_memt, sc->sc_memh,
		    IOC3_GPCR_S, IOC3_GPCR_PHY_RESET);
		delay(10);
		bus_space_write_4(sc->sc_memt, sc->sc_memh,
		    IOC3_GPPR(5), 1);

		ioc_attach_child(sc, "iec", 0, IOCDEV_EF);
	}
	if (ISSET(subdevice_mask, 1 << IOCDEV_LPT))
		ioc_attach_child(sc, "lpt", 0, IOCDEV_LPT);
	if (ISSET(subdevice_mask, 1 << IOCDEV_RTC))
		ioc_attach_child(sc, "dsrtc", rtcbase, IOCDEV_RTC);

	return;

unregister:
	if (has_enet)
		pci_intr_disestablish(sc->sc_pc, sc->sc_ih_enet);
unmap:
	bus_space_unmap(memt, memh, memsize);
}

void
ioc_attach_child(struct ioc_softc *sc, const char *name, bus_addr_t base,
    int dev)
{
	struct ioc_attach_args iaa;

	memset(&iaa, 0, sizeof iaa);

	iaa.iaa_name = name;
	pci_get_device_location(sc->sc_pc, sc->sc_tag, &iaa.iaa_location);
	iaa.iaa_memt = sc->sc_memt;
	iaa.iaa_memh = sc->sc_memh;
	iaa.iaa_dmat = sc->sc_dmat;
	iaa.iaa_base = base;
	iaa.iaa_dev = dev;
	iaa.iaa_flags = sc->sc_attach_flags;

	if (dev == IOCDEV_EF) {
		if (sc->sc_owmac != NULL)
			memcpy(iaa.iaa_enaddr, sc->sc_owmac->sc_enaddr, 6);
		else {
#ifdef TGT_ORIGIN
			/*
			 * On IP35 class machines, there are no
			 * Number-In-a-Can attached to the onboard
			 * IOC3; instead, the Ethernet address is
			 * stored in the Brick EEPROM, and can be
			 * retrieved with an L1 controller query.
			 */
			if (sys_config.system_type != SGI_IP35 ||
			    l1_get_brick_ethernet_address(currentnasid,
			      iaa.iaa_enaddr) != 0)
#endif
				memset(iaa.iaa_enaddr, 0xff, 6);
		}
	}

	config_found_sm(&sc->sc_dev, &iaa, ioc_print, ioc_search_mundane);
}

int
ioc_search_mundane(struct device *parent, void *vcf, void *args)
{
	struct cfdata *cf = vcf;
	struct ioc_attach_args *iaa = (struct ioc_attach_args *)args;

	if (strcmp(cf->cf_driver->cd_name, iaa->iaa_name) != 0)
		return 0;

	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != (int)iaa->iaa_base)
		return 0;

	return (*cf->cf_attach->ca_match)(parent, cf, iaa);
}

/*
 * Number-In-a-Can access driver (1-Wire interface through IOC)
 */

int
ioc_search_onewire(struct device *parent, void *vcf, void *args)
{
	struct ioc_softc *sc = (struct ioc_softc *)parent;
	struct cfdata *cf = vcf;
	struct onewirebus_attach_args oba;
	struct device *owdev, *dev;
	extern struct cfdriver owmac_cd;
	extern struct cfdriver owserial_cd;
	struct owserial_softc *s;

	if (strcmp(cf->cf_driver->cd_name, "onewire") != 0)
		return 0;

	sc->sc_bus.bus_cookie = sc;
	sc->sc_bus.bus_reset = iocow_reset;
	sc->sc_bus.bus_bit = iocow_send_bit;
	sc->sc_bus.bus_read_byte = iocow_read_byte;
	sc->sc_bus.bus_write_byte = NULL;	/* use default routine */
	sc->sc_bus.bus_read_block = NULL;	/* use default routine */
	sc->sc_bus.bus_write_block = NULL;	/* use default routine */
	sc->sc_bus.bus_triplet = iocow_triplet;
	sc->sc_bus.bus_matchrom = NULL;		/* use default routine */
	sc->sc_bus.bus_search = NULL;		/* use default routine */

	oba.oba_bus = &sc->sc_bus;
	oba.oba_flags = ONEWIRE_SCAN_NOW | ONEWIRE_NO_PERIODIC_SCAN;

	/* In case onewire is disabled in UKC... */
	if ((*cf->cf_attach->ca_match)(parent, cf, &oba) == 0)
		return 0;

	owdev = config_attach(parent, cf, &oba, onewirebus_print);

	/*
	 * Find the first owmac child of the onewire bus, and keep
	 * a pointer to it.  This allows us to pass the ethernet
	 * address to the ethernet subdevice.
	 */
	if (owdev != NULL) {
		TAILQ_FOREACH(dev, &alldevs, dv_list)
			if (dev->dv_parent == owdev &&
			    dev->dv_cfdata->cf_driver == &owmac_cd) {
				sc->sc_owmac = (struct owmac_softc *)dev;
				break;
			}
	}

	/*
	 * Find the first owserial child of the onewire bus not
	 * reporting power supply information, and keep a pointer
	 * to it.  This is a bit overkill since we do not need to
	 * keep the pointer after attach, but it makes that kind
	 * of code contained in the same place.
	 */
	if (owdev != NULL) {
		TAILQ_FOREACH(dev, &alldevs, dv_list)
			if (dev->dv_parent == owdev &&
			    dev->dv_cfdata->cf_driver == &owserial_cd) {
				s = (struct owserial_softc *)dev;
				if (strncmp(s->sc_name, "PWR", 3) == 0)
					continue;
				sc->sc_owserial = s;
				break;
			}
	}


	return 1;
}

int
iocow_reset(void *v)
{
	struct ioc_softc *sc = v;
	return iocow_pulse(sc, 500, 65);
}

int
iocow_read_bit(struct ioc_softc *sc)
{
	return iocow_pulse(sc, 6, 13);
}

int
iocow_send_bit(void *v, int bit)
{
	struct ioc_softc *sc = v;
	int rc;
	
	if (bit != 0)
		rc = iocow_pulse(sc, 6, 110);
	else
		rc = iocow_pulse(sc, 80, 30);
	return rc;
}

int
iocow_read_byte(void *v)
{
	struct ioc_softc *sc = v;
	unsigned int byte = 0;
	int i;

	for (i = 0; i < 8; i++)
		byte |= iocow_read_bit(sc) << i;

	return byte;
}

int
iocow_triplet(void *v, int dir)
{
	struct ioc_softc *sc = v;
	int rc;

	rc = iocow_read_bit(sc);
	rc <<= 1;
	rc |= iocow_read_bit(sc);

	switch (rc) {
	case 0x0:
		iocow_send_bit(v, dir);
		break;
	case 0x1:
		iocow_send_bit(v, 0);
		break;
	default:
		iocow_send_bit(v, 1);
		break;
	}

	return (rc);
}

int
iocow_pulse(struct ioc_softc *sc, int pulse, int data)
{
	uint32_t mcr_value;

	mcr_value = (pulse << 10) | (data << 2);
	bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_MCR, mcr_value);
	do {
		mcr_value =
		    bus_space_read_4(sc->sc_memt, sc->sc_memh, IOC3_MCR);
	} while ((mcr_value & 0x00000002) == 0);

	delay(500);

	return (mcr_value & 1);
}

/*
 * Interrupt handling.
 */

/*
 * List of interrupt bits to enable for each device.
 *
 * For the serial ports, we only enable the passthrough interrupt and
 * let com(4) tinker with the appropriate registers, instead of adding
 * an unnecessary layer there.
 */
static const uint32_t ioc_intrbits[IOC_NDEVS] = {
	IOC3_IRQ_UARTA,
	IOC3_IRQ_UARTB,
	IOC3_IRQ_LPT,
	IOC3_IRQ_KBC,
	0,	/* RTC */
	0	/* Ethernet, handled differently */
};

void *
ioc_intr_establish(void *cookie, u_long dev, int level, int (*func)(void *),
    void *arg, char *name)
{
	struct ioc_softc *sc = cookie;
	struct ioc_intr *ii;

	if (dev < 0 || dev >= IOC_NDEVS)
		return NULL;

	ii = (struct ioc_intr *)malloc(sizeof(*ii), M_DEVBUF, M_NOWAIT);
	if (ii == NULL)
		return NULL;

	ii->ii_ioc = sc;
	ii->ii_func = func;
	ii->ii_arg = arg;
	ii->ii_level = level;

	evcount_attach(&ii->ii_count, name, &ii->ii_level);
	sc->sc_intr[dev] = ii;

	/* enable hardware source if necessary */
	bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IES,
	    ioc_intrbits[dev]);
	
	return (ii);
}

int
ioc_intr_superio(void *v)
{
	struct ioc_softc *sc = (struct ioc_softc *)v;
	uint32_t pending, mask;
	int dev;

	pending = bus_space_read_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IR) &
	    bus_space_read_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IES);

	if (pending == 0)
		return 0;

	/* Disable pending interrupts */
	bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IEC, pending);

	for (dev = 0; dev < IOC_NDEVS - 1 /* skip Ethernet */; dev++) {
		mask = pending & ioc_intrbits[dev];
		if (mask != 0) {
			(void)ioc_intr_dispatch(sc, dev);

			/* Ack, then reenable, pending interrupts */
			bus_space_write_4(sc->sc_memt, sc->sc_memh,
			    IOC3_SIO_IR, mask);
			bus_space_write_4(sc->sc_memt, sc->sc_memh,
			    IOC3_SIO_IES, mask);
		}
	}

	return 1;
}

int
ioc_intr_ethernet(void *v)
{
	struct ioc_softc *sc = (struct ioc_softc *)v;

	/* This interrupt source is not shared between several devices. */
	return ioc_intr_dispatch(sc, IOCDEV_EF);
}

int
ioc_intr_shared(void *v)
{
	return ioc_intr_superio(v) | ioc_intr_ethernet(v);
}

int
ioc_intr_dispatch(struct ioc_softc *sc, int dev)
{
	struct ioc_intr *ii;
	int rc = 0;

	/* Call registered interrupt function. */
	if ((ii = sc->sc_intr[dev]) != NULL && ii->ii_func != NULL) {
		rc = (*ii->ii_func)(ii->ii_arg);
		if (rc != 0)
			ii->ii_count.ec_count++;
	}

	return rc;
}
@


1.39
log
@Format string fixes and removal of -Wno-format for sgi. Based upon an
initial diff from jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.38 2012/05/30 16:43:31 miod Exp $	*/
d484 13
a496 1
	if (ISSET(subdevice_mask, 1 << IOCDEV_EF))
d498 1
@


1.38
log
@Correctly compute the IOC3 device mask on MENET boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.37 2011/10/10 19:49:16 miod Exp $	*/
d144 1
a144 1
		printf(" base 0x%x", iaa->iaa_base);
@


1.37
log
@Extend pci_probe_device_hook() on sgi xbridge(4) to return either the straight
accessors or the byte-swapped accessors, depending upon the byteswap setting
of the device we are trying to attach.

This allows for the removal of byteswap knowledge from ioc(4) and iof(4)
drivers.

While there, build pci_chipset_t md structs by bcopy'ing a template and
filling the few runtime fields, instead of assigning every field of them.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.36 2010/09/20 06:33:47 matthew Exp $	*/
d215 1
a215 1
				subdevice_mask = (1 << IOCDEV_SERIAL_A) |
@


1.36
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.35 2010/05/09 18:37:45 miod Exp $	*/
a51 2
#include <sgi/xbow/xbow.h>

a67 2
	struct mips_bus_space	*sc_mem_bus_space;

d184 1
a184 24
	/*
	 * Build a suitable bus_space_handle by restoring the original
	 * non-swapped subword access methods.
	 *
	 * XXX This is horrible and will need to be rethought if
	 * XXX we ever support ioc3 cards not plugged to xbridges.
	 */

	sc->sc_mem_bus_space = malloc(sizeof (*sc->sc_mem_bus_space),
	    M_DEVBUF, M_NOWAIT);
	if (sc->sc_mem_bus_space == NULL) {
		printf("%s: can't allocate bus_space\n", self->dv_xname);
		goto unmap;
	}

	bcopy(memt, sc->sc_mem_bus_space, sizeof(*sc->sc_mem_bus_space));
	sc->sc_mem_bus_space->_space_read_1 = xbow_read_1;
	sc->sc_mem_bus_space->_space_read_2 = xbow_read_2;
	sc->sc_mem_bus_space->_space_read_raw_2 = xbow_read_raw_2;
	sc->sc_mem_bus_space->_space_write_1 = xbow_write_1;
	sc->sc_mem_bus_space->_space_write_2 = xbow_write_2;
	sc->sc_mem_bus_space->_space_write_raw_2 = xbow_write_raw_2;

	sc->sc_memt = sc->sc_mem_bus_space;
@


1.35
log
@Proper support for IP35 C-Brick types (i.e. Origin 3000): do not attach
a (missing) second serial port to ioc(4), read spdmem(4) records from the
right index, and query the Ethernet address from the I-Brick eeprom instead
of the C-Brick eeprom.
Tested by Sebastian Reitenbach, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.34 2010/04/06 19:12:34 miod Exp $	*/
d777 1
a777 1
	evcount_attach(&ii->ii_count, name, &ii->ii_level, &evcount_intr);
@


1.34
log
@Obtain struct sgi_device_location for the console input and output devices,
and compare against them when attaching potential console drivers, to figure
out whether they indeed are acting are console devices or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.33 2010/03/20 16:22:53 miod Exp $	*/
d338 1
a338 4
				subdevice_mask = (1 << IOCDEV_SERIAL_A) |
				    (1 << IOCDEV_SERIAL_B) | (1 << IOCDEV_LPT) |
				    (1 << IOCDEV_KBC) | (1 << IOCDEV_RTC) |
				    (1 << IOCDEV_EF);
d347 28
a374 2
				if (sys_config.system_subtype == IP35_O300)
					subdevice_mask &= ~(1 << IOCDEV_KBC);
d505 3
a507 1
		ioc_attach_child(sc, "com", IOC3_UARTB_BASE, IOCDEV_SERIAL_B);
@


1.33
log
@Add code to tell Origin 200 and Origin 2000 / Onyx 2 apart.
Use this to correctly handle the onboard IOC3 chip configuration on O2k
(two IOC3 chips to be able to provide four serial ports, and the other
 subdevices are split accross the two IOC3 chips).
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.32 2010/03/07 13:44:26 miod Exp $	*/
a68 1
	int			 sc_npci;
d76 1
d174 1
a174 1
	sc->sc_npci = pa->pa_device;
d511 1
a511 3
	iaa.iaa_nasid = pci_get_nasid(sc->sc_pc);
	iaa.iaa_widget = pci_get_widget(sc->sc_pc);
	iaa.iaa_npci = sc->sc_npci;
@


1.32
log
@Allow iockbc(4) and odysseey(4) to act as console devices and attach early;
this gives us working glass console on Fuel, as well as on Octane systems
with Odyssey graphics.
Joint work with jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.31 2009/11/11 15:56:42 miod Exp $	*/
d5 1
a5 1
 * Copyright (c) 2008, 2009 Miodrag Vallat.
d118 4
a121 4
 * We use this to prevent attaching a pci IOC3 card which NIC has failed,
 * as the onboard IOC3.
 *
 * XXX This obviously will not work in N mode...
d277 7
d285 52
a336 4
		if ((sys_config.system_type == SGI_IP27 ||
		    sys_config.system_type == SGI_IP35) &&
		    !ISSET(ioc_nodemask, 1UL << currentnasid)) {
			SET(ioc_nodemask, 1UL << currentnasid);
d338 19
a356 14
			subdevice_mask = (1 << IOCDEV_SERIAL_A) |
			    (1 << IOCDEV_SERIAL_B) | (1 << IOCDEV_LPT) |
			    (1 << IOCDEV_KBC) | (1 << IOCDEV_RTC) |
			    (1 << IOCDEV_EF);
			/*
			 * Origin 300 onboard IOC3 do not have PS/2 ports;
			 * since they can only be connected to other 300 or
			 * 350 bricks (the latter using IOC4 devices),
			 * it is safe to do this regardless of the current
			 * nasid.
			 */
			if (sys_config.system_type == SGI_IP35 &&
			    sys_config.system_subtype == IP35_O300)
				subdevice_mask &= ~(1 << IOCDEV_KBC);
d358 1
d360 3
a362 1
			has_superio = has_enet = 1;
d365 1
a365 1
#endif
@


1.31
log
@Let ioc(4) pass the information whether it is an onboard device or not, to its
subdevices; use this on iockbc to only perform the fuel workaround on the
onboard ioc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.30 2009/11/11 15:29:29 miod Exp $	*/
d69 1
d174 1
d448 3
@


1.30
log
@It turns out PCI IOC3 card which embed both the Ethernet controller and the
superio chip interrupt on two different pins (yet do not advertize
themselves as a multi-function device, of course).

So, on one hand, this makes the ioc attachment code simpler, because it
simply needs to map interrupt pins A and B, and another hand, this moves
all the interrupt knowledge to the PCI bridge driver, since routing of pin
B differs whether the device is the onboard IOC3 chip (and able to use
any of the 8 bridge interrupt sources...) or on a PCI board (with pin
mapping sane, since controlled by the bridge).

This makes superio interrupts on CADduo boards work. Tested to cause
no regressions on Origin 200, Octane and Fuel.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.29 2009/11/09 16:57:47 miod Exp $	*/
a55 5
struct device *
	ioc_attach_child(struct device *, const char *, bus_addr_t, int);
int	ioc_search_onewire(struct device *, void *, void *);
int	ioc_search_mundane(struct device *, void *, void *);
int	ioc_print(void *, const char *);
d85 2
d97 5
d401 2
d416 2
a417 2
		ioc_attach_child(self, "com", IOC3_UARTA_BASE, IOCDEV_SERIAL_A);
		ioc_attach_child(self, "com", IOC3_UARTB_BASE, IOCDEV_SERIAL_B);
d420 1
a420 1
		ioc_attach_child(self, "iockbc", 0, IOCDEV_KBC);
d422 1
a422 1
		ioc_attach_child(self, "iec", 0, IOCDEV_EF);
d424 1
a424 1
		ioc_attach_child(self, "lpt", 0, IOCDEV_LPT);
d426 1
a426 1
		ioc_attach_child(self, "dsrtc", rtcbase, IOCDEV_RTC);
d437 3
a439 2
struct device *
ioc_attach_child(struct device *ioc, const char *name, bus_addr_t base, int dev)
a440 1
	struct ioc_softc *sc = (struct ioc_softc *)ioc;
d451 1
d473 1
a473 1
	return config_found_sm(ioc, &iaa, ioc_print, ioc_search_mundane);
@


1.29
log
@Only invoke the L1 code if IP35.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.28 2009/11/08 22:44:16 miod Exp $	*/
d82 2
a83 2
	void			*sc_ih1;	/* Ethernet interrupt */
	void			*sc_ih2;	/* SuperIO interrupt */
d155 1
a155 1
	pci_intr_handle_t ih1, ih2;
d159 3
a161 4
	uint32_t data;
	int dev;
	int dual_irq, shared_handler;
	int device_mask;
d225 3
a227 4
	printf("%s: ", self->dv_xname);

	dual_irq = shared_handler = 0;
	device_mask = 0;
d235 4
a238 3
			device_mask = (1 << IOCDEV_EF);
			if (pa->pa_device != 3)
				device_mask = (1 << IOCDEV_SERIAL_A) |
d240 2
a241 1
			shared_handler = 1;
d245 1
a245 1
			device_mask = (1 << IOCDEV_SERIAL_A) |
d250 2
a251 1
			dual_irq = 1;
d255 2
a256 2
			device_mask = (1 << IOCDEV_KBC) | (1 << IOCDEV_EF);
			shared_handler = 1;
d261 1
a261 1
			device_mask = (1 << IOCDEV_SERIAL_A) |
d263 2
a264 1
		} else {
a265 1
		}
d279 1
a279 1
			device_mask = (1 << IOCDEV_SERIAL_A) |
d292 1
a292 1
				device_mask &= ~(1 << IOCDEV_KBC);
d295 2
a296 1
			dual_irq = 1;
d307 1
a307 1
			printf("unknown flavour\n");
d313 16
d334 2
a335 6
	 * Since our pci layer doesn't handle this, we have to compute
	 * the superio interrupt cookie ourselves, with the help of the
	 * pci bridge driver.
	 *
	 * (What the above means is that you should wear peril-sensitive
	 * sunglasses from now on).
d337 4
a340 5
	 * To make things ever worse, some IOC3 boards (real boards, not
	 * on-board components) lack the Ethernet component. We should
	 * eventually handle them there, but it's not worth doing yet...
	 * (and we'll need to parse the ownum serial numbers to know
	 * this anyway)
d343 7
a349 3
	if (pci_intr_map(pa, &ih1) != 0) {
		printf("failed to map interrupt!\n");
		goto unmap;
d352 11
a362 29
	/*
	 * The second vector source seems to be the first unused PCI
	 * slot.
	 */
	if (dual_irq) {
		for (dev = 0;
		    dev < pci_bus_maxdevs(pa->pa_pc, pa->pa_bus); dev++) {
			pcitag_t tag;
			int line, rc;

			if (dev == pa->pa_device)
				continue;

			tag = pci_make_tag(pa->pa_pc, pa->pa_bus, dev, 0);
			if (pci_conf_read(pa->pa_pc, tag, PCI_ID_REG) !=
			    0xffffffff)
				continue;	/* slot in use... */

			line = pa->pa_intrline;
			pa->pa_intrline = dev;
			rc = pci_intr_map(pa, &ih2);
			pa->pa_intrline = line;

			if (rc != 0) {
				printf(": failed to map superio interrupt!\n");
				goto unmap;
			}

			goto establish;
a363 9

		/*
		 * There are no empty slots, thus we can't steal an
		 * interrupt. I don't know how IOC3 behaves in this
		 * situation, but it's probably safe to revert to
		 * a shared, single interrupt.
		 */
		shared_handler = 1;
		dual_irq = 0;
d366 7
a372 11
	if (dual_irq) {
establish:
		/*
		 * Register the second (superio) interrupt.
		 */

		sc->sc_ih2 = pci_intr_establish(sc->sc_pc, ih2, IPL_TTY,
		    ioc_intr_superio, sc, self->dv_xname);
		if (sc->sc_ih2 == NULL) {
			printf("failed to establish superio interrupt at %s\n",
			    pci_intr_string(sc->sc_pc, ih2));
a374 2

		printf("superio %s", pci_intr_string(sc->sc_pc, ih2));
d377 9
a385 12
	/*
	 * Register the main (Ethernet if available, superio otherwise)
	 * interrupt.
	 */

	sc->sc_ih1 = pci_intr_establish(sc->sc_pc, ih1, IPL_NET,
	    shared_handler ? ioc_intr_shared : ioc_intr_ethernet,
	    sc, self->dv_xname);
	if (sc->sc_ih1 == NULL) {
		printf("\n%s: failed to establish %sinterrupt!\n",
		    self->dv_xname, dual_irq ? "ethernet " : "");
		goto unregister;
a386 2
	printf("%s%s\n", dual_irq ? "; ethernet " : "",
	    pci_intr_string(sc->sc_pc, ih1));
d388 6
a393 15
	/*
	 * Acknowledge all pending interrupts, and disable them.
	 * Be careful not all registers may be wired depending on what
	 * devices are actually present.
	 */

	if ((device_mask & ~(1 << IOCDEV_EF)) != 0) {
		bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IEC, ~0x0);
		bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IES, 0x0);
		bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IR,
		    bus_space_read_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IR));
	}
	if ((device_mask & (1 << IOCDEV_EF)) != 0) {
		bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_ENET_IER, 0);
	}
d399 1
a399 1
	if (ISSET(device_mask, 1 << IOCDEV_SERIAL_A)) {
d415 1
a415 1
	if (ISSET(device_mask, 1 << IOCDEV_KBC))
d417 1
a417 1
	if (ISSET(device_mask, 1 << IOCDEV_EF))
d419 1
a419 1
	if (ISSET(device_mask, 1 << IOCDEV_LPT))
d421 1
a421 1
	if (ISSET(device_mask, 1 << IOCDEV_RTC))
d427 2
a428 2
	if (dual_irq)
		pci_intr_disestablish(sc->sc_pc, sc->sc_ih2);
@


1.28
log
@Add code to send L1 commands and parse command results; use it to add a way
for IP35 systems with IOC3 onboard Ethernet to get their Ethernet address
since it's no longer stored as an owmac(4) device on the IOC3 device itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.27 2009/11/08 13:10:03 miod Exp $	*/
d490 3
a492 2
			if (l1_get_brick_ethernet_address(currentnasid,
			    iaa.iaa_enaddr) != 0)
@


1.27
log
@Do not risk touching nonexisting registers on MENET boards; untested due to
lack of such hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.26 2009/11/07 22:48:37 miod Exp $	*/
d34 1
d36 2
d112 1
d121 1
d266 1
d276 1
a276 1
			SET(currentnasid, 1UL << currentnasid);
d295 3
a297 7
			/*
			 * XXX On IP35 class machines, there are no
			 * XXX Number-In-a-Can chips to tell us the
			 * XXX Ethernet address, we need to query
			 * XXX the L1 controller.
			 */
		} else {
d469 2
d478 17
a494 11
	if (sc->sc_owmac != NULL)
		memcpy(iaa.iaa_enaddr, sc->sc_owmac->sc_enaddr, 6);
	else {
		/*
		 * XXX On IP35, there is no Number-In-a-Can attached to
		 * XXX the onboard IOC3; instead, the Ethernet address
		 * XXX is stored in the machine eeprom and can be
		 * XXX queried by sending the appropriate L1 command
		 * XXX to the L1 UART. This L1 code is not written yet.
		 */
		memset(iaa.iaa_enaddr, 0xff, 6);
@


1.26
log
@In case an ioc(4) device has lost its NIC component, do not recognize it
as the onboard ioc device, if one has already been found on this node.

Also, on Origin 300, do not attempt to attach the PS/2 controller on the
onboard ioc(4) since PS/2 ports are not wired.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.25 2009/11/07 14:49:01 miod Exp $	*/
d227 9
a235 3
			/* MENET board */
			device_mask = (1 << IOCDEV_SERIAL_A) |
			    (1 << IOCDEV_SERIAL_B) | (1 << IOCDEV_EF);
d409 2
d413 7
a419 5
	bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IEC, ~0x0);
	bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IES, 0x0);
	bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IR,
	    bus_space_read_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IR));
	if (ISSET(device_mask, 1 << IOCDEV_EF))
d421 1
d434 5
@


1.25
log
@Change sgi system identification from a single system type list, to a smaller
system type list (which really is the system family) and a subsystem type.

No functional change yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.24 2009/11/02 17:20:47 miod Exp $	*/
d34 2
d109 9
d258 2
a259 1
		 * on IP27 and IP35 systems.
d261 5
a265 2
		if (sys_config.system_type == SGI_IP27 ||
		    sys_config.system_type == SGI_IP35) {
d270 11
@


1.24
log
@When the iec(4) Ethernet address is unkown, pass ff:ff:ff:ff:ff:ff instead of
00:00:00:00:00:00, in order to trigger the code which will assign a `feel bad'
random address.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.23 2009/11/01 19:17:56 miod Exp $	*/
d249 2
a250 2
		if (sys_config.system_type == SGI_O200 ||
		    sys_config.system_type == SGI_O300) {
d372 1
a372 1
	printf("%s%s\n", dual_irq ? ", ethernet " : "",
@


1.23
log
@Driver for the sgi IOC3 onboard Ethernet interface. Tested on Octane only so
far, and needs help to figure out its Ethernet address on IP35 systems.

Heavily derived from mec(4) written by Izumi Tsutsui and Christopher Sekiya,
although it required many changes to fit the IOC3 chip.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.22 2009/10/26 18:13:34 miod Exp $	*/
d442 1
a442 1
		bzero(iaa.iaa_enaddr, 6);
@


1.22
log
@Add support for the Octane power button to power(4). Took me a while to
figure out how the interrupt was routed from xbridge to xheart... (it bypasses
the regular `have xbridge send a xio interrupt packet' mechanism)
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.21 2009/08/18 19:32:47 miod Exp $	*/
a147 1
	struct device *child;
d201 3
d383 2
d402 3
a404 14
		ioc_attach_child(self, "iockbc", IOC3_KBC_BASE, IOCDEV_KBC);
	if (ISSET(device_mask, 1 << IOCDEV_EF)) {
		child = ioc_attach_child(self, "iec", IOC3_EF_BASE, IOCDEV_EF);
		if (dual_irq != 0 && child == NULL) {
			/*
			 * If we did not attach an ethernet driver and
			 * this is the dual interrupt design, unhook the
			 * network interrupt, because ARCS might have left
			 * interrupt conditions pending, which will not be
			 * acknowledged at the IOC3 driver level.
			 */
			pci_intr_disestablish(sc->sc_pc, sc->sc_ih1);
		}
	}
d406 1
a406 1
		ioc_attach_child(self, "lpt", IOC3_LPT_BASE, IOCDEV_LPT);
@


1.21
log
@Replace a few hardcoded numbers from the interrupt register with proper
commented symbolic constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.20 2009/08/18 19:29:09 miod Exp $	*/
d127 2
a128 1
	if ((int)iaa->iaa_base > 0)	/* no base for onewire */
d145 3
a147 1
	int dual_irq, shared_handler, has_ethernet, has_ps2, has_serial;
d211 1
a211 1
	has_ethernet = has_ps2 = has_serial = 0;
d215 2
a216 1
			has_ethernet = has_serial = 1;
d221 5
a225 1
			has_ethernet = has_ps2 = has_serial = 1;
d230 1
a230 1
			has_ps2 = has_ethernet = 1;
d236 2
a237 1
			has_serial = 1;
d249 5
a253 1
			has_ethernet = has_ps2 = has_serial = 1;
d386 8
a393 1
	if (has_serial) {
d397 1
a397 1
	if (has_ps2)
d399 1
a399 1
	if (has_ethernet) {
d412 4
a415 2
	/* XXX what about the parallel port? */
	ioc_attach_child(self, "dsrtc", 0 /* IOC3_RTC_BASE */, IOCDEV_RTC);
@


1.20
log
@On dual interrupt IOC3 designs, disestablish the ethernet interrupt if no
ethernet driver attaches; prevents interrupt storms on Octane caused by
the way ARCS initializes the chip, when not booting from the network.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.19 2009/07/26 19:58:51 miod Exp $	*/
d21 1
a21 1
 * IOC device driver.
a32 1
#include <machine/cpu.h>
d127 2
a128 2
	if ((int)iaa->iaa_base > 0)
		printf(" base 0x%08x", iaa->iaa_base);
d179 1
a179 1
		goto unregister2;
a359 4
	/* Initialise interrupt handling structures. */
	for (dev = 0; dev < IOC_NDEVS; dev++)
		sc->sc_intr[dev] = NULL;

d378 1
a378 1
		ioc_attach_child(self, "iockbc", 0, IOCDEV_KEYBOARD);
d393 1
a393 1
	ioc_attach_child(self, "dsrtc", 0, IOCDEV_RTC);
a396 2
unregister2:
	pci_intr_disestablish(sc->sc_pc, sc->sc_ih1);
d615 7
a621 7
const uint32_t ioc_intrbits[IOC_NDEVS] = {
	0x00000040,	/* serial A */
	0x00008000,	/* serial B */
	0x00040000,	/* parallel port */
	0x00400000,	/* PS/2 port */
	0x08000000,	/* rtc */
	0x00000000	/* Ethernet (handled differently) */
d657 1
a657 1
	uint32_t pending;
d670 2
a671 1
		if (pending & ioc_intrbits[dev]) {
d676 1
a676 1
			    IOC3_SIO_IR, pending & ioc_intrbits[dev]);
d678 1
a678 1
			    IOC3_SIO_IES, pending & ioc_intrbits[dev]);
@


1.19
log
@Rework ioc children attachment: instead of having ioc build a semi-bogus
bus_space_handle_t, pass them ioc's own bus_space_handle and bus_space_tag,
and have the children use bus_space_subregion() on it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.18 2009/07/01 21:56:37 miod Exp $	*/
d52 2
a53 1
void	ioc_attach_child(struct device *, const char *, bus_addr_t, int);
d146 1
d384 13
a396 2
	if (has_ethernet)
		ioc_attach_child(self, "iec", IOC3_EF_BASE, IOCDEV_EF);
d411 1
a411 1
void
d437 1
a437 1
	config_found_sm(ioc, &iaa, ioc_print, ioc_search_mundane);
@


1.18
log
@The widget mapping code has been written back when I was only working on
Octane support. The Octane being a single-node system, address space is
ludicrous enough to allow the whole address space of every widget to be
directly accessible in whole, using the address bits reserved to nasid.

However, on IP27 and IP35, things do not work this way - while we still have
the low 16MB address space of each widget available (the so-called
``short window''), access to other parts of the wiget address space is done
through translation slots (IOTTE) at the Hub I/O space level, on a per-node
basis.

Given the imminent release lock, give up completely on ``large'' mappings
of widgets, and restrict ourselves to short window operation, all the time
(thus reinforcing the use of devio registers to map pci resources on xbridge).
A proper interface to request mappings of specific widget areas, either
directly on Octane, or through IOTTE if available on Origin, will appear
post-release.

No functional change (except from silently repairing Octane support which the
previous xbridge commit silently broke).
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.17 2009/06/21 18:03:15 miod Exp $	*/
d161 1
d167 1
a167 2
	 * Build a suitable bus_space_handle by rebasing the xbridge
	 * inherited one to our BAR, and restoring the original
a181 1
	sc->sc_mem_bus_space->bus_base = memh;
a188 3
	/* XXX undo xbridge mapping games */
	sc->sc_mem_bus_space->_space_map = xbow_space_map;

d406 1
@


1.17
log
@Remove the ioc interrupt probe code, the heuristic is correct; origin 300
is still unhappy due to ``interferences'' between the L1 console and the
brick's serial ports, unfortunately.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.16 2009/05/27 19:04:45 miod Exp $	*/
d185 1
d188 1
d190 2
a191 3
	/* XXX undo IP27 xbridge weird mapping */
	if (sys_config.system_type != SGI_OCTANE)
		sc->sc_mem_bus_space->_space_map = xbow_space_map_short;
@


1.16
log
@Yet another attempt at a more reliable detection of the second interrupt
used by onboard IOC chips, by forcing the IOC to trigger this interrupt,
and some help from the PCI bridge driver to report which interrupt has
fired through a fake PCI configuration register.

This works nicely on IP27 and IP35, but on IP30 the interrupt doesn't
happen, for some reason; so keep the existing heuristic in case the above
trick did not give us a valid interrupt number.

In case we got an interrupt, this will also detect IOC configurations where
there is actually one interrupt, should such configurations exist.

<rant style="beck">
I probably deserve to rot in hell for this abomination, but I won't mind
as long as the IOC designers who came with the bright ``let's use more than
one interrupt and defecate on the pci spec'' ideas are there, too.
</rant>
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.15 2009/05/22 21:21:19 miod Exp $	*/
d271 1
a271 1
	 * pci bridge driver. This is ugly, and depends on xbridge knowledge.
a292 45
		/*
		 * First, try to get reliable interrupt information
		 * from the pci bridge.
		 *
		 * In order to do this, we trigger the superio interrupt
		 * and read a magic register in configuration space.
		 * See the xbridge code for details.
		 */

		/* enable TX empty interrupt */
		delay(20 * 1000);	/* let console output drain */
		bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IEC, ~0x0);
		bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IES,
		    0x0201);

		/* read pseudo interrupt register */
		data = pci_conf_read(pa->pa_pc, pa->pa_tag,
		    PCI_INTERRUPT_REG + 4);

		/* disable interrupt again */
		bus_space_write_4(sc->sc_memt, sc->sc_memh, IOC3_SIO_IEC,
		    0x0201);

		if (data != 0) {
			/*
			 * If the interrupt has been received as the
			 * regular PCI interrupt, then we probably don't
			 * have separate interrupts.
			 */
			if (PCI_INTERRUPT_LINE(data) == pa->pa_intrline)
				goto single;

			pa->pa_intrline = PCI_INTERRUPT_LINE(data);
			pa->pa_rawintrpin = pa->pa_intrpin =
			    PCI_INTERRUPT_PIN(data);

			if (pci_intr_map(pa, &ih2) == 0)
				goto establish;
		}

		/*
		 * If there was no bridge hint or it did not work, use the
		 * heuristic of picking the lowest free slot.
		 */

a324 1
single:
@


1.15
log
@According to pics on ebay, CADDuo boards indeed have Ethernet connectors.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.14 2009/05/08 18:36:11 miod Exp $	*/
d113 1
a113 1
            PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SGI_IOC3)
d269 3
a271 3
	 * Since our pci layer doesn't handle this, we cheat and compute
	 * the superio interrupt cookie ourselves. This is ugly, and
	 * depends on xbridge knowledge.
a290 12
	 *
	 * On Octane systems, the on-board IOC3 is device #2 and
	 * immediately followed by the RAD1 audio, device #3, thus
	 * the next empty slot is #4.
	 * XXX Is this still true with the Octane PCI cardcage?
	 *
	 * On Origin200 systems, there is no RAD1 audio, slot #3 is
	 * empty (available PCI slots are #5-#7).
	 *
	 * On Fuel systems, the on-board IOC3 is device #4,
	 * with the USB controller being device #5, and slot #6
	 * is empty (available PCI slots are on a different bridge).
d293 45
d341 1
d347 13
a359 10
			if (pci_conf_read(pa->pa_pc, tag, PCI_ID_REG) ==
			    0xffffffff) {
				pa->pa_tag = tag;
				if (pci_intr_map(pa, &ih2) != 0) {
					printf(": failed to map superio"
					    " interrupt!\n");
					goto unmap;
				}
				pa->pa_tag = pci_make_tag(pa->pa_pc, pa->pa_bus,
				    pa->pa_device, pa->pa_function);
d361 1
a361 2
				goto establish;
			}
d370 1
d380 1
d384 2
a385 1
			printf("failed to establish superio interrupt!\n");
d396 1
d415 1
d432 1
a432 1
		ioc_attach_child(self, "ef", IOC3_EF_BASE, IOCDEV_EF);
d487 1
a487 1
        return (*cf->cf_attach->ca_match)(parent, cf, iaa);
d523 2
a524 2
        if ((*cf->cf_attach->ca_match)(parent, cf, &oba) == 0)
                return 0;
d670 1
a670 1
        struct ioc_softc *sc = cookie;
d751 1
a751 1
               		ii->ii_count.ec_count++;
@


1.14
log
@Attach children with config_found_sm() instead of directly invoking
config_search(), so that disabled or unconfigured child device appear in
dmesg as ``not configured''.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.13 2009/05/03 19:42:45 miod Exp $	*/
d224 2
a225 5
			has_ps2 = 1;
			/*
			 * XXX This card supposedly has the Ethernet part, too.
			 */
			/* has_ethernet = 1; shared_handler = 1; */
@


1.13
log
@Pass 0 as base offset, not -1, for child devices which ignore the value.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.12 2009/05/02 21:31:21 miod Exp $	*/
d388 2
a389 2
		ioc_attach_child(self, "com", 0x20178, IOCDEV_SERIAL_A);
		ioc_attach_child(self, "com", 0x20170, IOCDEV_SERIAL_B);
d394 1
a394 1
		ioc_attach_child(self, "ef", 0, IOCDEV_EF);
d434 1
a434 1
	config_search(ioc_search_mundane, ioc, &iaa);
d449 1
a449 5
        if ((*cf->cf_attach->ca_match)(parent, cf, iaa) == 0)
                return 0;

	config_attach(parent, cf, iaa, ioc_print);
	return 1;
@


1.12
log
@Let ioc(4) decide which child devices to attach depending on its identification
information, instead of trying to attach whatever is defined in the
kernel configuration file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.11 2009/04/25 20:37:30 miod Exp $	*/
d392 1
a392 1
		ioc_attach_child(self, "iockbc", -1, IOCDEV_KEYBOARD);
d394 1
a394 1
		ioc_attach_child(self, "ef", -1, IOCDEV_EF);
d396 1
a396 1
	ioc_attach_child(self, "dsrtc", -1, IOCDEV_RTC);
@


1.11
log
@More IOC3 flavour partnumbers. And apparently there are some flavours which
have a shared ethernet/superio interrupt source, so deal with this.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.10 2009/04/24 18:16:46 miod Exp $	*/
d52 1
d127 1
a127 1
	if (iaa->iaa_base != 0)
a128 2
	if (iaa->iaa_dev != 0)
		printf(" dev %d", iaa->iaa_dev);
d292 1
a292 1
	 * The second vector source seems to be the next unused PCI
d294 1
d299 2
a300 1
	 * On Origin systems, there is no RAD1 audio, slot #3 is
d302 2
a303 1
	 * And on Fuel systems, the on-board IOC3 is device #4,
d387 10
a396 2
	/* XXX need to limit search depending upon has_xxx values */
	config_search(ioc_search_mundane, self, aux);
d409 2
a410 2
int
ioc_search_mundane(struct device *parent, void *vcf, void *args)
d412 1
a412 2
	struct ioc_softc *sc = (struct ioc_softc *)parent;
	struct cfdata *cf = vcf;
d415 1
a415 4
	if (strcmp(cf->cf_driver->cd_name, "onewire") == 0)
		return 0;

	iaa.iaa_name = cf->cf_driver->cd_name;
d418 2
a419 9

	if (cf->cf_loc[0] == -1)
		iaa.iaa_base = 0;
	else
		iaa.iaa_base = cf->cf_loc[0];
	if (cf->cf_loc[1] == -1)
		iaa.iaa_dev = 0;
	else
		iaa.iaa_dev = cf->cf_loc[1];
d423 8
a430 1
	else
d432 16
d449 1
a449 1
        if ((*cf->cf_attach->ca_match)(parent, cf, &iaa) == 0)
d452 1
a452 1
	config_attach(parent, cf, &iaa, ioc_print);
a638 1
	dev--;
@


1.10
log
@Fix the superio irq discovery heuristic to work on systems where there is
an empty slot before the ioc card (such as on Fuel).
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.9 2009/04/19 18:36:07 miod Exp $	*/
d96 1
d145 1
a145 1
	int dual_irq, has_ethernet, has_ps2, has_serial;
d210 1
a210 1
	dual_irq = 0;
d213 5
d227 1
a227 5
			 * XXX This card supposedly has the Ethernet part,
			 * XXX too. If this is true, then it is likely than
			 * XXX they share the single interrupt; the
			 * XXX existing ioc3 interrupt code will need to
			 * XXX cope with this.
d229 1
a229 1
			/* has_ethernet = 1; */
d233 1
d248 6
a328 1
		printf("could not discover superio interrupt!\n");
d330 4
a333 2
		 * XXX Then we'd probably use a shared interrupt
		 * XXX handler there.
d335 3
a337 1
		goto unmap;
d339 1
d359 2
a360 1
	    ioc_intr_ethernet, sc, self->dv_xname);
d678 6
@


1.9
log
@Attach the 1-Wire devices early, and pick our partnumber; based on this
partnumber, decide what components of the IOC3 really are available, and
how many interrupts to register.

Based on knowledge found in Linux source code, only tested on full-blown
IOC3 devices so far.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.8 2009/04/19 16:10:40 jsing Exp $	*/
d220 8
d297 1
a297 1
		for (dev = pa->pa_device + 1;
d301 3
d321 4
d370 2
@


1.8
log
@Use correct device index for Ethernet interrupt handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.6 2009/04/18 14:47:25 miod Exp $	*/
d46 1
d76 2
a77 2
	void			*sc_sih;	/* SuperIO interrupt */
	void			*sc_eih;	/* Ethernet interrupt */
d83 1
d138 1
a138 1
	pci_intr_handle_t sih, eih;
d144 1
d163 87
d252 3
a254 2
	 * of convenience chips. And it actually needs to use two interrupts,
	 * one for the superio chip, and the other for the Ethernet chip.
d270 2
a271 2
	if (pci_intr_map(pa, &eih) != 0) {
		printf(": failed to map interrupt!\n");
d288 18
a305 10
	for (dev = pa->pa_device + 1;
	    dev < pci_bus_maxdevs(pa->pa_pc, pa->pa_bus); dev++) {
		pcitag_t tag;

		tag = pci_make_tag(pa->pa_pc, pa->pa_bus, dev, 0);
		if (pci_conf_read(pa->pa_pc, tag, PCI_ID_REG) == 0xffffffff) {
			pa->pa_tag = tag;
			if (pci_intr_map(pa, &sih) != 0) {
				printf(": failed to map superio interrupt!\n");
				goto unmap;
a306 4
			pa->pa_tag = pci_make_tag(pa->pa_pc, pa->pa_bus,
			    pa->pa_device, pa->pa_function);

			goto establish;
a307 1
	}
d309 2
a310 2
	printf(": could not discover superio interrupt!\n");
	goto unmap;
d313 11
a323 8
	/*
	 * Register the superio interrupt.
	 */
	sc->sc_sih = pci_intr_establish(sc->sc_pc, sih, IPL_TTY,
	    ioc_intr_superio, sc, self->dv_xname);
	if (sc->sc_sih == NULL) {
		printf(": failed to establish superio interrupt!\n");
		goto unmap;
a324 1
	printf(": superio %s", pci_intr_string(sc->sc_pc, sih));
d327 2
a328 1
	 * Register the ethernet interrupt.
d330 1
a330 1
	sc->sc_eih = pci_intr_establish(sc->sc_pc, eih, IPL_NET,
d332 3
a334 3
	if (sc->sc_eih == NULL) {
		printf("\n%s: failed to establish ethernet interrupt!\n",
		    self->dv_xname);
d337 2
a338 31
	printf(", ethernet %s\n", pci_intr_string(sc->sc_pc, eih));

	/*
	 * Build a suitable bus_space_handle by rebasing the xbridge
	 * inherited one to our BAR, and restoring the original
	 * non-swapped subword access methods.
	 *
	 * XXX This is horrible and will need to be rethought if
	 * XXX we ever support ioc3 cards not plugged to xbridges.
	 */

	sc->sc_mem_bus_space = malloc(sizeof (*sc->sc_mem_bus_space),
	    M_DEVBUF, M_NOWAIT);
	if (sc->sc_mem_bus_space == NULL) {
		printf("%s: can't allocate bus_space\n", self->dv_xname);
		goto unregister2;
	}

	bcopy(memt, sc->sc_mem_bus_space, sizeof(*sc->sc_mem_bus_space));
	sc->sc_mem_bus_space->bus_base = memh;
	sc->sc_mem_bus_space->_space_read_1 = xbow_read_1;
	sc->sc_mem_bus_space->_space_read_2 = xbow_read_2;
	sc->sc_mem_bus_space->_space_write_1 = xbow_write_1;
	sc->sc_mem_bus_space->_space_write_2 = xbow_write_2;

	/* XXX undo IP27 xbridge weird mapping */
	if (sys_config.system_type != SGI_OCTANE)
		sc->sc_mem_bus_space->_space_map = xbow_space_map_short;

	sc->sc_memt = sc->sc_mem_bus_space;
	sc->sc_memh = memh;
a352 6
	 * Attach the 1-Wire interface first, other sub-devices may
	 * need the information they'll provide.
	 */
	config_search(ioc_search_onewire, self, aux);

	/*
d360 1
a360 1
	pci_intr_disestablish(sc->sc_pc, sc->sc_eih);
d362 2
a363 1
	pci_intr_disestablish(sc->sc_pc, sc->sc_sih);
d415 2
d454 21
d646 1
a646 1
	return ioc_intr_dispatch(sc, IOCDEV_EF - 1);
@


1.7
log
@A much more reliable logic to find out the second interrupt of the ioc boards.
@
text
@d559 2
a560 2
	/* this interrupt source is not shared between several devices. */
	return ioc_intr_dispatch(sc, IOCDEV_EF);
@


1.6
log
@Simplify ethernet interrupt dispatching, since it is not shared with anything
else.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.5 2009/04/15 18:41:32 miod Exp $	*/
d193 3
d197 13
a209 4
	if (sys_config.system_type == SGI_OCTANE)
		sih = eih + 2;	/* XXX ACK GAG BARF */
	else
		sih = eih + 1;	/* XXX ACK GAG BARF */
d211 8
@


1.5
log
@Only enable the passthrough interrupt for serial ports, and let com(4) manage.
Otherwise we get stuck interrupted by the ``tx empty'' condition.

Also, on Origin 200 the second interrupt vector has to be computed
differently, which adds to the ``I wish I never had looked at this code''
trauma.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.4 2009/04/13 21:17:54 miod Exp $	*/
a44 3
#if 0
#include <sgi/dev/if_efreg.h>
#endif
d92 1
a92 1
void	ioc_intr_dispatch(struct ioc_softc *, int);
d521 1
a521 1
			ioc_intr_dispatch(sc, dev);
a536 1
#if 0
a537 1
	uint32_t stat;
d539 2
a540 12
	stat = bus_space_read_4(sc->sc_memt, sc->sc_memh, EF_INTR_STATUS);

	if (stat == 0)
		return 0;

	ioc_intr_dispatch(sc, IOCDEV_EF);
	bus_space_write_4(sc->sc_memt, sc->sc_memh, EF_INTR_STATUS, stat);

	return 1;
#else
	return 0;
#endif
d543 1
a543 1
void
d547 1
d551 2
a552 1
		if ((*ii->ii_func)(ii->ii_arg) != 0)
d555 2
@


1.4
log
@The start of Origin 200 support. Based on some code contributed by pefo@@
some years ago for KL enumeration, building on the existing XBow support
to limit ourselves to a single node for now.

This is a work-in-progress; it currently lacks complete interrupt code,
as well as PCI resource management. And there are likely bugs creeping
inside.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.3 2009/04/12 17:56:58 miod Exp $	*/
d186 15
a200 1
	sih = eih + 2;	/* XXX ACK GAG BARF */
d211 1
d219 2
a220 1
		printf(": failed to establish ethernet interrupt!\n");
d223 1
a223 3

	printf(": superio %s", pci_intr_string(sc->sc_pc, sih));
	printf(", ethernet %s", pci_intr_string(sc->sc_pc, eih));
d237 1
a237 1
		printf(": can't allocate bus_space\n");
d463 3
a465 2
 * We intentionnaly mask the RX high water bits, as they apparently never
 * clear on some machines regardless of what we do.
d468 6
a473 6
	0x000001ff & ~0x00000004,	/* serial A */
	0x0003fe00 & ~0x00000800,	/* serial B */
	0x003c0000,			/* parallel port */
	0x00400000,			/* PS/2 port */
	0x08000000,			/* rtc */
	0x00000000			/* Ethernet (handled differently) */
@


1.3
log
@Interrupt support for IOC3 and its subdevices (currently limited to the
SuperIO part, the Ethernet part needs a whole driver); kernel now boot
single user (or bsd.rd). Joint work with jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.2 2009/03/29 21:53:52 sthen Exp $	*/
d30 1
d45 1
d47 1
d234 4
d525 1
d538 3
@


1.2
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioc.c,v 1.1 2008/04/07 22:53:00 miod Exp $	*/
d5 1
a5 1
 * Copyright (c) 2008 Miodrag Vallat.
d44 1
d55 10
d73 5
d92 4
d125 2
a126 2
	if (iaa->iaa_intr != 0)
		printf(" irq %d", iaa->iaa_intr);
d136 1
d140 2
d149 1
d153 56
a219 1
		bus_space_unmap(memt, memh, memsize);
d221 1
a221 1
		return;
d234 11
a244 1
	printf("\n");
d256 9
d286 1
a286 1
		iaa.iaa_intr = 0;
d288 1
a288 1
		iaa.iaa_intr = cf->cf_loc[1];
d332 1
a332 1
	/* in case onewire is disabled in UKC */
d433 109
@


1.1
log
@Preliminary IOC3 multi-function chip driver, from jsing@@ and I. Currently
missing a driver for the ethernet part, and interrupt handling is not written
yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d122 1
a122 1
		printf(": cannot map memory space!\n");
d141 1
a141 1
		printf(": cannot allocate bus_space\n");
@

