head	1.47;
access;
symbols
	OPENBSD_6_1:1.47.0.14
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.47.0.10
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.47.0.6
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.47.0.8
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.45.0.8
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.45.0.4
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.45.0.2
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.44.0.2
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.2
	OPENBSD_5_0:1.41.0.4
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.2
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.21.0.2
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.47
date	2014.05.19.21.18.42;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2014.04.03.08.07.16;	author mpi;	state Exp;
branches;
next	1.45;

1.45
date	2012.09.29.18.54.39;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2012.03.15.18.52.56;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2011.10.10.19.49.16;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2011.10.10.19.42.36;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2010.12.04.17.06.31;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2010.09.22.02.28.37;	author jsg;	state Exp;
branches;
next	1.39;

1.39
date	2010.08.23.16.56.18;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2010.04.06.19.12.34;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2010.03.07.13.38.58;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.26.18.00.06;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.22.20.52.39;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2009.10.22.20.51.09;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2009.08.22.02.54.51;	author mk;	state Exp;
branches;
next	1.32;

1.32
date	2009.08.09.12.36.33;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.08.09.08.16.53;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2009.07.26.19.57.45;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2009.07.22.21.29.04;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2009.07.22.21.28.44;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2009.07.22.20.28.21;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2009.07.21.21.25.19;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2009.07.19.19.02.03;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.17.18.06.51;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.07.16.21.02.56;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.16.21.00.51;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2009.04.25.15.28.59;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2009.04.19.15.13.06;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2009.04.18.19.26.16;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.03.30.09.41.00;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2008.07.30.17.37.46;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2008.07.30.17.32.30;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2008.02.20.18.46.20;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2008.02.16.18.42.21;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.18.04.32.27;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.21.20.17.12;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.14.17.36.12;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.13.20.10.49;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.04.20.23.09;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.04.20.20.18;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.31.21.35.50;	author grange;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.20.12.49.15;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.24.14.22.49;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.20.10.31.16;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.11.15.13.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.10.19.16.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.21.12.19;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Format string fixes and removal of -Wno-format for sgi. Based upon an
initial diff from jasper@@
@
text
@/*	$OpenBSD: macepcibridge.c,v 1.46 2014/04/03 08:07:16 mpi Exp $ */

/*
 * Copyright (c) 2009 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 2001-2004 Opsycon AB (www.opsycon.se)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * Machine dependent PCI BUS Bridge driver on Mace (O2).
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/ioctl.h>
#include <sys/extent.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/vmparam.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/ppbreg.h>
#include <dev/pci/pcidevs.h>

#include <dev/cardbus/rbus.h>

#include <mips64/archtype.h>
#include <sgi/localbus/crimebus.h>
#include <sgi/localbus/macebus.h>
#include <sgi/localbus/macebusvar.h>
#include <sgi/pci/macepcibrvar.h>

#include "cardbus.h"

int	 mace_pcibrmatch(struct device *, void *, void *);
void	 mace_pcibrattach(struct device *, struct device *, void *);

void	 mace_pcibr_attach_hook(struct device *, struct device *,
	    struct pcibus_attach_args *);
int	 mace_pcibr_bus_maxdevs(void *, int);
pcitag_t mace_pcibr_make_tag(void *, int, int, int);
void	 mace_pcibr_decompose_tag(void *, pcitag_t, int *, int *, int *);
int	 mace_pcibr_conf_size(void *, pcitag_t);
pcireg_t mace_pcibr_conf_read(void *, pcitag_t, int);
void	 mace_pcibr_conf_write(void *, pcitag_t, int, pcireg_t);
int	 mace_pcibr_probe_device_hook(void *, struct pci_attach_args *);
int	 mace_pcibr_get_widget(void *);
int	 mace_pcibr_get_dl(void *, pcitag_t, struct sgi_device_location *);
int	 mace_pcibr_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
const char *mace_pcibr_intr_string(void *, pci_intr_handle_t);
void	*mace_pcibr_intr_establish(void *, pci_intr_handle_t, int,
	    int (*)(void *), void *, const char *);
void	 mace_pcibr_intr_disestablish(void *, void *);
int	 mace_pcibr_intr_line(void *, pci_intr_handle_t);
int	 mace_pcibr_ppb_setup(void *, pcitag_t, bus_addr_t *, bus_addr_t *,
	    bus_addr_t *, bus_addr_t *);
void	*mace_pcibr_rbus_parent_io(struct pci_attach_args *);
void	*mace_pcibr_rbus_parent_mem(struct pci_attach_args *);

void	*mace_pcib_space_vaddr(bus_space_tag_t, bus_space_handle_t);
void	 mace_pcib_space_barrier(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, bus_size_t, int);
bus_addr_t mace_pcibr_pa_to_device(paddr_t);
paddr_t	 mace_pcibr_device_to_pa(bus_addr_t);

int	mace_pcibr_rbus_space_map(bus_space_tag_t, bus_addr_t, bus_size_t,
	    int, bus_space_handle_t *);
void	mace_pcibr_rbus_space_unmap(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, bus_addr_t *);

void	mace_pcibr_configure(struct mace_pcibr_softc *);
void	mace_pcibr_device_fixup(struct mace_pcibr_softc *, int, int);
int	mace_pcibr_errintr(void *);

struct cfattach macepcibr_ca = {
	sizeof(struct mace_pcibr_softc), mace_pcibrmatch, mace_pcibrattach,
};

struct cfdriver macepcibr_cd = {
	NULL, "macepcibr", DV_DULL,
};

bus_space_t mace_pcibbus_mem_tag = {
	PHYS_TO_XKPHYS(MACE_PCI_MEM_BASE, CCA_NC),
	NULL,
	mace_pcib_read_1, mace_pcib_write_1,
	mace_pcib_read_2, mace_pcib_write_2,
	mace_pcib_read_4, mace_pcib_write_4,
	mace_pcib_read_8, mace_pcib_write_8,
	mace_pcib_read_raw_2, mace_pcib_write_raw_2,
	mace_pcib_read_raw_4, mace_pcib_write_raw_4,
	mace_pcib_read_raw_8, mace_pcib_write_raw_8,
	mace_pcib_space_map, mace_pcib_space_unmap, mace_pcib_space_region,
	mace_pcib_space_vaddr, mace_pcib_space_barrier
};

bus_space_t mace_pcibbus_io_tag = {
	PHYS_TO_XKPHYS(MACE_PCI_IO_BASE, CCA_NC),
	NULL,
	mace_pcib_read_1, mace_pcib_write_1,
	mace_pcib_read_2, mace_pcib_write_2,
	mace_pcib_read_4, mace_pcib_write_4,
	mace_pcib_read_8, mace_pcib_write_8,
	mace_pcib_read_raw_2, mace_pcib_write_raw_2,
	mace_pcib_read_raw_4, mace_pcib_write_raw_4,
	mace_pcib_read_raw_8, mace_pcib_write_raw_8,
	mace_pcib_space_map, mace_pcib_space_unmap, mace_pcib_space_region,
	mace_pcib_space_vaddr, mace_pcib_space_barrier
};

static const struct mips_pci_chipset mace_pci_chipset = {
	.pc_attach_hook = mace_pcibr_attach_hook,
	.pc_bus_maxdevs = mace_pcibr_bus_maxdevs,
	.pc_make_tag = mace_pcibr_make_tag,
	.pc_decompose_tag = mace_pcibr_decompose_tag,
	.pc_conf_size = mace_pcibr_conf_size,
	.pc_conf_read = mace_pcibr_conf_read,
	.pc_conf_write = mace_pcibr_conf_write,
	.pc_probe_device_hook = mace_pcibr_probe_device_hook,
	.pc_get_widget = mace_pcibr_get_widget,
	.pc_get_dl = mace_pcibr_get_dl,
	.pc_intr_map = mace_pcibr_intr_map,
	.pc_intr_string = mace_pcibr_intr_string,
	.pc_intr_establish = mace_pcibr_intr_establish,
	.pc_intr_disestablish = mace_pcibr_intr_disestablish,
	.pc_intr_line = mace_pcibr_intr_line,
	.pc_ppb_setup = mace_pcibr_ppb_setup,
#if NCARDBUS > 0
	.pc_rbus_parent_io = mace_pcibr_rbus_parent_io,
	.pc_rbus_parent_mem = mace_pcibr_rbus_parent_mem
#endif
};

/*
 * PCI doesn't have any special needs; just use the generic versions
 * of these functions.
 */
struct machine_bus_dma_tag mace_pci_bus_dma_tag = {
	NULL,                   /* _cookie */
	_dmamap_create,
	_dmamap_destroy,
	_dmamap_load,
	_dmamap_load_mbuf,
	_dmamap_load_uio,
	_dmamap_load_raw,
	_dmamap_load_buffer,
	_dmamap_unload,
	_dmamap_sync,
	_dmamem_alloc,
	_dmamem_free,
	_dmamem_map,
	_dmamem_unmap,
	_dmamem_mmap,
	mace_pcibr_pa_to_device,
	mace_pcibr_device_to_pa,
	CRIME_MEMORY_MASK
};

const struct _perr_map {
	pcireg_t mask;
	pcireg_t flag;
	const char *text;
} perr_map[] = {
  { PERR_MASTER_ABORT,	PERR_MASTER_ABORT_ADDR_VALID,	"master abort" },
  { PERR_TARGET_ABORT,	PERR_TARGET_ABORT_ADDR_VALID,	"target abort" },
  { PERR_DATA_PARITY_ERR,PERR_DATA_PARITY_ADDR_VALID,	"data parity error" },
  { PERR_RETRY_ERR,	PERR_RETRY_ADDR_VALID,	"retry error" },
  { PERR_ILLEGAL_CMD,	0,	"illegal command" },
  { PERR_SYSTEM_ERR,	0,	"system error" },
  { PERR_INTERRUPT_TEST,0,	"interrupt test" },
  { PERR_PARITY_ERR,	0,	"parity error" },
  { PERR_OVERRUN,	0,	"overrun error" },
  { PERR_RSVD,		0,	"reserved ??" },
  { PERR_MEMORY_ADDR,	0,	"memory address" },
  { PERR_CONFIG_ADDR,	0,	"config address" },
  { 0, 0, NULL }
};

static int mace_pcibrprint(void *, const char *pnp);

int
mace_pcibrmatch(struct device *parent, void *match, void *aux)
{
	switch (sys_config.system_type) {
	case SGI_O2:
		return 1;
	default:
		return 0;
	}
}

void
mace_pcibrattach(struct device *parent, struct device *self, void *aux)
{
	struct mace_pcibr_softc *sc = (struct mace_pcibr_softc *)self;
	struct pcibus_attach_args pba;
	struct macebus_attach_args *maa = aux;
	pcireg_t pcireg;

	sc->sc_mem_bus_space = &mace_pcibbus_mem_tag;
	sc->sc_io_bus_space = &mace_pcibbus_io_tag;

	/* Map in PCI control registers */
	sc->sc_memt = maa->maa_memt;
	if (bus_space_map(sc->sc_memt, maa->maa_baseaddr, 4096, 0,
	    &sc->sc_memh)) {
		printf(": can't map PCI control registers\n");
		return;
	}
	pcireg = bus_space_read_4(sc->sc_memt, sc->sc_memh, MACE_PCI_REVISION);

	printf(": mace rev %d\n", pcireg);

	/* Register the PCI ERROR interrupt handler */
	macebus_intr_establish(maa->maa_intr, maa->maa_mace_intr,
	    IST_LEVEL, IPL_HIGH, mace_pcibr_errintr, sc, sc->sc_dev.dv_xname);

	bcopy(&mace_pci_chipset, &sc->sc_pc, sizeof(mace_pci_chipset));
	sc->sc_pc.pc_conf_v = sc;
	sc->sc_pc.pc_intr_v = NULL;

	/*
	 * The O2 firmware sucks.  It makes a mess of I/O BARs and
	 * an even bigger mess for PCI-PCI bridges.
	 */
	mace_pcibr_configure(sc);

	/*
	 *  Configure our PCI devices.
	 */
	bzero(&pba, sizeof(pba));
	pba.pba_busname = "pci";
	pba.pba_iot = sc->sc_io_bus_space;
	pba.pba_memt = sc->sc_mem_bus_space;
	pba.pba_dmat = &mace_pci_bus_dma_tag;
	pba.pba_pc = &sc->sc_pc;
	pba.pba_ioex = extent_create("mace_io", 0, 0xffffffff, M_DEVBUF,
	    NULL, 0, EX_NOWAIT | EX_FILLED);
	if (pba.pba_ioex != NULL) {
		/*
		 * I/O accesses at address zero cause PCI errors, so
		 * make sure the first few bytes are not available.
		 */
		extent_free(pba.pba_ioex, 0x20, (1UL << 32) - 0x20, EX_NOWAIT);
	}
	pba.pba_memex = extent_create("mace_mem", 0, 0xffffffff, M_DEVBUF,
	    NULL, 0, EX_NOWAIT | EX_FILLED);
	if (pba.pba_memex != NULL)
		extent_free(pba.pba_memex, MACE_PCI_MEM_OFFSET,
		    MACE_PCI_MEM_SIZE, EX_NOWAIT);
	pba.pba_domain = pci_ndomains++;
	pba.pba_bus = 0;
	config_found(self, &pba, mace_pcibrprint);

	/* Clear PCI errors and set up error interrupt */
	bus_space_write_4(sc->sc_memt, sc->sc_memh, MACE_PCI_ERROR_FLAGS, 0);
	pcireg = bus_space_read_4(sc->sc_memt, sc->sc_memh, MACE_PCI_CONTROL);
	pcireg |= MACE_PCI_INTCTRL;
	bus_space_write_4(sc->sc_memt, sc->sc_memh, MACE_PCI_CONTROL, pcireg);
}

static int
mace_pcibrprint(void *aux, const char *pnp)
{
	struct pcibus_attach_args *pba = aux;

	if (pnp)
		printf("%s at %s", pba->pba_busname, pnp);
	printf(" bus %d", pba->pba_bus);
	return (UNCONF);
}

void
mace_pcibr_attach_hook(struct device *parent, struct device *self,
    struct pcibus_attach_args *pba)
{
}

int
mace_pcibr_errintr(void *v)
{
	struct mace_pcibr_softc *sc = v;
	bus_space_tag_t memt = sc->sc_memt;
	bus_space_handle_t memh = sc->sc_memh;
	const struct _perr_map *emap = perr_map;
	pcireg_t stat, erraddr;

	/* Check and clear any PCI error, report found */
	stat = bus_space_read_4(memt, memh, MACE_PCI_ERROR_FLAGS);
	erraddr = bus_space_read_4(memt, memh, MACE_PCI_ERROR_ADDRESS);
	while (emap->mask) {
		if (stat & emap->mask) {
			printf("mace: pci err %s", emap->text);
			if (emap->flag && stat & emap->flag)
				printf(" at address 0x%08x", erraddr);
			printf("\n");
		}
		emap++;
	}
	bus_space_write_4(memt, memh, MACE_PCI_ERROR_FLAGS, 0);
	return 1;
}

/*
 *  PCI access drivers
 */

pcitag_t
mace_pcibr_make_tag(void *cpv, int bus, int dev, int fnc)
{
	return (bus << 16) | (dev << 11) | (fnc << 8);
}

void
mace_pcibr_decompose_tag(void *cpv, pcitag_t tag, int *busp, int *devp,
    int *fncp)
{
	if (busp != NULL)
		*busp = (tag >> 16) & 0xff;
	if (devp != NULL)
		*devp = (tag >> 11) & 0x1f;
	if (fncp != NULL)
		*fncp = (tag >> 8) & 0x7;
}

int
mace_pcibr_bus_maxdevs(void *cpv, int busno)
{
	return busno == 0 ? 6 : 32;
}

int
mace_pcibr_conf_size(void *cpv, pcitag_t tag)
{
	return PCI_CONFIG_SPACE_SIZE;
}

pcireg_t
mace_pcibr_conf_read(void *cpv, pcitag_t tag, int offset)
{
	struct mace_pcibr_softc *sc = cpv;
	bus_space_tag_t memt = sc->sc_memt;
	bus_space_handle_t memh = sc->sc_memh;
	pcireg_t data, stat;
	int bus, dev;
	int s;

	s = splhigh();

	bus_space_write_4(memt, memh, MACE_PCI_ERROR_FLAGS, 0);
	data = tag | offset;
	bus_space_write_4(memt, memh, MACE_PCI_CFGADDR, data);
	data = bus_space_read_4(memt, memh, MACE_PCI_CFGDATA);
	bus_space_write_4(memt, memh, MACE_PCI_CFGADDR, 0);

	/*
	 * Onboard ahc on O2 can do Ultra speed despite not
	 * having SEEPROM nor external precision resistors.
	 */
	mace_pcibr_decompose_tag(cpv, tag, &bus, &dev, NULL);
	if (bus == 0 && (dev == 1 || dev == 2) && offset == 0x40)
		data |= 0x1000;	/* REXTVALID */

	/* Check and clear any PCI error, returns -1 if error is found */
	stat = bus_space_read_4(memt, memh, MACE_PCI_ERROR_FLAGS);
	bus_space_write_4(memt, memh, MACE_PCI_ERROR_FLAGS, 0);
	if (stat & (PERR_MASTER_ABORT | PERR_TARGET_ABORT |
		    PERR_DATA_PARITY_ERR | PERR_RETRY_ERR)) {
		data = -1;
	}

	splx(s);
	return(data);
}

void
mace_pcibr_conf_write(void *cpv, pcitag_t tag, int offset, pcireg_t data)
{
	struct mace_pcibr_softc *sc = cpv;
	pcireg_t addr;
	int s;

	s = splhigh();

	addr = tag | offset;
	bus_space_write_4(sc->sc_memt, sc->sc_memh, MACE_PCI_CFGADDR, addr);
	bus_space_write_4(sc->sc_memt, sc->sc_memh, MACE_PCI_CFGDATA, data);
	bus_space_write_4(sc->sc_memt, sc->sc_memh, MACE_PCI_CFGADDR, 0);

	splx(s);
}

int
mace_pcibr_probe_device_hook(void *unused, struct pci_attach_args *notused)
{
	return 0;
}

int
mace_pcibr_get_widget(void *unused)
{
	return 0;
}

int
mace_pcibr_get_dl(void *cpv, pcitag_t tag, struct sgi_device_location *sdl)
{
	int bus, device, fn;

	memset(sdl, 0, sizeof *sdl);
	mace_pcibr_decompose_tag(cpv, tag, &bus, &device, &fn);
	if (bus != 0)
		return 0;
	sdl->device = device;
	sdl->fn = fn;
	return 1;
}

int
mace_pcibr_intr_map(struct pci_attach_args *pa, pci_intr_handle_t *ihp)
{
	int bus, dev, pin = pa->pa_rawintrpin;
	static const signed char intrmap[][PCI_INTERRUPT_PIN_MAX] = {
		{ -1, -1, -1, -1 },
		{ 8, -1, -1, -1 },	/* ahc0 */
		{ 9, -1, -1, -1 },	/* ahc1 */
		{ 10, 13, 14, 15 },	/* slot */
		{ 11, 15, 13, 14 },	/* no slots... */
		{ 12, 14, 15, 13 }	/* ... unless you solder them */
	};

	*ihp = -1;

	if (pin == 0) {
		/* No IRQ used. */
		return 1;
	}
#ifdef DIAGNOSTIC
	if (pin > PCI_INTERRUPT_PIN_MAX) {
		printf("mace_pcibr_intr_map: bad interrupt pin %d\n", pin);
		return 1;
	}
#endif

	pci_decompose_tag(pa->pa_pc, pa->pa_tag, &bus, &dev, NULL);

	if (pa->pa_bridgetag) {
		pin = PPB_INTERRUPT_SWIZZLE(pin, dev);
		*ihp = pa->pa_bridgeih[pin - PCI_INTERRUPT_PIN_A];

		return ((*ihp == -1) ? 1 : 0);
	}

	if (dev < nitems(intrmap))
		*ihp = intrmap[dev][pin - PCI_INTERRUPT_PIN_A];

	return ((*ihp == -1) ? 1 : 0);
}

const char *
mace_pcibr_intr_string(void *lcv, pci_intr_handle_t ih)
{
	static char str[16];

	snprintf(str, sizeof(str), "irq %ld", ih);
	return(str);
}

void *
mace_pcibr_intr_establish(void *lcv, pci_intr_handle_t ih, int level,
    int (*func)(void *), void *arg, const char *name)
{
	return macebus_intr_establish(ih, 0, IST_LEVEL, level, func, arg, name);
}

void
mace_pcibr_intr_disestablish(void *lcv, void *ih)
{
	macebus_intr_disestablish(ih);
}

int
mace_pcibr_intr_line(void *lcv, pci_intr_handle_t ih)
{
	return ih;
}

/*
 *  Bus access primitives
 */

u_int8_t
mace_pcib_read_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
{
	return *(volatile u_int8_t *)(h + (o ^ 3));
}

u_int16_t
mace_pcib_read_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
{
	return *(volatile u_int16_t *)(h + (o ^ 2));
}

u_int32_t
mace_pcib_read_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
{
	return *(volatile u_int32_t *)(h + o);
}

u_int64_t
mace_pcib_read_8(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
{
	return *(volatile u_int64_t *)(h + o);
}

void
mace_pcib_write_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int8_t v)
{
	*(volatile u_int8_t *)(h + (o ^ 3)) = v;
}

void
mace_pcib_write_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int16_t v)
{
	*(volatile u_int16_t *)(h + (o ^ 2)) = v;
}

void
mace_pcib_write_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int32_t v)
{
	*(volatile u_int32_t *)(h + o) = v;
}

void
mace_pcib_write_8(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
    u_int64_t v)
{
	*(volatile u_int64_t *)(h + o) = v;
}

void
mace_pcib_read_raw_2(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    u_int8_t *buf, bus_size_t len)
{
	volatile u_int16_t *addr = (volatile u_int16_t *)(h + (o ^ 2));
	len >>= 1;
	while (len-- != 0) {
		*(u_int16_t *)buf = letoh16(*addr);
		buf += 2;
	}
}

void
mace_pcib_write_raw_2(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    const u_int8_t *buf, bus_size_t len)
{
	volatile u_int16_t *addr = (volatile u_int16_t *)(h + (o ^ 2));
	len >>= 1;
	while (len-- != 0) {
		*addr = htole16(*(u_int16_t *)buf);
		buf += 2;
	}
}

void
mace_pcib_read_raw_4(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    u_int8_t *buf, bus_size_t len)
{
	volatile u_int32_t *addr = (volatile u_int32_t *)(h + o);
	len >>= 2;
	while (len-- != 0) {
		*(u_int32_t *)buf = letoh32(*addr);
		buf += 4;
	}
}

void
mace_pcib_write_raw_4(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    const u_int8_t *buf, bus_size_t len)
{
	volatile u_int32_t *addr = (volatile u_int32_t *)(h + o);
	len >>= 2;
	while (len-- != 0) {
		*addr = htole32(*(u_int32_t *)buf);
		buf += 4;
	}
}

void
mace_pcib_read_raw_8(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    u_int8_t *buf, bus_size_t len)
{
	volatile u_int64_t *addr = (volatile u_int64_t *)(h + o);
	len >>= 3;
	while (len-- != 0) {
		*(u_int64_t *)buf = letoh64(*addr);
		buf += 8;
	}
}

void
mace_pcib_write_raw_8(bus_space_tag_t t, bus_space_handle_t h, bus_addr_t o,
    const u_int8_t *buf, bus_size_t len)
{
	volatile u_int64_t *addr = (volatile u_int64_t *)(h + o);
	len >>= 3;
	while (len-- != 0) {
		*addr = htole64(*(u_int64_t *)buf);
		buf += 8;
	}
}

int
mace_pcib_space_map(bus_space_tag_t t, bus_addr_t offs, bus_size_t size,
    int flags, bus_space_handle_t *bshp)
{
#ifdef DIAGNOSTIC
	if (t->bus_base == mace_pcibbus_mem_tag.bus_base) {
		if (offs < MACE_PCI_MEM_OFFSET ||
		    ((offs + size - 1) >> 32) != 0)
			return EINVAL;
	} else {
		if (((offs + size - 1) >> 32) != 0)
			return EINVAL;
	}
#endif

	if (ISSET(flags, BUS_SPACE_MAP_CACHEABLE))
		offs +=
		    PHYS_TO_XKPHYS(0, CCA_CACHED) - PHYS_TO_XKPHYS(0, CCA_NC);
	*bshp = t->bus_base + offs;
	return 0;
}

void
mace_pcib_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
    bus_size_t size)
{
}

int
mace_pcib_space_region(bus_space_tag_t t, bus_space_handle_t bsh,
    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp)
{
	*nbshp = bsh + offset;
	return (0);
}

void *
mace_pcib_space_vaddr(bus_space_tag_t t, bus_space_handle_t h)
{
	return (void *)h;
}

void
mace_pcib_space_barrier(bus_space_tag_t t, bus_space_handle_t h,
    bus_size_t offs, bus_size_t len, int flags)
{
	mips_sync();
}

/*
 * Mace PCI bus_dma helpers.
 * The PCI bus accesses memory contiguously at 0x00000000 onwards.
 */

bus_addr_t
mace_pcibr_pa_to_device(paddr_t pa)
{
	return (pa & CRIME_MEMORY_MASK);
}

paddr_t
mace_pcibr_device_to_pa(bus_addr_t addr)
{
	paddr_t pa = (paddr_t)addr & CRIME_MEMORY_MASK;

	if (pa >= 256 * 1024 * 1024)
		pa |= CRIME_MEMORY_OFFSET;

	return (pa);
}

/*
 * PCI configuration.
 */

void
mace_pcibr_configure(struct mace_pcibr_softc *sc)
{
	pci_chipset_tag_t pc = &sc->sc_pc;
	pcitag_t tag;
	pcireg_t id, bhlcr;
	int dev, nfuncs;
	uint nppb, npccbb;
	const struct pci_quirkdata *qd;

	nppb = npccbb = 0;
	for (dev = 0; dev < pci_bus_maxdevs(pc, 0); dev++) {
		tag = pci_make_tag(pc, 0, dev, 0);

		id = pci_conf_read(pc, tag, PCI_ID_REG);
		if (PCI_VENDOR(id) == PCI_VENDOR_INVALID ||
		    PCI_VENDOR(id) == 0)
			continue;

		bhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);
		if (PCI_HDRTYPE_TYPE(bhlcr) == 1)
			nppb++;
		if (PCI_HDRTYPE_TYPE(bhlcr) == 2)
			npccbb++;

		qd = pci_lookup_quirkdata(PCI_VENDOR(id), PCI_PRODUCT(id));
		if (PCI_HDRTYPE_MULTIFN(bhlcr) ||
		    (qd != NULL && (qd->quirks & PCI_QUIRK_MULTIFUNCTION) != 0))
			nfuncs = 8;
		else
			nfuncs = 1;

		mace_pcibr_device_fixup(sc, dev, nfuncs);
	}

	/*
	 * Since there is only one working slot, there should be only
	 * up to one bridge (PCI-PCI or PCI-CardBus), which we'll map
	 * after the on-board device resources.
	 */
	if (nppb + npccbb != 1)
		return;

	for (dev = 0; dev < pci_bus_maxdevs(pc, 0); dev++) {
		tag = pci_make_tag(pc, 0, dev, 0);

		id = pci_conf_read(pc, tag, PCI_ID_REG);
		if (PCI_VENDOR(id) == PCI_VENDOR_INVALID ||
		    PCI_VENDOR(id) == 0)
			continue;

		bhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);
		switch (PCI_HDRTYPE_TYPE(bhlcr)) {
		case 1:
			ppb_initialize(pc, tag, 0, 1, 255);
			break;
		case 2:
			pccbb_initialize(pc, tag, 0, 1, 1);
			break;
		}
	}
}

void
mace_pcibr_device_fixup(struct mace_pcibr_softc *sc, int dev, int nfuncs)
{
	pci_chipset_tag_t pc = &sc->sc_pc;
	pcitag_t tag;
	pcireg_t csr, bhlcr, type;
	int function;
	int reg, reg_start, reg_end;

	for (function = 0; function < nfuncs; function++) {
		tag = pci_make_tag(pc, 0, dev, function);

		bhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);
		switch (PCI_HDRTYPE_TYPE(bhlcr)) {
		case 0:
			reg_start = PCI_MAPREG_START;
			reg_end = PCI_MAPREG_END;
			break;
		case 1:	/* PCI-PCI bridge */
			reg_start = PCI_MAPREG_START;
			reg_end = PCI_MAPREG_PPB_END;
			break;
		case 2:	/* PCI-CardBus bridge */
			reg_start = PCI_MAPREG_START;
			reg_end = PCI_MAPREG_PCB_END;
			break;
		default:
			continue;
		}

		/*
		 * The firmware will only initialize memory BARs, and only
		 * the lower half of them if they are 64 bit.
		 * So here we disable I/O space and reset the I/O BARs to 0,
		 * and make sure the upper part of 64 bit memory BARs is
		 * correct.
		 * Device drivers will allocate resources themselves and
		 * enable I/O space on an as-needed basis.
		 */
		csr = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
		pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG,
	            csr & ~PCI_COMMAND_IO_ENABLE);

		for (reg = reg_start; reg < reg_end; reg += 4) {
			if (pci_mapreg_probe(pc, tag, reg, &type) == 0)
				continue;

			switch (type) {
			case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
				reg += 4;
				/* FALLTHROUGH */
			case PCI_MAPREG_TYPE_IO:
				pci_conf_write(pc, tag, reg, 0);
				break;
			}
		}
	}
}

int
mace_pcibr_ppb_setup(void *cookie, pcitag_t tag, bus_addr_t *iostart,
    bus_addr_t *ioend, bus_addr_t *memstart, bus_addr_t *memend)
{
	if (*memend != 0) {
		/*
		 * Give all resources to the bridge
		 * (except for the few the on-board ahc(4) will use).
		 */
		*memstart = 0x81000000;
		*memend =   0xffffffff;
	} else {
		*memstart = 0xffffffff;
		*memend = 0;
	}

	if (*ioend != 0) {
		/*
		 * Give all resources to the bridge
		 * (except for the few the on-board ahc(4) will use).
		 */
		*iostart = 0x00010000;
		*ioend =   0xffffffff;
	} else {
		*iostart = 0xffffffff;
		*ioend = 0;
	}

	return 0;
}

#if NCARDBUS > 0

static struct rb_md_fnptr mace_pcibr_rb_md_fn = {
	mace_pcibr_rbus_space_map,
	mace_pcibr_rbus_space_unmap
};

int
mace_pcibr_rbus_space_map(bus_space_tag_t t, bus_addr_t addr, bus_size_t size,
    int flags, bus_space_handle_t *bshp)
{
	return bus_space_map(t, addr, size, flags, bshp);
}

void
mace_pcibr_rbus_space_unmap(bus_space_tag_t t, bus_space_handle_t h,
    bus_size_t size, bus_addr_t *addrp)
{
	bus_space_unmap(t, h, size);
	/* can't simply subtract because of possible cacheability */
	*addrp = XKPHYS_TO_PHYS(h) - XKPHYS_TO_PHYS(t->bus_base);
}

void *
mace_pcibr_rbus_parent_io(struct pci_attach_args *pa)
{
	rbus_tag_t rb;

	rb = rbus_new_root_share(pa->pa_iot, pa->pa_ioex,
	    0x0000, 0xffff);
	if (rb != NULL)
		rb->rb_md = &mace_pcibr_rb_md_fn;

	return rb;
}

void *
mace_pcibr_rbus_parent_mem(struct pci_attach_args *pa)
{
	rbus_tag_t rb;

	rb = rbus_new_root_share(pa->pa_memt, pa->pa_memex,
	    0, 0xffffffff);
	if (rb != NULL)
		rb->rb_md = &mace_pcibr_rb_md_fn;

	return rb;
}

#endif	/* NCARDBUS > 0 */
@


1.46
log
@Moar <uvm/uvm.h> -> <uvm/uvm_extern.h> love.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.45 2012/09/29 18:54:39 miod Exp $ */
a115 2
extern void pciaddr_remap(pci_chipset_tag_t);

d220 1
a220 1
static int      mace_pcibrprint(void *, const char *pnp);
d506 1
a506 1
	snprintf(str, sizeof(str), "irq %d", ih);
@


1.45
log
@Proide a mips_sync() macro to wrap asm("sync"), and replace gazillions of
such statements with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.44 2012/03/15 18:52:56 miod Exp $ */
a55 1
#include <uvm/uvm.h>
@


1.44
log
@No longer allow bus_space_barrier() to be a NULL pointer on a given
bus_space_tag on sgi, but rather always provide at least a dummy asm("sync")
flavour. Saves a function pointer test at runtime.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.43 2011/10/10 19:49:16 miod Exp $ */
d706 1
a706 1
	__asm__ __volatile__ ("sync" ::: "memory");
@


1.43
log
@Extend pci_probe_device_hook() on sgi xbridge(4) to return either the straight
accessors or the byte-swapped accessors, depending upon the byteswap setting
of the device we are trying to attach.

This allows for the removal of byteswap knowledge from ioc(4) and iof(4)
drivers.

While there, build pci_chipset_t md structs by bcopy'ing a template and
filling the few runtime fields, instead of assigning every field of them.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.41 2010/12/04 17:06:31 miod Exp $ */
d103 2
d138 1
a138 2
	mace_pcib_space_vaddr,
	NULL
d152 1
a152 2
	mace_pcib_space_vaddr,
	NULL
d700 7
@


1.42
log
@Introduce pci_probe_device_hook(pci_chipset_tag_t, struct pci_attach_args *).
This mandatory function will get invoked in pci_probe_device(), and allows
a pci host driver to alter the pci_attach_args passed to a device when
attaching.

This function will also, if returning non-zero, cause the device to be
skipped completely during all the phases of the PCI device discovery
(i.e. ressource enumeration, ressource assignment, and actual attachment).
This particular feature is experimental and might be reverted in the future
(or the scope narrowed to device attachment only).

A dummy #define pci_probe_device_hook() 0 is added to all platforms except
sgi, where real functions (currently only returning 0) are added; real meat
will be added shortly.

Discussed at s2k11, no objection from the usual suspects.
@
text
@d155 23
d262 1
a263 10
	sc->sc_pc.pc_attach_hook = mace_pcibr_attach_hook;
	sc->sc_pc.pc_make_tag = mace_pcibr_make_tag;
	sc->sc_pc.pc_decompose_tag = mace_pcibr_decompose_tag;
	sc->sc_pc.pc_bus_maxdevs = mace_pcibr_bus_maxdevs;
	sc->sc_pc.pc_conf_size = mace_pcibr_conf_size;
	sc->sc_pc.pc_conf_read = mace_pcibr_conf_read;
	sc->sc_pc.pc_conf_write = mace_pcibr_conf_write;
	sc->sc_pc.pc_get_widget = mace_pcibr_get_widget;
	sc->sc_pc.pc_probe_device_hook = mace_pcibr_probe_device_hook;
	sc->sc_pc.pc_get_dl = mace_pcibr_get_dl;
a264 10
	sc->sc_pc.pc_intr_map = mace_pcibr_intr_map;
	sc->sc_pc.pc_intr_string = mace_pcibr_intr_string;
	sc->sc_pc.pc_intr_establish = mace_pcibr_intr_establish;
	sc->sc_pc.pc_intr_disestablish = mace_pcibr_intr_disestablish;
	sc->sc_pc.pc_intr_line = mace_pcibr_intr_line;
	sc->sc_pc.pc_ppb_setup = mace_pcibr_ppb_setup;
#if NCARDBUS > 0
	sc->sc_pc.pc_rbus_parent_io = mace_pcibr_rbus_parent_io;
	sc->sc_pc.pc_rbus_parent_mem = mace_pcibr_rbus_parent_mem;
#endif
@


1.41
log
@Introduce a new pci routine, pci_conf_size(), which returns the size of a
given pcitag_t configuration address space. Currently, all pci controllers
will return the usual 0x100 bytes of PCI configuration space, but this will
eventually change on PCIe-capable controlers.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.40 2010/09/22 02:28:37 jsg Exp $ */
d88 1
d248 1
d431 6
@


1.40
log
@remove unused offset argument to rbus functions
ok krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.39 2010/08/23 16:56:18 miod Exp $ */
d85 1
d243 1
d368 6
@


1.39
log
@Implement bus_space_barrier() on sgi; on xbridge, this will also flush
the pci write buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.38 2010/04/06 19:12:34 miod Exp $ */
d890 1
a890 1
	    0x0000, 0xffff, 0);
d903 1
a903 1
	    0, 0xffffffff, 0);
@


1.38
log
@Obtain struct sgi_device_location for the console input and output devices,
and compare against them when attaching potential console drivers, to figure
out whether they indeed are acting are console devices or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.37 2010/03/07 13:38:58 miod Exp $ */
d134 2
a135 1
	mace_pcib_space_vaddr
d149 2
a150 1
	mace_pcib_space_vaddr
@


1.37
log
@Add an MD interface for PCI drivers to be able to retrieve the node and widget
number the PCI bus they are on is connected to. Will be used shortly to help
the console device selection logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.36 2009/10/26 18:00:06 miod Exp $ */
a86 1
int16_t	 mace_pcibr_get_nasid(void *);
d88 1
a241 1
	sc->sc_pc.pc_get_nasid = mace_pcibr_get_nasid;
d243 1
d421 2
a422 2
int16_t
mace_pcibr_get_nasid(void *unused)
d428 1
a428 1
mace_pcibr_get_widget(void *unused)
d430 9
a438 1
	return 0;
@


1.36
log
@Better crime/mace interrupt handling; interrupt information is no longer
specified in the kernel configuration file, but is provided by macebus(4)
as part of the  child device attachment args, and provide both crime and
mace interrupt bitmasks; this allows us to only really enable interrupt
sources we care about, and to avoid invoking interrupt handler we don't need
to for the few mace interrupts multiplexed at the crime level.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.35 2009/10/22 20:52:39 miod Exp $ */
d87 2
d242 2
d419 12
@


1.35
log
@Implement bus_space_vaddr() for macepcibr.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.34 2009/10/22 20:51:09 miod Exp $ */
d72 1
a198 2
	static int once = 0;

d201 1
a201 1
		return once++ == 0 ? 1 : 0;
d212 1
a212 1
	struct confargs *ca = aux;
d219 3
a221 2
	sc->sc_memt = ca->ca_memt;
	if (bus_space_map(sc->sc_memt, MACE_PCI_OFFS, 4096, 0, &sc->sc_memh)) {
d227 1
a227 1
	printf(": mace rev %d, host system O2\n", pcireg);
d230 2
a231 2
	macebus_intr_establish(NULL, 8, IST_LEVEL, IPL_HIGH,
	    mace_pcibr_errintr, (void *)sc, sc->sc_dev.dv_xname);
d359 1
a359 1
	return busno == 0 ? 4 : 32;
d423 5
a427 7
		{ 9, -1, -1, -1 },	/* ahc0 */
		{ 10, -1, -1, -1 },	/* ahc1 */
		{ 11, 14, 15, 16 },	/* slot */
#ifdef useless
		{ 12, 16, 14, 15 },	/* no slots... */
		{ 13, 15, 16, 14 }	/* ... unless you solder them */
#endif
d471 1
a471 2
	return
	    macebus_intr_establish(NULL, ih, IST_LEVEL, level, func, arg, name);
@


1.34
log
@Make macebus_intr_disestablish() signature sane, and update its caller.
Still unimplemented for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.33 2009/08/22 02:54:51 mk Exp $ */
d97 1
d131 1
d145 1
d651 6
@


1.33
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.32 2009/08/09 12:36:33 miod Exp $ */
d475 1
a475 1
mace_pcibr_intr_disestablish(void *lcv, void *cookie)
d477 1
a477 1
	macebus_intr_disestablish(lcv, cookie);
@


1.32
log
@typo; brad
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.31 2009/08/09 08:16:53 miod Exp $ */
d89 1
a89 1
	    int (*)(void *), void *, char *);
d468 1
a468 1
    int (*func)(void *), void *arg, char *name)
@


1.31
log
@Clear the upper part of 64 bit memory BARs, for they show up as 0xffffffff
otherwise. Found the hard way by jasper@@, playing with a bge card.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.30 2009/07/26 19:57:45 miod Exp $ */
d250 1
a250 1
	 * The O2 firmware sucks.  It makes a mess off I/O BARs and
@


1.30
log
@Don't forget to bus_space_unmap(), even if it's a no-op, in rbus_space_unmap().
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.29 2009/07/22 21:29:04 miod Exp $ */
d770 7
a776 5
		 * The firmware fails to initialize I/O BARs.  Worse, it
		 * fills them with crap.  So here we disable I/O space and
		 * reset the I/O BARs to 0.  Device drivers will allocate
		 * resources themselves and enable I/O space on an as-needed
		 * basis.
d789 1
a789 1
				break;
@


1.29
log
@Get rid of now unused extent_malloc_ok variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.28 2009/07/22 21:28:44 miod Exp $ */
d845 1
@


1.28
log
@Get rid of bus_space_tag_t now unused bus_extent and bus_reverse fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.27 2009/07/22 20:28:21 miod Exp $ */
a612 2

extern int extent_malloc_flags;
@


1.27
log
@Overhaul resource handling and mapping in macepcibr(4):
- do not use a stinking extent to track bus_space_map allocations, but
  directly map in XKPHYS instead. What are 64 bit address spaces good for
  if we still need to use TLB for that?
- provide proper resource management extents to the MI pci code, so that,
  in turn, the cardbus code can reuse them instead of providing their own.
- use the whole 4GB address space window for PCI I/O resources, just
  because we can.
- make sure no device can get assigned address zero in I/O space, because
  this address triggers a PCI error.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.25 2009/07/19 19:02:03 kettenis Exp $ */
d120 1
a121 3
	0ULL,
	NULL,
	0,
d133 1
a134 3
	0ULL,
	NULL,
	0,
a211 5

	mace_pcibbus_io_tag.bus_base =
	    PHYS_TO_XKPHYS(MACE_PCI_IO_BASE, CCA_NC);
	mace_pcibbus_mem_tag.bus_base =
	    PHYS_TO_XKPHYS(MACE_PCI_MEM_BASE, CCA_NC);
@


1.26
log
@PCI-Cardbus bridge support for both O2 (macepcibr) and Octane/Origin (xbridge)
class systems. Tested on O2 and Origin 200 with wi@@pcmcia and xl@@cardbus,
using a Ricoh 5C475-based cbb(4) board.

acx@@cardbus doesn't work reliably yet, so your mileage may vary until more
bugs are fixed.

Thanks to matthieu@@ for lending me some cardbus devices for testing.
@
text
@d4 15
a118 3
long pci_io_ext_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof (long)];
long pci_mem_ext_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof (long)];

d121 1
a121 1
	(bus_addr_t)MACE_PCI_MEM_BASE,
d136 1
a136 1
	(bus_addr_t)MACE_PCI_IO_BASE,
d153 1
a153 1
struct machine_bus_dma_tag pci_bus_dma_tag = {
d191 1
a191 1
  { 0, 0 }
d199 2
d203 1
a203 1
		return 1;
d217 4
a220 10
	/* Create extents for PCI mappings */
	mace_pcibbus_io_tag.bus_extent = extent_create("pci_io",
	    MACE_PCI_IO_BASE, MACE_PCI_IO_BASE + MACE_PCI_IO_SIZE - 1,
	    M_DEVBUF, (caddr_t)pci_io_ext_storage,
	    sizeof(pci_io_ext_storage), EX_NOCOALESCE|EX_NOWAIT);

	mace_pcibbus_mem_tag.bus_extent = extent_create("pci_mem",
	    MACE_PCI_MEM_BASE, MACE_PCI_MEM_BASE + MACE_PCI_MEM_SIZE - 1,
	    M_DEVBUF, (caddr_t)pci_mem_ext_storage,
	    sizeof(pci_mem_ext_storage), EX_NOCOALESCE|EX_NOWAIT);
a221 1
	/* local -> PCI MEM mapping offset */
a222 2

	/* local -> PCI IO mapping offset */
d271 1
a271 2
	pba.pba_dmat = malloc(sizeof(pci_bus_dma_tag), M_DEVBUF, M_NOWAIT);
	*pba.pba_dmat = pci_bus_dma_tag;
d273 14
d331 1
a331 1
				printf(" at address %p", erraddr);
d627 1
a627 1
    int cacheable, bus_space_handle_t *bshp)
d629 8
a636 8
	bus_addr_t bpa;
	int error;

	bpa = t->bus_base + (offs & 0x7fffffff);

	if ((error = extent_alloc_region(t->bus_extent, bpa, size,
	    EX_NOWAIT | extent_malloc_flags))) {
		return error;
d638 1
d640 5
a644 9
	if ((error  = bus_mem_add_mapping(bpa, size, cacheable, bshp))) {
		if (extent_free(t->bus_extent, bpa, size,
		    EX_NOWAIT | extent_malloc_flags)) {
			printf("bus_space_map: pa %p, size %p\n", bpa, size);
			printf("bus_space_map: can't free region\n");
		}
	}

	return (error);
a650 19
	bus_addr_t sva;
	bus_size_t off, len;
	bus_addr_t paddr;

	/* should this verify that the proper size is freed? */
	sva = trunc_page(bsh);
	off = bsh - sva;
	len = size+off;

	if (pmap_extract(pmap_kernel(), bsh, (void *)&paddr) == 0) {
		printf("bus_space_unmap: no pa for va %p\n", bsh);
		return;
	}

	if (extent_free(t->bus_extent, paddr, size,
	    EX_NOWAIT | extent_malloc_flags)) {
		printf("bus_space_map: pa %p, size %p\n", paddr, size);
		printf("bus_space_map: can't free region\n");
	}
d813 2
a814 1
		 * Give all resources to the bridge.
d816 2
a817 2
		*memstart = 0x90000000;
		*memend = 0xffffffff;
d825 2
a826 1
		 * Give all resources to the bridge.
d829 1
a829 1
		*ioend = MACE_PCI_IO_SIZE - *iostart;
d856 2
a857 24
	bus_addr_t sva;
	bus_size_t off, len;
	paddr_t paddr;

	/* should this verify that the proper size is freed? */
	sva = trunc_page(h);
	off = h - sva;
	len = size + off;

	if (pmap_extract(pmap_kernel(), h, &paddr) == 0) {
		printf("bus_space_unmap: no pa for va %p\n", h);
		*addrp = 0;	/* XXX */
		return;
	}

	if (extent_free(t->bus_extent, (u_long)paddr, size,
	    EX_NOWAIT | extent_malloc_flags)) {
		printf("bus_space_map: pa %p, size %p\n", paddr, size);
		printf("bus_space_map: can't free region\n");
	}

	*addrp = paddr - t->bus_base;
	if (t->bus_base == MACE_PCI_MEM_BASE)
		*addrp += 0x80000000;
a863 8
	bus_addr_t start, end;

	/*
	 * Give all resources to the CardBus bridge.
	 */

	start = 0x2000;	/* leave some I/O for ahc */
	end = 0x10000;
d865 2
a866 1
	rb = rbus_new_root_delegate(pa->pa_iot, start, end - start, 0);
a876 8
	bus_addr_t start, end;

	/*
	 * Give all resources to the CardBus bridge.
	 */

	start = 0x90000000;
	end = 0x100000000UL;
d878 2
a879 1
	rb = rbus_new_root_delegate(pa->pa_memt, start, end - start, 0);
@


1.25
log
@Simplify code that sanitizes pci resources on the O2's mace PCI bridge.
The firmware messes up I/O BARs, so whack those back to 0, such that the MI
PCI code initializes on an as-needed basis.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.24 2009/07/17 18:06:51 miod Exp $ */
d52 2
d59 2
d76 5
d85 8
a92 6
int	 mace_pcibr_errintr(void *);

void	 mace_pcibr_configure(struct mace_pcibr_softc *);
void	 mace_pcibr_device_fixup(struct mace_pcibr_softc *, int, int);
int	 mace_pcibr_ppb_setup(void *, pcitag_t, bus_addr_t *, bus_addr_t *,
	    bus_addr_t *, bus_addr_t *);
a202 8
	/*
	 *  Common to all bridge chips.
	 */
	sc->sc_pc.pc_conf_v = sc;
	sc->sc_pc.pc_attach_hook = mace_pcibr_attach_hook;
	sc->sc_pc.pc_make_tag = mace_pcibr_make_tag;
	sc->sc_pc.pc_decompose_tag = mace_pcibr_decompose_tag;

d234 4
a240 1

d246 1
d248 4
d471 6
d698 1
a698 1
	uint curppb, nppb;
d701 1
a701 1
	nppb = 0;
d713 2
d728 2
a729 2
	 * up to one bridge, which we'll map after the on-board device
	 * resources.
d731 1
a731 1
	if (nppb != 1)
a733 1
	curppb = 0;
d743 8
a750 6
		if (PCI_HDRTYPE_TYPE(bhlcr) != 1)
			continue;

		ppb_initialize(pc, tag, 1 + curppb * (255 / nppb),
		    (curppb + 1) * (255 / nppb));
		curppb++;
d830 1
a830 1
		*iostart = 0x01000000;
d839 86
@


1.24
log
@Update bus_dma to the better codebase found on almost all other platforms,
where the common part to all bus_dmamap_load*() functions is implemented in
in an internal load_buffer routine.

This allows the xbridge-specific dma code to only provide this function,
instead of three; and this also brings us a working bus_dmamap_load_uio()
on all supported sgi machines, which in turns make crpyto(4) devices really
work. Tested with hifn(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.23 2009/07/16 21:02:56 miod Exp $ */
d76 2
d79 1
a79 1
int	 mace_pcibr_errintr(void *);
d243 2
a244 6
	 *  Firmware sucks. Remap PCI BAR registers. (sigh)
	 */
	pciaddr_remap(&sc->sc_pc);

	/*
	 * Setup any PCI-PCI bridge.
a677 2
	int dev;
	uint curppb, nppb;
d680 3
d696 9
d731 57
@


1.23
log
@Make the PCI-PCI bridge initialization code bus-independent, relying on a
per-pci_chipset_t function to perform actual resource allocation.
Add the necessary bits to macepcibr(4), and enable ppb(4) on O2 kernels now.

Joint effort with kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.22 2009/07/16 21:00:51 miod Exp $ */
d136 1
@


1.22
log
@Cheat in pci_conf_read() and force the REXTVALID bit in the O2 onboard ahc(4)
configuration register; this allows the driver to select ultra speed, which
this particular hardware supports.
From Linux, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.21 2009/04/25 15:28:59 kettenis Exp $ */
d50 1
a56 6
extern void *macebus_intr_establish(void *, u_long, int, int,
		int (*)(void *), void *, char *);
extern void macebus_intr_disestablish(void *, void *);
extern void pciaddr_remap(pci_chipset_tag_t);

/**/
d59 1
d61 2
a62 3
				struct pcibus_attach_args *);
int	 mace_pcibr_errintr(void *);

a64 2

int	 mace_pcibr_bus_maxdevs(void *, int);
d67 1
a67 2

int      mace_pcibr_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
d69 3
a71 3
void     *mace_pcibr_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *);
void     mace_pcibr_intr_disestablish(void *, void *);
d74 8
a81 1
paddr_t	mace_pcibr_device_to_pa(bus_addr_t);
d148 1
a148 1
struct _perr_map {
d151 1
a151 1
	char *text;
a167 1

a169 1

d173 1
a173 1
	switch(sys_config.system_type) {
d176 2
a178 1
	return (0);
d199 3
a201 3
		MACE_PCI_IO_BASE, MACE_PCI_IO_BASE + MACE_PCI_IO_SIZE - 1,
		M_DEVBUF, (caddr_t)pci_io_ext_storage,
		sizeof(pci_io_ext_storage), EX_NOCOALESCE|EX_NOWAIT);
d204 3
a206 3
		MACE_PCI_MEM_BASE, MACE_PCI_MEM_BASE + MACE_PCI_MEM_SIZE - 1,
		M_DEVBUF, (caddr_t)pci_mem_ext_storage,
		sizeof(pci_mem_ext_storage), EX_NOCOALESCE|EX_NOWAIT);
d217 1
a217 1
		printf("UH-OH! Can't map PCI control registers!\n");
d237 1
d245 5
d271 1
a271 3
mace_pcibrprint(aux, pnp)
	void *aux;
	const char *pnp;
d278 1
a278 1
	return(UNCONF);
d282 2
a283 3
mace_pcibr_attach_hook(parent, self, pba)
	struct device *parent, *self;
	struct pcibus_attach_args *pba;
d293 1
a293 1
	struct _perr_map *emap = perr_map;
d317 1
a317 3
mace_pcibr_make_tag(cpv, bus, dev, fnc)
	void *cpv;
	int bus, dev, fnc;
d323 2
a324 4
mace_pcibr_decompose_tag(cpv, tag, busp, devp, fncp)
	void *cpv;
	pcitag_t tag;
	int *busp, *devp, *fncp;
d327 1
a327 1
		*busp = (tag >> 16) & 0x7;
d335 1
a335 3
mace_pcibr_bus_maxdevs(cpv, busno)
	void *cpv;
	int busno;
d337 1
a337 1
	return 5;
d379 1
a379 5
mace_pcibr_conf_write(cpv, tag, offset, data)
	void *cpv;
	pcitag_t tag;
	int offset;
	pcireg_t data;
d404 1
d407 1
d439 1
a439 3
mace_pcibr_intr_string(lcv, ih)
	void *lcv;
	pci_intr_handle_t ih;
d448 2
a449 7
mace_pcibr_intr_establish(lcv, ih, level, func, arg, name)
	void *lcv;
	pci_intr_handle_t ih;
	int level;
	int (*func)(void *);
	void *arg;
	char *name;
d451 2
a452 1
	return macebus_intr_establish(NULL, ih, IST_LEVEL, level, func, arg, name);
d456 1
a456 2
mace_pcibr_intr_disestablish(lcv, cookie)
	void *lcv, *cookie;
a462 1
 *  XXX 64 bit access not clean in lp32 mode.
d468 1
a468 1
	return *(volatile u_int8_t *)(h + (o | 3) - (o & 3));
d474 1
a474 1
	return *(volatile u_int16_t *)(h + (o | 2) - (o & 3));
d490 2
a491 1
mace_pcib_write_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o, u_int8_t v)
d493 1
a493 1
	*(volatile u_int8_t *)(h + (o | 3) - (o & 3)) = v;
d497 2
a498 1
mace_pcib_write_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o, u_int16_t v)
d500 1
a500 1
	*(volatile u_int16_t *)(h + (o | 2) - (o & 3)) = v;
d504 2
a505 1
mace_pcib_write_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o, u_int32_t v)
d511 2
a512 1
mace_pcib_write_8(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o, u_int64_t v)
d521 1
a521 1
	volatile u_int16_t *addr = (volatile u_int16_t *)(h + (o | 2) - (o & 3));
d533 1
a533 1
	volatile u_int16_t *addr = (volatile u_int16_t *)(h + (o | 2) - (o & 3));
d593 1
a593 1
	int cacheable, bus_space_handle_t *bshp)
d617 2
a618 1
mace_pcib_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size)
d643 1
a643 1
	bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp)
d669 83
@


1.21
log
@Extend PCI mmio address space by using a bigger window that requires 64-bit
adressing (no problem since we only support 64-bit mode).

ok miod@@, jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.20 2009/04/19 15:13:06 kettenis Exp $ */
d346 1
a346 4
mace_pcibr_conf_read(cpv, tag, offset)
	void *cpv;
	pcitag_t tag;
	int offset;
d352 1
d362 8
@


1.20
log
@Fix interrupt mapping for devices behind PCI-PCI bridges.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.19 2009/04/18 19:26:16 miod Exp $ */
d602 2
a603 1
	bpa = t->bus_base + (offs & 0x01ffffff);
@


1.19
log
@Attach pci busses with pba_bus being zero, and not our bridge unit number,
these are completely unrelated as long as there is only one pci bus per
bridge.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.18 2009/03/30 09:41:00 kettenis Exp $ */
d49 1
d401 1
a401 1
	int bus, device, pirq;
d413 1
a413 1
	if (pa->pa_intrpin == 0) {
d418 2
a419 2
	if (pa->pa_intrpin > 4) {
		printf("mace_pcibr_intr_map: bad interrupt pin %d\n", pa->pa_intrpin);
d424 1
a424 1
	pci_decompose_tag(pa->pa_pc, pa->pa_intrtag, &bus, &device, NULL);
d426 3
a428 3
	pirq = -1;
	if ((unsigned int)device < sizeof(intrmap) / PCI_INTERRUPT_PIN_MAX)
		pirq = intrmap[device][pa->pa_intrpin - PCI_INTERRUPT_PIN_A];
d430 7
a436 2
	*ihp = pirq;
	return pirq >= 0 ? 0 : 1;
@


1.18
log
@bzero pci attach args
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.17 2008/07/30 17:37:46 miod Exp $ */
d255 1
a255 1
	pba.pba_bus = sc->sc_dev.dv_unit;
@


1.17
log
@Implement bus_space_{read,write}_raw_mult_[248] correctly, it needs
endianness conversion on pci bridges.
ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.16 2008/07/30 17:32:30 miod Exp $ */
d247 1
a255 1
	pba.pba_bridgetag = NULL;
@


1.16
log
@Proper interrupt values for pci interrupt pins B to D, found in some IRIX
developer documentation some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.15 2008/02/20 18:46:20 miod Exp $ */
d103 3
d118 3
d514 72
@


1.15
log
@Completely overhault attachment rules on sgi. No more indirect configuration
inherited from OpenBSD/arc machines with ISA bus; mainbus children match on
device name and other hierarchies match on simplified locators.
As a bonus, attachment lines in dmesg will now print their locators.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.14 2008/02/16 18:42:21 miod Exp $ */
d335 1
a335 1
	return(16);
d395 8
d410 1
d415 1
d417 1
a417 1
	mace_pcibr_decompose_tag((void *)NULL, pa->pa_tag, &bus, &device, NULL);
d419 3
a421 14
	if (sys_config.system_type == SGI_O2) {
		pirq = -1;
		switch (device) {
		case 1:
			pirq = 9;
			break;
		case 2:
			pirq = 10;
			break;
		case 3:
			pirq = 11;
			break;
		}
	}
d424 1
a424 1
	return 0;
@


1.14
log
@Remove unused fields of struct mips_pci_chipset.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.13 2007/10/18 04:32:27 miod Exp $ */
d220 1
a220 1
	BUS_INTR_ESTABLISH(ca, NULL, 8, IST_LEVEL, IPL_HIGH,
@


1.13
log
@No need to include <machine/pte.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.12 2007/06/21 20:17:12 miod Exp $ */
a190 1
	sc->sc_pc.pc_sync_cache = sys_config._IOSyncDCache;
@


1.12
log
@Extent sgi bus_dma to cope with different views of memory: non-contiguous
for the cpu, contiguous from different bases for devices. This allows
memory above 256MB to be used with bus_dma (and we had really been lucky
with the first few large-memory builds).
Information about memory accesses taken from Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.11 2006/12/14 17:36:12 kettenis Exp $ */
a43 1
#include <machine/pte.h>
@


1.11
log
@Make pci subsystem aware of domains.  Each host bridge gets assigned a unique
domain number such that we can distinguish between busses with the same bus
number that are behind different host bridges.  Domains can be accessed by
using different device nodes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.10 2006/03/13 20:10:49 brad Exp $ */
d52 1
d81 2
d138 3
a140 1
	NULL
a246 1
	pci_bus_dma_tag.dma_offs = 0x00000000;
d569 22
@


1.10
log
@* Add "pcitag_t *pba_bridgetag" to pci_attach_args.  This is set to
  NULL for root PCI busses.  For busses behind a bridge, it points to
  a persistent copy of the bridge's pcitag_t.  This can be very useful
  for machine-dependent PCI bus enumeration code.

From NetBSD

ok grange@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.9 2006/01/04 20:23:09 miod Exp $ */
d245 1
@


1.9
log
@Stop abusing phys_map to know if it is safe to use malloc in extent routines;
instead use a global flag, like some other architectures do. No functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.8 2006/01/04 20:20:18 miod Exp $ */
d246 1
@


1.8
log
@Do not return zero in bus_space_map() on failure (sigh).
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.7 2005/01/31 21:35:50 grange Exp $ */
d507 2
d518 1
a518 1
	    EX_NOWAIT | EX_MALLOCOK))) {
d523 2
a524 2
		if (extent_free(t->bus_extent, bpa, size, EX_NOWAIT |
		    ((phys_map != NULL) ? EX_MALLOCOK : 0))) {
d550 2
a551 8
	if (phys_map != NULL &&
	    ((sva >= VM_MIN_KERNEL_ADDRESS) && (sva < VM_MAX_KERNEL_ADDRESS))) {
		/* do not free memory which was stolen from the vm system */
		uvm_km_free(kernel_map, sva, len);
	}

	if (extent_free(t->bus_extent, paddr, size, EX_NOWAIT |
	    ((phys_map != NULL) ? EX_MALLOCOK : 0))) {
@


1.7
log
@Un-__P.

ok pefo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.6 2004/10/20 12:49:15 pefo Exp $ */
d527 2
a528 1
	return 0;
@


1.6
log
@Fix some 64 bit address problems.
Some function names made more unique.
Other changes for the upcoming Origin 200 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.5 2004/09/24 14:22:49 deraadt Exp $ */
d159 1
a159 1
static int      mace_pcibrprint __P((void *, const char *pnp));
d440 1
a440 1
	int (*func) __P((void *));
@


1.5
log
@new style interrupt counters; pefo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.4 2004/09/20 10:31:16 pefo Exp $ */
d30 1
a30 1
 * Machine dependent PCI BUS Bridge driver.
d61 3
a63 3
int	 pcibrmatch(struct device *, void *, void *);
void	 pcibrattach(struct device *, struct device *, void *);
void	 pcibr_attach_hook(struct device *, struct device *,
d65 1
a65 1
int	 pcibr_errintr(void *);
d67 2
a68 2
pcitag_t pcibr_make_tag(void *, int, int, int);
void	 pcibr_decompose_tag(void *, pcitag_t, int *, int *, int *);
d70 7
a76 7
int	 pcibr_bus_maxdevs(void *, int);
pcireg_t pcibr_conf_read(void *, pcitag_t, int);
void	 pcibr_conf_write(void *, pcitag_t, int, pcireg_t);

int      pcibr_intr_map(struct pci_attach_args *, pci_intr_handle_t *);
const char *pcibr_intr_string(void *, pci_intr_handle_t);
void     *pcibr_intr_establish(void *, pci_intr_handle_t,
d78 1
a78 1
void     pcibr_intr_disestablish(void *, void *);
d82 1
a82 1
	sizeof(struct pcibr_softc), pcibrmatch, pcibrattach,
d92 1
a92 1
bus_space_t pcibbus_mem_tag = {
d97 5
a101 5
	pcib_read_1, pcib_write_1,
	pcib_read_2, pcib_write_2,
	pcib_read_4, pcib_write_4,
	pcib_read_8, pcib_write_8,
	pcib_space_map, pcib_space_unmap, pcib_space_region,
d104 1
a104 1
bus_space_t pcibbus_io_tag = {
d109 5
a113 5
	pcib_read_1, pcib_write_1,
	pcib_read_2, pcib_write_2,
	pcib_read_4, pcib_write_4,
	pcib_read_8, pcib_write_8,
	pcib_space_map, pcib_space_unmap, pcib_space_region,
d159 1
a159 1
static int      pcibrprint __P((void *, const char *pnp));
d163 1
a163 1
pcibrmatch(struct device *parent, void *match, void *aux)
d173 1
a173 1
pcibrattach(struct device *parent, struct device *self, void *aux)
d175 1
a175 1
	struct pcibr_softc *sc = (struct pcibr_softc *)self;
d184 3
a186 3
	sc->sc_pc.pc_attach_hook = pcibr_attach_hook;
	sc->sc_pc.pc_make_tag = pcibr_make_tag;
	sc->sc_pc.pc_decompose_tag = pcibr_decompose_tag;
d190 1
a190 1
	pcibbus_io_tag.bus_extent = extent_create("pci_io",
d195 1
a195 1
	pcibbus_mem_tag.bus_extent = extent_create("pci_mem",
d201 1
a201 1
	sc->sc_mem_bus_space = &pcibbus_mem_tag;
d204 1
a204 1
	sc->sc_io_bus_space = &pcibbus_io_tag;
d218 1
a218 1
	    pcibr_errintr, (void *)sc, sc->sc_dev.dv_xname);
d220 3
a222 3
	sc->sc_pc.pc_bus_maxdevs = pcibr_bus_maxdevs;
	sc->sc_pc.pc_conf_read = pcibr_conf_read;
	sc->sc_pc.pc_conf_write = pcibr_conf_write;
d225 4
a228 4
	sc->sc_pc.pc_intr_map = pcibr_intr_map;
	sc->sc_pc.pc_intr_string = pcibr_intr_string;
	sc->sc_pc.pc_intr_establish = pcibr_intr_establish;
	sc->sc_pc.pc_intr_disestablish = pcibr_intr_disestablish;
d246 1
a246 1
	config_found(self, &pba, pcibrprint);
d256 1
a256 1
pcibrprint(aux, pnp)
d269 1
a269 1
pcibr_attach_hook(parent, self, pba)
d276 1
a276 1
pcibr_errintr(void *v)
d278 1
a278 1
	struct pcibr_softc *sc = v;
d305 1
a305 1
pcibr_make_tag(cpv, bus, dev, fnc)
d313 1
a313 1
pcibr_decompose_tag(cpv, tag, busp, devp, fncp)
d327 1
a327 1
pcibr_bus_maxdevs(cpv, busno)
d335 1
a335 1
pcibr_conf_read(cpv, tag, offset)
d340 1
a340 1
	struct pcibr_softc *sc = cpv;
d367 1
a367 1
pcibr_conf_write(cpv, tag, offset, data)
d373 1
a373 1
	struct pcibr_softc *sc = cpv;
d388 1
a388 1
pcibr_intr_map(struct pci_attach_args *pa, pci_intr_handle_t *ihp)
d399 1
a399 1
		printf("pcibr_intr_map: bad interrupt pin %d\n", pa->pa_intrpin);
d403 1
a403 1
	pcibr_decompose_tag((void *)NULL, pa->pa_tag, &bus, &device, NULL);
d425 1
a425 1
pcibr_intr_string(lcv, ih)
d436 1
a436 1
pcibr_intr_establish(lcv, ih, level, func, arg, name)
d448 1
a448 1
pcibr_intr_disestablish(lcv, cookie)
d460 1
a460 1
pcib_read_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
d466 1
a466 1
pcib_read_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
d472 1
a472 1
pcib_read_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
d478 1
a478 1
pcib_read_8(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o)
d484 1
a484 1
pcib_write_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o, u_int8_t v)
d490 1
a490 1
pcib_write_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o, u_int16_t v)
d496 1
a496 1
pcib_write_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o, u_int32_t v)
d502 1
a502 1
pcib_write_8(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o, u_int64_t v)
d508 1
a508 1
pcib_space_map(bus_space_tag_t t, bus_addr_t offs, bus_size_t size,
d531 1
a531 1
pcib_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size)
d561 1
a561 1
pcib_space_region(bus_space_tag_t t, bus_space_handle_t bsh,
@


1.4
log
@Add support for R10K cpu class
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.3 2004/08/11 15:13:35 deraadt Exp $ */
d429 1
a429 1
static char str[16];
@


1.3
log
@various ansi and spacing issues; pefo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.2 2004/08/10 19:16:18 deraadt Exp $ */
d187 1
a187 1
	sc->sc_pc.pc_sync_cache = Mips_IOSyncDCache;
@


1.2
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibridge.c,v 1.1 2004/08/06 21:12:19 pefo Exp $ */
d214 1
a214 1
	printf(" Mace revision %d, host system O2.\n", pcireg);
@


1.1
log
@initial sgi import
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 * 
d70 1
a70 1
int      pcibr_bus_maxdevs(void *, int);
d72 1
a72 1
void     pcibr_conf_write(void *, pcitag_t, int, pcireg_t);
d77 1
a77 1
            int, int (*func)(void *), void *, char *);
d82 1
a82 1
        sizeof(struct pcibr_softc), pcibrmatch, pcibrattach,
d262 1
a262 1
	if(pnp)
d394 8
a401 8
        if (pa->pa_intrpin == 0) {
                /* No IRQ used. */
                return 1;
        }
        if (pa->pa_intrpin > 4) {
                printf("pcibr_intr_map: bad interrupt pin %d\n", pa->pa_intrpin);
                return 1;
        }
d509 1
a509 1
        int cacheable, bus_space_handle_t *bshp)
d533 3
a535 3
        bus_addr_t sva;
        bus_size_t off, len;
        bus_addr_t paddr;
d564 2
a565 2
        *nbshp = bsh + offset;
        return (0);
@

