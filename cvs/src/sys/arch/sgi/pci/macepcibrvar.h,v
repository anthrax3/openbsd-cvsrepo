head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.30
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.32
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.28
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.24
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.26
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.18
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.22
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.20
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.16
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.14
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.12
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.10
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.4
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.3.0.14
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.12
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.10
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.8
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.6
date	2009.07.22.20.28.21;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.25.15.28.59;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2008.07.30.17.37.46;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.10.20.12.49.15;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.10.19.16.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.08.06.21.12.19;	author pefo;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Overhaul resource handling and mapping in macepcibr(4):
- do not use a stinking extent to track bus_space_map allocations, but
  directly map in XKPHYS instead. What are 64 bit address spaces good for
  if we still need to use TLB for that?
- provide proper resource management extents to the MI pci code, so that,
  in turn, the cardbus code can reuse them instead of providing their own.
- use the whole 4GB address space window for PCI I/O resources, just
  because we can.
- make sure no device can get assigned address zero in I/O space, because
  this address triggers a PCI error.
@
text
@/*	$OpenBSD: macepcibrvar.h,v 1.5 2009/04/25 15:28:59 kettenis Exp $ */

/*
 * Copyright (c) 2003-2004 Opsycon AB (www.opsycon.se)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#ifndef _PCIBRVAR_H_
#define _PCIBRVAR_H_

/*
 * Addresses of the PCI I/O and memory spaces.
 *
 * Note that PCI memory space addresses need to have bit 31 set to
 * reach hardware, otherwise they reach physical memory.
 */
#define	MACE_PCI_IO_BASE	0x100000000UL
#define	MACE_PCI_MEM_BASE	0x200000000UL
#define	MACE_PCI_MEM_OFFSET	0x80000000
#define	MACE_PCI_MEM_SIZE	0x80000000

struct mace_pcibr_softc {
	struct device	sc_dev;
	struct mips_bus_space *sc_mem_bus_space;
	struct mips_bus_space *sc_io_bus_space;
	struct mips_pci_chipset sc_pc;
	bus_space_tag_t sc_memt;
	bus_space_handle_t sc_memh;
};

u_int8_t mace_pcib_read_1(bus_space_tag_t, bus_space_handle_t, bus_size_t);
u_int16_t mace_pcib_read_2(bus_space_tag_t, bus_space_handle_t, bus_size_t);
u_int32_t mace_pcib_read_4(bus_space_tag_t, bus_space_handle_t, bus_size_t);
u_int64_t mace_pcib_read_8(bus_space_tag_t, bus_space_handle_t, bus_size_t);

void mace_pcib_write_1(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	u_int8_t);
void mace_pcib_write_2(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	u_int16_t);
void mace_pcib_write_4(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	u_int32_t);
void mace_pcib_write_8(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	u_int64_t);

void mace_pcib_read_raw_2(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, u_int8_t *, bus_size_t);
void mace_pcib_write_raw_2(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, const u_int8_t *, bus_size_t);
void mace_pcib_read_raw_4(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, u_int8_t *, bus_size_t);
void mace_pcib_write_raw_4(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, const u_int8_t *, bus_size_t);
void mace_pcib_read_raw_8(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, u_int8_t *, bus_size_t);
void mace_pcib_write_raw_8(bus_space_tag_t, bus_space_handle_t,
	    bus_addr_t, const u_int8_t *, bus_size_t);

int mace_pcib_space_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	bus_space_handle_t *);
void mace_pcib_space_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);
int mace_pcib_space_region(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	bus_size_t, bus_space_handle_t *);

#endif
@


1.5
log
@Extend PCI mmio address space by using a bigger window that requires 64-bit
adressing (no problem since we only support 64-bit mode).

ok miod@@, jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibrvar.h,v 1.4 2008/07/30 17:37:46 miod Exp $ */
d32 10
a41 4
#define	MACE_PCI_IO_BASE	0x18000000
#define	MACE_PCI_IO_SIZE	0x02000000
#define	MACE_PCI_MEM_BASE	0x280000000
#define	MACE_PCI_MEM_SIZE	0x100000000
@


1.4
log
@Implement bus_space_{read,write}_raw_mult_[248] correctly, it needs
endianness conversion on pci bridges.
ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibrvar.h,v 1.3 2004/10/20 12:49:15 pefo Exp $ */
d34 2
a35 2
#define	MACE_PCI_MEM_BASE	0x1a000000
#define	MACE_PCI_MEM_SIZE	0x02000000
@


1.3
log
@Fix some 64 bit address problems.
Some function names made more unique.
Other changes for the upcoming Origin 200 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibrvar.h,v 1.2 2004/08/10 19:16:18 deraadt Exp $ */
d59 13
@


1.2
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: macepcibrvar.h,v 1.1 2004/08/06 21:12:19 pefo Exp $ */
d37 1
a37 1
struct pcibr_softc {
d46 19
a64 13
u_int8_t pcib_read_1(bus_space_tag_t, bus_space_handle_t, bus_size_t);
u_int16_t pcib_read_2(bus_space_tag_t, bus_space_handle_t, bus_size_t);
u_int32_t pcib_read_4(bus_space_tag_t, bus_space_handle_t, bus_size_t);
u_int64_t pcib_read_8(bus_space_tag_t, bus_space_handle_t, bus_size_t);

void pcib_write_1(bus_space_tag_t, bus_space_handle_t, bus_size_t, u_int8_t);
void pcib_write_2(bus_space_tag_t, bus_space_handle_t, bus_size_t, u_int16_t);
void pcib_write_4(bus_space_tag_t, bus_space_handle_t, bus_size_t, u_int32_t);
void pcib_write_8(bus_space_tag_t, bus_space_handle_t, bus_size_t, u_int64_t);

int pcib_space_map(bus_space_tag_t, bus_addr_t, bus_size_t, int, bus_space_handle_t *);
void pcib_space_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);
int pcib_space_region(bus_space_tag_t, bus_space_handle_t, bus_size_t, bus_size_t, bus_space_handle_t *);
@


1.1
log
@initial sgi import
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 * 
@

