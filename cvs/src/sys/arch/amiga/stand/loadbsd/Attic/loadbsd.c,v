head	1.18;
access;
symbols
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	UBC_SYNC_A:1.18
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.17
	UBC:1.14.0.8
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.6
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.14.0.4
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.6
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.4
	SMP_BASE:1.13
	kame_19991208:1.13
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2002.12.31.16.35.39;	author miod;	state dead;
branches;
next	1.17;

1.17
date	2002.06.11.05.18.22;	author jsyn;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.03.15.52;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.30;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.07.15.39.24;	author espie;	state Exp;
branches
	1.14.8.1;
next	1.13;

1.13
date	99.09.09.21.25.13;	author espie;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	98.08.13.21.08.15;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	98.03.29.22.24.52;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	97.01.16.09.27.03;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.01.15.23.41.50;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.10.10.07.08.16;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.10.04.23.34.58;	author niklas;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	96.08.15.13.00.37;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.05.07.10.14.34;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.01.31.08.35.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.28.19.36.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.26.01.04.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.05;	author deraadt;	state Exp;
branches;
next	;

1.7.2.1
date	96.10.10.07.11.17;	author niklas;	state Exp;
branches;
next	;

1.13.4.1
date	2001.04.18.16.02.23;	author niklas;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2002.03.28.10.06.15;	author niklas;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2003.03.27.23.19.19;	author niklas;	state dead;
branches;
next	;

1.14.8.1
date	2002.06.11.03.34.58;	author art;	state Exp;
branches;
next	1.14.8.2;

1.14.8.2
date	2002.10.29.00.28.01;	author art;	state Exp;
branches;
next	1.14.8.3;

1.14.8.3
date	2003.05.19.21.49.40;	author tedu;	state dead;
branches;
next	;


desc
@@


1.18
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: loadbsd.c,v 1.17 2002/06/11 05:18:22 jsyn Exp $	*/
/*	$NetBSD: loadbsd.c,v 1.22 1996/10/13 13:39:52 is Exp $	*/

/*
 * Copyright (c) 1994 Michael L. Hitch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael L. Hitch.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <a.out.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <stdarg.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#if defined(__NetBSD__) || defined (__OpenBSD__)
#include <err.h>
#endif
#include <exec/types.h>
#include <exec/execbase.h>
#include <exec/memory.h>
#include <exec/resident.h>
#include <graphics/gfxbase.h>
#include <libraries/configregs.h>
#include <libraries/configvars.h>
#include <libraries/expansion.h>
#include <libraries/expansionbase.h>

#include <proto/exec.h>
#include <proto/expansion.h>
#include <proto/graphics.h>
#include <proto/dos.h>
/* Get definitions for boothowto */
#include "reboot.h"

#undef __LDPGSZ
#define __LDPGSZ 8192

#if !defined(__NetBSD__) && !defined(__OpenBSD__)
void err(int, const char *, ...);
void errx(int, const char *, ...);
void warn(const char *, ...);
void warnx(const char *, ...);
#endif

extern const char _version[];
/*
 *	Version history:
 *	1.x	Kernel startup interface version check.
 *	2.0	Added symbol table end address and symbol table support.
 *	2.1	03/23/94 - Round up end of fastram segment.
 *		Check fastram segment size for minimum of 2M.
 *		Use largest segment of highest priority if -p option.
 *		Print out fastram size in KB if not a multiple of MB.
 *	2.2	03/24/94 - Zero out all unused registers.
 *		Started version history comment.
 *	2.3	04/26/94 - Added -D option to enter debugger on boot.
 *	2.4	04/30/94 - Cpuid includes base machine type.
 *		Also check if CPU is capable of running OpenBSD.
 *	2.5	05/17/94 - Add check for "A3000 bonus".
 *	2.6	06/05/94 - Added -c option to override machine type.
 *	2.7	06/15/94 - Pass E clock frequency.
 *	2.8	06/22/94 - Fix supervisor stack usage.
 *	2.9	06/26/94 - Use PAL flag for E clock freq on pre 2.0 WB
 *		Added AGA enable parameter
 *	2.10	12/22/94 - Use FindResident() & OpenResource() for machine
 *		type detection.
 *		Add -n flag & option for non-contiguous memory.
 *		01/28/95 - Corrected -n on usage & help messages.
 *	2.11	03/12/95 - Check kernel size against chip memory size.
 *	2.12	11/11/95 - Add -I option to inhibit synchronous transfer
 *		11/12/95 - New kernel startup interface version - to
 *		support loading kernel image to fastmem rather than chipmem.
 *	2.13	04/15/96 - Direct load to fastmem.
 *		Add -Z flag to force chipmem load.
 *		Moved test mode exit to later - kernel image is created
 *		and startup interface version checked in test mode.
 *		Add -s flag for compatibility to bootblock loader.
 *		05/02/96 - Add a maximum startup interface version level
 *		to allow future kernel compatibility.
 *	2.14	06/26/96 is - Add first version of kludges needed to
 *		boot on DraCos. This can probably be done a bit more cleanly
 *		using TTRs, but it works for now.
 *	2.15	07/28/96 is - Add first version of kludges needed to
 *		get FusionForty kickrom'd memory back. Hope this doesn't
 *		break anything else.
 *
 *	2.13.1	OpenBSD branch: changed old -c to -C so new -c can be the
 *		architecture-independent bootflag for user-controlled
 *		startup configuration.
 *	2.15.1	Merge of changes from 2.13 -> 2.15
 *      2.15.2  03/30/98 ME - generic dust-off for amigaos compilation,
 *              turn on -Wall, clean up warnings. Be sensical about 
 *              ixemul/libnix issues.
 *      2.15.3  07/18/98 ME - poolmem awareness
 *      2.15.4  06/07/00 ME - change defaults to be less confusing
 */

/*
 * Kernel startup interface version
 *	1:	first version of loadbsd
 *	2:	needs esym location passed in a4
 *	3:	load kernel image into fastmem rather than chipmem
 *	MAX:	highest version with backward compatibility.
 */
#define KERNEL_STARTUP_VERSION	3
#define	KERNEL_STARTUP_VERSION_MAX	9

#define DRACOREVISION (*(UBYTE *)0x02000009)
#define DRACOMMUMARGIN 0x200000

#define MAXMEMSEG	16
struct boot_memlist {
	u_int	m_nseg; /* num_mem; */
	struct boot_memseg {
		u_int	ms_start;
		u_int	ms_size;
		u_short	ms_attrib;
		short	ms_pri;
	} m_seg[MAXMEMSEG];
};
struct boot_memlist memlist;
struct boot_memlist *kmemlist;

void get_mem_config(void **, u_long *, u_long *);
void get_cpuid(void);
void get_eclock(void);
void get_AGA(void);
void usage(void);
void verbose_usage(void);
void Version(void);
void startit(void *, u_long, u_long, void *, u_long, u_long, int, void *,
		int, int, u_long, u_long, int);
void startit_end(void);

extern void open_libraries(void);
extern void ensure_no_poolmem(void);

extern struct ExecBase *SysBase;
extern char *optarg;
extern int optind;

int k_flag;
int p_flag;
int t_flag;
int reqmemsz;
int S_flag = 1;
u_long I_flag;
int Z_flag;
u_long cpuid;
long eclock_freq;
long amiga_flags;
char *program_name;
char *kname;
/* let autoopen do its job */
extern struct ExpansionBase *ExpansionBase;
extern struct GfxBase *GfxBase;
u_char *kp;
int ksize;

int
main(argc, argv)
	int argc;
	char **argv;
{
	struct exec e;
	struct ConfigDev *cd, *kcd;
	u_long fmemsz, cmemsz;
	int fd, boothowto, textsz, stringsz, ncd, i, mem_ix, ch;
	u_short *kvers;
	int *nkcd;
	void *fmem;
	char *esym;
	void (*start_it)(void *, u_long, u_long, void *, u_long, u_long,
	     int, void *, int, int, u_long, u_long, int) = startit;

	program_name = argv[0];
	boothowto = RB_AUTOBOOT;

	open_libraries();

	while ((ch = getopt(argc, argv, "aAbcC:DhI:km:n:ptsRSVZ")) != -1) {
		switch (ch) {
		case 'k':
			k_flag = 1;
			break;
		case 'a':
			boothowto &= ~(RB_SINGLE);
			boothowto |= RB_AUTOBOOT;
			break;
		case 'b':
			boothowto |= RB_ASKNAME;
			break;
		case 'c':
			boothowto |= RB_CONFIG;
			break;
		case 'p':
			p_flag = 1;
			break;
		case 't':
			t_flag = 1;
			break;
		case 'm':
			reqmemsz = atoi(optarg) * 1024;
			break;
		case 's':
			boothowto &= ~(RB_AUTOBOOT);
			boothowto |= RB_SINGLE;
			break;
		case 'V':
			fprintf(stderr,"%s\n",_version + 6);
			break;
		case 'R':
			S_flag = 0;
			break;
		case 'S':
			S_flag = 1;
			break;
		case 'D':
			boothowto |= RB_KDB;
			break;
		case 'C':
			cpuid = atoi(optarg) << 16;
			break;
		case 'A':
			amiga_flags |= 1;
			break;
		case 'n':
			i = atoi(optarg);
			if (i >= 0 && i <= 3)
				amiga_flags |= i << 1;
			else
				err(20, "-n option must be 0, 1, 2, or 3");
			break;
		case 'I':
			I_flag = strtoul(optarg, NULL, 16);
			break;
		case 'Z':
			Z_flag = 1;
			break;
		case 'h':
			verbose_usage();
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc == 1)
		kname = argv[0];
	else if (argc == 0)
		kname = "bsd";
	else
		usage();
	
	if ((fd = open(kname, 0)) < 0)
		err(20, "open");
	if (read(fd, &e, sizeof(e)) != sizeof(e))
		err(20, "reading exec");
	if (e.a_magic != NMAGIC)
		err(20, "unknown binary");

	for (cd = 0, ncd = 0; ( cd = FindConfigDev(cd, -1, -1) ); ncd++)
		;
	get_cpuid();
	ensure_no_poolmem();
	get_mem_config(&fmem, &fmemsz, &cmemsz);
	get_eclock();
	get_AGA();

	textsz = (e.a_text + __LDPGSZ - 1) & (-__LDPGSZ);
	esym = NULL;
	ksize = textsz + e.a_data + e.a_bss + ncd * sizeof(*cd)
	    + 4 + memlist.m_nseg * sizeof(struct boot_memseg) + 4;

	/*
	 * get symbol table size & string size
	 * (should check kernel version to see if it will handle it)
	 */
	if (S_flag && e.a_syms) {
		if (lseek(fd, e.a_text + e.a_data + e.a_syms, SEEK_CUR) <= 0
		    || read(fd, &stringsz, 4) != 4
		    || lseek(fd, sizeof(e), SEEK_SET) < 0)
			err(20, "lseek for symbols");
		ksize += e.a_syms + 4 + ((stringsz + 3) & ~3);
	}

	kp = (u_char *)AllocMem(ksize + ((char *)startit_end - (char *)startit) + 256,
	    MEMF_FAST|MEMF_REVERSE);
	if (t_flag) {
		for (i = 0; i < memlist.m_nseg; ++i) {
			printf("mem segment %d: start=%08x size=%08x"
			    " attribute=%04x pri=%d\n",
			    i + 1, memlist.m_seg[i].ms_start,
			    memlist.m_seg[i].ms_size,
			    memlist.m_seg[i].ms_attrib,
			    memlist.m_seg[i].ms_pri);
		}
		printf("kernel size: %d\n", ksize);
	}
	if (kp == NULL)
		err(20, "failed malloc %d", ksize);

	if (read(fd, kp, e.a_text) != e.a_text 
	    || read(fd, kp + textsz, e.a_data) != e.a_data)
		err(20, "unable to read kernel image");

	if (k_flag) {
		fmem += 4 * 1024 * 1024;
		fmemsz -= 4 * 1024 * 1024;
	}

	if (reqmemsz && reqmemsz <= fmemsz)
		fmemsz = reqmemsz;
	if (boothowto & RB_AUTOBOOT)
		printf("Autobooting...");
	if (boothowto & RB_ASKNAME)
		printf("Askboot...");

	printf("Using %ld%c FASTMEM at 0x%p, %ldM CHIPMEM\n",
	    (fmemsz & 0xfffff) ? fmemsz >> 10 : fmemsz >> 20,
	    (fmemsz & 0xfffff) ? 'K' : 'M', fmem, cmemsz >> 20);
	kvers = (u_short *)(kp + e.a_entry - 2);
	if (*kvers > KERNEL_STARTUP_VERSION_MAX && *kvers != 0x4e73)
		err(20, "newer loadbsd required: %d", *kvers);
	if (*kvers > KERNEL_STARTUP_VERSION) {
		printf("****************************************************\n");
		printf("*** Notice:  this kernel has features which require\n");
		printf("*** a newer version of loadbsd.  To allow the use of\n");
		printf("*** any newer features or capabilities, you should\n");
		printf("*** update to a newer version of loadbsd\n");
		printf("****************************************************\n");
		sleep(3);	/* even more time to see that message */
	}
	if ((cpuid & AFB_68020) == 0)
		err(20, "cpu not supported");
	/*
	 * give them a chance to read the information...
	 */
	sleep(2);

	bzero(kp + textsz + e.a_data, e.a_bss);
	/*
	 * If symbols wanted (and kernel can handle them),
	 * load symbol table & strings and set esym to end.
	 */
	nkcd = (int *)(kp + textsz + e.a_data + e.a_bss);
	if (*kvers != 0x4e73 && *kvers > 1 && S_flag && e.a_syms) {
		*nkcd++ = e.a_syms;
		read(fd, (char *)nkcd, e.a_syms);
		nkcd = (int *)((char *)nkcd + e.a_syms);
		read(fd, (char *)nkcd, stringsz);
		    nkcd = (int *)((char *)nkcd + ((stringsz + 3) & ~3));
		    esym = (char *)(textsz + e.a_data + e.a_bss
		    + e.a_syms + 4 + ((stringsz + 3) & ~3));
	}
	*nkcd = ncd;

	kcd = (struct ConfigDev *)(nkcd + 1); 
	while( (cd = FindConfigDev(cd, -1, -1)) ) {
		*kcd = *cd;
		if (((cpuid >> 24) == 0x7d) &&
		    ((u_long)kcd->cd_BoardAddr < 0x1000000)) {
			if (t_flag)
				printf("Transformed Z2 device from %8p ",
				    kcd->cd_BoardAddr);
			kcd->cd_BoardAddr += 0x3000000;

			if (t_flag)
				printf("to %8p\n", kcd->cd_BoardAddr);
		}
		++kcd;
	}

	kmemlist = (struct boot_memlist *)kcd;
	kmemlist->m_nseg = memlist.m_nseg;
	for (mem_ix = 0; mem_ix < memlist.m_nseg; mem_ix++)
		kmemlist->m_seg[mem_ix] = memlist.m_seg[mem_ix];

	if (*kvers > 2 && Z_flag == 0) {
		/*
		 * Kernel supports direct load to fastmem, and the -Z
		 * option was not specified.  Copy startup code to end
		 * of kernel image and set start_it.
		 */
		if ((void *)kp < fmem) {
			printf("Kernel at %8p, Fastmem used at %8p\n",
			    kp, fmem);
			errx(20, "Can't copy upwards yet.\nDefragment your memory and try again OR try the -p OR try the -Z options.");
		}
		memcpy(kp + ksize + 256, (char *)startit,
		    (char *)startit_end - (char *)startit);
		CacheClearU();
		start_it = (void (*)())kp + ksize + 256;
		printf("*** Loading from %8p to Fastmem %8p ***\n",
		    kp, fmem);
		sleep(2);
	} else {
		/*
		 * Either the kernel doesn't suppport loading directly to
		 * fastmem or the -Z flag was given.  Verify kernel image
		 * fits into chipmem.
		 */
		if (ksize >= cmemsz) {
			printf("Kernel size %d exceeds Chip Memory of %ld\n",
			    ksize, cmemsz);
			err(20, "Insufficient Chip Memory for kernel");
		}
		Z_flag = 1;
		printf("*** Loading from %8p to Chipmem ***\n", kp);
	}

	/*
	 * if test option set, done
	 */
	if (t_flag) {
		if (kp)
			FreeMem(kp, ksize + ((char *)startit_end 
			    - (char *)startit) + 256);
		exit(0);
	}
		
	/*
	 * XXX AGA startup - may need more
	 */
	LoadView(NULL);		/* Don't do this if AGA active? */
	start_it(kp, ksize, e.a_entry, fmem, fmemsz, cmemsz, boothowto, esym,
	    cpuid, eclock_freq, amiga_flags, I_flag, Z_flag == 0);
	/*NOTREACHED*/
}

void
get_mem_config(fmem, fmemsz, cmemsz)
	void **fmem;
	u_long *fmemsz, *cmemsz;
{
	struct MemHeader *mh, *nmh;
	u_int segsz, seg, eseg, nmem, nseg, nsegsz;
/*	u_int tseg, tsegsz;	unused */
	char mempri;

	nmem = 0;
	mempri = -128;
	*fmemsz = 0;
	*cmemsz = 0;

	/*
	 * walk thru the exec memory list
	 */
	Forbid();
	for (mh  = (void *) SysBase->MemList.lh_Head;
	    (nmh = (void *) mh->mh_Node.ln_Succ); mh = nmh) {

		nseg = (u_int)mh->mh_Lower;
		nsegsz = (u_int)mh->mh_Upper - nseg;

		segsz = nsegsz;
		seg = (u_int)CachePreDMA((APTR)nseg, (LONG *)&segsz, 0L);
		nsegsz -= segsz, nseg += segsz;
		for (;segsz;
		    segsz = nsegsz, 
		    seg = (u_int)CachePreDMA((APTR)nseg, (LONG *)&segsz, DMA_Continue),
		    nsegsz -= segsz, nseg += segsz, ++nmem) {

			if (t_flag)
				printf("Translated %08x sz %08x to %08x sz %08x\n",
				    nseg - segsz, nsegsz + segsz, seg, segsz);
		
			eseg = seg + segsz;

	
			if ((cpuid >> 24) == 0x7D) {
				/* DraCo MMU table kludge */
				
				segsz = ((segsz -1) | 0xfffff) + 1;
				seg = eseg - segsz;

				/* 
				 * Only use first SIMM to boot; we know it is VA==PA. 
				 * Enter into table and continue. Yes,
				 * this is ugly.
				 */
				if (seg != 0x40000000) {
					memlist.m_seg[nmem].ms_attrib = mh->mh_Attributes;
					memlist.m_seg[nmem].ms_pri = mh->mh_Node.ln_Pri;
					memlist.m_seg[nmem].ms_size = segsz;
					memlist.m_seg[nmem].ms_start = seg;
					++nmem;
					continue; 
				}

				memlist.m_seg[nmem].ms_attrib = mh->mh_Attributes;
				memlist.m_seg[nmem].ms_pri = mh->mh_Node.ln_Pri;
				memlist.m_seg[nmem].ms_size = DRACOMMUMARGIN;
				memlist.m_seg[nmem].ms_start = seg;

				++nmem;
				seg += DRACOMMUMARGIN;
				segsz -= DRACOMMUMARGIN;						
			}

			memlist.m_seg[nmem].ms_attrib = mh->mh_Attributes;
			memlist.m_seg[nmem].ms_pri = mh->mh_Node.ln_Pri;
			memlist.m_seg[nmem].ms_size = segsz;
			memlist.m_seg[nmem].ms_start = seg;
		
			if ((mh->mh_Attributes & (MEMF_CHIP|MEMF_FAST)) == MEMF_CHIP) {
				/* 
				 * there should hardly be more than one entry for 
				 * chip mem, but handle it the same nevertheless 
				 * cmem always starts at 0, so include vector area
				 */
				memlist.m_seg[nmem].ms_start = seg = 0;
				/*
				 * round to multiple of 512K
				 */
				segsz = (segsz + 512 * 1024 - 1) & -(512 * 1024);
				memlist.m_seg[nmem].ms_size = segsz;
				if (segsz > *cmemsz)
					*cmemsz = segsz;
				continue;
			}
			/* 
			 * some heuristics..
			 */
			seg &= -__LDPGSZ;
			eseg = (eseg + __LDPGSZ - 1) & -__LDPGSZ;
	
			/*
			 * get the mem back stolen by incore kickstart on 
			 * A3000 with V36 bootrom.
			 */
			if (eseg == 0x07f80000)
				eseg = 0x08000000;
	
			/*
			 * or by zkick on a A2000.
			 */
			if (seg == 0x280000 &&
			    strcmp(mh->mh_Node.ln_Name, "zkick memory") == 0)
				seg = 0x200000;
			/*
			 * or by Fusion Forty fastrom
			 */
			if ((seg & ~(1024*1024-1)) == 0x11000000) {
				/* 
				 * XXX we should test the name.
				 * Unfortunately, the memory is just called
				 * "32 bit memory" which isn't very specific.
				 */
				seg = 0x11000000;
			}
	
			segsz = eseg - seg;
			memlist.m_seg[nmem].ms_start = seg;
			memlist.m_seg[nmem].ms_size = segsz;
			/*
			 *  If this segment is smaller than 2M,
			 *  don't use it to load the kernel
			 */
			if (segsz < 2 * 1024 * 1024)
				continue;
			/*
			 * if p_flag is set, select memory by priority 
			 * instead of size
			 */
			if ((!p_flag && segsz > *fmemsz) || (p_flag &&
			   mempri <= mh->mh_Node.ln_Pri && segsz > *fmemsz)) {
				*fmemsz = segsz;
				*fmem = (void *)seg;
				mempri = mh->mh_Node.ln_Pri;
			}

		}
	}
	memlist.m_nseg = nmem;
	Permit();
}

/*
 * Try to determine the machine ID by searching the resident module list
 * for modules only present on specific machines.  (Thanks, Bill!)
 */
void
get_cpuid()
{
#if 0
		/* unused */
	u_long *rl;
	struct Resident *rm;
	struct Node *rn;		/* Resource node entry */
#endif

	cpuid |= SysBase->AttnFlags;	/* get FPU and CPU flags */
	if (cpuid & 0xffff0000) {
		if ((cpuid & 0xff000000) == 0x7D)
			return;

		switch (cpuid >> 16) {
		case 500:
		case 600:
		case 1000:
		case 1200:
		case 2000:
		case 3000:
		case 4000:
			return;
		default:
			printf("machine Amiga %ld is not recognized\n",
			    cpuid >> 16);
			exit(1);
		}
	}
	if (FindResident("A4000 Bonus") || FindResident("A4000 bonus")
	    || FindResident("A1000 Bonus"))
		cpuid |= 4000 << 16;
	else if (FindResident("A3000 Bonus") || FindResident("A3000 bonus"))
		cpuid |= 3000 << 16;
	else if (OpenResource("card.resource")) {
		/* Test for AGA? */
		cpuid |= 1200 << 16;
	} else if (OpenResource("draco.resource")) {
		cpuid |= (32000 | DRACOREVISION) << 16;
	}
	/*
	 * Nothing found, it's probably an A2000 or A500
	 */
	if ((cpuid >> 16) == 0)
		cpuid |= 2000 << 16;
}

void
get_eclock()
{
#if 0
	/* XXX not called for, unless you manage to get libnix/ixemul to work under <2.0 */
	/* Fix for 1.3 startups? */
	if (SysBase->LibNode.lib_Version > 36)
#endif
		eclock_freq = SysBase->ex_EClockFrequency;
#if 0
	else
		eclock_freq = (GfxBase->DisplayFlags & PAL) ?
		    709379 : 715909;
#endif
}

void
get_AGA()
{
	/*
	 * Determine if an AGA mode is active
	 */
}


asm("
	.set	ABSEXECBASE,4

	.text
	.globl	_startit

_startit:
	movel	sp,a3
	movel	4:w,a6
	lea	pc@@(start_super),a5
	jmp	a6@@(-0x1e)		| supervisor-call

start_super:
	movew	#0x2700,sr

	| the BSD kernel wants values into the following registers:
	| a0:  fastmem-start
	| d0:  fastmem-size
	| d1:  chipmem-size
	| d3:  Amiga specific flags
	| d4:  E clock frequency
	| d5:  AttnFlags (cpuid)
	| d7:  boothowto
	| a4:  esym location
	| a2:  Inhibit sync flags
	| All other registers zeroed for possible future requirements.

	lea	pc@@(_startit),sp	| make sure we have a good stack ***

	movel	a3@@(4),a1		| loaded kernel
	movel	a3@@(8),d2		| length of loaded kernel
|	movel	a3@@(12),sp		| entry point in stack pointer
	movel	a3@@(12),a6		| push entry point		***
	movel	a3@@(16),a0		| fastmem-start
	movel	a3@@(20),d0		| fastmem-size
	movel	a3@@(24),d1		| chipmem-size
	movel	a3@@(28),d7		| boothowto
	movel	a3@@(32),a4		| esym
	movel	a3@@(36),d5		| cpuid
	movel	a3@@(40),d4		| E clock frequency
	movel	a3@@(44),d3		| Amiga flags
	movel	a3@@(48),a2		| Inhibit sync flags
	movel	a3@@(52),d6		| Load to fastmem flag
	subl	a5,a5			| target, load to 0

	cmpb	#0x7D,a3@@(36)		| is it DraCo?
	beq	nott			| yes, switch off MMU later

					| no, it is an Amiga:

|	movew	#0xf00,0xdff180		|red
|	moveb	#0,0x200003c8
|	moveb	#63,0x200003c9
|	moveb	#0,0x200003c9
|	moveb	#0,0x200003c9

	movew	#(1<<9),0xdff096	| disable DMA on Amigas.

| ------ mmu off start -----

	btst	#3,d5			| AFB_68040,SysBase->AttnFlags
	beq	not040

| Turn off 68040/060 MMU

	subl	a3,a3
	.word 0x4e7b,0xb003		| movec a3,tc
	.word 0x4e7b,0xb806		| movec a3,urp
	.word 0x4e7b,0xb807		| movec a3,srp
	.word 0x4e7b,0xb004		| movec a3,itt0
	.word 0x4e7b,0xb005		| movec a3,itt1
	.word 0x4e7b,0xb006		| movec a3,dtt0
	.word 0x4e7b,0xb007		| movec a3,dtt1
	bra	nott

not040:
	lea	pc@@(zero),a3
	pmove	a3@@,tc			| Turn off MMU
	lea	pc@@(nullrp),a3
	pmove	a3@@,crp			| Turn off MMU some more
	pmove	a3@@,srp			| Really, really, turn off MMU

| Turn off 68030 TT registers

	btst	#2,d5			| AFB_68030,SysBase->AttnFlags
	beq	nott			| Skip TT registers if not 68030
	lea	pc@@(zero),a3
	.word 0xf013,0x0800		| pmove a3@@,tt0 (gas only knows about 68851 ops..)
	.word 0xf013,0x0c00		| pmove a3@@,tt1 (gas only knows about 68851 ops..)

nott:
| ---- mmu off end ----
|	movew	#0xf60,0xdff180		| orange
|	moveb	#0,0x200003c8
|	moveb	#63,0x200003c9
|	moveb	#24,0x200003c9
|	moveb	#0,0x200003c9

| ---- copy kernel start ----

	tstl	d6			| Can we load to fastmem?
	beq	L0			| No, leave destination at 0
	movl	a0,a5			| Move to start of fastmem chunk
	addl	a0,a6			| relocate kernel entry point
L0:
	movl	a1@@+,a5@@+
	subl	#4,d2
	bcc	L0

	lea	pc@@(ckend:w),a1
	movl	a5,sp@@-
	movl	#_startit_end - ckend,d2
L2:
	movl	a1@@+,a5@@+
	subl	#4,d2
	bcc	L2

	btst	#3,d5
	jeq	L1
	.word	0xf4f8
L1:	movql	#0,d2			| switch off cache to ensure we use
	movec	d2,cacr			| valid kernel data

|	movew	#0xFF0,0xdff180		| yellow
|	moveb	#0,0x200003c8
|	moveb	#63,0x200003c9
|	moveb	#0,0x200003c9
|	moveb	#0,0x200003c9
	rts

| ---- copy kernel end ----

ckend:
|	movew	#0x0ff,0xdff180		| petrol
|	moveb	#0,0x200003c8
|	moveb	#0,0x200003c9
|	moveb	#63,0x200003c9
|	moveb	#63,0x200003c9

	movl	d5,d2
	roll	#8,d2
	cmpb	#0x7D,d2
	jne	noDraCo

| DraCo: switch off MMU now:

	subl	a3,a3
	.word 0x4e7b,0xb003		| movec a3,tc
	.word 0x4e7b,0xb806		| movec a3,urp
	.word 0x4e7b,0xb807		| movec a3,srp
	.word 0x4e7b,0xb004		| movec a3,itt0
	.word 0x4e7b,0xb005		| movec a3,itt1
	.word 0x4e7b,0xb006		| movec a3,dtt0
	.word 0x4e7b,0xb007		| movec a3,dtt1
	
noDraCo:
	moveq	#0,d2			| zero out unused registers
	moveq	#0,d6			| (might make future compatibility
	movel	d6,a1			|  would have known contents)
	movel	d6,a3
	movel	d6,a5
	movel	a6,sp			| entry point into stack pointer
	movel	d6,a6

|	movew	#0x0F0,0xdff180		| green
|	moveb	#0,0x200003c8
|	moveb	#0,0x200003c9
|	moveb	#63,0x200003c9
|	moveb	#0,0x200003c9

	jmp	sp@@			| jump to kernel entry point


| A do-nothing MMU root pointer (includes the following long as well)

nullrp:	.long	0x7fff0001
zero:	.long	0

_startit_end:

");

void
usage()
{
	fprintf(stderr,
	     "usage: %s [-abchkpstADRSVZ] [-C machine] [-m mem] [-n mode]\n",
	     program_name);
	fprintf(stderr,"           [-I sync-inhibit] [kernel]\n");
	exit(1);
}


void
verbose_usage()
{
	fprintf(stderr, "
NAME
\t%s - loads OpenBSD from amiga dos.
SYNOPSIS
\t%s [-abchkpstADRSVZ] [-C machine] [-m mem] [-n flags]
\t    [-I sync-inhibit] kernel
OPTIONS
\t-a  Boot up to multiuser mode (default).
\t-A  Use AGA display mode, if available.
\t-b  Ask for which root device.
\t    Its possible to have multiple roots and choose between them.
\t-c  Enter user-controlled startup-configuration mode.
\t-C  Set machine type. [e.g 3000; use 32000+N for DraCo rev. N]
\t-D  Enter debugger
\t-h  This help message.
\t-I  Inhibit sync negotiation. Option value is bit-encoded targets.
\t-k  Reserve the first 4M of fast mem [Some one else
\t    is going to have to answer what that it is used for].
\t-m  Tweak amount of available memory, for finding minimum amount
\t    of memory required to run. Sets fastmem size to specified
\t    size in Kbytes.
\t-n  Enable multiple non-contiguous memory: value = 0 (disabled),
\t    1 (two segments), 2 (all avail segments), 3 (same as 2?).
\t-p  Use highest priority fastmem segement instead of the largest
\t    segment. The higher priority segment is usually faster
\t    (i.e. 32 bit memory), but some people have smaller amounts
\t    of 32 bit memory.
\t-s  Boot up in singleuser mode.
\t-R  Remove kernel symbol table.
\t-S  Include kernel symbol table (default).
\t-t  This is a *test* option.  It prints out the memory
\t    list information being passed to the kernel and also
\t    exits without actually starting OpenBSD.
\t-V  Version of loadbsd program.
\t-Z  Force kernel load to chipmem.
HISTORY
\tThis version supports Kernel version 720 +\n",
      program_name, program_name);
      exit(1);
}


void
_Vdomessage(doexit, eval, doerrno, fmt, args)
	int doexit, doerrno, eval;
	const char *fmt;
	va_list args;
{
	fprintf(stderr, "%s: ", program_name);
	if (fmt) {
		vfprintf(stderr, fmt, args);
		fprintf(stderr, ": ");
	}
	if (doerrno && errno < sys_nerr) {
		fprintf(stderr, "%s", strerror(errno));
#if 0
		if (errno == EINTR || errno == 0) {
			int  sigs;
			sigpending((sigset_t *)&sigs);
			printf("%x\n", sigs);
		}
#endif
	}
	fprintf(stderr, "\n");
	if (doexit) {
		if (kp)
			FreeMem(kp, ksize + ((char *)startit_end 
			    - (char *)startit) + 256);
		exit(eval);
	}
}

void
err(int eval, const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	_Vdomessage(1, eval, 1, fmt, ap);
	/*NOTREACHED*/
}

void
errx(int eval, const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	_Vdomessage(1, eval, 0, fmt, ap);
	/*NOTREACHED*/
}

void
warn(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	_Vdomessage(0, 0, 1, fmt, ap);
	va_end(ap);
}

void
warnx(const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	_Vdomessage(0, 0, 0, fmt, ap);
	va_end(ap);
}


@


1.17
log
@err(3) appends a newline already; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: loadbsd.c,v 1.16 2002/03/14 03:15:52 millert Exp $	*/
@


1.16
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: loadbsd.c,v 1.15 2002/03/14 01:26:30 millert Exp $	*/
d332 1
a332 1
		err(20, "failed malloc %d\n", ksize);
d336 1
a336 1
		err(20, "unable to read kernel image\n");
d355 1
a355 1
		err(20, "newer loadbsd required: %d\n", *kvers);
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: loadbsd.c,v 1.14 2000/06/07 15:39:24 espie Exp $	*/
a68 7
#ifndef __P
#ifdef __STDC__
#define __P(x) x
#else
#define __P(x)
#endif
#endif
d383 1
a383 1
		    nkcd = (int*)((char *)nkcd + ((stringsz + 3) & ~3));
@


1.14
log
@At art@@'s prompting, change amiga's loadbsd  flag parsing to look more
like other bsd loaders (defaults to -a -S).
@
text
@d1 1
a1 1
/*	$OpenBSD: loadbsd.c,v 1.13 1999/09/09 21:25:13 espie Exp $	*/
d76 4
a79 4
void err __P((int, const char *, ...));
void errx __P((int, const char *, ...));
void warn __P((const char *, ...));
void warnx __P((const char *, ...));
d161 10
a170 10
void get_mem_config __P((void **, u_long *, u_long *));
void get_cpuid __P((void));
void get_eclock __P((void));
void get_AGA __P((void));
void usage __P((void));
void verbose_usage __P((void));
void Version __P((void));
void startit __P((void *, u_long, u_long, void *, u_long, u_long, int, void *,
		int, int, u_long, u_long, int));
void startit_end __P((void));
d172 2
a173 2
extern void open_libraries __P((void));
extern void ensure_no_poolmem __P((void));
d210 2
a211 2
	void (*start_it) __P((void *, u_long, u_long, void *, u_long, u_long,
	     int, void *, int, int, u_long, u_long, int)) = startit;
@


1.14.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: loadbsd.c,v 1.14 2000/06/07 15:39:24 espie Exp $	*/
d69 11
a79 4
void err(int, const char *, ...);
void errx(int, const char *, ...);
void warn(const char *, ...);
void warnx(const char *, ...);
d161 10
a170 10
void get_mem_config(void **, u_long *, u_long *);
void get_cpuid(void);
void get_eclock(void);
void get_AGA(void);
void usage(void);
void verbose_usage(void);
void Version(void);
void startit(void *, u_long, u_long, void *, u_long, u_long, int, void *,
		int, int, u_long, u_long, int);
void startit_end(void);
d172 2
a173 2
extern void open_libraries(void);
extern void ensure_no_poolmem(void);
d210 2
a211 2
	void (*start_it)(void *, u_long, u_long, void *, u_long, u_long,
	     int, void *, int, int, u_long, u_long, int) = startit;
d390 1
a390 1
		    nkcd = (int *)((char *)nkcd + ((stringsz + 3) & ~3));
@


1.14.8.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: loadbsd.c,v 1.14.8.1 2002/06/11 03:34:58 art Exp $	*/
d332 1
a332 1
		err(20, "failed malloc %d", ksize);
d336 1
a336 1
		err(20, "unable to read kernel image");
d355 1
a355 1
		err(20, "newer loadbsd required: %d", *kvers);
@


1.14.8.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: loadbsd.c,v 1.14.8.2 2002/10/29 00:28:01 art Exp $	*/
@


1.13
log
@Put the loadbsd amigaos binary into our repository to ease
make release.

Corresponding wrapper.

New loadbsd.8 man page.

New binary itself (gcc 2.95.1 runs under amigaos now)
@
text
@d1 1
a1 1
/*	$OpenBSD: loadbsd.c,v 1.12 1998/08/13 21:08:15 espie Exp $	*/
d132 1
d183 1
a183 1
int S_flag;
d214 1
a214 1
	boothowto = RB_SINGLE;
a215 2
	if (argc < 2)
		usage();
d218 1
a218 1
	while ((ch = getopt(argc, argv, "aAbcC:DhI:km:n:ptsSVZ")) != -1) {
d249 3
d286 5
a290 1
	if (argc != 1)
a291 1
	kname = argv[0];
d880 1
a880 1
	     "usage: %s [-abchkpstADSVZ] [-C machine] [-m mem] [-n mode]\n",
d882 1
a882 1
	fprintf(stderr,"           [-I sync-inhibit] kernel\n");
d894 1
a894 1
\t%s [-abchkpstADSVZ] [-C machine] [-m mem] [-n flags]
d897 1
a897 1
\t-a  Boot up to multiuser mode.
d917 3
a919 2
\t-s  Boot up in singleuser mode (default).
\t-S  Include kernel symbol table.
@


1.13.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: loadbsd.c,v 1.14 2000/06/07 15:39:24 espie Exp $	*/
a131 1
 *      2.15.4  06/07/00 ME - change defaults to be less confusing
d182 1
a182 1
int S_flag = 1;
d213 1
a213 1
	boothowto = RB_AUTOBOOT;
d215 2
d219 1
a219 1
	while ((ch = getopt(argc, argv, "aAbcC:DhI:km:n:ptsRSVZ")) != -1) {
a249 3
		case 'R':
			S_flag = 0;
			break;
d284 1
a284 5
	if (argc == 1)
		kname = argv[0];
	else if (argc == 0)
		kname = "bsd";
	else
d286 1
d875 1
a875 1
	     "usage: %s [-abchkpstADRSVZ] [-C machine] [-m mem] [-n mode]\n",
d877 1
a877 1
	fprintf(stderr,"           [-I sync-inhibit] [kernel]\n");
d889 1
a889 1
\t%s [-abchkpstADRSVZ] [-C machine] [-m mem] [-n flags]
d892 1
a892 1
\t-a  Boot up to multiuser mode (default).
d912 2
a913 3
\t-s  Boot up in singleuser mode.
\t-R  Remove kernel symbol table.
\t-S  Include kernel symbol table (default).
@


1.13.4.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 11
a79 4
void err(int, const char *, ...);
void errx(int, const char *, ...);
void warn(const char *, ...);
void warnx(const char *, ...);
d161 10
a170 10
void get_mem_config(void **, u_long *, u_long *);
void get_cpuid(void);
void get_eclock(void);
void get_AGA(void);
void usage(void);
void verbose_usage(void);
void Version(void);
void startit(void *, u_long, u_long, void *, u_long, u_long, int, void *,
		int, int, u_long, u_long, int);
void startit_end(void);
d172 2
a173 2
extern void open_libraries(void);
extern void ensure_no_poolmem(void);
d210 2
a211 2
	void (*start_it)(void *, u_long, u_long, void *, u_long, u_long,
	     int, void *, int, int, u_long, u_long, int) = startit;
d390 1
a390 1
		    nkcd = (int *)((char *)nkcd + ((stringsz + 3) & ~3));
@


1.13.4.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: loadbsd.c,v 1.13.4.2 2002/03/28 10:06:15 niklas Exp $	*/
@


1.12
log
@Make loadbsd aware of poolmem (mainly, kill poolmem before scanning the
memory list)
@
text
@d1 1
a1 1
/*	$OpenBSD: loadbsd.c,v 1.11 1998/03/29 22:24:52 espie Exp $	*/
a82 3
extern void open_libraries(void);
extern void ensure_no_poolmem(void);

d171 3
a173 1
extern void ensure_no_poolmem(void);
@


1.11
log
@

Updated to compile with recent AmigaOS Geek Gadgets toolchain,
plus clean-up.
@
text
@d1 1
a1 1
/*	$OpenBSD: loadbsd.c,v 1.10 1997/01/16 09:27:03 niklas Exp $	*/
d84 1
d134 1
a162 1

d174 1
d299 1
@


1.10
log
@Sync to NetBSD 970110
@
text
@d1 1
a1 1
/*	$OpenBSD: loadbsd.c,v 1.8 1996/10/10 07:08:16 niklas Exp $	*/
d41 4
d58 4
a61 4
#include <inline/exec.h>
#include <inline/expansion.h>
#include <inline/graphics.h>

d82 3
d130 3
a133 1
static const char _version[] = "$VER: LoadBSD 2.15.1 (OpenBSD 04.10.96)";
d189 3
a191 2
struct ExpansionBase *ExpansionBase;
struct GfxBase *GfxBase;
d216 1
a216 4
	if ((GfxBase = (void *)OpenLibrary(GRAPHICSNAME, 0)) == NULL)
		err(20, "can't open graphics library");
	if ((ExpansionBase=(void *)OpenLibrary(EXPANSIONNAME, 0)) == NULL)
		err(20, "can't open expansion library");
d294 1
a294 1
	for (cd = 0, ncd = 0; cd = FindConfigDev(cd, -1, -1); ncd++)
d322 2
a323 2
			printf("mem segment %d: start=%08lx size=%08lx"
			    " attribute=%04lx pri=%d\n",
d350 1
a350 1
	printf("Using %d%c FASTMEM at 0x%x, %dM CHIPMEM\n",
d390 1
a390 1
	while(cd = FindConfigDev(cd, -1, -1)) {
d395 1
a395 1
				printf("Transformed Z2 device from %08lx ",
d400 1
a400 1
				printf("to %08lx\n", kcd->cd_BoardAddr);
d417 1
a417 1
			printf("Kernel at %08lx, Fastmem used at %08lx\n",
d425 1
a425 1
		printf("*** Loading from %08lx to Fastmem %08lx ***\n",
d435 1
a435 1
			printf("Kernel size %d exceeds Chip Memory of %d\n",
d440 1
a440 1
		printf("*** Loading from %08lx to Chipmem ***\n");
d469 1
a469 1
	u_int tseg, tsegsz;
d482 1
a482 1
	    nmh = (void *) mh->mh_Node.ln_Succ; mh = nmh) {
d617 2
d622 1
d639 1
a639 1
			printf("machine Amiga %d is not recognized\n",
d665 2
d669 1
d671 1
d675 1
a987 7
}


u_int
sleep(u_int n)
{
	(void)TimeDelay(0L, n, 0L);
@


1.9
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d2 1
a2 1
/*	$NetBSD: loadbsd.c,v 1.19.4.2 1996/08/03 00:51:46 jtc Exp $	*/
d412 1
a412 1
			errx(20, "Can't copy downwards yet.");
@


1.8
log
@This is OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: loadbsd.c,v 1.7 1996/10/04 23:34:58 niklas Exp $	*/
d211 1
a211 1
	while ((ch = getopt(argc, argv, "aAbcC:DhI:km:n:ptsSVZ")) != EOF) {
@


1.7
log
@Merge of NetBSD 1.2 (961004)
@
text
@d1 1
a1 1
/*	$OpenBSD: loadbsd.c,v 1.6 1996/08/15 13:00:37 niklas Exp $	*/
d41 1
a41 1
#ifdef __NetBSD__
d64 1
a64 1
#ifndef __NetBSD__
d90 1
a90 1
 *		Also check if CPU is capable of running NetBSD.
d857 4
a860 2
	fprintf(stderr, "usage: %s [-abhkpstADSVZ] [-c machine] [-m mem] [-n mode] [-I sync-inhibit] kernel\n",
	    program_name);
d870 1
a870 1
\t%s - loads NetBSD from amiga dos.
d872 2
a873 1
\t%s [-abchkpstADSVZ] [-C machine] [-m mem] [-n flags] [-I sync-inhibit] kernel
d899 1
a899 1
\t    exits without actually starting NetBSD.
@


1.7.2.1
log
@Pullup: This is OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: loadbsd.c,v 1.8 1996/10/10 07:08:16 niklas Exp $	*/
d41 1
a41 1
#if defined(__NetBSD__) || defined (__OpenBSD__)
d64 1
a64 1
#if !defined(__NetBSD__) && !defined(__OpenBSD__)
d90 1
a90 1
 *		Also check if CPU is capable of running OpenBSD.
d857 2
a858 4
	fprintf(stderr,
	     "usage: %s [-abchkpstADSVZ] [-C machine] [-m mem] [-n mode]\n",
	     program_name);
	fprintf(stderr,"           [-I sync-inhibit] kernel\n");
d868 1
a868 1
\t%s - loads OpenBSD from amiga dos.
d870 1
a870 2
\t%s [-abchkpstADSVZ] [-C machine] [-m mem] [-n flags]
\t    [-I sync-inhibit] kernel
d896 1
a896 1
\t    exits without actually starting OpenBSD.
@


1.6
log
@Change old -c flag to -C, support -c for BOOT_CONFIG
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: loadbsd.c,v 1.19 1996/05/04 01:23:37 mhitch Exp $	*/
d112 7
d122 1
d124 1
a124 1
static const char _version[] = "$VER: LoadBSD 2.13.1 (OpenBSD 15.8.96)";
d136 3
d182 2
a183 1

d193 1
a193 1
	int fd, boothowto, ksize, textsz, stringsz, ncd, i, mem_ix, ch;
a195 1
	u_char *kp;
d289 1
a290 1
	get_cpuid();
d311 2
a312 1
	kp = (u_char *)malloc(ksize + ((char *)startit_end - (char *)startit) + 256);
d383 14
a396 2
	while(cd = FindConfigDev(cd, -1, -1))
		*kcd++ = *cd;
d409 5
d439 4
a442 1
	if (t_flag)
d444 1
d461 2
a462 1
	u_int segsz, seg, eseg, nmem;
d474 50
a523 9
	for (mh  = (void *) SysBase->MemList.lh_Head; 
	    nmh = (void *) mh->mh_Node.ln_Succ; mh = nmh, nmem++) {
		memlist.m_seg[nmem].ms_attrib = mh->mh_Attributes;
		memlist.m_seg[nmem].ms_pri = mh->mh_Node.ln_Pri;
		seg = (u_int)mh->mh_Lower;
		eseg = (u_int)mh->mh_Upper;
		segsz = eseg - seg;
		memlist.m_seg[nmem].ms_size = segsz;
		memlist.m_seg[nmem].ms_start = seg;
d525 21
a545 1
		if (mh->mh_Attributes & MEMF_CHIP) {
d547 14
a560 3
			 * there should hardly be more than one entry for 
			 * chip mem, but handle it the same nevertheless 
			 * cmem always starts at 0, so include vector area
d562 3
a564 1
			memlist.m_seg[nmem].ms_start = seg = 0;
d566 1
a566 1
			 * round to multiple of 512K
d568 11
a578 1
			segsz = (segsz + 512 * 1024 - 1) & -(512 * 1024);
d580 16
a595 9
			if (segsz > *cmemsz)
				*cmemsz = segsz;
			continue;
		}
		/* 
		 * some heuristics..
		 */
		seg &= -__LDPGSZ;
		eseg = (eseg + __LDPGSZ - 1) & -__LDPGSZ;
a596 32
		/*
		 * get the mem back stolen by incore kickstart on 
		 * A3000 with V36 bootrom.
		 */
		if (eseg == 0x07f80000)
			eseg = 0x08000000;

		/*
		 * or by zkick on a A2000.
		 */
		if (seg == 0x280000 &&
		    strcmp(mh->mh_Node.ln_Name, "zkick memory") == 0)
			seg = 0x200000;

		segsz = eseg - seg;
		memlist.m_seg[nmem].ms_start = seg;
		memlist.m_seg[nmem].ms_size = segsz;
		/*
		 *  If this segment is smaller than 2M,
		 *  don't use it to load the kernel
		 */
		if (segsz < 2 * 1024 * 1024)
			continue;
		/*
		 * if p_flag is set, select memory by priority 
		 * instead of size
		 */
		if ((!p_flag && segsz > *fmemsz) || (p_flag &&
		   mempri <= mh->mh_Node.ln_Pri && segsz > *fmemsz)) {
			*fmemsz = segsz;
			*fmem = (void *)seg;
			mempri = mh->mh_Node.ln_Pri;
d616 3
d642 2
d681 1
a681 1
	lea	pc@@(start_super-.+2),a5
d699 2
a700 1
	lea	pc@@(_startit-.+2),sp	| make sure we have a good stack ***
d704 1
a704 1
	movel	a3@@(12),sp@@-		| push entry point		***
d717 16
a732 1
	btst	#3,(ABSEXECBASE)@@(0x129) | AFB_68040,SysBase->AttnFlags
d735 1
a735 1
| Turn off 68040 MMU
d737 8
a744 7
	.word 0x4e7b,0xd003		| movec a5,tc
	.word 0x4e7b,0xd806		| movec a5,urp
	.word 0x4e7b,0xd807		| movec a5,srp
	.word 0x4e7b,0xd004		| movec a5,itt0
	.word 0x4e7b,0xd005		| movec a5,itt1
	.word 0x4e7b,0xd006		| movec a5,dtt0
	.word 0x4e7b,0xd007		| movec a5,dtt1
d748 1
a748 1
	lea	pc@@(zero-.+2),a3
d750 1
a750 1
	lea	pc@@(nullrp-.+2),a3
d756 1
a756 1
	btst	#2,(ABSEXECBASE)@@(0x129) | AFB_68030,SysBase->AttnFlags
d758 1
a758 1
	lea	pc@@(zero-.+2),a3
d763 6
d770 1
a770 1
	movew	#(1<<9),0xdff096	| disable DMA
d775 1
a775 2
	movl	a0,d6			|   and relocate kernel entry
	addl	d6,sp@@			|   address (on top of stack)
d781 47
d833 1
d835 8
a842 2
|	jmp	sp@@			| jump to kernel entry point
	rts				| enter kernel at address on stack ***
d877 1
a877 1
\t-C  Set machine type. [e.g 3000]
d919 1
d925 1
d928 4
a931 1
	if (doexit)
d933 1
d971 9
@


1.5
log
@From NetBSD:
Add support for loading kernel into fastmem, if the kernel also supports
loading into fastmem.  This removes the requirement that the kernel fit
into chipmem.
Add a -Z flag to force loading into chip memory.
Add a -s option for compatibility with my bootblock loader.
Move the test exit to just before starting the kernel;  this lets the
test mode actually load the kernel and do the version checks.
@
text
@d111 4
a114 1
 &		to allow future kernel compatibility.
d116 1
a116 1
static const char _version[] = "$VER: LoadBSD 2.13 (2.5.96)";
d200 1
a200 1
	while ((ch = getopt(argc, argv, "aAbc:DhI:km:n:ptsSVZ")) != EOF) {
d212 3
d237 1
a237 1
		case 'c':
d696 1
a696 1
\t%s [-abhkpstADSVZ] [-c machine] [-m mem] [-n flags] [-I sync-inhibit] kernel
d702 2
a703 1
\t-c  Set machine type. [e.g 3000]
@


1.4
log
@from netbsd; check for "A4000 bonus" too
@
text
@d1 2
a2 1
/*	$NetBSD: loadbsd.c,v 1.18 1996/01/28 20:01:10 chopps Exp $	*/
d80 1
a80 1
 *	1.x	Kernel parameter passing version check.
d103 9
a111 3
 *		11/12/95 - New kernel parameter version - to support passing
 *		a kernel parameter data structure and support moving kernel
 *		image to fastmem rather than chipmem.
d113 1
a113 1
static const char _version[] = "$VER: LoadBSD 2.12 (12.11.95)";
d116 1
a116 1
 * Kernel parameter passing version
d119 2
a120 2
 *	3:	allow kernel image in fastmem rather than chipmem, and
 *		passing kernel parameters in a data structure
d122 2
a123 1
#define KERNEL_PARAMETER_VERSION	3
d146 3
d160 1
d184 2
d197 1
a197 1
	while ((ch = getopt(argc, argv, "aAbc:DhI:km:n:ptSV")) != EOF) {
d218 4
d247 3
d291 1
a291 1
		ksize += e.a_syms + 4 + stringsz;
d294 1
a294 6
	if (ksize >= cmemsz) {
		printf("Kernel size %d exceeds Chip Memory of %d\n",
		    ksize, cmemsz);
		err(20, "Insufficient Chip Memory for kernel");
	}
	kp = (u_char *)malloc(ksize);
d329 1
a329 1
	if (*kvers > KERNEL_PARAMETER_VERSION && *kvers != 0x4e73)
d331 1
a331 1
	if (*kvers > 2) {
d336 1
a336 1
		printf("*** update your copy of loadbsd\n");
d358 1
a358 1
		    nkcd = (int*)((char *)nkcd + stringsz);
d360 1
a360 1
		    + e.a_syms + 4 + stringsz);
d372 29
d411 2
a412 2
	startit(kp, ksize, e.a_entry, fmem, fmemsz, cmemsz, boothowto, esym,
	    cpuid, eclock_freq, amiga_flags, I_flag);
d609 1
d645 5
d651 2
a652 2
	moveb	a1@@+,a5@@+
	subl	#1,d2
a654 1

d670 1
d677 1
a677 1
	fprintf(stderr, "usage: %s [-abhkptADSV] [-c machine] [-m mem] [-n mode] [-I sync-inhibit] kernel\n",
d690 1
a690 1
\t%s [-abhkptDSV] [-c machine] [-m mem] [-n flags] kernel
d711 1
d717 1
@


1.3
log
@let loadbsd define sync scsi operation
@
text
@d1 1
a1 1
/*	$NetBSD: loadbsd.c,v 1.16.2.2 1995/11/24 07:51:27 chopps Exp $	*/
d487 2
a488 1
	if (FindResident("A4000 Bonus") || FindResident("A1000 Bonus"))
@


1.2
log
@update from netbsd tree
@
text
@d1 1
a1 1
/*	$NetBSD: loadbsd.c,v 1.16.2.1 1995/10/20 11:01:16 chopps Exp $	*/
d101 4
d106 1
a106 1
static const char _version[] = "$VER: LoadBSD 2.11 (12.3.95)";
d112 2
d115 1
a115 1
#define KERNEL_PARAMETER_VERSION	2
d148 1
d183 1
a183 1
	while ((ch = getopt(argc, argv, "aAbc:Dhkm:n:ptSV")) != EOF) {
d226 3
d273 3
a275 1
	if (ksize >= cmemsz)
d277 1
d288 1
d315 9
d367 1
a367 1
	    cpuid, eclock_freq, amiga_flags);
d546 1
d562 1
a606 1
	movel	d6,a2
d625 1
a625 1
	fprintf(stderr, "usage: %s [-abhkptADSV] [-c machine] [-m mem] [-n mode] kernel\n",
d641 1
d645 1
d647 1
d659 1
a662 3
\t-S  Include kernel symbol table.
\t-D  Enter debugger
\t-A  Use AGA display mode, if available.
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: loadbsd.c,v 1.16 1995/02/12 19:19:41 chopps Exp $	*/
d100 1
d102 1
a102 1
static const char _version[] = "$VER: LoadBSD 2.10 (28.1.95)";
d263 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
