head	1.17;
access;
symbols
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.16
	UBC:1.14.0.4
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.13.0.12
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.13.0.10
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.8
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.6
	SMP_BASE:1.13
	kame_19991208:1.13
	OPENBSD_2_6:1.13.0.4
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.12.0.4
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.17
date	2002.12.31.16.35.38;	author miod;	state dead;
branches;
next	1.16;

1.16
date	2002.03.14.03.15.52;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.29;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.25.00.43.08;	author mickey;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	99.01.19.10.04.54;	author niklas;	state Exp;
branches
	1.13.6.1;
next	1.12;

1.12
date	98.03.01.12.53.43;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.09.09.22.55.55;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.09.09.22.41.43;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.01.04.12.49.24;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.11.28.23.33.08;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.11.23.21.45.26;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.11.12.20.29.49;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.08.04.01.30.49;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.06.04.13.40.14;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.04.27.18.38.58;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.15.40.56;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.02.26.21.55.52;	author niklas;	state Exp;
branches;
next	;

1.13.6.1
date	2001.07.04.10.15.19;	author niklas;	state Exp;
branches;
next	1.13.6.2;

1.13.6.2
date	2002.03.28.10.06.15;	author niklas;	state Exp;
branches;
next	1.13.6.3;

1.13.6.3
date	2003.03.27.23.19.18;	author niklas;	state dead;
branches;
next	;

1.14.4.1
date	2002.06.11.03.34.58;	author art;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2003.05.19.21.49.39;	author tedu;	state dead;
branches;
next	;


desc
@@


1.17
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: ggbus.c,v 1.16 2002/03/14 03:15:52 millert Exp $	*/

/*
 * Copyright (c) 1994, 1995, 1996 Niklas Hallqvist
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niklas Hallqvist.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/syslog.h>
#include <sys/systm.h>

#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/intr.h>

#include <dev/isa/isavar.h>

#include <amiga/amiga/custom.h>
#include <amiga/amiga/device.h>
#include <amiga/amiga/isr.h>
#include <amiga/dev/zbusvar.h>
#include <amiga/isa/isa_machdep.h>
#include <amiga/isa/ggbusvar.h>
#include <amiga/isa/ggbusreg.h>

int ggdebug = 0;
int ggstrayints = 0;

void	ggbusattach(struct device *, struct device *, void *);
int	ggbusmatch(struct device *, void *, void *);
int	ggbusprint(void *, const char *);

int	ggbus_io_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
int	ggbus_mem_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
int	ggbus_cannot_mem_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
int	ggbus_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);

int	ggbusintr(void *);

void	ggbus_attach_hook(struct device *, struct device *,
	    struct isabus_attach_args *);
void	*ggbus_intr_establish(void *, int, int, int, int (*)(void *),
	    void *, char *);
void	ggbus_intr_disestablish(void *, void *);
int	ggbus_intr_check(void *, int, int);

struct cfattach ggbus_ca = {
	sizeof(struct ggbus_softc), ggbusmatch, ggbusattach
};

struct cfdriver ggbus_cd = {
	NULL, "ggbus", DV_DULL, 0
};

int
ggbusmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct zbus_args *zap = aux;

	/*
	 * Check manufacturer and product id.
	 */
	if (zap->manid == 2150 && zap->prodid == 1)
		return (1);
	return (0);
}

void
ggbusattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct ggbus_softc *sc = (struct ggbus_softc *)self;
	struct zbus_args *zap = aux;
	struct isabus_attach_args iba;

	bcopy(zap, &sc->sc_zargs, sizeof(struct zbus_args));
	sc->sc_iot.bs_data = sc;
	sc->sc_iot.bs_map = ggbus_io_map;
	sc->sc_iot.bs_unmap = ggbus_unmap;
	sc->sc_iot.bs_swapped = 0;
	sc->sc_iot.bs_shift = 1;
	if (sc->sc_zargs.serno >= 2) {
		sc->sc_memt.bs_data = sc;
		sc->sc_memt.bs_map = ggbus_mem_map;
		sc->sc_memt.bs_unmap = ggbus_unmap;
		sc->sc_memt.bs_swapped = 0;
		sc->sc_memt.bs_shift = 1;
		sc->sc_status = GG2_STATUS_ADDR(sc->sc_zargs.va);

		/* XXX turn on wait states unconditionally for now. */
		GG2_ENABLE_WAIT(zap->va);
		GG2_ENABLE_INTS(zap->va);
	} else
		sc->sc_memt.bs_map = ggbus_cannot_mem_map;

	printf(": pa 0x%08x va 0x%08x size 0x%x\n", zap->pa, zap->va,
	    zap->size);

	sc->sc_ic.ic_data = sc;
	sc->sc_ic.ic_attach_hook = ggbus_attach_hook;
	sc->sc_ic.ic_intr_establish = ggbus_intr_establish;
	sc->sc_ic.ic_intr_disestablish = ggbus_intr_disestablish;
	sc->sc_ic.ic_intr_check = ggbus_intr_check;

	iba.iba_busname = "isa";
	iba.iba_iot = &sc->sc_iot;
	iba.iba_memt = &sc->sc_memt;
	iba.iba_ic = &sc->sc_ic;
	config_found(self, &iba, ggbusprint);
}

int
ggbusprint(auxp, pnp)
	void *auxp;
	const char *pnp;
{
	if (pnp == NULL)
		return (QUIET);
	return (UNCONF);
}

int
ggbus_io_map(bst, addr, sz, cacheable, handle)
	bus_space_tag_t bst;
	bus_addr_t addr;
	bus_size_t sz;
	int cacheable;
	bus_space_handle_t *handle;
{
	*handle = (bus_space_handle_t)
	    ((struct ggbus_softc *)bst->bs_data)->sc_zargs.va + 2 * addr + 1;
	return (0);
}

int
ggbus_mem_map(bst, addr, sz, cacheable, handle)
	bus_space_tag_t bst;
	bus_addr_t addr;
	bus_size_t sz;
	int cacheable;
	bus_space_handle_t *handle;
{
	*handle = (bus_space_handle_t)
	    ((struct ggbus_softc *)bst->bs_data)->sc_zargs.va + 2 * addr +
	    GG2_MEMORY_OFFSET;
	return (0);
}

int
ggbus_cannot_mem_map(bst, addr, sz, cacheable, handle)
	bus_space_tag_t bst;
	bus_addr_t addr;
	bus_size_t sz;
	int cacheable;
	bus_space_handle_t *handle;
{
	static int have_warned = 0;

	if (!have_warned++)
		printf("The Golden Gate 1 cannot map ISA memory.\n");
	return (1);
}

int
ggbus_unmap(bst, handle, sz)
	bus_space_tag_t bst;
	bus_space_handle_t handle;
	bus_size_t sz;
{
	return (0);
}

static int ggbus_int_map[] = {
    0, 0, 0, 0, GG2_IRQ3, GG2_IRQ4, GG2_IRQ5, GG2_IRQ6, GG2_IRQ7, 0,
    GG2_IRQ9, GG2_IRQ10, GG2_IRQ11, GG2_IRQ12, 0, GG2_IRQ14, GG2_IRQ15
};

int
ggbusintr(v)
	void *v;
{
	struct intrhand *ih = (struct intrhand *)v;
	int handled;

	if (!(*ih->ih_status & ih->ih_mask))
		return (0);
	for (handled = 0; ih; ih = ih->ih_next)
		if ((*ih->ih_fun)(ih->ih_arg))
			handled = 1;
	return (handled);
}

void
ggbus_attach_hook(parent, self, iba)
	struct device *parent, *self;
	struct isabus_attach_args *iba;
{
}

void *
ggbus_intr_establish(ic, irq, type, level, ih_fun, ih_arg, ih_what)
	void *ic;
	int irq;
	int type;
	int level;
	int (*ih_fun)(void *);
	void *ih_arg;
	char *ih_what;
{
	struct intrhand **p, *c, *ih;
	struct ggbus_softc *sc = (struct ggbus_softc *)ic;

	/* no point in sleeping unless someone can free memory. */
	ih = malloc(sizeof *ih, M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL) {
		printf("ggbus_intr_establish: can't malloc handler info");
		return (NULL);
	}

	if (irq > ICU_LEN || type == IST_NONE) {
		printf("ggbus_intr_establish: bogus irq or type");
		return (NULL);
	}

	switch (sc->sc_intrsharetype[irq]) {
	case IST_NONE:
		sc->sc_intrsharetype[irq] = type;
		break;
	case IST_EDGE:
	case IST_LEVEL:
		if (type == sc->sc_intrsharetype[irq])
			break;
	case IST_PULSE:
		if (type != IST_NONE)
			printf("ggbus_intr_establish: can't share %s with %s",
			    isa_intr_typename(sc->sc_intrsharetype[irq]),
			    isa_intr_typename(type));
		break;
        }

	/*
	 * Figure out where to put the handler.
	 * This is O(N^2), but we want to preserve the order, and N is
	 * generally small.
	 */
	for (p = &sc->sc_ih[irq]; (c = *p) != NULL; p = &c->ih_next)
		;

	/*
	 * Poke the real handler in now.
	 */
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_count = 0;
	ih->ih_next = NULL;
	ih->ih_irq = irq;
	ih->ih_what = ih_what;
	ih->ih_mask = 1 << ggbus_int_map[irq + 1];
	ih->ih_status = sc->sc_status;
	ih->ih_isr.isr_intr = ggbusintr;
	ih->ih_isr.isr_arg = ih;
	ih->ih_isr.isr_ipl = 6;
	ih->ih_isr.isr_mapped_ipl = level;
	*p = ih;

	add_isr(&ih->ih_isr);
	return (ih);
}

void
ggbus_intr_disestablish(ic, arg)
	void *ic;
	void *arg;
{
	struct intrhand *ih = arg;
	struct ggbus_softc *sc = (struct ggbus_softc *)ic;
	int irq = ih->ih_irq;
	struct intrhand **p, *q;

	if (irq > ICU_LEN)
		panic("ggbus_intr_establish: bogus irq");

	remove_isr(&ih->ih_isr);

	/*
	 * Remove the handler from the chain.
	 * This is O(n^2), too.
	 */
	for (p = &sc->sc_ih[irq]; (q = *p) != NULL && q != ih; p = &q->ih_next)
		;
	if (q)
		*p = q->ih_next;
	else
		panic("ggbus_intr_disestablish: handler not registered");
	free(ih, M_DEVBUF);

	if (sc->sc_intrsharetype[irq] == NULL)
		sc->sc_intrsharetype[irq] = IST_NONE;
}

int
ggbus_intr_check(ic, irq, type)
	void *ic;
	int irq;
	int type;
{
	struct ggbus_softc *sc = (struct ggbus_softc *)ic;

	return (__isa_intr_check(irq, type, sc->sc_intrsharetype));
}
@


1.16
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ggbus.c,v 1.15 2002/03/14 01:26:29 millert Exp $	*/
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ggbus.c,v 1.14 2001/06/25 00:43:08 mickey Exp $	*/
d73 2
a74 2
void	*ggbus_intr_establish __P((void *, int, int, int, int (*)(void *),
	    void *, char *));
@


1.14
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: ggbus.c,v 1.13 1999/01/19 10:04:54 niklas Exp $	*/
d57 11
a67 11
void	ggbusattach __P((struct device *, struct device *, void *));
int	ggbusmatch __P((struct device *, void *, void *));
int	ggbusprint __P((void *, const char *));

int	ggbus_io_map __P((bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *));
int	ggbus_mem_map __P((bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *));
int	ggbus_cannot_mem_map __P((bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *));
int	ggbus_unmap __P((bus_space_tag_t, bus_space_handle_t, bus_size_t));
d69 1
a69 1
int	ggbusintr __P((void *));
d71 2
a72 2
void	ggbus_attach_hook __P((struct device *, struct device *,
	    struct isabus_attach_args *));
d75 2
a76 2
void	ggbus_intr_disestablish __P((void *, void *));
int	ggbus_intr_check __P((void *, int, int));
@


1.14.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ggbus.c,v 1.14 2001/06/25 00:43:08 mickey Exp $	*/
d57 20
a76 20
void	ggbusattach(struct device *, struct device *, void *);
int	ggbusmatch(struct device *, void *, void *);
int	ggbusprint(void *, const char *);

int	ggbus_io_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
int	ggbus_mem_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
int	ggbus_cannot_mem_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
int	ggbus_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);

int	ggbusintr(void *);

void	ggbus_attach_hook(struct device *, struct device *,
	    struct isabus_attach_args *);
void	*ggbus_intr_establish(void *, int, int, int, int (*)(void *),
	    void *, char *);
void	ggbus_intr_disestablish(void *, void *);
int	ggbus_intr_check(void *, int, int);
@


1.14.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: ggbus.c,v 1.14.4.1 2002/06/11 03:34:58 art Exp $	*/
@


1.13
log
@Add isa_intr_check functionality
@
text
@d1 1
a1 1
/*	$OpenBSD: ggbus.c,v 1.12 1998/03/01 12:53:43 niklas Exp $	*/
a52 2

extern int cold;
@


1.13.6.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ggbus.c,v 1.13 1999/01/19 10:04:54 niklas Exp $	*/
d53 2
@


1.13.6.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 20
a76 20
void	ggbusattach(struct device *, struct device *, void *);
int	ggbusmatch(struct device *, void *, void *);
int	ggbusprint(void *, const char *);

int	ggbus_io_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
int	ggbus_mem_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
int	ggbus_cannot_mem_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
int	ggbus_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);

int	ggbusintr(void *);

void	ggbus_attach_hook(struct device *, struct device *,
	    struct isabus_attach_args *);
void	*ggbus_intr_establish(void *, int, int, int, int (*)(void *),
	    void *, char *);
void	ggbus_intr_disestablish(void *, void *);
int	ggbus_intr_check(void *, int, int);
@


1.13.6.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: ggbus.c,v 1.13.6.2 2002/03/28 10:06:15 niklas Exp $	*/
@


1.12
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: ggbus.c,v 1.11 1997/09/09 22:55:55 niklas Exp $	*/
d78 1
d139 1
d251 9
a259 5
	if (ih == NULL)
		panic("ggbus_intr_establish: can't malloc handler info");

	if (irq > ICU_LEN || type == IST_NONE)
		panic("ggbus_intr_establish: bogus irq or type");
d262 3
d271 1
a271 1
			panic("ggbus_intr_establish: can't share %s with %s",
d335 11
@


1.11
log
@KNF return nits
@
text
@d1 1
a1 1
/*	$OpenBSD: ggbus.c,v 1.9 1997/01/04 12:49:24 niklas Exp $	*/
d207 1
a207 1
static ggbus_int_map[] = {
@


1.10
log
@Make the bus_addr_t shift amount in addr calculations dynamic
@
text
@d98 2
a99 2
		return(1);
	return(0);
d152 2
a153 2
		return(QUIET);
	return(UNCONF);
d166 1
a166 1
	return 0;
d180 1
a180 1
	return 0;
d195 1
a195 1
	return -1;
d204 1
a204 1
	return 0;
d220 1
a220 1
		return 0;
d224 1
a224 1
	return handled;
d294 1
a294 1
	return ih;
@


1.9
log
@bus.h not bus.old.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ggbus.c,v 1.8 1996/11/28 23:33:08 niklas Exp $	*/
d116 1
d122 1
@


1.8
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ggbus.c,v 1.7 1996/11/23 21:45:26 kstailey Exp $	*/
d40 1
a40 1
#include <machine/bus.old.h>
@


1.7
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: ggbus.c,v 1.6 1996/11/12 20:29:49 niklas Exp $	*/
d63 7
a69 44
int	ggbus_io_map __P((bus_chipset_tag_t, bus_io_addr_t, bus_io_size_t,
	    bus_io_handle_t *));
int	ggbus_mem_map __P((bus_chipset_tag_t, bus_mem_addr_t, bus_mem_size_t,
	    int, bus_mem_handle_t *));

void	ggbus_io_read_multi_1 __P((bus_io_handle_t, bus_io_size_t, u_int8_t *,
	    bus_io_size_t));
void	ggbus_io_read_multi_2 __P((bus_io_handle_t, bus_io_size_t, u_int16_t *,
	    bus_io_size_t));

void	ggbus_io_write_multi_1 __P((bus_io_handle_t, bus_io_size_t,
	    const u_int8_t *, bus_io_size_t));
void	ggbus_io_write_multi_2 __P((bus_io_handle_t, bus_io_size_t,
	    const u_int16_t *, bus_io_size_t));

/*
 * Note that the following unified access functions are prototyped for the
 * I/O access case.  We use casts to get type correctness.
 */
int	ggbus_unmap __P((bus_io_handle_t, bus_io_size_t));

__inline u_int8_t ggbus_read_1 __P((bus_io_handle_t, bus_io_size_t));
__inline u_int16_t ggbus_read_2 __P((bus_io_handle_t, bus_io_size_t));

__inline void ggbus_write_1 __P((bus_io_handle_t, bus_io_size_t, u_int8_t));
__inline void ggbus_write_2 __P((bus_io_handle_t, bus_io_size_t, u_int16_t));

void	ggbus_io_read_raw_multi_2 __P((bus_io_handle_t, bus_io_size_t,
	    u_int8_t *, bus_io_size_t));
void	ggbus_io_write_raw_multi_2 __P((bus_io_handle_t, bus_io_size_t,
	    const u_int8_t *, bus_io_size_t));

/*
 * In order to share the access function implementations for I/O and memory
 * access we cast the functions for the memory access case.  These typedefs
 * make that casting look nicer.
 */
typedef int (*bus_mem_unmap_t) __P((bus_mem_handle_t, bus_mem_size_t));
typedef u_int8_t (*bus_mem_read_1_t) __P((bus_mem_handle_t, bus_mem_size_t));
typedef u_int16_t (*bus_mem_read_2_t) __P((bus_mem_handle_t, bus_mem_size_t));
typedef void (*bus_mem_write_1_t) __P((bus_mem_handle_t, bus_mem_size_t,
	    u_int8_t));
typedef void (*bus_mem_write_2_t) __P((bus_mem_handle_t, bus_mem_size_t,
	    u_int16_t));
a78 56
static u_int16_t swap __P((u_int16_t));

/* Golden Gate I.  */
struct amiga_bus_chipset ggbus1_chipset = {
	0 /* bc_data */,

	ggbus_io_map, ggbus_unmap,
	ggbus_read_1, ggbus_read_2,
	0 /* bc_io_read_4 */, 0 /* bc_io_read_8 */,
	ggbus_io_read_multi_1, ggbus_io_read_multi_2,
	0 /* bc_io_multi_4 */, 0 /* bc_io_multi_8 */,
	ggbus_write_1, ggbus_write_2,
	0 /* bc_io_write_4 */, 0 /* bc_io_write_8 */,
	ggbus_io_write_multi_1, ggbus_io_write_multi_2,
	0 /* bc_io_write_multi_4 */, 0 /* bc_io_write_multi_8 */,

	0 /* bc_mem_map */, 0 /* bc_mem_unmap */,
	0 /* bc_mem_read_1 */, 0 /* bc_mem_read_2 */,
	0 /* bc_mem_read_4 */, 0 /* bc_mem_read_8 */,
	0 /* bc_mem_write_1 */, 0 /* bc_mem_write_2 */,
	0 /* bc_mem_write_4 */, 0 /* bc_mem_write_8 */,

	0 /* bc_io_read_raw_multi_2 */,
	0 /* bc_io_read_raw_multi_4 */, 0 /* bc_io_read_raw_multi_8 */,

	0 /* bc_io_write_raw_multi_2 */,
	0 /* bc_io_write_raw_multi_4 */, 0 /* bc_io_write_raw_multi_8 */,
};

/* Golden Gate II.  */
struct amiga_bus_chipset ggbus2_chipset = {
	0 /* bc_data */,

	ggbus_io_map, ggbus_unmap,
	ggbus_read_1, ggbus_read_2,
	0 /* bc_io_read_4 */, 0 /* bc_io_read_8 */,
	ggbus_io_read_multi_1, ggbus_io_read_multi_2,
	0 /* bc_io_multi_4 */, 0 /* bc_io_multi_8 */,
	ggbus_write_1, ggbus_write_2,
	0 /* bc_io_write_4 */, 0 /* bc_io_write_8 */,
	ggbus_io_write_multi_1, ggbus_io_write_multi_2,
	0 /* bc_io_write_multi_4 */, 0 /* bc_io_write_multi_8 */,

	ggbus_mem_map, (bus_mem_unmap_t)ggbus_unmap,
	(bus_mem_read_1_t)ggbus_read_1, (bus_mem_read_2_t)ggbus_read_2,
	0 /* bc_mem_read_4 */, 0 /* bc_mem_read_8 */,
	(bus_mem_write_1_t)ggbus_write_1, (bus_mem_write_2_t)ggbus_write_2,
	0 /* bc_mem_write_4 */, 0 /* bc_mem_write_8 */,

	ggbus_io_read_raw_multi_2,
	0 /* bc_io_read_raw_multi_4 */, 0 /* bc_io_read_raw_multi_8 */,

	ggbus_io_write_raw_multi_2,
	0 /* bc_io_write_raw_multi_4 */, 0 /* bc_io_write_raw_multi_8 */,
};

d112 10
a121 5
	/* XXX Is serno reliable?  */
	bcopy(zap->serno < 2 ? &ggbus1_chipset : &ggbus2_chipset,
	    &sc->sc_bc, sizeof(struct amiga_bus_chipset));
	sc->sc_bc.bc_data = sc;
	sc->sc_status = GG2_STATUS_ADDR(sc->sc_zargs.va);
a122 1
	if (sc->sc_zargs.serno >= 2) {
d126 2
a127 1
	}
d138 2
a139 1
	iba.iba_bc = &sc->sc_bc;
d155 9
a163 11
ggbus_io_map(bct, addr, sz, handle)
	bus_chipset_tag_t bct;
	bus_io_addr_t addr;
	bus_io_size_t sz;
	bus_io_handle_t *handle;
{
	*handle = (bus_io_handle_t)
	    ((struct ggbus_softc *)bct->bc_data)->sc_zargs.va + 2 * addr;
#if 0
	printf("io_map %x %d -> %x\n", addr, sz, *handle);
#endif
d168 4
a171 4
ggbus_mem_map(bct, addr, sz, cacheable, handle)
	bus_chipset_tag_t bct;
	bus_mem_addr_t addr;
	bus_mem_size_t sz;
d173 1
a173 1
	bus_mem_handle_t *handle;
d175 2
a176 2
	*handle = (bus_mem_handle_t)
	    ((struct ggbus_softc *)bct->bc_data)->sc_zargs.va + 2 * addr +
a177 3
#if 0
	printf("mem_map %x %d -> %x\n", addr, sz, *handle);
#endif
d182 6
a187 3
ggbus_unmap(handle, sz)
	bus_io_handle_t handle;
	bus_io_size_t sz;
d189 1
a189 2
	return 0;
}
d191 3
a193 11
__inline u_int8_t
ggbus_read_1(handle, addr)
	bus_io_handle_t handle;
	bus_io_size_t addr;
{
	u_int8_t val = *(volatile u_int8_t *)(handle + 2 * addr + 1);

#if 0
	printf("read_1 @@%x handle %x -> %d\n", addr, handle, val);
#endif
	return val;
d196 5
a200 4
__inline u_int16_t
ggbus_read_2(handle, addr)
	bus_io_handle_t handle;
	bus_io_size_t addr;
d202 1
a202 96
	return *(volatile u_int16_t *)(handle + 2 * addr);
}

void
ggbus_io_read_multi_1(handle, addr, buf, cnt)
	bus_io_handle_t handle;
	bus_io_size_t addr;
	u_int8_t *buf;
	bus_io_size_t cnt;
{
	while (cnt--)
		*buf++ = ggbus_read_1(handle, addr);
}

void
ggbus_io_read_multi_2(handle, addr, buf, cnt)
	bus_io_handle_t handle;
	bus_io_size_t addr;
	u_int16_t *buf;
	bus_io_size_t cnt;
{
	while (cnt--)
		*buf++ = ggbus_read_2(handle, addr);
}

void
ggbus_io_read_raw_multi_2(handle, addr, buf, cnt)
	bus_io_handle_t handle;
	bus_io_size_t addr;
	u_int8_t *buf;
	bus_io_size_t cnt;
{
	u_int16_t *buf16 = (u_int16_t *)buf;

	while (cnt) {
		cnt -= 2;
		*buf16++ = swap(ggbus_read_2(handle, addr));
	}
}

__inline void
ggbus_write_1(handle, addr, val)
	bus_io_handle_t handle;
	bus_io_size_t addr;
	u_int8_t val;
{
#if 0
	printf("write_1 @@%x handle %x: %d\n", addr, handle, val);
#endif
	*(volatile u_int8_t *)(handle + 2 * addr + 1) = val;
}

__inline void
ggbus_write_2(handle, addr, val)
	bus_io_handle_t handle;
	bus_io_size_t addr;
	u_int16_t val;
{
	*(volatile u_int16_t *)(handle + 2 * addr) = val;
}

void
ggbus_io_write_multi_1(handle, addr, buf, cnt)
	bus_io_handle_t handle;
	bus_io_size_t addr;
	const u_int8_t *buf;
	bus_io_size_t cnt;
{
	while (cnt--)
		ggbus_write_1(handle, addr, *buf++);
}

void
ggbus_io_write_multi_2(handle, addr, buf, cnt)
	bus_io_handle_t handle;
	bus_io_size_t addr;
	const u_int16_t *buf;
	bus_io_size_t cnt;
{
	while (cnt--)
		ggbus_write_2(handle, addr, *buf++);
}

void
ggbus_io_write_raw_multi_2(handle, addr, buf, cnt)
	bus_io_handle_t handle;
	bus_io_size_t addr;
	const u_int8_t *buf;
	bus_io_size_t cnt;
{
	const u_int16_t *buf16 = (const u_int16_t *)buf;

	while (cnt) {
		cnt -= 2;
		ggbus_write_2(handle, addr, swap(*buf16++));
	}
a323 8
}

/* Swap bytes in a short word.  */
static u_int16_t
swap(u_int16_t x)
{
	__asm("rolw #8,%0" : "=r" (x) : "0" (x));
	return x;
@


1.6
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: ggbus.c,v 1.5 1996/08/04 01:30:49 niklas Exp $	*/
d61 1
a61 1
int	ggbusprint __P((void *, char *));
d234 1
a234 1
	char *pnp;
@


1.5
log
@Implement correct bus.h functions and our extensions
@
text
@d1 1
a1 1
/*	$OpenBSD: ggbus.c,v 1.4 1996/06/04 13:40:14 niklas Exp $	*/
d40 1
a40 1
#include <machine/bus.h>
@


1.4
log
@Cleanup for -Wall & -Wstrict-prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: ggbus.c,v 1.2 1996/02/27 15:40:56 niklas Exp $	*/
d90 5
d138 5
a142 3
	/* These are extensions to the general NetBSD bus interface.  */
	swap, 0 /* bc_to_host_4 */, 0 /* bc_to_host_8 */,
	swap, 0 /* bc_from_host_4 */, 0 /* bc_from_host_8 */,
d165 5
a169 3
	/* These are extensions to the general NetBSD bus interface.  */
	swap, 0 /* bc_to_host_4 */, 0 /* bc_to_host_8 */,
	swap, 0 /* bc_from_host_4 */, 0 /* bc_from_host_8 */,
d299 1
a299 1
	return swap(*(volatile u_int16_t *)(handle + 2 * addr));
d324 15
d357 1
a357 1
	*(volatile u_int16_t *)(handle + 2 * addr) = swap(val);
d380 15
@


1.3
log
@Bring forward the Amiga ISA support, and resolve a conflict with if_ed
@
text
@d38 1
d63 14
a76 14
int	ggbus_io_map(bus_chipset_tag_t, bus_io_addr_t, bus_io_size_t,
	    bus_io_handle_t *);
int	ggbus_mem_map(bus_chipset_tag_t, bus_mem_addr_t, bus_mem_size_t, int,
	    bus_mem_handle_t *);

void	ggbus_io_read_multi_1(bus_io_handle_t, bus_io_size_t, u_int8_t *,
	    bus_io_size_t);
void	ggbus_io_read_multi_2(bus_io_handle_t, bus_io_size_t, u_int16_t *,
	    bus_io_size_t);

void	ggbus_io_write_multi_1(bus_io_handle_t, bus_io_size_t,
	    const u_int8_t *, bus_io_size_t);
void	ggbus_io_write_multi_2(bus_io_handle_t, bus_io_size_t,
	    const u_int16_t *, bus_io_size_t);
d82 1
a82 1
int	ggbus_unmap(bus_io_handle_t, bus_io_size_t);
d84 2
a85 2
__inline u_int8_t ggbus_read_1(bus_io_handle_t, bus_io_size_t);
__inline u_int16_t ggbus_read_2(bus_io_handle_t, bus_io_size_t);
d87 2
a88 2
__inline void ggbus_write_1(bus_io_handle_t, bus_io_size_t, u_int8_t);
__inline void ggbus_write_2(bus_io_handle_t, bus_io_size_t, u_int16_t);
d95 7
a101 5
typedef int (*bus_mem_unmap_t)(bus_mem_handle_t, bus_mem_size_t);
typedef u_int8_t (*bus_mem_read_1_t)(bus_mem_handle_t, bus_mem_size_t);
typedef u_int16_t (*bus_mem_read_2_t)(bus_mem_handle_t, bus_mem_size_t);
typedef void (*bus_mem_write_1_t)(bus_mem_handle_t, bus_mem_size_t, u_int8_t);
typedef void (*bus_mem_write_2_t)(bus_mem_handle_t, bus_mem_size_t, u_int16_t);
d103 4
a106 2
void	ggbus_attach_hook(struct device *, struct device *,
	    struct isabus_attach_args *);
@


1.2
log
@Adapt to our isa_intr_establish interface
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$NetBSD: ggbus.c,v 1.1 1994/07/08 23:32:17 niklas Exp $	*/
d4 1
a4 1
 * Copyright (c) 1994, 1995 Niklas Hallqvist
d32 1
d39 1
d41 1
a41 1
#include <machine/pio.h>
a49 1
#include <amiga/isa/isa_intr.h>
d53 2
a57 3
/* This is OK because we only allow one ISA bus.  */
struct ggbus_device *ggbusp;

d60 71
a130 13
int	ggbusprint __P((void *auxp, char *));
void	ggbusstb __P((struct device *, int, u_char));
u_char	ggbusldb __P((struct device *, int));
void	ggbusstw __P((struct device *, int, u_short));
u_short ggbusldw __P((struct device *, int));
void	*ggbus_establish_intr __P((int intr, int type, int level,
				   int (*ih_fun) (void *), void *ih_arg,
				   char *ih_what));
void	ggbus_disestablish_intr __P((void *handler));

struct isa_intr_fcns ggbus_intr_fcns = {
	0 /* ggbus_intr_setup */,	ggbus_establish_intr,
	ggbus_disestablish_intr,	0 /* ggbus_iointr */
d133 31
a163 3
struct cfdriver ggbuscd = {
	NULL, "ggbus", ggbusmatch, ggbusattach, 
	DV_DULL, sizeof(struct ggbus_device), 0
d182 3
a184 3
ggbusattach(pdp, dp, auxp)
	struct device *pdp, *dp;
	void *auxp;
d186 3
a188 2
	struct zbus_args *zap = auxp;
	struct ggbus_device *gdp = (struct ggbus_device *)dp;
d190 12
a201 28
	ggbusp = gdp;
	bcopy(zap, &gdp->gd_zargs, sizeof(struct zbus_args));
	gdp->gd_link.il_dev = dp;
	if (gdp->gd_zargs.serno >= 2)
	  {
	    gdp->gd_link.il_ldb = ggbusldb;
	    gdp->gd_link.il_stb = ggbusstb;
	    gdp->gd_link.il_ldw = ggbusldw;
	    gdp->gd_link.il_stw = ggbusstw;
	  }
	else
	  {
	    gdp->gd_link.il_ldb = 0;
	    gdp->gd_link.il_stb = 0;
	    gdp->gd_link.il_ldw = 0;
	    gdp->gd_link.il_stw = 0;
	  }
	gdp->gd_imask = 0;

	isa_intr_fcns = &ggbus_intr_fcns;
	isa_pio_fcns = &ggbus_pio_fcns;

	if (gdp->gd_zargs.serno >= 2)
	  {
	    /* XXX turn on wait states unconditionally for now. */
	    GG2_ENABLE_WAIT(zap->va);
	    GG2_ENABLE_INTS(zap->va);
	  }
d203 2
a204 1
	printf(": pa 0x%08x va 0x%08x size 0x%x\n", zap->pa, zap->va, zap->size);
d206 9
a214 4
	/*
	 * attempt to configure the board.
	 */
	config_found(dp, &gdp->gd_link, ggbusprint);
d227 14
d242 7
a248 5
void
ggbusstb(dev, ia, b)
	struct device *dev;
	int ia;
	u_char b;
d250 8
a257 1
	struct ggbus_device *gd = (struct ggbus_device *)dev;
d259 6
a264 1
	*(volatile u_char *)(gd->gd_zargs.va + GG2_MEMORY_OFFSET + 2 * ia + 1) = b;
d267 4
a270 4
u_char
ggbusldb(dev, ia)
	struct device *dev;
	int ia;
d272 1
a272 3
	struct ggbus_device *gd = (struct ggbus_device *)dev;
	u_char retval =
	    *(volatile u_char *)(gd->gd_zargs.va + GG2_MEMORY_OFFSET + 2 * ia + 1);
d274 2
a275 3
#ifdef DEBUG
	if (ggdebug)
		printf("ldb 0x%x => 0x%x\n", ia, retval);
d277 20
a296 1
	return retval;
d300 5
a304 4
ggbusstw(dev, ia, w)
	struct device *dev;
	int ia;
	u_short w;
d306 15
a320 1
	struct ggbus_device *gd = (struct ggbus_device *)dev;
d322 7
a328 1
	*(volatile u_short *)(gd->gd_zargs.va + GG2_MEMORY_OFFSET + 2 * ia) = swap(w);
d331 6
a336 4
u_short
ggbusldw(dev, ia)
	struct device *dev;
	int ia;
d338 3
a340 3
	struct ggbus_device *gd = (struct ggbus_device *)dev;
	u_short retval =
	    swap(*(volatile u_short *)(gd->gd_zargs.va + GG2_MEMORY_OFFSET + 2 * ia));
d342 9
a350 5
#ifdef DEBUG
	if (ggdebug)
		printf("ldw 0x%x => 0x%x\n", ia, retval);
#endif
	return retval;
d358 6
a363 6
struct ggintr_desc {
	struct	isr gid_isr;
	int	gid_mask;
	int	(*gid_fun)(void *);
	void	*gid_arg;
};
d365 7
a371 1
static struct ggintr_desc *ggid[16];	/* XXX */
d373 4
a376 3
int
ggbusintr(gid)
	struct ggintr_desc *gid;
a377 2
	return (GG2_GET_STATUS (ggbusp->gd_zargs.va) & gid->gid_mask) ?
	    (*gid->gid_fun)(gid->gid_arg) : 0;
d381 3
a383 2
ggbus_establish_intr(intr, type, level, ih_fun, ih_arg, ih_what)
	int intr;
d390 51
a440 15
	if (ggid[intr]) {
		log(LOG_WARNING, "ISA interrupt %d already handled\n", intr);
		return 0;
	}
	MALLOC(ggid[intr], struct ggintr_desc *, sizeof(struct ggintr_desc),
	    M_DEVBUF, M_WAITOK);
	ggid[intr]->gid_isr.isr_intr = ggbusintr;
	ggid[intr]->gid_isr.isr_arg = ggid[intr];
	ggid[intr]->gid_isr.isr_ipl = 6;
	ggid[intr]->gid_isr.isr_mapped_ipl = level;
	ggid[intr]->gid_mask = 1 << ggbus_int_map[intr + 1];
	ggid[intr]->gid_fun = ih_fun;
	ggid[intr]->gid_arg = ih_arg;
	add_isr(&ggid[intr]->gid_isr);
	return &ggid[intr];
d444 3
a446 2
ggbus_disestablish_intr(handler)
	void  *handler;
d448 4
a451 1
	struct ggintr_desc **gid = handler;
d453 27
a479 3
	remove_isr(&(*gid)->gid_isr);
	FREE(*gid, M_DEVBUF);
	*gid = 0;
@


1.1
log
@Initial checkin of the Amiga ISA-kit
@
text
@d1 1
d67 2
a68 1
				   int (*ih_fun) (void *), void *));
d229 1
a229 1
ggbus_establish_intr(intr, type, level, ih_fun, ih_arg)
d235 1
@

