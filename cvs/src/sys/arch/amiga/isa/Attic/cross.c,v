head	1.23;
access;
symbols
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	UBC_SYNC_A:1.23
	OPENBSD_3_2:1.22.0.4
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.22
	UBC:1.20.0.2
	UBC_BASE:1.20
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.14.0.4
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.8
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.6
	SMP_BASE:1.13
	kame_19991208:1.13
	OPENBSD_2_6:1.13.0.4
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.12.0.4
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.23
date	2002.12.31.16.35.38;	author miod;	state dead;
branches;
next	1.22;

1.22
date	2002.03.14.03.15.52;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.26.29;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.28.16.24.26;	author art;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.11.28.13.47.38;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.27.03.54.13;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.25.00.43.08;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.28.03.28.42;	author art;	state Exp;
branches;
next	1.13;

1.13
date	99.01.19.10.04.54;	author niklas;	state Exp;
branches
	1.13.6.1;
next	1.12;

1.12
date	98.03.01.12.53.44;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.09.09.22.55.55;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.09.09.22.41.43;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.01.05.02.04.33;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.11.28.23.33.06;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.11.23.21.45.26;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.11.12.20.29.47;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.08.04.01.30.48;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.06.04.13.40.13;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.04.27.18.38.55;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.15.40.54;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.02.26.21.55.49;	author niklas;	state Exp;
branches;
next	;

1.13.6.1
date	2001.04.18.16.02.21;	author niklas;	state Exp;
branches;
next	1.13.6.2;

1.13.6.2
date	2001.07.04.10.15.18;	author niklas;	state Exp;
branches;
next	1.13.6.3;

1.13.6.3
date	2001.10.31.02.52.45;	author nate;	state Exp;
branches;
next	1.13.6.4;

1.13.6.4
date	2001.11.13.21.00.50;	author niklas;	state Exp;
branches;
next	1.13.6.5;

1.13.6.5
date	2001.12.05.00.39.09;	author niklas;	state Exp;
branches;
next	1.13.6.6;

1.13.6.6
date	2002.03.28.10.06.15;	author niklas;	state Exp;
branches;
next	1.13.6.7;

1.13.6.7
date	2003.03.27.23.19.18;	author niklas;	state dead;
branches;
next	;

1.20.2.1
date	2002.06.11.03.34.58;	author art;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2003.05.19.21.49.39;	author tedu;	state dead;
branches;
next	;


desc
@@


1.23
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: cross.c,v 1.22 2002/03/14 03:15:52 millert Exp $	*/

/*
 * Copyright (c) 1994, 1996 Niklas Hallqvist, Carsten Hammer
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niklas Hallqvist.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/syslog.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/intr.h>

#include <dev/isa/isavar.h>

#include <amiga/amiga/custom.h>
#include <amiga/amiga/device.h>
#include <amiga/amiga/isr.h>
#include <amiga/dev/zbusvar.h>
#include <amiga/isa/isa_machdep.h>
#include <amiga/isa/crossreg.h>
#include <amiga/isa/crossvar.h>

#if 1
void	crossattach(struct device *, struct device *, void *);
int	crossmatch(struct device *, void *, void *);

struct cfattach cross_ca = {
	sizeof(struct cross_softc), crossmatch, crossattach
};

struct cfdriver cross_cd = {
	NULL, "cross", DV_DULL, 0
};

void
crossattach(a, b, c)
	struct device *a;
	struct device *b;
	void *c;
{
	panic("crossattach && UVM");
}

int
crossmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct zbus_args *zap = aux;

	/*
	 * Check manufacturer and product id.
	 */
	if (zap->manid == 2011 && zap->prodid == 3)
		printf("cross not supported with uvm yet.");
	return(0);
}

#else

int crossdebug = 0;

void	crossattach(struct device *, struct device *, void *);
int	crossmatch(struct device *, void *, void *);
int	crossprint(void *, const char *);

int	cross_io_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
int	cross_mem_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
int	cross_io_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);
int	cross_mem_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);

int	crossintr(void *);

void	cross_attach_hook(struct device *, struct device *,
	    struct isabus_attach_args *);
void	*cross_intr_establish(void *, int, int, int, int (*)(void *),
	    void *, char *);
void	cross_intr_disestablish(void *, void *);
int	cross_intr_check(void *, int, int);

int	cross_pager_get_pages(vm_pager_t, struct vm_page **, int, boolean_t);

struct cfattach cross_ca = {
	sizeof(struct cross_softc), crossmatch, crossattach
};

struct cfdriver cross_cd = {
	NULL, "cross", DV_DULL, 0
};

struct pagerops crosspagerops = {
	NULL,
	NULL,
	NULL,
	cross_pager_get_pages,
	NULL,
	NULL,
	vm_pager_clusternull,
	NULL,
	NULL,
	NULL
};

struct pager_struct cross_pager;

int
crossmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct zbus_args *zap = aux;

	/*
	 * Check manufacturer and product id.
	 */
	if (zap->manid == 2011 && zap->prodid == 3)
		return(1);
	return(0);
}

void
crossattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct cross_softc *sc = (struct cross_softc *)self;
	struct zbus_args *zap = aux;
	struct isabus_attach_args iba;
	int i;

	bcopy(zap, &sc->sc_zargs, sizeof(struct zbus_args));
	sc->sc_status = CROSS_STATUS_ADDR(zap->va);
	sc->sc_imask = 1 << CROSS_MASTER;

	sc->sc_iot.bs_data = sc;
	sc->sc_iot.bs_map = cross_io_map;
	sc->sc_iot.bs_unmap = cross_io_unmap;
	sc->sc_iot.bs_swapped = 1;
	sc->sc_iot.bs_shift = 1;

	sc->sc_memt.bs_data = sc;
	sc->sc_memt.bs_map = cross_mem_map;
	sc->sc_memt.bs_unmap = cross_mem_unmap;
	sc->sc_memt.bs_shift = 1;

	sc->sc_ic.ic_data = sc;
	sc->sc_ic.ic_attach_hook = cross_attach_hook;
	sc->sc_ic.ic_intr_establish = cross_intr_establish;
	sc->sc_ic.ic_intr_disestablish = cross_intr_disestablish;
	sc->sc_ic.ic_intr_check = cross_intr_check;

	sc->sc_pager.pg_ops = &crosspagerops;
	sc->sc_pager.pg_type = PG_DFLT;
	sc->sc_pager.pg_flags = 0;
	sc->sc_pager.pg_data = sc;

	/* Allocate a bunch of pages used for the bank-switching logic.  */
	for (i = 0; i < CROSS_BANK_SIZE / NBPG; i++) {
		VM_PAGE_INIT(&sc->sc_page[i], NULL, 0);
		sc->sc_page[i].phys_addr = (vm_offset_t)zap->pa +
		    CROSS_XL_MEM + i * NBPG;
		sc->sc_page[i].flags |= PG_FICTITIOUS;
		vm_page_free(&sc->sc_page[i]);
	}

	/* Enable interrupts lazily in cross_intr_establish.  */
	CROSS_ENABLE_INTS(zap->va, 0);

	/* Default 16 bit tranfer  */
	*CROSS_HANDLE_TO_XLP_LATCH((bus_space_handle_t)zap->va) = CROSS_SBHE; 
	printf(": pa 0x%08x va 0x%08x size 0x%x\n", zap->pa, zap->va,
	    zap->size);

	iba.iba_busname = "isa";
	iba.iba_iot = &sc->sc_iot;
	iba.iba_memt = &sc->sc_memt;
	iba.iba_ic = &sc->sc_ic;
	config_found(self, &iba, crossprint);
}

int
crossprint(auxp, pnp)
	void *auxp;
	const char *pnp;
{
	if (pnp == NULL)
		return (QUIET);
	return (UNCONF);
}


int
cross_io_map(bst, addr, sz, cacheable, handle)
	bus_space_tag_t bst;
	bus_addr_t addr;
	bus_size_t sz;
	int cacheable;
	bus_space_handle_t *handle;
{
	*handle = (bus_space_handle_t)
	    ((struct cross_softc *)bst->bs_data)->sc_zargs.va + 2 * addr;
	return (0);
}

int
cross_mem_map(bst, addr, sz, cacheable, handle)
	bus_space_tag_t bst;
	bus_addr_t addr;
	bus_size_t sz;
	int cacheable;
	bus_space_handle_t *handle;
{
	struct cross_softc *sc = (struct cross_softc *)bst->bs_data;
	bus_addr_t banked_start;
	bus_size_t banked_size;
	vm_object_t object;
	vm_offset_t kva;
	int error;

	/*
	 * XXX Do extent checking here.
	 */

	/*
	 * Compute the bank range.  Note that we need to shift bus-addresses
	 * and sizes left one bit.
	 */
	banked_start = (addr << 1) & ~(CROSS_BANK_SIZE - 1);
        banked_size = ((sz << 1) + CROSS_BANK_SIZE - 1) &
	    ~(CROSS_BANK_SIZE - 1);

	/* Create the object that will take care of the bankswitching.  */
	object = vm_object_allocate(banked_size);
	if (object == NULL)
		goto fail_obj;
	vm_object_enter(object, &sc->sc_pager);
	vm_object_setpager(object, &sc->sc_pager, banked_start, FALSE);

	/*
	 * When done like this double mappings will be possible, thus
	 * wasting a little mapping space.  This happens when several
	 * bus_space_map maps stuff from the same bank.  But I don't care.
	 */
	kva = kmem_alloc_pageable(kernel_map, banked_size);
	if (kva == 0)
		goto fail_alloc;
	vm_map_lock(kernel_map);
	error = vm_map_insert(kernel_map, object, 0, kva, kva + banked_size);
	vm_map_unlock(kernel_map);
	if (error)
		goto fail_insert;

	/* Tell caller where to find his data.  */
	*handle = (bus_space_handle_t)(kva + (addr << 1) - banked_start);
	return (0);

fail_insert:
	kmem_free(kernel_map, kva, banked_size);
fail_alloc:
	vm_object_deallocate(object);
fail_obj:
	return (1);
}

int
cross_io_unmap(bst, handle, sz)
	bus_space_tag_t bst;
	bus_space_handle_t handle;
	bus_size_t sz;
{
	return (0);
}

int
cross_mem_unmap(bst, handle, sz)
	bus_space_tag_t bst;
	bus_space_handle_t handle;
	bus_size_t sz;
{
#if 0
	struct cross_softc *sc = (struct cross_softc *)bst->bs_data;
#endif

	/* Remove the object handling this mapping.  */
	return (0);
}

static int cross_int_map[] = {
    0, 0, 0, 0, CROSS_IRQ3, CROSS_IRQ4, CROSS_IRQ5, CROSS_IRQ6, CROSS_IRQ7, 0,
    CROSS_IRQ9, CROSS_IRQ10, CROSS_IRQ11, CROSS_IRQ12, 0, CROSS_IRQ14,
    CROSS_IRQ15
};

int
crossintr(v)
	void *v;
{
	struct intrhand *ih = (struct intrhand *)v;
	int handled;

	if (!(*ih->ih_status & ih->ih_mask))
		return (0);
	for (handled = 0; ih; ih = ih->ih_next)
		if ((*ih->ih_fun)(ih->ih_arg))
			handled = 1;
	return (handled);
}

void
cross_attach_hook(parent, self, iba)
	struct device *parent, *self;
	struct isabus_attach_args *iba;
{
}

void *
cross_intr_establish(ic, irq, type, level, ih_fun, ih_arg, ih_what)
	void *ic;
	int irq;
	int type;
	int level;
	int (*ih_fun)(void *);
	void *ih_arg;
	char *ih_what;
{
	struct intrhand **p, *c, *ih;
	struct cross_softc *sc = (struct cross_softc *)ic;

	/* no point in sleeping unless someone can free memory. */
	ih = malloc(sizeof *ih, M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL) {
		printf("cross_intr_establish: can't malloc handler info");
		return (NULL);
	}

	if (irq > ICU_LEN || type == IST_NONE) {
		printf("cross_intr_establish: bogus irq or type");
		return (NULL);
	}

	switch (sc->sc_intrsharetype[irq]) {
	case IST_NONE:
		sc->sc_intrsharetype[irq] = type;
		break;
	case IST_EDGE:
	case IST_LEVEL:
		if (type == sc->sc_intrsharetype[irq])
			break;
	case IST_PULSE:
		if (type != IST_NONE)
			printf("cross_intr_establish: can't share %s with %s",
			    isa_intr_typename(sc->sc_intrsharetype[irq]),
			    isa_intr_typename(type));
		break;
        }

	/*
	 * Figure out where to put the handler.
	 * This is O(N^2), but we want to preserve the order, and N is
	 * generally small.
	 */
	for (p = &sc->sc_ih[irq]; (c = *p) != NULL; p = &c->ih_next)
		;

	/*
	 * Poke the real handler in now.
	 */
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_count = 0;
	ih->ih_next = NULL;
	ih->ih_irq = irq;
	ih->ih_what = ih_what;
	ih->ih_mask = 1 << cross_int_map[irq + 1];
	ih->ih_status = sc->sc_status;

	ih->ih_isr.isr_intr = crossintr;
	ih->ih_isr.isr_arg = ih;
	ih->ih_isr.isr_ipl = 6;
	ih->ih_isr.isr_mapped_ipl = level;

	*p = ih;
	add_isr(&ih->ih_isr);

	sc->sc_imask |= 1 << cross_int_map[irq + 1];
	CROSS_ENABLE_INTS(sc->sc_zargs.va, sc->sc_imask);

	return (ih);
}

void
cross_intr_disestablish(ic, arg)
	void *ic;
	void *arg;
{
	struct intrhand *ih = arg;
	struct cross_softc *sc = (struct cross_softc *)ic;
	int irq = ih->ih_irq;
	struct intrhand **p, *q;

	if (irq > ICU_LEN)
		panic("cross_intr_establish: bogus irq");

	sc->sc_imask &= ~ih->ih_mask;
	CROSS_ENABLE_INTS (sc->sc_zargs.va, sc->sc_imask);
	remove_isr(&ih->ih_isr);

	/*
	 * Remove the handler from the chain.
	 * This is O(n^2), too.
	 */
	for (p = &sc->sc_ih[irq]; (q = *p) != NULL && q != ih; p = &q->ih_next)
		;
	if (q)
		*p = q->ih_next;
	else
		panic("cross_intr_disestablish: handler not registered");
	free(ih, M_DEVBUF);

	if (sc->sc_intrsharetype[irq] == NULL)
		sc->sc_intrsharetype[irq] = IST_NONE;
}

int
cross_pager_get_pages(pager, mlist, npages, sync)
	vm_pager_t	pager;
	struct vm_page	**mlist;
	int		npages;
	boolean_t	sync;
{
	struct cross_softc *sc = (struct cross_softc *)pager->pg_data;
	int i;
	vm_object_t object, old_object;
	vm_offset_t offset;

	while(npages--) {
		i = ((*mlist)->offset & (CROSS_BANK_SIZE - 1)) / NBPG;
		object = (*mlist)->object;
		old_object = sc->sc_page[i].object;
		offset = (*mlist)->offset;
		vm_page_lock_queues();
		vm_object_lock(object);
		if (old_object)
			vm_object_lock(old_object);
		vm_page_free(*mlist);

		/* generate A13-A19 for correct page */
		*CROSS_HANDLE_TO_XLP_LATCH(
		    (bus_space_handle_t)sc->sc_zargs.va) =
		    object->paging_offset >> 13 | CROSS_SBHE;

		vm_page_rename(&sc->sc_page[i], object, offset);
		if (old_object)
			vm_object_unlock(old_object);
		vm_object_unlock(object);
		vm_page_unlock_queues();
		mlist++;
	}
	return (VM_PAGER_OK);
}

int
cross_intr_check(ic, irq, type)
	void *ic;
	int irq;
	int type;
{
	struct cross_softc *sc = (struct cross_softc *)ic;

	return (__isa_intr_check(irq, type, sc->sc_intrsharetype));
}
#endif /* UVM */
@


1.22
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.21 2002/03/14 01:26:29 millert Exp $	*/
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.20 2001/11/28 16:24:26 art Exp $	*/
d111 2
a112 2
void	*cross_intr_establish __P((void *, int, int, int, int (*)(void *),
	    void *, char *));
@


1.20
log
@more typedef zapping vm_page_t -> struct vm_page *
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.19 2001/11/28 13:47:38 art Exp $	*/
d57 2
a58 2
void	crossattach __P((struct device *, struct device *, void *));
int	crossmatch __P((struct device *, void *, void *));
d96 10
a105 10
void	crossattach __P((struct device *, struct device *, void *));
int	crossmatch __P((struct device *, void *, void *));
int	crossprint __P((void *, const char *));

int	cross_io_map __P((bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *));
int	cross_mem_map __P((bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *));
int	cross_io_unmap __P((bus_space_tag_t, bus_space_handle_t, bus_size_t));
int	cross_mem_unmap __P((bus_space_tag_t, bus_space_handle_t, bus_size_t));
d107 1
a107 1
int	crossintr __P((void *));
d109 2
a110 2
void	cross_attach_hook __P((struct device *, struct device *,
	    struct isabus_attach_args *));
d113 2
a114 2
void	cross_intr_disestablish __P((void *, void *));
int	cross_intr_check __P((void *, int, int));
d116 1
a116 1
int	cross_pager_get_pages __P((vm_pager_t, struct vm_page **, int, boolean_t));
@


1.20.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.20 2001/11/28 16:24:26 art Exp $	*/
d57 2
a58 2
void	crossattach(struct device *, struct device *, void *);
int	crossmatch(struct device *, void *, void *);
d96 19
a114 19
void	crossattach(struct device *, struct device *, void *);
int	crossmatch(struct device *, void *, void *);
int	crossprint(void *, const char *);

int	cross_io_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
int	cross_mem_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
int	cross_io_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);
int	cross_mem_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);

int	crossintr(void *);

void	cross_attach_hook(struct device *, struct device *,
	    struct isabus_attach_args *);
void	*cross_intr_establish(void *, int, int, int, int (*)(void *),
	    void *, char *);
void	cross_intr_disestablish(void *, void *);
int	cross_intr_check(void *, int, int);
d116 1
a116 1
int	cross_pager_get_pages(vm_pager_t, struct vm_page **, int, boolean_t);
@


1.20.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.20.2.1 2002/06/11 03:34:58 art Exp $	*/
@


1.19
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.18 2001/11/06 19:53:14 miod Exp $	*/
d116 1
a116 1
int	cross_pager_get_pages __P((vm_pager_t, vm_page_t *, int, boolean_t));
d462 1
a462 1
	vm_page_t	*mlist;
@


1.18
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.17 2001/09/19 20:50:56 mickey Exp $	*/
d285 1
a285 1
	if (error != KERN_SUCCESS)
@


1.17
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.16 2001/06/27 03:54:13 art Exp $	*/
a39 1
#include <vm/vm.h>
@


1.16
log
@No more old VM on amiga.
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.15 2001/06/25 00:43:08 mickey Exp $	*/
d41 1
a41 1
#include <vm/vm_kern.h>
@


1.15
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.14 2000/05/28 03:28:42 art Exp $	*/
d57 1
a57 1
#if defined(UVM)
@


1.14
log
@Disable cross for UVM until I figure out what the #$%&! is happening in here.
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.13 1999/01/19 10:04:54 niklas Exp $	*/
a93 2

extern int cold;
@


1.13
log
@Add isa_intr_check functionality
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.12 1998/03/01 12:53:44 niklas Exp $	*/
d57 38
d510 1
@


1.13.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.14 2000/05/28 03:28:42 art Exp $	*/
a56 38
#if defined(UVM)
void	crossattach __P((struct device *, struct device *, void *));
int	crossmatch __P((struct device *, void *, void *));

struct cfattach cross_ca = {
	sizeof(struct cross_softc), crossmatch, crossattach
};

struct cfdriver cross_cd = {
	NULL, "cross", DV_DULL, 0
};

void
crossattach(a, b, c)
	struct device *a;
	struct device *b;
	void *c;
{
	panic("crossattach && UVM");
}

int
crossmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct zbus_args *zap = aux;

	/*
	 * Check manufacturer and product id.
	 */
	if (zap->manid == 2011 && zap->prodid == 3)
		printf("cross not supported with uvm yet.");
	return(0);
}

#else

a471 1
#endif /* UVM */
@


1.13.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.13.6.1 2001/04/18 16:02:21 niklas Exp $	*/
d57 1
a57 1
#if 1
d94 2
@


1.13.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.13.6.2 2001/07/04 10:15:18 niklas Exp $	*/
d41 1
a41 1
#include <uvm/uvm_extern.h>
@


1.13.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
@


1.13.6.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.13.6.4 2001/11/13 21:00:50 niklas Exp $	*/
d116 1
a116 1
int	cross_pager_get_pages __P((vm_pager_t, struct vm_page **, int, boolean_t));
d285 1
a285 1
	if (error)
d462 1
a462 1
	struct vm_page	**mlist;
@


1.13.6.6
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 2
a58 2
void	crossattach(struct device *, struct device *, void *);
int	crossmatch(struct device *, void *, void *);
d96 19
a114 19
void	crossattach(struct device *, struct device *, void *);
int	crossmatch(struct device *, void *, void *);
int	crossprint(void *, const char *);

int	cross_io_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
int	cross_mem_map(bus_space_tag_t, bus_addr_t, bus_size_t, int,
	    bus_space_handle_t *);
int	cross_io_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);
int	cross_mem_unmap(bus_space_tag_t, bus_space_handle_t, bus_size_t);

int	crossintr(void *);

void	cross_attach_hook(struct device *, struct device *,
	    struct isabus_attach_args *);
void	*cross_intr_establish(void *, int, int, int, int (*)(void *),
	    void *, char *);
void	cross_intr_disestablish(void *, void *);
int	cross_intr_check(void *, int, int);
d116 1
a116 1
int	cross_pager_get_pages(vm_pager_t, struct vm_page **, int, boolean_t);
@


1.13.6.7
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.13.6.6 2002/03/28 10:06:15 niklas Exp $	*/
@


1.12
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.11 1997/09/09 22:55:55 niklas Exp $	*/
d79 1
d150 1
d331 4
a334 2
	if (ih == NULL)
		panic("cross_intr_establish: can't malloc handler info");
d336 4
a339 2
	if (irq > ICU_LEN || type == IST_NONE)
		panic("cross_intr_establish: bogus irq or type");
d342 3
d351 1
a351 1
			panic("cross_intr_establish: can't share %s with %s",
d448 2
a449 1
		*CROSS_HANDLE_TO_XLP_LATCH((bus_space_handle_t)sc->sc_zargs.va) =
d460 11
@


1.11
log
@KNF return nits
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.10 1997/09/09 22:41:43 niklas Exp $	*/
d286 1
a286 1
static cross_int_map[] = {
@


1.10
log
@Make the bus_addr_t shift amount in addr calculations dynamic
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.9 1997/01/05 02:04:33 niklas Exp $	*/
d185 2
a186 2
		return(QUIET);
	return(UNCONF);
d200 1
a200 1
	return 0;
d253 1
a253 1
	return 0;
d260 1
a260 1
	return -1;
d269 1
a269 1
	return 0;
d283 1
a283 1
	return 0;
d300 1
a300 1
		return 0;
d304 1
a304 1
	return handled;
d379 1
a379 1
	return ih;
d449 1
a449 1
	return VM_PAGER_OK;
@


1.9
log
@First stab at making a VM-controlled bankswitching driver
for the CrossLink driver
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.8 1996/11/28 23:33:06 niklas Exp $	*/
d138 1
d143 1
a143 1
	sc->sc_memt.bs_swapped = 1;
@


1.8
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.7 1996/11/23 21:45:26 kstailey Exp $	*/
d41 1
a41 2
#include <vm/vm.h>
#include <vm/vm.h>
d69 2
a70 2
int	cross_io_unmap __P((bus_space_handle_t, bus_size_t));
int	cross_mem_unmap __P((bus_space_handle_t, bus_size_t));
d103 1
a103 1
struct vm_pager crosspager;
d131 3
d138 1
a142 10
	sc->sc_status = CROSS_STATUS_ADDR(zap->va);
	sc->sc_imask = 1 << CROSS_MASTER;

	/* Enable interrupts lazily in cross_intr_establish.  */
	CROSS_ENABLE_INTS(zap->va, 0);

	/* Default 16 bit tranfer  */
	*CROSS_HANDLE_TO_XLP_LATCH((bus_space_handle_t)zap->va) = CROSS_SBHE; 
	printf(": pa 0x%08x va 0x%08x size 0x%x\n", zap->pa, zap->va,
	    zap->size);
d149 5
d157 2
a158 1
		sc->sc_page[i].phys_addr = zap->pa + CROSS_XL_MEM + i * NBPG;
d162 9
a170 1
		
d210 1
d218 1
a218 2
	 * XXX When we do have a good enough extent-manager do extent
	 * checking here.
d230 1
a230 1
	object = vm_allocate_object(banked_size);
d233 2
a234 1
	vm_object_setpager(object, cross_pager, 0, 0);
d251 1
a251 1
	*handle = (bus_space_handle_t)(kva + (addr << 1)  - banked_addr));
d277 5
a281 1
	/* Remove traphandler */
d366 1
d371 1
d421 1
d429 1
a429 1
		old_object = sc->sc_page[i].offset;
d438 2
a439 1
		*CROSS_HANDLE_TO_XLP_LATCH(handle) = addr >> 13 | CROSS_SBHE;
d441 1
a441 1
		vm_page_rename(sc->sc_page[i], object, offset);
d446 1
a446 1
		mlist++:
@


1.7
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.6 1996/11/12 20:29:47 niklas Exp $	*/
d40 5
a44 1
#include <machine/bus.old.h>
d55 1
a56 1
#include <amiga/isa/crossreg.h>
d66 6
a71 44
int	cross_io_map __P((bus_chipset_tag_t, bus_io_addr_t, bus_io_size_t,
	    bus_io_handle_t *));
int	cross_mem_map __P((bus_chipset_tag_t, bus_mem_addr_t, bus_mem_size_t,
	    int, bus_mem_handle_t *));

void	cross_io_read_multi_1 __P((bus_io_handle_t, bus_io_size_t, u_int8_t *,
	    bus_io_size_t));
void	cross_io_read_multi_2 __P((bus_io_handle_t, bus_io_size_t, u_int16_t *,
	    bus_io_size_t));

void	cross_io_write_multi_1 __P((bus_io_handle_t, bus_io_size_t,
	    const u_int8_t *, bus_io_size_t));
void	cross_io_write_multi_2 __P((bus_io_handle_t, bus_io_size_t,
	    const u_int16_t *, bus_io_size_t));

void	cross_io_read_raw_multi_2 __P((bus_io_handle_t, bus_io_size_t,
	    u_int8_t *, bus_io_size_t));
void	cross_io_write_raw_multi_2 __P((bus_io_handle_t, bus_io_size_t,
	    const u_int8_t *, bus_io_size_t));

/*
 * Note that the following unified access functions are prototyped for the
 * I/O access case.  We use casts to get type correctness.
 */
int	cross_unmap __P((bus_io_handle_t, bus_io_size_t));

__inline u_int8_t cross_read_1 __P((bus_io_handle_t, bus_io_size_t));
__inline u_int16_t cross_read_2 __P((bus_io_handle_t, bus_io_size_t));

__inline void cross_write_1 __P((bus_io_handle_t, bus_io_size_t, u_int8_t));
__inline void cross_write_2 __P((bus_io_handle_t, bus_io_size_t, u_int16_t));

/*
 * In order to share the access function implementations for I/O and memory
 * access we cast the functions for the memory access case.  These typedefs
 * make that casting look nicer.
 */
typedef int (*bus_mem_unmap_t) __P((bus_mem_handle_t, bus_mem_size_t));
typedef u_int8_t (*bus_mem_read_1_t) __P((bus_mem_handle_t, bus_mem_size_t));
typedef u_int16_t (*bus_mem_read_2_t) __P((bus_mem_handle_t, bus_mem_size_t));
typedef void (*bus_mem_write_1_t) __P((bus_mem_handle_t, bus_mem_size_t,
	    u_int8_t));
typedef void (*bus_mem_write_2_t) __P((bus_mem_handle_t, bus_mem_size_t,
	    u_int16_t));
d81 1
a81 28
static u_int16_t swap __P((u_int16_t));

struct amiga_bus_chipset cross_chipset = {
	0 /* bc_data */,

	cross_io_map, cross_unmap,
	cross_read_1, cross_read_2,
	0 /* bc_io_read_4 */, 0 /* bc_io_read_8 */,
	cross_io_read_multi_1, cross_io_read_multi_2,
	0 /* bc_io_multi_4 */, 0 /* bc_io_multi_8 */,
	cross_write_1, cross_write_2,
	0 /* bc_io_write_4 */, 0 /* bc_io_write_8 */,
	cross_io_write_multi_1, cross_io_write_multi_2,
	0 /* bc_io_write_multi_4 */, 0 /* bc_io_write_multi_8 */,

	cross_mem_map, (bus_mem_unmap_t)cross_unmap,
	(bus_mem_read_1_t)cross_read_1, (bus_mem_read_2_t)cross_read_2,
	0 /* bc_mem_read_4 */, 0 /* bc_mem_read_8 */,
	(bus_mem_write_1_t)cross_write_1, (bus_mem_write_2_t)cross_write_2,
	0 /* bc_mem_write_4 */, 0 /* bc_mem_write_8 */,

	/* These are extensions to the general NetBSD bus interface.  */
	cross_io_read_raw_multi_2,
	0 /* bc_io_read_raw_multi_4 */, 0 /* bc_io_read_raw_multi_8 */,

	cross_io_write_raw_multi_2,
	0 /* bc_io_write_raw_multi_4 */, 0 /* bc_io_write_raw_multi_8 */,
};
d91 15
d129 1
d132 8
a139 2
	bcopy(&cross_chipset, &sc->sc_bc, sizeof(struct amiga_bus_chipset));
	sc->sc_bc.bc_data = sc;
d145 1
d147 1
a147 1
	*CROSS_HANDLE_TO_XLP_LATCH((bus_io_handle_t)zap->va) = CROSS_SBHE; 
d156 8
d165 2
a166 1
	iba.iba_bc = &sc->sc_bc;
d183 4
a186 19
cross_io_map(bct, addr, sz, handle)
	bus_chipset_tag_t bct;
	bus_io_addr_t addr;
	bus_io_size_t sz;
	bus_io_handle_t *handle;
{
	*handle = (bus_io_handle_t)
	    ((struct cross_softc *)bct->bc_data)->sc_zargs.va + 2 * addr;
#if 0
	printf("io_map %x %d -> %x\n", addr, sz, *handle);
#endif
	return 0;
}

int
cross_mem_map(bct, addr, sz, cacheable, handle)
	bus_chipset_tag_t bct;
	bus_mem_addr_t addr;
	bus_mem_size_t sz;
d188 1
a188 1
	bus_mem_handle_t *handle;
d190 2
a191 6
	*handle = (bus_mem_handle_t)
	    ((struct cross_softc *)bct->bc_data)->sc_zargs.va + 2 * addr +
	    CROSS_MEMORY_OFFSET;
#if 0
	printf("mem_map %x %d -> %x\n", addr, sz, *handle);
#endif
d196 6
a201 3
cross_unmap(handle, sz)
	bus_io_handle_t handle;
	bus_io_size_t sz;
d203 5
a207 2
	return 0;
}
d209 4
a212 26
__inline u_int8_t
cross_read_1(handle, addr)
	bus_io_handle_t handle;
	bus_io_size_t addr;
{
	u_int8_t val;

	/* generate A13-A19 for correct page */
	*CROSS_HANDLE_TO_XLP_LATCH(handle) = addr >> 13 | CROSS_SBHE;
	val = *(volatile u_int8_t *)(handle + 2 * addr);

#if 0
	printf("read_1 @@%x handle %x -> %d\n", addr, handle, val);
#endif
	return val;
}

__inline u_int16_t
cross_read_2(handle, addr)
	bus_io_handle_t handle;
	bus_io_size_t addr;
{
	/* generate A13-A19 for correct page */
	*CROSS_HANDLE_TO_XLP_LATCH(handle) = addr >> 13 | CROSS_SBHE;
	return *(volatile u_int16_t *)(handle + 2 * addr);
}
d214 13
a226 10
void
cross_io_read_multi_1(handle, addr, buf, cnt)
	bus_io_handle_t handle;
	bus_io_size_t addr;
	u_int8_t *buf;
	bus_io_size_t cnt;
{
	while (cnt--)
		*buf++ = cross_read_1(handle, addr);
}
d228 13
a240 10
void
cross_io_read_multi_2(handle, addr, buf, cnt)
	bus_io_handle_t handle;
	bus_io_size_t addr;
	u_int16_t *buf;
	bus_io_size_t cnt;
{
	while (cnt--)
		*buf++ = cross_read_2(handle, addr);
}
d242 3
a244 14
void
cross_io_read_raw_multi_2(handle, addr, buf, cnt)
	bus_io_handle_t handle;
	bus_io_size_t addr;
	u_int8_t *buf;
	bus_io_size_t cnt;
{
	u_int16_t *buf16 = (u_int16_t *)buf;

	while (cnt) {
		cnt -= 2;
		*buf16++ = swap(cross_read_2(handle, addr));
	}
}
d246 6
a251 23
__inline void
cross_write_1(handle, addr, val)
	bus_io_handle_t handle;
	bus_io_size_t addr;
	u_int8_t val;
{
	/* generate A13-A19 for correct page */
	*CROSS_HANDLE_TO_XLP_LATCH(handle) = addr >> 13 | CROSS_SBHE;
#if 0
	printf("write_1 @@%x handle %x: %d\n", addr, handle, val);
#endif
	*(volatile u_int8_t *)(handle + 2 * addr + 1) = val;
}

__inline void
cross_write_2(handle, addr, val)
	bus_io_handle_t handle;
	bus_io_size_t addr;
	u_int16_t val;
{
	/* generate A13-A19 for correct page */
	*CROSS_HANDLE_TO_XLP_LATCH(handle) = addr >> 13 | CROSS_SBHE;
	*(volatile u_int16_t *)(handle + 2 * addr) = val;
d254 5
a258 6
void
cross_io_write_multi_1(handle, addr, buf, cnt)
	bus_io_handle_t handle;
	bus_io_size_t addr;
	const u_int8_t *buf;
	bus_io_size_t cnt;
d260 1
a260 2
	while (cnt--)
		cross_write_1(handle, addr, *buf++);
d263 5
a267 6
void
cross_io_write_multi_2(handle, addr, buf, cnt)
	bus_io_handle_t handle;
	bus_io_size_t addr;
	const u_int16_t *buf;
	bus_io_size_t cnt;
d269 2
a270 17
	while (cnt--)
		cross_write_2(handle, addr, *buf++);
}

void
cross_io_write_raw_multi_2(handle, addr, buf, cnt)
	bus_io_handle_t handle;
	bus_io_size_t addr;
	const u_int8_t *buf;
	bus_io_size_t cnt;
{
	const u_int16_t *buf16 = (const u_int16_t *)buf;

	while (cnt) {
		cnt -= 2;
		cross_write_2(handle, addr, swap(*buf16++));
	}
d400 33
a432 6
/* Swap bytes in a short word.  */
static u_short
swap(u_short x)
{
	__asm("rolw #8,%0" : "=r" (x) : "0" (x));
	return x;
@


1.6
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.5 1996/08/04 01:30:48 niklas Exp $	*/
d60 1
a60 1
int	crossprint __P((void *, char *));
d203 1
a203 1
	char *pnp;
@


1.5
log
@Implement correct bus.h functions and our extensions
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.4 1996/06/04 13:40:13 niklas Exp $	*/
d40 1
a40 1
#include <machine/bus.h>
@


1.4
log
@Cleanup for -Wall & -Wstrict-prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: cross.c,v 1.2 1996/02/27 15:40:54 niklas Exp $	*/
d77 5
d137 5
a141 2
	swap, 0 /* bc_to_host_4 */, 0 /* bc_to_host_8 */,
	swap, 0 /* bc_from_host_4 */, 0 /* bc_from_host_8 */,
d300 15
d360 15
@


1.3
log
@Bring forward the Amiga ISA support, and resolve a conflict with if_ed
@
text
@d38 1
d62 14
a75 14
int	cross_io_map(bus_chipset_tag_t, bus_io_addr_t, bus_io_size_t,
	    bus_io_handle_t *);
int	cross_mem_map(bus_chipset_tag_t, bus_mem_addr_t, bus_mem_size_t, int,
	    bus_mem_handle_t *);

void	cross_io_read_multi_1(bus_io_handle_t, bus_io_size_t, u_int8_t *,
	    bus_io_size_t);
void	cross_io_read_multi_2(bus_io_handle_t, bus_io_size_t, u_int16_t *,
	    bus_io_size_t);

void	cross_io_write_multi_1(bus_io_handle_t, bus_io_size_t,
	    const u_int8_t *, bus_io_size_t);
void	cross_io_write_multi_2(bus_io_handle_t, bus_io_size_t,
	    const u_int16_t *, bus_io_size_t);
d81 1
a81 1
int	cross_unmap(bus_io_handle_t, bus_io_size_t);
d83 2
a84 2
__inline u_int8_t cross_read_1(bus_io_handle_t, bus_io_size_t);
__inline u_int16_t cross_read_2(bus_io_handle_t, bus_io_size_t);
d86 2
a87 2
__inline void cross_write_1(bus_io_handle_t, bus_io_size_t, u_int8_t);
__inline void cross_write_2(bus_io_handle_t, bus_io_size_t, u_int16_t);
d94 7
a100 5
typedef int (*bus_mem_unmap_t)(bus_mem_handle_t, bus_mem_size_t);
typedef u_int8_t (*bus_mem_read_1_t)(bus_mem_handle_t, bus_mem_size_t);
typedef u_int16_t (*bus_mem_read_2_t)(bus_mem_handle_t, bus_mem_size_t);
typedef void (*bus_mem_write_1_t)(bus_mem_handle_t, bus_mem_size_t, u_int8_t);
typedef void (*bus_mem_write_2_t)(bus_mem_handle_t, bus_mem_size_t, u_int16_t);
d102 4
a105 2
void	cross_attach_hook(struct device *, struct device *,
	    struct isabus_attach_args *);
@


1.2
log
@Adapt to our isa_intr_establish interface
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$NetBSD: cross.c,v 1.0 1994/07/08 23:32:17 niklas Exp $	*/
d4 1
a4 1
 * Copyright (c) 1994 Niklas Hallqvist, Carsten Hammer
d17 1
a17 1
 *      This product includes software developed by Christian E. Hopps.
d32 1
d39 1
d41 1
a41 1
#include <machine/pio.h>
a49 1
#include <amiga/isa/isa_intr.h>
d53 2
d57 73
a129 2
/* This static is OK because we only allow one ISA bus.  */
struct cross_device *crossp;
d131 2
a132 15
void crossattach __P((struct device *, struct device *, void *));
int crossmatch __P((struct device *, void *, void *));
int crossprint __P((void *auxp, char *));
void crossstb __P((struct device *, int, u_char));
u_char crossldb __P((struct device *, int));
void crossstw __P((struct device *, int, u_short));
u_short crossldw __P((struct device *, int));
void    *cross_establish_intr __P((int intr, int type, int level,
                                   int (*ih_fun) (void *), void *ih_arg,
				   char *ih_what));
void    cross_disestablish_intr __P((void *handler));

struct isa_intr_fcns cross_intr_fcns = {
        0 /* cross_intr_setup */,       cross_establish_intr,
        cross_disestablish_intr,        0 /* cross_iointr */
d135 2
a136 3
struct cfdriver crosscd = {
	NULL, "cross", crossmatch, crossattach, 
	DV_DULL, sizeof(struct cross_device), 0
d155 3
a157 3
crossattach(pdp, dp, auxp)
	struct device *pdp, *dp;
	void *auxp;
d159 3
a161 11
	struct zbus_args *zap = auxp;
	struct cross_device *cdp = (struct cross_device *)dp;

	crossp = cdp;
	bcopy(zap, &cdp->cd_zargs, sizeof(struct zbus_args));
	cdp->cd_link.il_dev = dp;
	cdp->cd_link.il_ldb = crossldb;
	cdp->cd_link.il_stb = crossstb;
	cdp->cd_link.il_ldw = crossldw;
	cdp->cd_link.il_stw = crossstw;
	cdp->cd_imask = 1 << CROSS_MASTER;
d163 5
a167 2
	isa_intr_fcns = &cross_intr_fcns;
        isa_pio_fcns = &cross_pio_fcns;
d169 1
a169 1
	/* Enable interrupts lazily in crossaddint.  */
d172 1
a172 2
	*(volatile u_short *)(cdp->cd_zargs.va + CROSS_XLP_LATCH) = CROSS_SBHE; 

d174 1
a174 2
            zap->size);

d176 9
a184 4
	/*
	 * attempt to configure the board.
	 */
	config_found(dp, &cdp->cd_link, crossprint);
d198 44
a241 5
void
crossstb(dev, ia, b)
	struct device *dev;
	int ia;
	u_char b;
d243 2
d246 2
a247 2
	u_short upper_addressbits = ia >> 13;
	struct cross_device *cd = (struct cross_device *)dev;
d249 4
a252 4
	*(volatile u_short *)(cd->cd_zargs.va + CROSS_XLP_LATCH) =
	    upper_addressbits | CROSS_SBHE;
	*(volatile u_char *)(cd->cd_zargs.va + CROSS_MEMORY_OFFSET + 2 * ia) =
	    b;
d255 4
a258 4
u_char
crossldb(dev, ia)
	struct device *dev;
	int ia;
d261 3
a263 2
	u_short upper_addressbits = ia >> 13;
	struct cross_device *cd = (struct cross_device *)dev;
d265 9
a273 4
	*(volatile u_short *)(cd->cd_zargs.va + CROSS_XLP_LATCH) =
	    upper_addressbits | CROSS_SBHE;
	return *(volatile u_char *)(cd->cd_zargs.va + CROSS_MEMORY_OFFSET +
            2 * ia);
d277 15
a291 4
crossstw(dev, ia, w)
	struct device *dev;
	int ia;
	u_short w;
d294 3
a296 8
	u_short upper_addressbits = ia >> 13;
	struct cross_device *cd = (struct cross_device *)dev;
 	
	*(volatile u_short *)(cd->cd_zargs.va + CROSS_XLP_LATCH) =
	    upper_addressbits | CROSS_SBHE;
#ifdef DEBUG
	if (crossdebug)
		printf("outw 0x%x,0x%x\n", ia, w);
d298 1
a298 2
	*(volatile u_short *)(cd->cd_zargs.va + CROSS_MEMORY_OFFSET + 2 * ia) =
	    w;
d301 5
a305 4
u_short
crossldw(dev, ia)
	struct device *dev;
	int ia;
d308 24
a331 13
	u_short upper_addressbits = ia >> 13;
	struct cross_device *cd = (struct cross_device *)dev;
	u_short retval;

	*(volatile u_short *)(cd->cd_zargs.va + CROSS_XLP_LATCH) =
	    upper_addressbits | CROSS_SBHE;
	retval = *(volatile u_short *)(cd->cd_zargs.va + CROSS_MEMORY_OFFSET +
	    2 * ia);
#ifdef DEBUG
	if (crossdebug)
		printf("ldw 0x%x => 0x%x\n", ia, retval);
#endif
	return retval;
d340 3
a342 9
#if 0
/* XXX We don't care about the priority yet, although we ought to.  */
void
crossaddint(dev, irq, func, arg, pri)
	struct device *dev;
	int irq;
	int (*func)();
	void *arg;
	int pri;
d344 9
a352 20
	struct cross_device *cd = (struct cross_device *)dev;
	int s = splhigh();
	int bit = cross_int_map[irq + 1];

	if (!bit) {
		log(LOG_WARNING, "Registration of unknown ISA interrupt %d\n",
		    irq);
		goto out;
	}
	if (cd->cd_imask & 1 << bit) {
		log(LOG_WARNING, "ISA interrupt %d already handled\n", irq);
		goto out;
	}
	cd->cd_imask |= (1 << bit);
        CROSS_ENABLE_INTS (cd->cd_zargs.va, cd->cd_imask);
	cd->cd_ifunc[bit] = func;
	cd->cd_ipri[bit] = pri;
	cd->cd_iarg[bit] = arg;
out:
	splx(s);
d356 3
a358 3
crossremint(dev, irq)
	struct device *dev;
	int irq;
a359 24
	struct cross_device *cd = (struct cross_device *)dev;
	int s = splhigh();
	int bit = cross_int_map[irq + 1];

	cd->cd_imask &= ~(1 << bit);
        CROSS_ENABLE_INTS (cd->cd_zargs.va, cd->cd_imask);
	splx(s);
}
#endif
struct crossintr_desc {
	struct	isr cid_isr;
	int	cid_mask;
        int     (*cid_fun)(void *);
        void    *cid_arg;
};

static struct crossintr_desc *crid[16];	/* XXX */

int
crossintr(cid)
	struct crossintr_desc *cid;
{
	return (CROSS_GET_STATUS (crossp->cd_zargs.va) & cid->cid_mask) ?
	    (*cid->cid_fun)(cid->cid_arg) : 0;
d363 7
a369 6
cross_establish_intr(intr, type, level, ih_fun, ih_arg, ih_what)
        int intr;
        int type;
        int level;
        int (*ih_fun)(void *);
        void *ih_arg;
d372 54
a425 17
	if (crid[intr]) {
		log(LOG_WARNING, "ISA interrupt %d already handled\n", intr);
		return 0;
	}
	MALLOC(crid[intr], struct crossintr_desc *,
	    sizeof(struct crossintr_desc), M_DEVBUF, M_WAITOK);
	crid[intr]->cid_isr.isr_intr = crossintr;
	crid[intr]->cid_isr.isr_arg = crid[intr];
	crid[intr]->cid_isr.isr_ipl = 6;
	crid[intr]->cid_isr.isr_mapped_ipl = level;
	crid[intr]->cid_mask = 1 << cross_int_map[intr + 1];
	crid[intr]->cid_fun = ih_fun;
	crid[intr]->cid_arg = ih_arg;
	add_isr (&crid[intr]->cid_isr);
	crossp->cd_imask |= 1 << cross_int_map[intr + 1];
        CROSS_ENABLE_INTS (crossp->cd_zargs.va, crossp->cd_imask);
	return &crid[intr];
d429 3
a431 2
cross_disestablish_intr(handler)
        void  *handler;
d433 11
a443 1
        struct crossintr_desc **cid = handler;
d445 22
a466 5
	remove_isr(&(*cid)->cid_isr);
	crossp->cd_imask &= ~(*cid)->cid_mask;
	FREE(*cid, M_DEVBUF);
	*cid = 0;
        CROSS_ENABLE_INTS (crossp->cd_zargs.va, crossp->cd_imask);
@


1.1
log
@Initial checkin of the Amiga ISA-kit
@
text
@d1 1
d66 2
a67 1
                                   int (*ih_fun) (void *), void *));
d283 1
a283 1
cross_establish_intr(intr, type, level, ih_fun, ih_arg)
d289 1
@

