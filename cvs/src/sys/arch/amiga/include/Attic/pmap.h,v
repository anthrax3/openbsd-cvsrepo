head	1.15;
access;
symbols
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.12
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2002.12.31.16.35.38;	author miod;	state dead;
branches;
next	1.14;

1.14
date	2002.03.25.19.41.03;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.29;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.23.00.31.11;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.20.19.02.26;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.30.23.20.09;	author miod;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.11.28.16.13.28;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.28.15.34.16;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.18.20.50.18;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.28.03.55.21;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.27.20.14.18;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.27.19.42.49;	author art;	state Exp;
branches;
next	1.3;

1.3
date	97.09.18.13.40.03;	author niklas;	state Exp;
branches
	1.3.12.1;
next	1.2;

1.2
date	97.01.16.09.26.01;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.04;	author deraadt;	state Exp;
branches;
next	;

1.3.12.1
date	2001.04.18.16.02.18;	author niklas;	state Exp;
branches;
next	1.3.12.2;

1.3.12.2
date	2001.10.31.02.52.45;	author nate;	state Exp;
branches;
next	1.3.12.3;

1.3.12.3
date	2001.12.05.00.39.09;	author niklas;	state Exp;
branches;
next	1.3.12.4;

1.3.12.4
date	2002.03.28.10.06.15;	author niklas;	state Exp;
branches;
next	1.3.12.5;

1.3.12.5
date	2003.03.27.23.19.18;	author niklas;	state dead;
branches;
next	;

1.10.2.1
date	2002.01.31.22.55.07;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2002.06.11.03.34.58;	author art;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2003.05.19.21.49.39;	author tedu;	state dead;
branches;
next	;


desc
@@


1.15
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: pmap.h,v 1.14 2002/03/25 19:41:03 niklas Exp $	*/
/*	$NetBSD: pmap.h,v 1.17 1997/06/10 18:34:52 veego Exp $	*/

/* 
 * Copyright (c) 1987 Carnegie-Mellon University
 * Copyright (c) 1991 Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pmap.h	7.6 (Berkeley) 5/10/91
 */
#ifndef	_MACHINE_PMAP_H_
#define	_MACHINE_PMAP_H_

/*
 * Pmap stuff
 */
struct pmap {
	pt_entry_t		*pm_ptab;	/* KVA of page table */
	st_entry_t		*pm_stab;	/* KVA of segment table */
	int			pm_stfree;	/* 040: free lev2 blocks */
	u_int			*pm_stpa;	/* 040: ST phys addr */
	short			pm_sref;	/* segment table ref count */
	short			pm_count;	/* pmap reference count */
	long			pm_ptpages;	/* more stats: PT pages */
	struct simplelock	pm_lock;	/* lock on pmap */
	struct pmap_statistics	pm_stats;	/* pmap statistics */
};

typedef struct pmap	*pmap_t;

/*
 * On the 040 we keep track of which level 2 blocks are already in use
 * with the pm_stfree mask.  Bits are arranged from LSB (block 0) to MSB
 * (block 31).  For convenience, the level 1 table is considered to be
 * block 0.
 *
 * MAX[KU]L2SIZE control how many pages of level 2 descriptors are allowed.
 * for the kernel and users.  16 implies only the initial "segment table"
 * page is used.  WARNING: don't change MAXUL2SIZE unless you can allocate
 * physically contiguous pages for the ST in pmap.c!
 */
#define	MAXKL2SIZE	32
#define MAXUL2SIZE	16
#define l2tobm(n)	(1 << (n))
#define	bmtol2(n)	(ffs(n) - 1)

/*
 * Macros for speed
 */
#define PMAP_ACTIVATE(pmap, loadhw) \
{ \
       if ((loadhw)) \
               loadustp(m68k_btop((pmap)->pm_stpa)); \
}

/*
 * For each vm_page_t, there is a list of all currently valid virtual
 * mappings of that page.  An entry is a pv_entry_t, the list is pv_table.
 */
typedef struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vm_offset_t	pv_va;		/* virtual address for mapping */
	u_int		*pv_ptste;	/* non-zero if VA maps a PT page */
	struct pmap	*pv_ptpmap;	/* if pv_ptste, pmap for PT page */
	int		pv_flags;	/* flags */
} *pv_entry_t;

#define	PV_CI		0x01	/* all entries must be cache inhibited */
#define PV_PTPAGE	0x02	/* entry maps a page table page */

struct pv_page;

struct pv_page_info {
	TAILQ_ENTRY(pv_page) pgi_list;
	struct pv_entry *pgi_freelist;
	int pgi_nfree;
};

/*
 * This is basically:
 * ((NBPG - sizeof(struct pv_page_info)) / sizeof(struct pv_entry))
 */
#define	NPVPPG	340

struct pv_page {
	struct pv_page_info pvp_pgi;
	struct pv_entry pvp_pv[NPVPPG];
};

#ifdef	_KERNEL
pv_entry_t	pv_table;	/* array of entries, one per page */
u_int		*Sysmap;
char		*vmmap;		/* map for mem, dumps, etc. */
struct pmap	kernel_pmap_store;

#define	pmap_kernel()		(&kernel_pmap_store)
#define	active_pmap(pm) \
	((pm) == pmap_kernel() || (pm) == curproc->p_vmspace->vm_map.pmap)
#define active_user_pmap(pm) \
	(curproc && \
	 (pm) != pmap_kernel() && (pm) == curproc->p_vmspace->vm_map.pmap)

#define	pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->pm_stats.wired_count)
#define pmap_update(pmap)			/* nothing */

#endif	/* _KERNEL */

#endif	/* !_MACHINE_PMAP_H_ */
@


1.14
log
@revert the pmap stuff to 0221, so we can boot
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.13 2002/03/14 01:26:29 millert Exp $	*/
@


1.13
log
@First round of __P removal in sys
@
text
@d1 2
a2 1
/*	$OpenBSD: pmap.h,v 1.12 2002/02/23 00:31:11 miod Exp $	*/
d4 39
d46 76
a121 1
#include <m68k/pmap_motorola.h>
d124 17
a140 3
void pmap_init_md(void);
#define	PMAP_INIT_MD()	pmap_init_md()
#endif
d142 1
a142 1
#endif	/* _MACHINE_PMAP_H_ */
@


1.12
log
@Bring back pmap_motorola in service for amiga, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.11 2001/12/20 19:02:26 miod Exp $	*/
d9 1
a9 1
void pmap_init_md __P((void));
@


1.11
log
@Temporarily revert the pmap_motorola changes, as they may account for
some problems as well.
Requested by deraadt@@
@
text
@d1 1
a1 2
/*	$OpenBSD: pmap.h,v 1.10 2001/11/30 23:20:09 miod Exp $	*/
/*	$NetBSD: pmap.h,v 1.17 1997/06/10 18:34:52 veego Exp $	*/
a2 39
/* 
 * Copyright (c) 1987 Carnegie-Mellon University
 * Copyright (c) 1991 Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pmap.h	7.6 (Berkeley) 5/10/91
 */
d6 1
a6 76
/*
 * Pmap stuff
 */
struct pmap {
	pt_entry_t		*pm_ptab;	/* KVA of page table */
	st_entry_t		*pm_stab;	/* KVA of segment table */
	int			pm_stfree;	/* 040: free lev2 blocks */
	u_int			*pm_stpa;	/* 040: ST phys addr */
	short			pm_sref;	/* segment table ref count */
	short			pm_count;	/* pmap reference count */
	long			pm_ptpages;	/* more stats: PT pages */
	struct simplelock	pm_lock;	/* lock on pmap */
	struct pmap_statistics	pm_stats;	/* pmap statistics */
};

typedef struct pmap	*pmap_t;

/*
 * On the 040 we keep track of which level 2 blocks are already in use
 * with the pm_stfree mask.  Bits are arranged from LSB (block 0) to MSB
 * (block 31).  For convenience, the level 1 table is considered to be
 * block 0.
 *
 * MAX[KU]L2SIZE control how many pages of level 2 descriptors are allowed.
 * for the kernel and users.  16 implies only the initial "segment table"
 * page is used.  WARNING: don't change MAXUL2SIZE unless you can allocate
 * physically contiguous pages for the ST in pmap.c!
 */
#define	MAXKL2SIZE	32
#define MAXUL2SIZE	16
#define l2tobm(n)	(1 << (n))
#define	bmtol2(n)	(ffs(n) - 1)

/*
 * Macros for speed
 */
#define PMAP_ACTIVATE(pmap, loadhw) \
{ \
       if ((loadhw)) \
               loadustp(m68k_btop((pmap)->pm_stpa)); \
}

/*
 * For each vm_page_t, there is a list of all currently valid virtual
 * mappings of that page.  An entry is a pv_entry_t, the list is pv_table.
 */
typedef struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vm_offset_t	pv_va;		/* virtual address for mapping */
	u_int		*pv_ptste;	/* non-zero if VA maps a PT page */
	struct pmap	*pv_ptpmap;	/* if pv_ptste, pmap for PT page */
	int		pv_flags;	/* flags */
} *pv_entry_t;

#define	PV_CI		0x01	/* all entries must be cache inhibited */
#define PV_PTPAGE	0x02	/* entry maps a page table page */

struct pv_page;

struct pv_page_info {
	TAILQ_ENTRY(pv_page) pgi_list;
	struct pv_entry *pgi_freelist;
	int pgi_nfree;
};

/*
 * This is basically:
 * ((NBPG - sizeof(struct pv_page_info)) / sizeof(struct pv_entry))
 */
#define	NPVPPG	340

struct pv_page {
	struct pv_page_info pvp_pgi;
	struct pv_entry pvp_pv[NPVPPG];
};
d9 3
a11 17
pv_entry_t	pv_table;	/* array of entries, one per page */
u_int		*Sysmap;
char		*vmmap;		/* map for mem, dumps, etc. */
struct pmap	kernel_pmap_store;

#define	pmap_kernel()		(&kernel_pmap_store)
#define	active_pmap(pm) \
	((pm) == pmap_kernel() || (pm) == curproc->p_vmspace->vm_map.pmap)
#define active_user_pmap(pm) \
	(curproc && \
	 (pm) != pmap_kernel() && (pm) == curproc->p_vmspace->vm_map.pmap)

#define	pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->pm_stats.wired_count)
#define pmap_update(pmap)			/* nothing */

#endif	/* _KERNEL */
d13 1
a13 1
#endif	/* !_MACHINE_PMAP_H_ */
@


1.10
log
@More changes that cvs forgot to commit in the pmap_motorola switch.
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d4 39
d46 76
a121 1
#include <m68k/pmap_motorola.h>
d124 17
a140 3
void pmap_init_md __P((void));
#define	PMAP_INIT_MD()	pmap_init_md()
#endif
d142 1
a142 1
#endif	/* _MACHINE_PMAP_H_ */
@


1.10.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 2
/*	$OpenBSD: pmap.h,v 1.11 2001/12/20 19:02:26 miod Exp $	*/
/*	$NetBSD: pmap.h,v 1.17 1997/06/10 18:34:52 veego Exp $	*/
a2 39
/* 
 * Copyright (c) 1987 Carnegie-Mellon University
 * Copyright (c) 1991 Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pmap.h	7.6 (Berkeley) 5/10/91
 */
d6 1
a6 76
/*
 * Pmap stuff
 */
struct pmap {
	pt_entry_t		*pm_ptab;	/* KVA of page table */
	st_entry_t		*pm_stab;	/* KVA of segment table */
	int			pm_stfree;	/* 040: free lev2 blocks */
	u_int			*pm_stpa;	/* 040: ST phys addr */
	short			pm_sref;	/* segment table ref count */
	short			pm_count;	/* pmap reference count */
	long			pm_ptpages;	/* more stats: PT pages */
	struct simplelock	pm_lock;	/* lock on pmap */
	struct pmap_statistics	pm_stats;	/* pmap statistics */
};

typedef struct pmap	*pmap_t;

/*
 * On the 040 we keep track of which level 2 blocks are already in use
 * with the pm_stfree mask.  Bits are arranged from LSB (block 0) to MSB
 * (block 31).  For convenience, the level 1 table is considered to be
 * block 0.
 *
 * MAX[KU]L2SIZE control how many pages of level 2 descriptors are allowed.
 * for the kernel and users.  16 implies only the initial "segment table"
 * page is used.  WARNING: don't change MAXUL2SIZE unless you can allocate
 * physically contiguous pages for the ST in pmap.c!
 */
#define	MAXKL2SIZE	32
#define MAXUL2SIZE	16
#define l2tobm(n)	(1 << (n))
#define	bmtol2(n)	(ffs(n) - 1)

/*
 * Macros for speed
 */
#define PMAP_ACTIVATE(pmap, loadhw) \
{ \
       if ((loadhw)) \
               loadustp(m68k_btop((pmap)->pm_stpa)); \
}

/*
 * For each vm_page_t, there is a list of all currently valid virtual
 * mappings of that page.  An entry is a pv_entry_t, the list is pv_table.
 */
typedef struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vm_offset_t	pv_va;		/* virtual address for mapping */
	u_int		*pv_ptste;	/* non-zero if VA maps a PT page */
	struct pmap	*pv_ptpmap;	/* if pv_ptste, pmap for PT page */
	int		pv_flags;	/* flags */
} *pv_entry_t;

#define	PV_CI		0x01	/* all entries must be cache inhibited */
#define PV_PTPAGE	0x02	/* entry maps a page table page */

struct pv_page;

struct pv_page_info {
	TAILQ_ENTRY(pv_page) pgi_list;
	struct pv_entry *pgi_freelist;
	int pgi_nfree;
};

/*
 * This is basically:
 * ((NBPG - sizeof(struct pv_page_info)) / sizeof(struct pv_entry))
 */
#define	NPVPPG	340

struct pv_page {
	struct pv_page_info pvp_pgi;
	struct pv_entry pvp_pv[NPVPPG];
};
d9 3
a11 17
pv_entry_t	pv_table;	/* array of entries, one per page */
u_int		*Sysmap;
char		*vmmap;		/* map for mem, dumps, etc. */
struct pmap	kernel_pmap_store;

#define	pmap_kernel()		(&kernel_pmap_store)
#define	active_pmap(pm) \
	((pm) == pmap_kernel() || (pm) == curproc->p_vmspace->vm_map.pmap)
#define active_user_pmap(pm) \
	(curproc && \
	 (pm) != pmap_kernel() && (pm) == curproc->p_vmspace->vm_map.pmap)

#define	pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->pm_stats.wired_count)
#define pmap_update(pmap)			/* nothing */

#endif	/* _KERNEL */
d13 1
a13 1
#endif	/* !_MACHINE_PMAP_H_ */
@


1.10.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.10.2.1 2002/01/31 22:55:07 niklas Exp $	*/
@


1.10.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.10.2.2 2002/06/11 03:34:58 art Exp $	*/
@


1.9
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 2
/*	$OpenBSD: pmap.h,v 1.8 2001/11/28 15:34:16 art Exp $	*/
/*	$NetBSD: pmap.h,v 1.17 1997/06/10 18:34:52 veego Exp $	*/
a2 39
/* 
 * Copyright (c) 1987 Carnegie-Mellon University
 * Copyright (c) 1991 Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pmap.h	7.6 (Berkeley) 5/10/91
 */
d6 1
a6 76
/*
 * Pmap stuff
 */
struct pmap {
	pt_entry_t		*pm_ptab;	/* KVA of page table */
	st_entry_t		*pm_stab;	/* KVA of segment table */
	int			pm_stfree;	/* 040: free lev2 blocks */
	u_int			*pm_stpa;	/* 040: ST phys addr */
	short			pm_sref;	/* segment table ref count */
	short			pm_count;	/* pmap reference count */
	long			pm_ptpages;	/* more stats: PT pages */
	struct simplelock	pm_lock;	/* lock on pmap */
	struct pmap_statistics	pm_stats;	/* pmap statistics */
};

typedef struct pmap	*pmap_t;

/*
 * On the 040 we keep track of which level 2 blocks are already in use
 * with the pm_stfree mask.  Bits are arranged from LSB (block 0) to MSB
 * (block 31).  For convenience, the level 1 table is considered to be
 * block 0.
 *
 * MAX[KU]L2SIZE control how many pages of level 2 descriptors are allowed.
 * for the kernel and users.  16 implies only the initial "segment table"
 * page is used.  WARNING: don't change MAXUL2SIZE unless you can allocate
 * physically contiguous pages for the ST in pmap.c!
 */
#define	MAXKL2SIZE	32
#define MAXUL2SIZE	16
#define l2tobm(n)	(1 << (n))
#define	bmtol2(n)	(ffs(n) - 1)

/*
 * Macros for speed
 */
#define PMAP_ACTIVATE(pmap, loadhw) \
{ \
       if ((loadhw)) \
               loadustp(m68k_btop((pmap)->pm_stpa)); \
}

/*
 * For each vm_page_t, there is a list of all currently valid virtual
 * mappings of that page.  An entry is a pv_entry_t, the list is pv_table.
 */
typedef struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vm_offset_t	pv_va;		/* virtual address for mapping */
	u_int		*pv_ptste;	/* non-zero if VA maps a PT page */
	struct pmap	*pv_ptpmap;	/* if pv_ptste, pmap for PT page */
	int		pv_flags;	/* flags */
} *pv_entry_t;

#define	PV_CI		0x01	/* all entries must be cache inhibited */
#define PV_PTPAGE	0x02	/* entry maps a page table page */

struct pv_page;

struct pv_page_info {
	TAILQ_ENTRY(pv_page) pgi_list;
	struct pv_entry *pgi_freelist;
	int pgi_nfree;
};

/*
 * This is basically:
 * ((NBPG - sizeof(struct pv_page_info)) / sizeof(struct pv_entry))
 */
#define	NPVPPG	340

struct pv_page {
	struct pv_page_info pvp_pgi;
	struct pv_entry pvp_pv[NPVPPG];
};
d9 3
a11 17
pv_entry_t	pv_table;	/* array of entries, one per page */
u_int		*Sysmap;
char		*vmmap;		/* map for mem, dumps, etc. */
struct pmap	kernel_pmap_store;

#define	pmap_kernel()		(&kernel_pmap_store)
#define	active_pmap(pm) \
	((pm) == pmap_kernel() || (pm) == curproc->p_vmspace->vm_map.pmap)
#define active_user_pmap(pm) \
	(curproc && \
	 (pm) != pmap_kernel() && (pm) == curproc->p_vmspace->vm_map.pmap)

#define	pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->pm_stats.wired_count)
#define pmap_update()			/* nothing */

#endif	/* _KERNEL */
d13 1
a13 1
#endif	/* !_MACHINE_PMAP_H_ */
@


1.8
log
@Make pmap_update functions into nops so that we can have a consistent
pmap_update API (right now it's nop).
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.7 2001/08/18 20:50:18 art Exp $	*/
d57 1
a57 1
	simple_lock_data_t	pm_lock;	/* lock on pmap */
@


1.7
log
@Move pmap_{de,}activate to vm/pmap.h, it's same on all archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.6 2000/05/28 03:55:21 art Exp $	*/
d138 1
@


1.6
log
@Bugfix pmap_activate.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.5 2000/05/27 20:14:18 art Exp $	*/
a138 3
struct proc;
void	pmap_activate __P((struct proc *));
void	pmap_deactivate __P((struct proc *));
@


1.5
log
@Make pmap_activate take struct proc * as arguemnt.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.4 2000/05/27 19:42:49 art Exp $	*/
a51 1
	int			pm_stchanged;	/* ST changed */
d82 1
a82 1
#define PMAP_ACTIVATE(pmap, pcb, loadhw) \
a83 1
       (pcb)->pcb_ustp = m68k_btop((vm_offset_t)(pmap)->pm_stpa); \
d85 1
a85 2
               loadustp((pcb)->pcb_ustp); \
       (pmap)->pm_stchanged = FALSE; \
@


1.4
log
@MACHINE_NEW_NONCONTIG code for amiga. Enabled by default.
Old contig and NONCONTIG code will no longer work.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.3 1997/09/18 13:40:03 niklas Exp $	*/
d83 7
a89 9
#define PMAP_ACTIVATE(pmapp, pcbp, iscurproc) \
	if ((pmapp) != NULL && (pmapp)->pm_stchanged) { \
		(pcbp)->pcb_ustp = \
		    m68k_btop((vm_offset_t)(pmapp)->pm_stpa); \
		if (iscurproc) \
			loadustp((pcbp)->pcb_ustp); \
		(pmapp)->pm_stchanged = FALSE; \
	}
#define PMAP_DEACTIVATE(pmapp, pcbp)
d135 4
d141 4
@


1.3
log
@Merge of NetBSD changes upto last week or so, with the exception of stand/
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.2 1997/01/16 09:26:01 niklas Exp $	*/
a133 6
#ifdef MACHINE_NONCONTIG
#define pa_index(pa)		pmap_page_index(pa)
#else
#define pa_index(pa)		atop(pa - vm_first_phys)
#endif
#define pa_to_pvh(pa)		(&pv_table[pa_index(pa)])
@


1.3.12.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.6 2000/05/28 03:55:21 art Exp $	*/
d52 1
d83 9
a91 5
#define PMAP_ACTIVATE(pmap, loadhw) \
{ \
       if ((loadhw)) \
               loadustp(m68k_btop((pmap)->pm_stpa)); \
}
d134 6
a142 4
#define active_user_pmap(pm) \
	(curproc && \
	 (pm) != pmap_kernel() && (pm) == curproc->p_vmspace->vm_map.pmap)

a144 4

struct proc;
void	pmap_activate __P((struct proc *));
void	pmap_deactivate __P((struct proc *));
@


1.3.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.3.12.1 2001/04/18 16:02:18 niklas Exp $	*/
d139 3
@


1.3.12.3
log
@Merge in -current
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d4 39
d46 76
a121 1
#include <m68k/pmap_motorola.h>
d124 16
a139 3
void pmap_init_md __P((void));
#define	PMAP_INIT_MD()	pmap_init_md()
#endif
d141 1
a141 1
#endif	/* _MACHINE_PMAP_H_ */
@


1.3.12.4
log
@Merge in -current from about a week ago
@
text
@d9 1
a9 1
void pmap_init_md(void);
@


1.3.12.5
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap.h,v 1.3.12.4 2002/03/28 10:06:15 niklas Exp $	*/
@


1.2
log
@Sync to NetBSD 970110
@
text
@d1 2
a2 2
/*	$OpenBSD: pmap.h,v 1.16 1995/09/29 13:52:08 chopps Exp $	*/
/*	$NetBSD: pmap.h,v 1.16 1995/09/29 13:52:08 chopps Exp $	*/
d86 1
a86 1
		    amiga_btop((vm_offset_t)(pmapp)->pm_stpa); \
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
