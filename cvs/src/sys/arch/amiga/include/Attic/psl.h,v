head	1.15;
access;
symbols
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.14
	UBC:1.12.0.4
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.11.0.4
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.6
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.4
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.8
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.6
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2002.12.31.16.35.38;	author miod;	state dead;
branches;
next	1.14;

1.14
date	2002.04.29.07.35.17;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.29;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.24.17.05.34;	author miod;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2000.07.06.15.29.52;	author ho;	state Exp;
branches;
next	1.10;

1.10
date	99.05.10.16.24.55;	author espie;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	97.09.18.13.40.04;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.01.16.09.26.04;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.05.31.10.46.29;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.05.07.10.22.45;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.05.02.07.33.43;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.05.02.06.44.46;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.04.27.18.38.53;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.26.20.17.47;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.04;	author deraadt;	state Exp;
branches;
next	;

1.10.4.1
date	2001.04.18.16.02.19;	author niklas;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2001.07.04.10.15.16;	author niklas;	state Exp;
branches;
next	1.10.4.3;

1.10.4.3
date	2002.03.28.10.06.15;	author niklas;	state Exp;
branches;
next	1.10.4.4;

1.10.4.4
date	2003.03.27.23.19.18;	author niklas;	state dead;
branches;
next	;

1.12.4.1
date	2002.06.11.03.34.58;	author art;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2003.05.19.21.49.39;	author tedu;	state dead;
branches;
next	;


desc
@@


1.15
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: psl.h,v 1.14 2002/04/29 07:35:17 miod Exp $	*/
/*	$NetBSD: psl.h,v 1.11 1996/11/30 00:33:49 is Exp $	*/

#ifndef _MACHINE_PSL_H_
#define _MACHINE_PSL_H_

#include <m68k/psl.h>

#if defined(_KERNEL) && !defined(_LOCORE)

/* SPL asserts */
#define	splassert(wantipl)	/* nothing */

static	__inline int splraise(int);
static	__inline int splexact(int);
static	__inline void splx(int);
static	__inline int spllower(int);

static __inline int
splraise(npsl)
	register int npsl;
{
        register int opsl;

        __asm __volatile ("clrl %0; movew sr,%0" : "=&d" (opsl) : : "cc");
	if (npsl > (opsl & (PSL_S|PSL_IPL)))
        	__asm __volatile ("movew %0,sr" : : "di" (npsl) : "cc");
        return opsl;
}

static __inline int
splexact(npsl)
	register int npsl;
{
        register int opsl;

        __asm __volatile ("clrl %0; movew sr,%0; movew %1,sr" : "=&d" (opsl) :
	    "di" (npsl) : "cc");
        return opsl;
}

#if !defined(IPL_REMAP_1) && !defined(IPL_REMAP_2)
static __inline void
splx(npsl)
	register int npsl;
{
        __asm __volatile ("movew %0,sr" : : "di" (npsl) : "cc");
}
#endif

#ifdef IPL_REMAP_1
extern int isr_exter_ipl;
extern void walk_ipls(int, int);

static __inline void
splx(npsl)
	register int npsl;
{
/*
 * XXX This is scary as hell.  Actually removing this increases performance
 * XXX while functionality remains.  However fairness of service is altered.
 * XXX Potential lower priority services gets serviced before higher ones.
 */
	if ((isr_exter_ipl << 8) > (npsl & PSL_IPL))
		walk_ipls(isr_exter_ipl, npsl);
        __asm __volatile("movew %0,sr" : : "di" (npsl) : "cc");
}
#endif

#ifdef IPL_REMAP_2
extern int walk_ipls(int);

static __inline void
splx(npsl)
	register int npsl;
{
	/* We should maybe have a flag telling if this is needed.  */
	walk_ipls(npsl);
        __asm __volatile("movew %0,sr" : : "di" (npsl) : "cc");
}
#endif

static __inline int
spllower(npsl)
	register int npsl;
{
        register int opsl;

        __asm __volatile ("clrl %0; movew sr,%0" : "=&d" (opsl) : : "cc");
        splx(npsl);
        return opsl;
}

/*
 * Shortcuts.  For enhanced security use splraise instead of splexact.
 */
#define spl1()		splexact(PSL_S|PSL_IPL1)
#define spl2()		splexact(PSL_S|PSL_IPL2)
#define spl3()		splexact(PSL_S|PSL_IPL3)
#define spl4()		splexact(PSL_S|PSL_IPL4)
#define spl5()		splexact(PSL_S|PSL_IPL5)
#define spl6()		splexact(PSL_S|PSL_IPL6)
#define spl7()  	splexact(PSL_S|PSL_IPL7)

/*
 * Hardware interrupt masks
 */
#define splbio()	spl3()
#define splnet()	spl3()

/*
 * spltty hack, idea by Jason Thorpe.
 * drivers which need it (at the present only drcom) raise the variable to
 * spl5 (the idea being that only ser.c really wants it below 5, and ser
 * and drcom will never be present at the same time).
 *
 * XXX ttyspl is statically initialized in drcom.c at the moment; should 
 * be some driver independent file.
 *
 * XXX should ttyspl be volatile? I think not; it is intended to be set only
 * during xxx_attach() time, and will be used only later.
 *	-is
 */

extern u_int16_t amiga_ttyspl;
#define spltty()	splexact(amiga_ttyspl)
#define splimp()	spltty()        /* XXX for the full story, see i386 */
#define splvm()		spltty()        /* XXX for the full story, see i386 */

#if defined(LEV6_DEFER) || defined(IPL_REMAP_1) || defined(IPL_REMAP_2)
#define splclock()	spl4()
#else
#define splclock()	spl6()
#endif
#define splstatclock()	splclock()

/*
 * Software interrupt masks
 *
 * NOTE: spllowersoftclock() is used by hardclock() to lower the priority from
 * clock to softclock before it calls softclock().
 */
#define spllowersoftclock()	spllower(PSL_S|PSL_IPL1)
#define splsoftclock()		spl1()
#define splsoftnet()		spl1()
#define splsofttty()		spl1()

/*
 * Miscellaneous
 */

/*
 * When remapping high interrupts down we also pull down splhigh, so that
 * the fast internal serial interrupt can get called allover.  This is safe
 * as this interrupt never goes outside of its own structures.
 */
#if defined(LEV6_DEFER) || defined(IPL_REMAP_1) || defined(IPL_REMAP_2)
#define splhigh()	spl4()
#else
#define splhigh()	spl7()
#endif
#define spl0()		spllower(PSL_S|PSL_IPL0)

#endif	/* KERNEL && !_LOCORE */
#endif	/* _MACHINE_PSL_H_ */
@


1.14
log
@Define placeholders for art's splassert() debugging stuff on all arches.
Currently as no-ops everywhere.

ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.13 2002/03/14 01:26:29 millert Exp $	*/
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.12 2001/06/24 17:05:34 miod Exp $	*/
d10 4
@


1.12
log
@Define splvm() for arches who don't already provide it, with the same
definition as splimp().
art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.11 2000/07/06 15:29:52 ho Exp $	*/
d10 4
a13 4
static	__inline int splraise __P((int));
static	__inline int splexact __P((int));
static	__inline void splx __P((int));
static	__inline int spllower __P((int));
d49 1
a49 1
extern void walk_ipls __P((int, int));
d67 1
a67 1
extern int walk_ipls __P((int));
@


1.12.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.12 2001/06/24 17:05:34 miod Exp $	*/
d10 4
a13 8

/* SPL asserts */
#define	splassert(wantipl)	/* nothing */

static	__inline int splraise(int);
static	__inline int splexact(int);
static	__inline void splx(int);
static	__inline int spllower(int);
d49 1
a49 1
extern void walk_ipls(int, int);
d67 1
a67 1
extern int walk_ipls(int);
@


1.12.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.12.4.1 2002/06/11 03:34:58 art Exp $	*/
@


1.11
log
@Change splsoftclock() to raise the spl, instead of lowering it.
Add spllowersoftclock() for the former behaviour. Update comment. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.10 1999/05/10 16:24:55 espie Exp $	*/
d124 1
@


1.10
log
@egcs -Wall warns unless & is used as a modifier in extended asms, e.g.,
constraints should begin "=&", not "&=".
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.9 1997/09/18 13:40:04 niklas Exp $	*/
d135 1
a135 1
 * NOTE: splsoftclock() is used by hardclock() to lower the priority from
d138 4
a141 3
#define splsoftclock()	spllower(PSL_S|PSL_IPL1)
#define splsoftnet()	spl1()
#define splsofttty()	spl1()
@


1.10.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.11 2000/07/06 15:29:52 ho Exp $	*/
d135 1
a135 1
 * NOTE: spllowersoftclock() is used by hardclock() to lower the priority from
d138 3
a140 4
#define spllowersoftclock()	spllower(PSL_S|PSL_IPL1)
#define splsoftclock()		spl1()
#define splsoftnet()		spl1()
#define splsofttty()		spl1()
@


1.10.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.10.4.1 2001/04/18 16:02:19 niklas Exp $	*/
a123 1
#define splvm()		spltty()        /* XXX for the full story, see i386 */
@


1.10.4.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d10 4
a13 4
static	__inline int splraise(int);
static	__inline int splexact(int);
static	__inline void splx(int);
static	__inline int spllower(int);
d49 1
a49 1
extern void walk_ipls(int, int);
d67 1
a67 1
extern int walk_ipls(int);
@


1.10.4.4
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.10.4.3 2002/03/28 10:06:15 niklas Exp $	*/
@


1.9
log
@Merge of NetBSD changes upto last week or so, with the exception of stand/
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.8 1997/01/16 09:26:04 niklas Exp $	*/
d21 1
a21 1
        __asm __volatile ("clrl %0; movew sr,%0" : "&=d" (opsl) : : "cc");
d33 1
a33 1
        __asm __volatile ("clrl %0; movew sr,%0; movew %1,sr" : "&=d" (opsl) :
d85 1
a85 1
        __asm __volatile ("clrl %0; movew sr,%0" : "&=d" (opsl) : : "cc");
@


1.8
log
@Sync to NetBSD 970110
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.7 1996/05/31 10:46:29 niklas Exp $	*/
d118 1
a118 1
 *   -is
@


1.7
log
@Added prototypes
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: psl.h,v 1.8 1996/04/21 21:13:22 veego Exp $	*/
d106 19
a124 2
#define spltty()	spl4()
#define splimp()	spl4()
@


1.6
log
@Restructure and document a bit.  Also fixed a confusing bug, which
actually might turn out a feature... :-)  But I want to test that a
bit more before having that into the tree.
@
text
@d10 4
@


1.5
log
@Fixup of a merge error
@
text
@d17 12
d30 1
a30 1
	    "di" (npsl));
d34 9
a43 1

d47 1
a47 1
static __inline int
d51 5
a55 3
        register int opsl;

        __asm __volatile ("clrl %0; movew sr,%0" : "=d" (opsl));
d58 1
a58 2
        __asm __volatile("movew %0,sr" : : "di" (npsl));
        return opsl;
d62 2
a63 3
#ifndef IPL_REMAP_2
#define splx splraise
#else
d65 9
a73 1
extern int walk_ipls __P((int));
d76 1
a76 1
splx(npsl)
d81 2
a82 3
	/* We should maybe have a flag telling if this is needed.  */
	opsl = walk_ipls(npsl);
        __asm __volatile("movew %0,sr" : : "di" (npsl));
a85 2
#endif

d87 1
a87 1
 * Shortcuts
d89 7
a95 7
#define spl1()	splraise(PSL_S|PSL_IPL1)
#define spl2()	splraise(PSL_S|PSL_IPL2)
#define spl3()	splraise(PSL_S|PSL_IPL3)
#define spl4()	splraise(PSL_S|PSL_IPL4)
#define spl5()	splraise(PSL_S|PSL_IPL5)
#define spl6()	splraise(PSL_S|PSL_IPL6)
#define spl7()  splraise(PSL_S|PSL_IPL7)
d117 1
a117 1
#define splsoftclock()	splx(PSL_S|PSL_IPL1)
d124 6
d135 1
a135 1
#define spl0()	splx(PSL_S|PSL_IPL0)
@


1.4
log
@Sync with NetBSD 9600430.  The port has gone over a major -Wall treat
@
text
@a10 7
/*
 * spl functions; all are normally done in-line
 */
#include <machine/psl.h>

#ifdef _KERNEL

@


1.3
log
@Bring forward the Amiga ISA support, and resolve a conflict with if_ed
@
text
@d1 2
a2 1
/*	$NetBSD: psl.h,v 1.7 1994/10/26 02:06:31 cgd Exp $	*/
d9 37
d47 68
@


1.2
log
@Add IPL_ and IST_ constants in preparation for the Amiga ISA-kit
@
text
@a5 14
/* Interrupt priority `levels'; not mutually exclusive. */
#define	IPL_NONE	-1
#define	IPL_BIO		3	/* block I/O */
#define	IPL_NET		3	/* network */
#define	IPL_TTY		4	/* terminal */
#define	IPL_CLOCK	4	/* clock */
#define	IPL_IMP		4	/* memory allocation */

/* Interrupt sharing types. */
#define	IST_NONE	0	/* none */
#define	IST_PULSE	1	/* pulsed */
#define	IST_EDGE	2	/* edge-triggered */
#define	IST_LEVEL	3	/* level-triggered */

@


1.1
log
@Initial revision
@
text
@d6 14
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
