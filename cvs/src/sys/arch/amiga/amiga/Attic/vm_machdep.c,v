head	1.31;
access;
symbols
	SMP_SYNC_A:1.31
	SMP_SYNC_B:1.31
	UBC_SYNC_A:1.31
	OPENBSD_3_2:1.30.0.6
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.30.0.4
	OPENBSD_3_1_BASE:1.30
	UBC_SYNC_B:1.30
	UBC:1.30.0.2
	UBC_BASE:1.30
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.11.0.6
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.4
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2002.12.31.16.35.36;	author miod;	state dead;
branches;
next	1.30;

1.30
date	2001.12.08.02.24.06;	author art;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2001.12.07.15.29.44;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.07.00.59.13;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.30.22.38.22;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.30.22.08.13;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.06.18.41.09;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.21.02.11.53;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.25.13.25.31;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.27.03.54.13;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.08.08.08.42;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.06.00.45.47;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.05.20.56.32;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.08.11.44.00;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.08.22.25.17;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.05.11.02.56;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.28.03.55.21;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.27.21.21.19;	author art;	state Exp;
branches;
next	1.11;

1.11
date	99.09.03.18.00.30;	author art;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	99.08.17.10.32.16;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.01.10.13.34.17;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	98.07.28.00.13.28;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.03.01.15.00.14;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.09.09.11.27.26;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.05.29.01.17.04;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.05.02.06.43.25;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.24.20.25.56;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.15.01.57.26;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.53;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.53;	author deraadt;	state Exp;
branches;
next	;

1.11.4.1
date	2001.04.18.16.02.01;	author niklas;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2001.07.04.10.15.03;	author niklas;	state Exp;
branches;
next	1.11.4.3;

1.11.4.3
date	2001.10.31.02.52.45;	author nate;	state Exp;
branches;
next	1.11.4.4;

1.11.4.4
date	2001.11.13.21.00.50;	author niklas;	state Exp;
branches;
next	1.11.4.5;

1.11.4.5
date	2001.12.05.00.39.09;	author niklas;	state Exp;
branches;
next	1.11.4.6;

1.11.4.6
date	2002.03.06.00.56.18;	author niklas;	state Exp;
branches;
next	1.11.4.7;

1.11.4.7
date	2003.03.27.23.19.17;	author niklas;	state dead;
branches;
next	;

1.30.2.1
date	2003.05.19.21.49.38;	author tedu;	state dead;
branches;
next	;


desc
@@


1.31
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: vm_machdep.c,v 1.30 2001/12/08 02:24:06 art Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.30 1997/05/19 10:14:50 veego Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: vm_machdep.c 1.21 91/04/06$
 *
 *	@@(#)vm_machdep.c	7.10 (Berkeley) 5/7/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/user.h>
#include <sys/core.h>
#include <sys/exec.h>

#include <machine/cpu.h>
#include <machine/pte.h>
#include <machine/reg.h>

#include <uvm/uvm_extern.h>

/*
 * Finish a fork operation, with process p2 nearly set up.
 * Copy and update the kernel stack and pcb, making the child
 * ready to run, and marking it so that it can return differently
 * than the parent.  Returns 1 in the child process, 0 in the parent.
 * We currently double-map the user area so that the stack is at the same
 * address in each process; in the future we will probably relocate
 * the frame pointers on the stack after copying.
 */
void
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
	void *stack;
	size_t stacksize;
	void (*func)(void *);
	void *arg;
{
	struct pcb *pcb = &p2->p_addr->u_pcb;
	struct trapframe *tf;
	struct switchframe *sf;
	extern struct pcb *curpcb;

	p2->p_md.md_flags = p1->p_md.md_flags;

	/* Copy pcb from proc p1 to p2. */
	if (p1 == curproc) {
		savectx(curpcb);
	}
#ifdef DIAGNOSTIC
	else if (p1 != &proc0)
		panic("cpu_fork: curproc");
#endif
	*pcb = p1->p_addr->u_pcb;

	/*
	 * Copy the trap frame, and arrange for the child to return directly
	 * through return_to_user().
	 */
	tf = (struct trapframe *)((u_int)p2->p_addr + USPACE) - 1;
	p2->p_md.md_regs = (int *)tf;
	*tf = *(struct trapframe *)p1->p_md.md_regs;

	/*
	 * If specified, give the child a different stack.
	 */
	if (stack != NULL)
		tf->tf_regs[15] = (u_int)stack + stacksize;

	sf = (struct switchframe *)tf - 1;
	sf->sf_pc = (u_int)proc_trampoline;
	pcb->pcb_regs[6] = (int)func;		/* A2 */
	pcb->pcb_regs[7] = (int)arg;		/* A3 */
	pcb->pcb_regs[11] = (int)sf;		/* SSP */
}

/*
 * cpu_exit is called as the last action during exit.
 * We release the address space and machine-dependent resources,
 * Block context switches and then call switch_exit() which will
 * free our stack and user area and switch to another process
 * thus we never return.
 */
void
cpu_exit(p)
	struct proc *p;
{

	(void)splhigh();
	uvmexp.swtch++;
	switch_exit(p);
	/* NOTREACHED */
}

/*
 * Move pages from one kernel virtual address to another.
 * Both addresses are assumed to reside in the Sysmap.
 */
void
pagemove(from, to, size)
	caddr_t from, to;
	size_t size;
{
	vm_offset_t pa;

#ifdef DEBUG
	if ((size & PAGE_MASK) != 0)
		panic("pagemove");
#endif
	while (size > 0) {
		pmap_extract(pmap_kernel(), (vm_offset_t)from, &pa);
#ifdef DEBUG
#if 0
		if (pa == 0)
			panic("pagemove 2");
		if (pmap_extract(pmap_kernel(), (vm_offset_t)to, XXX) != FALSE)
			panic("pagemove 3");
#endif
#endif
		pmap_kremove((vaddr_t)from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t)to, pa, VM_PROT_READ|VM_PROT_WRITE);
		from += PAGE_SIZE;
		to += PAGE_SIZE;
		size -= PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
}

/*
 * Map `size' bytes of physical memory starting at `paddr' into
 * kernel VA space at `vaddr'.  Read/write and cache-inhibit status
 * are specified by `prot'.
 */ 
void
physaccess(vaddr, paddr, size, prot)
	caddr_t vaddr, paddr;
	register int size, prot;
{
	u_int *pte;
	register u_int page;

	/* if cache not inhibited, set cacheable & copyback */
	if (mmutype <= MMU_68040 && (prot & PG_CI) == 0)
		prot |= PG_CCB;
	else if (cputype == CPU_68060 && (prot & PG_CI))
                prot |= PG_CIN;
	pte = kvtopte(vaddr);
	page = (u_int)paddr & PG_FRAME;
	for (size = btoc(size); size; size--) {
		*pte++ = PG_V | prot | page;
		page += NBPG;
	}
	TBIAS();
}

void
physunaccess(vaddr, size)
	caddr_t vaddr;
	register int size;
{
	u_int *pte;

	pte = kvtopte(vaddr);
	for (size = btoc(size); size; size--)
		*pte++ = PG_NV;
	TBIAS();
}

/*
 * Dump the machine specific segment at the start of a core dump.
 * This means the CPU and FPU registers.  The format used here is
 * the same one ptrace uses, so gdb can be machine independent.
 *
 * XXX - Generate Sun format core dumps for Sun executables?
 */
struct md_core {
	struct reg intreg;
	struct fpreg freg;
};
int
cpu_coredump(p, vp, cred, chdr)
	struct proc *p;
	struct vnode *vp;
	struct ucred *cred;
	struct core *chdr;
{
	int error;
	struct md_core md_core;
	struct coreseg cseg;
	struct user *up = p->p_addr;
	int i;

	CORE_SETMAGIC(*chdr, COREMAGIC, MID_M68K, 0);
	chdr->c_hdrsize = ALIGN(sizeof(*chdr));
	chdr->c_seghdrsize = ALIGN(sizeof(cseg));
	chdr->c_cpusize = sizeof(md_core);

	/* Save integer registers. */
	{
		register struct frame *f;

		f = (struct frame*) p->p_md.md_regs;
		for (i = 0; i < 16; i++) {
			md_core.intreg.r_regs[i] = f->f_regs[i];
		}
		md_core.intreg.r_sr = f->f_sr;
		md_core.intreg.r_pc = f->f_pc;
	}
	if (fputype) {
		register struct fpframe *f;

		f = &up->u_pcb.pcb_fpregs;
		m68881_save(f);
		for (i = 0; i < (8*3); i++) {
			md_core.freg.r_regs[i] = f->fpf_regs[i];
		}
		md_core.freg.r_fpcr  = f->fpf_fpcr;
		md_core.freg.r_fpsr  = f->fpf_fpsr;
		md_core.freg.r_fpiar = f->fpf_fpiar;
	} else {
		bzero((caddr_t)&md_core.freg, sizeof(md_core.freg));
	}

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_M68K, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = chdr->c_cpusize;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE,
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&md_core, sizeof(md_core),
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);

	if (!error)
		chdr->c_nseg++;

	return error;
}

/*
 * Convert kernel VA to physical address
 */
int
kvtop(addr)
	caddr_t addr;
{
	paddr_t pa;

	if (pmap_extract(pmap_kernel(), (vm_offset_t)addr, &pa) == FALSE)
		panic("kvtop: zero page frame");
	return((int)pa);
}

/*
 * Map a user I/O request into kernel virtual address space.
 * Note: the pages are already locked by uvm_vslock(), so we
 * do not need to pass an access_type to pmap_enter().
 */
void
vmapbuf(bp, len)
     struct buf *bp;
     vm_size_t len;
{
	struct pmap *upmap, *kpmap;
	vaddr_t uva;	/* User VA (map from) */
	vaddr_t kva;	/* Kernel VA (new to) */
	paddr_t pa;	/* physical address */
	vaddr_t off;

	if ((bp->b_flags & B_PHYS) == 0)
		panic("vmapbuf");

	uva = m68k_trunc_page(bp->b_saveaddr = bp->b_data);
	off = (vaddr_t)bp->b_data - uva;
	len = m68k_round_page(off + len);
	kva = uvm_km_valloc_wait(phys_map, len);
	bp->b_data = (caddr_t)(kva + off);

	upmap = vm_map_pmap(&bp->b_proc->p_vmspace->vm_map);
	kpmap = vm_map_pmap(phys_map);
	do {
		if (pmap_extract(upmap, uva, &pa) == FALSE)
			panic("vmapbuf: null page frame");
		pmap_enter(kpmap, kva, pa, VM_PROT_READ|VM_PROT_WRITE,
			   PMAP_WIRED);
                uva += PAGE_SIZE;
                kva += PAGE_SIZE;
                len -= PAGE_SIZE;
        } while (len);
	pmap_update(kpmap);
}

/*
 * Unmap a previously-mapped user I/O request.
 */
void
vunmapbuf(bp, len)
     struct buf *bp;
     vm_size_t len;
{
        vaddr_t kva;
        vaddr_t off;

        if ((bp->b_flags & B_PHYS) == 0)
                panic("vunmapbuf");

        kva = m68k_trunc_page(bp->b_data);
        off = (vaddr_t)bp->b_data - kva;
        len = m68k_round_page(off + len);

	pmap_remove(pmap_kernel(), kva, kva + len);
	pmap_update(pmap_kernel());
        uvm_km_free_wakeup(phys_map, kva, len);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = 0;
}
@


1.30
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.29 2001/12/07 15:29:44 art Exp $	*/
@


1.30.2.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.30 2001/12/08 02:24:06 art Exp $	*/
@


1.29
log
@Since amiga now has correct pmap_k* and uses them for mapping
the buffer cache, it's a good idea to use them in pagemove too.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.28 2001/12/07 00:59:13 miod Exp $	*/
d167 1
d335 1
d356 2
a357 4
        /*
         * pmap_remove() is unnecessary here, as kmem_free_wakeup()
         * will do it for us.
         */
@


1.28
log
@Ratibibugle setredzone()

[Ratibibugle is local slang for g/c, remove, rototill, etc]
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.27 2001/11/30 22:38:22 miod Exp $	*/
d161 2
a162 5
		pmap_remove(pmap_kernel(), (vm_offset_t)from,
		    (vm_offset_t)from + PAGE_SIZE);
		pmap_enter(pmap_kernel(),  (vm_offset_t)to, pa,
		    VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
@


1.27
log
@Oops, removed one #include line by mistake.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.26 2001/11/30 22:08:13 miod Exp $	*/
a284 19
}

/*
 * Set a red zone in the kernel stack after the u. area.
 * We don't support a redzone right now.  It really isn't clear
 * that it is a good idea since, if the kernel stack were to roll
 * into a write protected page, the processor would lock up (since
 * it cannot create an exception frame) and we would get no useful
 * post-mortem info.  Currently, under the DEBUG option, we just
 * check at every clock interrupt to see if the current k-stack has
 * gone too far (i.e. into the "redzone" page) and if so, panic.
 * Look at _lev6intr in locore.s for more details.
 */
/*ARGSUSED*/
void
setredzone(pte, vaddr)
	u_int *pte;
	caddr_t vaddr;
{
@


1.26
log
@Make it possible for mmutype to contain MMU_68060 if the hardware is
actually '060-based, instead to look at the machineid.
This is simpler, and will be required to switch to pmap_motorola anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.25 2001/11/06 19:53:14 miod Exp $	*/
d54 1
@


1.25
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.24 2001/11/06 18:41:09 art Exp $	*/
d51 1
d53 2
a54 4
#include <sys/buf.h>
#include <sys/core.h>
#include <sys/exec_aout.h>
#include <m68k/reg.h>
d57 2
a59 1
#include <sys/user.h>
a60 1
#include <machine/pte.h>
d185 1
a185 1
	if (mmutype == MMU_68040 && (prot & PG_CI) == 0)
@


1.24
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.23 2001/09/21 02:11:53 miod Exp $	*/
a58 1
#include <vm/vm.h>
@


1.23
log
@phys_map declaration comes from <vm/vm.h>, no need to declare it locally.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.22 2001/09/19 20:50:56 mickey Exp $	*/
a63 4
/* XXX - Put this in some header file? */
void child_return __P((struct proc *, struct frame));


d74 2
a75 2
cpu_fork(p1, p2, stack, stacksize)
	register struct proc *p1, *p2;
d78 2
d81 3
a83 3
	register struct pcb *pcb = &p2->p_addr->u_pcb;
	register struct trapframe *tf;
	register struct switchframe *sf;
d100 1
a100 1
	 * through return_to_user().  Note the inline cpu_set_kpc();
d114 2
a115 2
	pcb->pcb_regs[6] = (int)child_return;	/* A2 */
	pcb->pcb_regs[7] = (int)p2;		/* A3 */
a116 26
}

/*
 * cpu_set_kpc:
 *
 * Arrange for in-kernel execution of a process to continue at the
 * named pc, as if the code at that address were called as a function
 * with argument, the current process's process pointer.
 *
 * Note that it's assumed that when the named process returns, rei()
 * should be invoked, to return to user mode.
 */
void
cpu_set_kpc(p, pc, arg)
	struct proc	*p;
	void		(*pc) __P((void *));
	void		*arg;
{
	struct pcb *pcbp;
	struct switchframe *sf;

	pcbp = &p->p_addr->u_pcb;
	sf = (struct switchframe *)pcbp->pcb_regs[11];
	sf->sf_pc = (u_int)proc_trampoline;
	pcbp->pcb_regs[6] = (int)pc;		/* A2 */
	pcbp->pcb_regs[7] = (int)arg;		/* A3 */
@


1.22
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.21 2001/07/25 13:25:31 art Exp $	*/
a347 2

extern vm_map_t phys_map;
@


1.21
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.20 2001/06/27 03:54:13 art Exp $	*/
a60 1
#include <vm/vm_kern.h>
@


1.20
log
@No more old VM on amiga.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.19 2001/06/08 08:08:42 art Exp $	*/
d194 2
a195 2
		    VM_PROT_READ|VM_PROT_WRITE, 1,
		    VM_PROT_READ|VM_PROT_WRITE);
d383 1
a383 1
			   TRUE, 0);
@


1.19
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.18 2001/05/06 00:45:47 art Exp $	*/
a61 1
#if defined(UVM)
a62 1
#endif
a160 1
#if defined(UVM)
a161 3
#else
	cnt.v_swtch++;
#endif
a373 1
#if defined(UVM)
a374 3
#else
	kva = kva = kmem_alloc_wait(phys_map, len);
#endif
a411 1
#if defined(UVM)
d413 2
a414 5
#else
	kmem_free_wakeup(phys_map, kva, len);
#endif
        bp->b_data = bp->b_saveaddr;
        bp->b_saveaddr = 0;
@


1.18
log
@Update some comments wrt. the CLSIZE changes.
And remove that memory price comment from 1981. It is amusing, but also
confusing because the math in there is only correct on vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17 2001/05/05 20:56:32 art Exp $	*/
d178 1
a178 1
	register caddr_t from, to;
d181 1
a181 1
	register vm_offset_t pa;
d188 1
a188 1
		pa = pmap_extract(pmap_kernel(), (vm_offset_t)from);
d190 1
d193 1
a193 1
		if (pmap_extract(pmap_kernel(), (vm_offset_t)to) != 0)
d196 1
d347 1
a347 1
	register caddr_t addr;
d349 1
a349 1
	vm_offset_t va;
d351 1
a351 2
	va = pmap_extract(pmap_kernel(), (vm_offset_t)addr);
	if (va == 0)
d353 1
a353 1
	return((int)va);
d390 1
a390 1
		if ((pa = pmap_extract(upmap, uva)) == 0)
@


1.17
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16 2000/11/08 11:44:00 art Exp $	*/
d174 1
a174 2
 * Both addresses are assumed to reside in the Sysmap,
 * and size must be a multiple of CLSIZE.
@


1.16
log
@Some fixes to vmapbuf and vunmapbuf.
Mostly from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15 2000/06/08 22:25:17 niklas Exp $	*/
d185 1
a185 1
	if (size & CLOFSET)
@


1.15
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.15 2000/06/08 21:11:54 niklas Exp $	*/
d94 7
a100 1
	savectx(curpcb);
d223 2
d359 3
a361 16
 * Map an IO request into kernel virtual address space.  Requests fall into
 * one of five catagories:
 *
 *	B_PHYS|B_UAREA:	User u-area swap.
 *			Address is relative to start of u-area (p_addr).
 *	B_PHYS|B_PAGET:	User page table swap.
 *			Address is a kernel VA in usrpt (Usrptmap).
 *	B_PHYS|B_DIRTY:	Dirty page push.
 *			Address is a VA in proc2's address space.
 *	B_PHYS|B_PGIN:	Kernel pagein of user pages.
 *			Address is VA in user's address space.
 *	B_PHYS:		User "raw" IO request.
 *			Address is VA in user's address space.
 *
 * All requests are (re)mapped into kernel VA space via the useriomap
 * (a name with only slightly more meaning than "kernelmap")
a362 1
/*ARGSUSED*/
d364 9
a372 11
vmapbuf(bp, sz)
	register struct buf *bp;
	vm_size_t sz;
{
	register int npf;
	register caddr_t addr;
	register long flags = bp->b_flags;
	struct proc *p;
	int off;
	vm_offset_t kva;
	register vm_offset_t pa;
d374 1
a374 1
	if ((flags & B_PHYS) == 0)
d376 4
a379 4
	addr = bp->b_saveaddr = bp->b_un.b_addr;
	off = (int)addr & PGOFSET;
	p = bp->b_proc;
	npf = btoc(round_page(bp->b_bcount + off));
d381 1
a381 1
	kva = uvm_km_valloc_wait(phys_map, ctob(npf));
d383 1
a383 1
	kva = kmem_alloc_wait(phys_map, ctob(npf));
d385 6
a390 5
	bp->b_un.b_addr = (caddr_t) (kva + off);
	while (npf--) {
		pa = pmap_extract(vm_map_pmap(&p->p_vmspace->vm_map),
		    (vm_offset_t)addr);
		if (pa == 0)
d392 6
a397 5
		pmap_enter(vm_map_pmap(phys_map), kva, trunc_page(pa),
			   VM_PROT_READ|VM_PROT_WRITE, TRUE, 0);
		addr += PAGE_SIZE;
		kva += PAGE_SIZE;
	}
d401 1
a401 2
 * Free the io map PTEs associated with this IO operation.
 * We also invalidate the TLB entries and restore the original b_addr.
a402 1
/*ARGSUSED*/
d404 18
a421 12
vunmapbuf(bp, sz)
	register struct buf *bp;
	vm_size_t sz;
{
	register int npf;
	register caddr_t addr = bp->b_un.b_addr;
	vm_offset_t kva;

	if ((bp->b_flags & B_PHYS) == 0)
		panic("vunmapbuf");
	npf = btoc(round_page(bp->b_bcount + ((int)addr & PGOFSET)));
	kva = (vm_offset_t)((int)addr & ~PGOFSET);
d423 1
a423 1
	uvm_km_free_wakeup(phys_map, kva, ctob(npf));
d425 1
a425 1
	kmem_free_wakeup(phys_map, kva, ctob(npf));
d427 2
a428 2
	bp->b_un.b_addr = bp->b_saveaddr;
	bp->b_saveaddr = NULL;
@


1.14
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.13 2000/05/28 03:55:21 art Exp $	*/
d49 1
@


1.13
log
@Bugfix pmap_activate.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.12 2000/05/27 21:21:19 art Exp $	*/
d154 1
a154 6
#if defined(UVM)
	uvmspace_free(p->p_vmspace);
#else
	vmspace_free(p->p_vmspace);
#endif
	
@


1.12
log
@UVM support.
Just some changes of function names. *yawn*
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11 1999/09/03 18:00:30 art Exp $	*/
a95 2
	PMAP_ACTIVATE(p2->p_vmspace->vm_map.pmap, pcb, 0);

d393 1
a393 1
	kva = uvm_km_valloc_wait(phys_map, len);
d429 1
a429 1
	uvm_km_free_wakeup(phys_map, kva, len);
@


1.11
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.10 1999/08/17 10:32:16 niklas Exp $	*/
d61 3
d156 3
d160 1
d163 3
d167 1
d394 3
d398 1
d430 3
d434 1
@


1.11.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16 2000/11/08 11:44:00 art Exp $	*/
a48 1
#include <sys/signalvar.h>
a60 3
#if defined(UVM)
#include <uvm/uvm_extern.h>
#endif
d90 1
a90 7
	if (p1 == curproc) {
		savectx(curpcb);
	}
#ifdef DIAGNOSTIC
	else if (p1 != &proc0)
		panic("cpu_fork: curproc");
#endif
d93 2
d153 2
a154 1

a155 3
#if defined(UVM)
	uvmexp.swtch++;
#else
a156 1
#endif
a211 2
	else if (cputype == CPU_68060 && (prot & PG_CI))
                prot |= PG_CIN;
d346 16
a361 3
 * Map a user I/O request into kernel virtual address space.
 * Note: the pages are already locked by uvm_vslock(), so we
 * do not need to pass an access_type to pmap_enter().
d363 1
d365 11
a375 9
vmapbuf(bp, len)
     struct buf *bp;
     vm_size_t len;
{
	struct pmap *upmap, *kpmap;
	vaddr_t uva;	/* User VA (map from) */
	vaddr_t kva;	/* Kernel VA (new to) */
	paddr_t pa;	/* physical address */
	vaddr_t off;
d377 1
a377 1
	if ((bp->b_flags & B_PHYS) == 0)
d379 10
a388 15

	uva = m68k_trunc_page(bp->b_saveaddr = bp->b_data);
	off = (vaddr_t)bp->b_data - uva;
	len = m68k_round_page(off + len);
#if defined(UVM)
	kva = uvm_km_valloc_wait(phys_map, len);
#else
	kva = kva = kmem_alloc_wait(phys_map, len);
#endif
	bp->b_data = (caddr_t)(kva + off);

	upmap = vm_map_pmap(&bp->b_proc->p_vmspace->vm_map);
	kpmap = vm_map_pmap(phys_map);
	do {
		if ((pa = pmap_extract(upmap, uva)) == 0)
d390 5
a394 6
		pmap_enter(kpmap, kva, pa, VM_PROT_READ|VM_PROT_WRITE,
			   TRUE, 0);
                uva += PAGE_SIZE;
                kva += PAGE_SIZE;
                len -= PAGE_SIZE;
        } while (len);
d398 2
a399 1
 * Unmap a previously-mapped user I/O request.
d401 1
d403 15
a417 25
vunmapbuf(bp, len)
     struct buf *bp;
     vm_size_t len;
{
        vaddr_t kva;
        vaddr_t off;

        if ((bp->b_flags & B_PHYS) == 0)
                panic("vunmapbuf");

        kva = m68k_trunc_page(bp->b_data);
        off = (vaddr_t)bp->b_data - kva;
        len = m68k_round_page(off + len);

        /*
         * pmap_remove() is unnecessary here, as kmem_free_wakeup()
         * will do it for us.
         */
#if defined(UVM)
        uvm_km_free_wakeup(phys_map, kva, len);
#else
	kmem_free_wakeup(phys_map, kva, len);
#endif
        bp->b_data = bp->b_saveaddr;
        bp->b_saveaddr = 0;
@


1.11.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11.4.1 2001/04/18 16:02:01 niklas Exp $	*/
d62 1
d64 1
d163 1
d165 3
d174 2
a175 1
 * Both addresses are assumed to reside in the Sysmap.
d179 1
a179 1
	caddr_t from, to;
d182 1
a182 1
	vm_offset_t pa;
d185 1
a185 1
	if ((size & PAGE_MASK) != 0)
d189 1
a189 1
		pmap_extract(pmap_kernel(), (vm_offset_t)from, &pa);
a190 1
#if 0
d193 1
a193 1
		if (pmap_extract(pmap_kernel(), (vm_offset_t)to, XXX) != FALSE)
a195 1
#endif
d346 1
a346 1
	caddr_t addr;
d348 1
a348 1
	paddr_t pa;
d350 2
a351 1
	if (pmap_extract(pmap_kernel(), (vm_offset_t)addr, &pa) == FALSE)
d353 1
a353 1
	return((int)pa);
d380 1
d382 3
d390 1
a390 1
		if (pmap_extract(upmap, uva, &pa) == FALSE)
d422 1
d424 5
a428 2
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = 0;
@


1.11.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11.4.2 2001/07/04 10:15:03 niklas Exp $	*/
d61 1
d194 2
a195 2
		    VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d350 2
d383 1
a383 1
			   PMAP_WIRED);
@


1.11.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 1
d64 4
d78 2
a79 2
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
a81 2
	void (*func)(void *);
	void *arg;
d83 3
a85 3
	struct pcb *pcb = &p2->p_addr->u_pcb;
	struct trapframe *tf;
	struct switchframe *sf;
d102 1
a102 1
	 * through return_to_user().
d116 2
a117 2
	pcb->pcb_regs[6] = (int)func;		/* A2 */
	pcb->pcb_regs[7] = (int)arg;		/* A3 */
d119 26
@


1.11.4.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11.4.4 2001/11/13 21:00:50 niklas Exp $	*/
d51 1
a52 2
#include <sys/vnode.h>
#include <sys/user.h>
d54 2
a55 1
#include <sys/exec.h>
a57 2
#include <machine/pte.h>
#include <machine/reg.h>
d59 1
d61 1
d186 1
a186 1
	if (mmutype <= MMU_68040 && (prot & PG_CI) == 0)
@


1.11.4.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d161 5
a165 2
		pmap_kremove((vaddr_t)from, PAGE_SIZE);
		pmap_kenter_pa((vaddr_t)to, pa, VM_PROT_READ|VM_PROT_WRITE);
a169 1
	pmap_update(pmap_kernel());
d288 19
a355 1
	pmap_update(kpmap);
d376 4
a379 2
	pmap_remove(pmap_kernel(), kva, kva + len);
	pmap_update(pmap_kernel());
@


1.11.4.7
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11.4.6 2002/03/06 00:56:18 niklas Exp $	*/
@


1.10
log
@New cpu_fork API to take a stack in which you point the child's stackpointer
to, at the bottom or the top, depending on your architecture's stack growth
direction.  This is in preparation for Linux' clone(2) emulation.
port maintainers, please check that I did the work right.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.9 1999/01/10 13:34:17 niklas Exp $	*/
d188 2
a189 1
		    VM_PROT_READ|VM_PROT_WRITE, 1);
d391 1
a391 1
			   VM_PROT_READ|VM_PROT_WRITE, TRUE);
@


1.9
log
@Generalize cpu_set_kpc to take any kind of arg; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.8 1998/07/28 00:13:28 millert Exp $	*/
d77 1
a77 1
cpu_fork(p1, p2)
d79 2
d102 7
@


1.8
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.7 1998/03/01 15:00:14 niklas Exp $	*/
d95 1
a95 1
	 * through return_to_user().
d118 1
a118 1
cpu_set_kpc(p, pc)
d120 2
a121 1
	void		(*pc) __P((struct proc *));
d130 1
a130 1
	pcbp->pcb_regs[7] = (int)p;		/* A3 */
@


1.7
log
@GCC 2.8 requires explicit types
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.6 1997/09/09 11:27:26 niklas Exp $	*/
d284 1
a284 1
	    IO_NODELOCKED|IO_UNIT, cred, (int *)NULL, p);
d290 1
a290 1
	    IO_NODELOCKED|IO_UNIT, cred, (int *)NULL, p);
@


1.6
log
@From NetBSD: s/vm_pmap/vm_map.pmap/
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.5 1997/05/29 01:17:04 niklas Exp $	*/
d244 2
a245 2
	register struct user *up = p->p_addr;
	register i;
@


1.5
log
@Slight KNF
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: vm_machdep.c,v 1.29 1996/04/25 05:57:38 veego Exp $	*/
d91 1
a91 1
	PMAP_ACTIVATE(&p2->p_vmspace->vm_pmap, pcb, 0);
@


1.4
log
@Sync with NetBSD 9600430.  The port has gone over a major -Wall treat
@
text
@d175 4
a178 4
		pmap_remove(pmap_kernel(),
			    (vm_offset_t)from, (vm_offset_t)from + PAGE_SIZE);
		pmap_enter(pmap_kernel(),
			   (vm_offset_t)to, pa, VM_PROT_READ|VM_PROT_WRITE, 1);
@


1.3
log
@From NetBSD: vm prototype changes
@
text
@d1 2
a2 1
/*	$NetBSD: vm_machdep.c,v 1.26 1996/02/05 02:06:38 christos Exp $	*/
d63 4
a83 1
	extern void proc_trampoline(), child_return();
d119 2
a120 2
	struct proc *p;
	u_int32_t pc;
a123 1
	extern void proc_trampoline(), child_return();
d128 1
a128 1
	pcbp->pcb_regs[6] = pc;			/* A2 */
d156 1
d159 1
a159 1
	int size;
d190 1
d210 1
d310 1
d320 1
@


1.2
log
@from netbsd; cpu_fork changes types
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.25 1995/12/09 04:37:30 mycroft Exp $	*/
d344 3
a346 1
vmapbuf(bp)
d348 1
d382 3
a384 1
vunmapbuf(bp)
d386 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.24 1995/08/18 15:27:41 chopps Exp $	*/
d71 1
a100 2

	return (0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

