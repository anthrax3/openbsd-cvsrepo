head	1.41;
access;
symbols
	SMP_SYNC_A:1.41
	SMP_SYNC_B:1.41
	UBC_SYNC_A:1.41
	OPENBSD_3_2:1.40.0.4
	OPENBSD_3_2_BASE:1.40
	OPENBSD_3_1:1.40.0.2
	OPENBSD_3_1_BASE:1.40
	UBC_SYNC_B:1.40
	UBC:1.34.0.2
	UBC_BASE:1.34
	OPENBSD_3_0:1.31.0.2
	OPENBSD_3_0_BASE:1.31
	OPENBSD_2_9:1.29.0.4
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_8:1.29.0.2
	OPENBSD_2_8_BASE:1.29
	OPENBSD_2_7:1.25.0.8
	OPENBSD_2_7_BASE:1.25
	SMP:1.25.0.6
	SMP_BASE:1.25
	kame_19991208:1.25
	OPENBSD_2_6:1.25.0.4
	OPENBSD_2_6_BASE:1.25
	OPENBSD_2_5:1.25.0.2
	OPENBSD_2_5_BASE:1.25
	OPENBSD_2_4:1.24.0.6
	OPENBSD_2_4_BASE:1.24
	OPENBSD_2_3:1.24.0.4
	OPENBSD_2_3_BASE:1.24
	OPENBSD_2_2:1.24.0.2
	OPENBSD_2_2_BASE:1.24
	OPENBSD_2_1:1.21.0.2
	OPENBSD_2_1_BASE:1.21
	OPENBSD_2_0:1.11.0.2
	OPENBSD_2_0_BASE:1.11
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.41
date	2002.12.31.16.35.36;	author miod;	state dead;
branches;
next	1.40;

1.40
date	2002.03.25.19.41.03;	author niklas;	state Exp;
branches;
next	1.39;

1.39
date	2002.02.23.00.31.09;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2002.02.22.23.40.07;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2002.02.10.23.15.05;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2002.01.24.20.31.07;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2001.12.20.19.02.24;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2001.12.06.21.13.28;	author millert;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2001.11.30.23.14.28;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.30.22.08.13;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2001.08.12.23.52.59;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.27.03.54.12;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2000.06.05.11.02.55;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2000.05.28.03.55.21;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2000.05.27.20.14.18;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2000.05.27.19.48.36;	author art;	state Exp;
branches;
next	1.25;

1.25
date	99.01.20.12.04.01;	author niklas;	state Exp;
branches
	1.25.6.1;
next	1.24;

1.24
date	97.09.19.17.16.12;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	97.09.18.13.39.35;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	97.07.20.07.35.37;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	97.04.29.00.46.27;	author michaels;	state Exp;
branches;
next	1.20;

1.20
date	97.03.27.12.06.45;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	97.03.26.21.51.31;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	97.03.26.19.04.25;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	97.02.22.00.28.57;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	97.02.21.08.55.14;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	97.02.03.15.05.04;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.02.03.11.38.05;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.01.16.09.23.22;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	96.11.23.23.19.27;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	96.08.19.00.04.14;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.05.29.10.14.27;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	96.05.07.09.58.36;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.05.04.13.34.27;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.05.04.13.29.04;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.05.02.06.43.18;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.02.26.21.31.00;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.02.06.09.16.31;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	95.12.15.01.57.48;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.28.19.36.00;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.52;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.52;	author deraadt;	state Exp;
branches;
next	;

1.25.6.1
date	2001.04.18.16.01.56;	author niklas;	state Exp;
branches;
next	1.25.6.2;

1.25.6.2
date	2001.07.04.10.14.57;	author niklas;	state Exp;
branches;
next	1.25.6.3;

1.25.6.3
date	2001.10.31.02.52.45;	author nate;	state Exp;
branches;
next	1.25.6.4;

1.25.6.4
date	2001.12.05.00.39.09;	author niklas;	state Exp;
branches;
next	1.25.6.5;

1.25.6.5
date	2002.03.06.00.56.18;	author niklas;	state Exp;
branches;
next	1.25.6.6;

1.25.6.6
date	2003.03.27.23.19.16;	author niklas;	state dead;
branches;
next	;

1.34.2.1
date	2002.01.31.22.55.06;	author niklas;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2002.06.11.03.34.57;	author art;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2003.05.19.21.49.37;	author tedu;	state dead;
branches;
next	;


desc
@@


1.41
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: locore.s,v 1.40 2002/03/25 19:41:03 niklas Exp $	*/
/*	$NetBSD: locore.s,v 1.89 1997/07/17 16:22:54 is Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1980, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: locore.s 1.58 91/04/22$
 *
 *	@@(#)locore.s	7.11 (Berkeley) 5/9/91
 *
 * Original (hp300) Author: unknown, maybe Mike Hibler?
 * Amiga author: Markus Wild
 * Other contributors: Bryan Ford (kernel reload stuff),
 *		       Niklas Hallqvist (remapping interrupt system)
 */

#include "assym.h"

#include <machine/asm.h>
#include <machine/trap.h>

	.globl	_kernel_text
_kernel_text:
L_base:
	.long	0x4ef80400+NBPG	/* jmp jmp0.w */
	.fill	NBPG/4-1,4,0/*xdeadbeef*/

#include <amiga/amiga/vectors.s>
#include <amiga/amiga/custom.h>
#include "ser.h"
#include "fd.h"

#ifdef DRACO
#include <amiga/amiga/drcustom.h>
#endif

#define CIAAADDR(ar)	movl	_CIAAbase,ar
#define CIABADDR(ar)	movl	_CIABbase,ar
#define CUSTOMADDR(ar)	movl	_CUSTOMbase,ar
#define INTREQRADDR(ar)	movl	_INTREQRaddr,ar
#define INTREQWADDR(ar)	movl	_INTREQWaddr,ar
#define INTENAWADDR(ar) movl	_INTENAWaddr,ar
#define INTENARADDR(ar)	movl	_INTENARaddr,ar

	.text
/*
 * This is where we wind up if the kernel jumps to location 0.
 * (i.e. a bogus PC)  This is known to immediately follow the vector
 * table and is hence at 0x400 (see reset vector in vectors.s).
 */
	.globl	_panic
	pea	Ljmp0panic
	jbsr	_panic
	/* NOTREACHED */
Ljmp0panic:
	.asciz	"kernel jump to zero"
	.even

/*
 * Do a dump.
 * Called by auto-restart.
 */
	.globl	_dumpsys
	.globl	_doadump
_doadump:
	jbsr	_dumpsys
	jbsr	_doboot
	/*NOTREACHED*/

/*
 * Trap/interrupt vector routines
 */
#include <m68k/m68k/trap_subr.s>

	.globl	_trap, _nofault, _longjmp
#if defined(M68040) || defined(M68060)
	.globl _addrerr4060
_addrerr4060:
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	movl	sp@@(FR_HW+8),sp@@-
	clrl	sp@@-			| dummy code
	movl	#T_ADDRERR,sp@@-		| mark address error
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
#endif

#if defined(M68060)
	.globl _buserr60
_buserr60:
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	movel	sp@@(FR_HW+12),d0	| FSLW
	btst	#2,d0			| branch prediction error?
	jeq	Lnobpe			
	movc	cacr,d2
	orl	#IC60_CABC,d2		| clear all branch cache entries
	movc	d2,cacr
	movl	d0,d1
	addql	#1,L60bpe
	andl	#0x7ffd,d1
	jeq	_ASM_LABEL(faultstkadjnotrap2)
Lnobpe:
| we need to adjust for misaligned addresses
	movl	sp@@(FR_HW+8),d1		| grab VA
	btst	#27,d0			| check for mis-aligned access
	jeq	Lberr3			| no, skip
	addl	#28,d1			| yes, get into next page
					| operand case: 3,
					| instruction case: 4+12+12
	andl	#PG_FRAME,d1            | and truncate
Lberr3:
	movl	d1,sp@@-
	movl	d0,sp@@-			| code is FSLW now.
	andw	#0x1f80,d0 
	jeq	Lisberr
	movl	#T_MMUFLT,sp@@-		| show that we are an MMU fault
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
#endif
#if defined(M68040)
	.globl _buserr40
_buserr40:
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	movl	sp@@(FR_HW+20),d1	| get fault address
	moveq	#0,d0
	movw	sp@@(FR_HW+12),d0	| get SSW
	btst	#11,d0			| check for mis-aligned
	jeq	Lbe1stpg		| no skip
	addl	#3,d1			| get into next page
	andl	#PG_FRAME,d1		| and truncate
Lbe1stpg:
	movl	d1,sp@@-			| pass fault address.
	movl	d0,sp@@-			| pass SSW as code
	btst	#10,d0			| test ATC
	jeq	Lisberr			| it is a bus error
	movl	#T_MMUFLT,sp@@-		| show that we are an MMU fault
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
#endif

_buserr:
_addrerr:
#if !(defined(M68020) || defined(M68030))
	jra	_badtrap
#else
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	moveq	#0,d0
	movw	sp@@(FR_HW+10),d0	| grab SSW for fault processing
	btst	#12,d0			| RB set?
	jeq	LbeX0			| no, test RC
	bset	#14,d0			| yes, must set FB
	movw	d0,sp@@(FR_HW+10)	| for hardware too
LbeX0:
	btst	#13,d0			| RC set?
	jeq	LbeX1			| no, skip
	bset	#15,d0			| yes, must set FC
	movw	d0,sp@@(FR_HW+10)	| for hardware too
LbeX1:
	btst	#8,d0			| data fault?
	jeq	Lbe0			| no, check for hard cases
	movl	sp@@(FR_HW+16),d1	| fault address is as given in frame
	jra	Lbe10			| thats it
Lbe0:
	btst	#4,sp@@(FR_HW+6)		| long (type B) stack frame?
	jne	Lbe4			| yes, go handle
	movl	sp@@(FR_HW+2),d1		| no, can use save PC
	btst	#14,d0			| FB set?
	jeq	Lbe3			| no, try FC
	addql	#4,d1			| yes, adjust address
	jra	Lbe10			| done
Lbe3:
	btst	#15,d0			| FC set?
	jeq	Lbe10			| no, done
	addql	#2,d1			| yes, adjust address
	jra	Lbe10			| done
Lbe4:
	movl	sp@@(FR_HW+36),d1	| long format, use stage B address
	btst	#15,d0			| FC set?
	jeq	Lbe10			| no, all done
	subql	#2,d1			| yes, adjust address
Lbe10:
	movl	d1,sp@@-			| push fault VA
	movl	d0,sp@@-			| and padded SSW
	movw	sp@@(FR_HW+8+6),d0	| get frame format/vector offset
	andw	#0x0FFF,d0		| clear out frame format
	cmpw	#12,d0			| address error vector?
	jeq	Lisaerr			| yes, go to it
	movl	d1,a0			| fault address
	movl	sp@@,d0			| function code from ssw
	btst	#8,d0			| data fault?
	jne	Lbe10a
	movql	#1,d0			| user program access FC
					| (we dont separate data/program)
	btst	#5,sp@@(FR_HW+8)		| supervisor mode?
	jeq	Lbe10a			| if no, done
	movql	#5,d0			| else supervisor program access
Lbe10a:
	ptestr	d0,a0@@,#7		| do a table search
	pmove	psr,sp@@			| save result
	movb	sp@@,d1
	btst	#2,d1			| invalid (incl. limit viol. and berr)?
	jeq	Lmightnotbemerr		| no -> wp check
	btst	#7,d1			| is it MMU table berr?
	jeq	Lismerr			| no, must be fast
	jra	Lisberr1		| real bus err needs not be fast.
Lmightnotbemerr:
	btst	#3,d1			| write protect bit set?
	jeq	Lisberr1		| no: must be bus error
	movl	sp@@,d0			| ssw into low word of d0
	andw	#0xc0,d0		| Write protect is set on page:
	cmpw	#0x40,d0		| was it read cycle?
	jeq	Lisberr1		| yes, was not WPE, must be bus err
Lismerr:
	movl	#T_MMUFLT,sp@@-		| show that we are an MMU fault
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
Lisaerr:
	movl	#T_ADDRERR,sp@@-		| mark address error
	jra	_ASM_LABEL(faultstkadj)	| and deal with it
Lisberr1:
	clrw	sp@@			| re-clear pad word
#endif
Lisberr:				| also used by M68040/60
	tstl	_nofault		| device probe?
	jeq	LberrIsProbe		| no, handle as usual
	movl	_nofault,sp@@-		| yes,
	jbsr	_longjmp		|  longjmp(nofault)
	/* NOTREACHED */
LberrIsProbe:
	movl	#T_BUSERR,sp@@-		| mark bus error
	jra	_ASM_LABEL(faultstkadj)	| and deal with it

/*
 * FP exceptions.
 */
_fpfline:
#if defined(M68040)
	cmpw	#0x202c,sp@@(6)		| format type 2?
	jne	_illinst		| no, not an FP emulation
#ifdef FPSP
	.globl fpsp_unimp
	jmp	fpsp_unimp		| yes, go handle it
#endif
#endif

#ifdef FPU_EMULATE
	.globl _fpemuli
_fpemuli:
	addql	#1,Lfpecnt
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save registers
	movql	#T_FPEMULI,d0		| denote as FP emulation trap
	jra	fault			| do it
#endif
	
_fpunsupp:
#if defined(M68040)
	cmpl	#MMU_68040,_mmutype	| 68040?
	jgt	_illinst		| no, treat as illinst
#ifdef FPSP
	.globl	fpsp_unsupp
	jmp	fpsp_unsupp		| yes, go handle it
#else
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save registers
	movql	#T_FPEMULD,d0		| denote as FP emulation trap
	jra	fault			| do it
#endif
#else
	jra	_illinst
#endif
/*
 * Handles all other FP coprocessor exceptions.
 * Note that since some FP exceptions generate mid-instruction frames
 * and may cause signal delivery, we need to test for stack adjustment
 * after the trap call.
 */
	.globl	_fpfault
_fpfault:
	clrl	sp@@-		| stack adjust count
	moveml	#0xFFFF,sp@@-	| save user registers
	movl	usp,a0		| and save
	movl	a0,sp@@(FR_SP)	|   the user stack pointer
	clrl	sp@@-		| no VA arg
	movl	_curpcb,a0	| current pcb
	lea	a0@@(PCB_FPCTX),a0 | address of FP savearea
	fsave	a0@@		| save state
#if defined(M68020) || defined(M68030)
#if defined(M68060) || defined(M68040)
	movb	_machineid+3,d0
	andb	#0x90,d0	| AMIGA_68060 | AMIGA_68040
	jne	Lfptnull	| XXX
#endif
	tstb	a0@@		| null state frame? 
	jeq	Lfptnull	| yes, safe
	clrw	d0		| no, need to tweak BIU
	movb	a0@@(1),d0	| get frame size
	bset	#3,a0@@(0,d0:w)	| set exc_pend bit of BIU
Lfptnull:
#endif
	fmovem	fpsr,sp@@-	| push fpsr as code argument
	frestore a0@@		| restore state
	movl	#T_FPERR,sp@@-	| push type arg
	jra	_ASM_LABEL(faultstkadj) | call trap and deal with stack cleanup

/*
 * Other exceptions only cause four and six word stack frame and require
 * no post-trap stack adjustment.
 */

	.globl	_straytrap
_badtrap:
	moveml	#0xC0C0,sp@@-		| save scratch regs
	movw	sp@@(22),sp@@-		| push exception vector info
	clrw	sp@@-
	movl	sp@@(22),sp@@-		| and PC
	jbsr	_straytrap		| report
	addql	#8,sp			| pop args
	moveml	sp@@+,#0x0303		| restore regs
	jra	rei			| all done

	.globl	_syscall
_trap0:
	clrl	sp@@-			| stack adjust count
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	movl	d0,sp@@-			| push syscall number
	jbsr	_syscall		| handle it
	addql	#4,sp			| pop syscall arg
	movl	sp@@(FR_SP),a0		| grab and restore
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| restore most registers
	addql	#8,sp			| pop SP and stack adjust
	jra	rei			| all done

/*
 * Our native 4.3 implementation uses trap 1 as sigreturn() and trap 2
 * as a breakpoint trap.
 */
_trap1:
	jra	sigreturn

_trap2:
	jra	_trace

/*
 * Trap 12 is the entry point for the cachectl "syscall"
 *	cachectl(command, addr, length)
 * command in d0, addr in a1, length in d1
 */
	.globl	_cachectl
_trap12:
	movl	d1,sp@@-			| push length
	movl	a1,sp@@-			| push addr
	movl	d0,sp@@-			| push command
	jbsr	_cachectl		| do it
	lea	sp@@(12),sp		| pop args
	jra	rei			| all done

/*
 * Trap 15 is used for:
 *	- KGDB traps
 *	- trace traps for SUN binaries (not fully supported yet)
 * We just pass it on and let trap() sort it all out
 */
_trap15:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
#ifdef KGDB
	moveq	#T_TRAP15,d0
	movw	sp@@(FR_HW),d1		| get PSW
	andw	#PSL_S,d1		| from user mode?
	jeq	fault			| yes, just a regular fault
	movl	d0,sp@@-
	.globl	_kgdb_trap_glue
	jbsr	_kgdb_trap_glue		| returns if no debugger
	addl	#4,sp
#endif
	moveq	#T_TRAP15,d0
	jra	fault

/*
 * Hit a breakpoint (trap 1 or 2) instruction.
 * Push the code and treat as a normal fault.
 */
_trace:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
#ifdef KGDB
	moveq	#T_TRACE,d0
	movw	sp@@(FR_HW),d1		| get SSW
	andw	#PSL_S,d1		| from user mode?
	jeq	fault			| no, regular fault
	movl	d0,sp@@-
	jbsr	_kgdb_trap_glue		| returns if no debugger
	addl	#4,sp
#endif
	moveq	#T_TRACE,d0
	jra	fault

/* Use common m68k sigreturn */
#include <m68k/m68k/sigreturn.s>

/*
 * Interrupt handlers.
 *
 *	Level 0:	Spurious: ignored.
 *	Level 1:	builtin-RS232 TBE, softint
 *	Level 2:	keyboard (CIA-A) + DMA + SCSI + External devices
 *	Level 3:	VBL
 *	Level 4:	audio (and deferred IPL 6 when LEV6_DEFER)
 *	Level 5:	builtin-RS232 RBF
 *	Level 6:	Clock (CIA-B-Timers), Floppy index pulse & Ext. devices
 *	Level 7:	Non-maskable: shouldn't be possible. ignore.
 */

/* Provide a generic interrupt dispatcher, only handle hardclock (int6)
 * and serial RBF (int5) specially, to improve performance
 */

	.globl	_intrhand
	.globl	_hardclock

_spurintr:
	addql	#1,_intrcnt+0
	addql	#1,_uvmexp+UVMEXP_INTRS
	jra	rei

#ifdef DRACO
	.globl _DraCoLev2intr
_DraCoLev2intr:
	moveml	#0xC0C0,sp@@-

	CIAAADDR(a0)
	movb	a0@@(CIAICR),d0		| read irc register (clears ints!)
	jge     Ldrintrcommon		| CIAA IR not set, go through isr chain
	movel	_draco_intpen,a0
|	andib	#4,a0@@
|XXX this would better be 
	bclr	#2,a0@@
	btst	#0,d0			| timerA interrupt?
	jeq	Ldraciaend

	lea	sp@@(16),a1		| get pointer to PS
	movl	a1,sp@@-			| push pointer to PS, PC
	
	movw	#PSL_HIGHIPL,sr		| hardclock at high IPL
	jbsr	_hardclock		| call generic clock int routine
	addql	#4,sp			| pop params
	addql	#1,_intrcnt+32		| add another system clock interrupt

Ldraciaend:
	moveml	sp@@+,#0x0303
	addql	#1,_uvmexp+UVMEXP_INTRS
	jra	rei

/* XXX on the DraCo rev. 4 or later, lev 1 is vectored here. */
	.globl _DraCoLev1intr
	.globl _amiga_clk_interval
_DraCoLev1intr:
	moveml	#0xC0C0,sp@@-
	movl	_draco_ioct,a0
	btst	#5,a0@@(7)
	jeq	Ldrintrcommon
	btst	#4,a0@@(7)	| this only happens during autoconfiguration,
	jeq	Ldrintrcommon	| so test last.
	movw	#PSL_HIGHIPL,sr	| run clock at high ipl
Ldrclockretry:
	lea	sp@@(16),a1	| get pointer to PS
	movl	a1,sp@@-		| push pointer to PS, PC
	jbsr	_hardclock
	addql	#4,sp		| pop params
	addql	#1,_intrcnt+32	| add another system clock interrupt

	movl	_draco_ioct,a0
	tstb	a0@@(9)		| latch timer value
	movw	a0@@(11),d0	| can't use movpw here, might be 68060
	movb	a0@@(13),d0
	addw	_amiga_clk_interval+2,d0
	movb	d0,a0@@(13)	| low byte: latch write value
	movw	d0,a0@@(11)	| ...and write it into timer
	tstw	d0		| already positive?
	jcs	Ldrclockretry	| we lost more than one tick, call us again.

	clrb	a0@@(9)		| reset timer irq

	moveml	sp@@+,#0x0303
	addql	#1,_uvmexp+UVMEXP_INTRS
	jra	rei

/* XXX on the DraCo, lev 1, 3, 4, 5 and 6 are vectored here by initcpu() */
	.globl _DraCoIntr
_DraCoIntr:
	moveml  #0xC0C0,sp@@-
Ldrintrcommon:
	lea	Drintrcnt-4,a0
	movw	sp@@(22),d0		| use vector offset
	andw	#0xfff,d0		|   sans frame type
	addql	#1,a0@@(-0x60,d0:w)	|     to increment apropos counter
	movw	sr,sp@@-			| push current SR value
	clrw	sp@@-			|    padded to longword
	jbsr	_intrhand		| handle interrupt
	addql	#4,sp			| pop SR
	moveml	sp@@+,#0x0303
	addql	#1,_uvmexp+UVMEXP_INTRS
	jra	rei
#endif
	

_lev5intr:
	moveml	d0/d1/a0/a1,sp@@-
#if NSER > 0
	jsr	_ser_fastint
#else
	INTREQWADDR(a0)
	movew	#INTF_RBF,a0@@		| clear RBF interrupt in intreq
#endif
	moveml	sp@@+,d0/d1/a0/a1
	addql	#1,_intrcnt+20
	addql	#1,_uvmexp+UVMEXP_INTRS
	jra	rei

_lev1intr:
_lev2intr:
_lev3intr:
#ifndef LEV6_DEFER
_lev4intr:
#endif
	moveml	d0-d1/a0-a1,sp@@-
Lintrcommon:
	lea	_intrcnt,a0
	movw	sp@@(22),d0		| use vector offset
	andw	#0xfff,d0		|   sans frame type
	addql	#1,a0@@(-0x60,d0:w)	|     to increment apropos counter
	movw	sr,sp@@-			| push current SR value
	clrw	sp@@-			|    padded to longword
	jbsr	_intrhand		| handle interrupt
	addql	#4,sp			| pop SR
	moveml	sp@@+,d0-d1/a0-a1
	addql	#1,_uvmexp+UVMEXP_INTRS
	jra	rei

| Both IPL_REMAP_1 and IPL_REMAP_2 are experimental interruptsystems from
| Niklas Hallqvist <niklas@@appli.se>, checkout amiga/amiga/README.ints for
| details...
#ifdef IPL_REMAP_1
	.globl	_isr_exter_ipl
	.globl	_isr_exter_highipl
	.globl	_isr_exter_lowipl
#endif
#if defined(IPL_REMAP_1) || defined(IPL_REMAP_2)
	.globl	_hardclock_frame
#endif
	
/* XXX used to be ifndef DRACO; vector will be overwritten by initcpu() */

_lev6intr:
#ifndef IPL_REMAP_1
#ifdef LEV6_DEFER
	/*
	 * cause a level 4 interrupt (AUD3) to occur as soon
	 * as we return. Block generation of level 6 ints until
	 * we have dealt with this one.
	 */
	moveml	d0/a0,sp@@-
	INTREQRADDR(a0)
	movew	a0@@,d0
	btst	#INTB_EXTER,d0
	jeq	Llev6spur
	INTREQWADDR(a0)
	movew	#INTF_SETCLR+INTF_AUD3,a0@@
	INTENAWADDR(a0)
	movew	#INTF_EXTER,a0@@
	movew	#INTF_SETCLR+INTF_AUD3,a0@@	| make sure THIS one is ok...
	moveml	sp@@+,d0/a0
	rte
Llev6spur:
	addql	#1,_intrcnt+36		| count spurious level 6 interrupts
	moveml	sp@@+,d0/a0
	rte

_lev4intr:
_fake_lev6intr:
#endif
	moveml	d0-d1/a0-a1,sp@@-
#ifdef LEV6_DEFER
	/*
	 * check for fake level 6
	 */
	INTREQRADDR(a0)
	movew	a0@@,d0
	btst	#INTB_EXTER,d0
	jeq	Lintrcommon		| if EXTER not pending, handle normally
#endif

	CIABADDR(a0)
	movb	a0@@(CIAICR),d0		| read irc register (clears ints!)
	jge	Lchkexter		| CIAB IR not set, go through isr chain
	INTREQWADDR(a0)
#ifndef LEV6_DEFER
	movew	#INTF_EXTER,a0@@		| clear EXTER interrupt in intreq
#else
	movew	#INTF_EXTER+INTF_AUD3,a0@@ | clear EXTER & AUD3 in intreq
	INTENAWADDR(a0)
	movew	#INTF_SETCLR+INTF_EXTER,a0@@ | reenable EXTER interrupts
#endif
	btst	#0,d0			| timerA interrupt?
	jeq     Ltstciab4		| no
	movl	d0,sp@@-			| push CIAB interrupt flags
	lea	sp@@(20),a1		| get pointer to PS
	movl	a1,sp@@-			| push pointer to PS, PC
	jbsr	_hardclock		| call generic clock int routine
	addql	#4,sp			| pop params
	addql	#1,_intrcnt+32		| add another system clock interrupt
	movl	sp@@+,d0			| pop interrupt flags
Ltstciab4:
#if NFD > 0
	btst	#4,d0			| FLG (dskindex) interrupt?
	jeq	Lskipciab		| no
	jbsr	_fdidxintr		| tell floppy driver we got it
Lskipciab:
#endif
| other ciab interrupts?
Llev6done:
	moveml	sp@@+,d0-d1/a0-a1	| restore scratch regs
	addql	#1,_uvmexp+UVMEXP_INTRS
	jra	rei			| all done [can we do rte here?]
Lchkexter:
| check to see if EXTER request is really set?
	movl	_isr_exter,a0		| get head of EXTER isr chain
Lnxtexter:
	movl	a0,d0			| test if any more entries
	jeq	Lexterdone		| (spurious interrupt?)
	movl	a0,sp@@-			| save isr pointer
	movl	a0@@(ISR_ARG),sp@@-
	movl	a0@@(ISR_INTR),a0
	jsr	a0@@			| call isr handler
	addql	#4,sp
	movl	sp@@+,a0			| restore isr pointer
	movl	a0@@(ISR_FORW),a0	| get next pointer
	tstl	d0			| did handler process the int?
	jeq	Lnxtexter		| no, try next
Lexterdone:
	INTREQWADDR(a0)
#ifndef LEV6_DEFER
	movew	#INTF_EXTER,a0@@		| clear EXTER interrupt
#else
	movew	#INTF_EXTER+INTF_AUD3,a0@@ | clear EXTER & AUD3 interrupt
	INTENAWADDR(a0)
	movew	#INTF_SETCLR+INTF_EXTER,a0@@ | reenable EXTER interrupts
#endif
	addql	#1,_intrcnt+24		| count EXTER interrupts
	jra	Llev6done
/* XXX endif DRACO used to be here */

#else /* IPL_REMAP_1 */

	moveml	d0-d1/a0-a1,sp@@-	| save clobbered regs
#if 0
	INTREQRADDR(a0)
	movew	a0@@,d0
	btst	#INTB_EXTER,d0		| check for non-EXTER INT6 ints
	jne	Lexter
	| register spurious int6 interrupt
Lexter:	
#endif
	moveal	#_hardclock_frame,a0	| store the clockframe
	movel	sp@@(16),a0@@+		| where hardclock will find it
	movel	sp@@(20),a0@@
	INTENAWADDR(a0)
	movew	#INTF_EXTER,a0@@		| disable EXTER ints
	movew	sp@@(16),d0		| get PS-word
	andl	#PSL_IPL,d0		| only IPL is interesting
	orw	#PSL_S,d0		| note we're in kernel mode
	movel	d0,sp@@-
	movel	_isr_exter_highipl,sp@@-	| start out at the highest IPL
	jbsr	_walk_ipls		| run all ISRs at appropriate IPLs
	addql	#8,sp
	addql	#1,_intrcnt+24		| add another exter interrupt
	moveml	sp@@+,d0-d1/a0-a1	| restore scratch regs
	addql	#1,_uvmexp+UVMEXP_INTRS
	jra	Lastchk			| all done [can we do rte here?]
#endif
	
_lev7intr:
	addql	#1,_intrcnt+28
	/*
	 * some amiga zorro2 boards seem to generate spurious NMIs. Best
	 * thing to do is to return as quick as possible. That's the
	 * reason why I do RTE here instead of jra rei.
	 */
	rte				| all done

/*
 * Emulation of VAX REI instruction.
 *
 * This code deals with checking for and servicing ASTs
 * (profiling, scheduling) and software interrupts (network, softclock).
 * We check for ASTs first, just like the VAX.  To avoid excess overhead
 * the T_ASTFLT handling code will also check for software interrupts so we
 * do not have to do it here.
 * do not have to do it here.  After identifing that we need an AST we
 * drop the IPL to allow device interrupts.
 *
 * This code is complicated by the fact that sendsig may have been called
 * necessitating a stack cleanup.  A cleanup should only be needed at this
 * point for coprocessor mid-instruction frames (type 9), but we also test
 * for bus error frames (type 10 and 11).
 */
	.globl	_astpending
	.globl	rei
	.globl	_rei
_rei:
rei:
#ifdef DEBUG
	tstl	_panicstr		| have we paniced?
	jne	Ldorte			| yes, do not make matters worse
#endif
#ifdef IPL_REMAP_1
	tstl	_isr_exter_ipl		| IPL lowering in process?
	jeq	Lastchk			| no, go on to check for ASTs
	moveml	d0-d1/a0-a1,sp@@-	| save scratch regs
	movw	sp@@(16),d0		| get PS
	andl	#PSL_IPL,d0		| we're only interested in the IPL
	orw	#PSL_S,d0		| note that we're in kernel mode
	movel	d0,sp@@-
	movel	_isr_exter_ipl,sp@@-	| start where we left last walk_ipls
	jbsr	_walk_ipls		| run needed ISRs
	addql	#8,sp			| pop params
	moveml	sp@@+,d0-d1/a0-a1	| restore scratch regs
Lastchk:	
#endif
	tstl	_astpending		| AST pending?
	jeq	Ldorte			| no, done
Lrei1:
	btst	#5,sp@@			| yes, are we returning to user mode?
	jne	Ldorte			| no, done
	movw	#PSL_LOWIPL,sr		| lower SPL
	clrl	sp@@-			| stack adjust
	moveml	#0xFFFF,sp@@-		| save all registers
	movl	usp,a1			| including
	movl	a1,sp@@(FR_SP)		|    the users SP
	clrl	sp@@-			| VA == none
	clrl	sp@@-			| code == none
	movl	#T_ASTFLT,sp@@-		| type == async system trap
	jbsr	_trap			| go handle it
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore user SP
	movl	a0,usp			|   from save area
	movw	sp@@(FR_ADJ),d0		| need to adjust stack?
	jne	Laststkadj		| yes, go to it
	moveml	sp@@+,#0x7FFF		| no, restore most user regs
	addql	#8,sp			| toss SP and stack adjust
	rte				| and do real RTE
Laststkadj:
	lea	sp@@(FR_HW),a1		| pointer to HW frame
	addql	#8,a1			| source pointer
	movl	a1,a0			| source
	addw	d0,a0			|  + hole size = dest pointer
	movl	a1@@-,a0@@-		| copy
	movl	a1@@-,a0@@-		|  8 bytes
	movl	a0,sp@@(FR_SP)		| new SSP
	moveml	sp@@+,#0x7FFF		| restore user registers
	movl	sp@@,sp			| and our SP
Ldorte:
|	moveml	a0/a1/d0/d1,sp@@-
|	pea	pc@@(Ldoinrte)
|	jsr	_printf
|	addql	#4,sp
|	moveml	sp@@+,a0/a1/d0/d1
	rte				| real return
|Ldoinrte:
|	.asciz	"Doing RTE.\n"
|	.even

/*
 * Kernel access to the current processes kernel stack is via a fixed
 * virtual address.  It is at the same address as in the users VA space.
 */
	.data
_esym:	.long	0
	.globl	_esym


/*
 * Initialization
 *
 * A5 contains physical load point from boot
 * exceptions vector thru our table, that's bad.. just hope nothing exceptional
 * happens till we had time to initialize ourselves..
 */
	.comm	_lowram,4

#define	RELOC(var, ar)	\
	lea	var,ar;	\
	addl	a5,ar

	.text
	.globl	_eclockfreq
	.globl	_edata
	.globl	_etext,_end
	.globl	start

	| XXX should be a symbol?
	| 2: needs a4 = esym
	| 3: no chipmem requirement
	|    bootinfo data structure

	.word	0
	.word	0x0003			| loadbsd version required
start:
	lea	pc@@(L_base),a5		| initialize relocation register

	movw	#PSL_HIGHIPL,sr		| no interrupts
	RELOC(tmpstk,a6)
	movl	a6,sp			| give ourselves a temporary stack

	| save the passed parameters. "prepass" them on the stack for
	| later catch by _start_c
	movl	a2,sp@@-			| pass sync inhibit flags
	movl	d3,sp@@-			| pass AGA mode
	movl	a4,sp@@-			| pass address of _esym
	movl	d1,sp@@-			| pass chipmem-size
	movl	d0,sp@@-			| pass fastmem-size
	movl	a0,sp@@-			| pass fastmem_start
	movl	d5,sp@@-			| pass machine id

	/*
	 * initialize some hw addresses to their physical address 
	 * for early running
	 */
#ifdef DRACO
	/*
	 * this is already dynamically done on DraCo
	 */
	cmpb	#0x7D,sp@@
	jne	LisAmiga1
| debug code:
| we should need about 1 uSec for the loop.
| we dont need the AGA mode register.
	movel	#100000,d3
LisDraco0:
#ifdef DEBUG_KERNEL_START
	movb	#0,0x200003c8
	movb	#00,0x200003c9
	movb	#40,0x200003c9
	movb	#00,0x200003c9
|XXX:
	movb	#0,0x200003c8
	movb	#40,0x200003c9
	movb	#00,0x200003c9
	movb	#00,0x200003c9
	subql	#1,d3
	jcc	LisDraco0
#endif

	RELOC(_chipmem_start, a0)
	movl	#0,a0@@

	RELOC(_CIAAbase, a0)
	movl	#0x2801001, a0@@
	RELOC(_CIABbase, a0)
	movl	#0x2800000, a0@@

	/* XXXX more to come here; as we need it */

	jra	LisDraco1
LisAmiga1:
#endif
	RELOC(_chipmem_start, a0)
	movl	#0x400,a0@@
	RELOC(_CIAAbase, a0)
	movl	#0xbfe001,a0@@
	RELOC(_CIABbase, a0)
	movl	#0xbfd000,a0@@
	RELOC(_CUSTOMbase, a0)
	movl	#0xdff000,a0@@

#ifdef DRACO
LisDraco1:
#endif
	/*
	 * initialize the timer frequency
	 */
	RELOC(_eclockfreq, a0)
	movl	d4,a0@@

	RELOC(_mmutype, a0)
	RELOC(_cputype, a1)
	movl	#AMIGA_68030,d1		| 68030 Attn flag from exec
	andl	d5,d1
	jeq	Ltestfor020
	movl	#MMU_68030,a0@@		| assume 020 means 851
	movl	#CPU_68030,a1@@		| assume 020 means 851
	jra	Lsetcpu040		| skip to init.
Ltestfor020:
	movl	#AMIGA_68020,d1		| 68020 Attn flag from exec
	andl	d5,d1
	jeq	Lsetcpu040
	movl	#MMU_68851,a0@@
	movl	#CPU_68020,a1@@
Lsetcpu040:
	movl	#CACHE_OFF,d0		| 68020/030 cache
	movl	#AMIGA_68040,d1
	andl	d1,d5
	jeq	Lstartnot040		| it is not 68040
	movl	#MMU_68040,a0@@		| same as hp300 for compat
	movl	#CPU_68040,a1@@
	.word	0xf4f8			| cpusha bc - push and inval. caches
	movl	#CACHE40_OFF,d0		| 68040 cache disable
#ifndef BB060STUPIDROM
	btst	#7,sp@@(3)
	jeq	Lstartnot040
	movl	#MMU_68060,a0@@
	movl	#CPU_68060,a1@@		| set cputype
	orl	#IC60_CABC,d0		| XXX and clear all 060 branch cache
#else
	movc	d0,cacr
	bset	#30,d0			| not allocate data cache bit
	movc	d0,cacr			| does it stick?
	movc	cacr,d0
	tstl	d0
	jeq	Lstartnot040
	bset	#7,sp@@(3)		| note it is '60 family in machineid
	movl	#MMU_68060,a0@@
	movl	#CPU_68060,a1@@		| and in the cputype
	orl	#IC60_CABC,d0		| XXX and clear all 060 branch cache 
	.word	0x4e7a,0x1808		| movc	pcr,d1
	swap	d1
	cmpw	#0x430,d1		
	jne	Lstartnot040		| but no FPU
	bset	#6,sp@@(3)		| yes, we have FPU, note that
	swap	d1
	bclr	#1,d1			| ... and switch it on.
	.word	0x4e7b,0x1808		| movc	d1,pcr
#endif
Lstartnot040:
	movc	d0,cacr			| clear and disable on-chip cache(s)
	movl	#_vectab,a0
	movc	a0,vbr

/* initialize source/destination control registers for movs */
	moveq	#FC_USERD,d0		| user space
	movc	d0,sfc			|   as source
	movc	d0,dfc			|   and destination of transfers

/* let the C function initialize everything and enable the MMU */
	RELOC(_start_c, a0)
	jbsr	a0@@
	addl	#28,sp
	jmp	Lunshadow

Lunshadow:

	lea	tmpstk,sp		| give ourselves a temporary stack
	jbsr	_start_c_cleanup

/* set kernel stack, user SP, and initial pcb */
	movl	_proc0paddr,a1		| proc0 kernel stack
	lea	a1@@(USPACE),sp	| set kernel stack to end of area
	movl	#USRSTACK-4,a2
	movl	a2,usp			| init user SP
	movl	a2,a1@@(PCB_USP)		| and save it
	movl	a1,_curpcb		| proc0 is running
	clrw	a1@@(PCB_FLAGS)		| clear flags
	clrl	a1@@(PCB_FPCTX)		| ensure null FP context
|WRONG!	movl	a1,sp@@-
|	pea	a1@@(PCB_FPCTX)
|	jbsr	_m68881_restore		| restore it (does not kill a1)
|	addql	#4,sp

/* flush TLB and turn on caches */
	jbsr	_TBIA			| invalidate TLB
#ifndef APOLLO	/* XXX: unknown reason at the moment. */
	movl	#CACHE_ON,d0
	tstl	d5
	jeq	Lcacheon
| is this needed? MLH
	.word	0xf4f8			| cpusha bc - push & invalidate caches
	movl	#CACHE40_ON,d0
#ifdef M68060
	cmpl	#MMU_68060,_mmutype
	jne	Lcacheon
	movl	#CACHE60_ON,d0
#endif
Lcacheon:
	movc	d0,cacr			| clear cache(s)
#else 	/* APOLLO */
        movl    #0x00808000,d0
	movc    d0,cacr
#endif
/* final setup for C code */

	movw	#PSL_LOWIPL,sr		| lower SPL

	movl	d7,_boothowto		| save reboot flags
/*
	movl	d6,_bootdev		|   and boot device
*/
/*
 * Create a fake exception frame that returns to user mode,
 * make space for the rest of a fake saved register set, and
 * pass the first available RAM and a pointer to the register
 * set to "main()".  "main()" will do an "execve()" using that
 * stack frame.
 * When "main()" returns, we're running in process 1 and have
 * successfully executed the "execve()".  We load up the registers from
 * that set; the "rte" loads the PC and PSR, which jumps to "init".
 */
	.globl	_proc0
  	clrw	sp@@-			| vector offset/frame type
	clrl	sp@@-			| PC - filled in by "execve"
  	movw	#PSL_USER,sp@@-		| in user mode
	clrl	sp@@-			| stack adjust count
	lea	sp@@(-64),sp		| construct space for D0-D7/A0-A7
	lea	_proc0,a0		| proc0 in a0
	movl	sp,a0@@(P_MD_REGS)	| save frame for proc0
	movl	usp,a1
	movl	a1,sp@@(FR_SP)		| save user stack pointer in frame
	pea	sp@@			| addr of space for D0 

	jbsr	_main			| main(firstaddr, r0)
	addql	#4,sp			| pop args

	cmpl	#MMU_68040,_mmutype	| 68040?
	jgt	Lnoflush		| no, skip
	.word	0xf478			| cpusha dc
	.word	0xf498			| cinva ic
#ifdef M68060
| XXX dont need these; the cinva ic also clears the branch cache.
|	cmpl	#MMU_68060,_mmutype
|	jne	Lnoflush
|	movc	cacr,d0
|	orl	#IC60_CUBC,d0
|	movc	d0,cacr
#endif
Lnoflush:
	movl	sp@@(FR_SP),a0		| grab and load
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| load most registers (all but SSP)
	addql	#8,sp			| pop SSP and stack adjust count
  	rte

/*
 * proc_trampoline call function in register a2 with a3 as an arg
 * and then rei.
 */
	.globl	_proc_trampoline
_proc_trampoline:
	movl	a3,sp@@-			| push function arg (curproc)
	jbsr	a2@@			| call function
	addql	#4,sp			| pop arg
	movl	sp@@(FR_SP),a0		| usp to a0
	movl	a0,usp			| setup user stack pointer
	moveml	sp@@+,d0-d7/a0-a6	| restore all but sp
	addql	#8,sp			| pop sp and stack adjust
	jra	rei			| all done

/*
 * Use common m68k sigcode.
 */
#include <m68k/m68k/sigcode.s>

/*
 * Primitives
 */
#include <m68k/m68k/support.s>

	.globl	_whichqs,_qs,_panic
	.globl	_curproc
	.comm	_want_resched,4

/*
 * Use common m68k process manipulation routines.
 */
#include <m68k/m68k/proc_subr.s>

Lsw0:
 	.asciz	"cpu_switch"
	.even

	.globl	_curpcb
	.globl	_masterpaddr	| XXX compatibility (debuggers)
	.data
_masterpaddr:			| XXX compatibility (debuggers)
_curpcb:
	.long	0
pcbflag:
	.byte	0		| copy of pcb_flags low byte
	.align	2
	.comm	nullpcb,SIZEOF_PCB
	.text

/*
 * At exit of a process, do a switch for the last time.
 * Switch to a safe stack and PCB, and deallocate the process's user area.
 */
ENTRY(switch_exit)
	movl	sp@@(4),a0
	movl	#nullpcb,_curpcb	| save state into garbage pcb
	lea	tmpstk,sp		| goto a tmp stack

        /* Schedule the vmspace and stack to be freed. */
	movl    a0,sp@@-                 | exit2(p)
	jbsr    _C_LABEL(exit2)
	lea     sp@@(4),sp               | pop args

	jra	_cpu_switch

/*
 * When no processes are on the runq, Swtch branches to idle
 * to wait for something to come ready.
 */
	.globl	Idle
Lidle:
	stop	#PSL_LOWIPL
Idle:
idle:
	movw	#PSL_HIGHIPL,sr
	tstl	_whichqs
	jeq	Lidle
	movw	#PSL_LOWIPL,sr
	jra	Lsw1

Lbadsw:
	movl	#Lsw0,sp@@-
	jbsr	_panic
	/*NOTREACHED*/

/*
 * Cpu_switch()
 *
 * NOTE: On the mc68851 (318/319/330) we attempt to avoid flushing the
 * entire ATC.  The effort involved in selective flushing may not be
 * worth it, maybe we should just flush the whole thing?
 *
 * NOTE 2: With the new VM layout we now no longer know if an inactive
 * user's PTEs have been changed (formerly denoted by the SPTECHG p_flag
 * bit).  For now, we just always flush the full ATC.
 */
ENTRY(cpu_switch)
	movl	_curpcb,a0		| current pcb
	movw	sr,a0@@(PCB_PS)		| save sr before changing ipl

#ifdef notyet
	movl	_curproc,sp@@-		| remember last proc running
#endif
	clrl	_curproc
Lsw1:
	/*
	 * Find the highest-priority queue that isn't empty,
	 * then take the first proc from that queue.
	 */
	clrl	d0
	lea	_whichqs,a0
	movl	a0@@,d1
Lswchk:
	btst	d0,d1
	jne	Lswfnd
	addqb	#1,d0
	cmpb	#32,d0
	jne	Lswchk
	jra	idle
Lswfnd:
	movw	#PSL_HIGHIPL,sr		| lock out interrupts
	movl	a0@@,d1			| and check again...
	bclr	d0,d1
	jeq	Lsw1			| proc moved, rescan
	movl	d1,a0@@			| update whichqs
	moveq	#1,d1			| double check for higher priority
	lsll	d0,d1			| process (which may have snuck in
	subql	#1,d1			| while we were finding this one)
	andl	a0@@,d1
	jeq	Lswok			| no one got in, continue
	movl	a0@@,d1
	bset	d0,d1			| otherwise put this one back
	movl	d1,a0@@
	jra	Lsw1			| and rescan
Lswok:
	movl	d0,d1
	lslb	#3,d1			| convert queue number to index
	addl	#_qs,d1			| locate queue (q)
	movl	d1,a1
	cmpl	a1@@(P_FORW),a1		| anyone on queue?
	jeq	Lbadsw			| no, panic
	movl	a1@@(P_FORW),a0			| p = q->p_forw
	movl	a0@@(P_FORW),a1@@(P_FORW)		| q->p_forw = p->p_forw
	movl	a0@@(P_FORW),a1			| q = p->p_forw
	movl	a0@@(P_BACK),a1@@(P_BACK)	| q->p_back = p->p_back
	cmpl	a0@@(P_FORW),d1		| anyone left on queue?
	jeq	Lsw2			| no, skip
	movl	_whichqs,d1
	bset	d0,d1			| yes, reset bit
	movl	d1,_whichqs
Lsw2:
	movl	a0,_curproc
	clrl	_want_resched
#ifdef notyet
	movl	sp@@+,a1
	cmpl	a0,a1			| switching to same proc?
	jeq	Lswdone			| yes, skip save and restore
#endif
	/*
	 * Save state of previous process in its pcb.
	 */
	movl	_curpcb,a1
	moveml	#0xFCFC,a1@@(PCB_REGS)	| save non-scratch registers
	movl	usp,a2			| grab USP (a2 has been saved)
	movl	a2,a1@@(PCB_USP)		| and save it
	movl	_CMAP2,a1@@(PCB_CMAP2)	| save temporary map PTE
#ifdef FPU_EMULATE
	tstl	_fputype		| do we have any FPU?
	jeq	Lswnofpsave		| no, dont save
#endif
	lea	a1@@(PCB_FPCTX),a2	| pointer to FP save area
	fsave	a2@@			| save FP state
#if defined(M68020) || defined(M68030) || defined(M68040)
#ifdef M68060
	cmpl	#MMU_68060,_mmutype	| is 68060?
	jeq	Lsavfp60
#endif
	tstb	a2@@			| null state frame?
	jeq	Lswnofpsave		| yes, all done
	fmovem	fp0-fp7,a2@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a2@@(FPF_FPCR)	| save FP control registers
#ifdef M68060
	jra	Lswnofpsave
#endif
#endif
#ifdef M68060
Lsavfp60:
	tstb	a2@@(2)			| null state frame?
	jeq	Lswnofpsave		| yes, all done
	fmovem	fp0-fp7,a2@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr,a2@@(FPF_FPCR)	| save FP control registers
	fmovem	fpsr,a2@@(FPF_FPSR)
	fmovem	fpi,a2@@(FPF_FPI)
#endif
Lswnofpsave:

#ifdef DIAGNOSTIC
	tstl	a0@@(P_WCHAN)
	jne	Lbadsw
	cmpb	#SRUN,a0@@(P_STAT)
	jne	Lbadsw
#endif
	clrl	a0@@(P_BACK)		| clear back link
	movl	a0@@(P_ADDR),a1		| get p_addr
	movl	a1,_curpcb
	movb	a1@@(PCB_FLAGS+1),pcbflag | copy of pcb_flags low byte

	/*
	 * Activate process's address space.
	 * XXX Should remember the last USTP value loaded, and call this
	 * XXX only if it has changed.
	 */
	pea	a0@@			| push proc
	jbsr	_pmap_activate		| pmap_activate(p)
	addql	#4,sp
	movl	_curpcb,a1		| restore p_addr

	lea	tmpstk,sp		| now goto a tmp stack for NMI

	movl	a1@@(PCB_CMAP2),_CMAP2	| reload tmp map
	moveml	a1@@(PCB_REGS),#0xFCFC	| and registers
	movl	a1@@(PCB_USP),a0
	movl	a0,usp			| and USP
#ifdef FPU_EMULATE
	tstl	_fputype		| do we _have_ any fpu?
	jne	Lresnonofpatall
	movw	a1@@(PCB_PS),sr		| no, restore PS
	moveq	#1,d0			| return 1 (for alternate returns)
	rts
Lresnonofpatall:
#endif
	lea	a1@@(PCB_FPCTX),a0	| pointer to FP save area
#if defined(M68020) || defined(M68030) || defined(M68040)
#ifdef M68060
	cmpl	#MMU_68060,_mmutype
	jeq	Lresfp60rest1
#endif
	tstb	a0@@			| null state frame?
	jeq	Lresfprest2		| yes, easy
	fmovem	a0@@(FPF_FPCR),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
Lresfprest2:
	frestore a0@@			| restore state
	movw	a1@@(PCB_PS),sr		| no, restore PS
	moveq	#1,d0			| return 1 (for alternate returns)
	rts
#endif

#ifdef M68060
Lresfp60rest1:
	tstb	a0@@(2)			| null state frame?
	jeq	Lresfp60rest2		| yes, easy
	fmovem	a0@@(FPF_FPCR),fpcr	| restore FP control registers
	fmovem	a0@@(FPF_FPSR),fpsr
	fmovem	a0@@(FPF_FPI),fpi
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
Lresfp60rest2:
	frestore a0@@			| restore state
	movw	a1@@(PCB_PS),sr		| no, restore PS
	moveq	#1,d0			| return 1 (for alternate returns)
	rts
#endif

/*
 * savectx(pcb)
 * Update pcb, saving current processor state
 */
ENTRY(savectx)
	movl	sp@@(4),a1
	movw	sr,a1@@(PCB_PS)
	movl	usp,a0			| grab USP
	movl	a0,a1@@(PCB_USP)		| and save it
	moveml	#0xFCFC,a1@@(PCB_REGS)	| save non-scratch registers
	movl	_CMAP2,a1@@(PCB_CMAP2)	| save temporary map PTE
#ifdef FPU_EMULATE
	tstl	_fputype
	jeq	Lsavedone
#endif
	lea	a1@@(PCB_FPCTX),a0	| pointer to FP save area
	fsave	a0@@			| save FP state
#if defined(M68020) || defined(M68030) || defined(M68040)
#ifdef M68060
	cmpl	#MMU_68060,_mmutype
	jeq	Lsavctx60
#endif
	tstb	a0@@			| null state frame?
	jeq	Lsavedone		| yes, all done
	fmovem	fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a0@@(FPF_FPCR)	| save FP control registers
#ifdef	M68060
	moveq	#0,d0
	rts
#endif
#endif
#ifdef	M68060
Lsavctx60:
	tstb	a0@@(2)
	jeq	Lsavedone
	fmovem	fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr,a0@@(FPF_FPCR)	| save FP control registers
	fmovem	fpsr,a0@@(FPF_FPSR)
	fmovem	fpi,a0@@(FPF_FPI)
#endif
Lsavedone:
	moveq	#0,d0			| return 0
	rts

/*
 * Copy 1 relocation unit (NBPG bytes)
 * from user virtual address to physical address
 */
ENTRY(copyseg)
	movl	_curpcb,a1			| current pcb
	movl	#Lcpydone,a1@@(PCB_ONFAULT)	| where to return to on a fault
	movl	sp@@(8),d0			| destination page number
	moveq	#PGSHIFT,d1
	lsll	d1,d0				| convert to address
	orl	#PG_CI+PG_RW+PG_V,d0		| make sure valid and writable
	movl	_CMAP2,a0
	movl	_CADDR2,sp@@-			| destination kernel VA
	movl	d0,a0@@				| load in page table
	jbsr	_TBIS				| invalidate any old mapping
	addql	#4,sp
	movl	_CADDR2,a1			| destination addr
	movl	sp@@(4),a0			| source addr
	movl	#NBPG/4-1,d0			| count
Lcpyloop:
	movsl	a0@@+,d1				| read longword
	movl	d1,a1@@+				| write longword
	dbf	d0,Lcpyloop			| continue until done
Lcpydone:
	movl	_curpcb,a1			| current pcb
	clrl	a1@@(PCB_ONFAULT) 		| clear error catch
	rts

/*
 * Copy 1 relocation unit (NBPG bytes)
 * from physical address to physical address
 */
ENTRY(physcopyseg)
	movl	sp@@(4),d0			| source page number
	moveq	#PGSHIFT,d1
	lsll	d1,d0				| convert to address
	orl	#PG_CI+PG_RW+PG_V,d0		| make sure valid and writable
	movl	_CMAP1,a0
	movl	d0,a0@@				| load in page table
	movl	_CADDR1,sp@@-			| destination kernel VA
	jbsr	_TBIS				| invalidate any old mapping
	addql	#4,sp

	movl	sp@@(8),d0			| destination page number
	moveq	#PGSHIFT,d1
	lsll	d1,d0				| convert to address
	orl	#PG_CI+PG_RW+PG_V,d0		| make sure valid and writable
	movl	_CMAP2,a0
	movl	d0,a0@@				| load in page table
	movl	_CADDR2,sp@@-			| destination kernel VA
	jbsr	_TBIS				| invalidate any old mapping
	addql	#4,sp

	movl	_CADDR1,a0			| source addr
	movl	_CADDR2,a1			| destination addr
	movl	#NBPG/4-1,d0			| count
Lpcpy:
	movl	a0@@+,a1@@+			| copy longword
	dbf	d0,Lpcpy			| continue until done
	rts

/*
 * zero out physical memory
 * specified in relocation units (NBPG bytes)
 */
ENTRY(clearseg)
	movl	sp@@(4),d0			| destination page number
	moveq	#PGSHIFT,d1
	lsll	d1,d0				| convert to address
	orl	#PG_CI+PG_RW+PG_V,d0		| make sure valid and writable
	movl	_CMAP1,a0
	movl	_CADDR1,sp@@-			| destination kernel VA
	movl	d0,a0@@				| load in page map
	jbsr	_TBIS				| invalidate any old mapping
	addql	#4,sp
	movl	_CADDR1,a1			| destination addr
	movl	#NBPG/4-1,d0			| count
/* simple clear loop is fastest on 68020 */
Lclrloop:
	clrl	a1@@+				| clear a longword
	dbf	d0,Lclrloop			| continue til done
	rts

/*
 * Invalidate entire TLB.
 */
ENTRY(TBIA)
__TBIA:
	cmpl	#MMU_68040,_mmutype
	jeq	Ltbia040
	pflusha				| flush entire TLB
	tstl	_mmutype
	jpl	Lmc68851a		| 68851 implies no d-cache
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip d-cache
Lmc68851a:
	rts
Ltbia040:
	.word	0xf518			| pflusha
#ifdef M68060
	cmpl	#MMU_68060,_mmutype
	jne	Ltbiano60
	movc	cacr,d0
	orl	#IC60_CABC,d0		| and clear all branch cache entries
	movc	d0,cacr
#endif
Ltbiano60:
	rts

/*
 * Invalidate any TLB entry for given VA (TB Invalidate Single)
 */
ENTRY(TBIS)
#ifdef DEBUG
	tstl	fulltflush		| being conservative?
	jne	__TBIA			| yes, flush entire TLB
#endif
	movl	sp@@(4),a0		| get addr to flush
	cmpl	#MMU_68040,_mmutype
	jle	Ltbis040
	tstl	_mmutype
	jpl	Lmc68851b		| is 68851?
	pflush	#0,#0,a0@@		| flush address from both sides
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip data cache
	rts
Lmc68851b:
	pflushs	#0,#0,a0@@		| flush address from both sides
	rts
Ltbis040:
	moveq	#FC_SUPERD,d0		| select supervisor
	movc	d0,dfc
	.word	0xf508			| pflush a0@@
	moveq	#FC_USERD,d0		| select user
	movc	d0,dfc
	.word	0xf508			| pflush a0@@
#ifdef M68060
	cmpl	#MMU_68060,_mmutype
	jne	Ltbisno60
	movc	cacr,d0
	orl	#IC60_CABC,d0		| and clear all branch cache entries
	movc	d0,cacr
Ltbisno60:
#endif
	rts

/*
 * Invalidate supervisor side of TLB
 */
ENTRY(TBIAS)
#ifdef DEBUG
	tstl	fulltflush		| being conservative?
	jne	__TBIA			| yes, flush everything
#endif
	cmpl	#MMU_68040,_mmutype
	jle	Ltbias040
	tstl	_mmutype
	jpl	Lmc68851c		| 68851?
	pflush #4,#4			| flush supervisor TLB entries
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip d-cache
	rts
Lmc68851c:
	pflushs #4,#4			| flush supervisor TLB entries
	rts
Ltbias040:
| 68040 cannot specify supervisor/user on pflusha, so we flush all
	.word	0xf518			| pflusha
#ifdef M68060
	cmpl	#MMU_68060,_mmutype
	jne	Ltbiasno60
	movc	cacr,d0
	orl	#IC60_CABC,d0		| and clear all branch cache entries
	movc	d0,cacr
Ltbiasno60:
#endif
	rts

/*
 * Invalidate user side of TLB
 */
ENTRY(TBIAU)
#ifdef DEBUG
	tstl	fulltflush		| being conservative?
	jne	__TBIA			| yes, flush everything
#endif
	cmpl	#MMU_68040,_mmutype
	jle	Ltbiau040
	tstl	_mmutype
	jpl	Lmc68851d		| 68851?
	pflush	#0,#4			| flush user TLB entries
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip d-cache
	rts
Lmc68851d:
	pflushs	#0,#4			| flush user TLB entries
	rts
Ltbiau040:
| 68040 cannot specify supervisor/user on pflusha, so we flush all
	.word	0xf518			| pflusha
#ifdef M68060
	cmpl	#MMU_68060,_mmutype
	jne	Ltbiauno60
	movc	cacr,d0
	orl	#IC60_CUBC,d0		| but only user branch cache entries
	movc	d0,cacr
Ltbiauno60:
#endif
	rts

/*
 * Invalidate instruction cache
 */
ENTRY(ICIA)
ENTRY(ICPA)
#if defined(M68030) || defined(M68020)
#if defined(M68040) || defined(M68060)
	cmpl	#MMU_68040,_mmutype
	jle	Licia040
#endif
	movl	#IC_CLEAR,d0
	movc	d0,cacr			| invalidate i-cache
	rts
Licia040:
#endif
#if defined(M68040) || defined(M68060) 
	.word	0xf498		| cinva ic, clears also branch cache on 060
	rts
#endif

/*
 * Invalidate data cache.
 * NOTE: we do not flush 68030 on-chip cache as there are no aliasing
 * problems with DC_WA.  The only cases we have to worry about are context
 * switch and TLB changes, both of which are handled "in-line" in resume
 * and TBI*.
 */
ENTRY(DCIA)
__DCIA:
	cmpl	#MMU_68040,_mmutype
	jgt	Ldciax
	.word	0xf478		| cpusha dc
Ldciax:
	rts

ENTRY(DCIS)
__DCIS:
	cmpl	#MMU_68040,_mmutype
	jgt	Ldcisx
	.word	0xf478		| cpusha dc
	nop
Ldcisx:
	rts

ENTRY(DCIU)
__DCIU:
	cmpl	#MMU_68040,_mmutype
	jgt	Ldciux
	.word	0xf478		| cpusha dc
Ldciux:
	rts

| Invalid single cache line
ENTRY(DCIAS)
__DCIAS:
	cmpl	#MMU_68040,_mmutype
	jle	Ldciasx
	movl	sp@@(4),a0
	.word	0xf468		| cpushl dc,a0@@
Ldciasx:
	rts
#if defined(M68040) || defined(M68060)
ENTRY(ICPL)	/* invalidate instruction physical cache line */
	movl    sp@@(4),a0		| address
	.word   0xf488			| cinvl ic,a0@@
	rts
ENTRY(ICPP)	/* invalidate instruction physical cache page */
	movl    sp@@(4),a0		| address
	.word   0xf490			| cinvp ic,a0@@
	rts
ENTRY(DCPL)	/* invalidate data physical cache line */
	movl    sp@@(4),a0		| address
	.word   0xf448			| cinvl dc,a0@@
	rts
ENTRY(DCPP)	/* invalidate data physical cache page */
	movl    sp@@(4),a0		| address
	.word   0xf450			| cinvp dc,a0@@
	rts
ENTRY(DCPA)	/* invalidate data physical all */
	.word   0xf458			| cinva dc
	rts
ENTRY(DCFL)	/* data cache flush line */
	movl    sp@@(4),a0		| address
	.word   0xf468			| cpushl dc,a0@@
	rts
ENTRY(DCFP)	/* data cache flush page */
	movl    sp@@(4),a0		| address
	.word   0xf470			| cpushp dc,a0@@
	rts
#endif	/* M68040 */

ENTRY(PCIA)
#if defined(M68030) || defined(M68030)
#if defined(M68040) || defined(M68060)
	cmpl	#MMU_68040,_mmutype
	jle	Lpcia040
#endif
	movl	#DC_CLEAR,d0
	movc	d0,cacr			| invalidate on-chip d-cache
	rts
#endif
#if defined(M68040) || defined(M68060)
ENTRY(DCFA)
Lpcia040:
	.word	0xf478		| cpusha dc
	rts
#endif

/*
 * Get callers current SP value.
 * Note that simply taking the address of a local variable in a C function
 * doesn't work because callee saved registers may be outside the stack frame
 * defined by A6 (e.g. GCC generated code).
 */
	.globl	_getsp
_getsp:
	movl	sp,d0			| get current SP
	addql	#4,d0			| compensate for return address
	rts

	.globl	_getsfc, _getdfc
_getsfc:
	movc	sfc,d0
	rts
_getdfc:
	movc	dfc,d0
	rts

/*
 * Check out a virtual address to see if it's okay to write to.
 *
 * probeva(va, fc)
 *
 */
ENTRY(probeva)
	movl	sp@@(8),d0
	movec	d0,dfc
	movl	sp@@(4),a0
	.word	0xf548		| ptestw (a0)
	moveq	#FC_USERD,d0		| restore DFC to user space
	movc	d0,dfc
	.word	0x4e7a,0x0805	| movec  MMUSR,d0
	rts

/*
 * Load a new user segment table pointer.
 */
ENTRY(loadustp)
	movl	sp@@(4),d0		| new USTP
	moveq	#PGSHIFT,d1
	lsll	d1,d0			| convert to addr
#ifdef M68060
	cmpl	#MMU_68060,_mmutype
	jeq	Lldustp060
#endif
	cmpl	#MMU_68040,_mmutype
	jeq	Lldustp040
	pflusha				| flush entire TLB
	lea	_protorp,a0		| CRP prototype
	movl	d0,a0@@(4)		| stash USTP
	pmove	a0@@,crp			| load root pointer
	movl	#CACHE_CLR,d0
	movc	d0,cacr			| invalidate on-chip d-cache
	rts				|   since pmove flushes TLB
#ifdef M68060
Lldustp060:
	movc	cacr,d1
	orl	#IC60_CUBC,d1		| clear user branch cache entries
	movc	d1,cacr
#endif
Lldustp040:
	.word	0xf518
	.word	0x4e7b,0x0806		| movec d0,URP
	rts

/*
 * Save and restore 68881 state.
 * Pretty awful looking since our assembler does not
 * recognize FP mnemonics.
 */
ENTRY(m68881_save)
	movl	sp@@(4),a0		| save area pointer
	fsave	a0@@			| save state
#if defined(M68020) || defined(M68030) || defined(M68040)
#ifdef M68060
	cmpl	#MMU_68060,_mmutype
	jeq	Lm68060fpsave
#endif
	tstb	a0@@			| null state frame?
	jeq	Lm68881sdone		| yes, all done
	fmovem fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem fpcr/fpsr/fpi,a0@@(FPF_FPCR)	| save FP control registers
Lm68881sdone:
	rts
#endif

#ifdef M68060
Lm68060fpsave:
	tstb	a0@@(2)			| null state frame?
	jeq	Lm68060sdone		| yes, all done
	fmovem fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr,a0@@(FPF_FPCR)	| save FP control registers
	fmovem	fpsr,a0@@(FPF_FPSR)
	fmovem	fpi,a0@@(FPF_FPI)
Lm68060sdone:
	rts
#endif

ENTRY(m68881_restore)
	movl	sp@@(4),a0		| save area pointer
#if defined(M68020) || defined(M68030) || defined(M68040)
#if defined(M68060)
	cmpl	#MMU_68060,_mmutype
	jeq	Lm68060fprestore
#endif
	tstb	a0@@			| null state frame?
	jeq	Lm68881rdone		| yes, easy
	fmovem	a0@@(FPF_FPCR),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
Lm68881rdone:
	frestore a0@@			| restore state
	rts
#endif

#ifdef M68060
Lm68060fprestore:
	tstb	a0@@(2)			| null state frame?
	jeq	Lm68060fprdone		| yes, easy
	fmovem	a0@@(FPF_FPCR),fpcr	| restore FP control registers
	fmovem	a0@@(FPF_FPSR),fpsr
	fmovem	a0@@(FPF_FPI),fpi
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
Lm68060fprdone:
	frestore a0@@			| restore state
	rts
#endif

/*
 * Handle the nitty-gritty of rebooting the machine.
 *
 */
	.globl	_doboot
_doboot:
	movl	#CACHE_OFF,d0
	cmpl	#MMU_68040,_mmutype	| is it 68040
	jgt	Ldoboot0
	.word	0xf4f8		| cpusha bc - push and invalidate caches
	nop
	movl	#CACHE40_OFF,d0
Ldoboot0:
	movc	d0,cacr			| disable on-chip cache(s)

	movw	#0x2700,sr		| cut off any interrupts

#if defined(DRACO)
	cmpb	#0x7d,_machineid
	jeq	LdbOnDraCo
#endif

	| clear first 4k of CHIPMEM
	movl	_CHIPMEMADDR,a0
	movl	a0,a1
	movl	#1024,d0
Ldb1:
	clrl	a0@@+
	dbra	d0,Ldb1

	| now, copy the following code over
|	lea	a1@@(Ldoreboot),a0	| KVA starts at 0, CHIPMEM is phys 0
|	lea	a1@@(Ldorebootend),a1
|	lea	pc@@(Ldoreboot-.+2),a0
|	addl	a1,a0
|	lea	a0@@(128),a1
|	lea	pc@@(Ldoreboot-.+2),a2
	lea	Ldoreboot,a2
	lea	Ldorebootend,a0
	addl	a1,a0
	addl	a2,a1
	exg	a0,a1
Ldb2:
	movel	a2@@+,a0@@+
	cmpl	a1,a0
	jle	Ldb2

	| ok, turn off MMU..
Ldoreboot:
	cmpl	#MMU_68040,_mmutype	| is it 68040
 	jle	Lmmuoff040
	lea	zero,a0
	pmove	a0@@,tc			| Turn off MMU
	lea	nullrp,a0
	pmove	a0@@,crp			| Turn off MMU some more
	pmove	a0@@,srp			| Really, really, turn off MMU
	jra	Ldoboot1
Lmmuoff040:
	movl	#0,d0
	.word	0x4e7b,0x0003	| movc d0,TC
	.word	0x4e7b,0x0806	| movc d0,URP
	.word	0x4e7b,0x0807	| movc d0,SRP
Ldoboot1:

	| this weird code is the OFFICIAL way to reboot an Amiga ! ..
	lea	0x1000000,a0
	subl	a0@@(-0x14),a0
	movl	a0@@(4),a0
	subl	#2,a0
	cmpw	#0x4e70,a0@@		| 68040 kludge: if ROM entry is not
	jne	Ldoreset		| a reset, do the reset here
	jmp	a0@@			| otherwise, jump to the ROM to reset
	| reset needs to be on longword boundary
	nop
	.align	2
Ldoreset:
	| reset unconfigures all memory!
	reset
	| now rely on prefetch for next jmp
	jmp	a0@@
	| NOT REACHED
#ifdef DRACO
LdbOnDraCo:
| we should better use TTR instead of this... we want to boot even if
| half of us is already dead.

|	pea	LdoDraCoBoot
|	pea	_kernel_pmap_store
|	jsr	_pmap_extract
|	movl	d0,sp@@(4)
|	andl	#0xFFFFE000,d0
|	movl	#1,sp@@		| wired = TRUE
|	movl	#0x4,sp@@-	| prot = VM_PROT_EXECUTE
|	movl	d0,sp@@-		| map va == pa
|	movl	d0,sp@@-		| to pa
|	pea	_kernel_pmap_store
|	jsr	_pmap_enter	
|	addl	#NBPG,sp@@(4)
|	addl	#NBPG,sp@@(8)
|	jsr	_pmap_enter	
|	addl	#20,sp

	movl	_boot_fphystart, d0
	lea	LdoDraCoBoot, a0
	lea	a0@@(d0),a0
	andl	#0xFF000000,d0
	orl	#0x0000C044,d0	| enable, supervisor, CI, RO
	.word	0x4e7b,0x0004	| movc d0,ITT0
	jmp	a0@@

	.align	2
LdoDraCoBoot:
| turn off MMU now ... were more ore less guaranteed to run on 040/060:
	movl	#0,d0
	.word	0x4e7b,0x0003	| movc d0,TC
	.word	0x4e7b,0x0806	| movc d0,URP
	.word	0x4e7b,0x0807	| movc d0,SRP
	.word	0x4e7b,0x0004	| movc d0,ITT0
	nop
| map in boot ROM @@0:
	reset
| and simulate what a reset exception would have done.
	movl	4,a0
	movl	0,a7
	jmp	a0@@
	| NOT REACHED
#endif
/*
 * Reboot directly into a new kernel image.
 * kernel_reload(image, image_size, entry,
 *		 fastram_start, fastram_size, chipram_start, esym, eclockfreq)
 */
	.globl	_kernel_reload
_kernel_reload:
	lea	Lreload_copy,a0		| cursory validity check of new kernel
	movl	a0@@,d0			|  to see if the kernel reload code
	addl	sp@@(4),a0		|  in new image matches running kernel
	cmpl	a0@@,d0
	jeq	Lreload_ok
	rts				| It doesn't match - can't reload
Lreload_ok:
	jsr	_bootsync
	CUSTOMADDR(a5)

	movew	#(1<<9),a5@@(0x096)	| disable DMA (before clobbering chipmem)

	movl	#CACHE_OFF,d0
	cmpl	#MMU_68040,_mmutype
	jgt	Lreload1
	.word	0xf4f8		| cpusha bc - push and invalidate caches
	nop
	movl	#CACHE40_OFF,d0
Lreload1:
	movc	d0,cacr			| disable on-chip cache(s)

	movw	#0x2700,sr		| cut off any interrupts
	movel	_boothowto,d7		| save boothowto
	movel	_machineid,d5		| (and machineid)

	movel	sp@@(16),a0		| load memory parameters
	movel	sp@@(20),d0
	movel	sp@@(24),d1
	movel	sp@@(28),a4		| esym
	movel	sp@@(32),d4		| eclockfreq
	movel	sp@@(36),d3		| AGA mode
	movel	sp@@(40),a2		| sync inhibit flags

	movel	sp@@(12),a6		| find entrypoint (a6)

	movel	sp@@(4),a1		| copy kernel to low chip memory
	movel	sp@@(8),d2
	movl	_CHIPMEMADDR,a3
Lreload_copy:
	movel	a1@@+,a3@@+
	subl	#4,d2
	jcc	Lreload_copy

	| ok, turn off MMU..
	cmpl	#MMU_68040,_mmutype
	jle	Lreload040
	lea	zero,a3
	pmove	a3@@,tc			| Turn off MMU
	lea	nullrp,a3
	pmove	a3@@,crp			| Turn off MMU some more
	pmove	a3@@,srp			| Really, really, turn off MMU
	jra	Lreload2
Lreload040:
	movl	#0,d2
	.word	0x4e7b,0x2003	| movc d2,TC
	.word	0x4e7b,0x2806	| movc d2,URP
	.word	0x4e7b,0x2807	| movc d2,SRP
Lreload2:

	moveq	#0,d2			| clear unused registers
	moveq	#0,d6
	subl	a1,a1
	subl	a3,a3
	subl	a5,a5
	jmp	a6@@			| start new kernel


| A do-nothing MMU root pointer (includes the following long as well)

nullrp:	.long	0x7fff0001
zero:	.long	0
Ldorebootend:

	.align 2
	.globl _DELAY
	.globl _delay
	nop
_delay:
_DELAY:
	movql #10,d1		| 2 +2
	movl sp@@(4),d0		| 4 +4
	lsll d1,d0		| 8 +2
	movl _delaydivisor,d1	| A +6
Ldelay:				| longword aligned again.
	subl d1,d0
	jcc Ldelay
	rts

#ifdef M68060
	.globl _intemu60, _fpiemu60, _fpdemu60, _fpeaemu60
_intemu60:
	addql	#1,L60iem
	jra	_I_CALL_TOP+128+0x00
_fpiemu60:
	addql	#1,L60fpiem
	jra	_FP_CALL_TOP+128+0x30
_fpdemu60:
	addql	#1,L60fpdem
	jra	_FP_CALL_TOP+128+0x38
_fpeaemu60:
	addql	#1,L60fpeaem
	jra	_FP_CALL_TOP+128+0x40
#endif

	.data
	.space	NBPG
tmpstk:
	.globl	_mmutype,_cputype,_fputype,_protorp
_mmutype:
	.long	MMU_68851
_cputype:
	.long	CPU_68020
_ectype:
	.long	EC_NONE
_fputype:
	.long	FPU_NONE
_protorp:
	.long	0x80000002,0	| prototype root pointer
	.globl	_cold
_cold:
	.long	1		| cold start flag
	.globl	_proc0paddr
_proc0paddr:
	.long	0		| KVA of proc0 u-area
	.globl _delaydivisor
_delaydivisor:
	.long	12		| should be enough for 80 MHz 68060
				| will be adapted to other CPUs in
				| start_c_cleanup and calibrated
				| at clock attach time.
#ifdef DEBUG
	.globl	fulltflush, fullcflush
fulltflush:
	.long	0
fullcflush:
	.long	0
	.globl	timebomb
timebomb:
	.long	0
#endif
/* interrupt counters */
	.globl	_intrcnt,_eintrcnt,_intrnames,_eintrnames
_intrnames:
	.asciz	"spur"		| spurious interrupt
	.asciz	"tbe/soft"	| serial TBE & software
	.asciz	"kbd/ports"	| keyboard & PORTS
	.asciz	"vbl"		| vertical blank
	.asciz	"audio"		| audio channels
	.asciz	"rbf"		| serial receive
	.asciz	"exter"		| EXTERN
	.asciz	"nmi"		| non-maskable
	.asciz	"clock"		| clock interrupts
	.asciz	"spur6"		| spurious level 6
#ifdef DRACO
	.asciz	"kbd/soft"	| 1: native keyboard, soft ints
	.asciz	"cia/zbus"	| 2: cia, PORTS
	.asciz	"lclbus"	| 3: local bus, e.g. Altais vbl
	.asciz	"drscsi"	| 4: mainboard scsi
	.asciz	"superio"	| 5: superio chip
	.asciz	"lcl/zbus"	| 6: lcl/zorro lev6
	.asciz	"buserr"	| 7: nmi: bus timeout
#endif
#ifdef M68060
	.asciz	"60intemu"
	.asciz	"60fpiemu"
	.asciz	"60fpdemu"
	.asciz	"60fpeaemu"
	.asciz	"60bpe"
#endif
#ifdef FPU_EMULATE
	.asciz	"fpe"
#endif
_eintrnames:
	.align	2
_intrcnt:
	.long	0,0,0,0,0,0,0,0,0,0
#ifdef DRACO
Drintrcnt:
	.long	0,0,0,0,0,0,0
#endif
#ifdef M68060
L60iem:		.long	0
L60fpiem:	.long	0
L60fpdem:	.long	0
L60fpeaem:	.long	0
L60bpe:		.long	0
#endif
#ifdef FPU_EMULATE
Lfpecnt:	.long	0
#endif
_eintrcnt:
@


1.40
log
@revert the pmap stuff to 0221, so we can boot
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.37 2002/02/10 23:15:05 deraadt Exp $	*/
@


1.39
log
@Bring back pmap_motorola in service for amiga, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.38 2002/02/22 23:40:07 miod Exp $	*/
d1252 1
a1252 1
	movl	_caddr2_pte,a1@@(PCB_CMAP2)	| save temporary map PTE
d1306 1
a1306 1
	movl	a1@@(PCB_CMAP2),_caddr2_pte	| reload tmp map
d1360 1
a1360 1
	movl	_caddr2_pte,a1@@(PCB_CMAP2)	| save temporary map PTE
d1395 83
d1483 1
a1483 1
	jle	Ltbia040
@


1.38
log
@Unbreak 68060 support, sorry
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.37 2002/02/10 23:15:05 deraadt Exp $	*/
d1252 1
a1252 1
	movl	_CMAP2,a1@@(PCB_CMAP2)	| save temporary map PTE
d1306 1
a1306 1
	movl	a1@@(PCB_CMAP2),_CMAP2	| reload tmp map
d1360 1
a1360 1
	movl	_CMAP2,a1@@(PCB_CMAP2)	| save temporary map PTE
a1391 83
	rts

/*
 * Copy 1 relocation unit (NBPG bytes)
 * from user virtual address to physical address
 */
ENTRY(copyseg)
	movl	_curpcb,a1			| current pcb
	movl	#Lcpydone,a1@@(PCB_ONFAULT)	| where to return to on a fault
	movl	sp@@(8),d0			| destination page number
	moveq	#PGSHIFT,d1
	lsll	d1,d0				| convert to address
	orl	#PG_CI+PG_RW+PG_V,d0		| make sure valid and writable
	movl	_CMAP2,a0
	movl	_CADDR2,sp@@-			| destination kernel VA
	movl	d0,a0@@				| load in page table
	jbsr	_TBIS				| invalidate any old mapping
	addql	#4,sp
	movl	_CADDR2,a1			| destination addr
	movl	sp@@(4),a0			| source addr
	movl	#NBPG/4-1,d0			| count
Lcpyloop:
	movsl	a0@@+,d1				| read longword
	movl	d1,a1@@+				| write longword
	dbf	d0,Lcpyloop			| continue until done
Lcpydone:
	movl	_curpcb,a1			| current pcb
	clrl	a1@@(PCB_ONFAULT) 		| clear error catch
	rts

/*
 * Copy 1 relocation unit (NBPG bytes)
 * from physical address to physical address
 */
ENTRY(physcopyseg)
	movl	sp@@(4),d0			| source page number
	moveq	#PGSHIFT,d1
	lsll	d1,d0				| convert to address
	orl	#PG_CI+PG_RW+PG_V,d0		| make sure valid and writable
	movl	_CMAP1,a0
	movl	d0,a0@@				| load in page table
	movl	_CADDR1,sp@@-			| destination kernel VA
	jbsr	_TBIS				| invalidate any old mapping
	addql	#4,sp

	movl	sp@@(8),d0			| destination page number
	moveq	#PGSHIFT,d1
	lsll	d1,d0				| convert to address
	orl	#PG_CI+PG_RW+PG_V,d0		| make sure valid and writable
	movl	_CMAP2,a0
	movl	d0,a0@@				| load in page table
	movl	_CADDR2,sp@@-			| destination kernel VA
	jbsr	_TBIS				| invalidate any old mapping
	addql	#4,sp

	movl	_CADDR1,a0			| source addr
	movl	_CADDR2,a1			| destination addr
	movl	#NBPG/4-1,d0			| count
Lpcpy:
	movl	a0@@+,a1@@+			| copy longword
	dbf	d0,Lpcpy			| continue until done
	rts

/*
 * zero out physical memory
 * specified in relocation units (NBPG bytes)
 */
ENTRY(clearseg)
	movl	sp@@(4),d0			| destination page number
	moveq	#PGSHIFT,d1
	lsll	d1,d0				| convert to address
	orl	#PG_CI+PG_RW+PG_V,d0		| make sure valid and writable
	movl	_CMAP1,a0
	movl	_CADDR1,sp@@-			| destination kernel VA
	movl	d0,a0@@				| load in page map
	jbsr	_TBIS				| invalidate any old mapping
	addql	#4,sp
	movl	_CADDR1,a1			| destination addr
	movl	#NBPG/4-1,d0			| count
/* simple clear loop is fastest on 68020 */
Lclrloop:
	clrl	a1@@+				| clear a longword
	dbf	d0,Lclrloop			| continue til done
@


1.37
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.36 2002/01/24 20:31:07 miod Exp $	*/
d1483 1
a1483 1
	jeq	Ltbia040
@


1.36
log
@Don't provide a duplicate addupc_task() routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.35 2001/12/20 19:02:24 miod Exp $	*/
d235 1
a235 1
					| (we dont seperate data/program)
@


1.35
log
@Temporarily revert the pmap_motorola changes, as they may account for
some problems as well.
Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.34 2001/12/06 21:13:28 millert Exp $	*/
a1109 39

/*
 * update profiling information for the user
 * addupc(pc, &u.u_prof, ticks)
 */
ENTRY(addupc)
	movl	a2,sp@@-			| scratch register
	movl	sp@@(12),a2		| get &u.u_prof
	movl	sp@@(8),d0		| get user pc
	subl	a2@@(8),d0		| pc -= pr->pr_off
	jlt	Lauexit			| less than 0, skip it
	movl	a2@@(12),d1		| get pr->pr_scale
	lsrl	#1,d0			| pc /= 2
	lsrl	#1,d1			| scale /= 2
	mulul	d1,d0			| pc /= scale
	moveq	#14,d1
	lsrl	d1,d0			| pc >>= 14
	bclr	#0,d0			| pc &= ~1
	cmpl	a2@@(4),d0		| too big for buffer?
	jge	Lauexit			| yes, screw it
	addl	a2@@,d0			| no, add base
	movl	d0,sp@@-			| push address
	jbsr	_fusword		| grab old value
	movl	sp@@+,a0			| grab address back
	cmpl	#-1,d0			| access ok
	jeq	Lauerror		| no, skip out
	addw	sp@@(18),d0		| add tick to current value
	movl	d0,sp@@-			| push value
	movl	a0,sp@@-			| push address
	jbsr	_susword		| write back new value
	addql	#8,sp			| pop params
	tstl	d0			| fault?
	jeq	Lauexit			| no, all done
Lauerror:
	clrl	a2@@(12)			| clear scale (turn off prof)
Lauexit:
	movl	sp@@+,a2			| restore scratch reg
	rts

@


1.34
log
@Define proper macros for FP frame offsets rather than magic numbers.
From NetBSD (tsutsui).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.33 2001/11/30 23:14:28 miod Exp $	*/
d1291 1
a1291 1
	movl	_caddr2_pte,a1@@(PCB_CMAP2)	| save temporary map PTE
d1345 1
a1345 1
	movl	a1@@(PCB_CMAP2),_caddr2_pte	| reload tmp map
d1399 1
a1399 1
	movl	_caddr2_pte,a1@@(PCB_CMAP2)	| save temporary map PTE
d1434 83
d1522 1
a1522 1
	jle	Ltbia040
@


1.34.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.36 2002/01/24 20:31:07 miod Exp $	*/
d1111 39
d1291 1
a1291 1
	movl	_CMAP2,a1@@(PCB_CMAP2)	| save temporary map PTE
d1345 1
a1345 1
	movl	a1@@(PCB_CMAP2),_CMAP2	| reload tmp map
d1399 1
a1399 1
	movl	_CMAP2,a1@@(PCB_CMAP2)	| save temporary map PTE
a1433 83
 * Copy 1 relocation unit (NBPG bytes)
 * from user virtual address to physical address
 */
ENTRY(copyseg)
	movl	_curpcb,a1			| current pcb
	movl	#Lcpydone,a1@@(PCB_ONFAULT)	| where to return to on a fault
	movl	sp@@(8),d0			| destination page number
	moveq	#PGSHIFT,d1
	lsll	d1,d0				| convert to address
	orl	#PG_CI+PG_RW+PG_V,d0		| make sure valid and writable
	movl	_CMAP2,a0
	movl	_CADDR2,sp@@-			| destination kernel VA
	movl	d0,a0@@				| load in page table
	jbsr	_TBIS				| invalidate any old mapping
	addql	#4,sp
	movl	_CADDR2,a1			| destination addr
	movl	sp@@(4),a0			| source addr
	movl	#NBPG/4-1,d0			| count
Lcpyloop:
	movsl	a0@@+,d1				| read longword
	movl	d1,a1@@+				| write longword
	dbf	d0,Lcpyloop			| continue until done
Lcpydone:
	movl	_curpcb,a1			| current pcb
	clrl	a1@@(PCB_ONFAULT) 		| clear error catch
	rts

/*
 * Copy 1 relocation unit (NBPG bytes)
 * from physical address to physical address
 */
ENTRY(physcopyseg)
	movl	sp@@(4),d0			| source page number
	moveq	#PGSHIFT,d1
	lsll	d1,d0				| convert to address
	orl	#PG_CI+PG_RW+PG_V,d0		| make sure valid and writable
	movl	_CMAP1,a0
	movl	d0,a0@@				| load in page table
	movl	_CADDR1,sp@@-			| destination kernel VA
	jbsr	_TBIS				| invalidate any old mapping
	addql	#4,sp

	movl	sp@@(8),d0			| destination page number
	moveq	#PGSHIFT,d1
	lsll	d1,d0				| convert to address
	orl	#PG_CI+PG_RW+PG_V,d0		| make sure valid and writable
	movl	_CMAP2,a0
	movl	d0,a0@@				| load in page table
	movl	_CADDR2,sp@@-			| destination kernel VA
	jbsr	_TBIS				| invalidate any old mapping
	addql	#4,sp

	movl	_CADDR1,a0			| source addr
	movl	_CADDR2,a1			| destination addr
	movl	#NBPG/4-1,d0			| count
Lpcpy:
	movl	a0@@+,a1@@+			| copy longword
	dbf	d0,Lpcpy			| continue until done
	rts

/*
 * zero out physical memory
 * specified in relocation units (NBPG bytes)
 */
ENTRY(clearseg)
	movl	sp@@(4),d0			| destination page number
	moveq	#PGSHIFT,d1
	lsll	d1,d0				| convert to address
	orl	#PG_CI+PG_RW+PG_V,d0		| make sure valid and writable
	movl	_CMAP1,a0
	movl	_CADDR1,sp@@-			| destination kernel VA
	movl	d0,a0@@				| load in page map
	jbsr	_TBIS				| invalidate any old mapping
	addql	#4,sp
	movl	_CADDR1,a1			| destination addr
	movl	#NBPG/4-1,d0			| count
/* simple clear loop is fastest on 68020 */
Lclrloop:
	clrl	a1@@+				| clear a longword
	dbf	d0,Lclrloop			| continue til done
	rts

/*
d1439 1
a1439 1
	jeq	Ltbia040
@


1.34.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.34.2.1 2002/01/31 22:55:06 niklas Exp $	*/
d235 1
a235 1
					| (we dont separate data/program)
@


1.34.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.34.2.2 2002/06/11 03:34:57 art Exp $	*/
@


1.33
log
@Switch to pmap_motorola.
XXX Kernel compiles, but not tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.32 2001/11/30 22:08:13 miod Exp $	*/
d1305 2
a1306 2
	fmovem	fp0-fp7,a2@@(216)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a2@@(312)	| save FP control registers
d1315 4
a1318 4
	fmovem	fp0-fp7,a2@@(216)	| save FP general registers
	fmovem	fpcr,a2@@(312)		| save FP control registers
	fmovem	fpsr,a2@@(316)
	fmovem	fpi,a2@@(320)
d1365 2
a1366 2
	fmovem	a0@@(312),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(216),fp0-fp7	| restore FP general registers
d1378 4
a1381 4
	fmovem	a0@@(312),fpcr		| restore FP control registers
	fmovem	a0@@(316),fpsr
	fmovem	a0@@(320),fpi
	fmovem	a0@@(216),fp0-fp7	| restore FP general registers
d1413 2
a1414 2
	fmovem	fp0-fp7,a0@@(216)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a0@@(312)	| save FP control registers
d1424 4
a1427 4
	fmovem	fp0-fp7,a0@@(216)	| save FP general registers
	fmovem	fpcr,a0@@(312)		| save FP control registers
	fmovem	fpsr,a0@@(316)
	fmovem	fpi,a0@@(320)
d1750 2
a1751 2
	fmovem fp0-fp7,a0@@(216)		| save FP general registers
	fmovem fpcr/fpsr/fpi,a0@@(312)	| save FP control registers
d1760 4
a1763 4
	fmovem fp0-fp7,a0@@(216)		| save FP general registers
	fmovem	fpcr,a0@@(312)		| save FP control registers
	fmovem	fpsr,a0@@(316)
	fmovem	fpi,a0@@(320)
d1777 2
a1778 2
	fmovem	a0@@(312),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(216),fp0-fp7	| restore FP general registers
d1788 4
a1791 4
	fmovem	a0@@(312),fpcr		| restore FP control registers
	fmovem	a0@@(316),fpsr
	fmovem	a0@@(320),fpi
	fmovem	a0@@(216),fp0-fp7	| restore FP general registers
@


1.32
log
@Make it possible for mmutype to contain MMU_68060 if the hardware is
actually '060-based, instead to look at the machineid.
This is simpler, and will be required to switch to pmap_motorola anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.31 2001/08/12 23:52:59 miod Exp $	*/
d1291 1
a1291 1
	movl	_CMAP2,a1@@(PCB_CMAP2)	| save temporary map PTE
d1345 1
a1345 1
	movl	a1@@(PCB_CMAP2),_CMAP2	| reload tmp map
d1399 1
a1399 1
	movl	_CMAP2,a1@@(PCB_CMAP2)	| save temporary map PTE
a1430 83
	rts

/*
 * Copy 1 relocation unit (NBPG bytes)
 * from user virtual address to physical address
 */
ENTRY(copyseg)
	movl	_curpcb,a1			| current pcb
	movl	#Lcpydone,a1@@(PCB_ONFAULT)	| where to return to on a fault
	movl	sp@@(8),d0			| destination page number
	moveq	#PGSHIFT,d1
	lsll	d1,d0				| convert to address
	orl	#PG_CI+PG_RW+PG_V,d0		| make sure valid and writable
	movl	_CMAP2,a0
	movl	_CADDR2,sp@@-			| destination kernel VA
	movl	d0,a0@@				| load in page table
	jbsr	_TBIS				| invalidate any old mapping
	addql	#4,sp
	movl	_CADDR2,a1			| destination addr
	movl	sp@@(4),a0			| source addr
	movl	#NBPG/4-1,d0			| count
Lcpyloop:
	movsl	a0@@+,d1				| read longword
	movl	d1,a1@@+				| write longword
	dbf	d0,Lcpyloop			| continue until done
Lcpydone:
	movl	_curpcb,a1			| current pcb
	clrl	a1@@(PCB_ONFAULT) 		| clear error catch
	rts

/*
 * Copy 1 relocation unit (NBPG bytes)
 * from physical address to physical address
 */
ENTRY(physcopyseg)
	movl	sp@@(4),d0			| source page number
	moveq	#PGSHIFT,d1
	lsll	d1,d0				| convert to address
	orl	#PG_CI+PG_RW+PG_V,d0		| make sure valid and writable
	movl	_CMAP1,a0
	movl	d0,a0@@				| load in page table
	movl	_CADDR1,sp@@-			| destination kernel VA
	jbsr	_TBIS				| invalidate any old mapping
	addql	#4,sp

	movl	sp@@(8),d0			| destination page number
	moveq	#PGSHIFT,d1
	lsll	d1,d0				| convert to address
	orl	#PG_CI+PG_RW+PG_V,d0		| make sure valid and writable
	movl	_CMAP2,a0
	movl	d0,a0@@				| load in page table
	movl	_CADDR2,sp@@-			| destination kernel VA
	jbsr	_TBIS				| invalidate any old mapping
	addql	#4,sp

	movl	_CADDR1,a0			| source addr
	movl	_CADDR2,a1			| destination addr
	movl	#NBPG/4-1,d0			| count
Lpcpy:
	movl	a0@@+,a1@@+			| copy longword
	dbf	d0,Lpcpy			| continue until done
	rts

/*
 * zero out physical memory
 * specified in relocation units (NBPG bytes)
 */
ENTRY(clearseg)
	movl	sp@@(4),d0			| destination page number
	moveq	#PGSHIFT,d1
	lsll	d1,d0				| convert to address
	orl	#PG_CI+PG_RW+PG_V,d0		| make sure valid and writable
	movl	_CMAP1,a0
	movl	_CADDR1,sp@@-			| destination kernel VA
	movl	d0,a0@@				| load in page map
	jbsr	_TBIS				| invalidate any old mapping
	addql	#4,sp
	movl	_CADDR1,a1			| destination addr
	movl	#NBPG/4-1,d0			| count
/* simple clear loop is fastest on 68020 */
Lclrloop:
	clrl	a1@@+				| clear a longword
	dbf	d0,Lclrloop			| continue til done
@


1.31
log
@Actually, I was there only to remove an nappropriate hp300
comment. But I couldn't go without removing some unused sutff as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.30 2001/06/27 03:54:12 art Exp $	*/
d300 1
a300 1
	jne	_illinst		| no, treat as illinst
d956 1
d967 1
d1024 2
a1025 2
	btst	#7,_machineid+3
	jeq	Lcacheon
d1068 1
a1068 1
	jne	Lnoflush		| no, skip
d1071 1
d1073 2
a1074 2
|	btst	#7,_machineid+3
|	jeq	Lnoflush
d1078 1
d1300 2
a1301 2
	btst	#7,_machineid+3
	jne	Lsavfp60
d1360 2
a1361 2
	btst	#7,_machineid+3
	jne	Lresfp60rest1
d1408 2
a1409 2
	btst	#7,_machineid+3
	jne	Lsavctx60
d1522 1
a1522 1
	jeq	Ltbia040
d1533 2
a1534 2
	btst	#7,_machineid+3
	jeq	Ltbiano60
d1552 1
a1552 1
	jeq	Ltbis040
d1570 2
a1571 2
	btst	#7,_machineid+3
	jeq	Ltbisno60
d1588 1
a1588 1
	jeq	Ltbias040
d1602 2
a1603 2
	btst	#7,_machineid+3
	jeq	Ltbiasno60
d1620 1
a1620 1
	jeq	Ltbiau040
d1634 2
a1635 2
	btst	#7,_machineid+3
	jeq	Ltbiauno60
d1651 1
a1651 1
	jeq	Licia040
d1673 1
a1673 1
	jne	Ldciax
d1681 1
a1681 1
	jne	Ldcisx
d1690 1
a1690 1
	jne	Ldciux
d1699 1
a1699 1
	jne	Ldciasx
d1738 1
a1738 1
	jeq	Lpcia040
d1795 2
a1796 2
	btst	#7,_machineid+3
	jne	Lldustp060
d1828 2
a1829 2
	btst	#7,_machineid+3
	jne	Lm68060fpsave
d1855 2
a1856 2
	btst	#7,_machineid+3
	jne	Lm68060fprestore
d1888 1
a1888 1
	jne	Ldoboot0
d1930 1
a1930 1
 	jeq	Lmmuoff040
d2028 1
a2028 1
	jne	Lreload1
d2059 1
a2059 1
	jeq	Lreload040
@


1.30
log
@No more old VM on amiga.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.29 2000/06/05 11:02:55 art Exp $	*/
a1145 14
#ifdef notdef
/*
 * non-local gotos
 */
ENTRY(qsetjmp)
	movl	sp@@(4),a0	| savearea pointer
	lea	a0@@(40),a0	| skip regs we do not save
	movl	a6,a0@@+		| save FP
	movl	sp,a0@@+		| save SP
	movl	sp@@,a0@@		| and return address
	moveq	#0,d0		| return 0
	rts
#endif
	
a1746 6
ENTRY(ecacheon)
	rts

ENTRY(ecacheoff)
	rts

a1811 38
	rts

/*
 * Flush any hardware context associated with given USTP.
 * Only does something for HP330 where we must flush RPT
 * and ATC entries in PMMU.
 */
ENTRY(flushustp)
#ifdef M68060
	btst	#7,_machineid+3
	jne	Lflustp060
#endif
	cmpl	#MMU_68040,_mmutype
	jeq	Lnot68851
	tstl	_mmutype		| 68851 PMMU?
	jle	Lnot68851		| no, nothing to do
	movl	sp@@(4),d0		| get USTP to flush
	moveq	#PGSHIFT,d1
	lsll	d1,d0			| convert to address
	movl	d0,_protorp+4		| stash USTP
	pflushr	_protorp		| flush RPT/TLB entries
Lnot68851:
	rts
#ifdef M68060
Lflustp060:
	movc	cacr,d1
	orl	#IC60_CUBC,d1		| clear user branch cache entries
	movc	d1,cacr
	rts
#endif
	

ENTRY(ploadw)
	movl	sp@@(4),a0		| address to load
	cmpl	#MMU_68040,_mmutype
	jeq	Lploadw040
	ploadw	#1,a0@@			| pre-load translation
Lploadw040:				| should 68040 do a ptest?
@


1.29
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.28 2000/05/28 03:55:21 art Exp $	*/
a467 1
#ifdef UVM
a468 3
#else
	addql	#1,_cnt+V_INTR
#endif
a495 1
#ifdef UVM
a496 3
#else
	addql	#1,_cnt+V_INTR
#endif
a529 1
#ifdef UVM
a530 3
#else
	addql	#1,_cnt+V_INTR
#endif
a546 1
#ifdef UVM
a547 3
#else
	addql	#1,_cnt+V_INTR
#endif
a561 1
#ifdef UVM
a562 3
#else
	addql	#1,_cnt+V_INTR
#endif
a581 1
#ifdef UVM
a582 3
#else
	addql	#1,_cnt+V_INTR
#endif
a667 1
#ifdef UVM
a668 3
#else
	addql	#1,_cnt+V_INTR
#endif
a722 1
#ifdef UVM
a723 3
#else
	addql	#1,_cnt+V_INTR
#endif
@


1.28
log
@Bugfix pmap_activate.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.27 2000/05/27 20:14:18 art Exp $	*/
d1226 4
a1229 10
	/* Free old process's user area. */
	movl	#USPACE,sp@@-		| size of u-area
	movl	a0@@(P_ADDR),sp@@-	| address u-area of process
	movl	_kernel_map,sp@@-	| map it was allocated in
#if defined(UVM)
	jbsr	_uvm_km_free		| deallocate it
#else
	jbsr	_kmem_free		| deallocate it
#endif
	lea	sp@@(12),sp		| pop args
@


1.27
log
@Make pmap_activate take struct proc * as arguemnt.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.26 2000/05/27 19:48:36 art Exp $	*/
d1381 5
a1385 9
	/* see if pmap_activate needs to be called; should remove this */
	movl	a0@@(P_VMSPACE),a2	| vmspace = p->p_vmspace
#ifdef DIAGNOSTIC
	tstl	a2			| map == VM_MAP_NULL?
	jeq	Lbadsw			| panic
#endif
	movl	a2@@(VM_PMAP),a2		| pmap = vmspace->vm_map.pmap
	tstl	a2@@(PM_STCHG)		| pmap->st_changed?
	jeq	Lswnochg		| no, skip
d1390 1
a1390 1
Lswnochg:
d1392 1
a1392 30
	cmpl	#MMU_68040,_mmutype
	jeq	Lres2
	movl	#CACHE_CLR,d0
	movc	d0,cacr			| invalidate cache(s)
	pflusha				| flush entire TLB
	jra	Lres3
Lres2:
	.word	0xf518			| pflusha (68040)
|	movl	#CACHE40_ON,d0
|	movc	d0,cacr			| invalidate cache(s)
#ifdef M68060
	btst	#7,_machineid+3
	jeq	Lres3
	movc	cacr,d2
	orl	#IC60_CUBC,d2		| clear user branch cache entries
	movc	d2,cacr
#endif
Lres3:
	movl	a1@@(PCB_USTP),d0	| get USTP
	moveq	#PGSHIFT,d1
	lsll	d1,d0			| convert to addr
	cmpl	#MMU_68040,_mmutype
	jeq	Lres4
	lea	_protorp,a0		| CRP prototype
	movl	d0,a0@@(4)		| stash USTP
	pmove	a0@@,crp			| load new user root pointer
	jra	Lres5
Lres4:
	.word	0x4e7b,0x0806	| movc d0,URP
Lres5:
d1854 1
d1858 1
a1858 1
	movl	#DC_CLEAR,d0
d1868 1
@


1.26
log
@Start of support for UVM. interrupt counters and kmem_free -> uvm_km_free.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.25 1999/01/20 12:04:01 niklas Exp $	*/
d1231 1
a1231 1
	jbsr	_uvm_km_free		! deallocate it
d1382 1
a1382 1
	movl	a0@@(P_VMSPACE),a0	| vmspace = p->p_vmspace
d1384 1
a1384 1
	tstl	a0			| map == VM_MAP_NULL?
d1387 2
a1388 2
	movl	a0@@(VM_PMAP),a0		| pmap = vmspace->vm_map.pmap
	tstl	a0@@(PM_STCHG)		| pmap->st_changed?
d1390 3
a1392 4
	pea	a1@@			| push pcb (at p_addr)
	pea	a0@@			| push pmap
	jbsr	_pmap_activate		| pmap_activate(pmap, pcb)
	addql	#8,sp
@


1.25
log
@Remove stack reset that was incompatible with kthread rfork use
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.24 1997/09/19 17:16:12 niklas Exp $	*/
d468 3
d472 1
d500 3
d504 1
d538 3
d542 1
d559 3
d563 1
d578 3
d582 1
d602 3
d606 1
d692 5
a696 1
	addql	#1,_cnt+V_INTR		| chalk up another interrupt
d751 5
a755 1
	addql	#1,_cnt+V_INTR		| chalk up another interrupt
d1192 1
a1192 1
	.globl	_whichqs,_qs,_cnt,_panic
d1230 3
d1234 1
@


1.25.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.29 2000/06/05 11:02:55 art Exp $	*/
a467 3
#ifdef UVM
	addql	#1,_uvmexp+UVMEXP_INTRS
#else
a468 1
#endif
a495 3
#ifdef UVM
	addql	#1,_uvmexp+UVMEXP_INTRS
#else
a496 1
#endif
a529 3
#ifdef UVM
	addql	#1,_uvmexp+UVMEXP_INTRS
#else
a530 1
#endif
a546 3
#ifdef UVM
	addql	#1,_uvmexp+UVMEXP_INTRS
#else
a547 1
#endif
a561 3
#ifdef UVM
	addql	#1,_uvmexp+UVMEXP_INTRS
#else
a562 1
#endif
a581 3
#ifdef UVM
	addql	#1,_uvmexp+UVMEXP_INTRS
#else
a582 1
#endif
d668 1
a668 5
#ifdef UVM
	addql	#1,_uvmexp+UVMEXP_INTRS
#else
	addql	#1,_cnt+V_INTR
#endif
d723 1
a723 5
#ifdef UVM
	addql	#1,_uvmexp+UVMEXP_INTRS
#else
	addql	#1,_cnt+V_INTR
#endif
d1160 1
a1160 1
	.globl	_whichqs,_qs,_panic
d1194 6
a1199 4
        /* Schedule the vmspace and stack to be freed. */
	movl    a0,sp@@-                 | exit2(p)
	jbsr    _C_LABEL(exit2)
	lea     sp@@(4),sp               | pop args
d1345 13
a1357 8
	/*
	 * Activate process's address space.
	 * XXX Should remember the last USTP value loaded, and call this
	 * XXX only if it has changed.
	 */
	pea	a0@@			| push proc
	jbsr	_pmap_activate		| pmap_activate(p)
	addql	#4,sp
d1359 1
a1359 1

d1361 30
a1390 1

a1851 1
	pflusha				| flush entire TLB
d1855 1
a1855 1
	movl	#CACHE_CLR,d0
a1864 1
	.word	0xf518
@


1.25.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.25.6.1 2001/04/18 16:01:56 niklas Exp $	*/
d468 1
d470 3
d500 1
d502 3
d538 1
d540 3
d559 1
d561 3
d578 1
d580 3
d602 1
d604 3
d692 1
d694 3
d751 1
d753 3
@


1.25.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.25.6.2 2001/07/04 10:14:57 niklas Exp $	*/
d1146 14
d1761 6
d1832 38
@


1.25.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.25.6.3 2001/10/31 02:52:45 nate Exp $	*/
d300 1
a300 1
	jgt	_illinst		| no, treat as illinst
a955 1
	movl	#MMU_68060,a0@@
a965 1
	movl	#MMU_68060,a0@@
d1022 2
a1023 2
	cmpl	#MMU_68060,_mmutype
	jne	Lcacheon
d1066 1
a1066 1
	jgt	Lnoflush		| no, skip
a1068 1
#ifdef M68060
d1070 2
a1071 2
|	cmpl	#MMU_68060,_mmutype
|	jne	Lnoflush
a1074 1
#endif
d1287 1
a1287 1
	movl	_caddr2_pte,a1@@(PCB_CMAP2)	| save temporary map PTE
d1296 2
a1297 2
	cmpl	#MMU_68060,_mmutype	| is 68060?
	jeq	Lsavfp60
d1341 1
a1341 1
	movl	a1@@(PCB_CMAP2),_caddr2_pte	| reload tmp map
d1356 2
a1357 2
	cmpl	#MMU_68060,_mmutype
	jeq	Lresfp60rest1
d1395 1
a1395 1
	movl	_caddr2_pte,a1@@(PCB_CMAP2)	| save temporary map PTE
d1404 2
a1405 2
	cmpl	#MMU_68060,_mmutype
	jeq	Lsavctx60
d1430 83
d1518 1
a1518 1
	jle	Ltbia040
d1529 2
a1530 2
	cmpl	#MMU_68060,_mmutype
	jne	Ltbiano60
d1548 1
a1548 1
	jle	Ltbis040
d1566 2
a1567 2
	cmpl	#MMU_68060,_mmutype
	jne	Ltbisno60
d1584 1
a1584 1
	jle	Ltbias040
d1598 2
a1599 2
	cmpl	#MMU_68060,_mmutype
	jne	Ltbiasno60
d1616 1
a1616 1
	jle	Ltbiau040
d1630 2
a1631 2
	cmpl	#MMU_68060,_mmutype
	jne	Ltbiauno60
d1647 1
a1647 1
	jle	Licia040
d1669 1
a1669 1
	jgt	Ldciax
d1677 1
a1677 1
	jgt	Ldcisx
d1686 1
a1686 1
	jgt	Ldciux
d1695 1
a1695 1
	jle	Ldciasx
d1734 1
a1734 1
	jle	Lpcia040
d1791 2
a1792 2
	cmpl	#MMU_68060,_mmutype
	jeq	Lldustp060
d1824 2
a1825 2
	cmpl	#MMU_68060,_mmutype
	jeq	Lm68060fpsave
d1851 2
a1852 2
	cmpl	#MMU_68060,_mmutype
	jeq	Lm68060fprestore
d1884 1
a1884 1
	jgt	Ldoboot0
d1926 1
a1926 1
 	jle	Lmmuoff040
d2024 1
a2024 1
	jgt	Lreload1
d2055 1
a2055 1
	jle	Lreload040
@


1.25.6.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d235 1
a235 1
					| (we dont separate data/program)
d1111 39
d1305 2
a1306 2
	fmovem	fp0-fp7,a2@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a2@@(FPF_FPCR)	| save FP control registers
d1315 4
a1318 4
	fmovem	fp0-fp7,a2@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr,a2@@(FPF_FPCR)	| save FP control registers
	fmovem	fpsr,a2@@(FPF_FPSR)
	fmovem	fpi,a2@@(FPF_FPI)
d1365 2
a1366 2
	fmovem	a0@@(FPF_FPCR),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
d1378 4
a1381 4
	fmovem	a0@@(FPF_FPCR),fpcr	| restore FP control registers
	fmovem	a0@@(FPF_FPSR),fpsr
	fmovem	a0@@(FPF_FPI),fpi
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
d1413 2
a1414 2
	fmovem	fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr/fpsr/fpi,a0@@(FPF_FPCR)	| save FP control registers
d1424 4
a1427 4
	fmovem	fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr,a0@@(FPF_FPCR)	| save FP control registers
	fmovem	fpsr,a0@@(FPF_FPSR)
	fmovem	fpi,a0@@(FPF_FPI)
d1750 2
a1751 2
	fmovem fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem fpcr/fpsr/fpi,a0@@(FPF_FPCR)	| save FP control registers
d1760 4
a1763 4
	fmovem fp0-fp7,a0@@(FPF_REGS)	| save FP general registers
	fmovem	fpcr,a0@@(FPF_FPCR)	| save FP control registers
	fmovem	fpsr,a0@@(FPF_FPSR)
	fmovem	fpi,a0@@(FPF_FPI)
d1777 2
a1778 2
	fmovem	a0@@(FPF_FPCR),fpcr/fpsr/fpi	| restore FP control registers
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
d1788 4
a1791 4
	fmovem	a0@@(FPF_FPCR),fpcr	| restore FP control registers
	fmovem	a0@@(FPF_FPSR),fpsr
	fmovem	a0@@(FPF_FPI),fpi
	fmovem	a0@@(FPF_REGS),fp0-fp7	| restore FP general registers
@


1.25.6.6
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.25.6.5 2002/03/06 00:56:18 niklas Exp $	*/
@


1.24
log
@Kill FPCOPROC (and some forgotten {SWAP,DEV}PAGER)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.23 1997/09/18 13:39:35 niklas Exp $	*/
d1084 1
a1084 4
 * and then rei.  Note we restore the stack before calling thus giving
 * "a2" more stack  (e.g. if curproc had a deeply nested call chain...)
 * cpu_fork() also depends on struct frame being a second arg to the
 * function in a2.
a1087 1
	movl	a3@@(P_MD_REGS),sp	| frame pointer of process in sp
d1093 1
a1093 1
	moveml	sp@@+,#0x7FFF		| restore all but sp
@


1.23
log
@Merge of NetBSD changes upto last week or so, with the exception of stand/
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.22 1997/07/20 07:35:37 niklas Exp $	*/
a320 1
#ifdef FPCOPROC
a345 3
#else
	jra	_badtrap	| treat as an unexpected trap
#endif
a1005 1
#ifdef FPCOPROC
a1010 1
#endif
a1307 1
#ifdef FPCOPROC
a1336 1
#endif
a1398 1
#ifdef FPCOPROC
a1437 1
#endif
a1449 1
#ifdef FPCOPROC
a1478 1
#endif
a1909 1
#ifdef FPCOPROC
a1969 1
#endif
@


1.22
log
@Merge common m68k trap handling changes from NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: locore.s,v 1.21 1997/04/29 00:46:27 michaels Exp $	*/
/*	$NetBSD: locore.s,v 1.72 1996/12/17 11:09:10 is Exp $	*/
d54 1
d957 2
a958 1
	btst	#7,sp@@(3)		| XXX
d960 1
d962 19
d1013 3
a1015 3
	pea	a1@@(PCB_FPCTX)
	jbsr	_m68881_restore		| restore it (does not kill a1)
	addql	#4,sp
a1106 1

d1108 1
a1108 12
 * Signal "trampoline" code (18 bytes).  Invoked from RTE setup by sendsig().
 *
 * Stack looks like:
 *
 *	sp+0 ->	signal number
 *	sp+4	pointer to siginfo (sip)
 *	sp+8	pointer to signal context frame (scp)
 *	sp+16	address of handler
 *	sp+30	saved hardware state
 *			.
 *			.
 *	scp+0->	beginning of signal context frame
d1110 1
a1110 12
	.globl	_sigcode, _esigcode
	.data
_sigcode:
	movl	sp@@(12),a0		| signal handler addr	(4 bytes)
	jsr	a0@@			| call signal handler	(2 bytes)
	addql	#4,sp			| pop signo		(2 bytes)
	trap	#1			| special syscall entry	(2 bytes)
	movl	d0,sp@@(4)		| save errno		(4 bytes)
	moveq	#1,d0			| syscall == exit	(2 bytes)
	trap	#0			| exit(errno)		(2 bytes)
	.align	2
_esigcode:
d1115 1
a1115 1
#include <m68k/asm.h>
a1154 1
#include <m68k/m68k/support.s>
d1156 1
d1158 1
a1158 7
 * The following primitives manipulate the run queues.
 * _whichqs tells which of the 32 queues _qs have processes
 * in them.  Setrunqueue puts processes into queues, remrunqueue
 * removes them from queues.  The running process is on no queue,
 * other processes are on a queue related to p->p_priority, divided by 4
 * actually to shrink the 0-127 range of priorities into the 32 available
 * queues.
d1160 10
a1169 1

d1175 1
a1175 35
 * Setrunqueue(p)
 *
 * Call should be made at spl6(), and p->p_stat should be SRUN
 */
ENTRY(setrunqueue)
	movl	sp@@(4),a0
	tstl	a0@@(P_BACK)
	jeq	Lset1
	movl	#Lset2,sp@@-
	jbsr	_panic
Lset1:
	clrl	d0
	movb	a0@@(P_PRIORITY),d0
	lsrb	#2,d0
	movl	_whichqs,d1
	bset	d0,d1
	movl	d1,_whichqs
	lslb	#3,d0
	addl	#_qs,d0
	movl	d0,a0@@(P_FORW)
	movl	d0,a1
	movl	a1@@(P_BACK),a0@@(P_BACK)
	movl	a0,a1@@(P_BACK)
	movl	a0@@(P_BACK),a1
	movl	a0,a1@@(P_FORW)
	rts

Lset2:
	.asciz	"setrunqueue"
	.even

/*
 * remrunqueue(p)
 *
 * Call should be made at spl6().
d1177 1
a1177 28
ENTRY(remrunqueue)
	movl	sp@@(4),a0
	clrl	d0
	movb	a0@@(P_PRIORITY),d0
	lsrb	#2,d0
	movl	_whichqs,d1
	bclr	d0,d1
	jne	Lrem1
	movl	#Lrem3,sp@@-
	jbsr	_panic
Lrem1:
	movl	d1,_whichqs
	movl	a0@@(P_FORW),a1
	movl	a0@@(P_BACK),a1@@(P_BACK)
	movl	a0@@(P_BACK),a1
	movl	a0@@(P_FORW),a1@@(P_FORW)
	movl	#_qs,a1
	movl	d0,d1
	lslb	#3,d1
	addl	d1,a1
	cmpl	a1@@(P_FORW),a1
	jeq	Lrem2
	movl	_whichqs,d1
	bset	d0,d1
	movl	d1,_whichqs
Lrem2:
	clrl	a0@@(P_BACK)
	rts
a1178 2
Lrem3:
	.asciz	"remrunqueue"
d1180 1
a1180 1
	.asciz	"cpu_switch"
d1315 4
d1363 1
a1363 1
	lea	a0@@(VM_PMAP),a0		| pmap = &vmspace.vm_pmap
d1408 8
d1461 4
d2229 1
a2229 1
	.long	0
d2231 3
a2233 1
	.long	0
d2235 1
a2235 1
	.long	0
d2289 3
d2306 3
@


1.21
log
@disable the datacache on Apollo cards for this release it would seem.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.20 1997/03/27 12:06:45 niklas Exp $	*/
d53 2
d106 1
d109 3
a111 6
_buserr:
	tstl	_nofault		| device probe?
	jeq	_addrerr		| no, handle as usual
	movl	_nofault,sp@@-		| yes,
	jbsr	_longjmp		|  longjmp(nofault)
_addrerr:
d116 1
a116 4
	lea	sp@@(FR_HW),a1		| grab base of HW berr frame
	cmpl	#MMU_68040,_mmutype
	jne	Lbe030
	movl	a1@@(8),sp@@-		| V = exception address
d118 12
a129 9
	moveq	#0,d0
	movw	a1@@(6),d0		| get vector offset
	andw	#0x0fff,d0
	cmpw	#12,d0			| is it address error
	jeq	Lisaerr
#ifdef M68060
	btst	#7,_machineid+3		| is it 68060?
	jeq	Lbe040
	movel	a1@@(12),d0		| FSLW
d136 1
d138 1
a138 2
	addql	#1,L60bpe
	jeq	Lbpedone
a139 1
	movl	d0,sp@@			| code is FSLW now.
d141 1
a141 1
	movl	a1@@(8),d1		| grab VA
a146 1
					| XXX instr. case not done yet
d149 2
a150 1
	movl	d1,sp@@(4)
d153 2
a154 2
	jra	Lismerr
Lbe040:
d156 8
a163 1
	movl	a1@@(20),d1		| get fault address
d165 1
a165 1
	movw	a1@@(12),d0		| get SSW
d171 2
a172 2
	movl	d1,sp@@(4)		| pass fault address.
	movl	d0,sp@@			| pass SSW as code
d175 13
a187 2
	jra	Lismerr
Lbe030:
d189 1
a189 1
	movw	a1@@(10),d0		| grab SSW for fault processing
d193 1
a193 1
	movw	d0,a1@@(10)		| for hardware too
d198 1
a198 1
	movw	d0,a1@@(10)		| for hardware too
d202 1
a202 1
	movl	a1@@(16),d1		| fault address is as given in frame
d205 1
a205 1
	btst	#4,a1@@(6)		| long (type B) stack frame?
d207 1
a207 1
	movl	a1@@(2),d1		| no, can use save PC
d218 1
a218 1
	movl	a1@@(36),d1		| long format, use stage B address
d225 1
a225 1
	movw	a1@@(6),d0		| get frame format/vector offset
d235 1
a235 1
	btst	#5,a1@@			| supervisor mode?
d256 1
a256 1
	jra	Ltrapnstkadj		| and deal with it
d259 1
a259 1
	jra	Ltrapnstkadj		| and deal with it
d262 8
a269 1
Lisberr:
d271 1
a271 22
Ltrapnstkadj:
	jbsr	_trap			| handle the error
Lbpedone:
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore user SP
	movl	a0,usp			|   from save area
	movw	sp@@(FR_ADJ),d0		| need to adjust stack?
	jne	Lstkadj			| yes, go to it
	moveml	sp@@+,#0x7FFF		| no, restore most user regs
	addql	#8,sp			| toss SSP and stkadj
	jra	rei			| all done
Lstkadj:
	lea	sp@@(FR_HW),a1		| pointer to HW frame
	addql	#8,a1			| source pointer
	movl	a1,a0			| source
	addw	d0,a0			|  + hole size = dest pointer
	movl	a1@@-,a0@@-		| copy
	movl	a1@@-,a0@@-		|  8 bytes
	movl	a0,sp@@(FR_SP)		| new SSP
	moveml	sp@@+,#0x7FFF		| restore user registers
	movl	sp@@,sp			| and our SP
	jra	rei			| all done
d283 7
a289 1
#else
d292 1
a292 1
	moveq	#T_FPEMULI,d0		| denote as FP emulation trap
d295 1
a295 4
#else
	jra	_illinst
#endif

d306 1
a306 1
	moveq	#T_FPEMULD,d0		| denote as FP emulation trap
a316 5
 *
 * XXX I don't really understand what they do for the 68881/82, for which
 * I dont have docs at the moment. I don't find anything which looks like
 * it is intended in the 68040 FP docs. I pretend for the moment I don't
 * need to do anything for the 68060. -is
d329 1
d341 1
d345 1
a345 1
	jra	Ltrapnstkadj	| call trap and deal with stack cleanup
a350 25
 * Coprocessor and format errors can generate mid-instruction stack
 * frames and cause signal delivery hence we need to check for potential
 * stack adjustment.
 */
_coperr:
	clrl	sp@@-		| stack adjust count
	moveml	#0xFFFF,sp@@-
	movl	usp,a0		| get and save
	movl	a0,sp@@(FR_SP)	|   the user stack pointer
	clrl	sp@@-		| no VA arg
	clrl	sp@@-		| or code arg
	movl	#T_COPERR,sp@@-	| push trap type
	jra	Ltrapnstkadj	| call trap and deal with stack adjustments

_fmterr:
	clrl	sp@@-		| stack adjust count
	moveml	#0xFFFF,sp@@-
	movl	usp,a0		| get and save
	movl	a0,sp@@(FR_SP)	|   the user stack pointer
	clrl	sp@@-		| no VA arg
	clrl	sp@@-		| or code arg
	movl	#T_FMTERR,sp@@-	| push trap type
	jra	Ltrapnstkadj	| call trap and deal with stack adjustments

/*
a353 44
_illinst:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_ILLINST,d0
	jra	fault

_zerodiv:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_ZERODIV,d0
	jra	fault

_chkinst:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_CHKINST,d0
	jra	fault

_trapvinst:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_TRAPVINST,d0
	jra	fault

_privinst:
	clrl	sp@@-
	moveml	#0xFFFF,sp@@-
	moveq	#T_PRIVINST,d0
	jra	fault

	.globl	fault
fault:
	movl	usp,a0			| get and save
	movl	a0,sp@@(FR_SP)		|   the user stack pointer
	clrl	sp@@-			| no VA arg
	clrl	sp@@-			| or code arg
	movl	d0,sp@@-			| push trap type
	jbsr	_trap			| handle trap
	lea	sp@@(12),sp		| pop value args
	movl	sp@@(FR_SP),a0		| restore
	movl	a0,usp			|   user SP
	moveml	sp@@+,#0x7FFF		| restore most user regs
	addql	#8,sp			| pop SP and stack adjust
	jra	rei			| all done
@


1.20
log
@Use P_MD_REGS instead of P_MD + MD_REGS (consistent with hp300)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.19 1997/03/26 21:51:31 niklas Exp $	*/
d1061 1
a1062 2

	
d1064 1
d1069 1
a1069 1
	.word	0xf4f8		| cpusha bc - push & invalidate caches
d1078 4
@


1.19
log
@Got rid of an unused function
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.17 1997/02/22 00:28:57 niklas Exp $	*/
d1103 1
a1103 1
	movl	sp,a0@@(P_MD + MD_REGS)	| save frame for proc0
d1137 1
a1137 1
	movl	a3@@(P_MD + MD_REGS),sp	| frame pointer of process in sp
@


1.18
log
@use support.s from m68k/
@
text
@a1219 9
ENTRY(qsetjmp)
	movl	sp@@(4),a0	| savearea pointer
	lea	a0@@(40),a0	| skip regs we do not save
	movl	a6,a0@@+		| save FP
	movl	sp,a0@@+		| save SP
	movl	sp@@,a0@@		| and return address
	moveq	#0,d0		| return 0
	rts

@


1.17
log
@Set MMU/CPU better, except for 060 as that requires intrusive changes
elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.16 1997/02/21 08:55:14 niklas Exp $	*/
d1218 1
a1218 9
/*
 * non-local gotos
 */
ENTRY(setjmp)
	movl	sp@@(4),a0	| savearea pointer
	moveml	#0xFCFC,a0@@	| save d2-d7/a2-a7
	movl	sp@@,a0@@(48)	| and return address
	moveq	#0,d0		| return 0
	rts
a1228 7
ENTRY(longjmp)
	movl	sp@@(4),a0
	moveml	a0@@+,#0xFCFC
	movl	a0@@,sp@@
	moveq	#1,d0
	rts

a2035 24
	rts

ENTRY(_insque)
	movw	sr,d0
	movw	#PSL_HIGHIPL,sr		| atomic
	movl	sp@@(8),a0		| where to insert (after)
	movl	sp@@(4),a1		| element to insert (e)
	movl	a0@@,a1@@			| e->next = after->next
	movl	a0,a1@@(4)		| e->prev = after
	movl	a1,a0@@			| after->next = e
	movl	a1@@,a0
	movl	a1,a0@@(4)		| e->next->prev = e
	movw	d0,sr
	rts

ENTRY(_remque)
	movw	sr,d0
	movw	#PSL_HIGHIPL,sr		| atomic
	movl	sp@@(4),a0		| element to remove (e)
	movl	a0@@,a1
	movl	a0@@(4),a0
	movl	a0,a1@@(4)		| e->next->prev = e->prev
	movl	a1,a0@@			| e->prev->next = e->next
	movw	d0,sr
@


1.16
log
@copypage/zeropage adaption. cputype setting needs more work.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.15 1997/02/03 15:05:04 deraadt Exp $	*/
d1000 1
d1004 2
a1005 1
	movl	#-1,a0@@			| assume 020 means 851
d1011 2
a1012 1
	movl	#1,a0@@
d1019 2
a1020 3
	RELOC(_cputype, a0)
	movl	#CPU_68040,a0@@
	.word	0xf4f8			| cpusha bc - push and invalidate caches
@


1.15
log
@More siginfo implementations (alpha and mips might even work)
move "siginfo_t *" to 2nd arg of signal handler as 1003.1b requires.
I really wish I had 1003.1b documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.14 1997/02/03 11:38:05 deraadt Exp $	*/
d1016 2
a1178 30
 * copypage(fromaddr, toaddr)
 *
 * Optimized version of bcopy for a single page-aligned NBPG byte copy.
 * dbra will work better perhaps.
 */
ENTRY(copypage)
	movl	sp@@(4),a0		| source address
	movl	sp@@(8),a1		| destination address
	movl	#NBPG/32,d0		| number of 32 byte chunks
	cmpl	#MMU_68040,_mmutype
	jne	Lmlloop			| no, use movl
Lm16loop:
	.long	0xf6209000		| move16 a0@@+,a1@@+
	.long	0xf6209000		| move16 a0@@+,a1@@+
	subql	#1,d0
	jne	Lm16loop
	rts
Lmlloop:
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	subql	#1,d0
	jne	Lmlloop
	rts
/*
d2380 1
a2380 1
	.globl	_mmutype,_fputype,_protorp
d2382 2
@


1.14
log
@SA_SIGINFO implementation
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.13 1997/01/16 09:23:22 niklas Exp $	*/
d1150 1
a1150 1
 *	sp+4	signal specific code
a1151 1
 *	sp+12	pointer to siginfo (sip)
d1161 1
a1161 1
	movl	sp@@(16),a0		| signal handler addr	(4 bytes)
@


1.13
log
@Sync to NetBSD 970110
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.12 1996/11/23 23:19:27 kstailey Exp $	*/
d1152 3
a1154 2
 *	sp+12	address of handler
 *	sp+16	saved hardware state
d1162 1
a1162 1
	movl	sp@@(12),a0		| signal handler addr	(4 bytes)
@


1.12
log
@remrq -> remrunqueue
@
text
@d1 2
a2 2
/*	$OpenBSD: locore.s,v 1.11 1996/08/19 00:04:14 niklas Exp $	*/
/*	$NetBSD: locore.s,v 1.56.2.2 1996/06/14 11:20:45 is Exp $	*/
d63 1
a63 1
	
d74 1
a74 1
#define	INTENARADDR(ar)	movl	_INTENARaddr,ar
d133 1
a133 1
	orl	#0x00400000,d2		| clear all branch cache entries
d137 1
d224 2
a225 2
	movl	sp@@,d1
	btst	#26,d1			| invalid (incl. limit viol. and berr)?
d227 1
a227 1
	btst	#31,d1			| is it MMU table berr?
d231 1
a231 1
	btst	#27,d1			| write protect bit set?
d233 3
a235 3
					| ssw is in low word of d1
	andw	#0xc0,d1		| Write protect is set on page:
	cmpw	#0x40,d1		| was it read cycle?
d547 1
a547 2
	tstb	d0			| check if CIAB was source
	jeq	Ldrintrcommon
d567 35
d709 1
a709 2
	tstb	d0			| check if CIAB was source
	jeq	Lchkexter		| no, go through isr chain
d1020 1
a1020 1
	orl	#0x400000,d0		| XXX and clear all 060 branch cache 
d1067 5
d1111 6
a1116 5
	btst	#7,_machineid+3
	jeq	Lnoflush
	movc	cacr,d0
	orl	#200000,d0
	movc	d0,cacr
d1272 2
a1273 2
 * _whichqs tells which of the 32 queues _qs
 * have processes in them.  Setrunqueue puts processes into queues, Remrq
d1317 1
a1317 1
 * Remrq(p)
d1556 1
a1556 1
	orl	#0x00200000,d2		| clear user branch cache entries
d1755 1
a1755 1
	orl	#0x400000,d0	| and clear all branch cache entries
d1792 1
a1792 1
	orl	#0x400000,d0	| and clear all branch cache entries
d1824 1
a1824 1
	orl	#0x400000,d0	| and clear all branch cache entries
d1856 1
a1856 1
	orl	#0x200000,d0	| but only user branch cache entries
d2034 1
a2034 1
	orl	#0x200000,d1	| clear user branch cache entries
d2038 1
a2038 1
	.word	0x4e7b,0x0806	| movec d0,URP
d2065 1
a2065 1
	orl	#0x200000,d1	| clear user branch cache entries
d2114 1
a2114 1
	btst	#7,_machineid
d2141 1
a2141 1
	btst	#7,_machineid
d2374 30
d2408 5
a2412 1
	.globl	_mmutype,_protorp
d2421 6
d2459 7
d2473 7
@


1.11
log
@Merge of Late July NetBSD sources (mostly DRACO support).  More to come...
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.10 1996/05/29 10:14:27 niklas Exp $	*/
d1281 1
a1281 1
ENTRY(remrq)
d1311 1
a1311 1
	.asciz	"remrq"
@


1.10
log
@Merge of 960526 NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: locore.s,v 1.9 1996/05/07 09:58:36 niklas Exp $	*/
/*	$NetBSD: locore.s,v 1.56 1996/05/21 18:22:13 is Exp $	*/
d212 10
a221 1
	ptestr	#1,a0@@,#7		| do a table search
d223 13
a235 4
	btst	#7,sp@@			| bus error bit set?
	jeq	Lismerr			| no, must be MMU fault
	clrw	sp@@			| yes, re-clear pad word
	jra	Lisberr			| and process as normal bus error
d242 2
d547 1
a547 1
	jeq	Lintrcommon
d567 16
d584 1
a605 1
/* XXX on the DraCo, lev 4, 5 and 6 are vectored here by initcpu() */
d731 1
a731 1
/* XXX endifndef DRACO used to be here */
d920 1
d932 1
d1512 7
d1810 1
a1810 1
| 68040 can't specify supervisor/user on pflusha, so we flush all
d2370 9
d2383 4
@


1.9
log
@Use _vectab instead of Lvectab, which is moving to .data

From NetBSD:
Add floppy index interrupt processing.

Startup modified to work with kernel loaded directly into fast memory.
This removes the need to have enough chip memory to load the kernel
when booting.  Kernel memory is dual-mapped (VA == 0 and VA == PA)
for enabling the MMU, and the VA == PA mapping removed after start_c()
has completed.  Chip memory is still required for the /dev/reload
process.
@
text
@d1 2
a2 2
/*	$OpenBSD: locore.s,v 1.5 1996/02/26 21:31:00 niklas Exp $	*/
/*	$NetBSD: locore.s,v 1.52 1996/05/04 04:43:23 mhitch Exp $	*/
d53 2
d64 4
d126 30
d167 1
a167 1
	jeq	Lisberr			| it's a bus error
d228 1
d290 5
d307 6
a312 1
	tstb	a0@@		| null state frame?
d519 30
d569 1
d595 2
d695 1
d807 5
d813 3
d859 1
a859 1
	| save the passed parameters. `prepass' them on the stack for
d873 36
d918 3
d942 1
a942 1
	jeq	Lstartnot040		| it's not 68040
d944 1
a944 1
	.word	0xf4f8		| cpusha bc - push and invalidate caches
d946 3
d966 2
a967 1
|	lea	tmpstk,sp		| give ourselves a temporary stack
d969 1
d986 2
a998 1

d1026 1
d1029 1
d1034 5
d1055 1
a1055 1
	movl	a3@@(P_MD + MD_REGS),sp	| process' frame pointer in sp
d1301 1
a1301 1
	movl	a0@@(P_ADDR),sp@@-	| address of process's u-area
d1412 5
d1421 13
d1472 2
a1473 2
	movl	#CACHE40_ON,d0
	movc	d0,cacr			| invalidate cache(s)
d1493 5
d1504 3
d1508 11
d1522 2
d1539 5
d1548 14
d1666 8
d1703 8
d1733 1
a1733 1
| 68040 can't specify supervisor/user on pflusha, so we flush all
d1735 8
d1767 8
d1783 1
a1783 1
#if defined(M68040)
d1792 2
a1793 2
#if defined(M68040)
	.word	0xf498		| cinva ic
d1838 1
a1838 1
#ifdef M68040
d1870 1
a1870 1
#if defined(M68040)
d1878 1
a1878 1
#if defined(M68040)
d1934 4
d1946 6
d1962 4
d1977 8
d2027 5
d2038 13
d2054 5
d2068 14
d2099 5
d2163 28
d2192 17
@


1.8
log
@Remove small glitch in last commit
@
text
@d2 1
a2 1
/*	$NetBSD: locore.s,v 1.51 1996/05/02 02:08:33 mhitch Exp $	*/
d53 1
d60 1
d456 1
a456 1
 *	Level 6:	Clock (CIA-B-Timers) + External devices
d569 3
a571 3
	jeq     Lskipciab		| no
| save d0 if we want to check other CIAB interrupts?
	lea	sp@@(16),a1		| get pointer to PS
d576 6
d583 2
a584 1
| process any other CIAB interrupts?
d746 4
d755 6
d762 1
a762 3
	.word	0x0002			| loadbsd version required
					| 2: needs a4 = esym
					| XXX should be a symbol?
d764 2
d767 2
a768 1
	lea	tmpstk,sp		| give ourselves a temporary stack
d784 8
a791 4
	movl	#0x400,_chipmem_start
	movl	#0xbfe001,_CIAAbase
	movl	#0xbfd000,_CIABbase
	movl	#0xdff000,_CUSTOMbase
d796 2
a797 1
	movl	d4,_eclockfreq
d799 1
d803 1
a803 1
	movl	#-1,_mmutype		| assume 020 means 851
d809 1
a809 1
	movl	#1,_mmutype
d815 1
a815 1
	movl	#MMU_68040,_mmutype	| same as hp300 for compat
d820 1
a820 1
	movl	#Lvectab,a0
d829 2
a830 1
	jsr	_start_c
d832 1
d834 3
@


1.7
log
@From NetBSD:
Add a check in the kernel reload device (/dev/reload) to protect
against the MMU switch code being in different locations between
the running kernel and the new kernel.  Returns ENODEV if the reload
fails.
Change the error return from EFAULT to ENOEXEC when kernel_reload
gets a short write on the exec header.
@
text
@d844 1
a844 1
 * set to "mi_main()".  "mi_main()" will do an "execve()" using that
d846 1
a846 1
 * When "mi_main()" returns, we're running in process 1 and have
d861 1
a861 1
	jbsr	_mi_main		| mi_main(firstaddr, r0)
@


1.6
log
@Sync with NetBSD 9600430.  The port has gone over a major -Wall treat
@
text
@d2 1
a2 1
/*	$NetBSD: locore.s,v 1.50 1996/04/21 21:07:04 veego Exp $	*/
d844 1
a844 1
 * set to "main()".  "main()" will do an "execve()" using that
d846 1
a846 1
 * When "main()" returns, we're running in process 1 and have
d861 1
a861 1
	jbsr	_main			| main(firstaddr, r0)
d1845 8
@


1.5
log
@From NetBSD: assym.s -> assym.h
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: locore.s,v 1.48 1995/12/11 02:37:59 thorpej Exp $	*/
d442 2
a443 36
/*
 * The sigreturn() syscall comes here.  It requires special handling
 * because we must open a hole in the stack to fill in the (possibly much
 * larger) original stack frame.
 */
sigreturn:
	lea	sp@@(-84),sp		| leave enough space for largest frame
	movl	sp@@(84),sp@@		| move up current 8 byte frame
	movl	sp@@(88),sp@@(4)
	movl	#84,sp@@-		| default: adjust by 84 bytes
	moveml	#0xFFFF,sp@@-		| save user registers
	movl	usp,a0			| save the user SP
	movl	a0,sp@@(FR_SP)		|   in the savearea
	movl	#SYS_sigreturn,sp@@-	| push syscall number
	jbsr	_syscall		| handle it
	addql	#4,sp			| pop syscall#
	movl	sp@@(FR_SP),a0		| grab and restore
	movl	a0,usp			|   user SP
	lea	sp@@(FR_HW),a1		| pointer to HW frame
	movw	sp@@(FR_ADJ),d0		| do we need to adjust the stack?
	jeq	Lsigr1			| no, just continue
	moveq	#92,d1			| total size
	subw	d0,d1			|  - hole size = frame size
	lea	a1@@(92),a0		| destination
	addw	d1,a1			| source
	lsrw	#1,d1			| convert to word count
	subqw	#1,d1			| minus 1 for dbf
Lsigrlp:
	movw	a1@@-,a0@@-		| copy a word
	dbf	d1,Lsigrlp		| continue
	movl	a0,a1			| new HW frame base
Lsigr1:
	movl	a1,sp@@(FR_SP)		| new SP value
	moveml	sp@@+,#0x7FFF		| restore user registers
	movl	sp@@,sp			| and our SP
	jra	rei			| all done
@


1.4
log
@Added support for a new (well, I've run it locally for a year or two)
interrupt system which is a prerequisite for the Amiga ISA support.
It is described in amiga/amiga/README.ints, and is enabled by adding
an "options IPL_REMAP_1" in the kernel config file.  Along with this
change there is also some generic cleanup, like style polishing,
comment corrections, making sicallbacks operate in FIFO manner and
cleaning up the spl mess in param.h...
@
text
@d1 1
d51 1
a51 1
#include "assym.s"
@


1.3
log
@from netbsd; bcopy moves to m68k tree
@
text
@d46 2
a47 1
 * Other contributors: Bryan Ford (kernel reload stuff)
d57 2
a58 1

d64 2
a65 2
#define INTENAWADDR(ar) movl	_amiga_intena_write,ar
#define	INTENARADDR(ar)	movl	_amiga_intena_read,ar
d482 2
a483 2
 *	Level 1:	builtin-RS232 TBE, softint (not used yet)
 *	Level 2:	keyboard (CIA-A) + DMA + SCSI
d485 1
a485 1
 *	Level 4:	not used
d487 1
a487 1
 *	Level 6:	Clock (CIA-B-Timers)
d495 2
a496 1
	.globl	_intrhand, _hardclock
a504 1
#include "ser.h"
d522 1
a522 1
	moveml	#0xC0C0,sp@@-
d532 1
a532 1
	moveml	sp@@+,#0x0303
d536 12
d549 1
d556 1
a556 1
	moveml	#0x8080,sp@@-
d566 1
a566 1
	moveml	sp@@+,#0x0101
d570 1
a570 1
	moveml	sp@@+,#0x0101
d576 1
a576 1
	moveml	#0xC0C0,sp@@-
d610 1
a610 1
	moveml	sp@@+,#0x0303		| restore scratch regs
d640 29
a677 1

d703 14
d1314 1
a1314 1
	.word	0xf518		| pflusha (68040)
d1468 1
a1468 1
	.word	0xf518		| pflusha
d1494 1
a1494 1
	.word	0xf508		| pflush a0@@
d1497 1
a1497 1
	.word	0xf508		| pflush a0@@
d1521 1
a1521 1
	.word	0xf518		| pflusha
d1545 1
a1545 1
	.word	0xf518		| pflusha
d1740 1
a1740 1
Lploadw040:			| should 68040 do a ptest?
@


1.2
log
@let loadbsd define sync scsi operation
@
text
@d1 1
a1 1
/*	$NetBSD: locore.s,v 1.46.2.1 1995/11/24 07:51:10 chopps Exp $	*/
a1707 75
	rts

ENTRY(memcpy)
	movl	sp@@(12),d0		| get count
	jeq	Lcpyexit		| if zero, return
	movl	sp@@(8), a0		| src address
	movl	sp@@(4), a1		| dest address
	jra	Ldocopy			| jump into bcopy
/*
 * {ov}bcopy(from, to, len)
 *
 * Works for counts up to 128K.
 */
ALTENTRY(ovbcopy, _bcopy)
ENTRY(bcopy)
	movl	sp@@(12),d0		| get count
	jeq	Lcpyexit		| if zero, return
	movl	sp@@(4),a0		| src address
	movl	sp@@(8),a1		| dest address
Ldocopy:
	cmpl	a1,a0			| src before dest?
	jlt	Lcpyback		| yes, copy backwards (avoids overlap)
	movl	a0,d1
	btst	#0,d1			| src address odd?
	jeq	Lcfeven			| no, go check dest
	movb	a0@@+,a1@@+		| yes, copy a byte
	subql	#1,d0			| update count
	jeq	Lcpyexit		| exit if done
Lcfeven:
	movl	a1,d1
	btst	#0,d1			| dest address odd?
	jne	Lcfbyte			| yes, must copy by bytes
	movl	d0,d1			| no, get count
	lsrl	#2,d1			| convert to longwords
	jeq	Lcfbyte			| no longwords, copy bytes
	subql	#1,d1			| set up for dbf
Lcflloop:
	movl	a0@@+,a1@@+		| copy longwords
	dbf	d1,Lcflloop		| til done
	andl	#3,d0			| get remaining count
	jeq	Lcpyexit		| done if none
Lcfbyte:
	subql	#1,d0			| set up for dbf
Lcfbloop:
	movb	a0@@+,a1@@+		| copy bytes
	dbf	d0,Lcfbloop		| til done
Lcpyexit:
	rts
Lcpyback:
	addl	d0,a0			| add count to src
	addl	d0,a1			| add count to dest
	movl	a0,d1
	btst	#0,d1			| src address odd?
	jeq	Lcbeven			| no, go check dest
	movb	a0@@-,a1@@-		| yes, copy a byte
	subql	#1,d0			| update count
	jeq	Lcpyexit		| exit if done
Lcbeven:
	movl	a1,d1
	btst	#0,d1			| dest address odd?
	jne	Lcbbyte			| yes, must copy by bytes
	movl	d0,d1			| no, get count
	lsrl	#2,d1			| convert to longwords
	jeq	Lcbbyte			| no longwords, copy bytes
	subql	#1,d1			| set up for dbf
Lcblloop:
	movl	a0@@-,a1@@-		| copy longwords
	dbf	d1,Lcblloop		| til done
	andl	#3,d0			| get remaining count
	jeq	Lcpyexit		| done if none
Lcbbyte:
	subql	#1,d0			| set up for dbf
Lcbbloop:
	movb	a0@@-,a1@@-		| copy bytes
	dbf	d0,Lcbbloop		| til done
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: locore.s,v 1.46 1995/10/09 04:33:52 chopps Exp $	*/
d728 1
d780 1
a780 1
	addl	#16,sp
d1919 1
d1923 1
a1923 1
	movel	sp@@(4),a2		| copy kernel to low chip memory
d1927 1
a1927 1
	movel	a2@@+,a3@@+
a1949 1
	subl	a2,a2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
