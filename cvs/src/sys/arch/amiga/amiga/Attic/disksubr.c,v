head	1.23;
access;
symbols
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	UBC_SYNC_A:1.23
	OPENBSD_3_2:1.22.0.4
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.22
	UBC:1.20.0.8
	UBC_BASE:1.20
	OPENBSD_3_0:1.20.0.6
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9:1.20.0.4
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	SMP:1.18.0.6
	SMP_BASE:1.18
	kame_19991208:1.18
	OPENBSD_2_6:1.18.0.4
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.18.0.2
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.17.0.2
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.16.0.2
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2002.12.31.16.35.36;	author miod;	state dead;
branches;
next	1.22;

1.22
date	2002.03.14.03.15.51;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.26.28;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.18.21.00.33;	author mickey;	state Exp;
branches
	1.20.8.1;
next	1.19;

1.19
date	2000.04.29.15.57.51;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	99.01.08.04.29.04;	author millert;	state Exp;
branches
	1.18.6.1;
next	1.17;

1.17
date	98.10.03.21.18.54;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	98.03.26.12.41.28;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	98.03.26.12.38.39;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	97.08.08.21.46.34;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	97.05.29.01.18.18;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.04.10.08.52.52;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.02.23.02.33.05;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.02.21.09.06.18;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.01.20.15.43.28;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.01.16.09.23.18;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.12.20.16.48.09;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.06.10.19.37.05;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.05.04.13.36.14;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.05.02.06.43.15;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.14.50;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.12.20.19.57;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.52;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.52;	author deraadt;	state Exp;
branches;
next	;

1.18.6.1
date	2001.04.18.16.01.55;	author niklas;	state Exp;
branches;
next	1.18.6.2;

1.18.6.2
date	2002.03.28.10.06.14;	author niklas;	state Exp;
branches;
next	1.18.6.3;

1.18.6.3
date	2003.03.27.23.19.16;	author niklas;	state dead;
branches;
next	;

1.20.8.1
date	2002.06.11.03.34.57;	author art;	state Exp;
branches;
next	1.20.8.2;

1.20.8.2
date	2003.05.19.21.49.37;	author tedu;	state dead;
branches;
next	;


desc
@@


1.23
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: disksubr.c,v 1.22 2002/03/14 03:15:51 millert Exp $	*/
/*	$NetBSD: disksubr.c,v 1.27 1996/10/13 03:06:34 christos Exp $	*/

/*
 * Copyright (c) 1994 Christian E. Hopps
 * Copyright (c) 1982, 1986, 1988 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <amiga/amiga/adosglue.h>

/*
 * bitmap id's
 */
#define RDBLOCK_BID	1
#define PARTBLOCK_BID	2
#define BADBLOCK_BID	3
#define FSBLOCK_BID	4
#define LSEGBLOCK_BID	5

struct rdbmap {
	long firstblk;
	long lastblk;
	int  bigtype;
	struct {
		short next;
		short prev;
		char  shortid;
	} big[0];
	struct {
		char next;
		char prev;
		char shortid;
	} tab[0];
};

#define b_cylin b_resid
#define baddr(bp) (void *)((bp)->b_un.b_addr)

u_long rdbchksum(void *);
struct adostype getadostype(u_long);
struct rdbmap *getrdbmap(dev_t, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *);

/* XXX unknown function but needed for /sys/scsi to link */
void
dk_establish(dk, dev)
	struct disk *dk;
	struct device *dev;
{
	return;
}

/*
 * Attempt to read a disk label from a device
 * using the indicated strategy routine.
 * The label must be partly set up before this:
 * secpercyl and anything required in the strategy routine
 * (e.g., sector size) must be filled in before calling us.
 * Returns null on success and an error string on failure.
 */
char *
readdisklabel(dev, strat, lp, clp, spoofonly)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *clp;
	int spoofonly;
{
	struct disklabel *dlp;
	struct adostype adt;
	struct partition *pp = NULL;
	struct partblock *pbp;
	struct rdblock *rbp;
	struct buf *bp;
	char *msg, *bcpls, *s, bcpli;
	int cindex, i, nopname;
	u_long nextb;

	clp->rdblock = RDBNULL;
	/*
	 * give some guaranteed validity to
	 * the disklabel
	 */
	if (lp->d_secperunit == 0)
		lp->d_secperunit = 0x1fffffff;
	if (lp->d_secpercyl == 0)
		lp->d_secpercyl = 0x1fffffff;
	lp->d_npartitions = RAW_PART + 1;

	for (i = 0; i < MAXPARTITIONS; i++) {
		clp->pbindex[i] = -1;
		clp->pblist[i] = RDBNULL;
		if (i == RAW_PART)
			continue;
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
	}
	if (lp->d_partitions[RAW_PART].p_size == 0)
		lp->d_partitions[RAW_PART].p_size = 0x1fffffff;
	lp->d_partitions[RAW_PART].p_offset = 0;

	/* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
		return (NULL);

	/* obtain buffer to probe drive with */
	bp = (void *)geteblk((int)lp->d_secsize);

	/*
	 * request no partition relocation by driver on I/O operations
	 */
#ifdef _KERNEL
	bp->b_dev = MAKEDISKDEV(major(dev), DISKUNIT(dev), RAW_PART);
#else
	bp->b_dev = dev;
#endif
	msg = NULL;

	/*
	 * find the RDB block
	 */
	for (nextb = 0; nextb < RDB_MAXBLOCKS; nextb++) {
		bp->b_blkno = nextb;
		bp->b_cylin = bp->b_blkno / lp->d_secpercyl;
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		strat(bp);

		if (biowait(bp)) {
			msg = "rdb scan I/O error";
			goto done;
		}
		rbp = baddr(bp);
		if (rbp->id == RDBLOCK_ID) {
			if (rdbchksum(rbp) == 0)
				break;
			else
				msg = "bad rdb checksum";
		}
	}
	if (nextb == RDB_MAXBLOCKS) {
		/*
		 * No RDB found, let's look for an OpenBSD label instead.
		 */
		bp->b_dev = dev;
		bp->b_blkno = LABELSECTOR;
		bp->b_resid = 0;			/* was b_cylin */
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		(*strat)(bp);  

		/* if successful, find disk label within block and validate */
		if (biowait(bp)) {
			msg = "disklabel read error";
			goto done;
		}

		dlp = (struct disklabel *)(bp->b_un.b_addr + LABELOFFSET);
		if (dlp->d_magic == DISKMAGIC) {
			if (dkcksum(dlp)) {
				msg = "OpenBSD disk label corrupted";
				goto done;
			}
			*lp = *dlp;
			goto done;
		}
		msg = "no rdb nor BSD disklabel found";
#if defined(CD9660)
		if (iso_disklabelspoof(dev, strat, lp) == 0)
			msg = NULL;
#endif
		goto done;
	} else if (msg) {
		/*
		 * maybe we found an invalid one before a valid.
		 * clear err.
		 */
		msg = NULL;
	}
	clp->rdblock = nextb;

	lp->d_secsize = rbp->nbytes;
	lp->d_nsectors = rbp->nsectors;
	lp->d_ntracks = rbp->nheads;
	/*
	 * should be rdb->ncylinders however this is a bogus value 
	 * sometimes it seems
	 */
	if (rbp->highcyl == 0)
		lp->d_ncylinders = rbp->ncylinders;
	else
		lp->d_ncylinders = rbp->highcyl + 1;
	/*
	 * I also don't trust rdb->secpercyl
	 */
	lp->d_secpercyl = min(rbp->secpercyl, lp->d_nsectors * lp->d_ntracks);
	if (lp->d_secpercyl == 0)
		lp->d_secpercyl = lp->d_nsectors * lp->d_ntracks;
#ifdef DIAGNOSTIC
	if (lp->d_ncylinders != rbp->ncylinders)
		printf("warning found rdb->ncylinders(%ld) != "
		    "rdb->highcyl(%ld) + 1\n", rbp->ncylinders,
		    rbp->highcyl);
	if (lp->d_nsectors * lp->d_ntracks != rbp->secpercyl)
		printf("warning found rdb->secpercyl(%ld) != "
		    "rdb->nsectors(%ld) * rdb->nheads(%ld)\n", rbp->secpercyl,
		    rbp->nsectors, rbp->nheads);
#endif
	lp->d_sparespercyl =
	    max(rbp->secpercyl, lp->d_nsectors * lp->d_ntracks) 
	    - lp->d_secpercyl;
	if (lp->d_sparespercyl == 0)
		lp->d_sparespertrack = 0;
	else {
		lp->d_sparespertrack = lp->d_sparespercyl / lp->d_ntracks;
#ifdef DIAGNOSTIC
		if (lp->d_sparespercyl % lp->d_ntracks)
			printf("warning lp->d_sparespercyl(%d) not multiple "
			    "of lp->d_ntracks(%d)\n", lp->d_sparespercyl,
			    lp->d_ntracks);
#endif
	}

	lp->d_secperunit = lp->d_secpercyl * lp->d_ncylinders;
	lp->d_acylinders = rbp->ncylinders - (rbp->highcyl - rbp->lowcyl + 1);
	lp->d_rpm = 3600; 		/* good guess I suppose. */
	lp->d_interleave = rbp->interleave;
	lp->d_headswitch = lp->d_flags = lp->d_trackskew = lp->d_cylskew = 0;
	lp->d_trkseek = /* rbp->steprate */ 0;	

	/*
	 * raw partition gets the entire disk
	 */
	lp->d_partitions[RAW_PART].p_size = rbp->ncylinders * lp->d_secpercyl;

	/*
	 * scan for partition blocks
	 */
	nopname = 1;
	cindex = 0;
	for (nextb = rbp->partbhead; nextb != RDBNULL; nextb = pbp->next) {
		bp->b_blkno = nextb;
		bp->b_cylin = bp->b_blkno / lp->d_secpercyl;
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		strat(bp);
		
		if (biowait(bp)) {
			msg = "partition scan I/O error";
			goto done;
		}
		pbp = baddr(bp);

		if (pbp->id != PARTBLOCK_ID) {
			msg = "partition block with bad id";
			goto done;
		}
		if (rdbchksum(pbp)) {
			msg = "partition block bad checksum";
			goto done;
		}

		if (pbp->e.tabsize < 11) {
			/*
			 * not enough info, too funky for us.
			 * I don't want to skip I want it fixed.
			 */
			msg = "bad partition info (environ < 11)";
			goto done;
			continue;
		}

		/*
		 * XXXX should be ">" however some vendors don't know
		 * what a table size is so, we hack for them.
		 * the other checks can fail for all I care but this
		 * is a very common value. *sigh*.
		 */
		if (pbp->e.tabsize >= 16)
			adt = getadostype(pbp->e.dostype);
		else {
			adt.archtype = ADT_UNKNOWN;
			adt.fstype = FS_UNUSED;
		}

		switch (adt.archtype) {
		case ADT_NETBSDROOT:
			pp = &lp->d_partitions[0];
			if (pp->p_size) {
				printf("WARN: more than one root, ignoring\n");
				clp->rdblock = RDBNULL;	/* invlidate cpulab */
				continue;
			}
			break;
		case ADT_NETBSDSWAP:
			pp = &lp->d_partitions[1];
			if (pp->p_size) {
				printf("WARN: more than one swap, ignoring\n");
				clp->rdblock = RDBNULL;	/* invlidate cpulab */
				continue;
			}
			break;
		case ADT_NETBSDUSER:
		case ADT_AMIGADOS:
		case ADT_AMIX:
		case ADT_EXT2:
		case ADT_UNKNOWN:
			pp = &lp->d_partitions[lp->d_npartitions];
			break;
		}
		if (lp->d_npartitions <= (pp - lp->d_partitions))
			lp->d_npartitions = (pp - lp->d_partitions) + 1;

#ifdef DIAGNOSTIC
		if (lp->d_secpercyl != (pbp->e.secpertrk * pbp->e.numheads)) {
			if (pbp->partname[0] < sizeof(pbp->partname))
				pbp->partname[pbp->partname[0] + 1] = 0;
			else
				pbp->partname[sizeof(pbp->partname) - 1] = 0;
			printf("Partition '%s' geometry %ld/%ld differs",
			    pbp->partname + 1, pbp->e.numheads,
			    pbp->e.secpertrk);
			printf(" from RDB %d/%d\n", lp->d_ntracks,
			    lp->d_nsectors);
		}
#endif
		/*
		 * insert sort in increasing offset order
		 */
		while ((pp - lp->d_partitions) > RAW_PART + 1) {
			daddr_t boff;
			
			boff = pbp->e.lowcyl * pbp->e.secpertrk
			    * pbp->e.numheads;
			if (boff > (pp - 1)->p_offset)
				break;
			*pp = *(pp - 1);	/* struct copy */
			pp--;
		}
		i = (pp - lp->d_partitions);
		if (nopname || i == 1) {
			/*
			 * either we have no packname yet or we found
			 * the swap partition. copy BCPL string into packname
			 * [the reason we use the swap partition: the user
			 *  can supply a decent packname without worry
			 *  of having to access an odly named partition 
			 *  under AmigaDos]
			 */
			s = lp->d_packname;
			bcpls = &pbp->partname[1];
			bcpli = pbp->partname[0];
			if (sizeof(lp->d_packname) <= bcpli)
				bcpli = sizeof(lp->d_packname) - 1;
			while (bcpli--)
				*s++ = *bcpls++;
			*s = 0;
			nopname = 0;
		}

		pp->p_size = (pbp->e.highcyl - pbp->e.lowcyl + 1)
		    * pbp->e.secpertrk * pbp->e.numheads;
		pp->p_offset = pbp->e.lowcyl * pbp->e.secpertrk
		    * pbp->e.numheads;
		pp->p_fstype = adt.fstype;
		if (adt.archtype == ADT_AMIGADOS) {
			/*
			 * Save reserved blocks at begin in cpg and
			 *  adjust size by reserved blocks at end
			 */
			pp->p_fsize = 512;
			pp->p_frag = pbp->e.secperblk;
			pp->p_cpg = pbp->e.resvblocks;
			pp->p_size -= pbp->e.prefac;
		} else if (pbp->e.tabsize > 22 && ISFSARCH_NETBSD(adt)) {
			pp->p_fsize = pbp->e.fsize;
			pp->p_frag = pbp->e.frag;
			pp->p_cpg = pbp->e.cpg;
		} else {
			pp->p_fsize = 1024;
			pp->p_frag = 8;
			pp->p_cpg = 0;
		}

		/*
		 * store this partitions block number
		 */
		clp->pblist[clp->pbindex[i] = cindex++] = nextb;
	}
	/*
	 * calulate new checksum.
	 */
	lp->d_magic = lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = 0;
	lp->d_checksum = dkcksum(lp);
	if (clp->rdblock != RDBNULL)
		clp->valid = 1;
done:
	if (clp->valid == 0)
		clp->rdblock = RDBNULL;
	bp->b_flags = B_INVAL | B_AGE | B_READ;
	brelse(bp);
	return (msg);
}

/*
 * Check new disk label for sensibility
 * before setting it.
 */
int
setdisklabel(olp, nlp, openmask, clp)
	struct disklabel *olp, *nlp;
	u_long openmask;
	struct cpu_disklabel *clp;
{
	int i;
	struct partition *opp, *npp;

	if (nlp->d_magic != DISKMAGIC || nlp->d_magic2 != DISKMAGIC ||
	    dkcksum(nlp) != 0)
		return (EINVAL);
	while ((i = ffs((long)openmask)) != 0) {
		i--;
		openmask &= ~(1 << i);
		if (nlp->d_npartitions <= i)
			return (EBUSY);
		opp = &olp->d_partitions[i];
		npp = &nlp->d_partitions[i];
		if (npp->p_offset != opp->p_offset ||
		    npp->p_size < opp->p_size)
			return (EBUSY);
		/*
		 * Copy internally-set partition information
		 * if new label doesn't include it.		XXX
		 */
		if (npp->p_fstype == FS_UNUSED && opp->p_fstype != FS_UNUSED) {
			npp->p_fstype = opp->p_fstype;
			npp->p_fsize = opp->p_fsize;
			npp->p_frag = opp->p_frag;
			npp->p_cpg = opp->p_cpg;
		}
	}
 	nlp->d_checksum = 0;
 	nlp->d_checksum = dkcksum(nlp);
	*olp = *nlp;
	return (0);
}

/*
 * Write disk label back to device after modification.
 * this means write out the Rigid disk blocks to represent the 
 * label.  Hope the user was careful.
 */
int
writedisklabel(dev, strat, lp, clp)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *clp;
{
	struct rdbmap *bmap;
	struct buf *bp;
	bp = NULL;	/* XXX */

	return (EINVAL);
	/*
	 * get write out partition list iff cpu_label is valid.
	 */
	if (clp->valid == 0 ||
	    (clp->rdblock <= 0 || clp->rdblock >= RDB_MAXBLOCKS))
		return (EINVAL);

	bmap = getrdbmap(dev, strat, lp, clp);
	return (EINVAL);
}

int
bounds_check_with_label(bp, lp, osdep, wlabel)
	struct buf *bp;
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int wlabel;
{
#define blockpersec(count, lp) ((count) * (((lp)->d_secsize) / DEV_BSIZE))
	struct partition *p = lp->d_partitions + DISKPART(bp->b_dev);
	int sz = howmany(bp->b_bcount, DEV_BSIZE);

	/* avoid division by zero */
	if (lp->d_secpercyl == 0) {
		bp->b_error = EINVAL;
		goto bad;
	}

	if (bp->b_blkno + sz > blockpersec(p->p_size, lp)) {
		sz = blockpersec(p->p_size, lp) - bp->b_blkno;
		if (sz == 0) {
			/* If exactly at end of disk, return EOF. */
			bp->b_resid = bp->b_bcount;
			goto done;
		}
		if (sz < 0) {
			/* If past end of disk, return EINVAL. */
			bp->b_error = EINVAL;
			goto bad;
		}
		/* Otherwise, truncate request. */
		bp->b_bcount = sz << DEV_BSHIFT;
	}

	/* Calculate cylinder for disksort to order transfers with.  */
	bp->b_cylin = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
	    lp->d_secpercyl;
	return (1);

bad:
	bp->b_flags |= B_ERROR;
done:
	return (0);
}

u_long
rdbchksum(bdata)
	void *bdata;
{
	u_long *blp, cnt, val;

	blp = bdata;
	cnt = blp[1];
	val = 0;

	while (cnt--)
		val += *blp++;
	return (val);
}

struct adostype 
getadostype(dostype)
	u_long dostype;
{
	struct adostype adt;
	u_long t3, b1;

	t3 = dostype & 0xffffff00;
	b1 = dostype & 0x000000ff;

	adt.fstype = b1;

	switch (t3) {
	case DOST_NBR:
		adt.archtype = ADT_NETBSDROOT;
		return (adt);
	case DOST_NBS:
		adt.archtype = ADT_NETBSDSWAP;
		return (adt);
	case DOST_NBU:
		adt.archtype = ADT_NETBSDUSER;
		return (adt);
	case DOST_MUFS:
		/* check for 'muFS'? */
		adt.archtype = ADT_AMIGADOS;
		adt.fstype = FS_ADOS;
		return (adt);
	case DOST_DOS:
		adt.archtype = ADT_AMIGADOS;
                if (b1 > 5)
#if 0
			/*
			 * XXX at least I, <niklas@@appli.se>, have a partition 
			 * that looks like "DOS\023", wherever that came from,
			 * but ADOS accepts it, so should we.
			 */
			goto unknown;
		else
#else
			printf("found dostype: 0x%x, assuming an ADOS FS "
			    "although it's unknown\n", dostype);
#endif
		adt.fstype = FS_ADOS;
		return (adt);
	case DOST_AMIX:
		adt.archtype = ADT_AMIX;
		if (b1 == 2)
			adt.fstype = FS_BSDFFS;
		else
			goto unknown;
		return (adt);
	case DOST_XXXBSD:
#ifdef DIAGNOSTIC
		printf("found dostype: 0x%x which is deprecated", dostype);
#endif
		if (b1 == 'S') {
			dostype = DOST_NBS;
			dostype |= FS_SWAP;
		} else {
			if (b1 == 'R')
				dostype = DOST_NBR;
			else
				dostype = DOST_NBU;
			dostype |= FS_BSDFFS;
		}
#ifdef DIAGNOSTIC
		printf(" using: 0x%x instead\n", dostype);
#endif
		return (getadostype(dostype));
	case DOST_EXT2:
		adt.archtype = ADT_EXT2;
		adt.fstype = FS_EXT2FS;
		return(adt);
	default:
	unknown:
#ifdef DIAGNOSTIC
		printf("warning unknown dostype: 0x%x marking unused\n",
		    dostype);
#endif
		adt.archtype = ADT_UNKNOWN;
		adt.fstype = FS_UNUSED;
		return (adt);
	}	
}

/*
 * if we find a bad block we kill it (and the chain it belongs to for
 * lseg or end the chain for part, badb, fshd)
 */
struct rdbmap *
getrdbmap(dev, strat, lp, clp)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *clp;
{
	struct buf *bp;

	bp = (void *)geteblk(lp->d_secsize);
	/*
	 * get the raw partition
	 */

	bp->b_dev = MAKEDISKDEV(major(dev), DISKUNIT(dev), RAW_PART);
	/* XXX finish */
	brelse(bp);
	return (NULL);
}

@


1.22
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.21 2002/03/14 01:26:28 millert Exp $	*/
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.20 2000/10/18 21:00:33 mickey Exp $	*/
d74 2
a75 2
struct rdbmap *getrdbmap __P((dev_t, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *));
@


1.20
log
@typo in comment; from gluk@@ptci.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.19 2000/04/29 15:57:51 espie Exp $	*/
d72 2
a73 2
u_long rdbchksum __P((void *));
struct adostype getadostype __P((u_long));
@


1.20.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.20 2000/10/18 21:00:33 mickey Exp $	*/
d72 4
a75 4
u_long rdbchksum(void *);
struct adostype getadostype(u_long);
struct rdbmap *getrdbmap(dev_t, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *);
@


1.20.8.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.20.8.1 2002/06/11 03:34:57 art Exp $	*/
@


1.19
log
@From Lars Hecking <lhecking@@nmrc.ucc.ie>:
grab NetBSD changes to recognize Linux ados labels,
so that OpenBSD can mount them (provided it doesn't run into
more endianness problems)
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.18 1999/01/08 04:29:04 millert Exp $	*/
d88 1
a88 1
 * using the indicated stategy routine.
@


1.18
log
@check for lp->d_secpercyl == 0) in bounds_check_with_label()
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.17 1998/10/03 21:18:54 millert Exp $	*/
d339 1
d638 4
@


1.18.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.20 2000/10/18 21:00:33 mickey Exp $	*/
d88 1
a88 1
 * using the indicated strategy routine.
a338 1
		case ADT_EXT2:
a636 4
	case DOST_EXT2:
		adt.archtype = ADT_EXT2;
		adt.fstype = FS_EXT2FS;
		return(adt);
@


1.18.6.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d72 4
a75 4
u_long rdbchksum(void *);
struct adostype getadostype(u_long);
struct rdbmap *getrdbmap(dev_t, void (*)(struct buf *),
    struct disklabel *, struct cpu_disklabel *);
@


1.18.6.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.18.6.2 2002/03/28 10:06:14 niklas Exp $	*/
@


1.17
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.16 1998/03/26 12:41:28 niklas Exp $	*/
d519 6
@


1.16
log
@Some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.14 1997/08/08 21:46:34 niklas Exp $	*/
d95 1
a95 1
readdisklabel(dev, strat, lp, clp)
d100 1
d134 4
@


1.15
log
@Remove register specifiers, add one explicit int
@
text
@d430 1
a430 1
	return(msg);
d492 1
a492 1
	return(EINVAL);
d498 1
a498 1
		return(EINVAL);
d501 1
a501 1
	return(EINVAL);
d554 1
a554 1
	return(val);
d572 1
a572 1
		return(adt);
d575 1
a575 1
		return(adt);
d578 1
a578 1
		return(adt);
d583 1
a583 1
		return(adt);
d600 1
a600 1
		return(adt);
d607 1
a607 1
		return(adt);
d625 1
a625 1
		return(getadostype(dostype));
d634 1
a634 1
		return(adt);
d659 1
a659 1
	return(NULL);
@


1.14
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.13 1997/05/29 01:18:18 niklas Exp $	*/
d439 1
a439 1
	register struct disklabel *olp, *nlp;
d443 2
a444 2
	register i;
	register struct partition *opp, *npp;
d485 1
a485 1
	register struct disklabel *lp;
@


1.13
log
@small style nits
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.12 1997/04/10 08:52:52 niklas Exp $	*/
d505 1
a505 1
bounds_check_with_label(bp, lp, wlabel)
d508 1
@


1.12
log
@Do block/sector handling like the other ports
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.11 1997/02/23 02:33:05 niklas Exp $	*/
d370 1
a370 1
			 * either we have no packname yet or we found 
d456 2
a457 1
		if (npp->p_offset != opp->p_offset || npp->p_size < opp->p_size)
@


1.11
log
@Spoof ISO 9660 disklabels
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.10 1997/02/21 09:06:18 niklas Exp $	*/
d509 8
a516 17
	struct partition *pp;
	long maxsz, sz;

	pp = &lp->d_partitions[DISKPART(bp->b_dev)];
	if (bp->b_flags & B_RAW) {
		maxsz = pp->p_size * (lp->d_secsize / DEV_BSIZE);
		sz = (bp->b_bcount + DEV_BSIZE - 1) >> DEV_BSHIFT;
	} else {
		maxsz = pp->p_size;
		sz = (bp->b_bcount + lp->d_secsize - 1) / lp->d_secsize;
	}

	if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
		if (bp->b_blkno == maxsz) {
			/* 
			 * trying to get one block beyond return EOF.
			 */
d518 1
a518 1
			return(0);
d520 2
a521 2
		sz = maxsz - bp->b_blkno;
		if (sz <= 0 || bp->b_blkno < 0) {
d523 1
a523 2
			bp->b_flags |= B_ERROR;
			return(-1);
d525 2
a526 7
		/* 
		 * adjust count down
		 */
		if (bp->b_flags & B_RAW)
			bp->b_bcount = sz << DEV_BSHIFT;
		else
			bp->b_bcount = sz * lp->d_secsize;
d529 9
a537 5
	/*
	 * calc cylinder for disksort to order transfers with
	 */
	bp->b_cylin = (bp->b_blkno + pp->p_offset) / lp->d_secpercyl;
	return(1);
@


1.10
log
@Style cleanup and a printf string typo
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.9 1997/01/20 15:43:28 niklas Exp $	*/
d196 4
@


1.9
log
@Accept partitions looking like, but not matching exactly,
 an ADOS FS partition, as ADOSFS.  some %lx -> %x.  Print diagnostic for more
unknown partition types.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.8 1997/01/16 09:23:18 niklas Exp $	*/
a35 2
 *
 *	@@(#)ufs_disksubr.c	7.16 (Berkeley) 5/4/91
d74 2
a75 2
struct rdbmap *getrdbmap __P((dev_t, void (*)(struct buf *), struct disklabel *,
    struct cpu_disklabel *));
a148 1
	 * XXX Need to check for a standard label if this fails (fd0 etc..)
d474 1
a474 1
 * label.  Hope the user was carefull.
d602 1
a602 1
			    "although it's unknown", dostype);
@


1.8
log
@Sync to NetBSD 970110
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.7 1996/12/20 16:48:09 niklas Exp $	*/
d595 7
a601 1
			adt.fstype = FS_UNUSED;
d603 5
a607 1
			adt.fstype = FS_ADOS;
d614 1
a614 1
			adt.fstype = FS_UNUSED;
d618 1
a618 1
		printf("found dostype: 0x%lx which is deprecated", dostype);
d631 1
a631 1
		printf(" using: 0x%lx instead\n", dostype);
d635 1
d637 1
a637 1
		printf("warning unknown dostype: 0x%lx marking unused\n",
@


1.7
log
@Add readdisklabel support for BSD disklabels.  I got tired of the amiga RDB
only requirement, now you can partition with disklabel(8) -r instead.
However I have not done in-kernel writedisklabel support yet.
@
text
@d1 2
a2 2
/*	$OpenBSD: disksubr.c,v 1.6 1996/06/10 19:37:05 niklas Exp $	*/
/*	$NetBSD: disksubr.c,v 1.25 1996/04/30 05:00:51 mhitch Exp $	*/
@


1.6
log
@Fix typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.3 1996/04/21 22:14:50 deraadt Exp $	*/
d103 1
d169 1
a169 1
				msg = "rdb bad checksum";
d173 26
a198 2
		if (msg == NULL)
			msg = "no rdb found";
@


1.5
log
@dk_establish() now returns void.
@
text
@d114 1
a114 1
	 * give some guarnteed validity to
@


1.4
log
@Sync with NetBSD 9600430.  The port has gone over a major -Wall treat
@
text
@d2 1
a2 1
/*	$NetBSD: disksubr.c,v 1.24 1996/04/29 06:15:32 mhitch Exp $	*/
a41 1
#include <sys/cpu.h>
d43 1
d80 1
a80 1
int
d85 1
a85 1
	return(-1);
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: disksubr.c,v 1.22 1996/04/05 04:50:26 mhitch Exp $	*/
d42 1
a42 1
#include <sys/device.h>
a43 2
#include <sys/disk.h>
#include <sys/dkstat.h>
d76 1
a76 1
struct rdbmap *getrdbmap __P((dev_t, void (*)(), struct disklabel *,
d99 1
a99 1
	void (*strat)();
d104 1
a104 1
	struct partition *pp;
d108 2
a109 3
	char *msg, *bcpls, *s, bcpli, cindex;
	int i, trypart, nopname;
	u_char fstype;
d203 2
a204 2
		printf("warning found rdb->ncylinders(%d) != "
		    "rdb->highcyl(%d) + 1\n", rbp->ncylinders,
d207 2
a208 2
		printf("warning found rdb->secpercyl(%d) != "
		    "rdb->nsectors(%d) * rdb->nheads(%d)\n", rbp->secpercyl,
d321 1
a321 1
			printf("Partition '%s' geometry %d/%d differs",
d389 1
a389 1
		clp->pblist[clp->pbindex[i] = cindex++];
d454 1
d457 1
a457 1
	void (*strat)();
d462 3
d583 1
a583 1
		printf("found dostype: 0x%x which is deprecated", dostype);
d596 1
a596 1
		printf(" using: 0x%x instead\n", dostype);
d601 1
a601 1
		printf("warning unknown dostype: 0x%x marking unused\n",
d617 1
a617 1
	void (*strat)();
a629 1
bad:
@


1.2
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d1 2
a2 1
/*	$NetBSD: disksubr.c,v 1.21 1996/01/07 22:01:44 thorpej Exp $	*/
d315 16
d337 2
a338 1
			boff = pbp->e.lowcyl * lp->d_secpercyl;
a364 3
		if (lp->d_npartitions <= i)
			lp->d_npartitions = i + 1;

d366 3
a368 2
		    * lp->d_secpercyl;
		pp->p_offset = pbp->e.lowcyl * lp->d_secpercyl;
a369 9
		if (pbp->e.tabsize > 22 && ISFSARCH_NETBSD(adt)) {
			pp->p_fsize = pbp->e.fsize;
			pp->p_frag = pbp->e.frag;	
			pp->p_cpg = pbp->e.cpg;
		} else {
			pp->p_fsize = 1024;
			pp->p_frag = 8;	
			pp->p_cpg = 0;
		}
d375 2
d379 8
d563 3
d568 4
a571 1
		adt.fstype = FS_ADOS;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: disksubr.c,v 1.20 1995/09/29 13:51:33 chopps Exp $	*/
d83 1
a83 1
	struct dkdevice *dk;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
