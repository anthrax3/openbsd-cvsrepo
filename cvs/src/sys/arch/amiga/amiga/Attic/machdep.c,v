head	1.72;
access;
symbols
	SMP_SYNC_A:1.72
	SMP_SYNC_B:1.72
	UBC_SYNC_A:1.72
	OPENBSD_3_2:1.70.0.2
	OPENBSD_3_2_BASE:1.70
	OPENBSD_3_1:1.69.0.2
	OPENBSD_3_1_BASE:1.69
	UBC_SYNC_B:1.70
	UBC:1.63.0.2
	UBC_BASE:1.63
	OPENBSD_3_0:1.54.0.2
	OPENBSD_3_0_BASE:1.54
	OPENBSD_2_9:1.41.0.4
	OPENBSD_2_9_BASE:1.41
	OPENBSD_2_8:1.41.0.2
	OPENBSD_2_8_BASE:1.41
	OPENBSD_2_7:1.38.0.2
	OPENBSD_2_7_BASE:1.38
	SMP:1.35.0.2
	SMP_BASE:1.35
	kame_19991208:1.35
	OPENBSD_2_6:1.34.0.2
	OPENBSD_2_6_BASE:1.34
	OPENBSD_2_5:1.31.0.2
	OPENBSD_2_5_BASE:1.31
	OPENBSD_2_4:1.29.0.4
	OPENBSD_2_4_BASE:1.29
	OPENBSD_2_3:1.29.0.2
	OPENBSD_2_3_BASE:1.29
	OPENBSD_2_2:1.27.0.2
	OPENBSD_2_2_BASE:1.27
	OPENBSD_2_1:1.23.0.2
	OPENBSD_2_1_BASE:1.23
	OPENBSD_2_0:1.15.0.2
	OPENBSD_2_0_BASE:1.15
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.72
date	2002.12.31.16.35.36;	author miod;	state dead;
branches;
next	1.71;

1.71
date	2002.12.17.23.11.31;	author millert;	state Exp;
branches;
next	1.70;

1.70
date	2002.06.11.03.25.31;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2002.03.23.13.28.33;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2002.03.14.20.31.30;	author mickey;	state Exp;
branches;
next	1.67;

1.67
date	2002.03.14.01.26.28;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	2002.02.04.23.54.33;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2002.01.23.17.51.52;	author art;	state Exp;
branches;
next	1.64;

1.64
date	2002.01.23.17.35.56;	author art;	state Exp;
branches;
next	1.63;

1.63
date	2001.12.08.02.24.06;	author art;	state Exp;
branches
	1.63.2.1;
next	1.62;

1.62
date	2001.11.30.02.09.34;	author art;	state Exp;
branches;
next	1.61;

1.61
date	2001.11.28.16.13.27;	author art;	state Exp;
branches;
next	1.60;

1.60
date	2001.11.28.13.57.18;	author art;	state Exp;
branches;
next	1.59;

1.59
date	2001.11.28.13.47.37;	author art;	state Exp;
branches;
next	1.58;

1.58
date	2001.11.24.17.53.41;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2001.11.09.15.25.55;	author art;	state Exp;
branches;
next	1.56;

1.56
date	2001.11.07.01.18.00;	author art;	state Exp;
branches;
next	1.55;

1.55
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.53;

1.53
date	2001.09.12.00.23.33;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2001.08.23.14.01.02;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2001.08.23.12.02.04;	author art;	state Exp;
branches;
next	1.50;

1.50
date	2001.08.12.21.36.47;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2001.07.25.13.25.31;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2001.07.18.10.47.04;	author art;	state Exp;
branches;
next	1.47;

1.47
date	2001.07.05.07.17.52;	author art;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.27.03.54.12;	author art;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.06.21.21.12;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2001.05.17.18.41.47;	author provos;	state Exp;
branches;
next	1.43;

1.43
date	2001.05.05.22.33.28;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2001.05.05.20.56.32;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2000.05.28.02.23.30;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2000.05.27.20.44.41;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2000.05.27.19.42.49;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2000.04.11.02.44.23;	author pjanzen;	state Exp;
branches;
next	1.37;

1.37
date	2000.03.23.09.59.53;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2000.02.22.19.27.42;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	99.12.08.06.50.14;	author itojun;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	99.09.03.18.00.28;	author art;	state Exp;
branches;
next	1.33;

1.33
date	99.05.24.23.08.58;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	99.05.22.21.22.18;	author weingart;	state Exp;
branches;
next	1.31;

1.31
date	99.01.20.12.06.52;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	99.01.07.23.15.54;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	98.03.01.14.35.42;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	98.02.22.20.34.03;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	97.10.07.10.57.14;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	97.09.19.17.16.14;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	97.09.18.13.39.36;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	97.07.23.06.58.17;	author denny;	state Exp;
branches;
next	1.23;

1.23
date	97.03.26.18.30.50;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	97.02.21.09.02.41;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	97.02.03.15.05.06;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.02.03.12.48.35;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.02.03.11.38.08;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.01.18.12.48.01;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	97.01.17.05.53.39;	author kstailey;	state Exp;
branches;
next	1.16;

1.16
date	97.01.16.09.23.24;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	96.08.19.00.04.15;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	96.07.27.11.40.26;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.05.29.10.14.29;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	96.05.28.09.45.11;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	96.05.09.21.13.37;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.05.08.01.30.40;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.05.04.13.38.33;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.05.02.06.43.20;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.04.27.18.38.46;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.03.24.16.13.34;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.02.06.09.16.33;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.01.05.16.17.38;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.01.18.24.50;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.01.17.47.16;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.52;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.52;	author deraadt;	state Exp;
branches;
next	;

1.35.2.1
date	2000.03.02.07.04.25;	author niklas;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2000.03.24.09.06.58;	author niklas;	state Exp;
branches;
next	1.35.2.3;

1.35.2.3
date	2001.04.18.16.01.57;	author niklas;	state Exp;
branches;
next	1.35.2.4;

1.35.2.4
date	2001.07.04.10.14.57;	author niklas;	state Exp;
branches;
next	1.35.2.5;

1.35.2.5
date	2001.10.31.02.52.45;	author nate;	state Exp;
branches;
next	1.35.2.6;

1.35.2.6
date	2001.11.13.21.00.50;	author niklas;	state Exp;
branches;
next	1.35.2.7;

1.35.2.7
date	2001.12.05.00.39.09;	author niklas;	state Exp;
branches;
next	1.35.2.8;

1.35.2.8
date	2002.03.06.00.56.18;	author niklas;	state Exp;
branches;
next	1.35.2.9;

1.35.2.9
date	2002.03.28.10.06.14;	author niklas;	state Exp;
branches;
next	1.35.2.10;

1.35.2.10
date	2003.03.27.23.19.17;	author niklas;	state dead;
branches;
next	;

1.63.2.1
date	2002.01.31.22.55.06;	author niklas;	state Exp;
branches;
next	1.63.2.2;

1.63.2.2
date	2002.06.11.03.34.57;	author art;	state Exp;
branches;
next	1.63.2.3;

1.63.2.3
date	2002.10.29.00.28.01;	author art;	state Exp;
branches;
next	1.63.2.4;

1.63.2.4
date	2003.05.19.21.49.38;	author tedu;	state dead;
branches;
next	;


desc
@@


1.72
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: machdep.c,v 1.71 2002/12/17 23:11:31 millert Exp $	*/
/*	$NetBSD: machdep.c,v 1.95 1997/08/27 18:31:17 is Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: machdep.c 1.63 91/04/24$
 *
 *	@@(#)machdep.c	7.16 (Berkeley) 6/3/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/file.h>
#include <sys/clist.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/msgbuf.h>
#include <sys/user.h>
#include <sys/exec.h>            /* for PS_STRINGS */
#include <sys/vnode.h>
#include <sys/queue.h>
#include <sys/sysctl.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>
#include <sys/core.h>
#include <sys/kcore.h>
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
#include <net/netisr.h>
#define	MAXMEM	64*1024	/* XXX - from cmap.h */

#include <uvm/uvm_extern.h>

#include <machine/db_machdep.h>
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>

#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/reg.h>
#include <machine/psl.h>
#include <machine/pte.h>
#include <machine/kcore.h>
#include <dev/cons.h>
#include <amiga/amiga/isr.h>
#include <amiga/amiga/custom.h>
#ifdef DRACO
#include <amiga/amiga/drcustom.h>
#endif
#include <amiga/amiga/cia.h>
#include <amiga/amiga/cc.h>
#include <amiga/amiga/memlist.h>

#include "fd.h"
#include "ser.h"
#include "ether.h"
#include "ppp.h"

#include <net/if.h>

/* prototypes */
void identifycpu(void);
vm_offset_t reserve_dumppages(vm_offset_t);
void dumpsys(void);
void initcpu(void);
void straytrap(int, u_short);
void netintr(void);
void call_sicallbacks(void);
void _softintr_callit(void *, void *);
void intrhand(int);
#if NSER > 0
void ser_outintr(void);
#endif
#if NFD > 0
void fdintr(int);
#endif

/*
 * patched by some devices at attach time (currently, only drcom)
 */
u_int16_t amiga_ttyspl = PSL_S|PSL_IPL4;

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

/*
 * Declare these as initialized data so we can patch them.
 */
#ifdef	NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif
#ifdef	BUFPAGES
int	bufpages = BUFPAGES;
#else
int	bufpages = 0;
#endif

paddr_t	msgbufpa;

int	maxmem;			/* max memory per process */
int	physmem = MAXMEM;	/* max supported memory, changes to actual */
/*
 * extender "register" for software interrupts. Moved here 
 * from locore.s, since softints are no longer dealt with
 * in locore.s.
 */
unsigned char ssir;
/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int	safepri = PSL_LOWIPL;
extern  int   freebufspace;
extern	u_int lowram;
extern	short exframesize[];

#ifdef COMPAT_SUNOS
extern struct emul emul_sunos;
#endif

/* used in init_main.c */
char *cpu_type = "m68k";
/* the following is used externally (sysctl_hw) */
char machine[] = MACHINE;	/* from <machine/param.h> */
 
struct isr *isr_ports;
#ifdef DRACO
struct isr *isr_slot3;
struct isr *isr_supio;
#endif
#if defined(IPL_REMAP_1) || defined(IPL_REMAP_2)
struct isr *isr_exter[7];
#else
struct isr *isr_exter;
#endif

#ifdef IPL_REMAP_1
int isr_exter_lowipl = 7;
int isr_exter_highipl = 0;
int isr_exter_ipl = 0;

/*
 * Poll all registered ISRs starting at IPL start_ipl going down to
 * isr_exter_lowipl.  If we reach the IPL of ending_psw along the way
 * just return stating in isr_exter_ipl that we need to run the remaining
 * layers later when the IPL gets lowered (i.e. a spl? call).  If some
 * ISR handles the interrupt, or all layers have been processed, enable
 * EXTER interrupts again and return.
 */
void
walk_ipls (start_ipl, ending_psw)
	int start_ipl;
	int ending_psw;
{
	int i;

	for (i = start_ipl; i >= isr_exter_lowipl; i--) {
		register int psw = i << 8 | PSL_S;
		struct isr *isr;
		      
		if (psw <= ending_psw) {
			isr_exter_ipl = i;
			return;
		}
		__asm __volatile("movew %0,sr" : : "d" (psw) : "cc");
		for (isr = isr_exter[i]; isr; isr = isr->isr_forw)
			(*isr->isr_intr)(isr->isr_arg);
	}
	isr_exter_ipl = 0;
	__asm __volatile("movew %0,sr" : : "di" (PSL_S|PSL_IPL6) : "cc");
	custom.intreq = INTF_EXTER;
	custom.intena = INTF_SETCLR | INTF_EXTER;
}
#endif

#ifdef IPL_REMAP_2
/*
 * Service all waiting ISRs starting from current IPL to npsl.
 */
void
walk_ipls (npsl)
	int npsl;
{
        struct isr *isr_head;
	register struct isr *isr;
	int opsl;
	register int psl;

	psl = opsl = spl7();
	isr_head = &isr_exter[(psl & PSL_IPL) >> 8];
redo_ipl:
	while (psl > to_psl) {
		for (isr = isr_head; isr; isr = isr->isr_forw) {
			if (isr->isr_status == ISR_WAIT) {
				splx(psl);
				isr->isr_status = ISR_BUSY;
				(*isr->isr_intr)(isr->isr_arg);
				isr->isr_status = ISR_IDLE;
				spl7();
				goto redo_ipl;
			}
		}
		psl -= PSL_IPL1;
		isr_head--;
	}
	return opsl;
}
#endif

/*
 * current open serial device speed;  used by some SCSI drivers to reduce
 * DMA transfer lengths.
 */
int	ser_open_speed;

/*
 * Console initialization: called early on from main,
 * before vm init or startup.  Do enough configuration
 * to choose and initialize a console.
 */
void
consinit()
{
	/* initialize custom chip interface */
#ifdef DRACO
	if (is_draco()) {
		/* XXX to be done */
	} else
#endif
		custom_chips_init();
	/*
	 * Initialize the console before we print anything out.
	 */
	cninit();

#if defined (DDB)
        ddb_init();
        if (boothowto & RB_KDB)
                Debugger();
#endif
}

/*
 * cpu_startup: allocate memory for variable-sized tables,
 * initialize cpu, and do autoconfiguration.
 */
void
cpu_startup()
{
	unsigned i;
	caddr_t v, firstaddr;
	int base, residual;
#ifdef DEBUG
	extern int pmapdebug;
	int opmapdebug = pmapdebug;
#endif
	vaddr_t minaddr, maxaddr;
	vm_size_t size = 0;
	vaddr_t va;
	paddr_t pa;

	/*
	 * Initialize error message buffer (at end of core).
	 */
#ifdef DEBUG
	pmapdebug = 0;
#endif
	/*
	 * pmap_bootstrap has positioned this at the end of kernel
	 * memory segment - map and initialize it now.
	 */
	/*
	 * XXX - shouldn't this be msgbufp + i * PAGE_SIZE?
	 */
	va = (vaddr_t)msgbufp;
	pa = (paddr_t)msgbufpa;
	for (i = 0; i < btoc(MSGBUFSIZE); i++) {
		pmap_kenter_pa(va, pa, VM_PROT_READ|VM_PROT_WRITE);
		va += PAGE_SIZE;
		pa += PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf(version);
	identifycpu();
	printf("real  mem = %d (%d pages)\n", ctob(physmem), ctob(physmem)/NBPG);

	/*
	 * Allocate space for system data structures.
	 * The first available real memory address is in "firstaddr".
	 * The first available kernel virtual address is in "v".
	 * As pages of kernel virtual memory are allocated, "v" is incremented.
	 * As pages of memory are allocated and cleared,
	 * "firstaddr" is incremented.
	 * An index into the kernel page table corresponding to the
	 * virtual memory address maintained in "v" is kept in "mapaddr".
	 */
	/*
	 * Make two passes.  The first pass calculates how much memory is
	 * needed and allocates it.  The second pass assigns virtual
	 * addresses to the various data structures.
	 */
	firstaddr = 0;
again:
	v = (caddr_t)firstaddr;

#define	valloc(name, type, num) \
	    (name) = (type *)v; v = (caddr_t)((name)+(num))
#define	valloclim(name, type, num, lim) \
	    (name) = (type *)v; v = (caddr_t)((lim) = ((name)+(num)))
#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
	/*
	 * Determine how many buffers to allocate. We allocate
	 * the BSD standard of use 10% of memory for the first 2 Meg,
	 * 5% of remaining. Insure a minimum of 16 buffers.
	 * We allocate 3/4 as many swap buffer headers as file i/o buffers.
	 */
  	if (bufpages == 0) {
		if (physmem < btoc(2 * 1024 * 1024))
			bufpages = physmem / (10);
		else
			bufpages = (btoc(2 * 1024 * 1024) + physmem) / 20;
	}

	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}

	valloc(buf, struct buf, nbuf);
	/*
	 * End of first pass, size has been calculated so allocate memory
	 */
	if (firstaddr == 0) {
		size = (vm_size_t)(v - firstaddr);
		firstaddr = (caddr_t) uvm_km_zalloc(kernel_map,
						    round_page(size));
		if (firstaddr == 0)
			panic("startup: no room for tables");
		goto again;
	}
	/*
	 * End of second pass, addresses have been assigned
	 */
	if ((vm_size_t)(v - firstaddr) != size)
		panic("startup: table size inconsistency");

	/*
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
	 */
	size = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, (vaddr_t *)&buffers, round_page(size),
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)))
		panic("startup: cannot allocate buffers");
	minaddr = (vaddr_t) buffers;
	if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
		/* don't want to alloc more physical mem than needed */
		bufpages = btoc(MAXBSIZE) * nbuf;
	}
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	for (i = 0; i < nbuf; i++) {
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;

		/*
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vm_offset_t) buffers + (i * MAXBSIZE);
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for "
				      "buffer cache");

			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ|VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
		pmap_update(pmap_kernel());
	}

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate a submap for physio
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   VM_PHYS_SIZE, 0, FALSE, NULL);

#ifdef DEBUG
	pmapdebug = opmapdebug;
#endif
	printf("avail mem = %ld (%ld pages)\n", ptoa(uvmexp.free), uvmexp.free);
	printf("using %d buffers containing %d bytes of memory\n", nbuf,
	    bufpages * PAGE_SIZE);
	
	/*
	 * display memory configuration passed from loadbsd
	 */
	if (memlist->m_nseg > 0 && memlist->m_nseg < 16)
		for (i = 0; i < memlist->m_nseg; i++)
			printf("memory segment %d at %x size %x\n", i,
			    memlist->m_seg[i].ms_start, 
			    memlist->m_seg[i].ms_size);

#ifdef DEBUG_KERNEL_START
	printf("calling initcpu...\n");
#endif

	/*
	 * Set up CPU-specific registers, cache, etc.
	 */
	initcpu();

#ifdef DEBUG_KERNEL_START
	printf("survived initcpu...\n");
#endif
	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

#ifdef DEBUG_KERNEL_START
	printf("survived bufinit...\n");
#endif
	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}

/*
 * Set registers on exec.
 */
void
setregs(p, pack, stack, retval)
	register struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	struct frame *frame = (struct frame *)p->p_md.md_regs;
	
	frame->f_sr = PSL_USERSET;
	frame->f_pc = pack->ep_entry & ~1;
	frame->f_regs[D0] = 0;
	frame->f_regs[D1] = 0;
	frame->f_regs[D2] = 0;
	frame->f_regs[D3] = 0;
	frame->f_regs[D4] = 0;
	frame->f_regs[D5] = 0;
	frame->f_regs[D6] = 0;
	frame->f_regs[D7] = 0;
	frame->f_regs[A0] = 0;
	frame->f_regs[A1] = 0;
	frame->f_regs[A2] = (int)PS_STRINGS;
	frame->f_regs[A3] = 0;
	frame->f_regs[A4] = 0;
	frame->f_regs[A5] = 0;
	frame->f_regs[A6] = 0;
	frame->f_regs[SP] = stack;

	/* restore a null state frame */
	p->p_addr->u_pcb.pcb_fpregs.fpf_null = 0;
#ifdef FPU_EMULATE
	if (!fputype)
		bzero(&p->p_addr->u_pcb.pcb_fpregs, sizeof(struct fpframe));
	else
#endif
		m68881_restore(&p->p_addr->u_pcb.pcb_fpregs);
#ifdef COMPAT_SUNOS
	/*
	 * SunOS' ld.so does self-modifying code without knowing
	 * about the 040's cache purging needs.  So we need to uncache
	 * writeable executable pages.
	 */
	if (p->p_emul == &emul_sunos)
		p->p_md.md_flags |= MDP_UNCACHE_WX;
	else
		p->p_md.md_flags &= ~MDP_UNCACHE_WX;
#endif
}

/*
 * Info for CTL_HW
 */
char cpu_model[120];

#if defined(M68060)
int m68060_pcr_init = 0x21;	/* make this patchable */
#endif


void
identifycpu()
{
        /* there's alot of XXX in here... */
	char *mach, *mmu, *fpu;

#ifdef M68060
	char cpubuf[16];
	u_int32_t pcr;
#endif

#ifdef DRACO
	char machbuf[16];

	if (is_draco()) {
		sprintf(machbuf, "DraCo rev.%d", is_draco());
		mach = machbuf;
	} else 
#endif
	if (is_a4000())
		mach = "Amiga 4000";
	else if (is_a3000())
		mach = "Amiga 3000";
	else if (is_a1200())
		mach = "Amiga 1200";
	else
		mach = "Amiga 500/2000";

	fpu = NULL;
#ifdef M68060
	if (machineid & AMIGA_68060) {
		asm(".word 0x4e7a,0x0808; movl d0,%0" : "=d"(pcr) : : "d0");
		sprintf(cpubuf, "68%s060 rev.%d",
		    pcr & 0x10000 ? "LC/EC" : "", (pcr>>8)&0xff);
		cpu_type = cpubuf;
		mmu = "/MMU";
		if (pcr & 2) {
			fpu = "/FPU disabled";
			fputype = FPU_NONE;
		} else if (m68060_pcr_init & 2){
			fpu = "/FPU will be disabled";
			fputype = FPU_NONE;
		} else  if (machineid & AMIGA_FPU40) {
			fpu = "/FPU";
			fputype = FPU_68040; /* XXX */
		}
	} else 
#endif
	if (machineid & AMIGA_68040) {
		cpu_type = "m68040";
		mmu = "/MMU";
		fpu = "/FPU";
		fputype = FPU_68040; /* XXX */
	} else if (machineid & AMIGA_68030) {
		cpu_type = "m68030";	/* XXX */
		mmu = "/MMU";
	} else {
		cpu_type = "m68020";
		mmu = " m68851 MMU";
	}
	if (fpu == NULL) {
		if (machineid & AMIGA_68882) {
			fpu = " m68882 FPU";
			fputype = FPU_68882;
		} else if (machineid & AMIGA_68881) {
			fpu = " m68881 FPU";
			fputype = FPU_68881;
		} else {
			fpu = " no FPU";
			fputype = FPU_NONE;
		}
	}
	sprintf(cpu_model, "%s (%s CPU%s%s)", mach, cpu_type, mmu, fpu);
	printf("%s\n", cpu_model);
}

/*
 * machine dependent system variables.
 */
int
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	dev_t consdev;

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return(ENOTDIR);               /* overloaded */

	switch (name[0]) {
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return(sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof(consdev)));
	default:
		return(EOPNOTSUPP);
	}
	/* NOTREACHED */
}

#define SS_RTEFRAME	1
#define SS_FPSTATE	2
#define SS_USERREGS	4

struct sigstate {
	int	ss_flags;		/* which of the following are valid */
	struct	frame ss_frame;		/* original exception frame */
	struct	fpframe ss_fpstate;	/* 68881/68882 state info */
};

/*
 * WARNING: code in locore.s assumes the layout shown for sf_signum
 * thru sf_handler so... don't screw with them!
 */
struct sigframe {
	int	sf_signum;		/* signo for handler */
	siginfo_t *sf_sip;		/* additional info for handler */
	struct	sigcontext *sf_scp;	/* context ptr for handler */
	sig_t	sf_handler;		/* handler addr for u_sigc */
	struct	sigstate sf_state;	/* state of the hardware */
	struct	sigcontext sf_sc;	/* actual context */
	siginfo_t sf_si;
};

#ifdef DEBUG
int sigdebug = 0x0;
int sigpid = 0;
#define SDB_FOLLOW	0x01
#define SDB_KSTACK	0x02
#define SDB_FPSTATE	0x04
#endif

static int waittime = -1;

void
bootsync(void)
{
	if (waittime < 0) {
		waittime = 0;
		vfs_shutdown();
	}
}

void
boot(howto)
	register int howto;
{
	/* take a snap shot before clobbering any registers */
	if (curproc)
		savectx(&curproc->p_addr->u_pcb);

	/* If system is cold, just halt. */
	if (cold) {
		howto |= RB_HALT;
		goto haltsys;
	}

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0) {
		bootsync();

		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}

	/* Disable interrupts. */
	spl7();

	/* If rebooting and a dump is requested do it. */
	if (howto & RB_DUMP)
		dumpsys();

haltsys:
	/* Run any shutdown hooks. */
	doshutdownhooks();

	if (howto & RB_HALT) {
		printf("System halted.\n\n");
		asm("	stop	#0x2700");
		/*NOTREACHED*/
	}

	doboot();
	/*NOTREACHED*/
}

unsigned	dumpmag = 0x8fca0101;	/* magic number for savecore */
int	dumpsize = 0;		/* also for savecore */
long	dumplo = 0;
cpu_kcore_hdr_t cpu_kcore_hdr;

void
dumpconf()
{
	int nblks;
	int i;
	extern u_int Sysseg_pa;

	/* XXX new corefile format, single segment + chipmem */
	dumpsize = physmem;
	cpu_kcore_hdr.ram_segs[0].start = lowram;
	cpu_kcore_hdr.ram_segs[0].size = ctob(physmem);
	for (i = 0; i < memlist->m_nseg; i++) {
		if ((memlist->m_seg[i].ms_attrib & MEMF_CHIP) == 0)
			continue;
		dumpsize += btoc(memlist->m_seg[i].ms_size);
		cpu_kcore_hdr.ram_segs[1].start = 0;
		cpu_kcore_hdr.ram_segs[1].size = memlist->m_seg[i].ms_size;
		break;
	}
	cpu_kcore_hdr.mmutype = mmutype;
	cpu_kcore_hdr.kernel_pa = lowram;
	cpu_kcore_hdr.sysseg_pa = (st_entry_t *)Sysseg_pa;
	if (dumpdev != NODEV && bdevsw[major(dumpdev)].d_psize) {
		nblks = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
		if (dumpsize > btoc(dbtob(nblks - dumplo)))
			dumpsize = btoc(dbtob(nblks - dumplo));
		else if (dumplo == 0)
			dumplo = nblks - btodb(ctob(dumpsize));
	}
	--dumplo;	/* XXX assume header fits in one block */
	/*
	 * Don't dump on the first PAGE_SIZE
	 * in case the dump device includes a disk label.
	 */
	if (dumplo < btodb(PAGE_SIZE))
		dumplo = btodb(PAGE_SIZE);
}

/*
 * Doadump comes here after turning off memory management and
 * getting on the dump stack, either when called above, or by
 * the auto-restart code.
 */
#define BYTES_PER_DUMP MAXPHYS	/* Must be a multiple of pagesize XXX small */
static vm_offset_t dumpspace;

vm_offset_t
reserve_dumppages(p)
	vm_offset_t p;
{
	dumpspace = p;
	return (p + BYTES_PER_DUMP);
}

void
dumpsys()
{
	unsigned bytes, i, n, seg;
	int     maddr, psize;
	daddr_t blkno;
	int     (*dump)(dev_t, daddr_t, caddr_t, size_t);
	int     error = 0;
	kcore_seg_t *kseg_p;
	cpu_kcore_hdr_t *chdr_p;
	char	dump_hdr[dbtob(1)];	/* XXX assume hdr fits in 1 block */
	extern int msgbufmapped;

	msgbufmapped = 0;
	if (dumpdev == NODEV)
		return;
	/*
	 * For dumps during autoconfiguration,
	 * if dump device has already configured...
	 */
	if (dumpsize == 0)
		dumpconf();
	if (dumplo < 0)
		return;
	printf("\ndumping to dev %x, offset %ld\n", dumpdev, dumplo);

	psize = (*bdevsw[major(dumpdev)].d_psize) (dumpdev);
	printf("dump ");
	if (psize == -1) {
		printf("area unavailable.\n");
		return;
	}
	kseg_p = (kcore_seg_t *)dump_hdr;
	chdr_p = (cpu_kcore_hdr_t *)&dump_hdr[ALIGN(sizeof(*kseg_p))];
	bzero(dump_hdr, sizeof(dump_hdr));

	/*
	 * Generate a segment header
	 */
	CORE_SETMAGIC(*kseg_p, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	kseg_p->c_size = dbtob(1) - ALIGN(sizeof(*kseg_p));

	/*
	 * Add the md header
	 */

	*chdr_p = cpu_kcore_hdr;

	bytes = ctob(dumpsize);
	maddr = cpu_kcore_hdr.ram_segs[0].start;
	seg = 0;
	blkno = dumplo;
	dump = bdevsw[major(dumpdev)].d_dump;
	error = (*dump) (dumpdev, blkno++, (caddr_t)dump_hdr, dbtob(1));
	for (i = 0; i < bytes && error == 0; i += n) {
		/* Print out how many MBs we have to go. */
		n = bytes - i;
		if (n && (n % (1024 * 1024)) == 0)
			printf("%d ", n / (1024 * 1024));

		/* Limit size for next transfer. */
		if (n > BYTES_PER_DUMP)
			n = BYTES_PER_DUMP;

		if (maddr == 0) {	/* XXX kvtop chokes on this */
			maddr += NBPG;
			n -= NBPG;
			i += NBPG;
			++blkno;	/* XXX skip physical page 0 */
		}
		(void) pmap_map(dumpspace, maddr, maddr + n, VM_PROT_READ);
		error = (*dump) (dumpdev, blkno, (caddr_t) dumpspace, n);
		if (error)
			break;
		maddr += n;
		blkno += btodb(n);	/* XXX? */
		if (maddr >= (cpu_kcore_hdr.ram_segs[seg].start +
		    cpu_kcore_hdr.ram_segs[seg].size)) {
			++seg;
			maddr = cpu_kcore_hdr.ram_segs[seg].start;
			if (cpu_kcore_hdr.ram_segs[seg].size == 0)
				break;
		}
	}

	switch (error) {

	case ENXIO:
		printf("device bad\n");
		break;

	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	default:
		printf("succeeded\n");
		break;
	}
	printf("\n\n");
	delay(5000000);		/* 5 seconds */
}

/*
 * Return the best possible estimate of the time in the timeval
 * to which tvp points.  We do this by returning the current time
 * plus the amount of time since the last clock interrupt (clock.c:clkread).
 *
 * Check that this time is no less than any previously-reported time,
 * which could happen around the time of a clock adjustment.  Just for fun,
 * we guarantee that the time will be greater than the value obtained by a
 * previous call.
 */
void
microtime(tvp)
	register struct timeval *tvp;
{
	int s = spl7();
	static struct timeval lasttime;

	*tvp = time;
	tvp->tv_usec += clkread();
	while (tvp->tv_usec >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	if (tvp->tv_sec == lasttime.tv_sec &&
	    tvp->tv_usec <= lasttime.tv_usec &&
	    (tvp->tv_usec = lasttime.tv_usec + 1) >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
	lasttime = *tvp;
	splx(s);
}

void
initcpu()
{
	typedef void trapfun(void);

	/* XXX should init '40 vecs here, too */
#if defined(M68060) || defined(M68040) || defined(DRACO) || defined(FPU_EMULATE)
	extern trapfun *vectab[256];
#endif

#if defined(M68060) || defined(M68040)
	extern trapfun addrerr4060;
#endif

#ifdef M68060
	extern trapfun buserr60;
#if defined(M060SP)
	/*extern u_int8_t I_CALL_TOP[];*/
	extern trapfun intemu60, fpiemu60, fpdemu60, fpeaemu60;
	extern u_int8_t FP_CALL_TOP[];
#else
	extern trapfun illinst;
#endif
	extern trapfun fpfault;
#endif

#ifdef M68040
	extern trapfun buserr40;
#endif

#ifdef DRACO
	extern trapfun DraCoIntr, DraCoLev1intr, DraCoLev2intr;
	u_char dracorev;
#endif

#ifdef FPU_EMULATE
	extern trapfun fpemuli;
#endif

#ifdef M68060
	if (machineid & AMIGA_68060) {
		if (machineid & AMIGA_FPU40 && m68060_pcr_init & 2) {
			/* 
			 * in this case, we're about to switch the FPU off;
			 * do a FNOP to avoid stray FP traps later
			 */
			__asm("fnop");
			/* ... and mark FPU as absent for identifyfpu() */
			machineid &= ~(AMIGA_FPU40|AMIGA_68882|AMIGA_68881);
		}
		asm volatile ("movl %0,d0; .word 0x4e7b,0x0808" : : 
			"d"(m68060_pcr_init):"d0" );

		/* bus/addrerr vectors */
		vectab[2] = buserr60;
		vectab[3] = addrerr4060;
#if defined(M060SP)

		/* integer support */
		vectab[61] = intemu60/*(trapfun *)&I_CALL_TOP[128 + 0x00]*/;

		/* floating point support */
		/*
		 * XXX maybe we really should run-time check for the
		 * stack frame format here:
		 */
		vectab[11] = fpiemu60/*(trapfun *)&FP_CALL_TOP[128 + 0x30]*/;

		vectab[55] = fpdemu60/*(trapfun *)&FP_CALL_TOP[128 + 0x38]*/;
		vectab[60] = fpeaemu60/*(trapfun *)&FP_CALL_TOP[128 + 0x40]*/;

		vectab[54] = (trapfun *)&FP_CALL_TOP[128 + 0x00];
		vectab[52] = (trapfun *)&FP_CALL_TOP[128 + 0x08];
		vectab[53] = (trapfun *)&FP_CALL_TOP[128 + 0x10];
		vectab[51] = (trapfun *)&FP_CALL_TOP[128 + 0x18];
		vectab[50] = (trapfun *)&FP_CALL_TOP[128 + 0x20];
		vectab[49] = (trapfun *)&FP_CALL_TOP[128 + 0x28];

#else
		vectab[61] = illinst;
#endif
		vectab[48] = fpfault;
	}
#endif

/*
 * Vector initialization for special motherboards 
 */
#ifdef M68040
#ifdef M68060
	else
#endif
	if (machineid & AMIGA_68040) {
		/* addrerr vector */
		vectab[2] = buserr40;
		vectab[3] = addrerr4060;
	}
#endif

#ifdef FPU_EMULATE
	if (!(machineid & (AMIGA_68881|AMIGA_68882|AMIGA_FPU40))) {
		vectab[11] = fpemuli;
		printf("FPU software emulation initialized.\n");
	}
#endif

/*
 * Vector initialization for special motherboards 
 */

#ifdef DRACO
	dracorev = is_draco();
	if (dracorev) {
		if (dracorev >= 4) {
			vectab[24+1] = DraCoLev1intr;
			vectab[24+2] = DraCoIntr;
		} else {
			vectab[24+1] = DraCoIntr;
			vectab[24+2] = DraCoLev2intr;
		}
		vectab[24+3] = DraCoIntr;
		vectab[24+4] = DraCoIntr;
		vectab[24+5] = DraCoIntr;
		vectab[24+6] = DraCoIntr;
	}
#endif
	DCIS();
}

void
straytrap(pc, evec)
	int pc;
	u_short evec;
{
	printf("unexpected trap format %x (vector offset %x) from %x\n",
	       evec>>12, evec & 0xFFF, pc);
/*XXX*/	panic("straytrap");
}

int	*nofault;

int
badaddr(addr)
	register caddr_t addr;
{
	register int i;
	label_t	faultbuf;

#ifdef lint
	i = *addr; if (i) return(0);
#endif
	nofault = (int *) &faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *) 0;
		return(1);
	}
	i = *(volatile short *)addr;
	nofault = (int *) 0;
	return(0);
}

int
badbaddr(addr)
	register caddr_t addr;
{
	register int i;
	label_t	faultbuf;

#ifdef lint
	i = *addr; if (i) return(0);
#endif
	nofault = (int *) &faultbuf;
	if (setjmp((label_t *)nofault)) {
		nofault = (int *) 0;
		return(1);
	}
	i = *(volatile char *)addr;
	nofault = (int *) 0;
	return(0);
}

void
netintr()
{
#ifdef INET
#if NETHER > 0
	if (netisr & (1 << NETISR_ARP)) {
		netisr &= ~(1 << NETISR_ARP);
		arpintr();
	}
#endif
	if (netisr & (1 << NETISR_IP)) {
		netisr &= ~(1 << NETISR_IP);
		ipintr();
	}
#endif
#ifdef INET6
	if (netisr & (1 << NETISR_IPV6)) {
		netisr &= ~(1 << NETISR_IPV6);
		ip6intr();
	}
#endif
#ifdef NETATALK
	if (netisr & (1 << NETISR_ATALK)) {
		netisr &= ~(1 << NETISR_ATALK);
		atintr();
	}
#endif
#ifdef NS
	if (netisr & (1 << NETISR_NS)) {
		netisr &= ~(1 << NETISR_NS);
		nsintr();
	}
#endif
#ifdef ISO
	if (netisr & (1 << NETISR_ISO)) {
		netisr &= ~(1 << NETISR_ISO);
		clnlintr();
	}
#endif
#if NPPP > 0
	if (netisr & (1 << NETISR_PPP)) {
		netisr &= ~(1 << NETISR_PPP);
		pppintr();
	}
#endif
#if NBRIDGE > 0
	if (netisr & (1 << NETISR_BRIDGE)) {
		netisr &= ~(1 << NETISR_BRIDGE);
		bridgeintr();
	}
#endif
}


/*
 * this is a handy package to have asynchronously executed
 * function calls executed at very low interrupt priority.
 * Example for use is keyboard repeat, where the repeat 
 * handler running at splclock() triggers such a (hardware
 * aided) software interrupt.  These functions are called in
 * a FIFO manner as expected.
 */

struct si_callback {
	struct si_callback *next;
	void (*function)(void *rock1, void *rock2);
	void *rock1, *rock2;
};
static struct si_callback *si_callbacks;
static struct si_callback *si_callbacks_end;
static struct si_callback *si_free;
#ifdef DIAGNOSTIC
static int ncb;		/* number of callback blocks allocated */
static int ncbd;	/* number of callback blocks dynamically allocated */
#endif

/*
 * these are __GENERIC_SOFT_INTERRUPT wrappers; will be replaced
 * once by the real thing once all drivers are converted.
 *
 * to help performance for converted drivers, the YYY_sicallback() function
 * family can be implemented in terms of softintr_XXX() as an intermediate
 * measure.
 */

void
_softintr_callit(rock1, rock2)
	void *rock1, *rock2;
{
	(*(void (*)(void *))rock1)(rock2);
}

void *
softintr_establish(ipl, func, arg)
	int ipl;
	void func(void *);
	void *arg;
{
	struct si_callback *si;

	(void)ipl;

	si = (struct si_callback *)malloc(sizeof(*si), M_TEMP, M_NOWAIT);
	if (si == NULL)
		return (si);

	si->function = (void *)0;
	si->rock1 = (void *)func;
	si->rock2 = arg;

	alloc_sicallback();
	return ((void *)si);
}

void
alloc_sicallback()
{
	struct si_callback *si;
	int s;

	si = (struct si_callback *)malloc(sizeof(*si), M_TEMP, M_NOWAIT);
	if (si == NULL)
		return;
	s = splhigh();
	si->next = si_free;
	si_free = si;
	splx(s);
#ifdef DIAGNOSTIC
	++ncb;
#endif
}

void
softintr_schedule(vsi)
	void *vsi;
{
	struct si_callback *si;
	si = vsi;

	add_sicallback(_softintr_callit, si->rock1, si->rock2);
}

void
add_sicallback (function, rock1, rock2)
	void (*function)(void *rock1, void *rock2);
	void *rock1, *rock2;
{
	struct si_callback *si;
	int s;

	/*
	 * this function may be called from high-priority interrupt handlers.
	 * We may NOT block for  memory-allocation in here!.
	 */
	s = splhigh();
	si = si_free;
	if (si != NULL)
		si_free = si->next;
	splx(s);

	if (si == NULL) {
		si = (struct si_callback *)malloc(sizeof(*si), M_TEMP,
		    M_NOWAIT);
#ifdef DIAGNOSTIC
		if (si)
			++ncbd;		/* count # dynamically allocated */
#endif

		if (!si)
			return;
	}

	si->function = function;
	si->rock1 = rock1;
	si->rock2 = rock2;

	s = splhigh();
	si->next = NULL;
	if (si_callbacks)
		si_callbacks_end->next = si;
	else
		si_callbacks = si;
	si_callbacks_end = si;
	splx(s);

	/*
	 * Cause a software interrupt (spl1). This interrupt might
	 * happen immediately, or after returning to a safe enough level.
	 */
	setsoftcback();
}


void
rem_sicallback(function)
	void (*function)(void *rock1, void *rock2);
{
	struct si_callback *si, *psi, *nsi;
	int s;

	s = splhigh();
	for (psi = 0, si = si_callbacks; si; ) {
		nsi = si->next;

		if (si->function != function)
			psi = si;
		else {
			si->next = si_free;
			si_free = si;
			if (psi)
				psi->next = nsi;
			else
				si_callbacks = nsi;
			if (si == si_callbacks_end)
				si_callbacks_end = psi;
		}
		si = nsi;
	}
	splx(s);
}

/* purge the list */
void
call_sicallbacks()
{
	struct si_callback *si;
	int s;
	void *rock1, *rock2;
	void (*function)(void *, void *);

	do {
		s = splhigh ();
		if ((si = si_callbacks) != 0)
			si_callbacks = si->next;
		splx(s);

		if (si) {
			function = si->function;
			rock1 = si->rock1;
			rock2 = si->rock2;
			s = splhigh ();
			si->next = si_free;
			si_free = si;
			splx(s);
			function (rock1, rock2);
		}
	} while (si);
#ifdef DIAGNOSTIC
	if (ncbd) {
		ncb += ncbd;
		printf ("call_sicallback: "
		    "%d more dynamic structures %d total\n", ncbd, ncb);
		ncbd = 0;
	}
#endif
}

void
add_isr(isr)
	struct isr *isr;
{
	struct isr **p, *q;

	switch (isr->isr_ipl) {
	case 2:
		p = &isr_ports;
		break;
#ifdef DRACO
	case 3:
		p = &isr_slot3;
		break;

	case 5:
		p = &isr_supio;
		break;
#endif
	case 6:
#if defined(IPL_REMAP_1) || defined(IPL_REMAP_2)
		p = &isr_exter[isr->isr_mapped_ipl];
		if (isr->isr_mapped_ipl > isr_exter_highipl)
			isr_exter_highipl = isr->isr_mapped_ipl;
		if (isr->isr_mapped_ipl < isr_exter_lowipl)
			isr_exter_lowipl = isr->isr_mapped_ipl;
#else
		p = &isr_exter;
#endif
		break;
	default:
		panic("add_isr: bad isr_ipl (%d)", isr->isr_ipl);
	}
	while ((q = *p) != NULL)
		p = &q->isr_forw;
	isr->isr_forw = NULL;
	*p = isr;
	/* enable interrupt */
#ifdef DRACO
	if (is_draco())
		switch(isr->isr_ipl) {
			case 6:
				*draco_intena |= DRIRQ_INT6;
				break;
			case 2:
				*draco_intena |= DRIRQ_INT2;
				break;
			default:
				break;
		}
	else 
#endif
		custom.intena = INTF_SETCLR |
		    (isr->isr_ipl == 2 ? INTF_PORTS : INTF_EXTER);
}

void
remove_isr(isr)
	struct isr *isr;
{
	struct isr **p, *q, **chain;

	switch (isr->isr_ipl) {
	case 2:
		chain = &isr_ports;
		break;
#ifdef DRACO
	case 3:
		chain = &isr_slot3;
		break;

	case 5:
		chain = &isr_supio;
		break;
#endif
	case 6:
#if defined(IPL_REMAP_1) || defined(IPL_REMAP_2)
		chain = &isr_exter[isr->isr_mapped_ipl];
#else
		chain = &isr_exter;
#endif
		break;
	default:
		panic("remove_isr: bad isr_ipl (%d)", isr->isr_ipl);
	}
	for (p = chain; (q = *p) != NULL && q != isr; p = &q->isr_forw)
		;
	if (q)
		*p = q->isr_forw;
	else
		panic("remove_isr: handler not registered");
	/* disable interrupt if no more handlers */
	if (*chain == NULL)
		switch (isr->isr_ipl) {
		case 2:
#ifdef DRACO
			if (is_draco())
				*draco_intena &= ~DRIRQ_INT2;
			else
#endif
				custom.intena = INTF_PORTS;
			break;
		case 6:
#if defined(IPL_REMAP_1) || defined(IPL_REMAP_2)
			if (isr->isr_mapped_ipl == isr_exter_lowipl) {
				while (isr_exter_lowipl++ < 6 &&
				    isr_exter[isr_exter_lowipl] == NULL)
					;
				if (isr_exter_lowipl == 7) {
#ifdef DRACO
					if (is_draco())
						*draco_intena &= ~DRIRQ_INT6;
					else
#endif
						custom.intena = INTF_EXTER;
				}
			}
			if (isr->isr_mapped_ipl == isr_exter_highipl)
				while (isr_exter_highipl-- > 0 &&
				    isr_exter[isr_exter_highipl] == NULL)
					;
#else
#ifdef DRACO
			if (is_draco())
				*draco_intena &= ~DRIRQ_INT6;
			else
#endif
				custom.intena = INTF_EXTER;
#endif
			break;
		}
}

void
intrhand(sr)
	int sr;
{
	register unsigned int ipl;
	register unsigned short ireq;
	register struct isr **p, *q;

	ipl = (sr >> 8) & 7;
#ifdef REALLYDEBUG
	printf("intrhand: got int. %d\n", ipl);
#endif
#ifdef DRACO
	if (is_draco())
		ireq = ((ipl == 1)  && (*draco_intfrc & DRIRQ_SOFT) ?
		    INTF_SOFTINT : 0);
	else
#endif
		ireq = custom.intreqr;

	switch (ipl) {
	case 1:
#ifdef DRACO
		if (is_draco() && (draco_ioct->io_status & DRSTAT_KBDRECV))
			drkbdintr();
#endif
		if (ireq & INTF_TBE) {
#if NSER > 0
			ser_outintr();
#else
			custom.intreq = INTF_TBE;
#endif
		}

		if (ireq & INTF_DSKBLK) {
#if NFD > 0
			fdintr(0);
#endif
			custom.intreq = INTF_DSKBLK;
		}
		if (ireq & INTF_SOFTINT) {
			unsigned char ssir_active;
			int s;

			/*
			 * first clear the softint-bit
			 * then process all classes of softints.
			 * this order is dictated by the nature of 
			 * software interrupts.  The other order
			 * allows software interrupts to be missed.
			 * Also copy and clear ssir to prevent
			 * interrupt loss.
			 */
			clrsoftint();
			s = splhigh();
			ssir_active = ssir;
			siroff(SIR_NET | SIR_CLOCK | SIR_CBACK);
			splx(s);
			if (ssir_active & SIR_NET) {
#ifdef REALLYDEBUG
				printf("calling netintr\n");
#endif
				uvmexp.softs++;
				netintr();
			}
			if (ssir_active & SIR_CLOCK) {
#ifdef REALLYDEBUG
				printf("calling softclock\n");
#endif
				uvmexp.softs++;
				/* XXXX softclock(&frame.f_stackadj); */
				softclock();
			}
			if (ssir_active & SIR_CBACK) {
#ifdef REALLYDEBUG
				printf("calling softcallbacks\n");
#endif
				uvmexp.softs++;
				call_sicallbacks();
			}
		}
		break;

	case 2:
		p = &isr_ports;
		while ((q = *p) != NULL) {
			if ((q->isr_intr)(q->isr_arg))
				break;
			p = &q->isr_forw;
		}
		if (q == NULL)
			ciaa_intr ();
#ifdef DRACO
		if (is_draco())
			*draco_intpen &= ~DRIRQ_INT2;
		else
#endif
			custom.intreq = INTF_PORTS;
		break;
    case 3: 
      /* VBL */
		if (ireq & INTF_BLIT)
			blitter_handler();
		if (ireq & INTF_COPER)
			copper_handler();
		if (ireq & INTF_VERTB)
			vbl_handler();
		break;
#ifdef DRACO
	case 5:
		p = &isr_supio;
		while ((q = *p) != NULL) {
			if ((q->isr_intr)(q->isr_arg))
				break;
			p = &q->isr_forw;
		}
		break;
#endif
#if 0
/* now dealt with in locore.s for speed reasons */
	case 5:
		/* check RS232 RBF */
		serintr (0);

		custom.intreq = INTF_DSKSYNC;
		break;
#endif

	case 4:
#ifdef DRACO
#include "drsc.h"
		if (is_draco())
#if NDRSC > 0
			drsc_handler();
#else
			*draco_intpen &= ~DRIRQ_SCSI;
#endif
		else
#endif
		audio_handler();
		break;
	default:
		printf("intrhand: unexpected sr 0x%x, intreq = 0x%x\n",
		    sr, ireq);
		break;
	}
#ifdef REALLYDEBUG
	printf("intrhand: leaving.\n");
#endif
}

#if defined(DEBUG) && !defined(PANICBUTTON)
#define PANICBUTTON
#endif

#ifdef PANICBUTTON
int panicbutton = 1;	/* non-zero if panic buttons are enabled */
int crashandburn = 0;
int candbdelay = 50;	/* give em half a second */
void candbtimer(void);

void
candbtimer()
{
	crashandburn = 0;
}
#endif

#if 0
/*
 * Level 7 interrupts can be caused by the keyboard or parity errors.
 */
nmihand(frame)
	struct frame frame;
{
	if (kbdnmi()) {
#ifdef PANICBUTTON
		static int innmihand = 0;

		/*
		 * Attempt to reduce the window of vulnerability for recursive
		 * NMIs (e.g. someone holding down the keyboard reset button).
		 */
		if (innmihand == 0) {
			innmihand = 1;
			printf("Got a keyboard NMI\n");
			innmihand = 0;
		}
		if (panicbutton) {
			if (crashandburn) {
				crashandburn = 0;
				panic(panicstr ?
				      "forced crash, nosync" : "forced crash");
			}
			crashandburn++;
			timeout(candbtimer, (caddr_t)0, candbdelay);
		}
#endif
		return;
	}
	if (parityerror(&frame))
		return;
	/* panic?? */
	printf("unexpected level 7 interrupt ignored\n");
}
#endif

/*
 * should only get here, if no standard executable. This can currently
 * only mean, we're reading an old ZMAGIC file without MID, but since Amiga
 * ZMAGIC always worked the `right' way (;-)) just ignore the missing
 * MID and proceed to new zmagic code ;-)
 */
int
cpu_exec_aout_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	int error = ENOEXEC;
#ifdef COMPAT_NOMID
	struct exec *execp = epp->ep_hdr;
#endif

#ifdef COMPAT_NOMID
	if (!((execp->a_midmag >> 16) & 0x0fff)
	    && execp->a_midmag == ZMAGIC)
		return(exec_aout_prep_zmagic(p, epp));
#endif
#ifdef COMPAT_SUNOS
	{
		extern int sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
		if ((error = sunos_exec_aout_makecmds(p, epp)) == 0)
			return(0);
	}
#endif
	return(error);
}
@


1.71
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.70 2002/06/11 03:25:31 miod Exp $	*/
@


1.70
log
@Include <sys/conf.h> from <machine/conf.h> like in other arches.  Changes
to come soon depend on this.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.69 2002/03/23 13:28:33 espie Exp $	*/
a67 3
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
a70 3
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
a358 12
#ifdef SYSVSHM
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
@


1.69
log
@Add variables for config(8) -e time tweak of systemV shared memory
parameters.

Ok millert@@, miod@@, maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.68 2002/03/14 20:31:30 mickey Exp $	*/
a52 1
#include <sys/conf.h>
d86 1
@


1.68
log
@remove ambiguity in version,ostype,osversion,osrelease and their constanity, they are and declarre 'em accordingly also removing private externies of those
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2002/03/14 01:26:28 millert Exp $	*/
d366 3
@


1.67
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 2002/02/04 23:54:33 miod Exp $	*/
a578 1
extern char version[];
@


1.66
log
@Oops, missed a <sys/map.h> leftover.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.65 2002/01/23 17:51:52 art Exp $	*/
d110 9
a118 9
void identifycpu __P((void));
vm_offset_t reserve_dumppages __P((vm_offset_t));
void dumpsys __P((void));
void initcpu __P((void));
void straytrap __P((int, u_short));
void netintr __P((void));
void call_sicallbacks __P((void));
void _softintr_callit __P((void *, void *));
void intrhand __P((int));
d120 1
a120 1
void ser_outintr __P((void));
d123 1
a123 1
void fdintr __P((int));
d854 1
a854 1
	int     (*dump) __P((dev_t, daddr_t, caddr_t, size_t));
d995 1
a995 1
	typedef void trapfun __P((void));
d1238 1
a1238 1
	void (*function) __P((void *rock1, void *rock2));
d1268 1
a1268 1
	void func __P((void *));
d1317 1
a1317 1
	void (*function) __P((void *rock1, void *rock2));
d1368 1
a1368 1
	void (*function) __P((void *rock1, void *rock2));
d1401 1
a1401 1
	void (*function) __P((void *, void *));
d1722 1
a1722 1
void candbtimer __P((void));
d1793 1
a1793 2
		extern int sunos_exec_aout_makecmds
		    __P((struct proc *, struct exec_package *));
@


1.65
log
@move mb_map allocation to mbinit()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 2002/01/23 17:35:56 art Exp $	*/
a49 1
#include <sys/map.h>
@


1.64
log
@move definition of mb_map from zillions of machdep.c to uipc_mbuf.c
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 2001/12/08 02:24:06 art Exp $	*/
a474 3

	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				 VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
@


1.63
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 2001/11/30 02:09:34 art Exp $	*/
a132 1
struct vm_map *mb_map = NULL;
@


1.63.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.65 2002/01/23 17:51:52 art Exp $	*/
d133 1
d476 3
@


1.63.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63.2.1 2002/01/31 22:55:06 niklas Exp $	*/
d50 1
d111 9
a119 9
void identifycpu(void);
vm_offset_t reserve_dumppages(vm_offset_t);
void dumpsys(void);
void initcpu(void);
void straytrap(int, u_short);
void netintr(void);
void call_sicallbacks(void);
void _softintr_callit(void *, void *);
void intrhand(int);
d121 1
a121 1
void ser_outintr(void);
d124 1
a124 1
void fdintr(int);
a366 3
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
d580 1
d855 1
a855 1
	int     (*dump)(dev_t, daddr_t, caddr_t, size_t);
d996 1
a996 1
	typedef void trapfun(void);
d1239 1
a1239 1
	void (*function)(void *rock1, void *rock2);
d1269 1
a1269 1
	void func(void *);
d1318 1
a1318 1
	void (*function)(void *rock1, void *rock2);
d1369 1
a1369 1
	void (*function)(void *rock1, void *rock2);
d1402 1
a1402 1
	void (*function)(void *, void *);
d1723 1
a1723 1
void candbtimer(void);
d1794 2
a1795 1
		extern int sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
@


1.63.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63.2.2 2002/06/11 03:34:57 art Exp $	*/
d53 1
a86 1
#include <machine/conf.h>
@


1.63.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63.2.3 2002/10/29 00:28:01 art Exp $	*/
@


1.62
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 2001/11/28 16:13:27 art Exp $	*/
d302 2
a303 2
	register unsigned i;
	register caddr_t v, firstaddr;
d309 1
a309 1
	vm_offset_t minaddr, maxaddr;
d311 2
d327 8
a334 4
	for (i = 0; i < btoc(MSGBUFSIZE); i++)
		pmap_enter(pmap_kernel(), (vm_offset_t)msgbufp,
		    msgbufpa + i * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d461 1
@


1.61
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 2001/11/28 13:57:18 art Exp $	*/
d450 1
a450 1
			pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg),
@


1.60
log
@pmap_kenter_pgs(.., 1) is pointless. pmap_kenter_pa instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.59 2001/11/28 13:47:37 art Exp $	*/
d132 3
a134 3
vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
@


1.59
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 2001/11/24 17:53:41 miod Exp $	*/
d449 3
a451 1
			pmap_kenter_pgs(curbuf, &pg, 1);
@


1.58
log
@Harmonize boot() logic across arches:
- ensure RB_DUMP | RB_HALT will cause a dump
- or RB_HALT if (cold)
While there, honor RB_TIMEBAD on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 2001/11/09 15:25:55 art Exp $	*/
d421 1
a421 1
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
@


1.57
log
@nswbuf hasn't been used for ages. gc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 2001/11/07 01:18:00 art Exp $	*/
d742 6
d771 1
@


1.56
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.55 2001/11/06 19:53:13 miod Exp $	*/
a138 1
int	nswbuf = 0;
a394 5
	if (nswbuf == 0) {
		nswbuf = (nbuf * 3 / 4) &~ 1;	/* force even */
		if (nswbuf > 256)
			nswbuf = 256;		/* sanity */
	}
@


1.55
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2001/09/19 20:50:56 mickey Exp $	*/
d425 1
a425 1
		    NULL, UVM_UNKNOWN_OFFSET,
@


1.54
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.53 2001/09/12 00:23:33 art Exp $	*/
a81 1
#include <vm/vm.h>
@


1.53
log
@mbutl no more
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2001/08/23 14:01:02 art Exp $	*/
d83 1
a83 1
#include <vm/vm_kern.h>
@


1.52
log
@We can now move timeout_init into main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 2001/08/23 12:02:04 art Exp $	*/
d475 1
a475 1
	mb_map = uvm_km_suballoc(kernel_map, (vaddr_t *)&mbutl, &maxaddr,
@


1.51
log
@Remove even more old timeout tentacles.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.50 2001/08/12 21:36:47 mickey Exp $	*/
a476 5

	/*
	 * Initialize timeouts
	 */
	timeout_init();
@


1.50
log
@vm_pager.h no more
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 2001/07/25 13:25:31 art Exp $	*/
a362 2
/*	valloc(cfree, struct cblock, nclist); */
	valloc(timeouts, struct timeout, ntimeout);
@


1.49
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2001/07/18 10:47:04 art Exp $	*/
d81 2
a82 3
#include <vm/vm_param.h>
#include <vm/pmap.h>
#include <vm/vm_map.h>
a83 4
#include <vm/vm_page.h>
#include <vm/vm_pager.h>

#include <uvm/uvm_extern.h>
@


1.48
log
@Get rid of the PMAP_NEW option by making it mandatory for all archs.
The archs that didn't have a proper PMAP_NEW now have a dummy implementation
with wrappers around the old functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 2001/07/05 07:17:52 art Exp $	*/
d334 2
a335 2
		    msgbufpa + i * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE, TRUE,
		    VM_PROT_READ|VM_PROT_WRITE);
@


1.47
log
@clean up includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2001/06/27 03:54:12 art Exp $	*/
a462 1
#if defined(PMAP_NEW)
a463 5
#else
			pmap_enter(kernel_map->pmap, curbuf,
				   VM_PAGE_TO_PHYS(pg), VM_PROT_ALL, TRUE,
				   VM_PROT_READ|VM_PROT_WRITE);
#endif
@


1.46
log
@No more old VM on amiga.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2001/06/06 21:21:12 miod Exp $	*/
a83 1
#include <vm/vm_object.h>
d86 1
@


1.45
log
@Call doshutdownhooks() in boot(). ok jj@@ niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2001/05/17 18:41:47 provos Exp $	*/
a87 1
#if defined(UVM)
a88 1
#endif
a137 1
#if defined(UVM)
a140 1
#endif
a408 3
#if !defined(UVM)
	valloc(swbuf, struct buf, nswbuf);
#endif
a414 1
#if defined(UVM)
a416 3
#else
		firstaddr = (caddr_t) kmem_alloc(kernel_map, round_page(size));
#endif
a431 1
#if defined(UVM)
a437 8
#else
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
				   &maxaddr, size, TRUE);
	minaddr = (vm_offset_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
			&minaddr, size, FALSE) != KERN_SUCCESS)
		panic("startup: cannot allocate buffers");
#endif
a444 1
#if defined(UVM)
a472 16
#else
		vm_size_t curbufsize;
		vm_offset_t curbuf;

		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
		curbufsize = PAGE_SIZE * (i < residual ? base+1 : base);
		vm_map_pageable(buffer_map, curbuf, curbuf+curbufsize, FALSE);
		vm_map_simplify(buffer_map, curbuf);
#endif
a478 1
#if defined(UVM)
a480 4
#else
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr, 16 * NCARGS,
	    TRUE);
#endif
a484 1
#if defined(UVM)
a486 4
#else
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr, VM_PHYS_SIZE,
	    TRUE);
#endif
a487 1
#if defined(UVM)
a489 4
#else
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
	    VM_MBUF_SIZE, FALSE);
#endif
a498 1
#if defined(UVM)
a499 4
#else
	printf("avail mem = %ld (%ld pages)\n", ptoa(cnt.v_free_count),
	    ptoa(cnt.v_free_count)/NBPG);
#endif
a1638 1
#if defined(UVM)
a1639 3
#else
				cnt.v_soft++;
#endif
a1645 1
#if defined(UVM)
a1646 3
#else
				cnt.v_soft++;
#endif
a1653 1
#if defined(UVM)
a1654 3
#else
				cnt.v_soft++;
#endif
@


1.44
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2001/05/05 22:33:28 art Exp $	*/
d846 3
@


1.43
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2001/05/05 20:56:32 art Exp $	*/
a534 7
	/*
	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
	 * we use the more space efficient malloc in place of kmem_alloc.
	 */
	mclrefcnt = (char *)malloc(NMBCLUSTERS + PAGE_SIZE / MCLBYTES, M_MBUF,
	    M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS+PAGE_SIZE/MCLBYTES);
@


1.42
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 2000/05/28 02:23:30 art Exp $	*/
a605 4
	configure();
#ifdef DEBUG_KERNEL_START
	printf("survived configure...\n");
#endif
@


1.41
log
@missing arguments and typos.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2000/05/27 20:44:41 art Exp $	*/
d80 1
a80 1
#define	MAXMEM	64*1024*CLSIZE	/* XXX - from cmap.h */
d397 1
a397 1
			bufpages = physmem / (10 * CLSIZE);
d399 1
a399 2
			bufpages = (btoc(2 * 1024 * 1024) + physmem) /
			    (20 * CLSIZE);
d477 1
a477 1
		curbufsize = CLBYTES * ((i < residual) ? (base+1) : base);
d506 1
a506 1
		curbufsize = CLBYTES * (i < residual ? base+1 : base);
d539 1
a539 1
	mclrefcnt = (char *)malloc(NMBCLUSTERS + CLBYTES / MCLBYTES, M_MBUF,
d541 1
a541 1
	bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
d565 1
a565 1
	    bufpages * CLBYTES);
d904 1
a904 1
	 * Don't dump on the first CLBYTES (why CLBYTES?)
d907 2
a908 2
	if (dumplo < btodb(CLBYTES))
		dumplo = btodb(CLBYTES);
@


1.40
log
@uvm support.
Buffer cache allocation code from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 2000/05/27 19:42:49 art Exp $	*/
d481 1
a481 1
			pg = uvm_pagealloc(NULL, 0, NULL);
d489 2
a490 1
				   VM_PAGE_TO_PHYS(pg), VM_PROT_ALL, TRUE);
d545 1
a545 1
				 VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE; NULL);
@


1.39
log
@MACHINE_NEW_NONCONTIG code for amiga. Enabled by default.
Old contig and NONCONTIG code will no longer work.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 2000/04/11 02:44:23 pjanzen Exp $	*/
d88 4
d140 6
d414 1
d416 1
d423 4
d428 1
d444 8
d458 1
d466 29
d509 1
d516 4
d522 1
d527 4
d533 1
d542 4
d548 1
d558 3
d563 1
d1704 3
d1708 1
d1715 3
d1719 1
d1727 3
d1731 1
@


1.38
log
@Check usec for >= 1000000, not just > ; as msaitoh@@NetBSD.org
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 2000/03/23 09:59:53 art Exp $	*/
a113 4
/* vm_map_t buffer_map; */
extern vm_offset_t avail_end;
extern vm_offset_t avail_start;

d150 3
a311 7
#if defined(MACHINE_NONCONTIG) && defined(DEBUG)
	extern struct {
		vm_offset_t start;
		vm_offset_t end;
		int first_page;
	} phys_segs[16];
#endif
d319 7
a325 1
	/* avail_end was pre-decremented in pmap_bootstrap to compensate */
d327 2
a328 2
		pmap_enter(pmap_kernel(), (vm_offset_t)msgbufp, 
		    avail_end + i * NBPG, VM_PROT_READ|VM_PROT_WRITE, TRUE,
a499 8
#if defined(MACHINE_NONCONTIG) && defined(DEBUG)
	printf("Physical memory segments:\n");
	for (i = 0; i < memlist->m_nseg && phys_segs[i].start; ++i)
		printf("Physical segment %d at %08lx size %ld offset %d\n", i,
		    phys_segs[i].start,
		    (phys_segs[i].end - phys_segs[i].start) / NBPG,
		    phys_segs[i].first_page);
#endif
@


1.37
log
@New API for timeouts. Replaces the old timeout()/untimeout() API and
makes it the callers responsibility to allocate resources for the
timeouts.

This is a KISS implementation and does _not_ solve the problems of slow
handling of a large number of pending timeouts (this will be solved in
future work) (although hardclock is now guarateed to take constant time
for handling of timeouts).

Old timeout() and untimeout() are implemented as wrappers around the new
API and kept for compatibility. They will be removed as soon as all
subsystems are converted to use the new API.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2000/02/22 19:27:42 deraadt Exp $	*/
d992 1
a992 1
	while (tvp->tv_usec > 1000000) {
d998 1
a998 1
	    (tvp->tv_usec = lasttime.tv_usec + 1) > 1000000) {
@


1.36
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 1999/12/08 06:50:14 itojun Exp $	*/
d57 1
a57 1
#include <sys/callout.h>
d365 1
a365 1
	valloc(callout, struct callout, ncallout);
d482 1
a482 1
	 * Initialize callouts
d484 1
a484 3
	callfree = callout;
	for (i = 1; i < ncallout; i++)
		callout[i - 1].c_next = &callout[i];
@


1.35
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 1999/05/24 23:08:55 jason Exp $	*/
a153 1
int	msgbufmapped;		/* set when safe to use msgbuf */
d328 1
a328 1
	for (i = 0; i < btoc(sizeof (struct msgbuf)); i++)
d332 1
a332 1
	msgbufmapped = 1;
d875 1
@


1.35.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d154 1
d329 1
a329 1
	for (i = 0; i < btoc(MSGBUFSIZE); i++)
d333 1
a333 1
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));
a875 1
	extern int msgbufmapped;
@


1.35.2.2
log
@Sync with -current
@
text
@d57 1
a57 1
#include <sys/timeout.h>
d365 1
a365 1
	valloc(timeouts, struct timeout, ntimeout);
d482 1
a482 1
	 * Initialize timeouts
d484 3
a486 1
	timeout_init();
@


1.35.2.3
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 2000/05/28 02:23:30 art Exp $	*/
a87 4
#if defined(UVM)
#include <uvm/uvm_extern.h>
#endif

d114 4
a139 6
#if defined(UVM)
vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
#endif

a153 3

paddr_t	msgbufpa;

d313 7
d327 1
a327 7
	/*
	 * pmap_bootstrap has positioned this at the end of kernel
	 * memory segment - map and initialize it now.
	 */
	/*
	 * XXX - shouldn't this be msgbufp + i * PAGE_SIZE?
	 */
d329 2
a330 2
		pmap_enter(pmap_kernel(), (vm_offset_t)msgbufp,
		    msgbufpa + i * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE, TRUE,
a405 1
#if !defined(UVM)
a406 1
#endif
a412 4
#if defined(UVM)
		firstaddr = (caddr_t) uvm_km_zalloc(kernel_map,
						    round_page(size));
#else
a413 1
#endif
a428 8
#if defined(UVM)
	if (uvm_map(kernel_map, (vaddr_t *)&buffers, round_page(size),
		    NULL, UVM_UNKNOWN_OFFSET,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
		panic("startup: cannot allocate buffers");
	minaddr = (vaddr_t) buffers;
#else
a434 1
#endif
a441 30
#if defined(UVM)
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;

		/*
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vm_offset_t) buffers + (i * MAXBSIZE);
		curbufsize = CLBYTES * ((i < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for "
				      "buffer cache");
#if defined(PMAP_NEW)
			pmap_kenter_pgs(curbuf, &pg, 1);
#else
			pmap_enter(kernel_map->pmap, curbuf,
				   VM_PAGE_TO_PHYS(pg), VM_PROT_ALL, TRUE,
				   VM_PROT_READ|VM_PROT_WRITE);
#endif
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
#else
a455 1
#endif
a461 4
#if defined(UVM)
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
#else
a463 1
#endif
a467 4
#if defined(UVM)
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   VM_PHYS_SIZE, 0, FALSE, NULL);
#else
a469 1
#endif
a477 4
#if defined(UVM)
	mb_map = uvm_km_suballoc(kernel_map, (vaddr_t *)&mbutl, &maxaddr,
				 VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
#else
a479 1
#endif
a488 3
#if defined(UVM)
	printf("avail mem = %ld (%ld pages)\n", ptoa(uvmexp.free), uvmexp.free);
#else
a490 1
#endif
d502 8
d992 1
a992 1
	while (tvp->tv_usec >= 1000000) {
d998 1
a998 1
	    (tvp->tv_usec = lasttime.tv_usec + 1) >= 1000000) {
a1638 3
#if defined(UVM)
				uvmexp.softs++;
#else
a1639 1
#endif
a1645 3
#if defined(UVM)
				uvmexp.softs++;
#else
a1646 1
#endif
a1653 3
#if defined(UVM)
				uvmexp.softs++;
#else
a1654 1
#endif
@


1.35.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35.2.3 2001/04/18 16:01:57 niklas Exp $	*/
d80 1
a80 1
#define	MAXMEM	64*1024	/* XXX - from cmap.h */
d88 1
d90 1
d140 1
d144 1
d397 1
a397 1
			bufpages = physmem / (10);
d399 2
a400 1
			bufpages = (btoc(2 * 1024 * 1024) + physmem) / 20;
d414 3
d423 1
d426 3
d444 1
d451 8
d466 1
d478 1
a478 1
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);
d495 16
d517 1
d520 4
d528 1
d531 4
d536 8
d546 4
d559 1
d561 4
d566 1
a566 1
	    bufpages * PAGE_SIZE);
d607 4
a858 3
	/* Run any shutdown hooks. */
	doshutdownhooks();

d905 1
a905 1
	 * Don't dump on the first PAGE_SIZE
d908 2
a909 2
	if (dumplo < btodb(PAGE_SIZE))
		dumplo = btodb(PAGE_SIZE);
d1705 1
d1707 3
d1716 1
d1718 3
d1728 1
d1730 3
@


1.35.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35.2.4 2001/07/04 10:14:57 niklas Exp $	*/
d81 6
a87 1
#include <vm/vm.h>
d334 2
a335 2
		    msgbufpa + i * PAGE_SIZE, VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d368 2
d463 1
d465 5
d488 1
a488 1
	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
d490 5
@


1.35.2.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d82 1
d140 1
d397 5
d426 1
a426 1
		    NULL, UVM_UNKNOWN_OFFSET, 0,
@


1.35.2.7
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35.2.6 2001/11/13 21:00:50 niklas Exp $	*/
d132 3
a134 3
struct vm_map *exec_map = NULL;
struct vm_map *mb_map = NULL;
struct vm_map *phys_map = NULL;
d421 1
a421 1
				UVM_ADV_NORMAL, 0)))
d449 1
a449 3

			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ|VM_PROT_WRITE);
a741 6
	/* If system is cold, just halt. */
	if (cold) {
		howto |= RB_HALT;
		goto haltsys;
	}

a764 1
haltsys:
@


1.35.2.8
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 1
d133 1
d302 2
a303 2
	unsigned i;
	caddr_t v, firstaddr;
d309 1
a309 1
	vaddr_t minaddr, maxaddr;
a310 2
	vaddr_t va;
	paddr_t pa;
d325 4
a328 8
	va = (vaddr_t)msgbufp;
	pa = (paddr_t)msgbufpa;
	for (i = 0; i < btoc(MSGBUFSIZE); i++) {
		pmap_kenter_pa(va, pa, VM_PROT_READ|VM_PROT_WRITE);
		va += PAGE_SIZE;
		pa += PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
a454 1
		pmap_update(pmap_kernel());
d469 3
@


1.35.2.9
log
@Merge in -current from about a week ago
@
text
@d110 9
a118 9
void identifycpu(void);
vm_offset_t reserve_dumppages(vm_offset_t);
void dumpsys(void);
void initcpu(void);
void straytrap(int, u_short);
void netintr(void);
void call_sicallbacks(void);
void _softintr_callit(void *, void *);
void intrhand(int);
d120 1
a120 1
void ser_outintr(void);
d123 1
a123 1
void fdintr(int);
d579 1
d854 1
a854 1
	int     (*dump)(dev_t, daddr_t, caddr_t, size_t);
d995 1
a995 1
	typedef void trapfun(void);
d1238 1
a1238 1
	void (*function)(void *rock1, void *rock2);
d1268 1
a1268 1
	void func(void *);
d1317 1
a1317 1
	void (*function)(void *rock1, void *rock2);
d1368 1
a1368 1
	void (*function)(void *rock1, void *rock2);
d1401 1
a1401 1
	void (*function)(void *, void *);
d1722 1
a1722 1
void candbtimer(void);
d1793 2
a1794 1
		extern int sunos_exec_aout_makecmds(struct proc *, struct exec_package *);
@


1.35.2.10
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35.2.9 2002/03/28 10:06:14 niklas Exp $	*/
@


1.34
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 1999/05/24 23:08:58 jason Exp $	*/
a110 1
#include "bridge.h"
d1207 1
a1207 1
		ipv6intr();
@


1.33
log
@Only do basic work in the ethernet interrupt context, and queue packets to
be bridged.  Do the real work in a scheduled netisr.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 1999/05/22 21:22:18 weingart Exp $	*/
d332 2
a333 1
		    avail_end + i * NBPG, VM_PROT_ALL, TRUE);
@


1.32
log
@Add new vm_swap code for dynamic swap.  From netbsd, munged some by me, and
others.   syscall commit pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 1999/01/20 12:06:52 niklas Exp $	*/
d111 1
d1232 6
@


1.31
log
@Clear regs on process startup; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 1999/01/07 23:15:54 deraadt Exp $	*/
a365 1
	valloc(swapmap, struct map, nswapmap = maxproc * 2);
@


1.30
log
@global decl for *intr() routines, plus add INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 1998/03/01 14:35:42 niklas Exp $	*/
a551 2
 * XXX Should clear registers except sp, pc,
 * but would break init; should be fixed soon.
d562 1
d564 15
a579 1
	frame->f_regs[A2] = (int)PS_STRINGS;
@


1.29
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 1998/02/22 20:34:03 niklas Exp $	*/
a111 1
#include <net/netisr.h>
a113 23
#ifdef INET
#include <netinet/in.h>
#ifdef NETHER
#include <netinet/if_ether.h>
#endif
#include <netinet/ip_var.h>
#endif 
#ifdef NS
#include <netns/ns_var.h>
#endif
#ifdef ISO
#include <netiso/iso.h>
#include <netiso/clnp.h>
#endif
#ifdef NETATALK
#include <netatalk/at_extern.h>
#endif
#if NPPP > 0
#include <net/ppp_defs.h>
#include <net/if_ppp.h>
#endif


d1189 6
@


1.28
log
@provide a global to hold the current speed of the internal
serial port for use by SCSI drivers to limit their DMA length when the
port is in high speed.  This can limit loss of input.  From NetBSD (mhitch)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 1997/10/07 10:57:14 niklas Exp $	*/
d412 1
a412 1
  	if (bufpages == 0)
d418 1
d1553 1
a1553 1
				if (isr_exter_lowipl == 7)
d1560 1
d1808 1
a1808 1
		extern sunos_exec_aout_makecmds
@


1.27
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 1997/09/19 17:16:14 niklas Exp $	*/
d288 6
@


1.26
log
@Kill FPCOPROC (and some forgotten {SWAP,DEV}PAGER)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 1997/09/18 13:39:36 niklas Exp $	*/
d480 2
a481 2
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 16*NCARGS, TRUE);
d486 2
a487 2
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 VM_PHYS_SIZE, TRUE);
d493 2
a494 2
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
				   M_MBUF, M_NOWAIT);
d497 1
a497 1
			       VM_MBUF_SIZE, FALSE);
d504 1
a504 1
		callout[i-1].c_next = &callout[i];
@


1.25
log
@Merge of NetBSD changes upto last week or so, with the exception of stand/
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 1997/07/23 06:58:17 denny Exp $	*/
a584 1
#ifdef FPCOPROC
a592 1
#endif
a756 296

/*
 * Send an interrupt to process.
 */
void
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
{
	register struct proc *p = curproc;
	register struct sigframe *fp, *kfp;
	register struct frame *frame;
	register struct sigacts *psp = p->p_sigacts;
	register short ft;
	int oonstack, fsize;
	extern char sigcode[], esigcode[];

	frame = (struct frame *)p->p_md.md_regs;
	ft = frame->f_format;
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;

	/*
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in P0 space, the
	 * call to grow() is a nop, and the useracc() check
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
	 */
	fsize = sizeof(struct sigframe);
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
	} else
		fp = (struct sigframe *)(frame->f_regs[SP] - fsize);
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
		(void)grow(p, (unsigned)fp);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d ssp %p usp %p scp %p ft %d\n",
		    p->p_pid, sig, &oonstack, fp, &fp->sf_sc, ft);
#endif
	if (useracc((caddr_t)fp, fsize, B_WRITE) == 0) {
#ifdef DEBUG
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sendsig(%d): useracc failed on sig %d\n",
			    p->p_pid, sig);
#endif
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}
	kfp = (struct sigframe *)malloc((u_long)fsize, M_TEMP, M_WAITOK);
	/* 
	 * Build the argument list for the signal handler.
	 */
	kfp->sf_signum = sig;
	kfp->sf_sip = NULL;
	kfp->sf_scp = &fp->sf_sc;
	kfp->sf_handler = catcher;

	/*
	 * Save necessary hardware state.  Currently this includes:
	 *	- general registers
	 *	- original exception frame (if not a "normal" frame)
	 *	- FP coprocessor state
	 */
	kfp->sf_state.ss_flags = SS_USERREGS;
	bcopy((caddr_t)frame->f_regs,
	    (caddr_t)kfp->sf_state.ss_frame.f_regs, sizeof frame->f_regs);
	if (ft >= FMT7) {
#ifdef DEBUG
		if (ft > 15 || exframesize[ft] < 0)
			panic("sendsig: bogus frame type");
#endif
		kfp->sf_state.ss_flags |= SS_RTEFRAME;
		kfp->sf_state.ss_frame.f_format = frame->f_format;
		kfp->sf_state.ss_frame.f_vector = frame->f_vector;
		bcopy((caddr_t)&frame->F_u,
		    (caddr_t)&kfp->sf_state.ss_frame.F_u, exframesize[ft]);
		/*
		 * Leave an indicator that we need to clean up the kernel
		 * stack.  We do this by setting the "pad word" above the
		 * hardware stack frame to the amount the stack must be
		 * adjusted by.
		 *
		 * N.B. we increment rather than just set f_stackadj in
		 * case we are called from syscall when processing a
		 * sigreturn.  In that case, f_stackadj may be non-zero.
		 */
		frame->f_stackadj += exframesize[ft];
		frame->f_format = frame->f_vector = 0;
#ifdef DEBUG
		if (sigdebug & SDB_FOLLOW)
			printf("sendsig(%d): copy out %d of frame %d\n",
			    p->p_pid, exframesize[ft], ft);
#endif
	}

#ifdef FPCOPROC
	kfp->sf_state.ss_flags |= SS_FPSTATE;
	if (fputype)
		m68881_save(&kfp->sf_state.ss_fpstate);
#ifdef DEBUG
	if ((sigdebug & SDB_FPSTATE) && *(char *)&kfp->sf_state.ss_fpstate)
		printf("sendsig(%d): copy out FP state (%x) to %p\n",
		    p->p_pid, *(u_int *)&kfp->sf_state.ss_fpstate,
		    &kfp->sf_state.ss_fpstate);
#endif /* DEBUG */
#endif /* FPCOPROC */
	/*
	 * Build the signal context to be used by sigreturn.
	 */
	kfp->sf_sc.sc_onstack = oonstack;
	kfp->sf_sc.sc_mask = mask;
	kfp->sf_sc.sc_sp = frame->f_regs[SP];
	kfp->sf_sc.sc_fp = frame->f_regs[A6];
	kfp->sf_sc.sc_ap = (int)&fp->sf_state;
	kfp->sf_sc.sc_pc = frame->f_pc;
	kfp->sf_sc.sc_ps = frame->f_sr;

	if (psp->ps_siginfo & sigmask(sig)) {
		kfp->sf_sip = &fp->sf_si;
		initsiginfo(&kfp->sf_si, sig, code, type, val);
	}

	/* XXX do not copy out siginfo if not needed */
	(void)copyout((caddr_t)kfp, (caddr_t)fp, fsize);
	frame->f_regs[SP] = (int)fp;
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sendsig(%d): sig %d scp %p fp %p sc_sp %x sc_ap %x\n",
		    p->p_pid, sig, kfp->sf_scp, fp, kfp->sf_sc.sc_sp,
		    kfp->sf_sc.sc_ap);
#endif /* DEBUG */
	/*
	 * Signal trampoline code is at base of user stack.
	 */
	frame->f_pc = (int)PS_STRINGS - (esigcode - sigcode);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d returns\n", p->p_pid, sig);
#endif
	free((caddr_t)kfp, M_TEMP);
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper priviledges or to cause
 * a machine fault.
 */
/* ARGSUSED */
int
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext *scp, context;
	struct frame *frame;
	int rf, flags;
	struct sigstate tstate;
	extern short exframesize[];

	scp = SCARG(uap, sigcntxp);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: pid %d, scp %p\n", p->p_pid, scp);
#endif
	if ((int)scp & 1)
		return(EINVAL);
	/*
	 * Test and fetch the context structure.
	 * We grab it all at once for speed.
	 */
	if (useracc((caddr_t)scp, sizeof(*scp), B_WRITE) == 0 ||
	    copyin(scp, &context, sizeof(context)))
		return(EINVAL);
	scp = &context;
	if ((scp->sc_ps & (PSL_MBZ|PSL_IPL|PSL_S)) != 0)
		return(EINVAL);
	/*
	 * Restore the user supplied information
	 */
	if (scp->sc_onstack & 1)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
	else 
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = scp->sc_mask &~ sigcantmask;
	frame = (struct frame *) p->p_md.md_regs;
	frame->f_regs[SP] = scp->sc_sp;
	frame->f_regs[A6] = scp->sc_fp;
	frame->f_pc = scp->sc_pc;
	frame->f_sr = scp->sc_ps;
	/*
	 * Grab pointer to hardware state information.
	 * If zero, the user is probably doing a longjmp.
	 */
	if ((rf = scp->sc_ap) == 0)
		return (EJUSTRETURN);
	/*
	 * See if there is anything to do before we go to the
	 * expense of copying in close to 1/2K of data
	 */
	flags = fuword((caddr_t)rf);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn(%d): sc_ap %x flags %x\n",
		    p->p_pid, rf, flags);
#endif
	/*
	 * fuword failed (bogus sc_ap value).
	 */
	if (flags == -1)
		return (EINVAL);
	if (flags == 0 || copyin((caddr_t)rf, (caddr_t)&tstate, sizeof tstate))
		return (EJUSTRETURN);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sigreturn(%d): ssp %p usp %x scp %p ft %d\n",
		    p->p_pid, &flags, scp->sc_sp, SCARG(uap, sigcntxp),
		    (flags&SS_RTEFRAME) ? tstate.ss_frame.f_format : -1);
#endif
	/*
	 * Restore most of the users registers except for A6 and SP
	 * which were handled above.
	 */
	if (flags & SS_USERREGS)
		bcopy((caddr_t)tstate.ss_frame.f_regs,
		      (caddr_t)frame->f_regs, sizeof(frame->f_regs)-2*NBPW);
	/*
	 * Restore long stack frames.  Note that we do not copy
	 * back the saved SR or PC, they were picked up above from
	 * the sigcontext structure.
	 */
	if (flags & SS_RTEFRAME) {
		register int sz;
		
		/* grab frame type and validate */
		sz = tstate.ss_frame.f_format;
		if (sz > 15 || (sz = exframesize[sz]) < 0)
			return (EINVAL);
		frame->f_stackadj -= sz;
		frame->f_format = tstate.ss_frame.f_format;
		frame->f_vector = tstate.ss_frame.f_vector;
		bcopy((caddr_t)&tstate.ss_frame.F_u, (caddr_t)&frame->F_u, sz);
#ifdef DEBUG
		if (sigdebug & SDB_FOLLOW)
			printf("sigreturn(%d): copy in %d of frame type %d\n",
			    p->p_pid, sz, tstate.ss_frame.f_format);
#endif
	}
#ifdef FPCOPROC
	/*
	 * Finally we restore the original FP context
	 */
#ifdef FPU_EMULATE
	if ((flags & SS_FPSTATE) && fputype)
#else
	if (fputype)
#endif
		m68881_restore(&tstate.ss_fpstate);
#ifdef DEBUG
	if ((sigdebug & SDB_FPSTATE) && *(char *)&tstate.ss_fpstate)
		printf("sigreturn(%d): copied in FP state (%x) at %p\n",
		    p->p_pid, *(u_int *)&tstate.ss_fpstate,
		       &tstate.ss_fpstate);
#endif
#endif
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid))
		printf("sigreturn(%d): returns\n", p->p_pid);
#endif
	return (EJUSTRETURN);
}
@


1.24
log
@Add AppleTalk netisr. Only tested (indeed, only compiled) on mac68k port.
Add options NETATALK to your config to try it out.
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.23 1997/03/26 18:30:50 niklas Exp $	*/
/*	$NetBSD: machdep.c,v 1.82 1996/12/17 07:32:54 is Exp $	*/
d129 3
d148 3
a150 2
static void netintr __P((void));
static void call_sicallbacks __P((void));
a151 2
static void dumpmem __P((int *, int, int));
static char *hexstr __P((int, int));
d194 1
d203 1
a203 1
char machine[] = "amiga";
d588 6
a593 1
	m68881_restore(&p->p_addr->u_pcb.pcb_fpregs);
d655 10
a664 2
		fpu = "/FPU";
		fputype = FPU_68040; /* XXX */
d728 328
a1107 1

d1313 2
d1316 6
a1321 2
#if defined(M68060) || defined(DRACO)
	extern caddr_t vectab[256];
d1325 1
d1328 1
a1328 1
	extern u_int8_t intemu60, fpiemu60, fpdemu60, fpeaemu60;
d1331 1
a1331 1
	extern u_int8_t illinst;
d1333 5
a1337 1
	extern u_int8_t fpfault;
d1341 1
a1341 1
	extern u_int8_t DraCoIntr, DraCoLev1intr, DraCoLev2intr;
d1345 4
d1351 9
d1362 4
d1369 1
a1369 1
		vectab[61] = &intemu60/*&I_CALL_TOP[128 + 0x00]*/;
d1376 1
a1376 1
		vectab[11] = &fpiemu60/*&FP_CALL_TOP[128 + 0x30]*/;
d1378 2
a1379 2
		vectab[55] = &fpdemu60/*&FP_CALL_TOP[128 + 0x38]*/;
		vectab[60] = &fpeaemu60/*&FP_CALL_TOP[128 + 0x40]*/;
d1381 6
a1386 6
		vectab[54] = &FP_CALL_TOP[128 + 0x00];
		vectab[52] = &FP_CALL_TOP[128 + 0x08];
		vectab[53] = &FP_CALL_TOP[128 + 0x10];
		vectab[51] = &FP_CALL_TOP[128 + 0x18];
		vectab[50] = &FP_CALL_TOP[128 + 0x20];
		vectab[49] = &FP_CALL_TOP[128 + 0x28];
d1389 18
a1406 1
		vectab[61] = &illinst;
d1408 5
a1412 1
		vectab[48] = &fpfault;
d1424 2
a1425 2
			vectab[24+1] = &DraCoLev1intr;
			vectab[24+2] = &DraCoIntr;
d1427 2
a1428 2
			vectab[24+1] = &DraCoIntr;
			vectab[24+2] = &DraCoLev2intr;
d1430 4
a1433 4
		vectab[24+3] = &DraCoIntr;
		vectab[24+4] = &DraCoIntr;
		vectab[24+5] = &DraCoIntr;
		vectab[24+6] = &DraCoIntr;
d1491 1
a1491 1
static void
d1555 38
d1612 10
d1701 1
a1701 1
static void
a2073 92

void
regdump(fp, sbytes)
	struct frame *fp; /* must not be register */
	int sbytes;
{
	static int doingdump = 0;
	register int i;
	int s;

	if (doingdump)
		return;
	s = spl7();
	doingdump = 1;
	printf("pid = %d, pc = %s, ", curproc ? curproc->p_pid : 0,
	    hexstr(fp->f_pc, 8));
	printf("ps = %s, ", hexstr(fp->f_sr, 4));
	printf("sfc = %s, ", hexstr(getsfc(), 4));
	printf("dfc = %s\n", hexstr(getdfc(), 4));
	printf("Registers:\n     ");
	for (i = 0; i < 8; i++)
		printf("        %d", i);
	printf("\ndreg:");
	for (i = 0; i < 8; i++)
		printf(" %s", hexstr(fp->f_regs[i], 8));
	printf("\nareg:");
	for (i = 0; i < 8; i++)
		printf(" %s", hexstr(fp->f_regs[i+8], 8));
	if (sbytes > 0) {
		if (fp->f_sr & PSL_S) {
			printf("\n\nKernel stack (%s):",
			       hexstr((int)(((int *)&fp)-1), 8));
			dumpmem(((int *)&fp)-1, sbytes, 0);
		} else {
			printf("\n\nUser stack (%s):", hexstr(fp->f_regs[SP], 8));
			dumpmem((int *)fp->f_regs[SP], sbytes, 1);
		}
	}
	doingdump = 0;
	splx(s);
}

extern u_int proc0paddr;
#define KSADDR	((int *)((curproc ? (u_int)curproc->p_addr : proc0paddr) + USPACE - NBPG))

static void
dumpmem(ptr, sz, ustack)
	register int *ptr;
	int sz, ustack;
{
	register int i, val;

	for (i = 0; i < sz; i++) {
		if ((i & 7) == 0)
			printf("\n%s: ", hexstr((int)ptr, 6));
		else
			printf(" ");
		if (ustack == 1) {
			if ((val = fuword(ptr++)) == -1)
				break;
		} else {
			if (ustack == 0 &&
			    (ptr < KSADDR || ptr > KSADDR+(NBPG/4-1)))
				break;
			val = *ptr++;
		}
		printf("%s", hexstr(val, 8));
	}
	printf("\n");
}

static char *
hexstr(val, len)
	register int val;
	int len;
{
	static char nbuf[9];
	register int x, i;

	if (len > 8)
		return("");
	nbuf[len] = '\0';
	for (i = len-1; i >= 0; --i) {
		x = val & 0xF;
		if (x > 9)
			nbuf[i] = x - 10 + 'A';
		else
			nbuf[i] = x + '0';
		val >>= 4;
	}
	return(nbuf);
}
@


1.23
log
@Remove stuff now in m68k/
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 1997/02/21 09:02:41 niklas Exp $	*/
d1112 6
@


1.22
log
@fetched a comment from mvme68k + style nit
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 1997/02/03 15:05:06 deraadt Exp $	*/
a709 327
}

#define SS_RTEFRAME	1
#define SS_FPSTATE	2
#define SS_USERREGS	4

struct sigstate {
	int	ss_flags;		/* which of the following are valid */
	struct	frame ss_frame;		/* original exception frame */
	struct	fpframe ss_fpstate;	/* 68881/68882 state info */
};

/*
 * WARNING: code in locore.s assumes the layout shown for sf_signum
 * thru sf_handler so... don't screw with them!
 */
struct sigframe {
	int	sf_signum;		/* signo for handler */
	siginfo_t *sf_sip;		/* pointer to siginfo_t */
	struct	sigcontext *sf_scp;	/* context ptr for handler */
	sig_t	sf_handler;		/* handler addr for u_sigc */
	struct	sigstate sf_state;	/* state of the hardware */
	struct	sigcontext sf_sc;	/* actual context */
	siginfo_t sf_si;		/* actual siginfo_t */
};

#ifdef DEBUG
int sigdebug = 0x0;
int sigpid = 0;
#define SDB_FOLLOW	0x01
#define SDB_KSTACK	0x02
#define SDB_FPSTATE	0x04
#endif

/*
 * Send an interrupt to process.
 */
void
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
{
	register struct proc *p = curproc;
	register struct sigframe *fp, *kfp;
	register struct frame *frame;
	register struct sigacts *psp = p->p_sigacts;
	register short ft;
	int oonstack;
	extern short exframesize[];
	extern char sigcode[], esigcode[];


#if 0
printf("sendsig %d %d %x %x %x\n", p->p_pid, sig, mask, code, catcher);
#endif

	frame = (struct frame *)p->p_md.md_regs;
	ft = frame->f_format;
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;

	/*
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in P0 space, the
	 * call to grow() is a nop, and the useracc() check
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
	 */
	if ((psp->ps_flags & SAS_ALTSTACK) && oonstack == 0 &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size - sizeof(struct sigframe));
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
	} else
		fp = (struct sigframe *)frame->f_regs[SP] - 1;
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
		(void)grow(p, (unsigned)fp);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d ssp %p usp %p scp %p ft %d\n",
		    p->p_pid, sig, &oonstack, fp, &fp->sf_sc, ft);
#endif
	if (useracc((caddr_t)fp, sizeof(struct sigframe), B_WRITE) == 0) {
#ifdef DEBUG
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sendsig(%d): useracc failed on sig %d\n",
			    p->p_pid, sig);
#endif
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}
	kfp = malloc(sizeof(struct sigframe), M_TEMP, M_WAITOK);
	/* 
	 * Build the argument list for the signal handler.
	 */
	kfp->sf_signum = sig;
	kfp->sf_sip = NULL;
	kfp->sf_scp = &fp->sf_sc;
	kfp->sf_handler = catcher;
	/*
	 * Save necessary hardware state.  Currently this includes:
	 *	- general registers
	 *	- original exception frame (if not a "normal" frame)
	 *	- FP coprocessor state
	 */
	kfp->sf_state.ss_flags = SS_USERREGS;
	bcopy((caddr_t)frame->f_regs, (caddr_t)kfp->sf_state.ss_frame.f_regs,
	    sizeof frame->f_regs);
	if (ft >= FMT9) {
#ifdef DEBUG
		if (ft != FMT9 && ft != FMTA && ft != FMTB)
			panic("sendsig: bogus frame type");
#endif
		kfp->sf_state.ss_flags |= SS_RTEFRAME;
		kfp->sf_state.ss_frame.f_format = frame->f_format;
		kfp->sf_state.ss_frame.f_vector = frame->f_vector;
		bcopy((caddr_t)&frame->F_u,
		    (caddr_t)&kfp->sf_state.ss_frame.F_u, exframesize[ft]);
		/*
		 * Leave an indicator that we need to clean up the kernel
		 * stack.  We do this by setting the "pad word" above the
		 * hardware stack frame to the amount the stack must be
		 * adjusted by.
		 *
		 * N.B. we increment rather than just set f_stackadj in
		 * case we are called from syscall when processing a
		 * sigreturn.  In that case, f_stackadj may be non-zero.
		 */
		frame->f_stackadj += exframesize[ft];
		frame->f_format = frame->f_vector = 0;
#ifdef DEBUG
		if (sigdebug & SDB_FOLLOW)
			printf("sendsig(%d): copy out %d of frame %d\n",
			    p->p_pid, exframesize[ft], ft);
#endif
	}
#ifdef FPCOPROC
	kfp->sf_state.ss_flags |= SS_FPSTATE;
	m68881_save(&kfp->sf_state.ss_fpstate);
#ifdef DEBUG
	if ((sigdebug & SDB_FPSTATE) && *(char *)&kfp->sf_state.ss_fpstate)
		printf("sendsig(%d): copy out FP state (%x) to %p\n", p->p_pid,
		    *(u_int *)&kfp->sf_state.ss_fpstate,
		    &kfp->sf_state.ss_fpstate);
#endif
#endif
	/*
	 * Build the signal context to be used by sigreturn.
	 */
	kfp->sf_sc.sc_onstack = oonstack;
	kfp->sf_sc.sc_mask = mask;
	kfp->sf_sc.sc_sp = frame->f_regs[SP];
	kfp->sf_sc.sc_fp = frame->f_regs[A6];
	kfp->sf_sc.sc_ap = (int)&fp->sf_state;
	kfp->sf_sc.sc_pc = frame->f_pc;
	kfp->sf_sc.sc_ps = frame->f_sr;

	if (psp->ps_siginfo & sigmask(sig)) {
		kfp->sf_sip = &fp->sf_si;
		initsiginfo(&kfp->sf_si, sig, code, type, val);
	}

	/* XXX do not copy out siginfo if not needed */
	(void)copyout((caddr_t)kfp, (caddr_t)fp, sizeof(struct sigframe));
	frame->f_regs[SP] = (int)fp;
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sendsig(%d): sig %d scp %p fp %p sc_sp %x sc_ap %x\n",
		    p->p_pid, sig, kfp->sf_scp, fp, kfp->sf_sc.sc_sp,
		    kfp->sf_sc.sc_ap);
#endif
	/*
	 * Signal trampoline code is at base of user stack.
	 */
	frame->f_pc = (int)(((char *)PS_STRINGS) - (esigcode - sigcode));
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d returns\n", p->p_pid, sig);
#endif
	free((caddr_t)kfp, M_TEMP);
}


/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper priviledges or to cause
 * a machine fault.
 */
/* ARGSUSED */
int
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext *scp, context;
	struct frame *frame;
	int rf, flags;
	struct sigstate tstate;
	extern short exframesize[];

	scp = SCARG(uap, sigcntxp);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: pid %d, scp %p\n", p->p_pid, scp);
#endif
	if ((int)scp & 1)
		return(EINVAL);
	/*
	 * Test and fetch the context structure.
	 * We grab it all at once for speed.
	 */
	if (useracc((caddr_t)scp, sizeof(*scp), B_WRITE) == 0 ||
	    copyin(scp, &context, sizeof(context)))
		return(EINVAL);
	scp = &context;
	if ((scp->sc_ps & (PSL_MBZ|PSL_IPL|PSL_S)) != 0)
		return(EINVAL);
	/*
	 * Restore the user supplied information
	 */
	if (scp->sc_onstack & 1)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
	else 
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = scp->sc_mask &~ sigcantmask;
	frame = (struct frame *) p->p_md.md_regs;
	frame->f_regs[SP] = scp->sc_sp;
	frame->f_regs[A6] = scp->sc_fp;
	frame->f_pc = scp->sc_pc;
	frame->f_sr = scp->sc_ps;
	/*
	 * Grab pointer to hardware state information.
	 * If zero, the user is probably doing a longjmp.
	 */
	if ((rf = scp->sc_ap) == 0)
		return (EJUSTRETURN);
	/*
	 * See if there is anything to do before we go to the
	 * expense of copying in close to 1/2K of data
	 */
	flags = fuword((caddr_t)rf);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn(%d): sc_ap %x flags %x\n", p->p_pid, rf,
		    flags);
#endif
	/*
	 * fuword failed (bogus sc_ap value).
	 */
	if (flags == -1)
		return (EINVAL);
	if (flags == 0 || copyin((caddr_t)rf, (caddr_t)&tstate, sizeof tstate))
		return (EJUSTRETURN);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sigreturn(%d): ssp %p usp %x scp %p ft %d\n", p->p_pid,
		    &flags, scp->sc_sp, SCARG(uap, sigcntxp),
		    (flags&SS_RTEFRAME) ? tstate.ss_frame.f_format : -1);
#endif
	/*
	 * Restore most of the users registers except for A6 and SP
	 * which were handled above.
	 */
	if (flags & SS_USERREGS)
		bcopy((caddr_t)tstate.ss_frame.f_regs,
		      (caddr_t)frame->f_regs, sizeof(frame->f_regs)-2*NBPW);
	/*
	 * Restore long stack frames.  Note that we do not copy
	 * back the saved SR or PC, they were picked up above from
	 * the sigcontext structure.
	 */
	if (flags & SS_RTEFRAME) {
		register int sz;
		
		/* grab frame type and validate */
		sz = tstate.ss_frame.f_format;
		if (sz > 15 || (sz = exframesize[sz]) < 0)
			return (EINVAL);
		frame->f_stackadj -= sz;
		frame->f_format = tstate.ss_frame.f_format;
		frame->f_vector = tstate.ss_frame.f_vector;
		bcopy((caddr_t)&tstate.ss_frame.F_u, (caddr_t)&frame->F_u, sz);
#ifdef DEBUG
		if (sigdebug & SDB_FOLLOW)
			printf("sigreturn(%d): copy in %d of frame type %d\n",
			    p->p_pid, sz, tstate.ss_frame.f_format);
#endif
	}
#ifdef FPCOPROC
	/*
	 * Finally we restore the original FP context
	 */
	if (flags & SS_FPSTATE)
		m68881_restore(&tstate.ss_fpstate);
#ifdef DEBUG
	if ((sigdebug & SDB_FPSTATE) && *(char *)&tstate.ss_fpstate)
		printf("sigreturn(%d): copied in FP state (%x) at %p\n",
		    p->p_pid, *(u_int *)&tstate.ss_fpstate,
		    &tstate.ss_fpstate);
#endif
#endif
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid))
		printf("sigreturn(%d): returns\n", p->p_pid);
#endif
	return (EJUSTRETURN);
@


1.21
log
@More siginfo implementations (alpha and mips might even work)
move "siginfo_t *" to 2nd arg of signal handler as 1003.1b requires.
I really wish I had 1003.1b documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 1997/02/03 12:48:35 deraadt Exp $	*/
d883 2
a884 1
	(void) copyout((caddr_t)kfp, (caddr_t)fp, sizeof(struct sigframe));
@


1.20
log
@repair confusion over kv/uv addr for siginfo_t storage
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 1997/02/03 11:38:08 deraadt Exp $	*/
d728 1
a728 1
	int	sf_code;		/* additional info for handler */
a729 1
	siginfo_t *sf_sip;
d733 1
a733 1
	siginfo_t sf_si;
d817 1
a817 1
	kfp->sf_code = code;
@


1.19
log
@SA_SIGINFO implementation
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 1997/01/18 12:48:01 niklas Exp $	*/
d880 2
a881 2
		kfp->sf_sip = &kfp->sf_si;
		initsiginfo(kfp->sf_sip, sig, code, type, val);
@


1.18
log
@move the RB_TIMEBAD handling to where "howto" is reachable
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 1997/01/17 05:53:39 kstailey Exp $	*/
d730 1
d734 1
d749 1
a749 1
sendsig(catcher, sig, mask, code)
d753 2
d878 6
@


1.17
log
@don't update battery backed up clock if system time is wrong from begin
in ddb.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 1997/01/16 09:23:24 niklas Exp $	*/
a1036 11

		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
d1049 1
a1049 1
	if ((howto & RB_NOSYNC) == 0)
d1051 12
@


1.16
log
@Sync to NetBSD 970110
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 1996/08/19 00:04:15 niklas Exp $	*/
d1040 2
a1041 1
		 * will be out of synch; adjust it now.
d1043 5
a1047 1
		resettodr();
@


1.15
log
@Merge of Late July NetBSD sources (mostly DRACO support).  More to come...
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.14 1996/07/27 11:40:26 deraadt Exp $	*/
/*	$NetBSD: machdep.c,v 1.72.4.1 1996/05/26 16:23:23 is Exp $	*/
d158 5
d205 1
d508 2
a509 2
	printf("using %d buffers containing %d bytes of memory\n",
		nbuf, bufpages * CLBYTES);
d520 1
a520 1
	printf ("Physical memory segments:\n");
d522 1
a522 1
		printf ("Physical segment %d at %08lx size %ld offset %d\n", i,
d531 1
d605 6
a610 1
 
d655 1
a655 1
		fputype = FPU_68040;
d762 3
a764 1
/*printf("sendsig %d %d %x %x %x\n", p->p_pid, sig, mask, code, catcher);*/
d789 1
a789 1
		       p->p_pid, sig, &oonstack, fp, &fp->sf_sc, ft);
d795 1
a795 1
			       p->p_pid, sig);
d824 2
a825 2
	bcopy((caddr_t)frame->f_regs,
	      (caddr_t)kfp->sf_state.ss_frame.f_regs, sizeof frame->f_regs);
d835 1
a835 1
		      (caddr_t)&kfp->sf_state.ss_frame.F_u, exframesize[ft]);
d851 1
a851 1
			       p->p_pid, exframesize[ft], ft);
d859 3
a861 3
		printf("sendsig(%d): copy out FP state (%x) to %p\n",
		       p->p_pid, *(u_int *)&kfp->sf_state.ss_fpstate,
		       &kfp->sf_state.ss_fpstate);
d879 2
a880 2
		       p->p_pid, sig, kfp->sf_scp, fp,
		       kfp->sf_sc.sc_sp, kfp->sf_sc.sc_ap);
d888 1
a888 2
		printf("sendsig(%d): sig %d returns\n",
		       p->p_pid, sig);
d963 2
a964 2
		printf("sigreturn(%d): sc_ap %x flags %x\n",
		       p->p_pid, rf, flags);
d975 3
a977 3
		printf("sigreturn(%d): ssp %p usp %x scp %p ft %d\n",
		       p->p_pid, &flags, scp->sc_sp, SCARG(uap, sigcntxp),
		       (flags&SS_RTEFRAME) ? tstate.ss_frame.f_format : -1);
d1005 1
a1005 1
			       p->p_pid, sz, tstate.ss_frame.f_format);
d1017 2
a1018 2
		       p->p_pid, *(u_int *)&tstate.ss_fpstate,
		       &tstate.ss_fpstate);
d1037 1
a1277 4
#if defined(M68060)
int m68060_pcr_init = 0x21;	/* make this patchable */
#endif

d1288 2
a1289 1
	extern u_int8_t I_CALL_TOP[];
d1298 2
a1299 1
	extern u_int8_t DraCoIntr, DraCoLev2intr;
d1309 1
a1309 1
		vectab[61] = &I_CALL_TOP[128 + 0x00];
d1312 8
a1319 3
		vectab[11] = &FP_CALL_TOP[128 + 0x30];
		vectab[55] = &FP_CALL_TOP[128 + 0x38];
		vectab[60] = &FP_CALL_TOP[128 + 0x40];
d1335 4
d1340 9
a1348 3
	if (is_draco()) {
		vectab[24+1] = &DraCoIntr;
		vectab[24+2] = &DraCoLev2intr;
a1612 1
		panic("DraCo IPL3 not yet supported here");
d1615 4
d1641 10
a1650 2
		*draco_intena |= isr->isr_ipl == 6 ?
			DRIRQ_INT6 : DRIRQ_INT2;
a1668 1
		panic("DraCo IPL3 not yet supported here");
d1671 4
d1692 1
a1702 5
#ifdef DRACO
		case 3:
			panic("DraCo IPL3 not yet supported here");
			break;
#endif
d1841 10
@


1.14
log
@handle RB_CONFIG
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.13 1996/05/29 10:14:29 niklas Exp $	*/
/*	$NetBSD: machdep.c,v 1.72 1996/05/19 14:55:31 is Exp $	*/
d522 1
a522 1
#ifdef DEBUG
d530 1
a530 1
#ifdef DEBUG
d538 1
a538 1
#ifdef DEBUG
d552 1
a552 1
#ifdef DEBUG
d1283 1
d1287 1
a1287 1
	extern u_int8_t DraCoLev2intr, lev2intr;
d1314 1
d1320 1
d1322 4
a1325 3
		vectab[24+4] = &lev2intr;
		vectab[24+5] = &lev2intr;
		vectab[24+6] = &lev2intr;
a1579 10
#if defined(IPL_REMAP_1) || defined(IPL_REMAP_2)
	p = isr->isr_ipl == 2 ? &isr_ports : &isr_exter[isr->isr_mapped_ipl];
	if (isr->isr_ipl == 6) {
		if (isr->isr_mapped_ipl > isr_exter_highipl)
			isr_exter_highipl = isr->isr_mapped_ipl;
		if (isr->isr_mapped_ipl < isr_exter_lowipl)
			isr_exter_lowipl = isr->isr_mapped_ipl;
	}
#else
#ifdef DRACO
d1584 1
d1586 1
d1589 9
a1597 1
	default:	/* was case 6:; make gcc -Wall quiet */
d1599 1
d1601 2
a1603 4
#else
  	p = isr->isr_ipl == 2 ? &isr_ports : &isr_exter;
#endif
#endif
d1623 1
a1623 1
	struct isr **p, *q;
a1624 4
#if defined(IPL_REMAP_1) || defined(IPL_REMAP_2)
	p = isr->isr_ipl == 6 ? &isr_exter[isr->isr_mapped_ipl] : &isr_ports;
#else
#ifdef DRACO
d1627 1
a1627 1
		p = &isr_ports;
d1629 1
d1631 2
a1632 1
		p = &isr_slot3;
d1634 7
a1640 2
	default:	/* XXX to make gcc -Wall quiet, was 6: */
		p = &isr_exter;
d1642 2
d1645 2
a1646 6
#else
	p = isr->isr_ipl == 6 ? &isr_exter : &isr_ports;
#endif
#endif
	while ((q = *p) != NULL && q != isr)
		p = &q->isr_forw;
d1651 16
a1666 1
	/* disable interrupt if no more handlers */
d1668 1
a1668 4
	p = isr->isr_ipl == 6 ? &isr_exter[isr->isr_mapped_ipl] : &isr_ports;
	if (*p == NULL) {
		if (isr->isr_ipl == 6) {
			if (isr->isr_mapped_ipl == isr_exter_lowipl)
d1670 1
a1670 1
				    !isr_exter[isr_exter_lowipl])
d1672 8
d1682 1
a1682 1
				    !isr_exter[isr_exter_highipl])
a1683 5
			if (isr_exter_lowipl == 7)
				custom.intena = INTF_EXTER;
		} else if (isr->isr_ipl == 2)
			custom.intena = INTF_PORTS;
	}
d1686 3
a1688 13
	switch (isr->isr_ipl) {
	case 2:
		p = &isr_ports;
		break;
	case 3:
		p = &isr_slot3;
		break;
	case 6:
		p = &isr_exter;
		break;
	}
#else
	p = isr->isr_ipl == 6 ? &isr_exter : &isr_ports;
d1690 1
a1690 9
	if (*p == NULL)
#ifdef DRACO
		if (is_draco())
			*draco_intena &= isr->isr_ipl == 6 ? 
			    ~DRIRQ_INT6 : ~DRIRQ_INT2;
		else
#endif
			custom.intena = isr->isr_ipl == 6 ? 
			    INTF_EXTER : INTF_PORTS;
d1692 2
@


1.13
log
@Merge of 960526 NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 1996/05/28 09:45:11 niklas Exp $	*/
d544 7
@


1.12
log
@Implement bootsync() again, and let boot() call it
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: machdep.c,v 1.65 1996/05/01 09:56:22 veego Exp $	*/
d68 2
d96 1
d100 3
d198 3
d289 6
a294 2
	custom_chips_init();
		
d515 2
a516 2
	for (i = 0; phys_segs[i].start; ++i)
		printf ("Physical segment %d at %08lx size %ld pages %d\n", i,
d521 4
d530 3
d538 3
d545 3
d598 13
d621 11
d1058 1
d1064 2
d1067 1
d1069 13
d1087 1
a1087 1
			dumplo = nblks - btodb(ctob(physmem));
d1089 1
d1117 1
a1117 1
	unsigned bytes, i, n;
d1122 3
d1145 16
d1162 2
a1163 1
	maddr = lowram;
d1166 2
a1167 1
	for (i = 0; i < bytes; i += n) {
d1177 6
d1189 7
d1257 4
d1264 54
d1325 2
a1326 2
	printf("unexpected trap (vector offset %x) from %x\n",
	       evec & 0xFFF, pc);
d1578 13
d1593 1
d1599 8
a1606 2
	custom.intena = INTF_SETCLR |
	    (isr->isr_ipl == 2 ? INTF_PORTS : INTF_EXTER);
d1618 13
d1633 1
d1659 13
d1673 1
d1675 8
a1682 1
		custom.intena = isr->isr_ipl == 6 ? INTF_EXTER : INTF_PORTS;
d1695 10
a1704 1
	ireq = custom.intreqr;
d1708 4
d1745 3
d1752 3
d1760 3
d1778 6
a1783 1
		custom.intreq = INTF_PORTS;
d1805 10
d1822 3
d1987 1
d1989 1
@


1.11
log
@Remove bootsync(), use vfs_shutdown() instead
@
text
@d962 1
a962 2
boot(howto)
	register int howto;
d964 1
a964 6
	/* take a snap shot before clobbering any registers */
	if (curproc)
		savectx(&curproc->p_addr->u_pcb);

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
d973 13
@


1.10
log
@fix reboot panic.
@
text
@d962 2
a963 1
bootsync(void)
d965 3
a967 3
	if (waittime < 0) {
		register struct buf *bp;
		int iter, nbusy;
d969 2
d972 1
a972 33
		(void) spl0();
		printf("syncing disks... ");
		/*
		 * Release vnodes held by texts before sync.
		 */
		if (panicstr == 0)
			vnode_pager_umount(NULL);
		sys_sync(&proc0, (void *)NULL, (int *)NULL);
		/*
		 * unmount filesystems
		 */
		if (panicstr == 0) {
			extern struct proc proc0;
			if (curproc == NULL)
				curproc = &proc0;

			vfs_unmountall();
		}

		for (iter = 0; iter < 20; iter++) {
			nbusy = 0;
			for (bp = &buf[nbuf]; --bp >= buf; )
				if ((bp->b_flags & (B_BUSY|B_INVAL)) == B_BUSY)
					nbusy++;
			if (nbusy == 0)
				break;
			printf("%d ", nbusy);
			delay(40000 * iter);
		}
		if (nbusy)
			printf("giving up\n");
		else
			printf("done\n");
a978 14
}


void
boot(howto)
	register int howto;
{
	/* take a snap shot before clobbering any registers */
	if (curproc)
		savectx(&curproc->p_addr->u_pcb);

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0)
		bootsync();
@


1.9
log
@From NetBSD:
<sys/cpu.h> is no longer needed
@
text
@d980 5
a984 1
		if (panicstr == 0)
d986 1
@


1.8
log
@Sync with NetBSD 9600430.  The port has gone over a major -Wall treat
@
text
@d2 1
a2 1
/*	$NetBSD: machdep.c,v 1.64 1996/04/28 06:57:15 mhitch Exp $	*/
a49 1
#include <sys/cpu.h>
@


1.7
log
@Bring forward the Amiga ISA support, and resolve a conflict with if_ed
@
text
@d2 1
a2 1
/*	$NetBSD: machdep.c,v 1.59 1995/10/09 04:33:58 chopps Exp $	*/
d50 1
d86 5
d105 23
a128 1
#include "ppp.h"
d134 18
a301 2
	extern long Usrptsize;
	extern struct map *useriomap;
d310 2
a311 2
	vm_size_t size;
#ifdef MACHINE_NONCONTIG
d488 1
a488 1
	printf("avail mem = %d (%d pages)\n", ptoa(cnt.v_free_count),
d498 1
a498 1
			printf("memory segment %d at %08lx size %08lx\n", i,
d504 1
a504 1
		printf ("Physical segment %d at %08lx size %d pages %d\n", i,
d567 1
d614 1
d718 1
a718 1
		printf("sendsig(%d): sig %d ssp %x usp %x scp %x ft %d\n",
d789 1
a789 1
		printf("sendsig(%d): copy out FP state (%x) to %x\n",
d808 1
a808 1
		printf("sendsig(%d): sig %d scp %x fp %x sc_sp %x sc_ap %x\n",
d854 1
a854 1
		printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
d906 1
a906 1
		printf("sigreturn(%d): ssp %x usp %x scp %x ft %d\n",
d947 1
a947 1
		printf("sigreturn(%d): copied in FP state (%x) at %x\n",
d1006 1
d1013 1
a1013 1
		savectx(curproc->p_addr);
d1016 1
a1016 1
	if ((howto&RB_NOSYNC) == 0)
d1018 10
a1027 3
	spl7();				/* extreme priority */
	if (howto&RB_HALT) {
		printf("halted\n\n");
a1028 4
	} else {
		if (howto & RB_DUMP)
			dumpsys();
		doboot();
d1031 2
d1036 1
d1041 1
d1078 1
a1081 1
	int     range;
a1085 1
	int     c;
d1098 1
a1098 1
	printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
d1187 1
d1192 1
d1204 1
d1224 1
d1244 1
d1410 1
a1410 2
		si = si_callbacks;
		if (si)
d1503 1
d1531 3
d1539 3
a1541 1
			 * allows software interrupts to be missed
d1544 5
a1548 2
			if (ssir & SIR_NET) {
				siroff(SIR_NET);
d1552 1
a1552 2
			if (ssir & SIR_CLOCK) {
				siroff(SIR_CLOCK);
d1557 1
a1557 2
			if (ssir & SIR_CBACK) {
				siroff(SIR_CBACK);
d1612 1
d1614 1
d1660 1
a1660 1

a1667 1
	extern char *hexstr();
d1673 2
a1674 1
	printf("pid = %d, pc = %s, ", curproc->p_pid, hexstr(fp->f_pc, 8));
d1701 2
a1702 1
#define KSADDR	((int *)((u_int)curproc->p_addr + USPACE - NBPG))
d1704 1
d1707 1
a1707 1
	int sz;
a1709 1
	extern char *hexstr();
d1730 1
a1730 1
char *
d1733 1
d1758 1
@


1.6
log
@Style police
@
text
@d1 1
a171 1
	int handled = 0;
d173 1
a173 1
	for (i = start_ipl; !handled && i >= isr_exter_lowipl; i--) {
d182 2
a183 2
		for (isr = isr_exter[i]; !handled && isr; isr = isr->isr_forw)
			handled = (*isr->isr_intr)(isr->isr_arg);
@


1.5
log
@Added support for a new (well, I've run it locally for a year or two)
interrupt system which is a prerequisite for the Amiga ISA support.
It is described in amiga/amiga/README.ints, and is enabled by adding
an "options IPL_REMAP_1" in the kernel config file.  Along with this
change there is also some generic cleanup, like style polishing,
comment corrections, making sicallbacks operate in FIFO manner and
cleaning up the spl mess in param.h...
@
text
@d1281 2
a1282 1
		si = (struct si_callback *)malloc(sizeof(*si), M_TEMP, M_NOWAIT);
a1326 1
/*			free(si, M_TEMP); */
d1352 2
a1353 2
		/* Yes, that's an *assignment* below!  */
		if (si = si_callbacks)
a1360 2
/*			si->function(si->rock1, si->rock2); */
/*			free(si, M_TEMP); */
d1371 2
a1372 2
		printf ("call_sicallback: %d more dynamic structures %d total\n",
		    ncbd, ncb);
@


1.4
log
@ss_sp is correct, ss_base is not. noticed by agc@@sde.uts.amdahl.com; netbsd pr#1784
@
text
@d145 82
a226 1
 /*
d1227 2
a1228 4
 * aided) software interrupt.
 * Note: the installed functions are currently called in a
 * LIFO fashion, might want to change this to FIFO
 * later.
d1230 1
d1237 1
d1296 6
a1301 2
	si->next = si_callbacks;
	si_callbacks = si;
d1333 2
d1352 1
a1379 3
struct isr *isr_ports;
struct isr *isr_exter;

d1386 11
a1396 1
	p = isr->isr_ipl == 2 ? &isr_ports : &isr_exter;
d1402 2
a1403 2
	custom.intena = isr->isr_ipl == 2 ? INTF_SETCLR | INTF_PORTS :
	    INTF_SETCLR | INTF_EXTER;
d1412 3
d1416 1
d1424 18
d1445 1
d1478 1
a1478 1
			 * this order is dicated by the nature of 
d1515 1
a1515 1
		if (ireq & INTF_BLIT)  
d1517 1
a1517 1
		if (ireq & INTF_COPER)  
d1519 1
a1519 1
		if (ireq & INTF_VERTB) 
d1608 1
a1608 1
	s = splhigh();
@


1.3
log
@Oops, forgot to declare emul_sunos
@
text
@d582 1
a582 1
		fp = (struct sigframe *)(psp->ps_sigstk.ss_base +
@


1.2
log
@niklas pointed out the new MDP_UNCACHE_WX might break fork/exec.
always set/clear in setregs() now
@
text
@d136 4
@


1.1
log
@Initial revision
@
text
@d419 11
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

