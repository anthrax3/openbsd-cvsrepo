head	1.29;
access;
symbols
	SMP_SYNC_A:1.29
	SMP_SYNC_B:1.29
	UBC_SYNC_A:1.29
	OPENBSD_3_2:1.28.0.4
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.28.0.2
	OPENBSD_3_1_BASE:1.28
	UBC_SYNC_B:1.28
	UBC:1.23.0.2
	UBC_BASE:1.23
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.16.0.12
	OPENBSD_2_7_BASE:1.16
	SMP:1.16.0.10
	SMP_BASE:1.16
	kame_19991208:1.16
	OPENBSD_2_6:1.16.0.8
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.16.0.6
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.16.0.4
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.16.0.2
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	OPENBSD_2_0:1.13.0.2
	OPENBSD_2_0_BASE:1.13
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2002.12.31.16.35.36;	author miod;	state dead;
branches;
next	1.28;

1.28
date	2002.03.25.19.41.03;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.14.03.15.51;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.14.01.26.28;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.23.00.31.09;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.20.19.02.23;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.06.22.33.57;	author miod;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2001.11.30.23.14.28;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.30.22.08.13;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.06.19.53.13;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.14.15.43.11;	author jj;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.20.11.01.55;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.27.19.45.17;	author art;	state Exp;
branches;
next	1.16;

1.16
date	98.04.04.17.13.17;	author niklas;	state Exp;
branches
	1.16.10.1;
next	1.15;

1.15
date	97.09.08.19.42.28;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	97.01.16.09.23.14;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	96.10.04.23.34.35;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	96.08.19.00.04.12;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	96.05.29.10.14.17;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.05.07.09.55.10;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	96.05.04.13.24.48;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.05.02.06.43.09;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.14.47;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.03.24.15.59.41;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.02.26.21.24.51;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.02.06.09.16.29;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	95.11.28.19.35.58;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.03.53.30;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.51;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.51;	author deraadt;	state Exp;
branches;
next	;

1.16.10.1
date	2001.04.18.16.01.54;	author niklas;	state Exp;
branches;
next	1.16.10.2;

1.16.10.2
date	2001.07.04.10.14.54;	author niklas;	state Exp;
branches;
next	1.16.10.3;

1.16.10.3
date	2001.11.13.21.00.50;	author niklas;	state Exp;
branches;
next	1.16.10.4;

1.16.10.4
date	2001.12.05.00.39.09;	author niklas;	state Exp;
branches;
next	1.16.10.5;

1.16.10.5
date	2002.03.06.00.56.18;	author niklas;	state Exp;
branches;
next	1.16.10.6;

1.16.10.6
date	2002.03.28.10.06.14;	author niklas;	state Exp;
branches;
next	1.16.10.7;

1.16.10.7
date	2003.03.27.23.19.16;	author niklas;	state dead;
branches;
next	;

1.23.2.1
date	2002.01.31.22.55.06;	author niklas;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2002.06.11.03.34.56;	author art;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2003.05.19.21.49.37;	author tedu;	state dead;
branches;
next	;


desc
@@


1.29
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: amiga_init.c,v 1.28 2002/03/25 19:41:03 niklas Exp $	*/
/*	$NetBSD: amiga_init.c,v 1.56 1997/06/10 18:22:24 veego Exp $	*/

/*
 * Copyright (c) 1994 Michael L. Hitch
 * Copyright (c) 1993 Markus Wild
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Markus Wild.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <uvm/uvm_extern.h>
#include <sys/user.h>
#include <sys/ioctl.h>
#include <sys/select.h>
#include <sys/tty.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/msgbuf.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/domain.h>
#include <sys/dkbad.h>
#include <sys/reboot.h>
#include <sys/exec.h>
#include <uvm/uvm_pmap.h>
#include <machine/vmparam.h>
#include <machine/pte.h>
#include <machine/cpu.h>
#include <amiga/amiga/cc.h>
#include <amiga/amiga/cia.h>
#include <amiga/amiga/custom.h>
#include <amiga/amiga/cfdev.h>
#include <amiga/amiga/drcustom.h>
#include <amiga/amiga/memlist.h>
#include <amiga/dev/zbusvar.h>

#define RELOC(v, t)	*((t*)((u_int)&(v) + loadbase))

extern int	machineid, mmutype;
extern u_int	lowram;
extern u_int	Sysptmap, Sysptsize, Sysseg, Umap, proc0paddr;
extern u_int	Sysseg_pa;
extern u_int	virtual_avail;
#if defined(M68040) || defined(M68060)
extern int	protostfree;
#endif
vaddr_t		amiga_uptbase;

extern char *esym;

#ifdef GRF_AGA
extern u_long aga_enable;
#endif

extern u_long noncontig_enable;

/*
 * some addresses used in locore
 */
vm_offset_t INTREQRaddr;
vm_offset_t INTREQWaddr;
vm_offset_t INTENARaddr;
vm_offset_t INTENAWaddr;

/*
 * the number of pages in our hw mapping and the start address
 */
vm_offset_t amigahwaddr;
u_int namigahwpg;

vm_offset_t amigashdwaddr;
u_int namigashdwpg;

vm_offset_t z2mem_start;		/* XXX */
static vm_offset_t z2mem_end;		/* XXX */
int use_z2_mem = 1;			/* XXX */

u_long boot_fphystart, boot_fphysize, boot_cphysize;

static u_long boot_flags;

u_long scsi_nosync;
int shift_nosync;

void  start_c(int, u_int, u_int, u_int, char *, u_int, u_long);
void rollcolor(int);
static int kernel_image_magic_size(void);
static void kernel_image_magic_copy(u_char *);
int kernel_reload_write(struct uio *);
extern void kernel_reload(char *, u_long, u_long, u_long, u_long,
	u_long, u_long, u_long, u_long, u_long);
extern void etext(void);
void start_c_cleanup(void);

void *
chipmem_steal(amount)
	long amount;
{
	/*
	 * steal from top of chipmem, so we don't collide with
	 * the kernel loaded into chipmem in the not-yet-mapped state.
	 */
	vm_offset_t p = chipmem_end - amount;
	if (p & 1)
		p = p - 1;
	chipmem_end = p;
	if(chipmem_start > chipmem_end)
		panic("not enough chip memory");
	return((void *)p);
}

/*
 * XXX
 * used by certain drivers currently to allocate zorro II memory
 * for bounce buffers, if use_z2_mem is NULL, chipmem will be
 * returned instead.
 * XXX
 */
void *
alloc_z2mem(amount)
	long amount;
{
	if (use_z2_mem && z2mem_end && (z2mem_end - amount) >= z2mem_start) {
		z2mem_end -= amount;
		return ((void *)z2mem_end);
	}
	return (alloc_chipmem(amount));
}


/*
 * this is the C-level entry function, it's called from locore.s.
 * Preconditions:
 *	Interrupts are disabled
 *	PA may not be == VA, so we may have to relocate addresses
 *		before enabling the MMU
 * 	Exec is no longer available (because we're loaded all over
 *		low memory, no ExecBase is available anymore)
 *
 * It's purpose is:
 *	Do the things that are done in locore.s in the hp300 version,
 *		this includes allocation of kernel maps and enabling the MMU.
 *
 * Some of the code in here is `stolen' from Amiga MACH, and was
 * written by Bryan Ford and Niklas Hallqvist.
 *
 * Very crude 68040 support by Michael L. Hitch.
 *
 */

int kernel_copyback = 1;

void
start_c(id, fphystart, fphysize, cphysize, esym_addr, flags, inh_sync)
	int id;
	u_int fphystart, fphysize, cphysize;
	char *esym_addr;
	u_int flags;
	u_long inh_sync;
{
	extern char end[];
	extern u_int protorp[2];
	struct cfdev *cd;
	u_int pstart, pend, vstart, vend, avail;
	u_int pt, ptpa, ptsize, ptextra, kstsize;
	u_int Sysptmap_pa;
	register st_entry_t sg_proto, *sg, *esg;
	register pt_entry_t pg_proto, *pg;
	u_int tc, end_loaded, ncd, i;
	struct boot_memlist *ml;
	u_int loadbase = 0;	/* XXXXXXXXXXXXXXXXXXXXXXXXXXXX */
	u_int *shadow_pt = 0;	/* XXXXXXXXXXXXXXXXXXXXXXXXXXXX */

#ifdef DEBUG_KERNEL_START
	/* XXX this only is valid if Altais is in slot 0 */
	volatile u_int8_t *altaiscolpt = (u_int8_t *)0x200003c8;
	volatile u_int8_t *altaiscol = (u_int8_t *)0x200003c9;
#endif

	if ((u_int)&loadbase > cphysize)
		loadbase = fphystart;

#ifdef DEBUG_KERNEL_START
	if ((id>>24)==0x7D) {
		*altaiscolpt = 0;
		*altaiscol = 40;
		*altaiscol = 0;
		*altaiscol = 0;
	} else
((volatile struct Custom *)0xdff000)->color[0] = 0xa00;		/* RED */
#endif

	RELOC(boot_fphystart, u_long) = fphystart;
	RELOC(boot_fphysize, u_long) = fphysize;
	RELOC(boot_cphysize, u_long) = cphysize;

	RELOC(machineid, int) = id;
	RELOC(chipmem_end, vm_offset_t) = cphysize;
	RELOC(esym, char *) = esym_addr;
	RELOC(boot_flags, u_long) = flags;
#ifdef GRF_AGA
	if (flags & 1)
		RELOC(aga_enable, u_long) |= 1;
#endif
	if (flags & (3 << 1))
		RELOC(noncontig_enable, u_long) = (flags >> 1) & 3;

	RELOC(scsi_nosync, u_long) = inh_sync;

	/*
	 * the kernel ends at end(), plus the cfdev and memlist structures
	 * we placed there in the loader.  Correct for this now.  Also,
	 * account for kernel symbols if they are present.
	 */
	if (esym_addr == NULL)
		end_loaded = (u_int) &end;
	else
		end_loaded = (u_int) esym_addr;
	RELOC(ncfdev, int) = *(int *)(&RELOC(*(u_int *)end_loaded, u_int));
	RELOC(cfdev, struct cfdev *) = (struct cfdev *) ((int)end_loaded + 4);
	end_loaded += 4 + RELOC(ncfdev, int) * sizeof(struct cfdev);

	RELOC(memlist, struct boot_memlist *) =
	    (struct boot_memlist *)end_loaded;
	ml = &RELOC(*(struct boot_memlist *)end_loaded, struct boot_memlist);
	end_loaded = (u_int) &((RELOC(memlist, struct boot_memlist *))->
	    m_seg[ml->m_nseg]);

	/*
	 * Get ZorroII (16-bit) memory if there is any and it's not where the
	 * kernel is loaded.
	 */
	if (ml->m_nseg > 0 && ml->m_nseg < 16 && RELOC(use_z2_mem, int)) {
		struct boot_memseg *sp, *esp;

		sp = ml->m_seg;
		esp = sp + ml->m_nseg;
		for (; sp < esp; sp++) {
			if ((sp->ms_attrib & (MEMF_FAST | MEMF_24BITDMA))
			    != (MEMF_FAST|MEMF_24BITDMA))
				continue;
			if (sp->ms_start == fphystart)
				continue;
			RELOC(z2mem_end, vm_offset_t) =
			    sp->ms_start + sp->ms_size;
			RELOC(z2mem_start, vm_offset_t) =
			    RELOC(z2mem_end, vm_offset_t) - MAXPHYS *
			    RELOC(use_z2_mem, int) * 7;
			RELOC(NZTWOMEMPG, u_int) =
			    (RELOC(z2mem_end, vm_offset_t) -
			    RELOC(z2mem_start, vm_offset_t)) / NBPG;
			if ((RELOC(z2mem_end, vm_offset_t) -
			    RELOC(z2mem_start, vm_offset_t)) > sp->ms_size) {
				RELOC(NZTWOMEMPG, u_int) = sp->ms_size / NBPG;
				RELOC(z2mem_start, vm_offset_t) =
				    RELOC(z2mem_end, vm_offset_t) - sp->ms_size;
			}
			break;
		}
	}

	/*
	 * Scan ConfigDev list and get size of Zorro I/O boards that are
	 * outside the Zorro II I/O area.
	 */
	for (RELOC(ZBUSAVAIL, u_int) = 0, cd =
	    &RELOC(*RELOC(cfdev, struct cfdev *),struct cfdev),
	    ncd = RELOC(ncfdev, int); ncd > 0; ncd--, cd++) {
		int bd_type = cd->rom.type & (ERT_TYPEMASK | ERTF_MEMLIST);

		if (bd_type != ERT_ZORROIII &&
		    (bd_type != ERT_ZORROII || isztwopa(cd->addr)))
			continue;	/* It's not Z2 or Z3 I/O board */
		/*
		 *  Hack to adjust board size for Zorro III boards that
		 *  do not specify an extended size or subsize.  This is
		 *  specifically for the GVP Spectrum and hopefully won't
		 *  break with other boards that configure like this.
		 */
		if (bd_type == ERT_ZORROIII &&
		    !(cd->rom.flags & ERFF_EXTENDED) &&
		    (cd->rom.flags & ERT_Z3_SSMASK) == 0)
			cd->size = 0x10000 <<
			    ((cd->rom.type - 1) & ERT_MEMMASK);
		RELOC(ZBUSAVAIL, u_int) += m68k_round_page(cd->size);
	}


	/*
	 * assume KVA_MIN == 0.  We subtract the kernel code (and
	 * the configdev's and memlists) from the virtual and
	 * phsical starts and ends.
	 */
	vend   = fphysize;
	avail  = vend;
	vstart = (u_int) end_loaded;
	vstart = m68k_round_page (vstart);
	pstart = vstart + fphystart;
	pend   = vend   + fphystart;
	avail -= vstart;

#if defined(M68040) || defined(M68060)
	if (RELOC(mmutype, int) <= MMU_68040)
		kstsize = MAXKL2SIZE / (NPTEPG/SG4_LEV2SIZE);
	else
#endif
		kstsize = 1;

	/*
	 * allocate the kernel segment table
	 */
	RELOC(Sysseg_pa, u_int) = pstart;
	RELOC(Sysseg, u_int) = vstart;
	vstart += NBPG * kstsize;
	pstart += NBPG * kstsize;
	avail -= NBPG * kstsize;

	/*
	 * allocate initial page table pages
	 */
	pt = vstart;
	ptpa = pstart;
#ifdef DRACO
	if ((id>>24)==0x7D) {
		ptextra = NDRCCPG 
		    + RELOC(NZTWOMEMPG, u_int) 
		    + btoc(RELOC(ZBUSAVAIL, u_int));
	} else
#endif
	ptextra = NCHIPMEMPG + NCIAPG + NZTWOROMPG + RELOC(NZTWOMEMPG, u_int) +
	    btoc(RELOC(ZBUSAVAIL, u_int));
	/*
	 * if kernel shadow mapping will overlap any initial mapping
	 * of Zorro I/O space or the page table map, we need to
	 * adjust things to remove the overlap.
	 */
	if (loadbase != 0) {
		/* What to do, what to do? */
	}

	ptsize = (RELOC(Sysptsize, u_int) +
	    howmany(ptextra, NPTEPG)) << PGSHIFT;

	vstart += ptsize;
	pstart += ptsize;
	avail -= ptsize;

	/*
	 * allocate kernel page table map
	 */
	RELOC(Sysptmap, u_int) = vstart;
	Sysptmap_pa = pstart;
	vstart += NBPG;
	pstart += NBPG;
	avail -= NBPG;

	/*
	 * pt maps the first N megs of ram Sysptmap comes directly
	 * after pt (ptpa) and so it must map >= N meg + Its one
	 * page and so it must map 8M of space.  Specifically
	 * Sysptmap holds the pte's that map the kerne page tables.
	 *
	 * We want Sysmap to be the first address mapped by Sysptmap.
	 * this will be the address just above what pt,pt+ptsize maps.
	 * pt[0] maps address 0 so:
	 *
	 *		ptsize
	 * Sysmap  =	------ * NBPG
	 *		  4
	 */
	RELOC(Sysmap, u_int *) = (u_int *)(ptsize * (NBPG / 4));

	/*
	 * initialize segment table and page table map
	 */
#if defined(M68040) || defined(M68060)
	if (RELOC(mmutype, int) <= MMU_68040) {
		/*
		 * First invalidate the entire "segment table" pages
		 * (levels 1 and 2 have the same "invalid" values).
		 */
		sg = (u_int *)RELOC(Sysseg_pa, u_int);
		esg = &sg[kstsize * NPTEPG];
		while (sg < esg)
			*sg++ = SG_NV;
		/*
		 * Initialize level 2 descriptors (which immediately
		 * follow the level 1 table).  We need:
		 *	NPTEPG / SG4_LEV3SIZE
		 * level 2 descriptors to map each of the nptpages + 1
		 * pages of PTEs.  Note that we set the "used" bit
		 * now to save the HW the expense of doing it.
		 */
		i = ((ptsize >> PGSHIFT) + 1) * (NPTEPG / SG4_LEV3SIZE);
		sg = &((u_int *)(RELOC(Sysseg_pa, u_int)))[SG4_LEV1SIZE];
		esg = &sg[i];
		sg_proto = ptpa | SG_U | SG_RW | SG_V;
		while (sg < esg) {
			*sg++ = sg_proto;
			sg_proto += (SG4_LEV3SIZE * sizeof (st_entry_t));
		}
		if (loadbase != 0)
			shadow_pt = esg;	/* start of next L2 table */
		/*
		 * Initialize level 1 descriptors.  We need:
		 *	roundup(num, SG4_LEV2SIZE) / SG4_LEVEL2SIZE
		 * level 1 descriptors to map the 'num' level 2's.
		 */
		i = roundup(i, SG4_LEV2SIZE) / SG4_LEV2SIZE;
		RELOC(protostfree, u_int) =
		    (-1 << (i + 1)) /* & ~(-1 << MAXKL2SIZE) */;
		sg = (u_int *) RELOC(Sysseg_pa, u_int);
		esg = &sg[i];
		sg_proto = (u_int)&sg[SG4_LEV1SIZE] | SG_U | SG_RW |SG_V;
		while (sg < esg) {
			*sg++ = sg_proto;
			sg_proto += (SG4_LEV2SIZE * sizeof(st_entry_t));
		}
		if (loadbase != 0) {
			sg = (u_int *)RELOC(Sysseg_pa, u_int);
			if (sg[loadbase >> SG4_SHIFT1] == 0) {
				/* allocate another level 2 table */
				sg[loadbase >> SG4_SHIFT1] =
				    (u_int)shadow_pt | SG_U | SG_RW | SG_V;
				shadow_pt = NULL;
				RELOC(protostfree, u_int) =
				    RELOC(protostfree, u_int) << 1;
			}
			sg = (u_int *)(sg[loadbase >> SG4_SHIFT1] & SG4_ADDR1);
			if (sg[(loadbase & SG4_MASK2) >> SG4_SHIFT2] == 0) {
				/* no page table exists, need to allocate it */
				sg_proto = pstart | SG_U | SG_RW | SG_V;
				sg = &sg[(loadbase & SG4_MASK2) >> SG4_SHIFT2];
				sg = (u_int *)((int)sg & ~(NBPG / SG4_LEV3SIZE - 1));
				esg = &sg[NPTEPG / SG4_LEV3SIZE];
				while (sg < esg) {
					*sg++ = sg_proto;
					sg_proto += SG4_LEV3SIZE * sizeof (st_entry_t);
				}
				pg = (u_int *) pstart;
				esg = (u_int *)&pg[NPTEPG];
				while (pg < esg)
					*pg++ = PG_NV;
				pstart += NBPG;
				vstart += NBPG;
				avail -= NBPG;
				/* ptmap??? */
			}
			sg = (u_int *)RELOC(Sysseg_pa, u_int);
			sg = (u_int *)(sg[loadbase >> SG4_SHIFT1] & SG4_ADDR1);
			shadow_pt = 
			    ((u_int *)(sg[(loadbase & SG4_MASK2) >> SG4_SHIFT2] 
				& SG4_ADDR1)) +
			    ((loadbase & SG4_MASK3) >> SG4_SHIFT3); /* XXX is */

		}
		/*
		 * Initialize Sysptmap
		 */
		sg = (uint *) Sysptmap_pa;
		esg = &sg[(ptsize >> PGSHIFT) + 1];
		pg_proto = ptpa | PG_RW | PG_CI | PG_V;
		while (sg < esg) {
			*sg++ = pg_proto;
			pg_proto += NBPG;
		}
		/*
		 * Invalidate rest of Sysptmap page
		 */
		esg = (u_int *)(Sysptmap_pa + NBPG);
		while (sg < esg)
			*sg++ = SG_NV;
	} else
#endif /* M68040 */
	{
		/*
		 * Map the page table pages in both the HW segment table
		 * and the software Sysptmap.  Note that Sysptmap is also
		 * considered a PT page, hence the +1.
		 */
		sg = (u_int *)RELOC(Sysseg_pa, u_int);
		pg = (u_int *)Sysptmap_pa;
		esg = &pg[(ptsize >> PGSHIFT) + 1];
		sg_proto = ptpa | SG_RW | SG_V;
		pg_proto = ptpa | PG_RW | PG_CI | PG_V;
		while (pg < esg) {
			*sg++ = sg_proto;
			*pg++ = pg_proto;
			sg_proto += NBPG;
			pg_proto += NBPG;
		}
		/*
		 * invalidate the remainder of each table
		 */
		esg = (u_int *)(Sysptmap_pa + NBPG);
		while (pg < esg) {
			*sg++ = SG_NV;
			*pg++ = PG_NV;
		}

		if (loadbase != 0) {
			sg = (u_int *)RELOC(Sysseg_pa, u_int);
			if (sg[loadbase >> SG_ISHIFT] == 0) {
				/* no page table exists, need to allocate it */
				sg[loadbase >> SG_ISHIFT] =
				    pstart | SG_RW | SG_V;
				pg = (u_int *)Sysptmap_pa;
				pg[loadbase >> SG_ISHIFT] =
				    pstart | PG_RW | PG_CI | PG_V;
				pg = (u_int *) pstart;
				esg = (u_int *)&pg[NPTEPG];
				while (pg < esg)
					*pg++ = PG_NV;
				pstart += NBPG;
				vstart += NBPG;
				avail -= NBPG;
			}
			shadow_pt = 
			    ((u_int *)(sg[loadbase >> SG_ISHIFT] & 0xffffff00)) 
			    + ((loadbase & SG_PMASK) >> SG_PSHIFT);
		}
	}

	/*
	 * initialize kernel page table page(s) (assume load at VA 0)
	 */
	pg_proto = fphystart | PG_RO | PG_V;	/* text pages are RO */
	pg       = (u_int *) ptpa;
	*pg++ = PG_NV;				/* Make page 0 invalid */
	pg_proto += NBPG;
	for (i = NBPG; i < (u_int) etext; i += NBPG, pg_proto += NBPG)
		*pg++ = pg_proto;

	/*
	 * data, bss and dynamic tables are read/write
	 */
	pg_proto = (pg_proto & PG_FRAME) | PG_RW | PG_V;

#if defined(M68040) || defined(M68060)
	/*
	 * map the kernel segment table cache invalidated for 
	 * these machines (for the 68040 not strictly necessary, but
	 * recommended by Motorola; for the 68060 mandatory)
	 */
	if (RELOC(mmutype, int) <= MMU_68040) {

		if (RELOC(kernel_copyback, int))
			pg_proto |= PG_CCB;

		/*
		 * ASSUME: segment table and statically allocated page tables
		 * of the kernel are contiguously allocated, start at
		 * Sysseg and end at the current value of vstart.
		 */
		for (; i<RELOC(Sysseg, u_int); i+= NBPG, pg_proto += NBPG)
			*pg++ = pg_proto;

		pg_proto = (pg_proto &= ~PG_CCB) | PG_CI;
		for (; i < vstart; i += NBPG, pg_proto += NBPG)
			*pg++ = pg_proto;

		pg_proto = (pg_proto & ~PG_CI);
		if (RELOC(kernel_copyback, int))
			pg_proto |= PG_CCB;
	}
#endif
	/*
	 * go till end of data allocated so far
	 * plus proc0 u-area (to be allocated)
	 */
	for (; i < vstart + USPACE; i += NBPG, pg_proto += NBPG)
		*pg++ = pg_proto;
	/*
	 * invalidate remainder of kernel PT
	 */
	while ((paddr_t)pg < (paddr_t) (ptpa + ptsize))
		*pg++ = PG_NV;

	/*
	 * go back and validate internal IO PTEs
	 * at end of allocated PT space
	 */
	pg      -= ptextra;
#ifdef DRACO
	if ((id >> 24) == 0x7D) {
		pg_proto = DRCCBASE | PG_RW | PG_CI | PG_V;
		while (pg_proto < DRZ2BASE) {
			*pg++ = pg_proto;
			pg_proto += DRCCSTRIDE;
		}

		/* NCR 53C710 chip */
		*pg++ = DRSCSIBASE | PG_RW | PG_CI | PG_V;

#ifdef DEBUG_KERNEL_START
		/*
		 * early rollcolor Altais mapping 
		 * XXX (only works if in slot 0)
		 */
		*pg++ = 0x20000000 | PG_RW | PG_CI | PG_V;
#endif
	} else
#endif
	{
		pg_proto = CHIPMEMBASE | PG_RW | PG_CI | PG_V;	
						/* CI needed here?? */
		while (pg_proto < CHIPMEMTOP) {
			*pg++     = pg_proto;
			pg_proto += NBPG;
		}
	}
	if (RELOC(z2mem_end, vm_offset_t)) {			/* XXX */
		pg_proto = RELOC(z2mem_start, vm_offset_t) |	/* XXX */
		    PG_RW | PG_V;				/* XXX */
		while (pg_proto < RELOC(z2mem_end, vm_offset_t)) { /* XXX */
			*pg++ = pg_proto;			/* XXX */
			pg_proto += NBPG;			/* XXX */
		}						/* XXX */
	}							/* XXX */
#ifdef DRACO
	if ((id >> 24) != 0x7D)
#endif
	{
		pg_proto = CIABASE | PG_RW | PG_CI | PG_V;
		while (pg_proto < CIATOP) {
			*pg++     = pg_proto;
			pg_proto += NBPG;
		}
		pg_proto  = ZTWOROMBASE | PG_RW | PG_CI | PG_V;
		while (pg_proto < ZTWOROMTOP) {
			*pg++     = pg_proto;
			pg_proto += NBPG;
		}
	}

	/*
	 * Initial any "shadow" mapping of the kernel
	 */
	if (loadbase != 0 && shadow_pt != 0) {
		RELOC(amigashdwaddr, vm_offset_t) = (u_int)shadow_pt - loadbase;
		RELOC(namigashdwpg, u_int) = (vstart + USPACE) >> PGSHIFT;
		pg_proto = fphystart | PG_RO | PG_V;
		pg = shadow_pt;
		*pg++ = PG_NV;			/* Make page 0 invalid */
		pg_proto += NBPG;
		for (i = NBPG; i < (u_int)etext; i += NBPG, pg_proto += NBPG) 
			*pg++ = pg_proto;
		pg_proto = (pg_proto & PG_FRAME) | PG_RW | PG_V;
		for (; i < vstart + USPACE; i += NBPG, pg_proto += NBPG) 
			*pg++ = pg_proto;
	}

	/*
	 *[ following page tables MAY be allocated to ZORRO3 space,
	 * but they're then later mapped in autoconf.c ]
	 */

	/* zero out proc0 user area */
/*	bzero ((u_char *)pstart, USPACE);*/	/* XXXXXXXXXXXXXXXXXXXXX */

	/*
	 * save KVA of proc0 u-area and allocate it.
	 */
	RELOC(proc0paddr, u_int) = vstart;
	pstart += USPACE;
	vstart += USPACE;
	avail -= USPACE;

	/*
	 * init mem sizes
	 */
	RELOC(maxmem, u_int)  = pend >> PGSHIFT;
	RELOC(lowram, u_int)  = fphystart;
	RELOC(physmem, u_int) = fphysize >> PGSHIFT;

	/*
	 * Put user page tables starting at next 16MB boundary, to make kernel
	 * dumps more readable, with guaranteed 16MB of.
	 * XXX depends on Sysmap being last.
	 * XXX 16 MB instead of 256 MB should be enough, but...
	 * we need to fix the fastmem loading first. (see Zorro-related
	 * comment before ``What to do, what to do'' earlier in this
	 * function)
	 */
	RELOC(amiga_uptbase, vaddr_t) =
	    roundup(RELOC(Sysmap, u_int) + 0x10000000, 0x10000000);
	/*
	 * get the pmap module in sync with reality.
	 */
/*	pmap_bootstrap(pstart, fphystart);*/	/* XXXXXXXXXXXXXXXXXXXXXXx*/

	/*
	 * record base KVA of IO spaces which are just before Sysmap
	 */
#ifdef DRACO
	if ((id >> 24) == 0x7D) {
		RELOC(DRCCADDR, u_int) =
		    (u_int)RELOC(Sysmap, u_int) - ptextra * NBPG;

		RELOC(CIAADDR, u_int) =
		    RELOC(DRCCADDR, u_int) + DRCIAPG * NBPG;

		if (RELOC(z2mem_end, vm_offset_t)) {		/* XXX */
			RELOC(ZTWOMEMADDR, u_int) =
			    RELOC(DRCCADDR, u_int) + NDRCCPG * NBPG;

			RELOC(ZBUSADDR, vm_offset_t) =
			    RELOC(ZTWOMEMADDR, u_int) + 
			    RELOC(NZTWOMEMPG, u_int)*NBPG;
		} else {
			RELOC(ZBUSADDR, vm_offset_t) =
			    RELOC(DRCCADDR, u_int) + NDRCCPG * NBPG;
		}

		/*
		 * some nice variables for pmap to use
		 */
		RELOC(amigahwaddr, vm_offset_t) = RELOC(DRCCADDR, u_int);
	} else 
#endif
	{
		RELOC(CHIPMEMADDR, u_int) =
		    (u_int)RELOC(Sysmap, u_int) - ptextra * NBPG;
		if (RELOC(z2mem_end, u_int) == 0)
			RELOC(CIAADDR, u_int) =
			    RELOC(CHIPMEMADDR, u_int) + NCHIPMEMPG * NBPG;
		else {
			RELOC(ZTWOMEMADDR, u_int) =
			    RELOC(CHIPMEMADDR, u_int) + NCHIPMEMPG * NBPG;
			RELOC(CIAADDR, u_int) =
			    RELOC(ZTWOMEMADDR, u_int) + RELOC(NZTWOMEMPG, u_int) * NBPG;
		}
		RELOC(ZTWOROMADDR, vm_offset_t)  =
		    RELOC(CIAADDR, u_int) + NCIAPG * NBPG;
		RELOC(ZBUSADDR, vm_offset_t) =
		    RELOC(ZTWOROMADDR, u_int) + NZTWOROMPG * NBPG;
		RELOC(CIAADDR, vm_offset_t) += NBPG/2;	/* not on 8k boundery :-( */
		RELOC(CUSTOMADDR, vm_offset_t)  =
		    RELOC(ZTWOROMADDR, u_int) - ZTWOROMBASE + CUSTOMBASE;
		/*
		 * some nice variables for pmap to use
		 */
		RELOC(amigahwaddr, vm_offset_t) = RELOC(CHIPMEMADDR, u_int);
	}

	/* Tell pmap how much of the kernel_map to reserve */
	RELOC(namigahwpg, u_int) = ptextra;

	/*
	 * set this before copying the kernel, so the variable is updated in
	 * the `real' place too. protorp[0] is already preset to the
	 * CRP setting.
	 */
	RELOC(protorp[1], u_int) = RELOC(Sysseg_pa, u_int);	/* + segtable address */

	/*
	 * copy over the kernel (and all now initialized variables)
	 * to fastram.  DONT use bcopy(), this beast is much larger
	 * than 128k !
	 */
	if (loadbase == 0) {
		register u_int *lp, *le, *fp;

		lp = 0;
		le = (u_int *)end_loaded;
		fp = (u_int *)fphystart;
		while (lp < le)
			*fp++ = *lp++;
	}

#ifdef DEBUG_KERNEL_START
	if ((id>>24)==0x7D) {
		*altaiscolpt = 0;
		*altaiscol = 40;
		*altaiscol = 40;
		*altaiscol = 0;
	} else
((volatile struct Custom *)0xdff000)->color[0] = 0xAA0;		/* YELLOW */
#endif
	/*
	 * prepare to enable the MMU
	 */
#if defined(M68040) || defined(M68060)
	if (RELOC(mmutype, int) <= MMU_68040) {
		/*
		 * movel Sysseg_pa,a0;
		 * movec a0,SRP;
		 * pflusha;
		 * movel #$0xc000,d0;
		 * movec d0,TC
		 */

		if (RELOC(mmutype, int) <= MMU_68060) {
			/* do i need to clear the branch cache? */
			asm volatile (	".word 0x4e7a,0x0002;" 
					"orl #0x400000,d0;" 
					".word 0x4e7b,0x0002" : : : "d0");
		}

		asm volatile ("movel %0,a0; .word 0x4e7b,0x8807"
		    : : "a" (RELOC(Sysseg_pa, u_int)) : "a0");
		asm volatile (".word 0xf518" : : );

#ifdef DEBUG_KERNEL_START
		if ((id>>24)==0x7D) {
			*altaiscolpt = 0;
			*altaiscol = 40;
			*altaiscol = 33;
			*altaiscol = 0;
		} else
((volatile struct Custom *)0xdff000)->color[0] = 0xA70;		/* ORANGE */
#endif

		asm volatile ("movel #0xc000,d0; .word 0x4e7b,0x0003" 
		    : : :"d0" );
	} else
#endif
	{

		/*
		 * setup and load SRP
		 * nolimit, share global, 4 byte PTE's
		 */
		(RELOC(protorp[0], u_int)) = 0x80000202;
		asm volatile ("pmove %0@@,srp" : : "a" (&RELOC(protorp, u_int)));
		/*
		 * setup and load TC register.
		 * enable_cpr, enable_srp, pagesize=8k,
		 * A = 8 bits, B = 11 bits
		 */
		tc = 0x82d08b00;
		asm volatile ("pmove %0@@,tc" : : "a" (&tc));
	}
#ifdef DEBUG_KERNEL_START
#ifdef DRACO
	if ((id >> 24) == 0x7D) { /* mapping on, is_draco() is valid */
		int i;
		/* XXX experimental Altais register mapping only */
		altaiscolpt = (volatile u_int8_t *)(DRCCADDR+NBPG*9+0x3c8);
		altaiscol = altaiscolpt + 1;
		for (i=0; i<140000; i++) {
			*altaiscolpt = 0;
			*altaiscol = 0;
			*altaiscol = 40;
			*altaiscol = 0;
		}
	} else
#endif
((volatile struct Custom *)CUSTOMADDR)->color[0] = 0x0a0;	/* GREEN */
#endif

	bzero ((u_char *)proc0paddr, USPACE);	/* XXXXXXXXXXXXXXXXXXXXX */
	pmap_bootstrap(pstart, fphystart);	/* XXXXXXXXXXXXXXXXXXXXXXx*/

	/*
	 * to make life easier in locore.s, set these addresses explicitly
	 */
	CIAAbase = CIAADDR + 0x1001;	/* CIA-A at odd addresses ! */
	CIABbase = CIAADDR;
	CUSTOMbase = CUSTOMADDR;
#ifdef DRACO
	if (is_draco()) {
		draco_intena = (volatile u_int8_t *)DRCCADDR+1;
		draco_intpen = draco_intena + NBPG;
		draco_intfrc = draco_intpen + NBPG;
		draco_misc = draco_intfrc + NBPG;
		draco_ioct = (struct drioct *)(DRCCADDR + DRIOCTLPG*NBPG);
	} else 
#endif
	{
		INTREQRaddr = (vm_offset_t)&custom.intreqr;
		INTREQWaddr = (vm_offset_t)&custom.intreq;
		INTENARaddr = (vm_offset_t)&custom.intenar;
		INTENAWaddr = (vm_offset_t)&custom.intena;
	}

	/*
	 * Get our chip memory allocation system working
	 */
	chipmem_start = CHIPMEMADDR + chipmem_start;
	chipmem_end   = CHIPMEMADDR + chipmem_end;

	/* XXX is: this MUST NOT BE DONE before the pmap_bootstrap() call */
	if (z2mem_end) {
		z2mem_end = ZTWOMEMADDR + NZTWOMEMPG * NBPG;
		z2mem_start = ZTWOMEMADDR;
	}

	i = *(int *)proc0paddr;
	*(volatile int *)proc0paddr = i;

	/*
	 * disable all interupts but enable allow them to be enabled
	 * by specific driver code (global int enable bit)
	 */
#ifdef DRACO
	if (is_draco()) {
		/* XXX to be done. For now, just: */
		*draco_intena = 0;
		*draco_intpen = 0;
		*draco_intfrc = 0;
		ciaa.icr = 0x7f;			/* and keyboard */
		ciab.icr = 0x7f;			/* and again */

		draco_ioct->io_control &=
		    ~(DRCNTRL_KBDINTENA|DRCNTRL_FDCINTENA); /* and another */

		draco_ioct->io_status2 &=
		    ~(DRSTAT2_PARIRQENA|DRSTAT2_TMRINTENA); /* some more */

		*(volatile u_int8_t *)(DRCCADDR + 1 +
		    DRSUPIOPG*NBPG + 4*(0x3F8 + 1)) = 0; /* and com0 */

		*(volatile u_int8_t *)(DRCCADDR + 1 +
		    DRSUPIOPG*NBPG + 4*(0x2F8 + 1)) = 0; /* and com1 */
		
		draco_ioct->io_control |= DRCNTRL_WDOGDIS; /* stop Fido */
		*draco_misc &= ~1/*DRMISC_FASTZ2*/;

	} else 
#endif
	{
		custom.intena = 0x7fff;			/* disable ints */
		custom.intena = INTF_SETCLR | INTF_INTEN;
							/* but allow them */
		custom.intreq = 0x7fff;			/* clear any current */
		ciaa.icr = 0x7f;			/* and keyboard */
		ciab.icr = 0x7f;			/* and again */
	}

	/*
	 * This is needed for 3000's with superkick ROM's. Bit 7 of
	 * 0xde0002 enables the ROM if set. If this isn't set the machine
	 * has to be powercycled in order for it to boot again. ICKA! RFH
	 */
	if (is_a3000()) {
		volatile unsigned char *a3000_magic_reset;

		a3000_magic_reset = (unsigned char *)ztwomap(0xde0002);

		/* Turn SuperKick ROM (V36) back on */
		*a3000_magic_reset |= 0x80;
	}

}

void
start_c_cleanup()
{
	u_int *sg, *esg;
	extern u_int32_t delaydivisor;

	/*
	 * remove shadow mapping of kernel?
	 */
	if (amigashdwaddr == 0)
		return;
	sg = (u_int *) amigashdwaddr;
	esg = (u_int *)&sg[namigashdwpg];
	while (sg < esg)
		*sg++ = PG_NV;

	/*
	 * preliminary delay divisor value
	 */

	if (machineid & AMIGA_68060)
		delaydivisor = (1024 * 1) / 80;	/* 80 MHz 68060 w. BTC */

	else if (machineid & AMIGA_68040)
		delaydivisor = (1024 * 3) / 40;	/* 40 MHz 68040 */

	else if (machineid & AMIGA_68030)
		delaydivisor = (1024 * 8) / 50;	/* 50 MHz 68030 */

	else
		delaydivisor = (1024 * 8) / 33; /* 33 MHz 68020 */
}

void
rollcolor(color)
	int color;
{
	int s, i;

	s = splhigh();
	/*
	 * need to adjust count -
	 * too slow when cache off, too fast when cache on
	 */
	for (i = 0; i < 400000; i++)
		((volatile struct Custom *)CUSTOMbase)->color[0] = color;
	splx(s);
}

/*
 * Kernel reloading code
 */

static struct exec kernel_exec;
static u_char *kernel_image;
static u_long kernel_text_size, kernel_load_ofs;
static u_long kernel_load_phase;
static u_long kernel_load_endseg;
static u_long kernel_symbol_size, kernel_symbol_esym;

/* This supports the /dev/reload device, major 2, minor 20,
   hooked into mem.c.  Author: Bryan Ford.  */

/*
 * This is called below to find out how much magic storage
 * will be needed after a kernel image to be reloaded.
 */
static int
kernel_image_magic_size()
{
	int sz;

	/* 4 + cfdev's + Mem_Seg's + 4 */
	sz = 8 + ncfdev * sizeof(struct cfdev)
	    + memlist->m_nseg * sizeof(struct boot_memseg);
	return(sz);
}

/* This actually copies the magic information.  */
static void
kernel_image_magic_copy(dest)
	u_char *dest;
{
	*((int *)dest) = ncfdev;
	dest += 4;
	bcopy(cfdev, dest, ncfdev * sizeof(struct cfdev)
	    + memlist->m_nseg * sizeof(struct boot_memseg) + 4);
}

#undef __LDPGSZ
#define __LDPGSZ 8192 /* XXX ??? */

int
kernel_reload_write(uio)
	struct uio *uio;
{
	extern int eclockfreq;
	struct iovec *iov;
	int error, c;

	iov = uio->uio_iov;

	if (kernel_image == 0) {
		/*
		 * We have to get at least the whole exec header
		 * in the first write.
		 */
		if (iov->iov_len < sizeof(kernel_exec))
			return ENOEXEC;		/* XXX */

		/*
		 * Pull in the exec header and check it.
		 */
		if ((error = uiomove((caddr_t)&kernel_exec,
		    sizeof(kernel_exec), uio)) != 0)
			return(error);
		printf("loading kernel %ld+%ld+%ld+%ld\n", kernel_exec.a_text,
		    kernel_exec.a_data, kernel_exec.a_bss,
		    esym == NULL ? 0 : kernel_exec.a_syms);
		/*
		 * Looks good - allocate memory for a kernel image.
		 */
		kernel_text_size = (kernel_exec.a_text
			+ __LDPGSZ - 1) & (-__LDPGSZ);
		/*
		 * Estimate space needed for symbol names, since we don't
		 * know how big it really is.
		 */
		if (esym != NULL) {
			kernel_symbol_size = kernel_exec.a_syms;
			kernel_symbol_size += 16 * (kernel_symbol_size / 12);
		}
		/*
		 * XXX - should check that image will fit in CHIP memory
		 * XXX return an error if it doesn't
		 */
		if ((kernel_text_size + kernel_exec.a_data +
		    kernel_exec.a_bss + kernel_symbol_size +
		    kernel_image_magic_size()) > boot_cphysize)
			return (EFBIG);
		kernel_image = malloc(kernel_text_size + kernel_exec.a_data
			+ kernel_exec.a_bss
			+ kernel_symbol_size
			+ kernel_image_magic_size(),
			M_TEMP, M_WAITOK);
		kernel_load_ofs = 0;
		kernel_load_phase = 0;
		kernel_load_endseg = kernel_exec.a_text;
		return(0);
	}
	/*
	 * Continue loading in the kernel image.
	 */
	c = min(iov->iov_len, kernel_load_endseg - kernel_load_ofs);
	c = min(c, MAXPHYS);
	if ((error = uiomove(kernel_image + kernel_load_ofs, (int)c, uio)) != 0)
		return(error);
	kernel_load_ofs += c;

	/*
	 * Fun and games to handle loading symbols - the length of the
	 * string table isn't know until after the symbol table has
	 * been loaded.  We have to load the kernel text, data, and
	 * the symbol table, then get the size of the strings.  A
	 * new kernel image is then allocated and the data currently
	 * loaded moved to the new image.  Then continue reading the
	 * string table.  This has problems if there isn't enough
	 * room to allocate space for the two copies of the kernel
	 * image.  So the approach I took is to guess at the size
	 * of the symbol strings.  If the guess is wrong, the symbol
	 * table is ignored.
	 */

	if (kernel_load_ofs != kernel_load_endseg)
		return(0);

	switch (kernel_load_phase) {
	case 0:		/* done loading kernel text */
		kernel_load_ofs = kernel_text_size;
		kernel_load_endseg = kernel_load_ofs + kernel_exec.a_data;
		kernel_load_phase = 1;
		break;
	case 1:		/* done loading kernel data */
		for(c = 0; c < kernel_exec.a_bss; c++)
			kernel_image[kernel_load_ofs + c] = 0;
		kernel_load_ofs += kernel_exec.a_bss;
		if (esym) {
			kernel_load_endseg = kernel_load_ofs
			    + kernel_exec.a_syms + 8;
			*((u_long *)(kernel_image + kernel_load_ofs)) =
			    kernel_exec.a_syms;
			kernel_load_ofs += 4;
			kernel_load_phase = 3;
			break;
		}
		/*FALLTHROUGH*/
	case 2:		/* done loading kernel */

		/*
		 * Put the finishing touches on the kernel image.
		 */
		kernel_image_magic_copy(kernel_image + kernel_load_ofs);
		/*
		 * Start the new kernel with code in locore.s.
		 */
		kernel_reload(kernel_image,
		    kernel_load_ofs + kernel_image_magic_size(),
		    kernel_exec.a_entry, boot_fphystart, boot_fphysize,
		    boot_cphysize, kernel_symbol_esym, eclockfreq,
		    boot_flags, scsi_nosync);
		/*
		 * kernel_reload() now checks to see if the reload_code
		 * is at the same location in the new kernel.
		 * If it isn't, it will return and we will return
		 * an error.
		 */
		free(kernel_image, M_TEMP);
		kernel_image = NULL;
		return (ENODEV);	/* Say operation not supported */
	case 3:		/* done loading kernel symbol table */
		c = *((u_long *)(kernel_image + kernel_load_ofs - 4));
		if (c > 16 * (kernel_exec.a_syms / 12))
			c = 16 * (kernel_exec.a_syms / 12);
		kernel_load_endseg += c - 4;
		kernel_symbol_esym = kernel_load_endseg;
#ifdef notyet
		kernel_image_copy = kernel_image;
		kernel_image = malloc(kernel_load_ofs + c
		    + kernel_image_magic_size(), M_TEMP, M_WAITOK);
		if (kernel_image == NULL)
			panic("kernel_reload failed second malloc");
		for (c = 0; c < kernel_load_ofs; c += MAXPHYS)
			bcopy(kernel_image_copy + c, kernel_image + c,
			    (kernel_load_ofs - c) > MAXPHYS ? MAXPHYS :
			    kernel_load_ofs - c);
#endif
		kernel_load_phase = 2;
	}
	return(0);
}
@


1.28
log
@revert the pmap stuff to 0221, so we can boot
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.24 2001/12/20 19:02:23 miod Exp $	*/
@


1.27
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.26 2002/03/14 01:26:28 millert Exp $	*/
d177 2
d572 4
a580 1
		pg_proto |= PG_CCB;
d588 3
a590 1
		pg_proto = (pg_proto & ~PG_CI) | PG_CCB;
@


1.26
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.25 2002/02/23 00:31:09 miod Exp $	*/
d1049 1
a1049 1
	*((int*)dest) = ncfdev;
@


1.25
log
@Bring back pmap_motorola in service for amiga, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.24 2001/12/20 19:02:23 miod Exp $	*/
d111 9
a119 9
void  start_c __P((int, u_int, u_int, u_int, char *, u_int, u_long));
void rollcolor __P((int));
static int kernel_image_magic_size __P((void));
static void kernel_image_magic_copy __P((u_char *));
int kernel_reload_write __P((struct uio *));
extern void kernel_reload __P((char *, u_long, u_long, u_long, u_long,
	u_long, u_long, u_long, u_long, u_long));
extern void etext __P((void));
void start_c_cleanup __P((void));
@


1.24
log
@Temporarily revert the pmap_motorola changes, as they may account for
some problems as well.
Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.23 2001/12/06 22:33:57 miod Exp $	*/
a176 2
int kernel_copyback = 1;

a569 4

		if (RELOC(kernel_copyback, int))
			pg_proto |= PG_CCB;

d575 1
d583 1
a583 3
		pg_proto = (pg_proto & ~PG_CI);
		if (RELOC(kernel_copyback, int))
			pg_proto |= PG_CCB;
@


1.23
log
@References to ``comment at line foo'' is useless once line foo moves,
dammit. Change description.
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.22 2001/11/30 23:14:28 miod Exp $	*/
d177 2
d572 4
a580 1
		pg_proto |= PG_CCB;
d589 2
a590 1
		pg_proto |= PG_CCB;
@


1.23.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.24 2001/12/20 19:02:23 miod Exp $	*/
a176 2
int kernel_copyback = 1;

a569 4

		if (RELOC(kernel_copyback, int))
			pg_proto |= PG_CCB;

d575 1
d584 1
a584 2
		if (RELOC(kernel_copyback, int))
			pg_proto |= PG_CCB;
@


1.23.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.23.2.1 2002/01/31 22:55:06 niklas Exp $	*/
d111 9
a119 9
void  start_c(int, u_int, u_int, u_int, char *, u_int, u_long);
void rollcolor(int);
static int kernel_image_magic_size(void);
static void kernel_image_magic_copy(u_char *);
int kernel_reload_write(struct uio *);
extern void kernel_reload(char *, u_long, u_long, u_long, u_long,
	u_long, u_long, u_long, u_long, u_long);
extern void etext(void);
void start_c_cleanup(void);
d1056 1
a1056 1
	*((int *)dest) = ncfdev;
@


1.23.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.23.2.2 2002/06/11 03:34:56 art Exp $	*/
@


1.22
log
@Switch to pmap_motorola.
XXX Kernel compiles, but not tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.21 2001/11/30 22:08:13 miod Exp $	*/
d701 3
a703 1
	 * we need to fix the fastmem loading first. (see comment at line 375)
@


1.21
log
@Make it possible for mmutype to contain MMU_68060 if the hardware is
actually '060-based, instead to look at the machineid.
This is simpler, and will be required to switch to pmap_motorola anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.20 2001/11/06 19:53:13 miod Exp $	*/
d596 1
a596 1
	while (pg < (paddr_t) (ptpa + ptsize))
@


1.20
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.19 2001/05/14 15:43:11 jj Exp $	*/
a176 2
int kernel_copyback = 1;

d327 1
a327 1
	if (RELOC(mmutype, int) == MMU_68040)
d401 1
a401 1
	if (RELOC(mmutype, int) == MMU_68040) {
d569 1
a569 5
	if (RELOC(mmutype, int) == MMU_68040) {

		if (RELOC(kernel_copyback, int))
			pg_proto |= PG_CCB;

d575 1
d584 1
a584 2
		if (RELOC(kernel_copyback, int))
			pg_proto |= PG_CCB;
d596 1
a596 1
	while (pg < (u_int *) (ptpa + ptsize))
d802 1
a802 1
	if (RELOC(mmutype, int) == MMU_68040) {
d811 1
a811 1
		if (id & AMIGA_68060) {
@


1.19
log
@PAGE_SIZE,MASK,SHIFT-Reloc's had to go. Ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.18 2001/04/20 11:01:55 art Exp $	*/
d37 1
a37 1
#include <vm/vm.h>
d51 1
a51 1
#include <vm/pmap.h>
@


1.18
log
@Big upgrade of the pmap. Revised pagetable handling, more careful wiring,
more careful handling of pageability.

From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.17 2000/05/27 19:45:17 art Exp $	*/
a313 6
	/*
	 * update these as soon as possible!
	 */
	RELOC(PAGE_SIZE, u_int)  = NBPG;
	RELOC(PAGE_MASK, u_int)  = NBPG-1;
	RELOC(PAGE_SHIFT, u_int) = PG_SHIFT;
@


1.17
log
@Oops. This is also needed for MACHINE_NEW_NONCONTIG.
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.16 1998/04/04 17:13:17 niklas Exp $	*/
d73 1
d708 9
@


1.16
log
@Yay! This fixes a bug that has been there since day one of the amiga port.
We have never protected the kvm area that maps Zorro I/O registers in the
Z2 memory space from being allocated by the kmem_* routines.  Lately kvm
usage has increased and we have needed more kvm allocated than earlier thus
this area have got allocated with random results.  Most often resulting in
MMU fault panics, but also in hangs.  This bug has stalled the amiga port
release builds for several weeks, but now I *hope* the amiga will have a
chance to be built and tested in time for 2.3.
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.15 1997/09/08 19:42:28 niklas Exp $	*/
a79 1
#ifdef MACHINE_NONCONTIG
a80 1
#endif
a229 1
#ifdef MACHINE_NONCONTIG
d232 1
a232 1
#endif
@


1.16.10.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.17 2000/05/27 19:45:17 art Exp $	*/
d80 1
d82 1
d232 1
d235 1
a235 1

@


1.16.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.16.10.1 2001/04/18 16:01:54 niklas Exp $	*/
a72 1
vaddr_t		amiga_uptbase;
d313 6
a706 9
	/*
	 * Put user page tables starting at next 16MB boundary, to make kernel
	 * dumps more readable, with guaranteed 16MB of.
	 * XXX depends on Sysmap being last.
	 * XXX 16 MB instead of 256 MB should be enough, but...
	 * we need to fix the fastmem loading first. (see comment at line 375)
	 */
	RELOC(amiga_uptbase, vaddr_t) =
	    roundup(RELOC(Sysmap, u_int) + 0x10000000, 0x10000000);
@


1.16.10.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 1
a37 1
#include <uvm/uvm_extern.h>
d51 1
a51 1
#include <uvm/uvm_pmap.h>
@


1.16.10.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.16.10.3 2001/11/13 21:00:50 niklas Exp $	*/
d177 2
d329 1
a329 1
	if (RELOC(mmutype, int) <= MMU_68040)
d403 1
a403 1
	if (RELOC(mmutype, int) <= MMU_68040) {
d571 5
a575 1
	if (RELOC(mmutype, int) <= MMU_68040) {
a580 1
		pg_proto |= PG_CCB;
d589 2
a590 1
		pg_proto |= PG_CCB;
d602 1
a602 1
	while ((paddr_t)pg < (paddr_t) (ptpa + ptsize))
d808 1
a808 1
	if (RELOC(mmutype, int) <= MMU_68040) {
d817 1
a817 1
		if (RELOC(mmutype, int) <= MMU_68060) {
@


1.16.10.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d583 2
a584 1
		pg_proto = (pg_proto & ~PG_CI) | PG_CCB;
d701 1
a701 3
	 * we need to fix the fastmem loading first. (see Zorro-related
	 * comment before ``What to do, what to do'' earlier in this
	 * function)
@


1.16.10.6
log
@Merge in -current from about a week ago
@
text
@d111 9
a119 9
void  start_c(int, u_int, u_int, u_int, char *, u_int, u_long);
void rollcolor(int);
static int kernel_image_magic_size(void);
static void kernel_image_magic_copy(u_char *);
int kernel_reload_write(struct uio *);
extern void kernel_reload(char *, u_long, u_long, u_long, u_long,
	u_long, u_long, u_long, u_long, u_long);
extern void etext(void);
void start_c_cleanup(void);
d1049 1
a1049 1
	*((int *)dest) = ncfdev;
@


1.16.10.7
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.16.10.6 2002/03/28 10:06:14 niklas Exp $	*/
@


1.15
log
@From NetBSD: Correct delaydivisor for 030. s/amiga_round_page/m68k_round_page
@
text
@d1 1
a1 1
/*	$OpenBSD: amiga_init.c,v 1.14 1997/01/16 09:23:14 niklas Exp $	*/
a741 2
		RELOC(namigahwpg, u_int) =
		    NDRCCPG + NDRCIAPG + RELOC(NZTWOMEMPG, u_int);
a766 2
		RELOC(namigahwpg, u_int) =
		    NCHIPMEMPG + NCIAPG + NZTWOROMPG + RELOC(NZTWOMEMPG, u_int);
d769 3
d777 1
a777 1
	(RELOC(protorp[1], u_int)) = RELOC(Sysseg_pa, u_int);	/* + segtable address */
@


1.14
log
@Sync to NetBSD 970110
@
text
@d1 2
a2 2
/*	$OpenBSD: amiga_init.c,v 1.13 1996/10/04 23:34:35 niklas Exp $	*/
/*	$NetBSD: amiga_init.c,v 1.53 1996/11/30 01:20:14 is Exp $	*/
d313 1
a313 1
		RELOC(ZBUSAVAIL, u_int) += amiga_round_page(cd->size);
d331 1
a331 1
	vstart = amiga_round_page (vstart);
d998 1
a998 1
		delaydivisor = (1024 * 3) / 50;	/* 50 MHz 68030 */
@


1.13
log
@Merge of NetBSD 1.2 (961004)
@
text
@d1 2
a2 2
/*	$OpenBSD: amiga_init.c,v 1.12 1996/08/19 00:04:12 niklas Exp $	*/
/*	$NetBSD: amiga_init.c,v 1.41.4.4 1996/08/03 00:56:12 jtc Exp $	*/
a926 1
#if 0
d928 8
a935 2
#endif
		*(volatile u_int8_t *)(DRCCADDR + 
d937 2
a938 1
		*(volatile u_int8_t *)(DRCCADDR +
d941 1
d975 1
d986 16
d1084 2
a1085 2
		if ((error = uiomove((caddr_t)&kernel_exec, sizeof(kernel_exec),
		     uio)) != 0)
d1088 2
a1089 2
			kernel_exec.a_data, kernel_exec.a_bss,
			esym == NULL ? 0 : kernel_exec.a_syms);
@


1.12
log
@Merge of Late July NetBSD sources (mostly DRACO support).  More to come...
@
text
@d1 2
a2 2
/*	$OpenBSD: amiga_init.c,v 1.11 1996/05/29 10:14:17 niklas Exp $	*/
/*	$NetBSD: amiga_init.c,v 1.41.4.2 1996/06/21 06:45:37 jtc Exp $	*/
d101 1
a101 1
static vm_offset_t z2mem_start;		/* XXX */
d581 13
a593 3
		pg_proto |= PG_CI;
		for (; i < RELOC(Sysseg, u_int) + kstsize; i += NBPG, 
		    pg_proto += NBPG)
d907 1
@


1.11
log
@Merge of 960526 NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: amiga_init.c,v 1.7 1996/04/21 22:14:47 deraadt Exp $	*/
/*	$NetBSD: amiga_init.c,v 1.41 1996/05/09 20:30:30 is Exp $	*/
d70 1
a70 1
#ifdef M68040
d175 1
d201 1
d205 1
d210 1
d218 1
d336 1
a336 1
#ifdef M68040
d611 1
a611 8
		while (pg_proto < DRCIATOP) {
			if (*pg != PG_NV) {
				*altaiscolpt = 0;
				*altaiscol = 20;
				*altaiscol = 0;
				*altaiscol = 0;
				asm volatile("stop #0x2700"::);
			}
a616 7
		if (*pg != PG_NV) {
			*altaiscolpt = 0;
			*altaiscol = 20;
			*altaiscol = 0;
			*altaiscol = 0;
			asm volatile("stop #0x2700"::);
		}
d619 5
a623 8
		/* XXX Debug Altais register mapping */
		if (*pg != PG_NV) {
			*altaiscolpt = 0;
			*altaiscol = 20;
			*altaiscol = 0;
			*altaiscol = 0;
			asm volatile("stop #0x2700"::);
		}
d625 1
d785 1
d793 1
d797 1
a797 1
#ifdef M68040
d818 1
d826 1
d848 1
d853 1
a853 1
		altaiscolpt = (volatile u_int8_t *)(DRCCADDR+NBPG*8+0x3c8);
d864 1
@


1.10
log
@From NetBSD:
Startup modified to work with kernel loaded directly into fast memory.
This removes the need to have enough chip memory to load the kernel
when booting.  Kernel memory is dual-mapped (VA == 0 and VA == PA)
for enabling the MMU, and the VA == PA mapping removed after start_c()
has completed.  Chip memory is still required for the /dev/reload
process.
@
text
@d2 1
a2 1
/*	$NetBSD: amiga_init.c,v 1.40 1996/05/04 04:45:18 mhitch Exp $	*/
d59 1
d177 2
d200 4
d207 8
d352 7
d405 1
a405 1
#ifdef M68040
d480 5
a484 2
			shadow_pt = (u_int *)(sg[(loadbase & SG4_MASK2) >>
			    SG4_SHIFT2] & SG4_ADDR1);
d547 3
a549 2
			shadow_pt = (u_int *)(sg[loadbase >> SG_ISHIFT]
			    & 0xffffff00);
d567 18
a584 3
#ifdef M68040
	if (RELOC(mmutype, int) == MMU_68040)
		pg_proto |= PG_CCB;
d603 43
a645 4
	pg_proto = CHIPMEMBASE | PG_RW | PG_CI | PG_V;	/* CI needed here?? */
	while (pg_proto < CHIPMEMTOP) {
		*pg++     = pg_proto;
		pg_proto += NBPG;
d655 14
a668 9
	pg_proto = CIABASE | PG_RW | PG_CI | PG_V;
	while (pg_proto < CIATOP) {
		*pg++     = pg_proto;
		pg_proto += NBPG;
	}
	pg_proto  = ZTWOROMBASE | PG_RW | PG_CI | PG_V;
	while (pg_proto < ZTWOROMTOP) {
		*pg++     = pg_proto;
		pg_proto += NBPG;
d681 1
a681 1
		for (i = NBPG; i < (u_int)etext; i += NBPG, pg_proto += NBPG)
d684 1
a684 1
		for (; i < vstart + USPACE; i += NBPG, pg_proto += NBPG)
d719 5
a723 3
	RELOC(CHIPMEMADDR, u_int) =
	    (u_int)RELOC(Sysmap, u_int) - ptextra * NBPG;
	if (RELOC(z2mem_end, u_int) == 0)
d725 47
a771 6
		    RELOC(CHIPMEMADDR, u_int) + NCHIPMEMPG * NBPG;
	else {
		RELOC(ZTWOMEMADDR, u_int) =
		    RELOC(CHIPMEMADDR, u_int) + NCHIPMEMPG * NBPG;
		RELOC(CIAADDR, u_int) =
		    RELOC(ZTWOMEMADDR, u_int) + RELOC(NZTWOMEMPG, u_int) * NBPG;
a772 13
	RELOC(ZTWOROMADDR, vm_offset_t)  =
	    RELOC(CIAADDR, u_int) + NCIAPG * NBPG;
	RELOC(ZBUSADDR, vm_offset_t) =
	    RELOC(ZTWOROMADDR, u_int) + NZTWOROMPG * NBPG;
	RELOC(CIAADDR, vm_offset_t) += NBPG/2;	/* not on 8k boundery :-( */
	RELOC(CUSTOMADDR, vm_offset_t)  =
	    RELOC(ZTWOROMADDR, u_int) - ZTWOROMBASE + CUSTOMBASE;
	/*
	 * some nice variables for pmap to use
	 */
	RELOC(amigahwaddr, vm_offset_t) = RELOC(CHIPMEMADDR, u_int);
	RELOC(namigahwpg, u_int) =
	    NCHIPMEMPG + NCIAPG + NZTWOROMPG + RELOC(NZTWOMEMPG, u_int);
d796 7
d815 8
d826 11
a836 2
		asm volatile ("movel #0xc000,d0; .word 0x4e7b,0x0003"
		    : : : "d0");
d855 15
d880 15
a894 4
	INTREQRaddr = (vm_offset_t)&custom.intreqr;
	INTREQWaddr = (vm_offset_t)&custom.intreq;
	INTENARaddr = (vm_offset_t)&custom.intenar;
	INTENAWaddr = (vm_offset_t)&custom.intena;
d914 27
a940 5
	custom.intena = 0x7fff;				/* disable ints */
	custom.intena = INTF_SETCLR | INTF_INTEN;	/* but allow them */
	custom.intreq = 0x7fff;			/* clear any current */
	ciaa.icr = 0x7f;			/* and keyboard */
	ciab.icr = 0x7f;			/* and again */
@


1.9
log
@From NetBSD:
Add a check in the kernel reload device (/dev/reload) to protect
against the MMU switch code being in different locations between
the running kernel and the new kernel.  Returns ENODEV if the reload
fails.
Change the error return from EFAULT to ENOEXEC when kernel_reload
gets a short write on the exec header.
Missed a prototype for kernel_reload().
@
text
@d2 1
a2 1
/*	$NetBSD: amiga_init.c,v 1.39 1996/05/02 19:34:27 mhitch Exp $	*/
d62 2
d97 3
d119 1
d161 2
a162 2
 *	PA == VA, we don't have to relocate addresses before enabling
 *		the MMU
d193 15
a207 9

	boot_fphystart = fphystart;
	boot_fphysize = fphysize;
	boot_cphysize = cphysize;

	machineid = id;
	chipmem_end = cphysize;
	esym = esym_addr;
	boot_flags = flags;
d210 1
a210 1
		aga_enable |= 1;
d214 1
a214 1
		noncontig_enable = (flags >> 1) & 3;
d216 1
a216 1
	scsi_nosync = inh_sync;
d219 3
a221 2
	 * the kernel ends at end(), plus the cfdev structures we placed
	 * there in the loader. Correct for this now.
d223 13
a235 12
	if (esym == NULL) {
		ncfdev = *(int *)end;
		cfdev = (struct cfdev *) ((int)end + 4);
		end_loaded = (u_int)end + 4 + ncfdev * sizeof(struct cfdev);
	} else {
		ncfdev = *(int *)esym;
		cfdev = (struct cfdev *) ((int)esym + 4);
		end_loaded = (u_int)esym + 4 + ncfdev * sizeof(struct cfdev);
	}

	memlist = (struct boot_memlist *)end_loaded;
	end_loaded = (u_int)&memlist->m_seg[memlist->m_nseg];
d241 1
a241 1
	if (memlist->m_nseg > 0 && memlist->m_nseg < 16 && use_z2_mem) {
d244 2
a245 2
		sp = memlist->m_seg;
		esp = sp + memlist->m_nseg;
d252 13
a264 6
			z2mem_end = sp->ms_start + sp->ms_size;
			z2mem_start = z2mem_end - MAXPHYS * use_z2_mem * 7;
			NZTWOMEMPG = (z2mem_end - z2mem_start) / NBPG;
			if ((z2mem_end - z2mem_start) > sp->ms_size) {
				NZTWOMEMPG = sp->ms_size / NBPG;
				z2mem_start = z2mem_end - sp->ms_size;
d274 3
a276 1
	for (ZBUSAVAIL = 0, cd = cfdev, ncd = ncfdev; ncd > 0; ncd--, cd++) {
d293 1
a293 1
		ZBUSAVAIL += amiga_round_page(cd->size);
d299 3
a301 3
	PAGE_SIZE  = NBPG;
	PAGE_MASK  = NBPG-1;
	PAGE_SHIFT = PG_SHIFT;
d317 1
a317 1
	if (mmutype == MMU_68040)
d326 2
a327 2
	Sysseg_pa = pstart;
	Sysseg = vstart;
d337 13
a349 2
	ptextra = NCHIPMEMPG + NCIAPG + NZTWOROMPG + NZTWOMEMPG + btoc(ZBUSAVAIL);
	ptsize = (Sysptsize + howmany(ptextra, NPTEPG)) << PGSHIFT;
d358 1
a358 1
	Sysptmap = vstart;
d378 1
a378 1
	Sysmap = (u_int *)(ptsize * (NBPG / 4));
d384 1
a384 1
	if (mmutype == MMU_68040) {
d389 1
a389 1
		sg = (u_int *)Sysseg_pa;
d402 1
a402 1
		sg = &((u_int *)Sysseg_pa)[SG4_LEV1SIZE];
d409 2
d417 3
a419 2
		protostfree = (-1 << (i + 1)) /* & ~(-1 << MAXKL2SIZE) */;
		sg = (u_int *) Sysseg_pa;
d426 35
d464 1
a464 1
		sg = (u_int *)Sysptmap_pa;
d485 1
a485 1
		sg = (u_int *)Sysseg_pa;
d504 21
d542 1
a542 1
	if (mmutype == MMU_68040)
d567 4
a570 3
	if (z2mem_end) {					/* XXX */
		pg_proto = z2mem_start | PG_RW | PG_V;		/* XXX */
		while (pg_proto < z2mem_end) {			/* XXX */
d587 17
d609 1
a609 1
	bzero ((u_char *)pstart, USPACE);
d614 1
a614 1
	proc0paddr = vstart;
d622 3
a624 3
	maxmem  = pend >> PGSHIFT;
	lowram  = fphystart;
	physmem = fphysize >> PGSHIFT;
d629 1
a629 1
	pmap_bootstrap(pstart, fphystart);
d634 5
a638 3
	CHIPMEMADDR = (u_int)Sysmap - ptextra * NBPG;
	if (z2mem_end == 0)
		CIAADDR = CHIPMEMADDR + NCHIPMEMPG * NBPG;
d640 12
a651 7
		ZTWOMEMADDR = CHIPMEMADDR + NCHIPMEMPG * NBPG;
		CIAADDR   = ZTWOMEMADDR + NZTWOMEMPG * NBPG;
	}
	ZTWOROMADDR  = CIAADDR + NCIAPG * NBPG;
	ZBUSADDR = ZTWOROMADDR + NZTWOROMPG * NBPG;
	CIAADDR += NBPG/2;		 /* not on 8k boundery :-( */
	CUSTOMADDR  = ZTWOROMADDR - ZTWOROMBASE + CUSTOMBASE;
d655 3
a657 2
	amigahwaddr = CHIPMEMADDR;
	namigahwpg = NCHIPMEMPG + NCIAPG + NZTWOROMPG + NZTWOMEMPG;
d664 1
a664 1
	protorp[1] = Sysseg_pa;		/* + segtable address */
d671 1
a671 1
	{
d685 1
a685 1
	if (mmutype == MMU_68040) {
d694 1
a694 1
		    : : "a" (Sysseg_pa) : "a0");
d706 2
a707 2
		protorp[0] = 0x80000202;
		asm volatile ("pmove %0@@,srp" : : "a" (protorp));
d717 3
d771 15
@


1.8
log
@Sync with NetBSD 9600430.  The port has gone over a major -Wall treat
@
text
@d2 1
a2 1
/*	$NetBSD: amiga_init.c,v 1.37 1996/04/21 21:06:46 veego Exp $	*/
d111 2
a112 1
extern void kernel_reload ();
d725 1
a725 1
			return EFAULT;		/* XXX */
a818 1
		bootsync();
a826 1
		/*NOTREACHED*/
d828 8
a835 5
		 * XXX - kernel_reload() needs to verify that the
		 * reload code is at the same location in the new
		 * kernel.  If it isn't, it will return and we will
		 * return an error.
		 */
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: amiga_init.c,v 1.6 1996/03/24 15:59:41 niklas Exp $	*/
/*	$NetBSD: amiga_init.c,v 1.36 1996/03/19 11:12:10 is Exp $	*/
d106 8
a177 1
	extern void etext();
d182 1
a182 1
	u_int Sysptmap_pa, umap_pa;
d729 2
a730 2
		if (error = uiomove((caddr_t)&kernel_exec, sizeof(kernel_exec),
		    uio))
d732 1
a732 1
		printf("loading kernel %d+%d+%d+%d\n", kernel_exec.a_text,
d771 1
a771 1
	if (error = uiomove(kernel_image + kernel_load_ofs, (int)c, uio))
@


1.6
log
@From NetBSD: Add clobbers missing in asm statements
@
text
@d1 2
a2 2
/*    $OpenBSD: amiga_init.c,v 1.5 1996/02/26 21:24:51 niklas Exp $	*/
/*    $NetBSD: amiga_init.c,v 1.35 1996/02/24 07:43:14 chopps Exp $   */
@


1.5
log
@From NetBSD: cast to arg to caddr_t (fixes #2114)
@
text
@d1 1
a1 1
/*    $OpenBSD$	*/
d567 1
a567 1
		    : : "a" (Sysseg_pa));
d569 2
a570 1
		asm volatile ("movel #0xc000,d0; .word 0x4e7b,0x0003" : : );
@


1.4
log
@Added support for a new (well, I've run it locally for a year or two)
interrupt system which is a prerequisite for the Amiga ISA support.
It is described in amiga/amiga/README.ints, and is enabled by adding
an "options IPL_REMAP_1" in the kernel config file.  Along with this
change there is also some generic cleanup, like style polishing,
comment corrections, making sicallbacks operate in FIFO manner and
cleaning up the spl mess in param.h...
@
text
@d1 2
a2 1
/*	$NetBSD: amiga_init.c,v 1.33.2.2 1995/11/24 07:51:07 chopps Exp $	*/
d721 2
a722 1
		if (error = uiomove(&kernel_exec, sizeof(kernel_exec), uio))
@


1.3
log
@let loadbsd define sync scsi operation
@
text
@d85 2
a86 5

/*
 * these are used by the extended spl?() macros.
 */
volatile unsigned short *amiga_intena_read, *amiga_intena_write;
d596 2
a621 7

	/*
	 * remember address of read and write intena register for use
	 * by extended spl?() macros.
	 */
	amiga_intena_read  = &custom.intenar;
	amiga_intena_write = &custom.intena;
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: amiga_init.c,v 1.33.2.1 1995/11/10 16:09:54 chopps Exp $	*/
d105 3
d164 1
a164 1
start_c(id, fphystart, fphysize, cphysize, esym_addr, flags)
d169 1
d198 1
d750 4
d824 1
a824 1
		    boot_flags);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: amiga_init.c,v 1.33 1995/10/05 12:40:48 chopps Exp $	*/
d66 3
d352 1
a352 1
		 * level 2 descriptors to map eachof the nptpages + 1
d369 2
d372 1
a372 1
		esg = &sg[roundup(i, SG4_LEV2SIZE) / SG4_LEV2SIZE];
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
