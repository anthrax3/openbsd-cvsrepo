head	1.34;
access;
symbols
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	UBC_SYNC_A:1.34
	OPENBSD_3_2:1.33.0.2
	OPENBSD_3_2_BASE:1.33
	OPENBSD_3_1:1.32.0.2
	OPENBSD_3_1_BASE:1.32
	UBC_SYNC_B:1.33
	UBC:1.29.0.2
	UBC_BASE:1.29
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.17.0.12
	OPENBSD_2_7_BASE:1.17
	SMP:1.17.0.10
	SMP_BASE:1.17
	kame_19991208:1.17
	OPENBSD_2_6:1.17.0.8
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.17.0.6
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.17.0.4
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.17.0.2
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.16.0.2
	OPENBSD_2_2_BASE:1.16
	OPENBSD_2_1:1.13.0.2
	OPENBSD_2_1_BASE:1.13
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2002.12.31.16.35.36;	author miod;	state dead;
branches;
next	1.33;

1.33
date	2002.05.16.21.11.13;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.25.18.09.13;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.14.01.26.28;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.22.21.25.59;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.30.22.08.13;	author miod;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2001.11.28.16.13.27;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.28.13.47.37;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.25.17.21.32;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.25.17.15.15;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.06.18.41.09;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.13.15.35.05;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.27.03.54.13;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.05.20.56.32;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2000.11.10.18.15.35;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2000.05.27.21.34.36;	author art;	state Exp;
branches;
next	1.17;

1.17
date	98.03.01.14.56.46;	author niklas;	state Exp;
branches
	1.17.10.1;
next	1.16;

1.16
date	97.10.07.22.52.05;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	97.09.19.17.16.14;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	97.09.18.13.39.37;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	97.04.10.08.51.04;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.02.21.08.51.49;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.02.03.11.38.10;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.01.19.13.53.12;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.01.18.12.42.02;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.01.16.09.23.30;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.11.28.23.33.03;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.06.07.05.18.40;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.05.29.10.14.38;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.05.02.06.43.24;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.01.12.16.45.03;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.03.53.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.53;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.53;	author deraadt;	state Exp;
branches;
next	;

1.17.10.1
date	2001.04.18.16.02.00;	author niklas;	state Exp;
branches;
next	1.17.10.2;

1.17.10.2
date	2001.07.04.10.15.02;	author niklas;	state Exp;
branches;
next	1.17.10.3;

1.17.10.3
date	2001.10.31.02.52.45;	author nate;	state Exp;
branches;
next	1.17.10.4;

1.17.10.4
date	2001.11.13.21.00.50;	author niklas;	state Exp;
branches;
next	1.17.10.5;

1.17.10.5
date	2001.12.05.00.39.09;	author niklas;	state Exp;
branches;
next	1.17.10.6;

1.17.10.6
date	2002.03.06.00.56.18;	author niklas;	state Exp;
branches;
next	1.17.10.7;

1.17.10.7
date	2002.03.28.10.06.14;	author niklas;	state Exp;
branches;
next	1.17.10.8;

1.17.10.8
date	2003.03.27.23.19.17;	author niklas;	state dead;
branches;
next	;

1.29.2.1
date	2002.01.31.22.55.06;	author niklas;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2002.06.11.03.34.57;	author art;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2003.05.19.21.49.38;	author tedu;	state dead;
branches;
next	;


desc
@@


1.34
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: trap.c,v 1.33 2002/05/16 21:11:13 miod Exp $	*/
/*	$NetBSD: trap.c,v 1.56 1997/07/16 00:01:47 is Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: trap.c 1.32 91/04/06$
 *
 *	@@(#)trap.c	7.15 (Berkeley) 8/2/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/acct.h>
#include <sys/kernel.h>
#include <sys/signalvar.h>
#include <sys/resourcevar.h>
#include <sys/syslog.h>
#include <sys/syscall.h>
#ifdef KTRACE
#include <sys/ktrace.h>
#endif

#include <sys/user.h>

#include "systrace.h"
#include <dev/systrace.h>

#include <uvm/uvm_extern.h>
#include <uvm/uvm_pmap.h>

#include <machine/psl.h>
#include <machine/trap.h>
#include <machine/cpu.h>
#include <machine/reg.h>
#include <machine/mtpr.h>
#include <machine/pte.h>

#include <m68k/fpe/fpu_emulate.h>

#ifdef COMPAT_SUNOS
#include <compat/sunos/sunos_syscall.h>
extern struct emul emul_sunos;
#endif

/*
 * XXX Hack until I can figure out what to do about this code's removal
 * from m68k/include/frame.h
 */

/* 68040 fault frame */
#define SSW_CP		0x8000		/* Continuation - Floating-Point Post*/
#define SSW_CU		0x4000		/* Continuation - Unimpl. FP */
#define SSW_CT		0x2000		/* Continuation - Trace */
#define SSW_CM		0x1000		/* Continuation - MOVEM */
#define SSW_MA		0x0800		/* Misaligned access */
#define SSW_ATC		0x0400		/* ATC fault */
#define SSW_LK		0x0200		/* Locked transfer */
#define SSW_RW040	0x0100		/* Read/Write */
#define SSW_SZMASK	0x0060		/* Transfer size */
#define SSW_TTMASK	0x0018		/* Transfer type */
#define SSW_TMMASK	0x0007		/* Transfer modifier */

#define WBS_TMMASK	0x0007
#define WBS_TTMASK	0x0018
#define WBS_SZMASK	0x0060
#define WBS_VALID	0x0080

#define WBS_SIZE_BYTE	0x0020
#define WBS_SIZE_WORD	0x0040
#define WBS_SIZE_LONG	0x0000
#define WBS_SIZE_LINE	0x0060

#define WBS_TT_NORMAL	0x0000
#define WBS_TT_MOVE16	0x0008
#define WBS_TT_ALTFC	0x0010
#define WBS_TT_ACK	0x0018

#define WBS_TM_PUSH	0x0000
#define WBS_TM_UDATA	0x0001
#define WBS_TM_UCODE	0x0002
#define WBS_TM_MMUTD	0x0003
#define WBS_TM_MMUTC	0x0004
#define WBS_TM_SDATA	0x0005
#define WBS_TM_SCODE	0x0006
#define WBS_TM_RESV	0x0007

#define	MMUSR_PA_MASK	0xfffff000
#define MMUSR_B		0x00000800
#define MMUSR_G		0x00000400
#define MMUSR_U1	0x00000200
#define MMUSR_U0	0x00000100
#define MMUSR_S		0x00000080
#define MMUSR_CM	0x00000060
#define MMUSR_M		0x00000010
#define MMUSR_0		0x00000008
#define MMUSR_W		0x00000004
#define MMUSR_T		0x00000002
#define MMUSR_R		0x00000001

#define FSLW_STRING	"\020\1SEE\3BPE\4TTR\5WE\6RE\7TWE\010WP\011SP" \
			"\012PF\013IL\014PTB\015PTA\016SBE\017PBE"
/*
 * XXX End hack
 */
char	*trap_type[] = {
	"Bus error",
	"Address error",
	"Illegal instruction",
	"Zero divide",
	"CHK instruction",
	"TRAPV instruction",
	"Privilege violation",
	"Trace trap",
	"MMU fault",
	"SSIR trap",
	"Format error",
	"68881 exception",
	"Coprocessor violation",
	"Async system trap"
};
int	trap_types = sizeof trap_type / sizeof trap_type[0];

/*
 * Size of various exception stack frames (minus the standard 8 bytes)
 */
short	exframesize[] = {
	FMT0SIZE,	/* type 0 - normal (68020/030/040/060) */
	FMT1SIZE,	/* type 1 - throwaway (68020/030/040) */
	FMT2SIZE,	/* type 2 - normal 6-word (68020/030/040/060) */
	FMT3SIZE,	/* type 3 - FP post-instruction (68040/060) */
	FMT4SIZE,	/* type 4 - access error/fp disabled (68060) */
	-1, -1,		/* type 5-6 - undefined */
	FMT7SIZE,	/* type 7 - access error (68040) */
	58,		/* type 8 - bus fault (68010) */
	FMT9SIZE,	/* type 9 - coprocessor mid-instruction (68020/030) */
	FMTASIZE,	/* type A - short bus fault (68020/030) */
	FMTBSIZE,	/* type B - long bus fault (68020/030) */
	-1, -1, -1, -1	/* type C-F - undefined */
};

#ifdef DEBUG
int mmudebug = 0;
#endif

extern struct pcb *curpcb;
extern char fubail[], subail[];

/* XXX until we get it from m68k/cpu.h */
extern void    regdump(struct trapframe *, int);

int	_write_back(u_int, u_int, u_int, u_int, struct vm_map *);
void	panictrap(int, u_int, u_int, struct frame *);
void	trapcpfault(struct proc *, struct frame *);
void	trapmmufault(int, u_int, u_int, struct frame *, struct proc *,
    u_quad_t);
void	trap(int, u_int, u_int, struct frame);
#ifdef DDB
#include <m68k/db_machdep.h>
int	db_trap(int, db_regs_t *);
#endif
void	syscall(register_t, struct frame);
void	_wb_fault(void);

/*ARGSUSED*/
void
userret(p, fp, oticks, faultaddr, fromtrap)
	struct proc *p;
	struct frame *fp;
	u_quad_t oticks;
	u_int faultaddr;
	int fromtrap;
{
	int sig;

	while ((sig = CURSIG(p)) != 0)
		postsig(sig);

	p->p_priority = p->p_usrpri;

	if (want_resched) {
		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}
	/*
	 * If profiling, charge recent system time.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;
		
		addupc_task(p, fp->f_pc, (int)(p->p_sticks - oticks) * psratio);
	}
	curpriority = p->p_priority;
}

void
panictrap(type, code, v, fp)
	int type;
	u_int code, v;
	struct frame *fp;
{
	static int panicing = 0;
	if (panicing++ == 0) {
		printf("trap type %d, code = %x, v = %x\n", type, code, v);
		regdump((struct trapframe *)fp, 128);
	}
	type &= ~T_USER;
#ifdef DEBUG
	DCIS(); 		/* XXX? push cache */
#endif
	if ((u_int)type < trap_types)
		panic(trap_type[type]);
	panic("trap");
	/*NOTREACHED*/
}

/*
 * return to fault handler
 */
void
trapcpfault(p, fp)
	struct proc *p;
	struct frame *fp;
{
	/*
	 * We have arranged to catch this fault in one of the
	 * copy to/from user space routines, set PC to return to
	 * indicated location and set flag informing buserror code
	 * that it may need to clean up stack frame.
	 */
	fp->f_stackadj = exframesize[fp->f_format];
	fp->f_format = fp->f_vector = 0;
	fp->f_pc = (int) p->p_addr->u_pcb.pcb_onfault;
}

int donomore = 0;

void 
trapmmufault(type, code, v, fp, p, sticks)
	int type;
	u_int code, v;
	struct frame *fp;
	struct proc *p;
	u_quad_t sticks;
{
#if defined(DEBUG) && defined(M68060)
	static u_int oldcode=0, oldv=0;
	static struct proc *oldp=0;
#endif
	extern struct vm_map *kernel_map;
	struct vmspace *vm = NULL;
	vm_prot_t ftype, vftype;
	vm_offset_t va;
	struct vm_map *map;
	u_int nss;
	int rv;
	union sigval sv;

	/*
	 * It is only a kernel address space fault iff:
	 * 	1. (type & T_USER) == 0  and
	 * 	2. pcb_onfault not set or
	 *	3. pcb_onfault set but supervisor space data fault
	 * The last can occur during an exec() copyin where the
	 * argument space is lazy-allocated.
	 */
#ifdef DEBUG
	/*
	 * Print out some data about the fault
	 */
#ifdef DEBUG_PAGE0
	if (v < NBPG)					/* XXX PAGE0 */
		mmudebug |= 0x100;			/* XXX PAGE0 */
#endif
	if (mmudebug && mmutype <= MMU_68040) {
#ifdef M68060
		if (mmutype == MMU_68060) {
			if (--donomore == 0 || mmudebug & 1)
				printf ("68060 access error: pc %x, code %b,"
				     " ea %x\n", fp->f_pc, 
				     code, FSLW_STRING, v);
			if (p == oldp && v == oldv && code == oldcode)
				panic("Identical fault backtoback!");
			if (donomore == 0) 
				panic("Tired of faulting.");
			oldp = p;
			oldv = v;
			oldcode = code;
		} else
#endif
		printf("68040 access error: pc %x, code %x,"
		    " ea %x, fa %x\n", fp->f_pc, code, fp->f_fmt7.f_ea, v);
		if (curpcb)
			printf(" curpcb %p\n", curpcb);
				

#ifdef DDB						/* XXX PAGE0 */
		if (v < NBPG)				/* XXX PAGE0 */
			Debugger();			/* XXX PAGE0 */
#endif							/* XXX PAGE0 */
	}
#ifdef DEBUG_PAGE0
	mmudebug &= ~0x100;				/* XXX PAGE0 */
#endif
#endif

	if (p)
		vm = p->p_vmspace;

	if (type == T_MMUFLT && 
	    (!p || !p->p_addr || p->p_addr->u_pcb.pcb_onfault == 0 || (
#ifdef M68060
	     mmutype == MMU_68060 ? code & FSLW_TM_SV :
#endif
	     mmutype == MMU_68040 ? (code & SSW_TMMASK) == FC_SUPERD :
	     (code & (SSW_DF|FC_SUPERD)) == (SSW_DF|FC_SUPERD))))
		map = kernel_map;
	else
		map = &vm->vm_map;

	if (
#ifdef M68060
	    mmutype == MMU_68060 ? code & FSLW_RW_W :
#endif
	    mmutype == MMU_68040 ? (code & SSW_RW040) == 0 :
	    (code & (SSW_DF|SSW_RW)) == SSW_DF) {	/* what about RMW? */
		vftype = VM_PROT_WRITE;
		ftype = VM_PROT_READ | VM_PROT_WRITE;
	} else
		vftype = ftype = VM_PROT_READ;
	va = trunc_page((vm_offset_t)v);
#ifdef DEBUG
	if (map == kernel_map && va == 0) {
		printf("trap: bad kernel access at %x pc %x\n", v, fp->f_pc);
		panictrap(type, code, v, fp);
	}
#endif
#ifndef no_386bsd_code
	/*
	 * XXX: rude hack to make stack limits "work"
	 */
	nss = 0;
	if (map != kernel_map && (caddr_t)va >= vm->vm_maxsaddr) {
		nss = btoc(USRSTACK - (unsigned)va);
		if (nss > btoc(p->p_rlimit[RLIMIT_STACK].rlim_cur)) {
			rv = EFAULT;
			goto nogo;
		}
	}
#endif

#ifdef DEBUG
	if (mmudebug)
		printf("vm_fault(%p,%lx,%d,0)\n", map, va, ftype);
#endif

	rv = uvm_fault(map, va, 0, ftype);

#ifdef DEBUG
	if (mmudebug)
		printf("vmfault %s %lx returned %d\n",
		    map == kernel_map ? "kernel" : "user", va, rv);
#endif
	if (mmutype == MMU_68040) {	/* explicitely NOT MMU_68060 */
		if (rv) {
			goto nogo;
		}

		/*	
		 * The 68040 doesn't re-run instructions that cause
		 * write page faults (unless due to a move16 isntruction).
		 * So once the page is repaired, we have to write the
		 * value of WB2D out to memory ourselves.  Because
		 * the writeback could possibly span two pages in
		 * memory, so we need to check both "ends" of the
		 * address to see if they are in the same page or not.
		 * If not, then we need to make sure the second page
		 * is valid, and bring it into memory if it's not.
		 * 	
		 * This whole process needs to be repeated for WB3 as well.
		 * <sigh>
		 */	

		/* Check WB1 */
		if (fp->f_fmt7.f_wb1s & WBS_VALID) {
			printf ("trap: wb1 was valid, not handled yet\n");
			panictrap(type, code, v, fp);
		}

		/*
		 * Check WB2
		 * skip if it's for a move16 instruction 
		 */
		if (fp->f_fmt7.f_wb2s & WBS_VALID &&
		   ((fp->f_fmt7.f_wb2s & WBS_TTMASK)==WBS_TT_MOVE16) == 0) {
			if (_write_back(2, fp->f_fmt7.f_wb2s, 
			    fp->f_fmt7.f_wb2d, fp->f_fmt7.f_wb2a, map))
				goto nogo;
			if ((fp->f_fmt7.f_wb2s & WBS_TMMASK) 
			    != (code & SSW_TMMASK))
				panictrap(type, code, v, fp);
		}

		/* Check WB3 */
		if(fp->f_fmt7.f_wb3s & WBS_VALID) {
			struct vm_map *wb3_map;

			if ((fp->f_fmt7.f_wb3s & WBS_TMMASK) == WBS_TM_SDATA)
				wb3_map = kernel_map;
			else
				wb3_map = &vm->vm_map;
			if (_write_back(3, fp->f_fmt7.f_wb3s, 
			    fp->f_fmt7.f_wb3d, fp->f_fmt7.f_wb3a, wb3_map))
				goto nogo;
		}
	}

#ifdef no_386bsd_code
	/*
	 * If this was a stack access we keep track of the maximum
	 * accessed stack size.  Also, if vm_fault gets a protection
	 * failure it is due to accessing the stack region outside
	 * the current limit and we need to reflect that as an access
	 * error.
	 */
	if (map != kernel_map && (caddr_t)va >= vm->vm_maxsaddr) {
		if (rv == 0) {
			nss = btoc(USRSTACK-(unsigned)va);
			if (nss > vm->vm_ssize)
				vm->vm_ssize = nss;
		} else if (rv == EACCES)
			rv = EFAULT;
	}

	if (rv == 0) {
		if (type == T_MMUFLT)
			return;
		userret(p, fp, sticks, 0, 0); 
		return;
	}
#else /* use hacky 386bsd_code */
	if (rv == 0) {
		/*
		 * XXX: continuation of rude stack hack
		 */
		if (nss > vm->vm_ssize)
			vm->vm_ssize = nss;
		if (type == T_MMUFLT)
			return;
		userret(p, fp, sticks, 0, 0); 
		return;
	}
nogo:
#endif
	if (type == T_MMUFLT) {
		if (p && p->p_addr && p->p_addr->u_pcb.pcb_onfault) {
			trapcpfault(p, fp);
			return;
		}
		printf("vm_fault(%p, %lx, %x, 0) -> %x\n", map, va, ftype, rv);
		printf("  type %x, code [mmu,,ssw]: %x\n", type, code);
		panictrap(type, code, v, fp);
	}
	sv.sival_int = v;
	trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, sv);
	if ((type & T_USER) == 0)
		return;
	userret(p, fp, sticks, 0, 0); 
}

/*
 * Trap is called from locore to handle most types of processor traps,
 * including events such as simulated software interrupts/AST's.
 * System calls are broken out for efficiency.
 */
/*ARGSUSED*/
void
trap(type, code, v, frame)
	int type;
	u_int code, v;
	struct frame frame;
{
	struct proc *p;
	u_int ucode;
	u_quad_t sticks = 0;
	int typ, i;
	union sigval sv;
#ifdef COMPAT_SUNOS
	extern struct emul emul_sunos;
#endif

	p = curproc;
	typ = ucode = 0;
	uvmexp.traps++;

	if (USERMODE(frame.f_sr)) {
		type |= T_USER;
		sticks = p->p_sticks;
		p->p_md.md_regs = frame.f_regs;
	}

#ifdef DDB
	if (type == T_TRACE || type == T_BREAKPOINT) {
		if (kdb_trap(type, (db_regs_t *)&frame))
			return;
	}
#endif
#ifdef DEBUG
	if (mmudebug & 2)
		printf("trap: t %x c %x v %x pad %x adj %x sr %x pc %x fmt %x "
		    "vc %x\n", type, code, v, frame.f_pad, frame.f_stackadj,
		    frame.f_sr, frame.f_pc, frame.f_format, frame.f_vector);
#endif
	switch (type) {
	default:
		panictrap(type, code, v, &frame);

	/*
	 * Kernel Bus error
	 */
	case T_BUSERR:
		if (!p || !p->p_addr || !p->p_addr->u_pcb.pcb_onfault)
			panictrap(type, code, v, &frame);
		trapcpfault(p, &frame);
		return;

	/*
	 * User Bus/Addr error.
	 */
	case T_BUSERR|T_USER:
		ucode = code & ~T_USER;
		typ = BUS_OBJERR;
		i = SIGBUS;
		break;

	case T_ADDRERR|T_USER:
		ucode = code & ~T_USER;
		typ = BUS_ADRALN;
		i = SIGBUS;
		break;

	/*
	 * User illegal/privleged inst fault
	 */
	case T_ILLINST|T_USER:
		ucode = frame.f_format;	/* XXX was ILL_PRIVIN_FAULT */
		typ = ILL_ILLOPC;
		i = SIGILL;
		v = frame.f_pc;
		break;

	case T_PRIVINST|T_USER:
		ucode = frame.f_format;	/* XXX was ILL_PRIVIN_FAULT */
		typ = ILL_PRVOPC;
		i = SIGILL;
		v = frame.f_pc;
		break;

	/*
	 * divde by zero, CHK/TRAPV inst 
	 */
	case T_ZERODIV|T_USER:
		ucode = frame.f_format;
		typ = FPE_INTDIV;
		i = SIGFPE;
		v = frame.f_pc;
		break;

	case T_CHKINST|T_USER:
		ucode = frame.f_format;
		typ = FPE_FLTSUB;
		i = SIGFPE;
		v = frame.f_pc;
		break;

  
	case T_FPEMULI|T_USER:
	case T_FPEMULD|T_USER:
#ifdef FPU_EMULATE
		i = fpu_emulate(&frame, &p->p_addr->u_pcb.pcb_fpregs);
		/* XXX - Deal with tracing? (frame.f_sr & PSL_T) */
		if (i == 0)
			break;		
#else
		printf("pid %d killed: no floating point support\n", p->p_pid);
		i = SIGILL;
#endif
		typ = ILL_ILLTRP;
		v = frame.f_pc;
		break;

	case T_TRAPVINST|T_USER:
		ucode = frame.f_format;
		typ = ILL_ILLTRP;
		i = SIGILL;
		v = frame.f_pc;
		break;

	/* 
	 * User coprocessor violation
	 */
	case T_COPERR|T_USER:
		ucode = 0;
		typ = FPE_FLTINV;
		i = SIGFPE;	/* XXX What is a proper response here? */
		v = frame.f_pc;
		break;

	/* 
	 * 6888x exceptions 
	 */
	case T_FPERR|T_USER:
		/*
		 * We pass along the 68881 status register which locore
		 * stashed in code for us.  Note that there is a
		 * possibility that the bit pattern of this register
		 * will conflict with one of the FPE_* codes defined
		 * in signal.h.  Fortunately for us, the only such
		 * codes we use are all in the range 1-7 and the low
		 * 3 bits of the status register are defined as 0 so
		 * there is no clash.
		 */
		ucode = code;
		typ = FPE_FLTRES;
		i = SIGFPE;
		v = frame.f_pc;
		break;

	/* 
	 * Kernel coprocessor violation
	 */
	case T_COPERR:
		/*FALLTHROUGH*/

	/*
	 * Kernel format error
	 */
	case T_FMTERR:
		/*
		 * The user has most likely trashed the RTE or FP state info
		 * in the stack frame of a signal handler.
		 */
		type |= T_USER;
#ifdef DEBUG
		printf("pid %d: kernel %s exception\n", p->p_pid,
		    type==T_COPERR ? "coprocessor" : "format");
#endif
		p->p_sigacts->ps_sigact[SIGILL] = SIG_DFL;
		i = sigmask(SIGILL);
		p->p_sigignore &= ~i;
		p->p_sigcatch &= ~i;
		p->p_sigmask &= ~i;
		typ = ILL_COPROC;
		i = SIGILL;
		v = frame.f_pc;
		ucode = frame.f_format;	/* XXX was ILL_RESAD_FAULT */
		break;

	/*
	 * Trace traps.
	 *
	 * M68k NetBSD uses trap #2,
	 * SUN 3.x uses trap #15,
	 * KGDB uses trap #15 (for kernel breakpoints; handled elsewhere).
	 *
	 * Amiga traps get mapped by locore.s into T_TRACE.
	 * SUN 3.x traps get passed through as T_TRAP15 and are not really
	 * supported yet.
	 */
	case T_TRACE:
	case T_TRAP15:
		frame.f_sr &= ~PSL_T;
		typ = TRAP_TRACE;
		i = SIGTRAP;
		break;

	case T_TRACE|T_USER:
	case T_TRAP15|T_USER:
#ifdef COMPAT_SUNOS
		/*
		 * SunOS uses Trap #2 for a "CPU cache flush".
		 * Just flush the on-chip caches and return.
		 */
		if (p->p_emul == &emul_sunos) {
			ICIA();
			DCIU();
			return;
		}
#endif
		frame.f_sr &= ~PSL_T;
		typ = TRAP_TRACE;
		i = SIGTRAP;
		break;

	/* 
	 * Kernel AST (should not happen)
	 */
	case T_ASTFLT:
		panictrap(type, code, v, &frame);

	/*
	 * User AST
	 */
	case T_ASTFLT|T_USER:
		astpending = 0;
		spl0();
		if (p->p_flag & P_OWEUPC) {
			p->p_flag &= ~P_OWEUPC;
			ADDUPROF(p);
		}
		userret(p, &frame, sticks, 0, 0); 
		return;

	/*
	 * Kernel/User page fault
	 */
	case T_MMUFLT:
		if (p && p->p_addr &&
		    (p->p_addr->u_pcb.pcb_onfault == (caddr_t)fubail ||
		    p->p_addr->u_pcb.pcb_onfault == (caddr_t)subail)) {
			trapcpfault(p, &frame);
			return;
		}
		/*FALLTHROUGH*/

	case T_MMUFLT|T_USER:	/* page fault */
		trapmmufault(type, code, v, &frame, p, sticks);
		return;
	}

#ifdef DEBUG
	if (i != SIGTRAP)
		printf("trapsignal(%d, %d, %d, %x, %x)\n", p->p_pid, i,
		    ucode, v, frame.f_pc);
#endif
	if (i) {
		sv.sival_int = ucode;
		trapsignal(p, i, ucode, typ, sv);
	}
	if ((type & T_USER) == 0)
		return;
	userret(p, &frame, sticks, 0, 0); 
}

/*
 * Process a system call.
 */
void
syscall(code, frame)
	register_t code;
	struct frame frame;
{
	register caddr_t params;
	register struct sysent *callp;
	register struct proc *p;
	int error, opc, nsys;
	size_t argsize;
	register_t args[8], rval[2];
	u_quad_t sticks;
#ifdef COMPAT_SUNOS
	extern struct emul emul_sunos;
#endif

	uvmexp.syscalls++;
	if (!USERMODE(frame.f_sr))
		panic("syscall");
	p = curproc;
	sticks = p->p_sticks;
	p->p_md.md_regs = frame.f_regs;
	opc = frame.f_pc;

	nsys = p->p_emul->e_nsysent;
	callp = p->p_emul->e_sysent;
#ifdef COMPAT_SUNOS
	if (p->p_emul == &emul_sunos) {

		/*
		 * SunOS passes the syscall-number on the stack, whereas
		 * BSD passes it in D0. So, we have to get the real "code"
		 * from the stack, and clean up the stack, as SunOS glue
		 * code assumes the kernel pops the syscall argument the
		 * glue pushed on the stack. Sigh...
		 */
		code = fuword((caddr_t)frame.f_regs[SP]);

		/*
		 * XXX
		 * Don't do this for sunos_sigreturn, as there's no stored pc
		 * on the stack to skip, the argument follows the syscall
		 * number without a gap.
		 */
		if (code != SUNOS_SYS_sigreturn) {
			frame.f_regs[SP] += sizeof (int);
			/*
			 * remember that we adjusted the SP, 
			 * might have to undo this if the system call
			 * returns ERESTART.
			 */
			p->p_md.md_flags |= MDP_STACKADJ;
		} else
			p->p_md.md_flags &= ~MDP_STACKADJ;
	}
#endif

	params = (caddr_t)frame.f_regs[SP] + sizeof(int);

	switch (code) {
	case SYS_syscall:
		/*
		 * Code is first argument, followed by actual args.
		 */
		code = fuword(params);
		params += sizeof(int);
		/*
		 * XXX sigreturn requires special stack manipulation
		 * that is only done if entered via the sigreturn
		 * trap.  Cannot allow it here so make sure we fail.
		 */
		if (code == SYS_sigreturn)
			code = nsys;
		break;

	case SYS___syscall:
		/*
		 * Like syscall, but code is a quad, so as to maintain
		 * quad alignment for the rest of the arguments.
		 */
		if (callp != sysent)
			break;
		code = fuword(params + _QUAD_LOWWORD * sizeof(int));
		params += sizeof(quad_t);
		break;

	default:
		break;
	}
	if (code < 0 || code >= nsys)
		callp += p->p_emul->e_nosys;		/* illegal */
	else
		callp += code;
	argsize = callp->sy_argsize;
	if (argsize)
		error = copyin(params, (caddr_t)args, argsize);
	else
		error = 0;
#ifdef SYSCALL_DEBUG
	scdebug_call(p, code, args);
#endif
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL))
		ktrsyscall(p, code, argsize, args);
#endif
	if (error)
		goto bad;
	rval[0] = 0;
	rval[1] = frame.f_regs[D1];
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
	switch (error) {
	case 0:
		/*
		 * Reinitialize proc pointer `p' as it may be different
		 * if this is a child returning from fork syscall.
		 */
		p = curproc;
		frame.f_regs[D0] = rval[0];
		frame.f_regs[D1] = rval[1];
		frame.f_sr &= ~PSL_C;	/* carry bit */
		break;

	case ERESTART:
		/*
		 * We always enter through a `trap' instruction, which is 2
		 * bytes, so adjust the pc by that amount.
		 */
		frame.f_pc = opc - 2;
		break;

	case EJUSTRETURN:
		/* nothing to do */
		break;

	default:
	bad:
		frame.f_regs[D0] = error;
		frame.f_sr |= PSL_C;	/* carry bit */
		break;	
	}

#ifdef SYSCALL_DEBUG
	scdebug_ret(p, code, error, rval);
#endif
#ifdef COMPAT_SUNOS
	/* need new p-value for this */
	if (error == ERESTART && (p->p_md.md_flags & MDP_STACKADJ))
		frame.f_regs[SP] -= sizeof (int);
#endif
	userret(p, &frame, sticks, 0, 0);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, code, error, rval[0]);
#endif
}

/*
 * Process a pending write back
 */
int
_write_back (wb, wb_sts, wb_data, wb_addr, wb_map)
	u_int wb;	/* writeback type: 1, 2, or 3 */
	u_int wb_sts;	/* writeback status information */
	u_int wb_data;	/* data to writeback */
	u_int wb_addr;	/* address to writeback to */
	struct vm_map *wb_map;
{
	u_int wb_extra_page = 0;
	u_int wb_rc, mmusr;
	caddr_t oonfault = curpcb->pcb_onfault;
	int rv = 0;

	/* A fault in here must *not* go to the registered fault handler.  */
	curpcb->pcb_onfault = NULL;

#ifdef DEBUG
	if (mmudebug)
		printf("wb%d valid: %x %x %x\n", wb, wb_sts, wb_addr, wb_data);
#endif

	/* See if we're going to span two pages (for word or long transfers) */
	if ((wb_sts & WBS_SZMASK) == WBS_SIZE_WORD)
		if (trunc_page((vm_offset_t)wb_addr) !=
		    trunc_page((vm_offset_t)wb_addr + 1))
			wb_extra_page = 1;

	if ((wb_sts & WBS_SZMASK) == WBS_SIZE_LONG)
		if (trunc_page((vm_offset_t)wb_addr) !=
		    trunc_page((vm_offset_t)wb_addr + 3))
			wb_extra_page = 3;

	/*
	 * if it's writeback 3, we need to check the first page
	 */
	if (wb == 3) {
		mmusr = probeva(wb_addr, wb_sts & WBS_TMMASK);
#ifdef DEBUG
	if (mmudebug)
		printf("wb3: probeva(%x,%x) = %x\n",
		    wb_addr + wb_extra_page, wb_sts & WBS_TMMASK, mmusr);
#endif

		if ((mmusr & (MMUSR_R | MMUSR_W)) != MMUSR_R) {
#ifdef DEBUG
			if (mmudebug)
				printf("wb3: need to bring in first page\n");
#endif
			wb_rc = uvm_fault(wb_map, 
			    trunc_page((vm_offset_t)wb_addr), 
			    0, VM_PROT_READ | VM_PROT_WRITE);

			if (wb_rc) {
				rv = wb_rc;
				goto out;
			}
#ifdef DEBUG
			if (mmudebug)
				printf("wb3: first page brought in.\n");
#endif
		}
	}

	/*
	 * now check to see if a second page is required
	 */
	if(wb_extra_page) {

		mmusr = probeva(wb_addr+wb_extra_page, wb_sts & WBS_TMMASK);
#ifdef DEBUG
		if (mmudebug)
			printf("wb%d: probeva %x %x = %x\n",
			    wb, wb_addr + wb_extra_page, 
			    wb_sts & WBS_TMMASK,mmusr);
#endif

		if((mmusr & (MMUSR_R | MMUSR_W)) != MMUSR_R) {
#ifdef DEBUG
			if (mmudebug)
				printf("wb%d: page boundary crossed."
				    "  Bringing in extra page.\n", wb);
#endif

			wb_rc = uvm_fault(wb_map,
			    trunc_page((vm_offset_t)wb_addr + wb_extra_page),
			    0, VM_PROT_READ | VM_PROT_WRITE);
			if (wb_rc) {
				rv = wb_rc;
				goto out;
			}
		}
#ifdef DEBUG
		if (mmudebug)
			printf("wb%d: extra page brought in okay.\n", wb);
#endif
	}

	/* Actually do the write now */
	if ((wb_sts & WBS_TMMASK) == FC_USERD && oonfault != NULL)
		__asm volatile("movl #Lwberr,%0@@" : :
		     "a" (&curpcb->pcb_onfault));

	switch(wb_sts & WBS_SZMASK) {
	case WBS_SIZE_BYTE :
		__asm volatile("movec %0,dfc ; movesb %1,%2@@" : :
		    "d" (wb_sts & WBS_TMMASK), "d" (wb_data), "a" (wb_addr));
		break;

	case WBS_SIZE_WORD :
		__asm volatile("movec %0,dfc ; movesw %1,%2@@" : :
		    "d" (wb_sts & WBS_TMMASK), "d" (wb_data), "a" (wb_addr));
		break;

	case WBS_SIZE_LONG :
		__asm volatile("movec %0,dfc ; movesl %1,%2@@" : :
		    "d" (wb_sts & WBS_TMMASK), "d" (wb_data), "a" (wb_addr));
		break;

	default:
		/*
		 * This is trickery, we need this assembly somewhere out
		 * of the default execution path, but still not detectable as
		 * dead code that the compiler can throw away erroneously.
		 */
		__asm volatile("Lwberr: addql #1,%0" : "=d" (rv));
	}
	curpcb->pcb_onfault = NULL;
	if ((wb_sts & WBS_TMMASK) != FC_USERD)
		__asm volatile("movec %0,dfc\n" : : "d" (FC_USERD));

 out:
	curpcb->pcb_onfault = oonfault;
	return (rv);
}
@


1.33
log
@Add systrace support to all the remaining architectures.

Tested by various people on various platforms, I'm willing to fix any
breakage this causes.

ok niels@@ deraadt@@ and mickey@@ (after his comments were applied)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2002/03/25 18:09:13 niklas Exp $	*/
@


1.32
log
@I could have sworn I commited this, must have gone local
and later overwritten at my repos sync, sigh.  Do not treat pcb_onfault as
a procedure, it is a continuation point, thus necessarily needs to be at
ther same stack depth as the region covered by the onfault handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31 2002/03/14 01:26:28 millert Exp $	*/
d60 4
d896 6
a901 1
	error = (*callp->sy_call)(p, args, rval);
@


1.31
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 2001/12/22 21:25:59 miod Exp $	*/
d952 5
d994 4
a997 2
			if (wb_rc)
				return (wb_rc);
d1028 4
a1031 2
			if (wb_rc)
				return (wb_rc);
d1040 3
a1042 2
	if ((wb_sts & WBS_TMMASK) == FC_USERD && !curpcb->pcb_onfault)
	    	curpcb->pcb_onfault = (caddr_t)_wb_fault;
d1060 7
d1068 1
a1068 2
	if (curpcb->pcb_onfault == (caddr_t)_wb_fault)
		curpcb->pcb_onfault = NULL;
a1070 2
	return (0);
}
d1072 3
a1074 10
/*
 * fault handler for write back
 */
void
_wb_fault()
{
#ifdef DEBUG
	printf ("trap: writeback fault\n");
#endif
	return;
@


1.30
log
@Compile with option DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29 2001/11/30 22:08:13 miod Exp $	*/
d181 1
a181 1
extern void    regdump __P((struct trapframe *, int));
d183 6
a188 6
int	_write_back __P((u_int, u_int, u_int, u_int, struct vm_map *));
void	panictrap __P((int, u_int, u_int, struct frame *));
void	trapcpfault __P((struct proc *, struct frame *));
void	trapmmufault __P((int, u_int, u_int, struct frame *, struct proc *,
    u_quad_t));
void	trap __P((int, u_int, u_int, struct frame));
d191 1
a191 1
int	db_trap __P((int, db_regs_t *));
d193 2
a194 2
void	syscall __P((register_t, struct frame));
void	_wb_fault __P((void));
@


1.29
log
@Make it possible for mmutype to contain MMU_68060 if the hardware is
actually '060-based, instead to look at the machineid.
This is simpler, and will be required to switch to pmap_motorola anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 2001/11/28 16:13:27 art Exp $	*/
d329 1
a329 3
			printf(" curpcb %p ->pcb_ustp %x / %x\n",
			    curpcb, curpcb->pcb_ustp, 
			    curpcb->pcb_ustp << PG_SHIFT);
@


1.29.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 2001/12/22 21:25:59 miod Exp $	*/
d329 3
a331 1
			printf(" curpcb %p\n", curpcb);
@


1.29.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29.2.1 2002/01/31 22:55:06 niklas Exp $	*/
a59 4

#include "systrace.h"
#include <dev/systrace.h>

d181 1
a181 1
extern void    regdump(struct trapframe *, int);
d183 6
a188 6
int	_write_back(u_int, u_int, u_int, u_int, struct vm_map *);
void	panictrap(int, u_int, u_int, struct frame *);
void	trapcpfault(struct proc *, struct frame *);
void	trapmmufault(int, u_int, u_int, struct frame *, struct proc *,
    u_quad_t);
void	trap(int, u_int, u_int, struct frame);
d191 1
a191 1
int	db_trap(int, db_regs_t *);
d193 2
a194 2
void	syscall(register_t, struct frame);
void	_wb_fault(void);
d892 1
a892 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		error = systrace_redirect(code, p, args, rval);
	else
#endif
		error = (*callp->sy_call)(p, args, rval);
a951 5
	caddr_t oonfault = curpcb->pcb_onfault;
	int rv = 0;

	/* A fault in here must *not* go to the registered fault handler.  */
	curpcb->pcb_onfault = NULL;
d989 2
a990 4
			if (wb_rc) {
				rv = wb_rc;
				goto out;
			}
d1021 2
a1022 4
			if (wb_rc) {
				rv = wb_rc;
				goto out;
			}
d1031 2
a1032 3
	if ((wb_sts & WBS_TMMASK) == FC_USERD && oonfault != NULL)
		__asm volatile("movl #Lwberr,%0@@" : :
		     "a" (&curpcb->pcb_onfault));
a1049 7
	default:
		/*
		 * This is trickery, we need this assembly somewhere out
		 * of the default execution path, but still not detectable as
		 * dead code that the compiler can throw away erroneously.
		 */
		__asm volatile("Lwberr: addql #1,%0" : "=d" (rv));
d1051 2
a1052 1
	curpcb->pcb_onfault = NULL;
d1055 2
d1058 10
a1067 3
 out:
	curpcb->pcb_onfault = oonfault;
	return (rv);
@


1.29.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29.2.2 2002/06/11 03:34:57 art Exp $	*/
@


1.28
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 2001/11/28 13:47:37 art Exp $	*/
d310 1
a310 1
	if (mmudebug && mmutype == MMU_68040) {
d312 1
a312 1
		if (machineid & AMIGA_68060) {
d350 1
a350 1
	     machineid & AMIGA_68060 ? code & FSLW_TM_SV :
d360 1
a360 1
	    machineid & AMIGA_68060 ? code & FSLW_RW_W :
d401 1
a401 5
#ifdef M68060
	if ((machineid & AMIGA_68060) == 0 && mmutype == MMU_68040) {
#else
	if (mmutype == MMU_68040) {
#endif
@


1.27
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 2001/11/25 17:21:32 miod Exp $	*/
d183 1
a183 1
int	_write_back __P((u_int, u_int, u_int, u_int, vm_map_t));
d285 1
a285 1
	extern vm_map_t kernel_map;
d289 1
a289 1
	vm_map_t map;
d447 1
a447 1
			vm_map_t wb3_map;
d954 1
a954 1
	vm_map_t wb_map;
@


1.26
log
@Oops, commited this file from the wrong tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 2001/11/06 19:53:14 miod Exp $	*/
d383 1
a383 1
			rv = KERN_FAILURE;
d406 1
a406 1
		if(rv != KERN_SUCCESS) {
d438 1
a438 2
			    fp->f_fmt7.f_wb2d, fp->f_fmt7.f_wb2a, map)
			    != KERN_SUCCESS)
d454 1
a454 2
			    fp->f_fmt7.f_wb3d, fp->f_fmt7.f_wb3a, wb3_map)
			    != KERN_SUCCESS)
d468 1
a468 1
		if (rv == KERN_SUCCESS) {
d472 2
a473 2
		} else if (rv == KERN_PROTECTION_FAILURE)
			rv = KERN_INVALID_ADDRESS;
d476 1
a476 1
	if (rv == KERN_SUCCESS) {
d483 1
a483 1
	if (rv == KERN_SUCCESS) {
d995 1
a995 1
			if (wb_rc != KERN_SUCCESS)
d1027 1
a1027 2

			if (wb_rc != KERN_SUCCESS)
d1061 1
a1061 1
	return (KERN_SUCCESS);
@


1.25
log
@Harmonize userret() prototypes across m68k arches.
XXX The userret() code is not factorized out yet, as this will require
XXX insane amiga cleaning work.
@
text
@d198 1
a198 1
userret(p, f, oticks, faultaddr, fromtrap)
d410 49
a458 2
		if (writeback(fp, 1) != 0)
			goto nogo;
@


1.24
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 2001/11/06 18:41:09 art Exp $	*/
a183 1
void	userret __P((struct proc *, int, u_quad_t));
d196 1
d198 1
a198 1
userret(p, pc, oticks)
d200 1
a200 1
	int pc;
d202 2
d226 1
a226 1
		addupc_task(p, pc, (int)(p->p_sticks - oticks) * psratio);
d410 2
a411 49
		/*	
		 * The 68040 doesn't re-run instructions that cause
		 * write page faults (unless due to a move16 isntruction).
		 * So once the page is repaired, we have to write the
		 * value of WB2D out to memory ourselves.  Because
		 * the writeback could possibly span two pages in
		 * memory, so we need to check both "ends" of the
		 * address to see if they are in the same page or not.
		 * If not, then we need to make sure the second page
		 * is valid, and bring it into memory if it's not.
		 * 	
		 * This whole process needs to be repeated for WB3 as well.
		 * <sigh>
		 */	

		/* Check WB1 */
		if (fp->f_fmt7.f_wb1s & WBS_VALID) {
			printf ("trap: wb1 was valid, not handled yet\n");
			panictrap(type, code, v, fp);
		}

		/*
		 * Check WB2
		 * skip if it's for a move16 instruction 
		 */
		if (fp->f_fmt7.f_wb2s & WBS_VALID &&
		   ((fp->f_fmt7.f_wb2s & WBS_TTMASK)==WBS_TT_MOVE16) == 0) {
			if (_write_back(2, fp->f_fmt7.f_wb2s, 
			    fp->f_fmt7.f_wb2d, fp->f_fmt7.f_wb2a, map)
			    != KERN_SUCCESS)
				goto nogo;
			if ((fp->f_fmt7.f_wb2s & WBS_TMMASK) 
			    != (code & SSW_TMMASK))
				panictrap(type, code, v, fp);
		}

		/* Check WB3 */
		if(fp->f_fmt7.f_wb3s & WBS_VALID) {
			vm_map_t wb3_map;

			if ((fp->f_fmt7.f_wb3s & WBS_TMMASK) == WBS_TM_SDATA)
				wb3_map = kernel_map;
			else
				wb3_map = &vm->vm_map;
			if (_write_back(3, fp->f_fmt7.f_wb3s, 
			    fp->f_fmt7.f_wb3d, fp->f_fmt7.f_wb3a, wb3_map)
			    != KERN_SUCCESS)
				goto nogo;
		}
d434 1
a434 1
		userret(p, fp->f_pc, sticks); 
d446 1
a446 1
		userret(p, fp->f_pc, sticks); 
d464 1
a464 1
	userret(p, fp->f_pc, sticks); 
d707 1
a707 1
		userret(p, frame.f_pc, sticks); 
d738 1
a738 1
	userret(p, frame.f_pc, sticks); 
d893 1
a893 1
	userret(p, frame.f_pc, sticks);
@


1.23
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 2001/09/13 15:35:05 art Exp $	*/
a58 1
#include <vm/vm.h>
a59 2
#include <vm/pmap.h>

d61 1
@


1.22
log
@Simplify userret.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 2001/06/27 03:54:13 art Exp $	*/
a196 1
void	child_return __P((struct proc *, struct frame));
a198 1

a943 18
#endif
}

/*
 * Process the tail end of a fork() for the child
 */
void
child_return(p, frame)
	struct proc *p;
	struct frame frame;
{
	frame.f_regs[D0] = 0;
	frame.f_sr &= ~PSL_C;	/* carry bit */

	userret(p, frame.f_pc, p->p_sticks);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, SYS_fork, 0, 0);
@


1.21
log
@No more old VM on amiga.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 2001/05/05 20:56:32 art Exp $	*/
d207 1
a207 1
	int sig, s;
d216 1
a216 6
		 * Since we are curproc, clock will normally just change
		 * our priority without moving us from one queue to another
		 * (since the running process is not on a queue.)
		 * If that happened after we setrunqueue ourselves but before
		 * we switch'ed, we might not be on the queue indicated by
		 * our priority.
d218 1
a218 5
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
@


1.20
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 2000/11/10 18:15:35 art Exp $	*/
a62 1
#if defined(UVM)
a63 1
#endif
a404 1
#if defined(UVM)
a405 3
#else
	rv = vm_fault(map, va, ftype, FALSE);
#endif
a547 1
#if defined(UVM)
a548 3
#else
	cnt.v_trap++;
#endif
a817 1
#if defined(UVM)
a818 3
#else
	cnt.v_syscall++;
#endif
a1021 1
#if defined(UVM)
a1024 5
#else
			wb_rc = vm_fault(wb_map, 
			    trunc_page((vm_offset_t)wb_addr), 
			    VM_PROT_READ | VM_PROT_WRITE, FALSE);
#endif
a1054 1
#if defined(UVM)
a1057 5
#else
			wb_rc = vm_fault(wb_map, 
			    trunc_page((vm_offset_t)wb_addr + wb_extra_page),
			    VM_PROT_READ | VM_PROT_WRITE, FALSE);
#endif
@


1.19
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 2000/05/27 21:34:36 art Exp $	*/
d394 1
a394 1
		nss = clrnd(btoc(USRSTACK - (unsigned)va));
d488 1
a488 1
			nss = clrnd(btoc(USRSTACK-(unsigned)va));
@


1.18
log
@Even more name changes for UVM.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 1998/03/01 14:56:46 niklas Exp $	*/
d919 1
a919 1
		ktrsyscall(p->p_tracep, code, argsize, args);
d968 1
a968 1
		ktrsysret(p->p_tracep, code, error, rval[0]);
d986 1
a986 1
		ktrsysret(p->p_tracep, SYS_fork, 0, 0);
@


1.17
log
@GCC 2.8 type safety
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 1997/10/07 22:52:05 niklas Exp $	*/
d63 4
d407 3
d411 1
d554 3
d558 1
d828 3
d832 1
d1036 5
d1044 1
d1075 5
d1083 1
@


1.17.10.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 2000/11/10 18:15:35 art Exp $	*/
a62 4
#if defined(UVM)
#include <uvm/uvm_extern.h>
#endif

a402 3
#if defined(UVM)
	rv = uvm_fault(map, va, 0, ftype);
#else
a403 1
#endif
a545 3
#if defined(UVM)
	uvmexp.traps++;
#else
a546 1
#endif
a815 3
#if defined(UVM)
	uvmexp.syscalls++;
#else
a816 1
#endif
d903 1
a903 1
		ktrsyscall(p, code, argsize, args);
d952 1
a952 1
		ktrsysret(p, code, error, rval[0]);
d970 1
a970 1
		ktrsysret(p, SYS_fork, 0, 0);
a1019 5
#if defined(UVM)
			wb_rc = uvm_fault(wb_map, 
			    trunc_page((vm_offset_t)wb_addr), 
			    0, VM_PROT_READ | VM_PROT_WRITE);
#else
a1022 1
#endif
a1052 5
#if defined(UVM)
			wb_rc = uvm_fault(wb_map,
			    trunc_page((vm_offset_t)wb_addr + wb_extra_page),
			    0, VM_PROT_READ | VM_PROT_WRITE);
#else
a1055 1
#endif
@


1.17.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17.10.1 2001/04/18 16:02:00 niklas Exp $	*/
d63 1
d65 1
d394 1
a394 1
		nss = btoc(USRSTACK - (unsigned)va);
d407 1
d409 3
d488 1
a488 1
			nss = btoc(USRSTACK-(unsigned)va);
d554 1
d556 3
d828 1
d830 3
d1036 1
d1040 5
d1075 1
d1079 5
@


1.17.10.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17.10.2 2001/07/04 10:15:02 niklas Exp $	*/
d207 1
a207 1
	int sig;
d216 6
a221 1
		 * We're being preempted.
d223 5
a227 1
		preempt(NULL);
@


1.17.10.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 1
d61 2
a63 1
#include <uvm/uvm_pmap.h>
d197 1
d200 1
d946 18
@


1.17.10.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17.10.4 2001/11/13 21:00:50 niklas Exp $	*/
d183 2
a184 1
int	_write_back __P((u_int, u_int, u_int, u_int, struct vm_map *));
a196 1
/*ARGSUSED*/
d198 1
a198 1
userret(p, fp, oticks, faultaddr, fromtrap)
d200 1
a200 1
	struct frame *fp;
a201 2
	u_int faultaddr;
	int fromtrap;
d224 1
a224 1
		addupc_task(p, fp->f_pc, (int)(p->p_sticks - oticks) * psratio);
d283 1
a283 1
	extern struct vm_map *kernel_map;
d287 1
a287 1
	struct vm_map *map;
d308 1
a308 1
	if (mmudebug && mmutype <= MMU_68040) {
d310 1
a310 1
		if (mmutype == MMU_68060) {
d348 1
a348 1
	     mmutype == MMU_68060 ? code & FSLW_TM_SV :
d358 1
a358 1
	    mmutype == MMU_68060 ? code & FSLW_RW_W :
d381 1
a381 1
			rv = EFAULT;
d399 6
a404 2
	if (mmutype == MMU_68040) {	/* explicitely NOT MMU_68060 */
		if (rv) {
d436 2
a437 1
			    fp->f_fmt7.f_wb2d, fp->f_fmt7.f_wb2a, map))
d446 1
a446 1
			struct vm_map *wb3_map;
d453 2
a454 1
			    fp->f_fmt7.f_wb3d, fp->f_fmt7.f_wb3a, wb3_map))
d468 1
a468 1
		if (rv == 0) {
d472 2
a473 2
		} else if (rv == EACCES)
			rv = EFAULT;
d476 1
a476 1
	if (rv == 0) {
d479 1
a479 1
		userret(p, fp, sticks, 0, 0); 
d483 1
a483 1
	if (rv == 0) {
d491 1
a491 1
		userret(p, fp, sticks, 0, 0); 
d509 1
a509 1
	userret(p, fp, sticks, 0, 0); 
d752 1
a752 1
		userret(p, &frame, sticks, 0, 0); 
d783 1
a783 1
	userret(p, &frame, sticks, 0, 0); 
d938 1
a938 1
	userret(p, &frame, sticks, 0, 0);
d954 1
a954 1
	struct vm_map *wb_map;
d995 1
a995 1
			if (wb_rc)
d1027 2
a1028 1
			if (wb_rc)
d1062 1
a1062 1
	return (0);
@


1.17.10.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d329 3
a331 1
			printf(" curpcb %p\n", curpcb);
@


1.17.10.7
log
@Merge in -current from about a week ago
@
text
@d181 1
a181 1
extern void    regdump(struct trapframe *, int);
d183 6
a188 6
int	_write_back(u_int, u_int, u_int, u_int, struct vm_map *);
void	panictrap(int, u_int, u_int, struct frame *);
void	trapcpfault(struct proc *, struct frame *);
void	trapmmufault(int, u_int, u_int, struct frame *, struct proc *,
    u_quad_t);
void	trap(int, u_int, u_int, struct frame);
d191 1
a191 1
int	db_trap(int, db_regs_t *);
d193 2
a194 2
void	syscall(register_t, struct frame);
void	_wb_fault(void);
@


1.17.10.8
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17.10.7 2002/03/28 10:06:14 niklas Exp $	*/
@


1.16
log
@extern of regdump until after 2.2 when it'll be in m68k/cpu.h
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 1997/09/19 17:16:14 niklas Exp $	*/
d301 1
d516 2
a517 1
	trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, (caddr_t)v);
d539 1
d788 4
a791 2
	if (i)
		trapsignal(p, i, ucode, typ, (caddr_t)ucode);
@


1.15
log
@Kill FPCOPROC (and some forgotten {SWAP,DEV}PAGER)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 1997/09/18 13:39:37 niklas Exp $	*/
d179 3
@


1.14
log
@Merge of NetBSD changes upto last week or so, with the exception of stand/
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 1997/04/10 08:51:04 niklas Exp $	*/
a644 1
#ifdef FPCOPROC
a679 1
#endif
@


1.13
log
@SunOS emulation trap#2 handling from NetBSD (gwr via scottr)
@
text
@d1 2
a2 2
/*	$OpenBSD: trap.c,v 1.12 1997/02/21 08:51:49 niklas Exp $	*/
/*	$NetBSD: trap.c,v 1.53 1997/01/16 15:30:57 gwr Exp $	*/
d70 2
d246 1
a246 1
		regdump(fp, 128);
d622 16
d729 1
a729 1
		 * SunOS uses Trap #2 for a "CPU cache flush"
a730 1
		 * XXX - Too bad m68k BSD uses trap 2...
a734 1
			/* get out fast */
d784 2
a785 1
	trapsignal(p, i, ucode, typ, (caddr_t)ucode);
d941 1
a941 1
		frame.f_regs[SP] -= sizeof(int);
@


1.12
log
@Siginfo stuff as per the mvme68k port + KNF & other style nits
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 1997/02/03 11:38:10 deraadt Exp $	*/
d711 3
a713 4
		 * XXX This comment/code is not consistent XXX
		 * SunOS seems to use Trap #2 for some obscure 
		 * fpu operations.  So far, just ignore it, but
		 * DONT trap on it.. 
d716 3
a718 1
			userret(p, frame.f_pc, sticks); 
@


1.11
log
@SA_SIGINFO implementation
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 1997/01/19 13:53:12 niklas Exp $	*/
d177 8
a184 7
int _write_back __P((u_int, u_int, u_int, u_int, vm_map_t));
static void userret __P((struct proc *, int, u_quad_t));
void panictrap __P((int, u_int, u_int, struct frame *));
void trapcpfault __P((struct proc *, struct frame *));
void trapmmufault __P((int, u_int, u_int, struct frame *, struct proc *,
			u_quad_t));
void trap __P((int, u_int, u_int, struct frame));
d187 1
a187 1
int kdb_trap __P((int, db_regs_t *));
d189 3
a191 3
void syscall __P((register_t, struct frame));
void child_return __P((struct proc *, struct frame));
void _wb_fault __P((void));
d194 1
a194 1
static void
d291 1
a291 1
	vm_prot_t ftype;
d366 2
a367 2
	    (code & (SSW_DF|SSW_RW)) == SSW_DF)
							/* what about RMW? */
d369 2
a370 2
	else
		ftype = VM_PROT_READ;
d438 1
a438 1
		if(fp->f_fmt7.f_wb2s & WBS_VALID &&
d506 2
a507 4
		printf("vm_fault(%p, %lx, %x, 0) -> %x\n",
		       map, va, ftype, rv);
		printf("  type %x, code [mmu,,ssw]: %x\n",
		       type, code);
d510 1
a510 1
	trapsignal(p, SIGSEGV, v, T_MMUFLT, (caddr_t)v);
d515 1
d554 3
a556 3
	printf("trap: t %x c %x v %x pad %x adj %x sr %x pc %x fmt %x vc %x\n",
	    type, code, v, frame.f_pad, frame.f_stackadj, frame.f_sr,
	    frame.f_pc, frame.f_format, frame.f_vector);
d561 1
d570 1
d579 1
d585 1
d593 1
d595 1
d600 1
d602 1
d610 1
d612 1
d617 1
d619 1
d622 3
a624 2
		typ = FPE_FLTOVF;
		i = SIGFPE;
d626 1
d635 1
d637 1
d655 1
d657 1
d664 1
d685 1
d688 1
d706 1
d725 1
d731 1
d744 1
d756 1
d850 1
d861 1
d897 1
d905 1
d909 1
d923 1
a923 1
		frame.f_regs[SP] -= sizeof (int);
d966 1
a966 1
		printf("wb%d valid: %x %x %x\n",wb,wb_sts,wb_addr,wb_data);
d970 3
a972 4

	if((wb_sts & WBS_SZMASK) == WBS_SIZE_WORD)
		if(trunc_page((vm_offset_t)wb_addr) !=
		    trunc_page((vm_offset_t)wb_addr+1))
d975 3
a977 3
	if((wb_sts & WBS_SZMASK) == WBS_SIZE_LONG)
		if(trunc_page((vm_offset_t)wb_addr) !=
		    trunc_page((vm_offset_t)wb_addr+3))
d991 1
a991 1
		if((mmusr & (MMUSR_R | MMUSR_W)) != MMUSR_R) {
d1000 1
a1000 1
			if(wb_rc != KERN_SUCCESS)
d1026 1
a1026 1
				    "  Bringing in extra page.\n",wb);
d1031 1
a1031 1
			    VM_PROT_READ | VM_PROT_WRITE,FALSE);
d1033 1
a1033 1
			if(wb_rc != KERN_SUCCESS)
d1043 2
a1044 5

	if ((wb_sts & WBS_TMMASK) == FC_USERD &&
	    !curpcb->pcb_onfault) {
	    	curpcb->pcb_onfault = (caddr_t) _wb_fault;
	}
a1046 1

d1048 2
a1049 3
		asm volatile ("movec %0,dfc ; movesb %1,%2@@" : : "d" (wb_sts & WBS_TMMASK),
								 "d" (wb_data),
								 "a" (wb_addr));
d1053 2
a1054 3
		asm volatile ("movec %0,dfc ; movesw %1,%2@@" : : "d" (wb_sts & WBS_TMMASK),
								 "d" (wb_data),
								 "a" (wb_addr));
d1058 2
a1059 3
		asm volatile ("movec %0,dfc ; movesl %1,%2@@" : : "d" (wb_sts & WBS_TMMASK),
								 "d" (wb_data),
								 "a" (wb_addr));
d1063 1
a1063 1
	if (curpcb->pcb_onfault == (caddr_t) _wb_fault)
d1066 1
a1066 1
		asm volatile ("movec %0,dfc\n" : : "d" (FC_USERD));
@


1.10
log
@From Gordon W Ross (NetBSD):
Use db_regs_t instead of struct mc68020_saved_state
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.9 1997/01/18 12:42:02 niklas Exp $	*/
d511 1
a511 1
	trapsignal(p, SIGSEGV, v);
d531 1
a531 1
	int i;
d537 1
a537 1
	ucode = 0;
d573 4
d578 2
d586 4
d592 1
d599 4
d604 4
d610 1
d619 1
d637 1
d664 1
d682 1
d700 1
d741 1
a741 1
	trapsignal(p, i, ucode);
@


1.9
log
@Avoid a double trap
@
text
@d1 2
a2 2
/*	$OpenBSD: trap.c,v 1.8 1997/01/16 09:23:30 niklas Exp $	*/
/*	$NetBSD: trap.c,v 1.52 1996/11/13 06:22:20 thorpej Exp $	*/
d186 1
a186 1
int kdb_trap __P((int, struct mc68020_saved_state *));
@


1.8
log
@Sync to NetBSD 970110
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.7 1996/11/28 23:33:03 niklas Exp $	*/
d501 1
a501 1
		if (p && p->p_addr->u_pcb.pcb_onfault) {
@


1.7
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: trap.c,v 1.6 1996/06/07 05:18:40 niklas Exp $	*/
/*	$NetBSD: trap.c,v 1.47 1996/05/10 14:31:08 is Exp $	*/
d484 1
a484 1
		reutrn;
@


1.6
log
@a NULL curproc could doublefault
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.5 1996/05/29 10:14:38 niklas Exp $	*/
d511 1
a511 1
	trapsignal(p, (rv == KERN_PROTECTION_FAILURE) ? SIGBUS : SIGSEGV, v);
@


1.5
log
@Merge of 960526 NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d501 1
a501 1
		if (p->p_addr->u_pcb.pcb_onfault) {
@


1.4
log
@Sync with NetBSD 9600430.  The port has gone over a major -Wall treat
@
text
@d2 1
a2 1
/*	$NetBSD: trap.c,v 1.45 1996/04/28 07:01:08 mhitch Exp $	*/
d129 3
d157 1
a157 1
	FMT0SIZE,	/* type 0 - normal (68020/030/040) */
d159 4
a162 3
	FMT2SIZE,	/* type 2 - normal 6-word (68020/030/040) */
	FMT3SIZE,	/* type 3 - FP post-instruction (68040) */
	-1, -1, -1,	/* type 4-6 - undefined */
d274 2
d284 4
d313 15
d334 2
d350 6
a355 3
	    (!p || !p->p_addr || p->p_addr->u_pcb.pcb_onfault == 0 ||
	    (mmutype == MMU_68040 && (code & SSW_TMMASK) == FC_SUPERD) ||
	    (mmutype != MMU_68040 && (code & (SSW_DF|FC_SUPERD)) == (SSW_DF|FC_SUPERD))))
d359 1
d361 6
a366 3
	    (mmutype == MMU_68040 && (code & SSW_RW040) == 0) ||
	    (mmutype != MMU_68040 && (code & (SSW_DF|SSW_RW)) ==
	    SSW_DF))	/* what about RMW? */
d403 3
d407 1
d552 2
a553 1
/*
d557 1
a557 2
*/

@


1.3
log
@SIGBUS is an alignment fault. SIGSEGV is an access violation
@
text
@d1 2
a2 1
/*	$NetBSD: trap.c,v 1.42.2.1 1995/11/10 19:32:59 chopps Exp $	*/
d172 16
a187 2
int fubail();
int subail();
d279 1
a279 1
	struct vmspace *vm;
d303 1
a303 1
		printf ("68040 access error: pc %x, code %x,"
d306 1
a306 1
			printf (" curpcb %x ->pcb_ustp %x / %x\n",
d339 1
a339 1
		printf("trap: bad kernel access at %x\n", v);
d359 1
a359 1
		printf("vm_fault(%x,%x,%d,0)\n", map, va, ftype);
d366 1
a366 1
		printf("vmfault %s %x returned %d\n",
d467 1
a467 1
		printf("vm_fault(%x, %x, %x, 0) -> %x\n",
d473 1
a473 1
	trapsignal(p, SIGSEGV, v);
d484 1
d491 3
a493 3
	u_int ncode, ucode;
	u_quad_t sticks;
	int i, s;
d510 1
a510 1
		if (kdb_trap(type, &frame))
d687 1
d859 1
a868 1
	void _wb_fault ();	/* fault handler for write back */
d987 2
a988 1
void _wb_fault()
@


1.2
log
@update to netbsd
@
text
@d458 1
a458 1
	trapsignal(p, (rv == KERN_PROTECTION_FAILURE) ? SIGBUS : SIGSEGV, v);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.42 1995/10/09 04:34:08 chopps Exp $	*/
d283 1
d286 1
d299 1
d301 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

