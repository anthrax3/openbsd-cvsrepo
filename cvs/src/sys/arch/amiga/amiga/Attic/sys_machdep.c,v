head	1.13;
access;
symbols
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	UBC_SYNC_A:1.13
	OPENBSD_3_2:1.12.0.6
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.4
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.14
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.12
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2002.12.31.16.35.36;	author miod;	state dead;
branches;
next	1.12;

1.12
date	2001.11.30.22.08.13;	author miod;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.14.10.41.50;	author jj;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.08.08.08.42;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.23.02.14.35;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.08.22.25.17;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.09.09.11.11.23;	author niklas;	state Exp;
branches
	1.6.12.1;
next	1.5;

1.5
date	97.01.16.09.23.29;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.08.19.00.04.15;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.05.02.06.43.23;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.03.53.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.53;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.53;	author deraadt;	state Exp;
branches;
next	;

1.6.12.1
date	2001.04.18.16.02.00;	author niklas;	state Exp;
branches;
next	1.6.12.2;

1.6.12.2
date	2001.07.04.10.15.01;	author niklas;	state Exp;
branches;
next	1.6.12.3;

1.6.12.3
date	2001.11.13.21.00.50;	author niklas;	state Exp;
branches;
next	1.6.12.4;

1.6.12.4
date	2001.12.05.00.39.09;	author niklas;	state Exp;
branches;
next	1.6.12.5;

1.6.12.5
date	2003.03.27.23.19.17;	author niklas;	state dead;
branches;
next	;

1.12.2.1
date	2003.05.19.21.49.38;	author tedu;	state dead;
branches;
next	;


desc
@@


1.13
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: sys_machdep.c,v 1.12 2001/11/30 22:08:13 miod Exp $	*/
/*	$NetBSD: sys_machdep.c,v 1.16 1997/05/19 10:14:47 veego Exp $	*/

/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)sys_machdep.c	7.7 (Berkeley) 5/7/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <sys/time.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/mtio.h>
#include <sys/buf.h>

#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>

/* XXX should be in an include file somewhere */
#define CC_PURGE	1
#define CC_FLUSH	2
#define CC_IPURGE	4
#define CC_EXTPURGE	0x80000000
/* XXX end should be */

/*ARGSUSED1*/
int
cachectl(req, addr, len)
	int req;
	caddr_t	addr;
	int len;
{
	int error = 0;
#if defined(M68040) || defined(M68060)
	if (mmutype <= MMU_68040) {
		register int inc = 0;
		int doall = 0;
		caddr_t end = 0;
		paddr_t pa = 0;

		if (addr == 0 ||
		    ((req & ~CC_EXTPURGE) != CC_PURGE && len > 2*NBPG))
			doall = 1;
		if (!doall) {
			end = addr + len;
			if (len <= 1024) {
				addr = (caddr_t)((int)addr & ~0xF);
				inc = 16;
			} else {
				addr = (caddr_t)((int)addr & ~PGOFSET);
				inc = NBPG;
			}
		}
		do {
			/*
			 * Convert to physical address if needed.
			 * If translation fails, we perform operation on
			 * entire cache (XXX is this a rational thing to do?)
			 */
			if (!doall &&
			    (pa == 0 || ((int)addr & PGOFSET) == 0)) {
				if (pmap_extract(
				    curproc->p_vmspace->vm_map.pmap,
				    (vm_offset_t)addr, &pa) == FALSE)
					doall = 1;
			}
			switch (req) {
			case CC_EXTPURGE|CC_IPURGE:
			case CC_IPURGE:
				if (doall) {
					DCFA();
					ICPA();
				} else if (inc == 16) {
					DCFL(pa);
					ICPL(pa);
				} else if (inc == NBPG) {
					DCFP(pa);
					ICPP(pa);
				}
				break;
			
			case CC_EXTPURGE|CC_PURGE:
			case CC_PURGE:
				if (doall)
					DCFA();	/* note: flush not purge */
				else if (inc == 16)
					DCPL(pa);
				else if (inc == NBPG)
					DCPP(pa);
				break;

			case CC_EXTPURGE|CC_FLUSH:
			case CC_FLUSH:
				if (doall)
					DCFA();
				else if (inc == 16)
					DCFL(pa);
				else if (inc == NBPG)
					DCFP(pa);
				break;
				
			default:
				error = EINVAL;
				break;
			}
			if (doall)
				break;
			pa += inc;
			addr += inc;
		} while (addr < end);
		return(error);
	}
#endif	/* M68040 */

	switch (req) {
	case CC_EXTPURGE|CC_PURGE:
	case CC_EXTPURGE|CC_FLUSH:
	case CC_PURGE:
	case CC_FLUSH:
		DCIU();
		break;
	case CC_EXTPURGE|CC_IPURGE:
		DCIU();
		/*FALLTHROUGH*/
	case CC_IPURGE:
		ICIA();
		break;
	default:
		error = EINVAL;
		break;
	}
	return(error);
}

/*
 * DMA cache control
 */

/*ARGSUSED1*/
int
dma_cachectl(addr, len)
	caddr_t	addr;
	int len;
{
#if defined(M68040) || defined(M68060)
	if (mmutype <= MMU_68040) {
		register int inc = 0;
		int pa = 0;
		caddr_t end;

		end = addr + len;
		if (len <= 1024) {
			addr = (caddr_t)((int)addr & ~0xF);
			inc = 16;
		} else {
			addr = (caddr_t)((int)addr & ~PGOFSET);
			inc = NBPG;
		}
		do {
			/*
			 * Convert to physical address.
			 */
			if (pa == 0 || ((int)addr & PGOFSET) == 0) {
				pa = kvtop (addr);
			}
			if (inc == 16) {
				DCFL(pa);
				ICPL(pa);
			} else {
				DCFP(pa);
				ICPP(pa);
			}
			pa += inc;
			addr += inc;
		} while (addr < end);
	}
#endif	/* M68040 */
	return(0);
}

int
sys_sysarch(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
#ifdef notyet
	struct sys_sysarch_args /* {
		syscallarg(int) op;
		syscallarg(char *) parms;
	} */ *uap = v;
#endif

	return ENOSYS;
}
@


1.12
log
@Make it possible for mmutype to contain MMU_68060 if the hardware is
actually '060-based, instead to look at the machineid.
This is simpler, and will be required to switch to pmap_motorola anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.11 2001/11/06 19:53:14 miod Exp $	*/
@


1.12.2.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.12 2001/11/30 22:08:13 miod Exp $	*/
@


1.11
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.10 2001/06/14 10:41:50 jj Exp $	*/
d74 1
a74 1
	if (mmutype == MMU_68040) {
d185 1
a185 1
	if (mmutype == MMU_68040) {
@


1.10
log
@Fix for pmap_extract on amiga. int -> paddr_t fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.9 2001/06/08 08:08:42 art Exp $	*/
d54 1
a54 1
#include <vm/vm.h>
@


1.9
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.8 2000/06/23 02:14:35 mickey Exp $	*/
d76 1
a76 1
		int pa = 0, doall = 0;
d78 1
@


1.8
log
@remove obsolete vtrace guts; art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.7 2000/06/08 22:25:17 niklas Exp $	*/
d100 1
a100 1
				pa = pmap_extract(
d102 1
a102 2
				    (vm_offset_t)addr);
				if (pa == 0)
@


1.7
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.7 2000/06/08 21:11:54 niklas Exp $	*/
a49 1
#include <sys/trace.h>
a54 57

#ifdef TRACE
int	nvualarm;

sys_vtrace(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct sys_vtrace_args /* {
		syscallarg(int) request;
		syscallarg(int) value;
	} */ *uap = v;
	int vdoualarm();

	switch (SCARG(uap, request)) {

	case VTR_DISABLE:		/* disable a trace point */
	case VTR_ENABLE:		/* enable a trace point */
		if (SCARG(uap, value) < 0 || SCARG(uap, value) >= TR_NFLAGS)
			return (EINVAL);
		*retval = traceflags[SCARG(uap, value)];
		traceflags[SCARG(uap, value)] = SCARG(uap, request);
		break;

	case VTR_VALUE:		/* return a trace point setting */
		if (SCARG(uap, value) < 0 || SCARG(uap, value) >= TR_NFLAGS)
			return (EINVAL);
		*retval = traceflags[SCARG(uap, value)];
		break;

	case VTR_UALARM:	/* set a real-time ualarm, less than 1 min */
		if (SCARG(uap, value) <= 0 || SCARG(uap, value) > 60 * hz ||
		    nvualarm > 5)
			return (EINVAL);
		nvualarm++;
		timeout(vdoualarm, (caddr_t)p->p_pid, SCARG(uap, value));
		break;

	case VTR_STAMP:
		trace(TR_STAMP, SCARG(uap, value), p->p_pid);
		break;
	}
	return (0);
}

vdoualarm(arg)
	int arg;
{
	register struct proc *p;

	p = pfind(arg);
	if (p)
		psignal(p, 16);
	nvualarm--;
}
#endif
@


1.6
log
@From NetBSD: s/vm_pmap/vm_map.pmap/
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.5 1997/01/16 09:23:29 niklas Exp $	*/
d45 1
@


1.6.12.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.8 2000/06/23 02:14:35 mickey Exp $	*/
a44 1
#include <sys/signalvar.h>
d49 1
d55 57
@


1.6.12.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.6.12.1 2001/04/18 16:02:00 niklas Exp $	*/
d76 1
a76 1
		int doall = 0;
a77 1
		paddr_t pa = 0;
d100 1
a100 1
				if (pmap_extract(
d102 2
a103 1
				    (vm_offset_t)addr, &pa) == FALSE)
@


1.6.12.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 1
a54 1
#include <uvm/uvm_extern.h>
@


1.6.12.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.6.12.3 2001/11/13 21:00:50 niklas Exp $	*/
d74 1
a74 1
	if (mmutype <= MMU_68040) {
d185 1
a185 1
	if (mmutype <= MMU_68040) {
@


1.6.12.5
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.6.12.4 2001/12/05 00:39:09 niklas Exp $	*/
@


1.5
log
@Sync to NetBSD 970110
@
text
@d1 2
a2 2
/*	$OpenBSD: sys_machdep.c,v 1.4 1996/08/19 00:04:15 niklas Exp $	*/
/*	$NetBSD: sys_machdep.c,v 1.15 1996/05/25 21:54:28 is Exp $	*/
d157 3
a159 2
				pa = pmap_extract(&curproc->p_vmspace->vm_pmap,
						  (vm_offset_t)addr);
@


1.4
log
@Merge of Late July NetBSD sources (mostly DRACO support).  More to come...
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: sys_machdep.c,v 1.14.4.1 1996/05/26 16:23:34 is Exp $	*/
@


1.3
log
@Sync with NetBSD 9600430.  The port has gone over a major -Wall treat
@
text
@d2 1
a2 1
/*	$NetBSD: sys_machdep.c,v 1.14 1996/04/21 21:07:13 veego Exp $	*/
d130 1
a130 1
#ifdef M68040
d240 1
a240 1
#ifdef M68040
@


1.2
log
@update to netbsd
@
text
@d1 2
a2 1
/*	$NetBSD: sys_machdep.c,v 1.12.2.1 1995/11/10 16:13:41 chopps Exp $	*/
d123 1
d134 1
a134 1
		caddr_t end;
d137 1
a137 1
		    (req & ~CC_EXTPURGE) != CC_PURGE && len > 2*NBPG)
d235 1
d259 1
a259 1
				pa = kvtop ((vm_offset_t)addr);
d282 1
d287 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: sys_machdep.c,v 1.12 1995/10/09 04:34:05 chopps Exp $	*/
d63 1
a63 1
	register struct vtrace_args /* {
d279 1
a279 1
	struct sysarch_args /* {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
