head	1.17;
access;
symbols
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.16
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.8.0.20
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.18
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.16
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.14
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.12
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.10
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.8
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.6
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2002.12.31.16.35.37;	author miod;	state dead;
branches;
next	1.16;

1.16
date	2002.06.11.03.25.42;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.28;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.11.05.20.12.31;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.01.12.13.45;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.11.20.05.20;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.11.23.07.11;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.20.06.58.43;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.01.16.09.24.07;	author niklas;	state Exp;
branches
	1.8.14.1;
next	1.7;

1.7
date	96.11.24.20.23.40;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.11.23.21.45.10;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.05.29.10.14.54;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.05.02.06.43.42;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.15.08;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.26.01.04.35;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.56;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.56;	author deraadt;	state Exp;
branches;
next	;

1.8.14.1
date	2001.07.04.10.15.09;	author niklas;	state Exp;
branches;
next	1.8.14.2;

1.8.14.2
date	2001.10.31.02.52.45;	author nate;	state Exp;
branches;
next	1.8.14.3;

1.8.14.3
date	2001.11.13.21.00.50;	author niklas;	state Exp;
branches;
next	1.8.14.4;

1.8.14.4
date	2002.03.28.10.06.14;	author niklas;	state Exp;
branches;
next	1.8.14.5;

1.8.14.5
date	2003.03.27.23.19.17;	author niklas;	state dead;
branches;
next	;

1.14.2.1
date	2002.06.11.03.34.57;	author art;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.10.29.00.28.01;	author art;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2003.05.19.21.49.38;	author tedu;	state dead;
branches;
next	;


desc
@@


1.17
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: grf.c,v 1.16 2002/06/11 03:25:42 miod Exp $	*/
/*	$NetBSD: grf.c,v 1.32 1996/12/23 09:10:01 veego Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: grf.c 1.31 91/01/21$
 *
 *	@@(#)grf.c	7.8 (Berkeley) 5/7/91
 */

/*
 * Graphics display driver for the Amiga
 * This is the hardware-independent portion of the driver.
 * Hardware access is through the grf_softc->g_mode routine.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/file.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/vnode.h>
#include <sys/mman.h>
#include <uvm/uvm_extern.h>
#include <machine/cpu.h>
#include <machine/fbio.h>
#include <amiga/amiga/color.h>	/* DEBUG */
#include <amiga/amiga/device.h>
#include <amiga/dev/grfioctl.h>
#include <amiga/dev/grfvar.h>
#include <amiga/dev/itevar.h>
#include <amiga/dev/viewioctl.h>

#include <machine/conf.h>

#include "view.h"
#include "grf.h"

#if NGRF > 0
#include "ite.h"
#if NITE == 0
#define	ite_on(u,f)
#define	ite_off(u,f)
#define ite_reinit(d)
#endif

int grfon(dev_t);
int grfoff(dev_t);
int grfsinfo(dev_t, struct grfdyninfo *);
#ifdef BANKEDDEVPAGER
int grfbanked_get(dev_t, off_t, int);
int grfbanked_cur(dev_t);
int grfbanked_set(dev_t, int);
#endif

void grfattach(struct device *, struct device *, void *);
int grfmatch(struct device *, void *, void *);
int grfprint(void *, const char *);
/*
 * pointers to grf drivers device structs 
 */
struct grf_softc *grfsp[NGRF];

struct cfattach grf_ca = {
	sizeof(struct device), grfmatch, grfattach
};

struct cfdriver grf_cd = {
	NULL, "grf", DV_DULL, NULL, 0
};

/*
 * only used in console init.
 */
static struct cfdata *grf_cfdata;

/*
 * match if the unit of grf matches its perspective 
 * low level board driver.
 */
int
grfmatch(pdp, match, auxp)
	struct device *pdp;
	void *match, *auxp;
{
	struct cfdata *cfp = match;

	if (cfp->cf_unit != ((struct grf_softc *)pdp)->g_unit)
		return(0);
	grf_cfdata = cfp;
	return(1);
}

/*
 * attach.. plug pointer in and print some info.
 * then try and attach an ite to us. note: dp is NULL
 * during console init.
 */
void
grfattach(pdp, dp, auxp)
	struct device *pdp, *dp;
	void *auxp;
{
	struct grf_softc *gp;
	int maj;

	gp = (struct grf_softc *)pdp;
	grfsp[gp->g_unit] = (struct grf_softc *)pdp;

	/*
	 * find our major device number 
	 */
	for(maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == grfopen)
			break;

	gp->g_grfdev = makedev(maj, gp->g_unit);
	if (dp != NULL) {
		printf(": width %d height %d", gp->g_display.gd_dwidth,
		    gp->g_display.gd_dheight);
		if (gp->g_display.gd_colors == 2)
			printf(" monochrome\n");
		else
			printf(" colors %d\n", gp->g_display.gd_colors);
	}
	
	/*
	 * try and attach an ite
	 */
	amiga_config_found(grf_cfdata, dp, gp, grfprint);
}

int
grfprint(auxp, pnp)
	void *auxp;
	const char *pnp;
{
	if (pnp)
		printf("ite at %s", pnp);
	return(UNCONF);
}

/*ARGSUSED*/
int
grfopen(dev, flags, devtype, p)
	dev_t dev;
	int flags, devtype;
	struct proc *p;
{
	struct grf_softc *gp;

	if (GRFUNIT(dev) >= NGRF || (gp = grfsp[GRFUNIT(dev)]) == NULL)
		return(ENXIO);

	if ((gp->g_flags & GF_ALIVE) == 0)
		return(ENXIO);

	if ((gp->g_flags & (GF_OPEN|GF_EXCLUDE)) == (GF_OPEN|GF_EXCLUDE))
		return(EBUSY);

	return(0);
}

/*ARGSUSED*/
int
grfclose(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
{
	struct grf_softc *gp;

	gp = grfsp[GRFUNIT(dev)];
	(void)grfoff(dev);
	gp->g_flags &= GF_ALIVE;
	return(0);
}

/*ARGSUSED*/
int
grfioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct grf_softc *gp;
	int error;

	gp = grfsp[GRFUNIT(dev)];
	error = 0;

	switch (cmd) {
	case OGRFIOCGINFO:
	        /* argl.. no bank-member.. */
	  	bcopy((caddr_t)&gp->g_display, data, sizeof(struct grfinfo)-4);
		break;
	case GRFIOCGINFO:
		bcopy((caddr_t)&gp->g_display, data, sizeof(struct grfinfo));
		break;
	case GRFIOCON:
		error = grfon(dev);
		break;
	case GRFIOCOFF:
		error = grfoff(dev);
		break;
	case GRFIOCSINFO:
		error = grfsinfo(dev, (struct grfdyninfo *) data);
		break;
	case GRFGETVMODE:
		return(gp->g_mode(gp, GM_GRFGETVMODE, data, 0, 0));
	case GRFSETVMODE:
		error = gp->g_mode(gp, GM_GRFSETVMODE, data, 0, 0);
		if (error == 0 && gp->g_itedev && !(gp->g_flags & GF_GRFON))
			ite_reinit(gp->g_itedev);
		break;
	case GRFGETNUMVM:
		return(gp->g_mode(gp, GM_GRFGETNUMVM, data, 0, 0));
	/*
	 * these are all hardware dependant, and have to be resolved
	 * in the respective driver.
	 */
	case GRFIOCPUTCMAP:
	case GRFIOCGETCMAP:
	case GRFIOCSSPRITEPOS:
	case GRFIOCGSPRITEPOS:
	case GRFIOCSSPRITEINF:
	case GRFIOCGSPRITEINF:
	case GRFIOCGSPRITEMAX:
	case GRFIOCBITBLT:
    	case GRFIOCSETMON:
	case GRFIOCBLANK:	/* blank ioctl, IOCON/OFF will turn ite on */
	case GRFTOGGLE: /* Toggles between Cirrus boards and native ECS on
                     Amiga. 15/11/94 ill */
		/*
		 * We need the minor dev number to get the overlay/image
		 * information for grf_ul.
		 */
		return(gp->g_mode(gp, GM_GRFIOCTL, data, cmd, dev));

	case FBIOSVIDEO:
		return(gp->g_mode(gp, GM_GRFIOCTL, data, GRFIOCBLANK, dev));

	default:
#if NVIEW > 0
		/*
		 * check to see whether it's a command recognized by the
		 * view code if the unit is 0
		 * XXX 
		 */
		if (GRFUNIT(dev) == 0)
			return(viewioctl(dev, cmd, data, flag, p));
#endif
		error = EINVAL;
		break;

	}
	return(error);
}

/*ARGSUSED*/
int
grfselect(dev, rw, p)
	dev_t dev;
	int rw;
	struct proc *p;
{
	if (rw == FREAD)
		return(0);
	return(1);
}

/*
 * map the contents of a graphics display card into process' 
 * memory space.
 */
paddr_t
grfmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
{
	struct grf_softc *gp;
	struct grfinfo *gi;
	
	gp = grfsp[GRFUNIT(dev)];
	gi = &gp->g_display;

	/* 
	 * control registers
	 */
	if (off >= 0 && off < gi->gd_regsize)
		return(((u_int)gi->gd_regaddr + off) >> PGSHIFT);

	/*
	 * frame buffer
	 */
	if (off >= gi->gd_regsize && off < gi->gd_regsize+gi->gd_fbsize) {
		off -= gi->gd_regsize;
#ifdef BANKEDDEVPAGER
		if (gi->gd_bank_size)
			off %= gi->gd_bank_size;
#endif
		return(((u_int)gi->gd_fbaddr + off) >> PGSHIFT);
	}
	/* bogus */
	return(-1);
}

int
grfon(dev)
	dev_t dev;
{
	struct grf_softc *gp;

	gp = grfsp[GRFUNIT(dev)];

	if (gp->g_flags & GF_GRFON)
		return(0);

	gp->g_flags |= GF_GRFON;
	if (gp->g_itedev != NODEV)
		ite_off(gp->g_itedev, 3);

	return(gp->g_mode(gp, (dev & GRFOVDEV) ? GM_GRFOVON : GM_GRFON,
							NULL, 0, 0));
}

int
grfoff(dev)
	dev_t dev;
{
	struct grf_softc *gp;
	int error;

	gp = grfsp[GRFUNIT(dev)];

	if ((gp->g_flags & GF_GRFON) == 0)
		return(0);

	gp->g_flags &= ~GF_GRFON;
	error = gp->g_mode(gp, (dev & GRFOVDEV) ? GM_GRFOVOFF : GM_GRFOFF,
							NULL, 0, 0);

	/*
	 * Closely tied together no X's
	 */
	if (gp->g_itedev != NODEV)
		ite_on(gp->g_itedev, 2);

	return(error);
}

int
grfsinfo(dev, dyninfo)
	dev_t dev;
	struct grfdyninfo *dyninfo;
{
	struct grf_softc *gp;
	int error;

	gp = grfsp[GRFUNIT(dev)];
	error = gp->g_mode(gp, GM_GRFCONFIG, dyninfo, 0, 0);

	/*
	 * Closely tied together no X's
	 */
	if (gp->g_itedev != NODEV)
		ite_reinit(gp->g_itedev);
	return(error);
}

#ifdef BANKEDDEVPAGER

int
grfbanked_get (dev, off, prot)
     dev_t dev;
     off_t off;
     int   prot;
{
	struct grf_softc *gp;
	struct grfinfo *gi;
	int error, bank;

	gp = grfsp[GRFUNIT(dev)];
	gi = &gp->g_display;

	off -= gi->gd_regsize;
	if (off < 0 || off >= gi->gd_fbsize)
		return -1;

	error = gp->g_mode(gp, GM_GRFGETBANK, &bank, off, prot);
	return error ? -1 : bank;
}

int
grfbanked_cur (dev)
	dev_t dev;
{
	struct grf_softc *gp;
	int error, bank;

	gp = grfsp[GRFUNIT(dev)];

	error = gp->g_mode(gp, GM_GRFGETCURBANK, &bank, 0, 0);
	return(error ? -1 : bank);
}

int
grfbanked_set (dev, bank)
	dev_t dev;
	int bank;
{
	struct grf_softc *gp;

	gp = grfsp[GRFUNIT(dev)];
	return(gp->g_mode(gp, GM_GRFSETBANK, &bank, 0, 0) ? -1 : 0);
}

#endif /* BANKEDDEVPAGER */
#endif	/* NGRF > 0 */
@


1.16
log
@Include <sys/conf.h> from <machine/conf.h> like in other arches.  Changes
to come soon depend on this.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.15 2002/03/14 01:26:28 millert Exp $	*/
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.14 2001/11/06 19:53:14 miod Exp $	*/
a70 1
#include <sys/conf.h>
@


1.14
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.13 2001/11/05 20:12:31 art Exp $	*/
d85 3
a87 3
int grfon __P((dev_t));
int grfoff __P((dev_t));
int grfsinfo __P((dev_t, struct grfdyninfo *));
d89 3
a91 3
int grfbanked_get __P((dev_t, off_t, int));
int grfbanked_cur __P((dev_t));
int grfbanked_set __P((dev_t, int));
d94 3
a96 3
void grfattach __P((struct device *, struct device *, void *));
int grfmatch __P((struct device *, void *, void *));
int grfprint __P((void *, const char *));
@


1.14.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.14 2001/11/06 19:53:14 miod Exp $	*/
d85 3
a87 3
int grfon(dev_t);
int grfoff(dev_t);
int grfsinfo(dev_t, struct grfdyninfo *);
d89 3
a91 3
int grfbanked_get(dev_t, off_t, int);
int grfbanked_cur(dev_t);
int grfbanked_set(dev_t, int);
d94 3
a96 3
void grfattach(struct device *, struct device *, void *);
int grfmatch(struct device *, void *, void *);
int grfprint(void *, const char *);
@


1.14.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.14.2.1 2002/06/11 03:34:57 art Exp $	*/
d71 1
@


1.14.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.14.2.2 2002/10/29 00:28:01 art Exp $	*/
@


1.13
log
@typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.11 2001/09/11 20:05:20 miod Exp $	*/
d61 1
a61 1
#include <vm/vm.h>
@


1.12
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d320 1
a320 1
	off_t off
@


1.11
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.10 2001/08/11 23:07:11 art Exp $	*/
d317 1
a317 1
int
d320 2
a321 1
	int off, prot;
@


1.10
log
@redundant includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.9 2001/06/20 06:58:43 niklas Exp $	*/
a61 1
#include <vm/vm_kern.h>
@


1.9
log
@comment typo. from jsyn@@nthought.com
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.8 1997/01/16 09:24:07 niklas Exp $	*/
a62 2
#include <vm/vm_page.h>
#include <vm/vm_pager.h>
@


1.8
log
@Sync to NetBSD 970110
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.7 1996/11/24 20:23:40 niklas Exp $	*/
d138 1
a138 1
 * durring console init.
@


1.8.14.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.8 1997/01/16 09:24:07 niklas Exp $	*/
d138 1
a138 1
 * during console init.
@


1.8.14.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.8.14.1 2001/07/04 10:15:09 niklas Exp $	*/
d62 3
@


1.8.14.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d61 1
a61 1
#include <uvm/uvm_extern.h>
d317 1
a317 1
paddr_t
d320 1
a320 2
	off_t off;
	int prot;
@


1.8.14.4
log
@Merge in -current from about a week ago
@
text
@d85 3
a87 3
int grfon(dev_t);
int grfoff(dev_t);
int grfsinfo(dev_t, struct grfdyninfo *);
d89 3
a91 3
int grfbanked_get(dev_t, off_t, int);
int grfbanked_cur(dev_t);
int grfbanked_set(dev_t, int);
d94 3
a96 3
void grfattach(struct device *, struct device *, void *);
int grfmatch(struct device *, void *, void *);
int grfprint(void *, const char *);
@


1.8.14.5
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.8.14.4 2002/03/28 10:06:14 niklas Exp $	*/
@


1.7
log
@extern decl of cfdata from device.h conflicted with static one in-here
@
text
@d1 2
a2 2
/*	$OpenBSD: grf.c,v 1.6 1996/11/23 21:45:10 kstailey Exp $	*/
/*	$NetBSD: grf.c,v 1.27 1996/05/19 20:06:20 is Exp $	*/
@


1.6
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.5 1996/05/29 10:14:54 niklas Exp $	*/
d116 1
a116 1
static struct cfdata *cfdata;
d131 1
a131 1
	cfdata = cfp;
d171 1
a171 1
	amiga_config_found(cfdata, dp, gp, grfprint);
@


1.5
log
@Merge of 960526 NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: grf.c,v 1.3 1996/04/21 22:15:08 deraadt Exp $	*/
d99 1
a99 1
int grfprint __P((void *, char *));
d177 1
a177 1
	char *pnp;
@


1.4
log
@Sync with NetBSD 9600430.  The port has gone over a major -Wall treat
@
text
@d2 1
a2 1
/*	$NetBSD: grf.c,v 1.26 1996/04/21 21:11:07 veego Exp $	*/
d66 1
d283 4
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: grf.c,v 1.25 1996/03/17 01:17:09 thorpej Exp $	*/
a57 1
#include <sys/conf.h>
d71 4
d77 1
a78 1
#include "grf.h"
a79 1

a86 6
int grfopen __P((dev_t, int, int, struct proc *));
int grfclose __P((dev_t, int));
int grfioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int grfselect __P((dev_t, int));
int grfmmap __P((dev_t, int, int));

d206 1
a206 1
grfclose(dev, flags)
d209 2
d253 1
a253 1
		return(gp->g_mode(gp, GM_GRFGETVMODE, data));
d255 1
a255 1
		error = gp->g_mode(gp, GM_GRFSETVMODE, data);
d260 1
a260 1
		return(gp->g_mode(gp, GM_GRFGETNUMVM, data));
d281 1
a281 1
		return(gp->g_mode(gp, GM_GRFIOCTL, cmd, data, dev));
d301 1
a301 1
grfselect(dev, rw)
d304 1
d362 2
a363 1
	return(gp->g_mode(gp, (dev & GRFOVDEV) ? GM_GRFOVON : GM_GRFON));
d379 2
a380 1
	error = gp->g_mode(gp, (dev & GRFOVDEV) ? GM_GRFOVOFF : GM_GRFOFF);
d400 1
a400 1
	error = gp->g_mode(gp, GM_GRFCONFIG, dyninfo);
d442 1
a442 1
	error = gp->g_mode(gp, GM_GRFGETCURBANK, &bank);
d454 1
a454 1
	return(gp->g_mode(gp, GM_GRFSETBANK, bank) ? -1 : 0);
@


1.2
log
@update from netbsd tree
@
text
@d1 2
a2 1
/*	$NetBSD: grf.c,v 1.23.2.1 1995/10/20 11:01:06 chopps Exp $	*/
d101 1
a101 1
int grfmatch __P((struct device *, struct cfdata *, void *));
d108 7
a114 4

struct cfdriver grfcd = {
	NULL, "grf", (cfmatch_t)grfmatch, grfattach, DV_DULL,
	sizeof(struct device), NULL, 0 };
d126 1
a126 1
grfmatch(pdp, cfp, auxp)
d128 1
a128 2
	struct cfdata *cfp;
	void *auxp;
d130 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: grf.c,v 1.23 1995/10/09 02:08:43 chopps Exp $	*/
d191 1
a191 1
	if (GRFUNIT(dev) >= NGRF)
a192 2

	gp = grfsp[GRFUNIT(dev)];
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
