head	1.17;
access;
symbols
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.15
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.10.0.20
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.18
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.16
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.14
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.12
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.10
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.8
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.6
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2002.12.31.16.35.37;	author miod;	state dead;
branches;
next	1.16;

1.16
date	2002.11.06.00.17.27;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.28;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.24.20.31.08;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.19.08.58.05;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.28.13.47.38;	author art;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	97.09.18.13.39.43;	author niklas;	state Exp;
branches
	1.10.12.1;
next	1.9;

1.9
date	97.01.16.09.23.52;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.06.04.13.28.39;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.05.29.10.14.49;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.05.02.06.43.37;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.04.27.18.38.50;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.15.01;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.24.17.26.22;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.06.09.23.31;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.55;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.55;	author deraadt;	state Exp;
branches;
next	;

1.10.12.1
date	2001.11.13.21.00.50;	author niklas;	state Exp;
branches;
next	1.10.12.2;

1.10.12.2
date	2001.12.05.00.39.09;	author niklas;	state Exp;
branches;
next	1.10.12.3;

1.10.12.3
date	2002.03.06.00.56.18;	author niklas;	state Exp;
branches;
next	1.10.12.4;

1.10.12.4
date	2002.03.28.10.06.14;	author niklas;	state Exp;
branches;
next	1.10.12.5;

1.10.12.5
date	2003.03.27.23.19.17;	author niklas;	state dead;
branches;
next	;

1.12.2.1
date	2002.01.31.22.55.07;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.06.11.03.34.57;	author art;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2003.05.19.21.49.38;	author tedu;	state dead;
branches;
next	;


desc
@@


1.17
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: clock.c,v 1.16 2002/11/06 00:17:27 art Exp $	*/
/*	$NetBSD: clock.c,v 1.25 1997/01/02 20:59:42 is Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: clock.c 1.18 91/01/21$
 *
 *	@@(#)clock.c	7.6 (Berkeley) 5/7/91
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <machine/psl.h>
#include <machine/cpu.h>
#include <machine/intr.h>
#include <amiga/amiga/device.h>
#include <amiga/amiga/custom.h>
#include <amiga/amiga/cia.h>
#ifdef DRACO
#include <amiga/amiga/drcustom.h>
#endif
#include <amiga/amiga/isr.h>
#include <amiga/dev/rtc.h>
#include <amiga/dev/zbusvar.h>

#if defined(PROF) && defined(PROFTIMER)
#include <sys/PROF.h>
#endif

/* the clocks run at NTSC: 715.909kHz or PAL: 709.379kHz. 
   We're using a 100 Hz clock. */

#define CLK_INTERVAL amiga_clk_interval
int amiga_clk_interval;
int eclockfreq;
struct CIA *clockcia;

#if defined(IPL_REMAP_1) || defined(IPL_REMAP_2)
/*
 * The INT6 handler copies the clockframe from the stack in here as hardclock
 * may be delayed by the IPL-remapping code.  At that time the original stack
 * location will no longer be valid.
 */
struct clockframe hardclock_frame;
#endif

/*
 * Machine-dependent clock routines.
 *
 * Startrtclock restarts the real-time clock, which provides
 * hardclock interrupts to kern_clock.c.
 *
 * Inittodr initializes the time of day hardware which provides
 * date functions.
 *
 * Resettodr restores the time of day hardware after a time change.
 *
 * A note on the real-time clock:
 * We actually load the clock with CLK_INTERVAL-1 instead of CLK_INTERVAL.
 * This is because the counter decrements to zero after N+1 enabled clock
 * periods where N is the value loaded into the counter.
 */

int clockmatch(struct device *, void *, void *);
void clockattach(struct device *, struct device *, void *);
void cpu_initclocks(void);
void calibrate_delay(struct device *);
int clockintr(void *);

struct cfattach clock_ca = {
	sizeof(struct device), clockmatch, clockattach
};

struct cfdriver clock_cd = {
	NULL, "clock", DV_DULL, NULL, 0 };

int
clockmatch(pdp, match, auxp)
	struct device *pdp;
	void *match, *auxp;
{

	if (matchname("clock", auxp))
		return(1);
	return(0);
}

/*
 * Start the real-time clock.
 */
void
clockattach(pdp, dp, auxp)
	struct device *pdp, *dp;
	void *auxp;
{
	char *clockchip;
	unsigned short interval;
#ifdef DRACO
	u_char dracorev;
#endif

	if (eclockfreq == 0)
		eclockfreq = 715909;	/* guess NTSC */
		
	CLK_INTERVAL = (eclockfreq / 100);

#ifdef DRACO
	dracorev = is_draco();
	if (dracorev >= 4) {
		CLK_INTERVAL = (eclockfreq / 700);
		clockchip = "QuickLogic";
	} else if (dracorev) {
		clockcia = (struct CIA *)CIAAbase;
		clockchip = "CIA A";
	} else 
#endif
	{
		clockcia = (struct CIA *)CIABbase;
		clockchip = "CIA B";
	}

	if (dp)
		printf(": %s system hz %d hardware hz %d\n", clockchip, hz,
#ifdef DRACO
		dracorev >= 4 ? eclockfreq / 7 : eclockfreq);
#else
		eclockfreq);
#endif

#ifdef DRACO
	if (dracorev >= 4) {
		/* 
		 * can't preload anything beforehand, timer is free_running;
		 * but need this for delay calibration.
		 */

		draco_ioct->io_timerlo = CLK_INTERVAL & 0xff;
		draco_ioct->io_timerhi = CLK_INTERVAL >> 8;

		calibrate_delay(dp);

		return;
	}
#endif

	/*
	 * stop timer A 
	 */
	clockcia->cra = clockcia->cra & 0xc0;
	clockcia->icr = 1 << 0;		/* disable timer A interrupt */
	interval = clockcia->icr;		/* and make sure it's clear */

	/*
	 * load interval into registers.
         * the clocks run at NTSC: 715.909kHz or PAL: 709.379kHz
	 * supprort for PAL WHEN?!?! XXX
	 */
	interval = CLK_INTERVAL - 1;

	/*
	 * order of setting is important !
	 */
	clockcia->talo = interval & 0xff;
	clockcia->tahi = interval >> 8;

	/*
	 * start timer A in continuous mode
	 */
	clockcia->cra = (clockcia->cra & 0xc0) | 1;

	calibrate_delay(dp);
}

#if defined(IPL_REMAP_1) || defined(IPL_REMAP_2)
int
clockintr (arg)
	void *arg;
{
	/* Is it a timer A interrupt? */
	if (ciab.icr & 1) {
		hardclock(&hardclock_frame);
		return 1;
	}
	return 0;
}
#endif

/*
 * Calibrate delay loop.
 * We use two iterations because we don't have enough bits to do a factor of
 * 8 with better than 1%.
 *
 * XXX Note that we MUST stay below 1 tick if using clkread(), even for 
 * underestimated values of delaydivisor. 
 *
 * XXX the "ns" below is only correct for a shift of 10 bits, and even then
 * off by 2.4%
 */

void calibrate_delay(dp)
	struct device *dp;
{
	unsigned long t1, t2;
	extern u_int32_t delaydivisor;
		/* XXX this should be defined elsewhere */

	if (dp)
		printf("Calibrating delay loop... "); 

	do {
		t1 = clkread();
		delay(1024);
		t2 = clkread();
	} while (t2 <= t1);
	t2 -= t1;
	delaydivisor = (delaydivisor * t2 + 1023) >> 10;
#ifdef DIAGNOSTIC
	if (dp)
		printf("\ndiff %ld us, new divisor %u/1024 us\n", t2,
		    delaydivisor); 
	do {
		t1 = clkread();
		delay(1024);
		t2 = clkread();
	} while (t2 <= t1);
	t2 -= t1;
	delaydivisor = (delaydivisor * t2 + 1023) >> 10;
	if (dp)
		printf("diff %ld us, new divisor %u/1024 us\n", t2,
		    delaydivisor); 
#endif
	do {
		t1 = clkread();
		delay(1024);
		t2 = clkread();
	} while (t2 <= t1);
	t2 -= t1;
	delaydivisor = (delaydivisor * t2 + 1023) >> 10;
#ifdef DIAGNOSTIC
	if (dp)
		printf("diff %ld us, new divisor ", t2);
#endif
	if (dp)
		printf("%u/1024 us\n", delaydivisor); 
}

void
cpu_initclocks()
{
#if defined(IPL_REMAP_1) || defined(IPL_REMAP_2)
	static struct isr isr;
#endif

#ifdef DRACO
	unsigned char dracorev;

	dracorev = is_draco();
	if (dracorev >= 4) {
		draco_ioct->io_timerlo = CLK_INTERVAL & 0xFF;
		draco_ioct->io_timerhi = CLK_INTERVAL >> 8;
		draco_ioct->io_timerrst = 0;	/* any value resets */
		draco_ioct->io_status2 |= DRSTAT2_TMRINTENA;

		return;
	}
#endif

	/*
	 * enable interrupts for timer A
	 */
	clockcia->icr = (1<<7) | (1<<0);

	/*
	 * start timer A in continuous shot mode
	 */
	clockcia->cra = (clockcia->cra & 0xc0) | 1;
  
#if defined(IPL_REMAP_1) || defined(IPL_REMAP_2)
	isr.isr_intr = clockintr;
	isr.isr_ipl = 6;
	isr.isr_mapped_ipl = IPL_CLOCK;
	add_isr(&isr);
#else
	/*
	 * and globally enable interrupts for ciab
	 */
#ifdef DRACO
	if (dracorev)		/* we use cia a on DraCo */
		*draco_intena |= DRIRQ_INT2;
	else
#endif
		custom.intena = INTF_SETCLR | INTF_EXTER;
#endif
}

void
setstatclockrate(hz)
	int hz;
{
}

/*
 * Returns number of usec since last recorded clock "tick"
 * (i.e. clock interrupt).
 */
u_long
clkread()
{
	u_int interval;
	u_char hi, hi2, lo;

#ifdef DRACO
	if (is_draco() >= 4) {
		hi2 = draco_ioct->io_chiprev;	/* latch timer */
		hi = draco_ioct->io_timerhi;
		lo = draco_ioct->io_timerlo;
		interval = ((hi<<8) | lo);
		if (interval > CLK_INTERVAL)	/* timer underflow */
			interval = 65536 + CLK_INTERVAL - interval;
		else
			interval = CLK_INTERVAL - interval;

	} else
#endif
	{
		hi  = clockcia->tahi;
		lo  = clockcia->talo;
		hi2 = clockcia->tahi;
		if (hi != hi2) {
			lo = clockcia->talo;
			hi = hi2;
		}

		interval = (CLK_INTERVAL - 1) - ((hi<<8) | lo);
   
		/*
		 * should read ICR and if there's an int pending, adjust
		 * interval. However, since reading ICR clears the interrupt,
		 * we'd lose a hardclock int, and this is not tolerable.
		 */
	}

	return((interval * tick) / CLK_INTERVAL);
}

#if notyet

/* implement this later. I'd suggest using both timers in CIA-A, they're
   not yet used. */

#include "clock.h"
#if NCLOCK > 0
/*
 * /dev/clock: mappable high resolution timer.
 *
 * This code implements a 32-bit recycling counter (with a 4 usec period)
 * using timers 2 & 3 on the 6840 clock chip.  The counter can be mapped
 * RO into a user's address space to achieve low overhead (no system calls),
 * high-precision timing.
 *
 * Note that timer 3 is also used for the high precision profiling timer
 * (PROFTIMER code above).  Care should be taken when both uses are
 * configured as only a token effort is made to avoid conflicting use.
 */
#include <sys/proc.h>
#include <sys/resourcevar.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <uvm/uvm_extern.h>
#include <amiga/amiga/clockioctl.h>
#include <sys/specdev.h>
#include <sys/vnode.h>
#include <sys/mman.h>

int clockon = 0;		/* non-zero if high-res timer enabled */
#ifdef PROFTIMER
int  profprocs = 0;		/* # of procs using profiling timer */
#endif
#ifdef DEBUG
int clockdebug = 0;
#endif

/*ARGSUSED*/
clockopen(dev, flags)
	dev_t dev;
{
#ifdef PROFTIMER
#ifdef PROF
	/*
	 * Kernel profiling enabled, give up.
	 */
	if (profiling)
		return(EBUSY);
#endif
	/*
	 * If any user processes are profiling, give up.
	 */
	if (profprocs)
		return(EBUSY);
#endif
	if (!clockon) {
		startclock();
		clockon++;
	}
	return(0);
}

/*ARGSUSED*/
clockclose(dev, flags)
	dev_t dev;
{
	(void) clockunmmap(dev, (caddr_t)0, curproc);	/* XXX */
	stopclock();
	clockon = 0;
	return(0);
}

/*ARGSUSED*/
clockioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	struct proc *p;
{
	int error = 0;
	
	switch (cmd) {

	case CLOCKMAP:
		error = clockmmap(dev, (caddr_t *)data, p);
		break;

	case CLOCKUNMAP:
		error = clockunmmap(dev, *(caddr_t *)data, p);
		break;

	case CLOCKGETRES:
		*(int *)data = CLK_RESOLUTION;
		break;

	default:
		error = EINVAL;
		break;
	}
	return(error);
}

/*ARGSUSED*/
clockmap(dev, off, prot)
	dev_t dev;
{
	return((off + (INTIOBASE+CLKBASE+CLKSR-1)) >> PGSHIFT);
}

clockmmap(dev, addrp, p)
	dev_t dev;
	caddr_t *addrp;
	struct proc *p;
{
	int error;
	struct vnode vn;
	struct specinfo si;
	int flags;

	flags = MAP_FILE|MAP_SHARED;
	if (*addrp)
		flags |= MAP_FIXED;
	else
		*addrp = (caddr_t)0x1000000;	/* XXX */
	vn.v_type = VCHR;			/* XXX */
	vn.v_specinfo = &si;			/* XXX */
	vn.v_rdev = dev;			/* XXX */
	error = vm_mmap(&p->p_vmspace->vm_map, (vm_offset_t *)addrp,
			PAGE_SIZE, VM_PROT_ALL, flags, (caddr_t)&vn, 0);
	return(error);
}

clockunmmap(dev, addr, p)
	dev_t dev;
	caddr_t addr;
	struct proc *p;
{
	int rv;

	if (addr == 0)
		return(EINVAL);		/* XXX: how do we deal with this? */
	uvm_deallocate(p->p_vmspace->vm_map, (vm_offset_t)addr, PAGE_SIZE);
	return (0);
}

startclock()
{
	register struct clkreg *clk = (struct clkreg *)clkstd[0];

	clk->clk_msb2 = -1; clk->clk_lsb2 = -1;
	clk->clk_msb3 = -1; clk->clk_lsb3 = -1;

	clk->clk_cr2 = CLK_CR3;
	clk->clk_cr3 = CLK_OENAB|CLK_8BIT;
	clk->clk_cr2 = CLK_CR1;
	clk->clk_cr1 = CLK_IENAB;
}

stopclock()
{
	register struct clkreg *clk = (struct clkreg *)clkstd[0];

	clk->clk_cr2 = CLK_CR3;
	clk->clk_cr3 = 0;
	clk->clk_cr2 = CLK_CR1;
	clk->clk_cr1 = CLK_IENAB;
}
#endif

#endif


#ifdef PROFTIMER
/*
 * This code allows the amiga kernel to use one of the extra timers on
 * the clock chip for profiling, instead of the regular system timer.
 * The advantage of this is that the profiling timer can be turned up to
 * a higher interrupt rate, giving finer resolution timing. The profclock
 * routine is called from the lev6intr in locore, and is a specialized
 * routine that calls addupc_task. The overhead then is far less than if
 * hardclock/softclock was called. Further, the context switch code in
 * locore has been changed to turn the profile clock on/off when switching
 * into/out of a process that is profiling (startprofclock/stopprofclock).
 * This reduces the impact of the profiling clock on other users, and might
 * possibly increase the accuracy of the profiling. 
 */
int  profint   = PRF_INTERVAL;	/* Clock ticks between interrupts */
int  profscale = 0;		/* Scale factor from sys clock to prof clock */
char profon    = 0;		/* Is profiling clock on? */

/* profon values - do not change, locore.s assumes these values */
#define PRF_NONE	0x00
#define	PRF_USER	0x01
#define	PRF_KERNEL	0x80

initprofclock()
{
#if NCLOCK > 0
	struct proc *p = curproc;		/* XXX */

	/*
	 * If the high-res timer is running, force profiling off.
	 * Unfortunately, this gets reflected back to the user not as
	 * an error but as a lack of results.
	 */
	if (clockon) {
		p->p_stats->p_prof.pr_scale = 0;
		return;
	}
	/*
	 * Keep track of the number of user processes that are profiling
	 * by checking the scale value.
	 *
	 * XXX: this all assumes that the profiling code is well behaved;
	 * i.e. profil() is called once per process with pcscale non-zero
	 * to turn it on, and once with pcscale zero to turn it off.
	 * Also assumes you don't do any forks or execs.  Oh well, there
	 * is always adb...
	 */
	if (p->p_stats->p_prof.pr_scale)
		profprocs++;
	else
		profprocs--;
#endif
	/*
	 * The profile interrupt interval must be an even divisor
	 * of the CLK_INTERVAL so that scaling from a system clock
	 * tick to a profile clock tick is possible using integer math.
	 */
	if (profint > CLK_INTERVAL || (CLK_INTERVAL % profint) != 0)
		profint = CLK_INTERVAL;
	profscale = CLK_INTERVAL / profint;
}

startprofclock()
{
  unsigned short interval;

  /* stop timer B */
  clockcia->crb = clockcia->crb & 0xc0;

  /* load interval into registers.
     the clocks run at NTSC: 715.909kHz or PAL: 709.379kHz */

  interval = profint - 1;

  /* order of setting is important ! */
  clockcia->tblo = interval & 0xff;
  clockcia->tbhi = interval >> 8;

  /* enable interrupts for timer B */
  clockcia->icr = (1<<7) | (1<<1);

  /* start timer B in continuous shot mode */
  clockcia->crb = (clockcia->crb & 0xc0) | 1;
}

stopprofclock()
{
  /* stop timer B */
  clockcia->crb = clockcia->crb & 0xc0;
}

#ifdef PROF
/*
 * profclock() is expanded in line in lev6intr() unless profiling kernel.
 * Assumes it is called with clock interrupts blocked.
 */
profclock(pc, ps)
	caddr_t pc;
	int ps;
{
	/*
	 * Came from user mode.
	 * If this process is being profiled record the tick.
	 */
	if (USERMODE(ps)) {
		if (p->p_stats.p_prof.pr_scale)
			addupc_task(&curproc, pc, 1);
	}
	/*
	 * Came from kernel (supervisor) mode.
	 * If we are profiling the kernel, record the tick.
	 */
	else if (profiling < 2) {
		register int s = pc - s_lowpc;

		if (s < s_textsize)
			kcount[s / (HISTFRACTION * sizeof (*kcount))]++;
	}
	/*
	 * Kernel profiling was on but has been disabled.
	 * Mark as no longer profiling kernel and if all profiling done,
	 * disable the clock.
	 */
	if (profiling && (profon & PRF_KERNEL)) {
		profon &= ~PRF_KERNEL;
		if (profon == PRF_NONE)
			stopprofclock();
	}
}
#endif
#endif

/*
 * Initialize the time of day register, based on the time base which is, e.g.
 * from a filesystem.
 */
void
inittodr(base)
	time_t base;
{
	time_t timbuf = base;	/* assume no battery clock exists */
  
	if (gettod == NULL)
		printf("WARNING: no battery clock\n");
	else
		timbuf = gettod();
  
	if (timbuf < base) {
		printf("WARNING: bad date in battery clock\n");
		timbuf = base;
	}
  
	/* Battery clock does not store usec's, so forget about it. */
	time.tv_sec = timbuf;
}

void
resettodr()
{
	if (settod && settod(time.tv_sec) == 0)
		printf("Cannot set battery backed clock\n");
}
@


1.16
log
@Eliminate the use of KERN_SUCCESS outside of uvm/

Also uvm_map returns KERN_* codes that are directly mapped to
errnos, so we can return them instead of doing some attempt to
translation.

drahn@@ "I see no problem" pval@@ "makes sense"
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.15 2002/03/14 01:26:28 millert Exp $	*/
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.14 2002/01/24 20:31:08 miod Exp $	*/
d524 2
a525 2
	rv = vm_deallocate(p->p_vmspace->vm_map, (vm_offset_t)addr, PAGE_SIZE);
	return(rv == KERN_SUCCESS ? 0 : EINVAL);
@


1.14
log
@Don't provide a duplicate addupc_task() routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.13 2001/12/19 08:58:05 art Exp $	*/
d101 5
a105 5
int clockmatch __P((struct device *, void *, void *));
void clockattach __P((struct device *, struct device *, void *));
void cpu_initclocks __P((void));
void calibrate_delay __P((struct device *));
int clockintr __P((void *));
@


1.13
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.11 2001/11/06 19:53:14 miod Exp $	*/
d562 1
a562 1
 * routine that calls addupc. The overhead then is far less than if
d661 1
a661 1
			addupc(pc, &curproc->p_stats.p_prof, 1);
@


1.12
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d524 2
a525 2
	uvm_deallocate(p->p_vmspace->vm_map, (vm_offset_t)addr, PAGE_SIZE);
	return (0);
@


1.12.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.14 2002/01/24 20:31:08 miod Exp $	*/
d562 1
a562 1
 * routine that calls addupc_task. The overhead then is far less than if
d661 1
a661 1
			addupc_task(&curproc, pc, 1);
@


1.12.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.12.2.1 2002/01/31 22:55:07 niklas Exp $	*/
d101 5
a105 5
int clockmatch(struct device *, void *, void *);
void clockattach(struct device *, struct device *, void *);
void cpu_initclocks(void);
void calibrate_delay(struct device *);
int clockintr(void *);
@


1.12.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.12.2.2 2002/06/11 03:34:57 art Exp $	*/
@


1.11
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.10 1997/09/18 13:39:43 niklas Exp $	*/
d524 2
a525 2
	rv = vm_deallocate(p->p_vmspace->vm_map, (vm_offset_t)addr, PAGE_SIZE);
	return(rv == KERN_SUCCESS ? 0 : EINVAL);
@


1.10
log
@Merge of NetBSD changes upto last week or so, with the exception of stand/
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.9 1997/01/16 09:23:52 niklas Exp $	*/
d406 1
a406 1
#include <vm/vm.h>
@


1.10.12.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d406 1
a406 1
#include <uvm/uvm_extern.h>
@


1.10.12.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.10.12.1 2001/11/13 21:00:50 niklas Exp $	*/
d524 2
a525 2
	uvm_deallocate(p->p_vmspace->vm_map, (vm_offset_t)addr, PAGE_SIZE);
	return (0);
@


1.10.12.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d524 2
a525 2
	rv = vm_deallocate(p->p_vmspace->vm_map, (vm_offset_t)addr, PAGE_SIZE);
	return(rv == KERN_SUCCESS ? 0 : EINVAL);
d562 1
a562 1
 * routine that calls addupc_task. The overhead then is far less than if
d661 1
a661 1
			addupc_task(&curproc, pc, 1);
@


1.10.12.4
log
@Merge in -current from about a week ago
@
text
@d101 5
a105 5
int clockmatch(struct device *, void *, void *);
void clockattach(struct device *, struct device *, void *);
void cpu_initclocks(void);
void calibrate_delay(struct device *);
int clockintr(void *);
@


1.10.12.5
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.10.12.4 2002/03/28 10:06:14 niklas Exp $	*/
@


1.9
log
@Sync to NetBSD 970110
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.8 1996/06/04 13:28:39 niklas Exp $	*/
d103 1
a104 1
void cpu_initclocks __P((void));
d291 14
a686 12
/* this is a hook set by a clock driver for the configured realtime clock,
   returning plain current unix-time */
long (*gettod) __P((void));
int (*settod) __P((long));
void *clockaddr;

long a3gettod __P((void));
long a2gettod __P((void));
int a3settod __P((long));
int a2settod __P((long));
int rtcinit __P((void));

d695 1
a695 1
	u_long timbuf = base;	/* assume no battery clock exists */
d697 1
a697 1
	if (gettod == NULL && rtcinit() == 0)
a715 316
}

int
rtcinit()
{
	clockaddr = (void *)ztwomap(0xdc0000);
#ifdef DRACO
	if (is_draco()) {
		/* XXX to be done */
		gettod = (void *)0;
		settod = (void *)0;
		return 0;
	} else
#endif
	if (is_a3000() || is_a4000()) {
		if (a3gettod() == 0)
			return(0);
		gettod = a3gettod;
		settod = a3settod;
	} else {
		if (a2gettod() == 0)
			return(0);
		gettod = a2gettod;
		settod = a2settod;
	}
	return(1);
}

static int month_days[12] = {
	31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};

long
a3gettod()
{
	struct rtclock3000 *rt;
	int i, year, month, day, wday, hour, min, sec;
	u_long tmp;

	rt = clockaddr;

	/* hold clock */
	rt->control1 = A3CONTROL1_HOLD_CLOCK;

	/* read it */
	sec   = rt->second1 * 10 + rt->second2;
	min   = rt->minute1 * 10 + rt->minute2;
	hour  = rt->hour1   * 10 + rt->hour2;
	wday  = rt->weekday;
	day   = rt->day1    * 10 + rt->day2;
	month = rt->month1  * 10 + rt->month2;
	year  = rt->year1   * 10 + rt->year2   + 1900;

	/* let it run again.. */
	rt->control1 = A3CONTROL1_FREE_CLOCK;

	if (range_test(hour, 0, 23))
		return(0);
	if (range_test(wday, 0, 6))
		return(0);
	if (range_test(day, 1, 31))
		return(0);
	if (range_test(month, 1, 12))
		return(0);
	if (range_test(year, STARTOFTIME, 2000))
		return(0);

	tmp = 0;

	for (i = STARTOFTIME; i < year; i++)
		tmp += days_in_year(i);
	if (leapyear(year) && month > FEBRUARY)
		tmp++;

	for (i = 1; i < month; i++)
		tmp += days_in_month(i);

	tmp += (day - 1);
	tmp = ((tmp * 24 + hour) * 60 + min) * 60 + sec;

	return(tmp);
}

int
a3settod(tim)
	long tim;
{
	register int i;
	register long hms, day;
	u_char sec1, sec2;
	u_char min1, min2;
	u_char hour1, hour2;
/*	u_char wday; */
	u_char day1, day2;
	u_char mon1, mon2;
	u_char year1, year2;
	struct rtclock3000 *rt;

	rt = clockaddr;
	/*
	 * there seem to be problems with the bitfield addressing
	 * currently used..
	 */

	if (! rt)
		return 0;

	/* prepare values to be written to clock */
	day = tim / SECDAY;
	hms = tim % SECDAY;

	hour2 = hms / 3600;
	hour1 = hour2 / 10;
	hour2 %= 10;

	min2 = (hms % 3600) / 60;
	min1 = min2 / 10;
	min2 %= 10;


	sec2 = (hms % 3600) % 60;
	sec1 = sec2 / 10;
	sec2 %= 10;

	/* Number of years in days */
	for (i = STARTOFTIME - 1900; day >= days_in_year(i); i++)
		day -= days_in_year(i);
	year1 = i / 10;
	year2 = i % 10;

	/* Number of months in days left */
	if (leapyear(i))
		days_in_month(FEBRUARY) = 29;
	for (i = 1; day >= days_in_month(i); i++)
		day -= days_in_month(i);
	days_in_month(FEBRUARY) = 28;

	mon1 = i / 10;
	mon2 = i % 10;

	/* Days are what is left over (+1) from all that. */
	day ++;
	day1 = day / 10;
	day2 = day % 10;

	rt->control1 = A3CONTROL1_HOLD_CLOCK;
	rt->second1 = sec1;
	rt->second2 = sec2;
	rt->minute1 = min1;
	rt->minute2 = min2;
	rt->hour1   = hour1;
	rt->hour2   = hour2;
/*	rt->weekday = wday; */
	rt->day1    = day1;
	rt->day2    = day2;
	rt->month1  = mon1;
	rt->month2  = mon2;
	rt->year1   = year1;
	rt->year2   = year2;
	rt->control1 = A3CONTROL1_FREE_CLOCK;

	return 1;
}

long
a2gettod()
{
	struct rtclock2000 *rt;
	int i, year, month, day, hour, min, sec;
	u_long tmp;

	rt = clockaddr;

	/*
	 * hold clock
	 */
	rt->control1 |= A2CONTROL1_HOLD;
	i = 0x1000;
	while (rt->control1 & A2CONTROL1_BUSY && i--)
		;
	if (rt->control1 & A2CONTROL1_BUSY)
		return (0);	/* Give up and say it's not there */

	/*
	 * read it
	 */
	sec = rt->second1 * 10 + rt->second2;
	min = rt->minute1 * 10 + rt->minute2;
	hour = (rt->hour1 & 3)  * 10 + rt->hour2;
	day = rt->day1 * 10 + rt->day2;
	month = rt->month1 * 10 + rt->month2;
	year = rt->year1 * 10 + rt->year2   + 1900;

	if ((rt->control3 & A2CONTROL3_24HMODE) == 0) {
		if ((rt->hour1 & A2HOUR1_PM) == 0 && hour == 12)
			hour = 0;
		else if ((rt->hour1 & A2HOUR1_PM) && hour != 12)
			hour += 12;
	}

	/* 
	 * release the clock 
	 */
	rt->control1 &= ~A2CONTROL1_HOLD;

	if (range_test(hour, 0, 23))
		return(0);
	if (range_test(day, 1, 31))
		return(0);
	if (range_test(month, 1, 12))
		return(0);
	if (range_test(year, STARTOFTIME, 2000))
		return(0);
  
	tmp = 0;
  
	for (i = STARTOFTIME; i < year; i++)
		tmp += days_in_year(i);
	if (leapyear(year) && month > FEBRUARY)
		tmp++;
  
	for (i = 1; i < month; i++)
		tmp += days_in_month(i);
  
	tmp += (day - 1);
	tmp = ((tmp * 24 + hour) * 60 + min) * 60 + sec;
  
	return(tmp);
}

/*
 * there is some question as to whether this works
 * I guess
 */
int
a2settod(tim)
	long tim;
{

	int i;
	long hms, day;
	u_char sec1, sec2;
	u_char min1, min2;
	u_char hour1, hour2;
	u_char day1, day2;
	u_char mon1, mon2;
	u_char year1, year2;
	struct rtclock2000 *rt;

	rt = clockaddr;
	/* 
	 * there seem to be problems with the bitfield addressing
	 * currently used..
	 *
	 * XXX Check out the above where we (hour1 & 3)
	 */
	if (! rt)
		return 0;

	/* prepare values to be written to clock */
	day = tim / SECDAY;
	hms = tim % SECDAY;

	hour2 = hms / 3600;
	hour1 = hour2 / 10;
	hour2 %= 10;

	min2 = (hms % 3600) / 60;
	min1 = min2 / 10;
	min2 %= 10;


	sec2 = (hms % 3600) % 60;
	sec1 = sec2 / 10;
	sec2 %= 10;

	/* Number of years in days */
	for (i = STARTOFTIME - 1900; day >= days_in_year(i); i++)
		day -= days_in_year(i);
	year1 = i / 10;
	year2 = i % 10;

	/* Number of months in days left */
	if (leapyear(i))
		days_in_month(FEBRUARY) = 29;
	for (i = 1; day >= days_in_month(i); i++)
		day -= days_in_month(i);
	days_in_month(FEBRUARY) = 28;

	mon1 = i / 10;
	mon2 = i % 10;
  
	/* Days are what is left over (+1) from all that. */
	day ++;
	day1 = day / 10;
	day2 = day % 10;

	/* 
	 * XXXX spin wait as with reading???
	 */
	rt->control1 |= A2CONTROL1_HOLD;
	rt->second1 = sec1;
	rt->second2 = sec2;
	rt->minute1 = min1;
	rt->minute2 = min2;
	rt->hour1   = hour1;
	rt->hour2   = hour2;
	rt->day1    = day1;
	rt->day2    = day2;
	rt->month1  = mon1;
	rt->month2  = mon2;
	rt->year1   = year1;
	rt->year2   = year2;
	rt->control2 &= ~A2CONTROL1_HOLD;

	return 1;
@


1.8
log
@Cleanup for -Wall & -Wstrict-prototypes. clockcia is a pointer, not a struct
@
text
@d1 2
a2 2
/*	$OpenBSD: clock.c,v 1.7 1996/05/29 10:14:49 niklas Exp $	*/
/*	$NetBSD: clock.c,v 1.15 1996/05/10 14:30:53 is Exp $	*/
d103 1
a104 1
void setmicspertick __P((void));
d120 1
a120 5
	if (matchname("clock", auxp)
#ifdef DRACO
	    && (is_draco() < 4)
#endif
	    )
d133 1
d135 3
a137 1
	char cia;
d145 5
a149 1
	if (is_draco()) {
d151 1
a151 1
		cia = 'A';
d156 1
a156 1
		cia = 'B';
d159 23
a181 1
	printf(": CIA %c system hz %d hardware hz %d\n", cia, hz, eclockfreq);
d202 7
d225 59
d311 1
a311 1
	if (is_draco())		/* we use cia a on DraCo */
d332 1
a333 20
	u_int interval;
   
	hi  = clockcia->tahi;
	lo  = clockcia->talo;
	hi2 = clockcia->tahi;
	if (hi != hi2) {
		lo = clockcia->talo;
		hi = hi2;
	}

	interval = (CLK_INTERVAL - 1) - ((hi<<8) | lo);
   
	/*
	 * should read ICR and if there's an int pending, adjust interval.
	 * However, * since reading ICR clears the interrupt, we'd lose a
	 * hardclock int, and * this is not tolerable.
	 */

	return((interval * tick) / CLK_INTERVAL);
}
a334 9
u_int micspertick;

/*
 * we set up as much of the CIAa as possible
 * as all access to chip memory are very slow.
 */
void
setmicspertick()
{
d336 9
a344 4
	if (is_draco())
		return;	/* XXX */
#endif
	micspertick = (1000000ULL << 20) / 715909;
d346 1
a346 38
	/*
	 * disable interrupts (just in case.)
	 */
	ciaa.icr = 0x3;

	/*
	 * stop both timers if not already
	 */
	ciaa.cra &= ~1;
	ciaa.crb &= ~1;

	/*
	 * set timer B in "count timer A underflows" mode
	 * set timer A in one-shot mode
	 */
	ciaa.crb = (ciaa.crb & 0x80) | 0x48;
	ciaa.cra = (ciaa.cra & 0xc0) | 0x08;
}

/*
 * this function assumes that on any entry beyond the first
 * the following condintions exist:
 * Interrupts for Timers A and B are disabled.
 * Timers A and B are stoped. 
 * Timers A and B are in one-shot mode with B counting timer A underflows
 *
 */
void
delay(mic)
	u_int mic;
{
	u_int temp;

#ifdef DRACO
	if (is_draco()) {
		DELAY(mic);
		return;
	}
d348 8
a355 18
	if (micspertick == 0)
		setmicspertick();

	if (mic <= 1)
		return;

	/*
	 * basically this is going to do an integer
	 * usec / (1000000 / 715909) with no loss of
	 * precision
	 */
	temp = mic >> 12;
	asm("divul %3,%1:%0" : "=d" (temp) : "d" (mic >> 12), "0" (mic << 20),
	    "d" (micspertick));

	if ((temp & 0xffff0000) > 0x10000) {
		mic = (temp >> 16) - 1;
		temp &= 0xffff;
d357 2
d360 3
a362 1
		 * set timer A in continous mode
a363 38
		ciaa.cra = (ciaa.cra & 0xc0) | 0x00;
	
		/*
		 * latch/load/start "counts of timer A underflows" in B
		 */
		ciaa.tblo = mic & 0xff;
		ciaa.tbhi = mic >> 8;
		
		/*
		 * timer A latches 0xffff
		 * and start it.
		 */
		ciaa.talo = 0xff;
		ciaa.tahi = 0xff;
		ciaa.cra |= 1;

		while (ciaa.crb & 1)
			;

		/* 
		 * stop timer A 
		 */
		ciaa.cra &= ~1;

		/*
		 * set timer A in one shot mode
		 */
		ciaa.cra = (ciaa.cra & 0xc0) | 0x08;
	} else if ((temp & 0xffff0000) == 0x10000) {
		temp &= 0xffff;

		/*
		 * timer A is in one shot latch/load/start 1 full turn
		 */
		ciaa.talo = 0xff;
		ciaa.tahi = 0xff;
		while (ciaa.cra & 1)
			;
a364 2
	if (temp < 1)
		return;
d366 1
a366 38
	/*
	 * temp is now residual ammount, latch/load/start it.
	 */
	ciaa.talo = temp & 0xff;
	ciaa.tahi = temp >> 8;
	while (ciaa.cra & 1)
		;
}

/*
 * Needs to be calibrated for use, its way off most of the time
 */
void
DELAY(mic)
	u_int mic;
{
	u_long n;
	short hpos;

#ifdef DRACO
	if (is_draco()) {
		while (--mic > 0)
			n = *draco_intena;
		return;
	}
#endif
	/*
	 * this function uses HSync pulses as base units. The custom chips 
	 * display only deals with 31.6kHz/2 refresh, this gives us a
	 * resolution of 1/15800 s, which is ~63us (add some fuzz so we really
	 * wait awhile, even if using small timeouts)
	 */
	n = mic/63 + 2;
	do {
		hpos = custom.vhposr & 0xff00;
		while (hpos == (custom.vhposr & 0xff00))
			;
	} while (n--);
d1029 1
a1029 1
  return 1;
@


1.7
log
@Merge of 960526 NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: clock.c,v 1.4 1996/04/21 22:15:01 deraadt Exp $	*/
a66 2
extern void hardclock();

d105 1
d181 2
a182 1
clockintr ()
d203 1
a203 1
	clcokcia.icr = (1<<7) | (1<<0);
d208 1
a208 1
	clockcia.cra = (clockcia.cra & 0xc0) | 1;
@


1.6
log
@Sync with NetBSD 9600430.  The port has gone over a major -Wall treat
@
text
@d2 1
a2 1
/*	$NetBSD: clock.c,v 1.13 1996/04/21 21:10:57 veego Exp $	*/
d56 3
d75 1
d121 5
a125 1
	if (matchname("clock", auxp))
d139 1
d146 12
a157 1
	printf(": system hz %d hardware hz %d\n", hz, eclockfreq);
d162 3
a164 3
	ciab.cra = ciab.cra & 0xc0;
	ciab.icr = 1 << 0;		/* disable timer A interrupt */
	interval = ciab.icr;		/* and make sure it's clear */
d176 2
a177 2
	ciab.talo = interval & 0xff;
	ciab.tahi = interval >> 8;
d203 1
a203 1
	ciab.icr = (1<<7) | (1<<0);
d208 1
a208 1
	ciab.cra = (ciab.cra & 0xc0) | 1;
d219 6
a224 1
	custom.intena = INTF_SETCLR | INTF_EXTER;
d244 3
a246 3
	hi  = ciab.tahi;
	lo  = ciab.talo;
	hi2 = ciab.tahi;
d248 1
a248 1
		lo = ciab.talo;
d272 4
d311 6
d400 7
d660 1
a660 1
  ciab.crb = ciab.crb & 0xc0;
d668 2
a669 2
  ciab.tblo = interval & 0xff;
  ciab.tbhi = interval >> 8;
d672 1
a672 1
  ciab.icr = (1<<7) | (1<<1);
d675 1
a675 1
  ciab.crb = (ciab.crb & 0xc0) | 1;
d681 1
a681 1
  ciab.crb = ciab.crb & 0xc0;
d772 8
@


1.5
log
@Bring forward the Amiga ISA support, and resolve a conflict with if_ed
@
text
@d2 1
a2 1
/*	$NetBSD: clock.c,v 1.12 1996/03/17 05:58:30 mhitch Exp $	*/
d49 1
d101 2
a115 1
	struct cfdata *cfp = match;
d203 1
d213 1
a280 1
	int s;
d699 1
d719 1
d722 2
a723 3
	if (settod && settod(time.tv_sec) == 1)
		return;
	printf("Cannot set battery backed clock\n");
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 1
@


1.3
log
@Use IPL_ constants instead of numeric values.  Get rid of sicallbacks
in favour of the remapped IPL facility.  Some argument type fixes as
well.
@
text
@d1 2
a2 1
/*	$NetBSD: clock.c,v 1.10 1995/02/20 00:53:42 chopps Exp $	*/
d97 1
a97 1
int clockmatch __P((struct device *, struct cfdata *, void *));
d100 6
a105 3
struct cfdriver clockcd = {
	NULL, "clock", (cfmatch_t)clockmatch, clockattach, 
	DV_DULL, sizeof(struct device), NULL, 0 };
d108 1
a108 1
clockmatch(pdp, cfp, auxp)
d110 1
a110 2
	struct cfdata *cfp;
	void *auxp;
d112 2
@


1.2
log
@Added support for a new (well, I've run it locally for a year or two)
interrupt system which is a prerequisite for the Amiga ISA support.
It is described in amiga/amiga/README.ints, and is enabled by adding
an "options IPL_REMAP_1" in the kernel config file.  Along with this
change there is also some generic cleanup, like style polishing,
comment corrections, making sicallbacks operate in FIFO manner and
cleaning up the spl mess in param.h...
@
text
@d185 1
a185 1
	isr.isr_mapped_ipl = 4;
d268 1
a268 1
	int mic;
d351 1
a351 1
	int mic;
@


1.1
log
@Initial revision
@
text
@d53 1
d61 2
d70 9
d152 13
d168 4
d182 6
d192 1
d252 1
a252 1
	 * set tiemr A in one-shot mode
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
