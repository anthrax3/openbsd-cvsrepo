head	1.11;
access;
symbols
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.8.0.4
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.10
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.8
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2002.12.31.16.35.38;	author miod;	state dead;
branches;
next	1.10;

1.10
date	2002.06.11.03.25.43;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.29;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.20.19.35.18;	author miod;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.02.07.07.46.50;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.06.15.42.48;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	98.08.04.23.18.20;	author millert;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	97.01.16.09.25.09;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.05.02.06.44.24;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.22.15.41;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.01;	author deraadt;	state Exp;
branches;
next	;

1.5.8.1
date	2001.04.18.16.02.14;	author niklas;	state Exp;
branches;
next	1.5.8.2;

1.5.8.2
date	2001.10.31.02.52.45;	author nate;	state Exp;
branches;
next	1.5.8.3;

1.5.8.3
date	2002.03.28.10.06.14;	author niklas;	state Exp;
branches;
next	1.5.8.4;

1.5.8.4
date	2003.03.27.23.19.18;	author niklas;	state dead;
branches;
next	;

1.8.4.1
date	2002.06.11.03.34.58;	author art;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2002.10.29.00.28.01;	author art;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2003.05.19.21.49.39;	author tedu;	state dead;
branches;
next	;


desc
@@


1.11
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: par.c,v 1.10 2002/06/11 03:25:43 miod Exp $	*/
/*	$NetBSD: par.c,v 1.16 1996/12/23 09:10:28 veego Exp $	*/

/*
 * Copyright (c) 1982, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ppi.c	7.3 (Berkeley) 12/16/90
 */

/*
 * parallel port interface
 */

#include "par.h"
#if NPAR > 0

#include <sys/param.h>
#include <sys/errno.h>
#include <sys/uio.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/file.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/timeout.h>

#include <amiga/amiga/device.h>
#include <amiga/amiga/cia.h>
#include <amiga/dev/parioctl.h>

#include <machine/conf.h>

struct	par_softc {
	int	sc_flags;
	struct	parparam sc_param;
#define sc_burst sc_param.burst
#define sc_timo  sc_param.timo
#define sc_delay sc_param.delay
	struct	timeout sc_partimo;
	struct	timeout sc_parstart;
} *par_softcp;

#define getparsp(x)	(x > 0 ? NULL : par_softcp)

/* sc_flags values */
#define	PARF_ALIVE	0x01	
#define	PARF_OPEN	0x02	
#define PARF_UIO	0x04
#define PARF_TIMO	0x08
#define PARF_DELAY	0x10
#define PARF_OREAD	0x40
#define PARF_OWRITE	0x80

#define UNIT(x)		minor(x)

#ifdef DEBUG
int	pardebug = 0;
#define PDB_FOLLOW	0x01
#define PDB_IO		0x02
#define PDB_INTERRUPT   0x04
#define PDB_NOCHECK	0x80
#endif

int parrw(dev_t, struct uio *);
int parhztoms(int);
int parmstohz(int);
int parsend(u_char *, int);
int parreceive(u_char *, int);
int parsendch(u_char);

void partimo(void *);
void parstart(void *);
void parintr(void *);

void parattach(struct device *, struct device *, void *);
int parmatch(struct device *, void *, void *);

struct cfattach par_ca = {
	sizeof(struct device), parmatch, parattach
};

struct cfdriver par_cd = {
	NULL, "par", DV_DULL, NULL, 0
};

struct	timeout tmo_parintr;

/*ARGSUSED*/
int
parmatch(pdp, match, auxp)
	struct device *pdp;
	void *match, *auxp;
{
	struct cfdata *cfp = match;

	if (matchname((char *)auxp, "par") && cfp->cf_unit == 0)
		return(1);
	return(0);
}

void
parattach(pdp, dp, auxp)
	struct device *pdp, *dp;
	void *auxp;
{
	par_softcp = (struct par_softc *)dp;

#ifdef DEBUG
	if ((pardebug & PDB_NOCHECK) == 0)
#endif
		par_softcp->sc_flags = PARF_ALIVE;
	timeout_set(&tmo_parintr, parintr, par_softcp);
	printf("\n");
}

int
paropen(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
{
	int unit = UNIT(dev);
	struct par_softc *sc = getparsp(unit);
  
	if (unit >= NPAR || (sc->sc_flags & PARF_ALIVE) == 0)
		return(ENXIO);
#ifdef DEBUG
	if (pardebug & PDB_FOLLOW) {
		printf("paropen(%x, %x): flags %x, ",
		    dev, flags, sc->sc_flags);
		printf ("port = $%x\n", ((ciab.pra ^ CIAB_PRA_SEL)
		    & (CIAB_PRA_SEL|CIAB_PRA_BUSY|CIAB_PRA_POUT)));
	}
#endif
	if (sc->sc_flags & PARF_OPEN)
		return(EBUSY);
	/* can either read or write, but not both */
	if ((flags & (FREAD|FWRITE)) == (FREAD|FWRITE))
		return EINVAL;
  
	sc->sc_flags |= PARF_OPEN;

	if (flags & FREAD)
		sc->sc_flags |= PARF_OREAD;
	else
		sc->sc_flags |= PARF_OWRITE;

	sc->sc_burst = PAR_BURST;
	sc->sc_timo = parmstohz(PAR_TIMO);
	sc->sc_delay = parmstohz(PAR_DELAY);
	/* enable interrupts for CIAA-FLG */
	ciaa.icr = CIA_ICR_IR_SC | CIA_ICR_FLG;
	return(0);
}

int
parclose(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
{
  int unit = UNIT(dev);
  struct par_softc *sc = getparsp(unit);

#ifdef DEBUG
  if (pardebug & PDB_FOLLOW)
    printf("parclose(%x, %x): flags %x\n",
	   dev, flags, sc->sc_flags);
#endif
  sc->sc_flags &= ~(PARF_OPEN|PARF_OREAD|PARF_OWRITE);
  /* don't allow interrupts for CIAA-FLG any longer */
  ciaa.icr = CIA_ICR_FLG;
  return(0);
}

void
parstart(arg)
	void *arg;
{
	struct par_softc *sc;
	int unit;

	unit = (int)arg;
	sc = getparsp(unit);
#ifdef DEBUG
	if (pardebug & PDB_FOLLOW)
		printf("parstart(%x)\n", unit);
#endif
	sc->sc_flags &= ~PARF_DELAY;
	wakeup(sc);
}

void
partimo(arg)
	void *arg;
{
	struct par_softc *sc;
	int unit;

	unit = (int) arg;
	sc = getparsp(unit);
#ifdef DEBUG
	if (pardebug & PDB_FOLLOW)
		printf("partimo(%x)\n", unit);
#endif
	sc->sc_flags &= ~(PARF_UIO|PARF_TIMO);
	wakeup(sc);
}

int
parread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{

#ifdef DEBUG
	if (pardebug & PDB_FOLLOW)
		printf("parread(%x, %p)\n", dev, uio);
#endif
	return (parrw(dev, uio));
}


int
parwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{

#ifdef DEBUG
	if (pardebug & PDB_FOLLOW)
		printf("parwrite(%x, %p)\n", dev, uio);
#endif
	return (parrw(dev, uio));
}


int
parrw(dev, uio)
     dev_t dev;
     register struct uio *uio;
{
  int unit = UNIT(dev);
  register struct par_softc *sc = getparsp(unit);
  register int s, len, cnt;
  register char *cp;
  int error = 0, gotdata = 0;
  int buflen;
  char *buf;

  len = 0;
  cnt = 0;
  if (!!(sc->sc_flags & PARF_OREAD) ^ (uio->uio_rw == UIO_READ))
    return EINVAL;

  if (uio->uio_resid == 0)
    return(0);

#ifdef DEBUG
  if (pardebug & (PDB_FOLLOW|PDB_IO))
    printf("parrw(%x, %p, %c): burst %d, timo %d, resid %x\n",
	   dev, uio, uio->uio_rw == UIO_READ ? 'R' : 'W',
	   sc->sc_burst, sc->sc_timo, uio->uio_resid);
#endif
  buflen = min(sc->sc_burst, uio->uio_resid);
  buf = (char *)malloc(buflen, M_DEVBUF, M_WAITOK);
  sc->sc_flags |= PARF_UIO;
  if (sc->sc_timo > 0) 
    {
      sc->sc_flags |= PARF_TIMO;
      if (!timeout_initialized(&sc->sc_partimo))
	      timeout_set(&sc->sc_partimo, partimo, (caddr_t)unit);
      timeout_add(&sc->sc_partimo, sc->sc_timo);
    }
  while (uio->uio_resid > 0) 
    {
      len = min(buflen, uio->uio_resid);
      cp = buf;
      if (uio->uio_rw == UIO_WRITE) 
	{
	  error = uiomove(cp, len, uio);
	  if (error)
	    break;
	}
again:
      s = splbio();
#if 0
      if ((sc->sc_flags & PARF_UIO) && hpibreq(&sc->sc_dq) == 0)
	sleep(sc, PRIBIO+1);
#endif
      /*
       * Check if we timed out during sleep or uiomove
       */
      /* XXXX - Ieeeeek! this is a horrible abuse. It's probably not even
       * right */
      (void) spllowersoftclock();
      if ((sc->sc_flags & PARF_UIO) == 0) 
	{
#ifdef DEBUG
	  if (pardebug & PDB_IO)
	    printf("parrw: uiomove/sleep timo, flags %x\n",
		   sc->sc_flags);
#endif
	  if (sc->sc_flags & PARF_TIMO) 
	    {
	      timeout_del(&sc->sc_partimo);
	      sc->sc_flags &= ~PARF_TIMO;
	    }
	  splx(s);
	  break;
	}
      splx(s);
      /*
       * Perform the operation
       */
      if (uio->uio_rw == UIO_WRITE)
	cnt = parsend (cp, len);
      else
	cnt = parreceive (cp, len);
      
      if (cnt < 0)
	{
	  error = -cnt;
	  break;
	}
      
      s = splbio();
#if 0
      hpibfree(&sc->sc_dq);
#endif
#ifdef DEBUG
      if (pardebug & PDB_IO)
	printf("parrw: %s(%p, %d) -> %d\n",
	       uio->uio_rw == UIO_READ ? "recv" : "send", cp, len, cnt);
#endif
      splx(s);
      if (uio->uio_rw == UIO_READ) 
	{
	  if (cnt) 
	    {
	      error = uiomove(cp, cnt, uio);
	      if (error)
		break;
	      gotdata++;
	    }
	  /*
	   * Didn't get anything this time, but did in the past.
	   * Consider us done.
	   */
	  else if (gotdata)
	    break;
	}
      s = splsoftclock();
      /*
       * Operation timeout (or non-blocking), quit now.
       */
      if ((sc->sc_flags & PARF_UIO) == 0) 
	{
#ifdef DEBUG
	  if (pardebug & PDB_IO)
	    printf("parrw: timeout/done\n");
#endif
	  splx(s);
	  break;
	}
      /*
       * Implement inter-read delay
       */
      if (sc->sc_delay > 0) 
	{
	  sc->sc_flags |= PARF_DELAY;
	  if (!timeout_initialized(&sc->sc_parstart))
		  timeout_set(&sc->sc_parstart, parstart, (caddr_t)unit);
	  timeout_add(&sc->sc_parstart, sc->sc_delay);
	  error = tsleep(sc, PCATCH | (PZERO - 1), "par-cdelay", 0);
	  if (error) 
	    {
	      splx(s);
	      break;
	    }
	}
      splx(s);
      /*
       * Must not call uiomove again til we've used all data
       * that we already grabbed.
       */
      if (uio->uio_rw == UIO_WRITE && cnt != len) 
	{
	  cp += cnt;
	  len -= cnt;
	  cnt = 0;
	  goto again;
	}
    }
  s = splsoftclock();
  if (sc->sc_flags & PARF_TIMO) 
    {
      timeout_del(&sc->sc_partimo);
      sc->sc_flags &= ~PARF_TIMO;
    }
  if (sc->sc_flags & PARF_DELAY) 
    {
      timeout_del(&sc->sc_parstart);
      sc->sc_flags &= ~PARF_DELAY;
    }
  splx(s);
  /*
   * Adjust for those chars that we uiomove'ed but never wrote
   */
  if (uio->uio_rw == UIO_WRITE && cnt != len) 
    {
      uio->uio_resid += (len - cnt);
#ifdef DEBUG
      if (pardebug & PDB_IO)
	printf("parrw: short write, adjust by %d\n",
	       len-cnt);
#endif
    }
  free(buf, M_DEVBUF);
#ifdef DEBUG
  if (pardebug & (PDB_FOLLOW|PDB_IO))
    printf("parrw: return %d, resid %u\n", error, uio->uio_resid);
#endif
  return (error);
}

int
parioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
  struct par_softc *sc = getparsp(UNIT(dev));
  struct parparam *pp, *upp;
  int error = 0;

  switch (cmd) 
    {
    case PARIOCGPARAM:
      pp = &sc->sc_param;
      upp = (struct parparam *)data;
      upp->burst = pp->burst;
      upp->timo = parhztoms(pp->timo);
      upp->delay = parhztoms(pp->delay);
      break;

    case PARIOCSPARAM:
      pp = &sc->sc_param;
      upp = (struct parparam *)data;
      if (upp->burst < PAR_BURST_MIN || upp->burst > PAR_BURST_MAX ||
	  upp->delay < PAR_DELAY_MIN || upp->delay > PAR_DELAY_MAX)
	return(EINVAL);
      pp->burst = upp->burst;
      pp->timo = parmstohz(upp->timo);
      pp->delay = parmstohz(upp->delay);
      break;

    default:
      return(EINVAL);
    }
  return (error);
}

int
parhztoms(h)
     int h;
{
  extern int hz;
  register int m = h;

  if (m > 0)
    m = m * 1000 / hz;
  return(m);
}

int
parmstohz(m)
     int m;
{
  extern int hz;
  register int h = m;

  if (h > 0) {
    h = h * hz / 1000;
    if (h == 0)
      h = 1000 / hz;
  }
  return(h);
}

/* stuff below here if for interrupt driven output of data thru
   the parallel port. */

int partimeout_pending;
int parsend_pending;

void
parintr(arg)
	void *arg;
{
	int s, mask;

	mask = (int)arg;
	s = splclock();

#ifdef DEBUG
	if (pardebug & PDB_INTERRUPT)
		printf("parintr %s\n", mask ? "FLG" : "tout");
#endif
	/*
	 * if invoked from timeout handler, mask will be 0,
	 * if from interrupt, it will contain the cia-icr mask,
	 * which is != 0
	 */
	if (mask) {
		if (partimeout_pending)
			timeout_del(&tmo_parintr);
		if (parsend_pending)
			parsend_pending = 0;
	}

	/* either way, there won't be a timeout pending any longer */
	partimeout_pending = 0;
  
	wakeup(parintr);
	splx(s);
}

int
parsendch (ch)
     u_char ch;
{
  int error = 0;
  int s;

  /* if either offline, busy or out of paper, wait for that
     condition to clear */
  s = splclock();
  while (!error 
	 && (parsend_pending 
	     || ((ciab.pra ^ CIAB_PRA_SEL)
		 & (CIAB_PRA_SEL|CIAB_PRA_BUSY|CIAB_PRA_POUT))))
    {
      extern int hz;

#ifdef DEBUG
      if (pardebug & PDB_INTERRUPT)
	printf ("parsendch, port = $%x\n",
		((ciab.pra ^ CIAB_PRA_SEL)
		 & (CIAB_PRA_SEL|CIAB_PRA_BUSY|CIAB_PRA_POUT)));
#endif
      /* wait a second, and try again */
      timeout_add(&tmo_parintr, hz);
      partimeout_pending = 1;
      /* this is essentially a flipflop to have us wait for the
	 first character being transmitted when trying to transmit
	 the second, etc. */
      parsend_pending = 0;
      /* it's quite important that a parallel putc can be
	 interrupted, given the possibility to lock a printer
	 in an offline condition.. */
      if ((error = tsleep(parintr, PCATCH | (PZERO - 1), "parsendch", 0)) > 0)
	{
#ifdef DEBUG
	  if (pardebug & PDB_INTERRUPT)
	    printf ("parsendch interrupted, error = %d\n", error);
#endif
	  if (partimeout_pending)
	    timeout_del(&tmo_parintr);

	  partimeout_pending = 0;
	}
    }

  if (! error)
    {
#ifdef DEBUG
      if (pardebug & PDB_INTERRUPT)
	printf ("#%d", ch);
#endif
      ciaa.prb = ch;
      parsend_pending = 1;
    }

  splx (s);

  return error;
}


int
parsend (buf, len)
     u_char *buf;
     int len;
{
  int err, orig_len = len;

  /* make sure I/O lines are setup right for output */

  /* control lines set to input */
  ciab.ddra &= ~(CIAB_PRA_SEL|CIAB_PRA_POUT|CIAB_PRA_BUSY);
  /* data lines to output */
  ciaa.ddrb = 0xff;
  
  for (; len; len--, buf++)
    if ((err = parsendch (*buf)) != 0)
      return err < 0 ? -EINTR : -err;

  /* either all or nothing.. */
  return orig_len;
}



int
parreceive (buf, len)
     u_char *buf;
     int len;
{
  /* oh deary me, something's gotta be left to be implemented
     later... */
  return 0;
}


#endif
@


1.10
log
@Include <sys/conf.h> from <machine/conf.h> like in other arches.  Changes
to come soon depend on this.
@
text
@d1 1
a1 1
/*	$OpenBSD: par.c,v 1.9 2002/03/14 01:26:29 millert Exp $	*/
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: par.c,v 1.8 2001/08/20 19:35:18 miod Exp $	*/
a59 1
#include <sys/conf.h>
@


1.8
log
@Convert to new timeouts; ite tested by jj@@
@
text
@d1 1
a1 1
/*	$OpenBSD: par.c,v 1.7 2001/02/07 07:46:50 art Exp $	*/
d94 10
a103 10
int parrw __P((dev_t, struct uio *));
int parhztoms __P((int));
int parmstohz __P((int));
int parsend __P((u_char *, int));
int parreceive __P((u_char *, int));
int parsendch __P((u_char));

void partimo __P((void *));
void parstart __P((void *));
void parintr __P((void *));
d105 2
a106 2
void parattach __P((struct device *, struct device *, void *));
int parmatch __P((struct device *, void *, void *));
@


1.8.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: par.c,v 1.8 2001/08/20 19:35:18 miod Exp $	*/
d94 10
a103 10
int parrw(dev_t, struct uio *);
int parhztoms(int);
int parmstohz(int);
int parsend(u_char *, int);
int parreceive(u_char *, int);
int parsendch(u_char);

void partimo(void *);
void parstart(void *);
void parintr(void *);
d105 2
a106 2
void parattach(struct device *, struct device *, void *);
int parmatch(struct device *, void *, void *);
@


1.8.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: par.c,v 1.8.4.1 2002/06/11 03:34:58 art Exp $	*/
d60 1
@


1.8.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: par.c,v 1.8.4.2 2002/10/29 00:28:01 art Exp $	*/
@


1.7
log
@XXX two horrible abuses of spl.
@
text
@d1 1
a1 1
/*	$OpenBSD: par.c,v 1.6 2000/07/06 15:42:48 ho Exp $	*/
d54 1
d69 2
d116 2
d142 1
d305 3
a307 1
      timeout(partimo, (void *)unit, sc->sc_timo);
d340 1
a340 1
	      untimeout(partimo, (void *)unit);
d406 3
a408 1
	  timeout(parstart, (void *)unit, sc->sc_delay);
d432 1
a432 1
      untimeout(partimo, (void *)unit);
d437 1
a437 1
      untimeout(parstart, (void *)unit);
d553 1
a553 1
			untimeout(parintr, 0);
d589 1
a589 1
      timeout(parintr, 0, hz);
d605 1
a605 1
	    untimeout(parintr, 0);
@


1.6
log
@Change splsoftclock() call to spllowersoftclock() to conform with other
code and keep old behaviour. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: par.c,v 1.5 1998/08/04 23:18:20 millert Exp $	*/
d320 2
@


1.5
log
@fix type of resid in debugging printf
@
text
@d1 1
a1 1
/*	$OpenBSD: par.c,v 1.4 1997/01/16 09:25:09 niklas Exp $	*/
d320 1
a320 1
      (void) splsoftclock();
@


1.5.8.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: par.c,v 1.7 2001/02/07 07:46:50 art Exp $	*/
d320 1
a320 3
      /* XXXX - Ieeeeek! this is a horrible abuse. It's probably not even
       * right */
      (void) spllowersoftclock();
@


1.5.8.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: par.c,v 1.5.8.1 2001/04/18 16:02:14 niklas Exp $	*/
a53 1
#include <sys/timeout.h>
a67 2
	struct	timeout sc_partimo;
	struct	timeout sc_parstart;
a112 2
struct	timeout tmo_parintr;

a136 1
	timeout_set(&tmo_parintr, parintr, par_softcp);
d299 1
a299 3
      if (!timeout_initialized(&sc->sc_partimo))
	      timeout_set(&sc->sc_partimo, partimo, (caddr_t)unit);
      timeout_add(&sc->sc_partimo, sc->sc_timo);
d332 1
a332 1
	      timeout_del(&sc->sc_partimo);
d398 1
a398 3
	  if (!timeout_initialized(&sc->sc_parstart))
		  timeout_set(&sc->sc_parstart, parstart, (caddr_t)unit);
	  timeout_add(&sc->sc_parstart, sc->sc_delay);
d422 1
a422 1
      timeout_del(&sc->sc_partimo);
d427 1
a427 1
      timeout_del(&sc->sc_parstart);
d543 1
a543 1
			timeout_del(&tmo_parintr);
d579 1
a579 1
      timeout_add(&tmo_parintr, hz);
d595 1
a595 1
	    timeout_del(&tmo_parintr);
@


1.5.8.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d94 10
a103 10
int parrw(dev_t, struct uio *);
int parhztoms(int);
int parmstohz(int);
int parsend(u_char *, int);
int parreceive(u_char *, int);
int parsendch(u_char);

void partimo(void *);
void parstart(void *);
void parintr(void *);
d105 2
a106 2
void parattach(struct device *, struct device *, void *);
int parmatch(struct device *, void *, void *);
@


1.5.8.4
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: par.c,v 1.5.8.3 2002/03/28 10:06:14 niklas Exp $	*/
@


1.4
log
@Sync to NetBSD 970110
@
text
@d1 1
a1 1
/*	$OpenBSD: par.c,v 1.2 1996/04/21 22:15:41 deraadt Exp $	*/
d444 1
a444 1
    printf("parrw: return %d, resid %d\n", error, uio->uio_resid);
@


1.3
log
@Sync with NetBSD 9600430.  The port has gone over a major -Wall treat
@
text
@d2 1
a2 1
/*	$NetBSD: par.c,v 1.13 1996/04/21 21:12:18 veego Exp $	*/
@


1.2
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: par.c,v 1.12 1996/03/17 01:17:51 thorpej Exp $	*/
d53 1
d59 2
d91 7
d140 2
a141 1
paropen(dev, flags)
d143 3
d181 6
a186 2
parclose(dev, flags)
     dev_t dev;
d236 5
a240 3
parread(dev, uio)
     dev_t dev;
     struct uio *uio;
d244 2
a245 2
  if (pardebug & PDB_FOLLOW)
    printf("parread(%x, %x)\n", dev, uio);
d247 1
a247 1
  return (parrw(dev, uio));
d250 6
a255 3
parwrite(dev, uio)
     dev_t dev;
     struct uio *uio;
d259 2
a260 2
  if (pardebug & PDB_FOLLOW)
    printf("parwrite(%x, %x)\n", dev, uio);
d262 1
a262 1
  return (parrw(dev, uio));
d265 2
d279 2
d289 1
a289 1
    printf("parrw(%x, %x, %c): burst %d, timo %d, resid %x\n",
d357 1
a357 1
	printf("parrw: %s(%x, %d) -> %d\n",
d397 1
a397 1
	  error = tsleep(sc, PCATCH|PZERO-1, "par-cdelay", 0);
d586 1
a586 1
      if (error = tsleep(parintr, PCATCH|PZERO-1, "parsendch", 0))
d630 1
a630 1
    if (err = parsendch (*buf))
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: par.c,v 1.11 1994/12/01 17:25:33 chopps Exp $	*/
d93 1
a93 1
int parmatch __P((struct device *, struct cfdata *, void *));
d95 7
a101 3
struct cfdriver parcd = {
	NULL, "par", (cfmatch_t)parmatch, parattach, DV_DULL,
	sizeof(struct device), NULL, 0 };
d105 1
a105 1
parmatch(pdp, cfp, auxp)
d107 1
a107 2
	struct cfdata *cfp;
	void *auxp;
d109 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
