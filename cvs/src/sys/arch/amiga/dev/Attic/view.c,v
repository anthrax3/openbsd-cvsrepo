head	1.9;
access;
symbols
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.8
	UBC:1.5.0.2
	UBC_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.20
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.14
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2002.12.31.16.35.38;	author miod;	state dead;
branches;
next	1.8;

1.8
date	2002.08.02.16.13.07;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.11.03.25.43;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.29;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.01.12.13.45;	author art;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.05.16.12.49.44;	author ho;	state Exp;
branches;
next	1.3;

1.3
date	97.01.16.09.25.30;	author niklas;	state Exp;
branches
	1.3.14.1;
next	1.2;

1.2
date	96.05.02.06.44.36;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.02;	author deraadt;	state Exp;
branches;
next	;

1.3.14.1
date	2001.07.04.10.15.14;	author niklas;	state Exp;
branches;
next	1.3.14.2;

1.3.14.2
date	2001.11.13.21.00.50;	author niklas;	state Exp;
branches;
next	1.3.14.3;

1.3.14.3
date	2002.03.28.10.06.14;	author niklas;	state Exp;
branches;
next	1.3.14.4;

1.3.14.4
date	2003.03.27.23.19.18;	author niklas;	state dead;
branches;
next	;

1.5.2.1
date	2002.06.11.03.34.58;	author art;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.10.29.00.28.01;	author art;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.05.19.21.49.39;	author tedu;	state dead;
branches;
next	;


desc
@@


1.9
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: view.c,v 1.8 2002/08/02 16:13:07 millert Exp $	*/
/*	$NetBSD: view.c,v 1.16 1996/10/13 03:07:35 christos Exp $	*/

/*
 * Copyright (c) 1994 Christian E. Hopps
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christian E. Hopps.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* The view major device is a placeholder device.  It serves
 * simply to map the semantics of a graphics dipslay to 
 * the semantics of a character block device.  In other
 * words the graphics system as currently built does not like to be
 * refered to by open/close/ioctl.  This device serves as
 * a interface to graphics. */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <machine/cpu.h>
#include <amiga/dev/grfabs_reg.h>
#include <amiga/dev/viewioctl.h>
#include <amiga/dev/viewvar.h>

#include <machine/conf.h>

#include "view.h"

static void view_display(struct view_softc *);
static void view_remove(struct view_softc *);
static int view_setsize(struct view_softc *, struct view_size *);

int view_get_colormap(struct view_softc *, colormap_t *);
int view_set_colormap(struct view_softc *, colormap_t *);

void viewattach(int);

struct view_softc views[NVIEW];
int view_inited;			/* also checked in ite_cc.c */

int view_default_x;
int view_default_y;
int view_default_width = 640;
int view_default_height = 400;
int view_default_depth = 2;

/* 
 *  functions for probeing.
 */

void
viewattach(cnt)
	int cnt;
{
	viewprobe();
	printf("%d view%s configured\n", NVIEW, NVIEW > 1 ? "s" : "");
}

/* this function is called early to set up a display. */
void
viewprobe()
{
    	int i;
	
	if (view_inited)
		return;

    	view_inited = 1;

    	for (i=0; i<NVIEW; i++) {
		views[i].view = NULL;
		views[i].flags = 0;
    	}
	return;
}


/*
 *  Internal functions.
 */

static void
view_display (vu)
	struct view_softc *vu;
{
	int s, i;

	if (vu == NULL)
		return;
	
	s = spltty ();

	/*
	 * mark views that share this monitor as not displaying 
	 */
	for (i=0; i<NVIEW; i++) {
		if ((views[i].flags & VUF_DISPLAY) && 
		    views[i].monitor == vu->monitor)
			views[i].flags &= ~VUF_DISPLAY;
	}

	vu->flags |= VUF_ADDED;
	if (vu->view) {
		vu->view->display.x = vu->size.x;
		vu->view->display.y = vu->size.y;

		grf_display_view(vu->view);

		vu->size.x = vu->view->display.x;
		vu->size.y = vu->view->display.y;
		vu->flags |= VUF_DISPLAY;
	}
	splx(s);
}

/* 
 * remove a view from our added list if it is marked as displaying
 * switch to a new display.
 */
static void
view_remove(vu)
	struct view_softc *vu;
{
	int i;

	if ((vu->flags & VUF_ADDED) == 0)
		return;

	vu->flags &= ~VUF_ADDED;
	if (vu->flags & VUF_DISPLAY) {
		for (i = 0; i < NVIEW; i++) {
			if ((views[i].flags & VUF_ADDED) && &views[i] != vu && 
			    views[i].monitor == vu->monitor) {
				view_display(&views[i]);
				break;
			}
		}
	}
	vu->flags &= ~VUF_DISPLAY;
	grf_remove_view(vu->view);
}

static int
view_setsize(vu, vs)
	struct view_softc *vu;
	struct view_size *vs;
{
	view_t *new, *old;
	dimen_t ns;
	int co, cs;
   
	co = 0;
	cs = 0;
	if (vs->x != vu->size.x || vs->y != vu->size.y)
		co = 1;

	if (vs->width != vu->size.width || vs->height != vu->size.height ||
	    vs->depth != vu->size.depth)
		cs = 1;

	if (cs == 0 && co == 0)
		return(0);
    
	ns.width = vs->width;
	ns.height = vs->height;

	new = grf_alloc_view(NULL, &ns, vs->depth);
	if (new == NULL)
		return(ENOMEM);
	
	old = vu->view;
	vu->view = new;
	vu->size.x = new->display.x;
	vu->size.y = new->display.y;
	vu->size.width = new->display.width;
	vu->size.height = new->display.height;
	vu->size.depth = new->bitmap->depth;
	vu->mode = grf_get_display_mode(vu->view);
	vu->monitor = grf_get_monitor(vu->mode);
	vu->size.x = vs->x;
	vu->size.y = vs->y;

	/* 
	 * we need a custom remove here to avoid letting 
	 * another view display mark as not added or displayed 
	 */
	if (vu->flags & VUF_DISPLAY) {
		vu->flags &= ~(VUF_ADDED|VUF_DISPLAY);
		view_display(vu);
	}
	grf_free_view(old);
	return(0);
}

/*
 *  functions made available by conf.c
 */

/*ARGSUSED*/
int
viewopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	dimen_t size;
	struct view_softc *vu;

	vu = &views[minor(dev)];

	if (minor(dev) >= NVIEW)
		return(EXDEV);

	if (vu->flags & VUF_OPEN)
		return(EBUSY);

	vu->size.x = view_default_x;
	vu->size.y = view_default_y;
	size.width = vu->size.width = view_default_width;
	size.height = vu->size.height = view_default_height;
	vu->size.depth = view_default_depth;

	vu->view = grf_alloc_view(NULL, &size, vu->size.depth);
	if (vu->view == NULL)
		return(ENOMEM);

	vu->size.x = vu->view->display.x;
	vu->size.y = vu->view->display.y;
	vu->size.width = vu->view->display.width;
	vu->size.height = vu->view->display.height;
	vu->size.depth = vu->view->bitmap->depth;
       	vu->flags |= VUF_OPEN;
    	vu->mode = grf_get_display_mode(vu->view);
    	vu->monitor = grf_get_monitor(vu->mode);
       	return(0);
}

/*ARGSUSED*/
int
viewclose (dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
{
	struct view_softc *vu;

	vu = &views[minor(dev)];

	if ((vu->flags & VUF_OPEN) == 0)
		return(0);
	view_remove (vu);
	grf_free_view (vu->view);
	vu->flags = 0;
	vu->view = NULL;
	vu->mode = NULL;
	vu->monitor = NULL;	
       	return(0);
}


/*ARGSUSED*/
int
viewioctl (dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct view_softc *vu;
	bmap_t *bm;
	int error;

	vu = &views[minor(dev)];
	error = 0;

	switch (cmd) {
	case VIOCDISPLAY:
		view_display(vu);
		break;
	case VIOCREMOVE:
		view_remove(vu);
		break;
	case VIOCGSIZE:
		bcopy(&vu->size, data, sizeof (struct view_size)); 
		break;
	case VIOCSSIZE:
		error = view_setsize(vu, (struct view_size *)data);
		break;
	case VIOCGBMAP:
		bm = (bmap_t *)data;
		bcopy(vu->view->bitmap, bm, sizeof(bmap_t));
		if (flag != -1) {
			bm->plane = 0;
			bm->blit_temp = 0;
			bm->hardware_address = 0;
		}
		break;
	case VIOCGCMAP:
		error = view_get_colormap(vu, (colormap_t *)data);
		break;
	case VIOCSCMAP:
		error = view_set_colormap(vu, (colormap_t *)data);
		break;
	default:
		error = EINVAL;
		break;
	}
	return(error);
}

int
view_get_colormap (vu, ucm)
	struct view_softc *vu;
	colormap_t *ucm;
{
	int error;
	u_long *cme;
	u_long *uep;

	/* add one incase of zero, ick. */
	if (ucm->size >= SIZE_T_MAX / sizeof(u_long))
		return (EINVAL);
	cme = malloc(sizeof(u_long) * ((size_t)ucm->size + 1), M_IOCTLOPS,
	    M_WAITOK);

	uep = ucm->entry;
	error = 0;	
	ucm->entry = cme;	  /* set entry to out alloc. */
	if (vu->view == NULL || grf_get_colormap(vu->view, ucm))
		error = EINVAL;
	else 
		error = copyout(cme, uep, sizeof(u_long) * ucm->size);
	ucm->entry = uep;	  /* set entry back to users. */
	free(cme, M_IOCTLOPS);
	return(error);
}

int
view_set_colormap(vu, ucm)
	struct view_softc *vu;
	colormap_t *ucm;
{
	colormap_t *cm;
	int error;

	error = 0;
	cm = malloc(sizeof(u_long) * ucm->size + sizeof (*cm), M_IOCTLOPS,
	    M_WAITOK);

	bcopy (ucm, cm, sizeof(colormap_t));
	cm->entry = (u_long *)&cm[1];		 /* table directly after. */
	if (((error = 
	    copyin(ucm->entry, cm->entry, sizeof (u_long) * ucm->size)) == 0)
	    && (vu->view == NULL || grf_use_colormap(vu->view, cm)))
		error = EINVAL;
	free(cm, M_IOCTLOPS);
	return(error);
}

/*ARGSUSED*/
paddr_t
viewmmap(dev, off, prot)
        dev_t dev;
	off_t off;
	int prot;
{
	struct view_softc *vu;
	bmap_t *bm;
	u_char *bmd_start;
	u_long bmd_size; 

	vu = &views[minor(dev)];
	bm = vu->view->bitmap;
	bmd_start = bm->hardware_address; 
	bmd_size = bm->bytes_per_row*bm->rows*bm->depth;

	if (off >= 0 && off < bmd_size)
		return(((u_int)bmd_start + off) >> PGSHIFT);

	return(-1);
}

/*ARGSUSED*/
int
viewselect(dev, rw, p)
	dev_t dev;
	int rw;
	struct proc *p;
{
	if (rw == FREAD)
		return(0);
	return(1);
}
@


1.8
log
@Do correct bounds checking in get/set/put cmap routines.  A few of
these check were already OK but have been modified for consistency.
Problem found by Silvio Cesare.
@
text
@d1 1
a1 1
/*	$OpenBSD: view.c,v 1.7 2002/06/11 03:25:43 miod Exp $	*/
@


1.7
log
@Include <sys/conf.h> from <machine/conf.h> like in other arches.  Changes
to come soon depend on this.
@
text
@d1 1
a1 1
/*	$OpenBSD: view.c,v 1.6 2002/03/14 01:26:29 millert Exp $	*/
d351 4
a354 1
	cme = malloc(sizeof (u_long)*(ucm->size + 1), M_IOCTLOPS, M_WAITOK);
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: view.c,v 1.5 2001/11/01 12:13:45 art Exp $	*/
a53 1
#include <sys/conf.h>
@


1.5
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: view.c,v 1.4 2001/05/16 12:49:44 ho Exp $	*/
d59 3
a61 3
static void view_display __P((struct view_softc *));
static void view_remove __P((struct view_softc *));
static int view_setsize __P((struct view_softc *, struct view_size *));
d63 2
a64 2
int view_get_colormap __P((struct view_softc *, colormap_t *));
int view_set_colormap __P((struct view_softc *, colormap_t *));
d66 1
a66 1
void viewattach __P((int));
@


1.5.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: view.c,v 1.5 2001/11/01 12:13:45 art Exp $	*/
d59 3
a61 3
static void view_display(struct view_softc *);
static void view_remove(struct view_softc *);
static int view_setsize(struct view_softc *, struct view_size *);
d63 2
a64 2
int view_get_colormap(struct view_softc *, colormap_t *);
int view_set_colormap(struct view_softc *, colormap_t *);
d66 1
a66 1
void viewattach(int);
@


1.5.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: view.c,v 1.5.2.1 2002/06/11 03:34:58 art Exp $	*/
d54 1
d352 1
a352 4
	if (ucm->size >= SIZE_T_MAX / sizeof(u_long))
		return (EINVAL);
	cme = malloc(sizeof(u_long) * ((size_t)ucm->size + 1), M_IOCTLOPS,
	    M_WAITOK);
@


1.5.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: view.c,v 1.5.2.2 2002/10/29 00:28:01 art Exp $	*/
@


1.4
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: view.c,v 1.3 1997/01/16 09:25:30 niklas Exp $	*/
d389 1
a389 1
int
d392 2
a393 1
	int off, prot;
@


1.3
log
@Sync to NetBSD 970110
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a352 2
	if (cme == NULL)
		return(ENOMEM);
a376 2
	if (cm == NULL)
		return(ENOMEM);
@


1.3.14.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: view.c,v 1.3 1997/01/16 09:25:30 niklas Exp $	*/
d353 2
d379 2
@


1.3.14.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d389 1
a389 1
paddr_t
d392 1
a392 2
	off_t off;
	int prot;
@


1.3.14.3
log
@Merge in -current from about a week ago
@
text
@d59 3
a61 3
static void view_display(struct view_softc *);
static void view_remove(struct view_softc *);
static int view_setsize(struct view_softc *, struct view_size *);
d63 2
a64 2
int view_get_colormap(struct view_softc *, colormap_t *);
int view_set_colormap(struct view_softc *, colormap_t *);
d66 1
a66 1
void viewattach(int);
@


1.3.14.4
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: view.c,v 1.3.14.3 2002/03/28 10:06:14 niklas Exp $	*/
@


1.2
log
@Sync with NetBSD 9600430.  The port has gone over a major -Wall treat
@
text
@d2 1
a2 1
/*	$NetBSD: view.c,v 1.13 1996/04/21 21:12:39 veego Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: view.c,v 1.12 1995/04/10 09:12:46 mycroft Exp $	*/
d42 1
d53 4
a62 5
void viewclose __P((dev_t, int));
int viewioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int viewopen __P((dev_t, int));
int viewmmap __P((dev_t, int, int));

d66 1
a66 1
int viewprobe ();
d81 1
d90 1
d96 1
a96 1
		return(1);
d104 1
a104 1
	return(1);
d231 1
a231 1
viewopen(dev, flags)
d233 2
a234 1
	int flags;
d269 2
a270 2
void
viewclose (dev, flags)
d272 2
a273 1
	int flags;
d280 1
a280 1
		return;
d287 1
a300 1
	colormap_t *cm;
d323 1
a323 1
		if ((int)p != -1) {
d416 1
a416 1
viewselect(dev, rw)
d419 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
