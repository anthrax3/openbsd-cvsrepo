head	1.10;
access;
symbols
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	UBC_SYNC_A:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.6.0.24
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.22
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.20
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.18
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.16
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.14
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.12
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2002.12.31.16.35.38;	author miod;	state dead;
branches;
next	1.9;

1.9
date	2002.06.11.03.25.43;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.29;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.15.20.45.30;	author nordin;	state Exp;
branches;
next	1.6;

1.6
date	97.01.16.09.25.04;	author niklas;	state Exp;
branches
	1.6.14.1
	1.6.24.1;
next	1.5;

1.5
date	96.08.23.18.53.14;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.05.02.06.44.22;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.15.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.24.20.47.18;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.00;	author deraadt;	state Exp;
branches;
next	;

1.6.14.1
date	2002.03.06.00.56.18;	author niklas;	state Exp;
branches;
next	1.6.14.2;

1.6.14.2
date	2002.03.28.10.06.14;	author niklas;	state Exp;
branches;
next	1.6.14.3;

1.6.14.3
date	2003.03.27.23.19.18;	author niklas;	state dead;
branches;
next	;

1.6.24.1
date	2002.06.11.03.34.58;	author art;	state Exp;
branches;
next	1.6.24.2;

1.6.24.2
date	2002.10.29.00.28.01;	author art;	state Exp;
branches;
next	1.6.24.3;

1.6.24.3
date	2003.05.19.21.49.39;	author tedu;	state dead;
branches;
next	;


desc
@@


1.10
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: msc.c,v 1.9 2002/06/11 03:25:43 miod Exp $ */
/*	$NetBSD: msc.c,v 1.13 1996/12/23 09:10:26 veego Exp $	*/

/*
 * Copyright (c) 1993 Zik.
 * Copyright (c) 1995 Jukka Marin <jmarin@@jmp.fi>.
 * Copyright (c) 1995 Timo Rossi <trossi@@jyu.fi>.
 * Copyright (c) 1995 Rob Healey <rhealey@@kas.helios.mn.org>.
 * Copyright (c) 1982, 1986, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *   - converted from NetBSD Amiga serial driver to A2232 serial driver
 *     by zik 931207
 *   - added ttyflags hooks rfh 940419
 *   - added new style config support rfh 940601
 *   - added code to halt board during memory load so board doesn't flip
 *     out. /dev/reload works now. Also created mschwiflow function so BSD can
 *     attempt to use board RTS flow control now. rfh 950108
 *   - Integrated work from Jukka Marin <jmarin@@jmp.fi> and
 *     Timo Rossi <trossi@@jyu.fi> The mscmint() code is Jukka's. 950916
 *     Integrated more bug fixes by Jukka Marin <jmarin@@jmp.fi> 950918
 *     Also added Jukka's turbo board code. 950918
 *   - Reformatted to NetBSD style format.
 *   - Rewritten the carrier detect system to prevent lock-ups (jm 951029)
 */

#include "msc.h"

#if NMSC > 0
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/malloc.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/device.h>

#include <amiga/amiga/device.h>
#include <amiga/dev/zbusvar.h>
#include <amiga/dev/mscreg.h>
#include <machine/cpu.h>

#include <amiga/amiga/custom.h>
#include <amiga/amiga/cia.h>
#include <amiga/amiga/cc.h>

#include <machine/conf.h>

/* 6502 code for A2232 card */
#include "msc6502.h"

/*
 * Note: These are Zik's original comments:
 * There is a bit of a "gotcha" concerning the numbering
 * of msc devices and the specification of the number of serial
 * lines in the kernel.
 *
 * Each board has seven lines, but for programming convenience
 * and compatibility with Amiga UNIX the boards' minor device
 * numbers are allocated in groups of sixteen:
 *
 *                     minor device numbers
 * First board		0  2  4  6  8 10 12
 * Second board        16 18 20 22 24 26 28
 * Third board	       32 34 36 38 40 42 44
 *
 * The intermediate minor device numbers are dialin versions
 * of the same devices. ie. 10 is dialout line 6 and 11 is
 * the dialin version of line 6.
 *
 * On the other hand, I have made the NMSC config option refer
 * to the total number of a2232 cards, not the maximum
 * minor device number. So you might have NMSC=3, in which case
 * you have three boards with minor device numbers from 0 to 45.
 */

int	mscparam(struct tty *, struct termios *);
void	mscstart(struct tty *);
int	mschwiflow(struct tty *, int);
int	mscinitcard(struct zbus_args *);

int	mscdefaultrate = TTYDEF_SPEED;

struct	mscdevice mscdev[MSCSLOTS];	/* device structs for all lines */
struct	tty *msc_tty[MSCTTYS];		/* ttys for all lines */

struct	vbl_node msc_vbl_node[NMSC];	/* vbl interrupt node per board */

struct speedtab mscspeedtab_normal[] = {
	{ 0,		0		},
	{ 50,		MSCPARAM_B50	},
	{ 75,		MSCPARAM_B75	},
	{ 110,		MSCPARAM_B110	},
	{ 134,		MSCPARAM_B134	},
	{ 150,		MSCPARAM_B150	},
	{ 300,		MSCPARAM_B300	},
	{ 600,		MSCPARAM_B600	},
	{ 1200,		MSCPARAM_B1200	},
	{ 1800,		MSCPARAM_B1800	},
	{ 2400,		MSCPARAM_B2400	},
	{ 3600,		MSCPARAM_B3600	},
	{ 4800,		MSCPARAM_B4800	},
	{ 7200,		MSCPARAM_B7200	},
	{ 9600,		MSCPARAM_B9600	},
	{ 19200,	MSCPARAM_B19200	},
	{ 115200,	MSCPARAM_B115200 },
	{ -1,		-1		}
};
  
struct speedtab mscspeedtab_turbo[] = {
	{ 0,		0		},
	{ 100,		MSCPARAM_B50	},
	{ 150,		MSCPARAM_B75	},
	{ 220,		MSCPARAM_B110	},
	{ 269,		MSCPARAM_B134	},
	{ 300,		MSCPARAM_B150	},
	{ 600,		MSCPARAM_B300	},
	{ 1200,		MSCPARAM_B600	},
	{ 2400,		MSCPARAM_B1200	},
	{ 3600,		MSCPARAM_B1800	},
	{ 4800,		MSCPARAM_B2400	},
	{ 7200,		MSCPARAM_B3600	},
	{ 9600,		MSCPARAM_B4800	},
	{ 14400,	MSCPARAM_B7200	},
	{ 19200,	MSCPARAM_B9600	},
	{ 38400,	MSCPARAM_B19200	},
	{ 230400,	MSCPARAM_B115200 },
	{ -1,		-1		}
};
  
struct   speedtab *mscspeedtab;

int mscmctl(dev_t dev, int bits, int howto);
void mscmint(register void *data);

int mscmatch(struct device *, void *, void *);
void mscattach(struct device *, struct device *, void *);

#define	SWFLAGS(dev)	(msc->openflags | (MSCDIALIN(dev) ? 0 : TIOCFLAG_SOFTCAR))
#define	DEBUG_CD	0

struct cfattach msc_ca = {
	sizeof(struct device), mscmatch, mscattach
};

struct cfdriver msc_cd = {
	NULL, "msc",DV_TTY, NULL, 0
};

int
mscmatch(pdp, match, auxp)
	struct device *pdp;
	void *match, *auxp;
{
	struct zbus_args *zap;

	zap = auxp;
	if (zap->manid == 514 && (zap->prodid == 70 || zap->prodid == 69))
		return(1);

	return (0);
}

void
mscattach(pdp, dp, auxp)
	struct device *pdp, *dp;
	void *auxp;
{
	volatile struct mscmemory *mscmem;
	struct mscdevice *msc;
	struct zbus_args *zap;
	int unit;
	int Count;

	zap = (struct zbus_args *)auxp;
	unit = dp->dv_unit;

	/*
	 * Make config msgs look nicer.
	 */
	printf("\n");

	if (mscinitcard(zap) != 0) {
		printf("msc%d: Board initialize failed, bad download code.\n", unit);
		return;
	}

	printf("msc%d: Board successfully initialized.\n", unit);

	mscmem = (struct mscmemory *) zap->va;

	if (mscmem->Common.Crystal == MSC_UNKNOWN) {
		printf("msc%d: Unable to detect crystal frequency.\n", unit);
		return;
	}

	if (mscmem->Common.Crystal == MSC_TURBO) {
		printf("msc%d: Turbo version detected (%02x%02x:%d)\n", unit,
			mscmem->Common.TimerH, mscmem->Common.TimerL,
			mscmem->Common.Pad_a);
		mscspeedtab = mscspeedtab_turbo;
	} else {
		printf("msc%d: Normal version detected (%02x%02x:%d)\n", unit,
			mscmem->Common.TimerH, mscmem->Common.TimerL,
			mscmem->Common.Pad_a);
		mscspeedtab = mscspeedtab_normal;
	}

	mscmem->Common.CDStatus = 0;	/* common status for all 7 ports */

	/* XXX 8 is a constant */
	for (Count = 0; Count < 8 && MSCSLOTUL(unit, Count) < MSCSLOTS; Count++) {
		msc = &mscdev[MSCSLOTUL(unit, Count)];
		msc->board = mscmem;
		msc->port = Count;
		msc->flags = 0;
		msc->openflags = 0;
		msc->active = 1;
		msc->unit = unit;
		msc->closing = FALSE;
		msc_tty[MSCTTYSLOT(MSCSLOTUL(unit, Count))] = NULL;
		msc_tty[MSCTTYSLOT(MSCSLOTUL(unit, Count)) + 1] = NULL;
	}

	/* disable the non-existant eighth port */
	if (MSCSLOTUL(unit, NUMLINES) < MSCSLOTS)
		mscdev[MSCSLOTUL(unit, NUMLINES)].active = 0;

	msc_vbl_node[unit].function = (void (*) (void *)) mscmint;
	msc_vbl_node[unit].data = (void *) unit;

	add_vbl_function (&msc_vbl_node[unit], MSC_VBL_PRIORITY, (void *)unit);

	return; 
}

/* ARGSUSED */
int
mscopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	register struct tty *tp;
	struct mscdevice *msc;
	volatile struct mscstatus *ms;
	int error = 0;
	int s, slot, ttyn;
  
	/* get the device structure */
	slot = MSCSLOT(dev);
	ttyn = MSCTTY(dev);

	if (slot >= MSCSLOTS)
		return ENXIO;

	if (MSCLINE(dev) >= NUMLINES)
		return ENXIO;

	msc = &mscdev[slot];
	ms = &msc->board->Status[msc->port];

	if (!msc->active)
		return ENXIO;

	/*
	 * RFH: WHY here? Put down by while like other serial drivers
	 *      But if we do that it makes things bomb.
	 */
	s = spltty();

	if (!msc_tty[ttyn]) {

		tp = ttymalloc();
		tty_attach(tp);
		msc_tty[ttyn] = tp;
		msc_tty[ttyn+1] = (struct tty *)NULL;

#if 0
		/* default values are not optimal for this device, increase buffers. */
		clfree(&tp->t_rawq);
		clfree(&tp->t_canq);
		clfree(&tp->t_outq);
		clalloc(&tp->t_rawq, 8192, 1);
		clalloc(&tp->t_canq, 8192, 1);
		clalloc(&tp->t_outq, 8192, 0);
#endif

	} else
		tp = msc_tty[ttyn];

	tp->t_oproc = (void (*) (struct tty *)) mscstart;
	tp->t_param = mscparam;
	tp->t_dev = dev;
	tp->t_hwiflow = mschwiflow;
 
	/* if port is still closing, just bitbucket remaining characters */
	if (msc->closing) {
		ms->OutFlush = TRUE;
		msc->closing = FALSE;
	}

	/* initialize tty */
	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN;
		ttychars(tp);
		if (tp->t_ispeed == 0) {
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_cflag = TTYDEF_CFLAG;
			tp->t_lflag = TTYDEF_LFLAG;
			tp->t_ispeed = tp->t_ospeed = mscdefaultrate;
		}

		/* flags changed to be private to every unit by JM */
		if (msc->openflags & TIOCFLAG_CLOCAL)
			tp->t_cflag |= CLOCAL;
		if (msc->openflags & TIOCFLAG_CRTSCTS)
			tp->t_cflag |= CRTSCTS;
		if (msc->openflags & TIOCFLAG_MDMBUF)
			tp->t_cflag |= MDMBUF;

		mscparam(tp, &tp->t_termios);
		ttsetwater(tp);

		(void) mscmctl(dev, TIOCM_DTR | TIOCM_RTS, DMSET);

		if ((SWFLAGS(dev) & TIOCFLAG_SOFTCAR) ||
		    (mscmctl(dev, 0, DMGET) & TIOCM_CD))
			tp->t_state |= TS_CARR_ON;
		else
			tp->t_state &= ~TS_CARR_ON;

	} else {
		if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
			splx(s);
			return (EBUSY);
		}
	}

	/*
	 * if NONBLOCK requested, ignore carrier
	 */
	if (flag & O_NONBLOCK) {
#if DEBUG_CD
		printf("msc%d: %d open nonblock\n", msc->unit, MSCLINE(dev));
#endif
		goto done;
	}

	/* 
	 * s = spltty();
	 *
	 * This causes hangs when put here, like other TTY drivers do, rather than
	 * above, WHY? RFH
	 *
	 */

	while ((tp->t_state & TS_CARR_ON) == 0 && (tp->t_cflag & CLOCAL) == 0) {
		tp->t_state |= TS_WOPEN;

#if DEBUG_CD
		printf("msc%d: %d waiting for CD\n", msc->unit, MSCLINE(dev));
#endif
		error = ttysleep(tp, (caddr_t)&tp->t_rawq, TTIPRI | PCATCH, ttopen, 0);

		if (error) {
			splx(s);
			return(error);
		}
	}

#if DEBUG_CD
	printf("msc%d: %d got CD\n", msc->unit, MSCLINE(dev));
#endif

	done: 
		/* This is a way to handle lost XON characters */
		if ((flag & O_TRUNC) && (tp->t_state & TS_TTSTOP)) {
			tp->t_state &= ~TS_TTSTOP;
			ttstart (tp);
		}

	splx(s);

	/*
	 * Reset the tty pointer, as there could have been a dialout
	 * use of the tty with a dialin open waiting.
	 */
	tp->t_dev = dev;

	return((*linesw[tp->t_line].l_open)(dev, tp));
}

int
mscclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	register struct tty *tp;
	int slot;
	volatile struct mscstatus *ms;
	struct mscdevice *msc;
  
	/* get the device structure */
	slot = MSCSLOT(dev);

	if (slot >= MSCSLOTS)
		return ENXIO;

	msc = &mscdev[slot];

	if (!msc->active)
		return ENXIO;

	ms = &msc->board->Status[msc->port];
  
	tp = msc_tty[MSCTTY(dev)];
	(*linesw[tp->t_line].l_close)(tp, flag);

	(void) mscmctl(dev, 0, DMSET);

	ttyclose(tp);

	if (msc->flags & TIOCM_DTR)
		msc->closing = TRUE; /* flush remaining characters before dropping DTR */
	else
		ms->OutFlush = TRUE; /* just bitbucket remaining characters */

	return (0);
}
 
int
mscread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	register struct tty *tp;
  
	tp = msc_tty[MSCTTY(dev)];

	if (! tp)
	 return ENXIO;

	return((*linesw[tp->t_line].l_read)(tp, uio, flag));
}
 
int
mscwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	register struct tty *tp;
  
	tp = msc_tty[MSCTTY(dev)];

	if (! tp)
		return ENXIO;

	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

/*
 * This interrupt is periodically invoked in the vertical blank 
 * interrupt. It's used to keep track of the modem control lines
 * and (new with the fast_int code) to move accumulated data up in
 * to the tty layer.
 *
 * NOTE: MSCCDHACK is an invention of mine for dubious purposes. If you
 *	 want to activate it add
 *	 options MSCCDHACK
 *	 in the kernel conf file. Basically it forces CD->Low transitions
 *	 to ALWAYS send a signal to the process, even if the device is in
 *	 clocal mode or an outdial device. RFH
 */
void
mscmint (data)
	register void *data;
{
	register struct tty *tp;
	struct mscdevice *msc;
	volatile struct mscstatus *ms;
	volatile u_char *ibuf, *cbuf;
	unsigned char newhead; /* was int */
	unsigned char bufpos;  /* was int */
	unsigned char ncd, ocd, ccd;
	int unit, slot, maxslot;
	int s, i;

	unit = (int) data;

	/* check each line on this board */
	maxslot = MSCSLOTUL(unit, NUMLINES);
	if (maxslot > MSCSLOTS)
		maxslot = MSCSLOTS;

	msc = &mscdev[MSCSLOTUL(unit, 0)];

	newhead = msc->board->Common.CDHead;
	bufpos  = msc->board->Common.CDTail;
	if (newhead != bufpos) {	/* CD events in queue	*/
	    /* set interrupt priority level */
	    s = spltty();
	    ocd = msc->board->Common.CDStatus;		/* get old status bits	*/
	    while (newhead != bufpos) {			/* read all events	*/
		ncd = msc->board->CDBuf[bufpos++];	/* get one event	*/
		ccd = ncd ^ ocd;			/* mask of changed lines*/
		ocd = ncd;				/* save new status bits	*/
#if DEBUG_CD
		printf("ocd %02x ncd %02x ccd %02x\n", ocd, ncd, ccd);
#endif
		for(i = 0; i < NUMLINES; i++) {		/* do for all lines	*/
		    if (ccd & 1) {			/* this one changed	*/
			msc = &mscdev[MSCSLOTUL(unit, i)];
			if (ncd & 1) {	/* CD is now OFF */
#if DEBUG_CD
			    printf("msc%d: CD OFF %d\n", unit, msc->port);
#endif
			    msc->flags &= ~TIOCM_CD;
			    if ((tp = msc_tty[MSCTTYSLOT(MSCSLOTUL(unit, i))]) &&
				 (tp->t_state & (TS_ISOPEN | TS_WOPEN))) {

#ifndef MSCCDHACK
				if (MSCDIALIN(tp->t_dev))
#endif
				{
				    if ((*linesw[tp->t_line].l_modem)(tp, 0) == 0) {
					/* clear RTS and DTR, bitbucket output */
					ms = &msc->board->Status[msc->port];
					ms->Command = (ms->Command & ~MSCCMD_CMask) |
						 MSCCMD_Close;
					ms->Setup = TRUE;
					msc->flags &= ~(TIOCM_DTR | TIOCM_RTS);
					ms->OutFlush = TRUE;
				    }
				}
			    }
			} else {	/* CD is now ON */
#if DEBUG_CD
			    printf("msc%d: CD ON %d\n", unit, msc->port);
#endif
			    msc->flags |= TIOCM_CD;
			    if ((tp = msc_tty[MSCTTYSLOT(MSCSLOTUL(unit, i))]) &&
				(tp->t_state & (TS_ISOPEN | TS_WOPEN))) {
				    if (MSCDIALIN(tp->t_dev))
					(*linesw[tp->t_line].l_modem)(tp, 1);
			    } /* if tp valid and port open */
			}		/* CD on/off */
		    } /* if CD changed for this line */
		    ccd >>= 1; ncd >>= 1;			/* bit for next line */
		} /* for every line */
	    } /* while events in queue */
	msc->board->Common.CDStatus = ocd;		/* save new status */
	msc->board->Common.CDTail   = bufpos;	/* remove events */
	splx(s);
	}	/* if events in CD queue */

	for (slot = MSCSLOTUL(unit, 0); slot < maxslot; slot++) {
	    msc = &mscdev[slot];

	    if (!msc->active)
		continue;

	    tp = msc_tty[MSCTTYSLOT(slot)];
	    ms = &msc->board->Status[msc->port];

	    newhead = ms->InHead;		/* 65c02 write pointer */

	    /* yoohoo, is the port open? */
	    if (tp && (tp->t_state & (TS_ISOPEN|TS_WOPEN))) {
		/* port is open, handle all type of events */

		/* set interrupt priority level */
		s = spltty();

		/* check for input for this port */
		if (newhead != (bufpos = ms->InTail)) {
		    /* buffer for input chars/events */
		    ibuf = &msc->board->InBuf[msc->port][0];

		    /* data types of bytes in ibuf */
		    cbuf = &msc->board->InCtl[msc->port][0];
    
		    /* do for all chars, if room */
		    while (bufpos != newhead) {
			/* which type of input data? */
			switch (cbuf[bufpos]) {
			    /* input event (CD, BREAK, etc.) */
			    case MSCINCTL_EVENT:
				switch (ibuf[bufpos++]) {
				    case MSCEVENT_Break:
					(*linesw[tp->t_line].l_rint)(TTY_FE, tp);
					break;

				    default:
					printf("msc%d: unknown event type %d\n",
					msc->unit, ibuf[(bufpos-1)&0xff]);
				} /* event type switch */
				break;

			    case MSCINCTL_CHAR:
				if (tp->t_state & TS_TBLOCK) {
				    goto NoRoomForYa;
				}
				(*linesw[tp->t_line].l_rint)((int)ibuf[bufpos++], tp);
				break;

			    default:
				printf("msc%d: unknown data type %d\n", 
				msc->unit, cbuf[bufpos]);
				bufpos++;
			} /* switch on input data type */
		    } /* while there's something in the buffer */
NoRoomForYa:
		ms->InTail = bufpos;		/* tell 65C02 what we've read */
	    } /* if there was something in the buffer */

	    /* we get here only when the port is open */
	    /* send output */
	    if (tp->t_state & (TS_BUSY|TS_FLUSH)) {

		bufpos = ms->OutHead - ms->OutTail;

		/* busy and below low water mark? */
		if (tp->t_state & TS_BUSY) {
		    if (bufpos < IOBUFLOWWATER) {
			tp->t_state &= ~TS_BUSY;	/* not busy any more */
			if (tp->t_line)
			    (*linesw[tp->t_line].l_start)(tp);
			else
			    mscstart(tp);
		    }
		}

		/* waiting for flush and buffer empty? */
		if (tp->t_state & TS_FLUSH) {
		    if (bufpos == 0)
			tp->t_state &= ~TS_FLUSH;	/* finished flushing */
		}
	    } /* BUSY or FLUSH */

	    splx(s);

	    } else { /* End of port open */
		/* port is closed, don't pass on the chars from it */

		/* check for input for this port */
		if (newhead != (bufpos = ms->InTail)) {
		    /* buffer for input chars/events */
		    ibuf = &msc->board->InBuf[msc->port][0];

		    /* data types of bytes in ibuf */
		    cbuf = &msc->board->InCtl[msc->port][0];
    
		    /* do for all chars, if room */
			while (bufpos != newhead) {
			    /* which type of input data? */
			    switch (cbuf[bufpos]) {
			    /* input event (BREAK, etc.) */
				case MSCINCTL_EVENT:
				    switch (ibuf[bufpos++]) {
					default:
					    printf("msc: unknown event type %d\n",
						ibuf[(bufpos-1)&0xff]);
				    } /* event type switch */
				    break;

				default:
				    bufpos++;
			    } /* switch on input data type */
			} /* while there's something in the buffer */

		    ms->InTail = bufpos;		/* tell 65C02 what we've read */
		} /* if there was something in the buffer */
	    } /* End of port open/close */

	    /* is this port closing? */
	    if (msc->closing) {
		/* if DTR is off, just bitbucket remaining characters */
		if ( (msc->flags & TIOCM_DTR) == 0) {
		    ms->OutFlush = TRUE;
		    msc->closing = FALSE;
		}
		/* if output has drained, drop DTR */
		else if (ms->OutHead == ms->OutTail) {
		    (void) mscmctl(tp->t_dev, 0, DMSET);
		    msc->closing = FALSE;
		}
	    }
	}  /* For all ports */
}

int
mscioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	register struct tty *tp;
	register int slot;
	register int error;
	struct mscdevice *msc;
	volatile struct mscstatus *ms;
	int s;
  
	/* get the device structure */
	slot = MSCSLOT(dev);

	if (slot >= MSCSLOTS)
		return ENXIO;

	msc = &mscdev[slot];

	if (!msc->active)
		return ENXIO;

	ms = &msc->board->Status[msc->port];
	if (!(tp = msc_tty[MSCTTY(dev)]))
		return ENXIO;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);

	if (error >= 0)
		return (error);

	error = ttioctl(tp, cmd, data, flag, p);

	if (error >= 0)
		return (error);
  
	switch (cmd) {

		/* send break */
		case TIOCSBRK:
			s = spltty();
			ms->Command = (ms->Command & (~MSCCMD_RTSMask)) | MSCCMD_Break;
			ms->Setup = TRUE;
			splx(s);
			break;

		/* clear break */
		case TIOCCBRK:
			s = spltty();
			ms->Command = (ms->Command & (~MSCCMD_RTSMask)) | MSCCMD_RTSOn;
			ms->Setup = TRUE;
			splx(s);
			break;

		case TIOCSDTR:
			(void) mscmctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIS);
			break;
      
		case TIOCCDTR:
			if (!MSCDIALIN(dev))	/* don't let dialins drop DTR */
				(void) mscmctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIC);
			break;
      
		case TIOCMSET:
			(void) mscmctl(dev, *(int *)data, DMSET);
			break;
      
		case TIOCMBIS:
			(void) mscmctl(dev, *(int *)data, DMBIS);
			break;
      
		case TIOCMBIC:
			if (MSCDIALIN(dev))	/* don't let dialins drop DTR */
				(void) mscmctl(dev, *(int *)data & TIOCM_DTR, DMBIC);
			else
				(void) mscmctl(dev, *(int *)data, DMBIC);
			break;
      
		case TIOCMGET:
			*(int *)data = mscmctl(dev, 0, DMGET);
			break;
      
		case TIOCGFLAGS:
			*(int *)data = SWFLAGS(dev);
			break;

		case TIOCSFLAGS:
			error = suser(p->p_ucred, &p->p_acflag);
			if (error != 0)
				return(EPERM);
			msc->openflags = *(int *)data;
			/* only allow valid flags */
			msc->openflags &=
			     (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS);
			break;

		default:
			return (ENOTTY);
	}

	return (0);
}

int
mscparam(tp, t)
	register struct tty *tp;
	register struct termios *t;
{
	register int cflag = t->c_cflag;
	struct mscdevice *msc;
	volatile struct mscstatus *ms;
	int s, slot;
	int ospeed = ttspeedtab(t->c_ospeed, mscspeedtab);
  
	/* get the device structure */
	slot = MSCSLOT(tp->t_dev);

	if (slot >= MSCSLOTS)
		return ENXIO;

	msc = &mscdev[slot];

	if (!msc->active)
		return ENXIO;

	ms = &msc->board->Status[msc->port];

	/* check requested parameters */
	if (ospeed < 0 || (t->c_ispeed && t->c_ispeed != t->c_ospeed))
		return (EINVAL);

	/* and copy to tty */
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = cflag;
  
	/* hang up if baud is zero */
	if (t->c_ospeed == 0) {
		if (!MSCDIALIN(tp->t_dev))  /* don't let dialins drop DTR */
			(void) mscmctl(tp->t_dev, 0, DMSET);
	} else {
		/* set the baud rate */
		s = spltty();
		ms->Param = (ms->Param & ~MSCPARAM_BaudMask) | ospeed | MSCPARAM_RcvBaud;

		/*
		 * Make sure any previous hangup is undone, ie.  reenable DTR.
		 * also mscmctl will cause the speed to be set
		 */
		(void) mscmctl (tp->t_dev, TIOCM_DTR | TIOCM_RTS, DMSET);

		splx(s);
	}
  
	return(0);
}


/*
 *	Jukka's code initializes alot of stuff that other drivers don't
 *	I'm including it here so that this code is a common set of work
 *	done by both of us. rfh
 */
int
mschwiflow(tp, flag)
	struct tty *tp;
	int flag;
{

/* Rob's version */
#if 1
	if (flag)
		mscmctl( tp->t_dev, TIOCM_RTS, DMBIC);	/* Clear/Lower RTS */
	else
		mscmctl( tp->t_dev, TIOCM_RTS, DMBIS);	/* Set/Raise RTS */

#else	/* Jukka's version */

	int s, slot;
	struct mscdevice *msc;
	volatile struct mscstatus *ms;

	/* get the device structure */
	slot = MSCSLOT(tp->t_dev);
	if (slot >= MSCSLOTS)
		return ENXIO;
	msc = &mscdev[slot];
	if (!msc->active)
		return ENXIO;
	ms = &msc->board->Status[msc->port];

	/* Well, we should really _do_ something here, but the 65c02 code
	 * manages the RTS signal on its own now, so...  This will probably
	 * change in the future.
	 */
#endif
	return 1;
}

void
mscstart(tp)
	register struct tty *tp;
{
	register int cc;
	register char *cp;
	register int mhead;
	int s, slot;
	struct mscdevice *msc;
	volatile struct mscstatus *ms;
	volatile char *mob;
	int hiwat = 0;
	int maxout;

	if (! (tp->t_state & TS_ISOPEN))
		return;

	slot = MSCSLOT(tp->t_dev);

#if 0
	printf("starting msc%d\n", slot);
#endif

	s = spltty();

	/* don't start if explicitly stopped */
	if (tp->t_state & (TS_TIMEOUT|TS_TTSTOP)) 
		goto out;

	/* wake up if below low water */
	cc = tp->t_outq.c_cc;

	if (cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}

	/* don't bother if no characters or busy */
	if (cc == 0 || (tp->t_state & TS_BUSY))
		goto out;

	/*
	 * Limit the amount of output we do in one burst
	 */
	msc = &mscdev[slot];
	ms = &msc->board->Status[msc->port];
	mhead = ms->OutHead;
	maxout = mhead - ms->OutTail;

	if (maxout < 0)
		maxout += IOBUFLEN;

	maxout = IOBUFLEN - 1 - maxout;

	if (cc >= maxout) {
		hiwat++;
		cc = maxout;
	}

	cc = q_to_b (&tp->t_outq, msc->tmpbuf, cc);

	if (cc > 0) {
		tp->t_state |= TS_BUSY;

		mob = &msc->board->OutBuf[msc->port][0];
		cp = &msc->tmpbuf[0];
      
		/* enable output */
		ms->OutDisable = FALSE;

#if 0
		msc->tmpbuf[cc] = 0;
		printf("sending '%s'\n", msctmpbuf);
#endif

		/* send the first char across to reduce latency */
		mob[mhead++] = *cp++;
		mhead &= IOBUFLENMASK;
		ms->OutHead = mhead;
		cc--;

		/* copy the rest of the chars across quickly */
		while (cc > 0) {
			mob[mhead++] = *cp++;
			mhead &= IOBUFLENMASK;
			cc--;
		}
		ms->OutHead = mhead;

		/* leave the device busy if we've filled the buffer */
		if (!hiwat)
			tp->t_state &= ~TS_BUSY;
	}

out:  
	splx(s);
}
 
/* XXX */
/*
 * Stop output on a line.
 */
/*ARGSUSED*/
int
mscstop(tp, flag)
	register struct tty *tp;
	int flag;			/* defaulted to int anyway */
{
	register int s;
#if 0
	struct mscdevice *msc;
	volatile struct mscstatus *ms;
#endif

	s = spltty();
	if (tp->t_state & TS_BUSY) {
		if ((tp->t_state & TS_TTSTOP) == 0) {
			tp->t_state |= TS_FLUSH;
#if 0
			msc = &mscdev[MSCSLOT(tp->t_dev)];
			ms = &msc->board->Status[msc->port];
			printf("stopped output on msc%d\n", MSCSLOT(tp->t_dev));
			ms->OutDisable = TRUE;
#endif
		}
	}
	splx(s);
	return 0;
}
 
/*
 * bits can be: TIOCM_DTR, TIOCM_RTS, TIOCM_CTS, TIOCM_CD, TIOCM_RI, TIOCM_DSR
 */
int
mscmctl(dev, bits, how)
	dev_t dev;
	int bits, how;
{
	struct mscdevice *msc;
	volatile struct mscstatus *ms;
	int slot;
	int s;
	u_char newcmd;
	int OldFlags;

	/* get the device structure */
	slot = MSCSLOT(dev);

	if (slot >= MSCSLOTS)
		return ENXIO;

	msc = &mscdev[slot];

	if (!msc->active)
		return ENXIO;

	s = spltty();

	if (how != DMGET) {
		OldFlags = msc->flags;
		bits &= TIOCM_DTR | TIOCM_RTS;	/* can only modify DTR and RTS */

		switch (how) {
		    case DMSET:
			msc->flags = (bits | (msc->flags & ~(TIOCM_DTR | TIOCM_RTS)));
			break;
      
		    case DMBIC:
			msc->flags &= ~bits;
			break;
      
		    case DMBIS:
			msc->flags |= bits;
			break;
		}

		/* modify modem control state */
		ms = &msc->board->Status[msc->port];

		if (msc->flags & TIOCM_RTS)	/* was bits & */
			newcmd = MSCCMD_RTSOn;
		else			/* this doesn't actually work now */
			newcmd = MSCCMD_RTSOff;

		if (msc->flags & TIOCM_DTR)	/* was bits & */
			newcmd |= MSCCMD_Enable;

		ms->Command = (ms->Command & (~MSCCMD_RTSMask & ~MSCCMD_Enable)) | newcmd;
		ms->Setup = TRUE;

		/* if we've dropped DTR, bitbucket any pending output */
		if ( (OldFlags & TIOCM_DTR) && ((bits & TIOCM_DTR) == 0))
			ms->OutFlush = TRUE;
	}

	bits = msc->flags;

	splx(s);
  
	return(bits);
}

struct tty *
msctty(dev)
	dev_t dev;
{
	return(msc_tty[MSCTTY(dev)]);
}

/*
 * Load JM's freely redistributable A2232 6502c code. Let turbo detector
 * run for a while too.
 */

int
mscinitcard(zap)
	struct zbus_args *zap;
{
	int bcount;
	short start;
	u_char *from;
	volatile u_char *to;
	volatile struct mscmemory *mlm;

	mlm = (volatile struct mscmemory *)zap->va;	
	(void)mlm->Enable6502Reset;

	/* copy the code across to the board */
	to = (u_char *)mlm;
	from = msc6502code; bcount = sizeof(msc6502code) - 2;
	start = *(short *)from; from += sizeof(start);
	to += start;

	while(bcount--) *to++ = *from++;

	mlm->Common.Crystal = MSC_UNKNOWN;	/* use automatic speed check */

	/* start 6502 running */
	(void)mlm->ResetBoard;

	/* wait until speed detector has finished */
	for (bcount = 0; bcount < 200; bcount++) {
		delay(10000);
		if (mlm->Common.Crystal)
			break;
	}

	return(0);
}

#endif  /* NMSC > 0 */
@


1.9
log
@Include <sys/conf.h> from <machine/conf.h> like in other arches.  Changes
to come soon depend on this.
@
text
@d1 1
a1 1
/*	$OpenBSD: msc.c,v 1.8 2002/03/14 01:26:29 millert Exp $ */
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: msc.c,v 1.7 2002/02/15 20:45:30 nordin Exp $ */
a78 1
#include <sys/conf.h>
@


1.7
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msc.c,v 1.6 1997/01/16 09:25:04 niklas Exp $ */
d110 4
a113 4
int	mscparam __P((struct tty *, struct termios *));
void	mscstart __P((struct tty *));
int	mschwiflow __P((struct tty *, int));
int	mscinitcard __P((struct zbus_args *));
d166 2
a167 2
int mscmctl __P((dev_t dev, int bits, int howto));
void mscmint __P((register void *data));
d169 2
a170 2
int mscmatch __P((struct device *, void *, void *));
void mscattach __P((struct device *, struct device *, void *));
@


1.6
log
@Sync to NetBSD 970110
@
text
@d1 1
a1 1
/*	$OpenBSD: msc.c,v 1.5 1996/08/23 18:53:14 niklas Exp $ */
d1132 1
a1132 1
	(void) splx(s);
@


1.6.24.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: msc.c,v 1.6 1997/01/16 09:25:04 niklas Exp $ */
d110 4
a113 4
int	mscparam(struct tty *, struct termios *);
void	mscstart(struct tty *);
int	mschwiflow(struct tty *, int);
int	mscinitcard(struct zbus_args *);
d166 2
a167 2
int mscmctl(dev_t dev, int bits, int howto);
void mscmint(register void *data);
d169 2
a170 2
int mscmatch(struct device *, void *, void *);
void mscattach(struct device *, struct device *, void *);
d1132 1
a1132 1
	splx(s);
@


1.6.24.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: msc.c,v 1.6.24.1 2002/06/11 03:34:58 art Exp $ */
d79 1
@


1.6.24.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: msc.c,v 1.6.24.2 2002/10/29 00:28:01 art Exp $ */
@


1.6.14.1
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1132 1
a1132 1
	splx(s);
@


1.6.14.2
log
@Merge in -current from about a week ago
@
text
@d110 4
a113 4
int	mscparam(struct tty *, struct termios *);
void	mscstart(struct tty *);
int	mschwiflow(struct tty *, int);
int	mscinitcard(struct zbus_args *);
d166 2
a167 2
int mscmctl(dev_t dev, int bits, int howto);
void mscmint(register void *data);
d169 2
a170 2
int mscmatch(struct device *, void *, void *);
void mscattach(struct device *, struct device *, void *);
@


1.6.14.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: msc.c,v 1.6.14.2 2002/03/28 10:06:14 niklas Exp $ */
@


1.5
log
@Merge to late July NetBSD, more to come...
@
text
@d1 2
a2 2
/*	$OpenBSD: msc.c,v 1.3 1996/04/21 22:15:39 deraadt Exp $ */
/*	$NetBSD: msc.c,v 1.6.4.1 1996/06/06 04:53:17 mhitch Exp $ */
d6 1
a6 1
 * Copyright (c) 1995 Jukka Marin <jmarin@@teeri.jmp.fi>.
d52 1
d125 2
a126 2
	{ 75,		MSCPARAM_B75 	},
	{ 110,		MSCPARAM_B110 	},
a172 1
#define	DEBUG_MSC	0
a182 24
#if DEBUG_MSC
void
bugi(msc, string)
	struct mscdevice *msc;
	char *string;
{
	volatile struct mscstatus *ms;
	volatile struct mscmemory *mscmem;

	mscmem = msc->board;
	ms = &mscmem->Status[msc->port];

	printf("msc  %s u%d f%08lx F%08lx\n", string, msc->port, msc->flags,
		msc->openflags);
	printf("msc  h%d t%d H%d t%d p%02x c%02x CD%02x\n", ms->InHead,
		ms->InTail, ms->OutHead, ms->OutTail, ms->Param, ms->Command,
		ms->chCD);
	printf("msc  a%02x b%02x c%02x\n", ms->Pad_a, ms->Pad_b, ms->Padc);

	return
}
	
#endif

d202 41
a242 52
  volatile struct mscmemory *mscmem;
  struct mscdevice *msc;
  struct zbus_args *zap;
  int unit;
  int Count;

  zap = (struct zbus_args *)auxp;
  unit = dp->dv_unit;

  if (mscinitcard(zap) != 0) {
    printf("\nmsc%d: Board initialize failed, bad download code.\n", unit);
    return;
  }

  printf("\nmsc%d: Board successfully initialized.\n", unit);

  mscmem = (struct mscmemory *) zap->va;

  if (mscmem->Common.Crystal == MSC_UNKNOWN) {
	printf("msc%d: Unable to detect crystal frequency.\n", unit);
	return;
  }

  if (mscmem->Common.Crystal == MSC_TURBO) {
	printf("msc%d: Turbo version detected (%02x%02x:%d)\n", unit,
		mscmem->Common.TimerH, mscmem->Common.TimerL,
		mscmem->Common.Pad_a);
	mscspeedtab = mscspeedtab_turbo;
  } else {
	printf("msc%d: Normal version detected (%02x%02x:%d)\n", unit,
		mscmem->Common.TimerH, mscmem->Common.TimerL,
		mscmem->Common.Pad_a);
	mscspeedtab = mscspeedtab_normal;
  }

  /* XXX 8 is a constant */
  for (Count = 0; Count < 8 && MSCSLOTUL(unit, Count) < MSCSLOTS; Count++) {
    msc = &mscdev[MSCSLOTUL(unit, Count)];
    msc->board = mscmem;
    msc->port = Count;
    msc->flags = 0;
    msc->openflags = 0;
    msc->active = 1;
    msc->closing = FALSE;
    msc_tty[MSCTTYSLOT(MSCSLOTUL(unit, Count))] = NULL;
    msc_tty[MSCTTYSLOT(MSCSLOTUL(unit, Count))+1] = NULL;

  }

  /* disable the non-existant eighth port */
  if (MSCSLOTUL(unit, NUMLINES) < MSCSLOTS)
    mscdev[MSCSLOTUL(unit, NUMLINES)].active = 0;
d244 20
a263 2
  msc_vbl_node[unit].function = (void (*) (void *)) mscmint;
  msc_vbl_node[unit].data = (void *) unit;
d265 1
a265 1
  add_vbl_function (&msc_vbl_node[unit], MSC_VBL_PRIORITY, (void *)unit);
d267 1
a267 1
  return; 
d277 5
a281 7
  register struct tty *tp;
  int error = 0;
  int s;
  int slot;
  int ttyn;
  struct mscdevice *msc;
  volatile struct mscstatus *ms;
d283 28
a310 28
  /* get the device structure */
  slot = MSCSLOT(dev);
  ttyn = MSCTTY(dev);

  if (slot >= MSCSLOTS)
    return ENXIO;

  if (MSCLINE(dev) >= NUMLINES)
    return ENXIO;

  msc = &mscdev[slot];
  ms = &msc->board->Status[msc->port];

  if (!msc->active)
    return ENXIO;

  /*
   * RFH: WHY here? Put down by while like other serial drivers
   *      But if we do that it makes things bomb.
   */
  s = spltty();

  if (!msc_tty[ttyn]) {

      tp = ttymalloc();
      tty_attach(tp);
      msc_tty[ttyn] = tp;
      msc_tty[ttyn+1] = (struct tty *)NULL;
d313 34
a346 8
      /* default values are not optimal for this device, increase buffers. */
      clfree(&tp->t_rawq);
      clfree(&tp->t_canq);
      clfree(&tp->t_outq);
      clalloc(&tp->t_rawq, 8192, 1);
      clalloc(&tp->t_canq, 8192, 1);
      clalloc(&tp->t_outq, 8192, 0);
#endif
d348 25
a372 11
  } 
  else
    tp = msc_tty[ttyn];

  tp->t_oproc = (void (*) (struct tty *)) mscstart;
  tp->t_param = mscparam;
  tp->t_dev = dev;
  tp->t_hwiflow = mschwiflow;
 
  /* if port is still closing, just bitbucket remaining characters */
  if (msc->closing) {
d374 9
a382 58
      ms->OutFlush = TRUE;
      msc->closing = FALSE;
  }

  /* initialize tty */
  if ((tp->t_state & TS_ISOPEN) == 0) {

      tp->t_state |= TS_WOPEN;
      ttychars(tp);
      if (tp->t_ispeed == 0) {

	  tp->t_iflag = TTYDEF_IFLAG;
	  tp->t_oflag = TTYDEF_OFLAG;
	  tp->t_cflag = TTYDEF_CFLAG;
	  tp->t_lflag = TTYDEF_LFLAG;
	  tp->t_ispeed = tp->t_ospeed = mscdefaultrate;
      }

      /* flags changed to be private to every unit by JM */
      if (msc->openflags & TIOCFLAG_CLOCAL)
		tp->t_cflag |= CLOCAL;
      if (msc->openflags & TIOCFLAG_CRTSCTS)
		tp->t_cflag |= CRTSCTS;
      if (msc->openflags & TIOCFLAG_MDMBUF)
		tp->t_cflag |= MDMBUF;

      mscparam(tp, &tp->t_termios);
      ttsetwater(tp);

      (void) mscmctl(dev, TIOCM_DTR | TIOCM_RTS, DMSET);

      if ((SWFLAGS(dev) & TIOCFLAG_SOFTCAR) ||
	  (mscmctl(dev, 0, DMGET) & TIOCM_CD))
            tp->t_state |= TS_CARR_ON;
      else
            tp->t_state &= ~TS_CARR_ON;

  } 
  else {
        if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
	    splx(s);
	    return (EBUSY);
       }
  }

  /*
   * if NONBLOCK requested, ignore carrier
   */
  if (flag & O_NONBLOCK)
    goto done;

  /* 
   * s = spltty();
   *
   * This causes hangs when put here, like other TTY drivers do, rather than
   * above, WHY? RFH
   *
   */
d384 7
a390 1
  while ((tp->t_state & TS_CARR_ON) == 0 && (tp->t_cflag & CLOCAL) == 0) {
d392 2
a393 1
      tp->t_state |= TS_WOPEN;
d396 1
a396 1
      printf("msc %ld waiting for CD\n", MSCLINE(dev));
d398 1
a398 1
      error = ttysleep(tp, (caddr_t)&tp->t_rawq, TTIPRI | PCATCH, ttopen, 0);
d400 5
a404 5
      if (error) {
               splx(s);
               return(error);
      }
  }
a405 1
done: 
d407 1
a407 1
  printf("msc %ld waiting for CD\n", MSCLINE(dev));
a408 13
  /* This is a way to handle lost XON characters */
  if ((flag & O_TRUNC) && (tp->t_state & TS_TTSTOP)) {
          tp->t_state &= ~TS_TTSTOP;
          ttstart (tp);
  }

  splx(s);

  /*
   * Reset the tty pointer, as there could have been a dialout
   * use of the tty with a dialin open waiting.
   */
  tp->t_dev = dev;
d410 14
a423 1
  return((*linesw[tp->t_line].l_open)(dev, tp));
d425 1
d434 4
a437 4
  register struct tty *tp;
  int slot;
  volatile struct mscstatus *ms;
  struct mscdevice *msc;
d439 2
a440 2
  /* get the device structure */
  slot = MSCSLOT(dev);
d442 2
a443 2
  if (slot >= MSCSLOTS)
    return ENXIO;
d445 1
a445 1
  msc = &mscdev[slot];
d447 2
a448 2
  if (!msc->active)
    return ENXIO;
d450 1
a450 1
  ms = &msc->board->Status[msc->port];
d452 2
a453 3
#if DEBUG_MSC
  bugi(msc, "close1");
#endif
d455 1
a455 2
  tp = msc_tty[MSCTTY(dev)];
  (*linesw[tp->t_line].l_close)(tp, flag);
d457 1
a457 1
  (void) mscmctl(dev, 0, DMSET);
d459 4
a462 12
  ttyclose(tp);

  if (msc->flags & TIOCM_DTR)
    msc->closing = TRUE; /* flush remaining characters before dropping DTR */
  else
    ms->OutFlush = TRUE; /* just bitbucket remaining characters */

#if DEBUG_MSC
  bugi(msc, "close2");
#endif

  return (0);
d464 1
d489 1
a489 1
  register struct tty *tp;
d491 1
a491 1
  tp = msc_tty[MSCTTY(dev)];
d493 2
a494 2
  if (! tp)
    return ENXIO;
d496 1
a496 1
  return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
d516 29
a544 61
  int unit;
  register struct tty *tp;
  int slot;
  int maxslot;
  struct mscdevice *msc;
  volatile struct mscstatus *ms;
  volatile u_char *ibuf, *cbuf;
  unsigned char newhead; /* was int */
  unsigned char bufpos;  /* was int */
  int s;

  unit = (int) data;

  /* check each line on this board */
  maxslot = MSCSLOTUL(unit, NUMLINES);
  if (maxslot > MSCSLOTS)
    maxslot = MSCSLOTS;

  for (slot = MSCSLOTUL(unit, 0); slot < maxslot; slot++)
    {
      msc = &mscdev[slot];

      if (!msc->active)
        continue;

      tp = msc_tty[MSCTTYSLOT(slot)];
      ms = &msc->board->Status[msc->port];

      newhead = ms->InHead;		/* 65c02 write pointer */

      /* yoohoo, is the port open? */
      if (tp && (tp->t_state & (TS_ISOPEN|TS_WOPEN))) {
	/* port is open, handle all type of events */

	/* set interrupt priority level */
        s = spltty();

      /* check for input for this port */
      if (newhead != (bufpos = ms->InTail))
      {
#if DEBUG_MSC
	      printf("iop%d\n",slot);
#endif
	      /* buffer for input chars/events */
	      ibuf = &msc->board->InBuf[msc->port][0];

	      /* data types of bytes in ibuf */
	      cbuf = &msc->board->InCtl[msc->port][0];
    
	      /* do for all chars, if room */
	      while (bufpos != newhead)
	      {
		  /* which type of input data? */
		  switch (cbuf[bufpos])
		  {
		      /* input event (CD, BREAK, etc.) */
		      case MSCINCTL_EVENT:
			switch (ibuf[bufpos++])
			{
			    /* carrier detect change OFF -> ON */
			    case MSCEVENT_CarrierOn:
d546 1
a546 1
			      printf("msc  CD ON %d\n", msc->port);
d548 4
a551 7
			      msc->flags |= TIOCM_CD;
			      if (MSCDIALIN(tp->t_dev))
				(*linesw[tp->t_line].l_modem)(tp, 1);
			      break;
    
			    /*  carrier detect change ON -> OFF */
			    case MSCEVENT_CarrierOff:
d553 1
a553 1
			      printf("msc  CD OFF %d\n", msc->port);
d555 4
a558 1
			      msc->flags &= ~TIOCM_CD;
d560 17
a576 18
			      if (MSCDIALIN(tp->t_dev))
#endif			    /* Note to format police: Don't merge the { below
			       in to the line above! */
			      {
				  if ((*linesw[tp->t_line].l_modem)(tp, 0) == 0)
				  {
				      /* clear RTS and DTR, bitbucket output */
				      ms->Command = (ms->Command & ~MSCCMD_CMask) | MSCCMD_Close;
				      ms->Setup = TRUE;
				      msc->flags &= ~(TIOCM_DTR | TIOCM_RTS);
				      ms->OutFlush = TRUE;
				  }
			      }
			      break;
    
			    case MSCEVENT_Break:
#if DEBUG_MSC
			      printf("Break received on msc%d\n", slot);
d578 24
a601 6
			      (*linesw[tp->t_line].l_rint)(TTY_FE, tp);
			      break;
    
			    default:
			      printf("msc: unknown event type %d\n",
				      ibuf[(bufpos-1)&0xff]);
d603 1
a603 2
			} /* event type switch */
			break;
d605 3
a607 9
		      case MSCINCTL_CHAR:
			 if (tp->t_state & TS_TBLOCK) {
			   if (ms->chCD) {
			     /* Carrier detect ON -> OFF */
#if DEBUG_CD
			     printf("msc  CD OFF blocked %d msc->flags %08lx\n",
				    msc->port, msc->flags);
#endif
			     msc->flags &= ~TIOCM_CD;
d609 2
a610 21
#ifndef MSCCDHACK
			     if (MSCDIALIN(tp->t_dev))
#endif
			     {
			       if ((*linesw[tp->t_line].l_modem)(tp, 0) == 0) {
				 /* Clear RTS and DTR, bitbucket output */
				 ms->Command = (ms->Command & ~MSCCMD_CMask) |
					       MSCCMD_Close;
				 ms->Setup = TRUE;
				 msc->flags &= ~(TIOCM_DTR | TIOCM_RTS);
				 ms->OutFlush = TRUE;
			       }
			     }
			   }
			   goto NoRoomForYa;
			 }
#if DEBUG_MSC
			 printf("'%c' ",ibuf[bufpos]);
#endif
			 (*linesw[tp->t_line].l_rint)((int)ibuf[bufpos++], tp);
			break;
d612 4
a615 3
		      default:
			printf("msc: unknown data type %d\n", cbuf[bufpos]);
			bufpos++;
d617 26
a642 1
		   } /* switch on input data type */
d644 6
a649 1
		} /* while there's something in the buffer */
d651 1
a651 2
	      ms->InTail = bufpos;		/* tell 65C02 what we've read */

d654 14
a667 17
	  /* we get here only when the port is open */
	  /* send output */
	   if (tp->t_state & (TS_BUSY|TS_FLUSH))
	    {

	      bufpos = ms->OutHead - ms->OutTail;

	      /* busy and below low water mark? */
	      if (tp->t_state & TS_BUSY)
	        {
	          if (bufpos < IOBUFLOWWATER)
		    {
		      tp->t_state &= ~TS_BUSY;	/* not busy any more */
		      if (tp->t_line)
		        (*linesw[tp->t_line].l_start)(tp);
		      else
		        mscstart(tp);
d671 5
a675 6
	      /* waiting for flush and buffer empty? */
	      if (tp->t_state & TS_FLUSH)
	        {
	          if (bufpos == 0)
	            tp->t_state &= ~TS_FLUSH;	/* finished flushing */
	        }
d678 1
a678 1
	     splx(s);
d680 2
a681 2
      } else { /* End of port open */
	/* port is closed, don't pass on the chars from it */
d683 4
a686 8
      /* check for input for this port */
      if (newhead != (bufpos = ms->InTail))
      {
#if DEBUG_MSC
	      printf("icp%d\n",slot);
#endif
	      /* buffer for input chars/events */
	      ibuf = &msc->board->InBuf[msc->port][0];
d688 2
a689 2
	      /* data types of bytes in ibuf */
	      cbuf = &msc->board->InCtl[msc->port][0];
d691 34
a724 68
	      /* do for all chars, if room */
	      while (bufpos != newhead)
	      {
		  /* which type of input data? */
		  switch (cbuf[bufpos])
		  {
		      /* input event (CD, BREAK, etc.) */
		      case MSCINCTL_EVENT:
			switch (ibuf[bufpos++])
			{
			    /* carrier detect change OFF -> ON */
			    case MSCEVENT_CarrierOn:
#if DEBUG_CD
			      printf("msc  CD ON %d (closed)\n", msc->port);
#endif
			      msc->flags |= TIOCM_CD;
			      break;
    
			    /*  carrier detect change ON -> OFF */
			    case MSCEVENT_CarrierOff:
#if DEBUG_CD
			      printf("msc  CD OFF %d (closed)\n", msc->port);
#endif
			      msc->flags &= ~TIOCM_CD;
#ifndef MSCCDHACK
			      if (tp && MSCDIALIN(tp->t_dev))
#else
			      if (tp )
#endif
			      {
				  if ((*linesw[tp->t_line].l_modem)(tp, 0) == 0)
				  {
				      /* clear RTS and DTR, bitbucket output */
				      ms->Command = (ms->Command & ~MSCCMD_CMask) | MSCCMD_Close;
				      ms->Setup = TRUE;
				      msc->flags &= ~(TIOCM_DTR | TIOCM_RTS);
				      ms->OutFlush = TRUE;
				  }
			      }
			      break;
    
			    default:
			      printf("msc: unknown event type %d\n",
				     ibuf[(bufpos-1)&0xff]);

			} /* event type switch */
			break;

		      default:
			bufpos++;

		   } /* switch on input data type */

		} /* while there's something in the buffer */

	        ms->InTail = bufpos;		/* tell 65C02 what we've read */

	    } /* if there was something in the buffer */
      } /* End of port open/close */

      /* is this port closing? */
      if (msc->closing)
        {
	  /* if DTR is off, just bitbucket remaining characters */
	  if ( (msc->flags & TIOCM_DTR) == 0)
	    {
	      ms->OutFlush = TRUE;
	      msc->closing = FALSE;
d726 1
a726 9
	  /* if output has drained, drop DTR */
          else if (ms->OutHead == ms->OutTail)
	    {
	      (void) mscmctl(tp->t_dev, 0, DMSET);
	      msc->closing = FALSE;
            }
        }
    }  /* For all ports */
  
d737 6
a742 6
  register struct tty *tp;
  register int slot;
  register int error;
  struct mscdevice *msc;
  volatile struct mscstatus *ms;
  int s;
d744 2
a745 2
  /* get the device structure */
  slot = MSCSLOT(dev);
d747 2
a748 2
  if (slot >= MSCSLOTS)
    return ENXIO;
d750 1
a750 1
  msc = &mscdev[slot];
d752 2
a753 2
  if (!msc->active)
    return ENXIO;
d755 3
a757 3
  ms = &msc->board->Status[msc->port];
  if (!(tp = msc_tty[MSCTTY(dev)]))
    return ENXIO;
d759 1
a759 1
  error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
d761 2
a762 2
  if (error >= 0)
    return (error);
d764 1
a764 1
  error = ttioctl(tp, cmd, data, flag, p);
d766 2
a767 2
  if (error >= 0)
    return (error);
d769 17
a785 1
  switch (cmd) {
d787 3
a789 19
      /* send break */
    case TIOCSBRK:
      s = spltty();
      ms->Command = (ms->Command & (~MSCCMD_RTSMask)) | MSCCMD_Break;
      ms->Setup = TRUE;
      splx(s);
      break;

      /* clear break */
    case TIOCCBRK:
      s = spltty();
      ms->Command = (ms->Command & (~MSCCMD_RTSMask)) | MSCCMD_RTSOn;
      ms->Setup = TRUE;
      splx(s);
      break;

    case TIOCSDTR:
      (void) mscmctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIS);
      break;
d791 4
a794 4
    case TIOCCDTR:
      if (!MSCDIALIN(dev))	/* don't let dialins drop DTR */
        (void) mscmctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIC);
      break;
d796 3
a798 3
    case TIOCMSET:
      (void) mscmctl(dev, *(int *)data, DMSET);
      break;
d800 3
a802 3
    case TIOCMBIS:
      (void) mscmctl(dev, *(int *)data, DMBIS);
      break;
d804 6
a809 6
    case TIOCMBIC:
      if (MSCDIALIN(dev))	/* don't let dialins drop DTR */
        (void) mscmctl(dev, *(int *)data & TIOCM_DTR, DMBIC);
      else
        (void) mscmctl(dev, *(int *)data, DMBIC);
      break;
d811 3
a813 3
    case TIOCMGET:
      *(int *)data = mscmctl(dev, 0, DMGET);
      break;
d815 3
a817 10
    case TIOCGFLAGS:
      *(int *)data = SWFLAGS(dev);
      break;

    case TIOCSFLAGS:
      error = suser(p->p_ucred, &p->p_acflag);
      if (error != 0)
              return(EPERM);
      
      msc->openflags = *(int *)data;
d819 9
a827 2
      /* only allow valid flags */
      msc->openflags &= (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS);
d829 3
a831 1
      break;
d833 1
a833 5
    default:
      return (ENOTTY);
    }

  return (0);
a835 1

d841 5
a845 6
  register int cflag = t->c_cflag;
  int slot;
  struct mscdevice *msc;
  volatile struct mscstatus *ms;
  int s;
  int ospeed = ttspeedtab(t->c_ospeed, mscspeedtab);
d847 2
a848 2
  /* get the device structure */
  slot = MSCSLOT(tp->t_dev);
d850 2
a851 2
  if (slot >= MSCSLOTS)
    return ENXIO;
d853 1
a853 1
  msc = &mscdev[slot];
d855 2
a856 2
  if (!msc->active)
    return ENXIO;
d858 1
a858 1
  ms = &msc->board->Status[msc->port];
d860 8
a867 11
#if DEBUG_MSC
  bugi(msc, "param1");
#endif
  /* check requested parameters */
  if (ospeed < 0 || (t->c_ispeed && t->c_ispeed != t->c_ospeed))
    return (EINVAL);

  /* and copy to tty */
  tp->t_ispeed = t->c_ispeed;
  tp->t_ospeed = t->c_ospeed;
  tp->t_cflag = cflag;
d869 14
a882 2
  /* hang up if baud is zero */
  if (t->c_ospeed == 0) {
d884 2
a885 16
      if (!MSCDIALIN(tp->t_dev))  /* don't let dialins drop DTR */
        (void) mscmctl(tp->t_dev, 0, DMSET);
  }
  else {

      /* set the baud rate */
      s = spltty();
      ms->Param = (ms->Param & ~MSCPARAM_BaudMask) | ospeed | MSCPARAM_RcvBaud;

      /* make sure any previous hangup is undone, ie.  reenable DTR.
       * also mscmctl will cause the speed to be set
       */
      (void) mscmctl (tp->t_dev, TIOCM_DTR | TIOCM_RTS, DMSET);

      splx(s);
  }
d887 1
a887 5
#if DEBUG_MSC
  bugi(msc, "param2");
#endif
  return (0);

a903 4
#if DEBUG_MSC
	printf("mschwiflow %d\n", flag);
#endif

d905 1
a905 1
	   mscmctl( tp->t_dev, TIOCM_RTS, DMBIC); /* Clear/Lower RTS */
d907 1
a907 3
	   mscmctl( tp->t_dev, TIOCM_RTS, DMBIS); /* Set/Raise RTS */
	
#endif
d909 1
a909 15
/* Jukka's version */
#if 0
  int slot;
  struct mscdevice *msc;
  volatile struct mscstatus *ms;
  int s;

  /* get the device structure */
  slot = MSCSLOT(tp->t_dev);
  if (slot >= MSCSLOTS)
    return ENXIO;
  msc = &mscdev[slot];
  if (!msc->active)
    return ENXIO;
  ms = &msc->board->Status[msc->port];
d911 3
a913 7
#if DEBUG_MSC
  bugi(msc, "hwiflow");
#endif
  /* Well, we should really _do_ something here, but the 65c02 code
   * manages the RTS signal on its own now, so...  This will probably
   * change in the future.
   */
d915 13
a929 1

d936 9
a944 10
  register int cc;
  register char *cp;
  register int mhead;
  int s;
  int slot;
  struct mscdevice *msc;
  volatile struct mscstatus *ms;
  volatile char *mob;
  int hiwat = 0;
  int maxout;
d946 2
a947 2
  if (! (tp->t_state & TS_ISOPEN))
    return;
d949 1
a949 1
  slot = MSCSLOT(tp->t_dev);
d952 1
a952 1
  printf("starting msc%d\n", slot);
d955 1
a955 1
  s = spltty();
d957 14
a970 9
  /* don't start if explicitly stopped */
  if (tp->t_state & (TS_TIMEOUT|TS_TTSTOP)) 
    goto out;

  /* wake up if below low water */
  cc = tp->t_outq.c_cc;

  if (cc <= tp->t_lowat) {
      if (tp->t_state & TS_ASLEEP) {
d972 20
a991 2
	  tp->t_state &= ~TS_ASLEEP;
	  wakeup((caddr_t)&tp->t_outq);
d994 1
a994 2
      selwakeup(&tp->t_wsel);
  }
d996 2
a997 21
  /* don't bother if no characters or busy */
  if (cc == 0 || (tp->t_state & TS_BUSY))
    goto out;

  /*
   * Limit the amount of output we do in one burst
   */
  msc = &mscdev[slot];
  ms = &msc->board->Status[msc->port];
  mhead = ms->OutHead;
  maxout = mhead - ms->OutTail;

  if (maxout < 0)
      maxout += IOBUFLEN;

  maxout = IOBUFLEN - 1 - maxout;

  if (cc >= maxout) {
      hiwat++;
      cc = maxout;
  }
d999 2
a1000 7
  cc = q_to_b (&tp->t_outq, msc->tmpbuf, cc);

  if (cc > 0) {
      tp->t_state |= TS_BUSY;

      mob = &msc->board->OutBuf[msc->port][0];
      cp = &msc->tmpbuf[0];
d1002 2
a1003 2
      /* enable output */
      ms->OutDisable = FALSE;
d1006 2
a1007 2
      msc->tmpbuf[cc] = 0;
      printf("sending '%s'\n", msctmpbuf);
d1010 18
a1027 18
      /* send the first char across to reduce latency */
      mob[mhead++] = *cp++;
      mhead &= IOBUFLENMASK;
      ms->OutHead = mhead;
      cc--;

      /* copy the rest of the chars across quickly */
      while (cc > 0) {
	  mob[mhead++] = *cp++;
	  mhead &= IOBUFLENMASK;
	  cc--;
      }
      ms->OutHead = mhead;

      /* leave the device busy if we've filled the buffer */
      if (!hiwat)
        tp->t_state &= ~TS_BUSY;
    }
d1030 1
a1030 2
  splx(s);

d1073 6
a1078 12
  struct mscdevice *msc;
  volatile struct mscstatus *ms;
  int slot;
  int s;
  u_char newcmd;
  int OldFlags;

  /* get the device structure */
  slot = MSCSLOT(dev);

  if (slot >= MSCSLOTS)
    return ENXIO;
d1080 2
a1081 1
  msc = &mscdev[slot];
d1083 2
a1084 2
  if (!msc->active)
    return ENXIO;
d1086 4
a1089 3
#if DEBUG_MSC
  bugi(msc, "mctl1");
#endif
d1091 1
a1091 1
  s = spltty();		/* Jukka wants spl6() here, WHY?!! RFH */
d1093 8
a1100 8
  if (how != DMGET) {
      OldFlags = msc->flags;
      bits &= TIOCM_DTR | TIOCM_RTS; /* can only modify DTR and RTS */

      switch (how) {
        case DMSET:
	  msc->flags = (bits | (msc->flags & ~(TIOCM_DTR | TIOCM_RTS)));
          break;
d1102 3
a1104 3
        case DMBIC:
          msc->flags &= ~bits;
          break;
d1106 4
a1109 4
        case DMBIS:
          msc->flags |= bits;
          break;
      }
d1111 2
a1112 3
#if DEBUG_MSC
    bugi(msc, "mctl2");
#endif
d1114 15
a1128 13
      /* modify modem control state */
      ms = &msc->board->Status[msc->port];

      if (msc->flags & TIOCM_RTS)	/* was bits & */
	newcmd = MSCCMD_RTSOn;
      else			/* this doesn't actually work now */
	newcmd = MSCCMD_RTSOff;

      if (msc->flags & TIOCM_DTR)	/* was bits & */
	newcmd |= MSCCMD_Enable;

      ms->Command = (ms->Command & (~MSCCMD_RTSMask & ~MSCCMD_Enable)) | newcmd;
      ms->Setup = TRUE;
d1130 1
a1130 4
      /* if we've dropped DTR, bitbucket any pending output */
      if ( (OldFlags & TIOCM_DTR) && ((bits & TIOCM_DTR) == 0))
        ms->OutFlush = TRUE;
  }
d1132 1
a1132 3
  bits = msc->flags;

  (void) splx(s);
d1134 1
a1134 6
#if DEBUG_MSC
    bugi(msc, "mctl3");
#endif

  return(bits);

d1153 28
a1180 35
  int bcount;
  short start;
  u_char *from;
  volatile u_char *to;
  volatile struct mscmemory *mlm;

  mlm = (volatile struct mscmemory *)zap->va;	
  (void)mlm->Enable6502Reset;

  /* copy the code across to the board */
  to = (u_char *)mlm;
  from = msc6502code; bcount = sizeof(msc6502code) - 2;
  start = *(short *)from; from += sizeof(start);
  to += start;

#if DEBUG_MSC
  printf("\n** copying %ld bytes from %08lx to %08lx (start=%04lx)\n",
	  (unsigned long)bcount, (unsigned long)from, to, start);
  printf("First byte to copy is %02lx\n", *from);
#endif

  while(bcount--) *to++ = *from++;

  mlm->Common.Crystal = MSC_UNKNOWN;	/* use automatic speed check */

  /* start 6502 running */
  (void)mlm->ResetBoard;

  /* wait until speed detector has finished */
  for (bcount = 0; bcount < 200; bcount++) {
	delay(10000);
	if (mlm->Common.Crystal) break;
  }

  return(0);
d1182 1
@


1.4
log
@Sync with NetBSD 9600430.  The port has gone over a major -Wall treat
@
text
@d2 1
a2 1
/*	$NetBSD: msc.c,v 1.6 1996/04/21 21:12:15 veego Exp $ */
d327 1
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: msc.c,v 1.5 1996/03/17 05:58:54 mhitch Exp $ */
a61 1
#include <sys/conf.h>
d78 3
d109 2
a110 2
int	mscparam();
int	mscstart __P((struct tty *));
d122 18
a139 18
	0,	0,
	50,	MSCPARAM_B50,
	75,	MSCPARAM_B75,
	110,	MSCPARAM_B110,
	134,	MSCPARAM_B134,
	150,	MSCPARAM_B150,
	300,	MSCPARAM_B300,
	600,	MSCPARAM_B600,
	1200,	MSCPARAM_B1200,
	1800,	MSCPARAM_B1800,
	2400,	MSCPARAM_B2400,
	3600,	MSCPARAM_B3600,
	4800,	MSCPARAM_B4800,
	7200,	MSCPARAM_B7200,
	9600,	MSCPARAM_B9600,
	19200,	MSCPARAM_B19200,
	115200,	MSCPARAM_B115200,
	-1,	-1
d143 18
a160 18
	0,	0,
	100,	MSCPARAM_B50,
	150,	MSCPARAM_B75,
	220,	MSCPARAM_B110,
	269,	MSCPARAM_B134,
	300,	MSCPARAM_B150,
	600,	MSCPARAM_B300,
	1200,	MSCPARAM_B600,
	2400,	MSCPARAM_B1200,
	3600,	MSCPARAM_B1800,
	4800,	MSCPARAM_B2400,
	7200,	MSCPARAM_B3600,
	9600,	MSCPARAM_B4800,
	14400,	MSCPARAM_B7200,
	19200,	MSCPARAM_B9600,
	38400,	MSCPARAM_B19200,
	230400,	MSCPARAM_B115200,
	-1,	-1
a211 1
	struct cfdata *cdp = match;
d822 1
a822 1
	int cmd;
d934 1
a934 1
  register int cfcr, cflag = t->c_cflag;
d1047 1
a1047 1
int
d1163 1
d1166 1
d1170 1
a1170 1
		if (tp->t_state & TS_TTSTOP == 0) {
d1181 1
@


1.2
log
@From NetBSD:
Fix #includes.
@
text
@d1 2
a2 1
/*	$NetBSD: msc.c,v 1.3 1996/02/02 18:05:44 mycroft Exp $ */
d166 1
a166 1
int mscmatch __P((struct device *, struct cfdata *, void *));
d173 6
a178 3
struct cfdriver msccd = {
	NULL, "msc", (cfmatch_t) mscmatch, mscattach, DV_TTY,
	sizeof(struct device), NULL, 0
d206 1
a206 1
mscmatch(pdp, cdp, auxp)
d208 1
a208 2
	struct cfdata *cdp;
	void *auxp;
d210 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: msc.c,v 1.2 1995/10/07 18:18:26 chopps Exp $ */
d72 1
a72 1
#include "machine/cpu.h"
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
