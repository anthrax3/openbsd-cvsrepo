head	1.12;
access;
symbols
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.24
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.22
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.20
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.18
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.16
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.14
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.12
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.10
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.8
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.6
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2002.12.31.16.35.38;	author miod;	state dead;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.29;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.01.18.12.26.32;	author niklas;	state Exp;
branches
	1.10.14.1
	1.10.24.1;
next	1.9;

1.9
date	96.11.23.21.45.21;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	96.10.04.15.10.40;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.05.06.09.35.05;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.05.02.06.44.19;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.15.36;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.03.30.22.18.22;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.03.24.17.26.24;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.06.09.23.33;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.00;	author deraadt;	state Exp;
branches;
next	;

1.10.14.1
date	2002.03.28.10.06.14;	author niklas;	state Exp;
branches;
next	1.10.14.2;

1.10.14.2
date	2003.03.27.23.19.18;	author niklas;	state dead;
branches;
next	;

1.10.24.1
date	2002.06.11.03.34.58;	author art;	state Exp;
branches;
next	1.10.24.2;

1.10.24.2
date	2003.05.19.21.49.39;	author tedu;	state dead;
branches;
next	;


desc
@@


1.12
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: mgnsc.c,v 1.11 2002/03/14 01:26:29 millert Exp $	*/
/*	$NetBSD: mgnsc.c,v 1.18 1996/04/21 21:12:11 veego Exp $	*/

/*
 * Copyright (c) 1994 Michael L. Hitch
 * Copyright (c) 1982, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)dma.c
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <machine/intr.h>
#include <machine/psl.h>
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <amiga/amiga/custom.h>
#include <amiga/amiga/cc.h>
#include <amiga/amiga/device.h>
#include <amiga/amiga/isr.h>
#include <amiga/dev/siopreg.h>
#include <amiga/dev/siopvar.h>
#include <amiga/dev/zbusvar.h>

void mgnscattach(struct device *, struct device *, void *);
int mgnscmatch(struct device *, void *, void *);
int mgnsc_dmaintr(void *);
#ifdef DEBUG
void mgnsc_dump(void);
#endif

struct scsi_adapter mgnsc_scsiswitch = {
	siop_scsicmd,
	siop_minphys,
	0,			/* no lun support */
	0,			/* no lun support */
};

struct scsi_device mgnsc_scsidev = {
	NULL,		/* use default error handler */
	NULL,		/* do not have a start functio */
	NULL,		/* have no async handler */
	NULL,		/* Use default done routine */
};


#ifdef DEBUG
#endif

struct cfattach mgnsc_ca = {
	sizeof(struct siop_softc), mgnscmatch, mgnscattach
};

struct cfdriver mgnsc_cd = {
	NULL, "mgnsc", DV_DULL, NULL, 0
};

/*
 * if we are a CSA Magnum 40 SCSI
 */
int
mgnscmatch(pdp, match, auxp)
	struct device *pdp;
	void *match, *auxp;
{
	struct zbus_args *zap;

	zap = auxp;
	if (zap->manid == 1058 && zap->prodid == 17)
		return(1);
	return(0);
}

void
mgnscattach(pdp, dp, auxp)
	struct device *pdp, *dp;
	void *auxp;
{
	struct siop_softc *sc;
	struct zbus_args *zap;
	siop_regmap_p rp;

	printf("\n");
	zap = auxp;

	sc = (struct siop_softc *)dp;
	sc->sc_siopp = rp = zap->va + 0x8000;

	/*
	 * CTEST7 = TT1
	 */
	sc->sc_clock_freq = 33;		/* Clock = 33Mhz */
	sc->sc_ctest7 = SIOP_CTEST7_TT1;
	sc->sc_dcntl = 0x00;

	alloc_sicallback();

	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = 7;
	sc->sc_link.adapter = &mgnsc_scsiswitch;
	sc->sc_link.device = &mgnsc_scsidev;
	sc->sc_link.openings = 2;

	siopinitialize(sc);

	sc->sc_isr.isr_intr = mgnsc_dmaintr;
	sc->sc_isr.isr_arg = sc;
	sc->sc_isr.isr_ipl = 6;
#if defined(IPL_REMAP_1) || defined(IPL_REMAP_2)
	sc->sc_isr.isr_mapped_ipl = IPL_BIO;
#endif
	add_isr (&sc->sc_isr);

	/*
	 * attach all scsi units on us
	 */
	config_found(dp, &sc->sc_link, scsiprint);
}

/*
 * Level 6 interrupt processing for the Magnum/40 SCSI. Because the
 * level 6 interrupt is above splbio, the interrupt status is saved
 * and an sicallback to the level 2 interrupt handler scheduled.
 * This way, the actual processing of the interrupt can be deferred
 * until splbio is unblocked.
 */

int
mgnsc_dmaintr(arg)
	void *arg;
{
	struct siop_softc *sc = arg;
	siop_regmap_p rp;
	u_char istat;

	if (sc->sc_flags & SIOP_INTSOFF)
		return (0);	/* interrupts are not active */
	rp = sc->sc_siopp;
	istat = rp->siop_istat;
	if ((istat & (SIOP_ISTAT_SIP | SIOP_ISTAT_DIP)) == 0)
		return (0);
	/*
	 * save interrupt status, DMA status, and SCSI status 0
	 * (may need to deal with stacked interrupts?)
	 */
	sc->sc_sstat0 = rp->siop_sstat0;
	sc->sc_istat = istat;
	sc->sc_dstat = rp->siop_dstat;
	/*
	 * disable interrupts until the callback can process this
	 * interrupt.
	 */
	rp->siop_sien = 0;
	rp->siop_dien = 0;
	sc->sc_flags |= SIOP_INTDEFER | SIOP_INTSOFF;
#if defined(IPL_REMAP_1) || defined(IPL_REMAP_2)
	siopintr(sc);
#else
	add_sicallback((sifunc_t)siopintr, sc, NULL);
#endif
	return (1);
}

#ifdef DEBUG
void
mgnsc_dump()
{
	int i;

	for (i = 0; i < mgnsc_cd.cd_ndevs; ++i)
		if (mgnsc_cd.cd_devs[i])
			siop_dump(mgnsc_cd.cd_devs[i]);
}
#endif
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mgnsc.c,v 1.10 1997/01/18 12:26:32 niklas Exp $	*/
@


1.10
log
@Use scsiprint
@
text
@d1 1
a1 1
/*	$OpenBSD: mgnsc.c,v 1.9 1996/11/23 21:45:21 kstailey Exp $	*/
d56 3
a58 3
void mgnscattach __P((struct device *, struct device *, void *));
int mgnscmatch __P((struct device *, void *, void *));
int mgnsc_dmaintr __P((void *));
d60 1
a60 1
void mgnsc_dump __P((void));
@


1.10.24.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mgnsc.c,v 1.10 1997/01/18 12:26:32 niklas Exp $	*/
d56 3
a58 3
void mgnscattach(struct device *, struct device *, void *);
int mgnscmatch(struct device *, void *, void *);
int mgnsc_dmaintr(void *);
d60 1
a60 1
void mgnsc_dump(void);
@


1.10.24.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: mgnsc.c,v 1.10.24.1 2002/06/11 03:34:58 art Exp $	*/
@


1.10.14.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 3
a58 3
void mgnscattach(struct device *, struct device *, void *);
int mgnscmatch(struct device *, void *, void *);
int mgnsc_dmaintr(void *);
d60 1
a60 1
void mgnsc_dump(void);
@


1.10.14.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: mgnsc.c,v 1.10.14.1 2002/03/28 10:06:14 niklas Exp $	*/
@


1.9
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: mgnsc.c,v 1.8 1996/10/04 15:10:40 niklas Exp $	*/
a55 1
int mgnscprint __P((void *auxp, const char *));
d148 1
a148 14
	config_found(dp, &sc->sc_link, mgnscprint);
}

/*
 * print diag if pnp is NULL else just extra
 */
int
mgnscprint(auxp, pnp)
	void *auxp;
	const char *pnp;
{
	if (pnp == NULL)
		return(UNCONF);
	return(QUIET);
@


1.8
log
@IPL_* constants now found in intr.h
@
text
@d1 1
a1 1
/*	$OpenBSD: mgnsc.c,v 1.5 1996/04/21 22:15:36 deraadt Exp $	*/
d56 1
a56 1
int mgnscprint __P((void *auxp, char *));
d158 1
a158 1
	char *pnp;
@


1.7
log
@Fix typo, lost newline
@
text
@d44 1
@


1.6
log
@Sync with NetBSD 9600430.  The port has gone over a major -Wall treat
@
text
@d204 2
a205 1
#endif	return (1);
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: mgnsc.c,v 1.4 1996/03/30 22:18:22 niklas Exp $	*/
/*	$NetBSD: mgnsc.c,v 1.17 1996/03/17 01:17:45 thorpej Exp $	*/
d58 4
a61 2
int siopintr __P((struct siop_softc *));
int mgnsc_dmaintr __P((struct siop_softc *));
a96 1
	struct cfdata *cdp = match;
d173 2
a174 2
mgnsc_dmaintr(sc)
	struct siop_softc *sc;
d176 1
@


1.4
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: mgnsc.c,v 1.16 1996/03/15 22:11:12 mhitch Exp $	*/
d57 1
a57 1
int mgnscmatch __P((struct device *, struct cfdata *, void *));
d79 7
a85 3
struct cfdriver mgnsccd = {
	NULL, "mgnsc", (cfmatch_t)mgnscmatch, mgnscattach, 
	DV_DULL, sizeof(struct siop_softc), NULL, 0 };
d91 1
a91 1
mgnscmatch(pdp, cdp, auxp)
d93 1
a93 2
	struct cfdata *cdp;
	void *auxp;
d95 1
d211 3
a213 3
	for (i = 0; i < mgnsccd.cd_ndevs; ++i)
		if (mgnsccd.cd_devs[i])
			siop_dump(mgnsccd.cd_devs[i]);
@


1.3
log
@Use IPL_ constants instead of numeric values.  Get rid of sicallbacks
in favour of the remapped IPL facility.  Some argument type fixes as
well.
@
text
@d1 2
a2 1
/*	$NetBSD: mgnsc.c,v 1.15 1995/10/09 15:20:36 chopps Exp $	*/
d119 2
a120 1
	sc->sc_ctest7 = 0x02;		/* TT1 */
@


1.2
log
@Added support for a new (well, I've run it locally for a year or two)
interrupt system which is a prerequisite for the Amiga ISA support.
It is described in amiga/amiga/README.ints, and is enabled by adding
an "options IPL_REMAP_1" in the kernel config file.  Along with this
change there is also some generic cleanup, like style polishing,
comment corrections, making sicallbacks operate in FIFO manner and
cleaning up the spl mess in param.h...
@
text
@d43 1
d134 1
a134 2
	/* XXX Don't remap it yet, the driver uses a sicallback still.  */
	sc->sc_isr.isr_mapped_ipl = 6;
d192 3
d196 1
a196 1
	return (1);
@


1.1
log
@Initial revision
@
text
@d132 4
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
