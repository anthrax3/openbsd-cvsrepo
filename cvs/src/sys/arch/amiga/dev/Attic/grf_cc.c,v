head	1.12;
access;
symbols
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.7.0.6
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.16
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.14
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.12
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2002.12.31.16.35.37;	author miod;	state dead;
branches;
next	1.11;

1.11
date	2002.06.11.03.25.42;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.28;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.11.06.00.30.37;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.27.21.32.47;	author art;	state Exp;
branches;
next	1.6;

1.6
date	97.01.16.09.24.08;	author niklas;	state Exp;
branches
	1.6.14.1;
next	1.5;

1.5
date	96.11.24.20.23.41;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.11.23.21.45.10;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.05.02.06.43.42;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.22.15.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.56;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.56;	author deraadt;	state Exp;
branches;
next	;

1.6.14.1
date	2001.04.18.16.02.07;	author niklas;	state Exp;
branches;
next	1.6.14.2;

1.6.14.2
date	2001.11.13.21.00.50;	author niklas;	state Exp;
branches;
next	1.6.14.3;

1.6.14.3
date	2002.03.28.10.06.14;	author niklas;	state Exp;
branches;
next	1.6.14.4;

1.6.14.4
date	2003.03.27.23.19.17;	author niklas;	state dead;
branches;
next	;

1.9.2.1
date	2002.06.11.03.34.57;	author art;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.10.29.00.28.01;	author art;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2003.05.19.21.49.38;	author tedu;	state dead;
branches;
next	;


desc
@@


1.12
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: grf_cc.c,v 1.11 2002/06/11 03:25:42 miod Exp $	*/
/*	$NetBSD: grf_cc.c,v 1.23 1996/12/23 09:10:02 veego Exp $	*/

/*
 * Copyright (c) 1994 Christian E. Hopps
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christian E. Hopps.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include "grfcc.h"
#if NGRFCC > 0
/*
 * currently this is a backward compat hack that interface to 
 * view.c
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <uvm/uvm_param.h>
#include <machine/cpu.h>
#include <amiga/amiga/color.h>	/* DEBUG */
#include <amiga/amiga/device.h>
#include <amiga/amiga/custom.h>
#include <amiga/amiga/cia.h>
#include <amiga/dev/grfioctl.h>
#include <amiga/dev/grfvar.h>
#include <amiga/dev/grf_ccreg.h>
#include <amiga/dev/grfabs_reg.h>
#include <amiga/dev/viewioctl.h>

#include <machine/conf.h>
#include <uvm/uvm_extern.h>

#include "view.h" 

int grfccmatch(struct device *, void *, void *);
int grfccprint(void *, const char *);
void grfccattach(struct device *, struct device *, void *);
void grf_cc_on(struct grf_softc *);

struct cfattach grfcc_ca = {
	sizeof(struct grf_softc), grfccmatch, grfccattach
};

struct cfdriver grfcc_cd = {
	NULL, "grfcc", DV_DULL, NULL, 0
};

/* 
 * only used in console init
 */
static struct cfdata *grfcc_cfdata;

/*
 * we make sure to only init things once.  this is somewhat
 * tricky regarding the console.
 */
int 
grfccmatch(pdp, match, auxp)
	struct device *pdp;
	void *match, *auxp;
{
	struct cfdata *cfp = match;
	static int ccconunit = -1;
	char *mainbus_name = auxp;

	/*
	 * allow only one cc console
	 */
	if (amiga_realconfig == 0 && ccconunit != -1)
		return(0);
	if (matchname("grfcc", mainbus_name) == 0)
		return(0);
	if (amiga_realconfig == 0 || ccconunit != cfp->cf_unit) {
		if (grfcc_probe() == 0) 
			return(0);
		viewprobe();
		/*
		 * XXX nasty hack. opens view[0] and never closes.
		 */
		if (viewopen(0, 0, 0, NULL))
			return(0);
		if (amiga_realconfig == 0) {
			ccconunit = cfp->cf_unit;
			grfcc_cfdata = cfp;
		}
	}
	return(1);
}

/* 
 * attach to the grfbus (mainbus)
 */
void
grfccattach(pdp, dp, auxp)
	struct device *pdp, *dp;
	void *auxp;
{
	static struct grf_softc congrf;
	struct grf_softc *gp;

	if (dp == NULL) 
		gp = &congrf;
	else
		gp = (struct grf_softc *)dp;

	if (dp != NULL && congrf.g_regkva != 0) {
		/*
		 * we inited earlier just copy the info
		 * take care not to copy the device struct though.
		 */
		bcopy(&congrf.g_display, &gp->g_display, 
		    (char *)&gp[1] - (char *)&gp->g_display);
	} else {
		gp->g_unit = GRF_CC_UNIT;
		gp->g_flags = GF_ALIVE;
		gp->g_mode = cc_mode;
		gp->g_conpri = grfcc_cnprobe();
		grfcc_iteinit(gp);
		grf_cc_on(gp);
	}
	if (dp != NULL)
		printf("\n");
	/*
	 * attach grf
	 */
	amiga_config_found(grfcc_cfdata, &gp->g_device, gp, grfccprint);
}

int
grfccprint(auxp, pnp)
	void *auxp;
	const char *pnp;
{
	if (pnp)
		printf("grf%d at %s", ((struct grf_softc *)auxp)->g_unit,
			pnp);
	return(UNCONF);
}

/*
 * Change the mode of the display.
 * Right now all we can do is grfon/grfoff.
 * Return a UNIX error number or 0 for success.
 */
/*ARGSUSED*/
int
cc_mode(gp, cmd, arg, a2, a3)
	struct grf_softc *gp;
	u_long cmd;
	void *arg;
	u_long a2;
	int a3;
{

	switch (cmd) {
	case GM_GRFON:
		grf_cc_on(gp);
		return(0);
	case GM_GRFOFF:
		viewioctl(0, VIOCREMOVE, NULL, -1, NULL);
		return(0);
	case GM_GRFCONFIG:
	default:
		break;
	}
	return(EINVAL);
}

void
grf_cc_on(gp)
	struct grf_softc *gp;
{
	struct view_size vs;
	bmap_t bm;
	struct grfinfo *gi;

	gi = &gp->g_display;

	viewioctl(0, VIOCGBMAP, (caddr_t)&bm, -1, NULL); /* XXX type of bm ? */
  
	gp->g_data = (caddr_t) 0xDeadBeaf; /* not particularly clean.. */
  
	gi->gd_regaddr = (caddr_t) 0xdff000;	/* depricated */
	gi->gd_regsize = round_page(sizeof (custom));
	gi->gd_fbaddr  = bm.hardware_address;
	gi->gd_fbsize  = bm.depth*bm.bytes_per_row*bm.rows;

	if (viewioctl (0, VIOCGSIZE, (caddr_t)&vs, -1, NULL)) {
		/* XXX type of vs ? */
		/* fill in some default values... XXX */
		vs.width = 640;
		vs.height = 400;
		vs.depth = 2;
	}
	gi->gd_colors = 1 << vs.depth;
	gi->gd_planes = vs.depth;
  
	gi->gd_fbwidth = vs.width;
	gi->gd_fbheight = vs.height;
	gi->gd_fbx = 0;
	gi->gd_fby = 0;
	gi->gd_dwidth = vs.width;
	gi->gd_dheight = vs.height;
	gi->gd_dx = 0;
	gi->gd_dy = 0;

	gp->g_regkva = (void *)0xDeadBeaf;	/* builtin */
	gp->g_fbkva = NULL;		/* not needed, view internal */

	viewioctl(0, VIOCDISPLAY, NULL, -1, NULL);
}    
#endif

@


1.11
log
@Include <sys/conf.h> from <machine/conf.h> like in other arches.  Changes
to come soon depend on this.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_cc.c,v 1.10 2002/03/14 01:26:28 millert Exp $	*/
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_cc.c,v 1.9 2001/11/06 19:53:14 miod Exp $	*/
a58 1
#include <sys/conf.h>
@


1.9
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_cc.c,v 1.8 2001/11/06 00:30:37 art Exp $	*/
d65 4
a68 4
int grfccmatch __P((struct device *, void *, void *));
int grfccprint __P((void *, const char *));
void grfccattach __P((struct device *, struct device *, void *));
void grf_cc_on __P((struct grf_softc *));
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_cc.c,v 1.9 2001/11/06 19:53:14 miod Exp $	*/
d65 4
a68 4
int grfccmatch(struct device *, void *, void *);
int grfccprint(void *, const char *);
void grfccattach(struct device *, struct device *, void *);
void grf_cc_on(struct grf_softc *);
@


1.9.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_cc.c,v 1.9.2.1 2002/06/11 03:34:57 art Exp $	*/
d59 1
@


1.9.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_cc.c,v 1.9.2.2 2002/10/29 00:28:01 art Exp $	*/
@


1.8
log
@Kill vm/vm_param.h, move it to uvm/uvm_param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_cc.c,v 1.7 2000/05/27 21:32:47 art Exp $	*/
d61 1
a61 1
#include <vm/vm.h>
@


1.7
log
@Need to include <vm/vm.h> for round_page.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_cc.c,v 1.6 1997/01/16 09:24:08 niklas Exp $	*/
d47 1
a47 1
#include <vm/vm_param.h>
@


1.6
log
@Sync to NetBSD 970110
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_cc.c,v 1.5 1996/11/24 20:23:41 niklas Exp $	*/
d61 1
@


1.6.14.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_cc.c,v 1.7 2000/05/27 21:32:47 art Exp $	*/
a60 1
#include <vm/vm.h>
@


1.6.14.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
#include <uvm/uvm_param.h>
d61 1
a61 1
#include <uvm/uvm_extern.h>
@


1.6.14.3
log
@Merge in -current from about a week ago
@
text
@d65 4
a68 4
int grfccmatch(struct device *, void *, void *);
int grfccprint(void *, const char *);
void grfccattach(struct device *, struct device *, void *);
void grf_cc_on(struct grf_softc *);
@


1.6.14.4
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_cc.c,v 1.6.14.3 2002/03/28 10:06:14 niklas Exp $	*/
@


1.5
log
@extern decl of cfdata from device.h conflicted with static one in-here
@
text
@d1 2
a2 2
/*	$OpenBSD: grf_cc.c,v 1.4 1996/11/23 21:45:10 kstailey Exp $	*/
/*	$NetBSD: grf_cc.c,v 1.19 1996/04/21 21:11:08 veego Exp $	*/
@


1.4
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_cc.c,v 1.3 1996/05/02 06:43:42 niklas Exp $	*/
d80 1
a80 1
static struct cfdata *cfdata;
d113 1
a113 1
			cfdata = cfp;
d155 1
a155 1
	amiga_config_found(cfdata, &gp->g_device, gp, grfccprint);
@


1.3
log
@Sync with NetBSD 9600430.  The port has gone over a major -Wall treat
@
text
@d1 1
a1 1
/*	$OpenBSD: grf_cc.c,v 1.2 1996/04/21 22:15:09 deraadt Exp $	*/
d65 1
a65 1
int grfccprint __P((void *, char *));
d161 1
a161 1
	char *pnp;
@


1.2
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: grf_cc.c,v 1.18 1996/03/17 01:17:10 thorpej Exp $	*/
d41 1
d46 1
d59 4
d109 1
a109 1
		if (viewopen(0, 0))
a127 1
	static int coninited;
d178 1
a178 1
	int cmd, a2, a3;
d180 2
d183 1
d189 1
a189 1
		viewioctl(0, VIOCREMOVE, NULL, 0, -1);
d208 1
a208 1
	viewioctl(0, VIOCGBMAP, &bm, 0, -1);
d217 2
a218 1
	if (viewioctl (0, VIOCGSIZE, &vs, 0, -1)) {
d239 1
a239 1
	viewioctl(0, VIOCDISPLAY, NULL, 0, -1);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: grf_cc.c,v 1.17 1995/02/16 21:57:34 chopps Exp $	*/
d58 1
a58 1
int grfccmatch __P((struct device *, struct cfdata *, void *));
d63 7
a69 3
struct cfdriver grfcccd = {
	NULL, "grfcc", (cfmatch_t)grfccmatch, grfccattach, 
	DV_DULL, sizeof(struct grf_softc), NULL, 0 };
d81 1
a81 1
grfccmatch(pdp, cfp, auxp)
d83 1
a83 2
	struct cfdata *cfp;
	void *auxp;
d85 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
