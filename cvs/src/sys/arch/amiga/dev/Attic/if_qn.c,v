head	1.16;
access;
symbols
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	UBC_SYNC_A:1.16
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.15
	UBC:1.14.0.4
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.12.0.8
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.6
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.4
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.11.0.6
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2002.12.31.16.35.37;	author miod;	state dead;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.29;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.29.08.18.19;	author jj;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2001.02.20.19.39.30;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	99.05.13.15.44.48;	author jason;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	98.03.01.14.18.02;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.09.18.13.39.57;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.01.16.09.24.47;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.05.09.22.40.02;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.05.06.08.10.30;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.05.05.13.36.38;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.05.02.06.44.08;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.15.29;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.27.22.23.56;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.03.53.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.59;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.59;	author deraadt;	state Exp;
branches;
next	;

1.12.4.1
date	2001.04.18.16.02.12;	author niklas;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2001.07.04.10.15.10;	author niklas;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2002.03.28.10.06.14;	author niklas;	state Exp;
branches;
next	1.12.4.4;

1.12.4.4
date	2003.03.27.23.19.18;	author niklas;	state dead;
branches;
next	;

1.14.4.1
date	2002.06.11.03.34.58;	author art;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2003.05.19.21.49.39;	author tedu;	state dead;
branches;
next	;


desc
@@


1.16
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: if_qn.c,v 1.15 2002/03/14 01:26:29 millert Exp $	*/
/*	$NetBSD: if_qn.c,v 1.10 1996/12/23 09:10:19 veego Exp $	*/

/*
 * Copyright (c) 1995 Mika Kortelainen
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by  Mika Kortelainen
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Thanks for Aspecs Oy (Finland) for the data book for the NIC used
 * in this card and also many thanks for the Resource Management Force
 * (QuickNet card manufacturer) and especially Daniel Koch for providing
 * me with the necessary 'inside' information to write the driver.
 *
 * This is partly based on other code:
 * - if_ed.c: basic function structure for Ethernet driver and now also
 *	qn_put() is done similarly, i.e. no extra packet buffers.
 *
 *	Device driver for National Semiconductor DS8390/WD83C690 based ethernet
 *	adapters.
 *
 *	Copyright (c) 1994, 1995 Charles M. Hannum.  All rights reserved.
 *
 *	Copyright (C) 1993, David Greenman.  This software may be used,
 *	modified, copied, distributed, and sold, in both source and binary
 *	form provided that the above copyright and these terms are retained.
 *	Under no circumstances is the author responsible for the proper
 *	functioning of this software, nor does the author assume any
 *	responsibility for damages incurred with its use.
 *
 * - if_es.c: used as an example of -current driver
 *
 *	Copyright (c) 1995 Michael L. Hitch
 *	All rights reserved.
 *
 * - if_fe.c: some ideas for error handling for qn_rint() which might
 *	have fixed those random lock ups, too.
 *
 *	All Rights Reserved, Copyright (C) Fujitsu Limited 1995
 *
 *
 * TODO:
 * - add multicast support
 */

#include "qn.h"
#if NQN > 0

#define QN_DEBUG
#define QN_DEBUG1_no /* hides some old tests */
#define QN_CHECKS_no /* adds some checks (not needed in normal situations) */

#include "bpfilter.h"

/*
 * Fujitsu MB86950 Ethernet Controller (as used in the QuickNet QN2000
 * Ethernet card)
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/ioctl.h>
#include <sys/errno.h>

#include <net/if.h>
#include <net/netisr.h>
#include <net/route.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#endif

#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

#include <machine/cpu.h>
#include <machine/mtpr.h>
#include <amiga/amiga/device.h>
#include <amiga/amiga/isr.h>
#include <amiga/dev/zbusvar.h>
#include <amiga/dev/if_qnreg.h>


/* #define ETHER_MIN_LEN	60
#define ETHER_MAX_LEN	1514
#define ETHER_HDR_SIZE	14 */
#define	NIC_R_MASK	(R_INT_PKT_RDY | R_INT_ALG_ERR |\
			 R_INT_CRC_ERR | R_INT_OVR_FLO)
#define	MAX_PACKETS	30 /* max number of packets read per interrupt */

/*
 * Ethernet software status per interface
 *
 * Each interface is referenced by a network interface structure,
 * qn_if, which the routing code uses to locate the interface.
 * This structure contains the output queue for the interface, its address, ...
 */
struct	qn_softc {
	struct	device sc_dev;
	struct	isr sc_isr;
	struct	arpcom sc_arpcom;	/* Common ethernet structures */
	u_char	volatile *sc_base;
	u_char	volatile *sc_nic_base;
	u_short	volatile *nic_fifo;
	u_short	volatile *nic_r_status;
	u_short	volatile *nic_t_status;
	u_short	volatile *nic_r_mask;
	u_short	volatile *nic_t_mask;
	u_short	volatile *nic_r_mode;
	u_short	volatile *nic_t_mode;
	u_short	volatile *nic_reset;
	u_short	volatile *nic_len;
	u_char	transmit_pending;
#if NBPFILTER > 0
	caddr_t	sc_bpf;
#endif
} qn_softc[NQN];

#if NBPFILTER > 0
#include <net/bpf.h>
#include <net/bpfdesc.h>
#endif


int	qnmatch(struct device *, void *, void *);
void	qnattach(struct device *, struct device *, void *);
int	qnintr(void *);
int	qnioctl(struct ifnet *, u_long, caddr_t);
void	qnstart(struct ifnet *);
void	qnwatchdog(struct ifnet *);
void	qnreset(struct qn_softc *);
void	qninit(struct qn_softc *);
void	qnstop(struct qn_softc *);
static	u_short qn_put(u_short volatile *, struct mbuf *);
static	void qn_rint(struct qn_softc *, u_short);
static	void qn_flush(struct qn_softc *);
static	void __inline word_copy_from_card(u_short volatile *, u_short *, u_short);
static	void __inline word_copy_to_card(u_short *, u_short volatile *, u_short);
void	qn_get_packet(struct qn_softc *, u_short); 
#ifdef QN_DEBUG1
static	void qn_dump(struct qn_softc *);
#endif

struct cfattach qn_ca = {
	sizeof(struct qn_softc), qnmatch, qnattach
};

struct cfdriver qn_cd = {
	NULL, "qn", DV_IFNET
};


int
qnmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct zbus_args *zap;

	zap = (struct zbus_args *)aux;

	/* RMF QuickNet QN2000 EtherNet card */
	if (zap->manid == 2011 && zap->prodid == 2)
		return (1);

	return (0);
}

/*
 * Interface exists: make available by filling in network interface
 * record.  System will initialize the interface when it is ready
 * to accept packets.
 */
void
qnattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct zbus_args *zap;
	struct qn_softc *sc = (struct qn_softc *)self;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	zap = (struct zbus_args *)aux;

	sc->sc_base = zap->va;
	sc->sc_nic_base = sc->sc_base + QUICKNET_NIC_BASE;
	sc->nic_fifo = (u_short volatile *)(sc->sc_nic_base + NIC_BMPR0);
	sc->nic_len = (u_short volatile *)(sc->sc_nic_base + NIC_BMPR2);
	sc->nic_t_status = (u_short volatile *)(sc->sc_nic_base + NIC_DLCR0);
	sc->nic_r_status = (u_short volatile *)(sc->sc_nic_base + NIC_DLCR2);
	sc->nic_t_mask = (u_short volatile *)(sc->sc_nic_base + NIC_DLCR1);
	sc->nic_r_mask = (u_short volatile *)(sc->sc_nic_base + NIC_DLCR3);
	sc->nic_t_mode = (u_short volatile *)(sc->sc_nic_base + NIC_DLCR4);
	sc->nic_r_mode = (u_short volatile *)(sc->sc_nic_base + NIC_DLCR5);
	sc->nic_reset = (u_short volatile *)(sc->sc_nic_base + NIC_DLCR6);
	sc->transmit_pending = 0;

	/*
	 * The ethernet address of the board (1st three bytes are the vendor
	 * address, the rest is the serial number of the board).
	 */
	sc->sc_arpcom.ac_enaddr[0] = 0x5c;
	sc->sc_arpcom.ac_enaddr[1] = 0x5c;
	sc->sc_arpcom.ac_enaddr[2] = 0x00;
	sc->sc_arpcom.ac_enaddr[3] = (zap->serno >> 16) & 0xff;
	sc->sc_arpcom.ac_enaddr[4] = (zap->serno >> 8) & 0xff;
	sc->sc_arpcom.ac_enaddr[5] = zap->serno & 0xff;

	/* set interface to stopped condition (reset) */
	qnstop(sc);

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_ioctl = qnioctl;
	ifp->if_watchdog = qnwatchdog;
	ifp->if_output = ether_output;
	ifp->if_start = qnstart;
	/* XXX IFF_MULTICAST */
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;
	ifp->if_mtu = ETHERMTU;

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

#ifdef QN_DEBUG
	printf(": hardware address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
#endif

	sc->sc_isr.isr_intr = qnintr;
	sc->sc_isr.isr_arg = sc;
	sc->sc_isr.isr_ipl = 2;
	add_isr(&sc->sc_isr);
}

/*
 * Initialize device
 *
 */
void
qninit(sc)
	struct qn_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_short i;
	static int retry = 0;

	*sc->nic_r_mask   = NIC_R_MASK;
	*sc->nic_t_mode   = NO_LOOPBACK;

	if (sc->sc_arpcom.ac_if.if_flags & IFF_PROMISC) {
		*sc->nic_r_mode = PROMISCUOUS_MODE;
		log(LOG_INFO, "qn: Promiscuous mode (not tested)\n");
	} else
		*sc->nic_r_mode = NORMAL_MODE;

	/* Set physical ethernet address. */
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		*((u_short volatile *)(sc->sc_nic_base+
				       QNET_HARDWARE_ADDRESS+2*i)) =
		    ((((u_short)sc->sc_arpcom.ac_enaddr[i]) << 8) |
		    sc->sc_arpcom.ac_enaddr[i]);

	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;
	sc->transmit_pending = 0;

	qn_flush(sc);

	/* QuickNet magic. Done ONLY once, otherwise a lockup occurs. */
	if (retry == 0) {
		*((u_short volatile *)(sc->sc_nic_base + QNET_MAGIC)) = 0;
		retry = 1;
	}

	/* Enable data link controller. */
	*sc->nic_reset = ENABLE_DLC;

	/* Attempt to start output, if any. */
	qnstart(ifp);
}

/*
 * Device timeout/watchdog routine.  Entered if the device neglects to
 * generate an interrupt after a transmit has been started on it.
 */
void
qnwatchdog(ifp)
	struct ifnet *ifp;
{
	struct qn_softc *sc = ifp->if_softc;

	log(LOG_INFO, "qn: device timeout (watchdog)\n");
	++sc->sc_arpcom.ac_if.if_oerrors;

	qnreset(sc);
}

/*
 * Flush card's buffer RAM.
 */
static void
qn_flush(sc)
	struct qn_softc *sc;
{
#if 1
	/* Read data until bus read error (i.e. buffer empty). */
	while (!(*sc->nic_r_status & R_BUS_RD_ERR))
		(void)(*sc->nic_fifo);
#else
	/* Read data twice to clear some internal pipelines. */
	(void)(*sc->nic_fifo);
	(void)(*sc->nic_fifo);
#endif

	/* Clear bus read error. */
	*sc->nic_r_status = R_BUS_RD_ERR;
}

/*
 * Reset the interface.
 *
 */
void
qnreset(sc)
	struct qn_softc *sc;
{
	int s;

	s = splnet();
	qnstop(sc);
	qninit(sc);
	splx(s);
}

/*
 * Take interface offline.
 */
void
qnstop(sc)
	struct qn_softc *sc;
{

	/* Stop the interface. */
	*sc->nic_reset    = DISABLE_DLC;
	delay(200);
	*sc->nic_t_status = CLEAR_T_ERR;
	*sc->nic_t_mask   = CLEAR_T_MASK;
	*sc->nic_r_status = CLEAR_R_ERR;
	*sc->nic_r_mask   = CLEAR_R_MASK;

	/* Turn DMA off */
	*((u_short volatile *)(sc->sc_nic_base + NIC_BMPR4)) = 0;

	/* Accept no packets. */
	*sc->nic_r_mode = 0;
	*sc->nic_t_mode = 0;

	qn_flush(sc);
}

/*
 * Start output on interface. Get another datagram to send
 * off the interface queue, and copy it to the
 * interface before starting the output.
 *
 * This assumes that it is called inside a critical section...
 *
 */
void
qnstart(ifp)
	struct ifnet *ifp;
{
	struct qn_softc *sc = ifp->if_softc;
	struct mbuf *m;
	u_short len;
	int timout = 60000;


	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
		return;

	IF_DEQUEUE(&sc->sc_arpcom.ac_if.if_snd, m);
	if (m == 0)
		return;

#if NBPFILTER > 0
	/*
	 * If bpf is listening on this interface, let it
	 * see the packet before we commit it to the wire
	 *
	 * (can't give the copy in QuickNet card RAM to bpf, because
	 * that RAM is not visible to the host but is read from FIFO)
	 *
	 */
	if (sc->sc_bpf)
		bpf_mtap(sc->sc_bpf, m);
#endif
	len = qn_put(sc->nic_fifo, m);
	m_freem(m);

	/*
	 * Really transmit the packet.
	 */

	/* Set packet length (byte-swapped). */
	len = ((len >> 8) & 0x0007) | TRANSMIT_START | ((len & 0x00ff) << 8);
	*sc->nic_len = len;

	/* Wait for the packet to really leave. */
	while (!(*sc->nic_t_status & T_TMT_OK) && --timout) {
		if ((timout % 10000) == 0)
			log(LOG_INFO, "qn: timout...\n");
	}

	if (timout == 0)
		/* Maybe we should try to recover from this one? */
		/* But now, let's just fall thru and hope the best... */
		log(LOG_INFO, "qn: transmit timout (fatal?)\n");

	sc->transmit_pending = 1;
	*sc->nic_t_mask = INT_TMT_OK | INT_SIXTEEN_COL;

	sc->sc_arpcom.ac_if.if_flags |= IFF_OACTIVE;
	ifp->if_timer = 2;
}

/*
 * Memory copy, copies word at a time
 */
static void __inline
word_copy_from_card(card, b, len)
	u_short volatile *card;
	u_short *b, len;
{
	register u_short l = len/2;

	while (l--)
		*b++ = *card;
}

static void __inline
word_copy_to_card(a, card, len)
	u_short *a;
	u_short volatile *card;
	u_short len;
{
	while (len--)
		*card = *a++;
}

/*
 * Copy packet from mbuf to the board memory
 */
u_short
qn_put(addr, m)
	u_short volatile *addr;
	struct mbuf *m;
{
	u_short *data;
	u_char savebyte[2];
	int len, len1, wantbyte;
	u_short totlen;

	totlen = wantbyte = 0;

	for (; m != NULL; m = m->m_next) {
		data = mtod(m, u_short *);
		len = m->m_len;
		if (len > 0) {
			totlen += len;

			/* Finish the last word. */
			if (wantbyte) {
				savebyte[1] = *((u_char *)data);
				*addr = *((u_short *)savebyte);
				((u_char *)data)++;
				len--;
				wantbyte = 0;
			}
			/* Output contiguous words. */
			if (len > 1) {
				len1 = len/2;
				word_copy_to_card(data, addr, len1);
				data += len1;
				len &= 1;
			}
			/* Save last byte, if necessary. */
			if (len == 1) {
				savebyte[0] = *((u_char *)data);
				wantbyte = 1;
			}
		}
	}

	if (wantbyte) {
		savebyte[1] = 0;
		*addr = *((u_short *)savebyte);
	}

	if(totlen < ETHER_MIN_LEN) {
		/*
		 * Fill the rest of the packet with zeros.
		 * N.B.: This is required! Otherwise MB86950 fails.
		 */
		for(len = totlen + 1; len < ETHER_MIN_LEN; len += 2)
	  		*addr = (u_short)0x0000;
		totlen = ETHER_MIN_LEN;
	}

	return (totlen);
}

/*
 * Copy packet from board RAM.
 *
 * Trailers not supported.
 *
 */
void
qn_get_packet(sc, len)
	struct qn_softc *sc;
	u_short len;
{
	register u_short volatile *nic_fifo_ptr = sc->nic_fifo;
	struct ether_header *eh;
	struct mbuf *m, *dst, *head = NULL;
	register u_short len1;
	u_short amount;

	/* Allocate header mbuf. */
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		goto bad;

	/*
	 * Round len to even value.
	 */
	if (len & 1)
		len++;

	m->m_pkthdr.rcvif = &sc->sc_arpcom.ac_if;
	m->m_pkthdr.len = len;
	m->m_len = 0;
	head = m;

	eh = mtod(head, struct ether_header *);

	word_copy_from_card(nic_fifo_ptr,
	    mtod(head, u_short *),
	    sizeof(struct ether_header));

	head->m_len += sizeof(struct ether_header);
	len -= sizeof(struct ether_header);

	while (len > 0) {
		len1 = len;

		amount = M_TRAILINGSPACE(m);
		if (amount == 0) {
			/* Allocate another mbuf. */
			dst = m;
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL)
				goto bad;

			if (len1 >= MINCLSIZE)
				MCLGET(m, M_DONTWAIT);

			m->m_len = 0;
			dst->m_next = m;

			amount = M_TRAILINGSPACE(m);
		}

		if (amount < len1)
			len1 = amount;

		word_copy_from_card(nic_fifo_ptr,
		    (u_short *)(mtod(m, caddr_t) + m->m_len),
		    len1);
		m->m_len += len1;
		len -= len1;
	}

#if NBPFILTER > 0
	if (sc->sc_bpf)
		bpf_mtap(sc->sc_bpf, head);
#endif

	m_adj(head, sizeof(struct ether_header));
	ether_input(&sc->sc_arpcom.ac_if, eh, head);
	return;

bad:
	if (head) {
		m_freem(head);
		log(LOG_INFO, "qn_get_packet: mbuf alloc failed\n");
	}
}

/*
 * Ethernet interface receiver interrupt.
 */
static void
qn_rint(sc, rstat)
	struct qn_softc *sc;
	u_short rstat;
{
	int i;
	u_short len, status;

	/* Clear the status register. */
	*sc->nic_r_status = CLEAR_R_ERR;

	/*
	 * Was there some error?
	 * Some of them are senseless because they are masked off.
	 * XXX
	 */
	if (rstat & R_INT_OVR_FLO) {
#ifdef QN_DEBUG
		log(LOG_INFO, "Overflow\n");
#endif
		++sc->sc_arpcom.ac_if.if_ierrors;
	}
	if (rstat & R_INT_CRC_ERR) {
#ifdef QN_DEBUG
		log(LOG_INFO, "CRC Error\n");
#endif
		++sc->sc_arpcom.ac_if.if_ierrors;
	}
	if (rstat & R_INT_ALG_ERR) {
#ifdef QN_DEBUG
		log(LOG_INFO, "Alignment error\n");
#endif
		++sc->sc_arpcom.ac_if.if_ierrors;
	}
	if (rstat & R_INT_SRT_PKT) {
		/* Short packet (these may occur and are
		 * no reason to worry about - or maybe
		 * they are?).
		 */
#ifdef QN_DEBUG
		log(LOG_INFO, "Short packet\n");
#endif
		++sc->sc_arpcom.ac_if.if_ierrors;
	}
	if (rstat & 0x4040) {
#ifdef QN_DEBUG
		log(LOG_INFO, "Bus read error\n");
#endif
		++sc->sc_arpcom.ac_if.if_ierrors;
		qnreset(sc);
	}

	/*
	 * Read at most MAX_PACKETS packets per interrupt
	 */
	for (i = 0; i < MAX_PACKETS; i++) {
		if (*sc->nic_r_mode & RM_BUF_EMP)
			/* Buffer empty. */
			break;

		/*
		 * Read the first word: upper byte contains useful
		 * information.
		 */
		status = *sc->nic_fifo;
		if ((status & 0x7000) != 0x2000) {
			log(LOG_INFO, "qn: ERROR: status=%04x\n", status);
			continue;
		}

		/*
		 * Read packet length (byte-swapped).
		 * CRC is stripped off by the NIC.
		 */
		len = *sc->nic_fifo;
		len = ((len << 8) & 0xff00) | ((len >> 8) & 0x00ff);

#ifdef QN_CHECKS
		if (len > ETHER_MAX_LEN || len < ETHER_HDR_SIZE) {
			log(LOG_WARNING,
			    "%s: received a %s packet? (%u bytes)\n",
			    sc->sc_dev.dv_xname,
			    len < ETHER_HDR_SIZE ? "partial" : "big", len);
			++sc->sc_arpcom.ac_if.if_ierrors;
			continue;
		}
#endif
#ifdef QN_CHECKS
		if (len < ETHER_MIN_LEN)
			log(LOG_WARNING,
			    "%s: received a short packet? (%u bytes)\n",
			    sc->sc_dev.dv_xname, len);
#endif 

		/* Read the packet. */
		qn_get_packet(sc, len);

		++sc->sc_arpcom.ac_if.if_ipackets;
	}

#ifdef QN_DEBUG
	/* This print just to see whether MAX_PACKETS is large enough. */
	if (i == MAX_PACKETS)
		log(LOG_INFO, "used all the %d loops\n", MAX_PACKETS);
#endif
}

/*
 * Our interrupt routine
 */
int
qnintr(arg)
	void *arg;
{
	struct qn_softc *sc = arg;
	u_short tint, rint, tintmask;
	char return_tintmask = 0;

	/*
	 * If the driver has not been initialized, just return immediately.
	 * This also happens if there is no QuickNet board present.
	 */
	if (sc->sc_base == NULL)
		return (0);

	/* Get interrupt statuses and masks. */
	rint = (*sc->nic_r_status) & NIC_R_MASK;
	tintmask = *sc->nic_t_mask;
	tint = (*sc->nic_t_status) & tintmask;
	if (tint == 0 && rint == 0)
		return (0);

	/* Disable interrupts so that we won't miss anything. */
	*sc->nic_r_mask = CLEAR_R_MASK;
	*sc->nic_t_mask = CLEAR_T_MASK;

	/*
	 * Handle transmitter interrupts. Some of them are not asked for
	 * but do happen, anyway.
	 */

	if (tint != 0) {
		/* Clear transmit interrupt status. */
		*sc->nic_t_status = CLEAR_T_ERR;

		if (sc->transmit_pending && (tint & T_TMT_OK)) {
			sc->transmit_pending = 0;
			/*
			 * Update total number of successfully
			 * transmitted packets.
			 */
			sc->sc_arpcom.ac_if.if_opackets++;
		}

		if (tint & T_SIXTEEN_COL) {
			/*
			 * 16 collision (i.e., packet lost).
			 */
			log(LOG_INFO, "qn: 16 collision - packet lost\n");
#ifdef QN_DEBUG1
			qn_dump(sc);
#endif
			sc->sc_arpcom.ac_if.if_oerrors++;
			sc->sc_arpcom.ac_if.if_collisions += 16;
			sc->transmit_pending = 0;
		}

		if (sc->transmit_pending) {
			log(LOG_INFO, "qn:still pending...\n");

			/* Must return transmission interrupt mask. */
			return_tintmask = 1;
		} else {
			sc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;

			/* Clear watchdog timer. */
			sc->sc_arpcom.ac_if.if_timer = 0;
		}
	} else
		return_tintmask = 1;

	/*
	 * Handle receiver interrupts.
	 */
	if (rint != 0)
		qn_rint(sc, rint);

	if ((sc->sc_arpcom.ac_if.if_flags & IFF_OACTIVE) == 0)
		qnstart(&sc->sc_arpcom.ac_if);
	else if (return_tintmask == 1)
		*sc->nic_t_mask = tintmask;

	/* Set receive interrupt mask back. */
	*sc->nic_r_mask = NIC_R_MASK;

	return (1);
}

/*
 * Process an ioctl request. This code needs some work - it looks pretty ugly.
 * I somehow think that this is quite a common excuse... ;-)
 */
int
qnioctl(ifp, command, data)
	register struct ifnet *ifp;
	u_long command;
	caddr_t data;
{
	struct qn_softc *sc = ifp->if_softc;
	register struct ifaddr *ifa = (struct ifaddr *)data;
#if 0
	struct ifreg *ifr = (struct ifreg *)data;
#endif
	int s, error = 0;

	s = splnet();

	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {
		splx(s);
		return error;
	}

	switch (command) {

	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;

		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			qnstop(sc);
			qninit(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
#endif
#ifdef NS
		case AF_NS:
		    {
			register struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)(sc->sc_arpcom.ac_enaddr);
			else
				bcopy(ina->x_host.c_host,
				    sc->sc_arpcom.ac_enaddr,
				    sizeof(sc->sc_arpcom.ac_enaddr));
			qnstop(sc);
			qninit(sc);
			break;
		    }
#endif
		default:
			log(LOG_INFO, "qn:sa_family:default (not tested)\n");
			qnstop(sc);
			qninit(sc);
			break;
		}
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
#ifdef QN_DEBUG1
			qn_dump(sc);
#endif
			qnstop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
			   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			qninit(sc);
		} else {
			/*
			 * Something else... we won't do anything so we won't
			 * break anything (hope so).
			 */
#ifdef QN_DEBUG1
			log(LOG_INFO, "Else branch...\n");
#endif
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		log(LOG_INFO, "qnioctl: multicast not done yet\n");
#if 0
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			log(LOG_INFO, "qnioctl: multicast not done yet\n");
			error = 0;
		}
#else
		error = EINVAL;
#endif
		break;

	default:
		log(LOG_INFO, "qnioctl: default\n");
		error = EINVAL;
	}

	splx(s);
	return (error);
}

/*
 * Dump some register information.
 */
#ifdef QN_DEBUG1
static void
qn_dump(sc)
	struct qn_softc *sc;
{

	log(LOG_INFO, "t_status  : %04x\n", *sc->nic_t_status);
	log(LOG_INFO, "t_mask    : %04x\n", *sc->nic_t_mask);
	log(LOG_INFO, "t_mode    : %04x\n", *sc->nic_t_mode);
	log(LOG_INFO, "r_status  : %04x\n", *sc->nic_r_status);
	log(LOG_INFO, "r_mask    : %04x\n", *sc->nic_r_mask);
	log(LOG_INFO, "r_mode    : %04x\n", *sc->nic_r_mode);
	log(LOG_INFO, "pending   : %02x\n", sc->transmit_pending);
	log(LOG_INFO, "if_flags  : %04x\n", sc->sc_arpcom.ac_if.if_flags);
}
#endif

#endif /* NQN > 0 */
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_qn.c,v 1.14 2001/06/29 08:18:19 jj Exp $	*/
@


1.14
log
@Remove defines that are now defined elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_qn.c,v 1.13 2001/02/20 19:39:30 mickey Exp $	*/
d160 15
a174 15
int	qnmatch __P((struct device *, void *, void *));
void	qnattach __P((struct device *, struct device *, void *));
int	qnintr __P((void *));
int	qnioctl __P((struct ifnet *, u_long, caddr_t));
void	qnstart __P((struct ifnet *));
void	qnwatchdog __P((struct ifnet *));
void	qnreset __P((struct qn_softc *));
void	qninit __P((struct qn_softc *));
void	qnstop __P((struct qn_softc *));
static	u_short qn_put __P((u_short volatile *, struct mbuf *));
static	void qn_rint __P((struct qn_softc *, u_short));
static	void qn_flush __P((struct qn_softc *));
static	void __inline word_copy_from_card __P((u_short volatile *, u_short *, u_short));
static	void __inline word_copy_to_card __P((u_short *, u_short volatile *, u_short));
void	qn_get_packet __P((struct qn_softc *, u_short)); 
d176 1
a176 1
static	void qn_dump __P((struct qn_softc *));
@


1.14.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_qn.c,v 1.14 2001/06/29 08:18:19 jj Exp $	*/
d160 15
a174 15
int	qnmatch(struct device *, void *, void *);
void	qnattach(struct device *, struct device *, void *);
int	qnintr(void *);
int	qnioctl(struct ifnet *, u_long, caddr_t);
void	qnstart(struct ifnet *);
void	qnwatchdog(struct ifnet *);
void	qnreset(struct qn_softc *);
void	qninit(struct qn_softc *);
void	qnstop(struct qn_softc *);
static	u_short qn_put(u_short volatile *, struct mbuf *);
static	void qn_rint(struct qn_softc *, u_short);
static	void qn_flush(struct qn_softc *);
static	void __inline word_copy_from_card(u_short volatile *, u_short *, u_short);
static	void __inline word_copy_to_card(u_short *, u_short volatile *, u_short);
void	qn_get_packet(struct qn_softc *, u_short); 
d176 1
a176 1
static	void qn_dump(struct qn_softc *);
@


1.14.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: if_qn.c,v 1.14.4.1 2002/06/11 03:34:58 art Exp $	*/
@


1.13
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_qn.c,v 1.12 1999/05/13 15:44:48 jason Exp $	*/
d119 1
a119 1
#define ETHER_MIN_LEN	60
d121 1
a121 1
#define ETHER_HDR_SIZE	14
@


1.12
log
@Compensate for the check for onwership of unicast packets in promiscuous
mode being moved to if_ether.c.  This is the last of the drivers hopefully.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_qn.c,v 1.11 1998/03/01 14:18:02 niklas Exp $	*/
a262 4
#endif

#if NBPFILTER > 0
	bpfattach(&sc->sc_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
@


1.12.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_qn.c,v 1.13 2001/02/20 19:39:30 mickey Exp $	*/
d263 4
@


1.12.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_qn.c,v 1.12.4.1 2001/04/18 16:02:12 niklas Exp $	*/
d119 1
a119 1
/* #define ETHER_MIN_LEN	60
d121 1
a121 1
#define ETHER_HDR_SIZE	14 */
@


1.12.4.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d160 15
a174 15
int	qnmatch(struct device *, void *, void *);
void	qnattach(struct device *, struct device *, void *);
int	qnintr(void *);
int	qnioctl(struct ifnet *, u_long, caddr_t);
void	qnstart(struct ifnet *);
void	qnwatchdog(struct ifnet *);
void	qnreset(struct qn_softc *);
void	qninit(struct qn_softc *);
void	qnstop(struct qn_softc *);
static	u_short qn_put(u_short volatile *, struct mbuf *);
static	void qn_rint(struct qn_softc *, u_short);
static	void qn_flush(struct qn_softc *);
static	void __inline word_copy_from_card(u_short volatile *, u_short *, u_short);
static	void __inline word_copy_to_card(u_short *, u_short volatile *, u_short);
void	qn_get_packet(struct qn_softc *, u_short); 
d176 1
a176 1
static	void qn_dump(struct qn_softc *);
@


1.12.4.4
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: if_qn.c,v 1.12.4.3 2002/03/28 10:06:14 niklas Exp $	*/
@


1.11
log
@make int explicit for GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: if_qn.c,v 1.10 1997/09/18 13:39:57 niklas Exp $	*/
d626 1
a626 1
	if (sc->sc_bpf) {
a627 15

		/*
		 * The interface cannot be in promiscuous mode if there are
		 * no BPF listeners. And in prom. mode we have to check
		 * if the packet is really ours...
		 */
		if ((sc->sc_arpcom.ac_if.if_flags & IFF_PROMISC) &&
		    (eh->ether_dhost[0] & 1) == 0 && /* not bcast or mcast */
		    bcmp(eh->ether_dhost,
        	        sc->sc_arpcom.ac_enaddr,
		        ETHER_ADDR_LEN) != 0) {
			m_freem(head);
			return;
		}
	}
@


1.10
log
@Merge of NetBSD changes upto last week or so, with the exception of stand/
@
text
@d1 1
a1 1
/*	$OpenBSD: if_qn.c,v 1.9 1997/01/16 09:24:47 niklas Exp $	*/
d285 1
a285 1
	static retry = 0;
@


1.9
log
@Sync to NetBSD 970110
@
text
@d1 1
a1 1
/*	$OpenBSD: if_qn.c,v 1.4 1996/04/21 22:15:29 deraadt Exp $	*/
a492 4
 *
 * Uses an extra buffer/extra memory copy,
 * unless the whole packet fits in one mbuf.
 *
a508 1
		totlen += len;
@


1.8
log
@From NetBSD:
Changed struct ifnet to have a pointer to the softc of the underlying
device and a printable "external name" (name + unit number), thus eliminating
if_name and if_unit.  Updated interface to (*if_watchdog)() and (*if_start)()
to take a struct ifnet *, rather than a unit number.
@
text
@d2 1
a2 1
/*	$NetBSD: if_qn.c,v 1.6 1996/05/07 00:46:47 thorpej Exp $	*/
d74 1
d106 5
d172 3
a174 3
static	void inline word_copy_from_card __P((u_short volatile *, u_short *, u_short));
static	void inline word_copy_to_card __P((u_short *, u_short volatile *, u_short));
static	void qn_get_packet __P((struct qn_softc *, u_short)); 
a434 1
	log(LOG_INFO, "NBPFILTER... no-one has tested this with qn.\n");
d470 1
a470 1
static void inline
d481 1
a481 1
static void inline
d487 1
a487 3
	register u_short l = len/2;

	while (l--)
d498 1
a498 1
static u_short
d503 3
a505 2
	u_short *data, savebyte[2];
	int len, wantbyte;
d515 2
d519 1
a519 1
				savebyte[1] = *data;
d521 1
a521 1
				data++;
d527 3
a529 2
				word_copy_to_card(data, addr, len);
				data += len & ~1;
d534 1
a534 1
				savebyte[0] = *data;
d564 1
a564 1
static void
a630 1
	log(LOG_INFO, "qn: Beware, an untested code section\n");
d680 1
a680 1
	if (rstat & 0x0101) {
d686 1
a686 1
	if (rstat & 0x0202) {
d692 1
a692 1
	if (rstat & 0x0404) {
d698 1
a698 1
	if (rstat & 0x0808) {
d741 1
a741 1
#ifdef QN_DEBUG
d751 1
a751 1
#ifdef QN_DEBUG
d898 17
@


1.7
log
@fix arg names (s/cmd/command/).
@
text
@d2 1
a2 1
/*	$NetBSD: if_qn.c,v 1.5 1996/04/21 21:11:50 veego Exp $	*/
d159 1
a159 1
void	qnwatchdog __P((int));
d241 2
a242 2
	ifp->if_unit = sc->sc_dev.dv_unit;
	ifp->if_name = qn_cd.cd_name;
d321 2
a322 2
qnwatchdog(unit)
	int unit;
d324 1
a324 1
	struct qn_softc *sc = qn_cd.cd_devs[unit];
d407 1
a407 1
	struct qn_softc *sc = qn_cd.cd_devs[ifp->if_unit];
d866 1
a866 1
	struct qn_softc *sc = qn_cd.cd_devs[ifp->if_unit];
@


1.6
log
@add general ether_ioctl call in net/if_ethersubr.c,
NS,IPX,X.25 special processing is now handled in there.
reflect this amazing addition in all the ether ifaces.
ppl, pls check the stuff.
@
text
@d875 1
a875 1
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
@


1.5
log
@Sync with NetBSD 9600430.  The port has gone over a major -Wall treat
@
text
@a104 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

d875 5
a891 17
#endif
#ifdef NS
		case AF_NS:
		    {
			register struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)(sc->sc_arpcom.ac_enaddr);
			else
				bcopy(ina->x_host.c_host,
				    sc->sc_arpcom.ac_enaddr,
				    sizeof(sc->sc_arpcom.ac_enaddr));
			qnstop(sc);
			qninit(sc);
			break;
		    }
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: if_qn.c,v 1.4 1996/03/17 01:17:37 thorpej Exp $	*/
d161 1
a161 1
int	qnintr __P((struct qn_softc *sc));
d171 3
a215 1
	int i;
d483 1
a483 1
	u_short *a, len;
d485 1
d505 1
a505 1
	u_char *data, savebyte[2];
d512 1
a512 1
		data = mtod(m, u_char *);
d774 2
a775 2
qnintr(sc)
	struct qn_softc *sc;
d777 1
d900 1
a900 1
				    *(union ns_host *)(sc->sc_arpcom.sc_enaddr);
@


1.3
log
@from netbsd:
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d1 2
a2 1
/*	$NetBSD: if_qn.c,v 1.3 1995/12/24 02:30:02 mycroft Exp $	*/
d175 6
a180 2
struct cfdriver qncd = {
	NULL, "qn", qnmatch, qnattach, DV_IFNET, sizeof(struct qn_softc)
d245 1
a245 1
	ifp->if_name = qncd.cd_name;
d327 1
a327 1
	struct qn_softc *sc = qncd.cd_devs[unit];
d410 1
a410 1
	struct qn_softc *sc = qncd.cd_devs[ifp->if_unit];
d867 1
a867 1
	struct qn_softc *sc = qncd.cd_devs[ifp->if_unit];
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: if_qn.c,v 1.1.2.1 1995/11/10 16:39:12 chopps Exp $	*/
d361 1
a361 1
	s = splimp();
d869 1
a869 1
	s = splimp();
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: if_qn.c,v 1.1 1995/10/07 18:04:27 chopps Exp $	*/
d38 2
a39 1
 * - if_ed.c: basic function structure for Ethernet driver
d58 5
a65 2
 * - try to find out what is the reason for random lock-ups happening
 *   when (or after) getting data
d72 1
d77 2
a78 1
 * Fujitsu MB86950 Ethernet Controller (as used in QuickNet QN2000 Ethernet card)
d117 6
a122 4
#define ETHER_MIN_LEN 64
#define ETHER_MAX_LEN 1518
#define ETHER_ADDR_LEN 6

d168 1
d170 3
d178 1
d277 1
a277 3
	int s;

	s = splimp();
d279 2
a280 10
	/* Initialize NIC */
	*sc->nic_reset      = DISABLE_DLC;
	*sc->nic_t_status   = CLEAR_T_ERR;
	*sc->nic_t_mask     = CLEAR_T_MASK;
	*sc->nic_r_status   = CLEAR_R_ERR;
	*sc->nic_r_mask     = R_INT_PKT_RDY;
	*sc->nic_t_mode     = NO_LOOPBACK;

	/* Turn DMA off */
	*((u_short volatile *)(sc->sc_nic_base + NIC_BMPR4)) = (u_short)0x0000;
d290 2
a291 1
		*((u_short volatile *)(sc->sc_nic_base+QNET_HARDWARE_ADDRESS+2*i)) =
a294 1
	sc->transmit_pending = 0;
d297 1
d301 6
a307 1
	*((u_short volatile *)(sc->sc_nic_base + QNET_MAGIC)) = (u_short)0x0000;
a311 2

	splx(s);
a313 1

d324 1
a324 1
	log(LOG_ERR, "%s: device timeout (watchdog)\n", sc->sc_dev.dv_xname);
a329 1

d331 1
a331 1
 * Flush card's buffer RAM
d337 1
a337 3
#ifdef QN_DEBUG1
	int cnt = 0;
#endif
d339 1
a339 1
	while (!(*sc->nic_r_status & R_BUS_RD_ERR)) {
d341 4
a344 6
#ifdef QN_DEBUG1
		cnt++;
#endif
	}
#ifdef QN_DEBUG1
	log(LOG_INFO, "Flushed %d words\n", cnt);
a350 1

d352 1
a352 1
 * Reset the interface...
a366 1

d368 1
a368 1
 * Take interface offline
d376 9
a384 1
	*sc->nic_reset  = DISABLE_DLC;
d386 3
a388 2
	*sc->nic_t_mask = CLEAR_T_MASK;
	*sc->nic_r_mask = CLEAR_R_MASK;
a392 1

d408 2
a409 1
	int timout = 50000;
d411 1
a411 2
	if ((sc->sc_arpcom.ac_if.if_flags & (IFF_RUNNING | IFF_OACTIVE)) !=
	    IFF_RUNNING)
d432 1
d435 1
a435 1
	 * Really transmit the packet
d438 1
a438 1
	/* set packet length (byte-swapped) */
d442 6
a447 3
	/* Wait for the packet to really leave */
	while (!(*sc->nic_t_status & T_TMT_OK) && --timout)
		;
d450 2
a451 2
		/* But for now on, let's just fall thru and hope the best... */
		log(LOG_INFO, "qn:timout\n");
a459 1

a484 1

d497 32
a528 4
	struct mbuf *mp;
	register u_short len, tlen;
	static u_short packet_buf[1536/2];
	register u_char *p;
d530 4
a533 5
	/*
	 * If buffer is bzeroed, we might copy max(60, tlen) bytes and get
	 * rid of extra zero fill-ins.
	 */
	bzero(packet_buf, 1536);
d535 8
a542 25
	/*
	 * The whole packet in one mbuf?
	 */
	if (m->m_next == NULL) {
		tlen = m->m_len;
		bcopy(mtod(m, u_char *), (u_char *)packet_buf, tlen);
		/*word_copy_to_card(mtod(m, u_short *), addr, tlen + 1);*/
		word_copy_to_card(packet_buf,
		    addr,
		    max(tlen + 1, ETHER_MIN_LEN-4));
	} else {
		/* No it wasn't, let's start copying */
		for (p = (u_char *)packet_buf, tlen = 0, mp = m;
		     mp;
		     mp = mp->m_next) {
			if ((len = mp->m_len) == 0)
				continue;
			tlen += len;
			bcopy(mtod(mp, u_char *), p, len);
			p += len;
		}
		/* word_copy_to_card(packet_buf, addr, tlen + 1); */
		word_copy_to_card(packet_buf,
		    addr,
		    max(tlen + 1, ETHER_MIN_LEN-4));
a543 1
	m_freem(m);
d545 1
a545 4
	if (tlen < ETHER_MIN_LEN - 4)
		/* We have copied ETHER_MIN_LEN-4 bytes. */
		tlen = ETHER_MIN_LEN - 4;
	return (tlen);
d549 1
a549 1
 * Copy packet from board RAM
d561 1
a561 1
	struct mbuf *m, *dst, *head = 0;
d567 1
a567 1
	if (m == 0)
d570 6
d595 1
a595 1
			/* allocate another mbuf */
d598 1
a598 1
			if (m == 0)
d610 1
a610 3
		if (amount < len1) {
			if (amount & 1)
				log(LOG_INFO, "Room for odd-length packet\n");
d612 1
a612 1
		}
d615 1
a615 1
		    len1 + 1);
d646 1
a646 1
	if (head)
d648 2
a651 1

d656 1
a656 1
qn_rint(sc)
d658 1
d663 3
d667 3
a669 1
	 * Read at most 25 packets per interrupt
d671 1
a671 11
	for (i = 0; i < 25; i++) {
		if (*sc->nic_r_mode & RM_BUF_EMP) {
			/*
			 * Buffer empty
			 */
			if ((status = *sc->nic_r_status)) {
				/* It was some error: let's first clear
				 * the register.
				 */
				*sc->nic_r_status = CLEAR_R_ERR;
				if (status & 0x0101) {
d673 1
a673 1
					log(LOG_INFO, "Overflow\n");
d675 3
a677 2
					++sc->sc_arpcom.ac_if.if_ierrors;
				} else if (status & 0x0202) {
d679 1
a679 1
					log(LOG_INFO, "CRC Error\n");
d681 3
a683 2
					++sc->sc_arpcom.ac_if.if_ierrors;
				} else if (status & 0x0404) {
d685 1
a685 1
					log(LOG_INFO, "Alignment error\n");
d687 7
a693 6
					++sc->sc_arpcom.ac_if.if_ierrors;
				} else if (status & 0x0808) {
					/* Short packet (these may occur and are
					 * no reason to worry about - or maybe
					 * they are?).
					 */
d695 1
a695 1
					log(LOG_INFO, "Short packet\n");
d697 3
a699 3
					++sc->sc_arpcom.ac_if.if_ierrors;
					/* qnreset(sc); */
				} else if (status & 0x4040) {
d701 1
a701 1
					log(LOG_INFO, "Bus read error\n");
d703 3
a705 12
					++sc->sc_arpcom.ac_if.if_ierrors;
				} else {
					/* There are some registers which are
					 * not meaningful when read, so don't
					 * care...
					 */
				}
			}
			return;
		} else {
			/* At least one valid packet. Clear the whole register. */
			*sc->nic_r_status = CLEAR_R_ERR;
d707 7
a713 2
			/* Read one word of garbage. */
			(void)(*sc->nic_fifo);
d715 16
a730 3
			/* Read packet length. */
			len = *sc->nic_fifo;
			len = ((len << 8) & 0xff00) | ((len >> 8) & 0x00ff);
d732 8
a739 3
			/* Read the packet. */
			qn_get_packet(sc, len);
			++sc->sc_arpcom.ac_if.if_ipackets;
d741 12
d755 5
a759 2
	if (i == 25)
		log(LOG_INFO, "used all the 25 loops\n");
a761 1

d769 2
a770 1
	u_short tint, rint, tintmask, rintmask;
a775 1

d780 1
a780 3
	rint = *sc->nic_r_status;
	tint = *sc->nic_t_status;
	rintmask = *sc->nic_r_mask /* 0x8f8f */;
d782 2
a783 1
	if (!(tint&tintmask) && !(rint&rintmask))
d786 1
a786 1
	/* Disable receive interrupts so that we won't miss anything. */
d788 1
d794 3
a796 2
	if (tint) {
		*sc->nic_t_mask   = CLEAR_T_MASK;
d798 1
d813 3
a820 21
		if (tint & T_COL && !(tint & T_TMT_OK)) {
			/*
			 * Normal collision
			 */
			log(LOG_INFO, "qn:collision (shouldn't hurt)\n");
			sc->transmit_pending = 1;
			sc->sc_arpcom.ac_if.if_oerrors++;
			sc->sc_arpcom.ac_if.if_collisions++;
		}

		if (tint & BUS_WRITE_ERROR) {
			/* One bus write error occurs at start up, at least on my
			 * card. So I don't care about this one.
			 */
			sc->transmit_pending = 0;
		}

		if (tint & T_UNDERFLOW) {
			log(LOG_INFO, "qn:underflow\n");
		}

d823 3
a825 2
			/* Return transmission interrupt mask. */
			*sc->nic_t_mask = tintmask;
d832 2
a833 1
	}
d838 2
a839 5
	if (rint & rintmask)
		qn_rint(sc);

	/* Set receive interrupt mask back. */
	*sc->nic_r_mask = rintmask;
d843 5
d879 1
d896 1
d903 1
a909 3
		/*
		 * If interface is marked down and it is running, then stop it.
		 */
d916 3
d922 1
a922 1
			   (ifp->if_flags & IFF_RUNNING) == 0)
d928 1
a928 1
		else {
d933 3
d965 1
a965 1
	(void)splx(s);
d968 20
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

