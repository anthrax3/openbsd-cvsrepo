head	1.17;
access;
symbols
	OPENBSD_5_3:1.16.0.12
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.10
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.8
	OPENBSD_5_0:1.16.0.6
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.14
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.16
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.12
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.12.0.12
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.10
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.8
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.6
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.8.0.24
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.22
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.20
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.18
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.16
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.14
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.12
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.10
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.8
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.6
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2013.03.25.19.08.56;	author miod;	state dead;
branches;
next	1.16;

1.16
date	2010.07.20.20.47.17;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.11.20.43.28;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.30.21.23.22;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.16.22.08.26;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.09.22.27.09;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.29.22.23.49;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.03.15.54;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.34;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.02.13.21.49.16;	author kstailey;	state Exp;
branches
	1.8.14.1
	1.8.24.1;
next	1.7;

1.7
date	97.01.13.11.51.04;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.10.13.16.10.04;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.09.18.02.09.29;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.05.29.11.29.30;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.05.09.22.20.43;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.53.06;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.54;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.54;	author deraadt;	state Exp;
branches;
next	;

1.8.14.1
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.8.14.2;

1.8.14.2
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	;

1.8.24.1
date	2002.06.11.03.36.06;	author art;	state Exp;
branches;
next	1.8.24.2;

1.8.24.2
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Remove the m68k FPU emulator; it was only used by the mac68k port which has been
lying in the Attic for quite awhile; none of the remaining m68k-based ports
support FPU-less systems; assuming my HP332 cpu board is in working condition,
give me memory boards for it to have at least 8MB and a chassis, and I'll
consider bringing this code back. But then, the 332 has an FPU socket, and
I'd rather write a new glue to use the MI softloat code (bug-free) than try
and fix the bugs in this.
@
text
@/*	$OpenBSD: fpu_emulate.c,v 1.16 2010/07/20 20:47:17 miod Exp $	*/
/*	$NetBSD: fpu_emulate.c,v 1.25 2003/09/22 14:18:34 cl Exp $	*/

/*
 * Copyright (c) 1995 Gordon W. Ross
 * some portion Copyright (c) 1995 Ken Nakata
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 4. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Gordon Ross
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * mc68881 emulator
 * XXX - Just a start at it for now...
 */

#include <sys/types.h>
#include <sys/signal.h>
#include <sys/systm.h>
#include <machine/frame.h>

#if defined(DDB) && defined(DEBUG_FPE)
#include <machine/db_machdep.h>
#endif

#include <m68k/fpe/fpu_emulate.h>

int fpu_emul_fmovmcr(struct fpemu *fe, struct instruction *insn, int *);
int fpu_emul_fmovm(struct fpemu *fe, struct instruction *insn, int *);
int fpu_emul_arith(struct fpemu *fe, struct instruction *insn, int *);
int fpu_emul_type1(struct fpemu *fe, struct instruction *insn, int *);
int fpu_emul_brcc(struct fpemu *fe, struct instruction *insn);
int test_cc(struct fpemu *fe, int pred);
struct fpn *fpu_cmp(struct fpemu *fe);

#if DEBUG_FPE
#  define DUMP_INSN(insn)						\
    printf("fpu_emulate: insn={adv=%d,siz=%d,op=%04x,w1=%04x}\n",	\
	   (insn)->is_advance, (insn)->is_datasize,			\
	   (insn)->is_opcode, (insn)->is_word1)
#else
#  define DUMP_INSN(insn)
#endif

/*
 * Emulate a floating-point instruction.
 * Return zero for success, else signal number.
 * (Typically: zero, SIGFPE, SIGILL, SIGSEGV)
 */
int
fpu_emulate(struct frame *frame, struct fpframe *fpf, int *typ)
{
    static struct instruction insn;
    static struct fpemu fe;
    int optype, sig;
    u_int16_t word;


    /* initialize insn.is_datasize to tell it is *not* initialized */
    insn.is_datasize = -1;

    fe.fe_frame = frame;
    fe.fe_fpframe = fpf;
    fe.fe_fpsr = fpf->fpf_fpsr;
    fe.fe_fpcr = fpf->fpf_fpcr;

#if DEBUG_FPE
    printf("ENTERING fpu_emulate: FPSR=%08x, FPCR=%08x\n",
	   fe.fe_fpsr, fe.fe_fpcr);
#endif

    /* always set this (to avoid a warning) */
    insn.is_pc = frame->f_pc;
    insn.is_nextpc = 0;
    if (frame->f_format == 4) {
	/*
	 * A format 4 is generated by the 68{EC,LC}040.  The PC is
	 * already set to the instruction following the faulting
	 * instruction.  We need to calculate that, anyway.  The
	 * fslw is the PC of the faulted instruction, which is what
	 * we expect to be in f_pc.
	 *
	 * XXX - This is a hack; it assumes we at least know the
	 * sizes of all instructions we run across.
	 * XXX TODO: This may not be true, so we might want to save the PC
	 * in order to restore it later.
	 */
	/* insn.is_nextpc = frame->f_pc; */
	insn.is_pc = frame->f_fmt4.f_fslw;
	frame->f_pc = insn.is_pc;
    }

    if (copyin((void *)insn.is_pc, &word, sizeof(word)) != 0) {
#ifdef DEBUG
	printf("fpu_emulate: fault reading opcode\n");
#endif
	return (SIGSEGV);
    }

    if ((word & 0xf000) != 0xf000) {
#ifdef DEBUG
	printf("fpu_emulate: not coproc. insn.: opcode=0x%x\n", word);
#endif
	return (SIGILL);
    }

    if ((word & 0x0E00) != 0x0200) {
#ifdef DEBUG
	printf("fpu_emulate: bad coproc. id: opcode=0x%x\n", word);
#endif
	*typ = ILL_COPROC;
	return (SIGILL);
    }

    insn.is_opcode = word;
    optype = (word & 0x01C0);

    if (copyin((void *)(insn.is_pc + 2), &word, sizeof(word)) != 0) {
#ifdef DEBUG
	printf("fpu_emulate: fault reading word1\n");
#endif
	return (SIGSEGV);
    }
    insn.is_word1 = word;
    /* all FPU instructions are at least 4-byte long */
    insn.is_advance = 4;

    DUMP_INSN(&insn);

    /*
     * Which family (or type) of opcode is it?
     * Tests ordered by likelihood (hopefully).
     * Certainly, type 0 is the most common.
     */
    if (optype == 0x0000) {
	/* type=0: generic */
	if ((word & 0xc000) == 0xc000) {
#if DEBUG_FPE
	    printf("fpu_emulate: fmovm FPr\n");
#endif
	    sig = fpu_emul_fmovm(&fe, &insn, typ);
	} else if ((word & 0xc000) == 0x8000) {
#if DEBUG_FPE
	    printf("fpu_emulate: fmovm FPcr\n");
#endif
	    sig = fpu_emul_fmovmcr(&fe, &insn, typ);
	} else if ((word & 0xe000) == 0x6000) {
	    /* fstore = fmove FPn,mem */
#if DEBUG_FPE
	    printf("fpu_emulate: fmove to mem\n");
#endif
	    sig = fpu_emul_fstore(&fe, &insn, typ);
	} else if ((word & 0xfc00) == 0x5c00) {
	    /* fmovecr */
#if DEBUG_FPE
	    printf("fpu_emulate: fmovecr\n");
#endif
	    sig = fpu_emul_fmovecr(&fe, &insn, typ);
	} else if ((word & 0xa07f) == 0x26) {
	    /* fscale */
#if DEBUG_FPE
	    printf("fpu_emulate: fscale\n");
#endif
	    sig = fpu_emul_fscale(&fe, &insn, typ);
	} else {
#if DEBUG_FPE
	    printf("fpu_emulate: other type0\n");
#endif
	    /* all other type0 insns are arithmetic */
	    sig = fpu_emul_arith(&fe, &insn, typ);
	}
	if (sig == 0) {
#if DEBUG_FPE
	    printf("fpu_emulate: type 0 returned 0\n");
#endif
	    sig = fpu_upd_excp(&fe);
	}
    } else if (optype == 0x0080 || optype == 0x00C0) {
	/* type=2 or 3: fbcc, short or long disp. */
#if DEBUG_FPE
	printf("fpu_emulate: fbcc %s\n",
	       (optype & 0x40) ? "long" : "short");
#endif
	sig = fpu_emul_brcc(&fe, &insn);
    } else if (optype == 0x0040) {
	/* type=1: fdbcc, fscc, ftrapcc */
#if DEBUG_FPE
	printf("fpu_emulate: type1\n");
#endif
	sig = fpu_emul_type1(&fe, &insn, typ);
    } else {
	/* type=4: fsave    (privileged) */
	/* type=5: frestore (privileged) */
	/* type=6: reserved */
	/* type=7: reserved */
#ifdef DEBUG
	printf("fpu_emulate: bad opcode type: opcode=0x%x\n", insn.is_opcode);
#endif
	*typ = ILL_PRVOPC;
	sig = SIGILL;
    }

    DUMP_INSN(&insn);

     /*
      * XXX it is not clear to me, if we should progress the PC always,
      * for SIGFPE || 0, or only for 0; however, without SIGFPE, we
      * don't pass the signalling regression  tests.	-is
      */
    if ((sig == 0) || (sig == SIGFPE))
	frame->f_pc += insn.is_advance;
#if defined(DDB) && defined(DEBUG_FPE)
    else {
	printf("fpu_emulate: sig=%d, opcode=%x, word1=%x\n",
	       sig, insn.is_opcode, insn.is_word1);
	kdb_trap(-1, (db_regs_t *)frame);
    }
#endif
#if 0 /* XXX something is wrong */
    if (frame->f_format == 4) {
	/* XXX Restore PC -- 68{EC,LC}040 only */
	if (insn.is_nextpc)
		frame->f_pc = insn.is_nextpc;
    }
#endif

#if DEBUG_FPE
    printf("EXITING fpu_emulate: w/FPSR=%08x, FPCR=%08x\n",
	   fe.fe_fpsr, fe.fe_fpcr);
#endif

    if (*typ == 0)
	switch (sig) {
	case SIGSEGV:
		*typ = SEGV_MAPERR;
		break;
	case SIGILL:
		*typ = ILL_ILLOPC;
		break;
	case SIGFPE:
		*typ = FPE_FLTINV;
		break;
	}
    return (sig);
}

/* update accrued exception bits and see if there's an FP exception */
int
fpu_upd_excp(fe)
     struct fpemu *fe;
{
    u_int fpsr;
    u_int fpcr;

    fpsr = fe->fe_fpsr;
    fpcr = fe->fe_fpcr;
    /* update fpsr accrued exception bits; each insn doesn't have to
       update this */
    if (fpsr & (FPSR_BSUN | FPSR_SNAN | FPSR_OPERR)) {
	fpsr |= FPSR_AIOP;
    }
    if (fpsr & FPSR_OVFL) {
	fpsr |= FPSR_AOVFL;
    }
    if ((fpsr & FPSR_UNFL) && (fpsr & FPSR_INEX2)) {
	fpsr |= FPSR_AUNFL;
    }
    if (fpsr & FPSR_DZ) {
	fpsr |= FPSR_ADZ;
    }
    if (fpsr & (FPSR_INEX1 | FPSR_INEX2 | FPSR_OVFL)) {
	fpsr |= FPSR_AINEX;
    }

    fe->fe_fpframe->fpf_fpsr = fe->fe_fpsr = fpsr;

    return (fpsr & fpcr & FPSR_EXCP) ? SIGFPE : 0;
}

/* update fpsr according to fp (= result of an fp op) */
u_int
fpu_upd_fpsr(fe, fp)
     struct fpemu *fe;
     struct fpn *fp;
{
    u_int fpsr;

#if DEBUG_FPE
    printf("fpu_upd_fpsr: previous fpsr=%08x\n", fe->fe_fpsr);
#endif
    /* clear all condition code */
    fpsr = fe->fe_fpsr & ~FPSR_CCB;

#if DEBUG_FPE
    printf("fpu_upd_fpsr: result is a ");
#endif
    if (fp->fp_sign) {
#if DEBUG_FPE
	printf("negative ");
#endif
	fpsr |= FPSR_NEG;
#if DEBUG_FPE
    } else {
	printf("positive ");
#endif
    }

    switch (fp->fp_class) {
    case FPC_SNAN:
#if DEBUG_FPE
	printf("signaling NAN\n");
#endif
	fpsr |= (FPSR_NAN | FPSR_SNAN);
	break;
    case FPC_QNAN:
#if DEBUG_FPE
	printf("quiet NAN\n");
#endif
	fpsr |= FPSR_NAN;
	break;
    case FPC_ZERO:
#if DEBUG_FPE
	printf("Zero\n");
#endif
	fpsr |= FPSR_ZERO;
	break;
    case FPC_INF:
#if DEBUG_FPE
	printf("Inf\n");
#endif
	fpsr |= FPSR_INF;
	break;
    default:
#if DEBUG_FPE
	printf("Number\n");
#endif
	/* anything else is treated as if it is a number */
	break;
    }

    fe->fe_fpsr = fe->fe_fpframe->fpf_fpsr = fpsr;

#if DEBUG_FPE
    printf("fpu_upd_fpsr: new fpsr=%08x\n", fe->fe_fpframe->fpf_fpsr);
#endif

    return fpsr;
}

int
fpu_emul_fmovmcr(struct fpemu *fe, struct instruction *insn, int *typ)
{
    struct frame *frame = fe->fe_frame;
    struct fpframe *fpf = fe->fe_fpframe;
    int sig;
    int reglist;
    int fpu_to_mem;

    /* move to/from control registers */
    reglist = (insn->is_word1 & 0x1c00) >> 10;
    /* Bit 13 selects direction (FPU to/from Mem) */
    fpu_to_mem = insn->is_word1 & 0x2000;

    insn->is_datasize = 4;
    insn->is_advance = 4;
    sig = fpu_decode_ea(frame, insn, &insn->is_ea, insn->is_opcode, typ);
    if (sig) { return sig; }

    if (reglist != 1 && reglist != 2 && reglist != 4 &&
	(insn->is_ea.ea_flags & EA_DIRECT)) {
	/* attempted to copy more than one FPcr to CPU regs */
#ifdef DEBUG
	printf("fpu_emul_fmovmcr: tried to copy too many FPcr\n");
#endif
	return SIGILL;
    }

    if (reglist & 4) {
	/* fpcr */
	if ((insn->is_ea.ea_flags & EA_DIRECT) &&
	    insn->is_ea.ea_regnum >= 8 /* address reg */) {
	    /* attempted to copy FPCR to An */
#ifdef DEBUG
	    printf("fpu_emul_fmovmcr: tried to copy FPCR from/to A%d\n",
		   insn->is_ea.ea_regnum & 7);
#endif
	    return SIGILL;
	}
	if (fpu_to_mem) {
	    sig = fpu_store_ea(frame, insn, &insn->is_ea,
			       (char *)&fpf->fpf_fpcr);
	} else {
	    sig = fpu_load_ea(frame, insn, &insn->is_ea,
			      (char *)&fpf->fpf_fpcr, typ);
	}
    }
    if (sig) { return sig; }

    if (reglist & 2) {
	/* fpsr */
	if ((insn->is_ea.ea_flags & EA_DIRECT) &&
	    insn->is_ea.ea_regnum >= 8 /* address reg */) {
	    /* attempted to copy FPSR to An */
#ifdef DEBUG
	    printf("fpu_emul_fmovmcr: tried to copy FPSR from/to A%d\n",
		   insn->is_ea.ea_regnum & 7);
#endif
	    return SIGILL;
	}
	if (fpu_to_mem) {
	    sig = fpu_store_ea(frame, insn, &insn->is_ea,
			       (char *)&fpf->fpf_fpsr);
	} else {
	    sig = fpu_load_ea(frame, insn, &insn->is_ea,
			      (char *)&fpf->fpf_fpsr, typ);
	}
    }
    if (sig) { return sig; }
  
    if (reglist & 1) {
	/* fpiar - can be moved to/from An */
	if (fpu_to_mem) {
	    sig = fpu_store_ea(frame, insn, &insn->is_ea,
			       (char *)&fpf->fpf_fpiar);
	} else {
	    sig = fpu_load_ea(frame, insn, &insn->is_ea,
			      (char *)&fpf->fpf_fpiar, typ);
	}
    }
    return sig;
}

/*
 * type 0: fmovem
 * Separated out of fpu_emul_type0 for efficiency.
 * In this function, we know:
 *   (opcode & 0x01C0) == 0
 *   (word1 & 0x8000) == 0x8000
 *
 * No conversion or rounding is done by this instruction,
 * and the FPSR is not affected.
 */
int
fpu_emul_fmovm(struct fpemu *fe, struct instruction *insn, int *typ)
{
    struct frame *frame = fe->fe_frame;
    struct fpframe *fpf = fe->fe_fpframe;
    int word1, sig;
    int reglist, regmask, regnum;
    int fpu_to_mem, order;
    int w1_post_incr;
    int *fpregs;

    insn->is_advance = 4;
    insn->is_datasize = 12;
    word1 = insn->is_word1;

    /* Bit 13 selects direction (FPU to/from Mem) */
    fpu_to_mem = word1 & 0x2000;

    /*
     * Bits 12,11 select register list mode:
     * 0,0: Static  reg list, pre-decr.
     * 0,1: Dynamic reg list, pre-decr.
     * 1,0: Static  reg list, post-incr.
     * 1,1: Dynamic reg list, post-incr
     */
    w1_post_incr = word1 & 0x1000;
    if (word1 & 0x0800) {
	/* dynamic reg list */
	reglist = frame->f_regs[(word1 & 0x70) >> 4];
    } else {
	reglist = word1;
    }
    reglist &= 0xFF;

    /* Get effective address. (modreg=opcode&077) */
    sig = fpu_decode_ea(frame, insn, &insn->is_ea, insn->is_opcode, typ);
    if (sig) { return sig; }

    /* Get address of soft coprocessor regs. */
    fpregs = &fpf->fpf_regs[0];

    if (insn->is_ea.ea_flags & EA_PREDECR) {
	regnum = 7;
	order = -1;
    } else {
	regnum = 0;
	order = 1;
    }

    regmask = 0x80;
    while ((0 <= regnum) && (regnum < 8)) {
	if (regmask & reglist) {
	    if (fpu_to_mem) {
		sig = fpu_store_ea(frame, insn, &insn->is_ea,
				   (char *)&fpregs[regnum * 3]);
#if DEBUG_FPE
		printf("fpu_emul_fmovm: FP%d (%08x,%08x,%08x) saved\n",
		       regnum, fpregs[regnum * 3], fpregs[regnum * 3 + 1],
		       fpregs[regnum * 3 + 2]);
#endif
	    } else {		/* mem to fpu */
		sig = fpu_load_ea(frame, insn, &insn->is_ea,
				  (char *)&fpregs[regnum * 3], typ);
#if DEBUG_FPE
		printf("fpu_emul_fmovm: FP%d (%08x,%08x,%08x) loaded\n",
		       regnum, fpregs[regnum * 3], fpregs[regnum * 3 + 1],
		       fpregs[regnum * 3 + 2]);
#endif
	    }
	    if (sig) { break; }
	}
	regnum += order;
	regmask >>= 1;
    }

    return sig;
}

struct fpn *
fpu_cmp(fe)
     struct fpemu *fe;
{
    struct fpn *x = &fe->fe_f1, *y = &fe->fe_f2;

    /* take care of special cases */
    if (x->fp_class < 0 || y->fp_class < 0) {
	/* if either of two is a SNAN, result is SNAN */
	x->fp_class = (y->fp_class < x->fp_class) ? y->fp_class : x->fp_class;
    } else if (x->fp_class == FPC_INF) {
	if (y->fp_class == FPC_INF) {
	    /* both infinities */
	    if (x->fp_sign == y->fp_sign) {
		x->fp_class = FPC_ZERO;	/* return a signed zero */
	    } else {
		x->fp_class = FPC_NUM; /* return a faked number w/x's sign */
		x->fp_exp = 16383;
		x->fp_mant[0] = FP_1;
	    }
	} else {
	    /* y is a number */
	    x->fp_class = FPC_NUM; /* return a forged number w/x's sign */
	    x->fp_exp = 16383;
	    x->fp_mant[0] = FP_1;
	}
    } else if (y->fp_class == FPC_INF) {
	/* x is a Num but y is an Inf */
	/* return a forged number w/y's sign inverted */
	x->fp_class = FPC_NUM;
	x->fp_sign = !y->fp_sign;
	x->fp_exp = 16383;
	x->fp_mant[0] = FP_1;
    } else {
	/* x and y are both numbers or zeros, or pair of a number and a zero */
	y->fp_sign = !y->fp_sign;
	x = fpu_add(fe);	/* (x - y) */
	/*
	 * FCMP does not set Inf bit in CC, so return a forged number
	 * (value doesn't matter) if Inf is the result of fsub.
	 */
	if (x->fp_class == FPC_INF) {
	    x->fp_class = FPC_NUM;
	    x->fp_exp = 16383;
	    x->fp_mant[0] = FP_1;
	}
    }
    return x;
}

/*
 * arithmetic operations
 */
int
fpu_emul_arith(struct fpemu *fe, struct instruction *insn, int *typ)
{
    struct frame *frame = fe->fe_frame;
    u_int *fpregs = &(fe->fe_fpframe->fpf_regs[0]);
    struct fpn *res;
    int word1, sig = 0;
    int regnum, format;
    int discard_result = 0;
    u_int buf[3];
#if DEBUG_FPE
    int flags;
    char regname;
#endif

    fe->fe_fpsr &= ~FPSR_EXCP;

    DUMP_INSN(insn);

#if DEBUG_FPE
    printf("fpu_emul_arith: FPSR = %08x, FPCR = %08x\n",
	   fe->fe_fpsr, fe->fe_fpcr);
#endif

    word1 = insn->is_word1;
    format = (word1 >> 10) & 7;
    regnum = (word1 >> 7) & 7;

    /* fetch a source operand : may not be used */
#if DEBUG_FPE
    printf("fpu_emul_arith: dst/src FP%d=%08x,%08x,%08x\n",
	   regnum, fpregs[regnum*3], fpregs[regnum*3+1],
	   fpregs[regnum*3+2]);
#endif

    fpu_explode(fe, &fe->fe_f1, FTYPE_EXT, &fpregs[regnum * 3]);

    DUMP_INSN(insn);

    /* get the other operand which is always the source */
    if ((word1 & 0x4000) == 0) {
#if DEBUG_FPE
	printf("fpu_emul_arith: FP%d op FP%d => FP%d\n",
	       format, regnum, regnum);
	printf("fpu_emul_arith: src opr FP%d=%08x,%08x,%08x\n",
	       format, fpregs[format*3], fpregs[format*3+1],
	       fpregs[format*3+2]);
#endif
	fpu_explode(fe, &fe->fe_f2, FTYPE_EXT, &fpregs[format * 3]);
    } else {
	/* the operand is in memory */
	if (format == FTYPE_DBL) {
	    insn->is_datasize = 8;
	} else if (format == FTYPE_SNG || format == FTYPE_LNG) {
	    insn->is_datasize = 4;
	} else if (format == FTYPE_WRD) {
	    insn->is_datasize = 2;
	} else if (format == FTYPE_BYT) {
	    insn->is_datasize = 1;
	} else if (format == FTYPE_EXT) {
	    insn->is_datasize = 12;
	} else {
	    /* invalid or unsupported operand format */
	    *typ = ILL_ILLOPN;
	    sig = SIGILL;
	    return sig;
	}

	/* Get effective address. (modreg=opcode&077) */
	sig = fpu_decode_ea(frame, insn, &insn->is_ea, insn->is_opcode, typ);
	if (sig) {
#if DEBUG_FPE
	    printf("fpu_emul_arith: error in fpu_decode_ea\n");
#endif
	    return sig;
	}

	DUMP_INSN(insn);

#if DEBUG_FPE
	printf("fpu_emul_arith: addr mode = ");
	flags = insn->is_ea.ea_flags;
	regname = (insn->is_ea.ea_regnum & 8) ? 'a' : 'd';

	if (flags & EA_DIRECT) {
	    printf("%c%d\n",
		   regname, insn->is_ea.ea_regnum & 7);
	} else if (flags & EA_PC_REL) {
	    if (flags & EA_OFFSET) {
		printf("pc@@(%d)\n", insn->is_ea.ea_offset);
	    } else if (flags & EA_INDEXED) {
		printf("pc@@(...)\n");
	    }
	} else if (flags & EA_PREDECR) {
	    printf("%c%d@@-\n",
		   regname, insn->is_ea.ea_regnum & 7);
	} else if (flags & EA_POSTINCR) {
	    printf("%c%d@@+\n", regname, insn->is_ea.ea_regnum & 7);
	} else if (flags & EA_OFFSET) {
	    printf("%c%d@@(%d)\n", regname, insn->is_ea.ea_regnum & 7,
		   insn->is_ea.ea_offset);
	} else if (flags & EA_INDEXED) {
	    printf("%c%d@@(...)\n", regname, insn->is_ea.ea_regnum & 7);
	} else if (flags & EA_ABS) {
	    printf("0x%08x\n", insn->is_ea.ea_absaddr);
	} else if (flags & EA_IMMED) {

	    printf("#0x%08x,%08x,%08x\n", insn->is_ea.ea_immed[0],
		   insn->is_ea.ea_immed[1], insn->is_ea.ea_immed[2]);
	} else {
	    printf("%c%d@@\n", regname, insn->is_ea.ea_regnum & 7);
	}
#endif /* DEBUG_FPE */

	fpu_load_ea(frame, insn, &insn->is_ea, (char *)buf, typ);
	if (format == FTYPE_WRD) {
	    /* sign-extend */
	    buf[0] &= 0xffff;
	    if (buf[0] & 0x8000) {
		buf[0] |= 0xffff0000;
	    }
	    format = FTYPE_LNG;
	} else if (format == FTYPE_BYT) {
	    /* sign-extend */
	    buf[0] &= 0xff;
	    if (buf[0] & 0x80) {
		buf[0] |= 0xffffff00;
	    }
	    format = FTYPE_LNG;
	}
#if DEBUG_FPE
	printf("fpu_emul_arith: src = %08x %08x %08x, siz = %d\n",
	       buf[0], buf[1], buf[2], insn->is_datasize);
#endif
	fpu_explode(fe, &fe->fe_f2, format, buf);
    }

    DUMP_INSN(insn);

    /* An arithmetic instruction emulate function has a prototype of
     * struct fpn *fpu_op(struct fpemu *);
     
     * 1) If the instruction is monadic, then fpu_op() must use
     * fe->fe_f2 as its operand, and return a pointer to the
     * result.
     
     * 2) If the instruction is diadic, then fpu_op() must use
     * fe->fe_f1 and fe->fe_f2 as its two operands, and return a
     * pointer to the result.
     
     */
    res = 0;
    switch (word1 & 0x3f) {
    case 0x00:			/* fmove */
	res = &fe->fe_f2;
	break;

    case 0x01:			/* fint */
	res = fpu_int(fe);
	break;

    case 0x03:			/* fintrz */
	res = fpu_intrz(fe);
	break;

    case 0x04:			/* fsqrt */
	res = fpu_sqrt(fe);
	break;

    case 0x06:			/* flognp1 */
	res = fpu_lognp1(fe);
	break;

    case 0x14:			/* flogn */
	res = fpu_logn(fe);
	break;

    case 0x15:			/* flog10 */
	res = fpu_log10(fe);
	break;

    case 0x16:			/* flog2 */
	res = fpu_log2(fe);
	break;

    case 0x18:			/* fabs */
	fe->fe_f2.fp_sign = 0;
	res = &fe->fe_f2;
	break;

    case 0x1A:			/* fneg */
	fe->fe_f2.fp_sign = !fe->fe_f2.fp_sign;
	res = &fe->fe_f2;
	break;

    case 0x1E:			/* fgetexp */
	res = fpu_getexp(fe);
	break;

    case 0x1F:			/* fgetman */
	res = fpu_getman(fe);
	break;

    case 0x20:			/* fdiv */
    case 0x24:			/* fsgldiv: cheating - better than nothing */
	res = fpu_div(fe);
	break;

    case 0x21:			/* fmod */
	res = fpu_mod(fe);
	break;

    case 0x28:			/* fsub */
	fe->fe_f2.fp_sign = !fe->fe_f2.fp_sign; /* f2 = -f2 */
    case 0x22:			/* fadd */
	res = fpu_add(fe);
	break;

    case 0x23:			/* fmul */
    case 0x27:			/* fsglmul: cheating - better than nothing */
	res = fpu_mul(fe);
	break;

    case 0x25:			/* frem */
	res = fpu_rem(fe);
	break;

    case 0x26:
	/* fscale is handled by a separate function */
	break;

    case 0x38:			/* fcmp */
	res = fpu_cmp(fe);
	discard_result = 1;
	break;

    case 0x3A:			/* ftst */
	res = &fe->fe_f2;
	discard_result = 1;
	break;

    case 0x02:			/* fsinh */
    case 0x08:			/* fetoxm1 */
    case 0x09:			/* ftanh */
    case 0x0A:			/* fatan */
    case 0x0C:			/* fasin */
    case 0x0D:			/* fatanh */
    case 0x0E:			/* fsin */
    case 0x0F:			/* ftan */
    case 0x10:			/* fetox */
    case 0x11:			/* ftwotox */
    case 0x12:			/* ftentox */
    case 0x19:			/* fcosh */
    case 0x1C:			/* facos */
    case 0x1D:			/* fcos */
    case 0x30:			/* fsincos */
    case 0x31:			/* fsincos */
    case 0x32:			/* fsincos */
    case 0x33:			/* fsincos */
    case 0x34:			/* fsincos */
    case 0x35:			/* fsincos */
    case 0x36:			/* fsincos */
    case 0x37:			/* fsincos */
    default:
#ifdef DEBUG
	printf("fpu_emul_arith: bad opcode=0x%x, word1=0x%x\n",
	       insn->is_opcode, insn->is_word1);
#endif
	sig = SIGILL;
    } /* switch (word1 & 0x3f) */

    if (!discard_result && sig == 0) {
	fpu_implode(fe, res, FTYPE_EXT, &fpregs[regnum * 3]);
#if DEBUG_FPE
	printf("fpu_emul_arith: %08x,%08x,%08x stored in FP%d\n",
	       fpregs[regnum*3], fpregs[regnum*3+1],
	       fpregs[regnum*3+2], regnum);
    } else if (sig == 0) {
	static char *class_name[] = { "SNAN", "QNAN", "ZERO", "NUM", "INF" };
	printf("fpu_emul_arith: result(%s,%c,%d,%08x,%08x,%08x) discarded\n",
	       class_name[res->fp_class + 2],
	       res->fp_sign ? '-' : '+', res->fp_exp,
	       res->fp_mant[0], res->fp_mant[1],
	       res->fp_mant[2]);
    } else {
	printf("fpu_emul_arith: received signal %d\n", sig);
#endif
    }

    /* update fpsr according to the result of operation */
    fpu_upd_fpsr(fe, res);

#if DEBUG_FPE
    printf("fpu_emul_arith: FPSR = %08x, FPCR = %08x\n",
	   fe->fe_fpsr, fe->fe_fpcr);
#endif

    DUMP_INSN(insn);

    return sig;
}

/* test condition code according to the predicate in the opcode.
 * returns -1 when the predicate evaluates to true, 0 when false.
 * signal numbers are returned when an error is detected.
 */
int
test_cc(fe, pred)
     struct fpemu *fe;
     int pred;
{
    int result, sig_bsun, invert;
    int fpsr;

    fpsr = fe->fe_fpsr;
    invert = 0;
    fpsr &= ~FPSR_EXCP;		/* clear all exceptions */
#if DEBUG_FPE
    printf("test_cc: fpsr=0x%08x\n", fpsr);
#endif
    pred &= 0x3f;		/* lowest 6 bits */

#if DEBUG_FPE
    printf("test_cc: ");
#endif

    if (pred >= 0x20) {
	return SIGILL;
    } else if (pred & 0x10) {
	/* IEEE nonaware tests */
	sig_bsun = 1;
	pred &= 0x0f;		/* lower 4 bits */
    } else {
	/* IEEE aware tests */
#if DEBUG_FPE
	printf("IEEE ");
#endif
	sig_bsun = 0;
    }

    if (pred & 0x08) {
#if DEBUG_FPE
	printf("Not ");
#endif
	/* predicate is "NOT ..." */
	pred ^= 0xf;		/* invert */
	invert = -1;
    }
    switch (pred) {
    case 0:			/* (Signaling) False */
#if DEBUG_FPE
	printf("False");
#endif
	result = 0;
	break;
    case 1:			/* (Signaling) Equal */
#if DEBUG_FPE
	printf("Equal");
#endif
	result = -((fpsr & FPSR_ZERO) == FPSR_ZERO);
	break;
    case 2:			/* Greater Than */
#if DEBUG_FPE
	printf("GT");
#endif
	result = -((fpsr & (FPSR_NAN|FPSR_ZERO|FPSR_NEG)) == 0);
	break;
    case 3:			/* Greater or Equal */
#if DEBUG_FPE
	printf("GE");
#endif
	result = -((fpsr & FPSR_ZERO) ||
		   (fpsr & (FPSR_NAN|FPSR_NEG)) == 0);
	break;
    case 4:			/* Less Than */
#if DEBUG_FPE
	printf("LT");
#endif
	result = -((fpsr & (FPSR_NAN|FPSR_ZERO|FPSR_NEG)) == FPSR_NEG);
	break;
    case 5:			/* Less or Equal */
#if DEBUG_FPE
	printf("LE");
#endif
	result = -((fpsr & FPSR_ZERO) ||
		   ((fpsr & (FPSR_NAN|FPSR_NEG)) == FPSR_NEG));
	break;
    case 6:			/* Greater or Less than */
#if DEBUG_FPE
	printf("GLT");
#endif
	result = -((fpsr & (FPSR_NAN|FPSR_ZERO)) == 0);
	break;
    case 7:			/* Greater, Less or Equal */
#if DEBUG_FPE
	printf("GLE");
#endif
	result = -((fpsr & FPSR_NAN) == 0);
	break;
    default:
	/* invalid predicate */
	return SIGILL;
    }
    result ^= invert;		/* if the predicate is "NOT ...", then
				   invert the result */
#if DEBUG_FPE
    printf("=> %s (%d)\n", result ? "true" : "false", result);
#endif
    /* if it's an IEEE unaware test and NAN is set, BSUN is set */
    if (sig_bsun && (fpsr & FPSR_NAN)) {
	fpsr |= FPSR_BSUN;
    }

    /* put fpsr back */
    fe->fe_fpframe->fpf_fpsr = fe->fe_fpsr = fpsr;

    return result;
}

/*
 * type 1: fdbcc, fscc, ftrapcc
 * In this function, we know:
 *   (opcode & 0x01C0) == 0x0040
 */
int
fpu_emul_type1(struct fpemu *fe, struct instruction *insn, int *typ)
{
    struct frame *frame = fe->fe_frame;
    int advance, sig, branch;
    int16_t displ;

    branch = test_cc(fe, insn->is_word1);
    fe->fe_fpframe->fpf_fpsr = fe->fe_fpsr;

    insn->is_advance = 4;
    sig = 0;

    switch (insn->is_opcode & 070) {
    case 010:			/* fdbcc */
	if (branch == -1) {
	    /* advance */
	    insn->is_advance = 6;
	} else if (!branch) {
	    /* decrement Dn and if (Dn != -1) branch */
	    u_int16_t count = frame->f_regs[insn->is_opcode & 7];

	    if (count-- != 0) {
		if (copyin((void *)(insn->is_pc + insn->is_advance), &displ,
		    sizeof(displ)) != 0) {
#ifdef DEBUG
		    printf("fpu_emul_type1: fault reading displacement\n");
#endif
		    return SIGSEGV;
		}
		insn->is_advance += (int)displ;
		/* XXX insn->is_nextpc = insn->is_pc + insn->is_advance; */
	    } else {
		insn->is_advance = 6;
	    }
	    /* write it back */
	    frame->f_regs[insn->is_opcode & 7] &= 0xffff0000;
	    frame->f_regs[insn->is_opcode & 7] |= (u_int32_t)count;
	} else {		/* got a signal */
	    sig = SIGFPE;
	}
	break;

    case 070:			/* ftrapcc or fscc */
	advance = 4;
	if ((insn->is_opcode & 07) >= 2) {
	    switch (insn->is_opcode & 07) {
	    case 3:		/* long opr */
		advance += 2;
	    case 2:		/* word opr */
		advance += 2;
	    case 4:		/* no opr */
		break;
	    default:
		return SIGILL;
		break;
	    }

	    if (branch == 0) {
		/* no trap */
		insn->is_advance = advance;
		sig = 0;
	    } else {
		/* trap */
		sig = SIGILL;
		*typ = ILL_ILLTRP;
	    }
	    break;
	} /* if ((insn->is_opcode & 7) < 2), fall through to FScc */

    default:			/* fscc */
	insn->is_advance = 4;
	insn->is_datasize = 1;	/* always byte */
	sig = fpu_decode_ea(frame, insn, &insn->is_ea, insn->is_opcode, typ);
	if (sig) {
	    break;
	}
	if (branch == -1 || branch == 0) {
	    /* set result */
	    sig = fpu_store_ea(frame, insn, &insn->is_ea, (char *)&branch);
	} else {
	    /* got an exception */
	    sig = branch;
	}
	break;
    }
    return sig;
}

/*
 * Type 2 or 3: fbcc (also fnop)
 * In this function, we know:
 *   (opcode & 0x0180) == 0x0080
 */
int
fpu_emul_brcc(fe, insn)
     struct fpemu *fe;
     struct instruction *insn;
{
    int displ;
    int sig;
    u_int16_t word2;

    /*
     * Get branch displacement.
     */
    insn->is_advance = 4;
    displ = insn->is_word1;

    if (insn->is_opcode & 0x40) {
	if (copyin((void *)(insn->is_pc + insn->is_advance), &word2,
	    sizeof(word2)) != 0) {
#ifdef DEBUG
	    printf("fpu_emul_brcc: fault reading word2\n");
#endif
	    return SIGSEGV;
	}
	displ <<= 16;
	displ |= word2;
	insn->is_advance += 2;
    } else /* displacement is word sized */
        if (displ & 0x8000)
	    displ |= 0xFFFF0000;

    /* XXX: If CC, insn->is_pc += displ */
    sig = test_cc(fe, insn->is_opcode);
    fe->fe_fpframe->fpf_fpsr = fe->fe_fpsr;

    if (fe->fe_fpsr & fe->fe_fpcr & FPSR_EXCP) {
	return SIGFPE;		/* caught an exception */
    }
    if (sig == -1) {
	/* branch does take place; 2 is the offset to the 1st disp word */
	insn->is_advance = displ + 2;
	/* XXX insn->is_nextpc = insn->is_pc + insn->is_advance; */
    } else if (sig) {
	return SIGILL;		/* got a signal */
    }
#if DEBUG_FPE
    printf("fpu_emul_brcc: %s insn @@ %x (%x+%x) (disp=%x)\n",
	   (sig == -1) ? "BRANCH to" : "NEXT",
	   insn->is_pc + insn->is_advance, insn->is_pc, insn->is_advance,
	   displ);
#endif
    return 0;
}
@


1.16
log
@opration -> operation
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu_emulate.c,v 1.15 2006/06/11 20:43:28 miod Exp $	*/
@


1.15
log
@Use bracketed include paths.
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu_emulate.c,v 1.14 2006/01/30 21:23:22 miod Exp $	*/
d595 1
a595 1
 * arithmetic oprations
@


1.14
log
@Better siginfo field values for fpe failures.
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu_emulate.c,v 1.13 2006/01/16 22:08:26 miod Exp $	*/
d49 1
a49 1
#include "fpu_emulate.h"
@


1.13
log
@Sync m68k fpe code with NetBSD; but remove unimplemented opcodes stubs, so
that we trigger SIGILL instead of propagating false results.

Tested by martin@@ on Macintosh LCIII.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 4
a54 4
int fpu_emul_fmovmcr(struct fpemu *fe, struct instruction *insn);
int fpu_emul_fmovm(struct fpemu *fe, struct instruction *insn);
int fpu_emul_arith(struct fpemu *fe, struct instruction *insn);
int fpu_emul_type1(struct fpemu *fe, struct instruction *insn);
d74 1
a74 3
fpu_emulate(frame, fpf)
     struct frame *frame;
     struct fpframe *fpf;
d134 1
d164 1
a164 1
	    sig = fpu_emul_fmovm(&fe, &insn);
d169 1
a169 1
	    sig = fpu_emul_fmovmcr(&fe, &insn);
d175 1
a175 1
	    sig = fpu_emul_fstore(&fe, &insn);
d181 1
a181 1
	    sig = fpu_emul_fmovecr(&fe, &insn);
d187 1
a187 1
	    sig = fpu_emul_fscale(&fe, &insn);
d193 1
a193 1
	    sig = fpu_emul_arith(&fe, &insn);
d213 1
a213 1
	sig = fpu_emul_type1(&fe, &insn);
d222 1
d255 12
d374 1
a374 3
fpu_emul_fmovmcr(fe, insn)
     struct fpemu *fe;
     struct instruction *insn;
d389 1
a389 1
    sig = fpu_decode_ea(frame, insn, &insn->is_ea, insn->is_opcode);
d417 1
a417 1
			      (char *)&fpf->fpf_fpcr);
d438 1
a438 1
			      (char *)&fpf->fpf_fpsr);
d450 1
a450 1
			      (char *)&fpf->fpf_fpiar);
d467 1
a467 3
fpu_emul_fmovm(fe, insn)
     struct fpemu *fe;
     struct instruction *insn;
d501 1
a501 1
    sig = fpu_decode_ea(frame, insn, &insn->is_ea, insn->is_opcode);
d528 1
a528 1
				  (char *)&fpregs[regnum * 3]);
d598 1
a598 3
fpu_emul_arith(fe, insn)
     struct fpemu *fe;
     struct instruction *insn;
d660 2
a661 1
	    sig = SIGFPE;
d666 1
a666 1
	sig = fpu_decode_ea(frame, insn, &insn->is_ea, insn->is_opcode);
d711 1
a711 1
	fpu_load_ea(frame, insn, &insn->is_ea, (char *)buf);
d1022 1
a1022 3
fpu_emul_type1(fe, insn)
     struct fpemu *fe;
     struct instruction *insn;
d1085 2
a1086 1
		sig = SIGFPE;
d1094 1
a1094 1
	sig = fpu_decode_ea(frame, insn, &insn->is_ea, insn->is_opcode);
@


1.12
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 2
a2 2
/*	$OpenBSD: fpu_emulate.c,v 1.11 2002/04/29 22:23:49 miod Exp $	*/
/*	$NetBSD: fpu_emulate.c,v 1.14 1996/12/18 05:44:31 scottr Exp $	*/
a42 1
#include <machine/cpu.h>
d45 1
a45 1
#ifdef DDB
d51 11
a61 24
static int fpu_emul_fmovmcr(struct fpemu *fe, struct instruction *insn);
static int fpu_emul_fmovm(struct fpemu *fe, struct instruction *insn);
static int fpu_emul_arith(struct fpemu *fe, struct instruction *insn);
static int fpu_emul_type1(struct fpemu *fe, struct instruction *insn);
static int fpu_emul_brcc(struct fpemu *fe, struct instruction *insn);
static int test_cc(struct fpemu *fe, int pred);
static struct fpn *fpu_cmp(struct fpemu *fe);

#if !defined(DL_DEFAULT)
#  if defined(DEBUG_WITH_FPU)
#    define DL_DEFAULT DL_ALL
#  else
#    define DL_DEFAULT 0
#  endif
#endif

int fpu_debug_level;
#if DEBUG
static int global_debug_level = DL_DEFAULT;
#endif

#define DUMP_INSN(insn)							\
if (fpu_debug_level & DL_DUMPINSN) {					\
    printf("  fpu_emulate: insn={adv=%d,siz=%d,op=%04x,w1=%04x}\n",	\
d63 3
a65 6
	   (insn)->is_opcode, (insn)->is_word1);			\
}

#ifdef DEBUG_WITH_FPU
/* mock fpframe for FPE - it's never overwritten by the real fpframe */
struct fpframe mockfpf;
d80 3
a82 2
    u_int savedpc;
    int word, optype, sig;
a83 1
#ifdef DEBUG
d86 1
a86 1
#endif
a87 5
#ifdef DEBUG_WITH_FPU
    fe.fe_fpframe = &mockfpf;
    fe.fe_fpsr = mockfpf.fpf_fpsr;
    fe.fe_fpcr = mockfpf.fpf_fpcr;
#else
a90 1
#endif
d92 3
a94 5
#ifdef DEBUG
    if ((fpu_debug_level = (fe.fe_fpcr >> 16) & 0x0000ffff) == 0) {
	/* set the default */
	fpu_debug_level = global_debug_level;
    }
d97 3
a99 4
    if (fpu_debug_level & DL_VERBOSE) {
	printf("ENTERING fpu_emulate: FPSR=%08x, FPCR=%08x\n",
	       fe.fe_fpsr, fe.fe_fpcr);
    }
d109 3
a111 2
	 * sizes of all instructions we run across.  This may not
	 * be true, so we save the PC in order to restore it later.
d113 3
a115 2
	savedpc = frame->f_pc;
	frame->f_pc = frame->f_fmt4.f_fslw;
d118 1
a118 1
    if (copyin((void *)frame->f_pc, &word, sizeof(int)) != 0) {
d120 1
a120 1
	printf("  fpu_emulate: fault reading opcode\n");
d122 1
a122 1
	return SIGSEGV;
d127 1
a127 1
	printf("  fpu_emulate: not coproc. insn.: opcode=0x%x\n", word);
d129 1
a129 1
	return SIGILL;
d132 1
a132 7
    if (
#ifdef  DEBUG_WITH_FPU
	(word & 0x0E00) != 0x0c00 /* accept fake ID == 6 */
#else
	(word & 0x0E00) != 0x0200
#endif
	) {
d134 1
a134 1
	printf("  fpu_emulate: bad coproc. id: opcode=0x%x\n", word);
d136 1
a136 1
	return SIGILL;
d142 1
a142 1
    if (copyin((void *)(frame->f_pc + 2), &word, sizeof(int)) != 0) {
d144 1
a144 1
	printf("  fpu_emulate: fault reading word1\n");
d146 1
a146 1
	return SIGSEGV;
d162 3
a164 2
	    if (fpu_debug_level & DL_INSN)
		printf("  fpu_emulate: fmovm FPr\n");
d167 3
a169 2
	    if (fpu_debug_level & DL_INSN)
		printf("  fpu_emulate: fmovm FPcr\n");
d173 3
a175 2
	    if (fpu_debug_level & DL_INSN)
		printf("  fpu_emulate: fmove to mem\n");
d179 3
a181 2
	    if (fpu_debug_level & DL_INSN)
		printf("  fpu_emulate: fmovecr\n");
d185 3
a187 2
	    if (fpu_debug_level & DL_INSN)
		printf("  fpu_emulate: fscale\n");
d190 3
a192 2
	    if (fpu_debug_level & DL_INSN)
		printf("  fpu_emulte: other type0\n");
d197 3
a199 2
	    if (fpu_debug_level & DL_VERBOSE)
		printf("  fpu_emulate: type 0 returned 0\n");
d204 4
a207 3
	if (fpu_debug_level & DL_INSN)
	    printf("  fpu_emulate: fbcc %s\n",
		   (optype & 0x40) ? "long" : "short");
d211 3
a213 2
	if (fpu_debug_level & DL_INSN)
	    printf("  fpu_emulate: type1\n");
d221 1
a221 1
	printf(" fpu_emulate: bad opcode type: opcode=0x%x\n", insn.is_opcode);
d228 6
a233 1
    if (sig == 0)
d235 1
a235 1
#if defined(DDB) && defined(DEBUG)
d237 1
a237 1
	printf(" fpu_emulate: sig=%d, opcode=%x, word1=%x\n",
d242 7
a248 2
    if (frame->f_format == 4)
	frame->f_pc = savedpc;	/* XXX Restore PC -- 68{EC,LC}040 only */
d250 4
a253 3
    if (fpu_debug_level & DL_VERBOSE)
	printf("EXITING fpu_emulate: w/FPSR=%08x, FPCR=%08x\n",
	       fe.fe_fpsr, fe.fe_fpcr);
d299 3
a301 3
    if (fpu_debug_level & DL_RESULT)
	printf("  fpu_upd_fpsr: previous fpsr=%08x\n", fe->fe_fpsr);

d305 3
a307 3
    if (fpu_debug_level & DL_RESULT)
	printf("  fpu_upd_fpsr: result is a ");

d309 3
a311 2
	if (fpu_debug_level & DL_RESULT)
	    printf("negative ");
d313 1
d315 2
a316 2
	if (fpu_debug_level & DL_RESULT)
	    printf("positive ");
d321 3
a323 2
	if (fpu_debug_level & DL_RESULT)
	    printf("signaling NAN\n");
d327 3
a329 2
	if (fpu_debug_level & DL_RESULT)
	    printf("quiet NAN\n");
d333 3
a335 2
	if (fpu_debug_level & DL_RESULT)
	    printf("Zero\n");
d339 3
a341 2
	if (fpu_debug_level & DL_RESULT)
	    printf("Inf\n");
d345 3
a347 2
	if (fpu_debug_level & DL_RESULT)
	    printf("Number\n");
d354 3
a356 2
    if (fpu_debug_level & DL_RESULT)
	printf("  fpu_upd_fpsr: new fpsr=%08x\n", fe->fe_fpframe->fpf_fpsr);
d361 1
a361 1
static int
d379 1
a379 1
    sig = fpu_decode_ea(frame, insn, &insn->is_ea0, insn->is_opcode);
d383 1
a383 1
	(insn->is_ea0.ea_flags & EA_DIRECT)) {
d386 1
a386 1
	printf("  fpu_emul_fmovmcr: tried to copy too many FPcr\n");
d393 2
a394 2
	if ((insn->is_ea0.ea_flags & EA_DIRECT) &&
	    insn->is_ea0.ea_regnum >= 8 /* address reg */) {
d397 2
a398 2
	    printf("  fpu_emul_fmovmcr: tried to copy FPCR from/to A%d\n",
		   insn->is_ea0.ea_regnum & 7);
d403 1
a403 1
	    sig = fpu_store_ea(frame, insn, &insn->is_ea0,
d406 1
a406 1
	    sig = fpu_load_ea(frame, insn, &insn->is_ea0,
d414 2
a415 2
	if ((insn->is_ea0.ea_flags & EA_DIRECT) &&
	    insn->is_ea0.ea_regnum >= 8 /* address reg */) {
d418 2
a419 2
	    printf("  fpu_emul_fmovmcr: tried to copy FPSR from/to A%d\n",
		   insn->is_ea0.ea_regnum & 7);
d424 1
a424 1
	    sig = fpu_store_ea(frame, insn, &insn->is_ea0,
d427 1
a427 1
	    sig = fpu_load_ea(frame, insn, &insn->is_ea0,
d436 1
a436 1
	    sig = fpu_store_ea(frame, insn, &insn->is_ea0,
d439 1
a439 1
	    sig = fpu_load_ea(frame, insn, &insn->is_ea0,
d456 1
a456 1
static int
d493 1
a493 1
    sig = fpu_decode_ea(frame, insn, &insn->is_ea0, insn->is_opcode);
d499 1
a499 1
    if (insn->is_ea0.ea_flags & EA_PREDECR) {
d507 1
a508 4
	if (w1_post_incr)
	    regmask = 0x80 >> regnum;
	else
	    regmask = 1 << regnum;
d511 1
a511 1
		sig = fpu_store_ea(frame, insn, &insn->is_ea0,
d513 5
a517 4
		if (fpu_debug_level & DL_RESULT)
		    printf("  fpu_emul_fmovm: FP%d (%08x,%08x,%08x) saved\n",
			   regnum, fpregs[regnum * 3], fpregs[regnum * 3 + 1],
			   fpregs[regnum * 3 + 2]);
d519 1
a519 1
		sig = fpu_load_ea(frame, insn, &insn->is_ea0,
d521 5
a525 4
		if (fpu_debug_level & DL_RESULT)
		    printf("  fpu_emul_fmovm: FP%d (%08x,%08x,%08x) loaded\n",
			   regnum, fpregs[regnum * 3], fpregs[regnum * 3 + 1],
			   fpregs[regnum * 3 + 2]);
d530 1
d536 1
a536 1
static struct fpn *
d589 1
a589 1
static int
d601 1
d604 3
d610 4
a613 4
    if (fpu_debug_level & DL_ARITH) {
	printf("  fpu_emul_arith: FPSR = %08x, FPCR = %08x\n",
	       fe->fe_fpsr, fe->fe_fpcr);
    }
d620 6
a625 5
    if (fpu_debug_level & DL_ARITH) {
	printf("  fpu_emul_arith: dst/src FP%d=%08x,%08x,%08x\n",
	       regnum, fpregs[regnum*3], fpregs[regnum*3+1],
	       fpregs[regnum*3+2]);
    }
d632 7
a638 7
	if (fpu_debug_level & DL_ARITH) {
	    printf("  fpu_emul_arith: FP%d op FP%d => FP%d\n",
		   format, regnum, regnum);
	    printf("  fpu_emul_arith: src opr FP%d=%08x,%08x,%08x\n",
		   format, fpregs[format*3], fpregs[format*3+1],
		   fpregs[format*3+2]);
	}
d659 1
a659 1
	sig = fpu_decode_ea(frame, insn, &insn->is_ea0, insn->is_opcode);
d661 3
a663 3
	    if (fpu_debug_level & DL_ARITH) {
		printf("  fpu_emul_arith: error in fpu_decode_ea\n");
	    }
d669 11
a679 22
	if (fpu_debug_level & DL_ARITH) {
	    printf("  fpu_emul_arith: addr mode = ");
	    flags = insn->is_ea0.ea_flags;
	    regname = (insn->is_ea0.ea_regnum & 8) ? 'a' : 'd';

	    if (flags & EA_DIRECT) {
		printf("%c%d\n",
		       regname, insn->is_ea0.ea_regnum & 7);
	    } else if (flags & EA_PC_REL) {
		if (flags & EA_OFFSET) {
		    printf("pc@@(%d)\n", insn->is_ea0.ea_offset);
		} else if (flags & EA_INDEXED) {
		    printf("pc@@(...)\n");
		}
	    } else if (flags & EA_PREDECR) {
		printf("%c%d@@-\n",
		       regname, insn->is_ea0.ea_regnum & 7);
	    } else if (flags & EA_POSTINCR) {
		printf("%c%d@@+\n", regname, insn->is_ea0.ea_regnum & 7);
	    } else if (flags & EA_OFFSET) {
		printf("%c%d@@(%d)\n", regname, insn->is_ea0.ea_regnum & 7,
		       insn->is_ea0.ea_offset);
d681 15
a695 4
		printf("%c%d@@(...)\n", regname, insn->is_ea0.ea_regnum & 7);
	    } else if (flags & EA_ABS) {
		printf("0x%08x\n", insn->is_ea0.ea_absaddr);
	    } else if (flags & EA_IMMED) {
d697 6
a702 6
		printf("#0x%08x,%08x,%08x\n", insn->is_ea0.ea_immed[0],
		       insn->is_ea0.ea_immed[1], insn->is_ea0.ea_immed[2]);
	    } else {
		printf("%c%d@@\n", regname, insn->is_ea0.ea_regnum & 7);
	    }
	} /* if (fpu_debug_level & DL_ARITH) */
d704 1
a704 1
	fpu_load_ea(frame, insn, &insn->is_ea0, (char *)buf);
d720 4
a723 4
	if (fpu_debug_level & DL_ARITH) {
	    printf("  fpu_emul_arith: src = %08x %08x %08x, siz = %d\n",
		   buf[0], buf[1], buf[2], insn->is_datasize);
	}
a750 4
    case 0x02:			/* fsinh */
	res = fpu_sinh(fe);
	break;

a762 40
    case 0x08:			/* fetoxm1 */
	res = fpu_etoxm1(fe);
	break;

    case 0x09:			/* ftanh */
	res = fpu_tanh(fe);
	break;

    case 0x0A:			/* fatan */
	res = fpu_atan(fe);
	break;

    case 0x0C:			/* fasin */
	res = fpu_asin(fe);
	break;

    case 0x0D:			/* fatanh */
	res = fpu_atanh(fe);
	break;

    case 0x0E:			/* fsin */
	res = fpu_sin(fe);
	break;

    case 0x0F:			/* ftan */
	res = fpu_tan(fe);
	break;

    case 0x10:			/* fetox */
	res = fpu_etox(fe);
	break;

    case 0x11:			/* ftwotox */
	res = fpu_twotox(fe);
	break;

    case 0x12:			/* ftentox */
	res = fpu_tentox(fe);
	break;

a779 4
    case 0x19:			/* fcosh */
	res = fpu_cosh(fe);
	break;

a784 8
    case 0x1C:			/* facos */
	res = fpu_acos(fe);
	break;

    case 0x1D:			/* fcos */
	res = fpu_cos(fe);
	break;

a820 11
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:			/* fsincos */
	res = fpu_sincos(fe, word1 & 7);
	break;

d831 22
d855 1
a855 1
	printf("  fpu_emul_arith: bad opcode=0x%x, word1=0x%x\n",
d863 5
a867 6
	if (fpu_debug_level & DL_ARITH) {
	    printf("  fpu_emul_arith: %08x,%08x,%08x stored in FP%d\n",
		   fpregs[regnum*3], fpregs[regnum*3+1],
		   fpregs[regnum*3+2], regnum);
	}
    } else if (sig == 0 && fpu_debug_level & DL_ARITH) {
d869 1
a869 1
	printf("  fpu_emul_arith: result(%s,%c,%d,%08x,%08x,%08x,%08x) discarded\n",
d873 4
a876 3
	       res->fp_mant[2], res->fp_mant[3]);
    } else if (fpu_debug_level & DL_ARITH) {
	printf("  fpu_emul_arith: received signal %d\n", sig);
d882 4
a885 4
    if (fpu_debug_level & DL_ARITH) {
	printf("  fpu_emul_arith: FPSR = %08x, FPCR = %08x\n",
	       fe->fe_fpsr, fe->fe_fpcr);
    }
d896 1
a896 1
static int
d907 3
a909 3
    if (fpu_debug_level & DL_TESTCC) {
	printf("  test_cc: fpsr=0x%08x\n", fpsr);
    }
d912 3
a914 3
    if (fpu_debug_level & DL_TESTCC) {
	printf("  test_cc: ");
    }
d916 1
a916 1
    if (pred >= 040) {
d921 1
a921 1
	pred &= 017;		/* lower 4 bits */
d924 3
a926 3
	if (fpu_debug_level & DL_TESTCC) {
	    printf("IEEE ");
	}
d930 4
a933 4
    if (pred >= 010) {
	if (fpu_debug_level & DL_TESTCC) {
	    printf("Not ");
	}
d940 3
a942 3
	if (fpu_debug_level & DL_TESTCC) {
	    printf("False");
	}
d946 3
a948 3
	if (fpu_debug_level & DL_TESTCC) {
	    printf("Equal");
	}
d952 3
a954 3
	if (fpu_debug_level & DL_TESTCC) {
	    printf("GT");
	}
d958 3
a960 3
	if (fpu_debug_level & DL_TESTCC) {
	    printf("GE");
	}
d965 3
a967 3
	if (fpu_debug_level & DL_TESTCC) {
	    printf("LT");
	}
d971 3
a973 3
	if (fpu_debug_level & DL_TESTCC) {
	    printf("LE");
	}
d978 3
a980 3
	if (fpu_debug_level & DL_TESTCC) {
	    printf("GLT");
	}
d984 3
a986 3
	if (fpu_debug_level & DL_TESTCC) {
	    printf("GLE");
	}
d995 3
a997 3
    if (fpu_debug_level & DL_TESTCC) {
	printf(" => %s (%d)\n", result ? "true" : "false", result);
    }
d1014 1
a1014 1
static int
d1020 2
a1021 1
    int advance, sig, branch, displ;
d1039 2
a1040 2
    		if (copyin((void *)(frame->f_pc + insn->is_advance),
		    &displ, sizeof(int)) != 0) {
d1042 1
a1042 1
		    printf("  fpu_emul_type1: fault reading displacement\n");
d1046 2
a1047 6
		/* sign-extend the displacement */
		displ &= 0xffff;
		if (displ & 0x8000) {
		    displ |= 0xffff0000;
		}
		insn->is_advance += displ;
d1088 1
a1088 1
	sig = fpu_decode_ea(frame, insn, &insn->is_ea0, insn->is_opcode);
d1094 1
a1094 1
	    sig = fpu_store_ea(frame, insn, &insn->is_ea0, (char *)&branch);
d1109 1
a1109 1
static int
d1114 1
a1114 2
    struct frame *frame = fe->fe_frame;
    int displ, word2;
d1116 1
d1125 2
a1126 2
    	if (copyin((void *)(frame->f_pc + insn->is_advance), &word2,
	    sizeof(int)) != 0) {
d1128 1
a1128 1
	    printf("  fpu_emul_brcc: fault reading word2\n");
d1139 1
a1139 1
    /* XXX: If CC, frame->f_pc += displ */
d1149 1
d1153 6
a1158 6
    if (fpu_debug_level & DL_BRANCH) {
	printf("  fpu_emul_brcc: %s insn @@ %x (%x+%x) (disp=%x)\n",
	       (sig == -1) ? "BRANCH to" : "NEXT",
	       frame->f_pc + insn->is_advance, frame->f_pc, insn->is_advance,
	       displ);
    }
@


1.11
log
@I want option DEBUG to rock my world.

(and that means it should compile, for starters)
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu_emulate.c,v 1.10 2002/03/14 03:15:54 millert Exp $	*/
d142 1
a142 2
    word = fusword((void *) (frame->f_pc));
    if (word < 0) {
d172 1
a172 2
    word = fusword((void *) (frame->f_pc + 2));
    if (word < 0) {
d1080 2
a1081 2
		displ = fusword((void *) (frame->f_pc + insn->is_advance));
		if (displ < 0) {
d1170 2
a1171 2
	word2 = fusword((void *) (frame->f_pc + insn->is_advance));
	if (word2 < 0) {
@


1.10
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu_emulate.c,v 1.9 2002/03/14 01:26:34 millert Exp $	*/
d46 4
d257 1
a257 1
	kdb_trap(-1, frame);
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu_emulate.c,v 1.8 1997/02/13 21:49:16 kstailey Exp $	*/
d515 1
a515 1
				   (char*)&fpregs[regnum * 3]);
d522 1
a522 1
				  (char*)&fpregs[regnum * 3]);
d699 1
a699 1
	fpu_load_ea(frame, insn, &insn->is_ea0, (char*)buf);
@


1.8
log
@add #include <machine/cpu.h> for prototype of fusword()
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu_emulate.c,v 1.7 1997/01/13 11:51:04 niklas Exp $	*/
d48 7
a54 7
static int fpu_emul_fmovmcr __P((struct fpemu *fe, struct instruction *insn));
static int fpu_emul_fmovm __P((struct fpemu *fe, struct instruction *insn));
static int fpu_emul_arith __P((struct fpemu *fe, struct instruction *insn));
static int fpu_emul_type1 __P((struct fpemu *fe, struct instruction *insn));
static int fpu_emul_brcc __P((struct fpemu *fe, struct instruction *insn));
static int test_cc __P((struct fpemu *fe, int pred));
static struct fpn *fpu_cmp __P((struct fpemu *fe));
@


1.8.24.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu_emulate.c,v 1.8 1997/02/13 21:49:16 kstailey Exp $	*/
a45 4
#ifdef DDB
#include <machine/db_machdep.h>
#endif

d48 7
a54 7
static int fpu_emul_fmovmcr(struct fpemu *fe, struct instruction *insn);
static int fpu_emul_fmovm(struct fpemu *fe, struct instruction *insn);
static int fpu_emul_arith(struct fpemu *fe, struct instruction *insn);
static int fpu_emul_type1(struct fpemu *fe, struct instruction *insn);
static int fpu_emul_brcc(struct fpemu *fe, struct instruction *insn);
static int test_cc(struct fpemu *fe, int pred);
static struct fpn *fpu_cmp(struct fpemu *fe);
d253 1
a253 1
	kdb_trap(-1, (db_regs_t *)frame);
d515 1
a515 1
				   (char *)&fpregs[regnum * 3]);
d522 1
a522 1
				  (char *)&fpregs[regnum * 3]);
d699 1
a699 1
	fpu_load_ea(frame, insn, &insn->is_ea0, (char *)buf);
@


1.8.24.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d142 2
a143 1
    if (copyin((void *)frame->f_pc, &word, sizeof(int)) != 0) {
d173 2
a174 1
    if (copyin((void *)(frame->f_pc + 2), &word, sizeof(int)) != 0) {
d1082 2
a1083 2
    		if (copyin((void *)(frame->f_pc + insn->is_advance),
		    &displ, sizeof(int)) != 0) {
d1172 2
a1173 2
    	if (copyin((void *)(frame->f_pc + insn->is_advance), &word2,
	    sizeof(int)) != 0) {
@


1.8.14.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 7
a54 7
static int fpu_emul_fmovmcr(struct fpemu *fe, struct instruction *insn);
static int fpu_emul_fmovm(struct fpemu *fe, struct instruction *insn);
static int fpu_emul_arith(struct fpemu *fe, struct instruction *insn);
static int fpu_emul_type1(struct fpemu *fe, struct instruction *insn);
static int fpu_emul_brcc(struct fpemu *fe, struct instruction *insn);
static int test_cc(struct fpemu *fe, int pred);
static struct fpn *fpu_cmp(struct fpemu *fe);
d515 1
a515 1
				   (char *)&fpregs[regnum * 3]);
d522 1
a522 1
				  (char *)&fpregs[regnum * 3]);
d699 1
a699 1
	fpu_load_ea(frame, insn, &insn->is_ea0, (char *)buf);
@


1.8.14.2
log
@Sync the SMP branch with 3.3
@
text
@a45 4
#ifdef DDB
#include <machine/db_machdep.h>
#endif

d138 2
a139 1
    if (copyin((void *)frame->f_pc, &word, sizeof(int)) != 0) {
d169 2
a170 1
    if (copyin((void *)(frame->f_pc + 2), &word, sizeof(int)) != 0) {
d253 1
a253 1
	kdb_trap(-1, (db_regs_t *)frame);
d1078 2
a1079 2
    		if (copyin((void *)(frame->f_pc + insn->is_advance),
		    &displ, sizeof(int)) != 0) {
d1168 2
a1169 2
    	if (copyin((void *)(frame->f_pc + insn->is_advance), &word2,
	    sizeof(int)) != 0) {
@


1.7
log
@Sync to 970110 NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu_emulate.c,v 1.6 1996/10/13 16:10:04 briggs Exp $	*/
d43 1
@


1.6
log
@The 68LC040 generates a format 4 stack frame for floating point
exceptions, which puts the address of the instruction we faulted
on in a different location.  Copy it and handle as we normally would,
restoring the saved PC before returning.

The FPE should probably be reworked to take advantage of the 68LC040's
precalculated effective address, at some point.
@
text
@d1 2
a2 2
/*	$OpenBSD: fpu_emulate.c,v 1.5 1996/09/18 02:09:29 briggs Exp $	*/
/*	$NetBSD: fpu_emulate.c,v 1.10 1996/10/13 03:19:12 christos Exp $	*/
a54 2
int	fusword __P((void *));

d872 1
@


1.5
log
@NetBSD PR#2761 (wrong fmovem emulation) from Takeshi Nakayama
(takeshi@@sakabe.nuie.nagoya-u.ac.jp).  Untested by me, but it
looks correct against the FP User's manual.
@
text
@d1 2
a2 2
/*	$OpenBSD: fpu_emulate.c,v 1.4 1996/05/29 11:29:30 niklas Exp $	*/
/*	$NetBSD: fpu_emulate.c,v 1.6 1996/05/15 07:31:55 leo Exp $	*/
d94 1
d123 16
d248 1
a248 1
    if (sig == 0) {
a249 1
    }
d257 2
d509 1
a509 1
	if (w1_post_incr) {
d511 1
a511 1
	} else {
a512 1
	}
@


1.4
log
@From Netbsd: Fix "might be used uninitialized" warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d449 1
a449 1
    int w1_post_incr;		/* XXX - FP regs order? */
d491 5
a495 1
	regmask = 1 << regnum;
@


1.3
log
@From NetBSD:
Update for -Wall -Wstrict-prototypes -Wmissing-prototypes -Wno-uninitialized.
Bring back Step9 and fix an oversight from Ken Nakata <kenn@@remus.rutgers.edu>
@
text
@d2 1
a2 1
/*	$NetBSD: fpu_emulate.c,v 1.5 1996/04/30 11:52:13 briggs Exp $	*/
d716 1
@


1.2
log
@from netbsd:
Still incomplete, but much more complete FPE from Ken Nakata
<kenn@@remus.rutgers.edu>.  This emulator does not yet emulate
the following functions:
        FSINH, FETOXM1, FTANH, FATAN, FASIN, FATANH, FSIN, FTAN,
        FETOX, FTWOTOX, FTENTOX, FCOSH, FACOS, FCOS, FSINCOS
It is sufficient, however, to allow programs like df, w, and newfs,
to run to completion with correct results.
Portions of this code were based on the sparc fpe and on initial
work by gwr.
@
text
@d1 2
a2 1
/*	$NetBSD: fpu_emulate.c,v 1.4 1995/11/05 00:35:17 briggs Exp $	*/
d42 1
d55 2
d66 1
d68 1
a94 2
    int i;
    u_int *pt;
d122 1
a122 1
    word = fusword(frame->f_pc);
d153 1
a153 1
    word = fusword(frame->f_pc + 2);
d351 2
a352 2
    int word1, sig;
    int reglist, regmask, regnum;
a1037 1
    struct fpframe *fpf = fe->fe_fpframe;
d1056 1
a1056 1
		displ = fusword(frame->f_pc + insn->is_advance);
a1135 1
    struct fpframe *fpf = fe->fe_fpframe;
d1137 1
a1137 1
    int sig, advance;
d1146 1
a1146 1
	word2 = fusword(frame->f_pc + insn->is_advance);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: fpu_emulate.c,v 1.2 1995/03/10 01:43:05 gwr Exp $	*/
d5 1
d43 1
a43 1
#define	DEBUG 1	/* XXX */
d45 18
a62 51
/*
 * Internal info about a decoded effective address.
 */
struct insn_ea {
	int regnum;
	int immed;
	int flags;
#define	EA_DIRECT	0x01
#define EA_PREDECR	0x02
#define	EA_POSTINCR	0x04
#define EA_OFFSET	0x08	/* mode 5: base+offset */
#define	EA_INDEXED	0x10	/* mode 6: complicated */
#define EA_ABS  	0x20	/* mode 7: reg 0 or 1 */
#define EA_PC_REL	0x40	/* mode 7: reg 2 or 3 */
#define	EA_IMMED	0x80	/* mode 7: reg 4 */
};

struct instruction {
	int advance;	/* length of instruction */
	int datasize;	/* byte, word, long, float, double, ... */
	int	opcode;
	int word1;
	struct insn_ea ea0;
	struct insn_ea ea1;
};

int fpu_emul_fmovm(struct frame *frame,
				   struct fpframe *fpf,
				   struct instruction *insn);
int fpu_emul_type0(struct frame *frame,
				   struct fpframe *fpf,
				   struct instruction *insn);
int fpu_emul_type1(struct frame *frame,
				   struct fpframe *fpf,
				   struct instruction *insn);
int fpu_emul_brcc(struct frame *frame,
				  struct fpframe *fpf,
				  struct instruction *insn);

static int decode_ea(struct frame *frame,
					 struct instruction *insn,
					 struct insn_ea *ea,
					 int modreg);
static int load_ea(struct frame *frame,
				   struct instruction *insn,
				   struct insn_ea *ea,
				   char *cpureg);
static int store_ea(struct frame *frame,
					struct instruction *insn,
					struct insn_ea *ea,
					char *cpureg);
d64 11
d81 4
a84 1
int fpu_emulate(struct frame *frame, struct fpframe *fpf)
d86 27
a112 2
	struct instruction insn;
	int word, optype, sig;
d114 8
a121 4
	word = fusword(frame->f_pc);
	if (word < 0) {
#ifdef	DEBUG
		printf("fpu_emulate: fault reading opcode\n");
d123 2
a124 2
		return SIGSEGV;
	}
d126 3
a128 3
	if ((word & 0xF000) != 0xF000) {
#ifdef	DEBUG
		printf("fpu_emulate: not coproc. insn.: opcode=0x%x\n", word);
d130 2
a131 2
		return SIGILL;
	}
d133 9
a141 3
	if ((word & 0x0E00) != 0x0200) {
#ifdef	DEBUG
		printf("fpu_emulate: bad coproc. id: opcode=0x%x\n", word);
d143 2
a144 2
		return SIGILL;
	}
d146 2
a147 2
	insn.opcode = word;
	optype = (word & 0x01C0);
d149 4
a152 4
	word = fusword(frame->f_pc + 2);
	if (word < 0) {
#ifdef	DEBUG
		printf("fpu_emulate: fault reading word1\n");
d154 43
a196 1
		return SIGSEGV;
d198 4
a201 14
	insn.word1 = word;

	/*
	 * Which family (or type) of opcode is it?
	 * Tests ordered by likelihood (hopefully).
	 * Certainly, type 0 is the most common.
	 */
	if (optype == 0x0000) {
		/* type=0: generic */
		if (insn.word1 & 0x8000) {
			sig = fpu_emul_fmovm(frame, fpf, &insn);
		} else {
			sig = fpu_emul_type0(frame, fpf, &insn);
		}
d203 18
a220 19
	else if (optype == 0x0080) {
		/* type=2: fbcc, short disp. */
		sig = fpu_emul_brcc(frame, fpf, &insn);
	}
	else if (optype == 0x00C0) {
		/* type=3: fbcc, long disp. */
		sig = fpu_emul_brcc(frame, fpf, &insn);
	}
	else if (optype == 0x0040) {
		/* type=1: fdbcc, fscc, ftrapcc */
		sig = fpu_emul_type1(frame, fpf, &insn);
	}
	else {
		/* type=4: fsave    (privileged) */
		/* type=5: frestore (privileged) */
		/* type=6: reserved */
		/* type=7: reserved */
#ifdef	DEBUG
		printf("fpu_emulate: bad opcode type: opcode=0x%x\n", insn.opcode);
d222 4
a225 2
		sig = SIGILL;
	}
d227 3
a229 3
	if (sig == 0) {
		frame->f_pc += insn.advance;
	}
d231 5
a235 1
	else kdb_trap(-1, frame);
d238 5
a242 1
	return (sig);
d245 4
a248 13
/*
 * type 0: fmovem, fmove <cr>
 * Separated out of fpu_emul_type0 for efficiency.
 * In this function, we know:
 *   (opcode & 0x01C0) == 0
 *   (word1 & 0x8000) == 0x8000
 *
 * No conversion or rounding is done by this instruction,
 * and the FPSR is not affected.
 */
int fpu_emul_fmovm(struct frame *frame,
				   struct fpframe *fpf,
				   struct instruction *insn)
d250 22
a271 31
	int word1, sig;
	int reglist, regmask, regnum;
	int fpu_to_mem, order;
	int w1_post_incr;	/* XXX - FP regs order? */
	int *fpregs;

	insn->advance = 4;
	insn->datasize = 12;
	word1 = insn->word1;

	/* Bit 14 selects FPn or FP control regs. */
	if (word1 & 0x4000) {
		/*
		 * Bits 12,11 select register list mode:
		 * 0,0: Static  reg list, pre-decr.
		 * 0,1: Dynamic reg list, pre-decr.
		 * 1,0: Static  reg list, post-incr.
		 * 1,1: Dynamic reg list, post-incr
		 */
		w1_post_incr = word1 & 0x1000;
		if (word1 & 0x0800) {
			/* dynamic reg list */
			reglist = frame->f_regs[(word1 & 0x70) >> 4];
		} else
			reglist = word1;
		reglist &= 0xFF;
	} else {
		/* XXX: move to/from control registers */
		reglist = word1 & 0x1C00;
		return SIGILL;
	}
d273 1
a273 2
	/* Bit 13 selects direction (FPU to/from Mem) */
	fpu_to_mem = word1 & 0x2000;
d275 2
a276 3
	/* Get effective address. (modreg=opcode&077) */
	sig = decode_ea(frame, insn, &insn->ea0, insn->opcode);
	if (sig) return sig;
d278 7
a284 2
	/* Get address of soft coprocessor regs. */
	fpregs = &fpf->fpf_regs[0];
d286 2
a287 7
	if (insn->ea0.flags & EA_PREDECR) {
		regnum = 7;
		order = -1;
	} else {
		regnum = 0;
		order = 1;
	}
d289 2
a290 13
	while ((0 <= regnum) && (regnum < 8)) {
		regmask = 1 << regnum;
		if (regmask & reglist) {
			if (fpu_to_mem)
				sig = store_ea(frame, insn, &insn->ea0,
							   (char*) &fpregs[regnum]);
			else /* mem to fpu */
				sig = load_ea(frame, insn, &insn->ea0,
							  (char*) &fpregs[regnum]);
			if (sig) break;
		}
		regnum += order;
	}
d292 39
a330 2
	return 0;
}
d332 1
a332 5
int fpu_emul_type0(struct frame *frame,
				   struct fpframe *fpf,
				   struct instruction *insn)
{
	int sig;
d334 2
a335 2
	/* Get effective address */
	/* XXX */
d337 2
a338 1
	switch(insn->word1 & 0x3F) {
d340 29
a368 1
	case 0x00:	/* fmove */
d370 8
a377 45
	case 0x01:	/* fint */
	case 0x02:	/* fsinh */
	case 0x03:	/* fintrz */
	case 0x04:	/* fsqrt */
	case 0x06:	/* flognp1 */

	case 0x09:	/* ftanh */
	case 0x0A:	/* fatan */
	case 0x0C:	/* fasin */
	case 0x0D:	/* fatanh */
	case 0x0E:	/* fsin */
	case 0x0F:	/* ftan */

	case 0x10:	/* fetox */
	case 0x11:	/* ftwotox */
	case 0x12:	/* ftentox */
	case 0x14:	/* flogn */
	case 0x15:	/* flog10 */
	case 0x16:	/* flog2 */

	case 0x18:	/* fabs */
	case 0x19:	/* fcosh */
	case 0x1A:	/* fneg */
	case 0x1C:	/* facos */
	case 0x1D:	/* fcos */
	case 0x1E:	/* fgetexp */
	case 0x1F:	/* fgetman */

	case 0x20:	/* fdiv */
	case 0x21:	/* fmod */
	case 0x22:	/* fadd */
	case 0x23:	/* fmul */
	case 0x24:	/* fsgldiv */
	case 0x25:	/* frem */
	case 0x26:	/* fscale */
	case 0x27:	/* fsglmul */

	case 0x28:	/* fsub */
	case 0x38:	/* fcmp */
	case 0x3A:	/* ftst */

	default:
#ifdef	DEBUG
		printf("fpu_emul_type0: unknown: opcode=0x%x, word1=0x%x\n",
			   insn->opcode, insn->word1);
d379 11
a389 1
		sig = SIGILL;
d391 32
a422 2
	} /* switch */
	return (sig);
d426 2
a427 1
 * type 1: fdbcc, fscc, ftrapcc
d429 5
a433 1
 *   (opcode & 0x01C0) == 0x0040
d435 4
a438 3
int fpu_emul_type1(struct frame *frame,
				   struct fpframe *fpf,
				   struct instruction *insn)
d440 68
a507 21
	int sig;

	/* Get effective address */
	/* XXX */

	switch (insn->opcode & 070) {

	case 010:	/* fdbcc */
		/* XXX: If not CC { Decrement Dn; if (Dn >= 0) branch; } */

	case 070:	/* fscc or ftrapcc */
		if ((insn->opcode & 07) > 1) {
			/* ftrapcc */
			/* XXX: If CC, advance and return SIGFPE */
			break;
		}
		/* fallthrough */
	default:	/* fscc */
		/* XXX: If CC, store ones, else store zero */
		sig = SIGILL;
		break;
d509 1
a509 2
	}
	return (sig);
d512 3
a514 8
/*
 * Type 2 or 3: fbcc (also fnop)
 * In this function, we know:
 *   (opcode & 0x0180) == 0x0080
 */
int fpu_emul_brcc(struct frame *frame,
				  struct fpframe *fpf,
				  struct instruction *insn)
d516 1
a516 2
	int displ, word2;
	int sig, advance;
d518 31
d550 2
a551 1
	 * Get branch displacement.
d553 4
a556 16
	advance = 4;
	displ = insn->word1;
	if (displ & 0x8000)
		displ |= 0xFFFF0000;

	if (insn->opcode & 0x40) {
		word2 = fusword(frame->f_pc + 4);
		if (word2 < 0) {
#ifdef	DEBUG
			printf("fpu_emul_brcc: fault reading word2\n");
#endif
			return SIGSEGV;
		}
		displ << 16;
		displ |= word2;
		advance += 2;
d558 2
a559 3

	/* XXX: If CC, frame->f_pc += displ */
	return SIGILL;
d563 1
a563 1
 * Helper routines for dealing with "effective address" values.
d565 4
a568 9

/*
 * Decode an effective address into internal form.
 * Returns zero on success, else signal number.
 */
static int decode_ea(struct frame *frame,
					 struct instruction *insn,
					 struct insn_ea *ea,
					 int modreg)
d570 58
a627 2
	int immed_bytes = 0;
	int data;
d629 8
a636 2
	/* Set the most common value here. */
	ea->regnum = 8 + (modreg & 7);
d638 1
a638 1
	switch (modreg & 070) {
d640 57
a696 4
	case 0:	/* Dn */
		ea->regnum = (modreg & 7);
		ea->flags = EA_DIRECT;
		break;
d698 1
a698 3
	case 010:	/* An */
		ea->flags = EA_DIRECT;
		break;
d700 174
a873 3
	case 020:	/* (An) */
		ea->flags = 0;
		break;
d875 25
a899 12
	case 030: /* (An)+ */
		ea->flags = EA_POSTINCR;
		break;

	case 040: /* -(An) */
		ea->flags = EA_PREDECR;
		break;

	case 050: /* (d16,An) */
		ea->flags = EA_OFFSET;
		immed_bytes = 2;
		break;
d901 1
a901 4
	case 060:	/* (d8,An,Xn) */
		ea->flags = EA_INDEXED;
		immed_bytes = 2;
		break;
d903 1
a903 54
	case 070:	/* misc. */
		ea->regnum = (modreg & 7);
		switch (modreg & 7) {

		case 0: /* (xxxx).W */
			ea->flags = EA_ABS;
			immed_bytes = 2;
			break;

		case 1: /* (xxxxxxxx).L */
			ea->flags = EA_ABS;
			immed_bytes = 4;
			break;

		case 2: /* (d16,PC) */
			ea->flags = EA_PC_REL | EA_OFFSET;
			immed_bytes = 2;
			break;

		case 3: /* (d8,PC,Xn) */
			ea->flags = EA_PC_REL | EA_INDEXED;
			immed_bytes = 2;
			break;

		case 4: /* #data */
			ea->flags = EA_IMMED;
			immed_bytes = insn->datasize;
			break;

		default:
			return SIGILL;
		} /* switch for mode 7 */
		break;
	} /* switch mode */

	/* Now fetch any immediate data and advance. */
	if (immed_bytes > 0) {
		data = fusword(frame->f_pc + insn->advance);
		if (data < 0)
			return SIGSEGV;
		insn->advance += 2;
		if (data & 0x8000)
			data |= 0xFFFF0000;
		ea->immed = data;
	}
	if (immed_bytes > 2) {
		data = fusword(frame->f_pc + insn->advance);
		if (data < 0)
			return SIGSEGV;
		insn->advance += 2;
		ea->immed <<= 16;
		ea->immed |= data;
	}
	return 0;
d906 3
a908 4

/*
 * Load a value from an effective address.
 * Returns zero on success, else signal number.
d910 4
a913 4
static int load_ea(struct frame *frame,
				   struct instruction *insn,
				   struct insn_ea *ea,
				   char *dst)
d915 2
a916 33
	int *reg;
	char *src;
	int len;

#ifdef	DIAGNOSTIC
	if (ea->regnum & ~0xF)
		panic("load_ea: bad regnum");
#endif

	/* The dst is always int or larger. */
	len = insn->datasize;
	if (len < 4)
		dst += (4 - len);

	/* point to the register */
	if (ea->flags & EA_PC_REL)
		reg = &frame->f_pc;
	else
		reg = &frame->f_regs[ea->regnum];

	if (ea->flags & (EA_DIRECT | EA_IMMED)) {
		if (ea->flags & EA_DIRECT)
			src = (char*) reg;
		if (ea->flags & EA_IMMED)
			src = (char*) &ea->immed;
		if (len > 4)
			return SIGILL;
		/* The source is an int. */
		if (len < 4)
			src += (4 - len);
		bcopy(src, dst, len);
	} else {
		/* One of MANY indirect forms... */
d918 11
a928 3
		/* do pre-decrement */
		if (ea->flags & EA_PREDECR)
			*reg -= len;
d930 13
a942 2
		/* Grab the register contents. */
		src = (char*) *reg;
d944 72
a1015 7
		/* apply the signed offset */
		if (ea->flags & EA_OFFSET)
			src += ea->immed;

		/* XXX - Don't know how to handle this yet. */
		if (ea->flags & EA_INDEXED)
			return SIGILL;
d1017 2
a1018 1
		copyin(src, dst, len);
d1020 1
a1020 6
		/* do post-increment */
		if (ea->flags & EA_POSTINCR)
			*reg += len;
	}

	return 0;
d1024 3
a1026 2
 * Store a value at the effective address.
 * Returns zero on success, else signal number.
d1028 4
a1031 4
static int store_ea(struct frame *frame,
					struct instruction *insn,
					struct insn_ea *ea,
					char *src)
d1033 43
a1075 19
	int *reg;
	char *dst;
	int len;

#ifdef	DIAGNOSTIC
	if (ea->regnum & ~0xF)
		panic("load_ea: bad regnum");
#endif

	/* The src is always int or larger. */
	len = insn->datasize;
	if (len < 4)
		src += (4 - len);

	/* point to the register */
	if (ea->flags & EA_PC_REL)
		reg = &frame->f_pc;
	else
		reg = &frame->f_regs[ea->regnum];
d1077 11
a1087 1
	if (ea->flags & EA_IMMED)
d1089 2
d1092 21
a1112 8
	if (ea->flags & EA_DIRECT) {
		dst = (char*) reg;
		if (len > 4)
			return SIGILL;
		/* The destination is an int. */
		if (len < 4)
			dst += (4 - len);
		bcopy(src, dst, len);
d1114 7
a1120 1
		/* One of MANY indirect forms... */
d1122 28
a1149 20
		/* do pre-decrement */
		if (ea->flags & EA_PREDECR)
			*reg -= len;

		/* Grab the register contents. */
		dst = (char*) *reg;

		/* apply the signed offset */
		if (ea->flags & EA_OFFSET)
			dst += ea->immed;

		/* XXX - Don't know how to handle this yet. */
		if (ea->flags & EA_INDEXED)
			return SIGILL;

		copyout(src, dst, len);

		/* do post-increment */
		if (ea->flags & EA_POSTINCR)
			*reg += len;
d1151 27
a1177 2

	return 0;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
