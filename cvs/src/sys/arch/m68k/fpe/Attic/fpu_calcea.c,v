head	1.12;
access;
symbols
	OPENBSD_5_3:1.11.0.30
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.28
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.26
	OPENBSD_5_0:1.11.0.24
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.22
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.20
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.16
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.18
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.14
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.12
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.10
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.8
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.6
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.9.0.12
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.10
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.8
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.6
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.4
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.6.0.16
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.14
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.12
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.10
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.8
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.6
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.12
date	2013.03.25.19.08.55;	author miod;	state dead;
branches;
next	1.11;

1.11
date	2006.01.30.21.23.22;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.16.22.08.26;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.09.22.27.09;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.03.15.54;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.34;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.01.11.05.11.33;	author millert;	state Exp;
branches
	1.6.6.1
	1.6.16.1;
next	1.5;

1.5
date	97.02.13.21.49.15;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.01.13.11.51.03;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.05.09.22.20.43;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.11.03.17;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.12.14.04.53.04;	author deraadt;	state Exp;
branches;
next	;

1.6.6.1
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.6.6.2;

1.6.6.2
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	;

1.6.16.1
date	2002.06.11.03.36.06;	author art;	state Exp;
branches;
next	1.6.16.2;

1.6.16.2
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Remove the m68k FPU emulator; it was only used by the mac68k port which has been
lying in the Attic for quite awhile; none of the remaining m68k-based ports
support FPU-less systems; assuming my HP332 cpu board is in working condition,
give me memory boards for it to have at least 8MB and a chassis, and I'll
consider bringing this code back. But then, the 332 has an FPU socket, and
I'd rather write a new glue to use the MI softloat code (bug-free) than try
and fix the bugs in this.
@
text
@/*	$OpenBSD: fpu_calcea.c,v 1.11 2006/01/30 21:23:22 miod Exp $	*/
/*	$NetBSD: fpu_calcea.c,v 1.16 2004/02/13 11:36:14 wiz Exp $	*/

/*
 * Copyright (c) 1995 Gordon W. Ross
 * portion Copyright (c) 1995 Ken Nakata
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 4. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Gordon Ross
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/signal.h>
#include <sys/systm.h>
#include <machine/frame.h>

#include "fpu_emulate.h"

/*
 * Prototypes of local functions
 */
int decode_ea6(struct frame *frame, struct instruction *insn,
			   struct insn_ea *ea, int modreg, int *typ);
int fetch_immed(struct frame *frame, struct instruction *insn,
			    int *dst);
int fetch_disp(struct frame *frame, struct instruction *insn,
			   int size, int *res);
int calc_ea(struct insn_ea *ea, char *ptr, char **eaddr);

/*
 * Helper routines for dealing with "effective address" values.
 */

/*
 * Decode an effective address into internal form.
 * Returns zero on success, else signal number.
 */
int
fpu_decode_ea(struct frame *frame, struct instruction *insn, struct insn_ea *ea,
    int modreg, int *typ)
{
    int sig;

#ifdef DEBUG
    if (insn->is_datasize < 0) {
	panic("decode_ea: called with uninitialized datasize");
    }
#endif

    sig = 0;

    /* Set the most common value here. */
    ea->ea_regnum = 8 + (modreg & 7);

    if ((modreg & 060) == 0) {
	/* register direct */
	ea->ea_regnum = modreg & 0xf;
	ea->ea_flags = EA_DIRECT;
#ifdef DEBUG_FPE
	printf("decode_ea: register direct reg=%d\n", ea->ea_regnum);
#endif
    } else if ((modreg & 077) == 074) {
	/* immediate */
	ea->ea_flags = EA_IMMED;
	sig = fetch_immed(frame, insn, &ea->ea_immed[0]);
#ifdef DEBUG_FPE
	printf("decode_ea: immediate size=%d\n", insn->is_datasize);
#endif
    }
    /*
     * rest of the address modes need to be separately
     * handled for the LC040 and the others.
     */
#if 0 /* XXX */
    else if (frame->f_format == 4 && frame->f_fmt4.f_fa) {
	/* LC040 */
	ea->ea_flags = EA_FRAME_EA;
	ea->ea_fea = frame->f_fmt4.f_fa;
#ifdef DEBUG_FPE
	printf("decode_ea: 68LC040 - in-frame EA (%p) size %d\n",
		(void *)ea->ea_fea, insn->is_datasize);
#endif
	if ((modreg & 070) == 030) {
	    /* postincrement mode */
	    ea->ea_flags |= EA_POSTINCR;
	} else if ((modreg & 070) == 040) {
	    /* predecrement mode */
	    ea->ea_flags |= EA_PREDECR;
#ifdef M68060
#if defined(M68020) || defined(M68030) || defined(M68040)
	    if (cputype == CPU_68060)
#endif
		if (insn->is_datasize == 12)
			ea->ea_fea -= 8;
#endif
	}
    }
#endif /* XXX */
    else {
	/* 020/030 */
	switch (modreg & 070) {

	case 020:			/* (An) */
	    ea->ea_flags = 0;
#ifdef DEBUG_FPE
	    printf("decode_ea: register indirect reg=%d\n", ea->ea_regnum);
#endif
	    break;

	case 030:			/* (An)+ */
	    ea->ea_flags = EA_POSTINCR;
#ifdef DEBUG_FPE
	    printf("decode_ea: reg indirect postincrement reg=%d\n",
		   ea->ea_regnum);
#endif
	    break;

	case 040:			/* -(An) */
	    ea->ea_flags = EA_PREDECR;
#ifdef DEBUG_FPE
	    printf("decode_ea: reg indirect predecrement reg=%d\n",
		   ea->ea_regnum);
#endif
	    break;

	case 050:			/* (d16,An) */
	    ea->ea_flags = EA_OFFSET;
	    sig = fetch_disp(frame, insn, 1, &ea->ea_offset);
#ifdef DEBUG_FPE
	    printf("decode_ea: reg indirect with displacement reg=%d\n",
		   ea->ea_regnum);
#endif
	    break;

	case 060:			/* (d8,An,Xn) */
	    ea->ea_flags = EA_INDEXED;
	    sig = decode_ea6(frame, insn, ea, modreg, typ);
	    break;

	case 070:			/* misc. */
	    ea->ea_regnum = (modreg & 7);
	    switch (modreg & 7) {

	    case 0:			/* (xxxx).W */
		ea->ea_flags = EA_ABS;
		sig = fetch_disp(frame, insn, 1, &ea->ea_absaddr);
#ifdef DEBUG_FPE
		printf("decode_ea: absolute address (word)\n");
#endif
		break;

	    case 1:			/* (xxxxxxxx).L */
		ea->ea_flags = EA_ABS;
		sig = fetch_disp(frame, insn, 2, &ea->ea_absaddr);
#ifdef DEBUG_FPE
		printf("decode_ea: absolute address (long)\n");
#endif
		break;

	    case 2:			/* (d16,PC) */
		ea->ea_flags = EA_PC_REL | EA_OFFSET;
		sig = fetch_disp(frame, insn, 1, &ea->ea_absaddr);
#ifdef DEBUG_FPE
		printf("decode_ea: pc relative word displacement\n");
#endif
		break;

	    case 3:			/* (d8,PC,Xn) */
		ea->ea_flags = EA_PC_REL | EA_INDEXED;
		sig = decode_ea6(frame, insn, ea, modreg, typ);
		break;

	    case 4:			/* #data */
		/* it should have been taken care of earlier */
	    default:
#ifdef DEBUG_FPE
		printf("decode_ea: invalid addr mode (7,%d)\n", modreg & 7);
#endif
		*typ = ILL_ILLADR;
		return SIGILL;
	    } /* switch for mode 7 */
	    break;
	} /* switch mode */
    }
    ea->ea_moffs = 0;

    return sig;
}

/*
 * Decode Mode=6 address modes
 */
int
decode_ea6(struct frame *frame, struct instruction *insn, struct insn_ea *ea,
    int modreg, int *typ)
{
    int idx;
    int basedisp, outerdisp;
    int bd_size, od_size;
    int sig;
    u_int16_t extword;

    if (copyin((void *)(insn->is_pc + insn->is_advance), &extword,
	sizeof(extword)) != 0) {
	return SIGSEGV;
    }
    insn->is_advance += 2;

    /* get register index */
    ea->ea_idxreg = (extword >> 12) & 0xf;
    idx = frame->f_regs[ea->ea_idxreg];
    if ((extword & 0x0800) == 0) {
	/* if word sized index, sign-extend */
	idx &= 0xffff;
	if (idx & 0x8000) {
	    idx |= 0xffff0000;
	}
    }
    /* scale register index */
    idx <<= ((extword >> 9) & 3);

    if ((extword & 0x100) == 0) {
	/* brief extension word - sign-extend the displacement */
	basedisp = (extword & 0xff);
	if (basedisp & 0x80) {
	    basedisp |= 0xffffff00;
	}

	ea->ea_basedisp = idx + basedisp;
	ea->ea_outerdisp = 0;
#if DEBUG_FPE
	printf("decode_ea6: brief ext word idxreg=%d, basedisp=%08x\n",
	       ea->ea_idxreg, ea->ea_basedisp);
#endif
    } else {
	/* full extension word */
	if (extword & 0x80) {
	    ea->ea_flags |= EA_BASE_SUPPRSS;
	}
	bd_size = ((extword >> 4) & 3) - 1;
	od_size = (extword & 3) - 1;
	sig = fetch_disp(frame, insn, bd_size, &basedisp);
	if (sig) {
	    return sig;
	}
	if (od_size >= 0) {
	    ea->ea_flags |= EA_MEM_INDIR;
	}
	sig = fetch_disp(frame, insn, od_size, &outerdisp);
	if (sig) {
	    return sig;
	}

	switch (extword & 0x44) {
	case 0:			/* preindexed */
	    ea->ea_basedisp = basedisp + idx;
	    ea->ea_outerdisp = outerdisp;
	    break;
	case 4:			/* postindexed */
	    ea->ea_basedisp = basedisp;
	    ea->ea_outerdisp = outerdisp + idx;
	    break;
	case 0x40:		/* no index */
	    ea->ea_basedisp = basedisp;
	    ea->ea_outerdisp = outerdisp;
	    break;
	default:
#ifdef DEBUG
	    printf("decode_ea6: invalid indirect mode: ext word %02x\n",
		   extword);
#endif
	    *typ = ILL_ILLADR;
	    return SIGILL;
	    break;
	}
#if DEBUG_FPE
	printf("decode_ea6: full ext idxreg=%d, basedisp=%x, outerdisp=%x\n",
	       ea->ea_idxreg, ea->ea_basedisp, ea->ea_outerdisp);
#endif
    }
#if DEBUG_FPE
    printf("decode_ea6: regnum=%d, flags=%x\n",
	   ea->ea_regnum, ea->ea_flags);
#endif
    return 0;
}

/*
 * Load a value from an effective address.
 * Returns zero on success, else signal number.
 */
int
fpu_load_ea(struct frame *frame, struct instruction *insn, struct insn_ea *ea,
    char *dst, int *typ)
{
    int *reg;
    char *src;
    int len, step;
    int sig;

#ifdef DIAGNOSTIC
    if (ea->ea_regnum & ~0xF) {
	panic("load_ea: bad regnum");
    }
#endif

#ifdef DEBUG_FPE
    printf("load_ea: frame at %p\n", frame);
#endif
    /* dst is always int or larger. */
    len = insn->is_datasize;
    if (len < 4) {
	dst += (4 - len);
    }
    step = (len == 1 && ea->ea_regnum == 15 /* sp */) ? 2 : len;

#if 0
    if (ea->ea_flags & EA_FRAME_EA) {
	/* Using LC040 frame EA */
#ifdef DEBUG_FPE
	if (ea->ea_flags & (EA_PREDECR|EA_POSTINCR)) {
	    printf("load_ea: frame ea %08x w/r%d\n",
		   ea->ea_fea, ea->ea_regnum);
	} else {
	    printf("load_ea: frame ea %08x\n", ea->ea_fea);
	}
#endif
	src = (char *)ea->ea_fea;
	if (copyin(src + ea->ea_moffs, dst, len) != 0)
	    return (SIGSEGV);
	if (ea->ea_flags & EA_PREDECR) {
	    frame->f_regs[ea->ea_regnum] = ea->ea_fea;
	    ea->ea_fea -= step;
	    ea->ea_moffs = 0;
	} else if (ea->ea_flags & EA_POSTINCR) {
	    ea->ea_fea += step;
	    frame->f_regs[ea->ea_regnum] = ea->ea_fea;
	    ea->ea_moffs = 0;
	} else {
	    ea->ea_moffs += step;
	}
	/* That's it, folks */
    } else if (ea->ea_flags & EA_DIRECT) {
	if (len > 4) {
#ifdef DEBUG
	    printf("load_ea: operand doesn't fit CPU reg\n");
#endif
	    return SIGILL;
	}
	if (ea->ea_moffs > 0) {
#ifdef DEBUG
	    printf("load_ea: more than one move from CPU reg\n");
#endif
	    return SIGILL;
	}
	src = (char *)&frame->f_regs[ea->ea_regnum];
	/* The source is an int. */
	if (len < 4) {
	    src += (4 - len);
#ifdef DEBUG_FPE
	    printf("load_ea: short/byte opr - addr adjusted\n");
#endif
	}
#ifdef DEBUG_FPE
	printf("load_ea: src %p\n", src);
#endif
	memcpy(dst, src, len);
    } else
#endif	/* 0 */
    if (ea->ea_flags & EA_IMMED) {
#ifdef DEBUG_FPE
	printf("load_ea: immed %08x%08x%08x size %d\n",
	       ea->ea_immed[0], ea->ea_immed[1], ea->ea_immed[2], len);
#endif
	src = (char *)&ea->ea_immed[0];
	if (len < 4) {
	    src += (4 - len);
#ifdef DEBUG_FPE
	    printf("load_ea: short/byte immed opr - addr adjusted\n");
#endif
	}
	memcpy(dst, src, len);
    } else if (ea->ea_flags & EA_ABS) {
#ifdef DEBUG_FPE
	printf("load_ea: abs addr %08x\n", ea->ea_absaddr);
#endif
	src = (char *)ea->ea_absaddr;
	if (copyin(src, dst, len) != 0)
	    return (SIGSEGV);
    } else /* register indirect */ { 
	if (ea->ea_flags & EA_PC_REL) {
#ifdef DEBUG_FPE
	    printf("load_ea: using PC\n");
#endif
	    reg = NULL;
	    /* Grab the register contents. 4 is offset to the first
	       extension word from the opcode */
	    src = (char *)insn->is_pc + 4;
#ifdef DEBUG_FPE
	    printf("load_ea: pc relative pc+4 = %p\n", src);
#endif
	} else /* not PC relative */ {
#ifdef DEBUG_FPE
	    printf("load_ea: using register %c%d\n",
		   (ea->ea_regnum >= 8) ? 'a' : 'd', ea->ea_regnum & 7);
#endif
	    /* point to the register */
	    reg = &frame->f_regs[ea->ea_regnum];

	    if (ea->ea_flags & EA_PREDECR) {
#ifdef DEBUG_FPE
		printf("load_ea: predecr mode - reg decremented\n");
#endif
		*reg -= step;
		ea->ea_moffs = 0;
	    }

	    /* Grab the register contents. */
	    src = (char *)*reg;
#ifdef DEBUG_FPE
	    printf("load_ea: reg indirect reg = %p\n", src);
#endif
	}

	sig = calc_ea(ea, src, &src);
	if (sig)
	    return sig;

	if (copyin(src + ea->ea_moffs, dst, len) != 0)
	    return (SIGSEGV);

	/* do post-increment */
	if (ea->ea_flags & EA_POSTINCR) {
	    if (ea->ea_flags & EA_PC_REL) {
#ifdef DEBUG
		printf("load_ea: tried to postincrement PC\n");
#endif
		*typ = ILL_ILLADR;
		return SIGILL;
	    }
	    *reg += step;
	    ea->ea_moffs = 0;
#ifdef DEBUG_FPE
	    printf("load_ea: postinc mode - reg incremented\n");
#endif
	} else {
	    ea->ea_moffs += len;
	}
    }

    return 0;
}

/*
 * Store a value at the effective address.
 * Returns zero on success, else signal number.
 */
int
fpu_store_ea(frame, insn, ea, src)
     struct frame *frame;
     struct instruction *insn;
     struct insn_ea *ea;
     char *src;
{
    int *reg;
    char *dst;
    int len, step;
    int sig;

#ifdef	DIAGNOSTIC
    if (ea->ea_regnum & ~0xf) {
	panic("store_ea: bad regnum");
    }
#endif

    if (ea->ea_flags & (EA_IMMED|EA_PC_REL)) {
	/* not alterable address mode */
#ifdef DEBUG
	printf("store_ea: not alterable address mode\n");
#endif
	return SIGILL;
    }

    /* src is always int or larger. */
    len = insn->is_datasize;
    if (len < 4) {
	src += (4 - len);
    }
    step = (len == 1 && ea->ea_regnum == 15 /* sp */) ? 2 : len;

    if (ea->ea_flags & EA_FRAME_EA) {
	/* Using LC040 frame EA */
#ifdef DEBUG_FPE
	if (ea->ea_flags & (EA_PREDECR|EA_POSTINCR)) {
	    printf("store_ea: frame ea %08x w/r%d\n",
		   ea->ea_fea, ea->ea_regnum);
	} else {
	    printf("store_ea: frame ea %08x\n", ea->ea_fea);
	}
#endif
	dst = (char *)ea->ea_fea;
	copyout(src, dst + ea->ea_moffs, len);
	if (ea->ea_flags & EA_PREDECR) {
	    frame->f_regs[ea->ea_regnum] = ea->ea_fea;
	    ea->ea_fea -= step;
	    ea->ea_moffs = 0;
	} else if (ea->ea_flags & EA_POSTINCR) {
	    ea->ea_fea += step;
	    frame->f_regs[ea->ea_regnum] = ea->ea_fea;
	    ea->ea_moffs = 0;
	} else {
	    ea->ea_moffs += step;
	}
	/* That's it, folks */
    } else if (ea->ea_flags & EA_ABS) {
#ifdef DEBUG_FPE
	printf("store_ea: abs addr %08x\n", ea->ea_absaddr);
#endif
	dst = (char *)ea->ea_absaddr;
	copyout(src, dst + ea->ea_moffs, len);
	ea->ea_moffs += len;
    } else if (ea->ea_flags & EA_DIRECT) {
	if (len > 4) {
#ifdef DEBUG
	    printf("store_ea: operand doesn't fit CPU reg\n");
#endif
	    return SIGILL;
	}
	if (ea->ea_moffs > 0) {
#ifdef DEBUG
	    printf("store_ea: more than one move to CPU reg\n");
#endif
	    return SIGILL;
	}
	dst = (char *)&frame->f_regs[ea->ea_regnum];
	/* The destination is an int. */
	if (len < 4) {
	    dst += (4 - len);
#ifdef DEBUG_FPE
	    printf("store_ea: short/byte opr - dst addr adjusted\n");
#endif
	}
#ifdef DEBUG_FPE
	printf("store_ea: dst %p\n", dst);
#endif
	memcpy(dst, src, len);
    } else /* One of MANY indirect forms... */ {
#ifdef DEBUG_FPE
	printf("store_ea: using register %c%d\n",
	       (ea->ea_regnum >= 8) ? 'a' : 'd', ea->ea_regnum & 7);
#endif
	/* point to the register */
	reg = &(frame->f_regs[ea->ea_regnum]);

	/* do pre-decrement */
	if (ea->ea_flags & EA_PREDECR) {
#ifdef DEBUG_FPE
	    printf("store_ea: predecr mode - reg decremented\n");
#endif
	    *reg -= step;
	    ea->ea_moffs = 0;
	}

	/* calculate the effective address */
	sig = calc_ea(ea, (char *)*reg, &dst);
	if (sig)
	    return sig;

#ifdef DEBUG_FPE
	printf("store_ea: dst addr=%p+%d\n", dst, ea->ea_moffs);
#endif
	copyout(src, dst + ea->ea_moffs, len);

	/* do post-increment */
	if (ea->ea_flags & EA_POSTINCR) {
	    *reg += step;
	    ea->ea_moffs = 0;
#ifdef DEBUG_FPE
	    printf("store_ea: postinc mode - reg incremented\n");
#endif
	} else {
	    ea->ea_moffs += len;
	}
    }

    return 0;
}

/*
 * fetch_immed: fetch immediate operand
 */
int
fetch_immed(frame, insn, dst)
     struct frame *frame;
     struct instruction *insn;
     int *dst;
{
	int data, ext_bytes;
	u_int16_t tmp;

	ext_bytes = insn->is_datasize;
	if (ext_bytes < 0)
		return (0);

	if (ext_bytes <= 2) {
		if (copyin((void *)(insn->is_pc + insn->is_advance), &tmp,
		    sizeof(tmp)) != 0) {
			return SIGSEGV;
		}
		if (ext_bytes == 1) {
			/* sign-extend byte to long */
			data = (char)tmp;
		} else {
			/* sign-extend word to long */
			data = (int)tmp;
		}
		insn->is_advance += 2;
		dst[0] = data;
		return (0);
	}

	/* if (ext_bytes > 2) { */
		if (copyin((void *)(insn->is_pc + insn->is_advance), &dst[0],
		    sizeof(dst[0])) != 0) {
			return SIGSEGV;
		}
		insn->is_advance += 4;
	/* } */

	if (ext_bytes > 4) {
		if (copyin((void *)(insn->is_pc + insn->is_advance), &dst[1],
		    sizeof(dst[1])) != 0) {
			return SIGSEGV;
		}
		insn->is_advance += 4;
	}

	if (ext_bytes > 8) {
		if (copyin((void *)(insn->is_pc + insn->is_advance), &dst[2],
		     sizeof(dst[2])) != 0) {
			return SIGSEGV;
		}
		insn->is_advance += 4;
	}

	return 0;
}

/*
 * fetch_disp: fetch displacement in full extension words
 */
int
fetch_disp(frame, insn, size, res)
     struct frame *frame;
     struct instruction *insn;
     int size, *res;
{
	int disp;
	u_int16_t word;

	switch (size) {
	case 1:
		if (copyin((void *)(insn->is_pc + insn->is_advance), &word,
		    sizeof(word)) != 0) {
			return SIGSEGV;
		}
		/* sign-extend */
		disp = (int)word;
		insn->is_advance += 2;
		break;
	case 2:
		if (copyin((void *)(insn->is_pc + insn->is_advance), &disp,
		    sizeof(disp)) != 0) {
			return SIGSEGV;
		}
		insn->is_advance += 4;
		break;
	default:
		disp = 0;
		break;
	}

	*res = disp;

	return 0;
}

/*
 * Calculates an effective address for all address modes except for
 * register direct, absolute, and immediate modes.  However, it does
 * not take care of predecrement/postincrement of register content.
 * Returns a signal value (0 == no error).
 */
int
calc_ea(ea, ptr, eaddr)
     struct insn_ea *ea;
     char *ptr;		/* base address (usually a register content) */
     char **eaddr;	/* pointer to result pointer */
{
    int word;

#if DEBUG_FPE
    printf("calc_ea: reg indirect (reg) = %p\n", ptr);
#endif

    if (ea->ea_flags & EA_OFFSET) {
	/* apply the signed offset */
#if DEBUG_FPE
	printf("calc_ea: offset %d\n", ea->ea_offset);
#endif
	ptr += ea->ea_offset;
    } else if (ea->ea_flags & EA_INDEXED) {
#if DEBUG_FPE
	printf("calc_ea: indexed mode\n");
#endif

	if (ea->ea_flags & EA_BASE_SUPPRSS) {
	    /* base register is suppressed */
	    ptr = (char *)ea->ea_basedisp;
	} else {
	    ptr += ea->ea_basedisp;
	}

	if (ea->ea_flags & EA_MEM_INDIR) {
#if DEBUG_FPE
	    printf("calc_ea: mem indir mode: basedisp=%08x, outerdisp=%08x\n",
		   ea->ea_basedisp, ea->ea_outerdisp);
	    printf("calc_ea: addr fetched from %p\n", ptr);
#endif
	    /* memory indirect modes */
	    if (copyin(ptr, &word, sizeof(word)) != 0) {
		return SIGSEGV;
	    }
#if DEBUG_FPE
	    printf("calc_ea: fetched ptr 0x%08x\n", word);
#endif
	    ptr = (char *)word + ea->ea_outerdisp;
	}
    }

    *eaddr = ptr;

    return 0;
}
@


1.11
log
@Better siginfo field values for fpe failures.
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu_calcea.c,v 1.10 2006/01/16 22:08:26 miod Exp $	*/
@


1.10
log
@Sync m68k fpe code with NetBSD; but remove unimplemented opcodes stubs, so
that we trigger SIGILL instead of propagating false results.

Tested by martin@@ on Macintosh LCIII.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
			   struct insn_ea *ea, int modreg);
d62 2
a63 5
fpu_decode_ea(frame, insn, ea, modreg)
     struct frame *frame;
     struct instruction *insn;
     struct insn_ea *ea;
     int modreg;
d160 1
a160 1
	    sig = decode_ea6(frame, insn, ea, modreg);
d193 1
a193 1
		sig = decode_ea6(frame, insn, ea, modreg);
d202 1
d217 2
a218 5
decode_ea6(frame, insn, ea, modreg)
     struct frame *frame;
     struct instruction *insn;
     struct insn_ea *ea;
     int modreg;
d295 1
d316 2
a317 5
fpu_load_ea(frame, insn, ea, dst)
     struct frame *frame;
     struct instruction *insn;
     struct insn_ea *ea;
     char *dst;
d392 1
a392 1
#endif
d461 1
@


1.9
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 2
a2 2
/*	$OpenBSD: fpu_calcea.c,v 1.8 2002/03/14 03:15:54 millert Exp $	*/
/*	$NetBSD: fpu_calcea.c,v 1.7 1996/10/16 06:27:05 scottr Exp $	*/
a37 1
#include <machine/cpu.h>
d43 1
a43 1
 * Prototypes of static functions
d45 1
a45 1
static int decode_ea6(struct frame *frame, struct instruction *insn,
d47 1
a47 1
static int fetch_immed(struct frame *frame, struct instruction *insn,
d49 1
a49 1
static int fetch_disp(struct frame *frame, struct instruction *insn,
d51 1
a51 1
static int calc_ea(struct insn_ea *ea, char *ptr, char **eaddr);
d81 3
a83 4
    switch (modreg & 070) {
    case 0:			/* Dn */
	ea->ea_regnum &= 7;
    case 010:			/* An */
d85 37
a121 2
	if (fpu_debug_level & DL_DECODEEA) {
	    printf("  decode_ea: register direct reg=%d\n", ea->ea_regnum);
d123 12
a134 1
	break;
d136 4
a139 11
    case 020:			/* (An) */
	ea->ea_flags = 0;
	if (fpu_debug_level & DL_DECODEEA) {
	    printf("  decode_ea: register indirect reg=%d\n", ea->ea_regnum);
	}
	break;

    case 030:			/* (An)+ */
	ea->ea_flags = EA_POSTINCR;
	if (fpu_debug_level & DL_DECODEEA) {
	    printf("  decode_ea: reg indirect postincrement reg=%d\n",
d141 2
a142 2
	}
	break;
d144 4
a147 4
    case 040:			/* -(An) */
	ea->ea_flags = EA_PREDECR;
	if (fpu_debug_level & DL_DECODEEA) {
	    printf("  decode_ea: reg indirect predecrement reg=%d\n",
d149 2
a150 2
	}
	break;
d152 5
a156 5
    case 050:			/* (d16,An) */
	ea->ea_flags = EA_OFFSET;
	sig = fetch_disp(frame, insn, 1, &ea->ea_offset);
	if (fpu_debug_level & DL_DECODEEA) {
	    printf("  decode_ea: reg indirect with displacement reg=%d\n",
d158 2
a159 2
	}
	break;
d161 3
a163 15
    case 060:			/* (d8,An,Xn) */
	ea->ea_flags = EA_INDEXED;
	sig = decode_ea6(frame, insn, ea, modreg);
	break;

    case 070:			/* misc. */
	ea->ea_regnum = (modreg & 7);
	switch (modreg & 7) {

	case 0:			/* (xxxx).W */
	    ea->ea_flags = EA_ABS;
	    sig = fetch_disp(frame, insn, 1, &ea->ea_absaddr);
	    if (fpu_debug_level & DL_DECODEEA) {
		printf("  decode_ea: absolute address (word)\n");
	    }
d166 11
a176 7
	case 1:			/* (xxxxxxxx).L */
	    ea->ea_flags = EA_ABS;
	    sig = fetch_disp(frame, insn, 2, &ea->ea_absaddr);
	    if (fpu_debug_level & DL_DECODEEA) {
		printf("  decode_ea: absolute address (long)\n");
	    }
	    break;
d178 7
a184 7
	case 2:			/* (d16,PC) */
	    ea->ea_flags = EA_PC_REL | EA_OFFSET;
	    sig = fetch_disp(frame, insn, 1, &ea->ea_absaddr);
	    if (fpu_debug_level & DL_DECODEEA) {
		printf("  decode_ea: pc relative word displacement\n");
	    }
	    break;
d186 7
a192 4
	case 3:			/* (d8,PC,Xn) */
	    ea->ea_flags = EA_PC_REL | EA_INDEXED;
	    sig = decode_ea6(frame, insn, ea, modreg);
	    break;
d194 13
a206 6
	case 4:			/* #data */
	    ea->ea_flags = EA_IMMED;
	    sig = fetch_immed(frame, insn, &ea->ea_immed[0]);
	    if (fpu_debug_level & DL_DECODEEA) {
		printf("  decode_ea: immediate size=%d\n", insn->is_datasize);
	    }
d208 3
a210 11

	default:
	    if (fpu_debug_level & DL_DECODEEA) {
		printf("  decode_ea: invalid addr mode (7,%d)\n", modreg & 7);
	    }
	    return SIGILL;
	} /* switch for mode 7 */
	break;
    } /* switch mode */

    ea->ea_tdisp = 0;
d218 1
a218 1
static int
d225 1
a225 1
    int extword, idx;
d229 1
d231 2
a232 2
    if (copyin((void *)(frame->f_pc + insn->is_advance), &extword,
	sizeof(int)) != 0) {
d248 1
a248 1
    idx <<= ((extword >>9) & 3);
d251 1
a251 1
	/* brief extention word - sign-extend the displacement */
d259 4
a262 4
	if (fpu_debug_level & DL_DECODEEA) {
	    printf("  decode_ea6: brief ext word idxreg=%d, basedisp=%08x\n",
		   ea->ea_idxreg, ea->ea_basedisp);
	}
d264 1
a264 1
	/* full extention word */
d297 1
a297 1
	    printf("  decode_ea6: invalid indirect mode: ext word %04x\n",
d303 4
a306 8
	if (fpu_debug_level & DL_DECODEEA) {
	    printf("  decode_ea6: full ext idxreg=%d, basedisp=%x, outerdisp=%x\n",
		   ea->ea_idxreg, ea->ea_basedisp, ea->ea_outerdisp);
	}
    }
    if (fpu_debug_level & DL_DECODEEA) {
	printf("  decode_ea6: regnum=%d, flags=%x\n",
	       ea->ea_regnum, ea->ea_flags);
d308 4
d331 1
a331 1
#ifdef	DIAGNOSTIC
d333 1
a333 1
	panic("  load_ea: bad regnum");
d337 4
a340 4
    if (fpu_debug_level & DL_LOADEA) {
	printf("  load_ea: frame at %p\n", frame);
    }
    /* The dst is always int or larger. */
d347 27
a373 1
    if (ea->ea_flags & EA_DIRECT) {
d376 1
a376 1
	    printf("  load_ea: operand doesn't fit cpu reg\n");
d380 1
a380 1
	if (ea->ea_tdisp > 0) {
d382 1
a382 1
	    printf("  load_ea: more than one move from cpu reg\n");
d390 3
a392 12
	    if (fpu_debug_level & DL_LOADEA) {
		printf("  load_ea: short/byte opr - addr adjusted\n");
	    }
	}
	if (fpu_debug_level & DL_LOADEA) {
	    printf("  load_ea: src %p\n", src);
	}
	bcopy(src, dst, len);
    } else if (ea->ea_flags & EA_IMMED) {
	if (fpu_debug_level & DL_LOADEA) {
	    printf("  load_ea: immed %08x%08x%08x size %d\n",
		   ea->ea_immed[0], ea->ea_immed[1], ea->ea_immed[2], len);
d394 11
d408 3
a410 3
	    if (fpu_debug_level & DL_LOADEA) {
		printf("  load_ea: short/byte immed opr - addr adjusted\n");
	    }
d412 1
a412 1
	bcopy(src, dst, len);
d414 3
a416 3
	if (fpu_debug_level & DL_LOADEA) {
	    printf("  load_ea: abs addr %08x\n", ea->ea_absaddr);
	}
d418 2
a419 1
	copyin(src, dst, len);
d422 3
a424 3
	    if (fpu_debug_level & DL_LOADEA) {
		printf("  load_ea: using PC\n");
	    }
d427 5
a431 5
	       extention word from the opcode */
	    src = (char *)frame->f_pc + 4;
	    if (fpu_debug_level & DL_LOADEA) {
		printf("  load_ea: pc relative pc+4 = %p\n", src);
	    }
d433 4
a436 4
	    if (fpu_debug_level & DL_LOADEA) {
		printf("  load_ea: using register %c%d\n",
		       (ea->ea_regnum >= 8) ? 'a' : 'd', ea->ea_regnum & 7);
	    }
d441 3
a443 3
		if (fpu_debug_level & DL_LOADEA) {
		    printf("  load_ea: predecr mode - reg decremented\n");
		}
d445 1
a445 1
		ea->ea_tdisp = 0;
d450 3
a452 3
	    if (fpu_debug_level & DL_LOADEA) {
		printf("  load_ea: reg indirect reg = %p\n", src);
	    }
d459 2
a460 1
	copyin(src + ea->ea_tdisp, dst, len);
d466 1
a466 1
		printf("  load_ea: tried to postincrement PC\n");
d471 4
a474 4
	    ea->ea_tdisp = 0;
	    if (fpu_debug_level & DL_LOADEA) {
		printf("  load_ea: postinc mode - reg incremented\n");
	    }
d476 1
a476 1
	    ea->ea_tdisp += len;
d500 2
a501 2
    if (ea->ea_regnum & ~0xF) {
	panic("  store_ea: bad regnum");
d508 1
a508 1
	printf("  store_ea: not alterable address mode\n");
d513 1
a513 4
    if (fpu_debug_level & DL_STOREEA) {
	printf("  store_ea: frame at %p\n", frame);
    }
    /* The src is always int or larger. */
d520 22
a541 3
    if (ea->ea_flags & EA_ABS) {
	if (fpu_debug_level & DL_STOREEA) {
	    printf("  store_ea: abs addr %08x\n", ea->ea_absaddr);
d543 5
d549 2
a550 2
	copyout(src, dst + ea->ea_tdisp, len);
	ea->ea_tdisp += len;
d554 1
a554 1
	    printf("  store_ea: operand doesn't fit cpu reg\n");
d558 1
a558 1
	if (ea->ea_tdisp > 0) {
d560 1
a560 1
	    printf("  store_ea: more than one move to cpu reg\n");
d568 3
a570 3
	    if (fpu_debug_level & DL_STOREEA) {
		printf("  store_ea: short/byte opr - dst addr adjusted\n");
	    }
d572 4
a575 4
	if (fpu_debug_level & DL_STOREEA) {
	    printf("  store_ea: dst %p\n", dst);
	}
	bcopy(src, dst, len);
d577 4
a580 4
	if (fpu_debug_level & DL_STOREEA) {
	    printf("  store_ea: using register %c%d\n",
		   (ea->ea_regnum >= 8) ? 'a' : 'd', ea->ea_regnum & 7);
	}
d586 3
a588 3
	    if (fpu_debug_level & DL_STOREEA) {
		printf("  store_ea: predecr mode - reg decremented\n");
	    }
d590 1
a590 1
	    ea->ea_tdisp = 0;
d598 4
a601 4
	if (fpu_debug_level & DL_STOREEA) {
	    printf("  store_ea: dst addr=%p+%d\n", dst, ea->ea_tdisp);
	}
	copyout(src, dst + ea->ea_tdisp, len);
d606 4
a609 4
	    ea->ea_tdisp = 0;
	    if (fpu_debug_level & DL_STOREEA) {
		printf("  store_ea: postinc mode - reg incremented\n");
	    }
d611 1
a611 1
	    ea->ea_tdisp += len;
d621 1
a621 1
static int
d627 23
a649 1
    int data, ext_bytes;
d651 7
a657 1
    ext_bytes = insn->is_datasize;
d659 6
a664 17
    if (0 < ext_bytes) {
	if (copyin((void *)(frame->f_pc + insn->is_advance), &data,
	  sizeof(int)) != 0) {
	    return SIGSEGV;
	}
	if (ext_bytes == 1) {
	    /* sign-extend byte to long */
	    data &= 0xff;
	    if (data & 0x80) {
		data |= 0xffffff00;
	    }
	} else if (ext_bytes == 2) {
	    /* sign-extend word to long */
	    data &= 0xffff;
	    if (data & 0x8000) {
		data |= 0xffff0000;
	    }
d666 7
a672 34
	insn->is_advance += 2;
	dst[0] = data;
    }
    if (2 < ext_bytes) {
	if (copyin((void *)(frame->f_pc + insn->is_advance), &data,
	  sizeof(int)) != 0) {
	    return SIGSEGV;
	}
	insn->is_advance += 2;
	dst[0] <<= 16;
	dst[0] |= data;
    }
    if (4 < ext_bytes) {
	if (copyin((void *)(frame->f_pc + insn->is_advance), &data,
	  sizeof(int)) != 0) {
	    return SIGSEGV;
	}
	dst[1] = data << 16;
	if (copyin((void *)(frame->f_pc + insn->is_advance + 2), &data,
	  sizeof(int)) != 0) {
	    return SIGSEGV;
	}
	insn->is_advance += 4;
	dst[1] |= data;
    }
    if (8 < ext_bytes) {
	if (copyin((void *)(frame->f_pc + insn->is_advance), &data,
	  sizeof(int)) != 0) {
	    return SIGSEGV;
	}
	dst[2] = data << 16;
	if (copyin((void *)(frame->f_pc + insn->is_advance + 2), &data,
	  sizeof(int)) != 0) {
	    return SIGSEGV;
a673 3
	insn->is_advance += 4;
	dst[2] |= data;
    }
d675 1
a675 1
    return 0;
d679 1
a679 1
 * fetch_disp: fetch displacement in full extention words
d681 1
a681 1
static int
d687 2
a688 1
    int disp, word;
d690 20
a709 20
    if (size == 1) {
	if (copyin((void *)(frame->f_pc + insn->is_advance), &word,
	  sizeof(int)) != 0) {
	    return SIGSEGV;
	}
	disp = word & 0xffff;
	if (disp & 0x8000) {
	    /* sign-extend */
	    disp |= 0xffff0000;
	}
	insn->is_advance += 2;
    } else if (size == 2) {
	if (copyin((void *)(frame->f_pc + insn->is_advance), &word,
	  sizeof(int)) != 0) {
	    return SIGSEGV;
	}
	disp = word << 16;
	if (copyin((void *)(frame->f_pc + insn->is_advance + 2), &word,
	  sizeof(int)) != 0) {
	    return SIGSEGV;
d711 4
a714 7
	disp |= (word & 0xffff);
	insn->is_advance += 4;
    } else {
	disp = 0;
    }
    *res = disp;
    return 0;
d723 1
a723 1
static int
d729 1
a729 1
    int data, word;
d731 3
a733 3
    if (fpu_debug_level & DL_EA) {
	printf("  calc_ea: reg indirect (reg) = %p\n", ptr);
    }
d737 3
a739 3
	if (fpu_debug_level & DL_EA) {
	    printf("  calc_ea: offset %d\n", ea->ea_offset);
	}
d742 3
a744 3
	if (fpu_debug_level & DL_EA) {
	    printf("  calc_ea: indexed mode\n");
	}
d754 5
a758 5
	    if (fpu_debug_level & DL_EA) {
		printf("  calc_ea: mem indir mode: basedisp=%08x, outerdisp=%08x\n",
		       ea->ea_basedisp, ea->ea_outerdisp);
		printf("  calc_ea: addr fetched from %p\n", ptr);
	    }
d760 1
a760 1
	    if (copyin(ptr, &word, sizeof(int)) != 0) {
d763 3
a765 8
	    word <<= 16;
	    if (copyin(ptr + 2, &data, sizeof(int)) != 0) {
		return SIGSEGV;
	    }
	    word |= data;
	    if (fpu_debug_level & DL_STOREEA) {
		printf(" calc_ea: fetched ptr 0x%08x\n", word);
	    }
@


1.8
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu_calcea.c,v 1.7 2002/03/14 01:26:34 millert Exp $	*/
d199 2
a200 2
    extword = fusword((void *) (frame->f_pc + insn->is_advance));
    if (extword < 0) {
d549 2
a550 2
	data = fusword((void *) (frame->f_pc + insn->is_advance));
	if (data < 0) {
d570 2
a571 2
	data = fusword((void *) (frame->f_pc + insn->is_advance));
	if (data < 0) {
d579 2
a580 2
	data = fusword((void *) (frame->f_pc + insn->is_advance));
	if (data < 0) {
d584 2
a585 2
	data = fusword((void *) (frame->f_pc + insn->is_advance + 2));
	if (data < 0) {
d592 2
a593 2
	data = fusword((void *) (frame->f_pc + insn->is_advance));
	if (data < 0) {
d597 2
a598 2
	data = fusword((void *) (frame->f_pc + insn->is_advance + 2));
	if (data < 0) {
d620 2
a621 2
	word = fusword((void *) (frame->f_pc + insn->is_advance));
	if (word < 0) {
d631 2
a632 2
	word = fusword((void *) (frame->f_pc + insn->is_advance));
	if (word < 0) {
d636 2
a637 2
	word = fusword((void *) (frame->f_pc + insn->is_advance + 2));
	if (word < 0) {
d692 1
a692 2
	    word = fusword(ptr);
	    if (word < 0) {
d696 1
a696 2
	    data = fusword(ptr + 2);
	    if (data < 0) {
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu_calcea.c,v 1.6 1999/01/11 05:11:33 millert Exp $	*/
d481 1
a481 1
	dst = (char*)&frame->f_regs[ea->ea_regnum];
@


1.6
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu_calcea.c,v 1.5 1997/02/13 21:49:15 kstailey Exp $	*/
d46 7
a52 7
static int decode_ea6 __P((struct frame *frame, struct instruction *insn,
			   struct insn_ea *ea, int modreg));
static int fetch_immed __P((struct frame *frame, struct instruction *insn,
			    int *dst));
static int fetch_disp __P((struct frame *frame, struct instruction *insn,
			   int size, int *res));
static int calc_ea __P((struct insn_ea *ea, char *ptr, char **eaddr));
@


1.6.16.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu_calcea.c,v 1.6 1999/01/11 05:11:33 millert Exp $	*/
d46 7
a52 7
static int decode_ea6(struct frame *frame, struct instruction *insn,
			   struct insn_ea *ea, int modreg);
static int fetch_immed(struct frame *frame, struct instruction *insn,
			    int *dst);
static int fetch_disp(struct frame *frame, struct instruction *insn,
			   int size, int *res);
static int calc_ea(struct insn_ea *ea, char *ptr, char **eaddr);
d481 1
a481 1
	dst = (char *)&frame->f_regs[ea->ea_regnum];
@


1.6.16.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d199 2
a200 2
    if (copyin((void *)(frame->f_pc + insn->is_advance), &extword,
	sizeof(int)) != 0) {
d549 2
a550 2
	if (copyin((void *)(frame->f_pc + insn->is_advance), &data,
	  sizeof(int)) != 0) {
d570 2
a571 2
	if (copyin((void *)(frame->f_pc + insn->is_advance), &data,
	  sizeof(int)) != 0) {
d579 2
a580 2
	if (copyin((void *)(frame->f_pc + insn->is_advance), &data,
	  sizeof(int)) != 0) {
d584 2
a585 2
	if (copyin((void *)(frame->f_pc + insn->is_advance + 2), &data,
	  sizeof(int)) != 0) {
d592 2
a593 2
	if (copyin((void *)(frame->f_pc + insn->is_advance), &data,
	  sizeof(int)) != 0) {
d597 2
a598 2
	if (copyin((void *)(frame->f_pc + insn->is_advance + 2), &data,
	  sizeof(int)) != 0) {
d620 2
a621 2
	if (copyin((void *)(frame->f_pc + insn->is_advance), &word,
	  sizeof(int)) != 0) {
d631 2
a632 2
	if (copyin((void *)(frame->f_pc + insn->is_advance), &word,
	  sizeof(int)) != 0) {
d636 2
a637 2
	if (copyin((void *)(frame->f_pc + insn->is_advance + 2), &word,
	  sizeof(int)) != 0) {
d692 2
a693 1
	    if (copyin(ptr, &word, sizeof(int)) != 0) {
d697 2
a698 1
	    if (copyin(ptr + 2, &data, sizeof(int)) != 0) {
@


1.6.6.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 7
a52 7
static int decode_ea6(struct frame *frame, struct instruction *insn,
			   struct insn_ea *ea, int modreg);
static int fetch_immed(struct frame *frame, struct instruction *insn,
			    int *dst);
static int fetch_disp(struct frame *frame, struct instruction *insn,
			   int size, int *res);
static int calc_ea(struct insn_ea *ea, char *ptr, char **eaddr);
d481 1
a481 1
	dst = (char *)&frame->f_regs[ea->ea_regnum];
@


1.6.6.2
log
@Sync the SMP branch with 3.3
@
text
@d199 2
a200 2
    if (copyin((void *)(frame->f_pc + insn->is_advance), &extword,
	sizeof(int)) != 0) {
d549 2
a550 2
	if (copyin((void *)(frame->f_pc + insn->is_advance), &data,
	  sizeof(int)) != 0) {
d570 2
a571 2
	if (copyin((void *)(frame->f_pc + insn->is_advance), &data,
	  sizeof(int)) != 0) {
d579 2
a580 2
	if (copyin((void *)(frame->f_pc + insn->is_advance), &data,
	  sizeof(int)) != 0) {
d584 2
a585 2
	if (copyin((void *)(frame->f_pc + insn->is_advance + 2), &data,
	  sizeof(int)) != 0) {
d592 2
a593 2
	if (copyin((void *)(frame->f_pc + insn->is_advance), &data,
	  sizeof(int)) != 0) {
d597 2
a598 2
	if (copyin((void *)(frame->f_pc + insn->is_advance + 2), &data,
	  sizeof(int)) != 0) {
d620 2
a621 2
	if (copyin((void *)(frame->f_pc + insn->is_advance), &word,
	  sizeof(int)) != 0) {
d631 2
a632 2
	if (copyin((void *)(frame->f_pc + insn->is_advance), &word,
	  sizeof(int)) != 0) {
d636 2
a637 2
	if (copyin((void *)(frame->f_pc + insn->is_advance + 2), &word,
	  sizeof(int)) != 0) {
d692 2
a693 1
	    if (copyin(ptr, &word, sizeof(int)) != 0) {
d697 2
a698 1
	    if (copyin(ptr + 2, &data, sizeof(int)) != 0) {
@


1.5
log
@add #include <machine/cpu.h> for prototype of fusword()
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu_calcea.c,v 1.4 1997/01/13 11:51:03 niklas Exp $	*/
d73 1
a73 1
	panic("decode_ea: called with uninitialized datasize\n");
@


1.4
log
@Sync to 970110 NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: fpu_calcea.c,v 1.2 1996/02/27 11:03:17 niklas Exp $	*/
d38 1
@


1.3
log
@From NetBSD:
Update for -Wall -Wstrict-prototypes -Wmissing-prototypes -Wno-uninitialized.
Bring back Step9 and fix an oversight from Ken Nakata <kenn@@remus.rutgers.edu>
@
text
@d2 1
a2 1
/*	$NetBSD: fpu_calcea.c,v 1.4 1996/04/30 11:52:11 briggs Exp $	*/
a51 2

int fusword __P((void *));
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: fpu_calcea.c,v 1.3 1996/02/04 02:17:38 briggs Exp $	*/
d37 1
d53 2
d70 1
a70 1
    int data, sig;
d195 1
a195 1
    int word, extword, idx;
d200 1
a200 1
    extword = fusword(frame->f_pc + insn->is_advance);
d298 1
a298 1
    int data, word, sig;
d307 1
a307 1
	printf("  load_ea: frame at %08x\n", frame);
d338 1
a338 1
	    printf("  load_ea: src 0x%08x\n", src);
d370 1
a370 1
		printf("  load_ea: pc relative pc+4 = 0x%08x\n", src);
d391 1
a391 1
		printf("  load_ea: reg indirect reg = 0x%08x\n", src);
d436 1
a436 1
    int data, word, sig;
d453 1
a453 1
	printf("  store_ea: frame at %08x\n", frame);
d491 1
a491 1
	    printf("  store_ea: dst 0x%08x\n", dst);
d517 1
a517 1
	    printf("  store_ea: dst addr=0x%08x+%d\n", dst, ea->ea_tdisp);
d550 1
a550 1
	data = fusword(frame->f_pc + insn->is_advance);
d571 1
a571 1
	data = fusword(frame->f_pc + insn->is_advance);
d580 1
a580 1
	data = fusword(frame->f_pc + insn->is_advance);
d585 1
a585 1
	data = fusword(frame->f_pc + insn->is_advance + 2);
d593 1
a593 1
	data = fusword(frame->f_pc + insn->is_advance);
d598 1
a598 1
	data = fusword(frame->f_pc + insn->is_advance + 2);
d621 1
a621 1
	word = fusword(frame->f_pc + insn->is_advance);
d632 1
a632 1
	word = fusword(frame->f_pc + insn->is_advance);
d637 1
a637 1
	word = fusword(frame->f_pc + insn->is_advance + 2);
d662 1
a662 1
    int data, word, sig;
d665 1
a665 1
	printf("  calc_ea: reg indirect (reg) = 0x%08x\n", ptr);
d690 1
a690 1
		printf("  calc_ea: addr fetched from 0x%08x\n", ptr);
@


1.1
log
@from netbsd:
Still incomplete, but much more complete FPE from Ken Nakata
<kenn@@remus.rutgers.edu>.  This emulator does not yet emulate
the following functions:
        FSINH, FETOXM1, FTANH, FATAN, FASIN, FATANH, FSIN, FTAN,
        FETOX, FTWOTOX, FTENTOX, FCOSH, FACOS, FCOS, FSINCOS
It is sufficient, however, to allow programs like df, w, and newfs,
to run to completion with correct results.
Portions of this code were based on the sparc fpe and on initial
work by gwr.
@
text
@d1 2
a2 1
/*	$NetBSD: fpu_calcea.c,v 1.2 1995/11/05 00:35:15 briggs Exp $	*/
d35 1
a35 2
#include <stddef.h>
#include <sys/types.h>
@
