head	1.7;
access;
symbols
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.36
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.34
	OPENBSD_5_0:1.5.0.32
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.30
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.28
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.24
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.26
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.22
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.20
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.18
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.16
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.12
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.10
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.8
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.4.0.4
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.18
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.12
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.7
date	2014.03.18.22.36.33;	author miod;	state dead;
branches;
next	1.6;

1.6
date	2013.02.02.13.32.05;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.27.16.16.27;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.20.17.02.30;	author mpech;	state Exp;
branches;
next	1.3;

1.3
date	97.07.06.07.46.21;	author downsj;	state Exp;
branches
	1.3.12.1;
next	1.2;

1.2
date	96.05.29.21.05.32;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.56;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.56;	author deraadt;	state Exp;
branches;
next	;

1.3.12.1
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.3.12.2;

1.3.12.2
date	2004.02.19.10.49.01;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@*	$OpenBSD: netbsd.sa,v 1.6 2013/02/02 13:32:05 miod Exp $
*	$NetBSD: netbsd.sa,v 1.3 1997/04/25 02:26:04 thorpej Exp $

*	MOTOROLA MICROPROCESSOR & MEMORY TECHNOLOGY GROUP
*	M68000 Hi-Performance Microprocessor Division
*	M68040 Software Package 
*
*	M68040 Software Package Copyright (c) 1993, 1994 Motorola Inc.
*	All rights reserved.
*
*	THE SOFTWARE is provided on an "AS IS" basis and without warranty.
*	To the maximum extent permitted by applicable law,
*	MOTOROLA DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED,
*	INCLUDING IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
*	PARTICULAR PURPOSE and any warranty against infringement with
*	regard to the SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF)
*	and any accompanying written materials. 
*
*	To the maximum extent permitted by applicable law,
*	IN NO EVENT SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER
*	(INCLUDING WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS
*	PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR
*	OTHER PECUNIARY LOSS) ARISING OF THE USE OR INABILITY TO USE THE
*	SOFTWARE.  Motorola assumes no responsibility for the maintenance
*	and support of the SOFTWARE.  
*
*	You are hereby granted a copyright license to use, modify, and
*	distribute the SOFTWARE so long as this entire notice is retained
*	without alteration in any modified and/or redistributed versions,
*	and that such modified versions are clearly identified as such.
*	No licenses are granted by implication, estoppel or otherwise
*	under any patents or trademarks of Motorola, Inc.

*
*	skeleton.sa 3.2 4/26/91
*
*	This file contains code that is system dependent and will
*	need to be modified to install the FPSP.
*
*	Each entry point for exception 'xxxx' begins with a 'jmp fpsp_xxxx'.
*	Put any target system specific handling that must be done immediately
*	before the jump instruction.  If there no handling necessary, then
*	the 'fpsp_xxxx' handler entry point should be placed in the exception
*	table so that the 'jmp' can be eliminated. If the FPSP determines that the
*	exception is one that must be reported then there will be a
*	return from the package by a 'jmp real_xxxx'.  At that point
*	the machine state will be identical to the state before
*	the FPSP was entered.  In particular, whatever condition
*	that caused the exception will still be pending when the FPSP
*	package returns.  Thus, there will be system specific code
*	to handle the exception.
*
*	If the exception was completely handled by the package, then
*	the return will be via a 'jmp fpsp_done'.  Unless there is 
*	OS specific work to be done (such as handling a context switch or
*	interrupt) the user program can be resumed via 'rte'.
*
*	In the following skeleton code, some typical 'real_xxxx' handling
*	code is shown.  This code may need to be moved to an appropriate
*	place in the target system, or rewritten.
*	

SKELETON	IDNT    2,1 Motorola 040 Floating Point Software Package

	section 15
*
*	The following counters are used for standalone testing
*

	section 8

	include	fpsp.h

*
* XXX Note, this is NOT valid Motorola syntax, but what else can we do?
*
#include <machine/asm.h>

	xref	b1238_fix

*
*	Divide by Zero exception
*
*	All dz exceptions are 'real', hence no fpsp_dz entry point.
*
	xdef	dz
dz:
	link		a6,#-LOCAL_SIZE
	fsave		-(sp)
	bclr.b		#E1,E_BYTE(a6)
	frestore	(sp)+
	unlk		a6
	jmp		_C_LABEL(fpfault)

*
*	Inexact exception
*
*	All inexact exceptions are real, but the 'real' handler
*	will probably want to clear the pending exception.
*	The provided code will clear the E3 exception (if pending), 
*	otherwise clear the E1 exception.  The frestore is not really
*	necessary for E1 exceptions.
*
* Code following the 'inex' label is to handle bug #1232.  In this
* bug, if an E1 snan, ovfl, or unfl occurred, and the process was
* swapped out before taking the exception, the exception taken on
* return was inex, rather than the correct exception.  The snan, ovfl,
* and unfl exception to be taken must not have been enabled.  The
* fix is to check for E1, and the existence of one of snan, ovfl,
* or unfl bits set in the fpsr.  If any of these are set, branch
* to the appropriate  handler for the exception in the fpsr.  Note
* that this fix is only for d43b parts, and is skipped if the
* version number is not $40.
* 
*
	xdef	real_inex
	xdef	inex
inex:
	link		a6,#-LOCAL_SIZE
	fsave		-(sp)
	cmpi.b		#VER_40,(sp)		;test version number
	bne.b		not_fmt40
	fmove.l		fpsr,-(sp)
	btst.b		#E1,E_BYTE(a6)		;test for E1 set
	beq.b		not_b1232
	btst.b		#snan_bit,2(sp) ;test for snan
	beq		inex_ckofl
	addq.l		#4,sp
	frestore	(sp)+
	unlk		a6
	bra.l		fpsp_snan
inex_ckofl:
	btst.b		#ovfl_bit,2(sp) ;test for ovfl
	beq		inex_ckufl 
	addq.l		#4,sp
	frestore	(sp)+
	unlk		a6
	bra.l		fpsp_ovfl
inex_ckufl:
	btst.b		#unfl_bit,2(sp) ;test for unfl
	beq		not_b1232
	addq.l		#4,sp
	frestore	(sp)+
	unlk		a6
	bra.l		fpsp_unfl

*
* We do not have the bug 1232 case.  Clean up the stack and call
* real_inex.
*
not_b1232:
	addq.l		#4,sp
	frestore	(sp)+
	unlk		a6

real_inex:
	link		a6,#-LOCAL_SIZE
	fsave		-(sp)
not_fmt40:
	bclr.b		#E3,E_BYTE(a6)		;clear and test E3 flag
	beq.b		inex_cke1
*
* Clear dirty bit on dest resister in the frame before branching
* to b1238_fix.
*
	movem.l		d0/d1,USER_DA(a6)
	bfextu		CMDREG1B(a6){6:3},d0		;get dest reg no
	bclr.b		d0,FPR_DIRTY_BITS(a6)	;clr dest dirty bit
	bsr.l		b1238_fix		;test for bug1238 case
	movem.l		USER_DA(a6),d0/d1
	bra.b		inex_done
inex_cke1:
	bclr.b		#E1,E_BYTE(a6)
inex_done:
	frestore	(sp)+
	unlk		a6
	jmp		_C_LABEL(fpfault)
	
*
*	Overflow exception
*
	xdef	real_ovfl
real_ovfl:
	link		a6,#-LOCAL_SIZE
	fsave		-(sp)
	bclr.b		#E3,E_BYTE(a6)		;clear and test E3 flag
	bne.b		ovfl_done
	bclr.b		#E1,E_BYTE(a6)
ovfl_done:
	frestore	(sp)+
	unlk		a6
	jmp		_C_LABEL(fpfault)
	
*
*	Underflow exception
*
	xdef	real_unfl
real_unfl:
	link		a6,#-LOCAL_SIZE
	fsave		-(sp)
	bclr.b		#E3,E_BYTE(a6)		;clear and test E3 flag
	bne.b		unfl_done
	bclr.b		#E1,E_BYTE(a6)
unfl_done:
	frestore	(sp)+
	unlk		a6
	jmp		_C_LABEL(fpfault)
	
*
*	Signalling NAN exception
*
	xdef	real_snan
real_snan:
	link		a6,#-LOCAL_SIZE
	fsave		-(sp)
	bclr.b		#E1,E_BYTE(a6)	;snan is always an E1 exception
	frestore	(sp)+
	unlk		a6
	jmp		_C_LABEL(fpfault)
	
*
*	Operand Error exception
*
	xdef	real_operr
real_operr:
	link		a6,#-LOCAL_SIZE
	fsave		-(sp)
	bclr.b		#E1,E_BYTE(a6)	;operr is always an E1 exception
	frestore	(sp)+
	unlk		a6
	jmp		_C_LABEL(fpfault)
	
*
*	BSUN exception
*
*	This sample handler simply clears the nan bit in the FPSR.
*
	xdef	real_bsun
real_bsun:
	link		a6,#-LOCAL_SIZE
	fsave		-(sp)
	bclr.b		#E1,E_BYTE(a6)	;bsun is always an E1 exception
	fmove.l		FPSR,-(sp)
	bclr.b		#nan_bit,(sp)
	fmove.l		(sp)+,FPSR
	frestore	(sp)+
	unlk		a6
	jmp		_C_LABEL(fpfault)

*
*	F-line exception
*
*	A 'real' F-line exception is one that the FPSP isn't supposed to 
*	handle. E.g. an instruction with a co-processor ID that is not 1.
*
*
	xdef	real_fline
real_fline:
	jmp		_C_LABEL(fpfault)

*
*	Unsupported data type exception
*
	xdef	real_unsupp
real_unsupp:
	link		a6,#-LOCAL_SIZE
	fsave		-(sp)
	bclr.b		#E1,E_BYTE(a6)	;unsupp is always an E1 exception
	frestore	(sp)+
	unlk		a6
	jmp		_C_LABEL(fpfault)

*
*	Trace exception
*
	xdef	real_trace
real_trace:
	rte

*
*	fpsp_fmt_error --- exit point for frame format error
*
*	The fpu stack frame does not match the frames existing
*	or planned at the time of this writing.  The fpsp is
*	unable to handle frame sizes not in the following
*	version:size pairs:
*
*	{4060, 4160} - busy frame
*	{4028, 4130} - unimp frame
*	{4000, 4100} - idle frame
*
*	This entry point simply holds an f-line illegal value.  
*	Replace this with a call to your kernel panic code or
*	code to handle future revisions of the fpu.
*
	xdef	fpsp_fmt_error
fpsp_fmt_error:
	pea		1f
	jsr		_C_LABEL(panic)
	dc.l		$f27f0000	;f-line illegal
1:
	.asciz		"bad floating point stack frame"
	.even

*
*	fpsp_done --- FPSP exit point
*
*	The exception has been handled by the package and we are ready
*	to return to user mode, but there may be OS specific code
*	to execute before we do.  If there is, do it now.
*
*
	xref	_ASM_LABEL(rei)
	xdef	fpsp_done
fpsp_done:
	jmp		_ASM_LABEL(rei)

*
*	mem_write --- write to user or supervisor address space
*
* Writes to memory while in supervisor mode.  copyout accomplishes
* this via a 'moves' instruction.  copyout is a UNIX SVR3 (and later) function.
* If you don't have copyout, use the local copy of the function below.
*
*	a0 - supervisor source address
*	a1 - user destination address
*	d0 - number of bytes to write (maximum count is 12)
*
* The supervisor source address is guaranteed to point into the supervisor
* stack.  The result is that a UNIX
* process is allowed to sleep as a consequence of a page fault during
* copyout.  The probability of a page fault is exceedingly small because
* the 68040 always reads the destination address and thus the page
* faults should have already been handled.
*
* If the EXC_SR shows that the exception was from supervisor space,
* then just do a dumb (and slow) memory move.  In a UNIX environment
* there shouldn't be any supervisor mode floating point exceptions.
*
	xdef	mem_write
mem_write:
	btst.b	#5,EXC_SR(a6)	;check for supervisor state
	beq.b	user_write
super_write:
	move.b	(a0)+,(a1)+
	subq.l	#1,d0
	bne.b	super_write
	rts
user_write:
	move.l	d1,-(sp)	;preserve d1 just in case
	move.l	d0,-(sp)
	move.l	a1,-(sp)
	move.l	a0,-(sp)
	jsr	_C_LABEL(copyout)
	add.l	#12,sp
	move.l	(sp)+,d1
	rts

*
*	mem_read --- read from user or supervisor address space
*
* Reads from memory while in supervisor mode.  copyin accomplishes
* this via a 'moves' instruction.  copyin is a UNIX SVR3 (and later) function.
* If you don't have copyin, use the local copy of the function below.
*
* The FPSP calls mem_read to read the original F-line instruction in order
* to extract the data register number when the 'Dn' addressing mode is
* used.
*
*Input:
*	a0 - user source address
*	a1 - supervisor destination address
*	d0 - number of bytes to read (maximum count is 12)
*
* Like mem_write, mem_read always reads with a supervisor 
* destination address on the supervisor stack.  Also like mem_write,
* the EXC_SR is checked and a simple memory copy is done if reading
* from supervisor space is indicated.
*
	xdef	mem_read
mem_read:
	btst.b	#5,EXC_SR(a6)	;check for supervisor state
	beq.b	user_read
super_read:
	move.b	(a0)+,(a1)+
	subq.l	#1,d0
	bne.b	super_read
	rts
user_read:
	move.l	d1,-(sp)	;preserve d1 just in case
	move.l	d0,-(sp)
	move.l	a1,-(sp)
	move.l	a0,-(sp)
	jsr	_C_LABEL(copyin)
	add.l	#12,sp
	move.l	(sp)+,d1
	rts

	end
@


1.6
log
@Kernel bits for m68k/ELF, mostly from NetBSD. In addition, the `pmod' symbel
in fpsp has to be renamed due to a clash with other parts of the kernel.
@
text
@d1 1
a1 1
*	$OpenBSD: netbsd.sa,v 1.5 2004/01/27 16:16:27 miod Exp $
@


1.5
log
@Only install the fpsp exception vectors if the cpu is a 68040.
Thus, it becomes unnecessary to check for the cpu type in the exception
handlers, saving a few cycles and a few bytes.

Tested by various people on hp300, mac68k, mvme68k, 68040 and non-68040.
@
text
@d1 1
a1 1
*	$OpenBSD: netbsd.sa,v 1.4 2001/09/20 17:02:30 mpech Exp $
d77 1
a77 1
#include "../include/asm.h"
d131 1
a131 1
	bra		fpsp_snan
d138 1
a138 1
	bra		fpsp_ovfl
d145 1
a145 1
	bra		fpsp_unfl
@


1.4
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
*	$OpenBSD: netbsd.sa,v 1.3 1997/07/06 07:46:21 downsj Exp $
a79 1
	xref	_C_LABEL(mmutype)
a86 1
	xdef	real_dz
a87 3
	cmp.l		#-2,_C_LABEL(mmutype)
	bne.l		_C_LABEL(fpfault)
real_dz:
a118 2
	cmp.l		#-2,_C_LABEL(mmutype)
	bne.l		_C_LABEL(fpfault)
d131 1
a131 1
	bra		snan
d138 1
a138 1
	bra		ovfl
d145 1
a145 1
	bra		unfl
a181 1
	xref	fpsp_ovfl
a182 5
	xdef	ovfl
ovfl:
	cmp.l		#-2,_C_LABEL(mmutype)
	beq.l		fpsp_ovfl
	jmp		_C_LABEL(fpfault)
a196 1
	xref	fpsp_unfl
a197 5
	xdef	unfl
unfl:
	cmp.l		#-2,_C_LABEL(mmutype)
	beq.l		fpsp_unfl
	jmp		_C_LABEL(fpfault)
a211 1
	xref	fpsp_snan
a212 5
	xdef	snan
snan:
	cmp.l		#-2,_C_LABEL(mmutype)
	beq.l		fpsp_snan
	jmp		_C_LABEL(fpfault)
a223 1
	xref	fpsp_operr
a224 5
	xdef	operr
operr:
	cmp.l		#-2,_C_LABEL(mmutype)
	beq.l		fpsp_operr
	jmp		_C_LABEL(fpfault)
a237 1
	xref	fpsp_bsun
a238 5
	xdef	bsun
bsun:
	cmp.l		#-2,_C_LABEL(mmutype)
	beq.l		fpsp_bsun
	jmp		_C_LABEL(fpfault)
a256 1
	xref	fpsp_fline
a257 5
	xdef	fline
fline:
	cmp.l		#-2,_C_LABEL(mmutype)
	beq.l		fpsp_fline
	jmp		_C_LABEL(fpfault)
a263 1
	xref	fpsp_unsupp
a264 5
	xdef	unsupp
unsupp:
	cmp.l		#-2,_C_LABEL(mmutype)
	beq.l		fpsp_unsupp
	jmp		_C_LABEL(fpfault)
@


1.3
log
@Sync with NetBSD changes, 970415 - 970705.

This includes a new asm.h, as well as even more code abstracted from hp300.
These changes are likely to break ports that don't know about them; hp300
runs at the moment.
@
text
@d1 1
a1 1
*	$OpenBSD: netbsd.sa,v 1.2 1996/05/29 21:05:32 niklas Exp $
d110 1
a110 1
* bug, if an E1 snan, ovfl, or unfl occured, and the process was
@


1.3.12.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
*	$OpenBSD: netbsd.sa,v 1.3 1997/07/06 07:46:21 downsj Exp $
d110 1
a110 1
* bug, if an E1 snan, ovfl, or unfl occurred, and the process was
@


1.3.12.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
*	$OpenBSD$
d80 1
d88 1
d90 3
d124 2
d138 1
a138 1
	bra		fpsp_snan
d145 1
a145 1
	bra		fpsp_ovfl
d152 1
a152 1
	bra		fpsp_unfl
d189 1
d191 5
d210 1
d212 5
d231 1
d233 5
d249 1
d251 5
d269 1
d271 5
d294 1
d296 5
d307 1
d309 5
@


1.2
log
@$OpenBSD$ additions
@
text
@d1 2
a2 2
*	$OpenBSD: netbsd.sa,v 1.2 1994/10/26 07:49:19 cgd Exp $
*	$NetBSD: netbsd.sa,v 1.2 1994/10/26 07:49:19 cgd Exp $
d74 5
d80 1
a80 1
	xref	_mmutype
d90 2
a91 2
	cmp.l		#-2,_mmutype
	bne.l		_fpfault
d98 1
a98 1
	jmp		_fpfault
d124 2
a125 2
	cmp.l		#-2,_mmutype
	bne.l		_fpfault
d184 1
a184 1
	jmp		_fpfault
d193 1
a193 1
	cmp.l		#-2,_mmutype
d195 1
a195 1
	jmp		_fpfault
d205 1
a205 1
	jmp		_fpfault
d214 1
a214 1
	cmp.l		#-2,_mmutype
d216 1
a216 1
	jmp		_fpfault
d226 1
a226 1
	jmp		_fpfault
d235 1
a235 1
	cmp.l		#-2,_mmutype
d237 1
a237 1
	jmp		_fpfault
d244 1
a244 1
	jmp		_fpfault
d253 1
a253 1
	cmp.l		#-2,_mmutype
d255 1
a255 1
	jmp		_fpfault
d262 1
a262 1
	jmp		_fpfault
d273 1
a273 1
	cmp.l		#-2,_mmutype
d275 1
a275 1
	jmp		_fpfault
d285 1
a285 1
	jmp		_fpfault
d298 1
a298 1
	cmp.l		#-2,_mmutype
d300 1
a300 1
	jmp		_fpfault
d302 1
a302 1
	jmp		_fpfault
d311 1
a311 1
	cmp.l		#-2,_mmutype
d313 1
a313 1
	jmp		_fpfault
d320 1
a320 1
	jmp		_fpfault
d348 1
a348 1
	jsr		_panic
d362 1
a362 1
	xref	rei
d365 1
a365 1
	jmp		rei
d403 1
a403 1
	jsr	_copyout
d443 1
a443 1
	jsr	_copyin
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
