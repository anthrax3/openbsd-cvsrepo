head	1.3;
access;
symbols
	OPENBSD_5_5:1.2.0.78
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.74
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.72
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.70
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.68
	OPENBSD_5_0:1.2.0.66
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.64
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.62
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.58
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.60
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.56
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.54
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.52
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.50
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.48
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.46
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.44
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.42
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.40
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.38
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.36
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.34
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.2
	OPENBSD_3_3:1.2.0.32
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.30
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.28
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.2
	UBC:1.2.0.26
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.24
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.22
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.20
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.16
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.3
date	2014.03.18.22.36.33;	author miod;	state dead;
branches;
next	1.2;

1.2
date	96.05.29.21.05.39;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.57;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.57;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@*	$OpenBSD: slog2.sa,v 1.2 1996/05/29 21:05:39 niklas Exp $
*	$NetBSD: slog2.sa,v 1.2 1994/10/26 07:49:52 cgd Exp $

*	MOTOROLA MICROPROCESSOR & MEMORY TECHNOLOGY GROUP
*	M68000 Hi-Performance Microprocessor Division
*	M68040 Software Package 
*
*	M68040 Software Package Copyright (c) 1993, 1994 Motorola Inc.
*	All rights reserved.
*
*	THE SOFTWARE is provided on an "AS IS" basis and without warranty.
*	To the maximum extent permitted by applicable law,
*	MOTOROLA DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED,
*	INCLUDING IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
*	PARTICULAR PURPOSE and any warranty against infringement with
*	regard to the SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF)
*	and any accompanying written materials. 
*
*	To the maximum extent permitted by applicable law,
*	IN NO EVENT SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER
*	(INCLUDING WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS
*	PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR
*	OTHER PECUNIARY LOSS) ARISING OF THE USE OR INABILITY TO USE THE
*	SOFTWARE.  Motorola assumes no responsibility for the maintenance
*	and support of the SOFTWARE.  
*
*	You are hereby granted a copyright license to use, modify, and
*	distribute the SOFTWARE so long as this entire notice is retained
*	without alteration in any modified and/or redistributed versions,
*	and that such modified versions are clearly identified as such.
*	No licenses are granted by implication, estoppel or otherwise
*	under any patents or trademarks of Motorola, Inc.

*
*	slog2.sa 3.1 12/10/90
*
*       The entry point slog10 computes the base-10 
*	logarithm of an input argument X.
*	slog10d does the same except the input value is a 
*	denormalized number.  
*	sLog2 and sLog2d are the base-2 analogues.
*
*       INPUT:	Double-extended value in memory location pointed to 
*		by address register a0.
*
*       OUTPUT: log_10(X) or log_2(X) returned in floating-point 
*		register fp0.
*
*       ACCURACY and MONOTONICITY: The returned result is within 1.7 
*		ulps in 64 significant bit, i.e. within 0.5003 ulp 
*		to 53 bits if the result is subsequently rounded 
*		to double precision. The result is provably monotonic 
*		in double precision.
*
*       SPEED:	Two timings are measured, both in the copy-back mode. 
*		The first one is measured when the function is invoked 
*		the first time (so the instructions and data are not 
*		in cache), and the second one is measured when the 
*		function is reinvoked at the same input argument.
*
*       ALGORITHM and IMPLEMENTATION NOTES:
*
*       slog10d:
*
*       Step 0.   If X < 0, create a NaN and raise the invalid operation
*                 flag. Otherwise, save FPCR in D1; set FpCR to default.
*       Notes:    Default means round-to-nearest mode, no floating-point
*                 traps, and precision control = double extended.
*
*       Step 1.   Call slognd to obtain Y = log(X), the natural log of X.
*       Notes:    Even if X is denormalized, log(X) is always normalized.
*
*       Step 2.   Compute log_10(X) = log(X) * (1/log(10)).
*            2.1  Restore the user FPCR
*            2.2  Return ans := Y * INV_L10.
*
*
*       slog10: 
*
*       Step 0.   If X < 0, create a NaN and raise the invalid operation
*                 flag. Otherwise, save FPCR in D1; set FpCR to default.
*       Notes:    Default means round-to-nearest mode, no floating-point
*                 traps, and precision control = double extended.
*
*       Step 1.   Call sLogN to obtain Y = log(X), the natural log of X.
*
*       Step 2.   Compute log_10(X) = log(X) * (1/log(10)).
*            2.1  Restore the user FPCR
*            2.2  Return ans := Y * INV_L10.
*
*
*       sLog2d:
*
*       Step 0.   If X < 0, create a NaN and raise the invalid operation
*                 flag. Otherwise, save FPCR in D1; set FpCR to default.
*       Notes:    Default means round-to-nearest mode, no floating-point
*                 traps, and precision control = double extended.
*
*       Step 1.   Call slognd to obtain Y = log(X), the natural log of X.
*       Notes:    Even if X is denormalized, log(X) is always normalized.
*
*       Step 2.   Compute log_10(X) = log(X) * (1/log(2)).
*            2.1  Restore the user FPCR
*            2.2  Return ans := Y * INV_L2.
*
*
*       sLog2:
*
*       Step 0.   If X < 0, create a NaN and raise the invalid operation
*                 flag. Otherwise, save FPCR in D1; set FpCR to default.
*       Notes:    Default means round-to-nearest mode, no floating-point
*                 traps, and precision control = double extended.
*
*       Step 1.   If X is not an integer power of two, i.e., X != 2^k,
*                 go to Step 3.
*
*       Step 2.   Return k.
*            2.1  Get integer k, X = 2^k.
*            2.2  Restore the user FPCR.
*            2.3  Return ans := convert-to-double-extended(k).
*
*       Step 3.   Call sLogN to obtain Y = log(X), the natural log of X.
*
*       Step 4.   Compute log_2(X) = log(X) * (1/log(2)).
*            4.1  Restore the user FPCR
*            4.2  Return ans := Y * INV_L2.
*

SLOG2    IDNT    2,1 Motorola 040 Floating Point Software Package

	section	8

	xref	t_frcinx	
	xref	t_operr
	xref	slogn
	xref	slognd

INV_L10  DC.L $3FFD0000,$DE5BD8A9,$37287195,$00000000

INV_L2   DC.L $3FFF0000,$B8AA3B29,$5C17F0BC,$00000000

	xdef	slog10d
slog10d:
*--entry point for Log10(X), X is denormalized
	move.l		(a0),d0
	blt.w		invalid
	move.l		d1,-(sp)
	clr.l		d1
	bsr		slognd			...log(X), X denorm.
	fmove.l		(sp)+,fpcr
	fmul.x		INV_L10,fp0
	bra		t_frcinx

	xdef	slog10
slog10:
*--entry point for Log10(X), X is normalized

	move.l		(a0),d0
	blt.w		invalid
	move.l		d1,-(sp)
	clr.l		d1
	bsr		slogn			...log(X), X normal.
	fmove.l		(sp)+,fpcr
	fmul.x		INV_L10,fp0
	bra		t_frcinx


	xdef	slog2d
slog2d:
*--entry point for Log2(X), X is denormalized

	move.l		(a0),d0
	blt.w		invalid
	move.l		d1,-(sp)
	clr.l		d1
	bsr		slognd			...log(X), X denorm.
	fmove.l		(sp)+,fpcr
	fmul.x		INV_L2,fp0
	bra		t_frcinx

	xdef	slog2
slog2:
*--entry point for Log2(X), X is normalized
	move.l		(a0),d0
	blt.w		invalid

	move.l		8(a0),d0
	bne.b		continue		...X is not 2^k

	move.l		4(a0),d0
	and.l		#$7FFFFFFF,d0
	tst.l		d0
	bne.b		continue

*--X = 2^k.
	move.w		(a0),d0
	and.l		#$00007FFF,d0
	sub.l		#$3FFF,d0
	fmove.l		d1,fpcr
	fmove.l		d0,fp0
	bra		t_frcinx

continue:
	move.l		d1,-(sp)
	clr.l		d1
	bsr		slogn			...log(X), X normal.
	fmove.l		(sp)+,fpcr
	fmul.x		INV_L2,fp0
	bra		t_frcinx

invalid:
	bra		t_operr

	end
@


1.2
log
@$OpenBSD$ additions
@
text
@d1 1
a1 1
*	$OpenBSD: slog2.sa,v 1.2 1994/10/26 07:49:52 cgd Exp $
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
