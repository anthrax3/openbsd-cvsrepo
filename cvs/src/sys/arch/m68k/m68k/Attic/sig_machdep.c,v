head	1.28;
access;
symbols
	OPENBSD_5_5:1.27.0.8
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.4
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.25.0.6
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.4
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.19.0.6
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.6
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.8
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.6
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.10
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.2.0.14
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.12
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.10
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.8
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.28
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.27;

1.27
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2012.08.22.13.33.32;	author okan;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.05.04.48.01;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.15.04.52.39;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.27.22.04.01;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2009.03.25.22.42.58;	author weingart;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.02.19.18.54;	author martin;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.11.20.48.13;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.07.21.53.43;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.06.17.23.41;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.19.15.33.51;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.01.18.37.28;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.27.48;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.07.06.56;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.09.22.27.09;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.20.19.24.56;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.04.00.09.08;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.06.27.04.39.06;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.27.21.48.37;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.27.21.41.50;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.27.21.40.29;	author art;	state Exp;
branches;
next	1.2;

1.2
date	97.07.06.07.46.29;	author downsj;	state Exp;
branches
	1.2.12.1;
next	1.1;

1.1
date	97.03.26.08.23.55;	author downsj;	state Exp;
branches;
next	;

1.2.12.1
date	2001.04.18.16.10.01;	author niklas;	state Exp;
branches;
next	1.2.12.2;

1.2.12.2
date	2001.07.04.10.18.22;	author niklas;	state Exp;
branches;
next	1.2.12.3;

1.2.12.3
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.2.12.4;

1.2.12.4
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.2.12.5;

1.2.12.5
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	1.2.12.6;

1.2.12.6
date	2003.06.07.11.11.39;	author ho;	state Exp;
branches;
next	1.2.12.7;

1.2.12.7
date	2004.02.19.10.49.02;	author niklas;	state Exp;
branches;
next	1.2.12.8;

1.2.12.8
date	2004.06.05.23.10.51;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.36.07;	author art;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.10.29.00.28.05;	author art;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: sig_machdep.c,v 1.27 2012/12/02 07:03:31 guenther Exp $	*/
/*	$NetBSD: sig_machdep.c,v 1.3 1997/04/30 23:28:03 gwr Exp $	*/

/*
 * Copyright (c) 1997 Theo de Raadt
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: Utah Hdr: machdep.c 1.74 92/12/20
 *	from: @@(#)machdep.c	8.10 (Berkeley) 4/20/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/exec.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/signal.h>
#include <sys/signalvar.h>
#include <sys/malloc.h>
#include <sys/buf.h>

#include <uvm/uvm_extern.h>

#include <sys/syscallargs.h>

#include <machine/cpu.h>
#include <machine/frame.h>
#include <machine/reg.h>

extern short exframesize[];

#define SS_RTEFRAME	1
#define SS_FPSTATE	2
#define SS_USERREGS	4

struct sigstate {
	int	ss_flags;		/* which of the following are valid */
	struct	frame ss_frame;		/* original exception frame */
	struct	fpframe ss_fpstate;	/* 68881/68882 state info */
};

/*
 * WARNING: code in locore.s assumes the layout shown for sf_signum
 * thru sf_handler so... don't screw with them!
 */
struct sigframe {
	int	sf_signum;		/* signo for handler */
	siginfo_t *sf_sip;		/* pointer to siginfo_t */
	struct	sigcontext *sf_scp;	/* context ptr for handler */
	sig_t	sf_handler;		/* handler addr for u_sigc */
	struct	sigstate sf_state;	/* state of the hardware */
	struct	sigcontext sf_sc;	/* actual context */
	siginfo_t sf_si;
};

#ifdef DEBUG
int sigdebug = 0;
pid_t sigpid = 0;
#define SDB_FOLLOW	0x01
#define SDB_KSTACK	0x02
#define SDB_FPSTATE	0x04
#endif

/*
 * Send an interrupt to process.
 */
void
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
{
	struct proc *p = curproc;
	struct sigframe *fp, *kfp;
	struct frame *frame;
	struct sigacts *psp = p->p_sigacts;
	short ft;
	int fsize;

	frame = (struct frame *)p->p_md.md_regs;
	ft = frame->f_format;

	/*
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in P0 space, the
	 * call to grow() is a nop, and the useracc() check
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
	 */
	fsize = sizeof(struct sigframe);
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 &&
	    !sigonstack(frame->f_regs[SP]) &&
	    (psp->ps_sigonstack & sigmask(sig)))
		fp = (struct sigframe *)(p->p_sigstk.ss_sp +
					 p->p_sigstk.ss_size - fsize);
	else
		fp = (struct sigframe *)(frame->f_regs[SP] - fsize);
	if ((unsigned)fp <= USRSTACK - ptoa(p->p_vmspace->vm_ssize)) 
		(void)uvm_grow(p, (unsigned)fp);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d ssp %p usp %p scp %p ft %d\n",
		       p->p_pid, sig, &fsize, fp, &fp->sf_sc, ft);
#endif
	kfp = (struct sigframe *)malloc((u_long)fsize, M_TEMP,
	    M_WAITOK | M_CANFAIL | M_ZERO);
	if (kfp == NULL) {
		/* Better halt the process in its track than panicing */
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}

	/* 
	 * Build the argument list for the signal handler.
	 */
	kfp->sf_signum = sig;
	kfp->sf_sip = NULL;
	kfp->sf_scp = &fp->sf_sc;
	kfp->sf_handler = catcher;

	/*
	 * Save necessary hardware state.  Currently this includes:
	 *	- general registers
	 *	- original exception frame (if not a "normal" frame)
	 *	- FP coprocessor state
	 */
	kfp->sf_state.ss_flags = SS_USERREGS;
	bcopy((caddr_t)frame->f_regs,
	      (caddr_t)kfp->sf_state.ss_frame.f_regs, sizeof frame->f_regs);
	if (ft >= FMT7) {
#ifdef DEBUG
		if (ft > 15 || exframesize[ft] < 0)
			panic("sendsig: bogus frame type");
#endif
		kfp->sf_state.ss_flags |= SS_RTEFRAME;
		kfp->sf_state.ss_frame.f_format = frame->f_format;
		kfp->sf_state.ss_frame.f_vector = frame->f_vector;
		bcopy((caddr_t)&frame->F_u,
		      (caddr_t)&kfp->sf_state.ss_frame.F_u, exframesize[ft]);
		/*
		 * Leave an indicator that we need to clean up the kernel
		 * stack.  We do this by setting the "pad word" above the
		 * hardware stack frame to the amount the stack must be
		 * adjusted by.
		 *
		 * N.B. we increment rather than just set f_stackadj in
		 * case we are called from syscall when processing a
		 * sigreturn.  In that case, f_stackadj may be non-zero.
		 */
		frame->f_stackadj += exframesize[ft];
		frame->f_format = frame->f_vector = 0;
#ifdef DEBUG
		if (sigdebug & SDB_FOLLOW)
			printf("sendsig(%d): copy out %d of frame %d\n",
			       p->p_pid, exframesize[ft], ft);
#endif
	}

	if (fputype) {
		kfp->sf_state.ss_flags |= SS_FPSTATE;
		m68881_save(&kfp->sf_state.ss_fpstate);
	}
#ifdef DEBUG
	if ((sigdebug & SDB_FPSTATE) && *(char *)&kfp->sf_state.ss_fpstate)
		printf("sendsig(%d): copy out FP state (%x) to %p\n",
		       p->p_pid, *(u_int *)&kfp->sf_state.ss_fpstate,
		       &kfp->sf_state.ss_fpstate);
#endif
	/*
	 * Build the signal context to be used by sigreturn.
	 */
	kfp->sf_sc.sc_mask = mask;
	kfp->sf_sc.sc_sp = frame->f_regs[SP];
	kfp->sf_sc.sc_fp = frame->f_regs[A6];
	kfp->sf_sc.sc_ap = (int)&fp->sf_state;
	kfp->sf_sc.sc_pc = frame->f_pc;
	kfp->sf_sc.sc_ps = frame->f_sr;

	if (psp->ps_siginfo & sigmask(sig)) {
		kfp->sf_sip = &fp->sf_si;
		initsiginfo(&kfp->sf_si, sig, code, type, val);
	}

	/* XXX do not copy out siginfo if not needed */
	if (copyout((caddr_t)kfp, (caddr_t)fp, fsize) != 0) {
#ifdef DEBUG
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sendsig(%d): copyout failed on sig %d\n",
			       p->p_pid, sig);
#endif
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		free((caddr_t)kfp, M_TEMP);
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}
	frame->f_regs[SP] = (int)fp;
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sendsig(%d): sig %d scp %p fp %p sc_sp %x sc_ap %x\n",
		       p->p_pid, sig, kfp->sf_scp, fp,
		       kfp->sf_sc.sc_sp, kfp->sf_sc.sc_ap);
#endif
	/*
	 * Signal trampoline code is at base of user stack.
	 */
	frame->f_pc = p->p_sigcode;
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sendsig(%d): sig %d returns\n",
		       p->p_pid, sig);
#endif
	free((caddr_t)kfp, M_TEMP);
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper privileges or to cause
 * a machine fault.
 */
int
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	register struct sigcontext *scp;
	register struct frame *frame;
	register int rf;
	struct sigcontext tsigc;
	struct sigstate tstate;
	int flags;

	scp = SCARG(uap, sigcntxp);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: pid %d, scp %p\n", p->p_pid, scp);
#endif
	if ((int)scp & 1)
		return (EINVAL);

	/*
	 * Test and fetch the context structure.
	 * We grab it all at once for speed.
	 */
	if (copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof tsigc))
		return (EINVAL);
	scp = &tsigc;
	if ((scp->sc_ps & PSL_USERCLR) != 0 ||
	    (scp->sc_ps & PSL_USERSET) != PSL_USERSET)
		return (EINVAL);
	/*
	 * Restore the user supplied information
	 */
	p->p_sigmask = scp->sc_mask &~ sigcantmask;
	frame = (struct frame *) p->p_md.md_regs;
	frame->f_regs[SP] = scp->sc_sp;
	frame->f_regs[A6] = scp->sc_fp;
	frame->f_pc = scp->sc_pc;
	frame->f_sr = scp->sc_ps;

	/*
	 * Grab pointer to hardware state information.
	 * If zero, the user is probably doing a longjmp.
	 */
	if ((rf = scp->sc_ap) == 0)
		return (EJUSTRETURN);
	/*
	 * See if there is anything to do before we go to the
	 * expense of copying in close to 1/2K of data
	 */
	if (copyin((caddr_t)rf, &flags, sizeof(int)) != 0)
		return (EINVAL);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn(%d): sc_ap %x flags %x\n",
		       p->p_pid, rf, flags);
#endif
	if (flags == 0 || copyin((caddr_t)rf, (caddr_t)&tstate, sizeof tstate))
		return (EJUSTRETURN);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sigreturn(%d): ssp %p usp %x scp %p ft %d\n",
		       p->p_pid, &flags, scp->sc_sp, SCARG(uap, sigcntxp),
		       (flags&SS_RTEFRAME) ? tstate.ss_frame.f_format : -1);
#endif
	/*
	 * Restore most of the users registers except for A6 and SP
	 * which were handled above.
	 */
	if (flags & SS_USERREGS)
		bcopy((caddr_t)tstate.ss_frame.f_regs,
		      (caddr_t)frame->f_regs, sizeof(frame->f_regs)-2*sizeof(int));
	/*
	 * Restore long stack frames.  Note that we do not copy
	 * back the saved SR or PC, they were picked up above from
	 * the sigcontext structure.
	 */
	if (flags & SS_RTEFRAME) {
		register int sz;
		
		/* grab frame type and validate */
		sz = tstate.ss_frame.f_format;
		if (sz > 15 || (sz = exframesize[sz]) < 0)
			return (EINVAL);
		frame->f_stackadj -= sz;
		frame->f_format = tstate.ss_frame.f_format;
		frame->f_vector = tstate.ss_frame.f_vector;
		bcopy((caddr_t)&tstate.ss_frame.F_u, (caddr_t)&frame->F_u, sz);
#ifdef DEBUG
		if (sigdebug & SDB_FOLLOW)
			printf("sigreturn(%d): copy in %d of frame type %d\n",
			       p->p_pid, sz, tstate.ss_frame.f_format);
#endif
	}
	/*
	 * Finally we restore the original FP context
	 */
	if (fputype && (flags & SS_FPSTATE))
		m68881_restore(&tstate.ss_fpstate);
#ifdef DEBUG
	if ((sigdebug & SDB_FPSTATE) && *(char *)&tstate.ss_fpstate)
		printf("sigreturn(%d): copied in FP state (%x) at %p\n",
		       p->p_pid, *(u_int *)&tstate.ss_fpstate,
		       &tstate.ss_fpstate);
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid))
		printf("sigreturn(%d): returns\n", p->p_pid);
#endif
	return (EJUSTRETURN);
}
@


1.27
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.26 2012/08/22 13:33:32 okan Exp $	*/
@


1.26
log
@sigpid should be of type pid_t (only visable with DEBUG).

ok miod@@ (who found others to fix as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.25 2011/07/05 04:48:01 guenther Exp $	*/
d134 1
a134 1
	int oonstack, fsize;
a137 1
	oonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d147 3
a149 2
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !oonstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
d152 1
a152 2
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	} else
d159 1
a159 1
		       p->p_pid, sig, &oonstack, fp, &fp->sf_sc, ft);
d162 1
a162 1
	    M_WAITOK | M_CANFAIL);
a227 1
	kfp->sf_sc.sc_onstack = oonstack;
a320 4
	if (scp->sc_onstack & 1)
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.25
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.24 2011/04/18 21:44:55 guenther Exp $	*/
d112 1
a112 1
int sigpid = 0;
@


1.24
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.22 2010/06/27 22:04:01 miod Exp $	*/
d138 1
a138 1
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d148 1
a148 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
d150 3
a152 3
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d324 1
a324 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d326 1
a326 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.23
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d138 1
a138 1
	oonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d148 1
a148 1
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !oonstack &&
d150 3
a152 3
		fp = (struct sigframe *)(p->p_sigstk.ss_sp +
					 p->p_sigstk.ss_size - fsize);
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d324 1
a324 1
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d326 1
a326 1
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.22
log
@More include necessary after <sys/user.h> inclusion removal
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.21 2010/06/26 23:24:43 guenther Exp $	*/
d138 1
a138 1
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d148 1
a148 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
d150 3
a152 3
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d324 1
a324 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d326 1
a326 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.21
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.20 2009/03/25 22:42:58 weingart Exp $	*/
d81 1
@


1.20
log
@Nuke old useless define.  Miod was ok with the idea.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.19 2007/11/02 19:18:54 martin Exp $	*/
a67 1
#include <sys/user.h>
@


1.19
log
@replace ctob/btoc with ptoa/atop (plus the usual round_page() where needed)
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.18 2006/06/11 20:48:13 miod Exp $	*/
d365 1
a365 1
		      (caddr_t)frame->f_regs, sizeof(frame->f_regs)-2*NBPW);
@


1.18
log
@Move common prototypes to <m68k/{cpu,param}.h> instead of incomplete
declarations in <machine/{cpu,param}.h> and elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.17 2006/06/07 21:53:43 miod Exp $	*/
d155 1
a155 1
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
@


1.17
log
@Pass M_CANFAIL to malloc() in sendsig(), and if it fails, kill the process;
this is better than panic'ing due to low memory condition.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.16 2005/11/06 17:23:41 miod Exp $	*/
a83 1
extern int fputype;
a84 2
void	m68881_save(struct fpframe *);
void	m68881_restore(struct fpframe *);
@


1.16
log
@Homogeneize all PSR field tests in user-provided structures. No functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.15 2004/02/19 15:33:51 miod Exp $	*/
d165 8
a172 1
	kfp = (struct sigframe *)malloc((u_long)fsize, M_TEMP, M_WAITOK);
@


1.15
log
@When copyout() of the signal frame fails, sigexit() the process instead of
doing this by an hand-delivered SIGILL.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.14 2003/08/01 18:37:28 miod Exp $	*/
d313 2
a314 1
	if ((scp->sc_ps & (PSL_MBZ|PSL_IPL|PSL_S)) != 0)
@


1.14
log
@Nuke calls to uvm_useracc() and instead check copyin() and copyout() for
failure, since the former is not reliable; requested by art@@ long ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.13 2003/06/02 23:27:48 millert Exp $	*/
a248 6
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
d250 2
a251 1
		return;
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.12 2003/06/02 07:06:56 deraadt Exp $	*/
a164 18
	if (uvm_useracc((caddr_t)fp, fsize, B_WRITE) == 0) {
#ifdef DEBUG
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sendsig(%d): useracc failed on sig %d\n",
			       p->p_pid, sig);
#endif
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}
d239 19
a257 1
	(void) copyout((caddr_t)kfp, (caddr_t)fp, fsize);
d315 1
a315 2
	if (uvm_useracc((caddr_t)scp, sizeof (*scp), B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof tsigc))
@


1.12
log
@licence cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.11 2003/01/09 22:27:09 miod Exp $	*/
d44 1
a44 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.10 2002/07/20 19:24:56 art Exp $	*/
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.10
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.9 2002/06/04 00:09:08 deraadt Exp $	*/
d142 5
a146 5
	register struct proc *p = curproc;
	register struct sigframe *fp, *kfp;
	register struct frame *frame;
	register struct sigacts *psp = p->p_sigacts;
	register short ft;
d355 2
a356 1
	flags = fuword((caddr_t)rf);
a361 5
	/*
	 * fuword failed (bogus sc_ap value).
	 */
	if (flags == -1)
		return (EINVAL);
@


1.9
log
@spelling; raj@@cerias.purdue.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.8 2002/03/14 01:26:35 millert Exp $	*/
a147 1
	extern char sigcode[], esigcode[];
d278 1
a278 1
	frame->f_pc = (int)PS_STRINGS - (esigcode - sigcode);
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.7 2001/11/06 19:53:14 miod Exp $	*/
d295 1
a295 1
 * psl to gain improper priviledges or to cause
@


1.7
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.6 2001/06/27 04:39:06 art Exp $	*/
d96 2
a97 2
void	m68881_save __P((struct fpframe *));
void	m68881_restore __P((struct fpframe *));
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.7 2001/11/06 19:53:14 miod Exp $	*/
d96 2
a97 2
void	m68881_save(struct fpframe *);
void	m68881_restore(struct fpframe *);
d295 1
a295 1
 * psl to gain improper privileges or to cause
@


1.7.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.7.2.1 2002/06/11 03:36:07 art Exp $	*/
d148 1
d279 1
a279 1
	frame->f_pc = p->p_sigcode;
@


1.7.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d142 5
a146 5
	struct proc *p = curproc;
	struct sigframe *fp, *kfp;
	struct frame *frame;
	struct sigacts *psp = p->p_sigacts;
	short ft;
d355 1
a355 2
	if (copyin((caddr_t)rf, &flags, sizeof(int)) != 0)
		return (EINVAL);
d361 5
@


1.6
log
@kill old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.5 2000/05/27 21:48:37 art Exp $	*/
a86 1
#include <vm/vm.h>
@


1.5
log
@UVM. useracc -> uvm_useracc.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.4 2000/05/27 21:41:50 art Exp $	*/
a87 1
#if defined(UVM)
a88 1
#endif
a169 1
#if defined(UVM)
a171 4
#else
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
		(void)grow(p, (unsigned)fp);
#endif
a176 1
#if defined(UVM)
a177 3
#else
	if (useracc((caddr_t)fp, fsize, B_WRITE) == 0) {
#endif
a326 1
#if defined(UVM)
a329 5
#else
	if (useracc((caddr_t)scp, sizeof (*scp), B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof tsigc))
		return (EINVAL);
#endif
@


1.4
log
@oops. remove "line noise".
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.3 2000/05/27 21:40:29 art Exp $	*/
d184 3
d188 1
d338 5
d346 1
@


1.3
log
@UVM. grow -> uvm_grow
@
text
@d1 1
a1 1
'/*	$OpenBSD: sig_machdep.c,v 1.2 1997/07/06 07:46:29 downsj Exp $	*/
@


1.2
log
@Sync with NetBSD changes, 970415 - 970705.

This includes a new asm.h, as well as even more code abstracted from hp300.
These changes are likely to break ports that don't know about them; hp300
runs at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.1 1997/03/26 08:23:55 downsj Exp $	*/
d87 5
d172 4
d178 1
@


1.2.12.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.5 2000/05/27 21:48:37 art Exp $	*/
a86 5
#include <vm/vm.h>
#if defined(UVM)
#include <uvm/uvm_extern.h>
#endif

a166 4
#if defined(UVM)
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
		(void)uvm_grow(p, (unsigned)fp);
#else
a168 1
#endif
a173 3
#if defined(UVM)
	if (uvm_useracc((caddr_t)fp, fsize, B_WRITE) == 0) {
#else
a174 1
#endif
a323 5
#if defined(UVM)
	if (uvm_useracc((caddr_t)scp, sizeof (*scp), B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof tsigc))
		return (EINVAL);
#else
a326 1
#endif
@


1.2.12.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.2.12.1 2001/04/18 16:10:01 niklas Exp $	*/
d88 1
d90 1
d172 1
d175 4
d184 1
d186 3
d338 1
d342 5
@


1.2.12.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d87 1
@


1.2.12.4
log
@Merge in -current from about a week ago
@
text
@d96 2
a97 2
void	m68881_save(struct fpframe *);
void	m68881_restore(struct fpframe *);
@


1.2.12.5
log
@Sync the SMP branch with 3.3
@
text
@d142 5
a146 5
	struct proc *p = curproc;
	struct sigframe *fp, *kfp;
	struct frame *frame;
	struct sigacts *psp = p->p_sigacts;
	short ft;
d148 1
d279 1
a279 1
	frame->f_pc = p->p_sigcode;
d295 1
a295 1
 * psl to gain improper privileges or to cause
d356 1
a356 2
	if (copyin((caddr_t)rf, &flags, sizeof(int)) != 0)
		return (EINVAL);
d362 5
@


1.2.12.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sig_machdep.c,v 1.2.12.5 2003/03/27 23:28:43 niklas Exp $	*/
d15 6
d50 5
a54 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2.12.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d165 18
d257 1
a257 19
	if (copyout((caddr_t)kfp, (caddr_t)fp, fsize) != 0) {
#ifdef DEBUG
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sendsig(%d): copyout failed on sig %d\n",
			       p->p_pid, sig);
#endif
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		free((caddr_t)kfp, M_TEMP);
		return;
	}
d315 2
a316 1
	if (copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof tsigc))
@


1.2.12.8
log
@Merge with the trunk
@
text
@d249 6
d256 1
a256 2
		sigexit(p, SIGILL);
		/* NOTREACHED */
@


1.1
log
@Merge changes from NetBSD, 3/19/97; enforce use of new files in file.m68k.

All of the m68k ports need fixing, in various ways.  From a casual look,
mvme68k and sun3 need the most work.

Tested on hp300, from which sig_machdep.c is based.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: sig_machdep.c,v 1.2 1997/03/17 19:03:11 gwr Exp $	*/
d171 1
a171 1
		printf("sendsig(%d): sig %d ssp %x usp %x scp %x ft %d\n",
d245 1
a245 1
		printf("sendsig(%d): copy out FP state (%x) to %x\n",
d270 1
a270 1
		printf("sendsig(%d): sig %d scp %x fp %x sc_sp %x sc_ap %x\n",
d315 1
a315 1
		printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
d369 1
a369 1
		printf("sigreturn(%d): ssp %x usp %x scp %x ft %d\n",
d409 1
a409 1
		printf("sigreturn(%d): copied in FP state (%x) at %x\n",
@
