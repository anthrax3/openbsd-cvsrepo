head	1.18;
access;
symbols
	OPENBSD_5_5:1.17.0.50
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.46
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.44
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.42
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.40
	OPENBSD_5_0:1.17.0.38
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.36
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.34
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.30
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.32
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.28
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.26
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.24
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.22
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.20
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.18
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.16
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.14
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.12
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.10
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.8
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.6
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.17
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.9.0.16
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.14
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.12
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.10
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.8
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.17;

1.17
date	2002.05.18.09.49.17;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.03.15.54;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.06.23.45.23;	author miod;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.11.16.22.04.45;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.16.22.02.05;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.12.12.03.02;	author heko;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.15.01.43.15;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.03.01.14.12.42;	author niklas;	state Exp;
branches
	1.9.10.1;
next	1.8;

1.8
date	97.03.21.00.36.40;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.01.19.13.53.11;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.01.13.11.51.13;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.09.21.04.26.38;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.05.09.22.30.11;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.04.19.06.18.16;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.03.21.00.12.55;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.00;	author deraadt;	state Exp;
branches;
next	;

1.9.10.1
date	2001.07.04.10.18.19;	author niklas;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2001.10.31.03.01.14;	author nate;	state Exp;
branches;
next	1.9.10.3;

1.9.10.3
date	2001.12.05.00.39.11;	author niklas;	state Exp;
branches;
next	1.9.10.4;

1.9.10.4
date	2002.03.06.01.03.31;	author niklas;	state Exp;
branches;
next	1.9.10.5;

1.9.10.5
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.9.10.6;

1.9.10.6
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	;

1.14.2.1
date	2002.06.11.03.36.06;	author art;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: db_trace.c,v 1.17 2002/05/18 09:49:17 art Exp $	*/
/*	$NetBSD: db_trace.c,v 1.20 1997/02/05 05:10:25 scottr Exp $	*/

/* 
 * Mach Operating System
 * Copyright (c) 1992 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon 
 * the rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>

#include <machine/db_machdep.h>

#include <ddb/db_interface.h>
#include <ddb/db_output.h>
#include <ddb/db_access.h>
#include <ddb/db_sym.h>
#include <ddb/db_variables.h>

extern label_t	*db_recover;

/*
 * Register list
 */
static int db_var_short(struct db_variable *, db_expr_t *, int);

struct db_variable db_regs[] = {
	/* D0-D7 */
	{ "d0",	(long *)&ddb_regs.tf_regs[0],	FCN_NULL },
	{ "d1",	(long *)&ddb_regs.tf_regs[1],	FCN_NULL },
	{ "d2",	(long *)&ddb_regs.tf_regs[2],	FCN_NULL },
	{ "d3",	(long *)&ddb_regs.tf_regs[3],	FCN_NULL },
	{ "d4",	(long *)&ddb_regs.tf_regs[4],	FCN_NULL },
	{ "d5",	(long *)&ddb_regs.tf_regs[5],	FCN_NULL },
	{ "d6",	(long *)&ddb_regs.tf_regs[6],	FCN_NULL },
	{ "d7",	(long *)&ddb_regs.tf_regs[7],	FCN_NULL },
	/* A0-A7 */
	{ "a0",	(long *)&ddb_regs.tf_regs[8+0],	FCN_NULL },
	{ "a1",	(long *)&ddb_regs.tf_regs[8+1],	FCN_NULL },
	{ "a2",	(long *)&ddb_regs.tf_regs[8+2],	FCN_NULL },
	{ "a3",	(long *)&ddb_regs.tf_regs[8+3],	FCN_NULL },
	{ "a4",	(long *)&ddb_regs.tf_regs[8+4],	FCN_NULL },
	{ "a5",	(long *)&ddb_regs.tf_regs[8+5],	FCN_NULL },
	{ "a6",	(long *)&ddb_regs.tf_regs[8+6],	FCN_NULL },
	{ "sp",	(long *)&ddb_regs.tf_regs[8+7],	FCN_NULL },
	/* misc. */
	{ "pc",	(long *)&ddb_regs.tf_pc, 	FCN_NULL },
	{ "sr",	(long *)&ddb_regs.tf_sr,	db_var_short }
};
struct db_variable *db_eregs = db_regs + sizeof(db_regs)/sizeof(db_regs[0]);

static int
db_var_short(varp, valp, op)
    struct db_variable *varp;
    db_expr_t *valp;
    int op;
{
    if (op == DB_VAR_GET)
	*valp = (db_expr_t) *((short *)varp->valuep);
    else
	*((short *)varp->valuep) = (short) *valp;
    return(0);
}

#define	MAXINT	0x7fffffff

#if 0
#define	INKERNEL(va)	(((vaddr_t)(va)) >= VM_MIN_KERNEL_ADDRESS && \
			 (((vaddr_t)(va)) < (USRSTACK - MAXSSIZ) || \
			  ((vaddr_t)(va)) >= USRSTACK))
#else
/* XXX - Slight hack... */
extern int curpcb;
#define	INKERNEL(va)	(((int)(va) > curpcb) && \
			 ((int)(va) < (curpcb + USPACE)))
#endif

#define	get(addr, space) \
		(db_get_value((db_addr_t)(addr), sizeof(int), FALSE))
#define	get16(addr, space) \
		(db_get_value((db_addr_t)(addr), sizeof(u_short), FALSE))

#define	NREGISTERS	16

struct stackpos {
	 int	k_pc;
	 int	k_fp;
	 int	k_nargs;
	 int	k_entry;
	 int	k_caller;
	 int	k_flags;
	 int	k_regloc[NREGISTERS];
};

static void findentry(struct stackpos *);
static void findregs(struct stackpos *, db_addr_t);
static int  nextframe(struct stackpos *, int);
static void stacktop(db_regs_t *, struct stackpos *);


#define FR_SAVFP	0
#define FR_SAVPC	4
#define K_CALLTRAMP	1	/* for k_flags: caller is __sigtramp */
#define K_SIGTRAMP	2	/* for k_flags: this is   __sigtramp */

static void
stacktop(regs, sp)
	db_regs_t *regs;
	struct stackpos *sp;
{
	int i;

	/* Note: leave out a6, a7 */
	for (i = 0; i < (8+6); i++) {
		sp->k_regloc[i] = (int) &regs->tf_regs[i];
	}

	sp->k_fp = get(&regs->tf_regs[8+6], 0);
	/* skip sp (a7) */
	sp->k_pc = get(&regs->tf_pc, 0);
	sp->k_flags = 0;

	findentry(sp);
}


/*
 * The VAX has a very nice calling convention, and it is quite easy to
 * find saved registers, and the number of parameters. We are not nearly
 * so lucky. We must grub around in code for much of this information
 * (remember the PDP-11?), and the saved register list seems to be
 * especially hard to find.
 */

#define HIWORD	0xffff0000
#define LOWORD	0x0000ffff
#define LINKLA6	0x480e0000	/* linkl a6,#x    */
#define LINKWA6	0x4e560000	/* linkw a6,#x    */
#define ADDLSP	0xdffc0000	/* addl #x,sp    */
#define ADDWSP	0xdefc0000	/* addw #x,sp    */
#define LEASP	0x4fef0000	/* lea	sp@@(x),sp*/
#define TSTBSP	0x4a2f0000	/* tstb sp@@(x)   */
#define INSMSK	0xfff80000
#define MOVLSP	0x2e800000	/* movl dx,sp@@   */
#define MOVLD0	0x20000000	/* movl d0,dx	 */
#define MOVLA0	0x20400000	/* movl d0,ax	 */
#define MVLMSK	0xf1ff0000
#define MOVEML	0x48d70000	/* moveml #x,sp@@ */
#define JSR	0x4eb80000	/* jsr x.[WL]    */
#define JSRPC	0x4eba0000	/* jsr PC@@( )    */
#define LONGBIT 0x00010000
#define BSR	0x61000000	/* bsr x	 */
#define BSRL	0x61ff0000	/* bsrl x	 */
#define BYTE3	0x0000ff00
#define LOBYTE	0x000000ff
#define ADQMSK	0xf1ff0000
#define ADDQSP	0x508f0000	/* addql #x,sp   */
#define ADDQWSP	0x504f0000	/* addqw #x,sp   */

struct nlist *	trampsym = 0;
struct nlist *	funcsym = 0;

static int
nextframe(sp, kerneltrace)
	struct stackpos *sp;
	int kerneltrace;
{
	int		i;
	db_addr_t	addr;
	db_addr_t	calladdr;
	db_addr_t	oldfp = sp->k_fp;

	/*
	 * Find our entry point. Then find out
	 * which registers we saved, and map them.
	 * Our entry point is the address our caller called.
	 */

	calladdr = sp->k_caller;
	addr     = sp->k_entry;
	if (sp->k_flags & K_CALLTRAMP) {
#if	0
	/* we never set CALLTRAMP */
		/*
		 * Caller was sigtramp.  Therefore:
		 *   - no registers were saved;
		 *   - no new frame-pointer
		 *   - caller found in sigcontext structure.
		 *   - WE become sigtramp
		 *   - we have no parameters
		 * MUCH MAGIC USED IN FINDING CALLER'S PC.
		 */
		sp->k_pc = sp->k_caller;
		sp->k_entry = trampsym->n_value;
		sp->k_flags = 0;
		addr = get(sp->k_fp + sizeof(int) * 11, DSP);
		sp->k_nargs = 0;
#if DEBUG
		db_printf("nextframe: sigcontext at 0x%x, signaled at 0x%x\n",
		    addr, sp->k_caller);
#endif
		errflg = 0;
#endif /* 0 */
	} else {
		if (addr == MAXINT) {
			/* we don't know what registers are involved here--
			   invalidate all */
			for (i = 0; i < NREGISTERS; i++)
				sp->k_regloc[i] = -1;
		} else
			findregs(sp, addr);

		/* find caller's pc and fp */
		sp->k_pc = calladdr;
		sp->k_fp = get(sp->k_fp + FR_SAVFP, DSP);

		/* 
		 * Now that we have assumed the identity of our caller, find
		 * how many longwords of argument WE were called with.
		 */
		sp->k_flags = 0;

		/*
		 * Don't dig around in user stack to find no. of args and
		 * entry point if just tracing the kernel
		 */
		if (kerneltrace && !INKERNEL(sp->k_fp)) {
			sp->k_nargs = 0;
			sp->k_entry = MAXINT;
		} else
			findentry(sp);
	}

	if (sp->k_fp == 0 || oldfp == sp->k_fp)
		return 0;
	return (sp->k_fp);
}

static void
findentry(sp)
	struct stackpos *sp;
{ 
	/* 
	 * Set the k_nargs and k_entry fields in the stackpos structure.  This
	 * is called from stacktop() and from nextframe().  Our caller will do
	 * an addq or addl or addw to sp just after we return to pop off our
	 * arguments.  Find that instruction and extract the value.
	 */
	int		instruc;
	int		val;
	db_addr_t	addr, nextword;
	label_t		db_jmpbuf;
	label_t		*savejmp;

	savejmp = db_recover;
	db_recover = &db_jmpbuf;
	if (setjmp(&db_jmpbuf)) {
		/* oops -- we touched something we ought not to have */
		/* cannot trace caller of "start" */
		sp->k_entry = MAXINT;
		sp->k_nargs = 0;
		db_recover = savejmp;
		return;
	}

	addr = get(sp->k_fp + FR_SAVPC, DSP);
	if (addr == 0) {
		/* oops -- we touched something we ought not to have */
		/* cannot trace caller of "start" */
		sp->k_entry = MAXINT;
		sp->k_nargs = 0;
		db_recover = savejmp;
		return;
	}
	instruc  = get(addr - 6, ISP);
	nextword = get(addr - 4, ISP);

	db_recover = savejmp;

	if ((instruc & HIWORD) == (JSR | LONGBIT)) {
		/* longword offset here */
		sp->k_caller = addr - 6;
		sp->k_entry  = nextword;
	} else if ((instruc & HIWORD) == BSRL) {
		/* longword self-relative offset */
		sp->k_caller = addr - 6;
		sp->k_entry  = nextword + (addr - 4);
	} else {
		instruc = nextword;
		if ((instruc & HIWORD) == JSR) {
			/* short word offset */
			sp->k_caller = addr - 4;
			sp->k_entry  = instruc & LOWORD;
		} else if ((instruc & HIWORD) == BSR) {
			/* short word, self-relative offset */
			sp->k_caller = addr - 4;
			sp->k_entry  = (addr - 2) + (short)(instruc & LOWORD);
		} else if ((instruc & HIWORD) == JSRPC) {
			/* PC-relative, short word offset */
			sp->k_caller = addr - 4;
			sp->k_entry  = (addr - 2) + (instruc & LOWORD);
		} else {
			if ((instruc & BYTE3) == (BSR >> 16)) {
				/* byte, self-relative offset */
				sp->k_caller = addr - 2;
				sp->k_entry  = addr + (char)(instruc & LOBYTE);
			} else {
				/* was a call through a proc parameter */
				sp->k_caller = addr - 2;
				sp->k_entry  = MAXINT;
				/*
				 * We know that sigtramp calls your signal
				 * catcher this way -- see if this is the
				 * tramp: if so then:
				 *   - set the K_CALLTRAMP flag, for use by
				 *     nextframe();
				 *   - take k_entry from __sigfunc array.
				 */
#if	0
	/* not in kernel */
				/*
				 * The number (9) in the below expression is
				 * magic: it is the number of stack items below
				 * callee`s fp and sigtramp`s copy of the
				 * signal number.
				 */
				if (trampsym &&
				    (findsym(sp->k_caller, ISYM), cursym == trampsym)) {
					int signl;
					sp->k_flags |= K_CALLTRAMP;
					if (funcsym) {
						signl = get(sp->k_fp + sizeof(int) * 9, DSP);
						sp->k_entry = get(funcsym->n_value+(sizeof(int(*)()))*signl, DSP);
					} else
						sp->k_entry = -1;

					errflg = 0;
#ifdef DEBUG
					db_printf("Caller is sigtramp: signal is %d: entry is %x\n",
					    signl, sp->k_entry);
#endif
				}
#ifdef DEBUG
				else
				db_printf("Non-tramp jsr a0@@\n");
#endif
#endif /* 0 */
			}
		}
	}
	instruc = get(addr, ISP);
	/* on bad days, the compiler dumps a register move here */
	if ((instruc & MVLMSK) == MOVLA0 ||
	    (instruc & MVLMSK) == MOVLD0)
		instruc = get(addr += 2, ISP);
	if ((instruc & ADQMSK) == ADDQSP ||
	    (instruc & ADQMSK) == ADDQWSP) {
		val = 0;
		do {
			int n;
			n = (instruc >> (16+9)) & 07;
			if (n == 0)
				n = 8;
			val += n;
			instruc = get(addr += 2, ISP);
		} while ((instruc & ADQMSK) == ADDQSP ||
			 (instruc & ADQMSK) == ADDQWSP);
	} else if ((instruc & HIWORD) == ADDLSP)
		val = get(addr + 2, ISP);
	else if ((instruc & HIWORD) == ADDWSP ||
		 (instruc & HIWORD) == LEASP)
		val = instruc & LOWORD;
	else
		val = 20;
	sp->k_nargs = val / 4;
}

/*
 * Look at the procedure prolog of the current called procedure.
 * Figure out which registers we saved, and where they are
 */
static void
findregs(sp, addr)
	struct stackpos *sp;
	db_addr_t addr;
{
	long instruc, val, i;
	int  regp;

	regp = 0;
	instruc = get(addr, ISP);
	if ((instruc & HIWORD) == LINKLA6) {
		instruc = get(addr + 2, ISP);
		addr += 6;
		regp = sp->k_fp + instruc;
	} else if ((instruc & HIWORD) == LINKWA6) {
		addr += 4;
		if ((instruc &= LOWORD) == 0) {
			/* look for addl */
			instruc = get(addr, ISP);
			if ((instruc & HIWORD) == ADDLSP) {
				instruc = get(addr + 2, ISP);
				addr += 6;
			}
			/* else frame is really size 0 */
		} else {
			/* link offset was non-zero -- sign extend it */
			instruc <<= 16;
			instruc >>= 16;
		}
		/* we now have the negative frame size */
		regp = sp->k_fp + instruc;
	}

	/* find which registers were saved */
	/* (expecting probe instruction next) */
	instruc = get(addr, ISP);
	if ((instruc & HIWORD) == TSTBSP)
		addr += 4;

	/* now we expect either a moveml or a movl */
	instruc = get(addr, ISP);
	if ((instruc & INSMSK) == MOVLSP) {
		/* only saving one register */
		i = (instruc >> 16) & 07;
		sp->k_regloc[i] = regp;
	} else if ((instruc & HIWORD) == MOVEML) {
		/* saving multiple registers or unoptimized code */
		val = instruc & LOWORD;
		i = 0;
		while (val) {
			if (val & 1) {
				sp->k_regloc[i] = regp;
				regp += sizeof(int);
			}
			val >>= 1;
			i++;
		}
	}
	/* else no registers saved */
}

/*
 *	Frame tracing.
 */
void
db_stack_trace_print(addr, have_addr, count, modif, pr)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char		*modif;
	int		(*pr)(const char *, ...);
{
	int i, nargs;
	long val;
	db_addr_t	regp;
	char *		name;
	struct stackpos pos;
	boolean_t	kernel_only = TRUE;
	int		fault_pc = 0;

	{
		char *cp = modif;
		char c;

		while ((c = *cp++) != 0)
			if (c == 'u')
				kernel_only = FALSE;
	}

	if (count == -1)
		count = 65535;

	if (!have_addr)
		stacktop(&ddb_regs, &pos);
#if 0
	else {

		/*
		 * Only have user register state.
		 */
		pcb_t	t_pcb;
		db_regs_t *user_regs;
		
		t_pcb = (pcb_t) get(&th->pcb, 0);
		user_regs = (db_regs_t *)
			get(&t_pcb->user_regs, 0);
		
		stacktop(user_regs, &pos);

		/* foo*/
	}
#endif
	else {
		pos.k_flags = 0;
		pos.k_fp = addr;

		pos.k_nargs = 0;
		pos.k_pc = MAXINT;
		pos.k_entry = MAXINT;
		/* sorry, we cannot find our registers without knowing our pc */
		for (i = 0; i < NREGISTERS; i++)
			pos.k_regloc[i] = 0;
		findentry(&pos);
	}

	while (count) {
		count--;

		/* HACK */
		if (pos.k_pc == MAXINT) {
			name = "?";
			pos.k_pc = 0;
		} else {
			db_find_sym_and_offset(pos.k_pc, &name, &val);
			if (name == 0) {
				val = MAXINT;
				name = "?";
			}
		}

		/*
		 * Since faultstkadj doesn't set up a valid stack frame,
		 * we would assume it was the source of the fault. To
		 * get around this we peek at the fourth argument of
		 * "trap()" (the stack frame at the time of the fault)
		 * to determine the _real_ value of PC when things wen
		 * wrong.
		 *
		 * NOTE: If the argument list for 'trap()' ever changes,
		 * we lose.
		 */
		if (strcmp("_trap", name) == 0) {
			int tfp;

			/* Point to 'trap()'s 4th argument (frame structure) */
			tfp = pos.k_fp + FR_SAVFP + 4 + (4 * 4);

			/* Determine if fault was from kernel or user mode */
			regp = tfp + offsetof(struct frame, f_sr);
			if (!USERMODE(get16(regp, DSP))) {
				/*
				 * Definitely a kernel mode fault,
				 * so get the PC at the time of the fault.
				 */
				regp = tfp + offsetof(struct frame, f_pc);
				fault_pc = get(regp, DSP);
			}
		} else
		if (fault_pc) {
			if (strcmp("faultstkadj", name) == 0) {
				db_find_sym_and_offset(fault_pc, &name, &val);
				if (name == 0) {
					val = MAXINT;
					name = "?";
				}
			}
			fault_pc = 0;
		}

		(*pr)("%s", name);
		if (pos.k_entry != MAXINT && name) {
			char *	entry_name;
			long	e_val;

			db_find_sym_and_offset(pos.k_entry, &entry_name,
			    &e_val);
			if (entry_name != 0 && entry_name != name &&
			    e_val != val) {
				(*pr)("(?)\n%s", entry_name);
			}
		}
		(*pr)("(");
		regp = pos.k_fp + FR_SAVFP + 4;
		if ((nargs = pos.k_nargs)) {
			while (nargs--) {
				(*pr)("%lx", get(regp += 4, DSP));
				if (nargs)
					(*pr)(",");
			}
		}
		if (val == MAXINT)
			(*pr)(") at %x\n", pos.k_pc);
		else
			(*pr)(") + %lx\n", val);

		/*
		 * Stop tracing if frame ptr no longer points into kernel
		 * stack.
		 */
		if (kernel_only && !INKERNEL(pos.k_fp))
			break;
		if (nextframe(&pos, kernel_only) == 0)
			break;
	}
}

@


1.17
log
@Rename the MD db_stack_trace_cmd to db_stack_trace_print. Add an argument
that specifies which printf funciton it should use. Implement
db_stack_trace_cmd in MI code.

Thanks to miod@@ for all the tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.16 2002/03/14 03:15:54 millert Exp $	*/
@


1.16
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.15 2002/03/14 01:26:35 millert Exp $	*/
d469 1
a469 1
db_stack_trace_cmd(addr, have_addr, count, modif)
d474 1
d583 1
a583 1
		db_printf("%s", name);
d592 1
a592 1
				db_printf("(?)\n%s", entry_name);
d595 1
a595 1
		db_printf("(");
d599 1
a599 1
				db_printf("%lx", get(regp += 4, DSP));
d601 1
a601 1
					db_printf(",");
d605 1
a605 1
			db_printf(") at %x\n", pos.k_pc);
d607 1
a607 1
			db_printf(") + %lx\n", val);
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.14 2001/12/06 23:45:23 miod Exp $	*/
d81 1
a81 1
	*valp = (db_expr_t) *((short*)varp->valuep);
d83 1
a83 1
	*((short*)varp->valuep) = (short) *valp;
@


1.14
log
@DDB disassembly fixes and trace improvements from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.13 2001/11/16 22:04:45 mickey Exp $	*/
d47 1
a47 1
static int db_var_short __P((struct db_variable *, db_expr_t *, int));
d117 4
a120 4
static void findentry __P((struct stackpos *));
static void findregs __P((struct stackpos *, db_addr_t));
static int  nextframe __P((struct stackpos *, int));
static void stacktop __P((db_regs_t *, struct stackpos *));
@


1.14.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.14 2001/12/06 23:45:23 miod Exp $	*/
d47 1
a47 1
static int db_var_short(struct db_variable *, db_expr_t *, int);
d81 1
a81 1
	*valp = (db_expr_t) *((short *)varp->valuep);
d83 1
a83 1
	*((short *)varp->valuep) = (short) *valp;
d117 4
a120 4
static void findentry(struct stackpos *);
static void findregs(struct stackpos *, db_addr_t);
static int  nextframe(struct stackpos *, int);
static void stacktop(db_regs_t *, struct stackpos *);
d469 1
a469 1
db_stack_trace_print(addr, have_addr, count, modif, pr)
a473 1
	int		(*pr)(const char *, ...);
d582 1
a582 1
		(*pr)("%s", name);
d591 1
a591 1
				(*pr)("(?)\n%s", entry_name);
d594 1
a594 1
		(*pr)("(");
d598 1
a598 1
				(*pr)("%lx", get(regp += 4, DSP));
d600 1
a600 1
					(*pr)(",");
d604 1
a604 1
			(*pr)(") at %x\n", pos.k_pc);
d606 1
a606 1
			(*pr)(") + %lx\n", val);
@


1.13
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.12 2001/11/16 22:02:05 mickey Exp $	*/
d102 2
d130 2
a131 2
	register db_regs_t *regs;
	register struct stackpos *sp;
a174 1
#ifdef	mc68020
a175 1
#endif /* mc68020 */
d187 1
a187 1
	register struct stackpos *sp;
d263 1
a263 1
	register struct stackpos *sp;
a305 1
#ifdef	mc68020
a309 1
#endif /* mc68020 */
d406 2
a407 2
	register struct stackpos *sp;
	register db_addr_t addr;
d409 1
a409 1
	register long instruc, val, i;
d481 1
d484 2
a485 2
		register char *cp = modif;
		register char c;
d503 2
a504 2
		register pcb_t	t_pcb;
		register db_regs_t *user_regs;
d542 40
@


1.12
log
@make stack trace print addrs if no symtab present; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.11 2001/08/12 12:03:02 heko Exp $	*/
d545 1
a545 1
			const char *	entry_name;
@


1.11
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.10 2001/05/15 01:43:15 millert Exp $	*/
d538 2
a539 1
			if (name == 0)
d541 1
d545 1
a545 1
			char *	entry_name;
@


1.10
log
@Replace vm_offset_t with vaddr_t and paddr_t as appropriate.
NetBSD used as a guide.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.9 1998/03/01 14:12:42 niklas Exp $	*/
d175 1
a175 1
#endif	mc68020
d225 1
a225 1
#endif	0
d311 1
a311 1
#endif	mc68020
d371 1
a371 1
#endif	0
@


1.9
log
@make int explicit
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.8 1997/03/21 00:36:40 niklas Exp $	*/
d90 3
a92 3
#define	INKERNEL(va)	(((vm_offset_t)(va)) >= VM_MIN_KERNEL_ADDRESS && \
			 (((vm_offset_t)(va)) < (USRSTACK - MAXSSIZ) || \
			  ((vm_offset_t)(va)) >= USRSTACK))
@


1.9.10.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.9 1998/03/01 14:12:42 niklas Exp $	*/
d90 3
a92 3
#define	INKERNEL(va)	(((vaddr_t)(va)) >= VM_MIN_KERNEL_ADDRESS && \
			 (((vaddr_t)(va)) < (USRSTACK - MAXSSIZ) || \
			  ((vaddr_t)(va)) >= USRSTACK))
@


1.9.10.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.9.10.1 2001/07/04 10:18:19 niklas Exp $	*/
d175 1
a175 1
#endif /* mc68020 */
d225 1
a225 1
#endif /* 0 */
d311 1
a311 1
#endif /* mc68020 */
d371 1
a371 1
#endif /* 0 */
@


1.9.10.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.9.10.2 2001/10/31 03:01:14 nate Exp $	*/
d538 1
a538 2
			if (name == 0) {
				val = MAXINT;
a539 1
			}
@


1.9.10.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a101 2
#define	get16(addr, space) \
		(db_get_value((db_addr_t)(addr), sizeof(u_short), FALSE))
d128 2
a129 2
	db_regs_t *regs;
	struct stackpos *sp;
d173 1
d175 1
d187 1
a187 1
	struct stackpos *sp;
d263 1
a263 1
	struct stackpos *sp;
d306 1
d311 1
d408 2
a409 2
	struct stackpos *sp;
	db_addr_t addr;
d411 1
a411 1
	long instruc, val, i;
a482 1
	int		fault_pc = 0;
d485 2
a486 2
		char *cp = modif;
		char c;
d504 2
a505 2
		pcb_t	t_pcb;
		db_regs_t *user_regs;
a542 40

		/*
		 * Since faultstkadj doesn't set up a valid stack frame,
		 * we would assume it was the source of the fault. To
		 * get around this we peek at the fourth argument of
		 * "trap()" (the stack frame at the time of the fault)
		 * to determine the _real_ value of PC when things wen
		 * wrong.
		 *
		 * NOTE: If the argument list for 'trap()' ever changes,
		 * we lose.
		 */
		if (strcmp("_trap", name) == 0) {
			int tfp;

			/* Point to 'trap()'s 4th argument (frame structure) */
			tfp = pos.k_fp + FR_SAVFP + 4 + (4 * 4);

			/* Determine if fault was from kernel or user mode */
			regp = tfp + offsetof(struct frame, f_sr);
			if (!USERMODE(get16(regp, DSP))) {
				/*
				 * Definitely a kernel mode fault,
				 * so get the PC at the time of the fault.
				 */
				regp = tfp + offsetof(struct frame, f_pc);
				fault_pc = get(regp, DSP);
			}
		} else
		if (fault_pc) {
			if (strcmp("faultstkadj", name) == 0) {
				db_find_sym_and_offset(fault_pc, &name, &val);
				if (name == 0) {
					val = MAXINT;
					name = "?";
				}
			}
			fault_pc = 0;
		}

@


1.9.10.5
log
@Merge in -current from about a week ago
@
text
@d47 1
a47 1
static int db_var_short(struct db_variable *, db_expr_t *, int);
d81 1
a81 1
	*valp = (db_expr_t) *((short *)varp->valuep);
d83 1
a83 1
	*((short *)varp->valuep) = (short) *valp;
d117 4
a120 4
static void findentry(struct stackpos *);
static void findregs(struct stackpos *, db_addr_t);
static int  nextframe(struct stackpos *, int);
static void stacktop(db_regs_t *, struct stackpos *);
@


1.9.10.6
log
@Sync the SMP branch with 3.3
@
text
@d469 1
a469 1
db_stack_trace_print(addr, have_addr, count, modif, pr)
a473 1
	int		(*pr)(const char *, ...);
d582 1
a582 1
		(*pr)("%s", name);
d591 1
a591 1
				(*pr)("(?)\n%s", entry_name);
d594 1
a594 1
		(*pr)("(");
d598 1
a598 1
				(*pr)("%lx", get(regp += 4, DSP));
d600 1
a600 1
					(*pr)(",");
d604 1
a604 1
			(*pr)(") at %x\n", pos.k_pc);
d606 1
a606 1
			(*pr)(") + %lx\n", val);
@


1.8
log
@NetBSD sync to sth like 970218
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.7 1997/01/19 13:53:11 niklas Exp $	*/
d271 2
a272 2
	register	instruc;
	register	val;
@


1.7
log
@From Gordon W Ross (NetBSD):
Use db_regs_t instead of struct mc68020_saved_state
@
text
@d1 2
a2 2
/*	$OpenBSD: db_trace.c,v 1.6 1997/01/13 11:51:13 niklas Exp $	*/
/*	$NetBSD: db_trace.c,v 1.17 1997/01/15 23:11:48 gwr Exp $	*/
d50 21
a70 18
	{ "d0",	(int *)&ddb_regs.d0,	FCN_NULL },
	{ "d1",	(int *)&ddb_regs.d1,	FCN_NULL },
	{ "d2",	(int *)&ddb_regs.d2,	FCN_NULL },
	{ "d3",	(int *)&ddb_regs.d3,	FCN_NULL },
	{ "d4",	(int *)&ddb_regs.d4,	FCN_NULL },
	{ "d5",	(int *)&ddb_regs.d5,	FCN_NULL },
	{ "d6",	(int *)&ddb_regs.d6,	FCN_NULL },
	{ "d7",	(int *)&ddb_regs.d7,	FCN_NULL },
	{ "a0",	(int *)&ddb_regs.a0,	FCN_NULL },
	{ "a1",	(int *)&ddb_regs.a1,	FCN_NULL },
	{ "a2",	(int *)&ddb_regs.a2,	FCN_NULL },
	{ "a3",	(int *)&ddb_regs.a3,	FCN_NULL },
	{ "a4",	(int *)&ddb_regs.a4,	FCN_NULL },
	{ "a5",	(int *)&ddb_regs.a5,	FCN_NULL },
	{ "a6",	(int *)&ddb_regs.a6,	FCN_NULL },
	{ "sp",	(int *)&ddb_regs.sp,	FCN_NULL },
	{ "pc",	(int *)&ddb_regs.pc,	FCN_NULL },
	{ "sr",	(int *)&ddb_regs.sr,	db_var_short }
d131 1
a131 14
	sp->k_regloc[0]  = (int) &regs->d0;
	sp->k_regloc[1]  = (int) &regs->d1;
	sp->k_regloc[2]  = (int) &regs->d2;
	sp->k_regloc[3]  = (int) &regs->d3;
	sp->k_regloc[4]  = (int) &regs->d4;
	sp->k_regloc[5]  = (int) &regs->d5;
	sp->k_regloc[6]  = (int) &regs->d6;
	sp->k_regloc[7]  = (int) &regs->d7;
	sp->k_regloc[8]  = (int) &regs->a0;
	sp->k_regloc[9]  = (int) &regs->a1;
	sp->k_regloc[10] = (int) &regs->a2;
	sp->k_regloc[11] = (int) &regs->a3;
	sp->k_regloc[12] = (int) &regs->a4;
	sp->k_regloc[13] = (int) &regs->a5;
d133 8
a140 2
	sp->k_fp = get(&regs->a6, 0);
	sp->k_pc = get(&regs->pc, 0);
d477 2
a478 1
	int i, val, nargs;
d509 1
a509 1
		get(&t_pcb->user_regs, 0);
d544 1
a544 1
			int	e_val;
d557 1
a557 1
				db_printf("%x", get(regp += 4, DSP));
d565 1
a565 1
			db_printf(") + %x\n", val);
@


1.6
log
@Sync to 970110 NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: db_trace.c,v 1.5 1996/09/21 04:26:38 briggs Exp $	*/
/*	$NetBSD: db_trace.c,v 1.16 1996/04/29 20:50:29 leo Exp $	*/
d115 1
a115 1
static void stacktop __P((struct mc68020_saved_state *, struct stackpos *));
d125 1
a125 1
	register struct mc68020_saved_state *regs;
d508 1
a508 1
		register struct mc68020_saved_state *user_regs;
d511 1
a511 1
		user_regs = (struct mc68020_saved_state *)
@


1.5
log
@Remove references to mc68020.  I think this was suggested by Charles Hannum
a while back, but I made the change a while ago and don't recall now.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.4 1996/05/09 22:30:11 niklas Exp $	*/
d177 1
d179 1
d310 1
d315 1
@


1.4
log
@From NetBSD:
Prototype + -Wall fixes.
Clean up a few printf format strings.
Added an include for the sunos_sendsig prototype
Fix "prototype disagrees about inline" error.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.3 1996/04/19 06:18:16 niklas Exp $	*/
a176 1
#ifdef	mc68020
a177 1
#endif	mc68020
a307 1
#ifdef	mc68020
a311 1
#endif	mc68020
@


1.3
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD: db_trace.c,v 1.2 1996/03/21 00:12:55 niklas Exp $	*/
/*	$NetBSD: db_trace.c,v 1.15 1996/02/22 23:23:41 gwr Exp $	*/
d32 1
d36 2
d47 2
a48 1
static int db_var_short(struct db_variable *, db_expr_t *, int);
d71 2
a72 1
static int db_var_short(varp, valp, op)
d81 1
d112 6
d123 1
d189 1
d194 1
a194 1
	int		val, regp, i;
a196 1
	register int	instruc;
d265 1
d277 1
a277 1
	db_addr_t	addr, calladdr, nextword;
d410 1
d418 1
d481 1
a481 1
	int i, val, nargs, spa;
a485 1
	boolean_t	trace_thread = FALSE;
@


1.2
log
@From NetBSD: eliminate setjmp.h
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: db_trace.c,v 1.14 1996/02/13 17:34:46 gwr Exp $	*/
a44 1
extern int ddb_regs_ssp;
d61 1
a61 2
	{ "ssp",&ddb_regs_ssp,  	FCN_NULL },
	{ "usp",(int *)&ddb_regs.sp,	FCN_NULL },
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: db_trace.c,v 1.12 1995/05/24 20:23:34 gwr Exp $	*/
a31 1
#include <setjmp.h>
d39 1
a39 1
jmp_buf	*db_recover;
d266 2
a267 2
	jmp_buf		db_jmpbuf;
	jmp_buf		*savejmp = db_recover;
d269 3
a271 1
	if (setjmp(*(db_recover = &db_jmpbuf))) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

