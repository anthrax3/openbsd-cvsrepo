head	1.20;
access;
symbols
	OPENBSD_5_5:1.19.0.8
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.4
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.18.0.24
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.22
	OPENBSD_5_0:1.18.0.20
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.18
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.16
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.12
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.14
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.10
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.8
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.20
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.19;

1.19
date	2013.02.02.13.32.06;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.29.13.22.07;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.05.21.19.14;	author martin;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.30.21.27.19;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.27.48;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.09.22.27.09;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.21.20.35.49;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.21.19.48.54;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.27.04.39.05;	author art;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.03.28.22.38.13;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.27.21.38.36;	author art;	state Exp;
branches;
next	1.8;

1.8
date	99.11.13.21.34.06;	author deraadt;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	97.07.06.07.46.27;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.03.26.08.23.54;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.02.10.11.11.50;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.01.13.11.51.11;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.27.11.06.51;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.15.01.53.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.00;	author deraadt;	state Exp;
branches;
next	;

1.8.2.1
date	2001.04.18.16.10.00;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.04.10.18.17;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2002.03.06.01.03.31;	author niklas;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2003.06.07.11.11.39;	author ho;	state Exp;
branches;
next	;

1.11.4.1
date	2002.01.31.22.55.13;	author niklas;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: copy.s,v 1.19 2013/02/02 13:32:06 miod Exp $	*/
/*	$NetBSD: copy.s,v 1.30 1998/03/04 06:39:14 thorpej Exp $	*/

/*-
 * Copyright (c) 1998 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1994, 1995 Charles Hannum.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * This file contains the functions for user-space access:
 * copyin/copyout, etc.
 */

#include <machine/asm.h>

#include "assym.h"

	.file	"copy.s"
	.text

#ifdef	DEBUG
/*
 * The following routines all use the "moves" instruction to access
 * memory with "user" privilege while running in supervisor mode.
 * The "function code" registers actually determine what type of
 * access "moves" does, and the kernel arranges to leave them set
 * for "user data" access when these functions are called.
 *
 * The diagnostics:  CHECK_SFC,  CHECK_DFC
 * will verify that the sfc/dfc register values are correct.
 */
Lbadfc:
	PANIC("copy.s: bad sfc or dfc")
	bra	Lbadfc
#define	CHECK_SFC	movec sfc,d0; subql #FC_USERD,d0; bne Lbadfc
#define	CHECK_DFC	movec dfc,d0; subql #FC_USERD,d0; bne Lbadfc
#else	/* DEBUG */
#define	CHECK_SFC
#define	CHECK_DFC
#endif	/* DEBUG */

/*
 * copyin(caddr_t from, caddr_t to, size_t len);
 * Copy len bytes from the user's address space.
 *
 * This is probably not the best we can do, but it is still 2-10 times
 * faster than the C version in the portable gen directory.
 *
 * Things that might help:
 *	- unroll the longword copy loop (might not be good for a 68020)
 *	- longword align when possible (only on the 68020)
 */
ENTRY(copyin)
	CHECK_SFC
	movl	%sp@@(12),%d0		| check count
	beq	Lciret			| == 0, don't do anything
	movl	%d2,%sp@@-		| save scratch register
	movl	_C_LABEL(curpcb),%a0	| set fault handler
	movl	#Lcifault,%a0@@(PCB_ONFAULT)
	movl	%sp@@(8),%a0		| src address
	movl	%sp@@(12),%a1		| dest address
	movl	%a0,%d1
	btst	#0,%d1			| src address odd?
	beq	Lcieven			| no, skip alignment
	movsb	%a0@@+,%d2		| yes, copy a byte
	movb	%d2,%a1@@+
	subql	#1,%d0			| adjust count
	beq	Lcidone			| count 0, all done
Lcieven:
	movl	%a1,%d1
	btst	#0,%d1			| dest address odd?
	bne	Lcibytes		| yes, must copy bytes
	movl	%d0,%d1			| OK, both even.  Get count
	lsrl	#2,%d1			|   and convert to longwords
	beq	Lcibytes		| count 0, skip longword loop
	subql	#1,%d1			| predecrement for dbf
Lcilloop:
	movsl	%a0@@+,%d2		| copy a longword
	movl	%d2,%a1@@+
	dbf	%d1,Lcilloop		| decrement low word of count
	subil	#0x10000,%d1		| decrement high word of count
	bcc	Lcilloop
	andl	#3,%d0			| what remains
	beq	Lcidone			| nothing, all done
Lcibytes:
	subql	#1,%d0			| predecrement for dbf
Lcibloop:
	movsb	%a0@@+,%d2		| copy a byte
	movb	%d2,%a1@@+
	dbf	%d0,Lcibloop		| decrement low word of count
	subil	#0x10000,%d0		| decrement high word of count
	bcc	Lcibloop
	clrl	%d0			| no error
Lcidone:
	movl	_C_LABEL(curpcb),%a0	| clear fault handler
	clrl	%a0@@(PCB_ONFAULT)
	movl	%sp@@+,%d2		| restore scratch register
Lciret:
	rts
Lcifault:
	moveq	#EFAULT,%d0		| got a fault
	bra	Lcidone

/*
 * copyout(caddr_t from, caddr_t to, size_t len);
 * Copy len bytes into the user's address space.
 *
 * This is probably not the best we can do, but it is still 2-10 times
 * faster than the C version in the portable gen directory.
 *
 * Things that might help:
 *	- unroll the longword copy loop (might not be good for a 68020)
 *	- longword align when possible (only on the 68020)
 */
ENTRY(copyout)
	CHECK_DFC
	movl	%sp@@(12),%d0		| check count
	beq	Lcoret			| == 0, don't do anything
	movl	%d2,%sp@@-		| save scratch register
	movl	_C_LABEL(curpcb),%a0	| set fault handler
	movl	#Lcofault,%a0@@(PCB_ONFAULT)
	movl	%sp@@(8),%a0		| src address
	movl	%sp@@(12),%a1		| dest address
	movl	%a0,%d1
	btst	#0,%d1			| src address odd?
	beq	Lcoeven			| no, skip alignment
	movb	%a0@@+,%d2		| yes, copy a byte
	movsb	%d2,%a1@@+
	subql	#1,%d0			| adjust count
	beq	Lcodone			| count 0, all done
Lcoeven:
	movl	%a1,%d1
	btst	#0,%d1			| dest address odd?
	bne	Lcobytes		| yes, must copy bytes
	movl	%d0,%d1			| OK, both even.  Get count
	lsrl	#2,%d1			|   and convert to longwords
	beq	Lcobytes		| count 0, skip longword loop
	subql	#1,%d1			| predecrement for dbf
Lcolloop:
	movl	%a0@@+,%d2		| copy a longword
	movsl	%d2,%a1@@+
	dbf	%d1,Lcolloop		| decrement low word of count
	subil	#0x10000,%d1		| decrement high word of count
	bcc	Lcolloop
	andl	#3,%d0			| what remains
	beq	Lcodone			| nothing, all done
Lcobytes:
	subql	#1,%d0			| predecrement for dbf
Lcobloop:
	movb	%a0@@+,%d2		| copy a byte
	movsb	%d2,%a1@@+
	dbf	%d0,Lcobloop		| decrement low word of count
	subil	#0x10000,%d0		| decrement high word of count
	bcc	Lcobloop
	clrl	%d0			| no error
Lcodone:
	movl	_C_LABEL(curpcb),%a0	| clear fault handler
	clrl	%a0@@(PCB_ONFAULT)
	movl	%sp@@+,%d2		| restore scratch register
Lcoret:
	rts
Lcofault:
	moveq	#EFAULT,%d0
	bra	Lcodone

/*
 * copystr(caddr_t from, caddr_t to, size_t maxlen, size_t *lencopied);
 * Copy a NUL-terminated string, at most maxlen characters long.  Return the
 * number of characters copied (including the NUL) in *lencopied.  If the
 * string is too long, return ENAMETOOLONG; else return 0.
 */
ENTRY(copystr)
	movl	%sp@@(4),%a0		| a0 = fromaddr
	movl	%sp@@(8),%a1		| a1 = toaddr
	clrl	%d0
	movl	%sp@@(12),%d1		| count
	beq	Lcsdone			| nothing to copy
	subql	#1,%d1			| predecrement for dbeq
Lcsloop:
	movb	%a0@@+,%a1@@+		| copy a byte
	dbeq	%d1,Lcsloop		| decrement low word of count
	beq	Lcsdone			| copied null, exit
	subil	#0x10000,%d1		| decrement high word of count
	bcc	Lcsloop			| more room, keep going
	moveq	#ENAMETOOLONG,%d0	| ran out of space
Lcsdone:
	tstl	%sp@@(16)		| length desired?
	beq	Lcsret
	subl	%sp@@(4),%a0		| yes, calculate length copied
	movl	%sp@@(16),%a1		| store at return location
	movl	%a0,%a1@@
Lcsret:
	rts

/*
 * copyinstr(caddr_t from, caddr_t to, size_t maxlen, size_t *lencopied);
 * Copy a NUL-terminated string, at most maxlen characters long, from the
 * user's address space.  Return the number of characters copied (including
 * the NUL) in *lencopied.  If the string is too long, return ENAMETOOLONG;
 * else return 0 or EFAULT.
 */
ENTRY(copyinstr)
	CHECK_SFC
	movl	_C_LABEL(curpcb),%a0	| set fault handler
	movl	#Lcisfault,%a0@@(PCB_ONFAULT)
	movl	%sp@@(4),%a0		| a0 = fromaddr
	movl	%sp@@(8),%a1		| a1 = toaddr
	clrl	%d0
	movl	%sp@@(12),%d1		| count
	beq	Lcistoolong		| nothing to copy
	subql	#1,%d1			| predecrement for dbeq
Lcisloop:
	movsb	%a0@@+,%d0		| copy a byte
	movb	%d0,%a1@@+
	dbeq	%d1,Lcisloop		| decrement low word of count
	beq	Lcisdone		| copied null, exit
	subil	#0x10000,%d1		| decrement high word of count
	bcc	Lcisloop		| more room, keep going
Lcistoolong:
	moveq	#ENAMETOOLONG,%d0	| ran out of space
Lcisnull:
	cmpl	%sp@@(8),%a1		| do not attempt to clear last byte
	beq	Lcisdone		| if we faulted on first write
	subql	#1, %a1
	clrb	%a1@@+			| clear last byte
Lcisdone:
	tstl	%sp@@(16)		| length desired?
	beq	Lcisexit
	subl	%sp@@(4),%a0		| yes, calculate length copied
	movl	%sp@@(16),%a1		| store at return location
	movl	%a0,%a1@@
Lcisexit:
	movl	_C_LABEL(curpcb),%a0	| clear fault handler
	clrl	%a0@@(PCB_ONFAULT)
	rts
Lcisfault:
	moveq	#EFAULT,%d0
	bra	Lcisnull

/*
 * copyoutstr(caddr_t from, caddr_t to, size_t maxlen, size_t *lencopied);
 * Copy a NUL-terminated string, at most maxlen characters long, into the
 * user's address space.  Return the number of characters copied (including
 * the NUL) in *lencopied.  If the string is too long, return ENAMETOOLONG;
 * else return 0 or EFAULT.
 */
ENTRY(copyoutstr)
	CHECK_DFC
	movl	_C_LABEL(curpcb),%a0	| set fault handler
	movl	#Lcosfault,%a0@@(PCB_ONFAULT)
	movl	%sp@@(4),%a0		| a0 = fromaddr
	movl	%sp@@(8),%a1		| a1 = toaddr
	clrl	%d0
	movl	%sp@@(12),%d1		| count
	beq	Lcostoolong		| nothing to copy
	subql	#1,%d1			| predecrement for dbeq
Lcosloop:
	movb	%a0@@+,%d0		| copy a byte
	movsb	%d0,%a1@@+
	dbeq	%d1,Lcosloop		| decrement low word of count
	beq	Lcosdone		| copied null, exit
	subil	#0x10000,%d1		| decrement high word of count
	bcc	Lcosloop		| more room, keep going
Lcostoolong:
	moveq	#ENAMETOOLONG,%d0	| ran out of space
Lcosdone:
	tstl	%sp@@(16)		| length desired?
	beq	Lcosexit
	subl	%sp@@(4),%a0		| yes, calculate length copied
	movl	%sp@@(16),%a1		| store at return location
	movl	%a0,%a1@@
Lcosexit:
	movl	_C_LABEL(curpcb),%a0	| clear fault handler
	clrl	%a0@@(PCB_ONFAULT)
	rts
Lcosfault:
	moveq	#EFAULT,%d0
	bra	Lcosdone

/*
 * kcopy(const void *src, void *dst, size_t len);
 *
 * Copy len bytes from src to dst, aborting if we encounter a fatal
 * page fault.
 *
 * kcopy() _must_ save and restore the old fault handler since it is
 * called by uiomove(), which may be in the path of servicing a non-fatal
 * page fault.
 */
ENTRY(kcopy)
	link	%a6,#-4
	movl	_C_LABEL(curpcb),%a0	 | set fault handler
	movl	%a0@@(PCB_ONFAULT),%a6@@(-4) | save old handler first
	movl    #Lkcfault,%a0@@(PCB_ONFAULT)
	movl    %a6@@(16),%sp@@-		| push len
	movl    %a6@@(12),%sp@@-		| push dst
	movl    %a6@@(8),%sp@@-		| push src
	jbsr    _C_LABEL(bcopy)		| copy it
	addl    #12,%sp			| pop args
	clrl    %d0			| success!
Lkcdone:
	movl	_C_LABEL(curpcb),%a0	| restore fault handler
	movl	%a6@@(-4),%a0@@(PCB_ONFAULT)
	unlk    %a6
	rts
Lkcfault:
	addl    #16,%sp			| pop args and return address
	moveq   #EFAULT,%d0		| indicate a fault
	bra     Lkcdone
@


1.19
log
@Kernel bits for m68k/ELF, mostly from NetBSD. In addition, the `pmod' symbel
in fpsp has to be renamed due to a clash with other parts of the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.s,v 1.18 2006/11/29 13:22:07 miod Exp $	*/
@


1.18
log
@Remove MAPPEDCOPY. It does not work and I am not convinced it is worth
fixing.
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.s,v 1.17 2006/01/05 21:19:14 martin Exp $	*/
d85 1
a85 1
	movl	sp@@(12),d0		| check count
d87 7
a93 7
	movl	d2,sp@@-			| save scratch register
	movl	_C_LABEL(curpcb),a0	| set fault handler
	movl	#Lcifault,a0@@(PCB_ONFAULT)
	movl	sp@@(8),a0		| src address
	movl	sp@@(12),a1		| dest address
	movl	a0,d1
	btst	#0,d1			| src address odd?
d95 3
a97 3
	movsb	a0@@+,d2			| yes, copy a byte
	movb	d2,a1@@+
	subql	#1,d0			| adjust count
d100 2
a101 2
	movl	a1,d1
	btst	#0,d1			| dest address odd?
d103 2
a104 2
	movl	d0,d1			| OK, both even.  Get count
	lsrl	#2,d1			|   and convert to longwords
d106 1
a106 1
	subql	#1,d1			| predecrement for dbf
d108 4
a111 4
	movsl	a0@@+,d2			| copy a longword
	movl	d2,a1@@+
	dbf	d1,Lcilloop		| decrement low word of count
	subil	#0x10000,d1		| decrement high word of count
d113 1
a113 1
	andl	#3,d0			| what remains
d116 1
a116 1
	subql	#1,d0			| predecrement for dbf
d118 4
a121 4
	movsb	a0@@+,d2			| copy a byte
	movb	d2,a1@@+
	dbf	d0,Lcibloop		| decrement low word of count
	subil	#0x10000,d0		| decrement high word of count
d123 1
a123 1
	clrl	d0			| no error
d125 3
a127 3
	movl	_C_LABEL(curpcb),a0	| clear fault handler
	clrl	a0@@(PCB_ONFAULT)
	movl	sp@@+,d2			| restore scratch register
d131 1
a131 1
	moveq	#EFAULT,d0		| got a fault
d147 1
a147 1
	movl	sp@@(12),d0		| check count
d149 7
a155 7
	movl	d2,sp@@-			| save scratch register
	movl	_C_LABEL(curpcb),a0	| set fault handler
	movl	#Lcofault,a0@@(PCB_ONFAULT)
	movl	sp@@(8),a0		| src address
	movl	sp@@(12),a1		| dest address
	movl	a0,d1
	btst	#0,d1			| src address odd?
d157 3
a159 3
	movb	a0@@+,d2			| yes, copy a byte
	movsb	d2,a1@@+
	subql	#1,d0			| adjust count
d162 2
a163 2
	movl	a1,d1
	btst	#0,d1			| dest address odd?
d165 2
a166 2
	movl	d0,d1			| OK, both even.  Get count
	lsrl	#2,d1			|   and convert to longwords
d168 1
a168 1
	subql	#1,d1			| predecrement for dbf
d170 4
a173 4
	movl	a0@@+,d2			| copy a longword
	movsl	d2,a1@@+
	dbf	d1,Lcolloop		| decrement low word of count
	subil	#0x10000,d1		| decrement high word of count
d175 1
a175 1
	andl	#3,d0			| what remains
d178 1
a178 1
	subql	#1,d0			| predecrement for dbf
d180 4
a183 4
	movb	a0@@+,d2			| copy a byte
	movsb	d2,a1@@+
	dbf	d0,Lcobloop		| decrement low word of count
	subil	#0x10000,d0		| decrement high word of count
d185 1
a185 1
	clrl	d0			| no error
d187 3
a189 3
	movl	_C_LABEL(curpcb),a0	| clear fault handler
	clrl	a0@@(PCB_ONFAULT)
	movl	sp@@+,d2			| restore scratch register
d193 1
a193 1
	moveq	#EFAULT,d0
d203 4
a206 4
	movl	sp@@(4),a0		| a0 = fromaddr
	movl	sp@@(8),a1		| a1 = toaddr
	clrl	d0
	movl	sp@@(12),d1		| count
d208 1
a208 1
	subql	#1,d1			| predecrement for dbeq
d210 2
a211 2
	movb	a0@@+,a1@@+		| copy a byte
	dbeq	d1,Lcsloop		| decrement low word of count
d213 1
a213 1
	subil	#0x10000,d1		| decrement high word of count
d215 1
a215 1
	moveq	#ENAMETOOLONG,d0	| ran out of space
d217 1
a217 1
	tstl	sp@@(16)			| length desired?
d219 3
a221 3
	subl	sp@@(4),a0		| yes, calculate length copied
	movl	sp@@(16),a1		| store at return location
	movl	a0,a1@@
d234 6
a239 6
	movl	_C_LABEL(curpcb),a0	| set fault handler
	movl	#Lcisfault,a0@@(PCB_ONFAULT)
	movl	sp@@(4),a0		| a0 = fromaddr
	movl	sp@@(8),a1		| a1 = toaddr
	clrl	d0
	movl	sp@@(12),d1		| count
d241 1
a241 1
	subql	#1,d1			| predecrement for dbeq
d243 3
a245 3
	movsb	a0@@+,d0			| copy a byte
	movb	d0,a1@@+
	dbeq	d1,Lcisloop		| decrement low word of count
d247 1
a247 1
	subil	#0x10000,d1		| decrement high word of count
d250 1
a250 1
	moveq	#ENAMETOOLONG,d0	| ran out of space
d252 1
a252 1
	cmpl	sp@@(8),a1		| do not attempt to clear last byte
d254 2
a255 2
	subql	#1, a1
	clrb	a1@@+			| clear last byte
d257 1
a257 1
	tstl	sp@@(16)			| length desired?
d259 3
a261 3
	subl	sp@@(4),a0		| yes, calculate length copied
	movl	sp@@(16),a1		| store at return location
	movl	a0,a1@@
d263 2
a264 2
	movl	_C_LABEL(curpcb),a0	| clear fault handler
	clrl	a0@@(PCB_ONFAULT)
d267 1
a267 1
	moveq	#EFAULT,d0
d279 6
a284 6
	movl	_C_LABEL(curpcb),a0	| set fault handler
	movl	#Lcosfault,a0@@(PCB_ONFAULT)
	movl	sp@@(4),a0		| a0 = fromaddr
	movl	sp@@(8),a1		| a1 = toaddr
	clrl	d0
	movl	sp@@(12),d1		| count
d286 1
a286 1
	subql	#1,d1			| predecrement for dbeq
d288 3
a290 3
	movb	a0@@+,d0			| copy a byte
	movsb	d0,a1@@+
	dbeq	d1,Lcosloop		| decrement low word of count
d292 1
a292 1
	subil	#0x10000,d1		| decrement high word of count
d295 1
a295 1
	moveq	#ENAMETOOLONG,d0	| ran out of space
d297 1
a297 1
	tstl	sp@@(16)			| length desired?
d299 3
a301 3
	subl	sp@@(4),a0		| yes, calculate length copied
	movl	sp@@(16),a1		| store at return location
	movl	a0,a1@@
d303 2
a304 2
	movl	_C_LABEL(curpcb),a0	| clear fault handler
	clrl	a0@@(PCB_ONFAULT)
d307 1
a307 1
	moveq	#EFAULT,d0
d321 7
a327 7
	link	a6,#-4
	movl	_C_LABEL(curpcb),a0	 | set fault handler
	movl	a0@@(PCB_ONFAULT),a6@@(-4) | save old handler first
	movl    #Lkcfault,a0@@(PCB_ONFAULT)
	movl    a6@@(16),sp@@-		| push len
	movl    a6@@(12),sp@@-		| push dst
	movl    a6@@(8),sp@@-		| push src
d329 2
a330 2
	addl    #12,sp			| pop args
	clrl    d0			| success!
d332 3
a334 3
	movl	_C_LABEL(curpcb),a0	| restore fault handler
	movl	a6@@(-4),a0@@(PCB_ONFAULT)
	unlk    a6
d337 2
a338 2
	addl    #16,sp			| pop args and return address
	moveq   #EFAULT,d0		| indicate a fault
@


1.17
log
@don't include sys/errno.h, pointed out by Miod
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.s,v 1.16 2004/12/30 21:27:19 miod Exp $	*/
a86 4
#ifdef MAPPEDCOPY
	cmpl	_C_LABEL(mappedcopysize),d0 | size >= mappedcopysize
	bcc	_C_LABEL(mappedcopyin)	| yes, go do it the new way
#endif
a148 4
#ifdef MAPPEDCOPY
	cmpl	_C_LABEL(mappedcopysize),d0 | size >= mappedcopysize
	bcc	_C_LABEL(mappedcopyout)	| yes, go do it the new way
#endif
@


1.16
log
@Do the address space checks only if option DEBUG - nobody has seen them
triggered in BSD since a very, very long time, if ever.
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.s,v 1.15 2003/06/02 23:27:48 millert Exp $	*/
a43 1
#include <sys/errno.h>
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.s,v 1.14 2003/01/09 22:27:09 miod Exp $	*/
d52 1
a52 1
#ifdef	DIAGNOSTIC
d68 1
a68 1
#else	/* DIAGNOSTIC */
d71 1
a71 1
#endif	/* DIAGNOSTIC */
@


1.14
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.s,v 1.13 2002/01/21 20:35:49 miod Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@Argh, correctly handle the maxlen == 0 case.
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.s,v 1.11 2001/06/27 04:39:05 art Exp $	*/
d45 1
a45 1
 * copyin/copyout, fuword/suword, etc.
a352 139

/*
 * fuword(caddr_t uaddr);
 * Fetch an int from the user's address space.
 */
ENTRY(fuword)
	CHECK_SFC
	movl	sp@@(4),a0		| address to read
	movl	_C_LABEL(curpcb),a1	| set fault handler
	movl	#Lferr,a1@@(PCB_ONFAULT)
	movsl	a0@@,d0			| do read from user space
	bra	Lfdone

/*
 * fusword(caddr_t uaddr);
 * Fetch a short from the user's address space.
 */
ENTRY(fusword)
	CHECK_SFC
	movl	sp@@(4),a0		| address to read
	movl	_C_LABEL(curpcb),a1	| set fault handler
	movl	#Lferr,a1@@(PCB_ONFAULT)
	moveq	#0,d0
	movsw	a0@@,d0			| do read from user space
	bra	Lfdone

/*
 * fuswintr(caddr_t uaddr);
 * Fetch a short from the user's address space.
 * Can be called during an interrupt.
 */
ENTRY(fuswintr)
	CHECK_SFC
	movl	sp@@(4),a0		| address to read
	movl	_C_LABEL(curpcb),a1	| set fault handler
	movl	#_fubail,a1@@(PCB_ONFAULT)
	moveq	#0,d0
	movsw	a0@@,d0			| do read from user space
	bra	Lfdone

/*
 * fubyte(caddr_t uaddr);
 * Fetch a byte from the user's address space.
 */
ENTRY(fubyte)
	CHECK_SFC
	movl	sp@@(4),a0		| address to read
	movl	_C_LABEL(curpcb),a1	| set fault handler
	movl	#Lferr,a1@@(PCB_ONFAULT)
	moveq	#0,d0
	movsb	a0@@,d0			| do read from user space
	bra	Lfdone

/*
 * Error routine for fuswintr.  The fault handler in trap.c
 * checks for pcb_onfault set to this fault handler and
 * "bails out" before calling the VM fault handler.
 * (We can not call VM code from interrupt level.)
 * Same code as Lferr but must have a different address.
 */
ENTRY(fubail)
	nop
Lferr:
	moveq	#-1,d0			| error indicator
Lfdone:
	clrl	a1@@(PCB_ONFAULT) 	| clear fault handler
	rts

/*
 * suword(caddr_t uaddr, int x);
 * Store an int in the user's address space.
 */
ENTRY(suword)
	CHECK_DFC
	movl	sp@@(4),a0		| address to write
	movl	sp@@(8),d0		| value to put there
	movl	_C_LABEL(curpcb),a1	| set fault handler
	movl	#Lserr,a1@@(PCB_ONFAULT)
	movsl	d0,a0@@			| do write to user space
	moveq	#0,d0			| indicate no fault
	bra	Lsdone

/*
 * susword(caddr_t uaddr, short x);
 * Store a short in the user's address space.
 */
ENTRY(susword)
	CHECK_DFC
	movl	sp@@(4),a0		| address to write
	movw	sp@@(10),d0		| value to put there
	movl	_C_LABEL(curpcb),a1	| set fault handler
	movl	#Lserr,a1@@(PCB_ONFAULT)
	movsw	d0,a0@@			| do write to user space
	moveq	#0,d0			| indicate no fault
	bra	Lsdone

/*
 * suswintr(caddr_t uaddr, short x);
 * Store a short in the user's address space.
 * Can be called during an interrupt.
 */
ENTRY(suswintr)
	CHECK_DFC
	movl	sp@@(4),a0		| address to write
	movw	sp@@(10),d0		| value to put there
	movl	_C_LABEL(curpcb),a1	| set fault handler
	movl	#_subail,a1@@(PCB_ONFAULT)
	movsw	d0,a0@@			| do write to user space
	moveq	#0,d0			| indicate no fault
	bra	Lsdone

/*
 * subyte(caddr_t uaddr, char x);
 * Store a byte in the user's address space.
 */
ENTRY(subyte)
	CHECK_DFC
	movl	sp@@(4),a0		| address to write
	movb	sp@@(11),d0		| value to put there
	movl	_C_LABEL(curpcb),a1	| set fault handler
	movl	#Lserr,a1@@(PCB_ONFAULT)
	movsb	d0,a0@@			| do write to user space
	moveq	#0,d0			| indicate no fault
	bra	Lsdone

/*
 * Error routine for suswintr.  The fault handler in trap.c
 * checks for pcb_onfault set to this fault handler and
 * "bails out" before calling the VM fault handler.
 * (We can not call VM code from interrupt level.)
 * Same code as Lserr but must have a different address.
 */
ENTRY(subail)
	nop
Lserr:
	moveq	#-1,d0			| error indicator
Lsdone:
	clrl	a1@@(PCB_ONFAULT) 	| clear fault handler
	rts
@


1.12
log
@Always clear the destination string in copyinstr() on error, unless we faulted
when writing to the first character.

With some help from millert@@.
@
text
@d265 2
a280 2
	cmpl	sp@@(8),a1		| do not attempt to clear last byte
	beq	Lcisdone		| if we faulted on first write
@


1.11
log
@kill old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.s,v 1.10 2001/03/28 22:38:13 art Exp $	*/
d264 3
d279 3
a281 1
	bra	Lcisdone
@


1.11.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.s,v 1.13 2002/01/21 20:35:49 miod Exp $	*/
a263 5
Lcisnull:
	cmpl	sp@@(8),a1		| do not attempt to clear last byte
	beq	Lcisdone		| if we faulted on first write
	subql	#1, a1
	clrb	a1@@+			| clear last byte
d276 1
a276 1
	bra	Lcisnull
@


1.11.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
a45 1
 * copyin/copyout, etc.
d353 139
@


1.10
log
@kcopy must restore the previous pcbonfault, not zero it.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.s,v 1.9 2000/05/27 21:38:36 art Exp $	*/
a317 1
#if defined(UVM)
a347 1
#endif /* UVM */
@


1.9
log
@kcopy, needed by UVM.
From NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: copy.s,v 1.8 1999/11/13 21:34:06 deraadt Exp $	*/
/*	$NetBSD: copy.s,v 1.29 1998/02/15 21:18:45 thorpej Exp $	*/
d322 6
a327 1
 * Copy len bytes from src to dst, aborting if we encounter a page fault.
d330 3
a332 2
	link    a6,#0
	movl    _C_LABEL(curpcb),a0	| set fault handler
d341 2
a342 2
	movl    _C_LABEL(curpcb),a0	| clear fault handler
	clrl    a0@@(PCB_ONFAULT)
@


1.8
log
@overflow fixes; netbsd
@
text
@d1 2
a2 2
/*	$OpenBSD: copy.s,v 1.7 1997/07/06 07:46:27 downsj Exp $	*/
/*	$NetBSD: copy.s,v 1.28 1997/05/21 03:51:04 jeremy Exp $	*/
d5 1
d317 27
@


1.8.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: copy.s,v 1.10 2001/03/28 22:38:13 art Exp $	*/
/*	$NetBSD: copy.s,v 1.30 1998/03/04 06:39:14 thorpej Exp $	*/
a4 1
 * Copyright (c) 1998 Jason R. Thorpe.  All rights reserved.
a315 33

#if defined(UVM)
/*
 * kcopy(const void *src, void *dst, size_t len);
 *
 * Copy len bytes from src to dst, aborting if we encounter a fatal
 * page fault.
 *
 * kcopy() _must_ save and restore the old fault handler since it is
 * called by uiomove(), which may be in the path of servicing a non-fatal
 * page fault.
 */
ENTRY(kcopy)
	link	a6,#-4
	movl	_C_LABEL(curpcb),a0	 | set fault handler
	movl	a0@@(PCB_ONFAULT),a6@@(-4) | save old handler first
	movl    #Lkcfault,a0@@(PCB_ONFAULT)
	movl    a6@@(16),sp@@-		| push len
	movl    a6@@(12),sp@@-		| push dst
	movl    a6@@(8),sp@@-		| push src
	jbsr    _C_LABEL(bcopy)		| copy it
	addl    #12,sp			| pop args
	clrl    d0			| success!
Lkcdone:
	movl	_C_LABEL(curpcb),a0	| restore fault handler
	movl	a6@@(-4),a0@@(PCB_ONFAULT)
	unlk    a6
	rts
Lkcfault:
	addl    #16,sp			| pop args and return address
	moveq   #EFAULT,d0		| indicate a fault
	bra     Lkcdone
#endif /* UVM */
@


1.8.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.s,v 1.8.2.1 2001/04/18 16:10:00 niklas Exp $	*/
d318 1
d349 1
@


1.8.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a263 5
Lcisnull:
	cmpl	sp@@(8),a1		| do not attempt to clear last byte
	beq	Lcisdone		| if we faulted on first write
	subql	#1, a1
	clrb	a1@@+			| clear last byte
d276 1
a276 1
	bra	Lcisnull
@


1.8.2.4
log
@Sync the SMP branch with 3.3
@
text
@d45 1
a45 1
 * copyin/copyout, etc.
d353 139
@


1.8.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.s,v 1.8.2.4 2003/03/27 23:28:43 niklas Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7
log
@Sync with NetBSD changes, 970415 - 970705.

This includes a new asm.h, as well as even more code abstracted from hp300.
These changes are likely to break ports that don't know about them; hp300
runs at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: copy.s,v 1.6 1997/03/26 08:23:54 downsj Exp $	*/
d252 1
a252 1
	beq	Lcisdone		| nothing to copy
d261 1
d292 1
a292 1
	beq	Lcosdone		| nothing to copy
d301 1
@


1.6
log
@Merge changes from NetBSD, 3/19/97; enforce use of new files in file.m68k.

All of the m68k ports need fixing, in various ways.  From a casual look,
mvme68k and sun3 need the most work.

Tested on hp300, from which sig_machdep.c is based.
@
text
@d1 2
a2 2
/*	$OpenBSD: copy.s,v 1.5 1997/02/10 11:11:50 downsj Exp $	*/
/*	$NetBSD: copy.s,v 1.26 1997/03/17 19:46:36 gwr Exp $	*/
d66 5
a70 9
Lbadfc_msg:
	.asciz	"copy.s: bad sfc or dfc"
	.even
badfc:
	pea	Lbadfc_msg
	jsr	_panic
	bra	badfc
#define	CHECK_SFC	movec sfc,d0; subql #FC_USERD,d0; bne badfc
#define	CHECK_DFC	movec dfc,d0; subql #FC_USERD,d0; bne badfc
a75 6
#ifdef	MAPPEDCOPY
	.globl	_mappedcopyin
	.globl	_mappedcopyout
	.globl	_mappedcopysize
#endif

d92 2
a93 2
	cmpl	_mappedcopysize,d0	| size >= mappedcopysize
	bcc	_mappedcopyin		| yes, go do it the new way
d96 1
a96 1
	movl	_curpcb,a0		| set fault handler
d133 1
a133 1
	movl	_curpcb,a0		| clear fault handler
d158 2
a159 2
	cmpl	_mappedcopysize,d0	| size >= mappedcopysize
	bcc	_mappedcopyout		| yes, go do it the new way
d162 1
a162 1
	movl	_curpcb,a0		| set fault handler
d199 1
a199 1
	movl	_curpcb,a0		| clear fault handler
d246 1
a246 1
	movl	_curpcb,a0		| set fault handler
d269 1
a269 1
	movl	_curpcb,a0		| clear fault handler
d285 1
a285 1
	movl	_curpcb,a0		| set fault handler
d308 1
a308 1
	movl	_curpcb,a0		| clear fault handler
d322 1
a322 1
	movl	_curpcb,a1		| set fault handler
d334 1
a334 1
	movl	_curpcb,a1		| set fault handler
d348 1
a348 1
	movl	_curpcb,a1		| set fault handler
d361 1
a361 1
	movl	_curpcb,a1		| set fault handler
d390 1
a390 1
	movl	_curpcb,a1		| set fault handler
d397 2
a398 2
 * fusword(caddr_t uaddr);
 * Fetch a short from the user's address space.
d404 1
a404 1
	movl	_curpcb,a1		| set fault handler
d419 1
a419 1
	movl	_curpcb,a1		| set fault handler
d433 1
a433 1
	movl	_curpcb,a1		| set fault handler
@


1.5
log
@Add the generic m68k part of the copypage/zeropage/mappedcopy changes
from NetBSD.

m68k ports may/will need changing in order to cope with this.
@
text
@d1 2
a2 2
/*	$OpenBSD: copy.s,v 1.4 1997/01/13 11:51:11 niklas Exp $	*/
/*	$NetBSD: copy.s,v 1.25 1997/02/02 06:50:06 thorpej Exp $	*/
d42 5
a461 132
	rts

/*
 * {ov}bcopy(from, to, len)
 * memcpy(to, from, len)
 *
 * Works for counts up to 128K.
 */
ALTENTRY(memmove, _memcpy)
ENTRY(memcpy)
	movl	sp@@(12),d0		| get count
	jeq	Lbccpyexit		| if zero, return
	movl	sp@@(8), a0		| src address
	movl	sp@@(4), a1		| dest address
	jra	Lbcdocopy		| jump into bcopy
ALTENTRY(ovbcopy, _bcopy)
ENTRY(bcopy)
	movl	sp@@(12),d0		| get count
	jeq	Lbccpyexit		| if zero, return
	movl	sp@@(4),a0		| src address
	movl	sp@@(8),a1		| dest address
Lbcdocopy:
	cmpl	a1,a0			| src before dest?
	jlt	Lbccpyback		| yes, copy backwards (avoids overlap)
	movl	a0,d1
	btst	#0,d1			| src address odd?
	jeq	Lbccfeven		| no, go check dest
	movb	a0@@+,a1@@+		| yes, copy a byte
	subql	#1,d0			| update count
	jeq	Lbccpyexit		| exit if done
Lbccfeven:
	movl	a1,d1
	btst	#0,d1			| dest address odd?
	jne	Lbccfbyte		| yes, must copy by bytes
	movl	d0,d1			| no, get count
	lsrl	#2,d1			| convert to longwords
	jeq	Lbccfbyte		| no longwords, copy bytes
	subql	#1,d1			| set up for dbf
Lbccflloop:
	movl	a0@@+,a1@@+		| copy longwords
	dbf	d1,Lbccflloop		| til done
	andl	#3,d0			| get remaining count
	jeq	Lbccpyexit		| done if none
Lbccfbyte:
	subql	#1,d0			| set up for dbf
Lbccfbloop:
	movb	a0@@+,a1@@+		| copy bytes
	dbf	d0,Lbccfbloop		| til done
Lbccpyexit:
	rts
Lbccpyback:
	addl	d0,a0			| add count to src
	addl	d0,a1			| add count to dest
	movl	a0,d1
	btst	#0,d1			| src address odd?
	jeq	Lbccbeven		| no, go check dest
	movb	a0@@-,a1@@-		| yes, copy a byte
	subql	#1,d0			| update count
	jeq	Lbccpyexit		| exit if done
Lbccbeven:
	movl	a1,d1
	btst	#0,d1			| dest address odd?
	jne	Lbccbbyte		| yes, must copy by bytes
	movl	d0,d1			| no, get count
	lsrl	#2,d1			| convert to longwords
	jeq	Lbccbbyte		| no longwords, copy bytes
	subql	#1,d1			| set up for dbf
Lbccblloop:
	movl	a0@@-,a1@@-		| copy longwords
	dbf	d1,Lbccblloop		| til done
	andl	#3,d0			| get remaining count
	jeq	Lbccpyexit		| done if none
Lbccbbyte:
	subql	#1,d0			| set up for dbf
Lbccbbloop:
	movb	a0@@-,a1@@-		| copy bytes
	dbf	d0,Lbccbbloop		| til done
	rts

/*
 * copypage(fromaddr, toaddr)
 *
 * Optimized version of bcopy for a single page-aligned NBPG byte copy.
 */
ENTRY(copypage)
	movl	sp@@(4),a0		| source address
	movl	sp@@(8),a1		| destiniation address
	movl	#NBPG/32-1,d0		| number of 32 byte chunks - 1
#if defined(M68040) || defined(M68060)
#if defined(M68020) || defined(M68030)
	cmpl	#CPU_68030,_cputype	| 68030 or less?
	jle	Lmlloop			| yes, use movl
#endif /* M68020 || M68030 */
Lm16loop:
	.long	0xf6209000		| move16 a0@@+,a1@@+
	.long	0xf6209000		| move16 a0@@+,a1@@+
	dbf	d0,Lm16loop
	rts
#endif /* M68040 || M68060 */
#if defined(M68020) || defined(M68030)
Lmlloop:
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	movl	a0@@+,a1@@+
	dbf	d0,Lmlloop
#endif /* M68020 || M68030 */
	rts

/*
 * zeropage(addr)
 *
 * Optimized version of bzero for a single page-aligned NBPG byte zero.
 */
ENTRY(zeropage)
	movl	sp@@(4),a0		| dest address
	movl	#NBPG/32-1,d0		| number of 32 byte chunks - 1
	movq	#0,d1
Lzloop:
	movl	d1,a0@@+
	movl	d1,a0@@+
	movl	d1,a0@@+
	movl	d1,a0@@+
	movl	d1,a0@@+
	movl	d1,a0@@+
	movl	d1,a0@@+
	movl	d1,a0@@+
	dbf	d0,Lzloop
@


1.4
log
@Sync to 970110 NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: copy.s,v 1.3 1996/02/27 11:06:51 niklas Exp $	*/
/*	$NetBSD: copy.s,v 1.24 1996/07/20 01:53:42 jtc Exp $	*/
d534 55
@


1.3
log
@From NetBSD: assym.s -> assym.h
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: copy.s,v 1.22 1995/12/11 02:37:55 thorpej Exp $	*/
d465 1
@


1.2
log
@common bcopy used by all the m68k ports
@
text
@d1 1
d45 1
a45 1
#include "assym.s"
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: copy.s,v 1.21 1995/02/11 21:59:29 mycroft Exp $	*/
d458 75
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
