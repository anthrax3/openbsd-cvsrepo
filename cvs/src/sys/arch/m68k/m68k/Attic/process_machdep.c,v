head	1.7;
access;
symbols
	OPENBSD_5_5:1.6.0.42
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.38
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.36
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.34
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.32
	OPENBSD_5_0:1.6.0.30
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.28
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.26
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.22
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.24
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.20
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.18
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.16
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.14
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.12
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.10
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.8
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.6
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.4
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.5.0.10
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.8
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.4.0.4
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.20
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.14
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.6;

1.6
date	2004.04.12.15.28.38;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.00.42.24;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.23.05.40.57;	author art;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	97.01.19.03.14.12;	author briggs;	state Exp;
branches
	1.3.14.1;
next	1.2;

1.2
date	96.05.09.22.30.12;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.01;	author deraadt;	state Exp;
branches;
next	;

1.3.14.1
date	2001.07.04.10.18.21;	author niklas;	state Exp;
branches;
next	1.3.14.2;

1.3.14.2
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.3.14.3;

1.3.14.3
date	2004.06.05.23.10.51;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2002.06.11.03.36.07;	author art;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: process_machdep.c,v 1.6 2004/04/12 15:28:38 kettenis Exp $	*/
/*	$NetBSD: process_machdep.c,v 1.17 1996/05/06 20:05:24 gwr Exp $	*/

/*
 * Copyright (c) 1993 Christopher G. Demetriou
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This file may seem a bit stylized, but that so that it's easier to port.
 * Functions to be implemented here are:
 *
 * process_read_regs(proc, regs)
 *	Get the current user-visible register set from the process
 *	and copy it into the regs structure (<machine/reg.h>).
 *	The process is stopped at the time read_regs is called.
 *
 * process_write_regs(proc, regs)
 *	Update the current register set from the passed in regs
 *	structure.  Take care to avoid clobbering special CPU
 *	registers or privileged bits in the PSL.
 *	The process is stopped at the time write_regs is called.
 *
 * process_sstep(proc)
 *	Arrange for the process to trap after executing a single instruction.
 *
 * process_set_pc(proc)
 *	Set the process's program counter.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/vnode.h>
#include <sys/ptrace.h>
#include <machine/psl.h>
#include <machine/reg.h>

#define	process_frame(p)	(struct frame *)((p)->p_md.md_regs)
#define	process_fpframe(p)	&((p)->p_addr->u_pcb.pcb_fpregs)

int
process_read_regs(p, regs)
	struct proc *p;
	struct reg *regs;
{
	struct frame *frame = process_frame(p);

	bcopy(frame->f_regs, regs->r_regs, sizeof(frame->f_regs));
	regs->r_sr = frame->f_sr;
	regs->r_pc = frame->f_pc;

	return (0);
}

int
process_read_fpregs(p, regs)
	struct proc *p;
	struct fpreg *regs;
{
	struct fpframe *frame = process_fpframe(p);

	bcopy(frame->fpf_regs, regs->r_regs, sizeof(frame->fpf_regs));
	regs->r_fpcr = frame->fpf_fpcr;
	regs->r_fpsr = frame->fpf_fpsr;
	regs->r_fpiar = frame->fpf_fpiar;

	return (0);
}

#ifdef PTRACE

int
process_write_regs(p, regs)
	struct proc *p;
	struct reg *regs;
{
	struct frame *frame = process_frame(p);

	/*
	 * in the hp300 machdep.c _write_regs, PC alignment wasn't
	 * checked.  If an odd address is placed in the PC and the
	 * program is allowed to run, it will cause an Address Error
	 * which will be transmitted to the process by a SIGBUS.
	 * No reasonable debugger would let this happen, but
	 * it's not our problem.
	 */

	/*
	 * XXX
	 * in hp300 machdep.c, it just cleared/set these bits
	 * automatically.  here, we barf.  well-written programs
	 * shouldn't munge them.
	 */
	if ((regs->r_sr & PSL_USERCLR) != 0 ||
	    (regs->r_sr & PSL_USERSET) != PSL_USERSET)
		return EPERM;

	bcopy(regs->r_regs, frame->f_regs, sizeof(frame->f_regs));
	frame->f_sr = regs->r_sr;
	frame->f_pc = regs->r_pc;

	return (0);
}

int
process_write_fpregs(p, regs)
	struct proc *p;
	struct fpreg *regs;
{
	struct fpframe *frame = process_fpframe(p);

	bcopy(regs->r_regs, frame->fpf_regs, sizeof(frame->fpf_regs));
	frame->fpf_fpcr = regs->r_fpcr;
	frame->fpf_fpsr = regs->r_fpsr;
	frame->fpf_fpiar = regs->r_fpiar;

	return (0);
}

int
process_sstep(p, sstep)
	struct proc *p;
	int sstep;
{
	struct frame *frame = process_frame(p);

	if (sstep)
		frame->f_sr |= PSL_T;
	else
		frame->f_sr &= ~PSL_T;

	return (0);
}

int
process_set_pc(p, addr)
	struct proc *p;
	caddr_t addr;
{
	struct frame *frame = process_frame(p);

	/*
	 * in the hp300 machdep.c _set_pc, PC alignment is guaranteed
	 * by chopping off the low order bit of the new pc.
	 * If an odd address was placed in the PC and the program
	 * is allowed to run, it will cause an Address Error
	 * which will be transmitted to the process by a SIGBUS.
	 * No reasonable debugger would let this happen, but
	 * it's not our problem.
	 */
	frame->f_pc = (u_int)addr;

	return (0);
}

#endif	/* PTRACE */
@


1.6
log
@Fix process_frame macro.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.5 2002/03/14 00:42:24 miod Exp $	*/
@


1.5
log
@Turn the ptrace(2) syscall into a kernel compile option, option PTRACE in
your kernel configuration file.
By default, GENERIC will enable this.

When PTRACE is not enabled, several ptrace-like features of the procfs
filesystem will be disabled as well (namely, the ability to read and write
any process' registers, as well as attching, single stepping and detaching
to/from processes).

This should help paranoid people build better sandboxens, and us to build
smaller ramdisks.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.4 2001/06/23 05:40:57 art Exp $	*/
d66 1
a66 1
#define	process_frame(p)	(struct frame *)&((p)->p_md.md_regs)
@


1.4
log
@Only mips uses cpu_set_init_frame (and it shouldn't)
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.3 1997/01/19 03:14:12 briggs Exp $	*/
d66 2
a67 21
static __inline struct frame   *process_frame __P((struct proc *p));
static __inline struct fpframe *process_fpframe __P((struct proc *p));

static __inline struct frame *
process_frame(p)
	struct proc *p;
{
	void *ptr;

	ptr = p->p_md.md_regs;

	return (ptr);
}

static __inline struct fpframe *
process_fpframe(p)
	struct proc *p;
{

	return (&p->p_addr->u_pcb.pcb_fpregs);
}
d98 2
d183 2
@


1.4.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.4 2001/06/23 05:40:57 art Exp $	*/
d66 21
a86 2
#define	process_frame(p)	(struct frame *)&((p)->p_md.md_regs)
#define	process_fpframe(p)	&((p)->p_addr->u_pcb.pcb_fpregs)
a116 2
#ifdef PTRACE

a199 2

#endif	/* PTRACE */
@


1.3
log
@inline -> __inline
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.2 1996/05/09 22:30:12 niklas Exp $	*/
a65 3
#ifdef cpu_set_init_frame
extern char kstack[];		/* XXX */
#endif
a74 3
#ifdef cpu_set_init_frame
	ptr = (char *)p->p_addr + ((char *)p->p_md.md_regs - (char *)kstack);
#else
d76 1
a76 1
#endif
@


1.3.14.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: process_machdep.c,v 1.3 1997/01/19 03:14:12 briggs Exp $	*/
d66 3
d78 3
d82 1
a82 1

@


1.3.14.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 21
a86 2
#define	process_frame(p)	(struct frame *)&((p)->p_md.md_regs)
#define	process_fpframe(p)	&((p)->p_addr->u_pcb.pcb_fpregs)
a116 2
#ifdef PTRACE

a199 2

#endif	/* PTRACE */
@


1.3.14.3
log
@Merge with the trunk
@
text
@d66 1
a66 1
#define	process_frame(p)	(struct frame *)((p)->p_md.md_regs)
@


1.2
log
@From NetBSD:
Prototype + -Wall fixes.
Clean up a few printf format strings.
Added an include for the sunos_sendsig prototype
Fix "prototype disagrees about inline" error.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 2
a70 2
static inline struct frame   *process_frame __P((struct proc *p));
static inline struct fpframe *process_fpframe __P((struct proc *p));
d72 1
a72 1
static inline struct frame *
d86 1
a86 1
static inline struct fpframe *
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: process_machdep.c,v 1.15 1995/08/13 09:05:51 mycroft Exp $	*/
d69 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
