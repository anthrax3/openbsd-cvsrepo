head	1.21;
access;
symbols
	OPENBSD_5_5:1.20.0.8
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.4
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.2
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.19.0.10
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.8
	OPENBSD_5_0:1.19.0.6
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.4
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.17.0.14
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.16
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.12
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.10
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.8
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	UBC_SYNC_B:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	UBC:1.4.0.2
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.21
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.20;

1.20
date	2013.01.01.01.01.08;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.28.04.20.25;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.13.20.37.00;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.09.19.39.53;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.06.17.50.16;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.11.20.44.20;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.12.23.11.37;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.23.19.00.25;	author martin;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.01.12.06.39;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.14.19.57.48;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.04.18.38.33;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.30.21.22.20;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.27.14.26.30;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.22.19.37.39;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.02.23.27.48;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.02.07.06.56;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.16.20.53.47;	author miod;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2002.03.14.01.26.35;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.27.20.51.01;	author miod;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2002.02.23.04.58.28;	author miod;	state Exp;
branches;
next	;

1.2.2.1
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2003.06.07.11.11.39;	author ho;	state Exp;
branches;
next	;

1.4.2.1
date	2002.06.11.03.36.06;	author art;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: pmap_bootstrap.c,v 1.20 2013/01/01 01:01:08 miod Exp $	*/

/* 
 * Copyright (c) 1995 Theo de Raadt
 * Copyright (c) 1999 Steve Murphree, Jr. (68060 support)
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pmap_bootstrap.c	8.1 (Berkeley) 6/10/93
 */

/*
 * NOTICE: This is not a standalone file.  To use it, #include it in
 * your port's pmap_bootstrap.c, like so:
 *
 * #include <m68k/m68k/pmap_bootstrap.c>
 *
 * after having defined the following macros:
 * RELOC		relocate a variable
 * PA2VA		simple crude mapping for bootstraping
 * PMAP_MD_LOCALS	local variable declaration
 * PMAP_MD_RELOC1()	early variable relocation
 * PMAP_MD_RELOC2()	internal IO space variable relocation
 * PMAP_MD_RELOC3()	general purpose kernel virtual addresses relocation
 * PMAP_MD_MAPIOSPACE()	setup machine-specific internal iospace components
 * PMAP_MD_MEMSIZE()	compute avail_end
 */

extern char *etext;
extern int Sysptsize;
extern char *proc0paddr;
extern st_entry_t *Sysseg;
extern pt_entry_t *Sysptmap, *Sysmap;

extern int physmem;
extern paddr_t avail_start, avail_end;
extern vaddr_t virtual_avail, virtual_end;

void  pmap_bootstrap(paddr_t, paddr_t);

/*
 * Special purpose kernel virtual addresses, used for mapping
 * physical pages for a variety of temporary or permanent purposes:
 *
 *	CADDR1, CADDR2:	pmap zero/copy operations
 *	vmmap:		/dev/mem, crash dumps, parity error checking
 */
#ifndef __HAVE_PMAP_DIRECT
caddr_t		CADDR1, CADDR2;
#endif
caddr_t		vmmap;

/*
 * Bootstrap the VM system.
 *
 * Ideally called with MMU off, but not necessarily.  All global references
 * are relocated by `firstpa' to ensure this works.  Of course, it is not
 * possible to call any other functions from there.  `nextpa' is the first
 * available physical memory address.  Returns an updated first PA reflecting
 * the memory we have allocated.  MMU is still in the same state when we
 * return.
 *
 * XXX assumes sizeof(u_int) == sizeof(pt_entry_t)
 * XXX a PIC compiler would make this much easier.
 */
void
pmap_bootstrap(nextpa, firstpa)
	paddr_t nextpa;
	paddr_t firstpa;
{
	paddr_t kstpa, kptpa, iiopa, eiopa, kptmpa, lkptpa, p0upa;
	vaddr_t iiobase, eiobase;
	u_int nptpages, kstsize;
	st_entry_t protoste, *ste;
	pt_entry_t protopte, *pte, *epte;
	int num;
	PMAP_MD_LOCALS

	/*
	 * Calculate important physical addresses:
	 *
	 *	kstpa		kernel segment table	1 page (020/030)
	 *						N pages (040/060)
	 *
	 *	kptpa		statically allocated
	 *			kernel PT pages		Sysptsize+ pages
	 *
	 *	iiopa		internal IO space
	 *			PT pages		MACHINE_IIOMAPSIZE pages
	 *
	 *	eiopa		external IO space
	 *			PT pages		MACHINE_EIOMAPSIZE pages
	 *
	 * [ Sysptsize is the number of pages of PT, MACHINE_IIOMAPSIZE and
	 *   MACHINE_EIOMAPSIZE are the number of PTEs, hence we need to round
	 *   the total to a page boundary with IO maps at the end. ]
	 *
	 *	kptmpa		kernel PT map		1 page
	 *
	 *	lkptpa		last kernel PT page	1 page
	 *
	 *	p0upa		proc 0 u-area		UPAGES pages
	 *
	 * The KVA corresponding to any of these PAs is:
	 *	(PA - firstpa + KERNBASE).
	 */
	if (RELOC(mmutype, int) <= MMU_68040)
		kstsize = MAXKL2SIZE / (NPTEPG/SG4_LEV2SIZE);
	else
		kstsize = 1;
	kstpa = nextpa;
	nextpa += kstsize * NBPG;
	kptpa = nextpa;

	iiopa = nextpa + RELOC(Sysptsize, int) * NBPG;
	iiobase = ptoa(RELOC(Sysptsize, int) * NPTEPG);
	eiopa = iiopa + MACHINE_IIOMAPSIZE * sizeof(pt_entry_t);
	eiobase = iiobase + ptoa(MACHINE_IIOMAPSIZE);

	/*
	 * Compute how many PT pages we will need to have initialized.
	 * We need to have enough of them for the vm system to initialize
	 * up to the point we can use it to allocate more PT pages - i.e.
	 * when we can afford using pmap_enter_ptpage().
	 *
	 * Aside from the IO maps, we need to be able to successfully
	 * allocate:
	 * - nkmempages_max pages in kmeminit().
	 * - PAGER_MAP_SIZE bytes in uvm_pager_init().
	 * - 93.75 % of physmem anons in amap_init().
	 * - 4 * uvm_km_pages.lowat pages in uvm_km_page_init().
	 *
	 * We'll compute this size in bytes, then round it to pages,
	 * then to a multiple of NPTEPG.
	 */

	nptpages = ptoa(MACHINE_IIOMAPSIZE + MACHINE_EIOMAPSIZE);

	num = RELOC(physmem, int) / 4;
	if (num > NKMEMPAGES_MAX_DEFAULT)
		num = NKMEMPAGES_MAX_DEFAULT;
	nptpages += ptoa(num);

	nptpages += PAGER_MAP_SIZE;

	nptpages += (RELOC(physmem, int) * 15 * sizeof(struct vm_anon)) / 16;

#if !defined(__HAVE_PMAP_DIRECT)
	{
		if ((num = RELOC(uvm_km_pages.lowat, int)) == 0) {
			num = RELOC(physmem, int) / 256;
			if (num < 16)
				num = 32;
			else if (num < 128) {
				num = 128;
				if (num > UVM_KM_PAGES_LOWAT_MAX)
					num = UVM_KM_PAGES_LOWAT_MAX;
			}
		}
	}
	nptpages += ptoa(4 * num);
#endif

	nptpages = (atop(round_page(nptpages)) + NPTEPG - 1) / NPTEPG;

	nextpa += nptpages * NBPG;

	kptmpa = nextpa;
	nextpa += NBPG;
	lkptpa = nextpa;
	nextpa += NBPG;
	p0upa = nextpa;
	nextpa += USPACE;

	PMAP_MD_RELOC1();

	/*
	 * Initialize segment table and kernel page table map.
	 *
	 * On 68030s and earlier MMUs the two are identical except for
	 * the valid bits so both are initialized with essentially the
	 * same values.  On the 680[46]0, which have a mandatory 3-level
	 * structure, the segment table holds the level 1 table and part
	 * (or all) of the level 2 table and hence is considerably
	 * different.  Here the first level consists of 128 descriptors
	 * (512 bytes) each mapping 32mb of address space.  Each of these
	 * points to blocks of 128 second level descriptors (512 bytes)
	 * each mapping 256kb.  Note that there may be additional "segment
	 * table" pages depending on how large MAXKL2SIZE is.
	 *
	 * Portions of the last segment of KVA space (0xFFF00000 -
	 * 0xFFFFFFFF) are mapped for a couple of purposes.  0xFFF00000
	 * for UPAGES is used for mapping the current process u-area
	 * (u + kernel stack).  The very last page (0xFFFFF000) is mapped
	 * to the last physical page of RAM to give us a region in which
	 * PA == VA.  We use the first part of this page for enabling
	 * and disabling mapping.  The last part of this page also contains
	 * info left by the boot ROM.
	 *
	 * XXX cramming two levels of mapping into the single "segment"
	 * table on the 68040 is intended as a temporary hack to get things
	 * working.  The 224mb of address space that this allows will most
	 * likely be insufficient in the future (at least for the kernel).
	 */
	if (RELOC(mmutype, int) <= MMU_68040) {
		/*
		 * First invalidate the entire "segment table" pages
		 * (levels 1 and 2 have the same "invalid" value).
		 */
		pte = PA2VA(kstpa, u_int *);
		epte = &pte[kstsize * NPTEPG];
		while (pte < epte)
			*pte++ = SG_NV;
		/*
		 * Initialize level 2 descriptors (which immediately
		 * follow the level 1 table).  We need:
		 *	NPTEPG / SG4_LEV3SIZE
		 * level 2 descriptors to map each of the nptpages+1
		 * pages of PTEs.  Note that we set the "used" bit
		 * now to save the HW the expense of doing it.
		 */
		num = (nptpages + 1) * (NPTEPG / SG4_LEV3SIZE);
		pte = &(PA2VA(kstpa, u_int *))[SG4_LEV1SIZE];
		epte = &pte[num];
		protoste = kptpa | SG_U | SG_RW | SG_V;
		while (pte < epte) {
			*pte++ = protoste;
			protoste += (SG4_LEV3SIZE * sizeof(st_entry_t));
		}
		/*
		 * Initialize level 1 descriptors.  We need:
		 *	roundup(num, SG4_LEV2SIZE) / SG4_LEV2SIZE
		 * level 1 descriptors to map the `num' level 2's.
		 */
		pte = PA2VA(kstpa, u_int *);
		epte = &pte[roundup(num, SG4_LEV2SIZE) / SG4_LEV2SIZE];
		protoste = (u_int)&pte[SG4_LEV1SIZE] | SG_U | SG_RW | SG_V;
		while (pte < epte) {
			*pte++ = protoste;
			protoste += (SG4_LEV2SIZE * sizeof(st_entry_t));
		}
		/*
		 * Initialize the final level 1 descriptor to map the last
		 * block of level 2 descriptors.
		 */
		ste = &(PA2VA(kstpa, u_int *))[SG4_LEV1SIZE-1];
		pte = &(PA2VA(kstpa, u_int *))[kstsize*NPTEPG - SG4_LEV2SIZE];
		*ste = (u_int)pte | SG_U | SG_RW | SG_V;
		/*
		 * Now initialize the final portion of that block of
		 * descriptors to map the "last PT page".
		 */
		pte = &(PA2VA(kstpa, u_int *))
		    [kstsize*NPTEPG - NPTEPG/SG4_LEV3SIZE];
		epte = &pte[NPTEPG/SG4_LEV3SIZE];
		protoste = lkptpa | SG_U | SG_RW | SG_V;
		while (pte < epte) {
			*pte++ = protoste;
			protoste += (SG4_LEV3SIZE * sizeof(st_entry_t));
		}
		/*
		 * Initialize Sysptmap
		 */
		pte = PA2VA(kptmpa, u_int *);
		epte = &pte[nptpages+1];
		protopte = kptpa | PG_RW | PG_CI | PG_V | PG_U;
		while (pte < epte) {
			*pte++ = protopte;
			protopte += NBPG;
		}
		/*
		 * Invalidate all but the last remaining entry.
		 */
		epte = &(PA2VA(kptmpa, u_int *))[NPTEPG-1];
		while (pte < epte) {
			*pte++ = PG_NV;
		}
		/*
		 * Initialize the last to point to the page
		 * table page allocated earlier.
		 */
		*pte = lkptpa | PG_RW | PG_CI | PG_V | PG_U;
	} else {
		/*
		 * Map the page table pages in both the HW segment table
		 * and the software Sysptmap.  Note that Sysptmap is also
		 * considered a PT page hence the +1.
		 */
		ste = PA2VA(kstpa, u_int *);
		pte = PA2VA(kptmpa, u_int *);
		epte = &pte[nptpages+1];
		protoste = kptpa | SG_RW | SG_V;
		protopte = kptpa | PG_RW | PG_CI | PG_V;
		while (pte < epte) {
			*ste++ = protoste;
			*pte++ = protopte;
			protoste += NBPG;
			protopte += NBPG;
		}
		/*
		 * Invalidate all but the last remaining entries in both.
		 */
		epte = &(PA2VA(kptmpa, u_int *))[NPTEPG-1];
		while (pte < epte) {
			*ste++ = SG_NV;
			*pte++ = PG_NV;
		}
		/*
		 * Initialize the last to point to point to the page
		 * table page allocated earlier.
		 */
		*ste = lkptpa | SG_RW | SG_V;
		*pte = lkptpa | PG_RW | PG_CI | PG_V;
	}
	/*
	 * Invalidate all but the final entry in the last kernel PT page
	 * (u-area PTEs will be validated later).  The final entry maps
	 * the last page of physical memory.
	 */
	pte = PA2VA(lkptpa, u_int *);
	epte = &pte[NPTEPG-1];
	while (pte < epte)
		*pte++ = PG_NV;
#ifdef MAXADDR
	/*
	 * Temporary double-map for machines with physmem at the end of
	 * memory
	 */
	*pte = MAXADDR | PG_RW | PG_CI | PG_V | PG_U;
#else
	*pte = PG_NV;
#endif
	/*
	 * Initialize kernel page table.
	 * Start by invalidating the `nptpages' that we have allocated.
	 */
	pte = PA2VA(kptpa, u_int *);
	epte = &pte[nptpages * NPTEPG];
	while (pte < epte)
		*pte++ = PG_NV;

	/*
	 * Validate PTEs for kernel text (RO).  The first page
	 * of kernel text will remain invalid to force *NULL in the
	 * kernel to fault.
	 */
	pte = &(PA2VA(kptpa, u_int *))[atop(KERNBASE)];
	epte = &pte[atop(trunc_page((vaddr_t)&etext))];

#if defined(KGDB) || defined(DDB)
	protopte = firstpa | PG_RW | PG_V | PG_U; /* XXX RW for now */
#else
	protopte = firstpa | PG_RO | PG_V | PG_U;
#endif
	*pte++ = PG_NV;		/* make *NULL fail in the kernel */
	protopte += PAGE_SIZE;
	while (pte < epte) {
		*pte++ = protopte;
		protopte += PAGE_SIZE;
	}
	/*
	 * Validate PTEs for kernel data/bss, dynamic data allocated
	 * by us so far (nextpa - firstpa bytes), and pages for proc0
	 * u-area and page table allocated below (RW).
	 */
	epte = &(PA2VA(kptpa, u_int *))[atop(nextpa - firstpa)];
	protopte = (protopte & ~PG_PROT) | PG_RW | PG_U;
	/*
	 * Enable copy-back caching of data pages on 040, and write-through
	 * caching on 060
	 */
	if (RELOC(mmutype, int) == MMU_68040)
		protopte |= PG_CCB;
#ifdef M68060
	else if (RELOC(mmutype, int) == MMU_68060)
		protopte |= PG_CWT;
#endif
	while (pte < epte) {
		*pte++ = protopte;
		protopte += NBPG;
	}

	/*
	 * Finally, validate the internal IO space PTEs (RW+CI).
	 * We do this here since on hp300 machines with the HP MMU, the
	 * the MMU registers (also used, but to a lesser extent, on other
	 * models) are mapped in this range and it would be nice to be able
	 * to access them after the MMU is turned on.
	 */
	pte = PA2VA(iiopa, u_int *);
	epte = PA2VA(eiopa, u_int *);
	protopte = MACHINE_INTIOBASE | PG_RW | PG_CI | PG_V | PG_U;
	while (pte < epte) {
		*pte++ = protopte;
		protopte += NBPG;
	}
	PMAP_MD_MAPIOSPACE();

	/*
	 * Calculate important exported kernel virtual addresses
	 */
	/*
	 * Sysseg: base of kernel segment table
	 */
	RELOC(Sysseg, st_entry_t *) =
	    (st_entry_t *)(kstpa - firstpa);
	/*
	 * Sysptmap: base of kernel page table map
	 */
	RELOC(Sysptmap, pt_entry_t *) =
	    (pt_entry_t *)(kptmpa - firstpa);
	/*
	 * Sysmap: kernel page table (as mapped through Sysptmap)
	 * Immediately follows `nptpages' of static kernel page table.
	 */
	RELOC(Sysmap, pt_entry_t *) =
	    (pt_entry_t *)ptoa(nptpages * NPTEPG);

	PMAP_MD_RELOC2();

	/*
	 * Setup u-area for process 0.
	 */

	/* Zero the u-area (`pte' is not really a PTE here) */
	pte = PA2VA(p0upa, u_int *);
	for (num = USPACE / sizeof(u_int); num != 0; num--)
		*pte++ = 0;

	/*
	 * Remember the u-area address so it can be loaded in the
	 * proc struct p_addr field later.
	 */
	RELOC(proc0paddr, char *) = (char *)(p0upa - firstpa);

	/*
	 * VM data structures are now initialized, set up data for
	 * the pmap module.
	 *
	 * Note about avail_end: msgbuf is initialized just after
	 * avail_end in machdep.c.  Since the last page is used
	 * for rebooting the system (code is copied there and
	 * excution continues from copied code before the MMU
	 * is disabled), the msgbuf will get trounced between
	 * reboots if it's placed in the last physical page.
	 * To work around this, we move avail_end back one more
	 * page so the msgbuf can be preserved.
	 */
	RELOC(avail_start, paddr_t) = nextpa;
	PMAP_MD_MEMSIZE();
	RELOC(virtual_avail, vaddr_t) =
	    VM_MIN_KERNEL_ADDRESS + (nextpa - firstpa);
	RELOC(virtual_end, vaddr_t) = VM_MAX_KERNEL_ADDRESS;

	/*
	 * Kernel page/segment table allocated in locore,
	 * just initialize pointers.
	 */
	{
		struct pmap *kpm = &RELOC(kernel_pmap_store, struct pmap);

		kpm->pm_stab = RELOC(Sysseg, st_entry_t *);
		kpm->pm_ptab = RELOC(Sysmap, pt_entry_t *);
		simple_lock_init(&kpm->pm_lock);
		kpm->pm_count = 1;
		kpm->pm_stpa = (st_entry_t *)kstpa;
		/*
		 * For the 040 and 060 we also initialize the free level 2
		 * descriptor mask noting that we have used:
		 *	0:		level 1 table
		 *	1 to `num':	map page tables
		 *	MAXKL2SIZE-1:	maps last-page page table
		 */
		if (RELOC(mmutype, int) <= MMU_68040) {
			int num;
			
			kpm->pm_stfree = ~l2tobm(0);
			num = roundup((nptpages + 1) * (NPTEPG / SG4_LEV3SIZE),
			    SG4_LEV2SIZE) / SG4_LEV2SIZE;
			while (num)
				kpm->pm_stfree &= ~l2tobm(num--);
			kpm->pm_stfree &= ~l2tobm(MAXKL2SIZE-1);
			for (num = MAXKL2SIZE;
			     num < sizeof(kpm->pm_stfree)*NBBY;
			     num++)
				kpm->pm_stfree &= ~l2tobm(num);
		}
	}

	/*
	 * Allocate some fixed, special purpose kernel virtual addresses
	 */
	{
		vaddr_t va = RELOC(virtual_avail, vaddr_t);

#ifndef __HAVE_PMAP_DIRECT
		RELOC(CADDR1, caddr_t) = (caddr_t)va;
		va += NBPG;
		RELOC(CADDR2, caddr_t) = (caddr_t)va;
		va += NBPG;
#endif
		RELOC(vmmap, caddr_t) = (caddr_t)va;
		va += NBPG;

		PMAP_MD_RELOC3();

		RELOC(msgbufp, struct msgbuf *) = (struct msgbuf *)va;
		va += MSGBUFSIZE;
		RELOC(virtual_avail, vaddr_t) = va;
	}
}
@


1.20
log
@Remove unused mem_size global.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.19 2010/06/28 04:20:25 miod Exp $	*/
@


1.19
log
@Move uvm_km_pages struct declaration and watermark bounds to uvm_km.h, so
that md code can peek at it, and update m68k !__HAVE_PMAP_DIRECT setup code
to the recent uvm_km changes.
ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.18 2010/05/13 20:37:00 miod Exp $	*/
a87 1
extern vsize_t mem_size;
a500 1
	RELOC(mem_size, vsize_t) = ptoa(RELOC(physmem, int));
@


1.18
log
@If __HAVE_PMAP_DIRECT, do not bother creating special mappings for use in
pmap_{copy,zero}_page, but use direct mapped pages instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.17 2006/07/09 19:39:53 miod Exp $	*/
d182 1
a182 1
	 * - 4 * uvm_km_pages_lowat pages in uvm_km_page_init().
d201 1
a201 3
		extern int uvm_km_pages_lowat;

		if ((num = RELOC(uvm_km_pages_lowat, int)) == 0) {
d203 3
a205 1
			if (num < 128)
d207 3
d212 1
a212 1
	nptpages += ptoa(num);
@


1.17
log
@Make this compile on platforms which define __HAVE_PMAP_DIRECT.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.16 2006/07/06 17:50:16 miod Exp $	*/
d99 4
a102 1
caddr_t		CADDR1, CADDR2, vmmap;
d545 1
d550 1
@


1.16
log
@PMAP_MD_RWLOW kluge is no longer necessary now that mac68k does TRT.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.15 2006/06/11 20:44:20 miod Exp $	*/
d196 1
d207 1
@


1.15
log
@Move pmap_aliasmask declaration and initialization to MD code. No functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.14 2005/11/12 23:11:37 miod Exp $	*/
a76 1
 * PMAP_MD_RWLOW	number of pages to keep writeable, starting at address 0
a397 6
#ifdef	PMAP_MD_RWLOW
	for (num = PMAP_MD_RWLOW; num != 0; num--) {
		*pte++ = (protopte & ~PG_RO) | PG_RW;
		protopte += PAGE_SIZE;
	}
#else
a399 1
#endif
@


1.14
log
@Compute a rough estimate of exactly how much memory uvm_init() will allocate,
so as to correctly size the initial PT pages, to prevent the early
initialization from invoking pmap_enter_ptpage() [chicken and egg problem].
Much better than the previous arithmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.13 2005/10/23 19:00:25 martin Exp $	*/
a89 3
#ifdef M68K_MMU_HP
extern int pmap_aliasmask;
#endif
a505 12

#ifdef M68K_MMU_HP
	/*
	 * Determine VA aliasing distance if any
	 */
	if (RELOC(ectype, int) == EC_VIRT) {
		if (RELOC(machineid, int) == HP_320)
			RELOC(pmap_aliasmask, int) = 0x3fff;	/* 16k */
		else if (RELOC(machineid, int) == HP_350)
			RELOC(pmap_aliasmask, int) = 0x7fff;	/* 32k */
	}
#endif
@


1.13
log
@m68k_btop() and m68k_ptob() were mostly used by mac68k only and can
be replaced by the MI versions atop() and ptoa()
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.12 2005/08/01 12:06:39 miod Exp $	*/
d173 14
a186 2
	 * We need to be able to map a whole UPT here as well. Adjust
	 * nptpages if necessary.
d188 25
a212 3
	nptpages = (MACHINE_IIOMAPSIZE + MACHINE_EIOMAPSIZE +
	    atop(MACHINE_MAX_PTSIZE) * sizeof(pt_entry_t) + NPTEPG - 1) /
	    NPTEPG;
@


1.12
log
@Thinko in 68060-only #ifdef line.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.11 2005/01/14 19:57:48 miod Exp $	*/
d168 1
a168 1
	iiobase = m68k_ptob(RELOC(Sysptsize, int) * NPTEPG);
d170 1
a170 1
	eiobase = iiobase + m68k_ptob(MACHINE_IIOMAPSIZE);
d177 1
a177 1
	    m68k_btop(MACHINE_MAX_PTSIZE) * sizeof(pt_entry_t) + NPTEPG - 1) /
d360 2
a361 2
	pte = &(PA2VA(kptpa, u_int *))[m68k_btop(KERNBASE)];
	epte = &pte[m68k_btop(trunc_page((vaddr_t)&etext))];
d386 1
a386 1
	epte = &(PA2VA(kptpa, u_int *))[m68k_btop(nextpa - firstpa)];
d437 1
a437 1
	    (pt_entry_t *)m68k_ptob(nptpages * NPTEPG);
d471 1
a471 1
	RELOC(mem_size, vsize_t) = m68k_ptob(RELOC(physmem, int));
@


1.11
log
@Even better nptpages computation without unnecessary extra roundings; allows
extra large iomaps to work correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.10 2005/01/04 18:38:33 miod Exp $	*/
d394 1
a394 1
#ifdef CPU_68060
@


1.10
log
@Better check for UPT filling; saves one more page for userland on most hp300...
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.9 2004/12/30 21:22:20 miod Exp $	*/
a166 3
	nptpages =
	    (MACHINE_IIOMAPSIZE + MACHINE_EIOMAPSIZE + NPTEPG - 1) / NPTEPG;

d176 3
a178 6
	num = RELOC(Sysptsize, int) +
	    (m68k_btop(MACHINE_MAX_PTSIZE) * sizeof(pt_entry_t) + NPTEPG - 1) /
	      NPTEPG;
	if (nptpages < num)
		nptpages = num;

@


1.9
log
@Rework pmap_bootstrap() computations of I/O maps. Makes the MD part of
this much simpler.

Also, make sure an userland process can fill its UPT as expected.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.8 2004/11/27 14:26:30 miod Exp $	*/
d167 1
a167 1
	nptpages = RELOC(Sysptsize, int) +
@


1.8
log
@In pmap_bootstrap(), replace PMAP_MD_RWZERO, which would leave the lowest
page writeable, with PMAP_MD_RWLOW, which tells how many pages have to be
left writeable on low addresses, since the mac rom needs more than one.
This lets non-DDB mac68k kernels run.
No change on non-mac68k platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.7 2004/07/22 19:37:39 miod Exp $	*/
d124 1
d166 1
d169 16
d186 1
a186 2
	eiopa = nextpa - MACHINE_EIOMAPSIZE * sizeof(pt_entry_t);
	iiopa = eiopa - MACHINE_IIOMAPSIZE * sizeof(pt_entry_t);
@


1.7
log
@Make the inline bzero() of the U area much more readable.
As a bonus it generates smaller and faster code.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.6 2003/06/02 23:27:48 millert Exp $	*/
d77 1
a77 1
 * PMAP_MD_RWZERO	define to NOT make virtual address 0 read only
d351 1
a351 8
#ifndef	PMAP_MD_RWZERO
	*pte++ = firstpa | PG_NV;	/* make *NULL fail in the kernel */
#if defined(KGDB) || defined(DDB)
	protopte = (firstpa + NBPG) | PG_RW | PG_V | PG_U; /* XXX RW for now */
#else
	protopte = (firstpa + NBPG) | PG_RO | PG_V | PG_U;
#endif
#else
d357 8
d368 1
a368 1
		protopte += NBPG;
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.5 2003/06/02 07:06:56 deraadt Exp $	*/
d127 1
a207 2
		int num;

d432 2
a433 4
	/*
	 * Zero the u-area.
	 * NOTE: `pte' and `epte' aren't PTEs here.
	 */
d435 3
a437 3
	epte = (u_int *)(PA2VA(p0upa, u_int) + USPACE);
	while (pte < epte)
		*pte++ = PG_NV;
@


1.5
log
@licence cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.4 2002/04/16 20:53:47 miod Exp $	*/
d43 1
a43 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.4
log
@- allow users of pmap_bootstrap to not have virtual address 0 read only,
  mac68k needs this for now
- update comments to reflect that code, if invoked carefully, can work
  with the MMU enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.3 2002/03/14 01:26:35 millert Exp $	*/
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD by
 *	Theo de Raadt for Willowglen Singapore.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.4.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.2 2002/02/27 20:51:01 miod Exp $	*/
d87 1
a105 1

d118 6
a123 4
 * Called with MMU off so we must relocate all global references by `firstpa'
 * (don't call any functions here!)  `nextpa' is the first available physical
 * memory address.  Returns an updated first PA reflecting the memory we
 * have allocated.  MMU is still off when we return.
d343 2
d362 1
d368 7
@


1.2
log
@Better values for invalid pte initialization.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.1 2002/02/23 04:58:28 miod Exp $	*/
d103 1
a103 1
void  pmap_bootstrap __P((paddr_t, paddr_t));
@


1.2.2.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d103 1
a103 1
void  pmap_bootstrap(paddr_t, paddr_t);
@


1.2.2.2
log
@Sync the SMP branch with 3.3
@
text
@a86 1
 * PMAP_MD_RWZERO	define to NOT make virtual address 0 read only
d105 1
d118 4
a121 6
 * Ideally called with MMU off, but not necessarily.  All global references
 * are relocated by `firstpa' to ensure this works.  Of course, it is not
 * possible to call any other functions from there.  `nextpa' is the first
 * available physical memory address.  Returns an updated first PA reflecting
 * the memory we have allocated.  MMU is still in the same state when we
 * return.
a340 2
#else
	*pte = PG_NV;
a357 1
#ifndef	PMAP_MD_RWZERO
a362 7
#endif
#else
#if defined(KGDB) || defined(DDB)
	protopte = firstpa | PG_RW | PG_V | PG_U; /* XXX RW for now */
#else
	protopte = firstpa | PG_RO | PG_V | PG_U;
#endif
@


1.2.2.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_bootstrap.c,v 1.2.2.2 2003/03/27 23:28:43 niklas Exp $	*/
d15 6
d49 5
a53 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1
log
@Factorize most of the pmap_bootstrap() guts used by pmap_motorola users,
with a few hooks to cope with each architecture's specifics.

The new arch/m68k/m68k/pmap_bootstrap.c is not a standalone file, but will
be #included by the existing pmap_bootstrap.c code.

Tested on hp300 and mvme68k, mac68k coming soon. amiga will be left out
for now because it is a bit too different.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d287 1
a287 1
			*pte++ = PG_NV | PG_U;
d349 1
a349 1
		*pte++ = PG_NV | PG_U;
d438 1
a438 1
		*pte++ = 0;
@

