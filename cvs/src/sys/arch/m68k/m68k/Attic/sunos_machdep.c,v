head	1.22;
access;
symbols
	OPENBSD_4_7:1.19.0.8
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.10
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.6
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.8
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.6
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.6
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.14
	UBC:1.13.0.4
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.11.0.4
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.16
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.14
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.12
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.10
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.8
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.6
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2010.07.02.19.59.00;	author tedu;	state dead;
branches;
next	1.21;

1.21
date	2010.06.27.22.04.01;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.02.19.18.54;	author martin;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.06.17.23.41;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.06.12.10.28;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.01.18.37.28;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.27.48;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.04.00.09.08;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.27.04.39.06;	author art;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.05.15.01.43.16;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.28.02.24.43;	author art;	state Exp;
branches;
next	1.10;

1.10
date	97.02.02.01.38.11;	author deraadt;	state Exp;
branches
	1.10.14.1;
next	1.9;

1.9
date	97.01.27.22.48.13;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.01.13.11.51.14;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.08.04.01.15.16;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.05.09.22.30.12;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.05.03.08.51.35;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.01.05.16.17.54;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.29.17.02.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.28.20.44.54;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.51.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.51.01;	author deraadt;	state Exp;
branches;
next	;

1.10.14.1
date	2001.04.18.16.10.03;	author niklas;	state Exp;
branches;
next	1.10.14.2;

1.10.14.2
date	2001.07.04.10.18.22;	author niklas;	state Exp;
branches;
next	1.10.14.3;

1.10.14.3
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	1.10.14.4;

1.10.14.4
date	2003.06.07.11.11.39;	author ho;	state Exp;
branches;
next	1.10.14.5;

1.10.14.5
date	2004.02.19.10.49.02;	author niklas;	state Exp;
branches;
next	;

1.13.4.1
date	2002.06.11.03.36.07;	author art;	state Exp;
branches;
next	;


desc
@@


1.22
log
@delete sunos files
@
text
@/*	$OpenBSD: sunos_machdep.c,v 1.21 2010/06/27 22:04:01 miod Exp $	*/
/*	$NetBSD: sunos_machdep.c,v 1.12 1996/10/13 03:19:22 christos Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: machdep.c 1.63 91/04/24$
 *
 *	@@(#)machdep.c	7.16 (Berkeley) 6/3/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/kernel.h>
#include <sys/signal.h>
#include <sys/signalvar.h>
#include <sys/malloc.h>
#include <sys/buf.h>

#include <uvm/uvm_extern.h>

#include <sys/syscallargs.h>
#include <compat/sunos/sunos.h>
#include <compat/sunos/sunos_syscallargs.h>

#include <machine/frame.h>
#include <machine/reg.h>

#ifdef DEBUG
extern int sigdebug;
extern int sigpid;
#define SDB_FOLLOW      0x01
#define SDB_KSTACK      0x02
#define SDB_FPSTATE     0x04
#endif

/* sigh.. I guess it's too late to change now, but "our" sigcontext
   is plain vax, not very 68000 (ap, for example..) */
struct sunos_sigcontext {
	int 	sc_onstack;		/* sigstack state to restore */
	int	sc_mask;		/* signal mask to restore */
	int	sc_sp;			/* sp to restore */
	int	sc_pc;			/* pc to restore */
	int	sc_ps;			/* psl to restore */
};
struct sunos_sigframe {
	int	sf_signum;		/* signo for handler */
	int	sf_code;		/* additional info for handler */
	struct sunos_sigcontext *sf_scp;/* context pointer for handler */
	u_int	sf_addr;		/* even more info for handler */
	struct sunos_sigcontext sf_sc;	/* I don't know if that's what 
					   comes here */
};
/*
 * much simpler sendsig() for SunOS processes, as SunOS does the whole
 * context-saving in usermode. For now, no hardware information (ie.
 * frames for buserror etc) is saved. This could be fatal, so I take 
 * SIG_DFL for "dangerous" signals.
 */
void
sunos_sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
{
	register struct proc *p = curproc;
	register struct sunos_sigframe *fp;
	struct sunos_sigframe kfp;
	register struct frame *frame;
	register struct sigacts *psp = p->p_sigacts;
	register short ft;
	int oonstack, fsize;

	frame = (struct frame *)p->p_md.md_regs;
	ft = frame->f_format;
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;

	/*
	 * if this is a hardware fault (ft >= FMT9), sunos_sendsig
	 * can't currently handle it. Reset signal actions and
	 * have the process die unconditionally. 
	 */
	if (ft >= FMT9) {
		sigexit(p, sig);
		/* NOTREACHED */
	}

	/*
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in P0 space, the
	 * call to grow() is a nop, and the useracc() check
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
	 */
	fsize = sizeof(struct sunos_sigframe);
	if ((psp->ps_flags & SAS_ALTSTACK) && oonstack == 0 &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sunos_sigframe *)(psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size - sizeof(struct sunos_sigframe));
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
	} else
		fp = (struct sunos_sigframe *)frame->f_regs[SP] - 1;
	if ((vaddr_t)fp <= USRSTACK - ptoa(p->p_vmspace->vm_ssize)) 
		(void)uvm_grow(p, (unsigned)fp);
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sunos_sendsig(%d): sig %d ssp %p usp %p scp %p ft %d\n",
		       p->p_pid, sig, &oonstack, fp, &fp->sf_sc, ft);
#endif
	/* 
	 * Build the argument list for the signal handler.
	 */
	kfp.sf_signum = sig;
	kfp.sf_code = code;
	kfp.sf_scp = &fp->sf_sc;
	kfp.sf_addr = (u_int)val.sival_ptr;

	/*
	 * Build the signal context to be used by sigreturn.
	 */
	kfp.sf_sc.sc_onstack = oonstack;
	kfp.sf_sc.sc_mask = mask;
	kfp.sf_sc.sc_sp = frame->f_regs[SP];
	kfp.sf_sc.sc_pc = frame->f_pc;
	kfp.sf_sc.sc_ps = frame->f_sr;

	if (copyout(&kfp, fp, fsize) != 0) {
#ifdef DEBUG
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sunos_sendsig(%d): copyout failed on sig %d\n",
			       p->p_pid, sig);
#endif
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}

	frame->f_regs[SP] = (int)fp;
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sunos_sendsig(%d): sig %d scp %p sc_sp %x\n",
		       p->p_pid, sig, &fp->sf_sc,kfp.sf_sc.sc_sp);
#endif

	/* have the user-level trampoline code sort out what registers it
	   has to preserve. */
	frame->f_pc = (u_int) catcher;
#ifdef DEBUG
	if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
		printf("sunos_sendsig(%d): sig %d returns\n",
		       p->p_pid, sig);
#endif
}


/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper privileges or to cause
 * a machine fault.
 */
int
sunos_sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_sigreturn_args *uap = v;
	register struct sunos_sigcontext *scp;
	register struct frame *frame;
	struct sunos_sigcontext tsigc;

	scp = (struct sunos_sigcontext *) SCARG(uap, sigcntxp);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sunos_sigreturn: pid %d, scp %p\n", p->p_pid, scp);
#endif
	if ((int)scp & 1)
		return (EINVAL);
	/*
	 * Test and fetch the context structure.
	 * We grab it all at once for speed.
	 */
	if (copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof(tsigc)))
		return (EINVAL);
	scp = &tsigc;
	if ((scp->sc_ps & PSL_USERCLR) != 0 ||
	    (scp->sc_ps & PSL_USERSET) != PSL_USERSET)
		return (EINVAL);
	/*
	 * Restore the user supplied information
	 */
	if (scp->sc_onstack & 1)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = scp->sc_mask &~ sigcantmask;
	frame = (struct frame *) p->p_md.md_regs;
	frame->f_regs[SP] = scp->sc_sp;
	frame->f_pc = scp->sc_pc;
	frame->f_sr = scp->sc_ps;

	return EJUSTRETURN;
}
@


1.21
log
@More include necessary after <sys/user.h> inclusion removal
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.20 2010/06/26 23:24:43 guenther Exp $	*/
@


1.20
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.19 2007/11/02 19:18:54 martin Exp $	*/
d61 1
@


1.19
log
@replace ctob/btoc with ptoa/atop (plus the usual round_page() where needed)
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.18 2005/11/06 17:23:41 miod Exp $	*/
a45 1
#include <sys/user.h>
d54 2
@


1.18
log
@Homogeneize all PSR field tests in user-provided structures. No functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.17 2005/08/06 12:10:28 miod Exp $	*/
d138 1
a138 1
	if ((vaddr_t)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
@


1.17
log
@If a process has trashed its stack, use sigexit() instead of psignal() to
terminate it with prejudice, as done in native sendsig().
Plus you get a memory leak in COMPAT_HPUX on m68k fixed for free.

review art@@ test martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.16 2003/08/01 18:37:28 miod Exp $	*/
d229 2
a230 1
	if ((scp->sc_ps & (PSL_MBZ|PSL_IPL|PSL_S)) != 0)
@


1.16
log
@Nuke calls to uvm_useracc() and instead check copyin() and copyout() for
failure, since the former is not reliable; requested by art@@ long ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.15 2003/06/02 23:27:48 millert Exp $	*/
d119 2
a120 6
		SIGACTION(p, sig) = SIG_DFL;
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, sig);
		return;
d172 2
a173 7
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.14 2002/06/04 00:09:08 deraadt Exp $	*/
a148 18
	if (uvm_useracc((caddr_t)fp, fsize, B_WRITE) == 0) {
#ifdef DEBUG
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sunos_sendsig(%d): useracc failed on sig %d\n",
			       p->p_pid, sig);
#endif
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
	}
d167 5
d176 7
a182 2
		sigexit(p, SIGILL);
		/* NOTREACHED */ 
d235 1
a235 2
	if (uvm_useracc((caddr_t)scp, sizeof(*scp), B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof(tsigc)))
@


1.14
log
@spelling; raj@@cerias.purdue.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.13 2001/06/27 04:39:06 art Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@kill old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.12 2001/05/15 01:43:16 millert Exp $	*/
d222 1
a222 1
 * psl to gain improper priviledges or to cause
@


1.13.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.13 2001/06/27 04:39:06 art Exp $	*/
d222 1
a222 1
 * psl to gain improper privileges or to cause
@


1.12
log
@Replace vm_offset_t with vaddr_t and paddr_t as appropriate.
NetBSD used as a guide.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.11 2000/05/28 02:24:43 art Exp $	*/
a145 1
#if defined(UVM)
a147 4
#else
	if ((vaddr_t)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
		(void)grow(p, (unsigned)fp);
#endif
a152 1
#if defined(UVM)
a153 3
#else
	if (useracc((caddr_t)fp, fsize, B_WRITE) == 0) {
#endif
a246 1
#if defined(UVM)
a249 5
#else
	if (useracc((caddr_t)scp, sizeof(*scp), B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof(tsigc)))
		return (EINVAL);
#endif
@


1.11
log
@UVM. grow -> uvm_grow, useracc -> uvm_useracc.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.10 1997/02/02 01:38:11 deraadt Exp $	*/
d147 1
a147 1
	if ((vm_offset_t)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
d150 1
a150 1
	if ((vm_offset_t)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
@


1.10
log
@siginfo stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.9 1997/01/27 22:48:13 deraadt Exp $	*/
d146 4
d152 1
d158 3
d162 1
d256 5
d264 1
@


1.10.14.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.11 2000/05/28 02:24:43 art Exp $	*/
a145 4
#if defined(UVM)
	if ((vm_offset_t)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
		(void)uvm_grow(p, (unsigned)fp);
#else
a147 1
#endif
a152 3
#if defined(UVM)
	if (uvm_useracc((caddr_t)fp, fsize, B_WRITE) == 0) {
#else
a153 1
#endif
a246 5
#if defined(UVM)
	if (uvm_useracc((caddr_t)scp, sizeof(*scp), B_WRITE) == 0 ||
	    copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof(tsigc)))
		return (EINVAL);
#else
a249 1
#endif
@


1.10.14.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.10.14.1 2001/04/18 16:10:03 niklas Exp $	*/
d146 2
a147 1
	if ((vaddr_t)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
d149 4
d158 1
d160 3
d256 1
d260 5
@


1.10.14.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d222 1
a222 1
 * psl to gain improper privileges or to cause
@


1.10.14.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.10.14.3 2003/03/27 23:28:43 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.10.14.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d149 18
a184 5
#ifdef DEBUG
		if ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid)
			printf("sunos_sendsig(%d): copyout failed on sig %d\n",
			       p->p_pid, sig);
#endif
d189 2
a190 7
		SIGACTION(p, SIGILL) = SIG_DFL;
		sig = sigmask(SIGILL);
		p->p_sigignore &= ~sig;
		p->p_sigcatch &= ~sig;
		p->p_sigmask &= ~sig;
		psignal(p, SIGILL);
		return;
d243 2
a244 1
	if (copyin((caddr_t)scp, (caddr_t)&tsigc, sizeof(tsigc)))
@


1.9
log
@add another parameter to trapsignal() and sendsig() -- fault addr to be
delivered with in the siginfo information
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.8 1997/01/13 11:51:14 niklas Exp $	*/
d98 1
a98 1
sunos_sendsig(catcher, sig, mask, code, addr)
d102 2
a103 1
	caddr_t addr;
d177 1
a177 1
	kfp.sf_addr = (u_int)addr;
@


1.8
log
@Sync to 970110 NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_machdep.c,v 1.7 1996/08/04 01:15:16 niklas Exp $	*/
d98 1
a98 1
sunos_sendsig(catcher, sig, mask, code)
d102 1
d176 1
a176 1
	kfp.sf_addr = ~0;		/* means: not computable */
@


1.7
log
@Do not mix differently signed entities in comparisons.
Remove unnecessary include.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: sunos_machdep.c,v 1.10 1996/05/05 16:11:31 veego Exp $	*/
@


1.6
log
@From NetBSD:
Prototype + -Wall fixes.
Clean up a few printf format strings.
Added an include for the sunos_sendsig prototype
Fix "prototype disagrees about inline" error.
@
text
@a63 1
#include <machine/psl.h>
d144 1
a144 1
	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize)) 
@


1.5
log
@We need psl.h to get at the PSL_* stuff
@
text
@d1 2
a2 1
/*	$NetBSD: sunos_machdep.c,v 1.8 1996/01/04 22:22:12 jtc Exp $	*/
d61 1
d149 1
a149 1
		printf("sunos_sendsig(%d): sig %d ssp %x usp %x scp %x ft %d\n",
d199 2
a200 2
		printf("sunos_sendsig(%d): sig %d scp %x sc_sp %x\n",
		       p->p_pid, sig, kfp.sf_sc.sc_sp);
d238 1
a238 1
		printf("sunos_sigreturn: pid %d, scp %x\n", p->p_pid, scp);
@


1.4
log
@ss_sp is correct, ss_base is not. noticed by agc@@sde.uts.amdahl.com; netbsd pr#1784
@
text
@d62 1
@


1.3
log
@niklas pointed out the new MDP_UNCACHE_WX might break fork/exec.
always set/clear in setregs() now
@
text
@d1 1
a1 1
/*	$NetBSD: sunos_machdep.c,v 1.7 1995/10/10 21:18:01 gwr Exp $	*/
a88 1

d137 1
a137 1
		fp = (struct sunos_sigframe *)(psp->ps_sigstk.ss_base +
@


1.2
log
@Fix SunOS emulation on 040
@
text
@a90 15
 * SunOS' ld.so does self-modifying code without knowing about the 040's
 * cache purging needs.  So we need to uncache writeable executable pages.
 */
void
sunos_setregs(p, pack, stack, retval)
	register struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	setregs(p, pack, stack, retval);
	p->p_md.md_flags |= MDP_UNCACHE_WX;
}

/*
@


1.1
log
@Initial revision
@
text
@d89 16
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
