head	1.19;
access;
symbols
	OPENBSD_5_5:1.18.0.8
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.4
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.4
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.13.0.6
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.4.0.2
	UBC_BASE:1.4
	OPENBSD_3_0:1.1.0.20
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9:1.1.0.18
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.16
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.14
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.12
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.10
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.8
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.6
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.4
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.19
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.18;

1.18
date	2012.08.07.17.17.46;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2012.08.07.05.16.53;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2012.04.11.14.38.55;	author mikeb;	state Exp;
branches;
next	1.15;

1.15
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2010.07.02.19.57.14;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.26.05.42.11;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.09.17.30.55;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.15.13.46.22;	author martin;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.26.21.30.17;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.28.16.38.47;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.16.22.36.44;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.06.17.59.57;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.08.06.14.26.52;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.05.01.51.27;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.25.21.31.06;	author miod;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.11.25.17.15.19;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.06.18.41.09;	author art;	state Exp;
branches;
next	1.1;

1.1
date	97.07.06.07.46.28;	author downsj;	state Exp;
branches
	1.1.12.1;
next	;

1.1.12.1
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.1.12.2;

1.1.12.2
date	2001.12.05.00.39.11;	author niklas;	state Exp;
branches;
next	1.1.12.3;

1.1.12.3
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: m68k_machdep.c,v 1.18 2012/08/07 17:17:46 guenther Exp $	*/
/*	$NetBSD: m68k_machdep.c,v 1.3 1997/06/12 09:57:04 veego Exp $	*/

/*-
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Bernd Ernesti.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/exec.h>
#include <sys/proc.h>
#include <sys/syscall.h>
#include <sys/syscall_mi.h>
#include <sys/user.h>

#include <machine/cpu.h>
#include <machine/frame.h>
#include <machine/reg.h>

struct cpu_info cpu_info_store;

/*
 * Set registers on exec.
 */
void
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
{
	struct frame *frame = (struct frame *)p->p_md.md_regs;

	frame->f_sr = PSL_USERSET;
	frame->f_pc = pack->ep_entry & ~1;
	bzero(frame->f_regs, 15 * sizeof(register_t));
	frame->f_regs[A2] = (int)PS_STRINGS;
	frame->f_regs[SP] = stack;

	/* restore a null state frame */
	p->p_addr->u_pcb.pcb_fpregs.fpf_null = 0;
	if (fputype != FPU_NONE) {
		m68881_restore(&p->p_addr->u_pcb.pcb_fpregs);
	}

	retval[1] = 0;
}

/*
 * Process the tail end of a fork() for the child
 */
void
child_return(arg)
	void *arg;
{
	struct proc *p = (struct proc *)arg;
	struct frame *f = (struct frame *)p->p_md.md_regs;

	f->f_regs[D0] = 0;
	f->f_sr &= ~PSL_C;	/* carry bit */
	f->f_format = FMT0;

	mi_child_return(p);
}
@


1.18
log
@<sys/ktrace.h> is now pulled in via <sys/syscall_mi.h>, so drop it from here
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.17 2012/08/07 05:16:53 guenther Exp $	*/
@


1.17
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.16 2012/04/11 14:38:55 mikeb Exp $	*/
a38 1
#include <sys/ktrace.h>
@


1.16
log
@The first ktrace record for a newly spawned thread is a return
from a fork syscall done by the parent.  Use __tfork, not rfork
here to match the ktrace records for the parent (CALL __tfork,
RET __tfork).  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.15 2011/04/03 14:56:28 guenther Exp $	*/
d38 1
d89 1
a89 8
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p,
		    (p->p_flag & P_THREAD) ? SYS___tfork :
		    (p->p_p->ps_flags & PS_PPWAIT) ? SYS_vfork : SYS_fork,
		    0, 0);
#endif
@


1.15
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.14 2010/07/02 19:57:14 tedu Exp $	*/
d92 1
a92 1
		    (p->p_flag & P_THREAD) ? SYS_rfork :
@


1.14
log
@remove support for compat_sunos (and m68k4k).  ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.13 2008/06/26 05:42:11 ray Exp $	*/
d92 3
a94 1
		    (p->p_flag & P_PPWAIT) ? SYS_vfork : SYS_fork, 0, 0);
@


1.13
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.12 2007/11/09 17:30:55 miod Exp $	*/
a56 3
#ifdef COMPAT_SUNOS
	extern struct emul emul_sunos;
#endif
a69 12

#ifdef COMPAT_SUNOS
	/*
	 * SunOS' ld.so does self-modifying code without knowing
	 * about the 040's cache purging needs.  So we need to uncache
	 * writeable executable pages.
	 */
	if (p->p_emul == &emul_sunos)
		p->p_md.md_flags |= MDP_UNCACHE_WX;
	else
		p->p_md.md_flags &= ~MDP_UNCACHE_WX;
#endif
@


1.12
log
@Move splassert_check() from common m68k code to each m68k-based architecture,
as its implementation may vary accross platforms (and will very soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.11 2007/05/15 13:46:22 martin Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.11
log
@switch m68k to __HAVE_CPUINFO

help miod@@, art@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.10 2007/02/26 21:30:17 miod Exp $	*/
a116 21

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int oldipl;

	__asm __volatile ("movew sr,%0" : "=&d" (oldipl));

	oldipl = PSLTOIPL(oldipl);

	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
		/*
		 * If the splassert_ctl is set to not panic, raise the ipl
		 * in a feeble attempt to reduce damage.
		 */
		_spl(PSL_S | IPLTOPSL(wantipl));
	}
}
#endif
@


1.10
log
@Zero rval[1] in setregs.
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.9 2007/01/28 16:38:47 miod Exp $	*/
d51 2
@


1.9
log
@optimize m68k writeback():
- it can really only be invoked from trap(), not from other userret() callers,
  so it is safe to hardcode its docachepush parameter to 1.
- use pmap_kenter_pa()/pmap_kremove() for the temporary mapping instead of
  pmap_enter()/pmap_remove().

optimize m68k userret():
- define PROC_PC for m68k systems.
- only check want_resched when processing T_ASTFLT traps.
- provide two version of userret(), one which will also invoke writeback()
  on 68040 if required, which is only invoked from trap(), and regular
  userret(). This speeds up system call returns.
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.8 2006/04/16 22:36:44 miod Exp $	*/
d90 2
@


1.8
log
@Change child_return() to record a proper ktrace record for vfork child
processes.

ok art@@ uwe@@ (some time ago, and I forgot to commit this chunk)
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.7 2005/11/06 17:59:57 miod Exp $	*/
d106 1
a106 1
	userret(p, f, p->p_sticks, 0, 0);
@


1.7
log
@Factorize setregs() code to m68k-common location.
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.6 2005/08/06 14:26:52 miod Exp $	*/
d109 2
a110 1
		ktrsysret(p, SYS_fork, 0, 0);
@


1.6
log
@We do not need a char machine_arch[] constant.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.5 2003/01/05 01:51:27 miod Exp $	*/
d41 2
d46 1
d51 40
@


1.5
log
@splassert on m68k-based arches. Not totally accurate on hp300 at the moment,
still.
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.4 2001/11/25 21:31:06 miod Exp $	*/
a47 3

/* the following is used externally (sysctl_hw) */
char	machine_arch[] = MACHINE_ARCH;	/* from <machine/param.h> */
@


1.4
log
@Need <machine/cpu.h> to be sure to bring userret() prototype for all ports.
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.3 2001/11/25 17:15:19 miod Exp $	*/
d73 20
@


1.4.2.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a72 20
#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int oldipl;

	__asm __volatile ("movew sr,%0" : "=&d" (oldipl));

	oldipl = PSLTOIPL(oldipl);

	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
		/*
		 * If the splassert_ctl is set to not panic, raise the ipl
		 * in a feeble attempt to reduce damage.
		 */
		_spl(PSL_S | IPLTOPSL(wantipl));
	}
}
#endif
@


1.3
log
@Harmonize userret() prototypes across m68k arches.
XXX The userret() code is not factorized out yet, as this will require
XXX insane amiga cleaning work.
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.2 2001/11/06 18:41:09 art Exp $	*/
d45 1
@


1.2
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.1 1997/07/06 07:46:28 downsj Exp $	*/
a50 1
void    userret __P((struct proc *, int, u_quad_t));	/* XXX */
a52 2
 *
 * XXX - this is probably the wrong file.
d65 1
a65 1
	userret(p, f->f_pc, p->p_sticks);
@


1.1
log
@Sync with NetBSD changes, 970415 - 970705.

This includes a new asm.h, as well as even more code abstracted from hp300.
These changes are likely to break ports that don't know about them; hp300
runs at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 6
d50 24
@


1.1.12.1
log
@Merge in -current
@
text
@a40 6
#include <sys/proc.h>
#include <sys/syscall.h>
#include <sys/ktrace.h>

#include <machine/frame.h>
#include <machine/reg.h>
a43 24

void    userret __P((struct proc *, int, u_quad_t));	/* XXX */
/*
 * Process the tail end of a fork() for the child
 *
 * XXX - this is probably the wrong file.
 */
void
child_return(arg)
	void *arg;
{
	struct proc *p = (struct proc *)arg;
	struct frame *f = (struct frame *)p->p_md.md_regs;

	f->f_regs[D0] = 0;
	f->f_sr &= ~PSL_C;	/* carry bit */
	f->f_format = FMT0;

	userret(p, f->f_pc, p->p_sticks);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET))
		ktrsysret(p, SYS_fork, 0, 0);
#endif
}
@


1.1.12.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: m68k_machdep.c,v 1.1.12.1 2001/11/13 21:00:52 niklas Exp $	*/
a44 1
#include <machine/cpu.h>
d51 1
d54 2
d68 1
a68 1
	userret(p, f, p->p_sticks, 0, 0);
@


1.1.12.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a72 20
#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	int oldipl;

	__asm __volatile ("movew sr,%0" : "=&d" (oldipl));

	oldipl = PSLTOIPL(oldipl);

	if (oldipl < wantipl) {
		splassert_fail(wantipl, oldipl, func);
		/*
		 * If the splassert_ctl is set to not panic, raise the ipl
		 * in a feeble attempt to reduce damage.
		 */
		_spl(PSL_S | IPLTOPSL(wantipl));
	}
}
#endif
@


