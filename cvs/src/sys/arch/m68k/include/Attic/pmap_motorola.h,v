head	1.28;
access;
symbols
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.26.0.8
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.6
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.4
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.8
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.10
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.6
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.12.0.6
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.6
	UBC:1.2.0.4
	UBC_BASE:1.2
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.28
date	2014.03.18.22.36.34;	author miod;	state dead;
branches;
next	1.27;

1.27
date	2014.01.30.18.16.41;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2011.11.01.21.20.55;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2011.09.27.20.35.44;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2011.05.24.15.27.36;	author ariane;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.28.20.53.32;	author ariane;	state Exp;
branches;
next	1.22;

1.22
date	2011.03.23.16.54.35;	author pirofti;	state Exp;
branches;
next	1.21;

1.21
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2010.12.06.20.57.16;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2010.11.18.21.21.38;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.29.20.30.32;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2007.12.28.18.57.28;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.10.18.49.45;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.24.13.22.14;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.17.16.29.10;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.23.19.00.25;	author martin;	state Exp;
branches;
next	1.12;

1.12
date	2004.08.07.18.57.44;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.20.09.20.42;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.01.01.12.52;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.27.48;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.01.00.28.45;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.27.19.37.30;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.27.23.21.02;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.34;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.10.21.08.41;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.20.19.02.28;	author miod;	state dead;
branches;
next	1.2;

1.2
date	2001.12.05.00.11.51;	author millert;	state Exp;
branches
	1.2.2.1
	1.2.4.1;
next	1.1;

1.1
date	2001.11.30.20.54.50;	author miod;	state Exp;
branches;
next	;

1.2.2.1
date	2001.12.05.00.39.11;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.03.06.01.03.31;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2002.03.28.10.34.04;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2003.03.27.23.28.43;	author niklas;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2003.06.07.11.11.38;	author ho;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2004.02.19.10.49.02;	author niklas;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	2004.06.05.23.10.50;	author niklas;	state Exp;
branches;
next	;

1.2.4.1
date	2002.01.31.22.55.13;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.06.11.03.36.06;	author art;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.05.19.21.49.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: pmap_motorola.h,v 1.27 2014/01/30 18:16:41 miod Exp $	*/

/* 
 * Copyright (c) 1987 Carnegie-Mellon University
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pmap.h	8.1 (Berkeley) 6/10/93
 */

#ifndef	_M68K_M68K_PMAP_MOTOROLA_H_
#define	_M68K_M68K_PMAP_MOTOROLA_H_

#if !defined(_LOCORE)
#include <machine/pte.h>
#endif

#ifdef	_KERNEL

#include <machine/cpu.h>

/*
 * Pmap stuff
 */
struct pmap {
	pt_entry_t		*pm_ptab;	/* KVA of page table */
	st_entry_t		*pm_stab;	/* KVA of segment table */
	int			pm_stfree;	/* 040: free lev2 blocks */
	st_entry_t		*pm_stpa;	/* 040: ST phys addr */
	short			pm_sref;	/* segment table ref count */
	short			pm_count;	/* pmap reference count */
	struct simplelock	pm_lock;	/* lock on pmap */
	struct pmap_statistics	pm_stats;	/* pmap statistics */
	long			pm_ptpages;	/* more stats: PT pages */
};

typedef struct pmap	*pmap_t;

/*
 * On the 040 we keep track of which level 2 blocks are already in use
 * with the pm_stfree mask.  Bits are arranged from LSB (block 0) to MSB
 * (block 31).  For convenience, the level 1 table is considered to be
 * block 0.
 *
 * MAX[KU]L2SIZE control how many pages of level 2 descriptors are allowed.
 * for the kernel and users.  8 implies only the initial "segment table"
 * page is used.  WARNING: don't change MAXUL2SIZE unless you can allocate
 * physically contiguous pages for the ST in pmap.c!
 */
#define	MAXKL2SIZE	32
#define MAXUL2SIZE	8
#define l2tobm(n)	(1 << (n))
#define	bmtol2(n)	(ffs(n) - 1)

/*
 * Macros for speed
 */
#define PMAP_ACTIVATE(pmap, loadhw)					\
{									\
        if ((loadhw))							\
                loadustp(atop((paddr_t)(pmap)->pm_stpa));		\
}

/* XXX - struct pv_entry moved to vmparam.h because of include ordering issues */

extern struct pmap	kernel_pmap_store;

#define pmap_kernel()	(&kernel_pmap_store)
#define	active_pmap(pm) \
	((pm) == pmap_kernel() || (pm) == curproc->p_vmspace->vm_map.pmap)
#define	active_user_pmap(pm) \
	(curproc && \
	 (pm) != pmap_kernel() && (pm) == curproc->p_vmspace->vm_map.pmap)

extern struct pv_entry	*pv_table;	/* array of entries, one per page */

#define	pmap_resident_count(pmap)	((pmap)->pm_stats.resident_count)
#define	pmap_wired_count(pmap)		((pmap)->pm_stats.wired_count)

#define	pmap_copy(dp,sp,d,l,s)		do { /* nothing */ } while (0)
#define	pmap_update(pmap)		do { /* nothing (yet) */ } while (0)
#define	pmap_unuse_final(p)		do { /* nothing */ } while (0)
#define	pmap_remove_holes(map)		do { /* nothing */ } while (0)

extern pt_entry_t	*Sysmap;
extern char		*vmmap;		/* map for mem, dumps, etc. */

int	pmap_enter_cache(pmap_t, vaddr_t, paddr_t, vm_prot_t, int, pt_entry_t);
void	pmap_kenter_cache(vaddr_t, paddr_t, pt_entry_t);

#define PMAP_GROWKERNEL			/* turn on pmap_growkernel interface */

#endif	/* _KERNEL */

#ifndef _LOCORE

struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vaddr_t		pv_va;		/* virtual address for mapping */
	st_entry_t	*pv_ptste;	/* non-zero if VA maps a PT page */
	struct pmap	*pv_ptpmap;	/* if pv_ptste, pmap for PT page */
	int		pv_flags;	/* flags */
};

/*
 * pv_flags carries some PTE permission bits as well - make sure extra flags
 * values are > (1 << PG_SHIFT)
 */
/* header: all entries are cache inhibited */
#define	PV_CI		(0x01 << PG_SHIFT)
/* header: entry maps a page table page */
#define PV_PTPAGE	(0x02 << PG_SHIFT)

struct vm_page_md {
	struct pv_entry pvent;
};

#define	VM_MDPAGE_INIT(pg) do {			\
	(pg)->mdpage.pvent.pv_next = NULL;	\
	(pg)->mdpage.pvent.pv_pmap = NULL;	\
	(pg)->mdpage.pvent.pv_va = 0;		\
	(pg)->mdpage.pvent.pv_ptste = NULL;	\
	(pg)->mdpage.pvent.pv_ptpmap = NULL;	\
	(pg)->mdpage.pvent.pv_flags = 0;	\
} while (0)

#endif	/* _LOCORE */

#endif /* !_M68K_M68K_PMAP_MOTOROLA_H_ */
@


1.27
log
@Move declaration of struct vm_page_md from <machine/vmparam.h> to
<machine/pmap.h> where it belongs, and compensate in <uvm/uvm_extern.h>
by including <uvm/uvm_pmap.h> before <uvm/uvm_page.h>. Tested on all
MACHINE_ARCH but amd64 and i386 (and hppa64).
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.26 2011/11/01 21:20:55 miod Exp $	*/
@


1.26
log
@Drop support for the HP MMU. It was only found on two hp300 systems (models
320 and 350), which have been unsupported since a bunch of release already,
because this annoying MMU does not have TT registers (or if it does, it is
not documented) and thus went in the way of PMAP_DIRECT for hp300.
In other words: remove a bunch of code which was either #ifdef'ed out or
had no chance to run in real life.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.25 2011/09/27 20:35:44 miod Exp $	*/
d42 4
a48 1
#include <machine/pte.h>
d122 35
@


1.25
log
@Use a pool to allocate pv_entry from, instead of allocating whole pages and
maintaining our own free lists. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.24 2011/05/24 15:27:36 ariane Exp $	*/
d39 2
a40 2
#ifndef	_M68K_M68K_M68K_PMAP_MOTOROLA_H_
#define	_M68K_M68K_M68K_PMAP_MOTOROLA_H_
a117 11
#ifdef M68K_MMU_HP
vaddr_t	pmap_prefer(vaddr_t, vaddr_t);
#define	PMAP_PREFER(foff, va)	pmap_prefer((foff), (va))

extern int	pmap_aliasmask;	/* separation at which VA aliasing is ok */
/* pmap prefer alignment */
#define PMAP_PREFER_ALIGN()	(pmap_aliasmask ? pmap_aliasmask + 1 : 0)
/* pmap prefer offset */
#define PMAP_PREFER_OFFSET(of)	((of) & pmap_aliasmask)
#endif

d120 1
a120 1
#endif /* !_M68K_M68K_M68K_PMAP_MOTOROLA_H_ */
@


1.24
log
@Reimplement uvm/uvm_map.

vmmap is designed to perform address space randomized allocations,
without letting fragmentation of the address space go through the roof.

Some highlights:
- kernel address space randomization
- proper implementation of guardpages
- roughly 10% system time reduction during kernel build

Tested by alot of people on tech@@ and developers.
Theo's machines are still happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.23 2011/04/28 20:53:32 ariane Exp $	*/
a89 23

struct pv_page;

struct pv_page_info {
	TAILQ_ENTRY(pv_page) pgi_list;
	struct pv_entry *pgi_freelist;
	int pgi_nfree;
};

/*
 * This is basically:
 * ((PAGE_SIZE - sizeof(struct pv_page_info)) / sizeof(struct pv_entry))
 */
#if PAGE_SHIFT == 13
#define	NPVPPG	340
#elif PAGE_SHIFT == 12
#define	NPVPPG	170
#endif

struct pv_page {
	struct pv_page_info pvp_pgi;
	struct pv_entry pvp_pv[NPVPPG];
};
@


1.23
log
@Expose pmap_prefer parameters.
This will enable uvm_map to behave intelligently when allocating.

Prodded by deraadt to commit this.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.22 2011/03/23 16:54:35 pirofti Exp $	*/
d138 2
@


1.22
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.21 2010/12/26 15:40:59 miod Exp $	*/
d142 6
@


1.21
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.20 2010/12/06 20:57:16 miod Exp $	*/
d39 2
a40 2
#ifndef	_PMAP_MOTOROLA_H_
#define	_PMAP_MOTOROLA_H_
d146 1
a146 1
#endif /* !_PMAP_MOTOROLA_H_ */
@


1.20
log
@Change the signature of PMAP_PREFER from void PMAP_PREFER(..., vaddr_t *) to
vaddr_t PMAP_PREFER(..., vaddr_t). This allows better compiler optimization
when the function is inlined, and avoids accessing memory on architectures
when we can pass function arguments in registers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.19 2010/11/18 21:21:38 miod Exp $	*/
a126 1
#define	pmap_phys_address(frame)	((paddr_t)ptoa(frame))
@


1.19
log
@Declare pmap_proc_iflush() in <uvm/uvm_pmap.h> unless <machine/pmap.h>
provides an inline version of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.18 2010/06/29 20:30:32 guenther Exp $	*/
d141 2
a142 2
void	pmap_prefer(vaddr_t, vaddr_t *);
#define	PMAP_PREFER(foff, vap)	pmap_prefer((foff), (vap))
@


1.18
log
@Remove COMPAT_HPUX.  No one wanted to support it and its fewmets were
blocking other cleanups
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.17 2007/12/28 18:57:28 miod Exp $	*/
a135 2

void	pmap_proc_iflush(struct proc *, vaddr_t, vsize_t);
@


1.17
log
@Do not expose struct pmap unless _KERNEL
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.16 2007/09/10 18:49:45 miod Exp $	*/
a144 4
#endif

#ifdef COMPAT_HPUX
int	pmap_mapmulti(pmap_t, vaddr_t);
@


1.16
log
@Introduce a md pmap hook, pmap_remove_holes(), which is supposed to mark
the holes a MMU may have from a given vm_map. This will be automagically
invoked for newly created vmspaces.

On platforms with MMU holes (e.g. sun4, sun4c and vax), this prevents
mmap(2) hints which would end up being in the hole to be accepted as valid,
causing unexpected signals when the process tries to access the hole
(since pmap can not fill the hole anyway).

Unfortunately, the logic mmap() uses to pick a valid address for anonymous
mappings needs work, as it will only try to find an address higher than the
hint, which causes all mmap() with a hint in the hole to fail on vax. This
will be improved later.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.15 2006/06/24 13:22:14 miod Exp $	*/
d42 2
a112 2

#ifdef	_KERNEL
@


1.15
log
@Add pmap_enter_cache(), similar to pmap_kenter_cache() but for managed
pages, and implement pmap_enter() as a particular case of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.14 2006/06/17 16:29:10 miod Exp $	*/
d132 1
@


1.14
log
@Introduce pmap_kenter_cache(), similar to pmap_kenter_pa() but allowing
the pte cache bits to be specified. Will be used very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.13 2005/10/23 19:00:25 martin Exp $	*/
d138 1
@


1.13
log
@m68k_btop() and m68k_ptob() were mostly used by mac68k only and can
be replaced by the MI versions atop() and ptoa()
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.12 2004/08/07 18:57:44 miod Exp $	*/
d137 2
@


1.12
log
@Need pmap_unuse_final() too; Martin Reindl.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.11 2004/05/20 09:20:42 kettenis Exp $	*/
d84 1
a84 1
                loadustp(m68k_btop((paddr_t)(pmap)->pm_stpa));		\
d127 1
a127 1
#define	pmap_phys_address(frame)	((paddr_t)m68k_ptob(frame))
@


1.11
log
@Properly flush instruction cache for ptrace(PT_WRTIE_{DI}, ...) on powerpc
and m68k.
ok drahn@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.10 2004/01/01 01:12:52 miod Exp $	*/
d131 1
@


1.10
log
@Inline pmap_copy() and pmap_phys_address().
Also get rid of a spurious local initialization in pmap_remove_mapping().
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.9 2003/06/02 23:27:48 millert Exp $	*/
d134 2
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.8 2003/03/01 00:28:45 miod Exp $	*/
d127 1
d129 2
a130 1
#define	pmap_update(pmap)		/* nothing (yet) */
@


1.8
log
@- only declare and provide pmap_map() for mac68k, until it bites the dust.
  Other m68k-based arches do not need it.
- do not wait to allocate struct pv_page. Either pmap_enter() has been
  invoked with PMAP_CANFAIL and can live with this, or we are close to
  fandagoland anyways.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.7 2003/01/27 19:37:30 miod Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@Convert m68k pmap from physseg to VM_PAGE_MD.

This allows us to remove some ambiguities on how some functions are called,
remove some diagnostic checks for conditions that can never happen and
remove the ugly hack with "pmap_initialized".

Then, rework internal function interfaces and some logic so as to stop
fetching vm_page from a pa and the reverse every now and then - this makes
some pmap operations run much faster.

per art@@'s idea.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.6 2002/04/27 23:21:02 miod Exp $	*/
a140 2

vaddr_t	pmap_map(vaddr_t, paddr_t, paddr_t, int);
@


1.6
log
@Jumbo commit to fix all compilation warnings on mvme68k (add prototypes,
add casts, fix a few errors and typos in the process, etc)
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.5 2002/03/14 01:26:34 millert Exp $	*/
d91 1
a91 15
/*
 * For each vm_page_t, there is a list of all currently valid virtual
 * mappings of that page.  An entry is a pv_entry, the list is pv_table.
 */
struct pv_entry {
	struct pv_entry	*pv_next;	/* next pv_entry */
	struct pmap	*pv_pmap;	/* pmap where mapping lies */
	vaddr_t		pv_va;		/* virtual address for mapping */
	st_entry_t	*pv_ptste;	/* non-zero if VA maps a PT page */
	struct pmap	*pv_ptpmap;	/* if pv_ptste, pmap for PT page */
	int		pv_flags;	/* flags */
};

#define	PV_CI		0x01	/* header: all entries are cache inhibited */
#define PV_PTPAGE	0x02	/* header: entry maps a page table page */
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.4 2002/01/10 21:08:41 miod Exp $	*/
d157 4
@


1.4
log
@Reintroduce the pmap_motorola framework.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.2 2001/12/05 00:11:51 millert Exp $	*/
d152 1
a152 1
void	pmap_prefer __P((vaddr_t, vaddr_t *));
d156 1
a156 1
vaddr_t	pmap_map __P((vaddr_t, paddr_t, paddr_t, int));
@


1.3
log
@Temporarily revert the pmap_motorola changes, as they may account for
some problems as well.
Requested by deraadt@@
@
text
@@


1.2
log
@Update pmap_update macro for arches Art missed.  Still just a noop.
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.1 2001/11/30 20:54:50 miod Exp $	*/
@


1.2.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.4 2002/01/10 21:08:41 miod Exp $	*/
@


1.2.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.2.4.1 2002/01/31 22:55:13 niklas Exp $	*/
d152 1
a152 1
void	pmap_prefer(vaddr_t, vaddr_t *);
d156 1
a156 5
vaddr_t	pmap_map(vaddr_t, paddr_t, paddr_t, int);

#ifdef COMPAT_HPUX
int	pmap_mapmulti(pmap_t, vaddr_t);
#endif
@


1.2.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d91 15
a105 1
/* XXX - struct pv_entry moved to vmparam.h because of include ordering issues */
d155 2
@


1.2.2.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d146 1
a146 1
#define	pmap_update()			/* nothing */
@


1.2.2.2
log
@Merge in trunk
@
text
@d146 1
a146 1
#define	pmap_update(pmap)		/* nothing (yet) */
@


1.2.2.3
log
@Merge in -current from about a week ago
@
text
@d152 1
a152 1
void	pmap_prefer(vaddr_t, vaddr_t *);
d156 1
a156 1
vaddr_t	pmap_map(vaddr_t, paddr_t, paddr_t, int);
@


1.2.2.4
log
@Sync the SMP branch with 3.3
@
text
@d91 15
a105 1
/* XXX - struct pv_entry moved to vmparam.h because of include ordering issues */
d156 1
a156 3
#ifdef COMPAT_HPUX
int	pmap_mapmulti(pmap_t, vaddr_t);
#endif
@


1.2.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pmap_motorola.h,v 1.2.2.4 2003/03/27 23:28:43 niklas Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a126 1
#define	pmap_phys_address(frame)	((paddr_t)m68k_ptob(frame))
d128 1
a128 2
#define	pmap_copy(dp,sp,d,l,s)		do { /* nothing */ } while (0)
#define	pmap_update(pmap)		do { /* nothing (yet) */ } while (0)
@


1.2.2.7
log
@Merge with the trunk
@
text
@a134 2
void	pmap_proc_iflush(struct proc *, vaddr_t, vsize_t);

@


1.1
log
@Common pmap defines and code for all m68k platforms using Motorola (or
compatible) MMU.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d146 1
a146 1
#define	pmap_update()			/* nothing */
@

