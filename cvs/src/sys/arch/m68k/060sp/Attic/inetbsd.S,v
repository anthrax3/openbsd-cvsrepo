head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.8
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.70
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.68
	OPENBSD_5_0:1.2.0.66
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.64
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.62
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.58
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.60
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.56
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.54
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.52
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.50
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.48
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.46
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.44
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.42
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.40
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.38
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.36
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.34
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.2
	OPENBSD_3_3:1.2.0.32
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.30
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.28
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.2
	UBC:1.2.0.26
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.24
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.22
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.20
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.16
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@# @;


1.4
date	2014.03.18.22.36.33;	author miod;	state dead;
branches;
next	1.3;

1.3
date	2013.02.02.13.32.05;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	96.05.30.22.14.42;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.05.30.21.14.20;	author niklas;	state Exp;
branches;
next	;


desc
@BSD kernel source file
@


1.4
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*
 *$OpenBSD: inetbsd.S,v 1.3 2013/02/02 13:32:05 miod Exp $
 *$NetBSD: inetbsd.S,v 1.2 1996/05/15 21:16:44 is Exp $
 *
 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *MOTOROLA MICROPROCESSOR & MEMORY TECHNOLOGY GROUP
 *M68000 Hi-Performance Microprocessor Division
 *M68060 Software Package Production Release 
 *
 *M68060 Software Package Copyright (C) 1993, 1994, 1995, 1996 Motorola Inc.
 *All rights reserved.
 *
 *THE SOFTWARE is provided on an "AS IS" basis and without warranty.
 *To the maximum extent permitted by applicable law,
 *MOTOROLA DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED,
 *INCLUDING IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS
 *FOR A PARTICULAR PURPOSE and any warranty against infringement with
 *regard to the SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF)
 *and any accompanying written materials. 
 *
 *To the maximum extent permitted by applicable law,
 *IN NO EVENT SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER
 *(INCLUDING WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
 *BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY LOSS)
 *ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
 *
 *Motorola assumes no responsibility for the maintenance and support
 *of the SOFTWARE.  
 *
 *You are hereby granted a copyright license to use, modify, and distribute the
 *SOFTWARE so long as this entire notice is retained without alteration
 *in any modified and/or redistributed versions, and that such modified
 *versions are clearly identified as such.
 *No licenses are granted by implication, estoppel or otherwise under any
 *patents or trademarks of Motorola, Inc.
 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *Derived from: 
 *iskeleton.s
 *
 *This file contains:
 *	(1) example "Call-out"s
 *	(2) example package entry code
 *	(3) example "Call-out" table
 */


/********************************
 *(1) EXAMPLE CALL-OUTS 	*
 *				*
 *_060_isp_done()		*
 *_060_real_chk()		*
 *_060_real_divbyzero()		*
 *				*
 *_060_real_cas()		*
 *_060_real_cas2()		*
 *_060_real_lock_page()		*
 *_060_real_unlock_page()	*
 ********************************/

/*
 *_060_isp_done():
 *
 *This is and example main exit point for the Unimplemented Integer
 *Instruction exception handler. For a normal exit, the 
 *_isp_unimp() branches to here so that the operating system
 *can do any clean-up desired. The stack frame is the
 *Unimplemented Integer Instruction stack frame with
 *the PC pointing to the instruction following the instruction
 *just emulated.
 *To simply continue execution at the next instruction, just
 *do an "rte".
 */
ASENTRY_NOPROFILE(_060_isp_done)
	rte

/*
 *_060_real_chk():
 *
 *This is an alternate exit point for the Unimplemented Integer
 *Instruction exception handler. If the instruction was a "chk2"
 *and the operand was out of bounds, then _isp_unimp() creates
 *a CHK exception stack frame from the Unimplemented Integer Instrcution
 *stack frame and branches to this routine.
 */
ASENTRY_NOPROFILE(_060_real_chk)
	tstb	%sp@@			|# is tracing enabled?
	bpls	real_chk_end		|# no

/*
 *	    CHK FRAME		   TRACE FRAME
 *	*****************	*****************
 *	*   Current PC	*	*   Current PC	*
 *	*****************	*****************
 *	* 0x2 *  0x018	*	* 0x2 *  0x024	*
 *	*****************	*****************
 *	*     Next	*	*     Next	*
 *	*      PC	*	*      PC	*
 *	*****************	*****************
 *	*      SR	*	*      SR	*
 *	*****************	*****************
 */
	moveb	#0x24,%sp@@(0x7)		|# set trace vecno
	bral	_ASM_LABEL(_060_real_trace)

real_chk_end:
	jmp	_C_LABEL(chkinst)

/*
 *_060_real_divbyzero:
 *
 *This is an alternate exit point for the Unimplemented Integer 
 *Instruction exception handler isp_unimp(). If the instruction is a 64-bit
 *integer divide where the source operand is a zero, then the _isp_unimp() 
 *creates a Divide-by-zero exception stack frame from the Unimplemented
 *Integer Instruction stack frame and branches to this routine.
 *
 *Remember that a trace exception may be pending. The code below performs
 *no action associated with the "chk" exception. If tracing is enabled,
 *then it create a Trace exception stack frame from the "chk" exception
 *stack frame and branches to the _real_trace() entry point.
 */
ASENTRY_NOPROFILE(_060_real_divbyzero)
	tstb	%sp@@			|# is tracing enabled?
	bpls	real_divbyzero_end	|# no

/*
 *	 DIVBYZERO FRAME	   TRACE FRAME
 *	*****************	*****************
 *	*   Current PC	*	*   Current PC	*
 *	*****************	*****************
 *	* 0x2 *  0x014	*	* 0x2 *  0x024	*
 *	*****************	*****************
 *	*     Next	*	*     Next	*
 *	*      PC	*	*      PC	*
 *	*****************	*****************
 *	*      SR	*	*      SR	*
 *	*****************	*****************
 */
	moveb	#0x24,%sp@@(0x7)		|# set trace vecno
	bral	_ASM_LABEL(_060_real_trace)

real_divbyzero_end:
	jmp	_C_LABEL(zerodiv)

/***************************/

/*
 *_060_real_cas():
 *
 *Entry point for the selected cas emulation code implementation.
 *If the implementation provided by the 68060ISP is sufficient,
 *then this routine simply re-enters the package through _isp_cas.
 */
ASENTRY_NOPROFILE(_060_real_cas)
	bral	_C_LABEL(I_CALL_TOP)+0x80+0x08

/*
 *_060_real_cas2():
 *
 *Entry point for the selected cas2 emulation code implementation.
 *If the implementation provided by the 68060ISP is sufficient,
 *then this routine simply re-enters the package through _isp_cas2.
 */
ASENTRY_NOPROFILE(_060_real_cas2)
	bral	_C_LABEL(I_CALL_TOP)+0x80+0x10

/*
 *_060_lock_page():
 *
 *Entry point for the operating system's routine to "lock" a page
 *from being paged out. This routine is needed by the cas/cas2
 *algorithms so that no page faults occur within the "core" code
 *region. Note: the routine must lock two pages if the operand 
 *spans two pages.
 *NOTE: THE ROUTINE SHOULD RETURN AN FSLW VALUE IN D0 ON FAILURE
 *SO THAT THE 060SP CAN CREATE A PROPER ACCESS ERROR FRAME.
 *Arguments:
 *	a0 = operand address
 *	d0 = `xxxxxxff -> supervisor| `xxxxxx00 -> user
 *	d1 = `xxxxxxff -> longword| `xxxxxx00 -> word
 *Expected outputs:
 *	d0 = 0 -> success| non-zero -> failure
 */
ASENTRY_NOPROFILE(_060_real_lock_page)
	clrl	%d0
	rts

/*
 *_060_unlock_page():
 *
 *Entry point for the operating system's routine to "unlock" a
 *page that has been "locked" previously with _real_lock_page.
 *Note: the routine must unlock two pages if the operand spans
 *two pages.
 *Arguments:
 *	a0 = operand address
 *	d0 = `xxxxxxff -> supervisor| `xxxxxx00 -> user
 *	d1 = `xxxxxxff -> longword| `xxxxxx00 -> word
 */
ASENTRY_NOPROFILE(_060_real_unlock_page)
	clrl	%d0
	rts

/****************************************************************************/

/*********************************
 *(2) EXAMPLE PACKAGE ENTRY CODE *
 *********************************/

ASENTRY_NOPROFILE(_060_isp_unimp)
	bral	_C_LABEL(I_CALL_TOP)+0x80+0x00

ASENTRY_NOPROFILE(_060_isp_cas)
	bral	_C_LABEL(I_CALL_TOP)+0x80+0x08

ASENTRY_NOPROFILE(_060_isp_cas2)
	bral	_C_LABEL(I_CALL_TOP)+0x80+0x10

ASENTRY_NOPROFILE(_060_isp_cas_finish)
	bral	_C_LABEL(I_CALL_TOP)+0x80+0x18

ASENTRY_NOPROFILE(_060_isp_cas2_finish)
	bral	_C_LABEL(I_CALL_TOP)+0x80+0x20

ASENTRY_NOPROFILE(_060_isp_cas_inrange)
	bral	_C_LABEL(I_CALL_TOP)+0x80+0x28

ASENTRY_NOPROFILE(_060_isp_cas_terminate)
	bral	_C_LABEL(I_CALL_TOP)+0x80+0x30

ASENTRY_NOPROFILE(_060_isp_cas_restart)
	bral	_C_LABEL(I_CALL_TOP)+0x80+0x38

/****************************************************************************/

/*******************************
 *(3) EXAMPLE CALL-OUT SECTION *
 *******************************/

/*
 *The size of this section MUST be 128 bytes!!!
 */

GLOBAL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_real_chk)-_C_LABEL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_real_divbyzero)-_C_LABEL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_real_trace)-_C_LABEL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_real_access)-_C_LABEL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_isp_done)-_C_LABEL(I_CALL_TOP)

	.long	_ASM_LABEL(_060_real_cas)-_C_LABEL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_real_cas2)-_C_LABEL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_real_lock_page)-_C_LABEL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_real_unlock_page)-_C_LABEL(I_CALL_TOP)

	.long	0x00000000,0x00000000,0x00000000,0x00000000
	.long	0x00000000,0x00000000,0x00000000

	.long	_ASM_LABEL(_060_imem_read)-_C_LABEL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_dmem_read)-_C_LABEL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_dmem_write)-_C_LABEL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_imem_read_word)-_C_LABEL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_imem_read_long)-_C_LABEL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_dmem_read_byte)-_C_LABEL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_dmem_read_word)-_C_LABEL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_dmem_read_long)-_C_LABEL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_dmem_write_byte)-_C_LABEL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_dmem_write_word)-_C_LABEL(I_CALL_TOP)
	.long	_ASM_LABEL(_060_dmem_write_long)-_C_LABEL(I_CALL_TOP)

	.long	0x00000000
	.long	0x00000000,0x00000000,0x00000000,0x00000000

/****************************************************************************/

/*
 *060 INTEGER KERNEL PACKAGE MUST GO HERE!!!
 */

#include "isp.S"
@


1.3
log
@Kernel bits for m68k/ELF, mostly from NetBSD. In addition, the `pmod' symbel
in fpsp has to be renamed due to a clash with other parts of the kernel.
@
text
@d2 1
a2 1
 *$OpenBSD: inetbsd.S,v 1.2 1996/05/30 22:14:42 niklas Exp $
@


1.2
log
@Added $OpenBSD$ tags
@
text
@d1 73
a73 74
#
# $OpenBSD: inetbsd.S,v 1.2 1996/05/15 21:16:44 is Exp $
# $NetBSD: inetbsd.S,v 1.2 1996/05/15 21:16:44 is Exp $
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# MOTOROLA MICROPROCESSOR & MEMORY TECHNOLOGY GROUP
# M68000 Hi-Performance Microprocessor Division
# M68060 Software Package Production Release 
# 
# M68060 Software Package Copyright (C) 1993, 1994, 1995, 1996 Motorola Inc.
# All rights reserved.
# 
# THE SOFTWARE is provided on an "AS IS" basis and without warranty.
# To the maximum extent permitted by applicable law,
# MOTOROLA DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED,
# INCLUDING IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS
# FOR A PARTICULAR PURPOSE and any warranty against infringement with
# regard to the SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF)
# and any accompanying written materials. 
# 
# To the maximum extent permitted by applicable law,
# IN NO EVENT SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER
# (INCLUDING WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
# BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY LOSS)
# ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
# 
# Motorola assumes no responsibility for the maintenance and support
# of the SOFTWARE.  
# 
# You are hereby granted a copyright license to use, modify, and distribute the
# SOFTWARE so long as this entire notice is retained without alteration
# in any modified and/or redistributed versions, and that such modified
# versions are clearly identified as such.
# No licenses are granted by implication, estoppel or otherwise under any
# patents or trademarks of Motorola, Inc.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Derived from: 
# iskeleton.s
#
# This file contains:
#	(1) example "Call-out"s
#	(2) example package entry code
#	(3) example "Call-out" table
#


#################################
# (1) EXAMPLE CALL-OUTS 	#
#				#
# _060_isp_done()		#
# _060_real_chk()		#
# _060_real_divbyzero()		#
#				#
# _060_real_cas()		#
# _060_real_cas2()		#
# _060_real_lock_page()		#
# _060_real_unlock_page()	#
#################################

#
# _060_isp_done():
#
# This is and example main exit point for the Unimplemented Integer
# Instruction exception handler. For a normal exit, the 
# _isp_unimp() branches to here so that the operating system
# can do any clean-up desired. The stack frame is the
# Unimplemented Integer Instruction stack frame with
# the PC pointing to the instruction following the instruction
# just emulated.
# To simply continue execution at the next instruction, just
# do an "rte".
#
	.global	_060_isp_done
_060_isp_done:
d76 11
a86 12
#
# _060_real_chk():
#
# This is an alternate exit point for the Unimplemented Integer
# Instruction exception handler. If the instruction was a "chk2"
# and the operand was out of bounds, then _isp_unimp() creates
# a CHK exception stack frame from the Unimplemented Integer Instrcution
# stack frame and branches to this routine.
#
	.global	_060_real_chk
_060_real_chk:
	tstb	sp@@		|# is tracing enabled?
d89 15
a103 15
#
#	    CHK FRAME		   TRACE FRAME
#	*****************	*****************
#	*   Current PC	*	*   Current PC	*
#	*****************	*****************
#	* 0x2 *  0x018	*	* 0x2 *  0x024	*
#	*****************	*****************
#	*     Next	*	*     Next	*
#	*      PC	*	*      PC	*
#	*****************	*****************
#	*      SR	*	*      SR	*
#	*****************	*****************
#
	moveb	#0x24,sp@@(0x7)		|# set trace vecno
	bral	_060_real_trace
d106 1
a106 1
	jmp	_chkinst
d108 33
a140 34
#
# _060_real_divbyzero:
#
# This is an alternate exit point for the Unimplemented Integer 
# Instruction exception handler isp_unimp(). If the instruction is a 64-bit
# integer divide where the source operand is a zero, then the _isp_unimp() 
# creates a Divide-by-zero exception stack frame from the Unimplemented
# Integer Instruction stack frame and branches to this routine.
#
# Remember that a trace exception may be pending. The code below performs
# no action associated with the "chk" exception. If tracing is enabled,
# then it create a Trace exception stack frame from the "chk" exception
# stack frame and branches to the _real_trace() entry point.
# 
	.global	_060_real_divbyzero
_060_real_divbyzero:
	tstb	sp@@		|# is tracing enabled?
	bpls	real_divbyzero_end		|# no

#
#	 DIVBYZERO FRAME	   TRACE FRAME
#	*****************	*****************
#	*   Current PC	*	*   Current PC	*
#	*****************	*****************
#	* 0x2 *  0x014	*	* 0x2 *  0x024	*
#	*****************	*****************
#	*     Next	*	*     Next	*
#	*      PC	*	*      PC	*
#	*****************	*****************
#	*      SR	*	*      SR	*
#	*****************	*****************
#
	moveb	#0x24,sp@@(0x7)		|# set trace vecno
	bral	_060_real_trace
d143 1
a143 1
	jmp	_zerodiv
d145 1
a145 1
###########################
d147 39
a185 42
#
# _060_real_cas():
#
# Entry point for the selected cas emulation code implementation.
# If the implementation provided by the 68060ISP is sufficient,
# then this routine simply re-enters the package through _isp_cas.
#
	.global	_060_real_cas
_060_real_cas:
	bral	_I_CALL_TOP+0x80+0x08

#
# _060_real_cas2():
#
# Entry point for the selected cas2 emulation code implementation.
# If the implementation provided by the 68060ISP is sufficient,
# then this routine simply re-enters the package through _isp_cas2.
#
	.global	_060_real_cas2
_060_real_cas2:
	bral	_I_CALL_TOP+0x80+0x10

#
# _060_lock_page():
#
# Entry point for the operating system's routine to "lock" a page
# from being paged out. This routine is needed by the cas/cas2
# algorithms so that no page faults occur within the "core" code
# region. Note: the routine must lock two pages if the operand 
# spans two pages.
# NOTE: THE ROUTINE SHOULD RETURN AN FSLW VALUE IN D0 ON FAILURE
# SO THAT THE 060SP CAN CREATE A PROPER ACCESS ERROR FRAME.
# Arguments:
#	a0 = operand address
#	d0 = `xxxxxxff -> supervisor| `xxxxxx00 -> user
#	d1 = `xxxxxxff -> longword| `xxxxxx00 -> word
# Expected outputs:
#	d0 = 0 -> success| non-zero -> failure
#
	.global	_060_real_lock_page
_060_real_lock_page:
	clrl	d0
d188 14
a201 15
#
# _060_unlock_page():
#
# Entry point for the operating system's routine to "unlock" a
# page that has been "locked" previously with _real_lock_page.
# Note: the routine must unlock two pages if the operand spans
# two pages.
# Arguments:
# 	a0 = operand address
#	d0 = `xxxxxxff -> supervisor| `xxxxxx00 -> user
#	d1 = `xxxxxxff -> longword| `xxxxxx00 -> word
#
	.global	_060_real_unlock_page
_060_real_unlock_page:
	clrl	d0
d204 1
a204 1
############################################################################
d206 49
a254 56
##################################
# (2) EXAMPLE PACKAGE ENTRY CODE #
##################################

	.global	_060_isp_unimp
_060_isp_unimp:
	bral	_I_CALL_TOP+0x80+0x00

	.global	_060_isp_cas
_060_isp_cas:
	bral	_I_CALL_TOP+0x80+0x08

	.global	_060_isp_cas2
_060_isp_cas2:
	bral	_I_CALL_TOP+0x80+0x10

	.global	_060_isp_cas_finish
_060_isp_cas_finish:
	bral	_I_CALL_TOP+0x80+0x18

	.global	_060_isp_cas2_finish
_060_isp_cas2_finish:
	bral	_I_CALL_TOP+0x80+0x20

	.global	_060_isp_cas_inrange
_060_isp_cas_inrange:
	bral	_I_CALL_TOP+0x80+0x28

	.global	_060_isp_cas_terminate
_060_isp_cas_terminate:
	bral	_I_CALL_TOP+0x80+0x30

	.global	_060_isp_cas_restart
_060_isp_cas_restart:
	bral	_I_CALL_TOP+0x80+0x38

############################################################################

################################
# (3) EXAMPLE CALL-OUT SECTION #
################################

# The size of this section MUST be 128 bytes!!!

	.global	_I_CALL_TOP
_I_CALL_TOP:
	.long	_060_real_chk-_I_CALL_TOP
	.long	_060_real_divbyzero-_I_CALL_TOP
	.long	_060_real_trace-_I_CALL_TOP
	.long	_060_real_access-_I_CALL_TOP
	.long	_060_isp_done-_I_CALL_TOP

	.long	_060_real_cas-_I_CALL_TOP
	.long	_060_real_cas2-_I_CALL_TOP
	.long	_060_real_lock_page-_I_CALL_TOP
	.long	_060_real_unlock_page-_I_CALL_TOP
d259 11
a269 11
	.long	_060_imem_read-_I_CALL_TOP
	.long	_060_dmem_read-_I_CALL_TOP
	.long	_060_dmem_write-_I_CALL_TOP
	.long	_060_imem_read_word-_I_CALL_TOP
	.long	_060_imem_read_long-_I_CALL_TOP
	.long	_060_dmem_read_byte-_I_CALL_TOP
	.long	_060_dmem_read_word-_I_CALL_TOP
	.long	_060_dmem_read_long-_I_CALL_TOP
	.long	_060_dmem_write_byte-_I_CALL_TOP
	.long	_060_dmem_write_word-_I_CALL_TOP
	.long	_060_dmem_write_long-_I_CALL_TOP
d274 1
a274 1
############################################################################
d276 3
a278 1
# 060 INTEGER KERNEL PACKAGE MUST GO HERE!!!
d280 1
a280 1
	.include	"isp.S"
@


1.1
log
@checkin of files sup have missed earlier, this dir is now at 0529
@
text
@d2 1
@
