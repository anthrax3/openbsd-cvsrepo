head	1.5;
access;
symbols
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.66
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.64
	OPENBSD_5_0:1.3.0.62
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.60
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.58
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.54
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.56
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.52
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.50
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.48
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.46
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.44
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.42
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.40
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.38
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.36
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.34
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.32
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.30
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.28
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.26
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.24
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.22
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.20
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.18
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.12
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@# @;


1.5
date	2014.03.18.22.36.33;	author miod;	state dead;
branches;
next	1.4;

1.4
date	2013.02.02.13.32.05;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	97.07.06.07.46.19;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.05.30.22.15.02;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.05.30.21.14.25;	author niklas;	state Exp;
branches;
next	;


desc
@BSD kernel source file
@


1.5
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*
 * $OpenBSD: netbsd.S,v 1.4 2013/02/02 13:32:05 miod Exp $
 * $NetBSD: netbsd.S,v 1.3 1997/06/27 23:32:09 is Exp $
 *
 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * MOTOROLA MICROPROCESSOR & MEMORY TECHNOLOGY GROUP
 * M68000 Hi-Performance Microprocessor Division
 * M68060 Software Package Production Release 
 * 
 * M68060 Software Package Copyright (C) 1993, 1994, 1995, 1996 Motorola Inc.
 * All rights reserved.
 * 
 * THE SOFTWARE is provided on an "AS IS" basis and without warranty.
 * To the maximum extent permitted by applicable law,
 * MOTOROLA DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED,
 * INCLUDING IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS
 * FOR A PARTICULAR PURPOSE and any warranty against infringement with
 * regard to the SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF)
 * and any accompanying written materials. 
 * 
 * To the maximum extent permitted by applicable law,
 * IN NO EVENT SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER
 * (INCLUDING WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
 * BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY LOSS)
 * ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
 * 
 * Motorola assumes no responsibility for the maintenance and support
 * of the SOFTWARE.  
 * 
 * You are hereby granted a copyright license to use, modify, and distribute the
 * SOFTWARE so long as this entire notice is retained without alteration
 * in any modified and/or redistributed versions, and that such modified
 * versions are clearly identified as such.
 * No licenses are granted by implication, estoppel or otherwise under any
 * patents or trademarks of Motorola, Inc.
 *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * Derived from:
 * os.s
 *
 * This file contains:
 *	- example "Call-Out"s required by both the ISP and FPSP.
 */

#include <machine/asm.h>

/*
 * make the copyright notice appear in the binary:
 */
#include "copyright.S"

/********************************
 * EXAMPLE CALL-OUTS 		*
 * 				*
 * _060_dmem_write()		*
 * _060_dmem_read()		*
 * _060_imem_read()		*
 * _060_dmem_read_byte()	*
 * _060_dmem_read_word()	*
 * _060_dmem_read_long()	*
 * _060_imem_read_word()	*
 * _060_imem_read_long()	*
 * _060_dmem_write_byte()	*
 * _060_dmem_write_word()	*
 * _060_dmem_write_long()	*
 *				*
 * _060_real_trace()		*
 * _060_real_access()		*
 ********************************/

/* 
 * Each IO routine checks to see if the memory write/read is to/from user
 * or supervisor application space. The examples below use simple "move"
 * instructions for supervisor mode applications and call _copyin()/_copyout()
 * for user mode applications.
 * When installing the 060SP, the _copyin()/_copyout() equivalents for a 
 * given operating system should be substituted.
 *
 * The addresses within the 060SP are guaranteed to be on the stack.
 * The result is that Unix processes are allowed to sleep as a consequence
 * of a page fault during a _copyout.
 */

/*
 * _060_dmem_write():
 *
 * Writes to data memory while in supervisor mode.
 *
 * INPUTS:
 *	a0 - supervisor source address	
 *	a1 - user destination address
 *	d0 - number of bytes to write	
 * 	a6@@(0x4),bit5 - 1 = supervisor mode, 0 = user mode
 * OUTPUTS:
 *	d1 - 0 = success, !0 = failure
 */
ASENTRY_NOPROFILE(_060_dmem_write)
	btst	#0x5,%a6@@(0x4)	|# check for supervisor state
	beqs	user_write
super_write:
	moveb	%a0@@+,%a1@@+	|# copy 1 byte
	subql	#0x1,%d0	|# decr byte counter
	bnes	super_write	|# quit if ctr = 0
	clrl	%d1		|# return success
	rts
user_write:
	movel	%d0,%sp@@-	|# pass: counter
	movel	%a1,%sp@@-	|# pass: user dst
	movel	%a0,%sp@@-	|# pass: supervisor src
	bsrl	_C_LABEL(copyout)	|# write byte to user mem
	movel	%d0,%d1		|# return success
	addl	#0xc,%sp		|# clear 3 lw params
	rts

/*
 * _060_imem_read(), _060_dmem_read():
 *
 * Reads from data/instruction memory while in supervisor mode.
 *
 * INPUTS:
 *	a0 - user source address
 *	a1 - supervisor destination address
 *	d0 - number of bytes to read
 * 	a6@@(0x4),bit5 - 1 = supervisor mode, 0 = user mode
 * OUTPUTS:
 *	d1 - 0 = success, !0 = failure
 */
ASENTRY_NOPROFILE(_060_imem_read)
ASENTRY_NOPROFILE(_060_dmem_read)
	btst	#0x5,%a6@@(0x4)	|# check for supervisor state
	beqs	user_read
super_read:
	moveb	%a0@@+,%a1@@+	|# copy 1 byte
	subql	#0x1,%d0	|# decr byte counter
	bnes	super_read	|# quit if ctr = 0
	clrl	%d1		|# return success
	rts
user_read:
	movel	%d0,%sp@@-	|# pass: counter
	movel	%a1,%sp@@-	|# pass: super dst
	movel	%a0,%sp@@-	|# pass: user src
	bsrl	_C_LABEL(copyin)	|# read byte from user mem
	movel	%d0,%d1		|# return success
	addl	#0xc,%sp	|# clear 3 lw params
	rts

/*
 * _060_dmem_read_byte():
 * 
 * Read a data byte from user memory.
 *
 * INPUTS:
 *	a0 - user source address
 * 	a6@@(0x4),bit5 - 1 = supervisor mode, 0 = user mode
 * OUTPUTS:
 *	d0 - data byte in d0
 *	d1 - 0 = success, !0 = failure
 */
ASENTRY_NOPROFILE(_060_dmem_read_byte)
	btst	#0x5,%a6@@(0x4)	|# check for supervisor state
	bnes	dmrbs		|# supervisor
dmrbu:
	clrl	%sp@@-		|# clear space on stack for result
	movel	#0x1,%sp@@-	|# pass: # bytes to copy
	pea	%sp@@(0x7)	|# pass: dst addr (stack)
	movel	%a0,%sp@@-	|# pass: src addr (user mem)
	bsrl	_C_LABEL(copyin)		|# "copy in" the data
	movel	%d0,%d1		|# return success
	addl	#0xc,%sp	|# delete params
	movel	%sp@@+,%d0	|# put answer in d0
	rts
dmrbs:
	clrl	%d0		|# clear whole longword
	moveb	%a0@@,%d0	|# fetch super byte
	clrl	%d1		|# return success
	rts

/*
 * _060_imem_read_word():
 * Read an instruction word from user memory.
 *
 * _060_dmem_read_word():
 * Read a data word from user memory.
 *
 * INPUTS:
 *	a0 - user source address
 * 	a6@@(0x4),bit5 - 1 = supervisor mode, 0 = user mode
 * OUTPUTS:
 *	d0 - data word in d0
 *	d1 - 0 = success, !0 = failure
 */

ASENTRY_NOPROFILE(_060_imem_read_word)
ASENTRY_NOPROFILE(_060_dmem_read_word)
	btst	#0x5,%a6@@(0x4)	|# check for supervisor state
	bnes	dmrws		|# supervisor
dmrwu:
	clrl	%sp@@-		|# clear result space on stack
	movel	#0x2,%sp@@-	|# pass: # bytes to copy
	pea	%sp@@(0x6)	|# pass: dst addr (stack)
	movel	%a0,%sp@@-	|# pass: src addr (user mem)
	bsrl	_C_LABEL(copyin)		|# "copy in" the data
	movel	%d0,%d1		|# return success
	addl	#0xc,%sp	|# delete params
	movel	%sp@@+,%d0	|# put answer in d0
	rts
dmrws:
	clrl	%d0		|# clear whole longword
	movew	%a0@@,%d0	|# fetch super word
	clrl	%d1		|# return success
	rts

/* 
 * _060_imem_read_long():
 * Read an instruction longword from user memory.
 *
 * _060_dmem_read_long():
 * Read an data longword from user memory.
 * 

 *
 * INPUTS:
 *	a0 - user source address
 * 	a6@@(0x4),bit5 - 1 = supervisor mode, 0 = user mode
 * OUTPUTS:
 *	d0 - data longword in d0
 *	d1 - 0 = success, !0 = failure
 */

ASENTRY_NOPROFILE(_060_imem_read_long)
ASENTRY_NOPROFILE(_060_dmem_read_long)
	btst	#0x5,%a6@@(0x4)	|# check for supervisor state
	bnes	dmrls		|# supervisor
dmrlu:
	subql	#0x4,%sp	|# clear result space on stack
	movel	#0x4,%sp@@-	|# pass: # bytes to copy
	pea	%sp@@(0x4)	|# pass: dst addr (stack)
	movel	%a0,%sp@@-	|# pass: src addr (user mem)
	bsrl	_C_LABEL(copyin)	|# "copy in" the data
	movel	%d0,%d1		|# return success
	addl	#0xc,%sp	|# delete params
	movel	%sp@@+,%d0	|# put answer in d0
	rts
dmrls:
	movel	%a0@@,%d0	|# fetch super longword
	clrl	%d1		|# return success
	rts

/*
 * _060_dmem_write_byte():
 *
 * Write a data byte to user memory.
 *
 * INPUTS:
 *	a0 - user destination address
 * 	d0 - data byte in d0
 * 	a6@@(0x4),bit5 - 1 = supervisor mode, 0 = user mode
 * OUTPUTS:
 *	d1 - 0 = success, !0 = failure
 */
ASENTRY_NOPROFILE(_060_dmem_write_byte)
	btst	#0x5,%a6@@(0x4)	|# check for supervisor state
	bnes	dmwbs		|# supervisor
dmwbu:
	movel	%d0,%sp@@-	|# put src on stack
	movel	#0x1,%sp@@-	|# pass: # bytes to copy
	movel	%a0,%sp@@-	|# pass: dst addr (user mem)
	pea	%sp@@(0xb)	|# pass: src addr (stack)
	bsrl	_C_LABEL(copyout)	|# "copy out" the data
	movel	%d0,%d1		|# return success
	addl	#0x10,%sp	|# delete params + src
	rts
dmwbs:
	moveb	%d0,%a0@@	|# store super byte
	clrl	%d1		|# return success
	rts

/*
 * _060_dmem_write_word():
 *
 * Write a data word to user memory.
 *
 * INPUTS:
 *	a0 - user destination address
 * 	d0 - data word in d0
 * 	a6@@(0x4),bit5 - 1 = supervisor mode, 0 = user mode
 * OUTPUTS:
 *	d1 - 0 = success, !0 = failure
 */
ASENTRY_NOPROFILE(_060_dmem_write_word)
	btst	#0x5,%a6@@(0x4)	|# check for supervisor state
	bnes	dmwws		|# supervisor
dmwwu:
	movel	%d0,%sp@@-	|# put src on stack
	movel	#0x2,%sp@@-	|# pass: # bytes to copy
	movel	%a0,%sp@@-	|# pass: dst addr (user mem)
	pea	%sp@@(0xa)	|# pass: src addr (stack)
	bsrl	_C_LABEL(copyout)	|# "copy out" the data
	movel	%d0,%d1		|# return success
	addl	#0x10,%sp	|# delete params + src
	rts
dmwws:
	movew	%d0,%a0@@	|# store super word
	clrl	%d1		|# return success
	rts

/*
 * _060_dmem_write_long():
 *
 * Write a data longword to user memory.
 *
 * INPUTS:
 *	a0 - user destination address
 * 	d0 - data longword in d0
 * 	a6@@(0x4),bit5 - 1 = supervisor mode, 0 = user mode
 * OUTPUTS:
 *	d1 - 0 = success, !0 = failure
 */
ASENTRY_NOPROFILE(_060_dmem_write_long)
	btst	#0x5,%a6@@(0x4)	|# check for supervisor state
	bnes	dmwls		|# supervisor
dmwlu:
	movel	%d0,%sp@@-	|# put src on stack
	movel	#0x4,%sp@@-	|# pass: # bytes to copy
	movel	%a0,%sp@@-	|# pass: dst addr (user mem)
	pea	%sp@@(0x8)	|# pass: src addr (stack)
	bsrl	_C_LABEL(copyout)	|# "copy out" the data
	movel	%d0,%d1		|# return success
	addl	#0x10,%sp	|# delete params + src
	rts
dmwls:
	movel	%d0,%a0@@	|# store super longword
	clrl	%d1		|# return success
	rts

/*###########################################################################/

/*
 * _060_real_trace():
 *
 * This is the exit point for the 060FPSP when an instruction is being traced
 * and there are no other higher priority exceptions pending for this instruction
 * or they have already been processed.
 *
 * The sample code below simply executes an "rte".
 */
ASENTRY_NOPROFILE(_060_real_trace)
	jra	_C_LABEL(trace)

/*
 * _060_real_access():
 *
 * This is the exit point for the 060FPSP when an access error exception
 * is encountered. The routine below should point to the operating system
 * handler for access error exceptions. The exception stack frame is an
 * 8-word access error frame.
 *
 * We jump directly to the 68060 buserr handler.
 * If we had a sane ld, we could use use that entry point directly...
 */
ASENTRY_NOPROFILE(_060_real_access)
	jra	_C_LABEL(buserr60)

#include "inetbsd.S"
#include "fnetbsd.S"
@


1.4
log
@Kernel bits for m68k/ELF, mostly from NetBSD. In addition, the `pmod' symbel
in fpsp has to be renamed due to a clash with other parts of the kernel.
@
text
@d2 1
a2 1
 * $OpenBSD: netbsd.S,v 1.3 1997/07/06 07:46:19 downsj Exp $
@


1.3
log
@Sync with NetBSD changes, 970415 - 970705.

This includes a new asm.h, as well as even more code abstracted from hp300.
These changes are likely to break ports that don't know about them; hp300
runs at the moment.
@
text
@d1 98
a98 97
#
# $OpenBSD: netbsd.S,v 1.2 1996/05/30 22:15:02 niklas Exp $
# $NetBSD: netbsd.S,v 1.3 1997/06/27 23:32:09 is Exp $
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# MOTOROLA MICROPROCESSOR & MEMORY TECHNOLOGY GROUP
# M68000 Hi-Performance Microprocessor Division
# M68060 Software Package Production Release 
# 
# M68060 Software Package Copyright (C) 1993, 1994, 1995, 1996 Motorola Inc.
# All rights reserved.
# 
# THE SOFTWARE is provided on an "AS IS" basis and without warranty.
# To the maximum extent permitted by applicable law,
# MOTOROLA DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED,
# INCLUDING IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS
# FOR A PARTICULAR PURPOSE and any warranty against infringement with
# regard to the SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF)
# and any accompanying written materials. 
# 
# To the maximum extent permitted by applicable law,
# IN NO EVENT SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER
# (INCLUDING WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
# BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY LOSS)
# ARISING OF THE USE OR INABILITY TO USE THE SOFTWARE.
# 
# Motorola assumes no responsibility for the maintenance and support
# of the SOFTWARE.  
# 
# You are hereby granted a copyright license to use, modify, and distribute the
# SOFTWARE so long as this entire notice is retained without alteration
# in any modified and/or redistributed versions, and that such modified
# versions are clearly identified as such.
# No licenses are granted by implication, estoppel or otherwise under any
# patents or trademarks of Motorola, Inc.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
# Derived from:
# os.s
#
# This file contains:
#	- example "Call-Out"s required by both the ISP and FPSP.
#

#
# make the copyright notice appear in the binary:
#
	.include	"copyright.S"

#################################
# EXAMPLE CALL-OUTS 		#
# 				#
# _060_dmem_write()		#
# _060_dmem_read()		#
# _060_imem_read()		#
# _060_dmem_read_byte()		#
# _060_dmem_read_word()		#
# _060_dmem_read_long()		#
# _060_imem_read_word()		#
# _060_imem_read_long()		#
# _060_dmem_write_byte()	#
# _060_dmem_write_word()	#
# _060_dmem_write_long()	#
#				#
# _060_real_trace()		#
# _060_real_access()		#
#################################

# 
# Each IO routine checks to see if the memory write/read is to/from user
# or supervisor application space. The examples below use simple "move"
# instructions for supervisor mode applications and call _copyin()/_copyout()
# for user mode applications.
# When installing the 060SP, the _copyin()/_copyout() equivalents for a 
# given operating system should be substituted.
#
# The addresses within the 060SP are guaranteed to be on the stack.
# The result is that Unix processes are allowed to sleep as a consequence
# of a page fault during a _copyout.
#

#
# _060_dmem_write():
#
# Writes to data memory while in supervisor mode.
#
# INPUTS:
#	a0 - supervisor source address	
#	a1 - user destination address
#	d0 - number of bytes to write	
# 	a6@@(0x4),bit5 - 1 = supervisor mode, 0 = user mode
# OUTPUTS:
#	d1 - 0 = success, !0 = failure
#
	.global	_060_dmem_write
_060_dmem_write:
	btst	#0x5,a6@@(0x4)	|# check for supervisor state
d101 2
a102 2
	moveb	a0@@+,a1@@+	|# copy 1 byte
	subql	#0x1,d0		|# decr byte counter
d104 1
a104 1
	clrl	d1		|# return success
d107 24
a130 26
	movel	d0,sp@@-		|# pass: counter
	movel	a1,sp@@-		|# pass: user dst
	movel	a0,sp@@-		|# pass: supervisor src
	bsrl	_copyout	|# write byte to user mem
	movel	d0,d1		|# return success
	addl	#0xc,sp		|# clear 3 lw params
	rts

#
# _060_imem_read(), _060_dmem_read():
#
# Reads from data/instruction memory while in supervisor mode.
#
# INPUTS:
#	a0 - user source address
#	a1 - supervisor destination address
#	d0 - number of bytes to read
# 	a6@@(0x4),bit5 - 1 = supervisor mode, 0 = user mode
# OUTPUTS:
#	d1 - 0 = success, !0 = failure
#
	.global	_060_imem_read
	.global	_060_dmem_read
_060_imem_read:
_060_dmem_read:
	btst	#0x5,a6@@(0x4)	|# check for supervisor state
d133 2
a134 2
	moveb	a0@@+,a1@@+	|# copy 1 byte
	subql	#0x1,d0		|# decr byte counter
d136 1
a136 1
	clrl	d1		|# return success
d139 22
a160 23
	movel	d0,sp@@-		|# pass: counter
	movel	a1,sp@@-		|# pass: super dst
	movel	a0,sp@@-		|# pass: user src
	bsrl	_copyin		|# read byte from user mem
	movel	d0,d1		|# return success
	addl	#0xc,sp		|# clear 3 lw params
	rts

#
# _060_dmem_read_byte():
# 
# Read a data byte from user memory.
#
# INPUTS:
#	a0 - user source address
# 	a6@@(0x4),bit5 - 1 = supervisor mode, 0 = user mode
# OUTPUTS:
#	d0 - data byte in d0
#	d1 - 0 = success, !0 = failure
#
	.global	_060_dmem_read_byte
_060_dmem_read_byte:
	btst	#0x5,a6@@(0x4)	|# check for supervisor state
d163 8
a170 8
	clrl	sp@@-		|# clear space on stack for result
	movel	#0x1,sp@@-	|# pass: # bytes to copy
	pea	sp@@(0x7)	|# pass: dst addr (stack)
	movel	a0,sp@@-		|# pass: src addr (user mem)
	bsrl	_copyin		|# "copy in" the data
	movel	d0,d1		|# return success
	addl	#0xc,sp		|# delete params
	movel	sp@@+,d0		|# put answer in d0
d173 23
a195 25
	clrl	d0		|# clear whole longword
	moveb	a0@@,d0		|# fetch super byte
	clrl	d1		|# return success
	rts

#
# _060_imem_read_word():
# Read an instruction word from user memory.
#
# _060_dmem_read_word():
# Read a data word from user memory.
#
# INPUTS:
#	a0 - user source address
# 	a6@@(0x4),bit5 - 1 = supervisor mode, 0 = user mode
# OUTPUTS:
#	d0 - data word in d0
#	d1 - 0 = success, !0 = failure
#
	.global	_060_imem_read_word
	.global	_060_dmem_read_word

_060_imem_read_word:
_060_dmem_read_word:
	btst	#0x5,a6@@(0x4)	|# check for supervisor state
d198 8
a205 8
	clrl	sp@@-		|# clear result space on stack
	movel	#0x2,sp@@-	|# pass: # bytes to copy
	pea	sp@@(0x6)	|# pass: dst addr (stack)
	movel	a0,sp@@-		|# pass: src addr (user mem)
	bsrl	_copyin		|# "copy in" the data
	movel	d0,d1		|# return success
	addl	#0xc,sp		|# delete params
	movel	sp@@+,d0		|# put answer in d0
d208 25
a232 28
	clrl	d0		|# clear whole longword
	movew	a0@@,d0		|# fetch super word
	clrl	d1		|# return success
	rts

# 
# _060_imem_read_long():
# Read an instruction longword from user memory.
#
# _060_dmem_read_long():
# Read an data longword from user memory.
# 

#
# INPUTS:
#	a0 - user source address
# 	a6@@(0x4),bit5 - 1 = supervisor mode, 0 = user mode
# OUTPUTS:
#	d0 - data longword in d0
#	d1 - 0 = success, !0 = failure
#

	.global	_060_dmem_read_long
	.global	_060_imem_read_long

_060_imem_read_long:
_060_dmem_read_long:
	btst	#0x5,a6@@(0x4)	|# check for supervisor state
d235 8
a242 8
	subql	#0x4,sp		|# clear result space on stack
	movel	#0x4,sp@@-	|# pass: # bytes to copy
	pea	sp@@(0x4)	|# pass: dst addr (stack)
	movel	a0,sp@@-		|# pass: src addr (user mem)
	bsrl	_copyin		|# "copy in" the data
	movel	d0,d1		|# return success
	addl	#0xc,sp		|# delete params
	movel	sp@@+,d0		|# put answer in d0
d245 2
a246 2
	movel	a0@@,d0		|# fetch super longword
	clrl	d1		|# return success
d249 14
a262 15
#
# _060_dmem_write_byte():
#
# Write a data byte to user memory.
#
# INPUTS:
#	a0 - user destination address
# 	d0 - data byte in d0
# 	a6@@(0x4),bit5 - 1 = supervisor mode, 0 = user mode
# OUTPUTS:
#	d1 - 0 = success, !0 = failure
#
	.global	_060_dmem_write_byte
_060_dmem_write_byte:
	btst	#0x5,a6@@(0x4)	|# check for supervisor state
d265 7
a271 7
	movel	d0,sp@@-		|# put src on stack
	movel	#0x1,sp@@-	|# pass: # bytes to copy
	movel	a0,sp@@-		|# pass: dst addr (user mem)
	pea	sp@@(0xb)	|# pass: src addr (stack)
	bsrl	_copyout	|# "copy out" the data
	movel	d0,d1		|# return success
	addl	#0x10,sp	|# delete params + src
d274 2
a275 2
	moveb	d0,a0@@		|# store super byte
	clrl	d1		|# return success
d278 14
a291 15
#
# _060_dmem_write_word():
#
# Write a data word to user memory.
#
# INPUTS:
#	a0 - user destination address
# 	d0 - data word in d0
# 	a6@@(0x4),bit5 - 1 = supervisor mode, 0 = user mode
# OUTPUTS:
#	d1 - 0 = success, !0 = failure
#
	.global	_060_dmem_write_word
_060_dmem_write_word:
	btst	#0x5,a6@@(0x4)	|# check for supervisor state
d294 7
a300 7
	movel	d0,sp@@-		|# put src on stack
	movel	#0x2,sp@@-	|# pass: # bytes to copy
	movel	a0,sp@@-		|# pass: dst addr (user mem)
	pea	sp@@(0xa)	|# pass: src addr (stack)
	bsrl	_copyout	|# "copy out" the data
	movel	d0,d1		|# return success
	addl	#0x10,sp	|# delete params + src
d303 2
a304 2
	movew	d0,a0@@		|# store super word
	clrl	d1		|# return success
d307 14
a320 15
#
# _060_dmem_write_long():
#
# Write a data longword to user memory.
#
# INPUTS:
#	a0 - user destination address
# 	d0 - data longword in d0
# 	a6@@(0x4),bit5 - 1 = supervisor mode, 0 = user mode
# OUTPUTS:
#	d1 - 0 = success, !0 = failure
#
	.global	_060_dmem_write_long
_060_dmem_write_long:
	btst	#0x5,a6@@(0x4)	|# check for supervisor state
d323 7
a329 7
	movel	d0,sp@@-		|# put src on stack
	movel	#0x4,sp@@-	|# pass: # bytes to copy
	movel	a0,sp@@-		|# pass: dst addr (user mem)
	pea	sp@@(0x8)	|# pass: src addr (stack)
	bsrl	_copyout	|# "copy out" the data
	movel	d0,d1		|# return success
	addl	#0x10,sp	|# delete params + src
d332 2
a333 2
	movel	d0,a0@@		|# store super longword
	clrl	d1		|# return success
d336 1
a336 1
############################################################################
d338 25
a362 27
#
# _060_real_trace():
#
# This is the exit point for the 060FPSP when an instruction is being traced
# and there are no other higher priority exceptions pending for this instruction
# or they have already been processed.
#
# The sample code below simply executes an "rte".
#
	.global	_060_real_trace,_trace
_060_real_trace:
	jra	_trace

#
# _060_real_access():
#
# This is the exit point for the 060FPSP when an access error exception
# is encountered. The routine below should point to the operating system
# handler for access error exceptions. The exception stack frame is an
# 8-word access error frame.
#
# We jump directly to the 68060 buserr handler.
# If we had a sane ld, we could use use that entry point directly...
#
	.globl	_060_real_access,_buserr60
_060_real_access:
	jra	_buserr60
d364 2
a365 2
	.include	"inetbsd.S"
	.include	"fnetbsd.S"
@


1.2
log
@Added $OpenBSD$ tags
@
text
@d2 2
a3 2
# $OpenBSD: netbsd.S,v 1.1 1996/05/15 21:06:24 is Exp $
# $NetBSD: netbsd.S,v 1.1 1996/05/15 21:06:24 is Exp $
d97 1
a97 1
	btst	#0x5,a6@@(0x4)		|# check for supervisor state
d100 1
a100 1
	moveb	a0@@+,a1@@+		|# copy 1 byte
d102 1
a102 1
	bnes	super_write		|# quit if ctr = 0
d109 1
a109 1
	bsrl	_copyout		|# write byte to user mem
d131 1
a131 1
	btst	#0x5,a6@@(0x4)		|# check for supervisor state
d134 1
a134 1
	moveb	a0@@+,a1@@+		|# copy 1 byte
d136 1
a136 1
	bnes	super_read		|# quit if ctr = 0
d162 1
a162 1
	btst	#0x5,a6@@(0x4)		|# check for supervisor state
d166 2
a167 2
	movel	#0x1,sp@@-		|# pass: # bytes to copy
	pea	sp@@(0x7)		|# pass: dst addr (stack)
d199 1
a199 1
	btst	#0x5,a6@@(0x4)		|# check for supervisor state
d203 2
a204 2
	movel	#0x2,sp@@-		|# pass: # bytes to copy
	pea	sp@@(0x6)		|# pass: dst addr (stack)
d239 1
a239 1
	btst	#0x5,a6@@(0x4)		|# check for supervisor state
d243 2
a244 2
	movel	#0x4,sp@@-		|# pass: # bytes to copy
	pea	sp@@(0x4)		|# pass: dst addr (stack)
d270 1
a270 1
	btst	#0x5,a6@@(0x4)		|# check for supervisor state
d274 1
a274 1
	movel	#0x1,sp@@-		|# pass: # bytes to copy
d276 2
a277 2
	pea	sp@@(0xb)		|# pass: src addr (stack)
	bsrl	_copyout		|# "copy out" the data
d279 1
a279 1
	addl	#0x10,sp		|# delete params + src
d300 1
a300 1
	btst	#0x5,a6@@(0x4)		|# check for supervisor state
d304 1
a304 1
	movel	#0x2,sp@@-		|# pass: # bytes to copy
d306 2
a307 2
	pea	sp@@(0xa)		|# pass: src addr (stack)
	bsrl	_copyout		|# "copy out" the data
d309 1
a309 1
	addl	#0x10,sp		|# delete params + src
d330 1
a330 1
	btst	#0x5,a6@@(0x4)		|# check for supervisor state
d334 1
a334 1
	movel	#0x4,sp@@-		|# pass: # bytes to copy
d336 2
a337 2
	pea	sp@@(0x8)		|# pass: src addr (stack)
	bsrl	_copyout		|# "copy out" the data
d339 1
a339 1
	addl	#0x10,sp		|# delete params + src
d357 1
a357 1
	.global	_060_real_trace
d359 1
a359 1
	rte
d369 2
a370 3
# The sample routine below simply executes an "rte" instruction which
# is most likely the incorrect thing to do and could put the system
# into an infinite loop.
d372 1
a372 1
	.global	_060_real_access
d374 1
a374 2
	.globl	_buserr
	jmp	_buserr
@


1.1
log
@checkin of files sup have missed earlier, this dir is now at 0529
@
text
@d2 1
@
