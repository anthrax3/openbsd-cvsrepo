head	1.10;
access;
symbols
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	UBC_SYNC_A:1.10
	UBC_SYNC_B:1.10
	SMP:1.10.0.2
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	new:1.7.0.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	97.11.05.02.47.04;	author mickey;	state dead;
branches;
next	1.9;

1.9
date	96.11.22.11.11.30;	author graichen;	state Exp;
branches;
next	1.8;

1.8
date	96.09.28.08.30.45;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.06.16.10.26.15;	author deraadt;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	96.06.01.13.05.01;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.13.09.13.04;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.01.06.20.04.21;	author dm;	state Exp;
branches;
next	1.3;

1.3
date	95.12.26.20.27.53;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.22.07.17.10;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.30;	author deraadt;	state Exp;
branches;
next	;

1.7.2.1
date	96.09.26.12.11.35;	author mickey;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	96.09.26.12.15.47;	author mickey;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	96.10.28.12.14.26;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.10
log
@who needs that junk (;
@
text
@/*	$NetBSD: boot.c,v 1.29 1995/12/23 17:21:27 perry Exp $	*/

/*
 * Ported to boot 386BSD by Julian Elischer (julian@@tfs.com) Sept 1992
 *
 * Mach Operating System
 * Copyright (c) 1992, 1991 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

/*
  Copyright 1988, 1989, 1990, 1991, 1992 
   by Intel Corporation, Santa Clara, California.

                All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appears in all
copies and that both the copyright notice and this permission notice
appear in supporting documentation, and that the name of Intel
not be used in advertising or publicity pertaining to distribution
of the software without specific, written prior permission.

INTEL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
IN NO EVENT SHALL INTEL BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

#include <sys/param.h>
#include <sys/exec.h>
#include "boot.h"
#include <sys/reboot.h>

struct exec head;
int argv[9];
#ifdef CHECKSUM
int cflag;
#endif
char *name;
char *names[] = {
	"/bsd", "/obsd", "/bsd.old",
};
#define NUMNAMES	(sizeof(names)/sizeof(char *))

/* Number of seconds that prompt should wait during boot */
#define PROMPTWAIT 5

static void getbootdev __P((int *howto));
static void loadprog __P((int howto));

extern char version[];
extern int end;

void
boot(drive)
	int drive;
{
	int loadflags, currname = 0;
	char *t;

#ifdef SERIAL
	init_serial();
#endif
	printf("\n"
	       ">> OpenBSD BOOT: %d/%d k [%s]\n"
	       "use ? for file list, or carriage return for defaults\n"
	       "use hd(1,a)/bsd to boot sd0 when wd0 is also installed\n",
		argv[7] = memsize(0),
		argv[8] = memsize(1),
		version);
	gateA20(1);
loadstart:
	/***************************************************************\
	* As a default set it to the first partition of the first	*
	* floppy or hard drive						*
	\***************************************************************/
#ifdef DOSREAD
	if (drive== 0xff) {
          maj = 5;
          part = 0;
          unit = 0;
	} else
#endif
        {
          part = 0;
          unit = drive&0x7f;
          maj = (drive&0x80 ? 0 : 2);         /* a good first bet */
        }

	name = names[currname++];

	loadflags = 0;
	getbootdev(&loadflags);
	switch(openrd()) {
	case 0:
		loadprog(loadflags);
		break;
	case -1:
		currname--;
		break;
	default:
		printf("Can't find %s\n", name);
		break;
	}
	if (currname == NUMNAMES)
		currname = 0;
	goto loadstart;
}

static void
loadprog(howto)
	int howto;
{
	long int startaddr;
	long int addr;	/* physical address.. not directly useable */
	int i;
	static int (*x_entry)() = 0;

	read(&head, sizeof(head));
	if (N_BADMAG(head)) {
		printf("invalid format\n");
		return;
	}

	startaddr = (int)head.a_entry;
	addr = (startaddr & 0x00f00000); /* some MEG boundary */
	printf("Booting %s(%d,%c)%s @@ 0x%x\n",
	    devs[maj], unit, 'a'+part, name, addr);

	/*
	 * The +40960 is for memory used by locore.s for the kernel page
	 * table and proc0 stack.  XXX
	 */
	if ((addr + N_BSSADDR(head) + head.a_bss + 40960) >
	    ((memsize(1) + 1024) * 1024)) {
		printf("kernel too large\n");
		return;
	}

	/********************************************************/
	/* LOAD THE TEXT SEGMENT				*/
	/********************************************************/
	printf("%d", head.a_text);
      pcpy(&head, addr, sizeof(head));
      xread(addr+sizeof(head), head.a_text - sizeof(head));
#ifdef CHECKSUM
	if (cflag)
		printf("(%x)", cksum(addr, head.a_text));
#endif
	addr += head.a_text;

	/********************************************************/
	/* Load the Initialised data after the text		*/
	/********************************************************/
	if (N_GETMAGIC(head) == NMAGIC) {
		i = CLBYTES - (addr & CLOFSET);
		if (i < CLBYTES) {
			pbzero(addr, i);
			addr += i;
		}
	}

	printf("+%d", head.a_data);
	xread(addr, head.a_data);
#ifdef CHECKSUM
	if (cflag)
		printf("(%x)", cksum(addr, head.a_data));
#endif
	addr += head.a_data;

	/********************************************************/
	/* Skip over the uninitialised data			*/
	/* (but clear it)					*/
	/********************************************************/
	printf("+%d", head.a_bss);
	pbzero(addr, head.a_bss);

	argv[3] = (addr += head.a_bss);

	/********************************************************/
	/* copy in the symbol header				*/
	/********************************************************/
	pcpy(&head.a_syms, addr, sizeof(head.a_syms));
	addr += sizeof(head.a_syms);

	if (head.a_syms == 0)
		goto nosyms;
	
	/********************************************************/
	/* READ in the symbol table				*/
	/********************************************************/
	printf("+[%d", head.a_syms);
	xread(addr, head.a_syms);
#ifdef CHECKSUM
	if (cflag)
		printf("(%x)", cksum(addr, head.a_syms));
#endif
	addr += head.a_syms;
	
	/********************************************************/
	/* Followed by the next integer (another header)	*/
	/* more debug symbols?					*/
	/********************************************************/
	read(&i, sizeof(int));
	pcpy(&i, addr, sizeof(int));
	if (i) {
		i -= sizeof(int);
		addr += sizeof(int);
		printf("+%d", i);
		xread(addr, i);
#ifdef CHECKSUM
		if (cflag)
			printf("(%x)", cksum(addr, i));
#endif
		addr += i;
	}

	putchar(']');
#ifdef DOSREAD
      doclose();
#endif

	/********************************************************/
	/* and that many bytes of (debug symbols?)		*/
	/********************************************************/
nosyms:
	argv[4] = ((addr+sizeof(int)-1))&~(sizeof(int)-1);

	/********************************************************/
	/* and note the end address of all this			*/
	/********************************************************/
	printf("=0x%x\n", addr);

#ifdef CHECKSUM
	if (cflag)
		return;
#endif

	/*
	 *  We now pass the various bootstrap parameters to the loaded
	 *  image via the argument list
	 *
         *  arg0 = 8 (magic)
	 *  arg1 = boot flags
	 *  arg2 = boot device
	 *  arg3 = start of symbol table (0 if not loaded)
	 *  arg4 = end of symbol table (0 if not loaded)
	 *  arg5 = transfer address from image
	 *  arg6 = transfer address for next image pointer
         *  arg7 = conventional memory size (640)
         *  arg8 = extended memory size (8196)
	 */

	startaddr &= 0xffffff;
	argv[1] = howto;
	argv[2] = (MAKEBOOTDEV(maj, 0, 0, unit, part));
	argv[5] = startaddr;
	argv[6] = (int) &x_entry;
	argv[0] = 8;

	/****************************************************************/
	/* copy that first page and overwrite any BIOS variables	*/
	/****************************************************************/
	printf("entry point at 0x%x\n", (int)startaddr);
	startprog((int)startaddr, argv);
}

static void
getbootdev(howto)
	int *howto;
{
	static char namebuf[100]; /* don't allocate on stack! */
	char c, *ptr = namebuf;
	printf("Boot: [[[%s(%d,%c)]%s][-abcdrs]] : ",
	    devs[maj], unit, 'a'+part, name);
#ifdef CHECKSUM
	cflag = 0;
#endif
	if (awaitkey(PROMPTWAIT) && gets(namebuf)) {
		while (c = *ptr) {
			while (c == ' ')
				c = *++ptr;
			if (!c)
				return;
			if (c == '-')
				while ((c = *++ptr) && c != ' ') {
					if (c == 'a')
						*howto |= RB_ASKNAME;
					else if (c == 'b')
						*howto |= RB_HALT;
					else if (c == 'c')
						*howto |= RB_CONFIG;
#ifdef CHECKSUM
					else if (c == 'C')
						cflag = 1;
#endif
					else if (c == 'd')
						*howto |= RB_KDB;
					else if (c == 'r')
						*howto |= RB_DFLTROOT;
					else if (c == 's')
						*howto |= RB_SINGLE;
				}
			else {
				name = ptr;
				while ((c = *++ptr) && c != ' ');
				if (c)
					*ptr++ = 0;
			}
		}
	} else
		putchar('\n');
}
@


1.9
log
@fix booting with serial console - i replaced the bios code from OpenBSD with
FreeBSD's polling code so that it works with all serial terminals - if you now
remove the comment in front of #CPPFLAGS+=-DSERIAL -D... - the bootprompt
should appear on the serial console

note: i had to rename "geometry" in one printf of sys.c to "geom." to get the
      bootblocks small enough for serial console booting
@
text
@@


1.8
log
@Allow booting from 2.88mb floppies (in 1.44mb mode), and remove the
floppy "wait for filesystem" goop.
@
text
@d85 4
a88 1
		
@


1.7
log
@-c == RB_CONFIG; -C == checksum (disabled)
@
text
@a274 4
	if (maj == 2) {
		printf("\n\nInsert file system floppy\n");
		getc();
	}
@


1.7.2.1
log
@working now. only start.S requires as.new.
tested w/ floppy, expected to work w/ hd too....
/boot is coming soon.
DEBUG enabled!!!
@
text
@d66 1
a66 1
	"/boot", "/oboot", "/boot.old",
d70 4
d86 7
a92 2

	/*
a93 2
	*/
	*((short *)0xb7002) = 0x44bb;
d115 1
d136 2
a137 2
	u_long startaddr;
	u_long addr;	/* physical address.. not directly useable */
a140 2
	printf("loading %s...\n", name);

d147 2
a148 2
	addr = startaddr = (int)head.a_entry;
#ifdef	DEBUG
a150 1
#endif
a164 1
#ifdef	DEBUG
d166 2
a167 2
#endif
	xread(addr, head.a_text);
a184 1
#ifdef	DEBUG
a185 1
#endif
a196 1
#ifdef	DEBUG
a197 1
#endif
a213 1
#ifdef	DEBUG
a214 1
#endif
a230 1
#ifdef	DEBUG
a231 1
#endif
a239 1
#ifdef	DEBUG
a240 1
#endif
d242 1
a242 1
	doclose();
a253 1
#ifdef	DEBUG
a254 1
#endif
d275 6
a280 2
	/* startaddr &= 0xffffff; */
	argv[0] = 8;
d285 1
a285 2
	argv[7] = memsize(0);
	argv[8] = memsize(1);
a289 1
#ifdef	DEBUG
d291 31
d323 16
a338 1
	startprog((int)startaddr, argv);
@


1.7.2.2
log
@some cleanup.
forgot to mention: as.new is brain damaged on jmp/call (not ljmp/lcall)
to functions in other files.
@
text
@d82 2
d85 2
@


1.7.2.3
log
@new boots w/ libsa using.
new libsa required too, no commit yet.
this one is to mark the step. but it works for me (:
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 28
 * Copyright (c) 1996 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d6 23
d31 22
a52 2
#include <libsa.h>
#include <biosdev.h>
d54 11
d66 1
a66 1
	"/boot", "/oboot", "/boot.old"
d68 6
d79 2
a80 1
	register int currname = 0;
d83 17
d101 1
a101 16
	do {
		/*
		 * As a default set it to the first partition of the first
		 * floppy or hard drive	
		 */
		part = 0;
		unit = drive&0x7f;
		maj = (drive&0x80 ? 0 : 2);         /* a good first bet */

		if (currname == NENTS(names))
			currname = 0;

		printf("loading %s: ", names[currname]);
		exec (names[currname], (caddr_t)0x10000, boothowto);
		printf("\n");
		currname++;
d103 15
a117 1
	} while (1);
d120 3
a122 3
#ifdef	EXEC_DEBUG
int
getchar()
d124 171
a294 2
	asm("hlt");
	return 0;
a295 1
#endif
@


1.6
log
@prompt with : instead of :-
@
text
@d300 1
a300 1
	printf("Boot: [[[%s(%d,%c)]%s][-adrs]] : ",
d317 2
d320 1
a320 1
					else if (c == 'c')
@


1.5
log
@From NetBSD PR#1133:
add '?' to list available files at boot.
@
text
@d300 1
a300 1
	printf("Boot: [[[%s(%d,%c)]%s][-adrs]] :- ",
@


1.4
log
@/bsd and OpenBSD got changed back to /netbsd and NetBSD in the
timing patch.  I switched them back.
@
text
@d76 1
a76 1
extern char *version;
d88 1
d99 12
a110 3
	part = 0;
	unit = drive&0x7f;
	maj = (drive&0x80 ? 0 : 2);		/* a good first bet */
a114 2
	if (currname == NUMNAMES)
		currname = 0;
d116 8
a123 1
	if (openrd()) {
d125 1
a125 1
		goto loadstart;
d127 2
a128 1
	loadprog(loadflags);
a146 2
	poff = N_TXTOFF(head);

d166 2
a167 1
	xread(addr, head.a_text);
d241 3
@


1.3
log
@from perry:
fix my own pr 1762, in which it was noted that boot2 used a busy loop
to time out the boot prompt.  Now uses a usleep() routine that calls
the BIOS and the functionality is separate from gets(). Timeout is
#defined to 5 seconds. Also did some minor cleanup in preparation to
prototype/ANSIfy everything.
(problem was originally reported by deraadt a number of years ago)
@
text
@d66 1
a66 1
	"/netbsd", "/onetbsd", "/netbsd.old",
d87 2
a88 2
	       ">> NetBSD BOOT: %d/%d k [%s]\n"
	       "use hd(1,a)/netbsd to boot sd0 when wd0 is also installed\n",
@


1.2
log
@kernel name is /bsd
@
text
@d1 1
a1 1
/*	$NetBSD: boot.c,v 1.28 1995/03/12 00:10:57 mycroft Exp $	*/
d66 1
a66 1
	"/bsd", "/obsd", "/bsd.old",
d70 6
d77 1
d79 1
a79 1
extern int end;
d81 1
a81 1
int drive;
d87 2
a88 2
	       ">> OpenBSD BOOT: %d/%d k [%s]\n"
	       "use hd(1,a)/bsd to boot sd0 when wd0 is also installed\n",
d116 1
d118 1
a118 1
	int		howto;
d276 1
a276 1
char namebuf[100];
d280 1
d287 1
a287 1
	if (gets(namebuf)) {
@


1.1
log
@Initial revision
@
text
@d66 1
a66 1
	"/netbsd", "/onetbsd", "/netbsd.old",
d80 2
a81 2
	       ">> NetBSD BOOT: %d/%d k [%s]\n"
	       "use hd(1,a)/netbsd to boot sd0 when wd0 is also installed\n",
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
