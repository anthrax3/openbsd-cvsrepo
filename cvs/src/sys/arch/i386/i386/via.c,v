head	1.36;
access;
symbols
	OPENBSD_6_1:1.36.0.4
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.35.0.4
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.34.0.6
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.30.0.6
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.29.0.6
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.4
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.2
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.8
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.4
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.36
date	2017.02.07.17.25.45;	author patrick;	state Exp;
branches;
next	1.35;
commitid	dMJlqKWYCJoMV7JN;

1.35
date	2015.09.08.07.12.56;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	UsnEcDGT4QqqoPvB;

1.34
date	2014.12.09.06.58.28;	author doug;	state Exp;
branches;
next	1.33;
commitid	yWAxzpQP2PPpYlfT;

1.33
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.32;
commitid	uzzBR7hz9ncd4O6G;

1.32
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.31;
commitid	uKVPYMN2MLxdZxzH;

1.31
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2013.05.30.15.37.51;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	2012.01.13.09.53.24;	author mikeb;	state Exp;
branches;
next	1.28;

1.28
date	2011.04.20.06.51.35;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2011.01.12.17.15.20;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2011.01.11.15.42.04;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2010.12.15.23.34.23;	author mikeb;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.06.09.49.47;	author blambert;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2010.07.02.02.40.15;	author blambert;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.08.07.36.36;	author thib;	state Exp;
branches;
next	1.20;

1.20
date	2010.01.10.12.43.07;	author markus;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2008.06.09.07.07.15;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2007.12.09.21.30.24;	author hshoexer;	state Exp;
branches;
next	1.17;

1.17
date	2007.11.28.17.05.09;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.14.19.10.44;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.18.22.02.18;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.11.01.12.44;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.07.15.00.19;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2007.08.14.20.10.05;	author henric;	state Exp;
branches;
next	1.11;

1.11
date	2007.08.07.09.45.24;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.27.07.17.47;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.10.17.47.54;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.17.07.47.56;	author tom;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.17.06.48.12;	author tom;	state Exp;
branches;
next	1.6;

1.6
date	2006.08.24.12.29.54;	author hshoexer;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.27.04.08.57;	author gwk;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.11.13.21.12;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.15.23.36.55;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.15.19.19.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.11.18.12.10;	author deraadt;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.09.00;	author niklas;	state Exp;
branches;
next	;

1.20.2.1
date	2010.12.20.14.08.39;	author jasper;	state Exp;
branches;
next	;

1.24.2.1
date	2010.12.17.16.25.14;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Reduce the per-packet allocation costs for crypto operations (cryptop)
by pre-allocating two cryptodesc objects and storing them in an array
instead of a linked list.  If more than two cryptodesc objects are
required use mallocarray to fetch them.  Adapt the drivers to the new
API.

This change results in one pool-get per ESP packet instead of three.
It also simplifies softraid crypto where more cryptodesc objects are
allocated than used.

From, with and ok markus@@, ok bluhm@@
"looks sane" mpi@@
@
text
@/*	$OpenBSD: via.c,v 1.35 2015/09/08 07:12:56 deraadt Exp $	*/
/*	$NetBSD: machdep.c,v 1.214 1996/11/10 03:16:17 thorpej Exp $	*/

/*-
 * Copyright (c) 2003 Jason Wright
 * Copyright (c) 2003, 2004 Theo de Raadt
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/exec.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/extent.h>
#include <sys/sysctl.h>

#ifdef CRYPTO
#include <crypto/cryptodev.h>
#include <crypto/rijndael.h>
#include <crypto/xform.h>
#include <crypto/cryptosoft.h>
#endif

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/gdt.h>
#include <machine/pio.h>
#include <machine/bus.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/specialreg.h>
#include <machine/biosvar.h>

#include <dev/rndvar.h>

void	viac3_rnd(void *);


#ifdef CRYPTO

struct viac3_session {
	u_int32_t	ses_ekey[4 * (AES_MAXROUNDS + 1) + 4];	/* 128 bit aligned */
	u_int32_t	ses_dkey[4 * (AES_MAXROUNDS + 1) + 4];	/* 128 bit aligned */
	u_int32_t	ses_cw0;
	struct swcr_data *swd;
	int		ses_klen;
	int		ses_used;
};

struct viac3_softc {
	u_int32_t		op_cw[4];		/* 128 bit aligned */
	u_int8_t		op_iv[16];		/* 128 bit aligned */
	void			*op_buf;

	/* normal softc stuff */
	int32_t			sc_cid;
	int			sc_nsessions;
	struct viac3_session	*sc_sessions;
};

#define VIAC3_SESSION(sid)		((sid) & 0x0fffffff)
#define	VIAC3_SID(crd,ses)		(((crd) << 28) | ((ses) & 0x0fffffff))

static struct viac3_softc *vc3_sc;
extern int i386_has_xcrypt;

extern const u_int8_t hmac_ipad_buffer[HMAC_MAX_BLOCK_LEN];
extern const u_int8_t hmac_opad_buffer[HMAC_MAX_BLOCK_LEN];

void viac3_crypto_setup(void);
int viac3_crypto_newsession(u_int32_t *, struct cryptoini *);
int viac3_crypto_process(struct cryptop *);
int viac3_crypto_swauth(struct cryptop *, struct cryptodesc *,
    struct swcr_data *, caddr_t);
int viac3_crypto_encdec(struct cryptop *, struct cryptodesc *,
    struct viac3_session *, struct viac3_softc *, caddr_t);
int viac3_crypto_freesession(u_int64_t);
static __inline void viac3_cbc(void *, void *, void *, void *, int, void *);

void
viac3_crypto_setup(void)
{
	int algs[CRYPTO_ALGORITHM_MAX + 1];

	vc3_sc = malloc(sizeof(*vc3_sc), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (vc3_sc == NULL)
		return;	/* YYY bitch? */

	bzero(algs, sizeof(algs));
	algs[CRYPTO_AES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_MD5_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA1_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_RIPEMD160_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA2_256_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA2_384_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA2_512_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;

	vc3_sc->sc_cid = crypto_get_driverid(0);
	if (vc3_sc->sc_cid < 0) {
		free(vc3_sc, M_DEVBUF, sizeof(*vc3_sc));
		return;		/* YYY bitch? */
	}

	crypto_register(vc3_sc->sc_cid, algs, viac3_crypto_newsession,
	    viac3_crypto_freesession, viac3_crypto_process);
}

int
viac3_crypto_newsession(u_int32_t *sidp, struct cryptoini *cri)
{
	struct cryptoini	*c;
	struct viac3_softc	*sc = vc3_sc;
	struct viac3_session	*ses = NULL;
	struct auth_hash	*axf;
	struct swcr_data	*swd;
	int			 sesn, i, cw0;

	if (sc == NULL || sidp == NULL || cri == NULL)
		return (EINVAL);

	if (sc->sc_sessions == NULL) {
		ses = sc->sc_sessions = malloc(sizeof(*ses), M_DEVBUF,
		    M_NOWAIT);
		if (ses == NULL)
			return (ENOMEM);
		sesn = 0;
		sc->sc_nsessions = 1;
	} else {
		for (sesn = 0; sesn < sc->sc_nsessions; sesn++) {
			if (sc->sc_sessions[sesn].ses_used == 0) {
				ses = &sc->sc_sessions[sesn];
				break;
			}
		}

		if (ses == NULL) {
			sesn = sc->sc_nsessions;
			ses = mallocarray(sesn + 1, sizeof(*ses), M_DEVBUF,
			    M_NOWAIT);
			if (ses == NULL)
				return (ENOMEM);
			bcopy(sc->sc_sessions, ses, sesn * sizeof(*ses));
			explicit_bzero(sc->sc_sessions, sesn * sizeof(*ses));
			free(sc->sc_sessions, M_DEVBUF, sesn * sizeof(*ses));
			sc->sc_sessions = ses;
			ses = &sc->sc_sessions[sesn];
			sc->sc_nsessions++;
		}
	}

	bzero(ses, sizeof(*ses));
	ses->ses_used = 1;

	for (c = cri; c != NULL; c = c->cri_next) {
		switch (c->cri_alg) {
		case CRYPTO_AES_CBC:
			switch (c->cri_klen) {
			case 128:
				cw0 = C3_CRYPT_CWLO_KEY128;
				break;
			case 192:
				cw0 = C3_CRYPT_CWLO_KEY192;
				break;
			case 256:
				cw0 = C3_CRYPT_CWLO_KEY256;
				break;
			default:
				viac3_crypto_freesession(sesn);
				return (EINVAL);
			}
			cw0 |= C3_CRYPT_CWLO_ALG_AES | C3_CRYPT_CWLO_KEYGEN_SW |
			    C3_CRYPT_CWLO_NORMAL;

			ses->ses_klen = c->cri_klen;
			ses->ses_cw0 = cw0;

			/* Build expanded keys for both directions */
			rijndaelKeySetupEnc(ses->ses_ekey, c->cri_key,
			    c->cri_klen);
			rijndaelKeySetupDec(ses->ses_dkey, c->cri_key,
			    c->cri_klen);
			for (i = 0; i < 4 * (AES_MAXROUNDS + 1); i++) {
				ses->ses_ekey[i] = ntohl(ses->ses_ekey[i]);
				ses->ses_dkey[i] = ntohl(ses->ses_dkey[i]);
			}

			break;

		case CRYPTO_MD5_HMAC:
			axf = &auth_hash_hmac_md5_96;
			goto authcommon;
		case CRYPTO_SHA1_HMAC:
			axf = &auth_hash_hmac_sha1_96;
			goto authcommon;
		case CRYPTO_RIPEMD160_HMAC:
			axf = &auth_hash_hmac_ripemd_160_96;
			goto authcommon;
		case CRYPTO_SHA2_256_HMAC:
			axf = &auth_hash_hmac_sha2_256_128;
			goto authcommon;
		case CRYPTO_SHA2_384_HMAC:
			axf = &auth_hash_hmac_sha2_384_192;
			goto authcommon;
		case CRYPTO_SHA2_512_HMAC:
			axf = &auth_hash_hmac_sha2_512_256;
		authcommon:
			swd = malloc(sizeof(struct swcr_data), M_CRYPTO_DATA,
			    M_NOWAIT|M_ZERO);
			if (swd == NULL) {
				viac3_crypto_freesession(sesn);
				return (ENOMEM);
			}
			ses->swd = swd;

			swd->sw_ictx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if (swd->sw_ictx == NULL) {
				viac3_crypto_freesession(sesn);
				return (ENOMEM);
			}

			swd->sw_octx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if (swd->sw_octx == NULL) {
				viac3_crypto_freesession(sesn);
				return (ENOMEM);
			}

			for (i = 0; i < c->cri_klen / 8; i++)
				c->cri_key[i] ^= HMAC_IPAD_VAL;

			axf->Init(swd->sw_ictx);
			axf->Update(swd->sw_ictx, c->cri_key, c->cri_klen / 8);
			axf->Update(swd->sw_ictx, hmac_ipad_buffer,
			    axf->blocksize - (c->cri_klen / 8));

			for (i = 0; i < c->cri_klen / 8; i++)
				c->cri_key[i] ^= (HMAC_IPAD_VAL ^
				    HMAC_OPAD_VAL);

			axf->Init(swd->sw_octx);
			axf->Update(swd->sw_octx, c->cri_key, c->cri_klen / 8);
			axf->Update(swd->sw_octx, hmac_opad_buffer,
			    axf->blocksize - (c->cri_klen / 8));

			for (i = 0; i < c->cri_klen / 8; i++)
				c->cri_key[i] ^= HMAC_OPAD_VAL;

			swd->sw_axf = axf;
			swd->sw_alg = c->cri_alg;

			break;
		default:
			viac3_crypto_freesession(sesn);
			return (EINVAL);
		}
	}

	*sidp = VIAC3_SID(0, sesn);
	return (0);
}

int
viac3_crypto_freesession(u_int64_t tid)
{
	struct viac3_softc *sc = vc3_sc;
	struct swcr_data *swd;
	struct auth_hash *axf;
	int sesn;
	u_int32_t sid = ((u_int32_t)tid) & 0xffffffff;

	if (sc == NULL)
		return (EINVAL);
	sesn = VIAC3_SESSION(sid);
	if (sesn >= sc->sc_nsessions)
		return (EINVAL);

	if (sc->sc_sessions[sesn].swd) {
		swd = sc->sc_sessions[sesn].swd;
		axf = swd->sw_axf;

		if (swd->sw_ictx) {
			explicit_bzero(swd->sw_ictx, axf->ctxsize);
			free(swd->sw_ictx, M_CRYPTO_DATA, axf->ctxsize);
		}
		if (swd->sw_octx) {
			explicit_bzero(swd->sw_octx, axf->ctxsize);
			free(swd->sw_octx, M_CRYPTO_DATA, axf->ctxsize);
		}
		free(swd, M_CRYPTO_DATA, sizeof(*swd));
	}

	explicit_bzero(&sc->sc_sessions[sesn], sizeof(sc->sc_sessions[sesn]));
	return (0);
}

static __inline void
viac3_cbc(void *cw, void *src, void *dst, void *key, int rep,
    void *iv)
{
	unsigned int creg0;

	creg0 = rcr0();		/* Permit access to SIMD/FPU path */
	lcr0(creg0 & ~(CR0_EM|CR0_TS));

	/* Do the deed */
	__asm volatile("pushfl; popfl");
	__asm volatile("rep xcryptcbc" :
	    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
	    : "memory", "cc");

	lcr0(creg0);
}

int
viac3_crypto_swauth(struct cryptop *crp, struct cryptodesc *crd,
    struct swcr_data *sw, caddr_t buf)
{
	int	type;

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		type = CRYPTO_BUF_MBUF;
	else
		type= CRYPTO_BUF_IOV;
		
	return (swcr_authcompute(crp, crd, sw, buf, type));
}

int
viac3_crypto_encdec(struct cryptop *crp, struct cryptodesc *crd,
    struct viac3_session *ses, struct viac3_softc *sc, caddr_t buf)
{
	u_int32_t *key;
	int	err = 0;

	if ((crd->crd_len % 16) != 0) {
		err = EINVAL;
		return (err);
	}

	sc->op_buf = malloc(crd->crd_len, M_DEVBUF, M_NOWAIT);
	if (sc->op_buf == NULL) {
		err = ENOMEM;
		return (err);
	}

	if (crd->crd_flags & CRD_F_ENCRYPT) {
		sc->op_cw[0] = ses->ses_cw0 | C3_CRYPT_CWLO_ENCRYPT;
		key = ses->ses_ekey;
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crd->crd_iv, sc->op_iv, 16);
		else
			arc4random_buf(sc->op_iv, 16);

		if ((crd->crd_flags & CRD_F_IV_PRESENT) == 0) {
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				err = m_copyback((struct mbuf *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv, M_NOWAIT);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copyback((struct uio *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else
				bcopy(sc->op_iv,
				    crp->crp_buf + crd->crd_inject, 16);
			if (err)
				return (err);
		}
	} else {
		sc->op_cw[0] = ses->ses_cw0 | C3_CRYPT_CWLO_DECRYPT;
		key = ses->ses_dkey;
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crd->crd_iv, sc->op_iv, 16);
		else {
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata((struct mbuf *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copydata((struct uio *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else
				bcopy(crp->crp_buf + crd->crd_inject,
				    sc->op_iv, 16);
		}
	}

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		m_copydata((struct mbuf *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else if (crp->crp_flags & CRYPTO_F_IOV)
		cuio_copydata((struct uio *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else
		bcopy(crp->crp_buf + crd->crd_skip, sc->op_buf, crd->crd_len);

	sc->op_cw[1] = sc->op_cw[2] = sc->op_cw[3] = 0;
	viac3_cbc(&sc->op_cw, sc->op_buf, sc->op_buf, key,
	    crd->crd_len / 16, sc->op_iv);

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		m_copyback((struct mbuf *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf, M_NOWAIT);
	else if (crp->crp_flags & CRYPTO_F_IOV)
		cuio_copyback((struct uio *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else
		bcopy(sc->op_buf, crp->crp_buf + crd->crd_skip,
		    crd->crd_len);

	if (sc->op_buf != NULL) {
		explicit_bzero(sc->op_buf, crd->crd_len);
		free(sc->op_buf, M_DEVBUF, crd->crd_len);
		sc->op_buf = NULL;
	}

	return (err);
}

int
viac3_crypto_process(struct cryptop *crp)
{
	struct viac3_softc *sc = vc3_sc;
	struct viac3_session *ses;
	struct cryptodesc *crd;
	int sesn, err = 0;
	int i;

	if (crp == NULL || crp->crp_callback == NULL)
		return (EINVAL);
	if (crp->crp_ndesc < 1)
		return (EINVAL);

	sesn = VIAC3_SESSION(crp->crp_sid);
	if (sesn >= sc->sc_nsessions) {
		err = EINVAL;
		goto out;
	}
	ses = &sc->sc_sessions[sesn];
	if (ses->ses_used == 0) {
		err = EINVAL;
		goto out;
	}

	for (i = 0; i < crp->crp_ndesc; i++) {
		crd = &crp->crp_desc[i];
		switch (crd->crd_alg) {
		case CRYPTO_AES_CBC:
			if ((err = viac3_crypto_encdec(crp, crd, ses, sc,
			    crp->crp_buf)) != 0)
				goto out;
			break;

		case CRYPTO_MD5_HMAC:
		case CRYPTO_SHA1_HMAC:
		case CRYPTO_RIPEMD160_HMAC:
		case CRYPTO_SHA2_256_HMAC:
		case CRYPTO_SHA2_384_HMAC:
		case CRYPTO_SHA2_512_HMAC:
			if ((err = viac3_crypto_swauth(crp, crd, ses->swd,
			    crp->crp_buf)) != 0)
				goto out;
			break;

		default:
			err = EINVAL;
			goto out;
		}
	}
out:
	crp->crp_etype = err;
	crypto_done(crp);
	return (err);
}

#endif /* CRYPTO */

/*
 * Note, the VIA C3 Nehemiah provides 4 internal 8-byte buffers, which
 * store random data, and can be accessed a lot quicker than waiting
 * for new data to be generated.  As we are using every 8th bit only
 * due to whitening. Since the RNG generates in excess of 21KB/s at
 * its worst, collecting 64 bytes worth of entropy should not affect
 * things significantly.
 *
 * Note, due to some weirdness in the RNG, we need at least 7 bytes
 * extra on the end of our buffer.  Also, there is an outside chance
 * that the VIA RNG can "wedge", as the generated bit-rate is variable.
 * We could do all sorts of startup testing and things, but
 * frankly, I don't really see the point.  If the RNG wedges, then the
 * chances of you having a defective CPU are very high.  Let it wedge.
 *
 * Adding to the whole confusion, in order to access the RNG, we need
 * to have FXSR support enabled, and the correct FPU enable bits must
 * be there to enable the FPU in kernel.  It would be nice if all this
 * mumbo-jumbo was not needed in order to use the RNG.  Oh well, life
 * does go on...
 */
#define VIAC3_RNG_BUFSIZ	16		/* 32bit words */
struct timeout viac3_rnd_tmo;
int viac3_rnd_present;

void
viac3_rnd(void *v)
{
	struct timeout *tmo = v;
	unsigned int *p, i, rv, creg0, len = VIAC3_RNG_BUFSIZ;
	static int buffer[VIAC3_RNG_BUFSIZ + 2];	/* XXX why + 2? */
#ifdef MULTIPROCESSOR
	int s = splipi();
#endif

	creg0 = rcr0();		/* Permit access to SIMD/FPU path */
	lcr0(creg0 & ~(CR0_EM|CR0_TS));

	/*
	 * Here we collect the random data from the VIA C3 RNG.  We make
	 * sure that we turn on maximum whitening (%edx[0,1] == "11"), so
	 * that we get the best random data possible.
	 */
	__asm volatile("rep xstorerng"
	    : "=a" (rv) : "d" (3), "D" (buffer), "c" (len*sizeof(int))
	    : "memory", "cc");

	lcr0(creg0);

#ifdef MULTIPROCESSOR
	splx(s);
#endif

	for (i = 0, p = buffer; i < VIAC3_RNG_BUFSIZ; i++, p++)
		add_true_randomness(*p);

	timeout_add_msec(tmo, 10);
}
@


1.35
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.34 2014/12/09 06:58:28 doug Exp $	*/
d447 1
d451 2
d465 2
a466 1
	for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
@


1.34
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.33 2014/09/14 14:17:23 jsg Exp $	*/
d122 1
a122 1
		free(vc3_sc, M_DEVBUF, 0);
d166 1
a166 1
			free(sc->sc_sessions, M_DEVBUF, 0);
d306 1
a306 1
			free(swd->sw_ictx, M_CRYPTO_DATA, 0);
d310 1
a310 1
			free(swd->sw_octx, M_CRYPTO_DATA, 0);
d312 1
a312 1
		free(swd, M_CRYPTO_DATA, 0);
d433 1
a433 1
		free(sc->op_buf, M_DEVBUF, 0);
@


1.33
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.32 2014/07/12 18:44:41 tedu Exp $	*/
d160 1
a160 1
			ses = malloc((sesn + 1) * sizeof(*ses), M_DEVBUF,
@


1.32
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.31 2014/03/29 18:09:29 guenther Exp $	*/
a25 1
#include <sys/proc.h>
@


1.31
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.30 2013/05/30 15:37:51 matthew Exp $	*/
d123 1
a123 1
		free(vc3_sc, M_DEVBUF);
d167 1
a167 1
			free(sc->sc_sessions, M_DEVBUF);
d307 1
a307 1
			free(swd->sw_ictx, M_CRYPTO_DATA);
d311 1
a311 1
			free(swd->sw_octx, M_CRYPTO_DATA);
d313 1
a313 1
		free(swd, M_CRYPTO_DATA);
d434 1
a434 1
		free(sc->op_buf, M_DEVBUF);
@


1.30
log
@Switch to using unhyphenated VIA padlock mnemonics.  VIA abandoned the
hyphen in their official programming guide sometime between 2003 and
2005, and Clang's integrated assembler does not support hyphenated
mnemonics.

ok jsg, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.29 2012/01/13 09:53:24 mikeb Exp $	*/
d330 2
a331 2
	__asm __volatile("pushfl; popfl");
	__asm __volatile("rep xcryptcbc" :
d538 1
a538 1
	__asm __volatile("rep xstorerng"
@


1.29
log
@handle m_copyback errors, this code is too sensitive for such
failures to be neglected;  ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.28 2011/04/20 06:51:35 deraadt Exp $	*/
d331 1
a331 1
	__asm __volatile("rep xcrypt-cbc" :
d538 1
a538 1
	__asm __volatile("rep xstore-rng"
@


1.28
log
@Potential NULL deref in an error case spotted by chl on one copy;
correct fix applied to 3 similar drivers
ok chl
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.27 2011/01/12 17:15:20 deraadt Exp $	*/
d380 1
a380 1
				m_copyback((struct mbuf *)crp->crp_buf,
d388 2
@


1.27
log
@use explicit_bzero() for the session, in drivers where struct session
contains key material (note, that is not true in all drivers... hence
not always neccessary)
discussed with mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.26 2011/01/11 15:42:04 deraadt Exp $	*/
d447 2
a448 4
	if (crp == NULL || crp->crp_callback == NULL) {
		err = EINVAL;
		goto out;
	}
@


1.26
log
@for key material that is being being discarded, convert bzero() to
explicit_bzero() where required
ok markus mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.25 2010/12/15 23:34:23 mikeb Exp $	*/
d166 1
a166 1
			bzero(sc->sc_sessions, sesn * sizeof(*ses));
d316 1
a316 1
	bzero(&sc->sc_sessions[sesn], sizeof(sc->sc_sessions[sesn]));
@


1.25
log
@Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.

Original commit message by angelos:

Don't keep the last blocksize-bytes of ciphertext for use as the next
plaintext's IV, in CBC mode. Use arc4random() to acquire fresh IVs per
message.

with and ok deraadt, ok markus, djm
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.24 2010/07/06 09:49:47 blambert Exp $	*/
d306 1
a306 1
			bzero(swd->sw_ictx, axf->ctxsize);
d310 1
a310 1
			bzero(swd->sw_octx, axf->ctxsize);
d431 1
a431 1
		bzero(sc->op_buf, crd->crd_len);
@


1.24
log
@timeout_add -> timeout_add_msec

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.23 2010/07/02 02:40:15 blambert Exp $	*/
a66 1
	u_int8_t	ses_iv[16];			/* 128 bit aligned */
a196 1
			arc4random_buf(ses->ses_iv, sizeof(ses->ses_iv));
d376 1
a376 1
			bcopy(ses->ses_iv, sc->op_iv, 16);
a428 15

	/* copy out last block for use as next session IV */
	if (crd->crd_flags & CRD_F_ENCRYPT) {
		if (crp->crp_flags & CRYPTO_F_IMBUF)
			m_copydata((struct mbuf *)crp->crp_buf,
			    crd->crd_skip + crd->crd_len - 16, 16,
			    ses->ses_iv);
		else if (crp->crp_flags & CRYPTO_F_IOV)
			cuio_copydata((struct uio *)crp->crp_buf,
			    crd->crd_skip + crd->crd_len - 16, 16,
			    ses->ses_iv);
		else
			bcopy(crp->crp_buf + crd->crd_skip +
			    crd->crd_len - 16, ses->ses_iv, 16);
	}
@


1.24.2.1
log
@Backport from -current, original commit by mikeb@@:
------
Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.
------

ok deraadt@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.24 2010/07/06 09:49:47 blambert Exp $	*/
d67 1
d198 1
d378 1
a378 1
			arc4random_buf(sc->op_iv, 16);
d431 15
@


1.23
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.22 2010/06/26 23:24:43 guenther Exp $	*/
d568 1
a568 1
	timeout_add(tmo, (hz > 100) ? (hz / 100) : 1);
@


1.22
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.21 2010/06/08 07:36:36 thib Exp $	*/
d383 1
a383 1
				    crd->crd_inject, 16, sc->op_iv);
d424 1
a424 1
		    crd->crd_skip, crd->crd_len, sc->op_buf);
@


1.21
log
@in viac3_crypto_setup(), if we fail to get a crypto driverid,
free the softc before we return. While here, make the allocation
code a bit prettier too.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.20 2010/01/10 12:43:07 markus Exp $	*/
a26 1
#include <sys/user.h>
@


1.20
log
@Fix two bugs in IPsec/HMAC-SHA2:
(1) use correct (message) block size of 128 byte (instead of 64
    bytes) for HMAC-SHA512/384 (RFC4634).
(2) RFC4868 specifies that HMAC-SHA-{256,384,512} is truncated to
    nnn/2 bits, while we still use 96 bits. 96 bits have been
    specified in draft-ietf-ipsec-ciph-sha-256-00 while
    draft-ietf-ipsec-ciph-sha-256-01 changed it to 128 bits.

WARNING: this change makes IPsec with SHA-256 (the default)
incompatible with older OpenBSD versions and other IPsec-implementations
that share this bug.

ok+tests naddy, fries; requested by reyk/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.19 2008/06/09 07:07:15 djm Exp $	*/
d110 3
a112 3
	if ((vc3_sc = malloc(sizeof(*vc3_sc), M_DEVBUF,
	    M_NOWAIT|M_ZERO)) == NULL)
		return;		/* YYY bitch? */
d124 2
a125 1
	if (vc3_sc->sc_cid < 0)
d127 1
@


1.20.2.1
log
@Backport from -current, original commit by mikeb@@:
------
Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.
------
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.20 2010/01/10 12:43:07 markus Exp $	*/
d68 1
d197 1
d377 1
a377 1
			arc4random_buf(sc->op_iv, 16);
d430 15
@


1.19
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.18 2007/12/09 21:30:24 hshoexer Exp $	*/
d92 2
a93 2
extern const u_int8_t hmac_ipad_buffer[64];
extern const u_int8_t hmac_opad_buffer[64];
d223 1
a223 1
			axf = &auth_hash_hmac_sha2_256_96;
d226 1
a226 1
			axf = &auth_hash_hmac_sha2_384_96;
d229 1
a229 1
			axf = &auth_hash_hmac_sha2_512_96;
d259 1
a259 1
			    HMAC_BLOCK_LEN - (c->cri_klen / 8));
d268 1
a268 1
			    HMAC_BLOCK_LEN - (c->cri_klen / 8));
@


1.18
log
@FREE -> free

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.17 2007/11/28 17:05:09 tedu Exp $	*/
d197 1
a197 1
			arc4random_bytes(ses->ses_iv, sizeof(ses->ses_iv));
@


1.17
log
@quite a bit of simplification by removing cpu classes.
also assume that 386 cpus are really unknown, and promote them to 486
instead of panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.16 2007/11/14 19:10:44 markus Exp $	*/
d314 1
a314 1
		FREE(swd, M_CRYPTO_DATA);
@


1.16
log
@do not process requests linked to unused sessions. (crypto_freesession
might happen between enqueuing a crypto request and scheduling of
the crypto thread); ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.15 2007/09/18 22:02:18 djm Exp $	*/
a510 1
#if defined(I686_CPU)
a568 2

#endif /* defined(I686_CPU) */
@


1.15
log
@arc4random_bytes() is the preferred interface for generating nonces;
"looks ok" markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.14 2007/09/11 01:12:44 deraadt Exp $	*/
d474 4
@


1.14
log
@henric, tsk tsk, you missed stuff related to cryptosoft
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.13 2007/09/07 15:00:19 art Exp $	*/
d197 1
a197 1
			get_random_bytes(ses->ses_iv, sizeof(ses->ses_iv));
@


1.13
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.12 2007/08/14 20:10:05 henric Exp $	*/
d92 2
a93 2
extern u_int8_t hmac_ipad_buffer[64];
extern u_int8_t hmac_opad_buffer[64];
@


1.12
log
@Work-around an interaction between FPU context switching and the VIA
Padlock entropy polling on SMP boxes.

ok deraadt@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.11 2007/08/07 09:45:24 markus Exp $	*/
d110 2
a111 1
	if ((vc3_sc = malloc(sizeof(*vc3_sc), M_DEVBUF, M_NOWAIT)) == NULL)
a112 1
	bzero(vc3_sc, sizeof(*vc3_sc));
d231 2
a232 3
			MALLOC(swd, struct swcr_data *,
			    sizeof(struct swcr_data), M_CRYPTO_DATA,
			    M_NOWAIT);
a236 1
			bzero(swd, sizeof(struct swcr_data));
@


1.11
log
@do not leak sessions; ok hshoexer, tom, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.10 2007/05/27 07:17:47 tedu Exp $	*/
d541 3
d558 4
@


1.10
log
@fix another use of MAXNR for rijndael
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.9 2007/04/10 17:47:54 miod Exp $	*/
d191 1
d280 1
@


1.9
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.8 2006/11/17 07:47:56 tom Exp $	*/
d66 2
a67 2
	u_int32_t	ses_ekey[4 * (MAXNR + 1) + 4];	/* 128 bit aligned */
	u_int32_t	ses_dkey[4 * (MAXNR + 1) + 4];	/* 128 bit aligned */
d205 1
a205 1
			for (i = 0; i < 4 * (MAXNR + 1); i++) {
@


1.8
log
@Fix typo to let this compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.7 2006/11/17 06:48:12 tom Exp $	*/
d513 1
a513 1
 * it's worst, collecting 64 bytes worth of entropy should not affect
@


1.7
log
@Make sure we copy the IV back into the session structure, not the
softc.  Fortunately this branch (when neither CRYPTO_F_IMBUF nor
CRYPTO_F_IOV is specified) is not currently used.

ok hshoexer@@ jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.6 2006/08/24 12:29:54 hshoexer Exp $	*/
d443 1
a443 1
			    crd->crd_len - 16, sc->ses->ses_iv, 16);
@


1.6
log
@Add support for HMACs to the via c3/c7 crypto driver.  For now, we
just use the software implemented algorithms.  This is needed to
make this driver useable for ipsec.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.5 2006/05/27 04:08:57 gwk Exp $	*/
d440 1
a440 1
			    sc->op_iv);
d443 1
a443 1
			    crd->crd_len - 16, sc->op_iv, 16);
@


1.5
log
@casting mallloc
ok uwe@@, dlg2
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.4 2006/05/11 13:21:12 mickey Exp $	*/
d42 2
d70 1
a72 1
	int		ses_pad;			/* to multiple of 16 */
d92 3
d98 4
d116 6
d134 6
a139 7
	struct viac3_softc *sc = vc3_sc;
	struct viac3_session *ses = NULL;
	int sesn, i, cw0;

	if (sc == NULL || sidp == NULL || cri == NULL ||
	    cri->cri_next != NULL || cri->cri_alg != CRYPTO_AES_CBC)
		return (EINVAL);
d141 1
a141 11
	switch (cri->cri_klen) {
	case 128:
		cw0 = C3_CRYPT_CWLO_KEY128;
		break;
	case 192:
		cw0 = C3_CRYPT_CWLO_KEY192;
		break;
	case 256:
		cw0 = C3_CRYPT_CWLO_KEY256;
		break;
	default:
a142 3
	}
	cw0 |= C3_CRYPT_CWLO_ALG_AES | C3_CRYPT_CWLO_KEYGEN_SW |
	    C3_CRYPT_CWLO_NORMAL;
d177 104
a280 10
	get_random_bytes(ses->ses_iv, sizeof(ses->ses_iv));
	ses->ses_klen = cri->cri_klen;
	ses->ses_cw0 = cw0;

	/* Build expanded keys for both directions */
	rijndaelKeySetupEnc(ses->ses_ekey, cri->cri_key, cri->cri_klen);
	rijndaelKeySetupDec(ses->ses_dkey, cri->cri_key, cri->cri_klen);
	for (i = 0; i < 4 * (MAXNR + 1); i++) {
		ses->ses_ekey[i] = ntohl(ses->ses_ekey[i]);
		ses->ses_dkey[i] = ntohl(ses->ses_dkey[i]);
d291 2
d301 16
d340 16
a355 1
viac3_crypto_process(struct cryptop *crp)
a356 4
	struct viac3_softc *sc = vc3_sc;
	struct viac3_session *ses;
	struct cryptodesc *crd;
	int sesn, err = 0;
d358 1
d360 1
a360 1
	if (crp == NULL || crp->crp_callback == NULL) {
d362 1
a362 8
		goto out;
	}
	crd = crp->crp_desc;
	if (crd == NULL || crd->crd_next != NULL ||
	    crd->crd_alg != CRYPTO_AES_CBC ||
	    (crd->crd_len % 16) != 0) {
		err = EINVAL;
		goto out;
a364 7
	sesn = VIAC3_SESSION(crp->crp_sid);
	if (sesn >= sc->sc_nsessions) {
		err = EINVAL;
		goto out;
	}
	ses = &sc->sc_sessions[sesn];

d368 1
a368 1
		goto out;
d428 2
a429 1
		bcopy(sc->op_buf, crp->crp_buf + crd->crd_skip, crd->crd_len);
d435 2
a436 1
			    crd->crd_skip + crd->crd_len - 16, 16, ses->ses_iv);
d439 2
a440 1
			    crd->crd_skip + crd->crd_len - 16, 16, sc->op_iv);
d442 2
a443 2
			bcopy(crp->crp_buf + crd->crd_skip + crd->crd_len - 16,
			    sc->op_iv, 16);
a445 1
out:
d451 49
@


1.4
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.3 2004/06/15 23:36:55 deraadt Exp $	*/
d144 2
a145 2
		ses = sc->sc_sessions = (struct viac3_session *)malloc(
		    sizeof(*ses), M_DEVBUF, M_NOWAIT);
d160 2
a161 2
			ses = (struct viac3_session *)malloc((sesn + 1) *
			    sizeof(*ses), M_DEVBUF, M_NOWAIT);
d254 1
a254 1
	sc->op_buf = (char *)malloc(crd->crd_len, M_DEVBUF, M_NOWAIT);
@


1.3
log
@first parts of how C3 Esther will be handled; ok tom
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.2 2004/06/15 19:19:03 deraadt Exp $	*/
d241 1
a241 1
	    crd->crd_alg != CRYPTO_AES_CBC || 
@


1.2
log
@export actual xcrypt feature set bitmask
@
text
@d1 1
a1 1
/*	$OpenBSD: via.c,v 1.1 2004/04/11 18:12:10 deraadt Exp $	*/
a58 1
int viac3_crypto_present;
a113 1
	i386_has_xcrypt = viac3_crypto_present;
@


1.1
log
@move via-specific chunks to own file
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.288 2004/04/02 22:28:40 tedu Exp $	*/
d115 1
a115 1
	i386_has_xcrypt = 1;
@


1.1.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@

