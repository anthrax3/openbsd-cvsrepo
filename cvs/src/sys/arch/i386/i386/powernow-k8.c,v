head	1.30;
access;
symbols
	OPENBSD_6_1:1.29.0.8
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.18
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.14
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.12
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.10
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.8
	OPENBSD_5_0:1.26.0.6
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.4
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.25.0.6
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.8
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.23.0.4
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.3.0.2
	OPENBSD_3_9_BASE:1.3;
locks; strict;
comment	@ * @;


1.30
date	2017.09.08.05.36.51;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	uRv5pa9QDlZaYgwD;

1.29
date	2015.09.08.07.12.56;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	UsnEcDGT4QqqoPvB;

1.28
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.27;
commitid	uzzBR7hz9ncd4O6G;

1.27
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.26;
commitid	uKVPYMN2MLxdZxzH;

1.26
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.29.03.50.49;	author gwk;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.15.00.10.47;	author gwk;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.31.17.49.16;	author gwk;	state Exp;
branches;
next	1.22;

1.22
date	2007.04.24.17.12.26;	author gwk;	state Exp;
branches;
next	1.21;

1.21
date	2006.12.20.17.50.40;	author gwk;	state Exp;
branches;
next	1.20;

1.20
date	2006.12.12.23.14.27;	author dim;	state Exp;
branches;
next	1.19;

1.19
date	2006.12.09.00.16.46;	author gwk;	state Exp;
branches;
next	1.18;

1.18
date	2006.10.19.19.29.04;	author tom;	state Exp;
branches;
next	1.17;

1.17
date	2006.10.19.10.55.56;	author tom;	state Exp;
branches;
next	1.16;

1.16
date	2006.09.25.22.28.11;	author gwk;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.25.20.52.59;	author gwk;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.24.20.57.57;	author gwk;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.16.05.58.50;	author gwk;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.13.00.32.35;	author gwk;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.27.04.46.12;	author gwk;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.11.13.21.12;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.18.02.14.33;	author gwk;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.20.12.08.59;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.16.02.39.57;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.16.02.35.08;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.15.19.56.48;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.08.03.33.21;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.26.11.22.12;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.28.07.11.13;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2005.10.28.07.03.41;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.30
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: powernow-k8.c,v 1.29 2015/09/08 07:12:56 deraadt Exp $ */

/*
 * Copyright (c) 2004 Martin Végiard.
 * Copyright (c) 2004-2005 Bruno Ducrot
 * Copyright (c) 2004 FUKUDA Nobuhiko <nfukuda@@spa.is.uec.ac.jp>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/* AMD POWERNOW K8 driver */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/sysctl.h>

#include <dev/isa/isareg.h>
#include <i386/isa/isa_machdep.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/bus.h>

#include "acpicpu.h"

#if NACPICPU > 0
#include <dev/acpi/acpidev.h>
#include <dev/acpi/acpivar.h>
#endif

#define BIOS_START			0xe0000
#define	BIOS_LEN			0x20000
#define BIOS_STEP			16

/*
 * MSRs and bits used by PowerNow! technology
 */
#define MSR_AMDK7_FIDVID_CTL		0xc0010041
#define MSR_AMDK7_FIDVID_STATUS		0xc0010042
#define AMD_PN_FID_VID			0x06

/* Bitfields used by K8 */

#define PN8_CTR_FID(x)			((x) & 0x3f)
#define PN8_CTR_VID(x)			(((x) & 0x1f) << 8)
#define PN8_CTR_PENDING(x)		(((x) & 1) << 32)

#define PN8_STA_CFID(x)			((x) & 0x3f)
#define PN8_STA_SFID(x)			(((x) >> 8) & 0x3f)
#define PN8_STA_MFID(x)			(((x) >> 16) & 0x3f)
#define PN8_STA_PENDING(x)		(((x) >> 31) & 0x01)
#define PN8_STA_CVID(x)			(((x) >> 32) & 0x1f)
#define PN8_STA_SVID(x)			(((x) >> 40) & 0x1f)
#define PN8_STA_MVID(x)			(((x) >> 48) & 0x1f)

/* Reserved1 to powernow k8 configuration */
#define PN8_PSB_VERSION			0x14
#define PN8_PSB_TO_RVO(x)		((x) & 0x03)
#define PN8_PSB_TO_IRT(x)		(((x) >> 2) & 0x03)
#define PN8_PSB_TO_MVS(x)		(((x) >> 4) & 0x03)
#define PN8_PSB_TO_BATT(x)		(((x) >> 6) & 0x03)

/* ACPI ctr_val status register to powernow k8 configuration */
#define PN8_ACPI_CTRL_TO_FID(x)		((x) & 0x3f)
#define PN8_ACPI_CTRL_TO_VID(x)		(((x) >> 6) & 0x1f)
#define PN8_ACPI_CTRL_TO_VST(x)		(((x) >> 11) & 0x1f)
#define PN8_ACPI_CTRL_TO_MVS(x)		(((x) >> 18) & 0x03)
#define PN8_ACPI_CTRL_TO_PLL(x)		(((x) >> 20) & 0x7f)
#define PN8_ACPI_CTRL_TO_RVO(x)		(((x) >> 28) & 0x03)
#define PN8_ACPI_CTRL_TO_IRT(x)		(((x) >> 30) & 0x03)

#define PN8_PSS_CFID(x)			((x) & 0x3f)
#define PN8_PSS_CVID(x)			(((x) >> 6) & 0x1f)

#define PN8_PLL_LOCK(x)			((x) * 1000/5)
#define WRITE_FIDVID(fid, vid, ctrl)	\
	wrmsr(MSR_AMDK7_FIDVID_CTL,	\
	    (((ctrl) << 32) | (1ULL << 16) | ((vid) << 8) | (fid)))

#define COUNT_OFF_IRT(irt)		DELAY(10 * (1 << (irt)))
#define COUNT_OFF_VST(vst)		DELAY(20 * (vst))

#define FID_TO_VCO_FID(fid)		\
	(((fid) < 8) ? (8 + ((fid) << 1)) : (fid))

#define POWERNOW_MAX_STATES		16

struct k8pnow_state {
	int freq;
	uint8_t fid;
	uint8_t vid;
};

struct k8pnow_cpu_state {
	struct k8pnow_state state_table[POWERNOW_MAX_STATES];
	unsigned int n_states;
	unsigned int sgtc;
	unsigned int vst;
	unsigned int mvs;
	unsigned int pll;
	unsigned int rvo;
	unsigned int irt;
	int low;
};

struct psb_s {
	char signature[10];	/* AMDK7PNOW! */
	uint8_t version;
	uint8_t flags;
	uint16_t ttime;		/* Min Settling time */
	uint8_t reserved;
	uint8_t n_pst;
};

struct pst_s {
	uint32_t cpuid;
	uint8_t pll;
	uint8_t fid;
	uint8_t vid;
	uint8_t n_states;
};

struct k8pnow_cpu_state *k8pnow_current_state = NULL;
extern int setperf_prio;
extern int perflevel;

int k8pnow_read_pending_wait(uint64_t *);
int k8pnow_decode_pst(struct k8pnow_cpu_state *, uint8_t *);
int k8pnow_states(struct k8pnow_cpu_state *, uint32_t, unsigned int, unsigned int);
void k8pnow_transition(struct k8pnow_cpu_state *e, int);

#if NACPICPU > 0
int k8pnow_acpi_init(struct k8pnow_cpu_state *, uint64_t);
void k8pnow_acpi_pss_changed(struct acpicpu_pss *, int);
int k8pnow_acpi_states(struct k8pnow_cpu_state *, struct acpicpu_pss *, int,
    uint64_t);
#endif

int
k8pnow_read_pending_wait(uint64_t *status)
{
	unsigned int i = 100000;

	while (i--) {
		*status = rdmsr(MSR_AMDK7_FIDVID_STATUS);
		if (!PN8_STA_PENDING(*status))
			return 0;

	}
	printf("k8pnow_read_pending_wait: change pending stuck.\n");
	return 1;
}

void
k8_powernow_setperf(int level)
{
	unsigned int i;
	struct k8pnow_cpu_state *cstate;

	cstate = k8pnow_current_state;

	i = ((level * cstate->n_states) + 1) / 101;
	if (i >= cstate->n_states)
		i = cstate->n_states - 1;

	k8pnow_transition(cstate, i);
}

void
k8pnow_transition(struct k8pnow_cpu_state *cstate, int level)
{
	uint64_t status;
	int cfid, cvid, fid = 0, vid = 0;
	int rvo;
	u_int val;

	/*
	 * We dont do a k8pnow_read_pending_wait here, need to ensure that the
	 * change pending bit isn't stuck,
	 */
	status = rdmsr(MSR_AMDK7_FIDVID_STATUS);
	if (PN8_STA_PENDING(status))
		return;
	cfid = PN8_STA_CFID(status);
	cvid = PN8_STA_CVID(status);

	fid = cstate->state_table[level].fid;
	vid = cstate->state_table[level].vid;

	if (fid == cfid && vid == cvid)
		return;

	/*
	 * Phase 1: Raise core voltage to requested VID if frequency is
	 * going up.
	 */
	while (cvid > vid) {
		val = cvid - (1 << cstate->mvs);
		WRITE_FIDVID(cfid, (val > 0) ? val : 0, 1ULL);
		if (k8pnow_read_pending_wait(&status))
			return;
		cvid = PN8_STA_CVID(status);
		COUNT_OFF_VST(cstate->vst);
	}

	/* ... then raise to voltage + RVO (if required) */
	for (rvo = cstate->rvo; rvo > 0 && cvid > 0; --rvo) {
		/* XXX It's not clear from spec if we have to do that
		 * in 0.25 step or in MVS.  Therefore do it as it's done
		 * under Linux */
		WRITE_FIDVID(cfid, cvid - 1, 1ULL);
		if (k8pnow_read_pending_wait(&status))
			return;
		cvid = PN8_STA_CVID(status);
		COUNT_OFF_VST(cstate->vst);
	}

	/* Phase 2: change to requested core frequency */
	if (cfid != fid) {
		u_int vco_fid, vco_cfid;

		vco_fid = FID_TO_VCO_FID(fid);
		vco_cfid = FID_TO_VCO_FID(cfid);

		while (abs(vco_fid - vco_cfid) > 2) {
			if (fid > cfid) {
				if (cfid > 6)
					val = cfid + 2;
				else
					val = FID_TO_VCO_FID(cfid) + 2;
			} else
				val = cfid - 2;
			WRITE_FIDVID(val, cvid, (uint64_t)cstate->pll * 1000 / 5);

			if (k8pnow_read_pending_wait(&status))
				return;
			cfid = PN8_STA_CFID(status);
			COUNT_OFF_IRT(cstate->irt);

			vco_cfid = FID_TO_VCO_FID(cfid);
		}

		WRITE_FIDVID(fid, cvid, (uint64_t) cstate->pll * 1000 / 5);
		if (k8pnow_read_pending_wait(&status))
			return;
		cfid = PN8_STA_CFID(status);
		COUNT_OFF_IRT(cstate->irt);
	}

	/* Phase 3: change to requested voltage */
	if (cvid != vid) {
		WRITE_FIDVID(cfid, vid, 1ULL);
		if (k8pnow_read_pending_wait(&status))
			return;
		cvid = PN8_STA_CVID(status);
		COUNT_OFF_VST(cstate->vst);
	}

	if (cfid == fid || cvid == vid)
		cpuspeed = cstate->state_table[level].freq;
}

/*
 * Given a set of pair of fid/vid, and number of performance states,
 * compute state_table via an insertion sort.
 */
int
k8pnow_decode_pst(struct k8pnow_cpu_state *cstate, uint8_t *p)
{
	int i, j, n;
	struct k8pnow_state state;

	for (n = 0, i = 0; i < cstate->n_states; i++) {
		state.fid = *p++;
		state.vid = *p++;

		/*
		 * The minimum supported frequency per the data sheet is 800MHz
		 * The maximum supported frequency is 5000MHz.
		 */
		state.freq = 800 + state.fid * 100;
		j = n;
		while (j > 0 && cstate->state_table[j - 1].freq > state.freq) {
			memcpy(&cstate->state_table[j],
			    &cstate->state_table[j - 1],
			    sizeof(struct k8pnow_state));
			--j;
		}
		memcpy(&cstate->state_table[j], &state,
		    sizeof(struct k8pnow_state));
		n++;
	}
	return 1;
}

int
k8pnow_states(struct k8pnow_cpu_state *cstate, uint32_t cpusig,
    unsigned int fid, unsigned int vid)
{
	struct psb_s *psb;
	struct pst_s *pst;
	uint8_t *p;
	int i;

	for (p = (u_int8_t *)ISA_HOLE_VADDR(BIOS_START);
	    p < (u_int8_t *)ISA_HOLE_VADDR(BIOS_START + BIOS_LEN); p +=
	    BIOS_STEP) {
		if (memcmp(p, "AMDK7PNOW!", 10) == 0) {
			psb = (struct psb_s *)p;
			if (psb->version != PN8_PSB_VERSION)
				return 0;

			cstate->vst = psb->ttime;
			cstate->rvo = PN8_PSB_TO_RVO(psb->reserved);
			cstate->irt = PN8_PSB_TO_IRT(psb->reserved);
			cstate->mvs = PN8_PSB_TO_MVS(psb->reserved);
			cstate->low = PN8_PSB_TO_BATT(psb->reserved);
			p+= sizeof(struct psb_s);

			for (i = 0; i < psb->n_pst; ++i) {
				pst = (struct pst_s *) p;

				cstate->pll = pst->pll;
				cstate->n_states = pst->n_states;
				if (cpusig == pst->cpuid &&
				    pst->fid == fid && pst->vid == vid) {
					return (k8pnow_decode_pst(cstate,
					    p+= sizeof (struct pst_s)));
				}
				p += sizeof(struct pst_s) + 2
				     * cstate->n_states;
			}
		}
	}

	return 0;

}

#if NACPICPU > 0

int
k8pnow_acpi_states(struct k8pnow_cpu_state * cstate, struct acpicpu_pss * pss,
    int nstates, uint64_t status)
{
	struct k8pnow_state state;
	int j, k, n;
	uint32_t ctrl;

	k = -1;

	for (n = 0; n < cstate->n_states; n++) {
		if ((PN8_STA_CFID(status) == PN8_PSS_CFID(pss[n].pss_status)) &&
		    (PN8_STA_CVID(status) == PN8_PSS_CVID(pss[n].pss_status)))
			k = n;
		ctrl = pss[n].pss_ctrl;
		state.fid = PN8_ACPI_CTRL_TO_FID(ctrl);
		state.vid = PN8_ACPI_CTRL_TO_VID(ctrl);

		state.freq = pss[n].pss_core_freq;
		j = n;
		while (j > 0 && cstate->state_table[j - 1].freq > state.freq) {
			memcpy(&cstate->state_table[j],
			    &cstate->state_table[j - 1],
			    sizeof(struct k8pnow_state));
			--j;
		}
		memcpy(&cstate->state_table[j], &state,
		    sizeof(struct k8pnow_state));
	}

	return k;
}

void
k8pnow_acpi_pss_changed(struct acpicpu_pss * pss, int npss)
{
	int curs;
	struct k8pnow_cpu_state * cstate;
	uint32_t ctrl;
	uint64_t status;

	status = rdmsr(MSR_AMDK7_FIDVID_STATUS);
	cstate = k8pnow_current_state;

	curs = k8pnow_acpi_states(cstate, pss, npss, status);
	ctrl = pss[curs].pss_ctrl;

	cstate->rvo = PN8_ACPI_CTRL_TO_RVO(ctrl);
	cstate->vst = PN8_ACPI_CTRL_TO_VST(ctrl);
	cstate->mvs = PN8_ACPI_CTRL_TO_MVS(ctrl);
	cstate->pll = PN8_ACPI_CTRL_TO_PLL(ctrl);
	cstate->irt = PN8_ACPI_CTRL_TO_IRT(ctrl);
	cstate->low = 0;
	cstate->n_states = npss;
}

int
k8pnow_acpi_init(struct k8pnow_cpu_state * cstate, uint64_t status)
{
	int curs;
	uint32_t ctrl;
	struct acpicpu_pss *pss;

	cstate->n_states = acpicpu_fetch_pss(&pss);
	if (cstate->n_states == 0)
		return 0;
	acpicpu_set_notify(k8pnow_acpi_pss_changed);

	curs = k8pnow_acpi_states(cstate, pss, cstate->n_states, status);
	ctrl = pss[curs].pss_ctrl;

	cstate->rvo = PN8_ACPI_CTRL_TO_RVO(ctrl);
	cstate->vst = PN8_ACPI_CTRL_TO_VST(ctrl);
	cstate->mvs = PN8_ACPI_CTRL_TO_MVS(ctrl);
	cstate->pll = PN8_ACPI_CTRL_TO_PLL(ctrl);
	cstate->irt = PN8_ACPI_CTRL_TO_IRT(ctrl);
	cstate->low = 0;

	return 1;
}

#endif /* NACPICPU */

void
k8_powernow_init(void)
{
	uint64_t status;
	u_int maxfid, maxvid, i;
	struct k8pnow_cpu_state *cstate;
	struct k8pnow_state *state;
	struct cpu_info * ci;
	char * techname = NULL;
	u_int32_t regs[4];

	ci = curcpu();

	if (setperf_prio > 1)
		return;

	if (k8pnow_current_state)
		return;

	cpuid(0x80000000, regs);
	if (regs[0] < 0x80000007)
		return;

	cpuid(0x80000007, regs);
	if (!(regs[3] & AMD_PN_FID_VID))
		return;

	/* Extended CPUID signature value */
	cpuid(0x80000001, regs);

	cstate = malloc(sizeof(struct k8pnow_cpu_state), M_DEVBUF, M_NOWAIT);
	if (!cstate)
		return;

	cstate->n_states = 0;
	status = rdmsr(MSR_AMDK7_FIDVID_STATUS);
	maxfid = PN8_STA_MFID(status);
	maxvid = PN8_STA_MVID(status);

	/*
	* If start FID is different to max FID, then it is a
	* mobile processor.  If not, it is a low powered desktop
	* processor.
	*/
	if (PN8_STA_SFID(status) != PN8_STA_MFID(status))
		techname = "PowerNow! K8";
	else
		techname = "Cool'n'Quiet K8";

#if NACPICPU > 0
	/* If we have acpi check acpi first */
	if (!k8pnow_acpi_init(cstate, status))
#endif
	{
		if (!k8pnow_states(cstate, ci->ci_signature, maxfid, maxvid))
			k8pnow_states(cstate, regs[0], maxfid, maxvid);
	}
	if (cstate->n_states) {
		printf("%s: %s %d MHz: speeds:",
		    ci->ci_dev.dv_xname, techname, cpuspeed);
		for (i = cstate->n_states; i > 0; i--) {
			state = &cstate->state_table[i-1];
			printf(" %d", state->freq);
		}
		printf(" MHz\n");
		k8pnow_current_state = cstate;
		cpu_setperf = k8_powernow_setperf;
		setperf_prio = 1;
		return;
	}
	free(cstate, M_DEVBUF, sizeof(*cstate));
}
@


1.29
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.28 2014/09/14 14:17:23 jsg Exp $ */
a29 1
#include <sys/types.h>
@


1.28
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.27 2014/07/12 18:44:41 tedu Exp $ */
d514 1
a514 1
	free(cstate, M_DEVBUF, 0);
@


1.27
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.26 2010/04/20 22:05:41 tedu Exp $ */
a33 1
#include <sys/proc.h>
@


1.26
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.25 2008/06/29 03:50:49 gwk Exp $ */
d515 1
a515 1
	free(cstate, M_DEVBUF);
@


1.25
log
@Split k8_powernow_setperf into two functions, the new function called
k8pnow_transition handles the actual transition, this change is
necessitated by some of the ACPI work which can involve dynamic changes
in the available states in response to endogenous events such as removing
the AC power. This new code is designed to cope with the current operating
point not being among the newly available states in which case we
recalculate what the current desired performance level coresponds to among
the new states.

Also fix a screw up with the acpi_states function (fix originally by
Markus Hennecke in a diff to tech@@ thanks) which resolves PR 5854. Diff
tested by numerous people thanks!

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.24 2008/06/15 00:10:47 gwk Exp $ */
d34 1
@


1.24
log
@Ensure that when using the ACPI tables the RVO field is initialized from the ctrl value.
commit it marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.23 2007/05/31 17:49:16 gwk Exp $ */
d91 3
d144 1
d148 2
a149 2
int k8pnow_states(struct k8pnow_cpu_state *, uint32_t, unsigned int,
    unsigned int);
d177 14
d192 2
a193 1
	int cfid, cvid, fid = 0, vid = 0, rvo;
a194 1
	struct k8pnow_cpu_state *cstate;
d206 2
a207 7
	cstate = k8pnow_current_state;

	i = ((level * cstate->n_states) + 1) / 101;
	if (i >= cstate->n_states)
		i = cstate->n_states - 1;
	fid = cstate->state_table[i].fid;
	vid = cstate->state_table[i].vid;
d252 1
a252 2
			WRITE_FIDVID(val, cvid, (uint64_t)
			    PN8_PLL_LOCK(cstate->pll));
d262 1
a262 1
		WRITE_FIDVID(fid, cvid, (uint64_t) PN8_PLL_LOCK(cstate->pll));
d279 1
a279 1
		cpuspeed = cstate->state_table[i].freq;
d372 2
a373 1
		if (status == pss[n].pss_status)
@


1.23
log
@Make powernow-k8 on amd64 and i386 use the _PSS object from acpi to
retreive p_state data as spelled out in the amd64 bios and kernel
developers guide. This code is still a little rough around the edges but
has been tested by myself on a tyan machine and by phessler at theapt
dot org on an HP DL145. This diff also takes a first stab and cleaning up
the acpicpu dmesg spam.

ok tedu, marco
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.22 2007/04/24 17:12:26 gwk Exp $ */
d394 2
d419 1
@


1.22
log
@Choose the state for a request performance level based on calculations
involving the number of states and not the frequencies of the states,
which can lead to strange distributions of the states over the hw.setperf
range (0-100). Tested by many.

ok canacar, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.21 2006/12/20 17:50:40 gwk Exp $ */
d43 7
d147 7
d347 81
d477 8
a484 2
	if (!k8pnow_states(cstate, ci->ci_signature, maxfid, maxvid))
		k8pnow_states(cstate, regs[0], maxfid, maxvid);
@


1.21
log
@"#ifdef is a tool of the weak!"
Rename pentium_mhz to cpuspeed which is consistant with amd64 making
shared ACPI code less nasty.
ok marco, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.20 2006/12/12 23:14:27 dim Exp $ */
a134 3
/*
 * Prototypes
 */
d158 1
a158 1
	unsigned int i, low, high, freq;
a174 2
	low = cstate->state_table[0].freq;
	high = cstate->state_table[cstate->n_states-1].freq;
d176 5
a180 9
	freq = low + (high - low) * level / 100;

	for (i = 0; i < cstate->n_states; i++) {
		if (cstate->state_table[i].freq >= freq) {
			fid = cstate->state_table[i].fid;
			vid = cstate->state_table[i].vid;
			break;
		}
	}
d323 2
a324 1
				p += sizeof(struct pst_s) + 2 * cstate->n_states;
d355 1
a355 1
	
d359 1
a359 1
	
@


1.20
log
@Complete gwk's previous patch to stop setperf methods from returning
errors to userland: make all cpu_setperf functions return void.

Tested by many, ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.19 2006/12/09 00:16:46 gwk Exp $ */
d262 1
a262 1
		pentium_mhz = cstate->state_table[i].freq;
d394 1
a394 1
		    ci->ci_dev.dv_xname, techname, pentium_mhz);
@


1.19
log
@Like the earlier change to powernow-k7.c check for both the regular cpuid
signature AND the AMD extended cpuid 0x800000001 (%eax).
Tested by,
krw@@, Joerg Niendorf <joerg.bsd AT internode.net.au> and
steven mestdagh <steven.mestdagh AT esat.kuleuven.be>

ok dim@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.18 2006/10/19 19:29:04 tom Exp $ */
d158 1
a158 1
int
d173 1
a173 1
		return 0;
d192 1
a192 1
		return (0);
d202 1
a202 1
			return 0;
d214 1
a214 1
			return 0;
d238 1
a238 1
				return 0;
d247 1
a247 1
			return 0;
d256 1
a256 1
			return 0;
a262 2
	
	return (0);
@


1.18
log
@Fix the spellings of Cool'n'Quiet and PowerNow! in a couple of places.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.17 2006/10/19 10:55:56 tom Exp $ */
d369 3
d377 1
d392 8
a399 13
	if (k8pnow_states(cstate, ci->ci_signature, maxfid, maxvid)) {
		if (cstate->n_states) {
			printf("%s: %s %d MHz: speeds:",
			    ci->ci_dev.dv_xname, techname, pentium_mhz);
			for (i = cstate->n_states; i > 0; i--) {
				state = &cstate->state_table[i-1];
				printf(" %d", state->freq);
			}
			printf(" MHz\n");
			k8pnow_current_state = cstate;
			cpu_setperf = k8_powernow_setperf;
			setperf_prio = 1;
			return;
d401 5
@


1.17
log
@s/Mhz/MHz/ in comments and printf() strings

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.16 2006/09/25 22:28:11 gwk Exp $ */
d48 1
a48 1
 * MSRs and bits used by Powernow technology
d386 1
a386 1
		techname = "Cool`n'Quiet K8";
@


1.16
log
@Martin Végiard <deadbug AT gmail.com> has been kind enough to rescind the
third clause of his license and strike the phrase "All rights reserved", so we
can consolidate both license blocks into one. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.15 2006/08/25 20:52:59 gwk Exp $ */
d390 1
a390 1
			printf("%s: %s %d Mhz: speeds:",
d396 1
a396 1
			printf(" Mhz\n");
@


1.15
log
@Be a little less agressive in declaring the change pending bit stuck, increase
the number of retries by two orders of magnitude wont affect most systems
but will make transitions smoother on marginal ones, if people see
"change pending bit stuck" printed to the console after this I would like to
hear about it.

tested by and ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.14 2006/08/24 20:57:57 gwk Exp $ */
a4 24
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
@


1.14
log
@Same change as on amd64. Don't propogate low level errors to userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.13 2006/06/16 05:58:50 gwk Exp $ */
d170 1
a170 1
	unsigned int i = 1000;
@


1.13
log
@From k*_powernow_setperf() always return 0, i.e.
Do not return low level errors to userspace where they will not/can not be
coped with.
: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.12 2006/06/13 00:32:35 gwk Exp $ */
d197 1
a197 1
		return 1;
d226 1
a226 1
			return 1;
d238 1
a238 1
			return 1;
d262 1
a262 1
				return 1;
d271 1
a271 1
			return 1;
d280 1
a280 1
			return 1;
@


1.12
log
@Change the value returned if the CPU fails to honor a request to
adjust frequency from 1 (EPERM) to EIO.
Suggested by and ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.11 2006/05/27 04:46:12 gwk Exp $ */
d285 3
a287 8
	/* Check if transition failed. */
	if (cfid != fid || cvid != vid) {
		printf("%s transition to fid: %d vid: %d failed.", __func__,
		    fid, vid);		
		return (EIO);
	}

	pentium_mhz = cstate->state_table[i].freq;
@


1.11
log
@Teach powernow about setperf prioritys, add a setperf_prio to amd64.
ok uwe@@, "good" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.10 2006/05/11 13:21:12 mickey Exp $ */
d289 1
a289 1
		return (0);
@


1.10
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.9 2006/04/18 02:14:33 gwk Exp $ */
d157 1
d385 3
d428 1
@


1.9
log
@Ensure that we check if the transition succeeded before we adjust
pentium_mhz on K7, and print a usefull diagnostic message if it does
not on K7 and K8.
"makes sense to me" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.8 2006/03/20 12:08:59 dlg Exp $ */
d338 1
a338 1
	    p < (u_int8_t *)ISA_HOLE_VADDR(BIOS_START + BIOS_LEN); p += 
@


1.8
log
@a bit of demagification. this moves the checks for the cpu scaling features
out of machdep and into powernow-k7 and -k8. machdep now just figures out
if its the right type of cpu before calling the powernow code which
figures out if the scaling is supported.

from gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.7 2006/03/16 02:39:57 dlg Exp $ */
d67 3
a69 3
#define BIOS_START		0xe0000
#define	BIOS_LEN		0x20000
#define BIOS_STEP		16
d285 5
a289 2
	if (cfid != fid || cvid != vid)
		return (1);
@


1.7
log
@dont leak memory when we fail to find any valid states.

from gwk, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.7 2006/03/15 23:00:10 gwk Exp $ */
d69 1
d76 1
d93 1
d100 7
a106 7
#define ACPI_PN8_CTRL_TO_FID(x)		((x) & 0x3f)
#define ACPI_PN8_CTRL_TO_VID(x)		(((x) >> 6) & 0x1f)
#define ACPI_PN8_CTRL_TO_VST(x)		(((x) >> 11) & 0x1f)
#define ACPI_PN8_CTRL_TO_MVS(x)		(((x) >> 18) & 0x03)
#define ACPI_PN8_CTRL_TO_PLL(x)		(((x) >> 20) & 0x7f)
#define ACPI_PN8_CTRL_TO_RVO(x)		(((x) >> 28) & 0x03)
#define ACPI_PN8_CTRL_TO_IRT(x)		(((x) >> 30) & 0x03)
d108 1
d113 2
d116 1
a116 4
#define COUNT_OFF_IRT(irt)	DELAY(10 * (1 << (irt)))
#define COUNT_OFF_VST(vst)	DELAY(20 * (vst))

#define FID_TO_VCO_FID(fid)	\
d257 2
a258 1
			WRITE_FIDVID(val, cvid, (uint64_t)cstate->pll * 1000 / 5);
d268 1
a268 1
		WRITE_FIDVID(fid, cvid, (uint64_t) cstate->pll * 1000 / 5);
d335 2
a336 1
	    p < (u_int8_t *)ISA_HOLE_VADDR(BIOS_START + BIOS_LEN); p += 16) {
d339 1
a339 1
			if (psb->version != 0x14)
d377 2
d382 8
@


1.6
log
@display the possible speedstep values like we do on intel chips.

from gwk, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.6 2006/03/15 22:33:06 gwk Exp $ */
d406 1
d409 1
@


1.5
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.4 2006/03/08 03:33:21 uwe Exp $ */
d397 5
a401 6
			printf("%s: AMD %s available states ",
			    ci->ci_dev.dv_xname, techname);
			for (i= 0; i < cstate->n_states; i++) {
				state = &cstate->state_table[i];
				printf("%c%d", i==0 ? '(' : ',',
				    state->freq);
d403 1
a403 1
			printf(")\n");
@


1.4
log
@Patch from Gordon Klock to update AMD PowerNow K8 support on i386,
and to add amd64 K8 support from FreeBSD.
@
text
@d1 2
a2 1
/*	$OpenBSD: powernow-k8.c,v 1.3 2005/11/26 11:22:12 tedu Exp $ */
d137 1
a137 1
	char signature[10];     /* AMDK7PNOW! */
d140 1
a140 1
	uint16_t ttime;         /* Min Settling time */
d153 1
a153 1
struct k8pnow_cpu_state *k8pnow_current_state = NULL; 
d163 3
a165 1
int k8pnow_read_pending_wait(uint64_t * status) {
d167 2
a168 1
	while(i--) {
d183 1
a183 2
	int cfid, cvid, fid = 0, vid = 0;
	int rvo;
d297 1
d301 2
a302 2
	
		/* 
d304 2
a305 2
	   	 * The maximum supported frequency is 5000MHz. 
		 */ 	   
d344 1
a344 1
			for(i = 0; i < psb->n_pst; ++i) {
d374 1
a374 1
	if(k8pnow_current_state)
d399 1
a399 1
			for(i= 0; i < cstate->n_states; i++) {
@


1.3
log
@some cleanup from gordon
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.2 2005/10/28 07:11:13 tedu Exp $ */
a114 23
/*
 * Divide each value by 10 to get the processor multiplier.
 */

static int pn8_fid_to_mult[32] = {
	40, 50, 60, 70, 80, 90, 100, 110,
	120, 130, 140, 150, 160, 170, 180, 190,
	220, 230, 240, 250, 260, 270, 280, 290,
	300, 310, 320, 330, 340, 350,
};

/*
 * Units are in mV.
 */

/* Desktop and Mobile VRM (K8) */
static int pn8_vid_to_volts[] = {
	1550, 1525, 1500, 1475, 1450, 1425, 1400, 1375,
	1350, 1325, 1300, 1275, 1250, 1225, 1200, 1175,
	1150, 1125, 1100, 1075, 1050, 1025, 1000, 975,
	950, 925, 900, 875, 850, 825, 800, 0,
};

a125 1
	unsigned int fsb;
a132 1
	int *vid_to_volts;
d152 1
a152 1
struct k8pnow_cpu_state *k8pnow_current_state[I386_MAXPROCS];
d194 1
a194 1
	cstate = k8pnow_current_state[cpu_number()];
d251 1
a251 2
			WRITE_FIDVID(val, cvid, cstate->pll *
			    (uint64_t)cstate->fsb);
d261 1
a261 1
		WRITE_FIDVID(fid, cvid, cstate->pll * (uint64_t)cstate->fsb);
d281 1
a281 1
	pentium_mhz = ((cstate->state_table[i].freq / 100000)+1)*100;
d297 6
a302 2

		state.freq = 100 * pn8_fid_to_mult[state.fid >>1] *cstate->fsb;
d363 1
a363 1
	u_int maxfid, maxvid, currentfid, i;
d370 3
a379 4
	currentfid = PN8_STA_CFID(status);

	CPU_CLOCKUPDATE();
	cstate->fsb = pentium_base_tsc/ 100000/ pn8_fid_to_mult[currentfid>>1];
a380 1
	cstate->vid_to_volts = pn8_vid_to_volts;
d398 1
a398 1
				    ((state->freq / 100000)+1)*100);
d401 1
a401 1
			k8pnow_current_state[cpu_number()] = cstate;
@


1.2
log
@malloc(M_WAITOK) is bad in init code, M_DEVBUF is nicer than M_TEMP,
and if the cpu gets stuck, don't spin too long.
@
text
@d1 1
a1 1
/*	$OpenBSD: powernow-k8.c,v 1.1 2005/10/28 07:03:41 tedu Exp $ */
d142 2
a143 2
	int fid;
	int vid;
d170 5
a174 5
	uint32_t signature;
	uint8_t fsb;		/* Front Side Bus frequency (Mhz) */
	uint8_t fid;		/* Max Frequency code */
	uint8_t vid;		/* Max Voltage code */
	uint8_t n_states;	/* Number of states */
d183 1
a183 1
int k8pnow_decode_pst(struct k8pnow_cpu_state *, uint8_t *, int);
a186 1

d188 2
a189 8
	unsigned int i = 0;
	while(PN8_STA_PENDING(*status)) {
		i++;
		if (i > 1000) {
			printf("k8pnow_read_pending_wait: change pending stuck"
			    ".\n");
			return 1;
		}
d191 3
d195 2
a196 1
	return 0;
a219 1
	high = cstate->state_table[cstate->n_states - 1].freq;
d221 2
d307 1
a307 1
	calibrate_cyclecounter();
d316 1
a316 2
k8pnow_decode_pst(struct k8pnow_cpu_state *cstate, uint8_t *p,
	int npst)
d320 1
a320 5

	for (i = 0; i < POWERNOW_MAX_STATES; ++i)
		cstate->state_table[i].freq = -1;

	for (n = 0, i = 0; i < npst; ++i) {
d324 1
a324 2
		state.freq = 100 * pn8_fid_to_mult[state.fid >> 1] *
			cstate->fsb;
d326 1
a326 1
		while (j > 0 && cstate->state_table[j - 1].freq < state.freq) {
a342 1
	int maxpst;
d346 1
d360 4
d365 4
a368 11
			p += sizeof(struct psb_s);
			/*
			 * XXX: FreeBSD completely ignores psb->n_pst
			 * XXX: n_pst might be 2 its not supposed to be
			 * XXX: but why 200?
			 */
			for (maxpst = 0; maxpst < 200; maxpst++) {
				pst = (struct pst_s*) p;
				if (cpusig == pst->signature && fid == pst->fid
				   && vid == pst->vid) {
					cstate->n_states = pst->n_states;
d370 1
a370 2
					    p + sizeof(struct pst_s),
					    cstate->n_states));
d372 1
a372 1
				p += sizeof(struct pst_s) + (2 * pst->n_states);
d384 2
a385 2
	uint64_t status, rate;
	u_int maxfid, maxvid, currentfid;
d387 1
a395 1
	rate = pentium_mhz;
d401 3
a403 1
	cstate->fsb = rate / 100000 / pn8_fid_to_mult[currentfid >> 1];
a415 2
		printf("%s: AMD %s: %d available states\n", ci->ci_dev.dv_xname,
		    techname, cstate->n_states);
d417 8
@


1.1
log
@update support for powernow (cool and quiet) on k7, and add support
for k8.  preliminary and not well tested yet.  from freebsd via
gordon klok.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d192 1
a192 1
		if (i > 0x1000000) {
d403 3
a405 1
	cstate = malloc(sizeof(struct k8pnow_cpu_state), M_TEMP, M_WAITOK);
@

