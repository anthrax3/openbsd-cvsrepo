head	1.16;
access;
symbols
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.16
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.14
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.10
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.8
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.6
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.12.0.18
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.16
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.12
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.14
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.10
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.8
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.6
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.6.0.12
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.10
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.5.0.2
	UBC_BASE:1.5
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	SMP:1.2.0.2
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2015.12.18.08.15.09;	author gerhard;	state Exp;
branches;
next	1.15;
commitid	uf1gfS5CrWUpp8kL;

1.15
date	2015.04.12.18.37.53;	author mlarkin;	state Exp;
branches;
next	1.14;
commitid	5ST94uMTezmXYdhY;

1.14
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.13;
commitid	uzzBR7hz9ncd4O6G;

1.13
date	2011.04.23.22.16.13;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.20.21.15.01;	author tom;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.11.13.21.11;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.10.13.45.37;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.27.15.37.50;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.22.12.52.55;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.13.14.23.26;	author martin;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.16.04.15.17;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.28.15.02.58;	author art;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.05.23.25.35;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.22.23.36.51;	author niklas;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.07.05.14.26.34;	author hugh;	state Exp;
branches;
next	;

1.2.2.1
date	2001.04.18.16.07.15;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.07.04.10.16.34;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Prevent uvm_fault() when hitting a breakpoint by restoring the original
page protection bits.

Go ahead, mlarkin@@
@
text
@/*	$OpenBSD: db_memrw.c,v 1.15 2015/04/12 18:37:53 mlarkin Exp $	*/
/*	$NetBSD: db_memrw.c,v 1.6 1999/04/12 20:38:19 pk Exp $	*/

/*
 * Mach Operating System
 * Copyright (c) 1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 *
 *	db_interface.c,v 2.4 1991/02/05 17:11:13 mrt (CMU)
 */

/*
 * Routines to read and write memory on behalf of the debugger, used
 * by DDB and KGDB.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <machine/db_machdep.h>

#include <ddb/db_access.h>

#define PG_LGFRAME	0xffc00000	/* large (4M) page frame mask */
#define PG_LGFRAME_PAE	0xffe00000	/* large (2M) page frame mask */

extern int cpu_pae;

/*
 * Read bytes from kernel address space for debugger.
 */
void
db_read_bytes(vaddr_t addr, size_t size, char *data)
{
	char	*src;

	src = (char *)addr;
	while (size-- > 0)
		*data++ = *src++;
}

/*
 * Write bytes somewhere in the kernel text.  Make the text
 * pages writable temporarily.
 */
static void
db_write_text(vaddr_t addr, size_t size, char *data)
{
	vaddr_t pgva;
	size_t limit;
	uint32_t bits;
	char *dst;

	if (size == 0)
		return;

	dst = (char *)addr;

	do {
		/*
		 * Get the PTE for the page.
		 */
		bits = pmap_pte_bits(addr);

		if ((bits & PG_V) == 0) {
			printf(" address %p not a valid page\n", dst);
			return;
		}

		/*
		 * Get the VA for the page.
		 */
		if (bits & PG_PS) {
			if (cpu_pae)
				pgva = (vaddr_t)dst & PG_LGFRAME_PAE;
			else
				pgva = (vaddr_t)dst & PG_LGFRAME;
		 } else
			pgva = trunc_page((vaddr_t)dst);

		/*
		 * Compute number of bytes that can be written
		 * with this mapping and subtract it from the
		 * total size.
		 */
#ifdef NBPD_L2
		if (bits & PG_PS)
			limit = NBPD_L2 - ((vaddr_t)dst & (NBPD_L2 - 1));
		else
#endif
			limit = PAGE_SIZE - ((vaddr_t)dst & PGOFSET);
		if (limit > size)
			limit = size;
		size -= limit;

		pmap_update_pg(pgva);
		pmap_pte_setbits(addr, PG_RW, 0);

		/*
		 * Page is now writable.  Do as much access as we
		 * can in this page.
		 */
		for (; limit > 0; limit--)
			*dst++ = *data++;

		/*
		 * Restore the old PTE.
		 */
		pmap_update_pg(pgva);
		pmap_pte_setbits(addr, bits, PG_RW);
		
	} while (size != 0);
}

/*
 * Write bytes to kernel address space for debugger.
 */
void
db_write_bytes(vaddr_t addr, size_t size, char *data)
{
	char	*dst;
	extern char	etext;

	if (addr >= VM_MIN_KERNEL_ADDRESS &&
	    addr < (vaddr_t)&etext) {
		db_write_text(addr, size, data);
		return;
	}

	dst = (char *)addr;

	while (size-- > 0)
		*dst++ = *data++;
}
@


1.15
log
@
Bring PAE code back to life, in a different form. This diff (via bluhm then
to deraadt, then myself) brings the PAE pmap on i386 (not touched in any
significant way for years) closer to the current non-PAE pmap and allows
us to take a big next step toward better i386 W^X in the kernel (similar to
what we did a few months ago on amd64). Unlike the original PAE pmap, this
diff will not be supporting > 4GB physical memory on i386 - this effort is
specifically geared toward providing W^X (via NX) only.

There still seems to be a bug removing certain pmap entries when PAE is
enabled, so I'm leaving PAE mode disabled for the moment until we can
figure out what is going on, but with this diff in the tree hopefully
others can help.

The pmap functions now operate through function pointers, due to the need
to support both non-PAE and PAE forms. My unscientific testing showed
less than 0.3% (a third of a percent) slowdown with this approach during
a base build.

Discussed for months with guenther, kettenis, and deraadt.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_memrw.c,v 1.14 2014/09/14 14:17:23 jsg Exp $	*/
d132 1
a132 1
		pmap_pte_setbits(addr, 0, bits);
@


1.14
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_memrw.c,v 1.13 2011/04/23 22:16:13 deraadt Exp $	*/
d46 5
a70 1
	pt_entry_t *pte, oldpte, tmppte;
d73 1
d85 1
a85 2
		pte = kvtopte(addr);
		oldpte = *pte;
d87 1
a87 1
		if ((oldpte & PG_V) == 0) {
d95 6
a100 3
		if (oldpte & PG_PS)
			pgva = (vaddr_t)dst & PG_LGFRAME;
		else
d109 1
a109 1
		if (oldpte & PG_PS)
a117 2
		tmppte = (oldpte & ~PG_KR) | PG_KW;
		*pte = tmppte;
d119 1
a130 2
		*pte = oldpte;

d132 1
@


1.13
log
@Don't leave the kernel code/rodata writeable for DDB.  Make ddb enable
writes in the pte momentarily.  Modified the code stolen from amd64.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: db_memrw.c,v 1.12 2007/02/20 21:15:01 tom Exp $	*/
a37 1
#include <sys/proc.h>
@


1.12
log
@Revert PAE pmap for now, until the strange bug is found.  This stops
the freezes many of us are seeing (especially on amd64 machines running
OpenBSD/i386).

Much testing by nick@@ (as always - thanks!), hugh@@, ian@@, kettenis@@
and Sam Smith (s (at) msmith (dot) net).

Requested by, input from, and ok deraadt@@  ok art@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_memrw.c,v 1.8 2005/11/22 12:52:55 mickey Exp $	*/
d61 73
a139 6

	pt_entry_t *ptep0 = 0;
	pt_entry_t	oldmap0 = { 0 };
	vaddr_t	addr1;
	pt_entry_t *ptep1 = 0;
	pt_entry_t	oldmap1 = { 0 };
d144 2
a145 12
		ptep0 = kvtopte(addr);
		oldmap0 = *ptep0;
		*(int *)ptep0 |= /* INTEL_PTE_WRITE */ PG_RW;

		addr1 = trunc_page(addr + size - 1);
		if (trunc_page(addr) != addr1) {
			/* data crosses a page boundary */
			ptep1 = kvtopte(addr1);
			oldmap1 = *ptep1;
			*(int *)ptep1 |= /* INTEL_PTE_WRITE */ PG_RW;
		}
		tlbflush();
a151 7

	if (ptep0) {
		*ptep0 = oldmap0;
		if (ptep1)
			*ptep1 = oldmap1;
		tlbflush();
	}
@


1.11
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: db_memrw.c,v 1.10 2006/05/10 13:45:37 mickey Exp $	*/
d66 7
a73 3
	u_int32_t bits, bits1;
	vaddr_t	addr1 = 0;
	char	*dst;
d77 3
a79 1
		bits = pmap_pte_setbits(addr, PG_RW, 0) & PG_RW;
d82 1
a82 1
		if (trunc_page(addr) != addr1)
d84 4
a87 1
			bits1 = pmap_pte_setbits(addr1, PG_RW, 0) & PG_RW;
d96 4
a99 4
	if (addr1) {
		pmap_pte_setbits(addr, 0, bits ^ PG_RW);
		if (trunc_page(addr) != addr1)
			pmap_pte_setbits(addr1, 0, bits1 ^ PG_RW);
@


1.10
log
@in db_write_bytes correctly restore pte prot after write; this is not a big deal as kernel .text is not writable anyway; found by aaron
@
text
@d1 1
a1 1
/*	$OpenBSD: db_memrw.c,v 1.9 2006/04/27 15:37:50 mickey Exp $	*/
d4 1
a4 1
/* 
d8 1
a8 1
 * 
d14 1
a14 1
 * 
d18 1
a18 1
 * 
d20 1
a20 1
 * 
d25 1
a25 1
 * 
@


1.9
log
@implement separate PAE pmap that allows access to 64g of physmem
if supported by the cpu(s). currently not enabled by default and
not compiled into ramdisks. this grows paddr_t to 64bit but yet
leaves bus_addr_t at 32bits. measures are taken to favour dmaable
memory allocation from below 4g line such that buffer cache is
already allocated form below, pool backend allocator prefers lower
memory and then finally bounce buffers are used as last resort.
PAE is engaged only if global variable cpu_pae is manually set
to non-zero and there is physical memory present above 4g.
simplify pcibios address math to use u_long as we always will
be in the 32bit space.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_memrw.c,v 1.8 2005/11/22 12:52:55 mickey Exp $	*/
d88 3
a90 3
		pmap_pte_setbits(addr, 0, bits);
		if (bits1)
			pmap_pte_setbits(addr1, 0, bits1);
@


1.8
log
@do not manually inline kvtopte() macro; no func change
@
text
@d1 1
a1 1
/*	$OpenBSD: db_memrw.c,v 1.7 2005/11/13 14:23:26 martin Exp $	*/
d66 3
a70 7
	pt_entry_t *ptep0 = 0;
	pt_entry_t	oldmap0 = { 0 };
	vaddr_t	addr1;
	pt_entry_t *ptep1 = 0;
	pt_entry_t	oldmap1 = { 0 };
	extern char	etext;

d73 1
a73 3
		ptep0 = kvtopte(addr);
		oldmap0 = *ptep0;
		*(int *)ptep0 |= /* INTEL_PTE_WRITE */ PG_RW;
d76 1
a76 1
		if (trunc_page(addr) != addr1) {
d78 1
a78 4
			ptep1 = kvtopte(addr1);
			oldmap1 = *ptep1;
			*(int *)ptep1 |= /* INTEL_PTE_WRITE */ PG_RW;
		}
d87 4
a90 4
	if (ptep0) {
		*ptep0 = oldmap0;
		if (ptep1)
			*ptep1 = oldmap1;
@


1.7
log
@convert more MD macros to their MI counterparts, this time
i386_round_page(), i386_trunc_page(), i386_btop() and i386_ptob()
@
text
@d1 1
a1 1
/*	$OpenBSD: db_memrw.c,v 1.6 2003/01/16 04:15:17 art Exp $	*/
d77 1
a77 1
		ptep0 = PTE_BASE + atop(addr);
d84 1
a84 1
			ptep1 = PTE_BASE + atop(addr1);
@


1.6
log
@Getting rid of vm_offset_t
@
text
@d1 1
a1 1
/*	$OpenBSD: db_memrw.c,v 1.5 2001/11/28 15:02:58 art Exp $	*/
d77 1
a77 1
		ptep0 = PTE_BASE + i386_btop(addr);
d81 2
a82 2
		addr1 = i386_trunc_page(addr + size - 1);
		if (i386_trunc_page(addr) != addr1) {
d84 1
a84 1
			ptep1 = PTE_BASE + i386_btop(addr1);
@


1.5
log
@Don't use pmap_update when we mean tlbflush. make pmap_update into a noop.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_memrw.c,v 1.4 2001/11/06 19:53:14 miod Exp $	*/
d51 1
a51 4
db_read_bytes(addr, size, data)
	vm_offset_t	addr;
	register size_t	size;
	register char	*data;
d53 1
a53 1
	register char	*src;
d64 1
a64 4
db_write_bytes(addr, size, data)
	vm_offset_t	addr;
	register size_t	size;
	register char	*data;
d66 1
a66 1
	register char	*dst;
d68 1
a68 1
	register pt_entry_t *ptep0 = 0;
d70 2
a71 2
	vm_offset_t	addr1;
	register pt_entry_t *ptep1 = 0;
d76 1
a76 1
	    addr < (vm_offset_t)&etext) {
@


1.5.2.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 4
a54 1
db_read_bytes(vaddr_t addr, size_t size, char *data)
d56 1
a56 1
	char	*src;
d67 4
a70 1
db_write_bytes(vaddr_t addr, size_t size, char *data)
d72 1
a72 1
	char	*dst;
d74 1
a74 1
	pt_entry_t *ptep0 = 0;
d76 2
a77 2
	vaddr_t	addr1;
	pt_entry_t *ptep1 = 0;
d82 1
a82 1
	    addr < (vaddr_t)&etext) {
@


1.4
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_memrw.c,v 1.3 2001/05/05 23:25:35 art Exp $	*/
d94 1
a94 1
		pmap_update();
d106 1
a106 1
		pmap_update();
@


1.3
log
@PMAP_NEW and UVM are no longer optional on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_memrw.c,v 1.2 2001/03/22 23:36:51 niklas Exp $	*/
d41 1
a41 1
#include <vm/vm.h>
@


1.2
log
@Merge in NetBSD's PMAP_NEW, still disabled
@
text
@d1 1
a1 1
/*	$OpenBSD: db_memrw.c,v 1.1 2000/07/05 14:26:34 hugh Exp $	*/
a62 4
#ifndef PMAP_NEW
pt_entry_t *pmap_pte __P((pmap_t, vm_offset_t));
#endif

a82 1
#ifdef PMAP_NEW
a83 3
#else
		ptep0 = pmap_pte(pmap_kernel(), addr);
#endif
a89 1
#ifdef PMAP_NEW
a90 3
#else
			ptep1 = pmap_pte(pmap_kernel(), addr1);
#endif
@


1.2.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_memrw.c,v 1.2 2001/03/22 23:36:51 niklas Exp $	*/
@


1.2.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_memrw.c,v 1.2.2.1 2001/04/18 16:07:15 niklas Exp $	*/
d63 4
d87 1
d89 3
d98 1
d100 3
@


1.2.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
#include <uvm/uvm_extern.h>
@


1.2.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_memrw.c,v 1.2.2.3 2001/11/13 21:00:51 niklas Exp $	*/
d94 1
a94 1
		tlbflush();
d106 1
a106 1
		tlbflush();
@


1.2.2.5
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 4
a54 1
db_read_bytes(vaddr_t addr, size_t size, char *data)
d56 1
a56 1
	char	*src;
d67 4
a70 1
db_write_bytes(vaddr_t addr, size_t size, char *data)
d72 1
a72 1
	char	*dst;
d74 1
a74 1
	pt_entry_t *ptep0 = 0;
d76 2
a77 2
	vaddr_t	addr1;
	pt_entry_t *ptep1 = 0;
d82 1
a82 1
	    addr < (vaddr_t)&etext) {
@


1.1
log
@Decouple memory access functions from db_interface.c so they can be
shared with upcoming KGDB. As per NetBSD.
Ok'd by niklas.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 1
d65 1
d87 3
d91 1
d98 3
d102 1
@

