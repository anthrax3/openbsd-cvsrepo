head	1.128;
access;
symbols
	OPENBSD_6_1_BASE:1.128
	OPENBSD_6_0:1.125.0.2
	OPENBSD_6_0_BASE:1.125
	OPENBSD_5_9:1.123.0.2
	OPENBSD_5_9_BASE:1.123
	OPENBSD_5_8:1.123.0.4
	OPENBSD_5_8_BASE:1.123
	OPENBSD_5_7:1.120.0.2
	OPENBSD_5_7_BASE:1.120
	OPENBSD_5_6:1.117.0.4
	OPENBSD_5_6_BASE:1.117
	OPENBSD_5_5:1.111.0.4
	OPENBSD_5_5_BASE:1.111
	OPENBSD_5_4:1.108.0.2
	OPENBSD_5_4_BASE:1.108
	OPENBSD_5_3:1.107.0.2
	OPENBSD_5_3_BASE:1.107
	OPENBSD_5_2:1.102.0.2
	OPENBSD_5_2_BASE:1.102
	OPENBSD_5_1_BASE:1.101
	OPENBSD_5_1:1.101.0.2
	OPENBSD_5_0:1.100.0.2
	OPENBSD_5_0_BASE:1.100
	OPENBSD_4_9:1.94.0.4
	OPENBSD_4_9_BASE:1.94
	OPENBSD_4_8:1.94.0.2
	OPENBSD_4_8_BASE:1.94
	OPENBSD_4_7:1.88.0.2
	OPENBSD_4_7_BASE:1.88
	OPENBSD_4_6:1.87.0.8
	OPENBSD_4_6_BASE:1.87
	OPENBSD_4_5:1.87.0.4
	OPENBSD_4_5_BASE:1.87
	OPENBSD_4_4:1.87.0.2
	OPENBSD_4_4_BASE:1.87
	OPENBSD_4_3:1.86.0.2
	OPENBSD_4_3_BASE:1.86
	OPENBSD_4_2:1.85.0.2
	OPENBSD_4_2_BASE:1.85
	OPENBSD_4_1:1.81.0.2
	OPENBSD_4_1_BASE:1.81
	OPENBSD_4_0:1.77.0.2
	OPENBSD_4_0_BASE:1.77
	OPENBSD_3_9:1.72.0.2
	OPENBSD_3_9_BASE:1.72
	OPENBSD_3_8:1.69.0.2
	OPENBSD_3_8_BASE:1.69
	OPENBSD_3_7:1.67.0.2
	OPENBSD_3_7_BASE:1.67
	OPENBSD_3_6:1.66.0.2
	OPENBSD_3_6_BASE:1.66
	SMP_SYNC_A:1.62
	SMP_SYNC_B:1.62
	OPENBSD_3_5:1.61.0.4
	OPENBSD_3_5_BASE:1.61
	OPENBSD_3_4:1.61.0.2
	OPENBSD_3_4_BASE:1.61
	UBC_SYNC_A:1.57
	OPENBSD_3_3:1.53.0.2
	OPENBSD_3_3_BASE:1.53
	OPENBSD_3_2:1.50.0.2
	OPENBSD_3_2_BASE:1.50
	OPENBSD_3_1:1.49.0.2
	OPENBSD_3_1_BASE:1.49
	UBC_SYNC_B:1.50
	UBC:1.47.0.2
	UBC_BASE:1.47
	OPENBSD_3_0:1.43.0.2
	OPENBSD_3_0_BASE:1.43
	OPENBSD_2_9:1.37.0.2
	OPENBSD_2_9_BASE:1.37
	OPENBSD_2_8:1.33.0.2
	OPENBSD_2_8_BASE:1.33
	OPENBSD_2_7:1.31.0.8
	OPENBSD_2_7_BASE:1.31
	SMP:1.31.0.6
	SMP_BASE:1.31
	kame_19991208:1.31
	OPENBSD_2_6:1.31.0.4
	OPENBSD_2_6_BASE:1.31
	OPENBSD_2_5:1.31.0.2
	OPENBSD_2_5_BASE:1.31
	OPENBSD_2_4:1.27.0.2
	OPENBSD_2_4_BASE:1.27
	OPENBSD_2_3:1.26.0.2
	OPENBSD_2_3_BASE:1.26
	OPENBSD_2_2:1.25.0.2
	OPENBSD_2_2_BASE:1.25
	OPENBSD_2_1:1.22.0.2
	OPENBSD_2_1_BASE:1.22
	OPENBSD_2_0:1.11.0.2
	OPENBSD_2_0_BASE:1.11
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.128
date	2017.03.09.20.31.41;	author guenther;	state Exp;
branches;
next	1.127;
commitid	8BXUnLl9G8KoqE1Q;

1.127
date	2017.03.03.20.49.47;	author bluhm;	state Exp;
branches;
next	1.126;
commitid	HvXIPFg1fj3hCUTx;

1.126
date	2016.10.08.05.49.08;	author guenther;	state Exp;
branches;
next	1.125;
commitid	z63v1DilayzHcfkw;

1.125
date	2016.02.28.15.46.18;	author naddy;	state Exp;
branches;
next	1.124;
commitid	iOuZImHZRAr7Hvd6;

1.124
date	2016.02.27.13.08.07;	author mpi;	state Exp;
branches;
next	1.123;
commitid	hnv9KfQtxhCytAnd;

1.123
date	2015.06.28.01.11.27;	author guenther;	state Exp;
branches;
next	1.122;
commitid	pmt8zLCdl4eF6ZNV;

1.122
date	2015.04.24.12.52.38;	author kettenis;	state Exp;
branches;
next	1.121;
commitid	ldM9NygmNatsq6n7;

1.121
date	2015.04.18.05.14.05;	author guenther;	state Exp;
branches;
next	1.120;
commitid	omyqf8P2CTirfWNm;

1.120
date	2015.01.11.19.34.52;	author guenther;	state Exp;
branches;
next	1.119;
commitid	mYYjUBRhGJS1wXIo;

1.119
date	2014.12.02.18.13.10;	author tedu;	state Exp;
branches;
next	1.118;
commitid	ZYUxNRICiD9sC1vn;

1.118
date	2014.11.16.12.30.57;	author deraadt;	state Exp;
branches;
next	1.117;
commitid	yv0ECmCdICvq576h;

1.117
date	2014.07.09.07.29.00;	author guenther;	state Exp;
branches;
next	1.116;
commitid	e4lHxUW3rh9EKH2Z;

1.116
date	2014.05.11.00.12.44;	author guenther;	state Exp;
branches;
next	1.115;

1.115
date	2014.05.10.05.33.00;	author guenther;	state Exp;
branches;
next	1.114;

1.114
date	2014.04.18.11.51.17;	author guenther;	state Exp;
branches;
next	1.113;

1.113
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.112;

1.112
date	2014.03.07.07.47.14;	author gerhard;	state Exp;
branches;
next	1.111;

1.111
date	2014.02.13.23.11.06;	author kettenis;	state Exp;
branches;
next	1.110;

1.110
date	2013.12.22.11.00.13;	author sf;	state Exp;
branches;
next	1.109;

1.109
date	2013.11.03.13.52.44;	author pirofti;	state Exp;
branches;
next	1.108;

1.108
date	2013.04.09.01.50.02;	author guenther;	state Exp;
branches;
next	1.107;

1.107
date	2012.12.31.06.44.11;	author guenther;	state Exp;
branches;
next	1.106;

1.106
date	2012.10.31.03.30.22;	author jsg;	state Exp;
branches;
next	1.105;

1.105
date	2012.10.09.04.40.36;	author jsg;	state Exp;
branches;
next	1.104;

1.104
date	2012.09.06.20.20.30;	author tedu;	state Exp;
branches;
next	1.103;

1.103
date	2012.08.07.05.16.53;	author guenther;	state Exp;
branches;
next	1.102;

1.102
date	2012.04.11.14.38.55;	author mikeb;	state Exp;
branches;
next	1.101;

1.101
date	2011.11.16.20.50.18;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.99;

1.99
date	2011.07.07.18.11.23;	author art;	state Exp;
branches;
next	1.98;

1.98
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.97;

1.97
date	2011.07.05.00.30.10;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2011.04.05.12.50.15;	author guenther;	state Exp;
branches;
next	1.95;

1.95
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.94;

1.94
date	2010.07.20.00.16.39;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2010.07.14.00.15.27;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2010.07.05.22.20.22;	author tedu;	state Exp;
branches;
next	1.91;

1.91
date	2010.07.01.19.47.07;	author tedu;	state Exp;
branches;
next	1.90;

1.90
date	2010.07.01.17.30.27;	author tedu;	state Exp;
branches;
next	1.89;

1.89
date	2010.05.09.12.03.16;	author kettenis;	state Exp;
branches;
next	1.88;

1.88
date	2009.10.03.21.51.00;	author kettenis;	state Exp;
branches;
next	1.87;

1.87
date	2008.04.09.16.49.17;	author thib;	state Exp;
branches
	1.87.2.1
	1.87.4.1
	1.87.8.1;
next	1.86;

1.86
date	2007.10.10.04.36.11;	author ray;	state Exp;
branches;
next	1.85;

1.85
date	2007.06.26.13.39.02;	author tom;	state Exp;
branches;
next	1.84;

1.84
date	2007.05.29.18.47.51;	author tom;	state Exp;
branches;
next	1.83;

1.83
date	2007.05.11.10.06.55;	author pedro;	state Exp;
branches;
next	1.82;

1.82
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.81;

1.81
date	2007.01.09.08.43.25;	author art;	state Exp;
branches;
next	1.80;

1.80
date	2006.12.24.20.30.35;	author miod;	state Exp;
branches;
next	1.79;

1.79
date	2006.12.24.20.29.19;	author miod;	state Exp;
branches;
next	1.78;

1.78
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.77;

1.77
date	2006.08.22.20.09.25;	author mickey;	state Exp;
branches;
next	1.76;

1.76
date	2006.07.25.19.16.51;	author kettenis;	state Exp;
branches;
next	1.75;

1.75
date	2006.06.13.03.01.04;	author gwk;	state Exp;
branches;
next	1.74;

1.74
date	2006.05.11.13.21.12;	author mickey;	state Exp;
branches;
next	1.73;

1.73
date	2006.04.15.02.52.40;	author weingart;	state Exp;
branches;
next	1.72;

1.72
date	2005.10.26.20.32.59;	author marco;	state Exp;
branches;
next	1.71;

1.71
date	2005.09.15.21.14.27;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2005.09.15.21.09.29;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2005.05.29.03.20.38;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2005.05.25.23.17.47;	author niklas;	state Exp;
branches;
next	1.67;

1.67
date	2004.12.06.20.12.24;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2004.09.07.10.12.35;	author niklas;	state Exp;
branches;
next	1.65;

1.65
date	2004.08.14.00.14.11;	author niklas;	state Exp;
branches;
next	1.64;

1.64
date	2004.07.02.16.29.55;	author niklas;	state Exp;
branches;
next	1.63;

1.63
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.62;

1.62
date	2004.04.15.00.22.42;	author tedu;	state Exp;
branches;
next	1.61;

1.61
date	2003.07.29.18.24.36;	author mickey;	state Exp;
branches;
next	1.60;

1.60
date	2003.07.28.19.59.18;	author jason;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.24.22.45.33;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.02.23.27.47;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2003.05.13.03.49.04;	author art;	state Exp;
branches;
next	1.56;

1.56
date	2003.05.04.15.56.34;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	2003.05.04.04.58.16;	author drahn;	state Exp;
branches;
next	1.54;

1.54
date	2003.05.02.21.07.48;	author mickey;	state Exp;
branches;
next	1.53;

1.53
date	2003.01.16.04.15.17;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2003.01.09.22.27.09;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2002.12.12.07.41.45;	author ish;	state Exp;
branches;
next	1.50;

1.50
date	2002.05.16.16.16.52;	author provos;	state Exp;
branches;
next	1.49;

1.49
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2002.02.21.23.27.12;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2001.12.03.14.29.24;	author mpech;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2001.11.28.16.13.28;	author art;	state Exp;
branches;
next	1.45;

1.45
date	2001.11.28.13.47.38;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.06.18.41.09;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2001.09.20.11.57.18;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2001.09.13.14.37.52;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2001.08.12.21.51.03;	author mickey;	state Exp;
branches;
next	1.40;

1.40
date	2001.05.05.23.25.42;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2001.05.05.21.26.37;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.05.20.56.38;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2001.04.02.21.43.10;	author niklas;	state Exp;
branches;
next	1.36;

1.36
date	2001.03.22.23.36.51;	author niklas;	state Exp;
branches;
next	1.35;

1.35
date	2001.01.24.09.37.59;	author hugh;	state Exp;
branches;
next	1.34;

1.34
date	2000.11.10.18.15.38;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2000.06.26.22.45.53;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2000.06.08.22.25.19;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	99.03.21.03.30.01;	author weingart;	state Exp;
branches
	1.31.6.1;
next	1.30;

1.30
date	99.02.26.04.42.14;	author art;	state Exp;
branches;
next	1.29;

1.29
date	99.02.12.19.40.12;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	99.02.10.08.07.20;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	98.08.20.19.46.35;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	98.02.22.21.35.28;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	97.09.08.22.51.36;	author downsj;	state Exp;
branches;
next	1.24;

1.24
date	97.07.25.01.46.11;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	97.07.25.01.34.00;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	97.04.05.21.24.48;	author flipk;	state Exp;
branches;
next	1.21;

1.21
date	97.04.04.16.14.09;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	97.02.09.03.53.58;	author tholo;	state Exp;
branches;
next	1.19;

1.19
date	97.02.08.23.23.57;	author tholo;	state Exp;
branches;
next	1.18;

1.18
date	97.02.04.17.04.37;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.02.04.02.16.51;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.02.03.17.35.09;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.02.01.21.53.29;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.01.27.22.48.01;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.01.18.15.17.38;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	96.10.17.13.36.45;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.08.27.10.46.52;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	96.05.10.12.44.49;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.07.07.21.57;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.04.09.24.07;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.16.40;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.03.19.21.09.23;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.02.28.14.38.46;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.01.12.16.45.09;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.11.17.59.04;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.07.06;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.34;	author deraadt;	state Exp;
branches;
next	;

1.31.6.1
date	2001.04.18.16.07.24;	author niklas;	state Exp;
branches;
next	1.31.6.2;

1.31.6.2
date	2001.07.04.10.16.43;	author niklas;	state Exp;
branches;
next	1.31.6.3;

1.31.6.3
date	2001.07.14.10.02.31;	author ho;	state Exp;
branches;
next	1.31.6.4;

1.31.6.4
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.31.6.5;

1.31.6.5
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.31.6.6;

1.31.6.6
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.31.6.7;

1.31.6.7
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.31.6.8;

1.31.6.8
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.31.6.9;

1.31.6.9
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.31.6.10;

1.31.6.10
date	2003.05.13.19.42.08;	author ho;	state Exp;
branches;
next	1.31.6.11;

1.31.6.11
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.31.6.12;

1.31.6.12
date	2003.05.16.00.29.39;	author niklas;	state Exp;
branches;
next	1.31.6.13;

1.31.6.13
date	2003.05.18.17.41.16;	author niklas;	state Exp;
branches;
next	1.31.6.14;

1.31.6.14
date	2003.06.07.11.11.37;	author ho;	state Exp;
branches;
next	1.31.6.15;

1.31.6.15
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	1.31.6.16;

1.31.6.16
date	2004.04.15.15.45.47;	author niklas;	state Exp;
branches;
next	1.31.6.17;

1.31.6.17
date	2004.06.05.23.09.00;	author niklas;	state Exp;
branches;
next	1.31.6.18;

1.31.6.18
date	2004.06.10.11.40.24;	author niklas;	state Exp;
branches;
next	;

1.47.2.1
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	1.47.2.2;

1.47.2.2
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;

1.87.2.1
date	2009.10.05.00.36.05;	author sthen;	state Exp;
branches;
next	;

1.87.4.1
date	2009.10.05.00.36.33;	author sthen;	state Exp;
branches;
next	;

1.87.8.1
date	2009.10.05.00.37.54;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.128
log
@There are no compat emulations left so we never do errno mapping:
eliminate the last use of e_errno.

ok tom@@ mpi@@ kettenis@@ visa@@
@
text
@/*	$OpenBSD: trap.c,v 1.127 2017/03/03 20:49:47 bluhm Exp $	*/
/*	$NetBSD: trap.c,v 1.95 1996/05/05 06:50:02 mycroft Exp $	*/

/*-
 * Copyright (c) 1995 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the University of Utah, and William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)trap.c	7.4 (Berkeley) 5/13/91
 */

/*
 * 386 Trap and System call handling
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/user.h>
#include <sys/acct.h>
#include <sys/kernel.h>
#include <sys/signal.h>
#include <sys/syscall.h>
#include <sys/syscall_mi.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/trap.h>
#ifdef DDB
#include <machine/db_machdep.h>
#endif

#ifdef KGDB
#include <sys/kgdb.h>
#endif

#include <sys/exec.h>
#ifdef KVM86
#include <machine/kvm86.h>
#define KVM86MODE (kvm86_incall)
#endif

#include "isa.h"
#include "npx.h"

void trap(struct trapframe *);
void ast(struct trapframe *);
void syscall(struct trapframe *);

char	*trap_type[] = {
	"privileged instruction fault",		/*  0 T_PRIVINFLT */
	"breakpoint trap",			/*  1 T_BPTFLT */
	"arithmetic trap",			/*  2 T_ARITHTRAP */
	"reserved trap",			/*  3 T_RESERVED */
	"protection fault",			/*  4 T_PROTFLT */
	"trace trap",				/*  5 T_TRCTRAP */
	"page fault",				/*  6 T_PAGEFLT */
	"alignment fault",			/*  7 T_ALIGNFLT */
	"integer divide fault",			/*  8 T_DIVIDE */
	"non-maskable interrupt",		/*  9 T_NMI */
	"overflow trap",			/* 10 T_OFLOW */
	"bounds check fault",			/* 11 T_BOUND */
	"FPU not available fault",		/* 12 T_DNA */
	"double fault",				/* 13 T_DOUBLEFLT */
	"FPU operand fetch fault",		/* 14 T_FPOPFLT (![P]Pro) */
	"invalid TSS fault",			/* 15 T_TSSFLT */
	"segment not present fault",		/* 16 T_SEGNPFLT */
	"stack fault",				/* 17 T_STKFLT */
	"machine check",			/* 18 T_MACHK ([P]Pro) */
	"SIMD FP fault",			/* 19 T_XFTRAP */
};
int	trap_types = sizeof trap_type / sizeof trap_type[0];

#ifdef DEBUG
int	trapdebug = 0;
#endif

/*
 * trap(frame):
 *	Exception, fault, and trap interface to BSD kernel. This
 * common code is called from assembly language IDT gate entry
 * routines that prepare a suitable stack frame, and restore this
 * frame after the exception has been processed.
 */
void
trap(struct trapframe *frame)
{
	struct proc *p = curproc;
	int type = frame->tf_trapno;
	struct pcb *pcb = NULL;
	extern char resume_iret[], resume_pop_ds[], resume_pop_es[],
	    resume_pop_fs[], resume_pop_gs[];
	struct trapframe *vframe;
	int resume;
	vm_prot_t vftype, ftype;
	union sigval sv;
	caddr_t onfault;
	uint32_t cr2;

	uvmexp.traps++;

	/* SIGSEGV and SIGBUS need this */
	if (frame->tf_err & PGEX_W) {
		vftype = PROT_WRITE;
		ftype = PROT_READ | PROT_WRITE;
	} else if (frame->tf_err & PGEX_I) {
		ftype = vftype = PROT_EXEC;
	} else
		ftype = vftype = PROT_READ;

#ifdef DEBUG
	if (trapdebug) {
		printf("trap %d code %x eip %x cs %x eflags %x cr2 %x cpl %x\n",
		    frame->tf_trapno, frame->tf_err, frame->tf_eip,
		    frame->tf_cs, frame->tf_eflags, rcr2(), lapic_tpr);
		printf("curproc %p\n", curproc);
	}
#endif

	if (!KERNELMODE(frame->tf_cs, frame->tf_eflags)) {
		type |= T_USER;
		p->p_md.md_regs = frame;
		refreshcreds(p);
	}

	switch (type) {

	/* trace trap */
	case T_TRCTRAP:
#if !(defined(DDB) || defined(KGDB))
		return;	/* Just return if no kernel debugger */
#endif
		/* FALLTHROUGH */

	default:
	we_re_toast:
#ifdef KGDB
		if (kgdb_trap(type, frame))
			return;
		else {
			/*
			 * If this is a breakpoint, don't panic
			 * if we're not connected.
			 */
			if (type == T_BPTFLT) {
				printf("kgdb: ignored %s\n", trap_type[type]);
				return;
			}
		}
#endif

#ifdef DDB
		if (db_ktrap(type, 0, frame))
			return;
#endif
		if (frame->tf_trapno < trap_types)
			printf("fatal %s (%d)", trap_type[frame->tf_trapno],
				frame->tf_trapno);
		else
			printf("unknown trap %d", frame->tf_trapno);
		printf(" in %s mode\n", (type & T_USER) ? "user" : "supervisor");
		printf("trap type %d code %x eip %x cs %x eflags %x cr2 %x cpl %x\n",
		    type, frame->tf_err, frame->tf_eip, frame->tf_cs, frame->tf_eflags, rcr2(), lapic_tpr);

		panic("trap type %d, code=%x, pc=%x",
		    type, frame->tf_err, frame->tf_eip);
		/*NOTREACHED*/

	case T_PROTFLT:
#ifdef KVM86
		if (KVM86MODE) {
			kvm86_gpfault(frame);
			return;
		}
#endif
	case T_SEGNPFLT:
	case T_ALIGNFLT:
		/* Check for copyin/copyout fault. */
		if (p && p->p_addr) {
			pcb = &p->p_addr->u_pcb;
			if (pcb->pcb_onfault != 0) {
			copyfault:
				frame->tf_eip = (int)pcb->pcb_onfault;
				return;
			}
		}

		/*
		 * Check for failure during return to user mode.
		 *
		 * We do this by looking at the instruction we faulted on.  The
		 * specific instructions we recognize only happen when
		 * returning from a trap, syscall, or interrupt.
		 *
		 * XXX
		 * The heuristic used here will currently fail for the case of
		 * one of the 2 pop instructions faulting when returning from a
		 * a fast interrupt.  This should not be possible.  It can be
		 * fixed by rearranging the trap frame so that the stack format
		 * at this point is the same as on exit from a `slow'
		 * interrupt.
		 */
		switch (*(u_char *)frame->tf_eip) {
		case 0xcf:	/* iret */
			vframe = (void *)((int)&frame->tf_esp -
			    offsetof(struct trapframe, tf_eip));
			resume = (int)resume_iret;
			break;
		case 0x1f:	/* popl %ds */
			vframe = (void *)((int)&frame->tf_esp -
			    offsetof(struct trapframe, tf_ds));
			resume = (int)resume_pop_ds;
			break;
		case 0x07:	/* popl %es */
			vframe = (void *)((int)&frame->tf_esp -
			    offsetof(struct trapframe, tf_es));
			resume = (int)resume_pop_es;
			break;
		case 0x0f:	/* 0x0f prefix */
			switch (*(u_char *)(frame->tf_eip + 1)) {
			case 0xa1:		/* popl %fs */
				vframe = (void *)((int)&frame->tf_esp -
				    offsetof(struct trapframe, tf_fs));
				resume = (int)resume_pop_fs;
				break;
			case 0xa9:		/* popl %gs */
				vframe = (void *)((int)&frame->tf_esp -
				    offsetof(struct trapframe, tf_gs));
				resume = (int)resume_pop_gs;
				break;
			default:
				goto we_re_toast;
			}
			break;
		default:
			goto we_re_toast;
		}
		if (KERNELMODE(vframe->tf_cs, vframe->tf_eflags))
			goto we_re_toast;

		frame->tf_eip = resume;
		return;

	case T_PROTFLT|T_USER:		/* protection fault */
		KERNEL_LOCK();
#ifdef VM86
		if (frame->tf_eflags & PSL_VM) {
			vm86_gpfault(p, type & ~T_USER);
			KERNEL_UNLOCK();
			goto out;
		}
#endif
		/* If pmap_exec_fixup does something, let's retry the trap. */
		if (pmap_exec_fixup(&p->p_vmspace->vm_map, frame,
		    &p->p_addr->u_pcb)) {
			KERNEL_UNLOCK();
			goto out;
		}

		sv.sival_int = frame->tf_eip;
		trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, sv);
		KERNEL_UNLOCK();
		goto out;

	case T_TSSFLT|T_USER:
		sv.sival_int = frame->tf_eip;
		KERNEL_LOCK();
		trapsignal(p, SIGBUS, vftype, BUS_OBJERR, sv);
		KERNEL_UNLOCK();
		goto out;

	case T_SEGNPFLT|T_USER:
	case T_STKFLT|T_USER:
		sv.sival_int = frame->tf_eip;
		KERNEL_LOCK();
		trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, sv);
		KERNEL_UNLOCK();
		goto out;

	case T_ALIGNFLT|T_USER:
		sv.sival_int = frame->tf_eip;
		KERNEL_LOCK();
		trapsignal(p, SIGBUS, vftype, BUS_ADRALN, sv);
		KERNEL_UNLOCK();
		goto out;

	case T_PRIVINFLT|T_USER:	/* privileged instruction fault */
		sv.sival_int = frame->tf_eip;
		KERNEL_LOCK();
		trapsignal(p, SIGILL, type &~ T_USER, ILL_PRVOPC, sv);
		KERNEL_UNLOCK();
		goto out;

	case T_FPOPFLT|T_USER:		/* coprocessor operand fault */
		sv.sival_int = frame->tf_eip;
		KERNEL_LOCK();
		trapsignal(p, SIGILL, type &~ T_USER, ILL_COPROC, sv);
		KERNEL_UNLOCK();
		goto out;

	case T_DNA|T_USER: {
		printf("pid %d killed due to lack of floating point\n",
		    p->p_p->ps_pid);
		sv.sival_int = frame->tf_eip;
		KERNEL_LOCK();
		trapsignal(p, SIGKILL, type &~ T_USER, FPE_FLTINV, sv);
		KERNEL_UNLOCK();
		goto out;
	}

	case T_BOUND|T_USER:
		sv.sival_int = frame->tf_eip;
		KERNEL_LOCK();
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_FLTSUB, sv);
		KERNEL_UNLOCK();
		goto out;
	case T_OFLOW|T_USER:
		sv.sival_int = frame->tf_eip;
		KERNEL_LOCK();
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_INTOVF, sv);
		KERNEL_UNLOCK();
		goto out;
	case T_DIVIDE|T_USER:
		sv.sival_int = frame->tf_eip;
		KERNEL_LOCK();
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_INTDIV, sv);
		KERNEL_UNLOCK();
		goto out;

	case T_ARITHTRAP|T_USER:
		sv.sival_int = frame->tf_eip;
		KERNEL_LOCK();
		trapsignal(p, SIGFPE, frame->tf_err, FPE_INTOVF, sv);
		KERNEL_UNLOCK();
		goto out;

	case T_XFTRAP|T_USER:
		npxtrap(frame);
		goto out;

	case T_PAGEFLT:			/* allow page faults in kernel mode */
		if (p == 0 || p->p_addr == 0)
			goto we_re_toast;

		pcb = &p->p_addr->u_pcb;
#if 0
		/* XXX - check only applies to 386's and 486's with WP off */
		if (frame->tf_err & PGEX_P)
			goto we_re_toast;
#endif
		cr2 = rcr2();
		KERNEL_LOCK();
		/* This will only trigger if SMEP is enabled */
		if (cr2 <= VM_MAXUSER_ADDRESS && frame->tf_err & PGEX_I)
			panic("attempt to execute user address %p "
			    "in supervisor mode", (void *)cr2);
		/* This will only trigger if SMAP is enabled */
		if (pcb->pcb_onfault == NULL && cr2 <= VM_MAXUSER_ADDRESS &&
		    frame->tf_err & PGEX_P)
			panic("attempt to access user address %p "
			    "in supervisor mode", (void *)cr2);
		goto faultcommon;

	case T_PAGEFLT|T_USER: {	/* page fault */
		vaddr_t va, fa;
		struct vmspace *vm;
		struct vm_map *map;
		int rv;

		cr2 = rcr2();
		KERNEL_LOCK();
	faultcommon:
		vm = p->p_vmspace;
		if (vm == NULL)
			goto we_re_toast;
		fa = (vaddr_t)cr2;
		va = trunc_page(fa);
		/*
		 * It is only a kernel address space fault iff:
		 *	1. (type & T_USER) == 0  and
		 *	2. pcb_onfault not set or
		 *	3. pcb_onfault set but supervisor space fault
		 * The last can occur during an exec() copyin where the
		 * argument space is lazy-allocated.
		 */
		if (type == T_PAGEFLT && va >= KERNBASE)
			map = kernel_map;
		else
			map = &vm->vm_map;

#ifdef DIAGNOSTIC
		if (map == kernel_map && va == 0) {
			printf("trap: bad kernel access at %lx\n", va);
			goto we_re_toast;
		}
#endif

		if (curcpu()->ci_inatomic == 0 || map == kernel_map) {
			onfault = p->p_addr->u_pcb.pcb_onfault;
			p->p_addr->u_pcb.pcb_onfault = NULL;
			rv = uvm_fault(map, va, 0, ftype);
			p->p_addr->u_pcb.pcb_onfault = onfault;
		} else
			rv = EFAULT;

		if (rv == 0) {
			if (map != kernel_map)
				uvm_grow(p, va);
			if (type == T_PAGEFLT) {
				KERNEL_UNLOCK();
				return;
			}
			KERNEL_UNLOCK();
			goto out;
		}

		if (type == T_PAGEFLT) {
			if (pcb->pcb_onfault != 0) {
				KERNEL_UNLOCK();
				goto copyfault;
			}
			printf("uvm_fault(%p, 0x%lx, 0, %d) -> %x\n",
			    map, va, ftype, rv);
			goto we_re_toast;
		}
		sv.sival_int = fa;
		trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, sv);
		KERNEL_UNLOCK();
		break;
	}

#if 0  /* Should this be left out?  */
#if !defined(DDB) && !defined(KGDB)
	/* XXX need to deal with this when DDB is present, too */
	case T_TRCTRAP: /* kernel trace trap; someone single stepping lcall's */
			/* syscall has to turn off the trace bit itself */
		return;
#endif
#endif

	case T_BPTFLT|T_USER:		/* bpt instruction fault */
		sv.sival_int = rcr2();
		KERNEL_LOCK();
		trapsignal(p, SIGTRAP, type &~ T_USER, TRAP_BRKPT, sv);
		KERNEL_UNLOCK();
		break;
	case T_TRCTRAP|T_USER:		/* trace trap */
		sv.sival_int = rcr2();
		KERNEL_LOCK();
		trapsignal(p, SIGTRAP, type &~ T_USER, TRAP_TRACE, sv);
		KERNEL_UNLOCK();
		break;

#if NISA > 0
	case T_NMI:
	case T_NMI|T_USER:
#if defined(DDB) || defined(KGDB)
		/* NMI can be hooked up to a pushbutton for debugging */
		printf ("NMI ... going to debugger\n");
#ifdef KGDB
		if (kgdb_trap(type, frame))
			return;
#endif
#ifdef DDB
		if (db_ktrap(type, 0, frame))
			return;
#endif
#endif /* DDB || KGDB */
		/* machine/parity/power fail/"kitchen sink" faults */
		if (isa_nmi() == 0)
			return;
		else
			goto we_re_toast;
#endif
	}

	if ((type & T_USER) == 0)
		return;
out:
	userret(p);
}


/*
 * ast(frame):
 *	AST handler.  This is called from assembly language stubs when
 *	returning to userspace after a syscall, trap, or interrupt.
 */
void
ast(struct trapframe *frame)
{
	struct proc *p = curproc;

	uvmexp.traps++;
	KASSERT(!KERNELMODE(frame->tf_cs, frame->tf_eflags));
	p->p_md.md_regs = frame;
	refreshcreds(p);
	uvmexp.softs++;
	mi_ast(p, want_resched);
	userret(p);
}


/*
 * syscall(frame):
 *	System call request from POSIX system call gate interface to kernel.
 */
/*ARGSUSED*/
void
syscall(struct trapframe *frame)
{
	caddr_t params;
	struct sysent *callp;
	struct proc *p;
	int error, nsys;
	register_t code, args[8], rval[2];
#ifdef DIAGNOSTIC
	int ocpl = lapic_tpr;
#endif
	short argsize;

	uvmexp.syscalls++;
#ifdef DIAGNOSTIC
	if (!USERMODE(frame->tf_cs, frame->tf_eflags))
		panic("syscall");
#endif
	p = curproc;
	p->p_md.md_regs = frame;
	code = frame->tf_eax;

	nsys = p->p_p->ps_emul->e_nsysent;
	callp = p->p_p->ps_emul->e_sysent;

	params = (caddr_t)frame->tf_esp + sizeof(int);

#ifdef VM86
	/*
	 * VM86 mode application found our syscall trap gate by accident; let
	 * it get a SIGSYS and have the VM86 handler in the process take care
	 * of it.
	 */
	if (frame->tf_eflags & PSL_VM)
		code = -1;
	else
#endif

	switch (code) {
	case SYS_syscall:
		/*
		 * Code is first argument, followed by actual args.
		 */
		copyin(params, &code, sizeof(int));
		params += sizeof(int);
		break;
	case SYS___syscall:
		/*
		 * Like syscall, but code is a quad, so as to maintain
		 * quad alignment for the rest of the arguments.
		 */
		if (callp != sysent)
			break;
		copyin(params + _QUAD_LOWWORD * sizeof(int), &code, sizeof(int));
		params += sizeof(quad_t);
		break;
	default:
		break;
	}
	if (code < 0 || code >= nsys)
		callp += p->p_p->ps_emul->e_nosys;		/* illegal */
	else
		callp += code;
	argsize = callp->sy_argsize;
	if (argsize && (error = copyin(params, args, argsize)))
		goto bad;

	rval[0] = 0;
	rval[1] = frame->tf_edx;

	error = mi_syscall(p, code, callp, args, rval);

	switch (error) {
	case 0:
		frame->tf_eax = rval[0];
		frame->tf_edx = rval[1];
		frame->tf_eflags &= ~PSL_C;	/* carry bit */
		break;
	case ERESTART:
		/* Back up over the int$80 (2 bytes) that made the syscall */
		frame->tf_eip -= 2;
		break;
	case EJUSTRETURN:
		/* nothing to do */
		break;
	default:
	bad:
		frame->tf_eax = error;
		frame->tf_eflags |= PSL_C;	/* carry bit */
		break;
	}

	mi_syscall_return(p, code, error, rval);

#ifdef DIAGNOSTIC
	if (lapic_tpr != ocpl) {
		printf("WARNING: SPL (0x%x) NOT LOWERED ON "
		    "syscall(0x%lx, 0x%lx, 0x%lx, 0x%lx...) EXIT, PID %d\n",
		    lapic_tpr, code, args[0], args[1], args[2],
		    p->p_p->ps_pid);
		lapic_tpr = ocpl;
	}
#endif
}

void
child_return(void *arg)
{
	struct proc *p = (struct proc *)arg;
	struct trapframe *tf = p->p_md.md_regs;

	tf->tf_eax = 0;
	tf->tf_eflags &= ~PSL_C;

	KERNEL_UNLOCK();

	mi_child_return(p);
}
@


1.127
log
@Whan an amd64 machine got an NMI, the current process in user land
was killed with SIGBUS.  Better drop to ddb regardless wether a
user process is currently scheduled or not.  NMI signals hardware
failure or a debug button.  The code in i386 trap() has always been
that way.  The switch in db_ktrap() must also not depend on the
fact wether kernel or user land is running.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.126 2016/10/08 05:49:08 guenther Exp $	*/
d628 1
a628 4
		if (p->p_p->ps_emul->e_errno && error >= 0 && error <= ELAST)
			frame->tf_eax = p->p_p->ps_emul->e_errno[error];
		else
			frame->tf_eax = error;
@


1.126
log
@Various printf claim to report the PID, so actually report that and not the TID

Build testing assistance from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.125 2016/02/28 15:46:18 naddy Exp $	*/
d486 1
a486 1
#if	NISA > 0
@


1.125
log
@Support for running Linux binaries under emulation is going away.

Remove "option COMPAT_LINUX" and everything directly tied to it from the
kernel and the corresponding man page documentation.

ok visa@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.124 2016/02/27 13:08:07 mpi Exp $	*/
d335 1
a335 1
		    p->p_pid);
d642 2
a643 1
		    lapic_tpr, code, args[0], args[1], args[2], p->p_pid);
@


1.124
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.123 2015/06/28 01:11:27 guenther Exp $	*/
a69 4
#ifdef COMPAT_LINUX
#include <compat/linux/linux_syscall.h>
extern struct emul emul_linux_elf;
#endif
a580 5
#ifdef COMPAT_LINUX
		/* Linux has a special system setup call as number 0 */
		if (p->p_p->ps_emul == &emul_linux_elf)
			break;
#endif
a604 30
#ifdef COMPAT_LINUX
	/* XXX extra if() for every emul type.. */
	if (p->p_p->ps_emul == &emul_linux_elf) {
		/*
		 * Linux passes the args in ebx, ecx, edx, esi, edi, ebp, in
		 * increasing order.
		 */
		switch (argsize) {
		case 24:
			args[5] = frame->tf_ebp;
		case 20:
			args[4] = frame->tf_edi;
		case 16:
			args[3] = frame->tf_esi;
		case 12:
			args[2] = frame->tf_edx;
		case 8:
			args[1] = frame->tf_ecx;
		case 4:
			args[0] = frame->tf_ebx;
		case 0:
			break;
		default:
			panic("linux syscall with weird argument size %d",
			    argsize);
			break;
		}
	}
	else
#endif
@


1.123
log
@Split AST handling from trap() into ast() and get rid of T_ASTFLT

testing by krw@@, and then many via snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.122 2015/04/24 12:52:38 kettenis Exp $	*/
d189 1
a189 1
		if (kdb_trap(type, 0, frame))
d501 1
a501 1
		if (kdb_trap(type, 0, frame))
@


1.122
log
@Enable the NX bit and use it in the PAE pmap code.  PAE is still disabled
while we're chasing at least one remaining bug.

ok mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.121 2015/04/18 05:14:05 guenther Exp $	*/
d83 1
d90 1
a90 1
	"asynchronous system trap",		/*  3 T_ASTFLT */
a106 1
	"reserved trap",			/* 20 T_RESERVED */
a120 1
/*ARGSUSED*/
a336 5
	case T_ASTFLT|T_USER:		/* Allow process switch */
		uvmexp.softs++;
		mi_ast(p, want_resched);
		goto out;

d518 21
@


1.121
log
@i386 and amd64 have only one syscall entry point now, so simply the
EIP/RIP adjustment for ERESTART

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.120 2015/01/11 19:34:52 guenther Exp $	*/
d143 2
@


1.120
log
@LOCKDEBUG is dead; perform the funeral rites

pointed out by Helg (xx404 (at) msn.com)
ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.119 2014/12/02 18:13:10 tedu Exp $	*/
d534 1
a534 1
	int error, opc, nsys;
a547 1
	opc = frame->tf_eip;
d642 2
a643 6
		/*
		 * The offset to adjust the PC by depends on whether we entered
		 * the kernel through the trap or call gate.  We pushed the
		 * size of the instruction into tf_err on entry.
		 */
		frame->tf_eip = opc - frame->tf_err;
@


1.119
log
@delete all the simplelocks. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.118 2014/11/16 12:30:57 deraadt Exp $	*/
a383 5
#ifdef LOCKDEBUG
		/* If we page-fault while in scheduler, we're doomed. */
		if (__mp_lock_held(&sched_lock))
			goto we_re_toast;
#endif
@


1.118
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.117 2014/07/09 07:29:00 guenther Exp $	*/
a385 3
#ifdef notyet
		if (simple_lock_held(&sched_lock))
#else
a386 1
#endif
@


1.117
log
@Fix boot -d.  refreshcreds() should be called when trapping from userspace,
but I flipped the test on i386/amd64, thus breaking kernel traps before
enough proc0 bits were set up.  In theory, this could have resulted in
a NFS read for a page fault being done with a process's old credentials.

pointed out by Patrick Wildt of bitrig
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.116 2014/05/11 00:12:44 guenther Exp $	*/
d141 2
a142 2
		vftype = VM_PROT_WRITE;
		ftype = VM_PROT_READ | VM_PROT_WRITE;
d144 1
a144 1
		ftype = vftype = VM_PROT_READ;
@


1.116
log
@Move the increment of uvmexp.softs back to the caller of mi_ast():
it needs to be done atomicly on some MP archs and we don't have
atomic_add_int() everywhere yet.  Also, mi_ast() was meant to be inline.

noted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.115 2014/05/10 05:33:00 guenther Exp $	*/
a157 1
	} else if (type != T_NMI)
d159 1
@


1.115
log
@Factor out the common ast bits into mi_ast()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.114 2014/04/18 11:51:17 guenther Exp $	*/
d337 1
@


1.114
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.113 2014/03/26 05:23:42 guenther Exp $	*/
d337 1
a337 8
		uvmexp.softs++;
		if (p->p_flag & P_OWEUPC) {
			KERNEL_LOCK();
			ADDUPROF(p);
			KERNEL_UNLOCK();
		}
		if (want_resched)
			preempt(NULL);
@


1.113
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.112 2014/03/07 07:47:14 gerhard Exp $	*/
d158 2
a159 1
	}
@


1.112
log
@Remove superfluous 'return'.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.111 2014/02/13 23:11:06 kettenis Exp $	*/
d565 2
a566 2
	nsys = p->p_emul->e_nsysent;
	callp = p->p_emul->e_sysent;
d585 1
a585 1
		if (p->p_emul == &emul_linux_elf)
d608 1
a608 1
		callp += p->p_emul->e_nosys;		/* illegal */
d614 1
a614 1
	if (p->p_emul == &emul_linux_elf) {
d669 2
a670 2
		if (p->p_emul->e_errno && error >= 0 && error <= ELAST)
			frame->tf_eax = p->p_emul->e_errno[error];
@


1.111
log
@Some Linux i915 drm "fast" path code relies on being able to "disable" page
faults to avoid sleeping.  Implement this functionality for i386 and amd64
for faults in the user address space.  If the ci_inatomic flag is set in
struct cpu_info, copyin(9) and copyout(9) will return EFAULT when a user-space
address needs to be faulted in.  Use this to properly implement
__copy_to_user_inatomic() and __copy_from_user_inatomic_nocache() in the
inteldrm(4) code.

ok krw@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.110 2013/12/22 11:00:13 sf Exp $	*/
a521 1
			return;
@


1.110
log
@format string fix: %lx for register_t
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.109 2013/11/03 13:52:44 pirofti Exp $	*/
d452 7
a458 4
		onfault = p->p_addr->u_pcb.pcb_onfault;
		p->p_addr->u_pcb.pcb_onfault = NULL;
		rv = uvm_fault(map, va, 0, ftype);
		p->p_addr->u_pcb.pcb_onfault = onfault;
@


1.109
log
@Remove a.out support from compat_linux(8).

Tested with the syscall regression test suite from IBM and Opera.

Requested by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.108 2013/04/09 01:50:02 guenther Exp $	*/
d680 1
a680 1
		    "syscall(0x%x, 0x%x, 0x%x, 0x%x...) EXIT, PID %d\n",
@


1.108
log
@Need #include "isa.h" for NISA

Diff from Christian Groessler (chris (at) groessler.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.107 2012/12/31 06:44:11 guenther Exp $	*/
d72 1
a72 1
extern struct emul emul_linux_aout, emul_linux_elf;
d583 1
a583 2
		if (p->p_emul == &emul_linux_aout ||
		    p->p_emul == &emul_linux_elf)
d612 1
a612 1
	if (p->p_emul == &emul_linux_aout || p->p_emul == &emul_linux_elf) {
@


1.107
log
@Eliminate orig_errno, which could be uninitialized in one case, by doing
the emulation errno mapping directly into the register in the trapframe.
Range check the value in that case to guarantee there isn't an out-of-bounds
array access.

Uninitialized variable issue pointed out by David Hill.  Range check
suggested by matthew@@

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.106 2012/10/31 03:30:22 jsg Exp $	*/
d79 1
@


1.106
log
@Add support for Intel's Supervisor Mode Access Prevention (SMAP) feature.
When enabled SMAP will generate page faults on the kernel attempting
to read/write user data pages unless an override flag is set.

Instructions that modify the flag are patched into copyin/copyout and
friends on boot if SMAP is enabled.

Those with access to hardware with SMAP can contact me for a test case.

joint work with deraadt@@

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.105 2012/10/09 04:40:36 jsg Exp $	*/
d545 1
a545 1
	int orig_error, error, opc, nsys;
d646 1
a646 1
	orig_error = error = mi_syscall(p, code, callp, args, rval);
d667 4
a670 3
		if (p->p_emul->e_errno)
			error = p->p_emul->e_errno[error];
		frame->tf_eax = error;
d675 1
a675 1
	mi_syscall_return(p, code, orig_error, rval);
@


1.105
log
@Enable Supervisor Mode Execution Protection (SMEP), found in recent
Intel chips.  If the kernel is tricked into running code from a user
page while in supervisor mode we'll now get a page fault and panic
instead of running it.

suggestions and ok guenther@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.104 2012/09/06 20:20:30 tedu Exp $	*/
d409 5
@


1.104
log
@remove compat_aout support for i386. ok deraadt
miod has requested a stay of execution for compat_aout in general.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.103 2012/08/07 05:16:53 guenther Exp $	*/
d406 4
@


1.103
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.102 2012/04/11 14:38:55 mikeb Exp $	*/
a73 3
#ifdef COMPAT_AOUT
extern struct emul emul_aout;
#endif
d588 1
a588 5
		if (callp != sysent
#ifdef COMPAT_AOUT
		    && p->p_emul != &emul_aout
#endif
		    )
@


1.102
log
@The first ktrace record for a newly spawned thread is a return
from a fork syscall done by the parent.  Use __tfork, not rfork
here to match the ktrace records for the parent (CALL __tfork,
RET __tfork).  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.101 2011/11/16 20:50:18 deraadt Exp $	*/
a50 3
#ifdef KTRACE
#include <sys/ktrace.h>
#endif
d52 1
a52 3

#include "systrace.h"
#include <dev/systrace.h>
d539 1
a539 1
	int orig_error, error, opc, nsys, lock;
a634 1
		error = 0;
d638 2
a639 21
	if (argsize)
		error = copyin(params, (caddr_t)args, argsize);
	else
		error = 0;
	orig_error = error;

	lock = !(callp->sy_flags & SY_NOLOCK);	

#ifdef SYSCALL_DEBUG
	KERNEL_LOCK();
	scdebug_call(p, code, args);
	KERNEL_UNLOCK();
#endif

#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL)) {
		KERNEL_LOCK();
		ktrsyscall(p, code, argsize, args);
		KERNEL_UNLOCK();
	}
#endif
a640 3
	if (error) {
		goto bad;
	}
d644 1
a644 14
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE)) {
		KERNEL_LOCK();
		orig_error = error = systrace_redirect(code, p, args, rval);
		KERNEL_UNLOCK();
	} else
#endif
	{
		if (lock)
			KERNEL_LOCK();
			orig_error = error = (*callp->sy_call)(p, args, rval);
		if (lock)
			KERNEL_UNLOCK();
	}
d672 2
a673 13
#ifdef SYSCALL_DEBUG
	KERNEL_LOCK();
	scdebug_ret(p, code, orig_error, rval);
	KERNEL_UNLOCK();
#endif
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_LOCK();
		ktrsysret(p, code, orig_error, rval[0]);
		KERNEL_UNLOCK();
	}
#endif
d695 1
a695 11
	userret(p);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_LOCK();
		ktrsysret(p,
		    (p->p_flag & P_THREAD) ? SYS___tfork :
		    (p->p_p->ps_flags & PS_PPWAIT) ? SYS_vfork : SYS_fork,
		    0, 0);
		KERNEL_UNLOCK();
	}
#endif
@


1.101
log
@Make userret() MI.  On architectures which jammed stuff into it in the
past, pull that code out seperately.
ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.100 2011/07/11 15:40:47 guenther Exp $	*/
d752 1
a752 1
		    (p->p_flag & P_THREAD) ? SYS_rfork :
@


1.100
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.98 2011/07/06 21:41:37 art Exp $	*/
a88 1
static __inline void userret(struct proc *);
a90 16

/*
 * Define the code needed before returning to user mode, for
 * trap and syscall.
 */
static __inline void
userret(struct proc *p)
{
	int sig;

	/* take pending signals */
	while ((sig = CURSIG(p)) != 0)
		postsig(sig);

	p->p_cpu->ci_schedstate.spc_curpriority = p->p_priority = p->p_usrpri;
}
@


1.99
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@d325 1
d327 1
d333 1
d335 1
d340 1
d342 1
d347 1
d349 1
d354 1
d356 1
d362 1
d364 1
d374 1
d376 1
d382 1
d384 1
d388 1
d390 1
d394 1
d396 1
d401 1
d403 1
d509 1
d511 1
d515 1
d517 1
d670 1
d672 1
d677 1
d679 1
d691 1
d693 1
d699 1
a699 1
		orig_error = error = (*callp->sy_call)(p, args, rval);
d731 1
d733 1
d738 1
d740 1
d767 1
d772 1
@


1.98
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.97 2011/07/05 00:30:10 deraadt Exp $	*/
a324 1
		KERNEL_LOCK();
a325 1
		KERNEL_UNLOCK();
a330 1
		KERNEL_LOCK();
a331 1
		KERNEL_UNLOCK();
a335 1
		KERNEL_LOCK();
a336 1
		KERNEL_UNLOCK();
a340 1
		KERNEL_LOCK();
a341 1
		KERNEL_UNLOCK();
a345 1
		KERNEL_LOCK();
a346 1
		KERNEL_UNLOCK();
a351 1
			KERNEL_LOCK();
a352 1
			KERNEL_UNLOCK();
a361 1
		KERNEL_LOCK();
a362 1
		KERNEL_UNLOCK();
a367 1
		KERNEL_LOCK();
a368 1
		KERNEL_UNLOCK();
a371 1
		KERNEL_LOCK();
a372 1
		KERNEL_UNLOCK();
a375 1
		KERNEL_LOCK();
a376 1
		KERNEL_UNLOCK();
a380 1
		KERNEL_LOCK();
a381 1
		KERNEL_UNLOCK();
a486 1
		KERNEL_LOCK();
a487 1
		KERNEL_UNLOCK();
a490 1
		KERNEL_LOCK();
a491 1
		KERNEL_UNLOCK();
a643 1
	KERNEL_LOCK();
a644 1
	KERNEL_UNLOCK();
a648 1
		KERNEL_LOCK();
a649 1
		KERNEL_UNLOCK();
a660 1
		KERNEL_LOCK();
a661 1
		KERNEL_UNLOCK();
d667 1
a667 1
			orig_error = error = (*callp->sy_call)(p, args, rval);
a698 1
	KERNEL_LOCK();
a699 1
	KERNEL_UNLOCK();
a703 1
		KERNEL_LOCK();
a704 1
		KERNEL_UNLOCK();
a730 1
		KERNEL_LOCK();
a734 1
		KERNEL_UNLOCK();
@


1.97
log
@Remove the osyscall() kernel-entry; we do not use it anymore.
ok kettenis guenther tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.96 2011/04/05 12:50:15 guenther Exp $	*/
d303 1
a303 1
		KERNEL_PROC_LOCK(p);
d307 1
a307 1
			KERNEL_PROC_UNLOCK(p);
d314 1
a314 1
			KERNEL_PROC_UNLOCK(p);
d320 1
a320 1
		KERNEL_PROC_UNLOCK(p);
d325 1
a325 1
		KERNEL_PROC_LOCK(p);
d327 1
a327 1
		KERNEL_PROC_UNLOCK(p);
d333 1
a333 1
		KERNEL_PROC_LOCK(p);
d335 1
a335 1
		KERNEL_PROC_UNLOCK(p);
d340 1
a340 1
		KERNEL_PROC_LOCK(p);
d342 1
a342 1
		KERNEL_PROC_UNLOCK(p);
d347 1
a347 1
		KERNEL_PROC_LOCK(p);
d349 1
a349 1
		KERNEL_PROC_UNLOCK(p);
d354 1
a354 1
		KERNEL_PROC_LOCK(p);
d356 1
a356 1
		KERNEL_PROC_UNLOCK(p);
d362 1
a362 1
			KERNEL_PROC_LOCK(p);
d364 1
a364 1
			KERNEL_PROC_UNLOCK(p);
d374 1
a374 1
		KERNEL_PROC_LOCK(p);
d376 1
a376 1
		KERNEL_PROC_UNLOCK(p);
d382 1
a382 1
		KERNEL_PROC_LOCK(p);
d384 1
a384 1
		KERNEL_PROC_UNLOCK(p);
d388 1
a388 1
		KERNEL_PROC_LOCK(p);
d390 1
a390 1
		KERNEL_PROC_UNLOCK(p);
d394 1
a394 1
		KERNEL_PROC_LOCK(p);
d396 1
a396 1
		KERNEL_PROC_UNLOCK(p);
d401 1
a401 1
		KERNEL_PROC_LOCK(p);
d403 1
a403 1
		KERNEL_PROC_UNLOCK(p);
d440 1
a440 1
		KERNEL_PROC_LOCK(p);
d479 1
a479 1
			KERNEL_PROC_UNLOCK(p);
d494 1
a494 1
		KERNEL_PROC_UNLOCK(p);
d509 1
a509 1
		KERNEL_PROC_LOCK(p);
d511 1
a511 1
		KERNEL_PROC_UNLOCK(p);
d515 1
a515 1
		KERNEL_PROC_LOCK(p);
d517 1
a517 1
		KERNEL_PROC_UNLOCK(p);
d670 1
a670 1
	KERNEL_PROC_LOCK(p);
d672 1
a672 1
	KERNEL_PROC_UNLOCK(p);
d677 1
a677 1
		KERNEL_PROC_LOCK(p);
d679 1
a679 1
		KERNEL_PROC_UNLOCK(p);
d691 1
a691 1
		KERNEL_PROC_LOCK(p);
d693 1
a693 1
		KERNEL_PROC_UNLOCK(p);
d698 1
a698 1
			KERNEL_PROC_LOCK(p);
d701 1
a701 1
			KERNEL_PROC_UNLOCK(p);
d731 1
a731 1
	KERNEL_PROC_LOCK(p);
d733 1
a733 1
	KERNEL_PROC_UNLOCK(p);
d738 1
a738 1
		KERNEL_PROC_LOCK(p);
d740 1
a740 1
		KERNEL_PROC_UNLOCK(p);
d762 1
a762 1
	KERNEL_PROC_UNLOCK(p);
d767 1
a767 1
		KERNEL_PROC_LOCK(p);
d772 1
a772 1
		KERNEL_PROC_UNLOCK(p);
@


1.96
log
@Push COMPAT_FREEBSD in front of a whale.  Buggy, out of date, no
one has been weeding it, and it makes life harder.

Toasts of Brennivin for its passing from many; diff ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.95 2011/04/03 14:56:28 guenther Exp $	*/
d187 3
a189 15
	case T_TRCTRAP: {
#if defined(DDB) || defined(KGDB)
		/* Make sure nobody is single stepping into kernel land.
		 * The syscall has to turn off the trace bit itself.  The
		 * easiest way, is to simply not call the debugger, until
		 * we are through the problematic "osyscall" stub.  This
		 * is a hack, but it does seem to work.
		 */
		extern int Xosyscall, Xosyscall_end;

		if (frame->tf_eip >= (int)&Xosyscall &&
		    frame->tf_eip <= (int)&Xosyscall_end)
			return;
#else
		return; /* Just return if no DDB */
d191 1
a191 2
	}
	/* FALLTHROUGH */
@


1.95
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.94 2010/07/20 00:16:39 deraadt Exp $	*/
a78 3
#ifdef COMPAT_FREEBSD
extern struct emul emul_freebsd_aout, emul_freebsd_elf;
#endif
a626 4
#ifdef COMPAT_FREEBSD
		    && p->p_emul != &emul_freebsd_aout
		    && p->p_emul != &emul_freebsd_elf
#endif
@


1.94
log
@typo; martin.pelikan@@gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.93 2010/07/14 00:15:27 deraadt Exp $	*/
d789 3
a791 1
		    (p->p_flag & P_PPWAIT) ? SYS_vfork : SYS_fork, 0, 0);
@


1.93
log
@oops; Fred Crowson
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.92 2010/07/05 22:20:22 tedu Exp $	*/
d176 1
a176 1
		    frame->tf_trapno, frame->tf_err, frame->f_eip,
@


1.92
log
@remove compat_bsdos support
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.91 2010/07/01 19:47:07 tedu Exp $	*/
d176 1
a176 1
		    frame->tf_trapno, frame->tf_err, frame.->f_eip,
@


1.91
log
@I accidentally whacked something important.  Sorry.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.90 2010/07/01 17:30:27 tedu Exp $	*/
a81 3
#ifdef COMPAT_BSDOS
extern struct emul emul_bsdos;
#endif
a635 3
#endif
#ifdef COMPAT_BSDOS
		    && p->p_emul != &emul_bsdos
@


1.90
log
@another day, another compat gets removed.  today is ibcs2's turn
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.89 2010/05/09 12:03:16 kettenis Exp $	*/
d599 2
@


1.89
log
@Make i386 use a pointer to the trap frame like everybody else instead of
the weird "pass by reference" that causes problems with gcc4.

ok nicm@@, tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.88 2009/10/03 21:51:00 kettenis Exp $	*/
a73 5
#ifdef COMPAT_IBCS2
#include <compat/ibcs2/ibcs2_errno.h>
#include <compat/ibcs2/ibcs2_exec.h>
extern struct emul emul_ibcs2;
#endif
a598 7

#ifdef COMPAT_IBCS2
	if (p->p_emul == &emul_ibcs2)
		if (IBCS2_HIGH_SYSCALL(code))
			code = IBCS2_CVT_HIGH_SYSCALL(code);
#endif
	params = (caddr_t)frame->tf_esp + sizeof(int);
@


1.88
log
@Properly handle XMM exceptions instead of panicing the kernel.  Fixes the
issue reported by Slava Pestov.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.87 2008/04/09 16:49:17 thib Exp $	*/
d101 2
a102 2
void trap(struct trapframe);
void syscall(struct trapframe);
d154 1
a154 2
 * frame after the exception has been processed. Note that the
 * effect is as if the arguments were passed call by reference.
d158 1
a158 1
trap(struct trapframe frame)
d161 1
a161 1
	int type = frame.tf_trapno;
d175 1
a175 1
	if (frame.tf_err & PGEX_W) {
d184 2
a185 2
		    frame.tf_trapno, frame.tf_err, frame.tf_eip, frame.tf_cs,
		    frame.tf_eflags, rcr2(), lapic_tpr);
d190 1
a190 1
	if (!KERNELMODE(frame.tf_cs, frame.tf_eflags)) {
d192 1
a192 1
		p->p_md.md_regs = &frame;
d208 2
a209 2
		if (frame.tf_eip >= (int)&Xosyscall &&
		    frame.tf_eip <= (int)&Xosyscall_end)
d220 1
a220 1
		if (kgdb_trap(type, &frame))
d235 1
a235 1
		if (kdb_trap(type, 0, &frame))
d238 3
a240 3
		if (frame.tf_trapno < trap_types)
			printf("fatal %s (%d)", trap_type[frame.tf_trapno],
				frame.tf_trapno);
d242 1
a242 1
			printf("unknown trap %d", frame.tf_trapno);
d245 1
a245 1
		    type, frame.tf_err, frame.tf_eip, frame.tf_cs, frame.tf_eflags, rcr2(), lapic_tpr);
d248 1
a248 1
		    type, frame.tf_err, frame.tf_eip);
d254 1
a254 1
			kvm86_gpfault(&frame);
d265 1
a265 1
				frame.tf_eip = (int)pcb->pcb_onfault;
d285 1
a285 1
		switch (*(u_char *)frame.tf_eip) {
d287 1
a287 1
			vframe = (void *)((int)&frame.tf_esp -
d292 1
a292 1
			vframe = (void *)((int)&frame.tf_esp -
d297 1
a297 1
			vframe = (void *)((int)&frame.tf_esp -
d302 1
a302 1
			switch (*(u_char *)(frame.tf_eip+1)) {
d304 1
a304 1
				vframe = (void *)((int)&frame.tf_esp -
d309 1
a309 1
				vframe = (void *)((int)&frame.tf_esp -
d323 1
a323 1
		frame.tf_eip = resume;
d329 1
a329 1
		if (frame.tf_eflags & PSL_VM) {
d336 1
a336 1
		if (pmap_exec_fixup(&p->p_vmspace->vm_map, &frame,
d342 1
a342 1
		sv.sival_int = frame.tf_eip;
d348 1
a348 1
		sv.sival_int = frame.tf_eip;
d356 1
a356 1
		sv.sival_int = frame.tf_eip;
d363 1
a363 1
		sv.sival_int = frame.tf_eip;
d370 1
a370 1
		sv.sival_int = frame.tf_eip;
d377 1
a377 1
		sv.sival_int = frame.tf_eip;
d397 1
a397 1
		sv.sival_int = frame.tf_eip;
d405 1
a405 1
		sv.sival_int = frame.tf_eip;
d411 1
a411 1
		sv.sival_int = frame.tf_eip;
d417 1
a417 1
		sv.sival_int = frame.tf_eip;
d424 1
a424 1
		sv.sival_int = frame.tf_eip;
d426 1
a426 1
		trapsignal(p, SIGFPE, frame.tf_err, FPE_INTOVF, sv);
d431 1
a431 1
		npxtrap(&frame);
d450 1
a450 1
		if (frame.tf_err & PGEX_P)
d551 1
a551 1
		if (kgdb_trap(type, &frame))
d555 1
a555 1
		if (kdb_trap(type, 0, &frame))
a576 1
 * Like trap(), argument is call by reference.
d580 1
a580 1
syscall(struct trapframe frame)
d594 1
a594 1
	if (!USERMODE(frame.tf_cs, frame.tf_eflags))
d598 3
a600 3
	p->p_md.md_regs = &frame;
	opc = frame.tf_eip;
	code = frame.tf_eax;
d610 1
a610 1
	params = (caddr_t)frame.tf_esp + sizeof(int);
d618 1
a618 1
	if (frame.tf_eflags & PSL_VM)
d675 1
a675 1
			args[5] = frame.tf_ebp;
d677 1
a677 1
			args[4] = frame.tf_edi;
d679 1
a679 1
			args[3] = frame.tf_esi;
d681 1
a681 1
			args[2] = frame.tf_edx;
d683 1
a683 1
			args[1] = frame.tf_ecx;
d685 1
a685 1
			args[0] = frame.tf_ebx;
d723 1
a723 1
	rval[1] = frame.tf_edx;
d742 3
a744 3
		frame.tf_eax = rval[0];
		frame.tf_edx = rval[1];
		frame.tf_eflags &= ~PSL_C;	/* carry bit */
d752 1
a752 1
		frame.tf_eip = opc - frame.tf_err;
d761 2
a762 2
		frame.tf_eax = error;
		frame.tf_eflags |= PSL_C;	/* carry bit */
@


1.87
log
@Don't grab the kernel biglock for syscalls marked SY_NOLOCK;
matches what amd64 and sparc64 do.

tested by johan@@ and laurent@@
ok toby@@,dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.86 2007/10/10 04:36:11 ray Exp $	*/
d429 4
@


1.87.8.1
log
@Properly handle XMM exceptions instead of panicing the kernel.  Fixes the
issue reported by Slava Pestov. Fix from kettenis@@.

MFC requested by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.87 2008/04/09 16:49:17 thib Exp $	*/
a428 4
		goto out;

	case T_XFTRAP|T_USER:
		npxtrap(&frame);
@


1.87.4.1
log
@Properly handle XMM exceptions instead of panicing the kernel.  Fixes the
issue reported by Slava Pestov. Fix from kettenis@@.

MFC requested by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.87 2008/04/09 16:49:17 thib Exp $	*/
a428 4
		goto out;

	case T_XFTRAP|T_USER:
		npxtrap(&frame);
@


1.87.2.1
log
@Properly handle XMM exceptions instead of panicing the kernel.  Fixes the
issue reported by Slava Pestov. Fix from kettenis@@.

MFC requested by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.87 2008/04/09 16:49:17 thib Exp $	*/
a428 4
		goto out;

	case T_XFTRAP|T_USER:
		npxtrap(&frame);
@


1.86
log
@Change argsize from size_t to short, since it only stores a short
value.  Fixes a format string error.

Pointed out by deraadt, OK miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.85 2007/06/26 13:39:02 tom Exp $	*/
d583 1
a583 1
	int orig_error, error, opc, nsys;
d700 4
a704 1
#ifdef SYSCALL_DEBUG
d706 1
d708 1
d710 2
a711 1
	if (KTRPOINT(p, KTR_SYSCALL))
d713 2
d716 1
a717 1
		KERNEL_PROC_UNLOCK(p);
d722 1
d724 2
a725 1
	if (ISSET(p->p_flag, P_SYSTRACE))
d727 2
a728 1
	else
d730 8
a737 2
		orig_error = error = (*callp->sy_call)(p, args, rval);
	KERNEL_PROC_UNLOCK(p);
@


1.85
log
@Provide a default case so that we don't end up trying to dereference
vframe when it hasn't been set.

Prompted by a diff from mickey@@

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.84 2007/05/29 18:47:51 tom Exp $	*/
a583 1
	size_t argsize;
d588 1
@


1.84
log
@Remove trapwrite(), which was only used by 80386.

Prompted by miod@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.83 2007/05/11 10:06:55 pedro Exp $	*/
d314 2
d317 1
a317 1
                        break;
@


1.83
log
@Don't use LK_CANRECURSE for the kernel lock, okay miod@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.82 2007/03/15 10:22:29 art Exp $	*/
a101 1
int trapwrite(unsigned);
a566 25
}

/*
 * Compensate for 386 brain damage (missing URKR)
 */
int
trapwrite(unsigned int addr)
{
	vaddr_t va;
	struct proc *p;
	struct vmspace *vm;

	va = trunc_page((vaddr_t)addr);
	if (va >= VM_MAXUSER_ADDRESS)
		return 1;

	p = curproc;
	vm = p->p_vmspace;

	if (uvm_fault(&vm->vm_map, va, 0, VM_PROT_READ | VM_PROT_WRITE))
		return 1;

	uvm_grow(p, va);

	return 0;
@


1.82
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.81 2007/01/09 08:43:25 art Exp $	*/
d450 1
a450 1
		KERNEL_LOCK(LK_CANRECURSE|LK_EXCLUSIVE);
@


1.81
log
@Miod used a too large hatchet when trimming userret in 1.80.
Restore user priority before returning to userland.

(other architectures checked and seem to do the right thing)

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.80 2006/12/24 20:30:35 miod Exp $	*/
a385 1
			p->p_flag &= ~P_OWEUPC;
@


1.80
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.79 2006/12/24 20:29:19 miod Exp $	*/
d118 1
a118 1
	p->p_cpu->ci_schedstate.spc_curpriority = p->p_priority;
@


1.79
log
@Check for want_resched when processing AST and nowhere else. But then, when
doing so, do not check for signals - userret() will do this.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.78 2006/09/19 11:06:33 jsg Exp $	*/
d100 1
a100 1
static __inline void userret(struct proc *, int, u_quad_t);
d110 1
a110 1
userret(struct proc *p, int pc, u_quad_t oticks)
a116 18
	p->p_priority = p->p_usrpri;
	if (want_resched) {
		/*
		 * We're being preempted.
		 */
		preempt(NULL);
		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}

	/*
	 * If profiling, charge recent system time to the trapped pc.
	 */
	if (p->p_flag & P_PROFIL) {
		extern int psratio;

		addupc_task(p, pc, (int)(p->p_sticks - oticks) * psratio);
	}
a163 1
	u_quad_t sticks;
a193 1
		sticks = p->p_sticks;
d195 1
a195 2
	} else
		sticks = 0;
d568 1
a568 1
	userret(p, frame.tf_eip, sticks);
a610 1
	u_quad_t sticks;
a620 1
	sticks = p->p_sticks;
d777 1
a777 1
	userret(p, frame.tf_eip, sticks);
d806 1
a806 1
	userret(p, tf->tf_eip, 0);
@


1.78
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.77 2006/08/22 20:09:25 mickey Exp $	*/
d412 2
@


1.77
log
@provide some smp locking around protection fault trap from user too; originally from niklas; been in snaps; tested on various smp boxen; niklas@@ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.76 2006/07/25 19:16:51 kettenis Exp $	*/
d110 1
a110 4
userret(p, pc, oticks)
	register struct proc *p;
	int pc;
	u_quad_t oticks;
d178 1
a178 2
trap(frame)
	struct trapframe frame;
d180 1
a180 1
	register struct proc *p = curproc;
d622 1
a622 2
syscall(frame)
	struct trapframe frame;
d624 3
a626 3
	register caddr_t params;
	register struct sysent *callp;
	register struct proc *p;
d817 1
a817 2
child_return(arg)
	void *arg;
@


1.76
log
@Kill option GPL_MATH_EMULATE.

ok deraadt@@ and many others.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.75 2006/06/13 03:01:04 gwk Exp $	*/
d352 1
d356 1
d362 2
a363 1
		    &p->p_addr->u_pcb))
d365 1
d369 1
@


1.75
log
@Kernel virtual mode 8086, currently disabled in GENERIC.
lots of help at c2k6 and after from toby@@,
ok toby@@, mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.74 2006/05/11 13:21:12 mickey Exp $	*/
a413 13
#if defined(GPL_MATH_EMULATE)
		int rv;
		if ((rv = math_emulate(&frame)) == 0) {
			if (frame.tf_eflags & PSL_T)
				goto trace;
			return;
		}
		sv.sival_int = frame.tf_eip;
		KERNEL_PROC_LOCK(p);
		trapsignal(p, rv, type &~ T_USER, FPE_FLTINV, sv);
		KERNEL_PROC_UNLOCK(p);
		goto out;
#else
a420 1
#endif
a552 3
#if defined(GPL_MATH_EMULATE)
	trace:
#endif
@


1.74
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.73 2006/04/15 02:52:40 weingart Exp $	*/
d93 4
d279 6
@


1.73
log
@Print out trap number as well as string
representation.  Ok tom@@ quite some time
ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.72 2005/10/26 20:32:59 marco Exp $	*/
d129 1
a129 1
	if (p->p_flag & P_PROFIL) { 
d133 1
a133 1
	}                   
d321 1
a321 1
				vframe = (void *)((int)&frame.tf_esp - 
@


1.72
log
@Add basic handler for MCE and MCA.  Written mostly by toby@@ and commiting for
toby@@ per his request.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.71 2005/09/15 21:14:27 miod Exp $	*/
d262 2
a263 1
			printf("fatal %s", trap_type[frame.tf_trapno]);
@


1.71
log
@In syscall(), do not recompute the struct proc * after the syscall has
succeeded. This used to be necessary for fork(), when returning in the child,
but we return in the child in child_return() which does TRT.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.70 2005/09/15 21:09:29 miod Exp $	*/
d158 2
a159 1
	"reserved trap",			/* 19 T_RESERVED */
@


1.70
log
@Change child_return() to record a proper ktrace record for vfork child
processes.

ok art@@ uwe@@ (some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.69 2005/05/29 03:20:38 deraadt Exp $	*/
a773 5
		/*
		 * Reinitialize proc pointer `p' as it may be different
		 * if this is a child returning from fork syscall.
		 */
		p = curproc;
@


1.69
log
@sched work by niklas and art backed out; causes panics
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.67 2004/12/06 20:12:24 miod Exp $	*/
d842 2
a843 1
		ktrsysret(p, SYS_fork, 0, 0);
@


1.68
log
@This patch is mortly art's work and was done *a year* ago.  Art wants to thank
everyone for the prompt review and ok of this work ;-)  Yeah, that includes me
too, or maybe especially me.  I am sorry.

Change the sched_lock to a mutex. This fixes, among other things, the infamous
"telnet localhost &" problem.  The real bug in that case was that the sched_lock
which is by design a non-recursive lock, was recursively acquired, and not
enough releases made us hold the lock in the idle loop, blocking scheduling
on the other processors.  Some of the other processors would hold the biglock though,
which made it impossible for cpu 0 to enter the kernel...  A nice deadlock.
Let me just say debugging this for days just to realize that it was all fixed
in an old diff noone ever ok'd was somewhat of an anti-climax.

This diff also changes splsched to be correct for all our architectures.
@
text
@d454 9
@


1.67
log
@Use uvm_grow() to account for stack growth, rather than home-grown code
or nothing.
Inspired by a similar recent change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.66 2004/09/07 10:12:35 niklas Exp $	*/
a453 9
#ifdef LOCKDEBUG
		/* If we page-fault while in scheduler, we're doomed. */
#ifdef notyet
		if (simple_lock_held(&sched_lock))
#else
		if (__mp_lock_held(&sched_lock))
#endif
			goto we_re_toast;
#endif
@


1.66
log
@Properly put ktrsyscall (and scdebug_foo) into biglock, inspired from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.65 2004/08/14 00:14:11 niklas Exp $	*/
a478 1
		unsigned nss;
a507 19
		nss = 0;
		if ((caddr_t)va >= vm->vm_maxsaddr
		    && (caddr_t)va < (caddr_t)VM_MAXUSER_ADDRESS
		    && map != kernel_map) {
			nss = btoc(USRSTACK-(unsigned)va);
			if (nss > btoc(p->p_rlimit[RLIMIT_STACK].rlim_cur)) {
				/*
				 * We used to fail here. However, it may
				 * just have been an mmap()ed page low
				 * in the stack, which is legal. If it
				 * wasn't, uvm_fault() will fail below.
				 *
				 * Set nss to 0, since this case is not
				 * a "stack extension".
				 */
				nss = 0;
			}
		}

d512 1
d514 2
a515 2
			if (nss > vm->vm_ssize)
				vm->vm_ssize = nss;
a600 1
	unsigned nss;
a607 1
	nss = 0;
a609 5
	if ((caddr_t)va >= vm->vm_maxsaddr) {
		nss = btoc(USRSTACK-(unsigned)va);
		if (nss > btoc(p->p_rlimit[RLIMIT_STACK].rlim_cur))
			nss = 0;
	}
d614 1
a614 2
	if (nss > vm->vm_ssize)
		vm->vm_ssize = nss;
@


1.65
log
@bad bad typo + thinko made ktrace broken in smp.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.64 2004/07/02 16:29:55 niklas Exp $	*/
d778 1
d786 2
a787 1
	if (error)
d789 1
a791 1
	KERNEL_PROC_LOCK(p);
d831 1
d833 1
@


1.64
log
@Maintain %f and %gs over traps.  Mostly from NetBSD.  Preparation for SMP
speedups.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.63 2004/06/13 21:49:15 niklas Exp $	*/
a858 1
#ifdef notyet
a859 1
#endif
d863 1
a863 1
	if (KTRPOINT(p, KTR_SYSRET))
d867 1
@


1.63
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d183 2
a184 1
	extern char resume_iret[], resume_pop_ds[], resume_pop_es[];
d302 2
a303 1
			vframe = (void *)((int)&frame.tf_esp - 44);
d307 2
a308 1
			vframe = (void *)((int)&frame.tf_esp - 4);
d312 2
a313 1
			vframe = (void *)((int)&frame.tf_esp - 0);
d316 14
@


1.62
log
@rework access to emulations slightly in an effort to both merge and
separate exec format from emulation.  consistent naming of freebsd emuls.
not much in the way of functional changes yet.
testing and ok deraadt@@ and others along the way.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.61 2003/07/29 18:24:36 mickey Exp $	*/
d135 1
a135 1
	curpriority = p->p_priority;
d189 1
d204 1
a204 1
		    frame.tf_eflags, rcr2(), cpl);
d265 1
a265 1
		    type, frame.tf_err, frame.tf_eip, frame.tf_cs, frame.tf_eflags, rcr2(), cpl);
d339 1
d341 1
d347 1
d349 1
d354 1
d356 1
d361 1
d363 1
d368 1
d370 1
d377 1
d379 1
d392 1
d394 1
d400 1
d402 1
d409 1
d411 1
d415 1
d417 1
d421 1
d423 1
d428 1
d430 1
d436 10
d452 4
a455 1
		/* FALLTHROUGH */
d458 1
a458 1
		struct vmspace *vm = p->p_vmspace;
d463 4
d469 1
a469 1
		fa = (vaddr_t)rcr2();
d517 2
a518 1
			if (type == T_PAGEFLT)
d520 2
d526 2
a527 1
			if (pcb->pcb_onfault != 0)
d529 1
d536 1
d551 1
d553 1
d560 1
d562 1
d646 1
a646 1
	int ocpl = cpl;
d771 1
d778 1
d815 2
a816 1
	if (KTRPOINT(p, KTR_SYSRET))
d818 2
d822 1
a822 1
	if (cpl != ocpl) {
d825 2
a826 2
		    cpl, code, args[0], args[1], args[2], p->p_pid);
		cpl = ocpl;
d841 4
d848 1
d850 1
@


1.61
log
@move spl checking wrap over the syscall into trap.c:syscall();
this gives several benefits:
the arguments for a syscall printed are the exact args and not
  some wild guess fetched from the user stack;
the check does not include the AST traps that may be checked
  on their own in the trap() routine should be desired;
kill last use and thus itself the fuword() function and it's glue.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.60 2003/07/28 19:59:18 jason Exp $	*/
d85 1
a85 1
extern struct emul emul_aout_freebsd, emul_elf_freebsd;
d650 2
a651 2
		    && p->p_emul != &emul_aout_freebsd
		    && p->p_emul != &emul_elf_freebsd
@


1.60
log
@remove the non-licensed i386 math emulation stuff.  This only leaves the
gnu stuff as an option until it is replaced RSN.  ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.59 2003/06/24 22:45:33 espie Exp $	*/
d593 3
d763 8
@


1.59
log
@a.out emulation for dynamic binaries: intercept the right system calls
so that they look in /emul/a.out first. This allows a.out's ld.so to
find its own libraries without interfering with ELF at all.

Many comments from various people. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.58 2003/06/02 23:27:47 millert Exp $	*/
d371 1
a371 1
#if defined(MATH_EMULATE) || defined(GPL_MATH_EMULATE)
d506 1
a506 1
#if defined(MATH_EMULATE) || defined(GPL_MATH_EMULATE)
@


1.58
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.57 2003/05/13 03:49:04 art Exp $	*/
d90 3
d649 3
@


1.57
log
@The current solution to handle the protection fault trap is not
correct.  It breaks down if we're trying to jump through a function
pointer. The protection fault trap on i386 must be one of the most
braindead traps ever invented in the history of humankind. It doesn't
give you any information about what went wrong except the instruction
that faulted. Since the problem we're trying to deal with is a
segmentation problem, we don't get the desitination that we want to
jump to, we just get the instruction and we won't add a disassembler
to trap handling just to try to figure out what went wrong.

What we want to do is to handle this as a normal fault to let noexec
accounting in pmap_enter deal with the changes to the code
segment. Unfortunately that's impossible. We don't know the faulting
address, so we need to change how the exec accounting works. Basically
the code segment must already cover the address we want to execute
before we can fault it in.

New scheme:

 o Start with conservative code segment.

 o If we get a protection fault, go through all mappings in the process
  and find the highest executable mapping, fix up the code segment and
  record that address. If the code segment didn't change, the protection
  fault wasn't fixable - just die.

 o If the highest executable mapping is removed, just reset the code
  segment to something conservative and let the next protection fault
  deal with it.  We can't read all the vm mappings of the process from
  the pmap because of locking hell.

This should allow floating code segment whenever someone implements that.

Also, fix the pmap_protect function to behave more like the other
pmaps we have and be slightly more agressive to force more proper
protection changes.

ok:ed by various people.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.56 2003/05/04 15:56:34 mickey Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.56
log
@mop-mop squeek-squeek
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.55 2003/05/04 04:58:16 drahn Exp $	*/
d328 8
a335 6
		if (ftype == VM_PROT_READ) {
			ftype |= VM_PROT_EXECUTE;
			/* XXX force %cr2 register have fault address */
			__asm __volatile("movl %0,%%cr2" :: "r" (frame.tf_eip));
		}
		goto page_fault;
a418 1
	page_fault:
@


1.55
log
@When a protection fault occurs, force %cr2 to contain the pc as
the fault address.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.54 2003/05/02 21:07:48 mickey Exp $	*/
d328 1
a328 1
		if (ftype == VM_PROT_READ)
d330 3
a332 2
		/* force %cr2 register have fault address */
		__asm __volatile("movl %0,%%cr2" :: "r" (frame.tf_eip));
@


1.54
log
@when flipping the code descriptors also update cs in the
tss and not only in the frame since we might be returning that way too.
add a heuristic for detecting an exec protection fault:
iff we get a read protection fault (which we normally never
get due to our segments being always readable) we assume that
it was an exec protection indeed and go to page fault
routine which will decide the rest for us (including sending
a signal should that be needed).
problem found by drahn@@ and testing by many ppl.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.53 2003/01/16 04:15:17 art Exp $	*/
d330 2
@


1.53
log
@Getting rid of vm_offset_t
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.52 2003/01/09 22:27:09 miod Exp $	*/
d328 3
a330 3
		sv.sival_int = rcr2();
		trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, sv);
		goto out;
d414 1
a414 1

@


1.52
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.51 2002/12/12 07:41:45 ish Exp $	*/
d416 1
a416 1
		vm_offset_t va, fa;
a419 1
		extern struct vm_map *kernel_map;
d424 1
a424 1
		fa = (vm_offset_t)rcr2();
d544 1
a544 2
trapwrite(addr)
	unsigned addr;
d546 1
a546 1
	vm_offset_t va;
d551 1
a551 1
	va = trunc_page((vm_offset_t)addr);
@


1.51
log
@linux passes the 6th syscall argument in ebp
- from NetBSD
- ok deraadt, mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.50 2002/05/16 16:16:52 provos Exp $	*/
d184 1
a184 2
	extern char fusubail[],
		    resume_iret[], resume_pop_ds[], resume_pop_es[];
a407 6
		/*
		 * fusubail is used by [fs]uswintr() to prevent page faulting
		 * from inside the profiling interrupt.
		 */
		if (pcb->pcb_onfault == fusubail)
			goto copyfault;
d636 1
a636 1
		code = fuword(params);
d654 1
a654 1
		code = fuword(params + _QUAD_LOWWORD * sizeof(int));
@


1.50
log
@systrace facility, used to enforce and generate policies for system calls
okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.49 2002/03/14 01:26:33 millert Exp $	*/
d676 1
a676 1
		 * Linux passes the args in ebx, ecx, edx, esi, edi, in
d680 2
@


1.49
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.48 2002/02/21 23:27:12 deraadt Exp $	*/
d60 3
d717 6
a722 1
	orig_error = error = (*callp->sy_call)(p, args, rval);
@


1.48
log
@for a SIGSEGV, only read cr2 once, not twice (and now si_addr is not just the fault page)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.47 2001/12/03 14:29:24 mpech Exp $	*/
d94 4
a97 4
static __inline void userret __P((struct proc *, int, u_quad_t));
void trap __P((struct trapframe));
int trapwrite __P((unsigned));
void syscall __P((struct trapframe));
@


1.47
log
@be more verbose on panic. patch by form@@.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.46 2001/11/28 16:13:28 art Exp $	*/
d420 1
a420 1
		vm_offset_t va;
d429 2
a430 1
		va = trunc_page((vm_offset_t)rcr2());
d489 1
a489 1
		sv.sival_int = rcr2();
@


1.47.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.47 2001/12/03 14:29:24 mpech Exp $	*/
a59 3
#include "systrace.h"
#include <dev/systrace.h>

d94 4
a97 4
static __inline void userret(struct proc *, int, u_quad_t);
void trap(struct trapframe);
int trapwrite(unsigned);
void syscall(struct trapframe);
d420 1
a420 1
		vm_offset_t va, fa;
d429 1
a429 2
		fa = (vm_offset_t)rcr2();
		va = trunc_page(fa);
d488 1
a488 1
		sv.sival_int = fa;
d713 1
a713 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		orig_error = error = systrace_redirect(code, p, args, rval);
	else
#endif
		orig_error = error = (*callp->sy_call)(p, args, rval);
@


1.47.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d184 2
a185 1
	extern char resume_iret[], resume_pop_ds[], resume_pop_es[];
d329 1
a329 6
		/* If pmap_exec_fixup does something, let's retry the trap. */
		if (pmap_exec_fixup(&p->p_vmspace->vm_map, &frame,
		    &p->p_addr->u_pcb))
			goto out;

		sv.sival_int = frame.tf_eip;
d409 6
d421 1
d423 1
a423 1
		vaddr_t va, fa;
d427 1
d432 1
a432 1
		fa = (vaddr_t)rcr2();
d552 2
a553 1
trapwrite(unsigned int addr)
d555 1
a555 1
	vaddr_t va;
d560 1
a560 1
	va = trunc_page((vaddr_t)addr);
d643 1
a643 1
		copyin(params, &code, sizeof(int));
d661 1
a661 1
		copyin(params + _QUAD_LOWWORD * sizeof(int), &code, sizeof(int));
d676 1
a676 1
		 * Linux passes the args in ebx, ecx, edx, esi, edi, ebp, in
a679 2
		case 24:
			args[5] = frame.tf_ebp;
@


1.46
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.45 2001/11/28 13:47:38 art Exp $	*/
d265 2
a266 1
		panic("trap");
@


1.45
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.44 2001/11/06 18:41:09 art Exp $	*/
d419 3
a421 3
		register vm_offset_t va;
		register struct vmspace *vm = p->p_vmspace;
		register vm_map_t map;
d423 1
a423 1
		extern vm_map_t kernel_map;
@


1.44
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.43 2001/09/20 11:57:18 art Exp $	*/
d472 1
a472 1
		if (rv == KERN_SUCCESS) {
d568 1
a568 2
	if (uvm_fault(&vm->vm_map, va, 0, VM_PROT_READ | VM_PROT_WRITE)
	    != KERN_SUCCESS)
@


1.43
log
@Be much more careful about pcb_onfault.
Should solve 2026.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.42 2001/09/13 14:37:52 art Exp $	*/
d756 2
a757 3
child_return(p, frame)
	struct proc *p;
	struct trapframe frame;
d759 2
d762 2
a763 2
	frame.tf_eax = 0;
	frame.tf_eflags &= ~PSL_C;
d765 1
a765 1
	userret(p, frame.tf_eip, 0);
@


1.42
log
@Simplify userret, modelled after alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.41 2001/08/12 21:51:03 mickey Exp $	*/
d187 1
d468 2
d471 1
@


1.41
log
@uvm_extern.h is enough here
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.40 2001/05/05 23:25:42 art Exp $	*/
d109 1
a109 1
	int sig, s;
d117 1
a117 6
		 * Since we are curproc, a clock interrupt could
		 * change our priority without changing run queues
		 * (the running process is not kept on a run queue).
		 * If this happened after we setrunqueue ourselves but
		 * before we switch()'ed, we might not be on the queue
		 * indicated by our priority.
d119 1
a119 5
		s = splstatclock();
		setrunqueue(p);
		p->p_stats->p_ru.ru_nivcsw++;
		mi_switch();
		splx(s);
@


1.40
log
@PMAP_NEW and UVM are no longer optional on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.39 2001/05/05 21:26:37 art Exp $	*/
a58 4

#include <vm/vm_param.h>
#include <vm/pmap.h>
#include <vm/vm_map.h>
@


1.39
log
@Remove the (vaddr_t) casts inside the round_page and trunc_page macros.
We might want to use them on types that are bigger than vaddr_t.

Fix all callers that pass pointers without casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.38 2001/05/05 20:56:38 art Exp $	*/
a63 1
#if defined(UVM)
a64 1
#endif
a200 1
#if defined(UVM)
a201 3
#else
	cnt.v_trap++;
#endif
a367 1
#if defined(UVM)
a368 3
#else
		cnt.v_soft++;
#endif
a436 3
#ifndef PMAP_NEW
		unsigned v;
#endif
a479 22
#ifndef PMAP_NEW
		/* check if page table is mapped, if not, fault it first */
		if ((PTD[pdei(va)] & PG_V) == 0) {
			v = trunc_page((vaddr_t)vtopte(va));
#if defined(UVM)
			rv = uvm_fault(map, v, 0, ftype);
#else
			rv = vm_fault(map, v, ftype, FALSE);
#endif
			if (rv != KERN_SUCCESS)
				goto nogo;
			/* check if page table fault, increment wiring */
#if defined(UVM)
			uvm_map_pageable(map, v, round_page(v+1), FALSE);
#else
			vm_map_pageable(map, v, round_page(v+1), FALSE);
#endif
		} else
			v = 0;
#endif

#if defined(UVM)
a480 3
#else
		rv = vm_fault(map, va, ftype, FALSE);
#endif
a488 3
#ifndef PMAP_NEW
	nogo:
#endif
a491 1
#if defined(UVM)
a493 4
#else
			printf("vm_fault(%p, %lx, %x, 0) -> %x\n",
			    map, va, ftype, rv);
#endif
a576 1
#if defined(UVM)
a579 5
#else
	if (vm_fault(&vm->vm_map, va, VM_PROT_READ | VM_PROT_WRITE, FALSE)
	    != KERN_SUCCESS)
		return 1;
#endif
a604 1
#if defined(UVM)
a605 3
#else
	cnt.v_syscall++;
#endif
@


1.38
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.37 2001/04/02 21:43:10 niklas Exp $	*/
d496 1
a496 1
			v = trunc_page(vtopte(va));
@


1.37
log
@On popular demand, the Linux-compatibility clone(2) implementation based
on NetBSD's code, as well as some faked Posix RT extensions by me.  This makes
at least simple linuxthreads tests work.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.36 2001/03/22 23:36:51 niklas Exp $	*/
a3 2
#undef DEBUG
#define DEBUG
d478 1
a478 1
			nss = clrnd(btoc(USRSTACK-(unsigned)va));
d618 1
a618 1
		nss = clrnd(btoc(USRSTACK-(unsigned)va));
@


1.36
log
@Merge in NetBSD's PMAP_NEW, still disabled
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.35 2001/01/24 09:37:59 hugh Exp $	*/
d482 10
a491 2
				rv = KERN_FAILURE;
				goto nogo;
d529 1
d531 1
d622 1
a622 1
			return 1;
d654 1
a654 1
	int error, opc, nsys;
d768 1
d780 1
a780 1
	error = (*callp->sy_call)(p, args, rval);
d813 1
a813 1
	scdebug_ret(p, code, error, rval);
d818 1
a818 1
		ktrsysret(p, code, error, rval[0]);
@


1.35
log
@KGDB for i386 from NetBSD via niklas, with tweaks and accommodations.
Tested by various, vetted by mickey & theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.34 2000/11/10 18:15:38 art Exp $	*/
d448 4
a451 1
		unsigned nss, v;
d487 1
d506 1
@


1.34
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.33 2000/06/26 22:45:53 art Exp $	*/
d79 4
d238 1
a238 1
#ifdef DDB
d258 15
d534 9
a554 1
#include "isa.h"
d558 1
a558 1
#ifdef DDB
d561 2
a562 1
		if (kdb_trap (type, 0, &frame))
d565 6
@


1.33
log
@Make the check for !usermode in syscal a DIAGNOSTIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2000/06/08 22:25:19 niklas Exp $	*/
d724 1
a724 1
		ktrsyscall(p->p_tracep, code, argsize, args);
d768 1
a768 1
		ktrsysret(p->p_tracep, code, error, rval[0]);
d784 1
a784 1
		ktrsysret(p->p_tracep, SYS_fork, 0, 0);
@


1.32
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.32 2000/06/08 21:11:58 niklas Exp $	*/
d615 1
d618 1
@


1.31
log
@Fix TSS fault handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.30 1999/02/26 04:42:14 art Exp $	*/
d52 1
@


1.31.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.37 2001/04/02 21:43:10 niklas Exp $	*/
a51 1
#include <sys/signalvar.h>
a77 4
#ifdef KGDB
#include <sys/kgdb.h>
#endif

d233 1
a233 1
#if defined(DDB) || defined(KGDB)
a252 15
#ifdef KGDB
		if (kgdb_trap(type, &frame))
			return;
		else {
			/*
			 * If this is a breakpoint, don't panic
			 * if we're not connected.
			 */
			if (type == T_BPTFLT) {
				printf("kgdb: ignored %s\n", trap_type[type]);
				return;
			}
		}
#endif

d428 1
a428 4
		unsigned nss;
#ifndef PMAP_NEW
		unsigned v;
#endif
d459 2
a460 10
				/*
				 * We used to fail here. However, it may
				 * just have been an mmap()ed page low
				 * in the stack, which is legal. If it
				 * wasn't, uvm_fault() will fail below.
				 *
				 * Set nss to 0, since this case is not
				 * a "stack extension".
				 */
				nss = 0;
a463 1
#ifndef PMAP_NEW
a481 1
#endif
a495 1
#ifndef PMAP_NEW
a496 1
#endif
a513 9
#if 0  /* Should this be left out?  */
#if !defined(DDB) && !defined(KGDB)
	/* XXX need to deal with this when DDB is present, too */
	case T_TRCTRAP: /* kernel trace trap; someone single stepping lcall's */
			/* syscall has to turn off the trace bit itself */
		return;
#endif
#endif

d526 1
d530 1
a530 1
#if defined(DDB) || defined(KGDB)
d533 1
a533 6
#ifdef KGDB
		if (kgdb_trap(type, &frame))
			return;
#endif
#ifdef DDB
		if (kdb_trap(type, 0, &frame))
a535 2
			return;
#endif /* DDB || KGDB */
d572 1
a572 1
			nss = 0;
d604 1
a604 1
	int orig_error, error, opc, nsys;
a613 1
#ifdef DIAGNOSTIC
a615 1
#endif
a715 1
	orig_error = error;
d721 1
a721 1
		ktrsyscall(p, code, argsize, args);
d727 1
a727 1
	orig_error = error = (*callp->sy_call)(p, args, rval);
d760 1
a760 1
	scdebug_ret(p, code, orig_error, rval);
d765 1
a765 1
		ktrsysret(p, code, orig_error, rval[0]);
d781 1
a781 1
		ktrsysret(p, SYS_fork, 0, 0);
@


1.31.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31.6.1 2001/04/18 16:07:24 niklas Exp $	*/
d4 2
d66 1
d68 1
d205 1
d207 3
d376 1
d378 3
d449 3
d480 1
a480 1
			nss = btoc(USRSTACK-(unsigned)va);
d495 22
d518 3
d529 3
d535 1
d538 4
d620 1
a620 1
		nss = btoc(USRSTACK-(unsigned)va);
d625 1
d629 5
d659 1
d661 3
@


1.31.6.3
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31.6.2 2001/07/04 10:16:43 niklas Exp $	*/
d214 1
a214 1
		    frame.tf_eflags, rcr2(), lapic_tpr);
d275 1
a275 1
		    type, frame.tf_err, frame.tf_eip, frame.tf_cs, frame.tf_eflags, rcr2(), lapic_tpr);
@


1.31.6.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31.6.3 2001/07/14 10:02:31 ho Exp $	*/
d60 4
d113 1
a113 1
	int sig;
d121 6
a126 1
		 * We're being preempted.
d128 5
a132 1
		preempt(NULL);
a199 1
	caddr_t onfault;
a479 2
		onfault = p->p_addr->u_pcb.pcb_onfault;
		p->p_addr->u_pcb.pcb_onfault = NULL;
a480 1
		p->p_addr->u_pcb.pcb_onfault = onfault;
@


1.31.6.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d756 3
a758 2
child_return(arg)
	void *arg;
a759 2
	struct proc *p = (struct proc *)arg;
	struct trapframe *tf = p->p_md.md_regs;
d761 2
a762 2
	tf->tf_eax = 0;
	tf->tf_eflags &= ~PSL_C;
d764 1
a764 1
	userret(p, tf->tf_eip, 0);
@


1.31.6.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31.6.5 2001/11/13 21:00:52 niklas Exp $	*/
d265 1
a265 2
		panic("trap type %d, code=%x, pc=%x",
		    type, frame.tf_err, frame.tf_eip);
d419 3
a421 3
		vm_offset_t va;
		struct vmspace *vm = p->p_vmspace;
		struct vm_map *map;
d423 1
a423 1
		extern struct vm_map *kernel_map;
d472 1
a472 1
		if (rv == 0) {
d568 2
a569 1
	if (uvm_fault(&vm->vm_map, va, 0, VM_PROT_READ | VM_PROT_WRITE))
@


1.31.6.7
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d420 1
a420 1
		vm_offset_t va, fa;
d429 1
a429 2
		fa = (vm_offset_t)rcr2();
		va = trunc_page(fa);
d488 1
a488 1
		sv.sival_int = fa;
@


1.31.6.8
log
@Merge in -current from about a week ago
@
text
@d94 4
a97 4
static __inline void userret(struct proc *, int, u_quad_t);
void trap(struct trapframe);
int trapwrite(unsigned);
void syscall(struct trapframe);
@


1.31.6.9
log
@Sync the SMP branch with 3.3
@
text
@a59 3
#include "systrace.h"
#include <dev/systrace.h>

d181 2
a182 1
	extern char resume_iret[], resume_pop_ds[], resume_pop_es[];
d406 6
d420 1
a420 1
		vaddr_t va, fa;
d424 1
d429 1
a429 1
		fa = (vaddr_t)rcr2();
d549 2
a550 1
trapwrite(unsigned int addr)
d552 1
a552 1
	vaddr_t va;
d557 1
a557 1
	va = trunc_page((vaddr_t)addr);
d640 1
a640 1
		copyin(params, &code, sizeof(int));
d658 1
a658 1
		copyin(params + _QUAD_LOWWORD * sizeof(int), &code, sizeof(int));
d673 1
a673 1
		 * Linux passes the args in ebx, ecx, edx, esi, edi, ebp, in
a676 2
		case 24:
			args[5] = frame.tf_ebp;
d714 1
a714 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		orig_error = error = systrace_redirect(code, p, args, rval);
	else
#endif
		orig_error = error = (*callp->sy_call)(p, args, rval);
@


1.31.6.10
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31.6.9 2003/03/27 23:26:55 niklas Exp $	*/
d328 3
a330 6
		if (ftype == VM_PROT_READ) {
			ftype |= VM_PROT_EXECUTE;
			/* XXX force %cr2 register have fault address */
			__asm __volatile("movl %0,%%cr2" :: "r" (frame.tf_eip));
		}
		goto page_fault;
d414 1
a414 1
	page_fault:
@


1.31.6.11
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31.6.10 2003/05/13 19:42:08 ho Exp $	*/
a189 1
	uint32_t cr2;
a336 1
		KERNEL_PROC_LOCK(p);
a337 1
		KERNEL_PROC_UNLOCK(p);
a342 1
		KERNEL_PROC_LOCK(p);
a343 1
		KERNEL_PROC_UNLOCK(p);
a347 1
		KERNEL_PROC_LOCK(p);
a348 1
		KERNEL_PROC_UNLOCK(p);
a352 1
		KERNEL_PROC_LOCK(p);
a353 1
		KERNEL_PROC_UNLOCK(p);
a357 1
		KERNEL_PROC_LOCK(p);
a358 1
		KERNEL_PROC_UNLOCK(p);
a364 1
			KERNEL_PROC_LOCK(p);
a365 1
			KERNEL_PROC_UNLOCK(p);
a377 1
		KERNEL_PROC_LOCK(p);
a378 1
		KERNEL_PROC_UNLOCK(p);
a383 1
		KERNEL_PROC_LOCK(p);
a384 1
		KERNEL_PROC_UNLOCK(p);
a390 1
		KERNEL_PROC_LOCK(p);
a391 1
		KERNEL_PROC_UNLOCK(p);
a394 1
		KERNEL_PROC_LOCK(p);
a395 1
		KERNEL_PROC_UNLOCK(p);
a398 1
		KERNEL_PROC_LOCK(p);
a399 1
		KERNEL_PROC_UNLOCK(p);
a403 1
		KERNEL_PROC_LOCK(p);
a404 1
		KERNEL_PROC_UNLOCK(p);
a409 15
#ifdef LOCKDEBUG
		/* If we page-fault while in scheduler, we're doomed. */
		if (simple_lock_held(&sched_lock))
			goto we_re_toast;
#endif

#ifdef MULTIPROCESSOR
		/*
		 * process doing kernel-mode page fault must have
		 * been running with big lock held
		 */
		if ((p->p_flag & P_BIGLOCK) == 0)
			goto we_re_toast;
#endif

d416 1
a416 4
		cr2 = rcr2();
		KERNEL_LOCK(LK_CANRECURSE|LK_EXCLUSIVE);
		goto faultcommon;

d420 1
a420 1
		struct vmspace *vm;
a424 4
		cr2 = rcr2();
		KERNEL_PROC_LOCK(p);
	faultcommon:
		vm = p->p_vmspace;
d427 1
a427 1
		fa = (vaddr_t)cr2;
d475 1
a475 2
			if (type == T_PAGEFLT) {
				KERNEL_UNLOCK();
a476 2
			}
			KERNEL_PROC_UNLOCK(p);
d481 1
a481 2
			if (pcb->pcb_onfault != 0) {
				KERNEL_UNLOCK();
a482 1
			}
a488 1
		KERNEL_PROC_UNLOCK(p);
a502 1
		KERNEL_PROC_LOCK(p);
a503 1
		KERNEL_PROC_UNLOCK(p);
a509 1
		KERNEL_PROC_LOCK(p);
a510 1
		KERNEL_PROC_UNLOCK(p);
a712 1
	KERNEL_PROC_LOCK(p);
a718 1
	KERNEL_PROC_UNLOCK(p);
d755 1
a755 2
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_PROC_LOCK(p);
a756 2
		KERNEL_PROC_UNLOCK(p);
	}
a769 4
#ifdef notyet
	KERNEL_PROC_UNLOCK(p);
#endif

a772 1
		KERNEL_PROC_LOCK(p);
a773 1
		KERNEL_PROC_UNLOCK(p);
@


1.31.6.12
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d329 6
a334 8
		/* If pmap_exec_fixup does something, let's retry the trap. */
		if (pmap_exec_fixup(&p->p_vmspace->vm_map, &frame,
		    &p->p_addr->u_pcb))
			goto out;

		sv.sival_int = frame.tf_eip;
		trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, sv);
		goto out;
d460 1
@


1.31.6.13
log
@Go back to defining simplelocks as noops, even if MULTIPROCESSOR.  Instead use
a new real simple recursive-lock capable lock implementation for the few
necessary locks (kernel, scheduler, tlb shootdown, printf and ddb MP).
This because we cannot trust the old fine-grained locks spread out all over
our kernel, and not really tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31.6.12 2003/05/16 00:29:39 niklas Exp $	*/
a438 1
#ifdef notyet
a439 3
#else
		if (__mp_lock_held(&sched_lock))
#endif
@


1.31.6.14
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31.6.13 2003/05/18 17:41:16 niklas Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.31.6.15
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a89 3
#ifdef COMPAT_AOUT
extern struct emul emul_aout;
#endif
d381 1
a381 1
#if defined(GPL_MATH_EMULATE)
d562 1
a562 1
#if defined(GPL_MATH_EMULATE)
a650 3
#ifdef DIAGNOSTIC
	int ocpl = lapic_tpr;
#endif
a707 3
#ifdef COMPAT_AOUT
		    && p->p_emul != &emul_aout
#endif
a818 8
	}
#endif
#ifdef DIAGNOSTIC
	if (lapic_tpr != ocpl) {
		printf("WARNING: SPL (0x%x) NOT LOWERED ON "
		    "syscall(0x%x, 0x%x, 0x%x, 0x%x...) EXIT, PID %d\n",
		    lapic_tpr, code, args[0], args[1], args[2], p->p_pid);
		lapic_tpr = ocpl;
@


1.31.6.16
log
@Remove bogus P_BIGLOCK test, copyin is called before biglock acquired in syscall
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.31.6.15 2004/02/19 10:48:42 niklas Exp $	*/
d443 9
@


1.31.6.17
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d85 1
a85 1
extern struct emul emul_freebsd_aout, emul_freebsd_elf;
d702 2
a703 2
		    && p->p_emul != &emul_freebsd_aout
		    && p->p_emul != &emul_freebsd_elf
@


1.31.6.18
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d135 1
a135 1
	p->p_cpu->ci_schedstate.spc_curpriority = p->p_priority;
@


1.30
log
@cnt.foo -> uvmexp.bar
vm_fault -> uvm_fault
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.29 1999/02/12 19:40:12 deraadt Exp $	*/
d327 5
@


1.29
log
@do not accept T_TRCTRAP DDB inside the osyscall stub; weingart
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.28 1999/02/10 08:07:20 deraadt Exp $	*/
d65 4
d200 3
d204 1
d351 3
d355 1
d462 3
d466 1
d470 3
d474 1
d478 3
d482 1
d495 4
d501 1
d570 5
d578 1
d604 3
d608 1
@


1.28
log
@branding support and freebsd elf
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.27 1998/08/20 19:46:35 deraadt Exp $	*/
d223 20
a478 7

#ifndef DDB
	/* XXX need to deal with this when DDB is present, too */
	case T_TRCTRAP:	/* kernel trace trap; someone single stepping lcall's */
			/* syscall has to turn off the trace bit itself */
		return;
#endif
@


1.27
log
@avoid double fault during early boot; rvb
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.26 1998/02/22 21:35:28 niklas Exp $	*/
d85 1
a85 1
extern struct emul emul_freebsd;
d607 2
a608 1
		    && p->p_emul != &emul_freebsd
@


1.26
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.25 1997/09/08 22:51:36 downsj Exp $	*/
d393 2
@


1.25
log
@Fix SYS__syscall handler for BSD/OS.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.24 1997/07/25 01:46:11 mickey Exp $	*/
d194 1
d297 2
a298 1
		trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, (caddr_t)rcr2());
a301 3
		trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, frame.tf_eip);
		goto out;

d303 2
a304 1
		trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, frame.tf_eip);
d308 2
a309 1
		trapsignal(p, SIGBUS, vftype, BUS_ADRALN, frame.tf_eip);
d313 2
a314 1
		trapsignal(p, SIGILL, type &~ T_USER, ILL_PRVOPC, frame.tf_eip);
d318 2
a319 1
		trapsignal(p, SIGILL, type &~ T_USER, ILL_COPROC, frame.tf_eip);
d338 2
a339 1
		trapsignal(p, rv, type &~ T_USER, FPE_FLTINV, frame.tf_eip);
d344 2
a345 1
		trapsignal(p, SIGKILL, type &~ T_USER, FPE_FLTINV, frame.tf_eip);
d351 2
a352 1
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_FLTSUB, frame.tf_eip);
d355 2
a356 1
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_INTOVF, frame.tf_eip);
d359 2
a360 1
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_INTDIV, frame.tf_eip);
d364 2
a365 1
		trapsignal(p, SIGFPE, frame.tf_err, FPE_INTOVF, frame.tf_eip);
d453 2
a454 1
		trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, (caddr_t)rcr2());
d466 2
a467 1
		trapsignal(p, SIGTRAP, type &~ T_USER, TRAP_BRKPT, (caddr_t)rcr2());
d473 2
a474 1
		trapsignal(p, SIGTRAP, type &~ T_USER, TRAP_TRACE, (caddr_t)rcr2());
@


1.24
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.23 1997/07/25 01:34:00 mickey Exp $	*/
d87 3
d591 1
d593 4
a596 4
		/* FreeBSD has a same function in SYS___syscall */
		if (callp != sysent && p->p_emul != &emul_freebsd)
#else
		if (callp != sysent)
d598 1
@


1.23
log
@init uninitialized
remove dumb var
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.22 1997/04/05 21:24:48 flipk Exp $	*/
d441 1
a441 1
		trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, vv);
@


1.22
log
@do not up wiring count for page tables (especially those actually
owned by the kernel pmap). Chuck Cranor (chuck@@maria.wustl.edu) and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.21 1997/04/04 16:14:09 mickey Exp $	*/
d214 2
a215 1
	}
a379 1
		caddr_t vv = (caddr_t)rcr2();
d381 1
a381 1
		va = trunc_page((vm_offset_t)vv);
@


1.21
log
@add 'machine check' trap for Pentium and PPro cpus.
no special handler for it. i guess there will be rare cases when
you receive it, and then you should repair your cpu, since
it happens on internal cpu error.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.20 1997/02/09 03:53:58 tholo Exp $	*/
a427 6
			va = trunc_page(vtopte(va));
			/* for page table, increment wiring as long as
			   not a page table fault as well */
			if (!v && map != kernel_map)
				vm_map_pageable(map, va, round_page(va+1),
				    FALSE);
@


1.20
log
@Use the instruction pointer from the trapframe many places CR2 does not
hold valid data.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.19 1997/02/08 23:23:57 tholo Exp $	*/
d156 1
a156 1
	"FPU operand fetch fault",		/* 14 T_FPOPFLT */
d160 2
a161 1
	"reserved trap",			/* 18 T_RESERVED */
@


1.19
log
@Give correct signal information on integer overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.18 1997/02/04 17:04:37 deraadt Exp $	*/
d291 3
d295 1
a295 1
		trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, (caddr_t)rcr2());
d299 1
a299 1
		trapsignal(p, SIGSEGV, vftype, SEGV_MAPERR, (caddr_t)rcr2());
d303 1
a303 1
		trapsignal(p, SIGBUS, vftype, BUS_ADRALN, (caddr_t)rcr2());
d307 1
a307 1
		trapsignal(p, SIGILL, type &~ T_USER, ILL_PRVOPC, (caddr_t)rcr2());
d311 1
a311 1
		trapsignal(p, SIGILL, type &~ T_USER, ILL_COPROC, (caddr_t)rcr2());
d330 1
a330 1
		trapsignal(p, rv, type &~ T_USER, FPE_FLTINV, (caddr_t)rcr2());
d335 1
a335 1
		trapsignal(p, SIGKILL, type &~ T_USER, FPE_FLTINV, (caddr_t)rcr2());
d341 1
a341 1
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_FLTSUB, (caddr_t)rcr2());
d344 1
a344 1
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_INTOVF, (caddr_t)rcr2());
d347 1
a347 1
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_INTDIV, (caddr_t)rcr2());
d351 1
a351 1
		trapsignal(p, SIGFPE, frame.tf_err, FPE_INTOVF, (caddr_t)rcr2());
@


1.18
log
@VM_PROT_* for si_trapno in SIGBUS/SIGSEGV
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.17 1997/02/04 02:16:51 deraadt Exp $	*/
d341 1
a341 1
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_FLTOVF, (caddr_t)rcr2());
@


1.17
log
@T_DIVIDE -> FPE_INTDIV
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.16 1997/02/03 17:35:09 deraadt Exp $	*/
d189 1
d193 7
d292 1
a292 1
		trapsignal(p, SIGSEGV, type &~ T_USER, SEGV_MAPERR, (caddr_t)rcr2());
d296 1
a296 1
		trapsignal(p, SIGSEGV, type &~ T_USER, SEGV_MAPERR, (caddr_t)rcr2());
d300 1
a300 1
		trapsignal(p, SIGBUS, type &~ T_USER, BUS_ADRALN, (caddr_t)rcr2());
a372 1
		vm_prot_t ftype;
a389 4
		if (frame.tf_err & PGEX_W)
			ftype = VM_PROT_READ | VM_PROT_WRITE;
		else
			ftype = VM_PROT_READ;
d443 1
a443 1
		trapsignal(p, SIGSEGV, T_PAGEFLT, SEGV_ACCERR, vv);
@


1.16
log
@for SIGxxx always use xxx_* types as error code
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.15 1997/02/01 21:53:29 deraadt Exp $	*/
d336 1
a336 1
		trapsignal(p, SIGFPE, type &~ T_USER, FPE_FLTDIV, (caddr_t)rcr2());
@


1.15
log
@add type & union sigval args to sendsig/trapsignal
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.14 1997/01/27 22:48:01 deraadt Exp $	*/
d288 1
a288 1
		trapsignal(p, SIGSEGV, type &~ T_USER, ILL_BADSTK, (caddr_t)rcr2());
d300 1
a300 1
		trapsignal(p, SIGILL, type &~ T_USER, FPE_FLTINV, (caddr_t)rcr2());
@


1.14
log
@add another parameter to trapsignal() and sendsig() -- fault addr to be
delivered with in the siginfo information
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.13 1997/01/18 15:17:38 niklas Exp $	*/
d284 3
d288 1
a288 1
		trapsignal(p, SIGSEGV, type &~ T_USER, (caddr_t)rcr2());
d292 1
a292 1
		trapsignal(p, SIGBUS, type &~ T_USER, (caddr_t)rcr2());
d296 3
d300 1
a300 1
		trapsignal(p, SIGILL, type &~ T_USER, (caddr_t)rcr2());
d319 1
a319 1
		trapsignal(p, rv, type &~ T_USER, (caddr_t)rcr2());
d324 1
a324 1
		trapsignal(p, SIGKILL, type &~ T_USER, (caddr_t)rcr2());
d330 2
d333 2
d336 1
a336 1
		trapsignal(p, SIGFPE, type &~ T_USER, (caddr_t)rcr2());
d340 1
a340 1
		trapsignal(p, SIGFPE, frame.tf_err, (caddr_t)rcr2());
d440 1
a440 1
		trapsignal(p, SIGSEGV, T_PAGEFLT, vv);
d452 2
d458 1
a458 1
		trapsignal(p, SIGTRAP, type &~ T_USER, (caddr_t)rcr2());
@


1.13
log
@Do not doubletrap when curproc->p_addr is zero, as it is during autoconfig.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.12 1996/10/17 13:36:45 deraadt Exp $	*/
d285 1
a285 1
		trapsignal(p, SIGSEGV, type &~ T_USER);
d289 1
a289 1
		trapsignal(p, SIGBUS, type &~ T_USER);
d294 1
a294 1
		trapsignal(p, SIGILL, type &~ T_USER);
d313 1
a313 1
		trapsignal(p, rv, type &~ T_USER);
d318 1
a318 1
		trapsignal(p, SIGKILL, type &~ T_USER);
d326 1
a326 1
		trapsignal(p, SIGFPE, type &~ T_USER);
d330 1
a330 1
		trapsignal(p, SIGFPE, frame.tf_err);
d358 1
d360 1
a360 1
		va = trunc_page((vm_offset_t)rcr2());
d430 1
a430 1
		trapsignal(p, SIGSEGV, T_PAGEFLT);
d446 1
a446 1
		trapsignal(p, SIGTRAP, type &~ T_USER);
@


1.12
log
@more SIGBUS garbage
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.11 1996/08/27 10:46:52 downsj Exp $	*/
d230 7
a236 5
		pcb = &p->p_addr->u_pcb;
		if (pcb->pcb_onfault != 0) {
		copyfault:
			frame.tf_eip = (int)pcb->pcb_onfault;
			return;
d334 1
a334 1
		if (p == 0)
@


1.11
log
@Add:
	* GPL_MATH_EMULATE: fpemul
	* ALWAYS_MATH_EMULATE: causes npx probe to always fail.
	* better fp context in struct pcb.
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.10 1996/05/10 12:44:49 deraadt Exp $	*/
d283 3
@


1.10
log
@update netbsd tag
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.7 1996/04/21 22:16:40 deraadt Exp $	*/
d301 1
a301 1
#ifdef MATH_EMULATE
d437 1
a437 1
#ifdef MATH_EMULATE
@


1.9
log
@sync with 0504; prototype changes
@
text
@d2 1
a2 1
/*	$NetBSD: trap.c,v 1.94 1996/05/03 19:42:31 christos Exp $	*/
@


1.8
log
@bring back change in rev 1.4: we do not do SIGBUS the wrong way
@
text
@d2 1
a2 1
/*	$NetBSD: trap.c,v 1.93 1996/04/15 00:20:32 mycroft Exp $	*/
d70 3
d90 5
d99 1
a99 1
static inline void
d184 1
a184 1
	struct pcb *pcb;
d197 1
a197 1
		printf("curproc %x\n", curproc);
d374 1
a374 1
			printf("trap: bad kernel access at %x\n", va);
d420 1
a420 1
			printf("vm_fault(%x, %x, %x, 0) -> %x\n",
d437 1
d439 1
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: trap.c,v 1.6 1996/03/19 21:09:23 mickey Exp $	*/
d76 1
a77 1
#include <sys/exec.h>
d416 1
a416 5
		trapsignal(p, (rv == KERN_PROTECTION_FAILURE
#ifdef COMPAT_LINUX
		    && p->p_emul != &emul_linux_aout && p->p_emul != &emul_linux_elf
#endif
		    ) ? SIGBUS : SIGSEGV, T_PAGEFLT);
@


1.6
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 2
a2 2
/*	$OpenBSD: trap.c,v 1.5 1996/02/28 14:38:46 mickey Exp $	*/
/*	$NetBSD: trap.c,v 1.92 1996/01/08 13:51:38 mycroft Exp $	*/
d416 5
a420 2
		trapsignal(p, (rv == KERN_PROTECTION_FAILURE)
		    ? SIGBUS : SIGSEGV, T_PAGEFLT);
a433 1
		frame.tf_eflags &= ~PSL_T;
@


1.5
log
@Small changes from NetBSD (including /usr/include dependencies, and so).
@
text
@d1 2
a2 1
/*	$OpenBSD: trap.c,v 1.92 1996/01/08 13:51:38 mycroft Exp $	*/
@


1.4
log
@SIGBUS is an alignment fault. SIGSEGV is an access violation
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.92 1996/01/08 13:51:38 mycroft Exp $	*/
d415 2
a416 1
		trapsignal(p, SIGSEGV, T_PAGEFLT);
@


1.3
log
@from netbsd; VM86 support, by John Kohl, touched up a bit by charles
@
text
@d415 1
a415 2
		trapsignal(p, (rv == KERN_PROTECTION_FAILURE)
		    ? SIGBUS : SIGSEGV, T_PAGEFLT);
@


1.2
log
@from netbsd; Return 0 in the child, not the parent pid.
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.91 1995/12/09 05:00:27 mycroft Exp $	*/
d265 7
a273 1
	case T_PROTFLT|T_USER:		/* protection fault */
d529 11
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: trap.c,v 1.89.2.1 1995/10/15 06:54:03 mycroft Exp $	*/
d653 1
a653 10
#ifdef COMPAT_LINUX
	if (p->p_emul == &emul_linux_aout || p->p_emul == &emul_linux_elf) {
		frame.tf_eax = 0;
		frame.tf_edx = 0;
	} else
#endif
	{
		frame.tf_eax = p->p_pid;
		frame.tf_edx = 1;
	}
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
