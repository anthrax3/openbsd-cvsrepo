head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.12
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.10
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.6
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.4.0.20
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.16
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.14
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.12
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.10
	OPENBSD_5_0:1.4.0.8
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.6
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.9
date	2015.04.25.21.31.24;	author guenther;	state Exp;
branches;
next	1.8;
commitid	Jx2fq8kp0uEBpslo;

1.8
date	2014.10.17.20.37.57;	author sthen;	state Exp;
branches;
next	1.7;
commitid	s7jB18TtgTTta5r7;

1.7
date	2014.10.17.19.35.32;	author sthen;	state Exp;
branches;
next	1.6;
commitid	FcjWDvloUpMtxk2V;

1.6
date	2014.10.17.01.46.26;	author dlg;	state Exp;
branches;
next	1.5;
commitid	IJJrXsuNXPDjHg1o;

1.5
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.16.21.07.41;	author mk;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.07.01.36.43;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2008.12.03.15.46.06;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.22.17.45.20;	author oga;	state Exp;
branches;
next	;


desc
@@


1.9
log
@We now following the ABI and always clear cld on function entry, so remove
the extra CLD instructions from when that wasn't true

testing miod@@ krw@@
@
text
@/*	$OpenBSD: bus_space.c,v 1.8 2014/10/17 20:37:57 sthen Exp $ */
/*-
 * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1996 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1996 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1996 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/extent.h>

#include <machine/bus.h>

u_int8_t	i386_bus_space_io_read_1(bus_space_handle_t, bus_size_t);
u_int16_t	i386_bus_space_io_read_2(bus_space_handle_t, bus_size_t);
u_int32_t	i386_bus_space_io_read_4(bus_space_handle_t, bus_size_t);

void		i386_bus_space_io_read_multi_1(bus_space_handle_t, bus_size_t,
		    u_int8_t *, bus_size_t);
void		i386_bus_space_io_read_multi_2(bus_space_handle_t, bus_size_t,
		    u_int16_t *, bus_size_t);
void		i386_bus_space_io_read_multi_4(bus_space_handle_t, bus_size_t,
		    u_int32_t *, bus_size_t);

void		i386_bus_space_io_read_region_1(bus_space_handle_t, bus_size_t,
		    u_int8_t *, bus_size_t);
void		i386_bus_space_io_read_region_2(bus_space_handle_t, bus_size_t,
		    u_int16_t *, bus_size_t);
void		i386_bus_space_io_read_region_4(bus_space_handle_t, bus_size_t,
		    u_int32_t *, bus_size_t);

void		i386_bus_space_io_write_1(bus_space_handle_t, bus_size_t,
		    u_int8_t);
void		i386_bus_space_io_write_2(bus_space_handle_t, bus_size_t,
		    u_int16_t);
void		i386_bus_space_io_write_4(bus_space_handle_t, bus_size_t,
		    u_int32_t);

void		i386_bus_space_io_write_multi_1(bus_space_handle_t,
		    bus_size_t, const u_int8_t *, bus_size_t);
void		i386_bus_space_io_write_multi_2(bus_space_handle_t,
		    bus_size_t, const u_int16_t *, bus_size_t);
void		i386_bus_space_io_write_multi_4(bus_space_handle_t,
		    bus_size_t, const u_int32_t *, bus_size_t);

void		i386_bus_space_io_write_region_1(bus_space_handle_t,
		    bus_size_t, const u_int8_t *, bus_size_t);
void		i386_bus_space_io_write_region_2(bus_space_handle_t,
		    bus_size_t, const u_int16_t *, bus_size_t);
void		i386_bus_space_io_write_region_4(bus_space_handle_t,
		    bus_size_t, const u_int32_t *, bus_size_t);

void		i386_bus_space_io_set_multi_1(bus_space_handle_t, bus_size_t,
		    u_int8_t, size_t);
void		i386_bus_space_io_set_multi_2(bus_space_handle_t, bus_size_t,
		    u_int16_t, size_t);
void		i386_bus_space_io_set_multi_4(bus_space_handle_t, bus_size_t,
		    u_int32_t, size_t);

void		i386_bus_space_io_set_region_1(bus_space_handle_t, bus_size_t,
		    u_int8_t, size_t);
void		i386_bus_space_io_set_region_2(bus_space_handle_t, bus_size_t,
		    u_int16_t, size_t);
void		i386_bus_space_io_set_region_4(bus_space_handle_t, bus_size_t,
		    u_int32_t, size_t);

void		i386_bus_space_io_copy_1(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);
void		i386_bus_space_io_copy_2(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);
void		i386_bus_space_io_copy_4(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);

void *		i386_bus_space_io_vaddr(bus_space_handle_t);
paddr_t		i386_bus_space_io_mmap(bus_addr_t, off_t, int, int);

const struct i386_bus_space_ops i386_bus_space_io_ops = {
	i386_bus_space_io_read_1,
	i386_bus_space_io_read_2,
	i386_bus_space_io_read_4,
	i386_bus_space_io_read_multi_1,
	i386_bus_space_io_read_multi_2,
	i386_bus_space_io_read_multi_4,
	i386_bus_space_io_read_region_1,
	i386_bus_space_io_read_region_2,
	i386_bus_space_io_read_region_4,
	i386_bus_space_io_write_1,
	i386_bus_space_io_write_2,
	i386_bus_space_io_write_4,
	i386_bus_space_io_write_multi_1,
	i386_bus_space_io_write_multi_2,
	i386_bus_space_io_write_multi_4,
	i386_bus_space_io_write_region_1,
	i386_bus_space_io_write_region_2,
	i386_bus_space_io_write_region_4,
	i386_bus_space_io_set_multi_1,
	i386_bus_space_io_set_multi_2,
	i386_bus_space_io_set_multi_4,
	i386_bus_space_io_set_region_1,
	i386_bus_space_io_set_region_2,
	i386_bus_space_io_set_region_4,
	i386_bus_space_io_copy_1,
	i386_bus_space_io_copy_2,
	i386_bus_space_io_copy_4,
	i386_bus_space_io_vaddr,
};

u_int8_t	i386_bus_space_mem_read_1(bus_space_handle_t, bus_size_t);
u_int16_t	i386_bus_space_mem_read_2(bus_space_handle_t, bus_size_t);
u_int32_t	i386_bus_space_mem_read_4(bus_space_handle_t, bus_size_t);

void		i386_bus_space_mem_read_multi_1(bus_space_handle_t, bus_size_t,
		    u_int8_t *, bus_size_t);
void		i386_bus_space_mem_read_multi_2(bus_space_handle_t, bus_size_t,
		    u_int16_t *, bus_size_t);
void		i386_bus_space_mem_read_multi_4(bus_space_handle_t, bus_size_t,
		    u_int32_t *, bus_size_t);

void		i386_bus_space_mem_read_region_1(bus_space_handle_t, bus_size_t,
		    u_int8_t *, bus_size_t);
void		i386_bus_space_mem_read_region_2(bus_space_handle_t, bus_size_t,
		    u_int16_t *, bus_size_t);
void		i386_bus_space_mem_read_region_4(bus_space_handle_t, bus_size_t,
		    u_int32_t *, bus_size_t);

void		i386_bus_space_mem_write_1(bus_space_handle_t, bus_size_t,
		    u_int8_t);
void		i386_bus_space_mem_write_2(bus_space_handle_t, bus_size_t,
		    u_int16_t);
void		i386_bus_space_mem_write_4(bus_space_handle_t, bus_size_t,
		    u_int32_t);

void		i386_bus_space_mem_write_multi_1(bus_space_handle_t,
		    bus_size_t, const u_int8_t *, bus_size_t);
void		i386_bus_space_mem_write_multi_2(bus_space_handle_t,
		    bus_size_t, const u_int16_t *, bus_size_t);
void		i386_bus_space_mem_write_multi_4(bus_space_handle_t,
		    bus_size_t, const u_int32_t *, bus_size_t);

void		i386_bus_space_mem_write_region_1(bus_space_handle_t,
		    bus_size_t, const u_int8_t *, bus_size_t);
void		i386_bus_space_mem_write_region_2(bus_space_handle_t,
		    bus_size_t, const u_int16_t *, bus_size_t);
void		i386_bus_space_mem_write_region_4(bus_space_handle_t,
		    bus_size_t, const u_int32_t *, bus_size_t);

void		i386_bus_space_mem_set_multi_1(bus_space_handle_t, bus_size_t,
		    u_int8_t, size_t);
void		i386_bus_space_mem_set_multi_2(bus_space_handle_t, bus_size_t,
		    u_int16_t, size_t);
void		i386_bus_space_mem_set_multi_4(bus_space_handle_t, bus_size_t,
		    u_int32_t, size_t);

void		i386_bus_space_mem_set_region_1(bus_space_handle_t, bus_size_t,
		    u_int8_t, size_t);
void		i386_bus_space_mem_set_region_2(bus_space_handle_t, bus_size_t,
		    u_int16_t, size_t);
void		i386_bus_space_mem_set_region_4(bus_space_handle_t, bus_size_t,
		    u_int32_t, size_t);

void		i386_bus_space_mem_copy_1(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);
void		i386_bus_space_mem_copy_2(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);
void		i386_bus_space_mem_copy_4(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);

void *		i386_bus_space_mem_vaddr(bus_space_handle_t);
paddr_t		i386_bus_space_mem_mmap(bus_addr_t, off_t, int, int);

const struct i386_bus_space_ops i386_bus_space_mem_ops = {
	i386_bus_space_mem_read_1,
	i386_bus_space_mem_read_2,
	i386_bus_space_mem_read_4,
	i386_bus_space_mem_read_multi_1,
	i386_bus_space_mem_read_multi_2,
	i386_bus_space_mem_read_multi_4,
	i386_bus_space_mem_read_region_1,
	i386_bus_space_mem_read_region_2,
	i386_bus_space_mem_read_region_4,
	i386_bus_space_mem_write_1,
	i386_bus_space_mem_write_2,
	i386_bus_space_mem_write_4,
	i386_bus_space_mem_write_multi_1,
	i386_bus_space_mem_write_multi_2,
	i386_bus_space_mem_write_multi_4,
	i386_bus_space_mem_write_region_1,
	i386_bus_space_mem_write_region_2,
	i386_bus_space_mem_write_region_4,
	i386_bus_space_mem_set_multi_1,
	i386_bus_space_mem_set_multi_2,
	i386_bus_space_mem_set_multi_4,
	i386_bus_space_mem_set_region_1,
	i386_bus_space_mem_set_region_2,
	i386_bus_space_mem_set_region_4,
	i386_bus_space_mem_copy_1,
	i386_bus_space_mem_copy_2,
	i386_bus_space_mem_copy_4,
	i386_bus_space_mem_vaddr,
};

u_int8_t
i386_bus_space_io_read_1(bus_space_handle_t h, bus_size_t o)
{
	return (inb(h + o));
}

u_int16_t
i386_bus_space_io_read_2(bus_space_handle_t h, bus_size_t o)
{
	return (inw(h + o));
}

u_int32_t
i386_bus_space_io_read_4(bus_space_handle_t h, bus_size_t o)
{
	return (inl(h + o));
}

void
i386_bus_space_io_read_multi_1(bus_space_handle_t h, bus_size_t o,
    u_int8_t *a, bus_size_t cnt)
{
	insb(h + o, a, cnt);
}

void
i386_bus_space_io_read_multi_2(bus_space_handle_t h, bus_size_t o,
    u_int16_t *a, bus_size_t cnt)
{
	insw(h + o, a, cnt);
}

void
i386_bus_space_io_read_multi_4(bus_space_handle_t h, bus_size_t o,
    u_int32_t *a, bus_size_t cnt)
{
	insl(h + o, a, cnt);
}

void
i386_bus_space_io_read_region_1(bus_space_handle_t h,
    bus_size_t o, u_int8_t *a, bus_size_t cnt)
{
	int _cnt = cnt;
	void *_addr = a;
	int _port = h + o;

	__asm volatile(
	"1:	inb %w2,%%al				;"
	"	stosb					;"
	"	incl %2					;"
	"	loop 1b"				:
	    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::
	    "%eax", "memory", "cc");
}

void
i386_bus_space_io_read_region_2(bus_space_handle_t h,
    bus_size_t o, u_int16_t *a, bus_size_t cnt)
{
	int _cnt = cnt;
	void *_addr = a;
	int _port = h + o;

	__asm volatile(
	"1:	inw %w2,%%ax				;"
	"	stosw					;"
	"	addl $2,%2				;"
	"	loop 1b"				:
	    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::
	    "%eax", "memory", "cc");
}

void
i386_bus_space_io_read_region_4(bus_space_handle_t h,
    bus_size_t o, u_int32_t *a, bus_size_t cnt)
{
	int _cnt = cnt;
	void *_addr = a;
	int _port = h + o;

	__asm volatile(
	"1:	inl %w2,%%eax				;"
	"	stosl					;"
	"	addl $4,%2				;"
	"	loop 1b"				:
	    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::
	    "%eax", "memory", "cc");
}

void
i386_bus_space_io_write_1(bus_space_handle_t h, bus_size_t o, u_int8_t v)
{
	outb(h + o, v);
}

void
i386_bus_space_io_write_2(bus_space_handle_t h, bus_size_t o, u_int16_t v)
{
	outw(h + o, v);
}

void
i386_bus_space_io_write_4(bus_space_handle_t h, bus_size_t o, u_int32_t v)
{
	outl(h + o, v);
}

void
i386_bus_space_io_write_multi_1(bus_space_handle_t h,
    bus_size_t o, const u_int8_t *a, bus_size_t cnt)
{
	outsb(h + o, a, cnt);
}

void
i386_bus_space_io_write_multi_2(bus_space_handle_t h,
    bus_size_t o, const u_int16_t *a, bus_size_t cnt)
{
	outsw(h + o, a, cnt);
}

void
i386_bus_space_io_write_multi_4(bus_space_handle_t h,
    bus_size_t o, const u_int32_t *a, bus_size_t cnt)
{
	outsl(h + o, a, cnt);
}

void
i386_bus_space_io_write_region_1(bus_space_handle_t h,
    bus_size_t o, const u_int8_t *a, bus_size_t cnt)
{
	int _port = h + o;
	const void *_addr = a;
	int _cnt = cnt;

	__asm volatile(
	"1:	lodsb					;"
	"	outb %%al,%w0				;"
	"	incl %0					;"
	"	loop 1b"				:
	    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::
	    "%eax", "memory", "cc");
}

void
i386_bus_space_io_write_region_2(bus_space_handle_t h,
    bus_size_t o, const u_int16_t *a, bus_size_t cnt)
{
	int _port = h + o;
	const void *_addr = a;
	int _cnt = cnt;

	__asm volatile(
	"1:	lodsw					;"
	"	outw %%ax,%w0				;"
	"	addl $2,%0				;"
	"	loop 1b"				:
	    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::
	    "%eax", "memory", "cc");
}

void
i386_bus_space_io_write_region_4(bus_space_handle_t h,
    bus_size_t o, const u_int32_t *a, bus_size_t cnt)
{
	int _port = h + o;
	const void *_addr = a;
	int _cnt = cnt;

	__asm volatile(
	"1:	lodsl					;"
	"	outl %%eax,%w0				;"
	"	addl $4,%0				;"
	"	loop 1b"				:
	    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::
	    "%eax", "memory", "cc");
}

void
i386_bus_space_io_set_multi_1(bus_space_handle_t h,
    bus_size_t o, u_int8_t v, size_t cnt)
{
	int _cnt = cnt;

	__asm volatile(
	"1:	outb %b2, %w1				;"
	"	loop 1b"				:
	    "+c" (_cnt) : "d" (h + o), "a" (v)		:
	    "cc");
}

void
i386_bus_space_io_set_multi_2(bus_space_handle_t h,
    bus_size_t o, u_int16_t v, size_t cnt)
{
	int _cnt = cnt;

	__asm volatile(
	"1:	outw %w2, %w1				;"
	"	loop 1b"				:
	    "+c" (_cnt) : "d" (h + o), "a" (v)	:
	    "cc");
}

void
i386_bus_space_io_set_multi_4(bus_space_handle_t h,
    bus_size_t o, u_int32_t v, size_t cnt)
{
	int _cnt = cnt;

	__asm volatile(
	"1:	outl %2,%w1				;"
	"	loop 1b"				:
	    "+c" (_cnt) : "d" (h + o), "a" (v)	:
		    "cc");
}

void
i386_bus_space_io_set_region_1(bus_space_handle_t h,
    bus_size_t o, u_int8_t v, size_t cnt)
{
	int _port = h + o;
	int _cnt = cnt;

	__asm volatile(
	"1:	outb %%al,%w0				;"
	"	incl %0					;"
	"	loop 1b"				:
	    "+d" (_port), "+c" (_cnt) : "a" (v)	:
		    "cc");
}

void
i386_bus_space_io_set_region_2(bus_space_handle_t h,
    bus_size_t o, u_int16_t v, size_t cnt)
{
	int _port = h + o;
	int _cnt = cnt;

	__asm volatile(
	"1:	outw %%ax,%w0				;"
	"	addl $2, %0				;"
	"	loop 1b"				:
	    "+d" (_port), "+c" (_cnt) : "a" (v)		:
		    "cc");
}

void
i386_bus_space_io_set_region_4(bus_space_handle_t h,
    bus_size_t o, u_int32_t v, size_t cnt)
{
	int _port = h + o;
	int _cnt = cnt;

	__asm volatile(
	"1:	outl %%eax,%w0				;"
	"	addl $4, %0				;"
	"	loop 1b"				:
	    "+d" (_port), "+c" (_cnt) : "a" (v)		:
	    "cc");
}

void
i386_bus_space_io_copy_1(bus_space_handle_t h1, bus_size_t o1,
     bus_space_handle_t h2, bus_size_t o2, bus_size_t cnt)
{
	int _port1 = h1 + o1;
	int _port2 = h2 + o2;
	int _cnt = cnt;

	__asm volatile(
	"1:	movl %k1,%%edx				;"
	"	inb  %%dx,%%al				;"
	"	movl %k0,%%edx				;"
	"	outb %%al,%%dx				;"
	"	incl %0					;"
	"	incl %1					;"
	"	loop 1b"				:
	    "+D" (_port2), "+S" (_port1), "+c" (_cnt)	::
	    "%edx", "%eax", "cc");
}

void
i386_bus_space_io_copy_2(bus_space_handle_t h1, bus_size_t o1,
     bus_space_handle_t h2, bus_size_t o2, bus_size_t cnt)
{
	int _port1 = h1 + o1;
	int _port2 = h2 + o2;
	int _cnt=cnt;

	__asm volatile(
	"1:	movl %k1,%%edx				;"
	"	inw  %%dx,%%ax				;"
	"	movl %k0,%%edx				;"
	"	outw %%ax,%%dx				;"
	"	addl $2, %0				;"
	"	addl $2, %1				;"
	"	loop 1b"				:
	    "+D" (_port2), "+S" (_port1), "+c" (_cnt)	::
	    "%edx", "%eax", "cc");
}

void
i386_bus_space_io_copy_4(bus_space_handle_t h1, bus_size_t o1,
     bus_space_handle_t h2, bus_size_t o2, bus_size_t cnt)
{
	int _port1 = h1 + o1;
	int _port2 = h2 + o2;
	int _cnt = cnt;

	__asm volatile(
	"1:	movl %k1,%%edx				;"
	"	inl  %%dx,%%eax				;"
	"	movl %k0,%%edx				;"
	"	outl %%eax,%%dx				;"
	"	addl $4, %0				;"
	"	addl $4, %1				;"
	"	loop 1b"				:
	    "+D" (_port2), "+S" (_port1), "+c" (_cnt)	::
	    "%edx", "%eax", "cc");
}

void *
i386_bus_space_io_vaddr(bus_space_handle_t h)
{
	return (NULL);
}

paddr_t
i386_bus_space_io_mmap(bus_addr_t addr, off_t off, int prot, int flags)
{
	/* Can't mmap I/O space. */
	return (-1);
}

u_int8_t
i386_bus_space_mem_read_1(bus_space_handle_t h, bus_size_t o)
{
	return (*(volatile u_int8_t *)((h) + (o)));
}

u_int16_t
i386_bus_space_mem_read_2(bus_space_handle_t h, bus_size_t o)
{
	return (*(volatile u_int16_t *)((h) + (o)));
}

u_int32_t
i386_bus_space_mem_read_4(bus_space_handle_t h, bus_size_t o)
{
	return (*(volatile u_int32_t *)((h) + (o)));
}

void
i386_bus_space_mem_read_multi_1(bus_space_handle_t h, bus_size_t o,
    u_int8_t *a, bus_size_t cnt)
{
	void *_addr=a;
	int _cnt=cnt;
	__asm volatile(
	"1:	movb (%2),%%al				;"
	"	stosb					;"
	"	loop 1b"				:
	    "+D" (_addr), "+c" (_cnt) : "r" (h + o)	:
	    "%eax", "memory", "cc");
}

void
i386_bus_space_mem_read_multi_2(bus_space_handle_t h, bus_size_t o,
    u_int16_t *a, bus_size_t cnt)
{
	void *_addr=a;
	int _cnt=cnt;
	__asm volatile(
	"1:	movw (%2),%%ax				;"
	"	stosw					;"
	"	loop 1b"				:
	    "+D" (_addr), "+c" (_cnt) : "r" ((h) + (o))	:
	    "%eax", "memory", "cc");
}

void
i386_bus_space_mem_read_multi_4(bus_space_handle_t h, bus_size_t o,
    u_int32_t *a, bus_size_t cnt)
{
	void *_addr=a;
	int _cnt=cnt;
	__asm volatile(
	"1:	movl (%2),%%eax				;"
	"	stosl					;"
	"	loop 1b"				:
	    "+D" (_addr), "+c" (_cnt) : "r" (h + o)	:
	    "%eax", "memory", "cc");
}

void
i386_bus_space_mem_read_region_1(bus_space_handle_t h,
    bus_size_t o, u_int8_t *a, bus_size_t cnt)
{
	int _cnt = cnt;
	void *_addr = a;
	int _port = h + o;

	i386_space_copy(_port, _addr, 1, _cnt);
}

void
i386_bus_space_mem_read_region_2(bus_space_handle_t h,
    bus_size_t o, u_int16_t *a, bus_size_t cnt)
{
	int _cnt = cnt;
	void *_addr = a;
	int _port = h + o;

	i386_space_copy(_port, _addr, 2, _cnt);
}

void
i386_bus_space_mem_read_region_4(bus_space_handle_t h,
    bus_size_t o, u_int32_t *a, bus_size_t cnt)
{
	int _cnt = cnt;
	void *_addr = a;
	int _port = h + o;

	i386_space_copy(_port, _addr, 4, _cnt);
}

void
i386_bus_space_mem_write_1(bus_space_handle_t h, bus_size_t o, u_int8_t v)
{
	((void)(*(volatile u_int8_t *)(h + o) = v));
}

void
i386_bus_space_mem_write_2(bus_space_handle_t h, bus_size_t o, u_int16_t v)
{
	((void)(*(volatile u_int16_t *)(h + o) = v));
}

void
i386_bus_space_mem_write_4(bus_space_handle_t h, bus_size_t o, u_int32_t v)
{
	((void)(*(volatile u_int32_t *)(h + o) = v));
}

void
i386_bus_space_mem_write_multi_1(bus_space_handle_t h,
    bus_size_t o, const u_int8_t *a, bus_size_t cnt)
{
	const void *_addr=a;
	int _cnt=cnt;

	__asm volatile(
	"1:	lodsb					;"
	"	movb %%al,(%2)				;"
	"	loop 1b"				:
	    "+S" (_addr), "+c" (_cnt) : "r" (h + o)	:
	    "%eax", "memory", "cc");
}

void
i386_bus_space_mem_write_multi_2(bus_space_handle_t h,
    bus_size_t o, const u_int16_t *a, bus_size_t cnt)
{
	const void *_addr = a;
	int _cnt = cnt;

	__asm volatile(
	"1:	lodsw					;"
	"	movw %%ax,(%2)				;"
	"	loop 1b"				:
	    "+S" (_addr), "+c" (_cnt) : "r" (h + o)	:
	    "%eax", "memory", "cc");
}

void
i386_bus_space_mem_write_multi_4(bus_space_handle_t h,
    bus_size_t o, const u_int32_t *a, bus_size_t cnt)
{
	const void *_addr=a;
	int _cnt=cnt;

	__asm volatile(
	"1:	lodsl					;"
	"	movl %%eax,(%2)				;"
	"	loop 1b"				:
	    "+S" (_addr), "+c" (_cnt) : "r" (h + o)	:
	    "%eax", "memory", "cc");
}

void
i386_bus_space_mem_write_region_1(bus_space_handle_t h,
    bus_size_t o, const u_int8_t *a, bus_size_t cnt)
{
	int _port = h + o;
	const void *_addr = a;
	int _cnt = cnt;

	i386_space_copy(_addr, _port, 1, _cnt);
}

void
i386_bus_space_mem_write_region_2(bus_space_handle_t h,
    bus_size_t o, const u_int16_t *a, bus_size_t cnt)
{
	int _port = h + o;
	const void *_addr = a;
	int _cnt = cnt;

	i386_space_copy(_addr, _port, 2, _cnt);
}

void
i386_bus_space_mem_write_region_4(bus_space_handle_t h,
    bus_size_t o, const u_int32_t *a, bus_size_t cnt)
{
	int _port = h + o;
	const void *_addr = a;
	int _cnt = cnt;

	i386_space_copy(_addr, _port, 4, _cnt);
}

void
i386_bus_space_mem_set_multi_1(bus_space_handle_t h,
    bus_size_t o, u_int8_t v, size_t cnt)
{
	int _cnt = cnt;

	__asm volatile(
	"1:	movb %b2, (%1)				;"
	"	loop 1b"				:
	    "+c" (_cnt) : "D" (h + o), "a" (v)		:
	    "cc", "memory");
}

void
i386_bus_space_mem_set_multi_2(bus_space_handle_t h,
    bus_size_t o, u_int16_t v, size_t cnt)
{
	int _cnt = cnt;

	__asm volatile(
	"1:	movw %w2, (%1)				;"
	"	loop 1b"				:
	    "+c" (_cnt) : "D" (h + o), "a" (v)		:
	    "cc", "memory");
}

void
i386_bus_space_mem_set_multi_4(bus_space_handle_t h,
    bus_size_t o, u_int32_t v, size_t cnt)
{
	int _cnt = cnt;

	__asm volatile(
	"1:	movl %2,(%1)				;"
	"	loop 1b"				:
	    "+c" (_cnt) : "D" (h + o), "a" (v)	:
	    "cc", "memory");
}

void
i386_bus_space_mem_set_region_1(bus_space_handle_t h,
    bus_size_t o, u_int8_t v, size_t cnt)
{
	int _port = h + o;
	int _cnt = cnt;

	__asm volatile(
	"	repne					;"
	"	stosb"					:
	    "+D" (_port), "+c" (_cnt) : "a" (v)	:
	    "memory", "cc");
}

void
i386_bus_space_mem_set_region_2(bus_space_handle_t h,
    bus_size_t o, u_int16_t v, size_t cnt)
{
	int _port = h + o;
	int _cnt = cnt;

	__asm volatile(
	"	repne					;"
	"	stosw"					:
	    "+D" (_port), "+c" (_cnt) : "a" (v)	:
	    "memory", "cc");
}

void
i386_bus_space_mem_set_region_4(bus_space_handle_t h,
    bus_size_t o, u_int32_t v, size_t cnt)
{
	int _port = h + o;
	int _cnt = cnt;

	__asm volatile(
	"	repne					;"
	"	stosl"					:
	    "+D" (_port), "+c" (_cnt) : "a" (v)	:
	    "memory", "cc");
}

void
i386_bus_space_mem_copy_1( bus_space_handle_t h1, bus_size_t o1,
     bus_space_handle_t h2, bus_size_t o2, bus_size_t cnt)
{
	int _port1 = h1 + o1;
	int _port2 = h2 + o2;
	int _cnt = cnt;

	i386_space_copy(_port1, _port2, 1, _cnt);
}

void
i386_bus_space_mem_copy_2( bus_space_handle_t h1, bus_size_t o1,
     bus_space_handle_t h2, bus_size_t o2, bus_size_t cnt)
{
	int _port1 = h1 + o1;
	int _port2 = h2 + o2;
	int _cnt=cnt;

	i386_space_copy(_port1, _port2, 2, _cnt);
}

void
i386_bus_space_mem_copy_4( bus_space_handle_t h1, bus_size_t o1,
     bus_space_handle_t h2, bus_size_t o2, bus_size_t cnt)
{
	int _port1 = h1 + o1;
	int _port2 = h2 + o2;
	int _cnt = cnt;

	i386_space_copy(_port1, _port2, 4, _cnt);
}

void *
i386_bus_space_mem_vaddr(bus_space_handle_t h)
{
	return ((void *)h);
}

paddr_t
i386_bus_space_mem_mmap(bus_addr_t addr, off_t off, int prot, int flags)
{
	/*
	 * "addr" is the base address of the device we're mapping.
	 * "off" is the offset into that device.
	 *
	 * Note we are called for each "page" in the device that
	 * the upper layers want to map.
	 */
	return (addr + off);
}
@


1.8
log
@reinstate i386/bus_space diff now that serial consoles are fixed in
sys/arch/i386/i386/bios.c, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.6 2014/10/17 01:46:26 dlg Exp $ */
d306 1
a306 1
	__asm volatile("cld				;"
d323 1
a323 1
	__asm volatile("cld				;"
d340 1
a340 1
	__asm volatile("cld				;"
d396 1
a396 1
	__asm volatile("cld				;"
d413 1
a413 1
	__asm volatile("cld				;"
d430 1
a430 1
	__asm volatile("cld				;"
d445 1
a445 1
	__asm volatile("cld				;"
d458 1
a458 1
	__asm volatile("cld				;"
d471 1
a471 1
	__asm volatile("cld				;"
d620 1
a620 1
	__asm volatile("cld				;"
d634 1
a634 1
	__asm volatile("cld				;"
d648 1
a648 1
	__asm volatile("cld				;"
d714 1
a714 1
	__asm volatile("cld				;"
d729 1
a729 1
	__asm volatile("cld				;"
d744 1
a744 1
	__asm volatile("cld				;"
d791 1
a791 1
	__asm volatile("cld				;"
d804 1
a804 1
	__asm volatile("cld				;"
d817 1
a817 1
	__asm volatile("cld				;"
d831 1
a831 1
	__asm volatile("cld				;"
d845 1
a845 1
	__asm volatile("cld				;"
d859 1
a859 1
	__asm volatile("cld				;"
@


1.7
log
@backout i386/bus_space diff for now, req'd by deraadt@@ - problems at boot

|	i386/bus_space.c:1.5->1.6
|	i386/machdep.c:1.551->1.552
|	include/bus.h:1.61->1.62
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.5 2014/03/29 18:09:29 guenther Exp $ */
d71 188
d260 1
a260 2
bus_space_read_1(bus_space_tag_t t, bus_space_handle_t h,
    bus_size_t o)
d262 1
a262 2
	return ((t) == I386_BUS_SPACE_IO ? (inb((h) + (o))) :
	    (*(volatile u_int8_t *)((h) + (o))));
d266 1
a266 2
bus_space_read_2(bus_space_tag_t t, bus_space_handle_t h,
    bus_size_t o)
d268 1
a268 2
	return ((t) == I386_BUS_SPACE_IO ? (inw((h) + (o))) :
	    (*(volatile u_int16_t *)((h) + (o))));
d272 1
a272 2
bus_space_read_4(bus_space_tag_t t, bus_space_handle_t h,
    bus_size_t o)
d274 1
a274 2
	return ((t) == I386_BUS_SPACE_IO ? (inl((h) + (o))) :
	    (*(volatile u_int32_t *)((h) + (o))));
a276 1

d278 1
a278 1
bus_space_read_multi_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d281 1
a281 12
	if (t == I386_BUS_SPACE_IO) {
		insb(h + o, a, cnt);
	} else {
		void *_addr=a;
		int _cnt=cnt;
		__asm volatile("cld				;"
		"1:	movb (%2),%%al				;"
		"	stosb					;"
		"	loop 1b"				:
		    "+D" (_addr), "+c" (_cnt) : "r" (h + o)	:
		    "%eax", "memory", "cc");
	}
d285 1
a285 1
bus_space_read_multi_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d288 1
a288 12
	if (t == I386_BUS_SPACE_IO) {
		insw(h + o, a, cnt);
	} else {
		void *_addr=a;
		int _cnt=cnt;
		__asm volatile("cld				;"
		"1:	movw (%2),%%ax				;"
		"	stosw					;"
		"	loop 1b"				:
		    "+D" (_addr), "+c" (_cnt) : "r" ((h) + (o))	:
		    "%eax", "memory", "cc");
	}
d290 1
d292 1
a292 1
bus_space_read_multi_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d295 1
a295 12
	if (t == I386_BUS_SPACE_IO) {
		insl(h + o, a, cnt);
	} else {
		void *_addr=a;
		int _cnt=cnt;
		__asm volatile("cld				;"
		"1:	movl (%2),%%eax				;"
		"	stosl					;"
		"	loop 1b"				:
		    "+D" (_addr), "+c" (_cnt) : "r" (h + o)	:
		    "%eax", "memory", "cc");
	}
d299 1
a299 1
bus_space_read_region_1(bus_space_tag_t t, bus_space_handle_t h,
d306 7
a312 10
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	inb %w2,%%al				;"
		"	stosb					;"
		"	incl %2					;"
		"	loop 1b"				:
		    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::
		    "%eax", "memory", "cc");
	} else
		i386_space_copy(_port, _addr, 1, _cnt);
d316 1
a316 1
bus_space_read_region_2(bus_space_tag_t t, bus_space_handle_t h,
d323 7
a329 10
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	inw %w2,%%ax				;"
		"	stosw					;"
		"	addl $2,%2				;"
		"	loop 1b"				:
		    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::
		    "%eax", "memory", "cc");
	} else
		i386_space_copy(_port, _addr, 2, _cnt);
d333 1
a333 1
bus_space_read_region_4(bus_space_tag_t t, bus_space_handle_t h,
d340 7
a346 10
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	inl %w2,%%eax				;"
		"	stosl					;"
		"	addl $4,%2				;"
		"	loop 1b"				:
		    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::
		    "%eax", "memory", "cc");
	} else
		i386_space_copy(_port, _addr, 4, _cnt);
d350 1
a350 2
bus_space_write_1(bus_space_tag_t t, bus_space_handle_t h,
    bus_size_t o, u_int8_t v)
d352 1
a352 4
	if (t == I386_BUS_SPACE_IO)
		outb(h + o, v);
	else
		((void)(*(volatile u_int8_t *)(h + o) = v));
d356 1
a356 2
bus_space_write_2(bus_space_tag_t t, bus_space_handle_t h,
    bus_size_t o, u_int16_t v)
d358 1
a358 4
	if ((t) == I386_BUS_SPACE_IO)
		outw(h + o, v);
	else
		((void)(*(volatile u_int16_t *)(h + o) = v));
d362 1
a362 2
bus_space_write_4(bus_space_tag_t t, bus_space_handle_t h,
    bus_size_t o, u_int32_t v)
d364 1
a364 4
	if ((t) == I386_BUS_SPACE_IO)
		outl(h + o, v);
	else
		((void)(*(volatile u_int32_t *)(h + o) = v));
d368 1
a368 1
bus_space_write_multi_1(bus_space_tag_t t, bus_space_handle_t h,
d371 1
a371 13
	if (t == I386_BUS_SPACE_IO) {
		outsb(h + o, a, cnt);
	} else {
		const void *_addr=a;
		int _cnt=cnt;

		__asm volatile("cld				;"
		"1:	lodsb					;"
		"	movb %%al,(%2)				;"
		"	loop 1b"				:
		    "+S" (_addr), "+c" (_cnt) : "r" (h + o)	:
		    "%eax", "memory", "cc");
	}
d375 1
a375 1
bus_space_write_multi_2(bus_space_tag_t t, bus_space_handle_t h,
d378 1
a378 13
	if (t == I386_BUS_SPACE_IO) {
		outsw(h + o, a, cnt);
	} else {
		const void *_addr = a;
		int _cnt = cnt;

		__asm volatile("cld				;"
		"1:	lodsw					;"
		"	movw %%ax,(%2)				;"
		"	loop 1b"				:
		    "+S" (_addr), "+c" (_cnt) : "r" (h + o)	:
		    "%eax", "memory", "cc");
	}
d380 1
d382 1
a382 1
bus_space_write_multi_4(bus_space_tag_t t, bus_space_handle_t h,
d385 1
a385 13
	if (t == I386_BUS_SPACE_IO) {
		outsl(h + o, a, cnt);
	} else {
		const void *_addr=a;
		int _cnt=cnt;

		__asm volatile("cld				;"
		"1:	lodsl					;"
		"	movl %%eax,(%2)				;"
		"	loop 1b"				:
		    "+S" (_addr), "+c" (_cnt) : "r" (h + o)	:
		    "%eax", "memory", "cc");
	}
d389 1
a389 1
bus_space_write_region_1(bus_space_tag_t t, bus_space_handle_t h,
d396 7
a402 10
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	lodsb					;"
		"	outb %%al,%w0				;"
		"	incl %0					;"
		"	loop 1b"				:
		    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::
		    "%eax", "memory", "cc");
	} else
		i386_space_copy(_addr, _port, 1, _cnt);
d406 1
a406 1
bus_space_write_region_2(bus_space_tag_t t, bus_space_handle_t h,
d413 7
a419 10
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	lodsw					;"
		"	outw %%ax,%w0				;"
		"	addl $2,%0				;"
		"	loop 1b"				:
		    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::
		    "%eax", "memory", "cc");
	} else
		i386_space_copy(_addr, _port, 2, _cnt);
d423 1
a423 1
bus_space_write_region_4(bus_space_tag_t t, bus_space_handle_t h,
d430 7
a436 10
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	lodsl					;"
		"	outl %%eax,%w0				;"
		"	addl $4,%0				;"
		"	loop 1b"				:
		    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::
		    "%eax", "memory", "cc");
	} else
		i386_space_copy(_addr, _port, 4, _cnt);
d440 1
a440 1
bus_space_set_multi_1(bus_space_tag_t t, bus_space_handle_t h,
d445 5
a449 13
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	outb %b2, %w1				;"
		"	loop 1b"				:
		    "+c" (_cnt) : "d" (h + o), "a" (v)		:
		    "cc");
	} else {
		__asm volatile("cld				;"
		"1:	movb %b2, (%1)				;"
		"	loop 1b"				:
		    "+c" (_cnt) : "D" (h + o), "a" (v)		:
		    "cc", "memory");
	}
d453 1
a453 1
bus_space_set_multi_2(bus_space_tag_t t, bus_space_handle_t h,
d458 5
a462 13
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	outw %w2, %w1				;"
		"	loop 1b"				:
		    "+c" (_cnt) : "d" (h + o), "a" (v)	:
		    "cc");
	} else {
		__asm volatile("cld				;"
		"1:	movw %w2, (%1)				;"
		"	loop 1b"				:
		    "+c" (_cnt) : "D" (h + o), "a" (v)		:
		    "cc", "memory");
	}
d466 1
a466 1
bus_space_set_multi_4(bus_space_tag_t t, bus_space_handle_t h,
d471 4
a474 5
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	outl %2,%w1				;"
		"	loop 1b"				:
		    "+c" (_cnt) : "d" (h + o), "a" (v)	:
a475 7
	} else {
		__asm volatile("cld				;"
		"1:	movl %2,(%1)				;"
		"	loop 1b"				:
		    "+c" (_cnt) : "D" (h + o), "a" (v)	:
		    "cc", "memory");
	}
d479 1
a479 1
bus_space_set_region_1(bus_space_tag_t t, bus_space_handle_t h,
d485 5
a489 6
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile(
		"1:	outb %%al,%w0				;"
		"	incl %0					;"
		"	loop 1b"				:
		    "+d" (_port), "+c" (_cnt) : "a" (v)	:
a490 7
	} else {
		__asm volatile("cld				;"
		"	repne					;"
		"	stosb"					:
		    "+D" (_port), "+c" (_cnt) : "a" (v)	:
		    "memory", "cc");
	}
d494 1
a494 1
bus_space_set_region_2(bus_space_tag_t t, bus_space_handle_t h,
d500 5
a504 6
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile(
		"1:	outw %%ax,%w0				;"
		"	addl $2, %0				;"
		"	loop 1b"				:
		    "+d" (_port), "+c" (_cnt) : "a" (v)		:
a505 7
	} else {
		__asm volatile("cld				;"
		"	repne					;"
		"	stosw"					:
		    "+D" (_port), "+c" (_cnt) : "a" (v)	:
		    "memory", "cc");
	}
d509 345
a853 1
bus_space_set_region_4(bus_space_tag_t t, bus_space_handle_t h,
d859 5
a863 14
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile(
		"1:	outl %%eax,%w0				;"
		"	addl $4, %0				;"
		"	loop 1b"				:
		    "+d" (_port), "+c" (_cnt) : "a" (v)		:
		    "cc");
	} else {
		__asm volatile("cld				;"
		"	repne					;"
		"	stosl"					:
		    "+D" (_port), "+c" (_cnt) : "a" (v)	:
		    "memory", "cc");
	}
d867 1
a867 1
bus_space_copy_1(bus_space_tag_t t, bus_space_handle_t h1, bus_size_t o1,
d874 1
a874 13
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile(
		"1:	movl %k1,%%edx				;"
		"	inb  %%dx,%%al				;"
		"	movl %k0,%%edx				;"
		"	outb %%al,%%dx				;"
		"	incl %0					;"
		"	incl %1					;"
		"	loop 1b"				:
		    "+D" (_port2), "+S" (_port1), "+c" (_cnt)	::
		    "%edx", "%eax", "cc");
	} else
		i386_space_copy(_port1, _port2, 1, _cnt);
d878 1
a878 1
bus_space_copy_2(bus_space_tag_t t, bus_space_handle_t h1, bus_size_t o1,
d884 2
a885 13
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile(
		"1:	movl %k1,%%edx				;"
		"	inw  %%dx,%%ax				;"
		"	movl %k0,%%edx				;"
		"	outw %%ax,%%dx				;"
		"	addl $2, %0				;"
		"	addl $2, %1				;"
		"	loop 1b"				:
		    "+D" (_port2), "+S" (_port1), "+c" (_cnt)	::
		    "%edx", "%eax", "cc");
	} else
		i386_space_copy(_port1, _port2, 2, _cnt);
d889 1
a889 1
bus_space_copy_4(bus_space_tag_t t, bus_space_handle_t h1, bus_size_t o1,
d896 20
a915 13
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile(
		"1:	movl %k1,%%edx				;"
		"	inl  %%dx,%%eax				;"
		"	movl %k0,%%edx				;"
		"	outl %%eax,%%dx				;"
		"	addl $4, %0				;"
		"	addl $4, %1				;"
		"	loop 1b"				:
		    "+D" (_port2), "+S" (_port1), "+c" (_cnt)	::
		    "%edx", "%eax", "cc");
	} else
		i386_space_copy(_port1, _port2, 4, _cnt);
@


1.6
log
@bring the twisting of bus_space from amd64 over to i386. this is:

src/sys/arch/amd64/amd64/bus_space.c r1.22
src/sys/arch/amd64/include/bus.h r1.27

instead of using the tag as an identifier for IO or memory mappings
that was checked inside the api, turn it into a pointer to a structure
of function pointers. the api then generally becomes a set of macros
that deref the function pointers on the callers behalf. the idea
is that following a pointer to very small functions is cheap compared
to doing compares continuously.

the kernel is smaller and the api is more cache friendly now.

the porting of this code from amd64 to i386 was done by kimberley manning
requested by and ok tedu@@
@
text
@a70 188
u_int8_t	i386_bus_space_io_read_1(bus_space_handle_t, bus_size_t);
u_int16_t	i386_bus_space_io_read_2(bus_space_handle_t, bus_size_t);
u_int32_t	i386_bus_space_io_read_4(bus_space_handle_t, bus_size_t);

void		i386_bus_space_io_read_multi_1(bus_space_handle_t, bus_size_t,
		    u_int8_t *, bus_size_t);
void		i386_bus_space_io_read_multi_2(bus_space_handle_t, bus_size_t,
		    u_int16_t *, bus_size_t);
void		i386_bus_space_io_read_multi_4(bus_space_handle_t, bus_size_t,
		    u_int32_t *, bus_size_t);

void		i386_bus_space_io_read_region_1(bus_space_handle_t, bus_size_t,
		    u_int8_t *, bus_size_t);
void		i386_bus_space_io_read_region_2(bus_space_handle_t, bus_size_t,
		    u_int16_t *, bus_size_t);
void		i386_bus_space_io_read_region_4(bus_space_handle_t, bus_size_t,
		    u_int32_t *, bus_size_t);

void		i386_bus_space_io_write_1(bus_space_handle_t, bus_size_t,
		    u_int8_t);
void		i386_bus_space_io_write_2(bus_space_handle_t, bus_size_t,
		    u_int16_t);
void		i386_bus_space_io_write_4(bus_space_handle_t, bus_size_t,
		    u_int32_t);

void		i386_bus_space_io_write_multi_1(bus_space_handle_t,
		    bus_size_t, const u_int8_t *, bus_size_t);
void		i386_bus_space_io_write_multi_2(bus_space_handle_t,
		    bus_size_t, const u_int16_t *, bus_size_t);
void		i386_bus_space_io_write_multi_4(bus_space_handle_t,
		    bus_size_t, const u_int32_t *, bus_size_t);

void		i386_bus_space_io_write_region_1(bus_space_handle_t,
		    bus_size_t, const u_int8_t *, bus_size_t);
void		i386_bus_space_io_write_region_2(bus_space_handle_t,
		    bus_size_t, const u_int16_t *, bus_size_t);
void		i386_bus_space_io_write_region_4(bus_space_handle_t,
		    bus_size_t, const u_int32_t *, bus_size_t);

void		i386_bus_space_io_set_multi_1(bus_space_handle_t, bus_size_t,
		    u_int8_t, size_t);
void		i386_bus_space_io_set_multi_2(bus_space_handle_t, bus_size_t,
		    u_int16_t, size_t);
void		i386_bus_space_io_set_multi_4(bus_space_handle_t, bus_size_t,
		    u_int32_t, size_t);

void		i386_bus_space_io_set_region_1(bus_space_handle_t, bus_size_t,
		    u_int8_t, size_t);
void		i386_bus_space_io_set_region_2(bus_space_handle_t, bus_size_t,
		    u_int16_t, size_t);
void		i386_bus_space_io_set_region_4(bus_space_handle_t, bus_size_t,
		    u_int32_t, size_t);

void		i386_bus_space_io_copy_1(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);
void		i386_bus_space_io_copy_2(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);
void		i386_bus_space_io_copy_4(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);

void *		i386_bus_space_io_vaddr(bus_space_handle_t);
paddr_t		i386_bus_space_io_mmap(bus_addr_t, off_t, int, int);

const struct i386_bus_space_ops i386_bus_space_io_ops = {
	i386_bus_space_io_read_1,
	i386_bus_space_io_read_2,
	i386_bus_space_io_read_4,
	i386_bus_space_io_read_multi_1,
	i386_bus_space_io_read_multi_2,
	i386_bus_space_io_read_multi_4,
	i386_bus_space_io_read_region_1,
	i386_bus_space_io_read_region_2,
	i386_bus_space_io_read_region_4,
	i386_bus_space_io_write_1,
	i386_bus_space_io_write_2,
	i386_bus_space_io_write_4,
	i386_bus_space_io_write_multi_1,
	i386_bus_space_io_write_multi_2,
	i386_bus_space_io_write_multi_4,
	i386_bus_space_io_write_region_1,
	i386_bus_space_io_write_region_2,
	i386_bus_space_io_write_region_4,
	i386_bus_space_io_set_multi_1,
	i386_bus_space_io_set_multi_2,
	i386_bus_space_io_set_multi_4,
	i386_bus_space_io_set_region_1,
	i386_bus_space_io_set_region_2,
	i386_bus_space_io_set_region_4,
	i386_bus_space_io_copy_1,
	i386_bus_space_io_copy_2,
	i386_bus_space_io_copy_4,
	i386_bus_space_io_vaddr,
};

u_int8_t	i386_bus_space_mem_read_1(bus_space_handle_t, bus_size_t);
u_int16_t	i386_bus_space_mem_read_2(bus_space_handle_t, bus_size_t);
u_int32_t	i386_bus_space_mem_read_4(bus_space_handle_t, bus_size_t);

void		i386_bus_space_mem_read_multi_1(bus_space_handle_t, bus_size_t,
		    u_int8_t *, bus_size_t);
void		i386_bus_space_mem_read_multi_2(bus_space_handle_t, bus_size_t,
		    u_int16_t *, bus_size_t);
void		i386_bus_space_mem_read_multi_4(bus_space_handle_t, bus_size_t,
		    u_int32_t *, bus_size_t);

void		i386_bus_space_mem_read_region_1(bus_space_handle_t, bus_size_t,
		    u_int8_t *, bus_size_t);
void		i386_bus_space_mem_read_region_2(bus_space_handle_t, bus_size_t,
		    u_int16_t *, bus_size_t);
void		i386_bus_space_mem_read_region_4(bus_space_handle_t, bus_size_t,
		    u_int32_t *, bus_size_t);

void		i386_bus_space_mem_write_1(bus_space_handle_t, bus_size_t,
		    u_int8_t);
void		i386_bus_space_mem_write_2(bus_space_handle_t, bus_size_t,
		    u_int16_t);
void		i386_bus_space_mem_write_4(bus_space_handle_t, bus_size_t,
		    u_int32_t);

void		i386_bus_space_mem_write_multi_1(bus_space_handle_t,
		    bus_size_t, const u_int8_t *, bus_size_t);
void		i386_bus_space_mem_write_multi_2(bus_space_handle_t,
		    bus_size_t, const u_int16_t *, bus_size_t);
void		i386_bus_space_mem_write_multi_4(bus_space_handle_t,
		    bus_size_t, const u_int32_t *, bus_size_t);

void		i386_bus_space_mem_write_region_1(bus_space_handle_t,
		    bus_size_t, const u_int8_t *, bus_size_t);
void		i386_bus_space_mem_write_region_2(bus_space_handle_t,
		    bus_size_t, const u_int16_t *, bus_size_t);
void		i386_bus_space_mem_write_region_4(bus_space_handle_t,
		    bus_size_t, const u_int32_t *, bus_size_t);

void		i386_bus_space_mem_set_multi_1(bus_space_handle_t, bus_size_t,
		    u_int8_t, size_t);
void		i386_bus_space_mem_set_multi_2(bus_space_handle_t, bus_size_t,
		    u_int16_t, size_t);
void		i386_bus_space_mem_set_multi_4(bus_space_handle_t, bus_size_t,
		    u_int32_t, size_t);

void		i386_bus_space_mem_set_region_1(bus_space_handle_t, bus_size_t,
		    u_int8_t, size_t);
void		i386_bus_space_mem_set_region_2(bus_space_handle_t, bus_size_t,
		    u_int16_t, size_t);
void		i386_bus_space_mem_set_region_4(bus_space_handle_t, bus_size_t,
		    u_int32_t, size_t);

void		i386_bus_space_mem_copy_1(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);
void		i386_bus_space_mem_copy_2(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);
void		i386_bus_space_mem_copy_4(bus_space_handle_t, bus_size_t,
		    bus_space_handle_t, bus_size_t, size_t);

void *		i386_bus_space_mem_vaddr(bus_space_handle_t);
paddr_t		i386_bus_space_mem_mmap(bus_addr_t, off_t, int, int);

const struct i386_bus_space_ops i386_bus_space_mem_ops = {
	i386_bus_space_mem_read_1,
	i386_bus_space_mem_read_2,
	i386_bus_space_mem_read_4,
	i386_bus_space_mem_read_multi_1,
	i386_bus_space_mem_read_multi_2,
	i386_bus_space_mem_read_multi_4,
	i386_bus_space_mem_read_region_1,
	i386_bus_space_mem_read_region_2,
	i386_bus_space_mem_read_region_4,
	i386_bus_space_mem_write_1,
	i386_bus_space_mem_write_2,
	i386_bus_space_mem_write_4,
	i386_bus_space_mem_write_multi_1,
	i386_bus_space_mem_write_multi_2,
	i386_bus_space_mem_write_multi_4,
	i386_bus_space_mem_write_region_1,
	i386_bus_space_mem_write_region_2,
	i386_bus_space_mem_write_region_4,
	i386_bus_space_mem_set_multi_1,
	i386_bus_space_mem_set_multi_2,
	i386_bus_space_mem_set_multi_4,
	i386_bus_space_mem_set_region_1,
	i386_bus_space_mem_set_region_2,
	i386_bus_space_mem_set_region_4,
	i386_bus_space_mem_copy_1,
	i386_bus_space_mem_copy_2,
	i386_bus_space_mem_copy_4,
	i386_bus_space_mem_vaddr,
};

d72 2
a73 1
i386_bus_space_io_read_1(bus_space_handle_t h, bus_size_t o)
d75 2
a76 1
	return (inb(h + o));
d80 2
a81 1
i386_bus_space_io_read_2(bus_space_handle_t h, bus_size_t o)
d83 2
a84 1
	return (inw(h + o));
d88 2
a89 1
i386_bus_space_io_read_4(bus_space_handle_t h, bus_size_t o)
d91 2
a92 1
	return (inl(h + o));
d95 1
d97 1
a97 1
i386_bus_space_io_read_multi_1(bus_space_handle_t h, bus_size_t o,
d100 12
a111 1
	insb(h + o, a, cnt);
d115 1
a115 1
i386_bus_space_io_read_multi_2(bus_space_handle_t h, bus_size_t o,
d118 12
a129 1
	insw(h + o, a, cnt);
a130 1

d132 1
a132 1
i386_bus_space_io_read_multi_4(bus_space_handle_t h, bus_size_t o,
d135 12
a146 1
	insl(h + o, a, cnt);
d150 1
a150 1
i386_bus_space_io_read_region_1(bus_space_handle_t h,
d157 10
a166 7
	__asm volatile("cld				;"
	"1:	inb %w2,%%al				;"
	"	stosb					;"
	"	incl %2					;"
	"	loop 1b"				:
	    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::
	    "%eax", "memory", "cc");
d170 1
a170 1
i386_bus_space_io_read_region_2(bus_space_handle_t h,
d177 10
a186 7
	__asm volatile("cld				;"
	"1:	inw %w2,%%ax				;"
	"	stosw					;"
	"	addl $2,%2				;"
	"	loop 1b"				:
	    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::
	    "%eax", "memory", "cc");
d190 1
a190 1
i386_bus_space_io_read_region_4(bus_space_handle_t h,
d197 10
a206 7
	__asm volatile("cld				;"
	"1:	inl %w2,%%eax				;"
	"	stosl					;"
	"	addl $4,%2				;"
	"	loop 1b"				:
	    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::
	    "%eax", "memory", "cc");
d210 2
a211 1
i386_bus_space_io_write_1(bus_space_handle_t h, bus_size_t o, u_int8_t v)
d213 4
a216 1
	outb(h + o, v);
d220 2
a221 1
i386_bus_space_io_write_2(bus_space_handle_t h, bus_size_t o, u_int16_t v)
d223 4
a226 1
	outw(h + o, v);
d230 2
a231 1
i386_bus_space_io_write_4(bus_space_handle_t h, bus_size_t o, u_int32_t v)
d233 4
a236 1
	outl(h + o, v);
d240 1
a240 1
i386_bus_space_io_write_multi_1(bus_space_handle_t h,
d243 13
a255 1
	outsb(h + o, a, cnt);
d259 1
a259 1
i386_bus_space_io_write_multi_2(bus_space_handle_t h,
d262 13
a274 1
	outsw(h + o, a, cnt);
a275 1

d277 1
a277 1
i386_bus_space_io_write_multi_4(bus_space_handle_t h,
d280 13
a292 1
	outsl(h + o, a, cnt);
d296 1
a296 1
i386_bus_space_io_write_region_1(bus_space_handle_t h,
d303 10
a312 7
	__asm volatile("cld				;"
	"1:	lodsb					;"
	"	outb %%al,%w0				;"
	"	incl %0					;"
	"	loop 1b"				:
	    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::
	    "%eax", "memory", "cc");
d316 1
a316 1
i386_bus_space_io_write_region_2(bus_space_handle_t h,
d323 10
a332 7
	__asm volatile("cld				;"
	"1:	lodsw					;"
	"	outw %%ax,%w0				;"
	"	addl $2,%0				;"
	"	loop 1b"				:
	    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::
	    "%eax", "memory", "cc");
d336 1
a336 1
i386_bus_space_io_write_region_4(bus_space_handle_t h,
d343 10
a352 7
	__asm volatile("cld				;"
	"1:	lodsl					;"
	"	outl %%eax,%w0				;"
	"	addl $4,%0				;"
	"	loop 1b"				:
	    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::
	    "%eax", "memory", "cc");
d356 1
a356 1
i386_bus_space_io_set_multi_1(bus_space_handle_t h,
d361 13
a373 5
	__asm volatile("cld				;"
	"1:	outb %b2, %w1				;"
	"	loop 1b"				:
	    "+c" (_cnt) : "d" (h + o), "a" (v)		:
	    "cc");
d377 1
a377 1
i386_bus_space_io_set_multi_2(bus_space_handle_t h,
d382 13
a394 5
	__asm volatile("cld				;"
	"1:	outw %w2, %w1				;"
	"	loop 1b"				:
	    "+c" (_cnt) : "d" (h + o), "a" (v)	:
	    "cc");
d398 1
a398 1
i386_bus_space_io_set_multi_4(bus_space_handle_t h,
d403 5
a407 4
	__asm volatile("cld				;"
	"1:	outl %2,%w1				;"
	"	loop 1b"				:
	    "+c" (_cnt) : "d" (h + o), "a" (v)	:
d409 7
d419 1
a419 1
i386_bus_space_io_set_region_1(bus_space_handle_t h,
d425 6
a430 5
	__asm volatile(
	"1:	outb %%al,%w0				;"
	"	incl %0					;"
	"	loop 1b"				:
	    "+d" (_port), "+c" (_cnt) : "a" (v)	:
d432 7
d442 1
a442 1
i386_bus_space_io_set_region_2(bus_space_handle_t h,
d448 6
a453 5
	__asm volatile(
	"1:	outw %%ax,%w0				;"
	"	addl $2, %0				;"
	"	loop 1b"				:
	    "+d" (_port), "+c" (_cnt) : "a" (v)		:
d455 7
d465 1
a465 1
i386_bus_space_io_set_region_4(bus_space_handle_t h,
d471 14
a484 184
	__asm volatile(
	"1:	outl %%eax,%w0				;"
	"	addl $4, %0				;"
	"	loop 1b"				:
	    "+d" (_port), "+c" (_cnt) : "a" (v)		:
	    "cc");
}

void
i386_bus_space_io_copy_1(bus_space_handle_t h1, bus_size_t o1,
     bus_space_handle_t h2, bus_size_t o2, bus_size_t cnt)
{
	int _port1 = h1 + o1;
	int _port2 = h2 + o2;
	int _cnt = cnt;

	__asm volatile(
	"1:	movl %k1,%%edx				;"
	"	inb  %%dx,%%al				;"
	"	movl %k0,%%edx				;"
	"	outb %%al,%%dx				;"
	"	incl %0					;"
	"	incl %1					;"
	"	loop 1b"				:
	    "+D" (_port2), "+S" (_port1), "+c" (_cnt)	::
	    "%edx", "%eax", "cc");
}

void
i386_bus_space_io_copy_2(bus_space_handle_t h1, bus_size_t o1,
     bus_space_handle_t h2, bus_size_t o2, bus_size_t cnt)
{
	int _port1 = h1 + o1;
	int _port2 = h2 + o2;
	int _cnt=cnt;

	__asm volatile(
	"1:	movl %k1,%%edx				;"
	"	inw  %%dx,%%ax				;"
	"	movl %k0,%%edx				;"
	"	outw %%ax,%%dx				;"
	"	addl $2, %0				;"
	"	addl $2, %1				;"
	"	loop 1b"				:
	    "+D" (_port2), "+S" (_port1), "+c" (_cnt)	::
	    "%edx", "%eax", "cc");
}

void
i386_bus_space_io_copy_4(bus_space_handle_t h1, bus_size_t o1,
     bus_space_handle_t h2, bus_size_t o2, bus_size_t cnt)
{
	int _port1 = h1 + o1;
	int _port2 = h2 + o2;
	int _cnt = cnt;

	__asm volatile(
	"1:	movl %k1,%%edx				;"
	"	inl  %%dx,%%eax				;"
	"	movl %k0,%%edx				;"
	"	outl %%eax,%%dx				;"
	"	addl $4, %0				;"
	"	addl $4, %1				;"
	"	loop 1b"				:
	    "+D" (_port2), "+S" (_port1), "+c" (_cnt)	::
	    "%edx", "%eax", "cc");
}

void *
i386_bus_space_io_vaddr(bus_space_handle_t h)
{
	return (NULL);
}

paddr_t
i386_bus_space_io_mmap(bus_addr_t addr, off_t off, int prot, int flags)
{
	/* Can't mmap I/O space. */
	return (-1);
}

u_int8_t
i386_bus_space_mem_read_1(bus_space_handle_t h, bus_size_t o)
{
	return (*(volatile u_int8_t *)((h) + (o)));
}

u_int16_t
i386_bus_space_mem_read_2(bus_space_handle_t h, bus_size_t o)
{
	return (*(volatile u_int16_t *)((h) + (o)));
}

u_int32_t
i386_bus_space_mem_read_4(bus_space_handle_t h, bus_size_t o)
{
	return (*(volatile u_int32_t *)((h) + (o)));
}

void
i386_bus_space_mem_read_multi_1(bus_space_handle_t h, bus_size_t o,
    u_int8_t *a, bus_size_t cnt)
{
	void *_addr=a;
	int _cnt=cnt;
	__asm volatile("cld				;"
	"1:	movb (%2),%%al				;"
	"	stosb					;"
	"	loop 1b"				:
	    "+D" (_addr), "+c" (_cnt) : "r" (h + o)	:
	    "%eax", "memory", "cc");
}

void
i386_bus_space_mem_read_multi_2(bus_space_handle_t h, bus_size_t o,
    u_int16_t *a, bus_size_t cnt)
{
	void *_addr=a;
	int _cnt=cnt;
	__asm volatile("cld				;"
	"1:	movw (%2),%%ax				;"
	"	stosw					;"
	"	loop 1b"				:
	    "+D" (_addr), "+c" (_cnt) : "r" ((h) + (o))	:
	    "%eax", "memory", "cc");
}

void
i386_bus_space_mem_read_multi_4(bus_space_handle_t h, bus_size_t o,
    u_int32_t *a, bus_size_t cnt)
{
	void *_addr=a;
	int _cnt=cnt;
	__asm volatile("cld				;"
	"1:	movl (%2),%%eax				;"
	"	stosl					;"
	"	loop 1b"				:
	    "+D" (_addr), "+c" (_cnt) : "r" (h + o)	:
	    "%eax", "memory", "cc");
}

void
i386_bus_space_mem_read_region_1(bus_space_handle_t h,
    bus_size_t o, u_int8_t *a, bus_size_t cnt)
{
	int _cnt = cnt;
	void *_addr = a;
	int _port = h + o;

	i386_space_copy(_port, _addr, 1, _cnt);
}

void
i386_bus_space_mem_read_region_2(bus_space_handle_t h,
    bus_size_t o, u_int16_t *a, bus_size_t cnt)
{
	int _cnt = cnt;
	void *_addr = a;
	int _port = h + o;

	i386_space_copy(_port, _addr, 2, _cnt);
}

void
i386_bus_space_mem_read_region_4(bus_space_handle_t h,
    bus_size_t o, u_int32_t *a, bus_size_t cnt)
{
	int _cnt = cnt;
	void *_addr = a;
	int _port = h + o;

	i386_space_copy(_port, _addr, 4, _cnt);
}

void
i386_bus_space_mem_write_1(bus_space_handle_t h, bus_size_t o, u_int8_t v)
{
	((void)(*(volatile u_int8_t *)(h + o) = v));
}

void
i386_bus_space_mem_write_2(bus_space_handle_t h, bus_size_t o, u_int16_t v)
{
	((void)(*(volatile u_int16_t *)(h + o) = v));
d488 1
a488 166
i386_bus_space_mem_write_4(bus_space_handle_t h, bus_size_t o, u_int32_t v)
{
	((void)(*(volatile u_int32_t *)(h + o) = v));
}

void
i386_bus_space_mem_write_multi_1(bus_space_handle_t h,
    bus_size_t o, const u_int8_t *a, bus_size_t cnt)
{
	const void *_addr=a;
	int _cnt=cnt;

	__asm volatile("cld				;"
	"1:	lodsb					;"
	"	movb %%al,(%2)				;"
	"	loop 1b"				:
	    "+S" (_addr), "+c" (_cnt) : "r" (h + o)	:
	    "%eax", "memory", "cc");
}

void
i386_bus_space_mem_write_multi_2(bus_space_handle_t h,
    bus_size_t o, const u_int16_t *a, bus_size_t cnt)
{
	const void *_addr = a;
	int _cnt = cnt;

	__asm volatile("cld				;"
	"1:	lodsw					;"
	"	movw %%ax,(%2)				;"
	"	loop 1b"				:
	    "+S" (_addr), "+c" (_cnt) : "r" (h + o)	:
	    "%eax", "memory", "cc");
}

void
i386_bus_space_mem_write_multi_4(bus_space_handle_t h,
    bus_size_t o, const u_int32_t *a, bus_size_t cnt)
{
	const void *_addr=a;
	int _cnt=cnt;

	__asm volatile("cld				;"
	"1:	lodsl					;"
	"	movl %%eax,(%2)				;"
	"	loop 1b"				:
	    "+S" (_addr), "+c" (_cnt) : "r" (h + o)	:
	    "%eax", "memory", "cc");
}

void
i386_bus_space_mem_write_region_1(bus_space_handle_t h,
    bus_size_t o, const u_int8_t *a, bus_size_t cnt)
{
	int _port = h + o;
	const void *_addr = a;
	int _cnt = cnt;

	i386_space_copy(_addr, _port, 1, _cnt);
}

void
i386_bus_space_mem_write_region_2(bus_space_handle_t h,
    bus_size_t o, const u_int16_t *a, bus_size_t cnt)
{
	int _port = h + o;
	const void *_addr = a;
	int _cnt = cnt;

	i386_space_copy(_addr, _port, 2, _cnt);
}

void
i386_bus_space_mem_write_region_4(bus_space_handle_t h,
    bus_size_t o, const u_int32_t *a, bus_size_t cnt)
{
	int _port = h + o;
	const void *_addr = a;
	int _cnt = cnt;

	i386_space_copy(_addr, _port, 4, _cnt);
}

void
i386_bus_space_mem_set_multi_1(bus_space_handle_t h,
    bus_size_t o, u_int8_t v, size_t cnt)
{
	int _cnt = cnt;

	__asm volatile("cld				;"
	"1:	movb %b2, (%1)				;"
	"	loop 1b"				:
	    "+c" (_cnt) : "D" (h + o), "a" (v)		:
	    "cc", "memory");
}

void
i386_bus_space_mem_set_multi_2(bus_space_handle_t h,
    bus_size_t o, u_int16_t v, size_t cnt)
{
	int _cnt = cnt;

	__asm volatile("cld				;"
	"1:	movw %w2, (%1)				;"
	"	loop 1b"				:
	    "+c" (_cnt) : "D" (h + o), "a" (v)		:
	    "cc", "memory");
}

void
i386_bus_space_mem_set_multi_4(bus_space_handle_t h,
    bus_size_t o, u_int32_t v, size_t cnt)
{
	int _cnt = cnt;

	__asm volatile("cld				;"
	"1:	movl %2,(%1)				;"
	"	loop 1b"				:
	    "+c" (_cnt) : "D" (h + o), "a" (v)	:
	    "cc", "memory");
}

void
i386_bus_space_mem_set_region_1(bus_space_handle_t h,
    bus_size_t o, u_int8_t v, size_t cnt)
{
	int _port = h + o;
	int _cnt = cnt;

	__asm volatile("cld				;"
	"	repne					;"
	"	stosb"					:
	    "+D" (_port), "+c" (_cnt) : "a" (v)	:
	    "memory", "cc");
}

void
i386_bus_space_mem_set_region_2(bus_space_handle_t h,
    bus_size_t o, u_int16_t v, size_t cnt)
{
	int _port = h + o;
	int _cnt = cnt;

	__asm volatile("cld				;"
	"	repne					;"
	"	stosw"					:
	    "+D" (_port), "+c" (_cnt) : "a" (v)	:
	    "memory", "cc");
}

void
i386_bus_space_mem_set_region_4(bus_space_handle_t h,
    bus_size_t o, u_int32_t v, size_t cnt)
{
	int _port = h + o;
	int _cnt = cnt;

	__asm volatile("cld				;"
	"	repne					;"
	"	stosl"					:
	    "+D" (_port), "+c" (_cnt) : "a" (v)	:
	    "memory", "cc");
}

void
i386_bus_space_mem_copy_1( bus_space_handle_t h1, bus_size_t o1,
d495 13
a507 1
	i386_space_copy(_port1, _port2, 1, _cnt);
d511 1
a511 1
i386_bus_space_mem_copy_2( bus_space_handle_t h1, bus_size_t o1,
d517 13
a529 2

	i386_space_copy(_port1, _port2, 2, _cnt);
d533 1
a533 1
i386_bus_space_mem_copy_4( bus_space_handle_t h1, bus_size_t o1,
d540 13
a552 20
	i386_space_copy(_port1, _port2, 4, _cnt);
}

void *
i386_bus_space_mem_vaddr(bus_space_handle_t h)
{
	return ((void *)h);
}

paddr_t
i386_bus_space_mem_mmap(bus_addr_t addr, off_t off, int prot, int flags)
{
	/*
	 * "addr" is the base address of the device we're mapping.
	 * "off" is the offset into that device.
	 *
	 * Note we are called for each "page" in the device that
	 * the upper layers want to map.
	 */
	return (addr + off);
@


1.5
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.4 2009/07/16 21:07:41 mk Exp $ */
d71 188
d260 1
a260 2
bus_space_read_1(bus_space_tag_t t, bus_space_handle_t h,
    bus_size_t o)
d262 1
a262 2
	return ((t) == I386_BUS_SPACE_IO ? (inb((h) + (o))) :
	    (*(volatile u_int8_t *)((h) + (o))));
d266 1
a266 2
bus_space_read_2(bus_space_tag_t t, bus_space_handle_t h,
    bus_size_t o)
d268 1
a268 2
	return ((t) == I386_BUS_SPACE_IO ? (inw((h) + (o))) :
	    (*(volatile u_int16_t *)((h) + (o))));
d272 1
a272 2
bus_space_read_4(bus_space_tag_t t, bus_space_handle_t h,
    bus_size_t o)
d274 1
a274 2
	return ((t) == I386_BUS_SPACE_IO ? (inl((h) + (o))) :
	    (*(volatile u_int32_t *)((h) + (o))));
a276 1

d278 1
a278 1
bus_space_read_multi_1(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d281 1
a281 12
	if (t == I386_BUS_SPACE_IO) {
		insb(h + o, a, cnt);
	} else {
		void *_addr=a;
		int _cnt=cnt;
		__asm volatile("cld				;"
		"1:	movb (%2),%%al				;"
		"	stosb					;"
		"	loop 1b"				:
		    "+D" (_addr), "+c" (_cnt) : "r" (h + o)	:
		    "%eax", "memory", "cc");
	}
d285 1
a285 1
bus_space_read_multi_2(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d288 1
a288 12
	if (t == I386_BUS_SPACE_IO) {
		insw(h + o, a, cnt);
	} else {
		void *_addr=a;
		int _cnt=cnt;
		__asm volatile("cld				;"
		"1:	movw (%2),%%ax				;"
		"	stosw					;"
		"	loop 1b"				:
		    "+D" (_addr), "+c" (_cnt) : "r" ((h) + (o))	:
		    "%eax", "memory", "cc");
	}
d290 1
d292 1
a292 1
bus_space_read_multi_4(bus_space_tag_t t, bus_space_handle_t h, bus_size_t o,
d295 1
a295 12
	if (t == I386_BUS_SPACE_IO) {
		insl(h + o, a, cnt);
	} else {
		void *_addr=a;
		int _cnt=cnt;
		__asm volatile("cld				;"
		"1:	movl (%2),%%eax				;"
		"	stosl					;"
		"	loop 1b"				:
		    "+D" (_addr), "+c" (_cnt) : "r" (h + o)	:
		    "%eax", "memory", "cc");
	}
d299 1
a299 1
bus_space_read_region_1(bus_space_tag_t t, bus_space_handle_t h,
d306 7
a312 10
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	inb %w2,%%al				;"
		"	stosb					;"
		"	incl %2					;"
		"	loop 1b"				:
		    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::
		    "%eax", "memory", "cc");
	} else
		i386_space_copy(_port, _addr, 1, _cnt);
d316 1
a316 1
bus_space_read_region_2(bus_space_tag_t t, bus_space_handle_t h,
d323 7
a329 10
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	inw %w2,%%ax				;"
		"	stosw					;"
		"	addl $2,%2				;"
		"	loop 1b"				:
		    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::
		    "%eax", "memory", "cc");
	} else
		i386_space_copy(_port, _addr, 2, _cnt);
d333 1
a333 1
bus_space_read_region_4(bus_space_tag_t t, bus_space_handle_t h,
d340 7
a346 10
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	inl %w2,%%eax				;"
		"	stosl					;"
		"	addl $4,%2				;"
		"	loop 1b"				:
		    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::
		    "%eax", "memory", "cc");
	} else
		i386_space_copy(_port, _addr, 4, _cnt);
d350 1
a350 2
bus_space_write_1(bus_space_tag_t t, bus_space_handle_t h,
    bus_size_t o, u_int8_t v)
d352 1
a352 4
	if (t == I386_BUS_SPACE_IO)
		outb(h + o, v);
	else
		((void)(*(volatile u_int8_t *)(h + o) = v));
d356 1
a356 2
bus_space_write_2(bus_space_tag_t t, bus_space_handle_t h,
    bus_size_t o, u_int16_t v)
d358 1
a358 4
	if ((t) == I386_BUS_SPACE_IO)
		outw(h + o, v);
	else
		((void)(*(volatile u_int16_t *)(h + o) = v));
d362 1
a362 2
bus_space_write_4(bus_space_tag_t t, bus_space_handle_t h,
    bus_size_t o, u_int32_t v)
d364 1
a364 4
	if ((t) == I386_BUS_SPACE_IO)
		outl(h + o, v);
	else
		((void)(*(volatile u_int32_t *)(h + o) = v));
d368 1
a368 1
bus_space_write_multi_1(bus_space_tag_t t, bus_space_handle_t h,
d371 1
a371 13
	if (t == I386_BUS_SPACE_IO) {
		outsb(h + o, a, cnt);
	} else {
		const void *_addr=a;
		int _cnt=cnt;

		__asm volatile("cld				;"
		"1:	lodsb					;"
		"	movb %%al,(%2)				;"
		"	loop 1b"				:
		    "+S" (_addr), "+c" (_cnt) : "r" (h + o)	:
		    "%eax", "memory", "cc");
	}
d375 1
a375 1
bus_space_write_multi_2(bus_space_tag_t t, bus_space_handle_t h,
d378 1
a378 13
	if (t == I386_BUS_SPACE_IO) {
		outsw(h + o, a, cnt);
	} else {
		const void *_addr = a;
		int _cnt = cnt;

		__asm volatile("cld				;"
		"1:	lodsw					;"
		"	movw %%ax,(%2)				;"
		"	loop 1b"				:
		    "+S" (_addr), "+c" (_cnt) : "r" (h + o)	:
		    "%eax", "memory", "cc");
	}
d380 1
d382 1
a382 1
bus_space_write_multi_4(bus_space_tag_t t, bus_space_handle_t h,
d385 1
a385 13
	if (t == I386_BUS_SPACE_IO) {
		outsl(h + o, a, cnt);
	} else {
		const void *_addr=a;
		int _cnt=cnt;

		__asm volatile("cld				;"
		"1:	lodsl					;"
		"	movl %%eax,(%2)				;"
		"	loop 1b"				:
		    "+S" (_addr), "+c" (_cnt) : "r" (h + o)	:
		    "%eax", "memory", "cc");
	}
d389 1
a389 1
bus_space_write_region_1(bus_space_tag_t t, bus_space_handle_t h,
d396 7
a402 10
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	lodsb					;"
		"	outb %%al,%w0				;"
		"	incl %0					;"
		"	loop 1b"				:
		    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::
		    "%eax", "memory", "cc");
	} else
		i386_space_copy(_addr, _port, 1, _cnt);
d406 1
a406 1
bus_space_write_region_2(bus_space_tag_t t, bus_space_handle_t h,
d413 7
a419 10
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	lodsw					;"
		"	outw %%ax,%w0				;"
		"	addl $2,%0				;"
		"	loop 1b"				:
		    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::
		    "%eax", "memory", "cc");
	} else
		i386_space_copy(_addr, _port, 2, _cnt);
d423 1
a423 1
bus_space_write_region_4(bus_space_tag_t t, bus_space_handle_t h,
d430 7
a436 10
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	lodsl					;"
		"	outl %%eax,%w0				;"
		"	addl $4,%0				;"
		"	loop 1b"				:
		    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::
		    "%eax", "memory", "cc");
	} else
		i386_space_copy(_addr, _port, 4, _cnt);
d440 1
a440 1
bus_space_set_multi_1(bus_space_tag_t t, bus_space_handle_t h,
d445 5
a449 13
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	outb %b2, %w1				;"
		"	loop 1b"				:
		    "+c" (_cnt) : "d" (h + o), "a" (v)		:
		    "cc");
	} else {
		__asm volatile("cld				;"
		"1:	movb %b2, (%1)				;"
		"	loop 1b"				:
		    "+c" (_cnt) : "D" (h + o), "a" (v)		:
		    "cc", "memory");
	}
d453 1
a453 1
bus_space_set_multi_2(bus_space_tag_t t, bus_space_handle_t h,
d458 5
a462 13
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	outw %w2, %w1				;"
		"	loop 1b"				:
		    "+c" (_cnt) : "d" (h + o), "a" (v)	:
		    "cc");
	} else {
		__asm volatile("cld				;"
		"1:	movw %w2, (%1)				;"
		"	loop 1b"				:
		    "+c" (_cnt) : "D" (h + o), "a" (v)		:
		    "cc", "memory");
	}
d466 1
a466 1
bus_space_set_multi_4(bus_space_tag_t t, bus_space_handle_t h,
d471 4
a474 5
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile("cld				;"
		"1:	outl %2,%w1				;"
		"	loop 1b"				:
		    "+c" (_cnt) : "d" (h + o), "a" (v)	:
a475 7
	} else {
		__asm volatile("cld				;"
		"1:	movl %2,(%1)				;"
		"	loop 1b"				:
		    "+c" (_cnt) : "D" (h + o), "a" (v)	:
		    "cc", "memory");
	}
d479 1
a479 1
bus_space_set_region_1(bus_space_tag_t t, bus_space_handle_t h,
d485 5
a489 6
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile(
		"1:	outb %%al,%w0				;"
		"	incl %0					;"
		"	loop 1b"				:
		    "+d" (_port), "+c" (_cnt) : "a" (v)	:
a490 7
	} else {
		__asm volatile("cld				;"
		"	repne					;"
		"	stosb"					:
		    "+D" (_port), "+c" (_cnt) : "a" (v)	:
		    "memory", "cc");
	}
d494 1
a494 1
bus_space_set_region_2(bus_space_tag_t t, bus_space_handle_t h,
d500 5
a504 6
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile(
		"1:	outw %%ax,%w0				;"
		"	addl $2, %0				;"
		"	loop 1b"				:
		    "+d" (_port), "+c" (_cnt) : "a" (v)		:
a505 7
	} else {
		__asm volatile("cld				;"
		"	repne					;"
		"	stosw"					:
		    "+D" (_port), "+c" (_cnt) : "a" (v)	:
		    "memory", "cc");
	}
d509 345
a853 1
bus_space_set_region_4(bus_space_tag_t t, bus_space_handle_t h,
d859 5
a863 14
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile(
		"1:	outl %%eax,%w0				;"
		"	addl $4, %0				;"
		"	loop 1b"				:
		    "+d" (_port), "+c" (_cnt) : "a" (v)		:
		    "cc");
	} else {
		__asm volatile("cld				;"
		"	repne					;"
		"	stosl"					:
		    "+D" (_port), "+c" (_cnt) : "a" (v)	:
		    "memory", "cc");
	}
d867 1
a867 1
bus_space_copy_1(bus_space_tag_t t, bus_space_handle_t h1, bus_size_t o1,
d874 1
a874 13
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile(
		"1:	movl %k1,%%edx				;"
		"	inb  %%dx,%%al				;"
		"	movl %k0,%%edx				;"
		"	outb %%al,%%dx				;"
		"	incl %0					;"
		"	incl %1					;"
		"	loop 1b"				:
		    "+D" (_port2), "+S" (_port1), "+c" (_cnt)	::
		    "%edx", "%eax", "cc");
	} else
		i386_space_copy(_port1, _port2, 1, _cnt);
d878 1
a878 1
bus_space_copy_2(bus_space_tag_t t, bus_space_handle_t h1, bus_size_t o1,
d884 2
a885 13
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile(
		"1:	movl %k1,%%edx				;"
		"	inw  %%dx,%%ax				;"
		"	movl %k0,%%edx				;"
		"	outw %%ax,%%dx				;"
		"	addl $2, %0				;"
		"	addl $2, %1				;"
		"	loop 1b"				:
		    "+D" (_port2), "+S" (_port1), "+c" (_cnt)	::
		    "%edx", "%eax", "cc");
	} else
		i386_space_copy(_port1, _port2, 2, _cnt);
d889 1
a889 1
bus_space_copy_4(bus_space_tag_t t, bus_space_handle_t h1, bus_size_t o1,
d896 20
a915 13
	if (t == I386_BUS_SPACE_IO) {
		__asm volatile(
		"1:	movl %k1,%%edx				;"
		"	inl  %%dx,%%eax				;"
		"	movl %k0,%%edx				;"
		"	outl %%eax,%%dx				;"
		"	addl $4, %0				;"
		"	addl $4, %1				;"
		"	loop 1b"				:
		    "+D" (_port2), "+S" (_port1), "+c" (_cnt)	::
		    "%edx", "%eax", "cc");
	} else
		i386_space_copy(_port1, _port2, 4, _cnt);
@


1.4
log
@KNF

ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.3 2009/01/07 01:36:43 jsg Exp $ */
d105 1
a105 1
		__asm __volatile("cld				;"
d123 1
a123 1
		__asm __volatile("cld				;"
d140 1
a140 1
		__asm __volatile("cld				;"
d158 1
a158 1
		__asm __volatile("cld				;"
d178 1
a178 1
		__asm __volatile("cld				;"
d198 1
a198 1
		__asm __volatile("cld				;"
d249 1
a249 1
		__asm __volatile("cld				;"
d268 1
a268 1
		__asm __volatile("cld				;"
d286 1
a286 1
		__asm __volatile("cld				;"
d304 1
a304 1
		__asm __volatile("cld				;"
d324 1
a324 1
		__asm __volatile("cld				;"
d344 1
a344 1
		__asm __volatile("cld				;"
d362 1
a362 1
		__asm __volatile("cld				;"
d368 1
a368 1
		__asm __volatile("cld				;"
d383 1
a383 1
		__asm __volatile("cld				;"
d389 1
a389 1
		__asm __volatile("cld				;"
d404 1
a404 1
		__asm __volatile("cld				;"
d410 1
a410 1
		__asm __volatile("cld				;"
d426 1
a426 1
		__asm __volatile(
d433 1
a433 1
		__asm __volatile("cld				;"
d449 1
a449 1
		__asm __volatile(
d456 1
a456 1
		__asm __volatile("cld				;"
d472 1
a472 1
		__asm __volatile(
d479 1
a479 1
		__asm __volatile("cld				;"
d496 1
a496 1
		__asm __volatile(
d518 1
a518 1
		__asm __volatile(
d541 1
a541 1
		__asm __volatile(
@


1.3
log
@The E asm constraint refers to an immediate floating operand
and isn't what we want here.

ok weingart@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.2 2008/12/03 15:46:06 oga Exp $ */
d65 1
a65 1
#include<sys/systm.h>
@


1.2
log
@Remove the x86 and i386 prefixes to the bus_dma types. It's really quite
pointless and just makes the code different for no reason. This moves i386 and
amd64 bus_dma to being a lot closer to identical.

suggestion to just remove the prefix instead of merge them from deraadt@@.

no objections art@@, kettenis@@, ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus_space.c,v 1.1 2008/11/22 17:45:20 oga Exp $ */
d526 1
a526 1
		    "+D" (_port2), "+ES" (_port1), "+c" (_cnt)	::
d549 1
a549 1
		    "+D" (_port2), "+ES" (_port1), "+c" (_cnt)	::
@


1.1
log
@same change as for amd64. Move bus_space_* functions from inlines and
defines into real functions. since machdep.c is cluttered as it is move them
into bus_space.c (like amd64). a later commit will move the stuff from machdep
across too. since machdep.c is cluttered as it is move them into bus_space.c
(like amd64). a later commit will move the stuff from machdep across too.

some shrinkage stats:
GENERIC.MP 209.66kb
RAMDISK 50.84kb
RAMDISKB 50.04kb
RAMDISC 36.28kb
RAMDISK_CD 168.03kb

don't fill it up all at once!

claudio found no network performance hit. toby thought the code went
looked alright. art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a68 1
#define _I386_BUS_DMA_PRIVATE
@

