head	1.29;
access;
symbols
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.27.0.6
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.8
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.24
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.20
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.18
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.16
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.14
	OPENBSD_5_0:1.26.0.12
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.10
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.8
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.4
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.6
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.25.0.4
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.22.0.4
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.20.0.6
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.6
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.15
	UBC:1.14.0.4
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.13.0.8
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.13.0.6
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.4
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.2
	SMP_BASE:1.13
	kame_19991208:1.13
	OPENBSD_2_6:1.12.0.6
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.29
date	2016.09.26.03.33.03;	author guenther;	state Exp;
branches;
next	1.28;
commitid	HigQCsIM9rumEmFl;

1.28
date	2016.04.14.07.00.24;	author mlarkin;	state Exp;
branches;
next	1.27;
commitid	81lumGcTTM2QQ8It;

1.27
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2008.11.21.03.22.29;	author mikeb;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.24.17.56.58;	author mikeb;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.24.06.30.25;	author mikeb;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.17.02.30.25;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.11.29.20.03.20;	author dim;	state Exp;
branches;
next	1.21;

1.21
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.29.01.12.15;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.29.17.33.01;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.25.22.47.54;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.27.23.52.01;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.05.05.05.38;	author pvalchev;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	99.11.20.18.51.59;	author espie;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	98.06.04.04.56.42;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	98.05.25.08.01.42;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	97.08.16.16.31.18;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.06.15.13.45.13;	author dm;	state Exp;
branches;
next	1.8;

1.8
date	97.05.30.07.51.12;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.10.20.15.27.53;	author dm;	state Exp;
branches;
next	1.6;

1.6
date	96.08.16.00.02.36;	author dm;	state Exp;
branches;
next	1.5;

1.5
date	96.08.14.22.03.15;	author dm;	state Exp;
branches;
next	1.4;

1.4
date	96.08.14.03.02.54;	author dm;	state Exp;
branches;
next	1.3;

1.3
date	96.08.08.22.21.23;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.08.08.21.37.31;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.08.08.18.47.07;	author dm;	state Exp;
branches;
next	;

1.13.2.1
date	2001.07.04.10.16.38;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2001.07.14.10.02.30;	author ho;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2003.06.07.11.11.37;	author ho;	state Exp;
branches;
next	1.13.2.5;

1.13.2.5
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	;

1.14.4.1
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Check cpuid_level before using CPUID().

Problem noted by Sami (sami.tikkanen (at) haxaa.net)
ok deraadt@@
@
text
@/*	$OpenBSD: pctr.c,v 1.28 2016/04/14 07:00:24 mlarkin Exp $	*/

/*
 * Pentium performance counter driver for OpenBSD.
 * Copyright 1996 David Mazieres <dm@@lcs.mit.edu>.
 *
 * Modification and redistribution in source and binary forms is
 * permitted provided that due credit is given to the author and the
 * OpenBSD project by leaving this copyright notice intact.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/errno.h>
#include <sys/fcntl.h>
#include <sys/ioccom.h>
#include <sys/systm.h>

#include <machine/cputypes.h>
#include <machine/psl.h>
#include <machine/pctr.h>
#include <machine/cpu.h>
#include <machine/specialreg.h>

#define PCTR_AMD_NUM	PCTR_NUM
#define PCTR_INTEL_NUM	2		/* Intel supports only 2 counters */
#define PCTR_INTEL_VERSION_MASK 0xff

#define usetsc		(cpu_feature & CPUID_TSC)
#define usep5ctr	(pctr_isintel && (((cpu_id >> 8) & 15) == 5) && \
				(((cpu_id >> 4) & 15) > 0))
#define usepctr		((pctr_isamd && ((cpu_id >> 8) & 15) >= 6) || \
			    (pctr_isintel && \
			    (pctr_intel_cap & PCTR_INTEL_VERSION_MASK) >= 1))

int			pctr_isamd;
int			pctr_isintel;
uint32_t		pctr_intel_cap;

static int		p5ctrsel(int fflag, u_int cmd, u_int fn);
static int		pctrsel(int fflag, u_int cmd, u_int fn);
static void		pctrrd(struct pctrst *);

static void
p5ctrrd(struct pctrst *st)
{
	u_int msr11;

	msr11 = rdmsr(P5MSR_CTRSEL);
	st->pctr_fn[0] = msr11 & 0xffff;
	st->pctr_fn[1] = msr11 >> 16;
	__asm volatile("cli");
	st->pctr_tsc = rdtsc();
	st->pctr_hwc[0] = rdmsr(P5MSR_CTR0);
	st->pctr_hwc[1] = rdmsr(P5MSR_CTR1);
	__asm volatile("sti");
}

static void
pctrrd(struct pctrst *st)
{
	int i, num, reg;

	num = pctr_isamd ? PCTR_AMD_NUM : PCTR_INTEL_NUM;
	reg = pctr_isamd ? MSR_K7_EVNTSEL0 : P6MSR_CTRSEL0;
	for (i = 0; i < num; i++)
			st->pctr_fn[i] = rdmsr(reg + i);
	__asm volatile("cli");
	st->pctr_tsc = rdtsc();
	for (i = 0; i < num; i++)
		st->pctr_hwc[i] = rdpmc(i);
	__asm volatile("sti");
}

void
pctrattach(int num)
{
	uint32_t dummy;

	if (num > 1)
		return;

	pctr_isamd = (strcmp(cpu_vendor, "AuthenticAMD") == 0);
	if (!pctr_isamd && cpuid_level >= 0xa) {
		pctr_isintel = (strcmp(cpu_vendor, "GenuineIntel") == 0);
		CPUID(0xa, pctr_intel_cap, dummy, dummy, dummy);
	}

	if (usepctr) {
		/* Enable RDTSC and RDPMC instructions from user-level. */
		__asm volatile ("movl %%cr4,%%eax\n"
				  "\tandl %0,%%eax\n"
				  "\torl %1,%%eax\n"
				  "\tmovl %%eax,%%cr4"
				  :: "i" (~CR4_TSD), "i" (CR4_PCE) : "eax");
	} else if (usetsc) {
		/* Enable RDTSC instruction from user-level. */
		__asm volatile ("movl %%cr4,%%eax\n"
				  "\tandl %0,%%eax\n"
				  "\tmovl %%eax,%%cr4"
				  :: "i" (~CR4_TSD) : "eax");
	}
}

int
pctropen(dev_t dev, int oflags, int devtype, struct proc *p)
{

	if (minor(dev))
		return (ENXIO);
	return (0);
}

int
pctrclose(dev_t dev, int oflags, int devtype, struct proc *p)
{

	return (0);
}

int
p5ctrsel(int fflag, u_int cmd, u_int fn)
{
	pctrval msr11;
	int msr, shift;

	cmd -= PCIOCS0;
	if (cmd > 1)
		return (EINVAL);
	msr = P5MSR_CTR0 + cmd;
	shift = cmd ? 0x10 : 0;

	if (!(fflag & FWRITE))
		return (EPERM);
	if (fn >= 0x200)
		return (EINVAL);

	msr11 = rdmsr(P5MSR_CTRSEL);
	msr11 &= ~(0x1ffLL << shift);
	msr11 |= fn << shift;
	wrmsr(P5MSR_CTRSEL, msr11);
	wrmsr(msr, 0);

	return (0);
}

int
pctrsel(int fflag, u_int cmd, u_int fn)
{
	int msrsel, msrval;

	cmd -= PCIOCS0;
	if (pctr_isamd) {
		if (cmd > PCTR_AMD_NUM-1)
			return (EINVAL);
		msrsel = MSR_K7_EVNTSEL0 + cmd;
		msrval = MSR_K7_PERFCTR0 + cmd;
	} else {
		if (cmd > PCTR_INTEL_NUM-1)
			return (EINVAL);
		msrsel = P6MSR_CTRSEL0 + cmd;
		msrval = P6MSR_CTR0 + cmd;
	}

	if (!(fflag & FWRITE))
		return (EPERM);
	if (fn & 0x380000)
		return (EINVAL);

	wrmsr(msrval, 0);
	wrmsr(msrsel, fn);
	wrmsr(msrval, 0);

	return (0);
}

int
pctrioctl(dev_t dev, u_long cmd, caddr_t data, int fflag, struct proc *p)
{
	switch (cmd) {
	case PCIOCRD:
	{
		struct pctrst *st = (struct pctrst *)data;
		
		if (usepctr)
			pctrrd(st);
		else if (usep5ctr)
			p5ctrrd(st);
		else {
			bzero(st, sizeof(*st));
			if (usetsc)
				st->pctr_tsc = rdtsc();
		}
		return (0);
	}
	case PCIOCS0:
	case PCIOCS1:
	case PCIOCS2:
	case PCIOCS3:
		if (usepctr)
			return (pctrsel(fflag, cmd, *(u_int *)data));
		if (usep5ctr)
			return (p5ctrsel(fflag, cmd, *(u_int *)data));
		return (ENODEV);
	default:
		return (EINVAL);
	}
}
@


1.28
log
@
Use cpuid function 0xa to determine presence of general purpose
architectural performance counters, instead of cpu family/model values.

Fixes a panic seen on some hypervisors when pctr(1) is used when the
hypervisor masks out the counters.

Reported by Hiltjo Posthuma, thanks.

ok mikeb@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.27 2014/03/29 18:09:29 guenther Exp $	*/
d84 1
a84 1
	if (!pctr_isamd) {
@


1.27
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.26 2008/11/21 03:22:29 mikeb Exp $	*/
d27 1
d32 3
a34 2
#define usepctr		((pctr_isamd || pctr_isintel) && \
			    ((cpu_id >> 8) & 15) >= 6)
d38 1
a42 1
static void		pctrrd(struct pctrst *);
d78 1
d84 1
a84 1
	if (!pctr_isamd)
d86 2
@


1.26
log
@add forgotten ioctls. allows writing to extra counters found on amd cpus.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.25 2007/10/24 17:56:58 mikeb Exp $	*/
d50 1
a50 1
	__asm __volatile("cli");
d54 1
a54 1
	__asm __volatile("sti");
d66 1
a66 1
	__asm __volatile("cli");
d70 1
a70 1
	__asm __volatile("sti");
d86 1
a86 1
		__asm __volatile ("movl %%cr4,%%eax\n"
d93 1
a93 1
		__asm __volatile ("movl %%cr4,%%eax\n"
@


1.25
log
@Remove idle loop counter.

ok art deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.24 2007/10/24 06:30:25 mikeb Exp $	*/
d193 2
@


1.24
log
@Don't spam the dmesg.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.23 2007/10/17 02:30:25 deraadt Exp $	*/
a33 2
u_int64_t		pctr_idlcnt;	/* Gets incremented in locore.S */

a188 1
		st->pctr_idl = pctr_idlcnt;
@


1.23
log
@replacement for the pctr codebase that can handle amd64 processors as
well (in fact, all 4 combinations of codebase and processor) written by
Mike Belopuhov and Aleksey Lomovtsev
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.22 2006/11/29 20:03:20 dim Exp $	*/
a92 1
		printf("pctr: user-level performance counters enabled\n");
d99 1
a99 4
		printf("pctr: user-level cycle counter enabled\n");
	} else if (usep5ctr)
		printf("pctr: 586-class performance counters and user-level "
		    " cycle counter enabled\n");
@


1.22
log
@Remove all the extern cpu_{id,model,whatever} declarations from most
stuff in arch/i386/i386.  This should prevent more screwups like the
one I did before in ichpcib.c...

ok dlg@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.21 2006/09/19 11:06:33 jsg Exp $	*/
d25 2
a26 3
pctrval pctr_idlcnt;  /* Gets incremented in locore.s */

int pctr_isintel;
d31 27
a57 1
#define usep6ctr	(pctr_isintel && ((cpu_id >> 8) & 15) == 6)
d59 15
a73 8
void pctrattach(int);
int pctropen(dev_t, int, int, struct proc *);
int pctrclose(dev_t, int, int, struct proc *);
int pctrioctl(dev_t, u_long, caddr_t, int, struct proc *);
int p5ctrsel(int fflag, u_int cmd, u_int fn);
static __inline void p5ctrrd(struct pctrst *st);
int p6ctrsel(int fflag, u_int cmd, u_int fn);
static __inline void p6ctrrd(struct pctrst *st);
d78 1
d82 3
a84 1
	pctr_isintel = (strcmp(cpu_vendor, "GenuineIntel") == 0);
d86 1
a86 1
	if (usep6ctr)
d93 2
a94 1
	else if (usetsc)
a99 6

	if (usep6ctr)
		printf("pctr: 686-class user-level performance counters enabled\n");
	else if (usep5ctr)
		printf("pctr: 586-class performance counters and user-level cycle counter enabled\n");
	else if (usetsc)
d101 3
a103 2
	else
		printf("pctr: no performance counters in CPU\n");
d109 1
d111 2
a112 2
		return ENXIO;
	return 0;
d118 2
a119 1
	return 0;
d126 1
a126 2
	int msr;
	int shift;
d130 1
a130 1
		return EINVAL;
d135 1
a135 1
		return EPERM;
d137 1
a137 1
		return EINVAL;
d145 1
a145 16
	return 0;
}

static __inline void
p5ctrrd(struct pctrst *st)
{
	u_int msr11;

	msr11 = rdmsr(P5MSR_CTRSEL);
	st->pctr_fn[0] = msr11 & 0xffff;
	st->pctr_fn[1] = msr11 >> 16;
	__asm __volatile("cli");
	st->pctr_tsc = rdtsc();
	st->pctr_hwc[0] = rdmsr(P5MSR_CTR0);
	st->pctr_hwc[1] = rdmsr(P5MSR_CTR1);
	__asm __volatile("sti");
d149 1
a149 1
p6ctrsel(int fflag, u_int cmd, u_int fn)
d154 11
a164 4
	if (cmd > 1)
		return EINVAL;
	msrsel = P6MSR_CTRSEL0 + cmd;
	msrval = P6MSR_CTR0 + cmd;
d167 1
a167 1
		return EPERM;
d169 1
a169 1
		return EINVAL;
d175 1
a175 13
	return 0;
}

static __inline void
p6ctrrd(struct pctrst *st)
{
	st->pctr_fn[0] = rdmsr(P6MSR_CTRSEL0);
	st->pctr_fn[1] = rdmsr(P6MSR_CTRSEL1);
	__asm __volatile("cli");
	st->pctr_tsc = rdtsc();
	st->pctr_hwc[0] = rdpmc(0);
	st->pctr_hwc[1] = rdpmc(1);
	__asm __volatile("sti");
a177 1

d184 1
a184 1
		struct pctrst *st = (void *)data;
d186 2
a187 2
		if (usep6ctr)
			p6ctrrd(st);
d196 1
a196 1
		return 0;
d200 2
a201 2
		if (usep6ctr)
			return p6ctrsel(fflag, cmd, *(u_int *) data);
d203 2
a204 2
			return p5ctrsel(fflag, cmd, *(u_int *) data);
		return ENODEV;
d206 1
a206 1
		return EINVAL;
@


1.21
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.20 2005/04/29 01:12:15 deraadt Exp $	*/
a25 5

/* Pull in the cpuid values from locore.s */
extern int cpu_id;
extern int cpu_feature;
extern char cpu_vendor[];
@


1.20
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.19 2004/06/13 21:49:15 niklas Exp $	*/
d49 1
a49 2
pctrattach(num)
	int num;
d81 1
a81 5
pctropen(dev, oflags, devtype, p)
	dev_t dev;
	int oflags;
	int devtype;
	struct proc *p;
d89 1
a89 5
pctrclose(dev, oflags, devtype, p)
	dev_t dev;
	int oflags;
	int devtype;
	struct proc *p;
d95 1
a95 4
p5ctrsel(fflag, cmd, fn)
	int fflag;
	u_int cmd;
	u_int fn;
d122 1
a122 2
p5ctrrd(st)
	struct pctrst *st;
d137 1
a137 4
p6ctrsel(fflag, cmd, fn)
	int fflag;
	u_int cmd;
	u_int fn;
d160 1
a160 2
p6ctrrd(st)
	struct pctrst *st;
d173 1
a173 6
pctrioctl(dev, cmd, data, fflag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int fflag;
	struct proc *p;
@


1.19
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
a49 1
pctrattach (num)
d72 1
a72 1
		printf ("pctr: 686-class user-level performance counters enabled\n");
d74 1
a74 1
		printf ("pctr: 586-class performance counters and user-level cycle counter enabled\n");
d76 1
a76 1
		printf ("pctr: user-level cycle counter enabled\n");
d78 1
a78 1
		printf ("pctr: no performance counters in CPU\n");
d82 1
a82 1
pctropen (dev, oflags, devtype, p)
d88 1
a88 1
	if (minor (dev))
d94 1
a94 1
pctrclose (dev, oflags, devtype, p)
d104 1
a104 1
p5ctrsel (fflag, cmd, fn)
d119 1
a119 1
	if (! (fflag & FWRITE))
d124 1
a124 1
	msr11 = rdmsr (P5MSR_CTRSEL);
d127 2
a128 2
	wrmsr (P5MSR_CTRSEL, msr11);
	wrmsr (msr, 0);
d134 1
a134 1
p5ctrrd (st)
d139 1
a139 1
	msr11 = rdmsr (P5MSR_CTRSEL);
d142 5
a146 5
	__asm __volatile ("cli");
	st->pctr_tsc = rdtsc ();
	st->pctr_hwc[0] = rdmsr (P5MSR_CTR0);
	st->pctr_hwc[1] = rdmsr (P5MSR_CTR1);
	__asm __volatile ("sti");
d150 1
a150 1
p6ctrsel (fflag, cmd, fn)
d163 1
a163 1
	if (! (fflag & FWRITE))
d168 3
a170 3
	wrmsr (msrval, 0);
	wrmsr (msrsel, fn);
	wrmsr (msrval, 0);
d176 1
a176 1
p6ctrrd (st)
d179 7
a185 7
	st->pctr_fn[0] = rdmsr (P6MSR_CTRSEL0);
	st->pctr_fn[1] = rdmsr (P6MSR_CTRSEL1);
	__asm __volatile ("cli");
	st->pctr_tsc = rdtsc ();
	st->pctr_hwc[0] = rdpmc (0);
	st->pctr_hwc[1] = rdpmc (1);
	__asm __volatile ("sti");
d190 1
a190 1
pctrioctl (dev, cmd, data, fflag, p)
d200 1
a200 1
		struct pctrst *st = (void *) data;
d203 1
a203 1
			p6ctrrd (st);
d205 1
a205 1
			p5ctrrd (st);
d207 1
a207 1
			bzero (st, sizeof (*st));
d209 1
a209 1
				st->pctr_tsc = rdtsc ();
d217 1
a217 1
			return p6ctrsel (fflag, cmd, *(u_int *) data);
d219 1
a219 1
			return p5ctrsel (fflag, cmd, *(u_int *) data);
@


1.18
log
@to set smth in the register one has to write into it and not just read once more; fround by art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.17 2003/07/25 22:47:54 mickey Exp $	*/
d12 1
@


1.17
log
@use names not numbers for msrs, do not define yet another implementation of wrmsr/rdmsr
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.16 2003/05/27 23:52:01 fgsch Exp $	*/
d61 1
a61 1
				  "\tmovl %%cr4,%%eax"
d67 1
a67 1
				  "\tmovl %%cr4,%%eax"
@


1.16
log
@change .byte for the correct opcodes now that gas can handle'em.
art@@ toby@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.15 2002/03/14 01:26:32 millert Exp $	*/
d123 1
a123 1
	msr11 = rdmsr (0x11);
d126 1
a126 1
	wrmsr (0x11, msr11);
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.14 2001/06/05 05:05:38 pvalchev Exp $	*/
d58 1
a58 1
		__asm __volatile (".byte 0xf,0x20,0xe0   # movl %%cr4,%%eax\n"
d61 1
a61 1
				  "\t.byte 0xf,0x22,0xe0 # movl %%cr4,%%eax"
d65 1
a65 1
		__asm __volatile (".byte 0xf,0x20,0xe0   # movl %%cr4,%%eax\n"
d67 1
a67 1
				  "\t.byte 0xf,0x22,0xe0 # movl %%cr4,%%eax"
@


1.14
log
@License clarification from David Mazieres, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.13 1999/11/20 18:51:59 espie Exp $	*/
d38 8
a45 8
void pctrattach __P((int));
int pctropen __P((dev_t, int, int, struct proc *));
int pctrclose __P((dev_t, int, int, struct proc *));
int pctrioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int p5ctrsel __P((int fflag, u_int cmd, u_int fn));
static __inline void p5ctrrd __P((struct pctrst *st));
int p6ctrsel __P((int fflag, u_int cmd, u_int fn));
static __inline void p6ctrrd __P((struct pctrst *st));
@


1.14.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.14 2001/06/05 05:05:38 pvalchev Exp $	*/
d38 8
a45 8
void pctrattach(int);
int pctropen(dev_t, int, int, struct proc *);
int pctrclose(dev_t, int, int, struct proc *);
int pctrioctl(dev_t, u_long, caddr_t, int, struct proc *);
int p5ctrsel(int fflag, u_int cmd, u_int fn);
static __inline void p5ctrrd(struct pctrst *st);
int p6ctrsel(int fflag, u_int cmd, u_int fn);
static __inline void p6ctrrd(struct pctrst *st);
@


1.13
log
@ioctl arguments are u_long.
Replaces `undefined' code with `defined' behavior...

gcc 2.96 performs switch cases range analysis, warns about unreachable
cases, and weeds them out.

In

switch(i) {
case VALUE:
}

VALUE is first coerced into the type of i.  If i is signed, VALUE is
unsigned and exceeds i range, you lose... the result of the conversion
is undefined.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.12 1998/06/04 04:56:42 downsj Exp $	*/
d9 1
a9 2
 * OpenBSD project (for instance by leaving this copyright notice
 * intact).
@


1.13.2.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.13 1999/11/20 18:51:59 espie Exp $	*/
d9 2
a10 1
 * OpenBSD project by leaving this copyright notice intact.
@


1.13.2.2
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.13.2.1 2001/07/04 10:16:38 niklas Exp $	*/
a11 1
#include <sys/param.h>
@


1.13.2.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 8
a46 8
void pctrattach(int);
int pctropen(dev_t, int, int, struct proc *);
int pctrclose(dev_t, int, int, struct proc *);
int pctrioctl(dev_t, u_long, caddr_t, int, struct proc *);
int p5ctrsel(int fflag, u_int cmd, u_int fn);
static __inline void p5ctrrd(struct pctrst *st);
int p6ctrsel(int fflag, u_int cmd, u_int fn);
static __inline void p6ctrrd(struct pctrst *st);
@


1.13.2.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.13.2.3 2002/03/28 10:31:04 niklas Exp $	*/
d59 1
a59 1
		__asm __volatile ("movl %%cr4,%%eax\n"
d62 1
a62 1
				  "\tmovl %%cr4,%%eax"
d66 1
a66 1
		__asm __volatile ("movl %%cr4,%%eax\n"
d68 1
a68 1
				  "\tmovl %%cr4,%%eax"
@


1.13.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 1
a62 1
				  "\tmovl %%eax,%%cr4"
d68 1
a68 1
				  "\tmovl %%eax,%%cr4"
d124 1
a124 1
	msr11 = rdmsr (P5MSR_CTRSEL);
d127 1
a127 1
	wrmsr (P5MSR_CTRSEL, msr11);
@


1.12
log
@Cleanup, partial KNF, only use TSC on non-Intel processors.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.11 1998/05/25 08:01:42 downsj Exp $	*/
d42 1
a42 1
int pctrioctl __P((dev_t, int, caddr_t, int, struct proc *));
d192 1
a192 1
	int cmd;
@


1.11
log
@Major cleanup of configuration code; don't assume all the world is Intel, and
don't duplicate the work of locore.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.10 1997/08/16 16:31:18 mickey Exp $	*/
d32 1
a32 2
static int isintel;
static int iscyrix;
d35 1
a35 1
#define usep5ctr	(isintel && (((cpu_id >> 8) & 15) == 5) && \
d37 1
a37 2
/* I believe Cyrix supports RDPMC. */
#define usep6ctr	((isintel || iscyrix) && ((cpu_id >> 8) & 15) == 6)
d43 4
d49 2
a50 1
pctrattach (int num)
d55 1
a55 2
	isintel = (strcmp(cpu_vendor, "GenuineIntel") == 0);
	iscyrix = (strcmp(cpu_vendor, "CyrixInstead") == 0);
d82 5
a86 1
pctropen (dev_t dev, int oflags, int devtype, struct proc *p)
d94 5
a98 1
pctrclose (dev_t dev, int oflags, int devtype, struct proc *p)
d103 5
a107 2
static int
p5ctrsel (int fflag, u_int cmd, u_int fn)
d134 2
a135 1
p5ctrrd (struct pctrst *st)
d149 5
a153 2
static int
p6ctrsel (int fflag, u_int cmd, u_int fn)
d176 2
a177 1
p6ctrrd (struct pctrst *st)
d190 6
a195 1
pctrioctl (dev_t dev, int cmd, caddr_t data, int fflag, struct proc *p)
@


1.10
log
@tabs and consistensy
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.9 1997/06/15 13:45:13 dm Exp $	*/
d23 1
d27 13
a39 3
static int usetsc;
static int usep5ctr;
static int usep6ctr;
d49 2
a50 1
	pctrval id;
d52 2
a53 5
	if (num > 1) {
		printf ("Ignoring pctr device #%d\n", num);
		printf ("(config file should read `pseudo-device pctr 1')\n");
		return;
	}
a54 5
	id = __cpuid ();
	usetsc = __hastsc (id);
	usep5ctr = __hasp5ctr (id);
	usep6ctr = __hasp6ctr (id);
	
d70 1
a70 2
		printf ("pctr: Pentium Pro user-level "
			"performance counters enabled\n");
d72 1
a72 2
		printf ("pctr: Pentium performance counters and user-level "
			"cycle counter enabled\n");
d155 1
a155 1
  return 0;
@


1.9
log
@Address bug i386/224 from Jason Downs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.8 1997/05/30 07:51:12 downsj Exp $	*/
d38 1
a38 1
  pctrval id;
d40 35
a74 34
  if (num > 1) {
    printf ("Ignoring pctr device #%d\n", num);
    printf ("(config file should read `pseudo-device pctr 1')\n");
    return;
  }

  id = __cpuid ();
  usetsc = __hastsc (id);
  usep5ctr = __hasp5ctr (id);
  usep6ctr = __hasp6ctr (id);

  if (usep6ctr)
    /* Enable RDTSC and RDPMC instructions from user-level. */
    asm volatile (".byte 0xf,0x20,0xe0   # movl %%cr4,%%eax\n"
		  "\tandl %0,%%eax\n"
		  "\torl %1,%%eax\n"
		  "\t.byte 0xf,0x22,0xe0 # movl %%cr4,%%eax"
		  :: "i" (~CR4_TSD), "i" (CR4_PCE) : "eax");
  else if (usetsc)
    /* Enable RDTSC instruction from user-level. */
    asm volatile (".byte 0xf,0x20,0xe0   # movl %%cr4,%%eax\n"
		  "\tandl %0,%%eax\n"
		  "\t.byte 0xf,0x22,0xe0 # movl %%cr4,%%eax"
		  :: "i" (~CR4_TSD) : "eax");

  if (usep6ctr)
    printf ("pctr: Pentium Pro user-level performance counters enabled\n");
  else if (usep5ctr)
    printf ("pctr: Pentium performance counters and user-level "
	    "cycle counter enabled\n");
  else if (usetsc)
    printf ("pctr: user-level cycle counter enabled\n");
  else
    printf ("pctr: no performance counters in CPU\n");
d80 3
a82 3
  if (minor (dev))
    return ENXIO;
  return 0;
d88 1
a88 1
  return 0;
d94 20
a113 20
  pctrval msr11;
  int msr;
  int shift;

  cmd -= PCIOCS0;
  if (cmd > 1)
    return EINVAL;
  msr = P5MSR_CTR0 + cmd;
  shift = cmd ? 0x10 : 0;

  if (! (fflag & FWRITE))
    return EPERM;
  if (fn >= 0x200)
    return EINVAL;

  msr11 = rdmsr (0x11);
  msr11 &= ~(0x1ffLL << shift);
  msr11 |= fn << shift;
  wrmsr (0x11, msr11);
  wrmsr (msr, 0);
d115 1
a115 1
  return 0;
d118 1
a118 1
static inline void
d121 1
a121 1
  u_int msr11;
d123 8
a130 8
  msr11 = rdmsr (P5MSR_CTRSEL);
  st->pctr_fn[0] = msr11 & 0xffff;
  st->pctr_fn[1] = msr11 >> 16;
  __asm __volatile ("cli");
  st->pctr_tsc = rdtsc ();
  st->pctr_hwc[0] = rdmsr (P5MSR_CTR0);
  st->pctr_hwc[1] = rdmsr (P5MSR_CTR1);
  __asm __volatile ("sti");
d136 1
a136 1
  int msrsel, msrval;
d138 14
a151 14
  cmd -= PCIOCS0;
  if (cmd > 1)
    return EINVAL;
  msrsel = P6MSR_CTRSEL0 + cmd;
  msrval = P6MSR_CTR0 + cmd;

  if (! (fflag & FWRITE))
    return EPERM;
  if (fn & 0x380000)
    return EINVAL;

  wrmsr (msrval, 0);
  wrmsr (msrsel, fn);
  wrmsr (msrval, 0);
d156 1
a156 1
static inline void
d159 7
a165 7
  st->pctr_fn[0] = rdmsr (P6MSR_CTRSEL0);
  st->pctr_fn[1] = rdmsr (P6MSR_CTRSEL1);
  __asm __volatile ("cli");
  st->pctr_tsc = rdtsc ();
  st->pctr_hwc[0] = rdpmc (0);
  st->pctr_hwc[1] = rdpmc (1);
  __asm __volatile ("sti");
d172 27
a198 27
  switch (cmd) {
  case PCIOCRD:
    {
      struct pctrst *st = (void *) data;

      if (usep6ctr)
	p6ctrrd (st);
      else if (usep5ctr)
	p5ctrrd (st);
      else {
	bzero (st, sizeof (*st));
	if (usetsc)
	  st->pctr_tsc = rdtsc ();
      }
      st->pctr_idl = pctr_idlcnt;
      return 0;
    }
  case PCIOCS0:
  case PCIOCS1:
    if (usep6ctr)
      return p6ctrsel (fflag, cmd, *(u_int *) data);
    if (usep5ctr)
      return p5ctrsel (fflag, cmd, *(u_int *) data);
    return ENODEV;
  default:
    return EINVAL;
  }
@


1.8
log
@Add some protos so it compiles.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.7 1996/10/20 15:27:53 dm Exp $	*/
d40 5
a44 2
  if (num > 1)
    panic ("no more than one pctr device");
@


1.7
log
@Truncate rdpmc result to 40 bits.  Make pctr.c build with -Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.6 1996/08/16 00:02:36 dm Exp $	*/
d29 5
@


1.6
log
@Some mostly cosmetic bug fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.5 1996/08/14 22:03:15 dm Exp $	*/
d17 1
d109 1
a109 1
static inline int
d147 1
a147 1
static inline int
@


1.5
log
@Pentium Pro support
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.4 1996/08/14 03:02:54 dm Exp $	*/
d185 1
a185 1
    return EINVAL;
@


1.4
log
@Added support in the driver for the Pentium Pro (pctrctl still needs to
be done, though).
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.3 1996/08/08 22:21:23 dm Exp $	*/
d59 2
a60 1
    printf ("pctr: Pentium performance counters enabled\n");
d62 1
a62 1
    printf ("pctr: Cycle counter enabled\n");
d64 1
a64 1
    printf ("pctr: Performance counters not supported by CPU\n");
d103 1
a103 1
  wrmsr (msr, 0LL);
d139 1
d141 1
a141 1
  wrmsr (msrval, 0LL);
d153 2
a154 2
  st->pctr_hwc[0] = rdmsr (P6MSR_CTR0);
  st->pctr_hwc[1] = rdmsr (P6MSR_CTR1);
@


1.3
log
@Allow idle loop to be read even on 486's.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.2 1996/08/08 21:37:31 dm Exp $	*/
d5 6
a10 1
 * Author: David Mazieres <dm@@lcs.mit.edu>
a23 1
static int cpuid;
d25 3
a27 16
#define rdtsc()						\
({							\
  pctrval v;						\
  __asm __volatile (".byte 0xf, 0x31" : "=A" (v));	\
  v;							\
})

#define rdmsr(msr)						\
({								\
  pctrval v;							\
  __asm __volatile (".byte 0xf, 0x32" : "=A" (v) : "c" (msr));	\
  v;								\
})

#define wrmsr(msr, v) \
     __asm __volatile (".byte 0xf, 0x30" :: "A" (v), "c" (msr));
d32 2
d36 28
a63 18
  
  __asm __volatile ("cli\n"
		    "\tpushfl\n"
		    "\tpopl %%eax\n"
		    "\tmovl %%eax,%%ecx\n"
		    "\txorl %1,%%eax\n"
		    "\tpushl %%eax\n"
		    "\tpopfl\n"
		    "\tpushfl\n"
		    "\tpopl %%eax\n"
		    "\tpushl %%ecx\n"
		    "\tpopfl\n"
		    "\tcmpl %%eax,%%ecx\n"
		    "\tmov $0,%0\n"
		    "\tje 1f\n"
		    "\tcpuid\n"
		    "1:\tsti"
		    : "=a" (cpuid) : "i" (PSL_ID) : "edx", "ecx", "ebx");
d81 1
a81 1
pctrset (int fflag, int cmd, u_short fn)
d87 2
a88 10
  switch (cmd) {
  case PCIOCS0:
    msr = 0x12;
    shift = 0;
    break;
  case PCIOCS1:
    msr = 0x13;
    shift = 16;
    break;
  default:
d90 2
a91 1
  }
d97 1
d107 50
d163 1
a163 2
      u_int msr11;
      struct pctrst *st;
d165 4
a168 11
      st = (void *) data;
      if (cpuid == 1) {
	msr11 = rdmsr (0x11);
	st->pctr_fn[0] = msr11 & 0xffff;
	st->pctr_fn[1] = msr11 >> 16;
	__asm __volatile ("cli");
	st->pctr_tsc = rdtsc ();
	st->pctr_hwc[0] = rdmsr (0x12);
	st->pctr_hwc[1] = rdmsr (0x13);
	__asm __volatile ("sti");
      }
d171 1
a171 1
	if (cpuid)
d179 4
a182 2
    if (cpuid == 1)
      return pctrset (fflag, cmd, *(u_short *) data);
@


1.2
log
@Sadly, the performance counters don't seem to work on the pentium pro.
I'll have to find out how the P6 works and add support.
@
text
@d1 1
a1 1
/*	$OpenBSD: pctr.c,v 1.1 1996/08/08 18:47:07 dm Exp $	*/
a112 4

  if (minor (dev) || cpu_class < CPUCLASS_586)
    panic ("pctr: bad device %d should never have been opened.\n", dev);

@


1.1
log
@Added a pctr pseudo-device for accessing the Pentium performance counters,
and a program pctrctl to set the counter functions.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d19 1
d43 18
d66 1
a66 1
  if (minor (dev) || cpu_class < CPUCLASS_586)
d124 15
a138 8
      msr11 = rdmsr (0x11);
      st->pctr_fn[0] = msr11 & 0xffff;
      st->pctr_fn[1] = msr11 >> 16;
      __asm __volatile ("cli");
      st->pctr_tsc = rdtsc ();
      st->pctr_hwc[0] = rdmsr (0x12);
      st->pctr_hwc[1] = rdmsr (0x13);
      __asm __volatile ("sti");
a140 1
      break;
d144 3
a146 1
    return pctrset (fflag, cmd, *(u_short *) data);
@
