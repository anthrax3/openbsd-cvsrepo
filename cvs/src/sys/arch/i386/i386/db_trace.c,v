head	1.27;
access;
symbols
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.32
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.28
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.26
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.24
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.22
	OPENBSD_5_0:1.13.0.20
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.18
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.16
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.12
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.14
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.10
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.8
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.8
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.6
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.7
	UBC:1.4.0.24
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.22
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.20
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.18
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.14
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2017.05.29.06.14.10;	author mpi;	state Exp;
branches;
next	1.26;
commitid	kOJ4rx83W4cr7RQt;

1.26
date	2017.05.28.14.24.19;	author mpi;	state Exp;
branches;
next	1.25;
commitid	78V0YPcBVaG7RVc5;

1.25
date	2017.04.20.12.41.43;	author visa;	state Exp;
branches;
next	1.24;
commitid	Ok8Q9JWEGQTbpDky;

1.24
date	2017.02.06.09.13.41;	author mpi;	state Exp;
branches;
next	1.23;
commitid	wTgEeyM3ktFNF2jh;

1.23
date	2017.01.24.00.58.55;	author mpi;	state Exp;
branches;
next	1.22;
commitid	r0ks7yUPmANG37rA;

1.22
date	2016.09.18.13.38.01;	author jasper;	state Exp;
branches;
next	1.21;
commitid	jng6DdJvIh9i8Y2h;

1.21
date	2016.09.10.06.36.26;	author jasper;	state Exp;
branches;
next	1.20;
commitid	5zt7PjkXY2TQIokA;

1.20
date	2016.09.09.19.42.30;	author jasper;	state Exp;
branches;
next	1.19;
commitid	Qbet0NVZpZWm8AJv;

1.19
date	2016.03.03.12.44.09;	author mpi;	state Exp;
branches;
next	1.18;
commitid	C5OsdVbmpqsebKWq;

1.18
date	2016.03.01.21.35.13;	author mpi;	state Exp;
branches;
next	1.17;
commitid	cgyWVaMY5TPuOMDK;

1.17
date	2016.03.01.21.28.24;	author mpi;	state Exp;
branches;
next	1.16;
commitid	2tGVUgQfuQ1vj5lQ;

1.16
date	2016.02.26.09.29.20;	author mpi;	state Exp;
branches;
next	1.15;
commitid	Hq6GdUGmjFfywwuz;

1.15
date	2015.06.28.01.11.27;	author guenther;	state Exp;
branches;
next	1.14;
commitid	pmt8zLCdl4eF6ZNV;

1.14
date	2014.07.13.12.11.01;	author jasper;	state Exp;
branches;
next	1.13;
commitid	XHZxhpAa5R1Ymp1z;

1.13
date	2006.11.28.18.56.17;	author uwe;	state Exp;
branches;
next	1.12;

1.12
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.11.13.21.11;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.02.16.29.55;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.20.09.51.22;	author andreas;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.16.04.15.17;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.18.09.49.17;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.16.13.01.41;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.03.21.02.10.42;	author niklas;	state Exp;
branches
	1.4.14.1
	1.4.24.1;
next	1.3;

1.3
date	96.05.07.07.21.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.11.11.16.44;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.32;	author deraadt;	state Exp;
branches;
next	;

1.4.14.1
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.4.14.2;

1.4.14.2
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.4.14.3;

1.4.14.3
date	2003.06.07.11.11.36;	author ho;	state Exp;
branches;
next	;

1.4.24.1
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	1.4.24.2;

1.4.24.2
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Pass the symbol instead of its name when looking for CTF infos.

ok jasper@@
@
text
@/*	$OpenBSD: db_trace.c,v 1.26 2017/05/28 14:24:19 mpi Exp $	*/
/*	$NetBSD: db_trace.c,v 1.18 1996/05/03 19:42:01 christos Exp $	*/

/*
 * Mach Operating System
 * Copyright (c) 1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/user.h>

#include <machine/db_machdep.h>

#include <ddb/db_sym.h>
#include <ddb/db_access.h>
#include <ddb/db_variables.h>
#include <ddb/db_output.h>
#include <ddb/db_interface.h>

/*
 * Machine register set.
 */
struct db_variable db_regs[] = {
	{ "ds",		(long *)&ddb_regs.tf_ds,     FCN_NULL },
	{ "es",		(long *)&ddb_regs.tf_es,     FCN_NULL },
	{ "fs",		(long *)&ddb_regs.tf_fs,     FCN_NULL },
	{ "gs",		(long *)&ddb_regs.tf_gs,     FCN_NULL },
	{ "edi",	(long *)&ddb_regs.tf_edi,    FCN_NULL },
	{ "esi",	(long *)&ddb_regs.tf_esi,    FCN_NULL },
	{ "ebp",	(long *)&ddb_regs.tf_ebp,    FCN_NULL },
	{ "ebx",	(long *)&ddb_regs.tf_ebx,    FCN_NULL },
	{ "edx",	(long *)&ddb_regs.tf_edx,    FCN_NULL },
	{ "ecx",	(long *)&ddb_regs.tf_ecx,    FCN_NULL },
	{ "eax",	(long *)&ddb_regs.tf_eax,    FCN_NULL },
	{ "eip",	(long *)&ddb_regs.tf_eip,    FCN_NULL },
	{ "cs",		(long *)&ddb_regs.tf_cs,     FCN_NULL },
	{ "eflags",	(long *)&ddb_regs.tf_eflags, FCN_NULL },
	{ "esp",	(long *)&ddb_regs.tf_esp,    FCN_NULL },
	{ "ss",		(long *)&ddb_regs.tf_ss,     FCN_NULL },
};
struct db_variable *db_eregs = db_regs + nitems(db_regs);

/*
 * Stack trace.
 */
#define	INKERNEL(va)	(((vaddr_t)(va)) >= VM_MIN_KERNEL_ADDRESS)

#define	NONE		0
#define	TRAP		1
#define	SYSCALL		2
#define	INTERRUPT	3
#define	AST		4

int db_numargs(struct callframe *, db_sym_t);
void db_nextframe(struct callframe **, db_addr_t *, int *, int,
    int (*pr)(const char *, ...));

/*
 * Figure out how many arguments were passed into the frame at "fp".
 */
int
db_numargs(struct callframe *fp, db_sym_t sym)
{
	int	*argp;
	int	inst;
	int	args;
	extern char	etext[];

#ifdef DDBCTF
	if ((args = db_ctf_func_numargs(sym)) != -1)
		return args;
#endif /* DDBCTF */

	argp = (int *)db_get_value((int)&fp->f_retaddr, 4, FALSE);
	if (argp < (int *)VM_MIN_KERNEL_ADDRESS || argp > (int *)etext) {
		args = 5;
	} else {
		inst = db_get_value((int)argp, 4, FALSE);
		if ((inst & 0xff) == 0x59)	/* popl %ecx */
			args = 1;
		else if ((inst & 0xffff) == 0xc483)	/* addl %n, %esp */
			args = ((inst >> 16) & 0xff) / 4;
		else
			args = 5;
	}
	return args;
}

/*
 * Figure out the next frame up in the call stack.
 * For trap(), we print the address of the faulting instruction and
 *   proceed with the calling frame.  We return the ip that faulted.
 *   If the trap was caused by jumping through a bogus pointer, then
 *   the next line in the backtrace will list some random function as
 *   being called.  It should get the argument list correct, though.
 *   It might be possible to dig out from the next frame up the name
 *   of the function that faulted, but that could get hairy.
 */
void
db_nextframe(struct callframe **fp, db_addr_t	*ip, int *argp, int is_trap,
    int (*pr)(const char *, ...))
{

	switch (is_trap) {
	    case NONE:
		*ip = (db_addr_t)
			db_get_value((int) &(*fp)->f_retaddr, 4, FALSE);
		*fp = (struct callframe *)
			db_get_value((int) &(*fp)->f_frame, 4, FALSE);
		break;

	    default: {
		struct trapframe *tf;

		/* The only argument to trap() or syscall() is the trapframe. */
		tf = (struct trapframe *)argp;
		switch (is_trap) {
		case TRAP:
			(*pr)("--- trap (number %d) ---\n", tf->tf_trapno);
			break;
		case AST:
			(*pr)("--- ast ---\n");
			break;
		case SYSCALL:
			(*pr)("--- syscall (number %d) ---\n", tf->tf_eax);
			break;
		case INTERRUPT:
			(*pr)("--- interrupt ---\n");
			break;
		}
		*fp = (struct callframe *)tf->tf_ebp;
		*ip = (db_addr_t)tf->tf_eip;
		break;
	    }
	}
}

static inline int
db_is_trap(const char *name)
{
	if (name != NULL) {
		if (!strcmp(name, "trap"))
			return TRAP;
		if (!strcmp(name, "ast"))
			return AST;
		if (!strcmp(name, "syscall"))
			return SYSCALL;
		if (name[0] == 'X') {
			if (!strncmp(name, "Xintr", 5) ||
			    !strncmp(name, "Xresume", 7) ||
			    !strncmp(name, "Xstray", 6) ||
			    !strncmp(name, "Xhold", 5) ||
			    !strncmp(name, "Xrecurse", 8) ||
			    !strcmp(name, "Xdoreti") ||
			    !strncmp(name, "Xsoft", 5))
				return INTERRUPT;
		}
	}
	return NONE;
}

void
db_stack_trace_print(db_expr_t addr, boolean_t have_addr, db_expr_t count,
    char *modif, int (*pr)(const char *, ...))
{
	struct callframe *frame, *lastframe;
	int		*argp, *arg0;
	db_addr_t	callpc;
	int		is_trap = 0;
	boolean_t	kernel_only = TRUE;
	boolean_t	trace_thread = FALSE;
	boolean_t	trace_proc = FALSE;

	{
		char *cp = modif;
		char c;

		while ((c = *cp++) != 0) {
			if (c == 't')
				trace_thread = TRUE;
			if (c == 'p')
				trace_proc = TRUE;
			if (c == 'u')
				kernel_only = FALSE;
		}
	}

	if (count == -1)
		count = 65535;

	if (!have_addr) {
		frame = (struct callframe *)ddb_regs.tf_ebp;
		callpc = (db_addr_t)ddb_regs.tf_eip;
	} else if (trace_thread) {
		(*pr) ("%s: can't trace thread\n", __func__);
	} else if (trace_proc) {
		struct proc *p = tfind((pid_t)addr);
		if (p == NULL) {
			(*pr) ("not found\n");
			return;
		}
		frame = (struct callframe *)p->p_addr->u_pcb.pcb_ebp;
		callpc = (db_addr_t)
		    db_get_value((int)&frame->f_retaddr, 4, FALSE);
	} else {
		frame = (struct callframe *)addr;
		callpc = (db_addr_t)
			 db_get_value((int)&frame->f_retaddr, 4, FALSE);
	}

	lastframe = 0;
	while (count && frame != 0) {
		int		narg;
		char *	name;
		db_expr_t	offset;
		db_sym_t	sym;

		sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);
		db_symbol_values(sym, &name, NULL);

		if (lastframe == 0 && sym == NULL) {
			/* Symbol not found, peek at code */
			int	instr = db_get_value(callpc, 4, FALSE);

			offset = 1;
			if ((instr & 0x00ffffff) == 0x00e58955 ||
					/* enter: pushl %ebp, movl %esp, %ebp */
			    (instr & 0x0000ffff) == 0x0000e589
					/* enter+1: movl %esp, %ebp */) {
				offset = 0;
			}
		}
		if (INKERNEL(callpc) && (is_trap = db_is_trap(name)) != NONE)
			narg = 0;
		else {
			is_trap = NONE;
			narg = db_numargs(frame, sym);
		}

		(*pr)("%s(", name);

		if (lastframe == 0 && offset == 0 && !have_addr) {
			/*
			 * We have a breakpoint before the frame is set up
			 * Use %esp instead
			 */
			arg0 =
			    &((struct callframe *)(ddb_regs.tf_esp-4))->f_arg0;
		} else {
			arg0 = &frame->f_arg0;
		}

		for (argp = arg0; narg > 0; ) {
			(*pr)("%x", db_get_value((int)argp, 4, FALSE));
			argp++;
			if (--narg != 0)
				(*pr)(",");
		}
		(*pr)(") at ");
		db_printsym(callpc, DB_STGY_PROC, pr);
		(*pr)("\n");

		if (lastframe == 0 && offset == 0 && !have_addr && !is_trap) {
			/* Frame really belongs to next callpc */
			lastframe = (struct callframe *)(ddb_regs.tf_esp-4);
			callpc = (db_addr_t)
				 db_get_value((int)&lastframe->f_retaddr, 4, FALSE);
			continue;
		}

		lastframe = frame;
		db_nextframe(&frame, &callpc, arg0, is_trap, pr);

		if (frame == 0) {
			/* end of chain */
			break;
		}
		if (INKERNEL(frame)) {
			/* staying in kernel */
			if (frame <= lastframe) {
				(*pr)("Bad frame pointer: %p\n", frame);
				break;
			}
		} else if (INKERNEL(lastframe)) {
			/* switch from user to kernel */
			if (kernel_only)
				break;	/* kernel stack only */
		} else {
			/* in user */
			if (frame <= lastframe) {
				(*pr)("Bad user frame pointer: %p\n",
					  frame);
				break;
			}
		}
		--count;
	}

	if (count && is_trap != NONE) {
		db_printsym(callpc, DB_STGY_XTRN, pr);
		(*pr)(":\n");
	}
}

void
db_save_stack_trace(struct db_stack_trace *st)
{
	struct callframe *frame, *lastframe;
	db_addr_t	callpc;
	unsigned int	i;

	frame = __builtin_frame_address(0);
	callpc = db_get_value((int)&frame->f_retaddr, 4, FALSE);

	lastframe = NULL;
	for (i = 0; i < DB_STACK_TRACE_MAX && frame != NULL; i++) {
		char		*name;
		db_expr_t	offset;
		db_sym_t	sym;
		int		is_trap = 0;

		st->st_pc[st->st_count++] = callpc;
		sym = db_search_symbol(callpc, DB_STGY_ANY, &offset);
		db_symbol_values(sym, &name, NULL);

		if (INKERNEL(callpc))
			is_trap = db_is_trap(name);
		else
			is_trap = NONE;

		lastframe = frame;
		if (is_trap == NONE) {
			callpc = frame->f_retaddr;
			frame = frame->f_frame;
		} else {
			struct trapframe *tf;

			tf = (struct trapframe *)&frame->f_arg0;
			callpc = (db_addr_t)tf->tf_eip;
			frame = (struct callframe *)tf->tf_ebp;
		}

		if (!INKERNEL(frame))
			break;
		if (frame <= lastframe)
			break;
	}
}

vaddr_t
db_get_pc(struct trapframe *tf)
{
	struct callframe *cf;

	if (KERNELMODE(tf->tf_cs, tf->tf_eflags))
		cf = (struct callframe *)((long)&tf->tf_esp - sizeof(long));
	else
		cf = (struct callframe *)(tf->tf_esp - sizeof(long));

	return db_get_value((db_addr_t)&cf->f_retaddr, sizeof(long), 0);
}

vaddr_t
db_get_probe_addr(struct trapframe *tf)
{
	return tf->tf_eip - BKPT_SIZE;
}
@


1.26
log
@If a function is not found in the CTF data, do not assume it takes no
argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.25 2017/04/20 12:41:43 visa Exp $	*/
a36 3
#ifdef DDBCTF
#include <ddb/db_extern.h>
#endif
d77 1
a77 1
int db_numargs(struct callframe *, const char *);
d85 1
a85 1
db_numargs(struct callframe *fp, const char *sym)
d260 1
a260 1
			narg = db_numargs(frame, name);
@


1.25
log
@Add routines for saving stack traces and printing saved traces
on amd64 and i386.

With guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.24 2017/02/06 09:13:41 mpi Exp $	*/
a89 3
#ifdef DDBCTF
	return db_ctf_func_numargs(sym);
#else
d95 5
d112 1
a112 2
	return (args);
#endif
@


1.24
log
@Implement Dynamic Profiling, a ddb(4) based & gprof compatible kernel
profiling framework, for i386.

Code patching is used to enable probes when entering functions.  The
probes will call a mcount()-like function to match the behavior of a
GPROF kernel.

A new sysctl knob, ddb.profile, need to be set to 1 in securelevel 0
to be able to use this feature.

ok jasper@@, guenther@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.23 2017/01/24 00:58:55 mpi Exp $	*/
d163 24
d258 1
a258 17
		if (INKERNEL(callpc) && name) {
			if (!strcmp(name, "trap")) {
				is_trap = TRAP;
			} else if (!strcmp(name, "ast")) {
				is_trap = AST;
			} else if (!strcmp(name, "syscall")) {
				is_trap = SYSCALL;
			} else if (!strncmp(name, "Xintr", 5) ||
			    !strncmp(name, "Xresume", 7) ||
			    !strncmp(name, "Xstray", 6) ||
			    !strncmp(name, "Xhold", 5) ||
			    !strncmp(name, "Xrecurse", 8) ||
			    !strcmp(name, "Xdoreti") ||
			    !strncmp(name, "Xsoft", 5)) {
				is_trap = INTERRUPT;
			} else
				goto normal;
d260 1
a260 2
		} else {
		normal:
d303 1
a303 1
		if (INKERNEL((int)frame)) {
d309 1
a309 1
		} else if (INKERNEL((int)lastframe)) {
d327 45
@


1.23
log
@Rename pfind(9) into tfind(9) to reflect that it deals with threads.

While here document prfind(9.

with and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.22 2016/09/18 13:38:01 jasper Exp $	*/
d321 19
@


1.22
log
@as is done on amd64, allow using CTF to lookup the function parameters.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.21 2016/09/10 06:36:26 jasper Exp $	*/
d198 1
a198 1
		struct proc *p = pfind((pid_t)addr);
@


1.21
log
@take it one step further and bring the message inline with arm/sparc64

pointed out by guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.20 2016/09/09 19:42:30 jasper Exp $	*/
d37 3
d80 1
a80 1
int db_numargs(struct callframe *);
d88 1
a88 1
db_numargs(struct callframe *fp)
d90 3
d111 1
d255 1
a255 1
			narg = db_numargs(frame);
@


1.20
log
@don't hardcode the filename in an error message; use the function name instead

ok jsg@@ (who spotted the powerpc straggler too) millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.19 2016/03/03 12:44:09 mpi Exp $	*/
d193 1
a193 1
			(*pr) ("%s: process not found\n", __func__);
@


1.19
log
@Unwind the trapframe correctly when a breakpoint is set on `syscall'.

Prevent a fault in DDB on amd64.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.18 2016/03/01 21:35:13 mpi Exp $	*/
d189 1
a189 1
		(*pr) ("db_trace.c: can't trace thread\n");
d193 1
a193 1
			(*pr) ("db_trace.c: process not found\n");
@


1.18
log
@db_sym_numargs() has always been defined to FALSE so nuke it with all
its associated dead code.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.17 2016/03/01 21:28:24 mpi Exp $	*/
d161 1
a161 1
	int		*argp;
d227 1
a227 1
		if (INKERNEL((int)frame) && name) {
d258 2
a259 1
			argp = &((struct callframe *)(ddb_regs.tf_esp-4))->f_arg0;
d261 1
a261 1
			argp = &frame->f_arg0;
d264 1
a264 1
		while (narg) {
d274 1
a274 1
		if (lastframe == 0 && offset == 0 && !have_addr) {
d283 1
a283 1
		db_nextframe(&frame, &callpc, &frame->f_arg0, is_trap, pr);
@


1.17
log
@Kill never called db_find_trace_symbols().

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.16 2016/02/26 09:29:20 mpi Exp $	*/
a210 2
#define MAXNARG	16
		char	*argnames[MAXNARG], **argnp = NULL;
d248 1
a248 5
			narg = MAXNARG;
			if (db_sym_numargs(sym, &narg, argnames))
				argnp = argnames;
			else
				narg = db_numargs(frame);
a263 2
			if (argnp)
				(*pr)("%s=", *argnp++);
@


1.16
log
@Rename and move x86 calllframe definitions in <machine/frame.h> to use
it in MI code.

ok mlarkin@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.15 2015/06/28 01:11:27 guenther Exp $	*/
a76 6
db_addr_t	db_trap_symbol_value = 0;
db_addr_t	db_syscall_symbol_value = 0;
db_addr_t	db_kdintr_symbol_value = 0;
boolean_t	db_trace_symbols_found = FALSE;

void db_find_trace_symbols(void);
a80 14
void
db_find_trace_symbols(void)
{
	db_expr_t	value;

	if (db_value_of_name("trap", &value))
		db_trap_symbol_value = (db_addr_t) value;
	if (db_value_of_name("kdintr", &value))
		db_kdintr_symbol_value = (db_addr_t) value;
	if (db_value_of_name("syscall", &value))
		db_syscall_symbol_value = (db_addr_t) value;
	db_trace_symbols_found = TRUE;
}

a166 5

#if 0
	if (!db_trace_symbols_found)
		db_find_trace_symbols();
#endif
@


1.15
log
@Split AST handling from trap() into ast() and get rid of T_ASTFLT

testing by krw@@, and then many via snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.14 2014/07/13 12:11:01 jasper Exp $	*/
a70 6
struct i386_frame {
	struct i386_frame	*f_frame;
	int			f_retaddr;
	int			f_arg0;
};

d83 2
a84 2
int db_numargs(struct i386_frame *);
void db_nextframe(struct i386_frame **, db_addr_t *, int *, int,
d105 1
a105 1
db_numargs(struct i386_frame *fp)
d138 1
a138 1
db_nextframe(struct i386_frame **fp, db_addr_t	*ip, int *argp, int is_trap,
d146 1
a146 1
		*fp = (struct i386_frame *)
d169 1
a169 1
		*fp = (struct i386_frame *)tf->tf_ebp;
d180 1
a180 1
	struct i386_frame *frame, *lastframe;
d211 1
a211 1
		frame = (struct i386_frame *)ddb_regs.tf_ebp;
d221 1
a221 1
		frame = (struct i386_frame *)p->p_addr->u_pcb.pcb_ebp;
d225 1
a225 1
		frame = (struct i386_frame *)addr;
d289 1
a289 1
			argp = &((struct i386_frame *)(ddb_regs.tf_esp-4))->f_arg0;
d308 1
a308 1
			lastframe = (struct i386_frame *)(ddb_regs.tf_esp-4);
@


1.14
log
@use nitems() instead of handrolling something identical

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.13 2006/11/28 18:56:17 uwe Exp $	*/
d81 1
d165 3
d263 2
@


1.13
log
@Support "trace /p <pid>" to show the stack trace of any process.
(Keep in mind that $radix is 0x10 by default.); ok by many
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.12 2006/09/19 11:06:33 jsg Exp $	*/
d64 1
a64 1
struct db_variable *db_eregs = db_regs + sizeof(db_regs)/sizeof(db_regs[0]);
@


1.12
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.11 2006/05/11 13:21:11 mickey Exp $	*/
d33 1
d188 1
d202 2
d217 9
@


1.11
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.10 2004/07/02 16:29:55 niklas Exp $	*/
d92 1
a92 1
db_find_trace_symbols()
d109 1
a109 2
db_numargs(fp)
	struct i386_frame *fp;
d142 2
a143 6
db_nextframe(fp, ip, argp, is_trap, pr)
	struct i386_frame **fp;		/* in/out */
	db_addr_t	*ip;		/* out */
	int *argp;			/* in */
	int is_trap;			/* in */
	int (*pr)(const char *, ...);
d178 2
a179 6
db_stack_trace_print(addr, have_addr, count, modif, pr)
	db_expr_t	addr;
	boolean_t	have_addr;
	db_expr_t	count;
	char		*modif;
	int		(*pr)(const char *, ...);
d194 2
a195 2
		register char *cp = modif;
		register char c;
@


1.10
log
@Maintain %f and %gs over traps.  Mostly from NetBSD.  Preparation for SMP
speedups.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.9 2003/05/20 09:51:22 andreas Exp $	*/
d4 1
a4 1
/* 
d8 1
a8 1
 * 
d14 1
a14 1
 * 
d18 1
a18 1
 * 
d20 1
a20 1
 * 
d25 1
a25 1
 * 
d132 3
a134 3
/* 
 * Figure out the next frame up in the call stack.  
 * For trap(), we print the address of the faulting instruction and 
d137 2
a138 2
 *   the next line in the backtrace will list some random function as 
 *   being called.  It should get the argument list correct, though.  
@


1.9
log
@Make the ddb trace command recognize elfish names
niklas@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.8 2003/01/16 04:15:17 art Exp $	*/
d46 1
d48 2
a49 1
	{ "ds",		(long *)&ddb_regs.tf_ds,     FCN_NULL },
@


1.8
log
@Getting rid of vm_offset_t
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.7 2002/05/18 09:49:17 art Exp $	*/
d94 1
a94 1
	if (db_value_of_name("_trap", &value))
d96 1
a96 1
	if (db_value_of_name("_kdintr", &value))
d98 1
a98 1
	if (db_value_of_name("_syscall", &value))
d251 1
a251 1
			if (!strcmp(name, "_trap")) {
d253 1
a253 1
			} else if (!strcmp(name, "_syscall")) {
d255 8
a262 11
			} else if (name[0] == '_' && name[1] == 'X') {
				if (!strncmp(name, "_Xintr", 6) ||
				    !strncmp(name, "_Xresume", 8) ||
				    !strncmp(name, "_Xstray", 7) ||
				    !strncmp(name, "_Xhold", 6) ||
				    !strncmp(name, "_Xrecurse", 9) ||
				    !strcmp(name, "_Xdoreti") ||
				    !strncmp(name, "_Xsoft", 6)) {
					is_trap = INTERRUPT;
				} else
					goto normal;
@


1.7
log
@Rename the MD db_stack_trace_cmd to db_stack_trace_print. Add an argument
that specifies which printf funciton it should use. Implement
db_stack_trace_cmd in MI code.

Thanks to miod@@ for all the tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.6 2002/05/16 13:01:41 art Exp $	*/
d66 1
a66 1
#define	INKERNEL(va)	(((vm_offset_t)(va)) >= VM_MIN_KERNEL_ADDRESS)
@


1.6
log
@Add a an argument to db_printsym that specifies the printf function
we'll use for printing the information.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.5 2002/03/14 01:26:32 millert Exp $	*/
d86 2
a87 1
void db_nextframe(struct i386_frame **, db_addr_t *, int *, int);
d141 1
a141 1
db_nextframe(fp, ip, argp, is_trap)
d146 1
d164 1
a164 1
			db_printf("--- trap (number %d) ---\n", tf->tf_trapno);
d167 1
a167 1
			db_printf("--- syscall (number %d) ---\n", tf->tf_eax);
d170 1
a170 1
			db_printf("--- interrupt ---\n");
d181 1
a181 1
db_stack_trace_cmd(addr, have_addr, count, modif)
d186 1
d219 1
a219 1
		db_printf ("db_trace.c: can't trace thread\n");
d279 1
a279 1
		db_printf("%s(", name);
d293 2
a294 2
				db_printf("%s=", *argnp++);
			db_printf("%x", db_get_value((int)argp, 4, FALSE));
d297 1
a297 1
				db_printf(",");
d299 3
a301 3
		db_printf(") at ");
		db_printsym(callpc, DB_STGY_PROC, db_printf);
		db_printf("\n");
d312 1
a312 1
		db_nextframe(&frame, &callpc, &frame->f_arg0, is_trap);
d321 1
a321 1
				db_printf("Bad frame pointer: %p\n", frame);
d331 1
a331 1
				db_printf("Bad user frame pointer: %p\n",
d340 2
a341 2
		db_printsym(callpc, DB_STGY_XTRN, db_printf);
		db_printf(":\n");
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.4 1997/03/21 02:10:42 niklas Exp $	*/
d297 1
a297 1
		db_printsym(callpc, DB_STGY_PROC);
d337 1
a337 1
		db_printsym(callpc, DB_STGY_XTRN);
@


1.4
log
@Yet more DDB type correctness
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.3 1996/05/07 07:21:35 deraadt Exp $	*/
d84 3
a86 3
void db_find_trace_symbols __P((void));
int db_numargs __P((struct i386_frame *));
void db_nextframe __P((struct i386_frame **, db_addr_t *, int *, int));
@


1.4.24.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.4 1997/03/21 02:10:42 niklas Exp $	*/
d84 3
a86 4
void db_find_trace_symbols(void);
int db_numargs(struct i386_frame *);
void db_nextframe(struct i386_frame **, db_addr_t *, int *, int,
    int (*pr)(const char *, ...));
d140 1
a140 1
db_nextframe(fp, ip, argp, is_trap, pr)
a144 1
	int (*pr)(const char *, ...);
d162 1
a162 1
			(*pr)("--- trap (number %d) ---\n", tf->tf_trapno);
d165 1
a165 1
			(*pr)("--- syscall (number %d) ---\n", tf->tf_eax);
d168 1
a168 1
			(*pr)("--- interrupt ---\n");
d179 1
a179 1
db_stack_trace_print(addr, have_addr, count, modif, pr)
a183 1
	int		(*pr)(const char *, ...);
d216 1
a216 1
		(*pr) ("db_trace.c: can't trace thread\n");
d276 1
a276 1
		(*pr)("%s(", name);
d290 2
a291 2
				(*pr)("%s=", *argnp++);
			(*pr)("%x", db_get_value((int)argp, 4, FALSE));
d294 1
a294 1
				(*pr)(",");
d296 3
a298 3
		(*pr)(") at ");
		db_printsym(callpc, DB_STGY_PROC, pr);
		(*pr)("\n");
d309 1
a309 1
		db_nextframe(&frame, &callpc, &frame->f_arg0, is_trap, pr);
d318 1
a318 1
				(*pr)("Bad frame pointer: %p\n", frame);
d328 1
a328 1
				(*pr)("Bad user frame pointer: %p\n",
d337 2
a338 2
		db_printsym(callpc, DB_STGY_XTRN, pr);
		(*pr)(":\n");
@


1.4.24.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 1
a66 1
#define	INKERNEL(va)	(((vaddr_t)(va)) >= VM_MIN_KERNEL_ADDRESS)
@


1.4.14.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 3
a86 3
void db_find_trace_symbols(void);
int db_numargs(struct i386_frame *);
void db_nextframe(struct i386_frame **, db_addr_t *, int *, int);
@


1.4.14.2
log
@Sync the SMP branch with 3.3
@
text
@d66 1
a66 1
#define	INKERNEL(va)	(((vaddr_t)(va)) >= VM_MIN_KERNEL_ADDRESS)
d86 1
a86 2
void db_nextframe(struct i386_frame **, db_addr_t *, int *, int,
    int (*pr)(const char *, ...));
d140 1
a140 1
db_nextframe(fp, ip, argp, is_trap, pr)
a144 1
	int (*pr)(const char *, ...);
d162 1
a162 1
			(*pr)("--- trap (number %d) ---\n", tf->tf_trapno);
d165 1
a165 1
			(*pr)("--- syscall (number %d) ---\n", tf->tf_eax);
d168 1
a168 1
			(*pr)("--- interrupt ---\n");
d179 1
a179 1
db_stack_trace_print(addr, have_addr, count, modif, pr)
a183 1
	int		(*pr)(const char *, ...);
d216 1
a216 1
		(*pr) ("db_trace.c: can't trace thread\n");
d276 1
a276 1
		(*pr)("%s(", name);
d290 2
a291 2
				(*pr)("%s=", *argnp++);
			(*pr)("%x", db_get_value((int)argp, 4, FALSE));
d294 1
a294 1
				(*pr)(",");
d296 3
a298 3
		(*pr)(") at ");
		db_printsym(callpc, DB_STGY_PROC, pr);
		(*pr)("\n");
d309 1
a309 1
		db_nextframe(&frame, &callpc, &frame->f_arg0, is_trap, pr);
d318 1
a318 1
				(*pr)("Bad frame pointer: %p\n", frame);
d328 1
a328 1
				(*pr)("Bad user frame pointer: %p\n",
d337 2
a338 2
		db_printsym(callpc, DB_STGY_XTRN, pr);
		(*pr)(":\n");
@


1.4.14.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.4.14.2 2003/03/27 23:26:55 niklas Exp $	*/
d94 1
a94 1
	if (db_value_of_name("trap", &value))
d96 1
a96 1
	if (db_value_of_name("kdintr", &value))
d98 1
a98 1
	if (db_value_of_name("syscall", &value))
d251 1
a251 1
			if (!strcmp(name, "trap")) {
d253 1
a253 1
			} else if (!strcmp(name, "syscall")) {
d255 11
a265 8
			} else if (!strncmp(name, "Xintr", 5) ||
			    !strncmp(name, "Xresume", 7) ||
			    !strncmp(name, "Xstray", 6) ||
			    !strncmp(name, "Xhold", 5) ||
			    !strncmp(name, "Xrecurse", 8) ||
			    !strcmp(name, "Xdoreti") ||
			    !strncmp(name, "Xsoft", 5)) {
				is_trap = INTERRUPT;
@


1.3
log
@sync with 0504; prototype changes
@
text
@d1 1
a1 1
/*	$OpenBSD: db_trace.c,v 1.2 1996/03/11 11:16:44 mickey Exp $	*/
d46 14
a59 14
	{ "es",		&ddb_regs.tf_es,     FCN_NULL },
	{ "ds",		&ddb_regs.tf_ds,     FCN_NULL },
	{ "edi",	&ddb_regs.tf_edi,    FCN_NULL },
	{ "esi",	&ddb_regs.tf_esi,    FCN_NULL },
	{ "ebp",	&ddb_regs.tf_ebp,    FCN_NULL },
	{ "ebx",	&ddb_regs.tf_ebx,    FCN_NULL },
	{ "edx",	&ddb_regs.tf_edx,    FCN_NULL },
	{ "ecx",	&ddb_regs.tf_ecx,    FCN_NULL },
	{ "eax",	&ddb_regs.tf_eax,    FCN_NULL },
	{ "eip",	&ddb_regs.tf_eip,    FCN_NULL },
	{ "cs",		&ddb_regs.tf_cs,     FCN_NULL },
	{ "eflags",	&ddb_regs.tf_eflags, FCN_NULL },
	{ "esp",	&ddb_regs.tf_esp,    FCN_NULL },
	{ "ss",		&ddb_regs.tf_ss,     FCN_NULL },
@


1.2
log
@Debbuger changed towards the latest Mach.
Some minor changes for Linux ;) emulation.
Small bug fixes from NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: db_trace.c,v 1.17 1995/10/11 04:19:35 mycroft Exp $	*/
d31 1
d36 1
a37 1
#include <ddb/db_sym.h>
d39 2
d46 14
a59 14
	"es",	  &ddb_regs.tf_es,     FCN_NULL,
	"ds",	  &ddb_regs.tf_ds,     FCN_NULL,
	"edi",	  &ddb_regs.tf_edi,    FCN_NULL,
	"esi",	  &ddb_regs.tf_esi,    FCN_NULL,
	"ebp",	  &ddb_regs.tf_ebp,    FCN_NULL,
	"ebx",	  &ddb_regs.tf_ebx,    FCN_NULL,
	"edx",	  &ddb_regs.tf_edx,    FCN_NULL,
	"ecx",	  &ddb_regs.tf_ecx,    FCN_NULL,
	"eax",	  &ddb_regs.tf_eax,    FCN_NULL,
	"eip",	  &ddb_regs.tf_eip,    FCN_NULL,
	"cs",	  &ddb_regs.tf_cs,     FCN_NULL,
	"eflags", &ddb_regs.tf_eflags, FCN_NULL,
	"esp",	  &ddb_regs.tf_esp,    FCN_NULL,
	"ss",	  &ddb_regs.tf_ss,     FCN_NULL,
d84 4
d188 1
a188 1
	int		is_trap;
d216 1
a216 1
		printf ("db_trace.c: can't trace thread\n");
d318 1
a318 1
				db_printf("Bad frame pointer: 0x%x\n", frame);
d328 1
a328 1
				db_printf("Bad user frame pointer: 0x%x\n",
@


1.1
log
@Initial revision
@
text
@d1 1
d15 1
a15 1
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS 
d26 2
a27 2
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
