head	1.51;
access;
symbols
	OPENBSD_6_1:1.51.0.4
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.47.0.4
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.45.0.4
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.39.0.4
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.37.0.12
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.10
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.8
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.6
	OPENBSD_5_0:1.37.0.4
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.2
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.36.0.8
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.36.0.4
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.36.0.6
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.2
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.34.0.4
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.34.0.2
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.32.0.4
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.27.0.10
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.8
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.6
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.27.0.4
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.25.0.2
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.23.0.4
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.23
	UBC:1.22.0.2
	UBC_BASE:1.22
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_8:1.14.0.6
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.4
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.2
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.51
date	2016.09.25.15.23.37;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	YxqfPf79WCjoxCH9;

1.50
date	2016.08.16.18.19.15;	author tedu;	state Exp;
branches;
next	1.49;
commitid	8YFF5RvWfDxQMZDE;

1.49
date	2016.08.15.22.01.59;	author tedu;	state Exp;
branches;
next	1.48;
commitid	hzJmUc5FH2irhNvz;

1.48
date	2016.07.28.16.08.56;	author tedu;	state Exp;
branches;
next	1.47;
commitid	8inaaAl46CsTlDKC;

1.47
date	2015.09.08.07.12.56;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	UsnEcDGT4QqqoPvB;

1.46
date	2015.09.08.04.28.34;	author semarie;	state Exp;
branches;
next	1.45;
commitid	Ajpcv6B3UUP5Q4Cd;

1.45
date	2015.06.22.18.57.26;	author kettenis;	state Exp;
branches;
next	1.44;
commitid	E55PWdSNtZj8bfyG;

1.44
date	2015.05.28.20.53.05;	author jcs;	state Exp;
branches;
next	1.43;
commitid	mm0ThjDof6ifWCwA;

1.43
date	2015.02.10.22.44.35;	author miod;	state Exp;
branches;
next	1.42;
commitid	lsrmQ0A4gY4UmdnD;

1.42
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.41;
commitid	C5iGb36LQxjM60Q3;

1.41
date	2014.11.16.12.30.57;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	yv0ECmCdICvq576h;

1.40
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.39;
commitid	uzzBR7hz9ncd4O6G;

1.39
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.38;
commitid	uKVPYMN2MLxdZxzH;

1.38
date	2013.12.19.21.30.02;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2009.01.13.19.44.20;	author grange;	state Exp;
branches;
next	1.35;

1.35
date	2008.11.05.06.32.47;	author matthieu;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.07.15.00.19;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.01.15.14.44;	author martin;	state Exp;
branches;
next	1.32;

1.32
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.31;

1.31
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.27.04.08.57;	author gwk;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.11.13.21.11;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.13.14.23.26;	author martin;	state Exp;
branches;
next	1.27;

1.27
date	2003.08.15.20.32.13;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.02.23.27.47;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.26.18.25.29;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2003.01.16.04.15.17;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.08.02.24.06;	author art;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.25.13.25.32;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.16.05.07.48;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.05.23.25.39;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.05.20.56.38;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.17.21.10.31;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	99.11.20.11.11.28;	author matthieu;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	99.09.06.06.19.08;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	99.09.03.18.00.51;	author art;	state Exp;
branches;
next	1.11;

1.11
date	99.02.26.04.41.13;	author art;	state Exp;
branches;
next	1.10;

1.10
date	98.11.20.15.57.24;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.08.31.17.42.30;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.07.09.18.22.13;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.02.19.06.59.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.02.18.18.00.16;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.02.18.06.33.49;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	98.02.18.01.47.47;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.02.17.23.49.30;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	96.05.07.07.21.49;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.33;	author deraadt;	state Exp;
branches;
next	;

1.14.2.1
date	2001.04.18.16.07.21;	author niklas;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2001.07.04.10.16.37;	author niklas;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.14.2.4;

1.14.2.4
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.14.2.5;

1.14.2.5
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.14.2.6;

1.14.2.6
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.14.2.7;

1.14.2.7
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.14.2.8;

1.14.2.8
date	2003.06.07.11.11.37;	author ho;	state Exp;
branches;
next	1.14.2.9;

1.14.2.9
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	;

1.22.2.1
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.51
log
@Make a move towards ending 4 decades of kernel snooping.

Add sysctl kern.allowkmem (default 0) which controls the ability to open
/dev/mem or /dev/kmem at securelevel > 0.  Over 15 years we converted 99%
of utilities in the tree to operate on sysctl-nodes (either by themselves
or via code hiding in the guts of -lkvm).

pstat -d and -v & procmap are affected and continued use of them will
require kern.allowkmem=1 in /etc/sysctl.conf.  acpidump (and it's
buddy sendbug) are affected, but we'll work out a solution soon.

There will be some impact in ports.

ok kettenis guenther
@
text
@/*	$NetBSD: mem.c,v 1.31 1996/05/03 19:42:19 christos Exp $	*/
/*	$OpenBSD: mem.c,v 1.50 2016/08/16 18:19:15 tedu Exp $ */
/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)mem.c	8.3 (Berkeley) 1/12/94
 */

/*
 * Memory special file
 */

#include <sys/param.h>
#include <sys/buf.h>
#include <sys/systm.h>
#include <sys/uio.h>
#include <sys/ioccom.h>
#include <sys/malloc.h>
#include <sys/memrange.h>
#include <sys/fcntl.h>
#include <sys/rwlock.h>

#include <machine/cpu.h>
#include <machine/conf.h>

#include <uvm/uvm_extern.h>

extern char *vmmap;            /* poor name! */
caddr_t zeropage;

/* open counter for aperture */
#ifdef APERTURE
static int ap_open_count = 0;
extern int allowaperture;

#define VGA_START 0xA0000
#define BIOS_END  0xFFFFF
#endif

#ifdef MTRR
struct mem_range_softc mem_range_softc;
static int mem_ioctl(dev_t, u_long, caddr_t, int, struct proc *);
#endif

/*ARGSUSED*/
int
mmopen(dev_t dev, int flag, int mode, struct proc *p)
{
	extern int allowkmem;

	switch (minor(dev)) {
	case 0:
	case 1:
		if (securelevel <= 0 || allowkmem)
			break;
		return (EPERM);
	case 2:
	case 12:
		break;
#ifdef APERTURE
	case 4:
	        if (suser(p, 0) != 0 || !allowaperture)
			return (EPERM);

		/* authorize only one simultaneous open() unless
		 * allowaperture=3 */
		if (ap_open_count > 0 && allowaperture < 3)
			return(EPERM);
		ap_open_count++;
		break;
#endif
	default:
		return (ENXIO);
	}
	return (0);
}

/*ARGSUSED*/
int
mmclose(dev_t dev, int flag, int mode, struct proc *p)
{
#ifdef APERTURE
	if (minor(dev) == 4)
		ap_open_count = 0;
#endif
	return (0);
}

int
mmrw(dev_t dev, struct uio *uio, int flags)
{
	static struct rwlock physlock = RWLOCK_INITIALIZER("mmrw");
	vaddr_t o, v;
	size_t c;
	struct iovec *iov;
	int error = 0;

	if (minor(dev) == 0) {
		/* lock against other uses of shared vmmap */
		error = rw_enter(&physlock, RW_WRITE | RW_INTR);
		if (error)
			return (error);
	}
	while (uio->uio_resid > 0 && error == 0) {
		iov = uio->uio_iov;
		if (iov->iov_len == 0) {
			uio->uio_iov++;
			uio->uio_iovcnt--;
			if (uio->uio_iovcnt < 0)
				panic("mmrw");
			continue;
		}
		switch (minor(dev)) {

		/* minor device 0 is physical memory */
		case 0:
			v = uio->uio_offset;
			pmap_enter(pmap_kernel(), (vaddr_t)vmmap,
			    trunc_page(v), uio->uio_rw == UIO_READ ?
			    PROT_READ : PROT_WRITE, PMAP_WIRED);
			pmap_update(pmap_kernel());
			o = uio->uio_offset & PGOFSET;
			c = ulmin(uio->uio_resid, NBPG - o);
			error = uiomove((caddr_t)vmmap + o, c, uio);
			pmap_remove(pmap_kernel(), (vaddr_t)vmmap,
			    (vaddr_t)vmmap + NBPG);
			pmap_update(pmap_kernel());
			continue;

		/* minor device 1 is kernel memory */
		case 1:
			v = uio->uio_offset;
			c = ulmin(iov->iov_len, MAXPHYS);
			if (!uvm_kernacc((caddr_t)v, c,
			    uio->uio_rw == UIO_READ ? B_READ : B_WRITE))
				return (EFAULT);
			error = uiomove((caddr_t)v, c, uio);
			continue;

		/* minor device 2 is /dev/null */
		case 2:
			if (uio->uio_rw == UIO_WRITE)
				uio->uio_resid = 0;
			return (0);

		/* minor device 12 is /dev/zero */
		case 12:
			if (uio->uio_rw == UIO_WRITE) {
				c = iov->iov_len;
				break;
			}
			if (zeropage == NULL) {
				zeropage = malloc(PAGE_SIZE, M_TEMP,
				    M_WAITOK|M_ZERO);
			}
			c = ulmin(iov->iov_len, PAGE_SIZE);
			error = uiomove(zeropage, c, uio);
			continue;

		default:
			return (ENXIO);
		}
		iov->iov_base = (char *)iov->iov_base + c;
		iov->iov_len -= c;
		uio->uio_offset += c;
		uio->uio_resid -= c;
	}
	if (minor(dev) == 0) {
		rw_exit(&physlock);
	}
	return (error);
}

paddr_t
mmmmap(dev_t dev, off_t off, int prot)
{
	struct proc *p = curproc;	/* XXX */

	switch (minor(dev)) {
	/* minor device 0 is physical memory */
	case 0:
		if ((u_int)off > ptoa(physmem) && suser(p, 0) != 0)
			return -1;
		return off;

#ifdef APERTURE
	/* minor device 4 is aperture driver */
	case 4:
		/* Check if a write combining mapping is requested. */
		if (off >= MEMRANGE_WC_RANGE)
			off = (off - MEMRANGE_WC_RANGE) | PMAP_WC;

		switch (allowaperture) {
		case 1:
			/* Allow mapping of the VGA framebuffer & BIOS only */
			if ((off >= VGA_START && off <= BIOS_END) ||
			    (unsigned)off > (unsigned)ptoa(physmem))
				return off;
			else
				return -1;
		case 2:
		case 3:
			/* Allow mapping of the whole 1st megabyte
			   for x86emu */
			if (off <= BIOS_END ||
			    (unsigned)off > (unsigned)ptoa(physmem))
				return off;
			else
				return -1;
		default:
			return -1;
		}
			
#endif
	default:
		return -1;
	}
}

int
mmioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
#ifdef MTRR
	switch (minor(dev)) {
	case 0:
	case 4:
		return mem_ioctl(dev, cmd, data, flags, p);
	}
#endif
	return (ENODEV);
}

#ifdef MTRR
/*
 * Operations for changing memory attributes.
 *
 * This is basically just an ioctl shim for mem_range_attr_get
 * and mem_range_attr_set.
 */
static int
mem_ioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	int nd, error = 0;
	struct mem_range_op *mo = (struct mem_range_op *)data;
	struct mem_range_desc *md;
	
	/* is this for us? */
	if ((cmd != MEMRANGE_GET) &&
	    (cmd != MEMRANGE_SET))
		return (ENOTTY);

	/* any chance we can handle this? */
	if (mem_range_softc.mr_op == NULL)
		return (EOPNOTSUPP);

	/* do we have any descriptors? */
	if (mem_range_softc.mr_ndesc == 0)
		return (ENXIO);

	switch (cmd) {
	case MEMRANGE_GET:
		nd = imin(mo->mo_arg[0], mem_range_softc.mr_ndesc);
		if (nd > 0) {
			md = mallocarray(nd, sizeof(struct mem_range_desc),
			    M_MEMDESC, M_WAITOK);
			error = mem_range_attr_get(md, &nd);
			if (!error)
				error = copyout(md, mo->mo_desc,
					nd * sizeof(struct mem_range_desc));
			free(md, M_MEMDESC, nd * sizeof(struct mem_range_desc));
		} else {
			nd = mem_range_softc.mr_ndesc;
		}
		mo->mo_arg[0] = nd;
		break;
		
	case MEMRANGE_SET:
		md = malloc(sizeof(struct mem_range_desc), M_MEMDESC, M_WAITOK);
		error = copyin(mo->mo_desc, md, sizeof(struct mem_range_desc));
		/* clamp description string */
		md->mr_owner[sizeof(md->mr_owner) - 1] = 0;
		if (error == 0)
			error = mem_range_attr_set(md, &mo->mo_arg[0]);
		free(md, M_MEMDESC, sizeof(struct mem_range_desc));
		break;
	}
	return (error);
}

/*
 * Implementation-neutral, kernel-callable functions for manipulating
 * memory range attributes.
 */
int
mem_range_attr_get(struct mem_range_desc *mrd, int *arg)
{
	/* can we handle this? */
	if (mem_range_softc.mr_op == NULL)
		return (EOPNOTSUPP);

	if (*arg == 0) {
		*arg = mem_range_softc.mr_ndesc;
	} else {
		bcopy(mem_range_softc.mr_desc, mrd, (*arg) * sizeof(struct mem_range_desc));
	}
	return (0);
}

int
mem_range_attr_set(struct mem_range_desc *mrd, int *arg)
{
	/* can we handle this? */
	if (mem_range_softc.mr_op == NULL)
		return (EOPNOTSUPP);

	return (mem_range_softc.mr_op->set(&mem_range_softc, mrd, arg));
}

#endif /* MTRR */
@


1.50
log
@move static variable up to first
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.49 2016/08/15 22:01:59 tedu Exp $ */
d79 1
d84 3
@


1.49
log
@normalize some comments
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.48 2016/07/28 16:08:56 tedu Exp $ */
d118 1
a122 1
	static struct rwlock physlock = RWLOCK_INITIALIZER("mmrw");
@


1.48
log
@replace hand rolled physlock with real rwlock. ok mlarkin
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.47 2015/09/08 07:12:56 deraadt Exp $ */
a114 1
/*ARGSUSED*/
d141 1
a141 1
/* minor device 0 is physical memory */
d156 1
a156 1
/* minor device 1 is kernel memory */
d166 1
a166 1
/* minor device 2 is EOF/RATHOLE */
d172 1
a172 1
/* minor device 12 (/dev/zero) is source of nulls on read, rathole on write */
d206 1
a206 1
/* minor device 0 is physical memory */
d213 1
a213 1
/* minor device 4 is aperture driver */
a345 1

@


1.47
log
@sizes for free(); ok semarie
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.46 2015/09/08 04:28:34 semarie Exp $ */
d51 1
d123 1
a123 1
	static int physlock;
d127 3
a129 8
		while (physlock > 0) {
			physlock++;
			error = tsleep((caddr_t)&physlock, PZERO | PCATCH,
			    "mmrw", 0);
			if (error)
				return (error);
		}
		physlock = 1;
d196 1
a196 3
		if (physlock > 1)
			wakeup((caddr_t)&physlock);
		physlock = 0;
@


1.46
log
@convert several malloc(9) to mallocarray(9).

ok deraadt@@ guenther@@ "re-wrap the long lines" kettenis@@
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.45 2015/06/22 18:57:26 kettenis Exp $ */
d303 1
a303 1
			free(md, M_MEMDESC, 0);
d317 1
a317 1
		free(md, M_MEMDESC, 0);
@


1.45
log
@Make it possible to create write combing mappings through /dev/mem.  This is
done by introducining a magic offset.  Pages below this offset are mapped
with default memory attributes.  Above this offset pages are mapped write
combining.

ok mlarkin@@
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.44 2015/05/28 20:53:05 jcs Exp $ */
d297 2
a298 3
			md = (struct mem_range_desc *)
				malloc(nd * sizeof(struct mem_range_desc),
				       M_MEMDESC, M_WAITOK);
@


1.44
log
@when machdep.allowaperture sysctl is set to 3, allow concurrent access
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.43 2015/02/10 22:44:35 miod Exp $ */
d222 4
@


1.43
log
@Convert to uiomove().
ok guenther@@
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.41 2014/11/16 12:30:57 deraadt Exp $ */
d90 3
a92 2
		/* authorize only one simultaneous open() */
		if (ap_open_count > 0)
d231 1
@


1.42
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d118 1
a118 1
	int c;
d153 2
a154 2
			c = min(uio->uio_resid, (int)(NBPG - o));
			error = uiomovei((caddr_t)vmmap + o, c, uio);
d163 1
a163 1
			c = min(iov->iov_len, MAXPHYS);
d167 1
a167 1
			error = uiomovei((caddr_t)v, c, uio);
d186 2
a187 2
			c = min(iov->iov_len, PAGE_SIZE);
			error = uiomovei(zeropage, c, uio);
@


1.41
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.40 2014/09/14 14:17:23 jsg Exp $ */
d154 1
a154 1
			error = uiomove((caddr_t)vmmap + o, c, uio);
d167 1
a167 1
			error = uiomove((caddr_t)v, c, uio);
d187 1
a187 1
			error = uiomove(zeropage, c, uio);
@


1.40
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.39 2014/07/12 18:44:41 tedu Exp $ */
d150 1
a150 1
			    VM_PROT_READ : VM_PROT_WRITE, PMAP_WIRED);
@


1.39
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.38 2013/12/19 21:30:02 deraadt Exp $ */
a49 1
#include <sys/proc.h>
@


1.38
log
@Mtrr stops being a pseudo-device.  We need to probe the cpu type and
initialize the structures when we see the first cpu.  We also need to
initialize each cpu's properly (for PAT) before we setup mtrr on that
cpu.  On i386 (late hatch) we were getting this desperately wrong on
the primary cpu.

After suspend/resume, we also need to do the same work.  re-initialize
PAT before mtrr.  On some laptops apparently PAT was not turned on by the
BIOS, so we ended up with incorrect setup for the primary cpu.  Oops.

This makes mplayer on the x201 (and similar) machines work without weird
pauses after a suspend/resume.  Many other things are likely fixed.
ok kettenis
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.37 2010/12/26 15:40:59 miod Exp $ */
d299 1
a299 1
			free(md, M_MEMDESC);
d313 1
a313 1
		free(md, M_MEMDESC);
@


1.37
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.36 2009/01/13 19:44:20 grange Exp $ */
a57 2
#include "mtrr.h"

d70 1
a70 1
#if NMTRR > 0
d251 1
a251 1
#if NMTRR > 0
d261 1
a261 1
#if NMTRR > 0
d348 1
a348 1
#endif /* NMTRR > 0 */
@


1.36
log
@Trivial lvalue abuse fixes, no binary changes.
ok millert@@ tedu@@
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.35 2008/11/05 06:32:47 matthieu Exp $ */
d217 1
a217 2
		if ((u_int)off > ptoa(physmem) &&
		    suser(p, 0) != 0)
d219 1
a219 1
		return atop(off);
d229 1
a229 1
				return atop(off);
d237 1
a237 1
				return atop(off);
@


1.35
log
@since mmclose() is only called once for the final close,
set ap_open_count = 0 in mmclose() instread of decrementing it.
ok miod@@, oga@@.
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.34 2007/09/07 15:00:19 art Exp $ */
d196 1
a196 1
		(char *)iov->iov_base += c;
@


1.34
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.33 2007/09/01 15:14:44 martin Exp $ */
d111 1
a111 1
		ap_open_count--;
@


1.33
log
@replace the machine dependant bytes-to-clicks macro by the MI ptoa()
version for i386

more architectures and ctob() replacement is being worked on

prodded by and ok miod
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.32 2006/12/29 13:04:37 pedro Exp $ */
d186 2
a187 3
				zeropage = (caddr_t)
				    malloc(PAGE_SIZE, M_TEMP, M_WAITOK);
				bzero(zeropage, PAGE_SIZE);
@


1.32
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.31 2006/09/19 11:06:33 jsg Exp $ */
d218 1
a218 1
		if ((u_int)off > ctob(physmem) &&
d230 1
a230 1
			    (unsigned)off > (unsigned)ctob(physmem))
d238 1
a238 1
			    (unsigned)off > (unsigned)ctob(physmem))
@


1.31
log
@ansi/deregister
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.30 2006/05/27 04:08:57 gwk Exp $ */
d197 1
a197 1
		iov->iov_base += c;
@


1.30
log
@casting mallloc
ok uwe@@, dlg2
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.29 2006/05/11 13:21:11 mickey Exp $ */
d79 1
a79 4
mmopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d107 1
a107 4
mmclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d211 1
a211 4
mmmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
d253 1
a253 6
mmioctl(dev, cmd, data, flags, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
d273 1
a273 6
mem_ioctl(dev, cmd, data, flags, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
d328 1
a328 3
mem_range_attr_get(mrd, arg)
	struct mem_range_desc *mrd;
	int *arg;
d343 1
a343 3
mem_range_attr_set(mrd, arg)
	struct mem_range_desc *mrd;
	int *arg;
@


1.29
log
@kill trainling spaces
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.28 2005/11/13 14:23:26 martin Exp $ */
d330 1
a330 2
		md = (struct mem_range_desc *)malloc(sizeof(struct mem_range_desc),
						    M_MEMDESC, M_WAITOK);
@


1.28
log
@convert more MD macros to their MI counterparts, this time
i386_round_page(), i386_trunc_page(), i386_btop() and i386_ptob()
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.27 2003/08/15 20:32:13 tedu Exp $ */
d244 1
a244 1
			/* Allow mapping of the whole 1st megabyte 
d246 1
a246 1
			if (off <= BIOS_END || 
d249 1
a249 1
			else 
d286 1
a286 1
static int 
d320 1
a320 1
				error = copyout(md, mo->mo_desc, 
@


1.27
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.26 2003/06/02 23:27:47 millert Exp $ */
d230 1
a230 1
		return i386_btop((u_int)off);
d240 1
a240 1
				return i386_btop(off);
d248 1
a248 1
				return i386_btop(off);
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.25 2003/02/26 18:25:29 tedu Exp $ */
d93 1
a93 1
	        if (suser(p->p_ucred, &p->p_acflag) != 0 || !allowaperture)
d228 1
a228 1
		    suser(p->p_ucred, &p->p_acflag) != 0)
@


1.25
log
@eliminate some useless checks.  yichen xie's checker.

ok mickey@@
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.24 2003/01/16 04:15:17 art Exp $ */
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.24
log
@Getting rid of vm_offset_t
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.23 2002/03/14 01:26:32 millert Exp $ */
a206 2
		if (error)
			break;
@


1.23
log
@First round of __P removal in sys
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.22 2001/12/08 02:24:06 art Exp $ */
d128 1
a128 4
mmrw(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d130 3
a132 3
	register vm_offset_t o, v;
	register int c;
	register struct iovec *iov;
d161 1
a161 1
			pmap_enter(pmap_kernel(), (vm_offset_t)vmmap,
d168 2
a169 2
			pmap_remove(pmap_kernel(), (vm_offset_t)vmmap,
			    (vm_offset_t)vmmap + NBPG);
@


1.22
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.21 2001/11/06 19:53:14 miod Exp $ */
d78 1
a78 1
static int mem_ioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
@


1.22.2.1
log
@Sync UBC branch to -current
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.22 2001/12/08 02:24:06 art Exp $ */
d78 1
a78 1
static int mem_ioctl(dev_t, u_long, caddr_t, int, struct proc *);
@


1.22.2.2
log
@sync
@
text
@d2 1
a2 1
/*	$OpenBSD$ */
d128 4
a131 1
mmrw(dev_t dev, struct uio *uio, int flags)
d133 3
a135 3
	vaddr_t o, v;
	int c;
	struct iovec *iov;
d164 1
a164 1
			pmap_enter(pmap_kernel(), (vaddr_t)vmmap,
d171 2
a172 2
			pmap_remove(pmap_kernel(), (vaddr_t)vmmap,
			    (vaddr_t)vmmap + NBPG);
d210 2
@


1.21
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.20 2001/11/01 12:13:46 art Exp $ */
d167 1
d173 1
@


1.20
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.19 2001/07/25 13:25:32 art Exp $ */
a58 2

#include <vm/vm.h>
@


1.19
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.18 2001/05/16 05:07:48 millert Exp $ */
d225 1
a225 1
int
d228 2
a229 1
	int off, prot;
a240 6
/* minor device 1 is kernel memory */
	case 1:
		/* XXX - writability, executability checks? */
		if (!uvm_kernacc((caddr_t)off, NBPG, B_READ))
			return -1;
		return i386_btop(vtophys(off));
@


1.18
log
@kill COMPAT_{09,10,11} kernel options.  We still need kern_info_09.c and kern_ipc_10.c for other compat modules.
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.17 2001/05/05 23:25:39 art Exp $ */
d168 1
a168 1
			    VM_PROT_READ : VM_PROT_WRITE, TRUE, 0);
@


1.17
log
@PMAP_NEW and UVM are no longer optional on i386.
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.16 2001/05/05 20:56:38 art Exp $ */
a96 10
#ifdef COMPAT_10
	/* This is done by i386_iopl(3) now. */
	case 14:
		if (securelevel <= 0 && (flag & FWRITE)) {
			struct trapframe *fp;
			fp = curproc->p_md.md_regs;
			fp->tf_eflags |= PSL_IOPL;
		}
		break;
#endif
@


1.16
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.15 2000/12/17 21:10:31 matthieu Exp $ */
a61 1
#if defined(UVM)
a62 1
#endif
a189 1
#if defined(UVM)
a192 5
#else
			if (!kernacc((caddr_t)v, c,
			    uio->uio_rw == UIO_READ ? B_READ : B_WRITE))
				return (EFAULT);
#endif
a252 1
#if defined(UVM)
a253 3
#else
		if (!kernacc((caddr_t)off, NBPG, B_READ))
#endif
@


1.15
log
@Add a new possible value for the machdep.allowaperture sysctl: `2'
allows access to the whole 1st megabyte of memory, for use by XFree86
4.0.x int10 code.  (ok, deraadt@@) CVS:
----------------------------------------------------------------------
sys/arch/i386/i386/mem.c share/man/man4/man4.i386/xf86.4 CVS:
----------------------------------------------------------------------
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.14 1999/11/20 11:11:28 matthieu Exp $ */
d218 2
a219 2
				    malloc(CLBYTES, M_TEMP, M_WAITOK);
				bzero(zeropage, CLBYTES);
d221 1
a221 1
			c = min(iov->iov_len, CLBYTES);
@


1.14
log
@add MTRR support from FreeBSD
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.13 1999/09/06 06:19:08 matthieu Exp $ */
d271 17
a287 5
		if (allowaperture &&
		    (((off >= VGA_START && off <= BIOS_END) ||
		    (unsigned)off > (unsigned)ctob(physmem))))
			return i386_btop(off);
		else 
d289 2
@


1.14.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.15 2000/12/17 21:10:31 matthieu Exp $ */
d271 5
a275 17
		switch (allowaperture) {
		case 1:
			/* Allow mapping of the VGA framebuffer & BIOS only */
			if ((off >= VGA_START && off <= BIOS_END) ||
			    (unsigned)off > (unsigned)ctob(physmem))
				return i386_btop(off);
			else
				return -1;
		case 2:
			/* Allow mapping of the whole 1st megabyte 
			   for x86emu */
			if (off <= BIOS_END || 
			    (unsigned)off > (unsigned)ctob(physmem))
				return i386_btop(off);
			else 
				return -1;
		default:
a276 2
		}
			
@


1.14.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.14.2.1 2001/04/18 16:07:21 niklas Exp $ */
d62 1
d64 1
d99 10
d192 1
d196 5
d218 2
a219 2
				    malloc(PAGE_SIZE, M_TEMP, M_WAITOK);
				bzero(zeropage, PAGE_SIZE);
d221 1
a221 1
			c = min(iov->iov_len, PAGE_SIZE);
d261 1
d263 3
@


1.14.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.14.2.2 2001/07/04 10:16:37 niklas Exp $ */
d168 1
a168 1
			    VM_PROT_READ : VM_PROT_WRITE, PMAP_WIRED);
@


1.14.2.4
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$OpenBSD$ */
d60 2
d225 1
a225 1
paddr_t
d228 1
a228 2
	off_t off;
	int prot;
d240 6
@


1.14.2.5
log
@Merge in trunk
@
text
@a166 1
			pmap_update(pmap_kernel());
a171 1
			pmap_update(pmap_kernel());
@


1.14.2.6
log
@Merge in -current from about a week ago
@
text
@d78 1
a78 1
static int mem_ioctl(dev_t, u_long, caddr_t, int, struct proc *);
@


1.14.2.7
log
@Sync the SMP branch with 3.3
@
text
@d128 4
a131 1
mmrw(dev_t dev, struct uio *uio, int flags)
d133 3
a135 3
	vaddr_t o, v;
	int c;
	struct iovec *iov;
d164 1
a164 1
			pmap_enter(pmap_kernel(), (vaddr_t)vmmap,
d171 2
a172 2
			pmap_remove(pmap_kernel(), (vaddr_t)vmmap,
			    (vaddr_t)vmmap + NBPG);
d210 2
@


1.14.2.8
log
@Sync SMP branch to -current
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.14.2.7 2003/03/27 23:26:55 niklas Exp $ */
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.14.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 1
a2 1
/*	$OpenBSD$ */
d93 1
a93 1
	        if (suser(p, 0) != 0 || !allowaperture)
d228 1
a228 1
		    suser(p, 0) != 0)
@


1.13
log
@Some XFree86 3.9.15 drivers need to access the BIOS of the VGA boards
So widen the range allowed to be mmap()ed by the aperture driver to
the whole 640k-1Mo area.
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.12 1999/09/03 18:00:51 art Exp $ */
d51 1
d53 1
d66 2
d80 5
d282 118
@


1.12
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.11 1999/02/26 04:41:13 art Exp $ */
d73 1
a73 1
#define VGA_END   0xBFFFF
d263 1
a263 1
		    (((off >= VGA_START && off <= VGA_END) ||
@


1.11
log
@some allocation changes, name changes, etc for uvm
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.10 1998/11/20 15:57:24 deraadt Exp $ */
d171 1
a171 1
			    VM_PROT_READ : VM_PROT_WRITE, TRUE);
@


1.10
log
@careful off handling in mmap routines
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.9 1998/08/31 17:42:30 millert Exp $ */
d60 4
d183 5
d191 1
d252 3
d256 1
@


1.9
log
@Return ENXIO on open of /dev/mem minor devs that don't exist
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.8 1998/07/09 18:22:13 deraadt Exp $ */
d234 1
a234 1
		if (off > ctob(physmem) &&
d237 1
a237 1
		return i386_btop(off);
@


1.8
log
@never set PSL_IOPL at high securelevel (except the one xf86 case, controlled by the aperture driver; problem noted by csapuntz
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.7 1998/02/19 06:59:48 millert Exp $ */
d81 5
d108 1
a108 1
		break;
@


1.7
log
@missing piece of APERTURE -- return EPERM in open if allowaperture is 0.
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.6 1998/02/18 18:00:16 millert Exp $ */
d84 1
a84 1
		if (flag & FWRITE) {
@


1.6
log
@compile -- tsk tsk
@
text
@d2 1
a2 1
/*	$OpenBSD: mem.c,v 1.5 1998/02/18 06:33:49 matthieu Exp $ */
d93 1
a93 1
	        if (suser(p->p_ucred, &p->p_acflag) != 0)
@


1.5
log
@unused variables without APERTURE defined...
@
text
@d2 1
a2 1
/*	$OpenBSD$ */
d93 1
a93 1
	        if (suser(p->p_ucred, &p->p_acflag) != 0 ||
@


1.4
log
@indent
@
text
@d2 1
a2 1

d64 1
d70 1
@


1.3
log
@add an in-kernel /dev/xf86 aperture driver. the 'machdep.allowaperture'
sysctl controls whether it is permitted to access it. This sysctl can only
be manipulated when securelevel=0, hence in sysctl.conf
@
text
@d91 3
a93 6
	        if (suser(p->p_ucred, &p->p_acflag) != 0) {
			return(EPERM);
		}
		if (!allowaperture) {
			return(EPERM);
		}
d95 1
a95 1
		if (ap_open_count > 0) {
a96 1
		}
d114 1
a114 1
	if (minor(dev) == 4) {
a115 1
	}
d241 3
a243 3
		if (allowaperture 
		    && (((off >= VGA_START && off <= VGA_END )
			 || (unsigned)off > (unsigned)ctob(physmem)))) 
@


1.2
log
@sync with 0504; prototype changes
@
text
@d63 7
d89 15
a103 1

d117 5
a121 1

d243 10
a252 1

@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: mem.c,v 1.30 1995/10/11 04:19:46 mycroft Exp $	*/
a47 1
#include <sys/conf.h>
d56 1
d65 1
a65 1
mmopen(dev, flag, mode)
d68 1
d91 1
a91 1
mmclose(dev, flag, mode)
d94 1
a189 1
unlock:
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
