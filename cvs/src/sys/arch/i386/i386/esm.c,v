head	1.59;
access;
symbols
	OPENBSD_6_1:1.59.0.6
	OPENBSD_6_1_BASE:1.59
	OPENBSD_6_0:1.59.0.4
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.57.0.6
	OPENBSD_5_8_BASE:1.57
	OPENBSD_5_7:1.57.0.2
	OPENBSD_5_7_BASE:1.57
	OPENBSD_5_6:1.55.0.4
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.54.0.6
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.54.0.2
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.53.0.2
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.52.0.10
	OPENBSD_5_2_BASE:1.52
	OPENBSD_5_1_BASE:1.52
	OPENBSD_5_1:1.52.0.8
	OPENBSD_5_0:1.52.0.6
	OPENBSD_5_0_BASE:1.52
	OPENBSD_4_9:1.52.0.4
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.52.0.2
	OPENBSD_4_8_BASE:1.52
	OPENBSD_4_7:1.50.0.2
	OPENBSD_4_7_BASE:1.50
	OPENBSD_4_6:1.49.0.4
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.48.0.2
	OPENBSD_4_5_BASE:1.48
	OPENBSD_4_4:1.47.0.4
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.47.0.2
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.46.0.2
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.45.0.2
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.42.0.2
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.40.0.2
	OPENBSD_3_9_BASE:1.40;
locks; strict;
comment	@ * @;


1.59
date	2015.09.08.07.12.56;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	UsnEcDGT4QqqoPvB;

1.58
date	2015.09.08.04.28.34;	author semarie;	state Exp;
branches;
next	1.57;
commitid	Ajpcv6B3UUP5Q4Cd;

1.57
date	2014.12.10.12.27.56;	author mikeb;	state Exp;
branches;
next	1.56;
commitid	v6PAeA18rydwc5Vx;

1.56
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.55;
commitid	uzzBR7hz9ncd4O6G;

1.55
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.54;
commitid	uKVPYMN2MLxdZxzH;

1.54
date	2013.07.04.16.55.18;	author sf;	state Exp;
branches;
next	1.53;

1.53
date	2012.10.17.22.31.59;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2010.07.02.01.35.13;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2010.06.30.15.22.05;	author blambert;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.24.22.11.07;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.48;

1.48
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.07.15.00.19;	author art;	state Exp;
branches;
next	1.46;

1.46
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2007.01.10.15.41.27;	author dlg;	state Exp;
branches;
next	1.44;

1.44
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2006.11.26.11.21.55;	author mbalmer;	state Exp;
branches;
next	1.42;

1.42
date	2006.05.11.13.21.11;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2006.04.21.09.33.10;	author dlg;	state Exp;
branches;
next	1.40;

1.40
date	2006.02.20.07.48.30;	author dlg;	state Exp;
branches;
next	1.39;

1.39
date	2006.02.17.08.17.34;	author dlg;	state Exp;
branches;
next	1.38;

1.38
date	2006.02.17.07.22.43;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2006.02.10.04.26.14;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2006.02.10.04.20.04;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2006.02.10.02.55.23;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2006.01.29.00.13.27;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2006.01.19.17.08.39;	author grange;	state Exp;
branches;
next	1.32;

1.32
date	2006.01.05.07.39.30;	author dlg;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.04.21.58.21;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.15.08.45.33;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.15.07.58.52;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.15.07.49.42;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.13.02.31.45;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.01.00.19.14;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.30.17.39.45;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.30.15.46.32;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.30.13.40.33;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.30.11.46.57;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.28.23.56.04;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.28.22.13.48;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.28.22.11.07;	author jordan;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.28.20.37.16;	author jordan;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.28.20.27.43;	author jordan;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.28.19.59.25;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.24.08.23.59;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.24.08.11.04;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.24.08.03.16;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.23.01.07.40;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2005.11.22.21.51.19;	author jordan;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.22.13.50.31;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.22.13.28.27;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.22.13.24.20;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.22.11.54.53;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.22.08.33.24;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.21.23.03.39;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.21.22.13.30;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.21.22.07.49;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.21.22.05.36;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.21.17.23.19;	author jordan;	state Exp;
branches;
next	;


desc
@@


1.59
log
@sizes for free(); ok semarie
@
text
@/*	$OpenBSD: esm.c,v 1.58 2015/09/08 04:28:34 semarie Exp $ */

/*
 * Copyright (c) 2005 Jordan Hargrave <jordan@@openbsd.org>
 * Copyright (c) 2005 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/timeout.h>
#include <sys/queue.h>
#include <sys/sensors.h>

#include <dev/isa/isareg.h>
#include <machine/bus.h>
#include <machine/intr.h>

#include <arch/i386/i386/esmvar.h>
#include <arch/i386/i386/esmreg.h>
#include <arch/i386/isa/isa_machdep.h>

#ifdef ESM_DEBUG
#define DPRINTF(x...)		do { if (esmdebug) printf(x); } while (0)
#define DPRINTFN(n,x...)	do { if (esmdebug > (n)) printf(x); } while (0)
int	esmdebug = 3;
#else
#define DPRINTF(x...)		/* x */
#define DPRINTFN(n,x...)	/* n: x */
#endif

int		esm_match(struct device *, void *, void *);
void		esm_attach(struct device *, struct device *, void *);
int		esm_activate(struct device *, int);

enum esm_sensor_type {
	ESM_S_UNKNOWN, /* XXX */
	ESM_S_INTRUSION,
	ESM_S_TEMP,
	ESM_S_FANRPM,
	ESM_S_VOLTS,
	ESM_S_VOLTSx10,
	ESM_S_AMPS,
	ESM_S_PWRSUP,
	ESM_S_PCISLOT,
	ESM_S_SCSICONN,
	ESM_S_DRIVES, /* argument is the base index of the drive */
	ESM_S_DRIVE,
	ESM_S_HPSLOT,
	ESM_S_ACSWITCH
};

/*
 * map esm sensor types to kernel sensor types.
 * keep this in sync with the esm_sensor_type enum above.
 */
enum sensor_type esm_typemap[] = {
	SENSOR_INTEGER,
	SENSOR_INDICATOR,
	SENSOR_TEMP,
	SENSOR_FANRPM,
	SENSOR_VOLTS_DC,
	SENSOR_VOLTS_DC,
	SENSOR_AMPS,
	SENSOR_INDICATOR,
	SENSOR_INTEGER,
	SENSOR_INDICATOR,
	SENSOR_DRIVE,
	SENSOR_DRIVE,
	SENSOR_INTEGER,
	SENSOR_INDICATOR
};

struct esm_sensor_map {
	enum esm_sensor_type	type;
	int			arg;
	const char		*name;
};

struct esm_sensor {
	u_int8_t		es_dev;
	u_int8_t		es_id;

	enum esm_sensor_type	es_type;

	struct {
		u_int16_t		th_lo_crit;
		u_int16_t		th_lo_warn;
		u_int16_t		th_hi_warn;
		u_int16_t		th_hi_crit;
	}			es_thresholds;

	struct ksensor		*es_sensor;
	TAILQ_ENTRY(esm_sensor)	es_entry;
};

struct esm_softc {
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;

	TAILQ_HEAD(, esm_sensor) sc_sensors;
	struct esm_sensor	*sc_nextsensor;
	struct ksensordev	sc_sensordev;
	int			sc_retries;
	volatile int		sc_step;
	struct timeout		sc_timeout;

	int			sc_wdog_period;
	volatile int		sc_wdog_tickle;
};

struct cfattach esm_ca = {
	sizeof(struct esm_softc), esm_match, esm_attach,
	NULL, esm_activate
};

struct cfdriver esm_cd = {
	NULL, "esm", DV_DULL
};

#define DEVNAME(s)	((s)->sc_dev.dv_xname)

#define EREAD(s, r)	bus_space_read_1((s)->sc_iot, (s)->sc_ioh, (r))
#define EWRITE(s, r, v)	bus_space_write_1((s)->sc_iot, (s)->sc_ioh, (r), (v))

#define ECTRLWR(s, v)	EWRITE((s), ESM2_CTRL_REG, (v))
#define EDATARD(s)	EREAD((s), ESM2_DATA_REG)
#define EDATAWR(s, v)	EWRITE((s), ESM2_DATA_REG, (v))

int		esm_watchdog(void *, int);

void		esm_refresh(void *);

int		esm_get_devmap(struct esm_softc *, int, struct esm_devmap *);
void		esm_devmap(struct esm_softc *, struct esm_devmap *);
void		esm_make_sensors(struct esm_softc *, struct esm_devmap *,
		    struct esm_sensor_map *, int);
int		esm_thresholds(struct esm_softc *, struct esm_devmap *,
		    struct esm_sensor *);

int		esm_bmc_ready(struct esm_softc *, int, u_int8_t, u_int8_t, int);
int		esm_cmd(struct esm_softc *, void *, size_t, void *, size_t,
		    int, int);
int		esm_smb_cmd(struct esm_softc *, struct esm_smb_req *,
		    struct esm_smb_resp *, int, int);

int64_t		esm_val2temp(u_int16_t);
int64_t		esm_val2volts(u_int16_t);
int64_t		esm_val2amps(u_int16_t);

/* Determine if this is a Dell server */
int
esm_probe(void *aux)
{
	const char *pdellstr;
	struct dell_sysid *pdellid;
	uint16_t sysid;

	pdellstr = (const char *)ISA_HOLE_VADDR(DELL_SYSSTR_ADDR);
	DPRINTF("Dell String: %s\n", pdellstr);
	if (strncmp(pdellstr, "Dell System", 11))
		return (0);

	pdellid = (struct dell_sysid *)ISA_HOLE_VADDR(DELL_SYSID_ADDR);
	if ((sysid = pdellid->sys_id) == DELL_SYSID_EXT)
		sysid = pdellid->ext_id;
	DPRINTF("SysId: %x\n", sysid);

	switch (sysid) {
	case DELL_SYSID_2300:
	case DELL_SYSID_4300:
	case DELL_SYSID_4350:
	case DELL_SYSID_6300:
	case DELL_SYSID_6350:
	case DELL_SYSID_2400:
	case DELL_SYSID_2450:
	case DELL_SYSID_4400:
	case DELL_SYSID_6400:
	case DELL_SYSID_6450:
	case DELL_SYSID_2500:
	case DELL_SYSID_2550:
	case DELL_SYSID_PV530F:
	case DELL_SYSID_PV735N:
	case DELL_SYSID_PV750N:
	case DELL_SYSID_PV755N:
	case DELL_SYSID_PA200:
		return (1);
	}

	return (0);
}

int
esm_match(struct device *parent, void *match, void *aux)
{
	struct esm_attach_args		*eaa = aux;

	if (strcmp(eaa->eaa_name, esm_cd.cd_name) == 0 && esm_probe(eaa))
		return (1);

	return (0);
}

void
esm_attach(struct device *parent, struct device *self, void *aux)
{
	struct esm_softc		*sc = (struct esm_softc *)self;
	struct esm_attach_args		*eaa = aux;
	u_int8_t			x;

	struct esm_devmap		devmap;
	int				i;

	sc->sc_iot = eaa->eaa_iot;
	TAILQ_INIT(&sc->sc_sensors);

	if (bus_space_map(sc->sc_iot, ESM2_BASE_PORT, 8, 0, &sc->sc_ioh) != 0) {
		printf(": can't map mem space\n");
		return;
	}

	/* turn off interrupts here */
	x = EREAD(sc, ESM2_INTMASK_REG);
	x &= ~(ESM2_TIM_SCI_EN|ESM2_TIM_SMI_EN|ESM2_TIM_NMI2SMI);
	x |= ESM2_TIM_POWER_UP_BITS;
	EWRITE(sc, ESM2_INTMASK_REG, x);

	/* clear event doorbells */
	x = EREAD(sc, ESM2_CTRL_REG);
	x &= ~ESM2_TC_HOSTBUSY;
	x |= ESM2_TC_POWER_UP_BITS;
	EWRITE(sc, ESM2_CTRL_REG, x);

	/* see if card is alive */
	if (esm_bmc_ready(sc, ESM2_CTRL_REG, ESM2_TC_ECBUSY, 0, 1) != 0) {
		printf(": card is not alive\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, 8);
		return;
	}

	sc->sc_wdog_period = 0;
	wdog_register(esm_watchdog, sc);
	printf("\n");

	strlcpy(sc->sc_sensordev.xname, DEVNAME(sc),
	    sizeof(sc->sc_sensordev.xname));
	for (i = 0; i <= 0xff; i++) {
		if (esm_get_devmap(sc, i, &devmap) != 0)
			break; /* XXX not continue? */
		esm_devmap(sc, &devmap);
	}

	if (!TAILQ_EMPTY(&sc->sc_sensors)) {
		sensordev_install(&sc->sc_sensordev);
		DPRINTF("%s: starting refresh\n", DEVNAME(sc));
		sc->sc_nextsensor = TAILQ_FIRST(&sc->sc_sensors);
		sc->sc_retries = 0;
		timeout_set(&sc->sc_timeout, esm_refresh, sc);
		timeout_add_sec(&sc->sc_timeout, 1);
	}
}

int
esm_activate(struct device *self, int act)
{
	switch (act) {
	case DVACT_POWERDOWN:
		wdog_shutdown(self);
		break;
	}

	return (0);
}

int
esm_watchdog(void *arg, int period)
{
	struct esm_softc	*sc = arg;
	struct esm_wdog_prop	prop;
	struct esm_wdog_state	state;
	int			s;

	if (sc->sc_wdog_period == period) {
		if (period != 0) {
			s = splclock();
			if (sc->sc_step != 0) {
				/* defer tickling to the sensor refresh */
				sc->sc_wdog_tickle = 1;
			} else {
				/* tickle the watchdog */
				EWRITE(sc, ESM2_CTRL_REG, ESM2_TC_HBDB);
			}
			splx(s);
		}
		return (period);
	}

	/* we're changing the watchdog period */

	memset(&prop, 0, sizeof(prop));
	memset(&state, 0, sizeof(state));

	if (period < 10 && period > 0)
		period = 10;

	s = splclock();

	prop.cmd = ESM2_CMD_HWDC;
	prop.subcmd = ESM2_HWDC_WRITE_PROPERTY;
	prop.action = (period == 0) ? ESM_WDOG_DISABLE : ESM_WDOG_RESET;
	prop.time = period;

	/*
	 * if we're doing a refresh, we need to wait till the hardware is
	 * available again. since period changes only happen via sysctl we
	 * should have a process context we can sleep in.
	 */
	while (sc->sc_step != 0) {
		if (tsleep(sc, PUSER | PCATCH, "esm", 0) == EINTR) {
			splx(s);
			return (sc->sc_wdog_period);
		}
	}

	if (esm_cmd(sc, &prop, sizeof(prop), NULL, 0, 1, 0) != 0) {
		splx(s);
		return (sc->sc_wdog_period);
	}

	state.cmd = ESM2_CMD_HWDC;
	state.subcmd = ESM2_HWDC_WRITE_STATE;
	state.state = (period == 0) ? 0 : 1;

	/* we have the hw, this can't (shouldn't) fail */
	esm_cmd(sc, &state, sizeof(state), NULL, 0, 1, 0);

	splx(s);

	sc->sc_wdog_period = period;
	return (period);
}

void
esm_refresh(void *arg)
{
	struct esm_softc	*sc = arg;
	struct esm_sensor	*es = sc->sc_nextsensor;
	struct esm_smb_req	req;
	struct esm_smb_resp	resp;
	struct esm_smb_resp_val	*val = &resp.resp_val;
	int			nsensors, i, step;

	memset(&req, 0, sizeof(req));
	req.h_cmd = ESM2_CMD_SMB_XMIT_RECV;
	req.h_dev = es->es_dev;
	req.h_txlen = sizeof(req.req_val);
	req.h_rxlen = sizeof(resp.resp_val);
	req.req_val.v_cmd = ESM2_SMB_SENSOR_VALUE;
	req.req_val.v_sensor = es->es_id;

	switch (es->es_type) {
	case ESM_S_DRIVES:
		nsensors = 4;
		break;
	case ESM_S_PWRSUP:
		nsensors = 6;
		break;
	default:
		nsensors = 1;
		break;
	}

	if ((step = esm_smb_cmd(sc, &req, &resp, 0, sc->sc_step)) != 0) {
		sc->sc_step = step;
		if (++sc->sc_retries < 10)
			goto tick;

		for (i = 0; i < nsensors; i++)
			es->es_sensor[i].flags |= SENSOR_FINVALID;
	} else {
		switch (es->es_type) {
		case ESM_S_TEMP:
			es->es_sensor->value = esm_val2temp(val->v_reading);
			break;
		case ESM_S_VOLTS:
			es->es_sensor->value = esm_val2volts(val->v_reading);
			break;
		case ESM_S_VOLTSx10:
			es->es_sensor->value =
			    esm_val2volts(val->v_reading) * 10;
			break;
		case ESM_S_AMPS:
			es->es_sensor->value = esm_val2amps(val->v_reading);
			break;
		case ESM_S_DRIVES:
			for (i = 0; i < nsensors; i++) {
				es->es_sensor[i].value =
				    (val->v_reading >> i * 8) & 0xf;
			}
			break;
		case ESM_S_PWRSUP:
			for (i = 0; i < nsensors; i++) {
				es->es_sensor[i].value =
				    (val->v_reading >> i) & 0x1;
			}
			break;
		default:
			es->es_sensor->value = val->v_reading;
			break;
		}

		switch (es->es_type) {
		case ESM_S_TEMP:
		case ESM_S_FANRPM:
		case ESM_S_VOLTS:
		case ESM_S_AMPS:
			if (val->v_reading >= es->es_thresholds.th_hi_crit ||
			    val->v_reading <= es->es_thresholds.th_lo_crit) {
				es->es_sensor->status = SENSOR_S_CRIT;
				break;
			}

			if (val->v_reading >= es->es_thresholds.th_hi_warn ||
			    val->v_reading <= es->es_thresholds.th_lo_warn) {
				es->es_sensor->status = SENSOR_S_WARN;
				break;
			}

			es->es_sensor->status = SENSOR_S_OK;
			break;

		case ESM_S_PWRSUP:
			if (val->v_status & ESM2_VS_PSU_FAIL) {
				es->es_sensor[3].status = SENSOR_S_CRIT;
				break;
			}

			es->es_sensor[3].status = SENSOR_S_OK;
			break;

		default:
			break;
		}

		for (i = 0; i < nsensors; i++)
			es->es_sensor->flags &= ~SENSOR_FINVALID;
	}

	sc->sc_nextsensor = TAILQ_NEXT(es, es_entry);
	sc->sc_retries = 0;
	sc->sc_step = 0;

	if (sc->sc_wdog_tickle) {
		/*
		 * the controller was busy in a refresh when the watchdog
		 * needed a tickle, so do it now.
		 */
		EWRITE(sc, ESM2_CTRL_REG, ESM2_TC_HBDB);
		sc->sc_wdog_tickle = 0;
	}
	wakeup(sc);

	if (sc->sc_nextsensor == NULL) {
		sc->sc_nextsensor = TAILQ_FIRST(&sc->sc_sensors);
		timeout_add_sec(&sc->sc_timeout, 10);
		return;
	}
tick:
	timeout_add_msec(&sc->sc_timeout, 50);
}

int
esm_get_devmap(struct esm_softc *sc, int dev, struct esm_devmap *devmap)
{
	struct esm_devmap_req	req;
	struct esm_devmap_resp	resp;
#ifdef ESM_DEBUG
	int			i;
#endif

	memset(&req, 0, sizeof(req));
	memset(&resp, 0, sizeof(resp));

	req.cmd = ESM2_CMD_DEVICEMAP;
	req.action = ESM2_DEVICEMAP_READ;
	req.index = dev;
	req.ndev = 1;

	if (esm_cmd(sc, &req, sizeof(req), &resp, sizeof(resp), 1, 0) != 0)
		return (1);

	if (resp.status != 0)
		return (1);

	memcpy(devmap, &resp.devmap[0], sizeof(struct esm_devmap));

#ifdef ESM_DEBUG
	if (esmdebug > 5) {
		printf("\n");
		printf("Device Map(%d) returns:\n", dev);
		printf("  status: %.2x\n", resp.status);
		printf("  #devs : %.2x\n", resp.ndev);
		printf("   index: %.2x\n", resp.devmap[0].index);
		printf("   Type : %.2x.%.2x\n", resp.devmap[0].dev_major,
		    resp.devmap[0].dev_minor);
		printf("   Rev  : %.2x.%.2x\n", resp.devmap[0].rev_major,
		    resp.devmap[0].rev_minor);
		printf("   ROM  : %.2x\n", resp.devmap[0].rev_rom);
		printf("   SMB  : %.2x\n", resp.devmap[0].smb_addr);
		printf("   Stat : %.2x\n", resp.devmap[0].status);
		printf("   MonTy: %.2x\n", resp.devmap[0].monitor_type);
		printf("   Poll : %.2x\n", resp.devmap[0].pollcycle);
		printf("   UUID : ");
		for (i = 0; i < ESM2_UUID_LEN; i++) {
			printf("%02x", resp.devmap[0].uniqueid[i]);
		}
		printf("\n");
	}
#endif /* ESM_DEBUG */

	return (0);
}

struct esm_sensor_map esm_sensors_esm2[] = {
	{ ESM_S_UNKNOWN,	0,		"Motherboard" },
	{ ESM_S_TEMP,		0,		"CPU 1" },
	{ ESM_S_TEMP,		0,		"CPU 2" },
	{ ESM_S_TEMP,		0,		"CPU 3" },
	{ ESM_S_TEMP,		0,		"CPU 4" },

	{ ESM_S_TEMP,		0,		"Mainboard" },
	{ ESM_S_TEMP,		0,		"Ambient" },
	{ ESM_S_VOLTS,		0,		"CPU 1 Core" },
	{ ESM_S_VOLTS,		0,		"CPU 2 Core" },
	{ ESM_S_VOLTS,		0,		"CPU 3 Core" },

	{ ESM_S_VOLTS,		0,		"CPU 4 Core" },
	{ ESM_S_VOLTS,		0,		"Motherboard +5V" },
	{ ESM_S_VOLTS,		0,		"Motherboard +12V" },
	{ ESM_S_VOLTS,		0,		"Motherboard +3.3V" },
	{ ESM_S_VOLTS,		0,		"Motherboard +2.5V" },

	{ ESM_S_VOLTS,		0,		"Motherboard GTL Term" },
	{ ESM_S_VOLTS,		0,		"Motherboard Battery" },
	{ ESM_S_INTRUSION,	0,		"Chassis Intrusion", },
	{ ESM_S_UNKNOWN,	0,		"Chassis Fan Ctrl", },
	{ ESM_S_FANRPM,		0,		"Fan 1" },

	{ ESM_S_FANRPM,		0,		"Fan 2" }, /* 20 */
	{ ESM_S_FANRPM,		0,		"Fan 3" },
	{ ESM_S_FANRPM,		0,		"Power Supply Fan" },
	{ ESM_S_VOLTS,		0,		"CPU 1 cache" },
	{ ESM_S_VOLTS,		0,		"CPU 2 cache" },

	{ ESM_S_VOLTS,		0,		"CPU 3 cache" },
	{ ESM_S_VOLTS,		0,		"CPU 4 cache" },
	{ ESM_S_UNKNOWN,	0,		"Power Ctrl" },
	{ ESM_S_PWRSUP,		0,		"Power Supply 1" },
	{ ESM_S_PWRSUP,		0,		"Power Supply 2" },

	{ ESM_S_VOLTS,		0,		"Mainboard +1.5V" }, /* 30 */
	{ ESM_S_VOLTS,		0,		"Motherboard +2.8V" },
	{ ESM_S_UNKNOWN,	0,		"HotPlug Status" },
	{ ESM_S_PCISLOT,	0,		"PCI Slot 1" },
	{ ESM_S_PCISLOT,	0,		"PCI Slot 2" },

	{ ESM_S_PCISLOT,	0,		"PCI Slot 3" },
	{ ESM_S_PCISLOT,	0,		"PCI Slot 4" },
	{ ESM_S_PCISLOT,	0,		"PCI Slot 5" },
	{ ESM_S_PCISLOT,	0,		"PCI Slot 6" },
	{ ESM_S_PCISLOT,	0,		"PCI Slot 7" },

	{ ESM_S_VOLTS,		0,		"CPU 1 Cartridge" }, /* 40 */
	{ ESM_S_VOLTS,		0,		"CPU 2 Cartridge" },
	{ ESM_S_VOLTS,		0,		"CPU 3 Cartridge" },
	{ ESM_S_VOLTS,		0,		"CPU 4 Cartridge" },
	{ ESM_S_VOLTS,		0,		"Gigabit NIC +1.8V" },

	{ ESM_S_VOLTS,		0,		"Gigabit NIC +2.5V" },
	{ ESM_S_VOLTS,		0,		"Memory +3.3V" },
	{ ESM_S_VOLTS,		0,		"Video +2.5V" },
	{ ESM_S_PWRSUP,		0,		"Power Supply 3" },
	{ ESM_S_FANRPM,		0,		"Fan 4" },

	{ ESM_S_FANRPM,		0,		"Power Supply Fan" }, /* 50 */
	{ ESM_S_FANRPM,		0,		"Power Supply Fan" },
	{ ESM_S_FANRPM,		0,		"Power Supply Fan" },
	{ ESM_S_ACSWITCH,	0,		"A/C Power Switch" },
	{ ESM_S_UNKNOWN,	0,		"PS Over Temp" }
};

struct esm_sensor_map esm_sensors_backplane[] = {
	{ ESM_S_UNKNOWN,	0,		"Backplane" },
	{ ESM_S_UNKNOWN,	0,		"Backplane Control" },
	{ ESM_S_TEMP,		0,		"Backplane Top" },
	{ ESM_S_TEMP,		0,		"Backplane Bottom" },
	{ ESM_S_TEMP,		0,		"Backplane Control Panel" },
	{ ESM_S_VOLTS,		0,		"Backplane Battery" },
	{ ESM_S_VOLTS,		0,		"Backplane +5V" },
	{ ESM_S_VOLTS,		0,		"Backplane +12V" },
	{ ESM_S_VOLTS,		0,		"Backplane Board" },
	{ ESM_S_INTRUSION,	0,		"Backplane Intrusion" },
	{ ESM_S_UNKNOWN,	0,		"Backplane Fan Control" },
	{ ESM_S_FANRPM,		0,		"Backplane Fan 1" },
	{ ESM_S_FANRPM,		0,		"Backplane Fan 2" },
	{ ESM_S_FANRPM,		0,		"Backplane Fan 3" },
	{ ESM_S_SCSICONN,	0,		"Backplane SCSI A Connected" },
	{ ESM_S_VOLTS,		0,		"Backplane SCSI A External" },
	{ ESM_S_VOLTS,		0,		"Backplane SCSI A Internal" },
	{ ESM_S_SCSICONN,	0,		"Backplane SCSI B Connected" },
	{ ESM_S_VOLTS,		0,		"Backplane SCSI B External" },
	{ ESM_S_VOLTS,		0,		"Backplane SCSI B Internal" },
	{ ESM_S_DRIVES,		0,		"Drive" },
	{ ESM_S_DRIVES,		4,		"Drive" },
	{ ESM_S_DRIVE,		0,		"Drive 0" },
	{ ESM_S_DRIVE,		0,		"Drive 1" },
	{ ESM_S_DRIVE,		0,		"Drive 2" },
	{ ESM_S_DRIVE,		0,		"Drive 3" },
	{ ESM_S_DRIVE,		0,		"Drive 4" },
	{ ESM_S_DRIVE,		0,		"Drive 5" },
	{ ESM_S_DRIVE,		0,		"Drive 6" },
	{ ESM_S_DRIVE,		0,		"Drive 7" },
	{ ESM_S_UNKNOWN,	0,		"Backplane Control 2" },
	{ ESM_S_VOLTS,		0,		"Backplane +3.3V" },
};

struct esm_sensor_map esm_sensors_powerunit[] = {
	{ ESM_S_UNKNOWN,	0,		"Power Unit" },
	{ ESM_S_VOLTSx10,	0,		"Power Supply 1 +5V" },
	{ ESM_S_VOLTSx10,	0,		"Power Supply 1 +12V" },
	{ ESM_S_VOLTSx10,	0,		"Power Supply 1 +3.3V" },
	{ ESM_S_VOLTSx10,	0,		"Power Supply 1 -5V" },

	{ ESM_S_VOLTSx10,	0,		"Power Supply 1 -12V" },
	{ ESM_S_VOLTSx10,	0,		"Power Supply 2 +5V" },
	{ ESM_S_VOLTSx10,	0,		"Power Supply 2 +12V" },
	{ ESM_S_VOLTSx10,	0,		"Power Supply 2 +3.3V" },
	{ ESM_S_VOLTSx10,	0,		"Power Supply 2 -5V" },

	{ ESM_S_VOLTSx10,	0,		"Power Supply 2 -12V" },
	{ ESM_S_VOLTSx10,	0,		"Power Supply 3 +5V" },
	{ ESM_S_VOLTSx10,	0,		"Power Supply 3 +12V" },
	{ ESM_S_VOLTSx10,	0,		"Power Supply 3 +3.3V" },
	{ ESM_S_VOLTSx10,	0,		"Power Supply 3 -5V" },

	{ ESM_S_VOLTSx10,	0,		"Power Supply 3 -12V" },
	{ ESM_S_VOLTSx10,	0,		"System Power Supply +5V" },
	{ ESM_S_VOLTSx10,	0,		"System Power Supply +12V" },
	{ ESM_S_VOLTSx10,	0,		"System Power Supply +3.3V" },
	{ ESM_S_VOLTSx10,	0,		"System Power Supply -5V" },

	{ ESM_S_VOLTSx10,	0,		"System Power Supply -12V" },
	{ ESM_S_VOLTSx10,	0,		"System Power Supply +5V aux" },
	{ ESM_S_AMPS,		0,		"Power Supply 1 +5V" },
	{ ESM_S_AMPS,		0,		"Power Supply 1 +12V" },
	{ ESM_S_AMPS,		0,		"Power Supply 1 +3.3V" },

	{ ESM_S_AMPS,		0,		"Power Supply 2 +5V" },
	{ ESM_S_AMPS,		0,		"Power Supply 2 +12V" },
	{ ESM_S_AMPS,		0,		"Power Supply 2 +3.3V" },
	{ ESM_S_AMPS,		0,		"Power Supply 3 +5V" },
	{ ESM_S_AMPS,		0,		"Power Supply 3 +12V" },

	{ ESM_S_AMPS,		0,		"Power Supply 3 +3.3V" },
	{ ESM_S_FANRPM,		0,		"Power Supply 1 Fan" },
	{ ESM_S_FANRPM,		0,		"Power Supply 2 Fan" },
	{ ESM_S_FANRPM,		0,		"Power Supply 3 Fan" },
	{ ESM_S_PWRSUP,		0,		"Power Supply 1" },

	{ ESM_S_PWRSUP,		0,		"Power Supply 2" },
	{ ESM_S_PWRSUP,		0,		"Power Supply 3" },
	{ ESM_S_UNKNOWN,	0,		"PSPB Fan Control" },
	{ ESM_S_FANRPM,		0,		"Fan 1" },
	{ ESM_S_FANRPM,		0,		"Fan 2" },

	{ ESM_S_FANRPM,		0,		"Fan 3" },
	{ ESM_S_FANRPM,		0,		"Fan 4" },
	{ ESM_S_FANRPM,		0,		"Fan 5" },
	{ ESM_S_FANRPM,		0,		"Fan 6" },
	{ ESM_S_UNKNOWN,	0,		"Fan Enclosure" },
};

void
esm_devmap(struct esm_softc *sc, struct esm_devmap *devmap)
{
	struct esm_sensor_map	*sensor_map = NULL;
	const char		*name = NULL, *fname = NULL;
	int			mapsize = 0;

	switch (devmap->dev_major) {
	case ESM2_DEV_ESM2:
		sensor_map = esm_sensors_esm2;

		switch (devmap->dev_minor) {
		case ESM2_DEV_ESM2_2300:
			name = "PowerEdge 2300";
			mapsize = 23;
			break;
		case ESM2_DEV_ESM2_4300:
			name = "PowerEdge 4300";
			mapsize = 27;
			break;
		case ESM2_DEV_ESM2_6300:
			name = "PowerEdge 6300";
			mapsize = 27;
			break;
		case ESM2_DEV_ESM2_6400:
			name = "PowerEdge 6400";
			mapsize = 44;
			break;
		case ESM2_DEV_ESM2_2550:
			name = "PowerEdge 2550";
			mapsize = 48;
			break;
		case ESM2_DEV_ESM2_4350:
			name = "PowerEdge 4350";
			mapsize = 27;
			break;
		case ESM2_DEV_ESM2_6350:
			name = "PowerEdge 6350";
			mapsize = 27;
			break;
		case ESM2_DEV_ESM2_6450:
			name = "PowerEdge 6450";
			mapsize = 44;
			break;
		case ESM2_DEV_ESM2_2400:
			name = "PowerEdge 2400";
			mapsize = 30;
			break;
		case ESM2_DEV_ESM2_4400:
			name = "PowerEdge 4400";
			mapsize = 44;
			break;
		case ESM2_DEV_ESM2_2500:
			name = "PowerEdge 2500";
			mapsize = 55;
			break;
		case ESM2_DEV_ESM2_2450:
			name = "PowerEdge 2450";
			mapsize = 27;
			break;
		case ESM2_DEV_ESM2_2400EX:
			name = "PowerEdge 2400";
			mapsize = 27;
			break;
		case ESM2_DEV_ESM2_2450EX:
			name = "PowerEdge 2450";
			mapsize = 44;
			break;
		default:
			return;
		}

		fname = "Embedded Server Management";
		break;

	case ESM2_DEV_DRACII:
		fname = "Dell Remote Assistance Card II";
		break;

	case ESM2_DEV_FRONT_PANEL:
		fname = "Front Panel";
		break;

	case ESM2_DEV_BACKPLANE2:
		sensor_map = esm_sensors_backplane;
		mapsize = 22;

		fname = "Primary System Backplane";
		break;

	case ESM2_DEV_POWERUNIT2:
		sensor_map = esm_sensors_powerunit;
		mapsize = sizeof(esm_sensors_powerunit) /
		    sizeof(esm_sensors_powerunit[0]);

		fname = "Power Unit";
		break;

	case ESM2_DEV_ENCL2_BACKPLANE:
	case ESM2_DEV_ENCL1_BACKPLANE:
		fname = "Enclosure Backplane";
		break;

	case ESM2_DEV_ENCL2_POWERUNIT:
	case ESM2_DEV_ENCL1_POWERUNIT:
		fname = "Enclosure Powerunit";
		break;

	case ESM2_DEV_HPPCI: /* nfi what this is */
		fname = "HPPCI";
		break;

	case ESM2_DEV_BACKPLANE3:
		sensor_map = esm_sensors_backplane;
		mapsize = sizeof(esm_sensors_backplane) /
		    sizeof(esm_sensors_backplane[0]);

		fname = "Primary System Backplane";
		break;

	default:
		return;
	}

	printf("%s: %s%s%s %d.%d\n", DEVNAME(sc),
	    name ? name : "", name ? " " : "", fname,
	    devmap->rev_major, devmap->rev_minor);

	esm_make_sensors(sc, devmap, sensor_map, mapsize);
}

void
esm_make_sensors(struct esm_softc *sc, struct esm_devmap *devmap,
    struct esm_sensor_map *sensor_map, int mapsize)
{
	struct esm_smb_req	req;
	struct esm_smb_resp	resp;
	struct esm_smb_resp_val	*val = &resp.resp_val;
	struct esm_sensor	*es;
	struct ksensor		*s;
	int			nsensors, i, j;
	const char		*psulabels[] = {
				    "AC", "SW", "OK", "ON", "FFAN", "OTMP"
				};

	memset(&req, 0, sizeof(req));
	req.h_cmd = ESM2_CMD_SMB_XMIT_RECV;
	req.h_dev = devmap->index;
	req.h_txlen = sizeof(req.req_val);
	req.h_rxlen = sizeof(resp.resp_val);

	req.req_val.v_cmd = ESM2_SMB_SENSOR_VALUE;

	for (i = 0; i < mapsize; i++) {
		req.req_val.v_sensor = i;
		if (esm_smb_cmd(sc, &req, &resp, 1, 0) != 0)
			continue;

		DPRINTFN(1, "%s: dev: 0x%02x sensor: %d (%s) "
		    "reading: 0x%04x status: 0x%02x cksum: 0x%02x\n",
		    DEVNAME(sc), devmap->index, i, sensor_map[i].name,
		    val->v_reading, val->v_status, val->v_checksum);

		switch (sensor_map[i].type) {
		case ESM_S_PWRSUP:
			if (val->v_status == 0x00)
				continue;
			break;
		default:
			if (!(val->v_status & ESM2_VS_VALID))
				continue;
			break;
		}

		es = malloc(sizeof(struct esm_sensor), M_DEVBUF,
		    M_NOWAIT|M_ZERO);
		if (es == NULL)
			return;

		es->es_dev = devmap->index;
		es->es_id = i;
		es->es_type = sensor_map[i].type;

		switch (es->es_type) {
		case ESM_S_DRIVES:
			/*
			 * this esm sensor represents 4 kernel sensors, so we
			 * go through these hoops to deal with it.
			 */
			nsensors = 4;
			s = mallocarray(nsensors, sizeof(struct ksensor),
			    M_DEVBUF, M_NOWAIT|M_ZERO);
			if (s == NULL) {
				free(es, M_DEVBUF, sizeof(*es));
				return;
			}

			for (j = 0; j < nsensors; j++) {
				snprintf(s[j].desc, sizeof(s[j].desc), "%s %d",
				    sensor_map[i].name, sensor_map[i].arg + j);
			}
			break;
		case ESM_S_PWRSUP:
			/*
			 * the esm pwrsup sensor has a bitfield for its value,
			 * this expands it out to 6 separate indicators
			 */
			nsensors = 6;
			s = mallocarray(nsensors, sizeof(struct ksensor),
			    M_DEVBUF, M_NOWAIT|M_ZERO);
			if (s == NULL) {
				free(es, M_DEVBUF, sizeof(*es));
				return;
			}

			for (j = 0; j < nsensors; j++) {
				snprintf(s[j].desc, sizeof(s[j].desc), "%s %s",
				    sensor_map[i].name, psulabels[j]);
			}
			break;

		case ESM_S_TEMP:
		case ESM_S_FANRPM:
		case ESM_S_AMPS:
		case ESM_S_VOLTS:
		case ESM_S_VOLTSx10:
			if (esm_thresholds(sc, devmap, es) != 0) {
				free(es, M_DEVBUF, sizeof(*es));
				continue;
			}
			/* FALLTHROUGH */

		default:
			nsensors = 1;
			s = malloc(sizeof(struct ksensor), M_DEVBUF,
			    M_NOWAIT|M_ZERO);
			if (s == NULL) {
				free(es, M_DEVBUF, sizeof(*es));
				return;
			}

			strlcpy(s->desc, sensor_map[i].name, sizeof(s->desc));
			break;
		}

		for (j = 0; j < nsensors; j++) {
			s[j].type = esm_typemap[es->es_type];
			sensor_attach(&sc->sc_sensordev, &s[j]);
		}

		es->es_sensor = s;
		TAILQ_INSERT_TAIL(&sc->sc_sensors, es, es_entry);
	}
}

int
esm_thresholds(struct esm_softc *sc, struct esm_devmap *devmap,
    struct esm_sensor *es)
{
	struct esm_smb_req	req;
	struct esm_smb_resp	resp;
	struct esm_smb_resp_thr	*thr = &resp.resp_thr;

	memset(&req, 0, sizeof(req));
	req.h_cmd = ESM2_CMD_SMB_XMIT_RECV;
	req.h_dev = devmap->index;
	req.h_txlen = sizeof(req.req_thr);
	req.h_rxlen = sizeof(resp.resp_thr);

	req.req_thr.t_cmd = ESM2_SMB_SENSOR_THRESHOLDS;
	req.req_thr.t_sensor = es->es_id;

	if (esm_smb_cmd(sc, &req, &resp, 1, 0) != 0)
		return (1);

	DPRINTFN(2, "%s: dev: %d sensor: %d lo fail: %d hi fail: %d "
	    "lo warn: %d hi warn: %d hysterisis: %d checksum: 0x%02x\n",
	    DEVNAME(sc), devmap->index, es->es_id, thr->t_lo_fail,
	    thr->t_hi_fail, thr->t_lo_warn, thr->t_hi_warn, thr->t_hysterisis,
	    thr->t_checksum);

	es->es_thresholds.th_lo_crit = thr->t_lo_fail;
	es->es_thresholds.th_lo_warn = thr->t_lo_warn;
	es->es_thresholds.th_hi_warn = thr->t_hi_warn;
	es->es_thresholds.th_hi_crit = thr->t_hi_fail;

	return (0);
}

int
esm_bmc_ready(struct esm_softc *sc, int port, u_int8_t mask, u_int8_t val,
    int wait)
{
	unsigned int		count = wait ? 0 : 0xfffff;

	do {
		if ((EREAD(sc, port) & mask) == val)
			return (0);
	} while (count++ < 0xfffff);

	return (1);
}

int
esm_cmd(struct esm_softc *sc, void *cmd, size_t cmdlen, void *resp,
    size_t resplen, int wait, int step)
{
	u_int8_t		*tx = (u_int8_t *)cmd;
	u_int8_t		*rx = (u_int8_t *)resp;
	int			i;

	switch (step) {
	case 0:
	case 1:
		/* Wait for card ready */
		if (esm_bmc_ready(sc, ESM2_CTRL_REG, ESM2_TC_READY,
		    0, wait) != 0)
			return (1); /* busy */

		/* Write command data to port */
		ECTRLWR(sc, ESM2_TC_CLR_WPTR);
		for (i = 0; i < cmdlen; i++) {
			DPRINTFN(2, "write: %.2x\n", *tx);
			EDATAWR(sc, *tx);
			tx++;
		}

		/* Ring doorbell... */
		ECTRLWR(sc, ESM2_TC_H2ECDB);
		/* FALLTHROUGH */
	case 2:
		/* ...and wait */
		if (esm_bmc_ready(sc, ESM2_CTRL_REG, ESM2_TC_EC2HDB,
		    ESM2_TC_EC2HDB, wait) != 0)
			return (2);

		/* Set host busy semaphore and clear doorbell */
		ECTRLWR(sc, ESM2_TC_HOSTBUSY);
		ECTRLWR(sc, ESM2_TC_EC2HDB);
	
		/* Read response data from port */
		ECTRLWR(sc, ESM2_TC_CLR_RPTR);
		for (i = 0; i < resplen; i++) {
			*rx = EDATARD(sc);
			DPRINTFN(2, "read = %.2x\n", *rx);
			rx++;
		}

		/* release semaphore */
		ECTRLWR(sc, ESM2_TC_HOSTBUSY);
		break;
	}

	return (0);
}

int
esm_smb_cmd(struct esm_softc *sc, struct esm_smb_req *req,
    struct esm_smb_resp *resp, int wait, int step)
{
	int			err;

	memset(resp, 0, sizeof(struct esm_smb_resp));

	err = esm_cmd(sc, req, sizeof(req->hdr) + req->h_txlen, resp,
	    sizeof(resp->hdr) + req->h_rxlen, wait, step);
	if (err)
		return (err);

	if (resp->h_status != 0 || resp->h_i2csts != 0) {
		DPRINTFN(3, "%s: dev: 0x%02x error status: 0x%02x "
		    "i2csts: 0x%02x procsts: 0x%02x tx: 0x%02x rx: 0x%02x\n",
		    __func__, req->h_dev, resp->h_status, resp->h_i2csts,
		    resp->h_procsts, resp->h_rx, resp->h_tx);
		return (1);
	}

	return (0);
}

int64_t
esm_val2temp(u_int16_t value)
{
	return (((int64_t)value * 100000) + 273150000);
}

int64_t
esm_val2volts(u_int16_t value)
{
	return ((int64_t)value * 1000);
}

int64_t
esm_val2amps(u_int16_t value)
{
	return ((int64_t)value * 100000);
}
@


1.58
log
@convert several malloc(9) to mallocarray(9).

ok deraadt@@ guenther@@ "re-wrap the long lines" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.57 2014/12/10 12:27:56 mikeb Exp $ */
d891 1
a891 1
				free(es, M_DEVBUF, 0);
d909 1
a909 1
				free(es, M_DEVBUF, 0);
d925 1
a925 1
				free(es, M_DEVBUF, 0);
d935 1
a935 1
				free(es, M_DEVBUF, 0);
@


1.57
log
@Convert watchdog(4) devices to use autoconf(9) framework.

ok deraadt, tests on glxpcib and ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.56 2014/09/14 14:17:23 jsg Exp $ */
d888 2
a889 2
			s = malloc(sizeof(struct ksensor) * nsensors, M_DEVBUF,
			    M_NOWAIT|M_ZERO);
d906 2
a907 2
			s = malloc(sizeof(struct ksensor) * nsensors, M_DEVBUF,
			    M_NOWAIT|M_ZERO);
@


1.56
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.55 2014/07/12 18:44:41 tedu Exp $ */
d48 1
d128 2
a129 1
	sizeof(struct esm_softc), esm_match, esm_attach
d276 12
@


1.55
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.54 2013/07/04 16:55:18 sf Exp $ */
a25 1
#include <sys/proc.h>
@


1.54
log
@Format string fixes:

f_count is long
ok kettenis@@

Change esm_sensor_map.arg to int
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.53 2012/10/17 22:31:59 deraadt Exp $ */
d878 1
a878 1
				free(es, M_DEVBUF);
d896 1
a896 1
				free(es, M_DEVBUF);
d912 1
a912 1
				free(es, M_DEVBUF);
d922 1
a922 1
				free(es, M_DEVBUF);
@


1.53
log
@Swap arguments to wdog_register() since it is nicer, and prepare
wdog_shutdown() for external usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.52 2010/07/02 01:35:13 tedu Exp $ */
d90 1
a90 1
	long			arg;
@


1.52
log
@initialize values to something sensible.
ok deraadt pirofti
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.51 2010/06/30 15:22:05 blambert Exp $ */
d256 1
a256 1
	wdog_register(sc, esm_watchdog);
@


1.51
log
@change a pair of timeout_add calls to timeout_add_{,m}sec

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.50 2009/10/24 22:11:07 miod Exp $ */
d688 1
a688 1
	struct esm_sensor_map	*sensor_map;
d690 1
a690 1
	int			mapsize;
@


1.50
log
@Match on `esm' as the device name, not `anything starting with esm'; ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.49 2009/03/29 21:53:52 sthen Exp $ */
d467 1
a467 1
		timeout_add(&sc->sc_timeout, hz * 10);
d471 1
a471 1
	timeout_add(&sc->sc_timeout, hz / 20);
@


1.49
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.48 2008/09/10 14:01:22 blambert Exp $ */
d212 1
a212 2
	if (strncmp(eaa->eaa_name, esm_cd.cd_name, sizeof(esm_cd.cd_name)) == 0 &&
	    esm_probe(eaa))
@


1.48
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.47 2007/09/07 15:00:19 art Exp $ */
d233 1
a233 1
		printf(": unable to map memory\n");
@


1.47
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.46 2007/03/22 16:55:31 deraadt Exp $ */
d274 1
a274 1
		timeout_add(&sc->sc_timeout, hz);
@


1.46
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.45 2007/01/10 15:41:27 dlg Exp $ */
d860 2
a861 1
		es = malloc(sizeof(struct esm_sensor), M_DEVBUF, M_NOWAIT);
a864 1
		memset(es, 0, sizeof(struct esm_sensor));
d877 1
a877 1
			    M_NOWAIT);
a881 1
			memset(s, 0, sizeof(struct ksensor) * nsensors);
d895 1
a895 1
			    M_NOWAIT);
a899 1
			memset(s, 0, sizeof(struct ksensor) * nsensors);
d920 2
a921 1
			s = malloc(sizeof(struct ksensor), M_DEVBUF, M_NOWAIT);
a925 1
			memset(s, 0, sizeof(struct ksensor));
@


1.45
log
@fix fallout of the split sensor devices change which caused lockups on
boot.

dont call sensordev_install multiple times for esm0. there are multiple
devices accessed via the one esm interface that provide sensor info for
various parts of the system. sensordev_install was being called after each
of these parts was being probed, rather than right at the end after the
entire list of sensors has been built.

tested by kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.43 2006/11/26 11:21:55 mbalmer Exp $ */
d107 1
a107 1
	struct sensor		*es_sensor;
d118 1
a118 1
	struct sensordev	sc_sensordev;
d825 1
a825 1
	struct sensor		*s;
d876 1
a876 1
			s = malloc(sizeof(struct sensor) * nsensors, M_DEVBUF,
d882 1
a882 1
			memset(s, 0, sizeof(struct sensor) * nsensors);
d895 1
a895 1
			s = malloc(sizeof(struct sensor) * nsensors, M_DEVBUF,
d901 1
a901 1
			memset(s, 0, sizeof(struct sensor) * nsensors);
d922 1
a922 1
			s = malloc(sizeof(struct sensor), M_DEVBUF, M_NOWAIT);
d927 1
a927 1
			memset(s, 0, sizeof(struct sensor));
@


1.44
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d260 2
d269 1
a932 2
		strlcpy(sc->sc_sensordev.xname, DEVNAME(sc),
		    sizeof(sc->sc_sensordev.xname));
a936 1
		sensordev_install(&sc->sc_sensordev);
@


1.43
log
@use splclock() instead of splsoftclock() when setting the timeout period
from the watchdog framework; this is consistent with other watchdogs we have.
discussed with and ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.42 2006/05/11 13:21:11 mickey Exp $ */
d118 1
d930 2
d934 1
a934 2
			strlcpy(s[j].device, DEVNAME(sc), sizeof(s[j].device));
			sensor_add(&s[j]);
d936 1
@


1.42
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.41 2006/04/21 09:33:10 dlg Exp $ */
d284 1
a284 1
			s = splsoftclock();
d305 1
a305 1
	s = splsoftclock();
@


1.41
log
@the esm_sensor_maps describe esm sensors, not kernel sensors. i have no
idea how i got this screwed up.

found by lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.40 2006/02/20 07:48:30 dlg Exp $ */
d807 1
a807 1
	    name ? name : "", name ? " " : "", fname, 
@


1.40
log
@fix conversion for the temp values. i think i was losing some precision
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.39 2006/02/17 08:17:34 dlg Exp $ */
d89 1
a89 1
	enum sensor_type	type;
@


1.39
log
@add a comment to explain how to keep things working, remove a stray char
from another comment
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.38 2006/02/17 07:22:43 dlg Exp $ */
d1068 1
a1068 1
	return (((int64_t)value/10 * 1000000) + 273150000);
@


1.38
log
@jordan says the volt sensors on the powersupply esm device are always off
by a factor of 10, no matter which machine its found on. therefore i dont
need all that crazy glue to special case its values on the 4400. instead
i created a new VOLTSx10 esm sensor which is the same as the volts sensor
but gets multiplied by 10 after being read.
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.37 2006/02/10 04:26:14 dlg Exp $ */
d67 4
d888 1
a888 1
			 * this expands it out to 6 separate indicators/
@


1.37
log
@i got some labels in the system power supply bits mixed up
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.36 2006/02/10 04:20:04 dlg Exp $ */
d55 2
a56 1
	ESM_S_VOLTS, /* arg says if the 4400 volts should be x10 */
d73 1
a86 1
#define ESM_A_VOLTx10		0x01
a94 1
	long			es_arg;
a149 1
u_int16_t	esm_sysid(void);
a159 1

d165 2
d173 6
a178 1
	switch (esm_sysid()) {
d381 5
a385 2
			es->es_sensor->value = esm_val2volts(val->v_reading) *
			    es->es_arg;
d624 22
a645 22
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"Power Supply 1 +5V" },
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"Power Supply 1 +12V" },
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"Power Supply 1 +3.3V" },
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"Power Supply 1 -5V" },

	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"Power Supply 1 -12V" },
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"Power Supply 2 +5V" },
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"Power Supply 2 +12V" },
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"Power Supply 2 +3.3V" },
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"Power Supply 2 -5V" },

	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"Power Supply 2 -12V" },
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"Power Supply 3 +5V" },
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"Power Supply 3 +12V" },
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"Power Supply 3 +3.3V" },
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"Power Supply 3 -5V" },

	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"Power Supply 3 -12V" },
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"System Power Supply +5V" },
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"System Power Supply +12V" },
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"System Power Supply +3.3V" },
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"System Power Supply -5V" },
d647 2
a648 2
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"System Power Supply -12V" },
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"System Power Supply +5V aux" },
a821 1
	u_int16_t		sysid = esm_sysid();
a900 7
		case ESM_S_VOLTS:
			if ((sysid == DELL_SYSID_4400) &&
			    (sensor_map[i].arg == ESM_A_VOLTx10))
				es->es_arg = 10;
			else
				es->es_arg = 1;
			/* FALLTHROUGH */
d904 2
a967 13
}

u_int16_t
esm_sysid(void)
{
	struct dell_sysid *pdellid;
	uint16_t sysid;

	pdellid = (struct dell_sysid *)ISA_HOLE_VADDR(DELL_SYSID_ADDR);
	if ((sysid = pdellid->sys_id) == DELL_SYSID_EXT)
		sysid = pdellid->ext_id;

	return (sysid);
@


1.36
log
@hook the amp sensors up properly. normalise their values and check the
thresholds.
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.35 2006/02/10 02:55:23 dlg Exp $ */
d635 1
a636 1
	{ ESM_S_VOLTS,		ESM_A_VOLTx10,	"System Power Supply +12V" },
@


1.35
log
@some of the voltage sensors on the 4400 (not all of them, just some) are
off by a factor of 10. this puts some glue in for the volt sensors so they
can be individually marked as being off by ten or not.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.34 2006/01/29 00:13:27 dlg Exp $ */
d159 1
d379 3
d403 1
d903 1
d1082 6
@


1.34
log
@index the drive labels from 0 instead of 1 to match the labels on the front
of the machine. also helps line things up between sensors and bioctl.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.33 2006/01/19 17:08:39 grange Exp $ */
d55 1
a55 1
	ESM_S_VOLTS,
d85 1
a85 6
#define ESM_A_PWRSUP_1		0x10
#define ESM_A_PWRSUP_2		0x20
#define ESM_A_PWRSUP_3		0x40
#define ESM_A_PWRSUP_4		0x80
#define ESM_A_SCSI_A		0x01
#define ESM_A_SCSI_B		0x02
d94 1
d150 1
a165 2
	struct dell_sysid *pdellid;
	uint16_t sysid;
d172 1
a172 6
	pdellid = (struct dell_sysid *)ISA_HOLE_VADDR(DELL_SYSID_ADDR);
	if ((sysid = pdellid->sys_id) == DELL_SYSID_EXT)
		sysid = pdellid->ext_id;
	DPRINTF("SysId: %x\n", sysid);

	switch (sysid) {
d375 2
a376 1
			es->es_sensor->value = esm_val2volts(val->v_reading);
d540 2
a541 2
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_1,	"Power Supply 1" },
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_2,	"Power Supply 2" },
d564 1
a564 1
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_3,	"Power Supply 3" },
d589 6
a594 6
	{ ESM_S_SCSICONN,	ESM_A_SCSI_A,	"Backplane SCSI A Connected" },
	{ ESM_S_VOLTS,		ESM_A_SCSI_A,	"Backplane SCSI A External" },
	{ ESM_S_VOLTS,		ESM_A_SCSI_A,	"Backplane SCSI A Internal" },
	{ ESM_S_SCSICONN,	ESM_A_SCSI_B,	"Backplane SCSI B Connected" },
	{ ESM_S_VOLTS,		ESM_A_SCSI_B,	"Backplane SCSI B External" },
	{ ESM_S_VOLTS,		ESM_A_SCSI_B,	"Backplane SCSI B Internal" },
d611 40
a650 40
	{ ESM_S_VOLTS,		ESM_A_PWRSUP_1,	"Power Supply 1 +5V" },
	{ ESM_S_VOLTS,		ESM_A_PWRSUP_1,	"Power Supply 1 +12V" },
	{ ESM_S_VOLTS,		ESM_A_PWRSUP_1,	"Power Supply 1 +3.3V" },
	{ ESM_S_VOLTS,		ESM_A_PWRSUP_1,	"Power Supply 1 -5V" },

	{ ESM_S_VOLTS,		ESM_A_PWRSUP_1,	"Power Supply 1 -12V" },
	{ ESM_S_VOLTS,		ESM_A_PWRSUP_2,	"Power Supply 2 +5V" },
	{ ESM_S_VOLTS,		ESM_A_PWRSUP_2,	"Power Supply 2 +12V" },
	{ ESM_S_VOLTS,		ESM_A_PWRSUP_2,	"Power Supply 2 +3.3V" },
	{ ESM_S_VOLTS,		ESM_A_PWRSUP_2,	"Power Supply 2 -5V" },

	{ ESM_S_VOLTS,		ESM_A_PWRSUP_2,	"Power Supply 2 -12V" },
	{ ESM_S_VOLTS,		ESM_A_PWRSUP_3,	"Power Supply 3 +5V" },
	{ ESM_S_VOLTS,		ESM_A_PWRSUP_3,	"Power Supply 3 +12V" },
	{ ESM_S_VOLTS,		ESM_A_PWRSUP_3,	"Power Supply 3 +3.3V" },
	{ ESM_S_VOLTS,		ESM_A_PWRSUP_3,	"Power Supply 3 -5V" },

	{ ESM_S_VOLTS,		ESM_A_PWRSUP_3,	"Power Supply 3 -12V" },
	{ ESM_S_VOLTS,		0,		"System Power Supply +5V" },
	{ ESM_S_VOLTS,		0,		"System Power Supply +3.3V" },
	{ ESM_S_VOLTS,		0,		"System Power Supply +12V" },
	{ ESM_S_VOLTS,		0,		"System Power Supply -5V" },

	{ ESM_S_VOLTS,		0,		"System Power Supply -12V" },
	{ ESM_S_VOLTS,		0,		"System Power Supply +5V aux" },
	{ ESM_S_AMPS,		ESM_A_PWRSUP_1,	"Power Supply 1 +5V" },
	{ ESM_S_AMPS,		ESM_A_PWRSUP_1,	"Power Supply 1 +12V" },
	{ ESM_S_AMPS,		ESM_A_PWRSUP_1,	"Power Supply 1 +3.3V" },

	{ ESM_S_AMPS,		ESM_A_PWRSUP_2,	"Power Supply 2 +5V" },
	{ ESM_S_AMPS,		ESM_A_PWRSUP_2,	"Power Supply 2 +12V" },
	{ ESM_S_AMPS,		ESM_A_PWRSUP_2,	"Power Supply 2 +3.3V" },
	{ ESM_S_AMPS,		ESM_A_PWRSUP_3,	"Power Supply 3 +5V" },
	{ ESM_S_AMPS,		ESM_A_PWRSUP_3,	"Power Supply 3 +12V" },

	{ ESM_S_AMPS,		ESM_A_PWRSUP_3,	"Power Supply 3 +3.3V" },
	{ ESM_S_FANRPM,		ESM_A_PWRSUP_1,	"Power Supply 1 Fan" },
	{ ESM_S_FANRPM,		ESM_A_PWRSUP_2,	"Power Supply 2 Fan" },
	{ ESM_S_FANRPM,		ESM_A_PWRSUP_3,	"Power Supply 3 Fan" },
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_1,	"Power Supply 1" },
d652 2
a653 2
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_2,	"Power Supply 2" },
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_3,	"Power Supply 3" },
d809 1
d889 7
a897 1
		case ESM_S_VOLTS:
d960 13
@


1.33
log
@Replace SENSOR_ADD() macro with a pair of functions
sensor_add()/sensor_del() so that sensors can be attached
and detached dynamicaly.

ok kettenis@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.32 2006/01/05 07:39:30 dlg Exp $ */
d604 3
a606 2
	{ ESM_S_DRIVES,		1,		"Drive" },
	{ ESM_S_DRIVES,		5,		"Drive" },
a613 1
	{ ESM_S_DRIVE,		0,		"Drive 8" },
@


1.32
log
@interacting with the watchdog while we're in the middle of updating sensors
is bad(tm). if updates are happening then make esm_refresh to do
esm_watchdogs work after its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.31 2006/01/04 21:58:21 dlg Exp $ */
d922 1
a922 1
			SENSOR_ADD(&s[j]);
@


1.31
log
@esm_cmd has to wait for two registers to change state for every command
that you issue to the controller. the current code works around busy
waiting on the first register by retrying it in a new tick of softclock,
but the second register was still handled with a busy wait. esm_cmd now
returns which register it is up to dealing with so you can resume the
command at the right point in a new tick.

this drops the cpu usage when doing the updates from roughly 15% time in
interrupts down to barely noticable.

looks reasonable deraadt@@ commitsky! marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.30 2005/12/15 08:45:33 dlg Exp $ */
d26 1
d119 1
a119 1
	int			sc_step;
d123 1
d285 7
a291 2
			/* tickle the watchdog */
			EWRITE(sc, ESM2_CTRL_REG, ESM2_TC_HBDB);
d297 2
d312 12
d326 1
a326 1
		return (0);
d443 10
@


1.30
log
@shrink a little
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.29 2005/12/15 07:58:52 dlg Exp $ */
d118 1
d154 1
a154 1
		    int);
d156 1
a156 1
		    struct esm_smb_resp *, int);
d268 1
a268 1
		timeout_add(&sc->sc_timeout, hz * 10);
d303 1
a303 1
	if (esm_cmd(sc, &prop, sizeof(prop), NULL, 0, 1) != 0) {
d313 1
a313 1
	esm_cmd(sc, &state, sizeof(state), NULL, 0, 1);
d329 1
a329 1
	int			nsensors, i;
d351 2
a352 1
	if (esm_smb_cmd(sc, &req, &resp, 0) != 0) {
d421 1
d429 1
a429 1
	timeout_add(&sc->sc_timeout, hz / 100);
d449 1
a449 1
	if (esm_cmd(sc, &req, sizeof(req), &resp, sizeof(resp), 1) != 0)
d798 1
a798 1
		if (esm_smb_cmd(sc, &req, &resp, 1) != 0)
d916 1
a916 1
	if (esm_smb_cmd(sc, &req, &resp, 1) != 0)
d949 1
a949 1
    size_t resplen, int wait)
d955 40
a994 26
	/* Wait for card ready */
	if (esm_bmc_ready(sc, ESM2_CTRL_REG, ESM2_TC_READY, 0, wait) != 0)
		return (1); /* busy */

	/* Write command data to port */
	ECTRLWR(sc, ESM2_TC_CLR_WPTR);
	for (i = 0; i < cmdlen; i++) {
		DPRINTFN(2, "write: %.2x\n", *tx);
		EDATAWR(sc, *tx);
		tx++;
	}

	/* Ring doorbell and wait */
	ECTRLWR(sc, ESM2_TC_H2ECDB);
	esm_bmc_ready(sc, ESM2_CTRL_REG, ESM2_TC_EC2HDB, ESM2_TC_EC2HDB, 1);

	/* Set host busy semaphore and clear doorbell */
	ECTRLWR(sc, ESM2_TC_HOSTBUSY);
	ECTRLWR(sc, ESM2_TC_EC2HDB);

	/* Read response data from port */
	ECTRLWR(sc, ESM2_TC_CLR_RPTR);
	for (i = 0; i < resplen; i++) {
		*rx = EDATARD(sc);
		DPRINTFN(2, "read = %.2x\n", *rx);
		rx++;
a996 3
	/* release semaphore */
	ECTRLWR(sc, ESM2_TC_HOSTBUSY);

d1002 1
a1002 1
    struct esm_smb_resp *resp, int wait)
d1004 2
d1008 4
a1011 3
	if (esm_cmd(sc, req, sizeof(req->hdr) + req->h_txlen, resp,
	    sizeof(resp->hdr) + req->h_rxlen, wait) != 0)
		return (1);
@


1.29
log
@dont use the esm sensor tables to store format strings.
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.28 2005/12/15 07:49:42 dlg Exp $ */
d328 1
a328 1
	int			i;
d338 12
d354 2
a355 14
		switch (es->es_type) {
		case ESM_S_DRIVES:
			for (i = 0; i < 4; i++)
				es->es_sensor[i].flags |= SENSOR_FINVALID;
			break;
		case ESM_S_PWRSUP:
			for (i = 0; i < 6; i++)
				es->es_sensor[i].flags |= SENSOR_FINVALID;
			break;
		default:
			es->es_sensor->flags |= SENSOR_FINVALID;
			break;
		}

a359 1
			es->es_sensor->flags &= ~SENSOR_FINVALID;
a362 1
			es->es_sensor->flags &= ~SENSOR_FINVALID;
d365 1
a365 1
			for (i = 0; i < 4; i++) {
a367 1
				es->es_sensor[i].flags &= ~SENSOR_FINVALID;
d371 1
a371 1
			for (i = 0; i < 6; i++) {
a373 1
				es->es_sensor[i].flags &= ~SENSOR_FINVALID;
a377 1
			es->es_sensor->flags &= ~SENSOR_FINVALID;
d413 2
@


1.28
log
@split esms psu sensor into 6 kernel sensors. you can easily see if the
psu is powered, switched on, overtemp, failed and so on now.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.27 2005/12/13 02:31:45 dlg Exp $ */
d518 2
a519 2
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_1,	"Power Supply 1 %s" },
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_2,	"Power Supply 2 %s" },
d542 1
a542 1
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_3,	"Power Supply 3 %s" },
d573 2
a574 2
	{ ESM_S_DRIVES,		1,		"Drive %d" },
	{ ESM_S_DRIVES,		5,		"Drive %d" },
d628 1
a628 1
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_1,	"Power Supply 1 %s" },
d630 2
a631 2
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_2,	"Power Supply 2 %s" },
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_3,	"Power Supply 3 %s" },
d842 1
a842 1
				snprintf(s[j].desc, sizeof(s[j].desc),
d861 1
a861 1
				snprintf(s[j].desc, sizeof(s[j].desc),
@


1.27
log
@the status field for power supplies is different to the rest of the
sensors. as a result i wasnt being shown that i have a failed power supply.

power supplies now show up like this:
hw.sensors.14=esm0, Power Supply 1, OK, raw, 65359
hw.sensors.15=esm0, Power Supply 2, OK, raw, 65359
hw.sensors.16=esm0, Power Supply 3, CRITICAL, raw, 65347

anyone got a spare 2500 power supply they want to send to me?

ok deraadt@@ marco@@ jordan@@
VS: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.26 2005/12/01 00:19:14 deraadt Exp $ */
d72 1
a72 1
	SENSOR_INTEGER,
d347 4
d373 7
d407 1
a407 1
				es->es_sensor->status = SENSOR_S_CRIT;
d411 1
a411 1
			es->es_sensor->status = SENSOR_S_OK;
d518 2
a519 2
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_1,	"Power Supply 1" },
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_2,	"Power Supply 2" },
d542 1
a542 1
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_3,	"Power Supply 3" },
d628 1
a628 1
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_1,	"Power Supply 1" },
d630 2
a631 2
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_2,	"Power Supply 2" },
	{ ESM_S_PWRSUP,		ESM_A_PWRSUP_3,	"Power Supply 3" },
d784 3
d808 1
a808 1
			if (!(val->v_status & ESM2_VS_PSU_INST))
d846 19
d889 1
a889 1
			s->type = esm_typemap[es->es_type];
@


1.26
log
@shrink code size by sharing some printf code, no change in how it works
ok dlg marco
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.25 2005/11/30 17:39:45 deraadt Exp $ */
d394 9
d792 10
a801 2
		if ((val->v_status & ESM2_VS_VALID) != ESM2_VS_VALID)
			continue;
@


1.25
log
@format string mishandling
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.24 2005/11/30 15:46:32 dlg Exp $ */
d555 1
a555 1
	{ ESM_S_DRIVE,		0,		"Drive 1"},
d587 4
a590 4
	{ ESM_S_VOLTS,		0,		"System power supply +5V" },
	{ ESM_S_VOLTS,		0,		"System power supply +3.3V" },
	{ ESM_S_VOLTS,		0,		"System power supply +12V" },
	{ ESM_S_VOLTS,		0,		"System power supply -5V" },
d592 2
a593 2
	{ ESM_S_VOLTS,		0,		"System power supply -12V" },
	{ ESM_S_VOLTS,		0,		"System power supply +5V aux" },
d605 3
a607 3
	{ ESM_S_FANRPM,		ESM_A_PWRSUP_1,	"Power supply 1 Fan" },
	{ ESM_S_FANRPM,		ESM_A_PWRSUP_2,	"Power supply 2 Fan" },
	{ ESM_S_FANRPM,		ESM_A_PWRSUP_3,	"Power supply 3 Fan" },
d627 1
a627 1
	const char		*name;
a690 1

d695 1
a695 2
		printf("%s: %s Embedded Server Management %d.%d\n",
		    DEVNAME(sc), name, devmap->rev_major, devmap->rev_minor);
d699 2
a700 3
		printf("%s: Dell Remote Assistance Card II %d.%d\n",
		    DEVNAME(sc), devmap->rev_major, devmap->rev_minor);
		return;
d703 2
a704 3
		printf("%s: Front Panel %d.%d\n", DEVNAME(sc),
		    devmap->rev_major, devmap->rev_minor);
		return;
d710 1
a710 2
		printf("%s: Primary System Backplane %d.%d\n", DEVNAME(sc),
		    devmap->rev_major, devmap->rev_minor);
d718 1
a718 2
		printf("%s: Power Unit %d.%d\n", DEVNAME(sc),
		    devmap->rev_major, devmap->rev_minor);
d723 2
a724 3
		printf("%s: Enclosure Backplane %d.%d\n", DEVNAME(sc),
		    devmap->rev_major, devmap->rev_minor);
		return;
d728 2
a729 3
		printf("%s: Enclosure Powerunit %d.%d\n", DEVNAME(sc),
		    devmap->rev_major, devmap->rev_minor);
		return;
d732 2
a733 3
		printf("%s: HPPCI %d.%d\n", DEVNAME(sc),
		    devmap->rev_major, devmap->rev_minor);
		return;
d740 1
a740 2
		printf("%s: Primary System Backplane %d.%d\n", DEVNAME(sc),
		    devmap->rev_major, devmap->rev_minor);
d746 4
@


1.24
log
@add a sensor type for drive status and hook esm up with it.

ok marco@@ grange@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.23 2005/11/30 13:40:33 dlg Exp $ */
d247 1
a247 1
		printf("%s: card is not alive\n");
@


1.23
log
@reorder slightly
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.22 2005/11/30 11:46:57 dlg Exp $ */
d75 2
a76 2
	SENSOR_INTEGER,
	SENSOR_INTEGER,
@


1.22
log
@determine the status of fan, volt, and temp sensors by reading the
thresholds off at attach and then comparing the value at update to these
cutoffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.21 2005/11/28 23:56:04 deraadt Exp $ */
d65 16
a758 16

enum sensor_type esm_typemap[] = {
	SENSOR_INTEGER,
	SENSOR_INDICATOR,
	SENSOR_TEMP,
	SENSOR_FANRPM,
	SENSOR_VOLTS_DC,
	SENSOR_AMPS,
	SENSOR_INTEGER,
	SENSOR_INTEGER,
	SENSOR_INDICATOR,
	SENSOR_INTEGER,
	SENSOR_INTEGER,
	SENSOR_INTEGER,
	SENSOR_INDICATOR
};
@


1.21
log
@no need for printf; man page should describe functionality
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.20 2005/11/28 22:13:48 deraadt Exp $ */
a36 2
/* #define ESM_DEBUG */

d40 1
a40 1
int	esmdebug = 2;
d83 7
d132 2
d358 24
d822 9
d853 34
@


1.20
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.19 2005/11/28 22:11:07 jordan Exp $ */
d231 1
a231 1
	printf(": Hardware Watchdog\n");
@


1.19
log
@Added dlg@@ watchdog code for enabling ESM2 watchdog timer
Fixes for watchdog code by jordan@@
Spacing fixes in esmreg
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.18 2005/11/28 20:37:16 jordan Exp $ */
d99 1
a99 1
	int 			sc_wdog_period;
d149 1
a149 1
		return (0); 
d156 1
a156 1
 	switch(sysid) {
a247 1

a362 1
	
d760 1
a760 1
		
d772 1
a772 1
			/* 
a813 1

@


1.18
log
@Fixed Motherbobrd typo
Changed type of Power Unit sensor
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.17 2005/11/28 20:27:43 jordan Exp $ */
d31 1
d98 2
d119 2
d229 3
a231 1
	printf(": Watchdog shizz goes here\n");
d246 50
@


1.17
log
@Added sysids for PowerVault/PowerApp ESM2 systems
Changed Register names to be more readable
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.16 2005/11/28 19:59:25 deraadt Exp $ */
d363 1
a363 1
	{ ESM_S_UNKNOWN,	0,		"Motherbobrd" },
d466 1
a466 1
	{ SENSOR_INTEGER,	0,		"Power Unit" },
@


1.16
log
@probe before match; ok jordan marco
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.11 2005/11/22 21:51:19 jordan Exp $ */
d112 3
a114 3
#define ECTRLWR(s, v)	EWRITE((s), ESM2_TC_REG, (v))
#define EDATARD(s)	EREAD((s), ESM2_TBUF_REG)
#define EDATAWR(s, v)	EWRITE((s), ESM2_TBUF_REG, (v))
d164 5
d206 1
a206 1
	x = EREAD(sc, ESM2_TIM_REG);
d209 1
a209 1
	EWRITE(sc, ESM2_TIM_REG, x);
d212 1
a212 1
	x = EREAD(sc, ESM2_TC_REG);
d215 1
a215 1
	EWRITE(sc, ESM2_TC_REG, x);
d218 1
a218 1
	if (esm_bmc_ready(sc, ESM2_TC_REG, ESM2_TC_ECBUSY, 0, 1) != 0) {
d784 1
a784 1
	if (esm_bmc_ready(sc, ESM2_TC_REG, ESM2_TC_READY, 0, wait) != 0)
d797 1
a797 1
	esm_bmc_ready(sc, ESM2_TC_REG, ESM2_TC_EC2HDB, ESM2_TC_EC2HDB, 1);
@


1.15
log
@print something out when we hit unsupported devices. hopefully we can
pick up a dmesg with them.
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.14 2005/11/24 08:11:04 dlg Exp $ */
d132 2
d135 1
a135 1
esm_match(struct device *parent, void *match, void *aux)
d137 7
a143 12
	struct esm_attach_args		*eaa = aux;
	const char			*dell_str;
	const struct dell_sysid		*dell_sysid;
	u_int16_t			sysid;

	if (strncmp(eaa->eaa_name, esm_cd.cd_name, sizeof(esm_cd.cd_name)) != 0)
		return (0);

	/* Determine if this is a Dell server */
	dell_str = (const char *)ISA_HOLE_VADDR(DELL_SYSSTR_ADDR);
	DPRINTF("Dell String: %s\n", dell_str);
	if (strncmp(dell_str, "Dell System", 11) != 0)
d146 3
a148 4
	/* Determine if it is an appropriate Dell server */
	dell_sysid = (const struct dell_sysid *)ISA_HOLE_VADDR(DELL_SYSID_ADDR);
	if ((sysid = dell_sysid->sys_id) == DELL_SYSID_EXT)
		sysid = dell_sysid->ext_id;
d151 1
a151 1
 	switch (sysid) {
d164 1
a164 3
		break;
	default:
		return (0);
d167 13
a179 1
	return (1);
@


1.14
log
@white space fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.13 2005/11/24 08:03:16 dlg Exp $ */
d587 10
d613 17
@


1.13
log
@break the 1:1 mapping of esm sensors to kernel sensors. according to
jordan theres an esm sensor that packs the status of four drive slots
into a single reading, but it should be represented in the kernel as four
separate sensors. some of the sensors (such as the pci slot ones and the
hotplug status) should probably be dealt with in the same way.

so esm sensors now have a list of their own types, and a mapping of these
types to kernel sensor types. instead of storing the kernel sensor in the
esm_sensor struct, allocate the two separately so esm_sensor can point to
multiple kernel sensors. make the drives sensor fill out 4 kernel sensors.

it still works on my box, but i dont have a machine old enough to see if
the packed esm sensor turns into 4 kernel ones without problems.  i hate
how theres no mechanism to remove kernel sensors after you use SENSOR_ADD.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.12 2005/11/23 01:07:40 dlg Exp $ */
d388 29
a416 29
        { ESM_S_VOLTS,		0,		"Mainboard +1.5V" }, /* 30 */
        { ESM_S_VOLTS,		0,		"Motherboard +2.8V" },
        { ESM_S_UNKNOWN,	0,		"HotPlug Status" },
        { ESM_S_PCISLOT,	0,		"PCI Slot 1" },
        { ESM_S_PCISLOT,	0,		"PCI Slot 2" },

        { ESM_S_PCISLOT,	0,		"PCI Slot 3" },
        { ESM_S_PCISLOT,	0,		"PCI Slot 4" },
        { ESM_S_PCISLOT,	0,		"PCI Slot 5" },
        { ESM_S_PCISLOT,	0,		"PCI Slot 6" },
        { ESM_S_PCISLOT,	0,		"PCI Slot 7" },

        { ESM_S_VOLTS,		0,		"CPU 1 Cartridge" }, /* 40 */
        { ESM_S_VOLTS,		0,		"CPU 2 Cartridge" },
        { ESM_S_VOLTS,		0,		"CPU 3 Cartridge" },
        { ESM_S_VOLTS,		0,		"CPU 4 Cartridge" },
        { ESM_S_VOLTS,		0,		"Gigabit NIC +1.8V" },

        { ESM_S_VOLTS,		0,		"Gigabit NIC +2.5V" },
        { ESM_S_VOLTS,		0,		"Memory +3.3V" },
        { ESM_S_VOLTS,		0,		"Video +2.5V" },
        { ESM_S_PWRSUP,		ESM_A_PWRSUP_3,	"Power Supply 3" },
        { ESM_S_FANRPM,		0,		"Fan 4" },

        { ESM_S_FANRPM,		0,		"Power Supply Fan" }, /* 50 */
        { ESM_S_FANRPM,		0,		"Power Supply Fan" },
        { ESM_S_FANRPM,		0,		"Power Supply Fan" },
        { ESM_S_ACSWITCH,	0,		"A/C Power Switch" },
        { ESM_S_UNKNOWN,	0,		"PS Over Temp" }
@


1.12
log
@merge probe and match since one is only ever called from the other. knf too

yup deraadt@@ ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.11 2005/11/22 21:51:19 jordan Exp $ */
d50 17
a66 1
struct esm_sensor_type {
d82 1
a82 1
	long			es_arg;
d84 1
a84 1
	struct sensor		es_sensor;
d121 1
a121 1
		    struct esm_sensor_type *, int);
d234 1
a234 1
	struct esm_sensor	*sensor = sc->sc_nextsensor;
d238 1
d242 1
a242 1
	req.h_dev = sensor->es_dev;
d246 1
a246 1
	req.req_val.v_sensor = sensor->es_id;
d251 11
a261 1
		sensor->es_sensor.flags |= SENSOR_FINVALID;
d263 15
a277 6
		switch (sensor->es_sensor.type) {
		case SENSOR_TEMP:
			sensor->es_sensor.value = esm_val2temp(val->v_reading);
			break;
		case SENSOR_VOLTS_DC:
			sensor->es_sensor.value = esm_val2volts(val->v_reading);
d280 2
a281 1
			sensor->es_sensor.value = val->v_reading;
a283 1
		sensor->es_sensor.flags &= ~SENSOR_FINVALID;
d286 1
a286 1
	sc->sc_nextsensor = TAILQ_NEXT(sensor, es_entry);
d351 66
a416 66
struct esm_sensor_type esm_sensors_esm2[] = {
	{ SENSOR_INTEGER,	0,		"Motherboard" },
	{ SENSOR_TEMP,		0,		"CPU 1" },
	{ SENSOR_TEMP,		0,		"CPU 2" },
	{ SENSOR_TEMP,		0,		"CPU 3" },
	{ SENSOR_TEMP,		0,		"CPU 4" },

	{ SENSOR_TEMP,		0,		"Mainboard" },
	{ SENSOR_TEMP,		0,		"Ambient" },
	{ SENSOR_VOLTS_DC,	0,		"CPU 1 Core" },
	{ SENSOR_VOLTS_DC,	0,		"CPU 2 Core" },
	{ SENSOR_VOLTS_DC,	0,		"CPU 3 Core" },

	{ SENSOR_VOLTS_DC,	0,		"CPU 4 Core" },
	{ SENSOR_VOLTS_DC,	0,		"Motherboard +5V" },
	{ SENSOR_VOLTS_DC,	0,		"Motherboard +12V" },
	{ SENSOR_VOLTS_DC,	0,		"Motherboard +3.3V" },
	{ SENSOR_VOLTS_DC,	0,		"Motherboard +2.5V" },

	{ SENSOR_VOLTS_DC,	0,		"Motherboard GTL Term" },
	{ SENSOR_VOLTS_DC,	0,		"Motherboard Battery" },
	{ SENSOR_INDICATOR,	0,		"Chassis Intrusion", },
	{ SENSOR_INTEGER,	0,		"Chassis Fan Ctrl", },
	{ SENSOR_FANRPM,	0,		"Fan 1" },

	{ SENSOR_FANRPM,	0,		"Fan 2" }, /* 20 */
	{ SENSOR_FANRPM,	0,		"Fan 3" },
	{ SENSOR_FANRPM,	0,		"Power Supply Fan" },
	{ SENSOR_VOLTS_DC,	0,		"CPU 1 cache" },
	{ SENSOR_VOLTS_DC,	0,		"CPU 2 cache" },

	{ SENSOR_VOLTS_DC,	0,		"CPU 3 cache" },
	{ SENSOR_VOLTS_DC,	0,		"CPU 4 cache" },
	{ SENSOR_INTEGER,	0,		"Power Ctrl" },
	{ SENSOR_INTEGER,	ESM_A_PWRSUP_1,	"Power Supply 1" },
	{ SENSOR_INTEGER,	ESM_A_PWRSUP_2,	"Power Supply 2" },

        { SENSOR_VOLTS_DC,	0,		"Mainboard +1.5V" }, /* 30 */
        { SENSOR_VOLTS_DC,	0,		"Motherboard +2.8V" },
        { SENSOR_INTEGER,	0,		"HotPlug Status" },
        { SENSOR_INTEGER,	1,		"PCI Slot 1" },
        { SENSOR_INTEGER,	2,		"PCI Slot 2" },

        { SENSOR_INTEGER,	3,		"PCI Slot 3" },
        { SENSOR_INTEGER,	4,		"PCI Slot 4" },
        { SENSOR_INTEGER,	5,		"PCI Slot 5" },
        { SENSOR_INTEGER,	6,		"PCI Slot 6" },
        { SENSOR_INTEGER,	7,		"PCI Slot 7" },

        { SENSOR_VOLTS_DC,	0,		"CPU 1 Cartridge" }, /* 40 */
        { SENSOR_VOLTS_DC,	0,		"CPU 2 Cartridge" },
        { SENSOR_VOLTS_DC,	0,		"CPU 3 Cartridge" },
        { SENSOR_VOLTS_DC,	0,		"CPU 4 Cartridge" },
        { SENSOR_VOLTS_DC,	0,		"Gigabit NIC +1.8V" },

        { SENSOR_VOLTS_DC,	0,		"Gigabit NIC +2.5V" },
        { SENSOR_VOLTS_DC,	0,		"Memory +3.3V" },
        { SENSOR_VOLTS_DC,	0,		"Video +2.5V" },
        { SENSOR_INTEGER,	ESM_A_PWRSUP_3,	"Power Supply 3" },
        { SENSOR_FANRPM,	0,		"Fan 4" },

        { SENSOR_FANRPM,	0,		"Power Supply Fan" }, /* 50 */
        { SENSOR_FANRPM,	0,		"Power Supply Fan" },
        { SENSOR_FANRPM,	0,		"Power Supply Fan" },
        { SENSOR_INTEGER,	0,		"A/C Power Switch" },
        { SENSOR_INTEGER,	0,		"PS Over Temp" }
d419 33
a451 33
struct esm_sensor_type esm_sensors_backplane[] = {
	{ SENSOR_INTEGER,	0,		"Backplane" },
	{ SENSOR_INTEGER,	0,		"Backplane Control" },
	{ SENSOR_TEMP,		0,		"Backplane Top" },
	{ SENSOR_TEMP,		0,		"Backplane Bottom" },
	{ SENSOR_TEMP,		0,		"Backplane Control Panel" },
	{ SENSOR_VOLTS_DC,	0,		"Backplane Battery" },
	{ SENSOR_VOLTS_DC,	0,		"Backplane +5V" },
	{ SENSOR_VOLTS_DC,	0,		"Backplane +12V" },
	{ SENSOR_VOLTS_DC,	0,		"Backplane Board" },
	{ SENSOR_INTEGER,	0,		"Backplane Intrusion" },
	{ SENSOR_INTEGER,	0,		"Backplane Fan Control" },
	{ SENSOR_FANRPM,	0,		"Backplane Fan 1" },
	{ SENSOR_FANRPM,	0,		"Backplane Fan 2" },
	{ SENSOR_FANRPM,	0,		"Backplane Fan 3" },
	{ SENSOR_INDICATOR,	ESM_A_SCSI_A,	"Backplane SCSI A Connected" },
	{ SENSOR_VOLTS_DC,	ESM_A_SCSI_A,	"Backplane SCSI A External" },
	{ SENSOR_VOLTS_DC,	ESM_A_SCSI_A,	"Backplane SCSI A Internal" },
	{ SENSOR_INDICATOR,	ESM_A_SCSI_B,	"Backplane SCSI B Connected" },
	{ SENSOR_VOLTS_DC,	ESM_A_SCSI_B,	"Backplane SCSI B External" },
	{ SENSOR_VOLTS_DC,	ESM_A_SCSI_B,	"Backplane SCSI B Internal" },
	{ SENSOR_INTEGER,	0x41,		"Drives 1-4" },
	{ SENSOR_INTEGER,	0x45,		"Drives 5-8" },
	{ SENSOR_INTEGER,	0x11,		"Drive 1"},
	{ SENSOR_INTEGER,	0x12,		"Drive 2" },
	{ SENSOR_INTEGER,	0x13,		"Drive 3" },
	{ SENSOR_INTEGER,	0x14,		"Drive 4" },
	{ SENSOR_INTEGER,	0x15,		"Drive 5" },
	{ SENSOR_INTEGER,	0x16,		"Drive 6" },
	{ SENSOR_INTEGER,	0x17,		"Drive 7" },
	{ SENSOR_INTEGER,	0x18,		"Drive 8" },
	{ SENSOR_INTEGER,	0,		"Backplane Control 2" },
	{ SENSOR_VOLTS_DC,	0,		"Backplane +3.3V" },
d454 1
a454 1
struct esm_sensor_type esm_sensors_powerunit[] = {
d456 52
a507 52
	{ SENSOR_VOLTS_DC,	ESM_A_PWRSUP_1,	"Power Supply 1 +5V" },
	{ SENSOR_VOLTS_DC,	ESM_A_PWRSUP_1,	"Power Supply 1 +12V" },
	{ SENSOR_VOLTS_DC,	ESM_A_PWRSUP_1,	"Power Supply 1 +3.3V" },
	{ SENSOR_VOLTS_DC,	ESM_A_PWRSUP_1,	"Power Supply 1 -5V" },

	{ SENSOR_VOLTS_DC,	ESM_A_PWRSUP_1,	"Power Supply 1 -12V" },
	{ SENSOR_VOLTS_DC,	ESM_A_PWRSUP_2,	"Power Supply 2 +5V" },
	{ SENSOR_VOLTS_DC,	ESM_A_PWRSUP_2,	"Power Supply 2 +12V" },
	{ SENSOR_VOLTS_DC,	ESM_A_PWRSUP_2,	"Power Supply 2 +3.3V" },
	{ SENSOR_VOLTS_DC,	ESM_A_PWRSUP_2,	"Power Supply 2 -5V" },

	{ SENSOR_VOLTS_DC,	ESM_A_PWRSUP_2,	"Power Supply 2 -12V" },
	{ SENSOR_VOLTS_DC,	ESM_A_PWRSUP_3,	"Power Supply 3 +5V" },
	{ SENSOR_VOLTS_DC,	ESM_A_PWRSUP_3,	"Power Supply 3 +12V" },
	{ SENSOR_VOLTS_DC,	ESM_A_PWRSUP_3,	"Power Supply 3 +3.3V" },
	{ SENSOR_VOLTS_DC,	ESM_A_PWRSUP_3,	"Power Supply 3 -5V" },

	{ SENSOR_VOLTS_DC,	ESM_A_PWRSUP_3,	"Power Supply 3 -12V" },
	{ SENSOR_VOLTS_DC,	0,		"System power supply +5V" },
	{ SENSOR_VOLTS_DC,	0,		"System power supply +3.3V" },
	{ SENSOR_VOLTS_DC,	0,		"System power supply +12V" },
	{ SENSOR_VOLTS_DC,	0,		"System power supply -5V" },

	{ SENSOR_VOLTS_DC,	0,		"System power supply -12V" },
	{ SENSOR_VOLTS_DC,	0,		"System power supply +5V aux" },
	{ SENSOR_AMPS,		ESM_A_PWRSUP_1,	"Power Supply 1 +5V" },
	{ SENSOR_AMPS,		ESM_A_PWRSUP_1,	"Power Supply 1 +12V" },
	{ SENSOR_AMPS,		ESM_A_PWRSUP_1,	"Power Supply 1 +3.3V" },

	{ SENSOR_AMPS,		ESM_A_PWRSUP_2,	"Power Supply 2 +5V" },
	{ SENSOR_AMPS,		ESM_A_PWRSUP_2,	"Power Supply 2 +12V" },
	{ SENSOR_AMPS,		ESM_A_PWRSUP_2,	"Power Supply 2 +3.3V" },
	{ SENSOR_AMPS,		ESM_A_PWRSUP_3,	"Power Supply 3 +5V" },
	{ SENSOR_AMPS,		ESM_A_PWRSUP_3,	"Power Supply 3 +12V" },

	{ SENSOR_AMPS,		ESM_A_PWRSUP_3,	"Power Supply 3 +3.3V" },
	{ SENSOR_FANRPM,	ESM_A_PWRSUP_1,	"Power supply 1 Fan" },
	{ SENSOR_FANRPM,	ESM_A_PWRSUP_2,	"Power supply 2 Fan" },
	{ SENSOR_FANRPM,	ESM_A_PWRSUP_3,	"Power supply 3 Fan" },
	{ SENSOR_INTEGER,	ESM_A_PWRSUP_1,	"Power Supply 1" },

	{ SENSOR_INTEGER,	ESM_A_PWRSUP_2,	"Power Supply 2" },
	{ SENSOR_INTEGER,	ESM_A_PWRSUP_3,	"Power Supply 3" },
	{ SENSOR_INTEGER,	0,		"PSPB Fan Control" },
	{ SENSOR_FANRPM,	0,		"Fan 1" },
	{ SENSOR_FANRPM,	0,		"Fan 2" },

	{ SENSOR_FANRPM,	0,		"Fan 3" },
	{ SENSOR_FANRPM,	0,		"Fan 4" },
	{ SENSOR_FANRPM,	0,		"Fan 5" },
	{ SENSOR_FANRPM,	0,		"Fan 6" },
	{ SENSOR_INTEGER,	0,		"Fan Enclosure" },
d513 1
a513 1
	struct esm_sensor_type	*sensor_types;
d515 1
a515 1
	int			nsensors;
d519 1
a519 1
		sensor_types = esm_sensors_esm2;
d524 1
a524 1
			nsensors = 23;
d528 1
a528 1
			nsensors = 27;
d532 1
a532 1
			nsensors = 27;
d536 1
a536 1
			nsensors = 44;
d540 1
a540 1
			nsensors = 48;
d544 1
a544 1
			nsensors = 27;
d548 1
a548 1
			nsensors = 27;
d552 1
a552 1
			nsensors = 44;
d556 1
a556 1
			nsensors = 30;
d560 1
a560 1
			nsensors = 44;
d564 1
a564 1
			nsensors = 55;
d568 1
a568 1
			nsensors = 27;
d572 1
a572 1
			nsensors = 27;
d576 1
a576 1
			nsensors = 44;
d588 2
a589 2
		sensor_types = esm_sensors_backplane;
		nsensors = 22;
d596 2
a597 2
		sensor_types = esm_sensors_powerunit;
		nsensors = sizeof(esm_sensors_powerunit) /
d605 2
a606 2
		sensor_types = esm_sensors_backplane;
		nsensors = sizeof(esm_sensors_backplane) /
d617 1
a617 1
	esm_make_sensors(sc, devmap, sensor_types, nsensors);
d620 16
d638 1
a638 1
    struct esm_sensor_type *sensor_types, int nsensors)
d643 3
a645 2
	struct esm_sensor	*sensor;
	int			i;
d655 1
a655 1
	for (i = 0; i < nsensors; i++) {
d662 1
a662 1
		    DEVNAME(sc), devmap->index, i, sensor_types[i].name,
d667 4
d672 38
a709 16
		sensor = malloc(sizeof(struct esm_sensor), M_DEVBUF, M_NOWAIT);
		if (sensor == NULL)
			goto error;

		memset(sensor, 0, sizeof(struct esm_sensor));
		sensor->es_dev = devmap->index;
		sensor->es_id = i;
		sensor->es_arg = sensor_types[i].arg;
		sensor->es_sensor.type = sensor_types[i].type;
		strlcpy(sensor->es_sensor.device, DEVNAME(sc),
		    sizeof(sensor->es_sensor.device));
		strlcpy(sensor->es_sensor.desc, sensor_types[i].name,
		    sizeof(sensor->es_sensor.desc));
		TAILQ_INSERT_TAIL(&sc->sc_sensors, sensor, es_entry);
		SENSOR_ADD(&sensor->es_sensor);
	}
d711 5
a715 1
	return;
d717 2
a718 5
error:
	while (!TAILQ_EMPTY(&sc->sc_sensors)) {
		sensor = TAILQ_FIRST(&sc->sc_sensors);
		TAILQ_REMOVE(&sc->sc_sensors, sensor, es_entry);
		free(sensor, M_DEVBUF);
@


1.11
log
@Added probing for Dell ESM server
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.10 2005/11/22 13:50:31 dlg Exp $ */
a46 1
int             esm_probe(void);
a115 2

/* Determine if this is a Dell server */
d117 1
a117 1
esm_probe(void)
d119 12
a130 7
	const char *pdellstr;
	struct dell_sysid *pdellid;
	uint16_t sysid;

	pdellstr = (const char *)ISA_HOLE_VADDR(DELL_SYSSTR_ADDR);
	DPRINTF("Dell String: %s\n", pdellstr);
	if (strncmp(pdellstr, "Dell System", 11))
d133 4
a136 3
	pdellid = (struct dell_sysid *)ISA_HOLE_VADDR(DELL_SYSID_ADDR);
	if ((sysid = pdellid->sys_id) == DELL_SYSID_EXT)
		sysid = pdellid->ext_id;
d139 1
a139 1
 	switch(sysid) {
d152 1
a152 1
		return (1);
d157 1
a157 16
	/* NOTREACHED */
	return (0);
}

int
esm_match(struct device *parent, void *match, void *aux)
{
	struct esm_attach_args		*eaa = aux;

	if (!esm_probe())
		return (0);

	if (strncmp(eaa->eaa_name, esm_cd.cd_name, sizeof(esm_cd.cd_name)) == 0)
		return (1);

	return (0);
@


1.10
log
@support one of the powerunits
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.9 2005/11/22 13:28:27 dlg Exp $ */
d29 1
d32 1
d34 1
a34 1
#include <arch/i386/i386/esmvar.h>
d36 1
a36 1
#define ESM_DEBUG
d47 1
d117 41
d163 4
a166 2
	if (strncmp(eaa->eaa_name, esm_cd.cd_name,
	    sizeof(esm_cd.cd_name)) == 0)
@


1.9
log
@add another backplane
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.8 2005/11/22 13:24:20 dlg Exp $ */
d384 56
d522 9
@


1.8
log
@shrink a little
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.7 2005/11/22 11:54:53 dlg Exp $ */
d459 8
@


1.7
log
@for every sensor esm looks after it has to talk to the hardware, which
means it could busy wait while the hardware gets ready. all the sensors
are updated out of a single timeout. doing this for the 30ish esm sensors
on my machine is probably not a good thing...

this changes the way updates are handled. instead of a single big update
for all the sensors, we now update only one sensor in a timeout. after
that sensor has been updated it sets up a very short timeout for the next
sensor to run out of. we also use the short timeouts to retry the same
sensor if the hardware isnt ready which means we avoid the (worst) busy
wait.
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.6 2005/11/22 08:33:24 dlg Exp $ */
d388 1
a388 1
	const char		*maj_name, *min_name;
a392 1
		maj_name = "Embedded Server Management";
d397 1
a397 1
			min_name = "PowerEdge 2300";
d401 1
a401 1
			min_name = "PowerEdge 4300";
d405 1
a405 1
			min_name = "PowerEdge 6300";
d409 1
a409 1
			min_name = "PowerEdge 6400";
d413 1
a413 1
			min_name = "PowerEdge 2550";
d417 1
a417 1
			min_name = "PowerEdge 4350";
d421 1
a421 1
			min_name = "PowerEdge 6350";
d425 1
a425 1
			min_name = "PowerEdge 6450";
d429 1
a429 1
			min_name = "PowerEdge 2400";
d433 1
a433 1
			min_name = "PowerEdge 4400";
d437 1
a437 1
			min_name = "PowerEdge 2500";
d441 1
a441 1
			min_name = "PowerEdge 2450";
d445 1
a445 1
			min_name = "PowerEdge 2400";
d449 1
a449 1
			min_name = "PowerEdge 2450";
d457 2
a458 2
		printf("%s: %s %s %d.%d\n", DEVNAME(sc), min_name, maj_name,
		    devmap->rev_major, devmap->rev_minor);
a461 1
		maj_name = "Primary System Backplane";
d466 1
a466 1
		printf("%s: %s %d.%d\n", DEVNAME(sc), maj_name,
@


1.6
log
@get rid of bmc_wait and use a flag on bmc_ready to indicate if we want
to wait for the port to settle. lengthen the amount of time we wait to
what jordan had originally.
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.5 2005/11/21 23:03:39 dlg Exp $ */
d76 2
d173 2
d184 1
a184 1
	struct esm_sensor	*sensor;
d191 1
d195 1
d197 5
a201 9
	TAILQ_FOREACH(sensor, &sc->sc_sensors, es_entry) {
		req.h_dev = sensor->es_dev;
		req.req_val.v_sensor = sensor->es_id;

		if (esm_smb_cmd(sc, &req, &resp, 1) != 0) {
			sensor->es_sensor.flags |= SENSOR_FINVALID;
			continue;
		}

d213 1
d216 11
a226 1
	timeout_add(&sc->sc_timeout, hz * 10);
d561 1
a561 1
	if (esm_bmc_ready(sc, ESM2_TC_REG, ESM2_TC_READY, 0, 1) != 0)
@


1.5
log
@add support for the backplane found on my 2500
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.4 2005/11/21 22:13:30 dlg Exp $ */
d103 3
a105 3
int		esm_bmc_ready(struct esm_softc *, int, u_int8_t, u_int8_t);
int		esm_bmc_wait(struct esm_softc *, int, u_int8_t, u_int8_t);
int		esm_cmd(struct esm_softc *, void *, size_t, void *, size_t);
d107 1
a107 1
		    struct esm_smb_resp *);
d155 1
a155 1
	if (esm_bmc_wait(sc, ESM2_TC_REG, ESM2_TC_ECBUSY, 0) != 0) {
d195 1
a195 1
		if (esm_smb_cmd(sc, &req, &resp) != 0) {
d233 1
a233 1
	if (esm_cmd(sc, &req, sizeof(req), &resp, sizeof(resp)) != 0)
d486 1
a486 1
		if (esm_smb_cmd(sc, &req, &resp) != 0)
d526 2
a527 1
esm_bmc_ready(struct esm_softc *sc, int port, u_int8_t mask, u_int8_t val)
d529 1
a529 5
	if ((EREAD(sc, port) & mask) == val)
		return (1);

	return (0);
}
d531 2
a532 7
int
esm_bmc_wait(struct esm_softc *sc, int port, u_int8_t mask, u_int8_t val)
{
	unsigned int		count;

	for (count = 0; count < 0xffffL; count++) {
		if (esm_bmc_ready(sc, port, mask, val))
d534 1
a534 1
	}
d541 1
a541 1
    size_t resplen)
d548 1
a548 1
	if (esm_bmc_wait(sc, ESM2_TC_REG, ESM2_TC_READY, 0) != 0)
d561 1
a561 2
	if (esm_bmc_wait(sc, ESM2_TC_REG, ESM2_TC_EC2HDB, ESM2_TC_EC2HDB) != 0)
		printf("post\n");
d583 1
a583 1
    struct esm_smb_resp *resp)
d588 1
a588 1
	    sizeof(resp->hdr) + req->h_rxlen) != 0)
@


1.4
log
@normalise the values read off the hw for the voltages
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.3 2005/11/21 22:07:49 deraadt Exp $ */
d55 2
d336 35
d446 10
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.2 2005/11/21 22:05:36 marco Exp $ */
d108 1
d202 3
d568 6
@


1.2
log
@Fix copyrights.

ok jordan@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: esm.c,v 1.1 2005/11/21 17:23:19 jordan Exp $ */
d515 1
a515 1
  
@


1.1
log
@Add support for ESM (Embedded Server Management) for Dell PowerEdge servers.

Lot's of work by dlg@@ ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d4 1
@

