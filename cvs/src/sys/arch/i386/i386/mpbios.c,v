head	1.40;
access;
symbols
	OPENBSD_6_2:1.40.0.2
	OPENBSD_6_2_BASE:1.40
	OPENBSD_6_1:1.40.0.4
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.39.0.2
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.38.0.4
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.34.0.12
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.8
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.6
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.4
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.2
	OPENBSD_5_0:1.33.0.8
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.6
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.4
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	UBC_SYNC_A:1.1
	UBC_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.40
date	2016.07.28.21.57.56;	author kettenis;	state Exp;
branches;
next	1.39;
commitid	h0GHFDGWnEdswfbK;

1.39
date	2016.04.21.22.13.27;	author mlarkin;	state Exp;
branches;
next	1.38;
commitid	B9qJFBLTuH1tAVKL;

1.38
date	2015.06.07.12.16.27;	author jsg;	state Exp;
branches;
next	1.37;
commitid	uN5YxxZFxaAxG5nD;

1.37
date	2014.12.09.06.58.28;	author doug;	state Exp;
branches;
next	1.36;
commitid	yWAxzpQP2PPpYlfT;

1.36
date	2014.11.16.12.30.57;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	yv0ECmCdICvq576h;

1.35
date	2014.05.26.19.03.28;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2011.10.21.18.16.13;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2009.08.13.13.24.48;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2009.04.19.18.02.57;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2009.01.13.19.38.44;	author grange;	state Exp;
branches;
next	1.30;

1.30
date	2009.01.13.13.53.50;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2008.12.29.08.29.35;	author form;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.26.17.09.52;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2008.12.22.18.01.46;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2008.10.05.16.57.36;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2008.09.16.20.02.47;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.07.15.00.19;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2007.04.24.13.00.59;	author tom;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.20.21.15.01;	author tom;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.23.21.17.18;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.29.20.03.19;	author dim;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.11.21.47.52;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2006.10.03.22.35.01;	author gwk;	state Exp;
branches;
next	1.16;

1.16
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.18.08.30.35;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.29.20.40.58;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.14.19.07.46;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.09.18.41.22;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.01.17.01.14;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.30.17.38.26;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.27.15.37.51;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.18.17.42.24;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.12.13.54.09;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.23.09.24.46;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.13.14.23.26;	author martin;	state Exp;
branches;
next	1.4;

1.4
date	2005.07.18.02.43.25;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.23.17.14.31;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.14.10.02.29;	author ho;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.07.14.10.02.29;	author ho;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.07.15.11.04.49;	author ho;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.07.15.11.43.59;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.07.15.15.10.55;	author ho;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2001.07.16.21.40.24;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2003.05.13.19.42.08;	author ho;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2004.03.14.22.08.20;	author niklas;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2004.06.09.15.45.08;	author deraadt;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2004.06.10.18.19.28;	author grange;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	2004.06.13.07.31.56;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Store the acpi processor ID/UID in struct cpu_info, and use it to attach
acpicpu(4) drivers to the right cpu(4).

ok mlarkin@@, guenther@@
@
text
@/*	$OpenBSD: mpbios.c,v 1.39 2016/04/21 22:13:27 mlarkin Exp $	*/
/*	$NetBSD: mpbios.c,v 1.2 2002/10/01 12:56:57 fvdl Exp $	*/

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1999 Stefan Grefen
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the NetBSD
 *      Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * Derived from FreeBSD's mp_machdep.c
 */
/*
 * Copyright (c) 1996, by Steve Passe
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the developer may NOT be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * The Intel MP-stuff is just one way of x86 SMP systems
 * so only Intel MP specific stuff is here.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>

#include <machine/specialreg.h>
#include <machine/cputypes.h>
#include <machine/cpuvar.h>
#include <machine/bus.h>
#include <machine/biosvar.h>
#include <machine/mpbiosreg.h>
#include <machine/mpbiosvar.h>

#include <machine/i82093reg.h>
#include <machine/i82093var.h>
#include <machine/i82489reg.h>
#include <machine/i82489var.h>

#include <dev/isa/isareg.h>
#include <dev/pci/pcivar.h>

#include <dev/eisa/eisavar.h>	/* for ELCR* def'ns */

#include "pci.h"

#include "apm.h"
#include "acpi.h"
#if NAPM > 0 && NACPI > 0
extern int haveacpibutusingapm;
#endif

/* descriptions of MP basetable entries */
struct mpbios_baseentry {
	u_int8_t  	type;
	u_int8_t  	length;
	u_int16_t	count;
	const char    	*name;
};

static const char *loc_where[] = {
	"extended bios data area",
	"last page of base memory",
	"bios"
};

struct mp_map
{
	vaddr_t 	baseva;
	int	 	vsize;
	paddr_t 	pa;
	paddr_t 	pg;
	int		psize;
};

int	mp_print(void *, const char *);
int	mp_match(struct device *, void *, void *);
int	mpbios_cpu_start(struct cpu_info *);
const void *mpbios_search(struct device *, paddr_t, int, struct mp_map *);
static __inline int mpbios_cksum(const void *, int);

void	mp_cfg_special_intr(const struct mpbios_int *, u_int32_t *);
void	mp_print_special_intr(int);

void	mp_cfg_pci_intr(const struct mpbios_int *, u_int32_t *);
void	mp_print_pci_intr(int);

void	mp_cfg_eisa_intr(const struct mpbios_int *, u_int32_t *);
void	mp_print_eisa_intr(int);

void	mp_cfg_isa_intr(const struct mpbios_int *, u_int32_t *);
void	mp_print_isa_intr(int);

void	mpbios_cpu(const u_int8_t *, struct device *);
void	mpbios_bus(const u_int8_t *, struct device *);
void	mpbios_ioapic(const u_int8_t *, struct device *);
int	mpbios_int(const u_int8_t *, struct mp_intr_map *);

const void *mpbios_map(paddr_t, int, struct mp_map *);
void	mpbios_unmap(struct mp_map *);

/*
 * globals to help us bounce our way through parsing the config table.
 */

static struct mp_map mp_cfg_table_map;
static struct mp_map mp_fp_map;
const struct mpbios_cth	*mp_cth;
const struct mpbios_fps	*mp_fps;

#ifdef MPVERBOSE
int mp_verbose = 1;
#else
int mp_verbose = 0;
#endif

int	mpbios_match(struct device *, void *, void *);
void	mpbios_attach(struct device *, struct device *, void *);

struct cfattach mpbios_ca = {
	sizeof(struct device), mpbios_match, mpbios_attach
};

struct cfdriver mpbios_cd = {
	NULL, "mpbios", DV_DULL
};

int
mpbios_match(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct bios_attach_args *bia = aux;

	if (strcmp(bia->ba_name, cf->cf_driver->cd_name) == 0)
		return (1);
	return (0);
}

void
mpbios_attach(struct device *parent, struct device *self, void *aux)
{
	mpbios_scan(self);
}

int
mp_print(void *aux, const char *pnp)
{
	struct cpu_attach_args *caa = aux;

	if (pnp)
		printf("%s at %s:", caa->caa_name, pnp);
	return (UNCONF);
}

int
mp_match(struct device *parent, void *cfv, void *aux)
{
	struct cfdata *cf = cfv;
	struct cpu_attach_args *caa = aux;

	if (strcmp(caa->caa_name, cf->cf_driver->cd_name))
		return 0;

	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
}

/*
 * Map a chunk of memory read-only and return an appropriately
 * const'ed pointer.
 */
const void *
mpbios_map(paddr_t pa, int len, struct mp_map *handle)
{
	paddr_t pgpa = trunc_page(pa);
	paddr_t endpa = round_page(pa + len);
	vaddr_t va = uvm_km_valloc(kernel_map, endpa - pgpa);
	vaddr_t retva = va + (pa & PGOFSET);

	handle->pa = pa;
	handle->pg = pgpa;
	handle->psize = len;
	handle->baseva = va;
	handle->vsize = endpa - pgpa;

	do {
		pmap_kenter_pa(va, pgpa, PROT_READ);
		va += PAGE_SIZE;
		pgpa += PAGE_SIZE;
	} while (pgpa < endpa);

	return ((const void *)retva);
}

void
mpbios_unmap(struct mp_map *handle)
{
	pmap_kremove(handle->baseva, handle->vsize);
	uvm_km_free(kernel_map, handle->baseva, handle->vsize);
}

/*
 * Look for an Intel MP spec table, indicating SMP capable hardware.
 */
int
mpbios_probe(struct device *self)
{
	paddr_t  	ebda, memtop;

	paddr_t		cthpa;
	int		cthlen;
	const u_int8_t	*mpbios_page;
	int 		scan_loc;

	struct		mp_map t;

#if NAPM > 0 && NACPI > 0
	/*
	 * If we have acpi but chose to use apm, then we really should
	 * not go use mpbios.  Systems with usable acpi typically have
	 * unuseable mpbios
	 */
	if (haveacpibutusingapm)
		return (0);
#endif

	/*
	 * Skip probe if someone else (e.g. acpi) already provided the
	 * necessary details.
	 */
	if (mp_busses)
		return (0);

	/* see if EBDA exists */

	mpbios_page = mpbios_map(0, PAGE_SIZE, &t);

	/* XXX Ugly magic constants below. */
	ebda = *(const u_int16_t *)(&mpbios_page[0x40e]);
	ebda <<= 4;

	memtop = *(const u_int16_t *)(&mpbios_page[0x413]);
	memtop <<= 10;

	mpbios_page = NULL;
	mpbios_unmap(&t);

	scan_loc = 0;

	if (ebda && ebda < IOM_BEGIN ) {
		mp_fps = mpbios_search(self, ebda, 1024, &mp_fp_map);
		if (mp_fps != NULL)
			goto found;
	}

	scan_loc = 1;

	if (memtop && memtop <= IOM_BEGIN ) {
		mp_fps = mpbios_search(self, memtop - 1024, 1024, &mp_fp_map);
		if (mp_fps != NULL)
			goto found;
	}

	scan_loc = 2;

	mp_fps = mpbios_search(self, BIOS_BASE, BIOS_COUNT, &mp_fp_map);
	if (mp_fps != NULL)
		goto found;

	/* nothing found */
	return (0);

 found:
	if (mp_verbose)
		printf("%s: MP floating pointer found in %s at 0x%lx\n",
		    self->dv_xname, loc_where[scan_loc], mp_fp_map.pa);

	if (mp_fps->pap == 0) {
		if (mp_fps->mpfb1 == 0)
			printf("%s: MP fps invalid: "
			    "no default config and no configuration table\n",
			    self->dv_xname);
		else
			printf("%s: MP default configuration %d not "
    			    "supported\n", self->dv_xname, mp_fps->mpfb1);
		goto err;
	}

	cthpa = mp_fps->pap;

	mp_cth = mpbios_map(cthpa, sizeof (*mp_cth), &mp_cfg_table_map);
	cthlen = mp_cth->base_len;
	mpbios_unmap(&mp_cfg_table_map);

	mp_cth = mpbios_map(cthpa, cthlen, &mp_cfg_table_map);

	if (mp_verbose)
		printf("%s: MP config table at 0x%lx, %d bytes long\n",
		    self->dv_xname, cthpa, cthlen);

	if (mp_cth->signature != MP_CT_SIG) {
		printf("%s: MP signature mismatch (%x vs %x)\n",
		    self->dv_xname,
		    MP_CT_SIG, mp_cth->signature);
		goto err;
	}

	if (mpbios_cksum(mp_cth, cthlen)) {
		printf ("%s: MP Configuration Table checksum mismatch\n",
		    self->dv_xname);
		goto err;
	}
	return (1);

 err:
	if (mp_fps) {
		mp_fps = NULL;
		mpbios_unmap(&mp_fp_map);
	}
	if (mp_cth) {
		mp_cth = NULL;
		mpbios_unmap(&mp_cfg_table_map);
	}
	return (0);
}


/*
 * Simple byte checksum used on config tables.
 */

static __inline int
mpbios_cksum(const void *start, int len)
{
	unsigned char res=0;
	const char *p = start;
	const char *end = p + len;

	while (p < end)
		res += *p++;

	return res;
}


/*
 * Look for the MP floating pointer signature in the given physical
 * address range.
 *
 * We map the memory, scan through it, and unmap it.
 * If we find it, remap the floating pointer structure and return it.
 */

const void *
mpbios_search(struct device *self, paddr_t start, int count, struct mp_map *map)
{
	struct mp_map t;

	int i, len;
	const struct mpbios_fps *m;
	int end = count - sizeof(*m);
	const u_int8_t *base = mpbios_map(start, count, &t);

	if (mp_verbose)
		printf("%s: scanning 0x%lx to 0x%lx for MP signature\n",
		    self->dv_xname, start, start + count - sizeof(*m));

	for (i = 0; i <= end; i += 4) {
		m = (struct mpbios_fps *)&base[i];

		if ((m->signature == MP_FP_SIG) &&
		    ((len = m->length << 4) != 0) &&
		    mpbios_cksum(m, (m->length << 4)) == 0) {
			mpbios_unmap(&t);

			return (mpbios_map(start + i, len, map));
		}
	}
	mpbios_unmap(&t);

	return (0);
}

/*
 * MP configuration table parsing.
 */

static struct mpbios_baseentry mp_conf[] =
{
	{0, 20, 0, "cpu"},
	{1, 8, 0, "bus"},
	{2, 8, 0, "ioapic"},
	{3, 8, 0, "ioint"},
	{4, 8, 0, "lint"},
};

struct mp_bus *mp_busses;
int mp_nbusses;
struct mp_intr_map *mp_intrs;
int mp_nintrs;

struct mp_bus *mp_isa_bus;
struct mp_bus *mp_eisa_bus;

static struct mp_bus extint_bus = {
	"ExtINT",
	-1,
	mp_print_special_intr,
	mp_cfg_special_intr,
	0
};
static struct mp_bus smi_bus = {
	"SMI",
	-1,
	mp_print_special_intr,
	mp_cfg_special_intr,
	0
};
static struct mp_bus nmi_bus = {
	"NMI",
	-1,
	mp_print_special_intr,
	mp_cfg_special_intr,
	0
};


/*
 * 1st pass on BIOS's Intel MP specification table.
 *
 * initializes:
 *	mp_ncpus = 1
 *
 * determines:
 *	cpu_apic_address (common to all CPUs)
 *	ioapic_address[N]
 *	mp_naps
 *	mp_nbusses
 *	mp_napics
 *	nintrs
 */
void
mpbios_scan(struct device *self)
{
	const u_int8_t 	*position, *end;
	int		count;
	int		type;
	int		intr_cnt;
	paddr_t		lapic_base;

	printf(": Intel MP Specification 1.%d\n", mp_fps->spec_rev);

	/*
	 * looks like we've got a MP system.  start setting up
	 * infrastructure..
	 * XXX is this the right place??
	 */

	lapic_base = LAPIC_BASE;
	if (mp_cth != NULL)
		lapic_base = (paddr_t)mp_cth->apic_address;

	lapic_boot_init(lapic_base);

	/*
	 * Walk the table once, counting items
	 */
	for (count = mp_cth->entry_count,
	    position = (const u_int8_t *)mp_cth + sizeof(*mp_cth),
	    end = position + mp_cth->base_len;
	    count-- && position < end;
	    position += mp_conf[type].length) {

		type = *position;
		if (type >= MPS_MCT_NTYPES) {
			printf("%s: unknown entry type %x"
			    " in MP config table\n",
			    self->dv_xname, type);
			end = position;
			break;
		}
		mp_conf[type].count++;
	}

	/*
	 * Walk the table twice, counting int and bus entries
	 */
	for (count = mp_cth->entry_count,
	    intr_cnt = 15,	/* presume all isa irqs missing */
	    position = (const u_int8_t *)mp_cth + sizeof(*mp_cth);
	    count-- && position < end;
	    position += mp_conf[type].length) {
		type = *position;
		if (type == MPS_MCT_BUS) {
			const struct mpbios_bus *bp =
			    (const struct mpbios_bus *)position;
			if (bp->bus_id >= mp_nbusses)
				mp_nbusses = bp->bus_id + 1;
		}

		/*
		 * Count actual interrupt instances.
		 * dst_apic_id of MPS_ALL_APICS means "wired to all
		 * apics of this type".
		 */
		if ((type == MPS_MCT_IOINT) ||
		    (type == MPS_MCT_LINT)) {
			const struct mpbios_int *ie =
			    (const struct mpbios_int *)position;
			if (ie->dst_apic_id != MPS_ALL_APICS)
				intr_cnt++;
			else if (type == MPS_MCT_IOINT)
				intr_cnt +=
				    mp_conf[MPS_MCT_IOAPIC].count;
			else
				intr_cnt += mp_conf[MPS_MCT_CPU].count;
		}
	}

	mp_busses = mallocarray(mp_nbusses, sizeof(struct mp_bus),
	    M_DEVBUF, M_NOWAIT|M_ZERO);
	mp_intrs = mallocarray(intr_cnt, sizeof(struct mp_intr_map),
	    M_DEVBUF, M_NOWAIT);

	/* re-walk the table, recording info of interest */
	position = (const u_int8_t *)mp_cth + sizeof(*mp_cth);
	count = mp_cth->entry_count;
	mp_nintrs = 0;

	while ((count--) && (position < end)) {
		switch (type = *(u_char *)position) {
		case MPS_MCT_CPU:
			mpbios_cpu(position, self);
			break;
		case MPS_MCT_BUS:
			mpbios_bus(position, self);
			break;
		case MPS_MCT_IOAPIC:
			mpbios_ioapic(position, self);
			break;
		case MPS_MCT_IOINT:
		case MPS_MCT_LINT:
			if (mpbios_int(position,
			    &mp_intrs[mp_nintrs]) == 0)
				mp_nintrs++;
			break;
		default:
			printf("%s: unknown entry type %x "
			    "in MP config table\n",
			    self->dv_xname, type);
			/* NOTREACHED */
			return;
		}

		position += mp_conf[type].length;
	}
	if (mp_verbose && mp_cth->ext_len)
		printf("%s: MP WARNING: %d "
		    "bytes of extended entries not examined\n",
		    self->dv_xname, mp_cth->ext_len);

	/* Clean up. */
	mp_fps = NULL;
	mpbios_unmap(&mp_fp_map);
	if (mp_cth != NULL) {
		mp_cth = NULL;
		mpbios_unmap(&mp_cfg_table_map);
	}

#if NPCI > 0
	if (pci_mode_detect() != 0)
		mpbios_intr_fixup();
#endif
}

int
mpbios_invent(int irq, int type, int bus)
{
	struct mp_intr_map *mip;
	struct mpbios_int e;

	e.type = MPS_MCT_IOINT;
	e.int_type = MPS_INTTYPE_INT;
	switch (type) {
	case IST_EDGE:
		e.int_flags = MPS_INT(MPS_INTPO_ACTHI, MPS_INTTR_EDGE);
		break;

	case IST_LEVEL:
		e.int_flags = MPS_INT(MPS_INTPO_ACTLO, MPS_INTTR_LEVEL);
		break;

	case IST_NONE:
	case IST_PULSE:
		e.int_flags = MPS_INT(MPS_INTPO_DEF, MPS_INTTR_DEF);
		break;
	}
	e.src_bus_id = bus;
	e.src_bus_irq = irq;
	e.dst_apic_id = mp_busses[bus].mb_intrs->ioapic->sc_apicid;
	e.dst_apic_int = irq;

	if (mpbios_int((const u_int8_t *)&e, &mp_intrs[mp_nintrs]) == 0) {
		mip = &mp_intrs[mp_nintrs++];
		return (mip->ioapic_ih | irq);
	}

	return irq;
}

void
mpbios_cpu(const u_int8_t *ent, struct device *self)
{
	const struct mpbios_proc *entry = (const struct mpbios_proc *)ent;
	struct device *mainbus = self->dv_parent->dv_parent;
	struct cpu_attach_args caa;

	/* XXX move this into the CPU attachment goo. */
	/* check for usability */
	if (!(entry->cpu_flags & PROCENTRY_FLAG_EN))
		return;

	/* check for BSP flag */
	if (entry->cpu_flags & PROCENTRY_FLAG_BP)
		caa.cpu_role = CPU_ROLE_BP;
	else {
		caa.cpu_role = CPU_ROLE_AP;
		ncpusfound++;
	}

	caa.caa_name = "cpu";
	caa.cpu_apicid = entry->apic_id;
#ifdef MULTIPROCESSOR
	caa.cpu_func = &mp_cpu_funcs;
#endif
#if 1 /* XXX Will be removed when the real stuff is probed */
	caa.cpu_signature = entry->cpu_signature;

	/*
	 * XXX this is truncated to just contain the low-order 16 bits
	 * of the flags on at least some MP bioses
	 */
	caa.feature_flags = entry->feature_flags;

	/*
	 * XXX some MP bioses don't specify a valid CPU signature; use
	 * the result of the 'cpuid' instruction for the processor
	 * we're running on
	 */
	if ((caa.cpu_signature & 0x00000fff) == 0) {
		caa.cpu_signature = cpu_id;
		caa.feature_flags = cpu_feature;
	}
#endif

	config_found_sm(mainbus, &caa, mp_print, mp_match);
}

/*
 * The following functions conspire to compute base ioapic redirection
 * table entry for a given interrupt line.
 *
 * Fill in: trigger mode, polarity, and possibly delivery mode.
 */
void
mp_cfg_special_intr(const struct mpbios_int *entry, u_int32_t *redir)
{

	/*
	 * All of these require edge triggered, zero vector,
	 * appropriate delivery mode.
	 * see page 13 of the 82093AA datasheet.
	 */
	*redir &= ~IOAPIC_REDLO_DEL_MASK;
	*redir &= ~IOAPIC_REDLO_VECTOR_MASK;
	*redir &= ~IOAPIC_REDLO_LEVEL;

	switch (entry->int_type) {
	case MPS_INTTYPE_NMI:
		*redir |= (IOAPIC_REDLO_DEL_NMI<<IOAPIC_REDLO_DEL_SHIFT);
		break;

	case MPS_INTTYPE_SMI:
		*redir |= (IOAPIC_REDLO_DEL_SMI<<IOAPIC_REDLO_DEL_SHIFT);
		break;
	case MPS_INTTYPE_ExtINT:
		/*
		 * We are using the ioapic in "native" mode.
		 * This indicates where the 8259 is wired to the ioapic
		 * and/or local apic..
		 */
		*redir |= (IOAPIC_REDLO_DEL_EXTINT<<IOAPIC_REDLO_DEL_SHIFT);
		*redir |= (IOAPIC_REDLO_MASK);
		break;
	default:
		panic("unknown MPS interrupt type %d", entry->int_type);
	}
}

/* XXX too much duplicated code here. */

void
mp_cfg_pci_intr(const struct mpbios_int *entry, u_int32_t *redir)
{
	int mpspo = (entry->int_flags >> MPS_INTPO_SHIFT) & MPS_INTPO_MASK;
	int mpstrig = (entry->int_flags >> MPS_INTTR_SHIFT) & MPS_INTTR_MASK;

	*redir &= ~IOAPIC_REDLO_DEL_MASK;
	switch (mpspo) {
	case MPS_INTPO_ACTHI:
		*redir &= ~IOAPIC_REDLO_ACTLO;
		break;
	case MPS_INTPO_DEF:
	case MPS_INTPO_ACTLO:
		*redir |= IOAPIC_REDLO_ACTLO;
		break;
	default:
		panic("unknown MPS interrupt polarity %d", mpspo);
	}

	if (entry->int_type != MPS_INTTYPE_INT) {
		mp_cfg_special_intr(entry, redir);
		return;
	}
	*redir |= (IOAPIC_REDLO_DEL_LOPRI<<IOAPIC_REDLO_DEL_SHIFT);

	switch (mpstrig) {
	case MPS_INTTR_DEF:
	case MPS_INTTR_LEVEL:
		*redir |= IOAPIC_REDLO_LEVEL;
		break;
	case MPS_INTTR_EDGE:
		*redir &= ~IOAPIC_REDLO_LEVEL;
		break;
	default:
		panic("unknown MPS interrupt trigger %d", mpstrig);
	}
}

void
mp_cfg_eisa_intr(const struct mpbios_int *entry, u_int32_t *redir)
{
	int mpspo = (entry->int_flags >> MPS_INTPO_SHIFT) & MPS_INTPO_MASK;
	int mpstrig = (entry->int_flags >> MPS_INTTR_SHIFT) & MPS_INTTR_MASK;

	*redir &= ~IOAPIC_REDLO_DEL_MASK;
	switch (mpspo) {
	case MPS_INTPO_DEF:
	case MPS_INTPO_ACTHI:
		*redir &= ~IOAPIC_REDLO_ACTLO;
		break;
	case MPS_INTPO_ACTLO:
		*redir |= IOAPIC_REDLO_ACTLO;
		break;
	default:
		panic("unknown MPS interrupt polarity %d", mpspo);
	}

	if (entry->int_type != MPS_INTTYPE_INT) {
		mp_cfg_special_intr(entry, redir);
		return;
	}
	*redir |= (IOAPIC_REDLO_DEL_LOPRI<<IOAPIC_REDLO_DEL_SHIFT);

	switch (mpstrig) {
	case MPS_INTTR_LEVEL:
		*redir |= IOAPIC_REDLO_LEVEL;
		break;
	case MPS_INTTR_EDGE:
		*redir &= ~IOAPIC_REDLO_LEVEL;
		break;
	case MPS_INTTR_DEF:
		/*
		 * Set "default" setting based on ELCR value snagged
		 * earlier.
		 */
		if (mp_busses[entry->src_bus_id].mb_data &
		    (1<<entry->src_bus_irq)) {
			*redir |= IOAPIC_REDLO_LEVEL;
		} else {
			*redir &= ~IOAPIC_REDLO_LEVEL;
		}
		break;
	default:
		panic("unknown MPS interrupt trigger %d", mpstrig);
	}
}


void
mp_cfg_isa_intr(const struct mpbios_int *entry, u_int32_t *redir)
{
	int mpspo = (entry->int_flags >> MPS_INTPO_SHIFT) & MPS_INTPO_MASK;
	int mpstrig = (entry->int_flags >> MPS_INTTR_SHIFT) & MPS_INTTR_MASK;

	*redir &= ~IOAPIC_REDLO_DEL_MASK;
	switch (mpspo) {
	case MPS_INTPO_DEF:
	case MPS_INTPO_ACTHI:
		*redir &= ~IOAPIC_REDLO_ACTLO;
		break;
	case MPS_INTPO_ACTLO:
		*redir |= IOAPIC_REDLO_ACTLO;
		break;
	default:
		panic("unknown MPS interrupt polarity %d", mpspo);
	}

	if (entry->int_type != MPS_INTTYPE_INT) {
		mp_cfg_special_intr(entry, redir);
		return;
	}
	*redir |= (IOAPIC_REDLO_DEL_LOPRI << IOAPIC_REDLO_DEL_SHIFT);

	switch (mpstrig) {
	case MPS_INTTR_LEVEL:
		*redir |= IOAPIC_REDLO_LEVEL;
		break;
	case MPS_INTTR_DEF:
	case MPS_INTTR_EDGE:
		*redir &= ~IOAPIC_REDLO_LEVEL;
		break;
	default:
		panic("unknown MPS interrupt trigger %d", mpstrig);
	}
}


void
mp_print_special_intr(int intr)
{
}

void
mp_print_pci_intr(int intr)
{
	printf(" device %d INT_%c", (intr >> 2) & 0x1f, 'A' + (intr & 0x3));
}

void
mp_print_isa_intr(int intr)
{
	printf(" irq %d", intr);
}

void
mp_print_eisa_intr(int intr)
{
	printf(" EISA irq %d", intr);
}



#define TAB_UNIT	4
#define TAB_ROUND(a)	_TAB_ROUND(a, TAB_UNIT)

#define _TAB_ROUND(a,u)	(((a) + (u - 1)) & ~(u - 1))
#define EXTEND_TAB(a,u)	(!(_TAB_ROUND(a, u) == _TAB_ROUND((a + 1), u)))

void
mpbios_bus(const u_int8_t *ent, struct device *self)
{
	const struct mpbios_bus *entry = (const struct mpbios_bus *)ent;
	int bus_id = entry->bus_id;

	printf("%s: bus %d is type %6.6s\n", self->dv_xname,
	    bus_id, entry->bus_type);

#ifdef DIAGNOSTIC
	/*
	 * This "should not happen" unless the table changes out
	 * from underneath us
	 */
	if (bus_id >= mp_nbusses) {
		panic("%s: bus number %d out of range?? (type %6.6s)",
		    self->dv_xname, bus_id, entry->bus_type);
	}
#endif

	mp_busses[bus_id].mb_intrs = NULL;

	if (memcmp(entry->bus_type, "PCI   ", 6) == 0) {
		mp_busses[bus_id].mb_name = "pci";
		mp_busses[bus_id].mb_idx = bus_id;
		mp_busses[bus_id].mb_intr_print = mp_print_pci_intr;
		mp_busses[bus_id].mb_intr_cfg = mp_cfg_pci_intr;
	} else if (memcmp(entry->bus_type, "EISA  ", 6) == 0) {
		mp_busses[bus_id].mb_name = "eisa";
		mp_busses[bus_id].mb_idx = bus_id;
		mp_busses[bus_id].mb_intr_print = mp_print_eisa_intr;
		mp_busses[bus_id].mb_intr_cfg = mp_cfg_eisa_intr;

		mp_busses[bus_id].mb_data = inb(ELCR0) | (inb(ELCR1) << 8);

		if (mp_eisa_bus)
			printf("%s: multiple eisa busses?\n",
			    self->dv_xname);
		else
			mp_eisa_bus = &mp_busses[bus_id];
	} else if (memcmp(entry->bus_type, "ISA   ", 6) == 0) {
		mp_busses[bus_id].mb_name = "isa";
		mp_busses[bus_id].mb_idx = bus_id;
		mp_busses[bus_id].mb_intr_print = mp_print_isa_intr;
		mp_busses[bus_id].mb_intr_cfg = mp_cfg_isa_intr;
		if (mp_isa_bus)
			printf("%s: multiple isa busses?\n",
			    self->dv_xname);
		else
			mp_isa_bus = &mp_busses[bus_id];
	} else {
		printf("%s: unsupported bus type %6.6s\n", self->dv_xname,
		    entry->bus_type);
	}
}


void
mpbios_ioapic(const u_int8_t *ent, struct device *self)
{
	const struct mpbios_ioapic *entry = (const struct mpbios_ioapic *)ent;
	struct device *mainbus = self->dv_parent->dv_parent;
	struct apic_attach_args aaa;

	/* XXX let flags checking happen in ioapic driver.. */
	if (!(entry->apic_flags & IOAPICENTRY_FLAG_EN))
		return;

	aaa.aaa_name = "ioapic";
	aaa.apic_id = entry->apic_id;
	aaa.apic_version = entry->apic_version;
	aaa.apic_address = (u_int32_t)entry->apic_address;
	aaa.apic_vecbase = -1;
	aaa.flags = (mp_fps->mpfb2 & 0x80) ? IOAPIC_PICMODE : IOAPIC_VWIRE;

	config_found_sm(mainbus, &aaa, mp_print, mp_match);
}

int
mpbios_int(const u_int8_t *ent, struct mp_intr_map *mpi)
{
	const struct mpbios_int *entry = (const struct mpbios_int *)ent;
	struct mpbios_int rw_entry = *entry;
	struct ioapic_softc *sc = NULL, *sc2;

	struct mp_intr_map *altmpi;
	struct mp_bus *mpb;

	u_int32_t id = entry->dst_apic_id;
	u_int32_t pin = entry->dst_apic_int;
	u_int32_t bus = entry->src_bus_id;
	u_int32_t dev = entry->src_bus_irq;
	u_int32_t type = entry->int_type;
	u_int32_t flags = entry->int_flags;

	rw_entry.dst_apic_id = id;

	switch (type) {
	case MPS_INTTYPE_INT:
		mpb = &(mp_busses[bus]);
		break;
	case MPS_INTTYPE_ExtINT:
		mpb = &extint_bus;
		break;
	case MPS_INTTYPE_SMI:
		mpb = &smi_bus;
		break;
	case MPS_INTTYPE_NMI:
		mpb = &nmi_bus;
		break;
	default:
		panic("unknown MPS interrupt type %d", entry->int_type);
	}
	mpi->bus = mpb;
	mpi->bus_pin = dev;

	mpi->ioapic_ih = APIC_INT_VIA_APIC |
	    ((id << APIC_INT_APIC_SHIFT) | ((pin << APIC_INT_PIN_SHIFT)));

	mpi->type = type;
	mpi->flags = flags;
	mpi->redir = 0;
	if (mpb->mb_intr_cfg == NULL) {
		printf("mpbios: can't find bus %d for apic %d pin %d\n",
		    bus, id, pin);
		return (1);
	}

	(*mpb->mb_intr_cfg)(&rw_entry, &mpi->redir);

	if (entry->type == MPS_MCT_IOINT) {
		sc = ioapic_find(id);
		if (sc == NULL) {
			printf("mpbios: can't find ioapic %d\n", id);
			return (1);
		}

		/*
		 * XXX workaround for broken BIOSs that put the ACPI
		 * global interrupt number in the entry, not the pin
		 * number.
		 */
		if (pin >= sc->sc_apic_sz) {
			sc2 = ioapic_find_bybase(pin);
			if (sc2 != sc) {
				printf("mpbios: bad pin %d for apic %d\n",
				    pin, id);
				return (1);
			}
			printf("mpbios: WARNING: pin %d for apic %d too high; "
			       "assuming ACPI global int value\n", pin, id);
			pin -= sc->sc_apic_vecbase;
		}

		mpi->ioapic = sc;
		mpi->ioapic_pin = pin;

		altmpi = sc->sc_pins[pin].ip_map;

		if (altmpi != NULL) {
			if ((altmpi->type != type) ||
			    (altmpi->flags != flags)) {
				printf(
				    "%s: conflicting map entries for pin %d\n",
				    sc->sc_pic.pic_dev.dv_xname, pin);
			}
		} else {
			sc->sc_pins[pin].ip_map = mpi;
		}
	} else {
		if (pin >= 2)
			printf("pin %d of local apic doesn't exist!\n", pin);
		else {
			mpi->ioapic = NULL;
			mpi->ioapic_pin = pin;
			mpi->cpu_id = id;
		}
	}

	if (mp_verbose) {
		printf("%s: int%d attached to %s",
		    sc ? sc->sc_pic.pic_dev.dv_xname : "local apic", pin,
		    mpb->mb_name);
		if (mpb->mb_idx != -1)
			printf("%d", mpb->mb_idx);

		(*(mpb->mb_intr_print))(dev);

		printf(" (type 0x%x flags 0x%x)\n", type, flags);
	}

	mpi->next = mpb->mb_intrs;
	mpb->mb_intrs = mpi;

	return (0);
}
@


1.39
log
@
Support for 'default configuration' mpbios attachment was never completed,
so instead of halfway configuring this mode and unconditionally panicing,
just don't attach mpbios at all if this mode is detected during probe.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.38 2015/06/07 12:16:27 jsg Exp $	*/
d711 1
a711 1
	caa.cpu_number = entry->apic_id;
@


1.38
log
@Add a default panic case to a switch statement where code after assumes
one of the cases was reached.  Matches other parts of the mpbios code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.37 2014/12/09 06:58:28 doug Exp $	*/
a132 4
static struct mpbios_ioapic default_ioapic = {
    2, 0, 1, IOAPICENTRY_FLAG_EN, (caddr_t)IOAPIC_BASE_DEFAULT
};

d358 1
a358 1
		if (mp_fps->mpfb1 == 0) {
d362 4
a365 6

			goto err;
		}
		printf("%s: MP default configuration %d\n",
		    self->dv_xname, mp_fps->mpfb1);
		return (10);
d392 1
a392 1
	return (10);
d544 19
a562 3
	/* check for use of 'default' configuration */
	if (mp_fps->mpfb1 != 0) {
		struct mpbios_proc pe;
d564 15
a578 8
		printf("%s: MP default configuration %d\n",
		    self->dv_xname, mp_fps->mpfb1);

		/* use default addresses */
		pe.apic_id = cpu_number();
		pe.cpu_flags = PROCENTRY_FLAG_EN|PROCENTRY_FLAG_BP;
		pe.cpu_signature = cpu_info_primary.ci_signature;
		pe.feature_flags = cpu_info_primary.ci_feature_flags;
a579 15
		mpbios_cpu((u_int8_t *)&pe, self);

		pe.apic_id = 1 - cpu_number();
		pe.cpu_flags = PROCENTRY_FLAG_EN;

		mpbios_cpu((u_int8_t *)&pe, self);

		mpbios_ioapic((u_int8_t *)&default_ioapic, self);

		/* XXX */
		printf("%s: WARNING: interrupts not configured\n",
		    self->dv_xname);
		panic("lazy bum");
		return;
	} else {
d581 3
a583 2
		 * should not happen; mp_probe returns 0 in this case,
		 * but..
d585 11
a595 21
		if (mp_cth == NULL)
			panic("mpbios_scan: no config (can't happen?)");

		/*
		 * Walk the table once, counting items
		 */
		for (count = mp_cth->entry_count,
		    position = (const u_int8_t *)mp_cth + sizeof(*mp_cth),
		    end = position + mp_cth->base_len;
		    count-- && position < end;
		    position += mp_conf[type].length) {

			type = *position;
			if (type >= MPS_MCT_NTYPES) {
				printf("%s: unknown entry type %x"
				    " in MP config table\n",
				    self->dv_xname, type);
				end = position;
				break;
			}
			mp_conf[type].count++;
d597 1
d599 33
a631 33
		/*
		 * Walk the table twice, counting int and bus entries
		 */
		for (count = mp_cth->entry_count,
		    intr_cnt = 15,	/* presume all isa irqs missing */
		    position = (const u_int8_t *)mp_cth + sizeof(*mp_cth);
		    count-- && position < end;
		    position += mp_conf[type].length) {
			type = *position;
			if (type == MPS_MCT_BUS) {
				const struct mpbios_bus *bp =
				    (const struct mpbios_bus *)position;
				if (bp->bus_id >= mp_nbusses)
					mp_nbusses = bp->bus_id + 1;
			}

			/*
			 * Count actual interrupt instances.
			 * dst_apic_id of MPS_ALL_APICS means "wired to all
			 * apics of this type".
			 */
			if ((type == MPS_MCT_IOINT) ||
			    (type == MPS_MCT_LINT)) {
				const struct mpbios_int *ie =
				    (const struct mpbios_int *)position;
				if (ie->dst_apic_id != MPS_ALL_APICS)
					intr_cnt++;
				else if (type == MPS_MCT_IOINT)
					intr_cnt +=
					    mp_conf[MPS_MCT_IOAPIC].count;
				else
					intr_cnt += mp_conf[MPS_MCT_CPU].count;
			}
d634 1
a634 41
		mp_busses = mallocarray(mp_nbusses, sizeof(struct mp_bus),
		    M_DEVBUF, M_NOWAIT|M_ZERO);
		mp_intrs = mallocarray(intr_cnt, sizeof(struct mp_intr_map),
		    M_DEVBUF, M_NOWAIT);

		/* re-walk the table, recording info of interest */
		position = (const u_int8_t *)mp_cth + sizeof(*mp_cth);
		count = mp_cth->entry_count;
		mp_nintrs = 0;

		while ((count--) && (position < end)) {
			switch (type = *(u_char *)position) {
			case MPS_MCT_CPU:
				mpbios_cpu(position, self);
				break;
			case MPS_MCT_BUS:
				mpbios_bus(position, self);
				break;
			case MPS_MCT_IOAPIC:
				mpbios_ioapic(position, self);
				break;
			case MPS_MCT_IOINT:
			case MPS_MCT_LINT:
				if (mpbios_int(position,
				    &mp_intrs[mp_nintrs]) == 0)
					mp_nintrs++;
				break;
			default:
				printf("%s: unknown entry type %x "
				    "in MP config table\n",
				    self->dv_xname, type);
				/* NOTREACHED */
				return;
			}

			position += mp_conf[type].length;
		}
		if (mp_verbose && mp_cth->ext_len)
			printf("%s: MP WARNING: %d "
			    "bytes of extended entries not examined\n",
			    self->dv_xname, mp_cth->ext_len);
d636 4
@


1.37
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.36 2014/11/16 12:30:57 deraadt Exp $	*/
d1091 2
@


1.36
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.35 2014/05/26 19:03:28 kettenis Exp $	*/
d640 1
a640 1
		mp_busses = malloc(sizeof(struct mp_bus) * mp_nbusses,
d642 1
a642 1
		mp_intrs = malloc(sizeof(struct mp_intr_map) * intr_cnt,
@


1.35
log
@Replace some magic constants with appropriate defines.

ok krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.34 2011/10/21 18:16:13 kettenis Exp $	*/
d270 1
a270 1
		pmap_kenter_pa(va, pgpa, VM_PROT_READ);
@


1.34
log
@Add bounds checks for access to mp_busses.  Also make sure that we don't
accidentally use ISA or EISA interrupt mappings on PCI busses.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.33 2009/08/13 13:24:48 kettenis Exp $	*/
d826 2
a827 2
	int mpspo = entry->int_flags & 0x03; /* XXX magic */
	int mpstrig = (entry->int_flags >> 2) & 0x03; /* XXX magic */
d864 2
a865 2
	int mpspo = entry->int_flags & 0x03; /* XXX magic */
	int mpstrig = (entry->int_flags >> 2) & 0x03; /* XXX magic */
d914 2
a915 2
	int mpspo = entry->int_flags & 0x03; /* XXX magic */
	int mpstrig = (entry->int_flags >> 2) & 0x03; /* XXX magic */
@


1.33
log
@Make the i386 APIC code closer to the amd64 version.  Many whitespace fixes,
some additional code.

ok toby@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.32 2009/04/19 18:02:57 deraadt Exp $	*/
d483 1
a483 1
int mp_nbus;
d617 2
a618 2
				if (bp->bus_id >= mp_nbus)
					mp_nbus = bp->bus_id + 1;
d640 1
a640 1
		mp_busses = malloc(sizeof(struct mp_bus) * mp_nbus,
d995 1
a995 1
	if (bus_id >= mp_nbus) {
@


1.32
log
@Count number of cpus found (potentially not attached) and store that
in sysctl hw.ncpufound; ok miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.31 2009/01/13 19:38:44 grange Exp $	*/
d1143 1
a1143 1
				    sc->sc_dev.dv_xname, pin);
d1160 1
a1160 1
		    sc ? sc->sc_dev.dv_xname : "local apic", pin,
@


1.31
log
@Fix lvalue abuse by removing a redundant cast.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.30 2009/01/13 13:53:50 kettenis Exp $	*/
d747 1
a747 1
	else
d749 2
@


1.30
log
@Turn mpbios into a real device, such that people can disable it on crappy
BIOSes.

ok deraadt@@ (for the amd64 bit, or the i386 bit, can't remember which)
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.29 2008/12/29 08:29:35 form Exp $	*/
d675 1
a675 1
			(u_char*)position += mp_conf[type].length;
@


1.29
log
@fix compiling w/o apm(4)
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.28 2008/12/26 17:09:52 deraadt Exp $	*/
d111 1
d201 28
d536 1
a536 12
	printf("%s: Intel MP Specification ", self->dv_xname);

	switch (mp_fps->spec_rev) {
	case 1:
		printf("(Version 1.1)\n");
		break;
	case 4:
		printf("(Version 1.4)\n");
		break;
	default:
		printf("(unrecognized rev %d)\n", mp_fps->spec_rev);
	}
d554 1
a554 1
		printf("\n%s: MP default configuration %d\n",
d736 1
d775 1
a775 1
	config_found_sm(self, &caa, mp_print, mp_match);
d1040 1
d1054 1
a1054 1
	config_found_sm(self, &aaa, mp_print, mp_match);
@


1.28
log
@If we have usable acpi, but chose to use amp instead for various reasons,
then mpbios should not be used because it is probably full of lies.
ok kettenis, though he hates the variable name used.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.27 2008/12/22 18:01:46 kettenis Exp $	*/
d271 1
d279 1
@


1.27
log
@Get rid of many arbitrary differences between the i386 and amd64 mpbios code.
Mostly KNF issues, some reorganisation of the code.

ok dlg@@, deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.26 2008/10/05 16:57:36 kettenis Exp $	*/
d126 5
d270 8
@


1.26
log
@Remove IOAPIC ID remapping code.  It should not be necessary to avoid reusing
LAPIC IDs and if there are MPBIOSes we handle them with ACPI now.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.25 2008/09/16 20:02:47 brad Exp $	*/
a98 2
#include "mpbios.h"

d157 1
a157 2
const void *mpbios_search(struct device *, paddr_t, int,
    struct mp_map *);
d161 2
d164 2
d167 2
d170 1
a170 4
void	mp_print_special_intr (int);
void	mp_print_pci_intr (int);
void	mp_print_eisa_intr (int);
void	mp_print_isa_intr (int);
d178 1
a178 1
static __inline void mpbios_unmap(struct mp_map *);
d198 2
a199 1
	struct cpu_attach_args * caa = (struct cpu_attach_args *) aux;
d208 3
a210 2
        struct cfdata *cf = (struct cfdata *)cfv;
	struct cpu_attach_args * caa = (struct cpu_attach_args *) aux;
d233 1
a233 1
	handle->vsize = endpa-pgpa;
a235 1
#if 1
d237 2
a238 6
#else
		pmap_enter(pmap_kernel(), va, pgpa, VM_PROT_READ, TRUE,
		    VM_PROT_READ);
#endif
		va += NBPG;
		pgpa += NBPG;
d244 1
a244 1
static __inline void
d247 1
a247 5
#if 1
  	pmap_kremove(handle->baseva, handle->vsize);
#else
  	pmap_extract(pmap_kernel(), handle->baseva, NULL);
#endif
d275 1
a275 1
	mpbios_page = mpbios_map(0, NBPG, &t);
d649 1
d826 1
a826 1
mp_cfg_eisa_intr (const struct mpbios_int *entry, u_int32_t *redir)
@


1.25
log
@Make this compile if !MULTIPROCESSOR.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.24 2008/06/26 05:42:10 ray Exp $	*/
d1038 1
a1038 1
	u_int32_t id = IOAPIC_REMAPPED_ID(entry->dst_apic_id);
@


1.24
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.23 2007/09/07 15:00:19 art Exp $	*/
d724 1
d726 1
@


1.23
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.22 2007/04/24 13:00:59 tom Exp $	*/
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.22
log
@apic_address should be 32 bits, rather than paddr_t; prepares us for
paddr_t changing from 32 bits.

From mickey's original PAE work of a year ago

Tested by myself and nick@@; ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.21 2007/02/20 21:15:01 tom Exp $	*/
d622 1
a622 2
		    M_DEVBUF, M_NOWAIT);
		memset(mp_busses, 0, sizeof(struct mp_bus) * mp_nbus);
@


1.21
log
@Revert PAE pmap for now, until the strange bug is found.  This stops
the freezes many of us are seeing (especially on amd64 machines running
OpenBSD/i386).

Much testing by nick@@ (as always - thanks!), hugh@@, ian@@, kettenis@@
and Sam Smith (s (at) msmith (dot) net).

Requested by, input from, and ok deraadt@@  ok art@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.20 2007/01/23 21:17:18 kettenis Exp $	*/
d1027 1
a1027 1
	aaa.apic_address = (paddr_t)entry->apic_address;
@


1.20
log
@Handle not-all-lapics intterupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.19 2006/11/29 20:03:19 dim Exp $	*/
d1027 1
a1027 1
	aaa.apic_address = (u_long)entry->apic_address;
@


1.19
log
@Remove all the extern cpu_{id,model,whatever} declarations from most
stuff in arch/i386/i386.  This should prevent more screwups like the
one I did before in ichpcib.c...

ok dlg@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.18 2006/11/11 21:47:52 kettenis Exp $	*/
a456 1
struct mp_intr_map *lapic_ints[2]; /* XXX */
a1123 2
		if (id != MPS_ALL_APICS)
			panic("can't deal with not-all-lapics interrupt yet!");
d1129 1
a1129 1
			lapic_ints[pin] = mpi;
@


1.18
log
@Get rid of magic isa and eisa bus numbers in mpbios code.  Pave the way for
alternative sources for interrupt information.

ok gwk@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.17 2006/10/03 22:35:01 gwk Exp $	*/
a748 1
		extern int cpu_id, cpu_feature;
@


1.17
log
@Cease printing the mpbios vendor/version strings, smbios provides much
more informative information.
ok in principal deraadt@@, krw@@, mickey@@
this change with newline fixes ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.16 2006/09/19 11:06:33 jsg Exp $	*/
d280 7
d458 2
a459 2
int mp_isa_bus = -1;		/* XXX */
int mp_eisa_bus = -1;		/* XXX */
d994 1
a994 1
		if (mp_eisa_bus != -1)
d998 1
a998 1
			mp_eisa_bus = bus_id;
d1001 1
a1001 1
		mp_busses[bus_id].mb_idx = 0; /* XXX */
d1004 1
a1004 1
		if (mp_isa_bus != -1)
d1008 1
a1008 1
			mp_isa_bus = bus_id;
@


1.16
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.15 2006/08/18 08:30:35 kettenis Exp $	*/
d504 1
a504 1
		printf("(Version 1.1)");
d507 1
a507 1
		printf("(Version 1.4)");
d510 1
a510 1
		printf("(unrecognized rev %d)", mp_fps->spec_rev);
a558 3

		printf(" (%8.8s %12.12s)\n",
		    mp_cth->oem_id, mp_cth->product_id);
@


1.15
log
@Make sure the PCI mode detection code is called if it hasn't been run yet.
This can happen on machines with mpbios but without pcibios like the Sun
x4100 and x4200.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.14 2006/05/29 20:40:58 miod Exp $	*/
d203 1
a203 3
mp_print(aux, pnp)
	void *aux;
	const char *pnp;
d212 1
a212 4
mp_match(parent, cfv, aux)
	struct device *parent;
	void *cfv;
	void *aux;
d227 1
a227 4
mpbios_map(pa, len, handle)
	paddr_t pa;
	int len;
	struct mp_map *handle;
d255 1
a255 2
mpbios_unmap(handle)
	struct mp_map *handle;
d269 1
a269 2
mpbios_probe(self)
	struct device *self;
d381 1
a381 3
mpbios_cksum (start, len)
	const void *start;
	int len;
d403 1
a403 5
mpbios_search (self, start, count, map)
	struct device *self;
	paddr_t start;
	int count;
	struct mp_map *map;
d492 1
a492 2
mpbios_scan(self)
	struct device *self;
d711 1
a711 3
mpbios_cpu(ent, self)
	const u_int8_t *ent;
	struct device *self;
d761 1
a761 3
mp_cfg_special_intr(entry, redir)
	const struct mpbios_int *entry;
	u_int32_t *redir;
d798 1
a798 3
mp_cfg_pci_intr(entry, redir)
	const struct mpbios_int *entry;
	u_int32_t *redir;
d836 1
a836 3
mp_cfg_eisa_intr (entry, redir)
	const struct mpbios_int *entry;
	u_int32_t *redir;
d886 1
a886 3
mp_cfg_isa_intr(entry, redir)
	const struct mpbios_int *entry;
	u_int32_t *redir;
d925 1
a925 2
mp_print_special_intr(intr)
	int intr;
d930 1
a930 2
mp_print_pci_intr(intr)
	int intr;
d936 1
a936 2
mp_print_isa_intr(intr)
	int intr;
d942 1
a942 2
mp_print_eisa_intr(intr)
	int intr;
d956 1
a956 3
mpbios_bus(ent, self)
	const u_int8_t *ent;
	struct device *self;
d1013 1
a1013 3
mpbios_ioapic(ent, self)
	const u_int8_t *ent;
	struct device *self;
d1033 1
a1033 3
mpbios_int(ent, mpi)
	const u_int8_t *ent;
	struct mp_intr_map *mpi;
@


1.14
log
@Remove unused NetBSD new-style %b strings.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.13 2006/05/14 19:07:46 kettenis Exp $	*/
d687 1
a687 1
	if (pci_mode != 0)
@


1.13
log
@Bring over workaround for broken BIOSes that use ACPI global interrupt numbers
instead of APIC pin numbers from amd64.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.12 2006/05/09 18:41:22 kettenis Exp $	*/
a1065 7

static const char inttype_fmt[] = "\177\020"
		"f\0\2type\0" "=\1NMI\0" "=\2SMI\0" "=\3ExtINT\0";

static const char flagtype_fmt[] = "\177\020"
		"f\0\2pol\0" "=\1Act Hi\0" "=\3Act Lo\0"
		"f\2\2trig\0" "=\1Edge\0" "=\3Level\0";
@


1.12
log
@Import global ACPI interrupt code from amd64.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.11 2006/05/01 17:01:14 kettenis Exp $	*/
d1081 1
a1081 1
	struct ioapic_softc *sc = NULL;
d1131 17
@


1.11
log
@Fixup broken mpbios'es on VT8237 and nForce4 chipsets.  Fixes interrupt
routing for several integrated devices on those chipsets in GENERIC.MP.
ok brad@@, mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.10 2006/04/30 17:38:26 kettenis Exp $	*/
d1061 2
a1062 1
	aaa.flags =  (mp_fps->mpfb2 & 0x80) ? IOAPIC_PICMODE : IOAPIC_VWIRE;
@


1.10
log
@Do not leave behind half-initialized data structures so we don't stumble over
corrupt interrupt table entries later on.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.9 2006/04/27 15:37:51 mickey Exp $	*/
d127 1
d129 1
d133 2
d685 5
@


1.9
log
@implement separate PAE pmap that allows access to 64g of physmem
if supported by the cpu(s). currently not enabled by default and
not compiled into ramdisks. this grows paddr_t to 64bit but yet
leaves bus_addr_t at 32bits. measures are taken to favour dmaable
memory allocation from below 4g line such that buffer cache is
already allocated form below, pool backend allocator prefers lower
memory and then finally bounce buffers are used as last resort.
PAE is engaged only if global variable cpu_pae is manually set
to non-zero and there is physical memory present above 4g.
simplify pcibios address math to use u_long as we always will
be in the 32bit space.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.8 2006/04/18 17:42:24 kettenis Exp $	*/
d178 1
a178 1
void	mpbios_int(const u_int8_t *, struct mp_intr_map *);
d655 3
a657 1
				mpbios_int(position, &mp_intrs[mp_nintrs++]);
d710 4
a713 1
	mpbios_int((const u_int8_t *)&e, (mip = &mp_intrs[mp_nintrs++]));
d715 1
a715 1
	return (mip->ioapic_ih | irq);
d1064 1
a1064 1
void
a1098 2
	mpi->next = mpb->mb_intrs;
	mpb->mb_intrs = mpi;
d1111 1
a1111 1
		return;
d1120 1
a1120 1
			return;
d1149 1
a1156 2
		if (mpb != NULL)

d1161 5
@


1.8
log
@If mpbios doesn't specify a valid CPU signature, fall back on information
from the boot processor.
ok mpf@@, mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.7 2005/12/12 13:54:09 mickey Exp $	*/
d1046 1
a1046 1
	aaa.apic_address = (paddr_t)entry->apic_address;
@


1.7
log
@some bioses screw the order so be extra careful to counters; been in snaps for some time
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.6 2005/11/23 09:24:46 mickey Exp $	*/
d743 11
@


1.6
log
@resolve a couple of problems in mpbios-mapped interrupts:
- synthesise isa mappings (as 1-1) should those be missing in mpbios;
- for rcc osb* firce "special" ints into isa mappings always.
niklas@@ ok and testing by many since
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.5 2005/11/13 14:23:26 martin Exp $	*/
d579 5
a583 3
		position = (const u_int8_t *)(mp_cth);
		end = position + mp_cth->base_len;
		position += sizeof(*mp_cth);
a584 4
		count = mp_cth->entry_count;
		intr_cnt = 15;	/* presume all isa irqs being missing */

		while ((count--) && (position < end)) {
d590 1
d594 11
d611 1
a628 1
			position += mp_conf[type].length;
@


1.5
log
@convert more MD macros to their MI counterparts, this time
i386_round_page(), i386_trunc_page(), i386_btop() and i386_ptob()
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.4 2005/07/18 02:43:25 fgsch Exp $	*/
d178 1
a178 1
void	mpbios_int(const u_int8_t *, int, struct mp_intr_map *);
d460 1
d510 1
a510 1
	int		intr_cnt, cur_intr;
d584 1
a584 1
		intr_cnt = 0;
d630 1
a630 1
		cur_intr = 0;
d645 1
a645 3
				mpbios_int(position, type,
				    &mp_intrs[cur_intr]);
				cur_intr++;
d671 32
d1039 1
a1039 1
mpbios_int(ent, enttype, mpi)
a1040 1
	int enttype;
d1092 1
a1092 1
	if (enttype == MPS_MCT_IOINT) {
@


1.4
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.3 2004/06/23 17:14:31 niklas Exp $	*/
d233 2
a234 2
	paddr_t pgpa = i386_trunc_page(pa);
	paddr_t endpa = i386_round_page(pa + len);
@


1.3
log
@Renumber I/O APICs who clash with other APICs. Also clear the delivery
mode before setting it to fixed, since the MP BIOS may have left something
in that field. This fixed a Quad Xeon we have been loaned over the c2k4.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.2 2004/06/13 21:49:15 niklas Exp $	*/
d937 1
a937 1
		panic("%s: bus number %d out of range?? (type %6.6s)\n",
@


1.2
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1014 1
d1020 1
a1020 1
	u_int32_t id = entry->dst_apic_id;
d1027 2
d1060 1
a1060 1
	(*mpb->mb_intr_cfg)(entry, &mpi->redir);
@


1.1
log
@file mpbios.c was initially added on branch SMP.
@
text
@d1 1105
@


1.1.2.1
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@a0 1273
/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * Copyright (c) 1999 Stefan Grefen
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the NetBSD
 *      Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.  
 *
 * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * Derived from FreeBSD's mp_machdep.c
 */
/*
 * Copyright (c) 1996, by Steve Passe
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the developer may NOT be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$Id: mpbios.c,v 1.1.2.4 2000/02/29 13:20:07 sommerfeld Exp $
 */

/*
 * The Intel MP-stuff is just one way of x86 SMP systems
 * so only Intel MP specific stuff is here.
 */

#include "mpbios.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <vm/vm.h>
#include <vm/vm_param.h>
#include <vm/pmap.h>
#include <vm/vm_kern.h>
#include <vm/vm_extern.h>
#include <machine/specialreg.h>
#include <machine/cputypes.h>
#include <machine/cpuvar.h>
#include <machine/bus.h>
#include <machine/mpbiosreg.h>
#include <machine/mpbiosvar.h>

#include <machine/i82093reg.h>
#include <machine/i82093var.h>
#include <machine/i82489reg.h>
#include <machine/i82489var.h>
#include <dev/isa/isareg.h>

#include <dev/ic/mc146818reg.h>		/* for NVRAM POST */
#include <i386/isa/nvram.h>		/* for NVRAM POST */

#include <dev/eisa/eisavar.h>	/* for ELCR* def'ns */


static struct mpbios_ioapic default_ioapic = {
    2,0,1,IOAPICENTRY_FLAG_EN,(caddr_t)IOAPIC_BASE_DEFAULT
};

/* descriptions of MP basetable entries */
struct mpbios_baseentry {
	u_int8_t  	type;
	u_int8_t  	length;
	u_int16_t	count;
	const char    	*name;
};

static const char *loc_where[] = {
	"extended bios data area",
	"last page of base memory",
	"bios"
};

struct mp_map 
{
	vaddr_t 	baseva;
	int	 	vsize;
	paddr_t 	pa;
	paddr_t 	pg;
	int		psize;
};

/* XXX */
char *bitmask_snprintf(u_quad_t, const char *, char *, size_t);

int mp_print __P((void *, const char *));
int mp_match __P((struct device *,void *,void *));
int mpbios_cpu_start __P((struct cpu_info *));
static const void *mpbios_search __P((struct device *, paddr_t, int,
    struct mp_map *));
static inline int mpbios_cksum __P((const void *,int));

static void mp_cfg_special_intr __P((const struct mpbios_int *, u_int32_t *));
static void mp_cfg_pci_intr __P((const struct mpbios_int *, u_int32_t *));
static void mp_cfg_eisa_intr __P((const struct mpbios_int *, u_int32_t *));
static void mp_cfg_isa_intr __P((const struct mpbios_int *, u_int32_t *));
static void mp_print_special_intr (int intr);
static void mp_print_pci_intr (int intr);
static void mp_print_eisa_intr (int intr);
static void mp_print_isa_intr (int intr);

static void mpbios_cpu __P((const u_int8_t *, struct device *));
static void mpbios_bus __P((const u_int8_t *, struct device *));
static void mpbios_ioapic __P((const u_int8_t *, struct device *));
static void mpbios_int __P((const u_int8_t *, int, struct mp_intr_map *));

static const void *mpbios_map __P((paddr_t, int, struct mp_map *));
static void mpbios_unmap __P((struct mp_map *));

/*
 * globals to help us bounce our way through parsing the config table.
 */

static struct mp_map mp_cfg_table_map;
static struct mp_map mp_fp_map;
const struct mpbios_cth	*mp_cth;
const struct mpbios_fps	*mp_fps;

#ifdef MPVERBOSE
int mp_verbose = 1;
#else
int mp_verbose = 0;
#endif
	
struct cpu_functions mpbios_cpu_funcs = { mpbios_cpu_start, NULL };

int
mp_print(aux, pnp)
	void *aux;
	const char *pnp;
{
	struct cpu_attach_args * caa = (struct cpu_attach_args *) aux;
	if (pnp)
		printf("%s at %s:",caa->caa_name, pnp);
	return (UNCONF);
}

int
mp_match(parent, cfv, aux)
	struct device *parent;
	void *cfv;
	void *aux;
{
        struct cfdata *cf = (struct cfdata *)cfv;
	struct cpu_attach_args * caa = (struct cpu_attach_args *) aux;
	if (strcmp(caa->caa_name, cf->cf_driver->cd_name))
		return 0;

	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
}

/* -------------- XXX XXX XXX - rewrite ! */

char *
bitmask_snprintf(val, p, buf, buflen)
        u_quad_t val;
        const char *p;
        char *buf;
        size_t buflen;
{
        char *bp, *q;
        size_t left;
#define KPRINTF_BUFSIZE              (sizeof(quad_t) * NBBY / 3 + 2)
        char *sbase, snbuf[KPRINTF_BUFSIZE];
        int base, bit, ch, len, sep;
        u_quad_t field;

        bp = buf;
        memset(buf, 0, buflen);

        /*
         * Always leave room for the trailing NULL.
         */
        left = buflen - 1;

        /*
         * Print the value into the buffer.  Abort if there's not
         * enough room.
         */
        if (buflen < KPRINTF_BUFSIZE)
                return (buf);

        ch = *p++;
        base = ch != '\177' ? ch : *p++;
        sbase = base == 8 ? "%qo" : base == 10 ? "%qd" : base == 16 ? "%qx" : 0;
        if (sbase == 0)
                return (buf);   /* punt if not oct, dec, or hex */

        sprintf(snbuf, sbase, val);
        for (q = snbuf ; *q ; q++) {
                *bp++ = *q;
                left--;
        }

        /*
         * If the value we printed was 0 and we're using the old-style format,
         * or if we don't have room for "<x>", we're done.
         */
        if (((val == 0) && (ch != '\177')) || left < 3)
                return (buf);

#define PUTBYTE(b, c, l)        \
        *(b)++ = (c);           \
        if (--(l) == 0)         \
                goto out;
#define PUTSTR(b, p, l) do {            \
        int c;                          \
        while ((c = *(p)++) != 0) {     \
                *(b)++ = c;             \
                if (--(l) == 0)         \
                        goto out;       \
        }                               \
} while (0)

        /*
         * Chris Torek's new style %b format is identified by a leading \177
         */
        sep = '<';
        if (ch != '\177') {
                /* old (standard) %b format. */
                for (;(bit = *p++) != 0;) {
                        if (val & (1 << (bit - 1))) {
                                PUTBYTE(bp, sep, left);
                                for (; (ch = *p) > ' '; ++p) {
                                        PUTBYTE(bp, ch, left);
                                }
                                sep = ',';
                        } else
                                for (; *p > ' '; ++p)
                                        continue;
                }
        } else {
                /* new quad-capable %b format; also does fields. */
                field = val;
                while ((ch = *p++) != '\0') {
                        bit = *p++;     /* now 0-origin */
                        switch (ch) {
                        case 'b':
                                if (((u_int)(val >> bit) & 1) == 0)
                                        goto skip;
                                PUTBYTE(bp, sep, left);
                                PUTSTR(bp, p, left);
                                sep = ',';
                                break;
                        case 'f':
                        case 'F':
                                len = *p++;     /* field length */
                                field = (val >> bit) & ((1ULL << len) - 1);
                                if (ch == 'F')  /* just extract */
                                        break;
                                PUTBYTE(bp, sep, left);
                                sep = ',';
                                PUTSTR(bp, p, left);
                                PUTBYTE(bp, '=', left);
                                sprintf(snbuf, sbase, field);
                                q = snbuf; PUTSTR(bp, q, left);
                                break;
                        case '=':
                        case ':':
                                /*
                                 * Here "bit" is actually a value instead,
                                 * to be compared against the last field.
                                 * This only works for values in [0..255],
                                 * of course.
                                 */
                                if ((int)field != bit)
                                        goto skip;
                                if (ch == '=')
                                        PUTBYTE(bp, '=', left);
                                PUTSTR(bp, p, left);
                                break;
                        default:
                        skip:
                                while (*p++ != '\0')
                                        continue;
                                break;
                        }
                }
        }
        if (sep != '<')
                PUTBYTE(bp, '>', left);

out:
        return (buf);

#undef PUTBYTE
#undef PUTSTR
}

/*
 * Map a chunk of memory read-only and return an appropraitely
 * const'ed pointer.
 */

static const void *
mpbios_map (pa, len, handle)
	paddr_t pa;
	int len;
	struct mp_map *handle;
{
	paddr_t pgpa = i386_trunc_page(pa);
	paddr_t endpa = i386_round_page(pa + len);
	vaddr_t va = uvm_km_valloc(kernel_map, endpa - pgpa);
	vaddr_t retva = va + (pa & PGOFSET);
	
	handle->pa = pa;
	handle->pg = pgpa;
	handle->psize = len;
	handle->baseva = va;
	handle->vsize = endpa-pgpa;

	do {	  
		/* pmap_kenter_pa (va, pgpa, VM_PROT_READ); */
	        pmap_enter(pmap_kernel(), va, pgpa, VM_PROT_READ, TRUE,
			   VM_PROT_READ);
		va += NBPG;
		pgpa += NBPG;
	} while (pgpa < endpa);

	return (const void *)retva;
}

inline static void
mpbios_unmap (handle)
	struct mp_map *handle;
{
	bus_addr_t curaddr;
  	/* pmap_kremove (handle->baseva, handle->vsize); */
  	pmap_extract(pmap_kernel(), handle->baseva, (paddr_t *)&curaddr);
	uvm_km_free (kernel_map, handle->baseva, handle->vsize);
}

/*
 * Look for an Intel MP spec table, indicating SMP capable hardware.
 */
int
mpbios_probe(self)
	struct device *self;
{
	paddr_t  	ebda, memtop;

	paddr_t		cthpa;
	int		cthlen;
	const u_int8_t	*mpbios_page;
	int 		scan_loc;
	
	struct		mp_map t;
	
	/* see if EBDA exists */

	mpbios_page = mpbios_map (0, NBPG, &t);

	ebda =   *(const u_int16_t *) (&mpbios_page[0x40e]);
	ebda <<= 4;
	
	memtop = *(const u_int16_t *) (&mpbios_page[0x413]);
	memtop <<= 10;

	mpbios_page = NULL;
	mpbios_unmap(&t);
	
	scan_loc = 0;

	if (ebda && ebda < IOM_BEGIN ) {
		mp_fps = mpbios_search(self, ebda, 1024, &mp_fp_map);
		if (mp_fps != NULL)
			goto found;
	}
	
	scan_loc = 1;

	if (memtop && memtop <= IOM_BEGIN ) {
		mp_fps = mpbios_search(self, memtop - 1024, 1024, &mp_fp_map);
		if (mp_fps != NULL)
			goto found;
	}
	
	scan_loc = 2;
	
	mp_fps = mpbios_search(self, BIOS_BASE, BIOS_COUNT, &mp_fp_map);
	if (mp_fps != NULL)
		goto found;

	/* nothing found */
	return 0;

 found:
	if (mp_verbose)
		printf("%s: MP floating pointer found in %s at 0x%lx\n",
		    self->dv_xname, loc_where[scan_loc], mp_fp_map.pa);

	if (mp_fps->pap == 0) {
		if (mp_fps->mpfb1 == 0) {
			printf("%s: MP fps invalid: "
			    "no default config and no configuration table\n",
			    self->dv_xname);
			
			goto err;
		}
		printf("%s: MP default configuration %d\n",
		    self->dv_xname, mp_fps->mpfb1);
		return 10;
	}

	cthpa = mp_fps->pap;

	mp_cth = mpbios_map (cthpa, sizeof (*mp_cth), &mp_cfg_table_map);
	cthlen = mp_cth->base_len;
	mpbios_unmap(&mp_cfg_table_map);
	
	mp_cth = mpbios_map (cthpa, cthlen, &mp_cfg_table_map);
	
	if (mp_verbose)
		printf("%s: MP config table at 0x%lx, %d bytes long\n",
		    self->dv_xname, cthpa, cthlen);

	if (mp_cth->signature != MP_CT_SIG) {
		printf("%s: MP signature mismatch (%x vs %x)\n",
		    self->dv_xname,
		    MP_CT_SIG, mp_cth->signature);
		goto err;
	}
	
	if (mpbios_cksum(mp_cth, cthlen)) {
		printf ("%s: MP Configuration Table checksum mismatch\n",
		    self->dv_xname);
		goto err;
	}
	return 10;
 err:
	if (mp_fps) {
		mp_fps = NULL;
		mpbios_unmap(&mp_fp_map);
	}
	if (mp_cth) {
		mp_cth = NULL;
		mpbios_unmap(&mp_cfg_table_map);
	}
	return 0;
}


/*
 * Simple byte checksum used on config tables.
 */

inline static int     
mpbios_cksum (start, len) 
	const void *start;
	int len;
{
	unsigned char res=0;
	const char *p = start;
	const char *end = p + len;
	
	while (p < end)
		res += *p++;

	return res;
}


/*
 * Look for the MP floating pointer signature in the given physical
 * address range.
 *
 * We map the memory, scan through it, and unmap it.
 * If we find it, remap the floating pointer structure and return it.
 */

const void *
mpbios_search (self, start, count, map)
	struct device *self;
	paddr_t start;
	int count;
	struct mp_map *map;
{
	struct mp_map t;

	int i, len;
	const struct mpbios_fps *m;
	int end = count - sizeof(*m);
	const u_int8_t *base = mpbios_map (start, count, &t);	

	if (mp_verbose)
		printf("%s: scanning 0x%lx to 0x%lx for MP signature\n",
		    self->dv_xname, start, start+count-sizeof(*m));
		
	for (i = 0; i <= end; i += 4) {
		m = (struct mpbios_fps *)&base[i];
		
		if ((m->signature == MP_FP_SIG) &&
		    ((len = m->length << 4) != 0) &&
		    mpbios_cksum(m, (m->length << 4)) == 0) {

			mpbios_unmap (&t);

			return mpbios_map (start+i, len, map);
		}
	}
	mpbios_unmap(&t);
	
	return 0;
}

/*
 * MP configuration table parsing.
 */

static struct mpbios_baseentry mp_conf[] =
{
	{0, 20, 0, "cpu"},
	{1, 8, 0, "bus"},
	{2, 8, 0, "ioapic"},
	{3, 8, 0, "ioint"},
	{4, 8, 0, "lint"},
};

struct mp_bus *mp_busses; 
struct mp_intr_map *mp_intrs;
extern struct ioapic_softc *ioapics[]; /* XXX */

struct mp_intr_map *lapic_ints[2]; /* XXX */
int mp_isa_bus = -1;		/* XXX */

static struct mp_bus extint_bus = {
	"ExtINT",
	-1,
	mp_print_special_intr,
	mp_cfg_special_intr,
	0
};
static struct mp_bus smi_bus = {
	"SMI",
	-1,
	mp_print_special_intr,
	mp_cfg_special_intr,
	0
};
static struct mp_bus nmi_bus = {
	"NMI",
	-1,
	mp_print_special_intr,
	mp_cfg_special_intr,
	0
};


/*
 * 1st pass on BIOS's Intel MP specification table.
 *
 * initializes:
 *	mp_ncpus = 1
 *
 * determines:
 *	cpu_apic_address (common to all CPUs)
 *	ioapic_address[N]
 *	mp_naps
 *	mp_nbusses
 *	mp_napics
 *	nintrs
 */
void
mpbios_scan(self)
	struct device *self;
{
	const u_int8_t 	*position, *end;
	int		count;
	int		type;
	int		intr_cnt, cur_intr;
	paddr_t		lapic_base;
	
	printf ("%s: Intel MP Specification ", self->dv_xname);

	switch (mp_fps->spec_rev) {
	case 1:
		printf("(Version 1.1)");
		break;
	case 4:
		printf("(Version 1.4)");
		break;
	default:
		printf("(unrecognized rev %d)", mp_fps->spec_rev);
	}
	
	/*
	 * looks like we've got a MP system.  start setting up
	 * infrastructure..
	 * XXX is this the right place??
	 */

	lapic_base = LAPIC_BASE;
	if (mp_cth != NULL)
		lapic_base = (paddr_t)mp_cth->apic_address;
	
	lapic_boot_init(lapic_base);
		
	/* check for use of 'default' configuration */
	if (mp_fps->mpfb1 != 0) {
		struct mpbios_proc pe;

		extern int cpu_id, cpu_feature;	/* XXX */

		printf("\n%s: MP default configuration %d\n",
		    self->dv_xname, mp_fps->mpfb1);
		
		/* use default addresses */
		pe.apic_id = cpu_number();
		pe.cpu_flags = PROCENTRY_FLAG_EN|PROCENTRY_FLAG_BP;
		pe.cpu_signature = cpu_id;
		pe.feature_flags = cpu_feature;

		mpbios_cpu((u_int8_t *)&pe, self);

		pe.apic_id = 1 - cpu_number();
		pe.cpu_flags = PROCENTRY_FLAG_EN;

		mpbios_cpu((u_int8_t *)&pe, self);

		mpbios_ioapic((u_int8_t *)&default_ioapic, self);

		/* XXX */
		printf("%s: WARNING: interrupts not configured\n",
		    self->dv_xname);
		panic("lazy bum");
		return;
	} else {
		/*
		 * should not happen; mp_probe returns 0 in this case,
		 * but..
		 */
		if (mp_cth == NULL)
			panic ("mpbios_scan: no config (can't happen?)");

		printf("\n%s: MP OEM %8.8s Product %12.12s\n",
		    self->dv_xname, mp_cth->oem_id, mp_cth->product_id);

		/*
		 * Walk the table once, counting items
		 */
		position = (const u_int8_t *)(mp_cth);
		end = position + mp_cth->base_len;
		position += sizeof(*mp_cth);
		
		count = mp_cth->entry_count;
		intr_cnt = 0;
		
		while ((count--) && (position < end)) {
			type = *position;
			if (type >= MPS_MCT_NTYPES) {
				printf("%s: unknown entry type %x"
				    " in MP config table\n",
				    self->dv_xname, type);
				break;
			}
			mp_conf[type].count++;
			/*
			 * Count actual interrupt instances.
			 * APIC id 0xff means "wired to all apics of this
			 * type".
			 */
			if ((type == MPS_MCT_IOINT) ||
			    (type == MPS_MCT_LINT)) {
				const struct mpbios_int *ie =
				    (const struct mpbios_int *)position;
				if (ie->dst_apic_id != 0xff)
					intr_cnt++;
				else if (type == MPS_MCT_IOINT)
					intr_cnt += mp_conf[MPS_MCT_IOAPIC].count;
				else
					intr_cnt += mp_conf[MPS_MCT_CPU].count;
			}
			position += mp_conf[type].length;
		}

		mp_busses = malloc(sizeof(struct mp_bus)*
		    mp_conf[MPS_MCT_BUS].count, M_DEVBUF, M_NOWAIT);
		mp_intrs = malloc(sizeof(struct mp_intr_map)*intr_cnt,
		    M_DEVBUF, M_NOWAIT);
		
		/* re-walk the table, recording info of interest */
		position = (const u_int8_t *) mp_cth + sizeof(*mp_cth);
		count = mp_cth->entry_count;
		cur_intr = 0;
		
		while ((count--) && (position < end)) {
			switch (type = *(u_char *) position) {
			case MPS_MCT_CPU:
				mpbios_cpu(position, self);
				break;
			case MPS_MCT_BUS:
				mpbios_bus(position, self);
				break;
			case MPS_MCT_IOAPIC:
				mpbios_ioapic(position, self);
				break;
			case MPS_MCT_IOINT:
			case MPS_MCT_LINT:
				mpbios_int(position, type,
				    &mp_intrs[cur_intr]);
				cur_intr++;
				break;
			default:
				printf("%s: unknown entry type %x in MP config table\n",
				    self->dv_xname, type);
				/* NOTREACHED */
				return;
			}

			(u_char*)position += mp_conf[type].length;
		}
		if (mp_verbose && mp_cth->ext_len)
			printf("%s: MP WARNING: %d bytes of extended entries not examined\n",
			    self->dv_xname, 
			    mp_cth->ext_len);
	}
	/* Clean up. */
	mp_fps = NULL;
	mpbios_unmap (&mp_fp_map);
	if (mp_cth != NULL) {
		mp_cth = NULL;
		mpbios_unmap (&mp_cfg_table_map);
	}
}

static void
mpbios_cpu(ent, self)
	const u_int8_t *ent;
	struct device *self;
{
	const struct mpbios_proc *entry = (const struct mpbios_proc *)ent;
	struct cpu_attach_args caa;

	/* XXX move this into the CPU attachment goo. */
	/* check for usability */
	if (!(entry->cpu_flags & PROCENTRY_FLAG_EN))
		return;

	/* check for BSP flag */
	if (entry->cpu_flags & PROCENTRY_FLAG_BP)
		caa.cpu_role = CPU_ROLE_BP;
	else
		caa.cpu_role = CPU_ROLE_AP;

	caa.caa_name   = "cpu";
	caa.cpu_number = entry->apic_id;
	caa.cpu_func = &mpbios_cpu_funcs;
	caa.cpu_signature = entry->cpu_signature;

	/*
	 * XXX this is truncated to just contain the low-order 16 bits
	 * of the flags on at least some MP bioses
	 */
	caa.feature_flags = entry->feature_flags;

	config_found_sm(self, &caa, mp_print, mp_match);
}

/*
 * The following functions conspire to compute base ioapic redirection
 * table entry for a given interrupt line.
 *
 * Fill in: trigger mode, polarity, and possibly delivery mode.
 */
static void mp_cfg_special_intr (entry, redir)
	const struct mpbios_int *entry;
	u_int32_t *redir;
{

	/*
	 * All of these require edge triggered, zero vector,
	 * appropriate delivery mode.
	 * see page 13 of the 82093AA datasheet.
	 */
	*redir &= ~IOAPIC_REDLO_DEL_MASK;
	*redir &= ~IOAPIC_REDLO_VECTOR_MASK;
	*redir &= ~IOAPIC_REDLO_LEVEL;

	switch (entry->int_type) {
	case MPS_INTTYPE_NMI:
		*redir |= (IOAPIC_REDLO_DEL_NMI<<IOAPIC_REDLO_DEL_SHIFT);
		break;

	case MPS_INTTYPE_SMI:
		*redir |= (IOAPIC_REDLO_DEL_SMI<<IOAPIC_REDLO_DEL_SHIFT);
		break;
	case MPS_INTTYPE_ExtINT:
		/*
		 * We are using the ioapic in "native" mode.
		 * This indicates where the 8259 is wired to the ioapic
		 * and/or local apic..
		 */
		*redir |= (IOAPIC_REDLO_DEL_EXTINT<<IOAPIC_REDLO_DEL_SHIFT);
		*redir |= (IOAPIC_REDLO_MASK);
		break;
	default:
		panic("unknown MPS interrupt type %d", entry->int_type);
	}
}

/* XXX too much duplicated code here. */

static void mp_cfg_pci_intr (entry, redir)
	const struct mpbios_int *entry;
	u_int32_t *redir;
{
	int mpspo = entry->int_flags & 0x03; /* XXX magic */
	int mpstrig = (entry->int_flags >> 2) & 0x03; /* XXX magic */

	*redir &= ~IOAPIC_REDLO_DEL_MASK;
	switch (mpspo) {
	case MPS_INTPO_ACTHI:
		*redir &= ~IOAPIC_REDLO_ACTLO;
		break;
	case MPS_INTPO_DEF:
	case MPS_INTPO_ACTLO:
		*redir |= IOAPIC_REDLO_ACTLO;
		break;
	default:
		panic("unknown MPS interrupt polarity %d", mpspo);
	}
	
	if (entry->int_type != MPS_INTTYPE_INT) {
		mp_cfg_special_intr(entry, redir);
		return;
	}
	*redir |= (IOAPIC_REDLO_DEL_LOPRI<<IOAPIC_REDLO_DEL_SHIFT);
	
	switch (mpstrig) {
	case MPS_INTTR_DEF:
	case MPS_INTTR_LEVEL:
		*redir |= IOAPIC_REDLO_LEVEL;
		break;
	case MPS_INTTR_EDGE:
		*redir &= ~IOAPIC_REDLO_LEVEL;
		break;
	default:
		panic("unknown MPS interrupt trigger %d", mpstrig);	
	}
}

static void mp_cfg_eisa_intr (entry, redir)
	const struct mpbios_int *entry;
	u_int32_t *redir;
{
	int mpspo = entry->int_flags & 0x03; /* XXX magic */
	int mpstrig = (entry->int_flags >> 2) & 0x03; /* XXX magic */

	*redir &= ~IOAPIC_REDLO_DEL_MASK;
	switch (mpspo) {
	case MPS_INTPO_DEF:
	case MPS_INTPO_ACTHI:
		*redir &= ~IOAPIC_REDLO_ACTLO;
		break;
	case MPS_INTPO_ACTLO:
		*redir |= IOAPIC_REDLO_ACTLO;
		break;
	default:
		panic("unknown MPS interrupt polarity %d", mpspo);
	}
	
	if (entry->int_type != MPS_INTTYPE_INT) {
		mp_cfg_special_intr(entry, redir);
		return;
	}
	*redir |= (IOAPIC_REDLO_DEL_LOPRI<<IOAPIC_REDLO_DEL_SHIFT);
	
	switch (mpstrig) {
	case MPS_INTTR_LEVEL:
		*redir |= IOAPIC_REDLO_LEVEL;
		break;
	case MPS_INTTR_EDGE:
		*redir &= ~IOAPIC_REDLO_LEVEL;
		break;
	case MPS_INTTR_DEF:
		/*
		 * Set "default" setting based on ELCR value snagged
		 * earlier.
		 */
		if (mp_busses[entry->src_bus_id].mb_data &
		    (1<<entry->src_bus_irq)) {
			*redir |= IOAPIC_REDLO_LEVEL;			
		} else {
			*redir &= ~IOAPIC_REDLO_LEVEL;
		}
		break;
	default:
		panic("unknown MPS interrupt trigger %d", mpstrig);	
	}
}


static void mp_cfg_isa_intr (entry, redir)
	const struct mpbios_int *entry;
	u_int32_t *redir;
{
	int mpspo = entry->int_flags & 0x03; /* XXX magic */
	int mpstrig = (entry->int_flags >> 2) & 0x03; /* XXX magic */

	*redir &= ~IOAPIC_REDLO_DEL_MASK;
	switch (mpspo) {
	case MPS_INTPO_DEF:
	case MPS_INTPO_ACTHI:
		*redir &= ~IOAPIC_REDLO_ACTLO;
		break;
	case MPS_INTPO_ACTLO:
		*redir |= IOAPIC_REDLO_ACTLO;
		break;
	default:
		panic("unknown MPS interrupt polarity %d", mpspo);
	}
	
	if (entry->int_type != MPS_INTTYPE_INT) {
		mp_cfg_special_intr(entry, redir);
		return;
	}
	*redir |= (IOAPIC_REDLO_DEL_LOPRI<<IOAPIC_REDLO_DEL_SHIFT);
	
	switch (mpstrig) {
	case MPS_INTTR_LEVEL:
		*redir |= IOAPIC_REDLO_LEVEL;
		break;
	case MPS_INTTR_DEF:
	case MPS_INTTR_EDGE:
		*redir &= ~IOAPIC_REDLO_LEVEL;
		break;
	default:
		panic("unknown MPS interrupt trigger %d", mpstrig);	
	}
}


static void mp_print_special_intr (intr)
	int intr;
{
}

static void mp_print_pci_intr (intr)
	int intr;
{
	printf(" device %d INT_%c", (intr>>2)&0x1f, 'A' + (intr & 0x3));
}

static void mp_print_isa_intr (intr)
	int intr;
{
	printf(" irq %d", intr);
}

static void mp_print_eisa_intr (intr)
	int intr;
{
	printf(" EISA irq %d", intr);
}



#define TAB_UNIT	4
#define TAB_ROUND(a)	_TAB_ROUND(a, TAB_UNIT)

#define _TAB_ROUND(a,u)	(((a) + (u - 1)) & ~(u-1))
#define EXTEND_TAB(a,u)	(!(_TAB_ROUND(a,u) == _TAB_ROUND((a+1),u)))

static void
mpbios_bus(ent, self)
	const u_int8_t *ent;
	struct device *self;
{
	const struct mpbios_bus *entry = (const struct mpbios_bus *)ent;
	/* XXX should also add EISA support here. */
	mp_busses[entry->bus_id].mb_intrs = NULL;
	
	if (memcmp(entry->bus_type, "PCI   ", 6) == 0) {
		mp_busses[entry->bus_id].mb_name = "pci";
		mp_busses[entry->bus_id].mb_idx = entry->bus_id;
		mp_busses[entry->bus_id].mb_intr_print = mp_print_pci_intr;
		mp_busses[entry->bus_id].mb_intr_cfg = mp_cfg_pci_intr;
	} else if (memcmp(entry->bus_type, "EISA  ", 6) == 0) {
		mp_busses[entry->bus_id].mb_name = "eisa";
		mp_busses[entry->bus_id].mb_idx = entry->bus_id;
		mp_busses[entry->bus_id].mb_intr_print = mp_print_eisa_intr;
		mp_busses[entry->bus_id].mb_intr_cfg = mp_cfg_eisa_intr;

		mp_busses[entry->bus_id].mb_data =
		    inb(ELCR0) | (inb(ELCR1) << 8);
		
	} else if (memcmp(entry->bus_type, "ISA   ", 6) == 0) {
		mp_busses[entry->bus_id].mb_name = "isa";
		mp_busses[entry->bus_id].mb_idx = 0; /* XXX */
		mp_busses[entry->bus_id].mb_intr_print = mp_print_isa_intr;
		mp_busses[entry->bus_id].mb_intr_cfg = mp_cfg_isa_intr;
		if (mp_isa_bus != -1)
			printf("oops: multiple isa busses?\n");
		else
			mp_isa_bus = entry->bus_id;
	} else {
		printf("%s: unsupported bus type %6.6s\n", self->dv_xname,
		    entry->bus_type);
	}
}


static void
mpbios_ioapic(ent, self)
	const u_int8_t *ent;
	struct device *self;
{
	const struct mpbios_ioapic *entry = (const struct mpbios_ioapic *)ent;
	struct apic_attach_args aaa;

	/* XXX let flags checking happen in ioapic driver.. */
	if (!(entry->apic_flags & IOAPICENTRY_FLAG_EN))
		return;

	aaa.aaa_name   = "ioapic";
	aaa.apic_id = entry->apic_id;
	aaa.apic_version = entry->apic_version;
	aaa.apic_address = (paddr_t)entry->apic_address;
	aaa.flags =  (mp_fps->mpfb2 & 0x80) ? IOAPIC_PICMODE : IOAPIC_VWIRE;

	config_found_sm(self, &aaa, mp_print, mp_match);
}

static const char inttype_fmt[] = "\177\020"		
		"f\0\2type\0" "=\1NMI\0" "=\2SMI\0" "=\3ExtINT\0";

static const char flagtype_fmt[] = "\177\020"		
		"f\0\2pol\0" "=\1Act Hi\0" "=\3Act Lo\0"
		"f\2\2trig\0" "=\1Edge\0" "=\3Level\0";

static void
mpbios_int(ent, enttype, mpi)
	const u_int8_t *ent;
	int enttype;
	struct mp_intr_map *mpi;
{
	const struct mpbios_int *entry = (const struct mpbios_int *)ent;
	struct ioapic_softc *sc = NULL;

	struct mp_intr_map *altmpi;
	struct mp_bus *mpb;
	
	u_int32_t id = entry->dst_apic_id;
	u_int32_t pin = entry->dst_apic_int;
	u_int32_t bus = entry->src_bus_id;
	u_int32_t dev = entry->src_bus_irq;
	u_int32_t type = entry->int_type;
	u_int32_t flags = entry->int_flags;

	switch (type) {
	case MPS_INTTYPE_INT:
		mpb = &(mp_busses[bus]);
		break;
	case MPS_INTTYPE_ExtINT:
		mpb = &extint_bus;
		break;
	case MPS_INTTYPE_SMI:
		mpb = &smi_bus;
		break;
	case MPS_INTTYPE_NMI:
		mpb = &nmi_bus;
		break;
	}
	mpi->next = mpb->mb_intrs;
	mpb->mb_intrs = mpi;
	mpi->bus = mpb;
	mpi->bus_pin = dev;
	
	mpi->ioapic_ih = APIC_INT_VIA_APIC |
	    ((id<<APIC_INT_APIC_SHIFT) | ((pin<<APIC_INT_PIN_SHIFT)));

	mpi->type = type;
	mpi->flags = flags;
	mpi->redir = 0;
	if (mpb->mb_intr_cfg == NULL) {
		printf("mpbios: can't find bus %d for apic %d pin %d\n",
		    bus, id, pin);
		return;
	}
	
	(*mpb->mb_intr_cfg)(entry, &mpi->redir);

	if (enttype == MPS_MCT_IOINT) {
		/* XXX */
		if (id == 0xff)
			panic("can't deal with all-ioapics interrupt yet!");

		sc = ioapics[id]; /* XXX XXX XXX */
		mpi->ioapic = sc;
		mpi->ioapic_pin = pin;

		altmpi = sc->sc_pins[pin].ip_map;
	
		if (altmpi != NULL) {
			if ((altmpi->type != type) ||
			    (altmpi->flags != flags)) {
				printf("%s: conflicting map entries for pin %d\n",
				    sc->sc_dev.dv_xname, pin);
			}
		} else {
			sc->sc_pins[pin].ip_map = mpi;
		}
	} else {
		if (id != 0xff)
			panic("can't deal with not-all-lapics interrupt yet!");
		if (pin >= 2)
			printf("pin %d of local apic doesn't exist!\n", pin);
		else {
			mpi->ioapic = NULL;
			mpi->ioapic_pin = pin;
			lapic_ints[pin] = mpi;
		}
	}
	if (mp_verbose) {
		char buf[256];

		printf("%s: int%d attached to %s",
		    sc? sc->sc_dev.dv_xname : "local apic",
		    pin,
		    mpb->mb_name);
		if (mpb->mb_idx != -1)
			printf("%d", mpb->mb_idx);

		if (mpb != NULL) 

		(*(mpb->mb_intr_print))(dev);

		printf(" (type %s", 
		    bitmask_snprintf(type, inttype_fmt, buf, sizeof(buf)));
		
		printf(" flags %s)\n",
		    bitmask_snprintf(flags, flagtype_fmt, buf, sizeof(buf)));
	}
}


int
mpbios_cpu_start(struct cpu_info *ci)
{
	int error;
	unsigned short dwordptr[2];
	bus_addr_t curaddr;

	/*
	 * "The BSP must initialize CMOS shutdown code to 0Ah ..."
	 */

	outb(IO_RTC, NVRAM_RESET);
	outb(IO_RTC+1, NVRAM_RESET_SOFT);
	
	/*
	 * "and the warm reset vector (DWORD based at 40:67) to point
	 * to the AP startup code ..."
	 */

	dwordptr[0] = 0;
	dwordptr[1] = MP_TRAMPOLINE >> 4;
	
	/* pmap_kenter_pa (0, 0, VM_PROT_READ|VM_PROT_WRITE); */
	pmap_enter (pmap_kernel(), 0, 0, VM_PROT_READ|VM_PROT_WRITE, TRUE,
		    VM_PROT_READ|VM_PROT_WRITE);
	memcpy ((u_int8_t *) 0x467, dwordptr, 4);
	/* pmap_kremove (0, NBPG); */
	pmap_extract (pmap_kernel(), 0, (paddr_t *)&curaddr);
	
	/*
	 * ... prior to executing the following sequence:"
	 */

	if (ci->ci_flags & CPUF_AP) {
		if ((error = i386_ipi_init(ci->ci_cpuid)) != 0)
			return error;

		delay(10000);

		if (ci->ci_feature_flags & CPUID_APIC) {

			if ((error = i386_ipi(MP_TRAMPOLINE/NBPG,ci->ci_cpuid,
			    LAPIC_DLMODE_STARTUP)) != 0)
				return error;
			delay(200);

			if ((error = i386_ipi(MP_TRAMPOLINE/NBPG,ci->ci_cpuid,
			    LAPIC_DLMODE_STARTUP)) != 0)
				return error;
			delay(200);
		}
	}
	return 0;
}

@


1.1.2.2
log
@Better. From <rtecco@@umich.edu>.
@
text
@d98 1
a98 1
 *	$Id: mpbios.c,v 1.1.2.1 2001/07/14 10:02:29 ho Exp $
d409 1
d411 1
a411 1
  	pmap_extract(pmap_kernel(), handle->baseva, NULL);
d1224 1
d1246 1
a1246 1
	pmap_extract (pmap_kernel(), 0, NULL);
@


1.1.2.3
log
@KNF
@
text
@d57 1
a57 1
 *    from this software without specific prior written permission.
d98 1
a98 1
 *	$Id: mpbios.c,v 1.1.2.2 2001/07/15 11:04:49 ho Exp $
d156 1
a156 1
struct mp_map
d166 1
a166 1
char   *bitmask_snprintf(u_quad_t, const char *, char *, size_t);
d168 20
a187 20
int	mp_print(void *, const char *);
int	mp_match(struct device *, void *, void *);
int	mpbios_cpu_start(struct cpu_info *);
const void *mpbios_search(struct device *, paddr_t, int,
    struct mp_map *);
static __inline int mpbios_cksum(const void *, int);

void	mp_cfg_special_intr(const struct mpbios_int *, u_int32_t *);
void	mp_cfg_pci_intr(const struct mpbios_int *, u_int32_t *);
void	mp_cfg_eisa_intr(const struct mpbios_int *, u_int32_t *);
void	mp_cfg_isa_intr(const struct mpbios_int *, u_int32_t *);
void	mp_print_special_intr (int);
void	mp_print_pci_intr (int);
void	mp_print_eisa_intr (int);
void	mp_print_isa_intr (int);

void	mpbios_cpu(const u_int8_t *, struct device *);
void	mpbios_bus(const u_int8_t *, struct device *);
void	mpbios_ioapic(const u_int8_t *, struct device *);
void	mpbios_int(const u_int8_t *, int, struct mp_intr_map *);
d189 2
a190 2
const void *mpbios_map(paddr_t, int, struct mp_map *);
static __inline void mpbios_unmap(struct mp_map *);
d206 1
a206 1

d377 2
a378 2
const void *
mpbios_map(pa, len, handle)
d387 1
a387 1

d394 1
a394 1
	do {
d396 2
a397 2
		pmap_enter(pmap_kernel(), va, pgpa, VM_PROT_READ, TRUE,
		    VM_PROT_READ);
d402 1
a402 1
	return ((const void *)retva);
d405 2
a406 2
static __inline void
mpbios_unmap(handle)
d411 1
a411 1
	uvm_km_free(kernel_map, handle->baseva, handle->vsize);
d427 1
a427 1

d429 1
a429 1

d432 1
a432 1
	mpbios_page = mpbios_map(0, NBPG, &t);
d434 1
a434 2
	/* XXX Ugly magic constants below. */
	ebda = *(const u_int16_t *)(&mpbios_page[0x40e]);
d436 2
a437 2

	memtop = *(const u_int16_t *)(&mpbios_page[0x413]);
d442 1
a442 1

d450 1
a450 1

d458 1
a458 1

d460 1
a460 1

d466 1
a466 1
	return (0);
d478 1
a478 1

d483 1
a483 1
		return (10);
d488 1
a488 1
	mp_cth = mpbios_map(cthpa, sizeof (*mp_cth), &mp_cfg_table_map);
d491 3
a493 3

	mp_cth = mpbios_map(cthpa, cthlen, &mp_cfg_table_map);

d504 1
a504 1

d510 1
a510 2
	return (10);

d520 1
a520 1
	return (0);
d528 2
a529 2
static __inline int
mpbios_cksum (start, len)
d536 1
a536 1

d564 1
a564 1
	const u_int8_t *base = mpbios_map (start, count, &t);
d569 1
a569 1

d572 1
a572 1

a575 1
			mpbios_unmap(&t);
d577 3
a579 1
			return (mpbios_map(start + i, len, map));
d583 1
a583 1

d600 1
a600 1
struct mp_bus *mp_busses;
d653 2
a654 2

	printf("%s: Intel MP Specification ", self->dv_xname);
d666 1
a666 1

d676 1
a676 1

d678 1
a678 1

d687 1
a687 1

d714 1
a714 1
			panic("mpbios_scan: no config (can't happen?)");
d725 1
a725 1

d728 1
a728 1

d750 1
a750 2
					intr_cnt +=
					    mp_conf[MPS_MCT_IOAPIC].count;
d757 1
a757 1
		mp_busses = malloc(sizeof(struct mp_bus) *
d759 1
a759 1
		mp_intrs = malloc(sizeof(struct mp_intr_map) * intr_cnt,
d761 1
a761 1

d763 1
a763 1
		position = (const u_int8_t *)mp_cth + sizeof(*mp_cth);
d766 1
a766 1

d768 1
a768 1
			switch (type = *(u_char *)position) {
d785 1
a785 2
				printf("%s: unknown entry type %x "
				    "in MP config table\n",
d794 3
a796 3
			printf("%s: MP WARNING: %d "
			    "bytes of extended entries not examined\n",
			    self->dv_xname, mp_cth->ext_len);
d800 1
a800 1
	mpbios_unmap(&mp_fp_map);
d807 1
a807 1
void
d826 1
a826 1
	caa.caa_name = "cpu";
d846 1
a846 2
void
mp_cfg_special_intr(entry, redir)
d884 1
a884 2
void
mp_cfg_pci_intr(entry, redir)
d903 1
a903 1

d909 1
a909 1

d919 1
a919 1
		panic("unknown MPS interrupt trigger %d", mpstrig);
d923 1
a923 2
void
mp_cfg_eisa_intr (entry, redir)
d942 1
a942 1

d948 1
a948 1

d963 1
a963 1
			*redir |= IOAPIC_REDLO_LEVEL;
d969 1
a969 1
		panic("unknown MPS interrupt trigger %d", mpstrig);
d974 1
a974 2
void
mp_cfg_isa_intr(entry, redir)
d993 1
a993 1

d998 2
a999 2
	*redir |= (IOAPIC_REDLO_DEL_LOPRI << IOAPIC_REDLO_DEL_SHIFT);

d1009 1
a1009 1
		panic("unknown MPS interrupt trigger %d", mpstrig);
d1014 1
a1014 2
void
mp_print_special_intr(intr)
d1019 1
a1019 2
void
mp_print_pci_intr(intr)
d1022 1
a1022 1
	printf(" device %d INT_%c", (intr >> 2) & 0x1f, 'A' + (intr & 0x3));
d1025 1
a1025 2
void
mp_print_isa_intr(intr)
d1031 1
a1031 2
void
mp_print_eisa_intr(intr)
d1042 2
a1043 2
#define _TAB_ROUND(a,u)	(((a) + (u - 1)) & ~(u - 1))
#define EXTEND_TAB(a,u)	(!(_TAB_ROUND(a, u) == _TAB_ROUND((a + 1), u)))
d1045 1
a1045 1
void
d1053 1
a1053 1

d1067 1
d1084 1
a1084 1
void
d1096 1
a1096 1
	aaa.aaa_name = "ioapic";
d1105 1
a1105 1
static const char inttype_fmt[] = "\177\020"
d1108 1
a1108 1
static const char flagtype_fmt[] = "\177\020"
d1112 1
a1112 1
void
d1123 1
a1123 1

d1149 1
a1149 1

d1161 1
a1161 1

d1174 1
a1174 1

d1178 1
a1178 2
				printf(
				    "%s: conflicting map entries for pin %d\n",
d1199 2
a1200 1
		    sc ? sc->sc_dev.dv_xname : "local apic", pin,
d1205 1
a1205 1
		if (mpb != NULL)
d1209 1
a1209 1
		printf(" (type %s",
d1211 1
a1211 1

d1229 2
a1230 2
	outb(IO_RTC + 1, NVRAM_RESET_SOFT);

d1238 1
a1238 1

d1240 3
a1242 4
	pmap_enter(pmap_kernel(), 0, 0, VM_PROT_READ|VM_PROT_WRITE, TRUE,
	    VM_PROT_READ|VM_PROT_WRITE);
	/* XXX magic constant.  */
	memcpy((u_int8_t *)0x467, dwordptr, 4);
d1244 2
a1245 2
	pmap_extract(pmap_kernel(), 0, NULL);

d1252 1
a1252 1
			return (error);
d1260 1
a1260 1
				return (error);
d1265 1
a1265 1
				return (error);
d1269 1
a1269 1
	return (0);
@


1.1.2.4
log
@Add $OpenBSD$.
@
text
@a0 2
/*	$OpenBSD$	*/

d98 1
a98 1
 *	$Id: mpbios.c,v 1.1.2.3 2001/07/15 11:43:59 niklas Exp $
d395 1
d409 1
d1249 1
d1254 1
@


1.1.2.5
log
@KNF
Try to use pmap_kenter_pa/pmap_kremove now, it is simpler/faster.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.1.2.4 2001/07/15 15:10:55 ho Exp $	*/
d100 1
a100 1
 *	$Id: mpbios.c,v 1.1.2.4 2001/07/15 15:10:55 ho Exp $
d141 1
a141 1
    2, 0, 1, IOAPICENTRY_FLAG_EN, (caddr_t)IOAPIC_BASE_DEFAULT
d375 1
a375 1
 * Map a chunk of memory read-only and return an appropriately
a396 3
#if 1
		pmap_kenter_pa(va, pgpa, VM_PROT_READ);
#else
a398 1
#endif
a409 3
#if 1
  	pmap_kremove(handle->baseva, handle->vsize);
#else
a410 1
#endif
d566 1
a566 1
	const u_int8_t *base = mpbios_map(start, count, &t);
d570 1
a570 1
		    self->dv_xname, start, start + count - sizeof(*m));
d585 1
a585 1
	return (0);
d806 1
a806 1
		mpbios_unmap(&mp_cfg_table_map);
d1161 1
a1161 1
	    ((id << APIC_INT_APIC_SHIFT) | ((pin << APIC_INT_PIN_SHIFT)));
a1248 3
#if 1
	pmap_kenter_pa(0, 0, VM_PROT_READ|VM_PROT_WRITE);
#else
a1250 1
#endif
a1252 3
#if 1
	pmap_kremove(0, NBPG);
#else
a1253 1
#endif
@


1.1.2.6
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d100 1
a100 1
 *	$Id$
d119 2
@


1.1.2.7
log
@Merge in -current
@
text
@d116 3
a118 2
#include <uvm/uvm_extern.h>

@


1.1.2.8
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d270 1
a270 1
        snprintf(snbuf, sizeof snbuf, sbase, val);
d336 1
a336 1
                                snprintf(snbuf, sizeof snbuf, sbase, field);
@


1.1.2.9
log
@Some merged code from NetBSD, more to come
@
text
@d1 1
a1 2
/*	$OpenBSD: mpbios.c,v 1.1.2.8 2003/05/13 19:42:08 ho Exp $	*/
/*	$NetBSD: mpbios.c,v 1.2 2002/10/01 12:56:57 fvdl Exp $	*/
d41 1
d99 2
d131 3
d206 2
a606 1
int mp_nbus;
d608 1
a611 1
int mp_eisa_bus = -1;		/* XXX */
d689 2
d697 2
a698 2
		pe.cpu_signature = cpu_info_primary.ci_signature;
		pe.feature_flags = cpu_info_primary.ci_feature_flags;
d722 2
a723 2
		printf(" (%8.8s %12.12s)\n",
		    mp_cth->oem_id, mp_cth->product_id);
a743 6
			if (type == MPS_MCT_BUS) {
				const struct mpbios_bus *bp =
				    (const struct mpbios_bus *)position;
				if (bp->bus_id >= mp_nbus)
					mp_nbus = bp->bus_id + 1;
			}
d746 2
a747 2
			 * dst_apic_id of MPS_ALL_APICS means "wired to all
			 * apics of this type".
d753 1
a753 1
				if (ie->dst_apic_id != MPS_ALL_APICS)
d764 2
a765 3
		mp_busses = malloc(sizeof(struct mp_bus) * mp_nbus,
		    M_DEVBUF, M_NOWAIT);
		memset(mp_busses, 0, sizeof(struct mp_bus) * mp_nbus);
d836 1
a836 2
	caa.cpu_func = &mp_cpu_funcs;
#if 1 /* XXX Will be removed when the real stuff is probed */
a843 1
#endif
d1067 2
a1068 16
	int bus_id = entry->bus_id;

	printf("mpbios: bus %d is type %6.6s\n", bus_id, entry->bus_type);

#ifdef DIAGNOSTIC
	/*
	 * This "should not happen" unless the table changes out
	 * from underneath us
	 */
	if (bus_id >= mp_nbus) {
		panic("mpbios: bus number %d out of range?? (type %6.6s)\n",
		    bus_id, entry->bus_type);
	}
#endif

	mp_busses[bus_id].mb_intrs = NULL;
d1071 4
a1074 4
		mp_busses[bus_id].mb_name = "pci";
		mp_busses[bus_id].mb_idx = bus_id;
		mp_busses[bus_id].mb_intr_print = mp_print_pci_intr;
		mp_busses[bus_id].mb_intr_cfg = mp_cfg_pci_intr;
d1076 4
a1079 4
		mp_busses[bus_id].mb_name = "eisa";
		mp_busses[bus_id].mb_idx = bus_id;
		mp_busses[bus_id].mb_intr_print = mp_print_eisa_intr;
		mp_busses[bus_id].mb_intr_cfg = mp_cfg_eisa_intr;
d1081 2
a1082 6
		mp_busses[bus_id].mb_data = inb(ELCR0) | (inb(ELCR1) << 8);

		if (mp_eisa_bus != -1)
			printf("oops: multiple eisa busses?\n");
		else
			mp_eisa_bus = bus_id;
d1084 4
a1087 4
		mp_busses[bus_id].mb_name = "isa";
		mp_busses[bus_id].mb_idx = 0; /* XXX */
		mp_busses[bus_id].mb_intr_print = mp_print_isa_intr;
		mp_busses[bus_id].mb_intr_cfg = mp_cfg_isa_intr;
d1091 1
a1091 1
			mp_isa_bus = bus_id;
d1180 3
a1182 5
		sc = ioapic_find(id);
		if (sc == NULL) {
			printf("mpbios: can't find ioapic %d\n", id);
			return;
		}
d1184 1
d1201 1
a1201 1
		if (id != MPS_ALL_APICS)
d1231 63
@


1.1.2.10
log
@we do not use bitmask_snprintf; ok grange art
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.1.2.9 2004/03/14 22:08:20 niklas Exp $	*/
d159 3
d226 138
d368 1
d1232 2
d1244 5
a1248 2
		printf(" (type %b flags %b)\n", type, inttype_fmt,
		    flags, flagtype_fmt);
@


1.1.2.11
log
@Our %b can't handle new netbsd format, so just use %x for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.1.2.10 2004/06/09 15:45:08 deraadt Exp $	*/
d1100 2
a1101 1
		printf(" (type 0x%x flags 0x%x)\n", type, flags);
@


1.1.2.12
log
@pretty print in dmesg -- when it is easier on the eyes glaring problems
jump out; art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mpbios.c,v 1.1.2.11 2004/06/10 18:19:28 grange Exp $	*/
d205 1
a205 1
		printf("%s at %s:", caa->caa_name, pnp);
d928 1
a928 2
	printf("%s: bus %d is type %6.6s\n", self->dv_xname,
	    bus_id, entry->bus_type);
d936 2
a937 2
		panic("%s: bus number %d out of range?? (type %6.6s)\n",
		    self->dv_xname, bus_id, entry->bus_type);
d957 1
a957 2
			printf("%s: multiple eisa busses?\n",
			    self->dv_xname);
d966 1
a966 2
			printf("%s: multiple isa busses?\n",
			    self->dv_xname);
@


