head	1.37;
access;
symbols
	OPENBSD_6_2_BASE:1.37
	OPENBSD_6_1:1.37.0.6
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.37.0.2
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.35.0.4
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.6
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.31.0.8
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.4
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.2
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.30.0.10
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.8
	OPENBSD_5_0:1.30.0.6
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.4
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.29.0.4
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.6
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.4
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.24.0.6
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.4
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.22.0.4
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.8
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.6
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.19
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.11.0.10
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.8
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.6
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.10
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.8
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.6
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.4
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2016.03.07.05.32.46;	author naddy;	state Exp;
branches;
next	1.36;
commitid	Ht3NH0pdlkYC6Nxx;

1.36
date	2016.03.03.12.41.30;	author naddy;	state Exp;
branches;
next	1.35;
commitid	Ykztt9UU7jxBEqeD;

1.35
date	2015.02.11.05.54.48;	author dlg;	state Exp;
branches;
next	1.34;
commitid	fAl1KR17j4jH74Xf;

1.34
date	2014.11.16.12.30.57;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	yv0ECmCdICvq576h;

1.33
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.32;
commitid	uzzBR7hz9ncd4O6G;

1.32
date	2014.04.01.09.05.03;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2012.12.05.23.20.12;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2009.02.03.11.24.19;	author mikeb;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.27;

1.27
date	2007.07.02.17.11.29;	author thib;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.17.15.00.02;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.09.04.59.41;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.19.02.18.00;	author pedro;	state Exp;
branches;
next	1.23;

1.23
date	2005.09.25.20.48.21;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.06.23.40.43;	author hshoexer;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	2003.11.08.05.38.33;	author nordin;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.09.23.08.34;	author nordin;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.10.07.59.05;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.05.23.25.35;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.30.13.17.38;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.22.23.36.51;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.02.26.04.32.36;	author art;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	96.05.30.09.30.06;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.07.07.21.38;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.04.29.14.12.48;	author hvozda;	state Exp;
branches;
next	1.7;

1.7
date	96.04.18.19.18.08;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.04.17.05.18.52;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.03.19.21.09.16;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.11.11.16.46;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.28.14.38.41;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.05.53;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.32;	author deraadt;	state Exp;
branches;
next	;

1.11.6.1
date	2001.04.18.16.07.16;	author niklas;	state Exp;
branches;
next	1.11.6.2;

1.11.6.2
date	2001.07.04.10.16.34;	author niklas;	state Exp;
branches;
next	1.11.6.3;

1.11.6.3
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.11.6.4;

1.11.6.4
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.11.6.5;

1.11.6.5
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.11.6.6;

1.11.6.6
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.11.6.7;

1.11.6.7
date	2003.04.11.16.12.56;	author niklas;	state Exp;
branches;
next	1.11.6.8;

1.11.6.8
date	2003.05.15.04.08.01;	author niklas;	state Exp;
branches;
next	1.11.6.9;

1.11.6.9
date	2004.02.19.10.48.41;	author niklas;	state Exp;
branches;
next	1.11.6.10;

1.11.6.10
date	2004.06.05.23.08.59;	author niklas;	state Exp;
branches;
next	1.11.6.11;

1.11.6.11
date	2004.06.08.21.30.30;	author grange;	state Exp;
branches;
next	;

1.17.2.1
date	2002.01.31.22.55.11;	author niklas;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Sync no-argument function declaration and definition by adding (void).
ok mlarkin@@ deraadt@@
@
text
@/*	$OpenBSD: gdt.c,v 1.36 2016/03/03 12:41:30 naddy Exp $	*/
/*	$NetBSD: gdt.c,v 1.28 2002/12/14 09:38:50 junyoung Exp $	*/

/*-
 * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by John T. Kohl and Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * The GDT handling has two phases.  During the early lifetime of the
 * kernel there is a static gdt which will be stored in bootstrap_gdt.
 * Later, when the virtual memory is initialized, this will be
 * replaced with a maximum sized GDT.
 *
 * The bootstrap GDT area will hold the initial requirement of NGDT
 * descriptors.  The normal GDT will have a statically sized virtual memory
 * area of size MAXGDTSIZ.
 *
 * Every CPU in a system has its own copy of the GDT.  The only real difference
 * between the two are currently that there is a cpu-specific segment holding
 * the struct cpu_info of the processor, for simplicity at getting cpu_info
 * fields from assembly.  The boot processor will actually refer to the global
 * copy of the GDT as pointed to by the gdt variable.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mutex.h>

#include <uvm/uvm_extern.h>

#include <machine/gdt.h>
#include <machine/pcb.h>

union descriptor bootstrap_gdt[NGDT];
union descriptor *gdt = bootstrap_gdt;

int gdt_next;		/* next available slot for sweeping */
int gdt_free;		/* next free slot; terminated with GNULL_SEL */

struct mutex gdt_lock_store = MUTEX_INITIALIZER(IPL_HIGH);

int gdt_get_slot(void);
void gdt_put_slot(int);

/*
 * Lock and unlock the GDT.
 */
#define gdt_lock()	(mtx_enter(&gdt_lock_store))
#define gdt_unlock()	(mtx_leave(&gdt_lock_store))

/* XXX needs spinlocking if we ever mean to go finegrained. */
void
setgdt(int sel, void *base, size_t limit, int type, int dpl, int def32,
    int gran)
{
	struct segment_descriptor *sd = &gdt[sel].sd;
	CPU_INFO_ITERATOR cii;
	struct cpu_info *ci;

	KASSERT(sel < MAXGDTSIZ);

	setsegment(sd, base, limit, type, dpl, def32, gran);
	CPU_INFO_FOREACH(cii, ci)
		if (ci->ci_gdt != NULL && ci->ci_gdt != gdt)
			ci->ci_gdt[sel].sd = *sd;
}

/*
 * Initialize the GDT subsystem.  Called from autoconf().
 */
void
gdt_init(void)
{
	struct vm_page *pg;
	vaddr_t va;
	struct cpu_info *ci = &cpu_info_primary;

	gdt_next = NGDT;
	gdt_free = GNULL_SEL;

	gdt = (union descriptor *)uvm_km_valloc(kernel_map, MAXGDTSIZ);
	for (va = (vaddr_t)gdt; va < (vaddr_t)gdt + MAXGDTSIZ;
	    va += PAGE_SIZE) {
		pg = uvm_pagealloc(NULL, 0, NULL, UVM_PGA_ZERO);
		if (pg == NULL)
			panic("gdt_init: no pages");
		pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg),
		    PROT_READ | PROT_WRITE);
	}
	bcopy(bootstrap_gdt, gdt, NGDT * sizeof(union descriptor));
	ci->ci_gdt = gdt;
	setsegment(&ci->ci_gdt[GCPU_SEL].sd, ci, sizeof(struct cpu_info)-1,
	    SDT_MEMRWA, SEL_KPL, 0, 0);

	gdt_init_cpu(ci);
}

#ifdef MULTIPROCESSOR
/*
 * Allocate shadow GDT for a slave cpu.
 */
void
gdt_alloc_cpu(struct cpu_info *ci)
{
	struct vm_page *pg;
	vaddr_t va;

	ci->ci_gdt = (union descriptor *)uvm_km_valloc(kernel_map, MAXGDTSIZ);
	uvm_map_pageable(kernel_map, (vaddr_t)ci->ci_gdt,
	    (vaddr_t)ci->ci_gdt + MAXGDTSIZ, FALSE, FALSE);
	for (va = (vaddr_t)ci->ci_gdt; va < (vaddr_t)ci->ci_gdt + MAXGDTSIZ;
	    va += PAGE_SIZE) {
		pg = uvm_pagealloc(NULL, 0, NULL, UVM_PGA_ZERO);
		if (pg == NULL)
			panic("gdt_init: no pages");
		pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg),
		    PROT_READ | PROT_WRITE);
	}
	bzero(ci->ci_gdt, MAXGDTSIZ);
	bcopy(gdt, ci->ci_gdt, MAXGDTSIZ);
	setsegment(&ci->ci_gdt[GCPU_SEL].sd, ci, sizeof(struct cpu_info)-1,
	    SDT_MEMRWA, SEL_KPL, 0, 0);
}
#endif	/* MULTIPROCESSOR */


/*
 * Load appropriate gdt descriptor; we better be running on *ci
 * (for the most part, this is how a cpu knows who it is).
 */
void
gdt_init_cpu(struct cpu_info *ci)
{
	struct region_descriptor region;

	setregion(&region, ci->ci_gdt, MAXGDTSIZ - 1);
	lgdt(&region);
}

/*
 * Allocate a GDT slot as follows:
 * 1) If there are entries on the free list, use those.
 * 2) If there are fewer than MAXGDTSIZ entries in use, there are free slots
 *    near the end that we can sweep through.
 */
int
gdt_get_slot(void)
{
	int slot;

	gdt_lock();

	if (gdt_free != GNULL_SEL) {
		slot = gdt_free;
		gdt_free = gdt[slot].gd.gd_selector;
	} else {
		if (gdt_next >= MAXGDTSIZ)
			panic("gdt_get_slot: out of GDT descriptors");
		slot = gdt_next++;
	}

	gdt_unlock();
	return (slot);
}

/*
 * Deallocate a GDT slot, putting it on the free list.
 */
void
gdt_put_slot(int slot)
{

	gdt_lock();

	gdt[slot].gd.gd_type = SDT_SYSNULL;
	gdt[slot].gd.gd_selector = gdt_free;
	gdt_free = slot;

	gdt_unlock();
}

int
tss_alloc(struct pcb *pcb)
{
	int slot;

	slot = gdt_get_slot();
	setgdt(slot, &pcb->pcb_tss, sizeof(struct pcb) - 1,
	    SDT_SYS386TSS, SEL_KPL, 0, 0);
	return GSEL(slot, SEL_KPL);
}

void
tss_free(int sel)
{

	gdt_put_slot(IDXSEL(sel));
}
@


1.36
log
@Remove option USER_LDT and everything depending on it.
Remove machdep.userldt sysctl.
Remove i386_[gs]et_ldt syscall stub from libi386.
Remove i386_[gs]et_ldt regression test.

ok mlarkin@@ millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.35 2015/02/11 05:54:48 dlg Exp $	*/
d97 1
a97 1
gdt_init()
d172 1
a172 1
gdt_get_slot()
@


1.35
log
@deprecate use of sys/lock.h and replace it with sys/atomic.h or
machine/lock.h as appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.34 2014/11/16 12:30:57 deraadt Exp $	*/
a223 25

#ifdef USER_LDT
/*
 * Caller must have pmap locked for both of these functions.
 */
void
ldt_alloc(struct pmap *pmap, union descriptor *ldt, size_t len)
{
	int slot;

	slot = gdt_get_slot();
	setgdt(slot, ldt, len - 1, SDT_SYSLDT, SEL_KPL, 0, 0);
	pmap->pm_ldt_sel = GSEL(slot, SEL_KPL);
}

void
ldt_free(struct pmap *pmap)
{
	int slot;

	slot = IDXSEL(pmap->pm_ldt_sel);

	gdt_put_slot(slot);
}
#endif /* USER_LDT */
@


1.34
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.33 2014/09/14 14:17:23 jsg Exp $	*/
a51 1
#include <sys/lock.h>
@


1.33
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.32 2014/04/01 09:05:03 mpi Exp $	*/
d114 1
a114 1
		    VM_PROT_READ | VM_PROT_WRITE);
d143 1
a143 1
		    VM_PROT_READ | VM_PROT_WRITE);
@


1.32
log
@More <uvm/uvm.h> -> <uvm/uvm_extern.h> cleaning.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.31 2012/12/05 23:20:12 deraadt Exp $	*/
a51 1
#include <sys/proc.h>
@


1.31
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.30 2010/06/26 23:24:43 guenther Exp $	*/
d56 1
a56 1
#include <uvm/uvm.h>
@


1.30
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.29 2009/02/03 11:24:19 mikeb Exp $	*/
a48 2

#include <sys/cdefs.h>
@


1.29
log
@Free TSS on the stack of the dead process.

In order to do that we have to remove all sleeping parts: sleeping
memory allocation and a sleeping lock.  Thus we're moving this code
to the spinning lock (mutex) and getting rid of the GDT grow code.
Downside is that now we're pre-allocating 64kb of memory per CPU
from the start, but this might be optimized in future.

This also unifies GDT code and MAXGDTSIZ define across i386 and amd64.

With help from mickey.

ok toby, art
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.28 2008/06/26 05:42:10 ray Exp $	*/
a55 1
#include <sys/user.h>
d61 1
@


1.28
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.27 2007/07/02 17:11:29 thib Exp $	*/
d37 1
a37 4
 * replaced with a dynamically resizable GDT (although, we will only
 * ever be growing it, there is almost no gain at all to compact it,
 * and it has proven to be a complicated thing to do, considering
 * parallel access, so it's just not worth the effort.
d39 3
a41 4
 * The static GDT area will hold the initial requirement of NGDT descriptors.
 * The dynamic GDT will have a statically sized virtual memory area of size
 * GDTMAXPAGES, the physical area backing this will be allocated as needed
 * starting with the size needed for holding a copy of the bootstrap gdt.
d57 1
a57 1
#include <sys/rwlock.h>
a65 1
int gdt_size;		/* total number of GDT entries */
d69 1
a69 1
struct rwlock gdt_lock_store = RWLOCK_INITIALIZER("gdtlk");
a70 1
void gdt_grow(void);
d75 1
a75 2
 * Lock and unlock the GDT, to avoid races in case gdt_{ge,pu}t_slot() sleep
 * waiting for memory.
d77 2
a78 11
#define gdt_lock()					\
	do {						\
		if (curproc != NULL)			\
			rw_enter_write(&gdt_lock_store);\
	} while (0)

#define gdt_unlock()					\
	do {						\
		if (curproc != NULL)			\
			rw_exit_write(&gdt_lock_store);	\
	} while (0)
d89 1
a89 1
	KASSERT(sel < gdt_size);
a102 1
	size_t max_len, min_len;
a106 4
	max_len = MAXGDTSIZ * sizeof(union descriptor);
	min_len = MINGDTSIZ * sizeof(union descriptor);

	gdt_size = MINGDTSIZ;
d110 3
a112 2
	gdt = (union descriptor *)uvm_km_valloc(kernel_map, max_len);
	for (va = (vaddr_t)gdt; va < (vaddr_t)gdt + min_len; va += PAGE_SIZE) {
d134 2
a135 2
	int max_len = MAXGDTSIZ * sizeof(union descriptor);
	int min_len = MINGDTSIZ * sizeof(union descriptor);
d137 1
a137 1
	ci->ci_gdt = (union descriptor *)uvm_km_valloc(kernel_map, max_len);
d139 11
a149 3
	    (vaddr_t)ci->ci_gdt + min_len, FALSE, FALSE);
	bzero(ci->ci_gdt, min_len);
	bcopy(gdt, ci->ci_gdt, gdt_size * sizeof(union descriptor));
d165 1
a165 2
	setregion(&region, ci->ci_gdt,
	    MAXGDTSIZ * sizeof(union descriptor) - 1);
a169 32
 * Grow the GDT.
 */
void
gdt_grow()
{
	size_t old_len, new_len;
	CPU_INFO_ITERATOR cii;
	struct cpu_info *ci;
	struct vm_page *pg;
	vaddr_t va;

	old_len = gdt_size * sizeof(union descriptor);
	gdt_size <<= 1;
	new_len = old_len << 1;

	CPU_INFO_FOREACH(cii, ci) {
		for (va = (vaddr_t)(ci->ci_gdt) + old_len;
		     va < (vaddr_t)(ci->ci_gdt) + new_len;
		     va += PAGE_SIZE) {
			while (
			    (pg =
			    uvm_pagealloc(NULL, 0, NULL, UVM_PGA_ZERO)) ==
			    NULL) {
				uvm_wait("gdt_grow");
			}
			pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ | VM_PROT_WRITE);
		}
	}
}

/*
d172 1
a172 1
 * 2) If there are fewer than gdt_size entries in use, there are free slots
a173 2
 * 3) As a last resort, we increase the size of the GDT, and sweep through
 *    the new slots.
d186 2
a187 5
		if (gdt_next >= gdt_size) {
			if (gdt_size >= MAXGDTSIZ)
				panic("gdt_get_slot: out of GDT descriptors");
			gdt_grow();
		}
@


1.27
log
@replace two lockmgr lock with rwlocks.

been in snaps for a week, no objection
from deraadt@@ for putting this in.
ok tom@@ (for gdt)
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.26 2007/05/17 15:00:02 art Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.26
log
@There's no reason to keep track of gdt_count, we only use it for
copying the intial gdt when spinning up secondary cpus and then
we can simply use gdt_size for that.

From mickey, art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.25 2007/05/09 04:59:41 deraadt Exp $	*/
d68 1
d81 1
a81 2
struct simplelock gdt_simplelock;
struct lock gdt_lock_store;
a82 2
static __inline void gdt_lock(void);
static __inline void gdt_unlock(void);
d91 11
a101 13
static __inline void
gdt_lock()
{
	if (curproc != NULL)
		lockmgr(&gdt_lock_store, LK_EXCLUSIVE, &gdt_simplelock);
}

static __inline void
gdt_unlock()
{
	if (curproc != NULL)
		lockmgr(&gdt_lock_store, LK_RELEASE, &gdt_simplelock);
}
a129 3

	simple_lock_init(&gdt_simplelock);
	lockinit(&gdt_lock_store, PZERO, "gdtlck", 0, 0);
@


1.25
log
@only supply ldt_alloc() and ldt_free() if USER_LDT
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.24 2005/11/19 02:18:00 pedro Exp $	*/
a76 1
int gdt_count;		/* number of GDT entries in use */
d116 2
a141 1
	gdt_count = NGDT;
d175 1
a175 1
	bcopy(gdt, ci->ci_gdt, gdt_count * sizeof(union descriptor));
a246 2
		if (gdt_next != gdt_count)
			panic("gdt_get_slot: gdt_next != gdt_count");
a254 1
	gdt_count++;
a266 1
	gdt_count--;
@


1.24
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.23 2005/09/25 20:48:21 miod Exp $	*/
d297 1
d320 1
@


1.23
log
@Turn CPU_INFO_FOREACH into a real construct, like all queue(3) iterators,
instead of the contents of a for() loop. No functional change.
From the m88k SMP tree; ok art@@ deraadt@@

[complete diff this time]
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.22 2004/12/06 23:40:43 hshoexer Exp $	*/
d98 1
a98 2
		lockmgr(&gdt_lock_store, LK_EXCLUSIVE, &gdt_simplelock,
		    curproc);
d105 1
a105 1
		lockmgr(&gdt_lock_store, LK_RELEASE, &gdt_simplelock, curproc);
@


1.22
log
@set granularity for data segment used for struct cpu_info to bytes.
ok mickey deraadt tedu niklas
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.21 2004/06/13 21:49:15 niklas Exp $	*/
d119 1
a119 1
	for (CPU_INFO_FOREACH(cii, ci))
d213 1
a213 1
	for (CPU_INFO_FOREACH(cii, ci)) {
@


1.21
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d157 1
a157 1
	    SDT_MEMRWA, SEL_KPL, 1, 1);
d178 1
a178 1
	    SDT_MEMRWA, SEL_KPL, 1, 1);
@


1.20
log
@Remove compacting garbage collector. Fixes PR #3528.
Tested by henning@@ and frisco@@blackant.ne.
ok mickey@@, niklas@@, and weingart@@
@
text
@d1 2
a2 2
/*	$OpenBSD: gdt.c,v 1.19 2002/03/14 01:26:32 millert Exp $	*/
/*	$NetBSD: gdt.c,v 1.8 1996/05/03 19:42:06 christos Exp $	*/
d5 1
a5 1
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
d30 2
a31 2
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
d40 23
d66 1
d69 1
a69 1
#include <uvm/uvm_extern.h>
d73 7
a79 2
#define	MINGDTSIZ	512
#define	MAXGDTSIZ	8192
d81 2
a82 9
union descriptor *dynamic_gdt = gdt;
int gdt_size = NGDT;		/* total number of GDT entries */
int gdt_count = NGDT;		/* number of GDT entries in use */
int gdt_next = NGDT;		/* next available slot for sweeping */
int gdt_free = GNULL_SEL;	/* next free slot; terminated with GNULL_SEL */

int gdt_flags;
#define	GDT_LOCKED	0x1
#define	GDT_WANTED	0x2
d97 3
a99 6

	while ((gdt_flags & GDT_LOCKED) != 0) {
		gdt_flags |= GDT_WANTED;
		tsleep(&gdt_flags, PZERO, "gdtlck", 0);
	}
	gdt_flags |= GDT_LOCKED;
d105 3
d109 13
a121 5
	gdt_flags &= ~GDT_LOCKED;
	if ((gdt_flags & GDT_WANTED) != 0) {
		gdt_flags &= ~GDT_WANTED;
		wakeup(&gdt_flags);
	}
d131 6
a136 1
	struct region_descriptor region;
d140 1
d142 16
d159 2
a160 4
	dynamic_gdt = (union descriptor *)uvm_km_valloc(kernel_map, max_len);
	uvm_map_pageable(kernel_map, (vaddr_t)dynamic_gdt,
	    (vaddr_t)dynamic_gdt + min_len, FALSE, FALSE);
	bcopy(gdt, dynamic_gdt, NGDT * sizeof(union descriptor));
d162 32
a193 1
	setregion(&region, dynamic_gdt, max_len - 1);
d204 4
d213 14
a226 2
	uvm_map_pageable(kernel_map, (vaddr_t)dynamic_gdt + old_len,
	    (vaddr_t)dynamic_gdt + new_len, FALSE, FALSE);
d246 1
a246 1
		gdt_free = dynamic_gdt[slot].gd.gd_selector;
a252 2
			if (dynamic_gdt == gdt)
				panic("gdt_get_slot called before gdt_init");
d267 1
a267 2
gdt_put_slot(slot)
	int slot;
d273 2
a274 2
	dynamic_gdt[slot].gd.gd_type = SDT_SYSNULL;
	dynamic_gdt[slot].gd.gd_selector = gdt_free;
d280 2
a281 3
void
tss_alloc(pcb)
	struct pcb *pcb;
d286 1
a286 1
	setsegment(&dynamic_gdt[slot].sd, &pcb->pcb_tss, sizeof(struct pcb) - 1,
d288 1
a288 1
	pcb->pcb_tss_sel = GSEL(slot, SEL_KPL);
d292 1
a292 2
tss_free(pcb)
	struct pcb *pcb;
d295 1
a295 1
	gdt_put_slot(IDXSEL(pcb->pcb_tss_sel));
d298 3
d302 1
a302 4
ldt_alloc(pmap, ldt, len)
	struct pmap *pmap;
	union descriptor *ldt;
	size_t len;
d307 1
a307 3
	setsegment(&dynamic_gdt[slot].sd, ldt, len - 1, SDT_SYSLDT, SEL_KPL, 0,
	    0);
	simple_lock(&pmap->pm_lock);
a308 1
	simple_unlock(&pmap->pm_lock);
d312 1
a312 2
ldt_free(pmap)
	struct pmap *pmap;
a315 1
	simple_lock(&pmap->pm_lock);
a316 1
	simple_unlock(&pmap->pm_lock);
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.18 2002/01/09 23:08:34 nordin Exp $	*/
a63 1
void gdt_compact(void);
a64 1
void gdt_shrink(void);
a70 5
 *
 * Note that the locking done here is not sufficient for multiprocessor
 * systems.  A freshly allocated slot will still be of type SDT_SYSNULL for
 * some time after the GDT is unlocked, so gdt_compact() could attempt to
 * reclaim it.
d95 1
a95 53
 * Compact the GDT as follows:
 * 0) We partition the GDT into two areas, one of the slots before gdt_count,
 *    and one of the slots after.  After compaction, the former part should be
 *    completely filled, and the latter part should be completely empty.
 * 1) Step through the process list, looking for TSS and LDT descriptors in
 *    the second section, and swap them with empty slots in the first section.
 * 2) Arrange for new allocations to sweep through the empty section.  Since
 *    we're sweeping through all of the empty entries, and we'll create a free
 *    list as things are deallocated, we do not need to create a new free list
 *    here.
 */
void
gdt_compact()
{
	struct proc *p;
	struct pcb *pcb;
	int slot = NGDT, oslot;

	for (p = allproc.lh_first; p != 0; p = p->p_list.le_next) {
		pcb = &p->p_addr->u_pcb;
		oslot = IDXSEL(pcb->pcb_tss_sel);
		if (oslot >= gdt_count) {
			while (dynamic_gdt[slot].sd.sd_type != SDT_SYSNULL) {
				if (++slot >= gdt_count)
					panic("gdt_compact botch 1");
			}
			dynamic_gdt[slot] = dynamic_gdt[oslot];
			dynamic_gdt[oslot].gd.gd_type = SDT_SYSNULL;
			pcb->pcb_tss_sel = GSEL(slot, SEL_KPL);
		}
		oslot = IDXSEL(pcb->pcb_ldt_sel);
		if (oslot >= gdt_count) {
			while (dynamic_gdt[slot].sd.sd_type != SDT_SYSNULL) {
				if (++slot >= gdt_count)
					panic("gdt_compact botch 2");
			}
			dynamic_gdt[slot] = dynamic_gdt[oslot];
			dynamic_gdt[oslot].gd.gd_type = SDT_SYSNULL;
			pcb->pcb_ldt_sel = GSEL(slot, SEL_KPL);
		}
	}
	for (; slot < gdt_count; slot++)
		if (dynamic_gdt[slot].gd.gd_type == SDT_SYSNULL)
			panic("gdt_compact botch 3");
	for (slot = gdt_count; slot < gdt_size; slot++)
		if (dynamic_gdt[slot].gd.gd_type != SDT_SYSNULL)
			panic("gdt_compact botch 4");
	gdt_next = gdt_count;
	gdt_free = GNULL_SEL;
}

/*
 * Grow or shrink the GDT.
d116 3
a131 12
void
gdt_shrink()
{
	size_t old_len, new_len;

	old_len = gdt_size * sizeof(union descriptor);
	gdt_size >>= 1;
	new_len = old_len >> 1;
	uvm_map_pageable(kernel_map, (vaddr_t)dynamic_gdt + new_len,
	    (vaddr_t)dynamic_gdt + old_len, TRUE, FALSE);
}

d152 1
a152 1
			panic("gdt_get_slot botch 1");
d155 1
a155 1
				panic("gdt_get_slot botch 2");
d180 2
a181 13
	/* 
	 * shrink the GDT if we're using less than 1/4 of it.
	 * Shrinking at that point means we'll still have room for
	 * almost 2x as many processes as are now running without
	 * having to grow the GDT.
	 */
	if (gdt_size > MINGDTSIZ && gdt_count <= gdt_size / 4) {
		gdt_compact();
		gdt_shrink();
	} else {
		dynamic_gdt[slot].gd.gd_selector = gdt_free;
		gdt_free = slot;
	}
@


1.18
log
@Call gdt_init() earlier and only once. Work done with millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.17 2001/11/06 19:53:14 miod Exp $	*/
d62 7
a68 7
static __inline void gdt_lock __P((void));
static __inline void gdt_unlock __P((void));
void gdt_compact __P((void));
void gdt_grow __P((void));
void gdt_shrink __P((void));
int gdt_get_slot __P((void));
void gdt_put_slot __P((int));
@


1.17
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.16 2001/09/19 20:50:56 mickey Exp $	*/
d225 2
a226 3
				gdt_init();
			else
				gdt_grow();
@


1.17.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.18 2002/01/09 23:08:34 nordin Exp $	*/
d225 3
a227 2
				panic("gdt_get_slot called before gdt_init");
			gdt_grow();
@


1.17.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.17.2.1 2002/01/31 22:55:11 niklas Exp $	*/
d62 7
a68 7
static __inline void gdt_lock(void);
static __inline void gdt_unlock(void);
void gdt_compact(void);
void gdt_grow(void);
void gdt_shrink(void);
int gdt_get_slot(void);
void gdt_put_slot(int);
@


1.16
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.15 2001/05/10 07:59:05 art Exp $	*/
a44 1
#include <vm/vm.h>
@


1.15
log
@Some locking protocol fixes and better enforcement of wiring limits.

From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.14 2001/05/05 23:25:35 art Exp $	*/
a45 2
#include <vm/vm_kern.h>

@


1.14
log
@PMAP_NEW and UVM are no longer optional on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.13 2001/04/30 13:17:38 art Exp $	*/
d171 1
a171 1
	    (vaddr_t)dynamic_gdt + min_len, FALSE);
d188 1
a188 1
	    (vaddr_t)dynamic_gdt + new_len, FALSE);
d200 1
a200 1
	    (vaddr_t)dynamic_gdt + old_len, TRUE);
@


1.13
log
@Move gdt_init prototype to gdt.h
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.12 2001/03/22 23:36:51 niklas Exp $	*/
a47 1
#if defined(UVM)
a48 1
#endif
a168 1
#if defined(UVM)
a171 6
#else
	dynamic_gdt = (union descriptor *)kmem_alloc_pageable(kernel_map,
	    max_len);
	vm_map_pageable(kernel_map, (vm_offset_t)dynamic_gdt,
	    (vm_offset_t)dynamic_gdt + min_len, FALSE);
#endif
a186 1
#if defined(UVM)
a188 4
#else
	vm_map_pageable(kernel_map, (vm_offset_t)dynamic_gdt + old_len,
	    (vm_offset_t)dynamic_gdt + new_len, FALSE);
#endif
a198 1
#if defined(UVM)
a200 4
#else
	vm_map_pageable(kernel_map, (vm_offset_t)dynamic_gdt + new_len,
	    (vm_offset_t)dynamic_gdt + old_len, TRUE);
#endif
a289 1
#ifdef PMAP_NEW
a291 4
#else
ldt_alloc(pcb, ldt, len)
	struct pcb *pcb;
#endif
a299 1
#ifdef PMAP_NEW
a302 3
#else
	pcb->pcb_ldt_sel = GSEL(slot, SEL_KPL);
#endif
a305 1
#ifdef PMAP_NEW
a307 4
#else
ldt_free(pcb)
	struct pcb *pcb;
#endif
a310 1
#ifdef PMAP_NEW
a313 3
#else
	slot = IDXSEL(pcb->pcb_ldt_sel);
#endif
@


1.12
log
@Merge in NetBSD's PMAP_NEW, still disabled
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.11 1999/02/26 04:32:36 art Exp $	*/
a69 1
void gdt_init __P((void));
@


1.11
log
@kmem allocation changes for uvm
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.10 1996/05/30 09:30:06 deraadt Exp $	*/
d310 4
d316 1
d325 5
d331 1
d335 4
d341 1
d343 9
d353 1
a353 1
	gdt_put_slot(IDXSEL(pcb->pcb_ldt_sel));
@


1.11.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.12 2001/03/22 23:36:51 niklas Exp $	*/
a309 4
#ifdef PMAP_NEW
ldt_alloc(pmap, ldt, len)
	struct pmap *pmap;
#else
a311 1
#endif
a319 5
#ifdef PMAP_NEW
	simple_lock(&pmap->pm_lock);
	pmap->pm_ldt_sel = GSEL(slot, SEL_KPL);
	simple_unlock(&pmap->pm_lock);
#else
a320 1
#endif
a323 4
#ifdef PMAP_NEW
ldt_free(pmap)
	struct pmap *pmap;
#else
a325 1
#endif
a326 9
	int slot;

#ifdef PMAP_NEW
	simple_lock(&pmap->pm_lock);
	slot = IDXSEL(pmap->pm_ldt_sel);
	simple_unlock(&pmap->pm_lock);
#else
	slot = IDXSEL(pcb->pcb_ldt_sel);
#endif
d328 1
a328 1
	gdt_put_slot(slot);
@


1.11.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.11.6.1 2001/04/18 16:07:16 niklas Exp $	*/
d48 1
d50 1
d70 1
d172 1
d175 7
a181 1
	    (vaddr_t)dynamic_gdt + min_len, FALSE, FALSE);
d197 1
d199 5
a203 1
	    (vaddr_t)dynamic_gdt + new_len, FALSE, FALSE);
d214 1
d216 5
a220 1
	    (vaddr_t)dynamic_gdt + old_len, TRUE, FALSE);
d310 1
d313 4
d325 1
d329 3
d335 1
d338 4
d345 1
d349 3
@


1.11.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.11.6.2 2001/07/04 10:16:34 niklas Exp $	*/
d46 2
@


1.11.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
@


1.11.6.5
log
@Merge in trunk
@
text
@d225 3
a227 2
				panic("gdt_get_slot called before gdt_init");
			gdt_grow();
@


1.11.6.6
log
@Merge in -current from about a week ago
@
text
@d62 7
a68 7
static __inline void gdt_lock(void);
static __inline void gdt_unlock(void);
void gdt_compact(void);
void gdt_grow(void);
void gdt_shrink(void);
int gdt_get_slot(void);
void gdt_put_slot(int);
@


1.11.6.7
log
@Move TSS selector from the PCB to MD part of proc and to cpu_info.
Maintain a list of CPUs and provide an iterator for it.
Ifdef out IPI debugging.  Call pmap_{de,}activate as part of context switching.
Mostly from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.11.6.6 2002/03/28 10:31:04 niklas Exp $	*/
d122 1
a122 1
		oslot = IDXSEL(p->p_md.md_tss_sel);
d130 1
a130 1
			p->p_md.md_tss_sel = GSEL(slot, SEL_KPL);
d265 3
a267 2
int
tss_alloc(struct pcb *pcb)
d274 1
a274 1
	return (GSEL(slot, SEL_KPL));
d278 2
a279 1
tss_free(int sel)
d282 1
a282 1
	gdt_put_slot(IDXSEL(sel));
@


1.11.6.8
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 2
a2 2
/*	$OpenBSD: gdt.c,v 1.11.6.7 2003/04/11 16:12:56 niklas Exp $	*/
/*	$NetBSD: gdt.c,v 1.28 2002/12/14 09:38:50 junyoung Exp $	*/
d5 1
a5 1
 * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
d30 2
a31 2
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
a39 23
/*
 * The GDT handling has two phases.  During the early lifetime of the
 * kernel there is a static gdt which will be stored in bootstrap_gdt.
 * Later, when the virtual memory is initialized, this will be
 * replaced with a dynamically resizable GDT (although, we will only
 * ever be growing it, there is almost no gain at all to compact it,
 * and it has proven to be a complicated thing to do, considering
 * parallel access, so it's just not worth the effort.
 *
 * The static GDT area will hold the initial requirement of NGDT descriptors.
 * The dynamic GDT will have a statically sized virtual memory area of size
 * GDTMAXPAGES, the physical area backing this will be allocated as needed
 * starting with the size needed for holding a copy of the bootstrap gdt.
 *
 * Every CPU in a system has its own copy of the GDT.  The only real difference
 * between the two are currently that there is a cpu-specific segment holding
 * the struct cpu_info of the processor, for simplicity at getting cpu_info
 * fields from assembly.  The boot processor will actually refer to the global
 * copy of the GDT as pointed to by the gdt variable.
 */

#include <sys/cdefs.h>

a42 1
#include <sys/lock.h>
d45 1
a45 1
#include <uvm/uvm.h>
d49 2
a50 7
union descriptor bootstrap_gdt[NGDT];
union descriptor *gdt = bootstrap_gdt;

int gdt_size;		/* total number of GDT entries */
int gdt_count;		/* number of GDT entries in use */
int gdt_next;		/* next available slot for sweeping */
int gdt_free;		/* next free slot; terminated with GNULL_SEL */
d52 9
a60 2
struct simplelock gdt_simplelock;
struct lock gdt_lock_store;
d64 1
a64 1
void gdt_init(void);
d66 1
d73 5
d82 6
a87 1
	lockmgr(&gdt_lock_store, LK_EXCLUSIVE, &gdt_simplelock, curproc);
d93 6
a98 1
	lockmgr(&gdt_lock_store, LK_RELEASE, &gdt_simplelock, curproc);
d101 12
a112 1
/* XXX needs spinlocking if we ever mean to go finegrained. */
d114 1
a114 2
setgdt(int sel, void *base, size_t limit, int type, int dpl, int def32,
    int gran)
d116 35
a150 8
	struct segment_descriptor *sd = &gdt[sel].sd;
	CPU_INFO_ITERATOR cii;
	struct cpu_info *ci;

	setsegment(sd, base, limit, type, dpl, def32, gran);
	for (CPU_INFO_FOREACH(cii, ci))
		if (ci->ci_gdt != NULL && ci->ci_gdt != gdt)
			ci->ci_gdt[sel].sd = *sd;
d154 1
a154 1
 * Initialize the GDT subsystem.  Called from autoconf().
d160 1
a160 6
	struct vm_page *pg;
	vaddr_t va;
	struct cpu_info *ci = &cpu_info_primary;

	simple_lock_init(&gdt_simplelock);
	lockinit(&gdt_lock_store, PZERO, "gdtlck", 0, 0);
a163 1

a164 3
	gdt_count = NGDT;
	gdt_next = NGDT;
	gdt_free = GNULL_SEL;
d166 4
a169 12
	gdt = (union descriptor *)uvm_km_valloc(kernel_map, max_len);
	for (va = (vaddr_t)gdt; va < (vaddr_t)gdt + min_len; va += PAGE_SIZE) {
		pg = uvm_pagealloc(NULL, 0, NULL, UVM_PGA_ZERO);
		if (pg == NULL)
			panic("gdt_init: no pages");
		pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg),
		    VM_PROT_READ | VM_PROT_WRITE);
	}
	bcopy(bootstrap_gdt, gdt, NGDT * sizeof(union descriptor));
	ci->ci_gdt = gdt;
	setsegment(&ci->ci_gdt[GCPU_SEL].sd, ci, sizeof(struct cpu_info)-1,
	    SDT_MEMRWA, SEL_KPL, 1, 1);
d171 2
a172 1
	gdt_init_cpu(ci);
a174 3
/*
 * Allocate shadow GDT for a slave cpu.
 */
d176 1
a176 1
gdt_alloc_cpu(struct cpu_info *ci)
d178 1
a178 11
	int max_len = MAXGDTSIZ * sizeof(union descriptor);
	int min_len = MINGDTSIZ * sizeof(union descriptor);

	ci->ci_gdt = (union descriptor *)uvm_km_valloc(kernel_map, max_len);
	uvm_map_pageable(kernel_map, (vaddr_t)ci->ci_gdt,
	    (vaddr_t)ci->ci_gdt + min_len, FALSE, FALSE);
	bzero(ci->ci_gdt, min_len);
	bcopy(gdt, ci->ci_gdt, gdt_count * sizeof(union descriptor));
	setsegment(&ci->ci_gdt[GCPU_SEL].sd, ci, sizeof(struct cpu_info)-1,
	    SDT_MEMRWA, SEL_KPL, 1, 1);
}
d180 3
d184 2
a185 12
/*
 * Load appropriate gdt descriptor; we better be running on *ci
 * (for the most part, this is how a cpu knows who it is).
 */
void
gdt_init_cpu(struct cpu_info *ci)
{
	struct region_descriptor region;

	setregion(&region, ci->ci_gdt,
	    MAXGDTSIZ * sizeof(union descriptor) - 1);
	lgdt(&region);
a187 3
/*
 * Grow the GDT.
 */
d189 1
a189 1
gdt_grow()
a191 4
	CPU_INFO_ITERATOR cii;
	struct cpu_info *ci;
	struct vm_page *pg;
	vaddr_t va;
d194 4
a197 17
	gdt_size <<= 1;
	new_len = old_len << 1;

	for (CPU_INFO_FOREACH(cii, ci)) {
		for (va = (vaddr_t)(ci->ci_gdt) + old_len;
		     va < (vaddr_t)(ci->ci_gdt) + new_len;
		     va += PAGE_SIZE) {
			while (
			    (pg =
			    uvm_pagealloc(NULL, 0, NULL, UVM_PGA_ZERO)) ==
			    NULL) {
				uvm_wait("gdt_grow");
			}
			pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ | VM_PROT_WRITE);
		}
	}
d217 1
a217 1
		gdt_free = gdt[slot].gd.gd_selector;
d220 1
a220 1
			panic("gdt_get_slot: gdt_next != gdt_count");
d223 3
a225 1
				panic("gdt_get_slot: out of GDT descriptors");
d240 2
a241 1
gdt_put_slot(int slot)
d247 14
a260 3
	gdt[slot].gd.gd_type = SDT_SYSNULL;
	gdt[slot].gd.gd_selector = gdt_free;
	gdt_free = slot;
d271 1
a271 1
	setgdt(slot, &pcb->pcb_tss, sizeof(struct pcb) - 1,
d273 1
a273 1
	return GSEL(slot, SEL_KPL);
a282 3
/*
 * Caller must have pmap locked for both of these functions.
 */
d284 4
a287 1
ldt_alloc(struct pmap *pmap, union descriptor *ldt, size_t len)
d292 3
a294 1
	setgdt(slot, ldt, len - 1, SDT_SYSLDT, SEL_KPL, 0, 0);
d296 1
d300 2
a301 1
ldt_free(struct pmap *pmap)
d305 1
d307 1
@


1.11.6.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 1
@


1.11.6.10
log
@Merge with the trunk
@
text
@d97 1
a97 3
	if (curproc != NULL)
		lockmgr(&gdt_lock_store, LK_EXCLUSIVE, &gdt_simplelock,
		    curproc);
d103 1
a103 2
	if (curproc != NULL)
		lockmgr(&gdt_lock_store, LK_RELEASE, &gdt_simplelock, curproc);
@


1.11.6.11
log
@gdt_alloc_cpu() is SMP-only, save space on install media.

ok niklas@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.11.6.10 2004/06/05 23:08:59 niklas Exp $	*/
a161 1
#ifdef MULTIPROCESSOR
a178 1
#endif	/* MULTIPROCESSOR */
@


1.10
log
@clean & sync
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.9 1996/05/07 07:21:38 deraadt Exp $	*/
d48 4
d172 5
d181 1
d197 4
d203 1
d214 4
a217 1

d220 1
@


1.9
log
@sync with 0504; prototype changes
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.7 1996/04/18 19:18:08 niklas Exp $	*/
a225 10
			/*
			 * gdt_size is clamped by maxproc, set in
			 * /sys/conf/param.c and clamped in init386().
			 * It's held there to (MAXGDTSIZ - NGDT) if no
			 * user LDTs, or half that if user LDTs are
			 * allowed. It's important to count that
			 * correctly, because by the time we get here,
			 * it's too late to abort the fork operation
			 * -- we must have a GDT slot available.
			 */
@


1.8
log
@Pull in John Kohl's [jtk@@netbsd.org] most recent (15Apr96) APM and PCMCIA work
(original PCMCIA framework  by Stefan Grefen [grefen@@convex.com]).
@
text
@d2 1
a2 1
/*	$NetBSD: gdt.c,v 1.7 1996/02/27 22:45:01 jtc Exp $	*/
d63 9
d81 1
a81 1
static inline void
d92 1
a92 1
static inline void
@


1.7
log
@Merge of NetBSD 960317
@
text
@d1 1
a1 1
/*	$OpenBSD: gdt.c,v 1.6 1996/04/17 05:18:52 mickey Exp $	*/
d217 10
@


1.6
log
@Cleanups & fixes from latest NetBSD primarily to run doscmd, etc.
GENERIC added to the compile/.cvsignore (it is used for 'make links'
for example), thus conf/GENERIC should appear magically ...
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 1
a50 1
#define	GDTSTART	64
d150 21
a170 2
gdt_resize(newsize)
	int newsize;
a172 2
	union descriptor *old_gdt, *new_gdt;
	struct region_descriptor region;
d175 2
a176 10
	old_gdt = dynamic_gdt;
	gdt_size = newsize;
	new_len = gdt_size * sizeof(union descriptor);
	new_gdt = (union descriptor *)kmem_alloc(kernel_map, new_len);
	if (new_len > old_len) {
		bcopy(old_gdt, new_gdt, old_len);
		bzero((caddr_t)new_gdt + old_len, new_len - old_len);
	} else
		bcopy(old_gdt, new_gdt, new_len);
	dynamic_gdt = new_gdt;
d178 12
a189 2
	setregion(&region, new_gdt, new_len - 1);
	lgdt(&region);
d191 2
a192 2
	if (old_gdt != gdt)
		kmem_free(kernel_map, (vm_offset_t)old_gdt, old_len);
d220 1
a220 1
				gdt_resize(GDTSTART);
d222 1
a222 1
				gdt_resize(gdt_size * 2);
d250 1
a250 1
	if (gdt_size > GDTSTART && gdt_count < gdt_size / 4) {
d252 1
a252 1
		gdt_resize(gdt_size / 2);
@


1.5
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 2
a2 1
/*	$NetBSD: gdt.c,v 1.6 1996/01/30 12:18:26 mycroft Exp $	*/
d4 33
a36 25
/*
 *  Copyright (c) 1995 Charles M. Hannum.   All rights reserved.
 *  Copyright (c) 1995 John T. Kohl.   All rights reserved.
 * 
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
a37 1
 * 
a113 1
		PHOLD(p);
a134 1
		PRELE(p);
@


1.4
log
@Debbuger changed towards the latest Mach.
Some minor changes for Linux ;) emulation.
Small bug fixes from NetBSD.
@
text
@d1 1
a1 2
/*	$OpenBSD: gdt.c,v 1.3 1996/02/28 14:38:41 mickey Exp $	*/
/*	$NetBSD: gdt.c,v 1.5 1995/11/17 06:47:27 jtc Exp $	*/
d106 1
d128 1
@


1.3
log
@Small changes from NetBSD (including /usr/include dependencies, and so).
@
text
@d1 2
a2 1
/*	$OpenBSD: gdt.c,v 1.5 1995/11/17 06:47:27 jtc Exp $	*/
a106 1
		PHOLD(p);
a127 1
		PRELE(p);
@


1.2
log
@from netbsd; add copyright notice
@
text
@d1 1
a1 1
/*	$NetBSD: gdt.c,v 1.5 1995/11/17 06:47:27 jtc Exp $	*/
d106 1
d128 1
@


1.1
log
@Initial revision
@
text
@d1 31
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
