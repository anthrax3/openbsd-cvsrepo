head	1.48;
access;
symbols
	OPENBSD_6_1:1.48.0.6
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.48.0.2
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.45.0.6
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.45.0.2
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.43.0.4
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.40.0.8
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.40.0.4
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.40.0.2
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.39.0.2
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.4
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.36.0.4
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.36.0.2
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.30.0.8
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.6
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.4
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	SMP:1.5.0.2;
locks; strict;
comment	@ * @;


1.48
date	2016.03.07.05.32.46;	author naddy;	state Exp;
branches;
next	1.47;
commitid	Ht3NH0pdlkYC6Nxx;

1.47
date	2015.09.08.07.12.56;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	UsnEcDGT4QqqoPvB;

1.46
date	2015.09.08.04.28.34;	author semarie;	state Exp;
branches;
next	1.45;
commitid	Ajpcv6B3UUP5Q4Cd;

1.45
date	2014.12.09.06.58.28;	author doug;	state Exp;
branches;
next	1.44;
commitid	yWAxzpQP2PPpYlfT;

1.44
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.43;
commitid	uzzBR7hz9ncd4O6G;

1.43
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.42;
commitid	uKVPYMN2MLxdZxzH;

1.42
date	2014.05.23.03.30.41;	author guenther;	state Exp;
branches;
next	1.41;

1.41
date	2014.05.10.18.59.29;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2012.10.08.09.01.21;	author jsg;	state Exp;
branches;
next	1.39;

1.39
date	2012.03.27.07.04.33;	author jsg;	state Exp;
branches;
next	1.38;

1.38
date	2012.03.27.06.44.01;	author jsg;	state Exp;
branches;
next	1.37;

1.37
date	2011.05.13.11.30.26;	author jasper;	state Exp;
branches;
next	1.36;

1.36
date	2010.07.05.22.47.41;	author jsg;	state Exp;
branches;
next	1.35;

1.35
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2010.03.28.03.09.50;	author marco;	state Exp;
branches;
next	1.33;

1.33
date	2009.12.01.18.31.36;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2009.06.08.23.18.05;	author gwk;	state Exp;
branches;
next	1.31;

1.31
date	2009.06.06.23.21.43;	author gwk;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.07.11.20.58;	author dim;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.07.10.24.30;	author dim;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.24.17.12.26;	author gwk;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.22.01.34.46;	author dim;	state Exp;
branches;
next	1.26;

1.26
date	2006.12.21.22.31.07;	author dim;	state Exp;
branches;
next	1.25;

1.25
date	2006.12.20.17.50.40;	author gwk;	state Exp;
branches;
next	1.24;

1.24
date	2006.12.12.23.14.27;	author dim;	state Exp;
branches;
next	1.23;

1.23
date	2006.11.28.19.58.27;	author dim;	state Exp;
branches;
next	1.22;

1.22
date	2006.11.05.15.10.46;	author dim;	state Exp;
branches;
next	1.21;

1.21
date	2006.10.19.10.55.56;	author tom;	state Exp;
branches;
next	1.20;

1.20
date	2006.09.20.14.09.15;	author dim;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.12.13.18.18;	author dim;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.28.22.06.33;	author dim;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.24.11.44.35;	author dim;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.20.13.31.00;	author dim;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.19.19.43.41;	author dim;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.11.13.21.11;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.27.14.13.10;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.27.05.37.16;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.07.06.59.14;	author mbalmer;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.05.02.13.41;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.16.18.14.23;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.06.17.34.37;	author grange;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.27.21.46.44;	author grange;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.27.21.15.45;	author grange;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.14.15.09.22;	author grange;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2004.01.06.21.09.20;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.19.22.42.13;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.19.05.52.27;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.18.23.46.19;	author tedu;	state Exp;
branches;
next	;

1.5.2.1
date	2004.02.19.10.48.41;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2004.06.05.23.08.59;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2004.06.07.20.41.09;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Sync no-argument function declaration and definition by adding (void).
ok mlarkin@@ deraadt@@
@
text
@/*	$OpenBSD: est.c,v 1.47 2015/09/08 07:12:56 deraadt Exp $ */
/*
 * Copyright (c) 2003 Michael Eriksson.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * This is a driver for Intel's Enhanced SpeedStep, as implemented in
 * Pentium M processors.
 *
 * Reference documentation:
 *
 * - IA-32 Intel Architecture Software Developer's Manual, Volume 3:
 *   System Programming Guide.
 *   Section 13.14, Enhanced Intel SpeedStep technology.
 *   Table B-2, MSRs in Pentium M Processors.
 *   http://www.intel.com/design/pentium4/manuals/245472.htm
 *
 * - Intel Pentium M Processor Datasheet.
 *   Table 5, Voltage and Current Specifications.
 *   http://www.intel.com/design/mobile/datashts/252612.htm
 *
 * - Intel Pentium M Processor on 90 nm Process with 2-MB L2 Cache Datasheet
 *   Table 3-4, Voltage and Current Specifications.
 *   http://www.intel.com/design/mobile/datashts/302189.htm
 *
 * - Linux cpufreq patches, speedstep-centrino.c.
 *   Encoding of MSR_PERF_CTL and MSR_PERF_STATUS.
 *   http://www.codemonkey.org.uk/projects/cpufreq/cpufreq-2.4.22-pre6-1.gz
 */


#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sysctl.h>
#include <sys/malloc.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/specialreg.h>
#include <machine/bus.h>

#include "acpicpu.h"

#if NACPICPU > 0
#include <dev/acpi/acpidev.h>
#include <dev/acpi/acpivar.h>
#endif

/* Convert MHz and mV into IDs for passing to the MSR. */
#define ID16(MHz, mV, bus_clk) \
    { ((((MHz * 100 + 50) / bus_clk) << 8) | ((mV ? mV - 700 : 0) >> 4)), \
	 MHz }

struct est_op {
	uint16_t ctrl;
	uint16_t mhz;
};

/* Ultra Low Voltage Intel Pentium M processor 900 MHz */
static struct est_op pm130_900_ulv[] = {
	ID16( 900, 1004, BUS100),
	ID16( 800,  988, BUS100),
	ID16( 600,  844, BUS100),
};

/* Ultra Low Voltage Intel Pentium M processor 1.00 GHz */
static struct est_op pm130_1000_ulv[] = {
	ID16(1000, 1004, BUS100),
	ID16( 900,  988, BUS100),
	ID16( 800,  972, BUS100),
	ID16( 600,  844, BUS100),
};

/* Ultra Low Voltage Intel Pentium M processor 1.10 GHz */
static struct est_op pm130_1100_ulv[] = {
	ID16(1100, 1004, BUS100),
	ID16(1000,  988, BUS100),
	ID16( 900,  972, BUS100),
	ID16( 800,  956, BUS100),
	ID16( 600,  844, BUS100),
};

/* Low Voltage Intel Pentium M processor 1.10 GHz */
static struct est_op pm130_1100_lv[] = {
	ID16(1100, 1180, BUS100),
	ID16(1000, 1164, BUS100),
	ID16( 900, 1100, BUS100),
	ID16( 800, 1020, BUS100),
	ID16( 600,  956, BUS100),
};

/* Low Voltage Intel Pentium M processor 1.20 GHz */
static struct est_op pm130_1200_lv[] = {
	ID16(1200, 1180, BUS100),
	ID16(1100, 1164, BUS100),
	ID16(1000, 1100, BUS100),
	ID16( 900, 1020, BUS100),
	ID16( 800, 1004, BUS100),
	ID16( 600,  956, BUS100),
};

/* Low Voltage Intel Pentium M processor 1.30 GHz */
static struct est_op pm130_1300_lv[] = {
	ID16(1300, 1180, BUS100),
	ID16(1200, 1164, BUS100),
	ID16(1100, 1100, BUS100),
	ID16(1000, 1020, BUS100),
	ID16( 900, 1004, BUS100),
	ID16( 800,  988, BUS100),
	ID16( 600,  956, BUS100),
};

/* Intel Pentium M processor 1.30 GHz */
static struct est_op pm130_1300[] = {
	ID16(1300, 1388, BUS100),
	ID16(1200, 1356, BUS100),
	ID16(1000, 1292, BUS100),
	ID16( 800, 1260, BUS100),
	ID16( 600,  956, BUS100),
};

/* Intel Pentium M processor 1.40 GHz */
static struct est_op pm130_1400[] = {
	ID16(1400, 1484, BUS100),
	ID16(1200, 1436, BUS100),
	ID16(1000, 1308, BUS100),
	ID16( 800, 1180, BUS100),
	ID16( 600,  956, BUS100),
};

/* Intel Pentium M processor 1.50 GHz */
static struct est_op pm130_1500[] = {
	ID16(1500, 1484, BUS100),
	ID16(1400, 1452, BUS100),
	ID16(1200, 1356, BUS100),
	ID16(1000, 1228, BUS100),
	ID16( 800, 1116, BUS100),
	ID16( 600,  956, BUS100),
};

/* Intel Pentium M processor 1.60 GHz */
static struct est_op pm130_1600[] = {
	ID16(1600, 1484, BUS100),
	ID16(1400, 1420, BUS100),
	ID16(1200, 1276, BUS100),
	ID16(1000, 1164, BUS100),
	ID16( 800, 1036, BUS100),
	ID16( 600,  956, BUS100),
};

/* Intel Pentium M processor 1.70 GHz */
static struct est_op pm130_1700[] = {
	ID16(1700, 1484, BUS100),
	ID16(1400, 1308, BUS100),
	ID16(1200, 1228, BUS100),
	ID16(1000, 1116, BUS100),
	ID16( 800, 1004, BUS100),
	ID16( 600,  956, BUS100),
};

/* Intel Pentium M processor 723 1.0 GHz */
static struct est_op pm90_n723[] = {
	ID16(1000,  940, BUS100),
	ID16( 900,  908, BUS100),
	ID16( 800,  876, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 733 1.1 GHz, VID #G */
static struct est_op pm90_n733g[] = {
	ID16(1100,  956, BUS100),
	ID16(1000,  940, BUS100),
	ID16( 900,  908, BUS100),
	ID16( 800,  876, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 733 1.1 GHz, VID #H */
static struct est_op pm90_n733h[] = {
	ID16(1100,  940, BUS100),
	ID16(1000,  924, BUS100),
	ID16( 900,  892, BUS100),
	ID16( 800,  876, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 733 1.1 GHz, VID #I */
static struct est_op pm90_n733i[] = {
	ID16(1100,  924, BUS100),
	ID16(1000,  908, BUS100),
	ID16( 900,  892, BUS100),
	ID16( 800,  860, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 733 1.1 GHz, VID #J */
static struct est_op pm90_n733j[] = {
	ID16(1100,  908, BUS100),
	ID16(1000,  892, BUS100),
	ID16( 900,  876, BUS100),
	ID16( 800,  860, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 733 1.1 GHz, VID #K */
static struct est_op pm90_n733k[] = {
	ID16(1100,  892, BUS100),
	ID16(1000,  876, BUS100),
	ID16( 900,  860, BUS100),
	ID16( 800,  844, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 733 1.1 GHz, VID #L */
static struct est_op pm90_n733l[] = {
	ID16(1100,  876, BUS100),
	ID16(1000,  876, BUS100),
	ID16( 900,  860, BUS100),
	ID16( 800,  844, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 753 1.2 GHz, VID #G */
static struct est_op pm90_n753g[] = {
	ID16(1200,  956, BUS100),
	ID16(1100,  940, BUS100),
	ID16(1000,  908, BUS100),
	ID16( 900,  892, BUS100),
	ID16( 800,  860, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 753 1.2 GHz, VID #H */
static struct est_op pm90_n753h[] = {
	ID16(1200,  940, BUS100),
	ID16(1100,  924, BUS100),
	ID16(1000,  908, BUS100),
	ID16( 900,  876, BUS100),
	ID16( 800,  860, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 753 1.2 GHz, VID #I */
static struct est_op pm90_n753i[] = {
	ID16(1200,  924, BUS100),
	ID16(1100,  908, BUS100),
	ID16(1000,  892, BUS100),
	ID16( 900,  876, BUS100),
	ID16( 800,  860, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 753 1.2 GHz, VID #J */
static struct est_op pm90_n753j[] = {
	ID16(1200,  908, BUS100),
	ID16(1100,  892, BUS100),
	ID16(1000,  876, BUS100),
	ID16( 900,  860, BUS100),
	ID16( 800,  844, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 753 1.2 GHz, VID #K */
static struct est_op pm90_n753k[] = {
	ID16(1200,  892, BUS100),
	ID16(1100,  892, BUS100),
	ID16(1000,  876, BUS100),
	ID16( 900,  860, BUS100),
	ID16( 800,  844, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 753 1.2 GHz, VID #L */
static struct est_op pm90_n753l[] = {
	ID16(1200,  876, BUS100),
	ID16(1100,  876, BUS100),
	ID16(1000,  860, BUS100),
	ID16( 900,  844, BUS100),
	ID16( 800,  844, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 773 1.3 GHz, VID #G */
static struct est_op pm90_n773g[] = {
	ID16(1300,  956, BUS100),
	ID16(1200,  940, BUS100),
	ID16(1100,  924, BUS100),
	ID16(1000,  908, BUS100),
	ID16( 900,  876, BUS100),
	ID16( 800,  860, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 773 1.3 GHz, VID #H */
static struct est_op pm90_n773h[] = {
	ID16(1300,  940, BUS100),
	ID16(1200,  924, BUS100),
	ID16(1100,  908, BUS100),
	ID16(1000,  892, BUS100),
	ID16( 900,  876, BUS100),
	ID16( 800,  860, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 773 1.3 GHz, VID #I */
static struct est_op pm90_n773i[] = {
	ID16(1300,  924, BUS100),
	ID16(1200,  908, BUS100),
	ID16(1100,  892, BUS100),
	ID16(1000,  876, BUS100),
	ID16( 900,  860, BUS100),
	ID16( 800,  844, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 773 1.3 GHz, VID #J */
static struct est_op pm90_n773j[] = {
	ID16(1300,  908, BUS100),
	ID16(1200,  908, BUS100),
	ID16(1100,  892, BUS100),
	ID16(1000,  876, BUS100),
	ID16( 900,  860, BUS100),
	ID16( 800,  844, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 773 1.3 GHz, VID #K */
static struct est_op pm90_n773k[] = {
	ID16(1300,  892, BUS100),
	ID16(1200,  892, BUS100),
	ID16(1100,  876, BUS100),
	ID16(1000,  860, BUS100),
	ID16( 900,  860, BUS100),
	ID16( 800,  844, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 773 1.3 GHz, VID #L */
static struct est_op pm90_n773l[] = {
	ID16(1300,  876, BUS100),
	ID16(1200,  876, BUS100),
	ID16(1100,  860, BUS100),
	ID16(1000,  860, BUS100),
	ID16( 900,  844, BUS100),
	ID16( 800,  844, BUS100),
	ID16( 600,  812, BUS100),
};

/* Intel Pentium M processor 738 1.4 GHz */
static struct est_op pm90_n738[] = {
	ID16(1400, 1116, BUS100),
	ID16(1300, 1116, BUS100),
	ID16(1200, 1100, BUS100),
	ID16(1100, 1068, BUS100),
	ID16(1000, 1052, BUS100),
	ID16( 900, 1036, BUS100),
	ID16( 800, 1020, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 758 1.5 GHz */
static struct est_op pm90_n758[] = {
	ID16(1500, 1116, BUS100),
	ID16(1400, 1116, BUS100),
	ID16(1300, 1100, BUS100),
	ID16(1200, 1084, BUS100),
	ID16(1100, 1068, BUS100),
	ID16(1000, 1052, BUS100),
	ID16( 900, 1036, BUS100),
	ID16( 800, 1020, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 778 1.6 GHz */
static struct est_op pm90_n778[] = {
	ID16(1600, 1116, BUS100),
	ID16(1500, 1116, BUS100),
	ID16(1400, 1100, BUS100),
	ID16(1300, 1184, BUS100),
	ID16(1200, 1068, BUS100),
	ID16(1100, 1052, BUS100),
	ID16(1000, 1052, BUS100),
	ID16( 900, 1036, BUS100),
	ID16( 800, 1020, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 710 1.4 GHz, 533 MHz FSB */
static struct est_op pm90_n710[] = {
	ID16(1400, 1340, BUS133),
	ID16(1200, 1228, BUS133),
	ID16(1000, 1148, BUS133),
	ID16( 800, 1068, BUS133),
	ID16( 600,  998, BUS133),
};

/* Intel Pentium M processor 715 1.5 GHz, VID #A */
static struct est_op pm90_n715a[] = {
	ID16(1500, 1340, BUS100),
	ID16(1200, 1228, BUS100),
	ID16(1000, 1148, BUS100),
	ID16( 800, 1068, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 715 1.5 GHz, VID #B */
static struct est_op pm90_n715b[] = {
	ID16(1500, 1324, BUS100),
	ID16(1200, 1212, BUS100),
	ID16(1000, 1148, BUS100),
	ID16( 800, 1068, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 715 1.5 GHz, VID #C */
static struct est_op pm90_n715c[] = {
	ID16(1500, 1308, BUS100),
	ID16(1200, 1212, BUS100),
	ID16(1000, 1132, BUS100),
	ID16( 800, 1068, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 715 1.5 GHz, VID #D */
static struct est_op pm90_n715d[] = {
	ID16(1500, 1276, BUS100),
	ID16(1200, 1180, BUS100),
	ID16(1000, 1116, BUS100),
	ID16( 800, 1052, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 725 1.6 GHz, VID #A */
static struct est_op pm90_n725a[] = {
	ID16(1600, 1340, BUS100),
	ID16(1400, 1276, BUS100),
	ID16(1200, 1212, BUS100),
	ID16(1000, 1132, BUS100),
	ID16( 800, 1068, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 725 1.6 GHz, VID #B */
static struct est_op pm90_n725b[] = {
	ID16(1600, 1324, BUS100),
	ID16(1400, 1260, BUS100),
	ID16(1200, 1196, BUS100),
	ID16(1000, 1132, BUS100),
	ID16( 800, 1068, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 725 1.6 GHz, VID #C */
static struct est_op pm90_n725c[] = {
	ID16(1600, 1308, BUS100),
	ID16(1400, 1244, BUS100),
	ID16(1200, 1180, BUS100),
	ID16(1000, 1116, BUS100),
	ID16( 800, 1052, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 725 1.6 GHz, VID #D */
static struct est_op pm90_n725d[] = {
	ID16(1600, 1276, BUS100),
	ID16(1400, 1228, BUS100),
	ID16(1200, 1164, BUS100),
	ID16(1000, 1116, BUS100),
	ID16( 800, 1052, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 730 1.6 GHz, 533 MHz FSB */
static struct est_op pm90_n730[] = {
	ID16(1600, 1308, BUS133),
	ID16(1333, 1260, BUS133),
	ID16(1200, 1212, BUS133),
	ID16(1067, 1180, BUS133),
	ID16( 800,  988, BUS133),
};

/* Intel Pentium M processor 735 1.7 GHz, VID #A */
static struct est_op pm90_n735a[] = {
	ID16(1700, 1340, BUS100),
	ID16(1400, 1244, BUS100),
	ID16(1200, 1180, BUS100),
	ID16(1000, 1116, BUS100),
	ID16( 800, 1052, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 735 1.7 GHz, VID #B */
static struct est_op pm90_n735b[] = {
	ID16(1700, 1324, BUS100),
	ID16(1400, 1244, BUS100),
	ID16(1200, 1180, BUS100),
	ID16(1000, 1116, BUS100),
	ID16( 800, 1052, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 735 1.7 GHz, VID #C */
static struct est_op pm90_n735c[] = {
	ID16(1700, 1308, BUS100),
	ID16(1400, 1228, BUS100),
	ID16(1200, 1164, BUS100),
	ID16(1000, 1116, BUS100),
	ID16( 800, 1052, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 735 1.7 GHz, VID #D */
static struct est_op pm90_n735d[] = {
	ID16(1700, 1276, BUS100),
	ID16(1400, 1212, BUS100),
	ID16(1200, 1148, BUS100),
	ID16(1000, 1100, BUS100),
	ID16( 800, 1052, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 740 1.73 GHz, 533 MHz FSB */
static struct est_op pm90_n740[] = {
	ID16(1733, 1356, BUS133),
	ID16(1333, 1212, BUS133),
	ID16(1067, 1100, BUS133),
	ID16( 800,  988, BUS133),
};

/* Intel Pentium M processor 745 1.8 GHz, VID #A */
static struct est_op pm90_n745a[] = {
	ID16(1800, 1340, BUS100),
	ID16(1600, 1292, BUS100),
	ID16(1400, 1228, BUS100),
	ID16(1200, 1164, BUS100),
	ID16(1000, 1116, BUS100),
	ID16( 800, 1052, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 745 1.8 GHz, VID #B */
static struct est_op pm90_n745b[] = {
	ID16(1800, 1324, BUS100),
	ID16(1600, 1276, BUS100),
	ID16(1400, 1212, BUS100),
	ID16(1200, 1164, BUS100),
	ID16(1000, 1116, BUS100),
	ID16( 800, 1052, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 745 1.8 GHz, VID #C */
static struct est_op pm90_n745c[] = {
	ID16(1800, 1308, BUS100),
	ID16(1600, 1260, BUS100),
	ID16(1400, 1212, BUS100),
	ID16(1200, 1148, BUS100),
	ID16(1000, 1100, BUS100),
	ID16( 800, 1052, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 745 1.8 GHz, VID #D */
static struct est_op pm90_n745d[] = {
	ID16(1800, 1276, BUS100),
	ID16(1600, 1228, BUS100),
	ID16(1400, 1180, BUS100),
	ID16(1200, 1132, BUS100),
	ID16(1000, 1084, BUS100),
	ID16( 800, 1036, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 750 1.86 GHz, 533 MHz FSB */
/* values extracted from \_PR\NPSS (via _PSS) SDST ACPI table */
static struct est_op pm90_n750[] = {
	ID16(1867, 1308, BUS133),
	ID16(1600, 1228, BUS133),
	ID16(1333, 1148, BUS133),
	ID16(1067, 1068, BUS133),
	ID16( 800,  988, BUS133),
};

/* Intel Pentium M processor 755 2.0 GHz, VID #A */
static struct est_op pm90_n755a[] = {
	ID16(2000, 1340, BUS100),
	ID16(1800, 1292, BUS100),
	ID16(1600, 1244, BUS100),
	ID16(1400, 1196, BUS100),
	ID16(1200, 1148, BUS100),
	ID16(1000, 1100, BUS100),
	ID16( 800, 1052, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 755 2.0 GHz, VID #B */
static struct est_op pm90_n755b[] = {
	ID16(2000, 1324, BUS100),
	ID16(1800, 1276, BUS100),
	ID16(1600, 1228, BUS100),
	ID16(1400, 1180, BUS100),
	ID16(1200, 1132, BUS100),
	ID16(1000, 1084, BUS100),
	ID16( 800, 1036, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 755 2.0 GHz, VID #C */
static struct est_op pm90_n755c[] = {
	ID16(2000, 1308, BUS100),
	ID16(1800, 1276, BUS100),
	ID16(1600, 1228, BUS100),
	ID16(1400, 1180, BUS100),
	ID16(1200, 1132, BUS100),
	ID16(1000, 1084, BUS100),
	ID16( 800, 1036, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 755 2.0 GHz, VID #D */
static struct est_op pm90_n755d[] = {
	ID16(2000, 1276, BUS100),
	ID16(1800, 1244, BUS100),
	ID16(1600, 1196, BUS100),
	ID16(1400, 1164, BUS100),
	ID16(1200, 1116, BUS100),
	ID16(1000, 1084, BUS100),
	ID16( 800, 1036, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 760 2.0 GHz, 533 MHz FSB */
static struct est_op pm90_n760[] = {
	ID16(2000, 1356, BUS133),
	ID16(1600, 1244, BUS133),
	ID16(1333, 1164, BUS133),
	ID16(1067, 1084, BUS133),
	ID16( 800,  988, BUS133),
};

/* Intel Pentium M processor 765 2.1 GHz, VID #A */
static struct est_op pm90_n765a[] = {
	ID16(2100, 1340, BUS100),
	ID16(1800, 1276, BUS100),
	ID16(1600, 1228, BUS100),
	ID16(1400, 1180, BUS100),
	ID16(1200, 1132, BUS100),
	ID16(1000, 1084, BUS100),
	ID16( 800, 1036, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 765 2.1 GHz, VID #B */
static struct est_op pm90_n765b[] = {
	ID16(2100, 1324, BUS100),
	ID16(1800, 1260, BUS100),
	ID16(1600, 1212, BUS100),
	ID16(1400, 1180, BUS100),
	ID16(1200, 1132, BUS100),
	ID16(1000, 1084, BUS100),
	ID16( 800, 1036, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 765 2.1 GHz, VID #C */
static struct est_op pm90_n765c[] = {
	ID16(2100, 1308, BUS100),
	ID16(1800, 1244, BUS100),
	ID16(1600, 1212, BUS100),
	ID16(1400, 1164, BUS100),
	ID16(1200, 1116, BUS100),
	ID16(1000, 1084, BUS100),
	ID16( 800, 1036, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 765 2.1 GHz, VID #E */
static struct est_op pm90_n765e[] = {
	ID16(2100, 1356, BUS100),
	ID16(1800, 1292, BUS100),
	ID16(1600, 1244, BUS100),
	ID16(1400, 1196, BUS100),
	ID16(1200, 1148, BUS100),
	ID16(1000, 1100, BUS100),
	ID16( 800, 1052, BUS100),
	ID16( 600,  988, BUS100),
};

/* Intel Pentium M processor 770 2.13 GHz */
static struct est_op pm90_n770[] = {
	ID16(2133, 1356, BUS133),
	ID16(1867, 1292, BUS133),
	ID16(1600, 1212, BUS133),
	ID16(1333, 1148, BUS133),
	ID16(1067, 1068, BUS133),
	ID16( 800,  988, BUS133),
};

/*
 * VIA C7-M 500 MHz FSB, 400 MHz FSB, and ULV variants.
 * Data from the "VIA C7-M Processor BIOS Writer's Guide (v2.17)" datasheet.
 */

/* 1.00GHz Centaur C7-M ULV */
static struct est_op C7M_770_ULV[] = {
	ID16(1000,  844, BUS100),
	ID16( 800,  796, BUS100),
	ID16( 600,  796, BUS100),
	ID16( 400,  796, BUS100),
};

/* 1.00GHz Centaur C7-M ULV */
static struct est_op C7M_779_ULV[] = {
	ID16(1000,  796, BUS100),
	ID16( 800,  796, BUS100),
	ID16( 600,  796, BUS100),
	ID16( 400,  796, BUS100),
};

/* 1.20GHz Centaur C7-M ULV */
static struct est_op C7M_772_ULV[] = {
	ID16(1200,  844, BUS100),
	ID16(1000,  844, BUS100),
	ID16( 800,  828, BUS100),
	ID16( 600,  796, BUS100),
	ID16( 400,  796, BUS100),
};

/* 1.50GHz Centaur C7-M ULV */
static struct est_op C7M_775_ULV[] = {
	ID16(1500,  956, BUS100),
	ID16(1400,  940, BUS100),
	ID16(1000,  860, BUS100),
	ID16( 800,  828, BUS100),
	ID16( 600,  796, BUS100),
	ID16( 400,  796, BUS100),
};

/* 1.20GHz Centaur C7-M 400 MHz FSB */
static struct est_op C7M_771[] = {
	ID16(1200,  860, BUS100),
	ID16(1000,  860, BUS100),
	ID16( 800,  844, BUS100),
	ID16( 600,  844, BUS100),
	ID16( 400,  844, BUS100),
};

/* 1.50GHz Centaur C7-M 400 MHz FSB */
static struct est_op C7M_754[] = {
	ID16(1500, 1004, BUS100),
	ID16(1400,  988, BUS100),
	ID16(1000,  940, BUS100),
	ID16( 800,  844, BUS100),
	ID16( 600,  844, BUS100),
	ID16( 400,  844, BUS100),
};

/* 1.60GHz Centaur C7-M 400 MHz FSB */
static struct est_op C7M_764[] = {
	ID16(1600, 1084, BUS100),
	ID16(1400, 1052, BUS100),
	ID16(1000, 1004, BUS100),
	ID16( 800,  844, BUS100),
	ID16( 600,  844, BUS100),
	ID16( 400,  844, BUS100),
};

/* 1.80GHz Centaur C7-M 400 MHz FSB */
static struct est_op C7M_784[] = {
	ID16(1800, 1148, BUS100),
	ID16(1600, 1100, BUS100),
	ID16(1400, 1052, BUS100),
	ID16(1000, 1004, BUS100),
	ID16( 800,  844, BUS100),
	ID16( 600,  844, BUS100),
	ID16( 400,  844, BUS100),
};

/* 2.00GHz Centaur C7-M 400 MHz FSB */
static struct est_op C7M_794[] = {
	ID16(2000, 1148, BUS100),
	ID16(1800, 1132, BUS100),
	ID16(1600, 1100, BUS100),
	ID16(1400, 1052, BUS100),
	ID16(1000, 1004, BUS100),
	ID16( 800,  844, BUS100),
	ID16( 600,  844, BUS100),
	ID16( 400,  844, BUS100),
};

/* 1.60GHz Centaur C7-M 533 MHz FSB */
static struct est_op C7M_765[] = {
	ID16(1600, 1084, BUS133),
	ID16(1467, 1052, BUS133),
	ID16(1200, 1004, BUS133),
	ID16( 800,  844, BUS133),
	ID16( 667,  844, BUS133),
	ID16( 533,  844, BUS133),
};

/* 2.00GHz Centaur C7-M 533 MHz FSB */
static struct est_op C7M_785[] = {
	ID16(1867, 1148, BUS133),
	ID16(1600, 1100, BUS133),
	ID16(1467, 1052, BUS133),
	ID16(1200, 1004, BUS133),
	ID16( 800,  844, BUS133),
	ID16( 667,  844, BUS133),
	ID16( 533,  844, BUS133),
};

/* 2.00GHz Centaur C7-M 533 MHz FSB */
static struct est_op C7M_795[] = {
	ID16(2000, 1148, BUS133),
	ID16(1867, 1132, BUS133),
	ID16(1600, 1100, BUS133),
	ID16(1467, 1052, BUS133),
	ID16(1200, 1004, BUS133),
	ID16( 800,  844, BUS133),
	ID16( 667,  844, BUS133),
	ID16( 533,  844, BUS133),
};

/* 1.00GHz VIA Eden 90nm 'Esther' */
static struct est_op eden90_1000[] = {
	ID16(1000,  844, BUS100),
	ID16( 800,  844, BUS100),
	ID16( 600,  844, BUS100),
	ID16( 400,  844, BUS100),
};


struct fqlist {
	int vendor: 5;
	unsigned bus_clk : 1;
	unsigned n : 5;
	struct est_op *table;
};

#define ENTRY(ven, bus_clk, tab) \
	{ CPUVENDOR_##ven, bus_clk == BUS133 ? 1 : 0, nitems(tab), tab }

#define BUS_CLK(fqp) ((fqp)->bus_clk ? BUS133 : BUS100)

static struct fqlist est_cpus[] = {
	ENTRY(INTEL, BUS100, pm130_900_ulv),
	ENTRY(INTEL, BUS100, pm130_1000_ulv),
	ENTRY(INTEL, BUS100, pm130_1100_ulv),
	ENTRY(INTEL, BUS100, pm130_1100_lv),
	ENTRY(INTEL, BUS100, pm130_1200_lv),
	ENTRY(INTEL, BUS100, pm130_1300_lv),
	ENTRY(INTEL, BUS100, pm130_1300),
	ENTRY(INTEL, BUS100, pm130_1400),
	ENTRY(INTEL, BUS100, pm130_1500),
	ENTRY(INTEL, BUS100, pm130_1600),
	ENTRY(INTEL, BUS100, pm130_1700),

	ENTRY(INTEL, BUS100, pm90_n723),
	ENTRY(INTEL, BUS100, pm90_n733g),
	ENTRY(INTEL, BUS100, pm90_n733h),
	ENTRY(INTEL, BUS100, pm90_n733i),
	ENTRY(INTEL, BUS100, pm90_n733j),
	ENTRY(INTEL, BUS100, pm90_n733k),
	ENTRY(INTEL, BUS100, pm90_n733l),
	ENTRY(INTEL, BUS100, pm90_n753g),
	ENTRY(INTEL, BUS100, pm90_n753h),
	ENTRY(INTEL, BUS100, pm90_n753i),
	ENTRY(INTEL, BUS100, pm90_n753j),
	ENTRY(INTEL, BUS100, pm90_n753k),
	ENTRY(INTEL, BUS100, pm90_n753l),
	ENTRY(INTEL, BUS100, pm90_n773g),
	ENTRY(INTEL, BUS100, pm90_n773h),
	ENTRY(INTEL, BUS100, pm90_n773i),
	ENTRY(INTEL, BUS100, pm90_n773j),
	ENTRY(INTEL, BUS100, pm90_n773k),
	ENTRY(INTEL, BUS100, pm90_n773l),
	ENTRY(INTEL, BUS100, pm90_n738),
	ENTRY(INTEL, BUS100, pm90_n758),
	ENTRY(INTEL, BUS100, pm90_n778),

	ENTRY(INTEL, BUS133, pm90_n710),
	ENTRY(INTEL, BUS100, pm90_n715a),
	ENTRY(INTEL, BUS100, pm90_n715b),
	ENTRY(INTEL, BUS100, pm90_n715c),
	ENTRY(INTEL, BUS100, pm90_n715d),
	ENTRY(INTEL, BUS100, pm90_n725a),
	ENTRY(INTEL, BUS100, pm90_n725b),
	ENTRY(INTEL, BUS100, pm90_n725c),
	ENTRY(INTEL, BUS100, pm90_n725d),
	ENTRY(INTEL, BUS133, pm90_n730),
	ENTRY(INTEL, BUS100, pm90_n735a),
	ENTRY(INTEL, BUS100, pm90_n735b),
	ENTRY(INTEL, BUS100, pm90_n735c),
	ENTRY(INTEL, BUS100, pm90_n735d),
	ENTRY(INTEL, BUS133, pm90_n740),
	ENTRY(INTEL, BUS100, pm90_n745a),
	ENTRY(INTEL, BUS100, pm90_n745b),
	ENTRY(INTEL, BUS100, pm90_n745c),
	ENTRY(INTEL, BUS100, pm90_n745d),
	ENTRY(INTEL, BUS133, pm90_n750),
	ENTRY(INTEL, BUS100, pm90_n755a),
	ENTRY(INTEL, BUS100, pm90_n755b),
	ENTRY(INTEL, BUS100, pm90_n755c),
	ENTRY(INTEL, BUS100, pm90_n755d),
	ENTRY(INTEL, BUS133, pm90_n760),
	ENTRY(INTEL, BUS100, pm90_n765a),
	ENTRY(INTEL, BUS100, pm90_n765b),
	ENTRY(INTEL, BUS100, pm90_n765c),
	ENTRY(INTEL, BUS100, pm90_n765e),
	ENTRY(INTEL, BUS133, pm90_n770),

	ENTRY(VIA,   BUS100, C7M_770_ULV),
	ENTRY(VIA,   BUS100, C7M_779_ULV),
	ENTRY(VIA,   BUS100, C7M_772_ULV),
	ENTRY(VIA,   BUS100, C7M_771),
	ENTRY(VIA,   BUS100, C7M_775_ULV),
	ENTRY(VIA,   BUS100, C7M_754),
	ENTRY(VIA,   BUS100, C7M_764),
	ENTRY(VIA,   BUS133, C7M_765),
	ENTRY(VIA,   BUS100, C7M_784),
	ENTRY(VIA,   BUS133, C7M_785),
	ENTRY(VIA,   BUS100, C7M_794),
	ENTRY(VIA,   BUS133, C7M_795),

	ENTRY(VIA,   BUS100, eden90_1000),
};

#define MSR2MHZ(msr, bus) \
	(((((int) (msr) >> 8) & 0xff) * (bus) + 50) / 100)
#define MSR2MV(msr) \
	(((int) (msr) & 0xff) * 16 + 700)

static struct fqlist *est_fqlist;

extern int setperf_prio;
extern int perflevel;

void p4_get_bus_clock(struct cpu_info *);
void p3_get_bus_clock(struct cpu_info *);
void cyrix3_get_bus_clock(struct cpu_info *);

#if NACPICPU > 0
struct fqlist * est_acpi_init(void);
void est_acpi_pss_changed(struct acpicpu_pss *, int);

struct fqlist *
est_acpi_init(void)
{
	struct acpicpu_pss *pss;
	struct fqlist *acpilist;
	int nstates, i;

	if ((nstates = acpicpu_fetch_pss(&pss)) == 0)
		goto nolist;

	if ((acpilist = malloc(sizeof(struct fqlist), M_DEVBUF, M_NOWAIT))
	    == NULL)
		goto nolist;

	if ((acpilist->table = mallocarray(nstates, sizeof(struct est_op),
	    M_DEVBUF, M_NOWAIT)) == NULL)
		goto notable;

	acpilist->n = nstates;

	for (i = 0; i < nstates; i++) {
		acpilist->table[i].mhz = pss[i].pss_core_freq;
		acpilist->table[i].ctrl = pss[i].pss_ctrl;
	}

	acpicpu_set_notify(est_acpi_pss_changed);

	return acpilist;

notable:
	free(acpilist, M_DEVBUF, sizeof(*acpilist));
	acpilist = NULL;
nolist:
	return NULL;
}

void
est_acpi_pss_changed(struct acpicpu_pss *pss, int npss)
{
	struct fqlist *acpilist;
	int needtran = 1, i;
	u_int64_t msr;
	u_int16_t cur;

	msr = rdmsr(MSR_PERF_STATUS);
	cur = msr & 0xffff;

	if ((acpilist = malloc(sizeof(struct fqlist), M_DEVBUF, M_NOWAIT))
	    == NULL) {
		printf("est_acpi_pss_changed: cannot allocate memory for new "
		    "est state");
		return;
	}

	if ((acpilist->table = mallocarray(npss, sizeof(struct est_op),
	    M_DEVBUF, M_NOWAIT)) == NULL) {
		printf("est_acpi_pss_changed: cannot allocate memory for new "
		    "operating points");
		free(acpilist, M_DEVBUF, sizeof(*acpilist));
		return;
	}

	for (i = 0; i < npss; i++) {
		acpilist->table[i].mhz = pss[i].pss_core_freq;
		acpilist->table[i].ctrl = pss[i].pss_ctrl;
		if (pss[i].pss_ctrl == cur)
			needtran = 0;
	}

	free(est_fqlist->table, M_DEVBUF, 0);
	free(est_fqlist, M_DEVBUF, sizeof *est_fqlist);
	est_fqlist = acpilist;

	if (needtran) {
		est_setperf(perflevel);
	}
}
#endif

void
est_init(struct cpu_info *ci, int vendor)
{
	const char *cpu_device = ci->ci_dev.dv_xname;
	int i, low, high;
	u_int64_t msr;
	u_int16_t idhi, idlo, cur;
	u_int8_t crhi, crlo, crcur;
	struct fqlist *fql;
	struct fqlist *fake_fqlist;
	struct est_op *fake_table;

	if (setperf_prio > 3)
		return;

#if NACPICPU > 0
	est_fqlist = est_acpi_init();
#endif

	/* bus_clock is only used if we can't get values from ACPI */
	if (est_fqlist == NULL) {
		if (vendor == CPUVENDOR_VIA)
			cyrix3_get_bus_clock(ci);
		else if (ci->ci_family == 0xf)
			p4_get_bus_clock(ci);
		else if (ci->ci_family == 6)
			p3_get_bus_clock(ci);
	}

	/*
	 * Interpreting the values of PERF_STATUS is not valid
	 * on recent processors so don't do it on anything unknown
	 */
	if (est_fqlist == NULL && bus_clock != 0) {
		msr = rdmsr(MSR_PERF_STATUS);
		idhi = (msr >> 32) & 0xffff;
		idlo = (msr >> 48) & 0xffff;
		cur = msr & 0xffff;
		crhi = (idhi  >> 8) & 0xff;
		crlo = (idlo  >> 8) & 0xff;
		crcur = (cur >> 8) & 0xff;
		/*
		 * Find an entry which matches (vendor, bus_clock, idhi, idlo)
		 */
		for (i = 0; i < nitems(est_cpus); i++) {
			fql = &est_cpus[i];
			if (vendor == fql->vendor && bus_clock == BUS_CLK(fql)
			    && idhi == fql->table[0].ctrl
			    && idlo == fql->table[fql->n - 1].ctrl) {
				est_fqlist = fql;
				break;
			}
		}
	}

	if (est_fqlist == NULL && bus_clock != 0) {
		if (crhi == 0 || crcur == 0 || crlo > crhi ||
		    crcur < crlo || crcur > crhi) {
			/*
			 * Do complain about other weirdness, because we first
			 * want to know about it, before we decide what to do
			 * with it.
			 */
			printf("%s: EST: strange msr value 0x%016llx\n",
			    cpu_device, msr);
			return;
		}
		if (crlo == 0 || crhi == crlo) {
			/*
			 * Don't complain about these cases, and silently
			 * disable EST: - A lowest clock ratio of 0, which
			 * seems to happen on all Pentium 4's that report EST.
			 * - An equal highest and lowest clock ratio, which
			 * happens on at least the Core 2 Duo X6800, maybe on 
			 * newer models too.
			 */
			return;
		}

		printf("%s: unknown Enhanced SpeedStep CPU, msr 0x%016llx\n",
		    cpu_device, msr);
		/*
		 * Generate a fake table with the power states we know.
		 */

		if ((fake_fqlist = malloc(sizeof(struct fqlist), M_DEVBUF,
		    M_NOWAIT)) == NULL) {
			printf("%s: EST: cannot allocate memory for fake "
			    "list\n", cpu_device);
			return;
		}


		if ((fake_table = mallocarray(3, sizeof(struct est_op),
		    M_DEVBUF, M_NOWAIT)) == NULL) {
			free(fake_fqlist, M_DEVBUF, 0);
			printf("%s: EST: cannot allocate memory for fake "
			    "table\n", cpu_device);
			return;
		}
		fake_table[0].ctrl = idhi;
		fake_table[0].mhz = MSR2MHZ(idhi, bus_clock);
		if (cur == idhi || cur == idlo) {
			printf("%s: using only highest and lowest power "
			       "states\n", cpu_device);

			fake_table[1].ctrl = idlo;
			fake_table[1].mhz = MSR2MHZ(idlo, bus_clock);
			fake_fqlist->n = 2;
		} else {
			printf("%s: using only highest, current and lowest "
			    "power states\n", cpu_device);

			fake_table[1].ctrl = cur;
			fake_table[1].mhz = MSR2MHZ(cur, bus_clock);

			fake_table[2].ctrl = idlo;
			fake_table[2].mhz = MSR2MHZ(idlo, bus_clock);
			fake_fqlist->n = 3;
		}

		fake_fqlist->vendor = vendor;
		fake_fqlist->table = fake_table;
		est_fqlist = fake_fqlist;
	}

	if (est_fqlist == NULL)
		return;

	if (est_fqlist->n < 2)
		goto nospeedstep;

	low = est_fqlist->table[est_fqlist->n - 1].mhz;
	high = est_fqlist->table[0].mhz;
	if (low == high)
		goto nospeedstep;

	perflevel = (cpuspeed - low) * 100 / (high - low);

	printf("%s: Enhanced SpeedStep %d MHz", cpu_device, cpuspeed);

	/*
	 * OK, tell the user the available frequencies.
	 */
	printf(": speeds: ");
	for (i = 0; i < est_fqlist->n; i++)
		printf("%d%s", est_fqlist->table[i].mhz, i < est_fqlist->n - 1
		    ?  ", " : " MHz\n");

	cpu_setperf = est_setperf;
	setperf_prio = 3;

	return;

nospeedstep:
	/*
	 * While est_fqlist can point into the static est_cpus[],
	 * it can't fail in that case and therefore can't reach here.
	 */
	free(est_fqlist->table, M_DEVBUF, 0);
	free(est_fqlist, M_DEVBUF, 0);
}

void
est_setperf(int level)
{
	int i;
	uint64_t msr;

	if (est_fqlist == NULL)
		return;

	i = ((level * est_fqlist->n) + 1) / 101;
	if (i >= est_fqlist->n)
		i = est_fqlist->n - 1;
	i = est_fqlist->n - 1 - i;

	msr = rdmsr(MSR_PERF_CTL);
	msr &= ~0xffffULL;
	msr |= est_fqlist->table[i].ctrl;

	wrmsr(MSR_PERF_CTL, msr);
	cpuspeed = est_fqlist->table[i].mhz;
}
@


1.47
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.46 2015/09/08 04:28:34 semarie Exp $ */
d971 1
a971 1
est_acpi_init()
@


1.46
log
@convert several malloc(9) to mallocarray(9).

ok deraadt@@ guenther@@ "re-wrap the long lines" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.45 2014/12/09 06:58:28 doug Exp $ */
d1000 1
a1000 1
	free(acpilist, M_DEVBUF, 0);
d1028 1
a1028 1
		free(acpilist, M_DEVBUF, 0);
d1040 1
a1040 1
	free(est_fqlist, M_DEVBUF, 0);
@


1.45
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.44 2014/09/14 14:17:23 jsg Exp $ */
d1142 2
a1143 2
		if ((fake_table = malloc(sizeof(struct est_op) * 3, M_DEVBUF,
		     M_NOWAIT)) == NULL) {
@


1.44
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.43 2014/07/12 18:44:41 tedu Exp $ */
d984 1
a984 1
	if ((acpilist->table = malloc(sizeof(struct est_op) * nstates,
d1024 1
a1024 1
	if ((acpilist->table = malloc(sizeof(struct est_op) * npss,
@


1.43
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.42 2014/05/23 03:30:41 guenther Exp $ */
a57 1
#include <sys/proc.h>
@


1.42
log
@Free the est_fqlist allocations if we end up not using it.

suggested by Benjamin Baier (programmer (at) netzbasis.de)
ok and comment suggestion kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.41 2014/05/10 18:59:29 guenther Exp $ */
d1001 1
a1001 1
	free(acpilist, M_DEVBUF);
d1029 1
a1029 1
		free(acpilist, M_DEVBUF);
d1040 2
a1041 2
	free(est_fqlist->table, M_DEVBUF);
	free(est_fqlist, M_DEVBUF);
d1145 1
a1145 1
			free(fake_fqlist, M_DEVBUF);
d1209 2
a1210 2
	free(est_fqlist->table, M_DEVBUF);
	free(est_fqlist, M_DEVBUF);
@


1.41
log
@Disable speedstep instead of panicing if the high and low speeds are the same.

Problem noted by Benjamin Baier (programmer (at) netzbasis.de)
improvements and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.40 2012/10/08 09:01:21 jsg Exp $ */
d1180 1
a1180 1
		return;
d1185 1
a1185 1
		return;
d1201 10
@


1.40
log
@reduce the difference between i386 and amd64 versions of the speedstep code
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.39 2012/03/27 07:04:33 jsg Exp $ */
a1181 2
	printf("%s: Enhanced SpeedStep %d MHz", cpu_device, cpuspeed);

d1184 3
d1188 2
@


1.39
log
@only attempt to calculate bus_clock if we can't get tables from acpi
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.38 2012/03/27 06:44:01 jsg Exp $ */
d985 1
a985 1
	if ((acpilist->table = malloc(sizeof( struct est_op) * nstates,
d1025 1
a1025 1
	if ((acpilist->table = malloc(sizeof( struct est_op) * npss,
a1064 11
	if ((cpu_ecxfeature & CPUIDECX_EST) == 0)
		return;

	msr = rdmsr(MSR_PERF_STATUS);
	idhi = (msr >> 32) & 0xffff;
	idlo = (msr >> 48) & 0xffff;
	cur = msr & 0xffff;
	crhi = (idhi  >> 8) & 0xff;
	crlo = (idlo  >> 8) & 0xff;
	crcur = (cur >> 8) & 0xff;

d1084 7
d1117 1
a1117 1
		if   (crlo == 0 || crhi == crlo) {
d1120 1
a1120 1
			 * disable EST: - A lowest clock ratio of 0, which 
d1122 1
a1122 1
			 * - And equal highest and lowest clock ratio, which 
d1137 2
a1138 2
			printf("%s: EST: cannot allocate memory for fake list",
			    cpu_device);
@


1.38
log
@Make the bus_clock calculations happen later in the boot process so
they can be conditionally called in future.

This makes the i386 speedstep code closer to the amd64 code
(though still with the added complications of VIA support and the
*_update_cpuspeed callbacks)
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.37 2011/05/13 11:30:26 jasper Exp $ */
d1080 9
a1088 6
	if (vendor == CPUVENDOR_VIA)
		cyrix3_get_bus_clock(ci);
	else if (ci->ci_family == 0xf)
		p4_get_bus_clock(ci);
	else if (ci->ci_family == 6)
		p3_get_bus_clock(ci);
@


1.37
log
@replace handrolled NELEM() with nitems()

no binary change

from vadim zhukov
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.36 2010/07/05 22:47:41 jsg Exp $ */
d963 4
d1051 1
a1051 1
est_init(const char *cpu_device, int vendor)
d1053 1
d1079 7
@


1.36
log
@Rework somewhat for safety, so that we only interpret the values of
the PERF_STATUS MSR on earlier processors when we can't find the values
via acpi and have a bus clock value to use.  And let processors we
don't set a bus clock on (ie nehalem) use speedstep again.

Expanded/changed version of a diff from gwk who isn't around right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.35 2010/04/20 22:05:41 tedu Exp $ */
a864 2
#define NELEM(x) (sizeof(x) / sizeof((x)[0]))

d866 1
a866 1
	{ CPUVENDOR_##ven, bus_clk == BUS133 ? 1 : 0, NELEM(tab), tab }
d1083 1
a1083 1
		for (i = 0; i < NELEM(est_cpus); i++) {
@


1.35
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.34 2010/03/28 03:09:50 marco Exp $ */
a1064 6
	if (bus_clock == 0) {
		printf("%s: EST: PSS not yet available for this processor\n",
		    cpu_device);
		return;
	}

d1077 5
a1081 1
	if (est_fqlist == NULL) {
d1096 1
a1096 6
	if (est_fqlist == NULL) {
		if (bus_clock == 0) {
			printf("%s: EST: unknown system bus clock\n",
			    cpu_device);
			return;
		}
@


1.34
log
@Remove uninitialized nitems and use npss as $deity intended.
Found by clang and krw

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.33 2009/12/01 18:31:36 jsg Exp $ */
d58 1
@


1.33
log
@The MD ACPI PSS paths are using MSRs they shouldn't be
so don't try to do EST on machines we don't know the
bus_clock on for now.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.32 2009/06/08 23:18:05 gwk Exp $ */
d1008 1
a1008 1
	int needtran = 1, nstates, i;
d1022 1
a1022 1
	if ((acpilist->table = malloc(sizeof( struct est_op) * nstates,
d1030 1
a1030 1
	for (i = 0; i < nstates; i++) {
@


1.32
log
@If the machine only has one state enabling the EST driver is pointless,
this might need to be revisted later if its clear that there are machines
which only come up with a single state but more may appear after a PPC
change but for now we will just not initilize on systems with a single
state a boot. Solves a divide by zero panic when using the PDC diff on
broken hardware.

ok marco@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.31 2009/06/06 23:21:43 gwk Exp $ */
d1063 6
@


1.31
log
@Update est.c, make it capable of using ACPI if the PSS is available but
still support all different methods of getting states without e.g.
(highest/lowest state), and on i386 use the tables. The only change
should be the deletion of the mV from the printf at boot.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.30 2007/06/07 11:20:58 dim Exp $ */
d1168 3
@


1.30
log
@Replace magic bus clock constants in est related files with defines.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.29 2007/06/07 10:24:30 dim Exp $ */
d59 1
d64 1
d66 6
d75 2
a76 1
	((((MHz * 100 + 50) / bus_clk) << 8) | ((mV ? mV - 700 : 0) >> 4))
d78 4
d84 1
a84 1
static const u_int16_t pm130_900_ulv[] = {
d91 1
a91 1
static const u_int16_t pm130_1000_ulv[] = {
d99 1
a99 1
static const u_int16_t pm130_1100_ulv[] = {
d108 1
a108 1
static const u_int16_t pm130_1100_lv[] = {
d117 1
a117 1
static const u_int16_t pm130_1200_lv[] = {
d127 1
a127 1
static const u_int16_t pm130_1300_lv[] = {
d138 1
a138 1
static const u_int16_t pm130_1300[] = {
d147 1
a147 1
static const u_int16_t pm130_1400[] = {
d156 1
a156 1
static const u_int16_t pm130_1500[] = {
d166 1
a166 1
static const u_int16_t pm130_1600[] = {
d176 1
a176 1
static const u_int16_t pm130_1700[] = {
d186 1
a186 1
static const u_int16_t pm90_n723[] = {
d194 1
a194 1
static const u_int16_t pm90_n733g[] = {
d203 1
a203 1
static const u_int16_t pm90_n733h[] = {
d212 1
a212 1
static const u_int16_t pm90_n733i[] = {
d221 1
a221 1
static const u_int16_t pm90_n733j[] = {
d230 1
a230 1
static const u_int16_t pm90_n733k[] = {
d239 1
a239 1
static const u_int16_t pm90_n733l[] = {
d248 1
a248 1
static const u_int16_t pm90_n753g[] = {
d258 1
a258 1
static const u_int16_t pm90_n753h[] = {
d268 1
a268 1
static const u_int16_t pm90_n753i[] = {
d278 1
a278 1
static const u_int16_t pm90_n753j[] = {
d288 1
a288 1
static const u_int16_t pm90_n753k[] = {
d298 1
a298 1
static const u_int16_t pm90_n753l[] = {
d308 1
a308 1
static const u_int16_t pm90_n773g[] = {
d319 1
a319 1
static const u_int16_t pm90_n773h[] = {
d330 1
a330 1
static const u_int16_t pm90_n773i[] = {
d341 1
a341 1
static const u_int16_t pm90_n773j[] = {
d352 1
a352 1
static const u_int16_t pm90_n773k[] = {
d363 1
a363 1
static const u_int16_t pm90_n773l[] = {
d374 1
a374 1
static const u_int16_t pm90_n738[] = {
d386 1
a386 1
static const u_int16_t pm90_n758[] = {
d399 1
a399 1
static const u_int16_t pm90_n778[] = {
d413 1
a413 1
static const u_int16_t pm90_n710[] = {
d422 1
a422 1
static const u_int16_t pm90_n715a[] = {
d431 1
a431 1
static const u_int16_t pm90_n715b[] = {
d440 1
a440 1
static const u_int16_t pm90_n715c[] = {
d449 1
a449 1
static const u_int16_t pm90_n715d[] = {
d458 1
a458 1
static const u_int16_t pm90_n725a[] = {
d468 1
a468 1
static const u_int16_t pm90_n725b[] = {
d478 1
a478 1
static const u_int16_t pm90_n725c[] = {
d488 1
a488 1
static const u_int16_t pm90_n725d[] = {
d498 1
a498 1
static const u_int16_t pm90_n730[] = {
d507 1
a507 1
static const u_int16_t pm90_n735a[] = {
d517 1
a517 1
static const u_int16_t pm90_n735b[] = {
d527 1
a527 1
static const u_int16_t pm90_n735c[] = {
d537 1
a537 1
static const u_int16_t pm90_n735d[] = {
d547 1
a547 1
static const u_int16_t pm90_n740[] = {
d555 1
a555 1
static const u_int16_t pm90_n745a[] = {
d566 1
a566 1
static const u_int16_t pm90_n745b[] = {
d577 1
a577 1
static const u_int16_t pm90_n745c[] = {
d588 1
a588 1
static const u_int16_t pm90_n745d[] = {
d600 1
a600 1
static const u_int16_t pm90_n750[] = {
d609 1
a609 1
static const u_int16_t pm90_n755a[] = {
d621 1
a621 1
static const u_int16_t pm90_n755b[] = {
d633 1
a633 1
static const u_int16_t pm90_n755c[] = {
d645 1
a645 1
static const u_int16_t pm90_n755d[] = {
d657 1
a657 1
static const u_int16_t pm90_n760[] = {
d666 1
a666 1
static const u_int16_t pm90_n765a[] = {
d678 1
a678 1
static const u_int16_t pm90_n765b[] = {
d690 1
a690 1
static const u_int16_t pm90_n765c[] = {
d702 1
a702 1
static const u_int16_t pm90_n765e[] = {
d714 1
a714 1
static const u_int16_t pm90_n770[] = {
d729 1
a729 1
static const u_int16_t C7M_770_ULV[] = {
d737 1
a737 1
static const u_int16_t C7M_779_ULV[] = {
d745 1
a745 1
static const u_int16_t C7M_772_ULV[] = {
d754 1
a754 1
static const u_int16_t C7M_775_ULV[] = {
d764 1
a764 1
static const u_int16_t C7M_771[] = {
d773 1
a773 1
static const u_int16_t C7M_754[] = {
d783 1
a783 1
static const u_int16_t C7M_764[] = {
d793 1
a793 1
static const u_int16_t C7M_784[] = {
d804 1
a804 1
static const u_int16_t C7M_794[] = {
d816 1
a816 1
static const u_int16_t C7M_765[] = {
d826 1
a826 1
static const u_int16_t C7M_785[] = {
d837 1
a837 1
static const u_int16_t C7M_795[] = {
d849 1
a849 1
static const u_int16_t eden90_1000[] = {
d856 1
d858 1
a858 1
	int vendor : 5;
d861 1
a861 1
	const u_int16_t *table;
d871 1
a871 1
static const struct fqlist est_cpus[] = {
a953 1

d959 1
a959 4
static const struct fqlist *est_fqlist;

static u_int16_t fake_table[3];
static struct fqlist fake_fqlist;
d964 83
d1050 1
a1050 1
	int i, mhz, mv, low, high;
d1054 3
a1056 1
	const struct fqlist *fql;
a1063 5
	if (bus_clock == 0) {
		printf("%s: EST: unknown system bus clock\n", cpu_device);
		return;
	}

d1071 6
a1076 1
	if (crlo == 0 || crhi == crlo) {
d1078 1
a1078 5
		 * Don't complain about these cases, and silently disable EST:
		 * - A lowest clock ratio of 0, which seems to happen on all
		 *   Pentium 4's that report EST.
		 * - An equal highest and lowest clock ratio, which happens on
		 *   at least the Core 2 Duo X6800, maybe on newer models too.
d1080 8
a1087 21
		return;
	}
	if (crhi == 0 || crcur == 0 || crlo > crhi ||
	    crcur < crlo || crcur > crhi) {
		/*
		 * Do complain about other weirdness, because we first want to
		 * know about it, before we decide what to do with it.
		 */
		printf("%s: EST: strange msr value 0x%016llx\n",
		    cpu_device, msr);
		return;
	}
	/*
	 * Find an entry which matches (vendor, bus_clock, idhi, idlo)
	 */
	for (i = 0; i < NELEM(est_cpus); i++) {
		fql = &est_cpus[i];
		if (vendor == fql->vendor && bus_clock == BUS_CLK(fql) &&
		    idhi == fql->table[0] && idlo == fql->table[fql->n - 1]) {
			est_fqlist = fql;
			break;
d1090 1
d1092 28
a1121 1

d1125 18
a1142 1
		fake_table[0] = idhi;
d1145 1
a1145 1
			    "states\n", cpu_device);
d1147 3
a1149 2
			fake_table[1] = idlo;
			fake_fqlist.n = 2;
d1154 6
a1159 3
			fake_table[1] = cur;
			fake_table[2] = idlo;
			fake_fqlist.n = 3;
d1161 4
a1164 3
		fake_fqlist.vendor = vendor;
		fake_fqlist.table = fake_table;
		est_fqlist = &fake_fqlist;
d1167 4
a1170 3
	mhz = MSR2MHZ(cur, bus_clock);
	mv = MSR2MV(cur);
	printf("%s: Enhanced SpeedStep %d MHz (%d mV)", cpu_device, mhz, mv);
d1172 3
a1174 14
	/*
	 * Check that the current operating point is in our list.
	 */
	for (i = est_fqlist->n - 1; i >= 0; i--) {
		if (cur == est_fqlist->table[i])
			break;
	}
	if (i < 0) {
		printf(" (not in table, msr 0x%016llx)\n", msr);
		return;
	}
	low = MSR2MHZ(est_fqlist->table[est_fqlist->n - 1], bus_clock);
	high = MSR2MHZ(est_fqlist->table[0], bus_clock);
	perflevel = (mhz - low) * 100 / (high - low);
d1181 2
a1182 2
		printf("%d%s", MSR2MHZ(est_fqlist->table[i], bus_clock),
		    i < est_fqlist->n - 1 ? ", " : " MHz\n");
d1204 2
a1205 1
	msr |= est_fqlist->table[i];
d1207 1
a1207 1
	cpuspeed = MSR2MHZ(est_fqlist->table[i], bus_clock);
@


1.29
log
@Fix spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.28 2007/04/24 17:12:26 gwk Exp $ */
a67 6

/* Possible bus speeds (multiplied by 100 for rounding) */
#define BUS100 10000
#define BUS133 13333
#define BUS166 16666
#define BUS200 20000
@


1.28
log
@Choose the state for a request performance level based on calculations
involving the number of states and not the frequencies of the states,
which can lead to strange distributions of the states over the hw.setperf
range (0-100). Tested by many.

ok canacar, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.27 2006/12/22 01:34:46 dim Exp $ */
d492 5
a496 5
       ID16(1600, 1308, BUS133),
       ID16(1333, 1260, BUS133),
       ID16(1200, 1212, BUS133),
       ID16(1067, 1180, BUS133),
       ID16( 800,  988, BUS133),
d541 4
a544 4
       ID16(1733, 1356, BUS133),
       ID16(1333, 1212, BUS133),
       ID16(1067, 1100, BUS133),
       ID16( 800,  988, BUS133),
d1010 1
a1010 1
	for (i = 0; i <  NELEM(est_cpus); i++) {
@


1.27
log
@A more complete fix for perf status MSR's (on e.g. Core 2 Duo X6800),
that specify equal highest and lowest clock ratios.  EST is now
silently disabled on these, as was already done for lowest clock
ratios that are zero (on e.g. a bunch of Pentium 4's).

Other weird MSR's are still reported, because we first want to know
about them, before we decide how to handle them.
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.26 2006/12/21 22:31:07 dim Exp $ */
d1079 1
a1079 1
	int low, high, i, fq;
d1085 4
a1088 3
	low = MSR2MHZ(est_fqlist->table[est_fqlist->n - 1], bus_clock);
	high = MSR2MHZ(est_fqlist->table[0], bus_clock);
	fq = low + (high - low) * level / 100;
a1089 3
	for (i = est_fqlist->n - 1; i > 0; i--)
		if (MSR2MHZ(est_fqlist->table[i], bus_clock) >= fq)
			break;
@


1.26
log
@Quick fix for Core 2 Duo X6800, which reports an invalid setperf MSR,
with the same high and low speed, leading to a divide by zero error.
A more complete fix will be committed later.

Do it now, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.25 2006/12/20 17:50:40 gwk Exp $ */
d964 1
d966 1
a966 1
	u_int64_t msr;
d984 4
a987 1
	if (idlo == 0) {
d989 5
a993 2
		 * Don't complain about this case.  It seems to happen
		 * on all Pentium 4's that report EST.
d997 6
a1002 3
	if (idhi == 0 || cur == 0 ||
	    ((cur >> 8) & 0xff) < ((idlo >> 8) & 0xff) ||
	    ((cur >> 8) & 0xff) > ((idhi >> 8) & 0xff)) {
a1061 4
	if (low == high) {
		printf(": high and low speed are the same, disabling EST\n");
		return;
	}
@


1.25
log
@"#ifdef is a tool of the weak!"
Rename pentium_mhz to cpuspeed which is consistant with amd64 making
shared ACPI code less nasty.
ok marco, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.24 2006/12/12 23:14:27 dim Exp $ */
d1052 4
@


1.24
log
@Complete gwk's previous patch to stop setperf methods from returning
errors to userland: make all cpu_setperf functions return void.

Tested by many, ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.23 2006/11/28 19:58:27 dim Exp $ */
d1086 1
a1086 1
	pentium_mhz = MSR2MHZ(est_fqlist->table[i], bus_clock);
@


1.23
log
@Let est not complain about certain strange msr values on Pentium 4's.  We can't
use the feature on them anyway, since we don't have enough info from Intel.
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.22 2006/11/05 15:10:46 dim Exp $ */
d1066 1
a1066 1
int
d1073 1
a1073 1
		return (EOPNOTSUPP);
a1086 2

	return (0);
@


1.22
log
@Add deduced power state table for 1.00 GHz VIA Eden 90nm 'Esther'.

Tested & confirmed by Greg Mortensen, thevision at pobox.com
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.21 2006/10/19 10:55:56 tom Exp $ */
d983 8
a990 1
	if (idhi == 0 || idlo == 0 || cur == 0 ||
@


1.21
log
@s/Mhz/MHz/ in comments and printf() strings

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.20 2006/09/20 14:09:15 dim Exp $ */
d841 8
d942 2
@


1.20
log
@Correct EST table for Pentium M 770, from NetBSD.

Verified by shanejp netspace net au.
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.19 2006/06/12 13:18:18 dim Exp $ */
d756 1
a756 1
/* 1.20GHz Centaur C7-M 400 Mhz FSB */
d765 1
a765 1
/* 1.50GHz Centaur C7-M 400 Mhz FSB */
d775 1
a775 1
/* 1.60GHz Centaur C7-M 400 Mhz FSB */
d785 1
a785 1
/* 1.80GHz Centaur C7-M 400 Mhz FSB */
d796 1
a796 1
/* 2.00GHz Centaur C7-M 400 Mhz FSB */
d808 1
a808 1
/* 1.60GHz Centaur C7-M 533 Mhz FSB */
d818 1
a818 1
/* 2.00GHz Centaur C7-M 533 Mhz FSB */
d829 1
a829 1
/* 2.00GHz Centaur C7-M 533 Mhz FSB */
@


1.19
log
@Some more improvements to EST:
- If an unknown EST CPU is encountered, use the known highest and lowest
  (and if different, the current) power state to generate a fake power
  state table on the fly.  Thanks to canacar for the idea.
- Calculate system bus clock speed before calling est_init(); it is
  needed to display proper MHz values from MSR values.
- Also use the bus clock to identify EST CPU's, which is needed to
  differentiate e.g. Pentium M 715 and 760, which unfortunately have
  exactly the same MSR values.
- Store power states directly as MSR values.

Tested by many, "so when does it go in?" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.18 2006/05/28 22:06:33 dim Exp $ */
d708 6
a713 8
	ID16(2133, 1551, BUS133),
	ID16(1800, 1429, BUS133),
	ID16(1600, 1356, BUS133),
	ID16(1400, 1180, BUS133),
	ID16(1200, 1132, BUS133),
	ID16(1000, 1084, BUS133),
	ID16( 800, 1036, BUS133),
	ID16( 600,  988, BUS133),
@


1.18
log
@Remove obvious EST table dupe: Pentium M 733 and Pentium M 773 (VID #H),
and zap trailing spaces.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.17 2006/05/24 11:44:35 dim Exp $ */
d65 10
a74 4
struct fq_info {
	u_short mhz;
	u_short mv;
};
d77 4
a80 4
static const struct fq_info pm130_900_ulv[] = {
	{  900, 1004 },
	{  800,  988 },
	{  600,  844 },
d84 5
a88 5
static const struct fq_info pm130_1000_ulv[] = {
	{ 1000, 1004 },
	{  900,  988 },
	{  800,  972 },
	{  600,  844 },
d92 6
a97 6
static const struct fq_info pm130_1100_ulv[] = {
	{ 1100, 1004 },
	{ 1000,  988 },
	{  900,  972 },
	{  800,  956 },
	{  600,  844 },
d101 6
a106 6
static const struct fq_info pm130_1100_lv[] = {
	{ 1100, 1180 },
	{ 1000, 1164 },
	{  900, 1100 },
	{  800, 1020 },
	{  600,  956 },
d110 7
a116 7
static const struct fq_info pm130_1200_lv[] = {
	{ 1200, 1180 },
	{ 1100, 1164 },
	{ 1000, 1100 },
	{  900, 1020 },
	{  800, 1004 },
	{  600,  956 },
d120 8
a127 8
static const struct fq_info pm130_1300_lv[] = {
	{ 1300, 1180 },
	{ 1200, 1164 },
	{ 1100, 1100 },
	{ 1000, 1020 },
	{  900, 1004 },
	{  800,  988 },
	{  600,  956 },
d131 6
a136 6
static const struct fq_info pm130_1300[] = {
	{ 1300, 1388 },
	{ 1200, 1356 },
	{ 1000, 1292 },
	{  800, 1260 },
	{  600,  956 },
d140 6
a145 6
static const struct fq_info pm130_1400[] = {
	{ 1400, 1484 },
	{ 1200, 1436 },
	{ 1000, 1308 },
	{  800, 1180 },
	{  600,  956 }
d149 7
a155 7
static const struct fq_info pm130_1500[] = {
	{ 1500, 1484 },
	{ 1400, 1452 },
	{ 1200, 1356 },
	{ 1000, 1228 },
	{  800, 1116 },
	{  600,  956 }
d159 7
a165 7
static const struct fq_info pm130_1600[] = {
	{ 1600, 1484 },
	{ 1400, 1420 },
	{ 1200, 1276 },
	{ 1000, 1164 },
	{  800, 1036 },
	{  600,  956 }
d169 7
a175 7
static const struct fq_info pm130_1700[] = {
	{ 1700, 1484 },
	{ 1400, 1308 },
	{ 1200, 1228 },
	{ 1000, 1116 },
	{  800, 1004 },
	{  600,  956 }
d179 5
a183 5
static const struct fq_info pm90_n723[] = {
	{ 1000,  940 },
	{  900,  908 },
	{  800,  876 },
	{  600,  812 }
d187 6
a192 6
static const struct fq_info pm90_n733g[] = {
	{ 1100,  956 },
	{ 1000,  940 },
	{  900,  908 },
	{  800,  876 },
	{  600,  812 }
d196 6
a201 6
static const struct fq_info pm90_n733h[] = {
	{ 1100,  940 },
	{ 1000,  924 },
	{  900,  892 },
	{  800,  876 },
	{  600,  812 }
d205 6
a210 6
static const struct fq_info pm90_n733i[] = {
	{ 1100,  924 },
	{ 1000,  908 },
	{  900,  892 },
	{  800,  860 },
	{  600,  812 }
d214 6
a219 6
static const struct fq_info pm90_n733j[] = {
	{ 1100,  908 },
	{ 1000,  892 },
	{  900,  876 },
	{  800,  860 },
	{  600,  812 }
d223 6
a228 6
static const struct fq_info pm90_n733k[] = {
	{ 1100,  892 },
	{ 1000,  876 },
	{  900,  860 },
	{  800,  844 },
	{  600,  812 }
d232 6
a237 6
static const struct fq_info pm90_n733l[] = {
	{ 1100,  876 },
	{ 1000,  876 },
	{  900,  860 },
	{  800,  844 },
	{  600,  812 }
d241 7
a247 7
static const struct fq_info pm90_n753g[] = {
	{ 1200,  956 },
	{ 1100,  940 },
	{ 1000,  908 },
	{  900,  892 },
	{  800,  860 },
	{  600,  812 }
d251 7
a257 7
static const struct fq_info pm90_n753h[] = {
	{ 1200,  940 },
	{ 1100,  924 },
	{ 1000,  908 },
	{  900,  876 },
	{  800,  860 },
	{  600,  812 }
d261 7
a267 7
static const struct fq_info pm90_n753i[] = {
	{ 1200,  924 },
	{ 1100,  908 },
	{ 1000,  892 },
	{  900,  876 },
	{  800,  860 },
	{  600,  812 }
d271 7
a277 7
static const struct fq_info pm90_n753j[] = {
	{ 1200,  908 },
	{ 1100,  892 },
	{ 1000,  876 },
	{  900,  860 },
	{  800,  844 },
	{  600,  812 }
d281 7
a287 7
static const struct fq_info pm90_n753k[] = {
	{ 1200,  892 },
	{ 1100,  892 },
	{ 1000,  876 },
	{  900,  860 },
	{  800,  844 },
	{  600,  812 }
d291 7
a297 7
static const struct fq_info pm90_n753l[] = {
	{ 1200,  876 },
	{ 1100,  876 },
	{ 1000,  860 },
	{  900,  844 },
	{  800,  844 },
	{  600,  812 }
d301 8
a308 8
static const struct fq_info pm90_n773g[] = {
	{ 1300,  956 },
	{ 1200,  940 },
	{ 1100,  924 },
	{ 1000,  908 },
	{  900,  876 },
	{  800,  860 },
	{  600,  812 }
d312 8
a319 8
static const struct fq_info pm90_n773h[] = {
	{ 1300,  940 },
	{ 1200,  924 },
	{ 1100,  908 },
	{ 1000,  892 },
	{  900,  876 },
	{  800,  860 },
	{  600,  812 }
d323 8
a330 8
static const struct fq_info pm90_n773i[] = {
	{ 1300,  924 },
	{ 1200,  908 },
	{ 1100,  892 },
	{ 1000,  876 },
	{  900,  860 },
	{  800,  844 },
	{  600,  812 }
d334 8
a341 8
static const struct fq_info pm90_n773j[] = {
	{ 1300,  908 },
	{ 1200,  908 },
	{ 1100,  892 },
	{ 1000,  876 },
	{  900,  860 },
	{  800,  844 },
	{  600,  812 }
d345 8
a352 8
static const struct fq_info pm90_n773k[] = {
	{ 1300,  892 },
	{ 1200,  892 },
	{ 1100,  876 },
	{ 1000,  860 },
	{  900,  860 },
	{  800,  844 },
	{  600,  812 }
d356 8
a363 8
static const struct fq_info pm90_n773l[] = {
	{ 1300,  876 },
	{ 1200,  876 },
	{ 1100,  860 },
	{ 1000,  860 },
	{  900,  844 },
	{  800,  844 },
	{  600,  812 }
d367 9
a375 9
static const struct fq_info pm90_n738[] = {
	{ 1400, 1116 },
	{ 1300, 1116 },
	{ 1200, 1100 },
	{ 1100, 1068 },
	{ 1000, 1052 },
	{  900, 1036 },
	{  800, 1020 },
	{  600,  988 }
d379 10
a388 10
static const struct fq_info pm90_n758[] = {
	{ 1500, 1116 },
	{ 1400, 1116 },
	{ 1300, 1100 },
	{ 1200, 1084 },
	{ 1100, 1068 },
	{ 1000, 1052 },
	{  900, 1036 },
	{  800, 1020 },
	{  600,  988 }
d392 20
a411 20
static const struct fq_info pm90_n778[] = {
	{ 1600, 1116 },
	{ 1500, 1116 },
	{ 1400, 1100 },
	{ 1300, 1184 },
	{ 1200, 1068 },
	{ 1100, 1052 },
	{ 1000, 1052 },
	{  900, 1036 },
	{  800, 1020 },
	{  600,  988 }
};

/* Intel Pentium M processor 710 1.4 GHz */
static const struct fq_info pm90_n710[] = {
	{ 1400, 1340 },
	{ 1200, 1228 },
	{ 1000, 1148 },
	{  800, 1068 },
	{  600,  998 }
d415 6
a420 6
static const struct fq_info pm90_n715a[] = {
	{ 1500, 1340 },
	{ 1200, 1228 },
	{ 1000, 1148 },
	{  800, 1068 },
	{  600,  988 }
d424 6
a429 6
static const struct fq_info pm90_n715b[] = {
	{ 1500, 1324 },
	{ 1200, 1212 },
	{ 1000, 1148 },
	{  800, 1068 },
	{  600,  988 }
d433 6
a438 6
static const struct fq_info pm90_n715c[] = {
	{ 1500, 1308 },
	{ 1200, 1212 },
	{ 1000, 1132 },
	{  800, 1068 },
	{  600,  988 }
d442 6
a447 6
static const struct fq_info pm90_n715d[] = {
	{ 1500, 1276 },
	{ 1200, 1180 },
	{ 1000, 1116 },
	{  800, 1052 },
	{  600,  988 }
d451 7
a457 7
static const struct fq_info pm90_n725a[] = {
	{ 1600, 1340 },
	{ 1400, 1276 },
	{ 1200, 1212 },
	{ 1000, 1132 },
	{  800, 1068 },
	{  600,  988 }
d461 7
a467 7
static const struct fq_info pm90_n725b[] = {
	{ 1600, 1324 },
	{ 1400, 1260 },
	{ 1200, 1196 },
	{ 1000, 1132 },
	{  800, 1068 },
	{  600,  988 }
d471 7
a477 7
static const struct fq_info pm90_n725c[] = {
	{ 1600, 1308 },
	{ 1400, 1244 },
	{ 1200, 1180 },
	{ 1000, 1116 },
	{  800, 1052 },
	{  600,  988 }
d481 7
a487 7
static const struct fq_info pm90_n725d[] = {
	{ 1600, 1276 },
	{ 1400, 1228 },
	{ 1200, 1164 },
	{ 1000, 1116 },
	{  800, 1052 },
	{  600,  988 }
d491 6
a496 6
static const struct fq_info pm90_n730[] = {
       { 1600, 1308 },
       { 1333, 1260 },
       { 1200, 1212 },
       { 1067, 1180 },
       {  800,  988 }
d500 7
a506 7
static const struct fq_info pm90_n735a[] = {
	{ 1700, 1340 },
	{ 1400, 1244 },
	{ 1200, 1180 },
	{ 1000, 1116 },
	{  800, 1052 },
	{  600,  988 }
d510 7
a516 7
static const struct fq_info pm90_n735b[] = {
	{ 1700, 1324 },
	{ 1400, 1244 },
	{ 1200, 1180 },
	{ 1000, 1116 },
	{  800, 1052 },
	{  600,  988 }
d520 7
a526 7
static const struct fq_info pm90_n735c[] = {
	{ 1700, 1308 },
	{ 1400, 1228 },
	{ 1200, 1164 },
	{ 1000, 1116 },
	{  800, 1052 },
	{  600,  988 }
d530 7
a536 7
static const struct fq_info pm90_n735d[] = {
	{ 1700, 1276 },
	{ 1400, 1212 },
	{ 1200, 1148 },
	{ 1000, 1100 },
	{  800, 1052 },
	{  600,  988 }
d540 5
a544 5
static const struct fq_info pm90_n740[] = {
       { 1733, 1356 },
       { 1333, 1212 },
       { 1067, 1100 },
       {  800,  988 },
d548 8
a555 8
static const struct fq_info pm90_n745a[] = {
	{ 1800, 1340 },
	{ 1600, 1292 },
	{ 1400, 1228 },
	{ 1200, 1164 },
	{ 1000, 1116 },
	{  800, 1052 },
	{  600,  988 }
d559 8
a566 8
static const struct fq_info pm90_n745b[] = {
	{ 1800, 1324 },
	{ 1600, 1276 },
	{ 1400, 1212 },
	{ 1200, 1164 },
	{ 1000, 1116 },
	{  800, 1052 },
	{  600,  988 }
d570 8
a577 8
static const struct fq_info pm90_n745c[] = {
	{ 1800, 1308 },
	{ 1600, 1260 },
	{ 1400, 1212 },
	{ 1200, 1148 },
	{ 1000, 1100 },
	{  800, 1052 },
	{  600,  988 }
d581 8
a588 8
static const struct fq_info pm90_n745d[] = {
	{ 1800, 1276 },
	{ 1600, 1228 },
	{ 1400, 1180 },
	{ 1200, 1132 },
	{ 1000, 1084 },
	{  800, 1036 },
	{  600,  988 }
d593 6
a598 6
static const struct fq_info pm90_n750[] = {
	{ 1867, 1308 },
	{ 1600, 1228 },
	{ 1333, 1148 },
	{ 1067, 1068 },
	{  800,  988 }
d602 9
a610 9
static const struct fq_info pm90_n755a[] = {
	{ 2000, 1340 },
	{ 1800, 1292 },
	{ 1600, 1244 },
	{ 1400, 1196 },
	{ 1200, 1148 },
	{ 1000, 1100 },
	{  800, 1052 },
	{  600,  988 }
d614 9
a622 9
static const struct fq_info pm90_n755b[] = {
	{ 2000, 1324 },
	{ 1800, 1276 },
	{ 1600, 1228 },
	{ 1400, 1180 },
	{ 1200, 1132 },
	{ 1000, 1084 },
	{  800, 1036 },
	{  600,  988 }
d626 9
a634 9
static const struct fq_info pm90_n755c[] = {
	{ 2000, 1308 },
	{ 1800, 1276 },
	{ 1600, 1228 },
	{ 1400, 1180 },
	{ 1200, 1132 },
	{ 1000, 1084 },
	{  800, 1036 },
	{  600,  988 }
d638 9
a646 9
static const struct fq_info pm90_n755d[] = {
	{ 2000, 1276 },
	{ 1800, 1244 },
	{ 1600, 1196 },
	{ 1400, 1164 },
	{ 1200, 1116 },
	{ 1000, 1084 },
	{  800, 1036 },
	{  600,  988 }
d650 6
a655 6
static const struct fq_info pm90_n760[] = {
	{ 2000, 1356 },
	{ 1600, 1244 },
	{ 1333, 1164 },
	{ 1067, 1084 },
	{  800,  988 }
d659 9
a667 9
static const struct fq_info pm90_n765a[] = {
	{ 2100, 1340 },
	{ 1800, 1276 },
	{ 1600, 1228 },
	{ 1400, 1180 },
	{ 1200, 1132 },
	{ 1000, 1084 },
	{  800, 1036 },
	{  600,  988 }
d671 9
a679 9
static const struct fq_info pm90_n765b[] = {
	{ 2100, 1324 },
	{ 1800, 1260 },
	{ 1600, 1212 },
	{ 1400, 1180 },
	{ 1200, 1132 },
	{ 1000, 1084 },
	{  800, 1036 },
	{  600,  988 }
d683 9
a691 9
static const struct fq_info pm90_n765c[] = {
	{ 2100, 1308 },
	{ 1800, 1244 },
	{ 1600, 1212 },
	{ 1400, 1164 },
	{ 1200, 1116 },
	{ 1000, 1084 },
	{  800, 1036 },
	{  600,  988 }
d695 9
a703 9
static const struct fq_info pm90_n765e[] = {
	{ 2100, 1356 },
	{ 1800, 1292 },
	{ 1600, 1244 },
	{ 1400, 1196 },
	{ 1200, 1148 },
	{ 1000, 1100 },
	{  800, 1052 },
	{  600,  988 }
d707 9
a715 9
static const struct fq_info pm90_n770[] = {
	{ 2133, 1551 },
	{ 1800, 1429 },
	{ 1600, 1356 },
	{ 1400, 1180 },
	{ 1200, 1132 },
	{ 1000, 1084 },
	{  800, 1036 },
	{  600,  988 }
d724 5
a728 5
static const struct fq_info C7M_770_ULV[] = {
	{ 1000,  844 },
	{  800,  796 },
	{  600,  796 },
	{  400,  796 },
d732 5
a736 5
static const struct fq_info C7M_779_ULV[] = {
	{ 1000,  796 },
	{  800,  796 },
	{  600,  796 },
	{  400,  796 },
d740 6
a745 6
static const struct fq_info C7M_772_ULV[] = {
	{ 1200,  844 },
	{ 1000,  844 },
	{  800,  828 },
	{  600,  796 },
	{  400,  796 },
d749 7
a755 7
static const struct fq_info C7M_775_ULV[] = {
	{ 1500,  956 },
	{ 1400,  940 },
	{ 1000,  860 },
	{  800,  828 },
	{  600,  796 },
	{  400,  796 },
d759 6
a764 6
static const struct fq_info C7M_771[] = {
	{ 1200,  860 },
	{ 1000,  860 },
	{  800,  844 },
	{  600,  844 },
	{  400,  844 },
d768 7
a774 7
static const struct fq_info C7M_754[] = {
	{ 1500, 1004 },
	{ 1400,  988 },
	{ 1000,  940 },
	{  800,  844 },
	{  600,  844 },
	{  400,  844 },
d778 7
a784 7
static const struct fq_info C7M_764[] = {
	{ 1600, 1084 },
	{ 1400, 1052 },
	{ 1000, 1004 },
	{  800,  844 },
	{  600,  844 },
	{  400,  844 },
d788 8
a795 8
static const struct fq_info C7M_784[] = {
	{ 1800, 1148 },
	{ 1600, 1100 },
	{ 1400, 1052 },
	{ 1000, 1004 },
	{  800,  844 },
	{  600,  844 },
	{  400,  844 },
d799 9
a807 9
static const struct fq_info C7M_794[] = {
	{ 2000, 1148 },
	{ 1800, 1132 },
	{ 1600, 1100 },
	{ 1400, 1052 },
	{ 1000, 1004 },
	{  800,  844 },
	{  600,  844 },
	{  400,  844 },
d811 7
a817 7
static const struct fq_info C7M_765[] = {
	{ 1600, 1084 },
	{ 1467, 1052 },
	{ 1200, 1004 },
	{  800,  844 },
	{  667,  844 },
	{  533,  844 },
d821 8
a828 8
static const struct fq_info C7M_785[] = {
	{ 1867, 1148 },
	{ 1600, 1100 },
	{ 1467, 1052 },
	{ 1200, 1004 },
	{  800,  844 },
	{  667,  844 },
	{  533,  844 },
d832 9
a840 9
static const struct fq_info C7M_795[] = {
	{ 2000, 1148 },
	{ 1867, 1132 },
	{ 1600, 1100 },
	{ 1467, 1052 },
	{ 1200, 1004 },
	{  800,  844 },
	{  667,  844 },
	{  533,  844 },
a842 6
/* Convert MHz and mV into IDs for passing to the MSR. */
#define ID16(MHz, mV, bus_clk) \
	((((MHz * 100 + 50) / bus_clk) << 8) | ((mV ? mV - 700 : 0) >> 4))
#define ID32(MHz_hi, mV_hi, MHz_lo, mV_lo, bus_clk) \
	((ID16(MHz_lo, mV_lo, bus_clk) << 16) | (ID16(MHz_hi, mV_hi, bus_clk)))

d847 1
a847 1
	const struct fq_info *table;
d853 1
a853 4
	{ CPUVENDOR_##ven, bus_clk, NELEM(tab), tab }

#define BUS100 0
#define BUS133 1
d855 1
a855 1
#define BUS_CLK(fqp) ((fqp)->bus_clk ? 13333 : 10000)
d946 3
d956 1
a956 1
	u_int32_t id;
d966 5
d972 10
a981 1

d983 1
a983 1
	 * Find an entry which matches (vendor, id32)
d985 1
a985 2
	id = msr >> 32;
	for (i = 0; i < NELEM(est_cpus); i++) {
d987 2
a988 4
		if (vendor == fql->vendor &&
		    id == ID32(fql->table[0].mhz, fql->table[0].mv,
		    fql->table[fql->n - 1].mhz, fql->table[fql->n - 1].mv,
		    BUS_CLK(fql))) {
d996 22
a1017 1
		return;
d1020 2
a1021 2
	mhz = MSR2MHZ(msr, BUS_CLK(est_fqlist));
	mv = MSR2MV(msr);
d1028 1
a1028 2
		if (ID16(est_fqlist->table[i].mhz, est_fqlist->table[i].mv,
		    BUS_CLK(est_fqlist)) == (msr & 0xffff))
d1035 3
a1037 3
	low = est_fqlist->table[est_fqlist->n - 1].mhz;
	high = est_fqlist->table[0].mhz;
	perflevel = (est_fqlist->table[i].mhz - low) * 100 / (high - low);
d1044 1
a1044 1
		printf("%d%s", est_fqlist->table[i].mhz,
d1060 2
a1061 2
	low = est_fqlist->table[est_fqlist->n - 1].mhz;
	high = est_fqlist->table[0].mhz;
d1065 1
a1065 1
		if (est_fqlist->table[i].mhz >= fq)
d1067 3
a1069 3
	msr = (rdmsr(MSR_PERF_CTL) & ~0xffffULL) |
	    ID16(est_fqlist->table[i].mhz, est_fqlist->table[i].mv,
	    BUS_CLK(est_fqlist));
d1071 1
a1071 1
	pentium_mhz = est_fqlist->table[i].mhz;
@


1.17
log
@Cleanup and simplify the EST detection:
- Fix yet another rounding problem, in the ID16 macro this time.
  Luckily the resulting table was not affected by this.
- Remove unnecessary fqlist::id32 field.  This saves error-prone
  duplication of (MHz, mV) pairs in the source, and makes the table
  smaller.
- Put fqlist members in bit fields, this also saves lots of space.
  These fields are not accessed in performance-critical code anyway.

Tested by a bunch of people, ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.16 2006/05/20 13:31:00 dim Exp $ */
a179 9
/* Intel Pentium M processor 733 1.1 GHz */
static const struct fq_info pm90_n733[] = {
	{ 1100,  940 },
	{ 1000,  924 },
	{  900,  892 },
	{  800,  876 },
	{  600,  812 }
};

d487 1
a487 1
       { 1333, 1260 }, 
d491 1
a491 1
};     
a873 1
	ENTRY(INTEL, BUS100, pm90_n733),
d895 1
a895 1
		              		        	      
d926 1
a926 1
		              		        	      
@


1.16
log
@Some more EST improvements:
- Add Pentium M 710, 730, 740, 750, 760; preliminary, not all table
  values are known yet, thanks to incomplete Intel documentation.
- Change Pentium M 770 to 133 MHz system bus clock.
- Fix rounding, so 133 MHz bus clock based CPU speeds like 1733, 1866,
  2133 show up correcly, instead of 1729, 1862, 2128 as before.

If you have any of the 7[1-7]0 models, and it doesn't get detected
properly yet, please let me know.  It might be you have a slightly
different variant from what is in the tables.

Tested by a lot of people; ok brad@@, slap it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.15 2006/05/19 19:43:41 dim Exp $ */
d848 1
a848 1
	((((MHz + 50) * 100 / bus_clk) << 8) | ((mV ? mV - 700 : 0) >> 4))
d853 3
a855 3
	int vendor;
	u_int32_t id32;
	u_int32_t bus_clk;
a856 1
	unsigned n;
d859 1
a859 3
#define ENTRY(ven, tab, zhi, vhi, zlo, vlo, bus_clk) \
	{ CPUVENDOR_##ven, ID32(zhi, vhi, zlo, vlo, bus_clk), bus_clk, tab, \
	sizeof(tab) / sizeof((tab)[0]) }
d861 7
a867 2
#define BUS100 10000
#define BUS133 13333
d870 79
a948 79
	ENTRY(INTEL, pm130_900_ulv,	 900, 1004, 600, 844, BUS100),
	ENTRY(INTEL, pm130_1000_ulv,	1000, 1004, 600, 844, BUS100),
	ENTRY(INTEL, pm130_1100_ulv,	1100, 1004, 600, 844, BUS100),
	ENTRY(INTEL, pm130_1100_lv,	1100, 1180, 600, 956, BUS100),
	ENTRY(INTEL, pm130_1200_lv,	1200, 1180, 600, 956, BUS100),
	ENTRY(INTEL, pm130_1300_lv,	1300, 1180, 600, 956, BUS100),
	ENTRY(INTEL, pm130_1300,	1300, 1388, 600, 956, BUS100),
	ENTRY(INTEL, pm130_1400,	1400, 1484, 600, 956, BUS100),
	ENTRY(INTEL, pm130_1500,	1500, 1484, 600, 956, BUS100),
	ENTRY(INTEL, pm130_1600,	1600, 1484, 600, 956, BUS100),
	ENTRY(INTEL, pm130_1700,	1700, 1484, 600, 956, BUS100),

	ENTRY(INTEL, pm90_n723,		1000,  940, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n733,		1100,  940, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n733g,	1100,  956, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n733h,	1100,  940, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n733i,	1100,  924, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n733j,	1100,  908, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n733k,	1100,  892, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n733l,	1100,  876, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n753g,	1200,  956, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n753h,	1200,  940, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n753i,	1200,  924, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n753j,	1200,  908, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n753k,	1200,  892, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n753l,	1200,  876, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n773g,	1300,  956, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n773h,	1300,  940, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n773i,	1300,  924, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n773j,	1300,  908, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n773k,	1300,  892, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n773l,	1300,  876, 600, 812, BUS100),
	ENTRY(INTEL, pm90_n738,		1400, 1116, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n758,		1500, 1116, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n778,		1600, 1116, 600, 988, BUS100),

	ENTRY(INTEL, pm90_n710,		1400, 1340, 600, 988, BUS133),
	ENTRY(INTEL, pm90_n715a,	1500, 1340, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n715b,	1500, 1324, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n715c,	1500, 1308, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n715d,	1500, 1276, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n725a,	1600, 1340, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n725b,	1600, 1324, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n725c,	1600, 1308, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n725d,	1600, 1276, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n730,		1600, 1308, 800, 988, BUS133),
	ENTRY(INTEL, pm90_n735a,	1700, 1340, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n735b,	1700, 1324, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n735c,	1700, 1308, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n735d,	1700, 1276, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n740,		1733, 1356, 800, 988, BUS133),
	ENTRY(INTEL, pm90_n745a,	1800, 1340, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n745b,	1800, 1324, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n745c,	1800, 1308, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n745d,	1800, 1276, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n750,		1867, 1308, 800, 988, BUS133),
	ENTRY(INTEL, pm90_n755a,	2000, 1340, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n755b,	2000, 1324, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n755c,	2000, 1308, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n755d,	2000, 1276, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n760,		2000, 1356, 800, 988, BUS133),
	ENTRY(INTEL, pm90_n765a,	2100, 1340, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n765b,	2100, 1324, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n765c,	2100, 1308, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n765e,	2100, 1356, 600, 988, BUS100),
	ENTRY(INTEL, pm90_n770,		2133, 1551, 600, 988, BUS133),

	ENTRY(VIA,   C7M_770_ULV,	1000,  844, 400, 796, BUS100),
	ENTRY(VIA,   C7M_779_ULV,	1000,  796, 400, 796, BUS100),
	ENTRY(VIA,   C7M_772_ULV,	1200,  844, 400, 796, BUS100),
	ENTRY(VIA,   C7M_771,		1200,  860, 400, 844, BUS100),
	ENTRY(VIA,   C7M_775_ULV,	1500,  956, 400, 796, BUS100),
	ENTRY(VIA,   C7M_754,		1500, 1004, 400, 844, BUS100),
	ENTRY(VIA,   C7M_764,		1600, 1084, 400, 844, BUS100),
	ENTRY(VIA,   C7M_765,		1600, 1084, 533, 844, BUS133),
	ENTRY(VIA,   C7M_784,		1800, 1148, 400, 844, BUS100),
	ENTRY(VIA,   C7M_785,		1867, 1148, 533, 844, BUS133),
	ENTRY(VIA,   C7M_794,		2000, 1148, 400, 844, BUS100),
	ENTRY(VIA,   C7M_795,		2000, 1148, 533, 844, BUS133),
a950 2
#define NESTCPUS	  (sizeof(est_cpus) / sizeof(est_cpus[0]))

d968 1
d982 7
a988 3
	for (i = 0; i < NESTCPUS; i++) {
		if (est_cpus[i].vendor == vendor && est_cpus[i].id32 == id) {
			est_fqlist = &est_cpus[i];
d998 1
a998 1
	mhz = MSR2MHZ(msr, est_fqlist->bus_clk);
d1007 1
a1007 1
		    est_fqlist->bus_clk) == (msr & 0xffff))
d1048 1
a1048 1
	    est_fqlist->bus_clk);
@


1.15
log
@Reimplement the Enhanced SpeedStep CPU detection by using the
quintuplet { vendor, MHz_hi, mV_hi, MHz_lo, mV_lo }, which works much
better than parsing the branding string.  It also makes it easier to add
new models later.

Shouldn't break any CPU's which previously worked okay with EST; if
there's any trouble, please let me know!

Also adds quite a number of VIA C7-M models, and a few more Pentium M
models, all from FreeBSD.

"go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.14 2006/05/11 13:21:11 mickey Exp $ */
d408 9
d493 9
d542 8
d594 10
d652 9
d711 1
a711 1
	{ 2130, 1551 },
d848 1
a848 1
	(((MHz / bus_clk) << 8) | ((mV ? mV - 700 : 0) >> 4))
d864 3
d868 79
a946 73
	ENTRY(INTEL, pm130_900_ulv,	 900, 1004, 600, 844, 100),
	ENTRY(INTEL, pm130_1000_ulv,	1000, 1004, 600, 844, 100),
	ENTRY(INTEL, pm130_1100_ulv,	1100, 1004, 600, 844, 100),
	ENTRY(INTEL, pm130_1100_lv,	1100, 1180, 600, 956, 100),
	ENTRY(INTEL, pm130_1200_lv,	1200, 1180, 600, 956, 100),
	ENTRY(INTEL, pm130_1300_lv,	1300, 1180, 600, 956, 100),
	ENTRY(INTEL, pm130_1300,	1300, 1388, 600, 956, 100),
	ENTRY(INTEL, pm130_1400,	1400, 1484, 600, 956, 100),
	ENTRY(INTEL, pm130_1500,	1500, 1484, 600, 956, 100),
	ENTRY(INTEL, pm130_1600,	1600, 1484, 600, 956, 100),
	ENTRY(INTEL, pm130_1700,	1700, 1484, 600, 956, 100),

	ENTRY(INTEL, pm90_n723,		1000,  940, 600, 812, 100),
	ENTRY(INTEL, pm90_n733,		1100,  940, 600, 812, 100),
	ENTRY(INTEL, pm90_n733g,	1100,  956, 600, 812, 100),
	ENTRY(INTEL, pm90_n733h,	1100,  940, 600, 812, 100),
	ENTRY(INTEL, pm90_n733i,	1100,  924, 600, 812, 100),
	ENTRY(INTEL, pm90_n733j,	1100,  908, 600, 812, 100),
	ENTRY(INTEL, pm90_n733k,	1100,  892, 600, 812, 100),
	ENTRY(INTEL, pm90_n733l,	1100,  876, 600, 812, 100),
	ENTRY(INTEL, pm90_n753g,	1200,  956, 600, 812, 100),
	ENTRY(INTEL, pm90_n753h,	1200,  940, 600, 812, 100),
	ENTRY(INTEL, pm90_n753i,	1200,  924, 600, 812, 100),
	ENTRY(INTEL, pm90_n753j,	1200,  908, 600, 812, 100),
	ENTRY(INTEL, pm90_n753k,	1200,  892, 600, 812, 100),
	ENTRY(INTEL, pm90_n753l,	1200,  876, 600, 812, 100),
	ENTRY(INTEL, pm90_n773g,	1300,  956, 600, 812, 100),
	ENTRY(INTEL, pm90_n773h,	1300,  940, 600, 812, 100),
	ENTRY(INTEL, pm90_n773i,	1300,  924, 600, 812, 100),
	ENTRY(INTEL, pm90_n773j,	1300,  908, 600, 812, 100),
	ENTRY(INTEL, pm90_n773k,	1300,  892, 600, 812, 100),
	ENTRY(INTEL, pm90_n773l,	1300,  876, 600, 812, 100),
	ENTRY(INTEL, pm90_n738,		1400, 1116, 600, 988, 100),
	ENTRY(INTEL, pm90_n758,		1500, 1116, 600, 988, 100),
	ENTRY(INTEL, pm90_n778,		1600, 1116, 600, 988, 100),
	ENTRY(INTEL, pm90_n715a,	1500, 1340, 600, 988, 100),
	ENTRY(INTEL, pm90_n715b,	1500, 1324, 600, 988, 100),
	ENTRY(INTEL, pm90_n715c,	1500, 1308, 600, 988, 100),
	ENTRY(INTEL, pm90_n715d,	1500, 1276, 600, 988, 100),
	ENTRY(INTEL, pm90_n725a,	1600, 1340, 600, 988, 100),
	ENTRY(INTEL, pm90_n725b,	1600, 1324, 600, 988, 100),
	ENTRY(INTEL, pm90_n725c,	1600, 1308, 600, 988, 100),
	ENTRY(INTEL, pm90_n725d,	1600, 1276, 600, 988, 100),
	ENTRY(INTEL, pm90_n735a,	1700, 1340, 600, 988, 100),
	ENTRY(INTEL, pm90_n735b,	1700, 1324, 600, 988, 100),
	ENTRY(INTEL, pm90_n735c,	1700, 1308, 600, 988, 100),
	ENTRY(INTEL, pm90_n735d,	1700, 1276, 600, 988, 100),
	ENTRY(INTEL, pm90_n745a,	1800, 1340, 600, 988, 100),
	ENTRY(INTEL, pm90_n745b,	1800, 1324, 600, 988, 100),
	ENTRY(INTEL, pm90_n745c,	1800, 1308, 600, 988, 100),
	ENTRY(INTEL, pm90_n745d,	1800, 1276, 600, 988, 100),
	ENTRY(INTEL, pm90_n755a,	2000, 1340, 600, 988, 100),
	ENTRY(INTEL, pm90_n755b,	2000, 1324, 600, 988, 100),
	ENTRY(INTEL, pm90_n755c,	2000, 1308, 600, 988, 100),
	ENTRY(INTEL, pm90_n755d,	2000, 1276, 600, 988, 100),
	ENTRY(INTEL, pm90_n765a,	2100, 1340, 600, 988, 100),
	ENTRY(INTEL, pm90_n765b,	2100, 1324, 600, 988, 100),
	ENTRY(INTEL, pm90_n765c,	2100, 1308, 600, 988, 100),
	ENTRY(INTEL, pm90_n765e,	2100, 1356, 600, 988, 100),
	ENTRY(INTEL, pm90_n770,		2130, 1551, 600, 988, 100),

	ENTRY(VIA,   C7M_770_ULV,	1000,  844, 400, 796, 100),
	ENTRY(VIA,   C7M_779_ULV,	1000,  796, 400, 796, 100),
	ENTRY(VIA,   C7M_772_ULV,	1200,  844, 400, 796, 100),
	ENTRY(VIA,   C7M_771,		1200,  860, 400, 844, 100),
	ENTRY(VIA,   C7M_775_ULV,	1500,  956, 400, 796, 100),
	ENTRY(VIA,   C7M_754,		1500, 1004, 400, 844, 100),
	ENTRY(VIA,   C7M_764,		1600, 1084, 400, 844, 100),
	ENTRY(VIA,   C7M_765,		1600, 1084, 533, 844, 133),
	ENTRY(VIA,   C7M_784,		1800, 1148, 400, 844, 100),
	ENTRY(VIA,   C7M_785,		1867, 1148, 533, 844, 133),
	ENTRY(VIA,   C7M_794,		2000, 1148, 400, 844, 100),
	ENTRY(VIA,   C7M_795,		2000, 1148, 533, 844, 133),
d952 4
a955 3
#define MSRVALUE(mhz, mv, bus)	((((mhz) / (bus)) << 8) | (((mv) - 700) / 16))
#define MSR2MHZ(msr)		((((int) (msr) >> 8) & 0xff) * 100)
#define MSR2MV(msr)		(((int) (msr) & 0xff) * 16 + 700)
a975 4
	mhz = MSR2MHZ(msr);
	mv = MSR2MV(msr);
	printf("%s: Enhanced SpeedStep %d MHz (%d mV)",
	    cpu_device, mhz, mv);
d988 2
a989 1
		printf(": unknown EST cpu, msr %016llx\n", msr);
d993 4
d1000 3
a1002 3
	for (i = est_fqlist->n - 1; i >= 0; i--)
		if (est_fqlist->table[i].mhz == mhz &&
		    est_fqlist->table[i].mv == mv)
d1004 1
d1006 1
a1006 1
		printf(" (not in table)\n");
d1011 1
a1011 1
	perflevel = (mhz - low) * 100 / (high - low);
d1042 1
a1042 1
	    MSRVALUE(est_fqlist->table[i].mhz, est_fqlist->table[i].mv,
@


1.14
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.13 2006/02/27 14:13:10 marco Exp $ */
d71 1
a71 1
static const struct fq_info pentium_m_900[] = {
d78 1
a78 1
static const struct fq_info pentium_m_1000[] = {
d85 9
d95 1
a95 1
static const struct fq_info pentium_m_1100[] = {
d104 1
a104 1
static const struct fq_info pentium_m_1200[] = {
d113 11
d125 1
a125 1
static const struct fq_info pentium_m_1300[] = {
d134 1
a134 1
static const struct fq_info pentium_m_1400[] = {
d143 1
a143 1
static const struct fq_info pentium_m_1500[] = {
d153 1
a153 1
static const struct fq_info pentium_m_1600[] = {
d163 1
a163 1
static const struct fq_info pentium_m_1700[] = {
d173 1
a173 1
static const struct fq_info pentium_m_n723[] = {
d181 19
a199 1
static const struct fq_info pentium_m_n733[] = {
d207 48
a254 2
/* Intel Pentium M processor 753 1.2 GHz */
static const struct fq_info pentium_m_n753[] = {
d263 53
a315 2
/* Intel Pentium M processor 773 1.3 GHz */
static const struct fq_info pentium_m_n773[] = {
d325 44
d370 1
a370 1
static const struct fq_info pentium_m_n738[] = {
d382 1
a382 1
static const struct fq_info pentium_m_n758[] = {
d395 1
a395 1
static const struct fq_info pentium_m_n778[] = {
d408 2
a409 2
/* Intel Pentium M processor 715 1.5 GHz */
static const struct fq_info pentium_m_n715[] = {
d417 29
a445 2
/* Intel Pentium M processor 725 1.6 GHz */
static const struct fq_info pentium_m_n725[] = {
d454 32
a485 2
/* Intel Pentium M processor 735 1.7 GHz */
static const struct fq_info pentium_m_n735[] = {
d494 32
a525 2
/* Intel Pentium M processor 745 1.8 GHz */
static const struct fq_info pentium_m_n745[] = {
d535 35
a569 2
/* Intel Pentium M processor 755 2.0 GHz */
static const struct fq_info pentium_m_n755[] = {
d580 38
a617 2
/* Intel Pentium M processor 765 2.1 GHz */
static const struct fq_info pentium_m_n765[] = {
d628 36
d665 1
a665 1
static const struct fq_info pentium_m_n770[] = {
d673 1
a673 1
	{  600, 988 }
d676 131
d808 3
a810 2
	const char *brand_tag;
	const int cpu_id;
d812 1
a812 1
	u_int n;
d815 78
a892 51
static const struct fqlist pentium_m[] = {
#define ENTRY(s, i, v)	{ s, i, v, sizeof(v) / sizeof((v)[0]) }
	ENTRY(" 900", 0, pentium_m_900),
	ENTRY("1000", 0, pentium_m_1000),
	ENTRY("1100", 0, pentium_m_1100),
	ENTRY("1200", 0, pentium_m_1200),
	ENTRY("1300", 0, pentium_m_1300),
	ENTRY("1400", 0, pentium_m_1400),
	ENTRY("1500", 0, pentium_m_1500),
	ENTRY("1600", 0, pentium_m_1600),
	ENTRY("1700", 0, pentium_m_1700),
#undef ENTRY
};

static const struct fqlist pentium_m_dothan[] = {
#define ENTRY(s, i, v)	{ s, i, v, sizeof(v) / sizeof((v)[0]) }
	ENTRY("1.00", 0, pentium_m_n723),
	ENTRY("1.10", 0, pentium_m_n733),
	ENTRY("1.20", 0, pentium_m_n753),
	ENTRY("1.30", 0, pentium_m_n773),
	ENTRY("1.40", 0, pentium_m_n738),
	ENTRY("1.50", 0x06d6, pentium_m_n715),
	ENTRY("1.50", 0x06d8, pentium_m_n758),
	ENTRY("1.60", 0x06d6, pentium_m_n725),
	ENTRY("1.60", 0x06d8, pentium_m_n778),
	ENTRY("1.70", 0, pentium_m_n735),
	ENTRY("1.80", 0, pentium_m_n745),
	ENTRY("2.00", 0, pentium_m_n755),
	ENTRY("2.10", 0, pentium_m_n765),
	ENTRY("2.13", 0, pentium_m_n770),
#undef ENTRY
};

struct est_cpu {
	const char *brand_prefix;
	const char *brand_suffix;
	const struct fqlist *list;
	int n;
};

static const struct est_cpu est_cpus[] = {
	{
		"Intel(R) Pentium(R) M processor ", "MHz",
		pentium_m,
		(sizeof(pentium_m) / sizeof(pentium_m[0]))
	},
	{
		"Intel(R) Pentium(R) M processor ", "GHz",
		pentium_m_dothan,
		(sizeof(pentium_m_dothan) / sizeof(pentium_m_dothan[0]))
	},
d898 1
a898 1
#define MSRVALUE(mhz, mv)	((((mhz) / 100) << 8) | (((mv) - 700) / 16))
d908 1
a908 1
est_init(const char *cpu_device)
d910 2
a911 2
	int i, j, n, mhz, mv;
	const struct est_cpu *cpu;
a912 5
	char *tag;
	const struct fqlist *fql;
	extern char cpu_brandstr[];
	extern int cpu_id;
	int low, high;
d924 1
a924 1
	     cpu_device, mhz, mv);
d927 1
a927 1
	 * Look for a CPU matching cpu_brandstr.
d929 5
a933 15
	for (i = 0; est_fqlist == NULL && i < NESTCPUS; i++) {
		cpu = &est_cpus[i];
		n = strlen(cpu->brand_prefix);
		if (strncmp(cpu->brand_prefix, cpu_brandstr, n) != 0)
			continue;
		tag = cpu_brandstr + n;
		for (j = 0; j < cpu->n; j++) {
			fql = &cpu->list[j];
			n = strlen(fql->brand_tag);
			if (!strncmp(fql->brand_tag, tag, n) &&
			    !strcmp(cpu->brand_suffix, tag + n) &&
			    (fql->cpu_id == 0 || fql->cpu_id == cpu_id)) {
				est_fqlist = fql;
				break;
			}
d937 1
a937 1
		printf(": unknown EST cpu, no changes possible\n");
d985 2
a986 1
	    MSRVALUE(est_fqlist->table[i].mhz, est_fqlist->table[i].mv);
d989 1
a989 1
	
@


1.13
log
@Add the 770 model.  From NetBSD through Gregory Steuck
<greg at y2006 dot nest dot cx>

Suggestions and ok deraadt@@
ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.12 2006/02/27 05:37:16 marco Exp $ */
d35 1
a35 1
 *   
d54 1
a54 1
 
d157 1
a157 1
	{  600,  812 } 
d290 1
a290 1
	{  600,  988 } 
@


1.12
log
@Add 2 additional CPUs and uncomment a 3rd.  Based on this intel doc:
download.intel.com/design/mobile/datashts/30218908.pdf

cpu_id part of the diff was done by Dimitry Andric <dimitry at andric dot com>
Thanks :-)

Pointed to the doc and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.11 2005/03/07 06:59:14 mbalmer Exp $ */
d293 12
d341 1
@


1.11
log
@Add missing pentium m processors from the "Intel Pentium M Processor
on 90 nm Process with 2-MB L2 Cache Datasheet"

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.10 2004/10/05 02:13:41 tedu Exp $ */
a151 1

d179 11
a201 1
#if 0
d214 14
a227 1
#endif
d295 1
d301 10
a310 10
#define ENTRY(s, v)	{ s, v, sizeof(v) / sizeof((v)[0]) }
	ENTRY(" 900", pentium_m_900),
	ENTRY("1000", pentium_m_1000),
	ENTRY("1100", pentium_m_1100),
	ENTRY("1200", pentium_m_1200),
	ENTRY("1300", pentium_m_1300),
	ENTRY("1400", pentium_m_1400),
	ENTRY("1500", pentium_m_1500),
	ENTRY("1600", pentium_m_1600),
	ENTRY("1700", pentium_m_1700),
d315 14
a328 14
#define ENTRY(s, v)	{ s, v, sizeof(v) / sizeof((v)[0]) }
	ENTRY("1.00", pentium_m_n723),
	ENTRY("1.10", pentium_m_n733),
	ENTRY("1.20", pentium_m_n753),
	ENTRY("1.40", pentium_m_n738),
#if 0
	ENTRY("1.50", pentium_m_n758),
#endif
	ENTRY("1.50", pentium_m_n715),
	ENTRY("1.60", pentium_m_n725),
	ENTRY("1.70", pentium_m_n735),
	ENTRY("1.80", pentium_m_n745),
	ENTRY("2.00", pentium_m_n755),
	ENTRY("2.10", pentium_m_n765),
d373 1
d401 2
a402 1
			    !strcmp(cpu->brand_suffix, tag + n)) {
@


1.10
log
@grab the perflevel during init so it's synced with reality.
other drivers to come.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.9 2004/07/16 18:14:23 deraadt Exp $ */
d46 4
d153 54
d259 12
d293 7
d305 1
@


1.9
log
@dothan est support, from some netbsd guy, tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.8 2004/06/06 17:34:37 grange Exp $ */
d261 1
d272 1
d321 3
@


1.8
log
@Don't touch any hardware registers while fetching hw.cpuspeed and
just return current pentium_mhz value. Update this value in
all hw.setperf hoos either via its own private methods or using
global update_cpuspeed hook, if registered.
Also implement update_cpuspeed hook for Pentium 3.

Tested by millert@@, Gabriel Kihlman <gk@@stacken.kth.se> and me on
various i386 machines.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.7 2004/02/27 21:46:44 grange Exp $ */
d149 52
d221 9
d242 6
a247 1
		(sizeof(pentium_m) / sizeof(pentium_m[0])),
@


1.7
log
@Move setperf_prio to the machdep code, requested by deraadt@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.6 2004/02/27 21:15:45 grange Exp $ */
a262 1
	cpu_cpuspeed = est_cpuspeed;
a286 8
	return (0);
}


int
est_cpuspeed(int *freq)
{
	*freq = MSR2MHZ(rdmsr(MSR_PERF_STATUS));
@


1.6
log
@Introduce simple priorities mechanism so that concurrent
hw.setperf handlers don't override each other.
Problem reported and tested by danh@@.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.5 2004/02/14 15:09:22 grange Exp $ */
d193 2
@


1.5
log
@Simplify hw.{cpuspeed,setperf} api moving all the sysctl stuff
from the underlying callbacks.

Testing hppa mickey@@, ppc drahn@@
Ok markus@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.4 2004/01/06 21:09:20 tedu Exp $ */
d204 3
d262 1
@


1.5.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.5 2004/02/14 15:09:22 grange Exp $ */
d262 1
a262 1
est_setperf(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
d264 1
a264 2
	static uint level = 100;
	int low, high, i, fq, error;
a269 6
	error = sysctl_int(oldp, oldlenp, newp, newlen, &level);
	if (error)
		return (error);

	if (level > 100)
		level = 100;
d287 1
a287 1
est_cpuspeed(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
d289 2
a290 5
	int freq;

	freq = MSR2MHZ(rdmsr(MSR_PERF_STATUS));

	return (sysctl_rdint(oldp, oldlenp, newp, freq));
@


1.5.2.2
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a193 2
extern int setperf_prio;

a203 3
	if (setperf_prio > 3)
		return;

a258 1
	setperf_prio = 3;
d262 1
a262 1
est_setperf(int level)
d264 2
a265 1
	int low, high, i, fq;
d271 6
d294 1
a294 1
est_cpuspeed(int *freq)
d296 5
a300 2
	*freq = MSR2MHZ(rdmsr(MSR_PERF_STATUS));
	return (0);
@


1.5.2.3
log
@sync to head
@
text
@d263 1
d288 8
@


1.4
log
@adjust pentium_mhz when cpu speed changes.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.3 2003/12/19 22:42:13 tedu Exp $ */
d262 1
a262 1
est_setperf(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
d264 1
a264 2
	static uint level = 100;
	int low, high, i, fq, error;
a269 6
	error = sysctl_int(oldp, oldlenp, newp, newlen, &level);
	if (error)
		return (error);

	if (level > 100)
		level = 100;
d287 1
a287 1
est_cpuspeed(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
d289 2
a290 5
	int freq;

	freq = MSR2MHZ(rdmsr(MSR_PERF_STATUS));

	return (sysctl_rdint(oldp, oldlenp, newp, freq));
@


1.3
log
@
add cpu_ecxfeature to cpu.h, and stop locally externing it and cpu_feature.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.2 2003/12/19 05:52:27 millert Exp $ */
a193 3
extern int (*cpu_cpuspeed)(void *, size_t *, void *, size_t);
extern int (*cpu_setperf)(void *, size_t *, void *, size_t);

d287 1
@


1.2
log
@Make this compile after the struct was reordered.  OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: est.c,v 1.1 2003/12/18 23:46:19 tedu Exp $ */
a204 1
	extern int cpu_ecxfeature;
@


1.1
log
@add new hw sysctls, cpuspeed and setperf to control cpu frequency.
convert longrun support to use new sysctls.
add enhanced speedstep support, based on code by Michael Eriksson.
idea, help testing & ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d156 1
a156 1
#define ENTRY(s, v)	{ s, sizeof(v) / sizeof((v)[0]), v }
d180 1
a181 1
		pentium_m
@

