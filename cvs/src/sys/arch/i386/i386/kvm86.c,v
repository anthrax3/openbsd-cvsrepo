head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.10
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.8
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.4
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.12
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.14
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.10
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.8
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.6
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.4
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.2
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.1.0.2
	OPENBSD_4_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.03.07.05.32.46;	author naddy;	state Exp;
branches;
next	1.10;
commitid	Ht3NH0pdlkYC6Nxx;

1.10
date	2015.04.12.18.37.53;	author mlarkin;	state Exp;
branches;
next	1.9;
commitid	5ST94uMTezmXYdhY;

1.9
date	2015.02.11.05.54.48;	author dlg;	state Exp;
branches;
next	1.8;
commitid	fAl1KR17j4jH74Xf;

1.8
date	2014.11.16.12.30.57;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	yv0ECmCdICvq576h;

1.7
date	2014.04.01.09.05.03;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2012.12.05.23.20.12;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.27.13.28.46;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.23.21.34.40;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.20.21.15.01;	author tom;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.27.16.00.19;	author gwk;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.13.03.01.04;	author gwk;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Sync no-argument function declaration and definition by adding (void).
ok mlarkin@@ deraadt@@
@
text
@/* $OpenBSD: kvm86.c,v 1.10 2015/04/12 18:37:53 mlarkin Exp $ */
/* $NetBSD: kvm86.c,v 1.10 2005/12/26 19:23:59 perry Exp $ */
/*
 * Copyright (c) 2002
 * 	Matthias Drochner.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/malloc.h>
#include <sys/mutex.h>

#include <uvm/uvm_extern.h>

#include <machine/pcb.h>
#include <machine/pte.h>
#include <machine/pmap.h>
#include <machine/kvm86.h>
#include <machine/cpu.h>

/* assembler functions in kvm86call.s */
extern int kvm86_call(struct trapframe *);
extern void kvm86_ret(struct trapframe *, int);

#define PGTABLE_SIZE	((1024 + 64) * 1024 / PAGE_SIZE)

typedef uint32_t pt_entry_t;

struct kvm86_data {
	pt_entry_t pgtbl[PGTABLE_SIZE];

	struct segment_descriptor sd;

	struct pcb pcb;
	u_long iomap[0x10000/32];
};

void kvm86_map(struct kvm86_data *, paddr_t, uint32_t);
void kvm86_mapbios(struct kvm86_data *);
void kvm86_prepare(struct kvm86_data *vmd);
/*
 * global VM for BIOS calls
 */
struct kvm86_data *bioscallvmd;
/* page for trampoline and stack */
void *bioscallscratchpage;
/* where this page is mapped in the vm86 */
#define BIOSCALLSCRATCHPAGE_VMVA 0x1000
/* a virtual page to map in vm86 memory temporarily */
vaddr_t bioscalltmpva;

struct mutex kvm86_mp_mutex;

#define KVM86_IOPL3 /* not strictly necessary, saves a lot of traps */

void
kvm86_init(void)
{
	size_t vmdsize;
	char *buf;
	struct kvm86_data *vmd;
	struct pcb *pcb;
	paddr_t pa;
	int i;

	vmdsize = round_page(sizeof(struct kvm86_data)) + PAGE_SIZE;

	if ((buf = (char *)uvm_km_zalloc(kernel_map, vmdsize)) == NULL)
		return;
	
	/* first page is stack */
	vmd = (struct kvm86_data *)(buf + PAGE_SIZE);
	pcb = &vmd->pcb;

	/*
	 * derive pcb and TSS from proc0
	 * we want to access all IO ports, so we need a full-size
	 *  permission bitmap
	 * XXX do we really need the pcb or just the TSS?
	 */
	memcpy(pcb, &proc0.p_addr->u_pcb, sizeof(struct pcb));
	pcb->pcb_tss.tss_esp0 = (int)vmd;
	pcb->pcb_tss.tss_ss0 = GSEL(GDATA_SEL, SEL_KPL);
	for (i = 0; i < sizeof(vmd->iomap) / 4; i++)
		vmd->iomap[i] = 0;
	pcb->pcb_tss.tss_ioopt =
	    ((caddr_t)vmd->iomap - (caddr_t)&pcb->pcb_tss) << 16;

	/* setup TSS descriptor (including our iomap) */
	setsegment(&vmd->sd, &pcb->pcb_tss,
	    sizeof(struct pcb) + sizeof(vmd->iomap) - 1,
	    SDT_SYS386TSS, SEL_KPL, 0, 0);

	/* prepare VM for BIOS calls */
	kvm86_mapbios(vmd);
	if ((bioscallscratchpage = (void *)uvm_km_alloc(kernel_map, PAGE_SIZE))
	    == 0)
		return;

	pmap_extract(pmap_kernel(), (vaddr_t)bioscallscratchpage, &pa);
	kvm86_map(vmd, pa, BIOSCALLSCRATCHPAGE_VMVA);
	bioscallvmd = vmd;
	bioscalltmpva = uvm_km_alloc(kernel_map, PAGE_SIZE);
	mtx_init(&kvm86_mp_mutex, IPL_IPI);
}

/*
 * XXX pass some stuff to the assembler code
 * XXX this should be done cleanly (in call argument to kvm86_call())
 */

volatile struct pcb *vm86pcb;
volatile int vm86tssd0, vm86tssd1;
volatile paddr_t vm86newptd;
volatile struct trapframe *vm86frame;
volatile pt_entry_t *vm86pgtableva;

void
kvm86_prepare(struct kvm86_data *vmd)
{
	vm86newptd = vtophys((vaddr_t)vmd) | PG_V | PG_RW | PG_U | PG_u;
	vm86pgtableva = vmd->pgtbl;
	vm86frame = (struct trapframe *)vmd - 1;
	vm86pcb = &vmd->pcb;
	vm86tssd0 = *(int*)&vmd->sd;
	vm86tssd1 = *((int*)&vmd->sd + 1);
}

void
kvm86_map(struct kvm86_data *vmd, paddr_t pa, uint32_t vmva)
{

	vmd->pgtbl[vmva >> 12] = pa | PG_V | PG_RW | PG_U | PG_u;
}

void
kvm86_mapbios(struct kvm86_data *vmd)
{
	paddr_t pa;

	/* map first physical page (vector table, BIOS data) */
	kvm86_map(vmd, 0, 0);

	/* map ISA hole */
	for (pa = 0xa0000; pa < 0x100000; pa += PAGE_SIZE)
		kvm86_map(vmd, pa, pa);
}

void *
kvm86_bios_addpage(uint32_t vmva)
{
	void *mem;
	paddr_t pa;

	if (bioscallvmd->pgtbl[vmva >> 12]) /* allocated? */
		return (NULL);

	if ((mem = (void *)uvm_km_alloc(kernel_map, PAGE_SIZE)) == NULL)
		return (NULL);
	
	pmap_extract(pmap_kernel(), (vaddr_t)mem, &pa);	
	kvm86_map(bioscallvmd, pa, vmva);

	return (mem);
}

void
kvm86_bios_delpage(uint32_t vmva, void *kva)
{

	bioscallvmd->pgtbl[vmva >> 12] = 0;
	uvm_km_free(kernel_map, (vaddr_t)kva, PAGE_SIZE);
}

size_t
kvm86_bios_read(u_int32_t vmva, char *buf, size_t len)
{
	size_t todo, now;
	paddr_t vmpa;

	todo = len;
	while (todo > 0) {
		now = min(todo, PAGE_SIZE - (vmva & (PAGE_SIZE - 1)));

		if (!bioscallvmd->pgtbl[vmva >> 12])
			break;
		vmpa = bioscallvmd->pgtbl[vmva >> 12] & ~(PAGE_SIZE - 1);
		pmap_kenter_pa(bioscalltmpva, vmpa, PROT_READ);
		pmap_update(pmap_kernel());

		memcpy(buf, (void *)(bioscalltmpva + (vmva & (PAGE_SIZE - 1))),
		       now);
		buf += now;
		todo -= now;
		vmva += now;
	}
	return (len - todo);
}

int
kvm86_bioscall(int intno, struct trapframe *tf)
{
	static const unsigned char call[] = {
		0xfa, /* CLI */
		0xcd, /* INTxx */
		0,
		0xfb, /* STI */
		0xf4  /* HLT */
	};

	memcpy(bioscallscratchpage, call, sizeof(call));
	*((unsigned char *)bioscallscratchpage + 2) = intno;

	tf->tf_eip = BIOSCALLSCRATCHPAGE_VMVA;
	tf->tf_cs = 0;
	tf->tf_esp = BIOSCALLSCRATCHPAGE_VMVA + PAGE_SIZE - 2;
	tf->tf_ss = 0;
	tf->tf_eflags = PSL_USERSET | PSL_VM;
#ifdef KVM86_IOPL3
	tf->tf_eflags |= PSL_IOPL;
#endif
	tf->tf_ds = tf->tf_es = tf->tf_fs = tf->tf_gs = 0;

	kvm86_prepare(bioscallvmd); /* XXX */
	return (kvm86_call(tf));
}

int
kvm86_simplecall(int no, struct kvm86regs *regs)
{
	struct trapframe tf;
	int res;
	
	memset(&tf, 0, sizeof(struct trapframe));
	tf.tf_eax = regs->eax;
	tf.tf_ebx = regs->ebx;
	tf.tf_ecx = regs->ecx;
	tf.tf_edx = regs->edx;
	tf.tf_esi = regs->esi;
	tf.tf_edi = regs->edi;
	tf.tf_vm86_es = regs->es;
	
	mtx_enter(&kvm86_mp_mutex);	
	res = kvm86_bioscall(no, &tf);
	mtx_leave(&kvm86_mp_mutex);

	regs->eax = tf.tf_eax;
	regs->ebx = tf.tf_ebx;
	regs->ecx = tf.tf_ecx;
	regs->edx = tf.tf_edx;
	regs->esi = tf.tf_esi;
	regs->edi = tf.tf_edi;
	regs->es = tf.tf_vm86_es;
	regs->eflags = tf.tf_eflags;
	
	return (res);
}

void
kvm86_gpfault(struct trapframe *tf)
{
	unsigned char *kva, insn, trapno;
	uint16_t *sp;

	kva = (unsigned char *)((tf->tf_cs << 4) + tf->tf_eip);
	insn = *kva;
#ifdef KVM86DEBUG
	printf("kvm86_gpfault: cs=%x, eip=%x, insn=%x, eflags=%x\n",
	       tf->tf_cs, tf->tf_eip, insn, tf->tf_eflags);
#endif

	KASSERT(tf->tf_eflags & PSL_VM);

	switch (insn) {
	case 0xf4: /* HLT - normal exit */
		kvm86_ret(tf, 0);
		break;
	case 0xcd: /* INTxx */
		/* fake a return stack frame and call real mode handler */
		trapno = *(kva + 1);
		sp = (uint16_t *)((tf->tf_ss << 4) + tf->tf_esp);
		*(--sp) = tf->tf_eflags;
		*(--sp) = tf->tf_cs;
		*(--sp) = tf->tf_eip + 2;
		tf->tf_esp -= 6;
		tf->tf_cs = *(uint16_t *)(trapno * 4 + 2);
		tf->tf_eip = *(uint16_t *)(trapno * 4);
		break;
	case 0xcf: /* IRET */
		sp = (uint16_t *)((tf->tf_ss << 4) + tf->tf_esp);
		tf->tf_eip = *(sp++);
		tf->tf_cs = *(sp++);
		tf->tf_eflags = *(sp++);
		tf->tf_esp += 6;
		tf->tf_eflags |= PSL_VM; /* outside of 16bit flag reg */
		break;
#ifndef KVM86_IOPL3 /* XXX check VME? */
	case 0xfa: /* CLI */
	case 0xfb: /* STI */
		/* XXX ignore for now */
		tf->tf_eip++;
		break;
	case 0x9c: /* PUSHF */
		sp = (uint16_t *)((tf->tf_ss << 4) + tf->tf_esp);
		*(--sp) = tf->tf_eflags;
		tf->tf_esp -= 2;
		tf->tf_eip++;
		break;
	case 0x9d: /* POPF */
		sp = (uint16_t *)((tf->tf_ss << 4) + tf->tf_esp);
		tf->tf_eflags = *(sp++);
		tf->tf_esp += 2;
		tf->tf_eip++;
		tf->tf_eflags |= PSL_VM; /* outside of 16bit flag reg */
		break;
#endif
	default:
#ifdef KVM86DEBUG
		printf("kvm86_gpfault: unhandled\n");
#else
		printf("kvm86_gpfault: cs=%x, eip=%x, insn=%x, eflags=%x\n",
		       tf->tf_cs, tf->tf_eip, insn, tf->tf_eflags);
#endif
		/*
		 * signal error to caller
		 */
		kvm86_ret(tf, -1);
		break;
	}
}
@


1.10
log
@
Bring PAE code back to life, in a different form. This diff (via bluhm then
to deraadt, then myself) brings the PAE pmap on i386 (not touched in any
significant way for years) closer to the current non-PAE pmap and allows
us to take a big next step toward better i386 W^X in the kernel (similar to
what we did a few months ago on amd64). Unlike the original PAE pmap, this
diff will not be supporting > 4GB physical memory on i386 - this effort is
specifically geared toward providing W^X (via NX) only.

There still seems to be a bug removing certain pmap entries when PAE is
enabled, so I'm leaving PAE mode disabled for the moment until we can
figure out what is going on, but with this diff in the tree hopefully
others can help.

The pmap functions now operate through function pointers, due to the need
to support both non-PAE and PAE forms. My unscientific testing showed
less than 0.3% (a third of a percent) slowdown with this approach during
a base build.

Discussed for months with guenther, kettenis, and deraadt.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: kvm86.c,v 1.9 2015/02/11 05:54:48 dlg Exp $ */
d80 1
a80 1
kvm86_init()
@


1.9
log
@deprecate use of sys/lock.h and replace it with sys/atomic.h or
machine/lock.h as appropriate.
@
text
@d1 1
a1 1
/* $OpenBSD: kvm86.c,v 1.8 2014/11/16 12:30:57 deraadt Exp $ */
d49 2
@


1.8
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: kvm86.c,v 1.7 2014/04/01 09:05:03 mpi Exp $ */
a34 1
#include <sys/lock.h>
@


1.7
log
@More <uvm/uvm.h> -> <uvm/uvm_extern.h> cleaning.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: kvm86.c,v 1.6 2012/12/05 23:20:12 deraadt Exp $ */
d210 1
a210 1
		pmap_kenter_pa(bioscalltmpva, vmpa, VM_PROT_READ);
@


1.6
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: kvm86.c,v 1.5 2010/06/27 13:28:46 miod Exp $ */
d36 3
a38 1
#include <uvm/uvm.h>
@


1.5
log
@If you include <uvm/uvm.h>, you do not need to include any other <uvm/uvm_foo.h>
@
text
@d1 1
a1 1
/* $OpenBSD: kvm86.c,v 1.4 2010/04/23 21:34:40 deraadt Exp $ */
a27 1
#include <sys/cdefs.h>
@


1.4
log
@Merge the only relevant (for now) parts of simplelock.h into lock.h
since it is time to start transitioning away from the no-op behaviour.
ok oga kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: kvm86.c,v 1.3 2007/02/20 21:15:01 tom Exp $ */
a36 1
#include <uvm/uvm_extern.h>
@


1.3
log
@Revert PAE pmap for now, until the strange bug is found.  This stops
the freezes many of us are seeing (especially on amd64 machines running
OpenBSD/i386).

Much testing by nick@@ (as always - thanks!), hugh@@, ian@@, kettenis@@
and Sam Smith (s (at) msmith (dot) net).

Requested by, input from, and ok deraadt@@  ok art@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: kvm86.c,v 1.2 2006/11/27 16:00:19 gwk Exp $ */
d36 1
a36 1
#include <sys/simplelock.h>
@


1.2
log
@First attempt at making kvm86 MP safe, place mutex lock around calls
to kvm86_bioscall at IPL_IPI this might be incorrect, seems to fix
some issues with vt switching, however X still bombs on the second attempt with
disappointing frequency.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: kvm86.c,v 1.1 2006/06/13 03:01:04 gwk Exp $ */
a49 3

/* XXX: not here */
typedef u_int32_t pt_entry_t;
@


1.1
log
@Kernel virtual mode 8086, currently disabled in GENERIC.
lots of help at c2k6 and after from toby@@,
ok toby@@, mickey@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d35 2
d77 2
d129 1
d268 1
d270 2
a271 1
	
@

