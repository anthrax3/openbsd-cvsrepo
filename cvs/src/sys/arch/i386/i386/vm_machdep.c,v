head	1.67;
access;
symbols
	OPENBSD_6_2:1.67.0.2
	OPENBSD_6_2_BASE:1.67
	OPENBSD_6_1:1.65.0.4
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.64.0.2
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.63.0.2
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.63.0.4
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.61.0.2
	OPENBSD_5_7_BASE:1.61
	OPENBSD_5_6:1.60.0.10
	OPENBSD_5_6_BASE:1.60
	OPENBSD_5_5:1.60.0.8
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.60.0.4
	OPENBSD_5_4_BASE:1.60
	OPENBSD_5_3:1.60.0.2
	OPENBSD_5_3_BASE:1.60
	OPENBSD_5_2:1.58.0.14
	OPENBSD_5_2_BASE:1.58
	OPENBSD_5_1_BASE:1.58
	OPENBSD_5_1:1.58.0.12
	OPENBSD_5_0:1.58.0.10
	OPENBSD_5_0_BASE:1.58
	OPENBSD_4_9:1.58.0.8
	OPENBSD_4_9_BASE:1.58
	OPENBSD_4_8:1.58.0.6
	OPENBSD_4_8_BASE:1.58
	OPENBSD_4_7:1.58.0.2
	OPENBSD_4_7_BASE:1.58
	OPENBSD_4_6:1.58.0.4
	OPENBSD_4_6_BASE:1.58
	OPENBSD_4_5:1.56.0.2
	OPENBSD_4_5_BASE:1.56
	OPENBSD_4_4:1.54.0.4
	OPENBSD_4_4_BASE:1.54
	OPENBSD_4_3:1.54.0.2
	OPENBSD_4_3_BASE:1.54
	OPENBSD_4_2:1.52.0.2
	OPENBSD_4_2_BASE:1.52
	OPENBSD_4_1:1.49.0.2
	OPENBSD_4_1_BASE:1.49
	OPENBSD_4_0:1.45.0.2
	OPENBSD_4_0_BASE:1.45
	OPENBSD_3_9:1.42.0.2
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.41.0.2
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.40.0.4
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.40.0.2
	OPENBSD_3_6_BASE:1.40
	SMP_SYNC_A:1.39
	SMP_SYNC_B:1.39
	OPENBSD_3_5:1.39.0.4
	OPENBSD_3_5_BASE:1.39
	OPENBSD_3_4:1.39.0.2
	OPENBSD_3_4_BASE:1.39
	UBC_SYNC_A:1.38
	OPENBSD_3_3:1.38.0.2
	OPENBSD_3_3_BASE:1.38
	OPENBSD_3_2:1.37.0.2
	OPENBSD_3_2_BASE:1.37
	OPENBSD_3_1:1.36.0.4
	OPENBSD_3_1_BASE:1.36
	UBC_SYNC_B:1.37
	UBC:1.36.0.2
	UBC_BASE:1.36
	OPENBSD_3_0:1.30.0.2
	OPENBSD_3_0_BASE:1.30
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.17.0.6
	OPENBSD_2_7_BASE:1.17
	SMP:1.17.0.4
	SMP_BASE:1.17
	kame_19991208:1.17
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.16.0.2
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.12.0.6
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.12.0.4
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.11.0.2
	OPENBSD_2_0_BASE:1.11
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.67
date	2017.08.18.16.53.02;	author tom;	state Exp;
branches;
next	1.66;
commitid	9ho9zlbP5bkovcOD;

1.66
date	2017.08.16.18.34.10;	author deraadt;	state Exp;
branches;
next	1.65;
commitid	EyI8csXpSfpIPHgo;

1.65
date	2017.02.12.04.55.08;	author guenther;	state Exp;
branches;
next	1.64;
commitid	1rXx7AiXIWFC9gYa;

1.64
date	2016.04.03.17.45.30;	author guenther;	state Exp;
branches;
next	1.63;
commitid	r6DSGGWL0yrlGnH8;

1.63
date	2015.05.05.02.13.46;	author guenther;	state Exp;
branches;
next	1.62;
commitid	dNPv28CJI5BxtRGW;

1.62
date	2015.03.31.04.35.50;	author guenther;	state Exp;
branches;
next	1.61;
commitid	mpfrKObjwsjtDBz4;

1.61
date	2014.11.16.12.30.57;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	yv0ECmCdICvq576h;

1.60
date	2013.01.16.19.04.43;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2012.07.28.19.48.54;	author guenther;	state Exp;
branches;
next	1.58;

1.58
date	2009.06.03.00.49.12;	author art;	state Exp;
branches;
next	1.57;

1.57
date	2009.03.26.17.24.33;	author oga;	state Exp;
branches;
next	1.56;

1.56
date	2009.02.03.11.24.19;	author mikeb;	state Exp;
branches;
next	1.55;

1.55
date	2009.01.17.23.44.46;	author guenther;	state Exp;
branches;
next	1.54;

1.54
date	2007.10.13.07.18.32;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2007.10.10.15.53.51;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2007.05.27.20.59.25;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2007.05.25.15.55.26;	author art;	state Exp;
branches;
next	1.50;

1.50
date	2007.03.19.15.17.21;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2007.02.24.11.59.45;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2007.02.20.21.15.01;	author tom;	state Exp;
branches;
next	1.47;

1.47
date	2006.11.29.12.26.13;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.45;

1.45
date	2006.06.23.13.46.05;	author mickey;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.11.13.21.12;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.27.15.37.51;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2005.11.25.14.07.17;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2005.08.01.17.04.47;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.39;

1.39
date	2003.06.02.23.27.47;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2003.01.16.04.15.17;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.11.22.15.12;	author wilfried;	state Exp;
branches;
next	1.36;

1.36
date	2001.12.08.02.24.06;	author art;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2001.12.07.17.30.14;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2001.12.07.00.59.16;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2001.11.27.05.27.11;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.06.18.41.09;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.21.02.11.57;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2001.07.25.13.25.32;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.08.08.08.53;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.06.00.45.50;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.05.23.25.43;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.05.21.26.37;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.23.18.41.01;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.23.14.26.10;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.22.23.36.51;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.08.00.46.35;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.08.22.25.19;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.05.11.02.54;	author art;	state Exp;
branches;
next	1.17;

1.17
date	99.08.17.10.32.16;	author niklas;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	99.02.26.10.37.51;	author art;	state Exp;
branches;
next	1.15;

1.15
date	99.02.26.10.26.57;	author art;	state Exp;
branches;
next	1.14;

1.14
date	99.01.10.13.34.18;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	98.07.28.00.13.36;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	96.10.16.23.12.06;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.05.07.07.21.59;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.05.02.13.40.28;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.04.21.22.16.43;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.04.17.05.19.00;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.03.19.21.09.24;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.02.28.14.38.47;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	95.12.30.08.24.32;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.12.27.06.14.48;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.26.20.29.50;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.07.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.34;	author deraadt;	state Exp;
branches;
next	;

1.17.4.1
date	2001.04.18.16.07.24;	author niklas;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2001.07.04.10.16.43;	author niklas;	state Exp;
branches;
next	1.17.4.3;

1.17.4.3
date	2001.07.14.10.02.33;	author ho;	state Exp;
branches;
next	1.17.4.4;

1.17.4.4
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.17.4.5;

1.17.4.5
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.17.4.6;

1.17.4.6
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.17.4.7;

1.17.4.7
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.17.4.8;

1.17.4.8
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.17.4.9;

1.17.4.9
date	2003.04.11.16.12.57;	author niklas;	state Exp;
branches;
next	1.17.4.10;

1.17.4.10
date	2003.05.13.19.42.08;	author ho;	state Exp;
branches;
next	1.17.4.11;

1.17.4.11
date	2003.06.07.11.11.37;	author ho;	state Exp;
branches;
next	1.17.4.12;

1.17.4.12
date	2004.02.20.22.19.55;	author niklas;	state Exp;
branches;
next	1.17.4.13;

1.17.4.13
date	2004.04.21.09.33.08;	author niklas;	state Exp;
branches;
next	1.17.4.14;

1.17.4.14
date	2004.06.06.18.42.07;	author grange;	state Exp;
branches;
next	1.17.4.15;

1.17.4.15
date	2004.06.06.19.01.37;	author grange;	state Exp;
branches;
next	1.17.4.16;

1.17.4.16
date	2004.06.07.20.27.11;	author art;	state Exp;
branches;
next	;

1.36.2.1
date	2002.10.29.00.28.04;	author art;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.67
log
@We just need arc4random() for kernel stack random bias (modulo bios happens
with arc4random() % N when N is not a power of 2, which is why we normally
use arc4random_uniform(N), but PAGE_SIZE is always going to be a power of 2.
And to make it clear, use bitwise AND rather than %.)

ok deraadt@@
@
text
@/*	$OpenBSD: vm_machdep.c,v 1.66 2017/08/16 18:34:10 deraadt Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.61 1996/05/03 19:42:35 christos Exp $	*/

/*-
 * Copyright (c) 1995 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1982, 1986 The Regents of the University of California.
 * Copyright (c) 1989, 1990 William Jolitz
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department, and William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vm_machdep.c	7.3 (Berkeley) 5/13/91
 */

/*
 *	Utah $Hdr: vm_machdep.c 1.16.1.1 89/06/23$
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/malloc.h>
#include <sys/vnode.h>
#include <sys/buf.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/ptrace.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/gdt.h>
#include <machine/reg.h>
#include <machine/specialreg.h>

#include "npx.h"

/*
 * Finish a fork operation, with process p2 nearly set up.
 * Copy and update the kernel stack and pcb, making the child
 * ready to run, and marking it so that it can return differently
 * than the parent.  Returns 1 in the child process, 0 in the parent.
 */
void
cpu_fork(struct proc *p1, struct proc *p2, void *stack, void *tcb,
    void (*func)(void *), void *arg)
{
	struct pcb *pcb = &p2->p_addr->u_pcb;
	struct trapframe *tf;
	struct switchframe *sf;

#if NNPX > 0
	npxsave_proc(p1, 1);
#endif

	p2->p_md.md_flags = p1->p_md.md_flags;

#ifdef DIAGNOSTIC
	if (p1 != curproc && p1 != &proc0)
		panic("cpu_fork: curproc");
#endif
	*pcb = p1->p_addr->u_pcb;

	/* Fix up the TSS. */
	pcb->pcb_tss.tss_ss0 = GSEL(GDATA_SEL, SEL_KPL);
	pcb->pcb_tss.tss_esp0 = (int)p2->p_addr + USPACE - 16 -
	    (arc4random() & PAGE_MASK & ~_STACKALIGNBYTES);

	p2->p_md.md_tss_sel = tss_alloc(pcb);

	/*
	 * Copy the trapframe, and arrange for the child to return directly
	 */
	p2->p_md.md_regs = tf = (struct trapframe *)pcb->pcb_tss.tss_esp0 - 1;
	*tf = *p1->p_md.md_regs;

	/*
	 * If specified, give the child a different stack and/or TCB
	 */
	if (stack != NULL)
		tf->tf_esp = (u_int)stack;
	if (tcb != NULL)
		i386_set_threadbase(p2, (uint32_t)tcb, TSEG_GS);

	sf = (struct switchframe *)tf - 1;
	sf->sf_esi = (int)func;
	sf->sf_ebx = (int)arg;
	sf->sf_eip = (int)proc_trampoline;
	pcb->pcb_esp = (int)sf;
	pcb->pcb_ebp = 0;
}

/*
 * cpu_exit is called as the last action during exit.
 */
void
cpu_exit(struct proc *p)
{
#if NNPX > 0
	/* If we were using the FPU, forget about it. */
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		npxsave_proc(p, 0);
#endif

	tss_free(p->p_md.md_tss_sel);
	sched_exit(p);
}

/*
 * Convert kernel VA to physical address
 */
int
kvtop(caddr_t addr)
{
	paddr_t pa;

	if (pmap_extract(pmap_kernel(), (vaddr_t)addr, &pa) == FALSE)
		panic("kvtop: zero page frame");
	return((int)pa);
}

/*
 * Map an user IO request into kernel virtual address space.
 */
void
vmapbuf(struct buf *bp, vsize_t len)
{
	vaddr_t faddr, taddr, off;
	paddr_t fpa;

	if ((bp->b_flags & B_PHYS) == 0)
		panic("vmapbuf");
	faddr = trunc_page((vaddr_t)(bp->b_saveaddr = bp->b_data));
	off = (vaddr_t)bp->b_data - faddr;
	len = round_page(off + len);
	taddr= uvm_km_valloc_wait(phys_map, len);
	bp->b_data = (caddr_t)(taddr + off);
	/*
	 * The region is locked, so we expect that pmap_pte() will return
	 * non-NULL.
	 * XXX: unwise to expect this in a multithreaded environment.
	 * anything can happen to a pmap between the time we lock a
	 * region, release the pmap lock, and then relock it for
	 * the pmap_extract().
	 *
	 * no need to flush TLB since we expect nothing to be mapped
	 * where we we just allocated (TLB will be flushed when our
	 * mapping is removed).
	 */
	while (len) {
		pmap_extract(vm_map_pmap(&bp->b_proc->p_vmspace->vm_map),
		    faddr, &fpa);
		pmap_kenter_pa(taddr, fpa, PROT_READ | PROT_WRITE);
		faddr += PAGE_SIZE;
		taddr += PAGE_SIZE;
		len -= PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
}

/*
 * Free the io map PTEs associated with this IO operation.
 * We also invalidate the TLB entries and restore the original b_addr.
 */
void
vunmapbuf(struct buf *bp, vsize_t len)
{
	vaddr_t addr, off;

	if ((bp->b_flags & B_PHYS) == 0)
		panic("vunmapbuf");
	addr = trunc_page((vaddr_t)bp->b_data);
	off = (vaddr_t)bp->b_data - addr;
	len = round_page(off + len);
	pmap_kremove(addr, len);
	pmap_update(pmap_kernel());
	uvm_km_free_wakeup(phys_map, addr, len);
	bp->b_data = bp->b_saveaddr;
	bp->b_saveaddr = 0;
}
@


1.66
log
@Randomly bias downwards from the top of each kernel stack, thereby
introducing more entropy into stack locations.
TODO: consider if we should fill that space with something specific?
discussed with mlarkin, mortimer, guenther, kettenis, etc etc etc
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.65 2017/02/12 04:55:08 guenther Exp $	*/
d94 1
a94 1
	    (arc4random_uniform(PAGE_SIZE) & ~_STACKALIGNBYTES);
@


1.65
log
@Split up fork1():
 - FORK_THREAD handling is a totally separate function, thread_fork(),
   that is only used by sys___tfork() and which loses the flags, func,
   arg, and newprocp parameters and gains tcb parameter to guarantee
   the new thread's TCB is set before the creating thread returns
 - fork1() loses its stack and tidptr parameters
Common bits factor out:
 - struct proc allocation and initialization moves to thread_new()
 - maxthread handling moves to fork_check_maxthread()
 - setting the new thread running moves to fork_thread_start()
The MD cpu_fork() function swaps its unused stacksize parameter for
a tcb parameter.

luna88k testing by aoyama@@, alpha testing by dlg@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.64 2016/04/03 17:45:30 guenther Exp $	*/
d93 2
a94 1
	pcb->pcb_tss.tss_esp0 = (int)p2->p_addr + USPACE - 16;
@


1.64
log
@Don't call savectx() from cpu_fork(): the registers saved are overwritten
and the PCB_SAVECTX flag would be a lie.

ok kettenis@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.63 2015/05/05 02:13:46 guenther Exp $	*/
a69 3
 * We currently double-map the user area so that the stack is at the same
 * address in each process; in the future we will probably relocate
 * the frame pointers on the stack after copying.
d72 1
a72 1
cpu_fork(struct proc *p1, struct proc *p2, void *stack, size_t stacksize,
d104 1
a104 1
	 * If specified, give the child a different stack.
d107 3
a109 1
		tf->tf_esp = (u_int)stack + stacksize;
@


1.63
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.62 2015/03/31 04:35:50 guenther Exp $	*/
a87 5
	/* Copy pcb from proc p1 to p2. */
	if (p1 == curproc) {
		/* Sync the PCB before we copy it. */
		savectx(curpcb);
	}
d89 1
a89 1
	else if (p1 != &proc0)
@


1.62
log
@zero the frame pointer of the kernel stack of new threads to make ddb trace
happier

ok dlg@@ jsing@@ kettenis@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.61 2014/11/16 12:30:57 deraadt Exp $	*/
a52 1
#include <sys/core.h>
a138 50
}

/*
 * Dump the machine specific segment at the start of a core dump.
 */
struct md_core {
	struct reg intreg;
	struct fpreg freg;
};

int
cpu_coredump(struct proc *p, struct vnode *vp, struct ucred *cred,
    struct core *chdr)
{
	struct md_core md_core;
	struct coreseg cseg;
	int error;

	CORE_SETMAGIC(*chdr, COREMAGIC, MID_I386, 0);
	chdr->c_hdrsize = ALIGN(sizeof(*chdr));
	chdr->c_seghdrsize = ALIGN(sizeof(cseg));
	chdr->c_cpusize = sizeof(md_core);

	/* Save integer registers. */
	error = process_read_regs(p, &md_core.intreg);
	if (error)
		return error;

	/* Save floating point registers. */
	error = process_read_fpregs(p, &md_core.freg);
	if (error)
		return error;

	CORE_SETMAGIC(cseg, CORESEGMAGIC, MID_I386, CORE_CPU);
	cseg.c_addr = 0;
	cseg.c_size = chdr->c_cpusize;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&cseg, chdr->c_seghdrsize,
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&md_core, sizeof(md_core),
	    (off_t)(chdr->c_hdrsize + chdr->c_seghdrsize), UIO_SYSSPACE,
	    IO_UNIT, cred, NULL, p);
	if (error)
		return error;

	chdr->c_nseg++;
	return 0;
@


1.61
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.60 2013/01/16 19:04:43 miod Exp $	*/
d123 1
@


1.60
log
@cpu_coredump() also needs to invoke vn_rdwr() without IO_NODELOCKED; only
affects a.out binaries' core dumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.59 2012/07/28 19:48:54 guenther Exp $	*/
d235 1
a235 1
		pmap_kenter_pa(taddr, fpa, VM_PROT_READ|VM_PROT_WRITE);
@


1.59
log
@zap a misleading comment
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.58 2009/06/03 00:49:12 art Exp $	*/
d177 1
a177 2
	    (off_t)chdr->c_hdrsize, UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred,
	    NULL, p);
d183 1
a183 1
	    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
@


1.58
log
@Just like on amd64. Instead of keeping a bitmap of which cpus a pmap
is active on, save a curpmap pointer in cpu_info. This lets us simplify
a few things and do lazy context switching from a user process to a
kernel thread. There's a new IPI introduced for forcing a cr3 reload
when we're tearing down a dead pmap.

kettenis@@ ok (after I polished a few minor things)
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.57 2009/03/26 17:24:33 oga Exp $	*/
a107 1
	 * through rei().
@


1.57
log
@Remove cpu_wait(). It's original use was to be called from the reaper so
MD code would free resources that couldn't be freed until we were no
longer running in that processor. However, it's is unused on all
architectures since mikeb@@'s tss changes on x86 earlier in the year.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.56 2009/02/03 11:24:19 mikeb Exp $	*/
a137 1
	pmap_deactivate(p);
@


1.56
log
@Free TSS on the stack of the dead process.

In order to do that we have to remove all sleeping parts: sleeping
memory allocation and a sleeping lock.  Thus we're moving this code
to the spinning lock (mutex) and getting rid of the GDT grow code.
Downside is that now we're pre-allocating 64kb of memory per CPU
from the start, but this might be optimized in future.

This also unifies GDT code and MAXGDTSIZ define across i386 and amd64.

With help from mickey.

ok toby, art
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.55 2009/01/17 23:44:46 guenther Exp $	*/
a140 5
}

void
cpu_wait(struct proc *p)
{
@


1.55
log
@gdt_compact() was removed years ago, so kill the code and comments
that worked around its presence

ok'ed by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.54 2007/10/13 07:18:32 miod Exp $	*/
d139 1
a145 1
	tss_free(p->p_md.md_tss_sel);
@


1.54
log
@Fix cpu_exit() comments to be more closer to reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.53 2007/10/10 15:53:51 art Exp $	*/
a98 9

	/*
	 * Preset these so that gdt_compact() doesn't get confused if called
	 * during the allocations below.
	 *
	 * Note: pcb_ldt_sel is handled in the pmap_activate() call when
	 * we run the new process.
	 */
	p2->p_md.md_tss_sel = GSEL(GNULL_SEL, SEL_KPL);
@


1.53
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.52 2007/05/27 20:59:25 miod Exp $	*/
a136 5
 *
 * We clean up a little and then call switch_exit() with the old proc as an
 * argument.  switch_exit() first switches to proc0's context, then does the
 * vmspace_free() and kmem_free() that we don't do here, and finally jumps
 * into switch() to wait for another process to wake up.
@


1.52
log
@pagemove() is no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.51 2007/05/25 15:55:26 art Exp $	*/
a128 1
	sf->sf_ppl = 0;
d153 1
a153 1
	switch_exit(p);
@


1.51
log
@Replace the overdesigned and overcomplicated tlb shootdown code with
very simple and dumb fast tlb IPI handlers that have in the order of
the same amount of instructions as the old code had function calls.

All TLB shootdowns are reorganized so that we always shoot the,
without looking at PG_U and when we're shooting a range (primarily in
pmap_remove), we shoot the range when there are 32 or less pages in
it, otherwise we just nuke the whole TLB (this might need tweaking if
someone is interested in micro-optimization). The IPIs are not handled
through the normal interrupt vectoring code, they are not blockable
and they only shoot one page or a range of pages or the whole tlb.

This gives a 15% reduction in system time on my dual-core laptop
during a kernel compile and an 18% reduction in real time on a quad
machine doing bulk ports build.

Tested by many, in snaps for a week, no slowdowns reported (although not
everyone is seeing such huge wins).
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.50 2007/03/19 15:17:21 art Exp $	*/
a211 38
}

/*
 * Move pages from one kernel virtual address to another.
 * Both addresses are assumed to reside in the Sysmap.
 */
void
pagemove(caddr_t from, caddr_t to, size_t size)
{
	pt_entry_t *fpte, *tpte;
	pt_entry_t ofpte, otpte;
	vaddr_t fsva, tsva, feva, teva;

#ifdef DIAGNOSTIC
	if ((size & PAGE_MASK) != 0)
		panic("pagemove");
#endif

	fsva = (vaddr_t)from;
	tsva = (vaddr_t)to;
	feva = fsva + size;
	teva = tsva + size;

	fpte = kvtopte((vaddr_t)from);
	tpte = kvtopte((vaddr_t)to);
	while (size > 0) {
		ofpte = *fpte;
		otpte = *tpte;
		*tpte++ = *fpte;
		*fpte++ = 0;

		from += PAGE_SIZE;
		to += PAGE_SIZE;
		size -= PAGE_SIZE;
	}
	pmap_tlb_shootrange(pmap_kernel(), fsva, feva);
	pmap_tlb_shootrange(pmap_kernel(), tsva, teva);
	pmap_tlb_shootwait();
@


1.50
log
@Deactivate the pmap in cpu_exit. This way we can avoid quite a lot of
tlb shootdowns in the reaper.

mickey@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.49 2007/02/24 11:59:45 miod Exp $	*/
d223 1
a223 3
#ifdef MULTIPROCESSOR
	u_int32_t cpumask = 0;
#endif
d229 6
a241 19
#if defined(I386_CPU) && !defined(MULTIPROCESSOR)
		if (cpu_class != CPUCLASS_386)
#endif
		{
			if (otpte & PG_V)
#ifdef MULTIPROCESSOR
				pmap_tlb_shootdown(pmap_kernel(), (vaddr_t)to,
				    otpte, &cpumask);
#else
				pmap_update_pg((vaddr_t)to);
#endif
			if (ofpte & PG_V)
#ifdef MULTIPROCESSOR
				pmap_tlb_shootdown(pmap_kernel(),
				    (vaddr_t)from, ofpte, &cpumask);
#else
				pmap_update_pg((vaddr_t)from);
#endif
		}
d247 3
a249 8
#ifdef MULTIPROCESSOR
	pmap_tlb_shootnow(cpumask);
#else
#if defined(I386_CPU)
	if (cpu_class == CPUCLASS_386)
		tlbflush();		
#endif
#endif
@


1.49
log
@Remove unused B_DIRTY, B_PAGET, B_PGIN, B_TAPE and B_UAREA b_flags values.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.48 2007/02/20 21:15:01 tom Exp $	*/
d153 1
@


1.48
log
@Revert PAE pmap for now, until the strange bug is found.  This stops
the freezes many of us are seeing (especially on amd64 machines running
OpenBSD/i386).

Much testing by nick@@ (as always - thanks!), hugh@@, ian@@, kettenis@@
and Sam Smith (s (at) msmith (dot) net).

Requested by, input from, and ok deraadt@@  ok art@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.42 2005/11/25 14:07:17 mickey Exp $	*/
d285 1
a285 16
 * Map an IO request into kernel virtual address space.  Requests fall into
 * one of five catagories:
 *
 *	B_PHYS|B_UAREA:	User u-area swap.
 *			Address is relative to start of u-area (p_addr).
 *	B_PHYS|B_PAGET:	User page table swap.
 *			Address is a kernel VA in usrpt (Usrptmap).
 *	B_PHYS|B_DIRTY:	Dirty page push.
 *			Address is a VA in proc2's address space.
 *	B_PHYS|B_PGIN:	Kernel pagein of user pages.
 *			Address is VA in user's address space.
 *	B_PHYS:		User "raw" IO request.
 *			Address is VA in user's address space.
 *
 * All requests are (re)mapped into kernel VA space via the useriomap
 * (a name with only slightly more meaning than "kernelmap")
@


1.47
log
@Remove cpu_swapin() and cpu_swapout(), they are no longer necessary (except
for cpu_swapin() on hppa* which is kept).
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.46 2006/09/19 11:06:33 jsg Exp $	*/
d220 2
a221 1
	u_int32_t ofpte, otpte;
d230 2
d233 4
a236 5
		ofpte = pmap_pte_bits((vaddr_t)from);
		otpte = pmap_pte_bits((vaddr_t)to);
		pmap_pte_set((vaddr_t)to,
		    pmap_pte_paddr((vaddr_t)from), ofpte);
		pmap_pte_set((vaddr_t)from, 0, 0);
@


1.46
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.45 2006/06/23 13:46:05 mickey Exp $	*/
a133 12
}

void
cpu_swapout(struct proc *p)
{

#if NNPX > 0
	/*
	 * Make sure we save the FP state before the user area vanishes.
	 */
	npxsave_proc(p, 1);
#endif
@


1.45
log
@consistantly count context switches on exit; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.44 2006/05/11 13:21:12 mickey Exp $	*/
d76 2
a77 6
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
	void *stack;
	size_t stacksize;
	void (*func)(void *);
	void *arg;
d137 1
a137 2
cpu_swapout(p)
	struct proc *p;
d157 1
a157 2
cpu_exit(p)
	register struct proc *p;
d169 1
a169 2
cpu_wait(p)
	struct proc *p;
d183 2
a184 5
cpu_coredump(p, vp, cred, chdr)
	struct proc *p;
	struct vnode *vp;
	struct ucred *cred;
	struct core *chdr;
d230 1
a230 3
pagemove(from, to, size)
	caddr_t from, to;
	size_t size;
@


1.44
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.43 2006/04/27 15:37:51 mickey Exp $	*/
a170 1
	uvmexp.swtch++;
@


1.43
log
@implement separate PAE pmap that allows access to 64g of physmem
if supported by the cpu(s). currently not enabled by default and
not compiled into ramdisks. this grows paddr_t to 64bit but yet
leaves bus_addr_t at 32bits. measures are taken to favour dmaable
memory allocation from below 4g line such that buffer cache is
already allocated form below, pool backend allocator prefers lower
memory and then finally bounce buffers are used as last resort.
PAE is engaged only if global variable cpu_pae is manually set
to non-zero and there is physical memory present above 4g.
simplify pcibios address math to use u_long as we always will
be in the 32bit space.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.42 2005/11/25 14:07:17 mickey Exp $	*/
d184 1
a184 1
 */     
d342 1
a342 1
	 * anything can happen to a pmap between the time we lock a 
@


1.42
log
@explicitly cast caddr_t to vaddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.41 2005/08/01 17:04:47 deraadt Exp $	*/
d245 1
a245 2
	pt_entry_t *fpte, *tpte;
	pt_entry_t ofpte, otpte;
a253 2
	fpte = kvtopte((vaddr_t)from);
	tpte = kvtopte((vaddr_t)to);
d255 5
a259 4
		ofpte = *fpte;
		otpte = *tpte;
		*tpte++ = *fpte;
		*fpte++ = 0;
@


1.41
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.40 2004/06/13 21:49:15 niklas Exp $	*/
d255 2
a256 2
	fpte = kvtopte(from);
	tpte = kvtopte(to);
@


1.40
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d189 1
@


1.39
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.38 2003/01/16 04:15:17 art Exp $	*/
a64 3
#if NNPX > 0
extern struct proc *npxproc;
#endif
d88 1
a88 10
	/*
	 * If npxproc != p1, then the npx h/w state is irrelevant and the
	 * state had better already be in the pcb.  This is true for forks
	 * but not for dumps.
	 *
	 * If npxproc == p1, then we have to save the npx h/w state to
	 * p1's pcb so that we can copy it.
	 */
	if (npxproc == p1)
		npxsave();
d93 9
a101 2
	/* Sync curpcb (which is presumably p1's PCB) and copy it to p2. */
	savectx(curpcb);
d103 1
d107 3
d111 1
a111 5
	pcb->pcb_tss_sel = GSEL(GNULL_SEL, SEL_KPL);
	/*
	 * Activate the addres space.  Note this will refresh pcb_ldt_sel.
	 */
	pmap_activate(p2);
d116 2
a117 1
	tss_alloc(pcb);
d149 1
a149 2
	if (npxproc == p)
		npxsave();
d167 2
a168 2
	if (npxproc == p)
		npxproc = 0;
d179 1
a179 4
	struct pcb *pcb;

	pcb = &p->p_addr->u_pcb;
	tss_free(pcb);
d246 3
d261 1
a261 1
#if defined(I386_CPU)
d266 6
a271 1
				pmap_update_pg((vaddr_t) to);
d273 6
a278 1
				pmap_update_pg((vaddr_t) from);
d285 3
d291 1
@


1.38
log
@Getting rid of vm_offset_t
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.37 2002/06/11 22:15:12 wilfried Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.37
log
@use a correct test, ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.36 2001/12/08 02:24:06 art Exp $	*/
d275 1
a275 1
				pmap_update_pg((vm_offset_t) to);
d277 1
a277 1
				pmap_update_pg((vm_offset_t) from);
d294 1
a294 2
kvtop(addr)
	caddr_t addr;
d296 1
a296 1
	vm_offset_t pa;
d298 1
a298 1
	if (pmap_extract(pmap_kernel(), (vm_offset_t)addr, &pa) == FALSE)
d322 1
a322 3
vmapbuf(bp, len)
	struct buf *bp;
	vm_size_t len;
d324 1
a324 1
	vm_offset_t faddr, taddr, off;
d330 1
a330 1
	off = (vm_offset_t)bp->b_data - faddr;
d362 1
a362 3
vunmapbuf(bp, len)
	struct buf *bp;
	vm_size_t len;
d364 1
a364 1
	vm_offset_t addr, off;
d369 1
a369 1
	off = (vm_offset_t)bp->b_data - addr;
@


1.36
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.35 2001/12/07 17:30:14 art Exp $	*/
d285 1
a285 1
	if (cpu_class != CPUCLASS_386)
@


1.36.2.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.36 2001/12/08 02:24:06 art Exp $	*/
d285 1
a285 1
	if (cpu_class == CPUCLASS_386)
@


1.36.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d275 1
a275 1
				pmap_update_pg((vaddr_t) to);
d277 1
a277 1
				pmap_update_pg((vaddr_t) from);
d294 2
a295 1
kvtop(caddr_t addr)
d297 1
a297 1
	paddr_t pa;
d299 1
a299 1
	if (pmap_extract(pmap_kernel(), (vaddr_t)addr, &pa) == FALSE)
d323 3
a325 1
vmapbuf(struct buf *bp, vsize_t len)
d327 1
a327 1
	vaddr_t faddr, taddr, off;
d333 1
a333 1
	off = (vaddr_t)bp->b_data - faddr;
d365 3
a367 1
vunmapbuf(struct buf *bp, vsize_t len)
d369 1
a369 1
	vaddr_t addr, off;
d374 1
a374 1
	off = (vaddr_t)bp->b_data - addr;
@


1.35
log
@Use pmap_kenter for buffers and msgbuf.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.34 2001/12/07 00:59:16 miod Exp $	*/
d357 1
d377 1
@


1.34
log
@Ratibibugle setredzone()

[Ratibibugle is local slang for g/c, remove, rototill, etc]
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.33 2001/11/27 05:27:11 art Exp $	*/
d280 3
a282 3
		from += NBPG;
		to += NBPG;
		size -= NBPG;
@


1.33
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.32 2001/11/06 19:53:14 miod Exp $	*/
a72 2
void	setredzone __P((u_short *, caddr_t));

a245 20

#if 0
/*
 * Set a red zone in the kernel stack after the u. area.
 */
void
setredzone(pte, vaddr)
	u_short *pte;
	caddr_t vaddr;
{
/* eventually do this by setting up an expand-down stack segment
   for ss0: selector, allowing stack access down to top of u.
   this means though that protection violations need to be handled
   thru a double fault exception that must do an integral task
   switch to a known good context, within which a dump can be
   taken. a sensible scheme might be to save the initial context
   used by sched (that has physical memory mapped 1:1 at bottom)
   and take the dump while still in mapped mode */
}
#endif
@


1.32
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.31 2001/11/06 18:41:09 art Exp $	*/
d374 1
a374 3
		pmap_enter(vm_map_pmap(phys_map), taddr, fpa,
		    VM_PROT_READ | VM_PROT_WRITE,
		    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
d397 1
@


1.31
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.30 2001/09/21 02:11:57 miod Exp $	*/
a60 1
#include <vm/vm.h>
@


1.30
log
@phys_map declaration comes from <vm/vm.h>, no need to declare it locally.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.29 2001/09/19 20:50:56 mickey Exp $	*/
d86 2
a87 2
cpu_fork(p1, p2, stack, stacksize)
	register struct proc *p1, *p2;
d90 2
d93 3
a95 3
	register struct pcb *pcb = &p2->p_addr->u_pcb;
	register struct trapframe *tf;
	register struct switchframe *sf;
d132 1
a132 1
	 * through rei().  Note the inline version of cpu_set_kpc().
d145 2
a146 2
	sf->sf_esi = (int)child_return;
	sf->sf_ebx = (int)p2;
a148 14
}

void
cpu_set_kpc(p, pc, arg)
	struct proc *p;
	void (*pc) __P((void *));
	void *arg;
{
	struct switchframe *sf =
	    (struct switchframe *)p->p_addr->u_pcb.pcb_esp;

	sf->sf_esi = (int)pc;
	sf->sf_ebx = (int)arg;
	sf->sf_eip = (int)proc_trampoline;
@


1.29
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.28 2001/07/25 13:25:32 art Exp $	*/
a337 2

extern vm_map_t phys_map;
@


1.28
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.27 2001/06/08 08:08:53 art Exp $	*/
a61 2
#include <vm/vm_kern.h>

@


1.27
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.26 2001/05/06 00:45:50 art Exp $	*/
d392 2
a393 2
		    VM_PROT_READ | VM_PROT_WRITE, TRUE,
		    VM_PROT_READ | VM_PROT_WRITE);
@


1.26
log
@Update some comments wrt. the CLSIZE changes.
And remove that memory price comment from 1981. It is amusing, but also
confusing because the math in there is only correct on vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.25 2001/05/05 23:25:43 art Exp $	*/
d332 1
a332 1
	register caddr_t addr;
d336 1
a336 2
	pa = pmap_extract(pmap_kernel(), (vm_offset_t)addr);
	if (pa == 0)
d389 2
a390 2
		fpa = pmap_extract(vm_map_pmap(&bp->b_proc->p_vmspace->vm_map),
		    faddr);
@


1.25
log
@PMAP_NEW and UVM are no longer optional on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.24 2001/05/05 21:26:37 art Exp $	*/
d286 1
a286 2
 * Both addresses are assumed to reside in the Sysmap,
 * and size must be a multiple of CLSIZE.
@


1.24
log
@Remove the (vaddr_t) casts inside the round_page and trunc_page macros.
We might want to use them on types that are bigger than vaddr_t.

Fix all callers that pass pointers without casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.23 2001/03/23 18:41:01 art Exp $	*/
a63 1
#if defined(UVM)
a64 1
#endif
a114 3
#ifndef PMAP_NEW
	pmap_activate(p2);
#endif
a119 3
#ifndef PMAP_NEW
	pcb->pcb_ldt_sel = GSEL(GLDT_SEL, SEL_KPL);
#else
a123 1
#endif
a129 18
#if defined(USER_LDT) && !defined(PMAP_NEW)
	/* Copy the LDT, if necessary. */
	if (pcb->pcb_flags & PCB_USER_LDT) {
		size_t len;
		union descriptor *new_ldt;

		len = pcb->pcb_ldt_len * sizeof(union descriptor);
#if defined(UVM)
		new_ldt = (union descriptor *)uvm_km_alloc(kernel_map, len);
#else
		new_ldt = (union descriptor *)kmem_alloc(kernel_map, len);
#endif
		bcopy(pcb->pcb_ldt, new_ldt, len);
		pcb->pcb_ldt = new_ldt;
		ldt_alloc(pcb, new_ldt, len);
	}
#endif

a196 1
#if defined(UVM)
a197 3
#else
	cnt.v_swtch++;
#endif
a207 11
#ifndef PMAP_NEW
#ifdef USER_LDT
	if (pcb->pcb_flags & PCB_USER_LDT)
		i386_user_cleanup(pcb);
#endif
#else
	/*
	 * No need to do user LDT cleanup here; it's handled in
	 * pmap_destroy().
	 */
#endif
a294 1
#ifdef PMAP_NEW
a295 1
#endif
a303 1
#ifdef PMAP_NEW
a305 1
#endif
a307 1
#ifdef PMAP_NEW
a316 1
#endif
a321 1
#ifdef PMAP_NEW
a325 3
#else
	pmap_update();
#endif
a368 1
#ifdef PMAP_NEW
a369 4
#else
	pt_entry_t *fpte, *tpte;
	pt_entry_t *pmap_pte __P((pmap_t, vm_offset_t));
#endif
a375 1
#if defined(UVM)
a376 3
#else
	taddr = kmem_alloc_wait(phys_map, len);
#endif
a377 1
#ifdef PMAP_NEW
a399 13
#else
        /*
         * The region is locked, so we expect that pmap_pte() will return
         * non-NULL.
         */
        fpte = pmap_pte(vm_map_pmap(&bp->b_proc->p_vmspace->vm_map), faddr);
        tpte = pmap_pte(vm_map_pmap(phys_map), taddr);
        do {
                *tpte++ = *fpte++;
                len -= PAGE_SIZE;
        } while (len);
#endif

a417 1
#if defined(UVM)
a418 3
#else
	kmem_free_wakeup(phys_map, addr, len);
#endif
@


1.23
log
@Fix pagemove to work with PMAP_NEW. Mostly from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.22 2001/03/23 14:26:10 art Exp $	*/
d430 1
a430 1
	faddr = trunc_page(bp->b_saveaddr = bp->b_data);
d490 1
a490 1
	addr = trunc_page(bp->b_data);
@


1.22
log
@fix a diagnostic check in pagemove
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.21 2001/03/22 23:36:51 niklas Exp $	*/
d337 3
d348 4
d354 12
d370 6
d377 1
@


1.21
log
@Merge in NetBSD's PMAP_NEW, still disabled
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.20 2001/02/08 00:46:35 mickey Exp $	*/
d333 1
a333 1
	register caddr_t from, to;
d336 1
a336 1
	register pt_entry_t *fpte, *tpte;
d338 2
a339 1
	if (size % CLBYTES)
d341 1
@


1.20
log
@kvtop() returns pa, not va
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.19 2000/06/08 22:25:19 niklas Exp $	*/
d117 1
d119 1
a119 1

d125 1
d127 6
d139 1
a139 1
#ifdef USER_LDT
d239 1
d244 6
d393 3
d398 1
d411 1
d415 8
d424 8
a431 4
	fpte = pmap_pte(vm_map_pmap(&bp->b_proc->p_vmspace->vm_map), faddr);
	tpte = pmap_pte(vm_map_pmap(phys_map), taddr);
	do {
		*tpte++ = *fpte++;
d433 14
a446 1
	} while (len);
@


1.19
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.19 2000/06/08 21:11:59 niklas Exp $	*/
d344 1
a344 1
	vm_offset_t va;
d346 2
a347 2
	va = pmap_extract(pmap_kernel(), (vm_offset_t)addr);
	if (va == 0)
d349 1
a349 1
	return((int)va);
@


1.18
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17 1999/08/17 10:32:16 niklas Exp $	*/
d52 1
@


1.17
log
@New cpu_fork API to take a stack in which you point the child's stackpointer
to, at the bottom or the top, depending on your architecture's stack growth
direction.  This is in preparation for Linux' clone(2) emulation.
port maintainers, please check that I did the work right.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.16 1999/02/26 10:37:51 art Exp $	*/
a208 5
#ifdef USER_LDT
	struct pcb *pcb;
#endif
	struct vmspace *vm;

a214 12
#ifdef USER_LDT
	pcb = &p->p_addr->u_pcb;
	if (pcb->pcb_flags & PCB_USER_LDT)
		i386_user_cleanup(pcb);
#endif

	vm = p->p_vmspace;
#if !defined(UVM)
	if (vm->vm_refcnt == 1)
		vm_map_remove(&vm->vm_map, VM_MIN_ADDRESS, VM_MAXUSER_ADDRESS);
#endif

d221 14
@


1.17.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.23 2001/03/23 18:41:01 art Exp $	*/
a51 1
#include <sys/signalvar.h>
a115 1
#ifndef PMAP_NEW
d117 1
a117 1
#endif
a122 1
#ifndef PMAP_NEW
a123 6
#else
	/*
	 * Activate the addres space.  Note this will refresh pcb_ldt_sel.
	 */
	pmap_activate(p2);
#endif
d130 1
a130 1
#if defined(USER_LDT) && !defined(PMAP_NEW)
d209 5
d220 12
a239 21
void
cpu_wait(p)
	struct proc *p;
{
	struct pcb *pcb;

	pcb = &p->p_addr->u_pcb;
#ifndef PMAP_NEW
#ifdef USER_LDT
	if (pcb->pcb_flags & PCB_USER_LDT)
		i386_user_cleanup(pcb);
#endif
#else
	/*
	 * No need to do user LDT cleanup here; it's handled in
	 * pmap_destroy().
	 */
#endif
	tss_free(pcb);
}

d320 1
a320 1
	caddr_t from, to;
d323 1
a323 4
	pt_entry_t *fpte, *tpte;
#ifdef PMAP_NEW
	pt_entry_t ofpte, otpte;
#endif
d325 1
a325 2
#ifdef DIAGNOSTIC
	if ((size & PAGE_MASK) != 0)
a326 1
#endif
a329 4
#ifdef PMAP_NEW
		ofpte = *fpte;
		otpte = *tpte;
#endif
a331 12
#ifdef PMAP_NEW
#if defined(I386_CPU)
		if (cpu_class != CPUCLASS_386)
#endif
		{
			if (otpte & PG_V)
				pmap_update_pg((vm_offset_t) to);
			if (ofpte & PG_V)
				pmap_update_pg((vm_offset_t) from);
		}
#endif

a335 6
#ifdef PMAP_NEW
#if defined(I386_CPU)
	if (cpu_class != CPUCLASS_386)
		tlbflush();		
#endif
#else
a336 1
#endif
d346 1
a346 1
	vm_offset_t pa;
d348 2
a349 2
	pa = pmap_extract(pmap_kernel(), (vm_offset_t)addr);
	if (pa == 0)
d351 1
a351 1
	return((int)pa);
a379 3
#ifdef PMAP_NEW
	paddr_t fpa;
#else
a381 1
#endif
a393 1
#ifdef PMAP_NEW
a396 8
	 * XXX: unwise to expect this in a multithreaded environment.
	 * anything can happen to a pmap between the time we lock a 
	 * region, release the pmap lock, and then relock it for
	 * the pmap_extract().
	 *
	 * no need to flush TLB since we expect nothing to be mapped
	 * where we we just allocated (TLB will be flushed when our
	 * mapping is removed).
d398 4
a401 8
	while (len) {
		fpa = pmap_extract(vm_map_pmap(&bp->b_proc->p_vmspace->vm_map),
		    faddr);
		pmap_enter(vm_map_pmap(phys_map), taddr, fpa,
		    VM_PROT_READ | VM_PROT_WRITE, TRUE,
		    VM_PROT_READ | VM_PROT_WRITE);
		faddr += PAGE_SIZE;
		taddr += PAGE_SIZE;
d403 1
a403 14
	}
#else
        /*
         * The region is locked, so we expect that pmap_pte() will return
         * non-NULL.
         */
        fpte = pmap_pte(vm_map_pmap(&bp->b_proc->p_vmspace->vm_map), faddr);
        tpte = pmap_pte(vm_map_pmap(phys_map), taddr);
        do {
                *tpte++ = *fpte++;
                len -= PAGE_SIZE;
        } while (len);
#endif

@


1.17.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17.4.1 2001/04/18 16:07:24 niklas Exp $	*/
d64 1
d66 1
d117 3
d125 3
d132 1
d139 18
d224 1
d226 3
d239 11
d328 2
a329 1
 * Both addresses are assumed to reside in the Sysmap.
d337 1
d339 1
d348 1
d351 1
d354 1
d364 1
d370 1
d375 3
d385 1
a385 1
	caddr_t addr;
d389 2
a390 1
	if (pmap_extract(pmap_kernel(), (vm_offset_t)addr, &pa) == FALSE)
d421 1
d423 4
d430 1
a430 1
	faddr = trunc_page((vaddr_t)(bp->b_saveaddr = bp->b_data));
d433 1
d435 3
d439 1
d453 2
a454 2
		pmap_extract(vm_map_pmap(&bp->b_proc->p_vmspace->vm_map),
		    faddr, &fpa);
d462 13
d490 1
a490 1
	addr = trunc_page((vaddr_t)bp->b_data);
d493 1
d495 3
@


1.17.4.3
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17.4.2 2001/07/04 10:16:43 niklas Exp $	*/
d72 3
d98 10
a107 1
	npxsave_proc(p1);
d113 1
a113 1
	savectx(curcpu()->ci_curpcb);
d174 2
a175 1
	npxsave_proc(p);
d193 2
a194 7
	npxdrop(p);
#endif

#ifdef USER_LDT
	pcb = &p->p_addr->u_pcb;
	if (pcb->pcb_flags & PCB_USER_LDT)
		i386_user_cleanup(pcb);
d203 1
a203 1
     struct proc *p;
@


1.17.4.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17.4.3 2001/07/14 10:02:33 ho Exp $	*/
d62 2
d333 2
d384 2
a385 2
		    VM_PROT_READ | VM_PROT_WRITE,
		    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
@


1.17.4.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d61 1
d83 2
a84 2
cpu_fork(p1, p2, stack, stacksize, func, arg)
	struct proc *p1, *p2;
a86 2
	void (*func)(void *);
	void *arg;
d88 3
a90 3
	struct pcb *pcb = &p2->p_addr->u_pcb;
	struct trapframe *tf;
	struct switchframe *sf;
d118 1
a118 1
	 * through rei().
d131 16
a146 1
	sf->sf_esi = (int)func;
a148 1
	pcb->pcb_esp = (int)sf;
@


1.17.4.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17.4.5 2001/11/13 21:00:52 niklas Exp $	*/
d366 3
a368 1
		pmap_kenter_pa(taddr, fpa, VM_PROT_READ|VM_PROT_WRITE);
a390 1
	pmap_kremove(addr, len);
@


1.17.4.7
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 2
d241 20
d294 3
a296 3
		from += PAGE_SIZE;
		to += PAGE_SIZE;
		size -= PAGE_SIZE;
a370 1
	pmap_update(pmap_kernel());
a389 1
	pmap_update(pmap_kernel());
@


1.17.4.8
log
@Sync the SMP branch with 3.3
@
text
@d267 1
a267 1
				pmap_update_pg((vaddr_t) to);
d269 1
a269 1
				pmap_update_pg((vaddr_t) from);
d277 1
a277 1
	if (cpu_class == CPUCLASS_386)
d286 2
a287 1
kvtop(caddr_t addr)
d289 1
a289 1
	paddr_t pa;
d291 1
a291 1
	if (pmap_extract(pmap_kernel(), (vaddr_t)addr, &pa) == FALSE)
d315 3
a317 1
vmapbuf(struct buf *bp, vsize_t len)
d319 1
a319 1
	vaddr_t faddr, taddr, off;
d325 1
a325 1
	off = (vaddr_t)bp->b_data - faddr;
d357 3
a359 1
vunmapbuf(struct buf *bp, vsize_t len)
d361 1
a361 1
	vaddr_t addr, off;
d366 1
a366 1
	off = (vaddr_t)bp->b_data - addr;
@


1.17.4.9
log
@Move TSS selector from the PCB to MD part of proc and to cpu_info.
Maintain a list of CPUs and provide an iterator for it.
Ifdef out IPI debugging.  Call pmap_{de,}activate as part of context switching.
Mostly from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17.4.8 2003/03/27 23:26:55 niklas Exp $	*/
a99 1

a102 3
	 *
	 * Note: pcb_ldt_sel is handled in the pmap_activate() call when
	 * we run the new process.
d104 5
a108 1
	p2->p_md.md_tss_sel = GSEL(GNULL_SEL, SEL_KPL);
d113 1
a113 2

	p2->p_md.md_tss_sel = tss_alloc(pcb);
d180 4
a183 1
	tss_free(p->p_md.md_tss_sel);
@


1.17.4.10
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d165 6
@


1.17.4.11
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17.4.10 2003/05/13 19:42:08 ho Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.17.4.12
log
@Import NetBSD updates to NPX logic, and IPI API
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 1
a88 1
	npxsave_proc(p1, 1);
d142 1
a142 1
	npxsave_proc(p, 1);
d160 1
a160 2
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		npxsave_proc(p, 0);
@


1.17.4.13
log
@After countless hours of chasing data corruption, I finally
found the missing TLB shootdowns.  And then I see I missed a NetBSD commit
made in 2000 that fixed this! Arrrgh!!!
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17.4.12 2004/02/20 22:19:55 niklas Exp $	*/
a238 3
#ifdef MULTIPROCESSOR
	u_int32_t cpumask = 0;
#endif
d251 1
a251 1
#if defined(I386_CPU) && !defined(MULTIPROCESSOR)
d256 1
a256 6
#ifdef MULTIPROCESSOR
				pmap_tlb_shootdown(pmap_kernel(), (vaddr_t)to,
				    otpte, &cpumask);
#else
				pmap_update_pg((vaddr_to)to);
#endif
d258 1
a258 6
#ifdef MULTIPROCESSOR
				pmap_tlb_shootdown(pmap_kernel(),
				    (vaddr_t)from, ofpte, &cpumask);
#else
				pmap_update_pg((vaddr_to)from);
#endif
a264 3
#ifdef MULTIPROCESSOR
	pmap_tlb_shootnow(cpumask);
#else
a267 1
#endif
@


1.17.4.14
log
@cpu_wait() is only for MULTIPROCESSOR.
in !MULTIPROCESSOR fix typo: vaddr_to -> vaddr_t

ok niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17.4.13 2004/04/21 09:33:08 niklas Exp $	*/
a167 1
#ifdef MULTIPROCESSOR
d170 1
a170 1
	struct proc *p;
a173 1
#endif
d263 1
a263 1
				pmap_update_pg((vaddr_t)to);
d270 1
a270 1
				pmap_update_pg((vaddr_t)from);
@


1.17.4.15
log
@cpu_fork() allows parent to be non-curproc if and only if parent is proc0,
when forking non-curproc, assume its state has already been saved;
from NetBSD.

ok niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17.4.14 2004/06/06 18:42:07 grange Exp $	*/
d93 2
a94 9
	/* Copy pcb from proc p1 to p2. */
	if (p1 == curproc) {
		/* Sync the PCB before we copy it. */
		savectx(curpcb);
	}
#ifdef DIAGNOSTIC
	else if (p1 != &proc0)
		panic("cpu_fork: curproc");
#endif
@


1.17.4.16
log
@Err. Actually free the tss in !MP case too. 8k forks is not enough for
anyone.
markus@@ niklas@@ ok
grange@@ "blame me"
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.17.4.15 2004/06/06 19:01:37 grange Exp $	*/
d175 1
d182 1
@


1.16
log
@deal with uvm. Mostly name changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.14 1999/01/10 13:34:18 niklas Exp $	*/
d89 1
a89 1
cpu_fork(p1, p2)
d91 2
d154 7
@


1.15
log
@change pmap_{de,}activate to take a struct proc *.
XXX - This should be done to other archs, but since nothing (except uvm)
      uses it right now, the interface will be changed there when
      support for uvm is added.
@
text
@d63 4
d135 3
d139 1
d218 1
d221 1
d223 3
d227 1
d379 3
d383 1
d413 3
d417 1
@


1.14
log
@Generalize cpu_set_kpc to take any kind of arg; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.13 1998/07/28 00:13:36 millert Exp $	*/
d110 1
a110 1
	pmap_activate(&p2->p_vmspace->vm_pmap, pcb);
@


1.13
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.12 1996/10/16 23:12:06 deraadt Exp $	*/
d140 1
a140 1
	 * through rei().
d153 1
a153 1
cpu_set_kpc(p, pc)
d155 2
a156 1
	void (*pc) __P((struct proc *));
d158 2
a159 1
	struct switchframe *sf = (struct switchframe *)p->p_addr->u_pcb.pcb_esp;
d161 3
a163 1
	sf->sf_esi = (int) pc;
@


1.12
log
@contextual usage
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.11 1996/05/07 07:21:59 deraadt Exp $	*/
d252 1
a252 1
	    (int *)0, p);
d258 1
a258 1
	    IO_NODELOCKED|IO_UNIT, cred, (int *)0, p);
@


1.11
log
@sync with 0504; prototype changes
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.9 1996/04/21 22:16:43 deraadt Exp $	*/
d188 1
d190 1
@


1.10
log
@nice types
@
text
@d2 1
a2 1
/*	$NetBSD: vm_machdep.c,v 1.60 1996/04/25 01:15:41 christos Exp $	*/
d58 1
d73 2
a90 1
	extern void proc_trampoline(), child_return();
@


1.9
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: vm_machdep.c,v 1.8 1996/04/17 05:19:00 mickey Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.59 1996/04/03 08:24:17 mycroft Exp $	*/
d153 1
a153 1
	u_long pc;
d157 1
a157 1
	sf->sf_esi = pc;
d290 1
a290 1
	int size;
@


1.8
log
@Cleanups & fixes from latest NetBSD primarily to run doscmd, etc.
GENERIC added to the compile/.cvsignore (it is used for 'make links'
for example), thus conf/GENERIC should appear magically ...
@
text
@d1 2
a2 2
/*	$OpenBSD: vm_machdep.c,v 1.7 1996/03/19 21:09:24 mickey Exp $	*/
/*	$NetBSD: vm_machdep.c,v 1.58 1996/02/05 02:00:35 christos Exp $	*/
d262 1
d280 1
@


1.7
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 1
a1 1
/*	$OpenBSD: vm_machdep.c,v 1.6 1996/02/28 14:38:47 mickey Exp $	*/
d265 1
d285 1
@


1.6
log
@Small changes from NetBSD (including /usr/include dependencies, and so).
@
text
@d1 2
a2 1
/*	$OpenBSD: vm_machdep.c,v 1.57 1995/12/26 16:59:47 mycroft Exp $	*/
@


1.5
log
@from netbsd: mangle some comments
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.57 1995/12/26 16:59:47 mycroft Exp $	*/
d306 1
d338 1
d370 1
@


1.4
log
@from netbsd; copy md_flags at fork time (fixes npx problems)
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.56 1995/12/24 01:07:32 mycroft Exp $	*/
a106 1

d110 2
a111 2
	 * Preset these so that gdt_compact() doesn't get confused if called during
	 * the allocations below.
d116 1
a116 2
	/* Fix up the TSS, etc. */
	pcb->pcb_cr0 |= CR0_TS;
@


1.3
log
@from netbsd; enable cpu_swapout(), which must save npx state
@
text
@d102 2
@


1.2
log
@from netbsd; cpu_fork() now returns void
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.55 1995/12/09 04:37:44 mycroft Exp $	*/
d157 14
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: vm_machdep.c,v 1.54 1995/10/12 17:56:48 mycroft Exp $	*/
d80 1
a146 2

	return (0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
