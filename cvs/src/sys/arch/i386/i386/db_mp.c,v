head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.4
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.8.0.6
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.7.0.4
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.20
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.18
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.14
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.12
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.10
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.8
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.8
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.10
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.6
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.4
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.10
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.9;
commitid	2Gtqjzrin9LL2yHk;

1.9
date	2017.04.20.14.13.00;	author visa;	state Exp;
branches;
next	1.8;
commitid	GnoPKa34InShCqYl;

1.8
date	2016.03.07.05.32.46;	author naddy;	state Exp;
branches;
next	1.7;
commitid	Ht3NH0pdlkYC6Nxx;

1.7
date	2015.02.11.05.54.48;	author dlg;	state Exp;
branches;
next	1.6;
commitid	fAl1KR17j4jH74Xf;

1.6
date	2010.04.23.21.34.40;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.16.16.16.06;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.20.20.18.53;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.21.22.41.11;	author andreas;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.17.16.07.37;	author andreas;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.05.17.16.07.37;	author andreas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.05.18.17.41.15;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.02.20.22.19.55;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@/*	$OpenBSD: db_mp.c,v 1.9 2017/04/20 14:13:00 visa Exp $	*/

/*
 * Copyright (c) 2003, 2004 Andreas Gunnarsson <andreas@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/mutex.h>

#include <machine/db_machdep.h>

#include <ddb/db_output.h>

struct mutex ddb_mp_mutex =
    MUTEX_INITIALIZER_FLAGS(IPL_HIGH, "ddb_mp_mutex", MTX_NOWITNESS);

volatile int ddb_state = DDB_STATE_NOT_RUNNING;	/* protected by ddb_mp_mutex */
volatile cpuid_t ddb_active_cpu;		/* protected by ddb_mp_mutex */

extern volatile boolean_t	db_switch_cpu;
extern volatile long		db_switch_to_cpu;

/*
 * All processors wait in db_enter_ddb() (unless explicitly started from
 * ddb) but only one owns ddb.  If the current processor should own ddb,
 * db_enter_ddb() returns 1.  If the current processor should keep
 * executing as usual (if ddb is exited or the processor is explicitly
 * started), db_enter_ddb returns 0.
 * If this is the first CPU entering ddb, db_enter_ddb() will stop all
 * other CPUs by sending IPIs.
 */
int
db_enter_ddb(void)
{
	int i;

	mtx_enter(&ddb_mp_mutex);

	/* If we are first in, grab ddb and stop all other CPUs */
	if (ddb_state == DDB_STATE_NOT_RUNNING) {
		ddb_active_cpu = cpu_number();
		ddb_state = DDB_STATE_RUNNING;
		curcpu()->ci_ddb_paused = CI_DDB_INDDB;
		mtx_leave(&ddb_mp_mutex);
		for (i = 0; i < MAXCPUS; i++) {
			if (cpu_info[i] != NULL && i != cpu_number() &&
			    cpu_info[i]->ci_ddb_paused != CI_DDB_STOPPED) {
				cpu_info[i]->ci_ddb_paused = CI_DDB_SHOULDSTOP;
				i386_send_ipi(cpu_info[i], I386_IPI_DDB);
			}
		}
		return (1);
	}

	/* Leaving ddb completely.  Start all other CPUs and return 0 */
	if (ddb_active_cpu == cpu_number() && ddb_state == DDB_STATE_EXITING) {
		for (i = 0; i < MAXCPUS; i++) {
			if (cpu_info[i] != NULL) {
				cpu_info[i]->ci_ddb_paused = CI_DDB_RUNNING;
			}
		}
		mtx_leave(&ddb_mp_mutex);
		return (0);
	}

	/* We're switching to another CPU.  db_ddbproc_cmd() has made sure
	 * it is waiting for ddb, we just have to set ddb_active_cpu. */
	if (ddb_active_cpu == cpu_number() && db_switch_cpu) {
		curcpu()->ci_ddb_paused = CI_DDB_SHOULDSTOP;
		db_switch_cpu = 0;
		ddb_active_cpu = db_switch_to_cpu;
		cpu_info[db_switch_to_cpu]->ci_ddb_paused = CI_DDB_ENTERDDB;
	}

	/* Wait until we should enter ddb or resume */
	while (ddb_active_cpu != cpu_number() &&
	    curcpu()->ci_ddb_paused != CI_DDB_RUNNING) {
		if (curcpu()->ci_ddb_paused == CI_DDB_SHOULDSTOP)
			curcpu()->ci_ddb_paused = CI_DDB_STOPPED;
		mtx_leave(&ddb_mp_mutex);

		/* Busy wait without locking, we'll confirm with lock later */
		while (ddb_active_cpu != cpu_number() &&
		    curcpu()->ci_ddb_paused != CI_DDB_RUNNING)
			;	/* Do nothing */

		mtx_enter(&ddb_mp_mutex);
	}

	/* Either enter ddb or exit */
	if (ddb_active_cpu == cpu_number() && ddb_state == DDB_STATE_RUNNING) {
		curcpu()->ci_ddb_paused = CI_DDB_INDDB;
		mtx_leave(&ddb_mp_mutex);
		return (1);
	} else {
		mtx_leave(&ddb_mp_mutex);
		return (0);
	}
}

void
db_startcpu(int cpu)
{
	if (cpu != cpu_number() && cpu_info[cpu] != NULL) {
		mtx_enter(&ddb_mp_mutex);
		cpu_info[cpu]->ci_ddb_paused = CI_DDB_RUNNING;
		mtx_leave(&ddb_mp_mutex);
	}
}

void
db_stopcpu(int cpu)
{
	mtx_enter(&ddb_mp_mutex);
	if (cpu != cpu_number() && cpu_info[cpu] != NULL &&
	    cpu_info[cpu]->ci_ddb_paused != CI_DDB_STOPPED) {
		cpu_info[cpu]->ci_ddb_paused = CI_DDB_SHOULDSTOP;
		mtx_leave(&ddb_mp_mutex);
		i386_send_ipi(cpu_info[cpu], I386_IPI_DDB);
	} else {
		mtx_leave(&ddb_mp_mutex);
	}
}

void
i386_ipi_db(struct cpu_info *ci)
{
	db_enter();
}
@


1.9
log
@Tweak lock inits to make the system runnable with witness(4)
on amd64 and i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_mp.c,v 1.8 2016/03/07 05:32:46 naddy Exp $	*/
d140 1
a140 1
	Debugger();
@


1.8
log
@Sync no-argument function declaration and definition by adding (void).
ok mlarkin@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_mp.c,v 1.7 2015/02/11 05:54:48 dlg Exp $	*/
d26 2
a27 1
struct mutex ddb_mp_mutex = MUTEX_INITIALIZER(IPL_HIGH);
@


1.7
log
@deprecate use of sys/lock.h and replace it with sys/atomic.h or
machine/lock.h as appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_mp.c,v 1.6 2010/04/23 21:34:40 deraadt Exp $	*/
d44 1
a44 1
db_enter_ddb()
@


1.6
log
@Merge the only relevant (for now) parts of simplelock.h into lock.h
since it is time to start transitioning away from the no-op behaviour.
ok oga kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: db_mp.c,v 1.5 2007/11/16 16:16:06 deraadt Exp $	*/
d20 1
a20 1
#include <sys/lock.h>
a22 1
#include <sys/mutex.h>
@


1.5
log
@fix the bus_space #define nightmare, so that amd64 and i386 are much more
uniform. as a result shared code like acpi needs less #ifdef's
ok marco kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: db_mp.c,v 1.4 2004/07/20 20:18:53 art Exp $	*/
d20 1
a20 1
#include <sys/simplelock.h>
@


1.4
log
@Use mutex instead of SIMPLELOCK for protecting ddb on mp systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_mp.c,v 1.3 2004/06/21 22:41:11 andreas Exp $	*/
d57 1
a57 1
		for (i = 0; i < I386_MAXPROCS; i++) {
d69 1
a69 1
		for (i = 0; i < I386_MAXPROCS; i++) {
@


1.3
log
@Make 'machine ddbcpu' work, and use CPU device number instead of APIC id
KNF lesson and ok from niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_mp.c,v 1.2 2004/06/13 21:49:15 niklas Exp $	*/
d23 1
d27 1
a27 1
struct SIMPLELOCK ddb_mp_slock;
d29 2
a30 2
volatile int ddb_state = DDB_STATE_NOT_RUNNING;	/* protected by ddb_mp_slock */
volatile cpuid_t ddb_active_cpu;		/* protected by ddb_mp_slock */
d47 1
a47 1
	int s, i;
d49 1
a49 2
	s = splhigh();
	SIMPLE_LOCK(&ddb_mp_slock);
d56 1
a56 1
		SIMPLE_UNLOCK(&ddb_mp_slock);
a63 1
		splx(s);
d74 1
a74 2
		SIMPLE_UNLOCK(&ddb_mp_slock);
		splx(s);
d92 1
a92 2
		SIMPLE_UNLOCK(&ddb_mp_slock);
		splx(s);
d99 1
a99 2
		s = splhigh();
		SIMPLE_LOCK(&ddb_mp_slock);
d105 1
a105 2
		SIMPLE_UNLOCK(&ddb_mp_slock);
		splx(s);
d108 1
a108 2
		SIMPLE_UNLOCK(&ddb_mp_slock);
		splx(s);
a115 2
	int s;

d117 1
a117 2
		s = splhigh();
		SIMPLE_LOCK(&ddb_mp_slock);
d119 1
a119 2
		SIMPLE_UNLOCK(&ddb_mp_slock);
		splx(s);
d126 1
a126 4
	int s;

	s = splhigh();
	SIMPLE_LOCK(&ddb_mp_slock);
d130 1
a130 2
		SIMPLE_UNLOCK(&ddb_mp_slock);
		splx(s);
d133 1
a133 2
		SIMPLE_UNLOCK(&ddb_mp_slock);
		splx(s);
@


1.2
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 2
 * Copyright (c) 2003 Andreas Gunnarsson
 * All rights reserved.
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d10 7
a16 19
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
a25 3
#define DDB_STATE_NOT_RUNNING	0
#define DDB_STATE_RUNNING	1

d31 3
d35 7
a41 2
 * ddb_enter_ddb() is called when ddb is entered to stop the other
 * CPUs. If another cpu is already in ddb we'll wait until it's finished.
d43 1
a43 1
void
d51 43
a93 3
	while (ddb_state == DDB_STATE_RUNNING
	    && ddb_active_cpu != cpu_number()) {
		db_printf("CPU %d waiting to enter ddb\n", cpu_number());
d98 2
a99 2
		while (ddb_state == DDB_STATE_RUNNING
		   && ddb_active_cpu != cpu_number())
d106 10
a115 14
	ddb_state = DDB_STATE_RUNNING;
	ddb_active_cpu = cpu_number();

	for (i = 0; i < I386_MAXPROCS; i++) {
		if (cpu_info[i] != NULL) {
			if (i == cpu_number())
				cpu_info[i]->ci_ddb_paused = CI_DDB_INDDB;
			else if (cpu_info[i]->ci_ddb_paused
			    != CI_DDB_STOPPED) {
				cpu_info[i]->ci_ddb_paused = CI_DDB_SHOULDSTOP;
				db_printf("Sending IPI to cpu %d\n", i);
				i386_send_ipi(cpu_info[i], I386_IPI_DDB);
			}
		}
a116 21
	db_printf("CPU %d entering ddb\n", cpu_number());
	SIMPLE_UNLOCK(&ddb_mp_slock);
	splx(s);
}

void
db_leave_ddb()
{
	int s, i;

	s = splhigh();
	SIMPLE_LOCK(&ddb_mp_slock);
	db_printf("CPU %d leaving ddb\n", cpu_number());
	for (i = 0; i < I386_MAXPROCS; i++) {
		if (cpu_info[i] != NULL) {
			cpu_info[i]->ci_ddb_paused = CI_DDB_RUNNING;
		}
	}
	ddb_state = DDB_STATE_NOT_RUNNING;
	SIMPLE_UNLOCK(&ddb_mp_slock);
	splx(s);
d138 4
a141 3
	if (cpu != cpu_number() && cpu_info[cpu] != NULL) {
		s = splhigh();
		SIMPLE_LOCK(&ddb_mp_slock);
a142 1
		db_printf("Sending IPI to cpu %d\n", cpu);
d146 3
a152 15
db_movetocpu(int cpu)
{
	int s;

	s = splhigh();
	SIMPLE_LOCK(&ddb_mp_slock);
	cpu_info[cpu]->ci_ddb_paused = CI_DDB_ENTERDDB;
	db_printf("Sending IPI to cpu %d\n", cpu);
	SIMPLE_UNLOCK(&ddb_mp_slock);
	splx(s);
	/* XXX If other CPU was running and IPI is lost, we lose. */
	i386_send_ipi(cpu_info[cpu], I386_IPI_DDB);
}

void
d155 1
a155 27
	int s;

	s = splhigh();
	SIMPLE_LOCK(&ddb_mp_slock);
	db_printf("CPU %d received ddb IPI\n", cpu_number());
	while (ci->ci_ddb_paused == CI_DDB_SHOULDSTOP
	    || ci->ci_ddb_paused == CI_DDB_STOPPED) {
		if (ci->ci_ddb_paused == CI_DDB_SHOULDSTOP)
			ci->ci_ddb_paused = CI_DDB_STOPPED;
		SIMPLE_UNLOCK(&ddb_mp_slock);
		while (ci->ci_ddb_paused == CI_DDB_STOPPED)
			;	/* Do nothing */
		SIMPLE_LOCK(&ddb_mp_slock);
	}
	if (ci->ci_ddb_paused == CI_DDB_ENTERDDB) {
		ddb_state = DDB_STATE_RUNNING;
		ddb_active_cpu = cpu_number();
		ci->ci_ddb_paused = CI_DDB_INDDB;
		db_printf("CPU %d grabbing ddb\n", cpu_number());
		SIMPLE_UNLOCK(&ddb_mp_slock);
		Debugger();
		SIMPLE_LOCK(&ddb_mp_slock);
		ci->ci_ddb_paused = CI_DDB_RUNNING;
	}
	db_printf("CPU %d leaving ddb IPI handler\n", cpu_number());
	SIMPLE_UNLOCK(&ddb_mp_slock);
	splx(s);
@


1.1
log
@file db_mp.c was initially added on branch SMP.
@
text
@d1 187
@


1.1.2.1
log
@Some i386-specific stuff:
Stop other CPUs when entering ddb
'machine sysregs' shows system registers not usually used by applications
'machine cpuinfo' shows the status of the processors
'machine startcpu n' starts CPU n
'machine stopcpu n' stops CPU n
'machine ddbcpu n' transfers ddb control to CPU n (not very useful yet
though since the second processor can't use the keyboard...)

Niklas said that I should test this first to at least make sure it
compiles, but I'm too anxious to do my first commit. :)
@
text
@a0 187
/*	$OpenBSD$	*/

/*
 * Copyright (c) 2003 Andreas Gunnarsson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/simplelock.h>

#include <machine/db_machdep.h>

#include <ddb/db_output.h>

#define DDB_STATE_NOT_RUNNING	0
#define DDB_STATE_RUNNING	1

struct simplelock ddb_mp_slock;

volatile int ddb_state = DDB_STATE_NOT_RUNNING;	/* protected by ddb_mp_slock */
volatile cpuid_t ddb_active_cpu;		/* protected by ddb_mp_slock */

/*
 * ddb_enter_ddb() is called when ddb is entered to stop the other
 * CPUs. If another cpu is already in ddb we'll wait until it's finished.
 */
void
db_enter_ddb()
{
	int s, i;

	s = splhigh();
	simple_lock(&ddb_mp_slock);

	while (ddb_state == DDB_STATE_RUNNING
	    && ddb_active_cpu != cpu_number()) {
		db_printf("CPU %d waiting to enter ddb\n", cpu_number());
		simple_unlock(&ddb_mp_slock);
		splx(s);

		/* Busy wait without locking, we'll confirm with lock later */
		while (ddb_state == DDB_STATE_RUNNING
		   && ddb_active_cpu != cpu_number())
			;	/* Do nothing */

		s = splhigh();
		simple_lock(&ddb_mp_slock);
	}

	ddb_state = DDB_STATE_RUNNING;
	ddb_active_cpu = cpu_number();

	for (i = 0; i < I386_MAXPROCS; i++) {
		if (cpu_info[i] != NULL) {
			if (i == cpu_number())
				cpu_info[i]->ci_ddb_paused = CI_DDB_INDDB;
			else if (cpu_info[i]->ci_ddb_paused
			    != CI_DDB_STOPPED) {
				cpu_info[i]->ci_ddb_paused = CI_DDB_SHOULDSTOP;
				db_printf("Sending IPI to cpu %d\n", i);
				i386_send_ipi(cpu_info[i], I386_IPI_DDB);
			}
		}
	}
	db_printf("CPU %d entering ddb\n", cpu_number());
	simple_unlock(&ddb_mp_slock);
	splx(s);
}

void
db_leave_ddb()
{
	int s, i;

	s = splhigh();
	simple_lock(&ddb_mp_slock);
	db_printf("CPU %d leaving ddb\n", cpu_number());
	for (i = 0; i < I386_MAXPROCS; i++) {
		if (cpu_info[i] != NULL) {
			cpu_info[i]->ci_ddb_paused = CI_DDB_RUNNING;
		}
	}
	ddb_state = DDB_STATE_NOT_RUNNING;
	simple_unlock(&ddb_mp_slock);
	splx(s);
}

void
db_startcpu(int cpu)
{
	int s;

	if (cpu != cpu_number() && cpu_info[cpu] != NULL) {
		s = splhigh();
		simple_lock(&ddb_mp_slock);
		cpu_info[cpu]->ci_ddb_paused = CI_DDB_RUNNING;
		simple_unlock(&ddb_mp_slock);
		splx(s);
	}
}

void
db_stopcpu(int cpu)
{
	int s;

	if (cpu != cpu_number() && cpu_info[cpu] != NULL) {
		s = splhigh();
		simple_lock(&ddb_mp_slock);
		cpu_info[cpu]->ci_ddb_paused = CI_DDB_SHOULDSTOP;
		db_printf("Sending IPI to cpu %d\n", cpu);
		simple_unlock(&ddb_mp_slock);
		splx(s);
		i386_send_ipi(cpu_info[cpu], I386_IPI_DDB);
	}
}

void
db_movetocpu(int cpu)
{
	int s;

	s = splhigh();
	simple_lock(&ddb_mp_slock);
	cpu_info[cpu]->ci_ddb_paused = CI_DDB_ENTERDDB;
	db_printf("Sending IPI to cpu %d\n", cpu);
	simple_unlock(&ddb_mp_slock);
	splx(s);
	/* XXX If other CPU was running and IPI is lost, we lose. */
	i386_send_ipi(cpu_info[cpu], I386_IPI_DDB);
}

void
i386_ipi_db(void)
{
	int s;

	s = splhigh();
	simple_lock(&ddb_mp_slock);
	db_printf("CPU %d received ddb IPI\n", cpu_number());
	while (curcpu()->ci_ddb_paused == CI_DDB_SHOULDSTOP
	    || curcpu()->ci_ddb_paused == CI_DDB_STOPPED) {
		if (curcpu()->ci_ddb_paused == CI_DDB_SHOULDSTOP)
			curcpu()->ci_ddb_paused = CI_DDB_STOPPED;
		simple_unlock(&ddb_mp_slock);
		while (curcpu()->ci_ddb_paused == CI_DDB_STOPPED)
			;	/* Do nothing */
		simple_lock(&ddb_mp_slock);
	}
	if (curcpu()->ci_ddb_paused == CI_DDB_ENTERDDB) {
		ddb_state = DDB_STATE_RUNNING;
		ddb_active_cpu = cpu_number();
		curcpu()->ci_ddb_paused = CI_DDB_INDDB;
		db_printf("CPU %d grabbing ddb\n", cpu_number());
		simple_unlock(&ddb_mp_slock);
		Debugger();
		simple_lock(&ddb_mp_slock);
		curcpu()->ci_ddb_paused = CI_DDB_RUNNING;
	}
	db_printf("CPU %d leaving ddb IPI handler\n", cpu_number());
	simple_unlock(&ddb_mp_slock);
	splx(s);
}
@


1.1.2.2
log
@Go back to defining simplelocks as noops, even if MULTIPROCESSOR.  Instead use
a new real simple recursive-lock capable lock implementation for the few
necessary locks (kernel, scheduler, tlb shootdown, printf and ddb MP).
This because we cannot trust the old fine-grained locks spread out all over
our kernel, and not really tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_mp.c,v 1.1.2.1 2003/05/17 16:07:37 andreas Exp $	*/
d42 1
a42 1
struct SIMPLELOCK ddb_mp_slock;
d57 1
a57 1
	SIMPLE_LOCK(&ddb_mp_slock);
d62 1
a62 1
		SIMPLE_UNLOCK(&ddb_mp_slock);
d71 1
a71 1
		SIMPLE_LOCK(&ddb_mp_slock);
d90 1
a90 1
	SIMPLE_UNLOCK(&ddb_mp_slock);
d100 1
a100 1
	SIMPLE_LOCK(&ddb_mp_slock);
d108 1
a108 1
	SIMPLE_UNLOCK(&ddb_mp_slock);
d119 1
a119 1
		SIMPLE_LOCK(&ddb_mp_slock);
d121 1
a121 1
		SIMPLE_UNLOCK(&ddb_mp_slock);
d133 1
a133 1
		SIMPLE_LOCK(&ddb_mp_slock);
d136 1
a136 1
		SIMPLE_UNLOCK(&ddb_mp_slock);
d148 1
a148 1
	SIMPLE_LOCK(&ddb_mp_slock);
d151 1
a151 1
	SIMPLE_UNLOCK(&ddb_mp_slock);
d163 1
a163 1
	SIMPLE_LOCK(&ddb_mp_slock);
d169 1
a169 1
		SIMPLE_UNLOCK(&ddb_mp_slock);
d172 1
a172 1
		SIMPLE_LOCK(&ddb_mp_slock);
d179 1
a179 1
		SIMPLE_UNLOCK(&ddb_mp_slock);
d181 1
a181 1
		SIMPLE_LOCK(&ddb_mp_slock);
d185 1
a185 1
	SIMPLE_UNLOCK(&ddb_mp_slock);
@


1.1.2.3
log
@Import NetBSD updates to NPX logic, and IPI API
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d158 1
a158 1
i386_ipi_db(struct cpu_info *ci)
d165 4
a168 4
	while (ci->ci_ddb_paused == CI_DDB_SHOULDSTOP
	    || ci->ci_ddb_paused == CI_DDB_STOPPED) {
		if (ci->ci_ddb_paused == CI_DDB_SHOULDSTOP)
			ci->ci_ddb_paused = CI_DDB_STOPPED;
d170 1
a170 1
		while (ci->ci_ddb_paused == CI_DDB_STOPPED)
d174 1
a174 1
	if (ci->ci_ddb_paused == CI_DDB_ENTERDDB) {
d177 1
a177 1
		ci->ci_ddb_paused = CI_DDB_INDDB;
d182 1
a182 1
		ci->ci_ddb_paused = CI_DDB_RUNNING;
@


