head	1.116;
access;
symbols
	OPENBSD_6_2:1.116.0.2
	OPENBSD_6_2_BASE:1.116
	OPENBSD_6_1:1.116.0.4
	OPENBSD_6_1_BASE:1.116
	OPENBSD_6_0:1.115.0.4
	OPENBSD_6_0_BASE:1.115
	OPENBSD_5_9:1.115.0.2
	OPENBSD_5_9_BASE:1.115
	OPENBSD_5_8:1.110.0.4
	OPENBSD_5_8_BASE:1.110
	OPENBSD_5_7:1.108.0.2
	OPENBSD_5_7_BASE:1.108
	OPENBSD_5_6:1.107.0.4
	OPENBSD_5_6_BASE:1.107
	OPENBSD_5_5:1.105.0.4
	OPENBSD_5_5_BASE:1.105
	OPENBSD_5_4:1.104.0.10
	OPENBSD_5_4_BASE:1.104
	OPENBSD_5_3:1.104.0.8
	OPENBSD_5_3_BASE:1.104
	OPENBSD_5_2:1.104.0.6
	OPENBSD_5_2_BASE:1.104
	OPENBSD_5_1_BASE:1.104
	OPENBSD_5_1:1.104.0.4
	OPENBSD_5_0:1.104.0.2
	OPENBSD_5_0_BASE:1.104
	OPENBSD_4_9:1.100.0.2
	OPENBSD_4_9_BASE:1.100
	OPENBSD_4_8:1.99.0.4
	OPENBSD_4_8_BASE:1.99
	OPENBSD_4_7:1.99.0.2
	OPENBSD_4_7_BASE:1.99
	OPENBSD_4_6:1.98.0.6
	OPENBSD_4_6_BASE:1.98
	OPENBSD_4_5:1.98.0.2
	OPENBSD_4_5_BASE:1.98
	OPENBSD_4_4:1.97.0.2
	OPENBSD_4_4_BASE:1.97
	OPENBSD_4_3:1.94.0.4
	OPENBSD_4_3_BASE:1.94
	OPENBSD_4_2:1.94.0.2
	OPENBSD_4_2_BASE:1.94
	OPENBSD_4_1:1.70.0.2
	OPENBSD_4_1_BASE:1.70
	OPENBSD_4_0:1.55.0.2
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.47.0.2
	OPENBSD_3_9_BASE:1.47
	OPENBSD_3_8:1.45.0.2
	OPENBSD_3_8_BASE:1.45
	OPENBSD_3_7:1.44.0.6
	OPENBSD_3_7_BASE:1.44
	OPENBSD_3_6:1.44.0.4
	OPENBSD_3_6_BASE:1.44
	SMP_SYNC_A:1.44
	SMP_SYNC_B:1.44
	OPENBSD_3_5:1.44.0.2
	OPENBSD_3_5_BASE:1.44
	OPENBSD_3_4:1.43.0.2
	OPENBSD_3_4_BASE:1.43
	UBC_SYNC_A:1.42
	OPENBSD_3_3:1.42.0.6
	OPENBSD_3_3_BASE:1.42
	OPENBSD_3_2:1.42.0.4
	OPENBSD_3_2_BASE:1.42
	OPENBSD_3_1:1.42.0.2
	OPENBSD_3_1_BASE:1.42
	UBC_SYNC_B:1.42
	UBC:1.40.0.8
	UBC_BASE:1.40
	OPENBSD_3_0:1.40.0.6
	OPENBSD_3_0_BASE:1.40
	OPENBSD_2_9:1.40.0.4
	OPENBSD_2_9_BASE:1.40
	OPENBSD_2_8:1.40.0.2
	OPENBSD_2_8_BASE:1.40
	OPENBSD_2_7:1.38.0.2
	OPENBSD_2_7_BASE:1.38
	SMP:1.37.0.4
	SMP_BASE:1.37
	kame_19991208:1.37
	OPENBSD_2_6:1.37.0.2
	OPENBSD_2_6_BASE:1.37
	OPENBSD_2_5:1.36.0.2
	OPENBSD_2_5_BASE:1.36
	OPENBSD_2_4:1.34.0.2
	OPENBSD_2_4_BASE:1.34
	OPENBSD_2_3:1.33.0.2
	OPENBSD_2_3_BASE:1.33
	OPENBSD_2_2:1.29.0.2
	OPENBSD_2_2_BASE:1.29
	OPENBSD_2_1:1.24.0.2
	OPENBSD_2_1_BASE:1.24
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.116
date	2017.02.28.10.49.37;	author natano;	state Exp;
branches;
next	1.115;
commitid	9645cvu5lMcc7gZM;

1.115
date	2015.09.29.20.24.25;	author krw;	state Exp;
branches;
next	1.114;
commitid	eB7h5lgAEiQvP4gg;

1.114
date	2015.09.27.20.20.23;	author krw;	state Exp;
branches;
next	1.113;
commitid	OYyyQjE9Z0s0mlyI;

1.113
date	2015.09.10.14.28.17;	author krw;	state Exp;
branches;
next	1.112;
commitid	uaY2IS0JsuWLMJ5D;

1.112
date	2015.09.01.16.47.24;	author krw;	state Exp;
branches;
next	1.111;
commitid	kodBeKdedwVKnIne;

1.111
date	2015.08.26.13.56.04;	author krw;	state Exp;
branches;
next	1.110;
commitid	nHsnIOWwjfNf2UPo;

1.110
date	2015.07.23.18.02.58;	author krw;	state Exp;
branches;
next	1.109;
commitid	q5wcyDnmemhtL3T8;

1.109
date	2015.05.09.17.11.26;	author krw;	state Exp;
branches;
next	1.108;
commitid	XgIfRGTOOf864WwV;

1.108
date	2014.08.30.10.41.10;	author miod;	state Exp;
branches;
next	1.107;
commitid	Ymik9BkktuNsHeMq;

1.107
date	2014.07.13.15.32.28;	author miod;	state Exp;
branches;
next	1.106;
commitid	PkUmoT9mKpliN2oG;

1.106
date	2014.06.15.11.43.24;	author sf;	state Exp;
branches;
next	1.105;
commitid	Y0AWLKcfCeF28jP4;

1.105
date	2013.10.19.09.32.13;	author krw;	state Exp;
branches;
next	1.104;

1.104
date	2011.07.08.00.08.00;	author krw;	state Exp;
branches;
next	1.103;

1.103
date	2011.04.16.03.21.15;	author krw;	state Exp;
branches;
next	1.102;

1.102
date	2011.04.15.14.57.28;	author krw;	state Exp;
branches;
next	1.101;

1.101
date	2011.04.06.13.46.50;	author miod;	state Exp;
branches;
next	1.100;

1.100
date	2011.02.26.13.07.48;	author krw;	state Exp;
branches;
next	1.99;

1.99
date	2009.08.13.15.23.10;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2008.08.08.23.49.53;	author krw;	state Exp;
branches;
next	1.97;

1.97
date	2008.06.12.06.58.34;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2008.06.11.12.35.41;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2008.06.10.20.50.23;	author beck;	state Exp;
branches;
next	1.94;

1.94
date	2007.06.20.18.15.45;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2007.06.18.07.09.24;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2007.06.18.05.25.07;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2007.06.17.00.27.28;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2007.06.14.03.37.23;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2007.06.14.03.35.29;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2007.06.14.03.29.34;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2007.06.12.20.57.42;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2007.06.10.18.03.59;	author krw;	state Exp;
branches;
next	1.85;

1.85
date	2007.06.09.23.06.46;	author krw;	state Exp;
branches;
next	1.84;

1.84
date	2007.06.09.18.05.47;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2007.06.09.04.08.39;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2007.06.09.02.03.47;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2007.06.08.05.34.28;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2007.06.07.00.28.17;	author krw;	state Exp;
branches;
next	1.79;

1.79
date	2007.06.06.17.15.12;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.06.16.42.06;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.05.00.38.15;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2007.06.02.02.35.26;	author krw;	state Exp;
branches;
next	1.75;

1.75
date	2007.05.31.19.57.43;	author krw;	state Exp;
branches;
next	1.74;

1.74
date	2007.05.31.16.05.50;	author krw;	state Exp;
branches;
next	1.73;

1.73
date	2007.05.29.06.28.15;	author otto;	state Exp;
branches;
next	1.72;

1.72
date	2007.05.29.05.08.20;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2007.04.26.22.42.11;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2007.02.18.13.49.22;	author krw;	state Exp;
branches;
next	1.69;

1.69
date	2007.02.03.18.22.33;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2006.10.29.00.02.35;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2006.10.28.23.26.05;	author krw;	state Exp;
branches;
next	1.66;

1.66
date	2006.10.21.20.10.39;	author krw;	state Exp;
branches;
next	1.65;

1.65
date	2006.10.21.16.01.54;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2006.10.21.14.18.37;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2006.10.20.23.47.42;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2006.10.18.20.09.38;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2006.10.17.23.42.37;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2006.10.12.00.25.20;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2006.10.10.03.17.45;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2006.10.04.03.23.01;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2006.10.04.00.52.55;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.55;

1.55
date	2006.09.16.14.56.11;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2006.08.20.03.14.21;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2006.08.17.10.34.14;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2006.08.11.21.32.40;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2006.07.01.16.50.33;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.11.13.21.11;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2006.03.15.20.20.39;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2006.03.04.19.33.21;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2005.12.22.03.02.48;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2005.09.27.23.56.12;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.30.07.52.31;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.17.14.16.04;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.02.23.27.47;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.19.02.46.40;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2000.10.18.21.00.35;	author mickey;	state Exp;
branches
	1.40.8.1;
next	1.39;

1.39
date	2000.07.07.17.17.54;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2000.04.24.04.53.01;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	99.07.17.17.00.26;	author csapuntz;	state Exp;
branches
	1.37.4.1;
next	1.36;

1.36
date	99.01.08.04.29.06;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	98.11.21.20.43.43;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	98.10.03.21.18.54;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	98.02.24.04.22.41;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	98.02.22.21.35.25;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	98.02.19.20.36.40;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	98.01.11.20.42.06;	author provos;	state Exp;
branches;
next	1.29;

1.29
date	97.10.24.00.15.05;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	97.10.18.10.35.00;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	97.10.02.00.50.51;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	97.09.29.01.12.21;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	97.08.08.21.46.43;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	97.05.08.00.05.51;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	97.05.08.00.04.06;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.04.30.08.40.11;	author provos;	state Exp;
branches;
next	1.21;

1.21
date	97.04.18.20.15.43;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.04.18.14.27.22;	author provos;	state Exp;
branches;
next	1.19;

1.19
date	97.04.06.06.04.26;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.04.05.21.56.02;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.01.24.11.17.09;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.01.14.00.46.45;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.12.09.15.54.57;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.12.09.07.19.22;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.12.07.12.20.39;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.12.05.13.09.35;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.10.23.15.24.07;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.10.16.11.30.39;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.10.01.01.54.03;	author deraadt;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	96.09.28.09.44.10;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.09.26.21.08.53;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.09.25.11.20.13;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.06.01.09.34.30;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.07.07.21.36;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.16.25;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.18.19.18.07;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.32;	author deraadt;	state Exp;
branches;
next	;

1.9.2.1
date	96.10.24.18.22.35;	author deraadt;	state Exp;
branches;
next	;

1.37.4.1
date	2001.04.18.16.07.15;	author niklas;	state Exp;
branches;
next	1.37.4.2;

1.37.4.2
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.37.4.3;

1.37.4.3
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.37.4.4;

1.37.4.4
date	2003.06.07.11.11.36;	author ho;	state Exp;
branches;
next	1.37.4.5;

1.37.4.5
date	2004.06.05.23.08.59;	author niklas;	state Exp;
branches;
next	;

1.40.8.1
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	;


desc
@@


1.116
log
@Switch geteblks()'s size argument from int to size_t. It's called with
unsigned variables as argument in most places anyway. Decrease the
chance of signedness/range mismatch issues.

ok stefan
@
text
@/*	$OpenBSD: disksubr.c,v 1.115 2015/09/29 20:24:25 krw Exp $	*/
/*	$NetBSD: disksubr.c,v 1.21 1996/05/03 19:42:03 christos Exp $	*/

/*
 * Copyright (c) 1996 Theo de Raadt
 * Copyright (c) 1982, 1986, 1988 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/reboot.h>
#include <sys/conf.h>

#ifdef DEBUG
#include <sys/systm.h>
#endif

#include <machine/biosvar.h>

bios_diskinfo_t *bios_getdiskinfo(dev_t dev);

/*
 * Attempt to read a disk label from a device
 * using the indicated strategy routine.
 * The label must be partly set up before this:
 * secpercyl, secsize and anything required for a block i/o read
 * operation in the driver's strategy/start routines
 * must be filled in before calling us.
 *
 * If dos partition table requested, attempt to load it and
 * find disklabel inside a DOS partition.
 *
 * We would like to check if each MBR has a valid DOSMBR_SIGNATURE, but
 * we cannot because it doesn't always exist. So.. we assume the
 * MBR is valid.
 */
int
readdisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, int spoofonly)
{
	bios_diskinfo_t *pdi;
	struct buf *bp = NULL;
	dev_t devno;
	int error;

	if ((error = initdisklabel(lp)))
		goto done;

	/* Look for any BIOS geometry information we should honour. */
	devno = chrtoblk(dev);
	if (devno == NODEV)
		devno = dev;
	pdi = bios_getdiskinfo(MAKEBOOTDEV(major(devno), 0, 0, DISKUNIT(devno),
	    RAW_PART));
	if (pdi != NULL && pdi->bios_heads > 0 && pdi->bios_sectors > 0) {
#ifdef DEBUG
		printf("Disk GEOM %u/%u/%u -> BIOS GEOM %u/%u/%llu\n",
		    lp->d_ntracks, lp->d_nsectors, lp->d_ncylinders,
		    pdi->bios_heads, pdi->bios_sectors,
		    DL_GETDSIZE(lp) / (pdi->bios_heads * pdi->bios_sectors));
#endif
		lp->d_ntracks = pdi->bios_heads;
		lp->d_nsectors = pdi->bios_sectors;
		lp->d_secpercyl = pdi->bios_sectors * pdi->bios_heads;
		lp->d_ncylinders = DL_GETDSIZE(lp) / lp->d_secpercyl;
	}

	/* get a buffer and initialize it */
	bp = geteblk(lp->d_secsize);
	bp->b_dev = dev;

	error = readdoslabel(bp, strat, lp, NULL, spoofonly);
	if (error == 0)
		goto done;

#if defined(CD9660)
	error = iso_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif
#if defined(UDF)
	error = udf_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}

/*
 * Write disk label back to device after modification.
 */
int
writedisklabel(dev_t dev, void (*strat)(struct buf *), struct disklabel *lp)
{
	daddr_t partoff = -1;
	int error = EIO;
	int offset;
	struct disklabel *dlp;
	struct buf *bp = NULL;

	/* get a buffer and initialize it */
	bp = geteblk(lp->d_secsize);
	bp->b_dev = dev;

	if (readdoslabel(bp, strat, lp, &partoff, 1) != 0)
		goto done;

	/* Read it in, slap the new label in, and write it back out */
	error = readdisksector(bp, strat, lp, DL_BLKTOSEC(lp, partoff +
	    DOS_LABELSECTOR));
	if (error)
		goto done;
	offset = DL_BLKOFFSET(lp, partoff + DOS_LABELSECTOR);

	dlp = (struct disklabel *)(bp->b_data + offset);
	*dlp = *lp;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_WRITE | B_RAW);
	(*strat)(bp);
	error = biowait(bp);

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}
@


1.115
log
@Add missing prototype for bios_getdiskinfo() to amd64/disksubr.c.
Include systm.h inside #ifdef DEBUG in i386/disksubr.c, as
amd64/disksubr.c.

Makes amd64 and i386 disksubr.c identical once more.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.114 2015/09/27 20:20:23 krw Exp $	*/
d96 1
a96 1
	bp = geteblk((int)lp->d_secsize);
d136 1
a136 1
	bp = geteblk((int)lp->d_secsize);
@


1.114
log
@Use readdisksector() instead of manual buf initialization. These are
identical to the amd64 change already committed.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.113 2015/09/10 14:28:17 krw Exp $	*/
a34 1
#include <sys/systm.h>
d40 4
@


1.113
log
@Call readgptlabel() from readdoslabel() instead of MD readdisklabel().

Call it if and only if there is an MBR on sector 0 that contains 1
and only 1 partition; that partition is an EFI partition; and it
covers the entire disk or as much of the disk as can be covered in
an MBR partition.

Be paranoid about restoring any possible tweaks to the label being
built in the case that readgptlabel() fails, and in that case return
to the readdoslabel() code.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.112 2015/09/01 16:47:24 krw Exp $	*/
d140 4
a143 2
	bp->b_blkno = DL_BLKTOSEC(lp, partoff + DOS_LABELSECTOR) *
	    DL_BLKSPERSEC(lp);
a144 6
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if ((error = biowait(bp)) != 0)
		goto done;
@


1.112
log
@Always call readdoslabel() before readgptlabel(). Doubly always call them
in the same order. Fix writedisklabel() to follow these simple rules.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.111 2015/08/26 13:56:04 krw Exp $	*/
a99 6
#if defined(GPT)
	error = readgptlabel(bp, strat, lp, NULL, spoofonly);
	if (error == 0)
		goto done;
#endif

d137 1
a137 4
#if defined(GPT)
		if (readgptlabel(bp, strat, lp, &partoff, 1) != 0)
#endif
			goto done;
@


1.111
log
@MBR must have priority over GPT.

Found, fix tested & thus ok ajacoutot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.110 2015/07/23 18:02:58 krw Exp $	*/
d142 1
d144 1
a144 1
        if (readgptlabel(bp, strat, lp, &partoff, 1) != 0)
a145 1
		if (readdoslabel(bp, strat, lp, &partoff, 1) != 0)
@


1.110
log
@Revert attempted GPT code cleanup. Too much code, too little testing.

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.109 2015/05/09 17:11:26 krw Exp $	*/
d96 4
a104 4

	error = readdoslabel(bp, strat, lp, NULL, spoofonly);
	if (error == 0)
		goto done;
@


1.109
log
@Cleanup/rejig GPT code to be more readable, support different endian
archs and different sized disk sectors. Make MBR have higher priority
than GPT. Add many paranoia checks and associated DPRINTF's to make
further development easier. Keep everything hidden behind #ifdef
GPT.

Tested and ok doug@@ mpi@@. Nothing bad seen by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.108 2014/08/30 10:41:10 miod Exp $	*/
d96 6
d142 5
a146 2
	if (readdoslabel(bp, strat, lp, &partoff, 1) != 0)
		goto done;
@


1.108
log
@Make sure we check for GPT in writedisklabel() if kernel is compiled with GPT
support, for it would risk being overwritten otherwise.

From Markus Mueller
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.107 2014/07/13 15:32:28 miod Exp $	*/
a95 6
#if defined(GPT)
	error = readgptlabel(bp, strat, lp, NULL, spoofonly);
	if (error == 0)
		goto done;
#endif

d136 2
a137 5
#if defined(GPT)
        if (readgptlabel(bp, strat, lp, &partoff, 1) != 0)
#endif
		if (readdoslabel(bp, strat, lp, &partoff, 1) != 0)
			goto done;
@


1.107
log
@Initial support to read GPT partition tables in the kernel, if option GPT.
Contributed by Markus Mueller; code based upon Bitrig's GPT support, with
stricter GPT structures validation and support for alternate header places.

ok deraadt@@ jsing@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.106 2014/06/15 11:43:24 sf Exp $	*/
d142 5
a146 2
	if (readdoslabel(bp, strat, lp, &partoff, 1) != 0)
		goto done;
@


1.106
log
@Fix a few format string bugs with -DDEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.105 2013/10/19 09:32:13 krw Exp $	*/
d95 6
@


1.105
log
@Use daddr_t * instead of int * for the partoffp parameter to
readdoslabel(). Ditto all the MD variables whose addresses are passed
to readdoslabel() via partoffp.

Fix some 512-byte block vs disk sector confusion in hppa and sgi.
All the DL_GETxxxxx() defines return disk sector values. All
DL_SETxxxx() take disk sector values. These changes should be no-ops
until a drive using non-512-byte-sectors is encountered.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.104 2011/07/08 00:08:00 krw Exp $	*/
d81 1
a81 1
		printf("Disk GEOM %u/%u/%u -> BIOS GEOM %u/%u/%u\n",
@


1.104
log
@When reading dos labels use DOS_LABELSECTOR and don't use LABELOFFSET. For all these
arch's LABELSECTOR == DOS_LABELSECTOR == 1, and LABELOFFSET == 0. Thus, to quote bob,
"This is a no-op". Makes the expression used when writing label the same as the one
used in readdoslabel().
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.103 2011/04/16 03:21:15 krw Exp $	*/
d126 2
a127 1
	int error = EIO, partoff = -1;
@


1.103
log
@Use 'CLR(<buf>->b_flags, B_READ | B_WRITE | B_DONE)' regardless of
what the previous IO was. Less chance of copy and paste errors.
Suggested by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.102 2011/04/15 14:57:28 krw Exp $	*/
d139 3
a141 2
	bp->b_blkno = DL_BLKTOSEC(lp, partoff+LABELSECTOR) * DL_BLKSPERSEC(lp);
	offset = DL_BLKOFFSET(lp, partoff + LABELSECTOR) + LABELOFFSET;
@


1.102
log
@In days of yore one could arbitrarily whack buffer flags. Those days
are past. Use CLR() and SET() to modify necessary flags while leaving
the flags used by the buffer cache in peace.

Should make bufcache code much less confused about the state of the
bufs used in reading/writing disklabels. Other such flag abuses no
doubt await a visit.

Errors in original diff found by miod@@.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.101 2011/04/06 13:46:50 miod Exp $	*/
d142 1
a142 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d150 1
a150 1
	CLR(bp->b_flags, B_READ | B_DONE);
@


1.101
log
@The various read*label() have stopped returning error strings for quite
some time, and return errnos instead. Fix or remove out-of-date comments
mentioning the error strings, and make their callers check the return value
against zero, not NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.100 2011/02/26 13:07:48 krw Exp $	*/
d142 2
a143 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d150 2
a151 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.100
log
@Force the DUID cache used to generate hw.disknames to be updated
after every disklabel read or write. This keeps the DUID cache more
in sync with the physical world. De-syncing noted by drahn@@ while
zapping disklabels with dd.

ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.99 2009/08/13 15:23:10 deraadt Exp $	*/
d44 2
d55 1
a55 2
 * find disklabel inside a DOS partition. Return buffer
 * for use in signalling errors if requested.
a59 2
 *
 * Returns null on success and an error string on failure.
a60 2
bios_diskinfo_t *bios_getdiskinfo(dev_t dev);

d135 1
a135 1
	if (readdoslabel(bp, strat, lp, &partoff, 1) != NULL)
@


1.99
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.98 2008/08/08 23:49:53 krw Exp $	*/
d119 1
d161 1
@


1.98
log
@Admit b_blkno means block number; a block is DEV_BSIZE (a.k.a.
512) bytes; ffs is inextricably tied to using b_blkno and disklabel
always uses sectorsize units.

Thus use DEV_BSIZE units for all fields describing ffs filesystems
and convert to/from sectors where required. This enables the creation
and use of ffs filesystems on non-512 byte sectorsize devices.

This diff allows i386 and sgi (the two test platforms) to find
disklabels that are not on a sectorsize boundary. Same change to
further archs coming.

This is a no-op on 512-byte sectorsize devices.

This work triggered by jsing@@'s need to create ffs filesystems on
sgi cdroms so we can create cdrom install media for sgi.

sgi testing by jsing@@

ok jsing@@ pedro@@ "looks sane" beck@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.97 2008/06/12 06:58:34 deraadt Exp $	*/
d64 1
a64 1
char *
d71 1
a71 1
	char *msg;
d73 1
a73 1
	if ((msg = initdisklabel(lp)))
d99 2
a100 2
	msg = readdoslabel(bp, strat, lp, NULL, spoofonly);
	if (msg == NULL)
d104 2
a105 2
	if (iso_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a106 1
	}
d109 2
a110 2
	if (udf_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a111 1
	}
d119 1
a119 1
	return (msg);
@


1.97
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.95 2008/06/10 20:50:23 beck Exp $	*/
d131 1
d143 2
a144 1
	bp->b_blkno = partoff + LABELSECTOR;
d151 1
a151 1
	dlp = (struct disklabel *)(bp->b_data + LABELOFFSET);
@


1.96
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.94 2007/06/20 18:15:45 deraadt Exp $	*/
d144 1
a144 1
	bp->b_flags = B_BUSY | B_READ;
d151 1
a151 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.95
log
@Fix buffer cache pending read statistics by ensuring we can identify
biowait() reads that do *not* come from the buffer cache - we use the
B_RAW flag to identify these at art's suggestion - since it makes sense
and the flag was not being used. this just flags all these buffers with
B_RAW - biodone already ignores returned buffers marked B_RAW.
ok art@@
@
text
@d144 1
a144 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d151 1
a151 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.94
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.93 2007/06/18 07:09:24 deraadt Exp $	*/
d144 1
a144 1
	bp->b_flags = B_BUSY | B_READ;
d151 1
a151 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.93
log
@simplify error return case from writedisklabel()
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.92 2007/06/18 05:25:07 deraadt Exp $	*/
d66 1
a66 1
    struct disklabel *lp, struct cpu_disklabel *osdep, int spoofonly)
d99 1
a99 1
	msg = readdoslabel(bp, strat, lp, osdep, NULL, NULL, spoofonly);
d128 1
a128 2
writedisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, struct cpu_disklabel *osdep)
d130 1
a130 1
	int error = EIO, partoff = -1, cyl = 0;
d138 1
a138 1
	if (readdoslabel(bp, strat, lp, osdep, &partoff, &cyl, 1) != NULL)
a142 1
	bp->b_cylinder = cyl;
@


1.92
log
@this XXX has no place here anymore.  extended partition label writing
might even work now (ie. if it works, it is because finding the label
location is now MI code shared for the read & write paths)
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.91 2007/06/17 00:27:28 deraadt Exp $	*/
d131 1
a131 1
	int error, partoff = -1, cyl = 0;
d139 1
a139 2
	if (readdoslabel(bp, strat, lp, osdep, &partoff, &cyl, 1) != NULL) {
		error = EIO;
a140 1
	}
@


1.91
log
@significantly simplified disklabel infrastructure.  MBR handling becomes MI
to support hotplug media on most architectures.  disklabel setup and
verification done using new helper functions.  Disklabels must *always*
have a correct checksum now.  Same code paths are used to learn on-disk
location disklabels, to avoid new errors sneaking in.  Tested on almost all
cases, testing help from todd, kettenis, krw, otto, dlg, robert, gwk, drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.90 2007/06/14 03:37:23 deraadt Exp $	*/
a125 1
 * XXX cannot handle OpenBSD partitions in extended partitions!
@


1.90
log
@excessive blank lines making the versions different
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.89 2007/06/14 03:35:29 deraadt Exp $	*/
a31 2
 *
 *	@@(#)ufs_disksubr.c	7.16 (Berkeley) 5/4/91
a36 1
#include <sys/device.h>
a37 1
#include <sys/syslog.h>
a67 3
	struct dos_partition dp[NDOSPART], *dp2;
	struct partition *pp;
	struct disklabel *dlp;
a68 2
	unsigned long extoff = 0;
	unsigned int fattest;
a69 1
	daddr64_t part_blkno = DOSBBSECTOR;
d71 3
a73 11
	char *msg = NULL;
	int dospartoff, cyl, i, ourpart = -1;
	int wander = 1, n = 0, loop = 0;

	/* minimal requirements for archetypal disk label */
	if (lp->d_secsize < DEV_BSIZE)
		lp->d_secsize = DEV_BSIZE;
	if (DL_GETDSIZE(lp) == 0)
		DL_SETDSIZE(lp, MAXDISKSIZE);
	if (lp->d_secpercyl == 0) {
		msg = "invalid geometry";
a74 10
	}
	lp->d_npartitions = RAW_PART + 1;
	for (i = 0; i < RAW_PART; i++) {
		DL_SETPSIZE(&lp->d_partitions[i], 0);
		DL_SETPOFFSET(&lp->d_partitions[i], 0);
	}
	if (DL_GETPSIZE(&lp->d_partitions[RAW_PART]) == 0)
		DL_SETPSIZE(&lp->d_partitions[RAW_PART], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[RAW_PART], 0);
	lp->d_version = 1;
d99 2
a100 148
	/* do dos partitions in the process of getting disklabel? */
	dospartoff = 0;
	cyl = LABELSECTOR / lp->d_secpercyl;

	/*
	 * Read dos partition table, follow extended partitions.
	 * Map the partitions to disklabel entries i-p
	 */
	while (wander && n < 8 && loop < 8) {
		loop++;
		wander = 0;
		if (part_blkno < extoff)
			part_blkno = extoff;

		/* read boot record */
		bp->b_blkno = part_blkno;
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		bp->b_cylinder = part_blkno / lp->d_secpercyl;
		(*strat)(bp);

		/* if successful, wander through dos partition table */
		if (biowait(bp)) {
			msg = "dos partition I/O error";
			goto done;
		}
		bcopy(bp->b_data + DOSPARTOFF, dp, sizeof(dp));

		if (ourpart == -1 && part_blkno == DOSBBSECTOR) {
			/* Search for our MBR partition */
			for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
			    i++, dp2++)
				if (letoh32(dp2->dp_size) &&
				    dp2->dp_typ == DOSPTYP_OPENBSD)
					ourpart = i;
			if (ourpart == -1)
				goto donot;
			/*
			 * This is our MBR partition. need sector address
			 * for SCSI/IDE, cylinder for ESDI/ST506/RLL
			 */
			dp2 = &dp[ourpart];
			dospartoff = letoh32(dp2->dp_start) + part_blkno;
			cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);

			/* XXX build a temporary disklabel */
			DL_SETPSIZE(&lp->d_partitions[0], letoh32(dp2->dp_size));
			DL_SETPOFFSET(&lp->d_partitions[0],
			    letoh32(dp2->dp_start) + part_blkno);
			if (lp->d_ntracks == 0)
				lp->d_ntracks = dp2->dp_ehd + 1;
			if (lp->d_nsectors == 0)
				lp->d_nsectors = DPSECT(dp2->dp_esect);
			if (lp->d_secpercyl == 0)
				lp->d_secpercyl = lp->d_ntracks *
				    lp->d_nsectors;
		}
donot:
		/*
		 * In case the disklabel read below fails, we want to
		 * provide a fake label in i-p.
		 */
		for (dp2=dp, i=0; i < NDOSPART && n < 8; i++, dp2++) {
			pp = &lp->d_partitions[8+n];

			if (dp2->dp_typ == DOSPTYP_OPENBSD)
				continue;
			if (letoh32(dp2->dp_size) > DL_GETDSIZE(lp))
				continue;
			if (letoh32(dp2->dp_start) > DL_GETDSIZE(lp))
				continue;
			if (letoh32(dp2->dp_size) == 0)
				continue;
			if (letoh32(dp2->dp_start))
				DL_SETPOFFSET(pp,
				    letoh32(dp2->dp_start) + part_blkno);

			DL_SETPSIZE(pp, letoh32(dp2->dp_size));

			switch (dp2->dp_typ) {
			case DOSPTYP_UNUSED:
				pp->p_fstype = FS_UNUSED;
				n++;
				break;

			case DOSPTYP_LINUX:
				pp->p_fstype = FS_EXT2FS;
				n++;
				break;

			case DOSPTYP_FAT12:
			case DOSPTYP_FAT16S:
			case DOSPTYP_FAT16B:
			case DOSPTYP_FAT16L:
			case DOSPTYP_FAT32:
			case DOSPTYP_FAT32L:
				pp->p_fstype = FS_MSDOS;
				n++;
				break;
			case DOSPTYP_EXTEND:
			case DOSPTYP_EXTENDL:
				part_blkno = letoh32(dp2->dp_start) + extoff;
				if (!extoff) {
					extoff = letoh32(dp2->dp_start);
					part_blkno = 0;
				}
				wander = 1;
				break;
			default:
				pp->p_fstype = FS_OTHER;
				n++;
				break;
			}
		}
	}
	lp->d_bbsize = 8192;
	lp->d_sbsize = 64*1024;		/* XXX ? */
	lp->d_npartitions = MAXPARTITIONS;

	if (n == 0 && part_blkno == DOSBBSECTOR) {
		/* Check for a short jump instruction. */
		fattest = ((bp->b_data[0] << 8) & 0xff00) | (bp->b_data[2] &
		    0xff);
		if (fattest != 0xeb90 && fattest != 0xe900)
			goto notfat;

		/* Check for a valid bytes per sector value. */
		fattest = ((bp->b_data[12] << 8) & 0xff00) | (bp->b_data[11] &
		    0xff);
		if (fattest < 512 || fattest > 4096 || (fattest % 512 != 0))
			goto notfat;

		/* Check the end of sector marker. */
		fattest = ((bp->b_data[510] << 8) & 0xff00) | (bp->b_data[511] &
		    0xff);
		if (fattest != 0x55aa)
			goto notfat;

		/* Looks like a FAT filesystem. Spoof 'i'. */
		DL_SETPSIZE(&lp->d_partitions['i' - 'a'],
		    DL_GETPSIZE(&lp->d_partitions[RAW_PART]));
		DL_SETPOFFSET(&lp->d_partitions['i' - 'a'], 0);
		lp->d_partitions['i' - 'a'].p_fstype = FS_MSDOS;
	}
notfat:

	/* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
d103 3
a105 11
	/* next, dig out disk label */
	bp->b_blkno = dospartoff + LABELSECTOR;
	bp->b_cylinder = cyl;
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	(*strat)(bp);

	/* if successful, locate disk label within block and validate */
	if (biowait(bp)) {
		/* XXX we return the faked label built so far */
		msg = "disk label I/O error";
a107 20
	for (dlp = (struct disklabel *)bp->b_data;
	    dlp <= (struct disklabel *)(bp->b_data + lp->d_secsize - sizeof(*dlp));
	    dlp = (struct disklabel *)((char *)dlp + sizeof(long))) {
		if (dlp->d_magic != DISKMAGIC || dlp->d_magic2 != DISKMAGIC) {
			if (msg == NULL)
				msg = "no disk label";
		} else if (dlp->d_npartitions > MAXPARTITIONS ||
			   dkcksum(dlp) != 0)
			msg = "disk label corrupted";
		else {
			DL_SETDSIZE(dlp, DL_GETDSIZE(lp));
			*lp = *dlp;
			msg = NULL;
			break;
		}
	}

#if defined(CD9660)
	if (msg && iso_disklabelspoof(dev, strat, lp) == 0)
		msg = NULL;
d110 1
a110 1
	if (msg && udf_disklabelspoof(dev, strat, lp) == 0)
d112 2
a120 1
	disklabeltokernlabel(lp);
d132 1
a132 1
	struct dos_partition dp[NDOSPART], *dp2;
a134 2
	int error, dospartoff, cyl, i;
	int ourpart = -1;
d140 2
a141 12
	/* do dos partitions in the process of getting disklabel? */
	dospartoff = 0;
	cyl = LABELSECTOR / lp->d_secpercyl;

	/* read master boot record */
	bp->b_blkno = DOSBBSECTOR;
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	bp->b_cylinder = DOSBBSECTOR / lp->d_secpercyl;
	(*strat)(bp);

	if ((error = biowait(bp)) != 0)
a142 17

	/* XXX how do we check veracity/bounds of this? */
	bcopy(bp->b_data + DOSPARTOFF, dp, sizeof(dp));

	for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
		if (letoh32(dp2->dp_size) && dp2->dp_typ == DOSPTYP_OPENBSD)
			ourpart = i;

	if (ourpart != -1) {
		dp2 = &dp[ourpart];

		/*
		 * need sector address for SCSI/IDE,
		 * cylinder for ESDI/ST506/RLL
		 */
		dospartoff = letoh32(dp2->dp_start);
		cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);
d145 2
a146 2
	/* next, dig out disk label */
	bp->b_blkno = dospartoff + LABELSECTOR;
a150 2

	/* if successful, locate disk label within block and validate */
a152 12
	for (dlp = (struct disklabel *)bp->b_data;
	    dlp <= (struct disklabel *)(bp->b_data + lp->d_secsize - sizeof(*dlp));
	    dlp = (struct disklabel *)((char *)dlp + sizeof(long))) {
		if (dlp->d_magic == DISKMAGIC && dlp->d_magic2 == DISKMAGIC &&
		    dkcksum(dlp) == 0) {
			*dlp = *lp;
			bp->b_flags = B_BUSY | B_WRITE;
			(*strat)(bp);
			error = biowait(bp);
			goto done;
		}
	}
d154 2
a155 2
	/* Write it in the regular place. */
	*(struct disklabel *)bp->b_data = *lp;
@


1.89
log
@set the prototype disklabel to version 1
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.88 2007/06/14 03:29:34 deraadt Exp $	*/
a323 2


@


1.88
log
@do not depend on previous loop variable, use a constant instead
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.87 2007/06/12 20:57:42 deraadt Exp $	*/
d102 1
@


1.87
log
@all disksubr.c did their b_flags manipulation differently (and wrong).
correct and unify; ok thib miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.86 2007/06/10 18:03:59 krw Exp $	*/
d99 3
a101 3
	if (DL_GETPSIZE(&lp->d_partitions[i]) == 0)
		DL_SETPSIZE(&lp->d_partitions[i], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[i], 0);
@


1.86
log
@Remove spurious blank line at end of file. Spotted by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.85 2007/06/09 23:06:46 krw Exp $	*/
d336 1
a336 1
	struct buf *bp;
d406 4
a409 2
	bp->b_flags |= B_INVAL;
	brelse(bp);
@


1.85
log
@The differences in the last non-homogeneous bounds_check_with_label()
routines (alpha, vax) prove to be not worth keeping. Move
bounds_check_with_label() into the MI world. Eliminate unreliable and
almost certainly useless checks for overwriting a disklabel.

After discussion with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.84 2007/06/09 18:05:47 deraadt Exp $	*/
a409 1

@


1.84
log
@unify DOSPTYP_FAT* code (some architectures missed a filesystem type or two)
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.83 2007/06/09 04:08:39 deraadt Exp $	*/
a410 55
/*
 * Determine the size of the transfer, and make sure it is
 * within the boundaries of the partition. Adjust transfer
 * if needed, and signal errors or early completion.
 */
int
bounds_check_with_label(struct buf *bp, struct disklabel *lp,
    struct cpu_disklabel *osdep, int wlabel)
{
#define blockpersec(count, lp) ((count) * (((lp)->d_secsize) / DEV_BSIZE))
	struct partition *p = lp->d_partitions + DISKPART(bp->b_dev);
	int labelsector = blockpersec(DL_GETPOFFSET(&lp->d_partitions[RAW_PART]), lp) +
	    LABELSECTOR;
	int sz = howmany(bp->b_bcount, DEV_BSIZE);

	/* avoid division by zero */
	if (lp->d_secpercyl == 0) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/* beyond partition? */
	if (bp->b_blkno + sz > blockpersec(DL_GETPSIZE(p), lp)) {
		sz = blockpersec(DL_GETPSIZE(p), lp) - bp->b_blkno;
		if (sz == 0) {
			/* If exactly at end of disk, return EOF. */
			bp->b_resid = bp->b_bcount;
			return (-1);
		}
		if (sz < 0) {
			/* If past end of disk, return EINVAL. */
			bp->b_error = EINVAL;
			goto bad;
		}
		/* Otherwise, truncate request. */
		bp->b_bcount = sz << DEV_BSHIFT;
	}

	/* Overwriting disk label? */
	if (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) <= labelsector &&
	    bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) + sz > labelsector &&
	    (bp->b_flags & B_READ) == 0 && !wlabel) {
		bp->b_error = EROFS;
		goto bad;
	}

	/* calculate cylinder for disksort to order transfers with */
	bp->b_cylinder = (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp)) /
	    lp->d_secpercyl;
	return (1);

bad:
	bp->b_flags |= B_ERROR;
	return (-1);
}
@


1.83
log
@by hand i carefully found that all the differences in setdisklabel()
implimentations were simply either missing code, or spacing and such.
setdisklabel() can become MI now.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.82 2007/06/09 02:03:47 deraadt Exp $	*/
a218 1
			case DOSPTYP_FAT32L:
d221 1
@


1.82
log
@annoying spacing glitch which makes the diffs bigger
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.81 2007/06/08 05:34:28 deraadt Exp $	*/
a323 53
/*
 * Check new disk label for sensibility
 * before setting it.
 */
int
setdisklabel(struct disklabel *olp, struct disklabel *nlp,
    u_int openmask, struct cpu_disklabel *osdep)
{
	int i;
	struct partition *opp, *npp;

	/* sanity clause */
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0 ||
	    (nlp->d_secsize % DEV_BSIZE) != 0)
		return (EINVAL);

	/* special case to allow disklabel to be invalidated */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return (0);
	}

	if (nlp->d_magic != DISKMAGIC || nlp->d_magic2 != DISKMAGIC ||
	    dkcksum(nlp) != 0)
		return (EINVAL);

	/* XXX missing check if other dos partitions will be overwritten */

	while (openmask != 0) {
		i = ffs(openmask) - 1;
		openmask &= ~(1 << i);
		if (nlp->d_npartitions <= i)
			return (EBUSY);
		opp = &olp->d_partitions[i];
		npp = &nlp->d_partitions[i];
		if (DL_GETPOFFSET(npp) != DL_GETPOFFSET(opp) ||
		    DL_GETPSIZE(npp) < DL_GETPSIZE(opp))
			return (EBUSY);
		/*
		 * Copy internally-set partition information
		 * if new label doesn't include it.		XXX
		 */
		if (npp->p_fstype == FS_UNUSED && opp->p_fstype != FS_UNUSED) {
			npp->p_fstype = opp->p_fstype;
			npp->p_fragblock = opp->p_fragblock;
			npp->p_cpg = opp->p_cpg;
		}
	}
	nlp->d_checksum = 0;
	nlp->d_checksum = dkcksum(nlp);
	*olp = *nlp;
	return (0);
}
@


1.81
log
@all disklabels read from the kernel now always contain a total sector
size which is the REAL DISK SIZE.  always.  if a driver fails to set
this right, please fix it.  agreed with otto and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.80 2007/06/07 00:28:17 krw Exp $	*/
d338 1
a338 1
		return(EINVAL);
@


1.80
log
@More bounds_check_with_label homogenization. Fix a couple of typos while
there.

'so go to it!' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.79 2007/06/06 17:15:12 deraadt Exp $	*/
d299 1
@


1.79
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.78 2007/06/06 16:42:06 deraadt Exp $	*/
d490 1
a490 1
			goto done;
a502 1
#if LABELSECTOR != 0
a503 1
#endif
a515 1
done:
@


1.78
log
@a fair sprinking of knf, code movement, and sometimes character-by-character
accuracy so that the variious disksubr.c's can be compared easier.
setdisklabel() starts taking an int for openmask.
ok krw, and read by quite a few other people
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.77 2007/06/05 00:38:15 deraadt Exp $	*/
d79 1
a79 1
	daddr_t part_blkno = DOSBBSECTOR;
@


1.77
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.76 2007/06/02 02:35:26 krw Exp $	*/
d69 2
a70 2
readdisklabel(dev_t dev, void (*strat)(struct buf *), struct disklabel *lp,
    struct cpu_disklabel *osdep, int spoofonly)
a218 1
			case DOSPTYP_FAT32:
d221 1
d328 2
a329 2
setdisklabel(struct disklabel *olp, struct disklabel *nlp, u_long openmask,
    struct cpu_disklabel *osdep)
d383 2
a384 2
writedisklabel(dev_t dev, void (*strat)(struct buf *), struct disklabel *lp,
    struct cpu_disklabel *osdep)
@


1.76
log
@Rename cvtdisklabelv1 -> disklabeltokernlabel. It does more than just
convert version 0 to version 1 disklabels.

Suggested by deraadt@@.

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.75 2007/05/31 19:57:43 krw Exp $	*/
d88 2
a89 2
	if (lp->d_secperunit == 0)
		lp->d_secperunit = 0x1fffffff;
d96 2
a97 2
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
d99 3
a101 3
	if (lp->d_partitions[i].p_size == 0)
		lp->d_partitions[i].p_size = lp->d_secperunit;
	lp->d_partitions[i].p_offset = 0;
d114 1
a114 1
		    lp->d_secperunit / (pdi->bios_heads * pdi->bios_sectors));
d119 1
a119 1
		lp->d_ncylinders = lp->d_secperunit / lp->d_secpercyl;
d172 3
a174 3
			lp->d_partitions[0].p_size = letoh32(dp2->dp_size);
			lp->d_partitions[0].p_offset =
				letoh32(dp2->dp_start) + part_blkno;
d193 1
a193 1
			if (letoh32(dp2->dp_size) > lp->d_secperunit)
d195 1
a195 1
			if (letoh32(dp2->dp_start) > lp->d_secperunit)
d200 2
a201 2
				pp->p_offset =
				    letoh32(dp2->dp_start) + part_blkno;
d203 1
a203 1
			pp->p_size = letoh32(dp2->dp_size);
d265 3
a267 3
		lp->d_partitions['i' - 'a'].p_size =
		    lp->d_partitions[RAW_PART].p_size;
		lp->d_partitions['i' - 'a'].p_offset = 0;
d358 2
a359 1
		if (npp->p_offset != opp->p_offset || npp->p_size < opp->p_size)
d474 1
a474 1
	int labelsector = blockpersec(lp->d_partitions[RAW_PART].p_offset, lp) +
d485 2
a486 2
	if (bp->b_blkno + sz > blockpersec(p->p_size, lp)) {
		sz = blockpersec(p->p_size, lp) - bp->b_blkno;
d502 1
a502 1
	if (bp->b_blkno + blockpersec(p->p_offset, lp) <= labelsector &&
d504 1
a504 1
	    bp->b_blkno + blockpersec(p->p_offset, lp) + sz > labelsector &&
d512 1
a512 1
	bp->b_cylinder = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
@


1.75
log
@KNF, whitespace and comment rectification to make all
bounds_check_with_label() routines as identical as possible without
changing any code. Code nits and adjustments to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.74 2007/05/31 16:05:50 krw Exp $	*/
d319 1
a319 1
	cvtdisklabelv1(lp);
@


1.74
log
@Standardize on -1 as the error return value for
bounds_check_with_label. All callers check for <= 0, so no functional
change.

Feedback from miod@@.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.73 2007/05/29 06:28:15 otto Exp $	*/
d512 1
a512 1
		lp->d_secpercyl;
@


1.73
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.72 2007/05/29 05:08:20 krw Exp $	*/
d518 1
a518 1
	return (0);
@


1.72
log
@Refactor readdisklabel() to ensure there is a single point of return, in
preparation for translating all disk labels visible to the kernel to
the soon to arrive V1 format.

ok otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.71 2007/04/26 22:42:11 krw Exp $	*/
d319 1
d366 1
a366 2
			npp->p_fsize = opp->p_fsize;
			npp->p_frag = opp->p_frag;
@


1.71
log
@Eliminate CPU_BIOS from userland and wd(4) by always using the BIOS
geometry in the disklabel when there is a BIOS geometry to provide.
This removes the option to set a disklabel to 'BIOS' geometry via the
'g b' command in the editor.

Makes reported geometry more consistant and moves MD code to MD land
where it should be.

Doc help from jmc@@, Feedback from millert@@, marco@@, weingart@@,
kettenis@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.70 2007/02/18 13:49:22 krw Exp $	*/
d90 4
a93 2
	if (lp->d_secpercyl == 0)
		return ("invalid geometry");
@


1.70
log
@If no MBR partitions are found when spoofing a disklabel, try looking
for a bare FAT12/16/32 filesystem.  If one is found, spoof it as 'i'.
This enables iPod shuffles and other umass devices that are shipped
with a bare FAT32 filesystem to be used as install media. And
generally makes things easier for the user just trying to mount some
media, e.g.  floppies.

Does not make it safe to write a disklabel or MBR on such a device!
That will still obliterate the FAT filesystem.

Help and suggestions from tom@@ and deraadt@@. Feedback and suggestions
for future enhancements from espie@@ mickey@@ and peter@@.

ok tom@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.69 2007/02/03 18:22:33 krw Exp $	*/
d43 4
d66 2
d75 1
d80 1
d100 19
@


1.69
log
@Don't spoof an msdosfs partition if it claims to start after the end
of the disk. Fixes the creation of spurious 'i' partitions on new iPod
Shuffle.  And other devices with no MBR, just a FAT32 filesystem.

Pointed out most recently by Stephan A. Rickauer for his sixth
generation, clip-on iPod shuffle.

Fix tested by Stephan.

ok pedro@@ tom@@ miod@@ 'nice' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.68 2006/10/29 00:02:35 krw Exp $	*/
d70 1
d215 27
@


1.68
log
@Remove redundant if (msg) {} block around invocations of
iso_disklabelspoof() and udf_disklabelspoof(). Use (msg &&
iso_disklabelspoof()) instead. Makes more arch's textually consistant.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.67 2006/10/28 23:26:05 krw Exp $	*/
d164 2
@


1.67
log
@We don't currently write a disklabel into an OpenBSD ('A6') DOS MBR
extended partition except on alpha, hppa, hppa64 and mips64. So don't
spoof extended partitions as 'a' and try to read a disklabel from
them. Make all archs consistant.

When we can boot from extended partitions we can change to reading and
writing disklabels from them.

This means the first OpenBSD ('A6') extended partition will now be
ignored during spoofing, just as subsequent ones have always been.

Feedback from tom@@, weingart@@ and deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.66 2006/10/21 20:10:39 krw Exp $	*/
a245 1
	if (msg) {
d247 2
a248 2
		if (iso_disklabelspoof(dev, strat, lp) == 0)
			msg = NULL;
d251 2
a252 2
		if (msg && udf_disklabelspoof(dev, strat, lp) == 0)
			msg = NULL;
a253 1
	}
@


1.66
log
@Don't try to spoof 0 length DOS MBR/EBR partitions. By skipping
partitions with 0 in the length field we don't need to test for
and skip partitions that are all zeros. Eliminating that code
allows elimination of a local pointer.

"0 length partitions are definately dead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.65 2006/10/21 16:01:54 krw Exp $	*/
d124 1
a124 1
		if (ourpart == -1) {
@


1.65
log
@Some KNF cleanup.

De-register. Move declaration to top of function for DOS MBR
processing. Indent nit in macppc.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.64 2006/10/21 14:18:37 krw Exp $	*/
d72 1
a72 1
	char *msg = NULL, *cp;
d165 2
a166 2
			if (letoh32(dp2->dp_size))
				pp->p_size = letoh32(dp2->dp_size);
d171 2
a174 11
				for (cp = (char *)dp2;
				    cp < (char *)(dp2 + 1); cp++)
					if (*cp)
						break;
				/*
				 * Was it all zeroes?  If so, it is
				 * an unused entry that we don't
				 * want to show.
				 */
				if (cp == (char *)(dp2 + 1))
				    continue;
@


1.64
log
@We have a pointer (pp), so use it in the DOSPTYP_UNUSED case rather
than lp->d_partitions[8+n++]. All other cases already use the pointer.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.63 2006/10/20 23:47:42 krw Exp $	*/
d67 1
d159 1
a159 1
			struct partition *pp = &lp->d_partitions[8+n];
@


1.63
log
@Try again with local variable to avoid alignment issues.

"The dosparts member of cpu_disklabel was not used for any persistant
data. Eliminate it, and just use the data being read in while
processing MBR and EBR records.

Should be no functional change.

ok weingart@@ deraadt@@"
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.62 2006/10/18 20:09:38 deraadt Exp $	*/
d183 2
a184 2
				lp->d_partitions[8 + n++].p_fstype =
				    FS_UNUSED;
@


1.62
log
@back out disksubr changes ... since they violate strict alignment on
some architectures (kaboom); that will be fixed in the next iteration
hopefully!
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.60 2006/10/12 00:25:20 krw Exp $	*/
d66 3
a68 1
	struct dos_partition *dp = osdep->dosparts, *dp2;
d70 1
a70 1
	struct disklabel *dlp;
d73 1
a97 4
	if (dp) {
	        daddr_t part_blkno = DOSBBSECTOR;
		unsigned long extoff = 0;
		int wander = 1, n = 0, loop = 0;
d99 54
d154 2
a155 2
		 * Read dos partition table, follow extended partitions.
		 * Map the partitions to disklabel entries i-p
d157 2
a158 12
		while (wander && n < 8 && loop < 8) {
		        loop++;
			wander = 0;
			if (part_blkno < extoff)
				part_blkno = extoff;

			/* read boot record */
			bp->b_blkno = part_blkno;
			bp->b_bcount = lp->d_secsize;
			bp->b_flags = B_BUSY | B_READ;
			bp->b_cylinder = part_blkno / lp->d_secpercyl;
			(*strat)(bp);
d160 16
a175 16
			/* if successful, wander through dos partition table */
			if (biowait(bp)) {
				msg = "dos partition I/O error";
				goto done;
			}
			bcopy(bp->b_data + DOSPARTOFF, dp, NDOSPART * sizeof(*dp));

			if (ourpart == -1) {
				/* Search for our MBR partition */
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (letoh32(dp2->dp_size) &&
					    dp2->dp_typ == DOSPTYP_OPENBSD)
						ourpart = i;
				if (ourpart == -1)
					goto donot;
d177 3
a179 2
				 * This is our MBR partition. need sector address
				 * for SCSI/IDE, cylinder for ESDI/ST506/RLL
d181 26
a206 78
				dp2 = &dp[ourpart];
				dospartoff = letoh32(dp2->dp_start) + part_blkno;
				cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);

				/* XXX build a temporary disklabel */
				lp->d_partitions[0].p_size = letoh32(dp2->dp_size);
				lp->d_partitions[0].p_offset =
					letoh32(dp2->dp_start) + part_blkno;
				if (lp->d_ntracks == 0)
					lp->d_ntracks = dp2->dp_ehd + 1;
				if (lp->d_nsectors == 0)
					lp->d_nsectors = DPSECT(dp2->dp_esect);
				if (lp->d_secpercyl == 0)
					lp->d_secpercyl = lp->d_ntracks *
					    lp->d_nsectors;
			}
donot:
			/*
			 * In case the disklabel read below fails, we want to
			 * provide a fake label in i-p.
			 */
			for (dp2=dp, i=0; i < NDOSPART && n < 8; i++, dp2++) {
				struct partition *pp = &lp->d_partitions[8+n];

				if (dp2->dp_typ == DOSPTYP_OPENBSD)
					continue;
				if (letoh32(dp2->dp_size) > lp->d_secperunit)
					continue;
				if (letoh32(dp2->dp_size))
					pp->p_size = letoh32(dp2->dp_size);
				if (letoh32(dp2->dp_start))
					pp->p_offset =
					    letoh32(dp2->dp_start) + part_blkno;

				switch (dp2->dp_typ) {
				case DOSPTYP_UNUSED:
					for (cp = (char *)dp2;
					    cp < (char *)(dp2 + 1); cp++)
						if (*cp)
							break;
					/*
					 * Was it all zeroes?  If so, it is
					 * an unused entry that we don't
					 * want to show.
					 */
					if (cp == (char *)(dp2 + 1))
					    continue;
					lp->d_partitions[8 + n++].p_fstype =
					    FS_UNUSED;
					break;

				case DOSPTYP_LINUX:
					pp->p_fstype = FS_EXT2FS;
					n++;
					break;

				case DOSPTYP_FAT12:
				case DOSPTYP_FAT16S:
				case DOSPTYP_FAT16B:
				case DOSPTYP_FAT32:
				case DOSPTYP_FAT32L:
				case DOSPTYP_FAT16L:
					pp->p_fstype = FS_MSDOS;
					n++;
					break;
				case DOSPTYP_EXTEND:
				case DOSPTYP_EXTENDL:
					part_blkno = letoh32(dp2->dp_start) + extoff;
					if (!extoff) {
						extoff = letoh32(dp2->dp_start);
						part_blkno = 0;
					}
					wander = 1;
					break;
				default:
					pp->p_fstype = FS_OTHER;
					n++;
					break;
d208 6
a215 3
		lp->d_bbsize = 8192;
		lp->d_sbsize = 64*1024;		/* XXX ? */
		lp->d_npartitions = MAXPARTITIONS;
d217 3
a262 1
		goto done;
d336 2
a337 1
	struct dos_partition *dp = osdep->dosparts, *dp2;
a338 1
	struct disklabel *dlp;
a348 7
	if (dp) {
		/* read master boot record */
		bp->b_blkno = DOSBBSECTOR;
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		bp->b_cylinder = DOSBBSECTOR / lp->d_secpercyl;
		(*strat)(bp);
d350 12
a361 2
		if ((error = biowait(bp)) != 0)
			goto done;
d363 3
a365 7
		/* XXX how do we check veracity/bounds of this? */
		bcopy(bp->b_data + DOSPARTOFF, dp,
		    NDOSPART * sizeof(*dp));

		for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
			if (letoh32(dp2->dp_size) && dp2->dp_typ == DOSPTYP_OPENBSD)
				ourpart = i;
d367 2
a368 2
		if (ourpart != -1) {
			dp2 = &dp[ourpart];
d370 6
a375 7
			/*
			 * need sector address for SCSI/IDE,
			 * cylinder for ESDI/ST506/RLL
			 */
			dospartoff = letoh32(dp2->dp_start);
			cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);
		}
a405 1
	goto done;
@


1.61
log
@The dosparts member of cpu_disklabel was not used for any persistant
data. Eliminate it, and just use the data being read in while
processing MBR and EBR records.

Should be no functional change.

ok weingart@@ deraadt@@
@
text
@d66 2
a67 2
	struct dos_partition *dp, *dp2;
	unsigned long extoff = 0;
a68 2
	struct buf *bp = NULL;
	daddr_t part_blkno = DOSBBSECTOR;
a70 1
	int wander = 1, n = 0, loop = 0;
d95 4
d100 16
a115 9
	/*
	 * Read dos partition table, follow extended partitions.
	 * Map the partitions to disklabel entries i-p
	 */
	while (wander && n < 8 && loop < 8) {
		loop++;
		wander = 0;
		if (part_blkno < extoff)
			part_blkno = extoff;
d117 6
a122 6
		/* read boot record */
		bp->b_blkno = part_blkno;
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		bp->b_cylinder = part_blkno / lp->d_secpercyl;
		(*strat)(bp);
d124 30
a153 16
		/* if successful, wander through dos partition table */
		if (biowait(bp)) {
			msg = "dos partition I/O error";
			goto done;
		}
		dp = (struct dos_partition *)(bp->b_data + DOSPARTOFF);

		if (ourpart == -1) {
			/* Search for our MBR partition */
			for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
			    i++, dp2++)
				if (letoh32(dp2->dp_size) &&
				    dp2->dp_typ == DOSPTYP_OPENBSD)
					ourpart = i;
			if (ourpart == -1)
				goto donot;
d155 2
a156 2
			 * This is our MBR partition. need sector address
			 * for SCSI/IDE, cylinder for ESDI/ST506/RLL
d158 2
a159 23
			dp2 = &dp[ourpart];
			dospartoff = letoh32(dp2->dp_start) + part_blkno;
			cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);

			/* XXX build a temporary disklabel */
			lp->d_partitions[0].p_size = letoh32(dp2->dp_size);
			lp->d_partitions[0].p_offset =
				letoh32(dp2->dp_start) + part_blkno;
			if (lp->d_ntracks == 0)
				lp->d_ntracks = dp2->dp_ehd + 1;
			if (lp->d_nsectors == 0)
				lp->d_nsectors = DPSECT(dp2->dp_esect);
			if (lp->d_secpercyl == 0)
				lp->d_secpercyl = lp->d_ntracks *
				    lp->d_nsectors;
		}
donot:
		/*
		 * In case the disklabel read below fails, we want to
		 * provide a fake label in i-p.
		 */
		for (dp2=dp, i=0; i < NDOSPART && n < 8; i++, dp2++) {
			struct partition *pp = &lp->d_partitions[8+n];
d161 54
a214 47
			if (dp2->dp_typ == DOSPTYP_OPENBSD)
				continue;
			if (letoh32(dp2->dp_size) > lp->d_secperunit)
				continue;
			if (letoh32(dp2->dp_size))
				pp->p_size = letoh32(dp2->dp_size);
			if (letoh32(dp2->dp_start))
				pp->p_offset =
				    letoh32(dp2->dp_start) + part_blkno;

			switch (dp2->dp_typ) {
			case DOSPTYP_UNUSED:
				for (cp = (char *)dp2;
				    cp < (char *)(dp2 + 1); cp++)
					if (*cp)
						break;
				/*
				 * Was it all zeroes?  If so, it is
				 * an unused entry that we don't
				 * want to show.
				 */
				if (cp == (char *)(dp2 + 1))
				    continue;
				lp->d_partitions[8 + n++].p_fstype =
				    FS_UNUSED;
				break;

			case DOSPTYP_LINUX:
				pp->p_fstype = FS_EXT2FS;
				n++;
				break;

			case DOSPTYP_FAT12:
			case DOSPTYP_FAT16S:
			case DOSPTYP_FAT16B:
			case DOSPTYP_FAT32:
			case DOSPTYP_FAT32L:
			case DOSPTYP_FAT16L:
				pp->p_fstype = FS_MSDOS;
				n++;
				break;
			case DOSPTYP_EXTEND:
			case DOSPTYP_EXTENDL:
				part_blkno = letoh32(dp2->dp_start) + extoff;
				if (!extoff) {
					extoff = letoh32(dp2->dp_start);
					part_blkno = 0;
a215 6
				wander = 1;
				break;
			default:
				pp->p_fstype = FS_OTHER;
				n++;
				break;
d218 3
a221 3
	lp->d_bbsize = 8192;
	lp->d_sbsize = 64*1024;		/* XXX ? */
	lp->d_npartitions = MAXPARTITIONS;
d265 1
d339 1
a339 1
	struct dos_partition *dp, *dp2;
d352 7
d360 2
a361 6
	/* read master boot record */
	bp->b_blkno = DOSBBSECTOR;
	bp->b_bcount = lp->d_secsize;
	bp->b_flags = B_BUSY | B_READ;
	bp->b_cylinder = DOSBBSECTOR / lp->d_secpercyl;
	(*strat)(bp);
d363 7
a369 2
	if ((error = biowait(bp)) != 0)
		goto done;
d371 2
a372 2
	/* XXX how do we check veracity/bounds of this? */
	dp = (struct dos_partition *)(bp->b_data + DOSPARTOFF);
d374 7
a380 13
	for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
		if (letoh32(dp2->dp_size) && dp2->dp_typ == DOSPTYP_OPENBSD)
			ourpart = i;

	if (ourpart != -1) {
		dp2 = &dp[ourpart];

		/*
		 * need sector address for SCSI/IDE,
		 * cylinder for ESDI/ST506/RLL
		 */
		dospartoff = letoh32(dp2->dp_start);
		cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);
d411 1
@


1.60
log
@Since we no longer look in FreeBSD or NetBSD partitions for the
disklabel, we shouldn't write the disklabel in such partitions either.

Brings amd64, arm, i386, landisk, macppc, mvmeppc (which roll their
own MBR search in writedisklabel()) into line with alpha, hppa,
hppa64, mips64 (which use readdoslabel() in both reading and writing
the disklabel). If all goes well, soon everyone will be using
readdoslabel().
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.59 2006/10/10 03:17:45 krw Exp $	*/
d66 3
a68 1
	struct dos_partition *dp = osdep->dosparts, *dp2;
d70 1
a70 1
	struct disklabel *dlp;
d73 1
a97 4
	if (dp) {
	        daddr_t part_blkno = DOSBBSECTOR;
		unsigned long extoff = 0;
		int wander = 1, n = 0, loop = 0;
d99 54
d154 2
a155 2
		 * Read dos partition table, follow extended partitions.
		 * Map the partitions to disklabel entries i-p
d157 2
a158 19
		while (wander && n < 8 && loop < 8) {
		        loop++;
			wander = 0;
			if (part_blkno < extoff)
				part_blkno = extoff;

			/* read boot record */
			bp->b_blkno = part_blkno;
			bp->b_bcount = lp->d_secsize;
			bp->b_flags = B_BUSY | B_READ;
			bp->b_cylinder = part_blkno / lp->d_secpercyl;
			(*strat)(bp);

			/* if successful, wander through dos partition table */
			if (biowait(bp)) {
				msg = "dos partition I/O error";
				goto done;
			}
			bcopy(bp->b_data + DOSPARTOFF, dp, NDOSPART * sizeof(*dp));
d160 16
a175 9
			if (ourpart == -1) {
				/* Search for our MBR partition */
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (letoh32(dp2->dp_size) &&
					    dp2->dp_typ == DOSPTYP_OPENBSD)
						ourpart = i;
				if (ourpart == -1)
					goto donot;
d177 3
a179 2
				 * This is our MBR partition. need sector address
				 * for SCSI/IDE, cylinder for ESDI/ST506/RLL
d181 26
a206 78
				dp2 = &dp[ourpart];
				dospartoff = letoh32(dp2->dp_start) + part_blkno;
				cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);

				/* XXX build a temporary disklabel */
				lp->d_partitions[0].p_size = letoh32(dp2->dp_size);
				lp->d_partitions[0].p_offset =
					letoh32(dp2->dp_start) + part_blkno;
				if (lp->d_ntracks == 0)
					lp->d_ntracks = dp2->dp_ehd + 1;
				if (lp->d_nsectors == 0)
					lp->d_nsectors = DPSECT(dp2->dp_esect);
				if (lp->d_secpercyl == 0)
					lp->d_secpercyl = lp->d_ntracks *
					    lp->d_nsectors;
			}
donot:
			/*
			 * In case the disklabel read below fails, we want to
			 * provide a fake label in i-p.
			 */
			for (dp2=dp, i=0; i < NDOSPART && n < 8; i++, dp2++) {
				struct partition *pp = &lp->d_partitions[8+n];

				if (dp2->dp_typ == DOSPTYP_OPENBSD)
					continue;
				if (letoh32(dp2->dp_size) > lp->d_secperunit)
					continue;
				if (letoh32(dp2->dp_size))
					pp->p_size = letoh32(dp2->dp_size);
				if (letoh32(dp2->dp_start))
					pp->p_offset =
					    letoh32(dp2->dp_start) + part_blkno;

				switch (dp2->dp_typ) {
				case DOSPTYP_UNUSED:
					for (cp = (char *)dp2;
					    cp < (char *)(dp2 + 1); cp++)
						if (*cp)
							break;
					/*
					 * Was it all zeroes?  If so, it is
					 * an unused entry that we don't
					 * want to show.
					 */
					if (cp == (char *)(dp2 + 1))
					    continue;
					lp->d_partitions[8 + n++].p_fstype =
					    FS_UNUSED;
					break;

				case DOSPTYP_LINUX:
					pp->p_fstype = FS_EXT2FS;
					n++;
					break;

				case DOSPTYP_FAT12:
				case DOSPTYP_FAT16S:
				case DOSPTYP_FAT16B:
				case DOSPTYP_FAT32:
				case DOSPTYP_FAT32L:
				case DOSPTYP_FAT16L:
					pp->p_fstype = FS_MSDOS;
					n++;
					break;
				case DOSPTYP_EXTEND:
				case DOSPTYP_EXTENDL:
					part_blkno = letoh32(dp2->dp_start) + extoff;
					if (!extoff) {
						extoff = letoh32(dp2->dp_start);
						part_blkno = 0;
					}
					wander = 1;
					break;
				default:
					pp->p_fstype = FS_OTHER;
					n++;
					break;
d208 6
a215 3
		lp->d_bbsize = 8192;
		lp->d_sbsize = 64*1024;		/* XXX ? */
		lp->d_npartitions = MAXPARTITIONS;
d217 3
a262 1
		goto done;
d336 1
a336 1
	struct dos_partition *dp = osdep->dosparts, *dp2;
a348 7
	if (dp) {
		/* read master boot record */
		bp->b_blkno = DOSBBSECTOR;
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		bp->b_cylinder = DOSBBSECTOR / lp->d_secpercyl;
		(*strat)(bp);
d350 12
a361 2
		if ((error = biowait(bp)) != 0)
			goto done;
d363 3
a365 7
		/* XXX how do we check veracity/bounds of this? */
		bcopy(bp->b_data + DOSPARTOFF, dp,
		    NDOSPART * sizeof(*dp));

		for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
			if (letoh32(dp2->dp_size) && dp2->dp_typ == DOSPTYP_OPENBSD)
				ourpart = i;
d367 2
a368 2
		if (ourpart != -1) {
			dp2 = &dp[ourpart];
d370 6
a375 7
			/*
			 * need sector address for SCSI/IDE,
			 * cylinder for ESDI/ST506/RLL
			 */
			dospartoff = letoh32(dp2->dp_start);
			cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);
		}
a405 1
	goto done;
@


1.59
log
@Don't spoof a Free/NetBSD MBR partition as the 'a' partition in a
disklabel. Fixes 'double spoofing' of these partitions as both 'a' and
something in the 'i' to 'p' range.

OpenBSD changed its MBR partition type to 'A6' eight years ago.  As a
backward compatibility measure NetBSD and FreeBSD MBR partitions were
still spoofed as 'a' partitions when no OpenBSD partition could be
found. This bit of backward compatibility is no longer required.

'we can get rid of it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.58 2006/10/04 03:23:01 krw Exp $	*/
a368 6
				ourpart = i;
		for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
			if (letoh32(dp2->dp_size) && dp2->dp_typ == DOSPTYP_FREEBSD)
				ourpart = i;
		for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
			if (letoh32(dp2->dp_size) && dp2->dp_typ == DOSPTYP_NETBSD)
@


1.58
log
@More tidying up after bad144. Remove references in comments and
don't include dkbad.h when nothing in it is used. Missed
arm/include/disklabel.h first time around.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.57 2006/10/04 00:52:55 krw Exp $	*/
a129 10
						ourpart = i;
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (letoh32(dp2->dp_size) &&
					    dp2->dp_typ == DOSPTYP_FREEBSD)
						ourpart = i;
				for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
				    i++, dp2++)
					if (letoh32(dp2->dp_size) &&
					    dp2->dp_typ == DOSPTYP_NETBSD)
@


1.57
log
@Zap bad144 bad sector info in disklabels. Sparsely used if at all for
a few obsolete and easily replaced disk models. And didn't work anyway
according to Bob, who has tried.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.56 2006/09/19 11:06:33 jsg Exp $	*/
d53 1
a53 2
 * find disklabel inside a DOS partition. Also, if bad block
 * table needed, attempt to extract it as well. Return buffer
@


1.56
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.55 2006/09/16 14:56:11 krw Exp $	*/
a67 1
	struct dkbad *bdp = &DKBAD(osdep);
a276 35
	}

	/* obtain bad sector table if requested and present */
	if (bdp && (lp->d_flags & D_BADSECT)) {
		struct dkbad *db;

		i = 0;
		do {
			/* read a bad sector table */
			bp->b_flags = B_BUSY | B_READ;
			bp->b_blkno = lp->d_secperunit - lp->d_nsectors + i;
			if (lp->d_secsize > DEV_BSIZE)
				bp->b_blkno *= lp->d_secsize / DEV_BSIZE;
			else
				bp->b_blkno /= DEV_BSIZE / lp->d_secsize;
			bp->b_bcount = lp->d_secsize;
			bp->b_cylinder = lp->d_ncylinders - 1;
			(*strat)(bp);

			/* if successful, validate, otherwise try another */
			if (biowait(bp)) {
				msg = "bad sector table I/O error";
			} else {
				db = (struct dkbad *)(bp->b_data);
#define DKBAD_MAGIC 0x4321
				if (db->bt_mbz == 0
					&& db->bt_flag == DKBAD_MAGIC) {
					msg = NULL;
					*bdp = *db;
					break;
				} else
					msg = "bad sector table corrupted";
			}
		} while ((bp->b_flags & B_ERROR) && (i += 2) < 10 &&
			i < lp->d_nsectors);
@


1.55
log
@Revert new check for DOS partitions running past d_secperunit (e.g.
r1.54 of i386/disksubr.c). The check incorrectly handled extended
partitions. Possibly a symptom of a deeper problem with extended
partition offsets that will be addressed post-4.0.

Problem reported/fix tested by A. Velichinsky, cause diagnosed by
otto@@.

ok pedro@@ mickey@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.54 2006/08/20 03:14:21 krw Exp $	*/
d64 2
a65 6
readdisklabel(dev, strat, lp, osdep, spoofonly)
	dev_t dev;
	void (*strat)(struct buf *);
	register struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int spoofonly;
d328 2
a329 4
setdisklabel(olp, nlp, openmask, osdep)
	register struct disklabel *olp, *nlp;
	u_long openmask;
	struct cpu_disklabel *osdep;
d331 2
a332 2
	register int i;
	register struct partition *opp, *npp;
d383 2
a384 5
writedisklabel(dev, strat, lp, osdep)
	dev_t dev;
	void (*strat)(struct buf *);
	register struct disklabel *lp;
	struct cpu_disklabel *osdep;
d478 2
a479 5
bounds_check_with_label(bp, lp, osdep, wlabel)
	struct buf *bp;
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int wlabel;
@


1.54
log
@When spoofing an MSDOS disklabel, don't create partitions with a final
block past d_secperunit.

Fixes devices where bogus partitions with a starting offset >
d_secperunit were created. e.g. floppies formatted by Caldera DR-DOS.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.53 2006/08/17 10:34:14 krw Exp $	*/
a175 3
				u_int64_t blkno = (u_int64_t)part_blkno +
				    (u_int64_t)letoh32(dp2->dp_start) +
				    (u_int64_t)letoh32(dp2->dp_size);
d179 1
a179 1
				if (blkno > lp->d_secperunit)
@


1.53
log
@Check d_secpercyl in all readdisklable() functions, and have all of
them return 'invalid geometry' when d_secpercyl == 0. While there move
the check to a consistant location (after the check of d_secperunit)
and use a consistant idiom (i.e. some readdisklabel()'s have no 'done'
label).

prodded by thib@@ after a bad macppc experience. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.52 2006/08/11 21:32:40 krw Exp $	*/
d176 3
d182 1
a182 1
				if (letoh32(dp2->dp_size) > lp->d_secperunit)
@


1.52
log
@Use d_secperunit rather than 0x1fffffff as the default value for
RAW_PART's p_size. Since d_secperunit is initialized to 0x1fffffff if
not specified there should be no need to use the magic number again.
And if d_secperunit was specified then that value should be used
instead of the magic number.

This was already being done for hp300, luna88k, mac68k, mvme68k,
mvme88k.

Should be a no-op.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.51 2006/07/01 16:50:33 krw Exp $	*/
a80 4
	if (lp->d_secpercyl == 0) {
		msg = "invalid geometry";
		goto done;
	}
d83 2
@


1.51
log
@Eliminate redundant get_le() in favour of letoh32(). Add letoh32()
calls in alpha, hppa, hppa64 and mips63 when accessing the two DOS MBR
u_int32_t fields dp_size and dp_start.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.50 2006/05/11 13:21:11 mickey Exp $	*/
d93 1
a93 1
		lp->d_partitions[i].p_size = 0x1fffffff;
@


1.50
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.49 2006/03/15 20:20:39 miod Exp $	*/
d136 1
a136 1
					if (get_le(&dp2->dp_size) &&
d141 1
a141 1
					if (get_le(&dp2->dp_size) &&
d146 1
a146 1
					if (get_le(&dp2->dp_size) &&
d156 1
a156 1
				dospartoff = get_le(&dp2->dp_start) + part_blkno;
d160 1
a160 1
				lp->d_partitions[0].p_size = get_le(&dp2->dp_size);
d162 1
a162 1
					get_le(&dp2->dp_start) + part_blkno;
d181 1
a181 1
				if (get_le(&dp2->dp_size) > lp->d_secperunit)
d183 3
a185 3
				if (get_le(&dp2->dp_size))
					pp->p_size = get_le(&dp2->dp_size);
				if (get_le(&dp2->dp_start))
d187 1
a187 1
					    get_le(&dp2->dp_start) + part_blkno;
d222 1
a222 1
					part_blkno = get_le(&dp2->dp_start) + extoff;
d224 1
a224 1
						extoff = get_le(&dp2->dp_start);
d426 1
a426 1
			if (get_le(&dp2->dp_size) && dp2->dp_typ == DOSPTYP_OPENBSD)
d429 1
a429 1
			if (get_le(&dp2->dp_size) && dp2->dp_typ == DOSPTYP_FREEBSD)
d432 1
a432 1
			if (get_le(&dp2->dp_size) && dp2->dp_typ == DOSPTYP_NETBSD)
d442 1
a442 1
			dospartoff = get_le(&dp2->dp_start);
@


1.49
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.48 2006/03/04 19:33:21 miod Exp $	*/
d124 1
a124 1
		     
@


1.48
log
@Typos grab bag of the month, eyeballed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.47 2005/12/22 03:02:48 krw Exp $	*/
a42 7

void
dk_establish(dk, dev)
	struct disk *dk;
	struct device *dev;
{
}
@


1.47
log
@'spoofonly' does not mean what I thought it meant. The whole point is
to read non-OpenBSD label information like MBRs and populate ('spoof')
the OpenBSD disk label appropriately. So avoiding an I/O when doing
'spoofonly' is to miss the whole point.

Backout all Sept. 26 and subsequent changes to disksubr.c files. The
original CD problem with I/O errors on blank media will be addressed
another way.

Should fix the ext3 vs amd64 problems discussed on misc@@. Thanks to
steven@@ for finally putting it terms that I understood.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.46 2005/09/27 23:56:12 krw Exp $	*/
d85 1
a85 1
	/* minimal requirements for archtypal disk label */
@


1.46
log
@Don't try to read the DOS label from the device if spoofonly is 1.
This changes the architectures which use code identical to the amd64
disksubr.c.

macppc seems different so it will be separate. The remaining archs
don't try to read a DOS label.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.45 2005/03/30 07:52:31 deraadt Exp $	*/
a123 5

			if (spoofonly) {
				bzero(dp, NDOSPART * sizeof(*dp));
				goto donot;
			}
@


1.45
log
@first approximation:  spoof UDF filesystem disklabels when we see them.
it is likely a slight bug or two will sneak in with this, so everyone
please keep an eye out on your disklabels
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.44 2004/03/17 14:16:04 miod Exp $	*/
d124 5
@


1.44
log
@Make sure disklabels use at least DEV_BSIZE as their sector size.
This allows the kernel to survive reading the disklabel off a 256-bytes/sector
scsi device...

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.43 2003/06/02 23:27:47 millert Exp $	*/
d284 4
@


1.43
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.42 2002/03/14 01:26:32 millert Exp $	*/
d86 1
a86 1
	if (lp->d_secsize == 0)
@


1.42
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.41 2002/02/19 02:46:40 deraadt Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.41
log
@correct extended partition botch; gluk, in PR 1449
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.40 2000/10/18 21:00:35 mickey Exp $	*/
d77 1
a77 1
	void (*strat) __P((struct buf *));
d400 1
a400 1
	void (*strat) __P((struct buf *));
@


1.40
log
@typo in comment; from gluk@@ptci.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.39 2000/07/07 17:17:54 art Exp $	*/
d126 2
d234 1
a234 1
					if (!extoff)
d236 2
@


1.40.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.40 2000/10/18 21:00:35 mickey Exp $	*/
d77 1
a77 1
	void (*strat)(struct buf *);
a125 2
			if (part_blkno < extoff)
				part_blkno = extoff;
d232 1
a232 1
					if (!extoff) {
a233 2
						part_blkno = 0;
					}
d396 1
a396 1
	void (*strat)(struct buf *);
@


1.39
log
@Use b_cylinder instead of a homebrew define.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.38 2000/04/24 04:53:01 deraadt Exp $	*/
d57 1
a57 1
 * using the indicated stategy routine.
@


1.38
log
@support DOSPTYP_EXTENDL like DOSPTYP_EXTEND; scott@@nts.umn.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.37 1999/07/17 17:00:26 csapuntz Exp $	*/
a47 2
#define	b_cylin	b_resid

d131 1
a131 1
			bp->b_cylin = part_blkno / lp->d_secpercyl;
d254 1
a254 1
	bp->b_cylin = cyl;
d303 1
a303 1
			bp->b_cylin = lp->d_ncylinders - 1;
d418 1
a418 1
		bp->b_cylin = DOSBBSECTOR / lp->d_secpercyl;
d452 1
a452 1
	bp->b_cylin = cyl;
d538 2
a539 2
	bp->b_cylin = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
	    lp->d_secpercyl;
@


1.37
log
@

Fix a bug that caused panic instead of error return with invalid disk
geometries.

Make sure we don't brelse a buf that we don't have.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.36 1999/01/08 04:29:06 millert Exp $	*/
d232 1
@


1.37.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.40 2000/10/18 21:00:35 mickey Exp $	*/
d48 2
d59 1
a59 1
 * using the indicated strategy routine.
d133 1
a133 1
			bp->b_cylinder = part_blkno / lp->d_secpercyl;
a231 1
				case DOSPTYP_EXTENDL:
d255 1
a255 1
	bp->b_cylinder = cyl;
d304 1
a304 1
			bp->b_cylinder = lp->d_ncylinders - 1;
d419 1
a419 1
		bp->b_cylinder = DOSBBSECTOR / lp->d_secpercyl;
d453 1
a453 1
	bp->b_cylinder = cyl;
d539 2
a540 2
	bp->b_cylinder = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
		lp->d_secpercyl;
@


1.37.4.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a125 2
			if (part_blkno < extoff)
				part_blkno = extoff;
d232 1
a232 1
					if (!extoff) {
a233 2
						part_blkno = 0;
					}
@


1.37.4.3
log
@Merge in -current from about a week ago
@
text
@d77 1
a77 1
	void (*strat)(struct buf *);
d400 1
a400 1
	void (*strat)(struct buf *);
@


1.37.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.37.4.3 2002/03/28 10:31:04 niklas Exp $	*/
d17 5
a21 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.37.4.5
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 1
a86 1
	if (lp->d_secsize < DEV_BSIZE)
@


1.36
log
@check for lp->d_secpercyl == 0) in bounds_check_with_label()
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.35 1998/11/21 20:43:43 deraadt Exp $	*/
d86 1
a86 1
	struct buf *bp;
d326 4
a329 2
	bp->b_flags |= B_INVAL;
	brelse(bp);
@


1.35
log
@deal with d_secpercyl insanity
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.34 1998/10/03 21:18:54 millert Exp $	*/
d503 7
@


1.34
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.33 1998/02/24 04:22:41 deraadt Exp $	*/
d94 4
@


1.33
log
@rename some DOS MBR partition types
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.32 1998/02/22 21:35:25 niklas Exp $	*/
d77 1
a77 1
readdisklabel(dev, strat, lp, osdep)
d82 1
d244 4
@


1.32
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.31 1998/02/19 20:36:40 deraadt Exp $	*/
a219 1
				case DOSPTYP_FAT16C:
d221 2
@


1.31
log
@add netbsd partition, rename 386BSD one to FreeBSD..
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.30 1998/01/11 20:42:06 provos Exp $	*/
d331 1
a331 1
	register i;
@


1.30
log
@disklabel spoofing for FAT32.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.29 1997/10/24 00:15:05 mickey Exp $	*/
d148 6
a153 1
					    dp2->dp_typ == DOSPTYP_386BSD)
d421 4
a424 1
			if (get_le(&dp2->dp_size) && dp2->dp_typ == DOSPTYP_386BSD)
@


1.29
log
@remove bogus defines
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.28 1997/10/18 10:35:00 deraadt Exp $	*/
d216 1
@


1.28
log
@do not create spoofed partition for DOSTYP_OPENBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.27 1997/10/02 00:50:51 deraadt Exp $	*/
a49 3
#define BOOT_MAGIC 0xAA55
#define BOOT_MAGIC_OFF (DOSPARTOFF+NDOSPART*sizeof(struct dos_partition))

d70 1
a70 1
 * We would like to check if each MBR has a valid BOOT_MAGIC, but
@


1.27
log
@no more ESRCH from writedisklabel()
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.26 1997/09/29 01:12:21 deraadt Exp $	*/
d183 2
@


1.26
log
@ignore partitions larger than device, as an attempt to ignore floppies without MBR
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.16 1997/09/23 12:46:38 pefo Exp $	*/
d453 7
a459 1
	error = ESRCH;
@


1.25
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.24 1997/05/08 00:05:51 deraadt Exp $	*/
d145 1
a145 1
					if (dp2->dp_size &&
d150 1
a150 1
					if (dp2->dp_size &&
d160 1
a160 1
				dospartoff = dp2->dp_start + part_blkno;
d164 3
a166 3
				lp->d_partitions[0].p_size = dp2->dp_size;
				lp->d_partitions[0].p_offset = dp2->dp_start +
				    part_blkno;
d183 5
a187 3
				if (dp2->dp_size)
					pp->p_size = dp2->dp_size;
				if (dp2->dp_start)
d189 1
a189 1
					    dp2->dp_start + part_blkno;
d221 1
a221 1
					part_blkno = dp2->dp_start + extoff;
d223 1
a223 1
						extoff = dp2->dp_start;
d413 1
a413 1
			if (dp2->dp_size && dp2->dp_typ == DOSPTYP_OPENBSD)
d416 1
a416 1
			if (dp2->dp_size && dp2->dp_typ == DOSPTYP_386BSD)
d426 1
a426 1
			dospartoff = dp2->dp_start;
@


1.24
log
@wandering fix from provos
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.23 1997/05/08 00:04:06 deraadt Exp $	*/
d87 1
a87 1
	struct dkbad *bdp = &osdep->bad;
d465 1
a465 1
bounds_check_with_label(bp, lp, wlabel)
d468 1
@


1.23
log
@only detect first 166/165 as valid
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.22 1997/04/30 08:40:11 provos Exp $	*/
d178 1
a178 2
			 * provide a fake label in which m/n/o/p are MBR 
			 * partitions 0/1/2/3
d180 1
a180 2
			for (dp2=dp, i=0; i < NDOSPART && !wander && n < 8;
			    i++, dp2++) {
@


1.22
log
@guarantee termination for faked disklabels, no endless loops
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.21 1997/04/18 20:15:43 deraadt Exp $	*/
d73 4
d117 1
a117 3
		int wander = 1;
		int n = 0;
		int loop = 0;
a124 2

			/* on finding a extended partition wander further */
a138 7
		     
                	/* 
			 * We would like to check if each MBR has a valid
			 * BOOT_MAGIC, but we cannot because it doesn't
			 * always exist. So.. we assume the MBR is valid.
			 */
		     
a140 3
			/*
			 * Search for our MBR partition
			 */
d142 1
d153 2
a154 5
			}

			if (ourpart != -1) {
				dp2 = &dp[ourpart];

d159 1
d175 1
a175 1

d181 2
a182 1
			for (dp2=dp, i=0; i < NDOSPART && !wander; i++, dp2++) {
a184 5
/*		       		if (dp2->dp_start + dp2->dp_size > 
				    lp->d_ncylinders * lp->d_secpercyl)
					continue;
*/

d237 1
a237 1
	
d366 2
a367 2
 	nlp->d_checksum = 0;
 	nlp->d_checksum = dkcksum(nlp);
d375 1
d430 1
a430 1
	
@


1.21
log
@do not check BOOT_MAGIC!
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.20 1997/04/18 14:27:22 provos Exp $	*/
d115 1
d121 3
a123 1
		while (wander && n < 8) {
@


1.20
log
@faked disklabel for extended partition +
fixes by Niklas to faciliate use of other partition types (ext2fs) +
Indentation by Theo ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.19 1997/04/06 06:04:26 deraadt Exp $	*/
a114 1
		unsigned char *p;
d137 5
a141 6
                	/* XXX - how do we check veracity/bounds of this? */
			p = (unsigned char *)bp->b_data + BOOT_MAGIC_OFF;
			if ((p[0] | (p[1] << 8)) != BOOT_MAGIC) {
				msg = "dos partition corrupt";
				goto done;
			}
@


1.19
log
@correct labelsector confusion
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.18 1997/04/05 21:56:02 deraadt Exp $	*/
d50 2
a51 2
int fat_types[] = { DOSPTYP_FAT12, DOSPTYP_FAT16S,
		    DOSPTYP_FAT16B, DOSPTYP_FAT16C, -1 };
d86 2
a87 2
	char *msg = NULL;
	int dospartoff, cyl, i, *ip, ourpart = -1;
d111 5
a115 15
		/* read master boot record */
		bp->b_blkno = DOSBBSECTOR;
		bp->b_bcount = lp->d_secsize;
		bp->b_flags = B_BUSY | B_READ;
		bp->b_cylin = DOSBBSECTOR / lp->d_secpercyl;
		(*strat)(bp);

		/* if successful, wander through dos partition table */
		if (biowait(bp)) {
			msg = "dos partition I/O error";
			goto done;
		}

		/* XXX how do we check veracity/bounds of this? */
		bcopy(bp->b_data + DOSPARTOFF, dp, NDOSPART * sizeof(*dp));
d118 2
a119 1
		 * Search for our MBR partition
d121 25
a145 6
		for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
			if (dp2->dp_size && dp2->dp_typ == DOSPTYP_OPENBSD)
				ourpart = i;
		for (dp2=dp, i=0; i < NDOSPART && ourpart == -1; i++, dp2++)
			if (dp2->dp_size && dp2->dp_typ == DOSPTYP_386BSD)
				ourpart = i;
d147 38
a184 2
		if (ourpart != -1) {
			dp2 = &dp[ourpart];
d187 3
a189 2
			 * This is our MBR partition. need sector address
			 * for SCSI/IDE, cylinder for ESDI/ST506/RLL
d191 2
a192 2
			dospartoff = dp2->dp_start;
			cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);
d194 4
a197 11
			/* XXX build a temporary disklabel */
			lp->d_partitions[0].p_size = dp2->dp_size;
			lp->d_partitions[0].p_offset = dp2->dp_start;
			if (lp->d_ntracks == 0)
				lp->d_ntracks = dp2->dp_ehd + 1;
			if (lp->d_nsectors == 0)
				lp->d_nsectors = DPSECT(dp2->dp_esect);
			if (lp->d_secpercyl == 0)
				lp->d_secpercyl = lp->d_ntracks *
				    lp->d_nsectors;
		}
d199 46
a244 14
		/*
		 * In case the disklabel read below fails, we want to provide
		 * a fake label in which m/n/o/p are MBR partitions 0/1/2/3
		 */
		for (dp2=dp, i=0; i < NDOSPART; i++, dp2++) {
			if (dp2->dp_start + dp2->dp_size > lp->d_nsectors)
				continue;
			lp->d_partitions[12+i].p_size = dp2->dp_size;
			lp->d_partitions[12+i].p_offset = dp2->dp_start;
			for (ip = fat_types; *ip != -1; ip++) {
				if (dp2->dp_typ != *ip)
					continue;
				lp->d_partitions[12+i].p_fstype =
				    FS_MSDOS;
@


1.18
log
@correct DEV_BSIZE vs lp->d_secsize confusion; spotted by hte late night icb gang. Other ports need fixing still
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.17 1997/01/24 11:17:09 deraadt Exp $	*/
d413 1
d415 2
a416 1
	int labelsector = lp->d_partitions[RAW_PART].p_offset + LABELSECTOR;
a417 2

#define blockpersec(count, lp) ((count) * (((lp)->d_secsize) / DEV_BSIZE))
@


1.17
log
@do not build fake disklabel partitions for MBR partitions that have out-of-range start/size fields
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.16 1997/01/14 00:46:45 deraadt Exp $	*/
d415 1
a415 1
	int sz;
d417 1
a417 1
	sz = howmany(bp->b_bcount, lp->d_secsize);
d419 2
a420 2
	if (bp->b_blkno + sz > p->p_size) {
		sz = p->p_size - bp->b_blkno;
d436 1
a436 1
	if (bp->b_blkno + p->p_offset <= labelsector &&
d438 1
a438 1
	    bp->b_blkno + p->p_offset + sz > labelsector &&
d446 2
a447 2
	bp->b_cylin = (bp->b_blkno + p->p_offset) /
	    (lp->d_secsize / DEV_BSIZE) / lp->d_secpercyl;
@


1.16
log
@RAW_PART
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.15 1996/12/09 15:54:57 deraadt Exp $	*/
d164 2
@


1.15
log
@arc port can use the same disksubr code, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.14 1996/12/09 07:19:22 deraadt Exp $	*/
d412 1
a412 1
	int labelsector = lp->d_partitions[2].p_offset + LABELSECTOR;
@


1.14
log
@brelse properly
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.13 1996/12/07 12:20:39 deraadt Exp $	*/
d5 1
@


1.13
log
@fake the isofs label only if other probes fail
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.12 1996/12/05 13:09:35 deraadt Exp $	*/
d209 1
a209 1
			return (msg);
@


1.12
log
@call iso_disklabelspoof() as needed...
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.11 1996/10/23 15:24:07 deraadt Exp $	*/
a101 5
#if defined(CD9660)
	if (iso_disklabelspoof(dev, strat, lp) == 0)
		return (msg);
#endif

d206 5
a210 1
	if (msg)
d212 1
@


1.11
log
@correct disklabel writing; from price
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.10 1996/10/16 11:30:39 deraadt Exp $	*/
d101 5
@


1.10
log
@unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.9 1996/10/01 01:54:03 deraadt Exp $	*/
d321 1
a321 1
	int ourpart;
d359 2
a360 2
			dospartoff = dp->dp_start;
			cyl = DPCYL(dp->dp_scyl, dp->dp_ssect);
@


1.9
log
@writedisklabel with same semantics as readdisklabel
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.8 1996/09/28 09:44:10 deraadt Exp $	*/
a81 1
	struct partition *pp;
@


1.9.2.1
log
@merge fixes from price
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.10 1996/10/16 11:30:39 deraadt Exp $	*/
d82 1
d322 1
a322 1
	int ourpart = -1;
d360 2
a361 2
			dospartoff = dp2->dp_start;
			cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);
@


1.8
log
@if no disklabel, fake the MBR partitions at m/n/o/p
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.7 1996/09/26 21:08:53 niklas Exp $	*/
a149 2
			lp->d_partitions[RAW_PART].p_size = dp2->dp_size;
			lp->d_partitions[RAW_PART].p_offset = dp2->dp_start;
d265 3
a267 3
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0
		|| (nlp->d_secsize % DEV_BSIZE) != 0)
			return(EINVAL);
d318 1
a318 1
	struct dos_partition *dp = osdep->dosparts;
d322 1
d339 23
a361 13
		if ((error = biowait(bp)) == 0) {
			/* XXX how do we check veracity/bounds of this? */
			bcopy(bp->b_data + DOSPARTOFF, dp,
			    NDOSPART * sizeof(*dp));
			for (i = 0; i < NDOSPART; i++, dp++)
				/* is this ours? */
				if (dp->dp_size && dp->dp_typ == DOSPTYP_386BSD
				    && dospartoff == 0) {
					/* need sector address for SCSI/IDE,
					   cylinder for ESDI/ST506/RLL */
					dospartoff = dp->dp_start;
					cyl = DPCYL(dp->dp_scyl, dp->dp_ssect);
				}
a362 1
			
a364 9
#ifdef maybe
	/* disklabel in appropriate location? */
	if (lp->d_partitions[0].p_offset != 0
		&& lp->d_partitions[0].p_offset != dospartoff) {
		error = EXDEV;		
		goto done;
	}
#endif

@


1.7
log
@Do not override sectors, track & secpercyl values set by the driver, it
is deadly if CHS addressing is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.6 1996/09/25 11:20:13 deraadt Exp $	*/
d138 1
a138 1
			dp = &dp[i];
d141 2
a142 3
			 * This is our MBR partition.
			 * need sector address for SCSI/IDE,
			 * cylinder for ESDI/ST506/RLL
d144 2
a145 2
			dospartoff = dp->dp_start;
			cyl = DPCYL(dp->dp_scyl, dp->dp_ssect);
d148 4
a151 4
			lp->d_partitions[0].p_size = dp->dp_size;
			lp->d_partitions[0].p_offset = dp->dp_start;
			lp->d_partitions[RAW_PART].p_size = dp->dp_size;
			lp->d_partitions[RAW_PART].p_offset = dp->dp_start;
d153 1
a153 1
				lp->d_ntracks = dp->dp_ehd + 1;
d155 1
a155 1
				lp->d_nsectors = DPSECT(dp->dp_esect);
d160 18
@


1.6
log
@prefer a DOSPTYP_OPENBSD MBR partition, but accept one of DOSPTYP_386BSD.
remove garbage that made d/e/f/g/h partitions special (bet you didn't
know that this code was trying to treat e/f/g/h as special MBR partitions
did you!)
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.5 1996/06/01 09:34:30 deraadt Exp $	*/
d153 7
a159 3
			lp->d_ntracks = dp->dp_ehd + 1;
			lp->d_nsectors = DPSECT(dp->dp_esect);
			lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
@


1.5
log
@i386 needs dk_establish()
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.4 1996/05/07 07:21:36 deraadt Exp $	*/
d81 1
a81 1
	struct dos_partition *dp = osdep->dosparts;
d87 1
a87 1
	int dospartoff, cyl, i, *ip;
d122 34
a155 34
		} else {
			/* XXX how do we check veracity/bounds of this? */
			bcopy(bp->b_data + DOSPARTOFF, dp,
			    NDOSPART * sizeof(*dp));
			for (i = 0; i < NDOSPART; i++, dp++) {
				/* Install in partition e, f, g, or h. */
				pp = &lp->d_partitions[RAW_PART + 1 + i];
				pp->p_offset = dp->dp_start;
				pp->p_size = dp->dp_size;
				for (ip = fat_types; *ip != -1; ip++) {
				    if (dp->dp_typ == *ip)
					pp->p_fstype = FS_MSDOS;
				}

				/* is this ours? */
				if (dp->dp_size && dp->dp_typ == DOSPTYP_386BSD
				    && dospartoff == 0) {
					/* need sector address for SCSI/IDE,
					   cylinder for ESDI/ST506/RLL */
					dospartoff = dp->dp_start;
					cyl = DPCYL(dp->dp_scyl, dp->dp_ssect);

					/* update disklabel with details */
					lp->d_partitions[0].p_size =
					    dp->dp_size;
					lp->d_partitions[0].p_offset = 
					    dp->dp_start;
					lp->d_ntracks = dp->dp_ehd + 1;
					lp->d_nsectors = DPSECT(dp->dp_esect);
					lp->d_secpercyl =
					    lp->d_ntracks * lp->d_nsectors;
				}
			}
			lp->d_npartitions = RAW_PART + 1 + i;
d168 1
@


1.4
log
@sync with 0504; prototype changes
@
text
@d1 1
a1 1
/*	$OpenBSD: disksubr.c,v 1.3 1996/04/21 22:16:25 deraadt Exp $	*/
d42 1
d45 1
d51 7
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: disksubr.c,v 1.2 1996/04/18 19:18:07 niklas Exp $	*/
/*	$NetBSD: disksubr.c,v 1.20 1996/04/03 08:18:27 mycroft Exp $	*/
d68 1
a68 1
	void (*strat)();
a231 1
	struct dos_partition *dp = osdep->dosparts;
d285 1
a285 1
	void (*strat)();
d343 1
a343 1
	if (error = biowait(bp))
@


1.2
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: disksubr.c,v 1.19 1996/03/09 20:52:59 ghudson Exp $	*/
d226 1
d283 1
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: disksubr.c,v 1.18 1995/01/13 10:30:08 mycroft Exp $	*/
d47 3
d73 1
d78 1
a78 1
	int dospartoff, cyl, i;
d117 10
a126 1
			for (i = 0; i < NDOSPART; i++, dp++)
d145 2
a147 1
			
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
