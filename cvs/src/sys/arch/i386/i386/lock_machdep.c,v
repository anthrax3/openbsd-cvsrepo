head	1.24;
access;
symbols
	OPENBSD_6_1:1.20.0.4
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.10.0.18
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.16
	OPENBSD_5_0:1.10.0.14
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.12
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.10
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.6
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.8
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.3.0.2
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.2.0.10
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.8
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	UBC_SYNC_A:1.1
	UBC_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.24
date	2017.05.28.08.47.19;	author mpi;	state Exp;
branches;
next	1.23;
commitid	IEGjSFazYftxVkwt;

1.23
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.22;
commitid	2Gtqjzrin9LL2yHk;

1.22
date	2017.04.20.13.20.17;	author visa;	state Exp;
branches;
next	1.21;
commitid	sZ4zTrZbj3VK0Rkg;

1.21
date	2017.04.16.14.28.07;	author visa;	state Exp;
branches;
next	1.20;
commitid	tcoNZhnUhgj56GfW;

1.20
date	2017.03.07.14.41.57;	author visa;	state Exp;
branches;
next	1.19;
commitid	QuoJY64mTVcW3iGY;

1.19
date	2016.03.19.11.34.22;	author mpi;	state Exp;
branches;
next	1.18;
commitid	15xZY6veDWwRM6Iq;

1.18
date	2015.05.30.08.41.30;	author kettenis;	state Exp;
branches;
next	1.17;
commitid	WTgCsX48WglrjG8M;

1.17
date	2015.02.11.05.54.48;	author dlg;	state Exp;
branches;
next	1.16;
commitid	fAl1KR17j4jH74Xf;

1.16
date	2014.07.20.02.48.59;	author guenther;	state Exp;
branches;
next	1.15;
commitid	kpjidbWyLMzemdgM;

1.15
date	2014.07.10.12.14.48;	author mlarkin;	state Exp;
branches;
next	1.14;
commitid	HJVrj1M0qsHVknqv;

1.14
date	2014.03.14.03.01.38;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2013.12.05.01.28.45;	author uebayasi;	state Exp;
branches;
next	1.12;

1.12
date	2013.05.21.20.05.30;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2012.12.05.23.20.12;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.27.15.56.11;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.26.19.00.56;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.26.17.15.29;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.29.18.18.20;	author tom;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.25.15.55.26;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.04.12.58.41;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.14.10.02.26;	author ho;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.07.14.10.02.26;	author ho;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.07.15.15.10.55;	author ho;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.05.18.17.41.15;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Use intr_disable()/intr_restore() to reduce differences with sparc64
mp_lock.

ok kettenis@@, visa@@
@
text
@/*	$OpenBSD: lock_machdep.c,v 1.23 2017/04/30 16:45:45 mpi Exp $	*/
/* $NetBSD: lock_machdep.c,v 1.1.2.3 2000/05/03 14:40:30 sommerfeld Exp $ */

/*-
 * Copyright (c) 1998, 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Machine-dependent spin lock operations.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/atomic.h>
#include <sys/witness.h>
#include <sys/_lock.h>

#include <machine/lock.h>
#include <machine/cpufunc.h>

#include <ddb/db_output.h>

#ifdef MULTIPROCESSOR
 void
___mp_lock_init(struct __mp_lock *mpl)
{
	memset(mpl->mpl_cpus, 0, sizeof(mpl->mpl_cpus));
	mpl->mpl_users = 0;
	mpl->mpl_ticket = 1;
}

#if defined(MP_LOCKDEBUG)
#ifndef DDB
#error "MP_LOCKDEBUG requires DDB"
#endif

/* CPU-dependent timing, needs this to be settable from ddb. */
extern int __mp_lock_spinout;
#endif

static __inline void
__mp_lock_spin(struct __mp_lock *mpl, u_int me)
{
#ifndef MP_LOCKDEBUG
	while (mpl->mpl_ticket != me)
		SPINLOCK_SPIN_HOOK;
#else
	int nticks = __mp_lock_spinout;

	while (mpl->mpl_ticket != me) {
		SPINLOCK_SPIN_HOOK;

		if (--nticks <= 0) {
			db_printf("__mp_lock(%p): lock spun out", mpl);
			db_enter();
			nticks = __mp_lock_spinout;
		}
	}
#endif
}

void
___mp_lock(struct __mp_lock *mpl LOCK_FL_VARS)
{
	struct __mp_lock_cpu *cpu = &mpl->mpl_cpus[cpu_number()];
	unsigned long s;
#ifdef WITNESS
	int lock_held;

	lock_held = __mp_lock_held(mpl);
	if (!lock_held)
		WITNESS_CHECKORDER(&mpl->mpl_lock_obj,
		    LOP_EXCLUSIVE | LOP_NEWORDER, file, line, NULL);
#endif

	s = intr_disable();
	if (cpu->mplc_depth++ == 0)
		cpu->mplc_ticket = atomic_inc_int_nv(&mpl->mpl_users);
	intr_restore(s);

	__mp_lock_spin(mpl, cpu->mplc_ticket);

	WITNESS_LOCK(&mpl->mpl_lock_obj, LOP_EXCLUSIVE, file, line);
}

void
___mp_unlock(struct __mp_lock *mpl LOCK_FL_VARS)
{
	struct __mp_lock_cpu *cpu = &mpl->mpl_cpus[cpu_number()];
	unsigned long s;

#ifdef MP_LOCKDEBUG
	if (!__mp_lock_held(mpl)) {
		db_printf("__mp_unlock(%p): not held lock\n", mpl);
		db_enter();
	}
#endif

	WITNESS_UNLOCK(&mpl->mpl_lock_obj, LOP_EXCLUSIVE, file, line);

	s = intr_disable();
	if (--cpu->mplc_depth == 0)
		mpl->mpl_ticket++;
	intr_restore(s);
}

int
___mp_release_all(struct __mp_lock *mpl LOCK_FL_VARS)
{
	struct __mp_lock_cpu *cpu = &mpl->mpl_cpus[cpu_number()];
	unsigned long s;
	int rv;
#ifdef WITNESS
	int i;
#endif

	s = intr_disable();
	rv = cpu->mplc_depth;
#ifdef WITNESS
	for (i = 0; i < rv; i++)
		WITNESS_UNLOCK(&mpl->mpl_lock_obj, LOP_EXCLUSIVE, file, line);
#endif
	cpu->mplc_depth = 0;
	mpl->mpl_ticket++;
	intr_restore(s);

	return (rv);
}

int
___mp_release_all_but_one(struct __mp_lock *mpl LOCK_FL_VARS)
{
	struct __mp_lock_cpu *cpu = &mpl->mpl_cpus[cpu_number()];
	int rv = cpu->mplc_depth - 1;
#ifdef WITNESS
	int i;

	for (i = 0; i < rv; i++)
		WITNESS_UNLOCK(&mpl->mpl_lock_obj, LOP_EXCLUSIVE, file, line);
#endif

	cpu->mplc_depth = 1;

	return (rv);
}

void
___mp_acquire_count(struct __mp_lock *mpl, int count LOCK_FL_VARS)
{
	while (count--)
		___mp_lock(mpl LOCK_FL_ARGS);
}

int
__mp_lock_held(struct __mp_lock *mpl)
{
	struct __mp_lock_cpu *cpu = &mpl->mpl_cpus[cpu_number()];

	return (cpu->mplc_ticket == mpl->mpl_ticket && cpu->mplc_depth > 0);
}

#endif
@


1.23
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.22 2017/04/20 13:20:17 visa Exp $	*/
d92 1
a92 1
	long ef = read_eflags();
d102 1
a102 1
	disable_intr();
d105 1
a105 1
	write_eflags(ef);
d116 1
a116 1
	int ef = read_eflags();
d127 1
a127 1
	disable_intr();
d130 1
a130 1
	write_eflags(ef);
d137 1
a137 1
	int ef = read_eflags();
d143 1
a143 1
	disable_intr();
d151 1
a151 1
	write_eflags(ef);
@


1.22
log
@Hook up mplock to witness(4) on amd64 and i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.21 2017/04/16 14:28:07 visa Exp $	*/
d81 1
a81 1
			Debugger();
d121 1
a121 1
		Debugger();
@


1.21
log
@Replace fetch_and_add() with atomic_inc_int_nv() from <sys/atomic.h>
to make the code more similar to sparc64's.

OK mpi@@, guenther@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.20 2017/03/07 14:41:57 visa Exp $	*/
d41 2
d51 1
a51 1
__mp_lock_init(struct __mp_lock *mpl)
d89 1
a89 1
__mp_lock(struct __mp_lock *mpl)
d93 8
d108 2
d113 1
a113 1
__mp_unlock(struct __mp_lock *mpl)
d125 2
d134 1
a134 1
__mp_release_all(struct __mp_lock *mpl)
d139 3
d145 4
d157 1
a157 1
__mp_release_all_but_one(struct __mp_lock *mpl)
d161 6
d174 1
a174 1
__mp_acquire_count(struct __mp_lock *mpl, int count)
d177 1
a177 1
		__mp_lock(mpl);
@


1.20
log
@Keep on trying to grab the lock after leaving ddb after lock spin-out.
This restores the behaviour that preceded ticket locks. The feature can
be useful in some debug cases where the system is not totally borken.

OK guenther@@, dlg@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.19 2016/03/19 11:34:22 mpi Exp $	*/
d40 1
a41 1
#include <machine/atomic.h>
d53 1
a53 1
	mpl->mpl_ticket = 0;
a64 11
static inline u_int
fetch_and_add(u_int *var, u_int value)
{
	asm volatile("lock; xaddl %%eax, %2;"
	    : "=a" (value)
	    : "a" (value), "m" (*var)
	    : "memory");
 
	return (value);
}

d94 1
a94 1
		cpu->mplc_ticket = fetch_and_add(&mpl->mpl_users, 1);
@


1.19
log
@Reduces the noise around the global ``ticks'' variable by renaming
all the local ones to ``nticks''.

ok stefan@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.18 2015/05/30 08:41:30 kettenis Exp $	*/
d85 1
a85 1
	while (mpl->mpl_ticket != me && --nticks > 0)
d88 5
a92 3
	if (nticks == 0) {
		db_printf("__mp_lock(%p): lock spun out", mpl);
		Debugger();
@


1.18
log
@Native atomic operations for i386.

ok deraadt@@, guenther@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.17 2015/02/11 05:54:48 dlg Exp $	*/
d83 1
a83 1
	int ticks = __mp_lock_spinout;
d85 1
a85 1
	while (mpl->mpl_ticket != me && --ticks > 0)
d88 1
a88 1
	if (ticks == 0) {
@


1.17
log
@deprecate use of sys/lock.h and replace it with sys/atomic.h or
machine/lock.h as appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.16 2014/07/20 02:48:59 guenther Exp $	*/
a45 6

int
rw_cas_486(volatile unsigned long *p, unsigned long o, unsigned long n)
{
	return (i486_atomic_cas_int((u_int *)p, o, n) != o);
}
@


1.16
log
@This pulls in <ddb/db_output.h>, so don't redeclare ddb functions
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.15 2014/07/10 12:14:48 mlarkin Exp $	*/
a38 1
#include <sys/lock.h>
@


1.15
log
@

fix some errors in lockdebug code. not enabled by default.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.14 2014/03/14 03:01:38 dlg Exp $	*/
a66 4

extern void Debugger(void);
extern int db_printf(const char *, ...)
    __attribute__((__format__(__kprintf__,1,2)));
@


1.14
log
@rework mplocks to use tickets instead of spinning. this provides
fairer access to the kernel lock between logical cpus, especially
in multi socket systems.

i first wrote this diff in 2011.

ok n2k14 for post 5.5 (deraadt@@ and kettenis@@ in particular)
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.13 2013/12/05 01:28:45 uebayasi Exp $	*/
d100 1
a100 1
		db_printf("__mp_lock(0x%x): lock spun out", mpl);
d127 1
a127 1
	if (mpl->mpl_cpu != curcpu()) {
@


1.13
log
@Correct spin timeout detection in __mp_lock debug code.

OK pirofti@@ krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
a56 1
__mp_lock_init(struct __mp_lock *lock)
d58 3
a60 2
	lock->mpl_cpu = NULL;
	lock->mpl_count = 0;
d76 11
d88 1
a88 1
__mp_lock_spin(struct __mp_lock *mpl)
d91 1
a91 1
	while (mpl->mpl_count != 0)
d96 1
a96 1
	while (mpl->mpl_count != 0 && --ticks > 0)
d109 7
a115 26
	/*
	 * Please notice that mpl_count gets incremented twice for the
	 * first lock. This is on purpose. The way we release the lock
	 * in mp_unlock is to decrement the mpl_count and then check if
	 * the lock should be released. Since mpl_count is what we're
	 * spinning on, decrementing it in mpl_unlock to 0 means that
	 * we can't clear mpl_cpu, because we're no longer holding the
	 * lock. In theory mpl_cpu doesn't need to be cleared, but it's
	 * safer to clear it and besides, setting mpl_count to 2 on the
	 * first lock makes most of this code much simpler.
	 */

	while (1) {
		int ef = read_eflags();

		disable_intr();
		if (i486_atomic_cas_int(&mpl->mpl_count, 0, 1) == 0) {
			mpl->mpl_cpu = curcpu();
		}

		if (mpl->mpl_cpu == curcpu()) {
			mpl->mpl_count++;
			write_eflags(ef);
			break;
		}
		write_eflags(ef);
d117 1
a117 2
		__mp_lock_spin(mpl);
	}
d123 1
d133 3
a135 5
	disable_intr();	
	if (--mpl->mpl_count == 1) {
		mpl->mpl_cpu = NULL;
		mpl->mpl_count = 0;
	}
d142 1
a142 1
	int rv = mpl->mpl_count - 1;
d144 1
a144 7

#ifdef MP_LOCKDEBUG
	if (mpl->mpl_cpu != curcpu()) {
		db_printf("__mp_release_all(%p): not held lock\n", mpl);
		Debugger();
	}
#endif
d147 3
a149 2
	mpl->mpl_cpu = NULL;
	mpl->mpl_count = 0;
d158 2
a159 1
	int rv = mpl->mpl_count - 2;
d161 1
a161 8
#ifdef MP_LOCKDEBUG
	if (mpl->mpl_cpu != curcpu()) {
		db_printf("__mp_release_all_but_one(%p): not held lock\n", mpl);
		Debugger();
	}
#endif

	mpl->mpl_count = 2;
d176 3
a178 1
	return mpl->mpl_cpu == curcpu();
@


1.12
log
@remove unused cpu_lock code (where it is truly unused). it is not
part of the future we have planned. middling ok from a few
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.11 2012/12/05 23:20:12 deraadt Exp $	*/
d84 1
a84 1
	while (mpl->mpl_count != 0 && ticks-- > 0)
@


1.11
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.10 2008/06/26 05:42:10 ray Exp $	*/
a46 54

#ifdef LOCKDEBUG

void
__cpu_simple_lock_init(__cpu_simple_lock_t *lockp)
{
	*lockp = __SIMPLELOCK_UNLOCKED;
}

#if defined (DEBUG) && defined(DDB)
int spin_limit = 10000000;
#endif

void
__cpu_simple_lock(__cpu_simple_lock_t *lockp)
{
#if defined (DEBUG) && defined(DDB)	
	int spincount = 0;
#endif
	
	while (i386_atomic_testset_i(lockp, __SIMPLELOCK_LOCKED)
	    == __SIMPLELOCK_LOCKED) {
#if defined(DEBUG) && defined(DDB)
		spincount++;
		if (spincount == spin_limit) {
			extern int db_active;
			db_printf("spundry\n");
			if (db_active) {
				db_printf("but already in debugger\n");
			} else {
				Debugger();
			}
		}
#endif
	}
}

int
__cpu_simple_lock_try(__cpu_simple_lock_t *lockp)
{

	if (i386_atomic_testset_i(lockp, __SIMPLELOCK_LOCKED)
	    == __SIMPLELOCK_UNLOCKED)
		return (1);
	return (0);
}

void
__cpu_simple_unlock(__cpu_simple_lock_t *lockp)
{
	*lockp = __SIMPLELOCK_UNLOCKED;
}

#endif
@


1.10
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.9 2007/11/27 15:56:11 art Exp $	*/
a32 2

#include <sys/cdefs.h>			/* RCS ID & Copyright macro defns */
@


1.9
log
@ARGH. Work has poisoned my mind. KNF the braces.
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.8 2007/11/26 19:00:56 art Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.8
log
@Ooops. The perils of hacking in three different trees.
Make this compile on !MULTIPROCESSOR
noticed by jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.7 2007/11/26 17:15:29 art Exp $	*/
d212 2
a213 1
__mp_release_all(struct __mp_lock *mpl) {
d233 2
a234 1
__mp_release_all_but_one(struct __mp_lock *mpl) {
d250 2
a251 1
__mp_acquire_count(struct __mp_lock *mpl, int count) {
d257 2
a258 1
__mp_lock_held(struct __mp_lock *mpl) {
@


1.7
log
@Move the implementation of __mp_lock (biglock) into machine dependent
code. At this moment all architectures get the copy of the old code
except i386 which gets a new shiny implementation that doesn't spin
at splhigh (doh!) and doesn't try to grab the biglock when releasing
the biglock (double doh!).

Shaves 10% of system time during kernel compile and might solve a few
bugs as a bonus.

Other architectures coming shortly.

miod@@ deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.6 2007/05/29 18:18:20 tom Exp $	*/
d117 1
d258 1
@


1.6
log
@Remove support for 80386 processors.  Apologies if you have one of
the rare 80386-bases system with enough memory, a 387 FPU, a useable
disk subsystem, and the patience to wait for it to unpack the
distribution .tgz files.

approval from art@@ and many others (esp. nick@@); ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.5 2007/05/25 15:55:26 art Exp $	*/
d116 141
@


1.5
log
@Replace the overdesigned and overcomplicated tlb shootdown code with
very simple and dumb fast tlb IPI handlers that have in the order of
the same amount of instructions as the old code had function calls.

All TLB shootdowns are reorganized so that we always shoot the,
without looking at PG_U and when we're shooting a range (primarily in
pmap_remove), we shoot the range when there are 32 or less pages in
it, otherwise we just nuke the whole TLB (this might need tweaking if
someone is interested in micro-optimization). The IPIs are not handled
through the normal interrupt vectoring code, they are not blockable
and they only shoot one page or a range of pages or the whole tlb.

This gives a 15% reduction in system time on my dual-core laptop
during a kernel compile and an 18% reduction in real time on a quad
machine doing bulk ports build.

Tested by many, in snaps for a week, no slowdowns reported (although not
everyone is seeing such huge wins).
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.4 2007/05/04 12:58:41 art Exp $	*/
a109 34

int rw_cas_386(volatile unsigned long *,  unsigned long, unsigned long);
int rw_cas_486(volatile unsigned long *,  unsigned long, unsigned long);
int rw_cas_choose(volatile unsigned long *,  unsigned long, unsigned long);

int (*rw_cas_p)(volatile unsigned long *, unsigned long, unsigned long)
    = rw_cas_choose;

int
rw_cas_choose(volatile unsigned long *p, unsigned long o, unsigned long n)
{
	if (cpu_class == CPUCLASS_386)
		rw_cas_p = rw_cas_386;
	else
		rw_cas_p = rw_cas_486;

	return (*rw_cas_p)(p, o, n);
}

int
rw_cas_386(volatile unsigned long *p, unsigned long o, unsigned long n)
{
	u_int ef = read_eflags();

	disable_intr();
	if (*p != o) {
		write_eflags(ef);
		return (1);
	}
	*p = n;
	write_eflags(ef);

	return (0);
}
@


1.4
log
@Implement rw_cas for i386.

It uses a function pointer to choose between the 386 and 486 versions.
The 386 version is not MP safe, but we're not expecting MP support
for 386 cpus.

miod@@ ok (and prodding)
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.3 2006/09/19 11:06:33 jsg Exp $	*/
a144 6
#ifdef MULTIPROCESSOR
#define MPLOCK "lock "
#else
#define MPLOCK
#endif

d148 1
a148 6
	int res;

        __asm volatile(MPLOCK " cmpxchgl %2, %1" : "=a" (res), "=m" (*p)
             : "r" (n), "a" (o), "m" (*p) : "memory");

	return (res != o);
@


1.3
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.2 2004/06/13 21:49:15 niklas Exp $	*/
d53 1
d110 51
@


1.2
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 1
a59 2
__cpu_simple_lock_init(lockp)
	__cpu_simple_lock_t *lockp;
d69 1
a69 2
__cpu_simple_lock(lockp)
	__cpu_simple_lock_t *lockp;
d93 1
a93 2
__cpu_simple_lock_try(lockp)
	__cpu_simple_lock_t *lockp;
d103 1
a103 2
__cpu_simple_unlock(lockp)
	__cpu_simple_lock_t *lockp;
@


1.1
log
@file lock_machdep.c was initially added on branch SMP.
@
text
@d1 112
@


1.1.2.1
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@a0 111
/* $NetBSD: lock_machdep.c,v 1.1.2.3 2000/05/03 14:40:30 sommerfeld Exp $ */

/*-
 * Copyright (c) 1998, 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/cdefs.h>			/* RCS ID & Copyright macro defns */

/*
 * Machine-dependent spin lock operations.
 */

#include <sys/types.h>
#include <sys/lock.h>
#include <sys/systm.h>

#include <machine/atomic.h>
#include <machine/lock.h>

#include <ddb/db_output.h>

#ifdef LOCKDEBUG

void
__cpu_simple_lock_init(lockp)
	__cpu_simple_lock_t *lockp;
{
	*lockp = __SIMPLELOCK_UNLOCKED;
}

#if defined (DEBUG) && defined(DDB)
int spin_limit = 10000000;
#endif

void
__cpu_simple_lock(lockp)
	__cpu_simple_lock_t *lockp;
{
#if defined (DEBUG) && defined(DDB)	
	int spincount = 0;
#endif
	
	while (i386_atomic_testset_i(lockp, __SIMPLELOCK_LOCKED)
	    == __SIMPLELOCK_LOCKED) {
#if defined(DEBUG) && defined(DDB)
		spincount++;
		if (spincount == spin_limit) {
			extern int db_active;
			db_printf("spundry\n");
			if (db_active) {
				db_printf("but already in debugger\n");
			} else {
				Debugger();
			}
		}
#endif
	}
}

int
__cpu_simple_lock_try(lockp)
	__cpu_simple_lock_t *lockp;
{

	if (i386_atomic_testset_i(lockp, __SIMPLELOCK_LOCKED)
	    == __SIMPLELOCK_UNLOCKED)
		return (1);
	return (0);
}

void
__cpu_simple_unlock(lockp)
	__cpu_simple_lock_t *lockp;
{
	*lockp = __SIMPLELOCK_UNLOCKED;
}

#endif
@


1.1.2.2
log
@Add $OpenBSD$.
@
text
@a0 1
/*	$OpenBSD$	*/
@


1.1.2.3
log
@Go back to defining simplelocks as noops, even if MULTIPROCESSOR.  Instead use
a new real simple recursive-lock capable lock implementation for the few
necessary locks (kernel, scheduler, tlb shootdown, printf and ddb MP).
This because we cannot trust the old fine-grained locks spread out all over
our kernel, and not really tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: lock_machdep.c,v 1.1.2.2 2001/07/15 15:10:55 ho Exp $	*/
d47 1
a47 1
#include <sys/param.h>
@


