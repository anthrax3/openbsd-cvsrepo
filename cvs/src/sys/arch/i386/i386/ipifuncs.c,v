head	1.29;
access;
symbols
	OPENBSD_6_0:1.27.0.6
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.21.0.2
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.20.0.2
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.19.0.8
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.6
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	UBC_SYNC_A:1.1
	UBC_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.29
date	2016.10.21.16.57.53;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	lP5juDN56Vyfk2iG;

1.28
date	2016.10.21.06.20.58;	author mlarkin;	state Exp;
branches;
next	1.27;
commitid	szRuKZ9HgqvwYLcM;

1.27
date	2015.07.19.18.53.49;	author sf;	state Exp;
branches;
next	1.26;
commitid	Hi0HvjMg10KWPunS;

1.26
date	2015.07.18.19.21.03;	author sf;	state Exp;
branches;
next	1.25;
commitid	fKIY1z4O2YV68kXY;

1.25
date	2015.01.27.20.50.46;	author sf;	state Exp;
branches;
next	1.24;
commitid	MtXYKH4rRNF7LJUA;

1.24
date	2014.07.11.10.56.52;	author mlarkin;	state Exp;
branches;
next	1.23;
commitid	coKdWuxXuBFryssI;

1.23
date	2014.01.24.21.20.23;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2013.12.19.21.30.02;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2013.03.20.21.23.05;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2012.12.05.23.20.12;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2010.10.02.23.14.33;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.21.14.08.09;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.26.15.56.40;	author mlarkin;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.07.06.33.06;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.01.19.48.50;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.29.17.11.30;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.18.20.20.35;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2008.04.13.16.11.28;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2008.04.12.09.46.06;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.07.08.37.38;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.25.15.55.26;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2007.04.21.21.06.14;	author gwk;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.29.09.54.16;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.11.13.21.11;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.10.21.09.22;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.16.18.24.23;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.14.10.02.25;	author ho;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.07.14.10.02.26;	author ho;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.07.15.15.10.54;	author ho;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.04.04.15.02.03;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.04.06.14.03.58;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2003.04.15.03.56.20;	author niklas;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2003.05.17.16.07.37;	author andreas;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2004.02.20.22.19.55;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Fix MP builds including vmm
ok mlarkin
@
text
@/*	$OpenBSD: ipifuncs.c,v 1.28 2016/10/21 06:20:58 mlarkin Exp $	*/
/* $NetBSD: ipifuncs.c,v 1.1.2.3 2000/06/26 02:04:06 sommerfeld Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Interprocessor interrupt handlers.
 */

#include "npx.h"
#include "vmm.h"

#include <sys/param.h>
#include <sys/device.h>
#include <sys/memrange.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <machine/cpufunc.h>
#include <machine/cpuvar.h>
#include <machine/intr.h>
#include <machine/atomic.h>
#include <machine/i82093var.h>
#include <machine/db_machdep.h>
#include <machine/mplock.h>
#include <machine/vmmvar.h>

void i386_ipi_nop(struct cpu_info *);
void i386_ipi_halt(struct cpu_info *);

#if NNPX > 0
void i386_ipi_synch_fpu(struct cpu_info *);
void i386_ipi_flush_fpu(struct cpu_info *);
#else
#define i386_ipi_synch_fpu NULL
#define i386_ipi_flush_fpu NULL
#endif

#ifdef MTRR
void i386_ipi_reload_mtrr(struct cpu_info *);
#else
#define i386_ipi_reload_mtrr 0
#endif

#if NVMM > 0
void i386_ipi_start_vmm(struct cpu_info *);
void i386_ipi_stop_vmm(struct cpu_info *);
#endif /* NVMM > 0 */

void (*ipifunc[I386_NIPI])(struct cpu_info *) =
{
	i386_ipi_halt,
	i386_ipi_nop,
	i386_ipi_flush_fpu,
	i386_ipi_synch_fpu,
	i386_ipi_reload_mtrr,
#if 0
	gdt_reload_cpu,
#else
	NULL,
#endif
#ifdef DDB
	i386_ipi_db,
#else
	NULL,
#endif
	i386_setperf_ipi,
#if NVMM > 0
	i386_ipi_start_vmm,
	i386_ipi_stop_vmm,
#else
	NULL,
	NULL,
#endif /* NVMM > 0 */
};

void
i386_ipi_nop(struct cpu_info *ci)
{
}

void
i386_ipi_halt(struct cpu_info *ci)
{
	SCHED_ASSERT_UNLOCKED();
	KASSERT(!__mp_lock_held(&kernel_lock));

	npxsave_cpu(ci, 1);
	disable_intr();
	lapic_disable();
	wbinvd();
	ci->ci_flags &= ~CPUF_RUNNING;
	wbinvd();

	for(;;) {
		asm volatile("hlt");
	}
}

#if NNPX > 0
void
i386_ipi_flush_fpu(struct cpu_info *ci)
{
	if (ci->ci_fpsaveproc == ci->ci_fpcurproc)
		npxsave_cpu(ci, 0);
}

void
i386_ipi_synch_fpu(struct cpu_info *ci)
{
	if (ci->ci_fpsaveproc == ci->ci_fpcurproc)
		npxsave_cpu(ci, 1);
}
#endif

#ifdef MTRR
void
i386_ipi_reload_mtrr(struct cpu_info *ci)
{
	if (mem_range_softc.mr_op != NULL)
		mem_range_softc.mr_op->reload(&mem_range_softc);
}
#endif

void
i386_spurious(void)
{
	printf("spurious intr\n");
}

void
i386_send_ipi(struct cpu_info *ci, int ipimask)
{
	i386_atomic_setbits_l(&ci->ci_ipis, ipimask);

	/* Don't send IPI to cpu which isn't (yet) running. */
	if (!(ci->ci_flags & CPUF_RUNNING))
		return;

	i386_ipi(LAPIC_IPI_VECTOR, ci->ci_apicid, LAPIC_DLMODE_FIXED);

	return;
}

int
i386_fast_ipi(struct cpu_info *ci, int ipi)
{
	if (!(ci->ci_flags & CPUF_RUNNING))
		return (ENOENT);

	i386_ipi(ipi, ci->ci_apicid, LAPIC_DLMODE_FIXED);

	return 0;
}

void
i386_broadcast_ipi(int ipimask)
{
	struct cpu_info *ci, *self = curcpu();
	CPU_INFO_ITERATOR cii;
	int count = 0;

	CPU_INFO_FOREACH(cii, ci) {
		if (ci == self)
			continue;
		if ((ci->ci_flags & CPUF_RUNNING) == 0)
			continue;
		i386_atomic_setbits_l(&ci->ci_ipis, ipimask);
		count++;
	}
	if (!count)
		return;

	i386_ipi(LAPIC_IPI_VECTOR, LAPIC_DEST_ALLEXCL, LAPIC_DLMODE_FIXED); 
}

void
i386_ipi_handler(void)
{
	extern struct evcount ipi_count;
	struct cpu_info *ci = curcpu();
	u_int32_t pending;
	int bit;

	pending = i386_atomic_testset_ul(&ci->ci_ipis, 0);

	for (bit = 0; bit < I386_NIPI && pending; bit++) {
		if (pending & (1<<bit)) {
			pending &= ~(1<<bit);
			(*ipifunc[bit])(ci);
			ipi_count.ec_count++;
		}
	}
}

#if NVMM > 0
void
i386_ipi_start_vmm(struct cpu_info *ci)
{
	start_vmm_on_cpu(ci);
}

void
i386_ipi_stop_vmm(struct cpu_info *ci)
{
	stop_vmm_on_cpu(ci);
}
#endif /* NVMM > 0 */

@


1.28
log
@
vmm(4) for i386. Userland changes forthcoming. Note that for the time being,
i386 hosts are limited to running only i386 guests, even if the underlying
hardware supports amd64. This is a restriction I hope to lift moving forward,
but for now please don't report problems running amd64 guests on i386 hosts.

This was a straightforward port of the in-tree amd64 code plus the old rotted
tree I had from last year for i386 support. Changes included converting 64-bit
VMREAD/VMWRITE ops to 2x32-bit ops, and fixing treatment of the TSS, which
differs on i386.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.27 2015/07/19 18:53:49 sf Exp $	*/
d56 1
@


1.27
log
@Make i386_send_ipi() return void

Nobody uses its return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.26 2015/07/18 19:21:03 sf Exp $	*/
d40 1
d74 5
d97 7
d224 15
@


1.26
log
@Make {x86,i82489,x2apic,i386}_ipi return void

They always returned 0

ok mlarkin@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.25 2015/01/27 20:50:46 sf Exp $	*/
d147 1
a147 1
int
d154 1
a154 1
		return ENOENT;
d158 1
a158 1
	return 0;
@


1.25
log
@tedu x86_self_ipi()/i386_self_ipi()

They are not used anywhere.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.24 2014/07/11 10:56:52 mlarkin Exp $	*/
a149 2
	int ret;

d156 1
a156 5
	ret = i386_ipi(LAPIC_IPI_VECTOR, ci->ci_apicid, LAPIC_DLMODE_FIXED);
	if (ret != 0) {
		printf("ipi of %x from %s to %s failed\n",
		    ipimask, curcpu()->ci_dev.dv_xname, ci->ci_dev.dv_xname);
	}
d158 1
a158 1
	return ret;
d167 3
a169 1
	return (i386_ipi(ipi, ci->ci_apicid, LAPIC_DLMODE_FIXED));
@


1.24
log
@

Don't hold the kernel lock while halting a processor. Assert if we detect
this happening.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.23 2014/01/24 21:20:23 kettenis Exp $	*/
a174 8

void
i386_self_ipi(int vector)
{
	i82489_writereg(LAPIC_ICRLO,
	    vector | LAPIC_DLMODE_FIXED | LAPIC_LVL_ASSERT | LAPIC_DEST_SELF);
}

@


1.23
log
@Disable lapic when halting CPUs.  Allegedly this is necessary to make
suspend work on some machines.

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.22 2013/12/19 21:30:02 deraadt Exp $	*/
d54 1
d102 2
@


1.22
log
@Mtrr stops being a pseudo-device.  We need to probe the cpu type and
initialize the structures when we see the first cpu.  We also need to
initialize each cpu's properly (for PAT) before we setup mtrr on that
cpu.  On i386 (late hatch) we were getting this desperately wrong on
the primary cpu.

After suspend/resume, we also need to do the same work.  re-initialize
PAT before mtrr.  On some laptops apparently PAT was not turned on by the
BIOS, so we ended up with incorrect setup for the primary cpu.  Oops.

This makes mplayer on the x201 (and similar) machines work without weird
pauses after a suspend/resume.  Many other things are likely fixed.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.21 2013/03/20 21:23:05 kettenis Exp $	*/
d103 1
@


1.21
log
@Previous commit to acpi_machdep.c broke suspend because the IPI to save the
FPU state needs a little bit more setup.  Fix things properly this time by
simplifying matters and saving the FPU state from the IPI that halts the
CPU.  With help from deraadt@@ and mlarkin@@.

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.20 2012/12/05 23:20:12 deraadt Exp $	*/
a38 1
#include "mtrr.h"
d66 1
a66 1
#if NMTRR > 0
d128 1
a128 1
#if NMTRR > 0
@


1.20
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.19 2010/10/02 23:14:33 deraadt Exp $	*/
d102 1
@


1.19
log
@Ensure the caches are wbinvd'd before we say that the cpu is not running
anymore.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.18 2010/07/21 14:08:09 kettenis Exp $	*/
a33 2

#include <sys/cdefs.h>			/* RCS ID & Copyright macro defns */
@


1.18
log
@Make sure that the FPU IPIs shoot down the right FPU context and not the FPU
context of some random process that happened to be switched onto the FPU
after the decision was made to send the IPI.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.17 2010/06/26 15:56:40 mlarkin Exp $	*/
d105 1
@


1.17
log
@

Don't try to halt an AP if holding sched_lock since that causes hangs
on resume. Fail early if this is detected, so that we have a chance to
catch it.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.16 2010/04/07 06:33:06 kettenis Exp $	*/
d117 2
a118 1
	npxsave_cpu(ci, 0);
d124 2
a125 1
	npxsave_cpu(ci, 1);
@


1.16
log
@Make suspend/resume work on MP machines (running an MP kernel).  Joint work
from mlarkin@@ and me, with some amd64 fixes thrown in by deraadt@@

ok marco@@, deraadt@@, pirofti@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.15 2010/04/01 19:48:50 kettenis Exp $	*/
d103 1
@


1.15
log
@Don't index cpu_info by apic id, but by device unit number instead.  Recent
Intel CPUs come up with apic id's >= 32, even on systems with less than 32
logical CPUs.

ok krw@@, marco@@; tested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.14 2009/11/29 17:11:30 kettenis Exp $	*/
d105 1
@


1.14
log
@Reload mtrr state on all CPUs after updates.  Seems to speed up X on MP
systems, at least with Intel graphics.

ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.13 2008/06/26 05:42:10 ray Exp $	*/
d151 1
a151 1
	ret = i386_ipi(LAPIC_IPI_VECTOR, ci->ci_cpuid, LAPIC_DLMODE_FIXED);
d166 1
a166 1
	return (i386_ipi(ipi, ci->ci_cpuid, LAPIC_DLMODE_FIXED));
@


1.13
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.12 2008/04/18 20:20:35 kettenis Exp $	*/
a34 1

d41 1
d46 1
d49 2
d58 1
a58 2
#include <uvm/uvm_extern.h>

d65 2
a66 2
#define i386_ipi_synch_fpu 0
#define i386_ipi_flush_fpu 0
d69 5
a73 1
void i386_ipi_nop(struct cpu_info *);
d81 1
a82 1
	i386_reload_mtrr,
d85 1
a85 2
	0,
	0,
d90 1
a90 1
	0,
d122 9
@


1.12
log
@Now that i386 has a per-process astpending, we can garbage collect ipi_ast
and do an ipi_nop cross-call from signotify() instead.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.11 2008/04/13 16:11:28 kettenis Exp $	*/
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.11
log
@lear CPUF_RUNNING when halting a CPU.  Fixes problems with powering dowm
MP amd64 systems for quite a few people.

ok deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.10 2008/04/12 09:46:06 kettenis Exp $	*/
d74 2
d79 1
d96 5
@


1.10
log
@There are so many reasons why a printf in an ipi is a very bad idea.
Especially since it doesn't add anything but spam during reboot.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.9 2007/09/07 08:37:38 art Exp $	*/
d98 1
@


1.9
log
@Remove some left-overs from the TSC based microtime. We don't need
to synchronize the tsc between CPUs anymore. While here, also remove
the slow TLB IPI since it's been dead for a while.

noticed by mickey
toby@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.8 2007/05/25 15:55:26 art Exp $	*/
a98 1
	printf("%s: shutting down\n", ci->ci_dev.dv_xname);
@


1.8
log
@Replace the overdesigned and overcomplicated tlb shootdown code with
very simple and dumb fast tlb IPI handlers that have in the order of
the same amount of instructions as the old code had function calls.

All TLB shootdowns are reorganized so that we always shoot the,
without looking at PG_U and when we're shooting a range (primarily in
pmap_remove), we shoot the range when there are 32 or less pages in
it, otherwise we just nuke the whole TLB (this might need tweaking if
someone is interested in micro-optimization). The IPIs are not handled
through the normal interrupt vectoring code, they are not blockable
and they only shoot one page or a range of pages or the whole tlb.

This gives a 15% reduction in system time on my dual-core laptop
during a kernel compile and an 18% reduction in real time on a quad
machine doing bulk ports build.

Tested by many, in snaps for a week, no slowdowns reported (although not
everyone is seeing such huge wins).
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.7 2007/04/21 21:06:14 gwk Exp $	*/
a76 1
	i386_ipi_microset,
a78 1
	NULL,
@


1.7
log
@Introduce a smp aware hw.setperf mechanism, it will scale all CPUs or
cores by the same amount, i.e. if you do hw.setperf=50 both cores will
be scaled to the opearting state corresponing to 50%. Tested by many with
est (mainly on core2duo machines like X60 thinkpads). Only enable est
during GENERIC.MP build no one tested powernow.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.6 2006/05/29 09:54:16 mickey Exp $	*/
d80 1
a80 1
	pmap_do_tlb_shootdown,
d145 9
@


1.6
log
@implement reliable microtime on smp (joint work w/ otto):
send a bcast ipi from the cpu0 to all others to timestamp tsc
on every clock intr. this way using local tsc provides accurate
microtime() measurements. thus gettimeofday test passes now.
otto@@ deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.5 2006/05/11 13:21:11 mickey Exp $	*/
d93 1
d173 1
a173 1
	i386_ipi(LAPIC_IPI_VECTOR, LAPIC_DEST_ALLEXCL, LAPIC_DLMODE_FIXED);   
@


1.5
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.4 2006/03/10 21:09:22 mickey Exp $	*/
d77 1
a77 5
#if 0 && (defined(I586_CPU) || defined(I686_CPU))
	cc_microset,
#else
	0,
#endif
d157 16
a172 1
	panic("broadcast_ipi not implemented");
@


1.4
log
@provide a counter for ipis
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.3 2004/06/16 18:24:23 grange Exp $	*/
d74 1
a74 1
void (*ipifunc[I386_NIPI])(struct cpu_info *) = 
@


1.3
log
@Use i386_ipi_db only with DDB

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.2 2004/06/13 21:49:15 niklas Exp $	*/
d167 1
d178 1
@


1.2
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d92 1
d94 3
@


1.1
log
@file ipifuncs.c was initially added on branch SMP.
@
text
@d1 175
@


1.1.2.1
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@a0 180
/* $NetBSD: ipifuncs.c,v 1.1.2.3 2000/06/26 02:04:06 sommerfeld Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


#include <sys/cdefs.h>			/* RCS ID & Copyright macro defns */

/*
 * Interprocessor interrupt handlers.
 */

#include "npx.h"

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>

#include <vm/vm.h>

#include <machine/intr.h>
#include <machine/atomic.h>
#include <machine/cpuvar.h>
#include <machine/i82093var.h>

void i386_ipi_halt(void);
void i386_ipi_fpsave(void);

#if 0
void i386_ipi_gmtb(void);
void i386_ipi_nychi(void);
#endif

void (*ipifunc[I386_NIPI])(void) = 
{
	i386_ipi_halt,
#if 0 /* XXX */
	pmap_do_tlb_shootdown,
#else
	0,
#endif
#if NNPX > 0
	i386_ipi_fpsave,
#else
	0,
#endif
	0,
	0,
	0,
};

void
i386_ipi_halt(void)
{
	struct cpu_info *ci = curcpu();

	disable_intr();

	printf("%s: shutting down\n", ci->ci_dev.dv_xname);
	for(;;) {
		asm volatile("hlt");
	}
}

#if NNPX > 0
void
i386_ipi_fpsave(void)
{
	struct cpu_info *ci = curcpu();
	
	npxsave_cpu(ci);
}
#endif

#if 0
void
i386_ipi_gmtb(void)
{
#if 0
	struct cpu_info *ci = curcpu();
	printf("%s: we were asked for the brain.\n", ci->ci_dev.dv_xname);
#endif
	i386_send_ipi(1, I386_IPI_NYCHI);
}

void
i386_ipi_nychi(void)
{
#if 0
	struct cpu_info *ci = curcpu();
	printf("%s: we were asked for the brain.\n", ci->ci_dev.dv_xname);
#endif
}
#endif

void
i386_spurious (void)
{
	printf("spurious intr\n");
}

void
i386_send_ipi (struct cpu_info *ci, int ipimask)
{
	i386_atomic_setbits_l(&ci->ci_ipis, ipimask);
	i386_ipi(LAPIC_IPI_VECTOR, ci->ci_cpuid, LAPIC_DLMODE_FIXED);
}

void
i386_self_ipi (int vector)
{
	i82489_writereg(LAPIC_ICRLO,
	    vector | LAPIC_DLMODE_FIXED | LAPIC_LVL_ASSERT | LAPIC_DEST_SELF);
}


void
i386_broadcast_ipi (int ipimask)
{
	panic("broadcast_ipi not implemented");
}

void
i386_ipi_handler(void)
{
	struct cpu_info *ci = curcpu();
	u_int32_t pending;
	int bit;

	pending = i386_atomic_testset_ul(&ci->ci_ipis, 0);
#if 0
	printf("%s: pending IPIs: %x\n", ci->ci_dev.dv_xname, pending);
#endif

	for (bit = 0; bit < I386_NIPI && pending; bit++) {
		if (pending & (1<<bit)) {
			pending &= ~(1<<bit);
			(*ipifunc[bit])();
		}
	}
	
#if 0
	Debugger();
#endif
}
@


1.1.2.2
log
@Add $OpenBSD$.
@
text
@a0 1
/*	$OpenBSD$	*/
@


1.1.2.3
log
@Merge in -current
@
text
@d55 2
a56 2
#include <machine/cpufunc.h>
#include <machine/cpuvar.h>
d59 1
@


1.1.2.4
log
@Fixed IPI with boot processor, the cpu_info aray handling must be redone.
Debug IPIs going back and forth to the boot processor when a 2ary CPU starts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.1.2.3 2001/11/13 21:00:51 niklas Exp $	*/
d63 2
d67 1
d83 2
a84 2
	i386_ipi_gmtb,
	i386_ipi_nychi,
d110 1
d114 1
a114 1
	extern struct cpu_info *first_app_cpu;
a115 1

d117 2
a118 1
	i386_send_ipi(first_app_cpu, I386_IPI_NYCHI);
d124 1
a125 1

d127 1
d129 1
d132 1
a132 1
i386_spurious(void)
d138 1
a138 1
i386_send_ipi(struct cpu_info *ci, int ipimask)
d145 1
a145 1
i386_self_ipi(int vector)
d153 1
a153 1
i386_broadcast_ipi(int ipimask)
d166 1
d168 1
@


1.1.2.5
log
@Errorchecks in IPI sending
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.1.2.4 2003/04/04 15:02:03 niklas Exp $	*/
d131 1
a131 1
int
a133 2
	int ret;

d135 1
a135 14

	/* Don't send IPI to cpu which isn't (yet) running. */
	if (!(ci->ci_flags & CPUF_RUNNING))
		return ENOENT;

printf("send ipi %x from %s to %s\n", ipimask, curcpu()->ci_dev.dv_xname,
    ci->ci_dev.dv_xname);
	ret = i386_ipi(LAPIC_IPI_VECTOR, ci->ci_cpuid, LAPIC_DLMODE_FIXED);
	if (ret != 0) {
		printf("ipi of %x from %s to %s failed\n",
		    ipimask, curcpu()->ci_dev.dv_xname, ci->ci_dev.dv_xname);
	}

	return ret;
@


1.1.2.6
log
@Enable TLB shootdown, remove debugging code
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.1.2.6 2003/04/14 14:02:49 niklas Exp $	*/
a60 2
#include <uvm/uvm_extern.h>

d69 1
d71 3
d80 2
a81 2
	0,
	0,
d108 18
d142 2
d175 1
d183 4
@


1.1.2.7
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.1.2.6 2003/04/15 03:56:20 niklas Exp $	*/
d65 2
@


1.1.2.8
log
@Some i386-specific stuff:
Stop other CPUs when entering ddb
'machine sysregs' shows system registers not usually used by applications
'machine cpuinfo' shows the status of the processors
'machine startcpu n' starts CPU n
'machine stopcpu n' stops CPU n
'machine ddbcpu n' transfers ddb control to CPU n (not very useful yet
though since the second processor can't use the keyboard...)

Niklas said that I should test this first to at least make sure it
compiles, but I'm too anxious to do my first commit. :)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipifuncs.c,v 1.1.2.7 2003/05/15 04:08:02 niklas Exp $	*/
a59 1
#include <machine/db_machdep.h>
a77 1
	i386_ipi_db,
@


1.1.2.9
log
@Import NetBSD updates to NPX logic, and IPI API
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d64 2
a65 1
void i386_ipi_halt(struct cpu_info *);
d67 1
a67 9
#if NNPX > 0
void i386_ipi_synch_fpu(struct cpu_info *);
void i386_ipi_flush_fpu(struct cpu_info *);
#else
#define i386_ipi_synch_fpu 0
#define i386_ipi_flush_fpu 0
#endif

void (*ipifunc[I386_NIPI])(struct cpu_info *) = 
d70 3
a72 2
#if 0 && (defined(I586_CPU) || defined(I686_CPU))
	cc_microset,
a75 7
	i386_ipi_flush_fpu,
	i386_ipi_synch_fpu,
	pmap_do_tlb_shootdown,
#if 0
	i386_reload_mtrr,
	gdt_reload_cpu,
#else
d78 1
a78 1
#endif
d83 1
a83 1
i386_ipi_halt(struct cpu_info *ci)
d85 2
d97 1
a97 1
i386_ipi_flush_fpu(struct cpu_info *ci)
d99 3
a101 7
	npxsave_cpu(ci, 0);
}

void
i386_ipi_synch_fpu(struct cpu_info *ci)
{
	npxsave_cpu(ci, 1);
d157 1
a157 1
			(*ipifunc[bit])(ci);
@


