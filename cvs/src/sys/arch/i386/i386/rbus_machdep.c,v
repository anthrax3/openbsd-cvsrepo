head	1.27;
access;
symbols
	OPENBSD_6_2:1.27.0.30
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.28
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.24
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.20
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.22
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.14
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.27.0.18
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.16
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.12
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.10
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.8
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.6
	OPENBSD_5_0:1.27.0.4
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.23.0.4
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.6
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.15.0.8
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.6
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.13.0.4
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.15
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_9_BASE:1.7
	SMP:1.7.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.27
date	2010.09.22.02.28.37;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2010.01.13.09.10.33;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2009.05.15.21.47.40;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2009.04.28.18.37.13;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2008.07.07.23.41.58;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2008.07.02.03.00.00;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	2007.12.09.16.53.36;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.12.13.56.40;	author chl;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.01.15.14.44;	author martin;	state Exp;
branches;
next	1.18;

1.18
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.09.00.41.27;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.04.17.06.33;	author grange;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.23.17.53.24;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.13.19.59.01;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.06.01.43.48;	author art;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.22.21.01.24;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.08.08.08.53;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.05.23.25.40;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.01.03.15.43;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.25.01.00.52;	author mickey;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.01.24.23.40.25;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.21.14.23.33;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.31.18.56.40;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.06.17.44.35;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.05.17.55.54;	author nate;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.08.05.50.50;	author aaron;	state Exp;
branches;
next	;

1.7.2.1
date	2001.04.18.16.07.23;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.16.42;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2004.06.05.23.09.00;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2002.10.29.00.28.04;	author art;	state Exp;
branches;
next	;


desc
@@


1.27
log
@remove unused offset argument to rbus functions
ok krw@@ kettenis@@
@
text
@/*	$OpenBSD: rbus_machdep.c,v 1.26 2010/01/13 09:10:33 jsg Exp $ */
/*	$NetBSD: rbus_machdep.c,v 1.2 1999/10/15 06:43:06 haya Exp $	*/

/*
 * Copyright (c) 1999
 *     HAYAKAWA Koichi.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/extent.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <dev/cardbus/rbus.h>

#include <dev/pci/pcivar.h>

#ifndef RBUS_MEM_START
/* Avoid the ISA hole and everything below it. */
#define RBUS_MEM_START	0x00100000
#endif

#ifndef RBUS_IO_START
/* Try to avoid onboard legacy devices; just a guess. */
#define RBUS_IO_START	0xa000
#endif

struct rbustag rbus_null;

rbus_tag_t
rbus_pccbb_parent_mem(struct device *self, struct pci_attach_args *pa)
{
	struct extent *ex = pa->pa_memex;
	bus_addr_t start;
	bus_size_t size;

	if (ex == NULL)
		return &rbus_null;

	start = RBUS_MEM_START;
	size = ex->ex_end - start;

	return (rbus_new_root_share(pa->pa_memt, ex, start, size));
}

rbus_tag_t
rbus_pccbb_parent_io(struct device *self, struct pci_attach_args *pa)
{
	struct extent *ex = pa->pa_ioex;
	bus_addr_t start;
	bus_size_t size;

	if (ex == NULL)
		return &rbus_null;

	start = ex->ex_start;
	if (ex == pciio_ex) {
		/*
		 * We're on the root bus, or behind a subtractive
		 * decode PCI-PCI bridge.  To avoid conflicts with
		 * onboard legacy devices, we only make a subregion
		 * available.
		 */
		start = max(start, RBUS_IO_START);
	}
	size = ex->ex_end - start;

	return (rbus_new_root_share(pa->pa_iot, ex, start, size));
}

void
pccbb_attach_hook(struct device *parent, struct device *self,
    struct pci_attach_args *pa)
{
}
@


1.26
log
@As per NetBSD move HAYAKAWA Koichi's licenses to two clause.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.25 2009/05/15 21:47:40 kettenis Exp $ */
d66 1
a66 1
	return (rbus_new_root_share(pa->pa_memt, ex, start, size, 0));
d91 1
a91 1
	return (rbus_new_root_share(pa->pa_iot, ex, start, size, 0));
@


1.25
log
@Always subregion the main PCI I/O extents.  This will handle things properly
when we pass the main PCI I/O extents to the secondary bus of subtractive
decode brigdes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.24 2009/04/28 18:37:13 kettenis Exp $ */
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by HAYAKAWA Koichi.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.24
log
@Simplify rbus_machdep.c, and make it work more reliable behind PCI-PCI bridges
by using the pci resource accounting extents.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.23 2008/07/07 23:41:58 brad Exp $ */
d85 1
a85 1
	if (pa->pa_bridgetag == NULL) {
d87 4
a90 3
		 * If we're not behind a PCI-PCI bridge, we must be on
		 * the root bus.  To avoid conflicts with onboard
		 * legacy devices, we only make a subregion available.
@


1.23
log
@Comment correction, actually -> actual

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.22 2008/07/02 03:00:00 fgsch Exp $ */
a33 2
#include "pcibios.h"

d36 1
a40 2
#include <sys/device.h>

d45 5
a49 1
#include <arch/i386/pci/pcibiosvar.h>
d52 1
a54 39
#ifndef RBUS_IO_SIZE
#define RBUS_IO_SIZE	0x1000
#endif

#ifndef RBUS_MIN_START
#define RBUS_MIN_START	0x40000000	/* 1 GB */
#endif
#ifndef RBUS_MEM_SIZE
#define RBUS_MEM_SIZE	0x00100000	
#endif

/*
 * Dynamically set the start address for rbus.  This must be called
 * before rbus is initialized.  The start address should be determined
 * by the amount of installed memory.  Generally 1 GB has been found
 * to be a good value, but it fails on some Thinkpads (e.g. 2645-4AU),
 * for which 0.5 GB is a good value.  It also fails on (at least)
 * Thinkpads with 2GB of RAM, for which 2 GB is a good value.
 *
 * Thus, a general strategy of setting rbus_min_start to the amount of
 * memory seems in order.  However, the actual amount of memory is
 * generally slightly more than the amount found, e.g. 1014MB vs 1024,
 * or 2046 vs 2048.
 */
bus_addr_t
rbus_min_start_hint(void)
{
	bus_addr_t rbus_min_start = RBUS_MIN_START;
	size_t ram = ptoa(physmem);

	if (ram <= 192 * 1024 * 1024UL) {
		/*
		 * <= 192 MB, so try 0.5 GB.  This will work on
		 * Thinkpad 600E (2645-4AU), which fails at 1 GB, and
		 * on some other older machines that may have trouble
		 * with addresses needing more than 20 bits.
		 */
		rbus_min_start = 512 * 1024 * 1024UL;
	}
d56 1
a56 14
	if (ram >= 1024 * 1024 * 1024UL) {
		/*
		 * > 1 GB, so try 2 GB.
		 */
		rbus_min_start =  2 * 1024 * 1024 * 1024UL;
	}

	/* Not tested in > 2 GB case. */
	if (ram > 2 * 1024 * 1024 * 1024UL) {
		/*
		 * > 2 GB, so try 3 GB.
		 */
		rbus_min_start =  3 * 1024 * 1024 * 1024UL;
	}
a57 7
	return (rbus_min_start);
}

/*
 * This function makes an rbus tag for memory space.  This rbus tag
 * shares the all memory region of ex_iomem.
 */
d61 2
a62 1
	bus_addr_t start, rbus_min_start;
a63 1
	struct extent *ex;
d65 2
a66 17
	size = RBUS_MEM_SIZE;
	start = rbus_min_start = rbus_min_start_hint();
#if NPCIBIOS > 0
	if ((ex = pciaddr_search(PCIADDR_SEARCH_MEM, &start, size)) == NULL)
#endif
	{
		extern struct extent *iomem_ex;
		ex = iomem_ex;
		start = ex->ex_start;

		/* XXX: unfortunately, iomem_ex cannot be used for the
		 * dynamic bus_space allocation.  There are some
		 * hidden memory (or some obstacles which do not
		 * recognised by the kernel) in the region governed by
		 * iomem_ex.  So I decide to use only very high
		 * address region.
		 */
d68 2
a69 5
		if (start < rbus_min_start)
			start = rbus_min_start;

		size = ex->ex_end - start;
	}
d77 1
a79 1
	struct extent *ex;
d81 2
a82 2
	size = RBUS_IO_SIZE;
	start = RBUS_IO_START;
d84 8
a91 6
#if NPCIBIOS > 0
	if ((ex = pciaddr_search(PCIADDR_SEARCH_IO, &start, size)) == NULL)
#endif
	{
		extern struct extent *ioport_ex;
		ex = ioport_ex;
d93 1
@


1.22
log
@* Dynamically set the rbus start address. from netbsd.
* For amd64, remove pcibios traces.
* make RBUS_IO_START, RBUS_IO_SIZE, RBUS_MIN_START and RBUS_MEM_SIZE
  (on i386) configurable via kernel options.
* Remove unneeded headers.
* Some cleanups.

originally reported in pr/5829 and tested by viq <viq at viq dot ath dot cx>.
fixes ian@@ laptop too.
kettenis@@ and miod@@ agrees that although not perfect, this is the right
direction.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.21 2007/12/09 16:53:36 kettenis Exp $ */
d73 1
a73 1
 * memory seems in order.  However, the actually amount of memory is
@


1.21
log
@Add an empty pccbb_attach_hook.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.20 2007/09/12 13:56:40 chl Exp $ */
a41 2
#include <sys/sysctl.h>

a46 3
#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>

d50 13
d64 7
a70 2
/**********************************************************************
 * rbus_tag_t rbus_fakeparent_mem(struct pci_attach_args *pa)
d72 38
a109 5
 *   This function makes an rbus tag for memory space.  This rbus tag
 *   shares the all memory region of ex_iomem.
 **********************************************************************/
#define RBUS_MEM_START	0x40000000
#define RBUS_MEM_SIZE	0x00100000
d111 4
d118 1
a118 1
	bus_addr_t start, min_start;
d123 1
a123 1
	start = min_start = max(RBUS_MEM_START, ptoa(physmem));
a137 4
		 *
		 * if defined PCIBIOS_ADDR_FIXUP, PCI device using
		 * area which is not recognised by the kernel are
		 * already reserved.
d140 2
a141 3
		if (start < min_start) {
			start = min_start;
		}
d146 1
a146 1
	return rbus_new_root_share(pa->pa_memt, ex, start, size, 0);
a148 7

/**********************************************************************
 * rbus_tag_t rbus_pccbb_parent_io(struct pci_attach_args *pa)
 **********************************************************************/
#define RBUS_IO_START	0xa000
#define RBUS_IO_SIZE	0x1000

a151 1
	struct extent *ex;
d154 1
d156 1
a156 1
	size =  RBUS_IO_SIZE;
d158 1
d167 1
a167 1
	return rbus_new_root_share(pa->pa_iot, ex, start, size, 0);
@


1.20
log
@s/atoin/ation/ typos

ok ray@@ cnst@@ moritz@@ sobrado@@ millert@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.19 2007/09/01 15:14:44 martin Exp $ */
d129 6
@


1.19
log
@replace the machine dependant bytes-to-clicks macro by the MI ptoa()
version for i386

more architectures and ctob() replacement is being worked on

prodded by and ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.18 2006/09/19 11:06:33 jsg Exp $ */
d83 1
a83 1
		 * dynamic bus_space allocatoin.  There are some
@


1.18
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.17 2005/04/09 00:41:27 reyk Exp $ */
d73 1
a73 1
	start = min_start = max(RBUS_MEM_START, ctob(physmem));
@


1.17
log
@fix rbus on big memory i386 machines (used by cbb(4) pcmcia).
closes an slightly old PR kernel/3855.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.16 2004/05/04 17:06:33 grange Exp $ */
d66 1
a66 3
rbus_pccbb_parent_mem(self, pa)
     struct device *self;
     struct pci_attach_args *pa;
d112 1
a112 3
rbus_pccbb_parent_io(self, pa)
     struct device *self;
     struct pci_attach_args *pa;
@


1.16
log
@Move _bus_space_unmap() to machdep.c so it can be used not
only by the rbus code. Also knf it and sync with bus_space_unmap().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.15 2002/07/23 17:53:24 drahn Exp $ */
d70 1
a70 1
	bus_addr_t start;
d75 1
a75 1
	start = RBUS_MEM_START;
d96 2
a97 2
		if (start < RBUS_MEM_START) {
			start = RBUS_MEM_START;	/* 1GB */
@


1.15
log
@Cardbus/pcmcia support for macppc. parts borrowed from NetBSD, and other
portions of the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.14 2002/06/13 19:59:01 mickey Exp $ */
a53 64


/**********************************************************************
 * void _bus_space_unmap(bus_space_tag bst, bus_space_handle bsh,
 *                        bus_size_t size, bus_addr_t *adrp)
 *
 *   This function unmaps memory- or io-space mapped by the function
 *   _bus_space_map().  This function works nearly as same as
 *   bus_space_map(), but this function does not ask kernel
 *   built-in extents and returns physical address of the bus space,
 *   for the convenience of the extra extent manager.
 *
 *   I suppose this function should be in arch/i386/i386/machdep.c,
 *   but it is not.
 **********************************************************************/
void
_bus_space_unmap(t, bsh, size, adrp)
     bus_space_tag_t t;
     bus_space_handle_t bsh;
     bus_size_t size;
     bus_addr_t *adrp;
{
  u_long va, endva;
  bus_addr_t bpa;

  /*
   * Find the correct extent and bus physical address.
   */
  if (t == I386_BUS_SPACE_IO) {
    bpa = bsh;
  } else if (t == I386_BUS_SPACE_MEM) {
    if (bsh >= atdevbase && (bsh + size) <= (atdevbase + IOM_SIZE)) {
      bpa = (bus_addr_t)ISA_PHYSADDR(bsh);
    } else {

      va = i386_trunc_page(bsh);
      endva = i386_round_page(bsh + size);

#ifdef DIAGNOSTIC
      if (endva <= va) {
	panic("_i386_memio_unmap: overflow");
      }
#endif

      if (pmap_extract(pmap_kernel(), va, &bpa) == FALSE) {
	panic("_i386_memio_unmap:i386/rbus_machdep.c wrong virtual address");
      }
      bpa += (bsh & PGOFSET);

      /*
       * Free the kernel virtual mapping.
       */
      uvm_km_free(kernel_map, va, endva - va);
    }
  } else {
    panic("_i386_memio_unmap: bad bus space tag");
  }

  if (adrp != NULL) {
    *adrp = bpa;
  }
}


@


1.14
log
@start/size might have ben used uninitialized in case
pcibios was not compiled in and cardbus needed an mem
allocation.
we were away w/ this before because in most configurations
cadbus require pcibios configured into the kernel.
dale found it.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.13 2001/11/06 01:43:48 art Exp $ */
d44 2
a48 1
#include <sys/device.h>
d130 2
a131 1
rbus_pccbb_parent_mem(pa)
d178 2
a179 1
rbus_pccbb_parent_io(pa)
@


1.13
log
@Zap some redundant includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.12 2001/09/19 20:50:56 mickey Exp $ */
a135 1
#if NPCIBIOS > 0
d138 1
@


1.13.2.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.13 2001/11/06 01:43:48 art Exp $ */
a43 2
#include <sys/device.h>

d47 1
d129 1
a129 2
rbus_pccbb_parent_mem(self, pa)
     struct device *self;
d136 1
a138 1
#if NPCIBIOS > 0
d176 1
a176 2
rbus_pccbb_parent_io(self, pa)
     struct device *self;
@


1.12
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.11 2001/06/22 21:01:24 mickey Exp $ */
a38 3

#include <vm/vm.h>
#include <vm/vm_page.h>
@


1.11
log
@shift the range for i/o space allocation to 0xa000 as it
seems that some compaq machines have smth in the existing
range at 0x2000.
from nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.10 2001/06/08 08:08:53 art Exp $ */
a40 1
#include <vm/vm_kern.h>
@


1.10
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.9 2001/05/05 23:25:40 art Exp $ */
d176 1
a176 1
#define RBUS_IO_START	0x2000
@


1.9
log
@PMAP_NEW and UVM are no longer optional on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.8 2001/05/01 03:15:43 mickey Exp $ */
a100 1
#if __NetBSD_Version__ > 104050000
a104 3
#else
      bpa = pmap_extract(pmap_kernel(), va) + (bsh & PGOFSET);
#endif
@


1.8
log
@trailing spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.7 2001/01/25 01:00:52 mickey Exp $ */
a112 1
#if defined(UVM)
a113 3
#else
      kmem_free(kernel_map, va, endva - va);
#endif
@


1.7
log
@make code for searching in pcibios's addr allocation
extents common for both io and mem and private to pcibios.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.6 2001/01/24 23:40:25 mickey Exp $ */
a58 1

d157 1
a157 1
		
d169 1
a169 1
		
d173 1
a173 1
		
@


1.7.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.7 2001/01/25 01:00:52 mickey Exp $ */
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.7.2.1 2001/04/18 16:07:23 niklas Exp $ */
d59 1
d102 1
d107 3
d114 1
d116 3
d158 1
a158 1

d170 1
a170 1

d174 1
a174 1

d185 1
a185 1
#define RBUS_IO_START	0xa000
@


1.7.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.7.2.2 2001/07/04 10:16:42 niklas Exp $ */
d41 1
@


1.7.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d39 3
@


1.7.2.5
log
@Sync the SMP branch with 3.3
@
text
@a43 2
#include <sys/device.h>

d47 1
d129 1
a129 2
rbus_pccbb_parent_mem(self, pa)
     struct device *self;
d136 1
a138 1
#if NPCIBIOS > 0
d176 1
a176 2
rbus_pccbb_parent_io(self, pa)
     struct device *self;
@


1.7.2.6
log
@Merge with the trunk
@
text
@d57 64
@


1.6
log
@put pci_addr_fixup.h into pcibiosvar.h as well,
all it had were a struct and a proto.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.5 2000/11/21 14:23:33 aaron Exp $ */
d150 3
a152 27
	if (!(pcibios_flags & PCIBIOS_ADDR_FIXUP)) {
		struct extent_region *rp;
		ex = pciaddr.extent_mem;
		
		/* This size is the maximum size that would be
		   requested by a cardbus/pcmcia device */
		size = RBUS_MEM_SIZE;
		start = RBUS_MEM_START;
		
		/* Search the PCI I/O memory space extent for free
		   space that will accomidate size.  Remember that the
		   extent stores allocated space and we're searching
		   for the gaps. */
		rp = ex->ex_regions.lh_first;

		/* If we're at the end or the gap between this region
		   and the next region big enough, then we're done */
		while (rp && start + size > rp->er_start) {
			bus_addr_t new_start;

			new_start = (rp->er_end - 1 + size) & ~(size - 1);
			if (new_start > start)
				start = new_start;

			rp = rp->er_link.le_next;
		}
	} else
d167 1
a167 1
		 * area which do not recognised by the kernel are
d196 2
d199 1
a199 24
	if (!(pcibios_flags & PCIBIOS_ADDR_FIXUP)) {
		struct extent_region *rp;
		ex = pciaddr.extent_port;
		size =  RBUS_IO_SIZE;
		start = RBUS_IO_START;
		
		/* Search the PCI I/O port space extent for free space
		   that will accomidate size.  Remember that the
		   extent stores allocated space and we're searching
		   for the gaps. */
		rp = ex->ex_regions.lh_first;

		/* If we're at the end or the gap between this region
		   and the next region big enough, then we're done */
		while (rp && start + size > rp->er_start) {
			bus_addr_t new_start;

			new_start = (rp->er_end - 1 + size) & ~(size - 1);
			if (new_start > start)
				start = new_start;

			rp = rp->er_link.le_next;
		}
	} else
a203 2
		start = RBUS_IO_START;
		size =  RBUS_IO_START;
@


1.5
log
@Make this compile without UVM; dirt@@monkey.org
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.4 2000/10/31 18:56:40 deraadt Exp $ */
a56 1
#include <arch/i386/pci/pci_addr_fixup.h>
@


1.4
log
@rename pcibios.h to pcibiosvar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.3 2000/10/06 17:44:35 mickey Exp $ */
d115 1
d117 3
@


1.3
log
@make it compile w/o pcibios; aaron@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.2 2000/09/05 17:55:54 nate Exp $ */
d56 1
a56 1
#include <arch/i386/pci/pcibios.h>
@


1.2
log
@Fix the way that I/O port and memory space is allocated to cards. ok aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rbus_machdep.c,v 1.1 2000/04/08 05:50:50 aaron Exp $ */
d34 1
a34 1
/* $Id: rbus_machdep.c,v 1.1 2000/04/08 05:50:50 aaron Exp $ */
d146 1
d173 3
a175 2
	}
	else {
d217 1
d241 3
a243 2
	}
	else {
@


1.1
log
@Initial check-in for support of 32-bit CardBus PC Cards; from NetBSD. On many
machines, this code needs the new PCIBIOS* options enabled in the kernel config
file to work, but your mileage may vary. Included is a working 3c575 driver for
3Com 10/100 CardBus PC Card NICs (tested only with the 'C' revision). The 3c575
is the pccard version of the PCI EtherLink XL cards, and thus the xl driver has
been split into /sys/dev/ic.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d34 1
a34 1
/* $Id: rbus_machdep.c,v 1.2 1999/10/15 06:43:06 haya Exp $ */
d38 1
d56 2
d132 2
a133 1
 *   This function allocates a memory space from 1 GB to 1.25 GB.
d135 3
d142 54
a195 7
  bus_addr_t start =  0x40000000; /* 1 GB */
  bus_size_t size =  0x08000000; /* 128 MB */
  bus_space_handle_t memh;	/* fake */

  start += pa->pa_function * size;
  
  bus_space_map(pa->pa_memt, start, size, 0, &memh);
d197 1
a197 1
  return rbus_new_root_delegate(pa->pa_memt, start, size, 0);
d204 3
d211 34
a244 7
  bus_addr_t start =  0x2000;
  bus_size_t size =  0x0800;
  bus_space_handle_t ioh;

  start += pa->pa_function * size;

  bus_space_map(pa->pa_iot, start, size, 0, &ioh);
d246 1
a246 1
  return rbus_new_root_delegate(pa->pa_iot, start, size, 0);
@

