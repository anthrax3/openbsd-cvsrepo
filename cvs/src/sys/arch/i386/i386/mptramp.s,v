head	1.22;
access;
symbols
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.20.0.4
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.6
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.14
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.12
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.10
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.8
	OPENBSD_5_0:1.13.0.6
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.8.0.4
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.4.0.2
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.3.0.2
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	UBC_SYNC_A:1.1
	UBC_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@# @;


1.22
date	2017.06.29.07.51.59;	author mlarkin;	state Exp;
branches;
next	1.21;
commitid	DTxwoRCgZUbPDikJ;

1.21
date	2017.06.04.23.03.19;	author naddy;	state Exp;
branches;
next	1.20;
commitid	0nNiSmPoJuZPwDRg;

1.20
date	2017.02.06.01.50.36;	author mlarkin;	state Exp;
branches;
next	1.19;
commitid	OpJDpgA5UtBbaSUS;

1.19
date	2016.05.24.02.15.38;	author mlarkin;	state Exp;
branches;
next	1.18;
commitid	smaOaoe29WGalzTh;

1.18
date	2016.05.18.03.45.11;	author mlarkin;	state Exp;
branches;
next	1.17;
commitid	JQz4IJ6cQ8DinMqc;

1.17
date	2015.04.26.09.48.29;	author kettenis;	state Exp;
branches;
next	1.16;
commitid	3Uurxze029jRDQJK;

1.16
date	2015.04.24.12.52.38;	author kettenis;	state Exp;
branches;
next	1.15;
commitid	ldM9NygmNatsq6n7;

1.15
date	2015.04.12.18.37.53;	author mlarkin;	state Exp;
branches;
next	1.14;
commitid	5ST94uMTezmXYdhY;

1.14
date	2014.01.05.20.23.57;	author mlarkin;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.01.19.48.50;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.10.13.51.47;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2009.02.03.11.24.19;	author mikeb;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.10.15.53.51;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2007.02.20.21.15.01;	author tom;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.16.15.51.26;	author tom;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.27.15.37.51;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.14.14.44.37;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.13.16.44.22;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.26.04.29.06;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.14.10.02.29;	author ho;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.07.14.10.02.29;	author ho;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.07.16.23.05.35;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.10.27.22.43.48;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.05.15.17.47.16;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.22
log
@suppress local symbols in mptramp. Matches a similar diff in
acpi_wakecode.s that was committed previously.

Tested MP boot, un-zzz, un-ZZZ, no issues seen.
@
text
@/*	$OpenBSD: mptramp.s,v 1.21 2017/06/04 23:03:19 naddy Exp $	*/

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1999 Stefan Grefen
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the NetBSD
 *      Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * MP startup ...
 * the stuff from cpu_spinup_trampoline to mp_startup
 * is copied into the first 640 KB
 *
 * We startup the processors now when the kthreads become ready.
 * The steps are:
 *	1) Get the processors running kernel-code from a special
 *	   page-table and stack page, do chip identification.
 *	2) halt the processors waiting for them to be enabled
 *	   by a idle-thread
 */

#include "assym.h"
#include <machine/param.h>
#include <machine/asm.h>
#include <machine/specialreg.h>
#include <machine/segments.h>
#include <machine/gdt.h>
#include <machine/mpbiosvar.h>
#include <machine/i82489reg.h>

#ifdef __clang__
#define addr32
#endif

#define GDTE(a,b)	.byte	0xff,0xff,0x0,0x0,0x0,a,b,0x0
#define _RELOC(x)	((x) - KERNBASE)
#define RELOC(x)	_RELOC(_C_LABEL(x))

#define _TRMP_LABEL(a)  a = . - _C_LABEL(cpu_spinup_trampoline) + MP_TRAMPOLINE
#define _TRMP_OFFSET(a)  a = . - _C_LABEL(cpu_spinup_trampoline)
#define _TRMP_DATA_LABEL(a)  a = . - _C_LABEL(mp_tramp_data_start) + \
				MP_TRAMP_DATA
#define _TRMP_DATA_OFFSET(a)  a = . - _C_LABEL(mp_tramp_data_start)

	.globl	_C_LABEL(cpu),_C_LABEL(cpu_id),_C_LABEL(cpu_vendor)
	.globl	_C_LABEL(cpuid_level),_C_LABEL(cpu_feature)

	.global _C_LABEL(cpu_spinup_trampoline)
	.global _C_LABEL(cpu_spinup_trampoline_end)
	.global _C_LABEL(cpu_hatch)
	.global _C_LABEL(mp_pdirpa)
	.global _C_LABEL(mp_tramp_data_start)
	.global _C_LABEL(mp_tramp_data_end)
	.global _C_LABEL(gdt), _C_LABEL(local_apic)

	.text
	.align 4, 0xcc
	.code16
_C_LABEL(cpu_spinup_trampoline):
	cli
	movw	$(MP_TRAMP_DATA >> 4), %ax
	movw	%ax, %ds
	movw	%cs, %ax
	movw	%ax, %es
	movw	%ax, %ss
	addr32 lgdtl (.Lgdt_desc)	# load flat descriptor table
	movl	%cr0, %eax	# get cr0
	orl	$0x1, %eax	# enable protected mode
	movl	%eax, %cr0	# doit
	ljmpl	$0x8, $.Lmp_startup

_TRMP_LABEL(.Lmp_startup)
	.code32

	movl	$0x10, %eax	# data segment
	movw	%ax, %ds
	movw	%ax, %ss
	movw	%ax, %es
	movw	%ax, %fs
	movw	%ax, %gs
	movl	$(MP_TRAMP_DATA+NBPG-16),%esp	# bootstrap stack end,
						# with scratch space..

	/* First, reset the PSL. */
	pushl	$PSL_MBO
	popfl

	movl	RELOC(mp_pdirpa),%ecx

	/* Load base of page directory and enable mapping. */
	movl	%ecx,%cr3		# load ptd addr into mmu
#ifndef SMALL_KERNEL
	testl	$0x1, RELOC(_C_LABEL(cpu_pae))
	jz	nopae

	movl	%cr4,%eax
	orl	$CR4_PAE,%eax
	movl	%eax, %cr4
	
	movl	$MSR_EFER,%ecx
	rdmsr
	orl	$EFER_NXE, %eax
	wrmsr

nopae:
#endif
	movl	%cr0,%eax		# get control word
					# enable paging & NPX emulation
	orl	$(CR0_PE|CR0_PG|CR0_NE|CR0_TS|CR0_EM|CR0_MP|CR0_WP),%eax
	movl	%eax,%cr0		# and let's page NOW!

# ok, we're now running with paging enabled and sharing page tables with cpu0.
# figure out which processor we really are, what stack we should be on, etc.

	movl	_C_LABEL(local_apic)+LAPIC_ID,%eax
	shrl	$LAPIC_ID_SHIFT,%eax
	xorl	%ebx,%ebx
1:
	leal	0(,%ebx,4),%ecx
	incl	%ebx
	movl	_C_LABEL(cpu_info)(%ecx),%ecx
	movl	CPU_INFO_APICID(%ecx),%edx
	cmpl	%eax,%edx
	jne 1b

# %ecx points at our cpu_info structure..

	movw	$(MAXGDTSIZ-1), 6(%esp)		# prepare segment descriptor
	movl	CPU_INFO_GDT(%ecx), %eax	# for real gdt
	movl	%eax, 8(%esp)
	lgdt	6(%esp)
	jmp	1f
	nop
1:
	movl	$GSEL(GDATA_SEL, SEL_KPL),%eax	#switch to new segment
	movw	%ax,%ds
	movw	%ax,%es
	movw	%ax,%ss
	pushl	$GSEL(GCODE_SEL, SEL_KPL)
	pushl	$mp_cont
	lret

_C_LABEL(cpu_spinup_trampoline_end):	#end of code copied to MP_TRAMPOLINE
mp_cont:

	movl	CPU_INFO_IDLE_PCB(%ecx),%esi

# %esi now points at our PCB.

	movl	PCB_ESP(%esi),%esp
	movl	PCB_EBP(%esi),%ebp

	/* Switch address space. */
	movl	PCB_CR3(%esi),%eax
	movl	%eax,%cr3
	/* Load segment registers. */
	movl	$GSEL(GCPU_SEL, SEL_KPL),%eax
	movl	%eax,%fs
	xorl	%eax,%eax
	movl	%eax,%gs
	movl	PCB_CR0(%esi),%eax
	movl	%eax,%cr0
	pushl	%ecx
	call	_C_LABEL(cpu_hatch)
	/* NOTREACHED */

	.section .rodata
_C_LABEL(mp_tramp_data_start):
_TRMP_DATA_LABEL(.Lgdt_table)
	.word	0x0,0x0,0x0,0x0			# null GDTE
	 GDTE(0x9f,0xcf)			# Kernel text
	 GDTE(0x93,0xcf)			# Kernel data
_TRMP_DATA_OFFSET(.Lgdt_desc)
	.word	0x17				# limit 3 entries
	.long	.Lgdt_table			# where is gdt
_C_LABEL(mp_tramp_data_end):
@


1.21
log
@Catch up with changes made on amd64 (kettenis@@):

Generating mixed 16-bit/32-bit/64-bit code with clang's integrated
assembler is a bit tricky.  It supports the .code16, .code32 and
.code64 directives.  But it doesn't know about the data16/data32 and
addr16/addr32 instruction prefixes.  Instead it tries to determine
those from the instruction opcode.  It mostly succeeds, but there are
a couple of corner cases where clang will generate the "addr32" form
where gas generates the "addr16" form in .code16 segments.  That
should be no problem (and just waste a couple of bytes), but it makes
comparing the generated code a bit difficult.

Allow the trampoline code to be compiled with both.  For clang #define
away the addr32 prefix and avoid using the data32 prefix by using a
mnemonic that explicitly encodes the size of the operand.  Add a few
addr32 prefixes in .code16 blocks to reduce the differences between
code generated by clang and gas.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.20 2017/02/06 01:50:36 mlarkin Exp $	*/
d122 1
a122 1
	addr32 lgdtl (gdt_desc)	# load flat descriptor table
d126 1
a126 1
	ljmpl	$0x8, $mp_startup
d128 1
a128 1
_TRMP_LABEL(mp_startup)
d225 1
a225 1
_TRMP_DATA_LABEL(gdt_table)
d229 1
a229 1
_TRMP_DATA_OFFSET(gdt_desc)
d231 1
a231 1
	.long	gdt_table			# where is gdt
@


1.20
log
@When determining whether or not to hatch into PAE mode, use the cpu_pae
flag variable instead of checking some pointer assignment made earlier
in pae_bootstrap.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.19 2016/05/24 02:15:38 mlarkin Exp $	*/
d87 4
d122 1
a122 1
	data32 addr32 lgdt	(gdt_desc)	# load flat descriptor table
@


1.19
log
@
remove some ancient debugging code

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.18 2016/05/18 03:45:11 mlarkin Exp $	*/
d145 2
a146 3
	movl	$_C_LABEL(pmap_pte_set_pae),%eax
	cmpl	RELOC(_C_LABEL(pmap_pte_set_p)),%eax
	jne	nopae
@


1.18
log
@
Split i386 mp hatch trampoline into code and data pages, and protect each
with proper W^X policy. The same thing was done for amd64 late last year,
catching i386 up now. Diff has been in snaps for a few days with no
reported fallout.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.17 2015/04/26 09:48:29 kettenis Exp $	*/
a96 18
/*
 * Debug code to stop aux. processors in various stages based on the
 * value in cpu_trace.
 *
 * %edi points at cpu_trace;  cpu_trace[0] is the "hold point";
 * cpu_trace[1] is the point which the cpu has reached.
 * cpu_trace[2] is the last value stored by HALTT.
 */


#ifdef MPDEBUG
#define HALT(x)	1: movl (%edi),%ebx;cmpl $ x,%ebx ; jle 1b ; movl $x,4(%edi)
#define HALTT(x,y)	movl y,8(%edi); HALT(x)
#else
#define HALT(x)
#define HALTT(x,y)
#endif

a135 5
#ifdef MPDEBUG
	leal	RELOC(cpu_trace),%edi
#endif

	HALT(0x1)
a140 1
	HALTT(0x5,%ecx)
a164 5
#ifdef MPDEBUG
	leal	_C_LABEL(cpu_trace),%edi
#endif
	HALT(0x6)

a178 2
	HALTT(0x7, %ecx)

a183 1
	HALTT(0x8, %eax)
a184 1
	HALT(0x9)
a187 1
	HALT(0xa)
a188 1
	HALTT(0x10, %eax)
a189 1
	HALT(0x11)
a190 1
	HALT(0x12)
a191 1
	HALT(0x13)
a193 1
	HALT(0x14)
a202 2
	HALTT(0x19, %esi)

a205 1
	HALT(0x20)
a207 1
	HALTT(0x22, %eax)
a208 1
	HALT(0x25)
a210 1
	HALTT(0x26,%eax)
a212 1
	HALTT(0x27,%eax)
a214 1
	HALTT(0x28,%eax)
a215 1
	HALTT(0x30,%ecx)
a228 7
#ifdef MPDEBUG
	.global _C_LABEL(cpu_trace)
_TRMP_DATA_LABEL(cpu_trace)
	.long	0x40
	.long	0xff
	.long	0xff
#endif
@


1.17
log
@Only enable PAE if the CPU we're running on has NX support.  Without NX
support we're only wasting memory on the larger PAE page tables without
any real benefit.  This allows some simplifications of the low-level
assembly code.

ok mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.16 2015/04/24 12:52:38 kettenis Exp $	*/
d93 3
d122 2
d127 1
a127 1
	.align 4,0x0
d131 2
a133 1
	movw	%ax, %ds
d151 1
a151 1
	movl	$(MP_TRAMPOLINE+NBPG-16),%esp	# bootstrap stack end,
a233 8
	.align 4,0x0
_TRMP_LABEL(gdt_table)
	.word	0x0,0x0,0x0,0x0			# null GDTE
	 GDTE(0x9f,0xcf)			# Kernel text
	 GDTE(0x93,0xcf)			# Kernel data
_TRMP_OFFSET(gdt_desc)
	.word	0x17				# limit 3 entries
	.long	gdt_table			# where is gdt
d268 9
a276 3
	.data
_C_LABEL(mp_pdirpa):
	.long	0
d279 1
a279 1
_C_LABEL(cpu_trace):
d284 1
@


1.16
log
@Enable the NX bit and use it in the PAE pmap code.  PAE is still disabled
while we're chasing at least one remaining bug.

ok mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.15 2015/04/12 18:37:53 mlarkin Exp $	*/
a172 9
	movl	%edx, %edi		# %edx is needed by wrmsr below

	# Check if we need to enable NXE
	movl	$0x80000001, %eax
	cpuid
	andl	$CPUID_NXE, %edx
	xorl	%eax,%eax
	testl	%edx, %edx
	jz	1f
a173 3
1:
	movl	%edi, %edx		# Restore saved %edx
	movl	$MSR_EFER,%ecx
@


1.15
log
@
Bring PAE code back to life, in a different form. This diff (via bluhm then
to deraadt, then myself) brings the PAE pmap on i386 (not touched in any
significant way for years) closer to the current non-PAE pmap and allows
us to take a big next step toward better i386 W^X in the kernel (similar to
what we did a few months ago on amd64). Unlike the original PAE pmap, this
diff will not be supporting > 4GB physical memory on i386 - this effort is
specifically geared toward providing W^X (via NX) only.

There still seems to be a bug removing certain pmap entries when PAE is
enabled, so I'm leaving PAE mode disabled for the moment until we can
figure out what is going on, but with this diff in the tree hopefully
others can help.

The pmap functions now operate through function pointers, due to the need
to support both non-PAE and PAE forms. My unscientific testing showed
less than 0.3% (a third of a percent) slowdown with this approach during
a base build.

Discussed for months with guenther, kettenis, and deraadt.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.14 2014/01/05 20:23:57 mlarkin Exp $	*/
d170 18
@


1.14
log
@

Don't use the first 64KB for anything, including tramps. Move tramps and
hibernate goo up after 64KB to avoid posible corruption by buggy BIOS SMM
code. Diff also ensures the first 64KB doesn't get handed to UVM either.

ok deraadt@@, tested by many with no regressions reported
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.13 2010/04/01 19:48:50 kettenis Exp $	*/
d162 10
@


1.13
log
@Don't index cpu_info by apic id, but by device unit number instead.  Recent
Intel CPUs come up with apic id's >= 32, even on systems with less than 32
logical CPUs.

ok krw@@, marco@@; tested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.12 2009/07/10 13:51:47 jsg Exp $	*/
d92 1
d126 1
a126 1
	xorw	%ax, %ax
d134 1
a134 1
	ljmp	$0x8, $mp_startup
d217 1
a217 1
_TRMP_LABEL(gdt_desc)
@


1.12
log
@Switch away from using -traditional-cpp to iso/ansi cpp for asm files.
More architectures hopefully to follow.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.11 2009/02/03 11:24:19 mikeb Exp $	*/
d174 6
a179 3
	movl	_C_LABEL(local_apic)+LAPIC_ID,%ecx
	shrl	$LAPIC_ID_SHIFT,%ecx
	leal	0(,%ecx,4),%ecx
d181 3
@


1.11
log
@Free TSS on the stack of the dead process.

In order to do that we have to remove all sleeping parts: sleeping
memory allocation and a sleeping lock.  Thus we're moving this code
to the spinning lock (mutex) and getting rid of the GDT grow code.
Downside is that now we're pre-allocating 64kb of memory per CPU
from the start, but this might be optimized in future.

This also unifies GDT code and MAXGDTSIZ define across i386 and amd64.

With help from mickey.

ok toby, art
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.10 2008/06/26 05:42:10 ray Exp $	*/
d107 2
a108 2
#define HALT(x)	/**/
#define HALTT(x,y) /**/
@


1.10
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.9 2007/10/10 15:53:51 art Exp $	*/
d183 1
a183 1
	movw	$((MAXGDTSIZ*8) - 1), 6(%esp)	# prepare segment descriptor
@


1.9
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.8 2007/02/20 21:15:01 tom Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.8
log
@Revert PAE pmap for now, until the strange bug is found.  This stops
the freezes many of us are seeing (especially on amd64 machines running
OpenBSD/i386).

Much testing by nick@@ (as always - thanks!), hugh@@, ian@@, kettenis@@
and Sam Smith (s (at) msmith (dot) net).

Requested by, input from, and ok deraadt@@  ok art@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.5 2006/03/14 14:44:37 mickey Exp $	*/
d252 1
a252 3
	HALT(0x33)
	xorl	%esi,%esi
	jmp	_C_LABEL(idle_start)
@


1.7
log
@Fix some more "is is"s.  ok otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.6 2006/04/27 15:37:51 mickey Exp $	*/
d168 4
a171 14
#ifndef SMALL_KERNEL
	movl	$_C_LABEL(pmap_pte_set_pae),%eax
	cmpl	RELOC(_C_LABEL(pmap_pte_set_p)),%eax
	jne	nopae

	movl	%cr4,%eax
	orl	$CR4_PAE,%eax
	movl	%eax, %cr4
nopae:
#endif
        movl    %cr0,%eax               # get control word
                                        # enable paging & NPX emulation
        orl     $(CR0_PE|CR0_PG|CR0_NE|CR0_TS|CR0_EM|CR0_MP|CR0_WP),%eax
        movl    %eax,%cr0               # and let's page NOW!
@


1.6
log
@implement separate PAE pmap that allows access to 64g of physmem
if supported by the cpu(s). currently not enabled by default and
not compiled into ramdisks. this grows paddr_t to 64bit but yet
leaves bus_addr_t at 32bits. measures are taken to favour dmaable
memory allocation from below 4g line such that buffer cache is
already allocated form below, pool backend allocator prefers lower
memory and then finally bounce buffers are used as last resort.
PAE is engaged only if global variable cpu_pae is manually set
to non-zero and there is physical memory present above 4g.
simplify pcibios address math to use u_long as we always will
be in the 32bit space.
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.5 2006/03/14 14:44:37 mickey Exp $	*/
d229 1
a229 1
	.long	gdt_table			# where is is gdt
@


1.5
log
@trailing tabs nomore
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.4 2006/01/13 16:44:22 mickey Exp $	*/
d168 14
a181 4
	movl	%cr0,%eax		# get control word
					# enable paging & NPX emulation
	orl	$(CR0_PE|CR0_PG|CR0_NE|CR0_TS|CR0_EM|CR0_MP|CR0_WP),%eax
	movl	%eax,%cr0		# and let's page NOW!
@


1.4
log
@white space vs tabs; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.3 2005/05/26 04:29:06 mickey Exp $	*/
d40 1
a40 1
	
d84 1
a84 1
	
d108 2
a109 2
	
	
d162 1
a162 1
	
d165 1
a165 1
	
d177 1
a177 1
	
d185 1
a185 1
	
d193 1
a193 1
	HALTT(0x8, %eax)	
d195 1
a195 1
	HALT(0x9)	
d198 1
a198 1
1:	
d217 1
a217 1
_TRMP_LABEL(gdt_desc)	
d225 1
a225 1
	
d227 1
a227 1
	
d232 2
a233 2
	
	HALT(0x20)	
d236 1
a236 1
	HALTT(0x22, %eax)		
d241 2
a242 2
	HALTT(0x26,%eax)	
	movl	%eax,%fs		
d244 1
a244 1
	HALTT(0x27,%eax)		
d247 1
a247 1
	HALTT(0x28,%eax)		
d249 1
a249 1
	HALTT(0x30,%ecx)	
d252 1
a252 1
	HALT(0x33)	
d255 1
a255 1
	
d264 1
a264 1
	.long	0xff		
@


1.3
log
@optimise one more jmp out of the idle loop; toby@@ marco@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.2 2004/06/13 21:49:15 niklas Exp $	*/
d54 5
a58 5
 *      This product includes software developed by the NetBSD 
 *      Foundation, Inc. and its contributors.  
 * 4. Neither the name of The NetBSD Foundation nor the names of its 
 *    contributors may be used to endorse or promote products derived  
 *    from this software without specific prior written permission.   
d74 1
a74 1
 * the stuff from cpu_spinup_trampoline to mp_startup 
d79 4
a82 4
 *        1)   Get the processors running kernel-code from a special
 *                  page-table and stack page, do chip identification.
 *        2)   halt the processors waiting for them to be enabled
 *              by a idle-thread 
d94 3
a96 3
#define GDTE(a,b)               .byte   0xff,0xff,0x0,0x0,0x0,a,b,0x0
#define _RELOC(x)       ((x) - KERNBASE)
#define RELOC(x)        _RELOC(_C_LABEL(x))
d118 2
a119 2
        .globl  _C_LABEL(cpu),_C_LABEL(cpu_id),_C_LABEL(cpu_vendor)
	.globl  _C_LABEL(cpuid_level),_C_LABEL(cpu_feature)
d132 9
a140 9
	xorw    %ax, %ax
	movw    %ax, %ds
	movw    %ax, %es
	movw    %ax, %ss
	data32 addr32 lgdt    (gdt_desc)      # load flat descriptor table
	movl    %cr0, %eax      # get cr0
	orl     $0x1, %eax      # enable protected mode
	movl    %eax, %cr0      # doit
	ljmp    $0x8, $mp_startup
d145 7
a151 7
	movl    $0x10, %eax     # data segment
	movw    %ax, %ds
	movw    %ax, %ss
	movw    %ax, %es
	movw    %ax, %fs
	movw    %ax, %gs
	movl    $(MP_TRAMPOLINE+NBPG-16),%esp	# bootstrap stack end,
d155 1
a155 1
	leal    RELOC(cpu_trace),%edi       
d168 4
a171 4
        movl    %cr0,%eax               # get control word
                                        # enable paging & NPX emulation
        orl     $(CR0_PE|CR0_PG|CR0_NE|CR0_TS|CR0_EM|CR0_MP|CR0_WP),%eax
        movl    %eax,%cr0               # and let's page NOW!
d174 1
a174 1
	leal    _C_LABEL(cpu_trace),%edi
d190 3
a192 3
	movw    $((MAXGDTSIZ*8) - 1), 6(%esp)	# prepare segment descriptor
	movl    CPU_INFO_GDT(%ecx), %eax	# for real gdt
	movl    %eax, 8(%esp)
d200 1
a200 1
	movl    $GSEL(GDATA_SEL, SEL_KPL),%eax 	#switch to new segment
d202 1
a202 1
	movw    %ax,%ds
d204 1
a204 1
	movw    %ax,%es
d206 1
a206 1
	movw    %ax,%ss
d208 1
a208 1
	pushl   $GSEL(GCODE_SEL, SEL_KPL)
d213 4
a216 4
_TRMP_LABEL(gdt_table)   
	.word   0x0,0x0,0x0,0x0  # null GDTE
	 GDTE(0x9f,0xcf)         # Kernel text
	 GDTE(0x93,0xcf)         # Kernel data
d218 2
a219 2
	.word   0x17             # limit 3 entries
	.long   gdt_table              # where is is gdt
d246 1
a246 1
	movl    PCB_CR0(%esi),%eax
d248 1
a248 1
	movl    %eax,%cr0
d262 3
a264 3
	.long  0x40
	.long  0xff
	.long  0xff		
@


1.2
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d254 1
a254 1
	jmp	_C_LABEL(idle_loop)
@


1.1
log
@file mptramp.s was initially added on branch SMP.
@
text
@d1 265
@


1.1.2.1
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@a0 287
/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
	
/*
 * Copyright (c) 1999 Stefan Grefen
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the NetBSD 
 *      Foundation, Inc. and its contributors.  
 * 4. Neither the name of The NetBSD Foundation nor the names of its 
 *    contributors may be used to endorse or promote products derived  
 *    from this software without specific prior written permission.   
 *
 * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * MP startup ...
 * the stuff from cpu_spinup_trampoline to mp_startup 
 * is copied into the first 640 KB
 *
 * We startup the processors now when the kthreads become ready.
 * The steps are:
 *        1)   Get the processors running kernel-code from a special
 *                  page-table and stack page, do chip identification.
 *        2)   halt the processors waiting for them to be enabled
 *              by a idle-thread 
 */
	
#include "assym.h"
#include <machine/param.h>
#include <machine/asm.h>
#include <machine/specialreg.h>
#include <machine/segments.h>
#include <machine/mpbiosvar.h>
#include <machine/i82489reg.h>

#define GDTE(a,b)               .byte   0xff,0xff,0x0,0x0,0x0,a,b,0x0
#define _RELOC(x)       ((x) - KERNBASE)
#define RELOC(x)        _RELOC(_C_LABEL(x))

#define _TRMP_LABEL(a)  a = . - _C_LABEL(cpu_spinup_trampoline) + MP_TRAMPOLINE

/*
 * Debug code to stop aux. processors in various stages based on the
 * value in cpu_trace.
 *
 * %edi points at cpu_trace;  cpu_trace[0] is the "hold point";
 * cpu_trace[1] is the point which the cpu has reached.
 * cpu_trace[2] is the last value stored by HALTT.
 */
	
	
#ifdef MPDEBUG
#define HALT(x)	1: movl (%edi),%ebx;cmpl $ x,%ebx ; jle 1b ; movl $x,4(%edi)
#define HALTT(x,y)	movl y,8(%edi); HALT(x)
#else
#define HALT(x)	/**/
#define HALTT(x,y) /**/
#endif

        .globl  _C_LABEL(cpu),_C_LABEL(cpu_id),_C_LABEL(cpu_vendor)
	.globl  _C_LABEL(cpuid_level),_C_LABEL(cpu_feature)

	.global _C_LABEL(cpu_spinup_trampoline)
	.global _C_LABEL(cpu_spinup_trampoline_end)
	.global _C_LABEL(cpu_hatch)
	.global _C_LABEL(mp_pdirpa)
	.global _C_LABEL(gdt), _C_LABEL(local_apic)

	.text
	.align 4,0x0
_C_LABEL(cpu_spinup_trampoline):
	cli
	xorl    %eax,%eax
	movl    %ax, %ds
	movl    %ax, %es
	movl    %ax, %ss
	aword
	word
	lgdt    (gdt_desc)      # load flat descriptor table
	movl    %cr0,%eax       # get cr0
	word
	orl     $0x1, %eax      # enable protected mode
	movl    %eax, %cr0      # doit
	movl    $0x10, %eax     # data segment
	movl    %ax, %ds
	movl    %ax, %ss
	movl    %ax, %es
	movl    %ax, %fs
	movl    %ax, %gs
	word
	ljmp    $0x8, $mp_startup

_TRMP_LABEL(mp_startup)
	movl    $ (MP_TRAMPOLINE+NBPG-4),%esp       # bootstrap stack end location
	
#ifdef MPDEBUG
	leal    RELOC(cpu_trace),%edi       
#endif

	HALT(0x1)
#if 0
	/* 
	 * use cpuid
	 */
	xorl    %eax,%eax
	cpuid
	movl    %eax,RELOC(cpuid_level)
	movl    %ebx,RELOC(cpu_vendor)  # store vendor string
	movl    %edx,RELOC(cpu_vendor)+4
	movl    %ecx,RELOC(cpu_vendor)+8
	movl    $0,  RELOC(cpu_vendor)+12
	movl    $1,%eax
	cpuid
	movl    %eax,RELOC(cpu_id)      # store cpu_id and features
	movl    %edx,RELOC(cpu_feature)
	HALT(0x2)
#endif
	/* First, reset the PSL. */
	pushl   $PSL_MBO
	popfl
	
	movl	RELOC(mp_pdirpa),%ecx
	HALTT(0x5,%ecx)
	
        /* Load base of page directory and enable mapping. */
        movl    %ecx,%cr3               # load ptd addr into mmu
        movl    %cr0,%eax               # get control word
                                        # enable paging & NPX emulation
        orl     $(CR0_PE|CR0_PG|CR0_NE|CR0_TS|CR0_EM|CR0_MP|CR0_WP),%eax
        movl    %eax,%cr0               # and let's page NOW!
#ifdef MPDEBUG
	leal    _C_LABEL(cpu_trace),%edi       # bootstrap stack end location
#endif
	HALT(0x7)
	movw    $((NGDT*8) - 1), ngdt_table	# prepare segment descriptor
	movl    _C_LABEL(gdt), %eax		# for real gdt
	movl    %eax, ngdt_table+2
	lgdt	ngdt_table
	HALT(0x8)	
	jmp	1f
	nop
1:	
	HALT(0x12)
	movl    $GSEL(GDATA_SEL, SEL_KPL),%eax 	#switch to new segment
	movl    %ax,%ds
	movl    %ax,%es
	movl    %ax,%ss
	HALT(0x13)
	pushl   $GSEL(GCODE_SEL, SEL_KPL)
	pushl	$mp_cont
	HALT(0x14)
	lret
	.align 4,0x0
_TRMP_LABEL(gdt_table)   
	.word   0x0,0x0,0x0,0x0  # null GDTE
	 GDTE(0x9f,0xcf)         # Kernel text
	 GDTE(0x93,0xcf)         # Kernel data
_TRMP_LABEL(gdt_desc)	
	.word   0x17             # limit 3 entries
	.long   gdt_table              # where is is gdt
_TRMP_LABEL(ngdt_table)   
	.long  0		# filled in after paging in enabled
	.long  0
	.align 4,0x0
_C_LABEL(cpu_spinup_trampoline_end):	#end of code copied to MP_TRAMPOLINE
mp_cont:
	HALT(0x15)

# ok, we're now running with paging enabled and sharing page tables with cpu0.
# figure out which processor we really are, what stack we should be on, etc.

	movzbl	_C_LABEL(local_apic)+LAPIC_ID+3,%ecx
	leal	0(,%ecx,4),%ecx
	movl	_C_LABEL(cpu_info)(%ecx),%ecx
	
	HALTT(0x18, %ecx)

# %ecx points at our cpu_info structure..

	movl	CPU_INFO_IDLE_PCB(%ecx),%esi
#	movl	P_ADDR(%edx),%esi
	
	HALTT(0x19, %esi)
# %ecx points at our CPU_INFO.	
# %esi now points at our PCB.
	
	movl	PCB_ESP(%esi),%esp
	movl	PCB_EBP(%esi),%ebp
	
	/* Load TSS info. */
	movl	_C_LABEL(gdt),%eax
#	movl	PCB_TSS_SEL(%esi),%edx
	HALT(0x20)	
	/* Switch address space. */
	movl	PCB_CR3(%esi),%eax
	HALTT(0x22, %eax)		
	movl	%eax,%cr3
	HALT(0x24)
	
#	/* Switch TSS. */
#	andl	$~0x0200,4-SEL_KPL(%eax,%edx,1)
#	ltr	%dx
	
	HALT(0x25)
	/* Restore segment registers. */
	movl	PCB_FS(%esi),%eax
	HALTT(0x26,%eax)
	movl	%ax,%fs
	movl	PCB_GS(%esi),%eax
	HALTT(0x27,%eax)	
	movl	%ax,%gs
	movl    PCB_CR0(%esi),%eax
	HALTT(0x28,%eax)		
	movl    %eax,%cr0
	HALTT(0x30,%ecx)	
	pushl	%ecx
	call	_C_LABEL(cpu_hatch)
	HALT(0x33)	
mps:
	hlt
	jmp mps
	
	.data
_C_LABEL(mp_pdirpa):
	.long	0
#ifdef MPDEBUG
	.global _C_LABEL(cpu_trace)
_C_LABEL(cpu_trace):
	.long  0x40
	.long  0xff
	.long  0xff		
#endif
@


1.1.2.2
log
@$OpenBSD$
@
text
@a0 2
/*	$OpenBSD$	*/

@


1.1.2.3
log
@CPU 0 reporting for duty, Sir!
Some extra debugging, and movl change to leal made it work!
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.1.2.2 2001/07/16 23:05:35 niklas Exp $	*/
d193 1
a193 1
	leal    _C_LABEL(gdt), %eax		# for real gdt
a194 1
	HALTT(0x8, %eax)	
d196 1
a196 1
	HALT(0x9)	
d200 1
a200 1
	HALT(0xa)
a201 1
	HALTT(0x10, %eax)
a202 1
	HALT(0x11)
a203 1
	HALT(0x12)
d219 1
a219 1
	.word  0		# filled in after paging in enabled
@


1.1.2.4
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.1.2.3 2001/10/27 22:43:48 niklas Exp $	*/
a89 1
#include <machine/gdt.h>
a127 1
	.code16
d130 9
a138 6
	xorw    %ax, %ax
	movw    %ax, %ds
	movw    %ax, %es
	movw    %ax, %ss
	data32 addr32 lgdt    (gdt_desc)      # load flat descriptor table
	movl    %cr0, %eax      # get cr0
d141 7
d151 2
a152 11
	.code32

	movl    $0x10, %eax     # data segment
	movw    %ax, %ds
	movw    %ax, %ss
	movw    %ax, %es
	movw    %ax, %fs
	movw    %ax, %gs
	movl    $(MP_TRAMPOLINE+NBPG-16),%esp	# bootstrap stack end,
						# with scratch space..

d158 17
d176 1
a176 1
	pushl	$PSL_MBO
d182 2
a183 2
	/* Load base of page directory and enable mapping. */
	movl	%ecx,%cr3		# load ptd addr into mmu
a187 1

d189 1
a189 1
	leal    _C_LABEL(cpu_trace),%edi
d191 4
a194 16
	HALT(0x6)
	
# ok, we're now running with paging enabled and sharing page tables with cpu0.
# figure out which processor we really are, what stack we should be on, etc.

	movzbl	_C_LABEL(local_apic)+LAPIC_ID+3,%ecx
	leal	0(,%ecx,4),%ecx
	movl	_C_LABEL(cpu_info)(%ecx),%ecx
	
	HALTT(0x7, %ecx)

# %ecx points at our cpu_info structure..

	movw    $((MAXGDTSIZ*8) - 1), 6(%esp)	# prepare segment descriptor
	movl    CPU_INFO_GDT(%ecx), %eax	# for real gdt
	movl    %eax, 8(%esp)
d196 1
a196 1
	lgdt	6(%esp)
d204 1
a204 1
	movw    %ax,%ds
d206 1
a206 1
	movw    %ax,%es
d208 1
a208 1
	movw    %ax,%ss
d222 4
a225 1

d228 12
d242 1
d244 2
a247 2
	HALTT(0x19, %esi)

d251 3
d259 6
d266 7
a272 7
	/* Load segment registers. */
	movl	$GSEL(GCPU_SEL, SEL_KPL),%eax
	HALTT(0x26,%eax)	
	movl	%eax,%fs		
	xorl	%eax,%eax
	HALTT(0x27,%eax)		
	movl	%eax,%gs
d280 3
a282 2
	xorl	%esi,%esi
	jmp	_C_LABEL(idle_loop)
@


1.1.2.5
log
@LAPIC access need to be 32 bits, also load %fs with CPU segment
@
text
@d1 1
a1 1
/*	$OpenBSD: mptramp.s,v 1.1.2.4 2003/05/15 04:08:02 niklas Exp $	*/
d181 1
a181 2
	movl	_C_LABEL(local_apic)+LAPIC_ID,%ecx
	shrl	$LAPIC_ID_SHIFT,%ecx
@


