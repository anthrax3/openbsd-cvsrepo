head	1.62;
access;
symbols
	OPENBSD_6_1_BASE:1.62
	OPENBSD_6_0:1.60.0.2
	OPENBSD_6_0_BASE:1.60
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.59.0.4
	OPENBSD_5_8_BASE:1.59
	OPENBSD_5_7:1.57.0.2
	OPENBSD_5_7_BASE:1.57
	OPENBSD_5_6:1.55.0.4
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.51.0.4
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.49.0.2
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.46.0.2
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.43.0.2
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.6
	OPENBSD_5_0:1.41.0.4
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.2
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.22.0.4
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.3.0.2
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.1.0.2
	OPENBSD_3_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.62
date	2017.03.27.18.32.53;	author mlarkin;	state Exp;
branches;
next	1.61;
commitid	V2XqR4UPWQnnGV9h;

1.61
date	2017.03.27.18.24.08;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	KkdbYCyrebNljBOz;

1.60
date	2016.05.20.02.30.41;	author mlarkin;	state Exp;
branches;
next	1.59;
commitid	F5BmBZzZKQUK5NHq;

1.59
date	2015.05.30.08.41.30;	author kettenis;	state Exp;
branches;
next	1.58;
commitid	WTgCsX48WglrjG8M;

1.58
date	2015.03.16.20.31.47;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	UF5MXB4OGf08laCK;

1.57
date	2014.11.16.12.30.57;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	yv0ECmCdICvq576h;

1.56
date	2014.09.19.20.02.25;	author kettenis;	state Exp;
branches;
next	1.55;
commitid	lZNawJpIJwhgF8VB;

1.55
date	2014.07.16.07.42.50;	author mlarkin;	state Exp;
branches;
next	1.54;
commitid	BhZaVf1oRCQi7Ocn;

1.54
date	2014.06.08.17.53.14;	author daniel;	state Exp;
branches;
next	1.53;
commitid	qaHw3cZiWo1gKs8f;

1.53
date	2014.04.25.14.37.06;	author mlarkin;	state Exp;
branches;
next	1.52;

1.52
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.51;

1.51
date	2014.01.24.21.20.23;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2013.12.19.21.30.02;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2013.07.01.09.37.04;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2013.03.20.21.23.05;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2013.03.19.06.46.28;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2012.11.27.17.38.45;	author pirofti;	state Exp;
branches;
next	1.45;

1.45
date	2012.10.17.22.49.27;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2012.10.08.21.47.48;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2012.06.20.17.31.55;	author mlarkin;	state Exp;
branches;
next	1.42;

1.42
date	2012.03.26.16.15.42;	author mlarkin;	state Exp;
branches;
next	1.41;

1.41
date	2010.10.06.18.21.09;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2010.10.06.16.37.32;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2010.08.11.21.22.44;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2010.08.08.21.23.41;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.29.00.29.49;	author mlarkin;	state Exp;
branches;
next	1.36;

1.36
date	2010.07.27.16.53.10;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2010.07.25.21.43.35;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.06.06.25.55;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2010.07.01.21.45.03;	author mlarkin;	state Exp;
branches;
next	1.32;

1.32
date	2010.07.01.03.22.12;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2010.07.01.00.48.48;	author mlarkin;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2010.04.07.06.33.06;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2010.02.23.21.54.53;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.29.21.21.06;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.26.22.08.30;	author mlarkin;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.24.17.39.59;	author mlarkin;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.23.16.21.54;	author pirofti;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.13.15.33.20;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.07.16.58.28;	author mlarkin;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.06.00.21.53;	author mlarkin;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.04.23.48.00;	author mlarkin;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.03.19.05.34;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.31.03.42.38;	author mlarkin;	state Exp;
branches;
next	1.17;

1.17
date	2009.02.19.21.02.05;	author marco;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.20.20.21.03;	author mlarkin;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.28.22.27.10;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.26.17.09.52;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.01.17.59.55;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2008.02.05.22.00.54;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2007.12.05.19.17.13;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.25.15.42.15;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.25.09.11.12;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.16.02.45.56;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.15.22.19.13;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.29.08.22.14;	author gwk;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.29.11.16.25;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.28.13.00.51;	author dim;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.20.05.14.09;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.13.14.23.26;	author martin;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.02.20.09.39;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.62
log
@add a newline to an error printf
@
text
@/*	$OpenBSD: acpi_machdep.c,v 1.61 2017/03/27 18:24:08 deraadt Exp $	*/
/*
 * Copyright (c) 2005 Thorsten Lockert <tholo@@sigmasoft.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/memrange.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/reboot.h>
#include <sys/hibernate.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/conf.h>
#include <machine/acpiapm.h>
#include <i386/isa/isa_machdep.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/cpuvar.h>
#include <machine/npx.h>

#include <dev/isa/isareg.h>
#include <dev/acpi/acpireg.h>
#include <dev/acpi/acpivar.h>
#include <dev/acpi/acpidev.h>

#include "apm.h"
#include "isa.h"
#include "ioapic.h"
#include "lapic.h"

#if NIOAPIC > 0
#include <machine/i82093var.h>
#endif

#if NLAPIC > 0
#include <machine/apicvar.h>
#include <machine/i82489reg.h>
#include <machine/i82489var.h>
#endif

#if NAPM > 0
int haveacpibutusingapm;
#endif

extern u_char acpi_real_mode_resume[], acpi_resume_end[];
extern u_char acpi_tramp_data_start[], acpi_tramp_data_end[];

extern int acpi_savecpu(void) __returns_twice;
extern void intr_calculatemasks(void);

#define ACPI_BIOS_RSDP_WINDOW_BASE        0xe0000
#define ACPI_BIOS_RSDP_WINDOW_SIZE        0x20000

u_int8_t	*acpi_scan(struct acpi_mem_map *, paddr_t, size_t);

int
acpi_map(paddr_t pa, size_t len, struct acpi_mem_map *handle)
{
	paddr_t pgpa = trunc_page(pa);
	paddr_t endpa = round_page(pa + len);
	vaddr_t va = uvm_km_valloc(kernel_map, endpa - pgpa);

	if (va == 0)
		return (ENOMEM);

	handle->baseva = va;
	handle->va = (u_int8_t *)(va + (u_long)(pa & PGOFSET));
	handle->vsize = endpa - pgpa;
	handle->pa = pa;

	do {
		pmap_kenter_pa(va, pgpa, PROT_READ | PROT_WRITE);
		va += NBPG;
		pgpa += NBPG;
	} while (pgpa < endpa);

	return 0;
}

void
acpi_unmap(struct acpi_mem_map *handle)
{
	pmap_kremove(handle->baseva, handle->vsize);
	uvm_km_free(kernel_map, handle->baseva, handle->vsize);
}

u_int8_t *
acpi_scan(struct acpi_mem_map *handle, paddr_t pa, size_t len)
{
	size_t i;
	u_int8_t *ptr;
	struct acpi_rsdp1 *rsdp;

	if (acpi_map(pa, len, handle))
		return (NULL);
	for (ptr = handle->va, i = 0; i < len; ptr += 16, i += 16) {
		/* is there a valid signature? */
		if (memcmp(ptr, RSDP_SIG, sizeof(RSDP_SIG) - 1))
			continue;

		/* is the checksum valid? */
		if (acpi_checksum(ptr, sizeof(struct acpi_rsdp1)) != 0)
			continue;

		/* check the extended checksum as needed */
		rsdp = (struct acpi_rsdp1 *)ptr;
		if (rsdp->revision == 0)
			return (ptr);
		else if (rsdp->revision >= 2 && rsdp->revision <= 4)
			if (acpi_checksum(ptr, sizeof(struct acpi_rsdp)) == 0)
				return (ptr);
	}
	acpi_unmap(handle);

	return (NULL);
}

int
acpi_probe(struct device *parent, struct cfdata *match,
    struct bios_attach_args *ba)
{
	struct acpi_mem_map handle;
	u_int8_t *ptr;
	paddr_t ebda;
#if NAPM > 0
	extern int apm_attached;
#endif

	/*
	 * First try to find ACPI table entries in the EBDA
	 */
	if (acpi_map(0, NBPG, &handle))
		printf("acpi: failed to map BIOS data area\n");
	else {
		ebda = *(const u_int16_t *)(&handle.va[0x40e]);
		ebda <<= 4;
		acpi_unmap(&handle);

		if (ebda && ebda < IOM_BEGIN) {
			if ((ptr = acpi_scan(&handle, ebda, 1024)))
				goto havebase;
		}
	}

	/*
	 * Next try to find the ACPI table entries in the
	 * BIOS memory
	 */
	if ((ptr = acpi_scan(&handle, ACPI_BIOS_RSDP_WINDOW_BASE,
	    ACPI_BIOS_RSDP_WINDOW_SIZE)))
		goto havebase;

	return (0);

havebase:
	ba->ba_acpipbase = ptr - handle.va + handle.pa;
	acpi_unmap(&handle);
#if NAPM > 0
	if (apm_attached) {
		haveacpibutusingapm = 1;
		return (0);
	}
#endif

	return (1);
}

/*
 * Acquire the global lock.  If busy, set the pending bit.  The caller
 * will wait for notification from the BIOS that the lock is available
 * and then attempt to acquire it again.
 */
int
acpi_acquire_glk(uint32_t *lock)
{
	uint32_t	new, old;

	do {
		old = *lock;
		new = (old & ~GL_BIT_PENDING) | GL_BIT_OWNED;
		if ((old & GL_BIT_OWNED) != 0)
			new |= GL_BIT_PENDING;
	} while (atomic_cas_uint(lock, old, new) != old);

	return ((new & GL_BIT_PENDING) == 0);
}

/*
 * Release the global lock, returning whether there is a waiter pending.
 * If the BIOS set the pending bit, OSPM must notify the BIOS when it
 * releases the lock.
 */
int
acpi_release_glk(uint32_t *lock)
{
	uint32_t	new, old;

	do {
		old = *lock;
		new = old & ~(GL_BIT_PENDING | GL_BIT_OWNED);
	} while (atomic_cas_uint(lock, old, new) != old);

	return ((old & GL_BIT_PENDING) != 0);
}

void
acpi_attach_machdep(struct acpi_softc *sc)
{
	extern void (*cpuresetfn)(void);

	sc->sc_interrupt = isa_intr_establish(NULL, sc->sc_fadt->sci_int,
	    IST_LEVEL, IPL_TTY, acpi_interrupt, sc, sc->sc_dev.dv_xname);
	cpuresetfn = acpi_reset;

#ifndef SMALL_KERNEL
	acpiapm_open = acpiopen;
	acpiapm_close = acpiclose;
	acpiapm_ioctl = acpiioctl;
	acpiapm_kqfilter = acpikqfilter;

	/*
	 * Sanity check before setting up trampoline.
	 * Ensure the trampoline page sizes are < PAGE_SIZE
	 */
	KASSERT(acpi_resume_end - acpi_real_mode_resume < PAGE_SIZE);
	KASSERT(acpi_tramp_data_end - acpi_tramp_data_start < PAGE_SIZE);

	/* Map ACPI tramp code and data pages RW for copy */
	pmap_kenter_pa(ACPI_TRAMPOLINE, ACPI_TRAMPOLINE,
	    PROT_READ | PROT_WRITE);
	pmap_kenter_pa(ACPI_TRAMP_DATA, ACPI_TRAMP_DATA,
	    PROT_READ | PROT_WRITE);

	/* Fill the trampoline pages with int3 */
	memset((caddr_t)ACPI_TRAMPOLINE, 0xcc, PAGE_SIZE);
	memset((caddr_t)ACPI_TRAMP_DATA, 0xcc, PAGE_SIZE);

	/* Copy over real trampoline pages (code and data) */
	memcpy((caddr_t)ACPI_TRAMPOLINE, acpi_real_mode_resume,
	    acpi_resume_end - acpi_real_mode_resume);
	memcpy((caddr_t)ACPI_TRAMP_DATA, acpi_tramp_data_start,
	    acpi_tramp_data_end - acpi_tramp_data_start);

	/* Unmap, will be remapped in acpi_sleep_cpu */
	pmap_kremove(ACPI_TRAMPOLINE, PAGE_SIZE);
	pmap_kremove(ACPI_TRAMP_DATA, PAGE_SIZE);

#endif /* SMALL_KERNEL */
}

#ifndef SMALL_KERNEL

#if NLAPIC > 0
int	save_lapic_tpr;
#endif

void
acpi_sleep_clocks(struct acpi_softc *sc, int state)
{
	rtcstop();

#if NLAPIC > 0
	save_lapic_tpr = lapic_tpr;
	lapic_disable();
#endif
}

/*
 * Start the clocks early because AML will be executed next
 * which might do DELAY.
 */ 
void
acpi_resume_clocks(struct acpi_softc *sc)
{
#if NISA > 0
	isa_defaultirq();
#endif
	intr_calculatemasks();

#if NIOAPIC > 0
	ioapic_enable();
#endif

#if NLAPIC > 0
	lapic_tpr = save_lapic_tpr;
	lapic_enable();
	if (initclock_func == lapic_initclocks)
		lapic_startclock();
	lapic_set_lvt();
#endif

	i8254_startclock();
	if (initclock_func == i8254_initclocks)
		rtcstart();		/* in i8254 mode, rtc is profclock */
}
 
/*
 * This function may not have local variables due to a bug between
 * acpi_savecpu() and the resume path.
 */
int
acpi_sleep_cpu(struct acpi_softc *sc, int state)
{
	/* i386 does lazy pmap_activate: switch to kernel memory view */
	pmap_activate(curproc);

	/*
	 * ACPI defines two wakeup vectors. One is used for ACPI 1.0
	 * implementations - it's in the FACS table as wakeup_vector and
	 * indicates a 32-bit physical address containing real-mode wakeup
	 * code.
	 *
	 * The second wakeup vector is in the FACS table as
	 * x_wakeup_vector and indicates a 64-bit physical address
	 * containing protected-mode wakeup code.
	 */
	sc->sc_facs->wakeup_vector = (u_int32_t)ACPI_TRAMPOLINE;
	if (sc->sc_facs->length > 32 && sc->sc_facs->version >= 1)
		sc->sc_facs->x_wakeup_vector = 0;

	/* Map trampoline and data page */
	pmap_kenter_pa(ACPI_TRAMPOLINE, ACPI_TRAMPOLINE, PROT_READ | PROT_EXEC);
	pmap_kenter_pa(ACPI_TRAMP_DATA, ACPI_TRAMP_DATA,
	    PROT_READ | PROT_WRITE);

	/* Copy the current cpu registers into a safe place for resume.
	 * acpi_savecpu actually returns twice - once in the suspend
	 * path and once in the resume path (see setjmp(3)).
	 */
	if (acpi_savecpu()) {
		/* Suspend path */
		npxsave_cpu(curcpu(), 1);
		wbinvd();

#ifdef HIBERNATE
		if (state == ACPI_STATE_S4) {
			if (hibernate_suspend()) {
				printf("%s: hibernate_suspend failed\n",
				    DEVNAME(sc));
				return (ECANCELED);
			}
		}
#endif

		/* XXX
		 * Flag to disk drivers that they should "power down" the disk
		 * when we get to DVACT_POWERDOWN.
		 */
		boothowto |= RB_POWERDOWN;
		config_suspend_all(DVACT_POWERDOWN);
		boothowto &= ~RB_POWERDOWN;

		acpi_sleep_pm(sc, state);
		printf("%s: acpi_sleep_pm failed", DEVNAME(sc));
		return (ECANCELED);
	}
	/* Resume path */

	/* Reset the vectors */
	sc->sc_facs->wakeup_vector = 0;
	if (sc->sc_facs->length > 32 && sc->sc_facs->version >= 1)
		sc->sc_facs->x_wakeup_vector = 0;

	pmap_kremove(ACPI_TRAMPOLINE, PAGE_SIZE);
	pmap_kremove(ACPI_TRAMP_DATA, PAGE_SIZE);

	return (0);
}

void
acpi_resume_cpu(struct acpi_softc *sc)
{
	npxinit(&cpu_info_primary);

	cpu_init(&cpu_info_primary);
	
	/* Re-initialise memory range handling on BSP */
	if (mem_range_softc.mr_op != NULL)
		mem_range_softc.mr_op->initAP(&mem_range_softc);
}

#ifdef MULTIPROCESSOR
void
acpi_sleep_mp(void)
{
	int i;

	sched_stop_secondary_cpus();
	KASSERT(CPU_IS_PRIMARY(curcpu()));

	/* 
	 * Wait for cpus to halt so we know their FPU state has been
	 * saved and their caches have been written back.
	 */
	i386_broadcast_ipi(I386_IPI_HALT);
	for (i = 0; i < ncpus; i++) {
		struct cpu_info *ci = cpu_info[i];

		if (CPU_IS_PRIMARY(ci))
			continue;
		while (ci->ci_flags & CPUF_RUNNING)
			;
	}
}

void
acpi_resume_mp(void)
{
	struct cpu_info *ci;
	struct proc *p;
	struct pcb *pcb;
	struct trapframe *tf;
	struct switchframe *sf;
	int i;

	/* XXX refactor with matching code in cpu.c */

	for (i = 0; i < MAXCPUS; i++) {
		ci = cpu_info[i];
		if (ci == NULL)
			continue;
		if (ci->ci_idle_pcb == NULL)
			continue;
		if (ci->ci_flags & (CPUF_BSP|CPUF_SP|CPUF_PRIMARY))
			continue;
		KASSERT((ci->ci_flags & CPUF_RUNNING) == 0);

		p = ci->ci_schedstate.spc_idleproc;
		pcb = &p->p_addr->u_pcb;

		tf = (struct trapframe *)pcb->pcb_tss.tss_esp0 - 1;
		sf = (struct switchframe *)tf - 1;
		sf->sf_esi = (int)sched_idle;
		sf->sf_ebx = (int)ci;
		sf->sf_eip = (int)proc_trampoline;
		pcb->pcb_esp = (int)sf;

		ci->ci_idepth = 0;
	}

	cpu_boot_secondary_processors();
	sched_start_secondary_cpus();
}
#endif /* MULTIPROCESSOR */

#endif /* ! SMALL_KERNEL */
@


1.61
log
@hibernate_free() should not be called from MD code, acpi_sleep_state()
unwinds that.  Upon hibernate fail, this was a collection of double-frees..
ok claudio mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.60 2016/05/20 02:30:41 mlarkin Exp $	*/
d358 1
a358 1
				printf("%s: hibernate_suspend failed",
@


1.60
log
@
split the ACPI resume trampoline into code and data pages, and protect
with proper permissions. Same treatment was done on amd64 last year, i386
is catching up.

This diff has been in snaps for a few days, no regressions reported.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.59 2015/05/30 08:41:30 kettenis Exp $	*/
a359 1
				hibernate_free();
@


1.59
log
@Native atomic operations for i386.

ok deraadt@@, guenther@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.58 2015/03/16 20:31:47 deraadt Exp $	*/
d66 1
d243 1
a243 1
	 * Ensure the trampoline size is < PAGE_SIZE
d246 1
d248 12
a259 1
	bcopy(acpi_real_mode_resume, (caddr_t)ACPI_TRAMPOLINE,
d261 7
d341 5
d384 3
@


1.58
log
@Reduce use of SMALL_KERNEL in acpi, bringing acpiec driver and more gpe
handling into RAMDISK.  This is now possible because the install media
has ample room.  The goal is to reduce special cases where we may be
skipping (unknown) important operations...
ok mlarkin kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.57 2014/11/16 12:30:57 deraadt Exp $	*/
d202 1
a202 1
	} while (i386_atomic_cas_int32(lock, old, new) != old);
d220 1
a220 1
	} while (i386_atomic_cas_int32(lock, old, new) != old);
@


1.57
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.56 2014/09/19 20:02:25 kettenis Exp $	*/
a224 2
#ifndef SMALL_KERNEL

d232 3
a238 1
	cpuresetfn = acpi_reset;
d248 1
d250 2
@


1.56
log
@Use config_suspend_all(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.55 2014/07/16 07:42:50 mlarkin Exp $	*/
d91 1
a91 1
		pmap_kenter_pa(va, pgpa, VM_PROT_READ | VM_PROT_WRITE);
@


1.55
log
@

Reenable hibernate RLE support and flush+zero all memory after unpack.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.54 2014/06/08 17:53:14 daniel Exp $	*/
d343 1
a343 1
		config_suspend(device_mainbus(), DVACT_POWERDOWN);
@


1.54
log
@check both rsdp checksums in the case of rsdp revision >= 2.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.53 2014/04/25 14:37:06 mlarkin Exp $	*/
a328 1
			uvm_pmr_zero_everything();
a332 1
				uvm_pmr_dirty_everything();
@


1.53
log
@

Defer the free of the hibernate structures until later, when it is safe to
do so.

Freeing the hibernate structures too early leads to inadvertent calls into
splx when we aren't ready for them yet. Found when trapping splx calls in
the resume path.

discussed with deraadt@@ at m2k14
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.52 2014/03/13 03:52:55 dlg Exp $	*/
d115 15
a129 11
	for (ptr = handle->va, i = 0;
	     i < len;
	     ptr += 16, i += 16)
		if (memcmp(ptr, RSDP_SIG, sizeof(RSDP_SIG) - 1) == 0) {
			rsdp = (struct acpi_rsdp1 *)ptr;
			/*
			 * Only checksum whichever portion of the
			 * RSDP that is actually present
			 */
			if (rsdp->revision == 0 &&
			    acpi_checksum(ptr, sizeof(struct acpi_rsdp1)) == 0)
d131 1
a131 4
			else if (rsdp->revision >= 2 && rsdp->revision <= 4 &&
			    acpi_checksum(ptr, sizeof(struct acpi_rsdp)) == 0)
				return (ptr);
		}
@


1.52
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.51 2014/01/24 21:20:23 kettenis Exp $	*/
a351 7

#ifdef HIBERNATE
	if (state == ACPI_STATE_S4) {
		hibernate_free();
		uvm_pmr_dirty_everything();
	}
#endif
@


1.51
log
@Disable lapic when halting CPUs.  Allegedly this is necessary to make
suspend work on some machines.

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.50 2013/12/19 21:30:02 deraadt Exp $	*/
d344 1
a344 1
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.50
log
@Mtrr stops being a pseudo-device.  We need to probe the cpu type and
initialize the structures when we see the first cpu.  We also need to
initialize each cpu's properly (for PAT) before we setup mtrr on that
cpu.  On i386 (late hatch) we were getting this desperately wrong on
the primary cpu.

After suspend/resume, we also need to do the same work.  re-initialize
PAT before mtrr.  On some laptops apparently PAT was not turned on by the
BIOS, so we ended up with incorrect setup for the primary cpu.  Oops.

This makes mplayer on the x201 (and similar) machines work without weird
pauses after a suspend/resume.  Many other things are likely fixed.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.49 2013/07/01 09:37:04 kettenis Exp $	*/
d257 1
d260 1
@


1.49
log
@Make the acpi global lock functions actually work.  Luckily these functions
were still unused.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.48 2013/03/20 21:23:05 kettenis Exp $	*/
d369 4
a375 1
	npxinit(&cpu_info_primary);
@


1.48
log
@Previous commit to acpi_machdep.c broke suspend because the IPI to save the
FPU state needs a little bit more setup.  Fix things properly this time by
simplifying matters and saving the FPU state from the IPI that halts the
CPU.  With help from deraadt@@ and mlarkin@@.

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.47 2013/03/19 06:46:28 deraadt Exp $	*/
d201 1
a201 1
	} while (i386_atomic_cas_int32(lock, old, new) == 0);
d219 1
a219 1
	} while (i386_atomic_cas_int32(lock, old, new) == 0);
@


1.47
log
@in acpi_sleep_mp() properly flush fpu and halt the AP's
found when i told mlarkin to look at it for re-use in a different place
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.46 2012/11/27 17:38:45 pirofti Exp $	*/
d377 1
a377 1
acpi_sleep_mp()
d384 4
a387 12
	/* Wait for cpus to save their floating point context */
	i386_broadcast_ipi(I386_IPI_SYNCH_FPU);
	for (i = 0; i < ncpus; i++) {
		struct cpu_info *ci = cpu_info[i];

		if (CPU_IS_PRIMARY(ci))
			continue;
		while (ci->ci_fpcurproc)
			;
	}

	/* Wait for cpus to halt so we know their caches are written back */
@


1.46
log
@Add acpi_{acquire,release}_glk locking functions.

These functions represent the basic blocks for using the ACPI global
lock that provides mutual exclusion between the OSPM and the BIOS.

No functional change. Okay kettenis@@, deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.45 2012/10/17 22:49:27 deraadt Exp $	*/
d389 3
a391 1
		while (!CPU_IS_PRIMARY(curcpu()) && ci->ci_fpcurproc)
d400 3
a402 2
		while (!CPU_IS_PRIMARY(curcpu()) &&
		    (ci->ci_flags & CPUF_RUNNING))
@


1.45
log
@Document the 'boothowto hack' used to flag to (a few) DVACT_POWERDOWN
handlers how hard they should hit the hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.45 2012/10/17 22:43:48 deraadt Exp $	*/
d184 38
@


1.44
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.43 2012/06/20 17:31:55 mlarkin Exp $	*/
d299 4
@


1.43
log
@

Fix some hibernate issues on machines with > 3.5GB phys mem

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.42 2012/03/26 16:15:42 mlarkin Exp $	*/
d26 1
d211 4
d216 1
a216 1
acpi_cpu_flush(struct acpi_softc *sc, int state)
d218 4
a221 5
	/*
	 * Flush write back caches since we'll lose them.
	 */
	if (state > ACPI_STATE_S1)
		wbinvd();
d224 6
a229 2
int
acpi_sleep_machdep(struct acpi_softc *sc, int state)
d231 4
a234 1
	int s;
d236 3
a238 4
	if (sc->sc_facs == NULL) {
		printf("%s: acpi_sleep_machdep: no FACS\n", DEVNAME(sc));
		return (ENXIO);
	}
d240 7
a246 1
	rtcstop();
d248 13
a260 1
	/* i386 does lazy pmap_activate */
a263 6
	 * The local apic may lose its state, so save the Task
	 * Priority register where we keep the system priority level.
	 */
	s = lapic_tpr;

	/*
a283 4
#ifdef MULTIPROCESSOR
		i386_broadcast_ipi(I386_IPI_SYNCH_FPU);
		i386_broadcast_ipi(I386_IPI_HALT);
#endif
d285 1
d289 7
a295 2
			if (hibernate_suspend())
				panic("%s: hibernate failed", DEVNAME(sc));
d298 8
a305 2
		acpi_enter_sleep_state(sc, state);
		panic("%s: acpi_enter_sleep_state failed", DEVNAME(sc));
d307 1
a307 2

	/* Resume path continues here */
a309 1
	/* Free piglet and other pages allocated during suspend */
d316 1
a316 1
	/* Reset the vector */
d318 2
d321 2
a322 2
	/* Restore the Task Priority register */
	lapic_tpr = s;
d324 8
a331 4
#if NISA > 0
	isa_defaultirq();
#endif
	intr_calculatemasks();
d333 5
a337 6
#if NLAPIC > 0
	lapic_enable();
	if (initclock_func == lapic_initclocks)
		lapic_startclock();
	lapic_set_lvt();
#endif
d339 2
a340 1
	npxinit(&cpu_info_primary);
d342 4
a345 3
	/* Re-initialise memory range handling */
	if (mem_range_softc.mr_op != NULL)
		mem_range_softc.mr_op->initAP(&mem_range_softc);
d347 3
a349 7
#if NIOAPIC > 0
	ioapic_enable();
#endif
	i8254_startclock();
	if (initclock_func == i8254_initclocks)
		rtcstart();		/* in i8254 mode, rtc is profclock */
	inittodr(time_second);
d351 9
a359 1
	return (0);
d363 1
a363 1
acpi_resume_machdep(void)
a364 1
#ifdef MULTIPROCESSOR
d398 2
d401 1
a401 1
}
@


1.42
log
@

Fix an integer math error when using the result of uvm_page_rle, and
at the same time increase said function's max RLE page count return value.

Add hooks in the right places to call the hibernate suspend and resume
routines, so that we can enable hibernation with a HIBERNATE option
line in GENERIC and appropriate acpi.c goo.

discussed on and off with deraadt@@ over the past few months
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.41 2010/10/06 18:21:09 kettenis Exp $	*/
d268 2
a269 1
		if (state == ACPI_STATE_S4)
d272 1
d282 1
a282 1
	if (state == ACPI_STATE_S4)
d284 2
@


1.41
log
@Save and restore the lapic Task Priority register accross suspend/resume,
otherwise we wake up at IPL_NONE instead of IPL_HIGH.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.40 2010/10/06 16:37:32 deraadt Exp $	*/
d26 1
d267 5
d277 6
@


1.40
log
@Correct the condition under which the x_wakeup_vector is cleared.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.39 2010/08/11 21:22:44 kettenis Exp $	*/
d222 2
d235 6
d274 3
@


1.39
log
@Disable the RTC the periodic interrupt.  Leaving it enabled causes the
Dell Inspirion 4150 to wake up immediately even though RTC_EN isn't set
in the PM1 Enable register.

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.38 2010/08/08 21:23:41 deraadt Exp $	*/
a232 1
	 *
a240 1
	 *
d243 1
a243 1
	if (sc->sc_facs->version == 1)
@


1.38
log
@Accept "ACPI 4" or such, bug in laptop or spec? -- Thinkpad SL510
from marco, ok kettenis, hard to argue with it making the laptop work
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.37 2010/07/29 00:29:49 mlarkin Exp $	*/
d226 2
@


1.37
log
@

Zero out the firmware waking vector on successful resume from ACPI sleep.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.36 2010/07/27 16:53:10 deraadt Exp $	*/
d125 1
a125 1
			else if (rsdp->revision >= 2 && rsdp->revision <= 3 &&
@


1.36
log
@delete a #if 0 chunk which was used for early development and will never
be reused
ok jordan
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.35 2010/07/25 21:43:35 deraadt Exp $	*/
d263 3
@


1.35
log
@in the clock drivers, seperate the soft-state and hard-state which was
all jumbled up in the same functions. the rtc (mc chip) and clock (i8243)
startup was also mixed up.  they the soft state and hardware state can
be started in the right order, and it is easy to restart just the
neccessary parts upon resume.  tested in numerous cases:
(apic, pic) * (GENERIC.MP, GENERIC) * (mp, non-mp) * (i386, amd64)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.34 2010/07/06 06:25:55 deraadt Exp $	*/
a262 5
#if 0
        /* Temporarily disabled for debugging purposes */
        /* Reset the wakeup vector to avoid resuming on reboot */
        sc->sc_facs->wakeup_vector = 0;
#endif
@


1.34
log
@get rid of ridiculous differences between the i386 and amd64 versions
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.33 2010/07/01 21:45:03 mlarkin Exp $	*/
d276 2
a277 1
	lapic_initclocks();
d290 3
a292 1
	initrtclock();
@


1.33
log
@

Synch instead of flush FPU state on APs before suspending.

tested by kettenis@@ on i386 and myself on amd64
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.32 2010/07/01 03:22:12 jsg Exp $	*/
d60 1
a60 1
int haveacpibutusingapm;	
d249 1
a249 1
	 */ 
d267 1
a267 1
#endif	
a333 1

@


1.32
log
@mark acpi_savecpu with the gcc returns_twice attribute as suggested
by deraadt so the stack will be sane during suspend/resume with gcc4.
Noticed on i386 due to the lack of general purpose registers compared
to amd64.

ok deraadt@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.31 2010/07/01 00:48:48 mlarkin Exp $	*/
d254 1
a254 1
		i386_broadcast_ipi(I386_IPI_FLUSH_FPU);
@


1.31
log
@

More accurate comment as to what happens with acpi_savecpu

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.30 2010/04/20 22:05:41 tedu Exp $	*/
d65 1
a65 1
extern int acpi_savecpu(void);
@


1.30
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.29 2010/04/07 06:33:06 kettenis Exp $	*/
d246 4
a249 1
	/* Copy the current cpu registers into a safe place for resume. */
d251 1
d262 1
a262 9
	/*
	 * On resume, the execution path will actually occur here.
	 * This is because we previously saved the stack location
	 * in acpi_savecpu, and issued a far jmp to the restore
	 * routine in the wakeup code. This means we are
	 * returning to the location immediately following the
	 * last call instruction - after the call to acpi_savecpu.
	 */
	
@


1.29
log
@Make suspend/resume work on MP machines (running an MP kernel).  Joint work
from mlarkin@@ and me, with some amd64 fixes thrown in by deraadt@@

ok marco@@, deraadt@@, pirofti@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.28 2010/02/23 21:54:53 kettenis Exp $	*/
d24 1
@


1.28
log
@Restore MTRRs on resume.

ok oga@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.27 2009/11/29 21:21:06 deraadt Exp $	*/
d24 1
d33 1
d35 1
d248 4
d296 40
@


1.27
log
@At suspend time there is no need for a fancy cr3 dance to decide if
pmap_activate() should be called to force the kthread into the kernel pmap.
If it is i386 it is lazy pmap it may not be in the kernel kthread, so
it must be called so that pmap_activate can decide.  If it is amd64
without lazy pmap, it must not be called.
A comment is added to remind us about this in the future in case these
assumptions change.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.26 2009/11/26 22:08:30 mlarkin Exp $	*/
d23 1
d277 4
@


1.26
log
@

Reset the wakeup vector to ensure that we don't resume on reboot.
Temporarily disabled for debugging purposes, but can be turned on if
needed.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.25 2009/11/24 17:39:59 mlarkin Exp $	*/
d222 2
a223 5
	if (rcr3() != pmap_kernel()->pm_pdirpa) {
		pmap_activate(curproc);

		KASSERT(rcr3() == pmap_kernel()->pm_pdirpa);
	}
@


1.25
log
@

Save FPU state before suspend.

ok deraadt@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.24 2009/11/23 16:21:54 pirofti Exp $	*/
d261 6
@


1.24
log
@Remove ACPI_SLEEP_ENABLED checks.

This enables by default the suspend/resume paths in the kernel.

Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.23 2009/08/13 15:33:20 kettenis Exp $	*/
d246 1
@


1.23
log
@Cleanup differences between i386 and amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.22 2009/06/07 16:58:28 mlarkin Exp $	*/
a193 1
#ifdef ACPI_SLEEP_ENABLED
a201 1
#endif /* ACPI_SLEEP_ENABLED */
a216 1
#ifdef ACPI_SLEEP_ENABLED
a277 1
#endif /* ACPI_SLEEP_ENABLED */
@


1.22
log
@
We weren't including isa.h and therefore missing the NISA #define. This
caused the PIC to not be initialized on resume, which caused much
badness - things attached to the ISA bus weren't getting any
interupts (for example, keyboards).

Also move around some of the lapic reinit code to handle some clock
initialization bits we weren't doing before.

Worked out by deraadt and myself.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.21 2009/06/06 00:21:53 mlarkin Exp $	*/
a32 1
#include <machine/intr.h>
a53 1

d130 2
a131 1
acpi_probe(struct device *parent, struct cfdata *match, struct bios_attach_args *ba)
d175 1
d180 1
d194 1
a194 1
#ifdef ACPI_SLEEP_ENABLED  
d200 3
a202 1
	bcopy(acpi_real_mode_resume, (caddr_t)ACPI_TRAMPOLINE, acpi_resume_end - acpi_real_mode_resume);
d209 3
a211 1
	/* flush write back caches since we'll lose them  */
a219 1

d281 1
a282 1
#endif /* ACPI_SLEEP_ENABLED */
d285 1
@


1.21
log
@
Fix some lapic, interrupt, and clock issues on i386 ACPI S3 resume.
(Allows time to flow forward after resume)

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.20 2009/06/04 23:48:00 mlarkin Exp $	*/
d41 1
d258 1
a258 2

	npxinit(&cpu_info_primary);
d263 1
d267 1
d269 3
@


1.20
log
@
Change i386 ACPI sleep to KASSERT if the pmap can't be activated
properly. Now i386 and amd64 implementations match.

ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.19 2009/06/03 19:05:34 art Exp $	*/
d33 1
d44 4
d61 2
a62 5
int acpi_savecpu(void);
void intr_calculatemasks(void);
void acpi_cpu_flush(struct acpi_softc *, int);
void ioapic_enable(void);
void lapic_enable(void);
d259 1
d261 1
d265 1
a265 1
	lapic_calibrate_timer(&cpu_info_primary);
d271 1
a271 1
	enable_intr();
@


1.19
log
@Make sure we're running on the right pmap when going to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.18 2009/05/31 03:42:38 mlarkin Exp $	*/
d220 2
a221 5
		if (rcr3() != pmap_kernel()->pm_pdirpa) {
			printf("%s: acpi_sleep_machdep: only kernel thread\n",
			    DEVNAME(sc));
			return (ENXIO);
		}
@


1.18
log
@Reinitialize lapic on ACPI resume.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.17 2009/02/19 21:02:05 marco Exp $	*/
d219 6
a224 3
		printf("%s: acpi_sleep_machdep: only kernel may sleep\n",
		    DEVNAME(sc));
		return (ENXIO);
@


1.17
log
@suspend/resume bits so that we can develop this in tree.  This is disabled.
code from mlarkin and me
help from art,toby,jordan and several others
ok jordan, go for it deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.16 2009/01/20 20:21:03 mlarkin Exp $	*/
d40 9
d59 2
a211 1
	u_long ef;
a239 2
	ef = read_eflags();

d259 4
d268 1
a268 1
	write_eflags(ef);
@


1.16
log
@
Install ACPI S3 resume trampoline code in a lowmem page. First part
of ACPI S3 suspend/resume support. This is for i386.

Help/comments from art, toby, marco, jordan, kurt
ok marco@@, kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.15 2008/12/28 22:27:10 kettenis Exp $	*/
d37 1
d48 2
a179 1

a184 1

d187 20
d208 51
@


1.15
log
@No longer look for RSDP in memory marked as "ACPI Reclaim" in the BIOS memory
map.  The standard doesn't tell us to look there, Linux and NetBSD don't look
there either. It seems that some BIOSes use this memory as a scratch area
to build the final ACPI tables which means we can accidentally find what
seems like a valid RSDP there.  Fixes PR 5847.

ok krw@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.14 2008/12/26 17:09:52 deraadt Exp $	*/
d31 3
d44 4
d175 12
d188 1
a188 1
#endif /* SMALL_KERNEL */
@


1.14
log
@If we have usable acpi, but chose to use amp instead for various reasons,
then mpbios should not be used because it is probably full of lies.
ok kettenis, though he hates the variable name used.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.13 2008/06/01 17:59:55 marco Exp $	*/
a34 1
#include "bios.h"
a36 4
#if NBIOS > 0
#include <machine/biosvar.h>
#endif

a116 15
#if NBIOS > 0
	{
		bios_memmap_t *im;

		/*
	 	 * First look for ACPI entries in the BIOS memory map
		 */
		for (im = bios_memmap; im->type != BIOS_MAP_END; im++)
			if (im->type == BIOS_MAP_ACPI) {
				if ((ptr = acpi_scan(&handle, im->addr, im->size)))
					goto havebase;
			}
	}
#endif

d118 1
a118 1
	 * Next try to find ACPI table entries in the EBDA
d134 1
a134 1
	 * Finally try to find the ACPI table entries in the
@


1.13
log
@Re-enable new parser.  Lots of testing by various folks.  Fits all media
now too.

ok kettenis deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.12 2008/02/05 22:00:54 marco Exp $	*/
d42 4
a48 4
#if NAPM > 0 && NBIOS > 0
extern bios_apminfo_t *apm;
#endif

d120 1
a121 3
	if (apm_attached)
		return (0);
#endif
d166 6
a171 1

@


1.12
log
@ACPI 3.0 seems to work just fine so lets enable it.

Idea from fulvio ciriaco <oivulf@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.11 2007/12/05 19:17:13 deraadt Exp $	*/
d172 1
d186 1
@


1.11
log
@Hang acpi(4) below bios(4) instead of mainbus(4).  This lets us move acpi(4)
before pcibios(4), and then.... if acpi(4) attaches, skip pcibios(4) since
it messes the machines up.  Fixes claudio's HP dl320 G5, and almost assuredly
others.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.10 2007/11/25 15:42:15 tedu Exp $	*/
d103 1
a103 1
			else if (rsdp->revision == 2 &&
@


1.10
log
@fake out the apm device to switch between apm and acpi on i386.  now
a single device node will talk to the right kernel code automatically.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.9 2007/11/25 09:11:12 jsg Exp $	*/
d113 1
a113 1
acpi_probe(struct device *parent, struct cfdata *match, struct acpi_attach_args *aaa)
d166 1
a166 1
	aaa->aaa_pbase = ptr - handle.va + handle.pa;
d176 1
@


1.9
log
@When available and ACPI is enabled use the ACPI reset method
to reboot.  This is required for some quirky sis machines
and likely others to reboot.

Tested by many. 'commit early commit often' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.8 2007/11/16 02:45:56 deraadt Exp $	*/
d27 2
d178 4
@


1.8
log
@do not make up a device name for interrupts.. give it the dv_xname
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.7 2007/11/15 22:19:13 deraadt Exp $	*/
d173 1
d176 1
@


1.7
log
@remove the #ifdef ACPI_ENABLE.  the EC codepath is either safe enough (and
will be improved), or it is unsafe because AML assumes it must be there
ok almost everyone
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.6 2007/05/29 08:22:14 gwk Exp $	*/
d174 1
a174 1
	    IST_LEVEL, IPL_TTY, acpi_interrupt, sc, "acpi");
@


1.6
log
@Add global variable apm_attached, machine dependant probe routine for ACPI
will check this flag durring probe, meaning that if the machine has APM
ACPI will not attach. This should remove one obstacle on the road to
enabling ACPI by default.

ok marco, dreaadt, art, krw, art
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.5 2006/11/29 11:16:25 kettenis Exp $	*/
d118 1
a118 1
	
d120 1
a120 1
		return (0);	
a172 1
#ifdef ACPI_ENABLE
a174 1
#endif
@


1.5
log
@Only establish acpi interrupt if ACPI_ENABLE.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.4 2006/04/28 13:00:51 dim Exp $	*/
d116 6
d123 2
a124 1
	bios_memmap_t *im;
d126 9
a134 8
	/*
	 * First look for ACPI entries in the BIOS memory map
	 */
	for (im = bios_memmap; im->type != BIOS_MAP_END; im++)
		if (im->type == BIOS_MAP_ACPI) {
			if ((ptr = acpi_scan(&handle, im->addr, im->size)))
				goto havebase;
		}
a166 8
#ifdef notyet
	/*
	 * Disable APM if we are using ACPI
	 */
#if NAPM > 0 && NBIOS > 0
	apm = NULL;
#endif
#endif
@


1.4
log
@Fix cast warning in sys/arch/i386/i386/acpi_machdep.c, caused by recent PAE
checkins which change paddr_t for i386 into an unsigned long long.

ok marco
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.3 2006/02/20 05:14:09 marco Exp $	*/
d173 4
a176 2
	sc->sc_interrupt = isa_intr_establish(NULL, sc->sc_fadt->sci_int, IST_LEVEL,
					      IPL_TTY, acpi_interrupt, sc, "acpi");
@


1.3
log
@Region has to be read/write not just read.
ok jordan

Pointed out by Bjorn Andersson <bjorn at silversmedjan dot se>
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.2 2005/11/13 14:23:26 martin Exp $	*/
d60 1
a60 1
	handle->va = (u_int8_t *)(va + (pa & PGOFSET));
@


1.2
log
@convert more MD macros to their MI counterparts, this time
i386_round_page(), i386_trunc_page(), i386_btop() and i386_ptob()
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi_machdep.c,v 1.1 2005/06/02 20:09:39 tholo Exp $	*/
d65 1
a65 1
		pmap_kenter_pa(va, pgpa, VM_PROT_READ);
@


1.1
log
@Start on a basic ACPI framework -- does not do much more than read out the
ACPI tables into kernel memory and attach ACPI and HPET timers currently.

In order to test this code, enabling the devices in GENERIC as well as
the ACPI_ENABLE option is needed.  This code does not do any thermal
control yet, so this should be done with care depending on the platform.

In the tree so more people can contribute to making this more fully
featured.

Ok niklas@@ grange@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 2
a53 2
	paddr_t pgpa = i386_trunc_page(pa);
	paddr_t endpa = i386_round_page(pa + len);
@

