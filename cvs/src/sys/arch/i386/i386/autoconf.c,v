head	1.101;
access;
symbols
	OPENBSD_6_1:1.101.0.6
	OPENBSD_6_1_BASE:1.101
	OPENBSD_6_0:1.101.0.2
	OPENBSD_6_0_BASE:1.101
	OPENBSD_5_9:1.95.0.2
	OPENBSD_5_9_BASE:1.95
	OPENBSD_5_8:1.94.0.4
	OPENBSD_5_8_BASE:1.94
	OPENBSD_5_7:1.92.0.2
	OPENBSD_5_7_BASE:1.92
	OPENBSD_5_6:1.92.0.6
	OPENBSD_5_6_BASE:1.92
	OPENBSD_5_5:1.92.0.4
	OPENBSD_5_5_BASE:1.92
	OPENBSD_5_4:1.91.0.4
	OPENBSD_5_4_BASE:1.91
	OPENBSD_5_3:1.91.0.2
	OPENBSD_5_3_BASE:1.91
	OPENBSD_5_2:1.90.0.2
	OPENBSD_5_2_BASE:1.90
	OPENBSD_5_1_BASE:1.88
	OPENBSD_5_1:1.88.0.4
	OPENBSD_5_0:1.88.0.2
	OPENBSD_5_0_BASE:1.88
	OPENBSD_4_9:1.86.0.2
	OPENBSD_4_9_BASE:1.86
	OPENBSD_4_8:1.85.0.2
	OPENBSD_4_8_BASE:1.85
	OPENBSD_4_7:1.81.0.6
	OPENBSD_4_7_BASE:1.81
	OPENBSD_4_6:1.81.0.8
	OPENBSD_4_6_BASE:1.81
	OPENBSD_4_5:1.81.0.4
	OPENBSD_4_5_BASE:1.81
	OPENBSD_4_4:1.81.0.2
	OPENBSD_4_4_BASE:1.81
	OPENBSD_4_3:1.78.0.2
	OPENBSD_4_3_BASE:1.78
	OPENBSD_4_2:1.75.0.2
	OPENBSD_4_2_BASE:1.75
	OPENBSD_4_1:1.70.0.2
	OPENBSD_4_1_BASE:1.70
	OPENBSD_4_0:1.64.0.2
	OPENBSD_4_0_BASE:1.64
	OPENBSD_3_9:1.56.0.2
	OPENBSD_3_9_BASE:1.56
	OPENBSD_3_8:1.55.0.4
	OPENBSD_3_8_BASE:1.55
	OPENBSD_3_7:1.55.0.2
	OPENBSD_3_7_BASE:1.55
	OPENBSD_3_6:1.54.0.2
	OPENBSD_3_6_BASE:1.54
	SMP_SYNC_A:1.52
	SMP_SYNC_B:1.52
	OPENBSD_3_5:1.52.0.2
	OPENBSD_3_5_BASE:1.52
	OPENBSD_3_4:1.50.0.2
	OPENBSD_3_4_BASE:1.50
	UBC_SYNC_A:1.46
	OPENBSD_3_3:1.46.0.2
	OPENBSD_3_3_BASE:1.46
	OPENBSD_3_2:1.45.0.2
	OPENBSD_3_2_BASE:1.45
	OPENBSD_3_1:1.44.0.2
	OPENBSD_3_1_BASE:1.44
	UBC_SYNC_B:1.45
	UBC:1.41.0.2
	UBC_BASE:1.41
	OPENBSD_3_0:1.36.0.2
	OPENBSD_3_0_BASE:1.36
	OPENBSD_2_9:1.33.0.4
	OPENBSD_2_9_BASE:1.33
	OPENBSD_2_8:1.33.0.2
	OPENBSD_2_8_BASE:1.33
	OPENBSD_2_7:1.31.0.2
	OPENBSD_2_7_BASE:1.31
	SMP:1.30.0.4
	SMP_BASE:1.30
	kame_19991208:1.30
	OPENBSD_2_6:1.30.0.2
	OPENBSD_2_6_BASE:1.30
	OPENBSD_2_5:1.28.0.8
	OPENBSD_2_5_BASE:1.28
	OPENBSD_2_4:1.28.0.6
	OPENBSD_2_4_BASE:1.28
	OPENBSD_2_3:1.28.0.4
	OPENBSD_2_3_BASE:1.28
	OPENBSD_2_2:1.28.0.2
	OPENBSD_2_2_BASE:1.28
	OPENBSD_2_1:1.25.0.2
	OPENBSD_2_1_BASE:1.25
	OPENBSD_2_0:1.14.0.2
	OPENBSD_2_0_BASE:1.14
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.101
date	2016.06.08.17.24.44;	author tedu;	state Exp;
branches;
next	1.100;
commitid	oK6mhkiIMNMJ6OsK;

1.100
date	2016.05.20.02.30.41;	author mlarkin;	state Exp;
branches;
next	1.99;
commitid	F5BmBZzZKQUK5NHq;

1.99
date	2016.05.18.03.45.11;	author mlarkin;	state Exp;
branches;
next	1.98;
commitid	JQz4IJ6cQ8DinMqc;

1.98
date	2016.05.16.05.53.27;	author mlarkin;	state Exp;
branches;
next	1.97;
commitid	yAfyORIU5p3inPOF;

1.97
date	2016.05.16.03.46.55;	author mlarkin;	state Exp;
branches;
next	1.96;
commitid	8ruOHk2DpUaexhgf;

1.96
date	2016.03.15.03.17.50;	author guenther;	state Exp;
branches;
next	1.95;
commitid	hTA8iQcFPhTNwQXL;

1.95
date	2015.12.27.04.31.34;	author jsg;	state Exp;
branches;
next	1.94;
commitid	dxEnyjnljo1QbPFz;

1.94
date	2015.04.24.19.53.43;	author mlarkin;	state Exp;
branches;
next	1.93;
commitid	51Ck2lQM8rn25Q1k;

1.93
date	2015.04.12.18.37.53;	author mlarkin;	state Exp;
branches;
next	1.92;
commitid	5ST94uMTezmXYdhY;

1.92
date	2013.11.19.09.00.43;	author mpi;	state Exp;
branches;
next	1.91;

1.91
date	2012.09.19.20.19.31;	author jsg;	state Exp;
branches;
next	1.90;

1.90
date	2012.07.13.14.50.10;	author mlarkin;	state Exp;
branches;
next	1.89;

1.89
date	2012.03.26.16.15.42;	author mlarkin;	state Exp;
branches;
next	1.88;

1.88
date	2011.06.26.23.19.11;	author tedu;	state Exp;
branches;
next	1.87;

1.87
date	2011.04.25.21.00.08;	author mikeb;	state Exp;
branches;
next	1.86;

1.86
date	2010.11.18.21.13.19;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2010.07.25.21.43.35;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2010.06.28.22.20.12;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2010.06.27.19.21.19;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.81;

1.81
date	2008.07.21.04.35.54;	author todd;	state Exp;
branches;
next	1.80;

1.80
date	2008.05.26.22.49.57;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2008.03.19.05.47.44;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2007.12.27.18.04.27;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2007.12.11.17.53.16;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2007.11.28.17.05.09;	author tedu;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.01.19.25.10;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2007.05.15.01.56.47;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2007.05.04.19.30.55;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2007.05.04.03.44.44;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.01.17.35.56;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2007.02.20.21.15.01;	author tom;	state Exp;
branches;
next	1.69;

1.69
date	2006.11.29.22.40.13;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2006.11.29.19.31.37;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2006.10.29.18.46.52;	author kettenis;	state Exp;
branches;
next	1.66;

1.66
date	2006.10.17.19.39.06;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.64;

1.64
date	2006.06.14.19.46.54;	author gwk;	state Exp;
branches;
next	1.63;

1.63
date	2006.06.13.03.01.04;	author gwk;	state Exp;
branches;
next	1.62;

1.62
date	2006.05.28.14.58.12;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.20.22.40.30;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.20.07.52.36;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2006.05.11.13.21.11;	author mickey;	state Exp;
branches;
next	1.58;

1.58
date	2006.04.27.15.37.50;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2006.03.15.20.04.36;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2005.12.27.18.31.09;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2005.01.01.02.57.36;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2004.06.15.23.36.55;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.52;

1.52
date	2003.10.15.03.56.21;	author david;	state Exp;
branches;
next	1.51;

1.51
date	2003.10.14.19.38.20;	author jason;	state Exp;
branches;
next	1.50;

1.50
date	2003.09.11.21.48.56;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2003.09.11.19.46.22;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2003.09.07.04.02.03;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2003.06.02.23.27.47;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2003.03.14.22.05.43;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.08.08.08.28;	author niklas;	state Exp;
branches;
next	1.44;

1.44
date	2002.04.13.03.08.44;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2002.01.09.23.08.34;	author nordin;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.10.00.58.04;	author miod;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2001.12.05.23.58.41;	author tdeval;	state Exp;
branches;
next	1.39;

1.39
date	2001.12.04.00.00.36;	author niklas;	state Exp;
branches;
next	1.38;

1.38
date	2001.11.18.20.46.49;	author aaron;	state Exp;
branches;
next	1.37;

1.37
date	2001.11.12.20.28.20;	author niklas;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.25.00.43.11;	author mickey;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2001.05.05.22.33.44;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.30.13.23.11;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2000.08.17.20.15.39;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2000.08.08.19.12.44;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2000.03.26.22.38.32;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	99.09.12.19.44.04;	author weingart;	state Exp;
branches
	1.30.4.1;
next	1.29;

1.29
date	99.07.30.19.05.09;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	97.10.28.10.52.18;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	97.10.27.15.47.48;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	97.10.27.14.42.02;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	97.05.22.05.28.58;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	96.12.15.01.34.49;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	96.12.06.15.59.20;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	96.12.05.14.27.50;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	96.11.10.21.31.52;	author downsj;	state Exp;
branches;
next	1.20;

1.20
date	96.11.10.10.23.46;	author downsj;	state Exp;
branches;
next	1.19;

1.19
date	96.11.10.10.18.56;	author downsj;	state Exp;
branches;
next	1.18;

1.18
date	96.11.10.09.49.14;	author downsj;	state Exp;
branches;
next	1.17;

1.17
date	96.11.06.02.09.39;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.11.06.01.37.23;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.10.16.23.11.44;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.09.29.08.00.41;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	96.09.28.08.31.21;	author downsj;	state Exp;
branches;
next	1.12;

1.12
date	96.09.01.20.55.20;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	96.06.16.01.14.56;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.06.01.11.54.31;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.07.07.21.29;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.04.21.22.16.22;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.18.19.18.05;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.04.18.03.57.59;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.04.17.05.18.49;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.19.21.09.11;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.25.23.03.12;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.30.09.24.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.32;	author deraadt;	state Exp;
branches;
next	;

1.30.4.1
date	2001.04.18.16.07.12;	author niklas;	state Exp;
branches;
next	1.30.4.2;

1.30.4.2
date	2001.07.04.10.16.31;	author niklas;	state Exp;
branches;
next	1.30.4.3;

1.30.4.3
date	2001.07.14.10.02.24;	author ho;	state Exp;
branches;
next	1.30.4.4;

1.30.4.4
date	2001.10.27.09.57.31;	author niklas;	state Exp;
branches;
next	1.30.4.5;

1.30.4.5
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.30.4.6;

1.30.4.6
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.30.4.7;

1.30.4.7
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.30.4.8;

1.30.4.8
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.30.4.9;

1.30.4.9
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.30.4.10;

1.30.4.10
date	2003.04.11.16.12.56;	author niklas;	state Exp;
branches;
next	1.30.4.11;

1.30.4.11
date	2003.06.07.11.11.36;	author ho;	state Exp;
branches;
next	1.30.4.12;

1.30.4.12
date	2004.02.19.10.48.41;	author niklas;	state Exp;
branches;
next	;

1.36.2.1
date	2002.02.21.04.34.00;	author jason;	state Exp;
branches;
next	;

1.41.2.1
date	2002.01.31.22.55.11;	author niklas;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.101
log
@remove obsolete raid from namtoblk tables. from Artturi Alm
@
text
@/*	$OpenBSD: autoconf.c,v 1.100 2016/05/20 02:30:41 mlarkin Exp $	*/
/*	$NetBSD: autoconf.c,v 1.20 1996/05/03 19:41:56 christos Exp $	*/

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)autoconf.c	7.1 (Berkeley) 5/9/91
 */

/*
 * Setup the system to run on the current machine.
 *
 * cpu_configure() is called at boot time and initializes the vba
 * device tables and the memory controller monitoring.  Available
 * devices are determined (from possibilities mentioned in ioconf.c),
 * and the drivers are initialized.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/conf.h>
#include <sys/reboot.h>
#include <sys/device.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/hibernate.h>

#include <net/if.h>
#include <net/if_types.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <uvm/uvm_extern.h>

#include <machine/pte.h>
#include <machine/cpu.h>
#include <machine/gdt.h>
#include <machine/biosvar.h>
#include <machine/kvm86.h>

#include <dev/cons.h>

#include "ioapic.h"

#include "acpi.h"

#if NIOAPIC > 0
#include <machine/i82093var.h>
#endif

#if NACPI > 0
#include <dev/acpi/acpivar.h>
#endif

#ifdef MULTIPROCESSOR
#include <machine/mpbiosvar.h>
#endif

/*
 * The following several variables are related to
 * the configuration process, and are used in initializing
 * the machine.
 */
extern dev_t bootdev;

/* Support for VIA C3 RNG */
extern struct timeout viac3_rnd_tmo;
extern int	viac3_rnd_present;
void		viac3_rnd(void *);

extern struct timeout rdrand_tmo;
extern int	has_rdrand;
extern int	has_rdseed;
void		rdrand(void *);

#ifdef CRYPTO
void		viac3_crypto_setup(void);
extern int	i386_has_xcrypt;
#endif

/*
 * Determine i/o configuration for a machine.
 */
void
cpu_configure(void)
{
	/*
	 * Note, on i386, configure is not running under splhigh unlike other
	 * architectures.  This fact is used by the pcmcia irq line probing.
	 */

	gdt_init();		/* XXX - pcibios uses gdt stuff */

	/* Set up proc0's TSS */
	i386_proc0_tss_init();

#ifdef KVM86
	kvm86_init();
#endif
	pmap_bootstrap_pae();

#if defined(MULTIPROCESSOR) || \
    (NACPI > 0 && !defined(SMALL_KERNEL))
	/* install the lowmem ptp after boot args for 1:1 mappings */
	pmap_prealloc_lowmem_ptp();
#endif

#ifdef MULTIPROCESSOR
	pmap_kenter_pa((vaddr_t)MP_TRAMPOLINE,		/* virtual */
	    (paddr_t)MP_TRAMPOLINE,			/* physical */
	    PROT_READ | PROT_WRITE | PROT_EXEC);	/* protection */
	pmap_kenter_pa((vaddr_t)MP_TRAMP_DATA,		/* virtual */
	    (paddr_t)MP_TRAMP_DATA,			/* physical */
	    PROT_READ | PROT_WRITE);			/* protection */
#endif

	if (config_rootfound("mainbus", NULL) == NULL)
		panic("cpu_configure: mainbus not configured");

#if NIOAPIC > 0
	ioapic_enable();
#endif

	proc0.p_addr->u_pcb.pcb_cr0 = rcr0();

#ifdef MULTIPROCESSOR
	/* propagate TSS configuration to the idle pcb's. */
	cpu_init_idle_pcbs();
#endif
	spl0();

	/*
	 * We can not know which is our root disk, defer
	 * until we can checksum blocks to figure it out.
	 */
	cold = 0;

	/*
	 * At this point the RNG is running, and if FSXR is set we can
	 * use it.  Here we setup a periodic timeout to collect the data.
	 */
	if (viac3_rnd_present) {
		timeout_set(&viac3_rnd_tmo, viac3_rnd, &viac3_rnd_tmo);
		viac3_rnd(&viac3_rnd_tmo);
	}
	if (has_rdrand || has_rdseed) {
		timeout_set(&rdrand_tmo, rdrand, &rdrand_tmo);
		rdrand(&rdrand_tmo);
	}

#ifdef CRYPTO
	/*
	 * Also, if the chip has crypto available, enable it.
	 */
	if (i386_has_xcrypt)
		viac3_crypto_setup();
#endif
}

void
device_register(struct device *dev, void *aux)
{
}

/*
 * Now that we are fully operational, we can checksum the
 * disks, and using some heuristics, hopefully are able to
 * always determine the correct root disk.
 */
void
diskconf(void)
{
	int majdev, unit, part = 0;
	struct device *bootdv = NULL;
	dev_t tmpdev;
	char buf[128];
	extern bios_bootmac_t *bios_bootmac;

	dkcsumattach();

	if ((bootdev & B_MAGICMASK) == (u_int)B_DEVMAGIC) {
		majdev = B_TYPE(bootdev);
		unit = B_UNIT(bootdev);
		part = B_PARTITION(bootdev);
		snprintf(buf, sizeof buf, "%s%d%c", findblkname(majdev),
		    unit, part + 'a');
		bootdv = parsedisk(buf, strlen(buf), part, &tmpdev);
	}

	if (bios_bootmac) {
		struct ifnet *ifp;

		for (ifp = TAILQ_FIRST(&ifnet); ifp != NULL;
		    ifp = TAILQ_NEXT(ifp, if_list)) {
			if (ifp->if_type == IFT_ETHER &&
			    bcmp(bios_bootmac->mac,
			    ((struct arpcom *)ifp)->ac_enaddr,
			    ETHER_ADDR_LEN) == 0)
				break;
		}
		if (ifp) {
#if defined(NFSCLIENT)
			printf("PXE boot MAC address %s, interface %s\n",
			    ether_sprintf(bios_bootmac->mac), ifp->if_xname);
			bootdv = parsedisk(ifp->if_xname, strlen(ifp->if_xname),
			    0, &tmpdev);
			part = 0;
#endif
		} else
			printf("PXE boot MAC address %s, interface %s\n",
			    ether_sprintf(bios_bootmac->mac), "unknown");
	}

	setroot(bootdv, part, RB_USERREQ);
	dumpconf();

#ifdef HIBERNATE
	hibernate_resume();
#endif /* HIBERNATE */
}

struct nam2blk nam2blk[] = {
	{ "wd",		0 },
	{ "fd",		2 },
	{ "sd",		4 },
	{ "cd",		6 },
	{ "rd",		17 },
	{ "vnd",	14 },
	{ NULL,		-1 }
};
@


1.100
log
@
split the ACPI resume trampoline into code and data pages, and protect
with proper permissions. Same treatment was done on amd64 last year, i386
is catching up.

This diff has been in snaps for a few days, no regressions reported.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.99 2016/05/18 03:45:11 mlarkin Exp $	*/
a258 1
	{ "raid",	19 },
@


1.99
log
@
Split i386 mp hatch trampoline into code and data pages, and protect each
with proper W^X policy. The same thing was done for amd64 late last year,
catching i386 up now. Diff has been in snaps for a few days with no
reported fallout.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.98 2016/05/16 05:53:27 mlarkin Exp $	*/
a145 6
#endif

#if NACPI > 0 && !defined(SMALL_KERNEL)
	pmap_kenter_pa((vaddr_t)ACPI_TRAMPOLINE,	/* virtual */
	    (paddr_t)ACPI_TRAMPOLINE,			/* physical */
	    PROT_READ | PROT_WRITE | PROT_EXEC);	/* protection */
@


1.98
log
@
fix perms (previous cleanup commit introduced part of an unrelated change)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.97 2016/05/16 03:46:55 mlarkin Exp $	*/
d143 3
@


1.97
log
@
spaces -> tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.96 2016/03/15 03:17:50 guenther Exp $	*/
d142 1
a142 1
	    PROT_READ | PROT_EXEC);			/* protection */
@


1.96
log
@Burn more LDT deadwood: stop allocating one for each idle thread,
load the ldt register with the null selector (disabling use of it),
stop reloading it on every context switch, and blow away the table
itself, as well as the pcb and pmap bits that were used to track
it (making sure to keep pcb_savefpu correctly aligned).

testing naddy@@
ok kettenis@@ mpi@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.95 2015/12/27 04:31:34 jsg Exp $	*/
d140 3
a142 3
	pmap_kenter_pa((vaddr_t)MP_TRAMPOLINE,          /* virtual */
	    (paddr_t)MP_TRAMPOLINE,                     /* physical */
	    PROT_READ | PROT_WRITE | PROT_EXEC);        /* protection */
d146 3
a148 3
	pmap_kenter_pa((vaddr_t)ACPI_TRAMPOLINE,        /* virtual */
	    (paddr_t)ACPI_TRAMPOLINE,                   /* physical */
	    PROT_READ | PROT_WRITE | PROT_EXEC);        /* protection */
@


1.95
log
@If available prefer the rdseed instruction over rdrand when adding entropy
to the kernel rng.  If the rdseed source is empty fallback to rdrand
as suggested by naddy.  rdrand output comes from a prng that is
periodically reseeded.  rdseed should give us more bits of entropy.

ok naddy@@ djm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.94 2015/04/24 19:53:43 mlarkin Exp $	*/
d125 2
a126 2
	/* Set up proc0's TSS and LDT */
	i386_proc0_tss_ldt_init();
d161 1
a161 1
	/* propagate TSS and LDT configuration to the idle pcb's. */
@


1.94
log
@
Enable PAE mode for those CPUs that support it. This allows us to use the
NX bit for userland and kernel W^X. Unlike the previous c.2008 PAE
experiment, this does not provide > 4GB phys ram on i386 - PAE is solely
being used for NX capability this time. If you need > 4GB phys, use amd64.

Userland W^X was committed yesterday by kettenis@@, and we will shortly
start reworking the kernel like we did for amd64 a few months back to get
kernel W^X.

This has been in snaps for a few days and tested by kettenis and myself
as well.

ok deraadt@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.93 2015/04/12 18:37:53 mlarkin Exp $	*/
d104 1
d180 1
a180 1
	if (has_rdrand) {
@


1.93
log
@
Bring PAE code back to life, in a different form. This diff (via bluhm then
to deraadt, then myself) brings the PAE pmap on i386 (not touched in any
significant way for years) closer to the current non-PAE pmap and allows
us to take a big next step toward better i386 W^X in the kernel (similar to
what we did a few months ago on amd64). Unlike the original PAE pmap, this
diff will not be supporting > 4GB physical memory on i386 - this effort is
specifically geared toward providing W^X (via NX) only.

There still seems to be a bug removing certain pmap entries when PAE is
enabled, so I'm leaving PAE mode disabled for the moment until we can
figure out what is going on, but with this diff in the tree hopefully
others can help.

The pmap functions now operate through function pointers, due to the need
to support both non-PAE and PAE forms. My unscientific testing showed
less than 0.3% (a third of a percent) slowdown with this approach during
a base build.

Discussed for months with guenther, kettenis, and deraadt.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.92 2013/11/19 09:00:43 mpi Exp $	*/
a129 1
#ifdef notyet
a130 1
#endif
@


1.92
log
@Remove some FDDI/ATM leftovers.

ok mikeb@@, henning@@, deraadt@@, brad@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.91 2012/09/19 20:19:31 jsg Exp $	*/
d76 2
d82 8
d129 21
@


1.91
log
@Add support for the rdrand instruction found in recent Intel processors.
Joint work with naddy@@

ok naddy@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.90 2012/07/13 14:50:10 mlarkin Exp $	*/
d199 1
a199 2
			if ((ifp->if_type == IFT_ETHER ||
			    ifp->if_type == IFT_FDDI) &&
@


1.90
log
@

Improve diffability with amd64
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.89 2012/03/26 16:15:42 mlarkin Exp $	*/
d92 4
d150 5
@


1.89
log
@

Fix an integer math error when using the result of uvm_page_rle, and
at the same time increase said function's max RLE page count return value.

Add hooks in the right places to call the hibernate suspend and resume
routines, so that we can enable hibernation with a HIBERNATE option
line in GENERIC and appropriate acpi.c goo.

discussed on and off with deraadt@@ over the past few months
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.88 2011/06/26 23:19:11 tedu Exp $	*/
d57 1
a70 1
#include <sys/hibernate.h>
@


1.88
log
@kill mcd dead.  ok krw matthew millert thib
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.87 2011/04/25 21:00:08 mikeb Exp $	*/
d70 1
d212 4
@


1.87
log
@garbage collect biomask printf;  ok deraadt kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.86 2010/11/18 21:13:19 miod Exp $	*/
a217 1
	{ "mcd",	7 },
@


1.86
log
@Do not #include <sys/dkstat.h> if you don't need anything from it.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.85 2010/07/25 21:43:35 deraadt Exp $	*/
a119 8
	if (nioapics > 0)
		goto nomasks;
#endif
	printf("biomask %x netmask %x ttymask %x\n", (u_short)IMASK(IPL_BIO),
	    (u_short)IMASK(IPL_NET), (u_short)IMASK(IPL_TTY));

#if NIOAPIC > 0
 nomasks:
@


1.85
log
@in the clock drivers, seperate the soft-state and hard-state which was
all jumbled up in the same functions. the rtc (mc chip) and clock (i8243)
startup was also mixed up.  they the soft state and hardware state can
be started in the right order, and it is easy to restart just the
neccessary parts upon resume.  tested in numerous cases:
(apic, pic) * (GENERIC.MP, GENERIC) * (mp, non-mp) * (i386, amd64)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.84 2010/06/28 22:20:12 deraadt Exp $	*/
a50 1
#include <sys/dkstat.h>
@


1.84
log
@Ah, this will not help the netboot case
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.83 2010/06/27 19:21:19 deraadt Exp $	*/
a106 2

	startrtclock();
@


1.83
log
@Mark the PXE boot device as "netboot" even if we do not contain
nfs client support (yes, it becomes the root device too, but for ramdisks
this is OK because they are not a swap generic configuration)
Discussion with reyk and halex
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.82 2010/04/20 22:05:41 tedu Exp $	*/
d208 1
d214 1
@


1.82
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.81 2008/07/21 04:35:54 todd Exp $	*/
a207 1
#if defined(NFSCLIENT)
a212 1
#endif
@


1.81
log
@nam2blk[] needs a "vnd" entry for some things (like softraid)
ok marco@@ no objection miod@@ need this for regress djm@@ no objection krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.80 2008/05/26 22:49:57 deraadt Exp $	*/
d48 1
@


1.80
log
@do not muck with the mountroot variable, since setroot() uses the state of
it and rootdev to determine whether it is booting 'generic', 'nfs', or from
a specified disk partition
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.79 2008/03/19 05:47:44 deraadt Exp $	*/
d231 1
@


1.79
log
@label all interfaces we netboot from in group "netboot", in a MI fashion
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.78 2007/12/27 18:04:27 deraadt Exp $	*/
a209 1
			mountroot = nfs_mountroot;	/* potentially */
@


1.78
log
@missing newline in autoconf pxe report; spotted by henning
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.77 2007/12/11 17:53:16 deraadt Exp $	*/
a206 1
			if_addgroup(ifp, "pxeboot");
@


1.77
log
@if we pxebooted, and can find the interface, put it in a "pxeboot" group
so that later applications can try to do the right thing
for reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.76 2007/11/28 17:05:09 tedu Exp $	*/
d209 1
a209 1
			printf("PXE boot MAC address %s, interface %s",
@


1.76
log
@quite a bit of simplification by removing cpu classes.
also assume that 386 cpus are really unknown, and promote them to 486
instead of panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.75 2007/06/01 19:25:10 deraadt Exp $	*/
a180 1
#if defined(NFSCLIENT)
a181 1
#endif
a193 1
#if defined(NFSCLIENT)
a196 2
		printf("PXE boot MAC address %s, ",
		    ether_sprintf(bios_bootmac->mac));
d207 4
a210 1
			printf("interface %s\n", ifp->if_xname);
d215 1
d217 2
a218 1
			printf("unknown interface\n");
a219 1
#endif
@


1.75
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.75 2007/06/01 19:20:46 deraadt Exp $	*/
a86 1
#ifdef I686_CPU
a93 1
#endif /* CRYPTO */
a146 1
#ifdef I686_CPU
a160 1
#endif /* CRYPTO */
@


1.74
log
@kill __HAVE_DEVICE_REGISTER by requiring all architectures to have a
device_register() function -- even if it does nothing.  reduces the
cpp-based blather different between architectures
idea ok'd by miod; tested on all architectures (except a few miod will
need to cleanup because he has them)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.73 2007/05/04 19:30:55 deraadt Exp $	*/
a78 2
void diskconf(void);

a146 1
	md_diskconf = diskconf;
@


1.73
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.72 2007/05/04 03:44:44 deraadt Exp $	*/
d169 5
@


1.72
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.71 2007/05/01 17:35:56 deraadt Exp $	*/
d228 1
a228 4
static struct {
	char	*name;
	int	maj;
} nam2blk[] = {
d235 2
a236 1
	{ "raid",	19 }
a237 23

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)))
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}
@


1.71
log
@support exit at boot -a time
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.70 2007/02/20 21:15:01 tom Exp $	*/
a78 5
int findblkmajor(struct device *dv);
char *findblkname(int);

void rootconf(void);
void setroot(void);
d179 4
a182 68
	/*
	 * Configure root, swap, and dump area.  This is
	 * currently done by running the same checksum
	 * algorithm over all known disks, as was done in
	 * /boot.  Then we basically fixup the *dev vars
	 * from the info we gleaned from this.
	 */
	dkcsumattach();

	rootconf();
	dumpconf();
}

#define	DOSWAP			/* change swdevt and dumpdev */

static struct {
	char *name;
	int maj;
} nam2blk[] = {
	{ "wd", 0 },
	{ "sw", 1 },
	{ "fd", 2 },
	{ "wt", 3 },
	{ "sd", 4 },
	{ "cd", 6 },
	{ "mcd", 7 },
	{ "rd", 17 },
	{ "raid", 19 }
};

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name))
		    == 0)
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (maj == nam2blk[i].maj)
			return (nam2blk[i].name);
	return (NULL);
}

dev_t	argdev = NODEV;
int	nswap;

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 */
void
setroot(void)
{
	int  majdev, mindev, unit, part, adaptor;
	struct swdevt *swp;
	dev_t orootdev;
d186 11
a196 3
#ifdef DOSWAP
	dev_t temp = 0;
#endif
a199 1
		extern char *nfsbootdevname;
a200 2
		
		mountroot = nfs_mountroot;
a203 1

d214 5
a218 2
			nfsbootdevname = ifp->if_xname;
			printf("interface %s\n", nfsbootdevname);
d220 1
a220 2
			printf("no interface selected\n");
		return;
d224 2
a225 43
	if (boothowto & RB_DFLTROOT ||
	    (bootdev & B_MAGICMASK) != (u_long)B_DEVMAGIC)
		return;

	majdev = B_TYPE(bootdev);
	if (findblkname(majdev) == NULL)
		return;
	adaptor = B_ADAPTOR(bootdev);
	part = B_PARTITION(bootdev);
	unit = B_UNIT(bootdev);
	mindev = (unit * MAXPARTITIONS) + part;
	orootdev = rootdev;
	rootdev = makedev(majdev, mindev);
	mountroot = dk_mountroot;

	/*
	 * If the original rootdev is the same as the one
	 * just calculated, don't need to adjust the swap configuration.
	 */
	printf("root on %s%d%c\n", findblkname(majdev), unit, part + 'a');
	if (rootdev == orootdev)
		return;

#ifdef DOSWAP
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    mindev/MAXPARTITIONS == minor(swp->sw_dev)/MAXPARTITIONS) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device, move
	 * it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
#endif
d228 11
a238 56
#include "wd.h"
#if NWD > 0
extern	struct cfdriver wd_cd;
#endif
#include "sd.h"
#if NSD > 0
extern	struct cfdriver sd_cd;
#endif
#include "cd.h"
#if NCD > 0
extern	struct cfdriver cd_cd;
#endif
#include "mcd.h"
#if NMCD > 0
extern	struct cfdriver mcd_cd;
#endif
#include "fd.h"
#if NFD > 0
extern	struct cfdriver fd_cd;
#endif
#include "rd.h"
#if NRD > 0
extern	struct cfdriver rd_cd;
#endif
#include "raid.h"
#if NRAID > 0
extern	struct cfdriver raid_cd;
#endif

struct	genericconf {
	struct cfdriver *gc_driver;
	char *gc_name;
	dev_t gc_major;
} genericconf[] = {
#if NWD > 0
	{ &wd_cd,  "wd",  0 },
#endif
#if NFD > 0
	{ &fd_cd,  "fd",  2 },
#endif
#if NSD > 0
	{ &sd_cd,  "sd",  4 },
#endif
#if NCD > 0
	{ &cd_cd,  "cd",  6 },
#endif
#if NMCD > 0
	{ &mcd_cd, "mcd", 7 },
#endif
#if NRD > 0
	{ &rd_cd,  "rd",  17 },
#endif
#if NRAID > 0
	{ &raid_cd,  "raid",  19 },
#endif
	{ 0 }
d241 2
a242 2
void
rootconf(void)
d244 2
a245 7
	struct genericconf *gc;
	int unit, part = 0;
#if defined(NFSCLIENT)
	struct ifnet *ifp;
#endif
	char name[128];
	char *num;
d247 5
a251 57
	if (boothowto & RB_ASKNAME) {
		while (1) {
			printf("root device? ");
			cnpollc(TRUE);
			getsn(name, sizeof name);
			cnpollc(FALSE);
			if (*name == '\0')
				break;
			if (strcmp(name, "exit") == 0)
				boot(RB_USERREQ);
			for (gc = genericconf; gc->gc_driver; gc++)
				if (gc->gc_driver->cd_ndevs &&
				    strncmp(gc->gc_name, name,
				    strlen(gc->gc_name)) == 0)
					break;
			if (gc->gc_driver) {
				num = &name[strlen(gc->gc_name)];

				unit = -2;
				do {
					if (unit != -2 && *num >= 'a' &&
					    *num <= 'a'+MAXPARTITIONS-1 &&
					    num[1] == '\0') {
						part = *num++ - 'a';
						break;
					}
					if (unit == -2)
						unit = 0;
					unit = (unit * 10) + *num - '0';
					if (*num < '0' || *num > '9')
						unit = -1;
				} while (unit != -1 && *++num);
	
				if (unit < 0) {
					printf("%s: not a unit number\n",
					    &name[strlen(gc->gc_name)]);
				} else if (unit >= gc->gc_driver->cd_ndevs ||
				    gc->gc_driver->cd_devs[unit] == NULL) {
					printf("%d: no such unit\n", unit);
				} else {
					rootdev = makedev(gc->gc_major,
					    unit * MAXPARTITIONS + part);
					mountroot = dk_mountroot;
					break;
				}
#if defined(NFSCLIENT)
			} else {
				ifp = ifunit(name);
				if (ifp && (ifp->if_flags & IFF_BROADCAST)) {
					extern char *nfsbootdevname;
			
					mountroot = nfs_mountroot;
					nfsbootdevname = ifp->if_xname;
					return;
				}
#endif
			}
d253 4
a256 18
			printf("use one of: exit");
			for (gc = genericconf; gc->gc_driver; gc++) {
				for (unit=0; unit < gc->gc_driver->cd_ndevs; unit++) {
					if (gc->gc_driver->cd_devs[unit])
						printf(" %s%d[a-%c]", gc->gc_name,
						    unit, 'a'+MAXPARTITIONS-1);
				}
			}
#if defined(NFSCLIENT)
			for (ifp = TAILQ_FIRST(&ifnet); ifp != NULL;
			    ifp = TAILQ_NEXT(ifp, if_list)) {
				if ((ifp->if_flags & IFF_BROADCAST))
					printf(" %s", ifp->if_xname);
			}
#endif
			printf("\n");
		}
	}
d258 4
a261 21
	if (mountroot == NULL) {
		/* `swap generic' */
		setroot();
#if defined(NFSCLIENT)
	} else if (mountroot == nfs_mountroot) {
		;
#endif
	} else {
		/* preconfigured for disk */
		int  majdev, unit, part;

		majdev = major(rootdev);
		if (findblkname(majdev) == NULL)
			return;
		part = minor(rootdev) % MAXPARTITIONS;
		unit = minor(rootdev) / MAXPARTITIONS;
		printf("root on %s%d%c\n", findblkname(majdev), unit, part + 'a');
	}
	if (mountroot == dk_mountroot)
		swdevt[0].sw_dev = argdev = dumpdev =
		    MAKEDISKDEV(major(rootdev), DISKUNIT(rootdev), 1);
@


1.70
log
@Revert PAE pmap for now, until the strange bug is found.  This stops
the freezes many of us are seeing (especially on amd64 machines running
OpenBSD/i386).

Much testing by nick@@ (as always - thanks!), hugh@@, ian@@, kettenis@@
and Sam Smith (s (at) msmith (dot) net).

Requested by, input from, and ok deraadt@@  ok art@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.69 2006/11/29 22:40:13 miod Exp $	*/
d409 2
d459 1
a459 1
			printf("use one of: ");
d463 1
a463 1
						printf("%s%d[a-%c] ", gc->gc_name,
d471 1
a471 1
					printf("%s ", ifp->if_xname);
@


1.69
log
@Nuke all commons but one, and enable --warn-common in LINKFLAGS.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.68 2006/11/29 19:31:37 kettenis Exp $	*/
a126 3
#ifndef SMALL_KERNEL
	pmap_bootstrap_pae();
#endif
@


1.68
log
@Don't print masks if we're in apic mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.67 2006/10/29 18:46:52 kettenis Exp $	*/
a242 1
long	dumplo;
@


1.67
log
@The default for swap should be partition 'b' on the same unit as root is,
not partition 'b' on unit 0.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.66 2006/10/17 19:39:06 deraadt Exp $	*/
d133 4
d141 1
@


1.66
log
@swap is partition b, not partition after root (wherever root is defined
to be); pr 5256
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.65 2006/09/19 11:06:33 jsg Exp $	*/
d495 1
a495 1
		    makedev(major(rootdev), 1);
@


1.65
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.64 2006/06/14 19:46:54 gwk Exp $	*/
d495 1
a495 1
		    makedev(major(rootdev), minor(rootdev) + 1);
@


1.64
log
@Missed a part of the kvm86 commit, if option KVM86 is defined it would be
a good idea to actually call the init function, this was lost it was part of
the diff ok toby@@, mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.63 2006/06/13 03:01:04 gwk Exp $	*/
d109 1
a109 1
cpu_configure()
d180 1
a180 1
diskconf()
d213 1
a213 2
findblkmajor(dv)
	struct device *dv;
d226 1
a226 2
findblkname(maj)
	int maj;
d246 1
a246 1
setroot()
d390 1
a390 1
rootconf()
d392 1
a392 1
	register struct genericconf *gc;
@


1.63
log
@Kernel virtual mode 8086, currently disabled in GENERIC.
lots of help at c2k6 and after from toby@@,
ok toby@@, mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.62 2006/05/28 14:58:12 deraadt Exp $	*/
d69 1
d122 4
@


1.62
log
@do not print "root on ..." twice for the -a case, also cope with systems
configured for 'root on nfs'
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.61 2006/05/20 22:40:30 deraadt Exp $	*/
d119 3
d135 2
a148 3

	/* Set up proc0's TSS and LDT (after the FPU is configured). */
	i386_proc0_tss_ldt_init();
@


1.61
log
@Detect BOOTARG_BOOTMAC coming from PXE; search for interface and attempt
to boot from it.  At the same time add -a support for network interface
selection; tested by reyk, mk, deraadt on i386, cloned code applied to
amd64 and tested a little bit less
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.60 2006/05/20 07:52:36 deraadt Exp $	*/
a258 1
		nfsbootdevname = NULL;		/* we do not know */
a432 2
					printf("root on %s%d%c\n", gc->gc_name, unit,
					    'a' + part);
d473 4
d478 1
a478 1
		/* preconfigured */
a486 1
		mountroot = dk_mountroot;
@


1.60
log
@delete old #ifdef INSTALL chunk
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.59 2006/05/11 13:21:11 mickey Exp $	*/
d55 7
d244 1
d246 3
d252 29
a280 1
	struct swdevt *swp;
d285 1
d295 2
d390 4
d397 6
a402 12
		char name[128];
retry:
		printf("root device? ");
		cnpollc(TRUE);
		getsn(name, sizeof name);
		cnpollc(FALSE);
		if (*name == '\0')
			goto noask;
		for (gc = genericconf; gc->gc_driver; gc++)
			if (gc->gc_driver->cd_ndevs &&
			    strncmp(gc->gc_name, name,
			    strlen(gc->gc_name)) == 0)
d404 7
a410 2
		if (gc->gc_driver) {
			num = &name[strlen(gc->gc_name)];
d412 27
a438 6
			unit = -2;
			do {
				if (unit != -2 && *num >= 'a' &&
				    *num <= 'a'+MAXPARTITIONS-1 &&
				    num[1] == '\0') {
					part = *num++ - 'a';
d441 1
a441 13
				if (unit == -2)
					unit = 0;
				unit = (unit * 10) + *num - '0';
				if (*num < '0' || *num > '9')
					unit = -1;
			} while (unit != -1 && *++num);

			if (unit < 0) {
				printf("%s: not a unit number\n",
				    &name[strlen(gc->gc_name)]);
			} else if (unit >= gc->gc_driver->cd_ndevs ||
			    gc->gc_driver->cd_devs[unit] == NULL) {
				printf("%d: no such unit\n", unit);
d443 9
a451 5
				printf("root on %s%d%c\n", gc->gc_name, unit,
				    'a' + part);
				rootdev = makedev(gc->gc_major,
				    unit * MAXPARTITIONS + part);
				goto doswap;
d453 14
a466 7
		}
		printf("use one of: ");
		for (gc = genericconf; gc->gc_driver; gc++) {
			for (unit=0; unit < gc->gc_driver->cd_ndevs; unit++) {
				if (gc->gc_driver->cd_devs[unit])
					printf("%s%d[a-%c] ", gc->gc_name,
					    unit, 'a'+MAXPARTITIONS-1);
d468 2
a470 2
		printf("\n");
		goto retry;
d472 1
a472 1
noask:
d486 1
a486 1
		return;
d488 3
a490 8

doswap:
#ifndef DISKLESS
	mountroot = dk_mountroot;
#endif
	swdevt[0].sw_dev = argdev = dumpdev =
	    makedev(major(rootdev), minor(rootdev) + 1);
	/* swap size and dumplo set during autoconfigure */
@


1.59
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.58 2006/04/27 15:37:50 mickey Exp $	*/
a348 8

#ifdef INSTALL
	if (B_TYPE(bootdev) == 2) {
		printf("\n\nInsert file system floppy...\n");
		if (!(boothowto & RB_ASKNAME))
			cngetc();
	}
#endif
@


1.58
log
@implement separate PAE pmap that allows access to 64g of physmem
if supported by the cpu(s). currently not enabled by default and
not compiled into ramdisks. this grows paddr_t to 64bit but yet
leaves bus_addr_t at 32bits. measures are taken to favour dmaable
memory allocation from below 4g line such that buffer cache is
already allocated form below, pool backend allocator prefers lower
memory and then finally bounce buffers are used as last resort.
PAE is engaged only if global variable cpu_pae is manually set
to non-zero and there is physical memory present above 4g.
simplify pcibios address math to use u_long as we always will
be in the 32bit space.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.57 2006/03/15 20:04:36 miod Exp $	*/
d41 1
a41 1
 * cpu_configure() is called at boot time and initializes the vba 
@


1.57
log
@Correct checks against cd_ndevs - valid numbers are strictly inferior to
cd_ndevs.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.56 2005/12/27 18:31:09 miod Exp $	*/
d48 1
d112 3
@


1.56
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.55 2005/01/01 02:57:36 millert Exp $	*/
d389 1
a389 1
			} else if (unit > gc->gc_driver->cd_ndevs ||
@


1.55
log
@Move the declaration of bootdev from autoconf.c to locore.s.  gcc
3.3.5 was placing bootdev into bss and its value was getting zeroed
when bss is cleared.  Apparently we lucked out before and gcc 2.9.5
put it in .data; now it is explicit.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.54 2004/06/15 23:36:55 deraadt Exp $	*/
a73 1
void swapconf(void);
a173 1
	swapconf();
a174 24
}

/*
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	register struct swdevt *swp;
	register int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		int maj = major(swp->sw_dev);

		if (maj > nblkdev)
			break;
		if (bdevsw[maj].d_psize) {
			nblks = (*bdevsw[maj].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}
	}
@


1.54
log
@first parts of how C3 Esther will be handled; ok tom
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.53 2004/06/13 21:49:15 niklas Exp $	*/
d83 1
a83 1
dev_t	bootdev = 0;		/* bootdevice, initialized in locore.s */
@


1.53
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a91 1
extern int	viac3_crypto_present;
d93 1
d151 1
a151 1
	if (viac3_crypto_present)
@


1.52
log
@typo in comment, ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.51 2003/10/14 19:38:20 jason Exp $	*/
d64 6
d118 8
@


1.51
log
@Ok, now that the via c3 crypto stuff is in the tree, merge the last bit of
my cleanups before starting "real work".
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.48 2003/09/07 04:02:03 krw Exp $	*/
d135 1
a135 1
	 * Also, if the chip as crypto available, enable it.
@


1.50
log
@permit ramdisks to build
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.49 2003/09/11 19:46:22 deraadt Exp $	*/
d88 1
a88 1
#endif
d133 1
a136 1
#ifdef CRYPTO
@


1.49
log
@support new via c3 AES instruction; written by jason
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.48 2003/09/07 04:02:03 krw Exp $	*/
d84 2
d89 1
d136 1
d139 1
@


1.48
log
@Fix system hangs some i386 machines experienced when booting with the
'-a' option.

Closes PR #2122 and #3437. From Thorsten Glaser.

ok deraadt@@ henning@@ weingart@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.47 2003/06/02 23:27:47 millert Exp $	*/
d84 2
d130 5
@


1.47
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.46 2003/03/14 22:05:43 deraadt Exp $	*/
d358 1
d360 1
@


1.46
log
@Support for the VIA C3 Nehemiah on-cpu random number generator.  This chip
will be shipping soon (we have nice prototypes).  Written by toby.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.45 2002/06/08 08:08:28 niklas Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.45
log
@Explain why there is no splhigh here
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.45 2002/06/08 07:24:51 niklas Exp $	*/
d83 7
d122 11
@


1.44
log
@Try MUCH harder to always print a "root on" line
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.43 2002/03/14 01:26:32 millert Exp $	*/
d89 4
@


1.43
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.42 2002/01/09 23:08:34 nordin Exp $	*/
d237 1
a239 1
	printf("root on %s%d%c\n", findblkname(majdev), unit, part + 'a');
d397 8
@


1.42
log
@Call gdt_init() earlier and only once. Work done with millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.41 2001/12/10 00:58:04 miod Exp $	*/
d68 2
a69 2
int findblkmajor __P((struct device *dv));
char *findblkname __P((int));
d71 4
a74 4
void rootconf __P((void));
void swapconf __P((void));
void setroot __P((void));
void diskconf __P((void));
@


1.41
log
@No need to include <sys/dmap.h> and define related variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.40 2001/12/05 23:58:41 tdeval Exp $	*/
d59 2
d63 1
d91 2
@


1.41.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.42 2002/01/09 23:08:34 nordin Exp $	*/
a58 2
#include <uvm/uvm_extern.h>

a60 1
#include <machine/gdt.h>
a87 2

	gdt_init();		/* XXX - pcibios uses gdt stuff */
@


1.41.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.41.2.1 2002/01/31 22:55:11 niklas Exp $	*/
d68 2
a69 2
int findblkmajor(struct device *dv);
char *findblkname(int);
d71 4
a74 4
void rootconf(void);
void swapconf(void);
void setroot(void);
void diskconf(void);
a88 4
	/*
	 * Note, on i386, configure is not running under splhigh unlike other
	 * architectures.  This fact is used by the pcmcia irq line probing.
	 */
a236 1
	printf("root on %s%d%c\n", findblkname(majdev), unit, part + 'a');
d239 1
a396 8
		int  majdev, unit, part;

		majdev = major(rootdev);
		if (findblkname(majdev) == NULL)
			return;
		part = minor(rootdev) % MAXPARTITIONS;
		unit = minor(rootdev) / MAXPARTITIONS;
		printf("root on %s%d%c\n", findblkname(majdev), unit, part + 'a');
@


1.41.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a82 7
/* Support for VIA C3 RNG */
#ifdef I686_CPU
extern struct timeout viac3_rnd_tmo;
extern int	viac3_rnd_present;
void		viac3_rnd(void *);
#endif

a114 11

#ifdef I686_CPU
	/*
	 * At this point the RNG is running, and if FSXR is set we can
	 * use it.  Here we setup a periodic timeout to collect the data.
	 */
	if (viac3_rnd_present) {
		timeout_set(&viac3_rnd_tmo, viac3_rnd, &viac3_rnd_tmo);
		viac3_rnd(&viac3_rnd_tmo);
	}
#endif
@


1.40
log
@Enable rootdev auto-configuration by device drivers during boot.
Add support for "raid" devices (prepare future raidframe changes).

OK deraadt@@, Reviewed by drahn@@, jason@@, mickey@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.39 2001/12/04 00:00:36 niklas Exp $	*/
a55 1
#include <sys/dmap.h>
a199 1
int	dmmin, dmmax, dmtext;
@


1.39
log
@New try at a level based irq system.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.37 2001/11/12 20:28:20 niklas Exp $	*/
d66 3
d157 13
a169 22
static const char *devname[] = {
	"wd",		/* 0 = wd */
	"sw",		/* 1 = sw */
	"fd",		/* 2 = fd */
	"wt",		/* 3 = wt */
	"sd",		/* 4 = sd */
	"",		/* 5 */
	"",		/* 6 */
	"mcd",		/* 7 = mcd */
	"",		/* 8 */
	"",		/* 9 */
	"",		/* 10 */
	"",		/* 11 */
	"",		/* 12 */
	"",		/* 13 */
	"",		/* 14 */
	"",		/* 15 */
	"",		/* 16 */
	"rd",		/* 17 = rd */
	"",		/* 18 */
	"",		/* 19 */
	""		/* 20 */
d172 26
d222 1
a222 2
	if (majdev > sizeof(devname)/sizeof(devname[0]) ||
	    *devname[majdev] == '\0')
d236 1
a236 1
	printf("root on %s%d%c\n", devname[majdev], unit, part + 'a');
d284 4
d311 3
@


1.38
log
@Revert niklas's broken ICU interrupt handling changes; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.36 2001/06/25 00:43:11 mickey Exp $	*/
d90 2
a91 3
	printf("biomask %x netmask %x ttymask %x\n",
	    (u_short)imask[IPL_BIO], (u_short)imask[IPL_NET],
	    (u_short)imask[IPL_TTY]);
@


1.37
log
@Redo the ICU interrupt handling system to better emulate an APIC system.
This is done by representing the current blockings of interrupts with
a priority level instead of an interrupt mask.  This makes it possible to
share implementations for spl* functions/macros between both ICU
and APIC (a must when going MP) systems.  In this process, assign
soft interrupts their own levels to match the way things will be on
APIC systems where they actually will be real interrupts and not just
bits in a pending mask as they are now.
Heavily inspired by Bill Studenmunds SMP work in NetBSD
@
text
@d90 3
a92 2
	printf("biomask %x netmask %x ttymask %x\n", (u_short)IMASK(IPL_BIO),
	    (u_short)IMASK(IPL_NET), (u_short)IMASK(IPL_TTY));
@


1.36
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.35 2001/05/05 22:33:44 art Exp $	*/
d90 2
a91 3
	printf("biomask %x netmask %x ttymask %x\n",
	    (u_short)imask[IPL_BIO], (u_short)imask[IPL_NET],
	    (u_short)imask[IPL_TTY]);
@


1.36.2.1
log
@Pull in patch from current:
Fix (nordin):
Call gdt_init() earlier and only once. Work done with millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.36 2001/06/25 00:43:11 mickey Exp $	*/
a59 3
#include <vm/vm.h>
#include <uvm/uvm_extern.h>

a61 1
#include <machine/gdt.h>
a85 2

	gdt_init();		/* XXX - pcibios uses gdt stuff */
@


1.35
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.34 2001/04/30 13:23:11 art Exp $	*/
a75 1
extern int	cold;		/* cold start flag initialized in locore.s */
@


1.34
log
@Move proc0's TSS and LDT initialization to a separate function
that's called at the end of configure instead of cpu_startup.

Inspired by NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33 2000/08/17 20:15:39 mickey Exp $	*/
d45 1
a45 1
 * Configure() is called at boot time and initializes the vba 
d83 1
a83 1
configure()
d89 1
a89 1
		panic("configure: mainbus not configured");
@


1.33
log
@pcibios0 at bios0 flags 0x0000
this is now a real device, which looks in flags for disabling
address, interrupt or bus fixup.
bios0's flags are to disable bios32 and pcibios probing.
since boot_config support editing flags, it's posible
to adjust pcibios functionality in the generic kernel
upon boot time. man is coming.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.32 2000/08/08 19:12:44 mickey Exp $	*/
d103 3
@


1.32
log
@sync w/ netbsd almost -current code (;
fixes quite a few problems.
adds new option PCIBIOS_ADDR_FIXUP.
numerous extra fixes by me, also pointed out by other ppl,
such as avoid panics, ifdef on pciverbose, not diagnostic,
some other smaller knits; some have been forwarded back
to netbsd developers, some will go soon too.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.31 2000/03/26 22:38:32 mickey Exp $	*/
a63 3
#include <dev/pci/pcivar.h>
#include <i386/pci/pcibios.h>

a87 8
#ifdef BIOS32
	bios32_init();
#endif

#ifdef PCIBIOS
	pcibios_init();
#endif

d371 1
d373 1
@


1.31
log
@from netbsd: pci interrupt routing code.
also, change a few pcidevs names to match netbsd (and more descriptive).
tested on a bunch of laptops, helps resolving 'pin X unmapped'
problems for (usually) usb and cardbus cntrollers.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30 1999/09/12 19:44:04 weingart Exp $	*/
d64 1
@


1.30
log
@Fix rootdev handling, use disk checksums to find the device we were booted
from.  Hopefully this will fix all the hangs/panics where the root device
was not found.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.29 1999/07/30 19:05:09 deraadt Exp $	*/
d62 3
d89 8
@


1.30.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.33 2000/08/17 20:15:39 mickey Exp $	*/
a61 1
#include <machine/biosvar.h>
a369 1
#ifndef DISKLESS
a370 1
#endif
@


1.30.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30.4.1 2001/04/18 16:07:12 niklas Exp $	*/
d45 1
a45 1
 * cpu_configure() is called at boot time and initializes the vba 
d76 1
d83 1
a83 1
cpu_configure()
d89 1
a89 1
		panic("cpu_configure: mainbus not configured");
a102 3

	/* Set up proc0's TSS and LDT (after the FPU is configured). */
	i386_proc0_tss_ldt_init();
@


1.30.4.3
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30.4.2 2001/07/04 10:16:31 niklas Exp $	*/
a65 6
#include "ioapic.h"

#if NIOAPIC > 0
#include <machine/i82093var.h>
#endif

a92 8
/* XXXSMP - NetBSD's diff were like this:
+           (u_short)IMASK(IPL_BIO), (u_short)IMASK(IPL_NET),
+           (u_short)IMASK(IPL_TTY));
*/

#if NIOAPIC > 0
	ioapic_enable();
#endif
@


1.30.4.4
log
@New interrupt and spl* system, mostly from NetBSD's i386 MP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 6
a102 2
	    (u_short)IMASK(IPL_BIO), (u_short)IMASK(IPL_NET),
	    (u_short)IMASK(IPL_TTY));
@


1.30.4.5
log
@Merge in -current
@
text
@d96 3
a98 2
	printf("biomask %x netmask %x ttymask %x\n", (u_short)IMASK(IPL_BIO),
	    (u_short)IMASK(IPL_NET), (u_short)IMASK(IPL_TTY));
@


1.30.4.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30.4.5 2001/11/13 21:00:51 niklas Exp $	*/
@


1.30.4.7
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
a59 2
#include <uvm/uvm_extern.h>

a61 1
#include <machine/gdt.h>
a71 3
int findblkmajor __P((struct device *dv));
char *findblkname __P((int));

a92 2
	gdt_init();		/* XXX - pcibios uses gdt stuff */

d164 22
a185 13
static struct {
	char *name;
	int maj;
} nam2blk[] = {
	{ "wd", 0 },
	{ "sw", 1 },
	{ "fd", 2 },
	{ "wt", 3 },
	{ "sd", 4 },
	{ "cd", 6 },
	{ "mcd", 7 },
	{ "rd", 17 },
	{ "raid", 19 }
a187 26
int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name))
		    == 0)
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(maj)
	int maj;
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (maj == nam2blk[i].maj)
			return (nam2blk[i].name);
	return (NULL);
}

d191 1
d212 2
a213 1
	if (findblkname(majdev) == NULL)
d227 1
a227 1
	printf("root on %s%d%c\n", findblkname(majdev), unit, part + 'a');
a274 4
#include "raid.h"
#if NRAID > 0
extern	struct cfdriver raid_cd;
#endif
a297 3
#endif
#if NRAID > 0
	{ &raid_cd,  "raid",  19 },
@


1.30.4.8
log
@Merge in -current from about a week ago
@
text
@d74 2
a75 2
int findblkmajor(struct device *dv);
char *findblkname(int);
d77 4
a80 4
void rootconf(void);
void swapconf(void);
void setroot(void);
void diskconf(void);
@


1.30.4.9
log
@Sync the SMP branch with 3.3
@
text
@a88 7
/* Support for VIA C3 RNG */
#ifdef I686_CPU
extern struct timeout viac3_rnd_tmo;
extern int	viac3_rnd_present;
void		viac3_rnd(void *);
#endif

a94 4
	/*
	 * Note, on i386, configure is not running under splhigh unlike other
	 * architectures.  This fact is used by the pcmcia irq line probing.
	 */
a120 11

#ifdef I686_CPU
	/*
	 * At this point the RNG is running, and if FSXR is set we can
	 * use it.  Here we setup a periodic timeout to collect the data.
	 */
	if (viac3_rnd_present) {
		timeout_set(&viac3_rnd_tmo, viac3_rnd, &viac3_rnd_tmo);
		viac3_rnd(&viac3_rnd_tmo);
	}
#endif
a246 1
	printf("root on %s%d%c\n", findblkname(majdev), unit, part + 'a');
d249 1
a406 8
		int  majdev, unit, part;

		majdev = major(rootdev);
		if (findblkname(majdev) == NULL)
			return;
		part = minor(rootdev) % MAXPARTITIONS;
		unit = minor(rootdev) / MAXPARTITIONS;
		printf("root on %s%d%c\n", findblkname(majdev), unit, part + 'a');
@


1.30.4.10
log
@Move TSS selector from the PCB to MD part of proc and to cpu_info.
Maintain a list of CPUs and provide an iterator for it.
Ifdef out IPI debugging.  Call pmap_{de,}activate as part of context switching.
Mostly from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30.4.9 2003/03/27 23:26:55 niklas Exp $	*/
a120 4
#ifdef MULTIPROCESSOR
	/* propagate TSS and LDT configuration to the idle pcb's. */
	cpu_init_idle_pcbs();
#endif
@


1.30.4.11
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.30.4.10 2003/04/11 16:12:56 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.30.4.12
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a89 5

#ifdef CRYPTO
extern int	viac3_crypto_present;
void		viac3_crypto_setup(void);
#endif /* CRYPTO */
a141 7
#ifdef CRYPTO
	/*
	 * Also, if the chip has crypto available, enable it.
	 */
	if (viac3_crypto_present)
		viac3_crypto_setup();
#endif /* CRYPTO */
a371 1
		cnpollc(TRUE);
a372 1
		cnpollc(FALSE);
@


1.29
log
@acd goes away
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.28 1997/10/28 10:52:18 niklas Exp $	*/
d65 1
d68 1
a68 1
void setconf __P((void));
d76 1
d96 7
a102 1
	setconf();
d104 8
d113 5
a117 2
	 * Configure swap area and related system
	 * parameter based on device(s) used.
d119 3
a123 1
	cold = 0;
a150 1
u_long	bootdev = 0;		/* should be dev_t, but not until 32 bits */
d199 1
a199 1
	majdev = (bootdev >> B_TYPESHIFT) & B_TYPEMASK;
d203 3
a205 3
	adaptor = (bootdev >> B_ADAPTORSHIFT) & B_ADAPTORMASK;
	part = (bootdev >> B_PARTITIONSHIFT) & B_PARTITIONMASK;
	unit = (bootdev >> B_UNITSHIFT) & B_UNITMASK;
d291 1
a291 1
setconf()
a294 3
#if 0
	int swaponroot = 0;
#endif
d298 1
a298 1
	if (((bootdev >> B_TYPESHIFT) & B_TYPEMASK) == 2) {
a318 6
#if 0
			if (num[0] == '*') {
				strcpy(num, num+1);
				swaponroot++;
			}
#endif
a373 4
#if 0
	if (swaponroot)
		rootdev = dumpdev;
#endif
@


1.28
log
@dkcsum is *really* mandatory.  XXX will be done differently later.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.27 1997/10/27 15:47:48 mickey Exp $	*/
d151 1
a151 1
	"acd",		/* 18 = acd */
a234 4
#include "acd.h"
#if NACD > 0
extern	struct cfdriver acd_cd;
#endif
a265 3
#endif
#if NACD > 0
	{ &acd_cd,  "acd",  18 },
@


1.27
log
@check bios_diskinfo for NULL in dkcsumattach()
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.26 1997/10/27 14:42:02 niklas Exp $	*/
a64 6
#include "bios.h"
#if NBIOS > 0
extern void dkcsumattach __P((void));		/* XXX should be elsewhere */
int i386_mountroot __P((void));
#endif

a365 3
#if NBIOS > 0
	mountroot = i386_mountroot;
#else
a366 1
#endif
a374 10

#if NBIOS > 0
int
i386_mountroot()
{
	/* Establish BIOS to BSD disk mappings.  */
	dkcsumattach();
	return (dk_mountroot());
}
#endif
@


1.26
log
@Mandatory disk signature BIOS->BSD mapping enabled
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.25 1997/05/22 05:28:58 deraadt Exp $	*/
a66 1
#include <machine/biosvar.h>
a67 1
extern bios_diskinfo_t *bios_diskinfo;		/* XXX should be elsewhere */
d391 1
a391 2
	if (bios_diskinfo)
		dkcsumattach();
@


1.25
log
@-a support for rd; from mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.24 1996/12/15 01:34:49 deraadt Exp $	*/
d65 8
d374 3
d378 1
d387 11
@


1.24
log
@allow sd0a for root device prompt
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.23 1996/12/06 15:59:20 deraadt Exp $	*/
d150 1
a150 1
	"",		/* 17 */
d243 4
d267 3
@


1.23
log
@sizeof(x)/sizeof(x[0]) is your friend
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.22 1996/12/05 14:27:50 deraadt Exp $	*/
d274 1
a274 1
	int unit;
d309 1
a309 1
			unit = 0;
d311 8
d331 2
a332 1
				printf("root on %s%da\n", gc->gc_name, unit);
d334 1
a334 1
				    unit * MAXPARTITIONS);
d342 2
a343 1
					printf("%s%d ", gc->gc_name, unit);
@


1.22
log
@do setroot() based on wd.h/NWD and fd.h/NFD
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.21 1996/11/10 21:31:52 downsj Exp $	*/
d180 2
a181 1
	if ((majdev > 20) || (*devname[majdev] == '\0'))
d200 1
a200 2
		    (mindev / MAXPARTITIONS) ==
		    (minor(swp->sw_dev) / MAXPARTITIONS)) {
@


1.21
log
@Move fd back.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.20 1996/11/10 10:23:46 downsj Exp $	*/
d219 2
a220 2
#include "wdc.h"
#if NWDC > 0
d249 1
a249 1
#if NWDC > 0
d252 1
a252 1
#if NFDC > 0
@


1.20
log
@comment
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 1996/11/10 10:18:56 downsj Exp $	*/
d135 1
a135 1
	"",		/* 2 */
d153 1
a153 1
	"fd"		/* 20 = fd */
d252 3
a266 3
#if NFDC > 0
	{ &fd_cd,  "fd",  20 },
#endif
d281 1
a281 1
	if (((bootdev >> B_TYPESHIFT) & B_TYPEMASK) == 20) {
@


1.19
log
@Repair setroot() to at least have a chance of working after Theo's changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.18 1996/11/10 09:49:14 downsj Exp $	*/
d140 1
a140 1
	"mcd",		/* 7 */
@


1.18
log
@Another change Theo missed, plus some stylistic changes
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17 1996/11/06 02:09:39 deraadt Exp $	*/
d132 22
a153 6
static	char devname[][2] = {
	{ 'w','d' },	/* 0 = wd */
	{ 's','w' },	/* 1 = sw */
	{ 'f','d' },	/* 2 = fd */
	{ 'w','t' },	/* 3 = wt */
	{ 's','d' },	/* 4 = sd -- new SCSI system */
d180 1
a180 1
	if (majdev > sizeof(devname) / sizeof(devname[0]))
d194 1
a194 3
	printf("root on %c%c%d%c\n",
	    devname[majdev][0], devname[majdev][1],
	    unit, part + 'a');
@


1.17
log
@fd moves, acd gets added
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.16 1996/11/06 01:37:23 deraadt Exp $	*/
a208 4
#include "fd.h"
#if NFD > 0
extern	struct cfdriver fd_cd;
#endif
d225 4
d247 3
a252 3
#if NACD > 0
	{ &acd_cd,  "acd",  18 },
#endif
d267 1
a267 1
	if (((bootdev >> B_TYPESHIFT) & B_TYPEMASK) == 2) {
@


1.16
log
@use dk_mountroot
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 1996/10/16 23:11:44 deraadt Exp $	*/
d225 4
d248 4
a251 1
	{ &fd_cd,  "fd",  2 },
@


1.15
log
@proto
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.14 1996/09/29 08:00:41 downsj Exp $	*/
a251 2
	extern int ffs_mountroot __P((void *));
	extern int (*mountroot) __P((void *));
d328 1
a328 1
	mountroot = ffs_mountroot;
@


1.14
log
@Your average one line commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.13 1996/09/28 08:31:21 downsj Exp $	*/
d62 2
@


1.13
log
@Add INSTALL floppy filesystem goop.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.12 1996/09/01 20:55:20 downsj Exp $	*/
d262 2
a263 1
		cngetc();
@


1.12
log
@initial commit of split fdc/fd drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 1996/06/16 01:14:56 deraadt Exp $	*/
d258 7
@


1.11
log
@use getsn() from libkern
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.10 1996/06/01 11:54:31 deraadt Exp $	*/
d207 2
a208 2
#include "fdc.h"
#if NFDC > 0
@


1.10
log
@first attempt at `swap generic' and `boot -a' support. it is a bit ugly,
but it works.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 1996/05/07 07:21:29 deraadt Exp $	*/
a246 2
void	gets __P((char *));

d263 1
a263 1
		gets(name);
a327 38
}

void
gets(cp)
	char *cp;
{
	register char *lp;
	register c;

	lp = cp;
	for (;;) {
		c = cngetc() & 0177;
		switch (c) {
		case '\n':
		case '\r':
			printf("\n");
			*lp++ = '\0';
			return;
		case '\010':
		case '\177':
			if (lp > cp) {
				printf("\b \b");
				lp--;
			}
			break;
		case 'u' & 037:
			while (lp > cp) {
				printf("\b \b");
				lp--;
			}
			break;
		case '\t':
			c = ' ';
		default:
			printf("%c", c);
			*lp++ = c;
		}
	}
@


1.9
log
@sync with 0504; prototype changes
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.8 1996/04/21 22:16:22 deraadt Exp $	*/
d65 1
a91 3
#if GENERIC
	if ((boothowto & RB_ASKNAME) == 0)
		setroot();
d93 1
a93 3
#else
	setroot();
#endif
d138 5
a157 3
#if 0
	printf("howto %x bootdev %x ", boothowto, bootdev);
#endif
d176 3
a178 3
	printf("changing root device to %c%c%d%c\n",
		devname[majdev][0], devname[majdev][1],
		unit, part + 'a');
d183 2
a184 2
		    (mindev / MAXPARTITIONS)
		    == (minor(swp->sw_dev) / MAXPARTITIONS)) {
d201 167
@


1.8
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: autoconf.c,v 1.7 1996/04/18 19:18:05 niklas Exp $	*/
/*	$NetBSD: autoconf.c,v 1.19 1996/03/29 01:15:04 mycroft Exp $	*/
d61 1
d63 2
a64 6
void	swapconf __P((void));
void	setroot __P((void));

void	setroot __P((void));
void	swapconf __P((void));
void	dumpconf __P((void));
d135 5
a139 5
	'w','d',	/* 0 = wd */
	's','w',	/* 1 = sw */
	'f','d',	/* 2 = fd */
	'w','t',	/* 3 = wt */
	's','d',	/* 4 = sd -- new SCSI system */
d151 4
a154 1
	dev_t temp, orootdev;
d157 3
a159 1
/*printf("howto %x bootdev %x ", boothowto, bootdev);*/
@


1.7
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD: autoconf.c,v 1.5 1996/04/17 05:18:49 mickey Exp $	*/
/*	$NetBSD: autoconf.c,v 1.18 1996/03/04 03:26:18 cgd Exp $	*/
d64 4
@


1.6
log
@Fix prototyping, so it's compiling again.
@
text
@d2 1
a2 1
/*	$NetBSD: autoconf.c,v 1.14 1995/12/28 19:16:48 thorpej Exp $	*/
d81 2
a82 3
	config_rootfound("isa", NULL);
	config_rootfound("eisa", NULL);
	config_rootfound("pci", NULL);
@


1.5
log
@Cleanups & fixes from latest NetBSD primarily to run doscmd, etc.
GENERIC added to the compile/.cvsignore (it is used for 'make links'
for example), thus conf/GENERIC should appear magically ...
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d61 3
@


1.4
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 1
d72 1
d107 1
d144 1
@


1.3
log
@Allow use of Pentium cycle counter for high-precision time keeping;
from FreeBSD
@
text
@d73 3
@


1.2
log
@from netbsd:
Move the old-style disk instrumentation "structures" to a central
location (sys/kern/subr_disk.c) and note that they should/will be
deprecated.
@
text
@a72 3

	startrtclock();

@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: autoconf.c,v 1.13 1994/11/04 00:36:47 mycroft Exp $	*/
a65 1
int	dkn;		/* number of iostat dk numbers assigned so far */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
