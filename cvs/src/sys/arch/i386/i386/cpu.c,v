head	1.84;
access;
symbols
	OPENBSD_6_1:1.81.0.4
	OPENBSD_6_1_BASE:1.81
	OPENBSD_6_0:1.78.0.2
	OPENBSD_6_0_BASE:1.78
	OPENBSD_5_9:1.71.0.2
	OPENBSD_5_9_BASE:1.71
	OPENBSD_5_8:1.67.0.4
	OPENBSD_5_8_BASE:1.67
	OPENBSD_5_7:1.61.0.2
	OPENBSD_5_7_BASE:1.61
	OPENBSD_5_6:1.55.0.4
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.54.0.4
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.50.0.2
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.48.0.2
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.44.0.2
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.6
	OPENBSD_5_0:1.42.0.4
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.41.0.2
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.4
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.34.0.2
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.30.0.2
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	UBC_SYNC_A:1.1
	UBC_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.84
date	2017.05.30.15.11.32;	author deraadt;	state Exp;
branches;
next	1.83;
commitid	KepHUzDSsoNf5ym4;

1.83
date	2017.05.27.12.21.50;	author tedu;	state Exp;
branches;
next	1.82;
commitid	bXNHKOqIkb2LnYuD;

1.82
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.81;
commitid	2Gtqjzrin9LL2yHk;

1.81
date	2017.03.28.17.28.35;	author kettenis;	state Exp;
branches;
next	1.80;
commitid	dlppAvWAALWJYLAQ;

1.80
date	2016.10.21.06.20.58;	author mlarkin;	state Exp;
branches;
next	1.79;
commitid	szRuKZ9HgqvwYLcM;

1.79
date	2016.07.28.21.57.56;	author kettenis;	state Exp;
branches;
next	1.78;
commitid	h0GHFDGWnEdswfbK;

1.78
date	2016.06.28.05.37.50;	author mlarkin;	state Exp;
branches;
next	1.77;
commitid	ok6fKTnq7WY1hK1K;

1.77
date	2016.05.18.03.45.11;	author mlarkin;	state Exp;
branches;
next	1.76;
commitid	JQz4IJ6cQ8DinMqc;

1.76
date	2016.05.03.08.30.15;	author kettenis;	state Exp;
branches;
next	1.75;
commitid	MZpYt2QjcBZtOFba;

1.75
date	2016.04.29.16.49.53;	author mpi;	state Exp;
branches;
next	1.74;
commitid	kLGRoBzBa5Gai7Fe;

1.74
date	2016.03.17.13.18.47;	author mpi;	state Exp;
branches;
next	1.73;
commitid	YYXwHgvcvZhstSh4;

1.73
date	2016.03.15.03.17.50;	author guenther;	state Exp;
branches;
next	1.72;
commitid	hTA8iQcFPhTNwQXL;

1.72
date	2016.03.07.05.32.46;	author naddy;	state Exp;
branches;
next	1.71;
commitid	Ht3NH0pdlkYC6Nxx;

1.71
date	2016.02.03.03.25.07;	author guenther;	state Exp;
branches;
next	1.70;
commitid	ApB7haYYMOab9uut;

1.70
date	2015.12.27.04.31.34;	author jsg;	state Exp;
branches;
next	1.69;
commitid	dxEnyjnljo1QbPFz;

1.69
date	2015.12.07.06.34.14;	author jsg;	state Exp;
branches;
next	1.68;
commitid	SlCrK8YSV6f5HTmS;

1.68
date	2015.11.06.02.49.06;	author jsg;	state Exp;
branches;
next	1.67;
commitid	nlbTMB8LfRYbpeN6;

1.67
date	2015.07.18.19.21.03;	author sf;	state Exp;
branches;
next	1.66;
commitid	fKIY1z4O2YV68kXY;

1.66
date	2015.07.18.19.19.14;	author sf;	state Exp;
branches;
next	1.65;
commitid	2xGM1gJBLGHVxwpd;

1.65
date	2015.07.18.00.53.37;	author guenther;	state Exp;
branches;
next	1.64;
commitid	ATWH37CkH1qgVxC1;

1.64
date	2015.06.07.06.24.59;	author guenther;	state Exp;
branches;
next	1.63;
commitid	TPuT1ptKkvRzlUfp;

1.63
date	2015.04.19.06.27.17;	author sf;	state Exp;
branches;
next	1.62;
commitid	4CLlh1CnkUSpsRbo;

1.62
date	2015.04.18.22.16.21;	author kettenis;	state Exp;
branches;
next	1.61;
commitid	yRnPx9jjsPnb6oP6;

1.61
date	2015.02.11.05.54.48;	author dlg;	state Exp;
branches;
next	1.60;
commitid	fAl1KR17j4jH74Xf;

1.60
date	2015.01.27.02.15.30;	author mlarkin;	state Exp;
branches;
next	1.59;
commitid	fqOdFIelIDboxIK2;

1.59
date	2014.12.18.16.23.25;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	gw4ExnCJDIr6LMDe;

1.58
date	2014.12.14.05.04.49;	author guenther;	state Exp;
branches;
next	1.57;
commitid	tJI2pEquN5s3HlpJ;

1.57
date	2014.11.16.12.30.57;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	yv0ECmCdICvq576h;

1.56
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.55;
commitid	uzzBR7hz9ncd4O6G;

1.55
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.54;

1.54
date	2014.01.19.12.45.35;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2013.12.19.23.44.55;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2013.12.19.21.30.02;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2013.10.09.01.48.40;	author guenther;	state Exp;
branches;
next	1.50;

1.50
date	2013.06.03.16.55.21;	author guenther;	state Exp;
branches;
next	1.49;

1.49
date	2013.05.30.15.58.06;	author mlarkin;	state Exp;
branches;
next	1.48;

1.48
date	2012.11.02.15.10.28;	author jsg;	state Exp;
branches;
next	1.47;

1.47
date	2012.10.31.03.30.22;	author jsg;	state Exp;
branches;
next	1.46;

1.46
date	2012.10.09.04.40.36;	author jsg;	state Exp;
branches;
next	1.45;

1.45
date	2012.09.19.20.19.31;	author jsg;	state Exp;
branches;
next	1.44;

1.44
date	2012.07.09.15.25.37;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2012.07.09.09.07.28;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2010.11.27.13.03.04;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2010.07.25.21.43.35;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.39;

1.39
date	2010.05.08.16.54.07;	author oga;	state Exp;
branches;
next	1.38;

1.38
date	2010.04.16.17.44.00;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2010.04.08.19.28.31;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2010.04.01.19.48.50;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2009.06.03.00.49.12;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2009.01.20.20.21.03;	author mlarkin;	state Exp;
branches;
next	1.33;

1.33
date	2008.10.19.20.48.10;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2008.10.15.23.23.47;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2008.10.05.16.57.36;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.28.17.05.09;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.27.16.22.13;	author martynas;	state Exp;
branches;
next	1.27;

1.27
date	2007.11.16.16.16.06;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.10.15.53.51;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.29.18.18.20;	author tom;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.26.22.09.17;	author weingart;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.08.18.51.59;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2007.04.24.12.58.50;	author tom;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.20.21.15.01;	author tom;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.10.17.50.30;	author gwk;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.11.13.21.11;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.27.15.37.50;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.12.22.39.20;	author weingart;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.23.11.30.14;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.18.02.43.25;	author fgsch;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2005.05.27.10.41.11;	author kjell;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.26.04.02.44;	author kjell;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.09.09.29.52;	author deraadt;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2004.07.14.19.24.29;	author tom;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.14.18.35.50;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.27.23.59.00;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.24.19.35.23;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.23.17.23.27;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.23.17.14.31;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.20.19.33.07;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.17.00.37.24;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.16.18.23.05;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.14.10.02.24;	author ho;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.07.14.10.02.24;	author ho;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.07.15.15.10.54;	author ho;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.07.16.23.05.15;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2003.04.04.15.02.03;	author niklas;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2003.04.11.16.12.56;	author niklas;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2003.05.15.04.08.01;	author niklas;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2003.05.17.19.15.20;	author niklas;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2004.03.14.22.08.20;	author niklas;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2004.03.18.02.09.28;	author niklas;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	2004.03.23.00.57.51;	author niklas;	state Exp;
branches;
next	1.1.2.13;

1.1.2.13
date	2004.03.30.09.06.50;	author niklas;	state Exp;
branches;
next	1.1.2.14;

1.1.2.14
date	2004.04.06.13.30.48;	author niklas;	state Exp;
branches;
next	1.1.2.15;

1.1.2.15
date	2004.06.06.18.11.04;	author grange;	state Exp;
branches;
next	1.1.2.16;

1.1.2.16
date	2004.06.08.19.57.15;	author markus;	state Exp;
branches;
next	1.1.2.17;

1.1.2.17
date	2004.06.08.21.41.37;	author grange;	state Exp;
branches;
next	1.1.2.18;

1.1.2.18
date	2004.06.11.05.22.23;	author deraadt;	state Exp;
branches;
next	1.1.2.19;

1.1.2.19
date	2004.06.13.07.31.56;	author deraadt;	state Exp;
branches;
next	1.1.2.20;

1.1.2.20
date	2004.06.13.18.46.04;	author art;	state Exp;
branches;
next	;

1.12.4.1
date	2006.01.13.00.49.20;	author brad;	state Exp;
branches;
next	;

1.15.2.1
date	2006.01.13.01.56.54;	author brad;	state Exp;
branches;
next	;


desc
@@


1.84
log
@Support for SMAP is pretty small, so don't exclude it from the RAMDISKS.
ok jsg visa
@
text
@/*	$OpenBSD: cpu.c,v 1.83 2017/05/27 12:21:50 tedu Exp $	*/
/* $NetBSD: cpu.c,v 1.1.2.7 2000/06/26 02:04:05 sommerfeld Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1999 Stefan Grefen
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the NetBSD
 *      Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "lapic.h"
#include "ioapic.h"
#include "vmm.h"

#include <sys/param.h>
#include <sys/timeout.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/memrange.h>
#include <sys/atomic.h>

#include <uvm/uvm_extern.h>

#include <machine/codepatch.h>
#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/cpuvar.h>
#include <machine/pmap.h>
#include <machine/vmparam.h>
#include <machine/mpbiosvar.h>
#include <machine/npx.h>
#include <machine/pcb.h>
#include <machine/specialreg.h>
#include <machine/segments.h>
#include <machine/gdt.h>
#include <machine/pio.h>
#include <dev/rndvar.h>

#if NLAPIC > 0
#include <machine/apicvar.h>
#include <machine/i82489reg.h>
#include <machine/i82489var.h>
#endif

#if NIOAPIC > 0
#include <machine/i82093reg.h>
#include <machine/i82093var.h>
#endif

#include <dev/ic/mc146818reg.h>
#include <i386/isa/nvram.h>
#include <dev/isa/isareg.h>

int     cpu_match(struct device *, void *, void *);
void    cpu_attach(struct device *, struct device *, void *);
int     cpu_activate(struct device *, int);
void	patinit(struct cpu_info *ci);
void	cpu_idle_mwait_cycle(void);
void	cpu_init_mwait(struct device *);
#if NVMM > 0
void	cpu_init_vmm(struct cpu_info *ci);
#endif /* NVMM > 0 */

u_int cpu_mwait_size, cpu_mwait_states;

#ifdef MULTIPROCESSOR
int mp_cpu_start(struct cpu_info *);
void mp_cpu_start_cleanup(struct cpu_info *);
struct cpu_functions mp_cpu_funcs =
    { mp_cpu_start, NULL, mp_cpu_start_cleanup };
#endif

/*
 * Statically-allocated CPU info for the primary CPU (or the only
 * CPU, on uniprocessors).  The CPU info list is initialized to
 * point at it.
 */
struct cpu_info cpu_info_primary;
struct cpu_info *cpu_info_list = &cpu_info_primary;

void	cpu_init_tss(struct i386tss *, void *, void *);
void	cpu_set_tss_gates(struct cpu_info *);

#ifdef MULTIPROCESSOR
/*
 * Array of CPU info structures.  Must be statically-allocated because
 * curproc, etc. are used early.
 */

struct cpu_info *cpu_info[MAXCPUS] = { &cpu_info_primary };

void   	cpu_hatch(void *);
void   	cpu_boot_secondary(struct cpu_info *);
void	cpu_copy_trampoline(void);

/*
 * Runs once per boot once multiprocessor goo has been detected and
 * the local APIC has been mapped.
 * Called from mpbios_scan();
 */
void
cpu_init_first(void)
{
	cpu_copy_trampoline();
}
#endif

struct cfattach cpu_ca = {
	sizeof(struct cpu_info), cpu_match, cpu_attach, NULL, cpu_activate
};

struct cfdriver cpu_cd = {
	NULL, "cpu", DV_DULL /* XXX DV_CPU */
};

void	replacesmap(void);

extern int _stac;
extern int _clac;

u_int32_t mp_pdirpa;

void
replacesmap(void)
{
	static int replacedone = 0;
	int s;

	if (replacedone)
		return;
	replacedone = 1;

	s = splhigh();

	codepatch_replace(CPTAG_STAC, &_stac, 3);
	codepatch_replace(CPTAG_CLAC, &_clac, 3);

	splx(s);
}

int
cpu_match(struct device *parent, void *match, void *aux)
{
  	struct cfdata *cf = match;
	struct cpu_attach_args *caa = aux;

	if (strcmp(caa->caa_name, cf->cf_driver->cd_name) != 0)
		return 0;

	if (cf->cf_unit >= MAXCPUS)
		return 0;

	return 1;
}

void
cpu_attach(struct device *parent, struct device *self, void *aux)
{
	struct cpu_info *ci = (struct cpu_info *)self;
	struct cpu_attach_args *caa = (struct cpu_attach_args *)aux;

#ifdef MULTIPROCESSOR
	int cpunum = ci->ci_dev.dv_unit;
	vaddr_t kstack;
	struct pcb *pcb;
#endif

	if (caa->cpu_role == CPU_ROLE_AP) {
#ifdef MULTIPROCESSOR
		if (cpu_info[cpunum] != NULL)
			panic("cpu at apic id %d already attached?", cpunum);
		cpu_info[cpunum] = ci;
#endif
	} else {
		ci = &cpu_info_primary;
#ifdef MULTIPROCESSOR
		if (caa->cpu_apicid != lapic_cpu_number()) {
			panic("%s: running cpu is at apic %d"
			    " instead of at expected %d",
			    self->dv_xname, lapic_cpu_number(), caa->cpu_apicid);
		}
#endif
		bcopy(self, &ci->ci_dev, sizeof *self);
	}

	ci->ci_self = ci;
	ci->ci_apicid = caa->cpu_apicid;
	ci->ci_acpi_proc_id = caa->cpu_acpi_proc_id;
#ifdef MULTIPROCESSOR
	ci->ci_cpuid = cpunum;
#else
	ci->ci_cpuid = 0;	/* False for APs, so what, they're not used */
#endif
	ci->ci_signature = caa->cpu_signature;
	ci->ci_feature_flags = caa->feature_flags;
	ci->ci_func = caa->cpu_func;

#ifdef MULTIPROCESSOR
	/*
	 * Allocate UPAGES contiguous pages for the idle PCB and stack.
	 */

	kstack = uvm_km_alloc(kernel_map, USPACE);
	if (kstack == 0) {
		if (cpunum == 0) { /* XXX */
			panic("cpu_attach: unable to allocate idle stack for"
			    " primary");
		}
		printf("%s: unable to allocate idle stack\n",
		    ci->ci_dev.dv_xname);
		return;
	}
	pcb = ci->ci_idle_pcb = (struct pcb *)kstack;
	memset(pcb, 0, USPACE);

	pcb->pcb_tss.tss_ss0 = GSEL(GDATA_SEL, SEL_KPL);
	pcb->pcb_tss.tss_esp0 = kstack + USPACE - 16 -
	    sizeof (struct trapframe);
	pcb->pcb_tss.tss_esp = kstack + USPACE - 16 -
	    sizeof (struct trapframe);
	pcb->pcb_pmap = pmap_kernel();
	pcb->pcb_cr3 = pcb->pcb_pmap->pm_pdirpa;
#endif
	ci->ci_curpmap = pmap_kernel();

	/* further PCB init done later. */

	printf(": ");

	switch (caa->cpu_role) {
	case CPU_ROLE_SP:
		printf("(uniprocessor)\n");
		ci->ci_flags |= CPUF_PRESENT | CPUF_SP | CPUF_PRIMARY;
		identifycpu(ci);
#ifdef MTRR
		mem_range_attach();
#endif
		cpu_init(ci);
		cpu_init_mwait(&ci->ci_dev);
		break;

	case CPU_ROLE_BP:
		printf("apid %d (boot processor)\n", caa->cpu_apicid);
		ci->ci_flags |= CPUF_PRESENT | CPUF_BSP | CPUF_PRIMARY;
		identifycpu(ci);
#ifdef MTRR
		mem_range_attach();
#endif
		cpu_init(ci);

#if NLAPIC > 0
		/*
		 * Enable local apic
		 */
		lapic_enable();
		lapic_calibrate_timer(ci);
#endif
#if NIOAPIC > 0
		ioapic_bsp_id = caa->cpu_apicid;
#endif
		cpu_init_mwait(&ci->ci_dev);
		break;

	case CPU_ROLE_AP:
		/*
		 * report on an AP
		 */
		printf("apid %d (application processor)\n", caa->cpu_apicid);

#ifdef MULTIPROCESSOR
		gdt_alloc_cpu(ci);
		ci->ci_flags |= CPUF_PRESENT | CPUF_AP;
		identifycpu(ci);
		sched_init_cpu(ci);
		ci->ci_next = cpu_info_list->ci_next;
		cpu_info_list->ci_next = ci;
		ncpus++;
#endif
		break;

	default:
		panic("unknown processor type??");
	}

#ifdef MULTIPROCESSOR
	if (mp_verbose) {
		printf("%s: kstack at 0x%lx for %d bytes\n",
		    ci->ci_dev.dv_xname, kstack, USPACE);
		printf("%s: idle pcb at %p, idle sp at 0x%x\n",
		    ci->ci_dev.dv_xname, pcb, pcb->pcb_esp);
	}
#endif

#if NVMM > 0
	cpu_init_vmm(ci);
#endif /* NVMM > 0 */
}

/*
 * Initialize the processor appropriately.
 */

void
cpu_init(struct cpu_info *ci)
{
	u_int cr4 = 0;

	/* configure the CPU if needed */
	if (ci->cpu_setup != NULL)
		(*ci->cpu_setup)(ci);

	/*
	 * We do this here after identifycpu() because errata may affect
	 * what we do.
	 */
	patinit(ci);
 
	/*
	 * Enable ring 0 write protection (486 or above, but 386
	 * no longer supported).
	 */
	lcr0(rcr0() | CR0_WP);

	if (cpu_feature & CPUID_PGE)
		cr4 |= CR4_PGE;	/* enable global TLB caching */

	if (ci->ci_feature_sefflags_ebx & SEFF0EBX_SMEP)
		cr4 |= CR4_SMEP;
	if (ci->ci_feature_sefflags_ebx & SEFF0EBX_SMAP)
		cr4 |= CR4_SMAP;
	if (ci->ci_feature_sefflags_ecx & SEFF0ECX_UMIP)
		cr4 |= CR4_UMIP;

	/*
	 * If we have FXSAVE/FXRESTOR, use them.
	 */
	if (cpu_feature & CPUID_FXSR) {
		cr4 |= CR4_OSFXSR;

		/*
		 * If we have SSE/SSE2, enable XMM exceptions.
		 */
		if (cpu_feature & (CPUID_SSE|CPUID_SSE2))
			cr4 |= CR4_OSXMMEXCPT;
	}
	/* no cr4 on most 486s */
	if (cr4 != 0)
		lcr4(rcr4()|cr4);

#ifdef MULTIPROCESSOR
	ci->ci_flags |= CPUF_RUNNING;
	/*
	 * Big hammer: flush all TLB entries, including ones from PTE's
	 * with the G bit set.  This should only be necessary if TLB
	 * shootdown falls far behind.
	 *
	 * Intel Architecture Software Developer's Manual, Volume 3,
	 *	System Programming, section 9.10, "Invalidating the
	 * Translation Lookaside Buffers (TLBS)":
	 * "The following operations invalidate all TLB entries, irrespective
	 * of the setting of the G flag:
	 * ...
	 * "(P6 family processors only): Writing to control register CR4 to
	 * modify the PSE, PGE, or PAE flag."
	 *
	 * (the alternatives not quoted above are not an option here.)
	 *
	 * If PGE is not in use, we reload CR3 for the benefit of
	 * pre-P6-family processors.
	 */

	if (cpu_feature & CPUID_PGE) {
		cr4 = rcr4();
		lcr4(cr4 & ~CR4_PGE);
		lcr4(cr4);
	} else
		tlbflush();
#endif
}

void
cpu_init_vmm(struct cpu_info *ci)
{
	/*
	 * Allocate a per-cpu VMXON region
	 */
	if (ci->ci_vmm_flags & CI_VMM_VMX) {
		ci->ci_vmxon_region_pa = 0;
		ci->ci_vmxon_region = (struct vmxon_region *)malloc(PAGE_SIZE,
		    M_DEVBUF, M_WAITOK|M_ZERO);
	if (!pmap_extract(pmap_kernel(), (vaddr_t)ci->ci_vmxon_region,
	    (paddr_t *)&ci->ci_vmxon_region_pa))
		panic("Can't locate VMXON region in phys mem\n");
	}
}


void
patinit(struct cpu_info *ci)
{
	extern int	pmap_pg_wc;
	u_int64_t	reg;

	if ((ci->ci_feature_flags & CPUID_PAT) == 0)
		return;

	/* 
	 * Set up PAT bits.
	 * The default pat table is the following:
	 * WB, WT, UC- UC, WB, WT, UC-, UC
	 * We change it to:
	 * WB, WC, UC-, UC, WB, WC, UC-, UC.
	 * i.e change the WT bit to be WC.
	 */
	reg = PATENTRY(0, PAT_WB) | PATENTRY(1, PAT_WC) |
	    PATENTRY(2, PAT_UCMINUS) | PATENTRY(3, PAT_UC) |
	    PATENTRY(4, PAT_WB) | PATENTRY(5, PAT_WC) |
	    PATENTRY(6, PAT_UCMINUS) | PATENTRY(7, PAT_UC);

	wrmsr(MSR_CR_PAT, reg);
	pmap_pg_wc = PG_WC;
}

struct timeout rdrand_tmo;
void rdrand(void *);

void
rdrand(void *v)
{
	struct timeout *tmo = v;
	extern int      has_rdrand;
	extern int      has_rdseed;
	uint32_t r;
	uint8_t valid;
	int i;

	if (has_rdrand == 0 && has_rdseed == 0)
		return;
	for (i = 0; i < 4; i++) {
		if (has_rdseed)
			__asm volatile(
			    "rdseed	%0\n\t"
			    "setc	%1\n"
			    : "=r" (r), "=qm" (valid) );
		if (has_rdseed == 0 || valid == 0)
			__asm volatile(
			    "rdrand	%0\n\t"
			    "setc	%1\n"
			    : "=r" (r), "=qm" (valid) );
		if (valid)
			add_true_randomness(r);
	}

	if (tmo)
		timeout_add_msec(tmo, 10);
}

int
cpu_activate(struct device *self, int act)
{
	struct cpu_info *sc = (struct cpu_info *)self;

	switch (act) {
	case DVACT_RESUME:
		if (sc->ci_cpuid == 0)
			rdrand(NULL);
		break;
	}

	return (0);
}

#ifdef MULTIPROCESSOR
void
cpu_boot_secondary_processors(void)
{
	struct cpu_info *ci;
	u_long i;

	for (i = 0; i < MAXCPUS; i++) {
		ci = cpu_info[i];
		if (ci == NULL)
			continue;
		if (ci->ci_idle_pcb == NULL)
			continue;
		if ((ci->ci_flags & CPUF_PRESENT) == 0)
			continue;
		if (ci->ci_flags & (CPUF_BSP|CPUF_SP|CPUF_PRIMARY))
			continue;
		ci->ci_randseed = (arc4random() & 0x7fffffff) + 1;
		cpu_boot_secondary(ci);
	}
}

void
cpu_init_idle_pcbs(void)
{
	struct cpu_info *ci;
	u_long i;

	for (i=0; i < MAXCPUS; i++) {
		ci = cpu_info[i];
		if (ci == NULL)
			continue;
		if (ci->ci_idle_pcb == NULL)
			continue;
		if ((ci->ci_flags & CPUF_PRESENT) == 0)
			continue;
		i386_init_pcb_tss(ci);
	}
}

void
cpu_boot_secondary(struct cpu_info *ci)
{
	struct pcb *pcb;
	int i;
	struct pmap *kpm = pmap_kernel();

	if (mp_verbose)
		printf("%s: starting", ci->ci_dev.dv_xname);

	/* XXX move elsewhere, not per CPU. */
	mp_pdirpa = kpm->pm_pdirpa;

	pcb = ci->ci_idle_pcb;

	if (mp_verbose)
		printf(", init idle stack ptr is 0x%x\n", pcb->pcb_esp);

	CPU_STARTUP(ci);

	/*
	 * wait for it to become ready
	 */
	for (i = 100000; (!(ci->ci_flags & CPUF_RUNNING)) && i > 0; i--) {
		delay(10);
	}
	if (!(ci->ci_flags & CPUF_RUNNING)) {
		printf("%s failed to become ready\n", ci->ci_dev.dv_xname);
#ifdef DDB
		db_enter();
#endif
	}

	CPU_START_CLEANUP(ci);
}

/*
 * The CPU ends up here when it's ready to run
 * XXX should share some of this with init386 in machdep.c
 * for now it jumps into an infinite loop.
 */
void
cpu_hatch(void *v)
{
	struct cpu_info *ci = (struct cpu_info *)v;
	int s;

	cpu_init_idt();
	lapic_enable();
	lapic_startclock();
	lapic_set_lvt();
	gdt_init_cpu(ci);

	lldt(0);

	npxinit(ci);

	ci->ci_curpmap = pmap_kernel();
	cpu_init(ci);

	/* Re-initialise memory range handling on AP */
	if (mem_range_softc.mr_op != NULL)
		mem_range_softc.mr_op->initAP(&mem_range_softc);

	s = splhigh();		/* XXX prevent softints from running here.. */
	lapic_tpr = 0;
	enable_intr();
	if (mp_verbose)
		printf("%s: CPU at apid %ld running\n",
		    ci->ci_dev.dv_xname, ci->ci_cpuid);
	nanouptime(&ci->ci_schedstate.spc_runtime);
	splx(s);

	SCHED_LOCK(s);
	cpu_switchto(NULL, sched_chooseproc());
}

void
cpu_copy_trampoline(void)
{
	/*
	 * Copy boot code.
	 */
	extern u_char cpu_spinup_trampoline[];
	extern u_char cpu_spinup_trampoline_end[];
	extern u_char mp_tramp_data_start[];
	extern u_char mp_tramp_data_end[];

	memcpy((caddr_t)MP_TRAMPOLINE, cpu_spinup_trampoline,
	    cpu_spinup_trampoline_end - cpu_spinup_trampoline);
	memcpy((caddr_t)MP_TRAMP_DATA, mp_tramp_data_start,
	    mp_tramp_data_end - mp_tramp_data_start);

	pmap_write_protect(pmap_kernel(), (vaddr_t)MP_TRAMPOLINE,
	    (vaddr_t)(MP_TRAMPOLINE + NBPG), PROT_READ | PROT_EXEC);
}

#endif

#ifdef notyet
void
cpu_init_tss(struct i386tss *tss, void *stack, void *func)
{
	memset(tss, 0, sizeof *tss);
	tss->tss_esp0 = tss->tss_esp = (int)((char *)stack + USPACE - 16);
	tss->tss_ss0 = GSEL(GDATA_SEL, SEL_KPL);
	tss->__tss_cs = GSEL(GCODE_SEL, SEL_KPL);
	tss->tss_fs = GSEL(GCPU_SEL, SEL_KPL);
	tss->tss_gs = tss->__tss_es = tss->__tss_ds =
	    tss->__tss_ss = GSEL(GDATA_SEL, SEL_KPL);
	tss->tss_cr3 = pmap_kernel()->pm_pdirpa;
	tss->tss_esp = (int)((char *)stack + USPACE - 16);
	tss->tss_ldt = 0;
	tss->__tss_eflags = PSL_MBO | PSL_NT;	/* XXX not needed? */
	tss->__tss_eip = (int)func;
}

/* XXX */
#define IDTVEC(name)	__CONCAT(X, name)
typedef void (vector)(void);
extern vector IDTVEC(tss_trap08);
#ifdef DDB
extern vector Xintrddbipi;
extern int ddb_vec;
#endif

void
cpu_set_tss_gates(struct cpu_info *ci)
{
	struct segment_descriptor sd;

	ci->ci_doubleflt_stack = (char *)uvm_km_alloc(kernel_map, USPACE);
	cpu_init_tss(&ci->ci_doubleflt_tss, ci->ci_doubleflt_stack,
	    IDTVEC(tss_trap08));
	setsegment(&sd, &ci->ci_doubleflt_tss, sizeof(struct i386tss) - 1,
	    SDT_SYS386TSS, SEL_KPL, 0, 0);
	ci->ci_gdt[GTRAPTSS_SEL].sd = sd;
	setgate(&idt[8], NULL, 0, SDT_SYSTASKGT, SEL_KPL,
	    GSEL(GTRAPTSS_SEL, SEL_KPL));

#if defined(DDB) && defined(MULTIPROCESSOR)
	/*
	 * Set up separate handler for the DDB IPI, so that it doesn't
	 * stomp on a possibly corrupted stack.
	 *
	 * XXX overwriting the gate set in db_machine_init.
	 * Should rearrange the code so that it's set only once.
	 */
	ci->ci_ddbipi_stack = (char *)uvm_km_alloc(kernel_map, USPACE);
	cpu_init_tss(&ci->ci_ddbipi_tss, ci->ci_ddbipi_stack,
	    Xintrddbipi);

	setsegment(&sd, &ci->ci_ddbipi_tss, sizeof(struct i386tss) - 1,
	    SDT_SYS386TSS, SEL_KPL, 0, 0);
	ci->ci_gdt[GIPITSS_SEL].sd = sd;

	setgate(&idt[ddb_vec], NULL, 0, SDT_SYSTASKGT, SEL_KPL,
	    GSEL(GIPITSS_SEL, SEL_KPL));
#endif
}
#endif

#ifdef MULTIPROCESSOR
int
mp_cpu_start(struct cpu_info *ci)
{
	unsigned short dwordptr[2];

	/*
	 * "The BSP must initialize CMOS shutdown code to 0Ah ..."
	 */

	outb(IO_RTC, NVRAM_RESET);
	outb(IO_RTC+1, NVRAM_RESET_JUMP);

	/*
	 * "and the warm reset vector (DWORD based at 40:67) to point
	 * to the AP startup code ..."
	 */

	dwordptr[0] = 0;
	dwordptr[1] = MP_TRAMPOLINE >> 4;

	pmap_activate(curproc);

	pmap_kenter_pa(0, 0, PROT_READ | PROT_WRITE);
	memcpy((u_int8_t *)0x467, dwordptr, 4);
	pmap_kremove(0, PAGE_SIZE);

#if NLAPIC > 0
	/*
	 * ... prior to executing the following sequence:"
	 */

	if (ci->ci_flags & CPUF_AP) {
		i386_ipi_init(ci->ci_apicid);

		delay(10000);

		if (cpu_feature & CPUID_APIC) {
			i386_ipi(MP_TRAMPOLINE / PAGE_SIZE, ci->ci_apicid,
			    LAPIC_DLMODE_STARTUP);
			delay(200);

			i386_ipi(MP_TRAMPOLINE / PAGE_SIZE, ci->ci_apicid,
			    LAPIC_DLMODE_STARTUP);
			delay(200);
		}
	}
#endif
	return (0);
}

void
mp_cpu_start_cleanup(struct cpu_info *ci)
{
	/*
	 * Ensure the NVRAM reset byte contains something vaguely sane.
	 */

	outb(IO_RTC, NVRAM_RESET);
	outb(IO_RTC+1, NVRAM_RESET_RST);
}

#endif /* MULTIPROCESSOR */

void
cpu_idle_mwait_cycle(void)
{
	struct cpu_info *ci = curcpu();

	if ((read_eflags() & PSL_I) == 0)
		panic("idle with interrupts blocked!");

	/* something already queued? */
	if (!cpu_is_idle(ci))
		return;

	/*
	 * About to idle; setting the MWAIT_IN_IDLE bit tells
	 * cpu_unidle() that it can't be a no-op and tells cpu_kick()
	 * that it doesn't need to use an IPI.  We also set the
	 * MWAIT_KEEP_IDLING bit: those routines clear it to stop
	 * the mwait.  Once they're set, we do a final check of the
	 * queue, in case another cpu called setrunqueue() and added
	 * something to the queue and called cpu_unidle() between
	 * the check in sched_idle() and here.
	 */
	atomic_setbits_int(&ci->ci_mwait, MWAIT_IDLING | MWAIT_ONLY);
	if (cpu_is_idle(ci)) {
		monitor(&ci->ci_mwait, 0, 0);
		if ((ci->ci_mwait & MWAIT_IDLING) == MWAIT_IDLING)
			mwait(0, 0);
	}

	/* done idling; let cpu_kick() know that an IPI is required */
	atomic_clearbits_int(&ci->ci_mwait, MWAIT_IDLING);
}

void
cpu_init_mwait(struct device *dv)
{
	unsigned int smallest, largest, extensions, c_substates;

	if ((cpu_ecxfeature & CPUIDECX_MWAIT) == 0 || cpuid_level < 0x5)
		return;

	/* get the monitor granularity */
	CPUID(0x5, smallest, largest, extensions, cpu_mwait_states);
	smallest &= 0xffff;
	largest  &= 0xffff;

	printf("%s: mwait min=%u, max=%u", dv->dv_xname, smallest, largest);
	if (extensions & 0x1) {
		if (cpu_mwait_states > 0) {
			c_substates = cpu_mwait_states;
			printf(", C-substates=%u", 0xf & c_substates);
			while ((c_substates >>= 4) > 0)
				printf(".%u", 0xf & c_substates);
		}
		if (extensions & 0x2)
			printf(", IBE");
	} else {
		/* substates not supported, forge the default: just C1 */
		cpu_mwait_states = 1 << 4;
	}

	/* paranoia: check the values */
	if (smallest < sizeof(int) || largest < smallest ||
	    (largest & (sizeof(int)-1)))
		printf(" (bogus)");
	else
		cpu_mwait_size = largest;
	printf("\n");

	/* enable use of mwait; may be overriden by acpicpu later */
	if (cpu_mwait_size > 0)
		cpu_idle_cycle_fcn = &cpu_idle_mwait_cycle;
}

@


1.83
log
@manually inline tlbflushg. it's short and there's only one caller.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.82 2017/04/30 16:45:45 mpi Exp $	*/
a172 1
#ifndef SMALL_KERNEL
a196 1
#endif /* !SMALL_KERNEL */
a385 1
#ifndef SMALL_KERNEL
a389 1
#endif
@


1.82
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.81 2017/03/28 17:28:35 kettenis Exp $	*/
d413 26
a438 1
	tlbflushg();
@


1.81
log
@Reset ci_curmap to kernel_pmap() in cpu_hatch().  Otherwise the lazy pmap
switching code might think the old pmap is still active after a resume
which could lead to a page fault in the kernel.

ok stsp@@, mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.80 2016/10/21 06:20:58 mlarkin Exp $	*/
d578 1
a578 1
		Debugger();
@


1.80
log
@
vmm(4) for i386. Userland changes forthcoming. Note that for the time being,
i386 hosts are limited to running only i386 guests, even if the underlying
hardware supports amd64. This is a restriction I hope to lift moving forward,
but for now please don't report problems running amd64 guests on i386 hosts.

This was a straightforward port of the in-tree amd64 code plus the old rotted
tree I had from last year for i386 support. Changes included converting 64-bit
VMREAD/VMWRITE ops to 2x32-bit ops, and fixing treatment of the TSS, which
differs on i386.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.79 2016/07/28 21:57:56 kettenis Exp $	*/
d606 1
@


1.79
log
@Store the acpi processor ID/UID in struct cpu_info, and use it to attach
acpicpu(4) drivers to the right cpu(4).

ok mlarkin@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.78 2016/06/28 05:37:50 mlarkin Exp $	*/
d69 1
d117 3
d352 4
d418 17
a442 7
#define PATENTRY(n, type)	((u_int64_t)type << ((n) * 8))
#define	PAT_UC		0x0UL
#define	PAT_WC		0x1UL
#define	PAT_WT		0x4UL
#define	PAT_WP		0x5UL
#define	PAT_WB		0x6UL
#define	PAT_UCMINUS	0x7UL
@


1.78
log
@
Enable UMIP feature if present. miod originally pointed this out to me.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.77 2016/05/18 03:45:11 mlarkin Exp $	*/
d232 1
a232 1
		if (caa->cpu_number != lapic_cpu_number()) {
d235 1
a235 1
			    self->dv_xname, lapic_cpu_number(), caa->cpu_number);
d242 2
a243 1
	ci->ci_apicid = caa->cpu_number;
d298 1
a298 1
		printf("apid %d (boot processor)\n", caa->cpu_number);
d314 1
a314 1
		ioapic_bsp_id = caa->cpu_number;
d323 1
a323 1
		printf("apid %d (application processor)\n", caa->cpu_number);
@


1.77
log
@
Split i386 mp hatch trampoline into code and data pages, and protect each
with proper W^X policy. The same thing was done for amd64 late last year,
catching i386 up now. Diff has been in snaps for a few days with no
reported fallout.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.76 2016/05/03 08:30:15 kettenis Exp $	*/
d382 2
@


1.76
log
@Revert previous commit.  Calling sched_init_cpu() from
cpu_boot_secondary_processors() break suspend/resume.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.75 2016/04/29 16:49:53 mpi Exp $	*/
d175 2
a533 1
	extern u_int32_t mp_pdirpa;
d612 2
d615 1
a615 1
	bcopy(cpu_spinup_trampoline, (caddr_t)MP_TRAMPOLINE,
d617 5
@


1.75
log
@Call sched_init_cpu() just before booting secondary CPUs.

This prevent the scheduler from scheduling tasks to CPUs not beeing able
to execute them during the boot process.

ok visa@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.74 2016/03/17 13:18:47 mpi Exp $	*/
d326 1
a502 1
		sched_init_cpu(ci);
@


1.74
log
@Replace curcpu_is_idle() by cpu_is_idle() and use it instead of rolling
our own.

From Michal Mazurek, ok mmcc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.73 2016/03/15 03:17:50 guenther Exp $	*/
a325 1
		sched_init_cpu(ci);
d502 1
@


1.73
log
@Burn more LDT deadwood: stop allocating one for each idle thread,
load the ldt register with the null selector (disabling use of it),
stop reloading it on every context switch, and blow away the table
itself, as well as the pcb and pmap bits that were used to track
it (making sure to keep pcb_savefpu correctly aligned).

testing naddy@@
ok kettenis@@ mpi@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.72 2016/03/07 05:32:46 naddy Exp $	*/
d754 1
a754 1
	if (ci->ci_schedstate.spc_whichqs != 0)
d768 1
a768 1
	if (ci->ci_schedstate.spc_whichqs == 0) {
@


1.72
log
@Sync no-argument function declaration and definition by adding (void).
ok mlarkin@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.71 2016/02/03 03:25:07 guenther Exp $	*/
a274 2

	cpu_default_ldt(ci);	/* Use the `global' ldt until one alloc'd */
a323 1
		cpu_alloc_ldt(ci);
d522 1
a522 1
		i386_init_pcb_tss_ldt(ci);
a578 1
	cpu_init_ldt(ci);
d580 1
a580 1
	lldt(GSEL(GLDT_SEL, SEL_KPL));
d631 1
a631 1
	tss->tss_ldt = GSEL(GLDT_SEL, SEL_KPL);
@


1.71
log
@Test cpuid_level or ci->ci_pnfeatset before using a CPUID leaf; some BIOSes
can disable leaves that CPU feature flags would seem to imply.  Corrects
signal delivery on systems where the AVX leaf is disabled.

report and debugging help from Marcus MERIGHI (mcmer-openbsd (at) tor.at)
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.70 2015/12/27 04:31:34 jsg Exp $	*/
d155 1
a155 1
cpu_init_first()
d491 1
a491 1
cpu_boot_secondary_processors()
d512 1
a512 1
cpu_init_idle_pcbs()
d608 1
a608 1
cpu_copy_trampoline()
@


1.70
log
@If available prefer the rdseed instruction over rdrand when adding entropy
to the kernel rng.  If the rdseed source is empty fallback to rdrand
as suggested by naddy.  rdrand output comes from a prng that is
periodically reseeded.  rdseed should give us more bits of entropy.

ok naddy@@ djm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.69 2015/12/07 06:34:14 jsg Exp $	*/
d787 1
a787 1
	if ((cpu_ecxfeature & CPUIDECX_MWAIT) == 0)
@


1.69
log
@Add cpuid bits documented in the August 2015 revision of
"Intel Architecture Instruction Set Extensions Programming Reference"
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.68 2015/11/06 02:49:06 jsg Exp $	*/
d448 3
a450 1
	uint32_t r, valid;
d453 1
a453 1
	if (has_rdrand == 0)
d456 10
a465 5
		__asm volatile(
		    "xor        %1, %1\n\t"
		    "rdrand     %0\n\t"
		    "rcl        $1, %1\n"
		    : "=r" (r), "=r" (valid) );
@


1.68
log
@Only read/write cr4 if we have a bit to set after testing the various
cpuid based flags.

Unlike amd64 there is no CR4_DEFAULT used here, cr4 does not exist
on most/all? 486s and cr4 access traps on Cyrix 5x86 processors.

Should fix a regression introduced in rev 1.65 encountered
by 'Ppractivus' on a 5x86.

"looks good" guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.67 2015/07/18 19:21:03 sf Exp $	*/
d378 1
a378 1
	if (ci->ci_feature_sefflags & SEFF0EBX_SMEP)
d381 1
a381 1
	if (ci->ci_feature_sefflags & SEFF0EBX_SMAP)
@


1.67
log
@Make {x86,i82489,x2apic,i386}_ipi return void

They always returned 0

ok mlarkin@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.66 2015/07/18 19:19:14 sf Exp $	*/
d357 1
a357 1
	u_int cr4;
a374 1
	cr4 = rcr4();
d397 3
a399 1
	lcr4(cr4);
@


1.66
log
@Make *_ipi_init return void on i386/amd64

They always returned 0

ok mlarkin@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.65 2015/07/18 00:53:37 guenther Exp $	*/
a680 3
#if NLAPIC > 0
	int error;
#endif
d715 2
a716 3
			if ((error = i386_ipi(MP_TRAMPOLINE / PAGE_SIZE,
			    ci->ci_apicid, LAPIC_DLMODE_STARTUP)) != 0)
				return (error);
d719 2
a720 3
			if ((error = i386_ipi(MP_TRAMPOLINE / PAGE_SIZE,
			    ci->ci_apicid, LAPIC_DLMODE_STARTUP)) != 0)
				return (error);
@


1.65
log
@Set all the cr4 bits we want at once, instead of one by one

ok jsg@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.64 2015/06/07 06:24:59 guenther Exp $	*/
d713 1
a713 2
		if ((error = i386_ipi_init(ci->ci_apicid)) != 0)
			return (error);
@


1.64
log
@Enable use of mwait in non-MP boxes and report # of C-substates up to C7,
truncating trailing zeros.

Testing by many as part of a larger change to use ACPI _CST objects
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.63 2015/04/19 06:27:17 sf Exp $	*/
d357 2
d375 1
d377 1
a377 1
		lcr4(rcr4() | CR4_PGE);	/* enable global TLB caching */
d380 1
a380 1
		lcr4(rcr4() | CR4_SMEP);
d383 1
a383 6
		lcr4(rcr4() | CR4_SMAP);
#endif

#ifdef MULTIPROCESSOR
	ci->ci_flags |= CPUF_RUNNING;
	tlbflushg();
d390 1
a390 1
		lcr4(rcr4() | CR4_OSFXSR);
d396 1
a396 1
			lcr4(rcr4() | CR4_OSXMMEXCPT);
d398 6
@


1.63
log
@Binary code patching on i386

This commit ports the infrastructure to do binary code patching from amd64.
The existing code patching for SMAP is converted to the new infrastruture.

ok kettenis@@
"should go in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.62 2015/04/18 22:16:21 kettenis Exp $	*/
d116 2
a117 1
void	cpu_enable_mwait(void);
d293 1
a314 1
#if defined(MULTIPROCESSOR)
a315 1
#endif
a483 2
	cpu_enable_mwait();

d741 2
d765 1
a765 1
	atomic_setbits_int(&ci->ci_mwait, MWAIT_IDLING);
a775 2
u_int cpu_mwait_size;

d785 1
a785 1
	CPUID(0x5, smallest, largest, extensions, c_substates);
d791 6
a796 6
		printf(", C-substates=%u.%u.%u.%u.%u",
		    0xf & (c_substates),
		    0xf & (c_substates >> 4),
		    0xf & (c_substates >> 8),
		    0xf & (c_substates >> 12),
		    0xf & (c_substates >> 16));
d799 3
a810 1
}
d812 1
a812 3
void
cpu_enable_mwait(void)
{
a815 1
#endif /* MULTIPROCESSOR */
@


1.62
log
@It seems that the CPUID lies about the monitor-line size, or at least our
interpretation of it isn't quite right.  So instead of allocating memory
and slicing it based on the parameters returned by CPUID, simply use a member
in struct cpu_info like basically all other OSes out there do.  Our struct
cpu_info is large enough to never cause any overlap.  This makes the
mwait-based idle loop actually work.  We still execute the CPUID instruction
to make sure monitor/mwait is properly supported by the hardware we're
running on.

ok sthen@@, deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.61 2015/02/11 05:54:48 dlg Exp $	*/
d80 1
a170 10
extern int _copyout_stac;
extern int _copyout_clac;
extern int _copyin_stac;
extern int _copyin_clac;
extern int _copy_fault_clac;
extern int _copyoutstr_stac;
extern int _copyinstr_stac;
extern int _copystr_fault_clac;
extern int _ucas_32_stac;
extern int _ucas_32_clac;
a173 16
static const struct {
	void *daddr;
	void *saddr;
} ireplace[] = {
	{ &_copyout_stac, &_stac },
	{ &_copyout_clac, &_clac },
	{ &_copyin_stac, &_stac },
	{ &_copyin_clac, &_clac },
	{ &_copy_fault_clac, &_clac },
	{ &_copyoutstr_stac, &_stac },
	{ &_copyinstr_stac, &_stac },
	{ &_copystr_fault_clac, &_clac },
	{ &_ucas_32_stac, &_stac },
	{ &_ucas_32_clac, &_clac },
};

d178 1
a178 2
	int i, s;
	vaddr_t nva;
a184 20
	/*
	 * Create writeable aliases of memory we need
	 * to write to as kernel is mapped read-only
	 */
	nva = (vaddr_t)km_alloc(2 * PAGE_SIZE, &kv_any, &kp_none, &kd_waitok);

	for (i = 0; i < nitems(ireplace); i++) {
		paddr_t kva = trunc_page((paddr_t)ireplace[i].daddr);
		paddr_t po = (paddr_t)ireplace[i].daddr & PAGE_MASK;
		paddr_t pa1, pa2;

		pmap_extract(pmap_kernel(), kva, &pa1);
		pmap_extract(pmap_kernel(), kva + PAGE_SIZE, &pa2);
		pmap_kenter_pa(nva, pa1, PROT_READ | PROT_WRITE);
		pmap_kenter_pa(nva + PAGE_SIZE, pa2, PROT_READ | PROT_WRITE);
		pmap_update(pmap_kernel());

		/* replace 3 byte nops with stac/clac instructions */
		bcopy(ireplace[i].saddr, (void *)(nva + po), 3);
	}
d186 2
a187 1
	km_free((void *)nva, 2 * PAGE_SIZE, &kv_any, &kp_none);
@


1.61
log
@deprecate use of sys/lock.h and replace it with sys/atomic.h or
machine/lock.h as appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.60 2015/01/27 02:15:30 mlarkin Exp $	*/
a791 1
	volatile int *state = &ci->ci_mwait[0];
d810 1
a810 1
	atomic_setbits_int(state, MWAIT_IDLING);
d812 2
a813 2
		monitor(state, 0, 0);
		if ((*state & MWAIT_IDLING) == MWAIT_IDLING)
d818 1
a818 1
	atomic_clearbits_int(state, MWAIT_IDLING);
d821 1
a821 1
unsigned int mwait_size;
d853 1
a853 1
		mwait_size = largest;
a854 2
	/* XXX disable mwait: ACPI says not to use it on too many systems */
	mwait_size = 0;
d860 1
a860 23
	unsigned long area;
	struct cpu_info *ci;
	CPU_INFO_ITERATOR cii;

	if (mwait_size == 0)
		return;

	/*
	 * Allocate the area, with a bit extra so that we can align
	 * to a multiple of mwait_size
	 */
	area = (unsigned long)malloc((ncpus * mwait_size) + mwait_size
	    - sizeof(int), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (area == 0) {
		printf("cpu0: mwait failed\n");
	} else {
		/* round to a multiple of mwait_size  */
		area = ((area + mwait_size - sizeof(int)) / mwait_size)
		    * mwait_size;
		CPU_INFO_FOREACH(cii, ci) {
			ci->ci_mwait = (int *)area;
			area += mwait_size;
		}
a861 1
	}
@


1.60
log
@
Remove an unused and confusing assignment that had been commented out for
years. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.59 2014/12/18 16:23:25 deraadt Exp $	*/
d76 1
@


1.59
log
@If support is present, use rdrand() at resume time.  Make the rdrand()
function easier to call.
ok reyk djm
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.58 2014/12/14 05:04:49 guenther Exp $	*/
a317 1
	/* pcb->pcb_cr3 = pcb->pcb_pmap->pm_pdir - KERNBASE; XXX ??? */
@


1.58
log
@Disable MWAIT again, this time on both i386 and amd64.  Too many systems
run excessively hot with it to have it on by default, and I still don't
have good logic to let acpicpu enable it when the AML says it's good.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.57 2014/11/16 12:30:57 deraadt Exp $	*/
d110 1
d159 1
a159 1
	sizeof(struct cpu_info), cpu_match, cpu_attach
d487 1
d491 2
d503 17
a519 1
	timeout_add_msec(tmo, 10);
@


1.57
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.56 2014/09/14 14:17:23 jsg Exp $	*/
d836 2
@


1.56
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.55 2014/03/29 18:09:29 guenther Exp $	*/
d222 2
a223 3
		pmap_kenter_pa(nva, pa1, VM_PROT_READ | VM_PROT_WRITE);
		pmap_kenter_pa(nva + PAGE_SIZE, pa2, VM_PROT_READ | 
		    VM_PROT_WRITE);
d726 1
a726 1
	pmap_kenter_pa(0, 0, VM_PROT_READ|VM_PROT_WRITE);
@


1.55
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.54 2014/01/19 12:45:35 deraadt Exp $	*/
d71 1
a71 1
#include <sys/proc.h>
@


1.54
log
@Initialize ci_randseed better using arc4random() + a trick.  Remove the
libkern srandom() API since it is not suitable for this use.
ok kettenis miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.53 2013/12/19 23:44:55 deraadt Exp $	*/
d491 1
a491 1
		__asm __volatile(
@


1.53
log
@oh sorry, I forgot two #ifdef
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.52 2013/12/19 21:30:02 deraadt Exp $	*/
d91 1
a106 1
#include <dev/rndvar.h>
d522 1
a522 1
		ci->ci_randseed = random();
@


1.52
log
@Mtrr stops being a pseudo-device.  We need to probe the cpu type and
initialize the structures when we see the first cpu.  We also need to
initialize each cpu's properly (for PAT) before we setup mtrr on that
cpu.  On i386 (late hatch) we were getting this desperately wrong on
the primary cpu.

After suspend/resume, we also need to do the same work.  re-initialize
PAT before mtrr.  On some laptops apparently PAT was not turned on by the
BIOS, so we ended up with incorrect setup for the primary cpu.  Oops.

This makes mplayer on the x201 (and similar) machines work without weird
pauses after a suspend/resume.  Many other things are likely fixed.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.51 2013/10/09 01:48:40 guenther Exp $	*/
d333 1
d335 1
d343 1
d345 1
@


1.51
log
@Use monitor/mwait to idle when available.  Make cpu_unidle() do nothing
if it can tell the target CPU isn't actually idling and introduce cpu_kick()
for the cases where we want to force a non-idle CPU into the kernel.

just a port of the amd64 version; testing by many
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.50 2013/06/03 16:55:21 guenther Exp $	*/
d333 1
d341 1
d595 3
d600 1
a600 1
	lldt(GSEL(GLDT_SEL, SEL_KPL));
a604 2

	cpu_init(ci);
@


1.50
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.49 2013/05/30 15:58:06 mlarkin Exp $	*/
d74 1
d111 3
d352 3
d504 2
d761 102
a862 1
#endif
@


1.49
log
@

fix typos in some comments
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.48 2012/11/02 15:10:28 jsg Exp $	*/
d600 1
a600 1
	microuptime(&ci->ci_schedstate.spc_runtime);
@


1.48
log
@uvm_km_alloc() allocs bytes rounded up to the nearest page not pages.
Problem spotted by and diff to fix this (and convert to km_alloc) from oga

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.47 2012/10/31 03:30:22 jsg Exp $	*/
d568 1
a568 1
 * The CPU ends up here when its ready to run
@


1.47
log
@Add support for Intel's Supervisor Mode Access Prevention (SMAP) feature.
When enabled SMAP will generate page faults on the kernel attempting
to read/write user data pages unless an override flag is set.

Instructions that modify the flag are patched into copyin/copyout and
friends on boot if SMAP is enabled.

Those with access to hardware with SMAP can contact me for a test case.

joint work with deraadt@@

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.46 2012/10/09 04:40:36 jsg Exp $	*/
d209 1
a209 1
	nva = uvm_km_valloc(kernel_map, 2);
d227 1
a227 1
	uvm_km_free(kernel_map, nva, 2);
@


1.46
log
@Enable Supervisor Mode Execution Protection (SMEP), found in recent
Intel chips.  If the kernel is tricked into running code from a user
page while in supervisor mode we'll now get a page fault and panic
instead of running it.

suggestions and ok guenther@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.45 2012/09/19 20:19:31 jsg Exp $	*/
d161 72
d410 4
@


1.45
log
@Add support for the rdrand instruction found in recent Intel processors.
Joint work with naddy@@

ok naddy@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.44 2012/07/09 15:25:37 deraadt Exp $	*/
d335 3
@


1.44
log
@After a resume, re-initialize the MTRR registers on the AP processors
as well.  This fixes very slow performance due to lots of uncached
memory on buggy machines, for instance on very large memory thinkpad
W500 and such.
ok mlarkin kettenis sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.43 2012/07/09 09:07:28 deraadt Exp $	*/
d105 1
d388 22
@


1.43
log
@Do not re-initialize ci_randseed on the primary cpu
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.42 2010/11/27 13:03:04 kettenis Exp $	*/
d74 1
d485 4
@


1.42
log
@Make sure we don't attach more CPUs than we can handle.  Prevents an
out-of-bounds array access later on.

Allows OpenBSD to boot on machines with more than 32 CPUs/cores.

ok krw@@, jsing@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.41 2010/07/25 21:43:35 deraadt Exp $	*/
a397 1
		ci->ci_randseed = random();
d404 1
@


1.41
log
@in the clock drivers, seperate the soft-state and hard-state which was
all jumbled up in the same functions. the rtc (mc chip) and clock (i8243)
startup was also mixed up.  they the soft state and hardware state can
be started in the right order, and it is easy to restart just the
neccessary parts upon resume.  tested in numerous cases:
(apic, pic) * (GENERIC.MP, GENERIC) * (mp, non-mp) * (i386, amd64)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.40 2010/06/26 23:24:43 guenther Exp $	*/
d160 1
a160 1
cpu_match(struct device *parent, void *matchv, void *aux)
d162 2
a163 2
  	struct cfdata *match = (struct cfdata *)matchv;
	struct cpu_attach_args *caa = (struct cpu_attach_args *)aux;
d165 7
a171 3
	if (strcmp(caa->caa_name, match->cf_driver->cd_name) == 0)
		return (1);
	return (0);
@


1.40
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.39 2010/05/08 16:54:07 oga Exp $	*/
d473 1
a473 1
	lapic_initclocks();
@


1.39
log
@Page Attribute Tables (PAT) support for x86.

PAT allows setting per-mapping cachability bits. Our main interest in it
for write combining mappings so we do not have to rely so heaviliy on
mtrrs (which are stupidly set up on more and more machines). MD flags to
pmap allow setting these bits (which bus_space now uses for PREFETCHABLE
maps), if a vm page has a bit set, then we will use WC for all mappings
of a page (used for userland mappings). We also check for known errata
and fall back to UC- mappings in that case.

comments from kettenis@@, tedu@@ and william@@. kettenis@@, tedu@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.38 2010/04/16 17:44:00 kettenis Exp $	*/
a71 1
#include <sys/user.h>
@


1.38
log
@Use a somewhat bigger hammer and als flush tlb entries that have the global
bit set.  While there, add an #ifdef MULTIPROCESSOR to make the diff between
amd64 and i386 smaller.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.37 2010/04/08 19:28:31 kettenis Exp $	*/
d108 1
d317 6
d349 34
@


1.37
log
@Since we only start doing tlb shootdowns after setting the CPUF_RUNNING flag,
flush the TLB immediately after doing so, to make sure there are no stale
TLB entries.  Suggested by art@@

ok art@@, oga@@, deraadt@@, weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.36 2010/04/01 19:48:50 kettenis Exp $	*/
d324 1
d326 2
a327 1
	tlbflush();
@


1.36
log
@Don't index cpu_info by apic id, but by device unit number instead.  Recent
Intel CPUs come up with apic id's >= 32, even on systems with less than 32
logical CPUs.

ok krw@@, marco@@; tested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.35 2009/06/03 00:49:12 art Exp $	*/
d325 2
@


1.35
log
@Just like on amd64. Instead of keeping a bitmap of which cpus a pmap
is active on, save a curpmap pointer in cpu_info. This lets us simplify
a few things and do lazy context switching from a user process to a
kernel thread. There's a new IPI introduced for forcing a cr3 reload
when we're tearing down a dead pmap.

kettenis@@ ok (after I polished a few minor things)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.34 2009/01/20 20:21:03 mlarkin Exp $	*/
a146 7
	int cpunum = lapic_cpu_number();

	if (cpunum != 0) {
		cpu_info[0] = NULL;
		cpu_info[cpunum] = &cpu_info_primary;
	}

d177 1
a177 1
	int cpunum = caa->cpu_number;
d191 1
a191 1
		if (cpunum != lapic_cpu_number()) {
d194 1
a194 1
			    self->dv_xname, lapic_cpu_number(), cpunum);
d203 1
a203 1
	ci->ci_cpuid = ci->ci_apicid;
@


1.34
log
@
Install ACPI S3 resume trampoline code in a lowmem page. First part
of ACPI S3 suspend/resume support. This is for i386.

Help/comments from art, toby, marco, jordan, kurt
ok marco@@, kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.33 2008/10/19 20:48:10 brad Exp $	*/
d247 1
d560 2
@


1.33
log
@Shuffle MULTIPROCESSOR ifdef's around to allow code that deals with
the CPU roles to compile on !MULTIPROCESSOR kernels and make the
top part of cpu_attach() which deals with processor setup depending
on the CPU role look much closer to the equivalent code for amd64.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.32 2008/10/15 23:23:47 deraadt Exp $	*/
a466 3
	pmap_kenter_pa((vaddr_t)MP_TRAMPOLINE,	/* virtual */
	    (paddr_t)MP_TRAMPOLINE,		/* physical */
	    VM_PROT_ALL);			/* protection */
@


1.32
log
@make random(9) return per-cpu values (by saving the seed in the cpuinfo),
which are uniform for the profclock on each cpu in a SMP system (but using
a different seed for each cpu).  on all cpus, avoid seeding with a value out
of the [0, 2^31-1] range (since that is not stable)
ok kettenis drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.31 2008/10/05 16:57:36 kettenis Exp $	*/
d187 1
d189 9
a197 1
	if (caa->cpu_role != CPU_ROLE_AP) {
d203 1
a203 2

		ci = &cpu_info_primary;
a204 5

		/* special-case boot CPU */			    /* XXX */
		if (cpu_info[cpunum] == &cpu_info_primary) {	    /* XXX */
			cpu_info[cpunum] = NULL; 		    /* XXX */
		}				 		    /* XXX */
a205 5
	if (cpu_info[cpunum] != NULL)
		panic("cpu at apic id %d already attached?", cpunum);

	cpu_info[cpunum] = ci;
#endif
a249 2
/* XXXSMP: must be shared with UP */
#ifdef MULTIPROCESSOR
d283 2
d293 1
d300 1
d307 1
a307 3
#else	/* MULTIPROCESSOR */
	printf("\n");
#endif	/* !MULTIPROCESSOR */
a313 1
#ifdef MULTIPROCESSOR
d345 1
@


1.31
log
@Remove IOAPIC ID remapping code.  It should not be necessary to avoid reusing
LAPIC IDs and if there are MPBIOSes we handle them with ACPI now.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.30 2008/06/26 05:42:10 ray Exp $	*/
d358 1
@


1.30
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.29 2007/11/28 17:05:09 tedu Exp $	*/
a299 4

	/* Mark this ID as taken if it's in the I/O APIC ID area */
	if (ci->ci_apicid < IOAPIC_ID_MAX)
		ioapic_id_map &= ~(1 << ci->ci_apicid);
@


1.29
log
@quite a bit of simplification by removing cpu classes.
also assume that 386 cpus are really unknown, and promote them to 486
instead of panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.28 2007/11/27 16:22:13 martynas Exp $	*/
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.28
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.27 2007/11/16 16:16:06 deraadt Exp $	*/
a344 1
#if defined(I686_CPU)
a356 1
#endif /* I686_CPU */
@


1.27
log
@fix the bus_space #define nightmare, so that amd64 and i386 are much more
uniform. as a result shared code like acpi needs less #ifdef's
ok marco kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.26 2007/10/10 15:53:51 art Exp $	*/
d533 1
a533 1
	 * Set up seperate handler for the DDB IPI, so that it doesn't
@


1.26
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.25 2007/05/29 18:18:20 tom Exp $	*/
d140 1
a140 1
struct cpu_info *cpu_info[I386_MAXPROCS] = { &cpu_info_primary };
d367 1
a367 1
	for (i = 0; i < I386_MAXPROCS; i++) {
d387 1
a387 1
	for (i=0; i < I386_MAXPROCS; i++) {
@


1.25
log
@Remove support for 80386 processors.  Apologies if you have one of
the rare 80386-bases system with enough memory, a 387 FPU, a useable
disk subsystem, and the patience to wait for it to unpack the
distribution .tgz files.

approval from art@@ and many others (esp. nick@@); ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.24 2007/05/26 22:09:17 weingart Exp $	*/
d298 1
d467 3
@


1.24
log
@Move cpu_info/curcpu to be mapped by the %fs segment.  Extra input and
debugging by tom@@, art@@, kettenis@@, and others.  Testing by many others.

ok art@@, kettenis@@, tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.23 2007/05/08 18:51:59 deraadt Exp $	*/
a333 1
#if defined(I486_CPU) || defined(I586_CPU) || defined(I686_CPU)
d335 2
a336 1
	 * On a 486 or above, enable ring 0 write protection.
d338 2
a339 3
	if (ci->cpu_class >= CPUCLASS_486)
		lcr0(rcr0() | CR0_WP);
#endif
@


1.23
log
@cpu_init() is only used for the MP case (for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.22 2007/04/24 12:58:50 tom Exp $	*/
d154 1
a154 1
	int cpunum = cpu_number();
d196 1
a196 1
		if (cpunum != cpu_number()) {
d199 1
a199 1
			    self->dv_xname, cpu_number(), cpunum);
@


1.22
log
@Use the physical address we have stored for the page directory rather
than calculating it with vtophys().

From mickey's original PAE work of a year ago

Tested by myself and nick@@; ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.21 2007/02/20 21:15:01 tom Exp $	*/
d326 1
a359 3


#ifdef MULTIPROCESSOR
@


1.21
log
@Revert PAE pmap for now, until the strange bug is found.  This stops
the freezes many of us are seeing (especially on amd64 machines running
OpenBSD/i386).

Much testing by nick@@ (as always - thanks!), hugh@@, ian@@, kettenis@@
and Sam Smith (s (at) msmith (dot) net).

Requested by, input from, and ok deraadt@@  ok art@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.20 2006/06/10 17:50:30 gwk Exp $	*/
d251 1
a251 1
	pcb->pcb_cr3 = vtophys((vaddr_t)pcb->pcb_pmap->pm_pdir);
d413 1
a413 1
	mp_pdirpa = vtophys((vaddr_t)kpm->pm_pdir);
@


1.20
log
@ANSIfy, KNF
ok toby@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.19 2006/05/11 13:21:11 mickey Exp $	*/
d251 2
a252 1
	pcb->pcb_cr3 = pcb->pcb_pmap->pm_pdirpa;
d413 1
a413 1
	mp_pdirpa = kpm->pm_pdirpa;
@


1.19
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.18 2006/04/27 15:37:50 mickey Exp $	*/
d174 1
a174 4
cpu_match(parent, matchv, aux)
    struct device *parent;
    void *matchv;
    void *aux;
d185 1
a185 3
cpu_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d326 1
a326 2
cpu_init(ci)
	struct cpu_info *ci;
d401 1
a401 2
cpu_boot_secondary (ci)
	struct cpu_info *ci;
@


1.18
log
@implement separate PAE pmap that allows access to 64g of physmem
if supported by the cpu(s). currently not enabled by default and
not compiled into ramdisks. this grows paddr_t to 64bit but yet
leaves bus_addr_t at 32bits. measures are taken to favour dmaable
memory allocation from below 4g line such that buffer cache is
already allocated form below, pool backend allocator prefers lower
memory and then finally bounce buffers are used as last resort.
PAE is engaged only if global variable cpu_pae is manually set
to non-zero and there is physical memory present above 4g.
simplify pcibios address math to use u_long as we always will
be in the 32bit space.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.17 2006/01/12 22:39:20 weingart Exp $	*/
d117 1
a117 1
int mp_cpu_start(struct cpu_info *); 
@


1.17
log
@Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.16 2005/11/23 11:30:14 mickey Exp $	*/
d256 1
a256 2
	pcb->pcb_cr3 = vtophys((vaddr_t)pcb->pcb_pmap->pm_pdir);
	/* pcb->pcb_cr3 = pcb->pcb_pmap->pm_pdir - KERNBASE; XXX ??? */
d419 1
a419 1
	mp_pdirpa = vtophys((vaddr_t)kpm->pm_pdir);
@


1.16
log
@assume vtophys(vaddr_t) just what all the other archs expect; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.15 2005/07/18 02:43:25 fgsch Exp $	*/
d258 2
d300 1
d461 1
@


1.15
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.14 2005/05/27 10:41:11 kjell Exp $	*/
d256 1
a256 1
	pcb->pcb_cr3 = vtophys(pcb->pcb_pmap->pm_pdir);
d417 1
a417 1
	mp_pdirpa = vtophys(kpm->pm_pdir);
@


1.15.2.1
log
@MFC:
Fix by weingart@@

Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.15 2005/07/18 02:43:25 fgsch Exp $	*/
a257 2

	cpu_default_ldt(ci);	/* Use the `global' ldt until one alloc'd */
a297 1
		cpu_alloc_ldt(ci);
a457 1
	cpu_init_ldt(ci);
@


1.14
log
@Enable SSE instructions on secondary (i386) processors in
a multiprocessor boot.

This fixes the hardware AES (and likely RNG) instruction on the dual VIA,
which was failing because the SSE/SSE2 extensions are never enabled on
any processor but the boot processor.

Much assistance from niklas, and the eureka moment from theo.

"commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.13 2005/05/26 04:02:44 kjell Exp $	*/
d203 1
a203 1
			    " instead of at expected %d\n",
d306 1
a306 1
		panic("unknown processor type??\n");
@


1.13
log
@remove a self-nested #ifdef MULTIPROCESSOR

ok niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.12 2004/09/09 09:29:52 deraadt Exp $	*/
d334 1
a334 1
		(*ci->cpu_setup)(ci->ci_dev.dv_xname, 0, 0);
d347 14
@


1.12
log
@cpu_setup functions passed wrong first arg; from foleite@@yahoo.com.br
ok grange markus
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.11 2004/07/14 19:24:29 tom Exp $	*/
a296 2

#ifdef MULTIPROCESSOR
a302 3
#else
		printf("%s: not started\n", ci->ci_dev.dv_xname);
#endif
@


1.12.4.1
log
@MFC:
Fix by weingart@@

Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.12 2004/09/09 09:29:52 deraadt Exp $	*/
a257 2

	cpu_default_ldt(ci);	/* Use the `global' ldt until one alloc'd */
a299 1
		cpu_alloc_ldt(ci);
a448 1
	cpu_init_ldt(ci);
@


1.11
log
@Add missing \n to printf().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.10 2004/07/14 18:35:50 deraadt Exp $	*/
d339 1
a339 1
		(*ci->cpu_setup)(NULL, 0, 0);
@


1.10
log
@simplify printf code
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.9 2004/06/27 23:59:00 deraadt Exp $	*/
d275 1
a275 1
		printf("apid %d (boot processor)", caa->cpu_number);
@


1.9
log
@prettier print
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.8 2004/06/24 19:35:23 tholo Exp $	*/
d275 1
a275 2
		printf("apid %d (", caa->cpu_number);
		printf("boot processor");
a276 1
		printf(")\n");
@


1.8
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.7 2004/06/23 17:23:27 niklas Exp $	*/
d406 2
a407 1
	printf("%s: starting", ci->ci_dev.dv_xname);
d415 1
a415 3
		printf(", init idle stack ptr is 0x%x", pcb->pcb_esp);

	printf("\n");
d426 1
a426 1
		printf("cpu failed to become ready\n");
d460 3
a462 1
	printf("%s: CPU at apid %ld running\n", ci->ci_dev.dv_xname, ci->ci_cpuid);
@


1.7
log
@oops, keep MP stuff inside MULTIPROCESSOR
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.6 2004/06/23 17:14:31 niklas Exp $	*/
d462 1
a462 1
	microtime(&ci->ci_schedstate.spc_runtime);
@


1.6
log
@Renumber I/O APICs who clash with other APICs. Also clear the delivery
mode before setting it to fixed, since the MP BIOS may have left something
in that field. This fixed a Quad Xeon we have been loaned over the c2k4.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.5 2004/06/20 19:33:07 aaron Exp $	*/
a314 3
#else	/* MULTIPROCESSOR */
	printf("\n");
#endif	/* !MULTIPROCESSOR */
d319 1
a319 2
	
#ifdef MULTIPROCESSOR
d326 3
a328 1
#endif
@


1.5
log
@Init per-cpu spc_runtime before diving into the scheduler.  From NetBSD.
Fixes bogus process runtimes (I happened to notice it with USB kernel threads)
as shown in ps and top.  niklas@@, deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.4 2004/06/17 00:37:24 deraadt Exp $	*/
d105 1
d319 4
@


1.4
log
@pretty cpu spinup message
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.3 2004/06/16 18:23:05 grange Exp $	*/
d459 1
@


1.3
log
@Missing ifdef DDB

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.2 2004/06/13 21:49:15 niklas Exp $	*/
d458 1
a458 1
	printf("%s: CPU %ld running\n", ci->ci_dev.dv_xname, ci->ci_cpuid);
@


1.2
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d425 1
d427 1
@


1.1
log
@file cpu.c was initially added on branch SMP.
@
text
@d1 606
@


1.1.2.1
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@a0 435
/* $NetBSD: cpu.c,v 1.1.2.7 2000/06/26 02:04:05 sommerfeld Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1999 Stefan Grefen
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the NetBSD
 *      Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.  
 *
 * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "lapic.h"
#include "ioapic.h"

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <vm/vm.h>
#include <vm/vm_kern.h>
#include <vm/vm_page.h>
 
#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/cpuvar.h>
#include <machine/pmap.h>
#include <machine/vmparam.h>
#include <machine/mpbiosvar.h>
#include <machine/pcb.h>
#include <machine/specialreg.h>
#include <machine/segments.h>

#if NLAPIC > 0
#include <machine/apicvar.h>
#include <machine/i82489reg.h>
#include <machine/i82489var.h>
#endif

#if NIOAPIC > 0
#include <machine/i82093var.h>
#endif

int     cpu_match __P((struct device *, void *, void *));
void    cpu_attach __P((struct device *, struct device *, void *));

#ifdef MULTIPROCESSOR
/*
 * Array of CPU info structures.  Must be statically-allocated because
 * curproc, etc. are used early.
 */

static struct cpu_info dummy_cpu_info; /* XXX */
struct cpu_info *cpu_info[I386_MAXPROCS] = { &dummy_cpu_info };

void    	cpu_hatch __P((void *));
static void    	cpu_boot_secondary __P((struct cpu_info *ci));
static void	cpu_copy_trampoline __P((void));

/*
 * Runs once per boot once multiprocessor goo has been detected and
 * the local APIC has been mapped.
 * Called from mpbios_scan();
 */
void
cpu_init_first()
{
	int cpunum = cpu_number();

	if (cpunum != 0) {
		cpu_info[0] = NULL;
		cpu_info[cpunum] = &dummy_cpu_info;
	}

	cpu_copy_trampoline();
}
#endif
	
struct cfattach cpu_ca = {
	sizeof(struct cpu_info), cpu_match, cpu_attach
};

struct cfdriver cpu_cd = {
	NULL, "cpu", DV_DULL /* XXX DV_CPU */
};

int
cpu_match(parent, matchv, aux)
    struct device *parent;  
    void *matchv;   
    void *aux;
{
  	struct cfdata *match = (struct cfdata *)matchv;   
	struct cpu_attach_args * caa = (struct cpu_attach_args *) aux;

	if (strcmp(caa->caa_name, match->cf_driver->cd_name) == 0)
		return 1;
	return 0;
}

void 
cpu_attach(parent, self, aux)   
	struct device *parent, *self;
	void *aux;
{
	struct cpu_info *ci = (struct cpu_info *)self;  
	struct cpu_attach_args  *caa = (struct cpu_attach_args  *) aux;

#ifdef MULTIPROCESSOR
	int cpunum = caa->cpu_number;
	vaddr_t kstack;
	struct pcb *pcb;

	if (caa->cpu_role != CPU_ROLE_AP) {
		if (cpunum != cpu_number()) {
			panic("%s: running cpu is at apic %d"
			    " instead of at expected %d\n",
			    self->dv_xname, cpu_number(), cpunum);
		}
			
		/* special-case boot CPU */			    /* XXX */
		if (cpu_info[cpunum] == &dummy_cpu_info) {	    /* XXX */
			ci->ci_curproc = dummy_cpu_info.ci_curproc; /* XXX */
			cpu_info[cpunum] = NULL; 		    /* XXX */
		}				 		    /* XXX */
	}
	if (cpu_info[cpunum] != NULL)
		panic("cpu at apic id %d already attached?", cpunum);

	cpu_info[cpunum] = ci;
#endif			

	ci->ci_cpuid = caa->cpu_number;
	ci->ci_signature = caa->cpu_signature;
	ci->ci_feature_flags = caa->feature_flags;
	ci->ci_func = caa->cpu_func;

#ifdef MULTIPROCESSOR
	/*
	 * Allocate UPAGES contiguous pages for the idle PCB and stack.
	 */

	kstack = uvm_km_alloc (kernel_map, USPACE);
	if (kstack == 0) {
		if (cpunum == 0) { /* XXX */
			panic("cpu_attach: unable to allocate idle stack for"
			    " primary");
		}
		printf("%s: unable to allocate idle stack\n",
		    ci->ci_dev.dv_xname);
		return;
	}
	pcb = ci->ci_idle_pcb = (struct pcb *) kstack;
	memset(pcb, 0, USPACE);

	pcb->pcb_tss.tss_ss0 = GSEL(GDATA_SEL, SEL_KPL);
	pcb->pcb_tss.tss_esp0 = kstack + USPACE - 16 - sizeof (struct trapframe);
	pcb->pcb_tss.tss_esp = kstack + USPACE - 16 - sizeof (struct trapframe);
	pcb->pcb_pmap = pmap_kernel();
	pcb->pcb_cr3 = vtophys(pcb->pcb_pmap->pm_pdir);
	/* pcb->pcb_cr3 = pcb->pcb_pmap->pm_pdir - KERNBASE; XXX ??? */
#endif

	/* further PCB init done later. */

	printf(": ");

	switch (caa->cpu_role) {
	case CPU_ROLE_SP:
		printf("(uniprocessor)\n");
		ci->ci_flags |= CPUF_PRESENT | CPUF_SP | CPUF_PRIMARY;
		identifycpu(ci);
		cpu_init(ci);
		break;

	case CPU_ROLE_BP:
		printf("apid %d (", caa->cpu_number);
		printf("boot processor");
		ci->ci_flags |= CPUF_PRESENT | CPUF_BSP | CPUF_PRIMARY;
		printf(")\n");
		identifycpu(ci);
		cpu_init(ci);

#if NLAPIC > 0
		/*
		 * Enable local apic
		 */
		lapic_enable();
		lapic_calibrate_timer(ci);
#endif
#if NIOAPIC > 0
		ioapic_bsp_id = caa->cpu_number;
#endif
		break;
		
	case CPU_ROLE_AP:
		/*
		 * report on an AP
		 */
		printf("apid %d (", caa->cpu_number);
		ci->ci_flags |= CPUF_PRESENT | CPUF_AP;
		printf("application processor");
		printf(")\n");
		identifycpu(ci);
		break;
		
	default:
		panic("unknown processor type??\n");
	}

#ifdef MULTIPROCESSOR
	if (mp_verbose) {
		printf("%s: kstack at 0x%lx for %d bytes\n",
		    ci->ci_dev.dv_xname, kstack, USPACE);
		printf("%s: idle pcb at %p, idle sp at 0x%x\n", 
		    ci->ci_dev.dv_xname, pcb, pcb->pcb_esp);
	}
#endif
}

/*
 * Initialize the processor appropriately.
 */

void
cpu_init(ci)
	struct cpu_info *ci;
{
	/* configure the CPU if needed */
	if (ci->cpu_setup != NULL)
		(*ci->cpu_setup)(NULL, 0, 0);

#if defined(I486_CPU) || defined(I586_CPU) || defined(I686_CPU)
	/*
	 * On a 486 or above, enable ring 0 write protection.
	 */
	if (ci->cpu_class >= CPUCLASS_486)
		lcr0(rcr0() | CR0_WP);
#endif
	if (cpu_feature & CPUID_PGE)
		lcr4(rcr4() | CR4_PGE);	/* enable global TLB caching */

	ci->ci_flags |= CPUF_RUNNING;
}


#ifdef MULTIPROCESSOR

void
cpu_boot_secondary_processors()
{
	struct cpu_info *ci;
	u_long i;

	for (i=0; i < I386_MAXPROCS; i++) {
		ci = cpu_info[i];
		if (ci == NULL)
			continue;
		if (ci->ci_idle_pcb == NULL)
			continue;
		if ((ci->ci_flags & CPUF_PRESENT) == 0)
			continue;
		i386_init_pcb_tss_ldt(ci->ci_idle_pcb);
		if (ci->ci_flags & (CPUF_BSP|CPUF_SP|CPUF_PRIMARY))
			continue;
		cpu_boot_secondary(ci);
	}
}

void
cpu_boot_secondary (ci)
	struct cpu_info *ci;
{
	struct pcb *pcb;
	int i;
	struct pmap *kpm = pmap_kernel();
	extern u_int32_t mp_pdirpa;

	printf("%s: starting\n", ci->ci_dev.dv_xname);

	/* XXX move elsewhere, not per CPU. */
	mp_pdirpa = vtophys(kpm->pm_pdir); 
	
	pcb = ci->ci_idle_pcb;

	printf("%s: init idle stack ptr is 0x%x\n", ci->ci_dev.dv_xname,
	    pcb->pcb_esp);
	
	CPU_STARTUP(ci);

	/*
	 * wait for it to become ready
	 */
	for (i = 100000; (!(ci->ci_flags & CPUF_RUNNING)) && i>0;i--) {
		delay(10);
	}
	if (! (ci->ci_flags & CPUF_RUNNING)) {
		printf("cpu failed to become ready\n");
		Debugger();
	}
	
}

/*
 * The CPU ends up here when its ready to run
 * XXX should share some of this with init386 in machdep.c
 * for now it jumps into an infinite loop.
 */
void
cpu_hatch(void *v) 
{
	struct cpu_info *ci = (struct cpu_info *)v;
        struct region_descriptor region;
#if 0
	volatile int i;
#endif
	
	cpu_init_idt();

	lapic_enable();
	lapic_set_lvt();

	cpu_init(ci);

	splbio();		/* XXX prevent softints from running here.. */

	enable_intr();
	printf("%s: CPU %d reporting for duty, Sir!\n",ci->ci_dev.dv_xname, cpu_number());
	printf("%s: stack is %p\n", ci->ci_dev.dv_xname, &region);
#if 0
	printf("%s: sending IPI to cpu 0\n",ci->ci_dev.dv_xname);
	i386_send_ipi(cpu_primary, I386_IPI_GMTB);

	/* give it a chance to be handled.. */
	for (i=0; i<1000000; i++)
		;
	
	printf("%s: sending another IPI to cpu 0\n",
	    ci->ci_dev.dv_xname);
	i386_send_ipi(cpu_primary, I386_IPI_GMTB);
#endif	
	for (;;)
		;


}

static void
cpu_copy_trampoline()
{
	/*
	 * Copy boot code.
	 */
	extern u_char cpu_spinup_trampoline[];
	extern u_char cpu_spinup_trampoline_end[];
#if 0 
	pmap_kenter_pa((vaddr_t)MP_TRAMPOLINE,	/* virtual */
		       (paddr_t)MP_TRAMPOLINE,	/* physical */
		       VM_PROT_ALL);		/* protection */
	memcpy((caddr_t)MP_TRAMPOLINE, 
	    cpu_spinup_trampoline, 
	    cpu_spinup_trampoline_end-cpu_spinup_trampoline);
#endif
	pmap_enter (pmap_kernel(), (vaddr_t)MP_TRAMPOLINE,
		    (paddr_t)MP_TRAMPOLINE, VM_PROT_ALL, TRUE, VM_PROT_ALL);
	bcopy (cpu_spinup_trampoline, (caddr_t)MP_TRAMPOLINE, 
	       cpu_spinup_trampoline_end-cpu_spinup_trampoline);
}

#endif

@


1.1.2.2
log
@Add $OpenBSD$.
@
text
@a0 1
/*	$OpenBSD$	*/
@


1.1.2.3
log
@KNF, remove statics, use pmap_kenter_pa
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.2.2 2001/07/15 15:10:54 ho Exp $	*/
d59 1
a59 1
 *    from this software without specific prior written permission.
d86 1
a86 1

d121 3
a123 3
void   	cpu_hatch __P((void *));
void   	cpu_boot_secondary __P((struct cpu_info *));
void	cpu_copy_trampoline __P((void));
d143 1
a143 1

d154 2
a155 2
    struct device *parent;
    void *matchv;
d158 2
a159 2
  	struct cfdata *match = (struct cfdata *)matchv;
	struct cpu_attach_args *caa = (struct cpu_attach_args *)aux;
d162 2
a163 2
		return (1);
	return (0);
d166 2
a167 2
void
cpu_attach(parent, self, aux)
d171 2
a172 2
	struct cpu_info *ci = (struct cpu_info *)self;
	struct cpu_attach_args *caa = (struct cpu_attach_args *)aux;
d185 1
a185 1

d196 1
a196 1
#endif
d222 2
a223 4
	pcb->pcb_tss.tss_esp0 = kstack + USPACE - 16 -
	    sizeof (struct trapframe);
	pcb->pcb_tss.tss_esp = kstack + USPACE - 16 -
	    sizeof (struct trapframe);
d260 1
a260 1

d271 1
a271 1

d280 1
a280 1
		printf("%s: idle pcb at %p, idle sp at 0x%x\n",
d320 1
a320 1
	for (i = 0; i < I386_MAXPROCS; i++) {
d347 2
a348 2
	mp_pdirpa = vtophys(kpm->pm_pdir);

d353 1
a353 1

d359 1
a359 1
	for (i = 100000; (!(ci->ci_flags & CPUF_RUNNING)) && i > 0; i--) {
d362 1
a362 1
	if (!(ci->ci_flags & CPUF_RUNNING)) {
d366 1
a366 1

d375 1
a375 1
cpu_hatch(void *v)
d382 1
a382 1

d393 1
a393 2
	printf("%s: CPU %d reporting for duty, Sir!\n",ci->ci_dev.dv_xname,
	    cpu_number());
d402 1
a402 1

d406 1
a406 1
#endif
d409 2
d413 1
a413 1
void
d421 1
a421 1

d423 10
a432 4
	    (paddr_t)MP_TRAMPOLINE,		/* physical */
	    VM_PROT_ALL);			/* protection */
	bcopy(cpu_spinup_trampoline, (caddr_t)MP_TRAMPOLINE,
	    cpu_spinup_trampoline_end - cpu_spinup_trampoline);
d436 1
@


1.1.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 1
@


1.1.2.5
log
@Merge in -current
@
text
@d83 3
@


1.1.2.6
log
@Fixed IPI with boot processor, the cpu_info aray handling must be redone.
Debug IPIs going back and forth to the boot processor when a 2ary CPU starts.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.2.5 2001/11/13 21:00:51 niklas Exp $	*/
d114 2
a115 2
static struct cpu_info cpu_info_primary; /* XXX */
struct cpu_info *cpu_info[I386_MAXPROCS] = { &cpu_info_primary };
d133 1
a133 1
		cpu_info[cpunum] = &cpu_info_primary;
a181 3
		ci = &cpu_info_primary;
		bcopy(self, &ci->ci_dev, sizeof *self);

d183 2
a184 1
		if (cpu_info[cpunum] == &cpu_info_primary) {	    /* XXX */
a366 2
struct cpu_info *first_app_cpu = NULL;

d377 1
d379 1
a379 1
	int s;
d388 1
a388 1
	s = splhigh();		/* XXX prevent softints from running here.. */
d394 3
a396 6

	if (first_app_cpu == NULL)
		first_app_cpu = ci;
	printf("%s: sending IPI to CPU %d\n", ci->ci_dev.dv_xname,
	    cpu_info_primary.ci_cpuid);
	i386_send_ipi(&cpu_info_primary, I386_IPI_GMTB);
d399 1
a399 1
	for (i = 0; i < 1000000; i++)
d402 4
a405 6
	printf("%s: sending another IPI to CPU %d\n", ci->ci_dev.dv_xname,
	    cpu_info_primary.ci_cpuid);
	i386_send_ipi(&cpu_info_primary, I386_IPI_GMTB);

	splx(s);
	/* XXX Just run and collect IPIs */
@


1.1.2.7
log
@Move TSS selector from the PCB to MD part of proc and to cpu_info.
Maintain a list of CPUs and provide an iterator for it.
Ifdef out IPI debugging.  Call pmap_{de,}activate as part of context switching.
Mostly from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.2.6 2003/04/04 15:02:03 niklas Exp $	*/
a107 8
/*
 * Statically-allocated CPU info for the primary CPU (or the only
 * CPU, on uniprocessors).  The CPU info list is initialized to
 * point at it.
 */
struct cpu_info cpu_info_primary;
struct cpu_info *cpu_info_list = &cpu_info_primary;

d114 1
d216 1
a216 1
	pcb = ci->ci_idle_pcb = (struct pcb *)kstack;
a269 2
		ci->ci_next = cpu_info_list->ci_next;
		cpu_info_list->ci_next = ci;
d328 1
a335 18
cpu_init_idle_pcbs()
{
	struct cpu_info *ci;
	u_long i;

	for (i=0; i < I386_MAXPROCS; i++) {
		ci = cpu_info[i];
		if (ci == NULL)
			continue;
		if (ci->ci_idle_pcb == NULL)
			continue;
		if ((ci->ci_flags & CPUF_PRESENT) == 0)
			continue;
		i386_init_pcb_tss_ldt(ci);
	}
}

void
a380 1
#if 0
a381 1
#endif
a397 1
#if 0
a410 1
#endif
@


1.1.2.8
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.2.7 2003/04/11 16:12:56 niklas Exp $	*/
a93 1
#include <machine/gdt.h>
a115 3
void	cpu_init_tss(struct i386tss *, void *, void *);
void	cpu_set_tss_gates(struct cpu_info *);

d213 1
a213 1
	kstack = uvm_km_alloc(kernel_map, USPACE);
d272 1
a272 4
		printf("apid %d (application processor)\n", caa->cpu_number);

#ifdef MULTIPROCESSOR
		gdt_alloc_cpu(ci);
d274 2
a278 3
#else
		printf("%s: not started\n", sc->sc_dev.dv_xname);
#endif
d395 1
a395 1
int relcpus = 0;
d406 4
d413 1
a415 3
	gdt_init_cpu(ci);

	lldt(GSEL(GLDT_SEL, SEL_KPL));
d420 1
a420 1
	lapic_tpr = 0;
d422 3
a424 2
	printf("%s: CPU %ld running\n", ci->ci_dev.dv_xname, ci->ci_cpuid);
	splx(s);
d427 8
a434 1
	while(!relcpus)
d436 4
d442 4
a445 1
	printf("%s: CPU %ld released\n", ci->ci_dev.dv_xname, ci->ci_cpuid);
a463 131
#endif

#ifdef notyet
void
cpu_init_tss(struct i386tss *tss, void *stack, void *func)
{
	memset(tss, 0, sizeof *tss);
	tss->tss_esp0 = tss->tss_esp = (int)((char *)stack + USPACE - 16);
	tss->tss_ss0 = GSEL(GDATA_SEL, SEL_KPL);
	tss->__tss_cs = GSEL(GCODE_SEL, SEL_KPL);
	tss->tss_fs = GSEL(GCPU_SEL, SEL_KPL);
	tss->tss_gs = tss->__tss_es = tss->__tss_ds =
	    tss->__tss_ss = GSEL(GDATA_SEL, SEL_KPL);
	tss->tss_cr3 = pmap_kernel()->pm_pdirpa;
	tss->tss_esp = (int)((char *)stack + USPACE - 16);
	tss->tss_ldt = GSEL(GLDT_SEL, SEL_KPL);
	tss->__tss_eflags = PSL_MBO | PSL_NT;	/* XXX not needed? */
	tss->__tss_eip = (int)func;
}

/* XXX */
#define IDTVEC(name)	__CONCAT(X, name)
typedef void (vector)(void);
extern vector IDTVEC(tss_trap08);
#ifdef DDB
extern vector Xintrddbipi;
extern int ddb_vec;
#endif

void
cpu_set_tss_gates(struct cpu_info *ci)
{
	struct segment_descriptor sd;

	ci->ci_doubleflt_stack = (char *)uvm_km_alloc(kernel_map, USPACE);
	cpu_init_tss(&ci->ci_doubleflt_tss, ci->ci_doubleflt_stack,
	    IDTVEC(tss_trap08));
	setsegment(&sd, &ci->ci_doubleflt_tss, sizeof(struct i386tss) - 1,
	    SDT_SYS386TSS, SEL_KPL, 0, 0);
	ci->ci_gdt[GTRAPTSS_SEL].sd = sd;
	setgate(&idt[8], NULL, 0, SDT_SYSTASKGT, SEL_KPL,
	    GSEL(GTRAPTSS_SEL, SEL_KPL));

#if defined(DDB) && defined(MULTIPROCESSOR)
	/*
	 * Set up seperate handler for the DDB IPI, so that it doesn't
	 * stomp on a possibly corrupted stack.
	 *
	 * XXX overwriting the gate set in db_machine_init.
	 * Should rearrange the code so that it's set only once.
	 */
	ci->ci_ddbipi_stack = (char *)uvm_km_alloc(kernel_map, USPACE);
	cpu_init_tss(&ci->ci_ddbipi_tss, ci->ci_ddbipi_stack,
	    Xintrddbipi);

	setsegment(&sd, &ci->ci_ddbipi_tss, sizeof(struct i386tss) - 1,
	    SDT_SYS386TSS, SEL_KPL, 0, 0);
	ci->ci_gdt[GIPITSS_SEL].sd = sd;

	setgate(&idt[ddb_vec], NULL, 0, SDT_SYSTASKGT, SEL_KPL,
	    GSEL(GIPITSS_SEL, SEL_KPL));
#endif
}

int
mp_cpu_start(struct cpu_info *ci)
{
#if NLAPIC > 0
	int error;
#endif
	unsigned short dwordptr[2];

	/*
	 * "The BSP must initialize CMOS shutdown code to 0Ah ..."
	 */

	outb(IO_RTC, NVRAM_RESET);
	outb(IO_RTC+1, NVRAM_RESET_JUMP);

	/*
	 * "and the warm reset vector (DWORD based at 40:67) to point
	 * to the AP startup code ..."
	 */

	dwordptr[0] = 0;
	dwordptr[1] = MP_TRAMPOLINE >> 4;

	pmap_kenter_pa (0, 0, VM_PROT_READ|VM_PROT_WRITE);
	memcpy ((u_int8_t *) 0x467, dwordptr, 4);
	pmap_kremove (0, PAGE_SIZE);

#if NLAPIC > 0
	/*
	 * ... prior to executing the following sequence:"
	 */

	if (ci->ci_flags & CPUF_AP) {
		if ((error = x86_ipi_init(ci->ci_apicid)) != 0)
			return error;

		delay(10000);

		if (cpu_feature & CPUID_APIC) {

			if ((error = x86_ipi(MP_TRAMPOLINE/PAGE_SIZE,
					     ci->ci_apicid,
					     LAPIC_DLMODE_STARTUP)) != 0)
				return error;
			delay(200);

			if ((error = x86_ipi(MP_TRAMPOLINE/PAGE_SIZE,
					     ci->ci_apicid,
					     LAPIC_DLMODE_STARTUP)) != 0)
				return error;
			delay(200);
		}
	}
#endif
	return 0;
}

void
mp_cpu_start_cleanup(struct cpu_info *ci)
{
	/*
	 * Ensure the NVRAM reset byte contains something vaguely sane.
	 */

	outb(IO_RTC, NVRAM_RESET);
	outb(IO_RTC+1, NVRAM_RESET_RST);
}
@


1.1.2.9
log
@removed old debugging code
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.2.8 2003/05/15 04:08:01 niklas Exp $	*/
d403 2
d430 7
@


1.1.2.10
log
@Some merged code from NetBSD, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.2.9 2003/05/17 19:15:20 niklas Exp $	*/
a94 1
#include <machine/pio.h>
a105 4
#include <dev/ic/mc146818reg.h>
#include <i386/isa/nvram.h>
#include <dev/isa/isareg.h>

a108 5
int mp_cpu_start(struct cpu_info *); 
void mp_cpu_start_cleanup(struct cpu_info *);
struct cpu_functions mp_cpu_funcs =
    { mp_cpu_start, NULL, mp_cpu_start_cleanup };

d207 1
a207 6
	ci->ci_apicid = caa->cpu_number;
#ifdef MULTIPROCESSOR
	ci->ci_cpuid = ci->ci_apicid;
#else
	ci->ci_cpuid = 0;	/* False for APs, so what, they're not used */
#endif
a508 1
#endif
d533 3
a535 3
	pmap_kenter_pa(0, 0, VM_PROT_READ|VM_PROT_WRITE);
	memcpy((u_int8_t *)0x467, dwordptr, 4);
	pmap_kremove(0, PAGE_SIZE);
d543 2
a544 2
		if ((error = i386_ipi_init(ci->ci_apicid)) != 0)
			return (error);
d549 5
a553 3
			if ((error = i386_ipi(MP_TRAMPOLINE / PAGE_SIZE,
			    ci->ci_apicid, LAPIC_DLMODE_STARTUP)) != 0)
				return (error);
d556 4
a559 3
			if ((error = i386_ipi(MP_TRAMPOLINE / PAGE_SIZE,
			    ci->ci_apicid, LAPIC_DLMODE_STARTUP)) != 0)
				return (error);
d564 1
a564 1
	return (0);
d577 1
@


1.1.2.11
log
@Add some fields to cpu_info to manage interrupts, also a self pointer
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.2.10 2004/03/14 22:08:20 niklas Exp $	*/
a216 1
	ci->ci_self = ci;
@


1.1.2.12
log
@call cpu cleanup hook, so that reboot will work (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.2.11 2004/03/18 02:09:28 niklas Exp $	*/
a416 1
	CPU_START_CLEANUP(ci);
@


1.1.2.13
log
@All CPUs needs timers otherwise delays will break
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.2.12 2004/03/23 00:57:51 niklas Exp $	*/
a432 1
	lapic_initclocks();
@


1.1.2.14
log
@Initialize npx for 2ary cpus
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.2.13 2004/03/30 09:06:50 niklas Exp $	*/
a90 1
#include <machine/npx.h>
a435 1
	npxinit(ci);
@


1.1.2.15
log
@In !MULTIPROCESSOR replace sc->sc_dev with ci->ci_dev, like it
should be.

ok niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.2.14 2004/04/06 13:30:48 niklas Exp $	*/
d302 1
a302 1
		printf("%s: not started\n", ci->ci_dev.dv_xname);
@


1.1.2.16
log
@mp_cpu_funcs is MP only; ok grange, niklas
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.2.15 2004/06/06 18:11:04 grange Exp $	*/
a114 1
#ifdef MULTIPROCESSOR
a118 1
#endif
a530 1
#ifdef MULTIPROCESSOR
a594 1
#endif
@


1.1.2.17
log
@UP machines don't need identifycpu(), old_identifycpu() is enough.
XXX: of course both should be merged later.

ok niklas@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.2.16 2004/06/08 19:57:15 markus Exp $	*/
a260 2
/* XXXSMP: must be shared with UP */
#ifdef MULTIPROCESSOR
a310 3
#else	/* MULTIPROCESSOR */
	printf("\n");
#endif	/* !MULTIPROCESSOR */
@


1.1.2.18
log
@first cut at ncpus++ location; drahn ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.2.17 2004/06/08 21:41:37 grange Exp $	*/
a304 1
		ncpus++;
@


1.1.2.19
log
@pretty print in dmesg -- when it is easier on the eyes glaring problems
jump out; art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.2.18 2004/06/11 05:22:23 deraadt Exp $	*/
d403 1
a403 1
	printf("%s: starting", ci->ci_dev.dv_xname);
d410 2
a411 4
	if (mp_verbose)
		printf(", init idle stack ptr is 0x%x", pcb->pcb_esp);

	printf("\n");
@


1.1.2.20
log
@un__Pee
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.c,v 1.1.2.19 2004/06/13 07:31:56 deraadt Exp $	*/
d112 2
a113 2
int     cpu_match(struct device *, void *, void *);
void    cpu_attach(struct device *, struct device *, void *);
d141 3
a143 3
void   	cpu_hatch(void *);
void   	cpu_boot_secondary(struct cpu_info *);
void	cpu_copy_trampoline(void);
@


