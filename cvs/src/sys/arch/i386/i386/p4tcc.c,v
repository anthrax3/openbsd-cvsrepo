head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.14
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.12
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.8
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.4
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.18
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.14
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.12
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.10
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.8
	OPENBSD_5_0:1.17.0.6
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.4
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.14.0.12
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.8
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.6
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.19
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.18;
commitid	uzzBR7hz9ncd4O6G;

1.18
date	2014.07.08.13.06.58;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	eL0jnb8G3buKIRY6;

1.17
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.12.04.13.15;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.12.01.40.36;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.08.03.20.36.02;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.20.17.50.40;	author gwk;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.12.23.14.27;	author dim;	state Exp;
branches;
next	1.11;

1.11
date	2006.08.20.01.42.51;	author gwk;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.17.18.22.13;	author dim;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.17.17.23.39;	author dim;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.15.13.18.51;	author dim;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.13.20.47.42;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.13.00.36.39;	author gwk;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.06.17.34.37;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.27.21.46.44;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.27.21.15.45;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.14.15.09.22;	author grange;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.12.20.18.23.18;	author tedu;	state Exp;
branches;
next	;

1.2.2.1
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2004.06.05.23.09.00;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2004.06.07.20.41.10;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.19
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@/*	$OpenBSD: p4tcc.c,v 1.18 2014/07/08 13:06:58 deraadt Exp $ */
/*
 * Copyright (c) 2003 Ted Unangst
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * Restrict power consumption by using thermal control circuit.
 * This operates independently of speedstep.
 * Found on Pentium 4 and later models (feature TM).
 *
 * References:
 * Intel Developer's manual v.3 #245472-012
 *
 * On some models, the cpu can hang if it's running at a slow speed.
 * Workarounds included below.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sysctl.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/specialreg.h>

static struct {
	u_short level;
	u_short reg;
} tcc[] = {
	{ 88, 0 },
	{ 75, 7 },
	{ 63, 6 },
	{ 50, 5 },
	{ 38, 4 },
	{ 25, 3 },
	{ 13, 2 },
	{ 0, 1 }
};

#define TCC_LEVELS sizeof(tcc) / sizeof(tcc[0])

extern int setperf_prio;
int p4tcc_level;

int p4tcc_cpuspeed(int *);

void
p4tcc_init(int family, int step)
{
	if (setperf_prio > 1)
		return;

	switch (family) {
	case 0xf:	/* Pentium 4 */
		switch (step) {
		case 0x22:	/* errata O50 P44 and Z21 */
		case 0x24:
		case 0x25:
		case 0x27:
		case 0x29:
			/* hang with 12.5 */
			tcc[TCC_LEVELS - 1].reg = 2;
			break;
		case 0x07:	/* errata N44 and P18 */
		case 0x0a:
		case 0x12:
		case 0x13:
			/* hang at 12.5 and 25 */
			tcc[TCC_LEVELS - 1].reg = 3;
			tcc[TCC_LEVELS - 2].reg = 3;
			break;
		}
		break;
	}

	p4tcc_level = tcc[0].level;
	cpu_setperf = p4tcc_setperf;
	cpu_cpuspeed = p4tcc_cpuspeed;
	setperf_prio = 1;
}

int
p4tcc_cpuspeed(int *speed)
{
	*speed = cpuspeed * (p4tcc_level + 12) / 100;

	return 0;
}

void
p4tcc_setperf(int level)
{
	int i;
	uint64_t msreg, vet;

	for (i = 0; i < TCC_LEVELS; i++) {
		if (level >= tcc[i].level)
			break;
	}
	if (i == TCC_LEVELS)
		i = TCC_LEVELS - 1;

	msreg = rdmsr(MSR_THERM_CONTROL);
	msreg &= ~0x1e; /* bit 0 reserved */
	if (tcc[i].reg != 0) /* enable it */
		msreg |= tcc[i].reg << 1 | 1 << 4;
	wrmsr(MSR_THERM_CONTROL, msreg);
	vet = rdmsr(MSR_THERM_CONTROL);

	if ((vet & 0x1e) != (msreg & 0x1e))
		printf("p4_tcc: cpu did not honor request\n");
	else
		p4tcc_level = tcc[i].level;
}
@


1.18
log
@A few missing sys/systm.h includes.  Soon the universes dragged in via
uvm_extern.h, uvm_param.h, and sysctl.h will no longer gaurantee that
_KERNEL code gets it.
@
text
@d1 1
a1 1
/*	$OpenBSD: p4tcc.c,v 1.17 2010/04/20 22:05:41 tedu Exp $ */
a40 1
#include <sys/proc.h>
@


1.17
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: p4tcc.c,v 1.16 2009/11/12 04:13:15 deraadt Exp $ */
d40 1
@


1.16
log
@oops my slow editor conspired against me
@
text
@d1 1
a1 1
/*	$OpenBSD: p4tcc.c,v 1.15 2009/11/12 01:40:36 deraadt Exp $ */
d40 1
@


1.15
log
@if the table got messed up, early loop termination is not gauranteed, and
subsequent code will be out of bounds; unlikely situation.  found by parfait
ok weingart
@
text
@d1 1
a1 1
>/*	$OpenBSD: p4tcc.c,v 1.14 2007/08/03 20:36:02 deraadt Exp $ */
@


1.14
log
@when not dealing with floats, always multiply before dividing; from Przemyslaw Nowaczyk
@
text
@d1 1
a1 1
/*	$OpenBSD: p4tcc.c,v 1.13 2006/12/20 17:50:40 gwk Exp $ */
d120 2
@


1.13
log
@"#ifdef is a tool of the weak!"
Rename pentium_mhz to cpuspeed which is consistant with amd64 making
shared ACPI code less nasty.
ok marco, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: p4tcc.c,v 1.12 2006/12/12 23:14:27 dim Exp $ */
d105 1
a105 1
	*speed = cpuspeed / 100 * (p4tcc_level + 12);
@


1.12
log
@Complete gwk's previous patch to stop setperf methods from returning
errors to userland: make all cpu_setperf functions return void.

Tested by many, ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: p4tcc.c,v 1.11 2006/08/20 01:42:51 gwk Exp $ */
d105 1
a105 1
	*speed = pentium_mhz / 100 * (p4tcc_level + 12);
@


1.11
log
@When using p4tcc supply a cpu_cpuspeed function to provide an estimated
hw.cpuspeed. If cpu_cpuspeed is not null in identifycpu() don't overwrite
what it points to with pentium_cpuspeed.
lots of thanks to todd@@ for testing, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: p4tcc.c,v 1.10 2006/06/17 18:22:13 dim Exp $ */
d110 1
a110 1
int
a131 2

	return (0);
@


1.10
log
@Don't return low level errors to userspace in p4tcc_setperf().

requested by deraadt@@, ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: p4tcc.c,v 1.9 2006/06/17 17:23:39 dim Exp $ */
d63 3
d96 1
d98 1
d103 8
d130 2
@


1.9
log
@In p4tcc, only check cpu stepping for the Pentium 4 family.  Also kill
some trailing whitespace.

ok gklok@@
@
text
@d1 1
a1 1
/*	$OpenBSD: p4tcc.c,v 1.8 2006/06/15 13:18:51 dim Exp $ */
d115 1
a115 1
	if ((vet & 0x1e) != (msreg & 0x1e)) {
d117 1
a117 2
		return (EIO);
	}
@


1.8
log
@Add proper masking of reserved bits, when we test if the thermal
control MSR was written successfully.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: p4tcc.c,v 1.7 2006/06/13 20:47:42 miod Exp $ */
d65 1
a65 1
p4tcc_init(int model, int step)
d70 20
a89 18
	switch (step) {
	case 0x22:	/* errata O50 P44 and Z21 */
	case 0x24:
	case 0x25:
	case 0x27:
	case 0x29:
		/* hang with 12.5 */
		tcc[TCC_LEVELS - 1].reg = 2;
		break;
	case 0x07:	/* errata N44 and P18 */
	case 0x0a:
	case 0x12:
	case 0x13:
		/* hang at 12.5 and 25 */
		tcc[TCC_LEVELS - 1].reg = 3;
		tcc[TCC_LEVELS - 2].reg = 3;
		break;
	default:
@


1.7
log
@Do not compare apple with oranges when checking if the thermal control
register write was successful.
@
text
@d1 1
a1 1
/*	$OpenBSD: p4tcc.c,v 1.6 2006/06/13 00:36:39 gwk Exp $ */
d113 1
a113 1
	if (vet != msreg) {
@


1.6
log
@When adjusting the performance of the processor using p4tcc, the CPUs
frequency remains unaltered. Remove the unecessary call to update_cpuspeed(),
and add check the sucess of the operation, returing EIO in the event of
failure.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: p4tcc.c,v 1.5 2004/06/06 17:34:37 grange Exp $ */
a111 1
	vet &= ~0x1e;
@


1.5
log
@Don't touch any hardware registers while fetching hw.cpuspeed and
just return current pentium_mhz value. Update this value in
all hw.setperf hoos either via its own private methods or using
global update_cpuspeed hook, if registered.
Also implement update_cpuspeed hook for Pentium 3.

Tested by millert@@, Gabriel Kihlman <gk@@stacken.kth.se> and me on
various i386 machines.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: p4tcc.c,v 1.4 2004/02/27 21:46:44 grange Exp $ */
d99 1
a99 1
	uint64_t msreg;
d111 2
d114 4
a117 3
	if (update_cpuspeed != NULL)
		update_cpuspeed();

@


1.4
log
@Move setperf_prio to the machdep code, requested by deraadt@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: p4tcc.c,v 1.3 2004/02/27 21:15:45 grange Exp $ */
a94 10
#if 0
/* possible? not sure */
int
p4tcc_cpuspeed(int *)
{

	return EINVAL;
}
#endif

d111 3
@


1.3
log
@Introduce simple priorities mechanism so that concurrent
hw.setperf handlers don't override each other.
Problem reported and tested by danh@@.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: p4tcc.c,v 1.2 2004/02/14 15:09:22 grange Exp $ */
d61 2
@


1.2
log
@Simplify hw.{cpuspeed,setperf} api moving all the sysctl stuff
from the underlying callbacks.

Testing hppa mickey@@, ppc drahn@@
Ok markus@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: p4tcc.c,v 1.1 2003/12/20 18:23:18 tedu Exp $ */
d65 2
d90 1
a90 1

@


1.2.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: p4tcc.c,v 1.2 2004/02/14 15:09:22 grange Exp $ */
a61 3
extern int (*cpu_cpuspeed)(void *, size_t *, void *, size_t);
extern int (*cpu_setperf)(void *, size_t *, void *, size_t);

d94 1
a94 1
p4tcc_cpuspeed(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
d102 1
a102 1
p4tcc_setperf(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
d104 1
a104 1
	int i, error;
a105 11
	static uint level = 100;
	uint olevel;

	olevel = level;
	if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &level)))
		return (error);
	if (level == olevel)
		return (0);

	if (level > 100)
		level = 100;
@


1.2.2.2
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d62 2
a63 1
extern int setperf_prio;
a67 2
	if (setperf_prio > 1)
		return;
d91 1
a91 1
	setperf_prio = 1;
d97 1
a97 1
p4tcc_cpuspeed(int *)
d105 1
a105 1
p4tcc_setperf(int level)
d107 1
a107 1
	int i;
d109 11
@


1.2.2.3
log
@sync to head
@
text
@d95 10
a120 3

	if (update_cpuspeed != NULL)
		update_cpuspeed();
@


1.1
log
@add pentium 4 thermal control circuit (tcc) driver.  can use this to
limit power consumption with the hw.setperf sysctl.
tested by beck and grange
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a61 3
extern int (*cpu_cpuspeed)(void *, size_t *, void *, size_t);
extern int (*cpu_setperf)(void *, size_t *, void *, size_t);

d94 1
a94 1
p4tcc_cpuspeed(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
d102 1
a102 1
p4tcc_setperf(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
d104 1
a104 1
	int i, error;
a105 11
	static uint level = 100;
	uint olevel;

	olevel = level;
	if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &level)))
		return (error);
	if (level == olevel)
		return (0);

	if (level > 100)
		level = 100;
@

