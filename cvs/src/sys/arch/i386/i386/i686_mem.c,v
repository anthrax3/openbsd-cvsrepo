head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.4
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.6
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.4
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.6
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.4
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.8
	OPENBSD_5_0:1.13.0.6
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.10.0.10
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.6
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.3.0.12
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.10
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.3;
locks; strict;
comment	@ * @;


1.18
date	2016.04.26.15.27.32;	author mlarkin;	state Exp;
branches;
next	1.17;
commitid	F6kozG3kiHukwD4S;

1.17
date	2014.12.09.06.58.28;	author doug;	state Exp;
branches;
next	1.16;
commitid	yWAxzpQP2PPpYlfT;

1.16
date	2014.07.13.12.11.01;	author jasper;	state Exp;
branches;
next	1.15;
commitid	XHZxhpAa5R1Ymp1z;

1.15
date	2013.08.24.04.26.16;	author mlarkin;	state Exp;
branches;
next	1.14;

1.14
date	2012.08.01.15.44.14;	author mikeb;	state Exp;
branches;
next	1.13;

1.13
date	2010.03.23.19.31.18;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2010.02.23.21.54.53;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.29.17.11.30;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.07.15.00.19;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.27.04.08.57;	author gwk;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.11.13.21.11;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.04.04.29.03;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.14.21.01.01;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.11.24.01.43.32;	author deraadt;	state Exp;
branches
	1.3.2.1
	1.3.12.1;
next	1.2;

1.2
date	99.11.23.22.42.13;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.11.20.11.11.28;	author matthieu;	state Exp;
branches;
next	;

1.3.2.1
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2003.05.13.19.42.07;	author ho;	state Exp;
branches;
next	;

1.3.12.1
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	1.3.12.2;

1.3.12.2
date	2002.10.29.00.28.03;	author art;	state Exp;
branches;
next	1.3.12.3;

1.3.12.3
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.18
log
@
Convert some magic numbers into #defines - this is needed for some MTRR
decoding code I'm working on for vmm(4) debugging. No functional change.
@
text
@/* $OpenBSD: i686_mem.c,v 1.17 2014/12/09 06:58:28 doug Exp $ */
/*
 * Copyright (c) 1999 Michael Smith <msmith@@freebsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/i386/i386/i686_mem.c,v 1.8 1999/10/12 22:53:05 green Exp $
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/memrange.h>

#include <machine/cpufunc.h>
#include <machine/intr.h>
#include <machine/specialreg.h>

/*
 * This code implements a set of MSRs known as MTRR which define caching
 * modes/behavior for various memory ranges.
 */

char *mem_owner_bios = "BIOS";

#define MR_FIXMTRR	(1<<0)

#define mrwithin(mr, a) \
    (((a) >= (mr)->mr_base) && ((a) < ((mr)->mr_base + (mr)->mr_len)))
#define mroverlap(mra, mrb) \
    (mrwithin(mra, mrb->mr_base) || mrwithin(mrb, mra->mr_base))

#define mrvalid(base, len) 						\
    ((!(base & ((1 << 12) - 1))) && 	/* base is multiple of 4k */	\
     ((len) >= (1 << 12)) && 		/* length is >= 4k */		\
     powerof2((len)) && 		/* ... and power of two */	\
     !((base) & ((len) - 1)))		/* range is not discontiuous */

#define mrcopyflags(curr, new) (((curr) & ~MDF_ATTRMASK) | \
	((new) & MDF_ATTRMASK))

#define FIXTOP	((MTRR_N64K * 0x10000) + (MTRR_N16K * 0x4000) + \
	(MTRR_N4K * 0x1000))

void	mrinit(struct mem_range_softc *sc);
int	mrset(struct mem_range_softc *sc,
	    struct mem_range_desc *mrd, int *arg);
void	mrinit_cpu(struct mem_range_softc *sc);
void	mrreload_cpu(struct mem_range_softc *sc);

struct mem_range_ops mrops = {
	mrinit,
	mrset,
	mrinit_cpu,
	mrreload_cpu
};

u_int64_t	mtrrcap, mtrrdef;
u_int64_t	mtrrmask = 0x0000000ffffff000ULL;

struct mem_range_desc	*mem_range_match(struct mem_range_softc *sc,
			     struct mem_range_desc *mrd);
void			 mrfetch(struct mem_range_softc *sc);
int			 mtrrtype(u_int64_t flags);
int			 mrt2mtrr(u_int64_t flags);
int			 mtrr2mrt(int val);
int			 mtrrconflict(u_int64_t flag1, u_int64_t flag2);
void			 mrstore(struct mem_range_softc *sc);
void			 mrstoreone(struct mem_range_softc *sc);
struct mem_range_desc	*mtrrfixsearch(struct mem_range_softc *sc,
			     u_int64_t addr);
int			 mrsetlow(struct mem_range_softc *sc,
			     struct mem_range_desc *mrd, int *arg);
int			 mrsetvariable(struct mem_range_softc *sc,
			     struct mem_range_desc *mrd, int *arg);

/* MTRR type to memory range type conversion */
int mtrrtomrt[] = {
	MDF_UNCACHEABLE,
	MDF_WRITECOMBINE,
	MDF_UNKNOWN,
	MDF_UNKNOWN,
	MDF_WRITETHROUGH,
	MDF_WRITEPROTECT,
	MDF_WRITEBACK
};

int
mtrr2mrt(int val)
{
	if (val < 0 || val >= nitems(mtrrtomrt))
		return MDF_UNKNOWN;
	return mtrrtomrt[val];
}

/*
 * MTRR conflicts. Writeback and uncachable may overlap.
 */
int
mtrrconflict(u_int64_t flag1, u_int64_t flag2)
{
	flag1 &= MDF_ATTRMASK;
	flag2 &= MDF_ATTRMASK;
	if (flag1 == flag2 ||
	    (flag1 == MDF_WRITEBACK && flag2 == MDF_UNCACHEABLE) ||
	    (flag2 == MDF_WRITEBACK && flag1 == MDF_UNCACHEABLE))
		return 0;
	return 1;
}

/*
 * Look for an exactly-matching range.
 */
struct mem_range_desc *
mem_range_match(struct mem_range_softc *sc, struct mem_range_desc *mrd)
{
	struct mem_range_desc	*cand;
	int			 i;
	
	for (i = 0, cand = sc->mr_desc; i < sc->mr_ndesc; i++, cand++)
		if ((cand->mr_base == mrd->mr_base) &&
		    (cand->mr_len == mrd->mr_len))
			return(cand);
	return(NULL);
}

/*
 * Fetch the current mtrr settings from the current CPU (assumed to all
 * be in sync in the SMP case).  Note that if we are here, we assume
 * that MTRRs are enabled, and we may or may not have fixed MTRRs.
 */
void
mrfetch(struct mem_range_softc *sc)
{
	struct mem_range_desc	*mrd;
	u_int64_t		 msrv;
	int			 i, j, msr, mrt;

	mrd = sc->mr_desc;

	/* We should never be fetching MTRRs from an AP */
	KASSERT(CPU_IS_PRIMARY(curcpu()));
	
	/* Get fixed-range MTRRs, if the CPU supports them */
	if (sc->mr_cap & MR_FIXMTRR) {
		msr = MSR_MTRRfix64K_00000;
		for (i = 0; i < (MTRR_N64K / 8); i++, msr++) {
			msrv = rdmsr(msr);
			for (j = 0; j < 8; j++, mrd++) {
				mrt = mtrr2mrt(msrv & 0xff);
				if (mrt == MDF_UNKNOWN)
					mrt = MDF_UNCACHEABLE;
				mrd->mr_flags = (mrd->mr_flags & ~MDF_ATTRMASK) |
					mrt | MDF_ACTIVE;
				if (mrd->mr_owner[0] == 0)
					strlcpy(mrd->mr_owner, mem_owner_bios,
					    sizeof(mrd->mr_owner));
				msrv = msrv >> 8;
			}
		}

		msr = MSR_MTRRfix16K_80000;
		for (i = 0; i < (MTRR_N16K / 8); i++, msr++) {
			msrv = rdmsr(msr);
			for (j = 0; j < 8; j++, mrd++) {
				mrt = mtrr2mrt(msrv & 0xff);
				if (mrt == MDF_UNKNOWN)
					mrt = MDF_UNCACHEABLE;
				mrd->mr_flags = (mrd->mr_flags & ~MDF_ATTRMASK) |
					mrt | MDF_ACTIVE;
				if (mrd->mr_owner[0] == 0)
					strlcpy(mrd->mr_owner, mem_owner_bios,
					    sizeof(mrd->mr_owner));
				msrv = msrv >> 8;
			}
		}

		msr = MSR_MTRRfix4K_C0000;
		for (i = 0; i < (MTRR_N4K / 8); i++, msr++) {
			msrv = rdmsr(msr);
			for (j = 0; j < 8; j++, mrd++) {
				mrt = mtrr2mrt(msrv & 0xff);
				if (mrt == MDF_UNKNOWN)
					mrt = MDF_UNCACHEABLE;
				mrd->mr_flags = (mrd->mr_flags & ~MDF_ATTRMASK) |
					mrt | MDF_ACTIVE;
				if (mrd->mr_owner[0] == 0)
					strlcpy(mrd->mr_owner, mem_owner_bios,
					    sizeof(mrd->mr_owner));
				msrv = msrv >> 8;
			}
		}
	}

	/* Get remainder which must be variable MTRRs */
	msr = MSR_MTRRvarBase;
	for (; (mrd - sc->mr_desc) < sc->mr_ndesc; msr += 2, mrd++) {
		msrv = rdmsr(msr);
		mrt = mtrr2mrt(msrv & 0xff);
		if (mrt == MDF_UNKNOWN)
			mrt = MDF_UNCACHEABLE;
		mrd->mr_flags = (mrd->mr_flags & ~MDF_ATTRMASK) | mrt;
		mrd->mr_base = msrv & mtrrmask;
		msrv = rdmsr(msr + 1);
		mrd->mr_flags = (msrv & 0x800) ?
			(mrd->mr_flags | MDF_ACTIVE) :
			(mrd->mr_flags & ~MDF_ACTIVE);
		/* Compute the range from the mask. Ick. */
		mrd->mr_len = (~(msrv & mtrrmask) & mtrrmask) + 0x1000;
		if (!mrvalid(mrd->mr_base, mrd->mr_len))
			mrd->mr_flags |= MDF_BOGUS;
		/* If unclaimed and active, must be the BIOS */
		if ((mrd->mr_flags & MDF_ACTIVE) && (mrd->mr_owner[0] == 0))
			strlcpy(mrd->mr_owner, mem_owner_bios,
			    sizeof(mrd->mr_owner));
	}
}

/*
 * Return the MTRR memory type matching a region's flags
 */
int
mtrrtype(u_int64_t flags)
{
	int i;
	
	flags &= MDF_ATTRMASK;
	
	for (i = 0; i < nitems(mtrrtomrt); i++) {
		if (mtrrtomrt[i] == MDF_UNKNOWN)
			continue;
		if (flags == mtrrtomrt[i])
			return(i);
	}
	return MDF_UNCACHEABLE;
}

int
mrt2mtrr(u_int64_t flags)
{
	int val;

	val = mtrrtype(flags);

	return val & 0xff;
}

/*
 * Update running CPU(s) MTRRs to match the ranges in the descriptor
 * list.
 *
 * XXX Must be called with interrupts enabled.
 */
void
mrstore(struct mem_range_softc *sc)
{
	disable_intr();				/* disable interrupts */
#ifdef MULTIPROCESSOR
	i386_broadcast_ipi(I386_IPI_MTRR);
#endif
	mrstoreone(sc);
	enable_intr();
}

/*
 * Update the current CPU's MTRRs with those represented in the
 * descriptor list.  Note that we do this wholesale rather than
 * just stuffing one entry; this is simpler (but slower, of course).
 */
void
mrstoreone(struct mem_range_softc *sc)
{
	struct mem_range_desc	*mrd;
	u_int64_t		 msrv;
	int			 i, j, msr;
	u_int			 cr4save;
	
	mrd = sc->mr_desc;
	
	cr4save = rcr4();	/* save cr4 */
	if (cr4save & CR4_PGE)
		lcr4(cr4save & ~CR4_PGE);

	/* Flush caches, then disable caches, then disable MTRRs */
	wbinvd();
	lcr0((rcr0() & ~CR0_NW) | CR0_CD);
	wrmsr(MSR_MTRRdefType, rdmsr(MSR_MTRRdefType) & ~MTRRdefType_ENABLE);
	
	/* Set fixed-range MTRRs */
	if (sc->mr_cap & MR_FIXMTRR) {
		msr = MSR_MTRRfix64K_00000;
		for (i = 0; i < (MTRR_N64K / 8); i++, msr++) {
			msrv = 0;
			for (j = 7; j >= 0; j--) {
				msrv = msrv << 8;
				msrv |= mrt2mtrr((mrd + j)->mr_flags);
			}
			wrmsr(msr, msrv);
			mrd += 8;
		}

		msr = MSR_MTRRfix16K_80000;
		for (i = 0, msrv = 0; i < (MTRR_N16K / 8); i++, msr++) {
			for (j = 7; j >= 0; j--) {
				msrv = msrv << 8;
				msrv |= mrt2mtrr((mrd + j)->mr_flags);
			}
			wrmsr(msr, msrv);
			mrd += 8;
		}

		msr = MSR_MTRRfix4K_C0000;
		for (i = 0, msrv = 0; i < (MTRR_N4K / 8); i++, msr++) {
			for (j = 7; j >= 0; j--) {
				msrv = msrv << 8;
				msrv |= mrt2mtrr((mrd + j)->mr_flags);
			}
			wrmsr(msr, msrv);
			mrd += 8;
		}
	}
	
	/* Set remainder which must be variable MTRRs */
	msr = MSR_MTRRvarBase;
	for (; (mrd - sc->mr_desc) < sc->mr_ndesc; msr += 2, mrd++) {
		if (mrd->mr_flags & MDF_ACTIVE) {
			msrv = mrd->mr_base & mtrrmask;
			msrv |= mrt2mtrr(mrd->mr_flags);
		} else
			msrv = 0;

		wrmsr(msr, msrv);	
		
		/* mask/active register */
		if (mrd->mr_flags & MDF_ACTIVE) {
			msrv = 0x800 | (~(mrd->mr_len - 1) & mtrrmask);
		} else
			msrv = 0;

		wrmsr(msr + 1, msrv);
	}

	/* Re-enable caches and MTRRs */
	wrmsr(MSR_MTRRdefType, mtrrdef | MTRRdefType_ENABLE);
	lcr0(rcr0() & ~(CR0_CD | CR0_NW));
	lcr4(cr4save);
}

/*
 * Hunt for the fixed MTRR referencing (addr)
 */
struct mem_range_desc *
mtrrfixsearch(struct mem_range_softc *sc, u_int64_t addr)
{
	struct mem_range_desc *mrd;
	int			i;
	
	for (i = 0, mrd = sc->mr_desc; i < (MTRR_N64K + MTRR_N16K + MTRR_N4K); i++, mrd++)
		if ((addr >= mrd->mr_base) && (addr < (mrd->mr_base + mrd->mr_len)))
			return(mrd);
	return(NULL);
}

/*
 * Try to satisfy the given range request by manipulating the fixed MTRRs that
 * cover low memory.
 *
 * Note that we try to be generous here; we'll bloat the range out to the
 * next higher/lower boundary to avoid the consumer having to know too much
 * about the mechanisms here.
 */
int
mrsetlow(struct mem_range_softc *sc, struct mem_range_desc *mrd, int *arg)
{
	struct mem_range_desc	*first_md, *last_md, *curr_md;

	/* range check */
	if (((first_md = mtrrfixsearch(sc, mrd->mr_base)) == NULL) ||
	    ((last_md = mtrrfixsearch(sc, mrd->mr_base + mrd->mr_len - 1)) == NULL))
		return(EINVAL);
	
	/* check we aren't doing something risky */
	if (!(mrd->mr_flags & MDF_FORCE))
		for (curr_md = first_md; curr_md <= last_md; curr_md++) {
			if ((curr_md->mr_flags & MDF_ATTRMASK) == MDF_UNKNOWN)
				return (EACCES);
		}

	/* set flags, clear set-by-firmware flag */
	for (curr_md = first_md; curr_md <= last_md; curr_md++) {
		curr_md->mr_flags = mrcopyflags(curr_md->mr_flags & ~MDF_FIRMWARE, mrd->mr_flags);
		bcopy(mrd->mr_owner, curr_md->mr_owner, sizeof(mrd->mr_owner));
	}
	
	return(0);
}


/*
 * Modify/add a variable MTRR to satisfy the request.
 */
int
mrsetvariable(struct mem_range_softc *sc, struct mem_range_desc *mrd, int *arg)
{
	struct mem_range_desc	*curr_md, *free_md;
	int			 i;

	/*
	 * Scan the currently active variable descriptors, look for
	 * one we exactly match (straight takeover) and for possible
	 * accidental overlaps.
	 * Keep track of the first empty variable descriptor in case we
	 * can't perform a takeover.
	 */
	i = (sc->mr_cap & MR_FIXMTRR) ? MTRR_N64K + MTRR_N16K + MTRR_N4K : 0;
	curr_md = sc->mr_desc + i;
	free_md = NULL;
	for (; i < sc->mr_ndesc; i++, curr_md++) {
		if (curr_md->mr_flags & MDF_ACTIVE) {
			/* exact match? */
			if ((curr_md->mr_base == mrd->mr_base) &&
			    (curr_md->mr_len == mrd->mr_len)) {
				/* check we aren't doing something risky */
				if (!(mrd->mr_flags & MDF_FORCE) &&
				    ((curr_md->mr_flags & MDF_ATTRMASK)
				    == MDF_UNKNOWN))
					return (EACCES);
				/* Ok, just hijack this entry */
				free_md = curr_md;
				break;
			}
			/* non-exact overlap ? */
			if (mroverlap(curr_md, mrd)) {
				/* between conflicting region types? */
				if (mtrrconflict(curr_md->mr_flags,
						      mrd->mr_flags))
					return(EINVAL);
			}
		} else if (free_md == NULL) {
			free_md = curr_md;
		}
	}
	/* got somewhere to put it? */
	if (free_md == NULL)
		return(ENOSPC);
	
	/* Set up new descriptor */
	free_md->mr_base = mrd->mr_base;
	free_md->mr_len = mrd->mr_len;
	free_md->mr_flags = mrcopyflags(MDF_ACTIVE, mrd->mr_flags);
	bcopy(mrd->mr_owner, free_md->mr_owner, sizeof(mrd->mr_owner));
	return(0);
}

/*
 * Handle requests to set memory range attributes by manipulating MTRRs.
 */
int
mrset(struct mem_range_softc *sc, struct mem_range_desc *mrd, int *arg)
{
	struct mem_range_desc	*targ;
	int			 error = 0;

	switch(*arg) {
	case MEMRANGE_SET_UPDATE:
		/* make sure that what's being asked for is possible */
		if (!mrvalid(mrd->mr_base, mrd->mr_len) ||
		    mtrrtype(mrd->mr_flags) == -1)
			return(EINVAL);
		
		/* are the "low memory" conditions applicable? */
		if ((sc->mr_cap & MR_FIXMTRR) &&
		    ((mrd->mr_base + mrd->mr_len) <= FIXTOP)) {
			if ((error = mrsetlow(sc, mrd, arg)) != 0)
				return(error);
		} else {
			/* it's time to play with variable MTRRs */
			if ((error = mrsetvariable(sc, mrd, arg)) != 0)
				return(error);
		}
		break;
		
	case MEMRANGE_SET_REMOVE:
		if ((targ = mem_range_match(sc, mrd)) == NULL)
			return(ENOENT);
		if (targ->mr_flags & MDF_FIXACTIVE)
			return(EPERM);
		targ->mr_flags &= ~MDF_ACTIVE;
		targ->mr_owner[0] = 0;
		break;
		
	default:
		return(EOPNOTSUPP);
	}
	
	/* update the hardware */
	mrstore(sc);
	return(0);
}

/*
 * Work out how many ranges we support, initialise storage for them,
 * fetch the initial settings.
 */
void
mrinit(struct mem_range_softc *sc)
{
	struct mem_range_desc	*mrd;
	uint32_t		 regs[4];
	int			 nmdesc = 0;
	int			 i;

	mtrrcap = rdmsr(MSR_MTRRcap);
	mtrrdef = rdmsr(MSR_MTRRdefType);
	
	/* For now, bail out if MTRRs are not enabled */
	if (!(mtrrdef & MTRRdefType_ENABLE)) {
		printf("mtrr: CPU supports MTRRs but not enabled by BIOS\n");
		return;
	}
	nmdesc = mtrrcap & 0xff;
	printf("mtrr: Pentium Pro MTRR support, %d var ranges", nmdesc);
	
	/* If fixed MTRRs supported and enabled */
	if ((mtrrcap & MTRRcap_FIXED) && 
	    (mtrrdef & MTRRdefType_FIXED_ENABLE)) {
		sc->mr_cap = MR_FIXMTRR;
		nmdesc += MTRR_N64K + MTRR_N16K + MTRR_N4K;
		printf(", %d fixed ranges", MTRR_N64K + MTRR_N16K + MTRR_N4K);
	}

	printf("\n");
	
	sc->mr_desc = mallocarray(nmdesc, sizeof(struct mem_range_desc),
	     M_MEMDESC, M_WAITOK|M_ZERO);
	sc->mr_ndesc = nmdesc;
	
	mrd = sc->mr_desc;
	
	/* Populate the fixed MTRR entries' base/length */
	if (sc->mr_cap & MR_FIXMTRR) {
		for (i = 0; i < MTRR_N64K; i++, mrd++) {
			mrd->mr_base = i * 0x10000;
			mrd->mr_len = 0x10000;
			mrd->mr_flags = MDF_FIXBASE | MDF_FIXLEN | MDF_FIXACTIVE;
		}

		for (i = 0; i < MTRR_N16K; i++, mrd++) {
			mrd->mr_base = i * 0x4000 + 0x80000;
			mrd->mr_len = 0x4000;
			mrd->mr_flags = MDF_FIXBASE | MDF_FIXLEN | MDF_FIXACTIVE;
		}

		for (i = 0; i < MTRR_N4K; i++, mrd++) {
			mrd->mr_base = i * 0x1000 + 0xc0000;
			mrd->mr_len = 0x1000;
			mrd->mr_flags = MDF_FIXBASE | MDF_FIXLEN | MDF_FIXACTIVE;
		}
	}
	
	/*
	 * Fetch maximum physical address size supported by the
	 * processor as supported by CPUID leaf function 0x80000008.
	 * If CPUID does not support leaf function 0x80000008, use the
	 * default 36-bit address size.
	 */
	CPUID(0x80000000, regs[0], regs[1], regs[2], regs[3]);
	if (regs[0] >= 0x80000008) {
		CPUID(0x80000008, regs[0], regs[1], regs[2], regs[3]);
		if (regs[0] & 0xff) {
			mtrrmask = (1ULL << (regs[0] & 0xff)) - 1;
			mtrrmask &= ~0x0000000000000fffULL;
		}
	}

	/*
	 * Get current settings, anything set now is considered to have
	 * been set by the firmware.
	 */
	mrfetch(sc);
	mrd = sc->mr_desc;
	for (i = 0; i < sc->mr_ndesc; i++, mrd++) {
		if (mrd->mr_flags & MDF_ACTIVE)
			mrd->mr_flags |= MDF_FIRMWARE;
	}
}

/*
 * Initialise MTRRs on a cpu from the software state.
 */
void
mrinit_cpu(struct mem_range_softc *sc)
{
	mrstoreone(sc); /* set MTRRs to match BSP */
}

void
mrreload_cpu(struct mem_range_softc *sc)
{
	disable_intr();
	mrstoreone(sc); /* set MTRRs to match BSP */
	enable_intr();
}
@


1.17
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.16 2014/07/13 12:11:01 jasper Exp $ */
d308 1
a308 1
	wrmsr(MSR_MTRRdefType, rdmsr(MSR_MTRRdefType) & ~0x800);
d365 1
a365 1
	wrmsr(MSR_MTRRdefType, mtrrdef | 0x800);
d538 1
a538 1
	if (!(mtrrdef & 0x800)) {
d546 2
a547 1
	if ((mtrrcap & 0x100) && (mtrrdef & 0x400)) {
d586 1
a586 1
	 * default a 36-bit address size.
@


1.16
log
@use nitems() instead of handrolling something identical

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.15 2013/08/24 04:26:16 mlarkin Exp $ */
d554 1
a554 1
	sc->mr_desc = malloc(nmdesc * sizeof(struct mem_range_desc),
@


1.15
log
@

Cleanup amd64 and i386 MTRR code -

1. Makes amd64 and i386 MTRR code nearly identical
2. Removes support for per-process MTRRs (which were never implemented)
3. Treat "unknown" MTRR types as uncacheable instead of trying to preserve
bogus settings made by the BIOS
4. Various KNF cleanups

Should be no functional change.

ok jsg@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.14 2012/08/01 15:44:14 mikeb Exp $ */
a108 2
#define MTRRTOMRTLEN (sizeof(mtrrtomrt) / sizeof(mtrrtomrt[0]))

d112 1
a112 1
	if (val < 0 || val >= MTRRTOMRTLEN)
d250 1
a250 1
	for (i = 0; i < MTRRTOMRTLEN; i++) {
@


1.14
log
@Use mtrrmask instead of hardcoded values to accommodate newer CPUs
with a large physical address size (greater than 36 bit). Fixes a
major performance hit seen on newer servers where an incorrectly
programmed memory region length affects the PCI device mappings.

While here, make sure to invalidate the TLB after programming MSRs
and fix an incorrect behavior found by deraadt@@ where MTRRdefType
was updated outside of the protected region.

The fix was partly obtained from FreeBSD, tested by many.
With and OK deraadt
@
text
@d1 2
a2 2
/* $OpenBSD: i686_mem.c,v 1.13 2010/03/23 19:31:18 kettenis Exp $ */
/*-
d41 2
a42 4
 * i686 memory range operations
 *
 * This code will probably be impenetrable without reference to the
 * Intel Pentium Pro documentation.
d47 1
a47 1
#define MR686_FIXMTRR	(1<<0)
d60 2
a61 1
#define mrcopyflags(curr, new) (((curr) & ~MDF_ATTRMASK) | ((new) & MDF_ATTRMASK))
d63 5
a67 2
void	i686_mrinit(struct mem_range_softc *sc);
int	i686_mrset(struct mem_range_softc *sc,
d69 2
a70 2
void	i686_mrinit_cpu(struct mem_range_softc *sc);
void	i686_mrreload_cpu(struct mem_range_softc *sc);
d72 5
a76 5
struct mem_range_ops i686_mrops = {
	i686_mrinit,
	i686_mrset,
	i686_mrinit_cpu,
	i686_mrreload_cpu
a78 1
/* XXX for AP startup hook */
d84 8
a91 8
void			 i686_mrfetch(struct mem_range_softc *sc);
int			 i686_mtrrtype(int flags);
int			 i686_mrt2mtrr(int flags, int oldval);
int			 i686_mtrr2mrt(int val);
int			 i686_mtrrconflict(int flag1, int flag2);
void			 i686_mrstore(struct mem_range_softc *sc);
void			 i686_mrstoreone(struct mem_range_softc *sc);
struct mem_range_desc	*i686_mtrrfixsearch(struct mem_range_softc *sc,
d93 1
a93 1
int			 i686_mrsetlow(struct mem_range_softc *sc,
d95 1
a95 1
int			 i686_mrsetvariable(struct mem_range_softc *sc,
d98 2
a99 2
/* i686 MTRR type to memory range type conversion */
int i686_mtrrtomrt[] = {
d109 1
a109 1
#define MTRRTOMRTLEN (sizeof(i686_mtrrtomrt) / sizeof(i686_mtrrtomrt[0]))
d112 1
a112 1
i686_mtrr2mrt(int val)
d116 1
a116 1
	return i686_mtrrtomrt[val];
d120 1
a120 1
 * i686 MTRR conflicts. Writeback and uncachable may overlap.
d123 1
a123 1
i686_mtrrconflict(int flag1, int flag2)
a124 1

d156 1
a156 1
i686_mrfetch(struct mem_range_softc *sc)
d160 1
a160 1
	int			 i, j, msr;
d163 3
d167 3
a169 3
	/* Get fixed-range MTRRs */
	if (sc->mr_cap & MR686_FIXMTRR) {
		msr = MSR_MTRR64kBase;
d173 3
d177 1
a177 2
					i686_mtrr2mrt(msrv & 0xff) |
					MDF_ACTIVE;
d184 2
a185 1
		msr = MSR_MTRR16kBase;
d189 3
d193 1
a193 2
					i686_mtrr2mrt(msrv & 0xff) |
					MDF_ACTIVE;
d200 2
a201 1
		msr = MSR_MTRR4kBase;
d205 3
d209 1
a209 2
					i686_mtrr2mrt(msrv & 0xff) |
					MDF_ACTIVE;
d219 1
a219 1
	msr = MSR_MTRRVarBase;
d222 4
a225 2
		mrd->mr_flags = (mrd->mr_flags & ~MDF_ATTRMASK) |
			i686_mtrr2mrt(msrv & 0xff);
d246 1
a246 1
i686_mtrrtype(int flags)
d248 1
a248 1
	int		i;
d253 1
a253 1
		if (i686_mtrrtomrt[i] == MDF_UNKNOWN)
d255 1
a255 1
		if (flags == i686_mtrrtomrt[i])
d258 1
a258 1
	return(-1);
d262 1
a262 1
i686_mrt2mtrr(int flags, int oldval)
d266 2
a267 2
	if ((val = i686_mtrrtype(flags)) == -1)
		return oldval & 0xff;
d278 1
a278 1
i686_mrstore(struct mem_range_softc *sc)
d284 1
a284 1
	i686_mrstoreone(sc);
d294 1
a294 1
i686_mrstoreone(struct mem_range_softc *sc)
d297 1
a297 1
	u_int64_t		 omsrv, msrv;
d306 5
a310 3
	lcr0((rcr0() & ~CR0_NW) | CR0_CD); /* disable caches (CD = 1, NW = 0) */
	wbinvd();		/* flush caches */
	wrmsr(MSR_MTRRdefType, rdmsr(MSR_MTRRdefType) & ~0x800);	/* disable MTRRs (E = 0) */
d313 2
a314 2
	if (sc->mr_cap & MR686_FIXMTRR) {
		msr = MSR_MTRR64kBase;
a316 1
			omsrv = rdmsr(msr);
d319 1
a319 2
				msrv |= i686_mrt2mtrr((mrd + j)->mr_flags,
						      omsrv >> (j*8));
d324 3
a326 4
		msr = MSR_MTRR16kBase;
		for (i = 0; i < (MTRR_N16K / 8); i++, msr++) {
			msrv = 0;
			omsrv = rdmsr(msr);
d329 1
a329 2
				msrv |= i686_mrt2mtrr((mrd + j)->mr_flags,
						      omsrv >> (j*8));
d334 3
a336 4
		msr = MSR_MTRR4kBase;
		for (i = 0; i < (MTRR_N4K / 8); i++, msr++) {
			msrv = 0;
			omsrv = rdmsr(msr);
d339 1
a339 2
				msrv |= i686_mrt2mtrr((mrd + j)->mr_flags,
						      omsrv >> (j*8));
d347 1
a347 1
	msr = MSR_MTRRVarBase;
a348 2
		/* base/type register */
		omsrv = rdmsr(msr);
d351 2
a352 2
			msrv |= i686_mrt2mtrr(mrd->mr_flags, omsrv);
		} else {
d354 1
a354 1
		}
d360 1
a360 1
		} else {
d362 1
a362 1
		}
d365 5
a369 5
	wbinvd();					/* flush caches */
	tlbflushg();					/* flush TLB */
	wrmsr(MSR_MTRRdefType, mtrrdef | 0x800);	/* restore MTRR state */
	lcr0(rcr0() & ~(CR0_CD | CR0_NW));  			/* enable caches CD = 0 and NW = 0 */
	lcr4(cr4save);						/* restore cr4 */
d376 1
a376 1
i686_mtrrfixsearch(struct mem_range_softc *sc, u_int64_t addr)
a393 2
 *
 * XXX note that this will have to be updated when we start supporting "busy" ranges.
d396 1
a396 1
i686_mrsetlow(struct mem_range_softc *sc, struct mem_range_desc *mrd, int *arg)
d401 2
a402 2
	if (((first_md = i686_mtrrfixsearch(sc, mrd->mr_base)) == NULL) ||
	    ((last_md = i686_mtrrfixsearch(sc, mrd->mr_base + mrd->mr_len - 1)) == NULL))
a423 2
 *
 * XXX needs to be updated to properly support "busy" ranges.
d426 1
a426 2
i686_mrsetvariable(struct mem_range_softc *sc, struct mem_range_desc *mrd,
    int *arg)
d438 1
a438 1
	i = (sc->mr_cap & MR686_FIXMTRR) ? MTRR_N64K + MTRR_N16K + MTRR_N4K : 0;
a445 3
				/* whoops, owned by someone */
				if (curr_md->mr_flags & MDF_BUSY)
					return(EBUSY);
d458 1
a458 1
				if (i686_mtrrconflict(curr_md->mr_flags,
a479 1
 *
d482 1
a482 1
i686_mrset(struct mem_range_softc *sc, struct mem_range_desc *mrd, int *arg)
d489 1
a489 1
		/* make sure that what's being asked for is even possible at all */
d491 1
a491 1
		    i686_mtrrtype(mrd->mr_flags) == -1)
a493 2
#define FIXTOP	((MTRR_N64K * 0x10000) + (MTRR_N16K * 0x4000) + (MTRR_N4K * 0x1000))
		
d495 1
a495 1
		if ((sc->mr_cap & MR686_FIXMTRR) &&
d497 1
a497 1
			if ((error = i686_mrsetlow(sc, mrd, arg)) != 0)
d501 1
a501 1
			if ((error = i686_mrsetvariable(sc, mrd, arg)) != 0)
a510 2
		if (targ->mr_flags & MDF_BUSY)
			return(EBUSY);
d520 1
a520 2
	i686_mrstore(sc);
	i686_mrfetch(sc);	/* refetch to see where we're at */
d529 1
a529 1
i686_mrinit(struct mem_range_softc *sc)
d541 1
a541 1
		printf("mtrr: CPU supports MTRRs but not enabled\n");
d545 1
a545 1
	printf("mtrr: Pentium Pro MTRR support\n");
d549 1
a549 1
		sc->mr_cap = MR686_FIXMTRR;
d551 1
d553 2
d563 1
a563 1
	if (sc->mr_cap & MR686_FIXMTRR) {
d569 1
d575 1
d589 1
a589 1
	cpuid(0x80000000, regs);
d591 1
a591 1
		cpuid(0x80000008, regs);
d600 1
a600 1
	 * been set by the firmware. (XXX has something already played here?)
d602 1
a602 1
	i686_mrfetch(sc);
d611 1
a611 2
 * Initialise MTRRs on an AP after the BSP has run the init code (or
 * re-initialise the MTRRs on the BSP after suspend).
d614 1
a614 1
i686_mrinit_cpu(struct mem_range_softc *sc)
d616 1
a616 1
	i686_mrstoreone(sc); /* set MTRRs to match BSP */
d620 1
a620 1
i686_mrreload_cpu(struct mem_range_softc *sc)
d622 2
a623 2
	disable_intr();				/* disable interrupts */
	i686_mrstoreone(sc); /* set MTRRs to match BSP */
@


1.13
log
@Use CPUID leaf function 0x80000008 to fetch the physical address size
supported by the processor and use it to calculate the mask used for
manipulating the MTRR registers.  If CPUID leaf function 0x80000008 isn't
supported by the processor, default to the 36-bit mask we used before.
Fixes issues on machines that don't have a 36-bit physical address space
like Intel Atom and all 64-bit AMD CPUs.

ok weingart@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.12 2010/02/23 21:54:53 kettenis Exp $ */
d294 1
a294 1
	wbinvd();		/* flush caches, TLBs */
d343 1
a343 1
			msrv = mrd->mr_base & 0x0000000ffffff000LL;
d352 1
a352 1
			msrv = 0x800 | (~(mrd->mr_len - 1) & 0x0000000ffffff000LL);
d358 3
a360 2
	wbinvd();							/* flush caches, TLBs */
	wrmsr(MSR_MTRRdefType, rdmsr(MSR_MTRRdefType) | 0x800);	/* restore MTRR state */
a619 1
	wrmsr(MSR_MTRRdefType, mtrrdef); /* set MTRR behaviour to match BSP */
@


1.12
log
@Restore MTRRs on resume.

ok oga@@, pirofti@@
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.11 2009/11/29 17:11:30 kettenis Exp $ */
d79 1
d213 1
a213 1
		mrd->mr_base = msrv & 0x0000000ffffff000LL;
d219 1
a219 1
		mrd->mr_len = (~(msrv & 0x0000000ffffff000LL) & 0x0000000fffffffffLL) + 1;
d538 1
d584 15
@


1.11
log
@Reload mtrr state on all CPUs after updates.  Seems to speed up X on MP
systems, at least with Intel graphics.

ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.10 2007/09/07 15:00:19 art Exp $ */
d67 2
a68 2
void	i686_mrAPinit(struct mem_range_softc *sc);
void	i686_mrreload(struct mem_range_softc *sc);
d73 2
a74 2
	i686_mrAPinit,
	i686_mrreload
d595 2
a596 1
 * Initialise MTRRs on an AP after the BSP has run the init code.
d599 1
a599 1
i686_mrAPinit(struct mem_range_softc *sc)
d606 1
a606 1
i686_mrreload(struct mem_range_softc *sc)
@


1.10
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.9 2006/09/19 11:06:33 jsg Exp $ */
d37 1
d66 1
a66 2
			   struct mem_range_desc *mrd,
			   int *arg);
d68 1
d73 2
a74 1
	i686_mrAPinit
d81 1
a81 1
						      struct mem_range_desc *mrd);
d88 1
a88 1
void			 i686_mrstoreone(void *arg);
d90 1
a90 1
						    u_int64_t addr);
d92 1
a92 2
					      struct mem_range_desc *mrd,
					      int *arg);
d94 1
a94 2
						   struct mem_range_desc *mrd,
						   int *arg);
d267 4
a270 1
	i686_mrstoreone((void *)sc);
d280 1
a280 1
i686_mrstoreone(void *arg)
a281 1
	struct mem_range_softc 	*sc = (struct mem_range_softc *)arg;
d600 1
a600 1
	i686_mrstoreone((void *)sc); /* set MTRRs to match BSP */
d604 7
@


1.9
log
@ansi/deregister
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.8 2006/05/27 04:08:57 gwk Exp $ */
d556 1
a556 2
	     M_MEMDESC, M_WAITOK);
	bzero(sc->mr_desc, nmdesc * sizeof(struct mem_range_desc));
@


1.8
log
@casting mallloc
ok uwe@@, dlg2
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.7 2006/05/11 13:21:11 mickey Exp $ */
d137 1
a137 3
mem_range_match(sc, mrd)
	struct mem_range_softc *sc;
	struct mem_range_desc *mrd;
d155 1
a155 2
i686_mrfetch(sc)
	struct mem_range_softc *sc;
d232 1
a232 2
i686_mtrrtype(flags)
	int flags;
d264 1
a264 2
i686_mrstore(sc)
	struct mem_range_softc *sc;
d277 1
a277 2
i686_mrstoreone(arg)
	void *arg;
d365 1
a365 3
i686_mtrrfixsearch(sc, addr)
	struct mem_range_softc 	*sc;
	u_int64_t		 addr;
d387 1
a387 4
i686_mrsetlow(sc, mrd, arg)
	struct mem_range_softc 	*sc;
	struct mem_range_desc 	*mrd;
	int 			*arg;
d419 2
a420 4
i686_mrsetvariable(sc, mrd, arg)
	struct mem_range_softc 	*sc;
	struct mem_range_desc 	*mrd;
	int 			*arg;
d480 1
a480 4
i686_mrset(sc, mrd, arg)
	struct mem_range_softc 	*sc;
	struct mem_range_desc 	*mrd;
	int 			*arg;
d532 1
a532 2
i686_mrinit(sc)
	struct mem_range_softc 	*sc;
d597 1
a597 2
i686_mrAPinit(sc)
	struct mem_range_softc *sc;
@


1.7
log
@kill trainling spaces
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.6 2003/05/04 04:29:03 tedu Exp $ */
d572 2
a573 3
	sc->mr_desc =
		(struct mem_range_desc *)malloc(nmdesc * sizeof(struct mem_range_desc),
						M_MEMDESC, M_WAITOK);
@


1.6
log
@string cleaning.  ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.5 2002/10/14 21:01:01 matthieu Exp $ */
d110 1
a110 1
i686_mtrr2mrt(int val) 
d121 1
a121 1
i686_mtrrconflict(int flag1, int flag2) 
d217 1
a217 1
		mrd->mr_flags = (msrv & 0x800) ? 
d308 1
a308 1
				msrv |= i686_mrt2mtrr((mrd + j)->mr_flags, 
d388 1
a388 1
 * Note that we try to be generous here; we'll bloat the range out to the 
d397 1
a397 1
	struct mem_range_desc 	*mrd; 
d437 3
a439 3
    
	/* 
	 * Scan the currently active variable descriptors, look for 
d458 1
a458 1
				    ((curr_md->mr_flags & MDF_ATTRMASK) 
d468 1
a468 1
				if (i686_mtrrconflict(curr_md->mr_flags, 
d544 1
a544 1
 * Work out how many ranges we support, initialise storage for them, 
d572 2
a573 2
	sc->mr_desc = 
		(struct mem_range_desc *)malloc(nmdesc * sizeof(struct mem_range_desc), 
d599 2
a600 2
	/* 
	 * Get current settings, anything set now is considered to have 
@


1.5
log
@Fix from FreeBSD for atlhon problems with mtrr and XFree86. Ok deraadt@@

FreeBSD commit messages say:

Some BIOSs are using MTRR values that are only documented under NDA
to control the mapping of things like the ACPI and APM into memory.

The problem is that starting X changes these values, so if something
was using the bits of BIOS mapped into memory (say ACPI or APM),
then next time they access this memory the machine would hang.

This patch refuse to change MTRR values it doesn't understand,
unless a new "force" option is given. This means X doesn't change
them by accident but someone can override that if they really want
to.

PR:             28418
Tested by:      Christopher Masto <chris at netmonger dot net>,
                David Bushong <david at bushong dot net>,
                Santos <casd at myrealbox dot com>


Make the MTRR code a bit more defensive - this should help people
trying to run X on some Athlon systems where the BIOS does odd things
(mines an ASUS A7A266, but it seems to also help on other systems).

Here's a description of the problem and my fix:

        The problem with the old MTRR code is that it only expects
        to find documented values in the bytes of MTRR registers.
        To convert the MTRR byte into a FreeBSD "Memory Range Type"
        (mrt) it uses the byte value and looks it up in an array.
        If the value is not in range then the mrt value ends up
        containing random junk.

        This isn't an immediate problem. The mrt value is only used
        later when rewriting the MTRR registers. When we finally
        go to write a value back again, the function i686_mtrrtype()
        searches for the junk value and returns -1 when it fails
        to find it. This is converted to a byte (0xff) and written
        back to the register, causing a GPF as 0xff is an illegal
        value for a MTRR byte.

        To work around this problem I've added a new mrt flag
        MDF_UNKNOWN.  We set this when we read a MTRR byte which
        we do not understand.  If we try to convert a MDF_UNKNOWN
        back into a MTRR value, then the new function, i686_mrt2mtrr,
        just returns the old value of the MTRR byte. This leaves
        the memory range type unchanged.

I have seen one side effect of the fix, which is that ACPI calls
after X has been run seem to hang my machine. As running X would
previously panic the machine, this is still an improvement ;-)

PR:             28418, 25958
Tested by:      jkh, Christopher Masto <chris at netmonger dot net>
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.4 2002/03/14 01:26:32 millert Exp $ */
d176 2
a177 1
					strcpy(mrd->mr_owner, mem_owner_bios);
d189 2
a190 1
					strcpy(mrd->mr_owner, mem_owner_bios);
d202 2
a203 1
					strcpy(mrd->mr_owner, mem_owner_bios);
d226 2
a227 1
			strcpy(mrd->mr_owner, mem_owner_bios);
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.3 1999/11/24 01:43:32 deraadt Exp $ */
d82 3
d100 2
a101 2
	0,
	0,
d107 25
a131 16
/* 
 * i686 MTRR conflict matrix for overlapping ranges 
 *
 * Specifically, this matrix allows writeback and uncached ranges
 * to overlap (the overlapped region is uncached).  The array index
 * is the translated i686 code for the flags (because they map well).
 */
int i686_mtrrconflict[] = {
	MDF_WRITECOMBINE | MDF_WRITETHROUGH | MDF_WRITEPROTECT,
	MDF_ATTRMASK,
	0,
	0,
	MDF_ATTRMASK,
	MDF_ATTRMASK,
	MDF_WRITECOMBINE | MDF_WRITETHROUGH | MDF_WRITEPROTECT
};
d173 1
a173 1
					i686_mtrrtomrt[msrv & 0xff] |
d185 1
a185 1
					i686_mtrrtomrt[msrv & 0xff] |
d197 1
a197 1
					i686_mtrrtomrt[msrv & 0xff] |
d211 1
a211 1
			i686_mtrrtomrt[msrv & 0xff];
d238 2
a239 2
	for (i = 0; i < (sizeof(i686_mtrrtomrt) / sizeof(i686_mtrrtomrt[0])); i++) {
		if (i686_mtrrtomrt[i] == 0)
d247 10
d283 1
a283 1
	u_int64_t		 msrv;
d301 1
d304 2
a305 1
				msrv |= (i686_mtrrtype((mrd + j)->mr_flags) & 0xff);
d313 1
d316 2
a317 1
				msrv |= (i686_mtrrtype((mrd + j)->mr_flags) & 0xff);
d325 1
d328 2
a329 1
				msrv |= (i686_mtrrtype((mrd + j)->mr_flags) & 0xff);
d340 1
d343 1
a343 1
			msrv |= (i686_mtrrtype(mrd->mr_flags) & 0xff);
d403 7
d452 5
d464 2
a465 2
				if ((i686_mtrrconflict[i686_mtrrtype(curr_md->mr_flags)] & mrd->mr_flags) ||
				    (i686_mtrrconflict[i686_mtrrtype(mrd->mr_flags)] & curr_md->mr_flags))
d501 1
a501 1
		    (i686_mtrrtype(mrd->mr_flags & MDF_ATTRMASK) == -1))
@


1.3
log
@spelling
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.2 1999/11/23 22:42:13 deraadt Exp $ */
d63 2
a64 2
void	i686_mrinit __P((struct mem_range_softc *sc));
int	i686_mrset __P((struct mem_range_softc *sc,
d66 2
a67 2
			   int *arg));
void	i686_mrAPinit __P((struct mem_range_softc *sc));
d78 9
a86 9
struct mem_range_desc	*mem_range_match __P((struct mem_range_softc *sc,
						      struct mem_range_desc *mrd));
void			 i686_mrfetch __P((struct mem_range_softc *sc));
int			 i686_mtrrtype __P((int flags));
void			 i686_mrstore __P((struct mem_range_softc *sc));
void			 i686_mrstoreone __P((void *arg));
struct mem_range_desc	*i686_mtrrfixsearch __P((struct mem_range_softc *sc,
						    u_int64_t addr));
int			 i686_mrsetlow __P((struct mem_range_softc *sc,
d88 2
a89 2
					      int *arg));
int			 i686_mrsetvariable __P((struct mem_range_softc *sc,
d91 1
a91 1
						   int *arg));
@


1.3.12.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.3 1999/11/24 01:43:32 deraadt Exp $ */
d63 2
a64 2
void	i686_mrinit(struct mem_range_softc *sc);
int	i686_mrset(struct mem_range_softc *sc,
d66 2
a67 2
			   int *arg);
void	i686_mrAPinit(struct mem_range_softc *sc);
d78 9
a86 9
struct mem_range_desc	*mem_range_match(struct mem_range_softc *sc,
						      struct mem_range_desc *mrd);
void			 i686_mrfetch(struct mem_range_softc *sc);
int			 i686_mtrrtype(int flags);
void			 i686_mrstore(struct mem_range_softc *sc);
void			 i686_mrstoreone(void *arg);
struct mem_range_desc	*i686_mtrrfixsearch(struct mem_range_softc *sc,
						    u_int64_t addr);
int			 i686_mrsetlow(struct mem_range_softc *sc,
d88 2
a89 2
					      int *arg);
int			 i686_mrsetvariable(struct mem_range_softc *sc,
d91 1
a91 1
						   int *arg);
@


1.3.12.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.3.12.1 2002/06/11 03:35:53 art Exp $ */
a81 3
int			 i686_mrt2mtrr(int flags, int oldval);
int			 i686_mtrr2mrt(int val);
int			 i686_mtrrconflict(int flag1, int flag2);
d97 2
a98 2
	MDF_UNKNOWN,
	MDF_UNKNOWN,
d104 16
a119 25
#define MTRRTOMRTLEN (sizeof(i686_mtrrtomrt) / sizeof(i686_mtrrtomrt[0]))

int
i686_mtrr2mrt(int val) 
{
	if (val < 0 || val >= MTRRTOMRTLEN)
		return MDF_UNKNOWN;
	return i686_mtrrtomrt[val];
}

/*
 * i686 MTRR conflicts. Writeback and uncachable may overlap.
 */
int
i686_mtrrconflict(int flag1, int flag2) 
{

	flag1 &= MDF_ATTRMASK;
	flag2 &= MDF_ATTRMASK;
	if (flag1 == flag2 ||
	    (flag1 == MDF_WRITEBACK && flag2 == MDF_UNCACHEABLE) ||
	    (flag2 == MDF_WRITEBACK && flag1 == MDF_UNCACHEABLE))
		return 0;
	return 1;
}
d161 1
a161 1
					i686_mtrr2mrt(msrv & 0xff) |
d173 1
a173 1
					i686_mtrr2mrt(msrv & 0xff) |
d185 1
a185 1
					i686_mtrr2mrt(msrv & 0xff) |
d199 1
a199 1
			i686_mtrr2mrt(msrv & 0xff);
d226 2
a227 2
	for (i = 0; i < MTRRTOMRTLEN; i++) {
		if (i686_mtrrtomrt[i] == MDF_UNKNOWN)
a234 10
int
i686_mrt2mtrr(int flags, int oldval)
{
	int val;

	if ((val = i686_mtrrtype(flags)) == -1)
		return oldval & 0xff;
	return val & 0xff;
}

d261 1
a261 1
	u_int64_t		 omsrv, msrv;
a278 1
			omsrv = rdmsr(msr);
d281 1
a281 2
				msrv |= i686_mrt2mtrr((mrd + j)->mr_flags, 
						      omsrv >> (j*8));
a288 1
			omsrv = rdmsr(msr);
d291 1
a291 2
				msrv |= i686_mrt2mtrr((mrd + j)->mr_flags,
						      omsrv >> (j*8));
a298 1
			omsrv = rdmsr(msr);
d301 1
a301 2
				msrv |= i686_mrt2mtrr((mrd + j)->mr_flags,
						      omsrv >> (j*8));
a311 1
		omsrv = rdmsr(msr);
d314 1
a314 1
			msrv |= i686_mrt2mtrr(mrd->mr_flags, omsrv);
a373 7
	/* check we aren't doing something risky */
	if (!(mrd->mr_flags & MDF_FORCE))
		for (curr_md = first_md; curr_md <= last_md; curr_md++) {
			if ((curr_md->mr_flags & MDF_ATTRMASK) == MDF_UNKNOWN)
				return (EACCES);
		}

a415 5
				/* check we aren't doing something risky */
				if (!(mrd->mr_flags & MDF_FORCE) &&
				    ((curr_md->mr_flags & MDF_ATTRMASK) 
				    == MDF_UNKNOWN))
					return (EACCES);
d423 2
a424 2
				if (i686_mtrrconflict(curr_md->mr_flags, 
						      mrd->mr_flags))
d460 1
a460 1
		    i686_mtrrtype(mrd->mr_flags) == -1)
@


1.3.12.3
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d176 1
a176 2
					strlcpy(mrd->mr_owner, mem_owner_bios,
					    sizeof(mrd->mr_owner));
d188 1
a188 2
					strlcpy(mrd->mr_owner, mem_owner_bios,
					    sizeof(mrd->mr_owner));
d200 1
a200 2
					strlcpy(mrd->mr_owner, mem_owner_bios,
					    sizeof(mrd->mr_owner));
d223 1
a223 2
			strlcpy(mrd->mr_owner, mem_owner_bios,
			    sizeof(mrd->mr_owner));
@


1.3.2.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d63 2
a64 2
void	i686_mrinit(struct mem_range_softc *sc);
int	i686_mrset(struct mem_range_softc *sc,
d66 2
a67 2
			   int *arg);
void	i686_mrAPinit(struct mem_range_softc *sc);
d78 9
a86 9
struct mem_range_desc	*mem_range_match(struct mem_range_softc *sc,
						      struct mem_range_desc *mrd);
void			 i686_mrfetch(struct mem_range_softc *sc);
int			 i686_mtrrtype(int flags);
void			 i686_mrstore(struct mem_range_softc *sc);
void			 i686_mrstoreone(void *arg);
struct mem_range_desc	*i686_mtrrfixsearch(struct mem_range_softc *sc,
						    u_int64_t addr);
int			 i686_mrsetlow(struct mem_range_softc *sc,
d88 2
a89 2
					      int *arg);
int			 i686_mrsetvariable(struct mem_range_softc *sc,
d91 1
a91 1
						   int *arg);
@


1.3.2.2
log
@Sync the SMP branch with 3.3
@
text
@a81 3
int			 i686_mrt2mtrr(int flags, int oldval);
int			 i686_mtrr2mrt(int val);
int			 i686_mtrrconflict(int flag1, int flag2);
d97 2
a98 2
	MDF_UNKNOWN,
	MDF_UNKNOWN,
d104 6
a109 12
#define MTRRTOMRTLEN (sizeof(i686_mtrrtomrt) / sizeof(i686_mtrrtomrt[0]))

int
i686_mtrr2mrt(int val) 
{
	if (val < 0 || val >= MTRRTOMRTLEN)
		return MDF_UNKNOWN;
	return i686_mtrrtomrt[val];
}

/*
 * i686 MTRR conflicts. Writeback and uncachable may overlap.
d111 9
a119 12
int
i686_mtrrconflict(int flag1, int flag2) 
{

	flag1 &= MDF_ATTRMASK;
	flag2 &= MDF_ATTRMASK;
	if (flag1 == flag2 ||
	    (flag1 == MDF_WRITEBACK && flag2 == MDF_UNCACHEABLE) ||
	    (flag2 == MDF_WRITEBACK && flag1 == MDF_UNCACHEABLE))
		return 0;
	return 1;
}
d161 1
a161 1
					i686_mtrr2mrt(msrv & 0xff) |
d173 1
a173 1
					i686_mtrr2mrt(msrv & 0xff) |
d185 1
a185 1
					i686_mtrr2mrt(msrv & 0xff) |
d199 1
a199 1
			i686_mtrr2mrt(msrv & 0xff);
d226 2
a227 2
	for (i = 0; i < MTRRTOMRTLEN; i++) {
		if (i686_mtrrtomrt[i] == MDF_UNKNOWN)
a234 10
int
i686_mrt2mtrr(int flags, int oldval)
{
	int val;

	if ((val = i686_mtrrtype(flags)) == -1)
		return oldval & 0xff;
	return val & 0xff;
}

d261 1
a261 1
	u_int64_t		 omsrv, msrv;
a278 1
			omsrv = rdmsr(msr);
d281 1
a281 2
				msrv |= i686_mrt2mtrr((mrd + j)->mr_flags, 
						      omsrv >> (j*8));
a288 1
			omsrv = rdmsr(msr);
d291 1
a291 2
				msrv |= i686_mrt2mtrr((mrd + j)->mr_flags,
						      omsrv >> (j*8));
a298 1
			omsrv = rdmsr(msr);
d301 1
a301 2
				msrv |= i686_mrt2mtrr((mrd + j)->mr_flags,
						      omsrv >> (j*8));
a311 1
		omsrv = rdmsr(msr);
d314 1
a314 1
			msrv |= i686_mrt2mtrr(mrd->mr_flags, omsrv);
a373 7
	/* check we aren't doing something risky */
	if (!(mrd->mr_flags & MDF_FORCE))
		for (curr_md = first_md; curr_md <= last_md; curr_md++) {
			if ((curr_md->mr_flags & MDF_ATTRMASK) == MDF_UNKNOWN)
				return (EACCES);
		}

a415 5
				/* check we aren't doing something risky */
				if (!(mrd->mr_flags & MDF_FORCE) &&
				    ((curr_md->mr_flags & MDF_ATTRMASK) 
				    == MDF_UNKNOWN))
					return (EACCES);
d423 2
a424 2
				if (i686_mtrrconflict(curr_md->mr_flags, 
						      mrd->mr_flags))
d460 1
a460 1
		    i686_mtrrtype(mrd->mr_flags) == -1)
@


1.3.2.3
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.3.2.2 2003/03/27 23:26:55 niklas Exp $ */
d176 1
a176 2
					strlcpy(mrd->mr_owner, mem_owner_bios,
					    sizeof(mrd->mr_owner));
d188 1
a188 2
					strlcpy(mrd->mr_owner, mem_owner_bios,
					    sizeof(mrd->mr_owner));
d200 1
a200 2
					strlcpy(mrd->mr_owner, mem_owner_bios,
					    sizeof(mrd->mr_owner));
d223 1
a223 2
			strlcpy(mrd->mr_owner, mem_owner_bios,
			    sizeof(mrd->mr_owner));
@


1.2
log
@pretty mmtr messages
@
text
@d1 1
a1 1
/* $OpenBSD: i686_mem.c,v 1.1 1999/11/20 11:11:28 matthieu Exp $ */
d515 1
a515 1
		printf("mmtr: CPU supports MTRRs but not enabled\n");
d519 1
a519 1
	printf("mmtr: Pentium Pro MTRR support\n");
@


1.1
log
@add MTRR support from FreeBSD
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d515 1
a515 1
		printf("CPU supports MTRRs but not enabled\n");
d519 1
a519 1
	printf("Pentium Pro MTRR support enabled\n");
@

