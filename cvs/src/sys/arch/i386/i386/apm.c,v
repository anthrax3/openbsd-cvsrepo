head	1.116;
access;
symbols
	OPENBSD_6_0:1.114.0.4
	OPENBSD_6_0_BASE:1.114
	OPENBSD_5_9:1.114.0.2
	OPENBSD_5_9_BASE:1.114
	OPENBSD_5_8:1.113.0.6
	OPENBSD_5_8_BASE:1.113
	OPENBSD_5_7:1.113.0.2
	OPENBSD_5_7_BASE:1.113
	OPENBSD_5_6:1.105.0.4
	OPENBSD_5_6_BASE:1.105
	OPENBSD_5_5:1.102.0.4
	OPENBSD_5_5_BASE:1.102
	OPENBSD_5_4:1.100.0.4
	OPENBSD_5_4_BASE:1.100
	OPENBSD_5_3:1.100.0.2
	OPENBSD_5_3_BASE:1.100
	OPENBSD_5_2:1.98.0.6
	OPENBSD_5_2_BASE:1.98
	OPENBSD_5_1_BASE:1.98
	OPENBSD_5_1:1.98.0.4
	OPENBSD_5_0:1.98.0.2
	OPENBSD_5_0_BASE:1.98
	OPENBSD_4_9:1.96.0.2
	OPENBSD_4_9_BASE:1.96
	OPENBSD_4_8:1.88.0.2
	OPENBSD_4_8_BASE:1.88
	OPENBSD_4_7:1.84.0.2
	OPENBSD_4_7_BASE:1.84
	OPENBSD_4_6:1.84.0.4
	OPENBSD_4_6_BASE:1.84
	OPENBSD_4_5:1.83.0.2
	OPENBSD_4_5_BASE:1.83
	OPENBSD_4_4:1.81.0.4
	OPENBSD_4_4_BASE:1.81
	OPENBSD_4_3:1.81.0.2
	OPENBSD_4_3_BASE:1.81
	OPENBSD_4_2:1.76.0.2
	OPENBSD_4_2_BASE:1.76
	OPENBSD_4_1:1.73.0.2
	OPENBSD_4_1_BASE:1.73
	OPENBSD_4_0:1.70.0.2
	OPENBSD_4_0_BASE:1.70
	OPENBSD_3_9:1.67.0.2
	OPENBSD_3_9_BASE:1.67
	OPENBSD_3_8:1.66.0.2
	OPENBSD_3_8_BASE:1.66
	OPENBSD_3_7:1.63.0.4
	OPENBSD_3_7_BASE:1.63
	OPENBSD_3_6:1.63.0.2
	OPENBSD_3_6_BASE:1.63
	SMP_SYNC_A:1.62
	SMP_SYNC_B:1.62
	OPENBSD_3_5:1.61.0.2
	OPENBSD_3_5_BASE:1.61
	OPENBSD_3_4:1.59.0.2
	OPENBSD_3_4_BASE:1.59
	UBC_SYNC_A:1.59
	OPENBSD_3_3:1.58.0.2
	OPENBSD_3_3_BASE:1.58
	OPENBSD_3_2:1.54.0.2
	OPENBSD_3_2_BASE:1.54
	OPENBSD_3_1:1.53.0.2
	OPENBSD_3_1_BASE:1.53
	UBC_SYNC_B:1.54
	UBC:1.50.0.2
	UBC_BASE:1.50
	OPENBSD_3_0:1.49.0.2
	OPENBSD_3_0_BASE:1.49
	OPENBSD_2_9:1.45.0.2
	OPENBSD_2_9_BASE:1.45
	OPENBSD_2_8:1.41.0.2
	OPENBSD_2_8_BASE:1.41
	OPENBSD_2_7:1.37.0.2
	OPENBSD_2_7_BASE:1.37
	SMP:1.33.0.2
	SMP_BASE:1.33
	kame_19991208:1.27
	OPENBSD_2_6:1.26.0.4
	OPENBSD_2_6_BASE:1.26
	OPENBSD_2_5:1.26.0.2
	OPENBSD_2_5_BASE:1.26
	OPENBSD_2_4:1.22.0.2
	OPENBSD_2_4_BASE:1.22
	OPENBSD_2_3:1.19.0.2
	OPENBSD_2_3_BASE:1.19
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.116
date	2016.10.08.05.49.08;	author guenther;	state Exp;
branches;
next	1.115;
commitid	z63v1DilayzHcfkw;

1.115
date	2016.09.03.14.46.56;	author naddy;	state Exp;
branches;
next	1.114;
commitid	RpNaiU9Lz1B3rhqT;

1.114
date	2015.09.28.18.36.36;	author deraadt;	state Exp;
branches;
next	1.113;
commitid	sjQx9dlBaND52EhB;

1.113
date	2015.02.07.01.19.40;	author deraadt;	state Exp;
branches;
next	1.112;
commitid	J7ySI1ZREP62T8hM;

1.112
date	2014.12.18.17.02.35;	author deraadt;	state Exp;
branches;
next	1.111;
commitid	0gyx6OniqAaaI0XR;

1.111
date	2014.12.18.17.00.19;	author deraadt;	state Exp;
branches;
next	1.110;
commitid	k20qUVoE0cc9WIuk;

1.110
date	2014.10.17.15.35.31;	author deraadt;	state Exp;
branches;
next	1.109;
commitid	OpKXTU5XYbJ2lA1t;

1.109
date	2014.10.17.03.56.00;	author deraadt;	state Exp;
branches;
next	1.108;
commitid	ZxAWgx34QdzBzNac;

1.108
date	2014.10.01.20.49.50;	author mlarkin;	state Exp;
branches;
next	1.107;
commitid	VvR5F8wzVS2ciAv8;

1.107
date	2014.09.19.20.02.25;	author kettenis;	state Exp;
branches;
next	1.106;
commitid	lZNawJpIJwhgF8VB;

1.106
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.105;
commitid	uzzBR7hz9ncd4O6G;

1.105
date	2014.03.31.12.11.42;	author mpi;	state Exp;
branches;
next	1.104;

1.104
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.103;

1.103
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.102;

1.102
date	2013.12.06.21.03.05;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2013.11.18.20.21.51;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2012.10.17.22.49.27;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2012.10.08.21.47.48;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2011.07.02.22.20.07;	author nicm;	state Exp;
branches;
next	1.97;

1.97
date	2011.06.29.16.18.04;	author tedu;	state Exp;
branches;
next	1.96;

1.96
date	2011.01.13.23.19.36;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2011.01.04.23.08.56;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2010.09.09.04.13.15;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2010.09.08.21.38.43;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2010.09.08.21.18.15;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2010.09.06.15.42.18;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2010.08.27.19.10.59;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2010.08.27.04.09.11;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2010.07.25.21.43.35;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2010.07.20.12.23.00;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.85;

1.85
date	2010.03.30.17.40.55;	author oga;	state Exp;
branches;
next	1.84;

1.84
date	2009.06.24.13.54.42;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2009.02.26.17.19.47;	author oga;	state Exp;
branches;
next	1.82;

1.82
date	2008.08.16.00.26.26;	author krw;	state Exp;
branches;
next	1.81;

1.81
date	2007.12.11.15.44.00;	author tedu;	state Exp;
branches;
next	1.80;

1.80
date	2007.12.05.19.17.13;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2007.11.25.15.42.15;	author tedu;	state Exp;
branches;
next	1.78;

1.78
date	2007.11.03.03.37.08;	author weingart;	state Exp;
branches;
next	1.77;

1.77
date	2007.10.22.17.11.14;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2007.07.02.17.11.29;	author thib;	state Exp;
branches;
next	1.75;

1.75
date	2007.05.29.08.22.14;	author gwk;	state Exp;
branches;
next	1.74;

1.74
date	2007.03.19.09.29.33;	author art;	state Exp;
branches;
next	1.73;

1.73
date	2007.02.27.15.16.30;	author marco;	state Exp;
branches;
next	1.72;

1.72
date	2006.10.22.23.21.25;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2006.10.19.20.46.16;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2006.07.07.04.06.11;	author gwk;	state Exp;
branches;
next	1.69;

1.69
date	2006.05.11.13.21.11;	author mickey;	state Exp;
branches;
next	1.68;

1.68
date	2006.04.15.20.43.36;	author mickey;	state Exp;
branches;
next	1.67;

1.67
date	2005.11.19.02.18.00;	author pedro;	state Exp;
branches;
next	1.66;

1.66
date	2005.06.16.16.49.04;	author beck;	state Exp;
branches;
next	1.65;

1.65
date	2005.05.24.08.54.14;	author marco;	state Exp;
branches;
next	1.64;

1.64
date	2005.04.29.01.12.27;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches
	1.63.2.1
	1.63.4.1;
next	1.62;

1.62
date	2004.05.27.08.19.59;	author tedu;	state Exp;
branches;
next	1.61;

1.61
date	2004.03.11.17.20.33;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	2003.11.24.07.26.55;	author mickey;	state Exp;
branches;
next	1.59;

1.59
date	2003.04.26.08.01.41;	author jmc;	state Exp;
branches;
next	1.58;

1.58
date	2003.01.29.00.00.44;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2003.01.09.17.43.56;	author mickey;	state Exp;
branches;
next	1.56;

1.56
date	2002.12.22.17.12.44;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	2002.12.18.22.53.06;	author mickey;	state Exp;
branches;
next	1.54;

1.54
date	2002.06.19.02.43.40;	author mickey;	state Exp;
branches;
next	1.53;

1.53
date	2002.03.14.03.15.53;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2002.01.16.20.50.16;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2001.12.14.17.07.40;	author mickey;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2001.08.18.06.08.08;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.24.20.38.04;	author fgsch;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.24.05.02.13;	author fgsch;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.23.23.13.39;	author mickey;	state Exp;
branches;
next	1.45;

1.45
date	2001.02.19.04.57.02;	author ho;	state Exp;
branches;
next	1.44;

1.44
date	2001.02.06.00.15.01;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2001.01.02.16.16.50;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2000.12.12.00.36.58;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2000.10.18.16.53.01;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2000.07.26.03.39.45;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2000.06.07.22.25.47;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2000.05.30.03.39.34;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2000.04.21.16.29.58;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2000.04.17.18.14.22;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2000.02.21.17.46.16;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2000.02.21.17.09.01;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2000.02.01.01.33.45;	author mickey;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2000.01.31.21.09.36;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2000.01.31.19.48.58;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2000.01.31.10.00.05;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2000.01.31.02.04.35;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2000.01.29.21.46.53;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	99.11.07.17.39.15;	author provos;	state Exp;
branches;
next	1.26;

1.26
date	99.02.28.05.53.13;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	99.02.23.04.10.12;	author marc;	state Exp;
branches;
next	1.24;

1.24
date	99.01.06.01.31.20;	author kstailey;	state Exp;
branches;
next	1.23;

1.23
date	98.11.15.16.36.49;	author art;	state Exp;
branches;
next	1.22;

1.22
date	98.09.17.20.34.41;	author marc;	state Exp;
branches;
next	1.21;

1.21
date	98.07.18.02.40.33;	author marc;	state Exp;
branches;
next	1.20;

1.20
date	98.04.27.23.39.31;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.12.17.22.05.31;	author rees;	state Exp;
branches;
next	1.18;

1.18
date	97.12.11.01.03.51;	author rees;	state Exp;
branches;
next	1.17;

1.17
date	97.12.11.00.58.44;	author rees;	state Exp;
branches;
next	1.16;

1.16
date	97.12.03.00.19.32;	author rees;	state Exp;
branches;
next	1.15;

1.15
date	97.11.30.18.59.19;	author rees;	state Exp;
branches;
next	1.14;

1.14
date	97.10.24.06.49.19;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	97.10.22.23.37.10;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.10.13.00.09.20;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.09.29.03.42.24;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.09.24.22.18.12;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.09.22.14.55.13;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.09.22.12.07.45;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.09.21.04.27.52;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.08.19.20.09.04;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	97.07.08.02.52.25;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.01.02.12.24.35;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.10.21.11.37.53;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.07.15.07.33.16;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.04.29.14.13.34;	author hvozda;	state Exp;
branches;
next	;

1.33.2.1
date	2000.02.21.22.29.01;	author niklas;	state Exp;
branches;
next	1.33.2.2;

1.33.2.2
date	2001.04.18.16.07.12;	author niklas;	state Exp;
branches;
next	1.33.2.3;

1.33.2.3
date	2001.07.04.10.16.29;	author niklas;	state Exp;
branches;
next	1.33.2.4;

1.33.2.4
date	2001.10.31.03.01.11;	author nate;	state Exp;
branches;
next	1.33.2.5;

1.33.2.5
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.33.2.6;

1.33.2.6
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.33.2.7;

1.33.2.7
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.33.2.8;

1.33.2.8
date	2003.05.13.19.42.07;	author ho;	state Exp;
branches;
next	1.33.2.9;

1.33.2.9
date	2003.05.15.04.08.01;	author niklas;	state Exp;
branches;
next	1.33.2.10;

1.33.2.10
date	2004.02.19.10.48.41;	author niklas;	state Exp;
branches;
next	1.33.2.11;

1.33.2.11
date	2004.06.05.23.08.59;	author niklas;	state Exp;
branches;
next	1.33.2.12;

1.33.2.12
date	2004.06.11.18.54.16;	author deraadt;	state Exp;
branches;
next	;

1.50.2.1
date	2002.01.31.22.55.11;	author niklas;	state Exp;
branches;
next	1.50.2.2;

1.50.2.2
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	1.50.2.3;

1.50.2.3
date	2002.10.29.00.28.03;	author art;	state Exp;
branches;
next	1.50.2.4;

1.50.2.4
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;

1.63.2.1
date	2005.06.11.02.58.49;	author brad;	state Exp;
branches;
next	;

1.63.4.1
date	2005.06.12.16.07.34;	author brad;	state Exp;
branches;
next	;


desc
@@


1.116
log
@Various printf claim to report the PID, so actually report that and not the TID

Build testing assistance from deraadt@@
@
text
@/*	$OpenBSD: apm.c,v 1.115 2016/09/03 14:46:56 naddy Exp $	*/

/*-
 * Copyright (c) 1998-2001 Michael Shalayeff. All rights reserved.
 * Copyright (c) 1995 John T. Kohl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the names of the authors nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include "apm.h"

#if NAPM > 1
#error only one APM device may be configured
#endif

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/kthread.h>
#include <sys/rwlock.h>
#include <sys/sysctl.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/event.h>
#include <dev/rndvar.h>

#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/gdt.h>
#include <machine/psl.h>

#include <dev/isa/isareg.h>
#include <i386/isa/isa_machdep.h>
#include <i386/isa/nvram.h>
#include <dev/isa/isavar.h>
#include <dev/wscons/wsdisplayvar.h>

#include <machine/acpiapm.h>
#include <machine/biosvar.h>
#include <machine/apmvar.h>

#include "wsdisplay.h"

#if defined(APMDEBUG)
#define DPRINTF(x)	printf x
#else
#define	DPRINTF(x)	/**/
#endif

struct cfdriver apm_cd = {
	NULL, "apm", DV_DULL
};

struct apm_softc {
	struct device sc_dev;
	struct klist sc_note;
	int	sc_flags;
	int	batt_life;
	int	be_batt;
	struct proc *sc_thread;
	struct rwlock sc_lock;
};
#define	SCFLAG_OREAD	0x0000001
#define	SCFLAG_OWRITE	0x0000002
#define	SCFLAG_OPEN	(SCFLAG_OREAD|SCFLAG_OWRITE)

int	apmprobe(struct device *, void *, void *);
void	apmattach(struct device *, struct device *, void *);

struct cfattach apm_ca = {
	sizeof(struct apm_softc), apmprobe, apmattach
};

void	filt_apmrdetach(struct knote *kn);
int	filt_apmread(struct knote *kn, long hint);

struct filterops apmread_filtops = {
	1, NULL, filt_apmrdetach, filt_apmread
};

/* battery percentage at where we get verbose in our warnings.  This
 * value can be changed using sysctl(8), value machdep.apmwarn.
 * Setting it to zero kills all warnings
 */
int	cpu_apmwarn = 10;

#define	APM_RESUME_HOLDOFF	3

/*
 * Flags to control kernel display
 *	SCFLAG_NOPRINT:		do not output APM power messages due to
 *				a power change event.
 *
 *	SCFLAG_PCTPRINT:	do not output APM power messages due to
 *				to a power change event unless the battery
 *				percentage changes.
 */
#define SCFLAG_NOPRINT	0x0008000
#define SCFLAG_PCTPRINT	0x0004000
#define SCFLAG_PRINT	(SCFLAG_NOPRINT|SCFLAG_PCTPRINT)

#define	APMUNIT(dev)	(minor(dev)&0xf0)
#define	APMDEV(dev)	(minor(dev)&0x0f)
#define APMDEV_NORMAL	0
#define APMDEV_CTL	8

int	apm_standbys;
int	apm_lidclose;
int	apm_userstandbys;
int	apm_suspends;
int	apm_resumes;
int	apm_battlow;
int	apm_evindex;
int	apm_error;
int	apm_op_inprog;

u_int	apm_flags;
u_char	apm_majver;
u_char	apm_minver;
int	apm_attached = 0;
static int	apm_slow_called = 0;

struct {
	u_int32_t entry;
	u_int16_t seg;
	u_int16_t pad;
} apm_ep;

struct apmregs {
	u_int32_t	ax;
	u_int32_t	bx;
	u_int32_t	cx;
	u_int32_t	dx;
};

int  apmcall(u_int, u_int, struct apmregs *);
int  apm_handle_event(struct apm_softc *, struct apmregs *);
void apm_set_ver(struct apm_softc *);
int  apm_periodic_check(struct apm_softc *);
void apm_thread_create(void *v);
void apm_thread(void *);
void apm_disconnect(struct apm_softc *);
void apm_perror(const char *, struct apmregs *);
void apm_powmgt_enable(int onoff);
void apm_powmgt_engage(int onoff, u_int devid);
/* void apm_devpowmgt_enable(int onoff, u_int devid); */
int  apm_record_event(struct apm_softc *sc, u_int type);
const char *apm_err_translate(int code);

#define	apm_get_powstat(r) apmcall(APM_POWER_STATUS, APM_DEV_ALLDEVS, r)
void	apm_suspend(int);
void	apm_resume(struct apm_softc *, struct apmregs *);
void	apm_cpu_slow(void);

static int __inline
apm_get_event(struct apmregs *r)
{
	int rv;

	bzero(r, sizeof(*r));
	rv = apmcall(APM_GET_PM_EVENT, 0, r);
	return rv;
}

const char *
apm_err_translate(int code)
{
	switch (code) {
	case APM_ERR_PM_DISABLED:
		return "power management disabled";
	case APM_ERR_REALALREADY:
		return "real mode interface already connected";
	case APM_ERR_NOTCONN:
		return "interface not connected";
	case APM_ERR_16ALREADY:
		return "16-bit interface already connected";
	case APM_ERR_16NOTSUPP:
		return "16-bit interface not supported";
	case APM_ERR_32ALREADY:
		return "32-bit interface already connected";
	case APM_ERR_32NOTSUPP:
		return "32-bit interface not supported";
	case APM_ERR_UNRECOG_DEV:
		return "unrecognized device ID";
	case APM_ERR_ERANGE:
		return "parameter out of range";
	case APM_ERR_NOTENGAGED:
		return "interface not engaged";
	case APM_ERR_UNABLE:
		return "unable to enter requested state";
	case APM_ERR_NOEVENTS:
		return "No pending events";
	case APM_ERR_NOT_PRESENT:
		return "No APM present";
	default:
		return "unknown error code?";
	}
}

int apmerrors = 0;

void
apm_perror(const char *str, struct apmregs *regs)
{
	printf("apm0: APM %s: %s (%d)\n", str,
	    apm_err_translate(APM_ERR_CODE(regs)),
	    APM_ERR_CODE(regs));
	delay(1000000);

	apmerrors++;
}

void
apm_suspend(int state)
{
	extern int perflevel;
	int s;

#if NWSDISPLAY > 0
	wsdisplay_suspend();
#endif /* NWSDISPLAY > 0 */
	stop_periodic_resettodr();
	config_suspend_all(DVACT_QUIESCE);
	bufq_quiesce();

	s = splhigh();
	disable_intr();
	cold = 2;
	config_suspend_all(DVACT_SUSPEND);
	suspend_randomness();

	/* XXX
	 * Flag to disk drivers that they should "power down" the disk
	 * when we get to DVACT_POWERDOWN.
	 */
	boothowto |= RB_POWERDOWN;
	config_suspend_all(DVACT_POWERDOWN);
	boothowto &= ~RB_POWERDOWN;

	/* Send machine to sleep */
	apm_set_powstate(APM_DEV_ALLDEVS, state);
	/* Wake up  */

	/* They say that some machines may require reinitializing the clocks */
	i8254_startclock();
	if (initclock_func == i8254_initclocks)
		rtcstart();		/* in i8254 mode, rtc is profclock */
	inittodr(time_second);

	config_suspend_all(DVACT_RESUME);
	cold = 0;
	enable_intr();
	splx(s);

	resume_randomness(NULL, 0);	/* force RNG upper level reseed */
	bufq_restart();

	config_suspend_all(DVACT_WAKEUP);
	start_periodic_resettodr();

#if NWSDISPLAY > 0
	wsdisplay_resume();
#endif /* NWSDISPLAY > 0 */

	/* restore hw.setperf */
	if (cpu_setperf != NULL)
		cpu_setperf(perflevel);
}

void
apm_resume(struct apm_softc *sc, struct apmregs *regs)
{

	apm_resumes = APM_RESUME_HOLDOFF;

	/* lower bit in cx means pccard was powered down */

	apm_record_event(sc, regs->bx);
}

int
apm_record_event(struct apm_softc *sc, u_int type)
{
	if (!apm_error && (sc->sc_flags & SCFLAG_OPEN) == 0) {
		DPRINTF(("apm_record_event: no user waiting\n"));
		apm_error++;
		return 1;
	}

	apm_evindex++;
	KNOTE(&sc->sc_note, APM_EVENT_COMPOSE(type, apm_evindex));
	return (0);
}

int
apm_handle_event(struct apm_softc *sc, struct apmregs *regs)
{
	struct apmregs nregs;
	int ret = 0;

	switch (regs->bx) {
	case APM_NOEVENT:
		ret++;
		break;

	case APM_USER_STANDBY_REQ:
		if (apm_resumes || apm_op_inprog)
			break;
		DPRINTF(("user wants STANDBY--fat chance\n"));
		apm_op_inprog++;
		if (apm_record_event(sc, regs->bx)) {
			DPRINTF(("standby ourselves\n"));
			apm_userstandbys++;
		}
		break;
	case APM_STANDBY_REQ:
		if (apm_resumes || apm_op_inprog)
			break;
		DPRINTF(("standby requested\n"));
		if (apm_standbys || apm_suspends) {
			DPRINTF(("premature standby\n"));
			apm_error++;
			ret++;
		}
		apm_op_inprog++;
		if (apm_record_event(sc, regs->bx)) {
			DPRINTF(("standby ourselves\n"));
			apm_standbys++;
		}
		break;
	case APM_USER_SUSPEND_REQ:
		if (apm_resumes || apm_op_inprog)
			break;
		DPRINTF(("user wants suspend--fat chance!\n"));
		apm_op_inprog++;
		if (apm_record_event(sc, regs->bx)) {
			DPRINTF(("suspend ourselves\n"));
			apm_suspends++;
		}
		break;
	case APM_SUSPEND_REQ:
		if (apm_resumes || apm_op_inprog)
			break;
		DPRINTF(("suspend requested\n"));
		if (apm_standbys || apm_suspends) {
			DPRINTF(("premature suspend\n"));
			apm_error++;
			ret++;
		}
		apm_op_inprog++;
		if (apm_record_event(sc, regs->bx)) {
			DPRINTF(("suspend ourselves\n"));
			apm_suspends++;
		}
		break;
	case APM_POWER_CHANGE:
		DPRINTF(("power status change\n"));
		apm_get_powstat(&nregs);
		apm_record_event(sc, regs->bx);
		break;
	case APM_NORMAL_RESUME:
		DPRINTF(("system resumed\n"));
		apm_resume(sc, regs);
		break;
	case APM_CRIT_RESUME:
		DPRINTF(("system resumed without us!\n"));
		apm_resume(sc, regs);
		break;
	case APM_SYS_STANDBY_RESUME:
		DPRINTF(("system standby resume\n"));
		apm_resume(sc, regs);
		break;
	case APM_UPDATE_TIME:
		DPRINTF(("update time, please\n"));
		inittodr(time_second);
		apm_record_event(sc, regs->bx);
		break;
	case APM_CRIT_SUSPEND_REQ:
		DPRINTF(("suspend required immediately\n"));
		apm_record_event(sc, regs->bx);
		apm_suspend(APM_SYS_SUSPEND);
		break;
	case APM_BATTERY_LOW:
		DPRINTF(("Battery low!\n"));
		apm_battlow++;
		apm_record_event(sc, regs->bx);
		break;
	case APM_CAPABILITY_CHANGE:
		DPRINTF(("capability change\n"));
		if (apm_minver < 2) {
			DPRINTF(("adult event\n"));
		} else {
			if (apmcall(APM_GET_CAPABILITIES, APM_DEV_APM_BIOS,
			    &nregs) != 0) {
				apm_perror("get capabilities", &nregs);
			} else {
				apm_get_powstat(&nregs);
			}
		}
		break;
	default: {
#ifdef APMDEBUG
		char *p;
		switch (regs->bx >> 8) {
		case 0:	p = "reserved system";	break;
		case 1:	p = "reserved device";	break;
		case 2:	p = "OEM defined";	break;
		default:p = "reserved";		break;
		}
#endif
		DPRINTF(("apm_handle_event: %s event, code %d\n", p, regs->bx));
	    }
	}
	return ret;
}

int
apm_periodic_check(struct apm_softc *sc)
{
	struct apmregs regs;
	int ret = 0;

	if (apm_op_inprog)
		apm_set_powstate(APM_DEV_ALLDEVS, APM_LASTREQ_INPROG);

	while (1) {
		if (apm_get_event(&regs) != 0) {
			/* i think some bioses combine the error codes */
			if (!(APM_ERR_CODE(&regs) & APM_ERR_NOEVENTS))
				apm_perror("get event", &regs);
			break;
		}

		/* If the APM BIOS tells us to suspend, don't do it twice */
		if (regs.bx == APM_SUSPEND_REQ)
			apm_lidclose = 0;
		if (apm_handle_event(sc, &regs))
			break;
	}

	if (apm_error || APM_ERR_CODE(&regs) == APM_ERR_NOTCONN)
		ret = -1;

	if (apm_lidclose) {
		apm_lidclose = 0;
		/* Fake a suspend request */
		regs.bx = APM_SUSPEND_REQ;
		apm_handle_event(sc, &regs);
	}
	if (apm_suspends /*|| (apm_battlow && apm_userstandbys)*/) {
		apm_op_inprog = 0;
		apm_suspend(APM_SYS_SUSPEND);
	} else if (apm_standbys || apm_userstandbys) {
		apm_op_inprog = 0;
		apm_suspend(APM_SYS_STANDBY);
	}
	apm_suspends = apm_standbys = apm_battlow = apm_userstandbys = 0;
	apm_error = 0;

	if (apm_resumes)
		apm_resumes--;
	return (ret);
}

void
apm_powmgt_enable(int onoff)
{
	struct apmregs regs;

	bzero(&regs, sizeof(regs));
	regs.cx = onoff ? APM_MGT_ENABLE : APM_MGT_DISABLE;
	if (apmcall(APM_PWR_MGT_ENABLE,
	    (apm_minver? APM_DEV_APM_BIOS : APM_MGT_ALL), &regs) != 0)
		apm_perror("power management enable", &regs);
}

void
apm_powmgt_engage(int onoff, u_int dev)
{
	struct apmregs regs;

	if (apm_minver == 0)
		return;
	bzero(&regs, sizeof(regs));
	regs.cx = onoff ? APM_MGT_ENGAGE : APM_MGT_DISENGAGE;
	if (apmcall(APM_PWR_MGT_ENGAGE, dev, &regs) != 0)
		printf("apm0: APM engage (device %x): %s (%d)\n",
		    dev, apm_err_translate(APM_ERR_CODE(&regs)),
		    APM_ERR_CODE(&regs));
}

#ifdef notused
void
apm_devpowmgt_enable(int onoff, u_int dev)
{
	struct apmregs regs;

	if (apm_minver == 0)
		return;
	/* enable is auto BIOS management.
	 * disable is program control.
	 */
	bzero(&regs, sizeof(regs));
	regs.cx = onoff ? APM_MGT_ENABLE : APM_MGT_DISABLE;
	if (apmcall(APM_DEVICE_MGMT_ENABLE, dev, &regs) != 0)
		printf("APM device engage (device %x): %s (%d)\n",
		    dev, apm_err_translate(APM_ERR_CODE(&regs)),
		    APM_ERR_CODE(&regs));
}
#endif

int
apm_set_powstate(u_int dev, u_int state)
{
	struct apmregs regs;

	if (!apm_cd.cd_ndevs || (apm_minver == 0 && state > APM_SYS_OFF))
		return EINVAL;
	bzero(&regs, sizeof(regs));
	regs.cx = state;
	if (apmcall(APM_SET_PWR_STATE, dev, &regs) != 0) {
		apm_perror("set power state", &regs);
		if (APM_ERR_CODE(&regs) == APM_ERR_UNRECOG_DEV)
			return ENXIO;
		else
			return EIO;
	}
	return 0;
}

void
apm_cpu_slow(void)
{
	struct apmregs regs;
	static u_int64_t call_apm_slow = 0;

	if  (call_apm_slow != curcpu()->ci_schedstate.spc_cp_time[CP_IDLE]) {
		/* Always call BIOS halt/idle stuff */
		bzero(&regs, sizeof(regs));
		if (apmcall(APM_CPU_IDLE, 0, &regs) != 0) {
#ifdef DIAGNOSTIC
			apm_perror("set CPU slow", &regs);
#endif
		}
		apm_slow_called = 1;
		call_apm_slow = curcpu()->ci_schedstate.spc_cp_time[CP_IDLE];
	}
}

void
apm_cpu_busy(void)
{
	struct apmregs regs;

	if (!apm_slow_called)
		return;

	if (apm_flags & APM_IDLE_SLOWS) {
		bzero(&regs, sizeof(regs));
		if (apmcall(APM_CPU_BUSY, 0, &regs) != 0) {
#ifdef DIAGNOSTIC
			apm_perror("set CPU busy", &regs);
#endif
		}
		apm_slow_called = 0;
	}
}

void
apm_cpu_idle(void)
{
	struct apmregs regs;
	static u_int64_t call_apm_idle = 0;

	/*
	 * We call the bios APM_IDLE routine here only when we
	 * have been idle for some time - otherwise we just hlt.
	 */

	if  (call_apm_idle != curcpu()->ci_schedstate.spc_cp_time[CP_IDLE]) {
		/* Always call BIOS halt/idle stuff */
		bzero(&regs, sizeof(regs));
		if (apmcall(APM_CPU_IDLE, 0, &regs) != 0) {
#ifdef DIAGNOSTIC
			apm_perror("set CPU idle", &regs);
#endif
		}

		/* If BIOS did not halt, halt now! */
		if (apm_flags & APM_IDLE_SLOWS) {
			__asm volatile("sti;hlt");
		}
		call_apm_idle = curcpu()->ci_schedstate.spc_cp_time[CP_IDLE];
	} else {
		__asm volatile("sti;hlt");
	}
}

void
apm_set_ver(struct apm_softc *self)
{
	struct apmregs regs;
	int rv = 0;

	bzero(&regs, sizeof(regs));
	regs.cx = APM_VERSION;

	if (APM_MAJOR(apm_flags) == 1 && APM_MINOR(apm_flags) == 2 &&
	    (rv = apmcall(APM_DRIVER_VERSION, APM_DEV_APM_BIOS, &regs)) == 0) {
		apm_majver = APM_CONN_MAJOR(&regs);
		apm_minver = APM_CONN_MINOR(&regs);
	} else {
#ifdef APMDEBUG
		if (rv)
			apm_perror("set version 1.2", &regs);
#endif
		/* try downgrading to 1.1 */
		bzero(&regs, sizeof(regs));
		regs.cx = 0x0101;

		if (apmcall(APM_DRIVER_VERSION, APM_DEV_APM_BIOS, &regs) == 0) {
			apm_majver = 1;
			apm_minver = 1;
		} else {
#ifdef APMDEBUG
			apm_perror("set version 1.1", &regs);
#endif
			/* stay w/ flags then */
			apm_majver = APM_MAJOR(apm_flags);
			apm_minver = APM_MINOR(apm_flags);

			/* fix version for some endianess-challenged compaqs */
			if (!apm_majver) {
				apm_majver = 1;
				apm_minver = 0;
			}
		}
	}
	printf(": Power Management spec V%d.%d", apm_majver, apm_minver);
#ifdef DIAGNOSTIC
	if (apm_flags & APM_IDLE_SLOWS)
		printf(" (slowidle)");
	if (apm_flags & APM_BIOS_PM_DISABLED)
		printf(" (BIOS management disabled)");
	if (apm_flags & APM_BIOS_PM_DISENGAGED)
		printf(" (BIOS managing devices)");
#endif
	printf("\n");
}

void
apm_disconnect(struct apm_softc *sc)
{
	struct apmregs regs;

	bzero(&regs, sizeof(regs));
	if (apmcall(APM_SYSTEM_DEFAULTS,
	    (apm_minver == 1 ? APM_DEV_ALLDEVS : APM_DEFAULTS_ALL), &regs))
		apm_perror("system defaults failed", &regs);

	if (apmcall(APM_DISCONNECT, APM_DEV_APM_BIOS, &regs))
		apm_perror("disconnect failed", &regs);
	else
		printf("%s: disconnected\n", sc->sc_dev.dv_xname);
	apm_flags |= APM_BIOS_PM_DISABLED;
}

int
apmprobe(struct device *parent, void *match, void *aux)
{
	struct bios_attach_args *ba = aux;
	bios_apminfo_t *ap = ba->ba_apmp;
	bus_space_handle_t ch, dh;

	if (apm_cd.cd_ndevs || strcmp(ba->ba_name, "apm") ||
	    !(ap->apm_detail & APM_32BIT_SUPPORTED))
		return 0;

	/* addresses check
	   since pc* console and vga* probes much later
	   we cannot check for video memory being mapped
	   for apm stuff w/ bus_space_map() */
	if (ap->apm_code_len == 0 ||
	    (ap->apm_code32_base < IOM_BEGIN &&
	     ap->apm_code32_base + ap->apm_code_len > IOM_BEGIN) ||
	    (ap->apm_code16_base < IOM_BEGIN &&
	     ap->apm_code16_base + ap->apm_code16_len > IOM_BEGIN) ||
	    (ap->apm_data_base < IOM_BEGIN &&
	     ap->apm_data_base + ap->apm_data_len > IOM_BEGIN))
		return 0;

	if (bus_space_map(ba->ba_memt, ap->apm_code32_base,
	    ap->apm_code_len, 1, &ch) != 0) {
		DPRINTF(("apm0: can't map code\n"));
		return 0;
	}
	bus_space_unmap(ba->ba_memt, ch, ap->apm_code_len);

	if (bus_space_map(ba->ba_memt, ap->apm_data_base,
	    ap->apm_data_len, 1, &dh) != 0) {
		DPRINTF(("apm0: can't map data\n"));
		return 0;
	}
	bus_space_unmap(ba->ba_memt, dh, ap->apm_data_len);
	return 1;
}

void
apmattach(struct device *parent, struct device *self, void *aux)
{
	struct bios_attach_args *ba = aux;
	bios_apminfo_t *ap = ba->ba_apmp;
	struct apm_softc *sc = (void *)self;
	struct apmregs regs;
	u_int cbase, clen, l;
	bus_space_handle_t ch16, ch32, dh;

	apm_flags = ap->apm_detail;
	/*
	 * set up GDT descriptors for APM
	 */
	if (apm_flags & APM_32BIT_SUPPORTED) {

		/* truncate segments' limits to a page */
		ap->apm_code_len -= (ap->apm_code32_base +
		    ap->apm_code_len + 1) & 0xfff;
		ap->apm_code16_len -= (ap->apm_code16_base +
		    ap->apm_code16_len + 1) & 0xfff;
		ap->apm_data_len -= (ap->apm_data_base +
		    ap->apm_data_len + 1) & 0xfff;

		/* adjust version */
		if ((sc->sc_dev.dv_cfdata->cf_flags & APM_VERMASK) &&
		    (apm_flags & APM_VERMASK) !=
		    (sc->sc_dev.dv_cfdata->cf_flags & APM_VERMASK))
			apm_flags = (apm_flags & ~APM_VERMASK) |
			    (sc->sc_dev.dv_cfdata->cf_flags & APM_VERMASK);
		if (sc->sc_dev.dv_cfdata->cf_flags & APM_NOCLI) {
			extern int apm_cli; /* from apmcall.S */
			apm_cli = 0;
		}
		if (sc->sc_dev.dv_cfdata->cf_flags & APM_BEBATT)
			sc->be_batt = 1;
		apm_ep.seg = GSEL(GAPM32CODE_SEL,SEL_KPL);
		apm_ep.entry = ap->apm_entry;
		cbase = min(ap->apm_code32_base, ap->apm_code16_base);
		clen = max(ap->apm_code32_base + ap->apm_code_len,
			   ap->apm_code16_base + ap->apm_code16_len) - cbase;
		if ((cbase <= ap->apm_data_base &&
		     cbase + clen >= ap->apm_data_base) ||
		    (ap->apm_data_base <= cbase &&
		     ap->apm_data_base + ap->apm_data_len >= cbase)) {
			l = max(ap->apm_data_base + ap->apm_data_len + 1,
				cbase + clen + 1) -
			    min(ap->apm_data_base, cbase);
			bus_space_map(ba->ba_memt,
				min(ap->apm_data_base, cbase),
				l, 1, &dh);
			ch16 = dh;
			if (ap->apm_data_base < cbase)
				ch16 += cbase - ap->apm_data_base;
			else
				dh += ap->apm_data_base - cbase;
		} else {

			bus_space_map(ba->ba_memt, cbase, clen + 1, 1, &ch16);
			bus_space_map(ba->ba_memt, ap->apm_data_base,
			    ap->apm_data_len + 1, 1, &dh);
		}
		ch32 = ch16;
		if (ap->apm_code16_base == cbase)
			ch32 += ap->apm_code32_base - cbase;
		else
			ch16 += ap->apm_code16_base - cbase;

		setgdt(GAPM32CODE_SEL, (void *)ch32, ap->apm_code_len,
		    SDT_MEMERA, SEL_KPL, 1, 0);
		setgdt(GAPM16CODE_SEL, (void *)ch16, ap->apm_code16_len,
		    SDT_MEMERA, SEL_KPL, 0, 0);
		setgdt(GAPMDATA_SEL, (void *)dh, ap->apm_data_len, SDT_MEMRWA,
		    SEL_KPL, 1, 0);
		DPRINTF((": flags %x code 32:%x/%lx[%x] 16:%x/%lx[%x] "
		    "data %x/%lx/%x ep %x (%x:%lx)\n%s", apm_flags,
		    ap->apm_code32_base, ch32, ap->apm_code_len,
		    ap->apm_code16_base, ch16, ap->apm_code16_len,
		    ap->apm_data_base, dh, ap->apm_data_len,
		    ap->apm_entry, apm_ep.seg, ap->apm_entry+ch32,
		    sc->sc_dev.dv_xname));

		apm_set_ver(sc);

		if (apm_flags & APM_BIOS_PM_DISABLED)
			apm_powmgt_enable(1);

		/* Engage cooperative power management on all devices (v1.1) */
		apm_powmgt_engage(1, APM_DEV_ALLDEVS);

		bzero(&regs, sizeof(regs));
		if (apm_get_powstat(&regs) != 0)
			apm_perror("get power status", &regs);
		apm_cpu_busy();

		rw_init(&sc->sc_lock, "apmlk");

		/*
		 * Do a check once, ignoring any errors. This avoids
		 * gratuitous APM disconnects on laptops where the first
		 * event in the queue (after a boot) is non-recognizable.
		 * The IBM ThinkPad 770Z is one of those.
		 */
		apm_periodic_check(sc);

		if (apm_periodic_check(sc) == -1) {
			apm_disconnect(sc);

			/* Failed, nuke APM idle loop */
			cpu_idle_enter_fcn = NULL;
			cpu_idle_cycle_fcn = NULL;
			cpu_idle_leave_fcn = NULL;
		} else {
			kthread_create_deferred(apm_thread_create, sc);

			/* Setup APM idle loop */
			if (apm_flags & APM_IDLE_SLOWS) {
				cpu_idle_enter_fcn = apm_cpu_slow;
				cpu_idle_cycle_fcn = NULL;
				cpu_idle_leave_fcn = apm_cpu_busy;
			} else {
				cpu_idle_enter_fcn = NULL;
				cpu_idle_cycle_fcn = apm_cpu_idle;
				cpu_idle_leave_fcn = NULL;
			}

			/* All is well, let the rest of the world know */
			acpiapm_open = apmopen;
			acpiapm_close = apmclose;
			acpiapm_ioctl = apmioctl;
			acpiapm_kqfilter = apmkqfilter;
			apm_attached = 1;
		}
	} else {
		setgdt(GAPM32CODE_SEL, NULL, 0, 0, 0, 0, 0);
		setgdt(GAPM16CODE_SEL, NULL, 0, 0, 0, 0, 0);
		setgdt(GAPMDATA_SEL, NULL, 0, 0, 0, 0, 0);
	}
}

void
apm_thread_create(void *v)
{
	struct apm_softc *sc = v;

#ifdef MULTIPROCESSOR
	if (ncpus > 1) {
		apm_disconnect(sc);

		/* Nuke APM idle loop */
		cpu_idle_enter_fcn = NULL;
		cpu_idle_cycle_fcn = NULL;
		cpu_idle_leave_fcn = NULL;

		return;
	}
#endif

	if (kthread_create(apm_thread, sc, &sc->sc_thread,
	    sc->sc_dev.dv_xname)) {
		apm_disconnect(sc);
		printf("%s: failed to create kernel thread, disabled",
		    sc->sc_dev.dv_xname);

		/* Nuke APM idle loop */
		cpu_idle_enter_fcn = NULL;
		cpu_idle_cycle_fcn = NULL;
		cpu_idle_leave_fcn = NULL;
	}
}

void
apm_thread(void *v)
{
	struct apm_softc *sc = v;

	for (;;) {
		rw_enter_write(&sc->sc_lock);
		(void) apm_periodic_check(sc);
		rw_exit_write(&sc->sc_lock);
		tsleep(&lbolt, PWAIT, "apmev", 0);
	}
}

int
apmopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct apm_softc *sc;
	int error = 0;

	/* apm0 only */
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
		return ENXIO;

	if (apm_flags & APM_BIOS_PM_DISABLED)
		return ENXIO;

	DPRINTF(("apmopen: dev %d pid %d flag %x mode %x\n",
	    APMDEV(dev), p->p_p->ps_pid, flag, mode));

	rw_enter_write(&sc->sc_lock);
	switch (APMDEV(dev)) {
	case APMDEV_CTL:
		if (!(flag & FWRITE)) {
			error = EINVAL;
			break;
		}
		if (sc->sc_flags & SCFLAG_OWRITE) {
			error = EBUSY;
			break;
		}
		sc->sc_flags |= SCFLAG_OWRITE;
		break;
	case APMDEV_NORMAL:
		if (!(flag & FREAD) || (flag & FWRITE)) {
			error = EINVAL;
			break;
		}
		sc->sc_flags |= SCFLAG_OREAD;
		break;
	default:
		error = ENXIO;
		break;
	}
	rw_exit_write(&sc->sc_lock);
	return error;
}

int
apmclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct apm_softc *sc;

	/* apm0 only */
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
		return ENXIO;

	DPRINTF(("apmclose: pid %d flag %x mode %x\n",
	    p->p_p->ps_pid, flag, mode));

	rw_enter_write(&sc->sc_lock);
	switch (APMDEV(dev)) {
	case APMDEV_CTL:
		sc->sc_flags &= ~SCFLAG_OWRITE;
		break;
	case APMDEV_NORMAL:
		sc->sc_flags &= ~SCFLAG_OREAD;
		break;
	}
	rw_exit_write(&sc->sc_lock);
	return 0;
}

int
apmioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct apm_softc *sc;
	struct apmregs regs;
	int error = 0;

	/* apm0 only */
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
		return ENXIO;

	rw_enter_write(&sc->sc_lock);
	switch (cmd) {
		/* some ioctl names from linux */
	case APM_IOC_STANDBY:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else
			apm_userstandbys++;
		break;
	case APM_IOC_SUSPEND:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else
			apm_suspends++;
		break;
	case APM_IOC_PRN_CTL:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else {
			int flag = *(int *)data;
			DPRINTF(( "APM_IOC_PRN_CTL: %d\n", flag ));
			switch (flag) {
			case APM_PRINT_ON:	/* enable printing */
				sc->sc_flags &= ~SCFLAG_PRINT;
				break;
			case APM_PRINT_OFF: /* disable printing */
				sc->sc_flags &= ~SCFLAG_PRINT;
				sc->sc_flags |= SCFLAG_NOPRINT;
				break;
			case APM_PRINT_PCT: /* disable some printing */
				sc->sc_flags &= ~SCFLAG_PRINT;
				sc->sc_flags |= SCFLAG_PCTPRINT;
				break;
			default:
				error = EINVAL;
				break;
			}
		}
		break;
	case APM_IOC_DEV_CTL:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else {
			struct apm_ctl *actl = (struct apm_ctl *)data;

			bzero(&regs, sizeof(regs));
			if (!apmcall(APM_GET_POWER_STATE, actl->dev, &regs))
				printf("%s: dev %04x state %04x\n",
				    sc->sc_dev.dv_xname, dev, regs.cx);

			error = apm_set_powstate(actl->dev, actl->mode);
		}
		break;
	case APM_IOC_GETPOWER:
		if (apm_get_powstat(&regs) == 0) {
			struct apm_power_info *powerp =
			    (struct apm_power_info *)data;

			bzero(powerp, sizeof(*powerp));
			if (BATT_LIFE(&regs) != APM_BATT_LIFE_UNKNOWN)
				powerp->battery_life = BATT_LIFE(&regs);
			powerp->ac_state = AC_STATE(&regs);
			switch (apm_minver) {
			case 0:
				if (!(BATT_FLAGS(&regs) & APM_BATT_FLAG_NOBATTERY))
					powerp->battery_state = BATT_STATE(&regs);
				break;
			case 1:
			default:
				if (BATT_FLAGS(&regs) & APM_BATT_FLAG_HIGH)
					powerp->battery_state = APM_BATT_HIGH;
				else if (BATT_FLAGS(&regs) & APM_BATT_FLAG_LOW)
					powerp->battery_state = APM_BATT_LOW;
				else if (BATT_FLAGS(&regs) & APM_BATT_FLAG_CRITICAL)
					powerp->battery_state = APM_BATT_CRITICAL;
				else if (BATT_FLAGS(&regs) & APM_BATT_FLAG_CHARGING)
					powerp->battery_state = APM_BATT_CHARGING;
				else if (BATT_FLAGS(&regs) & APM_BATT_FLAG_NOBATTERY)
					powerp->battery_state = APM_BATTERY_ABSENT;
				else
					powerp->battery_state = APM_BATT_UNKNOWN;
				if (BATT_REM_VALID(&regs)) {
					powerp->minutes_left = BATT_REMAINING(&regs);
					if (sc->be_batt)
						powerp->minutes_left =
						    swap16(powerp->minutes_left);
				}
			}
		} else {
			apm_perror("ioctl get power status", &regs);
			error = EIO;
		}
		break;
	case APM_IOC_STANDBY_REQ:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		/* only fails if no one cares. apmd at least should */
		else if (apm_record_event(sc, APM_USER_STANDBY_REQ))
			error = EINVAL; /* ? */
		break;
	case APM_IOC_SUSPEND_REQ:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		/* only fails if no one cares. apmd at least should */
		else if (apm_record_event(sc, APM_USER_SUSPEND_REQ))
			error = EINVAL; /* ? */
		break;
	default:
		error = ENOTTY;
	}

	rw_exit_write(&sc->sc_lock);
	return error;
}

void
filt_apmrdetach(struct knote *kn)
{
	struct apm_softc *sc = (struct apm_softc *)kn->kn_hook;

	rw_enter_write(&sc->sc_lock);
	SLIST_REMOVE(&sc->sc_note, kn, knote, kn_selnext);
	rw_exit_write(&sc->sc_lock);
}

int
filt_apmread(struct knote *kn, long hint)
{
	/* XXX weird kqueue_scan() semantics */
	if (hint && !kn->kn_data)
		kn->kn_data = (int)hint;
	return (1);
}

int
apmkqfilter(dev_t dev, struct knote *kn)
{
	struct apm_softc *sc;

	/* apm0 only */
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
		return ENXIO;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		kn->kn_fop = &apmread_filtops;
		break;
	default:
		return (EINVAL);
	}

	kn->kn_hook = (caddr_t)sc;

	rw_enter_write(&sc->sc_lock);
	SLIST_INSERT_HEAD(&sc->sc_note, kn, kn_selnext);
	rw_exit_write(&sc->sc_lock);
	return (0);
}
@


1.115
log
@Write the system time back to the RTC every 30 minutes.
This fixes the problem that long-running machines which were not
shut down properly would reboot with a badly offset system time.

hints and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.114 2015/09/28 18:36:36 deraadt Exp $	*/
d936 1
a936 1
	    APMDEV(dev), p->p_pid, flag, mode));
d976 2
a977 1
	DPRINTF(("apmclose: pid %d flag %x mode %x\n", p->p_pid, flag, mode));
@


1.114
log
@In low-level suspend routines, set cold=2.  In tsleep(), use this to
spit out a ddb trace to console.  This should allow us to find suspend
or resume routines which break the rules.  It depends on the console
output function being non-sleeping.... but that's another codepath which
should try to be safe when cold is set.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.113 2015/02/07 01:19:40 deraadt Exp $	*/
d251 1
d288 1
@


1.113
log
@New framework that allows hibernate to pass in entropy from it's fresh
boot.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.112 2014/12/18 17:02:35 deraadt Exp $	*/
d256 1
d279 1
@


1.112
log
@perform cpu setperf at same position in sequence as acpi.c
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.110 2014/10/17 15:35:31 deraadt Exp $	*/
d281 1
a281 1
	resume_randomness();		/* force RNG upper level reseed */
@


1.111
log
@suspend & resume RNG subsystem
@
text
@a281 3
	/* restore hw.setperf */
	if (cpu_setperf != NULL)
		cpu_setperf(perflevel);
d289 4
@


1.110
log
@revert previous.  It isn't just i386 which cares about the setperf
hiding, it is a lot of other systems too.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.108 2014/10/01 20:49:50 mlarkin Exp $	*/
d53 1
d257 1
d281 1
@


1.109
log
@In the new world order, setperf does not exist on ramdisks.
@
text
@a243 1
#ifndef SMALL_KERNEL
a244 1
#endif
a278 1
#ifndef SMALL_KERNEL
a281 1
#endif
@


1.108
log
@

Fix some incorrect format specifiers in a debug printf.

Reported to tech@@ by THEvoid at openmailbox dot org

ok doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.107 2014/09/19 20:02:25 kettenis Exp $	*/
d244 1
d246 1
d281 1
d285 1
@


1.107
log
@Use config_suspend_all(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.106 2014/09/14 14:17:23 jsg Exp $	*/
d803 2
a804 2
		DPRINTF((": flags %x code 32:%x/%x[%x] 16:%x/%x[%x] "
		    "data %x/%x/%x ep %x (%x:%x)\n%s", apm_flags,
@


1.106
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.105 2014/03/31 12:11:42 mpi Exp $	*/
a243 1
	struct device *mainbus = device_mainbus();
d250 1
a250 1
	config_suspend(mainbus, DVACT_QUIESCE);
d255 1
a255 1
	config_suspend(mainbus, DVACT_SUSPEND);
d262 1
a262 1
	config_suspend(mainbus, DVACT_POWERDOWN);
d275 1
a275 1
	config_suspend(mainbus, DVACT_RESUME);
d284 1
a284 1
	config_suspend(mainbus, DVACT_WAKEUP);
@


1.105
log
@Change the order of operations during a suspend/resume cycle and
call bufq_quiesce() after executing the DVACT_QUIESCE handlers.

This should be safe since no disk nor controller drivers have such
handler but it will allow us to detach sd(4) devices attached to a
USB bus.

Another benefit pointed out by kettenis@@ is that drivers that need
to read a firmware from the disk should be able to do it at resume
time in a DVACT_WAKEUP handler.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.104 2014/03/29 18:09:29 guenther Exp $	*/
a44 1
#include <sys/proc.h>
@


1.104
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.103 2014/03/13 03:52:55 dlg Exp $	*/
d252 1
a253 1
	config_suspend(mainbus, DVACT_QUIESCE);
@


1.103
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.102 2013/12/06 21:03:05 deraadt Exp $	*/
d614 1
a614 1
			__asm __volatile("sti;hlt");
d618 1
a618 1
		__asm __volatile("sti;hlt");
@


1.102
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.101 2013/11/18 20:21:51 deraadt Exp $	*/
d245 1
d253 1
a253 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_QUIESCE);
d257 1
a257 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_SUSPEND);
d264 1
a264 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
d277 1
a277 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_RESUME);
d286 1
a286 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_WAKEUP);
@


1.101
log
@simplify kthread_create(). no more stdarg
ok matthew guenther mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.100 2012/10/17 22:49:27 deraadt Exp $	*/
d284 3
@


1.100
log
@Document the 'boothowto hack' used to flag to (a few) DVACT_POWERDOWN
handlers how hard they should hit the hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.100 2012/10/17 22:43:48 deraadt Exp $	*/
d885 1
a885 1
	if (kthread_create(apm_thread, sc, &sc->sc_thread, "%s",
@


1.99
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.98 2011/07/02 22:20:07 nicm Exp $	*/
d258 4
@


1.98
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.97 2011/06/29 16:18:04 tedu Exp $	*/
d52 1
d257 4
@


1.97
log
@stop printing in apm, acpi doesn't do this.  remove APM_NOPRINT option.
kind of ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.96 2011/01/13 23:19:36 deraadt Exp $	*/
d1133 1
a1133 1
		return (1);
@


1.96
log
@if the BIOS tells us to suspend at the same time that we notice a lid
event, don't suspend twice.
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.95 2011/01/04 23:08:56 deraadt Exp $	*/
a164 1
void apm_power_print(struct apm_softc *, struct apmregs *);
a241 77
apm_power_print(struct apm_softc *sc, struct apmregs *regs)
{
#if !defined(APM_NOPRINT)
	sc->batt_life = BATT_LIFE(regs);
	if (BATT_LIFE(regs) != APM_BATT_LIFE_UNKNOWN) {
		printf("%s: battery life expectancy %d%%\n",
		    sc->sc_dev.dv_xname,
		    BATT_LIFE(regs));
	}
	printf("%s: AC ", sc->sc_dev.dv_xname);
	switch (AC_STATE(regs)) {
	case APM_AC_OFF:
		printf("off,");
		break;
	case APM_AC_ON:
		printf("on,");
		break;
	case APM_AC_BACKUP:
		printf("backup power,");
		break;
	default:
	case APM_AC_UNKNOWN:
		printf("unknown,");
		break;
	}
	if (apm_minver == 0) {
		printf(" battery is ");
		switch (BATT_STATE(regs)) {
		case APM_BATT_HIGH:
			printf("high");
			break;
		case APM_BATT_LOW:
			printf("low");
			break;
		case APM_BATT_CRITICAL:
			printf("CRITICAL");
			break;
		case APM_BATT_CHARGING:
			printf("charging");
			break;
		case APM_BATT_UNKNOWN:
			printf("unknown");
			break;
		default:
			printf("undecoded (%x)", BATT_STATE(regs));
			break;
		}
	} else if (apm_minver >= 1) {
		if (BATT_FLAGS(regs) & APM_BATT_FLAG_NOBATTERY)
			printf(" no battery");
		else {
			printf(" battery charge ");
			if (BATT_FLAGS(regs) & APM_BATT_FLAG_HIGH)
				printf("high");
			else if (BATT_FLAGS(regs) & APM_BATT_FLAG_LOW)
				printf("low");
			else if (BATT_FLAGS(regs) & APM_BATT_FLAG_CRITICAL)
				printf("critical");
			else
				printf("unknown");
			if (BATT_FLAGS(regs) & APM_BATT_FLAG_CHARGING)
				printf(", charging");
			if (BATT_REM_VALID(regs)) {
				int life = BATT_REMAINING(regs);
				if (sc->be_batt)
					life = swap16(life);
				printf(", estimated %d:%02d hours",
				    life / 60, life % 60);
			}
		}
	}

	printf("\n");
#endif
}

void
d368 1
a368 7
		if (apm_get_powstat(&nregs) == 0 &&
		    BATT_LIFE(&nregs) != APM_BATT_LIFE_UNKNOWN &&
		    BATT_LIFE(&nregs) < cpu_apmwarn &&
		    (sc->sc_flags & SCFLAG_PRINT) != SCFLAG_NOPRINT &&
		    ((sc->sc_flags & SCFLAG_PRINT) != SCFLAG_PCTPRINT ||
		     sc->batt_life != BATT_LIFE(&nregs)))
			apm_power_print(sc, &nregs);
d809 1
a809 3
		if (apm_get_powstat(&regs) == 0)
			apm_power_print(sc, &regs);
		else
@


1.95
log
@Support machdep.lidsuspend support in apm(4) land, at least on thinkpads
which have aps(4).  You can now turn off the BIOS option for lid suspends,
and control it with sysctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.94 2010/09/09 04:13:15 deraadt Exp $	*/
d528 3
@


1.94
log
@The resume powerhooks were always in the wrong place. Then when replaced
by the device-tree activate walk it even worse since we were doing so much
more work.  apm_suspend() could return into the event handler and thus
tsleep() -- all this while we are supposedly trying to maintain splhigh
because our DVACT_SUSPEND mechanism has temporarily totally wrecked the
machine.
Move the hardware restoration code (DVACT_RESUME + other goo) to the same
function, and recognize that apm_resume() is just a boring event handler
which punts the event to userland.
ok oga
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.91 2010/09/06 15:42:18 deraadt Exp $	*/
d136 1
d535 6
@


1.93
log
@merge apm_standby() into apm_suspend()
vague ok from kettenis, but it is just mechanical
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.92 2010/09/08 21:18:15 deraadt Exp $	*/
a317 2
int apm_saved_spl;

d321 3
d330 1
a330 1
	apm_saved_spl = splhigh();
d334 3
a336 2
	(void)apm_set_powstate(APM_DEV_ALLDEVS, state);
}
d338 1
a338 12
void
apm_resume(struct apm_softc *sc, struct apmregs *regs)
{
	extern int perflevel;

	apm_resumes = APM_RESUME_HOLDOFF;

	/* Some machines resume with interrupts on */
	(void) splhigh();
	disable_intr();

	/* they say that some machines may require reinitializing the clocks */
a341 1

a342 1
	/* lower bit in cx means pccard was powered down */
a344 1

d346 1
a346 6
	splx(apm_saved_spl);

	apm_record_event(sc, regs->bx);

	/* acknowledge any rtc interrupt we may have missed */
	rtcdrain(NULL);
d355 11
@


1.92
log
@No need for vfs_syncwait() in a bufq_quiesce() world
ok thib kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.91 2010/09/06 15:42:18 deraadt Exp $	*/
d179 1
a179 2
void	apm_standby(void);
void	apm_suspend(void);
d321 1
a321 1
apm_suspend()
d333 1
a333 17
	(void)apm_set_powstate(APM_DEV_ALLDEVS, APM_SYS_SUSPEND);
}

void
apm_standby()
{
#if NWSDISPLAY > 0
	wsdisplay_suspend();
#endif /* NWSDISPLAY > 0 */
	bufq_quiesce();
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_QUIESCE);

	apm_saved_spl = splhigh();
	disable_intr();
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_SUSPEND);

	(void)apm_set_powstate(APM_DEV_ALLDEVS, APM_SYS_STANDBY);
d480 1
a480 1
		apm_suspend();
d542 1
a542 1
		apm_suspend();
d545 1
a545 1
		apm_standby();
@


1.91
log
@now that the drm issue is resolved, switch to using ca_activate calls
instead of powerhooks.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.90 2010/08/27 19:10:59 deraadt Exp $	*/
a52 1
#include <sys/mount.h>	/* for vfs_syncwait() proto */
a333 3
	if (cold)
		vfs_syncwait(0);

a348 3

	if (cold)
		vfs_syncwait(0);
@


1.90
log
@Run powerhooks with interrupts blocked.  This requires a bit of a song and
dance since some laptops unsuspend out of apm with interrupts enabled?!
That causes problems with shared interrupts... but also it would be best
if we treat powerhook functions (now backed by activate functions) the same as
acpi treats them, and it means that the powerhook wrappers don't need to do
their own spl protection.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.89 2010/08/27 04:09:11 deraadt Exp $	*/
d329 1
d333 1
a333 1
	dopowerhooks(PWR_SUSPEND);
d348 1
d352 1
a352 1
	dopowerhooks(PWR_SUSPEND);
d368 1
d379 1
a379 1
	dopowerhooks(PWR_RESUME);
@


1.89
log
@kill PWR_STANDBY (apm can use PWR_SUSPEND instead).  While here, renumber
PWR_{SUSPEND,RESUME} so that they match the values of DAVCT_{SUSPEND,RESUME}
so that we can eventually (many more steps...) kill the powerhook garbage
and use the activate mechanism.
no objections
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.88 2010/07/25 21:43:35 deraadt Exp $	*/
d320 2
d330 2
d348 2
d365 3
d375 1
d377 4
@


1.88
log
@in the clock drivers, seperate the soft-state and hard-state which was
all jumbled up in the same functions. the rtc (mc chip) and clock (i8243)
startup was also mixed up.  they the soft state and hardware state can
be started in the right order, and it is easy to restart just the
neccessary parts upon resume.  tested in numerous cases:
(apic, pic) * (GENERIC.MP, GENERIC) * (mp, non-mp) * (i386, amd64)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.87 2010/07/20 12:23:00 deraadt Exp $	*/
d344 1
a344 1
	dopowerhooks(PWR_STANDBY);
@


1.87
log
@also use bufq_quiesce() when suspending, and bufq_restart() when resuming,
which will result in more stable filesystems during suspend
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.86 2010/06/26 23:24:43 guenther Exp $	*/
d359 4
a362 2
	/* they say that some machines may require reinitializing the clock */
	initrtclock();
@


1.86
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.85 2010/03/30 17:40:55 oga Exp $	*/
d51 1
d326 2
d342 2
d373 1
@


1.85
log
@Prevent the apmd/x races for good.

When we hit suspend time, go through all wsdisplays on the system. if
they are in mode MAPPED, but not MODE_DUMBFB then if possible do a full
vt switch to a !mapped vt, and prevent switching back until resume time.
This has to be called from MD code because this involves userland
running so that X can run the vt switch signal handler. This way, any
case where we are using the "poke registers from userland" model, we
will not be on the hardware when we go down, so the kernel can actually
handle thing properly.

Tested on several acpi laptops (by kettenis@@ and ian@@), x40 (me and
beck@@ at LEAST) and zaurus (me). Maybe others, but if so I forgot who at
this time..

Idea from deraadt somewhere over the Faroe Islands (I thought of a
similar thing myself a while ago). Much prompting from him. Ok and
comments miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.84 2009/06/24 13:54:42 deraadt Exp $	*/
d46 1
a46 1
#include <sys/user.h>
@


1.84
log
@There are 3 reasons why the first block in apm_probe can fail, and in one
case it is not OK to DPRINTF, so delete that code.  Found by dhill
ok marco dhill
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.83 2009/02/26 17:19:47 oga Exp $	*/
d64 1
d70 2
d322 3
d336 3
d368 3
@


1.83
log
@Add a two new ioctls to the apm(4) interface.

APM_IOC_{SUSPEND,STANDBY}_REQ: This is to fix an issue with apm suspend
where a call to zzz suspended the machine immediately, not giving anyone
listening for apm events (other than apmd) a chance to deal with the
upcoming change. This hit X hard since the introduction of drm, since it
needs to have time to idle the 3d engine and otherwise get the device
into a recoverable state. Such things are needed until we support
modesetting in the kernel.

Now, instead of forcing a suspend, using ioctl sends out an event similar
to if you had put the lid down, giving all userland applications a
chance to reply.

tested by sthen@@ and beck@@, especial thanks to sthen for sitting there
while I tried to debug this remotely, I owe him beer.

Prompted by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.82 2008/08/16 00:26:26 krw Exp $	*/
d753 1
a753 2
	    !(ba->ba_apmp->apm_detail & APM_32BIT_SUPPORTED)) {
		DPRINTF(("%s: %x\n", ba->ba_name, ba->ba_apmp->apm_detail));
a754 1
	}
@


1.82
log
@bios_dev -> ba_name and bios_apmp -> ba_apmp in DPRINTF statements.
i386 kernels compile with BIOS_DEBUG again.

Spotted by Mathias Schmocker.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.81 2007/12/11 15:44:00 tedu Exp $	*/
d1148 14
a1161 1

@


1.81
log
@reword license to change regents to authors, and remove advertising clause.
cleared with all original authors. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.80 2007/12/05 19:17:13 deraadt Exp $	*/
d754 1
a754 1
		DPRINTF(("%s: %x\n", ba->bios_dev, ba->bios_apmp->apm_detail));
@


1.80
log
@Hang acpi(4) below bios(4) instead of mainbus(4).  This lets us move acpi(4)
before pcibios(4), and then.... if acpi(4) attaches, skip pcibios(4) since
it messes the machines up.  Fixes claudio's HP dl320 G5, and almost assuredly
others.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.79 2007/11/25 15:42:15 tedu Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d19 1
a19 1
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
d22 1
a22 1
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
@


1.79
log
@fake out the apm device to switch between apm and acpi on i386.  now
a single device node will talk to the right kernel code automatically.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.78 2007/11/03 03:37:08 weingart Exp $	*/
d753 1
a753 1
	bios_apminfo_t *ap = ba->bios_apmp;
d756 2
a757 2
	if (apm_cd.cd_ndevs || strcmp(ba->bios_dev, "apm") ||
	    !(ba->bios_apmp->apm_detail & APM_32BIT_SUPPORTED)) {
d775 1
a775 1
	if (bus_space_map(ba->bios_memt, ap->apm_code32_base,
d780 1
a780 1
	bus_space_unmap(ba->bios_memt, ch, ap->apm_code_len);
d782 1
a782 1
	if (bus_space_map(ba->bios_memt, ap->apm_data_base,
d787 1
a787 1
	bus_space_unmap(ba->bios_memt, dh, ap->apm_data_len);
d795 1
a795 1
	bios_apminfo_t *ap = ba->bios_apmp;
d839 1
a839 1
			bus_space_map(ba->bios_memt,
d849 2
a850 2
			bus_space_map(ba->bios_memt, cbase, clen + 1, 1, &ch16);
			bus_space_map(ba->bios_memt, ap->apm_data_base,
@


1.78
log
@APM switchto cleanup diff.  This uses the switchto functionality to
significantly clean up the APM idle loop things.  I actually can make
sense of what the APM idle loop is supposed to do.

Ok gwk@@, beck@@, and theo says ramdisks compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.77 2007/10/22 17:11:14 deraadt Exp $	*/
d69 1
d920 4
@


1.77
log
@remove flagsa/dobusy/doidle stuff introduced 3 years ago as a debugging aid..
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.76 2007/07/02 17:11:29 thib Exp $	*/
d87 1
a146 4
int	apm_dobusy = 0;
int	apm_doidle = 0;
int	apm_bebatt = 0;
int	apm_idle_called = 0;
d148 1
d182 1
d243 1
a243 1
apm_power_print (struct apm_softc *sc, struct apmregs *regs)
d307 1
a307 1
				if (apm_bebatt)
d612 19
d635 1
a635 5
	if (!apm_cd.cd_ndevs)	/* No APM device, punt */
		return;
	if (!apm_dobusy)
		return;
	if (!apm_idle_called)
d645 1
a645 1
		apm_idle_called = 0;
d653 1
a653 1
	static u_int64_t call_apm = 0;
a654 10
	if (!apm_cd.cd_ndevs) {	/* No APM device, wait for next interrupt */
		__asm __volatile("sti;hlt");
		return;
	}

	if (!apm_doidle) {
		__asm __volatile("sti;hlt");
		return;
	}
		
d660 1
a660 1
	if  (call_apm != curcpu()->ci_schedstate.spc_cp_time[CP_IDLE]) {
d664 1
a664 1
#ifdef APMDEBUG
d668 2
a669 2
		apm_idle_called = 1;
		/* If BIOS did halt, don't do it again! */
d673 1
a673 1
		call_apm = curcpu()->ci_schedstate.spc_cp_time[CP_IDLE];
a719 8
	if (apm_flags & APM_IDLE_SLOWS) {
		DPRINTF((" (slowidle)"));
		apm_dobusy = 1;
		apm_doidle = 1;
	} else {
		apm_dobusy = 0;
		apm_doidle = 1;
	}
d721 2
d724 1
a724 1
		printf(" (BIOS mgmt disabled)");
d825 1
a825 1
			apm_bebatt = 1;
d876 2
a877 4
		/*
		 * Engage cooperative power mgt (we get to do it)
		 * on all devices (v1.1).
		 */
d899 5
a903 1
			apm_dobusy = apm_doidle = 0;
d906 13
d936 6
a941 1
		apm_dobusy = apm_doidle = 0;
d951 5
a955 1
		apm_dobusy = apm_doidle = 0;
d1137 1
a1137 1
					if (apm_bebatt)
@


1.76
log
@replace two lockmgr lock with rwlocks.

been in snaps for a week, no objection
from deraadt@@ for putting this in.
ok tom@@ (for gdt)
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.75 2007/05/29 08:22:14 gwk Exp $	*/
a912 3
	/* XXX - To go away */
	printf("apm0: flags %x dobusy %d doidle %d\n",
	    apm_flags, apm_dobusy, apm_doidle);
@


1.75
log
@Add global variable apm_attached, machine dependant probe routine for ACPI
will check this flag durring probe, meaning that if the machine has APM
ACPI will not attach. This should remove one obstacle on the road to
enabling ACPI by default.

ok marco, dreaadt, art, krw, art
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.74 2007/03/19 09:29:33 art Exp $	*/
d48 1
a48 1
#include <sys/lock.h>
a77 3
#define	APM_LOCK(sc)	lockmgr(&(sc)->sc_lock, LK_EXCLUSIVE, NULL)
#define	APM_UNLOCK(sc)	lockmgr(&(sc)->sc_lock, LK_RELEASE, NULL)

d88 1
a88 1
	struct lock sc_lock;
d891 1
a891 1
		lockinit(&sc->sc_lock, PWAIT, "apmlk", 0, 0);
d946 1
a946 1
		APM_LOCK(sc);
d948 1
a948 1
		APM_UNLOCK(sc);
d970 1
a970 1
	APM_LOCK(sc);
d994 1
a994 1
	APM_UNLOCK(sc);
d1010 1
a1010 1
	APM_LOCK(sc);
d1019 1
a1019 1
	APM_UNLOCK(sc);
d1035 1
a1035 1
	APM_LOCK(sc);
d1133 1
a1133 1
	APM_UNLOCK(sc);
d1142 1
a1142 1
	APM_LOCK(sc);
d1144 1
a1144 1
	APM_UNLOCK(sc);
d1176 1
a1176 1
	APM_LOCK(sc);
d1178 1
a1178 1
	APM_UNLOCK(sc);
@


1.74
log
@Move i386 to timecounters. This is more or less the same code as amd64.

The "lapic" timer is ripped out since it wasn't actually a lapic timer,
but a hacked up tsc timer with some synchronization for MP. There is no
tsc timer right now since they are very unreliable on MP systems, systems
with apm, and systems that change the cpu clock. Which basically means
every modern machine out there. We're running with the i8259 timer now.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.73 2007/02/27 15:16:30 marco Exp $	*/
d153 1
d359 1
a359 1
	
d907 1
a907 1
		} else
d909 2
@


1.73
log
@call_apm should be 64 bit.

ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.72 2006/10/22 23:21:25 deraadt Exp $	*/
d354 1
a354 1
	inittodr(time.tv_sec);
d467 1
a467 1
		inittodr(time.tv_sec);
@


1.72
log
@more bits of cleanup before marco gets to play
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.71 2006/10/19 20:46:16 deraadt Exp $	*/
d641 1
a641 1
	static int call_apm = 0;
@


1.71
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.70 2006/07/07 04:06:11 gwk Exp $	*/
d97 2
a98 2
int apmprobe(struct device *, void *, void *);
void apmattach(struct device *, struct device *, void *);
d104 2
a105 2
void filt_apmrdetach(struct knote *kn);
int filt_apmread(struct knote *kn, long hint);
d107 3
a109 2
struct filterops apmread_filtops =
	{ 1, NULL, filt_apmrdetach, filt_apmread};
d112 4
a115 3
   value can be changed using sysctl(8), value machdep.apmwarn.
   Setting it to zero kills all warnings */
int cpu_apmwarn = 10;
d387 1
a387 1
	switch(regs->bx) {
@


1.70
log
@ANSIfy
ok deraadt@@, brad@@, toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.69 2006/05/11 13:21:11 mickey Exp $	*/
d135 16
a150 16
int apm_standbys;
int apm_userstandbys;
int apm_suspends;
int apm_resumes;
int apm_battlow;
int apm_evindex;
int apm_error;
int apm_op_inprog;

u_int apm_flags;
u_char apm_majver;
u_char apm_minver;
int apm_dobusy = 0;
int apm_doidle = 0;
int apm_bebatt = 0;
int apm_idle_called = 0;
d189 1
d198 1
a198 1
	switch(code) {
a375 1

a503 1

d550 1
d562 1
d578 1
d597 1
d737 1
d757 1
a757 2
	if (apm_cd.cd_ndevs ||
	    strcmp(ba->bios_dev, "apm") ||
a788 1

d867 1
a867 1
		       "data %x/%x/%x ep %x (%x:%x)\n%s", apm_flags,
d885 1
a885 1
		if (apm_get_powstat(&regs) == 0) {
d887 1
a887 1
		} else
d913 1
a913 1
		apm_flags, apm_dobusy, apm_doidle);
d929 2
a930 2
	if (kthread_create(apm_thread, sc, &sc->sc_thread,
	    "%s", sc->sc_dev.dv_xname)) {
a1150 1

a1176 1

@


1.69
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.68 2006/04/15 20:43:36 mickey Exp $	*/
d195 1
a195 2
apm_err_translate(code)
	int code;
d232 1
a232 3
apm_perror(str, regs)
	const char *str;
	struct apmregs *regs;
d243 1
a243 3
apm_power_print (sc, regs)
	struct apm_softc *sc;
	struct apmregs *regs;
d342 1
a342 3
apm_resume(sc, regs)
	struct apm_softc *sc;
	struct apmregs *regs;
d365 1
a365 3
apm_record_event(sc, type)
	struct apm_softc *sc;
	u_int type;
d380 1
a380 3
apm_handle_event(sc, regs)
	struct apm_softc *sc;
	struct apmregs *regs;
d509 1
a509 2
apm_periodic_check(sc)
	struct apm_softc *sc;
d548 1
a548 2
apm_powmgt_enable(onoff)
	int onoff;
d559 1
a559 3
apm_powmgt_engage(onoff, dev)
	int onoff;
	u_int dev;
d574 1
a574 3
apm_devpowmgt_enable(onoff, dev)
	int onoff;
	u_int dev;
d592 1
a592 2
apm_set_powstate(dev, state)
	u_int dev, state;
d673 1
a673 2
apm_set_ver(self)
	struct apm_softc *self;
d731 1
a731 2
apm_disconnect(sc)
	struct apm_softc *sc;
d747 1
a747 3
apmprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d791 1
a791 3
apmattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d915 1
a915 2
apm_thread_create(v)
	void *v;
d937 1
a937 2
apm_thread(v)
	void *v;
d950 1
a950 4
apmopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d995 1
a995 4
apmclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d1020 1
a1020 6
apmioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d1134 1
a1134 2
filt_apmrdetach(kn)
	struct knote *kn;
d1144 1
a1144 3
filt_apmread(kn, hint)
	struct knote *kn;
	long hint;
d1154 1
a1154 3
apmkqfilter(dev, kn)
	dev_t dev;
	struct knote *kn;
@


1.68
log
@fail opening apm device if apm is disconnected; deradt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.67 2005/11/19 02:18:00 pedro Exp $	*/
d666 2
a667 2
	/* 
	 * We call the bios APM_IDLE routine here only when we 
@


1.67
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.66 2005/06/16 16:49:04 beck Exp $	*/
d763 1
d987 3
@


1.66
log
@fix initialization of apm_dobusy and apm_doidle to be off by default until
apm attaches and we know what the correct state should be, also ensure that
they are set to off if the kernel apm thread fails to create.

ok toby@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.65 2005/05/24 08:54:14 marco Exp $	*/
d78 2
a79 2
#define	APM_LOCK(sc)	lockmgr(&(sc)->sc_lock, LK_EXCLUSIVE, NULL, curproc)
#define	APM_UNLOCK(sc)	lockmgr(&(sc)->sc_lock, LK_RELEASE, NULL, curproc)
@


1.65
log
@hlt hlt is not a good idea.  Rework APM to do what the spec actually says.  Run actual BIOS calls whenever we are actually idle. Tovarisch!

ok deraadt@@ toby@@ beck@@ weingart@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.64 2005/04/29 01:12:27 deraadt Exp $	*/
d147 2
a148 2
int apm_dobusy = 1;
int apm_doidle = 1;
d734 3
a736 1
	} else
d738 2
d956 1
@


1.64
log
@quiet apm
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.63 2004/06/13 21:49:15 niklas Exp $	*/
d150 1
d628 1
a628 1
apm_cpu_busy()
d631 6
a636 1
	if (!apm_cd.cd_ndevs || !apm_doidle)
a637 3
	bzero(&regs, sizeof(regs));
	if ((apm_flags & APM_IDLE_SLOWS) &&
		apmcall(APM_CPU_BUSY, 0, &regs) != 0) {
d639 3
d643 1
a643 1
		apm_perror("set CPU busy", &regs);
d645 2
d651 1
a651 1
apm_cpu_idle()
d654 4
a657 1
	if (!apm_cd.cd_ndevs || !apm_doidle)
d659 1
d661 9
a669 2
	bzero(&regs, sizeof(regs));
	if (apmcall(APM_CPU_IDLE, 0, &regs) != 0) {
d671 4
d676 1
a676 1
		apm_perror("set CPU idle", &regs);
d678 9
d928 3
@


1.63
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d652 1
a652 1
#ifdef DIAGNOSTIC
@


1.63.4.1
log
@MFC:
Fixes by marco@@, niklas@@, mickey@@ and beck@@

rev 1.87
one last optimization, removing a jump, mostly by
toby, committed so art will stop yelling at me to
avoid conflicts...

rev 1.86
repair whichqs race by disabling ints in between check and halt-halt

rev 1.85
replace jnz FOO;jmp BAR;FOO: with jz BAR;FOO:, the idle loop will be even more efficient

rev 1.84
hlt hlt is not a good idea.  Rework APM to do what the spec actually says.
Run actual BIOS calls whenever we are actually idle. Tovarisch!

ok deraadt@@ marco@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.63 2004/06/13 21:49:15 niklas Exp $	*/
a149 1
int apm_idle_called = 0;
d627 1
a627 1
apm_cpu_busy(void)
d630 1
a630 6

	if (!apm_cd.cd_ndevs)	/* No APM device, punt */
		return;
	if (!apm_dobusy)
		return;
	if (!apm_idle_called)
d632 3
a635 3
	if (apm_flags & APM_IDLE_SLOWS) {
		bzero(&regs, sizeof(regs));
		if (apmcall(APM_CPU_BUSY, 0, &regs) != 0) {
d637 1
a637 1
			apm_perror("set CPU busy", &regs);
a638 2
		}
		apm_idle_called = 0;
d643 1
a643 1
apm_cpu_idle(void)
d646 1
a646 4
	static int call_apm = 0;

	if (!apm_cd.cd_ndevs) { /* No APM device, wait for next interrupt */
		__asm __volatile("sti;hlt");
a647 1
	}
d649 2
a650 4
	if (!apm_doidle) {
		__asm __volatile("sti;hlt");
		return;
	}
a651 9
	/*
	 * We call the bios APM_IDLE routine here only when we
	 * have been idle for some time - otherwise we just hlt.
	 */

	if  (call_apm != curcpu()->ci_schedstate.spc_cp_time[CP_IDLE]) {
		/* Always call BIOS halt/idle stuff */
		bzero(&regs, sizeof(regs));
		if (apmcall(APM_CPU_IDLE, 0, &regs) != 0) {
d653 1
a653 1
			apm_perror("set CPU idle", &regs);
a654 9
		}
		apm_idle_called = 1;
		/* If BIOS did halt, don't do it again! */
		if (apm_flags & APM_IDLE_SLOWS) {
			__asm __volatile("sti;hlt");
		}
		call_apm = curcpu()->ci_schedstate.spc_cp_time[CP_IDLE];
	} else {
		__asm __volatile("sti;hlt");
@


1.63.2.1
log
@MFC:
Fixes by marco@@, niklas@@, mickey@@ and beck@@

rev 1.87
one last optimization, removing a jump, mostly by
toby, committed so art will stop yelling at me to
avoid conflicts...

rev 1.86
repair whichqs race by disabling ints in between check and halt-halt

rev 1.85
replace jnz FOO;jmp BAR;FOO: with jz BAR;FOO:, the idle loop will be even more efficient

rev 1.84
hlt hlt is not a good idea.  Rework APM to do what the spec actually says.
Run actual BIOS calls whenever we are actually idle. Tovarisch!

ok deraadt@@ marco@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.63 2004/06/13 21:49:15 niklas Exp $	*/
a149 1
int apm_idle_called = 0;
d627 1
a627 1
apm_cpu_busy(void)
d630 1
a630 6

	if (!apm_cd.cd_ndevs)	/* No APM device, punt */
		return;
	if (!apm_dobusy)
		return;
	if (!apm_idle_called)
d632 3
a635 3
	if (apm_flags & APM_IDLE_SLOWS) {
		bzero(&regs, sizeof(regs));
		if (apmcall(APM_CPU_BUSY, 0, &regs) != 0) {
d637 1
a637 1
			apm_perror("set CPU busy", &regs);
a638 2
		}
		apm_idle_called = 0;
d643 1
a643 1
apm_cpu_idle(void)
d646 1
a646 4
	static int call_apm = 0;

	if (!apm_cd.cd_ndevs) { /* No APM device, wait for next interrupt */
		__asm __volatile("sti;hlt");
a647 1
	}
d649 2
a650 4
	if (!apm_doidle) {
		__asm __volatile("sti;hlt");
		return;
	}
a651 9
	/*
	 * We call the bios APM_IDLE routine here only when we
	 * have been idle for some time - otherwise we just hlt.
	 */

	if  (call_apm != curcpu()->ci_schedstate.spc_cp_time[CP_IDLE]) {
		/* Always call BIOS halt/idle stuff */
		bzero(&regs, sizeof(regs));
		if (apmcall(APM_CPU_IDLE, 0, &regs) != 0) {
d653 1
a653 1
			apm_perror("set CPU idle", &regs);
a654 9
		}
		apm_idle_called = 1;
		/* If BIOS did halt, don't do it again! */
		if (apm_flags & APM_IDLE_SLOWS) {
			__asm __volatile("sti;hlt");
		}
		call_apm = curcpu()->ci_schedstate.spc_cp_time[CP_IDLE];
	} else {
		__asm __volatile("sti;hlt");
@


1.62
log
@apm restores perflevel after resume; some cpus are forgetful.
update cpu even with 100 -> 100 setperf changes, in case saved value
has gotten out of sync.  from grange@@ ok deraadt@@ grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.61 2004/03/11 17:20:33 millert Exp $	*/
a779 1
	extern union descriptor *dynamic_gdt;
d845 6
a850 6
		setsegment(&dynamic_gdt[GAPM32CODE_SEL].sd, (void *)ch32,
			   ap->apm_code_len, SDT_MEMERA, SEL_KPL, 1, 0);
		setsegment(&dynamic_gdt[GAPM16CODE_SEL].sd, (void *)ch16,
			   ap->apm_code16_len, SDT_MEMERA, SEL_KPL, 0, 0);
		setsegment(&dynamic_gdt[GAPMDATA_SEL].sd, (void *)dh,
			   ap->apm_data_len, SDT_MEMRWA, SEL_KPL, 1, 0);
d892 3
a894 3
		dynamic_gdt[GAPM32CODE_SEL] = dynamic_gdt[GNULL_SEL];
		dynamic_gdt[GAPM16CODE_SEL] = dynamic_gdt[GNULL_SEL];
		dynamic_gdt[GAPMDATA_SEL] = dynamic_gdt[GNULL_SEL];
d903 9
@


1.61
log
@Avoid a panic by checking for apm_code_len == 0.  Fixes a problem
found by jmc@@.  OK markus@@ and tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.60 2003/11/24 07:26:55 mickey Exp $	*/
d350 2
d364 4
@


1.60
log
@have to apm_set_ver() before the values calculated get used; from nedko@@users.sourceforge.net
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.59 2003/04/26 08:01:41 jmc Exp $	*/
d743 2
a744 1
	if ((ap->apm_code32_base < IOM_BEGIN &&
@


1.59
log
@managment -> management;

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.58 2003/01/29 00:00:44 tedu Exp $	*/
d853 2
a861 2

		apm_set_ver(sc);
@


1.58
log
@fix typo.  majver should be minver
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.57 2003/01/09 17:43:56 mickey Exp $	*/
d589 1
a589 1
	/* enable is auto BIOS managment.
@


1.57
log
@restore the prev version of the kq filter for events do not get delivered properly; reported by dugsong@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.56 2002/12/22 17:12:44 mickey Exp $	*/
d689 1
a689 1
				apm_majver = 0;
@


1.56
log
@better handling of bigendian batteries; problem noticed by blovett@@bsdguru.com
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.55 2002/12/18 22:53:06 mickey Exp $	*/
d1127 3
a1129 1
	kn->kn_data = (int)hint;
d1131 1
a1131 1
	return (hint != 0);
@


1.55
log
@APM_BEBATT is in the apm_flags, not sc_flags, from markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.54 2002/06/19 02:43:40 mickey Exp $	*/
d149 1
d311 1
a311 1
				if (apm_flags & APM_BEBATT)
d805 2
d1092 1
a1092 1
					if (apm_flags & APM_BEBATT)
@


1.54
log
@kq: it did not work like this and it seem to be working, from the denver whereabouts
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.53 2002/03/14 03:15:53 millert Exp $	*/
d310 1
a310 1
				if (sc->sc_flags & APM_BEBATT)
d1089 1
a1089 1
					if (sc->sc_flags & APM_BEBATT)
@


1.53
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.52 2002/03/14 01:26:32 millert Exp $	*/
d1124 1
a1124 3
	/* XXX weird kqueue_scan() semantics */
	if (hint && !kn->kn_data)
		kn->kn_data = (int)hint;
d1126 1
a1126 1
	return (1);
@


1.52
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.51 2002/01/16 20:50:16 miod Exp $	*/
d1025 1
a1025 1
			int flag = *(int*)data;
@


1.51
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.50 2001/12/14 17:07:40 mickey Exp $	*/
d97 2
a98 2
int apmprobe __P((struct device *, void *, void *));
void apmattach __P((struct device *, struct device *, void *));
d104 2
a105 2
void filt_apmrdetach __P((struct knote *kn));
int filt_apmread __P((struct knote *kn, long hint));
d163 14
a176 14
int  apmcall __P((u_int, u_int, struct apmregs *));
void apm_power_print __P((struct apm_softc *, struct apmregs *));
int  apm_handle_event __P((struct apm_softc *, struct apmregs *));
void apm_set_ver __P((struct apm_softc *));
int  apm_periodic_check __P((struct apm_softc *));
void apm_thread_create __P((void *v));
void apm_thread __P((void *));
void apm_disconnect __P((struct apm_softc *));
void apm_perror __P((const char *, struct apmregs *));
void apm_powmgt_enable __P((int onoff));
void apm_powmgt_engage __P((int onoff, u_int devid));
/* void apm_devpowmgt_enable __P((int onoff, u_int devid)); */
int  apm_record_event __P((struct apm_softc *sc, u_int type));
const char *apm_err_translate __P((int code));
d179 3
a181 3
void	apm_standby __P((void));
void	apm_suspend __P((void));
void	apm_resume __P((struct apm_softc *, struct apmregs *));
@


1.50
log
@on some sony vaios (con dios) battery life is reported
in big endian order, swap if flags was given.
reported by: Hans-Joerg Hoexer <Hans-Joerg.Hoexer@@yerbouti.franken.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.49 2001/08/18 06:08:08 mickey Exp $	*/
a48 1
#include <sys/map.h>
@


1.50.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.51 2002/01/16 20:50:16 miod Exp $	*/
d49 1
@


1.50.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.50.2.1 2002/01/31 22:55:11 niklas Exp $	*/
d97 2
a98 2
int apmprobe(struct device *, void *, void *);
void apmattach(struct device *, struct device *, void *);
d104 2
a105 2
void filt_apmrdetach(struct knote *kn);
int filt_apmread(struct knote *kn, long hint);
d163 14
a176 14
int  apmcall(u_int, u_int, struct apmregs *);
void apm_power_print(struct apm_softc *, struct apmregs *);
int  apm_handle_event(struct apm_softc *, struct apmregs *);
void apm_set_ver(struct apm_softc *);
int  apm_periodic_check(struct apm_softc *);
void apm_thread_create(void *v);
void apm_thread(void *);
void apm_disconnect(struct apm_softc *);
void apm_perror(const char *, struct apmregs *);
void apm_powmgt_enable(int onoff);
void apm_powmgt_engage(int onoff, u_int devid);
/* void apm_devpowmgt_enable(int onoff, u_int devid); */
int  apm_record_event(struct apm_softc *sc, u_int type);
const char *apm_err_translate(int code);
d179 3
a181 3
void	apm_standby(void);
void	apm_suspend(void);
void	apm_resume(struct apm_softc *, struct apmregs *);
d1025 1
a1025 1
			int flag = *(int *)data;
@


1.50.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.50.2.2 2002/06/11 03:35:53 art Exp $	*/
d1124 3
a1126 1
	kn->kn_data = (int)hint;
d1128 1
a1128 1
	return (hint != 0);
@


1.50.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a148 1
int apm_bebatt = 0;
d310 1
a310 1
				if (apm_bebatt)
d588 1
a588 1
	/* enable is auto BIOS management.
d688 1
a688 1
				apm_minver = 0;
a803 2
		if (sc->sc_dev.dv_cfdata->cf_flags & APM_BEBATT)
			apm_bebatt = 1;
d1089 1
a1089 1
					if (apm_bebatt)
d1124 1
a1124 3
	/* XXX weird kqueue_scan() semantics */
	if (hint && !kn->kn_data)
		kn->kn_data = (int)hint;
d1126 1
a1126 1
	return (1);
@


1.49
log
@make apm use kqueue for transferring events to luse listener.
apparently i thought i comitted this already before apmd.
tested by me, art@@ and jason@@ .
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.48 2001/06/24 20:38:04 fgsch Exp $	*/
d309 4
a312 1
			if (BATT_REM_VALID(regs))
d314 2
a315 2
				    BATT_REMAINING(regs) / 60,
				    BATT_REMAINING(regs) % 60);
d1088 1
a1088 1
				if (BATT_REM_VALID(&regs))
d1090 4
@


1.48
log
@move cold to .h
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.47 2001/06/24 05:02:13 fgsch Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2000 Michael Shalayeff. All rights reserved.
d56 1
d82 3
a84 10
int apmprobe __P((struct device *, void *, void *));
void apmattach __P((struct device *, struct device *, void *));

/* battery percentage at where we get verbose in our warnings.  This
   value can be changed using sysctl(8), value machdep.apmwarn.
   Setting it to zero kills all warnings */
int cpu_apmwarn = 10;

#define	APM_NEVENTS 16
#define	APM_RESUME_HOLDOFF	3
d88 1
a88 1
	struct selinfo sc_rsel;
a90 3
	int	event_count;
	int	event_ptr;
	struct	apm_event_info event_list[APM_NEVENTS];
d98 20
a135 8
struct cfattach apm_ca = {
	sizeof(struct apm_softc), apmprobe, apmattach
};

struct cfdriver apm_cd = {
	NULL, "apm", DV_DULL
};

d176 1
a176 1
int  apm_record_event __P((struct apm_softc *sc, u_int event_type));
a348 3
	/* flush the event queue */
	sc->event_count = 0;

d362 1
a362 1
apm_record_event(sc, event_type)
d364 1
a364 1
	u_int event_type;
a365 2
	struct apm_event_info *evp;

d372 2
a373 14
	if (sc->event_count >= APM_NEVENTS) {
		DPRINTF(("apm_record_event: overflow\n"));
		apm_error++;
	} else {
		int s = splhigh();
		evp = &sc->event_list[sc->event_ptr];
		sc->event_count++;
		sc->event_ptr++;
		sc->event_ptr %= APM_NEVENTS;
		evp->type = event_type;
		evp->index = ++apm_evindex;
		splx(s);
	}
	selwakeup(&sc->sc_rsel);
d375 1
a375 1
	return (sc->sc_flags & SCFLAG_OWRITE) ? 0 : 1; /* user may handle */
a982 4
	if ((sc->sc_flags & SCFLAG_OPEN) == 0) {
		sc->event_count = 0;
		sc->event_ptr = 0;
	}
d997 1
a997 1
	int i, error = 0;
a1056 11
	case APM_IOC_NEXTEVENT:
		if (sc->event_count) {
			struct apm_event_info *evp =
			    (struct apm_event_info *)data;
			i = sc->event_ptr + APM_NEVENTS - sc->event_count;
			i %= APM_NEVENTS;
			*evp = sc->event_list[i];
			sc->event_count--;
		} else
			error = EAGAIN;
		break;
d1102 23
d1126 1
a1126 1
apmselect(dev, rw, p)
d1128 1
a1128 2
	int rw;
	struct proc *p;
a1130 1
	int ret = 0;
d1137 3
a1139 10
	APM_LOCK(sc);
	switch (rw) {
	case FREAD:
		if (sc->event_count)
			ret++;
		else
			selrecord(p, &sc->sc_rsel);
		break;
	case FWRITE:
	case 0:
d1141 2
d1144 5
d1150 2
a1151 1
	return ret;
@


1.47
log
@Add cold as extern; makes kernel compiles again. bad mickey!
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.46 2001/06/23 23:13:39 mickey Exp $	*/
a319 2
	extern int cold;

a330 2
	extern int cold;

@


1.46
log
@do not do sync if too cold; niklas@@ arrived
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.45 2001/02/19 04:57:02 ho Exp $	*/
d320 2
d333 2
@


1.45
log
@Avoid losing rtc after suspend/resume on some laptops. Ok provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.44 2001/02/06 00:15:01 mickey Exp $	*/
d322 2
a323 1
	vfs_syncwait(0);
d333 2
a334 1
	vfs_syncwait(0);
@


1.44
log
@only call apm_perror() if get_event() failed
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.43 2001/01/02 16:16:50 mickey Exp $	*/
d354 3
@


1.43
log
@handle no-event as the end of event fetch loop; my fix for pr-1588 by Sam Isaacson <sbi@@mobius.colorado.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.42 2000/12/12 00:36:58 angelos Exp $	*/
d528 8
a535 1
	while (apm_get_event(&regs) == 0)
d538 1
a538 4

	/* i think some bioses actually combine the error codes */
	if (!(APM_ERR_CODE(&regs) & APM_ERR_NOEVENTS))
		apm_perror("periodic get event", &regs);
@


1.42
log
@Add an extra apm_periodic_check() call before the one we check for
errors; that way, Theo's laptop can still turn off APM when there's an
error, and the IBM 770Z won't gratuitously disconnect APM (since the
first event is always a bogus one).
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.41 2000/10/18 16:53:01 deraadt Exp $	*/
d161 1
a161 1
int apmcall __P((u_int, u_int, struct apmregs *));
d163 1
a163 1
void apm_handle_event __P((struct apm_softc *, struct apmregs *));
d165 1
a165 1
int apm_periodic_check __P((struct apm_softc *));
d173 1
a173 1
int apm_record_event __P((struct apm_softc *sc, u_int event_type));
d387 1
a387 1
void
a391 1
	int error;
d393 1
a393 1
	char *p;
d396 4
d417 1
d442 1
d452 1
a452 2
		error = apm_get_powstat(&nregs);
		if (error == 0 &&
d501 3
a503 1
	default:
d510 1
d512 1
d514 2
d528 3
a530 2
	while (apm_get_event(&regs) == 0 && !apm_error)
		apm_handle_event(sc, &regs);
@


1.41
log
@if periodic checks return errors, stop doing so.  This is a workaround for
some other apm bug that happens on the SuperMicro DL3 (ServerWorks-based)
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.40 2000/07/26 03:39:45 mickey Exp $	*/
d860 8
@


1.40
log
@proper busy/idle handling; pointed out by marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.39 2000/06/07 22:25:47 mickey Exp $	*/
d165 1
a165 1
void apm_periodic_check __P((struct apm_softc *));
d236 1
d508 1
a508 1
void
d513 1
d523 4
a526 1
		apm_perror("get event", &regs);
d540 1
d711 1
a711 1
		printf("APM disconnected\n");
d861 5
a865 3
		apm_periodic_check(sc);

		kthread_create_deferred(apm_thread_create, sc);
d894 1
a894 1
		apm_periodic_check(sc);
@


1.39
log
@look into config flags for version enforcement and other flags
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.38 2000/05/30 03:39:34 mickey Exp $	*/
d145 3
a147 1
int apm_dobusy;
a604 2
int apmidleon = 1;

d609 1
a609 1
	if (!apm_cd.cd_ndevs || !apmidleon)
a617 1
		apmidleon = 0;
d625 1
a625 1
	if (!apm_cd.cd_ndevs || !apmidleon)
a633 1
		apmidleon = 0;
a679 1
		/* not relevant much */
a680 1
		apm_dobusy = 1;
@


1.38
log
@hours vs minutes; pr 769 from mfriedl@@fau.de
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.37 2000/04/21 16:29:58 mickey Exp $	*/
d770 1
d774 1
a774 1
	if (ap->apm_detail & APM_32BIT_SUPPORTED) {
d784 10
a793 1
		apm_flags = ap->apm_detail;
d840 1
a840 1
		if (ap->apm_detail & APM_BIOS_PM_DISABLED)
@


1.37
log
@shovel apm into it's own thread.
apply art's idea to sleep on &lbolt, it seem fine w/ it.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.36 2000/04/17 18:14:22 mickey Exp $	*/
d304 1
a304 1
				printf(", estimated %d:%02d minutes",
@


1.36
log
@fix version for some endianess-challenged compaqs; via linux
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.35 2000/02/21 17:46:16 mickey Exp $	*/
d47 2
d78 3
d100 2
d109 1
a109 1
 * 	SCFLAG_NOPRINT:		do not output APM power messages due to
d163 4
a166 2
void apm_periodic_check __P((void *));
/* void apm_disconnect __P((void *)); */
d506 2
a507 2
apm_periodic_check(arg)
	void *arg;
a508 1
	register struct apm_softc *sc = arg;
a532 2

	timeout(apm_periodic_check, sc, hz);
d648 1
a648 1
	
d662 1
a662 1
	    	if (apmcall(APM_DRIVER_VERSION, APM_DEV_APM_BIOS, &regs) == 0) {
a695 1
#ifdef notused
d697 2
a698 2
apm_disconnect(xxx)
	void *xxx;
a710 1
#endif
d808 1
a808 1
				      ap->apm_data_len + 1, 1, &dh);
d846 3
d850 2
d859 27
d893 1
d903 1
d906 8
a913 4
		if (!(flag & FWRITE))
			return EINVAL;
		if (sc->sc_flags & SCFLAG_OWRITE)
			return EBUSY;
d917 4
a920 2
		if (!(flag & FREAD) || (flag & FWRITE))
			return EINVAL;
d924 1
a924 1
		return ENXIO;
d927 2
a928 1
	return 0;
a937 1
	int s;
d943 1
a943 1
	
d946 1
a946 1
	s = splhigh();
d959 1
a959 1
	splx(s);
a971 2
	struct apm_power_info *powerp;
	struct apm_event_info *evp;
d973 1
a973 3
	register int i;
	struct apm_ctl *actl;
	int s;
d979 2
a980 1
	
d985 4
a988 3
			return EBADF;
		apm_userstandbys++;
		return 0;
d991 4
a994 3
			return EBADF;
		apm_suspends++;
		return 0;
d997 2
a998 2
			return EBADF;
		{
a1000 1
			s = splhigh();
d1004 1
a1004 2
				splx(s);
				return 0;
d1008 1
a1008 2
				splx(s);
				return 0;
d1012 1
a1012 2
				splx(s);
				return 0;
d1014 1
d1018 1
a1018 1
		return EINVAL;
a1019 1
		actl = (struct apm_ctl *)data;
d1021 4
a1024 4
			return EBADF;
		{
			struct apmregs regs;
			
d1028 3
a1030 1
				       sc->sc_dev.dv_xname, dev, regs.cx);
d1032 1
a1032 1
		return apm_set_powstate(actl->dev, actl->mode);
a1033 1
		s = splhigh();
d1035 2
a1036 1
			evp = (struct apm_event_info *)data;
d1041 3
a1043 6
			splx(s);
			return 0;
		} else {
			splx(s);
			return EAGAIN;
		}
a1044 1
		powerp = (struct apm_power_info *)data;
d1046 3
d1077 1
a1077 1
			return (EIO);
d1080 1
a1080 1
		
d1082 1
a1082 1
		return (ENOTTY);
d1085 2
a1086 1
	return 0;
d1096 1
a1096 1
	int s, ret = 0;
d1102 2
a1103 1
	
a1105 1
		s = splhigh();
a1109 1
		splx(s);
d1115 1
@


1.35
log
@a few comment fixes from espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.34 2000/02/21 17:09:01 mickey Exp $	*/
d666 6
@


1.34
log
@separate assembly thing into an own file to avoid compiler-deps.
ignore suspend reqs while suspending.
ignore suspend requests for 3 seconds holdoff period once awaken.
protect event queue manipulations w/ splhigh's.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.33 2000/02/01 01:33:45 mickey Exp $	*/
d29 1
a29 1
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
d335 1
a335 1
	/* they say that some machines may require reinititalizing the clock */
@


1.33
log
@call vfs_syncwait on standby and suspend
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.32 2000/01/31 21:09:36 mickey Exp $	*/
d84 2
a85 1
#define APM_NEVENTS 16
a89 1
	struct selinfo sc_xsel;
d129 1
d154 1
a154 1
void apm_event_handle __P((struct apm_softc *, struct apmregs *));
a175 4
#ifdef APMDEBUG
	if (r->bx)
		printf("apm_get_event: %x\n", r->bx);
#endif
d330 5
d339 1
a343 41
/*
 * 	call the APM protected mode bios function FUNCTION for BIOS selection
 * 	WHICHBIOS.
 *	Fills in *regs with registers as returned by APM.
 *	returns nonzero if error returned by APM.
 */
int
apmcall(f, dev, r)
	u_int f, dev;
	struct apmregs *r;
{
	register int rv;

	/* todo: do something with %edi? */
	__asm __volatile(
#if defined(DEBUG) || defined(DIAGNOSTIC)
			"pushl %%ds; pushl %%es; pushl %%fs; pushl %%gs\n\t"
			"pushfl\n\t"
			"xorl	%0, %0\n\t"
			"movl	%0, %%ds\n\t"
			"movl	%0, %%es\n\t"
			"movl	%0, %%fs\n\t"
			"movl	%0, %%gs\n\t"
#endif
			"movl	%5, %%eax\n\t"
			"clc\n\t"
			"sti\n\t"
			"lcall	%%cs:(%7)\n\t"
			"pushl %1; setc %b1; movzbl %b1, %0; popl %1\n\t"

#if defined(DEBUG) || defined(DIAGNOSTIC)
			"popfl; popl %%gs; popl %%fs; popl %%es; popl %%ds"
#endif
			: "=r" (rv),
			  "=a" (r->ax), "=b" (r->bx), "+c" (r->cx), "+d" (r->dx)
			: "m" (f), "2" (dev), "m" (apm_ep)
			: "edi", "ebp", "cc", "memory");
	return rv;
}


d354 1
a354 1
		return 1;		/* no user waiting */
d356 2
a357 1
	if (!apm_error && sc->event_count == APM_NEVENTS) {
d360 9
a368 1
		return 1;			/* overflow */
a369 6
	evp = &sc->event_list[sc->event_ptr];
	sc->event_count++;
	sc->event_ptr++;
	sc->event_ptr %= APM_NEVENTS;
	evp->type = event_type;
	evp->index = ++apm_evindex;
d371 1
d376 1
a376 1
apm_event_handle(sc, regs)
d386 2
d389 3
a391 1
		if (apm_record_event(sc, regs->bx))
d393 1
a393 2
		apm_set_powstate(APM_DEV_ALLDEVS, APM_LASTREQ_INPROG);
		apm_op_inprog++;
d396 2
d403 3
a405 1
		if (apm_record_event(sc, regs->bx))
d407 1
a407 2
		apm_set_powstate(APM_DEV_ALLDEVS, APM_LASTREQ_INPROG);
		apm_op_inprog++;
d410 2
d413 3
a415 1
		if (apm_record_event(sc, regs->bx))
d417 1
a417 2
		apm_set_powstate(APM_DEV_ALLDEVS, APM_LASTREQ_INPROG);
		apm_op_inprog++;
d420 2
d427 3
a429 1
		if (apm_record_event(sc, regs->bx))
d431 1
a431 2
		apm_set_powstate(APM_DEV_ALLDEVS, APM_LASTREQ_INPROG);
		apm_op_inprog++;
d459 2
a460 1
		apm_resume(sc, regs);
d507 1
a507 1
		apm_event_handle(sc, &regs);
d509 2
a510 1
	if (APM_ERR_CODE(&regs) != APM_ERR_NOEVENTS)
a514 1
		/* stupid TI TM5000! */
d523 3
d663 3
a665 2
			apm_majver = 1;
			apm_minver = 0;
d856 4
a859 1
	
d887 1
d896 1
d909 1
d927 1
d952 1
d956 1
d961 1
d966 1
d987 1
d994 1
d996 2
a997 1
		} else
d999 1
d1049 1
d1058 1
d1060 4
a1063 2
			return 1;
		selrecord(p, &sc->sc_rsel);
d1067 1
a1067 1
		return 0;
d1069 1
a1069 1
	return 0;
@


1.33.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.35 2000/02/21 17:46:16 mickey Exp $	*/
d29 1
a29 1
 * OR SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
d84 1
a84 2
#define	APM_NEVENTS 16
#define	APM_RESUME_HOLDOFF	3
d89 1
a128 1
int apm_resumes;
d153 1
a153 1
void apm_handle_event __P((struct apm_softc *, struct apmregs *));
d175 4
d333 1
a333 6
	apm_resumes = APM_RESUME_HOLDOFF;

	/* flush the event queue */
	sc->event_count = 0;

	/* they say that some machines may require reinitializing the clock */
a336 1
	/* lower bit in cx means pccard was powered down */
d341 41
d392 1
a392 1
		return 1;
d394 1
a394 2

	if (sc->event_count >= APM_NEVENTS) {
d397 1
a397 9
	} else {
		int s = splhigh();
		evp = &sc->event_list[sc->event_ptr];
		sc->event_count++;
		sc->event_ptr++;
		sc->event_ptr %= APM_NEVENTS;
		evp->type = event_type;
		evp->index = ++apm_evindex;
		splx(s);
d399 6
a405 1

d410 1
a410 1
apm_handle_event(sc, regs)
a419 2
		if (apm_resumes || apm_op_inprog)
			break;
d421 3
a424 4
		if (apm_record_event(sc, regs->bx)) {
			DPRINTF(("standby ourselves\n"));
			apm_userstandbys++;
		}
a426 2
		if (apm_resumes || apm_op_inprog)
			break;
d432 3
a435 4
		if (apm_record_event(sc, regs->bx)) {
			DPRINTF(("standby ourselves\n"));
			apm_standbys++;
		}
a437 2
		if (apm_resumes || apm_op_inprog)
			break;
d439 3
a442 4
		if (apm_record_event(sc, regs->bx)) {
			DPRINTF(("suspend ourselves\n"));
			apm_suspends++;
		}
a444 2
		if (apm_resumes || apm_op_inprog)
			break;
d450 3
a453 4
		if (apm_record_event(sc, regs->bx)) {
			DPRINTF(("suspend ourselves\n"));
			apm_suspends++;
		}
d481 1
a481 2
		inittodr(time.tv_sec);
		apm_record_event(sc, regs->bx);
d528 1
a528 1
		apm_handle_event(sc, &regs);
d530 1
a530 2
	/* i think some bioses actually combine the error codes */
	if (!(APM_ERR_CODE(&regs) & APM_ERR_NOEVENTS))
d535 1
a543 3
	if (apm_resumes)
		apm_resumes--;

d681 2
a682 3
			/* stay w/ flags then */
			apm_majver = APM_MAJOR(apm_flags);
			apm_minver = APM_MINOR(apm_flags);
d873 1
a873 4

	DPRINTF(("apmopen: dev %d pid %d flag %x mode %x\n",
	    APMDEV(dev), p->p_pid, flag, mode));

a900 1
	int s;
a908 1
	s = splhigh();
a920 1
	splx(s);
a937 1
	int s;
a961 1
			s = splhigh();
a964 1
				splx(s);
a968 1
				splx(s);
a972 1
				splx(s);
a992 1
		s = splhigh();
a998 1
			splx(s);
d1000 1
a1000 2
		} else {
			splx(s);
a1001 1
		}
a1050 1
	int s, ret = 0;
a1058 1
		s = splhigh();
d1060 2
a1061 4
			ret++;
		else
			selrecord(p, &sc->sc_rsel);
		splx(s);
d1065 1
a1065 1
		break;
d1067 1
a1067 1
	return ret;
@


1.33.2.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.45 2001/02/19 04:57:02 ho Exp $	*/
a46 2
#include <sys/kthread.h>
#include <sys/lock.h>
a75 3
#define	APM_LOCK(sc)	lockmgr(&(sc)->sc_lock, LK_EXCLUSIVE, NULL, curproc)
#define	APM_UNLOCK(sc)	lockmgr(&(sc)->sc_lock, LK_RELEASE, NULL, curproc)

a94 2
	struct proc *sc_thread;
	struct lock sc_lock;
d102 1
a102 1
 *	SCFLAG_NOPRINT:		do not output APM power messages due to
d138 1
a138 3
int apm_dobusy = 1;
int apm_doidle = 1;

d152 1
a152 1
int  apmcall __P((u_int, u_int, struct apmregs *));
d154 1
a154 1
int  apm_handle_event __P((struct apm_softc *, struct apmregs *));
d156 2
a157 4
int  apm_periodic_check __P((struct apm_softc *));
void apm_thread_create __P((void *v));
void apm_thread __P((void *));
void apm_disconnect __P((struct apm_softc *));
d162 1
a162 1
int  apm_record_event __P((struct apm_softc *sc, u_int event_type));
a224 1
	delay(1000000);
d295 1
a295 1
				printf(", estimated %d:%02d hours",
a341 3
	
	/* acknowledge any rtc interrupt we may have missed */
	rtcdrain(NULL);
d375 1
a375 1
int
d380 1
d382 1
a382 1
	int ret = 0;
a384 4
	case APM_NOEVENT:
		ret++;
		break;

a401 1
			ret++;
a425 1
			ret++;
d435 2
a436 1
		if (apm_get_powstat(&nregs) == 0 &&
d485 1
a485 3
	default: {
#ifdef APMDEBUG
		char *p;
a491 1
#endif
a492 1
	    }
a493 2

	return ret;
d496 3
a498 3
int
apm_periodic_check(sc)
	struct apm_softc *sc;
d500 1
a501 1
	int ret = 0;
d506 2
a507 7
	while (1) {
		if (apm_get_event(&regs) != 0) {
			/* i think some bioses combine the error codes */
			if (!(APM_ERR_CODE(&regs) & APM_ERR_NOEVENTS))
				apm_perror("get event", &regs);
			break;
		}
d509 3
a511 6
		if (apm_handle_event(sc, &regs))
			break;
	}

	if (apm_error || APM_ERR_CODE(&regs) == APM_ERR_NOTCONN)
		ret = -1;
d525 2
a526 1
	return (ret);
d597 2
d603 1
a603 1
	if (!apm_cd.cd_ndevs || !apm_doidle)
d612 1
d620 1
a620 1
	if (!apm_cd.cd_ndevs || !apm_doidle)
d629 1
d642 1
a642 1

d656 1
a656 1
		if (apmcall(APM_DRIVER_VERSION, APM_DEV_APM_BIOS, &regs) == 0) {
a665 6

			/* fix version for some endianess-challenged compaqs */
			if (!apm_majver) {
				apm_majver = 1;
				apm_majver = 0;
			}
d670 1
d672 1
d684 1
d686 2
a687 2
apm_disconnect(sc)
	struct apm_softc *sc;
d698 1
a698 1
		printf("%s: disconnected\n", sc->sc_dev.dv_xname);
d700 1
a759 1
	apm_flags = ap->apm_detail;
d763 1
a763 1
	if (apm_flags & APM_32BIT_SUPPORTED) {
d773 1
a773 10
		/* adjust version */
		if ((sc->sc_dev.dv_cfdata->cf_flags & APM_VERMASK) &&
		    (apm_flags & APM_VERMASK) !=
		    (sc->sc_dev.dv_cfdata->cf_flags & APM_VERMASK))
			apm_flags = (apm_flags & ~APM_VERMASK) |
			    (sc->sc_dev.dv_cfdata->cf_flags & APM_VERMASK);
		if (sc->sc_dev.dv_cfdata->cf_flags & APM_NOCLI) {
			extern int apm_cli; /* from apmcall.S */
			apm_cli = 0;
		}
d798 1
a798 1
			    ap->apm_data_len + 1, 1, &dh);
d820 1
a820 1
		if (apm_flags & APM_BIOS_PM_DISABLED)
a835 9

		lockinit(&sc->sc_lock, PWAIT, "apmlk", 0, 0);

		/*
		 * Do a check once, ignoring any errors. This avoids
		 * gratuitous APM disconnects on laptops where the first
		 * event in the queue (after a boot) is non-recognizable.
		 * The IBM ThinkPad 770Z is one of those.
		 */
a836 6

		if (apm_periodic_check(sc) == -1) {
			apm_disconnect(sc);
			apm_dobusy = apm_doidle = 0;
		} else
			kthread_create_deferred(apm_thread_create, sc);
a843 27
void
apm_thread_create(v)
	void *v;
{
	struct apm_softc *sc = v;
	if (kthread_create(apm_thread, sc, &sc->sc_thread,
	    "%s", sc->sc_dev.dv_xname)) {
		apm_disconnect(sc);
		printf("%s: failed to create kernel thread, disabled",
		    sc->sc_dev.dv_xname);
	}
}

void
apm_thread(v)
	void *v;
{
	struct apm_softc *sc = v;

	for (;;) {
		APM_LOCK(sc);
		(void) apm_periodic_check(sc);
		APM_UNLOCK(sc);
		tsleep(&lbolt, PWAIT, "apmev", 0);
	}
}

a850 1
	int error = 0;
a859 1
	APM_LOCK(sc);
d862 4
a865 8
		if (!(flag & FWRITE)) {
			error = EINVAL;
			break;
		}
		if (sc->sc_flags & SCFLAG_OWRITE) {
			error = EBUSY;
			break;
		}
d869 2
a870 4
		if (!(flag & FREAD) || (flag & FWRITE)) {
			error = EINVAL;
			break;
		}
d874 1
a874 1
		error = ENXIO;
d877 1
a877 2
	APM_UNLOCK(sc);
	return error;
d887 1
d893 1
a893 1

d896 1
a896 1
	APM_LOCK(sc);
d909 1
a909 1
	APM_UNLOCK(sc);
d922 2
d925 3
a927 1
	int i, error = 0;
d933 1
a933 2

	APM_LOCK(sc);
d938 3
a940 4
			error = EBADF;
		else
			apm_userstandbys++;
		break;
d943 3
a945 4
			error = EBADF;
		else
			apm_suspends++;
		break;
d948 2
a949 2
			error = EBADF;
		else {
d952 1
d956 2
a957 1
				break;
d961 2
a962 1
				break;
d966 2
a967 1
				break;
a968 1
				error = EINVAL;
d972 1
a972 1
		break;
d974 1
d976 4
a979 4
			error = EBADF;
		else {
			struct apm_ctl *actl = (struct apm_ctl *)data;

d983 1
a983 3
				    sc->sc_dev.dv_xname, dev, regs.cx);

			error = apm_set_powstate(actl->dev, actl->mode);
d985 1
a985 1
		break;
d987 1
d989 1
a989 2
			struct apm_event_info *evp =
			    (struct apm_event_info *)data;
d994 6
a999 3
		} else
			error = EAGAIN;
		break;
d1001 1
a1002 3
			struct apm_power_info *powerp =
			    (struct apm_power_info *)data;

d1031 1
a1031 1
			error = EIO;
d1034 1
a1034 1

d1036 1
a1036 1
		error = ENOTTY;
d1039 1
a1039 2
	APM_UNLOCK(sc);
	return error;
d1049 1
a1049 1
	int ret = 0;
d1055 1
a1055 2

	APM_LOCK(sc);
d1058 1
d1063 1
a1068 1
	APM_UNLOCK(sc);
@


1.33.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.33.2.2 2001/04/18 16:07:12 niklas Exp $	*/
d322 1
a322 2
	if (cold)
		vfs_syncwait(0);
d332 1
a332 2
	if (cold)
		vfs_syncwait(0);
@


1.33.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.33.2.3 2001/07/04 10:16:29 niklas Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998-2001 Michael Shalayeff. All rights reserved.
a55 1
#include <sys/event.h>
d81 10
a90 3
struct cfdriver apm_cd = {
	NULL, "apm", DV_DULL
};
d94 1
a94 1
	struct klist sc_note;
d97 3
a106 20
int apmprobe __P((struct device *, void *, void *));
void apmattach __P((struct device *, struct device *, void *));

struct cfattach apm_ca = {
	sizeof(struct apm_softc), apmprobe, apmattach
};

void filt_apmrdetach __P((struct knote *kn));
int filt_apmread __P((struct knote *kn, long hint));

struct filterops apmread_filtops =
	{ 1, NULL, filt_apmrdetach, filt_apmread};

/* battery percentage at where we get verbose in our warnings.  This
   value can be changed using sysctl(8), value machdep.apmwarn.
   Setting it to zero kills all warnings */
int cpu_apmwarn = 10;

#define	APM_RESUME_HOLDOFF	3

d125 8
d173 1
a173 1
int  apm_record_event __P((struct apm_softc *sc, u_int type));
d346 3
d362 1
a362 1
apm_record_event(sc, type)
d364 1
a364 1
	u_int type;
d366 2
d374 14
a387 2
	apm_evindex++;
	KNOTE(&sc->sc_note, APM_EVENT_COMPOSE(type, apm_evindex));
d389 1
a389 1
	return (0);
d997 4
d1015 1
a1015 1
	int error = 0;
d1075 11
a1130 23
void
filt_apmrdetach(kn)
	struct knote *kn;
{
	struct apm_softc *sc = (struct apm_softc *)kn->kn_hook;

	APM_LOCK(sc);
	SLIST_REMOVE(&sc->sc_note, kn, knote, kn_selnext);
	APM_UNLOCK(sc);
}

int
filt_apmread(kn, hint)
	struct knote *kn;
	long hint;
{
	/* XXX weird kqueue_scan() semantics */
	if (hint && !kn->kn_data)
		kn->kn_data = (int)hint;

	return (1);
}

d1132 1
a1132 1
apmkqfilter(dev, kn)
d1134 2
a1135 1
	struct knote *kn;
d1138 1
d1145 10
a1154 3
	switch (kn->kn_filter) {
	case EVFILT_READ:
		kn->kn_fop = &apmread_filtops;
a1155 2
	default:
		return (1);
a1156 5

	kn->kn_hook = (caddr_t)sc;

	APM_LOCK(sc);
	SLIST_INSERT_HEAD(&sc->sc_note, kn, kn_selnext);
d1158 1
a1158 2

	return (0);
@


1.33.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
d309 1
a309 4
			if (BATT_REM_VALID(regs)) {
				int life = BATT_REMAINING(regs);
				if (sc->sc_flags & APM_BEBATT)
					life = swap16(life);
d311 2
a312 2
				    life / 60, life % 60);
			}
d1085 1
a1085 1
				if (BATT_REM_VALID(&regs)) {
a1086 4
					if (sc->sc_flags & APM_BEBATT)
						powerp->minutes_left =
						    swap16(powerp->minutes_left);
				}
@


1.33.2.6
log
@Merge in -current from about a week ago
@
text
@d97 2
a98 2
int apmprobe(struct device *, void *, void *);
void apmattach(struct device *, struct device *, void *);
d104 2
a105 2
void filt_apmrdetach(struct knote *kn);
int filt_apmread(struct knote *kn, long hint);
d163 14
a176 14
int  apmcall(u_int, u_int, struct apmregs *);
void apm_power_print(struct apm_softc *, struct apmregs *);
int  apm_handle_event(struct apm_softc *, struct apmregs *);
void apm_set_ver(struct apm_softc *);
int  apm_periodic_check(struct apm_softc *);
void apm_thread_create(void *v);
void apm_thread(void *);
void apm_disconnect(struct apm_softc *);
void apm_perror(const char *, struct apmregs *);
void apm_powmgt_enable(int onoff);
void apm_powmgt_engage(int onoff, u_int devid);
/* void apm_devpowmgt_enable(int onoff, u_int devid); */
int  apm_record_event(struct apm_softc *sc, u_int type);
const char *apm_err_translate(int code);
d179 3
a181 3
void	apm_standby(void);
void	apm_suspend(void);
void	apm_resume(struct apm_softc *, struct apmregs *);
d1025 1
a1025 1
			int flag = *(int *)data;
@


1.33.2.7
log
@Sync the SMP branch with 3.3
@
text
@a148 1
int apm_bebatt = 0;
d310 1
a310 1
				if (apm_bebatt)
d688 1
a688 1
				apm_minver = 0;
a803 2
		if (sc->sc_dev.dv_cfdata->cf_flags & APM_BEBATT)
			apm_bebatt = 1;
d1089 1
a1089 1
					if (apm_bebatt)
@


1.33.2.8
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.33.2.7 2003/03/27 23:26:55 niklas Exp $	*/
d589 1
a589 1
	/* enable is auto BIOS management.
@


1.33.2.9
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.33.2.8 2003/05/13 19:42:07 ho Exp $	*/
d773 1
d839 6
a844 6
		setgdt(GAPM32CODE_SEL, (void *)ch32, ap->apm_code_len,
		    SDT_MEMERA, SEL_KPL, 1, 0);
		setgdt(GAPM16CODE_SEL, (void *)ch16, ap->apm_code16_len,
		    SDT_MEMERA, SEL_KPL, 0, 0);
		setgdt(GAPMDATA_SEL, (void *)dh, ap->apm_data_len, SDT_MEMRWA,
		    SEL_KPL, 1, 0);
d886 3
a888 3
		setgdt(GAPM32CODE_SEL, NULL, 0, 0, 0, 0, 0);
		setgdt(GAPM16CODE_SEL, NULL, 0, 0, 0, 0, 0);
		setgdt(GAPMDATA_SEL, NULL, 0, 0, 0, 0, 0);
@


1.33.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a851 2
		apm_set_ver(sc);

d859 2
@


1.33.2.11
log
@Merge with the trunk
@
text
@a349 2
	extern int perflevel;

a361 4

	/* restore hw.setperf */
	if (cpu_setperf != NULL)
		cpu_setperf(perflevel);
d743 1
a743 2
	if (ap->apm_code_len == 0 ||
	    (ap->apm_code32_base < IOM_BEGIN &&
@


1.33.2.12
log
@if multiple cpus, disconnect apm
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.33.2.11 2004/06/05 23:08:59 niklas Exp $	*/
a902 9

#ifdef MULTIPROCESSOR
	if (ncpus > 1) {
		apm_disconnect(sc);
		apm_dobusy = apm_doidle = 0;
		return;
	}
#endif

@


1.32
log
@explicitly round segments to a page boundary
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.31 2000/01/31 19:48:58 mickey Exp $	*/
d54 1
d313 2
d322 2
@


1.31
log
@bzero() in get_event too
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.30 2000/01/31 10:00:05 mickey Exp $	*/
d777 7
a783 5
		/* adjust code size limits */
		if (ap->apm_code_len >= 0x10000)
			ap->apm_code_len = 0xffff;
		if (ap->apm_code16_len >= 0x10000)
			ap->apm_code16_len = 0xffff;
@


1.30
log
@possibly uninitialized vasriable used in DEBUG code piece; from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.29 2000/01/31 02:04:35 mickey Exp $	*/
d172 1
@


1.29
log
@remove if0ed stinkpad's spinlock
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.28 2000/01/29 21:46:53 mickey Exp $	*/
d650 1
a650 1
	int rv;
@


1.28
log
@bring in some mods for apm1.2 proto;
account for 16bit and 32bit code segments at different bases;
leave interrupts enabled when calling apm bios;
a few more debugging printfs (ifdef'ed appropriately).
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.27 1999/11/07 17:39:15 provos Exp $	*/
d740 1
a740 5
#if stinkpads
	/* this is a trick to not configure on some stinkpads */
	if (ap->apm_code32_base != ap->apm_code16_base)
		return 0;
#endif
@


1.27
log
@add APM powerhooks.
from NetBSD, Sat Jun 26 08:25:25 1999 UTC by augustss:

Add powerhooks, i.e., the ability to register a function that will be
called when the machine does a suspend or resume.
XXX Will go away when Jason's kevents come to life.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.26 1999/02/28 05:53:13 deraadt Exp $	*/
d4 1
a70 1
#define STATIC /**/
a72 1
#define STATIC static
d125 11
a135 3
STATIC u_int apm_flags;
STATIC u_char apm_majver;
STATIC u_char apm_minver;
d137 1
a137 1
STATIC struct {
d150 29
a178 18
STATIC int apmcall __P((u_int, u_int, struct apmregs *));
STATIC void apm_power_print __P((struct apm_softc *, struct apmregs *));
STATIC void apm_event_handle __P((struct apm_softc *, struct apmregs *));
STATIC void apm_set_ver __P((struct apm_softc *));
STATIC void apm_periodic_check __P((void *));
/* STATIC void apm_disconnect __P((void *)); */
STATIC void apm_perror __P((const char *, struct apmregs *));
/* STATIC void apm_powmgt_enable __P((int onoff)); */
STATIC void apm_powmgt_engage __P((int onoff, u_int devid));
/* STATIC void apm_devpowmgt_enable __P((int onoff, u_int devid)); */
STATIC int apm_record_event __P((struct apm_softc *sc, u_int event_type));
STATIC const char *apm_err_translate __P((int code));

#define	apm_get_powstat(r) apmcall(APM_POWER_STATUS, APM_DEV_ALLDEVS, &r)
#define	apm_get_event(r) apmcall(APM_GET_PM_EVENT, 0, &r)
STATIC void	apm_standby __P((void));
STATIC void	apm_suspend __P((void));
STATIC void	apm_resume __P((struct apm_softc *, struct apmregs *));
d180 1
a180 1
STATIC const char *
d218 1
a218 1
STATIC void
d230 1
a230 1
STATIC void
d259 1
a259 1
		printf(" battery charge ");
d268 1
a268 1
			printf("critical");
d306 1
a306 1
STATIC void
d314 1
a314 1
STATIC void
d322 1
a322 1
STATIC void
d327 3
d341 1
a341 1
STATIC int
d352 1
a352 1
			"pushfl; cli\n\t"
d360 3
a362 1
			"lcall	%%cs:(%9)\n\t"
d369 3
a371 4
			  "=a" (r->ax), "=b" (r->bx), "=c" (r->cx), "=d" (r->dx)
			: "m" (f), "2" (dev), "3" (r->cx), "4" (r->dx),
			  "m" (apm_ep)
			: "cc", "memory");
d376 1
a376 8
int apm_standbys = 0;
int apm_userstandbys = 0;
int apm_suspends = 0;
int apm_battlow = 0;

static int apm_evindex = 0;

STATIC int
d383 3
a385 1
	if ((sc->sc_flags & SCFLAG_OPEN) == 0)
d387 4
a390 1
	if (sc->event_count == APM_NEVENTS)
d392 1
d403 1
a403 1
STATIC void
d410 1
a414 1
		(void) apm_set_powstate(APM_DEV_ALLDEVS, APM_LASTREQ_REJECTED);
d417 2
d422 5
a426 5
		if (apm_standbys || apm_suspends)
			DPRINTF(("damn fool BIOS did not wait for answer\n"));
		if (apm_record_event(sc, regs->bx)) {
			(void) apm_set_powstate(APM_DEV_ALLDEVS,
			    APM_LASTREQ_INPROG);
d428 2
a429 3
		} else
			(void) apm_set_powstate(APM_DEV_ALLDEVS,
			    APM_LASTREQ_REJECTED);
a432 1
		(void) apm_set_powstate(APM_DEV_ALLDEVS, APM_LASTREQ_REJECTED);
d435 2
d440 5
a444 5
		if (apm_standbys || apm_suspends)
			DPRINTF(("damn fool BIOS did not wait for answer\n"));
		if (apm_record_event(sc, regs->bx)) {
			(void) apm_set_powstate(APM_DEV_ALLDEVS,
			    APM_LASTREQ_INPROG);
d446 2
a447 3
		} else
			(void) apm_set_powstate(APM_DEV_ALLDEVS,
			    APM_LASTREQ_REJECTED);
d451 1
a451 1
		error = apm_get_powstat(nregs);
d487 13
d501 7
a507 1
		printf("APM nonstandard event code %x\n", regs->bx);
d511 1
a511 1
STATIC void
d518 4
a521 1
	while (apm_get_event(regs) == 0)
d526 1
d528 1
d532 1
d536 1
d538 1
a538 6
	if(apmerrors < 10)
		timeout(apm_periodic_check, sc, hz);
#ifdef DIAGNOSTIC
	else
		printf("APM: too many errors, turning off timeout\n");
#endif
d541 1
a541 2
#ifdef notused
STATIC void
a551 1
#endif
d553 1
a553 1
STATIC void
d570 1
a570 1
STATIC void
d645 1
a645 7
#ifdef APM_V10_ONLY
int apm_v11_enabled = 0;
#else
int apm_v11_enabled = 1;
#endif

STATIC void
d650 1
a650 1
	int error;
d653 1
a653 1
	regs.cx = 0x0101;	/* APM Version 1.1 */
d655 2
a656 2
	if (apm_v11_enabled && (error =
	    apmcall(APM_DRIVER_VERSION, APM_DEV_APM_BIOS, &regs)) == 0) {
d660 18
a677 2
		apm_majver = 1;
		apm_minver = 0;
d696 1
a696 1
STATIC void
a723 1
	    ba->bios_apmp->apm_detail & APM_BIOS_PM_DISABLED ||
d729 16
a744 3
	if (ap->apm_code32_base + ap->apm_code_len > IOM_END)
		ap->apm_code_len -= ap->apm_code32_base + ap->apm_code_len -
		    IOM_END;
d751 1
a751 2
	if (ap->apm_data_base + ap->apm_data_len > IOM_END)
	    ap->apm_data_len -= ap->apm_data_base + ap->apm_data_len - IOM_END;
d772 2
a773 1
	bus_space_handle_t ch, dh;
d779 7
d789 10
a798 8
		if ((ap->apm_code32_base <= ap->apm_data_base &&
		     ap->apm_code32_base+ap->apm_code_len >= ap->apm_data_base)
		  ||(ap->apm_code32_base >= ap->apm_data_base &&
		     ap->apm_data_base+ap->apm_data_len>=ap->apm_code32_base)){
			int l;
			l = max(ap->apm_data_base + ap->apm_data_len,
				ap->apm_code32_base + ap->apm_data_len) -
			    min(ap->apm_data_base, ap->apm_code32_base);
d800 5
a804 5
				min(ap->apm_data_base, ap->apm_code32_base),
				l, 1, &ch);
			dh = ch;
			if (ap->apm_data_base < ap->apm_code32_base)
				ch += ap->apm_code32_base - ap->apm_data_base;
d806 1
a806 1
				dh += ap->apm_data_base - ap->apm_code32_base;
d809 3
a811 6
			bus_space_map(ba->bios_memt,
				      ba->bios_apmp->apm_code32_base,
				      ba->bios_apmp->apm_code_len, 1, &ch);
			bus_space_map(ba->bios_memt,
				      ba->bios_apmp->apm_data_base,
				      ba->bios_apmp->apm_data_len, 1, &dh);
d813 10
a822 4
		setsegment(&dynamic_gdt[GAPM32CODE_SEL].sd, (void *)ch,
			   ap->apm_code_len-1, SDT_MEMERA, SEL_KPL, 1, 0);
		setsegment(&dynamic_gdt[GAPM16CODE_SEL].sd, (void *)ch,
			   ap->apm_code_len-1, SDT_MEMERA, SEL_KPL, 0, 0);
d824 2
a825 2
			   ap->apm_data_len-1, SDT_MEMRWA, SEL_KPL, 1, 0);
		DPRINTF((": flags %x code 32:%x/%x 16:%x/%x %x "
d827 4
a830 3
		    ap->apm_code32_base, ch, ap->apm_code16_base, ch,
		    ap->apm_code_len, ap->apm_data_base, dh, ap->apm_data_len,
		    ap->apm_entry, apm_ep.seg, ap->apm_entry+ch,
d832 3
a834 1
		apm_set_ver(sc);
d840 5
a844 10
#if 0
		/* doesn't seem to work, sigh. */
		apm_powmgt_engage(1, APM_DEV_DISPLAY(APM_DEV_ALLUNITS));
		apm_powmgt_engage(1, APM_DEV_DISK(APM_DEV_ALLUNITS));
		apm_powmgt_engage(1, APM_DEV_PARALLEL(APM_DEV_ALLUNITS));
		apm_powmgt_engage(1, APM_DEV_NETWORK(APM_DEV_ALLUNITS));
		apm_powmgt_engage(1, APM_DEV_PCMCIA(APM_DEV_ALLUNITS));
#endif
		
		if (apm_get_powstat(regs) == 0) {
d866 2
a867 1
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 || !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
d899 2
a900 1
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 || !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
d936 2
a937 1
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 || !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
d1000 1
a1000 1
		if (apm_get_powstat(regs) == 0) {
d1007 2
a1008 1
				powerp->battery_state = BATT_STATE(&regs);
a1011 1
				powerp->battery_state = APM_BATT_UNKNOWN;
d1022 2
d1049 2
a1050 1
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 || !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
@


1.26
log
@DEBUG should not affect apm.c
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.25 1999/02/23 04:10:12 marc Exp $	*/
d158 3
a160 2
#define	apm_suspend() apm_set_powstate(APM_DEV_ALLDEVS, APM_SYS_SUSPEND)
#define	apm_standby() apm_set_powstate(APM_DEV_ALLDEVS, APM_SYS_STANDBY)
d288 26
d441 1
a441 2
		inittodr(time.tv_sec);
		apm_record_event(sc, regs->bx);
d445 1
a445 2
		inittodr(time.tv_sec);
		apm_record_event(sc, regs->bx);
d449 1
a449 2
		inittodr(time.tv_sec);
		apm_record_event(sc, regs->bx);
d453 1
a453 2
		inittodr(time.tv_sec);
		apm_record_event(sc, regs->bx);
@


1.25
log
@apm battery status messages now suppressed until battery life
falls below 'machdep.apmwarn' percent.  This defaults to 10 percent
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.24 1999/01/06 01:31:20 kstailey Exp $	*/
d68 1
a68 1
#if defined(DEBUG) || defined(APMDEBUG)
@


1.24
log
@fix for "halt -p" and BIOS goes "no disk drives"
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.23 1998/11/15 16:36:49 art Exp $	*/
d79 5
d404 2
@


1.23
log
@use DPRINTF in more places to make things more readable. (don't require DEBUG to be defined if we want to debug apm)
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.22 1998/09/17 20:34:41 marc Exp $	*/
d530 4
a533 1
		return EIO;
@


1.22
log
@add NO_APMPRINT conditional
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.21 1998/07/18 02:40:33 marc Exp $	*/
a596 1
#ifdef DEBUG
d598 1
a598 2
		printf(" (slowidle)");
#endif
d642 1
a642 3
#ifdef DEBUG
		printf("%s: %x\n", ba->bios_dev, ba->bios_apmp->apm_detail);
#endif
d651 1
a651 3
#ifdef DEBUG
		printf("apm0: can't map code\n");
#endif
d659 1
a659 3
#ifdef DEBUG
		printf("apm0: can't map data\n");
#endif
d717 1
a717 2
#if defined(DEBUG) || defined(APMDEBUG)
		printf(": flags %x code 32:%x/%x 16:%x/%x %x "
d722 1
a722 2
		    sc->sc_dev.dv_xname);
#endif
@


1.21
log
@add ioctl to apm to set message display to one of three states:
1) default: print out all messages.  I made this the default so there
   would be no visable change to people who are used to what they have.

2) disable all messages.  This mode is set by apmd when it starts up.
   I think it is reasonable for apmd to disable the driver display
   because it is collecting the data and syslogging it.  Don't need
   to see it three and 4 times.

3) print percentage changes.  For those who have a _noisy_ machine
   such as me but don't want to see lots and lots of messages I added
   a mode where the messages will only be displayed if the estimated
   battery percenge changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.20 1998/04/27 23:39:31 deraadt Exp $	*/
d211 1
d279 1
@


1.20
log
@cleanup messages a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.19 1997/12/17 22:05:31 rees Exp $	*/
d86 1
d95 13
d211 1
d396 4
a399 1
		if (error == 0)
d851 23
@


1.19
log
@set sc before checking in open et al
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.18 1997/12/11 01:03:51 rees Exp $	*/
d185 1
a185 1
	printf("APM %s: %s (%d)\n", str,
d218 2
a219 2
	printf(" battery charge ");
	if (apm_minver == 0)
d240 1
a240 1
	else if (apm_minver >= 1) {
d242 1
a242 1
			printf("[no battery]");
d244 1
a262 2

	return;
d354 1
a354 1
						APM_LASTREQ_INPROG);
d358 1
a358 1
						APM_LASTREQ_REJECTED);
d362 1
a362 2
		(void) apm_set_powstate(APM_DEV_ALLDEVS,
					APM_LASTREQ_REJECTED);
d372 1
a372 1
						APM_LASTREQ_INPROG);
d376 1
a376 1
						APM_LASTREQ_REJECTED);
d457 1
a457 1
		    (apm_minver? APM_DEV_APM_BIOS : APM_MGT_ALL), &regs) != 0)
d473 1
a473 1
		printf("APM power mgmt engage (device %x): %s (%d)\n",
d632 1
a632 1
			IOM_END;
d634 1
a634 1
			  ap->apm_code_len, 1, &ch) != 0) {
d642 1
a642 2
		ap->apm_data_len -= ap->apm_data_base + ap->apm_data_len -
			IOM_END;
d644 1
a644 1
			  ap->apm_data_len, 1, &dh) != 0) {
@


1.18
log
@oops -- local change leaked out (but it doesn't hurt anything)
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.17 1997/12/11 00:58:44 rees Exp $	*/
d753 1
a753 1
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 || sc == NULL)
a755 2
	sc = apm_cd.cd_devs[APMUNIT(dev)];

d785 1
a785 1
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 || sc == NULL)
a787 2
	sc = apm_cd.cd_devs[APMUNIT(dev)];

d821 1
a821 1
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 || sc == NULL)
a823 2
	sc = apm_cd.cd_devs[APMUNIT(dev)];

d908 1
a908 1
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 || sc == NULL)
a910 2
	sc = apm_cd.cd_devs[APMUNIT(dev)];

@


1.17
log
@don't panic in apmopen if apm not configured
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.16 1997/12/03 00:19:32 rees Exp $	*/
a516 3
#ifdef HANDBOOK
int apmidleon = 0;
#else
a517 1
#endif
@


1.16
log
@fix printfs in apm_power_print
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.14 1997/10/24 06:49:19 mickey Exp $	*/
d754 1
a754 1
	struct apm_softc *sc = apm_cd.cd_devs[APMUNIT(dev)];
d757 1
a757 1
	if (APMUNIT(dev) != 0 || sc == NULL)
d760 2
d788 1
a788 1
	struct apm_softc *sc = apm_cd.cd_devs[APMUNIT(dev)];
d791 1
a791 1
	if (APMUNIT(dev) != 0 || sc == NULL)
d794 2
d821 1
a821 1
	struct apm_softc *sc = apm_cd.cd_devs[APMUNIT(dev)];
d829 1
a829 1
	if (APMUNIT(dev) != 0 || sc == NULL)
d832 2
d915 1
a915 1
	struct apm_softc *sc = apm_cd.cd_devs[APMUNIT(dev)];
d918 1
a918 1
	if (APMUNIT(dev) != 0 || sc == NULL)
d921 2
@


1.15
log
@config apm even if power mgmt is disengaged
@
text
@d222 1
a222 1
			printf("high\n");
d225 1
a225 1
			printf("low\n");
d228 1
a228 1
			printf("critical\n");
d231 1
a231 1
			printf("charging\n");
d234 1
a234 1
			printf("unknown\n");
d237 1
a237 1
			printf("undecoded (%x)\n", BATT_STATE(regs));
d246 1
a246 1
			if (BATT_FLAGS(regs) & APM_BATT_FLAG_LOW)
d248 1
a248 1
			if (BATT_FLAGS(regs) & APM_BATT_FLAG_CRITICAL)
d250 2
d253 1
a253 1
				printf("charging");
d255 1
a255 1
				printf(", estimated %d:%02d minutes\n",
d257 1
a257 1
				    BATT_REMAINING(regs)%60);
d517 3
d521 1
@


1.14
log
@fix the case when data/code segment is not in the ISA memory
hole, so map 'em separatelly (or together if they intersect)
and use that mapped region for segment creations...
must help on some machines to avoid weird apm errors
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.13 1997/10/22 23:37:10 mickey Exp $	*/
a622 1
	    ba->bios_apmp->apm_detail & APM_BIOS_PM_DISENGAGED ||
@


1.13
log
@support new libsa
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.12 1997/10/13 00:09:20 mickey Exp $	*/
a109 1
STATIC u_short	apminited;
d178 2
d188 2
d202 1
a202 1
	printf("%s: AC state: ", sc->sc_dev.dv_xname);
d205 1
a205 1
		printf("off\n");
d208 1
a208 1
		printf("on\n");
d211 1
a211 1
		printf("backup power\n");
d215 1
a215 1
		printf("unknown\n");
d218 1
a218 1
	printf("%s: battery charge state:", sc->sc_dev.dv_xname);
d237 1
a237 1
			printf("undecoded state %x\n", BATT_STATE(regs));
d242 1
a242 1
			printf(" no battery\n");
d245 1
a245 1
				printf(" high");
d247 1
a247 1
				printf(" low");
d249 1
a249 1
				printf(" critical");
d251 1
a251 2
				printf(" charging");
			printf("\n");
d253 1
a253 2
				printf("%s: estimated %d:%02d minutes\n",
				    sc->sc_dev.dv_xname,
d258 3
d438 8
a445 2
	apm_suspends = apm_standbys = apm_battlow = apm_userstandbys =0;
	timeout(apm_periodic_check, sc, hz);
d504 1
a504 1
	if (!apminited || (apm_minver == 0 && state > APM_SYS_OFF))
a514 3
#ifdef APM_NOIDLE
int apmidleon = 0;
#else
a515 1
#endif
d521 1
a521 1
	if (!apminited || !apmidleon)
d525 3
a527 1
	    apmcall(APM_CPU_BUSY, 0, &regs) != 0)
d529 3
d538 1
a538 1
	if (!apminited || !apmidleon)
d540 1
d542 3
a544 1
	if (apmcall(APM_CPU_IDLE, 0, &regs) != 0)
d546 3
a575 1
	apminited = 1;
d617 2
d620 19
a638 1
	if (apminited)
a639 5
	if (!(ba->bios_apmp->apm_detail & APM_BIOS_PM_DISABLED) &&
	    !(ba->bios_apmp->apm_detail & APM_BIOS_PM_DISENGAGED) &&
	    (ba->bios_apmp->apm_detail & APM_32BIT_SUPPORTED) &&
	    strcmp(ba->bios_dev, "apm") == 0) {
		return 1;
d641 14
a654 1
	return 0;
d663 2
a664 1
	bios_apminfo_t *ap = ((struct bios_attach_args *)aux)->bios_apmp;
d667 1
d676 26
a701 2
		setsegment(&dynamic_gdt[GAPM32CODE_SEL].sd,
			   (void *)ISA_HOLE_VADDR(ap->apm_code32_base),
d703 1
a703 2
		setsegment(&dynamic_gdt[GAPM16CODE_SEL].sd,
			   (void *)ISA_HOLE_VADDR(ap->apm_code16_base),
d705 1
a705 2
		setsegment(&dynamic_gdt[GAPMDATA_SEL].sd,
			   (void *)ISA_HOLE_VADDR(ap->apm_data_base),
d710 3
a712 7
		    ap->apm_code32_base, ISA_HOLE_VADDR(ap->apm_code32_base),
		    ap->apm_code16_base, ISA_HOLE_VADDR(ap->apm_code16_base),
		    ap->apm_code_len,
		    ap->apm_data_base, ISA_HOLE_VADDR(ap->apm_data_base),
		    ap->apm_data_len,
		    ap->apm_entry, apm_ep.seg,
		    ap->apm_entry+ISA_HOLE_VADDR(ap->apm_code32_base),
@


1.12
log
@zero 'struct apmregs regs;' that will fix a whole bunch of errors
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.11 1997/09/29 03:42:24 mickey Exp $	*/
d604 3
a606 3
	if (!(ba->apm_detail & APM_BIOS_PM_DISABLED) &&
	    !(ba->apm_detail & APM_BIOS_PM_DISENGAGED) &&
	    (ba->apm_detail & APM_32BIT_SUPPORTED) &&
d619 1
a619 1
	register struct bios_attach_args *ba = aux;
d626 2
a627 2
	if (ba->apm_detail & APM_32BIT_SUPPORTED) {
		apm_flags = ba->apm_detail;
d629 1
a629 1
		apm_ep.entry = ba->apm_entry;
d631 2
a632 2
			   (void *)ISA_HOLE_VADDR(ba->apm_code32_base),
			   ba->apm_code_len-1, SDT_MEMERA, SEL_KPL, 1, 0);
d634 2
a635 2
			   (void *)ISA_HOLE_VADDR(ba->apm_code16_base),
			   ba->apm_code_len-1, SDT_MEMERA, SEL_KPL, 0, 0);
d637 2
a638 2
			   (void *)ISA_HOLE_VADDR(ba->apm_data_base),
			   ba->apm_data_len-1, SDT_MEMRWA, SEL_KPL, 1, 0);
d642 7
a648 7
		    ba->apm_code32_base, ISA_HOLE_VADDR(ba->apm_code32_base),
		    ba->apm_code16_base, ISA_HOLE_VADDR(ba->apm_code16_base),
		    ba->apm_code_len,
		    ba->apm_data_base, ISA_HOLE_VADDR(ba->apm_data_base),
		    ba->apm_data_len,
		    ba->apm_entry, apm_ep.seg,
		    ba->apm_entry+ISA_HOLE_VADDR(ba->apm_code32_base),
@


1.11
log
@apm0 at bios0
configs will be updated
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.10 1997/09/24 22:18:12 mickey Exp $	*/
d444 1
d460 1
d480 1
d496 1
d517 1
d529 1
d547 1
d583 1
d778 1
@


1.10
log
@cdev_decl(apm) in machine/conf.h
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.9 1997/09/22 14:55:13 deraadt Exp $	*/
a36 1
#if NAPM > 0
d65 1
d107 4
a110 4
struct apm_connect_info apminfo = { 0 };
u_char apm_majver;
u_char apm_minver;
u_short	apminited;
d112 12
d125 1
a125 1
STATIC int apm_get_powstat __P((struct apmregs *));
a127 1
STATIC int apm_get_event __P((struct apmregs *));
a134 2
STATIC void apm_suspend __P((void));
STATIC void apm_standby __P((void));
d137 5
a141 1
STATIC void apm_get_powstate __P((u_int dev));
d145 1
a145 1
int code;
d181 2
a182 2
const char *str;
struct apmregs *regs;
d191 2
a192 2
struct apm_softc *sc;
struct apmregs *regs;
d260 40
a304 26
STATIC void
apm_get_powstate(dev)
u_int dev;
{
	struct apmregs regs;
	int rval;

	regs.bx = dev;
	rval = apmcall(APM_GET_POWER_STATE, &regs);
	if (rval == 0) {
		printf("apm dev %04x state %04x\n", dev, regs.cx);
	}
}

STATIC void
apm_suspend()
{
	(void) apm_set_powstate(APM_DEV_ALLDEVS, APM_SYS_SUSPEND);
}

STATIC void
apm_standby()
{
	(void) apm_set_powstate(APM_DEV_ALLDEVS, APM_SYS_STANDBY);
}

d309 2
a310 2
struct apm_softc *sc;
u_int event_type;
d330 2
a331 2
struct apm_softc *sc;
struct apmregs *regs;
d376 1
a376 1
		error = apm_get_powstat(&nregs);
a415 7
STATIC int
apm_get_event(regs)
struct apmregs *regs;
{
	return apmcall(APM_GET_PM_EVENT, regs);
}

d418 1
a418 1
void *arg;
d420 1
d422 2
a423 2
	struct apm_softc *sc = arg;
	while (apm_get_event(&regs) == 0) {
d425 1
a425 1
	};
d441 1
a441 1
int onoff;
a443 1
	regs.bx = apm_minver == 0 ? APM_MGT_ALL : APM_DEV_APM_BIOS;
d445 2
a446 1
	if (apmcall(APM_PWR_MGT_ENABLE, &regs) != 0)
d453 2
a454 2
int onoff;
u_int dev;
a458 1
	regs.bx = dev;
d460 1
a460 1
	if (apmcall(APM_PWR_MGT_ENGAGE, &regs) != 0)
d469 2
a470 2
int onoff;
u_int dev;
a474 1
	regs.bx = dev;
d479 1
a479 1
	if (apmcall(APM_DEVICE_MGMT_ENABLE, &regs) != 0)
d488 1
a488 1
u_int dev, state;
a492 1
	regs.bx = dev;
d494 1
a494 1
	if (apmcall(APM_SET_PWR_STATE, &regs) != 0) {
d513 2
a514 2
	if ((apminfo.apm_detail & APM_IDLE_SLOWS) &&
	    apmcall(APM_CPU_BUSY, &regs) != 0)
d524 1
a524 1
	if (apmcall(APM_CPU_IDLE, &regs) != 0)
a527 2
void *apm_sh;

d536 1
a536 1
struct apm_softc *self;
a541 1
	regs.bx = APM_DEV_APM_BIOS;
d543 2
a544 2
	if (apm_v11_enabled &&
	    (error = apmcall(APM_DRIVER_VERSION, &regs)) == 0) {
d551 1
a551 2
	printf(": Power Management spec V%d.%d",
	    apm_majver, apm_minver);
d553 1
a553 1
	if (apminfo.apm_detail & APM_IDLE_SLOWS) {
d562 1
a562 1
	if (apminfo.apm_detail & APM_BIOS_PM_DISABLED)
d564 1
a564 1
	if (apminfo.apm_detail & APM_BIOS_PM_DISENGAGED)
a569 8
STATIC int
apm_get_powstat(regs)
struct apmregs *regs;
{
	regs->bx = APM_DEV_ALLDEVS;
	return apmcall(APM_POWER_STATUS, regs);
}

d573 1
a573 1
void *xxx;
d576 2
a577 2
	regs.bx = apm_minver == 1 ? APM_DEV_ALLDEVS : APM_DEFAULTS_ALL;
	if (apmcall(APM_SYSTEM_DEFAULTS, &regs))
d580 1
a580 2
	regs.bx = APM_DEV_APM_BIOS;
	if (apmcall(APM_DISCONNECT, &regs))
d592 1
a592 1
	struct apm_attach_args *aaa = aux;
d596 4
a599 2
	if ((apminfo.apm_detail & APM_32BIT_SUPPORTED) &&
	    strcmp(aaa->aaa_busname, "apm") == 0) {
d611 2
a612 1
	struct apm_softc *apmsc = (void *)self;
d614 1
a614 1
	int error;
d618 4
a621 2
	if (apminfo.apm_detail & APM_32BIT_SUPPORTED) {
		apminfo.apm_segsel = GSEL(GAPM32CODE_SEL,SEL_KPL);
d623 2
a624 3
			   (void *)ISA_HOLE_VADDR(apminfo.apm_code32_seg_base),
			   apminfo.apm_code32_seg_len-1,
			   SDT_MEMERA, SEL_KPL, 1, 0);
d626 2
a627 3
			   (void *)ISA_HOLE_VADDR(apminfo.apm_code16_seg_base),
			   apminfo.apm_code32_seg_len-1,
			   SDT_MEMERA, SEL_KPL, 0, 0);
d629 2
a630 3
			   (void *)ISA_HOLE_VADDR(apminfo.apm_data_seg_base),
			   apminfo.apm_data_seg_len-1,
			   SDT_MEMRWA, SEL_KPL, 1, 0);
d632 10
a641 14
		printf(": detail %x 32b:%x/%x/%x 16b:%x/%x data %x/%x/%x ep %x (%x:%x)\n%s",
		    apminfo.apm_detail,
		    apminfo.apm_code32_seg_base,
		    ISA_HOLE_VADDR(apminfo.apm_code32_seg_base),
		    apminfo.apm_code32_seg_len,
		    apminfo.apm_code16_seg_base,
		    ISA_HOLE_VADDR(apminfo.apm_code16_seg_base),
		    apminfo.apm_data_seg_base,
		    ISA_HOLE_VADDR(apminfo.apm_data_seg_base),
		    apminfo.apm_data_seg_len,
		    apminfo.apm_entrypt,
		    apminfo.apm_segsel,
		    apminfo.apm_entrypt+ISA_HOLE_VADDR(apminfo.apm_code32_seg_base),
		    apmsc->sc_dev.dv_xname);
d643 1
a643 1
		apm_set_ver(apmsc);
d657 3
a659 3
		error = apm_get_powstat(&regs);
		if (error == 0) {
			apm_power_print(apmsc, &regs);
d663 1
a663 1
		apm_periodic_check(apmsc);
d677 1
a677 3
	int unit = APMUNIT(dev);
	int ctl = APMDEV(dev);
	struct apm_softc *sc;
d679 2
a680 4
	if (unit >= apm_cd.cd_ndevs)
		return ENXIO;
	sc = apm_cd.cd_devs[unit];
	if (!sc)
d683 1
a683 1
	switch (ctl) {
a709 1
	int ctl = APMDEV(dev);
d711 4
d716 2
a717 1
	switch (ctl) {
a739 1
	int error;
d747 4
d767 7
a773 1
		apm_get_powstate(actl->dev); /* XXX */
d787 1
a787 2
		error = apm_get_powstat(&regs);
		if (error == 0) {
d814 1
a814 1
			error = EIO;
d819 1
a819 1
		return ENOTTY;
d821 1
d833 4
a848 2

#endif /* NAPM > 0 */
@


1.9
log
@A/C -> AC
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.8 1997/09/22 12:07:45 deraadt Exp $	*/
a46 1
#include <sys/conf.h>
d55 1
a105 2

cdev_decl(apm);	/* XXX should it be int <sys/conf.h> ? */
@


1.8
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.7 1997/09/21 04:27:52 mickey Exp $	*/
d188 1
a188 1
	printf("%s: A/C state: ", sc->sc_dev.dv_xname);
@


1.7
log
@support new boots
add to your config:
bios0 at mainbus0
apm0 at mainbus0	# (if you are using APM)
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.6 1997/08/19 20:09:04 angelos Exp $	*/
d100 1
a100 1
    sizeof(struct apm_softc), apmprobe, apmattach
d174 2
a175 2
	       apm_err_translate(APM_ERR_CODE(regs)),
	       APM_ERR_CODE(regs));
d185 2
a186 2
		       sc->sc_dev.dv_xname,
		       BATT_LIFE(regs));
d241 3
a243 3
				       sc->sc_dev.dv_xname,
				       BATT_REMAINING(regs) / 60,
				       BATT_REMAINING(regs)%60);
d258 8
a265 7
    struct apmregs regs;
    int rval;
    regs.bx = dev;
    rval = apmcall(APM_GET_POWER_STATE, &regs);
    if (rval == 0) {
	printf("apm dev %04x state %04x\n", dev, regs.cx);
    }
d321 1
a321 1
		    DPRINTF(("damn fool BIOS did not wait for answer\n"));
d340 1
a340 1
		    DPRINTF(("damn fool BIOS did not wait for answer\n"));
d395 1
a395 1
    return apmcall(APM_GET_PM_EVENT, regs);
d444 2
a445 2
		       dev, apm_err_translate(APM_ERR_CODE(&regs)),
		       APM_ERR_CODE(&regs));
d456 1
a456 1
	    return;
d464 2
a465 2
		       dev, apm_err_translate(APM_ERR_CODE(&regs)),
		       APM_ERR_CODE(&regs));
d475 1
a475 1
	    return EINVAL;
d496 1
a496 1
	    return;
d507 1
a507 1
	    return;
d539 1
a539 1
	       apm_majver, apm_minver);
d543 1
a543 1
	/* not relevant much */
d548 1
a548 1
	    apm_dobusy = 0;
d628 13
a640 13
		       apminfo.apm_detail,
		       apminfo.apm_code32_seg_base,
		       ISA_HOLE_VADDR(apminfo.apm_code32_seg_base),
		       apminfo.apm_code32_seg_len,
		       apminfo.apm_code16_seg_base,
		       ISA_HOLE_VADDR(apminfo.apm_code16_seg_base),
		       apminfo.apm_data_seg_base,
		       ISA_HOLE_VADDR(apminfo.apm_data_seg_base),
		       apminfo.apm_data_seg_len,
		       apminfo.apm_entrypt,
		       apminfo.apm_segsel,
		       apminfo.apm_entrypt+ISA_HOLE_VADDR(apminfo.apm_code32_seg_base),
		       apmsc->sc_dev.dv_xname);
d799 1
a799 1
						powerp->battery_state = APM_BATTERY_ABSENT;
d801 1
a801 1
				    powerp->minutes_left = BATT_REMAINING(&regs);
@


1.6
log
@ifdef'ed out 3 functions that were not used and were causing
compilation problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.5 1997/07/08 02:52:25 mickey Exp $	*/
a612 21
		apminfo.apm_code32_seg_base <<= 4;
		apminfo.apm_code16_seg_base <<= 4;
		apminfo.apm_data_seg_base <<= 4;
		/* something is still amiss in the limit-fetch in the boot
		   loader; it returns incorrect (too small) limits.
		   for now, force them to max size. */
		apminfo.apm_code32_seg_len = 65536;
		apminfo.apm_data_seg_len = 65536;
#if 0
		switch ((APM_MAJOR_VERS(apminfo.apm_detail) << 8) +
			APM_MINOR_VERS(apminfo.apm_detail)) {
		case 0x0100:
			apminfo.apm_code32_seg_len = 65536;
			apminfo.apm_data_seg_len = 65536;
			break;
		default:
			if (apminfo.apm_data_seg_len == 0)
				apminfo.apm_data_seg_len = 65536;
			break;
		}
#endif
d619 1
a619 1
			   65536-1,	/* just in case */
@


1.5
log
@don't show battery estimate if there is no one
honour apmnoidle.... warnings suxx
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.4 1997/01/02 12:24:35 mickey Exp $	*/
d121 1
a121 1
STATIC void apm_disconnect __P((void *));
d123 1
a123 1
STATIC void apm_powmgt_enable __P((int onoff));
d125 1
a125 1
STATIC void apm_devpowmgt_enable __P((int onoff, u_int devid));
d418 1
d429 1
d447 1
d466 1
d565 1
d581 1
@


1.4
log
@prevent system from suspend/standby twice.
(netbsd pr#3005, yasufu-i@@is.aist-nara.ac.jp)
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.3 1996/10/21 11:37:53 mickey Exp $	*/
d228 1
a228 1
			printf(" no battery");
d238 6
a244 6
		printf("\n");
		if (BATT_REM_VALID(regs))
			printf("%s: estimated %d:%02d minutes\n",
			       sc->sc_dev.dv_xname,
			       BATT_REMAINING(regs) / 60,
			       BATT_REMAINING(regs)%60);
d490 1
a490 1
	if (!apminited)
@


1.3
log
@-Wall happiness
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.2 1996/07/15 07:33:16 mickey Exp $	*/
d314 2
a315 2
		(void) apm_record_event(sc, regs->bx);
		apm_userstandbys++;
d333 2
a334 2
		apm_suspends++;
		apm_record_event(sc, regs->bx);
@


1.2
log
@add extern dynamic_gdt decl.
it does not even compile w/o that!
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
d107 2
d129 2
@


1.1
log
@Pull in John Kohl's [jtk@@netbsd.org] most recent (15Apr96) APM and PCMCIA work
(original PCMCIA framework  by Stefan Grefen [grefen@@convex.com]).
@
text
@d1 1
a1 1
/*	$NetBSD $	*/
d593 1
@
