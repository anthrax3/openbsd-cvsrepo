head	1.37;
access;
symbols
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.37.0.2
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.34.0.6
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.31.0.12
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.8
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.6
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.4
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.2
	OPENBSD_5_0:1.30.0.2
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.26.0.16
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.12
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.14
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.10
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.8
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.6
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.4
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.23.0.8
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.6
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.19
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.8
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.6
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2016.03.24.04.56.08;	author guenther;	state Exp;
branches;
next	1.36;
commitid	VRKppYthMQboSLVW;

1.36
date	2016.03.03.12.41.30;	author naddy;	state Exp;
branches;
next	1.35;
commitid	Ykztt9UU7jxBEqeD;

1.35
date	2015.09.08.07.12.56;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	UsnEcDGT4QqqoPvB;

1.34
date	2014.12.09.06.58.28;	author doug;	state Exp;
branches;
next	1.33;
commitid	yWAxzpQP2PPpYlfT;

1.33
date	2014.12.02.18.13.10;	author tedu;	state Exp;
branches;
next	1.32;
commitid	ZYUxNRICiD9sC1vn;

1.32
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.31;
commitid	uKVPYMN2MLxdZxzH;

1.31
date	2011.11.07.15.41.33;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2011.08.03.16.11.31;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2011.04.15.15.08.19;	author chl;	state Exp;
branches;
next	1.28;

1.28
date	2011.03.12.03.52.26;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2010.11.20.20.21.13;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.11.13.21.12;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2006.01.05.20.09.18;	author matthieu;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.01.12.26.45;	author grange;	state Exp;
branches
	1.23.6.1
	1.23.8.1;
next	1.22;

1.22
date	2003.08.15.20.32.13;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.23.27.47;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.28.00.49.13;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.02.00.19.18;	author nate;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.28.16.13.28;	author art;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.04.08.57.47;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.21.12.57.42;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.16.22.16.24;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.05.23.25.41;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.22.23.36.51;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.19.18.31.30;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.23.02.14.36;	author mickey;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.06.08.22.25.19;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.02.26.04.41.13;	author art;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	98.07.09.18.22.15;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.09.10.05.30.45;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.05.07.07.21.56;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.11.17.59.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.34;	author deraadt;	state Exp;
branches;
next	;

1.6.6.1
date	2001.04.18.16.07.24;	author niklas;	state Exp;
branches;
next	1.6.6.2;

1.6.6.2
date	2001.07.04.10.16.42;	author niklas;	state Exp;
branches;
next	1.6.6.3;

1.6.6.3
date	2001.07.15.15.10.55;	author ho;	state Exp;
branches;
next	1.6.6.4;

1.6.6.4
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.6.6.5;

1.6.6.5
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.6.6.6;

1.6.6.6
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.6.6.7;

1.6.6.7
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.6.6.8;

1.6.6.8
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.6.6.9;

1.6.6.9
date	2003.05.13.19.42.08;	author ho;	state Exp;
branches;
next	1.6.6.10;

1.6.6.10
date	2003.06.07.11.11.37;	author ho;	state Exp;
branches;
next	1.6.6.11;

1.6.6.11
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2001.02.23.17.07.21;	author jason;	state Exp;
branches;
next	;

1.17.2.1
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.10.29.00.28.04;	author art;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;

1.23.6.1
date	2006.01.13.04.12.15;	author brad;	state Exp;
branches;
next	;

1.23.8.1
date	2006.01.13.04.42.10;	author brad;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Delete i386_{get,set}_ioperm(2) APIs and underlying sysarch(2) bits.
They're no longer used by anything and should let us simplify the TSS
handling.

ok mikeb@@ naddy@@
@
text
@/*	$OpenBSD: sys_machdep.c,v 1.36 2016/03/03 12:41:30 naddy Exp $	*/
/*	$NetBSD: sys_machdep.c,v 1.28 1996/05/03 19:42:29 christos Exp $	*/

/*-
 * Copyright (c) 1995 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)sys_machdep.c	5.5 (Berkeley) 1/19/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <sys/time.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/user.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/mtio.h>
#include <sys/buf.h>
#include <sys/signal.h>
#include <sys/malloc.h>

#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/gdt.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/sysarch.h>

#ifdef VM86
#include <machine/vm86.h>
#endif

extern struct vm_map *kernel_map;

int i386_iopl(struct proc *, void *, register_t *);

#ifdef APERTURE
extern int allowaperture;
#endif

int
i386_iopl(struct proc *p, void *args, register_t *retval)
{
	int error;
	struct trapframe *tf = p->p_md.md_regs;
	struct i386_iopl_args ua;

	if ((error = suser(p, 0)) != 0)
		return error;
#ifdef APERTURE
	if (!allowaperture && securelevel > 0)
		return EPERM;
#else
	if (securelevel > 0)
		return EPERM;
#endif

	if ((error = copyin(args, &ua, sizeof(ua))) != 0)
		return error;

	if (ua.iopl)
		tf->tf_eflags |= PSL_IOPL;
	else
		tf->tf_eflags &= ~PSL_IOPL;

	return 0;
}

uint32_t
i386_get_threadbase(struct proc *p, int which)
{
	struct segment_descriptor *sdp =
	    &p->p_addr->u_pcb.pcb_threadsegs[which];
	return sdp->sd_hibase << 24 | sdp->sd_lobase;
}

int
i386_set_threadbase(struct proc *p, uint32_t base, int which)
{
	struct segment_descriptor *sdp;

	/*
	 * We can't place a limit on the segment used by the library
	 * thread register (%gs) because the ELF ABI for i386 places
	 * data structures both before and after base pointer, using
	 * negative offsets for some bits (the static (load-time)
	 * TLS slots) and non-negative for others (the TCB block,
	 * including the pointer to the TLS dynamic thread vector).
	 * Protection must be provided by the paging subsystem.
	 */
	sdp = &p->p_addr->u_pcb.pcb_threadsegs[which];
	setsegment(sdp, (void *)base, 0xfffff, SDT_MEMRWA, SEL_UPL, 1, 1);

	if (p == curproc) {
		curcpu()->ci_gdt[which == TSEG_FS ? GUFS_SEL : GUGS_SEL].sd
		    = *sdp;
	}
	return 0;
}

int
sys_sysarch(struct proc *p, void *v, register_t *retval)
{
	struct sys_sysarch_args /* {
		syscallarg(int) op;
		syscallarg(void *) parms;
	} */ *uap = v;
	int error = 0;

	switch(SCARG(uap, op)) {
	case I386_IOPL:
		error = i386_iopl(p, SCARG(uap, parms), retval);
		break;

#ifdef VM86
	case I386_VM86:
		error = i386_vm86(p, SCARG(uap, parms), retval);
		break;
#endif

	case I386_GET_FSBASE:
	      {
		uint32_t base = i386_get_threadbase(p, TSEG_FS);

		error = copyout(&base, SCARG(uap, parms), sizeof(base));
		break;
	      }

	case I386_SET_FSBASE:
	      {
		uint32_t base;

		if ((error = copyin(SCARG(uap, parms), &base, sizeof(base))))
			break;
		error = i386_set_threadbase(p, base, TSEG_FS);
		break;
	      }

	case I386_GET_GSBASE:
	      {
		uint32_t base = i386_get_threadbase(p, TSEG_GS);

		error = copyout(&base, SCARG(uap, parms), sizeof(base));
		break;
	      }

	case I386_SET_GSBASE:
	      {
		uint32_t base;

		if ((error = copyin(SCARG(uap, parms), &base, sizeof(base))))
			break;
		error = i386_set_threadbase(p, base, TSEG_GS);
		break;
	      }

	default:
		error = EINVAL;
		break;
	}
	return (error);
}
@


1.36
log
@Remove option USER_LDT and everything depending on it.
Remove machdep.userldt sysctl.
Remove i386_[gs]et_ldt syscall stub from libi386.
Remove i386_[gs]et_ldt regression test.

ok mlarkin@@ millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.35 2015/09/08 07:12:56 deraadt Exp $	*/
a72 2
int i386_get_ioperm(struct proc *, void *, register_t *);
int i386_set_ioperm(struct proc *, void *, register_t *);
a105 36
int
i386_get_ioperm(struct proc *p, void *args, register_t *retval)
{
	int error;
	struct pcb *pcb = &p->p_addr->u_pcb;
	struct i386_get_ioperm_args ua;

	if ((error = copyin(args, &ua, sizeof(ua))) != 0)
		return (error);

	return copyout(pcb->pcb_iomap, ua.iomap, sizeof(pcb->pcb_iomap));
}

int
i386_set_ioperm(struct proc *p, void *args, register_t *retval)
{
	int error;
	struct pcb *pcb = &p->p_addr->u_pcb;
	struct i386_set_ioperm_args ua;

	if ((error = suser(p, 0)) != 0)
		return error;

#ifdef APERTURE
	if (!allowaperture && securelevel > 0)
		return EPERM;
#else
	if (securelevel > 0)
		return EPERM;
#endif
	if ((error = copyin(args, &ua, sizeof(ua))) != 0)
		return (error);

	return copyin(ua.iomap, pcb->pcb_iomap, sizeof(pcb->pcb_iomap));
}

a149 8
		break;

	case I386_GET_IOPERM:
		error = i386_get_ioperm(p, SCARG(uap, parms), retval);
		break;

	case I386_SET_IOPERM:
		error = i386_set_ioperm(p, SCARG(uap, parms), retval);
@


1.35
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.34 2014/12/09 06:58:28 doug Exp $	*/
a75 242
#ifdef USER_LDT

#ifdef LDT_DEBUG
static void i386_print_ldt(int, const struct segment_descriptor *);

static void
i386_print_ldt(int i, const struct segment_descriptor *d)
{
	printf("[%d] lolimit=0x%x, lobase=0x%x, type=%u, dpl=%u, p=%u, "
	    "hilimit=0x%x, xx=%x, def32=%u, gran=%u, hibase=0x%x\n",
	    i, d->sd_lolimit, d->sd_lobase, d->sd_type, d->sd_dpl, d->sd_p,
	    d->sd_hilimit, d->sd_xx, d->sd_def32, d->sd_gran, d->sd_hibase);
}
#endif

int
i386_get_ldt(struct proc *p, void *args, register_t *retval)
{
	int error;
	pmap_t pmap = p->p_vmspace->vm_map.pmap;
	int nldt, num;
	union descriptor *lp, *cp;
	struct i386_get_ldt_args ua;

	if (user_ldt_enable == 0)
		return (ENOSYS);

	if ((error = copyin(args, &ua, sizeof(ua))) != 0)
		return (error);

#ifdef	LDT_DEBUG
	printf("i386_get_ldt: start=%d num=%d descs=%p\n", ua.start,
	    ua.num, ua.desc);
#endif

	if (ua.start < 0 || ua.num < 0 || ua.start > 8192 || ua.num > 8192 ||
	    ua.start + ua.num > 8192)
		return (EINVAL);

	cp = mallocarray(ua.num, sizeof(union descriptor), M_TEMP, M_WAITOK);

	if (pmap->pm_flags & PMF_USER_LDT) {
		nldt = pmap->pm_ldt_len;
		lp = pmap->pm_ldt;
	} else {
		nldt = NLDT;
		lp = ldt;
	}

	if (ua.start > nldt) {
		free(cp, M_TEMP, ua.num * sizeof(union descriptor));
		return (EINVAL);
	}

	lp += ua.start;
	num = min(ua.num, nldt - ua.start);
#ifdef LDT_DEBUG
	{
		int i;
		for (i = 0; i < num; i++)
			i386_print_ldt(i, &lp[i].sd);
	}
#endif

	memcpy(cp, lp, num * sizeof(union descriptor));

	error = copyout(cp, ua.desc, num * sizeof(union descriptor));
	if (error == 0)
		*retval = num;

	free(cp, M_TEMP, ua.num * sizeof(union descriptor));
	return (error);
}

int
i386_set_ldt(struct proc *p, void *args, register_t *retval)
{
	int error, i, n;
	struct pcb *pcb = &p->p_addr->u_pcb;
	pmap_t pmap = p->p_vmspace->vm_map.pmap;
	struct i386_set_ldt_args ua;
	union descriptor *descv;
	size_t old_len, new_len, ldt_len;
	union descriptor *old_ldt, *new_ldt;

	if (user_ldt_enable == 0)
		return (ENOSYS);

	if ((error = copyin(args, &ua, sizeof(ua))) != 0)
		return (error);

	if (ua.start < 0 || ua.num < 0 || ua.start > 8192 || ua.num > 8192 ||
	    ua.start + ua.num > 8192)
		return (EINVAL);

	descv = mallocarray(ua.num, sizeof(*descv), M_TEMP, M_NOWAIT);
	if (descv == NULL)
		return (ENOMEM);

	if ((error = copyin(ua.desc, descv, sizeof (*descv) * ua.num)) != 0)
		goto out;

	/* Check descriptors for access violations. */
	for (i = 0; i < ua.num; i++) {
		union descriptor *desc = &descv[i];

		switch (desc->sd.sd_type) {
		case SDT_SYSNULL:
			desc->sd.sd_p = 0;
			break;
		case SDT_SYS286CGT:
		case SDT_SYS386CGT:
			/*
			 * Only allow call gates targeting a segment
			 * in the LDT or a user segment in the fixed
			 * part of the gdt.  Segments in the LDT are
			 * constrained (below) to be user segments.
			 */
			if (desc->gd.gd_p != 0 &&
			    !ISLDT(desc->gd.gd_selector) &&
			    ((IDXSEL(desc->gd.gd_selector) >= NGDT) ||
			     (gdt[IDXSEL(desc->gd.gd_selector)].sd.sd_dpl !=
				 SEL_UPL))) {
				error = EACCES;
				goto out;
			}
			break;
		case SDT_MEMEC:
		case SDT_MEMEAC:
		case SDT_MEMERC:
		case SDT_MEMERAC:
			/* Must be "present" if executable and conforming. */
			if (desc->sd.sd_p == 0) {
				error = EACCES;
				goto out;
			}
			break;
		case SDT_MEMRO:
		case SDT_MEMROA:
		case SDT_MEMRW:
		case SDT_MEMRWA:
		case SDT_MEMROD:
		case SDT_MEMRODA:
		case SDT_MEMRWD:
		case SDT_MEMRWDA:
		case SDT_MEME:
		case SDT_MEMEA:
		case SDT_MEMER:
		case SDT_MEMERA:
			break;
		default:
			/*
			 * Make sure that unknown descriptor types are
			 * not marked present.
			 */
			if (desc->sd.sd_p != 0) {
				error = EACCES;
				goto out;
			}
			break;
		}

		if (desc->sd.sd_p != 0) {
			/* Only user (ring-3) descriptors may be present. */
			if (desc->sd.sd_dpl != SEL_UPL) {
				error = EACCES;
				goto out;
			}
		}
	}

	/* allocate user ldt */
	if (pmap->pm_ldt == 0 || (ua.start + ua.num) > pmap->pm_ldt_len) {
		if (pmap->pm_flags & PMF_USER_LDT)
			ldt_len = pmap->pm_ldt_len;
		else
			ldt_len = 512;
		while ((ua.start + ua.num) > ldt_len)
			ldt_len *= 2;
		new_len = ldt_len * sizeof(union descriptor);

		new_ldt = (union descriptor *)uvm_km_alloc(kernel_map,
		    new_len);
		if (new_ldt == NULL) {
			error = ENOMEM;
			goto out;
		}

		if (pmap->pm_ldt != NULL && ldt_len <= pmap->pm_ldt_len) {
			/*
			 * Another thread (re)allocated the LDT to
			 * sufficient size while we were blocked in
			 * uvm_km_alloc. Oh well. The new entries
			 * will quite probably not be right, but
			 * hey.. not our problem if user applications
			 * have race conditions like that.
			 */
			uvm_km_free(kernel_map, (vaddr_t)new_ldt, new_len);
			goto copy;
		}

		old_ldt = pmap->pm_ldt;

		if (old_ldt != NULL) {
			old_len = pmap->pm_ldt_len * sizeof(union descriptor);
		} else {
			old_len = NLDT * sizeof(union descriptor);
			old_ldt = ldt;
		}

		memcpy(new_ldt, old_ldt, old_len);
		memset((caddr_t)new_ldt + old_len, 0, new_len - old_len);

		if (old_ldt != ldt)
			uvm_km_free(kernel_map, (vaddr_t)old_ldt, old_len);

		pmap->pm_ldt = new_ldt;
		pmap->pm_ldt_len = ldt_len;

		if (pmap->pm_flags & PMF_USER_LDT)
			ldt_free(pmap);
		else
			pmap->pm_flags |= PMF_USER_LDT;
		ldt_alloc(pmap, new_ldt, new_len);
		pcb->pcb_ldt_sel = pmap->pm_ldt_sel;
		if (pcb == curpcb)
			lldt(pcb->pcb_ldt_sel);

	}
copy:
	/* Now actually replace the descriptors. */
	for (i = 0, n = ua.start; i < ua.num; i++, n++)
		pmap->pm_ldt[n] = descv[i];

	*retval = ua.start;

out:
	free(descv, M_TEMP, ua.num * sizeof(*descv));
	return (error);
}
#endif	/* USER_LDT */

a185 10
#ifdef	USER_LDT
	case I386_GET_LDT:
		error = i386_get_ldt(p, SCARG(uap, parms), retval);
		break;

	case I386_SET_LDT:
		error = i386_set_ldt(p, SCARG(uap, parms), retval);
		break;
#endif

@


1.34
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.33 2014/12/02 18:13:10 tedu Exp $	*/
d126 1
a126 1
		free(cp, M_TEMP, 0);
d146 1
a146 1
	free(cp, M_TEMP, 0);
d313 1
a313 1
	free(descv, M_TEMP, 0);
@


1.33
log
@delete all the simplelocks. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.32 2014/07/12 18:44:41 tedu Exp $	*/
d115 1
a115 1
	cp = malloc(ua.num * sizeof(union descriptor), M_TEMP, M_WAITOK);
d171 1
a171 1
	descv = malloc(sizeof (*descv) * ua.num, M_TEMP, M_NOWAIT);
@


1.32
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.31 2011/11/07 15:41:33 guenther Exp $	*/
a116 2
	simple_lock(&pmap->pm_lock);

a125 1
		simple_unlock(&pmap->pm_lock);
a140 1
	simple_unlock(&pmap->pm_lock);
a247 1
	simple_lock(&pmap->pm_lock);
a256 1
		simple_unlock(&pmap->pm_lock);
a262 1
		simple_lock(&pmap->pm_lock);
a308 2

	simple_unlock(&pmap->pm_lock);
@


1.31
log
@Lift the copyout() from i386_get_threadbase() to sys_sysarch(), so that
it can be used correctly from linux_sys_get_thread_area() and tcb.h.
linux_sys_set_thread_area() should use the copied in value instead of
deferencing SCARG() again.  i386_set_threadbase() should only update
curcpu's GDT if it's being called for curproc.

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.30 2011/08/03 16:11:31 guenther Exp $	*/
d129 1
a129 1
		free(cp, M_TEMP);
d150 1
a150 1
	free(cp, M_TEMP);
d322 1
a322 1
	free(descv, M_TEMP);
@


1.30
log
@Fix linux compat breakage: can't copyin() from kernel-space, so
move that out of i386_set_threadbase(), and have clone() pass NULL
to fork1() for the child func argument so that it gets the child
proc pointer.

Report and verification by pirofti@@, heavy lifting by matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.29 2011/04/15 15:08:19 chl Exp $	*/
d395 2
a396 2
int
i386_get_threadbase(struct proc *p, void *args, int which)
d400 1
a400 3
	uint32_t base = sdp->sd_hibase << 24 | sdp->sd_lobase;

	return copyout(&base, args, sizeof(base));
d419 5
a423 1
	curcpu()->ci_gdt[which == TSEG_FS ? GUFS_SEL : GUGS_SEL].sd = *sdp;
d466 4
a469 1
		error = i386_get_threadbase(p, SCARG(uap, parms), TSEG_FS);
d471 1
d484 4
a487 1
		error = i386_get_threadbase(p, SCARG(uap, parms), TSEG_GS);
d489 1
@


1.29
log
@Do not check malloc return value against NULL, as M_WAITOK is used.

ok pirofti@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.28 2011/03/12 03:52:26 guenther Exp $	*/
a74 2
int i386_get_threadbase(struct proc *, void *, int);
int i386_set_threadbase(struct proc *, void *, int);
d406 1
a406 1
i386_set_threadbase(struct proc *p, void *args, int which)
a407 2
	int error;
	uint32_t base;
a409 3
	if ((error = copyin(args, &base, sizeof(base))) != 0)
		return error;

d468 6
a473 1
		error = i386_set_threadbase(p, SCARG(uap, parms), TSEG_FS);
d475 1
d482 6
a487 1
		error = i386_set_threadbase(p, SCARG(uap, parms), TSEG_GS);
d489 1
@


1.28
log
@Provide distinct segments for the %fs and %gs selectors to use by
default, with per-rthread base offsets and with sysarch() functions,
I386_{GET,SET}_{FS,GS}BASE, for fetching and setting those base
offsets.  This is necessary for both rthread and Linux compat support.

suggestions from kettenis@@, prodding from pirofti@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.27 2010/11/20 20:21:13 miod Exp $	*/
a117 2
	if (cp == NULL)
		return ENOMEM;
@


1.27
log
@Check uvm_km_alloc() return values; pmap_fork() will currently panic,
while i386_set_ldt() can fail gracefully. To be improved eventually.
From mpech@@ sometime ago. ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.26 2006/09/19 11:06:33 jsg Exp $	*/
d75 2
d400 35
d471 16
@


1.26
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.25 2006/05/11 13:21:12 mickey Exp $	*/
d267 4
@


1.25
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.24 2006/01/05 20:09:18 matthieu Exp $	*/
d82 1
a82 3
i386_print_ldt(i, d)
	int  i;
	const struct segment_descriptor *d;
d92 1
a92 4
i386_get_ldt(p, args, retval)
	struct proc *p;
	void *args;
	register_t *retval;
d157 1
a157 4
i386_set_ldt(p, args, retval)
	struct proc *p;
	void *args;
	register_t *retval;
d330 1
a330 4
i386_iopl(p, args, retval)
	struct proc *p;
	void *args;
	register_t *retval;
d358 1
a358 4
i386_get_ioperm(p, args, retval)
	struct proc *p;
	void *args;
	register_t *retval;
d371 1
a371 4
i386_set_ioperm(p, args, retval)
	struct proc *p;
	void *args;
	register_t *retval;
d394 1
a394 4
sys_sysarch(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
@


1.24
log
@Check securelevel and machdep.allowaperture for i386_set_ioperm() the
same way as for i386_iopl(). ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.23 2004/02/01 12:26:45 grange Exp $	*/
d424 1
a424 1
	case I386_GET_LDT: 
d428 1
a428 1
	case I386_SET_LDT: 
d433 1
a433 1
	case I386_IOPL: 
d437 1
a437 1
	case I386_GET_IOPERM: 
d441 1
a441 1
	case I386_SET_IOPERM: 
@


1.23
log
@Sync user ldt code with NetBSD:
- finally remove it from pcb, it's a pmap thing only
- more sanity checks
- better lockin
- may be something else

Fixes panics when using apps requiring it (mplayer-win32 e.g.).
Problem found and test espie@@.
OKs from miod@@ (sshhh, don't tell anyone) and art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.22 2003/08/15 20:32:13 tedu Exp $	*/
d397 7
@


1.23.8.1
log
@MFC:
Fix by matthieu@@

Check securelevel and machdep.allowaperture for i386_set_ioperm() the
same way as for i386_iopl().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.23 2004/02/01 12:26:45 grange Exp $	*/
a396 7
#ifdef APERTURE
	if (!allowaperture && securelevel > 0)
		return EPERM;
#else
	if (securelevel > 0)
		return EPERM;
#endif
@


1.23.6.1
log
@MFC:
Fix by matthieu@@

Check securelevel and machdep.allowaperture for i386_set_ioperm() the
same way as for i386_iopl().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.23 2004/02/01 12:26:45 grange Exp $	*/
a396 7
#ifdef APERTURE
	if (!allowaperture && securelevel > 0)
		return EPERM;
#else
	if (securelevel > 0)
		return EPERM;
#endif
@


1.22
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.21 2003/06/02 23:27:47 millert Exp $	*/
d52 1
a71 4
#ifdef USER_LDT
int i386_get_ldt(struct proc *, void *, register_t *);
int i386_set_ldt(struct proc *, void *, register_t *);
#endif
d77 8
a84 7
/*
 * If the process has a local LDT, deallocate it, and restore the default from
 * proc0.     
 */   
void
i386_user_cleanup(pcb)
	struct pcb *pcb;
d86 4
a89 8

	ldt_free(pcb->pcb_pmap);
	pcb->pcb_ldt_sel = GSEL(GLDT_SEL, SEL_KPL);
	if (pcb == curpcb)
		lldt(pcb->pcb_ldt_sel);
	uvm_km_free(kernel_map, (vaddr_t)pcb->pcb_ldt,
	    (pcb->pcb_ldt_len * sizeof(union descriptor))); 
	pcb->pcb_ldt = 0;
d91 1
d100 1
a100 1
	struct pcb *pcb = &p->p_addr->u_pcb;
d102 1
a102 1
	union descriptor *lp;
d111 1
a111 1
#ifdef LDTDEBUG
d116 2
a117 1
	if (ua.start < 0 || ua.num < 0)
d120 9
a128 3
	if (pcb->pcb_flags & PCB_USER_LDT) {
		nldt = pcb->pcb_ldt_len;
		lp = pcb->pcb_ldt;
d134 3
a136 1
	if (ua.start > nldt)
d138 1
d142 7
d150 6
a155 3
	error = copyout(lp, ua.desc, num * sizeof(union descriptor));
	if (error)
		return (error);
d157 2
a158 2
	*retval = num;
	return (0);
a169 1
	int fsslot, gsslot;
d171 3
a173 1
	union descriptor desc;
d181 2
a182 8
#ifdef	LDT_DEBUG
	printf("i386_set_ldt: start=%d num=%d descs=%p\n", ua.start,
	    ua.num, ua.desc);
#endif

	if (ua.start < 0 || ua.num < 0 ||
	    ua.start > 8192 || ua.num > 8192 ||
	    (ua.start + ua.num) > 8192)
d185 3
a187 46
	/*
	 * XXX LOCKING
	 */

	/* allocate user ldt */
	if (pmap->pm_ldt == 0 || (ua.start + ua.num) > pmap->pm_ldt_len) {
		size_t old_len, new_len;
		union descriptor *old_ldt, *new_ldt;

		if (pmap->pm_flags & PMF_USER_LDT) {
			old_len = pmap->pm_ldt_len * sizeof(union descriptor);
			old_ldt = pmap->pm_ldt;
		} else {
			old_len = NLDT * sizeof(union descriptor);
			old_ldt = ldt;
			pmap->pm_ldt_len = 512;
		}
		while ((ua.start + ua.num) > pmap->pm_ldt_len)
			pmap->pm_ldt_len *= 2;
		new_len = pmap->pm_ldt_len * sizeof(union descriptor);
		new_ldt = (union descriptor *)uvm_km_alloc(kernel_map, new_len);
		bcopy(old_ldt, new_ldt, old_len);
		bzero((caddr_t)new_ldt + old_len, new_len - old_len);
		pmap->pm_ldt = new_ldt;

		if (pmap->pm_flags & PMF_USER_LDT)
			ldt_free(pmap);
		else
			pmap->pm_flags |= PMF_USER_LDT;
		ldt_alloc(pmap, new_ldt, new_len);
		pcb->pcb_ldt_sel = pmap->pm_ldt_sel;
		if (pcb == curpcb)
			lldt(pcb->pcb_ldt_sel);

		/*
		 * XXX Need to notify other processors which may be
		 * XXX currently using this pmap that they need to
		 * XXX re-load the LDT.
		 */

		if (old_ldt != ldt)
			uvm_km_free(kernel_map, (vaddr_t)old_ldt, old_len);
#ifdef LDT_DEBUG
		printf("i386_set_ldt(%d): new_ldt=%p\n", p->p_pid, new_ldt);
#endif
	}
d189 2
a190 5
	if (pcb == curpcb)
		savectx(curpcb);
	fsslot = IDXSEL(pcb->pcb_fs);
	gsslot = IDXSEL(pcb->pcb_gs);
	error = 0;
d193 2
a194 3
	for (i = 0, n = ua.start; i < ua.num; i++, n++) {
		if ((error = copyin(&ua.desc[i], &desc, sizeof(desc))) != 0)
			return (error);
d196 1
a196 1
		switch (desc.sd.sd_type) {
d198 1
a198 1
			desc.sd.sd_p = 0;
d208 8
a215 8
			if (desc.gd.gd_p != 0 && !ISLDT(desc.gd.gd_selector) &&
			    ((IDXSEL(desc.gd.gd_selector) >= NGDT) ||
			     (gdt[IDXSEL(desc.gd.gd_selector)].sd.sd_dpl !=
				 SEL_UPL)))
				return (EACCES);
			/* Can't replace in use descriptor with gate. */
			if (n == fsslot || n == gsslot)
				return (EBUSY);
d222 4
a225 2
			if (desc.sd.sd_p == 0)
				return (EACCES);
d233 2
d241 8
a248 3
			/* Only care if it's present. */
			if (desc.sd.sd_p != 0)
				return (EACCES);
d252 1
a252 1
		if (desc.sd.sd_p != 0) {
d254 40
a293 2
			if (desc.sd.sd_dpl != SEL_UPL)
				return (EACCES);
d295 2
a296 3
			/* Must be "present" if in use. */
			if (n == fsslot || n == gsslot)
				return (EBUSY);
d298 19
d318 1
a318 1

d320 2
a321 3
	for (i = 0, n = ua.start; i < ua.num; i++, n++) {
		if ((error = copyin(&ua.desc[i], &desc, sizeof(desc))) != 0)
			goto out;
d323 1
a323 2
		pmap->pm_ldt[n] = desc;
	}
d328 1
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.20 2003/03/28 00:49:13 miod Exp $	*/
d320 1
a320 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d367 1
a367 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.20
log
@Add a sysctl to option USER_LDT, to control its behaviour, which will be
disabled by default.

Enable with sysctl -w machdep.userldt=1

This will allow people to use the few ports that require this functionality
to work without requiring the user to recompile a kernel.

The option USER_LDT remains in order to not increase size on the
installation media. It is now enabled in GENERIC.

Per espie@@'s idea, but my diff was much simpler than his; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.19 2002/08/02 00:19:18 nate Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.19
log
@prevent integer overflow by verifying that ua.num is not too large.
ok niels, millert, art
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.18 2002/03/14 01:26:33 millert Exp $	*/
d114 3
d163 3
d204 1
a204 1
		if (pmap->pm_flags & PCB_USER_LDT)
d207 1
a207 1
			pmap->pm_flags |= PCB_USER_LDT;
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.17 2001/11/28 16:13:28 art Exp $	*/
d168 3
a170 3
	if (ua.start < 0 || ua.num < 0)
		return (EINVAL);
	if (ua.start > 8192 || (ua.start + ua.num) > 8192)
@


1.17
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.16 2001/11/06 19:53:14 miod Exp $	*/
d76 2
a77 2
int i386_get_ldt __P((struct proc *, void *, register_t *));
int i386_set_ldt __P((struct proc *, void *, register_t *));
d79 3
a81 3
int i386_iopl __P((struct proc *, void *, register_t *));
int i386_get_ioperm __P((struct proc *, void *, register_t *));
int i386_set_ioperm __P((struct proc *, void *, register_t *));
@


1.17.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.17 2001/11/28 16:13:28 art Exp $	*/
d76 2
a77 2
int i386_get_ldt(struct proc *, void *, register_t *);
int i386_set_ldt(struct proc *, void *, register_t *);
d79 3
a81 3
int i386_iopl(struct proc *, void *, register_t *);
int i386_get_ioperm(struct proc *, void *, register_t *);
int i386_set_ioperm(struct proc *, void *, register_t *);
@


1.17.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.17.2.1 2002/06/11 03:35:53 art Exp $	*/
d168 3
a170 3
	if (ua.start < 0 || ua.num < 0 ||
	    ua.start > 8192 || ua.num > 8192 ||
	    (ua.start + ua.num) > 8192)
@


1.17.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a113 3
	if (user_ldt_enable == 0)
		return (ENOSYS);

a159 3
	if (user_ldt_enable == 0)
		return (ENOSYS);

d198 1
a198 1
		if (pmap->pm_flags & PMF_USER_LDT)
d201 1
a201 1
			pmap->pm_flags |= PMF_USER_LDT;
@


1.16
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.15 2001/09/19 20:50:56 mickey Exp $	*/
d73 1
a73 1
extern vm_map_t kernel_map;
@


1.15
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.14 2001/07/04 08:57:47 niklas Exp $	*/
a59 1
#include <vm/vm.h>
@


1.14
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.28 1996/05/03 19:42:29 christos Exp $	*/
a60 2
#include <vm/vm_kern.h>

@


1.13
log
@Finish what Theo started (a char * to void * conversion)
@
text
@d1 1
@


1.12
log
@sysarch() takes a void *
@
text
@d105 1
a105 1
i386_get_ldt(p, void, retval)
d107 1
a107 1
	char *args;
@


1.11
log
@PMAP_NEW and UVM are no longer optional on i386.
@
text
@d78 2
a79 2
int i386_get_ldt __P((struct proc *, char *, register_t *));
int i386_set_ldt __P((struct proc *, char *, register_t *));
d81 3
a83 3
int i386_iopl __P((struct proc *, char *, register_t *));
int i386_get_ioperm __P((struct proc *, char *, register_t *));
int i386_set_ioperm __P((struct proc *, char *, register_t *));
d105 1
a105 1
i386_get_ldt(p, args, retval)
d152 1
a152 1
	char *args;
d313 1
a313 1
	char *args;
d344 1
a344 1
	char *args;
d360 1
a360 1
	char *args;
d384 1
a384 1
		syscallarg(char *) parms;
@


1.10
log
@Merge in NetBSD's PMAP_NEW, still disabled
@
text
@a61 1
#if defined(UVM)
a62 1
#endif
a94 1
#ifdef PMAP_NEW
a95 3
#else
	ldt_free(pcb);
#endif
a98 1
#if defined(UVM)
a100 4
#else
	kmem_free(kernel_map, (vm_offset_t)pcb->pcb_ldt,
	    (pcb->pcb_ldt_len * sizeof(union descriptor))); 
#endif
a156 1
#ifdef PMAP_NEW
a157 1
#endif
a158 3
#ifndef PMAP_NEW
	int s;
#endif
a179 1
#ifdef PMAP_NEW
a180 3
#else
	if (pcb->pcb_ldt == 0 || (ua.start + ua.num) > pcb->pcb_ldt_len) {
#endif
a183 1
#ifdef PMAP_NEW
a186 5
#else
		if (pcb->pcb_flags & PCB_USER_LDT) {
			old_len = pcb->pcb_ldt_len * sizeof(union descriptor);
			old_ldt = pcb->pcb_ldt;
#endif
a189 1
#ifdef PMAP_NEW
a190 3
#else
			pcb->pcb_ldt_len = 512;
#endif
a191 1
#ifdef PMAP_NEW
a194 6
#else
		while ((ua.start + ua.num) > pcb->pcb_ldt_len)
			pcb->pcb_ldt_len *= 2;
		new_len = pcb->pcb_ldt_len * sizeof(union descriptor);
#endif
#if defined(UVM)
a195 3
#else
		new_ldt = (union descriptor *)kmem_alloc(kernel_map, new_len);
#endif
a197 1
#ifdef PMAP_NEW
a205 9
#else
		pcb->pcb_ldt = new_ldt;

		if (pcb->pcb_flags & PCB_USER_LDT)
			ldt_free(pcb);
		else
			pcb->pcb_flags |= PCB_USER_LDT;
		ldt_alloc(pcb, new_ldt, new_len);
#endif
a215 1
#if defined(UVM)
a216 3
#else
			kmem_free(kernel_map, (vaddr_t)old_ldt, old_len);
#endif
a290 4
#ifndef PMAP_NEW
	s = splhigh();
#endif

a295 1
#ifdef PMAP_NEW
a296 3
#else
		pcb->pcb_ldt[n] = desc;
#endif
a301 3
#ifndef PMAP_NEW
	splx(s);
#endif
@


1.9
log
@validate gate targets; sommerfeld, mycroft
@
text
@d97 3
d101 1
d130 2
a131 2
#ifdef	DEBUG
	printf("i386_get_ldt: start=%d num=%d descs=%x\n", ua.start,
d168 3
d172 1
d174 1
d181 2
a182 2
#ifdef	DEBUG
	printf("i386_set_ldt: start=%d num=%d descs=%x\n", ua.start,
d191 4
d196 3
d200 1
d204 5
d212 1
d216 3
d220 1
d222 5
d230 1
d238 10
d255 1
d259 6
d269 1
a269 1
			kmem_free(kernel_map, (vm_offset_t)old_ldt, old_len);
d271 2
a272 2
#ifdef DEBUG
		printf("i386_set_ldt(%d): new_ldt=%x\n", p->p_pid, new_ldt);
d345 1
d347 1
d354 3
d358 1
d364 1
d366 1
@


1.8
log
@remove obsolete vtrace guts; art@@
@
text
@d243 11
@


1.8.2.1
log
@Pull in patch from current:
Errata (022), Fix (deraadt):
validate gate targets; sommerfeld, mycroft
@
text
@a242 11
			/*
			 * Only allow call gates targeting a segment
			 * in the LDT or a user segment in the fixed
			 * part of the gdt.  Segments in the LDT are
			 * constrained (below) to be user segments.
			 */
			if (desc.gd.gd_p != 0 && !ISLDT(desc.gd.gd_selector) &&
			    ((IDXSEL(desc.gd.gd_selector) >= NGDT) ||
			     (gdt[IDXSEL(desc.gd.gd_selector)].sd.sd_dpl !=
				 SEL_UPL)))
				return (EACCES);
@


1.7
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@a53 1
#include <sys/trace.h>
a85 58

#ifdef TRACE
int	nvualarm;

void
vdoualarm(arg)
	int arg;
{
	register struct proc *p;

	p = pfind(arg);
	if (p)
		psignal(p, 16);
	nvualarm--;
}

int
sys_vtrace(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct sys_vtrace_args /* {
		syscallarg(int) request;
		syscallarg(int) value;
	} */ *uap = v;

	switch (SCARG(uap, request)) {

	case VTR_DISABLE:		/* disable a trace point */
	case VTR_ENABLE:		/* enable a trace point */
		if (SCARG(uap, value) < 0 || SCARG(uap, value) >= TR_NFLAGS)
			return (EINVAL);
		*retval = traceflags[SCARG(uap, value)];
		traceflags[SCARG(uap, value)] = SCARG(uap, request);
		break;

	case VTR_VALUE:		/* return a trace point setting */
		if (SCARG(uap, value) < 0 || SCARG(uap, value) >= TR_NFLAGS)
			return (EINVAL);
		*retval = traceflags[SCARG(uap, value)];
		break;

	case VTR_UALARM:	/* set a real-time ualarm, less than 1 min */
		if (SCARG(uap, value) <= 0 || SCARG(uap, value) > 60 * hz ||
		    nvualarm > 5)
			return (EINVAL);
		nvualarm++;
		timeout(vdoualarm, (caddr_t)p->p_pid, SCARG(uap, value));
		break;

	case VTR_STAMP:
		trace(TR_STAMP, SCARG(uap, value), p->p_pid);
		break;
	}
	return (0);
}
#endif
@


1.6
log
@some allocation changes, name changes, etc for uvm
@
text
@d48 1
@


1.6.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@a47 1
#include <sys/signalvar.h>
d53 1
d87 58
a154 3
#ifdef PMAP_NEW
	ldt_free(pcb->pcb_pmap);
#else
a155 1
#endif
d184 2
a185 2
#ifdef LDTDEBUG
	printf("i386_get_ldt: start=%d num=%d descs=%p\n", ua.start,
a221 3
#ifdef PMAP_NEW
	pmap_t pmap = p->p_vmspace->vm_map.pmap;
#endif
a222 1
#ifndef PMAP_NEW
a223 1
#endif
d230 2
a231 2
#ifdef	LDT_DEBUG
	printf("i386_set_ldt: start=%d num=%d descs=%p\n", ua.start,
a239 4
	/*
	 * XXX LOCKING
	 */

a240 3
#ifdef PMAP_NEW
	if (pmap->pm_ldt == 0 || (ua.start + ua.num) > pmap->pm_ldt_len) {
#else
a241 1
#endif
a244 5
#ifdef PMAP_NEW
		if (pmap->pm_flags & PMF_USER_LDT) {
			old_len = pmap->pm_ldt_len * sizeof(union descriptor);
			old_ldt = pmap->pm_ldt;
#else
a247 1
#endif
a250 3
#ifdef PMAP_NEW
			pmap->pm_ldt_len = 512;
#else
a251 1
#endif
a252 5
#ifdef PMAP_NEW
		while ((ua.start + ua.num) > pmap->pm_ldt_len)
			pmap->pm_ldt_len *= 2;
		new_len = pmap->pm_ldt_len * sizeof(union descriptor);
#else
a255 1
#endif
a262 10
#ifdef PMAP_NEW
		pmap->pm_ldt = new_ldt;

		if (pmap->pm_flags & PCB_USER_LDT)
			ldt_free(pmap);
		else
			pmap->pm_flags |= PCB_USER_LDT;
		ldt_alloc(pmap, new_ldt, new_len);
		pcb->pcb_ldt_sel = pmap->pm_ldt_sel;
#else
a269 1
#endif
a272 6
		/*
		 * XXX Need to notify other processors which may be
		 * XXX currently using this pmap that they need to
		 * XXX re-load the LDT.
		 */

d277 1
a277 1
			kmem_free(kernel_map, (vaddr_t)old_ldt, old_len);
d279 2
a280 2
#ifdef LDT_DEBUG
		printf("i386_set_ldt(%d): new_ldt=%p\n", p->p_pid, new_ldt);
a300 11
			/*
			 * Only allow call gates targeting a segment
			 * in the LDT or a user segment in the fixed
			 * part of the gdt.  Segments in the LDT are
			 * constrained (below) to be user segments.
			 */
			if (desc.gd.gd_p != 0 && !ISLDT(desc.gd.gd_selector) &&
			    ((IDXSEL(desc.gd.gd_selector) >= NGDT) ||
			     (gdt[IDXSEL(desc.gd.gd_selector)].sd.sd_dpl !=
				 SEL_UPL)))
				return (EACCES);
a341 1
#ifndef PMAP_NEW
a342 1
#endif
a348 3
#ifdef PMAP_NEW
		pmap->pm_ldt[n] = desc;
#else
a349 1
#endif
a354 1
#ifndef PMAP_NEW
a355 1
#endif
@


1.6.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d62 1
d64 1
d80 2
a81 2
int i386_get_ldt __P((struct proc *, void *, register_t *));
int i386_set_ldt __P((struct proc *, void *, register_t *));
d83 3
a85 3
int i386_iopl __P((struct proc *, void *, register_t *));
int i386_get_ioperm __P((struct proc *, void *, register_t *));
int i386_set_ioperm __P((struct proc *, void *, register_t *));
d97 1
d99 3
d105 1
d108 4
d118 1
a118 1
	void *args;
d163 1
a163 1
	void *args;
d168 1
d170 1
d172 3
d196 1
d198 3
d204 1
d208 5
d216 1
d218 3
d222 1
d226 6
d233 3
d238 1
d247 9
d266 1
d268 3
d345 4
d354 1
d356 3
d364 3
d378 1
a378 1
	void *args;
d409 1
a409 1
	void *args;
d425 1
a425 1
	void *args;
d449 1
a449 1
		syscallarg(void *) parms;
@


1.6.6.3
log
@Add $OpenBSD$.
@
text
@a0 1
/*	$OpenBSD$	*/
@


1.6.6.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.6.6.3 2001/07/15 15:10:55 ho Exp $	*/
d61 2
@


1.6.6.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 1
@


1.6.6.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.6.6.5 2001/11/13 21:00:52 niklas Exp $	*/
d73 1
a73 1
extern struct vm_map *kernel_map;
@


1.6.6.7
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d76 2
a77 2
int i386_get_ldt(struct proc *, void *, register_t *);
int i386_set_ldt(struct proc *, void *, register_t *);
d79 3
a81 3
int i386_iopl(struct proc *, void *, register_t *);
int i386_get_ioperm(struct proc *, void *, register_t *);
int i386_set_ioperm(struct proc *, void *, register_t *);
@


1.6.6.8
log
@Sync the SMP branch with 3.3
@
text
@d168 3
a170 3
	if (ua.start < 0 || ua.num < 0 ||
	    ua.start > 8192 || ua.num > 8192 ||
	    (ua.start + ua.num) > 8192)
@


1.6.6.9
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.6.6.8 2003/03/27 23:26:55 niklas Exp $	*/
a113 3
	if (user_ldt_enable == 0)
		return (ENOSYS);

a159 3
	if (user_ldt_enable == 0)
		return (ENOSYS);

d198 1
a198 1
		if (pmap->pm_flags & PMF_USER_LDT)
d201 1
a201 1
			pmap->pm_flags |= PMF_USER_LDT;
@


1.6.6.10
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_machdep.c,v 1.6.6.9 2003/05/13 19:42:08 ho Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6.6.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a51 1
#include <sys/malloc.h>
d71 4
d80 8
d89 7
a95 12
#ifdef LDT_DEBUG
static void i386_print_ldt(int, const struct segment_descriptor *);

static void
i386_print_ldt(i, d)
	int  i;
	const struct segment_descriptor *d;
{
	printf("[%d] lolimit=0x%x, lobase=0x%x, type=%u, dpl=%u, p=%u, "
	    "hilimit=0x%x, xx=%x, def32=%u, gran=%u, hibase=0x%x\n",
	    i, d->sd_lolimit, d->sd_lobase, d->sd_type, d->sd_dpl, d->sd_p,
	    d->sd_hilimit, d->sd_xx, d->sd_def32, d->sd_gran, d->sd_hibase);
a96 1
#endif
d105 1
a105 1
	pmap_t pmap = p->p_vmspace->vm_map.pmap;
d107 1
a107 1
	union descriptor *lp, *cp;
d116 1
a116 1
#ifdef	LDT_DEBUG
d121 1
a121 2
	if (ua.start < 0 || ua.num < 0 || ua.start > 8192 || ua.num > 8192 ||
	    ua.start + ua.num > 8192)
d124 3
a126 9
	cp = malloc(ua.num * sizeof(union descriptor), M_TEMP, M_WAITOK);
	if (cp == NULL)
		return ENOMEM;

	simple_lock(&pmap->pm_lock);

	if (pmap->pm_flags & PMF_USER_LDT) {
		nldt = pmap->pm_ldt_len;
		lp = pmap->pm_ldt;
d132 1
a132 3
	if (ua.start > nldt) {
		simple_unlock(&pmap->pm_lock);
		free(cp, M_TEMP);
a133 1
	}
a136 7
#ifdef LDT_DEBUG
	{
		int i;
		for (i = 0; i < num; i++)
			i386_print_ldt(i, &lp[i].sd);
	}
#endif
d138 3
a140 6
	memcpy(cp, lp, num * sizeof(union descriptor));
	simple_unlock(&pmap->pm_lock);

	error = copyout(cp, ua.desc, num * sizeof(union descriptor));
	if (error == 0)
		*retval = num;
d142 2
a143 2
	free(cp, M_TEMP);
	return (error);
d155 1
d157 1
a157 3
	union descriptor *descv;
	size_t old_len, new_len, ldt_len;
	union descriptor *old_ldt, *new_ldt;
d165 8
a172 2
	if (ua.start < 0 || ua.num < 0 || ua.start > 8192 || ua.num > 8192 ||
	    ua.start + ua.num > 8192)
d175 3
a177 3
	descv = malloc(sizeof (*descv) * ua.num, M_TEMP, M_NOWAIT);
	if (descv == NULL)
		return (ENOMEM);
d179 48
a226 2
	if ((error = copyin(ua.desc, descv, sizeof (*descv) * ua.num)) != 0)
		goto out;
d229 3
a231 2
	for (i = 0; i < ua.num; i++) {
		union descriptor *desc = &descv[i];
d233 1
a233 1
		switch (desc->sd.sd_type) {
d235 1
a235 1
			desc->sd.sd_p = 0;
d245 8
a252 8
			if (desc->gd.gd_p != 0 &&
			    !ISLDT(desc->gd.gd_selector) &&
			    ((IDXSEL(desc->gd.gd_selector) >= NGDT) ||
			     (gdt[IDXSEL(desc->gd.gd_selector)].sd.sd_dpl !=
				 SEL_UPL))) {
				error = EACCES;
				goto out;
			}
d259 2
a260 4
			if (desc->sd.sd_p == 0) {
				error = EACCES;
				goto out;
			}
a267 2
		case SDT_MEMRWD:
		case SDT_MEMRWDA:
d274 3
a276 8
			/*
			 * Make sure that unknown descriptor types are
			 * not marked present.
			 */
			if (desc->sd.sd_p != 0) {
				error = EACCES;
				goto out;
			}
d280 1
a280 1
		if (desc->sd.sd_p != 0) {
d282 6
a287 4
			if (desc->sd.sd_dpl != SEL_UPL) {
				error = EACCES;
				goto out;
			}
d291 4
a294 55
	/* allocate user ldt */
	simple_lock(&pmap->pm_lock);
	if (pmap->pm_ldt == 0 || (ua.start + ua.num) > pmap->pm_ldt_len) {
		if (pmap->pm_flags & PMF_USER_LDT)
			ldt_len = pmap->pm_ldt_len;
		else
			ldt_len = 512;
		while ((ua.start + ua.num) > ldt_len)
			ldt_len *= 2;
		new_len = ldt_len * sizeof(union descriptor);

		simple_unlock(&pmap->pm_lock);
		new_ldt = (union descriptor *)uvm_km_alloc(kernel_map,
		    new_len);
		simple_lock(&pmap->pm_lock);

		if (pmap->pm_ldt != NULL && ldt_len <= pmap->pm_ldt_len) {
			/*
			 * Another thread (re)allocated the LDT to
			 * sufficient size while we were blocked in
			 * uvm_km_alloc. Oh well. The new entries
			 * will quite probably not be right, but
			 * hey.. not our problem if user applications
			 * have race conditions like that.
			 */
			uvm_km_free(kernel_map, (vaddr_t)new_ldt, new_len);
			goto copy;
		}

		old_ldt = pmap->pm_ldt;

		if (old_ldt != NULL) {
			old_len = pmap->pm_ldt_len * sizeof(union descriptor);
		} else {
			old_len = NLDT * sizeof(union descriptor);
			old_ldt = ldt;
		}

		memcpy(new_ldt, old_ldt, old_len);
		memset((caddr_t)new_ldt + old_len, 0, new_len - old_len);

		if (old_ldt != ldt)
			uvm_km_free(kernel_map, (vaddr_t)old_ldt, old_len);

		pmap->pm_ldt = new_ldt;
		pmap->pm_ldt_len = ldt_len;

		if (pmap->pm_flags & PMF_USER_LDT)
			ldt_free(pmap);
		else
			pmap->pm_flags |= PMF_USER_LDT;
		ldt_alloc(pmap, new_ldt, new_len);
		pcb->pcb_ldt_sel = pmap->pm_ldt_sel;
		if (pcb == curpcb)
			lldt(pcb->pcb_ldt_sel);
d296 1
a297 6
copy:
	/* Now actually replace the descriptors. */
	for (i = 0, n = ua.start; i < ua.num; i++, n++)
		pmap->pm_ldt[n] = descv[i];

	simple_unlock(&pmap->pm_lock);
a301 1
	free(descv, M_TEMP);
d320 1
a320 1
	if ((error = suser(p, 0)) != 0)
d367 1
a367 1
	if ((error = suser(p, 0)) != 0)
@


1.5
log
@never set PSL_IOPL at high securelevel (except the one xf86 case, controlled by the aperture driver; problem noted by csapuntz
@
text
@d62 4
d159 4
d165 1
d256 3
d260 1
d274 3
d278 1
@


1.4
log
@make compile w/ TRACE enabled
@
text
@d343 4
d359 7
@


1.3
log
@sync with 0504; prototype changes
@
text
@d86 12
a107 1
	int vdoualarm();
a137 11
}

vdoualarm(arg)
	int arg;
{
	register struct proc *p;

	p = pfind(arg);
	if (p)
		psignal(p, 16);
	nvualarm--;
@


1.2
log
@from netbsd; VM86 support, by John Kohl, touched up a bit by charles
@
text
@d1 1
a1 1
/*	$NetBSD: sys_machdep.c,v 1.27 1996/01/08 13:51:36 mycroft Exp $	*/
d75 8
d86 1
d172 1
a172 1
	if (error = copyin(args, &ua, sizeof(ua)))
d197 2
a198 1
	if (error = copyout(lp, ua.desc, num * sizeof(union descriptor)))
d218 1
a218 1
	if (error = copyin(args, &ua, sizeof(ua)))
d271 1
d275 1
a275 1
		if (error = copyin(&ua.desc[i], &desc, sizeof(desc)))
d329 1
a329 1
		if (error = copyin(&ua.desc[i], &desc, sizeof(desc)))
d353 1
a353 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d356 1
a356 1
	if (error = copyin(args, &ua, sizeof(ua)))
d377 1
a377 1
	if (error = copyin(args, &ua, sizeof(ua)))
d393 1
a393 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d396 1
a396 1
	if (error = copyin(args, &ua, sizeof(ua)))
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: sys_machdep.c,v 1.25.2.1 1995/10/15 06:54:02 mycroft Exp $	*/
d69 4
d277 8
d425 6
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
