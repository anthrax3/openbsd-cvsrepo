head	1.37;
access;
symbols
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.37.0.4
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.34.0.18
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.14
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.12
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.10
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.8
	OPENBSD_5_0:1.34.0.6
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.4
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.33.0.8
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.10
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.6
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.4
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.30.0.2
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.37
date	2015.09.08.07.12.56;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	UsnEcDGT4QqqoPvB;

1.36
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.35;
commitid	uzzBR7hz9ncd4O6G;

1.35
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.34;
commitid	uKVPYMN2MLxdZxzH;

1.34
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.07.03.50.42;	author gwk;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.27.03.03.37;	author gwk;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.24.17.12.26;	author gwk;	state Exp;
branches;
next	1.30;

1.30
date	2006.12.20.17.50.40;	author gwk;	state Exp;
branches;
next	1.29;

1.29
date	2006.12.12.23.14.27;	author dim;	state Exp;
branches;
next	1.28;

1.28
date	2006.10.19.19.29.04;	author tom;	state Exp;
branches;
next	1.27;

1.27
date	2006.10.19.10.55.56;	author tom;	state Exp;
branches;
next	1.26;

1.26
date	2006.09.29.21.09.25;	author gwk;	state Exp;
branches;
next	1.25;

1.25
date	2006.09.25.22.28.11;	author gwk;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.16.05.58.50;	author gwk;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.13.00.32.35;	author gwk;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.27.04.46.12;	author gwk;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.11.13.21.11;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.02.16.14.51;	author pat;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.18.03.29.47;	author gwk;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.18.02.14.33;	author gwk;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.15.05.17.17;	author gwk;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.15.05.13.54;	author gwk;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.15.05.01.15;	author gwk;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.15.04.57.02;	author gwk;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.15.04.25.12;	author gwk;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.04.03.32.56;	author uwe;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.20.12.08.59;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.15.19.56.48;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.28.17.48.02;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.26.11.22.12;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.28.07.14.31;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.28.07.11.13;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.28.07.03.41;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.20.16.38.51;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2004.08.05.04.56.05;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.14.05.38.37;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.14.05.34.14;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.37
log
@sizes for free(); ok semarie
@
text
@/* $OpenBSD: powernow-k7.c,v 1.36 2014/09/14 14:17:23 jsg Exp $ */

/*
 * Copyright (c) 2004 Martin Végiard.
 * Copyright (c) 2004-2005 Bruno Ducrot
 * Copyright (c) 2004 FUKUDA Nobuhiko <nfukuda@@spa.is.uec.ac.jp>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* AMD POWERNOW K7 driver */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/sysctl.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/bus.h>

#include <dev/isa/isareg.h>
#include <i386/isa/isa_machdep.h>

#include "acpicpu.h"

#if NACPICPU > 0
#include <dev/acpi/acpidev.h>
#include <dev/acpi/acpivar.h>
#endif

#define BIOS_START			0xe0000
#define	BIOS_LEN			0x20000
#define BIOS_STEP			16

/*
 * MSRs and bits used by PowerNow! technology
 */
#define MSR_AMDK7_FIDVID_CTL		0xc0010041
#define MSR_AMDK7_FIDVID_STATUS		0xc0010042
#define AMD_PN_FID_VID			0x06
#define AMD_ERRATA_A0_CPUSIG		0x660

#define PN7_FLAG_ERRATA_A0		0x01
#define PN7_FLAG_DESKTOP_VRM		0x02

/* Bitfields used by K7 */
#define PN7_PSB_VERSION			0x12
#define PN7_CTR_FID(x)			((x) & 0x1f)
#define PN7_CTR_VID(x)			(((x) & 0x1f) << 8)
#define PN7_CTR_FIDC			0x00010000
#define PN7_CTR_VIDC			0x00020000
#define PN7_CTR_FIDCHRATIO		0x00100000
#define PN7_CTR_SGTC(x)			(((uint64_t)(x) & 0x000fffff) << 32)

#define PN7_STA_CFID(x)			((x) & 0x1f)
#define PN7_STA_SFID(x)			(((x) >> 8) & 0x1f)
#define PN7_STA_MFID(x)			(((x) >> 16) & 0x1f)
#define PN7_STA_CVID(x)			(((x) >> 32) & 0x1f)
#define PN7_STA_SVID(x)			(((x) >> 40) & 0x1f)
#define PN7_STA_MVID(x)			(((x) >> 48) & 0x1f)

/*
 * ACPI ctr_val status register to powernow k7 configuration
 */
#define PN7_ACPI_CTRL_TO_FID(x)		((x) & 0x1f)
#define PN7_ACPI_CTRL_TO_VID(x)		(((x) >> 5) & 0x1f)
#define PN7_ACPI_CTRL_TO_SGTC(x)	(((x) >> 10) & 0xffff)

#define WRITE_FIDVID(fid, vid, ctrl)	\
	wrmsr(MSR_AMDK7_FIDVID_CTL,	\
	    (((ctrl) << 32) | (1ULL << 16) | ((vid) << 8) | (fid)))

/*
 * Divide each value by 10 to get the processor multiplier.
 * Taken from powernow-k7.c/Linux by Dave Jones
 */
static int k7pnow_fid_to_mult[32] = {
	110, 115, 120, 125, 50, 55, 60, 65,
	70, 75, 80, 85, 90, 95, 100, 105,
	30, 190, 40, 200, 130, 135, 140, 210,
	150, 225, 160, 165, 170, 180, -1, -1
};

#define POWERNOW_MAX_STATES		16

struct k7pnow_state {
	int freq;
	int fid;
	int vid;
};

struct k7pnow_cpu_state {
	unsigned int fsb;
	unsigned int sgtc;
	struct k7pnow_state state_table[POWERNOW_MAX_STATES];
	unsigned int n_states;
	int flags;
};

struct psb_s {
	char signature[10];	/* AMDK7PNOW! */
	uint8_t version;
	uint8_t flags;
	uint16_t ttime;		/* Min Settling time */
	uint8_t reserved;
	uint8_t n_pst;
};

struct pst_s {
	uint32_t signature;
	uint8_t fsb;		/* Front Side Bus frequency (MHz) */
	uint8_t fid;		/* Max Frequency code */
	uint8_t vid;		/* Max Voltage code */
	uint8_t n_states;	/* Number of states */
};

struct k7pnow_cpu_state *k7pnow_current_state;
extern int setperf_prio;

int k7pnow_decode_pst(struct k7pnow_cpu_state *, uint8_t *, int);
int k7pnow_states(struct k7pnow_cpu_state *, uint32_t, unsigned int,
    unsigned int);

#if NACPICPU > 0
int k7pnow_acpi_init(struct k7pnow_cpu_state * cstate, uint64_t status);
int k7pnow_acpi_states(struct k7pnow_cpu_state * cstate,
    struct acpicpu_pss *pss, int nstates, uint64_t status);
void k7pnow_acpi_pss_changed(struct acpicpu_pss *pss, int npss);
#endif

void
k7_powernow_setperf(int level)
{
	unsigned int i;
	int cvid, cfid, vid = 0, fid = 0;
	uint64_t status, ctl;
	struct k7pnow_cpu_state * cstate;

	cstate = k7pnow_current_state;

	i = ((level * cstate->n_states) + 1) / 101;
	if (i >= cstate->n_states)
		i = cstate->n_states - 1;
	fid = cstate->state_table[i].fid;
	vid = cstate->state_table[i].vid;

	if (fid == 0 || vid == 0)
		return;

	status = rdmsr(MSR_AMDK7_FIDVID_STATUS);
	cfid = PN7_STA_CFID(status);
	cvid = PN7_STA_CVID(status);

	/*
	 * We're already at the requested level.
	 */
	if (fid == cfid && vid == cvid)
		return;

	ctl = rdmsr(MSR_AMDK7_FIDVID_CTL) & PN7_CTR_FIDCHRATIO;

	ctl |= PN7_CTR_FID(fid);
	ctl |= PN7_CTR_VID(vid);
	ctl |= PN7_CTR_SGTC(cstate->sgtc);

	if (cstate->flags & PN7_FLAG_ERRATA_A0)
		disable_intr();

	if (k7pnow_fid_to_mult[fid] < k7pnow_fid_to_mult[cfid]) {
		wrmsr(MSR_AMDK7_FIDVID_CTL, ctl | PN7_CTR_FIDC);
		if (vid != cvid)
			wrmsr(MSR_AMDK7_FIDVID_CTL, ctl | PN7_CTR_VIDC);
	} else {
		wrmsr(MSR_AMDK7_FIDVID_CTL, ctl | PN7_CTR_VIDC);
		if (fid != cfid)
			wrmsr(MSR_AMDK7_FIDVID_CTL, ctl | PN7_CTR_FIDC);
	}

	if (cstate->flags & PN7_FLAG_ERRATA_A0)
		enable_intr();

	status = rdmsr(MSR_AMDK7_FIDVID_STATUS);
	cfid = PN7_STA_CFID(status);
	cvid = PN7_STA_CVID(status);
	if (cfid == fid || cvid == vid)
		cpuspeed = cstate->state_table[i].freq;
}

/*
 * Given a set of pair of fid/vid, and number of performance states,
 * compute state_table via an insertion sort.
 */
int
k7pnow_decode_pst(struct k7pnow_cpu_state * cstate, uint8_t *p, int npst)
{
	int i, j, n;
	struct k7pnow_state state;

	for (n = 0, i = 0; i < npst; ++i) {
		state.fid = *p++;
		state.vid = *p++;
		state.freq = k7pnow_fid_to_mult[state.fid]/10 * cstate->fsb;
		if ((cstate->flags & PN7_FLAG_ERRATA_A0) &&
		    (k7pnow_fid_to_mult[state.fid] % 10) == 5)
			continue;

		j = n;
		while (j > 0 && cstate->state_table[j - 1].freq > state.freq) {
			memcpy(&cstate->state_table[j],
			    &cstate->state_table[j - 1],
			    sizeof(struct k7pnow_state));
			--j;
		}
		memcpy(&cstate->state_table[j], &state,
		    sizeof(struct k7pnow_state));
		++n;
	}
	/*
	 * Fix powernow_max_states, if errata_a0 give us less states
	 * than expected.
	 */
	cstate->n_states = n;
	return 1;
}

int
k7pnow_states(struct k7pnow_cpu_state *cstate, uint32_t cpusig,
    unsigned int fid, unsigned int vid)
{
	int maxpst;
	struct psb_s *psb;
	struct pst_s *pst;
	uint8_t *p;

	/*
	 * Look in the 0xe0000 - 0x100000 physical address
	 * range for the pst tables; 16 byte blocks
	 */
	for (p = (u_int8_t *)ISA_HOLE_VADDR(BIOS_START);
	    p < (u_int8_t *)ISA_HOLE_VADDR(BIOS_START + BIOS_LEN); p+=
	    BIOS_STEP) {
		if (memcmp(p, "AMDK7PNOW!", 10) == 0) {
			psb = (struct psb_s *)p;
			if (psb->version != PN7_PSB_VERSION)
				return 0;

			cstate->sgtc = psb->ttime * cstate->fsb;
			if (cstate->sgtc < 100 * cstate->fsb)
				cstate->sgtc = 100 * cstate->fsb;
			if (psb->flags & 1)
				cstate->flags |= PN7_FLAG_DESKTOP_VRM;
			p += sizeof(struct psb_s);

			for (maxpst = 0; maxpst < psb->n_pst; maxpst++) {
				pst = (struct pst_s*) p;

				if (cpusig == pst->signature && fid == pst->fid
				    && vid == pst->vid) {

					if (abs(cstate->fsb - pst->fsb) > 5)
						continue;
					cstate->n_states = pst->n_states;
					return (k7pnow_decode_pst(cstate,
					    p + sizeof(struct pst_s),
					    cstate->n_states));
				}
				p += sizeof(struct pst_s) +
				    (2 * pst->n_states);
			}
		}
	}

	return 0;
}

#if NACPICPU > 0

int
k7pnow_acpi_states(struct k7pnow_cpu_state * cstate, struct acpicpu_pss *pss,
    int nstates, uint64_t status)
{
	struct k7pnow_state state;
	int j, k, n;
	uint32_t ctrl;

	k = -1;
	for (n = 0; n < cstate->n_states; n++) {
		if (status == pss[n].pss_status)
			k = n;
		ctrl = pss[n].pss_ctrl;
		state.fid = PN7_ACPI_CTRL_TO_FID(ctrl);
		state.vid = PN7_ACPI_CTRL_TO_VID(ctrl);

		if ((cstate->flags & PN7_FLAG_ERRATA_A0) &&
		    (k7pnow_fid_to_mult[state.fid] % 10) == 5)
			continue;

		state.freq = pss[n].pss_core_freq;
		j = n;
		while (j > 0 && cstate->state_table[j - 1].freq > state.freq) {
			memcpy(&cstate->state_table[j],
			    &cstate->state_table[j - 1],
			sizeof(struct k7pnow_state));
			--j;
		}
		memcpy(&cstate->state_table[j], &state,
		    sizeof(struct k7pnow_state));
	}
	return k;
}

void
k7pnow_acpi_pss_changed(struct acpicpu_pss *pss, int npss)
{
	int curs;
	struct k7pnow_cpu_state *cstate;
	uint32_t ctrl;
	uint64_t status;

	status = rdmsr(MSR_AMDK7_FIDVID_STATUS);
	cstate = k7pnow_current_state;

	curs = k7pnow_acpi_states(cstate, pss, npss, status);
	ctrl = pss[curs].pss_ctrl;
	cstate->sgtc = PN7_ACPI_CTRL_TO_SGTC(ctrl);
	cstate->n_states = npss;
}

int
k7pnow_acpi_init(struct k7pnow_cpu_state *cstate, uint64_t status)
{
	int curs;
	uint32_t ctrl;
	struct acpicpu_pss *pss;
	int mfid;

	cstate->n_states = acpicpu_fetch_pss(&pss);
	if (cstate->n_states == 0)
		return 0;

	curs = k7pnow_acpi_states(cstate, pss, cstate->n_states, status);
	/* 
	 * XXX: Some BIOS supplied _PSS implementations have the wrong
	 * maximum frequency, if we encounter one of these punt and 
	 * hope the legacy tables have correct values.
	 */
	mfid = PN7_STA_MFID(status);
	if (mfid != cstate->state_table[cstate->n_states - 1].fid) {
		return 0;
	}

	acpicpu_set_notify(k7pnow_acpi_pss_changed);
	ctrl = pss[curs].pss_ctrl;
	cstate->sgtc = PN7_ACPI_CTRL_TO_SGTC(ctrl);

	return 1;
}

#endif /* NACPICPU */

void
k7_powernow_init(void)
{
	u_int regs[4];
	uint64_t status;
	u_int maxfid, startvid, currentfid;
	struct k7pnow_cpu_state *cstate;
	struct k7pnow_state *state;
	struct cpu_info *ci;
	char *techname = NULL;
	int i;

	if (setperf_prio > 1)
		return;

	ci = curcpu();

	cpuid(0x80000000, regs);
	if (regs[0] < 0x80000007)
		return;

	cpuid(0x80000007, regs);
	if (!(regs[3] & AMD_PN_FID_VID))
		return;

	/* Extended CPUID signature value */
	cpuid(0x80000001, regs);

	cstate = malloc(sizeof(struct k7pnow_cpu_state), M_DEVBUF, M_NOWAIT);
	if (!cstate)
		return;

	cstate->flags = cstate->n_states = 0;
	if (ci->ci_signature == AMD_ERRATA_A0_CPUSIG)
		cstate->flags |= PN7_FLAG_ERRATA_A0;

	status = rdmsr(MSR_AMDK7_FIDVID_STATUS);
	maxfid = PN7_STA_MFID(status);
	startvid = PN7_STA_SVID(status);
	currentfid = PN7_STA_CFID(status);

	cstate->fsb = cpuspeed / (k7pnow_fid_to_mult[currentfid]/10);

	if (!k7pnow_states(cstate, ci->ci_signature, maxfid, startvid))
		if (!k7pnow_states(cstate, regs[0], maxfid, startvid)) {
#if NACPICPU > 0
			/* If we have it try ACPI */
			k7pnow_acpi_init(cstate, status);
#endif
	}

	if (cstate->n_states) {
		if (cstate->flags & PN7_FLAG_DESKTOP_VRM)
			techname = "Cool'n'Quiet K7";
		else
			techname = "PowerNow! K7";
		printf("%s: %s %d MHz: speeds:",
		    ci->ci_dev.dv_xname, techname, cpuspeed);
		for (i = cstate->n_states; i > 0; i--) {
			state = &cstate->state_table[i-1];
			printf(" %d", state->freq);
		}
		printf(" MHz\n");

		k7pnow_current_state = cstate;
		cpu_setperf = k7_powernow_setperf;
		setperf_prio = 1;
		return;
	}
	free(cstate, M_DEVBUF, sizeof(*cstate));
}
@


1.36
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.35 2014/07/12 18:44:41 tedu Exp $ */
d450 1
a450 1
	free(cstate, M_DEVBUF, 0);
@


1.35
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.34 2010/04/20 22:05:41 tedu Exp $ */
a34 1
#include <sys/proc.h>
@


1.34
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.33 2007/09/07 03:50:42 gwk Exp $ */
d451 1
a451 1
	free(cstate, M_DEVBUF);
@


1.33
log
@Based upon a diff orignally submitted by devin smith, Do two things run the
check that the maxfid and the highest reported acpi p_state frequency agree only
after actually getting the acpi p_state. Secondly prefer the legacy powernow
table over ACPI because machines of this vintage of are likely to have broken
ACPI implementations.

Tested by devin smith and tilo stritzky.
ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.32 2007/07/27 03:03:37 gwk Exp $ */
d35 1
@


1.32
log
@Adapt powernow-k7.c driver to use the ACPI _PSS table for retreiving
p_state data based on similar work done to powernow-k8.c. This work was
done by Devin Smith <devin at devinsmith dot net> and this commit is a
slightly modified verson of his last diff to tech@@, thanks again for your
work.
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.31 2007/04/24 17:12:26 gwk Exp $ */
d314 4
d361 1
a370 1
	curs = k7pnow_acpi_states(cstate, pss, cstate->n_states, status);
d424 2
d427 2
a428 2
	/* If we have it try ACPI */
	if (!k7pnow_acpi_init(cstate, status))
a429 4
	{
		/* if the base CPUID signature fails to match try, the extended one */
		if (!k7pnow_states(cstate, ci->ci_signature, maxfid, startvid))
			k7pnow_states(cstate, regs[0], maxfid, startvid);
@


1.31
log
@Choose the state for a request performance level based on calculations
involving the number of states and not the frequencies of the states,
which can lead to strange distributions of the states over the hw.setperf
range (0-100). Tested by many.

ok canacar, tedu
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.30 2006/12/20 17:50:40 gwk Exp $ */
d44 7
d85 1
d144 7
d296 81
d420 10
a429 3
	/* if the base CPUID signature fails to match try, the extended one */
	if (!k7pnow_states(cstate, ci->ci_signature, maxfid, startvid))
		k7pnow_states(cstate, regs[0], maxfid, startvid);
@


1.30
log
@"#ifdef is a tool of the weak!"
Rename pentium_mhz to cpuspeed which is consistant with amd64 making
shared ACPI code less nasty.
ok marco, deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.29 2006/12/12 23:14:27 dim Exp $ */
a131 3
/*
 * Prototypes
 */
d139 1
a139 1
	unsigned int i, low, high, freq;
d145 6
a150 11
	high = cstate->state_table[cstate->n_states - 1].freq;
	low = cstate->state_table[0].freq;
	freq = low + (high - low) * level / 100;

	for (i = 0; i < cstate->n_states; i++) {
		if (cstate->state_table[i].freq >= freq) {
			fid = cstate->state_table[i].fid;
			vid = cstate->state_table[i].vid;
			break;
		}
	}
d264 1
a264 1
					
d272 2
a273 1
				p += sizeof(struct pst_s) + (2 * pst->n_states);
d313 1
a313 1
	cstate->flags = cstate->n_states = 0;	
d326 1
a326 1
		k7pnow_states(cstate, regs[0], maxfid, startvid); 
d338 2
a339 2
		printf(" MHz\n");	
		
@


1.29
log
@Complete gwk's previous patch to stop setperf methods from returning
errors to userland: make all cpu_setperf functions return void.

Tested by many, ok gwk@@
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.28 2006/10/19 19:29:04 tom Exp $ */
d199 1
a199 1
		pentium_mhz = cstate->state_table[i].freq;
d329 1
a329 1
	cstate->fsb = pentium_mhz / (k7pnow_fid_to_mult[currentfid]/10);
d340 1
a340 1
		    ci->ci_dev.dv_xname, techname, pentium_mhz);
@


1.28
log
@Fix the spellings of Cool'n'Quiet and PowerNow! in a couple of places.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.27 2006/10/19 10:55:56 tom Exp $ */
d139 1
a139 1
int
d161 1
a161 1
		return (0);
d171 1
a171 1
		return (0);
a199 2

	return (0);
@


1.27
log
@s/Mhz/MHz/ in comments and printf() strings

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.26 2006/09/29 21:09:25 gwk Exp $ */
d49 1
a49 1
 * MSRs and bits used by Powernow technology
d338 1
a338 1
			techname = "Cool`n'Quiet K7";
d340 1
a340 1
			techname = "Powernow! K7";
@


1.26
log
@If we don't find a matching CPU signature using the base CPUID call, try
matching against the extended CPUID (0x80000001) signature. Problem
found by, and patch based on work by jason@@.
ok jason@@
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.25 2006/09/25 22:28:11 gwk Exp $ */
d123 1
a123 1
	uint8_t fsb;		/* Front Side Bus frequency (Mhz) */
d341 1
a341 1
		printf("%s: %s %d Mhz: speeds:",
d347 1
a347 1
		printf(" Mhz\n");	
@


1.25
log
@Martin Végiard <deadbug AT gmail.com> has been kind enough to rescind the
third clause of his license and strike the phrase "All rights reserved", so we
can consolidate both license blocks into one. Thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.24 2006/06/16 05:58:50 gwk Exp $ */
d136 2
a137 1
int k7pnow_states(struct k7pnow_cpu_state *, uint32_t, unsigned int, unsigned int);
d315 3
d322 1
a322 1
	cstate->flags = 0;	
d332 14
a345 18
	if (k7pnow_states(cstate, ci->ci_signature, maxfid, startvid)) {
		if (cstate->n_states) {
			if (cstate->flags & PN7_FLAG_DESKTOP_VRM)
				techname = "Cool`n'Quiet K7";
			else
				techname = "Powernow! K7";
			printf("%s: %s %d Mhz: speeds:",
			    ci->ci_dev.dv_xname, techname, pentium_mhz);
			for (i = cstate->n_states; i > 0; i--) {
				state = &cstate->state_table[i-1];
				printf(" %d", state->freq);
			}
			printf(" Mhz\n");	
			
			k7pnow_current_state = cstate;
			cpu_setperf = k7_powernow_setperf;
			setperf_prio = 1;
			return;
d347 6
@


1.24
log
@From k*_powernow_setperf() always return 0, i.e.
Do not return low level errors to userspace where they will not/can not be
coped with.
: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.23 2006/06/13 00:32:35 gwk Exp $ */
a4 24
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
@


1.23
log
@Change the value returned if the CPU fails to honor a request to
adjust frequency from 1 (EPERM) to EIO.
Suggested by and ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.22 2006/05/27 04:46:12 gwk Exp $ */
d221 2
a222 7
	if (cfid != fid || cvid != vid) {
		printf("%s transition to fid: %d vid: %d failed.", __func__,
		    fid, vid);
		return (EIO);
	}
	
	pentium_mhz = cstate->state_table[i].freq;
@


1.22
log
@Teach powernow about setperf prioritys, add a setperf_prio to amd64.
ok uwe@@, "good" tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.21 2006/05/11 13:21:11 mickey Exp $ */
d224 1
a224 1
		return 0;
d229 1
a229 1
	return 0;
@


1.21
log
@kill trainling spaces
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.20 2006/05/02 16:14:51 pat Exp $ */
d154 1
d330 3
d373 1
@


1.20
log
@* Plug memory leak if init fails; ok gwk@@
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.19 2006/04/18 03:29:47 gwk Exp $ */
d282 1
a282 1
	    p < (u_int8_t *)ISA_HOLE_VADDR(BIOS_START + BIOS_LEN); p+= 
d363 1
a363 1
				printf(" %d", state->freq); 
@


1.19
log
@Correct the heuristic to determin Cool`n'Quiet vs. Powernow! spotted in
the linux driver.
Correct the the cpu signature used to determin if the chip is affected
by errata a0, verified in the linux driver.
Some demagification and KNF.
ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.18 2006/04/18 02:14:33 gwk Exp $ */
a330 4
	cstate = malloc(sizeof(struct k7pnow_cpu_state), M_DEVBUF, M_NOWAIT);
	if (!cstate)
		return;

d337 4
@


1.18
log
@Ensure that we check if the transition succeeded before we adjust
pentium_mhz on K7, and print a usefull diagnostic message if it does
not on K7 and K8.
"makes sense to me" dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.17 2006/04/15 05:17:17 gwk Exp $ */
d78 4
d133 1
a133 1
	int errata_a0;
d201 1
a201 1
	if (cstate->errata_a0)
d214 1
a214 1
	if (cstate->errata_a0)
d245 1
a245 1
		if (cstate->errata_a0 &&
d292 2
a293 1

d342 4
a345 6
	
	cpuid(0x80000001, regs);
	if ((regs[0] & 0xfff) == 0x760)
		cstate->errata_a0 = TRUE;
	else
		cstate->errata_a0 = FALSE;
a352 10
	/*
	 * If start FID is different to max FID, then it is a
	 * mobile processor.  If not, it is a low powered desktop
	 * processor.
	 */
	if (maxfid != currentfid) {
		techname = "PowerNow! K7";
	} else {
		techname = "Cool`n'Quiet K7";
	}
d355 4
d361 1
a361 1
			for(i = cstate->n_states; i > 0; i--) {
@


1.17
log
@Don't bother setting the frequency entry in the available states table
to -1 we never check for it. (As has been the case on K8 for a long time).
ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.16 2006/04/14 05:30:34 gwk Exp $ */
d68 3
a70 3
#define BIOS_START		0xe0000
#define	BIOS_LEN		0x20000
#define BIOS_STEP		16
d213 9
@


1.16
log
@Eliminate some pointers we dont use, originally for multiprocessor support,
K7 MP parts do not support Cool'N'Quiet.
"also makes sense" dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.15 2006/04/14 05:25:42 gwk Exp $ */
a226 3

	for (i = 0; i < POWERNOW_MAX_STATES; ++i)
		cstate->state_table[i].freq = -1;
@


1.15
log
@Rid k7_powernow_setperf() of some bad math, this code expected the values
to be expressed in hertz not megahertz.
"makes sense to me" dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.14 2006/04/14 05:13:20 gwk Exp $ */
d149 1
a149 1
struct k7pnow_cpu_state * k7pnow_current_state[I386_MAXPROCS];
d165 1
a165 1
	cstate = k7pnow_current_state[cpu_number()];
d364 1
a364 1
			k7pnow_current_state[cpu_number()] = cstate;
@


1.14
log
@Change the return value in k7_powernow_setperf() from 1 to 0 so that it
does not print "operation not permitted" even though the operation was
successful.
ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.13 2006/04/15 04:25:12 gwk Exp $ */
d213 1
a213 1
	pentium_mhz = ((cstate->state_table[i].freq / 100000)+1)*100;
@


1.13
log
@Loop on the number of PST reported by the bios not a magic number.
Fixes PR 5075.
"go for it" dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.12 2006/04/04 03:32:56 uwe Exp $ */
d215 1
a215 1
	return 1;
@


1.12
log
@Small hex-vs-decimal typo from gwk, and tested by me (with cpusig check
disabled because my BIOS sucks).
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.11 2006/03/20 12:08:59 dlg Exp $ */
d285 1
a285 1
			for (maxpst = 0; maxpst < 200; maxpst++) {
@


1.11
log
@a bit of demagification. this moves the checks for the cpu scaling features
out of machdep and into powernow-k7 and -k8. machdep now just figures out
if its the right type of cpu before calling the powernow code which
figures out if the scaling is supported.

from gwk
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.10 2006/03/15 19:56:48 deraadt Exp $ */
d70 1
a70 1
#define BIOS_STEP		0x16
@


1.10
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.9 2005/11/28 17:48:02 mickey Exp $ */
d70 1
d77 1
d80 1
a80 1

d98 2
a99 2
#define ACPI_PN7_CTRL_TO_VID(x)		(((x) >> 5) & 0x1f)
#define ACPI_PN7_CTRL_TO_SGTC(x)	(((x) >> 10) & 0xffff)
a115 25
/*
 * Units are in mV.
 */

/*
 * Mobile VRM (K7)
 */
static int k7pnow_mobile_vid_to_volts[] = {
	2000, 1950, 1900, 1850, 1800, 1750, 1700, 1650,
	1600, 1550, 1500, 1450, 1400, 1350, 1300, 0,
	1275, 1250, 1225, 1200, 1175, 1150, 1125, 1100,
	1075, 1050, 1025, 1000, 975, 950, 925, 0,
};

/*
 * Desktop VRM (K7)
 */

static int k7pnow_desktop_vid_to_volts[] = {
	2000, 1950, 1900, 1850, 1800, 1750, 1700, 1650,
	1600, 1550, 1500, 1450, 1400, 1350, 1300, 0,
	1275, 1250, 1225, 1200, 1175, 1150, 1125, 1100,
	1075, 1050, 1025, 1000, 975, 950, 925, 0,
};

a129 1
	int *vid_to_volts;
d234 1
a234 1
		state.freq = 100 * k7pnow_fid_to_mult[state.fid] * cstate->fsb;
d272 2
a273 1
	    p < (u_int8_t *)ISA_HOLE_VADDR(BIOS_START + BIOS_LEN); p+= 16) {
d276 1
a276 1
			if (psb->version != 0x12)
d290 1
a290 14
					switch (pst->signature) {
					case 0x760:
					case 0x761:
					case 0x762:
					case 0x770:
					case 0x771:
					case 0x780:
					case 0x781:
					case 0x7a0:
						break;
					default:
						return 0;
					}

d324 8
d343 1
a343 2
	CPU_CLOCKUPDATE();
	cstate->fsb = pentium_base_tsc / 100000 / k7pnow_fid_to_mult[currentfid];
a349 1
		cstate->vid_to_volts = k7pnow_mobile_vid_to_volts;
a351 1
		cstate->vid_to_volts = k7pnow_desktop_vid_to_volts;
d356 5
a360 6
			printf("%s: AMD %s: available states ",
			    ci->ci_dev.dv_xname, techname);
			for (i = 0; i < cstate->n_states; i++) {
				state = &cstate->state_table[i];
				printf("%c%d", i==0 ? '(' : ',',
				    ((state->freq / 100000)+1)*100);
d362 2
a363 1
			printf(")\n");
d366 1
d369 1
@


1.9
log
@another dangling semicolon from Matthias Bauer
@
text
@d1 2
a2 1
/* $OpenBSD: powernow-k7.c,v 1.8 2005/11/26 11:22:12 tedu Exp $ */
d157 1
a157 1
	char signature[10];     /* AMDK7PNOW! */
d160 1
a160 1
	uint16_t ttime;         /* Min Settling time */
d313 1
a313 1
					switch(pst->signature) {
d331 2
a332 2
					     p + sizeof(struct pst_s),
					     cstate->n_states));
d387 1
a387 1
			printf("%s: AMD %s: available states ", 
d389 1
a389 1
			for(i = 0; i < cstate->n_states; i++) {
d394 1
a394 1
			printf(")\n");	
@


1.8
log
@some cleanup from gordon
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.7 2005/10/28 07:14:31 tedu Exp $ */
d233 1
a233 1
	if (cstate->errata_a0);
@


1.7
log
@lost a diff from gordon, only attach if we can do something useful
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.6 2005/10/28 07:11:13 tedu Exp $ */
a150 1
	unsigned int max_states;
d156 6
a161 6
        char signature[10];     /* AMDK7PNOW! */
        uint8_t version;
        uint8_t flags;
        uint16_t ttime;         /* Min Settling time */
        uint8_t reserved;
        uint8_t n_pst;
d236 1
a236 1
	calibrate_cyclecounter();
d263 1
a263 1
		while (j > 0 && cstate->state_table[j - 1].freq < state.freq) {
d277 1
a277 1
	cstate->max_states = n;
d326 1
a326 1
					if(abs(cstate->fsb - pst->fsb) > 5)
d328 1
a328 1
					cstate->max_states = pst->n_states;
d331 1
a331 1
					     cstate->max_states));
d345 1
a345 1
	uint64_t status, rate;
d348 1
d351 2
a364 1
	rate = pentium_mhz;
d370 2
a371 1
	cstate->fsb = rate / 100000 / k7pnow_fid_to_mult[currentfid];
a384 2
		printf("%s: AMD %s: %d available states\n", ci->ci_dev.dv_xname,
		    techname, cstate->n_states);
d386 8
@


1.6
log
@malloc(M_WAITOK) is bad in init code, M_DEVBUF is nicer than M_TEMP,
and if the cpu gets stuck, don't spin too long.
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.5 2005/10/28 07:03:41 tedu Exp $ */
d385 4
a388 2
		k7pnow_current_state[cpu_number()] = cstate;
		cpu_setperf = k7_powernow_setperf;
@


1.5
log
@update support for powernow (cool and quiet) on k7, and add support
for k8.  preliminary and not well tested yet.  from freebsd via
gordon klok.
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.4 2005/10/20 16:38:51 mickey Exp $ */
d353 3
a355 1
	cstate = malloc(sizeof(struct k7pnow_cpu_state), M_TEMP, M_WAITOK);
@


1.4
log
@fix addr range in the comments
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.3 2004/08/05 04:56:05 tedu Exp $ */
d27 23
a59 2
#include <dev/isa/isareg.h>

d61 1
d64 3
a66 6
#if 0
/*	WTF?	*/
#define BIOS_START		0xe0000
#define BIOS_END		0x20000
#define BIOS_LEN		BIOS_END - BIOS_START
#endif
d70 21
a90 3
#define MSR_K7_CTL		0xC0010041
#define CTL_SET_FID		0x0000000000010000ULL
#define CTL_SET_VID		0x0000000000020000ULL
d92 63
a154 1
#define cpufreq(x)	k7pnow_fsb * k7pnow_fid_codes[x] / 10
d157 6
a162 6
	char signature[10];	/* AMDK7PNOW! */
	uint8_t version;
	uint8_t flags;
	uint16_t ttime;		/* Min Settling time */
	uint8_t reserved;
	uint8_t n_pst;
d173 63
a235 4
struct state_s {
	uint8_t fid;		/* Frequency code */
	uint8_t vid;		/* Voltage code */
};
d237 1
a237 4
struct k7pnow_freq_table_s {
	unsigned int frequency;
	struct state_s *state;
};
d239 2
a240 7
/* Taken from powernow-k7.c/Linux by Dave Jones */
int k7pnow_fid_codes[32] = {
	110, 115, 120, 125, 50, 55, 60, 65,
	70, 75, 80, 85, 90, 95, 100, 105,
	30, 190, 40, 200, 130, 135, 140, 210,
	150, 225, 160, 165, 170, 180, -1, -1
};
d242 9
a250 6
/* Static variables */
unsigned int k7pnow_fsb;
unsigned int k7pnow_cur_freq;
unsigned int k7pnow_ttime;
unsigned int k7pnow_nstates;
struct k7pnow_freq_table_s *k7pnow_freq_table;
d252 2
d255 26
a280 2
/* Prototypes */
struct state_s *k7_powernow_getstates(uint32_t);
d282 3
a284 2
struct state_s *
k7_powernow_getstates(uint32_t signature)
d286 1
a286 1
	unsigned int i, j;
d289 1
a289 2
	char *ptr;
	bus_space_handle_t bh;
d295 4
a298 16
	if (bus_space_map(I386_BUS_SPACE_MEM, BIOS_START, BIOS_LEN, 0, &bh)) {
		printf("k7_powernow: couldn't map BIOS\n");
		return NULL;
	}
	ptr = malloc(BIOS_LEN, M_DEVBUF, M_NOWAIT);
	memcpy(ptr, (void *)bh, BIOS_LEN);
	bus_space_unmap(I386_BUS_SPACE_MEM, bh, BIOS_LEN);

	for (i = 0; i < BIOS_LEN; i += 16, ptr += 16) {
		if (memcmp(ptr, "AMDK7PNOW!", 10) == 0) {
			psb = (struct psb_s *) ptr;
			ptr += sizeof(struct psb_s);

			k7pnow_ttime = psb->ttime;

			/* Only this version is supported */
d302 22
a323 12
			/* Find the right PST */
			for (j = 0; j < psb->n_pst; j++) {
				pst = (struct pst_s *) ptr;
				ptr += sizeof(struct pst_s);

				/* Use the first PST with matching CPUID */
				if (signature == pst->signature) {
					/*
					 * XXX I need more info on this.
					 * For now, let's just ignore it
					 */
					if ((signature & 0xFF) == 0x60)
d325 1
d327 8
a334 6
					k7pnow_fsb = pst->fsb;
					k7pnow_nstates = pst->n_states;
					return (struct state_s *)ptr;
				} else
					ptr += sizeof(struct state_s) *
					    pst->n_states;
a335 2
			/* printf("No match was found for your CPUID\n"); */
			return 0;
d338 1
a338 1
	/* printf("Power state table not found\n"); */
d342 2
a343 2
int
k7_powernow_setperf(int level)
d345 21
a365 3
	unsigned int low, high, freq, i;
	uint32_t sgtc, vid = 0, fid = 0;
	uint64_t ctl;
d367 9
a375 35
	high = k7pnow_freq_table[k7pnow_nstates - 1].frequency;
	low = k7pnow_freq_table[0].frequency;
	freq = low + (high - low) * level / 100;

	for (i = 0; i < k7pnow_nstates; i++) {
		/* Do we know how to set that frequency? */
		if (k7pnow_freq_table[i].frequency >= freq) {
			fid = k7pnow_freq_table[i].state->fid;
			vid = k7pnow_freq_table[i].state->vid;
			break;
		}
	}

	if (fid == 0 || vid == 0)
		return (-1);

	/* Get CTL and only modify fid/vid/sgtc */
	ctl = rdmsr(MSR_K7_CTL);

	/* FID */
	ctl &= 0xFFFFFFFFFFFFFF00ULL;
	ctl |= fid;

	/* VID */
	ctl &= 0xFFFFFFFFFFFF00FFULL;
	ctl |= vid << 8;

	/* SGTC */
	if ((sgtc = k7pnow_ttime * 100) < 10000) sgtc = 10000;
	ctl &= 0xFFF00000FFFFFFFFULL;
	ctl |= (uint64_t)sgtc << 32;

	if (k7pnow_cur_freq > freq) {
		wrmsr(MSR_K7_CTL, ctl | CTL_SET_FID);
		wrmsr(MSR_K7_CTL, ctl | CTL_SET_VID);
d377 2
a378 2
		wrmsr(MSR_K7_CTL, ctl | CTL_SET_VID);
		wrmsr(MSR_K7_CTL, ctl | CTL_SET_FID);
d380 5
a384 20
	ctl = rdmsr(MSR_K7_CTL);
	return (0);
}

void
k7_powernow_init(uint32_t signature)
{
	unsigned int i;
	struct state_s *s;

	s = k7_powernow_getstates(signature);
	if (s == 0)
		return;

	k7pnow_freq_table = malloc(sizeof(struct k7pnow_freq_table_s) *
	    k7pnow_nstates, M_TEMP, M_WAITOK);

	for (i = 0; i < k7pnow_nstates; i++, s++) {
		k7pnow_freq_table[i].frequency = cpufreq(s->fid);
		k7pnow_freq_table[i].state = s;
a385 6

	/* On bootup the frequency should be at it's max */
	k7pnow_cur_freq = k7pnow_freq_table[i-1].frequency;

	printf("cpu0: AMD POWERNOW: %d available states\n", k7pnow_nstates);
	cpu_setperf = k7_powernow_setperf;
@


1.3
log
@unmap bios when done.  from form@@pdp-11.org.ru via grange
@
text
@d1 1
a1 1
/* $OpenBSD: powernow-k7.c,v 1.2 2004/07/14 05:38:37 tedu Exp $ */
d113 1
a113 1
	 * Look in the 0xe0000 - 0x20000 physical address
@


1.2
log
@names of frequencies aren't interesting, and require ugly snprintf
manipulation theo doesn't like.  just print number of states.
this way doesn't leak the memory for the string either.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d110 1
d116 1
a116 2
	if (bus_space_map(I386_BUS_SPACE_MEM, BIOS_START, BIOS_LEN, 0,
	    (bus_space_handle_t *)&ptr)) {
d120 3
@


1.1
log
@setperf driver for powernow in amd k7 cpus.  derived from a diff to
tech-i386@@netbsd by martin vegiard, and adapted to fit in here.
as yet untested.  ok deraadt@@
@
text
@d1 1
d214 1
a214 1
	unsigned int i, freq_names_len, len = 0;
a215 1
	char *freq_names;
a220 3
	freq_names_len =  k7pnow_nstates * (sizeof("9999 ")-1) + 1;
	freq_names = malloc(freq_names_len, M_TEMP, M_WAITOK);

a226 5

		/* XXX len += snprintf is an illegal idiom */ 
		len += snprintf(freq_names + len, freq_names_len - len, "%d%s",
		    k7pnow_freq_table[i].frequency,
		    i < k7pnow_nstates - 1 ? " " : "");
d232 1
a232 2
	printf("cpu0: AMD POWERNOW Available frequencies (Mhz): %s\n",
	    freq_names);
@

