head	1.603;
access;
symbols
	OPENBSD_6_1:1.598.0.4
	OPENBSD_6_1_BASE:1.598
	OPENBSD_6_0:1.588.0.2
	OPENBSD_6_0_BASE:1.588
	OPENBSD_5_9:1.579.0.2
	OPENBSD_5_9_BASE:1.579
	OPENBSD_5_8:1.574.0.4
	OPENBSD_5_8_BASE:1.574
	OPENBSD_5_7:1.567.0.2
	OPENBSD_5_7_BASE:1.567
	OPENBSD_5_6:1.550.0.4
	OPENBSD_5_6_BASE:1.550
	OPENBSD_5_5:1.531.0.4
	OPENBSD_5_5_BASE:1.531
	OPENBSD_5_4:1.523.0.2
	OPENBSD_5_4_BASE:1.523
	OPENBSD_5_3:1.520.0.2
	OPENBSD_5_3_BASE:1.520
	OPENBSD_5_2:1.510.0.2
	OPENBSD_5_2_BASE:1.510
	OPENBSD_5_1_BASE:1.506
	OPENBSD_5_1:1.506.0.2
	OPENBSD_5_0:1.505.0.2
	OPENBSD_5_0_BASE:1.505
	OPENBSD_4_9:1.487.0.2
	OPENBSD_4_9_BASE:1.487
	OPENBSD_4_8:1.481.0.2
	OPENBSD_4_8_BASE:1.481
	OPENBSD_4_7:1.468.0.2
	OPENBSD_4_7_BASE:1.468
	OPENBSD_4_6:1.453.0.4
	OPENBSD_4_6_BASE:1.453
	OPENBSD_4_5:1.447.0.2
	OPENBSD_4_5_BASE:1.447
	OPENBSD_4_4:1.435.0.2
	OPENBSD_4_4_BASE:1.435
	OPENBSD_4_3:1.418.0.2
	OPENBSD_4_3_BASE:1.418
	OPENBSD_4_2:1.403.0.2
	OPENBSD_4_2_BASE:1.403
	OPENBSD_4_1:1.379.0.2
	OPENBSD_4_1_BASE:1.379
	OPENBSD_4_0:1.364.0.2
	OPENBSD_4_0_BASE:1.364
	OPENBSD_3_9:1.340.0.2
	OPENBSD_3_9_BASE:1.340
	OPENBSD_3_8:1.324.0.2
	OPENBSD_3_8_BASE:1.324
	OPENBSD_3_7:1.316.0.2
	OPENBSD_3_7_BASE:1.316
	OPENBSD_3_6:1.309.0.2
	OPENBSD_3_6_BASE:1.309
	SMP_SYNC_A:1.296
	SMP_SYNC_B:1.296
	OPENBSD_3_5:1.287.0.2
	OPENBSD_3_5_BASE:1.287
	OPENBSD_3_4:1.244.0.2
	OPENBSD_3_4_BASE:1.244
	UBC_SYNC_A:1.231
	OPENBSD_3_3:1.222.0.2
	OPENBSD_3_3_BASE:1.222
	OPENBSD_3_2:1.214.0.2
	OPENBSD_3_2_BASE:1.214
	OPENBSD_3_1:1.204.0.2
	OPENBSD_3_1_BASE:1.204
	UBC_SYNC_B:1.216
	UBC:1.190.0.2
	UBC_BASE:1.190
	OPENBSD_3_0:1.178.0.2
	OPENBSD_3_0_BASE:1.178
	OPENBSD_2_9:1.155.0.2
	OPENBSD_2_9_BASE:1.155
	OPENBSD_2_8:1.137.0.2
	OPENBSD_2_8_BASE:1.137
	OPENBSD_2_7:1.131.0.2
	OPENBSD_2_7_BASE:1.131
	SMP:1.124.0.2
	SMP_BASE:1.124
	kame_19991208:1.120
	OPENBSD_2_6:1.118.0.2
	OPENBSD_2_6_BASE:1.118
	OPENBSD_2_5:1.105.0.2
	OPENBSD_2_5_BASE:1.105
	OPENBSD_2_4:1.94.0.2
	OPENBSD_2_4_BASE:1.94
	OPENBSD_2_3:1.84.0.2
	OPENBSD_2_3_BASE:1.84
	OPENBSD_2_2:1.63.0.2
	OPENBSD_2_2_BASE:1.63
	OPENBSD_2_1:1.45.0.2
	OPENBSD_2_1_BASE:1.45
	OPENBSD_2_0:1.24.0.2
	OPENBSD_2_0_BASE:1.24
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.603
date	2017.06.29.07.11.24;	author mlarkin;	state Exp;
branches;
next	1.602;
commitid	AmyRFfTfLmcOj1ke;

1.602
date	2017.05.30.15.11.32;	author deraadt;	state Exp;
branches;
next	1.601;
commitid	KepHUzDSsoNf5ym4;

1.601
date	2017.05.18.09.20.06;	author kettenis;	state Exp;
branches;
next	1.600;
commitid	JOc8Yh7oTJlujapO;

1.600
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.599;
commitid	2Gtqjzrin9LL2yHk;

1.599
date	2017.04.30.13.04.49;	author mpi;	state Exp;
branches;
next	1.598;
commitid	xDPbcPU6tYP39nZG;

1.598
date	2017.03.11.11.55.03;	author mpi;	state Exp;
branches;
next	1.597;
commitid	eXDj5wwfsbdFBB4L;

1.597
date	2017.03.07.11.49.42;	author natano;	state Exp;
branches;
next	1.596;
commitid	qcVMvyIHDSrZgRKv;

1.596
date	2017.03.02.10.38.10;	author natano;	state Exp;
branches;
next	1.595;
commitid	EeVoCYFCx2tYicZQ;

1.595
date	2017.01.13.17.15.27;	author mikeb;	state Exp;
branches;
next	1.594;
commitid	xf3Mp5sczmZXop5L;

1.594
date	2017.01.03.09.48.15;	author mlarkin;	state Exp;
branches;
next	1.593;
commitid	rOPSd8O2Di7WnNkY;

1.593
date	2016.10.21.06.20.58;	author mlarkin;	state Exp;
branches;
next	1.592;
commitid	szRuKZ9HgqvwYLcM;

1.592
date	2016.10.14.04.53.26;	author mlarkin;	state Exp;
branches;
next	1.591;
commitid	HlziCr2juunzjZBF;

1.591
date	2016.10.09.11.25.39;	author tom;	state Exp;
branches;
next	1.590;
commitid	DfYvEDcFmu1LY9q1;

1.590
date	2016.09.18.14.28.25;	author deraadt;	state Exp;
branches;
next	1.589;
commitid	BJaYTqaJQ1246GGO;

1.589
date	2016.09.03.12.12.43;	author mlarkin;	state Exp;
branches;
next	1.588;
commitid	VxEixNTRhSw9wrcd;

1.588
date	2016.06.22.07.22.00;	author mlarkin;	state Exp;
branches;
next	1.587;
commitid	M1lpFrN5wVgMVhed;

1.587
date	2016.05.21.01.06.53;	author deraadt;	state Exp;
branches;
next	1.586;
commitid	FpCvMH40i0c4D4sw;

1.586
date	2016.05.20.02.30.41;	author mlarkin;	state Exp;
branches;
next	1.585;
commitid	F5BmBZzZKQUK5NHq;

1.585
date	2016.05.18.03.45.11;	author mlarkin;	state Exp;
branches;
next	1.584;
commitid	JQz4IJ6cQ8DinMqc;

1.584
date	2016.05.10.18.39.45;	author deraadt;	state Exp;
branches;
next	1.583;
commitid	qfOifNidEGDB2jL1;

1.583
date	2016.03.24.04.56.08;	author guenther;	state Exp;
branches;
next	1.582;
commitid	VRKppYthMQboSLVW;

1.582
date	2016.03.15.03.17.51;	author guenther;	state Exp;
branches;
next	1.581;
commitid	hTA8iQcFPhTNwQXL;

1.581
date	2016.03.07.05.32.46;	author naddy;	state Exp;
branches;
next	1.580;
commitid	Ht3NH0pdlkYC6Nxx;

1.580
date	2016.03.03.12.41.30;	author naddy;	state Exp;
branches;
next	1.579;
commitid	Ykztt9UU7jxBEqeD;

1.579
date	2015.12.27.04.31.34;	author jsg;	state Exp;
branches;
next	1.578;
commitid	dxEnyjnljo1QbPFz;

1.578
date	2015.12.12.12.33.49;	author reyk;	state Exp;
branches;
next	1.577;
commitid	BGb3xaQZJ9ACCtNF;

1.577
date	2015.12.07.06.34.14;	author jsg;	state Exp;
branches;
next	1.576;
commitid	SlCrK8YSV6f5HTmS;

1.576
date	2015.10.21.07.59.18;	author mpi;	state Exp;
branches;
next	1.575;
commitid	XglPgGQ8qaiL0M4l;

1.575
date	2015.09.13.12.28.31;	author kettenis;	state Exp;
branches;
next	1.574;
commitid	AIBHsFOWHdAQ1DwO;

1.574
date	2015.07.21.03.38.22;	author reyk;	state Exp;
branches;
next	1.573;
commitid	t8p39jbat5DBrbFu;

1.573
date	2015.07.16.23.03.40;	author sf;	state Exp;
branches;
next	1.572;
commitid	vQBQlDELfKUomsax;

1.572
date	2015.07.16.05.10.14;	author guenther;	state Exp;
branches;
next	1.571;
commitid	vUE3LzynpntlHxEC;

1.571
date	2015.06.07.06.24.59;	author guenther;	state Exp;
branches;
next	1.570;
commitid	TPuT1ptKkvRzlUfp;

1.570
date	2015.05.28.20.10.58;	author guenther;	state Exp;
branches;
next	1.569;
commitid	nRKEXgw8UCVd37E0;

1.569
date	2015.04.18.22.16.21;	author kettenis;	state Exp;
branches;
next	1.568;
commitid	yRnPx9jjsPnb6oP6;

1.568
date	2015.04.12.18.37.53;	author mlarkin;	state Exp;
branches;
next	1.567;
commitid	5ST94uMTezmXYdhY;

1.567
date	2015.02.08.04.41.48;	author deraadt;	state Exp;
branches;
next	1.566;
commitid	X74o6HL4fdPsmZnb;

1.566
date	2015.02.07.03.29.27;	author guenther;	state Exp;
branches;
next	1.565;
commitid	ud6pWliQrnGGQIqi;

1.565
date	2015.02.06.05.17.48;	author mlarkin;	state Exp;
branches;
next	1.564;
commitid	6FJl8jQDXxYzHcqC;

1.564
date	2015.01.20.19.43.21;	author kettenis;	state Exp;
branches;
next	1.563;
commitid	Fn841MmVYz2JHvBP;

1.563
date	2015.01.19.16.01.44;	author jsg;	state Exp;
branches;
next	1.562;
commitid	XxkrcoKyIcX4NWk4;

1.562
date	2015.01.15.13.58.55;	author sf;	state Exp;
branches;
next	1.561;
commitid	JSZAlmd8Ysbk6RXG;

1.561
date	2015.01.12.16.33.31;	author deraadt;	state Exp;
branches;
next	1.560;
commitid	A44BjxYQVmvEK2uf;

1.560
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.559;
commitid	qHQiR2HLROzvZr7B;

1.559
date	2014.12.03.20.09.32;	author krw;	state Exp;
branches;
next	1.558;
commitid	rapVfhq63upxHrrZ;

1.558
date	2014.11.22.18.54.37;	author deraadt;	state Exp;
branches;
next	1.557;
commitid	zrRtUMwfcbj3RhLi;

1.557
date	2014.11.16.12.30.57;	author deraadt;	state Exp;
branches;
next	1.556;
commitid	yv0ECmCdICvq576h;

1.556
date	2014.10.25.16.57.58;	author kettenis;	state Exp;
branches;
next	1.555;
commitid	Zy0HwEHBV8xYYhHT;

1.555
date	2014.10.17.20.37.57;	author sthen;	state Exp;
branches;
next	1.554;
commitid	s7jB18TtgTTta5r7;

1.554
date	2014.10.17.19.35.32;	author sthen;	state Exp;
branches;
next	1.553;
commitid	FcjWDvloUpMtxk2V;

1.553
date	2014.10.17.18.15.48;	author kettenis;	state Exp;
branches;
next	1.552;
commitid	0TqbINb4qNa18Q8S;

1.552
date	2014.10.17.01.46.26;	author dlg;	state Exp;
branches;
next	1.551;
commitid	IJJrXsuNXPDjHg1o;

1.551
date	2014.09.19.20.02.25;	author kettenis;	state Exp;
branches;
next	1.550;
commitid	lZNawJpIJwhgF8VB;

1.550
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.549;
commitid	7QO4UJr3EKVAMc8t;

1.549
date	2014.07.14.08.36.31;	author uebayasi;	state Exp;
branches;
next	1.548;
commitid	q7wBn7ORojhipUMo;

1.548
date	2014.07.13.22.53.39;	author uebayasi;	state Exp;
branches;
next	1.547;
commitid	wsdp3qtXGjMj98oD;

1.547
date	2014.07.13.22.13.06;	author uebayasi;	state Exp;
branches;
next	1.546;
commitid	qYPOd6Qi4aRBKldK;

1.546
date	2014.07.11.22.28.05;	author uebayasi;	state Exp;
branches;
next	1.545;
commitid	fOXKrBuMmlMGQdd4;

1.545
date	2014.07.10.21.46.03;	author mpi;	state Exp;
branches;
next	1.544;
commitid	iYq3Z1ZWDKR3sS9G;

1.544
date	2014.07.10.20.15.27;	author uebayasi;	state Exp;
branches;
next	1.543;
commitid	YzvTa4t6mddz7Mh4;

1.543
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.542;
commitid	xpsLTYRIkonFtkr1;

1.542
date	2014.07.10.12.13.49;	author uebayasi;	state Exp;
branches;
next	1.541;
commitid	aofvn6ceiucgjg4N;

1.541
date	2014.07.04.09.48.38;	author kettenis;	state Exp;
branches;
next	1.540;
commitid	IUaJ7Fx6cmeISlvb;

1.540
date	2014.07.03.21.15.28;	author matthew;	state Exp;
branches;
next	1.539;
commitid	P69HFjn5e4zdBZir;

1.539
date	2014.06.15.11.43.24;	author sf;	state Exp;
branches;
next	1.538;
commitid	Y0AWLKcfCeF28jP4;

1.538
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.537;
commitid	eA4Y0YE1IUzj6hpW;

1.537
date	2014.05.30.13.46.16;	author mpi;	state Exp;
branches;
next	1.536;

1.536
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.535;

1.535
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.534;

1.534
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.533;

1.533
date	2014.03.16.05.19.44;	author jsg;	state Exp;
branches;
next	1.532;

1.532
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.531;

1.531
date	2014.01.05.20.23.57;	author mlarkin;	state Exp;
branches;
next	1.530;

1.530
date	2013.12.27.21.40.57;	author deraadt;	state Exp;
branches;
next	1.529;

1.529
date	2013.12.27.21.40.16;	author deraadt;	state Exp;
branches;
next	1.528;

1.528
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.527;

1.527
date	2013.10.17.08.02.15;	author deraadt;	state Exp;
branches;
next	1.526;

1.526
date	2013.10.09.01.48.40;	author guenther;	state Exp;
branches;
next	1.525;

1.525
date	2013.10.02.21.06.16;	author sf;	state Exp;
branches;
next	1.524;

1.524
date	2013.09.28.12.40.30;	author miod;	state Exp;
branches;
next	1.523;

1.523
date	2013.06.11.16.42.08;	author deraadt;	state Exp;
branches;
next	1.522;

1.522
date	2013.05.16.19.26.04;	author kettenis;	state Exp;
branches;
next	1.521;

1.521
date	2013.05.12.14.15.31;	author ratchov;	state Exp;
branches;
next	1.520;

1.520
date	2013.02.13.21.21.34;	author martynas;	state Exp;
branches;
next	1.519;

1.519
date	2012.12.04.20.51.10;	author kettenis;	state Exp;
branches;
next	1.518;

1.518
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.517;

1.517
date	2012.11.10.09.45.05;	author mglocker;	state Exp;
branches;
next	1.516;

1.516
date	2012.10.31.03.30.22;	author jsg;	state Exp;
branches;
next	1.515;

1.515
date	2012.10.09.09.16.09;	author jsg;	state Exp;
branches;
next	1.514;

1.514
date	2012.10.09.04.40.36;	author jsg;	state Exp;
branches;
next	1.513;

1.513
date	2012.10.08.21.47.48;	author deraadt;	state Exp;
branches;
next	1.512;

1.512
date	2012.09.19.20.19.31;	author jsg;	state Exp;
branches;
next	1.511;

1.511
date	2012.08.24.02.49.23;	author guenther;	state Exp;
branches;
next	1.510;

1.510
date	2012.05.23.08.23.43;	author mikeb;	state Exp;
branches;
next	1.509;

1.509
date	2012.03.27.06.44.01;	author jsg;	state Exp;
branches;
next	1.508;

1.508
date	2012.03.23.15.51.25;	author guenther;	state Exp;
branches;
next	1.507;

1.507
date	2012.03.19.00.49.08;	author jsg;	state Exp;
branches;
next	1.506;

1.506
date	2011.11.02.23.53.44;	author jsg;	state Exp;
branches;
next	1.505;

1.505
date	2011.07.05.04.48.01;	author guenther;	state Exp;
branches;
next	1.504;

1.504
date	2011.07.05.00.30.10;	author deraadt;	state Exp;
branches;
next	1.503;

1.503
date	2011.06.26.22.39.59;	author deraadt;	state Exp;
branches;
next	1.502;

1.502
date	2011.06.26.21.46.03;	author tedu;	state Exp;
branches;
next	1.501;

1.501
date	2011.06.26.21.37.52;	author tedu;	state Exp;
branches;
next	1.500;

1.500
date	2011.06.05.19.41.07;	author deraadt;	state Exp;
branches;
next	1.499;

1.499
date	2011.06.05.15.00.37;	author deraadt;	state Exp;
branches;
next	1.498;

1.498
date	2011.06.05.14.09.10;	author deraadt;	state Exp;
branches;
next	1.497;

1.497
date	2011.05.30.22.25.21;	author oga;	state Exp;
branches;
next	1.496;

1.496
date	2011.05.29.14.50.26;	author deraadt;	state Exp;
branches;
next	1.495;

1.495
date	2011.05.23.09.54.20;	author claudio;	state Exp;
branches;
next	1.494;

1.494
date	2011.04.30.15.33.18;	author mlarkin;	state Exp;
branches;
next	1.493;

1.493
date	2011.04.19.22.14.54;	author jsg;	state Exp;
branches;
next	1.492;

1.492
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.491;

1.491
date	2011.04.16.00.40.58;	author deraadt;	state Exp;
branches;
next	1.490;

1.490
date	2011.04.15.04.52.39;	author guenther;	state Exp;
branches;
next	1.489;

1.489
date	2011.03.20.21.44.08;	author guenther;	state Exp;
branches;
next	1.488;

1.488
date	2011.03.12.03.52.26;	author guenther;	state Exp;
branches;
next	1.487;

1.487
date	2011.01.27.21.27.44;	author jsg;	state Exp;
branches;
next	1.486;

1.486
date	2010.12.29.18.10.17;	author kettenis;	state Exp;
branches;
next	1.485;

1.485
date	2010.10.02.23.31.34;	author deraadt;	state Exp;
branches;
next	1.484;

1.484
date	2010.10.02.23.30.39;	author deraadt;	state Exp;
branches;
next	1.483;

1.483
date	2010.09.29.15.11.31;	author joshe;	state Exp;
branches;
next	1.482;

1.482
date	2010.09.29.13.46.38;	author joshe;	state Exp;
branches;
next	1.481;

1.481
date	2010.08.05.21.10.09;	author deraadt;	state Exp;
branches;
next	1.480;

1.480
date	2010.07.25.21.43.35;	author deraadt;	state Exp;
branches;
next	1.479;

1.479
date	2010.07.23.14.56.31;	author kettenis;	state Exp;
branches;
next	1.478;

1.478
date	2010.07.05.22.20.22;	author tedu;	state Exp;
branches;
next	1.477;

1.477
date	2010.07.03.04.54.32;	author kettenis;	state Exp;
branches;
next	1.476;

1.476
date	2010.07.01.23.05.50;	author kettenis;	state Exp;
branches;
next	1.475;

1.475
date	2010.07.01.17.30.25;	author tedu;	state Exp;
branches;
next	1.474;

1.474
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.473;

1.473
date	2010.06.10.17.54.13;	author deraadt;	state Exp;
branches;
next	1.472;

1.472
date	2010.06.04.15.03.34;	author jsg;	state Exp;
branches;
next	1.471;

1.471
date	2010.05.08.16.54.07;	author oga;	state Exp;
branches;
next	1.470;

1.470
date	2010.05.02.22.26.58;	author kettenis;	state Exp;
branches;
next	1.469;

1.469
date	2010.03.21.23.00.57;	author jsg;	state Exp;
branches;
next	1.468;

1.468
date	2009.12.09.14.27.34;	author oga;	state Exp;
branches;
next	1.467;

1.467
date	2009.12.01.18.59.13;	author jsg;	state Exp;
branches;
next	1.466;

1.466
date	2009.11.26.08.45.12;	author nicm;	state Exp;
branches;
next	1.465;

1.465
date	2009.11.23.16.21.54;	author pirofti;	state Exp;
branches;
next	1.464;

1.464
date	2009.11.18.18.16.46;	author jsg;	state Exp;
branches;
next	1.463;

1.463
date	2009.10.07.07.26.36;	author deraadt;	state Exp;
branches;
next	1.462;

1.462
date	2009.10.07.02.15.48;	author kevlo;	state Exp;
branches;
next	1.461;

1.461
date	2009.09.20.21.58.31;	author jsg;	state Exp;
branches;
next	1.460;

1.460
date	2009.09.20.15.37.23;	author kevlo;	state Exp;
branches;
next	1.459;

1.459
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.458;

1.458
date	2009.08.11.17.15.54;	author oga;	state Exp;
branches;
next	1.457;

1.457
date	2009.08.10.16.40.50;	author oga;	state Exp;
branches;
next	1.456;

1.456
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.455;

1.455
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.454;

1.454
date	2009.07.27.11.28.55;	author dms;	state Exp;
branches;
next	1.453;

1.453
date	2009.06.15.17.01.26;	author beck;	state Exp;
branches;
next	1.452;

1.452
date	2009.06.03.21.30.19;	author beck;	state Exp;
branches;
next	1.451;

1.451
date	2009.06.03.00.41.48;	author weingart;	state Exp;
branches;
next	1.450;

1.450
date	2009.06.01.20.11.38;	author weingart;	state Exp;
branches;
next	1.449;

1.449
date	2009.05.19.01.31.15;	author weingart;	state Exp;
branches;
next	1.448;

1.448
date	2009.03.10.15.03.17;	author oga;	state Exp;
branches;
next	1.447;

1.447
date	2009.02.16.17.24.21;	author krw;	state Exp;
branches;
next	1.446;

1.446
date	2009.02.16.15.44.25;	author jsg;	state Exp;
branches;
next	1.445;

1.445
date	2009.02.14.11.22.25;	author kettenis;	state Exp;
branches;
next	1.444;

1.444
date	2009.01.20.20.21.03;	author mlarkin;	state Exp;
branches;
next	1.443;

1.443
date	2009.01.11.07.12.07;	author jsg;	state Exp;
branches;
next	1.442;

1.442
date	2008.12.18.14.17.28;	author kurt;	state Exp;
branches;
next	1.441;

1.441
date	2008.12.04.15.24.18;	author oga;	state Exp;
branches;
next	1.440;

1.440
date	2008.12.03.15.46.06;	author oga;	state Exp;
branches;
next	1.439;

1.439
date	2008.11.22.18.12.32;	author art;	state Exp;
branches;
next	1.438;

1.438
date	2008.11.14.20.43.54;	author weingart;	state Exp;
branches;
next	1.437;

1.437
date	2008.10.09.19.04.18;	author kettenis;	state Exp;
branches;
next	1.436;

1.436
date	2008.10.06.19.46.21;	author kettenis;	state Exp;
branches;
next	1.435;

1.435
date	2008.07.11.03.03.07;	author dlg;	state Exp;
branches;
next	1.434;

1.434
date	2008.07.07.13.41.59;	author jsg;	state Exp;
branches;
next	1.433;

1.433
date	2008.06.27.17.22.14;	author miod;	state Exp;
branches;
next	1.432;

1.432
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.431;

1.431
date	2008.06.13.00.00.45;	author jsg;	state Exp;
branches;
next	1.430;

1.430
date	2008.06.08.20.57.18;	author miod;	state Exp;
branches;
next	1.429;

1.429
date	2008.05.30.23.10.16;	author fgsch;	state Exp;
branches;
next	1.428;

1.428
date	2008.05.21.18.49.47;	author kettenis;	state Exp;
branches;
next	1.427;

1.427
date	2008.05.07.20.42.02;	author kettenis;	state Exp;
branches;
next	1.426;

1.426
date	2008.04.25.19.50.07;	author kettenis;	state Exp;
branches;
next	1.425;

1.425
date	2008.04.20.16.11.13;	author kettenis;	state Exp;
branches;
next	1.424;

1.424
date	2008.04.18.20.20.35;	author kettenis;	state Exp;
branches;
next	1.423;

1.423
date	2008.04.18.18.54.39;	author kettenis;	state Exp;
branches;
next	1.422;

1.422
date	2008.04.12.12.49.28;	author kettenis;	state Exp;
branches;
next	1.421;

1.421
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.420;

1.420
date	2008.03.30.14.09.20;	author krw;	state Exp;
branches;
next	1.419;

1.419
date	2008.03.17.23.17.22;	author deraadt;	state Exp;
branches;
next	1.418;

1.418
date	2008.02.18.16.31.55;	author kettenis;	state Exp;
branches;
next	1.417;

1.417
date	2008.01.25.19.48.15;	author weingart;	state Exp;
branches;
next	1.416;

1.416
date	2008.01.15.22.22.26;	author weingart;	state Exp;
branches;
next	1.415;

1.415
date	2008.01.13.14.03.21;	author mikeb;	state Exp;
branches;
next	1.414;

1.414
date	2007.11.28.17.17.18;	author tedu;	state Exp;
branches;
next	1.413;

1.413
date	2007.11.28.17.05.09;	author tedu;	state Exp;
branches;
next	1.412;

1.412
date	2007.11.25.10.50.13;	author tom;	state Exp;
branches;
next	1.411;

1.411
date	2007.11.12.01.17.41;	author pascoe;	state Exp;
branches;
next	1.410;

1.410
date	2007.11.03.03.37.08;	author weingart;	state Exp;
branches;
next	1.409;

1.409
date	2007.10.31.15.55.44;	author deraadt;	state Exp;
branches;
next	1.408;

1.408
date	2007.09.30.17.50.20;	author gwk;	state Exp;
branches;
next	1.407;

1.407
date	2007.09.07.15.00.19;	author art;	state Exp;
branches;
next	1.406;

1.406
date	2007.09.03.01.09.09;	author krw;	state Exp;
branches;
next	1.405;

1.405
date	2007.09.01.15.14.44;	author martin;	state Exp;
branches;
next	1.404;

1.404
date	2007.08.22.21.28.41;	author marco;	state Exp;
branches;
next	1.403;

1.403
date	2007.07.20.17.04.14;	author mk;	state Exp;
branches;
next	1.402;

1.402
date	2007.06.07.11.20.58;	author dim;	state Exp;
branches;
next	1.401;

1.401
date	2007.06.06.17.15.12;	author deraadt;	state Exp;
branches;
next	1.400;

1.400
date	2007.06.04.06.57.56;	author jsg;	state Exp;
branches;
next	1.399;

1.399
date	2007.06.03.04.30.31;	author jsg;	state Exp;
branches;
next	1.398;

1.398
date	2007.05.29.21.01.56;	author tedu;	state Exp;
branches;
next	1.397;

1.397
date	2007.05.29.21.00.50;	author jason;	state Exp;
branches;
next	1.396;

1.396
date	2007.05.29.20.36.47;	author deraadt;	state Exp;
branches;
next	1.395;

1.395
date	2007.05.29.18.18.20;	author tom;	state Exp;
branches;
next	1.394;

1.394
date	2007.05.27.21.33.25;	author tom;	state Exp;
branches;
next	1.393;

1.393
date	2007.05.27.17.31.56;	author miod;	state Exp;
branches;
next	1.392;

1.392
date	2007.05.26.22.09.17;	author weingart;	state Exp;
branches;
next	1.391;

1.391
date	2007.05.26.20.26.50;	author pedro;	state Exp;
branches;
next	1.390;

1.390
date	2007.05.25.15.55.26;	author art;	state Exp;
branches;
next	1.389;

1.389
date	2007.05.23.20.33.46;	author pvalchev;	state Exp;
branches;
next	1.388;

1.388
date	2007.05.15.16.27.38;	author art;	state Exp;
branches;
next	1.387;

1.387
date	2007.05.14.04.46.02;	author deraadt;	state Exp;
branches;
next	1.386;

1.386
date	2007.05.14.04.45.49;	author deraadt;	state Exp;
branches;
next	1.385;

1.385
date	2007.05.13.08.18.11;	author gwk;	state Exp;
branches;
next	1.384;

1.384
date	2007.05.04.16.39.28;	author art;	state Exp;
branches;
next	1.383;

1.383
date	2007.04.21.21.06.14;	author gwk;	state Exp;
branches;
next	1.382;

1.382
date	2007.04.12.20.22.58;	author art;	state Exp;
branches;
next	1.381;

1.381
date	2007.04.03.10.14.47;	author art;	state Exp;
branches;
next	1.380;

1.380
date	2007.03.19.09.29.33;	author art;	state Exp;
branches;
next	1.379;

1.379
date	2007.02.21.19.34.25;	author deraadt;	state Exp;
branches;
next	1.378;

1.378
date	2007.02.20.21.15.01;	author tom;	state Exp;
branches;
next	1.377;

1.377
date	2007.02.17.23.59.03;	author marco;	state Exp;
branches;
next	1.376;

1.376
date	2007.02.17.17.38.37;	author tom;	state Exp;
branches;
next	1.375;

1.375
date	2007.02.13.00.22.48;	author jsg;	state Exp;
branches;
next	1.374;

1.374
date	2007.02.03.16.48.23;	author miod;	state Exp;
branches;
next	1.373;

1.373
date	2006.12.23.22.46.13;	author deraadt;	state Exp;
branches;
next	1.372;

1.372
date	2006.12.20.17.50.40;	author gwk;	state Exp;
branches;
next	1.371;

1.371
date	2006.11.29.20.03.19;	author dim;	state Exp;
branches;
next	1.370;

1.370
date	2006.11.28.18.35.19;	author dim;	state Exp;
branches;
next	1.369;

1.369
date	2006.11.28.16.32.09;	author dim;	state Exp;
branches;
next	1.368;

1.368
date	2006.11.28.15.24.08;	author dim;	state Exp;
branches;
next	1.367;

1.367
date	2006.10.17.21.28.23;	author tom;	state Exp;
branches;
next	1.366;

1.366
date	2006.10.05.01.36.41;	author mickey;	state Exp;
branches;
next	1.365;

1.365
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.364;

1.364
date	2006.08.20.01.42.51;	author gwk;	state Exp;
branches;
next	1.363;

1.363
date	2006.08.18.16.08.44;	author dim;	state Exp;
branches;
next	1.362;

1.362
date	2006.07.10.19.45.22;	author gwk;	state Exp;
branches;
next	1.361;

1.361
date	2006.06.17.17.23.39;	author dim;	state Exp;
branches;
next	1.360;

1.360
date	2006.06.15.02.53.15;	author gwk;	state Exp;
branches;
next	1.359;

1.359
date	2006.06.12.13.18.18;	author dim;	state Exp;
branches;
next	1.358;

1.358
date	2006.06.12.07.32.53;	author gwk;	state Exp;
branches;
next	1.357;

1.357
date	2006.05.31.10.34.54;	author todd;	state Exp;
branches;
next	1.356;

1.356
date	2006.05.19.19.43.41;	author dim;	state Exp;
branches;
next	1.355;

1.355
date	2006.05.18.17.36.31;	author dim;	state Exp;
branches;
next	1.354;

1.354
date	2006.05.11.13.21.11;	author mickey;	state Exp;
branches;
next	1.353;

1.353
date	2006.04.27.15.37.51;	author mickey;	state Exp;
branches;
next	1.352;

1.352
date	2006.04.18.17.39.15;	author kettenis;	state Exp;
branches;
next	1.351;

1.351
date	2006.03.24.12.17.03;	author mickey;	state Exp;
branches;
next	1.350;

1.350
date	2006.03.20.12.08.59;	author dlg;	state Exp;
branches;
next	1.349;

1.349
date	2006.03.16.22.23.26;	author deraadt;	state Exp;
branches;
next	1.348;

1.348
date	2006.03.16.22.21.39;	author dim;	state Exp;
branches;
next	1.347;

1.347
date	2006.03.16.02.55.52;	author dlg;	state Exp;
branches;
next	1.346;

1.346
date	2006.03.15.21.03.38;	author deraadt;	state Exp;
branches;
next	1.345;

1.345
date	2006.03.14.09.02.29;	author mickey;	state Exp;
branches;
next	1.344;

1.344
date	2006.03.08.13.52.34;	author kettenis;	state Exp;
branches;
next	1.343;

1.343
date	2006.03.08.08.18.24;	author deraadt;	state Exp;
branches;
next	1.342;

1.342
date	2006.03.08.03.33.21;	author uwe;	state Exp;
branches;
next	1.341;

1.341
date	2006.03.07.05.18.08;	author jsg;	state Exp;
branches;
next	1.340;

1.340
date	2006.02.22.22.16.05;	author miod;	state Exp;
branches;
next	1.339;

1.339
date	2006.01.12.22.39.20;	author weingart;	state Exp;
branches;
next	1.338;

1.338
date	2006.01.06.10.53.16;	author grange;	state Exp;
branches;
next	1.337;

1.337
date	2006.01.06.10.42.34;	author grange;	state Exp;
branches;
next	1.336;

1.336
date	2005.12.16.22.43.12;	author marco;	state Exp;
branches;
next	1.335;

1.335
date	2005.12.16.20.32.20;	author marco;	state Exp;
branches;
next	1.334;

1.334
date	2005.12.16.19.00.30;	author marco;	state Exp;
branches;
next	1.333;

1.333
date	2005.11.23.09.32.46;	author mickey;	state Exp;
branches;
next	1.332;

1.332
date	2005.11.18.17.11.57;	author brad;	state Exp;
branches;
next	1.331;

1.331
date	2005.11.13.17.24.31;	author martin;	state Exp;
branches;
next	1.330;

1.330
date	2005.11.13.14.23.26;	author martin;	state Exp;
branches;
next	1.329;

1.329
date	2005.11.10.14.32.38;	author mickey;	state Exp;
branches;
next	1.328;

1.328
date	2005.11.04.06.55.35;	author tedu;	state Exp;
branches;
next	1.327;

1.327
date	2005.10.28.07.03.41;	author tedu;	state Exp;
branches;
next	1.326;

1.326
date	2005.10.26.20.32.59;	author marco;	state Exp;
branches;
next	1.325;

1.325
date	2005.09.23.02.03.44;	author brad;	state Exp;
branches;
next	1.324;

1.324
date	2005.08.20.00.27.08;	author jsg;	state Exp;
branches
	1.324.2.1;
next	1.323;

1.323
date	2005.08.06.14.26.52;	author miod;	state Exp;
branches;
next	1.322;

1.322
date	2005.07.18.14.55.49;	author mickey;	state Exp;
branches;
next	1.321;

1.321
date	2005.06.26.19.23.53;	author deraadt;	state Exp;
branches;
next	1.320;

1.320
date	2005.06.01.16.41.03;	author mickey;	state Exp;
branches;
next	1.319;

1.319
date	2005.05.28.09.48.54;	author kjell;	state Exp;
branches;
next	1.318;

1.318
date	2005.05.27.10.41.11;	author kjell;	state Exp;
branches;
next	1.317;

1.317
date	2005.04.02.02.44.58;	author tedu;	state Exp;
branches;
next	1.316;

1.316
date	2005.02.24.21.14.11;	author grange;	state Exp;
branches
	1.316.2.1;
next	1.315;

1.315
date	2005.01.07.02.03.17;	author pascoe;	state Exp;
branches;
next	1.314;

1.314
date	2004.12.24.21.22.00;	author pvalchev;	state Exp;
branches;
next	1.313;

1.313
date	2004.12.06.23.40.44;	author hshoexer;	state Exp;
branches;
next	1.312;

1.312
date	2004.12.02.19.40.43;	author miod;	state Exp;
branches;
next	1.311;

1.311
date	2004.11.09.19.17.01;	author claudio;	state Exp;
branches;
next	1.310;

1.310
date	2004.11.02.21.20.59;	author miod;	state Exp;
branches;
next	1.309;

1.309
date	2004.08.24.05.15.50;	author mickey;	state Exp;
branches;
next	1.308;

1.308
date	2004.07.16.06.02.47;	author david;	state Exp;
branches;
next	1.307;

1.307
date	2004.07.15.07.20.40;	author deraadt;	state Exp;
branches;
next	1.306;

1.306
date	2004.07.14.05.34.14;	author tedu;	state Exp;
branches;
next	1.305;

1.305
date	2004.07.05.05.18.42;	author david;	state Exp;
branches;
next	1.304;

1.304
date	2004.07.02.23.22.58;	author deraadt;	state Exp;
branches;
next	1.303;

1.303
date	2004.07.02.16.29.55;	author niklas;	state Exp;
branches;
next	1.302;

1.302
date	2004.06.28.20.51.02;	author deraadt;	state Exp;
branches;
next	1.301;

1.301
date	2004.06.28.17.38.04;	author deraadt;	state Exp;
branches;
next	1.300;

1.300
date	2004.06.22.08.58.16;	author mickey;	state Exp;
branches;
next	1.299;

1.299
date	2004.06.15.23.36.55;	author deraadt;	state Exp;
branches;
next	1.298;

1.298
date	2004.06.15.21.12.31;	author tom;	state Exp;
branches;
next	1.297;

1.297
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.296;

1.296
date	2004.06.09.16.01.48;	author tedu;	state Exp;
branches;
next	1.295;

1.295
date	2004.06.06.17.34.37;	author grange;	state Exp;
branches;
next	1.294;

1.294
date	2004.05.23.20.28.46;	author tedu;	state Exp;
branches;
next	1.293;

1.293
date	2004.05.23.00.06.01;	author tedu;	state Exp;
branches;
next	1.292;

1.292
date	2004.05.19.18.17.00;	author tedu;	state Exp;
branches;
next	1.291;

1.291
date	2004.05.04.17.06.33;	author grange;	state Exp;
branches;
next	1.290;

1.290
date	2004.04.19.22.26.22;	author tom;	state Exp;
branches;
next	1.289;

1.289
date	2004.04.11.18.12.10;	author deraadt;	state Exp;
branches;
next	1.288;

1.288
date	2004.04.02.22.28.40;	author tedu;	state Exp;
branches;
next	1.287;

1.287
date	2004.03.26.04.00.59;	author drahn;	state Exp;
branches;
next	1.286;

1.286
date	2004.03.17.00.59.54;	author tedu;	state Exp;
branches;
next	1.285;

1.285
date	2004.03.10.23.02.53;	author tom;	state Exp;
branches;
next	1.284;

1.284
date	2004.02.27.21.46.44;	author grange;	state Exp;
branches;
next	1.283;

1.283
date	2004.02.27.21.07.48;	author grange;	state Exp;
branches;
next	1.282;

1.282
date	2004.02.19.23.31.58;	author deraadt;	state Exp;
branches;
next	1.281;

1.281
date	2004.02.19.23.10.42;	author deraadt;	state Exp;
branches;
next	1.280;

1.280
date	2004.02.19.22.33.29;	author grange;	state Exp;
branches;
next	1.279;

1.279
date	2004.02.19.21.40.24;	author grange;	state Exp;
branches;
next	1.278;

1.278
date	2004.02.08.20.58.01;	author deraadt;	state Exp;
branches;
next	1.277;

1.277
date	2004.02.05.10.23.56;	author deraadt;	state Exp;
branches;
next	1.276;

1.276
date	2004.02.04.22.54.10;	author grange;	state Exp;
branches;
next	1.275;

1.275
date	2004.02.03.18.38.49;	author deraadt;	state Exp;
branches;
next	1.274;

1.274
date	2004.02.03.08.42.19;	author deraadt;	state Exp;
branches;
next	1.273;

1.273
date	2004.02.02.01.15.58;	author deraadt;	state Exp;
branches;
next	1.272;

1.272
date	2004.02.01.19.23.54;	author deraadt;	state Exp;
branches;
next	1.271;

1.271
date	2004.02.01.19.22.30;	author deraadt;	state Exp;
branches;
next	1.270;

1.270
date	2004.02.01.19.20.30;	author deraadt;	state Exp;
branches;
next	1.269;

1.269
date	2004.02.01.19.16.54;	author deraadt;	state Exp;
branches;
next	1.268;

1.268
date	2004.02.01.19.05.23;	author deraadt;	state Exp;
branches;
next	1.267;

1.267
date	2004.02.01.12.26.45;	author grange;	state Exp;
branches;
next	1.266;

1.266
date	2004.01.31.00.09.41;	author deraadt;	state Exp;
branches;
next	1.265;

1.265
date	2004.01.29.19.01.54;	author tedu;	state Exp;
branches;
next	1.264;

1.264
date	2004.01.29.02.14.52;	author tom;	state Exp;
branches;
next	1.263;

1.263
date	2004.01.29.01.36.13;	author tom;	state Exp;
branches;
next	1.262;

1.262
date	2004.01.24.11.23.20;	author tom;	state Exp;
branches;
next	1.261;

1.261
date	2004.01.12.08.09.23;	author deraadt;	state Exp;
branches;
next	1.260;

1.260
date	2004.01.06.21.09.20;	author tedu;	state Exp;
branches;
next	1.259;

1.259
date	2004.01.03.15.17.48;	author markus;	state Exp;
branches;
next	1.258;

1.258
date	2003.12.29.08.14.18;	author grange;	state Exp;
branches;
next	1.257;

1.257
date	2003.12.20.18.23.18;	author tedu;	state Exp;
branches;
next	1.256;

1.256
date	2003.12.19.22.42.13;	author tedu;	state Exp;
branches;
next	1.255;

1.255
date	2003.12.19.19.03.34;	author grange;	state Exp;
branches;
next	1.254;

1.254
date	2003.12.18.23.46.19;	author tedu;	state Exp;
branches;
next	1.253;

1.253
date	2003.12.14.23.11.28;	author deraadt;	state Exp;
branches;
next	1.252;

1.252
date	2003.12.11.01.09.47;	author deraadt;	state Exp;
branches;
next	1.251;

1.251
date	2003.11.15.19.33.26;	author henning;	state Exp;
branches;
next	1.250;

1.250
date	2003.11.15.19.27.50;	author henning;	state Exp;
branches;
next	1.249;

1.249
date	2003.11.14.07.15.53;	author kevlo;	state Exp;
branches;
next	1.248;

1.248
date	2003.10.29.20.03.54;	author jason;	state Exp;
branches;
next	1.247;

1.247
date	2003.10.29.19.47.59;	author jason;	state Exp;
branches;
next	1.246;

1.246
date	2003.10.15.22.33.34;	author deraadt;	state Exp;
branches;
next	1.245;

1.245
date	2003.10.14.19.38.21;	author jason;	state Exp;
branches;
next	1.244;

1.244
date	2003.09.11.21.48.56;	author deraadt;	state Exp;
branches;
next	1.243;

1.243
date	2003.09.11.19.46.22;	author deraadt;	state Exp;
branches;
next	1.242;

1.242
date	2003.09.02.17.35.53;	author grange;	state Exp;
branches;
next	1.241;

1.241
date	2003.08.19.04.35.16;	author grange;	state Exp;
branches;
next	1.240;

1.240
date	2003.07.25.22.47.54;	author mickey;	state Exp;
branches;
next	1.239;

1.239
date	2003.07.25.21.42.02;	author mickey;	state Exp;
branches;
next	1.238;

1.238
date	2003.07.25.17.41.19;	author tedu;	state Exp;
branches;
next	1.237;

1.237
date	2003.07.07.03.07.19;	author tedu;	state Exp;
branches;
next	1.236;

1.236
date	2003.06.06.11.11.53;	author andreas;	state Exp;
branches;
next	1.235;

1.235
date	2003.06.02.23.27.47;	author millert;	state Exp;
branches;
next	1.234;

1.234
date	2003.06.02.18.14.16;	author jason;	state Exp;
branches;
next	1.233;

1.233
date	2003.05.27.23.52.01;	author fgsch;	state Exp;
branches;
next	1.232;

1.232
date	2003.05.18.02.43.12;	author andreas;	state Exp;
branches;
next	1.231;

1.231
date	2003.05.14.22.53.59;	author tedu;	state Exp;
branches;
next	1.230;

1.230
date	2003.05.14.22.08.04;	author tedu;	state Exp;
branches;
next	1.229;

1.229
date	2003.05.13.03.49.04;	author art;	state Exp;
branches;
next	1.228;

1.228
date	2003.05.05.17.54.59;	author drahn;	state Exp;
branches;
next	1.227;

1.227
date	2003.05.04.04.29.03;	author tedu;	state Exp;
branches;
next	1.226;

1.226
date	2003.04.30.22.37.11;	author mickey;	state Exp;
branches;
next	1.225;

1.225
date	2003.04.17.03.56.20;	author drahn;	state Exp;
branches;
next	1.224;

1.224
date	2003.03.28.00.49.13;	author miod;	state Exp;
branches;
next	1.223;

1.223
date	2003.03.28.00.28.22;	author weingart;	state Exp;
branches;
next	1.222;

1.222
date	2003.03.14.22.05.43;	author deraadt;	state Exp;
branches
	1.222.2.1;
next	1.221;

1.221
date	2003.03.07.19.23.37;	author wilfried;	state Exp;
branches;
next	1.220;

1.220
date	2003.01.16.19.39.23;	author mickey;	state Exp;
branches;
next	1.219;

1.219
date	2003.01.16.04.15.17;	author art;	state Exp;
branches;
next	1.218;

1.218
date	2003.01.15.01.43.44;	author mickey;	state Exp;
branches;
next	1.217;

1.217
date	2002.12.17.23.11.32;	author millert;	state Exp;
branches;
next	1.216;

1.216
date	2002.10.07.18.35.56;	author mickey;	state Exp;
branches;
next	1.215;

1.215
date	2002.10.06.22.06.15;	author art;	state Exp;
branches;
next	1.214;

1.214
date	2002.07.31.02.30.29;	author mickey;	state Exp;
branches
	1.214.2.1;
next	1.213;

1.213
date	2002.07.24.01.15.39;	author mickey;	state Exp;
branches;
next	1.212;

1.212
date	2002.07.20.19.24.56;	author art;	state Exp;
branches;
next	1.211;

1.211
date	2002.07.19.17.30.50;	author mickey;	state Exp;
branches;
next	1.210;

1.210
date	2002.06.18.12.50.55;	author nate;	state Exp;
branches;
next	1.209;

1.209
date	2002.06.08.22.20.49;	author weingart;	state Exp;
branches;
next	1.208;

1.208
date	2002.05.22.18.43.45;	author art;	state Exp;
branches;
next	1.207;

1.207
date	2002.05.18.19.39.01;	author mickey;	state Exp;
branches;
next	1.206;

1.206
date	2002.05.17.18.55.41;	author mickey;	state Exp;
branches;
next	1.205;

1.205
date	2002.05.16.15.33.05;	author mickey;	state Exp;
branches;
next	1.204;

1.204
date	2002.03.30.09.42.28;	author mickey;	state Exp;
branches;
next	1.203;

1.203
date	2002.03.24.00.21.23;	author deraadt;	state Exp;
branches;
next	1.202;

1.202
date	2002.03.23.13.28.34;	author espie;	state Exp;
branches;
next	1.201;

1.201
date	2002.03.18.16.04.24;	author espie;	state Exp;
branches;
next	1.200;

1.200
date	2002.03.14.20.31.31;	author mickey;	state Exp;
branches;
next	1.199;

1.199
date	2002.03.14.16.52.11;	author mickey;	state Exp;
branches;
next	1.198;

1.198
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.197;

1.197
date	2002.02.17.22.59.52;	author maja;	state Exp;
branches;
next	1.196;

1.196
date	2002.01.28.23.14.24;	author mickey;	state Exp;
branches;
next	1.195;

1.195
date	2002.01.23.21.59.52;	author mickey;	state Exp;
branches;
next	1.194;

1.194
date	2002.01.23.17.51.52;	author art;	state Exp;
branches;
next	1.193;

1.193
date	2002.01.23.17.35.56;	author art;	state Exp;
branches;
next	1.192;

1.192
date	2002.01.16.20.50.16;	author miod;	state Exp;
branches;
next	1.191;

1.191
date	2002.01.09.23.08.34;	author nordin;	state Exp;
branches;
next	1.190;

1.190
date	2001.12.14.08.35.12;	author niklas;	state Exp;
branches
	1.190.2.1;
next	1.189;

1.189
date	2001.12.08.02.24.06;	author art;	state Exp;
branches;
next	1.188;

1.188
date	2001.12.07.17.30.14;	author art;	state Exp;
branches;
next	1.187;

1.187
date	2001.11.28.16.24.26;	author art;	state Exp;
branches;
next	1.186;

1.186
date	2001.11.28.16.13.28;	author art;	state Exp;
branches;
next	1.185;

1.185
date	2001.11.28.15.02.58;	author art;	state Exp;
branches;
next	1.184;

1.184
date	2001.11.28.13.47.38;	author art;	state Exp;
branches;
next	1.183;

1.183
date	2001.11.24.17.53.41;	author miod;	state Exp;
branches;
next	1.182;

1.182
date	2001.11.09.15.25.55;	author art;	state Exp;
branches;
next	1.181;

1.181
date	2001.11.07.01.18.00;	author art;	state Exp;
branches;
next	1.180;

1.180
date	2001.11.06.01.43.48;	author art;	state Exp;
branches;
next	1.179;

1.179
date	2001.11.05.17.25.57;	author art;	state Exp;
branches;
next	1.178;

1.178
date	2001.10.04.21.25.03;	author mickey;	state Exp;
branches
	1.178.2.1;
next	1.177;

1.177
date	2001.10.04.21.20.12;	author mickey;	state Exp;
branches;
next	1.176;

1.176
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.175;

1.175
date	2001.09.12.00.23.33;	author art;	state Exp;
branches;
next	1.174;

1.174
date	2001.08.23.14.01.03;	author art;	state Exp;
branches;
next	1.173;

1.173
date	2001.08.23.12.02.04;	author art;	state Exp;
branches;
next	1.172;

1.172
date	2001.08.23.11.06.27;	author art;	state Exp;
branches;
next	1.171;

1.171
date	2001.07.30.14.15.59;	author art;	state Exp;
branches;
next	1.170;

1.170
date	2001.07.25.13.25.32;	author art;	state Exp;
branches;
next	1.169;

1.169
date	2001.07.15.10.54.44;	author niklas;	state Exp;
branches;
next	1.168;

1.168
date	2001.07.15.10.48.30;	author niklas;	state Exp;
branches;
next	1.167;

1.167
date	2001.07.05.10.00.30;	author art;	state Exp;
branches;
next	1.166;

1.166
date	2001.06.29.19.56.37;	author jason;	state Exp;
branches;
next	1.165;

1.165
date	2001.06.27.05.38.28;	author deraadt;	state Exp;
branches;
next	1.164;

1.164
date	2001.06.25.00.43.11;	author mickey;	state Exp;
branches;
next	1.163;

1.163
date	2001.06.08.08.08.51;	author art;	state Exp;
branches;
next	1.162;

1.162
date	2001.05.17.18.41.48;	author provos;	state Exp;
branches;
next	1.161;

1.161
date	2001.05.13.19.06.52;	author jason;	state Exp;
branches;
next	1.160;

1.160
date	2001.05.08.18.19.43;	author jason;	state Exp;
branches;
next	1.159;

1.159
date	2001.05.05.23.25.37;	author art;	state Exp;
branches;
next	1.158;

1.158
date	2001.05.05.22.33.45;	author art;	state Exp;
branches;
next	1.157;

1.157
date	2001.05.05.20.56.38;	author art;	state Exp;
branches;
next	1.156;

1.156
date	2001.04.30.13.23.11;	author art;	state Exp;
branches;
next	1.155;

1.155
date	2001.04.09.07.14.15;	author tholo;	state Exp;
branches;
next	1.154;

1.154
date	2001.03.30.22.18.29;	author mickey;	state Exp;
branches;
next	1.153;

1.153
date	2001.03.28.19.50.07;	author mickey;	state Exp;
branches;
next	1.152;

1.152
date	2001.03.22.23.36.51;	author niklas;	state Exp;
branches;
next	1.151;

1.151
date	2001.03.16.00.24.00;	author deraadt;	state Exp;
branches;
next	1.150;

1.150
date	2001.02.28.19.13.29;	author mickey;	state Exp;
branches;
next	1.149;

1.149
date	2001.02.25.23.24.18;	author aaron;	state Exp;
branches;
next	1.148;

1.148
date	2001.02.04.17.28.17;	author aaron;	state Exp;
branches;
next	1.147;

1.147
date	2001.01.30.00.00.31;	author aaron;	state Exp;
branches;
next	1.146;

1.146
date	2001.01.25.18.49.33;	author mickey;	state Exp;
branches;
next	1.145;

1.145
date	2001.01.25.05.15.24;	author mickey;	state Exp;
branches;
next	1.144;

1.144
date	2001.01.25.04.39.46;	author deraadt;	state Exp;
branches;
next	1.143;

1.143
date	2001.01.24.09.37.58;	author hugh;	state Exp;
branches;
next	1.142;

1.142
date	2001.01.23.21.59.18;	author deraadt;	state Exp;
branches;
next	1.141;

1.141
date	2001.01.05.04.27.23;	author marc;	state Exp;
branches;
next	1.140;

1.140
date	2000.11.16.19.10.58;	author millert;	state Exp;
branches;
next	1.139;

1.139
date	2000.11.13.15.53.33;	author aaron;	state Exp;
branches;
next	1.138;

1.138
date	2000.11.13.13.18.58;	author niklas;	state Exp;
branches;
next	1.137;

1.137
date	2000.10.27.00.16.14;	author mickey;	state Exp;
branches;
next	1.136;

1.136
date	2000.08.11.18.38.58;	author deraadt;	state Exp;
branches;
next	1.135;

1.135
date	2000.07.06.00.59.00;	author todd;	state Exp;
branches;
next	1.134;

1.134
date	2000.06.16.21.47.11;	author provos;	state Exp;
branches;
next	1.133;

1.133
date	2000.05.24.21.07.51;	author bjc;	state Exp;
branches;
next	1.132;

1.132
date	2000.05.15.06.14.25;	author niklas;	state Exp;
branches;
next	1.131;

1.131
date	2000.04.24.18.56.56;	author niklas;	state Exp;
branches;
next	1.130;

1.130
date	2000.04.11.02.44.27;	author pjanzen;	state Exp;
branches;
next	1.129;

1.129
date	2000.04.08.05.50.50;	author aaron;	state Exp;
branches;
next	1.128;

1.128
date	2000.03.23.09.59.54;	author art;	state Exp;
branches;
next	1.127;

1.127
date	2000.03.16.22.11.03;	author art;	state Exp;
branches;
next	1.126;

1.126
date	2000.03.02.00.15.00;	author niklas;	state Exp;
branches;
next	1.125;

1.125
date	2000.02.22.19.27.48;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	2000.02.08.00.14.12;	author niklas;	state Exp;
branches
	1.124.2.1;
next	1.123;

1.123
date	2000.02.03.15.32.23;	author niklas;	state Exp;
branches;
next	1.122;

1.122
date	2000.01.29.21.41.49;	author mickey;	state Exp;
branches;
next	1.121;

1.121
date	2000.01.15.08.59.25;	author deraadt;	state Exp;
branches;
next	1.120;

1.120
date	99.11.27.04.22.08;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	99.11.01.20.51.11;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	99.11.01.20.50.44;	author deraadt;	state Exp;
branches;
next	1.117;

1.117
date	99.11.01.17.15.08;	author art;	state Exp;
branches;
next	1.116;

1.116
date	99.10.26.18.16.48;	author mickey;	state Exp;
branches;
next	1.115;

1.115
date	99.10.14.20.09.09;	author niklas;	state Exp;
branches;
next	1.114;

1.114
date	99.09.30.04.00.42;	author downsj;	state Exp;
branches;
next	1.113;

1.113
date	99.09.03.18.00.50;	author art;	state Exp;
branches;
next	1.112;

1.112
date	99.08.20.10.33.34;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	99.08.12.07.25.12;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	99.08.04.23.17.40;	author niklas;	state Exp;
branches;
next	1.109;

1.109
date	99.07.06.07.59.54;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	99.06.04.16.37.47;	author mickey;	state Exp;
branches;
next	1.107;

1.107
date	99.05.22.21.22.23;	author weingart;	state Exp;
branches;
next	1.106;

1.106
date	99.05.09.15.09.04;	author mickey;	state Exp;
branches;
next	1.105;

1.105
date	99.03.16.08.34.40;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	99.03.09.05.00.40;	author downsj;	state Exp;
branches;
next	1.103;

1.103
date	99.03.08.23.47.26;	author downsj;	state Exp;
branches;
next	1.102;

1.102
date	99.02.26.04.41.13;	author art;	state Exp;
branches;
next	1.101;

1.101
date	99.02.25.21.17.22;	author mickey;	state Exp;
branches;
next	1.100;

1.100
date	99.02.24.22.05.13;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	99.02.23.21.18.27;	author marc;	state Exp;
branches;
next	1.98;

1.98
date	99.02.23.04.10.12;	author marc;	state Exp;
branches;
next	1.97;

1.97
date	99.01.11.05.11.24;	author millert;	state Exp;
branches;
next	1.96;

1.96
date	99.01.06.01.31.20;	author kstailey;	state Exp;
branches;
next	1.95;

1.95
date	98.12.28.11.03.57;	author downsj;	state Exp;
branches;
next	1.94;

1.94
date	98.09.28.05.13.13;	author downsj;	state Exp;
branches;
next	1.93;

1.93
date	98.08.30.07.30.13;	author downsj;	state Exp;
branches;
next	1.92;

1.92
date	98.08.17.18.15.02;	author csapuntz;	state Exp;
branches;
next	1.91;

1.91
date	98.08.16.03.54.21;	author downsj;	state Exp;
branches;
next	1.90;

1.90
date	98.08.04.20.40.46;	author downsj;	state Exp;
branches;
next	1.89;

1.89
date	98.06.04.05.00.27;	author downsj;	state Exp;
branches;
next	1.88;

1.88
date	98.05.25.06.54.48;	author downsj;	state Exp;
branches;
next	1.87;

1.87
date	98.05.22.05.49.07;	author downsj;	state Exp;
branches;
next	1.86;

1.86
date	98.04.26.21.03.15;	author provos;	state Exp;
branches;
next	1.85;

1.85
date	98.04.25.20.31.27;	author mickey;	state Exp;
branches;
next	1.84;

1.84
date	98.03.04.07.22.02;	author downsj;	state Exp;
branches;
next	1.83;

1.83
date	98.03.01.11.25.28;	author niklas;	state Exp;
branches;
next	1.82;

1.82
date	98.02.26.20.53.24;	author weingart;	state Exp;
branches;
next	1.81;

1.81
date	98.02.22.21.35.27;	author niklas;	state Exp;
branches;
next	1.80;

1.80
date	98.02.18.21.13.48;	author marc;	state Exp;
branches;
next	1.79;

1.79
date	98.02.18.01.47.42;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	98.02.17.23.49.29;	author matthieu;	state Exp;
branches;
next	1.77;

1.77
date	98.01.22.02.30.46;	author niklas;	state Exp;
branches;
next	1.76;

1.76
date	98.01.20.18.40.14;	author niklas;	state Exp;
branches;
next	1.75;

1.75
date	98.01.17.09.57.05;	author niklas;	state Exp;
branches;
next	1.74;

1.74
date	98.01.12.20.54.02;	author weingart;	state Exp;
branches;
next	1.73;

1.73
date	98.01.09.14.36.42;	author niklas;	state Exp;
branches;
next	1.72;

1.72
date	98.01.09.12.33.21;	author niklas;	state Exp;
branches;
next	1.71;

1.71
date	98.01.09.12.14.41;	author niklas;	state Exp;
branches;
next	1.70;

1.70
date	98.01.04.11.34.49;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	97.12.17.10.27.32;	author downsj;	state Exp;
branches;
next	1.68;

1.68
date	97.12.17.08.54.48;	author downsj;	state Exp;
branches;
next	1.67;

1.67
date	97.12.09.03.36.40;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	97.12.02.05.06.41;	author mickey;	state Exp;
branches;
next	1.65;

1.65
date	97.12.01.22.58.32;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	97.12.01.04.21.49;	author mickey;	state Exp;
branches;
next	1.63;

1.63
date	97.10.28.09.11.35;	author niklas;	state Exp;
branches;
next	1.62;

1.62
date	97.10.25.22.04.04;	author mickey;	state Exp;
branches;
next	1.61;

1.61
date	97.10.25.21.47.26;	author mickey;	state Exp;
branches;
next	1.60;

1.60
date	97.10.25.20.30.45;	author niklas;	state Exp;
branches;
next	1.59;

1.59
date	97.10.25.08.36.41;	author mickey;	state Exp;
branches;
next	1.58;

1.58
date	97.10.25.06.58.00;	author niklas;	state Exp;
branches;
next	1.57;

1.57
date	97.10.24.22.15.06;	author mickey;	state Exp;
branches;
next	1.56;

1.56
date	97.10.22.23.37.12;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	97.10.02.14.30.04;	author downsj;	state Exp;
branches;
next	1.54;

1.54
date	97.10.02.14.27.48;	author downsj;	state Exp;
branches;
next	1.53;

1.53
date	97.09.28.16.49.41;	author flipk;	state Exp;
branches;
next	1.52;

1.52
date	97.09.24.22.28.15;	author niklas;	state Exp;
branches;
next	1.51;

1.51
date	97.09.22.21.03.53;	author niklas;	state Exp;
branches;
next	1.50;

1.50
date	97.09.22.12.11.19;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	97.09.21.23.00.42;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	97.09.21.04.27.55;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	97.09.02.08.50.30;	author downsj;	state Exp;
branches;
next	1.46;

1.46
date	97.09.02.04.10.19;	author downsj;	state Exp;
branches;
next	1.45;

1.45
date	97.04.17.03.44.50;	author tholo;	state Exp;
branches;
next	1.44;

1.44
date	97.04.04.16.14.09;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	97.04.02.22.02.55;	author niklas;	state Exp;
branches;
next	1.42;

1.42
date	97.02.24.04.05.48;	author downsj;	state Exp;
branches;
next	1.41;

1.41
date	97.02.03.15.04.50;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	97.02.03.12.48.58;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	97.02.01.21.53.23;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	97.02.01.00.58.25;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	97.02.01.00.31.49;	author niklas;	state Exp;
branches;
next	1.36;

1.36
date	97.01.27.22.47.59;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	97.01.27.01.16.12;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	97.01.16.19.57.17;	author kstailey;	state Exp;
branches;
next	1.33;

1.33
date	96.12.29.12.27.26;	author graichen;	state Exp;
branches;
next	1.32;

1.32
date	96.12.10.23.34.12;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	96.12.09.09.54.04;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	96.12.09.08.36.41;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	96.12.05.18.08.06;	author dm;	state Exp;
branches;
next	1.28;

1.28
date	96.11.28.23.37.36;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	96.10.25.11.14.12;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	96.10.25.06.20.14;	author downsj;	state Exp;
branches;
next	1.25;

1.25
date	96.10.23.05.23.39;	author etheisen;	state Exp;
branches;
next	1.24;

1.24
date	96.09.21.07.15.33;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	96.09.12.21.54.41;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	96.06.27.06.13.44;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	96.06.23.19.39.13;	author maja;	state Exp;
branches;
next	1.20;

1.20
date	96.05.30.10.17.53;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	96.05.30.09.30.09;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	96.05.23.08.38.54;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	96.05.07.15.27.51;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	96.05.07.07.21.46;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.05.02.13.41.18;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.04.29.14.13.15;	author hvozda;	state Exp;
branches;
next	1.13;

1.13
date	96.04.21.22.16.31;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.04.18.19.18.11;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	96.04.18.04.19.49;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	96.04.18.04.04.57;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.04.17.05.18.54;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.03.11.11.16.50;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.03.03.03.02.34;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.02.28.14.38.42;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.02.25.23.03.13;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.01.11.17.59.02;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.05.16.17.49;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.15.15.40.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.33;	author deraadt;	state Exp;
branches;
next	;

1.124.2.1
date	2000.03.02.07.04.28;	author niklas;	state Exp;
branches;
next	1.124.2.2;

1.124.2.2
date	2000.03.24.09.07.38;	author niklas;	state Exp;
branches;
next	1.124.2.3;

1.124.2.3
date	2001.04.18.16.07.20;	author niklas;	state Exp;
branches;
next	1.124.2.4;

1.124.2.4
date	2001.07.04.10.16.36;	author niklas;	state Exp;
branches;
next	1.124.2.5;

1.124.2.5
date	2001.07.14.10.02.27;	author ho;	state Exp;
branches;
next	1.124.2.6;

1.124.2.6
date	2001.07.16.21.40.10;	author niklas;	state Exp;
branches;
next	1.124.2.7;

1.124.2.7
date	2001.10.27.09.48.47;	author niklas;	state Exp;
branches;
next	1.124.2.8;

1.124.2.8
date	2001.10.30.19.20.17;	author niklas;	state Exp;
branches;
next	1.124.2.9;

1.124.2.9
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.124.2.10;

1.124.2.10
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.124.2.11;

1.124.2.11
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.124.2.12;

1.124.2.12
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.124.2.13;

1.124.2.13
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.124.2.14;

1.124.2.14
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.124.2.15;

1.124.2.15
date	2003.04.11.16.12.57;	author niklas;	state Exp;
branches;
next	1.124.2.16;

1.124.2.16
date	2003.05.13.19.42.07;	author ho;	state Exp;
branches;
next	1.124.2.17;

1.124.2.17
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.124.2.18;

1.124.2.18
date	2003.05.16.00.29.39;	author niklas;	state Exp;
branches;
next	1.124.2.19;

1.124.2.19
date	2003.05.17.16.07.37;	author andreas;	state Exp;
branches;
next	1.124.2.20;

1.124.2.20
date	2003.05.18.17.41.15;	author niklas;	state Exp;
branches;
next	1.124.2.21;

1.124.2.21
date	2003.05.25.19.24.31;	author ho;	state Exp;
branches;
next	1.124.2.22;

1.124.2.22
date	2003.06.07.11.11.37;	author ho;	state Exp;
branches;
next	1.124.2.23;

1.124.2.23
date	2004.02.19.10.48.41;	author niklas;	state Exp;
branches;
next	1.124.2.24;

1.124.2.24
date	2004.02.20.22.19.55;	author niklas;	state Exp;
branches;
next	1.124.2.25;

1.124.2.25
date	2004.04.21.09.33.08;	author niklas;	state Exp;
branches;
next	1.124.2.26;

1.124.2.26
date	2004.06.05.17.19.54;	author niklas;	state Exp;
branches;
next	1.124.2.27;

1.124.2.27
date	2004.06.05.23.08.59;	author niklas;	state Exp;
branches;
next	1.124.2.28;

1.124.2.28
date	2004.06.06.22.26.33;	author niklas;	state Exp;
branches;
next	1.124.2.29;

1.124.2.29
date	2004.06.07.20.41.09;	author niklas;	state Exp;
branches;
next	1.124.2.30;

1.124.2.30
date	2004.06.08.21.38.02;	author grange;	state Exp;
branches;
next	1.124.2.31;

1.124.2.31
date	2004.06.08.21.41.38;	author grange;	state Exp;
branches;
next	1.124.2.32;

1.124.2.32
date	2004.06.10.11.40.24;	author niklas;	state Exp;
branches;
next	1.124.2.33;

1.124.2.33
date	2004.06.10.20.38.43;	author grange;	state Exp;
branches;
next	1.124.2.34;

1.124.2.34
date	2004.06.13.07.31.56;	author deraadt;	state Exp;
branches;
next	1.124.2.35;

1.124.2.35
date	2004.06.13.18.46.04;	author art;	state Exp;
branches;
next	;

1.178.2.1
date	2002.02.21.04.34.00;	author jason;	state Exp;
branches;
next	;

1.190.2.1
date	2002.01.31.22.55.11;	author niklas;	state Exp;
branches;
next	1.190.2.2;

1.190.2.2
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	1.190.2.3;

1.190.2.3
date	2002.10.29.00.28.04;	author art;	state Exp;
branches;
next	1.190.2.4;

1.190.2.4
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;

1.214.2.1
date	2003.08.09.18.07.11;	author brad;	state Exp;
branches;
next	;

1.222.2.1
date	2003.08.09.18.16.55;	author brad;	state Exp;
branches;
next	;

1.316.2.1
date	2006.01.13.00.49.21;	author brad;	state Exp;
branches;
next	;

1.324.2.1
date	2006.01.13.01.56.54;	author brad;	state Exp;
branches;
next	;


desc
@@


1.603
log
@Remove an "#if 1" that had been in the code for 16 years. I think it's
safe to say it's been enabled long enough to warrant permanent inclusion.
@
text
@/*	$OpenBSD: machdep.c,v 1.602 2017/05/30 15:11:32 deraadt Exp $	*/
/*	$NetBSD: machdep.c,v 1.214 1996/11/10 03:16:17 thorpej Exp $	*/

/*-
 * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1993, 1994, 1995, 1996 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1992 Terrence R. Lambert.
 * Copyright (c) 1982, 1987, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)machdep.c	7.4 (Berkeley) 6/3/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/msgbuf.h>
#include <sys/mount.h>
#include <sys/vnode.h>
#include <sys/device.h>
#include <sys/extent.h>
#include <sys/sysctl.h>
#include <sys/syscallargs.h>
#include <sys/core.h>
#include <sys/kcore.h>
#include <sys/sensors.h>

#include <dev/cons.h>
#include <stand/boot/bootarg.h>

#include <net/if.h>
#include <uvm/uvm_extern.h>

#include <machine/bus.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/cpuvar.h>
#include <machine/gdt.h>
#include <machine/kcore.h>
#include <machine/pio.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/specialreg.h>
#include <machine/biosvar.h>
#include <machine/pte.h>
#ifdef MULTIPROCESSOR
#include <machine/mpbiosvar.h>
#endif /* MULTIPROCESSOR */

#include <dev/rndvar.h>
#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#include <dev/ic/i8042reg.h>
#include <dev/ic/mc146818reg.h>
#include <i386/isa/isa_machdep.h>
#include <i386/isa/nvram.h>

#include "acpi.h"
#if NACPI > 0
#include <dev/acpi/acpivar.h>
#endif

#include "apm.h"
#if NAPM > 0
#include <machine/apmvar.h>
#endif

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_access.h>
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>
#endif

#ifdef VM86
#include <machine/vm86.h>
#endif

#include "isa.h"
#include "isadma.h"
#include "npx.h"
#if NNPX > 0
extern struct proc *npxproc;
#endif

#include "bios.h"
#include "com.h"

#if NCOM > 0
#include <sys/termios.h>
#include <dev/ic/comreg.h>
#include <dev/ic/comvar.h>
#endif /* NCOM > 0 */

#ifdef HIBERNATE
#include <machine/hibernate_var.h>
#endif /* HIBERNATE */

#include "ukbd.h"
#include "pckbc.h"
#if NPCKBC > 0 && NUKBD > 0
#include <dev/ic/pckbcvar.h>
#endif

#include "vmm.h"

void	replacesmap(void);
int     intr_handler(struct intrframe *, struct intrhand *);

/* the following is used externally (sysctl_hw) */
char machine[] = MACHINE;

/*
 * switchto vectors
 */
void (*cpu_idle_leave_fcn)(void) = NULL;
void (*cpu_idle_cycle_fcn)(void) = NULL;
void (*cpu_idle_enter_fcn)(void) = NULL;

/*
 * Declare these as initialized data so we can patch them.
 */
#if NAPM > 0
int	cpu_apmhalt = 0;	/* sysctl'd to 1 for halt -p hack */
#endif

struct uvm_constraint_range  isa_constraint = { 0x0, 0x00ffffffUL };
struct uvm_constraint_range  dma_constraint = { 0x0, 0xffffffffUL };
struct uvm_constraint_range *uvm_md_constraints[] = {
	&isa_constraint,
	&dma_constraint,
	NULL
};

extern int	boothowto;
int	physmem;

struct dumpmem dumpmem[VM_PHYSSEG_MAX];
u_int ndumpmem;

/*
 * These variables are needed by /sbin/savecore
 */
u_long	dumpmag = 0x8fca0101;	/* magic number */
int	dumpsize = 0;		/* pages */
long	dumplo = 0;		/* blocks */

int	cpu_class;
int	i386_fpu_present;
int	i386_fpu_exception;
int	i386_fpu_fdivbug;

int	i386_use_fxsave;
int	i386_has_sse;
int	i386_has_sse2;
int	i386_has_xcrypt;

bootarg_t *bootargp;
paddr_t avail_end;

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

#if !defined(SMALL_KERNEL)
int p4_model;
int p3_early;
void (*update_cpuspeed)(void) = NULL;
void	via_update_sensor(void *args);
#endif
int kbd_reset;
int lid_action = 1;
int forceukbd;

/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int	safepri = 0;

#if !defined(SMALL_KERNEL)
int bus_clock;
#endif
void (*setperf_setup)(struct cpu_info *);
int setperf_prio = 0;		/* for concurrent handlers */

void (*cpusensors_setup)(struct cpu_info *);

void (*delay_func)(int) = i8254_delay;
void (*initclock_func)(void) = i8254_initclocks;

/*
 * Extent maps to manage I/O and ISA memory hole space.  Allocate
 * storage for 16 regions in each, initially.  Later, ioport_malloc_safe
 * will indicate that it's safe to use malloc() to dynamically allocate
 * region descriptors.
 *
 * N.B. At least two regions are _always_ allocated from the iomem
 * extent map; (0 -> ISA hole) and (end of ISA hole -> end of RAM).
 *
 * The extent maps are not static!  Machine-dependent ISA and EISA
 * routines need access to them for bus address space allocation.
 */
static	long ioport_ex_storage[EXTENT_FIXED_STORAGE_SIZE(16) / sizeof(long)];
static	long iomem_ex_storage[EXTENT_FIXED_STORAGE_SIZE(16) / sizeof(long)];
struct	extent *ioport_ex;
struct	extent *iomem_ex;
static	int ioport_malloc_safe;

void	dumpsys(void);
int	cpu_dump(void);
void	init386(paddr_t);
void	consinit(void);
void	(*cpuresetfn)(void);

int	bus_mem_add_mapping(bus_addr_t, bus_size_t,
	    int, bus_space_handle_t *);

#ifdef APERTURE
int allowaperture = 0;
#endif

int has_rdrand;
int has_rdseed;

#include "pvbus.h"
#if NPVBUS > 0
#include <dev/pv/pvvar.h>
#endif

void	winchip_cpu_setup(struct cpu_info *);
void	amd_family5_setperf_setup(struct cpu_info *);
void	amd_family5_setup(struct cpu_info *);
void	amd_family6_setperf_setup(struct cpu_info *);
void	amd_family6_setup(struct cpu_info *);
void	cyrix3_setperf_setup(struct cpu_info *);
void	cyrix3_cpu_setup(struct cpu_info *);
void	cyrix6x86_cpu_setup(struct cpu_info *);
void	natsem6x86_cpu_setup(struct cpu_info *);
void	intel586_cpu_setup(struct cpu_info *);
void	intel686_cpusensors_setup(struct cpu_info *);
void	intel686_setperf_setup(struct cpu_info *);
void	intel686_common_cpu_setup(struct cpu_info *);
void	intel686_cpu_setup(struct cpu_info *);
void	intel686_p4_cpu_setup(struct cpu_info *);
void	intelcore_update_sensor(void *);
void	tm86_cpu_setup(struct cpu_info *);
char *	intel686_cpu_name(int);
char *	cyrix3_cpu_name(int, int);
char *	tm86_cpu_name(int);
void	cyrix3_get_bus_clock(struct cpu_info *);
void	p4_get_bus_clock(struct cpu_info *);
void	p3_get_bus_clock(struct cpu_info *);
void	p4_update_cpuspeed(void);
void	p3_update_cpuspeed(void);
int	pentium_cpuspeed(int *);
#if NVMM > 0
void	cpu_check_vmm_cap(struct cpu_info *);
#endif /* NVMM > 0 */

static __inline u_char
cyrix_read_reg(u_char reg)
{
	outb(0x22, reg);
	return inb(0x23);
}

static __inline void
cyrix_write_reg(u_char reg, u_char data)
{
	outb(0x22, reg);
	outb(0x23, data);
}

/*
 * cpuid instruction.  request in eax, result in eax, ebx, ecx, edx.
 * requires caller to provide u_int32_t regs[4] array.
 */
void
cpuid(u_int32_t ax, u_int32_t *regs)
{
	__asm volatile(
	    "cpuid\n\t"
	    "movl	%%eax, 0(%2)\n\t"
	    "movl	%%ebx, 4(%2)\n\t"
	    "movl	%%ecx, 8(%2)\n\t"
	    "movl	%%edx, 12(%2)\n\t"
	    :"=a" (ax)
	    :"0" (ax), "S" (regs)
	    :"bx", "cx", "dx");
}

/*
 * Machine-dependent startup code
 */
void
cpu_startup(void)
{
	unsigned i;
	vaddr_t minaddr, maxaddr, va;
	paddr_t pa;

	/*
	 * Initialize error message buffer (at end of core).
	 * (space reserved in pmap_bootstrap)
	 */
	pa = avail_end;
	va = (vaddr_t)msgbufp;
	for (i = 0; i < atop(MSGBUFSIZE); i++) {
		pmap_kenter_pa(va, pa, PROT_READ | PROT_WRITE);
		va += PAGE_SIZE;
		pa += PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));

	printf("%s", version);
	startclocks();

	/*
	 * We need to call identifycpu here early, so users have at least some
	 * basic information, if booting hangs later on.
	 */
	strlcpy(curcpu()->ci_dev.dv_xname, "cpu0",
	    sizeof(curcpu()->ci_dev.dv_xname));
	curcpu()->ci_signature = cpu_id;
	curcpu()->ci_feature_flags = cpu_feature;
	identifycpu(curcpu());

	printf("real mem  = %llu (%lluMB)\n",
	    (unsigned long long)ptoa((psize_t)physmem),
	    (unsigned long long)ptoa((psize_t)physmem)/1024U/1024U);

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate a submap for physio
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
				   VM_PHYS_SIZE, 0, FALSE, NULL);

	printf("avail mem = %llu (%lluMB)\n",
	    (unsigned long long)ptoa((psize_t)uvmexp.free),
	    (unsigned long long)ptoa((psize_t)uvmexp.free)/1024U/1024U);

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
	ioport_malloc_safe = 1;
}

/*
 * Set up proc0's TSS
 */
void
i386_proc0_tss_init(void)
{
	struct pcb *pcb;

	curpcb = pcb = &proc0.p_addr->u_pcb;

	pcb->pcb_tss.tss_ioopt = sizeof(pcb->pcb_tss) << 16;
	pcb->pcb_cr0 = rcr0();
	pcb->pcb_tss.tss_ss0 = GSEL(GDATA_SEL, SEL_KPL);
	pcb->pcb_tss.tss_esp0 = (int)proc0.p_addr + USPACE - 16;
	proc0.p_md.md_regs = (struct trapframe *)pcb->pcb_tss.tss_esp0 - 1;
	proc0.p_md.md_tss_sel = tss_alloc(pcb);

	ltr(proc0.p_md.md_tss_sel);
	lldt(0);
}

#ifdef MULTIPROCESSOR
void
i386_init_pcb_tss(struct cpu_info *ci)
{
	struct pcb *pcb = ci->ci_idle_pcb;

	pcb->pcb_tss.tss_ioopt = sizeof(pcb->pcb_tss) << 16;
	pcb->pcb_cr0 = rcr0();
	ci->ci_idle_tss_sel = tss_alloc(pcb);
}
#endif	/* MULTIPROCESSOR */

/*
 * Info for CTL_HW
 */
char	cpu_model[120];

/*
 * Note: these are just the ones that may not have a cpuid instruction.
 * We deal with the rest in a different way.
 */
const struct cpu_nocpuid_nameclass i386_nocpuid_cpus[] = {
	{ CPUVENDOR_INTEL, "Intel", "386SX",	CPUCLASS_386,
		NULL},				/* CPU_386SX */
	{ CPUVENDOR_INTEL, "Intel", "386DX",	CPUCLASS_386,
		NULL},				/* CPU_386   */
	{ CPUVENDOR_INTEL, "Intel", "486SX",	CPUCLASS_486,
		NULL},				/* CPU_486SX */
	{ CPUVENDOR_INTEL, "Intel", "486DX",	CPUCLASS_486,
		NULL},				/* CPU_486   */
	{ CPUVENDOR_CYRIX, "Cyrix", "486DLC",	CPUCLASS_486,
		NULL},				/* CPU_486DLC */
	{ CPUVENDOR_CYRIX, "Cyrix", "6x86",	CPUCLASS_486,
		cyrix6x86_cpu_setup},		/* CPU_6x86 */
	{ CPUVENDOR_NEXGEN,"NexGen","586",	CPUCLASS_386,
		NULL},				/* CPU_NX586 */
};

const char *classnames[] = {
	"386",
	"486",
	"586",
	"686"
};

const char *modifiers[] = {
	"",
	"OverDrive ",
	"Dual ",
	""
};

const struct cpu_cpuid_nameclass i386_cpuid_cpus[] = {
	{
		"GenuineIntel",
		CPUVENDOR_INTEL,
		"Intel",
		/* Family 4 */
		{ {
			CPUCLASS_486,
			{
				"486DX", "486DX", "486SX", "486DX2", "486SL",
				"486SX2", 0, "486DX2 W/B",
				"486DX4", 0, 0, 0, 0, 0, 0, 0,
				"486"		/* Default */
			},
			NULL
		},
		/* Family 5 */
		{
			CPUCLASS_586,
			{
				"Pentium (A-step)", "Pentium (P5)",
				"Pentium (P54C)", "Pentium (P24T)",
				"Pentium/MMX", "Pentium", 0,
				"Pentium (P54C)", "Pentium/MMX",
				0, 0, 0, 0, 0, 0, 0,
				"Pentium"	/* Default */
			},
			intel586_cpu_setup
		},
		/* Family 6 */
		{
			CPUCLASS_686,
			{
				"Pentium Pro", "Pentium Pro", 0,
				"Pentium II", "Pentium Pro",
				"Pentium II/Celeron",
				"Celeron",
				"Pentium III",
				"Pentium III",
				"Pentium M",
				"Pentium III Xeon",
				"Pentium III", 0,
				"Pentium M",
				"Core Duo/Solo", 0,
				"Pentium Pro, II or III"	/* Default */
			},
			intel686_cpu_setup
		},
		/* Family 7 */
		{
			CPUCLASS_686,
		} ,
		/* Family 8 */
		{
			CPUCLASS_686,
		} ,
		/* Family 9 */
		{
			CPUCLASS_686,
		} ,
		/* Family A */
		{
			CPUCLASS_686,
		} ,
		/* Family B */
		{
			CPUCLASS_686,
		} ,
		/* Family C */
		{
			CPUCLASS_686,
		} ,
		/* Family D */
		{
			CPUCLASS_686,
		} ,
		/* Family E */
		{
			CPUCLASS_686,
		} ,
		/* Family F */
		{
			CPUCLASS_686,
			{
				"Pentium 4", 0, 0, 0,
				0, 0, 0, 0,
				0, 0, 0, 0,
				0, 0, 0, 0,
				"Pentium 4"	/* Default */
			},
			intel686_p4_cpu_setup
		} }
	},
	{
		"AuthenticAMD",
		CPUVENDOR_AMD,
		"AMD",
		/* Family 4 */
		{ {
			CPUCLASS_486,
			{
				0, 0, 0, "Am486DX2 W/T",
				0, 0, 0, "Am486DX2 W/B",
				"Am486DX4 W/T or Am5x86 W/T 150",
				"Am486DX4 W/B or Am5x86 W/B 150", 0, 0,
				0, 0, "Am5x86 W/T 133/160",
				"Am5x86 W/B 133/160",
				"Am486 or Am5x86"	/* Default */
			},
			NULL
		},
		/* Family 5 */
		{
			CPUCLASS_586,
			{
				"K5", "K5", "K5", "K5", 0, 0, "K6",
				"K6", "K6-2", "K6-III", 0, 0, 0,
				"K6-2+/III+", 0, 0,
				"K5 or K6"		/* Default */
			},
			amd_family5_setup
		},
		/* Family 6 */
		{
			CPUCLASS_686,
			{
				0, "Athlon Model 1", "Athlon Model 2",
				"Duron Model 3",
				"Athlon Model 4",
				0, "Athlon XP Model 6",
				"Duron Model 7",
				"Athlon XP Model 8",
				0, "Athlon XP Model 10",
				0, 0, 0, 0, 0,
				"K7"		/* Default */
			},
			amd_family6_setup
		},
		/* Family 7 */
		{
			CPUCLASS_686,
		} ,
		/* Family 8 */
		{
			CPUCLASS_686,
		} ,
		/* Family 9 */
		{
			CPUCLASS_686,
		} ,
		/* Family A */
		{
			CPUCLASS_686,
		} ,
		/* Family B */
		{
			CPUCLASS_686,
		} ,
		/* Family C */
		{
			CPUCLASS_686,
		} ,
		/* Family D */
		{
			CPUCLASS_686,
		} ,
		/* Family E */
		{
			CPUCLASS_686,
		} ,
		/* Family F */
		{
			CPUCLASS_686,
			{
				0, 0, 0, 0, "Athlon64",
				"Opteron or Athlon64FX", 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
				"AMD64"			/* DEFAULT */
			},
			amd_family6_setup
		} }
	},
	{
		"CyrixInstead",
		CPUVENDOR_CYRIX,
		"Cyrix",
		/* Family 4 */
		{ {
			CPUCLASS_486,
			{
				0, 0, 0, "MediaGX", 0, 0, 0, 0, "5x86", 0, 0,
				0, 0, 0, 0,
				"486 class"	/* Default */
			},
			NULL
		},
		/* Family 5 */
		{
			CPUCLASS_586,
			{
				0, 0, "6x86", 0, "GXm", 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0,
				"586 class"	/* Default */
			},
			cyrix6x86_cpu_setup
		},
		/* Family 6 */
		{
			CPUCLASS_686,
			{
				"6x86MX", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0,
				"686 class"	/* Default */
			},
			NULL
		} }
	},
	{
		"CentaurHauls",
		CPUVENDOR_IDT,
		"IDT",
		/* Family 4, not available from IDT */
		{ {
			CPUCLASS_486,
			{
				0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
				"486 class"		/* Default */
			},
			NULL
		},
		/* Family 5 */
		{
			CPUCLASS_586,
			{
				0, 0, 0, 0, "WinChip C6", 0, 0, 0,
				"WinChip 2", "WinChip 3", 0, 0, 0, 0, 0, 0,
				"WinChip"		/* Default */
			},
			winchip_cpu_setup
		},
		/* Family 6 */
		{
			CPUCLASS_686,
			{
				0, 0, 0, 0, 0, 0,
				"C3 Samuel",
				"C3 Samuel 2/Ezra",
				"C3 Ezra-T",
				"C3 Nehemiah", "C3 Esther", 0, 0, 0, 0, 0,
				"C3"		/* Default */
			},
			cyrix3_cpu_setup
		} }
	},
	{
		"RiseRiseRise",
		CPUVENDOR_RISE,
		"Rise",
		/* Family 4, not available from Rise */
		{ {
			CPUCLASS_486,
			{
				0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
				"486 class"		/* Default */
			},
			NULL
		},
		/* Family 5 */
		{
			CPUCLASS_586,
			{
				"mP6", 0, "mP6", 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
				"mP6"			/* Default */
			},
			NULL
		},
		/* Family 6, not yet available from Rise */
		{
			CPUCLASS_686,
			{
				0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
				"686 class"		/* Default */
			},
			NULL
		} }
	},
	{
		"GenuineTMx86",
		CPUVENDOR_TRANSMETA,
		"Transmeta",
		/* Family 4, not available from Transmeta */
		{ {
			CPUCLASS_486,
			{
				0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
				"486 class"		/* Default */
			},
			NULL
		},
		/* Family 5 */
		{
			CPUCLASS_586,
			{
				0, 0, 0, 0, "TMS5x00", 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0,
				"TMS5x00"		/* Default */
			},
			tm86_cpu_setup
		},
		/* Family 6, not yet available from Transmeta */
		{
			CPUCLASS_686,
			{
				0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
				"686 class"		/* Default */
			},
			NULL
		},
		/* Family 7 */
		{
			CPUCLASS_686,
		} ,
		/* Family 8 */
		{
			CPUCLASS_686,
		} ,
		/* Family 9 */
		{
			CPUCLASS_686,
		} ,
		/* Family A */
		{
			CPUCLASS_686,
		} ,
		/* Family B */
		{
			CPUCLASS_686,
		} ,
		/* Family C */
		{
			CPUCLASS_686,
		} ,
		/* Family D */
		{
			CPUCLASS_686,
		} ,
		/* Family E */
		{
			CPUCLASS_686,
		} ,
		/* Family F */
		{
			/* Extended processor family - Transmeta Efficeon */
			CPUCLASS_686,
			{
				0, 0, "TM8000", "TM8000",
				0, 0, 0, 0,
				0, 0, 0, 0,
				0, 0, 0, 0,
				"TM8000"	/* Default */
			},
			tm86_cpu_setup
		} }
	},
	{
		"Geode by NSC",
		CPUVENDOR_NS,
		"National Semiconductor",
		/* Family 4, not available from National Semiconductor */
		{ {
			CPUCLASS_486,
			{
				0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
				"486 class"	/* Default */
			},
			NULL
		},
		/* Family 5 */
		{
			CPUCLASS_586,
			{
				0, 0, 0, 0, "Geode GX1", 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0,
				"586 class"	/* Default */
			},
			natsem6x86_cpu_setup
		} }
	},
	{
		"SiS SiS SiS ",
		CPUVENDOR_SIS,
		"SiS",
		/* Family 4, not available from SiS */
		{ {
			CPUCLASS_486,
			{
				0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
				"486 class"	/* Default */
			},
			NULL
		},
		/* Family 5 */
		{
			CPUCLASS_586,
			{
				"SiS55x", 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0,
				"586 class"	/* Default */
			},
			NULL
		} }
	}
};

const struct cpu_cpuid_feature i386_cpuid_features[] = {
	{ CPUID_FPU,	"FPU" },
	{ CPUID_VME,	"V86" },
	{ CPUID_DE,	"DE" },
	{ CPUID_PSE,	"PSE" },
	{ CPUID_TSC,	"TSC" },
	{ CPUID_MSR,	"MSR" },
	{ CPUID_PAE,	"PAE" },
	{ CPUID_MCE,	"MCE" },
	{ CPUID_CX8,	"CX8" },
	{ CPUID_APIC,	"APIC" },
	{ CPUID_SYS1,	"SYS" },
	{ CPUID_SEP,	"SEP" },
	{ CPUID_MTRR,	"MTRR" },
	{ CPUID_PGE,	"PGE" },
	{ CPUID_MCA,	"MCA" },
	{ CPUID_CMOV,	"CMOV" },
	{ CPUID_PAT,	"PAT" },
	{ CPUID_PSE36,	"PSE36" },
	{ CPUID_PSN,	"PSN" },
	{ CPUID_CFLUSH,	"CFLUSH" },
	{ CPUID_DS,	"DS" },
	{ CPUID_ACPI,	"ACPI" },
	{ CPUID_MMX,	"MMX" },
	{ CPUID_FXSR,	"FXSR" },
	{ CPUID_SSE,	"SSE" },
	{ CPUID_SSE2,	"SSE2" },
	{ CPUID_SS,	"SS" },
	{ CPUID_HTT,	"HTT" },
	{ CPUID_TM,	"TM" },
	{ CPUID_PBE,	"PBE" }
};

const struct cpu_cpuid_feature i386_ecpuid_features[] = {
	{ CPUID_MPC,		"MPC" },
	{ CPUID_NXE,		"NXE" },
	{ CPUID_MMXX,		"MMXX" },
	{ CPUID_FFXSR,		"FFXSR" },
	{ CPUID_PAGE1GB,	"PAGE1GB" },
	{ CPUID_LONG,		"LONG" },
	{ CPUID_3DNOW2,		"3DNOW2" },
	{ CPUID_3DNOW,		"3DNOW" }
};

const struct cpu_cpuid_feature i386_cpuid_ecxfeatures[] = {
	{ CPUIDECX_SSE3,	"SSE3" },
	{ CPUIDECX_PCLMUL,	"PCLMUL" },
	{ CPUIDECX_DTES64,	"DTES64" },
	{ CPUIDECX_MWAIT,	"MWAIT" },
	{ CPUIDECX_DSCPL,	"DS-CPL" },
	{ CPUIDECX_VMX,		"VMX" },
	{ CPUIDECX_SMX,		"SMX" },
	{ CPUIDECX_EST,		"EST" },
	{ CPUIDECX_TM2,		"TM2" },
	{ CPUIDECX_SSSE3,	"SSSE3" },
	{ CPUIDECX_CNXTID,	"CNXT-ID" },
	{ CPUIDECX_SDBG,	"SDBG" },
	{ CPUIDECX_FMA3,	"FMA3" },
	{ CPUIDECX_CX16,	"CX16" },
	{ CPUIDECX_XTPR,	"xTPR" },
	{ CPUIDECX_PDCM,	"PDCM" },
	{ CPUIDECX_PCID,	"PCID" },
	{ CPUIDECX_DCA,		"DCA" },
	{ CPUIDECX_SSE41,	"SSE4.1" },
	{ CPUIDECX_SSE42,	"SSE4.2" },
	{ CPUIDECX_X2APIC,	"x2APIC" },
	{ CPUIDECX_MOVBE,	"MOVBE" },
	{ CPUIDECX_POPCNT,	"POPCNT" },
	{ CPUIDECX_DEADLINE,	"DEADLINE" },
	{ CPUIDECX_AES,		"AES" },
	{ CPUIDECX_XSAVE,	"XSAVE" },
	{ CPUIDECX_OSXSAVE,	"OSXSAVE" },
	{ CPUIDECX_AVX,		"AVX" },
	{ CPUIDECX_F16C,	"F16C" },
	{ CPUIDECX_RDRAND,	"RDRAND" },
	{ CPUIDECX_HV,		"HV" },
};

const struct cpu_cpuid_feature i386_ecpuid_ecxfeatures[] = {
	{ CPUIDECX_LAHF,	"LAHF" },
	{ CPUIDECX_CMPLEG,	"CMPLEG" },
	{ CPUIDECX_SVM,		"SVM" },
	{ CPUIDECX_EAPICSP,	"EAPICSP" },
	{ CPUIDECX_AMCR8,	"AMCR8" },
	{ CPUIDECX_ABM,		"ABM" },
	{ CPUIDECX_SSE4A,	"SSE4A" },
	{ CPUIDECX_MASSE,	"MASSE" },
	{ CPUIDECX_3DNOWP,	"3DNOWP" },
	{ CPUIDECX_OSVW,	"OSVW" },
	{ CPUIDECX_IBS,		"IBS" },
	{ CPUIDECX_XOP,		"XOP" },
	{ CPUIDECX_SKINIT,	"SKINIT" },
	{ CPUIDECX_WDT,		"WDT" },
	{ CPUIDECX_LWP,		"LWP" },
	{ CPUIDECX_FMA4,	"FMA4" },
	{ CPUIDECX_NODEID,	"NODEID" },
	{ CPUIDECX_TBM,		"TBM" },
	{ CPUIDECX_TOPEXT,	"TOPEXT" },
};

const struct cpu_cpuid_feature cpu_seff0_ebxfeatures[] = {
	{ SEFF0EBX_FSGSBASE,	"FSGSBASE" },
	{ SEFF0EBX_SGX,		"SGX" },
	{ SEFF0EBX_BMI1,	"BMI1" },
	{ SEFF0EBX_HLE,		"HLE" },
	{ SEFF0EBX_AVX2,	"AVX2" },
	{ SEFF0EBX_SMEP,	"SMEP" },
	{ SEFF0EBX_BMI2,	"BMI2" },
	{ SEFF0EBX_ERMS,	"ERMS" },
	{ SEFF0EBX_INVPCID,	"INVPCID" },
	{ SEFF0EBX_RTM,		"RTM" },
	{ SEFF0EBX_PQM,		"PQM" },
	{ SEFF0EBX_MPX,		"MPX" },
	{ SEFF0EBX_AVX512F,	"AVX512F" },
	{ SEFF0EBX_AVX512DQ,	"AVX512DQ" },
	{ SEFF0EBX_RDSEED,	"RDSEED" },
	{ SEFF0EBX_ADX,		"ADX" },
	{ SEFF0EBX_SMAP,	"SMAP" },
	{ SEFF0EBX_AVX512IFMA,	"AVX512IFMA" },
	{ SEFF0EBX_PCOMMIT,	"PCOMMIT" },
	{ SEFF0EBX_CLFLUSHOPT,	"CLFLUSHOPT" },
	{ SEFF0EBX_CLWB,	"CLWB" },
	{ SEFF0EBX_PT,		"PT" },
	{ SEFF0EBX_AVX512PF,	"AVX512PF" },
	{ SEFF0EBX_AVX512ER,	"AVX512ER" },
	{ SEFF0EBX_AVX512CD,	"AVX512CD" },
	{ SEFF0EBX_SHA,		"SHA" },
	{ SEFF0EBX_AVX512BW,	"AVX512BW" },
	{ SEFF0EBX_AVX512VL,	"AVX512VL" },
};

const struct cpu_cpuid_feature cpu_seff0_ecxfeatures[] = {
	{ SEFF0ECX_PREFETCHWT1,	"PREFETCHWT1" },
	{ SEFF0ECX_UMIP,	"UMIP" },
	{ SEFF0ECX_AVX512VBMI,	"AVX512VBMI" },
	{ SEFF0ECX_PKU,		"PKU" },
};

const struct cpu_cpuid_feature cpu_tpm_eaxfeatures[] = {
	{ TPM_SENSOR,		"SENSOR" },
	{ TPM_ARAT,		"ARAT" },
};

const struct cpu_cpuid_feature i386_cpuid_eaxperf[] = {
	{ CPUIDEAX_VERID,	"PERF" },
};

const struct cpu_cpuid_feature i386_cpuid_edxapmi[] = {
	{ CPUIDEDX_ITSC,	"ITSC" },
};

void
winchip_cpu_setup(struct cpu_info *ci)
{

	switch ((ci->ci_signature >> 4) & 15) { /* model */
	case 4: /* WinChip C6 */
		ci->ci_feature_flags &= ~CPUID_TSC;
		/* Disable RDTSC instruction from user-level. */
		lcr4(rcr4() | CR4_TSD);
		printf("%s: TSC disabled\n", ci->ci_dev.dv_xname);
		break;
	}
}

#if !defined(SMALL_KERNEL)
void
cyrix3_setperf_setup(struct cpu_info *ci)
{
	if (cpu_ecxfeature & CPUIDECX_EST) {
		if (rdmsr(MSR_MISC_ENABLE) & (1 << 16))
			est_init(ci, CPUVENDOR_VIA);
		else
			printf("%s: Enhanced SpeedStep disabled by BIOS\n",
			    ci->ci_dev.dv_xname);
	}
}
#endif

void
cyrix3_cpu_setup(struct cpu_info *ci)
{
	int model = (ci->ci_signature >> 4) & 15;
	int step = ci->ci_signature & 15;

	u_int64_t msreg;
	u_int32_t regs[4];
	unsigned int val;
#if !defined(SMALL_KERNEL)
	extern void (*pagezero)(void *, size_t);
	extern void i686_pagezero(void *, size_t);

	pagezero = i686_pagezero;

	setperf_setup = cyrix3_setperf_setup;
#endif

	switch (model) {
	/* Possible earlier models */
	case 0: case 1: case 2:
	case 3: case 4: case 5:
		break;

	case 6: /* C3 Samuel 1 */
	case 7: /* C3 Samuel 2 or C3 Ezra */
	case 8: /* C3 Ezra-T */
		cpuid(0x80000001, regs);
		val = regs[3];
		if (val & (1U << 31)) {
			cpu_feature |= CPUID_3DNOW;
		} else {
			cpu_feature &= ~CPUID_3DNOW;
		}
		break;

	case 9:
		if (step < 3)
			break;
		/*
		 * C3 Nehemiah & later: fall through.
		 */
	
	case 10: /* C7-M Type A */
	case 13: /* C7-M Type D */
	case 15: /* Nano */
#if !defined(SMALL_KERNEL)
		if (CPU_IS_PRIMARY(ci) &&
		    (model == 10 || model == 13 || model == 15)) {
			/* Setup the sensors structures */
			strlcpy(ci->ci_sensordev.xname, ci->ci_dev.dv_xname,
			    sizeof(ci->ci_sensordev.xname));
			ci->ci_sensor.type = SENSOR_TEMP;
			sensor_task_register(ci, via_update_sensor, 5);
			sensor_attach(&ci->ci_sensordev, &ci->ci_sensor);
			sensordev_install(&ci->ci_sensordev);
		}
#endif

	default:
		/*
		 * C3 Nehemiah/Esther & later models:
		 * First we check for extended feature flags, and then
		 * (if present) retrieve the ones at 0xC0000001.  In this
		 * bit 2 tells us if the RNG is present.  Bit 3 tells us
		 * if the RNG has been enabled.  In order to use the RNG
		 * we need 3 things:  We need an RNG, we need the FXSR bit
		 * enabled in cr4 (SSE/SSE2 stuff), and we need to have
		 * Bit 6 of MSR 0x110B set to 1 (the default), which will
		 * show up as bit 3 set here.
		 */
		cpuid(0xC0000000, regs); /* Check for RNG */
		val = regs[0];
		if (val >= 0xC0000001) {
			cpuid(0xC0000001, regs);
			val = regs[3];
		} else
			val = 0;

		if (val & (C3_CPUID_HAS_RNG | C3_CPUID_HAS_ACE))
			printf("%s:", ci->ci_dev.dv_xname);

		/* Enable RNG if present and disabled */
		if (val & C3_CPUID_HAS_RNG) {
			extern int viac3_rnd_present;

			if (!(val & C3_CPUID_DO_RNG)) {
				msreg = rdmsr(0x110B);
				msreg |= 0x40;
				wrmsr(0x110B, msreg);
			}
			viac3_rnd_present = 1;
			printf(" RNG");
		}

		/* Enable AES engine if present and disabled */
		if (val & C3_CPUID_HAS_ACE) {
#ifdef CRYPTO
			if (!(val & C3_CPUID_DO_ACE)) {
				msreg = rdmsr(0x1107);
				msreg |= (0x01 << 28);
				wrmsr(0x1107, msreg);
			}
			i386_has_xcrypt |= C3_HAS_AES;
#endif /* CRYPTO */
			printf(" AES");
		}

		/* Enable ACE2 engine if present and disabled */
		if (val & C3_CPUID_HAS_ACE2) {
#ifdef CRYPTO
			if (!(val & C3_CPUID_DO_ACE2)) {
				msreg = rdmsr(0x1107);
				msreg |= (0x01 << 28);
				wrmsr(0x1107, msreg);
			}
			i386_has_xcrypt |= C3_HAS_AESCTR;
#endif /* CRYPTO */
			printf(" AES-CTR");
		}

		/* Enable SHA engine if present and disabled */
		if (val & C3_CPUID_HAS_PHE) {
#ifdef CRYPTO
			if (!(val & C3_CPUID_DO_PHE)) {
				msreg = rdmsr(0x1107);
				msreg |= (0x01 << 28/**/);
				wrmsr(0x1107, msreg);
			}
			i386_has_xcrypt |= C3_HAS_SHA;
#endif /* CRYPTO */
			printf(" SHA1 SHA256");
		}

		/* Enable MM engine if present and disabled */
		if (val & C3_CPUID_HAS_PMM) {
#ifdef CRYPTO
			if (!(val & C3_CPUID_DO_PMM)) {
				msreg = rdmsr(0x1107);
				msreg |= (0x01 << 28/**/);
				wrmsr(0x1107, msreg);
			}
			i386_has_xcrypt |= C3_HAS_MM;
#endif /* CRYPTO */
			printf(" RSA");
		}

		printf("\n");
		break;
	}
}

#if !defined(SMALL_KERNEL)
void
via_update_sensor(void *args)
{
	struct cpu_info *ci = (struct cpu_info *) args;
	u_int64_t msr;

	switch (ci->ci_model) {
	case 0xa:
	case 0xd:
		msr = rdmsr(MSR_C7M_TMTEMPERATURE);
		break;
	case 0xf:
		msr = rdmsr(MSR_CENT_TMTEMPERATURE);
		break;
	}
	ci->ci_sensor.value = (msr & 0xffffff);
	/* micro degrees */
	ci->ci_sensor.value *= 1000000;
	ci->ci_sensor.value += 273150000;
	ci->ci_sensor.flags &= ~SENSOR_FINVALID;
}
#endif

void
cyrix6x86_cpu_setup(struct cpu_info *ci)
{
	extern int clock_broken_latch;

	switch ((ci->ci_signature >> 4) & 15) { /* model */
	case -1: /* M1 w/o cpuid */
	case 2:	/* M1 */
		/* set up various cyrix registers */
		/* Enable suspend on halt */
		cyrix_write_reg(0xc2, cyrix_read_reg(0xc2) | 0x08);
		/* enable access to ccr4/ccr5 */
		cyrix_write_reg(0xC3, cyrix_read_reg(0xC3) | 0x10);
		/* cyrix's workaround  for the "coma bug" */
		cyrix_write_reg(0x31, cyrix_read_reg(0x31) | 0xf8);
		cyrix_write_reg(0x32, cyrix_read_reg(0x32) | 0x7f);
		cyrix_read_reg(0x33); cyrix_write_reg(0x33, 0);
		cyrix_write_reg(0x3c, cyrix_read_reg(0x3c) | 0x87);
		/* disable access to ccr4/ccr5 */
		cyrix_write_reg(0xC3, cyrix_read_reg(0xC3) & ~0x10);

		printf("%s: xchg bug workaround performed\n",
		    ci->ci_dev.dv_xname);
		break;	/* fallthrough? */
	case 4:	/* GXm */
		/* Unset the TSC bit until calibrate_delay() gets fixed. */
		clock_broken_latch = 1;
		curcpu()->ci_feature_flags &= ~CPUID_TSC;
		printf("%s: TSC disabled\n", ci->ci_dev.dv_xname);
		break;
	}
}

void
natsem6x86_cpu_setup(struct cpu_info *ci)
{
	extern int clock_broken_latch;
	int model = (ci->ci_signature >> 4) & 15;

	clock_broken_latch = 1;
	switch (model) {
	case 4:
		cpu_feature &= ~CPUID_TSC;
		printf("%s: TSC disabled\n", ci->ci_dev.dv_xname);
		break;
	}
}

void
intel586_cpu_setup(struct cpu_info *ci)
{
	if (!cpu_f00f_bug) {
		fix_f00f();
		printf("%s: F00F bug workaround installed\n",
		    ci->ci_dev.dv_xname);
	}
}

#if !defined(SMALL_KERNEL)
void
amd_family5_setperf_setup(struct cpu_info *ci)
{
	k6_powernow_init();
}
#endif

void
amd_family5_setup(struct cpu_info *ci)
{
	int model = (ci->ci_signature >> 4) & 15;

	switch (model) {
	case 0:		/* AMD-K5 Model 0 */
		/*
		 * According to the AMD Processor Recognition App Note,
		 * the AMD-K5 Model 0 uses the wrong bit to indicate
		 * support for global PTEs, instead using bit 9 (APIC)
		 * rather than bit 13 (i.e. "0x200" vs. 0x2000".  Oops!).
		 */
		if (cpu_feature & CPUID_APIC)
			cpu_feature = (cpu_feature & ~CPUID_APIC) | CPUID_PGE;
		/*
		 * XXX But pmap_pg_g is already initialized -- need to kick
		 * XXX the pmap somehow.  How does the MP branch do this?
		 */
		break;
	case 12:
	case 13:
#if !defined(SMALL_KERNEL)
		setperf_setup = amd_family5_setperf_setup;
#endif
		break;
	}
}

#if !defined(SMALL_KERNEL)
void
amd_family6_setperf_setup(struct cpu_info *ci)
{
	int family = (ci->ci_signature >> 8) & 15;

	switch (family) {
	case 6:
		k7_powernow_init();
		break;
	case 15:
		k8_powernow_init();
		break;
	}
	if (ci->ci_family >= 0x10)
		k1x_init(ci);
}
#endif

void
amd_family6_setup(struct cpu_info *ci)
{
#if !defined(SMALL_KERNEL)
	int family = (ci->ci_signature >> 8) & 15;
	extern void (*pagezero)(void *, size_t);
	extern void sse2_pagezero(void *, size_t);
	extern void i686_pagezero(void *, size_t);

	if (cpu_feature & CPUID_SSE2)
		pagezero = sse2_pagezero;
	else
		pagezero = i686_pagezero;

	setperf_setup = amd_family6_setperf_setup;

	if (family == 0xf) {
		amd64_errata(ci);
	}
#endif
}

#if !defined(SMALL_KERNEL)
/*
 * Temperature read on the CPU is relative to the maximum
 * temperature supported by the CPU, Tj(Max).
 * Refer to:
 * 64-ia-32-architectures-software-developer-vol-3c-part-3-manual.pdf
 * Section 35 and
 * http://www.intel.com/content/dam/www/public/us/en/documents/
 * white-papers/cpu-monitoring-dts-peci-paper.pdf
 *
 * The temperature on Intel CPUs can be between 70 and 105 degC, since
 * Westmere we can read the TJmax from the die. For older CPUs we have
 * to guess or use undocumented MSRs. Then we subtract the temperature
 * portion of thermal status from max to get current temperature.
 */
void
intelcore_update_sensor(void *args)
{
	struct cpu_info *ci = (struct cpu_info *) args;
	u_int64_t msr;
	int max = 100;

	/* Only some Core family chips have MSR_TEMPERATURE_TARGET. */
	if (ci->ci_model == 0x0e &&
	    (rdmsr(MSR_TEMPERATURE_TARGET_UNDOCUMENTED) &
	     MSR_TEMPERATURE_TARGET_LOW_BIT_UNDOCUMENTED))
		max = 85;

	/*
	 * Newer CPUs can tell you what their max temperature is.
	 * See: '64-ia-32-architectures-software-developer-
	 * vol-3c-part-3-manual.pdf'
	 */
	if (ci->ci_model > 0x17 && ci->ci_model != 0x1c &&
	    ci->ci_model != 0x26 && ci->ci_model != 0x27 &&
	    ci->ci_model != 0x35 && ci->ci_model != 0x36)
		max = MSR_TEMPERATURE_TARGET_TJMAX(
		    rdmsr(MSR_TEMPERATURE_TARGET));

	msr = rdmsr(MSR_THERM_STATUS);
	if (msr & MSR_THERM_STATUS_VALID_BIT) {
		ci->ci_sensor.value = max - MSR_THERM_STATUS_TEMP(msr);
		/* micro degrees */
		ci->ci_sensor.value *= 1000000;
		/* kelvin */
		ci->ci_sensor.value += 273150000;
		ci->ci_sensor.flags &= ~SENSOR_FINVALID;
	} else {
		ci->ci_sensor.value = 0;
		ci->ci_sensor.flags |= SENSOR_FINVALID;
	}
}

void
intel686_cpusensors_setup(struct cpu_info *ci)
{
	if (!CPU_IS_PRIMARY(ci) || (ci->ci_feature_tpmflags & TPM_SENSOR) == 0)
		return;

	/* Setup the sensors structures */
	strlcpy(ci->ci_sensordev.xname, ci->ci_dev.dv_xname,
	    sizeof(ci->ci_sensordev.xname));
	ci->ci_sensor.type = SENSOR_TEMP;
	sensor_task_register(ci, intelcore_update_sensor, 5);
	sensor_attach(&ci->ci_sensordev, &ci->ci_sensor);
	sensordev_install(&ci->ci_sensordev);
}
#endif

#if !defined(SMALL_KERNEL)
void
intel686_setperf_setup(struct cpu_info *ci)
{
	int family = (ci->ci_signature >> 8) & 15;
	int step = ci->ci_signature & 15;

	if (cpu_ecxfeature & CPUIDECX_EST) {
		if (rdmsr(MSR_MISC_ENABLE) & (1 << 16))
			est_init(ci, CPUVENDOR_INTEL);
		else
			printf("%s: Enhanced SpeedStep disabled by BIOS\n",
			    ci->ci_dev.dv_xname);
	} else if ((cpu_feature & (CPUID_ACPI | CPUID_TM)) ==
	    (CPUID_ACPI | CPUID_TM))
		p4tcc_init(family, step);
}
#endif

void
intel686_common_cpu_setup(struct cpu_info *ci)
{

#if !defined(SMALL_KERNEL)
	setperf_setup = intel686_setperf_setup;
	cpusensors_setup = intel686_cpusensors_setup;
	{
	extern void (*pagezero)(void *, size_t);
	extern void sse2_pagezero(void *, size_t);
	extern void i686_pagezero(void *, size_t);

	if (cpu_feature & CPUID_SSE2)
		pagezero = sse2_pagezero;
	else
		pagezero = i686_pagezero;
	}
#endif
	/*
	 * Make sure SYSENTER is disabled.
	 */
	if (cpu_feature & CPUID_SEP)
		wrmsr(MSR_SYSENTER_CS, 0);
}

void
intel686_cpu_setup(struct cpu_info *ci)
{
	int model = (ci->ci_signature >> 4) & 15;
	int step = ci->ci_signature & 15;
	u_quad_t msr119;

	intel686_common_cpu_setup(ci);

	/*
	 * Original PPro returns SYSCALL in CPUID but is non-functional.
	 * From Intel Application Note #485.
	 */
	if ((model == 1) && (step < 3))
		ci->ci_feature_flags &= ~CPUID_SEP;

	/*
	 * Disable the Pentium3 serial number.
	 */
	if ((model == 7) && (ci->ci_feature_flags & CPUID_PSN)) {
		msr119 = rdmsr(MSR_BBL_CR_CTL);
		msr119 |= 0x0000000000200000LL;
		wrmsr(MSR_BBL_CR_CTL, msr119);

		printf("%s: disabling processor serial number\n",
			 ci->ci_dev.dv_xname);
		ci->ci_feature_flags &= ~CPUID_PSN;
		ci->ci_level = 2;
	}

#if !defined(SMALL_KERNEL)
	p3_early = (model == 8 && step == 1) ? 1 : 0;
	update_cpuspeed = p3_update_cpuspeed;
#endif
}

void
intel686_p4_cpu_setup(struct cpu_info *ci)
{
	intel686_common_cpu_setup(ci);

#if !defined(SMALL_KERNEL)
	p4_model = (ci->ci_signature >> 4) & 15;
	update_cpuspeed = p4_update_cpuspeed;
#endif
}

void
tm86_cpu_setup(struct cpu_info *ci)
{
#if !defined(SMALL_KERNEL)
	longrun_init();
#endif
}

char *
intel686_cpu_name(int model)
{
	char *ret = NULL;

	switch (model) {
	case 5:
		switch (cpu_cache_edx & 0xFF) {
		case 0x40:
		case 0x41:
			ret = "Celeron";
			break;
		/* 0x42 should not exist in this model. */
		case 0x43:
			ret = "Pentium II";
			break;
		case 0x44:
		case 0x45:
			ret = "Pentium II Xeon";
			break;
		}
		break;
	case 7:
		switch (cpu_cache_edx & 0xFF) {
		/* 0x40 - 0x42 should not exist in this model. */
		case 0x43:
			ret = "Pentium III";
			break;
		case 0x44:
		case 0x45:
			ret = "Pentium III Xeon";
			break;
		}
		break;
	}

	return (ret);
}

char *
cyrix3_cpu_name(int model, int step)
{
	char	*name = NULL;

	switch (model) {
	case 7:
		if (step < 8)
			name = "C3 Samuel 2";
		else
			name = "C3 Ezra";
		break;
	}
	return name;
}

/*
 * Print identification for the given CPU.
 * XXX XXX
 * This is not as clean as one might like, because it references
 *
 * the "cpuid_level" and "cpu_vendor" globals.
 * cpuid_level isn't so bad, since both CPU's will hopefully
 * be of the same level.
 *
 * The Intel multiprocessor spec doesn't give us the cpu_vendor
 * information; however, the chance of multi-vendor SMP actually
 * ever *working* is sufficiently low that it's probably safe to assume
 * all processors are of the same vendor.
 *
 * Note that identifycpu() is called twice for the primary CPU: the first
 * is very early (right after the "OpenBSD X.Y" line) with the CPUF_PRIMARY
 * flag *not* set, then again later in the config sequence with CPUF_PRIMARY
 * set.  Thus, the tests here for ((ci->ci_flags & CPUF_PRIMARY) == 0) are
 * actually saying "do this on the first call for each CPU".  Don't change
 * them to use CPU_IS_PRIMARY() because then they would be done on both
 * calls in the SP build.
 */

void
identifycpu(struct cpu_info *ci)
{
	const char *name, *modifier, *vendorname, *token;
	int class = CPUCLASS_386, vendor, i, max;
	int family, model, step, modif, cachesize;
	const struct cpu_cpuid_nameclass *cpup = NULL;
	char *brandstr_from, *brandstr_to;
	char *cpu_device = ci->ci_dev.dv_xname;
	int skipspace;

	if (cpuid_level == -1) {
#ifdef DIAGNOSTIC
		if (cpu < 0 || cpu >=
		    (sizeof i386_nocpuid_cpus/sizeof(struct cpu_nocpuid_nameclass)))
			panic("unknown cpu type %d", cpu);
#endif
		name = i386_nocpuid_cpus[cpu].cpu_name;
		vendor = i386_nocpuid_cpus[cpu].cpu_vendor;
		vendorname = i386_nocpuid_cpus[cpu].cpu_vendorname;
		model = -1;
		step = -1;
		class = i386_nocpuid_cpus[cpu].cpu_class;
		ci->cpu_setup = i386_nocpuid_cpus[cpu].cpu_setup;
		modifier = "";
		token = "";
	} else {
		max = sizeof (i386_cpuid_cpus) / sizeof (i386_cpuid_cpus[0]);
		modif = (ci->ci_signature >> 12) & 3;
		family = (ci->ci_signature >> 8) & 15;
		ci->ci_family = family;
		model = (ci->ci_signature >> 4) & 15;
		ci->ci_model = model;
		step = ci->ci_signature & 15;
#ifdef CPUDEBUG
		printf("%s: family %x model %x step %x\n", cpu_device, family,
		    model, step);
		printf("%s: cpuid level %d cache eax %x ebx %x ecx %x edx %x\n",
		    cpu_device, cpuid_level, cpu_cache_eax, cpu_cache_ebx,
		    cpu_cache_ecx, cpu_cache_edx);
#endif
		if (family < CPU_MINFAMILY)
			panic("identifycpu: strange family value");

		for (i = 0; i < max; i++) {
			if (!strncmp(cpu_vendor,
			    i386_cpuid_cpus[i].cpu_id, 12)) {
				cpup = &i386_cpuid_cpus[i];
				break;
			}
		}

		if (cpup == NULL) {
			vendor = CPUVENDOR_UNKNOWN;
			if (cpu_vendor[0] != '\0')
				vendorname = &cpu_vendor[0];
			else
				vendorname = "Unknown";
			if (family > CPU_MAXFAMILY)
				family = CPU_MAXFAMILY;
			class = family - 3;
			if (class > CPUCLASS_686)
				class = CPUCLASS_686;
			modifier = "";
			name = "";
			token = "";
			ci->cpu_setup = NULL;
		} else {
			token = cpup->cpu_id;
			vendor = cpup->cpu_vendor;
			vendorname = cpup->cpu_vendorname;
			/*
			 * Special hack for the VIA C3 series.
			 *
			 * VIA bought Centaur Technology from IDT in Aug 1999
			 * and marketed the processors as VIA Cyrix III/C3.
			 */
			if (vendor == CPUVENDOR_IDT && family >= 6) {
				vendor = CPUVENDOR_VIA;
				vendorname = "VIA";
			}
			modifier = modifiers[modif];
			if (family > CPU_MAXFAMILY) {
				family = CPU_MAXFAMILY;
				model = CPU_DEFMODEL;
			} else if (model > CPU_MAXMODEL)
				model = CPU_DEFMODEL;
			i = family - CPU_MINFAMILY;

			/* store extended family/model values for later use */
			if ((vendor == CPUVENDOR_INTEL &&
			    (family == 0x6 || family == 0xf)) ||
			    (vendor == CPUVENDOR_AMD && family == 0xf)) {
				ci->ci_family += (ci->ci_signature >> 20) &
				    0xff;
				ci->ci_model += ((ci->ci_signature >> 16) &
				    0x0f) << 4;
			}

			/* Special hack for the PentiumII/III series. */
			if (vendor == CPUVENDOR_INTEL && family == 6 &&
			    (model == 5 || model == 7)) {
				name = intel686_cpu_name(model);
			/* Special hack for the VIA C3 series. */
			} else if (vendor == CPUVENDOR_VIA && family == 6 &&
			    model == 7) {
				name = cyrix3_cpu_name(model, step);
			/* Special hack for the TMS5x00 series. */
			} else if (vendor == CPUVENDOR_TRANSMETA &&
			    family == 5 && model == 4) {
				name = tm86_cpu_name(model);
			} else
				name = cpup->cpu_family[i].cpu_models[model];
			if (name == NULL) {
				name = cpup->cpu_family[i].cpu_models[CPU_DEFMODEL];
				if (name == NULL)
					name = "";
			}
			class = cpup->cpu_family[i].cpu_class;
			ci->cpu_setup = cpup->cpu_family[i].cpu_setup;
		}
	}

	/* Find the amount of on-chip L2 cache. */
	cachesize = -1;
	if (vendor == CPUVENDOR_INTEL && cpuid_level >= 2 && family < 0xf) {
		int intel_cachetable[] = { 0, 128, 256, 512, 1024, 2048 };

		if ((cpu_cache_edx & 0xFF) >= 0x40 &&
		    (cpu_cache_edx & 0xFF) <= 0x45)
			cachesize = intel_cachetable[(cpu_cache_edx & 0xFF) - 0x40];
	} else if (vendor == CPUVENDOR_AMD && class == CPUCLASS_686) {
		u_int regs[4];
		cpuid(0x80000000, regs);

		if (regs[0] >= 0x80000005)
			cpuid(0x80000005, ci->ci_amdcacheinfo);

		if (regs[0] >= 0x80000006) {
			cpuid(0x80000006, ci->ci_extcacheinfo);
			cachesize = (ci->ci_extcacheinfo[2] >> 16);
		}
	}

	if (vendor == CPUVENDOR_INTEL) {
		u_int regs[4];
		/*
		 * PIII, Core Solo and Core Duo CPUs have known
		 * errata stating:
		 * "Page with PAT set to WC while associated MTRR is UC
		 * may consolidate to UC".
		 * Because of this it is best we just fallback to mtrrs
		 * in this case.
		 */
		if (ci->ci_family == 6 && ci->ci_model < 15)
		    ci->ci_feature_flags &= ~CPUID_PAT;

		if (ci->ci_feature_flags & CPUID_CFLUSH) {
			/* to get the cacheline size you must do cpuid
			 * with eax 0x01
			 */

			cpuid(0x01, regs); 
			ci->ci_cflushsz = ((regs[1] >> 8) & 0xff) * 8;
		}

		cpuid(0x80000000, regs);
		if (regs[0] >= 0x80000006)
			cpuid(0x80000006, ci->ci_extcacheinfo);
	}

	/* Remove leading, trailing and duplicated spaces from cpu_brandstr */
	brandstr_from = brandstr_to = cpu_brandstr;
	skipspace = 1;
	while (*brandstr_from != '\0') {
		if (!skipspace || *brandstr_from != ' ') {
			skipspace = 0;
			*(brandstr_to++) = *brandstr_from;
		}
		if (*brandstr_from == ' ')
			skipspace = 1;
		brandstr_from++;
	}
	if (skipspace && brandstr_to > cpu_brandstr)
		brandstr_to--;
	*brandstr_to = '\0';

	if (cpu_brandstr[0] == '\0') {
		snprintf(cpu_brandstr, 48 /* sizeof(cpu_brandstr) */,
		    "%s %s%s", vendorname, modifier, name);
	}

	if ((ci->ci_flags & CPUF_PRIMARY) == 0) {
		if (cachesize > -1) {
			snprintf(cpu_model, sizeof(cpu_model),
			    "%s (%s%s%s%s-class, %dKB L2 cache)",
			    cpu_brandstr,
			    ((*token) ? "\"" : ""), ((*token) ? token : ""),
			    ((*token) ? "\" " : ""), classnames[class], cachesize);
		} else {
			snprintf(cpu_model, sizeof(cpu_model),
			    "%s (%s%s%s%s-class)",
			    cpu_brandstr,
			    ((*token) ? "\"" : ""), ((*token) ? token : ""),
			    ((*token) ? "\" " : ""), classnames[class]);
		}

		printf("%s: %s", cpu_device, cpu_model);
	}

	if (ci->ci_feature_flags && (ci->ci_feature_flags & CPUID_TSC)) {
		/* Has TSC, check if it's constant */
		switch (vendor) {
		case CPUVENDOR_INTEL:
			if ((ci->ci_family == 0x0f && ci->ci_model >= 0x03) ||
			    (ci->ci_family == 0x06 && ci->ci_model >= 0x0e)) {
				ci->ci_flags |= CPUF_CONST_TSC;
			}
			break;
		case CPUVENDOR_VIA:
			if (ci->ci_model >= 0x0f) {
				ci->ci_flags |= CPUF_CONST_TSC;
			}
			break;
		}
		calibrate_cyclecounter();
		if (cpuspeed > 994) {
			int ghz, fr;

			ghz = (cpuspeed + 9) / 1000;
			fr = ((cpuspeed + 9) / 10 ) % 100;
			if ((ci->ci_flags & CPUF_PRIMARY) == 0) {
				if (fr)
					printf(" %d.%02d GHz", ghz, fr);
				else
					printf(" %d GHz", ghz);
			}
		} else {
			if ((ci->ci_flags & CPUF_PRIMARY) == 0) {
				printf(" %d MHz", cpuspeed);
			}
		}
	}
	if ((ci->ci_flags & CPUF_PRIMARY) == 0) {
		printf("\n");

		if (ci->ci_feature_flags) {
			int numbits = 0;

			printf("%s: ", cpu_device);
			max = sizeof(i386_cpuid_features) /
			    sizeof(i386_cpuid_features[0]);
			for (i = 0; i < max; i++) {
				if (ci->ci_feature_flags &
				    i386_cpuid_features[i].feature_bit) {
					printf("%s%s", (numbits == 0 ? "" : ","),
					    i386_cpuid_features[i].feature_name);
					numbits++;
				}
			}
			for (i = 0; i < nitems(i386_ecpuid_features); i++) {
				if (ecpu_feature &
				    i386_ecpuid_features[i].feature_bit) {
					printf("%s%s", (numbits == 0 ? "" : ","),
					    i386_ecpuid_features[i].feature_name);
					numbits++;
				}
			}
			max = sizeof(i386_cpuid_ecxfeatures)
				/ sizeof(i386_cpuid_ecxfeatures[0]);
			for (i = 0; i < max; i++) {
				if (cpu_ecxfeature &
				    i386_cpuid_ecxfeatures[i].feature_bit) {
					printf("%s%s", (numbits == 0 ? "" : ","),
					    i386_cpuid_ecxfeatures[i].feature_name);
					numbits++;
				}
			}
			for (i = 0; i < nitems(i386_ecpuid_ecxfeatures); i++) {
				if (ecpu_ecxfeature &
				    i386_ecpuid_ecxfeatures[i].feature_bit) {
					printf("%s%s", (numbits == 0 ? "" : ","),
					    i386_ecpuid_ecxfeatures[i].feature_name);
					numbits++;
				}
			}
			for (i = 0; i < nitems(i386_cpuid_eaxperf); i++) {
				if (cpu_perf_eax &
				    i386_cpuid_eaxperf[i].feature_bit) {
					printf("%s%s", (numbits == 0 ? "" : ","),
					    i386_cpuid_eaxperf[i].feature_name);
					numbits++;
				}
			}
			for (i = 0; i < nitems(i386_cpuid_edxapmi); i++) {
				if (cpu_apmi_edx &
				    i386_cpuid_edxapmi[i].feature_bit) {
					printf("%s%s", (numbits == 0 ? "" : ","),
					    i386_cpuid_edxapmi[i].feature_name);
					numbits++;
				}
			}

			if (cpuid_level >= 0x07) {
				u_int dummy;

				/* "Structured Extended Feature Flags" */
				CPUID_LEAF(0x7, 0, dummy,
				    ci->ci_feature_sefflags_ebx,
				    ci->ci_feature_sefflags_ecx, dummy);
				for (i = 0; i < nitems(cpu_seff0_ebxfeatures); i++)
					if (ci->ci_feature_sefflags_ebx &
					    cpu_seff0_ebxfeatures[i].feature_bit)
						printf("%s%s",
						    (numbits == 0 ? "" : ","),
						    cpu_seff0_ebxfeatures[i].feature_name);
				for (i = 0; i < nitems(cpu_seff0_ecxfeatures); i++)
					if (ci->ci_feature_sefflags_ecx &
					    cpu_seff0_ecxfeatures[i].feature_bit)
						printf("%s%s",
						    (numbits == 0 ? "" : ","),
						    cpu_seff0_ecxfeatures[i].feature_name);
			}

			if (!strcmp(cpu_vendor, "GenuineIntel") &&
			    cpuid_level >= 0x06 ) {
				u_int dummy;

				CPUID(0x06, ci->ci_feature_tpmflags, dummy,
				    dummy, dummy);
				max = nitems(cpu_tpm_eaxfeatures);
				for (i = 0; i < max; i++)
					if (ci->ci_feature_tpmflags &
					    cpu_tpm_eaxfeatures[i].feature_bit)
						printf(",%s", cpu_tpm_eaxfeatures[i].feature_name);
			}

			printf("\n");
		}
	}

	/*
	 * Attempt to disable Silicon Debug and lock the configuration
	 * if it's enabled and unlocked.
	 */
	if (!strcmp(cpu_vendor, "GenuineIntel") &&
	    (cpu_ecxfeature & CPUIDECX_SDBG)) {
		uint64_t msr;

		msr = rdmsr(IA32_DEBUG_INTERFACE);
		if ((msr & IA32_DEBUG_INTERFACE_ENABLE) &&
		    (msr & IA32_DEBUG_INTERFACE_LOCK) == 0) {
			msr &= IA32_DEBUG_INTERFACE_MASK;
			msr |= IA32_DEBUG_INTERFACE_LOCK;
			wrmsr(IA32_DEBUG_INTERFACE, msr);
		} else if (msr & IA32_DEBUG_INTERFACE_ENABLE)
			printf("%s: cannot disable silicon debug\n",
			    cpu_device);
	}

	if (ci->ci_flags & CPUF_PRIMARY) {
		if (cpu_ecxfeature & CPUIDECX_RDRAND)
			has_rdrand = 1;
		if (ci->ci_feature_sefflags_ebx & SEFF0EBX_RDSEED)
			has_rdseed = 1;
		if (ci->ci_feature_sefflags_ebx & SEFF0EBX_SMAP)
			replacesmap();
	}

#ifndef SMALL_KERNEL
	if (cpuspeed != 0 && cpu_cpuspeed == NULL)
		cpu_cpuspeed = pentium_cpuspeed;
#endif

	cpu_class = class;

	if (cpu_class == CPUCLASS_386) {
		printf("WARNING: 386 (possibly unknown?) cpu class, assuming 486\n");
		cpu_class = CPUCLASS_486;
	}

	ci->cpu_class = class;

	if (cpu == CPU_486DLC)
		printf("WARNING: CYRIX 486DLC CACHE UNCHANGED.\n");

	/*
	 * Enable ring 0 write protection (486 or above, but 386
	 * no longer supported).
	 */
	lcr0(rcr0() | CR0_WP);

	/*
	 * If we have FXSAVE/FXRESTOR, use them.
	 */
	if (cpu_feature & CPUID_FXSR) {
		i386_use_fxsave = 1;
		lcr4(rcr4() | CR4_OSFXSR);

		/*
		 * If we have SSE/SSE2, enable XMM exceptions, and
		 * notify userland.
		 */
		if (cpu_feature & (CPUID_SSE|CPUID_SSE2)) {
			if (cpu_feature & CPUID_SSE)
				i386_has_sse = 1;
			if (cpu_feature & CPUID_SSE2)
				i386_has_sse2 = 1;
			lcr4(rcr4() | CR4_OSXMMEXCPT);
		}
	} else
		i386_use_fxsave = 0;

#if NVMM > 0
	cpu_check_vmm_cap(ci);
#endif /* NVMM > 0 */

}

char *
tm86_cpu_name(int model)
{
	u_int32_t regs[4];
	char *name = NULL;

	cpuid(0x80860001, regs);

	switch (model) {
	case 4:
		if (((regs[1] >> 16) & 0xff) >= 0x3)
			name = "TMS5800";
		else
			name = "TMS5600";
	}

	return name;
}

#ifndef SMALL_KERNEL
void
cyrix3_get_bus_clock(struct cpu_info *ci)
{
	u_int64_t msr;
	int bus;

	msr = rdmsr(MSR_EBL_CR_POWERON);
	bus = (msr >> 18) & 0x3;
	switch (bus) {
	case 0:
		bus_clock = BUS100;
		break;
	case 1:
		bus_clock = BUS133;
		break;
	case 2:
		bus_clock = BUS200;
		break;
	case 3:
		bus_clock = BUS166;
		break;
	}
}

void
p4_get_bus_clock(struct cpu_info *ci)
{
	u_int64_t msr;
	int model, bus;

	model = (ci->ci_signature >> 4) & 15;
	msr = rdmsr(MSR_EBC_FREQUENCY_ID);
	if (model < 2) {
		bus = (msr >> 21) & 0x7;
		switch (bus) {
		case 0:
			bus_clock = BUS100;
			break;
		case 1:
			bus_clock = BUS133;
			break;
		default:
			printf("%s: unknown Pentium 4 (model %d) "
			    "EBC_FREQUENCY_ID value %d\n",
			    ci->ci_dev.dv_xname, model, bus);
			break;
		}
	} else {
		bus = (msr >> 16) & 0x7;
		switch (bus) {
		case 0:
			bus_clock = (model == 2) ? BUS100 : BUS266;
			break;
		case 1:
			bus_clock = BUS133;
			break;
		case 2:
			bus_clock = BUS200;
			break;
		case 3:
			bus_clock = BUS166;
			break;
		default:
			printf("%s: unknown Pentium 4 (model %d) "
			    "EBC_FREQUENCY_ID value %d\n",
			    ci->ci_dev.dv_xname, model, bus);
			break;
		}
	}
}

void
p3_get_bus_clock(struct cpu_info *ci)
{
	u_int64_t msr;
	int bus;

	switch (ci->ci_model) {
	case 0x9: /* Pentium M (130 nm, Banias) */
		bus_clock = BUS100;
		break;
	case 0xd: /* Pentium M (90 nm, Dothan) */
		msr = rdmsr(MSR_FSB_FREQ);
		bus = (msr >> 0) & 0x7;
		switch (bus) {
		case 0:
			bus_clock = BUS100;
			break;
		case 1:
			bus_clock = BUS133;
			break;
		default:
			printf("%s: unknown Pentium M FSB_FREQ value %d",
			    ci->ci_dev.dv_xname, bus);
			goto print_msr;
		}
		break;
	case 0x15:	/* EP80579 no FSB */
		break;
	case 0xe: /* Core Duo/Solo */
	case 0xf: /* Core Xeon */
	case 0x16: /* 65nm Celeron */
	case 0x17: /* Core 2 Extreme/45nm Xeon */
	case 0x1d: /* Xeon MP 7400 */
		msr = rdmsr(MSR_FSB_FREQ);
		bus = (msr >> 0) & 0x7;
		switch (bus) {
		case 5:
			bus_clock = BUS100;
			break;
		case 1:
			bus_clock = BUS133;
			break;
		case 3:
			bus_clock = BUS166;
			break;
		case 2:
			bus_clock = BUS200;
			break;
		case 0:
			bus_clock = BUS266;
			break;
		case 4:
			bus_clock = BUS333;
			break;
		default:
			printf("%s: unknown Core FSB_FREQ value %d",
			    ci->ci_dev.dv_xname, bus);
			goto print_msr;
		}
		break;
	case 0x1c: /* Atom */
	case 0x26: /* Atom Z6xx */
	case 0x36: /* Atom [DN]2xxx */
		msr = rdmsr(MSR_FSB_FREQ);
		bus = (msr >> 0) & 0x7;
		switch (bus) {
		case 5:
			bus_clock = BUS100;
			break;
		case 1:
			bus_clock = BUS133;
			break;
		case 3:
			bus_clock = BUS166;
			break;
		case 2:
			bus_clock = BUS200;
			break;
		default:
			printf("%s: unknown Atom FSB_FREQ value %d",
			    ci->ci_dev.dv_xname, bus);
			goto print_msr;
		}
		break;
	case 0x1: /* Pentium Pro, model 1 */
	case 0x3: /* Pentium II, model 3 */
	case 0x5: /* Pentium II, II Xeon, Celeron, model 5 */
	case 0x6: /* Celeron, model 6 */
	case 0x7: /* Pentium III, III Xeon, model 7 */
	case 0x8: /* Pentium III, III Xeon, Celeron, model 8 */
	case 0xa: /* Pentium III Xeon, model A */
	case 0xb: /* Pentium III, model B */
		msr = rdmsr(MSR_EBL_CR_POWERON);
		bus = (msr >> 18) & 0x3;
		switch (bus) {
		case 0:
			bus_clock = BUS66;
			break;
		case 1:
			bus_clock = BUS133;
			break;
		case 2:
			bus_clock = BUS100;
			break;
		default:
			printf("%s: unknown i686 EBL_CR_POWERON value %d",
			    ci->ci_dev.dv_xname, bus);
			goto print_msr;
		}
		break;
	default: 
		/* no FSB on modern Intel processors */
		break;
	}
	return;
print_msr:
	/*
	 * Show the EBL_CR_POWERON MSR, so we'll at least have
	 * some extra information, such as clock ratio, etc.
	 */
	printf(" (0x%llx)\n", rdmsr(MSR_EBL_CR_POWERON));
}

void
p4_update_cpuspeed(void)
{
	struct cpu_info *ci;
	u_int64_t msr;
	int mult;

	ci = curcpu();
	p4_get_bus_clock(ci);

	if (bus_clock == 0) {
		printf("p4_update_cpuspeed: unknown bus clock\n");
		return;
	}

	msr = rdmsr(MSR_EBC_FREQUENCY_ID);
	mult = ((msr >> 24) & 0xff);

	cpuspeed = (bus_clock * mult) / 100;
}

void
p3_update_cpuspeed(void)
{
	struct cpu_info *ci;
	u_int64_t msr;
	int mult;
	const u_int8_t mult_code[] = {
	    50, 30, 40, 0, 55, 35, 45, 0, 0, 70, 80, 60, 0, 75, 0, 65 };

	ci = curcpu();
	p3_get_bus_clock(ci);

	if (bus_clock == 0) {
		printf("p3_update_cpuspeed: unknown bus clock\n");
		return;
	}

	msr = rdmsr(MSR_EBL_CR_POWERON);
	mult = (msr >> 22) & 0xf;
	mult = mult_code[mult];
	if (!p3_early)
		mult += ((msr >> 27) & 0x1) * 40;

	cpuspeed = (bus_clock * mult) / 1000;
}

int
pentium_cpuspeed(int *freq)
{
	*freq = cpuspeed;
	return (0);
}
#endif	/* !SMALL_KERNEL */

/*
 * Send an interrupt to process.
 *
 * Stack is set up to allow sigcode stored
 * in u. to call routine, followed by kcall
 * to sigreturn routine below.  After sigreturn
 * resets the signal mask, the stack, and the
 * frame pointer, it returns to the user
 * specified pc, psl.
 */
void
sendsig(sig_t catcher, int sig, int mask, u_long code, int type,
    union sigval val)
{
	struct proc *p = curproc;
	struct trapframe *tf = p->p_md.md_regs;
	struct sigframe *fp, frame;
	struct sigacts *psp = p->p_p->ps_sigacts;
	register_t sp;

	/*
	 * Build the argument list for the signal handler.
	 */
	bzero(&frame, sizeof(frame));
	frame.sf_signum = sig;

	/*
	 * Allocate space for the signal handler context.
	 */
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 &&
	    !sigonstack(tf->tf_esp) && (psp->ps_sigonstack & sigmask(sig)))
		sp = (long)p->p_sigstk.ss_sp + p->p_sigstk.ss_size;
	else
		sp = tf->tf_esp;

	frame.sf_sc.sc_fpstate = NULL;
	if (p->p_md.md_flags & MDP_USEDFPU) {
		npxsave_proc(p, 1);
		sp -= sizeof(union savefpu);
		sp &= ~0xf;	/* for XMM regs */
		frame.sf_sc.sc_fpstate = (void *)sp;
		if (copyout(&p->p_addr->u_pcb.pcb_savefpu,
		    (void *)sp, sizeof(union savefpu)))
			sigexit(p, SIGILL);

		/* Signal handlers get a completely clean FP state */
		p->p_md.md_flags &= ~MDP_USEDFPU;
	}

	fp = (struct sigframe *)sp - 1;
	frame.sf_scp = &fp->sf_sc;
	frame.sf_sip = NULL;
	frame.sf_handler = catcher;

	/*
	 * Build the signal context to be used by sigreturn.
	 */
	frame.sf_sc.sc_err = tf->tf_err;
	frame.sf_sc.sc_trapno = tf->tf_trapno;
	frame.sf_sc.sc_mask = mask;
#ifdef VM86
	if (tf->tf_eflags & PSL_VM) {
		frame.sf_sc.sc_gs = tf->tf_vm86_gs;
		frame.sf_sc.sc_fs = tf->tf_vm86_fs;
		frame.sf_sc.sc_es = tf->tf_vm86_es;
		frame.sf_sc.sc_ds = tf->tf_vm86_ds;
		frame.sf_sc.sc_eflags = get_vflags(p);
	} else
#endif
	{
		frame.sf_sc.sc_fs = tf->tf_fs;
		frame.sf_sc.sc_gs = tf->tf_gs;
		frame.sf_sc.sc_es = tf->tf_es;
		frame.sf_sc.sc_ds = tf->tf_ds;
		frame.sf_sc.sc_eflags = tf->tf_eflags;
	}
	frame.sf_sc.sc_edi = tf->tf_edi;
	frame.sf_sc.sc_esi = tf->tf_esi;
	frame.sf_sc.sc_ebp = tf->tf_ebp;
	frame.sf_sc.sc_ebx = tf->tf_ebx;
	frame.sf_sc.sc_edx = tf->tf_edx;
	frame.sf_sc.sc_ecx = tf->tf_ecx;
	frame.sf_sc.sc_eax = tf->tf_eax;
	frame.sf_sc.sc_eip = tf->tf_eip;
	frame.sf_sc.sc_cs = tf->tf_cs;
	frame.sf_sc.sc_esp = tf->tf_esp;
	frame.sf_sc.sc_ss = tf->tf_ss;

	if (psp->ps_siginfo & sigmask(sig)) {
		frame.sf_sip = &fp->sf_si;
		initsiginfo(&frame.sf_si, sig, code, type, val);
#ifdef VM86
		if (sig == SIGURG)	/* VM86 userland trap */
			frame.sf_si.si_trapno = code;
#endif
	}

	/* XXX don't copyout siginfo if not needed? */
	frame.sf_sc.sc_cookie = (long)&fp->sf_sc ^ p->p_p->ps_sigcookie;
	if (copyout(&frame, fp, sizeof(frame)) != 0) {
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}

	/*
	 * Build context to run handler in.
	 */
	tf->tf_fs = GSEL(GUFS_SEL, SEL_UPL);
	tf->tf_gs = GSEL(GUGS_SEL, SEL_UPL);
	tf->tf_es = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_ds = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_eip = p->p_p->ps_sigcode;
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
	tf->tf_eflags &= ~(PSL_T|PSL_D|PSL_VM|PSL_AC);
	tf->tf_esp = (int)fp;
	tf->tf_ss = GSEL(GUDATA_SEL, SEL_UPL);
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper privileges or to cause
 * a machine fault.
 */
int
sys_sigreturn(struct proc *p, void *v, register_t *retval)
{
	struct sys_sigreturn_args /* {
		syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext ksc, *scp = SCARG(uap, sigcntxp);
	struct trapframe *tf = p->p_md.md_regs;
	int error;

	if (PROC_PC(p) != p->p_p->ps_sigcoderet) {
		sigexit(p, SIGILL);
		return (EPERM);
	}

	if ((error = copyin((caddr_t)scp, &ksc, sizeof(*scp))))
		return (error);

	if (ksc.sc_cookie != ((long)scp ^ p->p_p->ps_sigcookie)) {
		sigexit(p, SIGILL);
		return (EFAULT);
	}

	/* Prevent reuse of the sigcontext cookie */
	ksc.sc_cookie = 0;
	(void)copyout(&ksc.sc_cookie, (caddr_t)scp +
	    offsetof(struct sigcontext, sc_cookie), sizeof (ksc.sc_cookie));

	/*
	 * Restore signal ksc.
	 */
#ifdef VM86
	if (ksc.sc_eflags & PSL_VM) {
		tf->tf_vm86_gs = ksc.sc_gs;
		tf->tf_vm86_fs = ksc.sc_fs;
		tf->tf_vm86_es = ksc.sc_es;
		tf->tf_vm86_ds = ksc.sc_ds;
		set_vflags(p, ksc.sc_eflags);
	} else
#endif
	{
		/*
		 * Check for security violations.  If we're returning to
		 * protected mode, the CPU will validate the segment registers
		 * automatically and generate a trap on violations.  We handle
		 * the trap, rather than doing all of the checking here.
		 */
		if (((ksc.sc_eflags ^ tf->tf_eflags) & PSL_USERSTATIC) != 0 ||
		    !USERMODE(ksc.sc_cs, ksc.sc_eflags))
			return (EINVAL);

		tf->tf_fs = ksc.sc_fs;
		tf->tf_gs = ksc.sc_gs;
		tf->tf_es = ksc.sc_es;
		tf->tf_ds = ksc.sc_ds;
		tf->tf_eflags = ksc.sc_eflags;
	}
	tf->tf_edi = ksc.sc_edi;
	tf->tf_esi = ksc.sc_esi;
	tf->tf_ebp = ksc.sc_ebp;
	tf->tf_ebx = ksc.sc_ebx;
	tf->tf_edx = ksc.sc_edx;
	tf->tf_ecx = ksc.sc_ecx;
	tf->tf_eax = ksc.sc_eax;
	tf->tf_eip = ksc.sc_eip;
	tf->tf_cs = ksc.sc_cs;
	tf->tf_esp = ksc.sc_esp;
	tf->tf_ss = ksc.sc_ss;

	if (p->p_md.md_flags & MDP_USEDFPU)
		npxsave_proc(p, 0);

	if (ksc.sc_fpstate) {
		union savefpu *sfp = &p->p_addr->u_pcb.pcb_savefpu;

		if ((error = copyin(ksc.sc_fpstate, sfp, sizeof(*sfp))))
			return (error);
		if (i386_use_fxsave)
			sfp->sv_xmm.sv_env.en_mxcsr &= fpu_mxcsr_mask;
		p->p_md.md_flags |= MDP_USEDFPU;
	}

	p->p_sigmask = ksc.sc_mask & ~sigcantmask;

	return (EJUSTRETURN);
}

#ifdef MULTIPROCESSOR
/* force a CPU into the kernel, whether or not it's idle */
void
cpu_kick(struct cpu_info *ci)
{
	/* only need to kick other CPUs */
	if (ci != curcpu()) {
		if (cpu_mwait_size > 0) {
			/*
			 * If not idling, then send an IPI, else
			 * just clear the "keep idling" bit.
			 */
			if ((ci->ci_mwait & MWAIT_IN_IDLE) == 0)
				i386_send_ipi(ci, I386_IPI_NOP);
			else
				atomic_clearbits_int(&ci->ci_mwait,
				    MWAIT_KEEP_IDLING);
		} else {
			/* no mwait, so need an IPI */
			i386_send_ipi(ci, I386_IPI_NOP);
		}
	}
}
#endif

/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */
void
signotify(struct proc *p)
{
	aston(p);
	cpu_kick(p->p_cpu);
}

#ifdef MULTIPROCESSOR
void
cpu_unidle(struct cpu_info *ci)
{
	if (cpu_mwait_size > 0 && (ci->ci_mwait & MWAIT_ONLY)) {
		/*
		 * Just clear the "keep idling" bit; if it wasn't
		 * idling then we didn't need to do anything anyway.
		 */
		atomic_clearbits_int(&ci->ci_mwait, MWAIT_KEEP_IDLING);
		return;
	}

	if (ci != curcpu())
		i386_send_ipi(ci, I386_IPI_NOP);
}
#endif

int	waittime = -1;
struct pcb dumppcb;

__dead void
boot(int howto)
{
	if ((howto & RB_POWERDOWN) != 0)
		lid_action = 0;

	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0 && waittime < 0) {
		waittime = 0;
		vfs_shutdown();

		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & RB_DUMP) != 0)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

#ifdef MULTIPROCESSOR
	i386_broadcast_ipi(I386_IPI_HALT);
#endif

	if ((howto & RB_HALT) != 0) {
#if NACPI > 0 && !defined(SMALL_KERNEL)
		extern int acpi_enabled;

		if (acpi_enabled) {
			delay(500000);
			if ((howto & RB_POWERDOWN) != 0)
				acpi_powerdown();
		}
#endif

#if NAPM > 0
		if ((howto & RB_POWERDOWN) != 0) {
			int rv;

			printf("\nAttempting to power down...\n");
			/*
			 * Turn off, if we can.  But try to turn disk off and
			 * wait a bit first--some disk drives are slow to
			 * clean up and users have reported disk corruption.
			 *
			 * If apm_set_powstate() fails the first time, don't
			 * try to turn the system off.
			 */
			delay(500000);
			/*
			 * It's been reported that the following bit of code
			 * is required on most systems <mickey@@openbsd.org>
			 * but cause powerdown problem on other systems
			 * <smcho@@tsp.korea.ac.kr>.  Use sysctl to set
			 * apmhalt to a non-zero value to skip the offending
			 * code.
			 */
			if (!cpu_apmhalt) {
				apm_set_powstate(APM_DEV_DISK(0xff),
						 APM_SYS_OFF);
				delay(500000);
			}
			rv = apm_set_powstate(APM_DEV_DISK(0xff), APM_SYS_OFF);
			if (rv == 0 || rv == ENXIO) {
				delay(500000);
				(void) apm_set_powstate(APM_DEV_ALLDEVS,
							APM_SYS_OFF);
			}
		}
#endif
		printf("\n");
		printf("The operating system has halted.\n");
		printf("Please press any key to reboot.\n\n");
		cnpollc(1);	/* for proper keyboard command handling */
		cngetc();
		cnpollc(0);
	}

	printf("rebooting...\n");
	cpu_reset();
	for (;;)
		continue;
	/* NOTREACHED */
}

/*
 * This is called by configure to set dumplo and dumpsize.
 * Dumps always skip the first block of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
void
dumpconf(void)
{
	int nblks;	/* size of dump area */
	int i;

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	/* Always skip the first block, in case there is a label there. */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

	for (i = 0; i < ndumpmem; i++)
		dumpsize = max(dumpsize, dumpmem[i].end);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize > dtoc(nblks - dumplo - 1))
		dumpsize = dtoc(nblks - dumplo - 1);
	if (dumplo < nblks - ctod(dumpsize) - 1)
		dumplo = nblks - ctod(dumpsize) - 1;
}

/*
 * cpu_dump: dump machine-dependent kernel core dump headers.
 */
int
cpu_dump(void)
{
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	long buf[dbtob(1) / sizeof (long)];
	kcore_seg_t	*segp;

	dump = bdevsw[major(dumpdev)].d_dump;

	segp = (kcore_seg_t *)buf;

	/*
	 * Generate a segment header.
	 */
	CORE_SETMAGIC(*segp, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	segp->c_size = dbtob(1) - ALIGN(sizeof(*segp));

	return (dump(dumpdev, dumplo, (caddr_t)buf, dbtob(1)));
}

/*
 * Doadump comes here after turning off memory management and
 * getting on the dump stack, either when called above, or by
 * the auto-restart code.
 */
static vaddr_t dumpspace;

vaddr_t
reserve_dumppages(vaddr_t p)
{

	dumpspace = p;
	return (p + PAGE_SIZE);
}

void
dumpsys(void)
{
	u_int i, j, npg;
	int maddr;
	daddr_t blkno;
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	int error;
	char *str;
	extern int msgbufmapped;

	/* Save registers. */
	savectx(&dumppcb);

	msgbufmapped = 0;	/* don't record dump msgs in msgbuf */
	if (dumpdev == NODEV)
		return;

	/*
	 * For dumps during autoconfiguration,
	 * if dump device has already configured...
	 */
	if (dumpsize == 0)
		dumpconf();
	if (dumplo < 0)
		return;
	printf("\ndumping to dev %x, offset %ld\n", dumpdev, dumplo);

	error = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
	printf("dump ");
	if (error == -1) {
		printf("area unavailable\n");
		return;
	}

#if 0	/* XXX this doesn't work.  grr. */
	/* toss any characters present prior to dump */
	while (sget() != NULL); /*syscons and pccons differ */
#endif

	/* scan through the dumpmem list */
	dump = bdevsw[major(dumpdev)].d_dump;
	error = cpu_dump();
	for (i = 0; !error && i < ndumpmem; i++) {

		npg = dumpmem[i].end - dumpmem[i].start;
		maddr = ptoa(dumpmem[i].start);
		blkno = dumplo + btodb(maddr) + 1;
#if 0
		printf("(%d %lld %d) ", maddr, (long long)blkno, npg);
#endif
		for (j = npg; j--; maddr += NBPG, blkno += btodb(NBPG)) {

			/* Print out how many MBs we have more to go. */
			if (dbtob(blkno - dumplo) % (1024 * 1024) < NBPG)
				printf("%ld ",
				    (ptoa(dumpsize) - maddr) / (1024 * 1024));
#if 0
			printf("(%x %lld) ", maddr, (long long)blkno);
#endif
			pmap_enter(pmap_kernel(), dumpspace, maddr,
			    PROT_READ, PMAP_WIRED);
			if ((error = (*dump)(dumpdev, blkno,
			    (caddr_t)dumpspace, NBPG)))
				break;

#if 0	/* XXX this doesn't work.  grr. */
			/* operator aborting dump? */
			if (sget() != NULL) {
				error = EINTR;
				break;
			}
#endif
		}
	}

	switch (error) {

	case 0:		str = "succeeded\n\n";			break;
	case ENXIO:	str = "device bad\n\n";			break;
	case EFAULT:	str = "device not ready\n\n";		break;
	case EINVAL:	str = "area improper\n\n";		break;
	case EIO:	str = "i/o error\n\n";			break;
	case EINTR:	str = "aborted from console\n\n";	break;
	default:	str = "error %d\n\n";			break;
	}
	printf(str, error);

	delay(5000000);		/* 5 seconds */
}

/*
 * Clear registers on exec
 */
void
setregs(struct proc *p, struct exec_package *pack, u_long stack,
    register_t *retval)
{
	struct pcb *pcb = &p->p_addr->u_pcb;
	struct pmap *pmap = vm_map_pmap(&p->p_vmspace->vm_map);
	struct trapframe *tf = p->p_md.md_regs;

#if NNPX > 0
	/* If we were using the FPU, forget about it. */
	if (pcb->pcb_fpcpu != NULL)
		npxsave_proc(p, 0);
	p->p_md.md_flags &= ~MDP_USEDFPU;
#endif

	/*
	 * Reset the code segment limit to I386_MAX_EXE_ADDR in the pmap;
	 * this gets copied into the GDT for GUCODE_SEL by pmap_activate().
	 * Similarly, reset the base of each of the two thread data
	 * segments to zero in the pcb; they'll get copied into the
	 * GDT for GUFS_SEL and GUGS_SEL.
	 */
	setsegment(&pmap->pm_codeseg, 0, atop(I386_MAX_EXE_ADDR) - 1,
	    SDT_MEMERA, SEL_UPL, 1, 1);
	setsegment(&pcb->pcb_threadsegs[TSEG_FS], 0,
	    atop(VM_MAXUSER_ADDRESS) - 1, SDT_MEMRWA, SEL_UPL, 1, 1);
	setsegment(&pcb->pcb_threadsegs[TSEG_GS], 0,
	    atop(VM_MAXUSER_ADDRESS) - 1, SDT_MEMRWA, SEL_UPL, 1, 1);

	/*
	 * And update the GDT since we return to the user process
	 * by leaving the syscall (we don't do another pmap_activate()).
	 */
	curcpu()->ci_gdt[GUCODE_SEL].sd = pmap->pm_codeseg;
	curcpu()->ci_gdt[GUFS_SEL].sd = pcb->pcb_threadsegs[TSEG_FS];
	curcpu()->ci_gdt[GUGS_SEL].sd = pcb->pcb_threadsegs[TSEG_GS];

	/*
	 * And reset the hiexec marker in the pmap.
	 */
	pmap->pm_hiexec = 0;

	tf->tf_fs = GSEL(GUFS_SEL, SEL_UPL);
	tf->tf_gs = GSEL(GUGS_SEL, SEL_UPL);
	tf->tf_es = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_ds = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_edi = 0;
	tf->tf_esi = 0;
	tf->tf_ebp = 0;
	tf->tf_ebx = (int)p->p_p->ps_strings;
	tf->tf_edx = 0;
	tf->tf_ecx = 0;
	tf->tf_eax = 0;
	tf->tf_eip = pack->ep_entry;
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
	tf->tf_eflags = PSL_USERSET;
	tf->tf_esp = stack;
	tf->tf_ss = GSEL(GUDATA_SEL, SEL_UPL);

	retval[1] = 0;
}

/*
 * Initialize segments and descriptor tables
 */

struct gate_descriptor idt_region[NIDT];
struct gate_descriptor *idt = idt_region;

extern  struct user *proc0paddr;

void
setgate(struct gate_descriptor *gd, void *func, int args, int type, int dpl,
    int seg)
{

	gd->gd_looffset = (int)func;
	gd->gd_selector = GSEL(seg, SEL_KPL);
	gd->gd_stkcpy = args;
	gd->gd_xx = 0;
	gd->gd_type = type;
	gd->gd_dpl = dpl;
	gd->gd_p = 1;
	gd->gd_hioffset = (int)func >> 16;
}

void
unsetgate(struct gate_descriptor *gd)
{
	gd->gd_p = 0;
	gd->gd_hioffset = 0;
	gd->gd_looffset = 0;
	gd->gd_selector = 0;
	gd->gd_xx = 0;
	gd->gd_stkcpy = 0;
	gd->gd_type = 0;
	gd->gd_dpl = 0;
}

void
setregion(struct region_descriptor *rd, void *base, size_t limit)
{

	rd->rd_limit = (int)limit;
	rd->rd_base = (int)base;
}

void
setsegment(struct segment_descriptor *sd, void *base, size_t limit, int type,
    int dpl, int def32, int gran)
{

	sd->sd_lolimit = (int)limit;
	sd->sd_lobase = (int)base;
	sd->sd_type = type;
	sd->sd_dpl = dpl;
	sd->sd_p = 1;
	sd->sd_hilimit = (int)limit >> 16;
	sd->sd_xx = 0;
	sd->sd_def32 = def32;
	sd->sd_gran = gran;
	sd->sd_hibase = (int)base >> 24;
}

#define	IDTVEC(name)	__CONCAT(X, name)
extern int IDTVEC(div), IDTVEC(dbg), IDTVEC(nmi), IDTVEC(bpt), IDTVEC(ofl),
    IDTVEC(bnd), IDTVEC(ill), IDTVEC(dna), IDTVEC(dble), IDTVEC(fpusegm),
    IDTVEC(tss), IDTVEC(missing), IDTVEC(stk), IDTVEC(prot), IDTVEC(page),
    IDTVEC(rsvd), IDTVEC(fpu), IDTVEC(align), IDTVEC(syscall), IDTVEC(mchk),
    IDTVEC(simd);

extern int IDTVEC(f00f_redirect);

int cpu_f00f_bug = 0;

void
fix_f00f(void)
{
	struct region_descriptor region;
	vaddr_t va;
	void *p;

	/* Allocate two new pages */
	va = uvm_km_zalloc(kernel_map, NBPG*2);
	p = (void *)(va + NBPG - 7*sizeof(*idt));

	/* Copy over old IDT */
	bcopy(idt, p, sizeof(idt_region));
	idt = p;

	/* Fix up paging redirect */
	setgate(&idt[ 14], &IDTVEC(f00f_redirect), 0, SDT_SYS386TGT, SEL_KPL,
	    GCODE_SEL);

	/* Map first page RO */
	pmap_pte_setbits(va, 0, PG_RW);

	/* Reload idtr */
	setregion(&region, idt, sizeof(idt_region) - 1);
	lidt(&region);

	/* Tell the rest of the world */
	cpu_f00f_bug = 1;
}

#ifdef MULTIPROCESSOR
void
cpu_init_idt(void)
{
	struct region_descriptor region;
	setregion(&region, idt, NIDT * sizeof(idt[0]) - 1);
	lidt(&region);
}
#endif /* MULTIPROCESSOR */

void
init386(paddr_t first_avail)
{
	int i, kb;
	struct region_descriptor region;
	bios_memmap_t *im;

	proc0.p_addr = proc0paddr;
	cpu_info_primary.ci_self = &cpu_info_primary;
	cpu_info_primary.ci_curpcb = &proc0.p_addr->u_pcb;

	/* make bootstrap gdt gates and memory segments */
	setsegment(&gdt[GCODE_SEL].sd, 0, 0xfffff, SDT_MEMERA, SEL_KPL, 1, 1);
	setsegment(&gdt[GICODE_SEL].sd, 0, 0xfffff, SDT_MEMERA, SEL_KPL, 1, 1);
	setsegment(&gdt[GDATA_SEL].sd, 0, 0xfffff, SDT_MEMRWA, SEL_KPL, 1, 1);
	setsegment(&gdt[GUCODE_SEL].sd, 0, atop(I386_MAX_EXE_ADDR) - 1,
	    SDT_MEMERA, SEL_UPL, 1, 1);
	setsegment(&gdt[GUDATA_SEL].sd, 0, atop(VM_MAXUSER_ADDRESS) - 1,
	    SDT_MEMRWA, SEL_UPL, 1, 1);
	setsegment(&gdt[GCPU_SEL].sd, &cpu_info_primary,
	    sizeof(struct cpu_info)-1, SDT_MEMRWA, SEL_KPL, 0, 0);
	setsegment(&gdt[GUFS_SEL].sd, 0, atop(VM_MAXUSER_ADDRESS) - 1,
	    SDT_MEMRWA, SEL_UPL, 1, 1);
	setsegment(&gdt[GUGS_SEL].sd, 0, atop(VM_MAXUSER_ADDRESS) - 1,
	    SDT_MEMRWA, SEL_UPL, 1, 1);

	/* exceptions */
	setgate(&idt[  0], &IDTVEC(div),     0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	setgate(&idt[  1], &IDTVEC(dbg),     0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	setgate(&idt[  2], &IDTVEC(nmi),     0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	setgate(&idt[  3], &IDTVEC(bpt),     0, SDT_SYS386TGT, SEL_UPL, GCODE_SEL);
	setgate(&idt[  4], &IDTVEC(ofl),     0, SDT_SYS386TGT, SEL_UPL, GCODE_SEL);
	setgate(&idt[  5], &IDTVEC(bnd),     0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	setgate(&idt[  6], &IDTVEC(ill),     0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	setgate(&idt[  7], &IDTVEC(dna),     0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	setgate(&idt[  8], &IDTVEC(dble),    0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	setgate(&idt[  9], &IDTVEC(fpusegm), 0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	setgate(&idt[ 10], &IDTVEC(tss),     0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	setgate(&idt[ 11], &IDTVEC(missing), 0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	setgate(&idt[ 12], &IDTVEC(stk),     0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	setgate(&idt[ 13], &IDTVEC(prot),    0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	setgate(&idt[ 14], &IDTVEC(page),    0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	setgate(&idt[ 15], &IDTVEC(rsvd),    0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	setgate(&idt[ 16], &IDTVEC(fpu),     0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	setgate(&idt[ 17], &IDTVEC(align),   0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	setgate(&idt[ 18], &IDTVEC(mchk),    0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	setgate(&idt[ 19], &IDTVEC(simd),    0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	for (i = 20; i < NRSVIDT; i++)
		setgate(&idt[i], &IDTVEC(rsvd), 0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	for (i = NRSVIDT; i < NIDT; i++)
		unsetgate(&idt[i]);
	setgate(&idt[128], &IDTVEC(syscall), 0, SDT_SYS386TGT, SEL_UPL, GCODE_SEL);

	setregion(&region, gdt, NGDT * sizeof(union descriptor) - 1);
	lgdt(&region);
	setregion(&region, idt, sizeof(idt_region) - 1);
	lidt(&region);

	/*
	 * Initialize the I/O port and I/O mem extent maps.
	 * Note: we don't have to check the return value since
	 * creation of a fixed extent map will never fail (since
	 * descriptor storage has already been allocated).
	 *
	 * N.B. The iomem extent manages _all_ physical addresses
	 * on the machine.  When the amount of RAM is found, the two
	 * extents of RAM are allocated from the map (0 -> ISA hole
	 * and end of ISA hole -> end of RAM).
	 */
	ioport_ex = extent_create("ioport", 0x0, 0xffff, M_DEVBUF,
	    (caddr_t)ioport_ex_storage, sizeof(ioport_ex_storage),
	    EX_NOCOALESCE|EX_NOWAIT);
	iomem_ex = extent_create("iomem", 0x0, 0xffffffff, M_DEVBUF,
	    (caddr_t)iomem_ex_storage, sizeof(iomem_ex_storage),
	    EX_NOCOALESCE|EX_NOWAIT);

#if NISA > 0
	isa_defaultirq();
#endif

	/*
	 * Attach the glass console early in case we need to display a panic.
	 */
	cninit();

	/*
	 * Saving SSE registers won't work if the save area isn't
	 * 16-byte aligned.
	 */
	if (offsetof(struct user, u_pcb.pcb_savefpu) & 0xf)
		panic("init386: pcb_savefpu not 16-byte aligned");

	/* call pmap initialization to make new kernel address space */
	pmap_bootstrap((vaddr_t)atdevbase + IOM_SIZE);

	/*
	 * Boot arguments are in a single page specified by /boot.
	 *
	 * We require the "new" vector form, as well as memory ranges
	 * to be given in bytes rather than KB.
	 */
	if ((bootapiver & (BAPIV_VECTOR | BAPIV_BMEMMAP)) ==
	    (BAPIV_VECTOR | BAPIV_BMEMMAP)) {
		if (bootargc > NBPG)
			panic("too many boot args");

		if (extent_alloc_region(iomem_ex, (paddr_t)bootargv, bootargc,
		    EX_NOWAIT))
			panic("cannot reserve /boot args memory");

		pmap_enter(pmap_kernel(), (vaddr_t)bootargp, (paddr_t)bootargv,
		    PROT_READ | PROT_WRITE,
		    PROT_READ | PROT_WRITE | PMAP_WIRED);

		bios_getopt();

	} else
		panic("/boot too old: upgrade!");

#ifdef DIAGNOSTIC
	if (bios_memmap == NULL)
		panic("no BIOS memory map supplied");
#endif
 
	/*
	 * account all the memory passed in the map from /boot
	 * calculate avail_end and count the physmem.
	 */
	avail_end = 0;
	physmem = 0;
#ifdef DEBUG
	printf("memmap:");
#endif
	for(i = 0, im = bios_memmap; im->type != BIOS_MAP_END; im++)
		if (im->type == BIOS_MAP_FREE) {
			paddr_t a, e;
#ifdef DEBUG
			printf(" %llx-%llx", im->addr, im->addr + im->size);
#endif

			if (im->addr >= 0x100000000ULL) {
#ifdef DEBUG
				printf("-H");
#endif
				continue;
			}

			a = round_page(im->addr);
			if (im->addr + im->size <= 0xfffff000ULL)
				e = trunc_page(im->addr + im->size);
			else {
#ifdef DEBUG
				printf("-T");
#endif
				e = 0xfffff000;
			}

			/* skip first 16 pages due to SMI corruption */
			if (a < 16 * NBPG)
				a = 16 * NBPG;

#ifdef MULTIPROCESSOR
			/* skip MP trampoline code page */
			if (a < MP_TRAMPOLINE + NBPG)
				a = MP_TRAMPOLINE + NBPG;

			/* skip MP trampoline data page */
			if (a < MP_TRAMP_DATA + NBPG)
				a = MP_TRAMP_DATA + NBPG;
#endif /* MULTIPROCESSOR */

#if NACPI > 0 && !defined(SMALL_KERNEL)
			/* skip ACPI resume trampoline code page */
			if (a < ACPI_TRAMPOLINE + NBPG)
				a = ACPI_TRAMPOLINE + NBPG;

			/* skip ACPI resume trampoline data page */
			if (a < ACPI_TRAMP_DATA + NBPG)
				a = ACPI_TRAMP_DATA + NBPG;
#endif /* ACPI */

#ifdef HIBERNATE
			/* skip hibernate reserved pages */
			if (a < HIBERNATE_HIBALLOC_PAGE + PAGE_SIZE)
				a = HIBERNATE_HIBALLOC_PAGE + PAGE_SIZE;
#endif /* HIBERNATE */

			/* skip shorter than page regions */
			if (a >= e || (e - a) < NBPG) {
#ifdef DEBUG
				printf("-S");
#endif
				continue;
			}

			/*
			 * XXX Some buggy ACPI BIOSes use memory that
			 * they declare as free.  Typically the
			 * affected memory areas are small blocks
			 * between areas reserved for ACPI and other
			 * BIOS goo.  So skip areas smaller than 1 MB
			 * above the 16 MB boundary (to avoid
			 * affecting legacy stuff).
			 */
			if (a > 16*1024*1024 && (e - a) < 1*1024*1024) {
#ifdef DEBUG
				printf("-X");
#endif
				continue;
			}

			/* skip legacy IO region */
			if ((a > IOM_BEGIN && a < IOM_END) ||
			    (e > IOM_BEGIN && e < IOM_END)) {
#ifdef DEBUG
				printf("-I");
#endif
				continue;
			}

			if (extent_alloc_region(iomem_ex, a, e - a, EX_NOWAIT))
				/* XXX What should we do? */
				printf("\nWARNING: CAN'T ALLOCATE RAM (%lx-%lx)"
				    " FROM IOMEM EXTENT MAP!\n", a, e);

			physmem += atop(e - a);
			dumpmem[i].start = atop(a);
			dumpmem[i].end = atop(e);
			i++;
			avail_end = max(avail_end, e);
		}

	ndumpmem = i;
	avail_end -= round_page(MSGBUFSIZE);

#ifdef DEBUG
	printf(": %lx\n", avail_end);
#endif
	if (physmem < atop(4 * 1024 * 1024)) {
		printf("\awarning: too little memory available;"
		    "running in degraded mode\npress a key to confirm\n\n");
		cnpollc(1);
		cngetc();
		cnpollc(0);
	}

#ifdef DEBUG
	printf("physload: ");
#endif
	kb = atop(KERNTEXTOFF - KERNBASE);
	if (kb > atop(IOM_END)) {
		paddr_t lim = atop(IOM_END);
#ifdef DEBUG
		printf(" %lx-%x (<16M)", lim, kb);
#endif
		uvm_page_physload(lim, kb, lim, kb, 0);
	}

	for (i = 0; i < ndumpmem; i++) {
		paddr_t a, e;

		a = dumpmem[i].start;
		e = dumpmem[i].end;
		if (a < atop(first_avail) && e > atop(first_avail))
			a = atop(first_avail);
		if (e > atop(avail_end))
			e = atop(avail_end);

		if (a < e) {
#ifdef DEBUG
				printf(" %lx-%lx", a, e);
#endif
				uvm_page_physload(a, e, a, e, 0);
		}
	}
#ifdef DEBUG
	printf("\n");
#endif

	tlbflush();
#if 0
#if NISADMA > 0
	/*
	 * Some motherboards/BIOSes remap the 384K of RAM that would
	 * normally be covered by the ISA hole to the end of memory
	 * so that it can be used.  However, on a 16M system, this
	 * would cause bounce buffers to be allocated and used.
	 * This is not desirable behaviour, as more than 384K of
	 * bounce buffers might be allocated.  As a work-around,
	 * we round memory down to the nearest 1M boundary if
	 * we're using any isadma devices and the remapped memory
	 * is what puts us over 16M.
	 */
	if (extmem > (15*1024) && extmem < (16*1024)) {
		printf("Warning: ignoring %dk of remapped memory\n",
		    extmem - (15*1024));
		extmem = (15*1024);
	}
#endif
#endif

#ifdef DDB
	db_machine_init();
	ddb_init();
	if (boothowto & RB_KDB)
		db_enter();
#endif

	softintr_init();
}

/*
 * consinit:
 * initialize the system console.
 */
void
consinit(void)
{
	/* Already done in init386(). */
}

void
cpu_reset(void)
{
	struct region_descriptor region;

	disable_intr();

	if (cpuresetfn)
		(*cpuresetfn)();

	/*
	 * The keyboard controller has 4 random output pins, one of which is
	 * connected to the RESET pin on the CPU in many PCs.  We tell the
	 * keyboard controller to pulse this line a couple of times.
	 */
	outb(IO_KBD + KBCMDP, KBC_PULSE0);
	delay(100000);
	outb(IO_KBD + KBCMDP, KBC_PULSE0);
	delay(100000);

	/*
	 * Try to cause a triple fault and watchdog reset by setting the
	 * IDT to point to nothing.
	 */
	bzero((caddr_t)idt, sizeof(idt_region));
	setregion(&region, idt, sizeof(idt_region) - 1);
	lidt(&region);
	__asm volatile("divl %0,%1" : : "q" (0), "a" (0));

	/*
	 * Try to cause a triple fault and watchdog reset by unmapping the
	 * entire address space.
	 */
	bzero((caddr_t)PTD, NBPG);
	tlbflush();

	for (;;)
		continue;
	/* NOTREACHED */
}

void
cpu_initclocks(void)
{
	(*initclock_func)();		/* lapic or i8254 */
}

void
need_resched(struct cpu_info *ci)
{
	ci->ci_want_resched = 1;

	/* There's a risk we'll be called before the idle threads start */
	if (ci->ci_curproc) {
		aston(ci->ci_curproc);
		cpu_kick(ci);
	}
}

/* Allocate an IDT vector slot within the given range.
 * XXX needs locking to avoid MP allocation races.
 */

int
idt_vec_alloc(int low, int high)
{
	int vec;

	for (vec = low; vec <= high; vec++)
		if (idt[vec].gd_p == 0)
			return (vec);
	return (0);
}

void
idt_vec_set(int vec, void (*function)(void))
{
	setgate(&idt[vec], function, 0, SDT_SYS386IGT, SEL_KPL, GICODE_SEL);
}

void
idt_vec_free(int vec)
{
	unsetgate(&idt[vec]);
}

/*
 * machine dependent system variables.
 */
int
cpu_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	dev_t dev;
	int val, error;

	switch (name[0]) {
	case CPU_CONSDEV:
		if (namelen != 1)
			return (ENOTDIR);		/* overloaded */

		if (cn_tab != NULL)
			dev = cn_tab->cn_dev;
		else
			dev = NODEV;
		return sysctl_rdstruct(oldp, oldlenp, newp, &dev, sizeof(dev));
#if NBIOS > 0
	case CPU_BIOS:
		return bios_sysctl(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen, p);
#endif
	case CPU_BLK2CHR:
		if (namelen != 2)
			return (ENOTDIR);		/* overloaded */
		dev = blktochr((dev_t)name[1]);
		return sysctl_rdstruct(oldp, oldlenp, newp, &dev, sizeof(dev));
	case CPU_CHR2BLK:
		if (namelen != 2)
			return (ENOTDIR);		/* overloaded */
		dev = chrtoblk((dev_t)name[1]);
		return sysctl_rdstruct(oldp, oldlenp, newp, &dev, sizeof(dev));
	case CPU_ALLOWAPERTURE:
#ifdef APERTURE
		if (securelevel > 0)
			return (sysctl_int_lower(oldp, oldlenp, newp, newlen,
			    &allowaperture));
		else
			return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &allowaperture));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
	case CPU_CPUVENDOR:
		return (sysctl_rdstring(oldp, oldlenp, newp, cpu_vendor));
	case CPU_CPUID:
		return (sysctl_rdint(oldp, oldlenp, newp, cpu_id));
	case CPU_CPUFEATURE:
		return (sysctl_rdint(oldp, oldlenp, newp, curcpu()->ci_feature_flags));
#if NAPM > 0
	case CPU_APMWARN:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &cpu_apmwarn));
	case CPU_APMHALT:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &cpu_apmhalt));
#endif
	case CPU_KBDRESET:
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp,
			    kbd_reset));
		else
			return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &kbd_reset));
	case CPU_OSFXSR:
		return (sysctl_rdint(oldp, oldlenp, newp, i386_use_fxsave));
	case CPU_SSE:
		return (sysctl_rdint(oldp, oldlenp, newp, i386_has_sse));
	case CPU_SSE2:
		return (sysctl_rdint(oldp, oldlenp, newp, i386_has_sse2));
	case CPU_XCRYPT:
		return (sysctl_rdint(oldp, oldlenp, newp, i386_has_xcrypt));
	case CPU_LIDSUSPEND:
	case CPU_LIDACTION:
		val = lid_action;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &val);
		if (!error) {
			if (val < 0 || val > 2)
				error = EINVAL;
			else
				lid_action = val;
		}
		return (error);
#if NPCKBC > 0 && NUKBD > 0
	case CPU_FORCEUKBD:
		if (forceukbd)
			return (sysctl_rdint(oldp, oldlenp, newp, forceukbd));

		error = sysctl_int(oldp, oldlenp, newp, newlen, &forceukbd);
		if (forceukbd)
			pckbc_release_console();
		return (error);
#endif
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

int
bus_space_map(bus_space_tag_t t, bus_addr_t bpa, bus_size_t size, int flags,
    bus_space_handle_t *bshp)
{
	int error;
	struct extent *ex;

	/*
	 * Pick the appropriate extent map.
	 */
	if (t == I386_BUS_SPACE_IO) {
		ex = ioport_ex;
		if (flags & BUS_SPACE_MAP_LINEAR)
			return (EINVAL);
	} else if (t == I386_BUS_SPACE_MEM) {
		ex = iomem_ex;
	} else {
		panic("bus_space_map: bad bus space tag");
	}

	/*
	 * Before we go any further, let's make sure that this
	 * region is available.
	 */
	error = extent_alloc_region(ex, bpa, size,
	    EX_NOWAIT | (ioport_malloc_safe ? EX_MALLOCOK : 0));
	if (error)
		return (error);

	/*
	 * For I/O space, that's all she wrote.
	 */
	if (t == I386_BUS_SPACE_IO) {
		*bshp = bpa;
		return (0);
	}

	if (IOM_BEGIN <= bpa && bpa <= IOM_END) {
		*bshp = (bus_space_handle_t)ISA_HOLE_VADDR(bpa);
		return (0);
	}

	/*
	 * For memory space, map the bus physical address to
	 * a kernel virtual address.
	 */
	error = bus_mem_add_mapping(bpa, size, flags, bshp);
	if (error) {
		if (extent_free(ex, bpa, size, EX_NOWAIT |
		    (ioport_malloc_safe ? EX_MALLOCOK : 0))) {
			printf("bus_space_map: pa 0x%lx, size 0x%lx\n",
			    bpa, size);
			printf("bus_space_map: can't free region\n");
		}
	}

	return (error);
}

int
_bus_space_map(bus_space_tag_t t, bus_addr_t bpa, bus_size_t size,
    int flags, bus_space_handle_t *bshp)
{
	/*
	 * For I/O space, that's all she wrote.
	 */
	if (t == I386_BUS_SPACE_IO) {
		*bshp = bpa;
		return (0);
	}

	/*
	 * For memory space, map the bus physical address to
	 * a kernel virtual address.
	 */
	return (bus_mem_add_mapping(bpa, size, flags, bshp));
}

int
bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart, bus_addr_t rend,
    bus_size_t size, bus_size_t alignment, bus_size_t boundary,
    int flags, bus_addr_t *bpap, bus_space_handle_t *bshp)
{
	struct extent *ex;
	u_long bpa;
	int error;

	/*
	 * Pick the appropriate extent map.
	 */
	if (t == I386_BUS_SPACE_IO) {
		ex = ioport_ex;
	} else if (t == I386_BUS_SPACE_MEM) {
		ex = iomem_ex;
	} else {
		panic("bus_space_alloc: bad bus space tag");
	}

	/*
	 * Sanity check the allocation against the extent's boundaries.
	 */
	if (rstart < ex->ex_start || rend > ex->ex_end)
		panic("bus_space_alloc: bad region start/end");

	/*
	 * Do the requested allocation.
	 */
	error = extent_alloc_subregion(ex, rstart, rend, size, alignment, 0,
	    boundary, EX_NOWAIT | (ioport_malloc_safe ?  EX_MALLOCOK : 0),
	    &bpa);

	if (error)
		return (error);

	/*
	 * For I/O space, that's all she wrote.
	 */
	if (t == I386_BUS_SPACE_IO) {
		*bshp = *bpap = bpa;
		return (0);
	}

	/*
	 * For memory space, map the bus physical address to
	 * a kernel virtual address.
	 */
	error = bus_mem_add_mapping(bpa, size, flags, bshp);
	if (error) {
		if (extent_free(iomem_ex, bpa, size, EX_NOWAIT |
		    (ioport_malloc_safe ? EX_MALLOCOK : 0))) {
			printf("bus_space_alloc: pa 0x%lx, size 0x%lx\n",
			    bpa, size);
			printf("bus_space_alloc: can't free region\n");
		}
	}

	*bpap = bpa;

	return (error);
}

int
bus_mem_add_mapping(bus_addr_t bpa, bus_size_t size, int flags,
    bus_space_handle_t *bshp)
{
	paddr_t pa, endpa;
	vaddr_t va;
	bus_size_t map_size;
	int pmap_flags = PMAP_NOCACHE;

	pa = trunc_page(bpa);
	endpa = round_page(bpa + size);

#ifdef DIAGNOSTIC
	if (endpa <= pa && endpa != 0)
		panic("bus_mem_add_mapping: overflow");
#endif

	map_size = endpa - pa;

	va = (vaddr_t)km_alloc(map_size, &kv_any, &kp_none, &kd_nowait);
	if (va == 0)
		return (ENOMEM);

	*bshp = (bus_space_handle_t)(va + (bpa & PGOFSET));

	if (flags & BUS_SPACE_MAP_CACHEABLE)
		pmap_flags = 0;
	else if (flags & BUS_SPACE_MAP_PREFETCHABLE)
		pmap_flags = PMAP_WC;

	for (; map_size > 0;
	    pa += PAGE_SIZE, va += PAGE_SIZE, map_size -= PAGE_SIZE)
		pmap_kenter_pa(va, pa | pmap_flags,
		    PROT_READ | PROT_WRITE);
	pmap_update(pmap_kernel());

	return 0;
}

void
bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size)
{
	struct extent *ex;
	u_long va, endva;
	bus_addr_t bpa;

	/*
	 * Find the correct extent and bus physical address.
	 */
	if (t == I386_BUS_SPACE_IO) {
		ex = ioport_ex;
		bpa = bsh;
	} else if (t == I386_BUS_SPACE_MEM) {
		ex = iomem_ex;
		bpa = (bus_addr_t)ISA_PHYSADDR(bsh);
		if (IOM_BEGIN <= bpa && bpa <= IOM_END)
			goto ok;

		va = trunc_page(bsh);
		endva = round_page(bsh + size);

#ifdef DIAGNOSTIC
		if (endva <= va)
			panic("bus_space_unmap: overflow");
#endif

		(void) pmap_extract(pmap_kernel(), va, &bpa);
		bpa += (bsh & PGOFSET);

		pmap_kremove(va, endva - va);
		pmap_update(pmap_kernel());

		/*
		 * Free the kernel virtual mapping.
		 */
		km_free((void *)va, endva - va, &kv_any, &kp_none);
	} else
		panic("bus_space_unmap: bad bus space tag");

ok:
	if (extent_free(ex, bpa, size,
	    EX_NOWAIT | (ioport_malloc_safe ? EX_MALLOCOK : 0))) {
		printf("bus_space_unmap: %s 0x%lx, size 0x%lx\n",
		    (t == I386_BUS_SPACE_IO) ? "port" : "pa", bpa, size);
		printf("bus_space_unmap: can't free region\n");
	}
}

void
_bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size,
    bus_addr_t *adrp)
{
	u_long va, endva;
	bus_addr_t bpa;

	/*
	 * Find the correct bus physical address.
	 */
	if (t == I386_BUS_SPACE_IO) {
		bpa = bsh;
	} else if (t == I386_BUS_SPACE_MEM) {
		bpa = (bus_addr_t)ISA_PHYSADDR(bsh);
		if (IOM_BEGIN <= bpa && bpa <= IOM_END)
			goto ok;

		va = trunc_page(bsh);
		endva = round_page(bsh + size);

#ifdef DIAGNOSTIC
		if (endva <= va)
			panic("_bus_space_unmap: overflow");
#endif

		(void) pmap_extract(pmap_kernel(), va, &bpa);
		bpa += (bsh & PGOFSET);

		pmap_kremove(va, endva - va);
		pmap_update(pmap_kernel());

		/*
		 * Free the kernel virtual mapping.
		 */
		km_free((void *)va, endva - va, &kv_any, &kp_none);
	} else
		panic("bus_space_unmap: bad bus space tag");

ok:
	if (adrp != NULL)
		*adrp = bpa;
}

void
bus_space_free(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size)
{

	/* bus_space_unmap() does all that we need to do. */
	bus_space_unmap(t, bsh, size);
}

int
bus_space_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp)
{
	*nbshp = bsh + offset;
	return (0);
}

paddr_t
bus_space_mmap(bus_space_tag_t t, bus_addr_t addr, off_t off, int prot, int flags)
{
	/* Can't mmap I/O space. */
	if (t == I386_BUS_SPACE_IO)
		return (-1);

	return (addr + off);
}

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	if (lapic_tpr < wantipl)
		splassert_fail(wantipl, lapic_tpr, func);
	if (wantipl == IPL_NONE && curcpu()->ci_idepth != 0)
		splassert_fail(-1, curcpu()->ci_idepth, func);
}
#endif

int
copyin32(const uint32_t *uaddr, uint32_t *kaddr)
{
	if ((vaddr_t)uaddr & 0x3)
		return EFAULT;

	/* copyin(9) is atomic */
	return copyin(uaddr, kaddr, sizeof(uint32_t));
}

/*
 * True if the system has any non-level interrupts which are shared
 * on the same pin.
 */
int	intr_shared_edge;

/*
 * Software interrupt registration
 *
 * We hand-code this to ensure that it's atomic.
 */
void
softintr(int sir)
{
	struct cpu_info *ci = curcpu();

	__asm volatile("orl %1, %0" :
	    "=m" (ci->ci_ipending) : "ir" (1 << sir));
}

/*
 * Raise current interrupt priority level, and return the old one.
 */
int
splraise(int ncpl)
{
	int ocpl;

	_SPLRAISE(ocpl, ncpl);
	return (ocpl);
}

/*
 * Restore an old interrupt priority level.  If any thereby unmasked
 * interrupts are pending, call Xspllower() to process them.
 */
void
splx(int ncpl)
{
	_SPLX(ncpl);
}

/*
 * Same as splx(), but we return the old value of spl, for the
 * benefit of some splsoftclock() callers.
 */
int
spllower(int ncpl)
{
	int ocpl = lapic_tpr;

	splx(ncpl);
	return (ocpl);
}

int
intr_handler(struct intrframe *frame, struct intrhand *ih)
{
	int rc;
#ifdef MULTIPROCESSOR
	int need_lock;

	if (ih->ih_flags & IPL_MPSAFE)
		need_lock = 0;
	else
		need_lock = frame->if_ppl < IPL_SCHED;

	if (need_lock)
		__mp_lock(&kernel_lock);
#endif
	rc = (*ih->ih_fun)(ih->ih_arg ? ih->ih_arg : frame);
#ifdef MULTIPROCESSOR
	if (need_lock)
		__mp_unlock(&kernel_lock);
#endif
	return rc;
}

void
intr_barrier(void *ih)
{
	sched_barrier(NULL);
}

#if NVMM > 0
/*
 * cpu_check_vmm_cap
 *
 * Checks for VMM capabilities for 'ci'. Initializes certain per-cpu VMM
 * state in 'ci' if virtualization extensions are found.
 *
 * Parameters:
 *  ci: the cpu being checked
 */
void
cpu_check_vmm_cap(struct cpu_info *ci)
{
	uint64_t msr;
	uint32_t cap, dummy;

	/*
	 * Check for workable VMX
	 */
	if (cpu_ecxfeature & CPUIDECX_VMX) {
		msr = rdmsr(MSR_IA32_FEATURE_CONTROL);

		if (!(msr & IA32_FEATURE_CONTROL_LOCK))
			ci->ci_vmm_flags |= CI_VMM_VMX;
		else {
			if (msr & IA32_FEATURE_CONTROL_VMX_EN)
				ci->ci_vmm_flags |= CI_VMM_VMX;
			else
				ci->ci_vmm_flags |= CI_VMM_DIS;
		}
	}

	/*
	 * Check for EPT (Intel Nested Paging) and other secondary
	 * controls
	 */
	if (ci->ci_vmm_flags & CI_VMM_VMX) {
		/* Secondary controls available? */
		/* XXX should we check true procbased ctls here if avail? */
		msr = rdmsr(IA32_VMX_PROCBASED_CTLS);
		if (msr & (IA32_VMX_ACTIVATE_SECONDARY_CONTROLS) << 32) {
			msr = rdmsr(IA32_VMX_PROCBASED2_CTLS);
			/* EPT available? */
			if (msr & (IA32_VMX_ENABLE_EPT) << 32)
				ci->ci_vmm_flags |= CI_VMM_EPT;
			/* VM Functions available? */
			if (msr & (IA32_VMX_ENABLE_VM_FUNCTIONS) << 32) {
				ci->ci_vmm_cap.vcc_vmx.vmx_vm_func =
				    rdmsr(IA32_VMX_VMFUNC);	
			}
		}
	}

	/*
	 * Check startup config (VMX)
	 */
	if (ci->ci_vmm_flags & CI_VMM_VMX) {
		/* CR0 fixed and flexible bits */
		msr = rdmsr(IA32_VMX_CR0_FIXED0);
		ci->ci_vmm_cap.vcc_vmx.vmx_cr0_fixed0 = msr;
		msr = rdmsr(IA32_VMX_CR0_FIXED1);
		ci->ci_vmm_cap.vcc_vmx.vmx_cr0_fixed1 = msr;

		/* CR4 fixed and flexible bits */
		msr = rdmsr(IA32_VMX_CR4_FIXED0);
		ci->ci_vmm_cap.vcc_vmx.vmx_cr4_fixed0 = msr;
		msr = rdmsr(IA32_VMX_CR4_FIXED1);
		ci->ci_vmm_cap.vcc_vmx.vmx_cr4_fixed1 = msr;

		/* VMXON region revision ID (bits 30:0 of IA32_VMX_BASIC) */
		msr = rdmsr(IA32_VMX_BASIC);
		ci->ci_vmm_cap.vcc_vmx.vmx_vmxon_revision =
			(uint32_t)(msr & 0x7FFFFFFF);

		/* MSR save / load table size */
		msr = rdmsr(IA32_VMX_MISC);
		ci->ci_vmm_cap.vcc_vmx.vmx_msr_table_size =
			(uint32_t)(msr & IA32_VMX_MSR_LIST_SIZE_MASK) >> 25;

		/* CR3 target count size */
		ci->ci_vmm_cap.vcc_vmx.vmx_cr3_tgt_count =
			(uint32_t)(msr & IA32_VMX_CR3_TGT_SIZE_MASK) >> 16;
	}

	/*
	 * Check for workable SVM
	 */
	if (ecpu_ecxfeature & CPUIDECX_SVM) {
		msr = rdmsr(MSR_AMD_VM_CR);

		if (!(msr & AMD_SVMDIS))
			ci->ci_vmm_flags |= CI_VMM_SVM;
	}

	/*
	 * Check for SVM Nested Paging
	 */
	if (ci->ci_vmm_flags & CI_VMM_SVM) {
		CPUID(CPUID_AMD_SVM_CAP, dummy, dummy, dummy, cap);
		if (cap & AMD_SVM_NESTED_PAGING_CAP)
			ci->ci_vmm_flags |= CI_VMM_RVI;
	}
}
#endif /* NVMM > 0 */

@


1.602
log
@Support for SMAP is pretty small, so don't exclude it from the RAMDISKS.
ok jsg visa
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.601 2017/05/18 09:20:06 kettenis Exp $	*/
a3422 1
#if 1
a3428 1
#endif
@


1.601
log
@Since copyin(9) already doeas access 32-bit quantities atomically, we can
add copyin32(9) as a simple C wrapper around it.  These wrappers do check
alignment and return EFAULT if the userland pointer is misaligned.  This is
enough to guarantee that the access doesn't cross a cache line boundary which
could make the access non-atomic.

ok mpi@@, visa@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.600 2017/04/30 16:45:45 mpi Exp $	*/
a2033 1
#ifndef SMALL_KERNEL
a2035 1
#endif
@


1.600
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.599 2017/04/30 13:04:49 mpi Exp $	*/
d3892 10
@


1.599
log
@Unifdef KGDB.

It doesn't compile und hasn't been working during the last decade.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.598 2017/03/11 11:55:03 mpi Exp $	*/
d3380 1
a3380 1
		Debugger();
@


1.598
log
@Introduce a new knob to force the first USB keyboard as console input.

By setting "machdep.forceukbd=1" you can now use your USB keyboard in
ddb(4) even if your BIOS emulates a pckbd(4).

ok tom@@, kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.597 2017/03/07 11:49:42 natano Exp $	*/
a94 4
#ifdef KGDB
#include <sys/kgdb.h>
#endif

a285 22
#ifdef KGDB
#ifndef KGDB_DEVNAME
#define KGDB_DEVNAME "com"
#endif /* KGDB_DEVNAME */
char kgdb_devname[] = KGDB_DEVNAME;
#if NCOM > 0
#ifndef KGDBADDR
#define KGDBADDR 0x3f8
#endif
int comkgdbaddr = KGDBADDR;
#ifndef KGDBRATE
#define KGDBRATE TTYDEF_SPEED
#endif
int comkgdbrate = KGDBRATE;
#ifndef KGDBMODE
#define KGDBMODE ((TTYDEF_CFLAG & ~(CSIZE | CSTOPB | PARENB)) | CS8) /* 8N1 */
#endif
int comkgdbmode = KGDBMODE;
#endif /* NCOM > 0 */
void kgdb_port_init(void);
#endif /* KGDB */

a3381 7
#ifdef KGDB
	kgdb_port_init();
	if (boothowto & RB_KDB) {
		kgdb_debug_init = 1;
		kgdb_connect(1);
	}
#endif /* KGDB */
a3394 15

#ifdef KGDB
void
kgdb_port_init(void)
{

#if NCOM > 0
	if (!strcmp(kgdb_devname, "com")) {
		bus_space_tag_t tag = I386_BUS_SPACE_IO;
		com_kgdb_attach(tag, comkgdbaddr, comkgdbrate, COM_FREQ,
		    comkgdbmode);
	}
#endif
}
#endif /* KGDB */
@


1.597
log
@Disallow setting machdep.lidaction to any other value but [0,2].

suggested by halex
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.596 2017/03/02 10:38:10 natano Exp $	*/
d171 6
d244 1
d3616 10
@


1.596
log
@Add a new sysctl machdep.lidaction. The sysctl works as follows:

machdep.lidaction=0	# do nothing
machdep.lidaction=1	# suspend
machdep.lidaction=2	# hibernate

lidsuspend is just an alias for lidaction, so if you change one, the
other one will have the same value. The plan is to remove
machdep.lidsuspend eventually when people have upgraded their
/ets/sysctl.conf.

discussed with deraadt, who came up with the new MIB name
no objections mlarkin
ok stsp halex jcs
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.595 2017/01/13 17:15:27 mikeb Exp $	*/
d3533 1
d3600 9
a3608 1
		return (sysctl_int(oldp, oldlenp, newp, newlen, &lid_action));
@


1.595
log
@Disable and lock Silicon Debug feature on modern Intel CPUs

This implements one of the countermeasures against using Direct
Connect Interface (DCI) to debug CPUs via USB3 mentioned in the
"Tapping into the core" talk at the 33c3: identify and disable
the Silicon Debug feature found in Haswell and newer CPUs.

ok mlarkin, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.594 2017/01/03 09:48:15 mlarkin Exp $	*/
d237 1
a237 1
int lid_suspend = 1;
d2658 1
a2658 1
		lid_suspend = 0;
d3598 2
a3599 1
		return (sysctl_int(oldp, oldlenp, newp, newlen, &lid_suspend));
@


1.594
log
@
reduce differences between amd64 and i386 vmm
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.593 2016/10/21 06:20:58 mlarkin Exp $	*/
d2027 19
@


1.593
log
@
vmm(4) for i386. Userland changes forthcoming. Note that for the time being,
i386 hosts are limited to running only i386 guests, even if the underlying
hardware supports amd64. This is a restriction I hope to lift moving forward,
but for now please don't report problems running amd64 guests on i386 hosts.

This was a straightforward port of the in-tree amd64 code plus the old rotted
tree I had from last year for i386 support. Changes included converting 64-bit
VMREAD/VMWRITE ops to 2x32-bit ops, and fixing treatment of the TSS, which
differs on i386.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.592 2016/10/14 04:53:26 mlarkin Exp $	*/
d4006 2
@


1.592
log
@
cache some more cpuid info. the cached data is presently unused, but will
soon be.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.591 2016/10/09 11:25:39 tom Exp $	*/
d171 1
d343 3
d2084 4
d3978 104
@


1.591
log
@Apply consistency to forever loops with continue and NOTREACHED

Same thought from kettenis@@, ok krw@@ phessler@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.590 2016/09/18 14:28:25 deraadt Exp $	*/
d1818 4
d1823 2
a1824 2
			cpuid(0x80000006, regs);
			cachesize = (regs[2] >> 16);
d1829 1
a1844 1
			u_int regs[4];
d1849 4
@


1.590
log
@option INSECURE is obsolete
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.589 2016/09/03 12:12:43 mlarkin Exp $	*/
d2714 2
a2715 1
	for (;;) ;
d3440 3
a3442 1
	for (;;);
@


1.589
log
@
add SDBG to cpuid bits and identcpu
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.588 2016/06/22 07:22:00 mlarkin Exp $	*/
a304 3
#ifdef INSECURE
int allowaperture = 1;
#else
a305 1
#endif
@


1.588
log
@
Identify UMIP feature, if available.

ok millert, kettenis, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.587 2016/05/21 01:06:53 deraadt Exp $	*/
d1007 1
@


1.587
log
@hand-massage sendsig() and sys_sigreturn() to be much more similar
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.586 2016/05/20 02:30:41 mlarkin Exp $	*/
d1083 1
@


1.586
log
@
split the ACPI resume trampoline into code and data pages, and protect
with proper permissions. Same treatment was done on amd64 last year, i386
is catching up.

This diff has been in snaps for a few days, no regressions reported.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.585 2016/05/18 03:45:11 mlarkin Exp $	*/
d2483 1
a2483 1
	struct sigcontext *scp = SCARG(uap, sigcntxp), context;
a2487 2
		printf("%s(%d): sigreturn not from tramp [pc 0x%x 0x%lx]\n",
		    p->p_comm, p->p_pid, PROC_PC(p), p->p_p->ps_sigcoderet);
d2492 1
a2492 1
	if ((error = copyin((caddr_t)scp, &context, sizeof(*scp))))
d2495 1
a2495 4
	if (context.sc_cookie != ((long)scp ^ p->p_p->ps_sigcookie)) {
		printf("%s(%d): cookie %lx should have been %lx\n",
		    p->p_comm, p->p_pid, context.sc_cookie,
		    (long)scp ^ p->p_p->ps_sigcookie);
d2501 3
a2503 4
	context.sc_cookie = 0;
	(void)copyout(&context.sc_cookie, (caddr_t)scp +
	    offsetof(struct sigcontext, sc_cookie),
	    sizeof (context.sc_cookie));
d2506 1
a2506 1
	 * Restore signal context.
d2509 6
a2514 6
	if (context.sc_eflags & PSL_VM) {
		tf->tf_vm86_gs = context.sc_gs;
		tf->tf_vm86_fs = context.sc_fs;
		tf->tf_vm86_es = context.sc_es;
		tf->tf_vm86_ds = context.sc_ds;
		set_vflags(p, context.sc_eflags);
d2524 2
a2525 2
		if (((context.sc_eflags ^ tf->tf_eflags) & PSL_USERSTATIC) != 0 ||
		    !USERMODE(context.sc_cs, context.sc_eflags))
d2528 17
a2544 17
		tf->tf_fs = context.sc_fs;
		tf->tf_gs = context.sc_gs;
		tf->tf_es = context.sc_es;
		tf->tf_ds = context.sc_ds;
		tf->tf_eflags = context.sc_eflags;
	}
	tf->tf_edi = context.sc_edi;
	tf->tf_esi = context.sc_esi;
	tf->tf_ebp = context.sc_ebp;
	tf->tf_ebx = context.sc_ebx;
	tf->tf_edx = context.sc_edx;
	tf->tf_ecx = context.sc_ecx;
	tf->tf_eax = context.sc_eax;
	tf->tf_eip = context.sc_eip;
	tf->tf_cs = context.sc_cs;
	tf->tf_esp = context.sc_esp;
	tf->tf_ss = context.sc_ss;
d2549 1
a2549 1
	if (context.sc_fpstate) {
d2552 1
a2552 1
		if ((error = copyin(context.sc_fpstate, sfp, sizeof(*sfp))))
d2559 1
a2559 1
	p->p_sigmask = context.sc_mask & ~sigcantmask;
@


1.585
log
@
Split i386 mp hatch trampoline into code and data pages, and protect each
with proper W^X policy. The same thing was done for amd64 late last year,
catching i386 up now. Diff has been in snaps for a few days with no
reported fallout.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.584 2016/05/10 18:39:45 deraadt Exp $	*/
d3241 4
@


1.584
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.583 2016/03/24 04:56:08 guenther Exp $	*/
d3231 4
@


1.583
log
@Delete i386_{get,set}_ioperm(2) APIs and underlying sysarch(2) bits.
They're no longer used by anything and should let us simplify the TSS
handling.

ok mikeb@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.582 2016/03/15 03:17:51 guenther Exp $	*/
d2443 1
d2483 1
a2483 1
	struct sigcontext *scp, context;
d2487 15
a2501 7
	/*
	 * The trampoline code hands us the context.
	 * It is unsafe to keep track of it ourselves, in the event that a
	 * program jumps out of a signal handler.
	 */
	scp = SCARG(uap, sigcntxp);
	if (copyin((caddr_t)scp, &context, sizeof(*scp)) != 0)
d2503 7
@


1.582
log
@Burn more LDT deadwood: stop allocating one for each idle thread,
load the ldt register with the null selector (disabling use of it),
stop reloading it on every context switch, and blow away the table
itself, as well as the pcb and pmap bits that were used to track
it (making sure to keep pcb_savefpu correctly aligned).

testing naddy@@
ok kettenis@@ mpi@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.581 2016/03/07 05:32:46 naddy Exp $	*/
a461 1
	int x;
d466 1
a466 6
	pcb->pcb_tss.tss_ioopt =
	    ((caddr_t)pcb->pcb_iomap - (caddr_t)&pcb->pcb_tss) << 16;
	for (x = 0; x < sizeof(pcb->pcb_iomap) / 4; x++)
		pcb->pcb_iomap[x] = 0xffffffff;
	pcb->pcb_iomap_pad = 0xff;

a480 1
	int x;
d483 1
a483 6
	pcb->pcb_tss.tss_ioopt =
	    ((caddr_t)pcb->pcb_iomap - (caddr_t)&pcb->pcb_tss) << 16;
	for (x = 0; x < sizeof(pcb->pcb_iomap) / 4; x++)
		pcb->pcb_iomap[x] = 0xffffffff;
	pcb->pcb_iomap_pad = 0xff;

@


1.581
log
@Sync no-argument function declaration and definition by adding (void).
ok mlarkin@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.580 2016/03/03 12:41:30 naddy Exp $	*/
d457 1
a457 1
 * Set up proc0's TSS and LDT.
d460 1
a460 1
i386_proc0_tss_ldt_init(void)
a472 2
	pcb->pcb_ldt_sel = pmap_kernel()->pm_ldt_sel = GSEL(GLDT_SEL, SEL_KPL);
	pcb->pcb_ldt = ldt;
d480 1
a480 1
	lldt(pcb->pcb_ldt_sel);
d485 1
a485 1
i386_init_pcb_tss_ldt(struct cpu_info *ci)
a495 2
	pcb->pcb_ldt_sel = pmap_kernel()->pm_ldt_sel = GSEL(GLDT_SEL, SEL_KPL);
	pcb->pcb_ldt = ci->ci_ldt;
a2952 1
union descriptor ldt[NLDT];
d3060 1
a3060 27

void
cpu_default_ldt(struct cpu_info *ci)
{
	ci->ci_ldt = ldt;
	ci->ci_ldt_len = sizeof(ldt);
}

void
cpu_alloc_ldt(struct cpu_info *ci)
{
	union descriptor *cpu_ldt;
	size_t len = sizeof(ldt);

	cpu_ldt = (union descriptor *)uvm_km_alloc(kernel_map, len);
	bcopy(ldt, cpu_ldt, len);
	ci->ci_ldt = cpu_ldt;
	ci->ci_ldt_len = len;
}

void
cpu_init_ldt(struct cpu_info *ci)
{
	setsegment(&ci->ci_gdt[GLDT_SEL].sd, ci->ci_ldt, ci->ci_ldt_len - 1,
	    SDT_SYSLDT, SEL_KPL, 0, 0);
}
#endif	/* MULTIPROCESSOR */
a3076 2
	setsegment(&gdt[GLDT_SEL].sd, ldt, sizeof(ldt) - 1, SDT_SYSLDT,
	    SEL_KPL, 0, 0);
@


1.580
log
@Remove option USER_LDT and everything depending on it.
Remove machdep.userldt sysctl.
Remove i386_[gs]et_ldt syscall stub from libi386.
Remove i386_[gs]et_ldt regression test.

ok mlarkin@@ millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.579 2015/12/27 04:31:34 jsg Exp $	*/
d383 1
a383 1
cpu_startup()
d460 1
a460 1
i386_proc0_tss_ldt_init()
d2763 1
a2763 1
cpu_dump()
d2798 1
a2798 1
dumpsys()
d3059 1
a3059 1
cpu_init_idt()
d3410 1
a3410 1
consinit()
d3417 1
a3417 1
kgdb_port_init()
d3431 1
a3431 1
cpu_reset()
@


1.579
log
@If available prefer the rdseed instruction over rdrand when adding entropy
to the kernel rng.  If the rdseed source is empty fallback to rdrand
as suggested by naddy.  rdrand output comes from a prng that is
periodically reseeded.  rdseed should give us more bits of entropy.

ok naddy@@ djm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.578 2015/12/12 12:33:49 reyk Exp $	*/
a191 4
#ifdef USER_LDT
int	user_ldt_enable = 0;	/* sysctl'd to 1 to enable */
#endif

a2905 4
#ifdef USER_LDT
	pmap_ldt_cleanup(p);
#endif

a3579 5
#ifdef USER_LDT
	case CPU_USERLDT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &user_ldt_enable));
#endif
@


1.578
log
@Identify hypervisors before configuring other children of the mainbus
(bios, CPU, interrupt handlers, pvbus).  This splits the pvbus attach
function into two parts: pvbus_identify() to scan the CPUID registers
for supported hypervisors and pvbus_attach() to attach the bus, print
information, and configure the children.

This will be needed for Xen and KVM, as discussed with mikeb@@ and sf@@
OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.577 2015/12/07 06:34:14 jsg Exp $	*/
d317 1
d2042 2
@


1.577
log
@Add cpuid bits documented in the August 2015 revision of
"Intel Architecture Instruction Set Extensions Programming Reference"
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.576 2015/10/21 07:59:18 mpi Exp $	*/
a2043 5
#endif

#if NPVBUS > 0
		if (cpu_ecxfeature & CPUIDECX_HV)
			has_hv_cpuid = 1;
@


1.576
log
@Do not call uvm_swap_finicrypt_all() a second time in dumpsys().

ok tedu@@, deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.575 2015/09/13 12:28:31 kettenis Exp $	*/
d1071 1
d1080 4
d1087 17
d2005 4
a2008 5
				    ci->ci_feature_sefflags, dummy, dummy);
				max = sizeof(cpu_seff0_ebxfeatures) /
				    sizeof(cpu_seff0_ebxfeatures[0]);
				for (i = 0; i < max; i++)
					if (ci->ci_feature_sefflags &
d2013 6
d2042 1
a2042 1
		if (ci->ci_feature_sefflags & SEFF0EBX_SMAP)
@


1.575
log
@intr_barrier(9) for i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.574 2015/07/21 03:38:22 reyk Exp $	*/
a103 1
#include <uvm/uvm_swap.h>
a2802 4

#ifdef UVM_SWAP_ENCRYPT
	uvm_swap_finicrypt_all();
#endif
@


1.574
log
@Add pvbus(4), a pseudo-bus to attach non-PCI paravirtual devices and buses.
vmt(4) is moved from mainbus0 to pvbus0, more devices will follow.

OK sf@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.573 2015/07/16 23:03:40 sf Exp $	*/
d3976 5
@


1.573
log
@Remove 4 second delay on reboot/shutdown that was added 8 years
ago to "workaround MP timeout/splhigh/scsi race at reboot time".

Probably the issue has been fixed by now. And if not, the relevant scsi
controller drivers should add a workaround in their DVACT_POWERDOWN
hook.

While there, change the default final reset delay on amd64 to 0. People
who like looking at the final reboot message may still set the
CPURESET_DELAY define.

OK deraadt@@ kettenis@@ mlarkin@@ uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.572 2015/07/16 05:10:14 guenther Exp $	*/
d319 5
d2018 5
@


1.572
log
@Move grab/release of the kernel_lock for softintrs from the ASM stubs to
softintr_dispatch().  Delete traces of long superseded stats code.

ok beck@@ mpi@@ uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.571 2015/06/07 06:24:59 guenther Exp $	*/
a2620 2

	delay(4*1000000);	/* XXX */
@


1.571
log
@Enable use of mwait in non-MP boxes and report # of C-substates up to C7,
truncating trailing zeros.

Testing by many as part of a larger change to use ACPI _CST objects
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.570 2015/05/28 20:10:58 guenther Exp $	*/
a3886 14
}
#endif

#ifdef MULTIPROCESSOR
void
i386_softintlock(void)
{
	__mp_lock(&kernel_lock);
}

void
i386_softintunlock(void)
{
	__mp_unlock(&kernel_lock);
@


1.570
log
@Save the cpuid(6) eax bits in the cpu_info and report the SENSOR and ARAT
bits from it.

ok krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.569 2015/04/18 22:16:21 kettenis Exp $	*/
d2580 1
a2580 1
	if (cpu_mwait_size > 0) {
@


1.569
log
@It seems that the CPUID lies about the monitor-line size, or at least our
interpretation of it isn't quite right.  So instead of allocating memory
and slicing it based on the parameters returned by CPUID, simply use a member
in struct cpu_info like basically all other OSes out there do.  Our struct
cpu_info is large enough to never cause any overlap.  This makes the
mwait-based idle loop actually work.  We still execute the CPUID instruction
to make sure monitor/mwait is properly supported by the hardware we're
running on.

ok sthen@@, deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.568 2015/04/12 18:37:53 mlarkin Exp $	*/
d1080 5
d1489 1
a1489 8
	u_int regs[4];

	if (!CPU_IS_PRIMARY(ci) || cpuid_level < 0x06)
		return;

	/* CPUID.06H.EAX[0] = 1 tells us if we have on-die sensor */
	cpuid(0x06, regs);
	if ((regs[0] & 0x01) != 1)
d1989 14
@


1.568
log
@
Bring PAE code back to life, in a different form. This diff (via bluhm then
to deraadt, then myself) brings the PAE pmap on i386 (not touched in any
significant way for years) closer to the current non-PAE pmap and allows
us to take a big next step toward better i386 W^X in the kernel (similar to
what we did a few months ago on amd64). Unlike the original PAE pmap, this
diff will not be supporting > 4GB physical memory on i386 - this effort is
specifically geared toward providing W^X (via NX) only.

There still seems to be a bug removing certain pmap entries when PAE is
enabled, so I'm leaving PAE mode disabled for the moment until we can
figure out what is going on, but with this diff in the tree hopefully
others can help.

The pmap functions now operate through function pointers, due to the need
to support both non-PAE and PAE forms. My unscientific testing showed
less than 0.3% (a third of a percent) slowdown with this approach during
a base build.

Discussed for months with guenther, kettenis, and deraadt.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.567 2015/02/08 04:41:48 deraadt Exp $	*/
d2535 1
a2535 1
		if (ci->ci_mwait != NULL) {
d2540 1
a2540 1
			if ((ci->ci_mwait[0] & MWAIT_IN_IDLE) == 0)
d2543 1
a2543 1
				atomic_clearbits_int(&ci->ci_mwait[0],
d2568 1
a2568 1
	if (ci->ci_mwait != NULL) {
d2573 1
a2573 1
		atomic_clearbits_int(&ci->ci_mwait[0], MWAIT_KEEP_IDLING);
@


1.567
log
@Only attach cpu-based sensors on the primary cpu, for two reasons
- The sensor framework cannot fetch values on the right cpu
- sensor_task_register() calls malloc, and calling it is inapproapriate
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.566 2015/02/07 03:29:27 guenther Exp $	*/
d118 1
a3000 1
	pt_entry_t *pte;
d3015 1
a3015 2
	pte = PTE_BASE + atop(va);
	*pte &= ~PG_RW;
a3186 3
	/* install the lowmem ptp after boot args for 1:1 mappings */
	pmap_prealloc_lowmem_ptp(round_page((paddr_t)(bootargv + bootargc)));

a3331 18
#endif

#if defined(MULTIPROCESSOR) || \
    (NACPI > 0 && !defined(SMALL_KERNEL))
	/* install the lowmem ptp after boot args for 1:1 mappings */
	pmap_prealloc_lowmem_ptp(PTP0_PA);
#endif

#ifdef MULTIPROCESSOR
	pmap_kenter_pa((vaddr_t)MP_TRAMPOLINE,		/* virtual */
	    (paddr_t)MP_TRAMPOLINE,			/* physical */
	    PROT_READ | PROT_WRITE | PROT_EXEC);	/* protection */
#endif

#if NACPI > 0 && !defined(SMALL_KERNEL)
	pmap_kenter_pa((vaddr_t)ACPI_TRAMPOLINE,	/* virtual */
	    (paddr_t)ACPI_TRAMPOLINE,			/* physical */
	    PROT_READ | PROT_WRITE | PROT_EXEC);	/* protection */
@


1.566
log
@Document a non-obvious aspect of identifycpu() use on i386
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.565 2015/02/06 05:17:48 mlarkin Exp $	*/
d1162 2
a1163 1
		if (model == 10 || model == 13 || model == 15) {
d1485 1
a1485 1
	if (cpuid_level < 0x06)
@


1.565
log
@
Fix a hibernate crash on some machines due to unmapping a page that
may not have been mapped previously (in the failure to hibernate case).

Also ensure that the lowmem ptp is mapped in all cases (not just MP).

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.564 2015/01/20 19:43:21 kettenis Exp $	*/
d1669 8
@


1.564
log
@Move ps_strings "after" the random stackgap.  This makes its location a
per-process value, and therefpore turns the VM_PSSTRINGS sysctl into a
per-process one as well.  This gets rid of a pointer to the bottom of the
stack at a fixed location.  Also clears the road for unmapping the stackgap.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.563 2015/01/19 16:01:44 jsg Exp $	*/
a3178 1
#if defined(MULTIPROCESSOR)
a3180 1
#endif
@


1.563
log
@Make use of an msr available on recent Intel processors to obtain the
maximum supported temperature, Tj(Max).  As the temperature values are
relative to this value this should make the sensor values more accurate.

From Simon Mages.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.562 2015/01/15 13:58:55 sf Exp $	*/
d2898 1
a2898 1
	tf->tf_ebx = (int)PS_STRINGS;
@


1.562
log
@Define and print HV cpuid flag on i386.

This is set by many hypervisors, including kvm, vmware, hyper-v.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.561 2015/01/12 16:33:31 deraadt Exp $	*/
d1430 10
a1439 6
 * Poorly documented, refer to:
 * http://softwarecommunity.intel.com/isn/Community/
 * en-US/forums/thread/30228638.aspx
 * Basically, depending on a bit in one msr, the max is either 85 or 100.
 * Then we subtract the temperature portion of thermal status from
 * max to get current temperature.
d1449 3
a1451 2
	if (ci->ci_model == 0xe &&
	    (rdmsr(MSR_TEMPERATURE_TARGET) & MSR_TEMPERATURE_TARGET_LOW_BIT))
d1453 11
@


1.561
log
@Enable lid suspends by default in the kernel, and remove the question from
the installer.  We used a full release cycle to learn that suspend/resume
is reliable enough for this default.  Personal policy can disable this using
machdep.lidsuspend=0 in /etc/sysctl.conf
ok more people begging, and less people whining
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.560 2014/12/10 15:29:53 mikeb Exp $	*/
d1039 1
@


1.560
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.559 2014/12/03 20:09:32 krw Exp $	*/
d240 1
a240 1
int lid_suspend;
@


1.559
log
@More duplicate #include cleanout.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.558 2014/11/22 18:54:37 deraadt Exp $	*/
a2592 1
	doshutdownhooks();
@


1.558
log
@Do not use PROT_MASK as a non-mask
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.557 2014/11/16 12:30:57 deraadt Exp $	*/
a113 1
#include <machine/bus.h>
@


1.557
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.556 2014/10/25 16:57:58 kettenis Exp $	*/
d3323 3
a3325 3
	pmap_kenter_pa((vaddr_t)MP_TRAMPOLINE,  /* virtual */
	    (paddr_t)MP_TRAMPOLINE,             /* physical */
	    PROT_MASK);                       /* protection */
d3329 3
a3331 3
	pmap_kenter_pa((vaddr_t)ACPI_TRAMPOLINE,/* virtual */
	    (paddr_t)ACPI_TRAMPOLINE,           /* physical */
	    PROT_MASK);                       /* protection */
@


1.556
log
@uvm_km_valloc -> km_alloc

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.555 2014/10/17 20:37:57 sthen Exp $	*/
d395 1
a395 1
		pmap_kenter_pa(va, pa, VM_PROT_READ|VM_PROT_WRITE);
d2797 1
a2797 1
			    VM_PROT_READ, PMAP_WIRED);
d3151 2
a3152 2
		    VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d3325 1
a3325 1
	    VM_PROT_ALL);                       /* protection */
d3331 1
a3331 1
	    VM_PROT_ALL);                       /* protection */
d3743 1
a3743 1
		    VM_PROT_READ | VM_PROT_WRITE);
@


1.555
log
@reinstate i386/bus_space diff now that serial consoles are fixed in
sys/arch/i386/i386/bios.c, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.552 2014/10/17 01:46:26 dlg Exp $	*/
d3729 1
a3729 1
	va = uvm_km_valloc(kernel_map, map_size);
d3785 1
a3785 1
		uvm_km_free(kernel_map, va, endva - va);
d3832 1
a3832 1
		uvm_km_free(kernel_map, va, endva - va);
@


1.554
log
@backout i386/bus_space diff for now, req'd by deraadt@@ - problems at boot

|	i386/bus_space.c:1.5->1.6
|	i386/machdep.c:1.551->1.552
|	include/bus.h:1.61->1.62
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.551 2014/09/19 20:02:25 kettenis Exp $	*/
d3579 1
a3579 2
	switch (t) {
	case I386_BUS_SPACE_IO:
d3583 1
a3583 3
		break;

	case I386_BUS_SPACE_MEM:
d3585 1
a3585 3
		break;

	default:
d3659 1
a3659 2
	switch (t) {
	case I386_BUS_SPACE_IO:
d3661 1
a3661 3
		break;

	case I386_BUS_SPACE_MEM:
d3663 1
a3663 3
		break;

	default:
@


1.553
log
@Also remove trailing spaces from the CPU brand string.

ok deraadt@@, armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.552 2014/10/17 01:46:26 dlg Exp $	*/
d3579 2
a3580 1
	if (t == I386_BUS_SPACE_IO) {
d3584 3
a3586 1
	} else if (t == I386_BUS_SPACE_MEM) {
d3588 3
a3590 1
	} else {
d3664 2
a3665 1
	if (t == I386_BUS_SPACE_IO) {
d3667 3
a3669 1
	} else if (t == I386_BUS_SPACE_MEM) {
d3671 3
a3673 1
	} else {
@


1.552
log
@bring the twisting of bus_space from amd64 over to i386. this is:

src/sys/arch/amd64/amd64/bus_space.c r1.22
src/sys/arch/amd64/include/bus.h r1.27

instead of using the tag as an identifier for IO or memory mappings
that was checked inside the api, turn it into a pointer to a structure
of function pointers. the api then generally becomes a set of macros
that deref the function pointers on the callers behalf. the idea
is that following a pointer to very small functions is cheap compared
to doing compares continuously.

the kernel is smaller and the api is more cache friendly now.

the porting of this code from amd64 to i386 was done by kimberley manning
requested by and ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.551 2014/09/19 20:02:25 kettenis Exp $	*/
d1818 1
a1818 1
	/* Remove leading and duplicated spaces from cpu_brandstr */
d1830 2
@


1.551
log
@Use config_suspend_all(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.550 2014/07/21 17:25:47 uebayasi Exp $	*/
d3577 1
a3577 2
	switch (t) {
	case I386_BUS_SPACE_IO:
d3581 1
a3581 3
		break;

	case I386_BUS_SPACE_MEM:
d3583 1
a3583 3
		break;

	default:
d3657 1
a3657 2
	switch (t) {
	case I386_BUS_SPACE_IO:
d3659 1
a3659 3
		break;

	case I386_BUS_SPACE_MEM:
d3661 1
a3661 3
		break;

	default:
@


1.550
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2559 2
	struct device *mainbus;

d2593 1
a2593 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.549
log
@More comment cleanup in boot().
@
text
@d2562 1
a2562 1
	if (howto & RB_POWERDOWN)
d2590 1
a2590 1
	if (howto & RB_DUMP)
d2603 1
a2603 1
	if (howto & RB_HALT) {
d2609 1
a2609 1
			if (howto & RB_POWERDOWN)
d2615 1
a2615 1
		if (howto & RB_POWERDOWN) {
d2659 1
a2659 1
	for(;;) ;
@


1.548
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@a2589 1
	/* Do a dump if requested. */
@


1.547
log
@Cosmetic changes to reduce diffs.
@
text
@d2661 1
a2661 1
	/*NOTREACHED*/
@


1.546
log
@boot(9): Undo curproc-overriding hacks

Some (not all) boot(9) implementations have ancient hacks which overrides if
(curproc == NULL).  This was probably made in a hope to forcibly proceed
various clean-shutdown related code, including VFS shutdown.  Let's clarify
that clean-shutdown needs process context; it is impossible to cleanly shutdown
VFS from within e.g. a panic in SPL_HIGH.

OK kettenis@@
@
text
@d2587 1
a2587 1
	splhigh();		/* Disable interrupts. */
@


1.545
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.544 2014/07/10 20:15:27 uebayasi Exp $	*/
a2572 5
		extern struct proc proc0;

		if (curproc == NULL)
			curproc = &proc0;

@


1.544
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d2593 1
@


1.543
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@a2565 4
		/*
		 * If the system is cold, just halt, unless the user
		 * explicitly asked for reboot.
		 */
@


1.542
log
@boot(): Unify declarations

OK deraadt@@
@
text
@a2578 1
		/* make sure there's a process to charge for I/O in sync() */
d2584 1
a2584 4
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now.
		 */
@


1.541
log
@Create the ioport_ex and iomem_ex extents after we've set up the gdt gates
such that curcpu() works.  The extent code creates pools, and if we want to
add any sort of locking to the pool code we need that working.  Found out the
hard way by guenther@@.

ok dlg@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.540 2014/07/03 21:15:28 matthew Exp $	*/
d2557 1
a2557 1
void
@


1.540
log
@Add identcpu detection for 1-GByte pages

ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.539 2014/06/15 11:43:24 sf Exp $	*/
a3063 18
	/*
	 * Initialize the I/O port and I/O mem extent maps.
	 * Note: we don't have to check the return value since
	 * creation of a fixed extent map will never fail (since
	 * descriptor storage has already been allocated).
	 *
	 * N.B. The iomem extent manages _all_ physical addresses
	 * on the machine.  When the amount of RAM is found, the two
	 * extents of RAM are allocated from the map (0 -> ISA hole
	 * and end of ISA hole -> end of RAM).
	 */
	ioport_ex = extent_create("ioport", 0x0, 0xffff, M_DEVBUF,
	    (caddr_t)ioport_ex_storage, sizeof(ioport_ex_storage),
	    EX_NOCOALESCE|EX_NOWAIT);
	iomem_ex = extent_create("iomem", 0x0, 0xffffffff, M_DEVBUF,
	    (caddr_t)iomem_ex_storage, sizeof(iomem_ex_storage),
	    EX_NOCOALESCE|EX_NOWAIT);

d3112 18
@


1.539
log
@Fix a few format string bugs with -DDEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.538 2014/05/31 15:49:28 mpi Exp $	*/
d1000 8
a1007 7
	{ CPUID_MPC,	"MPC" },
	{ CPUID_NXE,	"NXE" },
	{ CPUID_MMXX,	"MMXX" },
	{ CPUID_FFXSR,	"FFXSR" },
	{ CPUID_LONG,	"LONG" },
	{ CPUID_3DNOW2,	"3DNOW2" },
	{ CPUID_3DNOW,	"3DNOW" }
@


1.538
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.537 2014/05/30 13:46:16 mpi Exp $	*/
d3304 1
a3304 1
		printf(" %x-%x (<16M)", lim, kb);
d3321 1
a3321 1
				printf(" %x-%x", a, e);
@


1.537
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.536 2014/03/29 18:09:29 guenther Exp $	*/
a2599 1
	cold = 1;
@


1.536
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.535 2014/03/26 05:23:42 guenther Exp $	*/
d2600 1
@


1.535
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.534 2014/03/22 06:05:45 guenther Exp $	*/
d367 1
a367 1
	__asm __volatile(
d3439 1
a3439 1
	__asm __volatile("divl %0,%1" : : "q" (0), "a" (0));
d3932 1
a3932 1
	__asm __volatile("orl %1, %0" :
@


1.534
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.533 2014/03/16 05:19:44 jsg Exp $	*/
d2404 1
a2404 1
	tf->tf_eip = p->p_sigcode;
@


1.533
log
@Remove warnings on unknown x86 models in the code that returns the FSB
speed and remove the no-op cases added to avoid the warning.

We shouldn't normally hit the warning anyway, the bus speed is only
used on older i386 machines with piixpcib/ichpcib based speedstep or
to create a fake high/low table with newer style speedstep when we
can't get the table from ACPI.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.532 2014/03/13 03:52:55 dlg Exp $	*/
d2307 1
a2307 1
	struct sigacts *psp = p->p_sigacts;
@


1.532
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.531 2014/01/05 20:23:57 mlarkin Exp $	*/
a2221 15
	/* nehalem */
	case 0x1a: /* Core i7, Xeon 3500/5500 */
	case 0x1e: /* Core i5/i7, Xeon 3400 */
	case 0x1f: /* Core i5/i7 */
	case 0x2e: /* Xeon 6500/7500 */
	/* westmere */
	case 0x25: /* Core i3/i5, Xeon 3400 */
	case 0x2c: /* Core i7, Xeon 3600/5600 */
	case 0x2f: /* Xeon E7 */
	/* sandy bridge */
	case 0x2a: /* Core i5/i7 2nd Generation */
	case 0x2d: /* Xeon E5 */
	/* ivy bridge */
	case 0x3a: /* Core i3/i5/i7 3rd Generation */
		break;
d2223 1
a2223 8
		printf("%s: unknown i686 model 0x%x, can't get bus clock",
		    ci->ci_dev.dv_xname, ci->ci_model);
print_msr:
		/*
		 * Show the EBL_CR_POWERON MSR, so we'll at least have
		 * some extra information, such as clock ratio, etc.
		 */
		printf(" (0x%llx)\n", rdmsr(MSR_EBL_CR_POWERON));
d2226 7
@


1.531
log
@

Don't use the first 64KB for anything, including tramps. Move tramps and
hibernate goo up after 64KB to avoid posible corruption by buggy BIOS SMM
code. Diff also ensures the first 64KB doesn't get handed to UVM either.

ok deraadt@@, tested by many with no regressions reported
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.530 2013/12/27 21:40:57 deraadt Exp $	*/
d2574 2
d2622 3
a2624 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.530
log
@oops, correct wording
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.529 2013/12/27 21:40:16 deraadt Exp $	*/
d168 5
d3231 18
@


1.529
log
@correct comment about why first 16 pages are skipped: SMI corruption
is the real cause
discussed with mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.528 2013/11/01 17:36:19 krw Exp $	*/
d3223 1
a3223 1
			/* skip first 16 pages for due to SMI corruption */
@


1.528
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.527 2013/10/17 08:02:15 deraadt Exp $	*/
d3223 1
a3223 1
			/* skip first 16 pages for tramps and hibernate */
@


1.527
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.526 2013/10/09 01:48:40 guenther Exp $	*/
d2806 1
a2806 1
		printf("(%d %lld %d) ", maddr, blkno, npg);
d2815 1
a2815 1
			printf("(%x %lld) ", maddr, blkno);
@


1.526
log
@Use monitor/mwait to idle when available.  Make cpu_unidle() do nothing
if it can tell the target CPU isn't actually idling and introduce cpu_kick()
for the cases where we want to force a non-idle CPU into the kernel.

just a port of the amd64 version; testing by many
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.525 2013/10/02 21:06:16 sf Exp $	*/
a3373 13
}

/*
 * cpu_exec_aout_makecmds():
 *	cpu-dependent a.out format hook for execve().
 *
 * Determine of the given exec package refers to something which we
 * understand and, if so, set up the vmcmds for it.
 */
int
cpu_exec_aout_makecmds(struct proc *p, struct exec_package *epp)
{
	return ENOEXEC;
@


1.525
log
@Format string fixes: Use %l* for paddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.524 2013/09/28 12:40:30 miod Exp $	*/
d2509 25
d2542 1
a2542 1
	cpu_unidle(p->p_cpu);
d2549 9
d3469 1
a3469 1
		cpu_unidle(ci);
@


1.524
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.523 2013/06/11 16:42:08 deraadt Exp $	*/
d2778 1
a2778 1
				printf("%d ",
d3228 1
a3228 1
				printf("\nWARNING: CAN'T ALLOCATE RAM (%x-%x)"
@


1.523
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.522 2013/05/16 19:26:04 kettenis Exp $	*/
d2581 2
a2582 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.522
log
@Implement a mechanism to establish interrupt handlers that don't grab the
kernel lock upon entry through a new IPL_MPSAFE flag/level.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.521 2013/05/12 14:15:31 ratchov Exp $	*/
d2686 1
a2686 1
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
d2723 2
a2724 2
	daddr64_t blkno;
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
@


1.521
log
@Take the kernel lock and call the actual interrupt handler from a
single c function. This will hopefully make easier to stop taking
the kernel lock when running "mp safe" interrupt handlers.

help from ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.520 2013/02/13 21:21:34 martynas Exp $	*/
d3945 4
a3948 1
	need_lock = frame->if_ppl < IPL_SCHED;
@


1.520
log
@De-magic IOM_END like in the rest of machdep.c.  OK miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.519 2012/12/04 20:51:10 kettenis Exp $	*/
d169 1
a3870 14
i386_intlock(int ipl)
{
	if (ipl < IPL_SCHED)
		__mp_lock(&kernel_lock);
}

void
i386_intunlock(int ipl)
{
	if (ipl < IPL_SCHED)
		__mp_unlock(&kernel_lock);
}

void
d3937 21
@


1.519
log
@Implement bus_space_mmap(9).

ok miod@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.518 2012/12/02 07:03:31 guenther Exp $	*/
d3254 2
a3255 2
	if (kb > atop(0x100000)) {
		paddr_t lim = atop(0x100000);
@


1.518
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.517 2012/11/10 09:45:05 mglocker Exp $	*/
d3845 10
@


1.517
log
@Recent x86 CPUs come with a constant time stamp counter.  If this is
the case we verify if the CPU supports a specific version of the
architectural performance monitoring feature and read out the current
frequency from the fixed-function performance counter of the unhalted
core.

My initial motivation to implement this was the Soekris net6501-70
which comes with an Intel Atom E6xx 1.60GHz CPU.  It has a constant
time stamp counter plus speed step support and boots on the lowest
frequency of 600MHz.  This caused hw.cpuspeed and hw.setperf to
reflect the wrong values.

The diff is a cooperation work with jsg@@.  The fixed-function
performance counter read code comes from a former diff of him.

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.516 2012/10/31 03:30:22 jsg Exp $	*/
a2317 1
	int oonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d2322 1
d2328 2
a2329 2
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !oonstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
d2331 1
a2331 2
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	} else
a2357 1
	frame.sf_sc.sc_onstack = oonstack;
a2502 4
	if (context.sc_onstack & 01)
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.516
log
@Add support for Intel's Supervisor Mode Access Prevention (SMAP) feature.
When enabled SMAP will generate page faults on the kernel attempting
to read/write user data pages unless an override flag is set.

Instructions that modify the flag are patched into copyin/copyout and
friends on boot if SMAP is enabled.

Those with access to hardware with SMAP can contact me for a test case.

joint work with deraadt@@

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.515 2012/10/09 09:16:09 jsg Exp $	*/
d1072 8
d1849 14
a1862 1
		/* Has TSC */
d1921 16
@


1.515
log
@Sync "Structured Extended Feature Flags" cpuid bits with
the August 2012 revision of
"Intel Architecture Instruction Set Extensions Programming Reference".

Correct definitions of EREP and INVPCID, rename EREP to ERMS to
match Intel's docs.  Add some more Haswell feature bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.514 2012/10/09 04:40:36 jsg Exp $	*/
d168 2
d1926 4
@


1.514
log
@Enable Supervisor Mode Execution Protection (SMEP), found in recent
Intel chips.  If the kernel is tricked into running code from a user
page while in supervisor mode we'll now get a page fault and panic
instead of running it.

suggestions and ok guenther@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.513 2012/10/08 21:47:48 deraadt Exp $	*/
d1057 3
d1061 2
a1062 1
	{ SEFF0EBX_EREP,	"EREP" },
d1064 4
@


1.513
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.512 2012/09/19 20:19:31 jsg Exp $	*/
d1895 1
a1895 1
				u_int val, dummy;
d1898 2
a1899 1
				CPUID_LEAF(0x7, 0, dummy, val, dummy, dummy);
d1903 2
a1904 1
					if (val & cpu_seff0_ebxfeatures[i].feature_bit)
@


1.512
log
@Add support for the rdrand instruction found in recent Intel processors.
Joint work with naddy@@

ok naddy@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.511 2012/08/24 02:49:23 guenther Exp $	*/
d2533 1
@


1.511
log
@Synchronize CR4 and CPUID portions of <machine/specialreg.h> for i386 and amd64
Add display of more feature bits: DTES64 PCID DEADLINE F16C RDRAND
Add display of "Structured Extended Feature Flags Parameters":
    FSGSBASE SMEP EREP INVPCID

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.510 2012/05/23 08:23:43 mikeb Exp $	*/
d309 2
d1909 5
@


1.510
log
@increase the number of io and mem extent regions for amd64 to 16
as it was done for i386 some time ago;  update the comment in the
i386 code to reflect reality.  this helps machines with plenty of
memory regions set up by the bios.  ok kettenis, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.509 2012/03/27 06:44:01 jsg Exp $	*/
d975 1
a975 1
	{ CPUID_SER,	"SER" },
d986 1
a986 1
	{ CPUID_SBF,	"SBF" }
d1002 1
d1015 1
d1022 1
d1027 2
d1033 1
d1035 2
d1039 4
d1044 1
d1046 12
a1057 1
	{ CPUIDECX_FMA4,	"FMA4" }
d1522 1
a1522 1
	if ((model == 7) && (ci->ci_feature_flags & CPUID_SER)) {
d1529 1
a1529 1
		ci->ci_feature_flags &= ~CPUID_SER;
d1890 14
@


1.509
log
@Make the bus_clock calculations happen later in the boot process so
they can be conditionally called in future.

This makes the i386 speedstep code closer to the amd64 code
(though still with the added complications of VIA support and the
*_update_cpuspeed callbacks)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.508 2012/03/23 15:51:25 guenther Exp $	*/
d254 1
a254 1
 * storage for 8 regions in each, initially.  Later, ioport_malloc_safe
@


1.508
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.507 2012/03/19 00:49:08 jsg Exp $	*/
d1056 1
a1056 1
			est_init(ci->ci_dev.dv_xname, CPUVENDOR_VIA);
a1078 2
	cyrix3_get_bus_clock(ci);

d1444 1
a1444 1
			est_init(ci->ci_dev.dv_xname, CPUVENDOR_INTEL);
a1485 4
#if !defined(SMALL_KERNEL)
	p3_get_bus_clock(ci);
#endif

a1517 4
#if !defined(SMALL_KERNEL)
	p4_get_bus_clock(ci);
#endif

d2149 1
d2153 3
d2170 1
d2175 3
@


1.507
log
@more intel cpu models, though the low/high est method is largely
irrelevant with acpi machines
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.506 2011/11/02 23:53:44 jsg Exp $	*/
d2461 1
a2461 1
		/* protect against curproc->p_stats.foo refs in sync()   XXX */
@


1.506
log
@display AMD/extended (0x80000001) cpuid flags and remove the
Cyrix 3DNOW flag from normal cpuid flags as it will show up in
extended flags.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.505 2011/07/05 04:48:01 guenther Exp $	*/
d2050 1
d2079 2
d2128 1
d2132 2
d2136 2
a2137 2
		/* BUS133 */
		break;
d2140 2
a2141 4
		/* BUS100 */
		break;
	case 0x1d: /* Xeon MP 7400 */
	case 0x2e: /* Xeon 6500/7500 */
@


1.505
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.504 2011/07/05 00:30:10 deraadt Exp $	*/
d986 11
a996 2
	{ CPUID_SBF,	"SBF" },
	{ CPUID_3DNOW,	"3DNOW" },
d1026 10
d1851 8
d1866 8
@


1.504
log
@Remove the osyscall() kernel-entry; we do not use it anymore.
ok kettenis guenther tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.503 2011/06/26 22:39:59 deraadt Exp $	*/
d2183 1
a2183 1
	int oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d2193 1
a2193 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
d2195 2
a2196 2
		sp = (long)psp->ps_sigstk.ss_sp + psp->ps_sigstk.ss_size;
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d2371 1
a2371 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d2373 1
a2373 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.503
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.502 2011/06/26 21:46:03 tedu Exp $	*/
d2819 1
a2819 1
    IDTVEC(osyscall), IDTVEC(simd);
@


1.502
log
@1.500 was a good revision, let's stay there a little longer. (revert accidental commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.500 2011/06/05 19:41:07 deraadt Exp $	*/
d102 1
d2438 1
@


1.501
log
@remove remnants of scd device, discovered by Frederic Perrin
@
text
@d86 1
a103 1
#include <uvm/uvm.h>
@


1.500
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.499 2011/06/05 15:00:37 deraadt Exp $	*/
a85 1
#include <sys/vnode.h>
d103 1
@


1.499
log
@patch screwed me; left a line behind
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.498 2011/06/05 14:09:10 deraadt Exp $	*/
a186 11

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 10
#endif

#ifdef	BUFPAGES
int	bufpages = BUFPAGES;
#else
int	bufpages = 0;
#endif
int	bufcachepercent = BUFCACHEPERCENT;
@


1.498
log
@do not calculate bufpages; that is done later in MI bufinit().  in any
case, this MD calculation was overcommiting our use of pages...
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.497 2011/05/30 22:25:21 oga Exp $	*/
a418 1
	/*
@


1.497
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.496 2011/05/29 14:50:26 deraadt Exp $	*/
a419 6
	 * Determine how many buffers to allocate.  We use bufcachepercent%
	 * of the memory below 4GB.
	 */
	if (bufpages == 0)
		bufpages = atop(avail_end) * bufcachepercent / 100;

@


1.496
log
@Use k1x cpu scaling on all families 0x10 and above (the trend is likely to
continue); makes the AMD E-350 speed adjust (from slow to way slower).
discussion with jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.495 2011/05/23 09:54:20 claudio Exp $	*/
d3145 1
a3145 1
		uvm_page_physload(lim, kb, lim, kb, VM_FREELIST_FIRST16);
a3149 1
		paddr_t lim;
a3158 15
			if (a < atop(16 * 1024 * 1024)) {
				lim = MIN(atop(16 * 1024 * 1024), e);
#ifdef DEBUG
				printf(" %x-%x (<16M)", a, lim);
#endif
				uvm_page_physload(a, lim, a, lim,
				    VM_FREELIST_FIRST16);
				if (e > lim) {
#ifdef DEBUG
					printf(" %x-%x", lim, e);
#endif
					uvm_page_physload(lim, e, lim, e,
					    VM_FREELIST_DEFAULT);
				}
			} else {
d3162 1
a3162 3
				uvm_page_physload(a, e, a, e,
				    VM_FREELIST_DEFAULT);
			}
@


1.495
log
@AMD K10/K11 pstate driver allows setperf and apm to change CPU
frequencies on newer AMD systems.
Driver written by Bryan Steele / brynet gmail.com adjusted for i386
by myself. Put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.494 2011/04/30 15:33:18 mlarkin Exp $	*/
d1348 1
a1348 1
	if (ci->ci_family == 0x10 || ci->ci_family == 0x11)
@


1.494
log
@Preliminary plumbing code for i386 hibernate (suspend-to-disk).
This code is not yet called as there are still some important parts
not completed.

ok deraadt@@, kettenis@@ "looks reasonable"
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.493 2011/04/19 22:14:54 jsg Exp $	*/
d1348 2
@


1.493
log
@add some more intel cpuid models
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.492 2011/04/18 21:44:55 guenther Exp $	*/
d111 1
d210 1
a210 4
struct dumpmem {
	paddr_t	start;
	paddr_t	end;
} dumpmem[VM_PHYSSEG_MAX];
d3071 3
a3073 3
			/* skip first eight pages */
			if (a < 8 * NBPG)
				a = 8 * NBPG;
@


1.492
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.491 2011/04/16 00:40:58 deraadt Exp $	*/
d2109 1
d2112 7
@


1.491
log
@More than a decade ago, interrupt handlers on sparc started returning 0
(interrupt was not for me), 1 (positive interrupt was for me), or -1
(i am not sure...).  We have continued with this practice in as many
drivers as possible, throughout the tree.

This makes some of the architectures use that information in their
interrupt handler calling code -- if 1 is returned (and we know
this specific machine does not have edge-shared interrupts), we
finish servicing other possible handlers on the same pin.  If the
interrupt pin remains asserted (from a different device), we will
end up back in the interrupt servicing code of course... but this is
cheaper than calling all the chained interrupts on a pin.

This does of course count on shared level interrupts being properly
sorted by IPL.

There have been some concerns about starvation of drivers which
incorrectly return 1.  Those drivers should be hunted down so that
they return -1.

ok and help from various people.  In snaps for about a week now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.490 2011/04/15 04:52:39 guenther Exp $	*/
d2192 1
a2192 1
	int oonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d2202 1
a2202 1
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !oonstack &&
d2204 2
a2205 2
		sp = (long)p->p_sigstk.ss_sp + p->p_sigstk.ss_size;
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d2380 1
a2380 1
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d2382 1
a2382 1
		p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.490
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.489 2011/03/20 21:44:08 guenther Exp $	*/
d3781 6
@


1.489
log
@When reading MXCSR from userland sigcontext or a ptrace request,
mask out invalid bits to prevent a protect fault.

Original diff by joshe@@; further feedback and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.488 2011/03/12 03:52:26 guenther Exp $	*/
d2192 1
a2192 1
	int oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d2202 1
a2202 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
d2204 2
a2205 2
		sp = (long)psp->ps_sigstk.ss_sp + psp->ps_sigstk.ss_size;
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d2380 1
a2380 1
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
d2382 1
a2382 1
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.488
log
@Provide distinct segments for the %fs and %gs selectors to use by
default, with per-rthread base offsets and with sysarch() functions,
I386_{GET,SET}_{FS,GS}BASE, for fetching and setting those base
offsets.  This is necessary for both rthread and Linux compat support.

suggestions from kettenis@@, prodding from pirofti@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.487 2011/01/27 21:27:44 jsg Exp $	*/
d2370 3
a2372 2
		if ((error = copyin(context.sc_fpstate,
		    &p->p_addr->u_pcb.pcb_savefpu, sizeof (union savefpu))))
d2374 2
@


1.487
log
@Atom uses the same value for bus clock 200 MHz as Core, though
this is not documented by Intel.

tested by henning on d525
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.486 2010/12/29 18:10:17 kettenis Exp $	*/
d2285 2
a2286 2
	tf->tf_fs = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_gs = GSEL(GUDATA_SEL, SEL_UPL);
d2711 4
a2714 2
	 * this gets copied into the GDT and LDT for {G,L}UCODE_SEL by
	 * pmap_activate().
d2718 4
d2728 2
d2736 2
a2737 2
	tf->tf_fs = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_gs = GSEL(GUDATA_SEL, SEL_UPL);
d2939 4
@


1.486
log
@Bus clock doesn't matter on the Xeon 3600/5600 and Xeon 6500/7500, so don't
print the "can't get bus clock" message.  While there, adjust comments for
the i3/i5/i7 CPUs and include the relevant Xeon models.  The Intel marketing
people seem to have less influence on the Xeon names, so they describe the
CPU generation much better.

ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.485 2010/10/02 23:31:34 deraadt Exp $	*/
d2071 3
@


1.485
log
@turn off lid suspend if we doing halt -p
ok kettenis marco miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.484 2010/10/02 23:30:39 deraadt Exp $	*/
d2104 5
a2108 3
	case 0x1a: /* Core i7 */
	case 0x1e: /* Core i5 */
	case 0x25: /* Core i3 */
@


1.484
log
@unneccessary check before calling cpu_unidle; Vladimir Kirillov
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.483 2010/09/29 15:11:31 joshe Exp $	*/
d2406 3
@


1.483
log
@Back out previous, it appears to be broken.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.481 2010/08/05 21:10:09 deraadt Exp $	*/
d3306 1
a3306 2
		if (ci != curcpu())
			cpu_unidle(ci);
@


1.482
log
@When reading MXCSR from userland sigcontext, mask out invalid bits.

This prevents a protection fault if a userland signal handler
scribbles all over it's struct sigcontext

Help from and ok guenther@@ kettenis@@
@
text
@d2365 2
a2366 3
		union savefpu *sfp = &p->p_addr->u_pcb.pcb_savefpu;

		if ((error = copyin(context.sc_fpstate, sfp, sizeof(*sfp))))
a2367 2
		if (i386_use_fxsave)
			sfp->sv_xmm.sv_env.en_mxcsr &= fpu_mxcsr_mask;
@


1.481
log
@new i386/amd64 machdep.lidsuspend sysctl which decides whether a lid
close causes a suspend.  resumes are not tied to this; they happen
unconditionally.  this is a temporary knob for the 4.8 release; afterwards
it will move to a more convenient place
much moaning discussing where to put the knob with kettenis
tested by various including phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.480 2010/07/25 21:43:35 deraadt Exp $	*/
d2365 3
a2367 2
		if ((error = copyin(context.sc_fpstate,
		    &p->p_addr->u_pcb.pcb_savefpu, sizeof (union savefpu))))
d2369 2
@


1.480
log
@in the clock drivers, seperate the soft-state and hard-state which was
all jumbled up in the same functions. the rtc (mc chip) and clock (i8243)
startup was also mixed up.  they the soft state and hardware state can
be started in the right order, and it is easy to restart just the
neccessary parts upon resume.  tested in numerous cases:
(apic, pic) * (GENERIC.MP, GENERIC) * (mp, non-mp) * (i386, amd64)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.479 2010/07/23 14:56:31 kettenis Exp $	*/
d245 1
d3415 2
@


1.479
log
@Don't leak the contents of the FPU and SSE registers between processes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.478 2010/07/05 22:20:22 tedu Exp $	*/
d404 1
a404 1
	startrtclock();
d3294 1
a3294 6
	(*initclock_func)();

	if (initclock_func == i8254_initclocks)
		i8254_inittimecounter();
	else
		i8254_inittimecounter_simple();
@


1.478
log
@remove compat_bsdos support
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.477 2010/07/03 04:54:32 kettenis Exp $	*/
a2181 1
	union savefpu *sfp = &p->p_addr->u_pcb.pcb_savefpu;
a2214 5
		if (i386_use_fxsave) {
			sfp->sv_xmm.sv_env.en_cw = __OpenBSD_NPXCW__;
			sfp->sv_xmm.sv_env.en_mxcsr = __INITIAL_MXCSR__;
		} else
			sfp->sv_87.sv_env.en_cw = __OpenBSD_NPXCW__;
d2693 1
a2717 7

	p->p_md.md_flags &= ~MDP_USEDFPU;
	if (i386_use_fxsave) {
		pcb->pcb_savefpu.sv_xmm.sv_env.en_cw = __OpenBSD_NPXCW__;
		pcb->pcb_savefpu.sv_xmm.sv_env.en_mxcsr = __INITIAL_MXCSR__;
	} else
		pcb->pcb_savefpu.sv_87.sv_env.en_cw = __OpenBSD_NPXCW__;
@


1.477
log
@Make the kernel responsible for saving the FPU state before running
signal handlers.  Breaks ABI for applications that copy around struct
sigcontext to implement cooperative threading.  Other applications
shoouldn't notice the difference.

ok guenther@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.476 2010/07/01 23:05:50 kettenis Exp $	*/
a2933 6

	/* make ldt gates and memory segments */
#ifdef COMPAT_BSDOS
	setgate(&ldt[LBSDICALLS_SEL].gd, &IDTVEC(osyscall), 1, SDT_SYS386CGT,
	    SEL_UPL, GCODE_SEL);
#endif
@


1.476
log
@Make our trapframe squeeky clean in setregs().  Avoid leaking registers into
the new process image.

ok deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.475 2010/07/01 17:30:25 tedu Exp $	*/
a2180 1
	extern char sigcode, sigcode_xmm;
d2182 1
d2204 1
a2204 1
	frame.sf_fpstate = NULL;
d2206 1
d2209 12
a2220 1
		frame.sf_fpstate = (void *)sp;
a2290 2
	if (i386_use_fxsave)
		tf->tf_eip += &sigcode_xmm - &sigcode;
d2313 2
a2314 3
	struct trapframe *tf;

	tf = p->p_md.md_regs;
d2365 10
@


1.475
log
@another day, another compat gets removed.  today is ibcs2's turn
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.474 2010/06/27 03:03:48 thib Exp $	*/
d2716 2
d2720 3
@


1.474
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.472 2010/06/04 15:03:34 jsg Exp $	*/
a2911 4
#ifdef COMPAT_IBCS2
	setgate(&ldt[LSYS5CALLS_SEL].gd, &IDTVEC(osyscall), 1, SDT_SYS386CGT,
	    SEL_UPL, GCODE_SEL);
#endif
@


1.473
log
@Declare safepri at the MD level on each platform, so that the kern_synch.c
does not have to deal with it as a common.  Some platforms may be missed
by this commit... if you spot one, fix it the same way.
ok miod
@
text
@d198 8
@


1.472
log
@Don't warn about not knowing what the bus clock is on core i7/i5/i3
as the high/low guessing won't be done on these processors due to MSR
differences.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.471 2010/05/08 16:54:07 oga Exp $	*/
d238 6
d2199 1
a2199 1
		sp &= ~0xf;	/* foe XMM regs */
@


1.471
log
@Page Attribute Tables (PAT) support for x86.

PAT allows setting per-mapping cachability bits. Our main interest in it
for write combining mappings so we do not have to rely so heaviliy on
mtrrs (which are stupidly set up on more and more machines). MD flags to
pmap allow setting these bits (which bus_space now uses for PREFETCHABLE
maps), if a vm page has a bit set, then we will use WC for all mappings
of a page (used for userland mappings). We also check for known errata
and fall back to UC- mappings in that case.

comments from kettenis@@, tedu@@ and william@@. kettenis@@, tedu@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.470 2010/05/02 22:26:58 kettenis Exp $	*/
d2088 4
@


1.470
log
@The Cyrix "coma bug" workaround code has a really convoluted way to write 0
into a magic register.  Simplify the code by making this explicit, but keep
the dummy read just in case this has a magic side-effect.  And yes, as far as
I can tell, writing 0 is really what was intended here.  Makes gcc4 happy.
No binary change with gcc3.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.469 2010/03/21 23:00:57 jsg Exp $	*/
d1737 17
a1753 4
	if (vendor == CPUVENDOR_INTEL &&
	    curcpu()->ci_feature_flags & CPUID_CFLUSH) {
		/* to get the cachline size you must do cpuid with eax 0x01 */
		u_int regs[4];
d1755 3
a1757 2
		cpuid(0x01, regs); 
		ci->ci_cflushsz = ((regs[1] >> 8) & 0xff) * 8;
d3560 1
a3560 1
	u_long pa, endpa;
d3563 1
d3581 5
d3588 2
a3589 2
		pmap_kenter_pa(va, pa | ((flags & BUS_SPACE_MAP_CACHEABLE) ?
		    0 : PMAP_NOCACHE), VM_PROT_READ | VM_PROT_WRITE);
@


1.469
log
@Add some additional Intel CPUID values for recent and upcoming processors.
With some additions from sthen@@

ok kettenis@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.468 2009/12/09 14:27:34 oga Exp $	*/
d1242 1
a1242 1
		cyrix_write_reg(0x33, cyrix_read_reg(0x33) & ~0xff);
@


1.468
log
@Detect the cache line size for the clflush instruction when we identify
the cpu.

ok kettenis@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.467 2009/12/01 18:59:13 jsg Exp $	*/
d996 1
d1003 1
d1005 1
d1008 11
@


1.467
log
@Don't claim to know about nehalem until we can be sure
the the msr paths are sane.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.466 2009/11/26 08:45:12 nicm Exp $	*/
d1721 9
@


1.466
log
@Add an explicit check for supported models (10, 13, 15) before setting up the
Via CPU temperature sensor task, otherwise it is added for model 9 as well
which is not supported.

ok kevlo
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.465 2009/11/23 16:21:54 pirofti Exp $	*/
a2006 3
       case 0x1a: /* Nehalem based Core i7 and Xeon */
               bus_clock = BUS133;
               break;
@


1.465
log
@Remove ACPI_SLEEP_ENABLED checks.

This enables by default the suspend/resume paths in the kernel.

Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.464 2009/11/18 18:16:46 jsg Exp $	*/
d1084 9
a1092 7
		/* Setup the sensors structures */
		strlcpy(ci->ci_sensordev.xname, ci->ci_dev.dv_xname,
		    sizeof(ci->ci_sensordev.xname));
		ci->ci_sensor.type = SENSOR_TEMP;
		sensor_task_register(ci, via_update_sensor, 5);
		sensor_attach(&ci->ci_sensordev, &ci->ci_sensor);
		sensordev_install(&ci->ci_sensordev);
@


1.464
log
@Don't whinge about not knowing the bus_clock for EP80579 (model 0x15)
as there is no FSB and the processors don't have speedstep anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.463 2009/10/07 07:26:36 deraadt Exp $	*/
d3100 1
a3100 1
    (NACPI > 0 && defined(ACPI_SLEEP_ENABLED) && !defined(SMALL_KERNEL))
d3111 1
a3111 1
#if NACPI > 0 && defined(ACPI_SLEEP_ENABLED) && !defined(SMALL_KERNEL)
@


1.463
log
@This file is supposed to compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.462 2009/10/07 02:15:48 kevlo Exp $	*/
d1971 2
@


1.462
log
@add support for the temperature sensor of VIA Nano and C7-M CPUs.
some improvements suggested by jsg@@

"commit" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.461 2009/09/20 21:58:31 jsg Exp $	*/
d234 1
a1186 1
void	via_update_sensor(void *args);
@


1.461
log
@Back out via nano temperature sensor changes.
They break ramdisks as noticed by jasper, and have not been
adequately discussed.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.460 2009/09/20 15:37:23 kevlo Exp $	*/
d1078 14
d1184 25
@


1.460
log
@add support for VIA Nano cpu core temperature sensor

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.459 2009/08/11 18:46:32 miod Exp $	*/
a311 1
void	via_update_sensor(void *args);
a1166 9

		/* Setup the sensors structures */
		strlcpy(ci->ci_sensordev.xname, ci->ci_dev.dv_xname,
		    sizeof(ci->ci_sensordev.xname));
		ci->ci_sensor.type = SENSOR_TEMP;
		sensor_task_register(ci, via_update_sensor, 5);
		sensor_attach(&ci->ci_sensordev, &ci->ci_sensor);
		sensordev_install(&ci->ci_sensordev);

a1167 19
	}
}

void
via_update_sensor(void *args)
{
	struct cpu_info *ci = (struct cpu_info *) args;
	u_int64_t msr;

	if (ci->ci_model == 0xf) {
		msr = rdmsr(MSR_CENT_TMTEMPERATURE);
		ci->ci_sensor.value = (msr & 0xffffff);
		/* micro degrees */
		ci->ci_sensor.value *= 1000000;
		ci->ci_sensor.value += 273150000;
		ci->ci_sensor.flags &= ~SENSOR_FINVALID;
	} else {
		ci->ci_sensor.value = 0;
		ci->ci_sensor.flags |= SENSOR_FINVALID;
@


1.459
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.458 2009/08/11 17:15:54 oga Exp $	*/
d312 1
d1168 9
d1178 19
@


1.458
log
@fix some stupidity in x86 bus_space_map.

right now, we do a pmap_kenter_pa(), we then get the pte (behind pmap's
back) and check for the cache inhibit bit (if needed). If it isn't what
we want (this is the normal case) then we change it ourselves, and do a
manual tlb shootdown (i386 was a bit more stupid about it than amd64,
too).

Instead, make it so that like on some other archs (sparc64 comes to
mind) you can pass in flags in the low bits of the physical address,
pmap then does everything correctly for you.

Discovered this when I had some code doing a lot of bus_space_maps(), it
was incredibly slow, and profilling was dominated by
pmap_tlb_shootwait();

discussed with kettenis@@, miod@@, toby@@ and art@@.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.457 2009/08/10 16:40:50 oga Exp $	*/
a265 2
caddr_t	allocsys(caddr_t);
void	setup_buffers(void);
a370 2
	caddr_t v;
	int sz;
d406 2
a407 2
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
d409 2
a410 11
	sz = (int)allocsys((caddr_t)0);
	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");
	if (allocsys(v) - v != sz)
		panic("startup: table size inconsistency");

	/*
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
	 */
	setup_buffers();
a495 32


/*
 * Allocate space for system data structures.  We are given
 * a starting virtual address and we return a final virtual
 * address; along the way we set each data structure pointer.
 *
 * We call allocsys() with 0 to find out how much space we want,
 * allocate that much and fill it with zeroes, and then call
 * allocsys() again with the correct base virtual address.
 */
caddr_t
allocsys(caddr_t v)
{

#define	valloc(name, type, num) \
	    v = (caddr_t)(((name) = (type *)v) + (num))

	return v;
}

void
setup_buffers()
{
	/*
	 * Determine how many buffers to allocate.  We use bufcachepercent%
	 * of the memory below 4GB.
	 */
	if (bufpages == 0)
		bufpages = atop(avail_end) * bufcachepercent / 100;

}
@


1.457
log
@right now, we only increment ci_idepth in struct cpuinfo when
MULTIPROCESSOR is defined. This makes splassert incorrect for IPL_NONE
on such kernels.

Make this more similar to amd64, and move the inc and dec of ci_idepth
into the interrupt vectors, and only leave biglock in the locking
functions.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.456 2009/08/09 10:40:17 blambert Exp $	*/
a3529 1
	pt_entry_t *pte;
d3549 3
a3551 12
	    pa += PAGE_SIZE, va += PAGE_SIZE, map_size -= PAGE_SIZE) {
		pmap_kenter_pa(va, pa, VM_PROT_READ | VM_PROT_WRITE);

		pte = kvtopte(va);
		if (flags & BUS_SPACE_MAP_CACHEABLE)
			*pte &= ~PG_N;
		else
			*pte |= PG_N;
		pmap_tlb_shootpage(pmap_kernel(), va);
	}

	pmap_tlb_shootwait();
@


1.456
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.455 2009/08/02 16:28:39 beck Exp $	*/
a3691 2

	curcpu()->ci_idepth++;
a3696 2
	curcpu()->ci_idepth--;

a3704 1
	curcpu()->ci_idepth++;
a3709 1
	curcpu()->ci_idepth--;
@


1.455
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.454 2009/07/27 11:28:55 dms Exp $	*/
a93 3
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
a525 7

#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.454
log
@add bus speed recognition on Nehalem based cpus, this
makes Enhanced SpeedStep work on new machines, but requires
acpimadt0 to be enabled.

ok by jsg@@ and claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.453 2009/06/15 17:01:26 beck Exp $	*/
a549 5
	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4)
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.453
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.452 2009/06/03 21:30:19 beck Exp $	*/
d2024 3
@


1.452
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.451 2009/06/03 00:41:48 weingart Exp $	*/
d550 5
@


1.451
log
@Nuke CYRIX_CACHE (and related defines).  They've not been used in a long
time.  Beginning of refactoring cpu identification.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.450 2009/06/01 20:11:38 weingart Exp $	*/
a549 5
	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4)
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.450
log
@Move ibcs2_sendsig into compat.  Quit poluting machdep.

Ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.449 2009/05/19 01:31:15 weingart Exp $	*/
d1844 1
a1844 2
	if (cpu == CPU_486DLC) {
#ifndef CYRIX_CACHE_WORKS
a1845 8
#else
#ifndef CYRIX_CACHE_REALLY_WORKS
		printf("WARNING: CYRIX 486DLC CACHE ENABLED IN HOLD-FLUSH MODE.\n");
#else
		printf("WARNING: CYRIX 486DLC CACHE ENABLED.\n");
#endif
#endif
	}
@


1.449
log
@Seperate out BSDI and SYSV syscall gate setup, so if we don't
have one or the other option, we won't get said kernel entry
point.  Ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.448 2009/03/10 15:03:17 oga Exp $	*/
a2136 13

#ifdef COMPAT_IBCS2
void ibcs2_sendsig(sig_t, int, int, u_long, int, union sigval);

void
ibcs2_sendsig(sig_t catcher, int sig, int mask, u_long code, int type,
    union sigval val)
{
	extern int bsd_to_ibcs2_sig[];

	sendsig(catcher, bsd_to_ibcs2_sig[sig], mask, code, type, val);
}
#endif
@


1.448
log
@remove the _BUS_DMA_PRIVATE define from amd64 and i386.

a define needed to get to ``private'' functions that needs to be defined
5 or more times isn't much use and may cause namespace issues anyway.
Other archs will probably follow.

Discussed in portugal.  "Hell yes" weingart@@, ok kettenis@@, no
objections miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.447 2009/02/16 17:24:21 krw Exp $	*/
d2896 1
d2899 5
a2903 1
	ldt[LBSDICALLS_SEL] = ldt[LSYS5CALLS_SEL];
@


1.447
log
@Core i7 chips don't have MSR_TEMPERATURE_TARGET register, and blow up
if attempts are made to read it. So read MSR_TEMPERATURE_TARGET only
when ci_model == 0xe.

Found when my Core i7 box blew up. FreeBSD allows a few more chips
but this allows my box to boot.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.446 2009/02/16 15:44:25 jsg Exp $	*/
a107 1
#define _BUS_DMA_PRIVATE
@


1.446
log
@Store conditionally extended cpuid family/model values
in seperate variables in struct cpu_info instead
of duplicating the process of extracting it from the signature.

Use this value when determining the bus clock on P6/family 0x6
chips, which fixes speedstep on bernd@@'s ThinkPad x200s.

Discussed with several, 'just do it' weingart@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.445 2009/02/14 11:22:25 kettenis Exp $	*/
d1384 3
a1386 1
	if (rdmsr(MSR_TEMPERATURE_TARGET) & MSR_TEMPERATURE_TARGET_LOW_BIT)
@


1.445
log
@Don't call cpu_setup() twice on non-MULTIPROCESSOR kernels.  Fixes problems
with longrun on the Transmeta Crusoe.

tested by ian@@, grange@@
ok hshoexer@@, weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.444 2009/01/20 20:21:03 mlarkin Exp $	*/
d1631 1
d1633 1
d1690 10
d1979 1
a1979 1
	int model, bus;
d1981 1
a1981 2
	model = (ci->ci_signature >> 4) & 15;
	switch (model) {
d2003 2
d2032 1
a2032 1
	case 0xc: /* Atom */
d2078 2
a2079 2
		printf("%s: unknown i686 model %d, can't get bus clock",
		    ci->ci_dev.dv_xname, model);
@


1.444
log
@
Install ACPI S3 resume trampoline code in a lowmem page. First part
of ACPI S3 suspend/resume support. This is for i386.

Help/comments from art, toby, marco, jordan, kurt
ok marco@@, kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.443 2009/01/11 07:12:07 jsg Exp $	*/
a1815 6

#ifndef MULTIPROCESSOR
	/* configure the CPU if needed */
	if (ci->cpu_setup != NULL)
		(ci->cpu_setup)(ci);
#endif
@


1.443
log
@Add additional values for the Atom FSB_FREQ bus clock MSR now
Intel actually document it publically.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.442 2008/12/18 14:17:28 kurt Exp $	*/
d121 3
d3123 19
@


1.442
log
@Don't set the global bit PG_G for kernel pmap low memory mappings. Use a
new function pmap_prealloc_lowmem_ptp() to setup kernel pmap ptp 0 without
the PG_G bit set. This fixes the remaining reaper -> pmap_page_remove
panics. With much diagnostic help from Art and Theo.

ok  deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.441 2008/12/04 15:24:18 oga Exp $	*/
d2026 3
d2031 3
@


1.441
log
@Move the bus_dma generic functions out of the far-too-podgy machdep.c and
into bus_dma.c (a-la amd64).

Discussed with art and toby in coimbra. Ok mikeb.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.440 2008/12/03 15:46:06 oga Exp $	*/
d2964 2
a2965 6
	/* install the page after boot args as PT page for first 4M */
	pmap_enter(pmap_kernel(), (u_long)vtopte(0),
	   round_page((vaddr_t)(bootargv + bootargc)),
		VM_PROT_READ|VM_PROT_WRITE,
		VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
	memset(vtopte(0), 0, NBPG);  /* make sure it is clean before using */
@


1.440
log
@Remove the x86 and i386 prefixes to the bus_dma types. It's really quite
pointless and just makes the code different for no reason. This moves i386 and
amd64 bus_dma to being a lot closer to identical.

suggestion to just remove the prefix instead of merge them from deraadt@@.

no objections art@@, kettenis@@, ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.439 2008/11/22 18:12:32 art Exp $	*/
a276 2
int	_bus_dmamap_load_buffer(bus_dma_tag_t, bus_dmamap_t, void *,
    bus_size_t, struct proc *, int, paddr_t *, int *, int);
a3668 514
	return (0);
}

/*
 * Common function for DMA map creation.  May be called by bus-specific
 * DMA map creation functions.
 */
int
_bus_dmamap_create(bus_dma_tag_t t, bus_size_t size, int nsegments,
    bus_size_t maxsegsz, bus_size_t boundary, int flags, bus_dmamap_t *dmamp)
{
	struct bus_dmamap *map;
	void *mapstore;
	size_t mapsize;

	/*
	 * Allocate and initialize the DMA map.  The end of the map
	 * is a variable-sized array of segments, so we allocate enough
	 * room for them in one shot.
	 *
	 * Note we don't preserve the WAITOK or NOWAIT flags.  Preservation
	 * of ALLOCNOW notifies others that we've reserved these resources,
	 * and they are not to be freed.
	 *
	 * The bus_dmamap_t includes one bus_dma_segment_t, hence
	 * the (nsegments - 1).
	 */
	mapsize = sizeof(struct bus_dmamap) +
	    (sizeof(bus_dma_segment_t) * (nsegments - 1));
	if ((mapstore = malloc(mapsize, M_DEVBUF,
	    ((flags & BUS_DMA_NOWAIT) ? M_NOWAIT : M_WAITOK) | M_ZERO)) == NULL)
		return (ENOMEM);

	map = (struct bus_dmamap *)mapstore;
	map->_dm_size = size;
	map->_dm_segcnt = nsegments;
	map->_dm_maxsegsz = maxsegsz;
	map->_dm_boundary = boundary;
	map->_dm_flags = flags & ~(BUS_DMA_WAITOK|BUS_DMA_NOWAIT);
	map->dm_mapsize = 0;		/* no valid mappings */
	map->dm_nsegs = 0;

	*dmamp = map;
	return (0);
}

/*
 * Common function for DMA map destruction.  May be called by bus-specific
 * DMA map destruction functions.
 */
void
_bus_dmamap_destroy(bus_dma_tag_t t, bus_dmamap_t map)
{

	free(map, M_DEVBUF);
}

/*
 * Common function for loading a DMA map with a linear buffer.  May
 * be called by bus-specific DMA map load functions.
 */
int
_bus_dmamap_load(bus_dma_tag_t t, bus_dmamap_t map, void *buf,
    bus_size_t buflen, struct proc *p, int flags)
{
	bus_addr_t lastaddr = 0;
	int seg, error;

	/*
	 * Make sure that on error condition we return "no valid mappings".
	 */
	map->dm_mapsize = 0;
	map->dm_nsegs = 0;

	if (buflen > map->_dm_size)
		return (EINVAL);

	seg = 0;
	error = _bus_dmamap_load_buffer(t, map, buf, buflen, p, flags,
	    &lastaddr, &seg, 1);
	if (error == 0) {
		map->dm_mapsize = buflen;
		map->dm_nsegs = seg + 1;
	}
	return (error);
}

/*
 * Like _bus_dmamap_load(), but for mbufs.
 */
int
_bus_dmamap_load_mbuf(bus_dma_tag_t t, bus_dmamap_t map, struct mbuf *m0,
    int flags)
{
	paddr_t lastaddr = 0;
	int seg, error, first;
	struct mbuf *m;

	/*
	 * Make sure that on error condition we return "no valid mappings".
	 */
	map->dm_mapsize = 0;
	map->dm_nsegs = 0;

#ifdef DIAGNOSTIC
	if ((m0->m_flags & M_PKTHDR) == 0)
		panic("_bus_dmamap_load_mbuf: no packet header");
#endif

	if (m0->m_pkthdr.len > map->_dm_size)
		return (EINVAL);

	first = 1;
	seg = 0;
	error = 0;
	for (m = m0; m != NULL && error == 0; m = m->m_next) {
		if (m->m_len == 0)
			continue;
		error = _bus_dmamap_load_buffer(t, map, m->m_data, m->m_len,
		    NULL, flags, &lastaddr, &seg, first);
		first = 0;
	}
	if (error == 0) {
		map->dm_mapsize = m0->m_pkthdr.len;
		map->dm_nsegs = seg + 1;
	}
	return (error);
}

/*
 * Like _bus_dmamap_load(), but for uios.
 */
int
_bus_dmamap_load_uio(bus_dma_tag_t t, bus_dmamap_t map, struct uio *uio,
    int flags)
{
	paddr_t lastaddr = 0;
	int seg, i, error, first;
	bus_size_t minlen, resid;
	struct proc *p = NULL;
	struct iovec *iov;
	caddr_t addr;

	/*
	 * Make sure that on error condition we return "no valid mappings".
	 */
	map->dm_mapsize = 0;
	map->dm_nsegs = 0;

	resid = uio->uio_resid;
	iov = uio->uio_iov;

	if (resid > map->_dm_size)
		return (EINVAL);

	if (uio->uio_segflg == UIO_USERSPACE) {
		p = uio->uio_procp;
#ifdef DIAGNOSTIC
		if (p == NULL)
			panic("_bus_dmamap_load_uio: USERSPACE but no proc");
#endif
	}

	first = 1;
	seg = 0;
	error = 0;
	for (i = 0; i < uio->uio_iovcnt && resid != 0 && error == 0; i++) {
		/*
		 * Now at the first iovec to load.  Load each iovec
		 * until we have exhausted the residual count.
		 */
		minlen = resid < iov[i].iov_len ? resid : iov[i].iov_len;
		addr = (caddr_t)iov[i].iov_base;

		error = _bus_dmamap_load_buffer(t, map, addr, minlen,
		    p, flags, &lastaddr, &seg, first);
		first = 0;

		resid -= minlen;
	}
	if (error == 0) {
		map->dm_mapsize = uio->uio_resid;
		map->dm_nsegs = seg + 1;
	}
	return (error);
}

/*
 * Like _bus_dmamap_load(), but for raw memory allocated with
 * bus_dmamem_alloc().
 */
int
_bus_dmamap_load_raw(bus_dma_tag_t t, bus_dmamap_t map, bus_dma_segment_t *segs,
    int nsegs, bus_size_t size, int flags)
{
	if (nsegs > map->_dm_segcnt || size > map->_dm_size)
		return (EINVAL);

	/*
	 * Make sure we don't cross any boundaries.
	 */
	if (map->_dm_boundary) {
		bus_addr_t bmask = ~(map->_dm_boundary - 1);
		int i;

		for (i = 0; i < nsegs; i++) {
			if (segs[i].ds_len > map->_dm_maxsegsz)
				return (EINVAL);
			if ((segs[i].ds_addr & bmask) !=
			    ((segs[i].ds_addr + segs[i].ds_len - 1) & bmask))
				return (EINVAL);
		}
	}

	bcopy(segs, map->dm_segs, nsegs * sizeof(*segs));
	map->dm_nsegs = nsegs;
	return (0);
}

/*
 * Common function for unloading a DMA map.  May be called by
 * bus-specific DMA map unload functions.
 */
void
_bus_dmamap_unload(bus_dma_tag_t t, bus_dmamap_t map)
{

	/*
	 * No resources to free; just mark the mappings as
	 * invalid.
	 */
	map->dm_mapsize = 0;
	map->dm_nsegs = 0;
}

/*
 * Common function for DMA-safe memory allocation.  May be called
 * by bus-specific DMA memory allocation functions.
 */
int
_bus_dmamem_alloc(bus_dma_tag_t t, bus_size_t size, bus_size_t alignment,
    bus_size_t boundary, bus_dma_segment_t *segs, int nsegs, int *rsegs,
    int flags)
{

	return (_bus_dmamem_alloc_range(t, size, alignment, boundary,
	    segs, nsegs, rsegs, flags, 0, trunc_page(avail_end)));
}

/*
 * Common function for freeing DMA-safe memory.  May be called by
 * bus-specific DMA memory free functions.
 */
void
_bus_dmamem_free(bus_dma_tag_t t, bus_dma_segment_t *segs, int nsegs)
{
	struct vm_page *m;
	bus_addr_t addr;
	struct pglist mlist;
	int curseg;

	/*
	 * Build a list of pages to free back to the VM system.
	 */
	TAILQ_INIT(&mlist);
	for (curseg = 0; curseg < nsegs; curseg++) {
		for (addr = segs[curseg].ds_addr;
		    addr < (segs[curseg].ds_addr + segs[curseg].ds_len);
		    addr += PAGE_SIZE) {
			m = PHYS_TO_VM_PAGE(addr);
			TAILQ_INSERT_TAIL(&mlist, m, pageq);
		}
	}

	uvm_pglistfree(&mlist);
}

/*
 * Common function for mapping DMA-safe memory.  May be called by
 * bus-specific DMA memory map functions.
 */
int
_bus_dmamem_map(bus_dma_tag_t t, bus_dma_segment_t *segs, int nsegs,
    size_t size, caddr_t *kvap, int flags)
{
	vaddr_t va;
	bus_addr_t addr;
	int curseg;

	size = round_page(size);
	va = uvm_km_valloc(kernel_map, size);
	if (va == 0)
		return (ENOMEM);

	*kvap = (caddr_t)va;

	for (curseg = 0; curseg < nsegs; curseg++) {
		for (addr = segs[curseg].ds_addr;
		    addr < (segs[curseg].ds_addr + segs[curseg].ds_len);
		    addr += PAGE_SIZE, va += PAGE_SIZE, size -= PAGE_SIZE) {
			if (size == 0)
				panic("_bus_dmamem_map: size botch");
			pmap_enter(pmap_kernel(), va, addr,
			    VM_PROT_READ | VM_PROT_WRITE,
			    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
		}
	}
	pmap_update(pmap_kernel());

	return (0);
}

/*
 * Common function for unmapping DMA-safe memory.  May be called by
 * bus-specific DMA memory unmapping functions.
 */
void
_bus_dmamem_unmap(bus_dma_tag_t t, caddr_t kva, size_t size)
{

#ifdef DIAGNOSTIC
	if ((u_long)kva & PGOFSET)
		panic("_bus_dmamem_unmap");
#endif

	size = round_page(size);
	uvm_km_free(kernel_map, (vaddr_t)kva, size);
}

/*
 * Common function for mmap(2)'ing DMA-safe memory.  May be called by
 * bus-specific DMA mmap(2)'ing functions.
 */
paddr_t
_bus_dmamem_mmap(bus_dma_tag_t t, bus_dma_segment_t *segs, int nsegs, off_t off,
    int prot, int flags)
{
	int i;

	for (i = 0; i < nsegs; i++) {
#ifdef DIAGNOSTIC
		if (off & PGOFSET)
			panic("_bus_dmamem_mmap: offset unaligned");
		if (segs[i].ds_addr & PGOFSET)
			panic("_bus_dmamem_mmap: segment unaligned");
		if (segs[i].ds_len & PGOFSET)
			panic("_bus_dmamem_mmap: segment size not multiple"
			    " of page size");
#endif
		if (off >= segs[i].ds_len) {
			off -= segs[i].ds_len;
			continue;
		}

		return (atop(segs[i].ds_addr + off));
	}

	/* Page not found. */
	return (-1);
}

/**********************************************************************
 * DMA utility functions
 **********************************************************************/
/*
 * Utility function to load a linear buffer.  lastaddrp holds state
 * between invocations (for multiple-buffer loads).  segp contains
 * the starting segment on entrance, and the ending segment on exit.
 * first indicates if this is the first invocation of this function.
 */
int
_bus_dmamap_load_buffer(bus_dma_tag_t t, bus_dmamap_t map, void *buf,
    bus_size_t buflen, struct proc *p, int flags, paddr_t *lastaddrp, int *segp,
    int first)
{
	bus_size_t sgsize;
	bus_addr_t curaddr, lastaddr, baddr, bmask;
	vaddr_t vaddr = (vaddr_t)buf;
	int seg;
	pmap_t pmap;

	if (p != NULL)
		pmap = p->p_vmspace->vm_map.pmap;
	else
		pmap = pmap_kernel();

	lastaddr = *lastaddrp;
	bmask  = ~(map->_dm_boundary - 1);

	for (seg = *segp; buflen > 0 ; ) {
		/*
		 * Get the physical address for this segment.
		 */
		pmap_extract(pmap, vaddr, (paddr_t *)&curaddr);

		/*
		 * Compute the segment size, and adjust counts.
		 */
		sgsize = PAGE_SIZE - ((u_long)vaddr & PGOFSET);
		if (buflen < sgsize)
			sgsize = buflen;

		/*
		 * Make sure we don't cross any boundaries.
		 */
		if (map->_dm_boundary > 0) {
			baddr = (curaddr + map->_dm_boundary) & bmask;
			if (sgsize > (baddr - curaddr))
				sgsize = (baddr - curaddr);
		}

		/*
		 * Insert chunk into a segment, coalescing with
		 * previous segment if possible.
		 */
		if (first) {
			map->dm_segs[seg].ds_addr = curaddr;
			map->dm_segs[seg].ds_len = sgsize;
			first = 0;
		} else {
			if (curaddr == lastaddr &&
			    (map->dm_segs[seg].ds_len + sgsize) <=
			     map->_dm_maxsegsz &&
			    (map->_dm_boundary == 0 ||
			     (map->dm_segs[seg].ds_addr & bmask) ==
			     (curaddr & bmask)))
				map->dm_segs[seg].ds_len += sgsize;
			else {
				if (++seg >= map->_dm_segcnt)
					break;
				map->dm_segs[seg].ds_addr = curaddr;
				map->dm_segs[seg].ds_len = sgsize;
			}
		}

		lastaddr = curaddr + sgsize;
		vaddr += sgsize;
		buflen -= sgsize;
	}

	*segp = seg;
	*lastaddrp = lastaddr;

	/*
	 * Did we fit?
	 */
	if (buflen != 0)
		return (EFBIG);		/* XXX better return value here? */
	return (0);
}

/*
 * Allocate physical memory from the given physical address range.
 * Called by DMA-safe memory allocation methods.
 */
int
_bus_dmamem_alloc_range(bus_dma_tag_t t, bus_size_t size, bus_size_t alignment,
    bus_size_t boundary, bus_dma_segment_t *segs, int nsegs, int *rsegs,
    int flags, paddr_t low, paddr_t high)
{
	paddr_t curaddr, lastaddr;
	struct vm_page *m;
	struct pglist mlist;
	int curseg, error;

	/* Always round the size. */
	size = round_page(size);

	TAILQ_INIT(&mlist);
	/*
	 * Allocate pages from the VM system.
	 * For non-ISA mappings first try higher memory segments.
	 */
	if (high <= ISA_DMA_BOUNCE_THRESHOLD || (error = uvm_pglistalloc(size,
	    round_page(ISA_DMA_BOUNCE_THRESHOLD), high, alignment, boundary,
	    &mlist, nsegs, (flags & BUS_DMA_NOWAIT) == 0)))
		error = uvm_pglistalloc(size, low, high, alignment, boundary,
		    &mlist, nsegs, (flags & BUS_DMA_NOWAIT) == 0);
	if (error)
		return (error);

	/*
	 * Compute the location, size, and number of segments actually
	 * returned by the VM code.
	 */
	m = TAILQ_FIRST(&mlist);
	curseg = 0;
	lastaddr = segs[curseg].ds_addr = VM_PAGE_TO_PHYS(m);
	segs[curseg].ds_len = PAGE_SIZE;

	for (m = TAILQ_NEXT(m, pageq); m != NULL; m = TAILQ_NEXT(m, pageq)) {
		curaddr = VM_PAGE_TO_PHYS(m);
#ifdef DIAGNOSTIC
		if (curseg == nsegs) {
			printf("uvm_pglistalloc returned too many\n");
			panic("_bus_dmamem_alloc_range");
		}
		if (curaddr < low || curaddr >= high) {
			printf("uvm_pglistalloc returned non-sensical"
			    " address 0x%lx\n", curaddr);
			panic("_bus_dmamem_alloc_range");
		}
#endif
		if (curaddr == (lastaddr + PAGE_SIZE))
			segs[curseg].ds_len += PAGE_SIZE;
		else {
			curseg++;
			segs[curseg].ds_addr = curaddr;
			segs[curseg].ds_len = PAGE_SIZE;
		}
		lastaddr = curaddr;
	}
	*rsegs = curseg + 1;

@


1.439
log
@The last parts of cpu_unidle. i386, amd64 and sparc64
In short, make cpu_unidle do what signotify used to do and
make signotify use cpu_unidle.
Also, include a cpu_unidle in need_resched, it won't change much right now
but will be needed in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.438 2008/11/14 20:43:54 weingart Exp $	*/
d108 1
a108 1
#define _I386_BUS_DMA_PRIVATE
d3682 1
a3682 1
	struct i386_bus_dmamap *map;
d3698 1
a3698 1
	mapsize = sizeof(struct i386_bus_dmamap) +
d3704 1
a3704 1
	map = (struct i386_bus_dmamap *)mapstore;
@


1.438
log
@Garbage collect the LDT segments, and simply use the GDT segments.
The beginning of i386 segment review/cleanup.

Tested by various people.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.437 2008/10/09 19:04:18 kettenis Exp $	*/
d2343 3
d2347 6
a2352 2
	if (p->p_cpu != curcpu() && p->p_cpu != NULL)
		i386_send_ipi(p->p_cpu, I386_IPI_NOP);
a2353 1
}
a3251 2
	struct proc *p;

d3254 6
a3259 6
	/*
	 * Need to catch the curproc in case it's cleared just
	 * between the check and the aston().
	 */
	if ((p = ci->ci_curproc) != NULL)
		aston(p);
@


1.437
log
@Skip memory areas smaller than 1 MB above the 16 MB boundary to deal with
buggy ACP BIOSes.  Based on a diff from weingart@@.

ok deraadt@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.436 2008/10/06 19:46:21 kettenis Exp $	*/
d2658 1
a2658 1
	 * And update the GDT and LDT since we return to the user process
d2661 1
a2661 2
	curcpu()->ci_gdt[GUCODE_SEL].sd = pcb->pcb_ldt[LUCODE_SEL].sd =
	    pmap->pm_codeseg;
d2675 4
a2678 4
	tf->tf_fs = LSEL(LUDATA_SEL, SEL_UPL);
	tf->tf_gs = LSEL(LUDATA_SEL, SEL_UPL);
	tf->tf_es = LSEL(LUDATA_SEL, SEL_UPL);
	tf->tf_ds = LSEL(LUDATA_SEL, SEL_UPL);
d2682 1
a2682 1
	tf->tf_cs = LSEL(LUCODE_SEL, SEL_UPL);
d2685 1
a2685 1
	tf->tf_ss = LSEL(LUDATA_SEL, SEL_UPL);
a2876 2
	ldt[LUCODE_SEL] = gdt[GUCODE_SEL];
	ldt[LUDATA_SEL] = gdt[GUDATA_SEL];
@


1.436
log
@Unconditionally compile idt_vec_xxx functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.435 2008/07/11 03:03:07 dlg Exp $	*/
d3008 2
a3009 2
			/* skip regions which are zero or negative in size */
			if (a >= e) {
d3017 7
a3023 4
			 * XXX - This is a hack to work around BIOS bugs and
			 * a bug in the  msgbuf allocation.  We skip regions
			 * smaller than the message buffer or 16-bit segment
			 * limit in size.
d3025 1
a3025 1
			if ((e - a) < max((MSGBUFSIZE / NBPG), (64 * 1024))) {
@


1.435
log
@initialise the state kept between calls to dmamap_load_buffer to 0. there
was an extremely small chance that random stack garbage coudl be used which
could corrupt a dmamap.

this is the same as the change made to amd64 in
src/sys/arch/amd64/amd64/bus_dma.c r1.10.

ok miod@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.433 2008/06/27 17:22:14 miod Exp $	*/
a3257 1
#ifdef MULTIPROCESSOR
a3283 1
#endif	/* MULTIPROCESSOR */
@


1.434
log
@Add an entry to report the bus clock on bernd's atom laptop.
Intel don't publish the EST voltage tables, and they don't
even publish the MSRs for a shipping processor so we
can figure out how to do this in the backwards highest/lowest
way cleanly.

The mapping might look like the Core * one, but who really knows
for sure outside of a few guys at Intel.  Other machines with
Atom processors and a different bus clock will have to be added
one by one until this stupidity changes.

Tested by bernd, ok gwk
@
text
@d3734 1
a3734 1
	bus_addr_t lastaddr;
d3763 1
a3763 1
	paddr_t lastaddr;
d3805 1
a3805 1
	paddr_t lastaddr;
@


1.433
log
@Clear swap encryption keys before dumping a kernel image.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.432 2008/06/26 05:42:10 ray Exp $	*/
d2020 13
@


1.432
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.431 2008/06/13 00:00:45 jsg Exp $	*/
d106 1
d2547 4
@


1.431
log
@Detect if Intel's Safer Mode Extensions (SMX) are present,
See http://download.intel.com/technology/security/downloads/31516804.pdf
for more information.

ok deraadt@@ 'looks ok to me' djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.430 2008/06/08 20:57:18 miod Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.430
log
@Make sure to cnpollc(1)/cnpollc(0) around cngetc() or getsn() calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.429 2008/05/30 23:10:16 fgsch Exp $	*/
d1064 1
@


1.429
log
@Remove the untracked mapping before calling uvm_km_free(), otherwise the
code will treat it as a tracked one and panic down the road.
fixes one of the crashes reported in PR/5828. miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.428 2008/05/21 18:49:47 kettenis Exp $	*/
d3047 1
d3049 1
@


1.428
log
@Switch i386 from pccom to com.  Welcomed by many.

ok dlg@@, jsing@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.427 2008/05/07 20:42:02 kettenis Exp $	*/
d3580 3
d3626 3
@


1.427
log
@Move i386 to __HAVE_GENERIC_SOFT_INTERRUPTS

ok dlg@@, tested by dlg@@, oga@@, jsg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.426 2008/04/25 19:50:07 kettenis Exp $	*/
a165 1
#include "pccom.h"
d167 1
a167 1
#if (NCOM > 0 || NPCCOM > 0)
a169 1
#if NCOM > 0
d171 1
a171 4
#elif NPCCOM > 0
#include <arch/i386/isa/pccomvar.h>
#endif
#endif /* NCOM > 0 || NPCCOM > 0 */
a287 3
#ifdef __i386__
#define KGDB_DEVNAME "pccom"
#else
a288 1
#endif
d291 1
a291 1
#if (NCOM > 0 || NPCCOM > 0)
d304 1
a304 1
#endif /* NCOM  || NPCCOM */
d2906 4
a2909 2
	consinit();	/* XXX SHOULD NOT BE DONE HERE */
			/* XXX here, until we can use bios for printfs */
a3154 2
 * XXX - shouldn't deal with this initted thing, but then,
 * it shouldn't be called from init386 either.
d3159 1
a3159 6
	static int initted;

	if (initted)
		return;
	initted = 1;
	cninit();
d3167 2
a3168 2
#if (NCOM > 0 || NPCCOM > 0)
	if (!strcmp(kgdb_devname, "com") || !strcmp(kgdb_devname, "pccom")) {
@


1.426
log
@Make ipending per-cpu.  Should fix PR 5788.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.425 2008/04/20 16:11:13 kettenis Exp $	*/
d3142 2
d4231 1
a4231 1
softintr(int sir, int vec)
d4235 2
a4236 5
	__asm __volatile("orl %1, %0" : "=m" (ci->ci_ipending) : "ir" (sir));
#ifdef MULTIPROCESSOR
	i82489_writereg(LAPIC_ICRLO,
	    vec | LAPIC_DLMODE_FIXED | LAPIC_LVL_ASSERT | LAPIC_DEST_SELF);
#endif
@


1.425
log
@Call cnpollc() before cngetc() upon halt.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.424 2008/04/18 20:20:35 kettenis Exp $	*/
d4231 3
a4233 1
	__asm __volatile("orl %1, %0" : "=m" (ipending) : "ir" (sir));
@


1.424
log
@Now that i386 has a per-process astpending, we can garbage collect ipi_ast
and do an ipi_nop cross-call from signotify() instead.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.423 2008/04/18 18:54:39 kettenis Exp $	*/
d2452 1
d2454 1
@


1.423
log
@Halt CPUs upon reboot/halt.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.422 2008/04/12 12:49:28 kettenis Exp $	*/
a2137 23
 * To send an AST to a process on another cpu we send an IPI to that cpu,
 * the IPI schedules a special soft interrupt (that does nothing) and then
 * returns through the normal interrupt return path which in turn handles
 * the AST.
 *
 * The IPI can't handle the AST because it usually requires grabbing the
 * biglock and we can't afford spinning in the IPI handler with interrupts
 * unlocked (so that we take further IPIs and grow our stack until it
 * overflows).
 */
void
aston(struct proc *p)
{
#ifdef MULTIPROCESSOR
	if (i386_atomic_testset_i(&p->p_md.md_astpending, 1) == 0 &&
	    p->p_cpu != curcpu())
		i386_fast_ipi(p->p_cpu, LAPIC_IPI_AST);
#else
	p->p_md.md_astpending = 1;
#endif
}

/*
d2334 14
@


1.422
log
@Get rid of acpi_s5 global variables; simply send SIGUSR2 instead of SUGUSR1
to tell init(8) to power down the machine.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.421 2008/04/09 16:58:10 deraadt Exp $	*/
d2407 4
@


1.421
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.421 2008/04/09 16:50:28 deraadt Exp $	*/
d2410 1
a2410 1
		extern int acpi_s5, acpi_enabled;
d2414 1
a2414 1
			if ((howto & RB_POWERDOWN) || acpi_s5)
@


1.420
log
@Fix #ifdef NCOM collateral damage introduced in r1.210.

ok miod@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.419 2008/03/17 23:17:22 deraadt Exp $	*/
d2398 2
a2399 2
	/* Disable interrupts. */
	splhigh();
@


1.419
log
@Clear PSL_D when entering signal handlers; pointed out by dfly people;
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.418 2008/02/18 16:31:55 kettenis Exp $	*/
d168 1
a168 1
#if NPCCOM > 0
@


1.418
log
@Fix ptoa() cast.

Sigh... ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.417 2008/01/25 19:48:15 weingart Exp $	*/
d2274 1
a2274 1
	tf->tf_eflags &= ~(PSL_T|PSL_VM|PSL_AC);
@


1.417
log
@Add support for some other CPU's.  Thank you to
jahrens at centtech for the information.

ok otto@@, hshoexer@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.416 2008/01/15 22:22:26 weingart Exp $	*/
d423 3
a425 2
	printf("real mem  = %llu (%lluMB)\n", ptoa((unsigned long long)physmem),
	    ptoa((unsigned long long)physmem)/1024U/1024U);
d458 2
a459 2
	    ptoa((unsigned long long)uvmexp.free),
	    ptoa((unsigned long long)uvmexp.free)/1024U/1024U);
@


1.416
log
@Work around an intel BIOS bug where it locates the ACPI tables in
a region of memory marked free for use by the OS.

Ok beck@@, kettenis@@, and --ok && ++!!ok tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.415 2008/01/13 14:03:21 mikeb Exp $	*/
d1128 5
d1149 1
a1149 1
		 * C3 Nehemiah: fall through.
d1151 1
a1151 1
	case 10:
d1153 1
a1153 1
		 * C3 Nehemiah/Esther:
@


1.415
log
@Fix build with DEBUG defined.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.414 2007/11/28 17:17:18 tedu Exp $	*/
d3000 2
a3001 2
			/* skip shorter than page regions */
			if (a >= e || (e - a) < NBPG) {
d3007 15
@


1.414
log
@doh!
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.413 2007/11/28 17:05:09 tedu Exp $	*/
d3066 1
a3066 1
-				printf(" %x-%x (<16M)", a, lim);
d3072 1
a3072 1
-					printf(" %x-%x", lim, e);
d3079 1
a3079 1
-				printf(" %x-%x", a, e);
@


1.413
log
@quite a bit of simplification by removing cpu classes.
also assume that 386 cpus are really unknown, and promote them to 486
instead of panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.412 2007/11/25 10:50:13 tom Exp $	*/
d1105 1
@


1.412
log
@Add entries for the Transmeta Efficeon CPU to the CPUID table.
Without this we think it's an 80386-compatible, which is no longer
supported.

Problem found, and solution tested, by Anders Langworthy (anders
(at) psilanthropy (dot) org); thanks.  Initial suggestion for fix by
Travers Buda (traversbuda (at) gmail (dot) com).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.411 2007/11/12 01:17:41 pascoe Exp $	*/
d242 1
a242 1
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
a1081 1
#if defined(I586_CPU)
a1090 1
#endif
d1093 1
a1093 1
#if defined(I686_CPU) && !defined(SMALL_KERNEL)
a1104 1
#endif
a1108 1
#if defined(I686_CPU)
a1235 1
#endif
a1273 1
#if defined(I586_CPU) || defined(I686_CPU)
a1283 1
#endif
a1288 1
#if defined(I586_CPU)
a1293 1
#endif
d1296 1
a1296 1
#if !defined(SMALL_KERNEL) && defined(I586_CPU)
d1326 1
a1326 1
#if !defined(SMALL_KERNEL) && defined(I586_CPU)
d1333 1
a1333 1
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
d1348 1
a1348 1
#endif /* !SMALL_KERNEL && I686_CPU */
d1353 1
a1353 1
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
d1372 1
a1372 1
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
d1430 1
a1430 1
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
d1453 1
a1453 1
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
d1481 1
a1481 1
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
d1508 1
a1508 1
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
d1517 1
a1517 1
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
d1523 1
a1523 1
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
d1532 1
a1532 1
#if !defined(SMALL_KERNEL) && (defined(I586_CPU) || defined(I686_CPU))
a1771 1
#if defined(I586_CPU) || defined(I686_CPU)
a1791 1
#endif
a1829 1
#if defined(I586_CPU) || defined(I686_CPU)
a1832 1
#endif
d1836 2
a1837 22
	/*
	 * Now that we have told the user what they have,
	 * let them know if that machine type isn't configured.
	 */
	switch (cpu_class) {
#if !defined(I486_CPU) && !defined(I586_CPU) && !defined(I686_CPU)
#error No CPU classes configured.
#endif
#ifndef I686_CPU
	case CPUCLASS_686:
		printf("NOTICE: this kernel does not support Pentium Pro CPU class\n");
#ifdef I586_CPU
		printf("NOTICE: lowering CPU class to i586\n");
		cpu_class = CPUCLASS_586;
		break;
#endif
#endif
#ifndef I586_CPU
	case CPUCLASS_586:
		printf("NOTICE: this kernel does not support Pentium CPU class\n");
#ifdef I486_CPU
		printf("NOTICE: lowering CPU class to i486\n");
a1838 12
		break;
#endif
#endif
#ifndef I486_CPU
	case CPUCLASS_486:
		printf("NOTICE: this kernel does not support i486 CPU class\n");
#endif
	case CPUCLASS_386:
		printf("NOTICE: this kernel does not support i386 CPU class\n");
		panic("no appropriate CPU class available");
	default:
		break;
a1860 1
#if defined(I686_CPU)
a1881 1
#endif /* I686_CPU */
a1903 1
#ifdef I686_CPU
a2107 1
#endif	/* I686_CPU */
a2108 1
#if defined(I586_CPU) || defined(I686_CPU)
a2114 1
#endif
a2166 1
#ifdef I686_CPU
a2167 1
#endif
a2264 1
#ifdef I686_CPU
a2266 1
#endif
a2753 1
#if defined(I586_CPU)
a2788 1
#endif
@


1.411
log
@Select the right GDT entry for interrupt handlers on i386 systems when
using ioapics, so that interrupt time is accounted correctly.  This
fixes the problem that 0% interrupt time is always shown when running MP.

ok dlg@@, suspect this is correct art@@, just an oversight niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.410 2007/11/03 03:37:08 weingart Exp $	*/
d934 45
d1541 1
a1541 1
#if !defined(SMALL_KERNEL) && defined(I586_CPU)
@


1.410
log
@APM switchto cleanup diff.  This uses the switchto functionality to
significantly clean up the APM idle loop things.  I actually can make
sense of what the APM idle loop is supposed to do.

Ok gwk@@, beck@@, and theo says ramdisks compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.409 2007/10/31 15:55:44 deraadt Exp $	*/
d3268 1
a3268 1
	setgate(&idt[vec], function, 0, SDT_SYS386IGT, SEL_KPL, GCODE_SEL);
@


1.409
log
@for now, workaround MP timeout/splhigh/scsi race at reboot time using a
delay.  will be revisited.  ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.408 2007/09/30 17:50:20 gwk Exp $	*/
d180 7
@


1.408
log
@On i386, only call amd64_errata() on amd64 processors (family 0xf),
tested by krw@@. This diff by itself is insufficient to ensure that
we are only running on an amd64: todd@@'s machine is a mobile Athlon XP
that has a cpuid family of 0xf but is not an amd64 processor so more
must be done but this should prevent the vast majority of cases.

ok tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.407 2007/09/07 15:00:19 art Exp $	*/
d2391 2
@


1.407
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.406 2007/09/03 01:09:09 krw Exp $	*/
d1311 1
d1322 4
a1875 2
	if (vendor == CPUVENDOR_AMD)
		amd64_errata(ci);
@


1.406
log
@Typos from miod. 'functin' -> 'functin' in some comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.405 2007/09/01 15:14:44 martin Exp $	*/
d3672 1
a3672 1
	    (flags & BUS_DMA_NOWAIT) ? M_NOWAIT : M_WAITOK)) == NULL)
a3674 1
	bzero(mapstore, mapsize);
@


1.405
log
@replace the machine dependant bytes-to-clicks macro by the MI ptoa()
version for i386

more architectures and ctob() replacement is being worked on

prodded by and ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.404 2007/08/22 21:28:41 marco Exp $	*/
d3973 1
a3973 1
 * Common functin for mmap(2)'ing DMA-safe memory.  May be called by
@


1.404
log
@Add bus_space_vaddr to i386 arch.

Comments and ok kettenis, art & miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.403 2007/07/20 17:04:14 mk Exp $	*/
d395 1
a395 1
	for (i = 0; i < btoc(MSGBUFSIZE); i++) {
d416 2
a417 2
	printf("real mem  = %llu (%lluMB)\n", ctob((unsigned long long)physmem),
	    ctob((unsigned long long)physmem)/1024U/1024U);
d555 1
a555 1
		bufpages = btoc(avail_end) * bufcachepercent / 100;
d2574 1
a2574 1
		maddr = ctob(dumpmem[i].start);
d2584 1
a2584 1
				    (ctob(dumpsize) - maddr) / (1024 * 1024));
@


1.403
log
@Oh, look, code that begins like this:

	if (cpu_class != CPUCLASS_386) {

Since we don't support 386 now, unconditionally execute the block.

ok tom toby
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.402 2007/06/07 11:20:58 dim Exp $	*/
d3350 1
a3350 1
bus_space_map(bus_space_tag_t t, bus_addr_t bpa, bus_size_t size, int cacheable,
d3362 2
d3400 1
a3400 1
	error = bus_mem_add_mapping(bpa, size, cacheable, bshp);
d3415 1
a3415 1
    int cacheable, bus_space_handle_t *bshp)
d3429 1
a3429 1
	return (bus_mem_add_mapping(bpa, size, cacheable, bshp));
d3435 1
a3435 1
    int cacheable, bus_addr_t *bpap, bus_space_handle_t *bshp)
d3485 1
a3485 1
	error = bus_mem_add_mapping(bpa, size, cacheable, bshp);
d3501 1
a3501 1
bus_mem_add_mapping(bus_addr_t bpa, bus_size_t size, int cacheable,
d3530 1
a3530 1
		if (cacheable)
@


1.402
log
@Replace magic bus clock constants in est related files with defines.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.401 2007/06/06 17:15:12 deraadt Exp $	*/
d3527 6
a3532 13
		/*
		 * PG_N doesn't exist on 386's, so we assume that
		 * the mainboard has wired up device space non-cacheable
		 * on those machines.
		 */
		if (cpu_class != CPUCLASS_386) {
			pte = kvtopte(va);
			if (cacheable)
				*pte &= ~PG_N;
			else
				*pte |= PG_N;
			pmap_tlb_shootpage(pmap_kernel(), va);
		}
@


1.401
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.400 2007/06/04 06:57:56 jsg Exp $	*/
d1907 1
a1907 1
		bus_clock = 10000;
d1910 1
a1910 1
		bus_clock = 13333;
d1913 1
a1913 1
		bus_clock = 20000;
d1916 1
a1916 1
		bus_clock = 16666;
d1933 1
a1933 1
			bus_clock = 10000;
d1936 1
a1936 1
			bus_clock = 13333;
d1948 1
a1948 1
			bus_clock = (model == 2) ? 10000 : 26666;
d1951 1
a1951 1
			bus_clock = 13333;
d1954 1
a1954 1
			bus_clock = 20000;
d1957 1
a1957 1
			bus_clock = 16666;
d1977 1
a1977 1
		bus_clock = 10000;
d1984 1
a1984 1
			bus_clock = 10000;
d1987 1
a1987 1
			bus_clock = 13333;
d2001 1
a2001 1
			bus_clock = 10000;
d2004 1
a2004 1
			bus_clock = 13333;
d2007 1
a2007 1
			bus_clock = 16667;
d2010 1
a2010 1
			bus_clock = 20000;
d2013 1
a2013 1
			bus_clock = 26667;
d2016 1
a2016 1
			bus_clock = 33333;
d2036 1
a2036 1
			bus_clock = 6666;
d2039 1
a2039 1
			bus_clock = 13333;
d2042 1
a2042 1
			bus_clock = 10000;
@


1.400
log
@Use 166.67 and 266.67 for bus_clock and not 166.66 and 266.66,
as per recommended values from Intel documentation.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.399 2007/06/03 04:30:31 jsg Exp $	*/
d2496 1
a2496 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d2533 2
a2534 2
	daddr_t blkno;
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d2577 1
a2577 1
		printf("(%d %ld %d) ", maddr, blkno, npg);
d2586 1
a2586 1
			printf("(%x %d) ", maddr, blkno);
@


1.399
log
@Add a check for Intel Core processors with Scalable Bus Speed of 200 MHz.
From NetBSD and verified in Intel doc #253669

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.398 2007/05/29 21:01:56 tedu Exp $	*/
d2007 1
a2007 1
			bus_clock = 16666;
d2013 1
a2013 1
			bus_clock = 26666;
@


1.398
log
@add support for core cpu temperature sensors.
from a diff by pierre riteau, but updated to look like the amd64 version
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.397 2007/05/29 21:00:50 jason Exp $	*/
d2008 3
@


1.397
log
@s/entrace/entrance (not obvious that the code was cut/paste =)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.396 2007/05/29 20:36:47 deraadt Exp $	*/
d100 1
d248 2
d328 1
d333 1
d1325 58
d1407 1
@


1.396
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.395 2007/05/29 18:18:20 tom Exp $	*/
d3948 1
a3948 1
 * the starting segment on entrace, and the ending segment on exit.
@


1.395
log
@Remove support for 80386 processors.  Apologies if you have one of
the rare 80386-bases system with enough memory, a 387 FPU, a useable
disk subsystem, and the patience to wait for it to unpack the
distribution .tgz files.

approval from art@@ and many others (esp. nick@@); ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.394 2007/05/27 21:33:25 tom Exp $	*/
d2398 1
a2398 1
dumpconf()
d2401 1
a2401 1
	int maj, i;
d2403 2
a2404 1
	if (dumpdev == NODEV)
a2405 6
	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdevsw[maj].d_psize == NULL)
		return;
	nblks = (*bdevsw[maj].d_psize)(dumpdev);
@


1.394
log
@We don't need to special-case access to the GDT for UP or MP, since
ci_gdt is set correctly even when ! MULTIPROCESSOR.

ok art@@ toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.393 2007/05/27 17:31:56 miod Exp $	*/
a339 1
#if defined(I486_CPU) || defined(I586_CPU) || defined(I686_CPU)
a352 1
#endif
a1188 1
#if defined(I486_CPU) || defined(I586_CPU) || defined(I686_CPU)
a1216 1
#endif
d1733 1
a1733 1
#if !defined(I386_CPU) && !defined(I486_CPU) && !defined(I586_CPU) && !defined(I686_CPU)
a1756 4
#ifdef I386_CPU
		printf("NOTICE: lowering CPU class to i386\n");
		cpu_class = CPUCLASS_386;
		break;
a1757 2
#endif
#ifndef I386_CPU
a1760 1
#endif
a1778 1
#if defined(I486_CPU) || defined(I586_CPU) || defined(I686_CPU)
d1780 2
a1781 1
	 * On a 486 or above, enable ring 0 write protection.
d1783 1
a1783 3
	if (ci->cpu_class >= CPUCLASS_486)
		lcr0(rcr0() | CR0_WP);
#endif
@


1.393
log
@Make sure the minaddr hint for uvm_km_suballoc() calls is always initialized.
ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.392 2007/05/26 22:09:17 weingart Exp $	*/
a2602 1
#ifdef MULTIPROCESSOR
a2604 3
#else
	gdt[GUCODE_SEL].sd = pcb->pcb_ldt[LUCODE_SEL].sd = pmap->pm_codeseg;
#endif
@


1.392
log
@Move cpu_info/curcpu to be mapped by the %fs segment.  Extra input and
debugging by tom@@, art@@, kettenis@@, and others.  Testing by many others.

ok art@@, kettenis@@, tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.391 2007/05/26 20:26:50 pedro Exp $	*/
d436 1
@


1.391
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.390 2007/05/25 15:55:26 art Exp $	*/
d2788 1
@


1.390
log
@Replace the overdesigned and overcomplicated tlb shootdown code with
very simple and dumb fast tlb IPI handlers that have in the order of
the same amount of instructions as the old code had function calls.

All TLB shootdowns are reorganized so that we always shoot the,
without looking at PG_U and when we're shooting a range (primarily in
pmap_remove), we shoot the range when there are 32 or less pages in
it, otherwise we just nuke the whole TLB (this might need tweaking if
someone is interested in micro-optimization). The IPIs are not handled
through the normal interrupt vectoring code, they are not blockable
and they only shoot one page or a range of pages or the whole tlb.

This gives a 15% reduction in system time on my dual-core laptop
during a kernel compile and an 18% reduction in real time on a quad
machine doing bulk ports build.

Tested by many, in snaps for a week, no slowdowns reported (although not
everyone is seeing such huge wins).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.389 2007/05/23 20:33:46 pvalchev Exp $	*/
a176 11
/*
 * The following defines are for the code in setup_buffers that tries to
 * ensure that enough ISA DMAable memory is still left after the buffercache
 * has been allocated.
 */
#define CHUNKSZ		(3 * 1024 * 1024)
#define ISADMA_LIMIT	(16 * 1024 * 1024)	/* XXX wrong place */
#define ALLOC_PGS(sz, limit, pgs) \
    uvm_pglistalloc((sz), 0, (limit), PAGE_SIZE, 0, &(pgs), 1, 0)
#define FREE_PGS(pgs) uvm_pglistfree(&(pgs))

a190 6
#ifdef	NBUF
int	nbuf = NBUF;
#else
int	nbuf = 0;
#endif

d192 1
a192 1
#define BUFCACHEPERCENT 5
d269 1
a269 1
void	setup_buffers(vaddr_t *);
d430 1
a430 1
	setup_buffers(&maxaddr);
a447 2
	printf("using %d buffers containing %u bytes (%uK) of memory\n",
	    nbuf, bufpages * PAGE_SIZE, bufpages * PAGE_SIZE / 1024);
a539 28
	/*
	 * Determine how many buffers to allocate.  We use 10% of the
	 * first 2MB of memory, and 5% of the rest of below 4G memory,
	 * with a minimum of 16 buffers.  We allocate 1/2 as many swap
	 * buffer headers as file i/o buffers.
	 */
	if (bufpages == 0) {
		bufpages = (btoc(2 * 1024 * 1024 + avail_end)) *
		    bufcachepercent / 100;
	}
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}

	/* Restrict to at most 35% filled kvm */
	/* XXX - This needs UBC... */
	if (nbuf >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 35 / 100)
		nbuf = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 35 / 100;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	valloc(buf, struct buf, nbuf);
d544 1
a544 1
setup_buffers(vaddr_t *maxaddr)
a545 22
	vsize_t size;
	vaddr_t addr;
	int base, residual, left, chunk, i;
	struct pglist pgs, saved_pgs;
	struct vm_page *pg;

	size = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
		    NULL, UVM_UNKNOWN_OFFSET, 0,
		    UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
				UVM_ADV_NORMAL, 0)))
		panic("cpu_startup: cannot allocate VM for buffers");
	addr = (vaddr_t)buffers;

	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	if (base >= MAXBSIZE / PAGE_SIZE) {
		/* don't want to alloc more physical mem than needed */
		base = MAXBSIZE / PAGE_SIZE;
		residual = 0;
	}

d547 2
a548 17
	 * In case we might need DMA bouncing we have to make sure there
	 * is some memory below 16MB available.  On machines with many
	 * pages reserved for the buffer cache we risk filling all of that
	 * area with buffer pages.  We still want much of the buffers
	 * reside there as that lowers the probability of them needing to
	 * bounce, but we have to set aside some space for DMA buffers too.
	 *
	 * The current strategy is to grab hold of one 3MB chunk below 16MB
	 * first, which we are saving for DMA buffers, then try to get
	 * one chunk at a time for fs buffers, until that is not possible
	 * anymore, at which point we get the rest wherever we may find it.
	 * After that we give our saved area back. That will guarantee at
	 * least 3MB below 16MB left for drivers' attach routines, among
	 * them isadma.  However we still have a potential problem of PCI
	 * devices attached earlier snatching that memory.  This can be
	 * solved by making the PCI DMA memory allocation routines go for
	 * memory above 16MB first.
d550 2
d553 5
a557 52
	left = bufpages;

	/*
	 * First, save ISA DMA bounce buffer area so we won't lose that
	 * capability.
	 */
	TAILQ_INIT(&saved_pgs);
	TAILQ_INIT(&pgs);
	if (!ALLOC_PGS(CHUNKSZ, ISADMA_LIMIT, saved_pgs)) {
		/*
		 * Then, grab as much ISA DMAable memory as possible
		 * for the buffer cache as it is nice to not need to
		 * bounce all buffer I/O.
		 */
		for (left = bufpages; left > 0; left -= chunk) {
			chunk = min(left, CHUNKSZ / PAGE_SIZE);
			if (ALLOC_PGS(chunk * PAGE_SIZE, ISADMA_LIMIT, pgs))
				break;
		}
	}

	/*
	 * If we need more pages for the buffer cache, get them from anywhere.
	 */
	if (left > 0 && ALLOC_PGS(left * PAGE_SIZE, avail_end, pgs))
		panic("cannot get physical memory for buffer cache");

	/*
	 * Finally, give back the ISA DMA bounce buffer area, so it can be
	 * allocated by the isadma driver later.
	 */
	if (!TAILQ_EMPTY(&saved_pgs))
		FREE_PGS(saved_pgs);

	pg = TAILQ_FIRST(&pgs);
	for (i = 0; i < nbuf; i++) {
		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		addr = (vaddr_t)buffers + i * MAXBSIZE;
		for (size = PAGE_SIZE * (i < residual ? base + 1 : base);
		    size > 0; size -= PAGE_SIZE, addr += PAGE_SIZE) {
			pmap_kenter_pa(addr, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ|VM_PROT_WRITE);
			pg = TAILQ_NEXT(pg, pageq);
		}
	}
	pmap_update(pmap_kernel());
@


1.389
log
@Print real/available memory in MB as well as bytes in dmesg, and unify
architectures to print it the same way.
ok henning, miod; i386 part from tom
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.388 2007/05/15 16:27:38 art Exp $	*/
d2217 1
a2217 1
		i386_ipi(LAPIC_IPI_AST, p->p_cpu->ci_cpuid, LAPIC_DLMODE_FIXED);
a3587 3
#ifdef MULTIPROCESSOR
	u_int32_t cpumask = 0;
#endif
d3620 1
a3620 6
#ifdef MULTIPROCESSOR
			pmap_tlb_shootdown(pmap_kernel(), va, *pte,
			    &cpumask);
#else
			pmap_update_pg(va);
#endif
d3623 2
a3624 3
#ifdef MULTIPROCESSOR
	pmap_tlb_shootnow(cpumask);
#endif
@


1.388
log
@make splassert(IPL_NONE) work on i386/MP (the single-processor case is
a bit more hairy).

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.387 2007/05/14 04:46:02 deraadt Exp $	*/
d430 2
a431 2
	printf("real mem  = %lu (%uK)\n", ctob((paddr_t)physmem),
	    ctob((paddr_t)physmem)/1024U);
d462 3
a464 2
	printf("avail mem = %lu (%uK)\n", ptoa((paddr_t)uvmexp.free),
	    ptoa((paddr_t)uvmexp.free) / 1024U);
@


1.387
log
@_bus_dmamap_sync() is unused; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.386 2007/05/14 04:45:49 deraadt Exp $	*/
d4261 2
d4272 2
d4279 2
d4289 1
d4295 1
@


1.386
log
@SMALL_KERNEL unused bits
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.385 2007/05/13 08:18:11 gwk Exp $	*/
a3970 11
}

/*
 * Common function for DMA map synchronization.  May be called
 * by bus-specific DMA map synchronization functions.
 */
void
_bus_dmamap_sync(bus_dma_tag_t t, bus_dmamap_t map, bus_addr_t addr,
    bus_size_t size, int op)
{
	/* Nothing to do here. */
@


1.385
log
@Enable powernow on amd64 processors in the GENERIC.MP.
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.384 2007/05/04 16:39:28 art Exp $	*/
d251 1
a251 1
int kbd_reset;
d254 5
d260 1
a265 1
void (*update_cpuspeed)(void) = NULL;
@


1.384
log
@Remove dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.383 2007/04/21 21:06:14 gwk Exp $	*/
d1411 1
a1411 1
#if !defined(SMALL_KERNEL) && defined(I686_CPU) && !defined(MULTIPROCESSOR)
d1426 1
a1426 1
#endif /* !SMALL_KERNEL && I686_CPU && !MULTIPROCESSOR */
a1440 1
#if !defined(MULTIPROCESSOR)
a1441 1
#endif
@


1.383
log
@Introduce a smp aware hw.setperf mechanism, it will scale all CPUs or
cores by the same amount, i.e. if you do hw.setperf=50 both cores will
be scaled to the opearting state corresponing to 50%. Tested by many with
est (mainly on core2duo machines like X60 thinkpads). Only enable est
during GENERIC.MP build no one tested powernow.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.382 2007/04/12 20:22:58 art Exp $	*/
a2692 21

#ifdef HZ
/*
 * If HZ is defined we use this code, otherwise the code in
 * /sys/arch/i386/i386/microtime.s is used.  The other code only works
 * for HZ=100.
 */
void
i8254_microtime(struct timeval *tvp)
{
	int s = splhigh();

	*tvp = time;
	tvp->tv_usec += tick;
	splx(s);
	while (tvp->tv_usec >= 1000000) {
		tvp->tv_sec++;
		tvp->tv_usec -= 1000000;
	}
}
#endif /* HZ */
@


1.382
log
@Faster signal delivery on i386/MP.

We need to poke the other CPU so that it processes the AST immediately
and doesn't wait for the next interrupt or syscall.

Since IPIs really shouldn't process ASTs, we need to trigger a soft
interrupt on the destination CPU to process the AST. But since we can't
send soft interrupts to other CPUs, we send an IPI, that triggers a soft
interrupt that in turn processes the AST.

Also, this marks the beginning of moving to slightly better IPI mechanism
of short and optimized IPIs instead of the large and complicated IPI
infrastructure we're using now.

tested by many, ok tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.381 2007/04/03 10:14:47 art Exp $	*/
d1447 1
a1447 1
#if !defined(SMALL_KERNEL) && defined(I686_CPU) && !defined(MULTIPROCESSOR)
a1470 1
#if !defined(MULTIPROCESSOR)
a1471 1
#endif
@


1.381
log
@Make the ast on i386 per-process instead of per-cpu. This makes
signal delivery more reliable in some cases when a process switches
cpu.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.380 2007/03/19 09:29:33 art Exp $	*/
d2197 23
@


1.380
log
@Move i386 to timecounters. This is more or less the same code as amd64.

The "lapic" timer is ripped out since it wasn't actually a lapic timer,
but a hacked up tsc timer with some synchronization for MP. There is no
tsc timer right now since they are very unreliable on MP systems, systems
with apm, and systems that change the cpu clock. Which basically means
every modern machine out there. We're running with the i8259 timer now.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.379 2007/02/21 19:34:25 deraadt Exp $	*/
d3303 2
d3306 7
a3312 1
	ci->ci_astpending = 1;
@


1.379
log
@part missed in PAE revert: ptoa() paddr_t size is no longer printed
with %llu; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.378 2007/02/20 21:15:01 tom Exp $	*/
a258 1
void (*microtime_func)(struct timeval *) = i8254_microtime;
d3290 1
a3290 1
cpu_initclocks()
d3293 5
@


1.378
log
@Revert PAE pmap for now, until the strange bug is found.  This stops
the freezes many of us are seeing (especially on amd64 machines running
OpenBSD/i386).

Much testing by nick@@ (as always - thanks!), hugh@@, ian@@, kettenis@@
and Sam Smith (s (at) msmith (dot) net).

Requested by, input from, and ok deraadt@@  ok art@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.377 2007/02/17 23:59:03 marco Exp $	*/
d426 1
a426 1
	printf("real mem  = %llu (%uK)\n", ctob((paddr_t)physmem),
d458 1
a458 1
	printf("avail mem = %llu (%uK)\n", ptoa((paddr_t)uvmexp.free),
@


1.377
log
@Add SMALL_KERNEL throught acpi to make it fit on boot media.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.376 2007/02/17 17:38:37 tom Exp $	*/
a220 3
#ifndef	SMALL_KERNEL
int pae_copy;
#endif
d246 1
a246 1
paddr_t avail_end, avail_end2;
a327 6
#ifdef	I686_PAE
int cpu_pae = 1;
#else
int cpu_pae = 0;
#endif

d2843 1
d2858 2
a2859 1
	pmap_pte_setbits(va, 0, PG_RW);
d3014 1
a3014 1
		if (extent_alloc_region(iomem_ex, (u_long)bootargv, bootargc,
d3018 1
a3018 1
		pmap_enter(pmap_kernel(), (vaddr_t)bootargp, (u_long)bootargv,
d3031 9
d3053 10
d3065 3
a3067 1
			e = trunc_page(im->addr + im->size);
d3069 1
a3069 1
			printf(" %llx-%llx", a, e);
d3071 3
d3093 1
a3093 10
			if (a >= 0x100000000ULL) {
#ifdef DEBUG
				printf("-H");
#endif
				if (!cpu_pae)
					continue;
			}

			if (e <= 0x100000000ULL &&
			    extent_alloc_region(iomem_ex, a, e - a, EX_NOWAIT))
d3102 1
a3102 3
			avail_end2 = MAX(avail_end2, e);
			if (avail_end2 < 0x100000000ULL)
				avail_end = avail_end2;
a3106 2
	if (avail_end2 < 0x100000000ULL)
		avail_end2 = avail_end;
d3137 1
a3137 1
		if (a < atop(avail_end) && e > atop(avail_end))
d3144 1
a3144 1
				printf(" %llx-%llx (<16M)", a, lim);
d3150 1
a3150 1
					printf(" %llx-%llx", lim, e);
d3157 1
a3157 1
				printf(" %llx-%llx", a, e);
d3159 2
a3160 6
				if (a >= atop(0x100000000ULL))
					uvm_page_physload(a, e, a, a - 1,
					    VM_FREELIST_ABOVE4G);
				else
					uvm_page_physload(a, e, a, e,
					    VM_FREELIST_DEFAULT);
a3568 1
	u_int32_t bits;
d3570 1
d3602 1
d3604 1
a3604 1
				bits = pmap_pte_setbits(va, 0, PG_N);
d3606 1
a3606 1
				bits = pmap_pte_setbits(va, PG_N, 0);
d3608 1
a3608 1
			pmap_tlb_shootdown(pmap_kernel(), va, bits,
d3628 1
a3628 1
	paddr_t bpa;
d3638 1
a3638 1
		bpa = (u_long)ISA_PHYSADDR(bsh);
d3674 1
a3674 1
	paddr_t bpa;
d3682 1
a3682 1
		bpa = (u_long)ISA_PHYSADDR(bsh);
a3735 1
	int npages;
a3750 11
	npages = 0;
#ifndef SMALL_KERNEL
	if (avail_end2 > avail_end &&
	    (flags & (BUS_DMA_64BIT|BUS_DMA_24BIT)) == 0) {
		/* this many pages plus one in case we get split */
		npages = round_page(size) / PAGE_SIZE + 1;
		if (npages < nsegments)  /* looks stupid, but possible */
			npages = nsegments;
		mapsize += sizeof(struct vm_page *) * npages;
	}
#endif /* !SMALL_KERNEL */
a3760 2
	map->_dm_pages = npages? (void *)&map->dm_segs[nsegments] : NULL;
	map->_dm_npages = npages;
a3764 43
#ifndef SMALL_KERNEL
	if (npages) {
		struct pglist mlist;
		vaddr_t va;
		int error;

		size = npages << PGSHIFT;
		va = uvm_km_valloc(kernel_map, size);
		if (va == 0) {
			map->_dm_npages = 0;
			free(map, M_DEVBUF);
			return (ENOMEM);
		}

		TAILQ_INIT(&mlist);
		/* if not a 64bit map -- allocate some bouncy-bouncy */
		error = uvm_pglistalloc(size,
		    round_page(ISA_DMA_BOUNCE_THRESHOLD), 0xfffff000,
		    PAGE_SIZE, boundary, &mlist, nsegments,
		    (flags & BUS_DMA_NOWAIT) == 0);
		if (error) {
			map->_dm_npages = 0;
			uvm_km_free(kernel_map, (vaddr_t)va, size);
			free(map, M_DEVBUF);
			return (ENOMEM);
		} else {
			struct vm_page **pg = map->_dm_pages;

			npages--;
			*pg = TAILQ_FIRST(&mlist);
			pmap_kenter_pa(va, VM_PAGE_TO_PHYS(*pg),
			    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
			for (pg++, va += PAGE_SIZE; npages--;
			    pg++, va += PAGE_SIZE) {
				*pg = TAILQ_NEXT(pg[-1], pageq);
				pmap_kenter_pa(va, VM_PAGE_TO_PHYS(*pg),
				    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
			}
		}
		map->_dm_pgva = va;
	}
#endif /* !SMALL_KERNEL */

d3788 1
a3788 1
	paddr_t lastaddr;
a3955 1
	map->_dm_nused = 0;
d3963 1
a3963 1
_bus_dmamap_sync(bus_dma_tag_t t, bus_dmamap_t map, bus_addr_t offset,
d3966 1
a3966 34
#ifndef SMALL_KERNEL
	bus_dma_segment_t *sg;
	int i, off = offset;
	bus_size_t l;

	/* scan the segment list performing necessary copies */
	if (!(map->_dm_flags & BUS_DMA_64BIT) && map->_dm_nused) {
		for (i = map->_dm_segcnt, sg = map->dm_segs;
		    size && i--; sg++) {
			if (off >= sg->ds_len) {
				off -= sg->ds_len;
				continue;
			}

			l = sg->ds_len - off;
			if (l > size)
				l = size;
			size -= l;
			if (sg->ds_addr2) {
				if (op & BUS_DMASYNC_POSTREAD) {
					bcopy((void *)(sg->ds_va2 + off),
					    (void *)(sg->ds_va + off), l);
					pae_copy++;
				}
				if (op & BUS_DMASYNC_PREWRITE) {
					bcopy((void *)(sg->ds_va + off),
					    (void *)(sg->ds_va2 + off), l);
					pae_copy++;
				}
			}
			off = 0;
		}
	}
#endif /* !SMALL_KERNEL */
d4110 2
a4111 2
	paddr_t curaddr, lastaddr, oaddr, baddr, bmask;
	vaddr_t pgva, vaddr = (vaddr_t)buf;
d4127 1
a4127 18
		pmap_extract(pmap, vaddr, &curaddr);
		oaddr = 0;
		pgva  = 0;
#ifndef SMALL_KERNEL
		if (!(map->_dm_flags & BUS_DMA_64BIT) &&
		    curaddr >= 0x100000000ULL) {
			struct vm_page *pg;
			int page, off;
			
			if (map->_dm_nused + 1 >= map->_dm_npages)
				return (ENOMEM);
			off = vaddr & PAGE_MASK;
			pg = map->_dm_pages[page = map->_dm_nused++];
			oaddr = curaddr;
			curaddr = VM_PAGE_TO_PHYS(pg) + off;
			pgva = map->_dm_pgva + (page << PGSHIFT) + off;
		}
#endif /* !SMALL_KERNEL */
a4150 1
			map->dm_segs[seg].ds_addr2 = oaddr;
a4151 2
			map->dm_segs[seg].ds_va = vaddr;
			map->dm_segs[seg].ds_va2 = pgva;
a4164 1
				map->dm_segs[seg].ds_addr2 = oaddr;
a4165 2
				map->dm_segs[seg].ds_va = vaddr;
				map->dm_segs[seg].ds_va2 = pgva;
a4200 13
	if (flags & BUS_DMA_64BIT) {
		if (high > 0x100000000ULL && low < 0x100000000ULL)
			low = 0x100000000ULL;
	} else if (high > 0x100000000ULL) {
		if (low >= 0x100000000ULL) {
#ifdef DIAGNOSTIC
			printf("_bus_dmamem_alloc_range: "
			    "32bit request in above 4GB space\n");
#endif
			return (EINVAL);
		} else
			high = 0x100000000ULL;
	}
@


1.376
log
@Bring in the AMD errata checks from amd64.

Changes to either copy of amd64errata.c must be replicated in the other.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.375 2007/02/13 00:22:48 jsg Exp $	*/
d2459 1
a2459 1
#if NACPI > 0
@


1.375
log
@Check for xTPR result of CPUID.
ok tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.374 2007/02/03 16:48:23 miod Exp $	*/
d1955 3
@


1.374
log
@Remove unused functionality from lockmgr():
- LK_EXCLUPGRADE is never used.
- LK_REENABLE is never used.
- LK_SETRECURSE is never used. Because of this, the lk_recurselevel
  field is always zero, so it can be removed to.
- the spinlock version (and LK_SPIN) is never used, since it was decided
  to use different locking structure for MP-safe protection.

Tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.373 2006/12/23 22:46:13 deraadt Exp $	*/
d1153 1
@


1.373
log
@do not mix & and || badly
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.372 2006/12/20 17:50:40 gwk Exp $	*/
a4386 3
#ifdef notdef
		spinlockmgr(&kernel_lock, LK_EXCLUSIVE|LK_CANRECURSE, 0);
#else
a4387 1
#endif
a4393 3
#ifdef notdef
		spinlockmgr(&kernel_lock, LK_RELEASE, 0);
#else
a4394 1
#endif
a4399 3
#ifdef notdef
	spinlockmgr(&kernel_lock, LK_EXCLUSIVE|LK_CANRECURSE, 0);
#else
a4400 1
#endif
a4405 3
#ifdef notdef
	spinlockmgr(&kernel_lock, LK_RELEASE, 0);
#else
a4406 1
#endif
@


1.372
log
@"#ifdef is a tool of the weak!"
Rename pentium_mhz to cpuspeed which is consistant with amd64 making
shared ACPI code less nasty.
ok marco, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.371 2006/11/29 20:03:19 dim Exp $	*/
d2460 1
a2460 1
			if (howto & RB_POWERDOWN || acpi_s5)
@


1.371
log
@Remove all the extern cpu_{id,model,whatever} declarations from most
stuff in arch/i386/i386.  This should prevent more screwups like the
one I did before in ichpcib.c...

ok dlg@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.370 2006/11/28 18:35:19 dim Exp $	*/
d1803 1
a1803 1
		if (pentium_mhz > 994) {
d1806 2
a1807 2
			ghz = (pentium_mhz + 9) / 1000;
			fr = ((pentium_mhz + 9) / 10 ) % 100;
d1816 1
a1816 1
				printf(" %d MHz", pentium_mhz);
d1860 1
a1860 1
	if (pentium_mhz != 0 && cpu_cpuspeed == NULL)
d2155 1
a2155 1
	pentium_mhz = (bus_clock * mult) / 100;
d2177 1
a2177 1
	pentium_mhz = (bus_clock * mult) / 1000;
d2185 1
a2185 1
	*freq = pentium_mhz;
@


1.370
log
@Always call cyrix3_get_bus_clock in cyrix3_cpu_setup, since we might
need the bus clock later.  Add bus clock case for Core cpu's.  Rewrite
p[34]_update_cpuspeed to make of already detected bus clocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.369 2006/11/28 16:32:09 dim Exp $	*/
a406 1
	extern int cpu_id;
a1566 1
	extern int cpu_cache_edx;
a1636 7
	extern char cpu_vendor[];
	extern char cpu_brandstr[];
#ifdef CPUDEBUG
	extern int cpu_cache_eax, cpu_cache_ebx, cpu_cache_ecx, cpu_cache_edx;
#else
	extern int cpu_cache_edx;
#endif
a3334 5
	extern char cpu_vendor[];
	extern int cpu_id;
#if NAPM > 0
	extern int cpu_apmwarn;
#endif
@


1.369
log
@Don't display cpu brand string, features, etc. a second time, when booting an MP
kernel on a single cpu machine.

discussed with kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.368 2006/11/28 15:24:08 dim Exp $	*/
a1175 2
	cyrix3_get_bus_clock(ci);

d1202 2
d2099 3
d2154 6
a2159 1
	int bus, mult;
a2161 24
	if (p4_model < 2) {
		bus = (msr >> 21) & 0x7;
		switch (bus) {
		case 0:
			bus = 10000;
			break;
		case 1:
			bus = 13333;
			break;
		}
	} else {
		bus = (msr >> 16) & 0x7;
		switch (bus) {
		case 0:
			bus = 10000;
			break;
		case 1:
			bus = 13333;
			break;
		case 2:
			bus = 20000;
			break;
		}
	}
d2164 1
a2164 1
	pentium_mhz = bus * mult / 100;
d2171 1
a2171 1
	int bus, mult;
d2175 3
a2177 12
	msr = rdmsr(MSR_EBL_CR_POWERON);
	bus = (msr >> 18) & 0x3;
	switch (bus) {
	case 0:
		bus = 6666;
		break;
	case 1:
		bus = 13333;
		break;
	case 2:
		bus = 10000;
		break;
d2180 1
d2186 1
a2186 1
	pentium_mhz = (bus * mult) / 1000;
@


1.368
log
@Only use est and other non-acpi setperf mechanisms, if acpi is not
attached.  Also moves their initialization and printing of
information until after the primary cpu has attached to mainbus.

prodded by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.367 2006/10/17 21:28:23 tom Exp $	*/
d1790 1
a1790 1
	if ((ci->ci_flags & CPUF_BSP) == 0) {
d1817 1
a1817 1
			if ((ci->ci_flags & CPUF_BSP) == 0) {
d1824 1
a1824 1
			if ((ci->ci_flags & CPUF_BSP) == 0) {
d1830 1
a1830 1
	if ((ci->ci_flags & CPUF_BSP) == 0) {
@


1.367
log
@Set the Geode SC1100-specific reset function in the geodesc driver,
rather than when CPUID says we're on any Geode.  Should avoid reset
failure on Nokia IP110s and other non-SC1100 Geode-based systems.

Reset should hopefully still work on Soekris Net4801s and PC Engines
WRAP systems, but no-one bothered to test and report back in two days.

"commit" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.366 2006/10/05 01:36:41 mickey Exp $	*/
d258 1
d338 1
d340 1
d342 1
d347 1
d427 2
a428 3
	 * XXX SMP XXX identifycpu shouldn't need to be called here, but
	 * mpbios is broken otherwise.  Also, curcpu is not quite fully
	 * initialized this early either, so some extra work is needed.
d1172 16
d1204 1
a1204 9
	cyrix3_get_bus_clock(ci);

	if (cpu_ecxfeature & CPUIDECX_EST) {
		if (rdmsr(MSR_MISC_ENABLE) & (1 << 16))
			est_init(ci->ci_dev.dv_xname, CPUVENDOR_VIA);
		else
			printf("%s: Enhanced SpeedStep disabled by BIOS\n",
			    ci->ci_dev.dv_xname);
	}
d1384 8
d1415 1
a1415 1
		k6_powernow_init();
d1421 17
a1444 3
#if !defined(MULTIPROCESSOR)
	int family = (ci->ci_signature >> 8) & 15;
#endif
d1452 1
a1452 8
	switch (family) {
	case 6:
		k7_powernow_init();
		break;
	case 15:
		k8_powernow_init();
		break;
	}
d1457 1
d1459 1
a1459 1
intel686_common_cpu_setup(struct cpu_info *ci)
a1460 3

#if !defined(SMALL_KERNEL) && defined(I686_CPU)
#if !defined(MULTIPROCESSOR)
d1473 10
@


1.366
log
@only take in an account <4g memory for bufcache calculation as the upper part will not participate anyway; pedro@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.365 2006/09/19 11:06:33 jsg Exp $	*/
a1342 26
#if defined(I586_CPU) || defined(I686_CPU)
void	natsem6x86_cpureset(void);

void
natsem6x86_cpureset(void)
{
	/*
	 * Reset AMD Geode SC1100.
	 *
	 * 1) Write PCI Configuration Address Register (0xcf8) to
	 *    select Function 0, Register 0x44: Bridge Configuration,
	 *    GPIO and LPC Configuration Register Space, Reset
	 *    Control Register.
	 *
	 * 2) Write 0xf to PCI Configuration Data Register (0xcfc)
	 *    to reset IDE controller, IDE bus, and PCI bus, and
	 *    to trigger a system-wide reset.
	 *
	 * See AMD Geode SC1100 Processor Data Book, Revision 2.0,
	 * sections 6.3.1, 6.3.2, and 6.4.1.
	 */
	outl(0xCF8, 0x80009044UL);
	outb(0xCFC, 0x0F);
}
#endif

a1356 1
	cpuresetfn = natsem6x86_cpureset;
a1358 1

@


1.365
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.364 2006/08/20 01:42:51 gwk Exp $	*/
d562 3
a564 3
	 * first 2MB of memory, and 5% of the rest, with a minimum of 16
	 * buffers.  We allocate 1/2 as many swap buffer headers as file
	 * i/o buffers.
d567 1
a567 1
		bufpages = (btoc(2 * 1024 * 1024) + physmem) *
@


1.364
log
@When using p4tcc supply a cpu_cpuspeed function to provide an estimated
hw.cpuspeed. If cpu_cpuspeed is not null in identifycpu() don't overwrite
what it points to with pentium_cpuspeed.
lots of thanks to todd@@ for testing, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.363 2006/08/18 16:08:44 dim Exp $	*/
d547 1
a547 2
allocsys(v)
	register caddr_t v;
d2370 1
a2370 1
	register struct trapframe *tf;
d2549 1
a2549 1
	register int maj, i;
d2617 2
a2618 2
	register u_int i, j, npg;
	register int maddr;
d2622 1
a2622 1
	register char *str;
d3072 1
a3072 1
			register paddr_t a, e;
@


1.363
log
@Add a new Core Xeon CPU and an older Pentium Pro model to the bus
clock detection.  Also improve the error message in case of an unknown
CPU, so we can more easily see what needs to be added.

Tested by brad@@ and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.362 2006/07/10 19:45:22 gwk Exp $	*/
d1863 1
a1863 1
	if (pentium_mhz != 0)
@


1.362
log
@The setperf mechanism cannot handle multiprocessor systems. Ensure that
p4tcc and speedstep are not initialized in multiprocessor kernels.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.361 2006/06/17 17:23:39 dim Exp $	*/
d2074 1
a2074 1
			printf("%s: unknown Pentium M FSB_FREQ value %d\n",
d2076 1
a2076 1
			break;
d2080 1
d2093 3
d2097 1
a2097 1
			printf("%s: unknown Core Duo/Solo FSB_FREQ value %d\n",
d2099 1
a2099 1
			break;
d2102 1
d2123 1
a2123 1
			printf("%s: unknown i686 EBL_CR_POWERON value %d\n",
d2125 1
a2125 1
			break;
d2129 1
a2129 1
		printf("%s: unknown i686 model %d, can't get bus clock\n",
d2131 6
a2137 1
		
@


1.361
log
@In p4tcc, only check cpu stepping for the Pentium 4 family.  Also kill
some trailing whitespace.

ok gklok@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.360 2006/06/15 02:53:15 gwk Exp $	*/
d1464 1
d1477 1
a1477 1

@


1.360
log
@In p3_get_bus_clock() don't fall through if we have in fact correctly
matched a model.
Found in a dmesg from Craig Barraclough craigba AT creative.com.au.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.359 2006/06/12 13:18:18 dim Exp $	*/
d1438 1
a1438 1
	int family = (ci->ci_signature >> 8) & 15;	
d1464 1
a1464 1
	int model = (ci->ci_signature >> 4) & 15;
d1475 1
a1475 1
		p4tcc_init(model, step);
@


1.359
log
@Some more improvements to EST:
- If an unknown EST CPU is encountered, use the known highest and lowest
  (and if different, the current) power state to generate a fake power
  state table on the fly.  Thanks to canacar for the idea.
- Calculate system bus clock speed before calling est_init(); it is
  needed to display proper MHz values from MSR values.
- Also use the bus clock to identify EST CPU's, which is needed to
  differentiate e.g. Pentium M 715 and 760, which unfortunately have
  exactly the same MSR values.
- Store power states directly as MSR values.

Tested by many, "so when does it go in?" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.358 2006/06/12 07:32:53 gwk Exp $	*/
d2121 1
@


1.358
log
@ANSIfy, and nuke newline at end of file.
ok toby@@, "slap it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.357 2006/05/31 10:34:54 todd Exp $	*/
d257 1
d350 3
d772 3
a774 2
				"Pentium III", 0, 0,
				0, 0,
d1185 2
d1502 4
d1538 4
d1981 149
d2133 1
a2133 1
	int bus, mult, freq;
d2140 1
a2140 1
			bus = 100;
d2143 1
a2143 1
			bus = 133;
d2150 1
a2150 1
			bus = 100;
d2153 1
a2153 1
			bus = 133;
d2156 1
a2156 1
			bus = 200;
a2160 4
	freq = bus * mult;
	/* 133MHz actually means 133.(3)MHz */
	if (bus == 133)
		freq += mult / 3;
d2162 1
a2162 1
	pentium_mhz = freq;
d2177 1
a2177 1
		bus = 66;
d2180 1
a2180 1
		bus = 133;
d2183 1
a2183 1
		bus = 100;
d2192 1
a2192 1
	pentium_mhz = (bus * mult) / 10;
@


1.357
log
@do not call acpi_powerdown() unless acpi has successfully initialized
ok gwk@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.356 2006/05/19 19:43:41 dim Exp $	*/
d589 1
a589 2
setup_buffers(maxaddr)
	vaddr_t *maxaddr;
d1945 1
a1945 2
tm86_cpu_name(model)
	int model;
d2050 2
a2051 6
ibcs2_sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
d2070 2
a2071 6
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
d2193 1
a2193 4
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d2266 1
a2266 2
boot(howto)
	int howto;
d2541 1
a2541 2
i8254_microtime(tvp)
	register struct timeval *tvp;
d2559 2
a2560 5
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	register_t *retval;
d2633 2
a2634 4
setgate(gd, func, args, type, dpl, seg)
	struct gate_descriptor *gd;
	void *func;
	int args, type, dpl, seg;
d2648 1
a2648 2
unsetgate(gd)
	struct gate_descriptor *gd;
d2661 1
a2661 4
setregion(rd, base, limit)
	struct region_descriptor *rd;
	void *base;
	size_t limit;
d2669 2
a2670 5
setsegment(sd, base, limit, type, dpl, def32, gran)
	struct segment_descriptor *sd;
	void *base;
	size_t limit;
	int type, dpl, def32, gran;
d3063 1
a3063 3
cpu_exec_aout_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
d3187 2
a3188 8
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
d3272 2
a3273 6
bus_space_map(t, bpa, size, cacheable, bshp)
	bus_space_tag_t t;
	bus_addr_t bpa;
	bus_size_t size;
	int cacheable;
	bus_space_handle_t *bshp;
d3334 2
a3335 6
_bus_space_map(t, bpa, size, cacheable, bshp)
	bus_space_tag_t t;
	bus_addr_t bpa;
	bus_size_t size;
	int cacheable;
	bus_space_handle_t *bshp;
d3353 3
a3355 8
bus_space_alloc(t, rstart, rend, size, alignment, boundary, cacheable,
    bpap, bshp)
	bus_space_tag_t t;
	bus_addr_t rstart, rend;
	bus_size_t size, alignment, boundary;
	int cacheable;
	bus_addr_t *bpap;
	bus_space_handle_t *bshp;
d3421 2
a3422 5
bus_mem_add_mapping(bpa, size, cacheable, bshp)
	bus_addr_t bpa;
	bus_size_t size;
	int cacheable;
	bus_space_handle_t *bshp;
d3479 1
a3479 4
bus_space_unmap(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
d3565 1
a3565 4
bus_space_free(t, bsh, size)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t size;
d3573 2
a3574 5
bus_space_subregion(t, bsh, offset, size, nbshp)
	bus_space_tag_t t;
	bus_space_handle_t bsh;
	bus_size_t offset, size;
	bus_space_handle_t *nbshp;
d3585 2
a3586 8
_bus_dmamap_create(t, size, nsegments, maxsegsz, boundary, flags, dmamp)
	bus_dma_tag_t t;
	bus_size_t size;
	int nsegments;
	bus_size_t maxsegsz;
	bus_size_t boundary;
	int flags;
	bus_dmamap_t *dmamp;
d3686 1
a3686 3
_bus_dmamap_destroy(t, map)
	bus_dma_tag_t t;
	bus_dmamap_t map;
d3697 2
a3698 7
_bus_dmamap_load(t, map, buf, buflen, p, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	void *buf;
	bus_size_t buflen;
	struct proc *p;
	int flags;
d3726 2
a3727 5
_bus_dmamap_load_mbuf(t, map, m0, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	struct mbuf *m0;
	int flags;
d3768 2
a3769 5
_bus_dmamap_load_uio(t, map, uio, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	struct uio *uio;
	int flags;
d3827 2
a3828 7
_bus_dmamap_load_raw(t, map, segs, nsegs, size, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	bus_dma_segment_t *segs;
	int nsegs;
	bus_size_t size;
	int flags;
d3859 1
a3859 3
_bus_dmamap_unload(t, map)
	bus_dma_tag_t t;
	bus_dmamap_t map;
d3876 2
a3877 6
_bus_dmamap_sync(t, map, offset, size, op)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	bus_addr_t offset;
	bus_size_t size;
	int op;
d3920 3
a3922 7
_bus_dmamem_alloc(t, size, alignment, boundary, segs, nsegs, rsegs, flags)
	bus_dma_tag_t t;
	bus_size_t size, alignment, boundary;
	bus_dma_segment_t *segs;
	int nsegs;
	int *rsegs;
	int flags;
d3934 1
a3934 4
_bus_dmamem_free(t, segs, nsegs)
	bus_dma_tag_t t;
	bus_dma_segment_t *segs;
	int nsegs;
d3962 2
a3963 7
_bus_dmamem_map(t, segs, nsegs, size, kvap, flags)
	bus_dma_tag_t t;
	bus_dma_segment_t *segs;
	int nsegs;
	size_t size;
	caddr_t *kvap;
	int flags;
d3997 1
a3997 4
_bus_dmamem_unmap(t, kva, size)
	bus_dma_tag_t t;
	caddr_t kva;
	size_t size;
d4014 2
a4015 6
_bus_dmamem_mmap(t, segs, nsegs, off, prot, flags)
	bus_dma_tag_t t;
	bus_dma_segment_t *segs;
	int nsegs;
	off_t off;
	int prot, flags;
d4051 3
a4053 10
_bus_dmamap_load_buffer(t, map, buf, buflen, p, flags, lastaddrp, segp, first)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	void *buf;
	bus_size_t buflen;
	struct proc *p;
	int flags;
	paddr_t *lastaddrp;
	int *segp;
	int first;
d4159 3
a4161 10
_bus_dmamem_alloc_range(t, size, alignment, boundary, segs, nsegs, rsegs,
    flags, low, high)
	bus_dma_tag_t t;
	bus_size_t size, alignment, boundary;
	bus_dma_segment_t *segs;
	int nsegs;
	int *rsegs;
	int flags;
	paddr_t low;
	paddr_t high;
d4292 1
a4292 3
softintr(sir, vec)
	int sir;
	int vec;
d4305 1
a4305 2
splraise(ncpl)
	int ncpl;
d4318 1
a4318 2
splx(ncpl)
	int ncpl;
d4328 1
a4328 2
spllower(ncpl)
	int ncpl;
a4334 1

@


1.356
log
@Reimplement the Enhanced SpeedStep CPU detection by using the
quintuplet { vendor, MHz_hi, mV_hi, MHz_lo, mV_lo }, which works much
better than parsing the branding string.  It also makes it easier to add
new models later.

Shouldn't break any CPU's which previously worked okay with EST; if
there's any trouble, please let me know!

Also adds quite a number of VIA C7-M models, and a few more Pentium M
models, all from FreeBSD.

"go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.355 2006/05/18 17:36:31 dim Exp $	*/
d2325 1
a2325 1
		extern int acpi_s5;
d2327 5
a2331 3
		delay(500000);
		if (howto & RB_POWERDOWN || acpi_s5)
			acpi_powerdown();
@


1.355
log
@Enable detection of SpeedStep support for the VIA Esther CPU's.  Note
this won't identify the possible speeds yet.  Add some KNF while there.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.354 2006/05/11 13:21:11 mickey Exp $	*/
d1183 1
a1183 1
			est_init(ci->ci_dev.dv_xname);
d1463 1
a1463 1
			est_init(ci->ci_dev.dv_xname);
@


1.354
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.353 2006/04/27 15:37:51 mickey Exp $	*/
d1180 8
d1545 1
a1545 2
intel686_cpu_name(model)
	int model;
d1585 1
a1585 2
cyrix3_cpu_name(model, step)
	int model, step;
@


1.353
log
@implement separate PAE pmap that allows access to 64g of physmem
if supported by the cpu(s). currently not enabled by default and
not compiled into ramdisks. this grows paddr_t to 64bit but yet
leaves bus_addr_t at 32bits. measures are taken to favour dmaable
memory allocation from below 4g line such that buffer cache is
already allocated form below, pool backend allocator prefers lower
memory and then finally bounce buffers are used as last resort.
PAE is engaged only if global variable cpu_pae is manually set
to non-zero and there is physical memory present above 4g.
simplify pcibios address math to use u_long as we always will
be in the 32bit space.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.352 2006/04/18 17:39:15 kettenis Exp $	*/
d1347 1
a1347 1
	 * 
d1441 1
a1441 1
#endif 
@


1.352
log
@Make sure we print crucial debug information before we panic.
Stolen from mpf@@
ok mpf@@, mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.351 2006/03/24 12:17:03 mickey Exp $	*/
d221 3
d249 1
a249 1
paddr_t avail_end;
d329 6
d428 2
a429 1
	printf("real mem  = %u (%uK)\n", ctob(physmem), ctob(physmem)/1024U);
d460 2
a461 2
	printf("avail mem = %lu (%uK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024U);
a2720 1
	pt_entry_t *pte;
d2736 1
a2736 2
	pte = PTE_BASE + atop(va);
	*pte &= ~PG_RW;
d2891 1
a2891 1
		if (extent_alloc_region(iomem_ex, (paddr_t)bootargv, bootargc,
d2895 1
a2895 1
		pmap_enter(pmap_kernel(), (vaddr_t)bootargp, (paddr_t)bootargv,
a2908 9
#if defined(MULTIPROCESSOR)
	/* install the page after boot args as PT page for first 4M */
	pmap_enter(pmap_kernel(), (u_long)vtopte(0),
	   round_page((vaddr_t)(bootargv + bootargc)),
		VM_PROT_READ|VM_PROT_WRITE,
		VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
	memset(vtopte(0), 0, NBPG);  /* make sure it is clean before using */
#endif

a2920 10
#ifdef DEBUG
			printf(" %llx-%llx", im->addr, im->addr + im->size);
#endif

			if (im->addr >= 0x100000000ULL) {
#ifdef DEBUG
				printf("-H");
#endif
				continue;
			}
d2923 1
a2923 3
			if (im->addr + im->size <= 0xfffff000ULL)
				e = trunc_page(im->addr + im->size);
			else {
d2925 1
a2925 1
				printf("-T");
a2926 3
				e = 0xfffff000;
			}

d2946 10
a2955 1
			if (extent_alloc_region(iomem_ex, a, e - a, EX_NOWAIT))
d2964 3
a2966 1
			avail_end = max(avail_end, e);
d2971 2
d3003 1
a3003 1
		if (e > atop(avail_end))
d3010 1
a3010 1
				printf(" %x-%x (<16M)", a, lim);
d3016 1
a3016 1
					printf(" %x-%x", lim, e);
d3023 1
a3023 1
				printf(" %x-%x", a, e);
d3025 6
a3030 2
				uvm_page_physload(a, e, a, e,
				    VM_FREELIST_DEFAULT);
d3468 1
a3469 1
	pt_entry_t *pte;
a3500 1
			pte = kvtopte(va);
d3502 1
a3502 1
				*pte &= ~PG_N;
d3504 1
a3504 1
				*pte |= PG_N;
d3506 1
a3506 1
			pmap_tlb_shootdown(pmap_kernel(), va, *pte,
d3529 1
a3529 1
	bus_addr_t bpa;
d3539 1
a3539 1
		bpa = (bus_addr_t)ISA_PHYSADDR(bsh);
d3575 1
a3575 1
	bus_addr_t bpa;
d3583 1
a3583 1
		bpa = (bus_addr_t)ISA_PHYSADDR(bsh);
d3606 1
a3606 1
	if (adrp != NULL) {
a3607 1
	}
d3649 1
d3665 11
d3686 2
d3692 43
d3765 1
a3765 1
	bus_addr_t lastaddr;
d3946 1
d3954 1
a3954 1
_bus_dmamap_sync(t, map, addr, size, op)
d3957 1
a3957 1
	bus_addr_t addr;
d3961 13
d3975 20
a3994 1
	/* Nothing to do here. */
d4164 2
a4165 2
	bus_addr_t curaddr, lastaddr, baddr, bmask;
	vaddr_t vaddr = (vaddr_t)buf;
d4181 18
a4198 1
		pmap_extract(pmap, vaddr, (paddr_t *)&curaddr);
d4222 1
d4224 2
d4239 1
d4241 2
d4285 13
a4342 1

@


1.351
log
@move the mp tramp higher to avoid trashing boot args and also to fight strange memory zeroing happennning on some amd machines; toby@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.350 2006/03/20 12:08:59 dlg Exp $	*/
a1635 2
		if (family < CPU_MINFAMILY)
			panic("identifycpu: strange family value");
d1645 2
@


1.350
log
@a bit of demagification. this moves the checks for the cpu scaling features
out of machdep and into powernow-k7 and -k8. machdep now just figures out
if its the right type of cpu before calling the powernow code which
figures out if the scaling is supported.

from gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.349 2006/03/16 22:23:26 deraadt Exp $	*/
d2943 3
a2945 3
			/* skip first four pages */
			if (a < 5 * NBPG)
				a = 5 * NBPG;
@


1.349
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.348 2006/03/16 22:21:39 dim Exp $	*/
d1414 1
a1414 1
	u_int regs[4];
d1421 1
d1423 7
a1429 14
	cpuid(0x80000000, regs);
	if (regs[0] > 0x80000007) {
		cpuid(0x80000007, regs);

		if (regs[3] & 0x06) {
			switch (ci->ci_signature & 0xF00) {
			case 0x600:
				k7_powernow_init();
				break;
			case 0xf00:
				k8_powernow_init();
				break;
			}
		}
@


1.348
log
@Fix for PR 4966: Only disregard bit 27 of MSR_EBL_CR_POWERON for
specific Pentium III models (early stepping 1 Coppermines).

"go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.347 2006/03/16 02:55:52 dlg Exp $	*/
d1427 1
a1427 1
			switch(ci->ci_signature & 0xF00) {
d1430 1
a1430 1
			break;
d1433 1
a1433 1
			break;
d1944 1
a1944 1
	switch(model) {
@


1.347
log
@remove useless powernow cruft from dmesg. we're interested in the
available speed states (which is output separately), not if the cpu can
support them even if the speedstates are not provided.

from gwk, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.346 2006/03/15 21:03:38 deraadt Exp $	*/
d253 1
a253 1
int p3_step;
d1508 1
a1508 1
	p3_step = step;
d2021 1
a2021 1
	if (p3_step > 1)
@


1.346
log
@use sysctl_int_lower() for the aperture variable.  This lets root close
the aperture without having to reboot, but does not allow re-opening;
ok matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.345 2006/03/14 09:02:29 mickey Exp $	*/
a1405 5
struct amd_pn_flag {
	int mask;
	const char *name;
};

a1413 8
	static struct amd_pn_flag amd_pn_flags[] = {
	    {0x01, "TS"},
	    {0x02, "FID"},
	    {0x04, "VID"},
	    {0x08, "TTP"},
	    {0x10, "TM"},
	    {0x20, "STC"}
	};
a1414 1
	int i;
a1424 6
		printf("%s: AMD Powernow:", ci->ci_dev.dv_xname);
		for (i = 0; i < 6; i++) {
			if (regs[3] & amd_pn_flags[i].mask)
				printf(" %s", amd_pn_flags[i].name);
		}
		printf("\n");
a1425 1
#if !defined(MULTIPROCESSOR)
a1435 1
#endif 
@


1.345
log
@move the kernel 1m up to provide more space for isadma; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.344 2006/03/08 13:52:34 kettenis Exp $	*/
d3279 2
a3280 2
			return (sysctl_rdint(oldp, oldlenp, newp,
			    allowaperture));
@


1.344
log
@Really unbreak GENERIC.MP.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.343 2006/03/08 08:18:24 deraadt Exp $	*/
d2806 1
a2806 1
	int i;
d3017 9
@


1.343
log
@unbreak GENERIC.MP; from gklok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.342 2006/03/08 03:33:21 uwe Exp $	*/
d1418 1
d1429 1
@


1.342
log
@Patch from Gordon Klock to update AMD PowerNow K8 support on i386,
and to add amd64 K8 support from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.341 2006/03/07 05:18:08 jsg Exp $	*/
d1444 1
d1455 1
@


1.341
log
@Check for a few additional CPUID flags.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.340 2006/02/22 22:16:05 miod Exp $	*/
d1433 1
d1455 1
@


1.340
log
@Remove unused _{ins,rem}que functions - they were not even implemented on
all architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.339 2006/01/12 22:39:20 weingart Exp $	*/
d1115 1
d1131 2
d1136 1
@


1.339
log
@Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.338 2006/01/06 10:53:16 grange Exp $	*/
a3079 39
}

struct queue {
	struct queue *q_next, *q_prev;
};

/*
 * insert an element into a queue
 */
void
_insque(v1, v2)
	void *v1;
	void *v2;
{
	register struct queue *elem = v1, *head = v2;
	register struct queue *next;

	next = head->q_next;
	elem->q_next = next;
	head->q_next = elem;
	elem->q_prev = head;
	next->q_prev = elem;
}

/*
 * remove an element from a queue
 */
void
_remque(v)
	void *v;
{
	register struct queue *elem = v;
	register struct queue *next, *prev;

	next = elem->q_next;
	prev = elem->q_prev;
	next->q_prev = prev;
	prev->q_next = next;
	elem->q_prev = 0;
@


1.338
log
@Err, commited from the wrong tree
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.337 2006/01/06 10:42:34 grange Exp $	*/
d491 1
d516 1
a2088 1
	struct pmap *pmap = vm_map_pmap(&p->p_vmspace->vm_map);
d2184 1
a2184 2
	tf->tf_cs = pmap->pm_hiexec > I386_MAX_EXE_ADDR ?
	    GSEL(GUCODE1_SEL, SEL_UPL) : GSEL(GUCODE_SEL, SEL_UPL);
d2594 24
d2632 1
a2632 2
	tf->tf_cs = pmap->pm_hiexec > I386_MAX_EXE_ADDR ?
	    LSEL(LUCODE1_SEL, SEL_UPL) : LSEL(LUCODE_SEL, SEL_UPL);
d2765 26
a2826 2
	setsegment(&gdt[GUCODE1_SEL].sd, 0, atop(VM_MAXUSER_ADDRESS) - 1,
	    SDT_MEMERA, SEL_UPL, 1, 1);
a2836 1
	ldt[LUCODE1_SEL] = gdt[GUCODE1_SEL];
@


1.337
log
@Fix acpi includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.336 2005/12/16 22:43:12 marco Exp $	*/
a136 1
#include <dev/acpi/acpireg.h>
@


1.336
log
@Add delay before powering down on acpi.  Give the sync some extra time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.335 2005/12/16 20:32:20 marco Exp $	*/
d137 1
@


1.335
log
@Forgot to check a flag to powerdown via acpi.

ok deraadt@@ jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.334 2005/12/16 19:00:30 marco Exp $	*/
d2329 1
@


1.334
log
@Power down machine from acpi.

Help deraadt, ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.333 2005/11/23 09:32:46 mickey Exp $	*/
d2329 1
a2329 1
		if (acpi_s5)
@


1.333
log
@prioritise <16m memory for isa bus_dma'ble memorble memory allocations
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.332 2005/11/18 17:11:57 brad Exp $	*/
d135 5
d2326 7
@


1.332
log
@add some comments explaining the general CPU reset code and the AMD Geode
SC1100 specific reset code.

From NetBSD

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.331 2005/11/13 17:24:31 martin Exp $	*/
d4163 1
d4166 1
d4168 5
a4172 3
	TAILQ_INIT(&mlist);
	error = uvm_pglistalloc(size, low, high,
	    alignment, boundary, &mlist, nsegs, (flags & BUS_DMA_NOWAIT) == 0);
@


1.331
log
@need cast to vaddr_t

found the hard way by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.330 2005/11/13 14:23:26 martin Exp $	*/
d1315 15
a1329 1
	/* reset control SC1100 (datasheet page 170) */
a1330 1
	/* system wide reset */
d3119 5
a3123 1
	/* Toggle the hardware reset line on the keyboard controller. */
@


1.330
log
@convert more MD macros to their MI counterparts, this time
i386_round_page(), i386_trunc_page(), i386_btop() and i386_ptob()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.329 2005/11/10 14:32:38 mickey Exp $	*/
d2850 3
a2852 2
	   round_page(bootargv + bootargc), VM_PROT_READ|VM_PROT_WRITE,
	   VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
@


1.329
log
@make sure to ignore >4g and split on 4g memory segments from the bios map; tom@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.328 2005/11/04 06:55:35 tedu Exp $	*/
d2696 1
a2696 1
	pte = PTE_BASE + i386_btop(va);
d2752 1
a2752 1
	setsegment(&gdt[GUCODE1_SEL].sd, 0, i386_btop(VM_MAXUSER_ADDRESS) - 1,
d2754 1
a2754 1
	setsegment(&gdt[GUCODE_SEL].sd, 0, i386_btop(I386_MAX_EXE_ADDR) - 1,
d2756 1
a2756 1
	setsegment(&gdt[GUDATA_SEL].sd, 0, i386_btop(VM_MAXUSER_ADDRESS) - 1,
d2850 1
a2850 1
	   i386_round_page(bootargv + bootargc), VM_PROT_READ|VM_PROT_WRITE,
d2878 1
a2878 1
			a = i386_round_page(im->addr);
d2880 1
a2880 1
				e = i386_trunc_page(im->addr + im->size);
d2920 1
a2920 1
	avail_end -= i386_round_page(MSGBUFSIZE);
d3445 2
a3446 2
	pa = i386_trunc_page(bpa);
	endpa = i386_round_page(bpa + size);
d3514 2
a3515 2
		va = i386_trunc_page(bsh);
		endva = i386_round_page(bsh + size);
d3558 2
a3559 2
		va = i386_trunc_page(bsh);
		endva = i386_round_page(bsh + size);
d4017 1
a4017 1
		return (i386_btop((caddr_t)segs[i].ds_addr + off));
@


1.328
log
@only build powernow pieces as appropriate for config'd cpu types
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.327 2005/10/28 07:03:41 tedu Exp $	*/
d2867 10
d2879 9
a2887 1
			e = i386_trunc_page(im->addr + im->size);
a2890 3
#ifdef DEBUG
			printf(" %u-%u", a, e);
#endif
@


1.327
log
@update support for powernow (cool and quiet) on k7, and add support
for k8.  preliminary and not well tested yet.  from freebsd via
gordon klok.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.326 2005/10/26 20:32:59 marco Exp $	*/
d1375 1
a1375 1
#ifndef SMALL_KERNEL
@


1.326
log
@Add basic handler for MCE and MCA.  Written mostly by toby@@ and commiting for
toby@@ per his request.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.325 2005/09/23 02:03:44 brad Exp $	*/
d1419 10
a1428 4
#ifndef MULTIPROCESSOR
		if (regs[3] & 0x06)
			k7_powernow_init(curcpu()->ci_signature);
#endif
@


1.325
log
@- fix PowerNow flags, cosmetic, only affects dmesg output.
- k7_powernow_init() uses globals making it not SMP safe.
  so do not call k7_powernow_init() with multi-processor
  kernels for now.

From Gordon Willem Klok <gklok at cogeco dot ca>

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.324 2005/08/20 00:27:08 jsg Exp $	*/
d2661 2
a2662 2
    IDTVEC(rsvd), IDTVEC(fpu), IDTVEC(align), IDTVEC(syscall),
    IDTVEC(osyscall);
d2782 3
a2784 2
	setgate(&idt[ 18], &IDTVEC(rsvd),    0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	for (i = 19; i < NRSVIDT; i++)
@


1.324
log
@PNI was changed to be known as SSE3 by Intel so make
a similiar change when reporting CPU features here.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.323 2005/08/06 14:26:52 miod Exp $	*/
d1395 6
a1400 6
	    {0, "TS"},
	    {1, "FID"},
	    {2, "VID"},
	    {4, "TTP"},
	    {8, "TM"},
	    {16, "STC"}
d1418 3
a1420 1
		if (regs[3] & 6)
d1422 1
@


1.324.2.1
log
@MFC:
Fix by weingart@@

Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.324 2005/08/20 00:27:08 jsg Exp $	*/
a485 1
	pcb->pcb_ldt = ldt;
a509 1
	pcb->pcb_ldt = ci->ci_ldt;
d2060 1
d2156 2
a2157 1
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
a2558 24
	/*
	 * Reset the code segment limit to I386_MAX_EXE_ADDR in the pmap;
	 * this gets copied into the GDT and LDT for {G,L}UCODE_SEL by
	 * pmap_activate().
	 */
	setsegment(&pmap->pm_codeseg, 0, atop(I386_MAX_EXE_ADDR) - 1,
	    SDT_MEMERA, SEL_UPL, 1, 1);

	/*
	 * And update the GDT and LDT since we return to the user process
	 * by leaving the syscall (we don't do another pmap_activate()).
	 */
#ifdef MULTIPROCESSOR
	curcpu()->ci_gdt[GUCODE_SEL].sd = pcb->pcb_ldt[LUCODE_SEL].sd =
	    pmap->pm_codeseg;
#else
	gdt[GUCODE_SEL].sd = pcb->pcb_ldt[LUCODE_SEL].sd = pmap->pm_codeseg;
#endif

	/*
	 * And reset the hiexec marker in the pmap.
	 */
	pmap->pm_hiexec = 0;

d2573 2
a2574 1
	tf->tf_cs = LSEL(LUCODE_SEL, SEL_UPL);
a2706 26

void
cpu_default_ldt(struct cpu_info *ci)
{
	ci->ci_ldt = ldt;
	ci->ci_ldt_len = sizeof(ldt);
}

void
cpu_alloc_ldt(struct cpu_info *ci)
{
	union descriptor *cpu_ldt;
	size_t len = sizeof(ldt);

	cpu_ldt = (union descriptor *)uvm_km_alloc(kernel_map, len);
	bcopy(ldt, cpu_ldt, len);
	ci->ci_ldt = cpu_ldt;
	ci->ci_ldt_len = len;
}

void
cpu_init_ldt(struct cpu_info *ci)
{
	setsegment(&ci->ci_gdt[GLDT_SEL].sd, ci->ci_ldt, ci->ci_ldt_len - 1,
	    SDT_SYSLDT, SEL_KPL, 0, 0);
}
d2743 2
d2755 1
@


1.323
log
@We do not need a char machine_arch[] constant.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.322 2005/07/18 14:55:49 mickey Exp $	*/
d1121 1
a1121 1
	{ CPUIDECX_PNI,		"PNI" },
@


1.322
log
@save/restore fpu for the signal handler call in the trampoline.
modeled after sparc together w/ deraadt@@; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.321 2005/06/26 19:23:53 deraadt Exp $	*/
d184 1
a184 2
char machine[] = "i386";		/* cpu "architecture" */
char machine_arch[] = "i386";		/* machine == machine_arch */
@


1.321
log
@cpu0: RNG AES AES-CTR SHA1 SHA256 RSA
on fancy new VIA C3 Esther (aka C7) cpus
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.320 2005/06/01 16:41:03 mickey Exp $	*/
d2057 3
d2065 1
d2078 1
a2078 2
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size - sizeof(struct sigframe));
d2080 8
a2087 2
	} else {
		fp = (struct sigframe *)tf->tf_esp - 1;
d2090 1
d2159 4
@


1.320
log
@kjell is an evil tree-breaker
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.319 2005/05/28 09:48:54 kjell Exp $	*/
d1201 1
a1201 1
		if (val & 0x44/*???*/)
d1203 1
d1205 1
a1205 1
		if (val & 0x4) {
d1208 1
a1208 1
			if (!(val & 0x8)) {
d1216 1
d1218 1
a1218 1
		if (val & 0x40) {
d1220 1
a1220 1
			if (!(val & 0x80)) {
d1229 14
a1242 1
#if 0
d1244 1
a1244 1
		if (val & 0x40/**/) {
d1246 1
a1246 1
			if (!(val & 0x80/**/)) {
d1255 1
a1255 2
#endif
#if 0
d1257 1
a1257 1
		if (val & 0x40/*???*/) {
d1259 1
a1259 1
			if (!(val & 0x80/**/)) {
d1268 1
a1268 1
#endif
@


1.319
log
@move variable declaration inside #ifdef I386_686, etc.
Prompting from Chris Cappuccio.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.318 2005/05/27 10:41:11 kjell Exp $	*/
d1149 2
a1150 4
	int model, step;

	model = (ci->ci_signature >> 4) & 15;
	step = ci->ci_signature & 15;
a1414 6
	/*
	 * Make sure SYSENTER is disabled.
	 */
	if (cpu_feature & CPUID_SEP)
		wrmsr(MSR_SYSENTER_CS, 0);

d1440 5
@


1.318
log
@Enable SSE instructions on secondary (i386) processors in
a multiprocessor boot.

This fixes the hardware AES (and likely RNG) instruction on the dual VIA,
which was failing because the SSE/SSE2 extensions are never enabled on
any processor but the boot processor.

Much assistance from niklas, and the eureka moment from theo.

"commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.317 2005/04/02 02:44:58 tedu Exp $	*/
d1148 1
a1153 1
#if defined(I686_CPU)
a1415 2
	int model = (ci->ci_signature >> 4) & 15;
	int step = ci->ci_signature & 15;
d1424 3
@


1.317
log
@find cachesize for amd cpus too.  ok deraadt tom
bit more info about powernow, and only try to enable if cpu supports it.
both from diffs by gordon klok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.316 2005/02/24 21:14:11 grange Exp $	*/
d322 11
a332 11
void	winchip_cpu_setup(const char *, int, int);
void	amd_family5_setup(const char *, int, int);
void	amd_family6_setup(const char *, int, int);
void	cyrix3_cpu_setup(const char *, int, int);
void	cyrix6x86_cpu_setup(const char *, int, int);
void	natsem6x86_cpu_setup(const char *, int, int);
void	intel586_cpu_setup(const char *, int, int);
void	intel686_common_cpu_setup(const char *, int, int);
void	intel686_cpu_setup(const char *, int, int);
void	intel686_p4_cpu_setup(const char *, int, int);
void	tm86_cpu_setup(const char *, int, int);
d1130 1
a1130 3
winchip_cpu_setup(cpu_device, model, step)
	const char *cpu_device;
	int model, step;
d1134 1
a1134 1
	switch ((curcpu()->ci_signature >> 4) & 15) { /* model */
d1136 1
a1136 1
		curcpu()->ci_feature_flags &= ~CPUID_TSC;
d1139 1
a1139 1
		printf("%s: TSC disabled\n", cpu_device);
d1146 2
a1147 2
cyrix3_cpu_setup(cpu_device, model, step)
	const char *cpu_device;
d1149 4
a1152 1
{
d1203 2
a1205 2
		if (val & 0x44/*???*/)
			printf("%s:", cpu_device);
a1216 1

d1264 1
a1264 3
cyrix6x86_cpu_setup(cpu_device, model, step)
	const char *cpu_device;
	int model, step;
d1269 1
a1269 1
	switch ((curcpu()->ci_signature >> 4) & 15) { /* model */
d1285 2
a1286 1
		printf("%s: xchg bug workaround performed\n", cpu_device);
d1292 1
a1292 1
		printf("%s: TSC disabled\n", cpu_device);
d1312 1
a1312 3
natsem6x86_cpu_setup(cpu_device, model, step)
	const char *cpu_device;
	int model, step;
d1316 1
d1322 1
a1322 1
		printf("%s: TSC disabled\n", cpu_device);
d1331 1
a1331 3
intel586_cpu_setup(cpu_device, model, step)
	const char *cpu_device;
	int model, step;
d1336 2
a1337 1
		printf("%s: F00F bug workaround installed\n", cpu_device);
d1343 1
a1343 3
amd_family5_setup(cpu_device, model, step)
	const char *cpu_device;
	int model, step;
d1345 2
d1377 1
a1377 3
amd_family6_setup(cpu_device, model, step)
	const char *cpu_device;
	int model, step;
d1401 1
a1401 1
		printf("%s: AMD Powernow:", cpu_device);
d1414 1
a1414 1
intel686_common_cpu_setup(const char *cpu_device, int model, int step)
d1416 3
d1428 1
a1428 1
			est_init(cpu_device);
d1431 1
a1431 1
			    cpu_device);
d1450 1
a1450 1
intel686_cpu_setup(const char *cpu_device, int model, int step)
d1452 2
a1453 3
	struct cpu_info *ci = curcpu();
	/* XXX SMP int model = (ci->ci_signature >> 4) & 15; */
	/* XXX SMP int step = ci->ci_signature & 15; */
d1456 1
a1456 1
	intel686_common_cpu_setup(cpu_device, model, step);
d1473 2
a1474 1
		printf("%s: disabling processor serial number\n", cpu_device);
d1486 1
a1486 1
intel686_p4_cpu_setup(const char *cpu_device, int model, int step)
d1488 1
a1488 1
	intel686_common_cpu_setup(cpu_device, model, step);
d1491 1
a1491 1
	p4_model = model;
d1497 1
a1497 3
tm86_cpu_setup(cpu_device, model, step)
	const char *cpu_device;
	int model, step;
d1805 1
a1805 1
		(ci->cpu_setup)(cpu_device, model, step);
@


1.316
log
@Don't use inline assembly for cpuid instruction, it clobbers
registers that are used by gcc. Use cpuid() function instead like all
others do.
Problem noticed by david@@.

ok tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.315 2005/01/07 02:03:17 pascoe Exp $	*/
d1374 5
d1388 10
d1403 12
a1414 1
	k7_powernow_init(curcpu()->ci_signature);
d1699 1
a1699 1
	/* Find the amount of on-chip L2 cache.  Add support for AMD K6-3...*/
d1707 7
@


1.316.2.1
log
@MFC:
Fix by weingart@@

Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.316 2005/02/24 21:14:11 grange Exp $	*/
a486 1
	pcb->pcb_ldt = ldt;
a510 1
	pcb->pcb_ldt = ci->ci_ldt;
d2017 1
d2106 2
a2107 1
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
a2504 24
	/*
	 * Reset the code segment limit to I386_MAX_EXE_ADDR in the pmap;
	 * this gets copied into the GDT and LDT for {G,L}UCODE_SEL by
	 * pmap_activate().
	 */
	setsegment(&pmap->pm_codeseg, 0, atop(I386_MAX_EXE_ADDR) - 1,
	    SDT_MEMERA, SEL_UPL, 1, 1);

	/*
	 * And update the GDT and LDT since we return to the user process
	 * by leaving the syscall (we don't do another pmap_activate()).
	 */
#ifdef MULTIPROCESSOR
	curcpu()->ci_gdt[GUCODE_SEL].sd = pcb->pcb_ldt[LUCODE_SEL].sd =
	    pmap->pm_codeseg;
#else
	gdt[GUCODE_SEL].sd = pcb->pcb_ldt[LUCODE_SEL].sd = pmap->pm_codeseg;
#endif

	/*
	 * And reset the hiexec marker in the pmap.
	 */
	pmap->pm_hiexec = 0;

d2519 2
a2520 1
	tf->tf_cs = LSEL(LUCODE_SEL, SEL_UPL);
a2652 26

void
cpu_default_ldt(struct cpu_info *ci)
{
	ci->ci_ldt = ldt;
	ci->ci_ldt_len = sizeof(ldt);
}

void
cpu_alloc_ldt(struct cpu_info *ci)
{
	union descriptor *cpu_ldt;
	size_t len = sizeof(ldt);

	cpu_ldt = (union descriptor *)uvm_km_alloc(kernel_map, len);
	bcopy(ldt, cpu_ldt, len);
	ci->ci_ldt = cpu_ldt;
	ci->ci_ldt_len = len;
}

void
cpu_init_ldt(struct cpu_info *ci)
{
	setsegment(&ci->ci_gdt[GLDT_SEL].sd, ci->ci_ldt, ci->ci_ldt_len - 1,
	    SDT_SYSLDT, SEL_KPL, 0, 0);
}
d2689 2
d2701 1
@


1.315
log
@Fix profiled kernel builds on i386 by moving splraise/splx code into macros
permitting non-recursive reuse in mcount.

Should be a no-op for normal builds.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.314 2004/12/24 21:22:00 pvalchev Exp $	*/
d1154 1
d1167 2
a1168 2
		__asm __volatile("cpuid"
		    : "=d" (val) : "a" (0x80000001) : "ebx", "ecx");
d1194 2
a1195 2
		__asm __volatile("cpuid" /* Check for RNG */
		    : "=a" (val) : "a" (0xC0000000) : "cc");
d1197 2
a1198 2
			__asm __volatile("cpuid"
			    : "=d" (val) : "a" (0xC0000001) : "cc");
@


1.314
log
@Rewrite intlock/intunlock not to pass around interrupt frame directly
without copying which is against C conventions and broke GENERIC.MP
with a gcc3 optimization
From niklas, tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.313 2004/12/06 23:40:44 hshoexer Exp $	*/
d4188 1
a4188 1
	int ocpl = lapic_tpr;
d4190 1
a4190 2
	if (ncpl > ocpl)
		lapic_tpr = ncpl;
d4202 1
a4202 3
	lapic_tpr = ncpl;
	if (ipending & IUNMASK(ncpl))
		Xspllower();
@


1.313
log
@set granularity for data segment used for struct cpu_info to bytes.
ok mickey deraadt tedu niklas
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.312 2004/12/02 19:40:43 miod Exp $	*/
d4122 1
a4122 1
i386_intlock(struct intrframe iframe)
d4124 1
a4124 1
	if (iframe.if_ppl < IPL_SCHED)
d4133 1
a4133 1
i386_intunlock(struct intrframe iframe)
d4135 1
a4135 1
	if (iframe.if_ppl < IPL_SCHED)
@


1.312
log
@We do not support 2MB machines, so don't bother taking them into account
in allocsys().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.311 2004/11/09 19:17:01 claudio Exp $	*/
d2695 1
a2695 1
	    sizeof(struct cpu_info)-1, SDT_MEMRWA, SEL_KPL, 1, 1);
@


1.311
log
@Do not map empty mbufs (m_len == 0) in bus_dmamap_load_mbuf() as these mappings
may disturb the dma as seen in ipw(4). Emtpy mbufs are at the beginning of the
mbuf chain and are as example a "side-effect" of a previous m_adj() call.
OK miod@@ mickey@@ jason@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.310 2004/11/02 21:20:59 miod Exp $	*/
d548 2
a549 5
		if (physmem < btoc(2 * 1024 * 1024))
			bufpages = physmem / 10;
		else
			bufpages = (btoc(2 * 1024 * 1024) + physmem) *
			    bufcachepercent / 100;
@


1.310
log
@Remove __HAVE_NWSCONS and related remnants of pre-wscons days; no functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.309 2004/08/24 05:15:50 mickey Exp $	*/
d3657 2
@


1.309
log
@fix the microtime renaming leftover; from Emil Mikulic <g5ba9cd0@@dmr.ath.cx>; pr3893; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.308 2004/07/16 06:02:47 david Exp $	*/
a3001 14

#if (NPCKBC > 0) && (NPCKBD == 0)
/*
 * glue code to support old console code with the
 * mi keyboard controller driver
 */
int
pckbc_machdep_cnattach(kbctag, kbcslot)
	pckbc_tag_t kbctag;
	pckbc_slot_t kbcslot;
{
	return (ENXIO);
}
#endif
@


1.308
log
@merge old_identifycpu with identifycpu and remove old_identifycpu
help from Theo, Ted, and Tom
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.306 2004/07/14 05:34:14 tedu Exp $	*/
d2468 1
a2468 1
microtime(tvp)
@


1.307
log
@spaces
@
text
@a278 1
void	old_identifycpu(void);
d385 1
d404 11
a414 2
	/* XXX Merge with identifycpu */
	old_identifycpu();
d449 1
a449 1
		nbuf, bufpages * PAGE_SIZE, bufpages * PAGE_SIZE / 1024);
d1144 1
a1144 1
		printf("%s: TSC disabled\n", curcpu()->ci_dev.dv_xname);
d1289 1
a1289 2
		printf("%s: xchg bug workaround performed\n",
		       curcpu()->ci_dev.dv_xname);
d1342 1
a1342 2
		printf("%s: F00F bug workaround installed\n",
		    curcpu()->ci_dev.dv_xname);
d1430 1
a1430 1
        struct cpu_info *ci = curcpu();
d1452 1
a1452 2
		printf("%s: disabling processor serial number\n",
		       ci->ci_dev.dv_xname);
a1541 2
/* XXXSMP: must be shared with UP */
#ifdef MULTIPROCESSOR
d1572 1
a1574 3
	char *cpu_device = ci->ci_dev.dv_xname;
	/* XXX SMP XXX void (*cpu_setup)(const char *, int, int); */

d1600 1
a1600 1
			model, step);
d1602 2
a1603 2
			cpu_device, cpuid_level, cpu_cache_eax, cpu_cache_ebx,
			cpu_cache_ecx, cpu_cache_edx);
d1657 1
a1657 1
				   model == 7) {
d1661 1
a1661 1
				  family == 5 && model == 4) {
d1679 1
d1703 1
d1707 4
a1710 4
				"%s (%s%s%s%s-class, %dKB L2 cache)",
				cpu_brandstr,
				((*token) ? "\"" : ""), ((*token) ? token : ""),
				((*token) ? "\" " : ""), classnames[class], cachesize);
d1713 4
a1716 4
				"%s (%s%s%s%s-class)",
				cpu_brandstr,
				((*token) ? "\"" : ""), ((*token) ? token : ""),
				((*token) ? "\" " : ""), classnames[class]);
d1751 2
a1752 2
			max = sizeof(i386_cpuid_features)
				/ sizeof(i386_cpuid_features[0]);
d1761 10
d1775 4
a1778 92
	cpu_class = class;
	ci->cpu_class = class;

	/*
	 * Now that we have told the user what they have,
	 * let them know if that machine type isn't configured.
	 */
	switch (cpu_class) {
#if !defined(I386_CPU) && !defined(I486_CPU) && !defined(I586_CPU) && !defined(I686_CPU)
#error No CPU classes configured.
#endif
#ifndef I686_CPU
	case CPUCLASS_686:
		printf("NOTICE: this kernel does not support Pentium Pro CPU class\n");
#ifdef I586_CPU
		printf("NOTICE: lowering CPU class to i586\n");
		cpu_class = CPUCLASS_586;
		break;
#endif
#endif
#ifndef I586_CPU
	case CPUCLASS_586:
		printf("NOTICE: this kernel does not support Pentium CPU class\n");
#ifdef I486_CPU
		printf("NOTICE: lowering CPU class to i486\n");
		cpu_class = CPUCLASS_486;
		break;
#endif
#endif
#ifndef I486_CPU
	case CPUCLASS_486:
		printf("NOTICE: this kernel does not support i486 CPU class\n");
#ifdef I386_CPU
		printf("NOTICE: lowering CPU class to i386\n");
		cpu_class = CPUCLASS_386;
		break;
#endif
#endif
#ifndef I386_CPU
	case CPUCLASS_386:
		printf("NOTICE: this kernel does not support i386 CPU class\n");
		panic("no appropriate CPU class available");
#endif
	default:
		break;
	}

	if (cpu == CPU_486DLC) {
#ifndef CYRIX_CACHE_WORKS
		printf("WARNING: CYRIX 486DLC CACHE UNCHANGED.\n");
#else
#ifndef CYRIX_CACHE_REALLY_WORKS
		printf("WARNING: CYRIX 486DLC CACHE ENABLED IN HOLD-FLUSH MODE.\n");
#else
		printf("WARNING: CYRIX 486DLC CACHE ENABLED.\n");
#endif
#endif
	}

}
#endif	/* MULTIPROCESSOR */

char *
tm86_cpu_name(model)
	int model;
{
	u_int32_t regs[4];
	char *name = NULL;

	cpuid(0x80860001, regs);

	switch(model) {
	case 4:
		if (((regs[1] >> 16) & 0xff) >= 0x3)
			name = "TMS5800";
		else
			name = "TMS5600";
	}

	return name;
}

void
old_identifycpu()
{
	extern char cpu_vendor[];
	extern char cpu_brandstr[];
	extern int cpu_id;
#ifdef CPUDEBUG
	extern int cpu_cache_eax, cpu_cache_ebx, cpu_cache_ecx, cpu_cache_edx;
#else
	extern int cpu_cache_edx;
a1779 200
	const char *name, *modifier, *vendorname, *token;
	const char *cpu_device = "cpu0";
	int class = CPUCLASS_386, vendor, i, max;
	int family, model, step, modif, cachesize;
	const struct cpu_cpuid_nameclass *cpup = NULL;
	void (*cpu_setup)(const char *, int, int);
	char *brandstr_from, *brandstr_to;
	int skipspace;

	if (cpuid_level == -1) {
#ifdef DIAGNOSTIC
		if (cpu < 0 || cpu >=
		    (sizeof i386_nocpuid_cpus/sizeof(struct cpu_nocpuid_nameclass)))
			panic("unknown cpu type %d", cpu);
#endif
		name = i386_nocpuid_cpus[cpu].cpu_name;
		vendor = i386_nocpuid_cpus[cpu].cpu_vendor;
		vendorname = i386_nocpuid_cpus[cpu].cpu_vendorname;
		model = -1;
		step = -1;
		class = i386_nocpuid_cpus[cpu].cpu_class;
		cpu_setup = i386_nocpuid_cpus[cpu].cpu_setup;
		modifier = "";
		token = "";
	} else {
		max = sizeof (i386_cpuid_cpus) / sizeof (i386_cpuid_cpus[0]);
		modif = (cpu_id >> 12) & 3;
		family = (cpu_id >> 8) & 15;
		if (family < CPU_MINFAMILY)
			panic("identifycpu: strange family value");
		model = (cpu_id >> 4) & 15;
		step = cpu_id & 15;
#ifdef CPUDEBUG
		printf("%s: family %x model %x step %x\n", cpu_device, family,
			model, step);
		printf("%s: cpuid level %d cache eax %x ebx %x ecx %x edx %x\n",
			cpu_device, cpuid_level, cpu_cache_eax, cpu_cache_ebx,
			cpu_cache_ecx, cpu_cache_edx);
#endif

		for (i = 0; i < max; i++) {
			if (!strncmp(cpu_vendor,
			    i386_cpuid_cpus[i].cpu_id, 12)) {
				cpup = &i386_cpuid_cpus[i];
				break;
			}
		}

		if (cpup == NULL) {
			vendor = CPUVENDOR_UNKNOWN;
			if (cpu_vendor[0] != '\0')
				vendorname = &cpu_vendor[0];
			else
				vendorname = "Unknown";
			if (family > CPU_MAXFAMILY)
				family = CPU_MAXFAMILY;
			class = family - 3;
			if (class > CPUCLASS_686)
				class = CPUCLASS_686;
			modifier = "";
			name = "";
			token = "";
			cpu_setup = NULL;
		} else {
			token = cpup->cpu_id;
			vendor = cpup->cpu_vendor;
			vendorname = cpup->cpu_vendorname;
			/*
			 * Special hack for the VIA C3 series.
			 *
			 * VIA bought Centaur Technology from IDT in Aug 1999
			 * and marketed the processors as VIA Cyrix III/C3.
			 */
			if (vendor == CPUVENDOR_IDT && family >= 6) {
				vendor = CPUVENDOR_VIA;
				vendorname = "VIA";
			}
			modifier = modifiers[modif];
			if (family > CPU_MAXFAMILY) {
				family = CPU_MAXFAMILY;
				model = CPU_DEFMODEL;
			} else if (model > CPU_MAXMODEL)
				model = CPU_DEFMODEL;
			i = family - CPU_MINFAMILY;

			/* Special hack for the PentiumII/III series. */
			if (vendor == CPUVENDOR_INTEL && family == 6 &&
			    (model == 5 || model == 7)) {
				name = intel686_cpu_name(model);
			/* Special hack for the VIA C3 series. */
			} else if (vendor == CPUVENDOR_VIA && family == 6 &&
				   model == 7) {
				name = cyrix3_cpu_name(model, step);
			/* Special hack for the TMS5x00 series. */
			} else if (vendor == CPUVENDOR_TRANSMETA &&
				  family == 5 && model == 4) {
				name = tm86_cpu_name(model);
			} else
				name = cpup->cpu_family[i].cpu_models[model];
			if (name == NULL) {
				name = cpup->cpu_family[i].cpu_models[CPU_DEFMODEL];
				if (name == NULL)
					name = "";
			}
			class = cpup->cpu_family[i].cpu_class;
			cpu_setup = cpup->cpu_family[i].cpu_setup;
		}
	}

	/* Find the amount of on-chip L2 cache.  Add support for AMD K6-3...*/
	cachesize = -1;
	if (vendor == CPUVENDOR_INTEL && cpuid_level >= 2 && family < 0xf) {
		int intel_cachetable[] = { 0, 128, 256, 512, 1024, 2048 };
		if ((cpu_cache_edx & 0xFF) >= 0x40 &&
		    (cpu_cache_edx & 0xFF) <= 0x45)
			cachesize = intel_cachetable[(cpu_cache_edx & 0xFF) - 0x40];
	}

	/* Remove leading and duplicated spaces from cpu_brandstr */
	brandstr_from = brandstr_to = cpu_brandstr;
	skipspace = 1;
	while (*brandstr_from != '\0') {
		if (!skipspace || *brandstr_from != ' ') {
			skipspace = 0;
			*(brandstr_to++) = *brandstr_from;
		}
		if (*brandstr_from == ' ')
			skipspace = 1;
		brandstr_from++;
	}
	*brandstr_to = '\0';

	if (cpu_brandstr[0] == '\0') {
		snprintf(cpu_brandstr, 48 /* sizeof(cpu_brandstr) */,
		    "%s %s%s", vendorname, modifier, name);
	}

	if (cachesize > -1) {
		snprintf(cpu_model, sizeof(cpu_model),
		    "%s (%s%s%s%s-class, %dKB L2 cache)",
		    cpu_brandstr,
		    ((*token) ? "\"" : ""), ((*token) ? token : ""),
		    ((*token) ? "\" " : ""), classnames[class], cachesize);
	} else {
		snprintf(cpu_model, sizeof(cpu_model),
		    "%s (%s%s%s%s-class)",
		    cpu_brandstr,
		    ((*token) ? "\"" : ""), ((*token) ? token : ""),
		    ((*token) ? "\" " : ""), classnames[class]);
	}

	printf("%s: %s", cpu_device, cpu_model);

#if defined(I586_CPU) || defined(I686_CPU)
	if (cpu_feature & CPUID_TSC) {			/* Has TSC */
		calibrate_cyclecounter();
		if (pentium_mhz > 994) {
			int ghz, fr;

			ghz = (pentium_mhz + 9) / 1000;
			fr = ((pentium_mhz + 9) / 10 ) % 100;
			if (fr)
				printf(" %d.%02d GHz", ghz, fr);
			else
				printf(" %d GHz", ghz);
		} else
			printf(" %d MHz", pentium_mhz);
	}
#endif
	printf("\n");

	if (cpu_feature) {
		int numbits = 0;

		printf("%s: ", cpu_device);
		max = sizeof(i386_cpuid_features)
			/ sizeof(i386_cpuid_features[0]);
		for (i = 0; i < max; i++) {
			if (cpu_feature & i386_cpuid_features[i].feature_bit) {
				printf("%s%s", (numbits == 0 ? "" : ","),
				    i386_cpuid_features[i].feature_name);
				numbits++;
			}
		}
		max = sizeof(i386_cpuid_ecxfeatures)
			/ sizeof(i386_cpuid_ecxfeatures[0]);
		for (i = 0; i < max; i++) {
			if (cpu_ecxfeature &
			    i386_cpuid_ecxfeatures[i].feature_bit) {
				printf("%s%s", (numbits == 0 ? "" : ","),
				    i386_cpuid_ecxfeatures[i].feature_name);
				numbits++;
			}
		}
		printf("\n");
	}

	/* configure the CPU if needed */
	if (cpu_setup != NULL)
		cpu_setup(cpu_device, model, step);
d1834 2
d1852 1
a1852 1
	if (cpu_class >= CPUCLASS_486)
d1878 10
d1889 9
@


1.306
log
@setperf driver for powernow in amd k7 cpus.  derived from a diff to
tech-i386@@netbsd by martin vegiard, and adapted to fit in here.
as yet untested.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.305 2004/07/05 05:18:42 david Exp $	*/
d228 2
a229 2
int 	dumpsize = 0;		/* pages */
long	dumplo = 0; 		/* blocks */
d504 1
a504 1
}  
d554 1
a554 1
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 35 / 100) 
d666 1
a666 1
/*  
d713 1
a713 1
			CPUCLASS_486, 
d804 1
a804 1
			CPUCLASS_486, 
d835 1
a835 1
				"Duron Model 7", 
d928 1
a928 1
			CPUCLASS_486, 
d966 1
a966 1
			CPUCLASS_486, 
d1001 1
a1001 1
			CPUCLASS_486, 
d1130 1
a1130 1
  	switch ((curcpu()->ci_signature >> 4) & 15) { /* model */
d1172 1
a1172 1
		/* 
d1176 1
a1176 1
		/* 
d1264 1
a1264 1
  	switch ((curcpu()->ci_signature >> 4) & 15) { /* model */
d1280 1
a1280 1
		printf("%s: xchg bug workaround performed\n", 
d1334 1
a1334 1
		printf("%s: F00F bug workaround installed\n", 
d1424 1
a1424 1
  	/* XXX SMP int model = (ci->ci_signature >> 4) & 15; */
d1445 1
a1445 1
		printf("%s: disabling processor serial number\n", 
d1552 1
a1552 1
 
d1658 1
a1658 1
			} else if (vendor == CPUVENDOR_TRANSMETA && 
d1745 1
a1745 1
	
d1750 1
a1750 1
				if (ci->ci_feature_flags & 
d1836 1
a1836 1
		else 
d1948 1
a1948 1
			} else if (vendor == CPUVENDOR_TRANSMETA && 
d2278 1
a2278 1
	/* 
d2361 1
a2361 1
	tf->tf_cs = pmap->pm_hiexec > I386_MAX_EXE_ADDR ? 
d2507 1
a2507 1
		 	 * wait a bit first--some disk drives are slow to
d2512 1
a2512 1
		 	 */
d2774 1
a2774 1
	tf->tf_cs = pmap->pm_hiexec > I386_MAX_EXE_ADDR ? 
d3316 1
a3316 1
	tlbflush(); 
d3364 1
a3364 1
/*  
d3366 1
a3366 1
 */ 
d3411 2
a3412 2
		if (securelevel > 0) 
			return (sysctl_rdint(oldp, oldlenp, newp, 
d3415 1
a3415 1
			return (sysctl_int(oldp, oldlenp, newp, newlen, 
d3433 2
a3434 2
		if (securelevel > 0) 
			return (sysctl_rdint(oldp, oldlenp, newp, 
d3437 1
a3437 1
			return (sysctl_int(oldp, oldlenp, newp, newlen, 
d3772 1
a3772 1
void    
@


1.305
log
@sync various changes in old_identifycpu() into identifycpu()
first step toward merging these two functions
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.304 2004/07/02 23:22:58 deraadt Exp $	*/
d1383 1
@


1.304
log
@move into #ifdef; various people
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.303 2004/07/02 16:29:55 niklas Exp $	*/
d1556 1
d1566 2
d1620 2
d1630 10
d1652 8
d1662 1
a1662 1
			if (name == NULL)
d1664 3
d1681 18
d1702 2
a1703 2
				"%s %s%s (%s%s%s%s-class, %dKB L2 cache)",
				vendorname, modifier, name,
d1708 2
a1709 2
				"%s %s%s (%s%s%s%s-class)",
				vendorname, modifier, name,
@


1.303
log
@Maintain %f and %gs over traps.  Mostly from NetBSD.  Preparation for SMP
speedups.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.302 2004/06/28 20:51:02 deraadt Exp $	*/
d1146 1
a1147 1
#if defined(I686_CPU)
@


1.302
log
@er this is better...
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.301 2004/06/28 17:38:04 deraadt Exp $	*/
d2271 2
a2272 2
		__asm("movw %%gs,%w0" : "=r" (frame.sf_sc.sc_gs));
		__asm("movw %%fs,%w0" : "=r" (frame.sf_sc.sc_fs));
d2311 2
a2312 2
	__asm("movw %w0,%%gs" : : "r" (GSEL(GUDATA_SEL, SEL_UPL)));
	__asm("movw %w0,%%fs" : : "r" (GSEL(GUDATA_SEL, SEL_UPL)));
d2379 2
a2380 1
		/* %fs and %gs were restored by the trampoline. */
d2722 2
a2723 2
	__asm("movw %w0,%%gs" : : "r" (LSEL(LUDATA_SEL, SEL_UPL)));
	__asm("movw %w0,%%fs" : : "r" (LSEL(LUDATA_SEL, SEL_UPL)));
d2873 1
a2873 1
	curpcb = &proc0.p_addr->u_pcb;
@


1.301
log
@remove dup variable
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.300 2004/06/22 08:58:16 mickey Exp $	*/
a1145 1
#ifdef CRYPTO
a1146 1
#endif
@


1.300
log
@make sure real/avail mem printfs do unsigned ariths; found by beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.299 2004/06/15 23:36:55 deraadt Exp $	*/
a1203 2
				u_int64_t msreg;

@


1.299
log
@first parts of how C3 Esther will be handled; ok tom
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.298 2004/06/15 21:12:31 tom Exp $	*/
d406 1
a406 1
	printf("real mem  = %u (%uK)\n", ctob(physmem), ctob(physmem)/1024);
d438 1
a438 1
	    ptoa(uvmexp.free)/1024);
@


1.298
log
@Be more careful about what value we check for crypto capability bits
if the first cpuid returns too low a number.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.297 2004/06/13 21:49:15 niklas Exp $	*/
d954 1
a954 1
				"C3 Nehemiah", 0, 0, 0, 0, 0, 0,
d1146 3
a1157 1

a1173 1

d1175 5
a1179 1
		 * C3 Nehemiah:
d1194 1
a1194 1
		} else {
a1195 1
		}
d1198 1
a1198 1
		if (val & 0x44)
a1216 2
			extern int viac3_crypto_present;

a1217 2
				u_int64_t msreg;

d1222 1
a1222 1
			viac3_crypto_present = 1;
d1226 28
a1253 1

@


1.297
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1189 2
@


1.296
log
@we trust the calibrated pentium_mhz more, so don't overwrite it unless
we know the cpu speed has changed.  fixes pr3814 from mark pecaut.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.295 2004/06/06 17:34:37 grange Exp $	*/
d118 1
d252 3
d279 1
a279 1
void	identifycpu(void);
d404 2
a405 1
	identifycpu();
d466 1
a467 1
	int x;
d470 1
d481 2
a482 1
	tss_alloc(pcb);
d484 1
a484 1
	ltr(pcb->pcb_tss_sel);
d486 20
a506 2
	proc0.p_md.md_regs = (struct trapframe *)pcb->pcb_tss.tss_esp0 - 1;
}
d1130 1
a1130 1
	switch (model) {
d1132 1
a1132 1
		cpu_feature &= ~CPUID_TSC;
d1135 1
a1135 2

		printf("%s: TSC disabled\n", cpu_device);
d1239 1
a1239 1
	switch (model) {
d1255 2
a1256 1
		printf("%s: xchg bug workaround performed\n", cpu_device);
d1258 2
a1259 1
	case 4:
d1261 1
a1261 1
		cpu_feature &= ~CPUID_TSC;
d1307 5
a1311 2
	fix_f00f();
	printf("%s: F00F bug workaround installed\n", cpu_device);
d1397 3
d1409 1
a1409 1
		cpu_feature &= ~CPUID_SEP;
d1414 1
a1414 1
	if ((model == 7) && (cpu_feature & CPUID_SER)) {
d1419 4
a1422 3
		printf("%s: disabling processor serial number\n", cpu_device);
		cpu_feature &= ~CPUID_SER;
		cpuid_level = 2;
d1510 243
d1774 1
a1774 1
identifycpu()
d2681 2
a2682 2
	if (npxproc == p)
		npxdrop();
a2715 1
union descriptor gdt[NGDT];
d2740 14
d2813 2
a2814 2
	setgate(&idt[ 14], &IDTVEC(f00f_redirect), 0, SDT_SYS386TGT,
		SEL_KPL, GCODE_SEL);
d2829 10
d2867 1
a2867 1
	/* make gdt gates and memory segments */
d2871 2
a2872 2
	setsegment(&gdt[GLDT_SEL].sd, ldt, sizeof(ldt) - 1, SDT_SYSLDT, SEL_KPL,
	    0, 0);
d2879 2
d2910 1
a2910 1
	for (i = 19; i < NIDT; i++)
d2912 2
d2916 1
a2916 1
	setregion(&region, gdt, sizeof(gdt) - 1);
d2967 8
d2991 2
a2992 2
			if (a < 4 * NBPG)
				a = 4 * NBPG;
d3251 42
d3354 1
a3354 1
		return (sysctl_rdint(oldp, oldlenp, newp, cpu_feature));
d3560 3
d3595 4
d3600 1
d3603 3
d4312 46
a4357 3
	if (cpl < wantipl) {
		splassert_fail(wantipl, cpl, func);
	}
d4367 9
a4375 5
softintr(mask)
	int mask;
{
	__asm __volatile("orl %1, %0" : "=m"(ipending) : "ir" (mask));

d4385 1
a4385 1
	int ocpl = cpl;
d4388 1
a4388 1
		cpl = ncpl;
d4400 1
a4400 1
	cpl = ncpl;
d4413 1
a4413 1
	int ocpl = cpl;
d4418 1
@


1.295
log
@Don't touch any hardware registers while fetching hw.cpuspeed and
just return current pentium_mhz value. Update this value in
all hw.setperf hoos either via its own private methods or using
global update_cpuspeed hook, if registered.
Also implement update_cpuspeed hook for Pentium 3.

Tested by millert@@, Gabriel Kihlman <gk@@stacken.kth.se> and me on
various i386 machines.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.294 2004/05/23 20:28:46 tedu Exp $	*/
a1394 1
	update_cpuspeed();
a1405 1
	update_cpuspeed();
@


1.294
log
@don't need backslashes in splx.  spotted otto
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.293 2004/05/23 00:06:01 tedu Exp $	*/
d248 1
d251 2
d333 2
a334 1
int	p4_cpuspeed(int *);
d1391 6
d1405 3
a1407 4
	if (cpu_cpuspeed == NULL) {
		p4_model = model;
		cpu_cpuspeed = p4_cpuspeed;
	}
d1713 1
a1713 1
	if (cpu_cpuspeed == NULL && pentium_mhz != 0)
d1811 2
a1812 2
int
p4_cpuspeed(int *freq)
d1815 1
a1815 1
	int bus, mult;
d1843 1
a1843 1
	*freq = bus * mult;
d1846 31
a1876 1
		*freq += mult / 3;
d1878 1
a1878 1
	return (0);
@


1.293
log
@workaround gcc brokenness by outlining spl functions.
finally solves vfs corruption.  hint and ok art@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.292 2004/05/19 18:17:00 tedu Exp $	*/
d3948 7
a3954 7
void									\
splx(ncpl)								\
	int ncpl;							\
{									\
	cpl = ncpl;							\
	if (ipending & IUNMASK(ncpl))					\
		Xspllower();						\
a3969 1

@


1.292
log
@stupid typo that prevented i686 pagezero code from being used.  from art
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.291 2004/05/04 17:06:33 grange Exp $	*/
d3917 54
a3970 2
/* If SMALL_KERNEL this results in an out of line definition of splx.  */
SPLX_OUTLINED_BODY
@


1.291
log
@Move _bus_space_unmap() to machdep.c so it can be used not
only by the rbus code. Also knf it and sync with bus_space_unmap().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.290 2004/04/19 22:26:22 tom Exp $	*/
a1356 1
	pagezero = bzero;
@


1.290
log
@Report when VIA AES is present, even if we're not going to use it because
CRYPTO is not defined

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.289 2004/04/11 18:12:10 deraadt Exp $	*/
d3257 41
@


1.289
log
@move via-specific chunks to own file
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.288 2004/04/02 22:28:40 tedu Exp $	*/
a1179 1
#ifdef CRYPTO
d1182 1
d1193 1
a1195 1
#endif /* CRYPTO */
@


1.288
log
@K6-2/3 powernow driver.  not without quirks, but mostly working.
testing by david@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.287 2004/03/26 04:00:59 drahn Exp $	*/
a103 5
#ifdef CRYPTO
#include <crypto/cryptodev.h>
#include <crypto/rijndael.h>
#endif

a329 1
void	viac3_rnd(void *);
a1112 340
#if defined(I686_CPU)
/*
 * Note, the VIA C3 Nehemiah provides 4 internal 8-byte buffers, which
 * store random data, and can be accessed a lot quicker than waiting
 * for new data to be generated.  As we are using every 8th bit only
 * due to whitening. Since the RNG generates in excess of 21KB/s at
 * it's worst, collecting 64 bytes worth of entropy should not affect
 * things significantly.
 *
 * Note, due to some weirdness in the RNG, we need at least 7 bytes
 * extra on the end of our buffer.  Also, there is an outside chance
 * that the VIA RNG can "wedge", as the generated bit-rate is variable.
 * We could do all sorts of startup testing and things, but
 * frankly, I don't really see the point.  If the RNG wedges, then the
 * chances of you having a defective CPU are very high.  Let it wedge.
 *
 * Adding to the whole confusion, in order to access the RNG, we need
 * to have FXSR support enabled, and the correct FPU enable bits must
 * be there to enable the FPU in kernel.  It would be nice if all this
 * mumbo-jumbo was not needed in order to use the RNG.  Oh well, life
 * does go on...
 */
#define VIAC3_RNG_BUFSIZ	16		/* 32bit words */
struct timeout viac3_rnd_tmo;
int viac3_rnd_present = 0;

void
viac3_rnd(void *v)
{
	struct timeout *tmo = v;
	unsigned int *p, i, rv, creg0, len = VIAC3_RNG_BUFSIZ;
	static int buffer[VIAC3_RNG_BUFSIZ + 2];	/* XXX why + 2? */

	creg0 = rcr0();		/* Permit access to SIMD/FPU path */
	lcr0(creg0 & ~(CR0_EM|CR0_TS));

	/*
	 * Here we collect the random data from the VIA C3 RNG.  We make
	 * sure that we turn on maximum whitening (%edx[0,1] == "11"), so
	 * that we get the best random data possible.
	 */
	__asm __volatile("rep xstore-rng"
	    : "=a" (rv) : "d" (3), "D" (buffer), "c" (len*sizeof(int))
	    : "memory", "cc");

	lcr0(creg0);

	for (i = 0, p = buffer; i < VIAC3_RNG_BUFSIZ; i++, p++)
		add_true_randomness(*p);

	timeout_add(tmo, (hz > 100) ? (hz / 100) : 1);
}

#ifdef CRYPTO

struct viac3_session {
	u_int32_t	ses_ekey[4 * (MAXNR + 1) + 4];	/* 128 bit aligned */
	u_int32_t	ses_dkey[4 * (MAXNR + 1) + 4];	/* 128 bit aligned */
	u_int8_t	ses_iv[16];			/* 128 bit aligned */
	u_int32_t	ses_cw0;
	int		ses_klen;
	int		ses_used;
	int		ses_pad;			/* to multiple of 16 */
};

struct viac3_softc {
	u_int32_t		op_cw[4];		/* 128 bit aligned */
	u_int8_t		op_iv[16];		/* 128 bit aligned */
	void			*op_buf;

	/* normal softc stuff */
	int32_t			sc_cid;
	int			sc_nsessions;
	struct viac3_session	*sc_sessions;
};

#define VIAC3_SESSION(sid)		((sid) & 0x0fffffff)
#define	VIAC3_SID(crd,ses)		(((crd) << 28) | ((ses) & 0x0fffffff))

static struct viac3_softc *vc3_sc;
int viac3_crypto_present;

void viac3_crypto_setup(void);
int viac3_crypto_newsession(u_int32_t *, struct cryptoini *);
int viac3_crypto_process(struct cryptop *);
int viac3_crypto_freesession(u_int64_t);
static __inline void viac3_cbc(void *, void *, void *, void *, int, void *);

void
viac3_crypto_setup(void)
{
	int algs[CRYPTO_ALGORITHM_MAX + 1];

	if ((vc3_sc = malloc(sizeof(*vc3_sc), M_DEVBUF, M_NOWAIT)) == NULL)
		return;		/* YYY bitch? */
	bzero(vc3_sc, sizeof(*vc3_sc));

	bzero(algs, sizeof(algs));
	algs[CRYPTO_AES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;

	vc3_sc->sc_cid = crypto_get_driverid(0);
	if (vc3_sc->sc_cid < 0)
		return;		/* YYY bitch? */

	crypto_register(vc3_sc->sc_cid, algs, viac3_crypto_newsession,
	    viac3_crypto_freesession, viac3_crypto_process);
	i386_has_xcrypt = 1;
}

int
viac3_crypto_newsession(u_int32_t *sidp, struct cryptoini *cri)
{
	struct viac3_softc *sc = vc3_sc;
	struct viac3_session *ses = NULL;
	int sesn, i, cw0;

	if (sc == NULL || sidp == NULL || cri == NULL ||
	    cri->cri_next != NULL || cri->cri_alg != CRYPTO_AES_CBC)
		return (EINVAL);

	switch (cri->cri_klen) {
	case 128:
		cw0 = C3_CRYPT_CWLO_KEY128;
		break;
	case 192:
		cw0 = C3_CRYPT_CWLO_KEY192;
		break;
	case 256:
		cw0 = C3_CRYPT_CWLO_KEY256;
		break;
	default:
		return (EINVAL);
	}
	cw0 |= C3_CRYPT_CWLO_ALG_AES | C3_CRYPT_CWLO_KEYGEN_SW |
	    C3_CRYPT_CWLO_NORMAL;

	if (sc->sc_sessions == NULL) {
		ses = sc->sc_sessions = (struct viac3_session *)malloc(
		    sizeof(*ses), M_DEVBUF, M_NOWAIT);
		if (ses == NULL)
			return (ENOMEM);
		sesn = 0;
		sc->sc_nsessions = 1;
	} else {
		for (sesn = 0; sesn < sc->sc_nsessions; sesn++) {
			if (sc->sc_sessions[sesn].ses_used == 0) {
				ses = &sc->sc_sessions[sesn];
				break;
			}
		}

		if (ses == NULL) {
			sesn = sc->sc_nsessions;
			ses = (struct viac3_session *)malloc((sesn + 1) *
			    sizeof(*ses), M_DEVBUF, M_NOWAIT);
			if (ses == NULL)
				return (ENOMEM);
			bcopy(sc->sc_sessions, ses, sesn * sizeof(*ses));
			bzero(sc->sc_sessions, sesn * sizeof(*ses));
			free(sc->sc_sessions, M_DEVBUF);
			sc->sc_sessions = ses;
			ses = &sc->sc_sessions[sesn];
			sc->sc_nsessions++;
		}
	}

	bzero(ses, sizeof(*ses));
	ses->ses_used = 1;

	get_random_bytes(ses->ses_iv, sizeof(ses->ses_iv));
	ses->ses_klen = cri->cri_klen;
	ses->ses_cw0 = cw0;

	/* Build expanded keys for both directions */
	rijndaelKeySetupEnc(ses->ses_ekey, cri->cri_key, cri->cri_klen);
	rijndaelKeySetupDec(ses->ses_dkey, cri->cri_key, cri->cri_klen);
	for (i = 0; i < 4 * (MAXNR + 1); i++) {
		ses->ses_ekey[i] = ntohl(ses->ses_ekey[i]);
		ses->ses_dkey[i] = ntohl(ses->ses_dkey[i]);
	}

	*sidp = VIAC3_SID(0, sesn);
	return (0);
}

int
viac3_crypto_freesession(u_int64_t tid)
{
	struct viac3_softc *sc = vc3_sc;
	int sesn;
	u_int32_t sid = ((u_int32_t)tid) & 0xffffffff;

	if (sc == NULL)
		return (EINVAL);
	sesn = VIAC3_SESSION(sid);
	if (sesn >= sc->sc_nsessions)
		return (EINVAL);
	bzero(&sc->sc_sessions[sesn], sizeof(sc->sc_sessions[sesn]));
	return (0);
}

static __inline void
viac3_cbc(void *cw, void *src, void *dst, void *key, int rep,
    void *iv)
{
	unsigned int creg0;

	creg0 = rcr0();		/* Permit access to SIMD/FPU path */
	lcr0(creg0 & ~(CR0_EM|CR0_TS));

	/* Do the deed */
	__asm __volatile("pushfl; popfl");
	__asm __volatile("rep xcrypt-cbc" :
	    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
	    : "memory", "cc");

	lcr0(creg0);
}

int
viac3_crypto_process(struct cryptop *crp)
{
	struct viac3_softc *sc = vc3_sc;
	struct viac3_session *ses;
	struct cryptodesc *crd;
	int sesn, err = 0;
	u_int32_t *key;

	if (crp == NULL || crp->crp_callback == NULL) {
		err = EINVAL;
		goto out;
	}
	crd = crp->crp_desc;
	if (crd == NULL || crd->crd_next != NULL ||
	    crd->crd_alg != CRYPTO_AES_CBC || 
	    (crd->crd_len % 16) != 0) {
		err = EINVAL;
		goto out;
	}

	sesn = VIAC3_SESSION(crp->crp_sid);
	if (sesn >= sc->sc_nsessions) {
		err = EINVAL;
		goto out;
	}
	ses = &sc->sc_sessions[sesn];

	sc->op_buf = (char *)malloc(crd->crd_len, M_DEVBUF, M_NOWAIT);
	if (sc->op_buf == NULL) {
		err = ENOMEM;
		goto out;
	}

	if (crd->crd_flags & CRD_F_ENCRYPT) {
		sc->op_cw[0] = ses->ses_cw0 | C3_CRYPT_CWLO_ENCRYPT;
		key = ses->ses_ekey;
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crd->crd_iv, sc->op_iv, 16);
		else
			bcopy(ses->ses_iv, sc->op_iv, 16);

		if ((crd->crd_flags & CRD_F_IV_PRESENT) == 0) {
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copyback((struct mbuf *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copyback((struct uio *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else
				bcopy(sc->op_iv,
				    crp->crp_buf + crd->crd_inject, 16);
		}
	} else {
		sc->op_cw[0] = ses->ses_cw0 | C3_CRYPT_CWLO_DECRYPT;
		key = ses->ses_dkey;
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crd->crd_iv, sc->op_iv, 16);
		else {
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata((struct mbuf *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copydata((struct uio *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else
				bcopy(crp->crp_buf + crd->crd_inject,
				    sc->op_iv, 16);
		}
	}

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		m_copydata((struct mbuf *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else if (crp->crp_flags & CRYPTO_F_IOV)
		cuio_copydata((struct uio *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else
		bcopy(crp->crp_buf + crd->crd_skip, sc->op_buf, crd->crd_len);

	sc->op_cw[1] = sc->op_cw[2] = sc->op_cw[3] = 0;
	viac3_cbc(&sc->op_cw, sc->op_buf, sc->op_buf, key,
	    crd->crd_len / 16, sc->op_iv);

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		m_copyback((struct mbuf *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else if (crp->crp_flags & CRYPTO_F_IOV)
		cuio_copyback((struct uio *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else
		bcopy(sc->op_buf, crp->crp_buf + crd->crd_skip, crd->crd_len);

	/* copy out last block for use as next session IV */
	if (crd->crd_flags & CRD_F_ENCRYPT) {
		if (crp->crp_flags & CRYPTO_F_IMBUF)
			m_copydata((struct mbuf *)crp->crp_buf,
			    crd->crd_skip + crd->crd_len - 16, 16, ses->ses_iv);
		else if (crp->crp_flags & CRYPTO_F_IOV)
			cuio_copydata((struct uio *)crp->crp_buf,
			    crd->crd_skip + crd->crd_len - 16, 16, sc->op_iv);
		else
			bcopy(crp->crp_buf + crd->crd_skip + crd->crd_len - 16,
			    sc->op_iv, 16);
	}

out:
	if (sc->op_buf != NULL) {
		bzero(sc->op_buf, crd->crd_len);
		free(sc->op_buf, M_DEVBUF);
		sc->op_buf = NULL;
	}
	crp->crp_etype = err;
	crypto_done(crp);
	return (err);
}

#endif /* CRYPTO */

#endif /* defined(I686_CPU) */

d1167 2
d1183 2
@


1.287
log
@Allow the last page of physical memory (pci space) to be mapped. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.286 2004/03/17 00:59:54 tedu Exp $	*/
d1643 6
@


1.286
log
@one sysctl.h should be enough
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.285 2004/03/10 23:02:53 tom Exp $	*/
d3506 1
d3512 1
a3512 1
	if (endpa <= pa)
d3516 3
a3518 1
	va = uvm_km_valloc(kernel_map, endpa - pa);
d3524 2
a3525 1
	for (; pa < endpa; pa += PAGE_SIZE, va += PAGE_SIZE) {
@


1.285
log
@Ensure that we obey a user's ddb> boot reboot command even if the system
is cold (during startup).

This adds RB_USERREQ to sys/reboot.h, uses it in the ddb commands, and
ensures that */*/machdep.c:boot() won't set RB_HALT when cold if this
flag is set.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.284 2004/02/27 21:46:44 grange Exp $	*/
a116 2

#include <sys/sysctl.h>
@


1.284
log
@Move setperf_prio to the machdep code, requested by deraadt@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.283 2004/02/27 21:07:48 grange Exp $	*/
d2414 6
a2419 1
		howto |= RB_HALT;
@


1.283
log
@Cleanup I[3456]86_CPU defines usage, unbreaks compilation
without some of them.
Problem reported by William Culler <william@@neo.rr.com>.

Help from tedu@@ chris@@, ok tedu@@ chris@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.282 2004/02/19 23:31:58 deraadt Exp $	*/
d255 1
@


1.282
log
@better fix to avoid 1 second machine pauses; from grange
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.281 2004/02/19 23:10:42 deraadt Exp $	*/
d354 1
a372 1
#endif
d2041 1
d2045 1
d2138 2
a2139 1
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
d2179 1
d2181 1
d2189 1
@


1.281
log
@the cpu_cpuspeed function pointer MAY NOT BE SET TO POINT TO A FUNCTION
THAT SLEEPS FOR ONE SECOND AT HIGH SPL!  Who approved this, and what were
they smoking?
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.280 2004/02/19 22:33:29 grange Exp $	*/
a2039 1
#if 0
a2043 1
#endif
a2179 3
	/* XXX: what about CPU without TSC? */
	if (cpu_feature & CPUID_TSC)
		calibrate_cyclecounter();
a2180 1

@


1.280
log
@- split intel686_cpu_setup() into two parts: common for family
  0x6 and 0xf and only for family 0x6
- use intel686_p4_cpu_setup() for family 0xf cpus
- msr-based hw.cpuspeed for pentium 4
- use pentium_mhz for hw.cpuspeed if there's nothing better (diff from tedu@@)

Ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.279 2004/02/19 21:40:24 grange Exp $	*/
d2040 1
d2044 1
@


1.279
log
@spaces; ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.278 2004/02/08 20:58:01 deraadt Exp $	*/
d254 1
d329 1
d331 1
d337 2
d773 1
a773 1
			intel686_cpu_setup
d1666 1
a1666 3
intel686_cpu_setup(cpu_device, model, step)
	const char *cpu_device;
	int model, step;
a1667 9
	u_quad_t msr119;

	/*
	 * Original PPro returns SYSCALL in CPUID but is non-functional.
	 * From Intel Application Note #485.
	 */
	if ((model == 1) && (step < 3))
		cpu_feature &= ~CPUID_SEP;

a1673 12
	/*
	 * Disable the Pentium3 serial number.
	 */
	if ((model == 7) && (cpu_feature & CPUID_SER)) {
		msr119 = rdmsr(MSR_BBL_CR_CTL);
		msr119 |= 0x0000000000200000LL;
		wrmsr(MSR_BBL_CR_CTL, msr119);

		printf("%s: disabling processor serial number\n", cpu_device);
		cpu_feature &= ~CPUID_SER;
		cpuid_level = 2;
	}
d1679 2
a1680 2
			 printf("%s: Enhanced SpeedStep disabled by BIOS\n",
			     cpu_device);
d1700 41
d2040 5
d2135 53
@


1.278
log
@for the via c3 use software aes keys, thereby permitting 192 and 256.
this also speed things up substantially.  ipsec tested by markus
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.277 2004/02/05 10:23:56 deraadt Exp $	*/
d1648 1
a1648 1
#if !defined(SMALL_KERNEL) && defined (I686_CPU)
d1692 1
a1692 1
#if !defined(SMALL_KERNEL) && defined (I686_CPU)
d1722 1
a1722 1
#if !defined(SMALL_KERNEL) && defined (I586_CPU)
@


1.277
log
@2 new cpuid ecx features in prescott
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.276 2004/02/04 22:54:10 grange Exp $	*/
d106 1
d1171 7
a1177 2
	u_int8_t ses_iv[16];
	int ses_klen, ses_used;
d1181 2
a1182 4
	/* operand stuff, must be 128 bit aligned */
	u_int32_t		op_cw[4];
	u_int8_t		op_iv[16];
	u_int8_t		op_key[32];
a1183 1
	u_int32_t		pad[2];
d1229 1
a1229 1
	int sesn;
d1231 2
a1232 1
	if (sc == NULL || sidp == NULL || cri == NULL)
d1234 12
a1245 4
	if (cri->cri_next != NULL || cri->cri_alg != CRYPTO_AES_CBC)
		return (EINVAL);
	/* Initial version doesn't work for 192/256 */
	if (cri->cri_klen != 128)
d1247 4
d1286 9
a1294 1
	bcopy(cri->cri_key, cri->cri_key, ses->ses_klen / 8);
d1338 2
d1341 1
a1341 2
	struct cryptodesc *crd;
	struct viac3_session *ses;
a1346 7
	sesn = VIAC3_SESSION(crp->crp_sid);
	if (sesn >= sc->sc_nsessions) {
		err = EINVAL;
		goto out;
	}
	ses = &sc->sc_sessions[sesn];

d1349 2
a1350 1
	    crd->crd_alg != CRYPTO_AES_CBC || crd->crd_klen != 128) {
d1355 2
a1356 3
	bcopy(crd->crd_key, sc->op_key, crd->crd_klen / 8);

	if ((crd->crd_len % 16) != 0) {
d1360 1
a1367 3
	sc->op_cw[0] = C3_CRYPT_CWLO_ALG_AES | C3_CRYPT_CWLO_KEYGEN_HW |
	    C3_CRYPT_CWLO_NORMAL | C3_CRYPT_CWLO_KEY128;
	sc->op_cw[1] = sc->op_cw[2] = sc->op_cw[3] = 0;
d1369 2
a1370 1
		sc->op_cw[0] |= C3_CRYPT_CWLO_ENCRYPT;
d1388 2
a1389 1
		sc->op_cw[0] |= C3_CRYPT_CWLO_DECRYPT;
d1414 2
a1415 1
	viac3_cbc(&sc->op_cw, sc->op_buf, sc->op_buf, sc->op_key,
d1442 1
@


1.276
log
@Print a warning about disabling TSC.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.275 2004/02/03 18:38:49 deraadt Exp $	*/
d1088 2
@


1.275
log
@remove non-CBC modes from the VIA code; it is all that is used at the moment
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.274 2004/02/03 08:42:19 deraadt Exp $	*/
d1106 1
a1106 1
		printf("%s: broken TSC disabled\n", cpu_device);
d1548 1
d1579 1
@


1.274
log
@move VIA xcrypt-* options to specialreg.h
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.273 2004/02/02 01:15:58 deraadt Exp $	*/
d1143 1
a1143 1
	static int buffer[VIAC3_RNG_BUFSIZ + 2];
d1162 1
a1162 1
	timeout_add(tmo, (hz>100)?(hz/100):1);
d1196 1
a1196 1
void viac3_crypto(void *, void *, void *, void *, int, void *, int);
d1290 18
d1394 2
a1395 2
	viac3_crypto(&sc->op_cw, sc->op_buf, sc->op_buf, sc->op_key,
	    crd->crd_len / 16, sc->op_iv, VIAC3_CRYPTOP_CBC);
a1426 45
}

void
viac3_crypto(void *cw, void *src, void *dst, void *key, int rep,
    void *iv, int type)
{
	unsigned int creg0;

	creg0 = rcr0();		/* Permit access to SIMD/FPU path */
	lcr0(creg0 & ~(CR0_EM|CR0_TS));

	/* Do the deed */
	switch (type) {
	case VIAC3_CRYPTOP_RNG:
		__asm __volatile("rep xstore-rng" :
		    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
		    : "memory", "cc");
		break;
	case VIAC3_CRYPTOP_ECB:
		__asm __volatile("pushfl; popfl");
		__asm __volatile("rep xcrypt-ecb" :
		    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
		    : "memory", "cc");
		break;
	case VIAC3_CRYPTOP_CBC:
		__asm __volatile("pushfl; popfl");
		__asm __volatile("rep xcrypt-cbc" :
		    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
		    : "memory", "cc");
		break;
	case VIAC3_CRYPTOP_CFB:
		__asm __volatile("pushfl; popfl");
		__asm __volatile("rep xcrypt-cfb" :
		    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
		    : "memory", "cc");
		break;
	case VIAC3_CRYPTOP_OFB:
		__asm __volatile("pushfl; popfl");
		__asm __volatile("rep xcrypt-ofb" :
		    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
		    : "memory", "cc");
		break;
	}

	lcr0(creg0);
@


1.273
log
@I think there is no reason to splhigh around the VIA crypto stuff
anymore; also, indicate to userland that it may now safely use the
instructions
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.267 2004/02/01 12:26:45 grange Exp $	*/
a1188 14
#define	C3_CRYPT_CWLO_ROUND_M		0x0000000f
#define	C3_CRYPT_CWLO_ALG_M		0x00000070
#define	C3_CRYPT_CWLO_ALG_AES		0x00000000
#define	C3_CRYPT_CWLO_KEYGEN_M		0x00000080
#define	C3_CRYPT_CWLO_KEYGEN_HW		0x00000000
#define	C3_CRYPT_CWLO_KEYGEN_SW		0x00000080
#define	C3_CRYPT_CWLO_NORMAL		0x00000000
#define	C3_CRYPT_CWLO_INTERMEDIATE	0x00000100
#define	C3_CRYPT_CWLO_ENCRYPT		0x00000000
#define	C3_CRYPT_CWLO_DECRYPT		0x00000200
#define	C3_CRYPT_CWLO_KEY128		0x0000000a	/* 128bit, 10 rds */
#define	C3_CRYPT_CWLO_KEY192		0x0000040c	/* 192bit, 12 rds */
#define	C3_CRYPT_CWLO_KEY256		0x0000080e	/* 256bit, 15 rds */

a1190 7

/* Opcodes */
#define	VIAC3_CRYPTOP_RNG	0xc0		/* rng */
#define	VIAC3_CRYPTOP_ECB	0xc8		/* aes-ecb */
#define	VIAC3_CRYPTOP_CBC	0xd0		/* aes-cbc */
#define	VIAC3_CRYPTOP_CFB	0xe0		/* aes-cfb */
#define	VIAC3_CRYPTOP_OFB	0xe8		/* aes-ofb */
@


1.272
log
@set i386_has_xcrypt at the right place, which exposes itself as
sysctl machdep.xcrypt
Do not enabled yet..
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.271 2004/02/01 19:22:30 deraadt Exp $	*/
a1143 1
	int s;
a1144 1
	s = splhigh();
a1162 1
	splx(s);
a1236 1
#ifdef notdef
a1237 1
#endif
a1436 1
	int s;
a1437 1
	s = splhigh();
a1474 1
	splx(s);
@


1.271
log
@Use "pushfl; popfl" sequence before each xcrypt-* instruction.  According
to the manual, any load into the EFLAGS register clears bit 30, resulting
in key reload.  This is the mechanism that permits multi-process use of
the xcrypt-* instruction..
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.270 2004/02/01 19:20:30 deraadt Exp $	*/
d1240 3
@


1.270
log
@use VIA xstore-rng and xcrypt-* instructions, now that gas groks them
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.267 2004/02/01 12:26:45 grange Exp $	*/
d1453 1
d1459 1
d1465 1
d1471 1
@


1.269
log
@via crypto code no longer needs to temporarily enable FSXR -- it is
now always on.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.268 2004/02/01 19:05:23 deraadt Exp $	*/
d1155 1
a1155 1
	__asm __volatile ("rep;.byte 0x0F,0xA7,0xC0"
d1448 1
a1448 1
		__asm __volatile("rep;.byte 0x0F,0xA7,0xC0" :
d1453 1
a1453 1
		__asm __volatile("rep;.byte 0x0F,0xA7,0xC8" :
d1458 1
a1458 1
		__asm __volatile("rep;.byte 0x0F,0xA7,0xD0" :
d1463 1
a1463 1
		__asm __volatile("rep;.byte 0x0F,0xA7,0xE0" :
d1468 1
a1468 1
		__asm __volatile("rep;.byte 0x0F,0xA7,0xE8" :
@


1.268
log
@Enable FXSR all the time, and cope with NPX/FXSR conversions; from netbsd.
Pass SSE/SSE2/XCRYPT flags out via syctl, and prepare for being able to do
xcrypt-* in userland; ok naddy, tested a lot by pvalchev and jolan, also
works on amd64 in 32bit mode
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.267 2004/02/01 12:26:45 grange Exp $	*/
d1142 1
a1142 1
	unsigned int *p, i, rv, creg0, creg4, len = VIAC3_RNG_BUFSIZ;
d1147 1
a1147 2
	/* XXX - should not be needed, but we need FXSR & FPU set to access RNG */
	creg0 = rcr0();
a1148 2
	creg4 = rcr4();
	lcr4(creg4 | CR4_OSFXSR);
a1158 1
	/* XXX - should not be needed */
a1159 1
	lcr4(creg4);
d1438 1
a1438 1
	unsigned int creg0, creg4;
d1442 1
a1442 3

	/* XXX - should not be needed, but we might need FXSR & FPU for XUnit */
	creg0 = rcr0();
a1443 2
	creg4 = rcr4();
	lcr4(creg4 | CR4_OSFXSR);
a1473 1
	/* XXX - should not be neeeded */
a1474 2
	lcr4(creg4);

@


1.267
log
@Sync user ldt code with NetBSD:
- finally remove it from pcb, it's a pmap thing only
- more sanity checks
- better lockin
- may be something else

Fixes panics when using apps requiring it (mplayer-win32 e.g.).
Problem found and test espie@@.
OKs from miod@@ (sshhh, don't tell anyone) and art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.266 2004/01/31 00:09:41 deraadt Exp $	*/
d241 5
d2119 24
d2649 1
d2664 5
d2875 7
d3270 8
@


1.266
log
@rename SIMD/SIMD2 to SSE/SSE2
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.265 2004/01/29 19:01:54 tedu Exp $	*/
a456 1
	pcb->pcb_flags = 0;
a2619 1
	struct pcb *pcb = &p->p_addr->u_pcb;
d2630 1
a2630 2
	if (pcb->pcb_flags & PCB_USER_LDT)
		i386_user_cleanup(pcb);
a2633 1
	pcb->pcb_flags = 0;
@


1.265
log
@as seen in freebsd:  asm pagezero implementations, but use a fn pointer.
the sse2 version cuts ZOD fault time in half.
suggestions mickey deraadt.  many many testers. ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.264 2004/01/29 02:14:52 tom Exp $	*/
d1074 2
a1075 2
	{ CPUID_SIMD,	"SIMD" },
	{ CPUID_SIMD2,	"SIMD2" },
d1686 1
a1686 1
	if (cpu_feature & CPUID_SIMD2)
d1741 1
a1741 1
	if (cpu_feature & CPUID_SIMD2)
@


1.264
log
@Simplify test for CPUID_TSC in cpu_feature

ok fgsch@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.263 2004/01/29 01:36:13 tom Exp $	*/
d317 1
d809 1
a809 1
			NULL
d852 1
a852 1
			NULL
d1497 7
d1677 17
d1735 12
@


1.263
log
@No longer accept memory ranges in KB from /boot, which hasn't done
this since 1999.  If /boot tries to, we will now panic() with the
"/boot too old" message.  No-one should be using such an old /boot
anyway, since it didn't support ELF kernels then.

ok weingart@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.261 2004/01/12 08:09:23 deraadt Exp $	*/
d1966 1
a1966 1
	if (cpu_feature && (cpu_feature & CPUID_TSC)) {	/* Has TSC */
@


1.262
log
@Improve detection and reporting of VIA CPU types.  Correct spellings
of same.

ok deraadt@@, beck@@, weingart@@
@
text
@d2810 8
a2817 2
	/* Boot arguments are in a single page specified by /boot */
	if (bootapiver & BAPIV_VECTOR) {
@


1.261
log
@a native geode reset, because quite a few geode boards without keyboard
controllers are showing up; various ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.260 2004/01/06 21:09:20 tedu Exp $	*/
d917 5
a921 3
				0, 0, 0, 0, 0, 0, "C3 Samuel 1",
				"C3 Samule 2/Ezra",
				"C3 Ezra-T", 0, 0, 0, 0, 0, 0, 0,
d1109 1
a1109 1
 * Note, the VIA C3 Nehemia provides 4 internal 8-byte buffers, which
d1515 1
a1515 1
		 * C3 Nehemia:
a1776 7
	case 8:
		if (step < 8)
			name = "C3 Ezra-T";
		break;
	case 9:
		name = "C3 Nehemia";
		break;
d1879 6
a1884 1
			/* Special hack for the VIA C3 series. */
d1903 1
a1903 1
				   model >= 7 && model <= 8) {
@


1.260
log
@adjust pentium_mhz when cpu speed changes.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.259 2004/01/03 15:17:48 markus Exp $	*/
d274 1
d1600 13
d1627 1
d1631 1
d3078 3
@


1.259
log
@disable TSC for Geode SC1100; Stuart Henderson, pr 3625; ok mickey, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.258 2003/12/29 08:14:18 grange Exp $	*/
a279 3
extern int (*cpu_cpuspeed)(void *, size_t *, void *, size_t);
extern int (*cpu_setperf)(void *, size_t *, void *, size_t);

d1701 1
a1701 2
	cpu_cpuspeed = longrun_cpuspeed;
	cpu_setperf = longrun_setperf;
@


1.258
log
@Properly recognize SiS CPU family;
tested by Ian Zagorskih <ianzag@@megasignal.com>.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.257 2003/12/20 18:23:18 tedu Exp $	*/
d1611 5
@


1.257
log
@add pentium 4 thermal control circuit (tcc) driver.  can use this to
limit power consumption with the hw.setperf sysctl.
tested by beck and grange
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.256 2003/12/19 22:42:13 tedu Exp $	*/
d1020 25
@


1.256
log
@
add cpu_ecxfeature to cpu.h, and stop locally externing it and cpu_feature.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.255 2003/12/19 19:03:34 grange Exp $	*/
d1662 3
a1664 1
	}
@


1.255
log
@Unbreak ramdisk kernel after tedu's changes.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.254 2003/12/18 23:46:19 tedu Exp $	*/
a1068 1
	extern int cpu_feature;
a1469 1
	extern int cpu_feature;
a1627 4
	extern int cpu_feature, cpuid_level;
#ifndef SMALL_KERNEL
	extern int cpu_ecxfeature;
#endif
a1767 2
	extern int cpu_feature;
	extern int cpu_ecxfeature;
a3076 1
	extern int cpu_feature;
@


1.254
log
@add new hw sysctls, cpuspeed and setperf to control cpu frequency.
convert longrun support to use new sysctls.
add enhanced speedstep support, based on code by Michael Eriksson.
idea, help testing & ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.253 2003/12/14 23:11:28 deraadt Exp $	*/
d1630 4
a1633 1
	extern int cpu_feature, cpu_ecxfeature, cpuid_level;
@


1.253
log
@the extended long (bracketed) cpu names are not useful to anyone -- they are
just trivia -- and they bloat the ramdisk kernels by a fair bit.  remove
them.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.252 2003/12/11 01:09:47 deraadt Exp $	*/
d280 2
a281 1
int	longrun_sysctl(void *, size_t *, void *, size_t);
d1630 1
a1630 1
	extern int cpu_feature, cpuid_level;
d1658 9
d1674 3
a1676 4
#ifndef SMALL_KERNEL
	extern int longrun_enabled;

	longrun_enabled = 1;
a1923 4
	/* configure the CPU if needed */
	if (cpu_setup != NULL)
		cpu_setup(cpu_device, model, step);

d1970 4
a3146 4
#endif
#ifndef SMALL_KERNEL
	case CPU_LONGRUN:
		return (longrun_sysctl(oldp, oldlenp, newp, newlen));
@


1.252
log
@remove @@ that i do not like
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.251 2003/11/15 19:33:26 henning Exp $	*/
d684 1
a684 1
				"486SX2", 0, "486DX2 W/B Enhanced",
d694 1
a694 1
				"Pentium (P5 A-step)", "Pentium (P5)",
d697 1
a697 1
				"Pentium (P54C)", "Pentium/MMX (Tillamook)",
d707 6
a712 6
				"Pentium Pro (A-step)", "Pentium Pro", 0,
				"Pentium II (Klamath)", "Pentium Pro",
				"Pentium II/Celeron (Deschutes)",
				"Celeron (Mendocino)",
				"Pentium III (Katmai)",
				"Pentium III (Coppermine)",
d714 2
a715 2
				"Pentium III Xeon (Cascades)",
				"Pentium III (Tualatin)", 0, 0,
d800 6
a805 6
				"Duron Model 3 (Spitfire)",
				"Athlon Model 4 (Thunderbird)",
				0, "Athlon XP Model 6 (Palomino)",
				"Duron Model 7 (Morgan)", 
				"Athlon XP Model 8 (Thoroughbred)",
				0, "Athlon XP Model 10 (Barton)",
d807 1
a807 1
				"K7 (Athlon)"		/* Default */
d873 1
a873 1
				0, 0, "6x86 (M1)", 0, "GXm", 0, 0, 0, 0, 0,
d875 1
a875 1
				"M1 class"	/* Default */
d883 1
a883 1
				"6x86MX (M2)", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
d885 1
a885 1
				"M2 class"	/* Default */
d1016 1
a1016 1
				"M1 class"	/* Default */
@


1.251
log
@recognize AMD Opteron, Athlon64 and Athlon64FX as 686-class CPU
diff from Chris Timmons <ChrisT@@computar.ca> and jaimie@@camerarepair.com
with minor adjustments by me

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.250 2003/11/15 19:27:50 henning Exp $	*/
d1930 1
a1930 1
				printf(" @@%d.%02d GHz", ghz, fr);
d1932 1
a1932 1
				printf(" @@%d GHz", ghz);
d1934 1
a1934 1
			printf(" @@%d MHz", pentium_mhz);
@


1.250
log
@diff from andreas@@:
use the cpuid instruction for processor identification where available.
tested by grange@@, tedu@@ and me
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.249 2003/11/14 07:15:53 kevlo Exp $	*/
d808 43
@


1.249
log
@correct detects Transmeta cpu.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.248 2003/10/29 20:03:54 jason Exp $	*/
d1717 1
d1732 2
d1839 19
d1860 2
a1861 2
		    "%s %s%s (%s%s%s%s-class, %dKB L2 cache)",
		    vendorname, modifier, name,
d1866 2
a1867 2
		    "%s %s%s (%s%s%s%s-class)",
		    vendorname, modifier, name,
d1887 1
a1887 1
				printf(" %d.%02d GHz", ghz, fr);
d1889 1
a1889 1
				printf(" %d GHz", ghz);
d1891 1
a1891 1
			printf(" %d MHz", pentium_mhz);
@


1.248
log
@Avoid another malloc in the VIA AES stuff: move the operation stuff
into the softc allocated at attach time
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.247 2003/10/29 19:47:59 jason Exp $	*/
d326 1
d936 2
a937 2
				0, 0, 0, "TMS5400", "TMS5600", 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
d1693 20
d1811 4
@


1.247
log
@don't allocate two buffers when one will do (VIA's AES stuff can have src==dst)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.246 2003/10/15 22:33:34 deraadt Exp $	*/
d1107 8
a1136 8
struct viac3_crypto_op {
	u_int32_t		op_cw[4];
	u_int8_t		op_iv[16];
	u_int8_t		op_key[32];
	void			*op_buf;
	u_int32_t		pad[2];
};

a1247 1
	struct viac3_crypto_op *op = NULL;
d1270 1
a1270 7
	op = (struct viac3_crypto_op *)malloc(sizeof(*op), M_DEVBUF, M_NOWAIT);
	if (op == NULL) {
		err = ENOMEM;
		goto out;
	}

	bcopy(crd->crd_key, op->op_key, crd->crd_klen / 8);
d1277 2
a1278 2
	op->op_buf = (char *)malloc(crd->crd_len, M_DEVBUF, M_NOWAIT);
	if (op->op_buf == NULL) {
d1283 1
a1283 1
	op->op_cw[0] = C3_CRYPT_CWLO_ALG_AES | C3_CRYPT_CWLO_KEYGEN_HW |
d1285 1
a1285 1
	op->op_cw[1] = op->op_cw[2] = op->op_cw[3] = 0;
d1287 1
a1287 1
		op->op_cw[0] |= C3_CRYPT_CWLO_ENCRYPT;
d1289 1
a1289 1
			bcopy(crd->crd_iv, op->op_iv, 16);
d1291 1
a1291 1
			bcopy(ses->ses_iv, op->op_iv, 16);
d1296 1
a1296 1
				    crd->crd_inject, 16, op->op_iv);
d1299 1
a1299 1
				    crd->crd_inject, 16, op->op_iv);
d1301 1
a1301 1
				bcopy(op->op_iv,
d1305 1
a1305 1
		op->op_cw[0] |= C3_CRYPT_CWLO_DECRYPT;
d1307 1
a1307 1
			bcopy(crd->crd_iv, op->op_iv, 16);
d1311 1
a1311 1
				    crd->crd_inject, 16, op->op_iv);
d1314 1
a1314 1
				    crd->crd_inject, 16, op->op_iv);
d1317 1
a1317 1
				    op->op_iv, 16);
d1323 1
a1323 1
		    crd->crd_skip, crd->crd_len, op->op_buf);
d1326 1
a1326 1
		    crd->crd_skip, crd->crd_len, op->op_buf);
d1328 1
a1328 1
		bcopy(crp->crp_buf + crd->crd_skip, op->op_buf, crd->crd_len);
d1330 2
a1331 2
	viac3_crypto(&op->op_cw, op->op_buf, op->op_buf, op->op_key,
	    crd->crd_len / 16, op->op_iv, VIAC3_CRYPTOP_CBC);
d1335 1
a1335 1
		    crd->crd_skip, crd->crd_len, op->op_buf);
d1338 1
a1338 1
		    crd->crd_skip, crd->crd_len, op->op_buf);
d1340 1
a1340 1
		bcopy(op->op_buf, crp->crp_buf + crd->crd_skip, crd->crd_len);
d1349 1
a1349 1
			    crd->crd_skip + crd->crd_len - 16, 16, op->op_iv);
d1352 1
a1352 1
			    op->op_iv, 16);
d1356 3
a1358 4
	if (op != NULL) {
		if (op->op_buf != NULL)
			free(op->op_buf, M_DEVBUF);
		free(op, M_DEVBUF);
@


1.246
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.245 2003/10/14 19:38:21 jason Exp $	*/
d1133 1
a1133 2
	void			*op_src;
	void			*op_dst;
d1284 2
a1285 8
	op->op_src = (char *)malloc(crd->crd_len, M_DEVBUF, M_NOWAIT);
	if (op->op_src == NULL) {
		err = ENOMEM;
		goto out;
	}

	op->op_dst = (char *)malloc(crd->crd_len, M_DEVBUF, M_NOWAIT);
	if (op->op_dst == NULL) {
d1330 1
a1330 1
		    crd->crd_skip, crd->crd_len, op->op_src);
d1333 1
a1333 1
		    crd->crd_skip, crd->crd_len, op->op_src);
d1335 1
a1335 1
		bcopy(crp->crp_buf + crd->crd_skip, op->op_src, crd->crd_len);
d1337 1
a1337 1
	viac3_crypto(&op->op_cw, op->op_src, op->op_dst, op->op_key,
d1342 1
a1342 1
		    crd->crd_skip, crd->crd_len, op->op_dst);
d1345 1
a1345 1
		    crd->crd_skip, crd->crd_len, op->op_dst);
d1347 1
a1347 1
		bcopy(op->op_dst, crp->crp_buf + crd->crd_skip, crd->crd_len);
d1364 2
a1365 4
		if (op->op_src != NULL)
			free(op->op_src, M_DEVBUF);
		if (op->op_dst != NULL)
			free(op->op_dst, M_DEVBUF);
@


1.245
log
@Ok, now that the via c3 crypto stuff is in the tree, merge the last bit of
my cleanups before starting "real work".
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.242 2003/09/02 17:35:53 grange Exp $	*/
d1388 1
a1388 1
        
d1390 1
a1390 1
        
d1580 1
a1580 1
	case 0:         /* AMD-K5 Model 0 */
@


1.244
log
@permit ramdisks to build
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.243 2003/09/11 19:46:22 deraadt Exp $	*/
d1100 1
d1432 1
d1509 2
a1510 1
#endif
@


1.243
log
@support new via c3 AES instruction; written by jason
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.242 2003/09/02 17:35:53 grange Exp $	*/
d104 1
a104 2
#if defined(I686_CPU)
/* YYY move */
d1099 1
d1399 3
a1401 5
		__asm __volatile(
			"rep;.byte 0x0F,0xA7,0xC0"
			    :
			    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
			    : "memory", "cc");
d1404 3
a1406 5
		__asm __volatile(
			"rep;.byte 0x0F,0xA7,0xC8"
			    :
			    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
			    : "memory", "cc");
d1409 3
a1411 5
		__asm __volatile(
			"rep;.byte 0x0F,0xA7,0xD0"
			    :
			    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
			    : "memory", "cc");
d1414 3
a1416 5
		__asm __volatile(
			"rep;.byte 0x0F,0xA7,0xE0"
			    :
			    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
			    : "memory", "cc");
d1419 3
a1421 5
		__asm __volatile(
			"rep;.byte 0x0F,0xA7,0xE8"
			    :
			    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
			    : "memory", "cc");
a1422 1
	default:
d1431 1
d1433 1
a1433 1
#endif
d1494 1
d1507 1
@


1.242
log
@Revert the last change since both Pentium 4 and Mobile Pentium 4
can be with model = 2. Better cpu ident will be after 3.4.
Problem noted by Wouter Clarie <rimshot@@pandora.be>.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.240 2003/07/25 22:47:54 mickey Exp $	*/
d104 5
d1099 344
d1489 14
a1502 3
		/* Stop here if no RNG */
		if (!(val & 0x4))
			break;
d1504 11
a1514 8
		/* Enable RNG if disabled */
		if (!(val & 0x8)) {
			u_int64_t msreg;

			msreg = rdmsr(0x110B);
			msreg |= 0x40;
			wrmsr(0x110B, msreg);
			printf("Screwed with MSR 0x110B!\n");
d1516 1
a1516 2
		viac3_rnd_present = 1;
		printf("%s: RNG activated\n", cpu_device);
@


1.241
log
@Properly identify Mobile Pentium 4-M processor
ok mickey@@

Live from marshrutka 368 ;-)
@
text
@d752 1
a752 1
				"Pentium 4", 0, "Mobile Pentium 4-M", 0,
@


1.240
log
@use names not numbers for msrs, do not define yet another implementation of wrmsr/rdmsr
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.239 2003/07/25 21:42:02 mickey Exp $	*/
d752 1
a752 1
				"Pentium 4", 0, 0, 0,
@


1.239
log
@s/CPUID_SYS2/CPUID_SEP/ to avoid confusion
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.238 2003/07/25 17:41:19 tedu Exp $	*/
a1246 8
#define rdmsr(msr)	\
({			\
	u_quad_t v;	\
	__asm __volatile ("rdmsr" : "=A" (v) : "c" (msr));	\
	v;		\
})
#define wrmsr(msr, v)	\
	__asm __volatile ("wrmsr" :: "A" ((u_quad_t) (v)), "c" (msr));
d1265 3
a1267 3
		msr119 = rdmsr(0x119);
		msr119 |= 0x0000000000200000;
		wrmsr(0x119, msr119);
a1272 2
#undef rdmsr
#undef wrmsr
@


1.238
log
@make sure SYSENTER registers are 0 at boot time.  should fix an unusual
DOS reported by Michal Zalewski to bugtraq.  ok mickey@@ toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.237 2003/07/07 03:07:19 tedu Exp $	*/
d987 1
a987 1
	{ CPUID_SYS2,	"SYS" },
d1261 1
a1261 1
		cpu_feature &= ~CPUID_SYS2;
d1266 1
a1266 1
	if (cpu_feature & CPUID_SYS2)
@


1.237
log
@function for cpuid instruction.  pulled from longrun into generic code.
ok deraadt mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.236 2003/06/06 11:11:53 andreas Exp $	*/
d1262 6
@


1.236
log
@Identify Pentium M CPU
Recognize more feature flags
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.235 2003/06/02 23:27:47 millert Exp $	*/
d337 18
@


1.235
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.234 2003/06/02 18:14:16 jason Exp $	*/
d690 2
a691 1
				0, "Pentium III Xeon (Cascades)",
d977 2
d982 5
d990 6
d1344 1
d1505 10
@


1.234
log
@add length checks on bus_dmamap_load_uio() on the total length vs. what the
map is expecting.  Also, sparc64 was missing the equivalent check in
_load_mbuf() and the "make sure no valid mappings are returned" goop.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.233 2003/05/27 23:52:01 fgsch Exp $	*/
d58 1
a58 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.233
log
@change .byte for the correct opcodes now that gas can handle'em.
art@@ toby@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.232 2003/05/18 02:43:12 andreas Exp $	*/
d3130 3
@


1.232
log
@Add 'machine sysregs' command to ddb for 1386; show idtr, gdtr, ldtr, tr
and cr0-ct4
OK by niklas@@ and more or less by ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.231 2003/05/14 22:53:59 tedu Exp $	*/
d1222 1
a1222 1
	__asm __volatile (".byte 0xf, 0x32" : "=A" (v) : "c" (msr));	\
d1226 1
a1226 1
	__asm __volatile (".byte 0xf, 0x30" :: "A" ((u_quad_t) (v)), "c" (msr));
@


1.231
log
@remove option LONGRUN; it's in everything but SMALL_KERNEL now
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.230 2003/05/14 22:08:04 tedu Exp $	*/
d2445 1
@


1.230
log
@Support for Transmeta CPU power management, called LongRun.
option LONGRUN enables a new sysctl, allowing a userland program
to read the current CPU frequency and voltage and also set
the mininum and maximum frequencies to operate between, and switch
between performance mode and battery mode.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.229 2003/05/13 03:49:04 art Exp $	*/
d1256 1
a1256 1
#ifdef LONGRUN
d2673 1
a2673 1
#ifdef LONGRUN
@


1.229
log
@The current solution to handle the protection fault trap is not
correct.  It breaks down if we're trying to jump through a function
pointer. The protection fault trap on i386 must be one of the most
braindead traps ever invented in the history of humankind. It doesn't
give you any information about what went wrong except the instruction
that faulted. Since the problem we're trying to deal with is a
segmentation problem, we don't get the desitination that we want to
jump to, we just get the instruction and we won't add a disassembler
to trap handling just to try to figure out what went wrong.

What we want to do is to handle this as a normal fault to let noexec
accounting in pmap_enter deal with the changes to the code
segment. Unfortunately that's impossible. We don't know the faulting
address, so we need to change how the exec accounting works. Basically
the code segment must already cover the address we want to execute
before we can fault it in.

New scheme:

 o Start with conservative code segment.

 o If we get a protection fault, go through all mappings in the process
  and find the highest executable mapping, fix up the code segment and
  record that address. If the code segment didn't change, the protection
  fault wasn't fixable - just die.

 o If the highest executable mapping is removed, just reset the code
  segment to something conservative and let the next protection fault
  deal with it.  We can't read all the vm mappings of the process from
  the pmap because of locking hell.

This should allow floating code segment whenever someone implements that.

Also, fix the pmap_protect function to behave more like the other
pmaps we have and be slightly more agressive to force more proper
protection changes.

ok:ed by various people.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.228 2003/05/05 17:54:59 drahn Exp $	*/
d280 2
d323 1
d920 1
a920 1
			NULL
d922 1
a922 1
		/* Family 6, not yet available from Rise */
d1251 12
d2673 4
d2678 1
a2678 1
		return EOPNOTSUPP;
@


1.228
log
@Move exec base to 0x1c000000, exe/data gap to 512MB. Allows better
interleave of exe/shared libs. Raise MAXDSIZ back to 1G.
This change REQUIRES a binary update on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.227 2003/05/04 04:29:03 tedu Exp $	*/
d1677 1
a1677 1
	tf->tf_cs = pmap->pm_nxpages > 0?
d2081 1
a2081 1
	tf->tf_cs = pmap->pm_nxpages > 0?
@


1.227
log
@string cleaning.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.226 2003/04/30 22:37:11 mickey Exp $	*/
d2230 1
a2230 1
	setsegment(&gdt[GUCODE_SEL].sd, 0, i386_btop(0x3fffffff),  /* 1G */
@


1.226
log
@from netbsd:
The AMD-K5 Model 0 gets the PGE bit in the CPU features word wrong
using the APIC bit instead, according to the AMD Processor Recognition
App. Note.  Add a fixup routine to patch up cpu_feature in this case.

XXX Need a way to kick the pmap to enable pmap_pg_g -- look at how the
MP branch deals with this.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.225 2003/04/17 03:56:20 drahn Exp $	*/
d1432 5
a1436 4
		sprintf(cpu_model, "%s %s%s (%s%s%s%s-class, %dKB L2 cache)",
			vendorname, modifier, name,
			((*token) ? "\"" : ""), ((*token) ? token : ""),
			((*token) ? "\" " : ""), classnames[class], cachesize);
d1438 5
a1442 4
		sprintf(cpu_model, "%s %s%s (%s%s%s%s-class)",
			vendorname, modifier, name,
			((*token) ? "\"" : ""), ((*token) ? token : ""),
			((*token) ? "\" " : ""), classnames[class]);
@


1.225
log
@A SEVERE hack given to me by mickey to draw the line in the sand at 1G.
memory by default will be executable, above, non executable. If memory
is requested to be exectable above 1G, this limit is relaxed.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.224 2003/03/28 00:49:13 miod Exp $	*/
d315 1
d770 1
a770 1
			NULL
d1184 23
@


1.224
log
@Add a sysctl to option USER_LDT, to control its behaviour, which will be
disabled by default.

Enable with sysctl -w machdep.userldt=1

This will allow people to use the few ports that require this functionality
to work without requiring the user to recompile a kernel.

The option USER_LDT remains in order to not increase size on the
installation media. It is now enabled in GENERIC.

Per espie@@'s idea, but my diff was much simpler than his; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.223 2003/03/28 00:28:22 weingart Exp $	*/
d2204 1
a2204 2
	setsegment(&gdt[GUCODE_SEL].sd, 0,
	    i386_btop(VM_MAXUSER_ADDRESS - MAXSSIZ) - 1,
@


1.223
log
@Fix VIA C3 comment.
Ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.222 2003/03/14 22:05:43 deraadt Exp $	*/
d199 4
d2628 5
@


1.222
log
@Support for the VIA C3 Nehemiah on-cpu random number generator.  This chip
will be shipping soon (we have nice prototypes).  Written by toby.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.221 2003/03/07 19:23:37 wilfried Exp $	*/
d1003 3
a1005 3
 * due to whitening, we only pull off 4 bytes worth of data here, to
 * help prevent stalling, and allow the RNG to generate new data in
 * parallel with anything else going on.
d1007 1
a1007 1
 * Note, due to some weirdness in the RNG, we need at last 7 bytes
d1010 3
a1012 4
 * Since the RNG generates in excess of 21KB/s at it's worst, this is
 * still significantly faster than the rate at which we are collecting
 * from it.  We could do all sorts of startup testing and things, but
 * frankly, I don't really see the point.
d1016 3
a1018 3
 * be there to enable the FPU.  It would be nice if all this mumbo-
 * jumbo was not needed in order to use the RNG.  Oh well, life does
 * go on...
@


1.222.2.1
log
@MFC:
Fix by tedu@@

make sure SYSENTER registers are 0 at boot time.  should fix an unusual
DOS reported by Michal Zalewski to bugtraq.  ok mickey@@ toby@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.222 2003/03/14 22:05:43 deraadt Exp $	*/
a1203 6

 	/*
	 * Make sure SYSENTER is disabled.
	 */
	if (cpu_feature & CPUID_SYS2)
		wrmsr(MSR_SYSENTER_CS, 0);
@


1.221
log
@New athlon models, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.220 2003/01/16 19:39:23 mickey Exp $	*/
d132 1
d318 1
d998 63
d1082 39
d1278 3
@


1.220
log
@slightely better memory regions validity check; weingart@@ idea and ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.219 2003/01/16 04:15:17 art Exp $	*/
d770 7
a776 4
				"Duron", "Athlon Model 4 (Thunderbird)",
				0, "Athlon Model 6 (Palomino)",
				"Athlon Model 7 (Morgan)", 0,
				0, 0, 0, 0, 0, 0, 0,
@


1.219
log
@Getting rid of vm_offset_t
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.218 2003/01/15 01:43:44 mickey Exp $	*/
a2188 8
			/* skip zero sized regions */
			if (im->size == 0) {
#ifdef DEBUG
				printf("-Z");
#endif
				continue;
			}

d2190 1
a2190 1
			if ((e - a) < NBPG) {
@


1.218
log
@skip zero-sized memory regions, which pass otherwise due to the address rounding and such; from Carson Harding <harding@@motd.ca>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.217 2002/12/17 23:11:32 millert Exp $	*/
d219 2
a220 2
	vm_offset_t	start;
	vm_size_t	end;
d237 1
a237 1
vm_offset_t avail_end;
d263 1
a263 1
void	setup_buffers(vm_offset_t *);
d267 1
a267 1
void	init386(vm_offset_t);
d507 1
a507 1
	vm_offset_t *maxaddr;
d509 2
a510 2
	vm_size_t size;
	vm_offset_t addr;
d594 1
a594 1
		addr = (vm_offset_t)buffers + i * MAXBSIZE;
d1784 1
a1784 1
static vm_offset_t dumpspace;
d1786 2
a1787 3
vm_offset_t
reserve_dumppages(p)
	vm_offset_t p;
d1791 1
a1791 1
	return (p + NBPG);
d2023 1
a2023 1
fix_f00f()
d2026 1
a2026 1
	vm_offset_t va;
d2056 1
a2056 2
init386(first_avail)
	vm_offset_t first_avail;
d2142 1
a2142 1
	pmap_bootstrap((vm_offset_t)atdevbase + IOM_SIZE);
d2699 1
a2699 1
	vm_offset_t va;
d3141 1
a3141 1
	vm_offset_t va;
d3185 1
a3185 1
	uvm_km_free(kernel_map, (vm_offset_t)kva, size);
d3263 1
a3263 1
		pmap_extract(pmap, (vm_offset_t)vaddr, (paddr_t *)&curaddr);
d3334 2
a3335 2
	vm_offset_t low;
	vm_offset_t high;
d3337 1
a3337 1
	vm_offset_t curaddr, lastaddr;
@


1.217
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.216 2002/10/07 18:35:56 mickey Exp $	*/
d2190 8
@


1.216
log
@this removes the functionality of adding allocated
pages into the queue already containing allocated pages.
breaks i386:setup_buffers() because of this.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.215 2002/10/06 22:06:15 art Exp $	*/
a106 6
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
d463 1
a463 12
#ifdef SYSVSHM
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
	valloc(shmsegs, struct shmid_ds, shminfo.shmmni);
#endif
#ifdef SYSVSEM
	valloc(sema, struct semid_ds, seminfo.semmni);
	valloc(sem, struct sem, seminfo.semmns);
	/* This is pretty disgusting! */
	valloc(semu, int, (seminfo.semmnu * seminfo.semusz) / sizeof(int));
#endif
@


1.215
log
@No more need to initialize the result list before uvm_pglistalloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.214 2002/07/31 02:30:29 mickey Exp $	*/
d3359 1
@


1.214
log
@support for changing stack execution protection through mprotect()
by emulating the page execution protection bit and accounting
for pages mapped executable on the stack and swapping the
global user code descriptors for the process accordingly.
this is tested w/ the regress test and art@@ looked over it.

there is still a mistery how executable mappings on fault
works on i386 since no prot_exec faults ever happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.213 2002/07/24 01:15:39 mickey Exp $	*/
a3358 1
	TAILQ_INIT(&mlist);
@


1.214.2.1
log
@MFC:
Fix by tedu@@

make sure SYSENTER registers are 0 at boot time.  should fix an unusual
DOS reported by Michal Zalewski to bugtraq.  ok mickey@@ toby@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.214 2002/07/31 02:30:29 mickey Exp $	*/
a1113 6

 	/*
	 * Make sure SYSENTER is disabled.
	 */
	if (cpu_feature & CPUID_SYS2)
		wrmsr(MSR_SYSENTER_CS, 0);
@


1.213
log
@limit user code up to below the user stack, making stack addresses, effectively, unexecutable. signal trampoline is mapped elesewhere now, 10x to art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.212 2002/07/20 19:24:56 art Exp $	*/
d1465 3
a1467 2
	register struct proc *p = curproc;
	register struct trapframe *tf;
d1470 1
a1470 1
	int oonstack;
a1476 3
	tf = p->p_md.md_regs;
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;

d1555 2
a1556 1
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
d1935 3
a1937 2
	register struct pcb *pcb = &p->p_addr->u_pcb;
	register struct trapframe *tf;
a1952 1
	tf = p->p_md.md_regs;
d1960 2
a1961 1
	tf->tf_cs = LSEL(LUCODE_SEL, SEL_UPL);
d2108 2
d2119 1
@


1.212
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.211 2002/07/19 17:30:50 mickey Exp $	*/
d2108 2
a2109 1
	setsegment(&gdt[GUCODE_SEL].sd, 0, i386_btop(VM_MAXUSER_ADDRESS) - 1,
@


1.211
log
@do not use broken tsc on geode and broken latch on ns geodes; testing by markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.210 2002/06/18 12:50:55 nate Exp $	*/
a1469 1
	extern char sigcode[], esigcode[];
d1556 1
a1556 1
	tf->tf_eip = (int)(((char *)PS_STRINGS) - (esigcode - sigcode));
@


1.210
log
@Remove all traces of the PCCONS stuff.  (Remove pc.h and references to NPC
and NPCCONSKBD)
ok matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.209 2002/06/08 22:20:49 weingart Exp $	*/
d318 1
d959 1
a959 1
			cyrix6x86_cpu_setup
d1063 1
d1066 12
@


1.209
log
@Make 4GB machines work better.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.208 2002/05/22 18:43:45 art Exp $	*/
a167 5
#include "pc.h"
#if (NPC > 0)
#include <machine/pccons.h>
#endif

d172 1
a172 1
#if (NCOM > 0 || NPCCOM > 0)
a2387 3
#if (NPC > 0) && (NPCCONSKBD > 0)
	return (pcconskbd_cnattach(kbctag, kbcslot));
#else
a2388 1
#endif
@


1.208
log
@Implement splassert. Even simpler than on the sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.207 2002/05/18 19:39:01 mickey Exp $	*/
d511 2
a512 1
	/* Restrict to at most 70% filled kvm */
d514 1
a514 1
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 7 / 10) 
d516 1
a516 1
		    MAXBSIZE * 7 / 10;
d2185 1
a2185 1
			register int32_t a, e;
d2239 2
a2240 2
		int32_t a, e;
		int32_t lim;
@


1.207
log
@pasto
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.206 2002/05/17 18:55:41 mickey Exp $	*/
d3392 10
@


1.206
log
@properly detect the cpu model for the broken cyrix latch; better fix than pr#2661
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.205 2002/05/16 15:33:05 mickey Exp $	*/
d1064 1
a1064 2
	case 0x440:
	case 0x540:
@


1.205
log
@fix for a timer latch bug on the cyrix mediagx and gxm cpus.
based on freebsd pr#6630, netbsd pr#8654, openbsd pr#1492 .
does not affect other cpu models (cyrix or not).
asked by markus@@ and testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.204 2002/03/30 09:42:28 mickey Exp $	*/
d1044 1
d1064 4
@


1.204
log
@recognize more via/cyrix cpu types; from Kamo Hiroyasu <wd@@ics.nara-wu.ac.jp> via pr#2503 (w/ typos fixed)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.203 2002/03/24 00:21:23 deraadt Exp $	*/
a1043 1
	extern int cpu_feature;
a1062 4
	case 4:	/* GXm */
		/* Unset the TSC bit until calibrate_delay() gets fixed. */
		cpu_feature &= ~CPUID_TSC;
		break;
@


1.203
log
@handle NS Geode GX1; wd@@ics.nara-wu.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.202 2002/03/23 13:28:34 espie Exp $	*/
d326 1
d862 4
a865 3
				0, 0, 0, 0, 0, 0, "VIA Cyrix III", 0,
				0, 0, 0, 0, 0, 0, 0, 0,
				"VIA Cyrix III"		/* Default */
d1023 3
a1025 1
	case 6: /* VIA Cyrix III */
d1163 21
d1260 5
d1277 4
@


1.202
log
@Add variables for config(8) -e time tweak of systemV shared memory
parameters.

Ok millert@@, miod@@, maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.201 2002/03/18 16:04:24 espie Exp $	*/
d936 25
@


1.201
log
@pedantic assembly opcodes, to please new gas/new gcc.
okay mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.200 2002/03/14 20:31:31 mickey Exp $	*/
d473 3
@


1.200
log
@remove ambiguity in version,ostype,osversion,osrelease and their constanity, they are and declarre 'em accordingly also removing private externies of those
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.199 2002/03/14 16:52:11 mickey Exp $	*/
d1442 2
a1443 2
		__asm("movl %%gs,%w0" : "=r" (frame.sf_sc.sc_gs));
		__asm("movl %%fs,%w0" : "=r" (frame.sf_sc.sc_fs));
d1482 2
a1483 2
	__asm("movl %w0,%%gs" : : "r" (GSEL(GUDATA_SEL, SEL_UPL)));
	__asm("movl %w0,%%fs" : : "r" (GSEL(GUDATA_SEL, SEL_UPL)));
d1884 2
a1885 2
	__asm("movl %w0,%%gs" : : "r" (LSEL(LUDATA_SEL, SEL_UPL)));
	__asm("movl %w0,%%fs" : : "r" (LSEL(LUDATA_SEL, SEL_UPL)));
@


1.199
log
@protect from overflows and null derefs in cpu probing; from wd@@ics.nara-wu.ac.jp via pr#2457
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.198 2002/03/14 01:26:32 millert Exp $	*/
a624 1
extern	char version[];
@


1.198
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.197 2002/02/17 22:59:52 maja Exp $	*/
d1198 2
d1222 1
a1222 1
			if (name == NULL)
d1224 3
@


1.197
log
@Patch from Daniel Lucq <daniel@@lucq.org>

The patch allows you to change the value of NMBCLUSTERS, BUFCACHEPERCENT
and NKMEMPAGES using the config command, instead of recompiling the kernel.

This is the kernel part of the patch. I have compiled it on i386, sparc64,
alpha and macppc. -moj ok art@@ maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.196 2002/01/28 23:14:24 mickey Exp $	*/
d273 12
a284 12
caddr_t	allocsys __P((caddr_t));
void	setup_buffers __P((vm_offset_t *));
void	dumpsys __P((void));
int	cpu_dump __P((void));
void	identifycpu __P((void));
void	init386 __P((vm_offset_t));
void	consinit __P((void));

int	bus_mem_add_mapping __P((bus_addr_t, bus_size_t,
	    int, bus_space_handle_t *));
int	_bus_dmamap_load_buffer __P((bus_dma_tag_t, bus_dmamap_t, void *,
    bus_size_t, struct proc *, int, paddr_t *, int *, int));
d309 1
a309 1
void kgdb_port_init __P((void));
d320 6
a325 6
void	winchip_cpu_setup __P((const char *, int, int));
void	cyrix3_cpu_setup __P((const char *, int, int));
void	cyrix6x86_cpu_setup __P((const char *, int, int));
void	intel586_cpu_setup __P((const char *, int, int));
void	intel686_cpu_setup __P((const char *, int, int));
char *	intel686_cpu_name __P((int));
d1148 1
a1148 1
	void (*cpu_setup) __P((const char *, int, int));
d1356 1
a1356 1
void ibcs2_sendsig __P((sig_t, int, int, u_long, int, union sigval));
d1706 1
a1706 1
	int (*dump) __P((dev_t, daddr_t, caddr_t, size_t));
d1745 1
a1745 1
	int (*dump) __P((dev_t, daddr_t, caddr_t, size_t));
@


1.196
log
@yes, there is no sense in double savectx here; from Brian J. Kifiak <bk@@rt.fm>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.195 2002/01/23 21:59:52 mickey Exp $	*/
d214 5
d224 1
a487 3
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif
d499 1
a499 1
			    BUFCACHEPERCENT / 100;
@


1.195
log
@recognize athlon model 6 and model 7; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.194 2002/01/23 17:51:52 art Exp $	*/
d1605 1
a1605 4
	if (howto & RB_DUMP) {
		/* Save registers. */
		savectx(&dumppcb);

a1606 1
	}
@


1.194
log
@move mb_map allocation to mbinit()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.193 2002/01/23 17:35:56 art Exp $	*/
d785 3
a787 1
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@


1.193
log
@move definition of mb_map from zillions of machdep.c to uipc_mbuf.c
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.192 2002/01/16 20:50:16 miod Exp $	*/
a396 3

	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
@


1.192
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.191 2002/01/09 23:08:34 nordin Exp $	*/
a244 1
struct vm_map *mb_map = NULL;
@


1.191
log
@Call gdt_init() earlier and only once. Work done with millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.190 2001/12/14 08:35:12 niklas Exp $	*/
a84 1
#include <sys/map.h>
@


1.190
log
@SMALL_KERNEL -> outline splx
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.189 2001/12/08 02:24:06 art Exp $	*/
a434 1
	gdt_init();
@


1.190.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.196 2002/01/28 23:14:24 mickey Exp $	*/
d85 1
d246 1
d400 3
d435 1
d791 1
a791 3
				0, "Athlon Model 6 (Palomino)",
				"Athlon Model 7 (Morgan)", 0,
				0, 0, 0, 0, 0, 0, 0,
d1609 4
a1612 1
	if (howto & RB_DUMP)
d1614 1
@


1.190.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.190.2.1 2002/01/31 22:55:11 niklas Exp $	*/
a213 5

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

a218 1
int	bufcachepercent = BUFCACHEPERCENT;
d267 12
a278 12
caddr_t	allocsys(caddr_t);
void	setup_buffers(vm_offset_t *);
void	dumpsys(void);
int	cpu_dump(void);
void	identifycpu(void);
void	init386(vm_offset_t);
void	consinit(void);

int	bus_mem_add_mapping(bus_addr_t, bus_size_t,
	    int, bus_space_handle_t *);
int	_bus_dmamap_load_buffer(bus_dma_tag_t, bus_dmamap_t, void *,
    bus_size_t, struct proc *, int, paddr_t *, int *, int);
d303 1
a303 1
void kgdb_port_init(void);
d314 6
a319 7
void	winchip_cpu_setup(const char *, int, int);
void	cyrix3_cpu_setup(const char *, int, int);
void	cyrix6x86_cpu_setup(const char *, int, int);
void	intel586_cpu_setup(const char *, int, int);
void	intel686_cpu_setup(const char *, int, int);
char *	intel686_cpu_name(int);
char *	cyrix3_cpu_name(int, int);
a466 3
	shminfo.shmmax = shmmaxpgs;
	shminfo.shmall = shmmaxpgs;
	shminfo.shmseg = shmseg;
d482 3
d496 1
a496 1
			    bufcachepercent / 100;
d504 1
a504 2
	/* Restrict to at most 35% filled kvm */
	/* XXX - This needs UBC... */
d506 1
a506 1
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 35 / 100) 
d508 1
a508 1
		    MAXBSIZE * 35 / 100;
d622 1
d856 3
a858 4
				0, 0, 0, 0, 0, 0, "C3 Samuel 1",
				"C3 Samule 2/Ezra",
				"C3 Ezra-T", 0, 0, 0, 0, 0, 0, 0,
				"C3"		/* Default */
a931 25
	},
	{
		"Geode by NSC",
		CPUVENDOR_NS,
		"National Semiconductor",
		/* Family 4, not available from National Semiconductor */
		{ {
			CPUCLASS_486,
			{
				0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
				"486 class"	/* Default */
			},
			NULL
		},
		/* Family 5 */
		{
			CPUCLASS_586,
			{
				0, 0, 0, 0, "Geode GX1", 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0,
				"M1 class"	/* Default */
			},
			cyrix6x86_cpu_setup
		} }
d991 1
a991 3
	case 6: /* C3 Samuel 1 */
	case 7: /* C3 Samuel 2 or C3 Ezra */
	case 8: /* C3 Ezra-T */
d1010 1
a1010 1
	extern int clock_broken_latch;
d1030 3
a1032 2
	case 4:
		clock_broken_latch = 1;
a1128 21
char *
cyrix3_cpu_name(model, step)
	int model, step;
{
	char	*name = NULL;

	switch (model) {
	case 7:
		if (step < 8)
			name = "C3 Samuel 2";
		else
			name = "C3 Ezra";
		break;
	case 8:
		if (step < 8)
			name = "C3 Ezra-T";
		break;
	}
	return name;
}

d1145 1
a1145 1
	void (*cpu_setup)(const char *, int, int);
a1194 2
			if (class > CPUCLASS_686)
				class = CPUCLASS_686;
a1202 5
			/* Special hack for the VIA C3 series. */
			if (vendor == CPUVENDOR_IDT && family >= 6) {
				vendor = CPUVENDOR_VIA;
				vendorname = "VIA";
			}
a1214 4
			/* Special hack for the VIA C3 series. */
			} else if (vendor == CPUVENDOR_VIA && family == 6 &&
				   model >= 7 && model <= 8) {
				name = cyrix3_cpu_name(model, step);
d1217 1
a1217 1
			if (name == NULL) {
a1218 3
				if (name == NULL)
					name = "";
			}
d1353 1
a1353 1
void ibcs2_sendsig(sig_t, int, int, u_long, int, union sigval);
d1435 2
a1436 2
		__asm("movw %%gs,%w0" : "=r" (frame.sf_sc.sc_gs));
		__asm("movw %%fs,%w0" : "=r" (frame.sf_sc.sc_fs));
d1475 2
a1476 2
	__asm("movw %w0,%%gs" : : "r" (GSEL(GUDATA_SEL, SEL_UPL)));
	__asm("movw %w0,%%fs" : : "r" (GSEL(GUDATA_SEL, SEL_UPL)));
d1703 1
a1703 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d1742 1
a1742 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d1877 2
a1878 2
	__asm("movw %w0,%%gs" : : "r" (LSEL(LUDATA_SEL, SEL_UPL)));
	__asm("movw %w0,%%fs" : : "r" (LSEL(LUDATA_SEL, SEL_UPL)));
d2116 1
a2116 1
			register paddr_t a, e;
d2170 2
a2171 2
		paddr_t a, e;
		paddr_t lim;
a3323 10

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	if (cpl < wantipl) {
		splassert_fail(wantipl, cpl, func);
	}
}
#endif
@


1.190.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.190.2.2 2002/06/11 03:35:53 art Exp $	*/
d168 5
d177 1
a177 1
#if NPCCOM > 0
a322 1
void	natsem6x86_cpu_setup(const char *, int, int);
d963 1
a963 1
			natsem6x86_cpu_setup
a1066 1
		cpu_feature &= ~CPUID_TSC;
a1072 12
natsem6x86_cpu_setup(cpu_device, model, step)
	const char *cpu_device;
	int model, step;
{
#if defined(I586_CPU) || defined(I686_CPU)
	extern int clock_broken_latch;

	clock_broken_latch = 1;
#endif
}

void
d1456 2
a1457 3
	struct proc *p = curproc;
	struct pmap *pmap = vm_map_pmap(&p->p_vmspace->vm_map);
	struct trapframe *tf = p->p_md.md_regs;
d1460 2
a1461 1
	int oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d1468 3
d1548 2
a1549 3
	tf->tf_eip = p->p_sigcode;
	tf->tf_cs = pmap->pm_nxpages > 0?
	    GSEL(GUCODE1_SEL, SEL_UPL) : GSEL(GUCODE_SEL, SEL_UPL);
d1928 2
a1929 3
	struct pcb *pcb = &p->p_addr->u_pcb;
	struct pmap *pmap = vm_map_pmap(&p->p_vmspace->vm_map);
	struct trapframe *tf = p->p_md.md_regs;
d1945 1
d1953 1
a1953 2
	tf->tf_cs = pmap->pm_nxpages > 0?
	    LSEL(LUCODE1_SEL, SEL_UPL) : LSEL(LUCODE_SEL, SEL_UPL);
d2100 1
a2100 4
	setsegment(&gdt[GUCODE1_SEL].sd, 0, i386_btop(VM_MAXUSER_ADDRESS) - 1,
	    SDT_MEMERA, SEL_UPL, 1, 1);
	setsegment(&gdt[GUCODE_SEL].sd, 0,
	    i386_btop(VM_MAXUSER_ADDRESS - MAXSSIZ) - 1,
a2107 1
	ldt[LUCODE1_SEL] = gdt[GUCODE1_SEL];
d2393 3
d2397 1
@


1.190.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d107 6
a137 1
#include <dev/rndvar.h>
a203 4
#ifdef USER_LDT
int	user_ldt_enable = 0;	/* sysctl'd to 1 to enable */
#endif

d225 2
a226 2
	paddr_t	start;
	paddr_t	end;
d243 1
a243 1
paddr_t avail_end;
d269 1
a269 1
void	setup_buffers(vaddr_t *);
d273 1
a273 1
void	init386(paddr_t);
a280 2
int	longrun_sysctl(void *, size_t *, void *, size_t);

a315 1
void	amd_family5_setup(const char *, int, int);
a320 1
void	tm86_cpu_setup(const char *, int, int);
a322 1
void	viac3_rnd(void *);
d469 12
a480 1

d524 1
a524 1
	vaddr_t *maxaddr;
d526 2
a527 2
	vsize_t size;
	vaddr_t addr;
d611 1
a611 1
		addr = (vaddr_t)buffers + i * MAXBSIZE;
d780 1
a780 1
			amd_family5_setup
d787 4
a790 7
				"Duron Model 3 (Spitfire)",
				"Athlon Model 4 (Thunderbird)",
				0, "Athlon XP Model 6 (Palomino)",
				"Duron Model 7 (Morgan)", 
				"Athlon XP Model 8 (Thoroughbred)",
				0, "Athlon XP Model 10 (Barton)",
				0, 0, 0, 0, 0,
d924 1
a924 1
			tm86_cpu_setup
d926 1
a926 1
		/* Family 6, not yet available from Transmeta */
a1009 62
#if defined(I686_CPU)
/*
 * Note, the VIA C3 Nehemia provides 4 internal 8-byte buffers, which
 * store random data, and can be accessed a lot quicker than waiting
 * for new data to be generated.  As we are using every 8th bit only
 * due to whitening. Since the RNG generates in excess of 21KB/s at
 * it's worst, collecting 64 bytes worth of entropy should not affect
 * things significantly.
 *
 * Note, due to some weirdness in the RNG, we need at least 7 bytes
 * extra on the end of our buffer.  Also, there is an outside chance
 * that the VIA RNG can "wedge", as the generated bit-rate is variable.
 * We could do all sorts of startup testing and things, but
 * frankly, I don't really see the point.  If the RNG wedges, then the
 * chances of you having a defective CPU are very high.  Let it wedge.
 *
 * Adding to the whole confusion, in order to access the RNG, we need
 * to have FXSR support enabled, and the correct FPU enable bits must
 * be there to enable the FPU in kernel.  It would be nice if all this
 * mumbo-jumbo was not needed in order to use the RNG.  Oh well, life
 * does go on...
 */
#define VIAC3_RNG_BUFSIZ	16		/* 32bit words */
struct timeout viac3_rnd_tmo;
int viac3_rnd_present = 0;

void
viac3_rnd(void *v)
{
	struct timeout *tmo = v;
	unsigned int *p, i, rv, creg0, creg4, len = VIAC3_RNG_BUFSIZ;
	static int buffer[VIAC3_RNG_BUFSIZ + 2];
	int s;

	s = splhigh();
	/* XXX - should not be needed, but we need FXSR & FPU set to access RNG */
	creg0 = rcr0();
	lcr0(creg0 & ~(CR0_EM|CR0_TS));
	creg4 = rcr4();
	lcr4(creg4 | CR4_OSFXSR);

	/*
	 * Here we collect the random data from the VIA C3 RNG.  We make
	 * sure that we turn on maximum whitening (%edx[0,1] == "11"), so
	 * that we get the best random data possible.
	 */
	__asm __volatile ("rep;.byte 0x0F,0xA7,0xC0"
	    : "=a" (rv) : "d" (3), "D" (buffer), "c" (len*sizeof(int))
	    : "memory", "cc");

	/* XXX - should not be needed */
	lcr0(creg0);
	lcr4(creg4);

	for (i = 0, p = buffer; i < VIAC3_RNG_BUFSIZ; i++, p++)
		add_true_randomness(*p);

	timeout_add(tmo, (hz>100)?(hz/100):1);
	splx(s);
}
#endif

a1030 39

	case 9:
		if (step < 3)
			break;

		/* 
		 * C3 Nehemia:
		 * First we check for extended feature flags, and then
		 * (if present) retrieve the ones at 0xC0000001.  In this
		 * bit 2 tells us if the RNG is present.  Bit 3 tells us
		 * if the RNG has been enabled.  In order to use the RNG
		 * we need 3 things:  We need an RNG, we need the FXSR bit
		 * enabled in cr4 (SSE/SSE2 stuff), and we need to have
		 * Bit 6 of MSR 0x110B set to 1 (the default), which will
		 * show up as bit 3 set here.
		 */
		__asm __volatile("cpuid" /* Check for RNG */
		    : "=a" (val) : "a" (0xC0000000) : "cc");
		if (val >= 0xC0000001) {
			__asm __volatile("cpuid"
			    : "=d" (val) : "a" (0xC0000001) : "cc");
		}

		/* Stop here if no RNG */
		if (!(val & 0x4))
			break;

		/* Enable RNG if disabled */
		if (!(val & 0x8)) {
			u_int64_t msreg;

			msreg = rdmsr(0x110B);
			msreg |= 0x40;
			wrmsr(0x110B, msreg);
			printf("Screwed with MSR 0x110B!\n");
		}
		viac3_rnd_present = 1;
		printf("%s: RNG activated\n", cpu_device);
		break;
a1092 23
amd_family5_setup(cpu_device, model, step)
	const char *cpu_device;
	int model, step;
{
	switch (model) {
	case 0:         /* AMD-K5 Model 0 */
		/*
		 * According to the AMD Processor Recognition App Note,
		 * the AMD-K5 Model 0 uses the wrong bit to indicate
		 * support for global PTEs, instead using bit 9 (APIC)
		 * rather than bit 13 (i.e. "0x200" vs. 0x2000".  Oops!).
		 */
		if (cpu_feature & CPUID_APIC)
			cpu_feature = (cpu_feature & ~CPUID_APIC) | CPUID_PGE;
		/*
		 * XXX But pmap_pg_g is already initialized -- need to kick
		 * XXX the pmap somehow.  How does the MP branch do this?
		 */
		break;
	}
}

void
a1130 12
void
tm86_cpu_setup(cpu_device, model, step)
	const char *cpu_device;
	int model, step;
{
#ifndef SMALL_KERNEL
	extern int longrun_enabled;

	longrun_enabled = 1;
#endif
}

a1188 3
	case 9:
		name = "C3 Nehemia";
		break;
d1312 4
a1315 5
		snprintf(cpu_model, sizeof(cpu_model),
		    "%s %s%s (%s%s%s%s-class, %dKB L2 cache)",
		    vendorname, modifier, name,
		    ((*token) ? "\"" : ""), ((*token) ? token : ""),
		    ((*token) ? "\" " : ""), classnames[class], cachesize);
d1317 4
a1320 5
		snprintf(cpu_model, sizeof(cpu_model),
		    "%s %s%s (%s%s%s%s-class)",
		    vendorname, modifier, name,
		    ((*token) ? "\"" : ""), ((*token) ? token : ""),
		    ((*token) ? "\" " : ""), classnames[class]);
d1555 1
a1555 1
	tf->tf_cs = pmap->pm_hiexec > I386_MAX_EXE_ADDR ? 
d1801 1
a1801 1
static vaddr_t dumpspace;
d1803 3
a1805 2
vaddr_t
reserve_dumppages(vaddr_t p)
d1809 1
a1809 1
	return (p + PAGE_SIZE);
d1960 1
a1960 1
	tf->tf_cs = pmap->pm_hiexec > I386_MAX_EXE_ADDR ? 
d2041 1
a2041 1
fix_f00f(void)
d2044 1
a2044 1
	vaddr_t va;
d2074 2
a2075 1
init386(paddr_t first_avail)
d2110 2
a2111 1
	setsegment(&gdt[GUCODE_SEL].sd, 0, i386_btop(I386_MAX_EXE_ADDR) - 1,
d2161 1
a2161 1
	pmap_bootstrap((vaddr_t)atdevbase + IOM_SIZE);
d2209 1
a2209 1
			if (a >= e || (e - a) < NBPG) {
a2533 9
#ifdef USER_LDT
	case CPU_USERLDT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &user_ldt_enable));
#endif
#ifndef SMALL_KERNEL
	case CPU_LONGRUN:
		return (longrun_sysctl(oldp, oldlenp, newp, newlen));
#endif
d2535 1
a2535 1
		return (EOPNOTSUPP);
d2710 1
a2710 1
	vaddr_t va;
d3152 1
a3152 1
	vaddr_t va;
d3196 1
a3196 1
	uvm_km_free(kernel_map, (vaddr_t)kva, size);
d3274 1
a3274 1
		pmap_extract(pmap, vaddr, (paddr_t *)&curaddr);
d3345 2
a3346 2
	paddr_t low;
	paddr_t high;
d3348 1
a3348 1
	paddr_t curaddr, lastaddr;
@


1.189
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.188 2001/12/07 17:30:14 art Exp $	*/
d3332 3
@


1.188
log
@Use pmap_kenter for buffers and msgbuf.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.187 2001/11/28 16:24:26 art Exp $	*/
d362 1
d621 1
d2675 1
a2675 1
	tlbflush();
d3105 1
a3105 1
	tlbflush();
@


1.187
log
@more typedef zapping vm_page_t -> struct vm_page *
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.186 2001/11/28 16:13:28 art Exp $	*/
d348 2
a349 1
	vm_offset_t minaddr, maxaddr, pa;
d356 6
a361 5
	for (i = 0; i < btoc(MSGBUFSIZE); i++, pa += NBPG)
		pmap_enter(pmap_kernel(),
		    (vm_offset_t)((caddr_t)msgbufp + i * NBPG), pa,
		    VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d603 1
a603 1
	pg = pgs.tqh_first;
d614 4
a617 5
		    size > 0; size -= NBPG, addr += NBPG) {
			pmap_enter(pmap_kernel(), addr, pg->phys_addr,
			    VM_PROT_READ|VM_PROT_WRITE,
			    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
			pg = pg->pageq.tqe_next;
@


1.186
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.185 2001/11/28 15:02:58 art Exp $	*/
d529 1
a529 1
	vm_page_t pg;
d3046 1
a3046 1
	vm_page_t m;
d3277 1
a3277 1
	vm_page_t m;
@


1.185
log
@Don't use pmap_update when we mean tlbflush. make pmap_update into a noop.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.184 2001/11/28 13:47:38 art Exp $	*/
d245 3
a247 3
vm_map_t exec_map = NULL;
vm_map_t mb_map = NULL;
vm_map_t phys_map = NULL;
@


1.184
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.183 2001/11/24 17:53:41 miod Exp $	*/
d2212 1
a2212 1
	pmap_update();
d2380 1
a2380 1
	pmap_update(); 
d2672 1
a2672 1
	pmap_update();
d3102 1
a3102 1
	pmap_update();
@


1.183
log
@Harmonize boot() logic across arches:
- ensure RB_DUMP | RB_HALT will cause a dump
- or RB_HALT if (cold)
While there, honor RB_TIMEBAD on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.182 2001/11/09 15:25:55 art Exp $	*/
d535 1
a535 1
				UVM_ADV_NORMAL, 0)) != KERN_SUCCESS)
@


1.182
log
@nswbuf hasn't been used for ages. gc.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.181 2001/11/07 01:18:00 art Exp $	*/
d1606 1
a1606 1
	if ((howto & (RB_DUMP | RB_HALT)) == RB_DUMP) {
@


1.181
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.180 2001/11/06 01:43:48 art Exp $	*/
a209 1
int	nswbuf = 0;
a516 5
	if (nswbuf == 0) {
		nswbuf = (nbuf / 2) &~ 1;	/* force even */
		if (nswbuf > 256)
			nswbuf = 256;		/* sanity */
	}
@


1.180
log
@Zap some redundant includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.179 2001/11/05 17:25:57 art Exp $	*/
d539 1
a539 1
		    NULL, UVM_UNKNOWN_OFFSET,
@


1.179
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.178 2001/10/04 21:25:03 mickey Exp $	*/
a121 2
#include <vm/vm.h>
#include <vm/vm_page.h>
@


1.178
log
@in _bus_dmamem_alloc_range() use TAILQ_*() instead of tq*_* internals; more diagnostic checks
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.177 2001/10/04 21:20:12 mickey Exp $	*/
d3015 1
a3015 1
_bus_dmamap_sync(t, map, op)
d3018 3
a3020 1
	bus_dmasync_op_t op;
@


1.178.2.1
log
@Pull in patch from current:
Fix (nordin):
Call gdt_init() earlier and only once. Work done with millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.178 2001/10/04 21:25:03 mickey Exp $	*/
d435 1
@


1.177
log
@copy of macppc's bus_dmamap_load_raw() implementatio; not used on i386 yet
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.176 2001/09/19 20:50:56 mickey Exp $	*/
d3303 1
a3303 1
	m = mlist.tqh_first;
a3306 1
	m = m->pageq.tqe_next;
d3308 1
a3308 1
	for (; m != NULL; m = m->pageq.tqe_next) {
d3311 4
d3316 1
a3316 1
			printf("vm_page_alloc_memory returned non-sensical"
@


1.176
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.175 2001/09/12 00:23:33 art Exp $	*/
d2968 2
d2971 19
a2989 1
	panic("_bus_dmamap_load_raw: not implemented");
@


1.175
log
@mbutl no more
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.174 2001/08/23 14:01:03 art Exp $	*/
a122 1
#include <vm/vm_kern.h>
a123 1

@


1.174
log
@We can now move timeout_init into main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.173 2001/08/23 12:02:04 art Exp $	*/
d402 1
a402 1
	mb_map = uvm_km_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
@


1.173
log
@Remove even more old timeout tentacles.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.172 2001/08/23 11:06:27 art Exp $	*/
a403 5

	/*
	 * Initialize timeouts
	 */
	timeout_init();
@


1.172
log
@fix a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.171 2001/07/30 14:15:59 art Exp $	*/
a478 1
	valloc(timeouts, struct timeout, ntimeout);
@


1.171
log
@Change:
int bus_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t, int, int, int, int);
to:
paddr_t bus_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t, int, int, off_t, int);

To allow mmaping offsets larger than INT_MAX. And to simply make more sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.170 2001/07/25 13:25:32 art Exp $	*/
d357 1
a357 1
	 * (space reserved in /boot)
@


1.170
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.169 2001/07/15 10:54:44 niklas Exp $	*/
d3125 1
a3125 1
int
d3129 3
a3131 1
	int nsegs, off, prot, flags;
@


1.169
log
@Some more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.168 2001/07/15 10:48:30 niklas Exp $	*/
d363 2
a364 2
		    VM_PROT_READ|VM_PROT_WRITE, TRUE,
		    VM_PROT_READ|VM_PROT_WRITE);
d630 2
a631 2
			    VM_PROT_READ|VM_PROT_WRITE, TRUE,
			    VM_PROT_READ|VM_PROT_WRITE);
d1818 1
a1818 1
			    VM_PROT_READ, TRUE, 0);
d2113 2
a2114 2
		    VM_PROT_READ|VM_PROT_WRITE, TRUE,
		    VM_PROT_READ|VM_PROT_WRITE);
d3092 2
a3093 2
			    VM_PROT_READ | VM_PROT_WRITE, TRUE,
			    VM_PROT_READ | VM_PROT_WRITE);
@


1.168
log
@Comment clarification and indent; ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.167 2001/07/05 10:00:30 art Exp $	*/
d2106 1
a2106 1
			panic ("too many boot args");
d2151 1
a2151 1
				printf ("-S");
d2205 1
a2205 1
				printf (" %x-%x (<16M)", a, lim);
d2211 1
a2211 1
					printf (" %x-%x", lim, e);
d2218 1
a2218 1
				printf (" %x-%x", a, e);
@


1.167
log
@Get rid of the wrapper macros around extent_alloc*1
Pass the right amount of arguments and rename them back to their right names.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.166 2001/06/29 19:56:37 jason Exp $	*/
d2103 1
a2103 1
	/* Boot arguments are in page 1 */
d2108 2
a2109 2
		if (extent_alloc_region(iomem_ex, (paddr_t)bootargv,
					bootargc, EX_NOWAIT))
@


1.166
log
@merge a bit of bus_dma* from netbsd
convert some NBPG->PAGE_SIZE
add missing initialization missed in previous merge
use kernel_map not kmem_map
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.165 2001/06/27 05:38:28 deraadt Exp $	*/
a478 3
#ifdef REAL_CLISTS
	valloc(cfree, struct cblock, nclist);
#endif
d2612 1
a2612 1
	error = extent_alloc_subregion(ex, rstart, rend, size, alignment,
@


1.165
log
@stupid american river
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.164 2001/06/25 00:43:11 mickey Exp $	*/
d2674 2
a2675 4
	for (; pa < endpa; pa += NBPG, va += NBPG) {
		pmap_enter(pmap_kernel(), va, pa,
		    VM_PROT_READ | VM_PROT_WRITE, TRUE,
		    VM_PROT_READ | VM_PROT_WRITE);
d2691 2
a2692 1
 
d2709 1
a2709 2
	switch (t) {
	case I386_BUS_SPACE_IO:
d2712 1
a2712 3
		break;

	case I386_BUS_SPACE_MEM:
d2716 1
a2716 1
			break;
d2726 1
a2726 1
		pmap_extract(pmap_kernel(), va, &bpa);
d2733 1
a2733 3
		break;

	default:
a2734 1
	}
d2736 1
d2810 2
a2811 1
	map->dm_nsegs = 0;		/* no valid mappings */
d2997 1
d3082 1
a3082 1
	va = uvm_km_valloc(kmem_map, size);
d3091 1
a3091 1
		    addr += NBPG, va += NBPG, size -= NBPG) {
d3099 1
d3121 1
a3121 1
	uvm_km_free(kmem_map, (vm_offset_t)kva, size);
@


1.164
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.163 2001/06/08 08:08:51 art Exp $	*/
d720 2
a721 1
				0, "Pentium III Xeon (Cascades)", 0, 0, 0,
@


1.163
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.162 2001/05/17 18:41:48 provos Exp $	*/
a1593 2
	extern int cold;

@


1.162
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.161 2001/05/13 19:06:52 jason Exp $	*/
d2731 2
a2732 1
		bpa = pmap_extract(pmap_kernel(), va) + (bsh & PGOFSET);
d3201 1
a3201 1
		curaddr = (bus_addr_t)pmap_extract(pmap, (vm_offset_t)vaddr);
@


1.161
log
@in bus_dmamap_load_mbuf(), segments start at zero, not one (merge error)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.160 2001/05/08 18:19:43 jason Exp $	*/
a401 7
	/*
	 * Finally, allocate mbuf pool.  Since mclrefcnt is an off-size
	 * we use the more space efficient malloc in place of kmem_alloc.
	 */
	mclrefcnt = (char *)malloc(NMBCLUSTERS+PAGE_SIZE/MCLBYTES, M_MBUF,
	    M_NOWAIT);
	bzero(mclrefcnt, NMBCLUSTERS+PAGE_SIZE/MCLBYTES);
@


1.160
log
@From netbsd: implementations of _bus_dmamap_load_mbuf() and
_bus_dmamap_load_uio().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.159 2001/05/05 23:25:37 art Exp $	*/
d2906 1
a2906 1
	seg = 1;
@


1.159
log
@PMAP_NEW and UVM are no longer optional on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.158 2001/05/05 22:33:45 art Exp $	*/
d284 2
d2855 2
a2856 5
	bus_size_t sgsize;
	bus_addr_t curaddr, lastaddr, baddr, bmask;
	vaddr_t vaddr = (vaddr_t)buf;
	int first, seg;
	pmap_t pmap;
d2861 1
d2867 6
a2872 57
	if (p != NULL)
		pmap = p->p_vmspace->vm_map.pmap;
	else
		pmap = pmap_kernel();

	lastaddr = ~0;		/* XXX gcc */
	bmask  = ~(map->_dm_boundary - 1);

	for (first = 1, seg = 0; buflen > 0; ) {
		/*
		 * Get the physical address for this segment.
		 */
		curaddr = (bus_addr_t)pmap_extract(pmap, (vm_offset_t)vaddr);

		/*
		 * Compute the segment size, and adjust counts.
		 */
		sgsize = NBPG - ((u_long)vaddr & PGOFSET);
		if (buflen < sgsize)
			sgsize = buflen;

		/*
		 * Make sure we don't cross any boundaries.
		 */
		if (map->_dm_boundary > 0) {
			baddr = (curaddr + map->_dm_boundary) & bmask;
			if (sgsize > (baddr - curaddr))
				sgsize = (baddr - curaddr);
		}

		/*
		 * Insert chunk into a segment, coalescing with
		 * previous segment if possible.
		 */
		if (first) {
			map->dm_segs[seg].ds_addr = curaddr;
			map->dm_segs[seg].ds_len = sgsize;
			first = 0;
		} else {
			if (curaddr == lastaddr &&
			    (map->dm_segs[seg].ds_len + sgsize) <=
			     map->_dm_maxsegsz &&
			     (map->_dm_boundary == 0 ||
			     (map->dm_segs[seg].ds_addr & bmask) ==
			     (curaddr & bmask)))
				map->dm_segs[seg].ds_len += sgsize;
			else {
				if (++seg >= map->_dm_segcnt)
					break;
				map->dm_segs[seg].ds_addr = curaddr;
				map->dm_segs[seg].ds_len = sgsize;
			}
		}

		lastaddr = curaddr + sgsize;
		vaddr += sgsize;
		buflen -= sgsize;
d2874 1
a2874 9

	/*
	 * Did we fit?
	 */
	if (buflen != 0)
		return (EFBIG);		/* XXX better return value here? */

	map->dm_nsegs = seg + 1;
	return (0);
d2881 1
a2881 1
_bus_dmamap_load_mbuf(t, map, m, flags)
d2884 1
a2884 1
	struct mbuf *m;
d2887 3
d2891 27
a2917 1
	panic("_bus_dmamap_load: not implemented");
d2930 12
d2943 33
a2975 1
	panic("_bus_dmamap_load_uio: not implemented");
d3171 93
@


1.158
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.157 2001/05/05 20:56:38 art Exp $	*/
a125 1
#if defined(UVM)
a126 1
#endif
a198 1
#ifdef UVM
a201 5
#else
#define ALLOC_PGS(sz, limit, pgs) \
    vm_page_alloc_memory((sz), 0, (limit), PAGE_SIZE, 0, &(pgs), 1, 0)
#define FREE_PGS(pgs) vm_page_free_memory(&(pgs))
#endif
a249 1
#if defined(UVM)
a252 3
#else
vm_map_t buffer_map;
#endif
a375 1
#if defined(UVM)
a376 3
#else
	if ((v = (caddr_t)kmem_alloc(kernel_map, round_page(sz))) == 0)
#endif
a390 1
#if defined(UVM)
a392 4
#else
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr, 16*NCARGS,
	    TRUE);
#endif
a396 1
#if defined(UVM)
a398 4
#else
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr, VM_PHYS_SIZE,
	    TRUE);
#endif
a406 1
#if defined(UVM)
a408 4
#else
	mb_map = kmem_suballoc(kernel_map, (vm_offset_t *)&mbutl, &maxaddr,
	    VM_MBUF_SIZE, FALSE);
#endif
a414 1
#if defined(UVM)
a416 4
#else
	printf("avail mem = %lu (%uK)\n", ptoa(cnt.v_free_count),
	    ptoa(cnt.v_free_count)/1024);
#endif
a540 3
#if !defined(UVM)
	valloc(swbuf, struct buf, nswbuf);
#endif
a555 1
#if defined(UVM)
a561 8
#else
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
	    maxaddr, size, TRUE);
	addr = (vm_offset_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
	    &addr, size, FALSE) != KERN_SUCCESS)
		panic("startup: cannot allocate buffers");
#endif
a1989 3
#ifndef PMAP_NEW
pt_entry_t *pmap_pte __P((pmap_t, vm_offset_t));
#endif
a2001 1
#if defined(UVM)
a2002 3
#else
	va = kmem_alloc(kernel_map, NBPG*2);
#endif
a2013 1
#ifdef PMAP_NEW
a2014 3
#else
	pte = pmap_pte(pmap_kernel(), va);
#endif
a2200 1
#ifdef UVM
a2201 1
#endif
a2210 1
#ifdef UVM
a2231 3
#else
			vm_page_physload(a, e, a, e);
#endif
a2663 1
#ifdef PMAP_NEW
a2664 1
#endif
a2673 1
#if defined(UVM)
a2674 3
#else
	va = kmem_alloc_pageable(kernel_map, endpa - pa);
#endif
a2690 1
#ifdef PMAP_NEW
a2696 6
#else
			if (!cacheable)
				pmap_changebit(pa, PG_N, ~0);
			else
				pmap_changebit(pa, 0, ~PG_N);
#endif
a2740 1
#if defined(UVM)
a2741 3
#else
		kmem_free(kernel_map, va, endva - va);
#endif
a3057 1
#if defined(UVM)
a3058 3
#else
	vm_page_free_memory(&mlist);
#endif
a3078 1
#if defined(UVM)
a3079 3
#else
	va = kmem_alloc_pageable(kmem_map, size);
#endif
a3116 1
#if defined(UVM)
a3117 3
#else
	kmem_free(kmem_map, (vm_offset_t)kva, size);
#endif
a3185 1
#if defined(UVM)
a3187 4
#else
	error = vm_page_alloc_memory(size, low, high,
	    alignment, boundary, &mlist, nsegs, (flags & BUS_DMA_NOWAIT) == 0);
#endif
@


1.157
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.156 2001/04/30 13:23:11 art Exp $	*/
a471 1
	configure();
@


1.156
log
@Move proc0's TSS and LDT initialization to a separate function
that's called at the end of configure instead of cpu_startup.

Inspired by NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.155 2001/04/09 07:14:15 tholo Exp $	*/
d203 1
a203 1
    uvm_pglistalloc((sz), 0, (limit), CLBYTES, 0, &(pgs), 1, 0)
d207 1
a207 1
    vm_page_alloc_memory((sz), 0, (limit), CLBYTES, 0, &(pgs), 1, 0)
d430 1
a430 1
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES, M_MBUF,
d432 1
a432 1
	bzero(mclrefcnt, NMBCLUSTERS+CLBYTES/MCLBYTES);
d454 1
a454 1
		nbuf, bufpages * CLBYTES, bufpages * CLBYTES / 1024);
d552 1
a552 1
			bufpages = physmem / (10 * CLSIZE);
d555 1
a555 1
			    BUFCACHEPERCENT / (100 * CLSIZE);
d570 2
a571 2
	if (bufpages > nbuf * MAXBSIZE / CLBYTES)
		bufpages = nbuf * MAXBSIZE / CLBYTES;
d614 1
a614 1
	if (base >= MAXBSIZE / CLBYTES) {
d616 1
a616 1
		base = MAXBSIZE / CLBYTES;
d655 2
a656 2
			chunk = min(left, CHUNKSZ / CLBYTES);
			if (ALLOC_PGS(chunk * CLBYTES, ISADMA_LIMIT, pgs))
d664 1
a664 1
	if (left > 0 && ALLOC_PGS(left * CLBYTES, avail_end, pgs))
d684 1
a684 1
		for (size = CLBYTES * (i < residual ? base + 1 : base);
d1740 1
a1740 1
 * Dumps always skip the first CLBYTES of disk space
d1762 1
a1762 1
	/* Always skip the first CLBYTES, in case there is a label there. */
@


1.155
log
@Add emulation of Linux features to procfs; mostly from NetBSD.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.154 2001/03/30 22:18:29 mickey Exp $	*/
a363 2
	struct pcb *pcb;
	int x;
d473 10
d484 1
a484 3
	/*
	 * Set up proc0's TSS and LDT.
	 */
d493 1
a493 1
	pcb->pcb_ldt_sel = GSEL(GLDT_SEL, SEL_KPL);
@


1.154
log
@ok, test wheather cyrixIII supports 3dnow before enabling it
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.153 2001/03/28 19:50:07 mickey Exp $	*/
d251 3
@


1.153
log
@identify Cyrix III; from Armin Wolfermann <armin@@wolfermann.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.152 2001/03/22 23:36:51 niklas Exp $	*/
d329 1
d924 1
a924 1
			winchip_cpu_setup
d1030 1
a1030 1
#if defined(I586_CPU) || defined(I686_CPU)
d1041 14
d1056 7
a1062 2
		cpu_feature |= CPUID_CX8;
		cpu_feature |= CPUID_3DNOW;
@


1.152
log
@Merge in NetBSD's PMAP_NEW, still disabled
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.151 2001/03/16 00:24:00 deraadt Exp $	*/
d915 1
a915 1
		/* Family 6, not yet available from IDT */
d919 1
d921 1
a921 2
				0, 0, 0, 0, 0, 0, 0, 0,
				"686 class"		/* Default */
d923 1
a923 1
			NULL
d1029 1
a1029 1
#if defined(I586_CPU)
d1039 4
@


1.151
log
@mislabeling
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.150 2001/02/28 19:13:29 mickey Exp $	*/
d2006 1
d2008 1
d2037 3
d2041 1
d2062 1
d2432 1
d2439 1
d2697 3
d2730 8
d2742 1
d2905 1
a2905 1
	caddr_t vaddr = buf;
@


1.150
log
@double the fixed storage size for io*_ex; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.149 2001/02/25 23:24:18 aaron Exp $	*/
d763 1
a763 1
				"Pentium III/Celeron (Coppermine)",
@


1.149
log
@Add wscons_machdep.c which is a constab-style wrapper driver for wscons on
i386. This fixes serial console. millert@@, mickey@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.148 2001/02/04 17:28:17 aaron Exp $	*/
d277 2
a278 2
static	long ioport_ex_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof(long)];
static	long iomem_ex_storage[EXTENT_FIXED_STORAGE_SIZE(8) / sizeof(long)];
@


1.148
log
@#endif in the wrong place, causing certain kernel configs to not compile;
brian@@Awfulhak.org
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.147 2001/01/30 00:00:31 aaron Exp $	*/
a174 26
#include "vga.h"
#include "ega.h"
#include "pcdisplay.h"
#if (NVGA > 0) || (NEGA > 0) || (NPCDISPLAY > 0)
#include <dev/ic/mc6845reg.h>
#include <dev/ic/pcdisplayvar.h>
#if (NVGA > 0)
#include <dev/ic/vgareg.h>
#include <dev/ic/vgavar.h>
#endif
#if (NEGA > 0)
#include <dev/isa/egavar.h>
#endif
#if (NPCDISPLAY > 0)
#include <dev/isa/pcdisplayvar.h>
#endif
#endif

#include "pckbc.h"
#if (NPCKBC > 0)
#include <dev/isa/isareg.h>
#include <dev/ic/i8042reg.h>
#include <dev/ic/pckbcvar.h>
#endif
#include "pckbd.h"	/* for pckbc_machdep_cnattach */

a2366 1
#if 0
a2367 24
#endif

#if (NPC > 0) || (NVGA > 0) || (NEGA > 0) || (NPCDISPLAY > 0)
#if (NVGA > 0)
	if (!vga_cnattach(I386_BUS_SPACE_IO, I386_BUS_SPACE_MEM, -1, 1))
		goto dokbd;
#endif
#if (NEGA > 0)
	if (!ega_cnattach(I386_BUS_SPACE_IO, I386_BUS_SPACE_MEM))
		goto dokbd;
#endif
#if (NPCDISPLAY > 0)
	if (!pcdisplay_cnattach(I386_BUS_SPACE_IO, I386_BUS_SPACE_MEM))
		goto dokbd;
#endif
#if (NPC > 0)
	pccnattach();
#endif
	if (0) goto dokbd;	/* XXX stupid gcc */
dokbd:
#if (NPCKBC > 0)
	pckbc_cnattach(I386_BUS_SPACE_IO, IO_KBD, KBCMDP, PCKBC_KBD_SLOT);
#endif
#endif	/* PC | VGA | EGA | PCDISPLAY */
@


1.147
log
@Support for the wscons machine-independent console driver on the i386. To
become default in a few moments once deraadt commits new kernel config files.

IMPORTANT NOTE: A few important pieces are still required to be worked out
over the next few days. Users (and developers) relying on X should probably
stay away from -current until further notice. This should not take long, but
here is your first heads up. If you decide to upgrade your kernel anyway,
be sure to update your /etc/ttys file to use vt100 instead of vt220. The
rest of the fallout from this should be minor.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.146 2001/01/25 18:49:33 mickey Exp $	*/
d2417 2
a2418 1
#endif	/* PC | VT | VGA | PCDISPLAY */
a2436 1
#endif
@


1.146
log
@constify cpuid tables
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.145 2001/01/25 05:15:24 mickey Exp $	*/
d175 31
a2100 3
	consinit();	/* XXX SHOULD NOT BE DONE HERE */
			/* XXX here, until we can use bios for printfs */

d2152 3
d2393 1
d2395 40
d2436 2
@


1.145
log
@print cpu speed in GHz rounded to 2 digits after point
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.144 2001/01/25 04:39:46 deraadt Exp $	*/
d689 1
a689 1
struct cpu_nocpuid_nameclass i386_nocpuid_cpus[] = {
d720 1
a720 1
struct cpu_cpuid_nameclass i386_cpuid_cpus[] = {
d993 1
a993 1
struct cpu_cpuid_feature i386_cpuid_features[] = {
d1179 1
a1179 1
	struct cpu_cpuid_nameclass *cpup = NULL;
@


1.144
log
@detect Transmeta cpus
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.143 2001/01/24 09:37:58 hugh Exp $	*/
d1289 11
a1299 1
		printf(" %d MHz", pentium_mhz);
@


1.143
log
@KGDB for i386 from NetBSD via niklas, with tweaks and accommodations.
Tested by various, vetted by mickey & theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.142 2001/01/23 21:59:18 deraadt Exp $	*/
d670 1
a670 1
		     size > 0; size -= NBPG, addr += NBPG) {
d700 3
a702 3
	{ CPUVENDOR_CYRIX, "Cyrix", "6x86",		CPUCLASS_486,
		cyrix6x86_cpu_setup},	/* CPU_6x86 */
	{ CPUVENDOR_NEXGEN,"NexGen","586",      CPUCLASS_386,
d890 1
a890 1
		/* Family 4, not yet available from IDT */
d925 1
a925 1
		/* Family 4, not yet available from Rise */
d955 35
d1253 1
a1253 1
			    name = cpup->cpu_family[i].cpu_models[CPU_DEFMODEL];
d1303 1
a1303 1
				       i386_cpuid_features[i].feature_name);
d1738 1
a1738 1
        dump = bdevsw[major(dumpdev)].d_dump;
d2180 1
a2180 1
				       " FROM IOMEM EXTENT MAP!\n", a, e);
d2197 1
a2197 1
		       "running in degraded mode\npress a key to confirm\n\n");
@


1.142
log
@recognize P4; testing by techsupport@@lokmail.net, the unfortunate owner of such a thing
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.141 2001/01/05 04:27:23 marc Exp $	*/
d115 4
d176 12
d289 26
d372 1
a372 1
	
d1600 1
a1600 1
		
d2241 6
a2246 3
	if (boothowto & RB_KDB)
		kgdb_connect(0);
#endif
d2319 15
@


1.141
log
@
Add i386 specific sysctl to modify halt -p processing, required to make
powerdown work correctly on some processors.   Idea from mickey@@ and
smcho@@tsp.korea.ac.kr.   Tested my me and angelos@@.

Note: If you want to try these out you'll need to

  cd /sys/arch/i386/include &&
sudo install -m 444 -o root -g root cpu.h /usr/include/i386
cd /usr/src/sbin/sysctl && make obj && make && sudo make install

to get a sysctl that understands the new variable (machdep.apmhalt).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.140 2000/11/16 19:10:58 millert Exp $	*/
d722 44
d1170 2
a1171 2
			if ((vendor == CPUVENDOR_INTEL) && (family == 6)
				&& ((model == 5) || (model == 7))) {
d1184 1
a1184 1
	if ((vendor == CPUVENDOR_INTEL) && (cpuid_level >= 2)) {
d1186 2
a1187 2
		if ((cpu_cache_edx & 0xFF) >= 0x40
		    && (cpu_cache_edx & 0xFF) <= 0x45) {
a1188 1
		}
@


1.140
log
@Add entries for the AMD K6-2+/III+, newer Athlon/Duron chips, and
the Intel Cascades.  st@@devnull.demon.co.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.139 2000/11/13 15:53:33 aaron Exp $	*/
d197 4
d1537 13
a1549 2
			apm_set_powstate(APM_DEV_DISK(0xff), APM_SYS_OFF);
			delay(500000);
d2330 2
@


1.139
log
@Address the i8042 keyboard controller registers as offsets from IO_KBD; from
NetBSD. This will ease the pain when we bring in the pckbc MI keyboard
driver to be used for wscons/i386 and wscons/alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.138 2000/11/13 13:18:58 niklas Exp $	*/
d709 7
a715 5
				"Pentium II (Deschutes)",
				"Pentium II (Celeron)",
				"Pentium III", "Pentium III (Coppermine)",
				0, 0, 0, 0, 0, 0, 0,
				"Pentium Pro"	/* Default */
d743 2
a744 1
				"K6", "K6-2", "K6-3", 0, 0, 0, 0, 0, 0,
d753 3
a755 2
				0, "K7 (Athlon)", 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0,
@


1.138
log
@Do not use PG_N on "real" 386es as it does not exist there; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.137 2000/10/27 00:16:14 mickey Exp $	*/
d2221 1
a2221 1
	outb(KBCMDP, KBC_PULSE0);
d2223 1
a2223 1
	outb(KBCMDP, KBC_PULSE0);
@


1.137
log
@more precise BUFCACHEPERCENT calculations.
from gluk@@ptci.ru; deraadt@@ and niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.136 2000/08/11 18:38:58 deraadt Exp $	*/
d2519 12
a2530 4
		if (!cacheable)
			pmap_changebit(pa, PG_N, ~0);
		else
			pmap_changebit(pa, 0, ~PG_N);
@


1.136
log
@disable userland TCS access on winchip C6, it is busted; wd@@ics.nara-wu.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.135 2000/07/06 00:59:00 todd Exp $	*/
d493 2
a494 2
			bufpages = (btoc(2 * 1024 * 1024) + physmem) /
			    ((100/BUFCACHEPERCENT) * CLSIZE);
@


1.135
log
@printf %s
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.134 2000/06/16 21:47:11 provos Exp $	*/
d901 3
@


1.134
log
@take MIN/MAX from param.h, okay theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.133 2000/05/24 21:07:51 bjc Exp $	*/
d324 1
a324 1
	printf(version);
@


1.133
log
@Add an extra byte to the end of struct pcb and make sure that it is set to
0xff.  Intel (vol1 section 9.5.2) says that there must be a byte inside the
TSS after the iomap because it always reads two bytes when checking
permissions for io accesses.  before this, bits 1016-1023 were ignored.

This means that the entire pcb_iomap (and i386_*_ioperm) are accurate;
pr#1190 fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.132 2000/05/15 06:14:25 niklas Exp $	*/
a171 2

#define	MIN(a,b) (((a)<(b))?(a):(b))
@


1.132
log
@comment typo
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.131 2000/04/24 18:56:56 niklas Exp $	*/
d432 1
@


1.131
log
@3 bugs: off by one in dump offset calculation,
 when to print what is left, and what to print.  Fixes PR#1182
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.130 2000/04/11 02:44:27 pjanzen Exp $	*/
d591 1
a591 1
		 * for the buffer * cache as it is nice to not need to
@


1.130
log
@Check usec for >= 1000000, not just > ; as msaitoh@@NetBSD.org
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.129 2000/04/08 05:50:50 aaron Exp $	*/
d1581 4
a1584 4
	if (dumpsize > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo);
	if (dumplo < nblks - ctod(dumpsize))
		dumplo = nblks - ctod(dumpsize);
d1680 3
a1682 3
			if (!(dbtob(blkno - dumplo) % (1024*1024)))
				printf("%d ", (dumpsize - maddr) /
					      btoc(1024*1024));
d1687 1
a1687 1
				   VM_PROT_READ, TRUE, 0);
d1689 1
a1689 1
					     (caddr_t)dumpspace, NBPG)))
@


1.129
log
@Initial check-in for support of 32-bit CardBus PC Cards; from NetBSD. On many
machines, this code needs the new PCIBIOS* options enabled in the kernel config
file to work, but your mileage may vary. Included is a working 3c575 driver for
3Com 10/100 CardBus PC Card NICs (tested only with the 'C' revision). The 3c575
is the pccard version of the PCI EtherLink XL cards, and thus the xl driver has
been split into /sys/dev/ic.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.128 2000/03/23 09:59:54 art Exp $	*/
d1732 1
a1732 1
	while (tvp->tv_usec > 1000000) {
@


1.128
log
@New API for timeouts. Replaces the old timeout()/untimeout() API and
makes it the callers responsibility to allocate resources for the
timeouts.

This is a KISS implementation and does _not_ solve the problems of slow
handling of a large number of pending timeouts (this will be solved in
future work) (although hardclock is now guarateed to take constant time
for handling of timeouts).

Old timeout() and untimeout() are implemented as wrappers around the new
API and kept for compatibility. They will be removed as soon as all
subsystems are converted to use the new API.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.127 2000/03/16 22:11:03 art Exp $	*/
d2387 23
@


1.127
log
@Bring in some new UVM code from NetBSD (not current).

 - Introduce a new type of map that are interrupt safe and never allow faults
   in them. mb_map and kmem_map are made intrsafe.
 - Add "access protection" to uvm_vslock (to be passed down to uvm_fault and
   later to pmap_enter).
 - madvise(2) now works.
 - various cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.126 2000/03/02 00:15:00 niklas Exp $	*/
d93 1
a93 1
#include <sys/callout.h>
d391 1
a391 1
	 * Initialize callouts
d393 1
a393 3
	callfree = callout;
	for (i = 1; i < ncallout; i++)
		callout[i-1].c_next = &callout[i];
d464 1
a464 1
	valloc(callout, struct callout, ncallout);
@


1.126
log
@Several people noted that non-UVM was broken
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.125 2000/02/22 19:27:48 deraadt Exp $	*/
d358 1
a358 1
				   16*NCARGS, TRUE, FALSE, NULL);
d369 1
a369 1
				   VM_PHYS_SIZE, TRUE, FALSE, NULL);
d384 1
a384 1
	    VM_MBUF_SIZE, FALSE, FALSE, NULL);
@


1.125
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124 2000/02/08 00:14:12 niklas Exp $	*/
d2066 4
a2069 1
		register int32_t a, e, lim;
@


1.124
log
@Split low ISA memory (<16MB) into its own freelist, which is used last by
the VM subsystem.  This makes isadmaattach panics go away on large memory
systems.  Also use atop instead of btoc for consistency when dealing
with the initial chunks of physical memory to give to UVM.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.123 2000/02/03 15:32:23 niklas Exp $	*/
a228 3
struct	msgbuf *msgbufp;
int	msgbufmapped;

d319 1
a319 1
	for (i = 0; i < btoc(sizeof(struct msgbuf)); i++, pa += NBPG)
d324 1
a324 2

	msgbufmapped = 1;
d330 1
a330 1
	printf("real mem  = %d\n", ctob(physmem));
d398 2
a399 1
	printf("avail mem = %ld\n", ptoa(uvmexp.free));
d401 2
a402 1
	printf("avail mem = %ld\n", ptoa(cnt.v_free_count));
d404 2
a405 2
	printf("using %d buffers containing %d bytes of memory\n",
		nbuf, bufpages * CLBYTES);
d1637 1
d2051 1
a2051 1
	avail_end -= i386_round_page(sizeof(struct msgbuf));
@


1.124.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d229 3
d322 1
a322 1
	for (i = 0; i < btoc(MSGBUFSIZE); i++, pa += NBPG)
d327 2
a328 1
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));
d334 1
a334 1
	printf("real mem  = %u (%uK)\n", ctob(physmem), ctob(physmem)/1024);
d402 1
a402 2
	printf("avail mem = %lu (%uK)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free)/1024);
d404 1
a404 2
	printf("avail mem = %lu (%uK)\n", ptoa(cnt.v_free_count),
	    ptoa(cnt.v_free_count)/1024);
d406 2
a407 2
	printf("using %d buffers containing %u bytes (%uK) of memory\n",
		nbuf, bufpages * CLBYTES, bufpages * CLBYTES / 1024);
a1638 1
	extern int msgbufmapped;
d2052 1
a2052 1
	avail_end -= i386_round_page(MSGBUFSIZE);
@


1.124.2.2
log
@Sync with -current
@
text
@d93 1
a93 1
#include <sys/timeout.h>
d358 1
a358 1
				   16*NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);
d369 1
a369 1
				   VM_PHYS_SIZE, 0, FALSE, NULL);
d384 1
a384 1
	    VM_MBUF_SIZE, VM_MAP_INTRSAFE, FALSE, NULL);
d391 1
a391 1
	 * Initialize timeouts
d393 3
a395 1
	timeout_init();
d466 1
a466 1
	valloc(timeouts, struct timeout, ntimeout);
d2066 1
a2066 4
		int32_t a, e;
#ifdef UVM
		int32_t lim;
#endif
@


1.124.2.3
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.155 2001/04/09 07:14:15 tholo Exp $	*/
a114 4
#ifdef KGDB
#include <sys/kgdb.h>
#endif

a170 5
#include "pc.h"
#if (NPC > 0)
#include <machine/pccons.h>
#endif

a171 2
#include "com.h"
#include "pccom.h"
d173 1
a173 9
#if (NCOM > 0 || NPCCOM > 0)
#include <sys/termios.h>
#include <dev/ic/comreg.h>
#if NCOM > 0
#include <dev/ic/comvar.h>
#elif NPCCOM > 0
#include <arch/i386/isa/pccomvar.h>
#endif
#endif /* NCOM > 0 || NPCCOM > 0 */
a198 4
#if NAPM > 0
int	cpu_apmhalt = 0;	/* sysctl'd to 1 for halt -p hack */
#endif

a227 3
int	i386_fpu_present;
int	i386_fpu_exception;
int	i386_fpu_fdivbug;
d254 2
a255 2
static	long ioport_ex_storage[EXTENT_FIXED_STORAGE_SIZE(16) / sizeof(long)];
static	long iomem_ex_storage[EXTENT_FIXED_STORAGE_SIZE(16) / sizeof(long)];
a270 26
#ifdef KGDB
#ifndef KGDB_DEVNAME
#ifdef __i386__
#define KGDB_DEVNAME "pccom"
#else
#define KGDB_DEVNAME "com"
#endif
#endif /* KGDB_DEVNAME */
char kgdb_devname[] = KGDB_DEVNAME;
#if (NCOM > 0 || NPCCOM > 0)
#ifndef KGDBADDR
#define KGDBADDR 0x3f8
#endif
int comkgdbaddr = KGDBADDR;
#ifndef KGDBRATE
#define KGDBRATE TTYDEF_SPEED
#endif
int comkgdbrate = KGDBRATE;
#ifndef KGDBMODE
#define KGDBMODE ((TTYDEF_CFLAG & ~(CSIZE | CSTOPB | PARENB)) | CS8) /* 8N1 */
#endif
int comkgdbmode = KGDBMODE;
#endif /* NCOM  || NPCCOM */
void kgdb_port_init __P((void));
#endif /* KGDB */

a279 1
void	cyrix3_cpu_setup __P((const char *, int, int));
d326 1
a326 1
	printf("%s", version);
d328 1
a328 1

a431 1
	pcb->pcb_iomap_pad = 0xff;
d494 2
a495 2
			bufpages = (btoc(2 * 1024 * 1024) + physmem) *
			    BUFCACHEPERCENT / (100 * CLSIZE);
d591 1
a591 1
		 * for the buffer cache as it is nice to not need to
d625 1
a625 1
		    size > 0; size -= NBPG, addr += NBPG) {
d644 1
a644 1
const struct cpu_nocpuid_nameclass i386_nocpuid_cpus[] = {
d655 3
a657 3
	{ CPUVENDOR_CYRIX, "Cyrix", "6x86",	CPUCLASS_486,
		cyrix6x86_cpu_setup},		/* CPU_6x86 */
	{ CPUVENDOR_NEXGEN,"NexGen","586",	CPUCLASS_386,
d675 1
a675 1
const struct cpu_cpuid_nameclass i386_cpuid_cpus[] = {
d710 5
a714 51
				"Pentium II/Celeron (Deschutes)",
				"Celeron (Mendocino)",
				"Pentium III (Katmai)",
				"Pentium III (Coppermine)",
				0, "Pentium III Xeon (Cascades)", 0, 0, 0,
				0, 0,
				"Pentium Pro, II or III"	/* Default */
			},
			intel686_cpu_setup
		},
		/* Family 7 */
		{
			CPUCLASS_686,
		} ,
		/* Family 8 */
		{
			CPUCLASS_686,
		} ,
		/* Family 9 */
		{
			CPUCLASS_686,
		} ,
		/* Family A */
		{
			CPUCLASS_686,
		} ,
		/* Family B */
		{
			CPUCLASS_686,
		} ,
		/* Family C */
		{
			CPUCLASS_686,
		} ,
		/* Family D */
		{
			CPUCLASS_686,
		} ,
		/* Family E */
		{
			CPUCLASS_686,
		} ,
		/* Family F */
		{
			CPUCLASS_686,
			{
				"Pentium 4", 0, 0, 0,
				0, 0, 0, 0,
				0, 0, 0, 0,
				0, 0, 0, 0,
				"Pentium 4"	/* Default */
d742 1
a742 2
				"K6", "K6-2", "K6-III", 0, 0, 0,
				"K6-2+/III+", 0, 0,
d751 2
a752 3
				0, "Athlon Model 1", "Athlon Model 2",
				"Duron", "Athlon Model 4 (Thunderbird)",
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
d797 1
a797 1
		/* Family 4, not available from IDT */
d817 1
a817 1
		/* Family 6 */
a820 1
				0, 0, 0, 0, 0, 0, "VIA Cyrix III", 0,
d822 2
a823 1
				"VIA Cyrix III"		/* Default */
d825 1
a825 1
			cyrix3_cpu_setup
d832 1
a832 1
		/* Family 4, not available from Rise */
a861 35
	},
	{
		"GenuineTMx86",
		CPUVENDOR_TRANSMETA,
		"Transmeta",
		/* Family 4, not available from Transmeta */
		{ {
			CPUCLASS_486, 
			{
				0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
				"486 class"		/* Default */
			},
			NULL
		},
		/* Family 5 */
		{
			CPUCLASS_586,
			{
				0, 0, 0, "TMS5400", "TMS5600", 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
				"TMS5x00"		/* Default */
			},
			NULL
		},
		/* Family 6, not yet available from Rise */
		{
			CPUCLASS_686,
			{
				0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
				"686 class"		/* Default */
			},
			NULL
		} }
d865 1
a865 1
const struct cpu_cpuid_feature i386_cpuid_features[] = {
a901 3
		/* Disable RDTSC instruction from user-level. */
		lcr4(rcr4() | CR4_TSD);

a908 23
cyrix3_cpu_setup(cpu_device, model, step)
	const char *cpu_device;
	int model, step;
{
#if defined(I686_CPU)
	extern int cpu_feature;
	unsigned int val;

	switch (model) {
	case 6: /* VIA Cyrix III */
		__asm __volatile("cpuid"
		    : "=d" (val) : "a" (0x80000001) : "ebx", "ecx");
		if (val & (1U << 31)) {
			cpu_feature |= CPUID_3DNOW;
		} else {
			cpu_feature &= ~CPUID_3DNOW;
		}
		break;
	}
#endif
}

void
d1048 1
a1048 1
	const struct cpu_cpuid_nameclass *cpup = NULL;
d1116 2
a1117 2
			if (vendor == CPUVENDOR_INTEL && family == 6 &&
			    (model == 5 || model == 7)) {
d1122 1
a1122 1
				name = cpup->cpu_family[i].cpu_models[CPU_DEFMODEL];
d1130 1
a1130 1
	if (vendor == CPUVENDOR_INTEL && cpuid_level >= 2 && family < 0xf) {
d1132 2
a1133 2
		if ((cpu_cache_edx & 0xFF) >= 0x40 &&
		    (cpu_cache_edx & 0xFF) <= 0x45)
d1135 1
d1159 1
a1159 11
		if (pentium_mhz > 994) {
			int ghz, fr;

			ghz = (pentium_mhz + 9) / 1000;
			fr = ((pentium_mhz + 9) / 10 ) % 100;
			if (fr)
				printf(" %d.%02d GHz", ghz, fr);
			else
				printf(" %d GHz", ghz);
		} else
			printf(" %d MHz", pentium_mhz);
d1173 1
a1173 1
				    i386_cpuid_features[i].feature_name);
d1505 1
a1505 1

d1527 2
a1528 13
			/*
			 * It's been reported that the following bit of code
			 * is required on most systems <mickey@@openbsd.org>
			 * but cause powerdown problem on other systems
			 * <smcho@@tsp.korea.ac.kr>.  Use sysctl to set
			 * apmhalt to a non-zero value to skip the offending
			 * code.
			 */
			if (!cpu_apmhalt) {
				apm_set_powstate(APM_DEV_DISK(0xff),
						 APM_SYS_OFF);
				delay(500000);
			}
d1581 4
a1584 4
	if (dumpsize > dtoc(nblks - dumplo - 1))
		dumpsize = dtoc(nblks - dumplo - 1);
	if (dumplo < nblks - ctod(dumpsize) - 1)
		dumplo = nblks - ctod(dumpsize) - 1;
d1597 1
a1597 1
	dump = bdevsw[major(dumpdev)].d_dump;
d1680 3
a1682 3
			if (dbtob(blkno - dumplo) % (1024 * 1024) < NBPG)
				printf("%d ",
				    (ctob(dumpsize) - maddr) / (1024 * 1024));
d1687 1
a1687 1
			    VM_PROT_READ, TRUE, 0);
d1689 1
a1689 1
			    (caddr_t)dumpspace, NBPG)))
d1732 1
a1732 1
	while (tvp->tv_usec >= 1000000) {
a1849 1
#ifndef PMAP_NEW
a1850 1
#endif
a1878 3
#ifdef PMAP_NEW
	pte = PTE_BASE + i386_btop(va);
#else
a1879 1
#endif
a1899 1
	curpcb = &proc0.p_addr->u_pcb;
d1919 3
a1972 3
	consinit();	/* XXX SHOULD NOT BE DONE HERE */
			/* XXX here, until we can use bios for printfs */

d2039 1
a2039 1
				    " FROM IOMEM EXTENT MAP!\n", a, e);
d2056 1
a2056 1
		    "running in degraded mode\npress a key to confirm\n\n");
d2135 3
a2137 6
	kgdb_port_init();
	if (boothowto & RB_KDB) {
		kgdb_debug_init = 1;
		kgdb_connect(1);
	}
#endif /* KGDB */
a2210 33
#if (NPCKBC > 0) && (NPCKBD == 0)
/*
 * glue code to support old console code with the
 * mi keyboard controller driver
 */
int
pckbc_machdep_cnattach(kbctag, kbcslot)
	pckbc_tag_t kbctag;
	pckbc_slot_t kbcslot;
{
#if (NPC > 0) && (NPCCONSKBD > 0)
	return (pcconskbd_cnattach(kbctag, kbcslot));
#else
	return (ENXIO);
#endif
}
#endif

#ifdef KGDB
void
kgdb_port_init()
{

#if (NCOM > 0 || NPCCOM > 0)
	if (!strcmp(kgdb_devname, "com") || !strcmp(kgdb_devname, "pccom")) {
		bus_space_tag_t tag = I386_BUS_SPACE_IO;
		com_kgdb_attach(tag, comkgdbaddr, comkgdbrate, COM_FREQ,
		    comkgdbmode);
	}
#endif
}
#endif /* KGDB */

d2219 1
a2219 1
	outb(IO_KBD + KBCMDP, KBC_PULSE0);
d2221 1
a2221 1
	outb(IO_KBD + KBCMDP, KBC_PULSE0);
a2232 1
#if 1
a2238 1
#endif
a2308 2
	case CPU_APMHALT:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &cpu_apmhalt));
a2389 23
_bus_space_map(t, bpa, size, cacheable, bshp)
	bus_space_tag_t t;
	bus_addr_t bpa;
	bus_size_t size;
	int cacheable;
	bus_space_handle_t *bshp;
{
	/*
	 * For I/O space, that's all she wrote.
	 */
	if (t == I386_BUS_SPACE_IO) {
		*bshp = bpa;
		return (0);
	}

	/*
	 * For memory space, map the bus physical address to
	 * a kernel virtual address.
	 */
	return (bus_mem_add_mapping(bpa, size, cacheable, bshp));
}

int
a2470 3
#ifdef PMAP_NEW
	pt_entry_t *pte;
#endif
d2494 4
a2497 21

		/*
		 * PG_N doesn't exist on 386's, so we assume that
		 * the mainboard has wired up device space non-cacheable
		 * on those machines.
		 */
		if (cpu_class != CPUCLASS_386) {
#ifdef PMAP_NEW
			pte = kvtopte(va);
			if (cacheable)
				*pte &= ~PG_N;
			else
				*pte |= PG_N;
			pmap_update_pg(va);
#else
			if (!cacheable)
				pmap_changebit(pa, PG_N, ~0);
			else
				pmap_changebit(pa, 0, ~PG_N);
#endif
		}
d2659 1
a2659 1
	vaddr_t vaddr = (vaddr_t)buf;
@


1.124.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.3 2001/04/18 16:07:20 niklas Exp $	*/
d126 1
d128 1
d201 1
d203 1
a203 1
    uvm_pglistalloc((sz), 0, (limit), PAGE_SIZE, 0, &(pgs), 1, 0)
d205 5
d258 1
d262 3
a295 2
int	_bus_dmamap_load_buffer __P((bus_dma_tag_t, bus_dmamap_t, void *,
    bus_size_t, struct proc *, int, paddr_t *, int *, int));
d364 2
d390 1
d392 3
d409 1
d412 4
d420 1
d423 4
d428 8
d438 4
d448 1
d451 4
d456 1
a456 1
		nbuf, bufpages * PAGE_SIZE, bufpages * PAGE_SIZE / 1024);
d474 1
a474 1
}
d476 3
a478 10
/*
 * Set up proc0's TSS and LDT.
 */
void
i386_proc0_tss_ldt_init()
{
	struct pcb *pcb;
	int x;

	gdt_init();
d487 1
a487 1
	pcb->pcb_ldt_sel = pmap_kernel()->pm_ldt_sel = GSEL(GLDT_SEL, SEL_KPL);
d546 1
a546 1
			bufpages = physmem / 10;
d549 1
a549 1
			    BUFCACHEPERCENT / 100;
d564 2
a565 2
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;
d572 3
d590 1
d597 8
d608 1
a608 1
	if (base >= MAXBSIZE / PAGE_SIZE) {
d610 1
a610 1
		base = MAXBSIZE / PAGE_SIZE;
d649 2
a650 2
			chunk = min(left, CHUNKSZ / PAGE_SIZE);
			if (ALLOC_PGS(chunk * PAGE_SIZE, ISADMA_LIMIT, pgs))
d658 1
a658 1
	if (left > 0 && ALLOC_PGS(left * PAGE_SIZE, avail_end, pgs))
d678 1
a678 1
		for (size = PAGE_SIZE * (i < residual ? base + 1 : base);
d768 1
a768 2
				0, "Pentium III Xeon (Cascades)",
				"Pentium III (Tualatin)", 0, 0,
d1642 2
d1734 1
a1734 1
 * Dumps always skip the first block of disk space
d1756 1
a1756 1
	/* Always skip the first block, in case there is a label there. */
d2033 3
d2048 1
d2050 3
d2064 1
d2066 3
d2255 1
d2257 1
d2267 1
d2289 3
d2724 1
d2726 1
d2736 1
d2738 3
d2746 4
a2749 2
	for (; pa < endpa; pa += PAGE_SIZE, va += PAGE_SIZE) {
		pmap_kenter_pa(va, pa, VM_PROT_READ | VM_PROT_WRITE);
d2757 1
d2764 6
d2772 1
a2772 2
	pmap_update();

d2789 2
a2790 1
	if (t == I386_BUS_SPACE_IO) {
d2793 3
a2795 1
	} else if (t == I386_BUS_SPACE_MEM) {
d2799 1
a2799 1
			goto ok;
d2809 1
a2809 2
		(void) pmap_extract(pmap_kernel(), va, &bpa);
		bpa += (bsh & PGOFSET);
d2814 1
d2816 6
a2821 1
	} else
d2823 1
a2824 1
ok:
d2898 1
a2898 2
	map->dm_mapsize = 0;		/* no valid mappings */
	map->dm_nsegs = 0;
d2930 5
a2934 2
	bus_addr_t lastaddr;
	int seg, error;
a2938 1
	map->dm_mapsize = 0;
d2944 57
a3000 6
	seg = 0;
	error = _bus_dmamap_load_buffer(t, map, buf, buflen, p, flags,
	    &lastaddr, &seg, 1);
	if (error == 0) {
		map->dm_mapsize = buflen;
		map->dm_nsegs = seg + 1;
d3002 9
a3010 1
	return (error);
d3017 1
a3017 1
_bus_dmamap_load_mbuf(t, map, m0, flags)
d3020 1
a3020 1
	struct mbuf *m0;
a3022 9
	paddr_t lastaddr;
	int seg, error, first;
	struct mbuf *m;

	/*
	 * Make sure that on error condition we return "no valid mappings".
	 */
	map->dm_mapsize = 0;
	map->dm_nsegs = 0;
d3024 1
a3024 21
#ifdef DIAGNOSTIC
	if ((m0->m_flags & M_PKTHDR) == 0)
		panic("_bus_dmamap_load_mbuf: no packet header");
#endif

	if (m0->m_pkthdr.len > map->_dm_size)
		return (EINVAL);

	first = 1;
	seg = 0;
	error = 0;
	for (m = m0; m != NULL && error == 0; m = m->m_next) {
		error = _bus_dmamap_load_buffer(t, map, m->m_data, m->m_len,
		    NULL, flags, &lastaddr, &seg, first);
		first = 0;
	}
	if (error == 0) {
		map->dm_mapsize = m0->m_pkthdr.len;
		map->dm_nsegs = seg + 1;
	}
	return (error);
a3036 23
	paddr_t lastaddr;
	int seg, i, error, first;
	bus_size_t minlen, resid;
	struct proc *p = NULL;
	struct iovec *iov;
	caddr_t addr;

	/*
	 * Make sure that on error condition we return "no valid mappings".
	 */
	map->dm_mapsize = 0;
	map->dm_nsegs = 0;

	resid = uio->uio_resid;
	iov = uio->uio_iov;

	if (uio->uio_segflg == UIO_USERSPACE) {
		p = uio->uio_procp;
#ifdef DIAGNOSTIC
		if (p == NULL)
			panic("_bus_dmamap_load_uio: USERSPACE but no proc");
#endif
	}
d3038 1
a3038 22
	first = 1;
	seg = 0;
	error = 0;
	for (i = 0; i < uio->uio_iovcnt && resid != 0 && error == 0; i++) {
		/*
		 * Now at the first iovec to load.  Load each iovec
		 * until we have exhausted the residual count.
		 */
		minlen = resid < iov[i].iov_len ? resid : iov[i].iov_len;
		addr = (caddr_t)iov[i].iov_base;

		error = _bus_dmamap_load_buffer(t, map, addr, minlen,
		    p, flags, &lastaddr, &seg, first);
		first = 0;

		resid -= minlen;
	}
	if (error == 0) {
		map->dm_mapsize = uio->uio_resid;
		map->dm_nsegs = seg + 1;
	}
	return (error);
a3071 1
	map->dm_mapsize = 0;
d3135 1
d3137 3
d3160 5
a3164 1
	va = uvm_km_valloc(kernel_map, size);
d3173 1
a3173 1
		    addr += PAGE_SIZE, va += PAGE_SIZE, size -= PAGE_SIZE) {
a3180 1
	pmap_update();
d3202 5
a3206 1
	uvm_km_free(kernel_map, (vm_offset_t)kva, size);
a3245 93
/*
 * Utility function to load a linear buffer.  lastaddrp holds state
 * between invocations (for multiple-buffer loads).  segp contains
 * the starting segment on entrace, and the ending segment on exit.
 * first indicates if this is the first invocation of this function.
 */
int
_bus_dmamap_load_buffer(t, map, buf, buflen, p, flags, lastaddrp, segp, first)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	void *buf;
	bus_size_t buflen;
	struct proc *p;
	int flags;
	paddr_t *lastaddrp;
	int *segp;
	int first;
{
	bus_size_t sgsize;
	bus_addr_t curaddr, lastaddr, baddr, bmask;
	vaddr_t vaddr = (vaddr_t)buf;
	int seg;
	pmap_t pmap;

	if (p != NULL)
		pmap = p->p_vmspace->vm_map.pmap;
	else
		pmap = pmap_kernel();

	lastaddr = *lastaddrp;
	bmask  = ~(map->_dm_boundary - 1);

	for (seg = *segp; buflen > 0 ; ) {
		/*
		 * Get the physical address for this segment.
		 */
		pmap_extract(pmap, (vm_offset_t)vaddr, (paddr_t *)&curaddr);

		/*
		 * Compute the segment size, and adjust counts.
		 */
		sgsize = PAGE_SIZE - ((u_long)vaddr & PGOFSET);
		if (buflen < sgsize)
			sgsize = buflen;

		/*
		 * Make sure we don't cross any boundaries.
		 */
		if (map->_dm_boundary > 0) {
			baddr = (curaddr + map->_dm_boundary) & bmask;
			if (sgsize > (baddr - curaddr))
				sgsize = (baddr - curaddr);
		}

		/*
		 * Insert chunk into a segment, coalescing with
		 * previous segment if possible.
		 */
		if (first) {
			map->dm_segs[seg].ds_addr = curaddr;
			map->dm_segs[seg].ds_len = sgsize;
			first = 0;
		} else {
			if (curaddr == lastaddr &&
			    (map->dm_segs[seg].ds_len + sgsize) <=
			     map->_dm_maxsegsz &&
			    (map->_dm_boundary == 0 ||
			     (map->dm_segs[seg].ds_addr & bmask) ==
			     (curaddr & bmask)))
				map->dm_segs[seg].ds_len += sgsize;
			else {
				if (++seg >= map->_dm_segcnt)
					break;
				map->dm_segs[seg].ds_addr = curaddr;
				map->dm_segs[seg].ds_len = sgsize;
			}
		}

		lastaddr = curaddr + sgsize;
		vaddr += sgsize;
		buflen -= sgsize;
	}

	*segp = seg;
	*lastaddrp = lastaddr;

	/*
	 * Did we fit?
	 */
	if (buflen != 0)
		return (EFBIG);		/* XXX better return value here? */
	return (0);
}
d3275 1
d3278 4
@


1.124.2.5
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.4 2001/07/04 10:16:36 niklas Exp $	*/
a134 1
#include <machine/cpuvar.h>
a255 4
void (*delay_func) __P((int)) = i8254_delay;
void (*microtime_func) __P((struct timeval *)) = i8254_microtime;
void (*initclock_func) __P((void)) = i8254_initclocks;

d278 1
d370 1
a370 2
	/* XXX MULTIPROCESSOR identifycpu(); */

d440 1
d443 1
a443 17
	pcb = &proc0.p_addr->u_pcb;
	pcb->pcb_tss.tss_ss0 = GSEL(GDATA_SEL, SEL_KPL);
	pcb->pcb_tss.tss_esp0 = (int)proc0.p_addr + USPACE - 16;

	i386_init_pcb_tss_ldt(pcb);

	ltr(pcb->pcb_tss_sel);
	lldt(pcb->pcb_ldt_sel);

	proc0.p_md.md_regs = (struct trapframe *)pcb->pcb_tss.tss_esp0 - 1;
}

void
i386_init_pcb_tss_ldt(struct pcb *pcb)
{
	int x;

d453 2
a455 1
}  
d457 5
d987 3
a989 1
  	switch ((curcpu()->ci_signature >> 4) & 15) { /* model */
d991 1
a991 1
		curcpu()->ci_feature_flags &= ~CPUID_TSC;
d994 2
a995 1
		printf("%s: broken TSC disabled\n", curcpu()->ci_dev.dv_xname);
d1030 3
a1032 1
  	switch ((curcpu()->ci_signature >> 4) & 15) { /* model */
d1048 1
a1048 2
		printf("%s: xchg bug workaround performed\n", 
		       curcpu()->ci_dev.dv_xname);
d1052 1
a1052 1
		curcpu()->ci_feature_flags &= ~CPUID_TSC;
d1065 1
a1065 2
	printf("%s: F00F bug workaround installed\n", 
	       curcpu()->ci_dev.dv_xname);
d1074 1
a1074 3
        struct cpu_info *ci = curcpu();
  	/* SMP int model = (curcpu()->ci_signature >> 4) & 15; */
	/* SMP int step = curcpu()->ci_signature & 15; */
d1090 1
a1090 1
		ci->ci_feature_flags &= ~CPUID_SYS2;
d1095 1
a1095 1
	if ((model == 7) && (ci->ci_feature_flags & CPUID_SER)) {
d1100 3
a1102 4
		printf("%s: disabling processor serial number\n", 
		       ci->ci_dev.dv_xname);
		ci->ci_feature_flags &= ~CPUID_SER;
		ci->ci_level = 2;
a1148 15
/*
 * Print identification for the given CPU.
 * XXX XXX
 * This is not as clean as one might like, because it references
 *
 * the "cpuid_level" and "cpu_vendor" globals.
 * cpuid_level isn't so bad, since both CPU's will hopefully
 * be of the same level.
 *
 * The Intel multiprocessor spec doesn't give us the cpu_vendor
 * information; however, the chance of multi-vendor SMP actually
 * ever *working* is sufficiently low that it's probably safe to assume
 * all processors are of the same vendor.
 */
 
d1150 1
a1150 1
identifycpu(struct cpu_info *ci)
d1153 2
d1161 1
d1165 1
a1165 3

	char *cpu_device = ci->ci_dev.dv_xname;
	/* XXX SMP XXX void (*cpu_setup) __P((const char *, int, int)); */
d1179 1
a1179 1
		ci->cpu_setup = i386_nocpuid_cpus[cpu].cpu_setup;
d1184 2
a1185 2
		modif = (ci->ci_signature >> 12) & 3;
		family = (ci->ci_signature >> 8) & 15;
d1188 2
a1189 2
		model = (ci->ci_signature >> 4) & 15;
		step = ci->ci_signature & 15;
d1218 1
a1218 1
			ci->cpu_setup = NULL;
d1240 1
a1240 1
			ci->cpu_setup = cpup->cpu_family[i].cpu_setup;
d1265 4
d1272 1
a1272 2
	if (ci->ci_feature_flags && (ci->ci_feature_flags & CPUID_TSC)) {
		/* Has TSC */
d1289 1
a1289 1
	if (ci->ci_feature_flags) {
d1296 1
a1296 2
			if (ci->ci_feature_flags & 
			    i386_cpuid_features[i].feature_bit) {
a1305 1
	ci->cpu_class = class;
d1363 7
d1886 1
d1888 3
a1890 1
	npxdrop(p);
a1944 14
unsetgate(gd)
	struct gate_descriptor *gd;
{
	gd->gd_p = 0;
	gd->gd_hioffset = 0;
	gd->gd_looffset = 0;
	gd->gd_selector = 0;
	gd->gd_xx = 0;
	gd->gd_stkcpy = 0;
	gd->gd_type = 0;
	gd->gd_dpl = 0;
}

void
a2020 8
cpu_init_idt()
{
	struct region_descriptor region;
	setregion(&region, idt, NIDT * sizeof(idt[0]) - 1);
	lidt(&region);
}

void
a2128 7
#if defined(MULTIPROCESSOR)
	/* install page 2 as PT page for first 4M */
	pmap_enter(pmap_kernel(), (u_long)vtopte(0), 2*NBPG,
	   VM_PROT_READ|VM_PROT_WRITE, TRUE, VM_PROT_READ|VM_PROT_WRITE);
	memset(vtopte(0), 0, NBPG);  /* make sure it is clean before using */
#endif

a2337 3
#include <dev/ic/mc146818reg.h>                /* for NVRAM POST */
#include <i386/isa/nvram.h>            /* for NVRAM POST */

a2377 4
	/* Ensure the NVRAM reset byte contains something vaguely sane. */
	outb(IO_RTC, NVRAM_RESET);
	outb(IO_RTC+1, NVRAM_RESET_RST);

d2400 1
a2402 44
#endif
}

void
cpu_initclocks()
{
	(*initclock_func)();
}

#ifdef MULTIPROCESSOR
void
need_resched()
{
	struct cpu_info *ci = curcpu();
	ci->ci_want_resched = 1;
	ci->ci_astpending = 1;
}
#endif

/* Allocate an IDT vector slot within the given range.
 * XXX needs locking to avoid MP allocation races.
 */

int
idt_vec_alloc (int low, int high)
{
	int vec;

	for (vec = low; vec <= high; vec++)
		if (idt[vec].gd_p == 0)
			return vec;
	return 0;
}

void
idt_vec_set (int vec, void (*function) __P((void)))
{
	setgate (&idt[vec], function, 0, SDT_SYS386IGT, SEL_KPL, GCODE_SEL);
}

void
idt_vec_free (int vec)
{
	unsetgate(&idt[vec]);
d2420 1
d2467 1
a2467 1
		return (sysctl_rdint(oldp, oldlenp, newp, curcpu()->ci_feature_flags));
@


1.124.2.6
log
@KNF
We must identify the boot cpu before TLB flushing can work correctly.
This is an interim solution until we make the identifycpu function DTRT.
Setup the initial IDT gates in a way we can track descriptors free and
in use.
Do not overwrite boot arguments with the PTP for first 4MB.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a327 1
void	old_identifycpu __P((void));
d374 2
a375 2
	/* XXX Merge with identifycpu */
	old_identifycpu();
a1391 223
void
old_identifycpu()
{
	extern char cpu_vendor[];
	extern int cpu_id;
	extern int cpu_feature;
#ifdef CPUDEBUG
	extern int cpu_cache_eax, cpu_cache_ebx, cpu_cache_ecx, cpu_cache_edx;
#else
	extern int cpu_cache_edx;
#endif
	const char *name, *modifier, *vendorname, *token;
	const char *cpu_device = "cpu0";
	int class = CPUCLASS_386, vendor, i, max;
	int family, model, step, modif, cachesize;
	const struct cpu_cpuid_nameclass *cpup = NULL;
	void (*cpu_setup) __P((const char *, int, int));

	if (cpuid_level == -1) {
#ifdef DIAGNOSTIC
		if (cpu < 0 || cpu >=
		    (sizeof i386_nocpuid_cpus/sizeof(struct cpu_nocpuid_nameclass)))
			panic("unknown cpu type %d", cpu);
#endif
		name = i386_nocpuid_cpus[cpu].cpu_name;
		vendor = i386_nocpuid_cpus[cpu].cpu_vendor;
		vendorname = i386_nocpuid_cpus[cpu].cpu_vendorname;
		model = -1;
		step = -1;
		class = i386_nocpuid_cpus[cpu].cpu_class;
		cpu_setup = i386_nocpuid_cpus[cpu].cpu_setup;
		modifier = "";
		token = "";
	} else {
		max = sizeof (i386_cpuid_cpus) / sizeof (i386_cpuid_cpus[0]);
		modif = (cpu_id >> 12) & 3;
		family = (cpu_id >> 8) & 15;
		if (family < CPU_MINFAMILY)
			panic("identifycpu: strange family value");
		model = (cpu_id >> 4) & 15;
		step = cpu_id & 15;
#ifdef CPUDEBUG
		printf("%s: family %x model %x step %x\n", cpu_device, family,
			model, step);
		printf("%s: cpuid level %d cache eax %x ebx %x ecx %x edx %x\n",
			cpu_device, cpuid_level, cpu_cache_eax, cpu_cache_ebx,
			cpu_cache_ecx, cpu_cache_edx);
#endif

		for (i = 0; i < max; i++) {
			if (!strncmp(cpu_vendor,
			    i386_cpuid_cpus[i].cpu_id, 12)) {
				cpup = &i386_cpuid_cpus[i];
				break;
			}
		}

		if (cpup == NULL) {
			vendor = CPUVENDOR_UNKNOWN;
			if (cpu_vendor[0] != '\0')
				vendorname = &cpu_vendor[0];
			else
				vendorname = "Unknown";
			if (family > CPU_MAXFAMILY)
				family = CPU_MAXFAMILY;
			class = family - 3;
			modifier = "";
			name = "";
			token = "";
			cpu_setup = NULL;
		} else {
			token = cpup->cpu_id;
			vendor = cpup->cpu_vendor;
			vendorname = cpup->cpu_vendorname;
			modifier = modifiers[modif];
			if (family > CPU_MAXFAMILY) {
				family = CPU_MAXFAMILY;
				model = CPU_DEFMODEL;
			} else if (model > CPU_MAXMODEL)
				model = CPU_DEFMODEL;
			i = family - CPU_MINFAMILY;

			/* Special hack for the PentiumII/III series. */
			if (vendor == CPUVENDOR_INTEL && family == 6 &&
			    (model == 5 || model == 7)) {
				name = intel686_cpu_name(model);
			} else
				name = cpup->cpu_family[i].cpu_models[model];
			if (name == NULL)
				name = cpup->cpu_family[i].cpu_models[CPU_DEFMODEL];
			class = cpup->cpu_family[i].cpu_class;
			cpu_setup = cpup->cpu_family[i].cpu_setup;
		}
	}

	/* Find the amount of on-chip L2 cache.  Add support for AMD K6-3...*/
	cachesize = -1;
	if (vendor == CPUVENDOR_INTEL && cpuid_level >= 2 && family < 0xf) {
		int intel_cachetable[] = { 0, 128, 256, 512, 1024, 2048 };
		if ((cpu_cache_edx & 0xFF) >= 0x40 &&
		    (cpu_cache_edx & 0xFF) <= 0x45)
			cachesize = intel_cachetable[(cpu_cache_edx & 0xFF) - 0x40];
	}

	if (cachesize > -1) {
		sprintf(cpu_model, "%s %s%s (%s%s%s%s-class, %dKB L2 cache)",
			vendorname, modifier, name,
			((*token) ? "\"" : ""), ((*token) ? token : ""),
			((*token) ? "\" " : ""), classnames[class], cachesize);
	} else {
		sprintf(cpu_model, "%s %s%s (%s%s%s%s-class)",
			vendorname, modifier, name,
			((*token) ? "\"" : ""), ((*token) ? token : ""),
			((*token) ? "\" " : ""), classnames[class]);
	}

	/* configure the CPU if needed */
	if (cpu_setup != NULL)
		cpu_setup(cpu_device, model, step);

	printf("%s: %s", cpu_device, cpu_model);

#if defined(I586_CPU) || defined(I686_CPU)
	if (cpu_feature && (cpu_feature & CPUID_TSC)) {	/* Has TSC */
		calibrate_cyclecounter();
		if (pentium_mhz > 994) {
			int ghz, fr;

			ghz = (pentium_mhz + 9) / 1000;
			fr = ((pentium_mhz + 9) / 10 ) % 100;
			if (fr)
				printf(" %d.%02d GHz", ghz, fr);
			else
				printf(" %d GHz", ghz);
		} else
			printf(" %d MHz", pentium_mhz);
	}
#endif
	printf("\n");

	if (cpu_feature) {
		int numbits = 0;

		printf("%s: ", cpu_device);
		max = sizeof(i386_cpuid_features)
			/ sizeof(i386_cpuid_features[0]);
		for (i = 0; i < max; i++) {
			if (cpu_feature & i386_cpuid_features[i].feature_bit) {
				printf("%s%s", (numbits == 0 ? "" : ","),
				    i386_cpuid_features[i].feature_name);
				numbits++;
			}
		}
		printf("\n");
	}

	cpu_class = class;

	/*
	 * Now that we have told the user what they have,
	 * let them know if that machine type isn't configured.
	 */
	switch (cpu_class) {
#if !defined(I386_CPU) && !defined(I486_CPU) && !defined(I586_CPU) && !defined(I686_CPU)
#error No CPU classes configured.
#endif
#ifndef I686_CPU
	case CPUCLASS_686:
		printf("NOTICE: this kernel does not support Pentium Pro CPU class\n");
#ifdef I586_CPU
		printf("NOTICE: lowering CPU class to i586\n");
		cpu_class = CPUCLASS_586;
		break;
#endif
#endif
#ifndef I586_CPU
	case CPUCLASS_586:
		printf("NOTICE: this kernel does not support Pentium CPU class\n");
#ifdef I486_CPU
		printf("NOTICE: lowering CPU class to i486\n");
		cpu_class = CPUCLASS_486;
		break;
#endif
#endif
#ifndef I486_CPU
	case CPUCLASS_486:
		printf("NOTICE: this kernel does not support i486 CPU class\n");
#ifdef I386_CPU
		printf("NOTICE: lowering CPU class to i386\n");
		cpu_class = CPUCLASS_386;
		break;
#endif
#endif
#ifndef I386_CPU
	case CPUCLASS_386:
		printf("NOTICE: this kernel does not support i386 CPU class\n");
		panic("no appropriate CPU class available");
#endif
	default:
		break;
	}

	if (cpu == CPU_486DLC) {
#ifndef CYRIX_CACHE_WORKS
		printf("WARNING: CYRIX 486DLC CACHE UNCHANGED.\n");
#else
#ifndef CYRIX_CACHE_REALLY_WORKS
		printf("WARNING: CYRIX 486DLC CACHE ENABLED IN HOLD-FLUSH MODE.\n");
#else
		printf("WARNING: CYRIX 486DLC CACHE ENABLED.\n");
#endif
#endif
	}

#if defined(I486_CPU) || defined(I586_CPU) || defined(I686_CPU)
	/*
	 * On a 486 or above, enable ring 0 write protection.
	 */
	if (cpu_class >= CPUCLASS_486)
		lcr0(rcr0() | CR0_WP);
#endif
}

d2035 2
a2036 2
	setgate(&idt[ 14], &IDTVEC(f00f_redirect), 0, SDT_SYS386TGT, SEL_KPL,
	    GCODE_SEL);
d2126 1
a2126 1
	for (i = 19; i < NRSVIDT; i++)
a2127 2
	for (i = NRSVIDT; i < NIDT; i++)
		unsetgate(&idt[i]);
d2145 1
a2145 1
	/* Boot arguments are in a single page specified by /boot */
d2150 2
a2151 2
		if (extent_alloc_region(iomem_ex, (paddr_t)bootargv, bootargc,
		    EX_NOWAIT))
d2169 3
a2171 4
	/* install the page after boot args as PT page for first 4M */
	pmap_enter(pmap_kernel(), (u_long)vtopte(0),
	   i386_round_page(bootargv + bootargc), VM_PROT_READ|VM_PROT_WRITE,
	   TRUE, VM_PROT_READ|VM_PROT_WRITE);
d2479 1
a2479 1
idt_vec_alloc(int low, int high)
d2485 2
a2486 2
			return (vec);
	return (0);
d2490 1
a2490 1
idt_vec_set(int vec, void (*function) __P((void)))
d2492 1
a2492 1
	setgate(&idt[vec], function, 0, SDT_SYS386IGT, SEL_KPL, GCODE_SEL);
d2496 1
a2496 1
idt_vec_free(int vec)
@


1.124.2.7
log
@curpcb must be initialized
@
text
@d448 1
a448 1
	curpcb = pcb = &proc0.p_addr->u_pcb;
@


1.124.2.8
log
@reserve page 4 for mp trampoline
@
text
@d2418 2
a2419 2
			if (a < 5 * NBPG)
				a = 5 * NBPG;
@


1.124.2.9
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.7 2001/10/27 09:48:47 niklas Exp $	*/
d123 1
d125 1
d362 1
a362 1
	 * (space reserved in pmap_bootstrap)
d368 2
a369 2
		    VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d408 1
a408 1
	mb_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
d411 5
d494 4
d648 2
a649 2
			    VM_PROT_READ|VM_PROT_WRITE,
			    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d2065 1
a2065 1
			    VM_PROT_READ, PMAP_WIRED);
d2374 1
a2374 1
			panic("too many boot args");
d2381 2
a2382 2
		    VM_PROT_READ|VM_PROT_WRITE,
		    VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d2398 1
a2398 1
	   VM_PROT_READ|VM_PROT_WRITE|PMAP_WIRED);
d2427 1
a2427 1
				printf("-S");
d2481 1
a2481 1
				printf(" %x-%x (<16M)", a, lim);
d2487 1
a2487 1
					printf(" %x-%x", lim, e);
d2494 1
a2494 1
				printf(" %x-%x", a, e);
d2937 1
a2937 1
	error = extent_alloc_subregion(ex, rstart, rend, size, alignment, 0,
a3300 18
	if (nsegs > map->_dm_segcnt || size > map->_dm_size)
		return (EINVAL);

	/*
	 * Make sure we don't cross any boundaries.
	 */
	if (map->_dm_boundary) {
		bus_addr_t bmask = ~(map->_dm_boundary - 1);
		int i;

		for (i = 0; i < nsegs; i++) {
			if (segs[i].ds_len > map->_dm_maxsegsz)
				return (EINVAL);
			if ((segs[i].ds_addr & bmask) !=
			    ((segs[i].ds_addr + segs[i].ds_len - 1) & bmask))
				return (EINVAL);
		}
	}
d3302 1
a3302 3
	bcopy(segs, map->dm_segs, nsegs * sizeof(*segs));
	map->dm_nsegs = nsegs;
	return (0);
d3417 2
a3418 2
			    VM_PROT_READ | VM_PROT_WRITE,
			    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
d3450 1
a3450 1
paddr_t
d3454 1
a3454 3
	int nsegs;
	off_t off;
	int prot, flags;
d3614 1
a3614 1
	m = TAILQ_FIRST(&mlist);
d3618 1
d3620 1
a3620 1
	for (m = TAILQ_NEXT(m, pageq); m != NULL; m = TAILQ_NEXT(m, pageq)) {
a3622 4
		if (curseg == nsegs) {
			printf("uvm_pglistalloc returned too many\n");
			panic("_bus_dmamem_alloc_range");
		}
d3624 1
a3624 1
			printf("uvm_pglistalloc returned non-sensical"
@


1.124.2.10
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d122 2
d213 1
d535 5
d556 1
a556 1
		    NULL, UVM_UNKNOWN_OFFSET, 0,
d3337 1
a3337 1
_bus_dmamap_sync(t, map, addr, size, op)
d3340 1
a3340 3
	bus_addr_t addr;
	bus_size_t size;
	int op;
@


1.124.2.11
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.10 2001/11/13 21:00:51 niklas Exp $	*/
d246 3
a248 3
struct vm_map *exec_map = NULL;
struct vm_map *mb_map = NULL;
struct vm_map *phys_map = NULL;
d544 1
a544 1
	struct vm_page *pg;
d550 1
a550 1
				UVM_ADV_NORMAL, 0)))
d1850 1
a1850 1
	if (howto & RB_DUMP) {
d2485 1
a2485 1
	tlbflush();
d2660 1
a2660 2
	tlbflush(); 
#endif
d2663 1
d2994 1
a2994 1
	tlbflush();
d3368 1
a3368 1
	struct vm_page *m;
d3424 1
a3424 1
	tlbflush();
d3599 1
a3599 1
	struct vm_page *m;
@


1.124.2.12
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d85 1
a215 5

#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

a220 1
int	bufcachepercent = BUFCACHEPERCENT;
d247 1
d353 1
a353 2
	vaddr_t minaddr, maxaddr, va;
	paddr_t pa;
d360 5
a364 7
	va = (vaddr_t)msgbufp;
	for (i = 0; i < btoc(MSGBUFSIZE); i++) {
		pmap_kenter_pa(va, pa, VM_PROT_READ|VM_PROT_WRITE);
		va += PAGE_SIZE;
		pa += PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
d403 3
d437 1
d500 3
d514 1
a514 1
			    bufcachepercent / 100;
d616 1
a616 1
	pg = TAILQ_FIRST(&pgs);
d627 5
a631 4
		    size > 0; size -= PAGE_SIZE, addr += PAGE_SIZE) {
			pmap_kenter_pa(addr, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ|VM_PROT_WRITE);
			pg = TAILQ_NEXT(pg, pageq);
a633 1
	pmap_update(pmap_kernel());
d803 1
a803 3
				0, "Athlon Model 6 (Palomino)",
				"Athlon Model 7 (Morgan)", 0,
				0, 0, 0, 0, 0, 0, 0,
d1850 4
a1853 1
	if (howto & RB_DUMP)
d1855 1
d2994 1
a2994 1
	pmap_update(pmap_kernel());
d3424 1
a3424 1
	pmap_update(pmap_kernel());
a3650 3

/* If SMALL_KERNEL this results in an out of line definition of splx.  */
SPLX_OUTLINED_BODY
@


1.124.2.13
log
@Merge in -current from about a week ago
@
text
@d278 11
a288 12
caddr_t	allocsys(caddr_t);
void	setup_buffers(vm_offset_t *);
void	dumpsys(void);
int	cpu_dump(void);
void	old_identifycpu(void);
void	init386(vm_offset_t);
void	consinit(void);

int	bus_mem_add_mapping(bus_addr_t, bus_size_t,
	    int, bus_space_handle_t *);
int	_bus_dmamap_load_buffer(bus_dma_tag_t, bus_dmamap_t, void *,
    bus_size_t, struct proc *, int, paddr_t *, int *, int);
d313 1
a313 1
void kgdb_port_init(void);
d324 7
a330 6
void	winchip_cpu_setup(const char *, int, int);
void	cyrix3_cpu_setup(const char *, int, int);
void	cyrix6x86_cpu_setup(const char *, int, int);
void	intel586_cpu_setup(const char *, int, int);
void	intel686_cpu_setup(const char *, int, int);
char *	intel686_cpu_name(int);
d640 1
d1392 1
a1392 1
	void (*cpu_setup)(const char *, int, int);
a1441 2
			if (class > CPUCLASS_686)
				class = CPUCLASS_686;
d1464 1
a1464 1
			if (name == NULL) {
a1465 3
				if (name == NULL)
					name = "";
			}
d1600 1
a1600 1
void ibcs2_sendsig(sig_t, int, int, u_long, int, union sigval);
d1682 2
a1683 2
		__asm("movw %%gs,%w0" : "=r" (frame.sf_sc.sc_gs));
		__asm("movw %%fs,%w0" : "=r" (frame.sf_sc.sc_fs));
d1722 2
a1723 2
	__asm("movw %w0,%%gs" : : "r" (GSEL(GUDATA_SEL, SEL_UPL)));
	__asm("movw %w0,%%fs" : : "r" (GSEL(GUDATA_SEL, SEL_UPL)));
d1950 1
a1950 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d1989 1
a1989 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
d2121 2
a2122 2
	__asm("movw %w0,%%gs" : : "r" (LSEL(LUDATA_SEL, SEL_UPL)));
	__asm("movw %w0,%%fs" : : "r" (LSEL(LUDATA_SEL, SEL_UPL)));
@


1.124.2.14
log
@Sync the SMP branch with 3.3
@
text
@d107 6
a138 1
#include <dev/rndvar.h>
d169 5
d178 1
a178 1
#if NPCCOM > 0
d231 2
a232 2
	paddr_t	start;
	paddr_t	end;
d249 1
a249 1
paddr_t avail_end;
d279 1
a279 1
void	setup_buffers(vaddr_t *);
d283 1
a283 1
void	init386(paddr_t);
a327 1
void	natsem6x86_cpu_setup(const char *, int, int);
a330 2
char *	cyrix3_cpu_name(int, int);
void	viac3_rnd(void *);
d487 9
a495 1

d522 1
a522 2
	/* Restrict to at most 35% filled kvm */
	/* XXX - This needs UBC... */
d524 1
a524 1
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 35 / 100) 
d526 1
a526 1
		    MAXBSIZE * 35 / 100;
d538 1
a538 1
	vaddr_t *maxaddr;
d540 2
a541 2
	vsize_t size;
	vaddr_t addr;
d625 1
a625 1
		addr = (vaddr_t)buffers + i * MAXBSIZE;
d801 4
a804 7
				"Duron Model 3 (Spitfire)",
				"Athlon Model 4 (Thunderbird)",
				0, "Athlon XP Model 6 (Palomino)",
				"Duron Model 7 (Morgan)", 
				"Athlon XP Model 8 (Thoroughbred)",
				0, "Athlon XP Model 10 (Barton)",
				0, 0, 0, 0, 0,
d873 3
a875 4
				0, 0, 0, 0, 0, 0, "C3 Samuel 1",
				"C3 Samule 2/Ezra",
				"C3 Ezra-T", 0, 0, 0, 0, 0, 0, 0,
				"C3"		/* Default */
a948 25
	},
	{
		"Geode by NSC",
		CPUVENDOR_NS,
		"National Semiconductor",
		/* Family 4, not available from National Semiconductor */
		{ {
			CPUCLASS_486,
			{
				0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
				"486 class"	/* Default */
			},
			NULL
		},
		/* Family 5 */
		{
			CPUCLASS_586,
			{
				0, 0, 0, 0, "Geode GX1", 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0,
				"M1 class"	/* Default */
			},
			natsem6x86_cpu_setup
		} }
a994 63
#if defined(I686_CPU)
/*
 * Note, the VIA C3 Nehemia provides 4 internal 8-byte buffers, which
 * store random data, and can be accessed a lot quicker than waiting
 * for new data to be generated.  As we are using every 8th bit only
 * due to whitening, we only pull off 4 bytes worth of data here, to
 * help prevent stalling, and allow the RNG to generate new data in
 * parallel with anything else going on.
 *
 * Note, due to some weirdness in the RNG, we need at last 7 bytes
 * extra on the end of our buffer.  Also, there is an outside chance
 * that the VIA RNG can "wedge", as the generated bit-rate is variable.
 * Since the RNG generates in excess of 21KB/s at it's worst, this is
 * still significantly faster than the rate at which we are collecting
 * from it.  We could do all sorts of startup testing and things, but
 * frankly, I don't really see the point.
 *
 * Adding to the whole confusion, in order to access the RNG, we need
 * to have FXSR support enabled, and the correct FPU enable bits must
 * be there to enable the FPU.  It would be nice if all this mumbo-
 * jumbo was not needed in order to use the RNG.  Oh well, life does
 * go on...
 */
#define VIAC3_RNG_BUFSIZ	16		/* 32bit words */
struct timeout viac3_rnd_tmo;
int viac3_rnd_present = 0;

void
viac3_rnd(void *v)
{
	struct timeout *tmo = v;
	unsigned int *p, i, rv, creg0, creg4, len = VIAC3_RNG_BUFSIZ;
	static int buffer[VIAC3_RNG_BUFSIZ + 2];
	int s;

	s = splhigh();
	/* XXX - should not be needed, but we need FXSR & FPU set to access RNG */
	creg0 = rcr0();
	lcr0(creg0 & ~(CR0_EM|CR0_TS));
	creg4 = rcr4();
	lcr4(creg4 | CR4_OSFXSR);

	/*
	 * Here we collect the random data from the VIA C3 RNG.  We make
	 * sure that we turn on maximum whitening (%edx[0,1] == "11"), so
	 * that we get the best random data possible.
	 */
	__asm __volatile ("rep;.byte 0x0F,0xA7,0xC0"
	    : "=a" (rv) : "d" (3), "D" (buffer), "c" (len*sizeof(int))
	    : "memory", "cc");

	/* XXX - should not be needed */
	lcr0(creg0);
	lcr4(creg4);

	for (i = 0, p = buffer; i < VIAC3_RNG_BUFSIZ; i++, p++)
		add_true_randomness(*p);

	timeout_add(tmo, (hz>100)?(hz/100):1);
	splx(s);
}
#endif

d1005 1
a1005 3
	case 6: /* C3 Samuel 1 */
	case 7: /* C3 Samuel 2 or C3 Ezra */
	case 8: /* C3 Ezra-T */
a1013 39

	case 9:
		if (step < 3)
			break;

		/* 
		 * C3 Nehemia:
		 * First we check for extended feature flags, and then
		 * (if present) retrieve the ones at 0xC0000001.  In this
		 * bit 2 tells us if the RNG is present.  Bit 3 tells us
		 * if the RNG has been enabled.  In order to use the RNG
		 * we need 3 things:  We need an RNG, we need the FXSR bit
		 * enabled in cr4 (SSE/SSE2 stuff), and we need to have
		 * Bit 6 of MSR 0x110B set to 1 (the default), which will
		 * show up as bit 3 set here.
		 */
		__asm __volatile("cpuid" /* Check for RNG */
		    : "=a" (val) : "a" (0xC0000000) : "cc");
		if (val >= 0xC0000001) {
			__asm __volatile("cpuid"
			    : "=d" (val) : "a" (0xC0000001) : "cc");
		}

		/* Stop here if no RNG */
		if (!(val & 0x4))
			break;

		/* Enable RNG if disabled */
		if (!(val & 0x8)) {
			u_int64_t msreg;

			msreg = rdmsr(0x110B);
			msreg |= 0x40;
			wrmsr(0x110B, msreg);
			printf("Screwed with MSR 0x110B!\n");
		}
		viac3_rnd_present = 1;
		printf("%s: RNG activated\n", cpu_device);
		break;
a1023 2
	extern int clock_broken_latch;

a1044 1
		clock_broken_latch = 1;
a1051 12
natsem6x86_cpu_setup(cpu_device, model, step)
	const char *cpu_device;
	int model, step;
{
#if defined(I586_CPU) || defined(I686_CPU)
	extern int clock_broken_latch;

	clock_broken_latch = 1;
#endif
}

void
a1145 24
char *
cyrix3_cpu_name(model, step)
	int model, step;
{
	char	*name = NULL;

	switch (model) {
	case 7:
		if (step < 8)
			name = "C3 Samuel 2";
		else
			name = "C3 Ezra";
		break;
	case 8:
		if (step < 8)
			name = "C3 Ezra-T";
		break;
	case 9:
		name = "C3 Nehemia";
		break;
	}
	return name;
}

a1450 5
			/* Special hack for the VIA C3 series. */
			if (vendor == CPUVENDOR_IDT && family >= 6) {
				vendor = CPUVENDOR_VIA;
				vendorname = "VIA";
			}
a1462 4
			/* Special hack for the VIA C3 series. */
			} else if (vendor == CPUVENDOR_VIA && family == 6 &&
				   model >= 7 && model <= 8) {
				name = cyrix3_cpu_name(model, step);
d1638 2
a1639 3
	struct proc *p = curproc;
	struct pmap *pmap = vm_map_pmap(&p->p_vmspace->vm_map);
	struct trapframe *tf = p->p_md.md_regs;
d1642 2
a1643 1
	int oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d1650 3
d1730 2
a1731 3
	tf->tf_eip = p->p_sigcode;
	tf->tf_cs = pmap->pm_nxpages > 0?
	    GSEL(GUCODE1_SEL, SEL_UPL) : GSEL(GUCODE_SEL, SEL_UPL);
d1976 1
a1976 1
static vaddr_t dumpspace;
d1978 3
a1980 2
vaddr_t
reserve_dumppages(vaddr_t p)
d1984 1
a1984 1
	return (p + PAGE_SIZE);
d2110 2
a2111 3
	struct pcb *pcb = &p->p_addr->u_pcb;
	struct pmap *pmap = vm_map_pmap(&p->p_vmspace->vm_map);
	struct trapframe *tf = p->p_md.md_regs;
d2124 1
d2132 1
a2132 2
	tf->tf_cs = pmap->pm_nxpages > 0?
	    LSEL(LUCODE1_SEL, SEL_UPL) : LSEL(LUCODE_SEL, SEL_UPL);
d2226 1
a2226 1
fix_f00f(void)
d2229 1
a2229 1
	vaddr_t va;
d2267 2
a2268 1
init386(paddr_t first_avail)
d2301 1
a2301 4
	setsegment(&gdt[GUCODE1_SEL].sd, 0, i386_btop(VM_MAXUSER_ADDRESS) - 1,
	    SDT_MEMERA, SEL_UPL, 1, 1);
	setsegment(&gdt[GUCODE_SEL].sd, 0,
	    i386_btop(VM_MAXUSER_ADDRESS - MAXSSIZ) - 1,
a2308 1
	ldt[LUCODE1_SEL] = gdt[GUCODE1_SEL];
d2352 1
a2352 1
	pmap_bootstrap((vaddr_t)atdevbase + IOM_SIZE);
d2396 1
a2396 1
			register paddr_t a, e;
d2408 1
a2408 1
			if (a >= e || (e - a) < NBPG) {
d2450 2
a2451 2
		paddr_t a, e;
		paddr_t lim;
d2607 3
d2611 1
d2962 1
a2962 1
	vaddr_t va;
d3404 1
a3404 1
	vaddr_t va;
d3448 1
a3448 1
	uvm_km_free(kernel_map, (vaddr_t)kva, size);
d3526 1
a3526 1
		pmap_extract(pmap, vaddr, (paddr_t *)&curaddr);
d3597 2
a3598 2
	paddr_t low;
	paddr_t high;
d3600 1
a3600 1
	paddr_t curaddr, lastaddr;
a3652 10

#ifdef DIAGNOSTIC
void
splassert_check(int wantipl, const char *func)
{
	if (cpl < wantipl) {
		splassert_fail(wantipl, cpl, func);
	}
}
#endif
@


1.124.2.15
log
@Move TSS selector from the PCB to MD part of proc and to cpu_info.
Maintain a list of CPUs and provide an iterator for it.
Ifdef out IPI debugging.  Call pmap_{de,}activate as part of context switching.
Mostly from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.14 2003/03/27 23:26:55 niklas Exp $	*/
a431 1
	int x;
d438 1
a438 10
	pcb->pcb_flags = 0;
	pcb->pcb_tss.tss_ioopt =
	    ((caddr_t)pcb->pcb_iomap - (caddr_t)&pcb->pcb_tss) << 16;
	for (x = 0; x < sizeof(pcb->pcb_iomap) / 4; x++)
		pcb->pcb_iomap[x] = 0xffffffff;
	pcb->pcb_iomap_pad = 0xff;

	pcb->pcb_ldt_sel = pmap_kernel()->pm_ldt_sel = GSEL(GLDT_SEL, SEL_KPL);
	pcb->pcb_cr0 = rcr0();
	proc0.p_md.md_tss_sel = tss_alloc(pcb);
d440 1
a440 1
	ltr(proc0.p_md.md_tss_sel);
d447 1
a447 1
i386_init_pcb_tss_ldt(struct cpu_info *ci)
a449 1
	struct pcb *pcb = ci->ci_idle_pcb;
d460 1
a460 1
	ci->ci_idle_tss_sel = tss_alloc(pcb);
@


1.124.2.16
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.15 2003/04/11 16:12:57 niklas Exp $	*/
a199 4
#ifdef USER_LDT
int	user_ldt_enable = 0;	/* sysctl'd to 1 to enable */
#endif

a315 1
void	amd_family5_setup(const char *, int, int);
d791 1
a791 1
			amd_family5_setup
d1026 3
a1028 3
 * due to whitening. Since the RNG generates in excess of 21KB/s at
 * it's worst, collecting 64 bytes worth of entropy should not affect
 * things significantly.
d1030 1
a1030 1
 * Note, due to some weirdness in the RNG, we need at least 7 bytes
d1033 4
a1036 3
 * We could do all sorts of startup testing and things, but
 * frankly, I don't really see the point.  If the RNG wedges, then the
 * chances of you having a defective CPU are very high.  Let it wedge.
d1040 3
a1042 3
 * be there to enable the FPU in kernel.  It would be nice if all this
 * mumbo-jumbo was not needed in order to use the RNG.  Oh well, life
 * does go on...
a1208 23
amd_family5_setup(cpu_device, model, step)
	const char *cpu_device;
	int model, step;
{
	switch (model) {
	case 0:         /* AMD-K5 Model 0 */
		/*
		 * According to the AMD Processor Recognition App Note,
		 * the AMD-K5 Model 0 uses the wrong bit to indicate
		 * support for global PTEs, instead using bit 9 (APIC)
		 * rather than bit 13 (i.e. "0x200" vs. 0x2000".  Oops!).
		 */
		if (cpu_feature & CPUID_APIC)
			cpu_feature = (cpu_feature & ~CPUID_APIC) | CPUID_PGE;
		/*
		 * XXX But pmap_pg_g is already initialized -- need to kick
		 * XXX the pmap somehow.  How does the MP branch do this?
		 */
		break;
	}
}

void
d1434 1
a1434 2
		snprintf(cpu_model, sizeof(cpu_model),
			"%s %s%s (%s%s%s%s-class, %dKB L2 cache)",
d1439 1
a1439 2
		snprintf(cpu_model, sizeof(cpu_model),
			"%s %s%s (%s%s%s%s-class)",
d1663 4
a1666 5
		snprintf(cpu_model, sizeof(cpu_model),
		    "%s %s%s (%s%s%s%s-class, %dKB L2 cache)",
		    vendorname, modifier, name,
		    ((*token) ? "\"" : ""), ((*token) ? token : ""),
		    ((*token) ? "\" " : ""), classnames[class], cachesize);
d1668 4
a1671 5
		snprintf(cpu_model, sizeof(cpu_model),
		    "%s %s%s (%s%s%s%s-class)",
		    vendorname, modifier, name,
		    ((*token) ? "\"" : ""), ((*token) ? token : ""),
		    ((*token) ? "\" " : ""), classnames[class]);
d2478 2
a2479 1
	setsegment(&gdt[GUCODE_SEL].sd, 0, i386_btop(I386_MAX_EXE_ADDR) - 1,
d2773 3
a2960 5
#ifdef USER_LDT
	case CPU_USERLDT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &user_ldt_enable));
#endif
@


1.124.2.17
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.16 2003/05/13 19:42:07 ho Exp $	*/
d2351 1
d2501 1
a2501 1
	/* make bootstrap gdt gates and memory segments */
d2505 2
a2506 2
	setsegment(&gdt[GLDT_SEL].sd, ldt, sizeof(ldt) - 1, SDT_SYSLDT,
	    SEL_KPL, 0, 0);
a2512 2
	setsegment(&gdt[GCPU_SEL].sd, &cpu_info_primary,
	    sizeof(struct cpu_info)-1, SDT_MEMRWA, SEL_KPL, 1, 1);
d2548 1
a2548 1
	setregion(&region, gdt, NGDT * sizeof(union descriptor) - 1);
a3867 28
}
#endif

#ifdef MULTIPROCESSOR
void
i386_intlock(struct intrframe iframe)
{
	if (iframe.if_ppl < IPL_SCHED)
		spinlockmgr(&kernel_lock, LK_EXCLUSIVE|LK_CANRECURSE, 0);
}

void
i386_intunlock(struct intrframe iframe)
{
	if (iframe.if_ppl < IPL_SCHED)
		spinlockmgr(&kernel_lock, LK_RELEASE, 0);
}

void
i386_softintlock(void)
{
	spinlockmgr(&kernel_lock, LK_EXCLUSIVE|LK_CANRECURSE, 0);
}

void
i386_softintunlock(void)
{
	spinlockmgr(&kernel_lock, LK_RELEASE, 0);
@


1.124.2.18
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a284 2
int	longrun_sysctl(void *, size_t *, void *, size_t);

a325 1
void	tm86_cpu_setup(const char *, int, int);
d943 1
a943 1
			tm86_cpu_setup
d945 1
a945 1
		/* Family 6, not yet available from Transmeta */
a1276 12
void
tm86_cpu_setup(cpu_device, model, step)
	const char *cpu_device;
	int model, step;
{
#ifndef SMALL_KERNEL
	extern int longrun_enabled;

	longrun_enabled = 1;
#endif
}

d1937 1
a1937 1
	tf->tf_cs = pmap->pm_hiexec > I386_MAX_EXE_ADDR ? 
d2338 1
a2338 1
	tf->tf_cs = pmap->pm_hiexec > I386_MAX_EXE_ADDR ? 
a2993 4
#ifndef SMALL_KERNEL
	case CPU_LONGRUN:
		return (longrun_sysctl(oldp, oldlenp, newp, newlen));
#endif
d2995 1
a2995 1
		return (EOPNOTSUPP);
@


1.124.2.19
log
@Some i386-specific stuff:
Stop other CPUs when entering ddb
'machine sysregs' shows system registers not usually used by applications
'machine cpuinfo' shows the status of the processors
'machine startcpu n' starts CPU n
'machine stopcpu n' stops CPU n
'machine ddbcpu n' transfers ddb control to CPU n (not very useful yet
though since the second processor can't use the keyboard...)

Niklas said that I should test this first to at least make sure it
compiles, but I'm too anxious to do my first commit. :)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.18 2003/05/16 00:29:39 niklas Exp $	*/
a2734 1
	db_machine_init();
@


1.124.2.20
log
@Go back to defining simplelocks as noops, even if MULTIPROCESSOR.  Instead use
a new real simple recursive-lock capable lock implementation for the few
necessary locks (kernel, scheduler, tlb shootdown, printf and ddb MP).
This because we cannot trust the old fine-grained locks spread out all over
our kernel, and not really tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.19 2003/05/17 16:07:37 andreas Exp $	*/
a3896 1
#ifdef notdef
a3897 3
#else
		__mp_lock(&kernel_lock);
#endif
a3903 1
#ifdef notdef
a3904 3
#else
		__mp_unlock(&kernel_lock);
#endif
a3909 1
#ifdef notdef
a3910 3
#else
	__mp_lock(&kernel_lock);
#endif
a3915 1
#ifdef notdef
a3916 3
#else
	__mp_unlock(&kernel_lock);
#endif
@


1.124.2.21
log
@Fix splassert in the SMP branch. Remove the old 'cpl' variable. While here,
remove a bunch of commons from intr.h. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.20 2003/05/18 17:41:15 niklas Exp $	*/
d3886 3
a3888 2
	if (lapic_tpr < wantipl)
		splassert_fail(wantipl, lapic_tpr, func);
@


1.124.2.22
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.21 2003/05/25 19:24:31 ho Exp $	*/
d58 5
a62 1
 * 3. Neither the name of the University nor the names of its contributors
d720 1
a720 2
				"Pentium M",
				"Pentium III Xeon (Cascades)",
a1005 2
	{ CPUID_CFLUSH,	"CFLUSH" },
	{ CPUID_ACPI,	"ACPI" },
a1008 5
	{ CPUID_SIMD2,	"SIMD2" },
	{ CPUID_SS,	"SS" },
	{ CPUID_HTT,	"HTT" },
	{ CPUID_TM,	"TM" },
	{ CPUID_SBF,	"SBF" },
a1011 6
const struct cpu_cpuid_feature i386_cpuid_ecxfeatures[] = {
	{ CPUIDECX_EST,		"EST" },
	{ CPUIDECX_TM2,		"TM2" },
	{ CPUIDECX_CNXTID,	"CNXT-ID" },
};

d1250 1
a1250 1
	__asm __volatile ("rdmsr" : "=A" (v) : "c" (msr));	\
d1254 1
a1254 1
	__asm __volatile ("wrmsr" :: "A" ((u_quad_t) (v)), "c" (msr));
a1593 1
	extern int cpu_ecxfeature;
a1756 10
		max = sizeof(i386_cpuid_ecxfeatures)
			/ sizeof(i386_cpuid_ecxfeatures[0]);
		for (i = 0; i < max; i++) {
			if (cpu_ecxfeature &
			    i386_cpuid_ecxfeatures[i].feature_bit) {
				printf("%s%s", (numbits == 0 ? "" : ","),
				    i386_cpuid_ecxfeatures[i].feature_name);
				numbits++;
			}
		}
a3465 3

	if (resid > map->_dm_size)
		return (EINVAL);
@


1.124.2.23
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a103 4
#ifdef CRYPTO
#include <crypto/cryptodev.h>
#endif

a237 5
int	i386_use_fxsave;
int	i386_has_sse;
int	i386_has_sse2;
int	i386_has_xcrypt;

a274 1
void	(*cpuresetfn)(void);
d281 2
a318 1
void	amd_family6_setup(const char *, int, int);
a326 1
char *	tm86_cpu_name(int);
a342 18

/*
 * cpuid instruction.  request in eax, result in eax, ebx, ecx, edx.
 * requires caller to provide u_int32_t regs[4] array.
 */
void
cpuid(u_int32_t ax, u_int32_t *regs)
{
	__asm __volatile(
	    "cpuid\n\t"
	    "movl	%%eax, 0(%2)\n\t"
	    "movl	%%ebx, 4(%2)\n\t"
	    "movl	%%ecx, 8(%2)\n\t"
	    "movl	%%edx, 12(%2)\n\t"
	    :"=a" (ax)
	    :"0" (ax), "S" (regs)
	    :"bx", "cx", "dx");
}
d440 2
d443 1
a451 3
	pcb->pcb_tss.tss_ss0 = GSEL(GDATA_SEL, SEL_KPL);
	pcb->pcb_tss.tss_esp0 = (int)proc0.p_addr + USPACE - 16;
	proc0.p_md.md_regs = (struct trapframe *)pcb->pcb_tss.tss_esp0 - 1;
d456 2
d466 1
d687 1
a687 1
				"486SX2", 0, "486DX2 W/B",
d697 1
a697 1
				"Pentium (A-step)", "Pentium (P5)",
d700 1
a700 1
				"Pentium (P54C)", "Pentium/MMX",
d710 6
a715 6
				"Pentium Pro", "Pentium Pro", 0,
				"Pentium II", "Pentium Pro",
				"Pentium II/Celeron",
				"Celeron",
				"Pentium III",
				"Pentium III",
d717 2
a718 2
				"Pentium III Xeon",
				"Pentium III", 0, 0,
d803 6
a808 6
				"Duron Model 3",
				"Athlon Model 4",
				0, "Athlon XP Model 6",
				"Duron Model 7", 
				"Athlon XP Model 8",
				0, "Athlon XP Model 10",
d810 1
a810 1
				"K7"		/* Default */
d812 1
a812 44
			amd_family6_setup
		},
		/* Family 7 */
		{
			CPUCLASS_686,
		} ,
		/* Family 8 */
		{
			CPUCLASS_686,
		} ,
		/* Family 9 */
		{
			CPUCLASS_686,
		} ,
		/* Family A */
		{
			CPUCLASS_686,
		} ,
		/* Family B */
		{
			CPUCLASS_686,
		} ,
		/* Family C */
		{
			CPUCLASS_686,
		} ,
		/* Family D */
		{
			CPUCLASS_686,
		} ,
		/* Family E */
		{
			CPUCLASS_686,
		} ,
		/* Family F */
		{
			CPUCLASS_686,
			{
				0, 0, 0, 0, "Athlon64",
				"Opteron or Athlon64FX", 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
				"AMD64"			/* DEFAULT */
			},
			amd_family6_setup
d833 1
a833 1
				0, 0, "6x86", 0, "GXm", 0, 0, 0, 0, 0,
d835 1
a835 1
				"586 class"	/* Default */
d843 1
a843 1
				"6x86MX", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
d845 1
a845 1
				"686 class"	/* Default */
d878 3
a880 5
				0, 0, 0, 0, 0, 0,
				"C3 Samuel",
				"C3 Samuel 2/Ezra",
				"C3 Ezra-T",
				"C3 Nehemiah", 0, 0, 0, 0, 0, 0,
d939 2
a940 2
				0, 0, 0, 0, "TMS5x00", 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0,
d976 1
a976 1
				"586 class"	/* Default */
a979 25
	},
	{
		"SiS SiS SiS ",
		CPUVENDOR_SIS,
		"SiS",
		/* Family 4, not available from SiS */
		{ {
			CPUCLASS_486,
			{
				0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,
				"486 class"	/* Default */
			},
			NULL
		},
		/* Family 5 */
		{
			CPUCLASS_586,
			{
				"SiS55x", 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0,
				"586 class"	/* Default */
			},
			NULL
		} }
d995 1
a995 1
	{ CPUID_SEP,	"SEP" },
d1007 2
a1008 2
	{ CPUID_SSE,	"SSE" },
	{ CPUID_SSE2,	"SSE2" },
a1027 1

d1041 1
a1041 1
 * Note, the VIA C3 Nehemiah provides 4 internal 8-byte buffers, which
d1069 1
a1069 1
	unsigned int *p, i, rv, creg0, len = VIAC3_RNG_BUFSIZ;
d1071 1
d1073 3
a1075 1
	creg0 = rcr0();		/* Permit access to SIMD/FPU path */
d1077 2
d1085 1
a1085 1
	__asm __volatile("rep xstore-rng"
d1089 1
d1091 1
d1097 1
d1099 1
a1099 295

#ifdef CRYPTO

struct viac3_session {
	u_int8_t ses_iv[16];
	int ses_klen, ses_used;
};

struct viac3_softc {
	/* operand stuff, must be 128 bit aligned */
	u_int32_t		op_cw[4];
	u_int8_t		op_iv[16];
	u_int8_t		op_key[32];
	void			*op_buf;
	u_int32_t		pad[2];

	/* normal softc stuff */
	int32_t			sc_cid;
	int			sc_nsessions;
	struct viac3_session	*sc_sessions;
};

#define VIAC3_SESSION(sid)		((sid) & 0x0fffffff)
#define	VIAC3_SID(crd,ses)		(((crd) << 28) | ((ses) & 0x0fffffff))

static struct viac3_softc *vc3_sc;
int viac3_crypto_present;

void viac3_crypto_setup(void);
int viac3_crypto_newsession(u_int32_t *, struct cryptoini *);
int viac3_crypto_process(struct cryptop *);
int viac3_crypto_freesession(u_int64_t);
void viac3_crypto(void *, void *, void *, void *, int, void *, int);

void
viac3_crypto_setup(void)
{
	int algs[CRYPTO_ALGORITHM_MAX + 1];

	if ((vc3_sc = malloc(sizeof(*vc3_sc), M_DEVBUF, M_NOWAIT)) == NULL)
		return;		/* YYY bitch? */
	bzero(vc3_sc, sizeof(*vc3_sc));

	bzero(algs, sizeof(algs));
	algs[CRYPTO_AES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;

	vc3_sc->sc_cid = crypto_get_driverid(0);
	if (vc3_sc->sc_cid < 0)
		return;		/* YYY bitch? */

	crypto_register(vc3_sc->sc_cid, algs, viac3_crypto_newsession,
	    viac3_crypto_freesession, viac3_crypto_process);
	i386_has_xcrypt = 1;
}

int
viac3_crypto_newsession(u_int32_t *sidp, struct cryptoini *cri)
{
	struct viac3_softc *sc = vc3_sc;
	struct viac3_session *ses = NULL;
	int sesn;

	if (sc == NULL || sidp == NULL || cri == NULL)
		return (EINVAL);
	if (cri->cri_next != NULL || cri->cri_alg != CRYPTO_AES_CBC)
		return (EINVAL);
	/* Initial version doesn't work for 192/256 */
	if (cri->cri_klen != 128)
		return (EINVAL);
	if (sc->sc_sessions == NULL) {
		ses = sc->sc_sessions = (struct viac3_session *)malloc(
		    sizeof(*ses), M_DEVBUF, M_NOWAIT);
		if (ses == NULL)
			return (ENOMEM);
		sesn = 0;
		sc->sc_nsessions = 1;
	} else {
		for (sesn = 0; sesn < sc->sc_nsessions; sesn++) {
			if (sc->sc_sessions[sesn].ses_used == 0) {
				ses = &sc->sc_sessions[sesn];
				break;
			}
		}

		if (ses == NULL) {
			sesn = sc->sc_nsessions;
			ses = (struct viac3_session *)malloc((sesn + 1) *
			    sizeof(*ses), M_DEVBUF, M_NOWAIT);
			if (ses == NULL)
				return (ENOMEM);
			bcopy(sc->sc_sessions, ses, sesn * sizeof(*ses));
			bzero(sc->sc_sessions, sesn * sizeof(*ses));
			free(sc->sc_sessions, M_DEVBUF);
			sc->sc_sessions = ses;
			ses = &sc->sc_sessions[sesn];
			sc->sc_nsessions++;
		}
	}

	bzero(ses, sizeof(*ses));
	ses->ses_used = 1;

	get_random_bytes(ses->ses_iv, sizeof(ses->ses_iv));
	ses->ses_klen = cri->cri_klen;
	bcopy(cri->cri_key, cri->cri_key, ses->ses_klen / 8);

	*sidp = VIAC3_SID(0, sesn);
	return (0);
}

int
viac3_crypto_freesession(u_int64_t tid)
{
	struct viac3_softc *sc = vc3_sc;
	int sesn;
	u_int32_t sid = ((u_int32_t)tid) & 0xffffffff;

	if (sc == NULL)
		return (EINVAL);
	sesn = VIAC3_SESSION(sid);
	if (sesn >= sc->sc_nsessions)
		return (EINVAL);
	bzero(&sc->sc_sessions[sesn], sizeof(sc->sc_sessions[sesn]));
	return (0);
}

int
viac3_crypto_process(struct cryptop *crp)
{
	struct viac3_softc *sc = vc3_sc;
	int sesn, err = 0;
	struct cryptodesc *crd;
	struct viac3_session *ses;

	if (crp == NULL || crp->crp_callback == NULL) {
		err = EINVAL;
		goto out;
	}
	sesn = VIAC3_SESSION(crp->crp_sid);
	if (sesn >= sc->sc_nsessions) {
		err = EINVAL;
		goto out;
	}
	ses = &sc->sc_sessions[sesn];

	crd = crp->crp_desc;
	if (crd == NULL || crd->crd_next != NULL ||
	    crd->crd_alg != CRYPTO_AES_CBC || crd->crd_klen != 128) {
		err = EINVAL;
		goto out;
	}

	bcopy(crd->crd_key, sc->op_key, crd->crd_klen / 8);

	if ((crd->crd_len % 16) != 0) {
		err = EINVAL;
		goto out;
	}

	sc->op_buf = (char *)malloc(crd->crd_len, M_DEVBUF, M_NOWAIT);
	if (sc->op_buf == NULL) {
		err = ENOMEM;
		goto out;
	}

	sc->op_cw[0] = C3_CRYPT_CWLO_ALG_AES | C3_CRYPT_CWLO_KEYGEN_HW |
	    C3_CRYPT_CWLO_NORMAL | C3_CRYPT_CWLO_KEY128;
	sc->op_cw[1] = sc->op_cw[2] = sc->op_cw[3] = 0;
	if (crd->crd_flags & CRD_F_ENCRYPT) {
		sc->op_cw[0] |= C3_CRYPT_CWLO_ENCRYPT;
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crd->crd_iv, sc->op_iv, 16);
		else
			bcopy(ses->ses_iv, sc->op_iv, 16);

		if ((crd->crd_flags & CRD_F_IV_PRESENT) == 0) {
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copyback((struct mbuf *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copyback((struct uio *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else
				bcopy(sc->op_iv,
				    crp->crp_buf + crd->crd_inject, 16);
		}
	} else {
		sc->op_cw[0] |= C3_CRYPT_CWLO_DECRYPT;
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crd->crd_iv, sc->op_iv, 16);
		else {
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata((struct mbuf *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copydata((struct uio *)crp->crp_buf,
				    crd->crd_inject, 16, sc->op_iv);
			else
				bcopy(crp->crp_buf + crd->crd_inject,
				    sc->op_iv, 16);
		}
	}

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		m_copydata((struct mbuf *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else if (crp->crp_flags & CRYPTO_F_IOV)
		cuio_copydata((struct uio *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else
		bcopy(crp->crp_buf + crd->crd_skip, sc->op_buf, crd->crd_len);

	viac3_crypto(&sc->op_cw, sc->op_buf, sc->op_buf, sc->op_key,
	    crd->crd_len / 16, sc->op_iv, VIAC3_CRYPTOP_CBC);

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		m_copyback((struct mbuf *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else if (crp->crp_flags & CRYPTO_F_IOV)
		cuio_copyback((struct uio *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, sc->op_buf);
	else
		bcopy(sc->op_buf, crp->crp_buf + crd->crd_skip, crd->crd_len);

	/* copy out last block for use as next session IV */
	if (crd->crd_flags & CRD_F_ENCRYPT) {
		if (crp->crp_flags & CRYPTO_F_IMBUF)
			m_copydata((struct mbuf *)crp->crp_buf,
			    crd->crd_skip + crd->crd_len - 16, 16, ses->ses_iv);
		else if (crp->crp_flags & CRYPTO_F_IOV)
			cuio_copydata((struct uio *)crp->crp_buf,
			    crd->crd_skip + crd->crd_len - 16, 16, sc->op_iv);
		else
			bcopy(crp->crp_buf + crd->crd_skip + crd->crd_len - 16,
			    sc->op_iv, 16);
	}

out:
	if (sc->op_buf != NULL) {
		free(sc->op_buf, M_DEVBUF);
		sc->op_buf = NULL;
	}
	crp->crp_etype = err;
	crypto_done(crp);
	return (err);
}

void
viac3_crypto(void *cw, void *src, void *dst, void *key, int rep,
    void *iv, int type)
{
	unsigned int creg0;

	creg0 = rcr0();		/* Permit access to SIMD/FPU path */
	lcr0(creg0 & ~(CR0_EM|CR0_TS));

	/* Do the deed */
	switch (type) {
	case VIAC3_CRYPTOP_RNG:
		__asm __volatile("rep xstore-rng" :
		    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
		    : "memory", "cc");
		break;
	case VIAC3_CRYPTOP_ECB:
		__asm __volatile("pushfl; popfl");
		__asm __volatile("rep xcrypt-ecb" :
		    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
		    : "memory", "cc");
		break;
	case VIAC3_CRYPTOP_CBC:
		__asm __volatile("pushfl; popfl");
		__asm __volatile("rep xcrypt-cbc" :
		    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
		    : "memory", "cc");
		break;
	case VIAC3_CRYPTOP_CFB:
		__asm __volatile("pushfl; popfl");
		__asm __volatile("rep xcrypt-cfb" :
		    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
		    : "memory", "cc");
		break;
	case VIAC3_CRYPTOP_OFB:
		__asm __volatile("pushfl; popfl");
		__asm __volatile("rep xcrypt-ofb" :
		    : "a" (iv), "b" (key), "c" (rep), "d" (cw), "S" (src), "D" (dst)
		    : "memory", "cc");
		break;
	}

	lcr0(creg0);
}

#endif /* CRYPTO */

#endif /* defined(I686_CPU) */
d1107 1
a1108 7
#if !defined(SMALL_KERNEL)
	extern void (*pagezero)(void *, size_t);
	extern void i686_pagezero(void *, size_t);

	pagezero = i686_pagezero;
#endif

d1128 1
a1128 1
		 * C3 Nehemiah:
d1145 3
a1147 14
		/* Enable RNG if present and disabled */
		if (val & 0x44)
			printf("%s:", cpu_device);
		if (val & 0x4) {
			if (!(val & 0x8)) {
				u_int64_t msreg;

				msreg = rdmsr(0x110B);
				msreg |= 0x40;
				wrmsr(0x110B, msreg);
			}
			viac3_rnd_present = 1;
			printf(" RNG");
		}
d1149 8
a1156 12
#ifdef CRYPTO
		/* Enable AES engine if present and disabled */
		if (val & 0x40) {
			if (!(val & 0x80)) {
				u_int64_t msreg;

				msreg = rdmsr(0x1107);
				msreg |= (0x01 << 28);
				wrmsr(0x1107, msreg);
			}
			viac3_crypto_present = 1;
			printf(" AES");
d1158 2
a1159 3
#endif /* CRYPTO */

		printf("\n");
a1200 13
#if defined(I586_CPU) || defined(I686_CPU)
void	natsem6x86_cpureset(void);

void
natsem6x86_cpureset(void)
{
	/* reset control SC1100 (datasheet page 170) */
	outl(0xCF8, 0x80009044UL);
	/* system wide reset */
	outb(0xCFC, 0x0F);
}
#endif

a1209 6
	switch (model) {
	case 4:
		cpu_feature &= ~CPUID_TSC;
		break;
	}
	cpuresetfn = natsem6x86_cpureset;
a1212 1

d1231 1
a1231 1
	case 0:		/* AMD-K5 Model 0 */
a1248 17
amd_family6_setup(cpu_device, model, step)
	const char *cpu_device;
	int model, step;
{
#if !defined(SMALL_KERNEL) && defined (I686_CPU)
	extern void (*pagezero)(void *, size_t);
	extern void sse2_pagezero(void *, size_t);
	extern void i686_pagezero(void *, size_t);

	if (cpu_feature & CPUID_SSE2)
		pagezero = sse2_pagezero;
	else
		pagezero = i686_pagezero;
#endif
}

void
d1254 2
a1255 2
  	/* XXX SMP int model = (ci->ci_signature >> 4) & 15; */
	/* XXX SMP int step = ci->ci_signature & 15; */
d1257 8
d1271 1
a1271 7
		ci->ci_feature_flags &= ~CPUID_SEP;

	/*
	 * Make sure SYSENTER is disabled.
	 */
	if (cpu_feature & CPUID_SEP)
		wrmsr(MSR_SYSENTER_CS, 0);
d1277 3
a1279 3
		msr119 = rdmsr(MSR_BBL_CR_CTL);
		msr119 |= 0x0000000000200000LL;
		wrmsr(MSR_BBL_CR_CTL, msr119);
d1286 2
a1287 23
#if !defined(SMALL_KERNEL) && defined (I686_CPU)
	if (cpu_ecxfeature & CPUIDECX_EST) {
		if (rdmsr(MSR_MISC_ENABLE) & (1 << 16))
			est_init(cpu_device);
		else
			 printf("%s: Enhanced SpeedStep disabled by BIOS\n",
			     cpu_device);
	} else if ((cpu_feature & (CPUID_ACPI | CPUID_TM)) ==
	    (CPUID_ACPI | CPUID_TM))
		p4tcc_init(model, step);

	{
	extern void (*pagezero)(void *, size_t);
	extern void sse2_pagezero(void *, size_t);
	extern void i686_pagezero(void *, size_t);

	if (cpu_feature & CPUID_SSE2)
		pagezero = sse2_pagezero;
	else
		pagezero = i686_pagezero;
	pagezero = bzero;
	}
#endif
d1295 4
a1298 2
#if !defined(SMALL_KERNEL) && defined (I586_CPU)
	longrun_init();
d1356 7
a1597 20
char *
tm86_cpu_name(model)
	int model;
{
	u_int32_t regs[4];
	char *name = NULL;

	cpuid(0x80860001, regs);

	switch(model) {
	case 4:
		if (((regs[1] >> 16) & 0xff) >= 0x3)
			name = "TMS5800";
		else 
			name = "TMS5600";
	}

	return name;
}

a1601 1
	extern char cpu_brandstr[];
d1603 2
a1615 2
	char *brandstr_from, *brandstr_to;
	int skipspace;
d1675 1
a1675 6
			/*
			 * Special hack for the VIA C3 series.
			 *
			 * VIA bought Centaur Technology from IDT in Aug 1999
			 * and marketed the processors as VIA Cyrix III/C3.
			 */
d1694 1
a1694 1
				   model == 7) {
a1695 4
			/* Special hack for the TMS5x00 series. */
			} else if (vendor == CPUVENDOR_TRANSMETA && 
				  family == 5 && model == 4) {
				name = tm86_cpu_name(model);
a1716 19
	/* Remove leading and duplicated spaces from cpu_brandstr */
	brandstr_from = brandstr_to = cpu_brandstr;
	skipspace = 1;
	while (*brandstr_from != '\0') {
		if (!skipspace || *brandstr_from != ' ') {
			skipspace = 0;
			*(brandstr_to++) = *brandstr_from;
		}
		if (*brandstr_from == ' ')
			skipspace = 1;
		brandstr_from++;
	}
	*brandstr_to = '\0';

	if (cpu_brandstr[0] == '\0') {
		snprintf(cpu_brandstr, 48 /* sizeof(cpu_brandstr) */,
		    "%s %s%s", vendorname, modifier, name);
	}

d1719 2
a1720 2
		    "%s (%s%s%s%s-class, %dKB L2 cache)",
		    cpu_brandstr,
d1725 2
a1726 2
		    "%s (%s%s%s%s-class)",
		    cpu_brandstr,
d1731 4
d1738 1
a1738 1
	if (cpu_feature & CPUID_TSC) {			/* Has TSC */
a1780 4
	/* configure the CPU if needed */
	if (cpu_setup != NULL)
		cpu_setup(cpu_device, model, step);

a1845 24

#if defined(I686_CPU)
	/*
	 * If we have FXSAVE/FXRESTOR, use them.
	 */
	if (cpu_feature & CPUID_FXSR) {
		i386_use_fxsave = 1;
		lcr4(rcr4() | CR4_OSFXSR);

		/*
		 * If we have SSE/SSE2, enable XMM exceptions, and
		 * notify userland.
		 */
		if (cpu_feature & (CPUID_SSE|CPUID_SSE2)) {
			if (cpu_feature & CPUID_SSE)
				i386_has_sse = 1;
			if (cpu_feature & CPUID_SSE2)
				i386_has_sse2 = 1;
			lcr4(rcr4() | CR4_OSXMMEXCPT);
		}
	} else
		i386_use_fxsave = 0;
#endif /* I686_CPU */

d2360 2
a2361 1
	pmap_ldt_cleanup(p);
d2365 1
a2365 5
	if (i386_use_fxsave) {
		pcb->pcb_savefpu.sv_xmm.sv_env.en_cw = __OpenBSD_NPXCW__;
		pcb->pcb_savefpu.sv_xmm.sv_env.en_mxcsr = __INITIAL_MXCSR__;
	} else
		pcb->pcb_savefpu.sv_87.sv_env.en_cw = __OpenBSD_NPXCW__;
a2596 7
	/*
	 * Saving SSE registers won't work if the save area isn't
	 * 16-byte aligned.
	 */
	if (offsetof(struct user, u_pcb.pcb_savefpu) & 0xf)
		panic("init386: pcb_savefpu not 16-byte aligned");

d2600 2
a2601 8
	/*
	 * Boot arguments are in a single page specified by /boot.
	 *
	 * We require the "new" vector form, as well as memory ranges
	 * to be given in bytes rather than KB.
	 */
	if ((bootapiver & (BAPIV_VECTOR | BAPIV_BMEMMAP)) ==
	    (BAPIV_VECTOR | BAPIV_BMEMMAP)) {
d2877 3
a2879 2
	if (cpuresetfn)
		(*cpuresetfn)();
d3031 4
a3034 8
	case CPU_OSFXSR:
		return (sysctl_rdint(oldp, oldlenp, newp, i386_use_fxsave));
	case CPU_SSE:
		return (sysctl_rdint(oldp, oldlenp, newp, i386_has_sse));
	case CPU_SSE2:
		return (sysctl_rdint(oldp, oldlenp, newp, i386_has_sse2));
	case CPU_XCRYPT:
		return (sysctl_rdint(oldp, oldlenp, newp, i386_has_xcrypt));
@


1.124.2.24
log
@Import NetBSD updates to NPX logic, and IPI API
@
text
@a2879 1
#if NNPX > 0
d2881 1
a2881 3
	if (pcb->pcb_fpcpu != NULL)
		npxsave_proc(p, 0);
#endif
@


1.124.2.25
log
@After countless hours of chasing data corruption, I finally
found the missing TLB shootdowns.  And then I see I missed a NetBSD commit
made in 2000 that fixed this! Arrrgh!!!
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.24 2004/02/20 22:19:55 niklas Exp $	*/
a3758 3
#ifdef MULTIPROCESSOR
	u_int32_t cpumask = 0;
#endif
a3787 4
#ifdef MULTIPROCESSOR
			pmap_tlb_shootdown(pmap_kernel(), va, *pte,
			    &cpumask);
#else
a3788 1
#endif
a3790 3
#ifdef MULTIPROCESSOR
	pmap_tlb_shootnow(cpumask);
#endif
@


1.124.2.26
log
@Make a few scheduling globals per-cpu, mostly NetBSD code
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.25 2004/04/21 09:33:08 niklas Exp $	*/
d3458 1
a3458 1
need_resched(struct cpu_info *ci)
d3460 1
@


1.124.2.27
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d104 4
d117 2
a253 2
int p4_model;
int setperf_prio = 0;		/* for concurrent handlers */
a331 1
void	intel686_common_cpu_setup(const char *, int, int);
a332 1
void	intel686_p4_cpu_setup(const char *, int, int);
d337 1
a337 2
int	p4_cpuspeed(int *);
int	pentium_cpuspeed(int *);
a352 1
#endif
d371 1
d791 1
a791 1
			intel686_p4_cpu_setup
a1111 2
	{ CPUIDECX_PNI,		"PNI" },
	{ CPUIDECX_MWAIT,	"MWAIT" },
d1129 1
a1129 1
		printf("%s: TSC disabled\n", curcpu()->ci_dev.dv_xname);
d1135 348
a1536 2
			extern int viac3_rnd_present;

d1548 1
a1550 3
#ifdef CRYPTO
			extern int viac3_crypto_present;

a1558 1
#endif /* CRYPTO */
d1561 1
a1599 1
		printf("%s: TSC disabled\n", cpu_device);
a1629 1
		printf("%s: TSC disabled\n", cpu_device);
a1668 6
	case 12:
	case 13:
#ifndef SMALL_KERNEL
		k6_powernow_init();
#endif
		break;
d1677 1
a1677 1
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
d1690 3
a1692 34
intel686_common_cpu_setup(const char *cpu_device, int model, int step)
{
	/*
	 * Make sure SYSENTER is disabled.
	 */
	if (cpu_feature & CPUID_SEP)
		wrmsr(MSR_SYSENTER_CS, 0);

#if !defined(SMALL_KERNEL) && defined(I686_CPU)
	if (cpu_ecxfeature & CPUIDECX_EST) {
		if (rdmsr(MSR_MISC_ENABLE) & (1 << 16))
			est_init(cpu_device);
		else
			printf("%s: Enhanced SpeedStep disabled by BIOS\n",
			    cpu_device);
	} else if ((cpu_feature & (CPUID_ACPI | CPUID_TM)) ==
	    (CPUID_ACPI | CPUID_TM))
		p4tcc_init(model, step);

	{
	extern void (*pagezero)(void *, size_t);
	extern void sse2_pagezero(void *, size_t);
	extern void i686_pagezero(void *, size_t);

	if (cpu_feature & CPUID_SSE2)
		pagezero = sse2_pagezero;
	else
		pagezero = i686_pagezero;
	}
#endif
}

void
intel686_cpu_setup(const char *cpu_device, int model, int step)
a1698 2
	intel686_common_cpu_setup(cpu_device, model, step);

d1707 6
d1725 10
a1734 1
}
d1736 4
a1739 4
void
intel686_p4_cpu_setup(const char *cpu_device, int model, int step)
{
	intel686_common_cpu_setup(cpu_device, model, step);
d1741 5
a1745 4
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
	if (cpu_cpuspeed == NULL) {
		p4_model = model;
		cpu_cpuspeed = p4_cpuspeed;
d1755 1
a1755 1
#if !defined(SMALL_KERNEL) && defined(I586_CPU)
a2280 7
#ifndef SMALL_KERNEL
#if defined(I586_CPU) || defined(I686_CPU)
	if (cpu_cpuspeed == NULL && pentium_mhz != 0)
		cpu_cpuspeed = pentium_cpuspeed;
#endif
#endif

a2371 53
#ifndef SMALL_KERNEL
#ifdef I686_CPU
int
p4_cpuspeed(int *freq)
{
	u_int64_t msr;
	int bus, mult;

	msr = rdmsr(MSR_EBC_FREQUENCY_ID);
	if (p4_model < 2) {
		bus = (msr >> 21) & 0x7;
		switch (bus) {
		case 0:
			bus = 100;
			break;
		case 1:
			bus = 133;
			break;
		}
	} else {
		bus = (msr >> 16) & 0x7;
		switch (bus) {
		case 0:
			bus = 100;
			break;
		case 1:
			bus = 133;
			break;
		case 2:
			bus = 200;
			break;
		}
	}
	mult = ((msr >> 24) & 0xff);
	*freq = bus * mult;
	/* 133MHz actually means 133.(3)MHz */
	if (bus == 133)
		*freq += mult / 3;

	return (0);
}
#endif	/* I686_CPU */

#if defined(I586_CPU) || defined(I686_CPU)
int
pentium_cpuspeed(int *freq)
{
	*freq = pentium_mhz;
	return (0);
}
#endif
#endif	/* !SMALL_KERNEL */

d2594 1
a2594 6
		/*
		 * If the system is cold, just halt, unless the user
		 * explicitly asked for reboot.
		 */
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
a3757 1
	bus_size_t map_size;
d3766 1
a3766 1
	if (endpa <= pa && endpa != 0)
d3770 1
a3770 3
	map_size = endpa - pa;

	va = uvm_km_valloc(kernel_map, map_size);
d3776 1
a3776 2
	for (; map_size > 0;
	    pa += PAGE_SIZE, va += PAGE_SIZE, map_size -= PAGE_SIZE) {
a3854 41
void
_bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh, bus_size_t size,
    bus_addr_t *adrp)
{
	u_long va, endva;
	bus_addr_t bpa;

	/*
	 * Find the correct bus physical address.
	 */
	if (t == I386_BUS_SPACE_IO) {
		bpa = bsh;
	} else if (t == I386_BUS_SPACE_MEM) {
		bpa = (bus_addr_t)ISA_PHYSADDR(bsh);
		if (IOM_BEGIN <= bpa && bpa <= IOM_END)
			goto ok;

		va = i386_trunc_page(bsh);
		endva = i386_round_page(bsh + size);

#ifdef DIAGNOSTIC
		if (endva <= va)
			panic("_bus_space_unmap: overflow");
#endif

		(void) pmap_extract(pmap_kernel(), va, &bpa);
		bpa += (bsh & PGOFSET);

		/*
		 * Free the kernel virtual mapping.
		 */
		uvm_km_free(kernel_map, va, endva - va);
	} else
		panic("bus_space_unmap: bad bus space tag");

ok:
	if (adrp != NULL) {
		*adrp = bpa;
	}
}

d4515 2
a4516 55
#if 0
/*
 * Software interrupt registration
 *
 * We hand-code this to ensure that it's atomic.
 */
void
softintr(mask)
	int mask;
{
	__asm __volatile("orl %1, %0" : "=m"(ipending) : "ir" (mask));

}

/*
 * Raise current interrupt priority level, and return the old one.
 */
int
splraise(ncpl)
	int ncpl;
{
	int ocpl = cpl;

	if (ncpl > ocpl)
		cpl = ncpl;
	return (ocpl);
}

/*
 * Restore an old interrupt priority level.  If any thereby unmasked
 * interrupts are pending, call Xspllower() to process them.
 */
void
splx(ncpl)
	int ncpl;
{
	cpl = ncpl;
	if (ipending & IUNMASK(ncpl))
		Xspllower();
}

/*
 * Same as splx(), but we return the old value of spl, for the
 * benefit of some splsoftclock() callers.
 */
int
spllower(ncpl)
	int ncpl;
{
	int ocpl = cpl;

	splx(ncpl);
	return (ocpl);
}
#endif
@


1.124.2.28
log
@spl outlining
@
text
@d4307 1
d4314 2
a4315 3
softintr(sir, vec)
	int sir;
	int vec;
d4317 2
a4318 5
	__asm __volatile("orl %1, %0" : "=m" (ipending) : "ir" (sir));
#ifdef MULTIPROCESSOR
	i82489_writereg(LAPIC_ICRLO,
	    vec | LAPIC_DLMODE_FIXED | LAPIC_LVL_ASSERT | LAPIC_DEST_SELF);
#endif
d4328 1
a4328 1
	int ocpl = lapic_tpr;
d4331 1
a4331 1
		lapic_tpr = ncpl;
d4343 1
a4343 1
	lapic_tpr = ncpl;
d4356 1
a4356 1
	int ocpl = lapic_tpr;
d4361 1
a4361 1

@


1.124.2.29
log
@sync to head
@
text
@a248 1
int p3_step;
a253 1
void (*update_cpuspeed)(void) = NULL;
d335 1
a335 2
void	p4_update_cpuspeed(void);
void	p3_update_cpuspeed(void);
a1416 6

#if !defined(SMALL_KERNEL) && defined(I686_CPU)
	p3_step = step;
	update_cpuspeed = p3_update_cpuspeed;
	update_cpuspeed();
#endif
d1425 4
a1428 3
	p4_model = model;
	update_cpuspeed = p4_update_cpuspeed;
	update_cpuspeed();
d1965 1
a1965 1
	if (pentium_mhz != 0)
d2063 2
a2064 2
void
p4_update_cpuspeed(void)
d2067 1
a2067 1
	int bus, mult, freq;
d2095 1
a2095 1
	freq = bus * mult;
d2098 1
a2098 31
		freq += mult / 3;

	pentium_mhz = freq;
}

void
p3_update_cpuspeed(void)
{
	u_int64_t msr;
	int bus, mult;
	const u_int8_t mult_code[] = {
	    50, 30, 40, 0, 55, 35, 45, 0, 0, 70, 80, 60, 0, 75, 0, 65 };

	msr = rdmsr(MSR_EBL_CR_POWERON);
	bus = (msr >> 18) & 0x3;
	switch (bus) {
	case 0:
		bus = 66;
		break;
	case 1:
		bus = 133;
		break;
	case 2:
		bus = 100;
		break;
	}

	mult = (msr >> 22) & 0xf;
	mult = mult_code[mult];
	if (p3_step > 1)
		mult += ((msr >> 27) & 0x1) * 40;
d2100 1
a2100 1
	pentium_mhz = (bus * mult) / 10;
@


1.124.2.30
log
@Move SMP-only code under MULTIPROCESSOR, more space for install media.

ok niklas@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.29 2004/06/07 20:41:09 niklas Exp $	*/
a487 1
#ifdef MULTIPROCESSOR
a503 1
#endif	/* MULTIPROCESSOR */
a2814 1
#ifdef MULTIPROCESSOR
a2821 1
#endif	/* MULTIPROCESSOR */
d3248 1
a3275 1
#endif	/* MULTIPROCESSOR */
@


1.124.2.31
log
@UP machines don't need identifycpu(), old_identifycpu() is enough.
XXX: of course both should be merged later.

ok niklas@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.30 2004/06/08 21:38:02 grange Exp $	*/
a1509 2
/* XXXSMP: must be shared with UP */
#ifdef MULTIPROCESSOR
a1739 1
#endif	/* MULTIPROCESSOR */
@


1.124.2.32
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1426 1
d1438 1
d3248 1
a3255 1
#ifdef MULTIPROCESSOR
@


1.124.2.33
log
@Don't install F00F workaround twice, should fix pb's machine.
Idea from mickey.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.32 2004/06/10 11:40:24 niklas Exp $	*/
d1307 3
a1309 5
	if (!cpu_f00f_bug) {
		fix_f00f();
		printf("%s: F00F bug workaround installed\n", 
		    curcpu()->ci_dev.dv_xname);
	}
@


1.124.2.34
log
@pretty print in dmesg -- when it is easier on the eyes glaring problems
jump out; art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.33 2004/06/10 20:38:43 grange Exp $	*/
d1630 13
a1642 14
	if ((ci->ci_flags & CPUF_BSP) == 0) {
		if (cachesize > -1) {
			snprintf(cpu_model, sizeof(cpu_model),
				"%s %s%s (%s%s%s%s-class, %dKB L2 cache)",
				vendorname, modifier, name,
				((*token) ? "\"" : ""), ((*token) ? token : ""),
				((*token) ? "\" " : ""), classnames[class], cachesize);
		} else {
			snprintf(cpu_model, sizeof(cpu_model),
				"%s %s%s (%s%s%s%s-class)",
				vendorname, modifier, name,
				((*token) ? "\"" : ""), ((*token) ? token : ""),
				((*token) ? "\" " : ""), classnames[class]);
		}
d1644 1
a1644 2
		printf("%s: %s", cpu_device, cpu_model);
	}
d1655 6
a1660 11
			if ((ci->ci_flags & CPUF_BSP) == 0) {
				if (fr)
					printf(" %d.%02d GHz", ghz, fr);
				else
					printf(" %d GHz", ghz);
			}
		} else {
			if ((ci->ci_flags & CPUF_BSP) == 0) {
				printf(" %d MHz", pentium_mhz);
			}
		}
d1663 4
a1666 2
	if ((ci->ci_flags & CPUF_BSP) == 0) {
		printf("\n");
d1668 9
a1676 13
		if (ci->ci_feature_flags) {
			int numbits = 0;
	
			printf("%s: ", cpu_device);
			max = sizeof(i386_cpuid_features)
				/ sizeof(i386_cpuid_features[0]);
			for (i = 0; i < max; i++) {
				if (ci->ci_feature_flags & 
				    i386_cpuid_features[i].feature_bit) {
					printf("%s%s", (numbits == 0 ? "" : ","),
					    i386_cpuid_features[i].feature_name);
					numbits++;
				}
a1677 1
			printf("\n");
d1679 1
@


1.124.2.35
log
@un__Pee
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.124.2.34 2004/06/13 07:31:56 deraadt Exp $	*/
d252 3
a254 3
void (*delay_func)(int) = i8254_delay;
void (*microtime_func)(struct timeval *) = i8254_microtime;
void (*initclock_func)(void) = i8254_initclocks;
d1542 1
a1542 1
	/* XXX SMP XXX void (*cpu_setup)(const char *, int, int); */
d3281 1
a3281 1
idt_vec_set(int vec, void (*function)(void))
@


1.123
log
@Prevent overflow in computation of buffer cache limitation
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.122 2000/01/29 21:41:49 mickey Exp $	*/
d173 2
d2044 3
a2046 3
			physmem += btoc(e - a);
			dumpmem[i].start = btoc(a);
			dumpmem[i].end = btoc(e);
d2057 1
a2057 1
	if (physmem < btoc(4 * 1024 * 1024)) {
d2067 1
a2067 1
		register int32_t a, e;
d2071 2
a2072 2
		if (a < btoc(first_avail) && e > btoc(first_avail))
			a = btoc(first_avail);
d2075 11
d2087 1
a2087 1
		printf (" %x-%x", a, e);
d2089 10
a2098 6
		if (a < e) {
#ifdef UVM
			if (e <= 16 * 1024 * 1024)
				uvm_page_physload(a, e, a, e, VM_FREELIST_FIRST16);
			else
				uvm_page_physload(a, e, a, e, VM_FREELIST_DEFAULT);
@


1.122
log
@get usage of memory maps supplied from /boot.
gives two immidiate advances: memory holes support (two
best known are 640k-1M and 15M-16M), and bizaare apm segments placements.
/boot must be at least from 2.5 (well, some earlier might work too ;)
also, allows usage of new libkvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.121 2000/01/15 08:59:25 deraadt Exp $	*/
d506 2
a507 2
	if (nbuf * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 10)
@


1.121
log
@P3 id 8 is Coppermine; thanks maja for testing on your sweet sweet box
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.120 1999/11/27 04:22:08 deraadt Exp $	*/
d103 2
d211 14
a224 2
int	dumpmem_low;
int	dumpmem_high;
d231 1
a240 3
extern	vm_offset_t avail_start, avail_end;
vm_offset_t hole_start, hole_end;

d264 1
a271 3
extern u_int cnvmem;	/* BIOS's conventional memory size */
extern u_int extmem;	/* BIOS's extended memory size */

d317 1
a319 1
	/* avail_end was pre-decremented in pmap_bootstrap to compensate */
a327 12
	/* Boot arguments are in page 1 */
	if (bootapiver & BAPIV_VECTOR) {
		pa = (vm_offset_t)bootargv;
		for (i = 0; i < btoc(bootargc); i++, pa += NBPG)
			pmap_enter(pmap_kernel(),
			    (vm_offset_t)((caddr_t)bootargp + i * NBPG), pa,
			    VM_PROT_READ|VM_PROT_WRITE, TRUE,
			    VM_PROT_READ|VM_PROT_WRITE);
		bios_getopt();
	} else
		panic("/boot is too old: upgrade");

a331 2
	printf("BIOS mem  = %ld conventional, %ld extended\n",
		1024 * cnvmem, 1024 * extmem);
d1529 2
a1551 7
 * These variables are needed by /sbin/savecore
 */
u_long	dumpmag = 0x8fca0101;	/* magic number */
int 	dumpsize = 0;		/* pages */
long	dumplo = 0; 		/* blocks */

/*
d1562 1
a1562 1
	int maj;
a1574 2
	dumpsize = btoc(IOM_END + ctob(dumpmem_high));

d1579 3
d1590 23
a1616 1
#define BYTES_PER_DUMP  NBPG	/* must be a multiple of pagesize XXX small */
d1625 1
a1625 1
	return (p + BYTES_PER_DUMP);
d1631 2
a1632 2
	unsigned bytes, i, n;
	int maddr, psize;
d1636 4
d1655 1
a1655 1
	psize = (*bdevsw[major(dumpdev)].d_psize)(dumpdev);
d1657 1
a1657 1
	if (psize == -1) {
d1667 1
a1667 3
	bytes = ctob(dumpmem_high) + IOM_END;
	maddr = 0;
	blkno = dumplo;
d1669 2
a1670 12
	error = 0;
	for (i = 0; i < bytes; i += n) {
		/*
		 * Avoid dumping the ISA memory hole, and areas that
		 * BIOS claims aren't in low memory.
		 */
		if (i >= ctob(dumpmem_low) && i < IOM_END) {
			n = IOM_END - i;
			maddr += n;
			blkno += btodb(n);
			continue;
		}
d1672 20
a1691 15
		/* Print out how many MBs we to go. */
		n = bytes - i;
		if (n && (n % (1024*1024)) == 0)
			printf("%d ", n / (1024 * 1024));

		/* Limit size for next transfer. */
		if (n > BYTES_PER_DUMP)
			n =  BYTES_PER_DUMP;

		(void) pmap_map(dumpspace, maddr, maddr + n, VM_PROT_READ);
		error = (*dump)(dumpdev, blkno, (caddr_t)dumpspace, n);
		if (error)
			break;
		maddr += n;
		blkno += btodb(n);			/* XXX? */
d1694 6
a1699 4
		/* operator aborting dump? */
		if (sget() != NULL) {
			error = EINTR;
			break;
a1700 1
#endif
d1705 9
a1713 23
	case ENXIO:
		printf("device bad\n");
		break;

	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	case EINTR:
		printf("aborted from console\n");
		break;

	case 0:
		printf("succeeded\n");
		break;
a1714 5
	default:
		printf("error %d\n", error);
		break;
	}
	printf("\n\n");
d1721 1
a1721 1
 * /sys/i386/i386/microtime.s is used.  The other code only works
a1896 1
	u_int cm, em;
d1898 1
a1898 1
	extern void consinit __P((void));
d1921 1
d1974 24
a1997 3
#ifdef EXTMEM_SIZE
	/* Override memory size */
	extmem = EXTMEM_SIZE;
d2001 2
a2002 2
	 * BIOS leaves data in low memory and VM system doesn't work with
	 * phys 0,  /boot leaves arguments at page 1.
d2004 47
a2050 4
	avail_start = bootapiver & BAPIV_VECTOR?
		i386_round_page(bootargv+bootargc): NBPG;
	avail_end = extmem ? IOM_END + extmem * 1024
		: cnvmem * 1024;	/* just temporary use */
d2052 7
a2058 8
	/*
	 * Allocate the physical addresses used by RAM from the iomem
	 * extent map.  This is done before the addresses are
	 * page rounded just to make sure we get them all.
	 */
	if (extent_alloc_region(iomem_ex, avail_start, IOM_BEGIN, EX_NOWAIT)) {
		/* XXX What should we do? */
		printf("WARNING: CAN'T ALLOCATE BASE RAM FROM IOMEM EXTENT MAP!\n");
d2061 25
a2085 4
	if (avail_end > IOM_END && extent_alloc_region(iomem_ex, IOM_END,
	    (avail_end - IOM_END), EX_NOWAIT)) {
		/* XXX What should we do? */
		printf("WARNING: CAN'T ALLOCATE EXTENDED MEMORY FROM IOMEM EXTENT MAP!\n");
d2087 5
a2091 1

d2110 1
a2110 26

	/* Round down to whole pages. */
	cm = i386_round_page(cnvmem * 1024);
	em = i386_round_page(extmem * 1024);

	/* number of pages of physmem addr space */
	physmem = btoc(cm + em);
	dumpmem_low = btoc(cm);
	dumpmem_high = btoc(em);

	/*
	 * Initialize for pmap_free_pages and pmap_next_page.
	 * These guys should be page-aligned.
	 * We load right after the I/O hole; adjust hole_end to compensate.
	 */
	hole_start = cm;
	hole_end = round_page(first_avail);

	if (physmem < btoc(2 * 1024 * 1024)) {
		printf("\awarning: too little memory available;"
		       "running in degraded mode\npress a key to confirm\n\n");
		cngetc();
	}

	/* call pmap initialization to make new kernel address space */
	pmap_bootstrap((vm_offset_t)atdevbase + IOM_SIZE);
d2350 5
d2507 4
@


1.120
log
@Winchip c6 TSC is broken; wd@@ics.nara-wu.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.119 1999/11/01 20:51:11 deraadt Exp $	*/
d718 2
a719 1
				"Pentium III", 0, 0, 0, 0, 0, 0, 0, 0,
@


1.119
log
@add it back in
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.117 1999/11/01 17:15:08 art Exp $	*/
d270 1
d820 1
a820 1
			NULL
d895 17
@


1.118
log
@remove mickey code to avoid branching
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.115 1999/10/14 20:09:09 niklas Exp $	*/
d318 1
a318 1
	if (bootapiver >= 2) {
d325 1
d327 1
a327 1
		bootargp = NULL;
@


1.117
log
@setup_buffers: If the allocation of saved_pgs failed 'left' would be
uninitialized and we wouldn't know how much memory to allocate for buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.116 1999/10/26 18:16:48 mickey Exp $	*/
d318 1
a318 1
	if (bootapiver & BAPIV_VECTOR) {
a324 1
		bios_getopt();
d326 1
a326 1
		panic("/boot is too old: upgrade");
@


1.116
log
@modify bootapiver chekups to use bitwise operations.
factor out /boot options parser from biosattach().
add logic to warn about ancient /boots.
cleanup vanishing cruft.
@@niklas ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.115 1999/10/14 20:09:09 niklas Exp $	*/
d584 2
@


1.115
log
@A fix for the dreaded isadmaattach panic.  The reason was actually quite
obscure, many, many thanks to art@@ for finding my bug, which only hit people
having about 2300-2500 pages in the buffercache.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.114 1999/09/30 04:00:42 downsj Exp $	*/
d318 1
a318 1
	if (bootapiver >= 2) {
d325 1
d327 1
a327 1
		bootargp = NULL;
@


1.114
log
@Make sure 'model' and 'step' are initialized, even for non-cpuid chips.
Fix Cyrix setup to do it's thing for non-cpuid M1 processors.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.113 1999/09/03 18:00:50 art Exp $	*/
d171 17
d535 3
a537 3
	int base, residual, left, i;
	struct pglist pgs, freepgs;
	vm_page_t pg, *last, *last2;
d572 10
a581 4
	 * The current strategy is to grab hold of 2MB chunks at a time as long
	 * as they fit below 16MB, and as soon as that fail, give back the
	 * last one and allocate the rest above 16MB.  That should guarantee
	 * at least 2MB below 16MB left for DMA buffers.
d583 6
d590 10
a599 27
	last = last2 = 0;
	addr = 0;
	for (left = bufpages; left > 2 * 1024 * 1024 / CLBYTES;
	    left -= 2 * 1024 * 1024 / CLBYTES) {
#if defined(UVM)
		if (uvm_pglistalloc(2 * 1024 * 1024, 0, 16 * 1024 * 1024,
		    CLBYTES, 0, &pgs, 1, 0)) {
#else
		if (vm_page_alloc_memory(2 * 1024 * 1024, 0, 16 * 1024 * 1024,
		    CLBYTES, 0, &pgs, 1, 0)) {
#endif
			if (last2) {
				TAILQ_INIT(&freepgs);
				freepgs.tqh_first = *last2;
				freepgs.tqh_last = pgs.tqh_last;
				(*last2)->pageq.tqe_prev = &freepgs.tqh_first;
				pgs.tqh_last = last2;
				*last2 = NULL;
#if defined(UVM)
				uvm_pglistfree(&freepgs);
#else
				vm_page_free_memory(&freepgs);
#endif
				left += 2 * 1024 * 1024 / CLBYTES;
				addr = 16 * 1024 * 1024;
			}
			break;
a600 2
		last2 = last ? last : &pgs.tqh_first;
		last = pgs.tqh_last;
d602 13
a614 9
	if (left > 0)
#if defined(UVM)
		if (uvm_pglistalloc(left * CLBYTES, addr, avail_end,
		    CLBYTES, 0, &pgs, 1, 0))
#else
		if (vm_page_alloc_memory(left * CLBYTES, addr, avail_end,
		    CLBYTES, 0, &pgs, 1, 0))
#endif
			panic("cannot get physical memory for buffer cache");
@


1.113
log
@Change the pmap_enter api to pass down an argument that indicates
the access type that caused this mapping. This is to simplify pmaps
with mod/ref emulation (none for the moment) and in some cases speed
up pmap_is_{referenced,modified}.
At the same time, clean up some mappings that had too high protection.

XXX - the access type is incorrect in old vm, it's only used by uvm and MD code.
The actual use of this in pmap_enter implementations is not in this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.112 1999/08/20 10:33:34 deraadt Exp $	*/
d887 1
d1030 2
@


1.112
log
@teach it about Rise cpus; wd@@ics.nara-wu.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.111 1999/08/12 07:25:12 deraadt Exp $	*/
d294 4
a297 2
		    (vm_offset_t)((caddr_t)msgbufp + i * NBPG),
		    pa, VM_PROT_ALL, TRUE);
d305 3
a307 2
			    (vm_offset_t)((caddr_t)bootargp + i * NBPG),
			    pa, VM_PROT_READ|VM_PROT_WRITE, TRUE);
d615 2
a616 1
			    VM_PROT_READ|VM_PROT_WRITE, TRUE);
d2375 2
a2376 1
		    VM_PROT_READ | VM_PROT_WRITE, TRUE);
d2783 2
a2784 1
			    VM_PROT_READ | VM_PROT_WRITE, TRUE);
@


1.111
log
@IDT WinChip models; wd@@ics.nara-wu.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.110 1999/08/04 23:17:40 niklas Exp $	*/
d679 5
a683 3
				0, "Pentium", "Pentium (P54C)",
				"Pentium (P24T)", "Pentium/MMX", "Pentium", 0,
				"Pentium (P54C)", 0, 0, 0, 0, 0, 0, 0, 0,
d692 4
a695 2
				0, "Pentium Pro", 0, "Pentium II",
				"Pentium Pro", "Pentium II", "Celeron",
d730 1
a730 1
		/* Family 6, not yet available from AMD */
d734 1
a734 1
				0, 0, 0, 0, 0, 0, 0,
d736 1
a736 1
				"686 class"		/* Default */
d801 35
@


1.110
log
@Match bus_dma api with NetBSD; deprecate BUS_DMAMEM_NOSYNC, introduce
BUS_DMA_COHERENT as a hint instead, currently ignored.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.109 1999/07/06 07:59:54 deraadt Exp $	*/
d768 35
@


1.109
log
@for CTRL-ALT-DEL, send SIGUSR1 to initproc
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.108 1999/06/04 16:37:47 mickey Exp $	*/
a2704 6
#if 0
			if (flags & BUS_DMAMEM_NOSYNC)
				pmap_changebit(addr, PG_N, ~0);
			else
				pmap_changebit(addr, 0, ~PG_N);
#endif
@


1.108
log
@remove old MN code, which is not in use anymore, MNN been running for
a year already, and upcoming new apm stuff is not compatible w/ the old MN.
niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.107 1999/05/22 21:22:23 weingart Exp $	*/
d212 2
d2120 7
@


1.107
log
@Add new vm_swap code for dynamic swap.  From netbsd, munged some by me, and
others.   syscall commit pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.106 1999/05/09 15:09:04 mickey Exp $	*/
a210 3
#if !defined(MACHINE_NEW_NONCONTIG)
static	vm_offset_t avail_next;
#endif
a1870 3
#if !defined(MACHINE_NEW_NONCONTIG)
	avail_next =
#endif
a1936 7
#if !defined(MACHINE_NEW_NONCONTIG)
	/*
	 * Initialize for pmap_free_pages and pmap_next_page
	 */
	avail_next = avail_start;
#endif

a2000 41

#if !defined(MACHINE_NEW_NONCONTIG)
u_int
pmap_free_pages()
{

	if (avail_next <= hole_start)
		return ((hole_start - avail_next) / NBPG +
			(avail_end - hole_end) / NBPG);
	else
		return ((avail_end - avail_next) / NBPG);
}

int
pmap_next_page(addrp)
	vm_offset_t *addrp;
{

	if (avail_next + NBPG > avail_end)
		return FALSE;

	if (avail_next + NBPG > hole_start && avail_next < hole_end)
		avail_next = hole_end;

	*addrp = avail_next;
	avail_next += NBPG;
	return TRUE;
}

int
pmap_page_index(pa)
	vm_offset_t pa;
{

	if (pa >= avail_start && pa < hole_start)
		return i386_btop(pa - avail_start);
	if (pa >= hole_end && pa < avail_end)
		return i386_btop(pa - hole_end + hole_start - avail_start);
	return -1;
}
#endif
@


1.106
log
@provide suport for an apm data segemnt in the lower memory bios
data segment area, also calculate the apm segment lenghts.
niklas@@ - ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.105 1999/03/16 08:34:40 deraadt Exp $	*/
a449 1
	valloc(swapmap, struct map, nswapmap = maxproc * 2);
@


1.105
log
@K6-3
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.104 1999/03/09 05:00:40 downsj Exp $	*/
a1871 10
	 * Allocate the physical addresses used by RAM from the iomem
	 * extent map.  This is done before the addresses are
	 * page rounded just to make sure we get them all.
	 */
	if (extent_alloc_region(iomem_ex, 0, IOM_BEGIN, EX_NOWAIT)) {
		/* XXX What should we do? */
		printf("WARNING: CAN'T ALLOCATE BASE RAM FROM IOMEM EXTENT MAP!\n");
	}

	/*
d1878 2
a1879 1
	avail_start = bootapiver >= 2? i386_round_page(bootargv+bootargc): NBPG;
d1882 10
@


1.104
log
@Add support for disabling the processor serial number on the P3.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.103 1999/03/08 23:47:26 downsj Exp $	*/
d723 1
a723 1
				"K6", "K6-2", "K6-2", 0, 0, 0, 0, 0, 0,
@


1.103
log
@Add support for CPUID level 2.  This is used to determine the L2 cache size
on Intel processors; print out the correct CPU name and cache size at boot.

Also clean up the feature flags, including PPro errata.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.102 1999/02/26 04:41:13 art Exp $	*/
d851 10
a860 1
	extern int cpu_feature;
d868 15
@


1.102
log
@some allocation changes, name changes, etc for uvm
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.101 1999/02/25 21:17:22 mickey Exp $	*/
d254 4
a257 2
void	cyrix6x86_cpu_setup __P((const char *, int));
void	intel586_cpu_setup __P((const char *, int));
d693 1
a693 1
				"Pentium Pro", "Pentium II", "Pentium II",
d697 1
a697 1
			NULL
d793 3
d797 3
a799 3
	{ CPUID_EMMX,	"EMMX" },
	{ CPUID_3D,	"AMD3D" },
	{ CPUID_MMX2,	"MMX2" }
d803 1
a803 1
cyrix6x86_cpu_setup(cpu_device, model)
d805 1
a805 1
	int model;
d836 1
a836 1
intel586_cpu_setup(cpu_device, model)
d838 1
a838 1
	int model;
d847 56
d908 5
d916 1
a916 1
	int family, model, step, modif;
d918 1
a918 1
	void (*cpu_setup) __P((const char *, int));
d944 3
d981 7
a987 1
			name = cpup->cpu_family[i].cpu_models[model];
d995 21
a1015 6
	if (*token)
		sprintf(cpu_model, "%s %s%s (\"%s\" %s-class)", vendorname,
			modifier, name, token, classnames[class]);
	else
		sprintf(cpu_model, "%s %s%s (%s-class)", vendorname, modifier,
			name, classnames[class]);
d1019 1
a1019 1
		cpu_setup(cpu_device, model);
@


1.101
log
@fix /boot arguments mapping.
now fully trust bootargv value passed from the /boot
towards where in the physical memory they are located.
adjust available memory accordingly.
there is a mail coming into misc@@ about this patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.100 1999/02/24 22:05:13 deraadt Exp $	*/
d120 4
d200 6
d207 1
d320 3
d324 1
d339 4
d345 1
d350 4
d356 1
d365 4
d371 1
d380 3
d384 1
d502 1
d504 1
d520 8
d534 1
d562 4
d568 1
d576 3
d580 1
d590 4
d596 1
d1642 3
d1646 1
d2216 3
d2220 1
d2272 3
d2276 1
d2593 3
d2597 1
d2618 3
d2622 1
d2665 3
d2669 1
d2738 4
d2744 1
@


1.100
log
@pIII handling; testing by jdb@@layer8.net
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.99 1999/02/23 21:18:27 marc Exp $	*/
d288 1
a288 1
		pa = NBPG;
d1711 1
a1711 1
	avail_start = bootapiver >= 2 ? NBPG + i386_round_page(bootargc) : NBPG;
@


1.99
log
@Make ampwarn access conditional upon NAPM so kernels that do
not define the apm device build again (sorry)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.98 1999/02/23 04:10:12 marc Exp $	*/
d633 1
a633 1
				0, 0, 0, 0, 0, 0, 0, 0, 0,
d734 2
a735 1
	{ CPUID_3D,	"AMD3D" }
@


1.98
log
@apm battery status messages now suppressed until battery life
falls below 'machdep.apmwarn' percent.  This defaults to 10 percent
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.97 1999/01/11 05:11:24 millert Exp $	*/
d1943 1
d1945 1
d1990 1
d1993 1
@


1.97
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.96 1999/01/06 01:31:20 kstailey Exp $	*/
d1943 1
d1988 2
@


1.96
log
@fix for "halt -p" and BIOS goes "no disk drives"
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.95 1998/12/28 11:03:57 downsj Exp $	*/
d798 1
a798 1
			panic("unknown cpu type %d\n", cpu);
@


1.95
log
@Small hack to pass out VM86 traps using a siginfo field.
(There is no other way in our kernel.)

VM86 applications must use real sigaction handlers with SA_SIGINFO in order
to get their traps.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.94 1998/09/28 05:13:13 downsj Exp $	*/
d1232 2
d1244 2
a1245 2
			if (apm_set_powstate(APM_DEV_DISK(0xff),
					     APM_SYS_OFF) == 0) {
@


1.94
log
@Avoid a really stupid APM-related panic.

Someone who knows about this crap should figure out why calling
apm_set_powstate() after it's already failed once causes a vm_fault() crash.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.93 1998/08/30 07:30:13 downsj Exp $	*/
d1068 4
@


1.93
log
@Rearrange cpu_setup call and add an extra argument in order to cope with
MediaGXm problems.  For now, this unsets the TSC bit in the cpuid output.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.92 1998/08/17 18:15:02 csapuntz Exp $	*/
d1233 3
d1238 6
a1243 3
			apm_set_powstate(APM_DEV_DISK(0xff), APM_SYS_OFF);
			delay(500000);
			apm_set_powstate(APM_DEV_ALLDEVS, APM_SYS_OFF);
@


1.92
log
@

Fix i386 kernel crash so that register context is saved in a better place.
@
text
@d243 2
a244 2
void	cyrix6x86_cpu_setup __P((const char *));
void	intel586_cpu_setup __P((const char *));
d738 1
a738 1
cyrix6x86_cpu_setup(cpu_device)
d740 1
d743 1
a743 12
	/* set up various cyrix registers */
	/* Enable suspend on halt */
	cyrix_write_reg(0xc2, cyrix_read_reg(0xc2) | 0x08);
	/* enable access to ccr4/ccr5 */
	cyrix_write_reg(0xC3, cyrix_read_reg(0xC3) | 0x10);
	/* cyrix's workaround  for the "coma bug" */
	cyrix_write_reg(0x31, cyrix_read_reg(0x31) | 0xf8);
	cyrix_write_reg(0x32, cyrix_read_reg(0x32) | 0x7f);
	cyrix_write_reg(0x33, cyrix_read_reg(0x33) & ~0xff);
	cyrix_write_reg(0x3c, cyrix_read_reg(0x3c) | 0x87);
	/* disable access to ccr4/ccr5 */
	cyrix_write_reg(0xC3, cyrix_read_reg(0xC3) & ~0x10);
d745 22
a766 1
	printf("%s: xchg bug workaround performed\n", cpu_device);
d771 1
a771 1
intel586_cpu_setup(cpu_device)
d773 1
d792 1
a792 1
	void (*cpu_setup) __P((const char *));
d866 5
a941 4

	/* configure the CPU if needed */
	if (cpu_setup != NULL)
		cpu_setup(cpu_device);
@


1.91
log
@don't map DMA across boundaries; from NetBSD (don't know who).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.90 1998/08/04 20:40:46 downsj Exp $	*/
d1202 4
a1205 1
	if ((howto & (RB_DUMP | RB_HALT)) == RB_DUMP)
d1207 1
a1307 3

	/* Save registers. */
	savectx(&dumppcb);
@


1.90
log
@Change K6 3D to K6-2 (ewww) and set the Intel 686 model 5 as a P2.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.89 1998/06/04 05:00:27 downsj Exp $	*/
d2284 1
a2284 1
	bus_addr_t curaddr, lastaddr;
a2296 4
	/*
	 * XXX Need to implement "don't dma across this boundry".
	 */

d2303 3
a2305 1
	for (first = 1, seg = 0; buflen > 0 && seg < map->_dm_segcnt; ) {
d2319 9
d2338 4
a2341 1
			     map->_dm_maxsegsz)
d2344 2
a2345 1
				seg++;
@


1.89
log
@Make cpuid return values available via sysctl so that userland doesn't have
to rifle through kmem for them.  Also add a few more cpu names.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.88 1998/05/25 06:54:48 downsj Exp $	*/
d632 1
a632 1
				"Pentium Pro", 0, "Pentium II",
d662 1
a662 1
				"K6", "K6 3D", "K6 3D+", 0, 0, 0, 0, 0, 0,
@


1.88
log
@Fix Cyrix model names and add MediaGX/GXm; add feature bit display.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.87 1998/05/22 05:49:07 downsj Exp $	*/
d632 1
a632 1
				"Pentium Pro", 0, 0,
d673 1
a673 1
				"Pentium Pro compatible"	/* Default */
d686 2
a687 2
				0, 0, 0, "MediaGX", 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0,
d1914 3
d1944 1
a1944 1
	case  CPU_ALLOWAPERTURE:
d1955 6
@


1.87
log
@More AMD model names.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.86 1998/04/26 21:03:15 provos Exp $	*/
d686 3
a688 2
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				"486"		/* Default */
d696 3
a698 3
				0, 0, "6x86", 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0,
				"6x86"		/* Default */
d706 3
a708 2
				"M2", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				"M2"		/* Default */
d715 22
a773 1
#if defined(I586_CPU) || defined(I686_CPU)
a774 1
#endif
d857 1
a857 1
	if (cpu_feature && (cpu_feature & 0x10) >> 4) {	/* Has TSC */
d863 16
@


1.86
log
@update audio from NetBSD, mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.85 1998/04/25 20:31:27 mickey Exp $	*/
d662 1
a662 1
				0, 0, 0, 0, 0, 0, 0, 0, 0,
@


1.85
log
@convert i386 to MNN
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.84 1998/03/04 07:22:02 downsj Exp $	*/
d2507 19
d2527 2
a2528 1
	panic("_bus_dmamem_mmap: not implemented");
@


1.84
log
@nicer print
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.83 1998/03/01 11:25:28 niklas Exp $	*/
d199 2
a200 1
static	vm_offset_t hole_start, hole_end;
d202 1
d1643 4
a1646 2
	avail_next = avail_start =
	    bootapiver >= 2 ? NBPG + i386_round_page(bootargc) : NBPG;
d1701 7
d1773 1
d1812 1
@


1.83
log
@Conditionalize decl
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.82 1998/02/26 20:53:24 weingart Exp $	*/
d699 1
a699 1
		/* Family 6, not yet available from Cyrix */
a710 2
#define CPUDEBUG

d751 1
a751 1
	const char *name, *modifier, *vendorname;
d770 1
d803 1
d806 1
d824 6
a829 2
	sprintf(cpu_model, "%s %s%s (%s-class)", vendorname, modifier, name,
		classnames[class]);
@


1.82
log
@Fix boot flags not working.  The latest gas patches, which caught some
problems in our locore (which were then fixed), caused this latest bug
to appear.  Basically the clearing of the BSS was being done after the
boothowto integer was already filled in.

The new bootblocks already clear the BSS, so the clearing of the BSS
could well be removed from locore.  However, for backwards compatibility
we might still need it in there for a while.  (I believe the 2.1 boot-
blocks did not clear the BSS).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.81 1998/02/22 21:35:27 niklas Exp $	*/
d749 4
a752 1
	extern int cpu_id, cpu_feature;
@


1.81
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.80 1998/02/18 21:13:48 marc Exp $	*/
d186 1
a189 1
int	boothowto;
@


1.80
log
@fix typo; wouldn't compile unless APERTURE was defined
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.79 1998/02/18 01:47:42 deraadt Exp $	*/
d218 1
a218 1
static	ioport_malloc_safe;
d438 1
a438 1
	if (bufpages == 0)
d444 1
d1487 5
a1491 6
extern	IDTVEC(div),     IDTVEC(dbg),     IDTVEC(nmi),     IDTVEC(bpt),
	IDTVEC(ofl),     IDTVEC(bnd),     IDTVEC(ill),     IDTVEC(dna),
	IDTVEC(dble),    IDTVEC(fpusegm), IDTVEC(tss),     IDTVEC(missing),
	IDTVEC(stk),     IDTVEC(prot),    IDTVEC(page),    IDTVEC(rsvd),
	IDTVEC(fpu),     IDTVEC(align),
	IDTVEC(syscall), IDTVEC(osyscall);
d1494 1
a1494 1
extern IDTVEC(f00f_redirect);
@


1.79
log
@#ifndef APERTURE; machdep.allowaperture=0
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.78 1998/02/17 23:49:29 matthieu Exp $	*/
d1891 1
a1891 1
		return (sysctl_rdint(oldp, oldlenp, newp, 0);
@


1.78
log
@add an in-kernel /dev/xf86 aperture driver. the 'machdep.allowaperture'
sysctl controls whether it is permitted to access it. This sysctl can only
be manipulated when securelevel=0, hence in sysctl.conf
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.77 1998/01/22 02:30:46 niklas Exp $	*/
d1882 1
a1883 1
	case  CPU_ALLOWAPERTURE:
d1886 1
a1886 1
					     allowaperture));
d1889 3
a1891 1
					   &allowaperture));
@


1.77
log
@Split up the buffercache between low (<16MB) and high memory, so that
at least 2MB always will remain free in low memory for drivers to allocate
DMA buffers in
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.76 1998/01/20 18:40:14 niklas Exp $	*/
d233 8
d1882 9
@


1.76
log
@Merge bus_dma support from NetBSD, mostly by Jason Thorpe.  Only i386 uses it
 so far, the other archs gets placeholders for now.  I wrote a compatibility
layer for OpenBSD's old isadma code so we can still use our old
driver sources.  They will however get changed to native bus_dma use,
on a case by case basis.   Oh yes, I almost forgot, I kept our notion
of isadma being a device so DMA-less ISA-busses still work
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.75 1998/01/17 09:57:05 niklas Exp $	*/
d221 1
a260 1
	int base, residual;
a261 1
	vm_size_t size;
d308 1
a308 32
	size = MAXBSIZE * nbuf;
	buffer_map = kmem_suballoc(kernel_map, (vm_offset_t *)&buffers,
				   &maxaddr, size, TRUE);
	minaddr = (vm_offset_t)buffers;
	if (vm_map_find(buffer_map, vm_object_allocate(size), (vm_offset_t)0,
			&minaddr, size, FALSE) != KERN_SUCCESS)
		panic("startup: cannot allocate buffers");

	base = bufpages / nbuf;
	residual = bufpages % nbuf;
	if (base >= MAXBSIZE / CLBYTES) {
		/* don't want to alloc more physical mem than needed */
		base = MAXBSIZE / CLBYTES;
		residual = 0;
	}

	for (i = 0; i < nbuf; i++) {
		vm_size_t curbufsize;
		vm_offset_t curbuf;

		/*
		 * First <residual> buffers get (base+1) physical pages
		 * allocated for them.  The rest get (base) physical pages.
		 *
		 * The rest of each buffer occupies virtual space,
		 * but has no physical memory allocated for it.
		 */
		curbuf = (vm_offset_t)buffers + i * MAXBSIZE;
		curbufsize = CLBYTES * (i < residual ? base+1 : base);
		vm_map_pageable(buffer_map, curbuf, curbuf+curbufsize, FALSE);
		vm_map_simplify(buffer_map, curbuf);
	}
d314 2
a315 2
	exec_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 16*NCARGS, TRUE);
d320 2
a321 2
	phys_map = kmem_suballoc(kernel_map, &minaddr, &maxaddr,
				 VM_PHYS_SIZE, TRUE);
d327 2
a328 2
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
				   M_MBUF, M_NOWAIT);
d460 86
@


1.75
log
@Merge from NetBSD, thorpej@@netbsd.org says:

The boundary argument to bus_space_alloc() should be a bus_size_t, not
a bus_addr_t.  Pointed out by Chris Demetriou <cgd@@cs.cmu.edu>.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.74 1998/01/12 20:54:02 weingart Exp $	*/
d5 37
d122 3
d159 1
d169 1
d1582 19
d2064 421
@


1.74
log
@No need for f00f workaround on I686_CPU only
kernel.  Thanks to various people for noticing
this.
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.73 1998/01/09 14:36:42 niklas Exp $	*/
/*	$NetBSD: machdep.c,v 1.202 1996/05/18 15:54:59 christos Exp $	*/
d1831 1
a1831 2
	bus_size_t size, alignment;
	bus_addr_t boundary;
@


1.73
log
@oops, reenable machdep.bios sysctls
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.72 1998/01/09 12:33:21 niklas Exp $	*/
d634 1
a634 1
#if defined(I586_CPU) || defined(I686_CPU)
@


1.72
log
@oops wrong version checked in
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.70 1998/01/04 11:34:49 deraadt Exp $	*/
d123 2
@


1.71
log
@Make booting new kernels with old bootblocks moer robust
@
text
@d234 1
a234 1
	if (bootapiver >= BOOT_APIVER) {
d1528 1
a1528 1
	    bootapiver >= BOOT_APIVER ? NBPG + i386_round_page(bootargc) : NBPG;
@


1.70
log
@doc that the workaround is for the cyrix xchg bug
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.69 1997/12/17 10:27:32 downsj Exp $	*/
d93 1
a101 5
#include "bios.h"
#if NBIOS > 0
#include <machine/biosvar.h>
#endif

d234 1
a234 1
	if (bootargv != NULL) {
d1527 2
a1528 1
	avail_next = avail_start = NBPG + i386_round_page(bootargc);
@


1.69
log
@Streamline and use feature bits for determining whether or not to run the
calibration.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.68 1997/12/17 08:54:48 downsj Exp $	*/
d628 1
a628 1
	printf("%s: Cyrix workaround performed\n", cpu_device);
@


1.68
log
@New CPU detection code, from NetBSD, with some machdep changes from myself.

Add I686_CPU to your configs if you have a PPro...
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 1997/12/09 03:36:40 deraadt Exp $	*/
a193 1
void	intel686_cpu_setup __P((const char *));
d531 1
a531 1
			intel686_cpu_setup
d628 1
a628 1
	printf("\n%s: Cyrix workaround performed\n", cpu_device);
a636 3
	calibrate_cyclecounter();
	printf(" %d MHz\n", pentium_mhz);

a642 10
intel686_cpu_setup(cpu_device)
	const char *cpu_device;
{
#if defined(I586_CPU) || defined(I686_CPU)
	calibrate_cyclecounter();
	printf(" %d MHz\n", pentium_mhz);
#endif
}

void
d646 1
a646 1
	extern int cpu_id;
d721 8
a777 2
	else
		printf("\n");
@


1.67
log
@Intel P5 f00f workaround; weingart & who knows who else
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 1997/12/02 05:06:41 mickey Exp $	*/
d192 20
d461 146
a606 8
struct cpu_nameclass i386_cpus[] = {
	{ "i386SX",	CPUCLASS_386 },	/* CPU_386SX */
	{ "i386DX",	CPUCLASS_386 },	/* CPU_386   */
	{ "i486SX",	CPUCLASS_486 },	/* CPU_486SX */
	{ "i486DX",	CPUCLASS_486 },	/* CPU_486   */
	{ "Pentium",	CPUCLASS_586 },	/* CPU_586   */
	{ "Cx486DLC",	CPUCLASS_486 },	/* CPU_486DLC (Cyrix) */
	{ "Pentium Pro",CPUCLASS_686 },	/* CPU_686   */
d609 47
d660 7
d668 1
a668 1
	printf("CPU: ");
d670 64
a733 8
	if (cpu < 0 || cpu >= (sizeof i386_cpus/sizeof(struct cpu_nameclass)))
		panic("unknown cpu type %d\n", cpu);
#endif
	sprintf(cpu_model, "%s (", i386_cpus[cpu].cpu_name);
	if (cpu_vendor[0] != '\0') {
		strcat(cpu_model, cpu_vendor);
		strcat(cpu_model, " ");
	}
d735 1
a735 31
	cpu_class = i386_cpus[cpu].cpu_class;
	switch(cpu_class) {
	case CPUCLASS_386:
		strcat(cpu_model, "386");
		break;
	case CPUCLASS_486:
		strcat(cpu_model, "486");
		break;
	case CPUCLASS_586:
		strcat(cpu_model, "586");
		break;
	case CPUCLASS_686:
		strcat(cpu_model, "686");
		break;
	default:
		strcat(cpu_model, "unknown");	/* will panic below... */
		break;
	}
	strcat(cpu_model, "-class CPU)");
	printf("%s", cpu_model);
#if defined(I586_CPU)
	if (cpu_class >= CPUCLASS_586) {
		calibrate_cyclecounter();
		printf(" %d MHz", pentium_mhz);
	}
	if (!strcmp(cpu_model, "Pentium (GenuineIntel 586-class CPU)")) {
		fix_f00f();
		printf("\nCPU: F00F bug workaround installed");
	}
#endif
	printf("\n");
d742 1
a742 1
#if !defined(I386_CPU) && !defined(I486_CPU) && !defined(I586_CPU)
d745 9
a754 1
	case CPUCLASS_686:
d781 6
d799 1
a799 1
#if defined(I486_CPU) || defined(I586_CPU)
@


1.66
log
@once more
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 1997/12/01 04:21:49 mickey Exp $	*/
d492 4
d1086 2
a1087 1
struct gate_descriptor idt[NIDT];
d1147 39
d1261 1
a1261 1
	setregion(&region, idt, sizeof(idt) - 1);
d1461 2
a1462 2
	bzero((caddr_t)idt, sizeof(idt));
	setregion(&region, idt, sizeof(idt) - 1);
@


1.65
log
@Does not compile. Obviously untested code. Reverted
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 1997/10/28 09:11:35 niklas Exp $	*/
d1146 2
a1147 2
	int x;
	unsigned biosbasemem, biosextmem;
a1191 2
	for (x = 0; x < NIDT; x++)
		setgate(&idt[x], &IDTVEC(rsvd), 0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
d1207 1
d1211 2
a1223 21
#ifdef MEM_COMPUTE /* Default config  - get sizes from bootblocks */
	splhigh();
	enable_intr();

	/*
	 * Use BIOS values stored in RTC CMOS RAM, since probing
	 * breaks certain 386 AT relics.
	 *
	 * XXX Not only does probing break certain 386 AT relics, but
	 * not all BIOSes (Dell, Compaq, others) report the correct
	 * amount of extended memory.
	 */
	biosbasemem = (mc146818_read(NULL, NVRAM_BASEHI) << 8) |
	    mc146818_read(NULL, NVRAM_BASELO);
	biosextmem = (mc146818_read(NULL, NVRAM_EXTHI) << 8) |
	    mc146818_read(NULL, NVRAM_EXTLO);
#else
	biosbasemem = cnvmem;	/* Base memory as reported by BIOS call */
	biosextmem = extmem;	/* Extended memory as reported by BIOS call */
#endif

d1226 1
a1226 1
	biosextmem = EXTMEM_SIZE;
d1239 7
a1245 2
	avail_end = biosextmem ? IOM_END + biosextmem * 1024
	    : biosbasemem * 1024;	/* just temporary use */
d1254 2
a1255 11
	biosbasemem &= -(NBPG / 1024);
	biosextmem &= -(NBPG / 1024);

	/*
	 * BIOS leaves data in low memory and VM system doesn't work with
	 * phys 0,  /boot leaves arguments at page 1.
	 */
	avail_start = NBPG + i386_round_page(bootargc);

	avail_end = biosextmem ? IOM_END + biosextmem * 1024
	    : biosbasemem * 1024;
d1258 3
a1260 3
	physmem = btoc((biosbasemem + biosextmem) * 1024);
	dumpmem_low = btoc(biosbasemem * 1024);
	dumpmem_high = btoc(biosextmem * 1024);
d1265 1
d1267 1
a1267 3
	hole_start = biosbasemem * 1024;

	/* we load right after the I/O hole; adjust hole_end to compensate */
a1268 1
	avail_next = avail_start;
d1271 2
a1272 2
		printf("warning: too little memory available; running in degraded mode\n"
		    "press a key to confirm\n\n");
@


1.64
log
@rearrange memory computations, remove bogus MEM_COMPUTE hack
@
text
@d1146 2
a1147 2
	int i;
	u_int cm, em;
a1149 1
	extern char end, kernel_text;
d1192 2
a1208 1
	setgate(&idt[ 15], &IDTVEC(rsvd),    0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
a1211 2
	for (i = 19; i < NIDT; i++)
		setgate(&idt[i], &IDTVEC(rsvd), 0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
d1223 21
d1246 1
a1246 1
	extmem = EXTMEM_SIZE;
d1259 2
a1260 7
	/*
	 * BIOS leaves data in low memory and VM system doesn't work with
	 * phys 0,  /boot leaves arguments at page 1.
	 */
	avail_next = avail_start = NBPG + i386_round_page(bootargc);
	avail_end = extmem ? IOM_END + extmem * 1024
		: cnvmem * 1024;	/* just temporary use */
d1269 11
a1279 2
	cm = i386_round_page(cnvmem * 1024);
	em = i386_round_page(extmem * 1024);
d1282 3
a1284 3
	physmem = btoc(cm + em);
	dumpmem_low = btoc(cm);
	dumpmem_high = btoc(em);
a1288 1
	 * We load right after the I/O hole; adjust hole_end to compensate.
d1290 3
a1292 1
	hole_start = cm;
d1294 1
d1297 2
a1298 2
		printf("\awarning: too little memory available;"
		       "running in degraded mode\npress a key to confirm\n\n");
@


1.63
log
@DOH s/btoc/i386_round_page/
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 1997/10/25 22:04:04 mickey Exp $	*/
d1146 2
a1147 2
	int x;
	unsigned biosbasemem, biosextmem;
d1150 1
a1192 2
	for (x = 0; x < NIDT; x++)
		setgate(&idt[x], &IDTVEC(rsvd), 0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
d1208 1
d1212 2
a1224 21
#ifdef MEM_COMPUTE /* Default config  - get sizes from bootblocks */
	splhigh();
	enable_intr();

	/*
	 * Use BIOS values stored in RTC CMOS RAM, since probing
	 * breaks certain 386 AT relics.
	 *
	 * XXX Not only does probing break certain 386 AT relics, but
	 * not all BIOSes (Dell, Compaq, others) report the correct
	 * amount of extended memory.
	 */
	biosbasemem = (mc146818_read(NULL, NVRAM_BASEHI) << 8) |
	    mc146818_read(NULL, NVRAM_BASELO);
	biosextmem = (mc146818_read(NULL, NVRAM_EXTHI) << 8) |
	    mc146818_read(NULL, NVRAM_EXTLO);
#else
	biosbasemem = cnvmem;	/* Base memory as reported by BIOS call */
	biosextmem = extmem;	/* Extended memory as reported by BIOS call */
#endif

d1227 1
a1227 1
	biosextmem = EXTMEM_SIZE;
d1240 7
a1246 2
	avail_end = biosextmem ? IOM_END + biosextmem * 1024
	    : biosbasemem * 1024;	/* just temporary use */
d1255 2
a1256 11
	biosbasemem &= -(NBPG / 1024);
	biosextmem &= -(NBPG / 1024);

	/*
	 * BIOS leaves data in low memory and VM system doesn't work with
	 * phys 0,  /boot leaves arguments at page 1.
	 */
	avail_start = NBPG + i386_round_page(bootargc);

	avail_end = biosextmem ? IOM_END + biosextmem * 1024
	    : biosbasemem * 1024;
d1259 3
a1261 3
	physmem = btoc((biosbasemem + biosextmem) * 1024);
	dumpmem_low = btoc(biosbasemem * 1024);
	dumpmem_high = btoc(biosextmem * 1024);
d1266 1
d1268 1
a1268 3
	hole_start = biosbasemem * 1024;

	/* we load right after the I/O hole; adjust hole_end to compensate */
a1269 1
	avail_next = avail_start;
d1272 2
a1273 2
		printf("warning: too little memory available; running in degraded mode\n"
		    "press a key to confirm\n\n");
@


1.62
log
@hmm, copy&paste is evil
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 1997/10/25 21:47:26 mickey Exp $	*/
a354 1

d1276 1
a1276 1
	avail_start = NBPG + btoc(bootargc);
@


1.61
log
@fix blk2chr,chr2blk
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 1997/10/25 20:30:45 niklas Exp $	*/
d1497 1
a1497 1
		dev = blktochr((dev_t)name[1]);
@


1.60
log
@Boot args needs to be r/w
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.59 1997/10/25 08:36:41 mickey Exp $	*/
d1472 1
a1472 1
	dev_t consdev;
d1480 1
a1480 1
			consdev = cn_tab->cn_dev;
d1482 2
a1483 3
			consdev = NODEV;
		return sysctl_rdstruct(oldp, oldlenp, newp,
				       &consdev, sizeof consdev);
d1492 2
a1493 1
		return blktochr(name[1]);
d1497 2
a1498 1
		return chrtoblk(name[1]);
@


1.59
log
@do blk<-->chr dev_t conversions through the sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 1997/10/25 06:58:00 niklas Exp $	*/
d224 1
a224 1
			    pa, VM_PROT_READ, TRUE);
@


1.58
log
@Boot arguments are now at physmem 0x100
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 1997/10/24 22:15:06 mickey Exp $	*/
d1490 8
@


1.57
log
@map a piece of memory after the msgbuf and copy bootargv there.
pass cksumlen argument, sysctl it
mostly by niklas
me just did slite editing.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.56 1997/10/22 23:37:12 mickey Exp $	*/
d202 1
a202 1
	vm_offset_t minaddr, maxaddr, va, pa;
d218 1
a218 6
	/*
	 * The boot arguments can be anywhere in the low memory area, but
	 * we want it more nicely aligned to not have troubles in the pmap.
	 * So we have allocated an area right after msgbuf which we map now.
	 * We also temporarily map the old area while copying the arguments.
	 */
d220 5
a224 10
		va = (vm_offset_t)bootargp;
		for (i = 0; i < btoc(bootargc); i++, va += NBPG, pa += NBPG)
			pmap_enter(pmap_kernel(), va, pa, VM_PROT_ALL, TRUE);

		minaddr = i386_trunc_page(bootargv);
		maxaddr = i386_round_page(bootargv + bootargc) + 1;
		for (i = 0; i < maxaddr - minaddr; i += NBPG)
			pmap_enter(pmap_kernel(), va + i * NBPG, 
			    minaddr + i, VM_PROT_READ, TRUE);
		bcopy((void*)(va + (bootargv - minaddr)), bootargp, bootargc);
d1273 6
a1278 2
	avail_start = NBPG;	/* BIOS leaves data in low memory */
				/* and VM system doesn't work with phys 0 */
@


1.56
log
@support new libsa
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.55 1997/10/02 14:30:04 downsj Exp $	*/
d77 1
d155 1
d202 1
a202 1
	vm_offset_t minaddr, maxaddr;
d210 1
d212 1
a212 1
	for (i = 0; i < btoc(sizeof(struct msgbuf)); i++)
d215 1
a215 1
		    avail_end + i * NBPG, VM_PROT_ALL, TRUE);
d218 20
a1264 1
#if 0
d1269 1
a1269 1
#endif
d1298 1
@


1.55
log
@Ah, remove the stupid check for APM_NO_POWEROFF, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 1997/10/02 14:27:48 downsj Exp $	*/
d1242 1
d1247 1
@


1.54
log
@RB_POWERDOWN.  Come on people, RB_POWERDOWN has existing for *months*,
doesn't anyone bother to check these things?
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.53 1997/09/28 16:49:41 flipk Exp $	*/
d798 1
a798 1
#if NAPM > 0 && !defined(APM_NO_POWEROFF)
@


1.53
log
@cpu_reset() changes, inspired by netbsd
be damned if i can find netbsd's commit msg, tho..
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 1997/09/24 22:28:15 niklas Exp $	*/
d799 12
a810 8
		/* turn off, if we can.  But try to turn disk off and
		 * wait a bit first--some disk drives are slow to clean up
		 * and users have reported disk corruption.
		 */
		delay(500000);
		apm_set_powstate(APM_DEV_DISK(0xff), APM_SYS_OFF);
		delay(500000);
		apm_set_powstate(APM_DEV_ALLDEVS, APM_SYS_OFF);
@


1.52
log
@Revert, as we won't have enough time to test this fully before release.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.50 1997/09/22 12:11:19 deraadt Exp $	*/
d1409 2
d1413 1
a1413 1
	delay(20000);
d1415 1
a1415 1
	delay(20000);
d1421 2
a1422 1
	setregion(&region, 0, 0);
d1424 1
@


1.51
log
@Use vm_page_alloc_memory API. Some cleanup.
@
text
@a121 1
#include "isadma.h"
d205 1
a205 1
	/* 
a222 8
#if NISA > 0 && NISADMA > 0
	/*
	 * We need the bounce buffer allocated early so we have a good chance
	 * of getting a chunk of continuous low memory.
	 */
	isadma_init();
#endif

d287 2
a288 2
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES, M_MBUF,
	    M_NOWAIT);
@


1.50
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 1997/09/21 23:00:42 mickey Exp $	*/
d122 1
d206 1
a206 1
	/*
d224 8
d296 2
a297 2
	mclrefcnt = (char *)malloc(NMBCLUSTERS+CLBYTES/MCLBYTES,
				   M_MBUF, M_NOWAIT);
@


1.49
log
@branch the bios tree inside the machdep
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 1997/09/21 04:27:55 mickey Exp $	*/
d1461 1
a1461 1
				   newp, newlen, p);
@


1.48
log
@support new boots
add to your config:
bios0 at mainbus0
apm0 at mainbus0	# (if you are using APM)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 1997/09/02 08:50:30 downsj Exp $	*/
d100 5
a105 1

d1430 37
@


1.47
log
@Kill old COMPAT_BSDOS.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 1997/09/02 04:10:19 downsj Exp $	*/
d183 2
a184 2
extern long cnvmem;	/* BIOS's conventional memory size */
extern long extmem;	/* BIOS's extended memory size */
a533 33
}

/*  
 * machine dependent system variables.
 */ 
int
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	dev_t consdev;

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
@


1.46
log
@COMPAT_NOMID -> COMPAT_BSDOS, in preperation for a real emul library.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 1997/04/17 03:44:50 tholo Exp $	*/
a178 3
#ifdef COMPAT_BSDOS
static int exec_bsdos	__P((struct proc *, struct exec_package *));
#endif
a1361 66
#ifdef COMPAT_BSDOS
static int
exec_bsdos(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	int error;
	u_long midmag, magic;
	u_short mid;
	struct exec *execp = epp->ep_hdr;

	/* check on validity of epp->ep_hdr performed by exec_out_makecmds */

	midmag = ntohl(execp->a_midmag);
	mid = (midmag >> 16) & 0xffff;
	magic = midmag & 0xffff;

	if (magic == 0) {
		magic = (execp->a_midmag & 0xffff);
		mid = MID_ZERO;
	}

	midmag = mid << 16 | magic;

	switch (midmag) {
	case (MID_ZERO << 16) | ZMAGIC:
		/*
		 * 386BSD's ZMAGIC format:
		 */
		error = exec_aout_prep_oldzmagic(p, epp);
		break;

	case (MID_ZERO << 16) | QMAGIC:
		/*
		 * BSDI's QMAGIC format:
		 * same as new ZMAGIC format, but with different magic number
		 */
		error = exec_aout_prep_zmagic(p, epp);
		break;

	case (MID_ZERO << 16) | NMAGIC:
		/*
		 * BSDI's NMAGIC format:
		 * same as NMAGIC format, but with different magic number
		 * and with text starting at 0.
		 */
		error = exec_aout_prep_oldnmagic(p, epp);
		break;

	case (MID_ZERO << 16) | OMAGIC:
		/*
		 * BSDI's OMAGIC format:
		 * same as OMAGIC format, but with different magic number
		 * and with text starting at 0.
		 */
		error = exec_aout_prep_oldomagic(p, epp);
		break;

	default:
		error = ENOEXEC;
	}

	return error;
}
#endif

a1367 3
 *
 * On the i386, old (386bsd) ZMAGIC binaries and BSDI QMAGIC binaries
 * if COMPAT_BSDOS is given as a kernel option.
d1374 1
a1374 8
	int error = ENOEXEC;

#ifdef COMPAT_BSDOS
	if ((error = exec_bsdos(p, epp)) == 0)
		return error;
#endif /* ! COMPAT_BSDOS */

	return error;
@


1.45
log
@Do interrupt time accounting by running interrupt handlers with a seperate
code segment selector (otherwise identical to the standard kernel code
selector); idea by Dave Richards <richards@@zso.dec.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 1997/04/04 16:14:09 mickey Exp $	*/
d179 2
a180 2
#ifdef COMPAT_NOMID
static int exec_nomid	__P((struct proc *, struct exec_package *));
d1365 1
a1365 1
#ifdef COMPAT_NOMID
d1367 1
a1367 1
exec_nomid(p, epp)
d1439 1
a1439 1
 * if COMPAT_NOMID is given as a kernel option.
d1448 2
a1449 2
#ifdef COMPAT_NOMID
	if ((error = exec_nomid(p, epp)) == 0)
d1451 1
a1451 1
#endif /* ! COMPAT_NOMID */
@


1.44
log
@add 'machine check' trap for Pentium and PPro cpus.
no special handler for it. i guess there will be rare cases when
you receive it, and then you should repair your cpu, since
it happens on internal cpu error.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 1997/04/02 22:02:55 niklas Exp $	*/
d1103 1
a1103 1
setgate(gd, func, args, type, dpl)
d1106 1
a1106 1
	int args, type, dpl;
d1110 1
a1110 1
	gd->gd_selector = GSEL(GCODE_SEL, SEL_KPL);
d1191 1
d1202 1
a1202 1
	    SEL_UPL);
d1209 20
a1228 20
		setgate(&idt[x], &IDTVEC(rsvd), 0, SDT_SYS386TGT, SEL_KPL);
	setgate(&idt[  0], &IDTVEC(div),     0, SDT_SYS386TGT, SEL_KPL);
	setgate(&idt[  1], &IDTVEC(dbg),     0, SDT_SYS386TGT, SEL_KPL);
	setgate(&idt[  2], &IDTVEC(nmi),     0, SDT_SYS386TGT, SEL_KPL);
	setgate(&idt[  3], &IDTVEC(bpt),     0, SDT_SYS386TGT, SEL_UPL);
	setgate(&idt[  4], &IDTVEC(ofl),     0, SDT_SYS386TGT, SEL_UPL);
	setgate(&idt[  5], &IDTVEC(bnd),     0, SDT_SYS386TGT, SEL_KPL);
	setgate(&idt[  6], &IDTVEC(ill),     0, SDT_SYS386TGT, SEL_KPL);
	setgate(&idt[  7], &IDTVEC(dna),     0, SDT_SYS386TGT, SEL_KPL);
	setgate(&idt[  8], &IDTVEC(dble),    0, SDT_SYS386TGT, SEL_KPL);
	setgate(&idt[  9], &IDTVEC(fpusegm), 0, SDT_SYS386TGT, SEL_KPL);
	setgate(&idt[ 10], &IDTVEC(tss),     0, SDT_SYS386TGT, SEL_KPL);
	setgate(&idt[ 11], &IDTVEC(missing), 0, SDT_SYS386TGT, SEL_KPL);
	setgate(&idt[ 12], &IDTVEC(stk),     0, SDT_SYS386TGT, SEL_KPL);
	setgate(&idt[ 13], &IDTVEC(prot),    0, SDT_SYS386TGT, SEL_KPL);
	setgate(&idt[ 14], &IDTVEC(page),    0, SDT_SYS386TGT, SEL_KPL);
	setgate(&idt[ 16], &IDTVEC(fpu),     0, SDT_SYS386TGT, SEL_KPL);
	setgate(&idt[ 17], &IDTVEC(align),   0, SDT_SYS386TGT, SEL_KPL);
	setgate(&idt[ 18], &IDTVEC(rsvd),    0, SDT_SYS386TGT, SEL_KPL);
	setgate(&idt[128], &IDTVEC(syscall), 0, SDT_SYS386TGT, SEL_UPL);
@


1.43
log
@Fix end boundary of mapping for regions ending at offset 1 in a page.
From NetBSD PR#3441, Matthias Drochner <drochner@@zelz26.zel.kfa-juelich.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 1997/02/24 04:05:48 downsj Exp $	*/
d1226 1
@


1.42
log
@Kill the annoying printf (which I think I added).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 1997/02/03 15:04:50 deraadt Exp $	*/
d1684 1
a1684 1
	endpa = i386_round_page((bpa + size) - 1);
d1731 1
a1731 1
		endva = i386_round_page((bsh + size) - 1);
@


1.41
log
@More siginfo implementations (alpha and mips might even work)
move "siginfo_t *" to 2nd arg of signal handler as 1003.1b requires.
I really wish I had 1003.1b documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 1997/02/03 12:48:58 deraadt Exp $	*/
d1258 2
a1259 3
#ifdef EXTMEM_SIZE /* Override memory size */
	if (biosextmem != EXTMEM_SIZE)
		printf("Note:  Overriding BIOS memsize of %d.\n", biosextmem);
@


1.40
log
@repair confusion over kv/uv addr for siginfo_t storage
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 1997/02/01 21:53:23 deraadt Exp $	*/
a633 1
	frame.sf_code = code;
d635 1
a636 1
	frame.sf_sip = NULL;
@


1.39
log
@add type & union sigval args to sendsig/trapsignal
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 1997/02/01 00:58:25 deraadt Exp $	*/
d676 1
a676 1
		initsiginfo(frame.sf_sip, sig, code, type, val);
@


1.38
log
@grammar error
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 1997/02/01 00:31:49 niklas Exp $	*/
d573 1
a573 1
void ibcs2_sendsig __P((sig_t, int, int, u_long, caddr_t));
d576 1
a576 1
ibcs2_sendsig(catcher, sig, mask, code, addr)
d580 2
a581 1
	caddr_t addr;
d585 1
a585 1
	sendsig(catcher, bsd_to_ibcs2_sig[sig], mask, code, addr);
d600 1
a600 1
sendsig(catcher, sig, mask, code, addr)
d604 2
a605 1
	caddr_t addr;
d676 1
a676 9
		initsiginfo(frame.sf_sip, sig);
		fixsiginfo(frame.sf_sip, sig, code, addr);
		if (sig == SIGSEGV) {
			/* try to be more specific about read or write */
			if (tf->tf_err & PGEX_W)
				frame.sf_si.si_code = SEGV_ACCERR;
			else
				frame.sf_si.si_code = SEGV_MAPERR;
		}
a782 69
}

void
fixsiginfo(si, sig, code, addr)
	siginfo_t *si;
	int sig;
	u_long code;
	caddr_t addr;
{
	si->si_addr = addr;

	switch (code) {
	case T_PRIVINFLT:
		si->si_code = ILL_PRVOPC;
		si->si_trapno = T_PRIVINFLT;
		break;
	case T_BPTFLT:
		si->si_code = TRAP_BRKPT;
		si->si_trapno = T_BPTFLT;
		break;
	case T_ARITHTRAP:
		si->si_code = FPE_INTOVF;
		si->si_trapno = T_DIVIDE;
		break;
	case T_PROTFLT:
		si->si_code = SEGV_ACCERR;
		si->si_trapno = T_PROTFLT;
		break;
	case T_TRCTRAP:
		si->si_code = TRAP_TRACE;
		si->si_trapno = T_TRCTRAP;
		break;
	case T_PAGEFLT:
		si->si_code = SEGV_ACCERR;
		si->si_trapno = T_PAGEFLT;
		break;
	case T_ALIGNFLT:
		si->si_code = BUS_ADRALN;
		si->si_trapno = T_ALIGNFLT;
		break;
	case T_DIVIDE:
		si->si_code = FPE_FLTDIV;
		si->si_trapno = T_DIVIDE;
		break;
	case T_OFLOW:
		si->si_code = FPE_FLTOVF;
		si->si_trapno = T_DIVIDE;
		break;
	case T_BOUND:
		si->si_code = FPE_FLTSUB;
		si->si_trapno = T_BOUND;
		break;
	case T_DNA:
		si->si_code = FPE_FLTINV;
		si->si_trapno = T_DNA;
		break;
	case T_FPOPFLT:
		si->si_code = FPE_FLTINV;
		si->si_trapno = T_FPOPFLT;
		break;
	case T_SEGNPFLT:
		si->si_code = SEGV_MAPERR;
		si->si_trapno = T_SEGNPFLT;
		break;
	case T_STKFLT:
		si->si_code = ILL_BADSTK;
		si->si_trapno = T_STKFLT;
		break;
	}
@


1.37
log
@Allow bufpages/nbuf larger than 1 (still max out at all buffers
be MAXBSIZE).  Remove faulty limit test of buffer pages allocation.  The
check is now done at the bufpages+nbuf calculations.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 1997/01/27 22:47:59 deraadt Exp $	*/
d408 1
a408 1
	/* More buffer pages that fits into the buffers is senseless.  */
@


1.36
log
@add another parameter to trapsignal() and sendsig() -- fault addr to be
delivered with in the siginfo information
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 1997/01/27 01:16:12 deraadt Exp $	*/
d246 1
a246 1
	if (base >= MAXBSIZE) {
d248 1
a248 1
		base = MAXBSIZE;
a395 6

	/* Restrict to at most 70% filled kvm */
	if (bufpages * MAXBSIZE >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) * 7 / 10)
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;
d401 11
@


1.35
log
@i386 part of siginfo
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 1997/01/16 19:57:17 kstailey Exp $	*/
d568 1
a568 1
void ibcs2_sendsig __P((sig_t, int, int, u_long));
d571 1
a571 1
ibcs2_sendsig(catcher, sig, mask, code)
d575 1
d579 1
a579 1
	sendsig(catcher, bsd_to_ibcs2_sig[sig], mask, code);
d594 1
a594 1
sendsig(catcher, sig, mask, code)
d598 1
d670 1
a670 1
		fixsiginfo(frame.sf_sip, sig, code, (caddr_t)rcr2());
@


1.34
log
@do not call resettodr() if RB_TIMEBAD is set due to being in ddb with clock updates suspended
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 1996/12/29 12:27:26 graichen Exp $	*/
d628 1
d665 14
d784 69
d1016 1
a1016 1
        /* toss any characters present prior to dump */
@


1.33
log
@be more consistent when printing the memory values at bootup - now also
the BIOS mem stuff is printed in bytes - like the other values too
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 1996/12/10 23:34:12 niklas Exp $	*/
d797 5
a801 1
		resettodr();
@


1.32
log
@Forgotten line in extent handling code
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 1996/12/09 09:54:04 niklas Exp $	*/
d218 2
a219 2
	printf("BIOS mem  = %ldk conventional, %ldk extended\n",
		cnvmem, extmem);
@


1.31
log
@Use new extent manager when mapping bus resources
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 1996/12/09 08:36:41 deraadt Exp $	*/
d318 1
@


1.30
log
@minor whoops
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 1996/12/05 18:08:06 dm Exp $	*/
d156 18
d1149 18
d1244 18
d1528 26
d1568 9
d1591 1
d1596 32
d1640 8
d1696 1
d1701 1
a1701 1
	 * Find the correct bus physical address.
d1705 1
d1710 1
d1729 7
@


1.29
log
@NetBSD PR#2910: Recognize Pentium Pro machines
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 1996/11/28 23:37:36 niklas Exp $	*/
d379 2
a380 2
	if (bufpages * MAXBSIZE * 7 / 10 >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS))
@


1.28
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 1996/10/25 11:14:12 deraadt Exp $	*/
d411 1
d441 3
d451 1
a451 1
	if (cpu_class == CPUCLASS_586) {
d467 1
@


1.27
log
@grow kvm space; fix an over-agressive pmap optimization
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 1996/10/23 05:23:39 etheisen Exp $	*/
d63 1
d88 1
d165 3
d1461 32
a1492 4
bus_mem_map(t, bpa, size, cacheable, mhp)
	bus_chipset_tag_t t;
	bus_mem_addr_t bpa;
	bus_mem_size_t size;
d1494 31
a1524 1
	bus_mem_handle_t *mhp;
d1534 1
a1534 1
		panic("bus_mem_map: overflow");
d1539 3
a1541 2
		return (1);
	*mhp = (caddr_t)(va + (bpa & PGOFSET));
d1544 7
a1550 7
                pmap_enter(pmap_kernel(), va, pa, VM_PROT_READ | VM_PROT_WRITE,
                    TRUE);
                if (!cacheable)
                        pmap_changebit(pa, PG_N, ~0);
                else
                        pmap_changebit(pa, 0, ~PG_N);
        }
d1552 1
a1552 1
        return 0;
d1556 4
a1559 4
bus_mem_unmap(t, memh, size)
	bus_chipset_tag_t t;
	bus_mem_handle_t memh;
	bus_mem_size_t size;
d1561 2
a1562 1
	vm_offset_t va, endva;
d1564 11
a1574 2
	va = i386_trunc_page(memh);
	endva = i386_round_page((memh + size) - 1);
d1577 2
a1578 2
	if (endva <= va)
		panic("bus_mem_unmap: overflow");
d1581 33
a1613 1
	kmem_free(kernel_map, va, endva - va);
@


1.26
log
@be slightly more verbose for my sake
@
text
@d220 4
a223 1
	if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
d225 2
a226 1
		bufpages = btoc(MAXBSIZE) * nbuf;
d228 1
a228 2
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
d372 6
@


1.25
log
@Get memory configuration from boot blocks or /boot when it becomes
available.  Use MEM_COMPUTE option to use old behavior.  Use EXTMEM_SIZE
to override extended memory size.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 1996/09/21 07:15:33 deraadt Exp $	*/
d1184 2
@


1.24
log
@integer overflow should gen SIGFPE; netbsd pr#1833, cline@@ASM.FOX.CS.CMU.EDU (yes, this is from 12 december 95)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 1996/09/12 21:54:41 deraadt Exp $	*/
d163 3
d193 1
d195 2
d1162 1
a1175 3
#ifdef EXTMEM_SIZE
	biosextmem = EXTMEM_SIZE;
#else
d1178 8
a1185 1
#endif /* EXTMEM_SIZE */
@


1.23
log
@BUFCACHEPERCENT for cranking % of mem used
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 1996/06/27 06:13:44 deraadt Exp $	*/
d1132 1
a1132 1
	setgate(&idt[  4], &IDTVEC(ofl),     0, SDT_SYS386TGT, SEL_KPL);
@


1.22
log
@throw user_config() into #ifdef BOOT_CONFIG
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 1996/06/23 19:39:13 maja Exp $	*/
d348 3
d362 1
a362 1
			    (20 * CLSIZE);
@


1.21
log
@Added support for user modifiable kernel at boot (-c) /maja
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 1996/05/30 10:17:53 deraadt Exp $	*/
d280 1
d282 3
@


1.20
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 1996/05/30 09:30:09 deraadt Exp $	*/
d279 3
@


1.19
log
@clean & sync
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 1996/05/23 08:38:54 deraadt Exp $	*/
a1196 10

#ifdef USER_LDT
#define MAXPROC ((MAXGDTSIZ-NGDT)/2)
#else
#define MAXPROC (MAXGDTSIZ-NGDT)
#endif
	if (maxproc > MAXPROC) {
		printf("reducing maxproc to %d to fit into gdt\n", MAXPROC);
		maxproc = MAXPROC;
	}
@


1.18
log
@execve changes
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 1996/05/07 15:27:51 mickey Exp $	*/
d415 1
a415 1
	printf("%s", cpu_model);	/* cpu speed would be nice, but how? */
a704 6

	if (context.sc_onstack & 01)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = context.sc_mask & ~sigcantmask;
@


1.17
log
@from NetBSD PR#2124(port-i386):
Juergen Hannken-Illjes: core dump after panic does not work.
fill curproc w/ some reasonable (struct proc *) pointer.
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.13 1996/04/21 22:16:31 deraadt Exp $	*/
/*	$NetBSD: machdep.c,v 1.200 1996/05/03 19:42:15 christos Exp $	*/
a1263 1

d1293 1
a1293 1
		error = cpu_exec_aout_prep_oldzmagic(p, epp);
d1304 18
a1354 57
#if defined(COMPAT_NOMID) || defined(COMPAT_FREEBSD)
/*
 * cpu_exec_aout_prep_oldzmagic():
 *	Prepare the vmcmds to build a vmspace for an old (386BSD) ZMAGIC
 *	binary.
 *
 * Cloned from exec_aout_prep_zmagic() in kern/exec_aout.c; a more verbose
 * description of operation is there.
 */
int
cpu_exec_aout_prep_oldzmagic(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	struct exec *execp = epp->ep_hdr;

	epp->ep_taddr = 0;
	epp->ep_tsize = execp->a_text;
	epp->ep_daddr = epp->ep_taddr + execp->a_text;
	epp->ep_dsize = execp->a_data + execp->a_bss;
	epp->ep_entry = execp->a_entry;

	/*
	 * check if vnode is in open for writing, because we want to
	 * demand-page out of it.  if it is, don't do it, for various
	 * reasons
	 */
	if ((execp->a_text != 0 || execp->a_data != 0) &&
	    epp->ep_vp->v_writecount != 0) {
#ifdef DIAGNOSTIC
		if (epp->ep_vp->v_flag & VTEXT)
			panic("exec: a VTEXT vnode has writecount != 0\n");
#endif
		return ETXTBSY;
	}
	epp->ep_vp->v_flag |= VTEXT;

	/* set up command for text segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, execp->a_text,
	    epp->ep_taddr, epp->ep_vp, NBPG, /* XXX should NBPG be CLBYTES? */
	    VM_PROT_READ|VM_PROT_EXECUTE);

	/* set up command for data segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, execp->a_data,
	    epp->ep_daddr, epp->ep_vp,
	    execp->a_text + NBPG, /* XXX should NBPG be CLBYTES? */
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	/* set up command for bss segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, execp->a_bss,
	    epp->ep_daddr + execp->a_data, NULLVP, 0,
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	return exec_aout_setup_stack(p, epp);
}
#endif /* COMPAT_NOMID || COMPAT_FREEBSD */

d1451 6
a1456 1
	endpa = i386_round_page(bpa + size);
d1484 8
a1491 2
	endva = i386_round_page(memh);
	kmem_free(kmem_map, va, endva - va);
@


1.16
log
@sync with 0504; prototype changes
@
text
@d737 6
@


1.15
log
@Turn off the alignment check flag when entering a signal handler
@
text
@d2 1
a2 1
/*	$NetBSD: machdep.c,v 1.199 1996/04/18 09:58:13 mycroft Exp $	*/
d81 2
d104 7
d154 8
a161 5
void identifycpu __P((void));
caddr_t allocsys __P((caddr_t));
void dumpsys __P((void));
void cpu_reset __P((void));
void identifycpu __P((void));
d267 1
a267 1
	printf("avail mem = %d\n", ptoa(cnt.v_free_count));
a385 1
	int len;
d514 2
d847 1
a847 2
	int error = 0;
	int c;
d864 1
a864 1
	printf("\ndumping to dev %x, offset %d\n", dumpdev, dumplo);
d882 1
a1091 1
	extern char etext[], sigcode[], esigcode[];
a1092 1
	extern void lgdt();
a1346 1
	struct exec_vmcmd *ccmdp;
@


1.14
log
@Pull in John Kohl's [jtk@@netbsd.org] most recent (15Apr96) APM and PCMCIA work
(original PCMCIA framework  by Stefan Grefen [grefen@@convex.com]).
@
text
@d2 1
a2 1
/*	$NetBSD: machdep.c,v 1.197 1996/04/12 08:44:40 mycroft Exp $	*/
d462 1
a462 2
	 * On a 486 or above, enable ring 0 write protection and outer ring
	 * alignment checking.
d465 1
a465 1
		lcr0(rcr0() | CR0_WP | CR0_AM);
d615 1
a615 1
	tf->tf_eflags &= ~(PSL_T|PSL_VM);
@


1.13
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.12 1996/04/18 19:18:11 niklas Exp $	*/
d96 6
d745 10
d1187 10
@


1.12
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD: machdep.c,v 1.9 1996/04/17 05:18:54 mickey Exp $	*/
/*	$NetBSD: machdep.c,v 1.194 1996/03/08 20:19:48 cgd Exp $	*/
d5 1
a5 1
 * Copyright (c) 1993, 1994, 1995 Charles M. Hannum.  All rights reserved.
d139 1
a570 1
		tf->tf_eflags &= ~PSL_VM;
d610 1
d687 6
@


1.11
log
@Fix a typo (get_vflag[s]).
@
text
@d2 1
a2 1
/*	$NetBSD: machdep.c,v 1.191 1996/03/01 21:49:49 scottr Exp $	*/
d416 1
d425 1
d434 2
a435 1
		panic("CPU class not configured");
d709 1
d711 1
a711 1
	if ((howto&RB_NOSYNC) == 0 && waittime < 0) {
d720 2
d723 5
d730 1
a735 6
	} else {
		if (howto & RB_DUMP) {
			savectx(&dumppcb, 0);
			dumppcb.pcb_cr3 = rcr3();
			dumpsys();
		}
d737 1
d815 3
d1119 4
d1126 3
d1131 1
d1429 44
@


1.10
log
@Fix prototyping, so it's compiling again.
@
text
@d566 1
a566 1
		frame.sf_sc.sc_eflags = get_vflag(p);
@


1.9
log
@Cleanups & fixes from latest NetBSD primarily to run doscmd, etc.
GENERIC added to the compile/.cvsignore (it is used for 'make links'
for example), thus conf/GENERIC should appear magically ...
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.8 1996/03/11 11:16:50 mickey Exp $	*/
d142 1
@


1.8
log
@Debbuger changed towards the latest Mach.
Some minor changes for Linux ;) emulation.
Small bug fixes from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.7 1996/03/03 03:02:34 mickey Exp $	*/
d363 1
d565 2
a566 3
		frame.sf_sc.sc_eflags = tf->tf_eflags;
		SETFLAGS(frame.sf_sc.sc_eflags, VM86_EFLAGS(p),
			 VM86_FLAGMASK(p)|PSL_VIF);
a605 3
#ifdef VM86
	tf->tf_eflags &= ~PSL_VM;
#endif
d620 1
a643 16
	 * Check for security violations.  If we're returning to protected
	 * mode, the CPU will validate the segment registers automatically
	 * and generate a trap on violations.  We handle the trap, rather
	 * than doing all of the checking here.
	 */
	if (((context.sc_eflags ^ tf->tf_eflags) & PSL_USERSTATIC) != 0 ||
	    !USERMODE(context.sc_cs, context.sc_eflags))
		return (EINVAL);

	if (context.sc_onstack & 01)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = context.sc_mask & ~sigcantmask;

	/*
d652 1
a652 3
		tf->tf_eflags = context.sc_eflags;
		SETFLAGS(VM86_EFLAGS(p), context.sc_eflags,
			 VM86_FLAGMASK(p)|PSL_VIF);
d656 10
d683 6
d697 1
a697 1
	register int howto;
@


1.7
log
@from NetBSD: so it compiles now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d706 2
a707 2
		printf("hit reset please");
		for(;;);
d720 2
a722 1
		doshutdownhooks();
a732 1
		doshutdownhooks();
@


1.6
log
@Small changes from NetBSD (including /usr/include dependencies, and so).
@
text
@d1 2
a2 1
/*	$OpenBSD: machdep.c,v 1.185 1996/01/08 20:12:20 mycroft Exp $	*/
a1108 10
#ifdef DDB
	ddb_init();
	if (boothowto & RB_KDB)
		Debugger();
#endif
#ifdef KGDB
	if (boothowto & RB_KDB)
		kgdb_connect(0);
#endif

d1149 10
d1169 3
a1171 2
_insque(elem, head)
	register struct queue *elem, *head;
d1173 1
d1187 2
a1188 2
_remque(elem)
	register struct queue *elem;
d1190 1
@


1.5
log
@Allow use of Pentium cycle counter for high-precision time keeping;
from FreeBSD
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.185 1996/01/08 20:12:20 mycroft Exp $	*/
d460 1
d917 1
d1355 1
a1355 1
u_int
@


1.4
log
@from netbsd; VM86 support, by John Kohl, touched up a bit by charles
@
text
@d168 1
d394 8
a401 1
	printf("%s\n", cpu_model);	/* cpu speed would be nice, but how? */
@


1.3
log
@ss_sp is correct, ss_base is not. noticed by agc@@sde.uts.amdahl.com; netbsd pr#1784
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.183 1996/01/04 22:22:01 jtc Exp $	*/
d95 4
d544 2
d554 3
d564 1
d566 11
a576 12
	frame.sf_sc.sc_edi    = tf->tf_edi;
	frame.sf_sc.sc_esi    = tf->tf_esi;
	frame.sf_sc.sc_ebp    = tf->tf_ebp;
	frame.sf_sc.sc_ebx    = tf->tf_ebx;
	frame.sf_sc.sc_edx    = tf->tf_edx;
	frame.sf_sc.sc_ecx    = tf->tf_ecx;
	frame.sf_sc.sc_eax    = tf->tf_eax;
	frame.sf_sc.sc_eip    = tf->tf_eip;
	frame.sf_sc.sc_cs     = tf->tf_cs;
	frame.sf_sc.sc_eflags = tf->tf_eflags;
	frame.sf_sc.sc_esp    = tf->tf_esp;
	frame.sf_sc.sc_ss     = tf->tf_ss;
d590 4
a593 1
	tf->tf_esp = (int)fp;
d595 1
d599 1
a599 3
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
	tf->tf_ds = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_es = GSEL(GUDATA_SEL, SEL_UPL);
d660 3
d669 1
d671 11
a681 12
	tf->tf_edi    = context.sc_edi;
	tf->tf_esi    = context.sc_esi;
	tf->tf_ebp    = context.sc_ebp;
	tf->tf_ebx    = context.sc_ebx;
	tf->tf_edx    = context.sc_edx;
	tf->tf_ecx    = context.sc_ecx;
	tf->tf_eax    = context.sc_eax;
	tf->tf_eip    = context.sc_eip;
	tf->tf_cs     = context.sc_cs;
	tf->tf_eflags = context.sc_eflags;
	tf->tf_esp    = context.sc_esp;
	tf->tf_ss     = context.sc_ss;
@


1.2
log
@call doshutdownhooks() earlier
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.182 1995/12/14 18:31:20 ghudson Exp $	*/
d526 1
a526 1
		fp = (struct sigframe *)(psp->ps_sigstk.ss_base +
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: machdep.c,v 1.180.2.1 1995/10/15 22:11:38 mycroft Exp $	*/
d697 1
d708 1
a709 1
	doshutdownhooks();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
