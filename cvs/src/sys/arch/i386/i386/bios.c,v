head	1.116;
access;
symbols
	OPENBSD_6_2_BASE:1.116
	OPENBSD_6_1:1.115.0.6
	OPENBSD_6_1_BASE:1.115
	OPENBSD_6_0:1.115.0.2
	OPENBSD_6_0_BASE:1.115
	OPENBSD_5_9:1.114.0.2
	OPENBSD_5_9_BASE:1.114
	OPENBSD_5_8:1.111.0.4
	OPENBSD_5_8_BASE:1.111
	OPENBSD_5_7:1.109.0.2
	OPENBSD_5_7_BASE:1.109
	OPENBSD_5_6:1.104.0.4
	OPENBSD_5_6_BASE:1.104
	OPENBSD_5_5:1.103.0.4
	OPENBSD_5_5_BASE:1.103
	OPENBSD_5_4:1.99.0.2
	OPENBSD_5_4_BASE:1.99
	OPENBSD_5_3:1.97.0.2
	OPENBSD_5_3_BASE:1.97
	OPENBSD_5_2:1.95.0.2
	OPENBSD_5_2_BASE:1.95
	OPENBSD_5_1_BASE:1.93
	OPENBSD_5_1:1.93.0.2
	OPENBSD_5_0:1.90.0.2
	OPENBSD_5_0_BASE:1.90
	OPENBSD_4_9:1.88.0.2
	OPENBSD_4_9_BASE:1.88
	OPENBSD_4_8:1.87.0.2
	OPENBSD_4_8_BASE:1.87
	OPENBSD_4_7:1.86.0.2
	OPENBSD_4_7_BASE:1.86
	OPENBSD_4_6:1.85.0.4
	OPENBSD_4_6_BASE:1.85
	OPENBSD_4_5:1.84.0.2
	OPENBSD_4_5_BASE:1.84
	OPENBSD_4_4:1.81.0.2
	OPENBSD_4_4_BASE:1.81
	OPENBSD_4_3:1.78.0.2
	OPENBSD_4_3_BASE:1.78
	OPENBSD_4_2:1.70.0.2
	OPENBSD_4_2_BASE:1.70
	OPENBSD_4_1:1.68.0.2
	OPENBSD_4_1_BASE:1.68
	OPENBSD_4_0:1.67.0.2
	OPENBSD_4_0_BASE:1.67
	OPENBSD_3_9:1.57.0.2
	OPENBSD_3_9_BASE:1.57
	OPENBSD_3_8:1.56.0.2
	OPENBSD_3_8_BASE:1.56
	OPENBSD_3_7:1.55.0.4
	OPENBSD_3_7_BASE:1.55
	OPENBSD_3_6:1.55.0.2
	OPENBSD_3_6_BASE:1.55
	SMP_SYNC_A:1.54
	SMP_SYNC_B:1.54
	OPENBSD_3_5:1.54.0.2
	OPENBSD_3_5_BASE:1.54
	OPENBSD_3_4:1.52.0.2
	OPENBSD_3_4_BASE:1.52
	UBC_SYNC_A:1.50
	OPENBSD_3_3:1.49.0.4
	OPENBSD_3_3_BASE:1.49
	OPENBSD_3_2:1.49.0.2
	OPENBSD_3_2_BASE:1.49
	OPENBSD_3_1:1.48.0.2
	OPENBSD_3_1_BASE:1.48
	UBC_SYNC_B:1.49
	UBC:1.47.0.2
	UBC_BASE:1.47
	OPENBSD_3_0:1.46.0.2
	OPENBSD_3_0_BASE:1.46
	OPENBSD_2_9:1.42.0.2
	OPENBSD_2_9_BASE:1.42
	OPENBSD_2_8:1.38.0.2
	OPENBSD_2_8_BASE:1.38
	OPENBSD_2_7:1.27.0.2
	OPENBSD_2_7_BASE:1.27
	SMP:1.25.0.2
	SMP_BASE:1.25
	kame_19991208:1.25
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.23.0.2
	OPENBSD_2_5_BASE:1.23
	OPENBSD_2_4:1.22.0.4
	OPENBSD_2_4_BASE:1.22
	OPENBSD_2_3:1.22.0.2
	OPENBSD_2_3_BASE:1.22
	OPENBSD_2_2:1.19.0.2
	OPENBSD_2_2_BASE:1.19;
locks; strict;
comment	@ * @;


1.116
date	2017.07.15.17.20.56;	author tedu;	state Exp;
branches;
next	1.115;
commitid	wvzxYJyTqAJ13ePt;

1.115
date	2016.03.07.05.32.46;	author naddy;	state Exp;
branches;
next	1.114;
commitid	Ht3NH0pdlkYC6Nxx;

1.114
date	2016.02.20.19.59.01;	author mlarkin;	state Exp;
branches;
next	1.113;
commitid	YdhhS211QfzgRU4H;

1.113
date	2015.09.16.04.18.52;	author daniel;	state Exp;
branches;
next	1.112;
commitid	3jv7XhEcRN3Wk41i;

1.112
date	2015.09.03.03.13.56;	author yasuoka;	state Exp;
branches;
next	1.111;
commitid	dUHfqLm9bUtqA38m;

1.111
date	2015.07.17.22.31.16;	author mlarkin;	state Exp;
branches;
next	1.110;
commitid	B1FH5N3npnvcqf7b;

1.110
date	2015.07.17.21.36.56;	author mlarkin;	state Exp;
branches;
next	1.109;
commitid	myTLft2DQvq03Jlf;

1.109
date	2015.01.21.18.39.54;	author tedu;	state Exp;
branches;
next	1.108;
commitid	QJ0D0OdLEsmTh71I;

1.108
date	2015.01.17.17.44.15;	author tedu;	state Exp;
branches;
next	1.107;
commitid	0yIxdKLJHBNfHg5a;

1.107
date	2014.11.16.12.30.57;	author deraadt;	state Exp;
branches;
next	1.106;
commitid	yv0ECmCdICvq576h;

1.106
date	2014.10.17.20.34.23;	author kettenis;	state Exp;
branches;
next	1.105;
commitid	LBrNPHhKyCA4k7q6;

1.105
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.104;
commitid	uzzBR7hz9ncd4O6G;

1.104
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.103;

1.103
date	2013.11.02.15.02.27;	author kettenis;	state Exp;
branches;
next	1.102;

1.102
date	2013.10.16.13.41.17;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2013.10.01.20.22.11;	author sf;	state Exp;
branches;
next	1.100;

1.100
date	2013.09.29.12.56.31;	author kettenis;	state Exp;
branches;
next	1.99;

1.99
date	2013.04.24.08.23.45;	author blambert;	state Exp;
branches;
next	1.98;

1.98
date	2013.03.12.16.31.48;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2012.10.09.12.58.07;	author jsing;	state Exp;
branches;
next	1.96;

1.96
date	2012.08.10.18.50.04;	author krw;	state Exp;
branches;
next	1.95;

1.95
date	2012.06.04.15.19.47;	author jsing;	state Exp;
branches;
next	1.94;

1.94
date	2012.06.03.13.17.47;	author kettenis;	state Exp;
branches;
next	1.93;

1.93
date	2012.01.13.12.55.52;	author jsing;	state Exp;
branches;
next	1.92;

1.92
date	2012.01.11.19.33.28;	author krw;	state Exp;
branches;
next	1.91;

1.91
date	2012.01.11.15.58.27;	author jsing;	state Exp;
branches;
next	1.90;

1.90
date	2011.04.26.17.33.17;	author jsing;	state Exp;
branches;
next	1.89;

1.89
date	2011.04.07.15.30.15;	author miod;	state Exp;
branches;
next	1.88;

1.88
date	2010.11.22.21.08.07;	author miod;	state Exp;
branches;
next	1.87;

1.87
date	2010.03.28.12.08.49;	author kettenis;	state Exp;
branches;
next	1.86;

1.86
date	2009.11.23.17.57.22;	author mlarkin;	state Exp;
branches;
next	1.85;

1.85
date	2009.04.30.13.47.16;	author dlg;	state Exp;
branches;
next	1.84;

1.84
date	2009.01.13.13.53.50;	author kettenis;	state Exp;
branches;
next	1.83;

1.83
date	2008.10.28.00.05.32;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2008.08.16.00.26.26;	author krw;	state Exp;
branches;
next	1.81;

1.81
date	2008.06.08.13.55.06;	author kettenis;	state Exp;
branches;
next	1.80;

1.80
date	2008.05.21.18.49.47;	author kettenis;	state Exp;
branches;
next	1.79;

1.79
date	2008.03.29.15.26.47;	author krw;	state Exp;
branches;
next	1.78;

1.78
date	2008.03.02.18.01.05;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2008.01.23.16.37.56;	author jsing;	state Exp;
branches;
next	1.76;

1.76
date	2007.12.11.17.53.16;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2007.12.05.19.17.13;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2007.12.01.19.08.42;	author miod;	state Exp;
branches;
next	1.73;

1.73
date	2007.11.25.16.40.04;	author jmc;	state Exp;
branches;
next	1.72;

1.72
date	2007.11.15.20.02.33;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2007.11.03.05.48.49;	author ckuethe;	state Exp;
branches;
next	1.70;

1.70
date	2007.08.06.16.12.25;	author gwk;	state Exp;
branches;
next	1.69;

1.69
date	2007.03.29.15.00.15;	author gwk;	state Exp;
branches;
next	1.68;

1.68
date	2007.01.18.18.32.10;	author gwk;	state Exp;
branches;
next	1.67;

1.67
date	2006.08.22.19.15.36;	author tom;	state Exp;
branches;
next	1.66;

1.66
date	2006.07.17.20.31.57;	author fgsch;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.20.22.38.52;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2006.05.19.04.49.17;	author gwk;	state Exp;
branches;
next	1.63;

1.63
date	2006.05.11.23.19.36;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2006.05.08.21.13.03;	author gwk;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.09.00.35.29;	author gwk;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.08.22.53.10;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2006.05.08.22.51.18;	author gwk;	state Exp;
branches;
next	1.58;

1.58
date	2006.04.18.23.36.03;	author gwk;	state Exp;
branches;
next	1.57;

1.57
date	2005.11.13.14.23.26;	author martin;	state Exp;
branches;
next	1.56;

1.56
date	2005.08.19.01.10.42;	author marco;	state Exp;
branches;
next	1.55;

1.55
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.54;

1.54
date	2004.01.29.01.36.13;	author tom;	state Exp;
branches;
next	1.53;

1.53
date	2003.11.03.06.35.34;	author david;	state Exp;
branches;
next	1.52;

1.52
date	2003.07.11.17.51.11;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2003.06.03.20.10.31;	author mickey;	state Exp;
branches;
next	1.50;

1.50
date	2003.04.17.03.42.14;	author drahn;	state Exp;
branches;
next	1.49;

1.49
date	2002.05.20.16.38.01;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2001.09.19.20.50.56;	author mickey;	state Exp;
branches;
next	1.45;

1.45
date	2001.07.25.13.25.32;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2001.07.10.11.07.26;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2001.05.05.23.25.34;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2001.02.28.19.16.06;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2001.02.28.18.37.14;	author mickey;	state Exp;
branches;
next	1.40;

1.40
date	2001.02.28.16.45.25;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2001.01.21.20.23.22;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2000.10.25.19.13.11;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2000.10.21.17.43.50;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2000.10.17.16.30.19;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2000.10.16.19.29.09;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.25.16.33.05;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.22.02.00.21;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2000.08.18.01.23.22;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.17.22.08.09;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.17.20.15.39;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.27.20.38.10;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2000.07.25.22.36.30;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.16.05.07.29;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2000.02.18.17.10.09;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	99.10.26.18.16.48;	author mickey;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	99.08.25.00.54.18;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	98.11.15.16.33.01;	author art;	state Exp;
branches;
next	1.22;

1.22
date	98.02.24.22.02.09;	author weingart;	state Exp;
branches;
next	1.21;

1.21
date	98.01.09.12.14.42;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	97.11.10.16.09.55;	author flipk;	state Exp;
branches;
next	1.19;

1.19
date	97.10.26.09.32.47;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	97.10.25.19.50.08;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	97.10.25.08.45.53;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	97.10.25.07.01.36;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	97.10.25.03.01.30;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.10.24.23.24.29;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.10.24.22.15.05;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.10.24.06.49.20;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.10.22.23.37.11;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.10.19.06.34.21;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.10.18.00.33.11;	author weingart;	state Exp;
branches;
next	1.8;

1.8
date	97.09.29.03.42.25;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.09.24.23.00.01;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.09.24.22.52.56;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.09.22.12.09.45;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.09.21.23.00.41;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.09.21.22.08.07;	author weingart;	state Exp;
branches;
next	1.2;

1.2
date	97.09.21.05.18.07;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	97.09.21.04.27.53;	author mickey;	state Exp;
branches;
next	;

1.25.2.1
date	2000.02.20.10.30.44;	author niklas;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2000.02.20.11.56.47;	author niklas;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2000.07.03.14.19.07;	author niklas;	state Exp;
branches;
next	1.25.2.4;

1.25.2.4
date	2001.04.18.16.07.13;	author niklas;	state Exp;
branches;
next	1.25.2.5;

1.25.2.5
date	2001.07.04.10.16.32;	author niklas;	state Exp;
branches;
next	1.25.2.6;

1.25.2.6
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.25.2.7;

1.25.2.7
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.25.2.8;

1.25.2.8
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.25.2.9;

1.25.2.9
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.25.2.10;

1.25.2.10
date	2003.05.13.19.42.07;	author ho;	state Exp;
branches;
next	1.25.2.11;

1.25.2.11
date	2003.05.15.04.08.01;	author niklas;	state Exp;
branches;
next	1.25.2.12;

1.25.2.12
date	2003.06.07.11.11.36;	author ho;	state Exp;
branches;
next	1.25.2.13;

1.25.2.13
date	2004.02.19.10.48.41;	author niklas;	state Exp;
branches;
next	;

1.47.2.1
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	1.47.2.2;

1.47.2.2
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.116
log
@usingacpi might be referenced in apm only code, so adjust #if guard
from Nick Briggs
@
text
@/*	$OpenBSD: bios.c,v 1.115 2016/03/07 05:32:46 naddy Exp $	*/

/*
 * Copyright (c) 1997-2001 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/* #define BIOS_DEBUG */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/reboot.h>
#include <sys/extent.h>

#include <uvm/uvm_extern.h>
#include <sys/sysctl.h>

#include <dev/cons.h>
#include <stand/boot/bootarg.h>

#include <machine/cpu.h>
#include <machine/pio.h>
#include <machine/cpufunc.h>
#include <machine/conf.h>
#include <machine/gdt.h>
#include <machine/pcb.h>
#include <machine/biosvar.h>
#include <machine/apmvar.h>
#include <machine/mpbiosvar.h>
#include <machine/smbiosvar.h>

#include <dev/isa/isareg.h>
#include <i386/isa/isa_machdep.h>

#include <dev/pci/pcivar.h>

#include <dev/acpi/acpireg.h>
#include <dev/acpi/acpivar.h>

#include <dev/rndvar.h>

#include "apm.h"
#include "acpi.h"
#include "mpbios.h"
#include "pcibios.h"
#include "pci.h"

#include "com.h"
#if NCOM > 0
#include <sys/tty.h>
#include <dev/ic/comvar.h>
#include <dev/ic/comreg.h>
#endif

#include "softraid.h"
#if NSOFTRAID > 0
#include <dev/softraidvar.h>
#endif

struct bios_softc {
	struct	device sc_dev;
	vaddr_t bios32_service_va;
};

int biosprobe(struct device *, void *, void *);
void biosattach(struct device *, struct device *, void *);
int bios_print(void *, const char *);
char *fixstring(char *);

struct cfattach bios_ca = {
	sizeof(struct bios_softc), biosprobe, biosattach, NULL,
	config_activate_children
};

struct cfdriver bios_cd = {
	NULL, "bios", DV_DULL
};

extern dev_t bootdev;

#if NAPM > 0 || defined(DEBUG)
bios_apminfo_t *apm;
#endif
#if NPCI > 0
bios_pciinfo_t *bios_pciinfo;
#endif
bios_diskinfo_t *bios_diskinfo;
bios_memmap_t  *bios_memmap;
struct bios_softc *bios_softc;
u_int32_t	bios_cksumlen;
struct bios32_entry bios32_entry;
struct smbios_entry smbios_entry;
#ifdef MULTIPROCESSOR
void		*bios_smpinfo;
#endif
bios_bootmac_t	*bios_bootmac;
#ifdef DDB
extern int	db_console;
#endif

void		smbios_info(char*);

bios_diskinfo_t *bios_getdiskinfo(dev_t);

/*
 * used by hw_sysctl
 */
extern char *hw_vendor, *hw_prod, *hw_uuid, *hw_serial, *hw_ver;
const char *smbios_uninfo[] = {
	"System",
	"Not ",
	"To be",
	"SYS-"
};


int
biosprobe(struct device *parent, void *match, void *aux)
{
	struct bios_attach_args *bia = aux;

#ifdef BIOS_DEBUG
	printf("%s%d: boot API ver %x, %x; args %p[%d]\n",
	    bia->ba_name, bios_cd.cd_ndevs,
	    bootapiver, BOOTARG_APIVER, bootargp, bootargc);
#endif
	/* only one */
	if (bios_cd.cd_ndevs || strcmp(bia->ba_name, bios_cd.cd_name))
		return 0;

	if (!(bootapiver & BAPIV_VECTOR) || bootargp == NULL)
		return 0;

	return 1;
}

void
biosattach(struct device *parent, struct device *self, void *aux)
{
	struct bios_softc *sc = (struct bios_softc *)self;
#if (NPCI > 0 && NPCIBIOS > 0) || NAPM > 0
	struct bios_attach_args *bia = aux;
#endif
	struct smbios_struct_bios *sb;
	struct smbtable bios;
	volatile u_int8_t *va;
	char scratch[64], *str;
	int flags, smbiosrev = 0, ncpu = 0, isa_hole_exec = 0;
#if NACPI > 0 || NAPM > 0
	int usingacpi = 0;
#endif

	bios_softc = sc;
	/* remember flags */
	flags = sc->sc_dev.dv_cfdata->cf_flags;

	va = ISA_HOLE_VADDR(0xffff0);
	printf(": date %c%c/%c%c/%c%c",
	    va[5], va[6], va[8], va[9], va[11], va[12]);

	/*
	 * Determining whether BIOS32 extensions are available is
	 * done by searching for the BIOS32 service directory.
	 * This 16-byte structure can be found somewhere in the
	 * range 0E0000h - 0FFFFFh and must be 16-byte aligned.
	 *
	 *  _______________________________________________________
	 * | Offset | Bytes | Description                          |
	 * |-------------------------------------------------------|
	 * |    0   |   4   | ASCII signature string of "_32_".    |
	 * |    4   |   4   | 32-bit entry point.                  |
	 * |    8   |   1   | Revision Level. Typically 00h.       |
	 * |    9   |   1   | Header length in 16-byte units. So   |
	 * |        |       | would have the value of 01h.         |
	 * |    A   |   1   | Checksum. The sum of all bytes in    |
	 * |        |       | this header must be zero.            |
	 * |    B   |   5   | Reserved. Set to zero.               |
	 *  -------------------------------------------------------
	 *
	 * To find the service directory, we first search for the
	 * signature. If we find a match, we must also verify the
	 * checksum. This service directory may then be used to
	 * determine whether a PCI BIOS is present.
	 *
	 * For more information see the PCI BIOS Specification,
	 * Revision 2.1 (August 26, 1994).
	 */

	if (!(flags & BIOSF_BIOS32)) {
		for (va = ISA_HOLE_VADDR(BIOS32_START);
		    va < (u_int8_t *)ISA_HOLE_VADDR(BIOS32_END); va += 16) {
			bios32_header_t h = (bios32_header_t)va;
			u_int8_t cksum;
			int i;

			if (h->signature != BIOS32_SIGNATURE)
				continue;

			/* verify checksum */
			for (cksum = 0, i = h->length * 16; i--; cksum += va[i])
				;
			if (cksum != 0)
				continue;

			if (h->entry <= BIOS32_START || h->entry >= BIOS32_END)
				continue;

			bios32_entry.segment = GSEL(GCODE_SEL, SEL_KPL);
			bios32_entry.offset = (u_int32_t)ISA_HOLE_VADDR(h->entry);
			printf(", BIOS32 rev. %d @@ 0x%x", h->rev, h->entry);
			break;
		}
	}

	/* see if we have SMBIOS extensions */
	if (!(flags & BIOSF_SMBIOS)) {
		for (va = ISA_HOLE_VADDR(SMBIOS_START);
		    va < (u_int8_t *)ISA_HOLE_VADDR(SMBIOS_END); va+= 16) {
			struct smbhdr *sh = (struct smbhdr *)va;
			u_int8_t chksum;
			vaddr_t eva;
			paddr_t pa, end;
			int i;

			if (sh->sig != SMBIOS_SIGNATURE)
				continue;
			i = sh->len;
			for (chksum = 0; i--; chksum += va[i])
				;
			if (chksum != 0)
				continue;
			va += 0x10;
			if (!(va[0] == '_' && va[1] == 'D' && va[2] == 'M' &&
			    va[3] == 'I' && va[4] == '_'))
				continue;
			for (chksum = 0, i = 0xf; i--; chksum += va[i])
				;
			if (chksum != 0)
				continue;

			pa = trunc_page(sh->addr);
			end = round_page(sh->addr + sh->size);
			eva = uvm_km_valloc(kernel_map, end-pa);
			if (eva == 0)
				break;

			smbios_entry.addr = (u_int8_t *)(eva +
			    (sh->addr & PGOFSET));
			smbios_entry.len = sh->size;
			smbios_entry.mjr = sh->majrev;
			smbios_entry.min = sh->minrev;
			smbios_entry.count = sh->count;

			for (; pa < end; pa+= NBPG, eva+= NBPG)
				pmap_kenter_pa(eva, pa, PROT_READ);

			printf(", SMBIOS rev. %d.%d @@ 0x%x (%hd entries)",
			    sh->majrev, sh->minrev, sh->addr, sh->count);
			/*
			 * Unbelievably the SMBIOS version number
			 * sequence is like 2.3 ... 2.33 ... 2.4 ... 2.5
			 */
			smbiosrev = sh->majrev * 100 + sh->minrev;
			if (sh->minrev < 10)
				smbiosrev = sh->majrev * 100 + sh->minrev * 10;

			bios.cookie = 0;
			if (smbios_find_table(SMBIOS_TYPE_BIOS, &bios)) {
				sb = bios.tblhdr;
				printf("\n%s:", sc->sc_dev.dv_xname);

				if ((smbios_get_string(&bios, sb->vendor,
				    scratch, sizeof(scratch))) != NULL)
					printf(" vendor %s",
					    fixstring(scratch));
				if ((smbios_get_string(&bios, sb->version,
				    scratch, sizeof(scratch))) != NULL)
					printf(" version \"%s\"",
					    fixstring(scratch));
				if ((smbios_get_string(&bios, sb->release,
				    scratch, sizeof(scratch))) != NULL)
					printf(" date %s", fixstring(scratch));
			}
			smbios_info(sc->sc_dev.dv_xname);

			/* count cpus so that we can disable apm when cpu > 1 */
			bzero(&bios, sizeof(bios));
			while (smbios_find_table(SMBIOS_TYPE_PROCESSOR,&bios)) {
				struct smbios_cpu *cpu = bios.tblhdr;

				if (cpu->cpu_status & SMBIOS_CPUST_POPULATED) {
					/* SMBIOS 2.5 added multicore support */
					if (smbiosrev >= 250 &&
					    cpu->cpu_core_enabled)
						ncpu += cpu->cpu_core_enabled;
					else {
						ncpu++;
						if (cpu->cpu_id_edx & CPUID_HTT)
							ncpu++;
					}
				}
			}
			break;
		}
	}

	printf("\n");

	/* No SMBIOS extensions, go looking for Soekris comBIOS */
	if (!(flags & BIOSF_SMBIOS) && smbiosrev == 0) {
		const char *signature = "Soekris Engineering";

		for (va = ISA_HOLE_VADDR(SMBIOS_START);
		    va <= (u_int8_t *)ISA_HOLE_VADDR(SMBIOS_END -
		    (strlen(signature) - 1)); va++)
			if (!memcmp((u_int8_t *)va, signature,
			    strlen(signature))) {
				hw_vendor = malloc(strlen(signature) + 1,
				    M_DEVBUF, M_NOWAIT);
				if (hw_vendor)
					strlcpy(hw_vendor, signature,
					    strlen(signature) + 1);
				va += strlen(signature);
				break;
			}

		for (; hw_vendor &&
		    va <= (u_int8_t *)ISA_HOLE_VADDR(SMBIOS_END - 6); va++)
			/*
			 * Search for "net(4(5xx|801)|[56]501)" which matches
			 * the strings found in the comBIOS images
			 */
			if (!memcmp((u_int8_t *)va, "net45xx", 7) ||
			    !memcmp((u_int8_t *)va, "net4801", 7) ||
			    !memcmp((u_int8_t *)va, "net5501", 7) ||
			    !memcmp((u_int8_t *)va, "net6501", 7)) {
				hw_prod = malloc(8, M_DEVBUF, M_NOWAIT);
				if (hw_prod) {
					memcpy(hw_prod, (u_int8_t *)va, 7);
					hw_prod[7] = '\0';
				}
				break;
			}
	}

#if NACPI > 0
#if NPCI > 0
	if (smbiosrev >= 210 && pci_mode_detect() != 0)
#endif
	{
		struct bios_attach_args ba;

		memset(&ba, 0, sizeof(ba));
		ba.ba_name = "acpi";
		ba.ba_func = 0x00;		/* XXX ? */
		ba.ba_iot = I386_BUS_SPACE_IO;
		ba.ba_memt = I386_BUS_SPACE_MEM;
		if (config_found(self, &ba, bios_print)) {
			flags |= BIOSF_PCIBIOS;
			usingacpi = 1;
		}
	}
#endif

#if NAPM > 0
	if (usingacpi == 0 && apm && ncpu < 2 && smbiosrev < 240) {
		struct bios_attach_args ba;

#if defined(DEBUG) || defined(APMDEBUG)
		printf("apminfo: %x, code %x[%x]/%x[%x], data %x[%x], ept %x\n",
		    apm->apm_detail,
		    apm->apm_code32_base, apm->apm_code_len,
		    apm->apm_code16_base, apm->apm_code16_len,
		    apm->apm_data_base, apm->apm_data_len, apm->apm_entry);
#endif
		ba.ba_name = "apm";
		ba.ba_func = 0x15;
		ba.ba_memt = bia->ba_memt;
		ba.ba_iot = bia->ba_iot;
		ba.ba_apmp = apm;
		config_found(self, &ba, bios_print);
		isa_hole_exec = 1;
	}
#endif


#if NMPBIOS > 0
	if (mpbios_probe(self)) {
		struct bios_attach_args ba;

		memset(&ba, 0, sizeof(ba));
		ba.ba_name = "mpbios";
		ba.ba_iot = I386_BUS_SPACE_IO;
		ba.ba_memt = I386_BUS_SPACE_MEM;

		config_found(self, &ba, bios_print);
	}
#endif

#if NPCI > 0 && NPCIBIOS > 0
	if (!(flags & BIOSF_PCIBIOS)) {
		struct bios_attach_args ba;

		ba.ba_name = "pcibios";
		ba.ba_func = 0x1A;
		ba.ba_memt = bia->ba_memt;
		ba.ba_iot = bia->ba_iot;
		config_found(self, &ba, bios_print);
	}
#endif

	/*
	 * now that we gave 'em a chance to attach,
	 * scan and map all the proms we can find
	 */
	if (!(flags & BIOSF_PROMSCAN)) {
		volatile u_int8_t *eva;

		for (str = NULL, va = ISA_HOLE_VADDR(0xc0000),
		    eva = ISA_HOLE_VADDR(0xf0000);
		    va < eva; va += 512) {
			extern struct extent *iomem_ex;
			bios_romheader_t romh = (bios_romheader_t)va;
			u_int32_t off, len;
			u_int8_t cksum;
			int i;

			if (romh->signature != 0xaa55)
				continue;

			/*
			 * for this and the next check we probably want
			 * to reserve the page in the extent anyway
			 */
			if (!romh->len || romh->len == 0xff)
				continue;

			len = romh->len * 512;
			if (va + len > eva)
				continue;

			for (cksum = 0, i = len; i--; cksum += va[i])
				;
			off = 0xc0000 + (va - (u_int8_t *)
			    ISA_HOLE_VADDR(0xc0000));

			if (!str)
				printf("%s: ROM list:",
				    str = sc->sc_dev.dv_xname);
			printf(" 0x%05x/0x%x%s", off, len,
			    cksum? "!" : "");

			if ((i = extent_alloc_region(iomem_ex,
			    (paddr_t)off, len, EX_NOWAIT)))
				printf(":%d", i);

			isa_hole_exec = 1;
			va += len - 512;
		}
		if (str)
			printf("\n");
	}

	/*
	 * If we had no BIOS / proms that need exec permission in the ISA
	 * hole, remove X permissions.
	 */
	if (!isa_hole_exec)
		pmap_write_protect(pmap_kernel(), (vaddr_t)atdevbase,
		    (vaddr_t)atdevbase + IOM_SIZE, PROT_READ | PROT_WRITE);
}

void
bios_getopt(void)
{
	bootarg_t *q;
	bios_ddb_t *bios_ddb;
	bios_bootduid_t *bios_bootduid;
	bios_bootsr_t *bios_bootsr;

#ifdef BIOS_DEBUG
	printf("bootargv:");
#endif

	for(q = bootargp; q->ba_type != BOOTARG_END; q = q->ba_next) {
		q->ba_next = (bootarg_t *)((caddr_t)q + q->ba_size);
		switch (q->ba_type) {
		case BOOTARG_MEMMAP:
			bios_memmap = (bios_memmap_t *)q->ba_arg;
#ifdef BIOS_DEBUG
			printf(" memmap %p", bios_memmap);
#endif
			break;
		case BOOTARG_DISKINFO:
			bios_diskinfo = (bios_diskinfo_t *)q->ba_arg;
#ifdef BIOS_DEBUG
			printf(" diskinfo %p", bios_diskinfo);
#endif
			break;
#if NAPM > 0 || defined(DEBUG)
		case BOOTARG_APMINFO:
#ifdef BIOS_DEBUG
			printf(" apminfo %p", q->ba_arg);
#endif
			apm = (bios_apminfo_t *)q->ba_arg;
			break;
#endif
		case BOOTARG_CKSUMLEN:
			bios_cksumlen = *(u_int32_t *)q->ba_arg;
#ifdef BIOS_DEBUG
			printf(" cksumlen %d", bios_cksumlen);
#endif
			break;
#if NPCI > 0
		case BOOTARG_PCIINFO:
			bios_pciinfo = (bios_pciinfo_t *)q->ba_arg;
#ifdef BIOS_DEBUG
			printf(" pciinfo %p", bios_pciinfo);
#endif
			break;
#endif
		case BOOTARG_CONSDEV:
			if (q->ba_size >= sizeof(bios_consdev_t) +
			    offsetof(bootarg_t, ba_arg)) {
				bios_consdev_t *cdp =
				    (bios_consdev_t*)q->ba_arg;
#if NCOM > 0
				static const int ports[] =
				    { 0x3f8, 0x2f8, 0x3e8, 0x2e8 };
				int unit = minor(cdp->consdev);
				int consaddr = cdp->consaddr;
				if (consaddr == -1 && unit >=0 &&
				    unit < (sizeof(ports)/sizeof(ports[0])))
					consaddr = ports[unit];
				if (major(cdp->consdev) == 8 &&
				    consaddr != -1) {
					comconsunit = unit;
					comconsaddr = consaddr;
					comconsrate = cdp->conspeed;
					comconsiot = I386_BUS_SPACE_IO;

					/* Probe the serial port this time. */
					cninit();
				}
#endif
#ifdef BIOS_DEBUG
				printf(" console 0x%x:%d",
				    cdp->consdev, cdp->conspeed);
#endif
			}
			break;
#ifdef MULTIPROCESSOR
		case BOOTARG_SMPINFO:
			bios_smpinfo = q->ba_arg;
			printf(" smpinfo %p", bios_smpinfo);
			break;
#endif

		case BOOTARG_BOOTMAC:
			bios_bootmac = (bios_bootmac_t *)q->ba_arg;
			break;

		case BOOTARG_DDB:
			bios_ddb = (bios_ddb_t *)q->ba_arg;
#ifdef DDB
			db_console = bios_ddb->db_console;
#endif
			break;

		case BOOTARG_BOOTDUID:
			bios_bootduid = (bios_bootduid_t *)q->ba_arg;
			bcopy(bios_bootduid, bootduid, sizeof(bootduid));
			break;

		case BOOTARG_BOOTSR:
			bios_bootsr = (bios_bootsr_t *)q->ba_arg;
#if NSOFTRAID > 0
			bcopy(&bios_bootsr->uuid, &sr_bootuuid,
			    sizeof(sr_bootuuid));
			bcopy(&bios_bootsr->maskkey, &sr_bootkey,
			    sizeof(sr_bootkey));
#endif
			explicit_bzero(bios_bootsr, sizeof(bios_bootsr_t));
			break;

		default:
#ifdef BIOS_DEBUG
			printf(" unsupported arg (%d) %p", q->ba_type,
			    q->ba_arg);
#endif
			break;
		}
	}
	printf("\n");

}

int
bios_print(void *aux, const char *pnp)
{
	struct bios_attach_args *ba = aux;

	if (pnp)
		printf("%s at %s function 0x%x",
		    ba->ba_name, pnp, ba->ba_func);
	return (UNCONF);
}

int
bios32_service(u_int32_t service, bios32_entry_t e, bios32_entry_info_t ei)
{
	u_long pa, endpa;
	vaddr_t va, sva;
	u_int32_t base, count, off, ent;
	int slot;

	if (bios32_entry.offset == 0)
		return 0;

	base = 0;
	__asm volatile("lcall *(%4)"
	    : "+a" (service), "+b" (base), "=c" (count), "=d" (off)
	    : "D" (&bios32_entry)
	    : "%esi", "cc", "memory");

	if (service & 0xff)
		return 0;	/* not found */

	ent = base + off;
	if (ent <= BIOS32_START || ent >= BIOS32_END)
		return 0;

	endpa = round_page(BIOS32_END);

	sva = va = uvm_km_valloc(kernel_map, endpa);
	if (va == 0)
		return (0);

	/* Store bios32 service kva for cleanup later */
	bios_softc->bios32_service_va = sva;

	slot = gdt_get_slot();
	setgdt(slot, (caddr_t)va, BIOS32_END, SDT_MEMERA, SEL_KPL, 1, 0);

	for (pa = trunc_page(BIOS32_START),
	    va += trunc_page(BIOS32_START);
	    pa < endpa; pa += NBPG, va += NBPG) {
		pmap_enter(pmap_kernel(), va, pa,
		    PROT_READ | PROT_WRITE | PROT_EXEC,
		    PROT_READ | PROT_WRITE | PROT_EXEC | PMAP_WIRED);

		if (pa >= trunc_page(base)) {
			pmap_enter(pmap_kernel(), sva, pa,
			    PROT_READ | PROT_WRITE | PROT_EXEC,
			    PROT_READ | PROT_WRITE | PROT_EXEC | PMAP_WIRED);
			sva += NBPG;
		}
	}

	e->segment = GSEL(slot, SEL_KPL);
	e->offset = (vaddr_t)ent;

	ei->bei_base = base;
	ei->bei_size = count;
	ei->bei_entry = ent;

	return 1;
}

void
bios32_cleanup(void)
{
	u_long pa, size;
	vaddr_t va;

	size = round_page(BIOS32_END);

	for (va = bios_softc->bios32_service_va;
	    va < bios_softc->bios32_service_va + size;
	    va += NBPG) {
		if (pmap_extract(pmap_kernel(), va, &pa))
			pmap_remove(pmap_kernel(), va, va + PAGE_SIZE);
	}

	uvm_km_free(kernel_map, bios_softc->bios32_service_va, size);
}

int
biosopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct bios_softc *sc = bios_cd.cd_devs[0];

	if (minor(dev))
		return (ENXIO);

	(void)sc;

	return 0;
}

int
biosclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct bios_softc *sc = bios_cd.cd_devs[0];

	if (minor(dev))
		return (ENXIO);

	(void)sc;

	return 0;
}

int
biosioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct bios_softc *sc = bios_cd.cd_devs[0];

	if (minor(dev))
		return (ENXIO);

	switch (cmd) {
	default:
		return ENXIO;
	}

	(void)sc;

	return 0;
}

int
bios_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	bios_diskinfo_t *pdi;
	int biosdev;

	/* all sysctl names at this level except diskinfo are terminal */
	if (namelen != 1 && name[0] != BIOS_DISKINFO)
		return (ENOTDIR);		/* overloaded */

	if (!(bootapiver & BAPIV_VECTOR))
		return EOPNOTSUPP;

	switch (name[0]) {
	case BIOS_DEV:
		if ((pdi = bios_getdiskinfo(bootdev)) == NULL)
			return ENXIO;
		biosdev = pdi->bios_number;
		return sysctl_rdint(oldp, oldlenp, newp, biosdev);
	case BIOS_DISKINFO:
		if (namelen != 2)
			return ENOTDIR;
		if ((pdi = bios_getdiskinfo(name[1])) == NULL)
			return ENXIO;
		return sysctl_rdstruct(oldp, oldlenp, newp, pdi, sizeof(*pdi));
	case BIOS_CKSUMLEN:
		return sysctl_rdint(oldp, oldlenp, newp, bios_cksumlen);
	default:
		return EOPNOTSUPP;
	}
	/* NOTREACHED */
}

bios_diskinfo_t *
bios_getdiskinfo(dev_t dev)
{
	bios_diskinfo_t *pdi;

	if (bios_diskinfo == NULL)
		return NULL;

	for (pdi = bios_diskinfo; pdi->bios_number != -1; pdi++) {
		if ((dev & B_MAGICMASK) == B_DEVMAGIC) { /* search by bootdev */
			if (pdi->bsd_dev == dev)
				break;
		} else {
			if (pdi->bios_number == dev)
				break;
		}
	}

	if (pdi->bios_number == -1)
		return NULL;
	else
		return pdi;
}

/*
 * smbios_find_table() takes a caller supplied smbios struct type and
 * a pointer to a handle (struct smbtable) returning one if the structure
 * is successfully located and zero otherwise. Callers should take care
 * to initialize the cookie field of the smbtable structure to zero before
 * the first invocation of this function.
 * Multiple tables of the same type can be located by repeatedly calling
 * smbios_find_table with the same arguments.
 */
int
smbios_find_table(u_int8_t type, struct smbtable *st)
{
	u_int8_t *va, *end;
	struct smbtblhdr *hdr;
	int ret = 0, tcount = 1;

	va = smbios_entry.addr;
	end = va + smbios_entry.len;

	/*
	 * The cookie field of the smtable structure is used to locate
	 * multiple instances of a table of an arbitrary type. Following the
	 * successful location of a table, the type is encoded as bits 0:7 of
	 * the cookie value, the offset in terms of the number of structures
	 * preceding that referenced by the handle is encoded in bits 15:31.
	 */
	if ((st->cookie & 0xfff) == type && st->cookie >> 16) {
		if ((u_int8_t *)st->hdr >= va && (u_int8_t *)st->hdr < end) {
			hdr = st->hdr;
			if (hdr->type == type) {
				va = (u_int8_t *)hdr + hdr->size;
				for (; va + 1 < end; va++)
					if (*va == 0 && *(va + 1) == 0)
						break;
				va+= 2;
				tcount = st->cookie >> 16;
			}
		}
	}
	for (; va + sizeof(struct smbtblhdr) < end && tcount <=
	    smbios_entry.count; tcount++) {
		hdr = (struct smbtblhdr *)va;
		if (hdr->type == type) {
			ret = 1;
			st->hdr = hdr;
			st->tblhdr = va + sizeof(struct smbtblhdr);
			st->cookie = (tcount + 1) << 16 | type;
			break;
		}
		if (hdr->type == SMBIOS_TYPE_EOT)
			break;
		va+= hdr->size;
		for (; va + 1 < end; va++)
			if (*va == 0 && *(va + 1) == 0)
				break;
		va+=2;
	}

	return ret;
}

char *
smbios_get_string(struct smbtable *st, u_int8_t indx, char *dest, size_t len)
{
	u_int8_t *va, *end;
	char *ret = NULL;
	int i;

	va = (u_int8_t *)st->hdr + st->hdr->size;
	end = smbios_entry.addr + smbios_entry.len;
	for (i = 1; va < end && i < indx && *va; i++)
		while (*va++)
			;
	if (i == indx) {
		if (va + len < end) {
			ret = dest;
			bcopy(va, ret, len);
			ret[len - 1] = '\0';
		}
	}

	return ret;
}

char *
fixstring(char *s)
{
	char *p, *e;
	int i;

	for (i= 0; i < sizeof(smbios_uninfo)/sizeof(smbios_uninfo[0]); i++)
		if ((strncasecmp(s, smbios_uninfo[i], strlen(smbios_uninfo[i])))==0)
			return NULL;
	/*
	 * Remove leading and trailing whitespace
	 */
	for (p = s; *p == ' '; p++)
		;
	/*
	 * Special case entire string is whitespace
	 */
	if (p == s + strlen(s))
		return NULL;
	for (e = s + strlen(s) - 1; e > s && *e == ' '; e--)
		;
	if (p > s || e < s + strlen(s) - 1) {
		bcopy(p, s, e-p + 1);
		s[e - p + 1] = '\0';
	}

	return s;
}

void
smbios_info(char * str)
{
	char *sminfop, sminfo[64];
	struct smbtable stbl, btbl;
	struct smbios_sys *sys;
	struct smbios_board *board;
	int i, infolen, uuidf, havebb;
	char *p;

	if (smbios_entry.mjr < 2)
		return;
	/*
	 * According to the spec the system table among others is required,
	 * if it is not we do not bother with this smbios implementation.
	 */
	stbl.cookie = btbl.cookie = 0;
	if (!smbios_find_table(SMBIOS_TYPE_SYSTEM, &stbl))
		return;
	havebb = smbios_find_table(SMBIOS_TYPE_BASEBOARD, &btbl);

	sys = (struct smbios_sys *)stbl.tblhdr;
	if (havebb)
		board = (struct smbios_board *)btbl.tblhdr;
	/*
	 * Some smbios implementations have no system vendor or product strings,
	 * some have very uninformative data which is harder to work around
	 * and we must rely upon various heuristics to detect this. In both
	 * cases we attempt to fall back on the base board information in the
	 * perhaps naive belief that motherboard vendors will supply this
	 * information.
	 */
	sminfop = NULL;
	if ((p = smbios_get_string(&stbl, sys->vendor, sminfo,
	    sizeof(sminfo))) != NULL)
		sminfop = fixstring(p);
	if (sminfop == NULL) {
		if (havebb) {
			if ((p = smbios_get_string(&btbl, board->vendor,
			    sminfo, sizeof(sminfo))) != NULL)
				sminfop = fixstring(p);
		}
	}
	if (sminfop) {
		infolen = strlen(sminfop) + 1;
		hw_vendor = malloc(infolen, M_DEVBUF, M_NOWAIT);
		if (hw_vendor)
			strlcpy(hw_vendor, sminfop, infolen);
		sminfop = NULL;
	}
	if ((p = smbios_get_string(&stbl, sys->product, sminfo,
	    sizeof(sminfo))) != NULL)
		sminfop = fixstring(p);
	if (sminfop == NULL) {
		if (havebb) {
			if ((p = smbios_get_string(&btbl, board->product,
			    sminfo, sizeof(sminfo))) != NULL)
				sminfop = fixstring(p);
		}
	}
	if (sminfop) {
		infolen = strlen(sminfop) + 1;
		hw_prod = malloc(infolen, M_DEVBUF, M_NOWAIT);
		if (hw_prod)
			strlcpy(hw_prod, sminfop, infolen);
		sminfop = NULL;
	}
	if (hw_vendor != NULL && hw_prod != NULL)
		printf("\n%s: %s %s", str, hw_vendor, hw_prod);
	if ((p = smbios_get_string(&stbl, sys->version, sminfo,
	    sizeof(sminfo))) != NULL)
		sminfop = fixstring(p);
	if (sminfop) {
		infolen = strlen(sminfop) + 1;
		hw_ver = malloc(infolen, M_DEVBUF, M_NOWAIT);
		if (hw_ver)
			strlcpy(hw_ver, sminfop, infolen);
		sminfop = NULL;
	}
	if ((p = smbios_get_string(&stbl, sys->serial, sminfo,
	    sizeof(sminfo))) != NULL)
		sminfop = fixstring(p);
	if (sminfop) {
		infolen = strlen(sminfop) + 1;
		for (i = 0; i < infolen - 1; i++)
			add_timer_randomness(sminfop[i]);
		hw_serial = malloc(infolen, M_DEVBUF, M_NOWAIT);
		if (hw_serial)
			strlcpy(hw_serial, sminfop, infolen);
	}
	if (smbios_entry.mjr > 2 || (smbios_entry.mjr == 2 &&
	    smbios_entry.min >= 1)) {
		/*
		 * If the uuid value is all 0xff the uuid is present but not
		 * set, if its all 0 then the uuid isn't present at all.
		 */
		uuidf = SMBIOS_UUID_NPRESENT|SMBIOS_UUID_NSET;
		for (i = 0; i < sizeof(sys->uuid); i++) {
			if (sys->uuid[i] != 0xff)
				uuidf &= ~SMBIOS_UUID_NSET;
			if (sys->uuid[i] != 0)
				uuidf &= ~SMBIOS_UUID_NPRESENT;
		}

		if (uuidf & SMBIOS_UUID_NPRESENT)
			hw_uuid = NULL;
		else if (uuidf & SMBIOS_UUID_NSET)
			hw_uuid = "Not Set";
		else {
			for (i = 0; i < sizeof(sys->uuid); i++)
				add_timer_randomness(sys->uuid[i]);
			hw_uuid = malloc(SMBIOS_UUID_REPLEN, M_DEVBUF,
			    M_NOWAIT);
			if (hw_uuid) {
				snprintf(hw_uuid, SMBIOS_UUID_REPLEN,
				    SMBIOS_UUID_REP,
				    sys->uuid[0], sys->uuid[1], sys->uuid[2],
				    sys->uuid[3], sys->uuid[4], sys->uuid[5],
				    sys->uuid[6], sys->uuid[7], sys->uuid[8],
				    sys->uuid[9], sys->uuid[10], sys->uuid[11],
				    sys->uuid[12], sys->uuid[13], sys->uuid[14],
				    sys->uuid[15]);
			}
		}
	}
}
@


1.115
log
@Sync no-argument function declaration and definition by adding (void).
ok mlarkin@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.114 2016/02/20 19:59:01 mlarkin Exp $	*/
d174 1
a174 1
#if NACPI > 0
@


1.114
log
@
Fixes a boot issue on non-ACPI i386 machines that need X permissions on
the BIOS region in the ISA hole.

Also fix a separate unrelated issue relating to placing R/O (no X)
permissions on the kernel symbol area on bsd.rd.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.113 2015/09/16 04:18:52 daniel Exp $	*/
d499 1
a499 1
bios_getopt()
@


1.113
log
@Fix uninitialized variable found by Maxime Villard's Brainy Code Scanner.

ok uebayasi@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.112 2015/09/03 03:13:56 yasuoka Exp $	*/
d173 1
a173 1
	int flags, smbiosrev = 0, ncpu = 0;
d407 1
d482 1
d489 7
@


1.112
log
@Fix the condition of finding SMBIOS.  Found by gerhard@@.

ok gerhard uebayasi deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.111 2015/07/17 22:31:16 mlarkin Exp $	*/
d483 2
a486 2
	if (str)
		printf("\n");
@


1.111
log
@
Remove/reword some odd comments and a #define that looks like it was left
over from someone's debugging.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.110 2015/07/17 21:36:56 mlarkin Exp $	*/
d258 2
a259 2
			if (va[0] != '_' && va[1] != 'D' && va[2] != 'M' &&
			    va[3] != 'I' && va[4] != '_')
@


1.110
log
@
Include executable mapping for BIOS32 pages. Fixes a problem where mappings
done in this region using PAE w/NX caused #PFs (as they lacked the exec
permission previously).

Also unmap the region when we're finished. No sense in leaving extra
executable regions lying around.

Fixes non-ACPI uniprocessor i386 machines that have NX/PAE (these would
previously panic in pcibiosattach).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.109 2015/01/21 18:39:54 tedu Exp $	*/
d152 1
a152 1
	/* there could be only one */
a467 5
#ifdef __stinkpad_sucks__
			if (cksum != 0)
				continue;
#endif

a667 1
		/* for all you, broken hearted */
@


1.109
log
@I don't foresee knowing that my i386 netbook has an AT/286+ bios and
not a PCjr bios will help diagnose any problems.
ok deraadt kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.108 2015/01/17 17:44:15 tedu Exp $	*/
d87 1
d114 1
d178 1
a653 1

d660 3
d670 2
a671 2
		    PROT_READ | PROT_WRITE,
		    PROT_READ | PROT_WRITE | PMAP_WIRED);
d676 2
a677 2
			    PROT_READ | PROT_WRITE,
			    PROT_READ | PROT_WRITE | PMAP_WIRED);
d690 18
@


1.108
log
@guard usingacpi variable inside NACPI. from oyvind jaegtnes
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.107 2014/11/16 12:30:57 deraadt Exp $	*/
d180 2
a181 13
	switch (va[14]) {
	default:
	case 0xff: str = "PC";		break;
	case 0xfe: str = "PC/XT";	break;
	case 0xfd: str = "PCjr";	break;
	case 0xfc: str = "AT/286+";	break;
	case 0xfb: str = "PC/XT+";	break;
	case 0xfa: str = "PS/2 25/30";	break;
	case 0xf9: str = "PC Convertible";break;
	case 0xf8: str = "PS/2 386+";	break;
	}
	printf(": %s BIOS, date %c%c/%c%c/%c%c",
	    str, va[5], va[6], va[8], va[9], va[11], va[12]);
@


1.107
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.106 2014/10/17 20:34:23 kettenis Exp $	*/
d171 4
a174 1
	int flags, smbiosrev = 0, ncpu = 0, usingacpi = 0;
@


1.106
log
@Initialize comconsiot.  Fixes problems with the (now backed out) i386
bus_space(9) diff.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.105 2014/09/14 14:17:23 jsg Exp $	*/
d285 1
a285 1
				pmap_kenter_pa(eva, pa, VM_PROT_READ);
d673 2
a674 2
		    VM_PROT_READ | VM_PROT_WRITE,
		    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
d679 2
a680 2
			    VM_PROT_READ | VM_PROT_WRITE,
			    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
@


1.105
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.104 2014/03/29 18:09:29 guenther Exp $	*/
d566 1
@


1.104
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.103 2013/11/02 15:02:27 kettenis Exp $	*/
a35 1
#include <sys/proc.h>
@


1.103
log
@Cleanup bios_oconsdev_t.  Make sure you have a halfway recent bootloader
(at least BOOT 3.20 on amd64 and BOOT 3.18 on i386) or you'll risk losing
your serial console.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.102 2013/10/16 13:41:17 deraadt Exp $	*/
d647 1
a647 1
	__asm __volatile("lcall *(%4)"
@


1.102
log
@Prefer ACPI over APM.  For years, we had a SMBIOS-probing hack to prefer
APM on machines where it suspended better.  These days, suspend/resume
works better in ACPI.  Specific machine: x40.
There is a class of very early ACPI machines which are going to break,
because of buggy AML and bugs in our acpi code.  By making this change,
we will expose those, and hopefully get them fixed.
ok many
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.99 2013/04/24 08:23:45 blambert Exp $	*/
d550 1
a550 1
			if (q->ba_size >= sizeof(bios_oconsdev_t) +
d558 1
a558 4
				int consaddr = -1;
				if (q->ba_size >= sizeof(bios_consdev_t) +
				    offsetof(bootarg_t, ba_arg))
					consaddr = cdp->consaddr;
@


1.101
log
@Format string fixes: %hu/%hd for uint16_t, %u/%d/%x for uint32_t

- despite the name, ntohl returns uint32_t, not long
- also fix some %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.100 2013/09/29 12:56:31 kettenis Exp $	*/
d172 1
a172 1
	int flags, smbiosrev = 0, ncpu = 0;
d377 19
d397 1
a397 1
	if (apm && ncpu < 2 && smbiosrev < 240) {
a415 16
#if NACPI > 0
#if NPCI > 0
	if (smbiosrev && pci_mode_detect() != 0)
#endif
	{
		struct bios_attach_args ba;

		memset(&ba, 0, sizeof(ba));
		ba.ba_name = "acpi";
		ba.ba_func = 0x00;		/* XXX ? */
		ba.ba_iot = I386_BUS_SPACE_IO;
		ba.ba_memt = I386_BUS_SPACE_MEM;
		if (config_found(self, &ba, bios_print))
			flags |= BIOSF_PCIBIOS;
	}
#endif
@


1.100
log
@Get rid of cnset().  It is only used on amd64/i386 and doesn't really do
anything useful there.  Switching from glass console to serial console is
already done by cninit(), and the reinitializaton of cn_tab by cnset()
breaks the conseleness checks in the wsdisplay code.

Tested on various amd64/i386 systems with both glass and serial console.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.99 2013/04/24 08:23:45 blambert Exp $	*/
d241 1
a241 1
			printf(", BIOS32 rev. %d @@ 0x%lx", h->rev, h->entry);
d288 1
a288 1
			printf(", SMBIOS rev. %d.%d @@ 0x%lx (%d entries)",
@


1.99
log
@Use the manufacturer-supplied bios serial/uuid as a source of
uniqueness to seed the random pool; although it's somewhat
hit-or-miss, as serial numbers of 123456789 (I have the same
combination on my luggage!) and lazy uuid instantiation
mean it's not as unique as we would like.

Still, on those boards where the manufacturer isn't a slacker,
it's better than nothing...

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.98 2013/03/12 16:31:48 deraadt Exp $	*/
a575 1
				cnset(cdp->consdev);
@


1.98
log
@Fake 'SMBIOS detection' for the Soekris boxes, by Matt Dainty
This will make it easier to have device drivers for some oddities these
machines have
ok kettenis, assume jsg is ok with it too
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.97 2012/10/09 12:58:07 jsing Exp $	*/
d66 2
d995 2
d1020 2
@


1.97
log
@Allow boot(8) to pass information to the kernel, regarding the softraid
volume that it booted off.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.95 2012/06/04 15:19:47 jsing Exp $	*/
d337 37
@


1.96
log
@';;', even with a newline between the semicolons, doesn't make much
sense as a for() body. One semicolon is enough. From llvm via Brad.
@
text
@d79 5
d464 1
d561 11
@


1.95
log
@Correct the backwards compatibility code for console device configuration.

Fix tested by naddy@@

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.93 2012/01/13 12:55:52 jsing Exp $	*/
d260 1
a260 1
			for (chksum = 0, i = 0xf; i--; chksum += va[i]);
@


1.94
log
@Add support for serial consoles at non-standard addresses.  This implements
a new "machine comaddr" command that makes it possible to configure the
io port used to access the serial port.  This can be used to use serial ports
on a puc(4) device as serial console.
@
text
@d502 2
a503 1
			if (q->ba_size >= sizeof(bios_oconsdev_t)) {
d511 2
a512 1
				if (q->ba_size >= sizeof(bios_consdev_t))
@


1.93
log
@Switch back to bootduid, however remember to include sys/systm.h...
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.91 2012/01/11 15:58:27 jsing Exp $	*/
d502 1
a502 1
			if (q->ba_size >= sizeof(bios_consdev_t)) {
d509 8
a516 2
				if (major(cdp->consdev) == 8 && unit >= 0 &&
				    unit < (sizeof(ports)/sizeof(ports[0]))) {
d518 1
a518 1
					comconsaddr = ports[unit];
@


1.92
log
@Backout premature use of 'bootduid', as 'rootduid' has not yet been
renamed.
@
text
@d546 1
a546 1
			bcopy(bios_bootduid, rootduid, sizeof(rootduid));
@


1.91
log
@Pass the DUID of the boot disk via bootduid instead of rootduid, since it
is the DUID that we booted from, which is not always going to be the same
as the DUID that we mount root on.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.90 2011/04/26 17:33:17 jsing Exp $	*/
d546 1
a546 1
			bcopy(bios_bootduid, bootduid, sizeof(bootduid));
@


1.90
log
@Make amd64/i386 boot(8) pass the DUID of the selected boot device to the
kernel so that it can use it to identify the root disk. This will be
needed in order to correctly boot from a softraid volume.

ok deraadt@@ marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.88 2010/11/22 21:08:07 miod Exp $	*/
d458 1
a458 1
	bios_rootduid_t *bios_rootduid;
d544 3
a546 3
		case BOOTARG_ROOTDUID:
			bios_rootduid = (bios_rootduid_t *)q->ba_arg;
			bcopy(bios_rootduid, rootduid, sizeof(rootduid));
@


1.89
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d458 1
d542 6
@


1.88
log
@Remove unused (and dummied) bios console routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.87 2010/03/28 12:08:49 kettenis Exp $	*/
d759 1
a759 1
					if (*va == NULL && *(va + 1) == NULL)
d780 1
a780 1
			if (*va == NULL && *(va + 1) == NULL)
@


1.87
log
@Properly initialize variable instead of just ORing in bits into random garbage.
Shouldn't change the behaviour since only the ORed in bits are checked later,
but it makes the code clearer and should shut up the clang static analyser.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.86 2009/11/23 17:57:22 mlarkin Exp $	*/
a666 39
}

void
bioscnprobe(struct consdev *cn)
{
#if 0
	bios_init(I386_BUS_SPACE_MEM); /* XXX */
	if (!bios_cd.cd_ndevs)
		return;

	if (0 && bios_call(BOOTC_CHECK, NULL))
		return;

	cn->cn_pri = CN_LOWPRI;
	cn->cn_dev = makedev(48, 0);
#endif
}

void
bioscninit(struct consdev *cn)
{

}

void
bioscnputc(dev_t dev, int ch)
{

}

int
bioscngetc(dev_t dev)
{
	return -1;
}

void
bioscnpollc(dev_t dev, int on)
{
@


1.86
log
@

bios* devices need to call their children on suspend/resume.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.85 2009/04/30 13:47:16 dlg Exp $	*/
d973 1
a973 1
		uuidf |= SMBIOS_UUID_NPRESENT|SMBIOS_UUID_NSET;
@


1.85
log
@add support for passing db_console from the bootloader to the kernel.

based on the same change in amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.83 2008/10/28 00:05:32 deraadt Exp $	*/
d89 2
a90 1
	sizeof(struct bios_softc), biosprobe, biosattach
@


1.84
log
@Turn mpbios into a real device, such that people can disable it on crappy
BIOSes.

ok deraadt@@ (for the amd64 bit, or the i386 bit, can't remember which)
@
text
@d113 3
d456 1
d534 6
@


1.83
log
@Try to use ACPI a little bit harder.  Skip it only if ncpu < 2 and the
SMBIOS version is < 2.4.  This lets 40-series thinkpads continue to use
apm.
worked on with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.82 2008/08/16 00:26:26 krw Exp $	*/
d55 1
d68 1
d363 13
@


1.82
log
@bios_dev -> ba_name and bios_apmp -> ba_apmp in DPRINTF statements.
i386 kernels compile with BIOS_DEBUG again.

Spotted by Mathias Schmocker.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.81 2008/06/08 13:55:06 kettenis Exp $	*/
d159 1
a159 4
	int flags, havesmbios = 0;
#if NAPM > 0 || defined(MULTIPROCESSOR)
	int ncpu = 0;
#endif
a274 1
			havesmbios = 1;
d277 7
a303 1
#ifdef MULTIPROCESSOR
d310 2
a311 5
					/*
					 * smbios 2.5 added multi code support
					 */
					if (sh->majrev * 100 +
					    sh->minrev >= 250 &&
a320 2
#endif /* MULTIPROCESSOR */

d328 1
a328 1
	if (apm && ncpu < 2) {
d349 1
a349 1
	if (havesmbios && pci_mode_detect() != 0)
@


1.81
log
@Make serial console on non-primary ports work to on i386.

tested by jbg@@, "it is right" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.80 2008/05/21 18:49:47 kettenis Exp $	*/
d135 1
a135 1
	    bia->bios_dev, bios_cd.cd_ndevs,
@


1.80
log
@Switch i386 from pccom to com.  Welcomed by many.

ok dlg@@, jsing@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.79 2008/03/29 15:26:47 krw Exp $	*/
d493 1
a499 2
				extern int comconsrate; /* isa/pccom.c */
				comconsrate = cdp->conspeed;
@


1.79
log
@Fix amd64 and i386 serial console handling for non-default speeds. Bring
i386 pccom into line with com. Problem reported and first diff by Markus
Hennecke, who also tested and corrected subsequent diffs. Boot messages
and console now work with his 57K serial connections.

Suggestions and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.78 2008/03/02 18:01:05 deraadt Exp $	*/
d70 7
d484 15
a498 6
			if (q->ba_size >= sizeof(bios_consdev_t))
			{
				bios_consdev_t *cdp = (bios_consdev_t*)q->ba_arg;
#include "com.h"
#include "pccom.h"
#if NCOM + NPCCOM > 0
@


1.78
log
@if there is no smbios, there cannot be acpi
ok kettenis gwk, tested by a lot of people, and checked from the logs
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.77 2008/01/23 16:37:56 jsing Exp $	*/
d483 2
a484 2
				extern int comdefaultrate; /* ic/com.c */
				comdefaultrate = cdp->conspeed;
@


1.77
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.75 2007/12/05 19:17:13 deraadt Exp $	*/
d152 1
a152 1
	int flags;
d233 1
a233 1
			struct smbhdr * sh = (struct smbhdr *)va;
d271 1
d345 1
a345 1
	if (pci_mode_detect() != 0)
@


1.76
log
@if we pxebooted, and can find the interface, put it in a "pxeboot" group
so that later applications can try to do the right thing
for reyk
@
text
@d641 1
a641 1
	cn->cn_pri = CN_NORMAL;
@


1.75
log
@Hang acpi(4) below bios(4) instead of mainbus(4).  This lets us move acpi(4)
before pcibios(4), and then.... if acpi(4) attaches, skip pcibios(4) since
it messes the machines up.  Fixes claudio's HP dl320 G5, and almost assuredly
others.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.74 2007/12/01 19:08:42 miod Exp $	*/
a102 1
#ifdef NFSCLIENT
a103 1
#endif
a498 1
#ifdef NFSCLIENT
a501 1
#endif
@


1.74
log
@Let apmless non-mp kernels compile, from chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.73 2007/11/25 16:40:04 jmc Exp $	*/
d60 5
d66 1
d134 1
a134 1
	if (bios_cd.cd_ndevs || strcmp(bia->bios_dev, bios_cd.cd_name))
d327 1
d335 5
a339 5
		ba.bios_dev = "apm";
		ba.bios_func = 0x15;
		ba.bios_memt = bia->bios_memt;
		ba.bios_iot = bia->bios_iot;
		ba.bios_apmp = apm;
d343 18
d365 4
a368 4
		ba.bios_dev = "pcibios";
		ba.bios_func = 0x1A;
		ba.bios_memt = bia->bios_memt;
		ba.bios_iot = bia->bios_iot;
d526 1
a526 1
		    ba->bios_dev, pnp, ba->bios_func);
@


1.73
log
@spelling fixes, from Martynas Venckus;
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.72 2007/11/15 20:02:33 deraadt Exp $	*/
d148 4
a151 1
	int flags, ncpu = 0;
@


1.72
log
@in MP kernels, use smbios to count number of cpus.  if > 1 disable apm, so
that acpi can get a chance at controlling the machine.
done with marco, and even tested on the nastiest case: smbios <2.5 w/ HTT
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.71 2007/11/03 05:48:49 ckuethe Exp $	*/
d706 1
a706 1
 * is sucessfully located and zero otherwise. Callers should take care
d725 1
a725 1
	 * sucessful location of a table, the type is encoded as bits 0:7 of
@


1.71
log
@don't spam dmesg with huge, whitespace padded bios strings.
ok beck, gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.70 2007/08/06 16:12:25 gwk Exp $	*/
d148 1
a148 1
	int flags;
d285 24
d316 1
a316 1
	if (apm) {
@


1.70
log
@Spew smbios bios table vendor/version/release date into the dmesg. Diff
from theo.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.69 2007/03/29 15:00:15 gwk Exp $	*/
d274 2
a275 1
					printf(" vendor %s", scratch);
d278 2
a279 1
					printf(" version \"%s\"", scratch);
d282 1
a282 1
					printf(" date %s", scratch);
@


1.69
log
@Comment fixes from Daniel Dickman <didickman AT gmail DOT com>, relevant changes
for amd64 added by myself and while here nuke some whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.68 2007/01/18 18:32:10 gwk Exp $	*/
d144 2
d147 1
a147 1
	char *str;
d267 15
@


1.68
log
@No longer print the 'bios id' field in the dmesg, its of dubious diagnostic
value and changes with acpi versus non acpi kernels.
ok deraadt@@ tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.67 2006/08/22 19:15:36 tom Exp $	*/
d166 28
a193 1
	/* see if we have BIOS32 extensions */
d220 1
a220 1
	/* see if we have SMBIOS extentions */
d259 1
a259 1
	    		for (; pa < end; pa+= NBPG, eva+= NBPG)
d303 1
a303 1
	 * now, that we've gave 'em a chance to attach,
d434 1
a434 1
#endif			
d664 1
a664 1
 * to initilize the cookie field of the smbtable structure to zero before
d666 1
a666 1
 * Multiple tables of the same type can be located by repeadtly calling
d802 1
a802 1
	 * perhaps naieve belief that motherboard vendors will supply this
d865 1
a865 1
		 * set, if its all 0 then the uuid isnt present at all.
@


1.67
log
@Use a case-insensitive comparison when checking for bogus SMBIOS
strings.  Fixes identification of millert@@'s system.

ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.66 2006/07/17 20:31:57 fgsch Exp $	*/
d163 2
a164 2
	printf(": %s(%02x) BIOS, date %c%c/%c%c/%c%c",
	    str, va[15], va[5], va[6], va[8], va[9], va[11], va[12]);
@


1.66
log
@use malloc'ed buffers rather than losing some/all of the static buffers
and allow for longer strings (as per spec).
mickey@@ and gwk@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.65 2006/05/20 22:38:52 deraadt Exp $	*/
d724 1
a724 1
		if ((strncmp(s, smbios_uninfo[i], strlen(smbios_uninfo[i])))==0)
@


1.65
log
@handle BOOTARG_BOOTMAC from boot block; tested by reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.64 2006/05/19 04:49:17 gwk Exp $	*/
d749 1
a749 1
	static char vend[40], prod[30], ver[30], ser[20];
d753 1
a753 1
	int i, uuidf, havebb;
d778 5
a782 4
	if ((p = smbios_get_string(&stbl, sys->vendor, vend, sizeof(vend))) != 
	    NULL)
		hw_vendor = fixstring(p);
	if (hw_vendor == NULL) {
d784 20
a803 3
			if ((p = smbios_get_string(&btbl, board->vendor, vend,
			   sizeof(vend))) != NULL)
				hw_vendor = fixstring(p);
d806 6
a811 9
	if ((p = smbios_get_string(&stbl, sys->product, prod, sizeof(prod))) !=
	     NULL)
		hw_prod = fixstring(p);
	if (hw_prod == NULL) {
		if (havebb) {
			if ((p = smbios_get_string(&btbl, board->product, prod, 
			    sizeof(prod))) != NULL)
				hw_prod = fixstring(p);
		}
d815 19
a833 6
	if ((p = smbios_get_string(&stbl, sys->version, ver, sizeof(ver))) != 
	    NULL)
		hw_ver = fixstring(p);
	if ((p = smbios_get_string(&stbl, sys->serial, ser, sizeof(ser))) != 
	    NULL)
		hw_serial = fixstring(p);
@


1.64
log
@Smbios cleanup
Improve the heuristics a little and extend them to the version and serial
number fields. Clean the strings of leading/trailing space and deal with
strings which consist entirely of space. Use fixed buffers for strings
instead of using pointers into the table.
ok deraadt@@, and tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.63 2006/05/11 23:19:36 deraadt Exp $	*/
d97 3
d402 6
@


1.63
log
@cleaner
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.62 2006/05/08 21:13:03 gwk Exp $	*/
d71 1
d108 3
a110 1
	"Not Specified"
d686 1
a686 1
smbios_get_string(struct smbtable *st, u_int8_t indx)
d697 7
a703 2
	if (i == indx)
		ret = (char *)va;
d708 29
d740 1
d745 1
d750 2
a751 3
	 * According to the spec the system table among others are required to
	 * be present, if it is not we dont bother with this smbios
	 * implementation.
d769 8
a776 10
	if ((hw_vendor = smbios_get_string(&stbl, sys->vendor)) != NULL) {
		for (i = 0; i < sizeof(smbios_uninfo)/sizeof(smbios_uninfo[0]);
		    i++) {
			if ((strncmp(hw_vendor, smbios_uninfo[i],
			    strlen(smbios_uninfo[i]))) == 0) {
				if (havebb)
					hw_vendor = smbios_get_string(&btbl,
				   	    board->vendor);
				break;
			}
d778 9
a786 12
	} else
		hw_vendor = smbios_get_string(&btbl, board->vendor);
	if ((hw_prod = smbios_get_string(&stbl, sys->product)) != NULL) {
		for (i = 0; i < sizeof(smbios_uninfo)/sizeof(smbios_uninfo[0]);
		    i++) {
			if ((strncmp(hw_prod, smbios_uninfo[i],
			    strlen(smbios_uninfo[i]))) == 0) {
				if (havebb)
					hw_prod = smbios_get_string(&btbl,
				   	    board->product);
				break;
			}
d788 1
a788 2
	} else
		hw_prod = smbios_get_string(&btbl, board->product);
d791 6
a796 2
	hw_ver = smbios_get_string(&stbl, sys->version);
	hw_serial = smbios_get_string(&stbl, sys->serial);
@


1.62
log
@Remove a stray newline thats making the dmesg's ugly.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.61 2006/05/09 00:35:29 gwk Exp $	*/
d105 1
a105 1
const char * smbios_uninfo[] = {
d134 1
a134 1
	struct bios_softc *sc = (struct bios_softc *) self;
d651 1
a651 1
				va = (u_int8_t *) hdr + hdr->size;
d662 1
a662 1
		hdr = (struct smbtblhdr *) va;
d695 1
a695 1
		ret = (char *) va;
d732 2
a733 2
		for (i = 0; i < sizeof(smbios_uninfo) / sizeof(smbios_uninfo[0])
		    ; i++) {
d745 2
a746 2
		for (i = 0; i < sizeof(smbios_uninfo) / sizeof(smbios_uninfo[0])
		    ; i++) {
d751 1
a751 1
				   		board->product);
@


1.61
log
@Remove some debug printf's that snuck in.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.60 2006/05/08 22:53:10 deraadt Exp $	*/
a678 1
	printf("\n");
@


1.60
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.59 2006/05/08 22:51:18 gwk Exp $	*/
a662 1
		printf("SMBIOS (%d)@@%p type: %d", tcount, va, hdr->type);
a672 1
		printf(" size: %d strings@@%p", hdr->size, va);
a676 1
		printf(" end@@%p\n", va);
@


1.59
log
@Add smbios support for i386 and amd64, fix ipmi to use this new functionallity,
hook up some sysctls to add system vendor/product/version and UUID reporting.

"get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.58 2006/04/18 23:36:03 gwk Exp $	*/
d94 1
a94 1
void	       *bios_smpinfo;
d106 2
a107 2
        "System",
        "Not Specified"
d163 1
a163 1
		     va < (u_int8_t *)ISA_HOLE_VADDR(BIOS32_END); va += 16) {
d187 1
a187 1
	/* see if we have SMBIOS extentions */	
d213 1
a213 1
			pa = trunc_page(sh->addr); 
d219 1
a219 1
			smbios_entry.addr = (u_int8_t *)(eva + 
d228 2
a229 2
			
			printf(", SMBIOS rev. %d.%d @@ 0x%lx (%d entries)", 
d231 1
a231 1
		
d277 2
a278 2
		     eva = ISA_HOLE_VADDR(0xf0000);
		     va < eva; va += 512) {
d455 2
a456 2
	     va += trunc_page(BIOS32_START);
	     pa < endpa; pa += NBPG, va += NBPG) {
d631 1
a631 1
smbios_find_table(u_int8_t type, struct smbtable *st) 
d663 1
a663 1
		printf("SMBIOS (%d)@@%p type: %d", tcount, va, hdr->type);  
d705 1
a705 1
smbios_info(char * str) 
d727 1
a727 1
	/* 
@


1.58
log
@ANSIfy
ok marco@@, dlg@@, mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.57 2005/11/13 14:23:26 martin Exp $	*/
d55 1
d92 1
d97 2
d101 10
d187 50
d621 178
@


1.57
log
@convert more MD macros to their MI counterparts, this time
i386_round_page(), i386_trunc_page(), i386_btop() and i386_ptob()
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.56 2005/08/19 01:10:42 marco Exp $	*/
d98 1
a98 3
biosprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d118 1
a118 3
biosattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d346 1
a346 3
bios_print(aux, pnp)
	void *aux;
	const char *pnp;
d357 1
a357 4
bios32_service(service, e, ei)
	u_int32_t service;
	bios32_entry_t e;
	bios32_entry_info_t ei;
d417 1
a417 4
biosopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d430 1
a430 4
biosclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d443 1
a443 6
biosioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d461 1
a461 2
bioscnprobe(cn)
	struct consdev *cn;
d477 1
a477 2
bioscninit(cn)
	struct consdev *cn;
d483 1
a483 3
bioscnputc(dev, ch)
	dev_t dev;
	int ch;
d489 1
a489 2
bioscngetc(dev)
	dev_t dev;
d495 1
a495 3
bioscnpollc(dev, on)
	dev_t dev;
	int on;
d500 2
a501 8
bios_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
d534 1
a534 2
bios_getdiskinfo(dev)
	dev_t dev;
@


1.56
log
@Spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.55 2004/06/13 21:49:15 niklas Exp $	*/
d390 1
a390 1
	endpa = i386_round_page(BIOS32_END);
d399 2
a400 2
	for (pa = i386_trunc_page(BIOS32_START),
	     va += i386_trunc_page(BIOS32_START);
d407 1
a407 1
		if (pa >= i386_trunc_page(base)) {
@


1.55
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d113 1
a113 1
	if (!(bootapiver & BAPIV_VECTOR) || bootargp == NULL )
@


1.54
log
@No longer accept memory ranges in KB from /boot, which hasn't done
this since 1999.  If /boot tries to, we will now panic() with the
"/boot too old" message.  No-one should be using such an old /boot
anyway, since it didn't support ELF kernels then.

ok weingart@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.52 2003/07/11 17:51:11 deraadt Exp $	*/
d88 1
a88 1
bios_memmap_t	*bios_memmap;
d91 3
d330 6
a367 3
	extern union descriptor *dynamic_gdt;
	extern int gdt_get_slot(void);

d397 1
a397 2
	setsegment(&dynamic_gdt[slot].sd, (caddr_t)va, BIOS32_END,
	    SDT_MEMERA, SEL_KPL, 1, 0);
@


1.53
log
@spelling fixes (in the comments)
@
text
@a277 1
			if (bootapiver & BAPIV_BMEMMAP) {
d279 1
a279 1
				printf(" memmap %p", bios_memmap);
a280 16
			} else {
				register bios_memmap_t *p;
#ifdef BIOS_DEBUG
				printf(" omemmap %p", bios_memmap);
#endif
				/*
				 * older /boots passed memmap in Kbytes,
				 * which is very inconvenient from the
				 * point of view of memory management
				 */
				for (p = bios_memmap;
				     p->type != BIOS_MAP_END; p++) {
					p->addr /= 1024;
					p->size *= 1024;
				}
			}
@


1.52
log
@debug only; mickey ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.51 2003/06/03 20:10:31 mickey Exp $	*/
d289 1
a289 1
				 * which is very inconvinient from the
@


1.51
log
@three four kill
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.50 2003/04/17 03:42:14 drahn Exp $	*/
d322 1
d324 1
@


1.50
log
@i386 changes to move to ELF. asm cleanup. Change MAXDSIZ to 512M for 1Gsep.
DARPA funded work.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.49 2002/05/20 16:38:01 mickey Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.49
log
@ignore corrupted prom headers w/ length exceeding the scanned isa hole region; reported by Jason Spence <jspence@@lightconsulting.com> for Toshiba Satellite 3005-S303. add a note on a more aggressive course of action
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.48 2002/03/14 01:26:32 millert Exp $	*/
d391 1
a391 1
	__asm __volatile("lcall (%4)"
@


1.48
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.47 2001/11/06 19:53:14 miod Exp $	*/
d230 4
d238 2
a239 2
			off = 0xc0000 + (va - (u_int8_t *)
			    ISA_HOLE_VADDR(0xc0000));
d247 3
@


1.47
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.46 2001/09/19 20:50:56 mickey Exp $	*/
d72 3
a74 3
int biosprobe __P((struct device *, void *, void *));
void biosattach __P((struct device *, struct device *, void *));
int bios_print __P((void *, const char *));
d97 1
a97 1
bios_diskinfo_t *bios_getdiskinfo __P((dev_t));
d373 1
a373 1
	extern int gdt_get_slot __P((void));
@


1.47.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.47 2001/11/06 19:53:14 miod Exp $	*/
d72 3
a74 3
int biosprobe(struct device *, void *, void *);
void biosattach(struct device *, struct device *, void *);
int bios_print(void *, const char *);
d97 1
a97 1
bios_diskinfo_t *bios_getdiskinfo(dev_t);
a229 4
			/*
			 * for this and the next check we probably want
			 * to reserve the page in the extent anyway
			 */
d234 2
a235 2
			if (va + len > eva)
				continue;
a243 3
			off = 0xc0000 + (va - (u_int8_t *)
			    ISA_HOLE_VADDR(0xc0000));

d373 1
a373 1
	extern int gdt_get_slot(void);
@


1.47.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d391 1
a391 1
	__asm __volatile("lcall *(%4)"
@


1.46
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.45 2001/07/25 13:25:32 art Exp $	*/
a45 1
#include <vm/vm.h>
@


1.45
log
@Change the pmap_enter interface to merge access_type and the wired boolean
and arbitrary flags into one argument.

One new flag is PMAP_CANFAIL that tells pmap_enter that it can fail if there
are not enough resources to satisfy the request. If this flag is not passed,
pmap_enter should panic as it should have done before this change (XXX - many
pmaps are still not doing that).

Only i386 and alpha implement CANFAIL for now.

Includes uvm updates from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.44 2001/07/10 11:07:26 espie Exp $	*/
d47 1
a47 1
#include <vm/vm_kern.h>
@


1.44
log
@ANSI C does not like labels: without a statement after that.
Restore missing breaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.43 2001/05/05 23:25:34 art Exp $	*/
d412 2
a413 2
		    VM_PROT_READ | VM_PROT_WRITE, TRUE,
		    VM_PROT_READ | VM_PROT_WRITE);
d418 2
a419 2
			    VM_PROT_READ | VM_PROT_WRITE, TRUE,
			    VM_PROT_READ | VM_PROT_WRITE);
@


1.43
log
@PMAP_NEW and UVM are no longer optional on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.42 2001/02/28 19:16:06 mickey Exp $	*/
d347 1
@


1.42
log
@proper bang placement
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.41 2001/02/28 18:37:14 mickey Exp $	*/
a398 1
#if defined(UVM)
a399 3
#else
	sva = va = kmem_alloc_pageable(kernel_map, endpa);
#endif
@


1.41
log
@better print due to theo's suggestion
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.40 2001/02/28 16:45:25 mickey Exp $	*/
d240 1
d242 2
a243 1
				printf("!");	/* stinking x20 again */
d248 2
a249 1
			printf(" 0x%05x/0x%x", off, len);
@


1.40
log
@scan the isa hole for `optional rom's.
found proms are excluded from the iomem_ex such
that devices cannot map on the same memory.
next step would be for pcic and similar devices
to choose memory windows from unused spots
in the iomem_ex.
currently prom checksum test is not enforced
due to broken stinkpad bioses, which do not
pass the checksum test.
testing from aaron@@, fgsch@@, fries@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.39 2001/01/21 20:23:22 mickey Exp $	*/
d244 1
a244 1
				printf("%s: PROM list:",
d246 1
a246 1
			printf(" %05x[%04x]", off, len);
@


1.39
log
@map the bios rom at both it's real address and
zero offset corresponding to the base of the rom.
this solves a problem for roms referring
to their internal tables by real addresses.
brad@@ testing, 10x
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.38 2000/10/25 19:13:11 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997-2000 Michael Shalayeff
d44 1
d109 2
a110 2
	       bia->bios_dev, bios_cd.cd_ndevs,
	       bootapiver, BOOTARG_APIVER, bootargp, bootargc);
d131 1
a131 1
	u_int8_t *va;
d169 1
a169 1
		
d211 47
@


1.38
log
@put back using bios_pciinfo, we will rework it later on
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.37 2000/10/21 17:43:50 mickey Exp $	*/
d325 1
a325 1
	vm_offset_t va;
d349 1
a349 1
	va = uvm_km_valloc(kernel_map, endpa);
d351 1
a351 1
	va = kmem_alloc_pageable(kernel_map, endpa);
d362 1
a362 1
	     pa < endpa; pa += NBPG, va += NBPG)
d366 9
@


1.37
log
@w/ help of aaron@@ make it work now:
base the segment for a service returned by bios32 service
directory on absolute 0, w/ a length extending to a full
megabyte, 32bit descriptor of course.
this approach seems to be the most compatible.
map only the bios32 area though.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.35 2000/10/16 19:29:09 mickey Exp $	*/
d89 3
d267 6
@


1.36
log
@undo last commit.  on some kernel links, this causes pcibios panics at
startup (on ALL machines)
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.34 2000/09/25 16:33:05 mickey Exp $	*/
d46 1
d315 2
d336 11
d348 9
a356 2
	setsegment(&dynamic_gdt[slot].sd, ISA_HOLE_VADDR(base),
	    ((base + 0x10000) & ~0xffff) - 1, SDT_MEMERA, SEL_KPL, 1, 0);
d359 1
a359 1
	e->offset = (vaddr_t)(ent - base);
@


1.35
log
@base the segment for a service returned by bios32 service
directory on absolute 0, w/ a length extending to a full
megabyte, 32bit descriptor of course.
this approach seems to be the most compatible.
10x to millert@@ for a testbed.
@
text
@a45 1
#include <vm/vm_kern.h>
a313 2
	u_long pa, endpa;
	vm_offset_t va;
a332 11

	endpa = i386_round_page(BIOS32_END);

#if defined(UVM)
	va = uvm_km_valloc(kernel_map, endpa);
#else
	va = kmem_alloc_pageable(kernel_map, endpa);
#endif
	if (va == 0)
		return (0);

d334 2
a335 7
	setsegment(&dynamic_gdt[slot].sd, (caddr_t)va, BIOS32_END,
	    SDT_MEMERA, SEL_KPL, 1, 0);

	for (; pa < endpa; pa += NBPG, va += NBPG)
		pmap_enter(pmap_kernel(), va, pa,
		    VM_PROT_READ | VM_PROT_WRITE, TRUE,
		    VM_PROT_READ | VM_PROT_WRITE);
d338 1
a338 1
	e->offset = (vaddr_t)ent;
@


1.34
log
@once again bios does not return a correct segment limits for the
pcibios segments. we work this around as we used to do in apm (;
round segment size to the next 64k boundary.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.33 2000/09/22 02:00:21 mickey Exp $	*/
d46 1
d315 2
d336 11
d348 7
a354 2
	setsegment(&dynamic_gdt[slot].sd, ISA_HOLE_VADDR(base),
	    ((base + 0x10000) & ~0xffff) - 1, SDT_MEMERA, SEL_KPL, 1, 0);
d357 1
a357 1
	e->offset = (vaddr_t)(ent - base);
@


1.33
log
@this follows the dox, saying that %ds should be loaded w/
the proper segment address/selector as returned from bios32_service().
both %cs and %ds have to be the same value (hmm, same descs?),
sincw some bioses are pic, and care only about offsets against the segs.
huge, enormous, 10X to brad@@ for providing an incredibly usefull
testbed and invaluable time of his, for resets and incouraging comments (;
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.32 2000/08/18 01:23:22 mickey Exp $	*/
d335 1
a335 1
	    count - 1, SDT_MEMERA, SEL_KPL, 1, 0);
@


1.32
log
@unused variable if no apm and no pcibios conditions; pt out by chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.31 2000/08/17 22:08:09 mickey Exp $	*/
d311 3
d315 1
d333 6
a338 2
	e->offset = (vaddr_t)ISA_HOLE_VADDR(ent);
	e->segment = GSEL(GCODE_SEL, SEL_KPL);
@


1.31
log
@pcibios tells us everything, no bios_pciinfo
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.30 2000/08/17 20:15:39 mickey Exp $	*/
d123 1
d125 1
@


1.30
log
@pcibios0 at bios0 flags 0x0000
this is now a real device, which looks in flags for disabling
address, interrupt or bus fixup.
bios0's flags are to disable bios32 and pcibios probing.
since boot_config support editing flags, it's posible
to adjust pcibios functionality in the generic kernel
upon boot time. man is coming.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.29 2000/07/27 20:38:10 mickey Exp $	*/
a87 3
#if NPCI > 0
bios_pciinfo_t *bios_pciinfo;
#endif
a260 6
#if NPCI > 0
		case BOOTARG_PCIINFO:
			bios_pciinfo = (bios_pciinfo_t *)q->ba_arg;
			printf(" pciinfo %p", bios_pciinfo);
			break;
#endif
@


1.29
log
@do not print anything before console has been set
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.28 2000/07/25 22:36:30 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997-1999 Michael Shalayeff
d64 1
d94 1
d125 1
a125 2
	/* struct bios_softc *sc = (void *) self; */
#if NAPM > 0
d127 1
a127 2
#endif
	u_int8_t *va = ISA_HOLE_VADDR(0xffff0);
d129 1
d131 4
d146 1
a146 1
	printf(": %s(%02x) BIOS, date %c%c/%c%c/%c%c\n",
d149 29
d196 11
d310 34
@


1.28
log
@allow compiling -DDEBUG w/o apm0 in he config; pointed by cleb <cb@@hert.org>.
also, print console device and speed before switching to the new console.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.27 2000/04/16 05:07:29 deraadt Exp $	*/
d169 1
d171 1
d178 2
a179 1
			if (bootapiver & BAPIV_BMEMMAP)
d181 2
a182 1
			else {
d184 1
d186 1
d201 1
d203 1
d207 1
d209 1
d215 1
d217 1
d235 1
d238 1
a238 1

d244 1
d247 1
@


1.27
log
@permit compiling kernel without pccom or com
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.26 2000/02/18 17:10:09 mickey Exp $	*/
d84 1
a84 1
#if NAPM > 0
d223 3
@


1.26
log
@full support for a serial console.
iface addition: pass serial speed from /boot.
tested on 4 /boot+kernel permutations.
also, niklas@@ said he likes it
bugs: any printfs before cninit() will go to the
default console, which is mon/kbd, but are usually
only sorts of debugging messages (like bios_memmap load).
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.25 1999/10/26 18:16:48 mickey Exp $	*/
d217 3
d222 1
@


1.25
log
@modify bootapiver chekups to use bitwise operations.
factor out /boot options parser from biosattach().
add logic to warn about ancient /boots.
cleanup vanishing cruft.
@@niklas ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.24 1999/08/25 00:54:18 mickey Exp $	*/
d214 7
a220 1
			cnset(*(dev_t *)q->ba_arg);
@


1.25.2.1
log
@Get MP info from /boot
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.25 1999/10/26 18:16:48 mickey Exp $	*/
d91 1
a91 1
bios_memmap_t  *bios_memmap;
a92 3
#ifdef SMP
void	       *bios_smpinfo;
#endif
a215 7

#ifdef SMP
		case BOOTARG_SMPINFO:
			bios_smpinfo = q->ba_arg;
			printf(" smpinfo %p", bios_smpinfo);
			break;
#endif
@


1.25.2.2
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.26 2000/02/18 17:10:09 mickey Exp $	*/
d217 1
a217 7
			if (q->ba_size >= sizeof(bios_consdev_t))
			{
				bios_consdev_t *cdp = (bios_consdev_t*)q->ba_arg;
				extern int comdefaultrate; /* ic/com.c */
				comdefaultrate = cdp->conspeed;
				cnset(cdp->consdev);
			}
d219 1
@


1.25.2.3
log
@use MULTIPROCESSOR instead of SMP as the define to get MP stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.25.2.2 2000/02/20 11:56:47 niklas Exp $	*/
d93 1
a93 1
#ifdef MULTIPROCESSOR
d225 1
a225 1
#ifdef MULTIPROCESSOR
@


1.25.2.4
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.42 2001/02/28 19:16:06 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997-2001 Michael Shalayeff
a43 1
#include <sys/extent.h>
a45 1
#include <vm/vm_kern.h>
a63 1
#include "pcibios.h"
d84 1
a84 1
#if NAPM > 0 || defined(DEBUG)
a92 1
struct bios32_entry bios32_entry;
d108 2
a109 2
	    bia->bios_dev, bios_cd.cd_ndevs,
	    bootapiver, BOOTARG_APIVER, bootargp, bootargc);
d126 2
a127 2
	struct bios_softc *sc = (struct bios_softc *) self;
#if (NPCI > 0 && NPCIBIOS > 0) || NAPM > 0
d130 1
a130 1
	volatile u_int8_t *va;
a131 4
	int flags;

	/* remember flags */
	flags = sc->sc_dev.dv_cfdata->cf_flags;
a132 1
	va = ISA_HOLE_VADDR(0xffff0);
d144 1
a144 1
	printf(": %s(%02x) BIOS, date %c%c/%c%c/%c%c",
a146 29
	/* see if we have BIOS32 extensions */
	if (!(flags & BIOSF_BIOS32)) {
		for (va = ISA_HOLE_VADDR(BIOS32_START);
		     va < (u_int8_t *)ISA_HOLE_VADDR(BIOS32_END); va += 16) {
			bios32_header_t h = (bios32_header_t)va;
			u_int8_t cksum;
			int i;

			if (h->signature != BIOS32_SIGNATURE)
				continue;

			/* verify checksum */
			for (cksum = 0, i = h->length * 16; i--; cksum += va[i])
				;
			if (cksum != 0)
				continue;

			if (h->entry <= BIOS32_START || h->entry >= BIOS32_END)
				continue;

			bios32_entry.segment = GSEL(GCODE_SEL, SEL_KPL);
			bios32_entry.offset = (u_int32_t)ISA_HOLE_VADDR(h->entry);
			printf(", BIOS32 rev. %d @@ 0x%lx", h->rev, h->entry);
			break;
		}
	}

	printf("\n");

a164 61
#if NPCI > 0 && NPCIBIOS > 0
	if (!(flags & BIOSF_PCIBIOS)) {
		struct bios_attach_args ba;

		ba.bios_dev = "pcibios";
		ba.bios_func = 0x1A;
		ba.bios_memt = bia->bios_memt;
		ba.bios_iot = bia->bios_iot;
		config_found(self, &ba, bios_print);
	}
#endif

	/*
	 * now, that we've gave 'em a chance to attach,
	 * scan and map all the proms we can find
	 */
	if (!(flags & BIOSF_PROMSCAN)) {
		volatile u_int8_t *eva;

		for (str = NULL, va = ISA_HOLE_VADDR(0xc0000),
		     eva = ISA_HOLE_VADDR(0xf0000);
		     va < eva; va += 512) {
			extern struct extent *iomem_ex;
			bios_romheader_t romh = (bios_romheader_t)va;
			u_int32_t off, len;
			u_int8_t cksum;
			int i;

			if (romh->signature != 0xaa55)
				continue;

			if (!romh->len || romh->len == 0xff)
				continue;

			len = romh->len * 512;
			off = 0xc0000 + (va - (u_int8_t *)
			    ISA_HOLE_VADDR(0xc0000));

			for (cksum = 0, i = len; i--; cksum += va[i])
				;
#ifdef __stinkpad_sucks__
			if (cksum != 0)
				continue;
#endif

			if (!str)
				printf("%s: ROM list:",
				    str = sc->sc_dev.dv_xname);
			printf(" 0x%05x/0x%x%s", off, len,
			    cksum? "!" : "");

			if ((i = extent_alloc_region(iomem_ex,
			    (paddr_t)off, len, EX_NOWAIT)))
				printf(":%d", i);

			va += len - 512;
		}
	}

	if (str)
		printf("\n");
a171 1
#ifdef BIOS_DEBUG
a172 1
#endif
d179 1
a179 2
			if (bootapiver & BAPIV_BMEMMAP) {
#ifdef BIOS_DEBUG
d181 1
a181 2
#endif
			} else {
a182 1
#ifdef BIOS_DEBUG
a183 1
#endif
a197 1
#ifdef BIOS_DEBUG
a198 1
#endif
a201 1
#ifdef BIOS_DEBUG
a202 1
#endif
a207 1
#ifdef BIOS_DEBUG
a208 1
#endif
a219 3
#include "com.h"
#include "pccom.h"
#if NCOM + NPCCOM > 0
a221 5
#endif
#ifdef BIOS_DEBUG
				printf(" console 0x%x:%d",
				    cdp->consdev, cdp->conspeed);
#endif
a232 1
#ifdef BIOS_DEBUG
a234 1
#endif
a251 71
}

int
bios32_service(service, e, ei)
	u_int32_t service;
	bios32_entry_t e;
	bios32_entry_info_t ei;
{
	extern union descriptor *dynamic_gdt;
	extern int gdt_get_slot __P((void));

	u_long pa, endpa;
	vaddr_t va, sva;
	u_int32_t base, count, off, ent;
	int slot;

	if (bios32_entry.offset == 0)
		return 0;

	base = 0;
	__asm __volatile("lcall (%4)"
	    : "+a" (service), "+b" (base), "=c" (count), "=d" (off)
	    : "D" (&bios32_entry)
	    : "%esi", "cc", "memory");

	if (service & 0xff)
		return 0;	/* not found */

	ent = base + off;
	if (ent <= BIOS32_START || ent >= BIOS32_END)
		return 0;


	endpa = i386_round_page(BIOS32_END);

#if defined(UVM)
	sva = va = uvm_km_valloc(kernel_map, endpa);
#else
	sva = va = kmem_alloc_pageable(kernel_map, endpa);
#endif
	if (va == 0)
		return (0);

	slot = gdt_get_slot();
	setsegment(&dynamic_gdt[slot].sd, (caddr_t)va, BIOS32_END,
	    SDT_MEMERA, SEL_KPL, 1, 0);

	for (pa = i386_trunc_page(BIOS32_START),
	     va += i386_trunc_page(BIOS32_START);
	     pa < endpa; pa += NBPG, va += NBPG) {
		pmap_enter(pmap_kernel(), va, pa,
		    VM_PROT_READ | VM_PROT_WRITE, TRUE,
		    VM_PROT_READ | VM_PROT_WRITE);

		/* for all you, broken hearted */
		if (pa >= i386_trunc_page(base)) {
			pmap_enter(pmap_kernel(), sva, pa,
			    VM_PROT_READ | VM_PROT_WRITE, TRUE,
			    VM_PROT_READ | VM_PROT_WRITE);
			sva += NBPG;
		}
	}

	e->segment = GSEL(slot, SEL_KPL);
	e->offset = (vaddr_t)ent;

	ei->bei_base = base;
	ei->bei_size = count;
	ei->bei_entry = ent;

	return 1;
@


1.25.2.5
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.25.2.4 2001/04/18 16:07:13 niklas Exp $	*/
d408 1
d410 3
@


1.25.2.6
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.25.2.5 2001/07/04 10:16:32 niklas Exp $	*/
d47 1
a47 1
#include <uvm/uvm_extern.h>
a355 1
			break;
d420 2
a421 2
		    VM_PROT_READ | VM_PROT_WRITE,
		    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
d426 2
a427 2
			    VM_PROT_READ | VM_PROT_WRITE,
			    VM_PROT_READ | VM_PROT_WRITE | PMAP_WIRED);
@


1.25.2.7
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
@


1.25.2.8
log
@Merge in -current from about a week ago
@
text
@d72 3
a74 3
int biosprobe(struct device *, void *, void *);
void biosattach(struct device *, struct device *, void *);
int bios_print(void *, const char *);
d100 1
a100 1
bios_diskinfo_t *bios_getdiskinfo(dev_t);
d382 1
a382 1
	extern int gdt_get_slot(void);
@


1.25.2.9
log
@Sync the SMP branch with 3.3
@
text
@a232 4
			/*
			 * for this and the next check we probably want
			 * to reserve the page in the extent anyway
			 */
d237 2
a238 2
			if (va + len > eva)
				continue;
a245 3

			off = 0xc0000 + (va - (u_int8_t *)
			    ISA_HOLE_VADDR(0xc0000));
@


1.25.2.10
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.25.2.9 2003/03/27 23:26:55 niklas Exp $	*/
d400 1
a400 1
	__asm __volatile("lcall *(%4)"
@


1.25.2.11
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.25.2.10 2003/05/13 19:42:07 ho Exp $	*/
d388 3
d420 2
a421 1
	setgdt(slot, (caddr_t)va, BIOS32_END, SDT_MEMERA, SEL_KPL, 1, 0);
@


1.25.2.12
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.25.2.11 2003/05/15 04:08:01 niklas Exp $	*/
d15 5
@


1.25.2.13
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d281 1
d283 1
a283 1
			printf(" memmap %p", bios_memmap);
d285 16
a324 1
#ifdef BIOS_DEBUG
a325 1
#endif
@


1.24
log
@give better support to the bios memory maps.
provide memory maps editing through the machine memory command.
rearrange probing in machdep, so it provides less output,
also giving a shot for apm to fix the memory maps.
changes to kernel are minimal, only that is required due
to the api version bits addition and such cosmetic changes.
tested on all critical kernel,boot combinations; niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.23 1998/11/15 16:33:01 art Exp $	*/
d84 3
d88 1
a88 1
bios_pciinfo_t *bios_pciinfo = NULL;
d90 2
a91 1
bios_diskinfo_t *bios_diskinfo = NULL;
d112 1
a112 1
	if (bootapiver < BOOTARG_APIVER || bootargp == NULL )
d123 1
a123 1
	struct bios_softc *sc = (void *) self;
a126 3
#if NAPM > 0 || defined(DEBUG)
	bios_apminfo_t *apm = NULL;
#endif
a128 1
	bootarg_t *q;
d144 26
a169 1
	printf("%s:", sc->sc_dev.dv_xname);
d175 17
a191 1
			printf(" memmap %p", q->ba_arg);
d197 1
a199 1
#if NAPM > 0 || defined(DEBUG)
d201 1
a202 1
			break;
d213 4
a223 17
#if NAPM > 0
	if (apm) {
		struct bios_attach_args ba;
#if defined(DEBUG) || defined(APMDEBUG)
		printf("apminfo: %x, code %x/%x[%x], data %x[%x], entry %x\n",
		    apm->apm_detail, apm->apm_code32_base,
		    apm->apm_code16_base, apm->apm_code_len,
		    apm->apm_data_base, apm->apm_data_len, apm->apm_entry);
#endif
		ba.bios_dev = "apm";
		ba.bios_func = 0x15;
		ba.bios_memt = bia->bios_memt;
		ba.bios_iot = bia->bios_iot;
		ba.bios_apmp = apm;
		config_found(self, &ba, bios_print);
	}
#endif
a349 1
	extern u_int cnvmem, extmem; /* locore.s */
d357 3
a361 2
		if (bootapiver < BOOTARG_APIVER)
			return EOPNOTSUPP;
a368 2
		if (bootapiver < BOOTARG_APIVER)
			return EOPNOTSUPP;
a371 4
	case BIOS_CNVMEM:
		return sysctl_rdint(oldp, oldlenp, newp, cnvmem);
	case BIOS_EXTMEM:
		return sysctl_rdint(oldp, oldlenp, newp, extmem);
@


1.23
log
@print info about apm when APMDEBUG is defined
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.22 1998/02/24 22:02:09 weingart Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997 Michael Shalayeff
d17 1
a17 1
 *	This product includes software developed by Michael Shalayeff.
d21 11
a31 12
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
d102 1
a102 1
	       bootapiver, BOOT_APIVER, bootargp, bootargc);
d108 1
a108 1
	if (bootapiver < BOOT_APIVER || bootargp == NULL )
d332 1
a332 1
		if (bootapiver < BOOT_APIVER)
d341 1
a341 1
		if (bootapiver < BOOT_APIVER)
@


1.22
log
@First commit of /boot changes/fixes.  More to come.
Add BIOS PCI probe stuff.
@
text
@d183 1
a183 1
#ifdef DEBUG
@


1.21
log
@Make booting new kernels with old bootblocks moer robust
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.20 1997/11/10 16:09:55 flipk Exp $	*/
d65 1
d85 3
d167 6
@


1.20
log
@"unused variable 'bia'"
when DEBUG defined and NAPM=0
is now gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.19 1997/10/26 09:32:47 niklas Exp $	*/
a81 1
extern u_int bootapiver; /* locore.s */
@


1.19
log
@More info from attach, cleared by Mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.18 1997/10/25 19:50:08 mickey Exp $	*/
d118 3
a121 1
	struct bios_attach_args *bia = aux;
@


1.18
log
@treat a case bios0 is not attached
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.17 1997/10/25 08:45:53 mickey Exp $	*/
d146 1
a146 1
			printf(" memmap");
a148 1
			printf(" diskinfo");
d150 1
d153 1
a153 1
			printf(" apminfo");
d159 2
a160 2
			printf(" cksumlen");
			bios_cksumlen = (u_int32_t)q->ba_arg;
d163 2
d316 1
a316 1
	/* all sysctl names at this level are terminal */
@


1.17
log
@better sizeof
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.16 1997/10/25 07:01:36 niklas Exp $	*/
d85 1
a85 1
bios_diskinfo_t *bios_diskinfo;
d351 3
@


1.16
log
@Remove no-serving variable
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.15 1997/10/25 03:01:30 deraadt Exp $	*/
d333 1
a333 2
		return sysctl_rdstruct(oldp, oldlenp, newp,
		    pdi, sizeof(*bios_diskinfo));
@


1.15
log
@unused variable warning squelch
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.14 1997/10/24 23:24:29 deraadt Exp $	*/
d124 1
a124 1
	bootarg_t *p, *q;
d142 1
a142 1
	for(q = p = bootargp; q->ba_type != BOOTARG_END; q = q->ba_next) {
@


1.14
log
@uninitialized variables are bad
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.13 1997/10/24 22:15:05 mickey Exp $	*/
d118 1
a119 1
#if NAPM > 0 || defined(DEBUG)
@


1.13
log
@map a piece of memory after the msgbuf and copy bootargv there.
pass cksumlen argument, sysctl it
mostly by niklas
me just did slite editing.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.12 1997/10/24 06:49:20 mickey Exp $	*/
d120 1
a120 1
	bios_apminfo_t *apm;
d138 1
a138 1
	       str, va[15], va[5], va[6], va[8], va[9], va[11], va[12]);
d154 1
d156 1
d168 1
a168 1
	{
d171 4
a174 4
	printf("apminfo: %x, code %x/%x[%x], data %x[%x], entry %x\n",
	       apm->apm_detail, apm->apm_code32_base,
	       apm->apm_code16_base, apm->apm_code_len,
	       apm->apm_data_base, apm->apm_data_len, apm->apm_entry);
d195 1
a195 1
		       ba->bios_dev, pnp, ba->bios_func);
d334 1
a334 1
					pdi, sizeof(*bios_diskinfo));
@


1.12
log
@fix the case when data/code segment is not in the ISA memory
hole, so map 'em separatelly (or together if they intersect)
and use that mapped region for segment creations...
must help on some machines to avoid weird apm errors
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.11 1997/10/22 23:37:11 mickey Exp $	*/
a81 2
extern bus_addr_t bootargv;
extern int bootargc;
d86 1
a95 2
	bus_space_handle_t hsp;
	int error;
d100 1
a100 1
	       bootapiver, BOOT_APIVER, bootargv, bootargc);
d106 1
a106 1
	if (bootapiver < BOOT_APIVER || bootargv == NULL)
a108 9
	if ((error = bus_space_map(bia->bios_memt,
				   bootargv, bootargc, 1, &hsp)) != 0) {
#ifdef DEBUG
		printf("bios0: bus_space_map() == %d\n", error);
#endif
		return 0;
	}
	bus_space_unmap(bia->bios_memt, hsp, bootargc);

a123 1
	bus_space_handle_t hsp;
a125 7
	if (bus_space_map(bia->bios_memt, bootargv, bootargc, 1, &hsp) != 0) {
#ifdef DEBUG
		panic("getbootargs: can't map low memory");
#endif
		return;
	}

d141 2
a142 2
	p = (bootarg_t *)hsp;
	for(q = p; q->ba_type != BOOTARG_END; q = q->ba_next) {
d156 4
d337 2
@


1.11
log
@support new libsa
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.10 1997/10/19 06:34:21 mickey Exp $	*/
d181 3
a189 5
#if NAPM > 0
	{
		struct bios_attach_args ba;

		ba.bios_apmp = apm;
d192 3
@


1.10
log
@no, not good. will be fixed soon
xyu te6e B poT, teo
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.9 1997/10/18 00:33:11 weingart Exp $	*/
d35 2
d43 2
d50 1
a65 5
#define LMVAS (1024*1024-NBPG)
#define LMVOF NBPG

int gdt_get_slot __P((void));

a67 2

	bus_space_handle_t bt;
a71 1
void bios_init __P((bus_space_handle_t));
a72 1
static __inline int bios_call __P((u_int cmd, u_int arg));
d82 4
a85 40
int bios_initted = 0;
int bios_ds, bios_cs16;
bus_space_handle_t bios_lmva;
struct {
	u_int32_t ip;
	u_int16_t cs;
} bios_kentry;
struct BIOS_vars BIOS_vars;

static __inline int
bios_call(cmd, arg)
	u_int cmd;
	u_int arg;
{
	int rv;
	__asm volatile ("pushl %1\n\t"
			"pushl %2\n\t"
			"pushl %%ds\n\t"
			"movl  %4, %%ds\n\t"
			"movl  %4, %%es\n\t"
			"movl  %4, %%gs\n\t"
			"movl  %4, %%fs\n\t"
			"lcall %%cs:(%3)\n\t"
			"popl  %%ds\n\t"
			"addl $8, %%esp"
			: "=a" (rv)
			: "id" (cmd), "r" (arg),
			  "r" (&bios_kentry), "r" (bios_ds));
	return rv;
}

void
bios_init(bt)
	bus_space_handle_t bt;
{
	if (bios_initted)
		return;

	if (bus_space_map(bt, LMVOF, LMVAS, 0, &bios_lmva) == 0) {
		extern union descriptor *dynamic_gdt;
d87 1
a87 6
		setsegment(&dynamic_gdt[bios_kentry.cs = gdt_get_slot()].sd,
			   (void*)bios_lmva, LMVAS, SDT_MEMERA, SEL_KPL, 1, 0);
		setsegment(&dynamic_gdt[bios_ds = gdt_get_slot()].sd,
			   (void*)bios_lmva, LMVAS, SDT_MEMRWA, SEL_KPL, 1, 0);
		setsegment(&dynamic_gdt[bios_cs16 = gdt_get_slot()].sd,
			   (void*)bios_lmva, LMVAS, SDT_MEMERA, SEL_KPL, 0, 0);
d89 1
a89 3
		bios_initted++;
	}
}
d97 2
a98 1
	extern u_int bootapiver; /* locore.s */
d100 7
a106 1
	if (bootapiver == 0)
d109 2
a110 3
#if 0
	if (!bios_initted) {
		bus_space_handle_t hsp;
d112 6
a117 3
		if (bus_space_map(bia->bios_memt, LMVOF, LMVAS, 0, &hsp) != 0)
			return 0;
		bus_space_unmap(bia->bios_memt, hsp, LMVAS);
d119 3
a121 2
#endif
	return !bios_cd.cd_ndevs && !strcmp(bia->bios_dev, "bios");
d131 7
d139 6
a144 2
	u_int8_t *va = ISA_HOLE_VADDR(0xffff0);
	char *p;
a145 2
	sc->bt = bia->bios_memt;
	/* bios_init(sc->bt); */
d148 8
a155 8
	case 0xff: p = "PC";		break;
	case 0xfe: p = "PC/XT";		break;
	case 0xfd: p = "PCjr";		break;
	case 0xfc: p = "AT/286+";	break;
	case 0xfb: p = "PC/XT+";	break;
	case 0xfa: p = "PS/2 25/30";	break;
	case 0xf9: p = "PC Convertible";break;
	case 0xf8: p = "PS/2 386+";	break;
d158 23
a180 1
	    p, va[15], va[5], va[6], va[8], va[9], va[11], va[12]);
d183 3
a185 4
	    BIOS_vars.bios_apm_detail, BIOS_vars.bios_apm_code32_base,
	    BIOS_vars.bios_apm_code16_base, BIOS_vars.bios_apm_code_len,
	    BIOS_vars.bios_apm_data_base, BIOS_vars.bios_apm_data_len,
	    BIOS_vars.bios_apm_entry);
d191 1
a191 7
		ba.apm_detail = BIOS_vars.bios_apm_detail;
		ba.apm_code32_base = BIOS_vars.bios_apm_code32_base;
		ba.apm_code16_base = BIOS_vars.bios_apm_code16_base;
		ba.apm_code_len = BIOS_vars.bios_apm_code_len;
		ba.apm_data_base = BIOS_vars.bios_apm_data_base;
		ba.apm_data_len = BIOS_vars.bios_apm_data_len;
		ba.apm_entry = BIOS_vars.bios_apm_entry;
d193 1
d207 2
a208 1
		printf("%s at %s", ba->bios_dev, pnp);
d273 1
a273 1
	if (!bios_initted)
d323 3
a325 1
	extern u_int cnvmem, extmem, bootapiver; /* locore.s */
d328 1
a328 1
	if (namelen != 1)
a330 3
	if (bootapiver == 0)
		return EOPNOTSUPP;

d333 15
a347 3
		return sysctl_rdint(oldp, oldlenp, newp, BIOS_vars.bios_dev);
	case BIOS_GEOMETRY:
		return sysctl_rdint(oldp, oldlenp, newp, BIOS_vars.bios_geometry);
d357 23
@


1.9
log
@Copy in bios_diskinfo array from /boot space.
Add length field for checksum to same.
Start of making /boot deduce bsd dev_t for
all BIOS drives.
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.8 1997/09/29 03:42:25 mickey Exp $	*/
a93 1
bios_diskinfo_t bios_diskinfo[16];		/* XXX - For now */
@


1.8
log
@apm0 at bios0
configs will be updated
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.7 1997/09/24 23:00:01 mickey Exp $	*/
d94 1
@


1.7
log
@bios and pctr are both ocis w/ seltrue
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.6 1997/09/24 22:52:56 mickey Exp $	*/
d75 1
d158 1
a158 1
	return !bios_cd.cd_ndevs && !strcmp(bia->bios_busname, "bios");
a173 9
#if NAPM > 0
	apminfo.apm_detail = BIOS_vars.apm_detail;
	apminfo.apm_code32_seg_base = BIOS_vars.apm_code32_base;
	apminfo.apm_code16_seg_base = BIOS_vars.apm_code16_base;
	apminfo.apm_code32_seg_len = BIOS_vars.apm_code_len;
	apminfo.apm_data_seg_base = BIOS_vars.apm_data_base;
	apminfo.apm_data_seg_len = BIOS_vars.apm_data_len;
	apminfo.apm_entrypt = BIOS_vars.apm_entry;
#endif
d189 19
a207 4
	    BIOS_vars.apm_detail, BIOS_vars.apm_code32_base,
	    BIOS_vars.apm_code16_base, BIOS_vars.apm_code_len,
	    BIOS_vars.apm_data_base, BIOS_vars.apm_data_len,
	    BIOS_vars.apm_entry);
d209 12
@


1.6
log
@bios device is ocis from now
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.5 1997/09/22 12:09:45 deraadt Exp $	*/
a255 9
	return 0;
}

int
biosselect(dev, rw, p)
	dev_t	dev;
	int	rw;
	struct proc *p;
{
@


1.5
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.4 1997/09/21 23:00:41 mickey Exp $	*/
d256 9
@


1.4
log
@branch the bios tree inside the machdep
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.3 1997/09/21 22:08:07 weingart Exp $	*/
d174 1
a174 1
	apminfo.apm_detail          = BIOS_vars.apm_detail;
d177 4
a180 4
	apminfo.apm_code32_seg_len  = BIOS_vars.apm_code_len;
	apminfo.apm_data_seg_base   = BIOS_vars.apm_data_base;
	apminfo.apm_data_seg_len    = BIOS_vars.apm_data_len;
	apminfo.apm_entrypt         = BIOS_vars.apm_entry;
d183 9
a191 9
		default:
		case 0xff: p = "PC";		break;
		case 0xfe: p = "PC/XT";		break;
		case 0xfd: p = "PCjr";		break;
		case 0xfc: p = "AT/286+";	break;
		case 0xfb: p = "PC/XT+";	break;
		case 0xfa: p = "PS/2 25/30";	break;
		case 0xf9: p = "PC Convertible";break;
		case 0xf8: p = "PS/2 386+";	break;
d194 1
a194 1
	       p, va[15], va[5], va[6], va[8], va[9], va[11], va[12]);
d197 4
a200 4
		BIOS_vars.apm_detail, BIOS_vars.apm_code32_base,
		BIOS_vars.apm_code16_base, BIOS_vars.apm_code_len,
		BIOS_vars.apm_data_base, BIOS_vars.apm_data_len,
		BIOS_vars.apm_entry);
@


1.3
log
@Stray %u, poof
@
text
@d1 1
a1 1
/*	$OpenBSD: bios.c,v 1.2 1997/09/21 05:18:07 mickey Exp $	*/
a304 3
/*  
 * machine dependent system variables.
 */ 
d306 1
a306 1
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
a315 1
	dev_t consdev;
d321 1
a321 1
	if (bootapiver == 0 && name[0] != CPU_CONSDEV)
d325 1
a325 7
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return sysctl_rdstruct(oldp, oldlenp, newp, &consdev, sizeof consdev);
	case CPU_BIOSDEV:
d327 1
a327 1
	case CPU_BIOSGEOMETRY:
d329 1
a329 1
	case CPU_CNVMEM:
d331 1
a331 1
	case CPU_EXTMEM:
@


1.2
log
@bootapiver is unsigned
don'tprint entry point, which is valid at the moment
don't support new CPU* sysctls being boot w/ old boots
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d193 1
a193 1
	printf(": %s(%02x) BIOS, date %u%c%c/%c%c/%c%c\n",
@


1.1
log
@support new boots
add to your config:
bios0 at mainbus0
apm0 at mainbus0	# (if you are using APM)
@
text
@d143 1
a143 1
	extern int bootapiver; /* locore.s */
d193 2
a194 3
	printf(": %s(%02x) BIOS, date %c%c/%c%c/%c%c; entry %x:%x\n",
	       p, va[15], va[5], va[6], va[8], va[9], va[11], va[12],
	       bios_kentry.cs, bios_kentry.ip);
d318 1
a318 1
	extern u_int cnvmem, extmem;
d324 3
@

