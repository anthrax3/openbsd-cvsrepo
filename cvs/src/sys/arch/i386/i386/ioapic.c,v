head	1.40;
access;
symbols
	OPENBSD_6_1:1.38.0.6
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.38.0.2
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.27.0.4
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.2
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.4
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	UBC_SYNC_A:1.1
	UBC_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.40
date	2017.08.29.15.19.57;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	k3fxvzTcBCdGH4Z4;

1.39
date	2017.08.08.15.53.55;	author visa;	state Exp;
branches;
next	1.38;
commitid	6B7LR9Puqd7qyZjP;

1.38
date	2016.05.07.14.19.50;	author kettenis;	state Exp;
branches;
next	1.37;
commitid	dLJGiP2q7RyaboOz;

1.37
date	2015.09.08.07.12.56;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	UsnEcDGT4QqqoPvB;

1.36
date	2015.07.13.17.45.01;	author mikeb;	state Exp;
branches;
next	1.35;
commitid	zrjFB8VvK0ekXjjA;

1.35
date	2015.04.29.04.29.23;	author jsg;	state Exp;
branches;
next	1.34;
commitid	U9xF9kYRexusnt6p;

1.34
date	2014.12.09.06.58.28;	author doug;	state Exp;
branches;
next	1.33;
commitid	yWAxzpQP2PPpYlfT;

1.33
date	2014.11.22.18.55.20;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	nFIm5oOp8CCDBtjV;

1.32
date	2014.07.17.12.56.07;	author dlg;	state Exp;
branches;
next	1.31;
commitid	Zb1U0BBOzPFl6Ur5;

1.31
date	2014.07.12.18.44.41;	author tedu;	state Exp;
branches;
next	1.30;
commitid	uKVPYMN2MLxdZxzH;

1.30
date	2013.10.01.20.22.11;	author sf;	state Exp;
branches
	1.30.4.1;
next	1.29;

1.29
date	2013.07.10.21.31.11;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2013.05.16.19.26.04;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2012.07.09.16.09.47;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2011.04.16.00.40.58;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	2010.08.08.16.43.19;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.22.00.41.29;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.13.13.24.48;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.09.18.53.16;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2008.10.21.21.52.07;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2008.10.21.21.31.10;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2008.10.05.16.57.36;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.28.19.13.51;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.22.19.46.16;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.22.03.47.14;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.19.20.44.24;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.12.04.41.30;	author gwk;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.11.13.21.11;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.09.18.41.22;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.08.20.50.38;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.06.19.10.06;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.10.14.35.13;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.12.06.11.57;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.28.01.41.53;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.23.17.14.31;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.14.10.02.25;	author ho;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.07.14.10.02.25;	author ho;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.07.15.15.10.54;	author ho;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.07.16.21.39.28;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.10.27.09.57.31;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2003.05.13.19.42.07;	author ho;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2003.05.15.16.44.33;	author niklas;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2004.03.14.22.08.20;	author niklas;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2004.03.30.09.07.45;	author niklas;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2004.06.09.18.37.04;	author drahn;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	2004.06.10.15.58.51;	author deraadt;	state Exp;
branches;
next	1.1.2.13;

1.1.2.13
date	2004.06.13.07.31.56;	author deraadt;	state Exp;
branches;
next	1.1.2.14;

1.1.2.14
date	2004.06.13.18.42.25;	author grange;	state Exp;
branches;
next	;

1.30.4.1
date	2014.07.17.13.13.45;	author sthen;	state Exp;
branches;
next	;
commitid	HBUMLKCYiOHjgoMK;


desc
@@


1.40
log
@In previous change, misconfigured APICs were not being repaired.
noticed by Andrew Daugherity
ok kettenis
@
text
@/*	$OpenBSD: ioapic.c,v 1.39 2017/08/08 15:53:55 visa Exp $	*/
/* 	$NetBSD: ioapic.c,v 1.7 2003/07/14 22:32:40 lukem Exp $	*/

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * Copyright (c) 1999 Stefan Grefen
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the NetBSD
 *      Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/bus.h>
#include <machine/psl.h>

#include <uvm/uvm_extern.h>

#include <machine/i82093reg.h>
#include <machine/i82093var.h>

#include <machine/i82489reg.h>
#include <machine/i82489var.h>

#include <machine/pmap.h>

#include <machine/mpbiosvar.h>

#include "isa.h"

/*
 * XXX locking
 */

int     ioapic_match(struct device *, void *, void *);
void    ioapic_attach(struct device *, struct device *, void *);
int	ioapic_activate(struct device *, int);

/* XXX */
extern int bus_mem_add_mapping(bus_addr_t, bus_size_t, int,
    bus_space_handle_t *);

void ioapic_hwmask(struct pic *, int);
void ioapic_hwunmask(struct pic *, int);
void	apic_set_redir(struct ioapic_softc *, int);
void	apic_vectorset(struct ioapic_softc *, int, int, int);

void	apic_stray(int);

int ioapic_bsp_id = 0;
int ioapic_cold = 1;

struct ioapic_softc *ioapics;	 /* head of linked list */
int nioapics = 0;	   	 /* number attached */
static int ioapic_vecbase;

void ioapic_set_id(struct ioapic_softc *);

static __inline u_long
ioapic_lock(struct ioapic_softc *sc)
{
	u_long flags;

	flags = intr_disable();
#ifdef MULTIPROCESSOR
	mtx_enter(&sc->sc_pic.pic_mutex);
#endif
	return flags;
}

static __inline void
ioapic_unlock(struct ioapic_softc *sc, u_long flags)
{
#ifdef MULTIPROCESSOR
	mtx_leave(&sc->sc_pic.pic_mutex);
#endif
	intr_restore(flags);
}

/*
 * Register read/write routines.
 */
static __inline u_int32_t
ioapic_read_ul(struct ioapic_softc *sc,int regid)
{
	u_int32_t val;
	
	*(sc->sc_reg) = regid;
	val = *sc->sc_data;

	return (val);
}

static __inline void
ioapic_write_ul(struct ioapic_softc *sc,int regid, u_int32_t val)
{
	*(sc->sc_reg) = regid;
	*(sc->sc_data) = val;
}

static __inline u_int32_t
ioapic_read(struct ioapic_softc *sc, int regid)
{
	u_int32_t val;
	u_long flags;

	flags = ioapic_lock(sc);
	val = ioapic_read_ul(sc, regid);
	ioapic_unlock(sc, flags);
	return val;
}

static __inline void
ioapic_write(struct ioapic_softc *sc,int regid, int val)
{
	u_long flags;

	flags = ioapic_lock(sc);
	ioapic_write_ul(sc, regid, val);
	ioapic_unlock(sc, flags);
}

struct ioapic_softc *
ioapic_find(int apicid)
{
	struct ioapic_softc *sc;

	if (apicid == MPS_ALL_APICS) {	/* XXX mpbios-specific */
		/*
		 * XXX kludge for all-ioapics interrupt support
		 * on single ioapic systems
		 */
		if (nioapics <= 1)
			return (ioapics);
		panic("unsupported: all-ioapics interrupt with >1 ioapic");
	}

	for (sc = ioapics; sc != NULL; sc = sc->sc_next)
		if (sc->sc_apicid == apicid)
			return (sc);

	return (NULL);
}

/*
 * For the case the I/O APICs were configured using ACPI, there must
 * be an option to match global ACPI interrupts with APICs.
 */
struct ioapic_softc *
ioapic_find_bybase(int vec)
{
	struct ioapic_softc *sc;

	for (sc = ioapics; sc != NULL; sc = sc->sc_next) {
		if (vec >= sc->sc_apic_vecbase &&
		    vec < (sc->sc_apic_vecbase + sc->sc_apic_sz))
			return sc;
	}

	return NULL;
}

static __inline void
ioapic_add(struct ioapic_softc *sc)
{
	sc->sc_next = ioapics;
	ioapics = sc;
	nioapics++;
}

void
ioapic_print_redir(struct ioapic_softc *sc, char *why, int pin)
{
	u_int32_t redirlo = ioapic_read(sc, IOAPIC_REDLO(pin));
	u_int32_t redirhi = ioapic_read(sc, IOAPIC_REDHI(pin));

	apic_format_redir(sc->sc_pic.pic_name, why, pin, redirhi, redirlo);
}

struct cfattach ioapic_ca = {
	sizeof(struct ioapic_softc), ioapic_match, ioapic_attach, NULL,
	ioapic_activate
};

struct cfdriver ioapic_cd = {
	NULL, "ioapic", DV_DULL
};

int
ioapic_match(struct device *parent, void *v, void *aux)
{
	struct apic_attach_args *aaa = (struct apic_attach_args *)aux;
	struct cfdata *match = v;

	if (strcmp(aaa->aaa_name, match->cf_driver->cd_name) == 0)
		return (1);
	return (0);
}

/* Reprogram the APIC ID, and check that it actually got set. */
void
ioapic_set_id(struct ioapic_softc *sc)
{
	u_int8_t apic_id;

	ioapic_write(sc, IOAPIC_ID,
	    (ioapic_read(sc, IOAPIC_ID) & ~IOAPIC_ID_MASK) |
	    (sc->sc_apicid << IOAPIC_ID_SHIFT));

	apic_id = (ioapic_read(sc, IOAPIC_ID) & IOAPIC_ID_MASK) >>
	    IOAPIC_ID_SHIFT;

	if (apic_id != sc->sc_apicid)
		printf(", can't remap to apid %d\n", sc->sc_apicid);
	else
		printf(", remapped to apid %d\n", sc->sc_apicid);
}

/*
 * can't use bus_space_xxx as we don't have a bus handle ...
 */
void
ioapic_attach(struct device *parent, struct device *self, void *aux)
{
	struct ioapic_softc *sc = (struct ioapic_softc *)self;
	struct apic_attach_args  *aaa = (struct apic_attach_args *)aux;
	int apic_id;
	bus_space_handle_t bh;
	u_int32_t ver_sz;
	int i;

	sc->sc_flags = aaa->flags;
	sc->sc_apicid = aaa->apic_id;

	printf(": apid %d", aaa->apic_id);

	if (ioapic_find(aaa->apic_id) != NULL) {
		printf(", duplicate apic id (ignored)\n");
		return;
	}

	ioapic_add(sc);

	printf(" pa 0x%x", aaa->apic_address);

	if (bus_mem_add_mapping(aaa->apic_address, PAGE_SIZE, 0, &bh) != 0) {
		printf(", map failed\n");
		return;
	}
	sc->sc_reg = (volatile u_int32_t *)(bh + IOAPIC_REG);
	sc->sc_data = (volatile u_int32_t *)(bh + IOAPIC_DATA);

	ver_sz = ioapic_read(sc, IOAPIC_VER);
	sc->sc_apic_vers = (ver_sz & IOAPIC_VER_MASK) >> IOAPIC_VER_SHIFT;
	sc->sc_apic_sz = (ver_sz & IOAPIC_MAX_MASK) >> IOAPIC_MAX_SHIFT;
	sc->sc_apic_sz++;

	if (aaa->apic_vecbase != -1)
		sc->sc_apic_vecbase = aaa->apic_vecbase;
	else {
		/*
		 * XXX this assumes ordering of ioapics in the table.
		 * Only needed for broken BIOS workaround (see mpbios.c)
		 */
		sc->sc_apic_vecbase = ioapic_vecbase;
		ioapic_vecbase += sc->sc_apic_sz;
	}

	if (mp_verbose) {
		printf(", %s mode",
		    aaa->flags & IOAPIC_PICMODE ? "PIC" : "virtual wire");
	}

	printf(", version %x, %d pins\n", sc->sc_apic_vers, sc->sc_apic_sz);

	apic_id = (ioapic_read(sc, IOAPIC_ID) & IOAPIC_ID_MASK) >>
	    IOAPIC_ID_SHIFT;

	sc->sc_pins = mallocarray(sc->sc_apic_sz, sizeof(struct ioapic_pin),
	    M_DEVBUF, M_WAITOK);

	for (i = 0; i < sc->sc_apic_sz; i++) {
		sc->sc_pins[i].ip_handler = NULL;
		sc->sc_pins[i].ip_next = NULL;
		sc->sc_pins[i].ip_map = NULL;
		sc->sc_pins[i].ip_vector = 0;
		sc->sc_pins[i].ip_type = 0;
		sc->sc_pins[i].ip_minlevel = 0xff; /* XXX magic*/
		sc->sc_pins[i].ip_maxlevel = 0; /* XXX magic */
	}

	/*
	 * In case the APIC is not initialized to the correct ID
	 * do it now.
	 */
	if (apic_id != sc->sc_apicid) {
		if (mp_verbose)
			printf("%s: misconfigured as apic %d",
			    sc->sc_pic.pic_name, apic_id);
		ioapic_set_id(sc);
	}
#if 0
	/* output of this was boring. */
	if (mp_verbose)
		for (i = 0; i < sc->sc_apic_sz; i++)
			ioapic_print_redir(sc, "boot", i);
#endif
}

int
ioapic_activate(struct device *self, int act)
{
	struct ioapic_softc *sc = (struct ioapic_softc *)self;

	switch (act) {
	case DVACT_RESUME:
		/* On resume, reset the APIC id, like we do on boot */
		ioapic_write(sc, IOAPIC_ID,
		    (ioapic_read(sc, IOAPIC_ID) & ~IOAPIC_ID_MASK) |
		    (sc->sc_apicid << IOAPIC_ID_SHIFT));
	}

	return (0);
}

/*
 * Interrupt mapping.
 *
 * Multiple handlers may exist for each pin, so there's an
 * intrhand chain for each pin.
 *
 * Ideally, each pin maps to a single vector at the priority of the
 * highest level interrupt for that pin.
 *
 * XXX in the event that there are more than 16 interrupt sources at a
 * single level, some doubling-up may be needed.  This is not yet
 * implemented.
 *
 * XXX we are wasting some space here because we only use a limited
 * range of the vectors here.  (0x30..0xef)
 */

struct intrhand *apic_intrhand[256];
int	apic_maxlevel[256];


/* XXX should check vs. softc max int number */
#define	LEGAL_IRQ(x)	((x) >= 0 && (x) < APIC_ICU_LEN && (x) != 2)

void
apic_set_redir(struct ioapic_softc *sc, int pin)
{
	u_int32_t redlo;
	u_int32_t redhi = 0;
	int delmode;

	struct ioapic_pin *pp;
	struct mp_intr_map *map;

	pp = &sc->sc_pins[pin];
	map = pp->ip_map;
	redlo = (map == NULL) ? IOAPIC_REDLO_MASK : map->redir;
	delmode = (redlo & IOAPIC_REDLO_DEL_MASK) >> IOAPIC_REDLO_DEL_SHIFT;

	/* XXX magic numbers */
	if ((delmode != 0) && (delmode != 1))
		;
	else if (pp->ip_handler == NULL) {
		redlo |= IOAPIC_REDLO_MASK;
	} else {
		redlo |= (pp->ip_vector & 0xff);
		redlo &= ~IOAPIC_REDLO_DEL_MASK;
		redlo |= (IOAPIC_REDLO_DEL_FIXED << IOAPIC_REDLO_DEL_SHIFT);
		redlo &= ~IOAPIC_REDLO_DSTMOD;

		/*
		 * Destination: BSP CPU
		 *
		 * XXX will want to distribute interrupts across cpu's
		 * eventually.  most likely, we'll want to vector each
		 * interrupt to a specific CPU and load-balance across
		 * cpu's.  but there's no point in doing that until after
		 * most interrupts run without the kernel lock.
		 */
		redhi |= (ioapic_bsp_id << IOAPIC_REDHI_DEST_SHIFT);

		/* XXX derive this bit from BIOS info */
		if (pp->ip_type == IST_LEVEL)
			redlo |= IOAPIC_REDLO_LEVEL;
		else
			redlo &= ~IOAPIC_REDLO_LEVEL;
		if (map != NULL && ((map->flags & 3) == MPS_INTPO_DEF)) {
			if (pp->ip_type == IST_LEVEL)
				redlo |= IOAPIC_REDLO_ACTLO;
			else
				redlo &= ~IOAPIC_REDLO_ACTLO;
		}
	}
	/* Do atomic write */
	ioapic_write(sc, IOAPIC_REDLO(pin), IOAPIC_REDLO_MASK);
	ioapic_write(sc, IOAPIC_REDHI(pin), redhi);
	ioapic_write(sc, IOAPIC_REDLO(pin), redlo);
	if (mp_verbose)
		ioapic_print_redir(sc, "int", pin);
}

/*
 * XXX To be really correct an NISA > 0 condition should check for these.
 * However, the i386 port pretty much assumes isa is there anyway.
 * For example, pci_intr_establish calls isa_intr_establish unconditionally.
 */
extern int fakeintr(void *); 	/* XXX headerify */
extern char *isa_intr_typename(int); 	/* XXX headerify */

/*
 * apic_vectorset: allocate a vector for the given pin, based on
 * the levels of the interrupts on that pin.
 *
 * XXX if the level of the pin changes while the pin is
 * masked, need to do something special to prevent pending
 * interrupts from being lost.
 * (the answer may be to hang the interrupt chain off of both vectors
 * until any interrupts from the old source have been handled.  the trouble
 * is that we don't have a global view of what interrupts are pending.
 *
 * Deferring for now since MP systems are more likely servers rather
 * than laptops or desktops, and thus will have relatively static
 * interrupt configuration.
 */

void
apic_vectorset(struct ioapic_softc *sc, int pin, int minlevel, int maxlevel)
{
	struct ioapic_pin *pp = &sc->sc_pins[pin];
	int nvector, ovector = pp->ip_vector;
	
	if (maxlevel == 0) {
		/* no vector needed. */
		pp->ip_minlevel = 0xff; /* XXX magic */
		pp->ip_maxlevel = 0; /* XXX magic */
		pp->ip_vector = 0;
	} else if (minlevel != pp->ip_minlevel) {
#ifdef MPVERBOSE
		if (minlevel != maxlevel)
			printf("%s: pin %d shares different IPL interrupts "
			    "(%x..%x)\n", sc->sc_pic.pic_name, pin,
			    minlevel, maxlevel);
#endif

		/*
		 * Allocate interrupt vector at the *lowest* priority level
		 * of any of the handlers invoked by this pin.
		 *
		 * The interrupt handler will raise ipl higher than this
		 * as appropriate.
		 */
		nvector = idt_vec_alloc(minlevel, minlevel+15);
		if (nvector == 0) {
			/*
			 * XXX XXX we should be able to deal here..
			 * need to double-up an existing vector
			 * and install a slightly different handler.
			 */
			panic("%s: can't alloc vector for pin %d at level %x",
			    sc->sc_pic.pic_name, pin, maxlevel);
		}

		idt_vec_set(nvector, apichandler[nvector & 0xf]);
		pp->ip_minlevel = minlevel;
		pp->ip_vector = nvector;
	}

	pp->ip_maxlevel = maxlevel;
	apic_maxlevel[pp->ip_vector] = maxlevel;
	apic_intrhand[pp->ip_vector] = pp->ip_handler;

	if (ovector && ovector != pp->ip_vector) {
		/*
		 * XXX should defer this until we're sure the old vector
		 * doesn't have a pending interrupt on any processor.
		 * do this by setting a counter equal to the number of CPU's,
		 * and firing off a low-priority broadcast IPI to all cpu's.
		 * each cpu then decrements the counter; when it
		 * goes to zero, free the vector..
		 * i.e., defer until all processors have run with a CPL
		 * less than the level of the interrupt..
		 *
		 * this is only an issue for dynamic interrupt configuration
		 * (e.g., cardbus or pcmcia).
		 */
		apic_intrhand[ovector] = NULL;
		idt_vec_free(ovector);
	}

	apic_set_redir(sc, pin);
}

/*
 * Throw the switch and enable interrupts..
 */

void
ioapic_enable(void)
{
	int p, maxlevel, minlevel;
	struct ioapic_softc *sc;
	struct intrhand *q;
	extern void intr_calculatemasks(void); /* XXX */

	intr_calculatemasks();	/* for softints, AST's */

	ioapic_cold = 0;

	if (ioapics == NULL)
		return;

#if 1 /* XXX Will probably get removed */
	lapic_set_softvectors();
	lapic_set_lvt();
#endif

	if (ioapics->sc_flags & IOAPIC_PICMODE) {
		printf("%s: writing to IMCR to disable pics\n",
		    ioapics->sc_pic.pic_name);
		outb(IMCR_ADDR, IMCR_REGISTER);
		outb(IMCR_DATA, IMCR_APIC);
	}

	for (sc = ioapics; sc != NULL; sc = sc->sc_next) {
		if (mp_verbose)
			printf("%s: enabling\n", sc->sc_pic.pic_name);

		for (p = 0; p < sc->sc_apic_sz; p++) {
			maxlevel = 0;	 /* magic */
			minlevel = 0xff; /* magic */
				
			for (q = sc->sc_pins[p].ip_handler; q != NULL;
			     q = q->ih_next) {
				if (q->ih_level > maxlevel)
					maxlevel = q->ih_level;
				if (q->ih_level < minlevel)
					minlevel = q->ih_level;
			}
			apic_vectorset(sc, p, minlevel, maxlevel);
		}
	}
}

void
ioapic_hwmask(struct pic *pic, int pin)
{
	u_int32_t redlo;
	struct ioapic_softc *sc = (struct ioapic_softc *)pic;
	u_long flags;

	if (ioapic_cold)
		return;
	flags = ioapic_lock(sc);
	redlo = ioapic_read_ul(sc, IOAPIC_REDLO(pin));
	redlo |= IOAPIC_REDLO_MASK;
	ioapic_write_ul(sc, IOAPIC_REDLO(pin), redlo);
	ioapic_unlock(sc, flags);
}

void
ioapic_hwunmask(struct pic *pic, int pin)
{
	u_int32_t redlo;
	struct ioapic_softc *sc = (struct ioapic_softc *)pic;
	u_long flags;

	if (ioapic_cold)
		return;
	flags = ioapic_lock(sc);
	redlo = ioapic_read_ul(sc, IOAPIC_REDLO(pin));
	redlo &= ~IOAPIC_REDLO_MASK;
	ioapic_write_ul(sc, IOAPIC_REDLO(pin), redlo);
	ioapic_unlock(sc, flags);
}

/*
 * Interrupt handler management with the apic is radically different from the
 * good old 8259.
 *
 * The APIC adds an additional level of indirection between interrupt
 * signals and interrupt vectors in the IDT.
 * It also encodes a priority into the high-order 4 bits of the IDT vector
 * number.
 *
 *
 * interrupt establishment:
 *	-> locate interrupt pin.
 *	-> locate or allocate vector for pin.
 *	-> locate or allocate handler chain for vector.
 *	-> chain interrupt into handler chain.
 * 	#ifdef notyet
 *	-> if level of handler chain increases, reallocate vector, move chain.
 *	#endif
 */

void *
apic_intr_establish(int irq, int type, int level, int (*ih_fun)(void *),
    void *ih_arg, const char *ih_what)
{
	unsigned int ioapic = APIC_IRQ_APIC(irq);
	unsigned int intr = APIC_IRQ_PIN(irq);
	struct ioapic_softc *sc = ioapic_find(ioapic);
	struct ioapic_pin *pin;
	struct intrhand **p, *q, *ih;
	extern int cold;
	int minlevel, maxlevel;
	extern void intr_calculatemasks(void); /* XXX */
	int flags;

	flags = level & IPL_MPSAFE;
	level &= ~IPL_MPSAFE;

	KASSERT(level <= IPL_TTY || flags & IPL_MPSAFE);

	if (sc == NULL)
		panic("apic_intr_establish: unknown ioapic %d", ioapic);

	if ((irq & APIC_INT_VIA_APIC) == 0)
		panic("apic_intr_establish of non-apic interrupt 0x%x", irq);

	if (intr >= sc->sc_apic_sz || type == IST_NONE)
		panic("apic_intr_establish: bogus intr or type");

	/* no point in sleeping unless someone can free memory. */
	ih = malloc(sizeof *ih, M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL)
		panic("apic_intr_establish: can't malloc handler info");

	pin = &sc->sc_pins[intr];
	switch (pin->ip_type) {
	case IST_NONE:
		pin->ip_type = type;
		break;
	case IST_EDGE:
		intr_shared_edge = 1;
		/* FALLTHROUGH */
	case IST_LEVEL:
		if (type == pin->ip_type)
			break;
	case IST_PULSE:
		if (type != IST_NONE) {
			/*printf("%s: intr_establish: can't share %s with %s, irq %d\n",
			    ih_what, isa_intr_typename(pin->ip_type),
			    isa_intr_typename(type), intr);*/
			free(ih, M_DEVBUF, sizeof(*ih));
			return (NULL);
		}
		break;
	}

	if (!cold)
		ioapic_hwmask(&sc->sc_pic, intr);

	/*
	 * Figure out where to put the handler.
	 * This is O(N^2) to establish N interrupts, but we want to
	 * preserve the order, and N is generally small.
	 */
	maxlevel = level;
	minlevel = level;
	for (p = &pin->ip_handler; (q = *p) != NULL; p = &q->ih_next) {
		if (q->ih_level > maxlevel)
			maxlevel = q->ih_level;
		if (q->ih_level < minlevel)
			minlevel = q->ih_level;
	}

	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_next = NULL;
	ih->ih_level = level;
	ih->ih_flags = flags;
	ih->ih_irq = irq;
	evcount_attach(&ih->ih_count, ih_what, &pin->ip_vector);

	*p = ih;

	intr_calculatemasks();

	/*
	 * Fix up the vector for this pin.
	 * (if cold, defer this until most interrupts have been established,
	 * to avoid too much thrashing of the idt..)
	 */

	if (!ioapic_cold)
		apic_vectorset(sc, intr, minlevel, maxlevel);

	if (!cold)
		ioapic_hwunmask(&sc->sc_pic, intr);

	return (ih);
}

/*
 * apic disestablish:
 *	locate handler chain.
 * 	dechain intrhand from handler chain
 *	if chain empty {
 *		reprogram apic for "safe" vector.
 *		free vector (point at stray handler).
 *	}
 *	#ifdef notyet
 *	else {
 *		recompute level for current chain.
 *		if changed, reallocate vector, move chain.
 *	}
 *	#endif
 */

void
apic_intr_disestablish(void *arg)
{
	struct intrhand *ih = arg;
	int irq = ih->ih_irq;
	unsigned int ioapic = APIC_IRQ_APIC(irq);
	unsigned int intr = APIC_IRQ_PIN(irq);
	struct ioapic_softc *sc = ioapic_find(ioapic);
	struct ioapic_pin *pin;
	struct intrhand **p, *q;
	int minlevel, maxlevel;
	extern void intr_calculatemasks(void); /* XXX */

	if (sc == NULL)
		panic("apic_intr_disestablish: unknown ioapic %d", ioapic);
	pin = &sc->sc_pins[intr];

	if (intr >= sc->sc_apic_sz)
		panic("apic_intr_disestablish: bogus irq");

	/*
	 * Remove the handler from the chain.
	 * This is O(n^2), too.
	 */
	maxlevel = 0;
	minlevel = 0xff;
	for (p = &pin->ip_handler; (q = *p) != NULL && q != ih;
	     p = &q->ih_next) {
		if (q->ih_level > maxlevel)
			maxlevel = q->ih_level;
		if (q->ih_level < minlevel)
			minlevel = q->ih_level;
	}

	if (q)
		*p = q->ih_next;
	else
		panic("intr_disestablish: handler not registered");
	for (q = *p; q != NULL; q = q->ih_next) {
		if (q->ih_level > maxlevel)
			maxlevel = q->ih_level;
		if (q->ih_level < minlevel)
			minlevel = q->ih_level;
	}

	intr_calculatemasks();
	if (!ioapic_cold)
		apic_vectorset(sc, intr, minlevel, maxlevel);

	evcount_detach(&ih->ih_count);
	free(ih, M_DEVBUF, sizeof(*ih));
}

void
apic_stray(int irqnum)
{
	unsigned int apicid;
	struct ioapic_softc *sc;

	apicid = APIC_IRQ_APIC(irqnum);
	sc = ioapic_find(apicid);
	if (sc == NULL)
		return;
	printf("%s: stray interrupt %d\n", sc->sc_pic.pic_name, irqnum);
}

#ifdef DDB
void ioapic_dump(void);

void
ioapic_dump(void)
{
	struct ioapic_softc *sc;
	struct ioapic_pin *ip;
	int p;

	for (sc = ioapics; sc != NULL; sc = sc->sc_next) {
		for (p = 0; p < sc->sc_apic_sz; p++) {
			ip = &sc->sc_pins[p];
			if (ip->ip_type != IST_NONE)
				ioapic_print_redir(sc, "dump", p);
		}
	}
}
#endif
@


1.39
log
@Get rid of read_psl() and write_psl() by replacing
read_psl() + disable_intr() with intr_disable(),
and write_psl() with intr_restore().

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.38 2016/05/07 14:19:50 kettenis Exp $	*/
d355 4
a358 3
	if (mp_verbose && apic_id != sc->sc_apicid) {
		printf("%s: misconfigured as apic %d",
		    sc->sc_pic.pic_name, apic_id);
@


1.38
log
@Stop printing the "ioapic0: misconfigured as apic..." messages.  Basically
all modern machines are "misconfigured".  We simply have to configure them
and it is pointless to complain.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.37 2015/09/08 07:12:56 deraadt Exp $	*/
d123 1
a123 2
	flags = read_psl();
	disable_intr();
d136 1
a136 1
	write_psl(flags);
@


1.37
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.36 2015/07/13 17:45:01 mikeb Exp $	*/
d356 1
a356 1
	if (apic_id != sc->sc_apicid) {
@


1.36
log
@remove unused isa_nodefaultirq;  ok kettenis, mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.35 2015/04/29 04:29:23 jsg Exp $	*/
d709 1
a709 1
			free(ih, M_DEVBUF, 0);
d825 1
a825 1
	free(ih, M_DEVBUF, 0);
@


1.35
log
@Move a variable's initialisation so a panic will work as intended.

ok guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.34 2014/12/09 06:58:28 doug Exp $	*/
a587 4
#if 0 /* XXX Will be removed when we have intrsource. */
	isa_nodefaultirq();
#endif
			
@


1.34
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.33 2014/11/22 18:55:20 deraadt Exp $	*/
d787 1
a787 1
	struct ioapic_pin *pin = &sc->sc_pins[intr];
d794 1
@


1.33
log
@{ on seperate line at start of function or I go crazy
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.32 2014/07/17 12:56:07 dlg Exp $	*/
d339 1
a339 1
	sc->sc_pins = malloc(sizeof(struct ioapic_pin) * sc->sc_apic_sz,
@


1.32
log
@interrupt handlers established via the ioapic didnt get their
ih_flags set. ih_flags are used by the intr_handler() code to
determine if the kernel lock should be taken or not.

because the flags werent set, random memory was used instead which
in turn meant you sometimes didnt have the biglock when running
interrupt handlers which relied on it. races ahoy.

this was found by jmatthew@@ while helping me try to figure out why
bnx was blowing up and causing double frees and use after frees.
turns out bnx was the smoke for this fire.

sorry it took so long.

ok kettenis@@ sthen@@
sthen@@ seems happy to have the i386 ports build machine working again.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.31 2014/07/12 18:44:41 tedu Exp $	*/
d262 2
a263 1
ioapic_set_id(struct ioapic_softc *sc) {
d832 2
a833 1
apic_stray(int irqnum) {
@


1.31
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.30 2013/10/01 20:22:11 sf Exp $	*/
d739 1
@


1.30
log
@Format string fixes: %hu/%hd for uint16_t, %u/%d/%x for uint32_t

- despite the name, ntohl returns uint32_t, not long
- also fix some %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.29 2013/07/10 21:31:11 kettenis Exp $	*/
d712 1
a712 1
			free(ih, M_DEVBUF);
d826 1
a826 1
	free(ih, M_DEVBUF);
@


1.30.4.1
log
@merge ioapic.c fix from -current (r1.32), suggested by miod via dlg, ok deraadt@@

interrupt handlers established via the ioapic didnt get their
ih_flags set. ih_flags are used by the intr_handler() code to
determine if the kernel lock should be taken or not.

because the flags werent set, random memory was used instead which
in turn meant you sometimes didnt have the biglock when running
interrupt handlers which relied on it. races ahoy.

this was found by jmatthew@@ while helping me try to figure out why
bnx was blowing up and causing double frees and use after frees.
turns out bnx was the smoke for this fire.

sorry it took so long.

ok kettenis@@ sthen@@
sthen@@ seems happy to have the i386 ports build machine working again.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.30 2013/10/01 20:22:11 sf Exp $	*/
a738 1
	ih->ih_flags = flags;
@


1.29
log
@To prevent lock ordering problems with the kernel lock, we need to make sure
we block all interrupts that can grab the kernel lock.  The simplest way to
achieve this is to make sure mutexes always raise the ipl to the highest
level that has interrupts that grab the kernel lock.  This will allow us
to have "mpsafe" interrupt handlers at lower priority levels.

No change for non-MULTIPROCESSOR kernels.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.28 2013/05/16 19:26:04 kettenis Exp $	*/
d303 1
a303 1
	printf(" pa 0x%lx", aaa->apic_address);
@


1.28
log
@Implement a mechanism to establish interrupt handlers that don't grab the
kernel lock upon entry through a new IPL_MPSAFE flag/level.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.27 2012/07/09 16:09:47 deraadt Exp $	*/
d679 2
@


1.27
log
@Remove apic_intrcount counting in the interrupt handlers.  Not that useful
anymore as a debugging tool, and it is in a rather critical path.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.26 2011/04/16 00:40:58 deraadt Exp $	*/
d675 4
@


1.26
log
@More than a decade ago, interrupt handlers on sparc started returning 0
(interrupt was not for me), 1 (positive interrupt was for me), or -1
(i am not sure...).  We have continued with this practice in as many
drivers as possible, throughout the tree.

This makes some of the architectures use that information in their
interrupt handler calling code -- if 1 is returned (and we know
this specific machine does not have edge-shared interrupts), we
finish servicing other possible handlers on the same pin.  If the
interrupt pin remains asserted (from a different device), we will
end up back in the interrupt servicing code of course... but this is
cheaper than calling all the chained interrupts on a pin.

This does of course count on shared level interrupts being properly
sorted by IPL.

There have been some concerns about starvation of drivers which
incorrectly return 1.  Those drivers should be hunted down so that
they return -1.

ok and help from various people.  In snaps for about a week now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.25 2010/09/20 06:33:47 matthew Exp $	*/
a401 1
int	apic_intrcount[256];
@


1.25
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.24 2010/08/08 16:43:19 deraadt Exp $	*/
d697 2
@


1.24
log
@Restore the APIC ID to what we set it to at boot (some machines come up
with it incorrect)
from mklarkin, ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.23 2010/07/22 00:41:29 deraadt Exp $	*/
d733 1
a733 2
	evcount_attach(&ih->ih_count, ih_what, (void *)&pin->ip_vector,
	    &evcount_intr);
@


1.23
log
@remove unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.22 2009/08/22 02:54:50 mk Exp $	*/
d96 1
d241 2
a242 1
	sizeof(struct ioapic_softc), ioapic_match, ioapic_attach
d366 16
@


1.22
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.21 2009/08/13 13:24:48 kettenis Exp $	*/
a106 2

int apic_verbose = 0;
@


1.21
log
@Make the i386 APIC code closer to the amd64 version.  Many whitespace fixes,
some additional code.

ok toby@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.20 2009/01/09 18:53:16 kettenis Exp $	*/
d650 1
a650 1
    void *ih_arg, char *ih_what)
@


1.20
log
@Make sure we move an interrupt vector to the "lowest" priority level if
necessary.  Fixes a nasty bug with establishing interrupts "late".  Also
make sure we skip the handler being removed when calculating the new "lowest"
and "highest" priority level when disestablishing interrupts.  Remove dmesg
spam when freeing vectors.

tested by many, ok marco@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.19 2008/10/21 21:52:07 brad Exp $	*/
d67 1
d101 2
d119 22
d145 1
a145 1
ioapic_read(struct ioapic_softc *sc, int regid)
d148 1
a148 4

	/*
	 * XXX lock apic
	 */
a152 1

d156 1
a156 1
ioapic_write(struct ioapic_softc *sc, int regid, int val)
a157 3
	/*
	 * XXX lock apic
	 */
d162 22
d238 1
a238 1
	apic_format_redir(sc->sc_dev.dv_xname, why, pin, redirhi, redirlo);
d246 1
a246 1
	NULL, "ioapic", DV_DULL /* XXX DV_CPU ? */
d250 1
a250 1
ioapic_match(struct device *parent, void *matchv, void *aux)
d252 2
a253 2
        struct cfdata *match = (struct cfdata *)matchv;
	struct apic_attach_args * aaa = (struct apic_attach_args *)aux;
d348 1
a348 1
		sc->sc_pins[i].ip_maxlevel = 0;	/* XXX magic */
d356 2
a357 2
		printf("%s: misconfigured as apic %d", sc->sc_dev.dv_xname,
		    apic_id);
d489 1
a489 1
			    "(%x..%x)\n", sc->sc_dev.dv_xname, pin,
d508 1
a508 1
			    sc->sc_dev.dv_xname, pin, maxlevel);
d567 1
a567 1
		    ioapics->sc_dev.dv_xname);
d578 1
a578 1
			printf("%s: enabling\n", sc->sc_dev.dv_xname);
d596 32
a656 1
	static struct intrhand fakehand = {fakeintr};
d659 1
d695 3
d712 11
a722 7
	/*
	 * Actually install a fake handler momentarily, since we might be doing
	 * this with interrupts enabled and don't want the real routine called
	 * until masking is set up.
	 */
	fakehand.ih_level = level;
	*p = &fakehand;
d733 2
a734 15
#if 0
	apic_calculatemasks();
#endif

	/*
	 * Poke the real handler in now.
	 */
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_next = NULL;
	ih->ih_level = level;
	ih->ih_irq = irq;
	evcount_attach(&ih->ih_count, ih_what, (void *)&pin->ip_vector,
	    &evcount_intr);
	*p = ih;
d766 1
d799 1
d816 1
a816 1
	printf("%s: stray interrupt %d\n", sc->sc_dev.dv_xname, irqnum);
@


1.19
log
@more style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.18 2008/10/21 21:31:10 brad Exp $	*/
d445 1
a445 1
	} else if (maxlevel != pp->ip_maxlevel) {
a460 1

d470 1
a470 5
		apic_maxlevel[nvector] = maxlevel;
		/*
		 * XXX want special handler for the maxlevel != minlevel
		 * case here!
		 */
d472 1
a473 2
		pp->ip_minlevel = minlevel;
		pp->ip_maxlevel = maxlevel;
d475 3
a495 1
		printf("freed vector %x\n", ovector);
d725 1
a725 1
	for (; q != NULL; q = q->ih_next) {
@


1.18
log
@style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.17 2008/10/05 16:57:36 kettenis Exp $	*/
d323 1
a323 1
		for (i=0; i<sc->sc_apic_sz; i++)
@


1.17
log
@Remove IOAPIC ID remapping code.  It should not be necessary to avoid reusing
LAPIC IDs and if there are MPBIOSes we handle them with ACPI now.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.16 2008/06/26 05:42:10 ray Exp $	*/
d301 1
a301 1
	for (i=0; i<sc->sc_apic_sz; i++) {
d544 1
a544 1
		for (p=0; p<sc->sc_apic_sz; p++) {
@


1.16
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.15 2007/11/28 19:13:51 kettenis Exp $	*/
a116 14
 * A bitmap telling what APIC IDs usable for I/O APICs are free.
 * The size must be at least IOAPIC_ID_MAX bits (16).
 */
u_int16_t ioapic_id_map = (1 << IOAPIC_ID_MAX) - 1;

/*
 * When we renumber I/O APICs we provide a mapping vector giving us the new
 * ID out of the old BIOS supplied one.  Each item must be able to hold IDs
 * in [0, IOAPIC_ID_MAX << 1), since we use an extra bit to tell if the ID
 * has actually been remapped.
 */
u_int8_t ioapic_id_remap[IOAPIC_ID_MAX];

/*
a246 1
	int8_t new_id;
d249 1
a249 1
	int i, ioapic_found;
d254 10
a263 1
	printf(": apid %d pa 0x%lx", aaa->apic_id, aaa->apic_address);
a293 29

	/*
	 * If either a LAPIC or an I/O APIC is already at the ID the BIOS
	 * setup for this I/O APIC, try to find a free ID to use and reprogram
	 * the chip.  Record this remapping since all references done by the
	 * MP BIOS will be through the old ID.
	 */
	ioapic_found = ioapic_find(sc->sc_apicid) != NULL;
	if (cpu_info[sc->sc_apicid] != NULL || ioapic_found) {
		printf("%s: duplicate apic id", sc->sc_dev.dv_xname);
		new_id = ffs(ioapic_id_map) - 1;
		if (new_id == -1) {
			printf(" (and none free, ignoring)\n");
			return;
		}

		/*
		 * If there were many I/O APICs at the same ID, we choose
		 * to let later references to that ID (in the MP BIOS) refer
		 * to the first found.
		 */
		if (!ioapic_found && !IOAPIC_REMAPPED(sc->sc_apicid))
			IOAPIC_REMAP(sc->sc_apicid, new_id);
		sc->sc_apicid = new_id;
		ioapic_set_id(sc);
	}
	ioapic_id_map &= ~(1 << sc->sc_apicid);

	ioapic_add(sc);
@


1.15
log
@Don't free the old idt vector if we reuse it.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.14 2007/02/22 19:46:16 marco Exp $	*/
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.14
log
@Revert my previous commit.  Kettenis no likey.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.13 2007/02/22 03:47:14 marco Exp $	*/
d480 1
a480 4
	int ovector = 0;
	int nvector = 0;

	ovector = pp->ip_vector;
d525 1
a525 1
	if (ovector) {
@


1.13
log
@Print base so that we can make a correct mapping between apic and irq.

ok jordan
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.12 2007/02/19 20:44:24 kettenis Exp $	*/
d306 1
a306 2
	printf(", version %x, pins %d, base %d\n", sc->sc_apic_vers,
	    sc->sc_apic_sz, sc->sc_apic_vecbase);
@


1.12
log
@Put warning about shared IPL interrupts under MPVERBOSE and don't talk about
degraded performance.

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.11 2006/06/12 04:41:30 gwk Exp $	*/
d306 2
a307 1
	printf(", version %x, %d pins\n", sc->sc_apic_vers, sc->sc_apic_sz);
@


1.11
log
@Add stray interrupt reporting to the apicvec.s, fix the code for stray
interrupt reporting in vector.s. Stray interrupts will only be reported if
a kernel is compiled with option DEBUG, in the case of a non-ioapic kernel
some stray interrupts may be erroneously reported durring the boot process.
ok toby@@, "get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.10 2006/05/11 13:21:11 mickey Exp $	*/
d491 1
d494 3
a496 2
			    "(%x..%x), degraded performance\n",
			    sc->sc_dev.dv_xname, pin, minlevel, maxlevel);
@


1.10
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.9 2006/05/09 18:41:22 kettenis Exp $	*/
d110 2
d784 12
@


1.9
log
@Import global ACPI interrupt code from amd64.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.8 2006/04/08 20:50:38 kettenis Exp $	*/
d131 1
a131 1
 * has actually been remapped.  
d425 2
a426 2
		 * cpu's.  but there's no point in doing that until after 
		 * most interrupts run without the kernel lock.  
d513 1
a513 1
		/* 
@


1.8
log
@Don't panic in apic_intr_establush() if interrupt is not sharable and already
taken; return NULL instead, just like we do for non-apic interrupts.
Fixes PR 5064.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.7 2006/03/06 19:10:06 kettenis Exp $	*/
d117 1
d185 18
d287 11
@


1.7
log
@Synch bits of the i386 and amd64 ioapic code.
Make ioapic redirect register writes atomic on amd64 just like on i386.
ok niklas@@, grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.6 2005/11/10 14:35:13 mickey Exp $	*/
d628 7
a634 7
		if (type != IST_NONE)
			/* XXX should not panic here! */
			panic("apic_intr_establish: "
			      "intr %d can't share %s with %s",
			      intr,
			      isa_intr_typename(sc->sc_pins[intr].ip_type),
			      isa_intr_typename(type));
@


1.6
log
@do not use the array index before a range check is done
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.5 2004/08/12 06:11:57 niklas Exp $	*/
d235 1
a235 1
		printf(", remapped to apic %d\n", sc->sc_apicid);
d375 1
a375 5
	if (map == NULL) {
		redlo = IOAPIC_REDLO_MASK;
	} else {
		redlo = map->redir;
	}
@


1.5
log
@Fix the shared irq problem, by allocating a low priority vector
so that the "high" pri interrupt gets blocked by the "low" spl & irq handler,
and raise the cpl to the "high" level in the handler, so that no other
in fact lower-leveled, interrupts can preempt the handling of the "high"
interrupt.  This means that the "low" interrupt gets the same quality treatment,
thus causing some degradation in performance.  Therefore we still issue a
diagnostic, so people can try to avoid the situation by tweaking their BIOS
settings. Note, there is still issues with dynamically established interrupts
which cause irq sharing, we are working on that.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.5 2004/08/12 06:08:50 niklas Exp $	*/
a613 1
	pin = &sc->sc_pins[intr];
d622 1
a622 1

@


1.4
log
@Use new event counter API for interrupt counting on i386.  deraadt@@ tholo@@
drahn@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.3 2004/06/23 17:14:31 niklas Exp $	*/
d357 1
d463 4
a466 8
		if (minlevel != maxlevel) {
			printf("%s: WARNING: sharing interrupt "
			    "between different IPLs (currently broken)\n",
			    sc->sc_dev.dv_xname);
			printf("%s: pin %d, ipls %x..%x\n",
			    sc->sc_dev.dv_xname,
			    pin, minlevel, maxlevel);
		}
d475 1
a475 1
		nvector = idt_vec_alloc(maxlevel, maxlevel+15);
d486 1
@


1.3
log
@Renumber I/O APICs who clash with other APICs. Also clear the delivery
mode before setting it to fixed, since the MP BIOS may have left something
in that field. This fixed a Quad Xeon we have been loaned over the c2k4.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.2 2004/06/13 21:49:15 niklas Exp $	*/
d599 1
a599 1
    void *ih_arg, char *what)
a684 1
	ih->ih_count = 0;
d688 2
a689 1
	ih->ih_what = what;
d757 1
@


1.2
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d118 16
d220 17
d247 1
d250 1
a250 1
	int i;
d255 1
a255 10
	printf(" apid %d", aaa->apic_id);

	if (ioapic_find(aaa->apic_id) != NULL) {
		printf(": duplicate apic id (ignored)\n");
		return;
	}

	ioapic_add(sc);

	printf(": pa 0x%lx", aaa->apic_address);
a263 2
	apic_id = (ioapic_read(sc,IOAPIC_ID) & IOAPIC_ID_MASK) >>
	    IOAPIC_ID_SHIFT;
a264 1

d276 32
a323 2
	 * Maybe we should record the original ID for interrupt
	 * mapping later ...
d328 1
a328 12

		ioapic_write(sc, IOAPIC_ID,
		    (ioapic_read(sc, IOAPIC_ID) & ~IOAPIC_ID_MASK)
		    | (sc->sc_apicid << IOAPIC_ID_SHIFT));

		apic_id = (ioapic_read(sc,IOAPIC_ID) & IOAPIC_ID_MASK) >>
		    IOAPIC_ID_SHIFT;

		if (apic_id != sc->sc_apicid)
			printf(", can't remap to apid %d\n", sc->sc_apicid);
		else
			printf(", remapped to apic %d\n", sc->sc_apicid);
d388 1
@


1.1
log
@file ioapic.c was initially added on branch SMP.
@
text
@d1 736
@


1.1.2.1
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@a0 664
/* $NetBSD: ioapic.c,v 1.1.2.4 2000/06/25 20:46:08 sommerfeld Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * Copyright (c) 1999 Stefan Grefen
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the NetBSD 
 *      Foundation, Inc. and its contributors.  
 * 4. Neither the name of The NetBSD Foundation nor the names of its 
 *    contributors may be used to endorse or promote products derived  
 *    from this software without specific prior written permission.   
 *
 * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <vm/vm.h>
#include <vm/vm_kern.h>
#include <vm/vm_page.h>

#include <machine/bus.h>

/* #include <machine/isa_machdep.h> * XXX intrhand */
#include <../../isa/isa_machdep.h> /* XXX Move this file! */
 
#include <uvm/uvm_extern.h>
#include <machine/i82093reg.h>
#include <machine/i82093var.h>

#include <machine/i82489reg.h>
#include <machine/i82489var.h>

#include <machine/pmap.h>

#include <machine/mpbiosvar.h>

/*
 * maps an IO-apic
 * TODO locking, export of interrupt functions
 * and mapping of interrupts.
 */

int     ioapic_match __P((struct device *, void *, void *));
void    ioapic_attach __P((struct device *, struct device *, void *));

int     bus_mem_add_mapping __P((bus_addr_t, bus_size_t,
            int, bus_space_handle_t *)); /* XXX */

void	apic_vectorset __P((struct ioapic_softc *, int, int));

int apic_verbose = 0;

int ioapic_bsp_id = 0;
int ioapic_cold = 1;

static __inline  u_int32_t
ioapic_read(struct ioapic_softc *sc,int regid)
{
	u_int32_t val;
	
	/*
	 * TODO: lock apic  
	 */
	*(sc->sc_reg) = regid;
	val = *sc->sc_data;

	return val;
	
}

static __inline  void
ioapic_write(struct ioapic_softc *sc,int regid, int val)
{
	/*
	 * todo lock apic  
	 */

	*(sc->sc_reg) = regid;
	*(sc->sc_data) = val;
}

struct cfattach ioapic_ca = {
	sizeof(struct ioapic_softc), ioapic_match, ioapic_attach
};

struct cfdriver ioapic_cd = {
	NULL, "ioapic", DV_DULL /* XXX DV_CPU ? */
};

/*
 * table of ioapics indexed by apic id.
 */

struct ioapic_softc *ioapics[16] = { 0 };

int
ioapic_match(parent, matchv, aux)
	struct device *parent;  
	void *matchv;   
	void *aux;
{
        struct cfdata *match = (struct cfdata *)matchv;
	struct apic_attach_args * aaa = (struct apic_attach_args *) aux;

	if (strcmp(aaa->aaa_name, match->cf_driver->cd_name) == 0)
		return 1;
	return 0;
}

void ioapic_print_redir (struct ioapic_softc *sc, char *why, int pin)
{
	u_int32_t redirlo = ioapic_read(sc, IOAPIC_REDLO(pin));
	u_int32_t redirhi = ioapic_read(sc, IOAPIC_REDHI(pin));

	apic_format_redir(sc->sc_dev.dv_xname, why, pin, redirhi, redirlo);
}


/*
 * can't use bus_space_xxx as we don't have a bus handle ...
 */
void 
ioapic_attach(parent, self, aux)   
	struct device *parent, *self;
	void *aux;
{
	struct ioapic_softc *sc = (struct ioapic_softc *)self;  
	struct apic_attach_args  *aaa = (struct apic_attach_args  *) aux;
	int apic_id;
	bus_space_handle_t bh;
	u_int32_t ver_sz;
	int i;
	
	sc->sc_flags = aaa->flags;
	sc->sc_apicid = aaa->apic_id;

	printf(" apid %d (I/O APIC)\n", aaa->apic_id);

	if (ioapics[aaa->apic_id] != NULL) {
		printf("%s: duplicate apic id (ignored)\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	ioapics[aaa->apic_id] = sc;
	
	printf("%s: pa 0x%lx", sc->sc_dev.dv_xname, aaa->apic_address);

	if (bus_mem_add_mapping(aaa->apic_address, NBPG, 0, &bh) != 0) {
		printf(": map failed\n");
		return;
	}
	sc->sc_reg = (volatile u_int32_t *)(bh + IOAPIC_REG);
	sc->sc_data = (volatile u_int32_t *)(bh + IOAPIC_DATA);	

	apic_id = (ioapic_read(sc,IOAPIC_ID)&IOAPIC_ID_MASK)>>IOAPIC_ID_SHIFT;
	ver_sz = ioapic_read(sc, IOAPIC_VER);
	
	sc->sc_apic_vers = (ver_sz & IOAPIC_VER_MASK) >> IOAPIC_VER_SHIFT;
	sc->sc_apic_sz = (ver_sz & IOAPIC_MAX_MASK) >> IOAPIC_MAX_SHIFT;
	sc->sc_apic_sz++;

	if (mp_verbose) {
		printf(", %s mode",
		    aaa->flags & IOAPIC_PICMODE ? "PIC" : "virtual wire");
	}
	
	printf(", version %x, %d pins\n", sc->sc_apic_vers, sc->sc_apic_sz);

	sc->sc_pins = malloc(sizeof(struct ioapic_pin) * sc->sc_apic_sz,
	    M_DEVBUF, M_WAITOK);

	for (i=0; i<sc->sc_apic_sz; i++) {
		sc->sc_pins[i].ip_handler = NULL;
		sc->sc_pins[i].ip_next = NULL;
		sc->sc_pins[i].ip_map = NULL;
		sc->sc_pins[i].ip_vector = 0;
		sc->sc_pins[i].ip_type = 0;
		sc->sc_pins[i].ip_level = 0;
	}
	
	/*
	 * In case the APIC is not initialized to the correct ID
	 * do it now.
	 * Maybe we should record the original ID for interrupt
	 * mapping later ...
	 */
	if (apic_id != sc->sc_apicid) {
		printf("%s: misconfigured as apic %d\n", sc->sc_dev.dv_xname, apic_id);

		ioapic_write(sc,IOAPIC_VER,
		    (ioapic_read(sc,IOAPIC_ID)&~IOAPIC_ID_MASK)
		    |(sc->sc_apicid<<IOAPIC_ID_SHIFT));
		
		apic_id = (ioapic_read(sc,IOAPIC_ID)&IOAPIC_ID_MASK)>>IOAPIC_ID_SHIFT;
		
		if (apic_id != sc->sc_apicid) {
			printf("%s: can't remap to apid %d\n",
			    sc->sc_dev.dv_xname,
			    sc->sc_apicid);
		} else {
			printf("%s: remapped to apic %d\n",
			    sc->sc_dev.dv_xname,
			    sc->sc_apicid);
		}
	}
#if 0
	/* output of this was boring. */
	if (mp_verbose)
		for (i=0; i<sc->sc_apic_sz; i++)
			ioapic_print_redir(sc, "boot", i);
#endif
}

/*
 * Interrupt mapping.
 *
 * Multiple handlers may exist for each pin, so there's an
 * intrhand chain for each pin.
 *
 * Ideally, each pin maps to a single vector at the priority of the
 * highest level interrupt for that pin.
 *
 * XXX in the event that there are more than 16 interrupt sources at a
 * single level, some doubling-up may be needed.  This is not yet
 * implemented.
 *
 * XXX we are wasting some space here because we only use a limited
 * range of the vectors here.  (0x30..0xef)
 */

struct intrhand *apic_intrhand[256];
int	apic_intrcount[256];

#if 0
int apic_intrtype[APIC_ICU_LEN];
int apic_intrlevel[NIPL];
int apic_imask[NIPL];
#endif

/* XXX should check vs. softc max int number */
#define	LEGAL_IRQ(x)	((x) >= 0 && (x) < APIC_ICU_LEN && (x) != 2)

static void
apic_set_redir (struct ioapic_softc *sc, int irq)
{
	u_int32_t redlo;
	u_int32_t redhi = 0;
	int delmode;

	struct ioapic_pin *pin;
	struct mp_intr_map *map;
	
	pin = &sc->sc_pins[irq];
	map = pin->ip_map;
	if (map == NULL) {
		redlo = IOAPIC_REDLO_MASK;
	} else {
		redlo = map->redir;
	}
	delmode = (redlo & IOAPIC_REDLO_DEL_MASK) >> IOAPIC_REDLO_DEL_SHIFT;
	
	/* XXX magic numbers */
	if ((delmode != 0) && (delmode != 1))
		;
	else if (pin->ip_handler == NULL) {
		redlo |= IOAPIC_REDLO_MASK;
	} else {
		redlo |= (pin->ip_vector & 0xff);
		redlo |= (IOAPIC_REDLO_DEL_FIXED<<IOAPIC_REDLO_DEL_SHIFT);
		redlo &= ~IOAPIC_REDLO_DSTMOD;
		
		/* destination: BSP CPU */

		/*
		 * XXX will want to eventually switch to
		 * lowest-priority delivery mode, possibly with focus
		 * processor.
		 */
		redhi |= (ioapic_bsp_id << IOAPIC_REDHI_DEST_SHIFT);

		/* XXX derive this bit from BIOS info */
		if (pin->ip_type == IST_LEVEL)
			redlo |= IOAPIC_REDLO_LEVEL;
		else
			redlo &= ~IOAPIC_REDLO_LEVEL;
		/* XXX polarity goo, too */
	}
	ioapic_write(sc,IOAPIC_REDLO(irq), redlo);
	ioapic_write(sc,IOAPIC_REDHI(irq), redhi);
	if (mp_verbose)
		ioapic_print_redir(sc, "int", irq);
}

static int fakeintr __P((void *)); 	/* XXX headerify */
extern char *isa_intr_typename (int); 	/* XXX headerify */

static int fakeintr(arg)
	void *arg;
{
	return 0;
}


/*
 * apic_vectorset: allocate a vector for the given pin, based on
 * the levels of the interrupts on that pin.
 *
 * XXX if the level of the pin changes while the pin is
 * masked, need to do something special to prevent pending
 * interrupts from being lost.
 * (the answer may be to hang the interrupt chain off of both vectors
 * until any interrupts from the old source have been handled.  the trouble
 * is that we don't have a global view of what interrupts are pending.
 *
 * Deferring for now since MP systems are more likely servers rather
 * than laptops or desktops, and thus will have relatively static
 * interrupt configuration.
 */

void
apic_vectorset (sc, irq, level)
	struct ioapic_softc *sc;
	int irq;
	int level;
{
	struct ioapic_pin *pin = &sc->sc_pins[irq];
	int ovector = 0;
	int nvector = 0;
	
	ovector = pin->ip_vector;

	if (level == 0) {
		/* no vector needed. */
		pin->ip_level = 0;
		pin->ip_vector = 0;
	} else if (level != pin->ip_level) {
		nvector = idt_vec_alloc (level, level+15);

		if (nvector == NULL) {
			/*
			 * XXX XXX we should be able to deal here..
			 * need to double-up an existing vector
			 * and install a slightly different handler.
			 */
			panic("apic_vectorset: no free vectors");
		}
		idt_vec_set(nvector, apichandler[nvector & 0xf]);
		pin->ip_vector = nvector;
		pin->ip_level = level;
	}
	apic_intrhand[pin->ip_vector] = pin->ip_handler;

	if (ovector) {
		/*
		 * XXX should defer this until we're sure the old vector
		 * doesn't have a pending interrupt on any processor.
		 * do this by setting a counter equal to the number of CPU's,
		 * and firing off a low-priority broadcast IPI to all cpu's.
		 * each cpu then decrements the counter; when it
		 * goes to zero, free the vector..
		 * i.e., defer until all processors have run with a CPL
		 * less than the level of the interrupt..
		 *
		 * this is only an issue for dynamic interrupt configuration
		 * (e.g., cardbus or pcmcia).
		 */
		apic_intrhand[ovector] = NULL;
		idt_vec_free (ovector);
		printf("freed vector %x\n", ovector);
	}
	
	apic_set_redir (sc, irq);
}

/*
 * Throw the switch and enable interrupts..
 */

void
ioapic_enable ()
{
	int a, p, maxlevel;
	struct intrhand *q;
	extern void intr_calculatemasks __P((void)); /* XXX */
	int did_imcr = 0;

	intr_calculatemasks();	/* for softints, AST's */

	ioapic_cold = 0;

	lapic_set_lvt();
	
	for (a=0; a<16; a++) {
		struct ioapic_softc *sc = ioapics[a];
		if (sc != NULL) {
			printf("%s: enabling\n", sc->sc_dev.dv_xname);

			if (!did_imcr &&
			    (sc->sc_flags & IOAPIC_PICMODE)) {
				/*
				 * XXX not tested yet..
				 */
				printf("%s: writing to IMCR to disable pics\n",
				    sc->sc_dev.dv_xname);
				outb (IMCR_ADDR, IMCR_REGISTER);
				outb (IMCR_DATA, IMCR_APIC);
				printf("%s: here's hoping it works\n",
				    sc->sc_dev.dv_xname);
				did_imcr = 1;
			}
			
			for (p=0; p<sc->sc_apic_sz; p++) {
				maxlevel = 0;
				
				for (q = sc->sc_pins[p].ip_handler;
				     q != NULL;
				     q = q->ih_next) {
					if (q->ih_level > maxlevel)
						maxlevel = q->ih_level;
				}
				apic_vectorset (sc, p, maxlevel);
			}
		}
	}
}




/*
 * Interrupt handler management with the apic is radically different from the
 * good old 8259.
 *
 * The APIC adds an additional level of indirection between interrupt
 * signals and interrupt vectors in the IDT.
 * It also encodes a priority into the high-order 4 bits of the IDT vector
 * number. 
 *
 *
 * interrupt establishment:
 *	-> locate interrupt pin.
 *	-> locate or allocate vector for pin.
 *	-> locate or allocate handler chain for vector.
 *	-> chain interrupt into handler chain.
 * 	#ifdef notyet
 *	-> if level of handler chain increases, reallocate vector, move chain.
 *	#endif
 */

void *
apic_intr_establish(irq, type, level, ih_fun, ih_arg)
	int irq;
	int type;
	int level;
	int (*ih_fun) __P((void *));
	void *ih_arg;
{
	unsigned int ioapic = APIC_IRQ_APIC(irq);
	unsigned int intr = APIC_IRQ_PIN(irq);
	struct ioapic_softc *sc = ioapics[ioapic];
	struct ioapic_pin *pin;
	struct intrhand **p, *q, *ih;
	static struct intrhand fakehand = {fakeintr};
	extern int cold;
	int maxlevel;

	if (sc == NULL)
		panic("unknown ioapic id %d", ioapic);

	if ((irq & APIC_INT_VIA_APIC) == NULL)
		panic("apic_intr_establish of non-apic interrupt 0x%x", irq);
	
	pin = &sc->sc_pins[intr];
	if (intr >= sc->sc_apic_sz || type == IST_NONE)
		panic("apic_intr_establish: bogus intr or type");
	
	/* no point in sleeping unless someone can free memory. */
	ih = malloc(sizeof *ih, M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL)
		panic("apic_intr_establish: can't malloc handler info");


	switch (pin->ip_type) {
	case IST_NONE:
		pin->ip_type = type;
		break;
	case IST_EDGE:
	case IST_LEVEL:
		if (type == pin->ip_type)
			break;
	case IST_PULSE:
		if (type != IST_NONE)
			/* XXX should not panic here! */
			panic("apic_intr_establish: intr %d can't share %s with %s",
			      intr,
			      isa_intr_typename(sc->sc_pins[intr].ip_type),
			      isa_intr_typename(type));
		break;
	}

	/*
	 * Figure out where to put the handler.
	 * This is O(N^2) to establish N interrupts, but we want to
	 * preserve the order, and N is generally small.
	 */
	maxlevel = level;
	for (p = &pin->ip_handler; (q = *p) != NULL; p = &q->ih_next) {
		if (q->ih_level > maxlevel)
			maxlevel = q->ih_level;
	}

	/*
	 * Actually install a fake handler momentarily, since we might be doing
	 * this with interrupts enabled and don't want the real routine called
	 * until masking is set up.
	 */
	fakehand.ih_level = level;
	*p = &fakehand;

	/*
	 * fix up the vector for this pin.
	 * XXX perhaps defer this until most interrupts have been established?
	 * (to avoid too much thrashing of the idt..)
	 */

	if (!ioapic_cold)
		apic_vectorset(sc, intr, maxlevel);

#if 0
	apic_calculatemasks();
#endif

	/*
	 * Poke the real handler in now.
	 */
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_count = 0;
	ih->ih_next = NULL;
	ih->ih_level = level;
	ih->ih_irq = irq;
	*p = ih;

	return (ih);
}

/*
 * apic disestablish:
 *	locate handler chain.
 * 	dechain intrhand from handler chain
 *	if chain empty {
 *		reprogram apic for "safe" vector.
 *		free vector (point at stray handler).
 *	} 
 *	#ifdef notyet
 *	else {
 *		recompute level for current chain.
 *		if changed, reallocate vector, move chain.
 *	}
 *	#endif
 */

void
apic_intr_disestablish(arg)
	void *arg;
{
	struct intrhand *ih = arg;
	int irq = ih->ih_irq;
	unsigned int ioapic = APIC_IRQ_APIC(irq);
	unsigned int intr = APIC_IRQ_PIN(irq);
	struct ioapic_softc *sc = ioapics[ioapic];
	struct ioapic_pin *pin = &sc->sc_pins[intr];
	struct intrhand **p, *q;
	int maxlevel;
	
	if (intr >= sc->sc_apic_sz)
		panic("apic_intr_establish: bogus irq");

	/*
	 * Remove the handler from the chain.
	 * This is O(n^2), too.
	 */
	maxlevel = 0;
	for (p = &pin->ip_handler; (q = *p) != NULL && q != ih;
	     p = &q->ih_next)
		if (q->ih_level > maxlevel)
			maxlevel = q->ih_level;
		
	if (q)
		*p = q->ih_next;
	else
		panic("intr_disestablish: handler not registered");
	for (; q != NULL; q = q->ih_next)
		if (q->ih_level > maxlevel)
			maxlevel = q->ih_level;
	
	if (!ioapic_cold)
		apic_vectorset(sc, intr, maxlevel);

	free(ih, M_DEVBUF);
}

@


1.1.2.2
log
@Add $OpenBSD$.
@
text
@a0 1
/*	$OpenBSD$	*/
@


1.1.2.3
log
@KNF
remove statics
remove fakeintr since it is in isa_machdep.c too
Adjust IDT vector allocation to match OpenBSD
Remove ICU vectors when enabling APIC
Add name to APIC interupt establishments a la OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.1.2.2 2001/07/15 15:10:54 ho Exp $	*/
d56 5
a60 5
 *      This product includes software developed by the NetBSD
 *      Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
a83 1
#include <machine/psl.h>
d85 3
a98 2
#include "isa.h"

d105 2
a106 2
int     ioapic_match(struct device *, void *, void *);
void    ioapic_attach(struct device *, struct device *, void *);
d108 2
a109 2
/* XXX */
int     bus_mem_add_mapping(bus_addr_t, bus_size_t, int, bus_space_handle_t *);
d111 1
a111 2
void	apic_set_redir(struct ioapic_softc *, int);
void	apic_vectorset(struct ioapic_softc *, int, int);
d118 2
a119 2
static __inline u_int32_t
ioapic_read(struct ioapic_softc *sc, int regid)
d122 1
a122 1

d124 1
a124 1
	 * TODO: lock apic
d130 1
a130 1

d133 2
a134 2
static __inline void
ioapic_write(struct ioapic_softc *sc, int regid, int val)
d137 1
a137 1
	 * todo lock apic
d159 4
a162 1
ioapic_match(struct device *parent, void *matchv, void *aux)
d165 1
a165 1
	struct apic_attach_args * aaa = (struct apic_attach_args *)aux;
d168 2
a169 2
		return (1);
	return (0);
d172 1
a172 2
void
ioapic_print_redir(struct ioapic_softc *sc, char *why, int pin)
d184 4
a187 2
void
ioapic_attach(struct device *parent, struct device *self, void *aux)
d189 2
a190 2
	struct ioapic_softc *sc = (struct ioapic_softc *)self;
	struct apic_attach_args  *aaa = (struct apic_attach_args *)aux;
d195 1
a195 1

d208 1
a208 1

d216 1
a216 1
	sc->sc_data = (volatile u_int32_t *)(bh + IOAPIC_DATA);
d218 1
a218 2
	apic_id = (ioapic_read(sc,IOAPIC_ID) & IOAPIC_ID_MASK) >>
	    IOAPIC_ID_SHIFT;
d220 1
a220 1

d229 1
a229 1

d243 1
a243 1

d251 1
a251 9
		printf("%s: misconfigured as apic %d\n", sc->sc_dev.dv_xname,
		    apic_id);

		ioapic_write(sc, IOAPIC_VER,
		    (ioapic_read(sc, IOAPIC_ID) & ~IOAPIC_ID_MASK)
		    | (sc->sc_apicid << IOAPIC_ID_SHIFT));

		apic_id = (ioapic_read(sc,IOAPIC_ID) & IOAPIC_ID_MASK) >>
		    IOAPIC_ID_SHIFT;
d253 6
d261 2
a262 1
			    sc->sc_dev.dv_xname, sc->sc_apicid);
d265 2
a266 1
			    sc->sc_dev.dv_xname, sc->sc_apicid);
d306 2
a307 2
void
apic_set_redir(struct ioapic_softc *sc, int irq)
d315 1
a315 1

d324 1
a324 1

d332 1
a332 1
		redlo |= (IOAPIC_REDLO_DEL_FIXED << IOAPIC_REDLO_DEL_SHIFT);
d334 1
a334 1

d357 9
a365 7
/*
 * XXX To be really correct an NISA > 0 condition should check for these.
 * However, the i386 port pretty much assumes isa is there anyway.
 * For example, pci_intr_establish calls isa_intr_establish unconditionally.
 */
extern int fakeintr(void *); 	/* XXX headerify */
extern char *isa_intr_typename(int); 	/* XXX headerify */
d384 4
a387 1
apic_vectorset(struct ioapic_softc *sc, int irq, int level)
d392 1
a392 1

d400 1
a400 2
		nvector = idt_vec_alloc(NRSVIDT + level * 16,
		    NRSVIDT + level * 16 + 15);
d402 1
a402 1
		if (nvector == 0) {
d431 1
a431 1
		idt_vec_free(ovector);
d434 2
a435 2

	apic_set_redir(sc, irq);
d443 1
a443 1
ioapic_enable(void)
d447 1
a447 1
	extern void intr_calculatemasks(void); /* XXX */
a453 4
#if NISA > 0
	isa_nodefaultirq();
#endif

d455 2
a456 2

	for (a = 0; a < 16; a++) {
d468 2
a469 2
				outb(IMCR_ADDR, IMCR_REGISTER);
				outb(IMCR_DATA, IMCR_APIC);
d474 2
a475 2

			for (p = 0; p < sc->sc_apic_sz; p++) {
d477 1
a477 1

d484 1
a484 1
				apic_vectorset(sc, p, maxlevel);
d490 3
d500 1
a500 1
 * number.
d514 6
a519 2
apic_intr_establish(int irq, int type, int level, int (*ih_fun)(void *),
    void *ih_arg, char *what)
d533 1
a533 1
	if ((irq & APIC_INT_VIA_APIC) == 0)
d535 1
a535 1

d539 1
a539 1

d557 1
a557 2
			panic("apic_intr_establish: "
			      "intr %d can't share %s with %s",
a604 1
	ih->ih_what = what;
d617 1
a617 1
 *	}
d627 2
a628 1
apic_intr_disestablish(void *arg)
d638 1
a638 1

d651 1
a651 1

d659 1
a659 1

d665 1
@


1.1.2.4
log
@New interrupt and spl* system, mostly from NetBSD's i386 MP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.1.2.3 2001/07/16 21:39:28 niklas Exp $	*/
d393 2
a394 1
		nvector = idt_vec_alloc(level, level + 15);
@


1.1.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 1
@


1.1.2.6
log
@Merge in -current
@
text
@d79 3
a449 1
	lapic_set_softvectors();
@


1.1.2.7
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d443 4
a452 7
#if NISA > 0
			static int found_one = 0;

			if (!found_one++)
				isa_nodefaultirq();
#endif

@


1.1.2.8
log
@typo, in apic id misconfiguration case, fixes bochs
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.1.2.7 2003/05/13 19:42:07 ho Exp $	*/
d248 1
a248 1
		ioapic_write(sc, IOAPIC_ID,
@


1.1.2.9
log
@Some merged code from NetBSD, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: ioapic.c,v 1.1.2.8 2003/05/15 16:44:33 niklas Exp $	*/
/* 	$NetBSD: ioapic.c,v 1.7 2003/07/14 22:32:40 lukem Exp $	*/
a82 1

d96 3
a98 1
 * XXX locking
d105 1
a105 2
extern int bus_mem_add_mapping(bus_addr_t, bus_size_t, int,
    bus_space_handle_t *);
d108 1
a108 1
void	apic_vectorset(struct ioapic_softc *, int, int, int);
a114 6
struct ioapic_softc *ioapics;	 /* head of linked list */
int nioapics = 0;	   	 /* number attached */

/*
 * Register read/write routines.
 */
d121 1
a121 1
	 * XXX lock apic
d126 1
a126 1
	return (val);
d134 1
a134 1
	 * XXX lock apic
d136 1
a140 39
struct ioapic_softc *
ioapic_find(int apicid)
{
	struct ioapic_softc *sc;

	if (apicid == MPS_ALL_APICS) {	/* XXX mpbios-specific */
		/*
		 * XXX kludge for all-ioapics interrupt support
		 * on single ioapic systems
		 */
		if (nioapics <= 1)
			return (ioapics);
		panic("unsupported: all-ioapics interrupt with >1 ioapic");
	}

	for (sc = ioapics; sc != NULL; sc = sc->sc_next)
		if (sc->sc_apicid == apicid)
			return (sc);

	return (NULL);
}

static __inline void
ioapic_add(struct ioapic_softc *sc)
{
	sc->sc_next = ioapics;
	ioapics = sc;
	nioapics++;
}

void
ioapic_print_redir(struct ioapic_softc *sc, char *why, int pin)
{
	u_int32_t redirlo = ioapic_read(sc, IOAPIC_REDLO(pin));
	u_int32_t redirhi = ioapic_read(sc, IOAPIC_REDHI(pin));

	apic_format_redir(sc->sc_dev.dv_xname, why, pin, redirhi, redirlo);
}

d149 6
d166 9
d194 1
a194 1
	if (ioapic_find(aaa->apic_id) != NULL) {
d200 1
a200 1
	ioapic_add(sc);
d204 1
a204 1
	if (bus_mem_add_mapping(aaa->apic_address, PAGE_SIZE, 0, &bh) != 0) {
d235 1
a235 2
		sc->sc_pins[i].ip_minlevel = 0xff; /* XXX magic*/
		sc->sc_pins[i].ip_maxlevel = 0;	/* XXX magic */
d291 5
d301 1
a301 1
apic_set_redir(struct ioapic_softc *sc, int pin)
d307 1
a307 1
	struct ioapic_pin *pp;
d310 2
a311 2
	pp = &sc->sc_pins[pin];
	map = pp->ip_map;
d322 1
a322 1
	else if (pp->ip_handler == NULL) {
d325 1
a325 1
		redlo |= (pp->ip_vector & 0xff);
d329 2
d332 3
a334 7
		 * Destination: BSP CPU
		 *
		 * XXX will want to distribute interrupts across cpu's
		 * eventually.  most likely, we'll want to vector each
		 * interrupt to a specific CPU and load-balance across
		 * cpu's.  but there's no point in doing that until after 
		 * most interrupts run without the kernel lock.  
d339 1
a339 1
		if (pp->ip_type == IST_LEVEL)
d343 1
a343 6
		if (map != NULL && ((map->flags & 3) == MPS_INTPO_DEF)) {
			if (pp->ip_type == IST_LEVEL)
				redlo |= IOAPIC_REDLO_ACTLO;
			else
				redlo &= ~IOAPIC_REDLO_ACTLO;
		}
d345 2
a346 2
	ioapic_write(sc, IOAPIC_REDLO(pin), redlo);
	ioapic_write(sc, IOAPIC_REDHI(pin), redhi);
d348 1
a348 1
		ioapic_print_redir(sc, "int", pin);
d376 1
a376 1
apic_vectorset(struct ioapic_softc *sc, int pin, int minlevel, int maxlevel)
d378 1
a378 1
	struct ioapic_pin *pp = &sc->sc_pins[pin];
d382 3
a384 3
	ovector = pp->ip_vector;
	
	if (maxlevel == 0) {
d386 4
a389 21
		pp->ip_minlevel = 0xff; /* XXX magic */
		pp->ip_maxlevel = 0; /* XXX magic */
		pp->ip_vector = 0;
	} else if (maxlevel != pp->ip_maxlevel) {
		if (minlevel != maxlevel) {
			printf("%s: WARNING: sharing interrupt "
			    "between different IPLs (currently broken)\n",
			    sc->sc_dev.dv_xname);
			printf("%s: pin %d, ipls %x..%x\n",
			    sc->sc_dev.dv_xname,
			    pin, minlevel, maxlevel);
		}

		/*
		 * Allocate interrupt vector at the *lowest* priority level
		 * of any of the handlers invoked by this pin.
		 *
		 * The interrupt handler will raise ipl higher than this
		 * as appropriate.
		 */
		nvector = idt_vec_alloc(maxlevel, maxlevel+15);
d397 1
a397 2
			panic("%s: can't alloc vector for pin %d at level %x",
			    sc->sc_dev.dv_xname, pin, maxlevel);
a398 4
		/* 
		 * XXX want special handler for the maxlevel != minlevel
		 * case here!
		 */
d400 2
a401 2
		pp->ip_vector = nvector;		pp->ip_minlevel = minlevel;
		pp->ip_maxlevel = maxlevel;
d403 1
a403 1
	apic_intrhand[pp->ip_vector] = pp->ip_handler;
d424 1
a424 1
	apic_set_redir(sc, pin);
d434 1
a434 2
	int p, maxlevel, minlevel;
	struct ioapic_softc *sc;
d437 1
a442 1
#if 1 /* XXX Will probably get removed */
d445 9
d456 15
a470 2
	if (ioapics == NULL)
		return;
d472 2
a473 6
	if (ioapics->sc_flags & IOAPIC_PICMODE) {
		printf("%s: writing to IMCR to disable pics\n",
		    ioapics->sc_dev.dv_xname);
		outb(IMCR_ADDR, IMCR_REGISTER);
		outb(IMCR_DATA, IMCR_APIC);
	}
d475 7
a481 17
#if 1 /* XXX Will be removed when we have intrsource. */
	isa_nodefaultirq();
#endif
			
	for (sc = ioapics; sc != NULL; sc = sc->sc_next) {
		printf("%s: enabling\n", sc->sc_dev.dv_xname);

		for (p=0; p<sc->sc_apic_sz; p++) {
			maxlevel = 0;	 /* magic */
			minlevel = 0xff; /* magic */
				
			for (q = sc->sc_pins[p].ip_handler; q != NULL;
			     q = q->ih_next) {
				if (q->ih_level > maxlevel)
					maxlevel = q->ih_level;
				if (q->ih_level < minlevel)
					minlevel = q->ih_level;
a482 1
			apic_vectorset(sc, p, minlevel, maxlevel);
d513 1
a513 1
	struct ioapic_softc *sc = ioapic_find(ioapic);
d518 1
a518 1
	int minlevel, maxlevel;
d521 1
a521 1
		panic("apic_intr_establish: unknown ioapic %d", ioapic);
a560 1
	minlevel = level;
a563 2
		if (q->ih_level < minlevel)
			minlevel = q->ih_level;
d575 3
a577 3
	 * Fix up the vector for this pin.
	 * (if cold, defer this until most interrupts have been established,
	 * to avoid too much thrashing of the idt..)
d581 1
a581 1
		apic_vectorset(sc, intr, minlevel, maxlevel);
d625 1
a625 1
	struct ioapic_softc *sc = ioapic_find(ioapic);
d628 1
a628 4
	int minlevel, maxlevel;

	if (sc == NULL)
		panic("apic_intr_disestablish: unknown ioapic %d", ioapic);
d631 1
a631 1
		panic("apic_intr_disestablish: bogus irq");
a637 1
	minlevel = 0xff;
d639 1
a639 1
	     p = &q->ih_next) {
a641 3
		if (q->ih_level < minlevel)
			minlevel = q->ih_level;
	}
d647 1
a647 1
	for (; q != NULL; q = q->ih_next) {
a649 3
		if (q->ih_level < minlevel)
			minlevel = q->ih_level;
	}
d652 1
a652 1
		apic_vectorset(sc, intr, minlevel, maxlevel);
a655 20

#ifdef DDB
void ioapic_dump(void);

void
ioapic_dump(void)
{
	struct ioapic_softc *sc;
	struct ioapic_pin *ip;
	int p;

	for (sc = ioapics; sc != NULL; sc = sc->sc_next) {
		for (p = 0; p < sc->sc_apic_sz; p++) {
			ip = &sc->sc_pins[p];
			if (ip->ip_type != IST_NONE)
				ioapic_print_redir(sc, "dump", p);
		}
	}
}
#endif
@


1.1.2.10
log
@Accept legacy PIC interrupts even after enabling IOAPICs
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.1.2.9 2004/03/14 22:08:20 niklas Exp $	*/
d512 1
a512 1
#if 0 /* XXX Will be removed when we have intrsource. */
@


1.1.2.11
log
@Do not call lapic_set_softvectors, or lapic_set_lvt, if no ioapics are present
in the system. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.1.2.10 2004/03/30 09:07:45 niklas Exp $	*/
a496 3
	if (ioapics == NULL)
		return;

d501 3
@


1.1.2.12
log
@crazy indent
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.1.2.11 2004/06/09 18:37:04 drahn Exp $	*/
d454 1
a454 2
		pp->ip_vector = nvector;
		pp->ip_minlevel = minlevel;
@


1.1.2.13
log
@pretty print in dmesg -- when it is easier on the eyes glaring problems
jump out; art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.1.2.12 2004/06/10 15:58:51 deraadt Exp $	*/
d221 1
a221 1
	printf(" apid %d", aaa->apic_id);
d224 2
a225 1
		printf(": duplicate apic id (ignored)\n");
d231 1
a231 1
	printf(": pa 0x%lx", aaa->apic_address);
d234 1
a234 1
		printf(", map failed\n");
d275 1
a275 1
		printf("%s: misconfigured as apic %d", sc->sc_dev.dv_xname,
d285 7
a291 4
		if (apic_id != sc->sc_apicid)
			printf(", can't remap to apid %d\n", sc->sc_apicid);
		else
			printf(", remapped to apic %d\n", sc->sc_apicid);
d518 1
a518 2
		if (mp_verbose)
			printf("%s: enabling\n", sc->sc_dev.dv_xname);
@


1.1.2.14
log
@Since ioapic redirection table entries are 64-bit it takes 2
memory writes to fill one. To do it atomically disable the entry first,
write high part then write low part.

ok niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioapic.c,v 1.1.2.13 2004/06/13 07:31:56 deraadt Exp $	*/
d373 1
a373 2
	/* Do atomic write */
	ioapic_write(sc, IOAPIC_REDLO(pin), IOAPIC_REDLO_MASK);
a374 1
	ioapic_write(sc, IOAPIC_REDLO(pin), redlo);
@


