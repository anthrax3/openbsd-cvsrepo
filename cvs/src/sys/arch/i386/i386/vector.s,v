head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.2
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.20.0.10
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.6
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.6
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.4
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.12.0.8
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@# @;


1.21
date	2017.05.30.12.41.55;	author mlarkin;	state Exp;
branches;
next	1.20;
commitid	yZk0oJDrVea2Th12;

1.20
date	2015.06.28.01.11.27;	author guenther;	state Exp;
branches;
next	1.19;
commitid	pmt8zLCdl4eF6ZNV;

1.19
date	2015.04.25.21.31.24;	author guenther;	state Exp;
branches;
next	1.18;
commitid	Jx2fq8kp0uEBpslo;

1.18
date	2013.11.28.19.30.46;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2013.05.12.14.15.31;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2011.09.22.12.17.04;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2011.04.16.00.40.58;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.10.16.40.50;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.10.13.51.47;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.26.14.33.27;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2008.04.25.19.50.08;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.12.20.22.58;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.09.19.49.47;	author tom;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.12.04.41.30;	author gwk;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.13.16.14.49;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.24.22.50.29;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.24.21.22.00;	author pvalchev;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.28.02.00.20;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.20.16.30.51;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2004.03.16.18.27.10;	author niklas;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.03.16.18.27.10;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2004.03.22.23.48.40;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.03.23.08.02.55;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2004.03.23.22.26.23;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.21
log
@move some data tables out of .text and into .rodata where they belong

ok deraadt
@
text
@/*	$OpenBSD: vector.s,v 1.20 2015/06/28 01:11:27 guenther Exp $	*/
/*	$NetBSD: vector.s,v 1.32 1996/01/07 21:29:47 mycroft Exp $	*/

/*
 * Copyright (c) 1993, 1994, 1995 Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *	notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *	notice, this list of conditions and the following disclaimer in the
 *	documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *	must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *	derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <machine/i8259.h>
#include <dev/isa/isareg.h>

/*
 * Macros for interrupt entry, call to handler, and exit.
 *
 * XXX
 * The interrupt frame is set up to look like a trap frame.  This may be a
 * waste.  The only handler which needs a frame is the clock handler, and it
 * only needs a few bits.  Xdoreti() needs a trap frame for handling ASTs, but
 * it could easily convert the frame on demand.
 *
 * The direct costs of setting up a trap frame are two pushl's (error code and
 * trap number), an addl to get rid of these, and pushing and popping the
 * callee-saved registers %esi, %edi, %ebx, and %ebp twice.
 *
 * If the interrupt frame is made more flexible,  INTR can push %eax first and
 * decide the ipending case with less overhead, e.g., by avoiding loading the
 * segment registers.
 */

	.globl	_C_LABEL(isa_strayintr)

#define voidop(num)

/*
 * Normal vectors.
 *
 * We cdr down the intrhand chain, calling each handler with its appropriate
 * argument (0 meaning a pointer to the frame, for clock interrupts).
 *
 * The handler returns one of three values:
 *   0 - This interrupt wasn't for me.
 *   1 - This interrupt was for me.
 *  -1 - This interrupt might have been for me, but I don't know.
 * If there are no handlers, or they all return 0, we flag it as a `stray'
 * interrupt.  On a system with level-triggered interrupts, we could terminate
 * immediately when one of them returns 1; but this is a PC.
 *
 * On exit, we jump to Xdoreti(), to process soft interrupts and ASTs.
 */
#define	INTRSTUB(name, num, early_ack, late_ack, mask, unmask, level_mask) \
IDTVEC(resume_##name##num)						;\
	push	%ebx							;\
	cli								;\
	jmp	1f							;\
IDTVEC(recurse_##name##num)						;\
	pushfl								;\
	pushl	%cs							;\
	pushl	%esi							;\
	subl	$8,%esp			/* space for tf_{err,trapno} */ ;\
	movl	%ebx,%esi						;\
	INTRENTRY							;\
	MAKE_FRAME							;\
	push	%esi							;\
	cli								;\
	jmp	1f							;\
_C_LABEL(Xintr_##name##num):						;\
	subl	$8,%esp			/* space for tf_{err,trapno} */ ;\
	INTRENTRY							;\
	MAKE_FRAME							;\
	mask(num)			/* mask it in hardware */	;\
	early_ack(num)			/* and allow other intrs */	;\
	incl	_C_LABEL(uvmexp)+V_INTR	/* statistical info */		;\
	movl	_C_LABEL(iminlevel) + (num) * 4, %eax			;\
	movl	CPL,%ebx						;\
	cmpl	%eax,%ebx						;\
	jae	_C_LABEL(Xhold_##name##num)/* currently masked; hold it */;\
	pushl	%ebx			/* cpl to restore on exit */	;\
1:									;\
	movl	_C_LABEL(imaxlevel) + (num) * 4,%eax			;\
	movl	%eax,CPL		/* block enough for this irq */	;\
	sti				/* safe to take intrs now */	;\
	movl	_C_LABEL(intrhand) + (num) * 4,%ebx	/* head of chain */ ;\
	testl	%ebx,%ebx						;\
	jz	_C_LABEL(Xstray_##name##num)	/* no handlers; we're stray */	;\
	STRAY_INITIALIZE		/* nobody claimed it yet */	;\
	incl	CPUVAR(IDEPTH)						;\
7:	movl	%esp, %eax		/* save frame pointer in eax */	;\
	pushl	%ebx			/* arg 2: ih structure */	;\
	pushl	%eax			/* arg 1: frame pointer */	;\
	call	_C_LABEL(intr_handler)	/* call it */			;\
	addl	$8, %esp		/* toss args */			;\
	STRAY_INTEGRATE			/* maybe he claimed it */	;\
	orl	%eax,%eax		/* should it be counted? */	;\
	jz	5f			/* no, skip it */		;\
	addl	$1,IH_COUNT(%ebx)	/* count the intrs */		;\
	adcl	$0,IH_COUNT+4(%ebx)					;\
	cmpl	$0,_C_LABEL(intr_shared_edge)				;\
	jne	5f			 /* if no shared edges ... */	;\
	orl	%eax,%eax		/* ... 1 means stop trying */	;\
	jns	8f							;\
5:	movl	IH_NEXT(%ebx),%ebx	/* next handler in chain */	;\
	testl	%ebx,%ebx						;\
	jnz	7b							;\
8:	decl	CPUVAR(IDEPTH)						;\
	STRAY_TEST(name,num)		/* see if it's a stray */	;\
6:	unmask(num)			/* unmask it in hardware */	;\
	late_ack(num)							;\
	jmp	_C_LABEL(Xdoreti)	/* lower spl and do ASTs */	;\
IDTVEC(stray_##name##num)						;\
	pushl	$num							;\
	call	_C_LABEL(isa_strayintr)					;\
	addl	$4,%esp							;\
	jmp	6b							;\
IDTVEC(hold_##name##num)						;\
	orb	$IRQ_BIT(num),CPUVAR(IPENDING) + IRQ_BYTE(num)	;\
	INTRFASTEXIT

#if defined(DEBUG)
#define	STRAY_INITIALIZE \
	xorl	%esi,%esi
#define	STRAY_INTEGRATE \
	orl	%eax,%esi
#define	STRAY_TEST(name,num) \
	testl	%esi,%esi						;\
	jz	_C_LABEL(Xstray_##name##num)
#else /* !DEBUG */
#define	STRAY_INITIALIZE
#define	STRAY_INTEGRATE
#define	STRAY_TEST(name,num)
#endif /* DEBUG */

#ifdef DDB
#define	MAKE_FRAME \
	leal	-8(%esp),%ebp
#else /* !DDB */
#define	MAKE_FRAME
#endif /* DDB */

#define ICUADDR IO_ICU1

INTRSTUB(legacy,0, i8259_asm_ack1, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,1, i8259_asm_ack1, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,2, i8259_asm_ack1, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,3, i8259_asm_ack1, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,4, i8259_asm_ack1, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,5, i8259_asm_ack1, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,6, i8259_asm_ack1, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,7, i8259_asm_ack1, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)

#undef ICUADDR
#define ICUADDR IO_ICU2

INTRSTUB(legacy,8, i8259_asm_ack2, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,9, i8259_asm_ack2, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,10, i8259_asm_ack2, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,11, i8259_asm_ack2, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,12, i8259_asm_ack2, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,13, i8259_asm_ack2, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,14, i8259_asm_ack2, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,15, i8259_asm_ack2, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)

	.section .rodata
/*
 * These tables are used by the ISA configuration code.
 */
/* interrupt service routine entry points */
IDTVEC(intr)
	.long   _C_LABEL(Xintr_legacy0), _C_LABEL(Xintr_legacy1)
	.long	_C_LABEL(Xintr_legacy2), _C_LABEL(Xintr_legacy3)
	.long	_C_LABEL(Xintr_legacy4), _C_LABEL(Xintr_legacy5)
	.long	_C_LABEL(Xintr_legacy6), _C_LABEL(Xintr_legacy7)
	.long	_C_LABEL(Xintr_legacy8), _C_LABEL(Xintr_legacy9)
	.long	_C_LABEL(Xintr_legacy10), _C_LABEL(Xintr_legacy11)
	.long	_C_LABEL(Xintr_legacy12), _C_LABEL(Xintr_legacy13)
	.long	_C_LABEL(Xintr_legacy14), _C_LABEL(Xintr_legacy15)

/*
 * These tables are used by Xdoreti() and Xspllower().
 */
/* resume points for suspended interrupts */
IDTVEC(resume)
	.long	_C_LABEL(Xresume_legacy0), _C_LABEL(Xresume_legacy1)
	.long	_C_LABEL(Xresume_legacy2), _C_LABEL(Xresume_legacy3)
	.long	_C_LABEL(Xresume_legacy4), _C_LABEL(Xresume_legacy5)
	.long	_C_LABEL(Xresume_legacy6), _C_LABEL(Xresume_legacy7)
	.long	_C_LABEL(Xresume_legacy8), _C_LABEL(Xresume_legacy9)
	.long	_C_LABEL(Xresume_legacy10), _C_LABEL(Xresume_legacy11)
	.long	_C_LABEL(Xresume_legacy12), _C_LABEL(Xresume_legacy13)
	.long	_C_LABEL(Xresume_legacy14), _C_LABEL(Xresume_legacy15)
	/* for soft interrupts */
	.long	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	.long	_C_LABEL(Xsofttty), _C_LABEL(Xsoftnet), _C_LABEL(Xsoftclock)
	.long	0, 0
/* fake interrupts to resume from splx() */
IDTVEC(recurse)
	.long	_C_LABEL(Xrecurse_legacy0), _C_LABEL(Xrecurse_legacy1)
	.long	_C_LABEL(Xrecurse_legacy2), _C_LABEL(Xrecurse_legacy3)
	.long	_C_LABEL(Xrecurse_legacy4), _C_LABEL(Xrecurse_legacy5)
	.long	_C_LABEL(Xrecurse_legacy6), _C_LABEL(Xrecurse_legacy7)
	.long	_C_LABEL(Xrecurse_legacy8), _C_LABEL(Xrecurse_legacy9)
	.long	_C_LABEL(Xrecurse_legacy10), _C_LABEL(Xrecurse_legacy11)
	.long	_C_LABEL(Xrecurse_legacy12), _C_LABEL(Xrecurse_legacy13)
	.long	_C_LABEL(Xrecurse_legacy14), _C_LABEL(Xrecurse_legacy15)
	/* for soft interrupts */
	.long	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	.long	_C_LABEL(Xsofttty), _C_LABEL(Xsoftnet), _C_LABEL(Xsoftclock)
	.long	0, 0
@


1.20
log
@Split AST handling from trap() into ast() and get rid of T_ASTFLT

testing by krw@@, and then many via snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.19 2015/04/25 21:31:24 guenther Exp $	*/
d202 1
@


1.19
log
@We now following the ABI and always clear cld on function entry, so remove
the extra CLD instructions from when that wasn't true

testing miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.18 2013/11/28 19:30:46 brad Exp $	*/
d83 1
a83 2
	pushl	$0			/* dummy error code */		;\
	pushl	$T_ASTFLT		/* trap # for doing ASTs */	;\
d91 1
a91 2
	pushl	$0			/* dummy error code */		;\
	pushl	$T_ASTFLT		/* trap # for doing ASTs */	;\
@


1.18
log
@Appease LLVM's integrated assembler.

error: ambiguous instructions require an explicit suffix (could be 'cmpb', 'cmpw', 'cmpl', or 'cmpq'
error: unknown token in expression

cmp -> cmpl, %cs:* -> *%cs:

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.17 2013/05/12 14:15:31 ratchov Exp $	*/
a51 4
 *
 * XXX
 * Should we do a cld on every system entry to avoid the requirement for
 * scattered cld's?
@


1.17
log
@Take the kernel lock and call the actual interrupt handler from a
single c function. This will hopefully make easier to stop taking
the kernel lock when running "mp safe" interrupt handlers.

help from ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.16 2011/09/22 12:17:04 deraadt Exp $	*/
d127 1
a127 1
	cmp	$0,_C_LABEL(intr_shared_edge)				;\
@


1.16
log
@The MY_COUNT abstraction which depends on locore including these two
files is ridiculous.  Remove it.
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.15 2011/04/16 00:40:58 deraadt Exp $	*/
a59 8
#ifdef MULTIPROCESSOR
#define LOCK_KERNEL(ipl)	pushl ipl; call _C_LABEL(i386_intlock);	addl $4,%esp
#define UNLOCK_KERNEL(ipl)	pushl ipl; call _C_LABEL(i386_intunlock); addl $4,%esp
#else
#define LOCK_KERNEL(ipl)
#define UNLOCK_KERNEL(ipl)
#endif

d117 5
a121 8
	LOCK_KERNEL(IF_PPL(%esp))					;\
7:	movl	IH_ARG(%ebx),%eax	/* get handler arg */		;\
	testl	%eax,%eax						;\
	jnz	4f							;\
	movl	%esp,%eax		/* 0 means frame pointer */	;\
4:	pushl	%eax							;\
	call	*IH_FUN(%ebx)		/* call it */			;\
	addl	$4,%esp			/* toss the arg */		;\
d134 1
a134 2
8:	UNLOCK_KERNEL(IF_PPL(%esp))					;\
	decl	CPUVAR(IDEPTH)						;\
@


1.15
log
@More than a decade ago, interrupt handlers on sparc started returning 0
(interrupt was not for me), 1 (positive interrupt was for me), or -1
(i am not sure...).  We have continued with this practice in as many
drivers as possible, throughout the tree.

This makes some of the architectures use that information in their
interrupt handler calling code -- if 1 is returned (and we know
this specific machine does not have edge-shared interrupts), we
finish servicing other possible handlers on the same pin.  If the
interrupt pin remains asserted (from a different device), we will
end up back in the interrupt servicing code of course... but this is
cheaper than calling all the chained interrupts on a pin.

This does of course count on shared level interrupts being properly
sorted by IPL.

There have been some concerns about starvation of drivers which
incorrectly return 1.  Those drivers should be hunted down so that
they return -1.

ok and help from various people.  In snaps for about a week now.
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.14 2009/08/10 16:40:50 oga Exp $	*/
a35 2
#define MY_COUNT _C_LABEL(uvmexp)

d110 1
a110 1
	incl	MY_COUNT+V_INTR		/* statistical info */		;\
@


1.14
log
@right now, we only increment ci_idepth in struct cpuinfo when
MULTIPROCESSOR is defined. This makes splassert incorrect for IPL_NONE
on such kernels.

Make this more similar to amd64, and move the inc and dec of ci_idepth
into the interrupt vectors, and only leave biglock in the locking
functions.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.13 2009/07/10 13:51:47 jsg Exp $	*/
d140 4
d147 1
a147 1
	UNLOCK_KERNEL(IF_PPL(%esp))					;\
@


1.13
log
@Switch away from using -traditional-cpp to iso/ansi cpp for asm files.
More architectures hopefully to follow.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.12 2008/04/26 14:33:27 kettenis Exp $	*/
d126 1
d144 1
@


1.12
log
@Remove softast; it's no longer used.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.11 2008/04/25 19:50:08 kettenis Exp $	*/
d89 1
a89 1
IDTVEC(resume_/**/name/**/num)						;\
d93 1
a93 1
IDTVEC(recurse_/**/name/**/num)						;\
d105 1
a105 1
_C_LABEL(Xintr_/**/name/**/num):					;\
d116 1
a116 1
	jae	_C_LABEL(Xhold_/**/name/**/num)/* currently masked; hold it */;\
d124 1
a124 1
	jz	_C_LABEL(Xstray_/**/name/**/num)	/* no handlers; we're stray */	;\
d147 1
a147 1
IDTVEC(stray_/**/name/**/num)						;\
d152 1
a152 1
IDTVEC(hold_/**/name/**/num)						;\
d163 1
a163 1
	jz	_C_LABEL(Xstray_/**/name/**/num)
@


1.11
log
@Make ipending per-cpu.  Should fix PR 5788.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.10 2007/04/12 20:22:58 art Exp $	*/
d244 2
a245 3
	.long	0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	.long	_C_LABEL(Xsoftast), _C_LABEL(Xsofttty) 
	.long	_C_LABEL(Xsoftnet), _C_LABEL(Xsoftclock)
d258 2
a259 3
	.long	0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	.long	_C_LABEL(Xsoftast), _C_LABEL(Xsofttty) 
	.long	_C_LABEL(Xsoftnet), _C_LABEL(Xsoftclock)
@


1.10
log
@Faster signal delivery on i386/MP.

We need to poke the other CPU so that it processes the AST immediately
and doesn't wait for the next interrupt or syscall.

Since IPIs really shouldn't process ASTs, we need to trigger a soft
interrupt on the destination CPU to process the AST. But since we can't
send soft interrupts to other CPUs, we send an IPI, that triggers a soft
interrupt that in turn processes the AST.

Also, this marks the beginning of moving to slightly better IPI mechanism
of short and optimized IPIs instead of the large and complicated IPI
infrastructure we're using now.

tested by many, ok tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.9 2007/02/09 19:49:47 tom Exp $	*/
d153 1
a153 1
	orb	$IRQ_BIT(num),_C_LABEL(ipending) + IRQ_BYTE(num)	;\
@


1.9
log
@Don't both reloading the CPL into %eax before pushing it onto the stack,
since it's already in %ebx.  (And %eax is reloaded immediately after
the push, so CPL not needed in %eax.)  Saves one load every interrupt.

ok dim@@, gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.8 2006/06/12 04:41:30 gwk Exp $	*/
d244 3
a246 3
	.long	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	.long	_C_LABEL(Xsofttty), _C_LABEL(Xsoftnet)
	.long	_C_LABEL(Xsoftclock)
d259 3
a261 3
	.long	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	.long	_C_LABEL(Xsofttty), _C_LABEL(Xsoftnet)
	.long	_C_LABEL(Xsoftclock)
@


1.8
log
@Add stray interrupt reporting to the apicvec.s, fix the code for stray
interrupt reporting in vector.s. Stray interrupts will only be reported if
a kernel is compiled with option DEBUG, in the case of a non-ioapic kernel
some stray interrupts may be erroneously reported durring the boot process.
ok toby@@, "get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.7 2005/12/13 16:14:49 aaron Exp $	*/
d117 1
a117 2
	movl	CPL,%eax		/* cpl to restore on exit */	;\
	pushl	%eax							;\
@


1.7
log
@Prevent recursive interrupts.  Solves kernel stack overflow on i386 under
heavy network interrupt load (I can reproduce with an ARP flood) with an MP
kernel.  Patch from NetBSD PR20180.

Has been in snapshots for a bit.  Testing by pedro@@, jolan@@.  deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.6 2004/12/24 22:50:29 miod Exp $	*/
d144 1
a144 1
	STRAY_TEST			/* see if it's a stray */	;\
d157 1
a157 1
#if defined(DEBUG) && defined(notdef)
d162 1
a162 1
#define	STRAY_TEST \
d168 1
a168 1
#define	STRAY_TEST
@


1.6
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.5 2004/12/24 21:22:00 pvalchev Exp $	*/
d89 4
d97 6
d104 1
a116 1
Xresume_/**/name/**/num/**/:						;\
d119 1
@


1.5
log
@Rewrite intlock/intunlock not to pass around interrupt frame directly
without copying which is against C conventions and broke GENERIC.MP
with a gcc3 optimization
From niklas, tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.4 2004/06/28 02:00:20 deraadt Exp $	*/
a252 10

/* Some bogus data, to keep vmstat happy, for now. */
	.globl	_C_LABEL(intrnames), _C_LABEL(eintrnames)
	.globl	_C_LABEL(intrcnt), _C_LABEL(eintrcnt)
_C_LABEL(intrnames):
	.long	0
_C_LABEL(eintrnames):
_C_LABEL(intrcnt):
	.long	0
_C_LABEL(eintrcnt):
@


1.4
log
@move from unsafe ev_count32 to safe ev_count; aaron ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.3 2004/06/20 16:30:51 aaron Exp $	*/
d63 2
a64 2
#define LOCK_KERNEL	call _C_LABEL(i386_intlock)
#define UNLOCK_KERNEL	call _C_LABEL(i386_intunlock)
d66 2
a67 2
#define LOCK_KERNEL
#define UNLOCK_KERNEL
d116 1
a116 1
	LOCK_KERNEL							;\
d132 1
a132 1
	UNLOCK_KERNEL							;\
@


1.3
log
@Fix some comment typos I noticed while reading this code.
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.2 2004/06/13 21:49:15 niklas Exp $	*/
d127 2
a128 1
	incl	IH_COUNT(%ebx)		/* count the intrs */		;\
@


1.2
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d82 1
a82 1
 * If there are no handlers, or they all return 0, we flags it as a `stray'
d114 1
a114 1
	jz	_C_LABEL(Xstray_/**/name/**/num)	/* no handlears; we're stray */	;\
@


1.1
log
@file vector.s was initially added on branch SMP.
@
text
@d1 261
@


1.1.2.1
log
@Moving vector.s from isa to i386 in preparation for a merged (for all kind of sources) interrupt system
@
text
@a0 305
/*	$OpenBSD: vector.s,v 1.10.6.9 2003/05/15 17:47:16 niklas Exp $	*/
/*	$NetBSD: vector.s,v 1.32 1996/01/07 21:29:47 mycroft Exp $	*/

/*
 * Copyright (c) 1993, 1994, 1995 Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *	notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *	notice, this list of conditions and the following disclaimer in the
 *	documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *	must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *	derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <i386/isa/icu.h>
#include <dev/isa/isareg.h>

#define ICU_HARDWARE_MASK

#define MY_COUNT _C_LABEL(uvmexp)

/*
 * These macros are fairly self explanatory.  If ICU_SPECIAL_MASK_MODE is
 * defined, we try to take advantage of the ICU's `special mask mode' by only
 * EOIing the interrupts on return.  This avoids the requirement of masking and
 * unmasking.  We can't do this without special mask mode, because the ICU
 * would also hold interrupts that it thinks are of lower priority.
 *
 * Many machines do not support special mask mode, so by default we don't try
 * to use it.
 */

#define	IRQ_BIT(irq_num)	(1 << ((irq_num) % 8))
#define	IRQ_BYTE(irq_num)	((irq_num) / 8)

#ifdef ICU_SPECIAL_MASK_MODE

#define	ACK1(irq_num)
#define	ACK2(irq_num) \
	movb	$(0x60|IRQ_SLAVE),%al	/* specific EOI for IRQ2 */	;\
	outb	%al,$IO_ICU1
#define	MASK(irq_num, icu)
#define	UNMASK(irq_num, icu) \
	movb	$(0x60|(irq_num%8)),%al	/* specific EOI */		;\
	outb	%al,$icu

#else /* ICU_SPECIAL_MASK_MODE */

#ifndef	AUTO_EOI_1
#define	ACK1(irq_num) \
	movb	$(0x60|(irq_num%8)),%al	/* specific EOI */		;\
	outb	%al,$IO_ICU1
#else
#define	ACK1(irq_num)
#endif

#ifndef AUTO_EOI_2
#define	ACK2(irq_num) \
	movb	$(0x60|(irq_num%8)),%al	/* specific EOI */		;\
	outb	%al,$IO_ICU2		/* do the second ICU first */	;\
	movb	$(0x60|IRQ_SLAVE),%al	/* specific EOI for IRQ2 */	;\
	outb	%al,$IO_ICU1
#else
#define	ACK2(irq_num)
#endif

#ifdef ICU_HARDWARE_MASK

#define	MASK(irq_num, icu) \
	movb	_C_LABEL(imen) + IRQ_BYTE(irq_num),%al				;\
	orb	$IRQ_BIT(irq_num),%al					;\
	movb	%al,_C_LABEL(imen) + IRQ_BYTE(irq_num)				;\
	FASTER_NOP							;\
	outb	%al,$(icu+1)
#define	UNMASK(irq_num, icu) \
	cli								;\
	movb	_C_LABEL(imen) + IRQ_BYTE(irq_num),%al				;\
	andb	$~IRQ_BIT(irq_num),%al					;\
	movb	%al,_C_LABEL(imen) + IRQ_BYTE(irq_num)				;\
	FASTER_NOP							;\
	outb	%al,$(icu+1)						;\
	sti

#else /* ICU_HARDWARE_MASK */

#define	MASK(irq_num, icu)
#define	UNMASK(irq_num, icu)

#endif /* ICU_HARDWARE_MASK */

#endif /* ICU_SPECIAL_MASK_MODE */

/*
 * Macros for interrupt entry, call to handler, and exit.
 *
 * XXX
 * The interrupt frame is set up to look like a trap frame.  This may be a
 * waste.  The only handler which needs a frame is the clock handler, and it
 * only needs a few bits.  Xdoreti() needs a trap frame for handling ASTs, but
 * it could easily convert the frame on demand.
 *
 * The direct costs of setting up a trap frame are two pushl's (error code and
 * trap number), an addl to get rid of these, and pushing and popping the
 * callee-saved registers %esi, %edi, %ebx, and %ebp twice.
 *
 * If the interrupt frame is made more flexible,  INTR can push %eax first and
 * decide the ipending case with less overhead, e.g., by avoiding loading the
 * segment registers.
 *
 * XXX
 * Should we do a cld on every system entry to avoid the requirement for
 * scattered cld's?
 */

	.globl	_C_LABEL(isa_strayintr)

#ifdef MULTIPROCESSOR
#define LOCK_KERNEL	call _C_LABEL(i386_intlock)
#define UNLOCK_KERNEL	call _C_LABEL(i386_intunlock)
#else
#define LOCK_KERNEL
#define UNLOCK_KERNEL
#endif

/*
 * Normal vectors.
 *
 * We cdr down the intrhand chain, calling each handler with its appropriate
 * argument (0 meaning a pointer to the frame, for clock interrupts).
 *
 * The handler returns one of three values:
 *   0 - This interrupt wasn't for me.
 *   1 - This interrupt was for me.
 *  -1 - This interrupt might have been for me, but I don't know.
 * If there are no handlers, or they all return 0, we flags it as a `stray'
 * interrupt.  On a system with level-triggered interrupts, we could terminate
 * immediately when one of them returns 1; but this is a PC.
 *
 * On exit, we jump to Xdoreti(), to process soft interrupts and ASTs.
 */
#define	INTR(irq_num, icu, ack) \
IDTVEC(recurse/**/irq_num)						;\
	pushfl								;\
	pushl	%cs							;\
	pushl	%esi							;\
	cli								;\
_C_LABEL(Xintr)/**/irq_num/**/:						;\
	pushl	$0			/* dummy error code */		;\
	pushl	$T_ASTFLT		/* trap # for doing ASTs */	;\
	INTRENTRY							;\
	MAKE_FRAME							;\
	MASK(irq_num, icu)		/* mask it in hardware */	;\
	ack(irq_num)			/* and allow other intrs */	;\
	incl	MY_COUNT+V_INTR		/* statistical info */		;\
	movl	_C_LABEL(iminlevel) + (irq_num) * 4, %eax		;\
	movl	CPL,%ebx						;\
	cmpl	%eax,%ebx						;\
	jae	_C_LABEL(Xhold/**/irq_num)/* currently masked; hold it */;\
Xresume/**/irq_num/**/:						;\
	movl	CPL,%eax		/* cpl to restore on exit */	;\
	pushl	%eax							;\
	movl	_C_LABEL(imaxlevel) + (irq_num) * 4,%eax		;\
	movl	%eax,CPL		/* block enough for this irq */	;\
	sti				/* safe to take intrs now */	;\
	movl	_C_LABEL(intrhand) + (irq_num) * 4,%ebx	/* head of chain */ ;\
	testl	%ebx,%ebx						;\
	jz	_C_LABEL(Xstray)/**/irq_num	/* no handlears; we're stray */	;\
	STRAY_INITIALIZE		/* nobody claimed it yet */	;\
	LOCK_KERNEL							;\
7:	movl	IH_ARG(%ebx),%eax	/* get handler arg */		;\
	testl	%eax,%eax						;\
	jnz	4f							;\
	movl	%esp,%eax		/* 0 means frame pointer */	;\
4:	pushl	%eax							;\
	call	*IH_FUN(%ebx)		/* call it */			;\
	addl	$4,%esp			/* toss the arg */		;\
	STRAY_INTEGRATE			/* maybe he claimed it */	;\
	orl	%eax,%eax		/* should it be counted? */	;\
	jz	5f			/* no, skip it */		;\
	incl	IH_COUNT(%ebx)		/* count the intrs */		;\
5:	movl	IH_NEXT(%ebx),%ebx	/* next handler in chain */	;\
	testl	%ebx,%ebx						;\
	jnz	7b							;\
	UNLOCK_KERNEL							;\
	STRAY_TEST			/* see if it's a stray */	;\
6:	UNMASK(irq_num, icu)		/* unmask it in hardware */	;\
	jmp	_C_LABEL(Xdoreti)	/* lower spl and do ASTs */	;\
IDTVEC(stray/**/irq_num)						;\
	pushl	$irq_num						;\
	call	_C_LABEL(isa_strayintr)					;\
	addl	$4,%esp							;\
	jmp	6b							;\
IDTVEC(hold/**/irq_num)							;\
	orb	$IRQ_BIT(irq_num),_C_LABEL(ipending) + IRQ_BYTE(irq_num)	;\
	INTRFASTEXIT

#if defined(DEBUG) && defined(notdef)
#define	STRAY_INITIALIZE \
	xorl	%esi,%esi
#define	STRAY_INTEGRATE \
	orl	%eax,%esi
#define	STRAY_TEST \
	testl	%esi,%esi						;\
	jz	_C_LABEL(Xstray)/**/irq_num
#else /* !DEBUG */
#define	STRAY_INITIALIZE
#define	STRAY_INTEGRATE
#define	STRAY_TEST
#endif /* DEBUG */

#ifdef DDB
#define	MAKE_FRAME \
	leal	-8(%esp),%ebp
#else /* !DDB */
#define	MAKE_FRAME
#endif /* DDB */

INTR(0, IO_ICU1, ACK1)
INTR(1, IO_ICU1, ACK1)
INTR(2, IO_ICU1, ACK1)
INTR(3, IO_ICU1, ACK1)
INTR(4, IO_ICU1, ACK1)
INTR(5, IO_ICU1, ACK1)
INTR(6, IO_ICU1, ACK1)
INTR(7, IO_ICU1, ACK1)
INTR(8, IO_ICU2, ACK2)
INTR(9, IO_ICU2, ACK2)
INTR(10, IO_ICU2, ACK2)
INTR(11, IO_ICU2, ACK2)
INTR(12, IO_ICU2, ACK2)
INTR(13, IO_ICU2, ACK2)
INTR(14, IO_ICU2, ACK2)
INTR(15, IO_ICU2, ACK2)

/*
 * These tables are used by the ISA configuration code.
 */
/* interrupt service routine entry points */
IDTVEC(intr)
	.long   _C_LABEL(Xintr0), _C_LABEL(Xintr1), _C_LABEL(Xintr2)
	.long	_C_LABEL(Xintr3), _C_LABEL(Xintr4), _C_LABEL(Xintr5)
	.long	_C_LABEL(Xintr6), _C_LABEL(Xintr7), _C_LABEL(Xintr8)
	.long	_C_LABEL(Xintr9), _C_LABEL(Xintr10), _C_LABEL(Xintr11)
	.long	_C_LABEL(Xintr12), _C_LABEL(Xintr13)
	.long	_C_LABEL(Xintr14), _C_LABEL(Xintr15)

/*
 * These tables are used by Xdoreti() and Xspllower().
 */
/* resume points for suspended interrupts */
IDTVEC(resume)
	.long	_C_LABEL(Xresume0), _C_LABEL(Xresume1)
	.long	_C_LABEL(Xresume2), _C_LABEL(Xresume3)
	.long	_C_LABEL(Xresume4), _C_LABEL(Xresume5)
	.long	_C_LABEL(Xresume6), _C_LABEL(Xresume7)
	.long	_C_LABEL(Xresume8), _C_LABEL(Xresume9)
	.long	_C_LABEL(Xresume10), _C_LABEL(Xresume11)
	.long	_C_LABEL(Xresume12), _C_LABEL(Xresume13)
	.long	_C_LABEL(Xresume14), _C_LABEL(Xresume15)
	/* for soft interrupts */
	.long	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	.long	_C_LABEL(Xsofttty), _C_LABEL(Xsoftnet)
	.long	_C_LABEL(Xsoftclock)
/* fake interrupts to resume from splx() */
IDTVEC(recurse)
	.long	_C_LABEL(Xrecurse0), _C_LABEL(Xrecurse1)
	.long	_C_LABEL(Xrecurse2), _C_LABEL(Xrecurse3)
	.long	_C_LABEL(Xrecurse4), _C_LABEL(Xrecurse5)
	.long	_C_LABEL(Xrecurse6), _C_LABEL(Xrecurse7)
	.long	_C_LABEL(Xrecurse8), _C_LABEL(Xrecurse9)
	.long	_C_LABEL(Xrecurse10), _C_LABEL(Xrecurse11)
	.long	_C_LABEL(Xrecurse12), _C_LABEL(Xrecurse13)
	.long	_C_LABEL(Xrecurse14), _C_LABEL(Xrecurse15)
	/* for soft interrupts */
	.long	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	.long	_C_LABEL(Xsofttty), _C_LABEL(Xsoftnet)
	.long	_C_LABEL(Xsoftclock)

/* Some bogus data, to keep vmstat happy, for now. */
	.globl	_C_LABEL(intrnames), _C_LABEL(eintrnames)
	.globl	_C_LABEL(intrcnt), _C_LABEL(eintrcnt)
_C_LABEL(intrnames):
	.long	0
_C_LABEL(eintrnames):
_C_LABEL(intrcnt):
	.long	0
_C_LABEL(eintrcnt):
@


1.1.2.2
log
@softintr vecs have moved, fixes hang at start of init(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.1.2.1 2004/03/16 18:27:10 niklas Exp $	*/
d279 1
a279 1
	.long	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
a281 1
	.long	0, 0
d293 1
a293 1
	.long	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
a295 1
	.long	0, 0
@


1.1.2.3
log
@a small step towards an integrated PIC/APIC system: move isa/icu.h to
include/i8259.h, and adapt the ACK/MASK/UNMASK macros so we can
reuse the API for APICs.  From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.1.2.2 2004/03/22 23:48:40 niklas Exp $	*/
d33 1
a33 1
#include <machine/i8259.h>
d36 2
d41 71
d159 1
a159 1
#define	INTR(irq_num, ack) \
d170 1
a170 1
	i8259_asm_mask(irq_num)		/* mask it in hardware */	;\
d204 1
a204 1
6:	i8259_asm_unmask(irq_num)	/* unmask it in hardware */	;\
d236 16
a251 22
#define ICUADDR IO_ICU1

INTR(0, i8259_asm_ack1)
INTR(1, i8259_asm_ack1)
INTR(2, i8259_asm_ack1)
INTR(3, i8259_asm_ack1)
INTR(4, i8259_asm_ack1)
INTR(5, i8259_asm_ack1)
INTR(6, i8259_asm_ack1)
INTR(7, i8259_asm_ack1)

#undef ICUADDR
#define ICUADDR IO_ICU2

INTR(8, i8259_asm_ack2)
INTR(9, i8259_asm_ack2)
INTR(10, i8259_asm_ack2)
INTR(11, i8259_asm_ack2)
INTR(12, i8259_asm_ack2)
INTR(13, i8259_asm_ack2)
INTR(14, i8259_asm_ack2)
INTR(15, i8259_asm_ack2)
@


1.1.2.4
log
@Yet another small step towards merged PIC and APIC handling
@
text
@d1 1
a1 1
/*	$OpenBSD: vector.s,v 1.1.2.3 2004/03/23 08:02:55 niklas Exp $	*/
a69 2
#define voidop(num)

d86 2
a87 2
#define	INTRSTUB(name, num, early_ack, late_ack, mask, unmask, level_mask) \
IDTVEC(recurse_/**/name/**/num)						;\
d92 1
a92 1
_C_LABEL(Xintr_/**/name/**/num):					;\
d97 2
a98 2
	mask(num)			/* mask it in hardware */	;\
	early_ack(num)			/* and allow other intrs */	;\
d100 1
a100 1
	movl	_C_LABEL(iminlevel) + (num) * 4, %eax			;\
d103 2
a104 2
	jae	_C_LABEL(Xhold_/**/name/**/num)/* currently masked; hold it */;\
Xresume_/**/name/**/num/**/:						;\
d107 1
a107 1
	movl	_C_LABEL(imaxlevel) + (num) * 4,%eax			;\
d110 1
a110 1
	movl	_C_LABEL(intrhand) + (num) * 4,%ebx	/* head of chain */ ;\
d112 1
a112 1
	jz	_C_LABEL(Xstray_/**/name/**/num)	/* no handlears; we're stray */	;\
d131 1
a131 2
6:	unmask(num)			/* unmask it in hardware */	;\
	late_ack(num)							;\
d133 2
a134 2
IDTVEC(stray_/**/name/**/num)						;\
	pushl	$num							;\
d138 2
a139 2
IDTVEC(hold_/**/name/**/num)						;\
	orb	$IRQ_BIT(num),_C_LABEL(ipending) + IRQ_BYTE(num)	;\
d149 1
a149 1
	jz	_C_LABEL(Xstray_/**/name/**/num)
d165 8
a172 16
INTRSTUB(legacy,0, i8259_asm_ack1, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,1, i8259_asm_ack1, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,2, i8259_asm_ack1, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,3, i8259_asm_ack1, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,4, i8259_asm_ack1, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,5, i8259_asm_ack1, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,6, i8259_asm_ack1, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,7, i8259_asm_ack1, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
d177 8
a184 16
INTRSTUB(legacy,8, i8259_asm_ack2, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,9, i8259_asm_ack2, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,10, i8259_asm_ack2, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,11, i8259_asm_ack2, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,12, i8259_asm_ack2, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,13, i8259_asm_ack2, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,14, i8259_asm_ack2, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
INTRSTUB(legacy,15, i8259_asm_ack2, voidop, i8259_asm_mask, i8259_asm_unmask,
    voidop)
d191 6
a196 8
	.long   _C_LABEL(Xintr_legacy0), _C_LABEL(Xintr_legacy1)
	.long	_C_LABEL(Xintr_legacy2), _C_LABEL(Xintr_legacy3)
	.long	_C_LABEL(Xintr_legacy4), _C_LABEL(Xintr_legacy5)
	.long	_C_LABEL(Xintr_legacy6), _C_LABEL(Xintr_legacy7)
	.long	_C_LABEL(Xintr_legacy8), _C_LABEL(Xintr_legacy9)
	.long	_C_LABEL(Xintr_legacy10), _C_LABEL(Xintr_legacy11)
	.long	_C_LABEL(Xintr_legacy12), _C_LABEL(Xintr_legacy13)
	.long	_C_LABEL(Xintr_legacy14), _C_LABEL(Xintr_legacy15)
d203 8
a210 8
	.long	_C_LABEL(Xresume_legacy0), _C_LABEL(Xresume_legacy1)
	.long	_C_LABEL(Xresume_legacy2), _C_LABEL(Xresume_legacy3)
	.long	_C_LABEL(Xresume_legacy4), _C_LABEL(Xresume_legacy5)
	.long	_C_LABEL(Xresume_legacy6), _C_LABEL(Xresume_legacy7)
	.long	_C_LABEL(Xresume_legacy8), _C_LABEL(Xresume_legacy9)
	.long	_C_LABEL(Xresume_legacy10), _C_LABEL(Xresume_legacy11)
	.long	_C_LABEL(Xresume_legacy12), _C_LABEL(Xresume_legacy13)
	.long	_C_LABEL(Xresume_legacy14), _C_LABEL(Xresume_legacy15)
d218 8
a225 8
	.long	_C_LABEL(Xrecurse_legacy0), _C_LABEL(Xrecurse_legacy1)
	.long	_C_LABEL(Xrecurse_legacy2), _C_LABEL(Xrecurse_legacy3)
	.long	_C_LABEL(Xrecurse_legacy4), _C_LABEL(Xrecurse_legacy5)
	.long	_C_LABEL(Xrecurse_legacy6), _C_LABEL(Xrecurse_legacy7)
	.long	_C_LABEL(Xrecurse_legacy8), _C_LABEL(Xrecurse_legacy9)
	.long	_C_LABEL(Xrecurse_legacy10), _C_LABEL(Xrecurse_legacy11)
	.long	_C_LABEL(Xrecurse_legacy12), _C_LABEL(Xrecurse_legacy13)
	.long	_C_LABEL(Xrecurse_legacy14), _C_LABEL(Xrecurse_legacy15)
@


