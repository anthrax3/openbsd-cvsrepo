head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.2
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.4
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.22.0.10
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.6
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.8
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.21.0.14
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.10
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.8
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.6
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.18.0.12
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.10
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.6
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.8
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.17.0.6
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.14
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.12
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.10
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.8
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.6
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.4
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.12.0.4
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.11.0.6
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.4
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	SMP:1.10.0.10
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.8
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.6
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.23
date	2016.10.08.05.49.08;	author guenther;	state Exp;
branches;
next	1.22;
commitid	z63v1DilayzHcfkw;

1.22
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.05.04.48.01;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2011.04.15.04.52.39;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.17;

1.17
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.11.13.21.12;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.09.22.27.09;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.16.20.50.16;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.04.08.57.48;	author niklas;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2000.03.23.17.17.32;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	98.03.04.22.44.10;	author deraadt;	state Exp;
branches
	1.10.10.1;
next	1.9;

1.9
date	97.02.01.21.53.31;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.01.27.22.48.02;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.05.30.09.30.35;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.07.07.21.58;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.02.13.42.56;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.16.42;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.18.19.18.13;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.04.17.05.18.59;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.01.11.17.59.05;	author deraadt;	state Exp;
branches;
next	;

1.10.10.1
date	2000.03.24.09.07.39;	author niklas;	state Exp;
branches;
next	1.10.10.2;

1.10.10.2
date	2001.07.15.15.10.55;	author ho;	state Exp;
branches;
next	1.10.10.3;

1.10.10.3
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.10.10.4;

1.10.10.4
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.10.10.5;

1.10.10.5
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.10.10.6;

1.10.10.6
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	;

1.12.4.1
date	2002.01.31.22.55.11;	author niklas;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Various printf claim to report the PID, so actually report that and not the TID

Build testing assistance from deraadt@@
@
text
@/*	$OpenBSD: vm86.c,v 1.22 2014/03/29 18:09:29 guenther Exp $	*/
/*	$NetBSD: vm86.c,v 1.15 1996/05/03 19:42:33 christos Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by John T. Kohl and Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/msgbuf.h>
#include <sys/mount.h>
#include <sys/vnode.h>
#include <sys/device.h>
#include <sys/sysctl.h>
#include <sys/syscallargs.h>
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVSHM
#include <sys/shm.h>
#endif

#include <sys/ktrace.h>
#include <machine/sysarch.h>
#include <machine/vm86.h>

static void fast_intxx(struct proc *, int);
static __inline int is_bitset(int, caddr_t);

#define	CS(tf)		(*(u_short *)&tf->tf_cs)
#define	IP(tf)		(*(u_short *)&tf->tf_eip)
#define	SS(tf)		(*(u_short *)&tf->tf_ss)
#define	SP(tf)		(*(u_short *)&tf->tf_esp)


#define putword(base, ptr, val) \
__asm__ volatile( \
	"decw %w0\n\t" \
	"movb %h2,0(%1,%0)\n\t" \
	"decw %w0\n\t" \
	"movb %b2,0(%1,%0)" \
	: "=r" (ptr) \
	: "r" (base), "q" (val), "0" (ptr))

#define putdword(base, ptr, val) \
__asm__ volatile( \
	"rorl $16,%2\n\t" \
	"decw %w0\n\t" \
	"movb %h2,0(%1,%0)\n\t" \
	"decw %w0\n\t" \
	"movb %b2,0(%1,%0)\n\t" \
	"rorl $16,%2\n\t" \
	"decw %w0\n\t" \
	"movb %h2,0(%1,%0)\n\t" \
	"decw %w0\n\t" \
	"movb %b2,0(%1,%0)" \
	: "=r" (ptr) \
	: "r" (base), "q" (val), "0" (ptr))

#define getbyte(base, ptr) \
({ unsigned long __res; \
__asm__ volatile( \
	"movb 0(%1,%0),%b2\n\t" \
	"incw %w0" \
	: "=r" (ptr), "=r" (base), "=q" (__res) \
	: "0" (ptr), "1" (base), "2" (0)); \
__res; })

#define getword(base, ptr) \
({ unsigned long __res; \
__asm__ volatile( \
	"movb 0(%1,%0),%b2\n\t" \
	"incw %w0\n\t" \
	"movb 0(%1,%0),%h2\n\t" \
	"incw %w0" \
	: "=r" (ptr), "=r" (base), "=q" (__res) \
	: "0" (ptr), "1" (base), "2" (0)); \
__res; })

#define getdword(base, ptr) \
({ unsigned long __res; \
__asm__ volatile( \
	"movb 0(%1,%0),%b2\n\t" \
	"incw %w0\n\t" \
	"movb 0(%1,%0),%h2\n\t" \
	"incw %w0\n\t" \
	"rorl $16,%2\n\t" \
	"movb 0(%1,%0),%b2\n\t" \
	"incw %w0\n\t" \
	"movb 0(%1,%0),%h2\n\t" \
	"incw %w0\n\t" \
	"rorl $16,%2" \
	: "=r" (ptr), "=r" (base), "=q" (__res) \
	: "0" (ptr), "1" (base)); \
__res; })


static __inline int
is_bitset(int nr, caddr_t bitmap)
{
	u_int byte;		/* bt instruction doesn't do
					   bytes--it examines ints! */
	bitmap += nr / NBBY;
	nr = nr % NBBY;
	copyin(bitmap, &byte, sizeof(u_char));

	__asm__ volatile("btl %2,%1\n\tsbbl %0,%0"
			     :"=r" (nr)
			     :"r" (byte),"r" (nr));
	return (nr);
}


#define V86_AH(regs)	(((u_char *)&((regs)->tf_eax))[1])
#define V86_AL(regs)	(((u_char *)&((regs)->tf_eax))[0])

static void
fast_intxx(struct proc *p, int intrno)
{
	struct trapframe *tf = p->p_md.md_regs;
	/*
	 * handle certain interrupts directly by pushing the interrupt
	 * frame and resetting registers, but only if user said that's ok
	 * (i.e. not revectored.)  Otherwise bump to 32-bit user handler.
	 */
	struct vm86_struct *u_vm86p;
	struct { u_short ip, cs; } ihand;

	u_long ss, sp;

	/*
	 * Note: u_vm86p points to user-space, we only compute offsets
	 * and don't deref it. is_revectored() above does copyin() to
	 * get stuff from it
	 */
	u_vm86p = (struct vm86_struct *)p->p_addr->u_pcb.vm86_userp;

	/*
	 * If user requested special handling, return to user space with
	 * indication of which INT was requested.
	 */
	if (is_bitset(intrno, &u_vm86p->int_byuser[0]))
		goto vector;

	/*
	 * If it's interrupt 0x21 (special in the DOS world) and the
	 * sub-command (in AH) was requested for special handling,
	 * return to user mode.
	 */
	if (intrno == 0x21 && is_bitset(V86_AH(tf), &u_vm86p->int21_byuser[0]))
		goto vector;

	/*
	 * Fetch intr handler info from "real-mode" IDT based at addr 0 in
	 * the user address space.
	 */
	if (copyin((caddr_t)(intrno * sizeof(ihand)), &ihand, sizeof(ihand)))
		goto bad;

	/*
	 * Otherwise, push flags, cs, eip, and jump to handler to
	 * simulate direct INT call.
	 */
	ss = SS(tf) << 4;
	sp = SP(tf);

	putword(ss, sp, get_vflags_short(p));
	putword(ss, sp, CS(tf));
	putword(ss, sp, IP(tf));
	SP(tf) = sp;

	IP(tf) = ihand.ip;
	CS(tf) = ihand.cs;

	return;

vector:
	vm86_return(p, VM86_MAKEVAL(VM86_INTx, intrno));
	return;

bad:
	vm86_return(p, VM86_UNKNOWN);
	return;
}

void
vm86_return(struct proc *p, int retval)
{
	union sigval sv;

	/*
	 * We can't set the virtual flags in our real trap frame,
	 * since it's used to jump to the signal handler.  Instead we
	 * let sendsig() pull in the vm86_eflags bits.
	 */
	if (p->p_sigmask & sigmask(SIGURG)) {
#ifdef DIAGNOSTIC
		printf("pid %d killed on VM86 protocol screwup (SIGURG blocked)\n",
		    p->p_p->ps_pid);
#endif
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}
	sv.sival_int = 0;
	trapsignal(p, SIGURG, retval, 0, sv);
}

#define	CLI	0xFA
#define	STI	0xFB
#define	INTxx	0xCD
#define	INTO	0xCE
#define	IRET	0xCF
#define	OPSIZ	0x66
#define	INT3	0xCC	/* Actually the process gets 32-bit IDT to handle it */
#define	LOCK	0xF0
#define	PUSHF	0x9C
#define	POPF	0x9D

/*
 * Handle a GP fault that occurred while in VM86 mode.  Things that are easy
 * to handle here are done here (much more efficient than trapping to 32-bit
 * handler code and then having it restart VM86 mode).
 */
void
vm86_gpfault(struct proc *p, int type)
{
	struct trapframe *tf = p->p_md.md_regs;
	union sigval sv;

	/*
	 * we want to fetch some stuff from the current user virtual
	 * address space for checking.  remember that the frame's
	 * segment selectors are real-mode style selectors.
	 */
	u_long cs, ip, ss, sp;
	u_char tmpbyte;
	int trace;

	cs = CS(tf) << 4;
	ip = IP(tf);
	ss = SS(tf) << 4;
	sp = SP(tf);

	trace = tf->tf_eflags & PSL_T;

	/*
	 * For most of these, we must set all the registers before calling
	 * macros/functions which might do a vm86_return.
	 */
	tmpbyte = getbyte(cs, ip);
	IP(tf) = ip;
	switch (tmpbyte) {
	case CLI:
		/* simulate handling of IF */
		clr_vif(p);
		break;

	case STI:
		/* simulate handling of IF.
		 * XXX the i386 enables interrupts one instruction later.
		 * code here is wrong, but much simpler than doing it Right.
		 */
		set_vif(p);
		break;

	case INTxx:
		/* try fast intxx, or return to 32bit mode to handle it. */
		tmpbyte = getbyte(cs, ip);
		IP(tf) = ip;
		fast_intxx(p, tmpbyte);
		break;

	case INTO:
		if (tf->tf_eflags & PSL_V)
			fast_intxx(p, 4);
		break;

	case PUSHF:
		putword(ss, sp, get_vflags_short(p));
		SP(tf) = sp;
		break;

	case IRET:
		IP(tf) = getword(ss, sp);
		CS(tf) = getword(ss, sp);
	case POPF:
		set_vflags_short(p, getword(ss, sp));
		SP(tf) = sp;
		break;

	case OPSIZ:
		tmpbyte = getbyte(cs, ip);
		IP(tf) = ip;
		switch (tmpbyte) {
		case PUSHF:
			putdword(ss, sp, get_vflags(p) & ~PSL_VM);
			SP(tf) = sp;
			break;

		case IRET:
			IP(tf) = getdword(ss, sp);
			CS(tf) = getdword(ss, sp);
		case POPF:
			set_vflags(p, getdword(ss, sp) | PSL_VM);
			SP(tf) = sp;
			break;

		default:
			IP(tf) -= 2;
			goto bad;
		}
		break;

	case LOCK:
	default:
		IP(tf) -= 1;
		goto bad;
	}

	if (trace && tf->tf_eflags & PSL_VM) {
		sv.sival_int = 0;
		trapsignal(p, SIGTRAP, T_TRCTRAP, TRAP_TRACE, sv);
	}
	return;

bad:
	vm86_return(p, VM86_UNKNOWN);
	return;
}

int
i386_vm86(struct proc *p, char *args, register_t *retval)
{
	struct trapframe *tf = p->p_md.md_regs;
	struct pcb *pcb = &p->p_addr->u_pcb;
	struct vm86_kern vm86s;
	int error;

	error = copyin(args, &vm86s, sizeof(vm86s));
	if (error)
		return (error);

	pcb->vm86_userp = (void *)args;

	/*
	 * Keep mask of flags we simulate to simulate a particular type of
	 * processor.
	 */
	switch (vm86s.ss_cpu_type) {
	case VCPU_086:
	case VCPU_186:
	case VCPU_286:
		pcb->vm86_flagmask = PSL_ID|PSL_AC|PSL_NT|PSL_IOPL;
		break;
	case VCPU_386:
		pcb->vm86_flagmask = PSL_ID|PSL_AC;
		break;
	case VCPU_486:
		pcb->vm86_flagmask = PSL_ID;
		break;
	case VCPU_586:
		pcb->vm86_flagmask = 0;
		break;
	default:
		return (EINVAL);
	}

#define DOVREG(reg) tf->tf_vm86_##reg = (u_short) vm86s.regs.vmsc.sc_##reg
#define DOREG(reg) tf->tf_##reg = (u_short) vm86s.regs.vmsc.sc_##reg

	DOVREG(ds);
	DOVREG(es);
	DOVREG(fs);
	DOVREG(gs);
	DOREG(edi);
	DOREG(esi);
	DOREG(ebp);
	DOREG(eax);
	DOREG(ebx);
	DOREG(ecx);
	DOREG(edx);
	DOREG(eip);
	DOREG(cs);
	DOREG(esp);
	DOREG(ss);

#undef	DOVREG
#undef	DOREG

	/* Going into vm86 mode jumps off the signal stack. */
	p->p_sigstk.ss_flags &= ~SS_ONSTACK;

	set_vflags(p, vm86s.regs.vmsc.sc_eflags | PSL_VM);

	return (EJUSTRETURN);
}
@


1.22
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm86.c,v 1.21 2011/07/05 04:48:01 guenther Exp $	*/
d238 1
a238 1
		       p->p_pid);
@


1.21
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm86.c,v 1.20 2011/04/18 21:44:55 guenther Exp $	*/
d76 1
a76 1
__asm__ __volatile__( \
d85 1
a85 1
__asm__ __volatile__( \
d101 1
a101 1
__asm__ __volatile__( \
d110 1
a110 1
__asm__ __volatile__( \
d121 1
a121 1
__asm__ __volatile__( \
d146 1
a146 1
	__asm__ __volatile__("btl %2,%1\n\tsbbl %0,%0"
@


1.20
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: vm86.c,v 1.18 2008/06/26 05:42:10 ray Exp $	*/
d430 1
a430 1
	p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.19
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d430 1
a430 1
	p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.18
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm86.c,v 1.17 2006/09/19 11:06:33 jsg Exp $	*/
d430 1
a430 1
	p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.17
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: vm86.c,v 1.16 2006/05/11 13:21:12 mickey Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.16
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: vm86.c,v 1.15 2003/01/09 22:27:09 miod Exp $	*/
d145 1
a145 3
is_bitset(nr, bitmap)
	int nr;
	caddr_t bitmap;
d164 1
a164 3
fast_intxx(p, intrno)
	struct proc *p;
	int intrno;
d233 1
a233 3
vm86_return(p, retval)
	struct proc *p;
	int retval;
d271 1
a271 3
vm86_gpfault(p, type)
	struct proc *p;
	int type;
d378 1
a378 4
i386_vm86(p, args, retval)
	struct proc *p;
	char *args;
	register_t *retval;
@


1.15
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: vm86.c,v 1.14 2002/03/14 01:26:33 millert Exp $	*/
d181 1
a181 1
	/* 
d188 1
a188 1
	/* 
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vm86.c,v 1.13 2002/01/16 20:50:16 miod Exp $	*/
d153 1
a153 1
	byte = fubyte(bitmap);
d183 1
a183 1
	 * and don't deref it. is_revectored() above does fubyte() to
@


1.13
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: vm86.c,v 1.12 2001/07/04 08:57:48 niklas Exp $	*/
d73 2
a74 2
static void fast_intxx __P((struct proc *, int));
static __inline int is_bitset __P((int, caddr_t));
@


1.12
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: vm86.c,v 1.15 1996/05/03 19:42:33 christos Exp $	*/
a43 1
#include <sys/map.h>
@


1.12.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: vm86.c,v 1.13 2002/01/16 20:50:16 miod Exp $	*/
d44 1
@


1.12.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vm86.c,v 1.12.4.1 2002/01/31 22:55:11 niklas Exp $	*/
d73 2
a74 2
static void fast_intxx(struct proc *, int);
static __inline int is_bitset(int, caddr_t);
@


1.12.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d153 1
a153 1
	copyin(bitmap, &byte, sizeof(u_char));
d183 1
a183 1
	 * and don't deref it. is_revectored() above does copyin() to
@


1.11
log
@Do not include <sys/callout.h>, it is never needed; art@@
@
text
@d1 1
@


1.10
log
@please gcc 2.8
@
text
@a50 1
#include <sys/callout.h>
@


1.10.10.1
log
@Sync with -current
@
text
@d51 1
@


1.10.10.2
log
@Add $OpenBSD$.
@
text
@a0 1
/*	$OpenBSD$	*/
@


1.10.10.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vm86.c,v 1.10.10.2 2001/07/15 15:10:55 ho Exp $	*/
@


1.10.10.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
@


1.10.10.5
log
@Merge in -current from about a week ago
@
text
@d73 2
a74 2
static void fast_intxx(struct proc *, int);
static __inline int is_bitset(int, caddr_t);
@


1.10.10.6
log
@Sync the SMP branch with 3.3
@
text
@d153 1
a153 1
	copyin(bitmap, &byte, sizeof(u_char));
d183 1
a183 1
	 * and don't deref it. is_revectored() above does copyin() to
@


1.9
log
@add type & union sigval args to sendsig/trapsignal
@
text
@d242 1
d257 2
a258 1
	trapsignal(p, SIGURG, retval, 0, 0);
d283 2
d375 4
a378 2
	if (trace && tf->tf_eflags & PSL_VM)
		trapsignal(p, SIGTRAP, T_TRCTRAP, TRAP_TRACE, 0);
@


1.8
log
@add another parameter to trapsignal() and sendsig() -- fault addr to be
delivered with in the siginfo information
@
text
@d256 1
a256 1
	trapsignal(p, SIGURG, retval, 0);
d372 1
a372 1
		trapsignal(p, SIGTRAP, T_TRCTRAP, 0);
@


1.7
log
@clean & sync
@
text
@d256 1
a256 1
	trapsignal(p, SIGURG, retval);
d372 1
a372 1
		trapsignal(p, SIGTRAP, T_TRCTRAP);
@


1.6
log
@sync with 0504; prototype changes
@
text
@a0 1
/*	$OpenBSD: vm86.c,v 1.4 1996/04/21 22:16:42 deraadt Exp $	*/
d77 1
a77 3
#define	SETDIRECT	((~(PSL_USERSTATIC|PSL_NT)) & 0xffff)
#define	GETDIRECT	(SETDIRECT|0x02a) /* add in two MBZ bits */

d79 1
@


1.5
log
@sync with netbsd
@
text
@d2 1
a2 1
/*	$NetBSD: vm86.c,v 1.13 1996/04/25 13:50:21 mycroft Exp $	*/
d76 1
d147 1
a147 1
static __inline__ int
a181 1
	u_short cs;
d192 2
a193 3
	 * If coming from BIOS segment, or going to BIOS segment, or user
	 * requested special handling, return to user space with indication
	 * of which INT was requested.
d195 1
a195 2
	cs = CS(tf);
	if (cs == BIOSSEG || is_bitset(intrno, &u_vm86p->int_byuser[0]))
a212 3
	if (ihand.cs == BIOSSEG)
		goto vector;

a227 3
	/* disable further "hardware" interrupts, turn off any tracing. */
	tf->tf_eflags &= ~PSL_T;
	clr_vif(p);
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: vm86.c,v 1.3 1996/04/18 19:18:13 niklas Exp $	*/
/*	$NetBSD: vm86.c,v 1.9 1996/04/12 05:57:43 mycroft Exp $	*/
d272 1
d296 1
d298 1
a298 1
	u_long cs, ip, ss, sp;
d305 2
d334 5
d380 3
@


1.3
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD: vm86.c,v 1.2 1996/04/17 05:18:59 mickey Exp $	*/
/*	$NetBSD: vm86.c,v 1.8 1996/04/11 10:07:17 mycroft Exp $	*/
d77 3
a79 1
#define	CS(tf)		(*(u_short *)&tf->tf_cs)
a80 1
#define	SS(tf)		(*(u_short *)&tf->tf_ss)
d387 1
a387 1
	int err;
d389 3
a391 2
	if (err = copyin(args, &vm86s, sizeof(vm86s)))
		return err;
d403 1
a403 1
		pcb->vm86_flagmask = 0;
d406 1
a406 1
		pcb->vm86_flagmask = PSL_NT|PSL_IOPL;
d409 1
a409 1
		pcb->vm86_flagmask = PSL_AC|PSL_NT|PSL_IOPL;
d412 2
d415 1
a415 2
		pcb->vm86_flagmask = PSL_ID|PSL_AC|PSL_NT|PSL_IOPL;
		break;
@


1.2
log
@Cleanups & fixes from latest NetBSD primarily to run doscmd, etc.
GENERIC added to the compile/.cvsignore (it is used for 'make links'
for example), thus conf/GENERIC should appear magically ...
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@from netbsd; VM86 support, by John Kohl, touched up a bit by charles
@
text
@d1 2
a2 1
/*	$NetBSD: vm86.c,v 1.3 1996/01/08 22:23:35 mycroft Exp $	*/
d4 33
a36 25
/*
 *  Copyright (c) 1995 John T. Kohl
 *  All rights reserved.
 * 
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
a37 1
 * 
a74 1
static void return_to_32bit __P((struct proc *, int));
d77 1
a77 3
#define	SETDIRECT	((~(PSL_USERSTATIC|PSL_NT)) & 0xffff)
#define	GETDIRECT	(SETDIRECT|0x02a) /* add in two MBZ bits */

d79 1
a162 51
static __inline__ void
set_vif(p)
	struct proc *p;
{

	VM86_EFLAGS(p) |= PSL_VIF;
	if (VM86_EFLAGS(p) & PSL_VIP)
		return_to_32bit(p, VM86_STI);
}

static __inline__ void
set_vflags(p, flags)
	struct proc *p;
	int flags;
{
	struct trapframe *tf = p->p_md.md_regs;

	SETFLAGS(VM86_EFLAGS(p), flags, VM86_FLAGMASK(p));
	SETFLAGS(tf->tf_eflags, flags, SETDIRECT);
	if (flags & PSL_I)
		set_vif(p);
}

static __inline__ void
set_vflags_short(p, flags)
	struct proc *p;
	int flags;
{
	struct trapframe *tf = p->p_md.md_regs;

	SETFLAGS(VM86_EFLAGS(p), flags, VM86_FLAGMASK(p) & 0xffff);
	SETFLAGS(tf->tf_eflags, flags, SETDIRECT);
	if (flags & PSL_I)
		set_vif(p);
}

static __inline__ int
get_vflags(p)
	struct proc *p;
{
	struct trapframe *tf = p->p_md.md_regs;
	int flags = 0;

	SETFLAGS(flags, VM86_EFLAGS(p), VM86_FLAGMASK(p));
	SETFLAGS(flags, tf->tf_eflags, GETDIRECT);
	if (VM86_EFLAGS(p) & PSL_VIF)
		flags |= PSL_I;
	return (flags);
}


d195 1
a195 1
	cs = tf->tf_cs;
d221 1
a221 1
	ss = tf->tf_ss << 4;
d224 2
a225 2
	putword(ss, sp, get_vflags(p));
	putword(ss, sp, tf->tf_cs);
d230 1
a230 1
	tf->tf_cs = ihand.cs;
d233 2
a234 2
	VM86_EFLAGS(p) &= ~PSL_VIF;
	tf->tf_eflags &= ~PSL_VIF|PSL_T;
d238 1
a238 1
	return_to_32bit(p, VM86_MAKEVAL(VM86_INTx, intrno));
d242 1
a242 1
	return_to_32bit(p, VM86_UNKNOWN);
d246 2
a247 2
static void
return_to_32bit(p, retval)
d255 1
a255 1
	 * let sendsig() pull in the VM86_EFLAGS bits.
d297 1
a297 1
	cs = tf->tf_cs << 4;
d299 1
a299 1
	ss = tf->tf_ss << 4;
d304 1
a304 1
	 * macros/functions which might do a return_to_32bit.
d311 1
a311 2
		VM86_EFLAGS(p) &= ~PSL_VIF;
		tf->tf_eflags &= ~PSL_VIF;
d330 1
a330 1
		putword(ss, sp, get_vflags(p));
d336 1
a336 1
		tf->tf_cs = getword(ss, sp);
d347 1
a347 1
			putdword(ss, sp, get_vflags(p));
d353 1
a353 1
			tf->tf_cs = getdword(ss, sp);
d355 1
a355 1
			set_vflags(p, getdword(ss, sp));
d373 1
a373 1
	return_to_32bit(p, VM86_UNKNOWN);
d384 1
d391 23
a413 1
	p->p_addr->u_pcb.vm86_userp = (void *)args;
d437 2
a438 25
	SETFLAGS(VM86_EFLAGS(p), vm86s.regs.vmsc.sc_eflags, VM86_FLAGMASK(p)|PSL_VIF);
	SETFLAGS(tf->tf_eflags, vm86s.regs.vmsc.sc_eflags, SETDIRECT);
	tf->tf_eflags |= PSL_VM;

	/*
	 * Keep mask of flags we simulate to simulate a particular type of
	 * processor.
	 */
	switch (vm86s.ss_cpu_type) {
	case VCPU_086:
	case VCPU_186:
	case VCPU_286:
		VM86_FLAGMASK(p) = 0;
		break;
	case VCPU_386:
		VM86_FLAGMASK(p) = PSL_NT|PSL_IOPL;
		break;
	case VCPU_486:
		VM86_FLAGMASK(p) = PSL_AC|PSL_NT|PSL_IOPL;
		break;
	case VCPU_586:
	default:
		VM86_FLAGMASK(p) = PSL_ID|PSL_AC|PSL_NT|PSL_IOPL;
		break;
	}
d440 1
a440 2
	/* Going into vm86 mode jumps off the signal stack. */
	p->p_sigacts->ps_sigstk.ss_flags &= ~SA_ONSTACK;
@

