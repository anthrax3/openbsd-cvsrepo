head	1.57;
access;
symbols
	OPENBSD_6_2_BASE:1.57
	OPENBSD_6_1:1.57.0.4
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.54.0.4
	OPENBSD_6_0_BASE:1.54
	OPENBSD_5_9:1.54.0.2
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.52.0.4
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.50.0.6
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.50.0.10
	OPENBSD_5_6_BASE:1.50
	OPENBSD_5_5:1.50.0.8
	OPENBSD_5_5_BASE:1.50
	OPENBSD_5_4:1.50.0.4
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.50.0.2
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.48.0.8
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.6
	OPENBSD_5_0:1.48.0.4
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.48.0.2
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.47.0.4
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.45.0.4
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.42.0.2
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.40.0.2
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.38.0.2
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.10
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.8
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.6
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.15
	UBC:1.14.0.16
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.14
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.14.0.12
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.14.0.10
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.8
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.6
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.4
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.13.0.4
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.57
date	2017.03.25.22.24.01;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	0BdiEUSnzOoly0V9;

1.56
date	2016.10.21.06.20.58;	author mlarkin;	state Exp;
branches;
next	1.55;
commitid	szRuKZ9HgqvwYLcM;

1.55
date	2016.07.28.21.57.56;	author kettenis;	state Exp;
branches;
next	1.54;
commitid	h0GHFDGWnEdswfbK;

1.54
date	2015.12.12.12.33.49;	author reyk;	state Exp;
branches;
next	1.53;
commitid	BGb3xaQZJ9ACCtNF;

1.53
date	2015.08.20.04.41.46;	author mlarkin;	state Exp;
branches;
next	1.52;
commitid	eoSwLmCZ9T7CGJzs;

1.52
date	2015.07.23.06.21.37;	author reyk;	state Exp;
branches;
next	1.51;
commitid	B8gdYj4HofAJDgCP;

1.51
date	2015.07.21.03.38.22;	author reyk;	state Exp;
branches;
next	1.50;
commitid	t8p39jbat5DBrbFu;

1.50
date	2012.10.04.08.32.20;	author ehrhardt;	state Exp;
branches;
next	1.49;

1.49
date	2012.09.19.23.03.12;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2010.11.03.10.15.23;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2009.11.23.22.57.38;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2009.11.23.15.21.05;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2009.04.11.17.13.32;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2009.03.31.21.57.57;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2009.01.13.13.53.50;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2008.07.08.05.22.00;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2008.06.18.20.15.54;	author mbalmer;	state Exp;
branches;
next	1.40;

1.40
date	2008.01.13.22.29.01;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2007.12.05.19.17.13;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.29.21.01.56;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.09.23.13.16;	author todd;	state Exp;
branches;
next	1.36;

1.36
date	2007.04.21.21.06.14;	author gwk;	state Exp;
branches;
next	1.35;

1.35
date	2007.03.19.14.33.28;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2007.03.19.03.02.09;	author marco;	state Exp;
branches;
next	1.33;

1.33
date	2007.02.13.12.52.07;	author dim;	state Exp;
branches;
next	1.32;

1.32
date	2007.01.31.23.30.51;	author gwk;	state Exp;
branches;
next	1.31;

1.31
date	2006.12.14.17.36.12;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2006.11.29.20.03.19;	author dim;	state Exp;
branches;
next	1.29;

1.29
date	2006.11.28.15.24.08;	author dim;	state Exp;
branches;
next	1.28;

1.28
date	2006.11.27.18.04.28;	author gwk;	state Exp;
branches;
next	1.27;

1.27
date	2006.10.18.20.59.51;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.14.21.26.18;	author marco;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.13.20.10.49;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.13.15.40.37;	author marco;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.19.03.50.44;	author marco;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.18.05.09.23;	author marco;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.28.19.59.25;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.21.17.24.26;	author jordan;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.18.23.08.24;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.04.22.04.23;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.02.20.09.39;	author tholo;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.02.19.17.32.39;	author art;	state Exp;
branches
	1.14.6.1
	1.14.16.1;
next	1.13;

1.13
date	98.01.20.18.40.15;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.12.25.06.09.52;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	97.12.24.09.44.18;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	97.09.29.03.42.27;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.09.21.04.27.56;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.11.28.23.37.37;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.11.23.21.45.49;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.11.12.20.29.57;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.05.30.09.30.08;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.07.07.21.47;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.29.14.13.25;	author hvozda;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.22.16.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.04.18.19.18.11;	author niklas;	state Exp;
branches;
next	;

1.14.6.1
date	2000.02.20.10.30.44;	author niklas;	state Exp;
branches;
next	1.14.6.2;

1.14.6.2
date	2000.02.21.21.42.59;	author niklas;	state Exp;
branches;
next	1.14.6.3;

1.14.6.3
date	2000.07.03.14.19.07;	author niklas;	state Exp;
branches;
next	1.14.6.4;

1.14.6.4
date	2001.07.14.10.02.28;	author ho;	state Exp;
branches;
next	1.14.6.5;

1.14.6.5
date	2001.07.15.12.01.11;	author niklas;	state Exp;
branches;
next	1.14.6.6;

1.14.6.6
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	;

1.14.16.1
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Split vmm_probe() into a vmm_enabled() function, to better follow the
probe/attach approach used by mainbus.
ok mlarkin kettenis
@
text
@/*	$OpenBSD: mainbus.c,v 1.56 2016/10/21 06:20:58 mlarkin Exp $	*/
/*	$NetBSD: mainbus.c,v 1.21 1997/06/06 23:14:20 thorpej Exp $	*/

/*
 * Copyright (c) 1996 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/specialreg.h>

#include <dev/isa/isavar.h>
#include <dev/eisa/eisavar.h>
#include <dev/pci/pcivar.h>

#include <dev/isa/isareg.h>		/* for ISA_HOLE_VADDR */
#include <i386/isa/isa_machdep.h>

#include "pci.h"
#include "eisa.h"
#include "isa.h"
#include "apm.h"
#include "bios.h"
#include "acpi.h"
#include "ipmi.h"
#include "esm.h"
#include "amdmsr.h"
#include "vmm.h"
#include "pvbus.h"

#include <machine/cpuvar.h>
#include <machine/i82093var.h>

#if NBIOS > 0
#include <machine/biosvar.h>
#endif

#include <dev/acpi/acpivar.h>

#if NIPMI > 0
#include <dev/ipmivar.h>
#endif

#if NPVBUS > 0
#include <dev/pv/pvvar.h>
#endif

#if NAMDMSR > 0
#include <machine/amdmsr.h>
#endif

#if NESM > 0
#include <arch/i386/i386/esmvar.h>
#endif

int	mainbus_match(struct device *, void *, void *);
void	mainbus_attach(struct device *, struct device *, void *);

struct cfattach mainbus_ca = {
	sizeof(struct device), mainbus_match, mainbus_attach, NULL,
	config_activate_children
};

struct cfdriver mainbus_cd = {
	NULL, "mainbus", DV_DULL
};

int	mainbus_print(void *, const char *);

union mainbus_attach_args {
	const char *mba_busname;		/* first elem of all */
	struct pcibus_attach_args mba_pba;
	struct eisabus_attach_args mba_eba;
	struct isabus_attach_args mba_iba;
#if NBIOS > 0
	struct bios_attach_args mba_bios;
#endif
	struct cpu_attach_args mba_caa;
	struct apic_attach_args	aaa_caa;
#if NIPMI > 0
	struct ipmi_attach_args mba_iaa;
#endif
#if NESM > 0
	struct esm_attach_args mba_eaa;
#endif
#if NPVBUS > 0
	struct pvbus_attach_args mba_pvba;
#endif
};

/*
 * This is set when the ISA bus is attached.  If it's not set by the
 * time it's checked below, then mainbus attempts to attach an ISA.
 */
int     isa_has_been_seen;

/*
 * Probe for the mainbus; always succeeds.
 */
int
mainbus_match(struct device *parent, void *match, void *aux)
{
	return (1);
}

/*
 * Attach the mainbus.
 */
void
mainbus_attach(struct device *parent, struct device *self, void *aux)
{
#if NVMM > 0
	extern int vmm_enabled(void);
#endif
	union mainbus_attach_args	mba;
	extern void			(*setperf_setup)(struct cpu_info *);
	extern void			(*cpusensors_setup)(struct cpu_info *);

	printf("\n");

#if NPVBUS > 0
	/* Detect hypervisors early, attach the paravirtual bus later */
	if (cpu_ecxfeature & CPUIDECX_HV)
		pvbus_identify();
#endif

#if NBIOS > 0
	{
		mba.mba_bios.ba_name = "bios";
		mba.mba_bios.ba_iot = I386_BUS_SPACE_IO;
		mba.mba_bios.ba_memt = I386_BUS_SPACE_MEM;
		config_found(self, &mba.mba_bios, mainbus_print);
	}
#endif

#if NIPMI > 0
	{
		memset(&mba.mba_iaa, 0, sizeof(mba.mba_iaa));
		mba.mba_iaa.iaa_name = "ipmi";
		mba.mba_iaa.iaa_iot  = I386_BUS_SPACE_IO;
		mba.mba_iaa.iaa_memt = I386_BUS_SPACE_MEM;
		if (ipmi_probe(&mba.mba_iaa))
			config_found(self, &mba.mba_iaa, mainbus_print);
	}
#endif

	if ((cpu_info_primary.ci_flags & CPUF_PRESENT) == 0) {
		struct cpu_attach_args caa;

		memset(&caa, 0, sizeof(caa));
		caa.caa_name = "cpu";
		caa.cpu_apicid = 0;
		caa.cpu_role = CPU_ROLE_SP;
		caa.cpu_func = 0;
		caa.cpu_signature = cpu_id;
		caa.feature_flags = cpu_feature;

		config_found(self, &caa, mainbus_print);
	}
#if NAMDMSR > 0
	if (amdmsr_probe()) {
		mba.mba_busname = "amdmsr";
		config_found(self, &mba.mba_busname, mainbus_print);
	}
#endif

#if NACPI > 0
	if (!acpi_hasprocfvs)
#endif
	{
		if (setperf_setup != NULL)
			setperf_setup(&cpu_info_primary);
	}

#ifdef MULTIPROCESSOR
	mp_setperf_init();
#endif

	if (cpusensors_setup != NULL)
		cpusensors_setup(&cpu_info_primary);

#if NESM > 0
	{
		memset(&mba.mba_eaa, 0, sizeof(mba.mba_eaa));
		mba.mba_eaa.eaa_name = "esm";
		mba.mba_eaa.eaa_iot  = I386_BUS_SPACE_IO;
		mba.mba_eaa.eaa_memt = I386_BUS_SPACE_MEM;
		if (esm_probe(&mba.mba_eaa))
			config_found(self, &mba.mba_eaa, mainbus_print);
	}
#endif

#if NPVBUS > 0
	/* Probe first to hide the "not configured" message */
	if (pvbus_probe()) {
		mba.mba_pvba.pvba_busname = "pvbus";
		config_found(self, &mba.mba_pvba.pvba_busname, mainbus_print);
	}
#endif

	/*
	 * XXX Note also that the presence of a PCI bus should
	 * XXX _always_ be checked, and if present the bus should be
	 * XXX 'found'.  However, because of the structure of the code,
	 * XXX that's not currently possible.
	 */
#if NPCI > 0
	if (pci_mode_detect() != 0) {
		pci_init_extents();
		
		bzero(&mba.mba_pba, sizeof(mba.mba_pba));
		mba.mba_pba.pba_busname = "pci";
		mba.mba_pba.pba_iot = I386_BUS_SPACE_IO;
		mba.mba_pba.pba_memt = I386_BUS_SPACE_MEM;
		mba.mba_pba.pba_dmat = &pci_bus_dma_tag;
		mba.mba_pba.pba_ioex = pciio_ex;
		mba.mba_pba.pba_memex = pcimem_ex;
		mba.mba_pba.pba_busex = pcibus_ex;
		mba.mba_pba.pba_domain = pci_ndomains++;
		mba.mba_pba.pba_bus = 0;
		config_found(self, &mba.mba_pba, mainbus_print);
#if NACPI > 0
		acpi_pciroots_attach(self, &mba.mba_pba, mainbus_print);
#endif
	}
#endif

	if (!bcmp(ISA_HOLE_VADDR(EISA_ID_PADDR), EISA_ID, EISA_ID_LEN)) {
		mba.mba_eba.eba_busname = "eisa";
		mba.mba_eba.eba_iot = I386_BUS_SPACE_IO;
		mba.mba_eba.eba_memt = I386_BUS_SPACE_MEM;
#if NEISA > 0
		mba.mba_eba.eba_dmat = &eisa_bus_dma_tag;
#endif
		config_found(self, &mba.mba_eba, mainbus_print);
	}

	if (isa_has_been_seen == 0) {
		mba.mba_iba.iba_busname = "isa";
		mba.mba_iba.iba_iot = I386_BUS_SPACE_IO;
		mba.mba_iba.iba_memt = I386_BUS_SPACE_MEM;
#if NISADMA > 0
		mba.mba_iba.iba_dmat = &isa_bus_dma_tag;
#endif
		config_found(self, &mba.mba_iba, mainbus_print);
	}

#if NVMM > 0
	if (vmm_enabled()) {
		mba.mba_busname = "vmm";
		config_found(self, &mba.mba_busname, mainbus_print);
	}
#endif /* NVMM > 0 */
}

int
mainbus_print(void *aux, const char *pnp)
{
	union mainbus_attach_args	*mba = aux;

	if (pnp)
		printf("%s at %s", mba->mba_busname, pnp);
	if (!strcmp(mba->mba_busname, "pci"))
		printf(" bus %d", mba->mba_pba.pba_bus);

	return (UNCONF);
}
@


1.56
log
@
vmm(4) for i386. Userland changes forthcoming. Note that for the time being,
i386 hosts are limited to running only i386 guests, even if the underlying
hardware supports amd64. This is a restriction I hope to lift moving forward,
but for now please don't report problems running amd64 guests on i386 hosts.

This was a straightforward port of the in-tree amd64 code plus the old rotted
tree I had from last year for i386 support. Changes included converting 64-bit
VMREAD/VMWRITE ops to 2x32-bit ops, and fixing treatment of the TSS, which
differs on i386.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.55 2016/07/28 21:57:56 kettenis Exp $	*/
d141 3
d278 4
a281 2
	mba.mba_busname = "vmm";
	config_found(self, &mba.mba_busname, mainbus_print);
@


1.55
log
@Store the acpi processor ID/UID in struct cpu_info, and use it to attach
acpicpu(4) drivers to the right cpu(4).

ok mlarkin@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.54 2015/12/12 12:33:49 reyk Exp $	*/
d57 1
d273 5
@


1.54
log
@Identify hypervisors before configuring other children of the mainbus
(bios, CPU, interrupt handlers, pvbus).  This splits the pvbus attach
function into two parts: pvbus_identify() to scan the CPUID registers
for supported hypervisors and pvbus_attach() to attach the bus, print
information, and configure the children.

This will be needed for Xen and KVM, as discussed with mikeb@@ and sf@@
OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.53 2015/08/20 04:41:46 mlarkin Exp $	*/
d177 1
a177 1
		caa.cpu_number = 0;
@


1.53
log
@
remove unused vesafb code, had been commented out and not compiled in for
7 years (for some parts, 9 years), and was only ever referenced in i386
anyway.

ok jsg@@, matthieu@@, armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.52 2015/07/23 06:21:37 reyk Exp $	*/
d39 1
d145 6
@


1.52
log
@Attach pvbus(4) later just before pci(4).  Same change was done for amd64.
Tested on VMware-GENERIC-i386.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.51 2015/07/21 03:38:22 reyk Exp $	*/
a54 1
#include "vesabios.h"
a82 4
#if NVESABIOS > 0
#include <dev/vesa/vesabiosvar.h>
#endif

a198 7

#if NVESABIOS > 0
	if (vbeprobe())	{
		mba.mba_busname = "vesabios";
		config_found(self, &mba.mba_busname, NULL);
	}
#endif
@


1.51
log
@Add pvbus(4), a pseudo-bus to attach non-PCI paravirtual devices and buses.
vmt(4) is moved from mainbus0 to pvbus0, more devices will follow.

OK sf@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.50 2012/10/04 08:32:20 ehrhardt Exp $	*/
a169 8
#if NPVBUS > 0
	/* Probe first to hide the "not configured" message */
	if (pvbus_probe()) {
		mba.mba_pvba.pvba_busname = "pvbus";
		config_found(self, &mba.mba_pvba.pvba_busname, mainbus_print);
	}
#endif

d220 8
@


1.50
log
@Use information provided by ACPI to attach secondary PCI host bridges.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.49 2012/09/19 23:03:12 kettenis Exp $	*/
a54 1
#include "vmt.h"
d57 1
d72 2
a73 2
#if NVMT > 0
#include <dev/vmtvar.h>
d118 3
d170 5
a174 4
#if NVMT > 0
	if (vmt_probe()) {
		mba.mba_busname = "vmt";
		config_found(self, &mba.mba_busname, mainbus_print);
@


1.49
log
@Set up PCI bus number resource accounting for the main PCI bus hierarchy.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.48 2010/11/03 10:15:23 dlg Exp $	*/
d248 3
@


1.48
log
@only let vmt match and therefore attach if mainbus is specifically asking
for vmt to attach after vmt_probe succeeds. this prevents vmt from
appearing at other attach points hanging off mainbus.

found by phessler@@ and debugged gently by claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.47 2009/11/23 22:57:38 deraadt Exp $	*/
d244 1
@


1.47
log
@diffable against amd64
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.46 2009/11/23 15:21:05 deraadt Exp $	*/
d169 1
a169 1
		mba.mba_busname = "vmware";
@


1.46
log
@Use config_activate_children() for our cf_activate function
ok mlarkin pirofti
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.45 2009/04/11 17:13:32 kettenis Exp $	*/
d92 2
a93 2
	sizeof(struct device), mainbus_match, mainbus_attach,
	NULL, config_activate_children
@


1.45
log
@Create extents for resource accounting on the root PCI bus and populate them
based on the BIOS memory map.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.44 2009/03/31 21:57:57 kettenis Exp $	*/
d92 2
a93 1
	sizeof(struct device), mainbus_match, mainbus_attach
@


1.44
log
@bzero pci attach args
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.43 2009/01/13 13:53:50 kettenis Exp $	*/
d234 2
d241 2
@


1.43
log
@Turn mpbios into a real device, such that people can disable it on crappy
BIOSes.

ok deraadt@@ (for the amd64 bit, or the i386 bit, can't remember which)
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.42 2008/07/08 05:22:00 dlg Exp $	*/
d234 1
a240 1
		mba.mba_pba.pba_bridgetag = NULL;
@


1.42
log
@vmt(4) is a kernel level implementation of the vmware tools.

it only provides the hosts machines clock as a timedelta sensor so far.

getting it into the tree so people can work on it as suggested by fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.40 2008/01/13 22:29:01 kettenis Exp $	*/
a51 1
#include "mpbios.h"
a60 1
#include <machine/mpbiosvar.h>
a170 5
#endif

#if NMPBIOS > 0
	if (mpbios_probe(self))
		mpbios_scan(self);
@


1.41
log
@Attach amdmsr(4) at mainbus in a way that it can be disabled in UKC or the
config file, only configure the driver when we have an AMD Geode LX
CPU and the graphics processor is available.

mainbus part by miod, ok miod, matthieu
@
text
@d56 1
d74 4
d165 7
@


1.40
log
@Kill <machine/mp.h>.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.39 2007/12/05 19:17:13 deraadt Exp $	*/
d57 1
d73 4
d181 6
@


1.39
log
@Hang acpi(4) below bios(4) instead of mainbus(4).  This lets us move acpi(4)
before pcibios(4), and then.... if acpi(4) attaches, skip pcibios(4) since
it messes the machines up.  Fixes claudio's HP dl320 G5, and almost assuredly
others.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.38 2007/05/29 21:01:56 tedu Exp $	*/
a79 6
#if 0
#ifdef SMP /* XXX MULTIPROCESSOR */
#include <machine/mp.h>
#endif
#endif

a196 15
#endif

#if 0
#ifdef SMP
	if (bios_smpinfo != NULL) {
		struct mp_float *mp = bios_smpinfo;

		printf("%s: MP 1.%d configuration %d\n", self->dv_xname,
		    mp->revision, mp->feature1);
	}
#ifdef CPU_DEBUG
	else
		printf ("%s: No MP configuration found.", self->dv_xname);
#endif
#endif
@


1.38
log
@add support for core cpu temperature sensors.
from a diff by pierre riteau, but updated to look like the amd64 version
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.37 2007/05/09 23:13:16 todd Exp $	*/
a65 2
#if NACPI > 0
#include <dev/acpi/acpireg.h>
a66 1
#endif
a108 3
#if NACPI > 0
	struct acpi_attach_args mba_aaa;
#endif
d146 3
a148 3
		mba.mba_bios.bios_dev = "bios";
		mba.mba_bios.bios_iot = I386_BUS_SPACE_IO;
		mba.mba_bios.bios_memt = I386_BUS_SPACE_MEM;
a149 14
	}
#endif
#if NACPI > 0
#if NPCI > 0
	if (pci_mode_detect() != 0)
#endif
	{
		memset(&mba.mba_aaa, 0, sizeof(mba.mba_aaa));
		mba.mba_aaa.aaa_name = "acpi";
		mba.mba_aaa.aaa_iot = I386_BUS_SPACE_IO;
		mba.mba_aaa.aaa_memt = I386_BUS_SPACE_MEM;

		if (acpi_probe(self, aux, &mba.mba_aaa))
			config_found(self, &mba.mba_aaa, mainbus_print);
@


1.37
log
@remove 'struct sr_attach_args' as it's now elsewhere with softraid defined
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.36 2007/04/21 21:06:14 gwk Exp $	*/
d146 1
d214 3
@


1.36
log
@Introduce a smp aware hw.setperf mechanism, it will scale all CPUs or
cores by the same amount, i.e. if you do hw.setperf=50 both cores will
be scaled to the opearting state corresponing to 50%. Tested by many with
est (mainly on core2duo machines like X60 thinkpads). Only enable est
during GENERIC.MP build no one tested powernow.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.35 2007/03/19 14:33:28 dlg Exp $	*/
a119 3
#endif
#if NSOFTRAID > 0
	struct sr_attach_args mba_maa;
@


1.35
log
@attach softraid to the root of the device tree in a machine independant
way, rather than requiring some glue in each machines mainbus probe.

it is still commented out.

based on a discussion with miod@@ ok marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.34 2007/03/19 03:02:09 marco Exp $	*/
d212 4
@


1.34
log
@Add a new device that provides a framework for IO manipulation.  A very basic
implementation of a RAID 1 is included in this but it does not deal with
failures yet.  Disabled in GENERIC.

Suggestions from and ok beck@@ miod@@ krw@@ dlg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.33 2007/02/13 12:52:07 dim Exp $	*/
a55 1
#include "softraid.h"
a78 4
#if NSOFTRAID > 0
#include <dev/softraidvar.h>
#endif

a283 6

#if NSOFTRAID > 0
	memset(&mba.mba_maa, 0, sizeof(mba.mba_maa));
	mba.mba_maa.maa_name = "softraid";
	config_found(self, &mba.mba_maa, mainbus_print);
#endif
@


1.33
log
@Zap unused local acpi_attached variable, since it has been superseded
by acpi_hasprocfvs.

ok gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.32 2007/01/31 23:30:51 gwk Exp $	*/
d56 1
d80 4
d126 3
d289 6
@


1.32
log
@Introduce acpi_hasprocfvs thats "ACPI Has Processor Frequency and Voltage
Scalling" a global flag set by acicpu attach to indicate that ACPI is
handling fvs through the _PSS objects. This will fix disappearing
EST/powernow when booting kernels with acpi enabled, as acpicpu isnt
compiled into GENERIC yet. Also in cases where acpicpu is built in and
legacy EST/powernow work but acpi is missing the _PSS object, the legacy
routines will be used.

tested by dim@@, and Nick Nauwelaerts <nick AT nauwelaerts.net>
ok marco@@, dim@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.31 2006/12/14 17:36:12 kettenis Exp $	*/
a144 3
#if NACPI > 0
	int				acpi_attached = 0;
#endif
d167 2
a168 3
		if (acpi_probe(self, aux, &mba.mba_aaa) &&
		    config_found(self, &mba.mba_aaa, mainbus_print) != NULL)
			acpi_attached = 1;
@


1.31
log
@Make pci subsystem aware of domains.  Each host bridge gets assigned a unique
domain number such that we can distinguish between busses with the same bus
number that are behind different host bridges.  Domains can be accessed by
using different device nodes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.30 2006/11/29 20:03:19 dim Exp $	*/
d207 1
a207 1
	if (!acpi_attached)
d215 1
a215 1
        if (vbeprobe())	{
@


1.30
log
@Remove all the extern cpu_{id,model,whatever} declarations from most
stuff in arch/i386/i386.  This should prevent more screwups like the
one I did before in ichpcib.c...

ok dlg@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.29 2006/11/28 15:24:08 dim Exp $	*/
d259 1
@


1.29
log
@Only use est and other non-acpi setperf mechanisms, if acpi is not
attached.  Also moves their initialization and printing of
information until after the primary cpu has attached to mainbus.

prodded by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.28 2006/11/27 18:04:28 gwk Exp $	*/
a148 1
	extern int			cpu_id, cpu_feature;
@


1.28
log
@commit vesabios for matthieu@@
ok deraadt, "slap it in" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.27 2006/10/18 20:59:51 kettenis Exp $	*/
d145 4
d171 3
a173 2
		if (acpi_probe(self, aux, &mba.mba_aaa))
			config_found(self, &mba.mba_aaa, mainbus_print);
d176 1
d205 8
@


1.27
log
@Decide whether we need to attach the primary cpu by checking the CPUF_PRESENT
flag.

tested by ckuethe@@, ok deraadt@@, gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.26 2006/04/14 21:26:18 marco Exp $	*/
d56 1
d79 4
d200 7
@


1.26
log
@ANSIfy function names.
Spacing.
KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.25 2006/03/13 20:10:49 brad Exp $	*/
a179 1
	else
d181 2
a182 1
	{
d184 1
a184 1
		
@


1.25
log
@* Add "pcitag_t *pba_bridgetag" to pci_attach_args.  This is set to
  NULL for root PCI busses.  For busses behind a bridge, it points to
  a persistent copy of the bridge's pcitag_t.  This can be very useful
  for machine-dependent PCI bus enumeration code.

From NetBSD

ok grange@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.24 2006/03/13 15:40:37 marco Exp $	*/
d128 1
a128 3
mainbus_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d130 1
a130 2

	return 1;
d137 1
a137 3
mainbus_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d139 2
a140 2
	union mainbus_attach_args mba;
	extern int cpu_id, cpu_feature;
d262 1
a262 3
mainbus_print(aux, pnp)
	void *aux;
	const char *pnp;
d264 1
a264 1
	union mainbus_attach_args *mba = aux;
d270 1
@


1.24
log
@Fix machines that need PCI access during ACPI bringup.
Inspired by gklok@@cogeco.ca.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.23 2006/01/19 03:50:44 marco Exp $	*/
d240 1
@


1.23
log
@Flip BIOS and ACPI around since ACPI uses BIOS stuff.

ok dlg@@ grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.22 2006/01/18 05:09:23 marco Exp $	*/
d158 3
@


1.22
log
@Silence acpi during dmesg if it isnt there.

tested by todd
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.21 2005/11/28 19:59:25 deraadt Exp $	*/
d149 8
a165 8
	}
#endif
#if NBIOS > 0
	{
		mba.mba_bios.bios_dev = "bios";
		mba.mba_bios.bios_iot = I386_BUS_SPACE_IO;
		mba.mba_bios.bios_memt = I386_BUS_SPACE_MEM;
		config_found(self, &mba.mba_bios, mainbus_print);
@


1.21
log
@probe before match; ok jordan marco
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.20 2005/11/21 17:24:26 jordan Exp $	*/
d156 2
a157 1
		config_found(self, &mba.mba_aaa, mainbus_print);
@


1.20
log
@Add ESM support glue but keep it disabled for now.

ok dlg@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.19 2005/10/18 23:08:24 marco Exp $	*/
d218 2
a219 1
		config_found(self, &mba.mba_eaa, mainbus_print);
@


1.19
log
@Scan SMBIOS before calling config_attach() to prevent unnecessary kernel print.

Written with jordan@@ help.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.18 2005/10/04 22:04:23 marco Exp $	*/
d55 1
d74 4
d113 3
d210 10
@


1.18
log
@Add initial IPMI implementation.  Currently only KCS retrieval method is
supported.  SMIC and BMC will follow shortly.

Code written by Jordan Hargrave <jordan underscore hargrave at hotmail dot com>

help grange@@ and deraadt@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.17 2005/06/02 20:09:39 tholo Exp $	*/
d165 2
a166 1
		config_found(self, &mba.mba_iaa, mainbus_print);
@


1.17
log
@Start on a basic ACPI framework -- does not do much more than read out the
ACPI tables into kernel memory and attach ACPI and HPET timers currently.

In order to test this code, enabling the devices in GENERIC as well as
the ACPI_ENABLE option is needed.  This code does not do any thermal
control yet, so this should be done with care depending on the platform.

In the tree so more people can contribute to making this more fully
featured.

Ok niklas@@ grange@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.16 2004/06/13 21:49:15 niklas Exp $	*/
d54 1
d69 4
d105 3
d157 9
@


1.16
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 1
d63 5
d97 3
d133 10
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.14 1999/02/19 17:32:39 art Exp $	*/
d52 5
d62 6
d89 2
d120 1
d131 34
@


1.14
log
@This should be NISADMA, not NISA.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.13 1998/01/20 18:40:15 niklas Exp $	*/
d57 2
a58 2
int	mainbus_match __P((struct device *, void *, void *));
void	mainbus_attach __P((struct device *, struct device *, void *));
d68 1
a68 1
int	mainbus_print __P((void *, const char *));
@


1.14.16.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.14 1999/02/19 17:32:39 art Exp $	*/
d57 2
a58 2
int	mainbus_match(struct device *, void *, void *);
void	mainbus_attach(struct device *, struct device *, void *);
d68 1
a68 1
int	mainbus_print(void *, const char *);
@


1.14.6.1
log
@Get MP info from /boot
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.14 1999/02/19 17:32:39 art Exp $	*/
a55 3
#ifdef SMP
#include <machine/mp.h>
#endif
a115 9
	}
#endif

#ifdef SMP
	if (bios_smpinfo != NULL) {
		struct mp_float *mp = bios_smpinfo;

		printf("%s: MP 1.%d configuration %d\n", mba.mba_busname,
		    mp->revision, mp->feature1);
@


1.14.6.2
log
@Wrong name used
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.14.6.1 2000/02/20 10:30:44 niklas Exp $	*/
d126 1
a126 1
		printf("%s: MP 1.%d configuration %d\n", self->dv_xname,
@


1.14.6.3
log
@use MULTIPROCESSOR instead of SMP as the define to get MP stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.14.6.2 2000/02/21 21:42:59 niklas Exp $	*/
d56 1
a56 1
#ifdef MULTIPROCESSOR
d122 1
a122 1
#ifdef MULTIPROCESSOR
@


1.14.6.4
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.14.6.3 2000/07/03 14:19:07 niklas Exp $	*/
a51 5
#include "mpbios.h"

#include <machine/cpuvar.h>
#include <machine/i82093var.h>
#include <machine/mpbiosvar.h>
d56 1
a56 3

#if 0
#ifdef SMP /* XXX MULTIPROCESSOR */
a58 1
#endif
a80 2
	struct cpu_attach_args mba_caa;
	struct apic_attach_args	aaa_caa;
a109 1
	extern int cpu_id, cpu_feature;
d122 1
a122 21
#if NMBIOS > 0
	if (mpbios_probe(self))
		mpbios_scan(self);
	else
#endif
	{
		struct cpu_attach_args caa;
		
		memset(&caa, 0, sizeof(caa));
		caa.caa_name = "cpu";
		caa.cpu_number = 0;
		caa.cpu_role = CPU_ROLE_SP;
		caa.cpu_func = 0;
		caa.cpu_signature = cpu_id;
		caa.feature_flags = cpu_feature;

		config_found(self, &caa, mainbus_print);
	}

#if 0
#ifdef SMP
a128 5
#ifdef CPU_DEBUG
	else
		printf ("%s: No MP configuration found.", self->dv_xname);
#endif
#endif
@


1.14.6.5
log
@typo preventing MP probing
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d133 1
a133 1
#if NMPBIOS > 0
@


1.14.6.6
log
@Merge in -current from about a week ago
@
text
@d68 2
a69 2
int	mainbus_match(struct device *, void *, void *);
void	mainbus_attach(struct device *, struct device *, void *);
d79 1
a79 1
int	mainbus_print(void *, const char *);
@


1.13
log
@Merge bus_dma support from NetBSD, mostly by Jason Thorpe.  Only i386 uses it
 so far, the other archs gets placeholders for now.  I wrote a compatibility
layer for OpenBSD's old isadma code so we can still use our old
driver sources.  They will however get changed to native bus_dma use,
on a case by case basis.   Oh yes, I almost forgot, I kept our notion
of isadma being a device so DMA-less ISA-busses still work
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.12 1997/12/25 06:09:52 downsj Exp $	*/
d150 1
a150 1
#if NISA > 0
@


1.12
log
@isa_has_been_seen; NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: mainbus.c,v 1.11 1997/12/24 09:44:18 downsj Exp $	*/
/*	$NetBSD: mainbus.c,v 1.8 1996/04/11 22:13:37 cgd Exp $	*/
d48 2
d130 1
d140 3
d150 3
@


1.11
log
@Reverse mainbus probe order.  Now we get to fix whatever breaks...
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.10 1997/09/29 03:42:27 mickey Exp $	*/
d79 6
d140 1
a140 1
	if (1 /* XXX ISA NOT YET SEEN */) {
@


1.10
log
@apm0 at bios0
configs will be updated
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.9 1997/09/21 04:27:56 mickey Exp $	*/
a109 13
	if (1 /* XXX ISA NOT YET SEEN */) {
		mba.mba_iba.iba_busname = "isa";
		mba.mba_iba.iba_iot = I386_BUS_SPACE_IO;
		mba.mba_iba.iba_memt = I386_BUS_SPACE_MEM;
		config_found(self, &mba.mba_iba, mainbus_print);
	}

	if (!bcmp(ISA_HOLE_VADDR(EISA_ID_PADDR), EISA_ID, EISA_ID_LEN)) {
		mba.mba_eba.eba_busname = "eisa";
		mba.mba_eba.eba_iot = I386_BUS_SPACE_IO;
		mba.mba_eba.eba_memt = I386_BUS_SPACE_MEM;
		config_found(self, &mba.mba_eba, mainbus_print);
	}
d126 14
@


1.9
log
@support new boots
add to your config:
bios0 at mainbus0
apm0 at mainbus0	# (if you are using APM)
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.8 1996/11/28 23:37:37 niklas Exp $	*/
a50 3
#if NAPM > 0
#include <machine/apmvar.h>
#endif
a72 3
#if NAPM > 0
	struct apm_attach_args mba_aaa;
#endif
d104 1
a104 1
		mba.mba_bios.bios_busname = "bios";
a107 6
	}
#endif
#if NAPM > 0
	{
		mba.mba_aaa.aaa_busname = "apm";
		config_found(self, &mba.mba_aaa, mainbus_print);
@


1.8
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.7 1996/11/23 21:45:49 kstailey Exp $	*/
d49 1
d54 3
d79 3
d108 14
a148 6
	}
#endif
#if NAPM > 0
	{
	    mba.mba_aaa.aaa_busname = "apm";
	    config_found(self, &mba.mba_aaa, mainbus_print);
@


1.7
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.6 1996/11/12 20:29:57 niklas Exp $	*/
d38 1
a38 1
#include <machine/bus.old.h>
d103 2
a104 2
		mba.mba_iba.iba_bc = NULL;
		mba.mba_iba.iba_ic = NULL;
d110 2
a111 2
		mba.mba_eba.eba_bc = NULL;
		mba.mba_eba.eba_ec = NULL;
d124 2
a125 1
		mba.mba_pba.pba_bc = NULL;
@


1.6
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.5 1996/05/30 09:30:08 deraadt Exp $	*/
d65 1
a65 1
int	mainbus_print __P((void *, char *));
d140 1
a140 1
	char *pnp;
@


1.5
log
@clean & sync
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.4 1996/05/07 07:21:47 deraadt Exp $	*/
d38 1
a38 1
#include <machine/bus.h>
@


1.4
log
@sync with 0504; prototype changes
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.2 1996/04/21 22:16:32 deraadt Exp $	*/
a107 1
#ifndef AHA284X_HACK
a108 3
#else
	{
#endif
@


1.3
log
@Pull in John Kohl's [jtk@@netbsd.org] most recent (15Apr96) APM and PCMCIA work
(original PCMCIA framework  by Stefan Grefen [grefen@@convex.com]).
@
text
@d108 1
d110 3
@


1.2
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: mainbus.c,v 1.1 1996/04/18 19:18:11 niklas Exp $	*/
d48 5
d72 3
d129 6
a134 1

@


1.1
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: mainbus.c,v 1.4 1996/03/14 02:37:28 cgd Exp $	*/
a39 1
#if 0 /* XXX eisavar.h includes isavar.h, which is not idempotent */
a40 1
#endif
d44 1
a44 1
#include <dev/isa/isareg.h>
a45 1
#include <i386/eisa/eisa_machdep.h>
d52 7
a58 3
struct cfdriver mainbuscd =
    { NULL, "mainbus", mainbus_match, mainbus_attach,
      DV_DULL, sizeof(struct device) };
d93 14
a121 11
	if (!bcmp(ISA_HOLE_VADDR(EISA_ID_PADDR), EISA_ID, EISA_ID_LEN)) {
		mba.mba_eba.eba_busname = "eisa";
		mba.mba_eba.eba_bc = NULL;
		config_found(self, &mba.mba_eba, mainbus_print);
	}

	if (1 /* XXX ISA NOT YET SEEN */) {
		mba.mba_iba.iba_busname = "isa";
		mba.mba_iba.iba_bc = NULL;
		config_found(self, &mba.mba_iba, mainbus_print);
	}
@
