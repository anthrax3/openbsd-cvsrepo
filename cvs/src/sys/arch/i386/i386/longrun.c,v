head	1.16;
access;
symbols
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.8
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.20
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.18
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.14
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.12
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.10
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.8
	OPENBSD_5_0:1.15.0.6
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.6
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	UBC:1.1.0.4
	UBC_SYNC_A:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.16
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.15;
commitid	uzzBR7hz9ncd4O6G;

1.15
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.25.20.32.29;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.20.17.50.40;	author gwk;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.12.23.14.27;	author dim;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.10.13.01.46;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.06.17.34.37;	author grange;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.14.15.09.22;	author grange;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.06.21.09.20;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.18.23.46.19;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.24.09.03.20;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.07.03.07.19;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.27.23.52.01;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.26.08.30.03;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.14.22.08.04;	author tedu;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.06.07.11.11.37;	author ho;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2004.02.19.10.48.41;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.06.05.23.08.59;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2004.06.07.20.41.09;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.16
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@/* $OpenBSD: longrun.c,v 1.15 2010/04/20 22:05:41 tedu Exp $ */
/*
 * Copyright (c) 2003 Ted Unangst
 * Copyright (c) 2001 Tamotsu Hattori
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/sysctl.h>
#include <sys/timeout.h>

#include <machine/cpufunc.h>

union msrinfo {
	u_int64_t msr;
	uint32_t regs[2];
};

/*
 * Crusoe model specific registers which interest us.
 */
#define MSR_TMx86_LONGRUN       0x80868010
#define MSR_TMx86_LONGRUN_FLAGS 0x80868011

#define LONGRUN_MODE_MASK(x) ((x) & 0x000000007f)
#define LONGRUN_MODE_RESERVED(x) ((x) & 0xffffff80)
#define LONGRUN_MODE_WRITE(x, y) (LONGRUN_MODE_RESERVED(x) | LONGRUN_MODE_MASK(y))

void	longrun_update(void *);

struct timeout longrun_timo;

void
longrun_init(void)
{
	cpu_setperf = longrun_setperf;

	timeout_set(&longrun_timo, longrun_update, NULL);
	timeout_add_sec(&longrun_timo, 1);
}

/*
 * These are the instantaneous values used by the CPU.
 * regs[0] = Frequency is self-evident.
 * regs[1] = Voltage is returned in millivolts.
 * regs[2] = Percent is amount of performance window being used, not
 * percentage of top megahertz.  (0 values are typical.)
 */
void
longrun_update(void *arg)
{
	uint32_t eflags, regs[4];

	eflags = read_eflags();
	disable_intr();
	cpuid(0x80860007, regs);
	enable_intr();
	write_eflags(eflags);

	cpuspeed = regs[0];

	timeout_add_sec(&longrun_timo, 1);
}

/*
 * Transmeta documentation says performance window boundaries
 * must be between 0 and 100 or a GP0 exception is generated.
 * mode is really only a bit, 0 or 1
 * These values will be rounded by the CPU to within the
 * limits it handles.  Typically, there are about 5 performance
 * levels selectable.
 */
void
longrun_setperf(int high)
{
	uint32_t eflags, mode;
 	union msrinfo msrinfo;

	if (high >= 50)
		mode = 1;	/* power */
	else
		mode = 0;	/* battery */

	eflags = read_eflags();
	disable_intr();

	msrinfo.msr = rdmsr(MSR_TMx86_LONGRUN);
	msrinfo.regs[0] = LONGRUN_MODE_WRITE(msrinfo.regs[0], 0); /* low */
	msrinfo.regs[1] = LONGRUN_MODE_WRITE(msrinfo.regs[1], high);
	wrmsr(MSR_TMx86_LONGRUN, msrinfo.msr);

	msrinfo.msr = rdmsr(MSR_TMx86_LONGRUN_FLAGS);
	msrinfo.regs[0] = (msrinfo.regs[0] & ~0x01) | mode;
	wrmsr(MSR_TMx86_LONGRUN_FLAGS, msrinfo.msr);

	enable_intr();
	write_eflags(eflags);

	longrun_update(NULL);
}

@


1.15
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: longrun.c,v 1.14 2008/09/10 14:01:22 blambert Exp $ */
a33 1
#include <sys/proc.h>
@


1.14
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: longrun.c,v 1.13 2007/05/25 20:32:29 krw Exp $ */
d34 1
@


1.13
log
@"boundries" -> "boundaries" in various comments. Started by Diego Casati.
@
text
@d1 1
a1 1
/* $OpenBSD: longrun.c,v 1.12 2006/12/20 17:50:40 gwk Exp $ */
d64 1
a64 1
	timeout_add(&longrun_timo, hz);
d87 1
a87 1
	timeout_add(&longrun_timo, hz);
@


1.12
log
@"#ifdef is a tool of the weak!"
Rename pentium_mhz to cpuspeed which is consistant with amd64 making
shared ACPI code less nasty.
ok marco, deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: longrun.c,v 1.11 2006/12/12 23:14:27 dim Exp $ */
d91 1
a91 1
 * Transmeta documentation says performance window boundries
@


1.11
log
@Complete gwk's previous patch to stop setperf methods from returning
errors to userland: make all cpu_setperf functions return void.

Tested by many, ok gwk@@
@
text
@d1 1
a1 1
/* $OpenBSD: longrun.c,v 1.10 2005/11/10 13:01:46 dlg Exp $ */
d85 1
a85 1
	pentium_mhz = regs[0];
@


1.10
log
@sensors.h is not used here, so remove the include

ok grange@@
@
text
@d1 1
a1 1
/* $OpenBSD: longrun.c,v 1.9 2004/06/06 17:34:37 grange Exp $ */
d98 1
a98 1
int
a124 2

	return (0);
@


1.9
log
@Don't touch any hardware registers while fetching hw.cpuspeed and
just return current pentium_mhz value. Update this value in
all hw.setperf hoos either via its own private methods or using
global update_cpuspeed hook, if registered.
Also implement update_cpuspeed hook for Pentium 3.

Tested by millert@@, Gabriel Kihlman <gk@@stacken.kth.se> and me on
various i386 machines.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: longrun.c,v 1.8 2004/02/14 15:09:22 grange Exp $ */
a35 2
#include <sys/sensors.h>

@


1.8
log
@Simplify hw.{cpuspeed,setperf} api moving all the sysctl stuff
from the underlying callbacks.

Testing hppa mickey@@, ppc drahn@@
Ok markus@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: longrun.c,v 1.7 2004/01/06 21:09:20 tedu Exp $ */
a62 1
	cpu_cpuspeed = longrun_cpuspeed;
a91 8
int
longrun_cpuspeed(int *freq)
{
	longrun_update(NULL);	/* force update */
	*freq = pentium_mhz;
	return (0);
}

d125 2
@


1.7
log
@adjust pentium_mhz when cpu speed changes.  ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: longrun.c,v 1.6 2003/12/18 23:46:19 tedu Exp $ */
d94 1
a94 1
longrun_cpuspeed(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
d97 2
a98 1
	return (sysctl_rdint(oldp, oldlenp, newp, pentium_mhz));
d110 1
a110 1
longrun_setperf(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
a111 1
	int error;
a113 9
	static uint32_t high = 100;

	if (newp == NULL)
		return (EINVAL);
	if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &high)))
		return (error);

	if (high > 100)
		high = 100;
@


1.6
log
@add new hw sysctls, cpuspeed and setperf to control cpu frequency.
convert longrun support to use new sysctls.
add enhanced speedstep support, based on code by Michael Eriksson.
idea, help testing & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: longrun.c,v 1.5 2003/10/24 09:03:20 grange Exp $ */
d33 1
d35 4
d56 14
d77 2
a78 2
int
longrun_cpuspeed(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
d80 1
a80 1
	uint32_t eflags, freq, regs[4];
d88 4
a91 1
	freq = regs[0];
d93 5
a97 1
	return (sysctl_rdint(oldp, oldlenp, newp, freq));
@


1.5
log
@No need to have several implementations of {read,write}_eflags(),
put it to cpufunc.h.
ok weingart@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: longrun.c,v 1.4 2003/07/07 03:07:19 tedu Exp $ */
d33 1
a35 8
#include <machine/longrun.h>

static void	longrun_getmode(u_int32_t *, u_int32_t *, u_int32_t *);
static void	longrun_setmode(u_int32_t, u_int32_t, u_int32_t);
int		longrun_sysctl(void *, size_t *, void *, size_t);

int longrun_enabled;

a50 33
/* 
 * sysctl handler and entry point.  Just call the right function
 */
int longrun_sysctl(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
{
	struct longrun oinfo;
	struct longrun ninfo;
	int error;

	if (!longrun_enabled)
		return (EINVAL);

	if (oldp && *oldlenp < sizeof(oinfo))
		return (ENOMEM);
	*oldlenp = sizeof(oinfo);

	if (newp != NULL) {
		error = copyin(newp, &ninfo, sizeof(ninfo));
		if (error)
			return (error);
		longrun_setmode(ninfo.low, ninfo.high, ninfo.mode);
	}
	
	if (oldp != NULL) {
		memset(&oinfo, 0, sizeof(oinfo));
		longrun_getmode(&oinfo.freq, &oinfo.voltage, &oinfo.percent);
		error = copyout(&oinfo, oldp, sizeof(oinfo));
	}

	return (error);

}

d53 4
a56 4
 * Frequency is self-evident.
 * Voltage is returned in millivolts.
 * Percent is amount of performance window being used, not percentage
 * of top megahertz.  (0 values are typical.)
d58 2
a59 2
static void
longrun_getmode(u_int32_t *freq, u_int32_t *voltage, u_int32_t *percent)
d61 1
a61 2
	u_long eflags;
	u_int32_t regs[4];
a64 1

a65 4
	*freq = regs[0];
	*voltage = regs[1];
	*percent = regs[2];

d68 4
d82 2
a83 2
static void 
longrun_setmode(u_int32_t low, u_int32_t high, u_int32_t mode)
d85 4
a88 2
 	u_long		eflags;
 	union msrinfo	msrinfo;
d90 12
a101 4
	if (low > 100 || high > 100 || low > high)
		return;
	if (mode != 0 && mode != 1)
		return;
d105 1
d107 1
a107 1
	msrinfo.regs[0] = LONGRUN_MODE_WRITE(msrinfo.regs[0], low);
d117 2
@


1.4
log
@function for cpuid instruction.  pulled from longrun into generic code.
ok deraadt mickey
@
text
@d1 1
a1 1
/* $OpenBSD: longrun.c,v 1.3 2003/05/27 23:52:01 fgsch Exp $ */
a56 5
#define read_eflags()           ({register u_long ef; \
                                  __asm("pushfl; popl %0" : "=r" (ef)); \
                                  ef;}) 
#define write_eflags(x)         ({register u_long ef = (x); \
                                  __asm("pushl %0; popfl" : : "r" (ef));})
@


1.3
log
@change .byte for the correct opcodes now that gas can handle'em.
art@@ toby@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: longrun.c,v 1.2 2003/05/26 08:30:03 tedu Exp $ */
a36 1
static void	longrun_readreg(u_int32_t, u_int32_t *);
d112 1
a112 1
	longrun_readreg(0x80860007, regs);
a118 18
}

/*
 * Get the info.  Multiple return values
 */
static void
longrun_readreg(u_int32_t ax, u_int32_t *regs)
{
	__asm __volatile(
	"cpuid;"
	"movl	%%eax, 0(%2);"
	"movl	%%ebx, 4(%2);"
	"movl	%%ecx, 8(%2);"
	"movl	%%edx, 12(%2);"
	:"=a"(ax)
	:"0"(ax), "S"(regs)
	:"bx", "cx", "dx"
	);
@


1.2
log
@cleanup, value paranoia, elaborate on some comments
@
text
@d1 1
a1 1
/* $OpenBSD: longrun.c,v 1.1 2003/05/14 22:08:04 tedu Exp $ */
d129 1
a129 1
	".byte	0x0f, 0xa2;"
@


1.1
log
@Support for Transmeta CPU power management, called LongRun.
option LONGRUN enables a new sysctl, allowing a userland program
to read the current CPU frequency and voltage and also set
the mininum and maximum frequencies to operate between, and switch
between performance mode and battery mode.

ok mickey@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d49 3
d64 3
a66 1
/* sysctl handler and entry point.  Just call the right function */
d69 3
a71 2
	struct longrun *oinfo = oldp;
	struct longrun *ninfo = newp;
d76 10
a85 2
	if (ninfo != NULL)
		longrun_setmode(ninfo->low, ninfo->high, ninfo->mode);
d87 5
a91 2
	if (oinfo != NULL)
		longrun_getmode(&oinfo->freq, &oinfo->voltage, &oinfo->percent);
d93 1
a93 1
	return (0);
d97 7
d122 3
d126 1
a126 1
longrun_readreg(u_int ax, u_int * p)
d130 1
a130 1
	"movl	%%eax, (%2);"
d135 1
a135 1
	:"0"(ax), "S"(p)
d140 8
d154 1
a154 1
	if (low < 0 || low > 100 || high < 0 || high > 100)
d165 1
a165 1
	
@


1.1.2.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: longrun.c,v 1.1 2003/05/14 22:08:04 tedu Exp $ */
a48 3
/*
 * Crusoe model specific registers which interest us.
 */
d61 1
a61 3
/* 
 * sysctl handler and entry point.  Just call the right function
 */
d64 2
a65 3
	struct longrun oinfo;
	struct longrun ninfo;
	int error;
d70 2
a71 10
	if (oldp && *oldlenp < sizeof(oinfo))
		return (ENOMEM);
	*oldlenp = sizeof(oinfo);

	if (newp != NULL) {
		error = copyin(newp, &ninfo, sizeof(ninfo));
		if (error)
			return (error);
		longrun_setmode(ninfo.low, ninfo.high, ninfo.mode);
	}
d73 2
a74 5
	if (oldp != NULL) {
		memset(&oinfo, 0, sizeof(oinfo));
		longrun_getmode(&oinfo.freq, &oinfo.voltage, &oinfo.percent);
		error = copyout(&oinfo, oldp, sizeof(oinfo));
	}
d76 1
a76 1
	return (error);
a79 7
/*
 * These are the instantaneous values used by the CPU.
 * Frequency is self-evident.
 * Voltage is returned in millivolts.
 * Percent is amount of performance window being used, not percentage
 * of top megahertz.  (0 values are typical.)
 */
a97 3
/*
 * Get the info.  Multiple return values
 */
d99 1
a99 1
longrun_readreg(u_int32_t ax, u_int32_t *regs)
d102 2
a103 2
	"cpuid;"
	"movl	%%eax, 0(%2);"
d108 1
a108 1
	:"0"(ax), "S"(regs)
a112 8
/*
 * Transmeta documentation says performance window boundries
 * must be between 0 and 100 or a GP0 exception is generated.
 * mode is really only a bit, 0 or 1
 * These values will be rounded by the CPU to within the
 * limits it handles.  Typically, there are about 5 performance
 * levels selectable.
 */
d119 1
a119 1
	if (low > 100 || high > 100 || low > high)
d130 1
a130 1

@


1.1.2.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d33 3
a35 4
#include <sys/kernel.h>
#include <sys/sysctl.h>
#include <sys/timeout.h>
#include <sys/sensors.h>
d37 4
d42 1
a42 1
#include <machine/cpufunc.h>
d58 5
d64 8
a71 1
void	longrun_update(void *);
d73 19
a91 1
struct timeout longrun_timo;
d93 1
a93 5
void
longrun_init(void)
{
	cpu_cpuspeed = longrun_cpuspeed;
	cpu_setperf = longrun_setperf;
a94 2
	timeout_set(&longrun_timo, longrun_update, NULL);
	timeout_add(&longrun_timo, hz);
d99 4
a102 4
 * regs[0] = Frequency is self-evident.
 * regs[1] = Voltage is returned in millivolts.
 * regs[2] = Percent is amount of performance window being used, not
 * percentage of top megahertz.  (0 values are typical.)
d104 2
a105 2
void
longrun_update(void *arg)
d107 2
a108 1
	uint32_t eflags, regs[4];
d112 6
a117 1
	cpuid(0x80860007, regs);
a119 4

	pentium_mhz = regs[0];

	timeout_add(&longrun_timo, hz);
d122 5
a126 2
int
longrun_cpuspeed(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
d128 10
a137 2
	longrun_update(NULL);	/* force update */
	return (sysctl_rdint(oldp, oldlenp, newp, pentium_mhz));
d148 2
a149 2
int
longrun_setperf(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
d151 2
a152 4
	int error;
	uint32_t eflags, mode;
 	union msrinfo msrinfo;
	static uint32_t high = 100;
d154 4
a157 12
	if (newp == NULL)
		return (EINVAL);
	if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &high)))
		return (error);

	if (high > 100)
		high = 100;

	if (high >= 50)
		mode = 1;	/* power */
	else
		mode = 0;	/* battery */
a160 1

d162 1
a162 1
	msrinfo.regs[0] = LONGRUN_MODE_WRITE(msrinfo.regs[0], 0); /* low */
a171 2

	return (0);
@


1.1.2.3
log
@Merge with the trunk
@
text
@d94 1
a94 1
longrun_cpuspeed(int *freq)
d97 1
a97 2
	*freq = pentium_mhz;
	return (0);
d109 1
a109 1
longrun_setperf(int high)
d111 1
d114 9
@


1.1.2.4
log
@sync to head
@
text
@d63 1
d93 8
a133 2

	longrun_update(NULL);
@


