head	1.30;
access;
symbols
	OPENBSD_4_9:1.26.0.12
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.10
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.6
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.8
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.4
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.25.0.6
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.4
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.21.0.6
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.16
	UBC:1.14.0.22
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.20
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.14.0.18
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.14.0.16
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.14
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.12
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.10
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.8
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.6
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.14.0.4
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2011.07.04.23.01.33;	author tedu;	state dead;
branches;
next	1.29;

1.29
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2011.04.15.10.03.44;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2011.04.15.04.52.39;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2008.03.18.14.29.25;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.24;

1.24
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.11.13.21.12;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.12.22.39.21;	author weingart;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.02.16.29.55;	author niklas;	state Exp;
branches
	1.21.4.1
	1.21.6.1;
next	1.20;

1.20
date	2003.05.13.03.49.04;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.04.05.01.04;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.17.03.42.14;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.28.00.49.13;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.20.19.24.56;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.09.12.23.17.54;	author martin;	state Exp;
branches
	1.14.12.1
	1.14.22.1;
next	1.13;

1.13
date	97.08.27.20.17.41;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.04.01.20.13.27;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.02.05.15.50.18;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.02.01.21.53.26;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.01.27.22.48.00;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.01.27.01.17.08;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.10.17.19.34.24;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.05.07.07.21.54;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.02.13.41.20;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.16.38;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.17.05.18.57;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.01.05.16.17.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.34;	author deraadt;	state Exp;
branches;
next	;

1.14.12.1
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.14.12.2;

1.14.12.2
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.14.12.3;

1.14.12.3
date	2003.05.13.19.42.08;	author ho;	state Exp;
branches;
next	1.14.12.4;

1.14.12.4
date	2003.05.16.00.29.39;	author niklas;	state Exp;
branches;
next	;

1.14.22.1
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	1.14.22.2;

1.14.22.2
date	2002.10.29.00.28.04;	author art;	state Exp;
branches;
next	1.14.22.3;

1.14.22.3
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;

1.21.4.1
date	2006.01.13.00.49.21;	author brad;	state Exp;
branches;
next	;

1.21.6.1
date	2006.01.13.01.56.55;	author brad;	state Exp;
branches;
next	;


desc
@@


1.30
log
@remove all the compat svr4 files
@
text
@/*	$OpenBSD: svr4_machdep.c,v 1.29 2011/04/18 21:44:55 guenther Exp $	*/
/*	$NetBSD: svr4_machdep.c,v 1.24 1996/05/03 19:42:26 christos Exp $	 */

/*
 * Copyright (c) 1994 Christos Zoulas
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/kernel.h>
#include <sys/signal.h>
#include <sys/signalvar.h>
#include <sys/malloc.h>

#include <sys/syscallargs.h>
#include <compat/svr4/svr4_types.h>
#include <compat/svr4/svr4_ucontext.h>
#include <compat/svr4/svr4_syscallargs.h>
#include <compat/svr4/svr4_util.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/specialreg.h>
#include <machine/sysarch.h>
#include <machine/vm86.h>
#include <machine/svr4_machdep.h>

static void svr4_getsiginfo(union svr4_siginfo *, int, u_long, int, caddr_t);

void
svr4_getcontext(struct proc *p, struct svr4_ucontext *uc, int mask,
    int oonstack)
{
	struct trapframe *tf = p->p_md.md_regs;
	struct sigacts *psp = p->p_sigacts;
	svr4_greg_t *r = uc->uc_mcontext.greg;
	struct svr4_sigaltstack *s = &uc->uc_stack;
	struct sigaltstack *sf = &psp->ps_sigstk;

	bzero(uc, sizeof(struct svr4_ucontext));

	/*
	 * Set the general purpose registers
	 */
#ifdef VM86
	if (tf->tf_eflags & PSL_VM) {
		r[SVR4_X86_GS] = tf->tf_vm86_gs;
		r[SVR4_X86_FS] = tf->tf_vm86_fs;
		r[SVR4_X86_ES] = tf->tf_vm86_es;
		r[SVR4_X86_DS] = tf->tf_vm86_ds;
		r[SVR4_X86_EFL] = get_vflags(p);
	} else
#endif
	{
		r[SVR4_X86_FS] = tf->tf_fs;
		r[SVR4_X86_GS] = tf->tf_gs;
		r[SVR4_X86_ES] = tf->tf_es;
		r[SVR4_X86_DS] = tf->tf_ds;
		r[SVR4_X86_EFL] = tf->tf_eflags;
	}
	r[SVR4_X86_EDI] = tf->tf_edi;
	r[SVR4_X86_ESI] = tf->tf_esi;
	r[SVR4_X86_EBP] = tf->tf_ebp;
	r[SVR4_X86_ESP] = tf->tf_esp;
	r[SVR4_X86_EBX] = tf->tf_ebx;
	r[SVR4_X86_EDX] = tf->tf_edx;
	r[SVR4_X86_ECX] = tf->tf_ecx;
	r[SVR4_X86_EAX] = tf->tf_eax;
	r[SVR4_X86_TRAPNO] = 0;
	r[SVR4_X86_ERR] = 0;
	r[SVR4_X86_EIP] = tf->tf_eip;
	r[SVR4_X86_CS] = tf->tf_cs;
	r[SVR4_X86_UESP] = 0;
	r[SVR4_X86_SS] = tf->tf_ss;

	/*
	 * Set the signal stack
	 */
	bsd_to_svr4_sigaltstack(sf, s);

	/*
	 * Set the signal mask
	 */
	bsd_to_svr4_sigset(&mask, &uc->uc_sigmask);

	/*
	 * Set the flags
	 */
	uc->uc_flags = SVR4_UC_ALL;
}


/*
 * Set to ucontext specified.
 * has been taken.  Reset signal mask and
 * stack state from context.
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper privileges or to cause
 * a machine fault.
 */
int
svr4_setcontext(struct proc *p, struct svr4_ucontext *uc)
{
	struct sigacts *psp = p->p_sigacts;
	struct trapframe *tf;
	svr4_greg_t *r = uc->uc_mcontext.greg;
	struct svr4_sigaltstack *s = &uc->uc_stack;
	struct sigaltstack *sf = &psp->ps_sigstk;
	int mask;

	/*
	 * XXX:
	 * Should we check the value of flags to determine what to restore?
	 * What to do with uc_link?
	 * What to do with floating point stuff?
	 * Should we bother with the rest of the registers that we
	 * set to 0 right now?
	 */

	tf = p->p_md.md_regs;

	/*
	 * Restore register context.
	 */
#ifdef VM86
	if (r[SVR4_X86_EFL] & PSL_VM) {
		tf->tf_vm86_gs = r[SVR4_X86_GS];
		tf->tf_vm86_fs = r[SVR4_X86_FS];
		tf->tf_vm86_es = r[SVR4_X86_ES];
		tf->tf_vm86_ds = r[SVR4_X86_DS];
		set_vflags(p, r[SVR4_X86_EFL]);
	} else
#endif
	{
		/*
		 * Check for security violations.  If we're returning to
		 * protected mode, the CPU will validate the segment registers
		 * automatically and generate a trap on violations.  We handle
		 * the trap, rather than doing all of the checking here.
		 */
		if (((r[SVR4_X86_EFL] ^ tf->tf_eflags) & PSL_USERSTATIC) != 0 ||
		    !USERMODE(r[SVR4_X86_CS], r[SVR4_X86_EFL]))
			return (EINVAL);

		tf->tf_fs = r[SVR4_X86_FS];
		tf->tf_gs = r[SVR4_X86_GS];
		tf->tf_es = r[SVR4_X86_ES];
		tf->tf_ds = r[SVR4_X86_DS];
		tf->tf_eflags = r[SVR4_X86_EFL];
	}
	tf->tf_edi = r[SVR4_X86_EDI];
	tf->tf_esi = r[SVR4_X86_ESI];
	tf->tf_ebp = r[SVR4_X86_EBP];
	tf->tf_ebx = r[SVR4_X86_EBX];
	tf->tf_edx = r[SVR4_X86_EDX];
	tf->tf_ecx = r[SVR4_X86_ECX];
	tf->tf_eax = r[SVR4_X86_EAX];
	tf->tf_eip = r[SVR4_X86_EIP];
	tf->tf_cs = r[SVR4_X86_CS];
	tf->tf_ss = r[SVR4_X86_SS];
	tf->tf_esp = r[SVR4_X86_ESP];

	/*
	 * restore signal stack
	 */
	svr4_to_bsd_sigaltstack(s, sf);

	/*
	 * restore signal mask
	 */
	svr4_to_bsd_sigset(&uc->uc_sigmask, &mask);
	p->p_sigmask = mask & ~sigcantmask;

	return EJUSTRETURN;
}


static void
svr4_getsiginfo(union svr4_siginfo *si, int sig, u_long code, int type,
    caddr_t addr)
{
	si->svr4_si_signo = bsd_to_svr4_sig[sig];
	si->svr4_si_errno = 0;
	si->svr4_si_addr  = addr;

	si->svr4_si_code = 0;
	si->svr4_si_trap = 0;

	switch (sig) {
	case SIGSEGV:
		switch (type) {
		case SEGV_ACCERR:
			si->svr4_si_code = SVR4_SEGV_ACCERR;
			si->svr4_si_trap = SVR4_T_PROTFLT;
			break;
		case SEGV_MAPERR:
			si->svr4_si_code = SVR4_SEGV_MAPERR;
			si->svr4_si_trap = SVR4_T_SEGNPFLT;
			break;
		}
		break;
	case SIGBUS:
		switch (type) {
		case BUS_ADRALN:
			si->svr4_si_code = SVR4_BUS_ADRALN;
			si->svr4_si_trap = SVR4_T_ALIGNFLT;
			break;
		}
		break;
	case SIGTRAP:
		switch (type) {
		case TRAP_BRKPT:
			si->svr4_si_code = SVR4_TRAP_BRKPT;
			si->svr4_si_trap = SVR4_T_BPTFLT;
			break;
		case TRAP_TRACE:
			si->svr4_si_code = SVR4_TRAP_TRACE;
			si->svr4_si_trap = SVR4_T_TRCTRAP;
			break;
		}
		break;
	case SIGEMT:
		switch (type) {
		}
		break;
	case SIGILL:
		switch (type) {
		case ILL_PRVOPC:
			si->svr4_si_code = SVR4_ILL_PRVOPC;
			si->svr4_si_trap = SVR4_T_PRIVINFLT;
			break;
		case ILL_BADSTK:
			si->svr4_si_code = SVR4_ILL_BADSTK;
			si->svr4_si_trap = SVR4_T_STKFLT;
			break;
		}
		break;
	case SIGFPE:
		switch (type) {
		case FPE_INTOVF:
			si->svr4_si_code = SVR4_FPE_INTOVF;
			si->svr4_si_trap = SVR4_T_DIVIDE;
			break;
		case FPE_FLTDIV:
			si->svr4_si_code = SVR4_FPE_FLTDIV;
			si->svr4_si_trap = SVR4_T_DIVIDE;
			break;
		case FPE_FLTOVF:
			si->svr4_si_code = SVR4_FPE_FLTOVF;
			si->svr4_si_trap = SVR4_T_DIVIDE;
			break;
		case FPE_FLTSUB:
			si->svr4_si_code = SVR4_FPE_FLTSUB;
			si->svr4_si_trap = SVR4_T_BOUND;
			break;
		case FPE_FLTINV:
			si->svr4_si_code = SVR4_FPE_FLTINV;
			si->svr4_si_trap = SVR4_T_FPOPFLT;
			break;
		}
		break;
	}
}


/*
 * Send an interrupt to process.
 *
 * Stack is set up to allow sigcode stored
 * in u. to call routine. After the handler is
 * done svr4 will call setcontext for us
 * with the user context we just set up, and we
 * will return to the user pc, psl.
 */
void
svr4_sendsig(sig_t catcher, int sig, int mask, u_long code, int type,
    union sigval val)
{
	struct proc *p = curproc;
	struct trapframe *tf;
	struct svr4_sigframe *fp, frame;
	struct sigacts *psp = p->p_sigacts;
	int oonstack;

	tf = p->p_md.md_regs;
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;

	/*
	 * Allocate space for the signal handler context.
	 */
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct svr4_sigframe *)((char *)psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size - sizeof(struct svr4_sigframe));
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
	} else {
		fp = (struct svr4_sigframe *)tf->tf_esp - 1;
	}

	/*
	 * Build the argument list for the signal handler.
	 * Notes:
	 * 	- we always build the whole argument list, even when we
	 *	  don't need to [when SA_SIGINFO is not set, we don't need
	 *	  to pass all sf_si and sf_uc]
	 *	- we don't pass the correct signal address [we need to
	 *	  modify many kernel files to enable that]
	 */

	svr4_getcontext(p, &frame.sf_uc, mask, oonstack);
	svr4_getsiginfo(&frame.sf_si, sig, code, type, val.sival_ptr);

	frame.sf_signum = frame.sf_si.svr4_si_signo;
	frame.sf_sip = &fp->sf_si;
	frame.sf_ucp = &fp->sf_uc;
	frame.sf_handler = catcher;
#ifdef DEBUG_SVR4
	printf("sig = %d, sip %p, ucp = %p, handler = %p\n",
	       frame.sf_signum, frame.sf_sip, frame.sf_ucp, frame.sf_handler);
#endif

	if (copyout(&frame, fp, sizeof(frame)) != 0) {
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}

	/*
	 * Build context to run handler in.
	 */
	tf->tf_es = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_ds = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_eip = p->p_sigcode;
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
	tf->tf_eflags &= ~(PSL_T|PSL_D|PSL_VM|PSL_AC);
	tf->tf_esp = (int)fp;
	tf->tf_ss = GSEL(GUDATA_SEL, SEL_UPL);
}


/*
 * sysi86
 */
int
svr4_sys_sysarch(struct proc *p, void *v, register_t *retval)
{
	struct svr4_sys_sysarch_args *uap = v;
	int error;
#ifdef USER_LDT
	caddr_t sg = stackgap_init(p->p_emul);
#endif
	*retval = 0;	/* XXX: What to do */

	switch (SCARG(uap, op)) {
	case SVR4_SYSARCH_FPHW:
		return 0;

	case SVR4_SYSARCH_DSCR:
#ifdef USER_LDT
		if (user_ldt_enable == 0)
			return (ENOSYS);
		else {
			struct i386_set_ldt_args sa, *sap;
			struct sys_sysarch_args ua;

			struct svr4_ssd ssd;
			union descriptor bsd;

			if ((error = copyin(SCARG(uap, a1), &ssd,
					    sizeof(ssd))) != 0) {
				printf("Cannot copy arg1\n");
				return error;
			}

			printf("s=%x, b=%x, l=%x, a1=%x a2=%x\n",
			       ssd.selector, ssd.base, ssd.limit,
			       ssd.access1, ssd.access2);

			/* We can only set ldt's for now. */
			if (!ISLDT(ssd.selector)) {
				printf("Not an ldt\n");
				return EPERM;
			}

			/* Oh, well we don't cleanup either */
			if (ssd.access1 == 0)
				return 0;

			bsd.sd.sd_lobase = ssd.base & 0xffffff;
			bsd.sd.sd_hibase = (ssd.base >> 24) & 0xff;

			bsd.sd.sd_lolimit = ssd.limit & 0xffff;
			bsd.sd.sd_hilimit = (ssd.limit >> 16) & 0xf;

			bsd.sd.sd_type = ssd.access1 & 0x1f;
			bsd.sd.sd_dpl =  (ssd.access1 >> 5) & 0x3;
			bsd.sd.sd_p = (ssd.access1 >> 7) & 0x1;

			bsd.sd.sd_xx = ssd.access2 & 0x3;
			bsd.sd.sd_def32 = (ssd.access2 >> 2) & 0x1;
			bsd.sd.sd_gran = (ssd.access2 >> 3)& 0x1;

			sa.start = IDXSEL(ssd.selector);
			sa.desc = stackgap_alloc(&sg, sizeof(union descriptor));
			sa.num = 1;
			sap = stackgap_alloc(&sg,
					     sizeof(struct i386_set_ldt_args));

			if ((error = copyout(&sa, sap, sizeof(sa))) != 0) {
				printf("Cannot copyout args\n");
				return error;
			}

			SCARG(&ua, op) = I386_SET_LDT;
			SCARG(&ua, parms) = (char *) sap;

			if ((error = copyout(&bsd, sa.desc, sizeof(bsd))) != 0) {
				printf("Cannot copyout desc\n");
				return error;
			}

			return sys_sysarch(p, &ua, retval);
		}
#endif
	case SVR4_SYSARCH_GOSF:
		{
				/* just as SCO Openserver 5.0 says */
			char features[] = {1,1,1,1,1,1,1,1,2,1,1,1};

			if ((error = copyout(features, SCARG(uap, a1),
					     sizeof(features))) != 0) {
				printf("Cannot copyout vector\n");
				return error;
			}

			return 0;
		}

	default:
		printf("svr4_sysarch(%d), a1 %p\n", SCARG(uap, op),
		       SCARG(uap, a1));
		return 0;
	}
}
@


1.29
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.26 2008/03/18 14:29:25 kettenis Exp $	*/
@


1.28
log
@Remove local variables that are no longer used after the last commit
and cause build failure. Bad guenther@@ no cookies.
commitski! mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.27 2011/04/15 04:52:39 guenther Exp $	*/
d66 1
d69 1
a69 1
	struct sigaltstack *sf = &p->p_sigstk;
d137 1
d141 1
a141 1
	struct sigaltstack *sf = &p->p_sigstk;
d319 1
a319 1
	oonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d324 1
a324 1
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !oonstack &&
d326 3
a328 3
		fp = (struct svr4_sigframe *)((char *)p->p_sigstk.ss_sp +
		    p->p_sigstk.ss_size - sizeof(struct svr4_sigframe));
		p->p_sigstk.ss_flags |= SS_ONSTACK;
@


1.27
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.26 2008/03/18 14:29:25 kettenis Exp $	*/
a65 1
	struct sigacts *psp = p->p_sigacts;
a135 1
	struct sigacts *psp = p->p_sigacts;
@


1.26
log
@Clear PSL_D when entering signal handlers; pointed out by dfly people;

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.25 2006/12/29 13:04:37 pedro Exp $	*/
d69 1
a69 1
	struct sigaltstack *sf = &psp->ps_sigstk;
d141 1
a141 1
	struct sigaltstack *sf = &psp->ps_sigstk;
d319 1
a319 1
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d324 1
a324 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
d326 3
a328 3
		fp = (struct svr4_sigframe *)((char *)psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size - sizeof(struct svr4_sigframe));
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
@


1.25
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.24 2006/09/19 11:06:33 jsg Exp $	*/
d371 1
a371 1
	tf->tf_eflags &= ~(PSL_T|PSL_VM|PSL_AC);
@


1.24
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.23 2006/05/11 13:21:12 mickey Exp $	*/
d326 1
a326 1
		fp = (struct svr4_sigframe *)(psp->ps_sigstk.ss_sp +
@


1.23
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.22 2006/01/12 22:39:21 weingart Exp $	*/
d62 2
a63 4
svr4_getcontext(p, uc, mask, oonstack)
	struct proc *p;
	struct svr4_ucontext *uc;
	int mask, oonstack;
d135 1
a135 3
svr4_setcontext(p, uc)
	struct proc *p;
	struct svr4_ucontext *uc;
d138 1
a138 1
	register struct trapframe *tf;
d212 2
a213 6
svr4_getsiginfo(si, sig, code, type, addr)
	union svr4_siginfo	*si;
	int			 sig;
	u_long			 code;
	int			 type;
	caddr_t			 addr;
d309 2
a310 6
svr4_sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
d312 2
a313 2
	register struct proc *p = curproc;
	register struct trapframe *tf;
d381 1
a381 4
svr4_sys_sysarch(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
@


1.22
log
@Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.21 2004/07/02 16:29:55 niklas Exp $	*/
d345 1
a345 1
	/* 
d363 1
a363 1
	printf("sig = %d, sip %p, ucp = %p, handler = %p\n", 
@


1.21
log
@Maintain %f and %gs over traps.  Mostly from NetBSD.  Preparation for SMP
speedups.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.20 2003/05/13 03:49:04 art Exp $	*/
a324 1
	struct pmap *pmap = vm_map_pmap(&p->p_vmspace->vm_map);
d382 1
a382 2
	tf->tf_cs = pmap->pm_hiexec > I386_MAX_EXE_ADDR ? 
	    GSEL(GUCODE1_SEL, SEL_UPL) : GSEL(GUCODE_SEL, SEL_UPL);
@


1.21.6.1
log
@MFC:
Fix by weingart@@

Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.21 2004/07/02 16:29:55 niklas Exp $	*/
d325 1
d383 2
a384 1
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
@


1.21.4.1
log
@MFC:
Fix by weingart@@

Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.21 2004/07/02 16:29:55 niklas Exp $	*/
d325 1
d383 2
a384 1
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
@


1.20
log
@The current solution to handle the protection fault trap is not
correct.  It breaks down if we're trying to jump through a function
pointer. The protection fault trap on i386 must be one of the most
braindead traps ever invented in the history of humankind. It doesn't
give you any information about what went wrong except the instruction
that faulted. Since the problem we're trying to deal with is a
segmentation problem, we don't get the desitination that we want to
jump to, we just get the instruction and we won't add a disassembler
to trap handling just to try to figure out what went wrong.

What we want to do is to handle this as a normal fault to let noexec
accounting in pmap_enter deal with the changes to the code
segment. Unfortunately that's impossible. We don't know the faulting
address, so we need to change how the exec accounting works. Basically
the code segment must already cover the address we want to execute
before we can fault it in.

New scheme:

 o Start with conservative code segment.

 o If we get a protection fault, go through all mappings in the process
  and find the highest executable mapping, fix up the code segment and
  record that address. If the code segment didn't change, the protection
  fault wasn't fixable - just die.

 o If the highest executable mapping is removed, just reset the code
  segment to something conservative and let the next protection fault
  deal with it.  We can't read all the vm mappings of the process from
  the pmap because of locking hell.

This should allow floating code segment whenever someone implements that.

Also, fix the pmap_protect function to behave more like the other
pmaps we have and be slightly more agressive to force more proper
protection changes.

ok:ed by various people.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.19 2003/05/04 05:01:04 drahn Exp $	*/
d88 2
a89 2
	        __asm("movl %%gs,%k0" : "=r" (r[SVR4_X86_GS]));
		__asm("movl %%fs,%k0" : "=r" (r[SVR4_X86_FS]));
d182 2
a183 1
		/* %fs and %gs were restored by the trampoline. */
@


1.19
log
@Set code segment register according to nxpages, copied from machdep.c
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.18 2003/04/17 03:42:14 drahn Exp $	*/
d382 1
a382 1
	tf->tf_cs = pmap->pm_nxpages > 0?
@


1.18
log
@i386 changes to move to ELF. asm cleanup. Change MAXDSIZ to 512M for 1Gsep.
DARPA funded work.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.17 2003/03/28 00:49:13 miod Exp $	*/
d324 1
d382 2
a383 1
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
@


1.17
log
@Add a sysctl to option USER_LDT, to control its behaviour, which will be
disabled by default.

Enable with sysctl -w machdep.userldt=1

This will allow people to use the few ports that require this functionality
to work without requiring the user to recompile a kernel.

The option USER_LDT remains in order to not increase size on the
installation media. It is now enabled in GENERIC.

Per espie@@'s idea, but my diff was much simpler than his; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.16 2002/07/20 19:24:56 art Exp $	*/
d88 2
a89 2
	        __asm("movl %%gs,%w0" : "=r" (r[SVR4_X86_GS]));
		__asm("movl %%fs,%w0" : "=r" (r[SVR4_X86_FS]));
@


1.16
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.15 2002/03/14 01:26:33 millert Exp $	*/
d410 3
a412 1
		{
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.14 1997/09/12 23:17:54 martin Exp $	*/
a327 1
	extern char svr4_esigcode[], svr4_sigcode[];
d380 1
a380 2
	tf->tf_eip = (int)(((char *)PS_STRINGS) -
	     (svr4_esigcode - svr4_sigcode));
@


1.14
log
@Moved define of int error outside of ifdef USER_LDT
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.13 1997/08/27 20:17:41 mickey Exp $	*/
d59 1
a59 1
static void svr4_getsiginfo __P((union svr4_siginfo *, int, u_long, int, caddr_t));
@


1.14.22.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.14 1997/09/12 23:17:54 martin Exp $	*/
d59 1
a59 1
static void svr4_getsiginfo(union svr4_siginfo *, int, u_long, int, caddr_t);
@


1.14.22.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.14.22.1 2002/06/11 03:35:53 art Exp $	*/
d328 1
d381 2
a382 1
	tf->tf_eip = p->p_sigcode;
@


1.14.22.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 2
a89 2
	        __asm("movl %%gs,%k0" : "=r" (r[SVR4_X86_GS]));
		__asm("movl %%fs,%k0" : "=r" (r[SVR4_X86_FS]));
a323 1
	struct pmap *pmap = vm_map_pmap(&p->p_vmspace->vm_map);
d381 1
a381 2
	tf->tf_cs = pmap->pm_hiexec > I386_MAX_EXE_ADDR ? 
	    GSEL(GUCODE1_SEL, SEL_UPL) : GSEL(GUCODE_SEL, SEL_UPL);
d410 1
a410 3
		if (user_ldt_enable == 0)
			return (ENOSYS);
		else {
@


1.14.12.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 1
a59 1
static void svr4_getsiginfo(union svr4_siginfo *, int, u_long, int, caddr_t);
@


1.14.12.2
log
@Sync the SMP branch with 3.3
@
text
@d328 1
d381 2
a382 1
	tf->tf_eip = p->p_sigcode;
@


1.14.12.3
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.14.12.2 2003/03/27 23:26:55 niklas Exp $	*/
d88 2
a89 2
	        __asm("movl %%gs,%k0" : "=r" (r[SVR4_X86_GS]));
		__asm("movl %%fs,%k0" : "=r" (r[SVR4_X86_FS]));
a323 1
	struct pmap *pmap = vm_map_pmap(&p->p_vmspace->vm_map);
d381 1
a381 2
	tf->tf_cs = pmap->pm_nxpages > 0?
	    GSEL(GUCODE1_SEL, SEL_UPL) : GSEL(GUCODE_SEL, SEL_UPL);
d410 1
a410 3
		if (user_ldt_enable == 0)
			return (ENOSYS);
		else {
@


1.14.12.4
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d382 1
a382 1
	tf->tf_cs = pmap->pm_hiexec > I386_MAX_EXE_ADDR ? 
@


1.13
log
@add get OS features support vector, as per SCO OS 5.0
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.12 1997/04/01 20:13:27 deraadt Exp $	*/
d400 1
a402 1
	int error;
@


1.12
log
@FPE_INTOVF botch
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.11 1997/02/05 15:50:18 deraadt Exp $	*/
d475 13
@


1.11
log
@map native sig/code to svr4 code in a different fashion; must be checked later
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.10 1997/02/01 21:53:26 deraadt Exp $	*/
d280 1
a280 1
		case T_ARITHTRAP:
@


1.10
log
@add type & union sigval args to sendsig/trapsignal
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.9 1997/01/27 22:48:00 deraadt Exp $	*/
d226 2
a227 55
	switch (code) {
	case T_PRIVINFLT:
		si->svr4_si_code = SVR4_ILL_PRVOPC;
		si->svr4_si_trap = SVR4_T_PRIVINFLT;
		break;

	case T_BPTFLT:
		si->svr4_si_code = SVR4_TRAP_BRKPT;
		si->svr4_si_trap = SVR4_T_BPTFLT;
		break;

	case T_ARITHTRAP:
		si->svr4_si_code = SVR4_FPE_INTOVF;
		si->svr4_si_trap = SVR4_T_DIVIDE;
		break;

	case T_PROTFLT:
		si->svr4_si_code = SVR4_SEGV_ACCERR;
		si->svr4_si_trap = SVR4_T_PROTFLT;
		break;

	case T_TRCTRAP:
		si->svr4_si_code = SVR4_TRAP_TRACE;
		si->svr4_si_trap = SVR4_T_TRCTRAP;
		break;

	case T_PAGEFLT:
		si->svr4_si_code = SVR4_SEGV_ACCERR;
		si->svr4_si_trap = SVR4_T_PAGEFLT;
		break;

	case T_ALIGNFLT:
		si->svr4_si_code = SVR4_BUS_ADRALN;
		si->svr4_si_trap = SVR4_T_ALIGNFLT;
		break;

	case T_DIVIDE:
		si->svr4_si_code = SVR4_FPE_FLTDIV;
		si->svr4_si_trap = SVR4_T_DIVIDE;
		break;

	case T_OFLOW:
		si->svr4_si_code = SVR4_FPE_FLTOVF;
		si->svr4_si_trap = SVR4_T_DIVIDE;
		break;

	case T_BOUND:
		si->svr4_si_code = SVR4_FPE_FLTSUB;
		si->svr4_si_trap = SVR4_T_BOUND;
		break;

	case T_DNA:
		si->svr4_si_code = SVR4_FPE_FLTINV;
		si->svr4_si_trap = SVR4_T_DNA;
		break;
d229 72
a300 22
	case T_FPOPFLT:
		si->svr4_si_code = SVR4_FPE_FLTINV;
		si->svr4_si_trap = SVR4_T_FPOPFLT;
		break;

	case T_SEGNPFLT:
		si->svr4_si_code = SVR4_SEGV_MAPERR;
		si->svr4_si_trap = SVR4_T_SEGNPFLT;
		break;

	case T_STKFLT:
		si->svr4_si_code = SVR4_ILL_BADSTK;
		si->svr4_si_trap = SVR4_T_STKFLT;
		break;

	default:
		si->svr4_si_code = 0;
		si->svr4_si_trap = 0;
#ifdef DIAGNOSTIC
		printf("sig %d code %ld\n", sig, code);
		panic("svr4_getsiginfo");
#endif
@


1.9
log
@add another parameter to trapsignal() and sendsig() -- fault addr to be
delivered with in the siginfo information
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.8 1997/01/27 01:17:08 deraadt Exp $	*/
d59 1
a59 1
static void svr4_getsiginfo __P((union svr4_siginfo *, int, u_long, caddr_t));
d215 1
a215 1
svr4_getsiginfo(si, sig, code, addr)
d219 1
d319 1
a319 1
svr4_sendsig(catcher, sig, mask, code, addr)
d323 2
a324 1
	caddr_t addr;
d359 1
a359 1
	svr4_getsiginfo(&frame.sf_si, sig, code, addr);
@


1.8
log
@match svr4 siginfo changes
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.7 1996/10/17 19:34:24 niklas Exp $	*/
d318 1
a318 1
svr4_sendsig(catcher, sig, mask, code)
d322 1
d357 1
a357 1
	svr4_getsiginfo(&frame.sf_si, sig, code, (caddr_t) tf->tf_eip);
@


1.7
log
@Conditionalize variable decls
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_machdep.c,v 1.4 1996/04/21 22:16:38 deraadt Exp $	*/
d221 3
a223 3
	si->si_signo = bsd_to_svr4_sig[sig];
	si->si_errno = 0;
	si->si_addr  = addr;
d227 2
a228 2
		si->si_code = SVR4_ILL_PRVOPC;
		si->si_trap = SVR4_T_PRIVINFLT;
d232 2
a233 2
		si->si_code = SVR4_TRAP_BRKPT;
		si->si_trap = SVR4_T_BPTFLT;
d237 2
a238 2
		si->si_code = SVR4_FPE_INTOVF;
		si->si_trap = SVR4_T_DIVIDE;
d242 2
a243 2
		si->si_code = SVR4_SEGV_ACCERR;
		si->si_trap = SVR4_T_PROTFLT;
d247 2
a248 2
		si->si_code = SVR4_TRAP_TRACE;
		si->si_trap = SVR4_T_TRCTRAP;
d252 2
a253 2
		si->si_code = SVR4_SEGV_ACCERR;
		si->si_trap = SVR4_T_PAGEFLT;
d257 2
a258 2
		si->si_code = SVR4_BUS_ADRALN;
		si->si_trap = SVR4_T_ALIGNFLT;
d262 2
a263 2
		si->si_code = SVR4_FPE_FLTDIV;
		si->si_trap = SVR4_T_DIVIDE;
d267 2
a268 2
		si->si_code = SVR4_FPE_FLTOVF;
		si->si_trap = SVR4_T_DIVIDE;
d272 2
a273 2
		si->si_code = SVR4_FPE_FLTSUB;
		si->si_trap = SVR4_T_BOUND;
d277 2
a278 2
		si->si_code = SVR4_FPE_FLTINV;
		si->si_trap = SVR4_T_DNA;
d282 2
a283 2
		si->si_code = SVR4_FPE_FLTINV;
		si->si_trap = SVR4_T_FPOPFLT;
d287 2
a288 2
		si->si_code = SVR4_SEGV_MAPERR;
		si->si_trap = SVR4_T_SEGNPFLT;
d292 2
a293 2
		si->si_code = SVR4_ILL_BADSTK;
		si->si_trap = SVR4_T_STKFLT;
d297 2
a298 2
		si->si_code = 0;
		si->si_trap = 0;
d358 1
a358 1
	frame.sf_signum = frame.sf_si.si_signo;
@


1.6
log
@sync with 0504; prototype changes
@
text
@d400 1
d403 1
@


1.5
log
@Turn off the alignment check flag when entering a signal handler
@
text
@d2 1
a2 1
/*	$NetBSD: svr4_machdep.c,v 1.23 1996/04/18 08:36:31 mycroft Exp $	 */
a140 1
	struct sigcontext *scp, context;
d300 1
a300 1
		printf("sig %d code %d\n", sig, code);
d362 2
a363 1
	printf("sig = %d, sip %x, ucp = %x, handler = %x\n", 
d365 1
d475 1
a475 1
		printf("svr4_sysarch(%d), a1 %x\n", SCARG(uap, op),
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: svr4_machdep.c,v 1.3 1996/04/17 05:18:57 mickey Exp $	*/
/*	$NetBSD: svr4_machdep.c,v 1.22 1996/04/12 08:44:42 mycroft Exp $ */
d383 1
a383 1
	tf->tf_eflags &= ~(PSL_T|PSL_VM);
@


1.3
log
@Cleanups & fixes from latest NetBSD primarily to run doscmd, etc.
GENERIC added to the compile/.cvsignore (it is used for 'make links'
for example), thus conf/GENERIC should appear magically ...
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: svr4_machdep.c,v 1.21 1996/04/11 07:47:50 mycroft Exp $	 */
a84 1
		tf->tf_eflags &= ~PSL_VM;
d378 2
a379 1
	tf->tf_esp = (int)fp;
d381 1
a381 4
				(svr4_esigcode - svr4_sigcode));
#ifdef VM86
	tf->tf_eflags &= ~PSL_VM;
#endif
d383 2
a384 2
	tf->tf_ds = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_es = GSEL(GUDATA_SEL, SEL_UPL);
@


1.2
log
@ss_sp is correct, ss_base is not. noticed by agc@@sde.uts.amdahl.com; netbsd pr#1784
@
text
@d1 2
a2 1
/*	$NetBSD: svr4_machdep.c,v 1.20 1996/01/04 22:22:04 jtc Exp $	 */
d56 1
d84 2
d93 1
a106 1
	r[SVR4_X86_EFL] = tf->tf_eflags;
a161 18
	 * Check for security violations.
	 */
	if (((r[SVR4_X86_EFL] ^ tf->tf_eflags) & PSL_USERSTATIC) != 0 ||
	    !USERMODE(r[SVR4_X86_CS], r[SVR4_X86_EFL]))
		return (EINVAL);

	/*
	 * restore signal stack
	 */
	svr4_to_bsd_sigaltstack(s, sf);

	/*
	 * restore signal mask
	 */
	svr4_to_bsd_sigset(&uc->uc_sigmask, &mask);
	p->p_sigmask = mask & ~sigcantmask;

	/*
d170 1
d174 10
d187 1
a197 1
	tf->tf_eflags = r[SVR4_X86_EFL];
d200 11
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: svr4_machdep.c,v 1.19 1995/10/11 17:04:11 mycroft Exp $	 */
d332 1
a332 1
		fp = (struct svr4_sigframe *)(psp->ps_sigstk.ss_base +
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
