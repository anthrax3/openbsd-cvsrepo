head	1.23;
access;
symbols
	OPENBSD_4_9:1.22.0.12
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.10
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.6
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.8
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.21.0.6
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.4
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.10
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.8
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.4
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.13
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.10.0.10
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.8
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.6
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.8
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.6
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2011.04.05.12.50.15;	author guenther;	state dead;
branches;
next	1.22;

1.22
date	2008.03.18.14.29.25;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2006.12.29.13.04.36;	author pedro;	state Exp;
branches;
next	1.20;

1.20
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.11.13.21.11;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.12.22.39.20;	author weingart;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.23.27.47;	author millert;	state Exp;
branches
	1.17.8.1
	1.17.10.1;
next	1.16;

1.16
date	2003.05.13.03.49.04;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.04.05.01.04;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.16.04.15.17;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.20.19.24.56;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.02.03.02.46.28;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	99.01.11.05.11.23;	author millert;	state Exp;
branches
	1.10.6.1;
next	1.9;

1.9
date	97.02.01.21.53.18;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.01.27.22.47.57;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.08.27.10.46.51;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.05.07.07.21.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.02.13.41.14;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.16.26;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.17.05.18.51;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.01.05.16.17.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.32;	author deraadt;	state Exp;
branches;
next	;

1.10.6.1
date	2001.04.18.16.07.16;	author niklas;	state Exp;
branches;
next	1.10.6.2;

1.10.6.2
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.10.6.3;

1.10.6.3
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.10.6.4;

1.10.6.4
date	2003.05.13.19.42.07;	author ho;	state Exp;
branches;
next	1.10.6.5;

1.10.6.5
date	2003.05.16.00.29.39;	author niklas;	state Exp;
branches;
next	1.10.6.6;

1.10.6.6
date	2003.06.07.11.11.36;	author ho;	state Exp;
branches;
next	;

1.12.2.1
date	2002.10.29.00.28.03;	author art;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;

1.17.8.1
date	2006.01.13.00.49.21;	author brad;	state Exp;
branches;
next	;

1.17.10.1
date	2006.01.13.01.56.54;	author brad;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Push COMPAT_FREEBSD in front of a whale.  Buggy, out of date, no
one has been weeding it, and it makes life harder.

Toasts of Brennivin for its passing from many; diff ok henning@@
@
text
@/*	$OpenBSD: freebsd_machdep.c,v 1.22 2008/03/18 14:29:25 kettenis Exp $	*/
/*	$NetBSD: freebsd_machdep.c,v 1.10 1996/05/03 19:42:05 christos Exp $	*/

/*-
 * Copyright (c) 1993, 1994, 1995, 1996 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1992 Terrence R. Lambert.
 * Copyright (c) 1982, 1987, 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)machdep.c	7.4 (Berkeley) 6/3/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/exec.h>
#include <sys/mount.h>

#include <uvm/uvm_extern.h>

#include <machine/cpufunc.h>
#include <machine/npx.h>
#include <machine/reg.h>
#include <machine/vm86.h>
#include <machine/freebsd_machdep.h>

#include <compat/freebsd/freebsd_signal.h>
#include <compat/freebsd/freebsd_syscallargs.h>
#include <compat/freebsd/freebsd_exec.h>
#include <compat/freebsd/freebsd_ptrace.h>

/*
 * signal support
 */

/*
 * Send an interrupt to process.
 *
 * Stack is set up to allow sigcode stored
 * in u. to call routine, followed by kcall
 * to sigreturn routine below.  After sigreturn
 * resets the signal mask, the stack, and the
 * frame pointer, it returns to the user
 * specified pc, psl.
 */
void
freebsd_sendsig(sig_t catcher, int sig, int mask, u_long code, int type,
    union sigval val)
{
	struct proc *p = curproc;
	struct trapframe *tf;
	struct freebsd_sigframe *fp, frame;
	struct sigacts *psp = p->p_sigacts;
	int oonstack;

	/*
	 * Build the argument list for the signal handler.
	 */
	frame.sf_signum = sig;

	tf = p->p_md.md_regs;
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;

	/*
	 * Allocate space for the signal handler context.
	 */
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct freebsd_sigframe *)((char *)psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size - sizeof(struct freebsd_sigframe));
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
	} else {
		fp = (struct freebsd_sigframe *)tf->tf_esp - 1;
	}

	frame.sf_code = code;
	frame.sf_scp = &fp->sf_sc;
	frame.sf_addr = (char *)rcr2();
	frame.sf_handler = catcher;

	/*
	 * Build the signal context to be used by sigreturn.
	 */
	frame.sf_sc.sc_onstack = oonstack;
	frame.sf_sc.sc_mask = mask;
#ifdef VM86
	if (tf->tf_eflags & PSL_VM) {
		frame.sf_sc.sc_es = tf->tf_vm86_es;
		frame.sf_sc.sc_ds = tf->tf_vm86_ds;
		frame.sf_sc.sc_eflags = get_vflags(p);
	} else
#endif
	{
		frame.sf_sc.sc_es = tf->tf_es;
		frame.sf_sc.sc_ds = tf->tf_ds;
		frame.sf_sc.sc_eflags = tf->tf_eflags;
	}
	frame.sf_sc.sc_edi = tf->tf_edi;
	frame.sf_sc.sc_esi = tf->tf_esi;
	frame.sf_sc.sc_ebp = tf->tf_ebp;
	frame.sf_sc.sc_isp = 0; /* don't have to pass kernel sp to user. */
	frame.sf_sc.sc_ebx = tf->tf_ebx;
	frame.sf_sc.sc_edx = tf->tf_edx;
	frame.sf_sc.sc_ecx = tf->tf_ecx;
	frame.sf_sc.sc_eax = tf->tf_eax;
	frame.sf_sc.sc_eip = tf->tf_eip;
	frame.sf_sc.sc_cs = tf->tf_cs;
	frame.sf_sc.sc_esp = tf->tf_esp;
	frame.sf_sc.sc_ss = tf->tf_ss;

	if (copyout(&frame, fp, sizeof(frame)) != 0) {
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}

	/*
	 * Build context to run handler in.
	 */
	tf->tf_es = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_ds = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_eip = p->p_sigcode;
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
	tf->tf_eflags &= ~(PSL_T|PSL_D|PSL_VM|PSL_AC);
	tf->tf_esp = (int)fp;
	tf->tf_ss = GSEL(GUDATA_SEL, SEL_UPL);
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper privileges or to cause
 * a machine fault.
 */
int
freebsd_sys_sigreturn(struct proc *p, void *v, register_t *retval)
{
	struct freebsd_sys_sigreturn_args /* {
		syscallarg(struct freebsd_sigcontext *) scp;
	} */ *uap = v;
	struct freebsd_sigcontext *scp, context;
	struct trapframe *tf;

	tf = p->p_md.md_regs;

	/*
	 * The trampoline code hands us the context.
	 * It is unsafe to keep track of it ourselves, in the event that a
	 * program jumps out of a signal handler.
	 */
	scp = SCARG(uap, scp);
	if (copyin((caddr_t)scp, &context, sizeof(*scp)) != 0)
		return (EFAULT);

	/*
	 * Restore signal context.
	 */
#ifdef VM86
	if (context.sc_eflags & PSL_VM) {
		tf->tf_vm86_es = context.sc_es;
		tf->tf_vm86_ds = context.sc_ds;
		set_vflags(p, context.sc_eflags);
	} else
#endif
	{
		/*
		 * Check for security violations.  If we're returning to
		 * protected mode, the CPU will validate the segment registers
		 * automatically and generate a trap on violations.  We handle
		 * the trap, rather than doing all of the checking here.
		 */
		if (((context.sc_eflags ^ tf->tf_eflags) & PSL_USERSTATIC) != 0 ||
		    !USERMODE(context.sc_cs, context.sc_eflags))
			return (EINVAL);

		tf->tf_es = context.sc_es;
		tf->tf_ds = context.sc_ds;
		tf->tf_eflags = context.sc_eflags;
	}
	tf->tf_edi = context.sc_edi;
	tf->tf_esi = context.sc_esi;
	tf->tf_ebp = context.sc_ebp;
	/* FreeBSD's context.sc_isp is useless. (`popal' ignores it.) */
	tf->tf_ebx = context.sc_ebx;
	tf->tf_edx = context.sc_edx;
	tf->tf_ecx = context.sc_ecx;
	tf->tf_eax = context.sc_eax;
	tf->tf_eip = context.sc_eip;
	tf->tf_cs = context.sc_cs;
	tf->tf_esp = context.sc_esp;
	tf->tf_ss = context.sc_ss;

	if (context.sc_onstack & 01)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = context.sc_mask & ~sigcantmask;

	return (EJUSTRETURN);
}


/*
 * freebsd_ptrace(2) support
 */

void
netbsd_to_freebsd_ptrace_regs(struct reg *nregs, struct fpreg *nfpregs,
    struct freebsd_ptrace_reg *fregs)
{
	struct save87 *nframe = (struct save87 *)nfpregs;

	fregs->freebsd_ptrace_regs.tf_es = nregs->r_es;
	fregs->freebsd_ptrace_regs.tf_ds = nregs->r_ds;
	fregs->freebsd_ptrace_regs.tf_edi = nregs->r_edi;
	fregs->freebsd_ptrace_regs.tf_esi = nregs->r_esi;
	fregs->freebsd_ptrace_regs.tf_ebp = nregs->r_ebp;
	fregs->freebsd_ptrace_regs.tf_isp = 0;
	fregs->freebsd_ptrace_regs.tf_ebx = nregs->r_ebx;
	fregs->freebsd_ptrace_regs.tf_edx = nregs->r_edx;
	fregs->freebsd_ptrace_regs.tf_ecx = nregs->r_ecx;
	fregs->freebsd_ptrace_regs.tf_eax = nregs->r_eax;
	fregs->freebsd_ptrace_regs.tf_trapno = 0;

	fregs->freebsd_ptrace_regs.tf_err = 0;
	fregs->freebsd_ptrace_regs.tf_eip = nregs->r_eip;
	fregs->freebsd_ptrace_regs.tf_cs = nregs->r_cs;
	fregs->freebsd_ptrace_regs.tf_eflags = nregs->r_eflags;

	fregs->freebsd_ptrace_regs.tf_esp = nregs->r_esp;
	fregs->freebsd_ptrace_regs.tf_ss = nregs->r_ss;

	fregs->freebsd_ptrace_fpregs.sv_env =
		*(struct freebsd_env87 *)&nframe->sv_env;
	bcopy(nframe->sv_ac, fregs->freebsd_ptrace_fpregs.sv_ac,
	      sizeof(fregs->freebsd_ptrace_fpregs.sv_ac));
	fregs->freebsd_ptrace_fpregs.sv_ex_sw =
		nframe->sv_ex_sw;
#if 0
	/*
	 * fortunately, sizeof(freebsd_save87) >= sizeof(save87)
	 */
#ifdef DIAGNOSTIC
	if (sizeof(fregs->freebsd_ptrace_fpregs.sv_pad) <
	    sizeof(nframe->sv_ex_tw) + sizeof(nframe->sv_pad)) {
		panic("netbsd_to_freebsd_ptrace_regs: %s",
		      "sizeof(freebsd_save87) >= sizeof(save87)");
	}
#endif
#endif
	bcopy(&nframe->sv_ex_tw, fregs->freebsd_ptrace_fpregs.sv_pad,
	      sizeof(nframe->sv_ex_tw));
#if 0
	bcopy(nframe->sv_pad,
	      (caddr_t)fregs->freebsd_ptrace_fpregs.sv_pad +
	      sizeof(nframe->sv_ex_tw),
	      sizeof(nframe->sv_pad));
	bzero((caddr_t)fregs->freebsd_ptrace_fpregs.sv_pad +
	      sizeof(nframe->sv_ex_tw) + sizeof(nframe->sv_pad),
	      sizeof(fregs->freebsd_ptrace_fpregs.sv_pad) -
	      sizeof(nframe->sv_ex_tw) - sizeof(nframe->sv_pad));
#endif
}

void
freebsd_to_netbsd_ptrace_regs(struct freebsd_ptrace_reg *fregs,
    struct reg *nregs, struct fpreg *nfpregs)
{
	struct save87 *nframe = (struct save87 *)nfpregs;

	nregs->r_es = fregs->freebsd_ptrace_regs.tf_es;
	nregs->r_ds = fregs->freebsd_ptrace_regs.tf_ds;
	nregs->r_edi = fregs->freebsd_ptrace_regs.tf_edi;
	nregs->r_esi = fregs->freebsd_ptrace_regs.tf_esi;
	nregs->r_ebp = fregs->freebsd_ptrace_regs.tf_ebp;
	nregs->r_ebx = fregs->freebsd_ptrace_regs.tf_ebx;
	nregs->r_edx = fregs->freebsd_ptrace_regs.tf_edx;
	nregs->r_ecx = fregs->freebsd_ptrace_regs.tf_ecx;
	nregs->r_eax = fregs->freebsd_ptrace_regs.tf_eax;

	nregs->r_eip = fregs->freebsd_ptrace_regs.tf_eip;
	nregs->r_cs = fregs->freebsd_ptrace_regs.tf_cs;
	nregs->r_eflags = fregs->freebsd_ptrace_regs.tf_eflags;

	nregs->r_esp = fregs->freebsd_ptrace_regs.tf_esp;
	nregs->r_ss = fregs->freebsd_ptrace_regs.tf_ss;

	nframe->sv_env =
		*(struct env87 *)&fregs->freebsd_ptrace_fpregs.sv_env;
	bcopy(fregs->freebsd_ptrace_fpregs.sv_ac, nframe->sv_ac,
	      sizeof(nframe->sv_ac));
	nframe->sv_ex_sw =
		fregs->freebsd_ptrace_fpregs.sv_ex_sw;
	/*
	 * fortunately, sizeof(freebsd_save87) >= sizeof(save87)
	 */
	bcopy(fregs->freebsd_ptrace_fpregs.sv_pad, &nframe->sv_ex_tw,
	      sizeof(nframe->sv_ex_tw));
#if 0
	bcopy((caddr_t)fregs->freebsd_ptrace_fpregs.sv_pad +
	      sizeof(nframe->sv_ex_tw),
	      nframe->sv_pad, sizeof(nframe->sv_pad));
#endif
}

/* random value, except FREEBSD_U_AR0_OFFSET..., FREEBSD_U_SAVEFP_OFFSET... */
#define	FREEBSD_REGS_OFFSET 0x2000

int
freebsd_ptrace_getregs(struct freebsd_ptrace_reg *fregs, caddr_t addr,
    register_t *datap)
{
	vaddr_t offset = (vaddr_t)addr;

	if (offset == FREEBSD_U_AR0_OFFSET) {
		*datap = FREEBSD_REGS_OFFSET + FREEBSD_USRSTACK;
		return 0;
	} else if (offset >= FREEBSD_REGS_OFFSET &&
		   offset <= FREEBSD_REGS_OFFSET +
		      sizeof(fregs->freebsd_ptrace_regs)-sizeof(register_t)) {
		*datap = *(register_t *)&((caddr_t)&fregs->freebsd_ptrace_regs)
			[(vaddr_t) addr - FREEBSD_REGS_OFFSET];
		return 0;
	} else if (offset >= FREEBSD_U_SAVEFP_OFFSET &&
		   offset <= FREEBSD_U_SAVEFP_OFFSET +
		      sizeof(fregs->freebsd_ptrace_fpregs)-sizeof(register_t)){
		*datap= *(register_t *)&((caddr_t)&fregs->freebsd_ptrace_fpregs)
			[offset - FREEBSD_U_SAVEFP_OFFSET];
		return 0;
	}
#ifdef DIAGNOSTIC
	printf("freebsd_ptrace_getregs: *(0x%08lx)\n", offset);
#endif
	return EFAULT;
}

int
freebsd_ptrace_setregs(struct freebsd_ptrace_reg *fregs, caddr_t addr, int data)
{
	vaddr_t offset = (vaddr_t)addr;

	if (offset >= FREEBSD_REGS_OFFSET &&
	    offset <= FREEBSD_REGS_OFFSET +
			sizeof(fregs->freebsd_ptrace_regs) - sizeof(int)) {
		*(int *)&((caddr_t)&fregs->freebsd_ptrace_regs)
			[offset - FREEBSD_REGS_OFFSET] = data;
		return 0;
	} else if (offset >= FREEBSD_U_SAVEFP_OFFSET &&
		   offset <= FREEBSD_U_SAVEFP_OFFSET +
			sizeof(fregs->freebsd_ptrace_fpregs) - sizeof(int)) {
		*(int *)&((caddr_t)&fregs->freebsd_ptrace_fpregs)
			[offset - FREEBSD_U_SAVEFP_OFFSET] = data;
		return 0;
	}
#ifdef DIAGNOSTIC
	printf("freebsd_ptrace_setregs: *(0x%08lx) = 0x%08x\n", offset, data);
#endif
	return EFAULT;
}
@


1.22
log
@Clear PSL_D when entering signal handlers; pointed out by dfly people;

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.21 2006/12/29 13:04:36 pedro Exp $	*/
@


1.21
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.20 2006/09/19 11:06:33 jsg Exp $	*/
d156 1
a156 1
	tf->tf_eflags &= ~(PSL_T|PSL_VM|PSL_AC);
@


1.20
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.19 2006/05/11 13:21:11 mickey Exp $	*/
d98 1
a98 1
		fp = (struct freebsd_sigframe *)(psp->ps_sigstk.ss_sp +
@


1.19
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.18 2006/01/12 22:39:20 weingart Exp $	*/
d76 2
a77 6
freebsd_sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
d79 2
a80 2
	register struct proc *p = curproc;
	register struct trapframe *tf;
d172 1
a172 4
freebsd_sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d178 1
a178 1
	register struct trapframe *tf;
d244 2
a245 4
netbsd_to_freebsd_ptrace_regs(nregs, nfpregs, fregs)
	struct reg *nregs;
	struct fpreg *nfpregs;
	struct freebsd_ptrace_reg *fregs;
d302 2
a303 4
freebsd_to_netbsd_ptrace_regs(fregs, nregs, nfpregs)
	struct freebsd_ptrace_reg *fregs;
	struct reg *nregs;
	struct fpreg *nfpregs;
d374 1
a374 4
freebsd_ptrace_setregs(fregs, addr, data)
	struct freebsd_ptrace_reg *fregs;
	caddr_t addr;
	int data;
@


1.18
log
@Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.17 2003/06/02 23:27:47 millert Exp $	*/
d89 1
a89 1
	/* 
d282 1
a282 1
	fregs->freebsd_ptrace_fpregs.sv_ex_sw = 
d366 1
a366 1
		   offset <= FREEBSD_REGS_OFFSET + 
d372 1
a372 1
		   offset <= FREEBSD_U_SAVEFP_OFFSET + 
d399 1
a399 1
		   offset <= FREEBSD_U_SAVEFP_OFFSET + 
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.16 2003/05/13 03:49:04 art Exp $	*/
a83 1
	struct pmap *pmap = vm_map_pmap(&p->p_vmspace->vm_map);
d159 1
a159 2
	tf->tf_cs = pmap->pm_hiexec > I386_MAX_EXE_ADDR ? 
	    GSEL(GUCODE1_SEL, SEL_UPL) : GSEL(GUCODE_SEL, SEL_UPL);
@


1.17.10.1
log
@MFC:
Fix by weingart@@

Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.17 2003/06/02 23:27:47 millert Exp $	*/
d84 1
d160 2
a161 1
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
@


1.17.8.1
log
@MFC:
Fix by weingart@@

Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.17 2003/06/02 23:27:47 millert Exp $	*/
d84 1
d160 2
a161 1
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
@


1.16
log
@The current solution to handle the protection fault trap is not
correct.  It breaks down if we're trying to jump through a function
pointer. The protection fault trap on i386 must be one of the most
braindead traps ever invented in the history of humankind. It doesn't
give you any information about what went wrong except the instruction
that faulted. Since the problem we're trying to deal with is a
segmentation problem, we don't get the desitination that we want to
jump to, we just get the instruction and we won't add a disassembler
to trap handling just to try to figure out what went wrong.

What we want to do is to handle this as a normal fault to let noexec
accounting in pmap_enter deal with the changes to the code
segment. Unfortunately that's impossible. We don't know the faulting
address, so we need to change how the exec accounting works. Basically
the code segment must already cover the address we want to execute
before we can fault it in.

New scheme:

 o Start with conservative code segment.

 o If we get a protection fault, go through all mappings in the process
  and find the highest executable mapping, fix up the code segment and
  record that address. If the code segment didn't change, the protection
  fault wasn't fixable - just die.

 o If the highest executable mapping is removed, just reset the code
  segment to something conservative and let the next protection fault
  deal with it.  We can't read all the vm mappings of the process from
  the pmap because of locking hell.

This should allow floating code segment whenever someone implements that.

Also, fix the pmap_protect function to behave more like the other
pmaps we have and be slightly more agressive to force more proper
protection changes.

ok:ed by various people.
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.15 2003/05/04 05:01:04 drahn Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.15
log
@Set code segment register according to nxpages, copied from machdep.c
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.14 2003/01/16 04:15:17 art Exp $	*/
d164 1
a164 1
	tf->tf_cs = pmap->pm_nxpages > 0?
@


1.14
log
@Getting rid of vm_offset_t
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.13 2002/07/20 19:24:56 art Exp $	*/
d88 1
d164 2
a165 1
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
@


1.13
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.12 2001/11/06 19:53:14 miod Exp $	*/
d361 2
a362 4
freebsd_ptrace_getregs(fregs, addr, datap)
	struct freebsd_ptrace_reg *fregs;
	caddr_t addr;
	register_t *datap;
d364 1
a364 1
	vm_offset_t offset = (vm_offset_t)addr;
d373 1
a373 1
			[(vm_offset_t) addr - FREEBSD_REGS_OFFSET];
d394 1
a394 1
	vm_offset_t offset = (vm_offset_t)addr;
@


1.12
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.11 2001/02/03 02:46:28 mickey Exp $	*/
a91 1
	extern char freebsd_sigcode[], freebsd_esigcode[];
d162 1
a162 2
	tf->tf_eip = (int)(((char *)PS_STRINGS) - 
	     (freebsd_esigcode - freebsd_sigcode));
@


1.12.2.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.12 2001/11/06 19:53:14 miod Exp $	*/
d92 1
d163 2
a164 1
	tf->tf_eip = p->p_sigcode;
@


1.12.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a87 1
	struct pmap *pmap = vm_map_pmap(&p->p_vmspace->vm_map);
d163 1
a163 2
	tf->tf_cs = pmap->pm_hiexec > I386_MAX_EXE_ADDR ? 
	    GSEL(GUCODE1_SEL, SEL_UPL) : GSEL(GUCODE_SEL, SEL_UPL);
d361 4
a364 2
freebsd_ptrace_getregs(struct freebsd_ptrace_reg *fregs, caddr_t addr,
    register_t *datap)
d366 1
a366 1
	vaddr_t offset = (vaddr_t)addr;
d375 1
a375 1
			[(vaddr_t) addr - FREEBSD_REGS_OFFSET];
d396 1
a396 1
	vaddr_t offset = (vaddr_t)addr;
@


1.11
log
@make it compile
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.10 1999/01/11 05:11:23 millert Exp $	*/
d52 1
a52 1
#include <vm/vm.h>
@


1.10
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.9 1997/02/01 21:53:18 deraadt Exp $	*/
d60 1
@


1.10.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.11 2001/02/03 02:46:28 mickey Exp $	*/
a59 1
#include <compat/freebsd/freebsd_signal.h>
@


1.10.6.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
a52 1
#include <uvm/uvm_extern.h>
@


1.10.6.3
log
@Sync the SMP branch with 3.3
@
text
@d92 1
d163 2
a164 1
	tf->tf_eip = p->p_sigcode;
d363 4
a366 2
freebsd_ptrace_getregs(struct freebsd_ptrace_reg *fregs, caddr_t addr,
    register_t *datap)
d368 1
a368 1
	vaddr_t offset = (vaddr_t)addr;
d377 1
a377 1
			[(vaddr_t) addr - FREEBSD_REGS_OFFSET];
d398 1
a398 1
	vaddr_t offset = (vaddr_t)addr;
@


1.10.6.4
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.10.6.3 2003/03/27 23:26:55 niklas Exp $	*/
a87 1
	struct pmap *pmap = vm_map_pmap(&p->p_vmspace->vm_map);
d163 1
a163 2
	tf->tf_cs = pmap->pm_nxpages > 0?
	    GSEL(GUCODE1_SEL, SEL_UPL) : GSEL(GUCODE_SEL, SEL_UPL);
@


1.10.6.5
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d164 1
a164 1
	tf->tf_cs = pmap->pm_hiexec > I386_MAX_EXE_ADDR ? 
@


1.10.6.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.10.6.5 2003/05/16 00:29:39 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9
log
@add type & union sigval args to sendsig/trapsignal
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.8 1997/01/27 22:47:57 deraadt Exp $	*/
d296 1
a296 1
		panic("netbsd_to_freebsd_ptrace_regs: %s\n",
@


1.8
log
@add another parameter to trapsignal() and sendsig() -- fault addr to be
delivered with in the siginfo information
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.7 1996/08/27 10:46:51 downsj Exp $	*/
d79 1
a79 1
freebsd_sendsig(catcher, sig, mask, code, addr)
d83 2
a84 1
	caddr_t addr;
@


1.7
log
@Add:
	* GPL_MATH_EMULATE: fpemul
	* ALWAYS_MATH_EMULATE: causes npx probe to always fail.
	* better fp context in struct pcb.
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.6 1996/05/07 07:21:37 deraadt Exp $	*/
d79 1
a79 1
freebsd_sendsig(catcher, sig, mask, code)
d83 1
@


1.6
log
@sync with 0504; prototype changes
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_machdep.c,v 1.4 1996/04/21 22:16:26 deraadt Exp $	*/
d287 1
d298 1
d301 1
d310 1
d349 1
d353 1
@


1.5
log
@Turn off the alignment check flag when entering a signal handler
@
text
@d2 1
a2 1
/*	$NetBSD: freebsd_machdep.c,v 1.9 1996/04/18 08:36:20 mycroft Exp $	*/
d378 1
a378 1
	printf("freebsd_ptrace_getregs: *(0x%08x)\n", offset);
d405 1
a405 1
	printf("freebsd_ptrace_setregs: *(0x%08x) = 0x%08x\n", offset, data);
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: freebsd_machdep.c,v 1.3 1996/04/17 05:18:51 mickey Exp $	*/
/*	$NetBSD: freebsd_machdep.c,v 1.8 1996/04/12 08:44:35 mycroft Exp $	*/
d163 1
a163 1
	tf->tf_eflags &= ~(PSL_T|PSL_VM);
@


1.3
log
@Cleanups & fixes from latest NetBSD primarily to run doscmd, etc.
GENERIC added to the compile/.cvsignore (it is used for 'make links'
for example), thus conf/GENERIC should appear magically ...
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: freebsd_machdep.c,v 1.7 1996/04/11 07:47:44 mycroft Exp $	*/
a125 1
		tf->tf_eflags &= ~PSL_VM;
d163 1
@


1.2
log
@ss_sp is correct, ss_base is not. noticed by agc@@sde.uts.amdahl.com; netbsd pr#1784
@
text
@d1 2
a2 1
/*	$NetBSD: freebsd_machdep.c,v 1.5 1996/01/04 22:21:55 jtc Exp $	*/
d5 1
a5 1
 * Copyright (c) 1993, 1994, 1995 Charles M. Hannum.  All rights reserved.
d48 1
d57 1
d125 2
d132 1
d134 12
a145 13
	frame.sf_sc.sc_edi    = tf->tf_edi;
	frame.sf_sc.sc_esi    = tf->tf_esi;
	frame.sf_sc.sc_ebp    = tf->tf_ebp;
	frame.sf_sc.sc_isp    = 0; /* don't have to pass kernel sp to user. */
	frame.sf_sc.sc_ebx    = tf->tf_ebx;
	frame.sf_sc.sc_edx    = tf->tf_edx;
	frame.sf_sc.sc_ecx    = tf->tf_ecx;
	frame.sf_sc.sc_eax    = tf->tf_eax;
	frame.sf_sc.sc_eip    = tf->tf_eip;
	frame.sf_sc.sc_cs     = tf->tf_cs;
	frame.sf_sc.sc_eflags = tf->tf_eflags;
	frame.sf_sc.sc_esp    = tf->tf_esp;
	frame.sf_sc.sc_ss     = tf->tf_ss;
d159 2
a160 1
	tf->tf_esp = (int)fp;
a162 3
#ifdef VM86
	tf->tf_eflags &= ~PSL_VM;
#endif
d164 1
a164 2
	tf->tf_ds = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_es = GSEL(GUDATA_SEL, SEL_UPL);
d178 1
a201 16
	 * Check for security violations.  If we're returning to protected
	 * mode, the CPU will validate the segment registers automatically
	 * and generate a trap on violations.  We handle the trap, rather
	 * than doing all of the checking here.
	 */
	if (((context.sc_eflags ^ tf->tf_eflags) & PSL_USERSTATIC) != 0 ||
	    !USERMODE(context.sc_cs, context.sc_eflags))
		return (EINVAL);

	if (context.sc_onstack & 01)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = context.sc_mask & ~sigcantmask;

	/*
d208 1
d212 10
d224 1
d226 3
a228 3
	tf->tf_edi    = context.sc_edi;
	tf->tf_esi    = context.sc_esi;
	tf->tf_ebp    = context.sc_ebp;
d230 14
a243 9
	tf->tf_ebx    = context.sc_ebx;
	tf->tf_edx    = context.sc_edx;
	tf->tf_ecx    = context.sc_ecx;
	tf->tf_eax    = context.sc_eax;
	tf->tf_eip    = context.sc_eip;
	tf->tf_cs     = context.sc_cs;
	tf->tf_eflags = context.sc_eflags;
	tf->tf_esp    = context.sc_esp;
	tf->tf_ss     = context.sc_ss;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: freebsd_machdep.c,v 1.4 1995/10/10 04:54:18 mycroft Exp $	*/
d101 1
a101 1
		fp = (struct freebsd_sigframe *)(psp->ps_sigstk.ss_base +
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
