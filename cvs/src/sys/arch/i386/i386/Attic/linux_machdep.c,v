head	1.47;
access;
symbols
	OPENBSD_5_9:1.46.0.4
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.46.0.6
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.43.0.10
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.43.0.6
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.4
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.2
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.2
	OPENBSD_5_0:1.41.0.2
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.35.0.12
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.10
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.6
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.8
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.4
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.34.0.6
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.34.0.4
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.30.0.6
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.30.0.4
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	SMP_SYNC_A:1.29
	SMP_SYNC_B:1.29
	OPENBSD_3_5:1.29.0.4
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.23
	UBC:1.17.0.4
	UBC_BASE:1.17
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_8:1.14.0.4
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	SMP:1.12.0.8
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.6
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.47
date	2016.03.01.16.12.40;	author naddy;	state dead;
branches;
next	1.46;
commitid	EdchA0ejb7OS0o5l;

1.46
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.45;
commitid	P6Av4XGqOi3rFasL;

1.45
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.44;

1.44
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.42;

1.42
date	2011.11.07.15.41.33;	author guenther;	state Exp;
branches;
next	1.41;

1.41
date	2011.08.03.16.11.31;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.05.04.48.01;	author guenther;	state Exp;
branches;
next	1.39;

1.39
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.38;

1.38
date	2011.04.15.04.52.39;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2011.04.05.13.54.42;	author pirofti;	state Exp;
branches;
next	1.36;

1.36
date	2011.04.04.21.50.41;	author pirofti;	state Exp;
branches;
next	1.35;

1.35
date	2008.03.18.14.29.25;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2007.02.14.00.53.47;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.32;

1.32
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.12.22.39.20;	author weingart;	state Exp;
branches;
next	1.30;

1.30
date	2004.07.02.16.29.55;	author niklas;	state Exp;
branches
	1.30.4.1
	1.30.6.1;
next	1.29;

1.29
date	2003.08.15.20.32.13;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.13.03.49.04;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2003.05.04.05.01.04;	author drahn;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.17.03.42.14;	author drahn;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.28.00.49.13;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.01.09.22.27.09;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.20.19.24.56;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2002.04.19.21.28.58;	author jasoni;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.13.20.43.42;	author jasoni;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.06.01.55.04;	author jasoni;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.16.20.50.16;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.27.06.10.38;	author csapuntz;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	2001.05.01.19.15.16;	author aaron;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.07.21.31.24;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.28.06.35.57;	author jasoni;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.23.17.17.32;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	98.07.09.18.22.12;	author deraadt;	state Exp;
branches
	1.12.8.1;
next	1.11;

1.11
date	98.02.08.08.32.34;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.02.01.21.53.20;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.01.27.22.47.58;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.07.07.21.42;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.05.02.13.41.16;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.16.28;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.18.19.18.09;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.04.17.05.18.53;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.03.11.11.16.48;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.01.05.16.17.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.33;	author deraadt;	state Exp;
branches;
next	;

1.12.8.1
date	2000.03.24.09.07.38;	author niklas;	state Exp;
branches;
next	1.12.8.2;

1.12.8.2
date	2001.04.18.16.07.19;	author niklas;	state Exp;
branches;
next	1.12.8.3;

1.12.8.3
date	2001.07.04.10.16.35;	author niklas;	state Exp;
branches;
next	1.12.8.4;

1.12.8.4
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.12.8.5;

1.12.8.5
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.12.8.6;

1.12.8.6
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.12.8.7;

1.12.8.7
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.12.8.8;

1.12.8.8
date	2003.05.13.19.42.07;	author ho;	state Exp;
branches;
next	1.12.8.9;

1.12.8.9
date	2003.05.16.00.29.39;	author niklas;	state Exp;
branches;
next	1.12.8.10;

1.12.8.10
date	2004.02.19.10.48.41;	author niklas;	state Exp;
branches;
next	;

1.17.4.1
date	2002.01.31.22.55.11;	author niklas;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	1.17.4.3;

1.17.4.3
date	2002.10.29.00.28.03;	author art;	state Exp;
branches;
next	1.17.4.4;

1.17.4.4
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;

1.30.4.1
date	2006.01.13.00.49.21;	author brad;	state Exp;
branches;
next	;

1.30.6.1
date	2006.01.13.01.56.54;	author brad;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Support for running Linux binaries under emulation is going away.

Remove "option COMPAT_LINUX" and everything directly tied to it from the
kernel and the corresponding man page documentation.

ok visa@@ guenther@@
@
text
@/*	$OpenBSD: linux_machdep.c,v 1.46 2014/12/16 18:30:03 tedu Exp $	*/
/*	$NetBSD: linux_machdep.c,v 1.29 1996/05/03 19:42:11 christos Exp $	*/

/*
 * Copyright (c) 1995 Frank van der Linden
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project
 *      by Frank van der Linden
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/msgbuf.h>
#include <sys/mount.h>
#include <sys/device.h>
#include <sys/sysctl.h>
#include <sys/syscallargs.h>
#include <sys/filedesc.h>

#include <uvm/uvm_extern.h>

#include <compat/linux/linux_types.h>
#include <compat/linux/linux_signal.h>
#include <compat/linux/linux_syscallargs.h>
#include <compat/linux/linux_util.h>
#include <compat/linux/linux_ioctl.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/psl.h>
#include <machine/reg.h>
#include <machine/segments.h>
#include <machine/specialreg.h>
#include <machine/sysarch.h>
#include <machine/vm86.h>
#include <machine/linux_machdep.h>

/*
 * To see whether wsdisplay is configured (for virtual console ioctl calls).
 */
#include "wsdisplay.h"
#include <sys/ioctl.h>
#if NWSDISPLAY > 0 && defined(WSDISPLAY_COMPAT_USL)
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplay_usl_io.h>
#endif

#ifdef USER_LDT
#include <machine/cpu.h>
int linux_read_ldt(struct proc *, struct linux_sys_modify_ldt_args *,
    register_t *);
int linux_write_ldt(struct proc *, struct linux_sys_modify_ldt_args *,
    register_t *);
#endif

/*
 * Deal with some i386-specific things in the Linux emulation code.
 * This means just signals for now, will include stuff like
 * I/O map permissions and V86 mode sometime.
 */

/*
 * Send an interrupt to process.
 *
 * Stack is set up to allow sigcode stored
 * in u. to call routine, followed by kcall
 * to sigreturn routine below.  After sigreturn
 * resets the signal mask, the stack, and the
 * frame pointer, it returns to the user
 * specified pc, psl.
 */

void
linux_sendsig(sig_t catcher, int sig, int mask, u_long code, int type,
    union sigval val)
{
	struct proc *p = curproc;
	struct trapframe *tf;
	struct linux_sigframe *fp, frame;
	struct sigacts *psp = p->p_p->ps_sigacts;
	int oonstack;

	tf = p->p_md.md_regs;
	oonstack = p->p_sigstk.ss_flags & SS_ONSTACK;

	/*
	 * Allocate space for the signal handler context.
	 */
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !oonstack &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct linux_sigframe *)((char *)p->p_sigstk.ss_sp +
		    p->p_sigstk.ss_size - sizeof(struct linux_sigframe));
		p->p_sigstk.ss_flags |= SS_ONSTACK;
	} else {
		fp = (struct linux_sigframe *)tf->tf_esp - 1;
	}

	frame.sf_handler = catcher;
	frame.sf_sig = bsd_to_linux_sig[sig];

	/*
	 * Build the signal context to be used by sigreturn.
	 */
	frame.sf_sc.sc_mask   = mask;
#ifdef VM86
	if (tf->tf_eflags & PSL_VM) {
		frame.sf_sc.sc_gs = tf->tf_vm86_gs;
		frame.sf_sc.sc_fs = tf->tf_vm86_fs;
		frame.sf_sc.sc_es = tf->tf_vm86_es;
		frame.sf_sc.sc_ds = tf->tf_vm86_ds;
		frame.sf_sc.sc_eflags = get_vflags(p);
	} else
#endif
	{
		frame.sf_sc.sc_fs = tf->tf_fs;
		frame.sf_sc.sc_gs = tf->tf_gs;
		frame.sf_sc.sc_es = tf->tf_es;
		frame.sf_sc.sc_ds = tf->tf_ds;
		frame.sf_sc.sc_eflags = tf->tf_eflags;
	}
	frame.sf_sc.sc_edi = tf->tf_edi;
	frame.sf_sc.sc_esi = tf->tf_esi;
	frame.sf_sc.sc_ebp = tf->tf_ebp;
	frame.sf_sc.sc_ebx = tf->tf_ebx;
	frame.sf_sc.sc_edx = tf->tf_edx;
	frame.sf_sc.sc_ecx = tf->tf_ecx;
	frame.sf_sc.sc_eax = tf->tf_eax;
	frame.sf_sc.sc_eip = tf->tf_eip;
	frame.sf_sc.sc_cs = tf->tf_cs;
	frame.sf_sc.sc_esp_at_signal = tf->tf_esp;
	frame.sf_sc.sc_ss = tf->tf_ss;
	frame.sf_sc.sc_err = tf->tf_err;
	frame.sf_sc.sc_trapno = tf->tf_trapno;

	if (copyout(&frame, fp, sizeof(frame)) != 0) {
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}

	/*
	 * Build context to run handler in.
	 */
	tf->tf_es = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_ds = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_eip = p->p_p->ps_sigcode;
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
	tf->tf_eflags &= ~(PSL_T|PSL_D|PSL_VM|PSL_AC);
	tf->tf_esp = (int)fp;
	tf->tf_ss = GSEL(GUDATA_SEL, SEL_UPL);
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper privileges or to cause
 * a machine fault.
 */
int
linux_sys_sigreturn(struct proc *p, void *v, register_t *retval)
{
	struct linux_sys_sigreturn_args /* {
		syscallarg(struct linux_sigcontext *) scp;
	} */ *uap = v;
	struct linux_sigcontext *scp, context;
	struct trapframe *tf;

	tf = p->p_md.md_regs;

	/*
	 * The trampoline code hands us the context.
	 * It is unsafe to keep track of it ourselves, in the event that a
	 * program jumps out of a signal handler.
	 */
	scp = SCARG(uap, scp);
	if (copyin((caddr_t)scp, &context, sizeof(*scp)) != 0)
		return (EFAULT);

	/*
	 * Restore signal context.
	 */
#ifdef VM86
	if (context.sc_eflags & PSL_VM) {
		tf->tf_vm86_gs = context.sc_gs;
		tf->tf_vm86_fs = context.sc_fs;
		tf->tf_vm86_es = context.sc_es;
		tf->tf_vm86_ds = context.sc_ds;
		set_vflags(p, context.sc_eflags);
	} else
#endif
	{
		/*
		 * Check for security violations.  If we're returning to
		 * protected mode, the CPU will validate the segment registers
		 * automatically and generate a trap on violations.  We handle
		 * the trap, rather than doing all of the checking here.
		 */
		if (((context.sc_eflags ^ tf->tf_eflags) & PSL_USERSTATIC) != 0 ||
		    !USERMODE(context.sc_cs, context.sc_eflags))
			return (EINVAL);

		tf->tf_fs = context.sc_fs;
		tf->tf_gs = context.sc_gs;
		tf->tf_es = context.sc_es;
		tf->tf_ds = context.sc_ds;
		tf->tf_eflags = context.sc_eflags;
	}
	tf->tf_edi = context.sc_edi;
	tf->tf_esi = context.sc_esi;
	tf->tf_ebp = context.sc_ebp;
	tf->tf_ebx = context.sc_ebx;
	tf->tf_edx = context.sc_edx;
	tf->tf_ecx = context.sc_ecx;
	tf->tf_eax = context.sc_eax;
	tf->tf_eip = context.sc_eip;
	tf->tf_cs = context.sc_cs;
	tf->tf_esp = context.sc_esp_at_signal;
	tf->tf_ss = context.sc_ss;

	p->p_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = context.sc_mask & ~sigcantmask;

	return (EJUSTRETURN);
}

int
linux_sys_rt_sigreturn(struct proc *p, void *v, register_t *retval)
{
	return(ENOSYS);
}

#ifdef USER_LDT

int
linux_read_ldt(struct proc *p, struct linux_sys_modify_ldt_args *uap,
    register_t *retval)
{
	struct i386_get_ldt_args gl;
	int error;
	caddr_t sg;
	char *parms;

	if (user_ldt_enable == 0)
		return (ENOSYS);

	sg = stackgap_init(p);

	gl.start = 0;
	gl.desc = SCARG(uap, ptr);
	gl.num = SCARG(uap, bytecount) / sizeof(union descriptor);

	parms = stackgap_alloc(&sg, sizeof(gl));

	if ((error = copyout(&gl, parms, sizeof(gl))) != 0)
		return (error);

	if ((error = i386_get_ldt(p, parms, retval)) != 0)
		return (error);

	*retval *= sizeof(union descriptor);
	return (0);
}

struct linux_ldt_info {
	u_int entry_number;
	u_long base_addr;
	u_int limit;
	u_int seg_32bit:1;
	u_int contents:2;
	u_int read_exec_only:1;
	u_int limit_in_pages:1;
	u_int seg_not_present:1;
};

int
linux_write_ldt(struct proc *p, struct linux_sys_modify_ldt_args *uap,
    register_t *retval)
{
	struct linux_ldt_info ldt_info;
	struct segment_descriptor sd;
	struct i386_set_ldt_args sl;
	int error;
	caddr_t sg;
	char *parms;

	if (user_ldt_enable == 0)
		return (ENOSYS);

	if (SCARG(uap, bytecount) != sizeof(ldt_info))
		return (EINVAL);
	if ((error = copyin(SCARG(uap, ptr), &ldt_info, sizeof(ldt_info))) != 0)
		return error;
	if (ldt_info.contents == 3)
		return (EINVAL);

	sg = stackgap_init(p);

	sd.sd_lobase = ldt_info.base_addr & 0xffffff;
	sd.sd_hibase = (ldt_info.base_addr >> 24) & 0xff;
	sd.sd_lolimit = ldt_info.limit & 0xffff;
	sd.sd_hilimit = (ldt_info.limit >> 16) & 0xf;
	sd.sd_type =
	    16 | (ldt_info.contents << 2) | (!ldt_info.read_exec_only << 1);
	sd.sd_dpl = SEL_UPL;
	sd.sd_p = !ldt_info.seg_not_present;
	sd.sd_def32 = ldt_info.seg_32bit;
	sd.sd_gran = ldt_info.limit_in_pages;

	sl.start = ldt_info.entry_number;
	sl.desc = stackgap_alloc(&sg, sizeof(sd));
	sl.num = 1;

#if 0
	printf("linux_write_ldt: idx=%d, base=%x, limit=%x\n",
	    ldt_info.entry_number, ldt_info.base_addr, ldt_info.limit);
#endif

	parms = stackgap_alloc(&sg, sizeof(sl));

	if ((error = copyout(&sd, sl.desc, sizeof(sd))) != 0)
		return (error);
	if ((error = copyout(&sl, parms, sizeof(sl))) != 0)
		return (error);

	if ((error = i386_set_ldt(p, parms, retval)) != 0)
		return (error);

	*retval = 0;
	return (0);
}

#endif /* USER_LDT */

int
linux_sys_modify_ldt(struct proc *p, void *v, register_t *retval)
{
	struct linux_sys_modify_ldt_args /* {
		syscallarg(int) func;
		syscallarg(void *) ptr;
		syscallarg(size_t) bytecount;
	} */ *uap = v;

	switch (SCARG(uap, func)) {
#ifdef USER_LDT
	case 0:
		return (linux_read_ldt(p, uap, retval));

	case 1:
		return (linux_write_ldt(p, uap, retval));
#endif /* USER_LDT */

	default:
		return (ENOSYS);
	}
}

/*
 * XXX Pathetic hack to make svgalib work. This will fake the major
 * device number of an opened VT so that svgalib likes it. grmbl.
 * Should probably do it 'wrong the right way' and use a mapping
 * array for all major device numbers, and map linux_mknod too.
 */
dev_t
linux_fakedev(dev_t dev)
{

	if (major(dev) == NATIVE_CONS_MAJOR)
		return makedev(LINUX_CONS_MAJOR, (minor(dev) + 1));
	return dev;
}

/*
 * We come here in a last attempt to satisfy a Linux ioctl() call
 */
int
linux_machdepioctl(struct proc *p, void *v, register_t *retval)
{
	struct linux_sys_ioctl_args /* {
		syscallarg(int) fd;
		syscallarg(u_long) com;
		syscallarg(caddr_t) data;
	} */ *uap = v;
	struct sys_ioctl_args bia;
	u_long com;
	int error;
#if (NWSDISPLAY > 0 && defined(WSDISPLAY_COMPAT_USL))
	struct vt_mode lvt;
	caddr_t bvtp, sg;
#endif
	struct filedesc *fdp;
	struct file *fp;
	int fd;
	int (*ioctlf)(struct file *, u_long, caddr_t, struct proc *);
	struct ioctl_pt pt;

	fd = SCARG(uap, fd);
	SCARG(&bia, fd) = SCARG(uap, fd);
	SCARG(&bia, data) = SCARG(uap, data);
	com = SCARG(uap, com);

	fdp = p->p_fd;
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);

	switch (com) {
#if (NWSDISPLAY > 0 && defined(WSDISPLAY_COMPAT_USL))
	case LINUX_KDGKBMODE:
		com = KDGKBMODE;
		break;
	case LINUX_KDSKBMODE:
		com = KDSKBMODE;
		if ((unsigned)SCARG(uap, data) == LINUX_K_MEDIUMRAW)
			SCARG(&bia, data) = (caddr_t)K_RAW;
		break;
	case LINUX_KIOCSOUND:
		SCARG(&bia, data) =
			(caddr_t)(((unsigned long)SCARG(&bia, data)) & 0xffff);
		/* FALLTHROUGH */
	case LINUX_KDMKTONE:
		com = KDMKTONE;
		break;
	case LINUX_KDSETMODE:
		com = KDSETMODE;
		break;
	case LINUX_KDGETMODE:
#if NWSDISPLAY > 0 && defined(WSDISPLAY_COMPAT_USL)
		com = WSDISPLAYIO_GMODE;
#else
		com = KDGETMODE;
#endif
		break;
	case LINUX_KDENABIO:
		com = KDENABIO;
		break;
	case LINUX_KDDISABIO:
		com = KDDISABIO;
		break;
	case LINUX_KDGETLED:
		com = KDGETLED;
		break;
	case LINUX_KDSETLED:
		com = KDSETLED;
		break;
	case LINUX_VT_OPENQRY:
		com = VT_OPENQRY;
		break;
	case LINUX_VT_GETMODE: {
		int sig;

		SCARG(&bia, com) = VT_GETMODE;
		if ((error = sys_ioctl(p, &bia, retval)))
			return error;
		if ((error = copyin(SCARG(uap, data), (caddr_t)&lvt,
		    sizeof (struct vt_mode))))
			return error;
		/* We need to bounds check here in case there
		   is a race with another thread */
		if ((error = bsd_to_linux_signal(lvt.relsig, &sig)))
			return error;
		lvt.relsig = sig;

		if ((error = bsd_to_linux_signal(lvt.acqsig, &sig)))
			return error;
		lvt.acqsig = sig;
		
		if ((error = bsd_to_linux_signal(lvt.frsig, &sig)))
			return error;
		lvt.frsig = sig;

		return copyout((caddr_t)&lvt, SCARG(uap, data),
		    sizeof (struct vt_mode));
	}
	case LINUX_VT_SETMODE: {
		int sig;

		com = VT_SETMODE;
		if ((error = copyin(SCARG(uap, data), (caddr_t)&lvt,
		    sizeof (struct vt_mode))))
			return error;
		if ((error = linux_to_bsd_signal(lvt.relsig, &sig)))
			return error;
		lvt.relsig = sig;

		if ((error = linux_to_bsd_signal(lvt.acqsig, &sig)))
			return error;
		lvt.acqsig = sig;

		if ((error = linux_to_bsd_signal(lvt.frsig, &sig)))
			return error;
		lvt.frsig = sig;

		sg = stackgap_init(p);
		bvtp = stackgap_alloc(&sg, sizeof (struct vt_mode));
		if ((error = copyout(&lvt, bvtp, sizeof (struct vt_mode))))
			return error;
		SCARG(&bia, data) = bvtp;
		break;
	}
	case LINUX_VT_DISALLOCATE:
		/* XXX should use WSDISPLAYIO_DELSCREEN */
		return 0;
	case LINUX_VT_RELDISP:
		com = VT_RELDISP;
		break;
	case LINUX_VT_ACTIVATE:
		com = VT_ACTIVATE;
		break;
	case LINUX_VT_WAITACTIVE:
		com = VT_WAITACTIVE;
		break;
	case LINUX_VT_GETSTATE:
		com = VT_GETSTATE;
		break;
	case LINUX_KDGKBTYPE:
	{
		char tmp = KB_101;

		/* This is what Linux does */
		return copyout(&tmp, SCARG(uap, data), sizeof(char));
	}
#endif
	default:
		/*
		 * Unknown to us. If it's on a device, just pass it through
		 * using PTIOCLINUX, the device itself might be able to
		 * make some sense of it.
		 * XXX hack: if the function returns EJUSTRETURN,
		 * it has stuffed a sysctl return value in pt.data.
		 */
		FREF(fp);
		ioctlf = fp->f_ops->fo_ioctl;
		pt.com = SCARG(uap, com);
		pt.data = SCARG(uap, data);
		error = ioctlf(fp, PTIOCLINUX, (caddr_t)&pt, p);
		FRELE(fp, p);
		if (error == EJUSTRETURN) {
			retval[0] = (register_t)pt.data;
			error = 0;
		}

		if (error == ENOTTY)
			printf("linux_machdepioctl: invalid ioctl %08lx\n",
			    com);
		return (error);
	}
	SCARG(&bia, com) = com;
	return sys_ioctl(p, &bia, retval);
}

/*
 * Set I/O permissions for a process. Just set the maximum level
 * right away (ignoring the argument), otherwise we would have
 * to rely on I/O permission maps, which are not implemented.
 */
int
linux_sys_iopl(struct proc *p, void *v, register_t *retval)
{
#if 0
	struct linux_sys_iopl_args /* {
		syscallarg(int) level;
	} */ *uap = v;
#endif
	struct trapframe *fp = p->p_md.md_regs;

	if (suser(p, 0) != 0)
		return EPERM;
	if (securelevel > 0)
		return EPERM;
	fp->tf_eflags |= PSL_IOPL;
	*retval = 0;
	return 0;
}

/*
 * See above. If a root process tries to set access to an I/O port,
 * just let it have the whole range.
 */
int
linux_sys_ioperm(struct proc *p, void *v, register_t *retval)
{
	struct linux_sys_ioperm_args /* {
		syscallarg(unsigned int) lo;
		syscallarg(unsigned int) hi;
		syscallarg(int) val;
	} */ *uap = v;
	struct trapframe *fp = p->p_md.md_regs;

	if (suser(p, 0) != 0)
		return EPERM;
	if (securelevel > 0)
		return EPERM;
	if (SCARG(uap, val))
		fp->tf_eflags |= PSL_IOPL;
	*retval = 0;
	return 0;
}

int
linux_sys_set_thread_area(struct proc *p, void *v, register_t *retval)
{
	struct linux_sys_set_thread_area_args *uap = v;
	struct l_segment_descriptor ldesc;
	int error;

	error = copyin(SCARG(uap, desc), &ldesc, sizeof ldesc);
	if (error != 0)
		return error;

	if (ldesc.entry_number == -1) {
		ldesc.entry_number = GUGS_SEL;
		if ((error = copyout(&ldesc, SCARG(uap, desc), sizeof ldesc)))
			return error;
	} else if (ldesc.entry_number != GUGS_SEL)
		return EINVAL;

	return i386_set_threadbase(p, ldesc.base_addr, TSEG_GS);
}

int
linux_sys_get_thread_area(struct proc *p, void *v, register_t *retval)
{
	struct linux_sys_get_thread_area_args *uap = v;
	struct l_segment_descriptor info;
	int error;
	int idx;

	error = copyin(SCARG(uap, desc), &info, sizeof(info));
	if (error)
		return error;

	idx = info.entry_number;
	if (idx != GUGS_SEL)
		return (EINVAL);

	info.base_addr = i386_get_threadbase(p, TSEG_GS);
	info.limit = atop(VM_MAXUSER_ADDRESS) - 1;
	info.seg_32bit = 1;
	info.contents = 0;
	info.read_exec_only = 0;	/* SDT_MEMRWA */
	info.limit_in_pages = 1;
	info.seg_not_present = 0;
	info.useable = 1;

	return (copyout(&info, SCARG(uap, desc), sizeof(SCARG(uap, desc))));
}
@


1.46
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.45 2014/03/26 05:23:42 guenther Exp $	*/
@


1.45
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.44 2014/03/22 06:05:45 guenther Exp $	*/
a48 1
#include <sys/vnode.h>
d53 2
@


1.44
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.43 2012/04/22 05:43:14 guenther Exp $	*/
d182 1
a182 1
	tf->tf_eip = p->p_sigcode;
d286 1
a286 1
	sg = stackgap_init(p->p_emul);
d336 1
a336 1
	sg = stackgap_init(p->p_emul);
d532 1
a532 1
		sg = stackgap_init(p->p_emul);
@


1.43
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.42 2011/11/07 15:41:33 guenther Exp $	*/
d113 1
a113 1
	struct sigacts *psp = p->p_sigacts;
@


1.42
log
@Lift the copyout() from i386_get_threadbase() to sys_sysarch(), so that
it can be used correctly from linux_sys_get_thread_area() and tcb.h.
linux_sys_set_thread_area() should use the copied in value instead of
deferencing SCARG() again.  i386_set_threadbase() should only update
curcpu's GDT if it's being called for curproc.

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.41 2011/08/03 16:11:31 guenther Exp $	*/
d575 1
a575 1
		FRELE(fp);
@


1.41
log
@Fix linux compat breakage: can't copyin() from kernel-space, so
move that out of i386_set_threadbase(), and have clone() pass NULL
to fork1() for the child func argument so that it gets the child
proc pointer.

Report and verification by pirofti@@, heavy lifting by matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.40 2011/07/05 04:48:01 guenther Exp $	*/
d656 1
a656 1
	return i386_set_threadbase(p, SCARG(uap, desc)->base_addr, TSEG_GS);
a665 1
	void *base;
d675 1
a675 5
	error = i386_get_threadbase(p, &base, TSEG_GS);
	if (error)
		return error;

	info.base_addr = (int)base;
d684 1
a684 5
	error = copyout(&info, SCARG(uap, desc), sizeof(SCARG(uap, desc)));
	if (error)
	   	return error;

	return 0;
@


1.40
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.39 2011/04/18 21:44:55 guenther Exp $	*/
d656 1
a656 1
	return i386_set_threadbase(p, &SCARG(uap, desc)->base_addr, TSEG_GS);
@


1.39
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.37 2011/04/05 13:54:42 pirofti Exp $	*/
d117 1
a117 1
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d122 1
a122 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
d124 3
a126 3
		fp = (struct linux_sigframe *)((char *)psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size - sizeof(struct linux_sigframe));
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d260 1
a260 1
	p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.38
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d117 1
a117 1
	oonstack = p->p_sigstk.ss_flags & SS_ONSTACK;
d122 1
a122 1
	if ((p->p_sigstk.ss_flags & SS_DISABLE) == 0 && !oonstack &&
d124 3
a126 3
		fp = (struct linux_sigframe *)((char *)p->p_sigstk.ss_sp +
		    p->p_sigstk.ss_size - sizeof(struct linux_sigframe));
		p->p_sigstk.ss_flags |= SS_ONSTACK;
d260 1
a260 1
	p->p_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.37
log
@Remove unused variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.36 2011/04/04 21:50:41 pirofti Exp $	*/
d117 1
a117 1
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
d122 1
a122 1
	if ((psp->ps_flags & SAS_ALTSTACK) && !oonstack &&
d124 3
a126 3
		fp = (struct linux_sigframe *)((char *)psp->ps_sigstk.ss_sp +
		    psp->ps_sigstk.ss_size - sizeof(struct linux_sigframe));
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
d260 1
a260 1
	p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
@


1.36
log
@Add linux_sys_[g|s]et_set_thread_area() support. Okay guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.35 2008/03/18 14:29:25 kettenis Exp $	*/
a641 1

a642 2
	int eno;

a648 1
	eno = ldesc.entry_number;
@


1.35
log
@Clear PSL_D when entering signal handlers; pointed out by dfly people;

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.34 2007/02/14 00:53:47 jsg Exp $	*/
d635 62
@


1.34
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.33 2006/12/29 13:04:37 pedro Exp $	*/
d184 1
a184 1
	tf->tf_eflags &= ~(PSL_T|PSL_VM|PSL_AC);
@


1.33
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.32 2006/09/19 11:06:33 jsg Exp $	*/
d458 1
a458 1
		/* fall through */
@


1.32
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.31 2006/01/12 22:39:20 weingart Exp $	*/
d124 1
a124 1
		fp = (struct linux_sigframe *)(psp->ps_sigstk.ss_sp +
@


1.31
log
@Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.30 2004/07/02 16:29:55 niklas Exp $	*/
d107 2
a108 6
linux_sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	u_long code;
	int type;
	union sigval val;
d200 1
a200 4
linux_sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d267 1
a267 4
linux_sys_rt_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d275 2
a276 8
linux_read_ldt(p, uap, retval)
	struct proc *p;
	struct linux_sys_modify_ldt_args /* {
		syscallarg(int) func;
		syscallarg(void *) ptr;
		syscallarg(size_t) bytecount;
	} */ *uap;
	register_t *retval;
d316 2
a317 8
linux_write_ldt(p, uap, retval)
	struct proc *p;
	struct linux_sys_modify_ldt_args /* {
		syscallarg(int) func;
		syscallarg(void *) ptr;
		syscallarg(size_t) bytecount;
	} */ *uap;
	register_t *retval;
d375 1
a375 4
linux_sys_modify_ldt(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d404 1
a404 2
linux_fakedev(dev)
	dev_t dev;
d416 1
a416 4
linux_machdepioctl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d596 1
a596 4
linux_sys_iopl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d619 1
a619 4
linux_sys_ioperm(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
@


1.30
log
@Maintain %f and %gs over traps.  Mostly from NetBSD.  Preparation for SMP
speedups.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.29 2003/08/15 20:32:13 tedu Exp $	*/
a114 1
	struct pmap *pmap = vm_map_pmap(&p->p_vmspace->vm_map);
d187 1
a187 2
	tf->tf_cs = pmap->pm_hiexec > I386_MAX_EXE_ADDR ? 
	    GSEL(GUCODE1_SEL, SEL_UPL) : GSEL(GUCODE_SEL, SEL_UPL);
@


1.30.6.1
log
@MFC:
Fix by weingart@@

Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.30 2004/07/02 16:29:55 niklas Exp $	*/
d115 1
d188 2
a189 1
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
@


1.30.4.1
log
@MFC:
Fix by weingart@@

Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.30 2004/07/02 16:29:55 niklas Exp $	*/
d115 1
d188 2
a189 1
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
@


1.29
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.28 2003/05/13 03:49:04 art Exp $	*/
d153 2
a154 2
		__asm("movl %%gs,%k0" : "=r" (frame.sf_sc.sc_gs));
		__asm("movl %%fs,%k0" : "=r" (frame.sf_sc.sc_fs));
d251 2
a252 1
		/* %fs and %gs were restored by the trampoline. */
@


1.28
log
@The current solution to handle the protection fault trap is not
correct.  It breaks down if we're trying to jump through a function
pointer. The protection fault trap on i386 must be one of the most
braindead traps ever invented in the history of humankind. It doesn't
give you any information about what went wrong except the instruction
that faulted. Since the problem we're trying to deal with is a
segmentation problem, we don't get the desitination that we want to
jump to, we just get the instruction and we won't add a disassembler
to trap handling just to try to figure out what went wrong.

What we want to do is to handle this as a normal fault to let noexec
accounting in pmap_enter deal with the changes to the code
segment. Unfortunately that's impossible. We don't know the faulting
address, so we need to change how the exec accounting works. Basically
the code segment must already cover the address we want to execute
before we can fault it in.

New scheme:

 o Start with conservative code segment.

 o If we get a protection fault, go through all mappings in the process
  and find the highest executable mapping, fix up the code segment and
  record that address. If the code segment didn't change, the protection
  fault wasn't fixable - just die.

 o If the highest executable mapping is removed, just reset the code
  segment to something conservative and let the next protection fault
  deal with it.  We can't read all the vm mappings of the process from
  the pmap because of locking hell.

This should allow floating code segment whenever someone implements that.

Also, fix the pmap_protect function to behave more like the other
pmaps we have and be slightly more agressive to force more proper
protection changes.

ok:ed by various people.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.27 2003/05/04 05:01:04 drahn Exp $	*/
d638 1
a638 1
	if (suser(p->p_ucred, &p->p_acflag) != 0)
d664 1
a664 1
	if (suser(p->p_ucred, &p->p_acflag) != 0)
@


1.27
log
@Set code segment register according to nxpages, copied from machdep.c
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.26 2003/04/17 03:42:14 drahn Exp $	*/
d188 1
a188 1
	tf->tf_cs = pmap->pm_nxpages > 0?
@


1.26
log
@i386 changes to move to ELF. asm cleanup. Change MAXDSIZ to 512M for 1Gsep.
DARPA funded work.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.25 2003/03/28 00:49:13 miod Exp $	*/
d115 1
d188 2
a189 1
	tf->tf_cs = GSEL(GUCODE_SEL, SEL_UPL);
@


1.25
log
@Add a sysctl to option USER_LDT, to control its behaviour, which will be
disabled by default.

Enable with sysctl -w machdep.userldt=1

This will allow people to use the few ports that require this functionality
to work without requiring the user to recompile a kernel.

The option USER_LDT remains in order to not increase size on the
installation media. It is now enabled in GENERIC.

Per espie@@'s idea, but my diff was much simpler than his; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.24 2003/01/09 22:27:09 miod Exp $	*/
d152 2
a153 2
		__asm("movl %%gs,%w0" : "=r" (frame.sf_sc.sc_gs));
		__asm("movl %%fs,%w0" : "=r" (frame.sf_sc.sc_fs));
@


1.24
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.23 2002/07/20 19:24:56 art Exp $	*/
d298 3
d346 3
@


1.23
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.22 2002/04/19 21:28:58 jasoni Exp $	*/
d577 3
d581 2
a582 1
		return (subyte(SCARG(uap, data), KB_101));
@


1.22
log
@build when NSWDISPLAY is undefined or 0; from brian@@freebsd-services.com
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.21 2002/03/14 01:26:32 millert Exp $	*/
a118 1
	extern char linux_sigcode[], linux_esigcode[];
d186 1
a186 2
	tf->tf_eip = (int)(((char *)PS_STRINGS) -
	     (linux_esigcode - linux_sigcode));
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.20 2002/02/13 20:43:42 jasoni Exp $	*/
d75 1
a76 1
#include <sys/ioctl.h>
d449 1
a450 1
	int error;
@


1.20
log
@FREF/FRELE where required due to fd_getfile.
- ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.19 2002/02/06 01:55:04 jasoni Exp $	*/
d83 4
a86 4
int linux_read_ldt __P((struct proc *, struct linux_sys_modify_ldt_args *,
    register_t *));
int linux_write_ldt __P((struct proc *, struct linux_sys_modify_ldt_args *,
    register_t *));
d457 1
a457 1
	int (*ioctlf) __P((struct file *, u_long, caddr_t, struct proc *));
@


1.19
log
@emulate linux behaviour by passing ioctl's down to the underlying device
> From NetBSD; ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.18 2002/01/16 20:50:16 miod Exp $	*/
d590 1
d595 1
@


1.18
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.17 2001/07/27 06:10:38 csapuntz Exp $	*/
d114 2
a115 2
	register struct proc *p = curproc;
	register struct trapframe *tf;
d215 1
a215 1
	register struct trapframe *tf;
d454 5
d460 1
d465 4
d583 20
a602 2
		printf("linux_machdepioctl: invalid ioctl %08lx\n", com);
		return EINVAL;
@


1.17
log
@

Convert array lookups to function calls that are bounds checked
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.16 2001/05/01 19:15:16 aaron Exp $	*/
a38 1
#include <sys/map.h>
@


1.17.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.18 2002/01/16 20:50:16 miod Exp $	*/
d39 1
@


1.17.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.17.4.1 2002/01/31 22:55:11 niklas Exp $	*/
d75 1
a76 1
#if NWSDISPLAY > 0 && defined(WSDISPLAY_COMPAT_USL)
d83 4
a86 4
int linux_read_ldt(struct proc *, struct linux_sys_modify_ldt_args *,
    register_t *);
int linux_write_ldt(struct proc *, struct linux_sys_modify_ldt_args *,
    register_t *);
d114 2
a115 2
	struct proc *p = curproc;
	struct trapframe *tf;
d215 1
a215 1
	struct trapframe *tf;
d449 1
a450 1
#if (NWSDISPLAY > 0 && defined(WSDISPLAY_COMPAT_USL))
a453 5
	struct filedesc *fdp;
	struct file *fp;
	int fd;
	int (*ioctlf)(struct file *, u_long, caddr_t, struct proc *);
	struct ioctl_pt pt;
a454 1
	fd = SCARG(uap, fd);
a458 4
	fdp = p->p_fd;
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);

d573 2
a574 22
		/*
		 * Unknown to us. If it's on a device, just pass it through
		 * using PTIOCLINUX, the device itself might be able to
		 * make some sense of it.
		 * XXX hack: if the function returns EJUSTRETURN,
		 * it has stuffed a sysctl return value in pt.data.
		 */
		FREF(fp);
		ioctlf = fp->f_ops->fo_ioctl;
		pt.com = SCARG(uap, com);
		pt.data = SCARG(uap, data);
		error = ioctlf(fp, PTIOCLINUX, (caddr_t)&pt, p);
		FRELE(fp);
		if (error == EJUSTRETURN) {
			retval[0] = (register_t)pt.data;
			error = 0;
		}

		if (error == ENOTTY)
			printf("linux_machdepioctl: invalid ioctl %08lx\n",
			    com);
		return (error);
@


1.17.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.17.4.2 2002/06/11 03:35:53 art Exp $	*/
d119 1
d187 2
a188 1
	tf->tf_eip = p->p_sigcode;
@


1.17.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a114 1
	struct pmap *pmap = vm_map_pmap(&p->p_vmspace->vm_map);
d152 2
a153 2
		__asm("movl %%gs,%k0" : "=r" (frame.sf_sc.sc_gs));
		__asm("movl %%fs,%k0" : "=r" (frame.sf_sc.sc_fs));
d187 1
a187 2
	tf->tf_cs = pmap->pm_hiexec > I386_MAX_EXE_ADDR ? 
	    GSEL(GUCODE1_SEL, SEL_UPL) : GSEL(GUCODE_SEL, SEL_UPL);
a297 3
	if (user_ldt_enable == 0)
		return (ENOSYS);

a343 3
	if (user_ldt_enable == 0)
		return (ENOSYS);

a576 3
	{
		char tmp = KB_101;

d578 1
a578 2
		return copyout(&tmp, SCARG(uap, data), sizeof(char));
	}
@


1.16
log
@Remove PCVT cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.15 2001/04/07 21:31:24 tholo Exp $	*/
d502 3
a504 1
	case LINUX_VT_GETMODE:
d511 14
a524 3
		lvt.relsig = bsd_to_linux_sig[lvt.relsig];
		lvt.acqsig = bsd_to_linux_sig[lvt.acqsig];
		lvt.frsig = bsd_to_linux_sig[lvt.frsig];
d527 4
a530 1
	case LINUX_VT_SETMODE:
d535 12
a546 3
		lvt.relsig = linux_to_bsd_sig[lvt.relsig];
		lvt.acqsig = linux_to_bsd_sig[lvt.acqsig];
		lvt.frsig = linux_to_bsd_sig[lvt.frsig];
d553 1
@


1.15
log
@Handle Linux Virtual Terminal ioctl calls with wscons as well as vt;
requires WSDISPLAY_COMPAT_USL
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.14 2000/03/28 06:35:57 jasoni Exp $	*/
d73 1
a73 1
 * To see whether pcvt is configured (for virtual console ioctl calls).
a75 1
#include "vt.h"
a79 2
#elif NVT > 0
#include <arch/i386/isa/pcvt/pcvt_ioctl.h>
d450 1
a450 1
#if (NWSDISPLAY > 0 && defined(WSDISPLAY_COMPAT_USL)) || NVT > 0
d461 1
a461 1
#if (NWSDISPLAY > 0 && defined(WSDISPLAY_COMPAT_USL)) || NVT > 0
@


1.14
log
@Implement rt_sigreturn.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.13 2000/03/23 17:17:32 aaron Exp $	*/
d75 1
d77 5
a81 1
#if NVT > 0
d453 1
a453 1
#if NVT > 0
d464 1
a464 1
#if NVT > 0
d473 4
d483 7
d531 3
d543 6
@


1.13
log
@Do not include <sys/callout.h>, it is never needed; art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.12 1998/07/09 18:22:12 deraadt Exp $	*/
d271 9
@


1.12
log
@never set PSL_IOPL at high securelevel (except the one xf86 case, controlled by the aperture driver; problem noted by csapuntz
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.11 1998/02/08 08:32:34 deraadt Exp $	*/
a45 1
#include <sys/callout.h>
@


1.12.8.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
@


1.12.8.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.15 2001/04/07 21:31:24 tholo Exp $	*/
a74 1
#include "wsdisplay.h"
d76 1
a76 5
#if NWSDISPLAY > 0 && defined(WSDISPLAY_COMPAT_USL)
#include <sys/ioctl.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplay_usl_io.h>
#elif NVT > 0
a272 9
int
linux_sys_rt_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	return(ENOSYS);
}

d439 1
a439 1
#if (NWSDISPLAY > 0 && defined(WSDISPLAY_COMPAT_USL)) || NVT > 0
d450 1
a450 1
#if (NWSDISPLAY > 0 && defined(WSDISPLAY_COMPAT_USL)) || NVT > 0
a458 4
	case LINUX_KIOCSOUND:
		SCARG(&bia, data) =
			(caddr_t)(((unsigned long)SCARG(&bia, data)) & 0xffff);
		/* fall through */
a464 7
	case LINUX_KDGETMODE:
#if NWSDISPLAY > 0 && defined(WSDISPLAY_COMPAT_USL)
		com = WSDISPLAYIO_GMODE;
#else
		com = KDGETMODE;
#endif
		break;
a505 3
	case LINUX_VT_DISALLOCATE:
		/* XXX should use WSDISPLAYIO_DELSCREEN */
		return 0;
a514 6
	case LINUX_VT_GETSTATE:
		com = VT_GETSTATE;
		break;
	case LINUX_KDGKBTYPE:
		/* This is what Linux does */
		return (subyte(SCARG(uap, data), KB_101));
@


1.12.8.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.12.8.2 2001/04/18 16:07:19 niklas Exp $	*/
d73 1
a73 1
 * To see whether wsdisplay is configured (for virtual console ioctl calls).
d76 1
d81 2
d453 1
a453 1
#if (NWSDISPLAY > 0 && defined(WSDISPLAY_COMPAT_USL))
d464 1
a464 1
#if (NWSDISPLAY > 0 && defined(WSDISPLAY_COMPAT_USL))
@


1.12.8.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.12.8.3 2001/07/04 10:16:35 niklas Exp $	*/
d502 1
a502 3
	case LINUX_VT_GETMODE: {
		int sig;

d509 3
a511 14
		/* We need to bounds check here in case there
		   is a race with another thread */
		if ((error = bsd_to_linux_signal(lvt.relsig, &sig)))
			return error;
		lvt.relsig = sig;

		if ((error = bsd_to_linux_signal(lvt.acqsig, &sig)))
			return error;
		lvt.acqsig = sig;
		
		if ((error = bsd_to_linux_signal(lvt.frsig, &sig)))
			return error;
		lvt.frsig = sig;

d514 1
a514 4
	}
	case LINUX_VT_SETMODE: {
		int sig;

d519 3
a521 12
		if ((error = linux_to_bsd_signal(lvt.relsig, &sig)))
			return error;
		lvt.relsig = sig;

		if ((error = linux_to_bsd_signal(lvt.acqsig, &sig)))
			return error;
		lvt.acqsig = sig;

		if ((error = linux_to_bsd_signal(lvt.frsig, &sig)))
			return error;
		lvt.frsig = sig;

a527 1
	}
@


1.12.8.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 1
d115 2
a116 2
	struct proc *p = curproc;
	struct trapframe *tf;
d216 1
a216 1
	struct trapframe *tf;
a454 5
	struct filedesc *fdp;
	struct file *fp;
	int fd;
	int (*ioctlf) __P((struct file *, u_long, caddr_t, struct proc *));
	struct ioctl_pt pt;
a455 1
	fd = SCARG(uap, fd);
a459 4
	fdp = p->p_fd;
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);

d574 2
a575 22
		/*
		 * Unknown to us. If it's on a device, just pass it through
		 * using PTIOCLINUX, the device itself might be able to
		 * make some sense of it.
		 * XXX hack: if the function returns EJUSTRETURN,
		 * it has stuffed a sysctl return value in pt.data.
		 */
		FREF(fp);
		ioctlf = fp->f_ops->fo_ioctl;
		pt.com = SCARG(uap, com);
		pt.data = SCARG(uap, data);
		error = ioctlf(fp, PTIOCLINUX, (caddr_t)&pt, p);
		FRELE(fp);
		if (error == EJUSTRETURN) {
			retval[0] = (register_t)pt.data;
			error = 0;
		}

		if (error == ENOTTY)
			printf("linux_machdepioctl: invalid ioctl %08lx\n",
			    com);
		return (error);
@


1.12.8.6
log
@Merge in -current from about a week ago
@
text
@d83 4
a86 4
int linux_read_ldt(struct proc *, struct linux_sys_modify_ldt_args *,
    register_t *);
int linux_write_ldt(struct proc *, struct linux_sys_modify_ldt_args *,
    register_t *);
d457 1
a457 1
	int (*ioctlf)(struct file *, u_long, caddr_t, struct proc *);
@


1.12.8.7
log
@Sync the SMP branch with 3.3
@
text
@d75 1
a76 1
#if NWSDISPLAY > 0 && defined(WSDISPLAY_COMPAT_USL)
d119 1
d187 2
a188 1
	tf->tf_eip = p->p_sigcode;
d449 1
a450 1
#if (NWSDISPLAY > 0 && defined(WSDISPLAY_COMPAT_USL))
a578 3
	{
		char tmp = KB_101;

d580 1
a580 2
		return copyout(&tmp, SCARG(uap, data), sizeof(char));
	}
@


1.12.8.8
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.12.8.7 2003/03/27 23:26:55 niklas Exp $	*/
a114 1
	struct pmap *pmap = vm_map_pmap(&p->p_vmspace->vm_map);
d152 2
a153 2
		__asm("movl %%gs,%k0" : "=r" (frame.sf_sc.sc_gs));
		__asm("movl %%fs,%k0" : "=r" (frame.sf_sc.sc_fs));
d187 1
a187 2
	tf->tf_cs = pmap->pm_nxpages > 0?
	    GSEL(GUCODE1_SEL, SEL_UPL) : GSEL(GUCODE_SEL, SEL_UPL);
a297 3
	if (user_ldt_enable == 0)
		return (ENOSYS);

a342 3

	if (user_ldt_enable == 0)
		return (ENOSYS);
@


1.12.8.9
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d188 1
a188 1
	tf->tf_cs = pmap->pm_hiexec > I386_MAX_EXE_ADDR ? 
@


1.12.8.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d638 1
a638 1
	if (suser(p, 0) != 0)
d664 1
a664 1
	if (suser(p, 0) != 0)
@


1.11
log
@nicer
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.10 1997/02/01 21:53:20 deraadt Exp $	*/
d545 2
d570 2
@


1.10
log
@add type & union sigval args to sendsig/trapsignal
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.9 1997/01/27 22:47:58 deraadt Exp $	*/
d419 1
a419 1
	if (major(dev) == NETBSD_CONS_MAJOR)
@


1.9
log
@add another parameter to trapsignal() and sendsig() -- fault addr to be
delivered with in the siginfo information
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.8 1996/05/07 07:21:42 deraadt Exp $	*/
d107 1
a107 1
linux_sendsig(catcher, sig, mask, code, addr)
d111 2
a112 1
	caddr_t addr;
@


1.8
log
@sync with 0504; prototype changes
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.6 1996/04/21 22:16:28 deraadt Exp $	*/
d107 1
a107 1
linux_sendsig(catcher, sig, mask, code)
d111 1
@


1.7
log
@Turn off the alignment check flag when entering a signal handler
@
text
@d2 1
a2 1
/*	$NetBSD: linux_machdep.c,v 1.28 1996/04/18 08:36:22 mycroft Exp $	*/
d61 1
d81 8
d297 1
a297 1
	if (error = copyout(&gl, parms, sizeof(gl)))
d300 1
a300 1
	if (error = i386_get_ldt(p, parms, retval))
d337 1
a337 1
	if (error = copyin(SCARG(uap, ptr), &ldt_info, sizeof(ldt_info)))
d366 1
a366 1
	if (error = copyout(&sd, sl.desc, sizeof(sd)))
d368 1
a368 1
	if (error = copyout(&sl, parms, sizeof(sl)))
d371 1
a371 1
	if (error = i386_set_ldt(p, parms, retval))
d436 1
a436 1
	struct sys_ioctl_args bia, tmparg;
d439 1
a439 1
	int error, mode;
a441 3
	u_int fd;
	struct file *fp;
	struct filedesc *fdp;
d516 1
a516 1
		printf("linux_machdepioctl: invalid ioctl %08x\n", com);
d534 1
d538 1
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: linux_machdep.c,v 1.5 1996/04/18 19:18:09 niklas Exp $	*/
/*	$NetBSD: linux_machdep.c,v 1.27 1996/04/12 08:44:37 mycroft Exp $	*/
d179 1
a179 1
	tf->tf_eflags &= ~(PSL_T|PSL_VM);
@


1.5
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD: linux_machdep.c,v 1.4 1996/04/17 05:18:53 mickey Exp $	*/
/*	$NetBSD: linux_machdep.c,v 1.26 1996/04/11 07:47:45 mycroft Exp $	*/
a138 1
		tf->tf_eflags &= ~PSL_VM;
d179 1
@


1.4
log
@Cleanups & fixes from latest NetBSD primarily to run doscmd, etc.
GENERIC added to the compile/.cvsignore (it is used for 'make links'
for example), thus conf/GENERIC should appear magically ...
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_machdep.c,v 1.3 1996/03/11 11:16:48 mickey Exp $	*/
@


1.3
log
@Debbuger changed towards the latest Mach.
Some minor changes for Linux ;) emulation.
Small bug fixes from NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: linux_machdep.c,v 1.24 1996/01/04 22:21:57 jtc Exp $	*/
d69 1
d138 2
d147 1
d149 9
a157 10
	frame.sf_sc.sc_edi    = tf->tf_edi;
	frame.sf_sc.sc_esi    = tf->tf_esi;
	frame.sf_sc.sc_ebp    = tf->tf_ebp;
	frame.sf_sc.sc_ebx    = tf->tf_ebx;
	frame.sf_sc.sc_edx    = tf->tf_edx;
	frame.sf_sc.sc_ecx    = tf->tf_ecx;
	frame.sf_sc.sc_eax    = tf->tf_eax;
	frame.sf_sc.sc_eip    = tf->tf_eip;
	frame.sf_sc.sc_cs     = tf->tf_cs;
	frame.sf_sc.sc_eflags = tf->tf_eflags;
d159 2
a160 2
	frame.sf_sc.sc_ss     = tf->tf_ss;
	frame.sf_sc.sc_err    = tf->tf_err;
d175 2
a176 1
	tf->tf_esp = (int)fp;
a178 3
#ifdef VM86
	tf->tf_eflags &= ~PSL_VM;
#endif
d180 1
a180 2
	tf->tf_ds = GSEL(GUDATA_SEL, SEL_UPL);
	tf->tf_es = GSEL(GUDATA_SEL, SEL_UPL);
a217 10
	 * Check for security violations.
	 */
	if (((context.sc_eflags ^ tf->tf_eflags) & PSL_USERSTATIC) != 0 ||
	    !USERMODE(context.sc_cs, context.sc_eflags))
		return (EINVAL);

	p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = context.sc_mask & ~sigcantmask;

	/*
d226 1
d230 10
d243 1
d245 14
a258 12
	tf->tf_edi    = context.sc_edi;
	tf->tf_esi    = context.sc_esi;
	tf->tf_ebp    = context.sc_ebp;
	tf->tf_ebx    = context.sc_ebx;
	tf->tf_edx    = context.sc_edx;
	tf->tf_ecx    = context.sc_ecx;
	tf->tf_eax    = context.sc_eax;
	tf->tf_eip    = context.sc_eip;
	tf->tf_cs     = context.sc_cs;
	tf->tf_eflags = context.sc_eflags;
	tf->tf_esp    = context.sc_esp_at_signal;
	tf->tf_ss     = context.sc_ss;
a509 1
#ifdef	DIAGNOSTIC
a510 1
#endif
@


1.2
log
@ss_sp is correct, ss_base is not. noticed by agc@@sde.uts.amdahl.com; netbsd pr#1784
@
text
@d1 1
d506 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: linux_machdep.c,v 1.23 1995/10/10 04:54:25 mycroft Exp $	*/
d116 1
a116 1
		fp = (struct linux_sigframe *)(psp->ps_sigstk.ss_base +
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
