head	1.22;
access;
symbols
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.20.0.10
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.8
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.6
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.4
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.14.0.6
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.16
	UBC:1.14.0.4
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.13.0.14
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.13.0.12
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.10
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.8
	SMP_BASE:1.13
	kame_19991208:1.13
	OPENBSD_2_6:1.13.0.6
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.4
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.8.0.6
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.4
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.22
date	2007.05.04.16.39.28;	author art;	state dead;
branches;
next	1.21;

1.21
date	2006.12.20.17.50.40;	author gwk;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.04.16.36.14;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.27.23.52.01;	author fgsch;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.17.03.42.14;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.24.00.06.22;	author nordin;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.06.19.14.20;	author nordin;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.20.17.02.30;	author mpech;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	98.08.27.05.00.34;	author deraadt;	state Exp;
branches
	1.13.8.1;
next	1.12;

1.12
date	98.08.27.00.44.38;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	98.05.13.19.49.25;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.12.30.23.35.19;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.12.17.08.54.49;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	96.08.08.18.47.11;	author dm;	state Exp;
branches;
next	1.7;

1.7
date	96.04.29.00.42.25;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.04.28.22.29.06;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.04.28.21.11.19;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.03.19.21.09.20;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.28.14.38.45;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.02.25.23.03.14;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.33;	author deraadt;	state Exp;
branches;
next	;

1.13.8.1
date	2001.07.14.10.02.28;	author ho;	state Exp;
branches;
next	1.13.8.2;

1.13.8.2
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.13.8.3;

1.13.8.3
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.13.8.4;

1.13.8.4
date	2003.05.13.19.42.08;	author ho;	state Exp;
branches;
next	1.13.8.5;

1.13.8.5
date	2003.06.07.11.11.37;	author ho;	state Exp;
branches;
next	;

1.14.4.1
date	2002.10.29.00.28.04;	author art;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Remove dead code.
@
text
@/*	$OpenBSD: microtime.s,v 1.21 2006/12/20 17:50:40 gwk Exp $	*/
/*	$NetBSD: microtime.s,v 1.16 1995/04/17 12:06:47 cgd Exp $	*/

/*-
 * Copyright (c) 1993 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WArRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <machine/asm.h>
#include <dev/isa/isareg.h>
#include <i386/isa/timerreg.h>

#define	IRQ_BIT(irq_num)	(1 << ((irq_num) % 8))
#define	IRQ_BYTE(irq_num)	((irq_num) / 8)

/*
 * Use a higher resolution version of microtime if HZ is not
 * overridden (i.e. it is 100Hz).
 */
#ifndef HZ
ENTRY(i8254_microtime)

#if defined(I586_CPU) || defined(I686_CPU)
	movl	_C_LABEL(cpuspeed), %ecx
	testl	%ecx, %ecx
	jne	pentium_microtime
#else
	xorl	%ecx,%ecx
#endif
	movb	$(TIMER_SEL0|TIMER_LATCH),%al

	pushfl
	cli				# disable interrupts

	outb	%al,$TIMER_MODE		# latch timer 0's counter

	# Read counter value into ecx, LSB first
	xorl	%ecx,%ecx
	inb	$TIMER_CNTR0,%al
	movb	%al,%cl
	inb	$TIMER_CNTR0,%al
	movb	%al,%ch

	# Now check for counter overflow.  This is tricky because the
	# timer chip doesn't let us atomically read the current counter
	# value and the output state (i.e., overflow state).  We have
	# to read the ICU interrupt request register (IRR) to see if the
	# overflow has occurred.  Because we lack atomicity, we use
	# the (very accurate) heuristic that we do not check for
	# overflow if the value read is close to 0.
	# E.g., if we just checked the IRR, we might read a non-overflowing
	# value close to 0, experience overflow, then read this overflow
	# from the IRR, and mistakenly add a correction to the "close
	# to zero" value.
	#
	# We compare the counter value to the heuristic constant 12.
	# If the counter value is less than this, we assume the counter
	# didn't overflow between disabling clock interrupts and latching
	# the counter value above.  For example, we assume that the first 3
	# instructions take less than 12 microseconds to execute.
	#
	# (We used to check for overflow only if the value read was close to
	# the timer limit, but this doesn't work very well if we're at the
	# clock's ipl or higher.)
	#
	# Otherwise, the counter might have overflowed.  We check for this
	# condition by reading the interrupt request register out of the ICU.
	# If it overflowed, we add in one clock period.

	movl	$11932,%edx	# counter limit

	testb	$IRQ_BIT(0),_C_LABEL(ipending) + IRQ_BYTE(0)
	jnz	1f

	cmpl	$12,%ecx	# check for potential overflow
	jbe	2f
	
	inb	$IO_ICU1,%al	# read IRR in ICU
	testb	$IRQ_BIT(0),%al	# is a timer interrupt pending?
	jz	2f

1:	subl	%edx,%ecx	# add another tick
	
2:	subl	%ecx,%edx	# subtract counter value from counter limit

	# Divide by 1193280/1000000.  We use a fast approximation of 4096/3433.
	# For values of hz more than 100, this has a maximum error of 2us.

	leal	(%edx,%edx,2),%eax	# a = 3d
	leal	(%edx,%eax,4),%eax	# a = 4a + d = 13d
	movl	%eax,%ecx
	shll	$5,%ecx
	addl	%ecx,%eax		# a = 33a    = 429d
	leal	(%edx,%eax,8),%eax	# a = 8a + d = 3433d
	shrl	$12,%eax		# a = a/4096 = 3433d/4096

common_microtime:
	movl	_C_LABEL(time),%edx	# get time.tv_sec
	addl	_C_LABEL(time)+4,%eax	# add time.tv_usec

	popfl			# enable interrupts
	
	cmpl	$1000000,%eax	# carry in timeval?
	jb	3f
	subl	$1000000,%eax	# adjust usec
	incl	%edx		# bump sec
	
3:	movl	4(%esp),%ecx	# load timeval pointer arg
	movl	%edx,(%ecx)	# tvp->tv_sec = sec
	movl	%eax,4(%ecx)	# tvp->tv_usec = usec

	ret

#if defined(I586_CPU) || defined(I686_CPU)
	.data
	.globl	_C_LABEL(pentium_base_tsc)
	.comm	_C_LABEL(pentium_base_tsc),8
	.text

	.align	2, 0x90
pentium_microtime:
	pushfl
	cli
	rdtsc
	subl	_C_LABEL(pentium_base_tsc),%eax
	sbbl	_C_LABEL(pentium_base_tsc)+4,%edx
	/*
	 * correct the high word first so we won't
	 * receive a result overflow aka div/0 fault
	 */
	pushl	%eax
	movl	%edx, %eax
	shll	$16, %edx
	divw	%cx
	movzwl	%dx, %edx
	popl	%eax
	divl	%ecx
	jmp	common_microtime
#endif

#endif
@


1.21
log
@"#ifdef is a tool of the weak!"
Rename pentium_mhz to cpuspeed which is consistant with amd64 making
shared ACPI code less nasty.
ok marco, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.20 2004/06/13 21:49:15 niklas Exp $	*/
@


1.20
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
	movl	_C_LABEL(pentium_mhz), %ecx
@


1.19
log
@more term 3 & 4 from various developers, with permission of course
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.18 2003/05/27 23:52:01 fgsch Exp $	*/
d45 1
a45 1
ENTRY(microtime)
@


1.18
log
@change .byte for the correct opcodes now that gas can handle'em.
art@@ toby@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.17 2003/04/17 03:42:14 drahn Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@i386 changes to move to ELF. asm cleanup. Change MAXDSIZ to 512M for 1Gsep.
DARPA funded work.
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.16 2002/09/24 00:06:22 nordin Exp $	*/
d152 1
a152 1
	.byte	0x0f, 0x31	# RDTSC
@


1.16
log
@Restore pentium_microtime, testing by henning@@, millert@@. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.15 2002/07/06 19:14:20 nordin Exp $	*/
d52 1
a52 1
	movl	_pentium_mhz, %ecx
d100 1
a100 1
	testb	$IRQ_BIT(0),_ipending + IRQ_BYTE(0)
d126 2
a127 2
	movl	_time,%edx	# get time.tv_sec
	addl	_time+4,%eax	# add time.tv_usec
d144 2
a145 2
	.globl	_pentium_base_tsc
	.comm	_pentium_base_tsc,8
d153 2
a154 2
	subl	_pentium_base_tsc,%eax
	sbbl	_pentium_base_tsc+4,%edx
@


1.15
log
@Remove kernel support for NTP. ok deraadt@@ and tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.14 2001/09/20 17:02:30 mpech Exp $	*/
d51 5
d57 1
a142 2
	# XXX: Move to machdep.c?

d147 20
@


1.14
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.13 1998/08/27 05:00:34 deraadt Exp $	*/
a50 5
#if (defined(I586_CPU) || defined(I686_CPU)) && defined(NTP) 
	movl	_pentium_mhz, %ecx
	testl	%ecx, %ecx
	jne	pentium_microtime
#else
a51 1
#endif
d137 2
a142 22

#if defined (NTP)
	.align	2, 0x90
pentium_microtime:
	pushfl
	cli
	.byte	0x0f, 0x31	# RDTSC
	subl	_pentium_base_tsc,%eax
	sbbl	_pentium_base_tsc+4,%edx
	/*
	 * correct the high word first so we won't
	 * receive a result overflow aka div/0 fault
	 */
	pushl	%eax
	movl	%edx, %eax
	shll	$16, %edx
	divw	%cx
	movzwl	%dx, %edx
	popl	%eax
	divl	%ecx
	jmp	common_microtime
#endif
@


1.14.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.14 2001/09/20 17:02:30 mpech Exp $	*/
d51 1
a51 1
#if defined(I586_CPU) || defined(I686_CPU)
d148 1
d168 1
@


1.14.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
a52 1
	movl	_C_LABEL(pentium_mhz), %ecx
d100 1
a100 1
	testb	$IRQ_BIT(0),_C_LABEL(ipending) + IRQ_BYTE(0)
d126 2
a127 2
	movl	_C_LABEL(time),%edx	# get time.tv_sec
	addl	_C_LABEL(time)+4,%eax	# add time.tv_usec
d144 2
a145 2
	.globl	_C_LABEL(pentium_base_tsc)
	.comm	_C_LABEL(pentium_base_tsc),8
d153 2
a154 2
	subl	_C_LABEL(pentium_base_tsc),%eax
	sbbl	_C_LABEL(pentium_base_tsc)+4,%edx
@


1.13
log
@Undo changes which were not discussed.
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.11 1998/05/13 19:49:25 mickey Exp $	*/
d76 1
a76 1
	# overflow has occured.  Because we lack atomicity, we use
@


1.13.8.1
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.13 1998/08/27 05:00:34 deraadt Exp $	*/
d49 1
a49 1
ENTRY(i8254_microtime)
@


1.13.8.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.13.8.1 2001/07/14 10:02:28 ho Exp $	*/
d76 1
a76 1
	# overflow has occurred.  Because we lack atomicity, we use
@


1.13.8.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 1
a51 1
#if defined(I586_CPU) || defined(I686_CPU)
d148 1
d168 1
@


1.13.8.4
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.13.8.3 2003/03/27 23:26:55 niklas Exp $	*/
d52 1
a52 1
	movl	_C_LABEL(pentium_mhz), %ecx
d100 1
a100 1
	testb	$IRQ_BIT(0),_C_LABEL(ipending) + IRQ_BYTE(0)
d126 2
a127 2
	movl	_C_LABEL(time),%edx	# get time.tv_sec
	addl	_C_LABEL(time)+4,%eax	# add time.tv_usec
d144 2
a145 2
	.globl	_C_LABEL(pentium_base_tsc)
	.comm	_C_LABEL(pentium_base_tsc),8
d153 2
a154 2
	subl	_C_LABEL(pentium_base_tsc),%eax
	sbbl	_C_LABEL(pentium_base_tsc)+4,%edx
@


1.13.8.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.13.8.4 2003/05/13 19:42:08 ho Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
d152 1
a152 1
	rdtsc
@


1.12
log
@defopt NTP
@
text
@a36 2
#include "opt_ntp.h"

@


1.11
log
@making kernel, drinking LI tea and writing an opus magnum enspired
by the freebsd commit logs:
first of all i should state that we are the only os that uses pentium
counters in their microtime (freebsd, netbsd, etc checked).
the bug fixed derives from the fact that #UD (divide by zero)
is generated in two cases:
	a) divide by zero;
	b) divide overflow.
so, the later case was the one causing panics on reboot.
due to the divl insn design in the intel processors, the possible
sizes of operands and results are: 16/8=8,8; 32/16=16,16; 64/32=32,32.
the division will generate an #UD exception when the quotient
won't fit into result, that is 32bit in our case (64bit is divided on 32bit).
problem solved by normalizing the dividend by the divisor, so the quotient
would not result a divide overflow.

tested by: mickey, gene, mickey.
talked over: mickey, gene, marc, maillists, mickey.
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.10 1997/12/30 23:35:19 mickey Exp $	*/
d36 2
@


1.10
log
@be carefull about div by zero
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.9 1997/12/17 08:54:49 downsj Exp $	*/
d60 1
d129 1
a129 1
	sti			# enable interrupts
d151 1
d156 11
a166 4
	orl	%ecx, %ecx
	jnz	1f
	incl	%ecx
1:	divl	%ecx		# convert to usec
@


1.9
log
@New CPU detection code, from NetBSD, with some machdep changes from myself.

Add I686_CPU to your configs if you have a PPro...
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.8 1996/08/08 18:47:11 dm Exp $	*/
d154 4
a157 1
	divl	%ecx		# convert to usec
@


1.8
log
@Added a pctr pseudo-device for accessing the Pentium performance counters,
and a program pctrctl to set the counter functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.4 1996/03/19 21:09:20 mickey Exp $	*/
d51 1
a51 1
#if defined(I586_CPU) && defined(NTP) 
d141 1
a141 1
#if defined(I586_CPU)
@


1.7
log
@Revert last commit.
@
text
@d141 7
a147 1
#if defined(I586_CPU) && defined(NTP)
d152 2
d156 1
@


1.6
log
@rnd driver needs i586 counter too.
@
text
@d26 1
a26 1
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
a39 1
#include "rnd.h"
d51 1
a51 1
#if defined(I586_CPU) && (defined(NTP) || NRND)
d141 1
a141 1
#if defined(I586_CPU) && (defined(NTP) || NRND)
@


1.5
log
@Only use Pentium instruction counter of we have been compiled with NTP
support, otherwise we won't get the counter reset at the top of every
second and will return highly inaccurate values.
@
text
@d40 1
d52 1
a52 1
#if defined(I586_CPU) && defined(NTP)
d142 1
a142 1
#if defined(I586_CPU) && defined(NTP)
@


1.4
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 1
a1 1
/*	$OpenBSD: microtime.s,v 1.3 1996/02/28 14:38:45 mickey Exp $	*/
d51 1
a51 1
#ifdef I586_CPU
d141 1
a141 1
#ifdef I586_CPU
@


1.3
log
@Small changes from NetBSD (including /usr/include dependencies, and so).
@
text
@d1 2
a2 1
/*	$OpenBSD: microtime.s,v 1.16 1995/04/17 12:06:47 cgd Exp $	*/
@


1.2
log
@Allow use of Pentium cycle counter for high-precision time keeping;
from FreeBSD
@
text
@d1 1
a1 1
/*	$NetBSD: microtime.s,v 1.16 1995/04/17 12:06:47 cgd Exp $	*/
d64 1
@


1.1
log
@Initial revision
@
text
@d49 10
a60 1
	movb	$(TIMER_SEL0|TIMER_LATCH),%al
a63 1
	xorl	%ecx,%ecx
d122 1
d138 10
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
