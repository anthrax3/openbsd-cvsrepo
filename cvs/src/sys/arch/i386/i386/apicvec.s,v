head	1.32;
access;
symbols
	OPENBSD_6_1:1.32.0.6
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.32.0.2
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.4
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.4
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.2
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.2
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.16.0.4
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	UBC_SYNC_A:1.1
	UBC_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@# @;


1.32
date	2016.07.16.06.04.29;	author mlarkin;	state Exp;
branches;
next	1.31;
commitid	2VViksTJanHcGpAF;

1.31
date	2015.07.16.05.10.14;	author guenther;	state Exp;
branches;
next	1.30;
commitid	vUE3LzynpntlHxEC;

1.30
date	2015.06.28.01.11.27;	author guenther;	state Exp;
branches;
next	1.29;
commitid	pmt8zLCdl4eF6ZNV;

1.29
date	2015.02.07.00.26.37;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	kEuv7zJ8MalymF3m;

1.28
date	2013.11.28.19.30.46;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2013.05.12.14.15.31;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2012.07.09.16.09.47;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2011.09.22.12.17.04;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.05.17.11.07;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.16.00.40.58;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2010.12.21.14.56.23;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2010.01.11.23.09.52;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.10.16.40.50;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.10.13.51.47;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.06.22.37.34;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.03.00.49.12;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.15;

1.15
date	2008.05.21.18.49.47;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2008.05.07.20.42.02;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2008.04.26.14.33.27;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.25.19.50.07;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2008.04.18.20.20.35;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.25.15.55.26;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.12.20.22.58;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.15.14.40.50;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.12.04.41.30;	author gwk;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.14.14.46.53;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.24.21.22.00;	author pvalchev;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.12.06.11.57;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.28.02.00.20;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.14.10.02.23;	author ho;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.07.14.10.02.24;	author ho;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.07.16.21.39.06;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.07.16.22.59.23;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.10.27.09.57.31;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2001.10.30.19.21.17;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2001.10.30.19.37.03;	author niklas;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2003.05.13.19.42.07;	author ho;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2003.05.17.19.14.44;	author niklas;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2004.03.22.23.47.53;	author niklas;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2004.03.23.23.02.19;	author niklas;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2004.03.23.23.26.06;	author niklas;	state Exp;
branches;
next	1.1.2.12;

1.1.2.12
date	2004.06.11.14.54.40;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.32
log
@
remove some unused #includes
@
text
@/* $OpenBSD: apicvec.s,v 1.31 2015/07/16 05:10:14 guenther Exp $ */
/* $NetBSD: apicvec.s,v 1.1.2.2 2000/02/21 21:54:01 sommerfeld Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "ioapic.h"

#include <machine/i82093reg.h>
#include <machine/i82489reg.h>

#define XINTR(vec) Xintr##vec

	.globl  _C_LABEL(apic_stray)

#ifdef MULTIPROCESSOR
	.globl	XINTR(ipi)
XINTR(ipi):
	subl	$8,%esp			/* space for tf_{err,trapno} */
	INTRENTRY
	MAKE_FRAME
	pushl	CPL
	movl	_C_LABEL(lapic_ppr),%eax
	movl	%eax,CPL
	ioapic_asm_ack()
	sti			/* safe to take interrupts.. */
	call	_C_LABEL(i386_ipi_handler)
	cli
	popl	CPL
	INTRFASTEXIT

	.globl	XINTR(ipi_invltlb)
	.p2align 4,0x90
XINTR(ipi_invltlb):
	pushl	%eax
	pushl	%ds
	movl	$GSEL(GDATA_SEL, SEL_KPL), %eax
	movl	%eax, %ds

	ioapic_asm_ack()

	movl	%cr3, %eax
	movl	%eax, %cr3

	lock
	decl	tlb_shoot_wait

	popl	%ds
	popl	%eax
	iret

	.globl	XINTR(ipi_invlpg)
	.p2align 4,0x90
XINTR(ipi_invlpg):
	pushl	%eax
	pushl	%ds
	movl	$GSEL(GDATA_SEL, SEL_KPL), %eax
	movl	%eax, %ds

	ioapic_asm_ack()

	movl	tlb_shoot_addr1, %eax
	invlpg	(%eax)

	lock
	decl	tlb_shoot_wait

	popl	%ds
	popl	%eax
	iret

	.globl	XINTR(ipi_invlrange)
	.p2align 4,0x90
XINTR(ipi_invlrange):
	pushl	%eax
	pushl	%edx
	pushl	%ds
	movl	$GSEL(GDATA_SEL, SEL_KPL), %eax
	movl	%eax, %ds

	ioapic_asm_ack()

	movl	tlb_shoot_addr1, %eax
	movl	tlb_shoot_addr2, %edx
1:	invlpg	(%eax)
	addl	$PAGE_SIZE, %eax
	cmpl	%edx, %eax
	jb	1b

	lock
	decl	tlb_shoot_wait

	popl	%ds
	popl	%edx
	popl	%eax
	iret

	.globl	XINTR(ipi_reloadcr3)
	.p2align 4,0x90
XINTR(ipi_reloadcr3):
	pushl	%eax
	pushl	%ds
	movl	$GSEL(GDATA_SEL, SEL_KPL), %eax
	movl	%eax, %ds
	pushl	%fs
	movl	$GSEL(GCPU_SEL, SEL_KPL),%eax
	movw	%ax,%fs

	ioapic_asm_ack()

	movl	CPUVAR(CURPCB), %eax
	movl	PCB_PMAP(%eax), %eax
	movl	%eax, CPUVAR(CURPMAP)
	movl	PM_PDIRPA(%eax), %eax
	movl	%eax, %cr3

	lock
	decl	tlb_shoot_wait

	popl	%fs
	popl	%ds
	popl	%eax
	iret

#endif

	/*
	 * Interrupt from the local APIC timer.
	 */
	.globl	XINTR(ltimer)
XINTR(ltimer):
	subl	$8,%esp			/* space for tf_{err,trapno} */
	INTRENTRY
	MAKE_FRAME
	pushl	CPL
	movl	_C_LABEL(lapic_ppr),%eax
	movl	%eax,CPL
	ioapic_asm_ack()
	sti
	incl	CPUVAR(IDEPTH)
	movl	%esp,%eax
	pushl	%eax
	call	_C_LABEL(lapic_clockintr)
	addl	$4,%esp
	decl	CPUVAR(IDEPTH)
	jmp	_C_LABEL(Xdoreti)

	.globl	XINTR(softclock), XINTR(softnet), XINTR(softtty)
XINTR(softclock):
	subl	$8,%esp			/* space for tf_{err,trapno} */
	INTRENTRY
	MAKE_FRAME
	pushl	CPL
	movl	$IPL_SOFTCLOCK,CPL
	andl	$~(1<<SIR_CLOCK),CPUVAR(IPENDING)
	ioapic_asm_ack()
	sti
	incl	CPUVAR(IDEPTH)
	pushl	$I386_SOFTINTR_SOFTCLOCK
	call	_C_LABEL(softintr_dispatch)
	addl	$4,%esp
	decl	CPUVAR(IDEPTH)
	jmp	_C_LABEL(Xdoreti)

XINTR(softnet):
	subl	$8,%esp			/* space for tf_{err,trapno} */
	INTRENTRY
	MAKE_FRAME
	pushl	CPL
	movl	$IPL_SOFTNET,CPL
	andl	$~(1<<SIR_NET),CPUVAR(IPENDING)
	ioapic_asm_ack()
	sti
	incl	CPUVAR(IDEPTH)
	pushl	$I386_SOFTINTR_SOFTNET
	call	_C_LABEL(softintr_dispatch)
	addl	$4,%esp
	decl	CPUVAR(IDEPTH)
	jmp	_C_LABEL(Xdoreti)
#undef DONETISR

XINTR(softtty):
	subl	$8,%esp			/* space for tf_{err,trapno} */
	INTRENTRY
	MAKE_FRAME
	pushl	CPL
	movl	$IPL_SOFTTTY,CPL
	andl	$~(1<<SIR_TTY),CPUVAR(IPENDING)
	ioapic_asm_ack()
	sti
	incl	CPUVAR(IDEPTH)
	pushl	$I386_SOFTINTR_SOFTTTY
	call	_C_LABEL(softintr_dispatch)
	addl	$4,%esp
	decl	CPUVAR(IDEPTH)
	jmp	_C_LABEL(Xdoreti)

#if NIOAPIC > 0

#define voidop(num)

	/*
	 * I/O APIC interrupt.
	 * We sort out which one is which based on the value of
	 * the processor priority register.
	 *
	 * XXX use cmove when appropriate.
	 */

#define APICINTR(name, num, early_ack, late_ack, mask, unmask, level_mask) \
_C_LABEL(Xintr_##name##num):						\
	subl	$8,%esp			/* space for tf_{err,trapno} */	;\
	INTRENTRY							;\
	MAKE_FRAME							;\
	pushl	CPL							;\
	movl	_C_LABEL(lapic_ppr),%eax				;\
	orl	$num,%eax						;\
	movl	_C_LABEL(apic_maxlevel)(,%eax,4),%ebx			;\
	movl	%ebx,CPL						;\
	mask(num)			/* mask it in hardware */	;\
	early_ack(num)			/* and allow other intrs */	;\
	incl	_C_LABEL(uvmexp)+V_INTR	/* statistical info */		;\
	sti								;\
	movl	_C_LABEL(apic_intrhand)(,%eax,4),%ebx /* chain head */	;\
	testl	%ebx,%ebx						;\
	jz      _C_LABEL(Xstray_##name##num)				;\
	APIC_STRAY_INIT			/* nobody claimed it yet */	;\
7:	incl	CPUVAR(IDEPTH)						;\
	movl	%esp, %eax		/* save frame pointer in eax */	;\
	pushl	%ebx			/* arg 2: ih structure */	;\
	pushl	%eax			/* arg 1: frame pointer */	;\
	call	_C_LABEL(intr_handler)	/* call it */			;\
	addl	$8, %esp		/* toss args */			;\
	APIC_STRAY_INTEGRATE		/* maybe he claimed it */	;\
	orl	%eax,%eax		/* should it be counted? */	;\
	jz	4f							;\
	addl	$1,IH_COUNT(%ebx)	/* count the intrs */		;\
	adcl	$0,IH_COUNT+4(%ebx)					;\
	cmpl	$0,_C_LABEL(intr_shared_edge)				;\
	jne	4f			/* if no shared edges ... */	;\
	orl	%eax,%eax		/* ... 1 means stop trying */	;\
	js	4f							;\
1:	decl	CPUVAR(IDEPTH)						;\
	jmp	8f							;\
4:	decl	CPUVAR(IDEPTH)						;\
	movl	IH_NEXT(%ebx),%ebx	/* next handler in chain */	;\
	testl	%ebx,%ebx						;\
	jnz	7b							;\
	APIC_STRAY_TEST(name,num)	/* see if it's a stray */	;\
8:									 \
	unmask(num)			/* unmask it in hardware */	;\
	late_ack(num)							;\
	jmp	_C_LABEL(Xdoreti)					;\
_C_LABEL(Xstray_##name##num):					 \
	pushl	$num							;\
	call	_C_LABEL(apic_stray)					;\
	addl	$4,%esp							;\
	jmp	8b							;\

#if defined(DEBUG)
#define APIC_STRAY_INIT \
	xorl	%esi,%esi
#define	APIC_STRAY_INTEGRATE \
	orl	%eax,%esi
#define APIC_STRAY_TEST(name,num) \
	testl 	%esi,%esi						;\
	jz 	_C_LABEL(Xstray_##name##num)
#else /* !DEBUG */
#define APIC_STRAY_INIT
#define APIC_STRAY_INTEGRATE
#define APIC_STRAY_TEST(name,num)
#endif /* DEBUG */

APICINTR(ioapic,0, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,1, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,2, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,3, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,4, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,5, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,6, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,7, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,8, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,9, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,10, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,11, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,12, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,13, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,14, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,15, voidop, ioapic_asm_ack, voidop, voidop, voidop)

	.globl	_C_LABEL(Xintr_ioapic0),_C_LABEL(Xintr_ioapic1)
	.globl	_C_LABEL(Xintr_ioapic2),_C_LABEL(Xintr_ioapic3)
	.globl	_C_LABEL(Xintr_ioapic4),_C_LABEL(Xintr_ioapic5)
	.globl	_C_LABEL(Xintr_ioapic6),_C_LABEL(Xintr_ioapic7)
	.globl	_C_LABEL(Xintr_ioapic8),_C_LABEL(Xintr_ioapic9)
	.globl	_C_LABEL(Xintr_ioapic10),_C_LABEL(Xintr_ioapic11)
	.globl	_C_LABEL(Xintr_ioapic12),_C_LABEL(Xintr_ioapic13)
	.globl	_C_LABEL(Xintr_ioapic14),_C_LABEL(Xintr_ioapic15)
	.globl _C_LABEL(apichandler)

_C_LABEL(apichandler):
	.long	_C_LABEL(Xintr_ioapic0),_C_LABEL(Xintr_ioapic1)
	.long	_C_LABEL(Xintr_ioapic2),_C_LABEL(Xintr_ioapic3)
	.long	_C_LABEL(Xintr_ioapic4),_C_LABEL(Xintr_ioapic5)
	.long	_C_LABEL(Xintr_ioapic6),_C_LABEL(Xintr_ioapic7)
	.long	_C_LABEL(Xintr_ioapic8),_C_LABEL(Xintr_ioapic9)
	.long	_C_LABEL(Xintr_ioapic10),_C_LABEL(Xintr_ioapic11)
	.long	_C_LABEL(Xintr_ioapic12),_C_LABEL(Xintr_ioapic13)
	.long	_C_LABEL(Xintr_ioapic14),_C_LABEL(Xintr_ioapic15)

#endif

@


1.31
log
@Move grab/release of the kernel_lock for softintrs from the ASM stubs to
softintr_dispatch().  Delete traces of long superseded stats code.

ok beck@@ mpi@@ uebayasi@@
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.30 2015/06/28 01:11:27 guenther Exp $ */
d34 2
@


1.30
log
@Split AST handling from trap() into ast() and get rid of T_ASTFLT

testing by krw@@, and then many via snapshots
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.29 2015/02/07 00:26:37 deraadt Exp $ */
a184 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintlock)
#endif
a187 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintunlock)
#endif
a200 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintlock)
#endif
a203 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintunlock)
#endif
a217 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintlock)
#endif
a220 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintunlock)
#endif
@


1.29
log
@Delete non-ELF support, in particular .align 12 (always a bit jarring)
ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.28 2013/11/28 19:30:46 brad Exp $ */
d45 1
a45 2
	pushl	$0
	pushl	$T_ASTFLT
d158 1
a158 2
	pushl	$0
	pushl	$T_ASTFLT
d176 1
a176 2
	pushl	$0
	pushl	$T_ASTFLT
d198 1
a198 2
	pushl	$0
	pushl	$T_ASTFLT
d221 1
a221 2
	pushl	$0
	pushl	$T_ASTFLT
d256 1
a256 2
	pushl	$0							;\
	pushl	$T_ASTFLT						;\
@


1.28
log
@Appease LLVM's integrated assembler.

error: ambiguous instructions require an explicit suffix (could be 'cmpb', 'cmpw', 'cmpl', or 'cmpq'
error: unknown token in expression

cmp -> cmpl, %cs:* -> *%cs:

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.27 2013/05/12 14:15:31 ratchov Exp $ */
a37 1
#ifdef __ELF__
a38 3
#else
#define XINTR(vec) _Xintr##vec
#endif
@


1.27
log
@Take the kernel lock and call the actual interrupt handler from a
single c function. This will hopefully make easier to stop taking
the kernel lock when running "mp safe" interrupt handlers.

help from ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.26 2012/07/09 16:09:47 deraadt Exp $ */
d293 1
a293 1
	cmp	$0,_C_LABEL(intr_shared_edge)				;\
@


1.26
log
@Remove apic_intrcount counting in the interrupt handlers.  Not that useful
anymore as a debugging tool, and it is in a rather critical path.
ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.25 2011/09/22 12:17:04 deraadt Exp $ */
d282 6
a287 11
7:									 \
	incl	CPUVAR(IDEPTH)						;\
	LOCK_KERNEL(IF_PPL(%esp))					;\
	movl	IH_ARG(%ebx),%eax	/* get handler arg */		;\
	testl	%eax,%eax						;\
	jnz	6f							;\
	movl	%esp,%eax		/* 0 means frame pointer */	;\
6:									 \
	pushl	%eax							;\
	call	*IH_FUN(%ebx)		/* call it */			;\
	addl	$4,%esp			/* toss the arg */		;\
d297 1
a297 2
1:	UNLOCK_KERNEL(IF_PPL(%esp))					;\
	decl	CPUVAR(IDEPTH)						;\
d299 1
a299 2
4:	UNLOCK_KERNEL(IF_PPL(%esp))					;\
	decl	CPUVAR(IDEPTH)						;\
@


1.25
log
@The MY_COUNT abstraction which depends on locore including these two
files is ridiculous.  Remove it.
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.24 2011/07/05 17:11:07 oga Exp $ */
a277 1
	incl	_C_LABEL(apic_intrcount)(,%eax,4)			;\
@


1.24
log
@N: Thou shalt not call hardclock() with biglock held.

i386 disobeys the Nth commandment. Fix this. While here, make i386 and amd64
definitions of iplclock and statclock match.

ok art@@, kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.23 2011/04/16 00:40:58 deraadt Exp $ */
d276 1
a276 1
	incl	MY_COUNT+V_INTR		/* statistical info */		;\
@


1.23
log
@More than a decade ago, interrupt handlers on sparc started returning 0
(interrupt was not for me), 1 (positive interrupt was for me), or -1
(i am not sure...).  We have continued with this practice in as many
drivers as possible, throughout the tree.

This makes some of the architectures use that information in their
interrupt handler calling code -- if 1 is returned (and we know
this specific machine does not have edge-shared interrupts), we
finish servicing other possible handlers on the same pin.  If the
interrupt pin remains asserted (from a different device), we will
end up back in the interrupt servicing code of course... but this is
cheaper than calling all the chained interrupts on a pin.

This does of course count on shared level interrupts being properly
sorted by IPL.

There have been some concerns about starvation of drivers which
incorrectly return 1.  Those drivers should be hunted down so that
they return -1.

ok and help from various people.  In snaps for about a week now.
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.22 2010/12/21 14:56:23 claudio Exp $ */
a172 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintlock)
#endif
a176 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintunlock)
#endif
@


1.22
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.21 2010/01/11 23:09:52 kettenis Exp $ */
d305 8
a312 2
4:									 \
	UNLOCK_KERNEL(IF_PPL(%esp))					;\
@


1.21
log
@Increase/decrease the per-CPU interrupt depth variable around APIC interrupts
like we do for PIC interrupts.

ok art@@, deraadt@@, oga@@
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.20 2009/08/10 16:40:50 oga Exp $ */
a209 7
#define DONETISR(s, c) \
	.globl  _C_LABEL(c)	;\
	testl	$(1 << s),%edi	;\
	jz	1f		;\
	call	_C_LABEL(c)	;\
1:

a223 5
	xorl	%edi,%edi
	xchgl	_C_LABEL(netisr),%edi

#include <net/netisr_dispatch.h>

@


1.20
log
@right now, we only increment ci_idepth in struct cpuinfo when
MULTIPROCESSOR is defined. This makes splassert incorrect for IPL_NONE
on such kernels.

Make this more similar to amd64, and move the inc and dec of ci_idepth
into the interrupt vectors, and only leave biglock in the locking
functions.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.19 2009/07/10 13:51:47 jsg Exp $ */
d302 1
d319 1
@


1.19
log
@Switch away from using -traditional-cpp to iso/ansi cpp for asm files.
More architectures hopefully to follow.
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.18 2009/06/06 22:37:34 guenther Exp $ */
d172 1
d183 1
d197 1
d207 1
d227 1
d242 1
d256 1
d266 1
@


1.18
log
@ipi_reloadcr3 uses CPUVAR, so it needs to set up %fs in order to
work if it interrupts userspace

ok kettenis@@  "you haven't committed that yet?" art@@
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.17 2009/06/03 00:49:12 art Exp $ */
d39 1
a39 1
#define XINTR(vec) Xintr/**/vec
d41 1
a41 1
#define XINTR(vec) _Xintr/**/vec
d274 1
a274 1
_C_LABEL(Xintr_/**/name/**/num):					\
d291 1
a291 1
	jz      _C_LABEL(Xstray_/**/name/**/num)			;\
d318 1
a318 1
_C_LABEL(Xstray_/**/name/**/num):					 \
d331 1
a331 1
	jz 	_C_LABEL(Xstray_/**/name/**/num)
@


1.17
log
@Just like on amd64. Instead of keeping a bitmap of which cpus a pmap
is active on, save a curpmap pointer in cpu_info. This lets us simplify
a few things and do lazy context switching from a user process to a
kernel thread. There's a new IPI introduced for forcing a cr3 reload
when we're tearing down a dead pmap.

kettenis@@ ok (after I polished a few minor things)
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.16 2008/06/26 05:42:10 ray Exp $ */
d136 3
d151 1
@


1.16
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.15 2008/05/21 18:49:47 kettenis Exp $ */
d126 23
@


1.15
log
@Switch i386 from pccom to com.  Welcomed by many.

ok dlg@@, jsing@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.14 2008/05/07 20:42:02 kettenis Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.14
log
@Move i386 to __HAVE_GENERIC_SOFT_INTERRUPTS

ok dlg@@, tested by dlg@@, oga@@, jsg@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.13 2008/04/26 14:33:27 kettenis Exp $ */
d233 3
a235 1
	call	_C_LABEL(comsoft)
@


1.13
log
@Remove softast; it's no longer used.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.12 2008/04/25 19:50:07 kettenis Exp $ */
d178 3
a180 1
	call	_C_LABEL(softclock)
d208 1
d210 4
@


1.12
log
@Make ipending per-cpu.  Should fix PR 5788.

ok weingart@@
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.11 2008/04/18 20:20:35 kettenis Exp $ */
d164 1
a164 1
	.globl	XINTR(softclock), XINTR(softnet), XINTR(softtty), XINTR(softast)
a229 12
	jmp	_C_LABEL(Xdoreti)

XINTR(softast):
	pushl	$0
	pushl	$T_ASTFLT
	INTRENTRY
	MAKE_FRAME
	pushl	CPL
	movl	$IPL_SOFTAST,CPL
	andl	$~(1<<SIR_AST),CPUVAR(IPENDING)
	ioapic_asm_ack()
	sti
@


1.11
log
@Now that i386 has a per-process astpending, we can garbage collect ipi_ast
and do an ipi_nop cross-call from signotify() instead.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.10 2007/05/25 15:55:26 art Exp $ */
d172 1
a172 1
	andl	$~(1<<SIR_CLOCK),_C_LABEL(ipending)
d198 1
a198 1
	andl	$~(1<<SIR_NET),_C_LABEL(ipending)
d220 1
a220 1
	andl	$~(1<<SIR_TTY),_C_LABEL(ipending)
d239 1
a239 1
	andl	$~(1<<SIR_AST),_C_LABEL(ipending)
@


1.10
log
@Replace the overdesigned and overcomplicated tlb shootdown code with
very simple and dumb fast tlb IPI handlers that have in the order of
the same amount of instructions as the old code had function calls.

All TLB shootdowns are reorganized so that we always shoot the,
without looking at PG_U and when we're shooting a range (primarily in
pmap_remove), we shoot the range when there are 32 or less pages in
it, otherwise we just nuke the whole TLB (this might need tweaking if
someone is interested in micro-optimization). The IPIs are not handled
through the normal interrupt vectoring code, they are not blockable
and they only shoot one page or a range of pages or the whole tlb.

This gives a 15% reduction in system time on my dual-core laptop
during a kernel compile and an 18% reduction in real time on a quad
machine doing bulk ports build.

Tested by many, in snaps for a week, no slowdowns reported (although not
everyone is seeing such huge wins).
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.9 2007/04/12 20:22:58 art Exp $ */
a68 20

	.globl XINTR(ipi_ast)
XINTR(ipi_ast):
	pushl	%eax
	pushl	%ds
	movl	$GSEL(GDATA_SEL, SEL_KPL), %eax
	movl	%eax, %ds

	ioapic_asm_ack()

	movl	$IPL_SOFTAST, %eax
	orl	$(1 << SIR_AST), _C_LABEL(ipending)

	orl	$(LAPIC_DLMODE_FIXED|LAPIC_LVL_ASSERT|LAPIC_DEST_SELF), %eax
	movl	%eax, _C_LABEL(local_apic) + LAPIC_ICRLO

	movl	_C_LABEL(local_apic) + LAPIC_ID, %eax
	popl	%ds
	popl	%eax
	iret
@


1.9
log
@Faster signal delivery on i386/MP.

We need to poke the other CPU so that it processes the AST immediately
and doesn't wait for the next interrupt or syscall.

Since IPIs really shouldn't process ASTs, we need to trigger a soft
interrupt on the destination CPU to process the AST. But since we can't
send soft interrupts to other CPUs, we send an IPI, that triggers a soft
interrupt that in turn processes the AST.

Also, this marks the beginning of moving to slightly better IPI mechanism
of short and optimized IPIs instead of the large and complicated IPI
infrastructure we're using now.

tested by many, ok tholo@@
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.8 2006/11/15 14:40:50 mickey Exp $ */
d89 67
@


1.8
log
@do not go processing normal interrupts after ipi.
this is to avoid spins at high spl especialy on cpu0.
other local interrupts (timer and softint) still do
also pending interrupts processing. niklas@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.7 2006/06/12 04:41:30 gwk Exp $ */
d69 20
d117 1
a117 1
	.globl	XINTR(softclock), XINTR(softnet), XINTR(softtty)
d183 12
@


1.7
log
@Add stray interrupt reporting to the apicvec.s, fix the code for stray
interrupt reporting in vector.s. Stray interrupts will only be reported if
a kernel is compiled with option DEBUG, in the case of a non-ioapic kernel
some stray interrupts may be erroneously reported durring the boot process.
ok toby@@, "get it in" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.6 2006/03/14 14:46:53 mickey Exp $ */
d66 3
a68 1
	jmp	_C_LABEL(Xdoreti)
@


1.6
log
@trailing tabs nomore
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.5 2004/12/24 21:22:00 pvalchev Exp $ */
d51 2
a171 1
	 * XXX no stray interrupt mangling stuff..
d193 2
a194 1
	jz	8f			/* oops, no handlers.. */	;\
d205 1
d215 1
d219 20
a238 1
	jmp	_C_LABEL(Xdoreti)
@


1.5
log
@Rewrite intlock/intunlock not to pass around interrupt frame directly
without copying which is against C conventions and broke GENERIC.MP
with a gcc3 optimization
From niklas, tested by many
@
text
@d1 2
a2 2
/* $OpenBSD: apicvec.s,v 1.4 2004/08/12 06:11:57 niklas Exp $ */	
/* $NetBSD: apicvec.s,v 1.1.2.2 2000/02/21 21:54:01 sommerfeld Exp $ */	
d41 1
a41 1
	
d43 1
a43 1
#include <machine/i82489reg.h>	
d54 1
a54 1
	pushl	$0		
d56 2
a57 2
	INTRENTRY		
	MAKE_FRAME		
d62 1
a62 1
        sti			/* safe to take interrupts.. */
d66 1
a66 1
	
d71 2
a72 2
XINTR(ltimer):			
	pushl	$0		
d74 2
a75 2
	INTRENTRY		
	MAKE_FRAME		
d87 1
a87 1
	addl	$4,%esp		
d95 1
a95 1
	pushl	$0		
d97 2
a98 2
	INTRENTRY		
	MAKE_FRAME		
d112 1
a112 1
	
d121 1
a121 1
	pushl	$0		
d123 2
a124 2
	INTRENTRY		
	MAKE_FRAME		
d142 2
a143 2
XINTR(softtty):	
	pushl	$0		
d145 2
a146 2
	INTRENTRY		
	MAKE_FRAME		
d167 1
a167 1
	 * We sort out which one is which based on the value of 
d173 1
a173 1
	
d216 1
a216 1
	
d244 1
a244 1
_C_LABEL(apichandler):	
d255 1
a255 1
	
@


1.4
log
@Fix the shared irq problem, by allocating a low priority vector
so that the "high" pri interrupt gets blocked by the "low" spl & irq handler,
and raise the cpl to the "high" level in the handler, so that no other
in fact lower-leveled, interrupts can preempt the handling of the "high"
interrupt.  This means that the "low" interrupt gets the same quality treatment,
thus causing some degradation in performance.  Therefore we still issue a
diagnostic, so people can try to avoid the situation by tweaking their BIOS
settings. Note, there is still issues with dynamically established interrupts
which cause irq sharing, we are working on that.
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.4 2004/08/12 06:08:50 niklas Exp $ */	
d194 1
a194 1
	LOCK_KERNEL							;\
d208 1
a208 1
	UNLOCK_KERNEL							;\
@


1.3
log
@move from unsafe ev_count32 to safe ev_count; aaron ok
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.2 2004/06/13 21:49:15 niklas Exp $ */	
d182 3
a184 1
	movl	%eax,CPL						;\
a188 1
	orl	$num,%eax						;\
@


1.2
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/* $OpenBSD$ */	
d202 5
a207 1
	incl	IH_COUNT(%ebx)		/* count the intrs */		;\
@


1.1
log
@file apicvec.s was initially added on branch SMP.
@
text
@d1 250
@


1.1.2.1
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@a0 200
/* $NetBSD: apicvec.s,v 1.1.2.2 2000/02/21 21:54:01 sommerfeld Exp $ */	

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
	
#include <machine/i82489reg.h>	

#ifdef __ELF__
#define XINTR(irq_num) Xintr/**/irq_num
#else
#define XINTR(irq_num) _Xintr/**/irq_num
#endif

#ifdef MULTIPROCESSOR
	.globl	XINTR(ipi)
XINTR(ipi):
	pushl	$0		
	pushl	$T_ASTFLT
	INTRENTRY		
	MAKE_FRAME		
	pushl	CPL
	movl	_C_LABEL(lapic_ppr),%eax
	movl	%eax,CPL
	movl	$0,_C_LABEL(local_apic)+LAPIC_EOI
        sti			/* safe to take interrupts.. */
	call	_C_LABEL(i386_ipi_handler)
	jmp	_C_LABEL(Xdoreti)
#endif
	
	
	/*
	 * Interrupt from the local APIC timer.
	 */
	.globl	XINTR(ltimer)
XINTR(ltimer):			
	pushl	$0		
	pushl	$T_ASTFLT
	INTRENTRY		
	MAKE_FRAME		
	pushl	CPL
	movl	_C_LABEL(lapic_ppr),%eax
	movl	%eax,CPL
	movl	$0,_C_LABEL(local_apic)+LAPIC_EOI
	sti
	movl	%esp,%eax
	pushl	%eax
	call	_C_LABEL(lapic_clockintr)
	addl	$4,%esp		
	jmp	_C_LABEL(Xdoreti)

	.globl	XINTR(softclock), XINTR(softnet), XINTR(softtty)
XINTR(softclock):
	pushl	$0		
	pushl	$T_ASTFLT
	INTRENTRY		
	MAKE_FRAME		
	pushl	CPL
	movl	$IPL_CLOCK,CPL  /* XXX was IPL_SOFTCLOCK */
	andl	$~(1<<SIR_CLOCK),_C_LABEL(ipending)
	movl	$0,_C_LABEL(local_apic)+LAPIC_EOI
	sti
	call	_C_LABEL(softclock)
	jmp	_C_LABEL(Xdoreti)
	
XINTR(softnet):
	pushl	$0		
	pushl	$T_ASTFLT
	INTRENTRY		
	MAKE_FRAME		
	pushl	CPL
	movl	$IPL_NET,CPL	/* XXX was IPL_SOFTNET */
	andl	$~(1<<SIR_NET),_C_LABEL(ipending)
	movl	$0,_C_LABEL(local_apic)+LAPIC_EOI	
	sti
	xorl	%edi,%edi
	xchgl	_C_LABEL(netisr),%edi

	jmp	_C_LABEL(Xdoreti)

XINTR(softtty):	
	pushl	$0		
	pushl	$T_ASTFLT
	INTRENTRY		
	MAKE_FRAME		
	pushl	CPL
	movl	$IPL_TTY,CPL	/* XXX was IPL_SOFTTTY */
	andl	$~(1<<SIR_TTY),_C_LABEL(ipending)
	movl	$0,_C_LABEL(local_apic)+LAPIC_EOI	
	sti
	call	_C_LABEL(comsoft)
	jmp	_C_LABEL(Xdoreti)

#if NIOAPIC > 0
	/*
	 * I/O APIC interrupt.
	 * We sort out which one is which based on the value of 
	 * the processor priority register.
	 *
	 * XXX no stray interrupt mangling stuff..
	 * XXX use cmove when appropriate.
	 */
	
#define APICINTR(minor)							\
XINTR(ioapic/**/minor):						\
	pushl	$0							;\
	pushl	$T_ASTFLT						;\
	INTRENTRY							;\
	MAKE_FRAME							;\
	pushl	CPL							;\
	movl	_C_LABEL(lapic_ppr),%eax				;\
	movl	%eax,CPL						;\
	movl	$0,_C_LABEL(local_apic)+LAPIC_EOI			;\
	sti								;\
	orl	$minor,%eax						;\
	incl	_C_LABEL(apic_intrcount)(,%eax,4)			;\
	movl	_C_LABEL(apic_intrhand)(,%eax,4),%ebx /* chain head */	;\
	testl	%ebx,%ebx						;\
	jz	8f			/* oops, no handlers.. */	;\
7:									 \
	movl	IH_ARG(%ebx),%eax	/* get handler arg */		;\
	testl	%eax,%eax						;\
	jnz	6f							;\
	movl	%esp,%eax		/* 0 means frame pointer */	;\
6:									 \
	pushl	%eax							;\
	call	IH_FUN(%ebx)		/* call it */			;\
	addl	$4,%esp			/* toss the arg */		;\
	incl	IH_COUNT(%ebx)		/* count the intrs */		;\
	movl	IH_NEXT(%ebx),%ebx	/* next handler in chain */	;\
	testl	%ebx,%ebx						;\
	jnz	7b							;\
8:									 \
	jmp	_C_LABEL(Xdoreti)
	
APICINTR(0)
APICINTR(1)
APICINTR(2)
APICINTR(3)
APICINTR(4)
APICINTR(5)
APICINTR(6)
APICINTR(7)
APICINTR(8)
APICINTR(9)
APICINTR(10)
APICINTR(11)
APICINTR(12)
APICINTR(13)
APICINTR(14)
APICINTR(15)

	.globl _C_LABEL(apichandler)

_C_LABEL(apichandler):	
	.long	_C_LABEL(Xintrioapic0),_C_LABEL(Xintrioapic1)
	.long	_C_LABEL(Xintrioapic2),_C_LABEL(Xintrioapic3)
	.long	_C_LABEL(Xintrioapic4),_C_LABEL(Xintrioapic5)
	.long	_C_LABEL(Xintrioapic6),_C_LABEL(Xintrioapic7)
	.long	_C_LABEL(Xintrioapic8),_C_LABEL(Xintrioapic9)
	.long	_C_LABEL(Xintrioapic10),_C_LABEL(Xintrioapic11)
	.long	_C_LABEL(Xintrioapic12),_C_LABEL(Xintrioapic13)
	.long	_C_LABEL(Xintrioapic14),_C_LABEL(Xintrioapic15)

#endif
	
@


1.1.2.2
log
@KNF
@
text
@a0 1
/* $OpenBSD: apicvec.s,v 1.1.2.2 2000/02/21 21:54:01 sommerfeld Exp $ */	
@


1.1.2.3
log
@export some interrupt handler symbols to ease debugging
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.1.2.2 2001/07/16 21:39:06 niklas Exp $ */	
a187 8
	.globl	_C_LABEL(Xintrioapic0),_C_LABEL(Xintrioapic1)
	.globl	_C_LABEL(Xintrioapic2),_C_LABEL(Xintrioapic3)
	.globl	_C_LABEL(Xintrioapic4),_C_LABEL(Xintrioapic5)
	.globl	_C_LABEL(Xintrioapic6),_C_LABEL(Xintrioapic7)
	.globl	_C_LABEL(Xintrioapic8),_C_LABEL(Xintrioapic9)
	.globl	_C_LABEL(Xintrioapic10),_C_LABEL(Xintrioapic11)
	.globl	_C_LABEL(Xintrioapic12),_C_LABEL(Xintrioapic13)
	.globl	_C_LABEL(Xintrioapic14),_C_LABEL(Xintrioapic15)
@


1.1.2.4
log
@New interrupt and spl* system, mostly from NetBSD's i386 MP branch
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.1.2.3 2001/07/16 22:59:23 niklas Exp $ */	
d94 1
a94 1
	movl	$IPL_SOFTCLOCK,CPL
d107 1
a107 1
	movl	$IPL_SOFTNET,CPL
d122 1
a122 1
	movl	$IPL_SOFTTTY,CPL
@


1.1.2.5
log
@run network soft interrupts!
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.1.2.4 2001/10/27 09:57:31 niklas Exp $ */	
d113 1
a113 1
#include <net/netisr_dispatch.h>
@


1.1.2.6
log
@netisr_dispatch preprocessor magic
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.1.2.5 2001/10/30 19:21:17 niklas Exp $ */	
a100 7
#define DONETISR(s, c) \
	.globl  _C_LABEL(c)	;\
	testl	$(1 << s),%edi	;\
	jz	1f		;\
	call	_C_LABEL(c)	;\
1:

a114 1
#undef DONETISR
@


1.1.2.7
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/* $OpenBSD$ */	
d170 1
a170 1
	call	*IH_FUN(%ebx)		/* call it */			;\
@


1.1.2.8
log
@biglock added to apic vectors
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.1.2.7 2003/05/13 19:42:07 ho Exp $ */	
a80 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintlock)
#endif
a84 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintunlock)
#endif
a97 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintlock)
#endif
a98 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintunlock)
#endif
a117 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintlock)
#endif
a120 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintunlock)
#endif
a133 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintlock)
#endif
a134 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintunlock)
#endif
a163 1
	LOCK_KERNEL							;\
a171 1
	UNLOCK_KERNEL							;\
@


1.1.2.9
log
@style
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.1.2.8 2003/05/17 19:14:44 niklas Exp $ */	
d65 1
@


1.1.2.10
log
@Start making the intrstubs similar to the PIC handlers
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.1.2.9 2004/03/22 23:47:53 niklas Exp $ */	
a41 1
#include <machine/i82093reg.h>	
d45 1
a45 1
#define XINTR(name) Xintr/**/name
d47 1
a47 1
#define XINTR(name) _Xintr/**/name
a49 2
#define	IDTVEC(name)	ALIGN_TEXT; .globl X/**/name; X/**/name:

a50 11
IDTVEC(recurse_lapic_ipi)
	pushfl
	pushl	%cs
	pushl	%esi
	pushl	$0		
	pushl	$T_ASTFLT
	INTRENTRY		
IDTVEC(resume_lapic_ipi)
	cli
	jmp	1f
IDTVEC(intr_lapic_ipi)
d57 3
a60 8
	movl	CPUVAR(ILEVEL),%ebx
	cmpl	$IPL_IPI,%ebx
	jae	2f
1:
#ifdef notyet
	incl	CPUVAR(IDEPTH)
#endif
	movl	$IPL_IPI,CPUVAR(ILEVEL)
a61 1
	pushl	%ebx
a63 23
2:
	orl	$(1 << LIR_IPI),CPUVAR(IPENDING)
	sti
	INTRFASTEXIT

#ifdef notyet
#if defined(DDB)
IDTVEC(intrddbipi)
1:
	str	%ax
	GET_TSS
	movzwl	(%eax),%eax
	GET_TSS
	pushl	%eax
	movl	$0xff,_C_LABEL(lapic_tpr)
	movl	$0,_C_LABEL(local_apic)+LAPIC_EOI
	sti
	call	_C_LABEL(ddb_ipi_tss)
	addl	$4,%esp
	movl	$0,_C_LABEL(lapic_tpr)
	iret
	jmp	1b
#endif /* DDB */
a68 11
IDTVEC(recurse_lapic_ltimer)
	pushfl
	pushl	%cs
	pushl	%esi
	pushl	$0		
	pushl	$T_ASTFLT
	INTRENTRY		
IDTVEC(resume_lapic_ltimer)
	cli
	jmp	1f
IDTVEC(intr_lapic_ltimer)
d75 3
a78 9
	movl	CPUVAR(ILEVEL),%ebx
	cmpl	$IPL_CLOCK,%ebx
	jae	2f
1:
	pushl	%ebx
#ifdef notyet
	incl	CPUVAR(IDEPTH)
#endif
	movl	$IPL_CLOCK,CPUVAR(ILEVEL)
a90 4
2:
	orl	$(1 << LIR_TIMER),CPUVAR(IPENDING)
	sti
	INTRFASTEXIT
d98 3
a100 7
	movl	CPUVAR(ILEVEL),%ebx
	pushl	%ebx
	movl	$IPL_SOFTCLOCK,CPUVAR(ILEVEL)
#ifdef notyet
	incl	CPUVAR(IDEPTH)
#endif
	andl	$~(1<<SIR_CLOCK),CPUVAR(IPENDING)
a109 3
#ifdef notyet
	decl	CPUVAR(IDEPTH)
#endif
d124 3
a126 7
	movl	CPUVAR(ILEVEL),%ebx
	pushl	%ebx
	movl	$IPL_SOFTNET,CPUVAR(ILEVEL)
#ifdef notyet
	incl	CPUVAR(IDEPTH)
#endif
	andl	$~(1<<SIR_NET),CPUVAR(IPENDING)
a137 3
#ifdef notyet
	decl	CPUVAR(IDEPTH)
#endif
d146 3
a148 7
	movl	CPUVAR(ILEVEL),%ebx
	pushl	%ebx
	movl	$IPL_SOFTTTY,CPUVAR(ILEVEL)
#ifdef notyet
	incl	CPUVAR(IDEPTH)
#endif
	andl	$~(1<<SIR_TTY),CPUVAR(IPENDING)
a157 3
#ifdef notyet
	decl	CPUVAR(IDEPTH)
#endif
a160 3

#define voidop(num)

d170 2
a171 16
#define APICINTR(name, num, early_ack, late_ack, mask, unmask, level_mask) \
IDTVEC(recurse_/**/name/**/num)						;\
	pushfl								;\
	pushl	%cs							;\
	pushl	%esi							;\
	subl	$4,%esp							;\
	pushl	$T_ASTFLT		/* trap # for doing ASTs */	;\
	INTRENTRY							;\
IDTVEC(resume_/**/name/**/num)						\
/*	movl	$IREENT_MAGIC,TF_ERR(%esp)	*/			;\
/*	movl	%ebx,%esi	*/					;\
/*	movl	CPUVAR(ISOURCES) + (num) * 4, %ebp	*/		;\
/*	movl	IS_MAXLEVEL(%ebp),%ebx	*/				;\
	jmp	1f							;\
/*IDTVEC(intr_-**-name-**-num)*/					;\
XINTR(_/**/name/**/num):						\
d176 1
a176 10
/*	movl	CPUVAR(ISOURCES) + (num) * 4, %ebp	*/		;\
	mask(num)			/* mask it in hardware */	;\
	early_ack(num)			/* and allow other intrs */	;\
/*	movl	IS_MAXLEVEL(%ebp),%ebx	*/				;\
	movl	CPUVAR(ILEVEL),%esi					;\
/*	cmpl	%ebx,%esi	*/					;\
/*	jae	10f		*/	/* currently masked; hold it */	;\
/*	incl	MY_COUNT+V_INTR	*/	/* statistical info */		;\
1:									;\
	pushl	%esi							;\
d178 2
a179 1
	movl	%eax,CPUVAR(ILEVEL)					;\
d181 1
a181 1
	orl	$num,%eax						;\
a182 1
/*	incl	CPUVAR(IDEPTH)	*/					;\
d186 3
a188 1
7:	movl	IH_ARG(%ebx),%eax	/* get handler arg */		;\
d190 1
a190 1
	jnz	4f							;\
d192 1
a192 1
4:									 \
d196 1
a196 2
	orl	%eax,%eax		/* should it be counted? */	;\
	jz	5f			/* no, skip it */		;\
d198 1
a198 1
5:	movl	IH_NEXT(%ebx),%ebx	/* next handler in chain */	;\
d201 2
a202 14
	UNLOCK_KERNEL							;\
6:	cli								;\
	unmask(num)			/* unmask it in hardware */	;\
	late_ack(num)							;\
	sti								;\
	jmp	_C_LABEL(Xdoreti)					;\
8:	pushl	$num							;\
	call	_C_LABEL(isa_strayintr)					;\
	addl	$4,%esp							;\
	jmp	6b							;\
10:									;\
	orb	$IRQ_BIT(num),CPUVAR(IPENDING) + IRQ_BYTE(num)		;\
	sti								;\
	INTRFASTEXIT
d204 25
a228 25
APICINTR(ioapic,0, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,1, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,2, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,3, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,4, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,5, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,6, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,7, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,8, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,9, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,10, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,11, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,12, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,13, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,14, voidop, ioapic_asm_ack, voidop, voidop, voidop)
APICINTR(ioapic,15, voidop, ioapic_asm_ack, voidop, voidop, voidop)

	.globl	_C_LABEL(Xintr_ioapic0),_C_LABEL(Xintr_ioapic1)
	.globl	_C_LABEL(Xintr_ioapic2),_C_LABEL(Xintr_ioapic3)
	.globl	_C_LABEL(Xintr_ioapic4),_C_LABEL(Xintr_ioapic5)
	.globl	_C_LABEL(Xintr_ioapic6),_C_LABEL(Xintr_ioapic7)
	.globl	_C_LABEL(Xintr_ioapic8),_C_LABEL(Xintr_ioapic9)
	.globl	_C_LABEL(Xintr_ioapic10),_C_LABEL(Xintr_ioapic11)
	.globl	_C_LABEL(Xintr_ioapic12),_C_LABEL(Xintr_ioapic13)
	.globl	_C_LABEL(Xintr_ioapic14),_C_LABEL(Xintr_ioapic15)
d232 9
a240 8
	.long	_C_LABEL(Xintr_ioapic0),_C_LABEL(Xintr_ioapic1)
	.long	_C_LABEL(Xintr_ioapic2),_C_LABEL(Xintr_ioapic3)
	.long	_C_LABEL(Xintr_ioapic4),_C_LABEL(Xintr_ioapic5)
	.long	_C_LABEL(Xintr_ioapic6),_C_LABEL(Xintr_ioapic7)
	.long	_C_LABEL(Xintr_ioapic8),_C_LABEL(Xintr_ioapic9)
	.long	_C_LABEL(Xintr_ioapic10),_C_LABEL(Xintr_ioapic11)
	.long	_C_LABEL(Xintr_ioapic12),_C_LABEL(Xintr_ioapic13)
	.long	_C_LABEL(Xintr_ioapic14),_C_LABEL(Xintr_ioapic15)
d242 1
@


1.1.2.11
log
@Correct intrstubs
@
text
@d42 1
a42 1
#include <machine/i82093reg.h>
d46 1
a46 1
#define XINTR(vec) Xintr/**/vec
d48 1
a48 1
#define XINTR(vec) _Xintr/**/vec
d51 2
d54 11
d71 9
a79 4
	pushl	CPL
	movl	_C_LABEL(lapic_ppr),%eax
	movl	%eax,CPL
	ioapic_asm_ack()
d81 1
d84 23
d112 11
d129 10
a138 4
	pushl	CPL
	movl	_C_LABEL(lapic_ppr),%eax
	movl	%eax,CPL
	ioapic_asm_ack()
d151 4
d162 8
a169 4
	pushl	CPL
	movl	$IPL_SOFTCLOCK,CPL
	andl	$~(1<<SIR_CLOCK),_C_LABEL(ipending)
	ioapic_asm_ack()
d178 3
d195 8
a202 4
	pushl	CPL
	movl	$IPL_SOFTNET,CPL
	andl	$~(1<<SIR_NET),_C_LABEL(ipending)
	ioapic_asm_ack()
d213 3
d224 8
a231 4
	pushl	CPL
	movl	$IPL_SOFTTTY,CPL
	andl	$~(1<<SIR_TTY),_C_LABEL(ipending)
	ioapic_asm_ack()
d240 3
d259 15
a273 1
_C_LABEL(Xintr_/**/name/**/num):					\
d278 1
a278 3
	pushl	CPL							;\
	movl	_C_LABEL(lapic_ppr),%eax				;\
	movl	%eax,CPL						;\
d281 9
d293 1
d297 1
a297 3
7:									 \
	LOCK_KERNEL							;\
	movl	IH_ARG(%ebx),%eax	/* get handler arg */		;\
d299 1
a299 1
	jnz	6f							;\
d301 1
a301 1
6:									 \
d305 2
a306 1
	UNLOCK_KERNEL							;\
d308 1
a308 1
	movl	IH_NEXT(%ebx),%ebx	/* next handler in chain */	;\
d311 2
a312 1
8:									 \
d315 10
a324 1
	jmp	_C_LABEL(Xdoreti)
a361 1

a362 1
	
@


1.1.2.12
log
@increment the uvmexp interrupt counter in the MP interrupt handler.
@
text
@d1 1
a1 1
/* $OpenBSD: apicvec.s,v 1.1.2.11 2004/03/23 23:26:06 niklas Exp $ */	
a184 1
	incl	MY_COUNT+V_INTR		/* statistical info */		;\
@


