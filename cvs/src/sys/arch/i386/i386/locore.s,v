head	1.180;
access;
symbols
	OPENBSD_6_2:1.180.0.4
	OPENBSD_6_2_BASE:1.180
	OPENBSD_6_1:1.172.0.4
	OPENBSD_6_1_BASE:1.172
	OPENBSD_6_0:1.170.0.2
	OPENBSD_6_0_BASE:1.170
	OPENBSD_5_9:1.161.0.2
	OPENBSD_5_9_BASE:1.161
	OPENBSD_5_8:1.159.0.4
	OPENBSD_5_8_BASE:1.159
	OPENBSD_5_7:1.150.0.2
	OPENBSD_5_7_BASE:1.150
	OPENBSD_5_6:1.147.0.8
	OPENBSD_5_6_BASE:1.147
	OPENBSD_5_5:1.147.0.6
	OPENBSD_5_5_BASE:1.147
	OPENBSD_5_4:1.147.0.2
	OPENBSD_5_4_BASE:1.147
	OPENBSD_5_3:1.145.0.2
	OPENBSD_5_3_BASE:1.145
	OPENBSD_5_2:1.141.0.4
	OPENBSD_5_2_BASE:1.141
	OPENBSD_5_1_BASE:1.141
	OPENBSD_5_1:1.141.0.2
	OPENBSD_5_0:1.139.0.2
	OPENBSD_5_0_BASE:1.139
	OPENBSD_4_9:1.130.0.4
	OPENBSD_4_9_BASE:1.130
	OPENBSD_4_8:1.130.0.2
	OPENBSD_4_8_BASE:1.130
	OPENBSD_4_7:1.128.0.2
	OPENBSD_4_7_BASE:1.128
	OPENBSD_4_6:1.127.0.4
	OPENBSD_4_6_BASE:1.127
	OPENBSD_4_5:1.125.0.2
	OPENBSD_4_5_BASE:1.125
	OPENBSD_4_4:1.124.0.2
	OPENBSD_4_4_BASE:1.124
	OPENBSD_4_3:1.121.0.2
	OPENBSD_4_3_BASE:1.121
	OPENBSD_4_2:1.114.0.2
	OPENBSD_4_2_BASE:1.114
	OPENBSD_4_1:1.106.0.2
	OPENBSD_4_1_BASE:1.106
	OPENBSD_4_0:1.103.0.2
	OPENBSD_4_0_BASE:1.103
	OPENBSD_3_9:1.96.0.2
	OPENBSD_3_9_BASE:1.96
	OPENBSD_3_8:1.91.0.2
	OPENBSD_3_8_BASE:1.91
	OPENBSD_3_7:1.82.0.2
	OPENBSD_3_7_BASE:1.82
	OPENBSD_3_6:1.80.0.2
	OPENBSD_3_6_BASE:1.80
	SMP_SYNC_A:1.77
	SMP_SYNC_B:1.77
	OPENBSD_3_5:1.77.0.2
	OPENBSD_3_5_BASE:1.77
	OPENBSD_3_4:1.73.0.2
	OPENBSD_3_4_BASE:1.73
	UBC_SYNC_A:1.69
	OPENBSD_3_3:1.68.0.2
	OPENBSD_3_3_BASE:1.68
	OPENBSD_3_2:1.66.0.2
	OPENBSD_3_2_BASE:1.66
	OPENBSD_3_1:1.65.0.2
	OPENBSD_3_1_BASE:1.65
	UBC_SYNC_B:1.66
	UBC:1.64.0.2
	UBC_BASE:1.64
	OPENBSD_3_0:1.58.0.2
	OPENBSD_3_0_BASE:1.58
	OPENBSD_2_9:1.54.0.2
	OPENBSD_2_9_BASE:1.54
	OPENBSD_2_8:1.52.0.2
	OPENBSD_2_8_BASE:1.52
	OPENBSD_2_7:1.50.0.2
	OPENBSD_2_7_BASE:1.50
	SMP:1.48.0.6
	SMP_BASE:1.48
	kame_19991208:1.48
	OPENBSD_2_6:1.48.0.4
	OPENBSD_2_6_BASE:1.48
	OPENBSD_2_5:1.48.0.2
	OPENBSD_2_5_BASE:1.48
	OPENBSD_2_4:1.45.0.2
	OPENBSD_2_4_BASE:1.45
	OPENBSD_2_3:1.42.0.2
	OPENBSD_2_3_BASE:1.42
	OPENBSD_2_2:1.36.0.2
	OPENBSD_2_2_BASE:1.36
	OPENBSD_2_1:1.26.0.2
	OPENBSD_2_1_BASE:1.26
	OPENBSD_2_0:1.16.0.2
	OPENBSD_2_0_BASE:1.16
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.180
date	2017.08.25.19.28.48;	author guenther;	state Exp;
branches;
next	1.179;
commitid	pIA4jy9i3oGgdop6;

1.179
date	2017.08.20.04.15.43;	author deraadt;	state Exp;
branches;
next	1.178;
commitid	NeACme4lTSsPWxuN;

1.178
date	2017.07.06.06.17.05;	author deraadt;	state Exp;
branches;
next	1.177;
commitid	8lSpPCbSabFJN412;

1.177
date	2017.06.30.06.17.47;	author mlarkin;	state Exp;
branches;
next	1.176;
commitid	5DEl2HSiHCMie99h;

1.176
date	2017.06.29.17.17.28;	author deraadt;	state Exp;
branches;
next	1.175;
commitid	W8lruZ7GPI2dyHQY;

1.175
date	2017.05.31.19.18.18;	author deraadt;	state Exp;
branches;
next	1.174;
commitid	HlDgymhwBU2bW7Tm;

1.174
date	2017.05.30.15.11.32;	author deraadt;	state Exp;
branches;
next	1.173;
commitid	KepHUzDSsoNf5ym4;

1.173
date	2017.05.12.08.46.28;	author mpi;	state Exp;
branches;
next	1.172;
commitid	PA52H6oQQYmCFJyn;

1.172
date	2017.02.06.09.13.41;	author mpi;	state Exp;
branches
	1.172.4.1;
next	1.171;
commitid	wTgEeyM3ktFNF2jh;

1.171
date	2016.10.13.09.01.04;	author mlarkin;	state Exp;
branches;
next	1.170;
commitid	659WBm0IRG82MHNg;

1.170
date	2016.07.16.06.04.29;	author mlarkin;	state Exp;
branches
	1.170.2.1;
next	1.169;
commitid	2VViksTJanHcGpAF;

1.169
date	2016.05.23.20.11.49;	author deraadt;	state Exp;
branches;
next	1.168;
commitid	0oWSDXhpPUnuLpPD;

1.168
date	2016.05.10.18.39.45;	author deraadt;	state Exp;
branches;
next	1.167;
commitid	qfOifNidEGDB2jL1;

1.167
date	2016.03.15.03.17.51;	author guenther;	state Exp;
branches;
next	1.166;
commitid	hTA8iQcFPhTNwQXL;

1.166
date	2016.03.09.13.46.14;	author mpi;	state Exp;
branches;
next	1.165;
commitid	k5dfDpN4kQrAB35k;

1.165
date	2016.03.03.12.32.23;	author mpi;	state Exp;
branches;
next	1.164;
commitid	M5r4S7Tt7Pvfl2xO;

1.164
date	2016.02.28.15.46.18;	author naddy;	state Exp;
branches;
next	1.163;
commitid	iOuZImHZRAr7Hvd6;

1.163
date	2016.02.26.02.25.09;	author mlarkin;	state Exp;
branches;
next	1.162;
commitid	2dVx35vBar1NAXha;

1.162
date	2016.02.26.02.23.07;	author mlarkin;	state Exp;
branches;
next	1.161;
commitid	e4E2zaYiFk2BixAH;

1.161
date	2015.08.25.04.57.31;	author mlarkin;	state Exp;
branches;
next	1.160;
commitid	9OQndlj4AhqxzfSp;

1.160
date	2015.08.12.06.19.25;	author mlarkin;	state Exp;
branches;
next	1.159;
commitid	laQtIfN3a82NKYjy;

1.159
date	2015.07.16.22.06.08;	author mlarkin;	state Exp;
branches;
next	1.158;
commitid	VGzGyC3YSwCK9Iuw;

1.158
date	2015.06.28.01.11.27;	author guenther;	state Exp;
branches;
next	1.157;
commitid	pmt8zLCdl4eF6ZNV;

1.157
date	2015.04.26.09.48.29;	author kettenis;	state Exp;
branches;
next	1.156;
commitid	3Uurxze029jRDQJK;

1.156
date	2015.04.25.21.31.24;	author guenther;	state Exp;
branches;
next	1.155;
commitid	Jx2fq8kp0uEBpslo;

1.155
date	2015.04.24.12.52.38;	author kettenis;	state Exp;
branches;
next	1.154;
commitid	ldM9NygmNatsq6n7;

1.154
date	2015.04.19.06.27.17;	author sf;	state Exp;
branches;
next	1.153;
commitid	4CLlh1CnkUSpsRbo;

1.153
date	2015.04.18.05.14.05;	author guenther;	state Exp;
branches;
next	1.152;
commitid	omyqf8P2CTirfWNm;

1.152
date	2015.04.12.18.37.53;	author mlarkin;	state Exp;
branches;
next	1.151;
commitid	5ST94uMTezmXYdhY;

1.151
date	2015.04.01.19.45.21;	author mlarkin;	state Exp;
branches;
next	1.150;
commitid	yA1yvBixEjnNsROq;

1.150
date	2015.02.11.00.16.07;	author miod;	state Exp;
branches;
next	1.149;
commitid	VyxunAh1HrORJ74l;

1.149
date	2015.02.07.00.26.37;	author deraadt;	state Exp;
branches;
next	1.148;
commitid	kEuv7zJ8MalymF3m;

1.148
date	2014.11.23.00.25.05;	author guenther;	state Exp;
branches;
next	1.147;
commitid	83mVtEFG1oiGteGB;

1.147
date	2013.06.13.02.26.53;	author deraadt;	state Exp;
branches;
next	1.146;

1.146
date	2013.06.09.12.42.22;	author tedu;	state Exp;
branches;
next	1.145;

1.145
date	2012.11.18.12.17.40;	author sf;	state Exp;
branches;
next	1.144;

1.144
date	2012.11.10.09.45.05;	author mglocker;	state Exp;
branches;
next	1.143;

1.143
date	2012.10.31.03.30.22;	author jsg;	state Exp;
branches;
next	1.142;

1.142
date	2012.09.25.09.58.57;	author pirofti;	state Exp;
branches;
next	1.141;

1.141
date	2011.11.02.23.53.44;	author jsg;	state Exp;
branches;
next	1.140;

1.140
date	2011.10.12.18.30.09;	author miod;	state Exp;
branches;
next	1.139;

1.139
date	2011.07.09.01.49.16;	author pirofti;	state Exp;
branches;
next	1.138;

1.138
date	2011.07.08.21.11.20;	author pirofti;	state Exp;
branches;
next	1.137;

1.137
date	2011.07.05.00.30.10;	author deraadt;	state Exp;
branches;
next	1.136;

1.136
date	2011.07.04.22.53.53;	author tedu;	state Exp;
branches;
next	1.135;

1.135
date	2011.05.10.11.11.56;	author kettenis;	state Exp;
branches;
next	1.134;

1.134
date	2011.04.27.11.30.53;	author bluhm;	state Exp;
branches;
next	1.133;

1.133
date	2011.04.23.22.16.13;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2011.04.05.12.50.15;	author guenther;	state Exp;
branches;
next	1.131;

1.131
date	2011.03.12.03.52.26;	author guenther;	state Exp;
branches;
next	1.130;

1.130
date	2010.07.03.04.54.32;	author kettenis;	state Exp;
branches;
next	1.129;

1.129
date	2010.05.09.12.03.16;	author kettenis;	state Exp;
branches;
next	1.128;

1.128
date	2009.07.10.13.51.47;	author jsg;	state Exp;
branches;
next	1.127;

1.127
date	2009.06.03.00.49.12;	author art;	state Exp;
branches;
next	1.126;

1.126
date	2009.06.03.00.41.48;	author weingart;	state Exp;
branches;
next	1.125;

1.125
date	2009.01.17.23.44.46;	author guenther;	state Exp;
branches;
next	1.124;

1.124
date	2008.07.28.19.08.46;	author miod;	state Exp;
branches;
next	1.123;

1.123
date	2008.06.09.20.43.43;	author miod;	state Exp;
branches;
next	1.122;

1.122
date	2008.03.22.16.25.08;	author weingart;	state Exp;
branches;
next	1.121;

1.121
date	2007.11.28.17.05.09;	author tedu;	state Exp;
branches;
next	1.120;

1.120
date	2007.11.05.21.46.13;	author weingart;	state Exp;
branches;
next	1.119;

1.119
date	2007.11.03.03.37.08;	author weingart;	state Exp;
branches;
next	1.118;

1.118
date	2007.11.03.03.06.21;	author weingart;	state Exp;
branches;
next	1.117;

1.117
date	2007.10.24.17.56.58;	author mikeb;	state Exp;
branches;
next	1.116;

1.116
date	2007.10.10.15.53.51;	author art;	state Exp;
branches;
next	1.115;

1.115
date	2007.10.03.07.51.26;	author kettenis;	state Exp;
branches;
next	1.114;

1.114
date	2007.05.29.23.02.02;	author tom;	state Exp;
branches;
next	1.113;

1.113
date	2007.05.29.18.18.20;	author tom;	state Exp;
branches;
next	1.112;

1.112
date	2007.05.27.21.35.36;	author tom;	state Exp;
branches;
next	1.111;

1.111
date	2007.05.27.18.34.01;	author art;	state Exp;
branches;
next	1.110;

1.110
date	2007.05.26.22.09.17;	author weingart;	state Exp;
branches;
next	1.109;

1.109
date	2007.05.25.20.32.29;	author krw;	state Exp;
branches;
next	1.108;

1.108
date	2007.04.13.11.16.08;	author art;	state Exp;
branches;
next	1.107;

1.107
date	2007.04.03.10.14.47;	author art;	state Exp;
branches;
next	1.106;

1.106
date	2007.02.20.21.15.01;	author tom;	state Exp;
branches;
next	1.105;

1.105
date	2006.12.08.21.35.05;	author dim;	state Exp;
branches;
next	1.104;

1.104
date	2006.11.26.15.13.21;	author dim;	state Exp;
branches;
next	1.103;

1.103
date	2006.05.11.13.21.11;	author mickey;	state Exp;
branches;
next	1.102;

1.102
date	2006.05.07.11.30.51;	author kettenis;	state Exp;
branches;
next	1.101;

1.101
date	2006.05.06.14.42.32;	author mickey;	state Exp;
branches;
next	1.100;

1.100
date	2006.04.27.15.37.51;	author mickey;	state Exp;
branches;
next	1.99;

1.99
date	2006.04.19.14.19.30;	author mickey;	state Exp;
branches;
next	1.98;

1.98
date	2006.04.14.21.52.47;	author weingart;	state Exp;
branches;
next	1.97;

1.97
date	2006.03.14.12.25.20;	author mickey;	state Exp;
branches;
next	1.96;

1.96
date	2006.01.12.15.59.03;	author mickey;	state Exp;
branches;
next	1.95;

1.95
date	2005.11.25.07.07.49;	author tom;	state Exp;
branches;
next	1.94;

1.94
date	2005.11.23.16.51.28;	author mickey;	state Exp;
branches;
next	1.93;

1.93
date	2005.10.26.20.32.59;	author marco;	state Exp;
branches;
next	1.92;

1.92
date	2005.09.14.05.38.48;	author marco;	state Exp;
branches;
next	1.91;

1.91
date	2005.07.18.14.55.49;	author mickey;	state Exp;
branches;
next	1.90;

1.90
date	2005.05.29.03.20.38;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2005.05.26.04.29.06;	author mickey;	state Exp;
branches;
next	1.88;

1.88
date	2005.05.25.23.17.47;	author niklas;	state Exp;
branches;
next	1.87;

1.87
date	2005.05.25.22.50.25;	author beck;	state Exp;
branches;
next	1.86;

1.86
date	2005.05.25.19.07.13;	author mickey;	state Exp;
branches;
next	1.85;

1.85
date	2005.05.24.19.37.08;	author niklas;	state Exp;
branches;
next	1.84;

1.84
date	2005.05.24.08.54.14;	author marco;	state Exp;
branches;
next	1.83;

1.83
date	2005.04.17.07.33.13;	author tedu;	state Exp;
branches;
next	1.82;

1.82
date	2005.02.10.04.06.01;	author weingart;	state Exp;
branches
	1.82.2.1;
next	1.81;

1.81
date	2005.01.01.02.57.36;	author millert;	state Exp;
branches;
next	1.80;

1.80
date	2004.07.20.20.16.44;	author art;	state Exp;
branches
	1.80.2.1;
next	1.79;

1.79
date	2004.07.02.16.29.55;	author niklas;	state Exp;
branches;
next	1.78;

1.78
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.77;

1.77
date	2004.02.01.19.05.23;	author deraadt;	state Exp;
branches
	1.77.2.1;
next	1.76;

1.76
date	2004.01.29.19.01.53;	author tedu;	state Exp;
branches;
next	1.75;

1.75
date	2003.11.17.14.55.58;	author miod;	state Exp;
branches;
next	1.74;

1.74
date	2003.11.15.19.27.50;	author henning;	state Exp;
branches;
next	1.73;

1.73
date	2003.07.29.18.24.36;	author mickey;	state Exp;
branches;
next	1.72;

1.72
date	2003.07.11.20.45.18;	author art;	state Exp;
branches;
next	1.71;

1.71
date	2003.06.06.11.11.53;	author andreas;	state Exp;
branches;
next	1.70;

1.70
date	2003.06.02.23.27.47;	author millert;	state Exp;
branches;
next	1.69;

1.69
date	2003.04.17.03.42.14;	author drahn;	state Exp;
branches;
next	1.68;

1.68
date	2003.01.09.22.27.09;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2002.10.29.01.52.46;	author art;	state Exp;
branches;
next	1.66;

1.66
date	2002.07.24.23.20.11;	author mickey;	state Exp;
branches;
next	1.65;

1.65
date	2002.02.18.23.09.53;	author mickey;	state Exp;
branches;
next	1.64;

1.64
date	2001.12.04.20.54.11;	author niklas;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2001.12.04.01.20.27;	author marc;	state Exp;
branches;
next	1.62;

1.62
date	2001.12.01.07.51.32;	author niklas;	state Exp;
branches;
next	1.61;

1.61
date	2001.11.18.20.46.49;	author aaron;	state Exp;
branches;
next	1.60;

1.60
date	2001.11.12.20.28.20;	author niklas;	state Exp;
branches;
next	1.59;

1.59
date	2001.10.24.04.04.30;	author mickey;	state Exp;
branches;
next	1.58;

1.58
date	2001.09.20.11.57.18;	author art;	state Exp;
branches;
next	1.57;

1.57
date	2001.08.26.17.45.00;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2001.05.17.00.18.19;	author fgsch;	state Exp;
branches;
next	1.55;

1.55
date	2001.05.05.23.25.37;	author art;	state Exp;
branches;
next	1.54;

1.54
date	2001.03.22.23.36.51;	author niklas;	state Exp;
branches;
next	1.53;

1.53
date	2001.01.24.09.37.58;	author hugh;	state Exp;
branches;
next	1.52;

1.52
date	2000.06.16.19.11.25;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2000.06.05.11.02.54;	author art;	state Exp;
branches;
next	1.50;

1.50
date	2000.05.01.00.43.41;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2000.04.30.18.48.58;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	99.03.08.23.47.26;	author downsj;	state Exp;
branches
	1.48.6.1;
next	1.47;

1.47
date	99.02.26.04.34.31;	author art;	state Exp;
branches;
next	1.46;

1.46
date	99.02.12.19.40.12;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	98.09.06.20.09.58;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	98.08.18.22.29.10;	author marc;	state Exp;
branches;
next	1.43;

1.43
date	98.05.10.18.29.49;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	98.02.26.20.53.23;	author weingart;	state Exp;
branches;
next	1.41;

1.41
date	98.02.22.00.34.52;	author niklas;	state Exp;
branches;
next	1.40;

1.40
date	98.02.17.12.07.21;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	98.01.29.11.30.27;	author niklas;	state Exp;
branches;
next	1.38;

1.38
date	97.12.17.08.54.47;	author downsj;	state Exp;
branches;
next	1.37;

1.37
date	97.12.09.03.36.39;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	97.10.22.23.37.12;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	97.10.19.06.34.22;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	97.10.18.00.33.13;	author weingart;	state Exp;
branches;
next	1.33;

1.33
date	97.09.29.03.42.26;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	97.09.25.00.13.54;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	97.09.21.04.27.55;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	97.09.11.10.45.43;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	97.07.25.17.15.22;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	97.07.18.06.49.26;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	97.07.18.05.32.27;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	97.04.16.19.59.21;	author flipk;	state Exp;
branches;
next	1.25;

1.25
date	97.02.07.08.32.18;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	97.02.07.08.05.01;	author tholo;	state Exp;
branches;
next	1.23;

1.23
date	97.02.05.04.12.44;	author tholo;	state Exp;
branches;
next	1.22;

1.22
date	97.02.03.15.04.52;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	96.12.05.18.08.05;	author dm;	state Exp;
branches;
next	1.20;

1.20
date	96.11.23.23.19.36;	author kstailey;	state Exp;
branches;
next	1.19;

1.19
date	96.10.23.15.23.33;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	96.10.23.05.23.37;	author etheisen;	state Exp;
branches;
next	1.17;

1.17
date	96.10.16.12.28.22;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.08.23.19.40.46;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	96.08.16.02.54.01;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.08.16.02.51.29;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.08.08.18.47.08;	author dm;	state Exp;
branches;
next	1.12;

1.12
date	96.08.08.03.31.21;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	96.05.07.07.21.44;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.05.06.22.11.59;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	96.05.06.20.29.38;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	96.05.04.16.38.07;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.04.29.14.13.04;	author hvozda;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.16.29;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.03.19.21.09.18;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.01.12.16.45.10;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.08.09.33.31;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.26.01.00.45;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.33;	author deraadt;	state Exp;
branches;
next	;

1.48.6.1
date	2001.04.18.16.07.19;	author niklas;	state Exp;
branches;
next	1.48.6.2;

1.48.6.2
date	2001.07.04.10.16.36;	author niklas;	state Exp;
branches;
next	1.48.6.3;

1.48.6.3
date	2001.07.14.10.02.27;	author ho;	state Exp;
branches;
next	1.48.6.4;

1.48.6.4
date	2001.10.27.09.47.29;	author niklas;	state Exp;
branches;
next	1.48.6.5;

1.48.6.5
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.48.6.6;

1.48.6.6
date	2001.10.31.12.00.43;	author ho;	state Exp;
branches;
next	1.48.6.7;

1.48.6.7
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.48.6.8;

1.48.6.8
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.48.6.9;

1.48.6.9
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.48.6.10;

1.48.6.10
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.48.6.11;

1.48.6.11
date	2003.04.06.09.43.12;	author niklas;	state Exp;
branches;
next	1.48.6.12;

1.48.6.12
date	2003.04.11.16.12.56;	author niklas;	state Exp;
branches;
next	1.48.6.13;

1.48.6.13
date	2003.04.15.03.55.50;	author niklas;	state Exp;
branches;
next	1.48.6.14;

1.48.6.14
date	2003.05.13.19.42.07;	author ho;	state Exp;
branches;
next	1.48.6.15;

1.48.6.15
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.48.6.16;

1.48.6.16
date	2003.05.15.17.47.15;	author niklas;	state Exp;
branches;
next	1.48.6.17;

1.48.6.17
date	2003.05.15.18.48.58;	author niklas;	state Exp;
branches;
next	1.48.6.18;

1.48.6.18
date	2003.05.18.17.16.42;	author niklas;	state Exp;
branches;
next	1.48.6.19;

1.48.6.19
date	2003.05.25.17.32.07;	author ho;	state Exp;
branches;
next	1.48.6.20;

1.48.6.20
date	2003.06.07.11.11.37;	author ho;	state Exp;
branches;
next	1.48.6.21;

1.48.6.21
date	2004.02.19.10.48.41;	author niklas;	state Exp;
branches;
next	1.48.6.22;

1.48.6.22
date	2004.02.20.22.21.05;	author niklas;	state Exp;
branches;
next	1.48.6.23;

1.48.6.23
date	2004.03.14.17.47.43;	author niklas;	state Exp;
branches;
next	1.48.6.24;

1.48.6.24
date	2004.03.16.18.29.34;	author niklas;	state Exp;
branches;
next	1.48.6.25;

1.48.6.25
date	2004.04.06.13.31.05;	author niklas;	state Exp;
branches;
next	1.48.6.26;

1.48.6.26
date	2004.04.15.15.44.56;	author niklas;	state Exp;
branches;
next	1.48.6.27;

1.48.6.27
date	2004.06.06.18.20.27;	author grange;	state Exp;
branches;
next	1.48.6.28;

1.48.6.28
date	2004.06.08.07.33.12;	author niklas;	state Exp;
branches;
next	1.48.6.29;

1.48.6.29
date	2004.06.09.18.59.29;	author art;	state Exp;
branches;
next	1.48.6.30;

1.48.6.30
date	2004.06.10.11.40.24;	author niklas;	state Exp;
branches;
next	;

1.64.2.1
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	1.64.2.2;

1.64.2.2
date	2002.10.29.00.28.03;	author art;	state Exp;
branches;
next	1.64.2.3;

1.64.2.3
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;

1.77.2.1
date	2005.02.27.00.39.58;	author brad;	state Exp;
branches;
next	;

1.80.2.1
date	2005.02.27.00.57.02;	author brad;	state Exp;
branches;
next	1.80.2.2;

1.80.2.2
date	2005.06.11.02.58.49;	author brad;	state Exp;
branches;
next	;

1.82.2.1
date	2005.06.12.16.07.34;	author brad;	state Exp;
branches;
next	;

1.170.2.1
date	2017.08.26.00.15.05;	author bluhm;	state Exp;
branches;
next	;
commitid	EJSKXWVfg55NrgI5;

1.172.4.1
date	2017.08.26.00.14.20;	author bluhm;	state Exp;
branches;
next	;
commitid	ubjDaswy90l5VD3W;


desc
@@


1.180
log
@If SMAP is present, clear PSL_AC on kernel entry and interrupt so that
only the code in copy{in,out}* that need it run with it set.  Panic if
it's set on entry to trap() or syscall().  Prompted by Maxime Villard's
NetBSD work.

ok kettenis@@ mlarkin@@ deraadt@@
@
text
@/*	$OpenBSD: locore.s,v 1.179 2017/08/20 04:15:43 deraadt Exp $	*/
/*	$NetBSD: locore.s,v 1.145 1996/05/03 19:41:19 christos Exp $	*/

/*-
 * Copyright (c) 1993, 1994, 1995 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)locore.s	7.3 (Berkeley) 5/13/91
 */

#include "npx.h"
#include "assym.h"
#include "apm.h"
#include "lapic.h"
#include "ksyms.h"

#include <sys/errno.h>
#include <sys/syscall.h>

#include <machine/codepatch.h>
#include <machine/cputypes.h>
#include <machine/param.h>
#include <machine/pte.h>
#include <machine/segments.h>
#include <machine/specialreg.h>
#include <machine/trap.h>

#include <dev/isa/isareg.h>

#if NLAPIC > 0
#include <machine/i82489reg.h>
#endif

/*
 * As stac/clac SMAP instructions are 3 bytes, we want the fastest
 * 3 byte nop sequence possible here.  This will be replaced by
 * stac/clac instructions if SMAP is detected after booting.
 *
 * Intel documents multi-byte NOP sequences as being available
 * on all family 0x6 and 0xf processors (ie 686+)
 * So use 3 of the single byte nops for compatibility
 */
#define SMAP_NOP	.byte 0x90, 0x90, 0x90
#define SMAP_STAC	CODEPATCH_START			;\
			SMAP_NOP			;\
			CODEPATCH_END(CPTAG_STAC)
#define SMAP_CLAC	CODEPATCH_START			;\
			SMAP_NOP			;\
			CODEPATCH_END(CPTAG_CLAC)

/*
 * override user-land alignment before including asm.h
 */

#define	ALIGN_DATA	.align  4,0xcc
#define	ALIGN_TEXT	.align  4,0x90	/* 4-byte boundaries, NOP-filled */
#define _ALIGN_TEXT	ALIGN_TEXT
#include <machine/asm.h>

#define CPL _C_LABEL(lapic_tpr)

#define	GET_CURPCB(reg)					\
	movl	CPUVAR(CURPCB), reg

#define	CHECK_ASTPENDING(treg)				\
	movl 	CPUVAR(CURPROC),treg		;	\
	cmpl	$0, treg			;	\
	je	1f				;	\
	cmpl	$0,P_MD_ASTPENDING(treg)	;	\
	1:

#define	CLEAR_ASTPENDING(cpreg)				\
	movl	$0,P_MD_ASTPENDING(cpreg)

/*
 * These are used on interrupt or trap entry or exit.
 */
#define	INTRENTRY \
	cld			; \
	SMAP_CLAC		; \
	pushl	%eax		; \
	pushl	%ecx		; \
	pushl	%edx		; \
	pushl	%ebx		; \
	pushl	%ebp		; \
	pushl	%esi		; \
	pushl	%edi		; \
	pushl	%ds		; \
	pushl	%es		; \
	pushl	%gs		; \
	movl	$GSEL(GDATA_SEL, SEL_KPL),%eax	; \
	movw	%ax,%ds		; \
	movw	%ax,%es		; \
	xorl	%eax,%eax	; /* $GSEL(GNULL_SEL, SEL_KPL) == 0 */ \
	movw	%ax,%gs		; \
	pushl	%fs		; \
	movl	$GSEL(GCPU_SEL, SEL_KPL),%eax	; \
	movw	%ax,%fs

#define	INTR_RESTORE_ALL \
	popl	%fs		; \
	popl	%gs		; \
	popl	%es		; \
	popl	%ds		; \
	popl	%edi		; \
	popl	%esi		; \
	popl	%ebp		; \
	popl	%ebx		; \
	popl	%edx		; \
	popl	%ecx		; \
	popl	%eax

#define	INTRFASTEXIT \
	INTR_RESTORE_ALL	;\
	addl	$8,%esp		; \
	iret

#define	INTR_FAKE_TRAP	0xbadabada

/*
 * PTmap is recursive pagemap at top of virtual address space.
 * Within PTmap, the page directory can be found (third indirection).
 */
	.globl	_C_LABEL(PTmap), _C_LABEL(PTD)
	.set	_C_LABEL(PTmap), (PDSLOT_PTE << PDSHIFT)
	.set	_C_LABEL(PTD), (_C_LABEL(PTmap) + PDSLOT_PTE * NBPG)

/*
 * Initialization
 */
	.data

	.globl	_C_LABEL(cpu), _C_LABEL(cpu_id), _C_LABEL(cpu_vendor)
	.globl	_C_LABEL(cpu_brandstr)
	.globl	_C_LABEL(cpuid_level)
	.globl	_C_LABEL(cpu_miscinfo)
	.globl	_C_LABEL(cpu_feature), _C_LABEL(cpu_ecxfeature)
	.globl	_C_LABEL(ecpu_feature), _C_LABEL(ecpu_eaxfeature)
	.globl	_C_LABEL(ecpu_ecxfeature)
	.globl	_C_LABEL(cpu_cache_eax), _C_LABEL(cpu_cache_ebx)
	.globl	_C_LABEL(cpu_cache_ecx), _C_LABEL(cpu_cache_edx)
	.globl	_C_LABEL(cpu_perf_eax)
	.globl	_C_LABEL(cpu_perf_ebx)
	.globl	_C_LABEL(cpu_perf_edx)
	.globl	_C_LABEL(cpu_apmi_edx)
	.globl	_C_LABEL(cold), _C_LABEL(cnvmem), _C_LABEL(extmem)
	.globl	_C_LABEL(cpu_pae)
	.globl	_C_LABEL(esym)
	.globl	_C_LABEL(ssym)
	.globl	_C_LABEL(nkptp_max)
	.globl	_C_LABEL(boothowto), _C_LABEL(bootdev), _C_LABEL(atdevbase)
	.globl	_C_LABEL(proc0paddr), _C_LABEL(PTDpaddr), _C_LABEL(PTDsize)
	.globl	_C_LABEL(gdt)
	.globl	_C_LABEL(bootapiver), _C_LABEL(bootargc), _C_LABEL(bootargv)
	.globl	_C_LABEL(lapic_tpr)

#if NLAPIC > 0
	.align NBPG
	.globl _C_LABEL(local_apic), _C_LABEL(lapic_id)
_C_LABEL(local_apic):
	.space	LAPIC_ID
_C_LABEL(lapic_id):
	.long	0x00000000
	.space	LAPIC_TPRI-(LAPIC_ID+4)
_C_LABEL(lapic_tpr):
	.space	LAPIC_PPRI-LAPIC_TPRI
_C_LABEL(lapic_ppr):
	.space	LAPIC_ISR-LAPIC_PPRI
_C_LABEL(lapic_isr):
	.space	NBPG-LAPIC_ISR
#else
_C_LABEL(lapic_tpr):
	.long	0
#endif

_C_LABEL(cpu):		.long	0	# are we 386, 386sx, 486, 586 or 686
_C_LABEL(cpu_id):	.long	0	# saved from 'cpuid' instruction
_C_LABEL(cpu_pae):	.long	0	# are we using PAE paging mode?
_C_LABEL(cpu_miscinfo):	.long	0	# misc info (apic/brand id) from 'cpuid'
_C_LABEL(cpu_feature):	.long	0	# feature flags from 'cpuid' instruction
_C_LABEL(ecpu_feature): .long	0	# extended feature flags from 'cpuid'
_C_LABEL(cpu_ecxfeature):.long	0	# ecx feature flags from 'cpuid'
_C_LABEL(ecpu_eaxfeature): .long 0	# extended eax feature flags
_C_LABEL(ecpu_ecxfeature): .long 0	# extended ecx feature flags
_C_LABEL(cpuid_level):	.long	-1	# max. lvl accepted by 'cpuid' insn
_C_LABEL(cpu_cache_eax):.long	0
_C_LABEL(cpu_cache_ebx):.long	0
_C_LABEL(cpu_cache_ecx):.long	0
_C_LABEL(cpu_cache_edx):.long	0
_C_LABEL(cpu_perf_eax):	.long	0	# arch. perf. mon. flags from 'cpuid'
_C_LABEL(cpu_perf_ebx):	.long	0	# arch. perf. mon. flags from 'cpuid'
_C_LABEL(cpu_perf_edx):	.long	0	# arch. perf. mon. flags from 'cpuid'
_C_LABEL(cpu_apmi_edx):	.long	0	# adv. power management info. 'cpuid'
_C_LABEL(cpu_vendor): .space 16	# vendor string returned by 'cpuid' instruction
_C_LABEL(cpu_brandstr):	.space 48 # brand string returned by 'cpuid'
_C_LABEL(cold):		.long	1	# cold till we are not
_C_LABEL(ssym):		.long	0	# ptr to start of syms
_C_LABEL(esym):		.long	0	# ptr to end of syms
_C_LABEL(cnvmem):	.long	0	# conventional memory size
_C_LABEL(extmem):	.long	0	# extended memory size
_C_LABEL(atdevbase):	.long	0	# location of start of iomem in virtual
_C_LABEL(bootapiver):	.long	0	# /boot API version
_C_LABEL(bootargc):	.long	0	# /boot argc
_C_LABEL(bootargv):	.long	0	# /boot argv
_C_LABEL(bootdev):	.long	0	# device we booted from
_C_LABEL(proc0paddr):	.long	0
_C_LABEL(PTDpaddr):	.long	0	# paddr of PTD, for libkvm
_C_LABEL(PTDsize):	.long	NBPG	# size of PTD, for libkvm

	.text

NENTRY(proc_trampoline)
#ifdef MULTIPROCESSOR
	call	_C_LABEL(proc_trampoline_mp)
#endif
	movl	$IPL_NONE,CPL
	pushl	%ebx
	call	*%esi
	addl	$4,%esp
	INTRFASTEXIT
	/* NOTREACHED */

	/* This must come before any use of the CODEPATCH macros */
       .section .codepatch,"a"
       .align  8
       .globl _C_LABEL(codepatch_begin)
_C_LABEL(codepatch_begin):
       .previous

       .section .codepatchend,"a"
       .globl _C_LABEL(codepatch_end)
_C_LABEL(codepatch_end):
       .previous

/*****************************************************************************/

/*
 * Signal trampoline; copied to top of user stack.
 */
	.section .rodata
	.globl	_C_LABEL(sigcode)
_C_LABEL(sigcode):
	call	*SIGF_HANDLER(%esp)
	leal	SIGF_SC(%esp),%eax	# scp (the call may have clobbered the
					# copy at SIGF_SCP(%esp))
	pushl	%eax
	pushl	%eax			# junk to fake return address
	movl	$SYS_sigreturn,%eax
	int	$0x80			# enter kernel with args on stack
	.globl	_C_LABEL(sigcoderet)
_C_LABEL(sigcoderet):
	movl	$SYS_exit,%eax
	int	$0x80			# exit if sigreturn fails
	.globl	_C_LABEL(esigcode)
_C_LABEL(esigcode):

	.globl	_C_LABEL(sigfill)
_C_LABEL(sigfill):
	int3
_C_LABEL(esigfill):

	.data
	.globl	_C_LABEL(sigfillsiz)
_C_LABEL(sigfillsiz):
	.long	_C_LABEL(esigfill) - _C_LABEL(sigfill)

	.text

/*****************************************************************************/

/*
 * The following primitives are used to fill and copy regions of memory.
 */

/* Frame pointer reserve on stack. */
#ifdef DDB
#define FPADD 4
#else
#define FPADD 0
#endif

/*
 * kcopy(caddr_t from, caddr_t to, size_t len);
 * Copy len bytes, abort on fault.
 */
ENTRY(kcopy)
#ifdef DDB
	pushl	%ebp
	movl	%esp,%ebp
#endif
	pushl	%esi
	pushl	%edi
	GET_CURPCB(%eax)		# load curpcb into eax and set on-fault
	pushl	PCB_ONFAULT(%eax)
	movl	$_C_LABEL(copy_fault), PCB_ONFAULT(%eax)

	movl	16+FPADD(%esp),%esi
	movl	20+FPADD(%esp),%edi
	movl	24+FPADD(%esp),%ecx
	movl	%edi,%eax
	subl	%esi,%eax
	cmpl	%ecx,%eax		# overlapping?
	jb	1f
	shrl	$2,%ecx			# nope, copy forward by 32-bit words
	rep
	movsl
	movl	24+FPADD(%esp),%ecx
	andl	$3,%ecx			# any bytes left?
	rep
	movsb

	GET_CURPCB(%edx)		# XXX save curpcb?
	popl	PCB_ONFAULT(%edx)
	popl	%edi
	popl	%esi
	xorl	%eax,%eax
#ifdef DDB
	leave
#endif
	ret

	.align  4,0xcc
1:	addl	%ecx,%edi		# copy backward
	addl	%ecx,%esi
	std
	andl	$3,%ecx			# any fractional bytes?
	decl	%edi
	decl	%esi
	rep
	movsb
	movl	24+FPADD(%esp),%ecx	# copy remainder by 32-bit words
	shrl	$2,%ecx
	subl	$3,%esi
	subl	$3,%edi
	rep
	movsl
	cld

	GET_CURPCB(%edx)
	popl	PCB_ONFAULT(%edx)
	popl	%edi
	popl	%esi
	xorl	%eax,%eax
#ifdef DDB
	leave
#endif
	ret
	
/*****************************************************************************/

/*
 * The following primitives are used to copy data in and out of the user's
 * address space.
 */

/*
 * copyout(caddr_t from, caddr_t to, size_t len);
 * Copy len bytes into the user's address space.
 */
ENTRY(copyout)
#ifdef DDB
	pushl	%ebp
	movl	%esp,%ebp
#endif
	pushl	%esi
	pushl	%edi
	pushl	$0	
	
	movl	16+FPADD(%esp),%esi
	movl	20+FPADD(%esp),%edi
	movl	24+FPADD(%esp),%eax

	/*
	 * We check that the end of the destination buffer is not past the end
	 * of the user's address space.  If it's not, then we only need to
	 * check that each page is writable.  The 486 will do this for us; the
	 * 386 will not.  (We assume that pages in user space that are not
	 * writable by the user are not writable by the kernel either.)
	 */
	movl	%edi,%edx
	addl	%eax,%edx
	jc	_C_LABEL(copy_fault)
	cmpl	$VM_MAXUSER_ADDRESS,%edx
	ja	_C_LABEL(copy_fault)

	GET_CURPCB(%edx)
	movl	$_C_LABEL(copy_fault),PCB_ONFAULT(%edx)
	SMAP_STAC

	/* bcopy(%esi, %edi, %eax); */
	movl	%eax,%ecx
	shrl	$2,%ecx
	rep
	movsl
	movl	%eax,%ecx
	andl	$3,%ecx
	rep
	movsb

	SMAP_CLAC
	popl	PCB_ONFAULT(%edx)
	popl	%edi
	popl	%esi
	xorl	%eax,%eax
#ifdef DDB
	leave
#endif
	ret

/*
 * copyin(caddr_t from, caddr_t to, size_t len);
 * Copy len bytes from the user's address space.
 */
ENTRY(copyin)
#ifdef DDB
	pushl	%ebp
	movl	%esp,%ebp
#endif
	pushl	%esi
	pushl	%edi
	GET_CURPCB(%eax)
	pushl	$0
	movl	$_C_LABEL(copy_fault),PCB_ONFAULT(%eax)
	SMAP_STAC
	
	movl	16+FPADD(%esp),%esi
	movl	20+FPADD(%esp),%edi
	movl	24+FPADD(%esp),%eax

	/*
	 * We check that the end of the destination buffer is not past the end
	 * of the user's address space.  If it's not, then we only need to
	 * check that each page is readable, and the CPU will do that for us.
	 */
	movl	%esi,%edx
	addl	%eax,%edx
	jc	_C_LABEL(copy_fault)
	cmpl	$VM_MAXUSER_ADDRESS,%edx
	ja	_C_LABEL(copy_fault)

	/* bcopy(%esi, %edi, %eax); */
	movl	%eax,%ecx
	shrl	$2,%ecx
	rep
	movsl
	movb	%al,%cl
	andb	$3,%cl
	rep
	movsb

	SMAP_CLAC
	GET_CURPCB(%edx)
	popl	PCB_ONFAULT(%edx)
	popl	%edi
	popl	%esi
	xorl	%eax,%eax
#ifdef DDB
	leave
#endif
	ret

ENTRY(copy_fault)
	SMAP_CLAC
	GET_CURPCB(%edx)
	popl	PCB_ONFAULT(%edx)
	popl	%edi
	popl	%esi
	movl	$EFAULT,%eax
#ifdef DDB
	leave
#endif
	ret

/*
 * copyoutstr(caddr_t from, caddr_t to, size_t maxlen, size_t *lencopied);
 * Copy a NUL-terminated string, at most maxlen characters long, into the
 * user's address space.  Return the number of characters copied (including the
 * NUL) in *lencopied.  If the string is too long, return ENAMETOOLONG; else
 * return 0 or EFAULT.
 */
ENTRY(copyoutstr)
#ifdef DDB
	pushl	%ebp
	movl	%esp,%ebp
#endif
	pushl	%esi
	pushl	%edi

	movl	12+FPADD(%esp),%esi		# esi = from
	movl	16+FPADD(%esp),%edi		# edi = to
	movl	20+FPADD(%esp),%edx		# edx = maxlen

5:	GET_CURPCB(%eax)
	movl	$_C_LABEL(copystr_fault),PCB_ONFAULT(%eax)
	SMAP_STAC
	/*
	 * Get min(%edx, VM_MAXUSER_ADDRESS-%edi).
	 */
	movl	$VM_MAXUSER_ADDRESS,%eax
	subl	%edi,%eax
	jbe	_C_LABEL(copystr_fault)		# die if CF == 1 || ZF == 1
						# i.e. make sure that %edi
						# is below VM_MAXUSER_ADDRESS

	cmpl	%edx,%eax
	jae	1f
	movl	%eax,%edx
	movl	%eax,20+FPADD(%esp)

1:	incl	%edx

1:	decl	%edx
	jz	2f
	lodsb
	stosb
	testb	%al,%al
	jnz	1b

	/* Success -- 0 byte reached. */
	decl	%edx
	xorl	%eax,%eax
	jmp	copystr_return

2:	/* edx is zero -- return EFAULT or ENAMETOOLONG. */
	cmpl	$VM_MAXUSER_ADDRESS,%edi
	jae	_C_LABEL(copystr_fault)
	movl	$ENAMETOOLONG,%eax
	jmp	copystr_return

/*
 * copyinstr(caddr_t from, caddr_t to, size_t maxlen, size_t *lencopied);
 * Copy a NUL-terminated string, at most maxlen characters long, from the
 * user's address space.  Return the number of characters copied (including the
 * NUL) in *lencopied.  If the string is too long, return ENAMETOOLONG; else
 * return 0 or EFAULT.
 */
ENTRY(copyinstr)
#ifdef DDB
	pushl	%ebp
	movl	%esp,%ebp
#endif
	pushl	%esi
	pushl	%edi
	GET_CURPCB(%ecx)
	movl	$_C_LABEL(copystr_fault),PCB_ONFAULT(%ecx)
	SMAP_STAC

	movl	12+FPADD(%esp),%esi		# %esi = from
	movl	16+FPADD(%esp),%edi		# %edi = to
	movl	20+FPADD(%esp),%edx		# %edx = maxlen

	/*
	 * Get min(%edx, VM_MAXUSER_ADDRESS-%esi).
	 */
	movl	$VM_MAXUSER_ADDRESS,%eax
	subl	%esi,%eax
	jbe	_C_LABEL(copystr_fault)		# Error if CF == 1 || ZF == 1
						# i.e. make sure that %esi
						# is below VM_MAXUSER_ADDRESS
	cmpl	%edx,%eax
	jae	1f
	movl	%eax,%edx
	movl	%eax,20+FPADD(%esp)

1:	incl	%edx

1:	decl	%edx
	jz	2f
	lodsb
	stosb
	testb	%al,%al
	jnz	1b

	/* Success -- 0 byte reached. */
	decl	%edx
	xorl	%eax,%eax
	jmp	copystr_return

2:	/* edx is zero -- return EFAULT or ENAMETOOLONG. */
	cmpl	$VM_MAXUSER_ADDRESS,%esi
	jae	_C_LABEL(copystr_fault)
	movl	$ENAMETOOLONG,%eax
	jmp	copystr_return

ENTRY(copystr_fault)
	movl	$EFAULT,%eax

copystr_return:
	SMAP_CLAC
	/* Set *lencopied and return %eax. */
	GET_CURPCB(%ecx)
	movl	$0,PCB_ONFAULT(%ecx)
	movl	20+FPADD(%esp),%ecx
	subl	%edx,%ecx
	movl	24+FPADD(%esp),%edx
	testl	%edx,%edx
	jz	8f
	movl	%ecx,(%edx)

8:	popl	%edi
	popl	%esi
#ifdef DDB
	leave
#endif
	ret

/*
 * copystr(caddr_t from, caddr_t to, size_t maxlen, size_t *lencopied);
 * Copy a NUL-terminated string, at most maxlen characters long.  Return the
 * number of characters copied (including the NUL) in *lencopied.  If the
 * string is too long, return ENAMETOOLONG; else return 0.
 */
ENTRY(copystr)
#ifdef DDB
	pushl	%ebp
	movl	%esp,%ebp
#endif
	pushl	%esi
	pushl	%edi

	movl	12+FPADD(%esp),%esi		# esi = from
	movl	16+FPADD(%esp),%edi		# edi = to
	movl	20+FPADD(%esp),%edx		# edx = maxlen
	incl	%edx

1:	decl	%edx
	jz	4f
	lodsb
	stosb
	testb	%al,%al
	jnz	1b

	/* Success -- 0 byte reached. */
	decl	%edx
	xorl	%eax,%eax
	jmp	6f

4:	/* edx is zero -- return ENAMETOOLONG. */
	movl	$ENAMETOOLONG,%eax

6:	/* Set *lencopied and return %eax. */
	movl	20+FPADD(%esp),%ecx
	subl	%edx,%ecx
	movl	24+FPADD(%esp),%edx
	testl	%edx,%edx
	jz	7f
	movl	%ecx,(%edx)

7:	popl	%edi
	popl	%esi
#ifdef DDB
	leave
#endif
	ret

/*****************************************************************************/

/*
 * The following is i386-specific nonsense.
 */

/*
 * void lgdt(struct region_descriptor *rdp);
 * Change the global descriptor table.
 */
NENTRY(lgdt)
	/* Reload the descriptor table. */
	movl	4(%esp),%eax
	lgdt	(%eax)
	/* Flush the prefetch q. */
	jmp	1f
	nop
1:	/* Reload "stale" selectors. */
	movl	$GSEL(GDATA_SEL, SEL_KPL),%eax
	movw	%ax,%ds
	movw	%ax,%es
	movw	%ax,%ss
	movl	$GSEL(GCPU_SEL, SEL_KPL),%eax
	movw	%ax,%fs
	/* Reload code selector by doing intersegment return. */
	popl	%eax
	pushl	$GSEL(GCODE_SEL, SEL_KPL)
	pushl	%eax
	lret

ENTRY(setjmp)
	movl	4(%esp),%eax
	movl	%ebx,(%eax)		# save ebx
	movl	%esp,4(%eax)		# save esp
	movl	%ebp,8(%eax)		# save ebp
	movl	%esi,12(%eax)		# save esi
	movl	%edi,16(%eax)		# save edi
	movl	(%esp),%edx		# get rta
	movl	%edx,20(%eax)		# save eip
	xorl	%eax,%eax		# return (0);
	ret

ENTRY(longjmp)
	movl	4(%esp),%eax
	movl	(%eax),%ebx		# restore ebx
	movl	4(%eax),%esp		# restore esp
	movl	8(%eax),%ebp		# restore ebp
	movl	12(%eax),%esi		# restore esi
	movl	16(%eax),%edi		# restore edi
	movl	20(%eax),%edx		# get rta
	movl	%edx,(%esp)		# put in return frame
	xorl	%eax,%eax		# return (1);
	incl	%eax
	ret

/*****************************************************************************/
		
/*
 * cpu_switchto(struct proc *old, struct proc *new)
 * Switch from the "old" proc to the "new" proc. If "old" is NULL, we
 * don't need to bother saving old context.
 */
ENTRY(cpu_switchto)
	pushl	%ebx
	pushl	%esi
	pushl	%edi

	movl	16(%esp), %esi
	movl	20(%esp), %edi

	/* If old process exited, don't bother. */
	testl	%esi,%esi
	jz	switch_exited

	/* Save old stack pointers. */
	movl	P_ADDR(%esi),%ebx
	movl	%esp,PCB_ESP(%ebx)
	movl	%ebp,PCB_EBP(%ebx)

switch_exited:
	/* Restore saved context. */

	/* No interrupts while loading new state. */
	cli

	/* Record new process. */
	movl	%edi, CPUVAR(CURPROC)
	movb	$SONPROC, P_STAT(%edi)

	/* Restore stack pointers. */
	movl	P_ADDR(%edi),%ebx
	movl	PCB_ESP(%ebx),%esp
	movl	PCB_EBP(%ebx),%ebp

	/* Record new pcb. */
	movl	%ebx, CPUVAR(CURPCB)

	/*
	 * Activate the address space.  The pcb copy of %cr3 will
	 * be refreshed from the pmap, and because we're
	 * curproc they'll both be reloaded into the CPU.
	 */
	pushl	%edi
	pushl	%esi
	call	_C_LABEL(pmap_switch)
	addl	$8,%esp

	/* Load TSS info. */
	movl	CPUVAR(GDT),%eax
	movl	P_MD_TSS_SEL(%edi),%edx

	/* Switch TSS. */
	andl	$~0x0200,4-SEL_KPL(%eax,%edx,1)
	ltr	%dx

	/* Restore cr0 (including FPU state). */
	movl	PCB_CR0(%ebx),%ecx
#ifdef MULTIPROCESSOR
	/*
	 * If our floating point registers are on a different CPU,
	 * clear CR0_TS so we'll trap rather than reuse bogus state.
	 */
	movl	CPUVAR(SELF), %esi
	cmpl	PCB_FPCPU(%ebx), %esi
	jz	1f
	orl	$CR0_TS,%ecx
1:	
#endif	
	movl	%ecx,%cr0

	/* Interrupts are okay again. */
	sti

	popl	%edi
	popl	%esi
	popl	%ebx
	ret

ENTRY(cpu_idle_enter)
	movl	_C_LABEL(cpu_idle_enter_fcn),%eax
	cmpl	$0,%eax
	je	1f
	jmpl	*%eax
1:
	ret

ENTRY(cpu_idle_cycle)
	movl	_C_LABEL(cpu_idle_cycle_fcn),%eax
	cmpl	$0,%eax
	je	1f
	call	*%eax
	ret
1:
	sti
	hlt
	ret

ENTRY(cpu_idle_leave)
	movl	_C_LABEL(cpu_idle_leave_fcn),%eax
	cmpl	$0,%eax
	je	1f
	jmpl	*%eax
1:
	ret

/*
 * savectx(struct pcb *pcb);
 * Update pcb, saving current processor state.
 */
ENTRY(savectx)
	movl	4(%esp),%edx		# edx = p->p_addr

	/* Save stack pointers. */
	movl	%esp,PCB_ESP(%edx)
	movl	%ebp,PCB_EBP(%edx)

	movl	PCB_FLAGS(%edx),%ecx
	orl	$PCB_SAVECTX,%ecx
	movl	%ecx,PCB_FLAGS(%edx)

	ret

/*****************************************************************************/

/*
 * Trap and fault vector routines
 *
 * On exit from the kernel to user mode, we always need to check for ASTs.  In
 * addition, we need to do this atomically; otherwise an interrupt may occur
 * which causes an AST, but it won't get processed until the next kernel entry
 * (possibly the next clock tick).  Thus, we disable interrupt before checking,
 * and only enable them again on the final `iret' or before calling the AST
 * handler.
 */
#define	IDTVEC(name)	ALIGN_TEXT; .globl X##name; X##name:

#define	TRAP(a)		pushl $(a) ; jmp _C_LABEL(alltraps)
#define	ZTRAP(a)	pushl $0 ; TRAP(a)


	.text
IDTVEC(div)
	ZTRAP(T_DIVIDE)
IDTVEC(dbg)
	subl	$4,%esp
	pushl	%eax
	movl	%dr6,%eax
	movl	%eax,4(%esp)
	andb	$~0xf,%al
	movl	%eax,%dr6
	popl	%eax
	TRAP(T_TRCTRAP)
IDTVEC(nmi)
	ZTRAP(T_NMI)
IDTVEC(bpt)
	ZTRAP(T_BPTFLT)
IDTVEC(ofl)
	ZTRAP(T_OFLOW)
IDTVEC(bnd)
	ZTRAP(T_BOUND)
IDTVEC(ill)
	ZTRAP(T_PRIVINFLT)
IDTVEC(dna)
#if NNPX > 0
	pushl	$0			# dummy error code
	pushl	$T_DNA
	INTRENTRY
#ifdef MULTIPROCESSOR
	pushl	CPUVAR(SELF)
#else
	pushl	$_C_LABEL(cpu_info_primary)
#endif
	call	*_C_LABEL(npxdna_func)
	addl	$4,%esp
	testl	%eax,%eax
	jz	calltrap
	INTRFASTEXIT
#else
	ZTRAP(T_DNA)
#endif
IDTVEC(dble)
	TRAP(T_DOUBLEFLT)
IDTVEC(fpusegm)
	ZTRAP(T_FPOPFLT)
IDTVEC(tss)
	TRAP(T_TSSFLT)
IDTVEC(missing)
	TRAP(T_SEGNPFLT)
IDTVEC(stk)
	TRAP(T_STKFLT)
IDTVEC(prot)
	TRAP(T_PROTFLT)
IDTVEC(f00f_redirect)
	pushl	$T_PAGEFLT
	INTRENTRY
	testb	$PGEX_U,TF_ERR(%esp)
	jnz	calltrap
	movl	%cr2,%eax
	subl	_C_LABEL(idt),%eax
	cmpl	$(6*8),%eax
	jne	calltrap
	movb	$T_PRIVINFLT,TF_TRAPNO(%esp)
	jmp	calltrap
IDTVEC(page)
	TRAP(T_PAGEFLT)
IDTVEC(rsvd)
	ZTRAP(T_RESERVED)
IDTVEC(mchk)
	ZTRAP(T_MACHK)
IDTVEC(simd)
	ZTRAP(T_XFTRAP)
IDTVEC(intrspurious)
	/*
	 * The Pentium Pro local APIC may erroneously call this vector for a
	 * default IR7.  Just ignore it.
	 *
	 * (The local APIC does this when CPL is raised while it's on the
	 * way to delivering an interrupt.. presumably enough has been set
	 * up that it's inconvenient to abort delivery completely..)
	 */
	iret
IDTVEC(fpu)
#if NNPX > 0
	/*
	 * Handle like an interrupt so that we can call npxintr to clear the
	 * error.  It would be better to handle npx interrupts as traps but
	 * this is difficult for nested interrupts.
	 */
	subl	$8,%esp			/* space for tf_{err,trapno} */
	INTRENTRY
	pushl	CPL			# if_ppl in intrframe
	pushl	%esp			# push address of intrframe
	incl	_C_LABEL(uvmexp)+V_TRAP
	call	_C_LABEL(npxintr)
	addl	$8,%esp			# pop address and if_ppl
	INTRFASTEXIT
#else
	ZTRAP(T_ARITHTRAP)
#endif
IDTVEC(align)
	ZTRAP(T_ALIGNFLT)
	/* 18 - 31 reserved for future exp */

/*
 * If an error is detected during trap, syscall, or interrupt exit, trap() will
 * change %eip to point to one of these labels.  We clean up the stack, if
 * necessary, and resume as if we were handling a general protection fault.
 * This will cause the process to get a SIGBUS.
 */
NENTRY(resume_iret)
	ZTRAP(T_PROTFLT)
NENTRY(resume_pop_ds)
	pushl	%es
	movl	$GSEL(GDATA_SEL, SEL_KPL),%eax
	movw	%ax,%es
NENTRY(resume_pop_es)
	pushl	%gs
	xorl	%eax,%eax	/* $GSEL(GNULL_SEL, SEL_KPL) == 0 */
	movw	%ax,%gs
NENTRY(resume_pop_gs)
	pushl	%fs
	movl	$GSEL(GCPU_SEL, SEL_KPL),%eax
	movw	%ax,%fs
NENTRY(resume_pop_fs)
	movl	$T_PROTFLT,TF_TRAPNO(%esp)
	sti
	jmp	calltrap

/*
 * All traps go through here. Call the generic trap handler, and
 * check for ASTs afterwards.
 */
NENTRY(alltraps)
	INTRENTRY
	sti
calltrap:
#ifdef DIAGNOSTIC
	movl	CPL,%ebx
#endif /* DIAGNOSTIC */
#if !defined(GPROF) && defined(DDBPROF)
	cmpl	$T_BPTFLT,TF_TRAPNO(%esp)
	jne	.Lreal_trap

	pushl	%esp
	call	_C_LABEL(db_prof_hook)
	addl	$4,%esp
	cmpl	$1,%eax
	jne	.Lreal_trap

	/*
	 * Abuse the error field to indicate that INTRFASTEXIT needs
	 * to emulate the patched instruction.
	 */
	movl	$INTR_FAKE_TRAP, TF_ERR(%esp)
	jz	2f
.Lreal_trap:
#endif /* !defined(GPROF) && defined(DDBPROF) */
	pushl	%esp
	call	_C_LABEL(trap)
	addl	$4,%esp
2:	/* Check for ASTs on exit to user mode. */
	cli
	CHECK_ASTPENDING(%ecx)
	je	1f
	testb	$SEL_RPL,TF_CS(%esp)
#ifdef VM86
	jnz	5f
	testl	$PSL_VM,TF_EFLAGS(%esp)
#endif
	jz	1f
5:	CLEAR_ASTPENDING(%ecx)
	sti
	pushl	%esp
	call	_C_LABEL(ast)
	addl	$4,%esp
	jmp	2b
1:
#if !defined(GPROF) && defined(DDBPROF)
	/*
	 * If we are returning from a probe trap we need to fix the
	 * stack layout and emulate the patched instruction.
	 *
	 * The code below does that by trashing %eax, so it MUST be
	 * restored afterward.
	 */
	cmpl	$INTR_FAKE_TRAP, TF_ERR(%esp)
	je	.Lprobe_fixup
#endif /* !defined(GPROF) && defined(DDBPROF) */
#ifndef DIAGNOSTIC
	INTRFASTEXIT
#else
	cmpl	CPL,%ebx
	jne	3f
	INTRFASTEXIT
3:	sti
	pushl	$spl_lowered
	call	_C_LABEL(printf)
	addl	$4,%esp
#if defined(DDB) && 0
	int	$3
#endif /* DDB */
	movl	%ebx,CPL
	jmp	2b

	.section .rodata
spl_lowered:
	.asciz	"WARNING: SPL NOT LOWERED ON TRAP EXIT\n"
#endif /* DIAGNOSTIC */

	.text
#if !defined(GPROF) && defined(DDBPROF)
.Lprobe_fixup:
	/* Restore all register unwinding the stack. */
	INTR_RESTORE_ALL

	/*
	 * Use the space left by ``err'' and ``trapno'' to emulate
	 * "pushl %ebp".
	 *
	 * Temporarily save %eax.
	 */
	movl	%eax,0(%esp)

	/* Shift hardware-saved registers: eip, cs, eflags */
	movl	8(%esp),%eax
	movl	%eax,4(%esp)
	movl	12(%esp),%eax
	movl	%eax,8(%esp)
	movl	16(%esp),%eax
	movl	%eax,12(%esp)

	/* Store %ebp in the expected location to finish the emulation. */
	movl	%ebp,16(%esp)

	popl	%eax
	iret
#endif /* !defined(GPROF) && defined(DDBPROF) */
/*
 * Trap gate entry for syscall
 */
IDTVEC(syscall)
	subl	$8,%esp			/* space for tf_{err,trapno} */
	INTRENTRY
	pushl	%esp
	call	_C_LABEL(syscall)
	addl	$4,%esp
2:	/* Check for ASTs on exit to user mode. */
	cli
	CHECK_ASTPENDING(%ecx)
	je	1f
	/* Always returning to user mode here. */
	CLEAR_ASTPENDING(%ecx)
	sti
	pushl	%esp
	call	_C_LABEL(ast)
	addl	$4,%esp
	jmp	2b
1:	INTRFASTEXIT

#include <i386/i386/vector.s>
#include <i386/isa/icu.s>

/*
 * bzero (void *b, size_t len)
 *	write len zero bytes to the string b.
 */

ENTRY(bzero)
	pushl	%edi
	movl	8(%esp),%edi
	movl	12(%esp),%edx

	xorl	%eax,%eax		/* set fill data to 0 */

	/*
	 * if the string is too short, it's really not worth the overhead
	 * of aligning to word boundaries, etc.  So we jump to a plain
	 * unaligned set.
	 */
	cmpl	$16,%edx
	jb	7f

	movl	%edi,%ecx		/* compute misalignment */
	negl	%ecx
	andl	$3,%ecx
	subl	%ecx,%edx
	rep				/* zero until word aligned */
	stosb

	cmpl	$CPUCLASS_486,_C_LABEL(cpu_class)
	jne	8f

	movl	%edx,%ecx
	shrl	$6,%ecx
	jz	8f
	andl	$63,%edx
1:	movl	%eax,(%edi)
	movl	%eax,4(%edi)
	movl	%eax,8(%edi)
	movl	%eax,12(%edi)
	movl	%eax,16(%edi)
	movl	%eax,20(%edi)
	movl	%eax,24(%edi)
	movl	%eax,28(%edi)
	movl	%eax,32(%edi)
	movl	%eax,36(%edi)
	movl	%eax,40(%edi)
	movl	%eax,44(%edi)
	movl	%eax,48(%edi)
	movl	%eax,52(%edi)
	movl	%eax,56(%edi)
	movl	%eax,60(%edi)
	addl	$64,%edi
	decl	%ecx
	jnz	1b

8:	movl	%edx,%ecx		/* zero by words */
	shrl	$2,%ecx
	andl	$3,%edx
	rep
	stosl

7:	movl	%edx,%ecx		/* zero remainder bytes */
	rep
	stosb

	popl	%edi
	ret

#if !defined(SMALL_KERNEL)
ENTRY(sse2_pagezero)
	pushl	%ebx
	movl	8(%esp),%ecx
	movl	%ecx,%eax
	addl	$4096,%eax
	xor	%ebx,%ebx
1:
	movnti	%ebx,(%ecx)
	addl	$4,%ecx
	cmpl	%ecx,%eax
	jne	1b
	sfence
	popl	%ebx
	ret

ENTRY(i686_pagezero)
	pushl	%edi
	pushl	%ebx

	movl	12(%esp), %edi
	movl	$1024, %ecx

	.align  4,0x90
1:
	xorl	%eax, %eax
	repe
	scasl
	jnz	2f

	popl	%ebx
	popl	%edi
	ret

	.align  4,0x90
2:
	incl	%ecx
	subl	$4, %edi

	movl	%ecx, %edx
	cmpl	$16, %ecx

	jge	3f

	movl	%edi, %ebx
	andl	$0x3f, %ebx
	shrl	%ebx
	shrl	%ebx
	movl	$16, %ecx
	subl	%ebx, %ecx

3:
	subl	%ecx, %edx
	rep
	stosl

	movl	%edx, %ecx
	testl	%edx, %edx
	jnz	1b

	popl	%ebx
	popl	%edi
	ret
#endif

/*
 * int cpu_paenable(void *);
 */
ENTRY(cpu_paenable)
	movl	$-1, %eax
	testl	$CPUID_PAE, _C_LABEL(cpu_feature)
	jz	1f

	pushl	%esi
	pushl	%edi
	movl	12(%esp), %esi
	movl	%cr3, %edi
	orl	$0xfe0, %edi    /* PDPT will be in the last four slots! */
	movl	%edi, %cr3
	addl	$KERNBASE, %edi /* and make it back virtual again */
	movl	$8, %ecx
	rep
	movsl

	movl	$MSR_EFER, %ecx
	rdmsr
	orl	$EFER_NXE, %eax
	wrmsr

	movl	%cr4, %eax
	orl	$CR4_PAE, %eax
	movl	%eax, %cr4      /* BANG!!! */

	movl	12(%esp), %eax
	subl	$KERNBASE, %eax
	movl	%eax, %cr3      /* reload real PDPT */
	movl	$4*NBPG, %eax
	movl	%eax, _C_LABEL(PTDsize)

	xorl	%eax, %eax
	popl	%edi
	popl	%esi
1:
	ret

#if NLAPIC > 0
#include <i386/i386/apicvec.s>
#endif

#include <i386/i386/mutex.S>

	.section .rodata
	.globl _C_LABEL(_stac)
_C_LABEL(_stac):
	stac

	.globl _C_LABEL(_clac)
_C_LABEL(_clac):
	clac
@


1.179
log
@The codepatch chunks for SMEP slac & clac can placed in .rodata because
they are never executed directly.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.178 2017/07/06 06:17:05 deraadt Exp $	*/
d108 1
@


1.178
log
@0xcc-fill a few more alignments.  Not because these ones matter particularily,
but because elimination highlights more important ones.
Cursory review mortimer, ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.177 2017/06/30 06:17:47 mlarkin Exp $	*/
d1323 2
a1324 1
.globl _C_LABEL(_stac)
d1328 1
a1328 1
.globl _C_LABEL(_clac)
@


1.177
log
@Remove unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.176 2017/06/29 17:17:28 deraadt Exp $	*/
d83 1
a83 1
#define	ALIGN_DATA	.align  4
a84 1
#define	SUPERALIGN_TEXT	.align  16,0x90	/* 16-byte boundaries better for 486 */
d349 1
a349 1
	ALIGN_TEXT
d1235 1
a1235 1
	ALIGN_TEXT
d1246 1
a1246 2
	ALIGN_TEXT

@


1.176
log
@Put asm-generated strings into .rodata
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.175 2017/05/31 19:18:18 deraadt Exp $	*/
d152 1
a152 1
	.globl	_C_LABEL(PTmap), _C_LABEL(PTD), _C_LABEL(PTDpde)
a154 11
	.set	_C_LABEL(PTDpde), (_C_LABEL(PTD) + PDSLOT_PTE * 4)	# XXX 4 == sizeof pde

/*
 * APTmap, APTD is the alternate recursive pagemap.
 * It's used when modifying another process's page tables.
 */
	.globl	_C_LABEL(APTmap), _C_LABEL(APTD), _C_LABEL(APTDpde)
	.set	_C_LABEL(APTmap), (PDSLOT_APTE << PDSHIFT)
	.set	_C_LABEL(APTD), (_C_LABEL(APTmap) + PDSLOT_APTE * NBPG)
	# XXX 4 == sizeof pde
	.set	_C_LABEL(APTDpde), (_C_LABEL(PTD) + PDSLOT_APTE * 4)
@


1.175
log
@Split early startup code out of locore.S into locore0.S.  Adjust link
run so that this locore0.o is always at the start of the executable.
But randomize the link order of all other .o files in the kernel, so
that their exec/rodata/data/bss segments land all over the place.
Late during kernel boot, unmap the early startup code.

As a result, the internal layout of every newly build bsd kernel is
different from past kernels.  Internal relative offsets are not known
to an outside attacker.  The only known offsets are in the startup code,
which has been unmapped.

Ramdisk kernels cannot be compiled like this, because they are gzip'd.
When the internal pointer references change, the compression dictionary
bloats and results in poorer compression.

ok kettenis mlarkin visa, also thanks to tedu for getting me back to this
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.174 2017/05/30 15:11:32 deraadt Exp $	*/
d1090 1
a1090 1
	pushl	$4f
d1098 4
a1101 1
4:	.asciz	"WARNING: SPL NOT LOWERED ON TRAP EXIT\n"
d1104 1
@


1.174
log
@Support for SMAP is pretty small, so don't exclude it from the RAMDISKS.
ok jsg visa
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.173 2017/05/12 08:46:28 mpi Exp $	*/
a248 6
	.space 512
tmpstk:


#define	RELOC(x)	((x) - KERNBASE)

a249 404
	.globl	start
	.globl	_C_LABEL(kernel_text)
	_C_LABEL(kernel_text) = KERNTEXTOFF
start:	movw	$0x1234,0x472			# warm boot

	/*
	 * Load parameters from stack (howto, bootdev, unit, bootapiver, esym).
	 * note: (%esp) is return address of boot
	 * (If we want to hold onto /boot, it's physical %esp up to _end.)
	 */
	movl	4(%esp),%eax
	movl	%eax,RELOC(_C_LABEL(boothowto))
	movl	8(%esp),%eax
	movl	%eax,RELOC(_C_LABEL(bootdev))
	movl	16(%esp),%eax
	testl	%eax,%eax
	jz	1f
	addl	$KERNBASE,%eax
1:	movl	%eax,RELOC(_C_LABEL(esym))
	movl	$__kernel_bss_end, RELOC(_C_LABEL(ssym))

	movl	12(%esp),%eax
	movl	%eax,RELOC(_C_LABEL(bootapiver))
	movl	28(%esp), %eax
	movl	%eax, RELOC(_C_LABEL(bootargc))
	movl	32(%esp), %eax
	movl	%eax, RELOC(_C_LABEL(bootargv))

	/* First, reset the PSL. */
	pushl	$PSL_MBO
	popfl

	/* Clear segment registers; null until proc0 setup */
	xorl	%eax,%eax
	movw	%ax,%fs
	movw	%ax,%gs

	/* Find out our CPU type. */

try386:	/* Try to toggle alignment check flag; does not exist on 386. */
	pushfl
	popl	%eax
	movl	%eax,%ecx
	orl	$PSL_AC,%eax
	pushl	%eax
	popfl
	pushfl
	popl	%eax
	xorl	%ecx,%eax
	andl	$PSL_AC,%eax
	pushl	%ecx
	popfl

	testl	%eax,%eax
	jnz	try486

	/*
	 * Try the test of a NexGen CPU -- ZF will not change on a DIV
	 * instruction on a NexGen, it will on an i386.  Documented in
	 * Nx586 Processor Recognition Application Note, NexGen, Inc.
	 */
	movl	$0x5555,%eax
	xorl	%edx,%edx
	movl	$2,%ecx
	divl	%ecx
	jnz	is386

isnx586:
	/*
	 * Don't try cpuid, as Nx586s reportedly don't support the
	 * PSL_ID bit.
	 */
	movl	$CPU_NX586,RELOC(_C_LABEL(cpu))
	jmp	2f

is386:
	movl	$CPU_386,RELOC(_C_LABEL(cpu))
	jmp	2f

try486:	/* Try to toggle identification flag; does not exist on early 486s. */
	pushfl
	popl	%eax
	movl	%eax,%ecx
	xorl	$PSL_ID,%eax
	pushl	%eax
	popfl
	pushfl
	popl	%eax
	xorl	%ecx,%eax
	andl	$PSL_ID,%eax
	pushl	%ecx
	popfl

	testl	%eax,%eax
	jnz	try586
is486:	movl	$CPU_486,RELOC(_C_LABEL(cpu))

	/*
	 * Check Cyrix CPU
	 * Cyrix CPUs do not change the undefined flags following
	 * execution of the divide instruction which divides 5 by 2.
	 *
	 * Note: CPUID is enabled on M2, so it passes another way.
	 */
	pushfl
	movl	$0x5555, %eax
	xorl	%edx, %edx
	movl	$2, %ecx
	clc
	divl	%ecx
	jnc	trycyrix486
	popfl
	jmp	2f
trycyrix486:
	movl	$CPU_6x86,RELOC(_C_LABEL(cpu))	# set CPU type
	/*
	 * Check for Cyrix 486 CPU by seeing if the flags change during a
	 * divide.  This is documented in the Cx486SLC/e SMM Programmer's
	 * Guide.
	 */
	xorl	%edx,%edx
	cmpl	%edx,%edx		# set flags to known state
	pushfl
	popl	%ecx			# store flags in ecx
	movl	$-1,%eax
	movl	$4,%ebx
	divl	%ebx			# do a long division
	pushfl
	popl	%eax
	xorl	%ecx,%eax		# are the flags different?
	testl	$0x8d5,%eax		# only check C|PF|AF|Z|N|V
	jne	2f			# yes; must not be Cyrix CPU
	movl	$CPU_486DLC,RELOC(_C_LABEL(cpu))	# set CPU type

	/* Disable caching of the ISA hole only. */
	invd
	movb	$CCR0,%al		# Configuration Register index (CCR0)
	outb	%al,$0x22
	inb	$0x23,%al
	orb	$(CCR0_NC1|CCR0_BARB),%al
	movb	%al,%ah
	movb	$CCR0,%al
	outb	%al,$0x22
	movb	%ah,%al
	outb	%al,$0x23
	invd

	jmp	2f

try586:	/* Use the `cpuid' instruction. */
	xorl	%eax,%eax
	cpuid
	movl	%eax,RELOC(_C_LABEL(cpuid_level))
	movl	%ebx,RELOC(_C_LABEL(cpu_vendor))	# store vendor string
	movl	%edx,RELOC(_C_LABEL(cpu_vendor))+4
	movl	%ecx,RELOC(_C_LABEL(cpu_vendor))+8
	movl	$0,  RELOC(_C_LABEL(cpu_vendor))+12

	movl	$1,%eax
	xorl	%ecx,%ecx
	cpuid
	movl	%eax,RELOC(_C_LABEL(cpu_id))	# store cpu_id and features
	movl	%ebx,RELOC(_C_LABEL(cpu_miscinfo))
	movl	%edx,RELOC(_C_LABEL(cpu_feature))
	movl	%ecx,RELOC(_C_LABEL(cpu_ecxfeature))

	movl	RELOC(_C_LABEL(cpuid_level)),%eax
	cmp	$2,%eax
	jl	1f

	movl	$2,%eax
	cpuid

	movl	%eax,RELOC(_C_LABEL(cpu_cache_eax))
	movl	%ebx,RELOC(_C_LABEL(cpu_cache_ebx))
	movl	%ecx,RELOC(_C_LABEL(cpu_cache_ecx))
	movl	%edx,RELOC(_C_LABEL(cpu_cache_edx))

	movl	$0x0a,%eax
	cpuid
	movl	%eax,RELOC(_C_LABEL(cpu_perf_eax))
	movl	%ebx,RELOC(_C_LABEL(cpu_perf_ebx))
	movl	%edx,RELOC(_C_LABEL(cpu_perf_edx))

1:
	/* Check if brand identification string is supported */
	movl	$0x80000000,%eax
	cpuid
	cmpl	$0x80000000,%eax
	jbe	2f
	movl	$0x80000001,%eax
	cpuid
	movl	%eax,RELOC(_C_LABEL(ecpu_eaxfeature))
	movl	%edx,RELOC(_C_LABEL(ecpu_feature))
	movl	%ecx,RELOC(_C_LABEL(ecpu_ecxfeature))
	movl	$0x80000002,%eax
	cpuid
	movl	%eax,RELOC(_C_LABEL(cpu_brandstr))
	movl	%ebx,RELOC(_C_LABEL(cpu_brandstr))+4
	movl	%ecx,RELOC(_C_LABEL(cpu_brandstr))+8
	movl	%edx,RELOC(_C_LABEL(cpu_brandstr))+12
	movl	$0x80000003,%eax
	cpuid
	movl	%eax,RELOC(_C_LABEL(cpu_brandstr))+16
	movl	%ebx,RELOC(_C_LABEL(cpu_brandstr))+20
	movl	%ecx,RELOC(_C_LABEL(cpu_brandstr))+24
	movl	%edx,RELOC(_C_LABEL(cpu_brandstr))+28
	movl	$0x80000004,%eax
	cpuid
	movl	%eax,RELOC(_C_LABEL(cpu_brandstr))+32
	movl	%ebx,RELOC(_C_LABEL(cpu_brandstr))+36
	movl	%ecx,RELOC(_C_LABEL(cpu_brandstr))+40
	andl	$0x00ffffff,%edx	/* Shouldn't be necessary */
	movl	%edx,RELOC(_C_LABEL(cpu_brandstr))+44

	movl	$0x80000007,%eax
	cpuid
	movl	%edx,RELOC(_C_LABEL(cpu_apmi_edx))

2:
	/*
	 * Finished with old stack; load new %esp now instead of later so we
	 * can trace this code without having to worry about the trace trap
	 * clobbering the memory test or the zeroing of the bss+bootstrap page
	 * tables.
	 *
	 * The boot program should check:
	 *	text+data <= &stack_variable - more_space_for_stack
	 *	text+data+bss+pad+space_for_page_tables <= end_of_memory
	 * Oops, the gdt is in the carcass of the boot program so clearing
	 * the rest of memory is still not possible.
	 */
	movl	$RELOC(tmpstk),%esp	# bootstrap stack end location

/*
 * Virtual address space of kernel:
 *
 * text | data | bss | [syms] | proc0 kstack | page dir     | Sysmap
 *			      0             1       2       6
 */
#define	PROC0STACK	((0)		* NBPG)
#define	PROC0PDIR	((  UPAGES)	* NBPG)
#define	SYSMAP		((4+UPAGES)	* NBPG)
#define	TABLESIZE	((4+UPAGES) * NBPG) /* + _C_LABEL(nkpde) * NBPG */

	/* Find end of kernel image. */
	movl	$RELOC(_C_LABEL(end)),%edi
#if (NKSYMS || defined(DDB))
	/* Save the symbols (if loaded). */
	movl	RELOC(_C_LABEL(esym)),%eax
	testl	%eax,%eax
	jz	1f
	subl	$KERNBASE,%eax
	movl	%eax,%edi
1:
#endif

	/* Calculate where to start the bootstrap tables. */
	movl	%edi,%esi			# edi = esym ? esym : end
	addl	$PGOFSET, %esi			# page align up
	andl	$~PGOFSET, %esi

	/*
	 * Calculate the size of the kernel page table directory, and
	 * how many entries it will have.
	 */
	movl	RELOC(_C_LABEL(nkpde)),%ecx	# get nkpde
	cmpl	$NKPTP_MIN,%ecx			# larger than min?
	jge	1f
	movl	$NKPTP_MIN,%ecx			# set at min
	jmp	2f
1:	cmpl	RELOC(_C_LABEL(nkptp_max)),%ecx	# larger than max?
	jle	2f
	movl	RELOC(_C_LABEL(nkptp_max)),%ecx
2:	movl	%ecx,RELOC(_C_LABEL(nkpde))	# and store it back

	/* Clear memory for bootstrap tables. */
	shll	$PGSHIFT,%ecx
	addl	$TABLESIZE,%ecx
	addl	%esi,%ecx			# end of tables
	subl	%edi,%ecx			# size of tables
	shrl	$2,%ecx
	xorl	%eax, %eax
	rep
	stosl

/*
 * fillkpt
 *	eax = pte (page frame | control | status)
 *	ebx = page table address
 *	ecx = number of pages to map
 */
#define	fillkpt		\
1:	movl	%eax,(%ebx)	; \
	addl	$NBPG,%eax	; /* increment physical address */ \
	addl	$4,%ebx		; /* next pte */ \
	loop	1b		;

/*
 * Build initial page tables.
 */
	/* Calculate end of text segment, rounded to a page. */
	leal	(RELOC(_C_LABEL(etext))+PGOFSET),%edx
	andl	$~PGOFSET,%edx

	/* Skip over the first 2MB. */
	movl	$RELOC(KERNTEXTOFF),%eax
	movl	%eax,%ecx
	shrl	$PGSHIFT,%ecx
	leal	(SYSMAP)(%esi,%ecx,4),%ebx

	/* Map the kernel text read-only. */
	movl	%edx,%ecx
	subl	%eax,%ecx
	shrl	$PGSHIFT,%ecx
	orl	$(PG_V|PG_KR),%eax
	fillkpt

	/* Map the data, BSS, and bootstrap tables read-write. */
	leal	(PG_V|PG_KW)(%edx),%eax
	movl	RELOC(_C_LABEL(nkpde)),%ecx
	shll	$PGSHIFT,%ecx
	addl	$TABLESIZE,%ecx
	addl	%esi,%ecx				# end of tables
	subl	%edx,%ecx				# subtract end of text
	shrl	$PGSHIFT,%ecx
	fillkpt

	/* Map ISA I/O memory. */
	movl	$(IOM_BEGIN|PG_V|PG_KW/*|PG_N*/),%eax	# having these bits set
	movl	$(IOM_SIZE>>PGSHIFT),%ecx		# for this many pte s,
	fillkpt

/*
 * Construct a page table directory.
 */
	movl	RELOC(_C_LABEL(nkpde)),%ecx		# count of pdes,
	leal	(PROC0PDIR+0*4)(%esi),%ebx		# where temp maps!
	leal	(SYSMAP+PG_V|PG_KW|PG_U|PG_M)(%esi),%eax # pte for KPT in proc 0
	fillkpt

/*
 * Map kernel PDEs: this is the real mapping used
 * after the temp mapping outlives its usefulness.
 */
	movl	RELOC(_C_LABEL(nkpde)),%ecx		# count of pde s,
	leal	(PROC0PDIR+PDSLOT_KERN*4)(%esi),%ebx	# map them high
	leal	(SYSMAP+PG_V|PG_KW|PG_U|PG_M)(%esi),%eax # pte for KPT in proc 0
	fillkpt

	/* Install a PDE recursively mapping page directory as a page table! */
	leal	(PROC0PDIR+PG_V|PG_KW|PG_U|PG_M)(%esi),%eax # pte for ptd
	movl	%eax,(PROC0PDIR+PDSLOT_PTE*4)(%esi)	# recursive PD slot
	addl	$NBPG, %eax				# pte for ptd[1]
	movl    %eax,(PROC0PDIR+(PDSLOT_PTE+1)*4)(%esi) # recursive PD slot

	/* Save phys. addr of PTD, for libkvm. */
	leal	(PROC0PDIR)(%esi),%eax		# phys address of ptd in proc 0
	movl	%eax,RELOC(_C_LABEL(PTDpaddr))

	/* Load base of page directory and enable mapping. */
	movl	%eax,%cr3		# load ptd addr into mmu
	movl	%cr0,%eax		# get control word
					# enable paging & NPX emulation
	orl	$(CR0_PE|CR0_PG|CR0_NE|CR0_TS|CR0_EM|CR0_MP),%eax
	movl	%eax,%cr0		# and let's page NOW!

	pushl	$begin			# jump to high mem
	ret

begin:
	/* Now running relocated at KERNBASE.  Remove double mapping. */
	movl	_C_LABEL(nkpde),%ecx		# for this many pde s,
	leal	(PROC0PDIR+0*4)(%esi),%ebx	# which is where temp maps!
	addl	$(KERNBASE), %ebx	# now use relocated address
1:	movl	$0,(%ebx)
	addl	$4,%ebx	# next pde
	loop	1b

	/* Relocate atdevbase. */
	movl	_C_LABEL(nkpde),%edx
	shll	$PGSHIFT,%edx
	addl	$(TABLESIZE+KERNBASE),%edx
	addl	%esi,%edx
	movl	%edx,_C_LABEL(atdevbase)

	/* Set up bootstrap stack. */
	leal	(PROC0STACK+KERNBASE)(%esi),%eax
	movl	%eax,_C_LABEL(proc0paddr)
	leal	(USPACE-FRAMESIZE)(%eax),%esp
	leal	(PROC0PDIR)(%esi),%ebx	# phys address of ptd in proc 0
	movl	%ebx,PCB_CR3(%eax)	# pcb->pcb_cr3
	xorl	%ebp,%ebp		# mark end of frames

	movl	_C_LABEL(nkpde),%eax
	shll	$PGSHIFT,%eax
	addl	$TABLESIZE,%eax
	addl	%esi,%eax		# skip past stack and page tables
	pushl	%eax
	call	_C_LABEL(init386)	# wire 386 chip for unix operation
	addl	$4,%esp

	call	_C_LABEL(main)
	/* NOTREACHED */
@


1.173
log
@Make atomic.h ready to be included in userland.

- prefix the LOCK macro with an underscore
- keep setbits/clearbits and virtio barriers inside _KERNEL
- Get rid of unused futex_atomic_ucas_int32().

ok dlg@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.172 2017/02/06 09:13:41 mpi Exp $	*/
a61 1
#ifndef SMALL_KERNEL
a77 8

#else

#define SMAP_STAC
#define SMAP_CLAC

#endif

@


1.172
log
@Implement Dynamic Profiling, a ddb(4) based & gprof compatible kernel
profiling framework, for i386.

Code patching is used to enable probes when entering functions.  The
probes will call a mcount()-like function to match the behavior of a
GPROF kernel.

A new sysctl knob, ddb.profile, need to be set to 1 in securelevel 0
to be able to use this feature.

ok jasper@@, guenther@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.171 2016/10/13 09:01:04 mlarkin Exp $	*/
a1742 36
	ret

/*
 * ucas_32(volatile int32_t *uptr, int32_t old, int32_t new);
 */
ENTRY(ucas_32)
#ifdef DDB
	pushl	%ebp
	movl	%esp,%ebp
#endif
	pushl	%esi
	pushl	%edi
	pushl	$0	
	
	movl	16+FPADD(%esp),%esi
	movl	20+FPADD(%esp),%eax
	movl	24+FPADD(%esp),%edi

	cmpl    $VM_MAXUSER_ADDRESS-4, %esi
	ja      _C_LABEL(copy_fault)

	GET_CURPCB(%edx)
	movl	$_C_LABEL(copy_fault),PCB_ONFAULT(%edx)
	SMAP_STAC

	lock
	cmpxchgl %edi, (%esi)

	SMAP_CLAC
	popl	PCB_ONFAULT(%edx)
	popl	%edi
	popl	%esi
	xorl	%eax,%eax
#ifdef DDB
	leave
#endif
@


1.172.4.1
log
@If SMAP is present, clear PSL_AC on kernel entry and interrupt so that
only the code in copy{in,out}* that need it run with it set.  Panic if
it's set on entry to trap() or syscall().  Prompted by Maxime Villard's
NetBSD work.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.172 2017/02/06 09:13:41 mpi Exp $	*/
a117 1
	SMAP_CLAC		; \
@


1.171
log
@
cache another feature bit for something I'm working on
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.170 2016/07/16 06:04:29 mlarkin Exp $	*/
d136 2
a137 1
#define	INTRFASTEXIT \
d148 4
a151 1
	popl	%eax		; \
d155 1
d1453 18
d1490 12
d1503 1
a1503 1
1:	INTRFASTEXIT
d1505 1
a1505 1
1:	cmpl	CPL,%ebx
d1520 27
@


1.170
log
@
remove some unused #includes
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.169 2016/05/23 20:11:49 deraadt Exp $	*/
d181 2
a182 1
	.globl	_C_LABEL(ecpu_feature), _C_LABEL(ecpu_ecxfeature)
d226 1
d452 1
@


1.170.2.1
log
@If SMAP is present, clear PSL_AC on kernel entry and interrupt so that
only the code in copy{in,out}* that need it run with it set.  Panic if
it's set on entry to trap() or syscall().  Prompted by Maxime Villard's
NetBSD work.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.170 2016/07/16 06:04:29 mlarkin Exp $	*/
a117 1
	SMAP_CLAC		; \
@


1.169
log
@Place a cpu-dependent trap/illegal instruction over the remainder of the
sigtramp page, so that it will generate a nice kernel fault if touched.
While here, move most of the sigtramps to the .rodata segment, because
they are not executed in the kernel.
Also some preparation for sliding the actual sigtramp forward (will need
some gdb changes)
ok mlarkin kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.168 2016/05/10 18:39:45 deraadt Exp $	*/
a42 1
#include "ioapic.h"
a43 1
#include "acpi.h"
@


1.168
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.167 2016/03/15 03:17:51 guenther Exp $	*/
d692 3
a694 1
NENTRY(sigcode)
d702 1
a702 1
	.globl  _C_LABEL(sigcoderet)
d708 12
@


1.167
log
@Burn more LDT deadwood: stop allocating one for each idle thread,
load the ldt register with the null selector (disabling use of it),
stop reloading it on every context switch, and blow away the table
itself, as well as the pcb and pmap bits that were used to track
it (making sure to keep pcb_savefpu correctly aligned).

testing naddy@@
ok kettenis@@ mpi@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.166 2016/03/09 13:46:14 mpi Exp $	*/
d700 2
@


1.166
log
@Unmask interrupts unconditionnally before calling the generic trap handler.

Reduce differences with amd64.

Inputs from mikeb@@, ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.165 2016/03/03 12:32:23 mpi Exp $	*/
d1190 2
a1191 2
	 * Activate the address space.  The pcb copy of %cr3 and the
	 * LDT will be refreshed from the pmap, and because we're
@


1.165
log
@Kill BPTTRAP() and reduce some differences betwen i386 and amd64 trap
handlers.

No functionnal change.

ok mlarkin@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.164 2016/02/28 15:46:18 naddy Exp $	*/
a1284 3
 *
 * XXX - debugger traps are now interrupt gates so at least bdb doesn't lose
 * control. STI gives the standard losing behaviour for ddb and kgdb.
a1289 1
#define STI		testb $(PSL_I>>8),13(%esp) ; jz 1f ; sti ; 1: ;
a1302 1
	STI
a1306 1
	STI
a1401 1
	sti
d1426 1
@


1.164
log
@Support for running Linux binaries under emulation is going away.

Remove "option COMPAT_LINUX" and everything directly tied to it from the
kernel and the corresponding man page documentation.

ok visa@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.163 2016/02/26 02:25:09 mlarkin Exp $	*/
d1287 1
a1287 1
 * control.  The sti's give the standard losing behaviour for ddb and kgdb.
d1293 2
a1294 2
#define	BPTTRAP(a)	testb $(PSL_I>>8),13(%esp) ; jz 1f ; sti ; 1: ; \
			TRAP(a)
d1307 2
a1308 1
	BPTTRAP(T_TRCTRAP)
d1312 2
a1313 2
	pushl	$0
	BPTTRAP(T_BPTFLT)
d1427 4
@


1.163
log
@
pctr.h is not used here, so no need to include it.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.162 2016/02/26 02:23:07 mlarkin Exp $	*/
a48 3
#ifdef COMPAT_LINUX
#include <compat/linux/linux_syscall.h>
#endif
a703 21

/*****************************************************************************/

/*****************************************************************************/

#ifdef COMPAT_LINUX
/*
 * Signal trampoline; copied to top of user stack.
 */
NENTRY(linux_sigcode)
	call	*LINUX_SIGF_HANDLER(%esp)
	leal	LINUX_SIGF_SC(%esp),%ebx # scp (the call may have clobbered the
					# copy at SIGF_SCP(%esp))
	pushl	%eax			# junk to fake return address
	movl	$LINUX_SYS_sigreturn,%eax
	int	$0x80			# enter kernel with args on stack
	movl	$LINUX_SYS_exit,%eax
	int	$0x80			# exit if sigreturn fails
	.globl	_C_LABEL(linux_esigcode)
_C_LABEL(linux_esigcode):
#endif
@


1.162
log
@
SYMTAB_SPACE is no longer used (last used with a.out ddb)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.161 2015/08/25 04:57:31 mlarkin Exp $	*/
a43 1
#include "pctr.h"
@


1.161
log
@
Enforce kernel w^x policy by properly setting NX (as needed) for
kernel text, PTEs, .rodata, data, bss and the symbol regions. This has
been in snaps for a while with no reported fallout.

The APTE space and MP/ACPI trampolines will be fixed next.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.160 2015/08/12 06:19:25 mlarkin Exp $	*/
d510 1
a510 1
#if (defined(DDB) || NKSYMS > 0) && !defined(SYMTAB_SPACE)
@


1.160
log
@
Use a linker script when building i386 kernels to allow section padding on
PAGE_SIZE boundaries. This is required to enforce proper separation of
sections when adding page protections (coming shortly).

This was in snaps before release with no reported side effects.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.159 2015/07/16 22:06:08 mlarkin Exp $	*/
a1670 4
	movl	%cr4, %eax
	orl	$CR4_PAE, %eax
	movl	%eax, %cr4      /* BANG!!! */

d1675 4
@


1.159
log
@
Remove a piece of code that has been commented out for 16 years and was
wrong to begin with.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.158 2015/06/28 01:11:27 guenther Exp $	*/
d197 1
d244 1
d283 1
@


1.158
log
@Split AST handling from trap() into ast() and get rid of T_ASTFLT

testing by krw@@, and then many via snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.157 2015/04/26 09:48:29 kettenis Exp $	*/
a432 4
/*
	cmp	$1,%al
	jne	1f
*/
@


1.157
log
@Only enable PAE if the CPU we're running on has NX support.  Without NX
support we're only wasting memory on the larger PAE page tables without
any real benefit.  This allows some simplifications of the low-level
assembly code.

ok mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.156 2015/04/25 21:31:24 guenther Exp $	*/
d1411 1
a1411 2
	pushl	$0			# dummy error code
	pushl	$T_ASTFLT
a1472 1
	movl	$T_ASTFLT,TF_TRAPNO(%esp)
d1474 1
a1474 1
	call	_C_LABEL(trap)
d1499 1
a1499 2
	pushl	$2		# ignored
	pushl	$T_ASTFLT	# trap # for doing ASTs
a1510 1
	/* Pushed T_ASTFLT into tf_trapno on entry. */
d1512 1
a1512 1
	call	_C_LABEL(trap)
@


1.156
log
@We now following the ABI and always clear cld on function entry, so remove
the extra CLD instructions from when that wasn't true

testing miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.155 2015/04/24 12:52:38 kettenis Exp $	*/
d1663 1
a1663 1
	jz	2f
d1680 1
a1680 1
	movl	$MSR_EFER,%ecx
a1681 9
	movl	%edx, %edi		# %edx is needed by wrmsr below

	# Check if we need to enable NXE
	movl	$0x80000001, %eax
	cpuid
	andl	$CPUID_NXE, %edx
	xorl	%eax,%eax
	testl	%edx, %edx
	jz	1f
a1682 3
1:
	movl	%edi, %edx		# Restore saved %edx
	movl	$MSR_EFER,%ecx
d1694 1
a1694 1
2:
@


1.155
log
@Enable the NX bit and use it in the PAE pmap code.  PAE is still disabled
while we're chasing at least one remaining bug.

ok mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.154 2015/04/19 06:27:17 sf Exp $	*/
a546 1
	cld
d766 1
a766 2
	cld				# nope, copy forward
	shrl	$2,%ecx			# copy by 32-bit words
a852 1
	cld
a903 1
	cld
a972 1
	cld
a1027 1
	cld
a1086 1
	cld
a1533 1
	cld				/* set fill direction forward */
a1612 1
	cld
a1672 1
	cld
@


1.154
log
@Binary code patching on i386

This commit ports the infrastructure to do binary code patching from amd64.
The existing code patching for SMAP is converted to the new infrastruture.

ok kettenis@@
"should go in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.153 2015/04/18 05:14:05 guenther Exp $	*/
d1672 1
a1672 1
	jz	1f
d1685 1
d1689 18
d1716 1
a1716 1
1:
@


1.153
log
@i386 and amd64 have only one syscall entry point now, so simply the
EIP/RIP adjustment for ERESTART

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.152 2015/04/12 18:37:53 mlarkin Exp $	*/
d54 1
d68 1
d78 15
a92 1
#define SMAP_NOP       .byte 0x90, 0x90, 0x90
d681 12
a823 1
.globl _C_LABEL(_copyout_stac), _C_LABEL(_copyout_clac)
d852 1
a852 2
_C_LABEL(_copyout_stac):
	SMAP_NOP
d865 1
a865 2
_C_LABEL(_copyout_clac):
	SMAP_NOP
a878 1
.globl _C_LABEL(_copyin_stac), _C_LABEL(_copyin_clac)
d889 1
a889 2
_C_LABEL(_copyin_stac):
	SMAP_NOP
d917 1
a917 2
_C_LABEL(_copyin_clac):
	SMAP_NOP
a927 1
.globl _C_LABEL(_copy_fault_clac)
d929 1
a929 2
_C_LABEL(_copy_fault_clac):
	SMAP_NOP
a946 1
.globl _C_LABEL(_copyoutstr_stac)
d961 1
a961 2
_C_LABEL(_copyoutstr_stac):
	SMAP_NOP
a1003 1
.globl _C_LABEL(_copyinstr_stac)
d1013 1
a1013 2
_C_LABEL(_copyinstr_stac):
	SMAP_NOP
a1052 1
.globl _C_LABEL(_copystr_fault_clac)
d1057 1
a1057 2
_C_LABEL(_copystr_fault_clac):
	SMAP_NOP
a1702 1
.global _C_LABEL(_ucas_32_stac), _C_LABEL(_ucas_32_clac)
d1721 1
a1721 2
_C_LABEL(_ucas_32_stac):
	SMAP_NOP
d1726 1
a1726 2
_C_LABEL(_ucas_32_clac):
	SMAP_NOP
@


1.152
log
@
Bring PAE code back to life, in a different form. This diff (via bluhm then
to deraadt, then myself) brings the PAE pmap on i386 (not touched in any
significant way for years) closer to the current non-PAE pmap and allows
us to take a big next step toward better i386 W^X in the kernel (similar to
what we did a few months ago on amd64). Unlike the original PAE pmap, this
diff will not be supporting > 4GB physical memory on i386 - this effort is
specifically geared toward providing W^X (via NX) only.

There still seems to be a bug removing certain pmap entries when PAE is
enabled, so I'm leaving PAE mode disabled for the moment until we can
figure out what is going on, but with this diff in the tree hopefully
others can help.

The pmap functions now operate through function pointers, due to the need
to support both non-PAE and PAE forms. My unscientific testing showed
less than 0.3% (a third of a percent) slowdown with this approach during
a base build.

Discussed for months with guenther, kettenis, and deraadt.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.151 2015/04/01 19:45:21 mlarkin Exp $	*/
d1494 1
a1494 1
	pushl	$2		# size of instruction for restart
@


1.151
log
@
Add cpu_pae variable (which will be later used to determine if PAE mode is
in use) now so that libkvm can be fixed before the rest of the bulk of PAE
support is committed.

requested by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.150 2015/02/11 00:16:07 miod Exp $	*/
d181 1
d485 2
a486 2
 * text | data | bss | [syms] | proc0 stack | page dir     | Sysmap
 *			      0             1       2      3
d490 2
a491 2
#define	SYSMAP		((1+UPAGES)	* NBPG)
#define	TABLESIZE	((1+UPAGES) * NBPG) /* + _C_LABEL(nkpde) * NBPG */
d519 1
a519 1
1:	cmpl	$NKPTP_MAX,%ecx			# larger than max?
d521 1
a521 1
	movl	$NKPTP_MAX,%ecx
d585 1
a585 1
	movl	RELOC(_C_LABEL(nkpde)),%ecx		# count of pde s,
d587 1
a587 1
	leal	(SYSMAP+PG_V|PG_KW)(%esi),%eax		# pte for KPT in proc 0
d596 1
a596 1
	leal	(SYSMAP+PG_V|PG_KW)(%esi),%eax		# pte for KPT in proc 0
d600 1
a600 1
	leal	(PROC0PDIR+PG_V|PG_KW)(%esi),%eax	# pte for ptd
d602 2
d1651 34
@


1.150
log
@zero ecx before cpuid(1), for some Cyrix processors do not really
support cpuid with other values than zero, and leave the ecx register
unchanged.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.149 2015/02/07 00:26:37 deraadt Exp $	*/
d179 1
d208 1
@


1.149
log
@Delete non-ELF support, in particular .align 12 (always a bit jarring)
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.148 2014/11/23 00:25:05 guenther Exp $	*/
d401 1
@


1.148
log
@Make sure the direction bit is cleared on entry to the kernel by syscall
or interrupt, as specified by the ABIs.  Our current gcc doesn't assume
this bit of the ABI, but future compilers may and some ASM can be
simplified by assuming it.

in snaps for a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.147 2013/06/13 02:26:53 deraadt Exp $	*/
a186 1
#ifdef __ELF__
a187 3
#else
	.align 12
#endif
@


1.147
log
@bcopy/memmove/memcpy are now in libkern
tested by various
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.146 2013/06/09 12:42:22 tedu Exp $	*/
d107 1
@


1.146
log
@the kernel is supposed to provide memmove, but some archs are missing it.
add i386 sparc and sparc64. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.145 2012/11/18 12:17:40 sf Exp $	*/
a781 62
/*
 * bcopy(caddr_t from, caddr_t to, size_t len);
 * Copy len bytes.
 */
ALTENTRY(ovbcopy)
ENTRY(bcopy)
	pushl	%esi
	pushl	%edi
	movl	12(%esp),%esi
	movl	16(%esp),%edi
docopy:
	movl	20(%esp),%ecx
	movl	%edi,%eax
	subl	%esi,%eax
	cmpl	%ecx,%eax		# overlapping?
	jb	1f
	cld				# nope, copy forward
	shrl	$2,%ecx			# copy by 32-bit words
	rep
	movsl
	movl	20(%esp),%ecx
	andl	$3,%ecx			# any bytes left?
	rep
	movsb
	popl	%edi
	popl	%esi
	ret

	ALIGN_TEXT
1:	addl	%ecx,%edi		# copy backward
	addl	%ecx,%esi
	std
	andl	$3,%ecx			# any fractional bytes?
	decl	%edi
	decl	%esi
	rep
	movsb
	movl	20(%esp),%ecx		# copy remainder by 32-bit words
	shrl	$2,%ecx
	subl	$3,%esi
	subl	$3,%edi
	rep
	movsl
	popl	%edi
	popl	%esi
	cld
	ret

/*
 * Emulate memmove() by loading the first two arguments in reverse order
 * and jumping into bcopy(), which handles overlapping regions.
 * memcpy() is not guaranteed to have this guarantee, but it's safe
 * to offer it (if a bit slower).
 */
ALTENTRY(memcpy)
ENTRY(memmove)
	pushl	%esi
	pushl	%edi
	movl	12(%esp),%edi
	movl	16(%esp),%esi
	jmp	docopy

@


1.145
log
@Small memcpy optimizations

On x86, the xchg operation between reg and mem has an implicit lock
prefix, i.e. on MP, it is a relatively expensive atomic operation.
This is not needed here.
Instead of swapping arguments on the stack, load them in reverse order
and jump further into bcopy (idea by kettenis@@).

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.144 2012/11/10 09:45:05 mglocker Exp $	*/
d831 4
a834 2
 * Emulate memcpy() by loading the first two arguments in reverse order
 * and jumping into bcopy()
d836 2
a837 1
ENTRY(memcpy)
@


1.144
log
@Recent x86 CPUs come with a constant time stamp counter.  If this is
the case we verify if the CPU supports a specific version of the
architectural performance monitoring feature and read out the current
frequency from the fixed-function performance counter of the unhalted
core.

My initial motivation to implement this was the Soekris net6501-70
which comes with an Intel Atom E6xx 1.60GHz CPU.  It has a constant
time stamp counter plus speed step support and boots on the lowest
frequency of 600MHz.  This caused hw.cpuspeed and hw.setperf to
reflect the wrong values.

The diff is a cooperation work with jsg@@.  The fixed-function
performance counter read code comes from a former diff of him.

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.143 2012/10/31 03:30:22 jsg Exp $	*/
d792 1
d831 2
a832 1
 * Emulate memcpy() by swapping the first two arguments and calling bcopy()
d835 5
a839 4
	movl	4(%esp),%ecx
	xchg	8(%esp),%ecx
	movl	%ecx,4(%esp)
	jmp	_C_LABEL(bcopy)
@


1.143
log
@Add support for Intel's Supervisor Mode Access Prevention (SMAP) feature.
When enabled SMAP will generate page faults on the kernel attempting
to read/write user data pages unless an override flag is set.

Instructions that modify the flag are patched into copyin/copyout and
friends on boot if SMAP is enabled.

Those with access to hardware with SMAP can contact me for a test case.

joint work with deraadt@@

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.142 2012/09/25 09:58:57 pirofti Exp $	*/
d173 4
d220 4
d426 6
d461 4
@


1.142
log
@Remove unused acpi locking code.

To be replaced with higher level C routines once we settle for a common
consistent set of atomic operations across platforms.

Discussed with and okay by deraadt@@ and kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.141 2011/11/02 23:53:44 jsg Exp $	*/
d68 11
d831 1
d860 2
d874 2
d889 1
d900 2
d929 2
d941 1
d943 2
d962 1
d977 2
d1021 1
d1031 2
d1072 1
d1077 2
d1690 1
d1709 2
d1715 2
d1731 8
@


1.141
log
@display AMD/extended (0x80000001) cpuid flags and remove the
Cyrix 3DNOW flag from normal cpuid flags as it will show up in
extended flags.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.140 2011/10/12 18:30:09 miod Exp $	*/
a1650 28
	ret
#endif

#if NACPI > 0
ENTRY(acpi_acquire_global_lock)
	movl	4(%esp), %ecx
1:	movl	(%ecx), %eax
	movl	%eax, %edx
	andl	$~1, %edx
	btsl	$1, %edx
	adcl	$0, %edx
	lock
	cmpxchgl	%edx, (%ecx)
	jnz	1b
	andl	$3, %edx
	cmpl	$3, %edx
	sbb	%eax, %eax
	ret

ENTRY(acpi_release_global_lock)
	movl	4(%esp), %ecx
1:	movl	(%ecx), %eax
	movl	%eax, %edx
	andl	$~3, %edx
	lock
	cmpxchgl	%edx, (%ecx)
	jnz	1b
	andl	$1, %eax
@


1.140
log
@Remove all MD diagnostics in cpu_switchto(), and move them to MI code if
they apply.

ok oga@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.139 2011/07/09 01:49:16 pirofti Exp $	*/
d159 1
d197 3
a199 1
_C_LABEL(cpu_ecxfeature):.long	0	# extended feature flags from 'cpuid'
d413 4
@


1.139
log
@Add an atomic compare and exchange operation dealing with addresses
from userland for i386.

Okay art@@, assembly okay mlarkin@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.138 2011/07/08 21:11:20 pirofti Exp $	*/
a1162 15
#ifdef DIAGNOSTIC
NENTRY(switch_error1)
	pushl	%edi
	pushl	$1f
	call	_C_LABEL(panic)
	/* NOTREACHED */
1:	.asciz	"cpu_switch1 %p"
NENTRY(switch_error2)
	pushl	%edi
	pushl	$1f
	call	_C_LABEL(panic)
	/* NOTREACHED */
1:	.asciz	"cpu_switch2 %p"
#endif /* DIAGNOSTIC */

a1174 8

#ifdef	DIAGNOSTIC
	xorl	%eax, %eax
	cmpl	%eax,P_WCHAN(%edi)	# Waiting for something?
	jne	_C_LABEL(switch_error1)	# Yes; shouldn't be queued.
	cmpb	$SRUN,P_STAT(%edi)	# In run state?
	jne	_C_LABEL(switch_error2)	# No; shouldn't be queued.
#endif /* DIAGNOSTIC */
@


1.138
log
@Remove useless labels from copyin and copyout.

Noticed by matthew@@, `go for it' guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.137 2011/07/05 00:30:10 deraadt Exp $	*/
d1697 34
@


1.137
log
@Remove the osyscall() kernel-entry; we do not use it anymore.
ok kettenis guenther tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.136 2011/07/04 22:53:53 tedu Exp $	*/
d839 1
a839 1
3:	GET_CURPCB(%edx)
d892 1
a892 1
3:	/* bcopy(%esi, %edi, %eax); */
@


1.136
log
@remove compat_svr4 support.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.135 2011/05/10 11:11:56 kettenis Exp $	*/
a1508 15
 * Old call gate entry for syscall
 */
IDTVEC(osyscall)
	/* Set eflags in trap frame. */
	pushfl
	popl	8(%esp)
	/* Turn off trace flag and nested task. */
	pushfl
	andb	$~((PSL_T|PSL_NT)>>8),1(%esp)
	popfl
	pushl	$7		# size of instruction for restart
	jmp	syscall1
IDTVEC(osyscall_end)

/*
a1512 1
syscall1:
@


1.135
log
@Fix deadlock (re)introduced by the previous commit by explicitly re-enabling
interrupts in the code that cleans up after we fault during return to user
mode.  Handling traps with interrupts blocked is *not* ok!

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.134 2011/04/27 11:30:53 bluhm Exp $	*/
a49 3
#ifdef COMPAT_SVR4
#include <compat/svr4/svr4_syscall.h>
#endif
a644 16

#ifdef COMPAT_SVR4
NENTRY(svr4_sigcode)
	call	*SVR4_SIGF_HANDLER(%esp)
	leal	SVR4_SIGF_UC(%esp),%eax	# ucp (the call may have clobbered the
					# copy at SIGF_UCP(%esp))
	pushl	%eax
	pushl	$1			# setcontext(p) == syscontext(1, p)
	pushl	%eax			# junk to fake return address
	movl	$SVR4_SYS_context,%eax
	int	$0x80			# enter kernel with args on stack
	movl	$SVR4_SYS_exit,%eax
	int	$0x80			# exit if sigreturn fails
	.globl	_C_LABEL(svr4_esigcode)
_C_LABEL(svr4_esigcode):
#endif
@


1.134
log
@Do not explicitly enable interrupts before returning from interrupt.
This fixes possible stack overflows under high interrupt load.  Note
that this allows traps on kernel code to run with interrupts blocked.
From Christian Ehrhardt
ok guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.133 2011/04/23 22:16:13 deraadt Exp $	*/
d1464 1
d1480 1
@


1.133
log
@Don't leave the kernel code/rodata writeable for DDB.  Make ddb enable
writes in the pte momentarily.  Modified the code stolen from amd64.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.132 2011/04/05 12:50:15 guenther Exp $	*/
a128 1
	sti			; \
@


1.132
log
@Push COMPAT_FREEBSD in front of a whale.  Buggy, out of date, no
one has been weeding it, and it makes life harder.

Toasts of Brennivin for its passing from many; diff ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.131 2011/03/12 03:52:26 guenther Exp $	*/
a530 3
#ifdef DDB
	orl	$(PG_V|PG_KW),%eax
#else
a531 1
#endif
@


1.131
log
@Provide distinct segments for the %fs and %gs selectors to use by
default, with per-rthread base offsets and with sysarch() functions,
I386_{GET,SET}_{FS,GS}BASE, for fetching and setting those base
offsets.  This is necessary for both rthread and Linux compat support.

suggestions from kettenis@@, prodding from pirofti@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.130 2010/07/03 04:54:32 kettenis Exp $	*/
a55 3
#ifdef COMPAT_FREEBSD
#include <compat/freebsd/freebsd_syscall.h>
#endif
a686 20
#endif

/*****************************************************************************/

#ifdef COMPAT_FREEBSD
/*
 * Signal trampoline; copied to top of user stack.
 */
NENTRY(freebsd_sigcode)
	call	*FREEBSD_SIGF_HANDLER(%esp)
	leal	FREEBSD_SIGF_SC(%esp),%eax # scp (the call may have clobbered
					# the copy at SIGF_SCP(%esp))
	pushl	%eax
	pushl	%eax			# junk to fake return address
	movl	$FREEBSD_SYS_sigreturn,%eax
	int	$0x80			# enter kernel with args on stack
	movl	$FREEBSD_SYS_exit,%eax
	int	$0x80			# exit if sigreturn fails
	.globl	_C_LABEL(freebsd_esigcode)
_C_LABEL(freebsd_esigcode):
@


1.130
log
@Make the kernel responsible for saving the FPU state before running
signal handlers.  Breaks ABI for applications that copy around struct
sigcontext to implement cooperative threading.  Other applications
shoouldn't notice the difference.

ok guenther@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.129 2010/05/09 12:03:16 kettenis Exp $	*/
d115 1
d1499 1
a1499 1
	movl	$GSEL(GDATA_SEL, SEL_KPL),%eax
@


1.129
log
@Make i386 use a pointer to the trap frame like everybody else instead of
the weird "pass by reference" that causes problems with gcc4.

ok nicm@@, tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.128 2009/07/10 13:51:47 jsg Exp $	*/
d642 2
a643 23
	movl	SIGF_FPSTATE(%esp),%esi	# FPU state area if need saving
	testl	%esi,%esi
	jz	1f
	fnsave	(%esi)
1:	call	*SIGF_HANDLER(%esp)
	testl	%esi,%esi
	jz	2f
	frstor	(%esi)
	jmp	2f

	.globl  _C_LABEL(sigcode_xmm)
_C_LABEL(sigcode_xmm):
	movl	SIGF_FPSTATE(%esp),%esi	# FPU state area if need saving
	testl	%esi,%esi
	jz	1f
	fxsave	(%esi)
	fninit
1:	call	*SIGF_HANDLER(%esp)
	testl	%esi,%esi
	jz	2f
	fxrstor	(%esi)

2:	leal	SIGF_SC(%esp),%eax	# scp (the call may have clobbered the
@


1.128
log
@Switch away from using -traditional-cpp to iso/ansi cpp for asm files.
More architectures hopefully to follow.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.127 2009/06/03 00:49:12 art Exp $	*/
d1535 1
d1537 1
d1551 1
d1553 1
d1596 1
d1598 1
d1607 1
d1609 1
@


1.127
log
@Just like on amd64. Instead of keeping a bitmap of which cpus a pmap
is active on, save a curpmap pointer in cpu_info. This lets us simplify
a few things and do lazy context switching from a user process to a
kernel thread. There's a new IPI introduced for forcing a cr3 reload
when we're tearing down a dead pmap.

kettenis@@ ok (after I polished a few minor things)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.126 2009/06/03 00:41:48 weingart Exp $	*/
d1393 1
a1393 1
#define	IDTVEC(name)	ALIGN_TEXT; .globl X/**/name; X/**/name:
@


1.126
log
@Nuke CYRIX_CACHE (and related defines).  They've not been used in a long
time.  Beginning of refactoring cpu identification.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.125 2009/01/17 23:44:46 guenther Exp $	*/
a87 3
#define	SET_CURPCB(reg)					\
	movl	reg, CPUVAR(CURPCB)

d1270 4
a1273 18
	/*
	 * Save old context.
	 *
	 * Registers:
	 *   %eax, %ecx - scratch
	 *   %esi - old process, then old pcb
	 *   %edi - new process
	 */

	pushl	%esi
	call	_C_LABEL(pmap_deactivate)
	addl	$4,%esp

	movl	P_ADDR(%esi),%esi

	/* Save stack pointers. */
	movl	%esp,PCB_ESP(%esi)
	movl	%ebp,PCB_EBP(%esi)
d1276 1
a1276 8
	/*
	 * Third phase: restore saved context.
	 *
	 * Registers:
	 *   %eax, %ecx, %edx - scratch
	 *   %esi - new pcb
	 *   %edi - new process
	 */
a1281 1
	movl	CPUVAR(SELF), %ebx
a1283 1
	movl	%ebx, P_CPU(%edi)
d1285 4
a1288 1
	movl	P_ADDR(%edi),%esi
d1290 2
a1291 3
	/* Restore stack pointers. */
	movl	PCB_ESP(%esi),%esp
	movl	PCB_EBP(%esi),%ebp
d1299 4
a1302 3
	call	_C_LABEL(pmap_activate)
	addl	$4,%esp
	
d1312 1
a1312 1
	movl	PCB_CR0(%esi),%ecx
d1318 2
a1319 2
	movl	CPUVAR(SELF), %ebx
	cmpl	PCB_FPCPU(%esi),%ebx
a1324 3

	/* Record new pcb. */
	SET_CURPCB(%esi)
@


1.125
log
@gdt_compact() was removed years ago, so kill the code and comments
that worked around its presence

ok'ed by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.124 2008/07/28 19:08:46 miod Exp $	*/
a365 1
#ifndef CYRIX_CACHE_WORKS
a377 43
#else /* CYRIX_CACHE_WORKS */
	/* Set cache parameters */
	invd				# Start with guaranteed clean cache
	movb	$CCR0,%al		# Configuration Register index (CCR0)
	outb	%al,$0x22
	inb	$0x23,%al
	andb	$~CCR0_NC0,%al
#ifndef CYRIX_CACHE_REALLY_WORKS
	orb	$(CCR0_NC1|CCR0_BARB),%al
#else
	orb	$CCR0_NC1,%al
#endif
	movb	%al,%ah
	movb	$CCR0,%al
	outb	%al,$0x22
	movb	%ah,%al
	outb	%al,$0x23
	/* clear non-cacheable region 1	*/
	movb	$(NCR1+2),%al
	outb	%al,$0x22
	movb	$NCR_SIZE_0K,%al
	outb	%al,$0x23
	/* clear non-cacheable region 2	*/
	movb	$(NCR2+2),%al
	outb	%al,$0x22
	movb	$NCR_SIZE_0K,%al
	outb	%al,$0x23
	/* clear non-cacheable region 3	*/
	movb	$(NCR3+2),%al
	outb	%al,$0x22
	movb	$NCR_SIZE_0K,%al
	outb	%al,$0x23
	/* clear non-cacheable region 4	*/
	movb	$(NCR4+2),%al
	outb	%al,$0x22
	movb	$NCR_SIZE_0K,%al
	outb	%al,$0x23
	/* enable caching in CR0 */
	movl	%cr0,%eax
	andl	$~(CR0_CD|CR0_NW),%eax
	movl	%eax,%cr0
	invd
#endif /* CYRIX_CACHE_WORKS */
@


1.124
log
@No longer clear ci_want_resched within cpu_switchto(), now that it's done
in the MI code.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.123 2008/06/09 20:43:43 miod Exp $	*/
d1362 3
a1364 4
	 * Activate the address space.  We're curproc, so %cr3 will
	 * be reloaded, but we're not yet curpcb, so the LDT won't
	 * be reloaded, although the PCB copy of the selector will
	 * be refreshed from the pmap.
a1376 12

#ifdef USER_LDT
	/*
	 * Switch LDT.
	 *
	 * XXX
	 * Always do this, because the LDT could have been swapped into a
	 * different selector after a process exited.  (See gdt_compact().)
	 */
	movl	PCB_LDT_SEL(%esi),%edx
	lldt	%dx
#endif /* USER_LDT */
@


1.123
log
@Remove fillw(). Bonus points if you do not remember what it was used for.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.122 2008/03/22 16:25:08 weingart Exp $	*/
d1305 1
a1306 4

	movl	%eax, CPUVAR(RESCHED)

#ifdef	DIAGNOSTIC
@


1.122
log
@Quick comment fixups.

ok deraadt@@, kettenis@@, brad@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.121 2007/11/28 17:05:09 tedu Exp $	*/
a783 24

/*
 * fillw(short pattern, caddr_t addr, size_t len);
 * Write len copies of pattern at addr.
 */
ENTRY(fillw)
	pushl	%edi
	movl	8(%esp),%eax
	movl	12(%esp),%edi
	movw	%ax,%cx
	rorl	$16,%eax
	movw	%cx,%ax
	cld
	movl	16(%esp),%ecx
	shrl	%ecx			# do longwords
	rep
	stosl
	movl	16(%esp),%ecx
	andl	$1,%ecx			# do remainder
	rep
	stosw
	popl	%edi
	ret

@


1.121
log
@quite a bit of simplification by removing cpu classes.
also assume that 386 cpus are really unknown, and promote them to 486
instead of panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.120 2007/11/05 21:46:13 weingart Exp $	*/
d604 1
a604 1
*/
d670 1
@


1.120
log
@I screwed the pooch.  Fix the stack offsets.

"That's much better." kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.119 2007/11/03 03:37:08 weingart Exp $	*/
a1561 1
#ifdef I586_CPU
a1572 1
#endif
a1744 2
#if defined(I486_CPU)
#if defined(I586_CPU) || defined(I686_CPU)
a1746 1
#endif
a1770 1
#endif
d1785 1
a1785 1
#if defined(I686_CPU) && !defined(SMALL_KERNEL)
@


1.119
log
@APM switchto cleanup diff.  This uses the switchto functionality to
significantly clean up the APM idle loop things.  I actually can make
sense of what the APM idle loop is supposed to do.

Ok gwk@@, beck@@, and theo says ramdisks compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.118 2007/11/03 03:06:21 weingart Exp $	*/
d1860 1
a1860 1
	movl	8(%esp), %ecx
d1875 1
a1875 1
	movl	8(%esp), %ecx
@


1.118
log
@Add acpi_acquire_global_lock() and acpi_release_global_lock() in MD locore.s
because it is easier to write these here in asm than it is to put them inline
with gcc's __asm() construct.  Also, chances are amd64's versions will need
to be written in a different manner.

Basically yanked from ACPI spec V3, section 5.2.10.1.

Ok canacar@@, beck@@, gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.117 2007/10/24 17:56:58 mikeb Exp $	*/
d1444 5
d1452 6
a1457 3
#if NAPM > 0
	call	_C_LABEL(apm_cpu_idle)
#else
a1459 1
#endif
d1463 5
@


1.117
log
@Remove idle loop counter.

ok art deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.116 2007/10/10 15:53:51 art Exp $	*/
d46 1
d1843 28
@


1.116
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.115 2007/10/03 07:51:26 kettenis Exp $	*/
a1448 4
#if NPCTR > 0
	addl	$1,_C_LABEL(pctr_idlcnt)
	adcl	$0,_C_LABEL(pctr_idlcnt)+4
#endif
@


1.115
log
@Add pcb_flags member to 'struct pcb', and set PCB_SAVECTX on contexts saved
by savectx().

ok art@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.114 2007/05/29 23:02:02 tom Exp $	*/
d1298 1
a1298 16

/*
 * The following primitives manipulate the run queues.
 * whichqs tells which of the 32 queues qs have processes in them.
 * Setrq puts processes into queues, Remrq removes them from queues.
 * The running process is on no queue, other processes are on a queue
 * related to p->p_pri, divided by 4 actually to shrink the 0-127 range
 * of priorities into the 32 available queues.
 */
	.globl	_C_LABEL(whichqs),_C_LABEL(qs),_C_LABEL(uvmexp),_C_LABEL(panic)
/*
 * setrunqueue(struct proc *p);
 * Insert a process on the appropriate queue.  Should be called at splclock().
 */
NENTRY(setrunqueue)
	movl	4(%esp),%eax
d1300 3
a1302 19
	cmpl	$0,P_BACK(%eax)	# should not be on q already
	jne	1f
	cmpl	$0,P_WCHAN(%eax)
	jne	1f
	cmpb	$SRUN,P_STAT(%eax)
	jne	1f
#endif /* DIAGNOSTIC */
	movzbl	P_PRIORITY(%eax),%edx
	shrl	$2,%edx
	btsl	%edx,_C_LABEL(whichqs)		# set q full bit
	leal	_C_LABEL(qs)(,%edx,8),%edx	# locate q hdr
	movl	P_BACK(%edx),%ecx
	movl	%edx,P_FORW(%eax)	# link process on tail of q
	movl	%eax,P_BACK(%edx)
	movl	%eax,P_FORW(%ecx)
	movl	%ecx,P_BACK(%eax)
	ret
#ifdef DIAGNOSTIC
1:	pushl	$2f
d1305 3
a1307 143
2:	.asciz	"setrunqueue"
#endif /* DIAGNOSTIC */

/*
 * remrunqueue(struct proc *p);
 * Remove a process from its queue.  Should be called at splclock().
 */
NENTRY(remrunqueue)
	movl	4(%esp),%ecx
	movzbl	P_PRIORITY(%ecx),%eax
#ifdef DIAGNOSTIC
	shrl	$2,%eax
	btl	%eax,_C_LABEL(whichqs)
	jnc	1f
#endif /* DIAGNOSTIC */
	movl	P_BACK(%ecx),%edx	# unlink process
	movl	$0,P_BACK(%ecx)		# zap reverse link to indicate off list
	movl	P_FORW(%ecx),%ecx
	movl	%ecx,P_FORW(%edx)
	movl	%edx,P_BACK(%ecx)
	cmpl	%ecx,%edx		# q still has something?
	jne	2f
#ifndef DIAGNOSTIC
	shrl	$2,%eax
#endif
	btrl	%eax,_C_LABEL(whichqs)		# no; clear bit
2:	ret
#ifdef DIAGNOSTIC
1:	pushl	$3f
	call	_C_LABEL(panic)
	/* NOTREACHED */
3:	.asciz	"remrunqueue"
#endif /* DIAGNOSTIC */

#if NAPM > 0
	.globl _C_LABEL(apm_cpu_idle),_C_LABEL(apm_cpu_busy)
#endif
/*
 * When no processes are on the runq, cpu_switch() branches to here to wait for
 * something to come ready.
 */
ENTRY(idle)
	/* Skip context saving if we have none. */
	testl %esi,%esi
	jz	1f

	/*
	 * idling:	save old context.
	 *
	 * Registers:
	 *   %eax, %ebx, %ecx - scratch
	 *   %esi - old proc, then old pcb
	 *   %edi - idle pcb
	 *   %edx - idle TSS selector
	 */

	pushl	%esi
	call	_C_LABEL(pmap_deactivate)	# pmap_deactivate(oldproc)
	addl	$4,%esp

	movl	P_ADDR(%esi),%esi

	/* Save stack pointers. */
	movl	%esp,PCB_ESP(%esi)
	movl	%ebp,PCB_EBP(%esi)

	/* Find idle PCB for this CPU */
#ifndef MULTIPROCESSOR
	movl	$_C_LABEL(proc0),%ebx
	movl	P_ADDR(%ebx),%edi
	movl	P_MD_TSS_SEL(%ebx),%edx
#else
	movl	CPUVAR(IDLE_PCB), %edi
	movl	CPUVAR(IDLE_TSS_SEL), %edx
#endif

	/* Restore the idle context (avoid interrupts) */
	cli

	/* Restore stack pointers. */
	movl	PCB_ESP(%edi),%esp
	movl	PCB_EBP(%edi),%ebp


	/* Switch address space. */
	movl	PCB_CR3(%edi),%ecx
	movl	%ecx,%cr3

	/* Switch TSS. Reset "task busy" flag before loading. */
	movl	CPUVAR(GDT), %eax
	andl	$~0x0200,4-SEL_KPL(%eax,%edx,1)
	ltr	%dx

	/* We're always in the kernel, so we don't need the LDT. */

	/* Restore cr0 (including FPU state). */
	movl	PCB_CR0(%edi),%ecx
	movl	%ecx,%cr0

	/* Record new pcb. */
	SET_CURPCB(%edi)

	xorl	%esi,%esi
	sti

1:
#if defined(MULTIPROCESSOR) || defined(LOCKDEBUG)	
	call	_C_LABEL(sched_unlock_idle)
#endif

	movl	$IPL_NONE,CPL		# spl0()
	call	_C_LABEL(Xspllower)	# process pending interrupts
	jmp	_C_LABEL(idle_start)

ENTRY(idle_loop)
#if NAPM > 0
	call	_C_LABEL(apm_cpu_idle)
#else
#if NPCTR > 0
	addl	$1,_C_LABEL(pctr_idlcnt)
	adcl	$0,_C_LABEL(pctr_idlcnt)+4
#endif
	sti
	hlt
#endif
ENTRY(idle_start)
	cli
	cmpl	$0,_C_LABEL(whichqs)
	jz	_C_LABEL(idle_loop)

ENTRY(idle_exit)
	movl	$IPL_HIGH,CPL		# splhigh
	sti
#if defined(MULTIPROCESSOR) || defined(LOCKDEBUG)	
	call	_C_LABEL(sched_lock_idle)
#endif
#if NAPM > 0
	call	_C_LABEL(apm_cpu_busy)
#endif
	jmp	switch_search
		
#ifdef DIAGNOSTIC
NENTRY(switch_error)
d1311 1
a1311 1
1:	.asciz	"cpu_switch"
d1315 3
a1317 4
 * cpu_switch(void);
 * Find a runnable process and switch to it.  Wait if necessary.  If the new
 * process is the same as the old one, we short-circuit the context save and
 * restore.
d1319 1
a1319 1
ENTRY(cpu_switch)
a1322 1
	pushl	CPL
d1324 2
a1325 1
	movl	CPUVAR(CURPROC), %esi
d1327 1
a1327 21
	/*
	 * Clear curproc so that we don't accumulate system time while idle.
	 * This also insures that schedcpu() will move the old process to
	 * the correct queue if it happens to get called from the spllower()
	 * below and changes the priority.  (See corresponding comment in
	 * userret()).
	 */
	movl	$0, CPUVAR(CURPROC)

switch_search:
	/*
	 * First phase: find new process.
	 *
	 * Registers:
	 *   %eax - queue head, scratch, then zero
	 *   %ebx - queue number
	 *   %ecx - cached value of whichqs
	 *   %edx - next process in queue
	 *   %esi - old process
	 *   %edi - new process
	 */
d1329 1
a1329 23
	/* Wait for new process. */
	movl	_C_LABEL(whichqs),%ecx
	bsfl	%ecx,%ebx		# find a full q
	jz	_C_LABEL(idle)		# if none, idle
	leal	_C_LABEL(qs)(,%ebx,8),%eax	# select q
	movl	P_FORW(%eax),%edi	# unlink from front of process q
#ifdef	DIAGNOSTIC
	cmpl	%edi,%eax		# linked to self (i.e. nothing queued)?
	je	_C_LABEL(switch_error)	# not possible
#endif /* DIAGNOSTIC */
	movl	P_FORW(%edi),%edx
	movl	%edx,P_FORW(%eax)
	movl	%eax,P_BACK(%edx)

	cmpl	%edx,%eax		# q empty?
	jne	3f

	btrl	%ebx,%ecx		# yes, clear to indicate empty
	movl	%ecx,_C_LABEL(whichqs)	# update q status

3:	xorl	%eax, %eax
	/* We just did it. */
	movl	$0, CPUVAR(RESCHED)
d1333 1
a1333 1
	jne	_C_LABEL(switch_error)	# Yes; shouldn't be queued.
d1335 1
a1335 1
	jne	_C_LABEL(switch_error)	# No; shouldn't be queued.
a1337 13
	/* Isolate process.  XXX Is this necessary? */
	movl	%eax,P_BACK(%edi)

	/* Record new process. */
	movb	$SONPROC,P_STAT(%edi)	# p->p_stat = SONPROC
	movl	CPUVAR(SELF), %ecx
	movl	%edi, CPUVAR(CURPROC)
	movl	%ecx, P_CPU(%edi)

	/* Skip context switch if same process. */
	cmpl	%edi,%esi
	je	switch_return

d1343 1
a1343 1
	 * Second phase: save old context.
d1373 7
a1385 6
#if 0
	/* Don't bother with the rest if switching to a system process. */
	testl	$P_SYSTEM,P_FLAG(%edi)
	jnz	switch_restored
#endif

a1415 1
switch_restored:
a1436 20
switch_return:
#if 0
	pushl	%edi
	movl	CPUVAR(NAME), %ebx
	leal	CPU_INFO_NAME(%ebx),%ebx
	pushl	%ebx
	pushl	$1f
	call	_C_LABEL(printf)
	addl	$0xc,%esp
#endif
#if defined(MULTIPROCESSOR) || defined(LOCKDEBUG)
	call    _C_LABEL(sched_unlock_idle)
#endif
	/*
	 * Restore old cpl from stack.  Note that this is always an increase,
	 * due to the spl0() on entry.
	 */
	popl	CPL

	movl	%edi,%eax		# return (p);
d1441 7
a1447 16
1:	.asciz	"%s: scheduled %x\n"
/*
 * switch_exit(struct proc *p);
 * Switch to the appropriate idle context (proc0's if uniprocessor; the cpu's if
 * multiprocessor) and deallocate the address space and kernel stack for p.
 * Then jump into cpu_switch(), as if we were in the idle proc all along.
 */
#ifndef MULTIPROCESSOR
	.globl	_C_LABEL(proc0)
#endif
ENTRY(switch_exit)
	movl	4(%esp),%edi		# old process
#ifndef MULTIPROCESSOR
	movl	$_C_LABEL(proc0),%ebx
	movl	P_ADDR(%ebx),%esi
	movl	P_MD_TSS_SEL(%ebx),%edx
d1449 3
a1451 2
	movl	CPUVAR(IDLE_PCB), %esi
	movl	CPUVAR(IDLE_TSS_SEL), %edx
a1452 40

	/* In case we fault... */
	movl	$0, CPUVAR(CURPROC)

	/* Restore the idle context. */
	cli

	/* Restore stack pointers. */
	movl	PCB_ESP(%esi),%esp
	movl	PCB_EBP(%esi),%ebp

	/* Load TSS info. */
	movl	CPUVAR(GDT), %eax

	/* Switch address space. */
	movl	PCB_CR3(%esi),%ecx
	movl	%ecx,%cr3

	/* Switch TSS. */
	andl	$~0x0200,4-SEL_KPL(%eax,%edx,1)
	ltr	%dx

	/* We're always in the kernel, so we don't need the LDT. */

	/* Clear segment registers; always null in proc0. */
	xorl	%ecx,%ecx
	movw	%cx,%gs

	/* Point to cpu_info */
	movl	$GSEL(GCPU_SEL, SEL_KPL),%ecx
	movw	%cx,%fs

	/* Restore cr0 (including FPU state). */
	movl	PCB_CR0(%esi),%ecx
	movl	%ecx,%cr0

	/* Record new pcb. */
	SET_CURPCB(%esi)

	/* Interrupts are okay again. */
d1454 3
d1458 2
a1459 11
	/*
	 * Schedule the dead process's vmspace and stack to be freed.
	 */
	pushl	%edi			/* exit2(p) */
	call	_C_LABEL(exit2)
	addl	$4,%esp

	/* Jump into cpu_switch() with the right state. */
	xorl	%esi,%esi
	movl	$0, CPUVAR(CURPROC)
	jmp	switch_search
@


1.114
log
@Improve copyinstr and copyoutstr by performing the check against
VM_MAXUSER_ADDRESS before running the loop rather than for every
byte we copy.  Saves 4 bytes in locore :)

Similar to how this is done on amd64.

ok weingart@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.113 2007/05/29 18:18:20 tom Exp $	*/
d1772 4
@


1.113
log
@Remove support for 80386 processors.  Apologies if you have one of
the rare 80386-bases system with enough memory, a 387 FPU, a useable
disk subsystem, and the patience to wait for it to unpack the
distribution .tgz files.

approval from art@@ and many others (esp. nick@@); ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.112 2007/05/27 21:35:36 tom Exp $	*/
d1086 4
a1099 2
	cmpl	$VM_MAXUSER_ADDRESS,%edi
	jae	_C_LABEL(copystr_fault)
d1142 3
a1154 2
	cmpl    $VM_MAXUSER_ADDRESS,%esi
	jae     _C_LABEL(copystr_fault)
@


1.112
log
@Locore UP can use the same code as MULTIPROCESSOR to access the GDT
once we're up and running; similar to what was just committed for
machdep.c and pmap.c.

ok art@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.111 2007/05/27 18:34:01 art Exp $	*/
a974 52
#if defined(I386_CPU)
#if defined(I486_CPU) || defined(I586_CPU) || defined(I686_CPU)
	cmpl	$CPUCLASS_386,_C_LABEL(cpu_class)
	jne	3f
#endif /* I486_CPU || I586_CPU || I686_CPU */

	testl	%eax,%eax		# anything to do?
	jz	3f

	/*
	 * We have to check each PTE for (write) permission, since the CPU
	 * doesn't do it for us.
	 */

	/* Compute number of pages. */
	movl	%edi,%ecx
	andl	$PGOFSET,%ecx
	addl	%eax,%ecx
	decl	%ecx
	shrl	$PGSHIFT,%ecx

	/* Compute PTE offset for start address. */
	shrl	$PGSHIFT,%edi

	GET_CURPCB(%edx)
	movl	$2f, PCB_ONFAULT(%edx)

1:	/* Check PTE for each page. */
	testb	$PG_RW,_C_LABEL(PTmap)(,%edi,4)
	jz	2f

4:	incl	%edi
	decl	%ecx
	jns	1b

	movl	20+FPADD(%esp),%edi
	movl	24+FPADD(%esp),%eax
	jmp	3f

2:	/* Simulate a trap. */
	pushl	%ecx
	movl	%edi,%eax
	shll	$PGSHIFT,%eax
	pushl	%eax
	call	_C_LABEL(trapwrite)	# trapwrite(addr)
	addl	$4,%esp			# pop argument
	popl	%ecx
	testl	%eax,%eax		# if not ok, return EFAULT
	jz	4b
	jmp	_C_LABEL(copy_fault)
#endif /* I386_CPU */

a1078 67
#if defined(I386_CPU)
#if defined(I486_CPU) || defined(I586_CPU) || defined(I686_CPU)
	cmpl	$CPUCLASS_386,_C_LABEL(cpu_class)
	jne	5f
#endif /* I486_CPU || I586_CPU || I686_CPU */

	/* Compute number of bytes in first page. */
	movl	%edi,%eax
	andl	$PGOFSET,%eax
	movl	$NBPG,%ecx
	subl	%eax,%ecx		# ecx = NBPG - (src % NBPG)

	GET_CURPCB(%ecx)
	movl	$6f, PCB_ONFAULT(%ecx)

1:	/*
	 * Once per page, check that we are still within the bounds of user
	 * space, and check for a write fault.
	 */
	cmpl	$VM_MAXUSER_ADDRESS,%edi
	jae	_C_LABEL(copystr_fault)

	/* Compute PTE offset for start address. */
	movl	%edi,%eax
	shrl	$PGSHIFT,%eax		# calculate pte address

	testb	$PG_RW,_C_LABEL(PTmap)(,%eax,4)
	jnz	2f

6:	/* Simulate a trap. */
	pushl	%edx
	pushl	%edi
	call	_C_LABEL(trapwrite)	# trapwrite(addr)
	addl	$4,%esp			# clear argument from stack
	popl	%edx
	testl	%eax,%eax
	jnz	_C_LABEL(copystr_fault)

2:	/* Copy up to end of this page. */
	subl	%ecx,%edx		# predecrement total count
	jnc	3f
	addl	%edx,%ecx		# ecx += (edx - ecx) = edx
	xorl	%edx,%edx

3:	decl	%ecx
	js	4f
	lodsb
	stosb
	testb	%al,%al
	jnz	3b

	/* Success -- 0 byte reached. */
	addl	%ecx,%edx		# add back residual for this page
	xorl	%eax,%eax
	jmp	copystr_return

4:	/* Go to next page, if any. */
	movl	$NBPG,%ecx
	testl	%edx,%edx
	jnz	1b

	/* edx is zero -- return ENAMETOOLONG. */
	movl	$ENAMETOOLONG,%eax
	jmp	copystr_return
#endif /* I386_CPU */

#if defined(I486_CPU) || defined(I586_CPU) || defined(I686_CPU)
a1112 1
#endif /* I486_CPU || I586_CPU || I686_CPU */
d2033 1
a2033 1
#if defined(I386_CPU) || defined(I586_CPU) || defined(I686_CPU)
@


1.111
log
@We can now access curcpu() members through %fs instead of doing it
with the complicated and expensive macros.

tom@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.110 2007/05/26 22:09:17 weingart Exp $	*/
a1541 1
#ifdef MULTIPROCESSOR
a1542 3
#else
	movl	_C_LABEL(gdt),%eax
#endif
a1739 1
#ifdef MULTIPROCESSOR
a1740 3
#else
	movl	_C_LABEL(gdt),%eax
#endif
a1836 1
#ifdef MULTIPROCESSOR
a1837 3
#else
	movl	_C_LABEL(gdt),%eax
#endif
@


1.110
log
@Move cpu_info/curcpu to be mapped by the %fs segment.  Extra input and
debugging by tom@@, art@@, kettenis@@, and others.  Testing by many others.

ok art@@, kettenis@@, tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.109 2007/05/25 20:32:29 krw Exp $	*/
a83 29
#if defined(MULTIPROCESSOR)
#include <machine/i82489reg.h>

#define	GET_CPUINFO(reg)				\
	movl	_C_LABEL(lapic_id),reg	;		\
	shrl	$LAPIC_ID_SHIFT,reg	; 		\
	movl	_C_LABEL(cpu_info)(,reg,4),reg
#else
#define	GET_CPUINFO(reg)				\
	leal	_C_LABEL(cpu_info_primary),reg
#endif

#define	GET_CURPROC(reg, treg)				\
	GET_CPUINFO(treg)			;	\
	movl	CPU_INFO_CURPROC(treg),reg

#define	PUSH_CURPROC(treg)				\
	GET_CPUINFO(treg)			;	\
	pushl	CPU_INFO_CURPROC(treg)

#define	CLEAR_CURPROC(treg)				\
	GET_CPUINFO(treg)			;	\
	movl	$0,CPU_INFO_CURPROC(treg)

#define	SET_CURPROC(proc,cpu)				\
	GET_CPUINFO(cpu)			;	\
	movl	proc,CPU_INFO_CURPROC(cpu)	;	\
	movl	cpu,P_CPU(proc)

d85 1
a85 2
	GET_CPUINFO(reg)			;	\
	movl	CPU_INFO_CURPCB(reg),reg
d87 2
a88 8
#define	SET_CURPCB(reg,treg)				\
	GET_CPUINFO(treg)			;	\
	movl	reg,CPU_INFO_CURPCB(treg)

#define	CLEAR_RESCHED(treg)				\
	GET_CPUINFO(treg)			;	\
	xorl	%eax,%eax			;	\
	movl	%eax,CPU_INFO_RESCHED(treg)
d91 1
a91 2
	GET_CPUINFO(treg)			;	\
	movl	CPU_INFO_CURPROC(treg), treg	;	\
d1525 2
a1526 3
	GET_CPUINFO(%ebx)
	movl	CPU_INFO_IDLE_PCB(%ebx),%edi
	movl	CPU_INFO_IDLE_TSS_SEL(%ebx),%edx
d1543 1
a1543 1
	movl	CPU_INFO_GDT(%ebx),%eax
d1557 1
a1557 1
	SET_CURPCB(%edi,%ecx)
d1618 1
a1618 1
	GET_CURPROC(%esi,%ecx)
d1627 1
a1627 1
	CLEAR_CURPROC(%ecx)
d1662 3
a1664 2
3:	/* We just did it. */
	CLEAR_RESCHED(%ecx)
d1678 3
a1680 1
	SET_CURPROC(%edi,%ecx)
d1745 1
a1745 2
	GET_CPUINFO(%ebx)
	movl	CPU_INFO_GDT(%ebx),%eax
d1775 1
a1775 1
	GET_CPUINFO(%ebx)
d1784 1
a1784 1
	SET_CURPCB(%esi, %ecx)
d1792 1
a1792 1
	GET_CPUINFO(%ebx)
d1830 2
a1831 3
	GET_CPUINFO(%ebx)
	movl	CPU_INFO_IDLE_PCB(%ebx),%esi
	movl	CPU_INFO_IDLE_TSS_SEL(%ebx),%edx
d1835 1
a1835 1
	CLEAR_CURPROC(%ecx)
d1846 1
a1846 1
	movl	CPU_INFO_GDT(%ebx),%eax
d1874 1
a1874 1
	SET_CURPCB(%esi, %ecx)
d1888 1
a1888 1
	CLEAR_CURPROC(%ecx)
d1955 1
a1955 2
	GET_CPUINFO(%eax)
	pushl	%eax
@


1.109
log
@"boundries" -> "boundaries" in various comments. Started by Diego Casati.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.108 2007/04/13 11:16:08 art Exp $	*/
d300 1
a300 1
	/* Clear segment registers; always null in proc0. */
d1900 4
a1904 1
	movw	%cx,%gs
d2089 1
a2089 1
	movl	$GSEL(GDATA_SEL, SEL_KPL),%eax
@


1.108
log
@Move the proc0 stack below the proc0 page tables so that in case we
overflow the stack, we run into the symbol table (not critical) instead
of overwriting the page tables.

From mickey, ok art@@, ok toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.107 2007/04/03 10:14:47 art Exp $	*/
d2186 1
a2186 1
	 * of aligning to word boundries, etc.  So we jump to a plain
@


1.107
log
@Make the ast on i386 per-process instead of per-cpu. This makes
signal delivery more reliable in some cases when a process switches
cpu.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.106 2007/02/20 21:15:01 tom Exp $	*/
d537 2
a538 2
 * text | data | bss | [syms] | page dir | proc0 kstack | Sysmap
 *			      0          1       2      3
d540 2
a541 2
#define	PROC0PDIR	((0)		* NBPG)
#define	PROC0STACK	((1)		* NBPG)
d606 1
a606 1
	/* Skip over the first 1MB. */
d660 2
a661 1
	movl	%esi,RELOC(_C_LABEL(PTDpaddr))
a663 1
	movl	%esi,%eax		# phys address of ptd in proc 0
d693 2
a694 1
	movl	%esi,PCB_CR3(%eax)	# pcb->pcb_cr3
@


1.106
log
@Revert PAE pmap for now, until the strange bug is found.  This stops
the freezes many of us are seeing (especially on amd64 machines running
OpenBSD/i386).

Much testing by nick@@ (as always - thanks!), hugh@@, ian@@, kettenis@@
and Sam Smith (s (at) msmith (dot) net).

Requested by, input from, and ok deraadt@@  ok art@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.105 2006/12/08 21:35:05 dim Exp $	*/
d128 5
a132 1
	cmpl	$0,CPU_INFO_ASTPENDING(treg)
d134 2
a135 2
#define	CLEAR_ASTPENDING(cireg)				\
	movl	$0,CPU_INFO_ASTPENDING(cireg)
@


1.105
log
@Fix kernel link warning on i386 about boothowto being overridden, by
removing the second definition from locore.  To prevent locore from
subsequently clobbering boothowto, remove clearing bss from it.  The
bootloader has already taken care of this.

ok miod weingart deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.104 2006/11/26 15:13:21 dim Exp $	*/
a203 1
	.globl	_C_LABEL(nkptp_max)
d537 3
a539 3
#define	PROC0STACK	((4)		* NBPG)
#define	SYSMAP		((4+UPAGES)	* NBPG)
#define	TABLESIZE	((4+UPAGES) * NBPG) /* + _C_LABEL(nkpde) * NBPG */
d567 1
a567 1
1:	cmpl	RELOC(_C_LABEL(nkptp_max)),%ecx	# larger than max?
d569 1
a569 1
	movl	RELOC(_C_LABEL(nkptp_max)),%ecx
a653 2
	addl	$NBPG, %eax				# pte for ptd[1]
	movl	%eax,(PROC0PDIR+(PDSLOT_PTE+1)*4)(%esi)	# recursive PD slot
a2303 36

#ifndef SMALL_KERNEL
/*
 * int cpu_paenable(void *);
 */
ENTRY(cpu_paenable)
	movl	$-1, %eax
	testl	$CPUID_PAE, _C_LABEL(cpu_feature)
	jz	1f

	pushl	%esi
	pushl	%edi
	movl	12(%esp), %esi
	movl	%cr3, %edi
	orl	$0xfe0, %edi	/* PDPT will be in the last four slots! */
	movl	%edi, %cr3
	addl	$KERNBASE, %edi	/* and make it back virtual again */
	movl	$8, %ecx
	cld
	rep
	movsl
	movl	%cr4, %eax
	orl	$CR4_PAE, %eax
	movl	%eax, %cr4	/* BANG!!! */
	movl	12(%esp), %eax
	subl	$KERNBASE, %eax
	movl	%eax, %cr3	/* reload real PDPT */
	movl	$4*NBPG, %eax
	movl	%eax, _C_LABEL(PTDsize)

	xorl	%eax, %eax
	popl	%edi
	popl	%esi
1:
	ret
#endif /* !SMALL_KERNEL */
@


1.104
log
@Save misc info (ebx) register from cpuid with eax=1, so we can use it
later for some identifications.

"slap it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.103 2006/05/11 13:21:11 mickey Exp $	*/
a249 1
_C_LABEL(boothowto):	.long	0	# boot flags
a540 11

	/* Clear the BSS. */
	movl	$RELOC(_C_LABEL(edata)),%edi
	movl	$_C_LABEL(end),%ecx
	subl	$_C_LABEL(edata),%ecx
	addl	$3,%ecx
	shrl	$2,%ecx
	xorl	%eax,%eax
	cld
	rep
	stosl
@


1.103
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.102 2006/05/07 11:30:51 kettenis Exp $	*/
d198 1
d236 1
d471 1
@


1.102
log
@.globl PTDsize; mickey obviously doesn't test before he commits
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.101 2006/05/06 14:42:32 mickey Exp $	*/
d68 1
a68 1
#if NLAPIC > 0 
d103 1
a103 1
       
d107 1
a107 1
       
d112 1
a112 1
       
d129 1
a129 1
               
d1814 1
a1814 1
	/* 
d1842 1
a1842 1
#if defined(MULTIPROCESSOR) || defined(LOCKDEBUG)     
d2047 2
a2048 2
	 * (The local APIC does this when CPL is raised while it's on the 
	 * way to delivering an interrupt.. presumably enough has been set 
d2092 1
a2092 1
	pushl	%fs     
d2123 1
a2123 1
#else 
d2353 1
a2353 1
#if NLAPIC > 0 
@


1.101
log
@somehow PTDsize got lost from the pae diff; found by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.100 2006/04/27 15:37:51 mickey Exp $	*/
d205 1
a205 1
	.globl	_C_LABEL(proc0paddr), _C_LABEL(PTDpaddr)
@


1.100
log
@implement separate PAE pmap that allows access to 64g of physmem
if supported by the cpu(s). currently not enabled by default and
not compiled into ramdisks. this grows paddr_t to 64bit but yet
leaves bus_addr_t at 32bits. measures are taken to favour dmaable
memory allocation from below 4g line such that buffer cache is
already allocated form below, pool backend allocator prefers lower
memory and then finally bounce buffers are used as last resort.
PAE is engaged only if global variable cpu_pae is manually set
to non-zero and there is physical memory present above 4g.
simplify pcibios address math to use u_long as we always will
be in the 32bit space.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.99 2006/04/19 14:19:30 mickey Exp $	*/
d256 1
d2343 2
@


1.99
log
@curpcb is long gone and is a #define -- do not declare it global anymore (no func change)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.98 2006/04/14 21:52:47 weingart Exp $	*/
d203 1
d535 3
a537 3
#define	PROC0STACK	((1)		* NBPG)
#define	SYSMAP		((1+UPAGES)	* NBPG)
#define	TABLESIZE	((1+UPAGES) * NBPG) /* + _C_LABEL(nkpde) * NBPG */
d576 1
a576 1
1:	cmpl	$NKPTP_MAX,%ecx			# larger than max?
d578 1
a578 1
	movl	$NKPTP_MAX,%ecx
d663 2
d2315 34
@


1.98
log
@Nuke DUMMY_NOPS, cleanup.
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.97 2006/03/14 12:25:20 mickey Exp $	*/
a206 3
#ifndef MULTIPROCESSOR
	.globl	_C_LABEL(curpcb)
#endif
@


1.97
log
@prevent the faults on iret to run w/ disabled intrs and cause deadlocks; niklas toby tom ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.96 2006/01/12 15:59:03 mickey Exp $	*/
a80 10

/* NB: NOP now preserves registers so NOPs can be inserted anywhere */
/* XXX: NOP and FASTER_NOP are misleadingly named */
#ifdef DUMMY_NOPS	/* this will break some older machines */
#define	FASTER_NOP
#define	NOP
#else
#define	FASTER_NOP	pushl %eax ; inb $0x84,%al ; popl %eax
#define	NOP	pushl %eax ; inb $0x84,%al ; inb $0x84,%al ; popl %eax
#endif
@


1.96
log
@after range-checking save nkpde back; toby@@ ok and discussion w/ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.95 2005/11/25 07:07:49 tom Exp $	*/
d176 1
@


1.95
log
@Remove $ on access to cpuid_level: we want to get the value of the
variable, not its address.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.94 2005/11/23 16:51:28 mickey Exp $	*/
d590 1
a590 1
2:
@


1.94
log
@finnish the PTDPTDI and APTDPTDI conversion to PDSLOT_PTE and PDSLOT_APTE thus reducing confusion; remove compatibility defines and comments
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.93 2005/10/26 20:32:59 marco Exp $	*/
d482 1
a482 1
	movl	$RELOC(_C_LABEL(cpuid_level)),%eax
@


1.93
log
@Add basic handler for MCE and MCA.  Written mostly by toby@@ and commiting for
toby@@ per his request.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.92 2005/09/14 05:38:48 marco Exp $	*/
d194 2
a195 2
	.set	_C_LABEL(APTmap), (APTDPTDI << PDSHIFT)
	.set	_C_LABEL(APTD), (_C_LABEL(APTmap) + APTDPTDI * NBPG)
d197 1
a197 1
	.set	_C_LABEL(APTDpde), (_C_LABEL(PTD) + APTDPTDI * 4)
@


1.92
log
@Remove unused label.

ahh ok, you're confusing me with turdshining :) beck@@
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.91 2005/07/18 14:55:49 mickey Exp $	*/
d2046 4
@


1.91
log
@save/restore fpu for the signal handler call in the trampoline.
modeled after sparc together w/ deraadt@@; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.90 2005/05/29 03:20:38 deraadt Exp $	*/
d1540 1
a1540 1
	.globl _C_LABEL(apm_cpu_idle),_C_LABEL(apm_cpu_busy),_C_LABEL(apm_dobusy)
@


1.90
log
@sched work by niklas and art backed out; causes panics
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.87 2005/05/25 22:50:25 beck Exp $	*/
d739 23
a761 2
	call	*SIGF_HANDLER(%esp)
	leal	SIGF_SC(%esp),%eax	# scp (the call may have clobbered the
@


1.89
log
@optimise one more jmp out of the idle loop; toby@@ marco@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.88 2005/05/25 23:17:47 niklas Exp $	*/
d1620 1
@


1.88
log
@This patch is mortly art's work and was done *a year* ago.  Art wants to thank
everyone for the prompt review and ok of this work ;-)  Yeah, that includes me
too, or maybe especially me.  I am sorry.

Change the sched_lock to a mutex. This fixes, among other things, the infamous
"telnet localhost &" problem.  The real bug in that case was that the sched_lock
which is by design a non-recursive lock, was recursively acquired, and not
enough releases made us hold the lock in the idle loop, blocking scheduling
on the other processors.  Some of the other processors would hold the biglock though,
which made it impossible for cpu 0 to enter the kernel...  A nice deadlock.
Let me just say debugging this for days just to realize that it was all fixed
in an old diff noone ever ok'd was somewhat of an anti-climax.

This diff also changes splsched to be correct for all our architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.87 2005/05/25 22:50:25 beck Exp $	*/
d1601 1
d1604 4
a1607 4
	cli
	cmpl	$0,_C_LABEL(whichqs)
	jnz	_C_LABEL(idle_exit)
#if NPCTR > 0 && NAPM == 0
a1610 3
#if NAPM > 0
	call	_C_LABEL(apm_cpu_idle)
#else
d1614 4
a1617 1
	jmp	_C_LABEL(idle_loop)
@


1.87
log
@one last optimization, removing a jump, mostly by
toby, committed so art will stop yelling at me to
avoid conflicts...
ok marco@@, weingart@@, mickey@@, niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.86 2005/05/25 19:07:13 mickey Exp $	*/
a1618 1
	movl	$IPL_HIGH,CPL		# splhigh
@


1.86
log
@repair whichqs race by disabling ints in between check and halt-halt; marco@@ beck@@ niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.85 2005/05/24 19:37:08 niklas Exp $	*/
d1602 1
a1605 2

ENTRY(idle_loop)
d1616 1
a1616 3
	cli
	cmpl	$0,_C_LABEL(whichqs)
	jz	_C_LABEL(idle_loop)
@


1.85
log
@replace jnz FOO;jmp BAR;FOO: with jz BAR;FOO:, the idle loop will be even more efficient
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.84 2005/05/24 08:54:14 marco Exp $	*/
d1602 1
d1617 1
d1623 1
@


1.84
log
@hlt hlt is not a good idea.  Rework APM to do what the spec actually says.  Run actual BIOS calls whenever we are actually idle. Tovarisch!

ok deraadt@@ toby@@ beck@@ weingart@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.83 2005/04/17 07:33:13 tedu Exp $	*/
d1617 1
a1617 2
	jnz	_C_LABEL(idle_exit)
	jmp	_C_LABEL(idle_loop)
@


1.83
log
@make sure user address is in user space in copyinstr.  ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.82 2005/02/10 04:06:01 weingart Exp $	*/
a1601 1
ENTRY(idle_loop)
d1604 2
a1605 7
#if NAPM > 0
	call	_C_LABEL(apm_cpu_idle)
	cmpl	$0,_C_LABEL(apm_dobusy)
	je	1f
	call	_C_LABEL(apm_cpu_busy)
1:
#endif
d1609 3
d1613 1
d1616 2
d1625 2
a1626 7
#if 0
	GET_CPUINFO(%ebx)
	leal	CPU_INFO_NAME(%ebx),%ebx
	pushl	%ebx
	pushl	$1f
	call	_C_LABEL(printf)
	addl	$8,%esp
a1628 1
1:	.asciz	"%s: unidle\n"
@


1.82
log
@Nasty, fix tedu's test case.  This needs to be
looked at after release again.  Lots of testing.

Partial ok from drah@@, hshoexer@@, others.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.81 2005/01/01 02:57:36 millert Exp $	*/
d1301 2
@


1.82.2.1
log
@MFC:
Fixes by marco@@, niklas@@, mickey@@ and beck@@

rev 1.87
one last optimization, removing a jump, mostly by
toby, committed so art will stop yelling at me to
avoid conflicts...

rev 1.86
repair whichqs race by disabling ints in between check and halt-halt

rev 1.85
replace jnz FOO;jmp BAR;FOO: with jz BAR;FOO:, the idle loop will be even more efficient

rev 1.84
hlt hlt is not a good idea.  Rework APM to do what the spec actually says.
Run actual BIOS calls whenever we are actually idle. Tovarisch!

ok deraadt@@ marco@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.82 2005/02/10 04:06:01 weingart Exp $	*/
a1600 1
	cli
d1603 7
a1612 3
#endif
#if NAPM > 0
	call	_C_LABEL(apm_cpu_idle)
a1613 1
	sti
a1619 1
	sti
d1623 7
a1629 2
#if NAPM > 0
	call	_C_LABEL(apm_cpu_busy)
d1632 1
@


1.81
log
@Move the declaration of bootdev from autoconf.c to locore.s.  gcc
3.3.5 was placing bootdev into bss and its value was getting zeroed
when bss is cleared.  Apparently we lucked out before and gcc 2.9.5
put it in .data; now it is explicit.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.80 2004/07/20 20:16:44 art Exp $	*/
d1246 2
@


1.80
log
@MD mutex implementation for i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.79 2004/07/02 16:29:55 niklas Exp $	*/
d264 1
@


1.80.2.1
log
@MFC:
Fix by weingart@@

Nasty, fix tedu's test case.  This needs to be
looked at after release again.  Lots of testing.

ok deraadt@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.80 2004/07/20 20:16:44 art Exp $	*/
a1244 2
	cmpl	$VM_MAXUSER_ADDRESS,%edi
	jae	_C_LABEL(copystr_fault)
@


1.80.2.2
log
@MFC:
Fixes by marco@@, niklas@@, mickey@@ and beck@@

rev 1.87
one last optimization, removing a jump, mostly by
toby, committed so art will stop yelling at me to
avoid conflicts...

rev 1.86
repair whichqs race by disabling ints in between check and halt-halt

rev 1.85
replace jnz FOO;jmp BAR;FOO: with jz BAR;FOO:, the idle loop will be even more efficient

rev 1.84
hlt hlt is not a good idea.  Rework APM to do what the spec actually says.
Run actual BIOS calls whenever we are actually idle. Tovarisch!

ok deraadt@@ marco@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.80.2.1 2005/02/27 00:57:02 brad Exp $	*/
a1599 1
	cli
d1602 7
a1611 3
#endif
#if NAPM > 0
	call	_C_LABEL(apm_cpu_idle)
a1612 1
	sti
a1618 1
	sti
d1622 7
a1628 2
#if NAPM > 0
	call	_C_LABEL(apm_cpu_busy)
d1631 1
@


1.79
log
@Maintain %f and %gs over traps.  Mostly from NetBSD.  Preparation for SMP
speedups.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.78 2004/06/13 21:49:15 niklas Exp $	*/
d2304 2
@


1.78
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d156 1
d159 5
a163 1
	movw	%ax,%es
d165 2
d305 5
a718 5
	/* Clear segment registers; always null in proc0. */
	xorl	%ecx,%ecx
	movw	%cx,%fs
	movw	%cx,%gs

d741 1
a741 9
#ifdef VM86
	testl	$PSL_VM,SC_EFLAGS(%eax)
	jnz	1f
#endif
	movl	SC_FS(%eax),%ecx
	movl	SC_GS(%eax),%edx
	movw	%cx,%fs
	movw	%dx,%gs
1:	pushl	%eax
d757 1
a757 9
#ifdef VM86
	testl	$PSL_VM,SVR4_UC_EFLAGS(%eax)
	jnz	1f
#endif
	movl	SVR4_UC_FS(%eax),%ecx
	movl	SVR4_UC_GS(%eax),%edx
	movw	%cx,%fs
	movw	%dx,%gs
1:	pushl	%eax
d778 1
a778 9
#ifdef VM86
	testl	$PSL_VM,LINUX_SC_EFLAGS(%ebx)
	jnz	1f
#endif
	movl	LINUX_SC_FS(%ebx),%ecx
	movl	LINUX_SC_GS(%ebx),%edx
	movw	%cx,%fs
	movw	%dx,%gs
1:	pushl	%eax			# junk to fake return address
a1734 10
	/* Save segment registers. */
#ifdef DDB
	xorl	%eax, %eax
	xorl	%ecx, %ecx
#endif
	movw	%fs,%ax
	movw	%gs,%cx
	movl	%eax,PCB_FS(%esi)
	movl	%ecx,PCB_GS(%esi)

a1797 6
	/* Restore segment registers. */
	movl	PCB_FS(%esi),%eax
	movl	PCB_GS(%esi),%ecx
	movw	%ax,%fs
	movw	%cx,%gs

a1926 10
	/* Save segment registers. */
#ifdef DDB
	xorl	%eax, %eax
	xorl	%ecx, %ecx
#endif
	movw	%fs,%ax
	movw	%gs,%cx
	movl	%eax,PCB_FS(%edx)
	movl	%ecx,PCB_GS(%edx)

d2068 1
d2072 8
@


1.77
log
@Enable FXSR all the time, and cope with NPX/FXSR conversions; from netbsd.
Pass SSE/SSE2/XCRYPT flags out via syctl, and prepare for being able to do
xcrypt-* in userland; ok naddy, tested a lot by pvalchev and jolan, also
works on amd64 in 32bit mode
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.76 2004/01/29 19:01:53 tedu Exp $	*/
d42 2
d68 4
d92 51
d203 2
a204 1
	.globl	_C_LABEL(cold), _C_LABEL(esym)
d206 2
a207 2
	.globl	_C_LABEL(proc0paddr), _C_LABEL(curpcb), _C_LABEL(PTDpaddr)
	.globl	_C_LABEL(dynamic_gdt)
d209 27
d250 2
d715 4
d853 8
d866 4
d872 1
a872 1
	movl	_C_LABEL(curpcb),%eax	# load curpcb into eax and set on-fault
d876 3
a878 3
	movl	16(%esp),%esi
	movl	20(%esp),%edi
	movl	24(%esp),%ecx
d887 1
a887 1
	movl	24(%esp),%ecx
d892 1
a892 1
	movl	_C_LABEL(curpcb),%edx
d897 3
d911 1
a911 1
	movl	24(%esp),%ecx		# copy remainder by 32-bit words
d919 1
a919 1
	movl	_C_LABEL(curpcb),%edx
d924 3
d997 4
d1005 3
a1007 3
	movl	16(%esp),%esi
	movl	20(%esp),%edi
	movl	24(%esp),%eax
d1046 1
a1046 1
	movl	_C_LABEL(curpcb), %edx
d1057 2
a1058 2
	movl	20(%esp),%edi
	movl	24(%esp),%eax
d1074 1
a1074 1
3:	movl	_C_LABEL(curpcb),%edx
d1092 3
d1102 4
d1108 1
a1108 1
	movl	_C_LABEL(curpcb),%eax
d1112 3
a1114 3
	movl	16(%esp),%esi
	movl	20(%esp),%edi
	movl	24(%esp),%eax
d1138 1
a1138 1
	movl	_C_LABEL(curpcb),%edx
d1143 3
d1149 1
a1149 1
	movl	_C_LABEL(curpcb),%edx
d1154 3
d1167 4
d1174 3
a1176 3
	movl	12(%esp),%esi		# esi = from
	movl	16(%esp),%edi		# edi = to
	movl	20(%esp),%edx		# edx = maxlen
d1190 2
a1191 2
	movl	_C_LABEL(curpcb), %eax
	movl	$6f, PCB_ONFAULT(%eax)
d1245 1
a1245 1
5:	movl	_C_LABEL(curpcb), %eax
d1255 1
a1255 1
	movl	%eax,20(%esp)
d1287 4
d1293 1
a1293 1
	movl	_C_LABEL(curpcb),%ecx
d1296 3
a1298 3
	movl	12(%esp),%esi		# %esi = from
	movl	16(%esp),%edi		# %edi = to
	movl	20(%esp),%edx		# %edx = maxlen
d1308 1
a1308 1
	movl	%eax,20(%esp)
d1336 1
a1336 1
	movl	_C_LABEL(curpcb),%ecx
d1338 1
a1338 1
	movl	20(%esp),%ecx
d1340 1
a1340 1
	movl	24(%esp),%edx
d1347 3
d1359 4
d1366 3
a1368 3
	movl	12(%esp),%esi		# esi = from
	movl	16(%esp),%edi		# edi = to
	movl	20(%esp),%edx		# edx = maxlen
d1388 1
a1388 1
	movl	20(%esp),%ecx
d1390 1
a1390 1
	movl	24(%esp),%edx
d1397 3
d1424 2
d1538 36
d1575 29
a1603 3
	movl	_C_LABEL(whichqs),%ecx
	testl	%ecx,%ecx
	jnz	sw1
d1605 12
d1630 1
a1630 1
	jmp	_C_LABEL(idle)
d1632 16
d1666 1
a1666 1
	pushl	_C_LABEL(cpl)
d1668 1
a1668 1
	movl	_C_LABEL(curproc),%esi
d1677 1
a1677 4
	movl	$0,_C_LABEL(curproc)

	movl	$IPL_NONE,_C_LABEL(cpl)	# spl0()
	call	_C_LABEL(Xspllower)	# process pending interrupts
a1692 1
	cli				# splhigh doesn't do a cli
d1694 1
a1694 2

sw1:	bsfl	%ecx,%ebx		# find a full q
a1695 1

a1696 1

d1713 1
a1713 2
	xorl	%eax,%eax
	movl	%eax,_C_LABEL(want_resched)
d1726 2
a1727 4
	movl	%edi,_C_LABEL(curproc)

	/* It's okay to take interrupts here. */
	sti
d1746 4
d1790 10
d1801 7
a1807 6
	movl	_C_LABEL(dynamic_gdt),%eax
	movl	PCB_TSS_SEL(%esi),%edx

	/* Switch address space. */
	movl	PCB_CR3(%esi),%ecx
	movl	%ecx,%cr3
d1834 11
d1848 1
a1848 1
	movl	%esi,_C_LABEL(curpcb)
d1854 12
d1870 1
a1870 1
	popl	_C_LABEL(cpl)
d1877 1
a1877 1

d1880 3
a1882 2
 * Switch to proc0's saved context and deallocate the address space and kernel
 * stack for p.  Then jump into cpu_switch(), as if we were in proc0 all along.
d1884 1
d1886 1
d1889 1
d1891 7
d1900 1
a1900 1
	movl	$0,_C_LABEL(curproc)
d1902 1
a1902 1
	/* Restore proc0's context. */
a1903 1
	movl	P_ADDR(%ebx),%esi
d1910 5
a1914 2
	movl	_C_LABEL(dynamic_gdt),%eax
	movl	PCB_TSS_SEL(%esi),%edx
d1936 1
a1936 1
	movl	%esi,_C_LABEL(curpcb)
d1949 2
a1950 2
	movl	%ebx,%esi
	movl	$0,_C_LABEL(curproc)
d2026 6
a2031 1
	pushl	_C_LABEL(curproc)
d2069 10
d2089 1
a2089 1
	pushl	_C_LABEL(cpl)		# if_ppl in intrframe
d2121 1
a2121 1
	movl	_C_LABEL(cpl),%ebx
d2126 1
a2126 1
	cmpb	$0,_C_LABEL(astpending)
d2134 1
a2134 1
5:	movb	$0,_C_LABEL(astpending)
d2141 2
a2142 2
#else /* DIAGNOSTIC */
1:	cmpl	_C_LABEL(cpl),%ebx
d2152 1
a2152 1
	movl	%ebx,_C_LABEL(cpl)
d2183 1
a2183 1
	cmpb	$0,_C_LABEL(astpending)
d2186 1
a2186 1
	movb	$0,_C_LABEL(astpending)
d2193 1
a2193 1
#include <i386/isa/vector.s>
d2333 4
@


1.77.2.1
log
@MFC:
Fix by weingart@@

Nasty, fix tedu's test case.  This needs to be
looked at after release again.  Lots of testing.

ok deraadt@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.77 2004/02/01 19:05:23 deraadt Exp $	*/
a1131 2
	cmpl	$VM_MAXUSER_ADDRESS,%edi
	jae	_C_LABEL(copystr_fault)
@


1.76
log
@as seen in freebsd:  asm pagezero implementations, but use a fn pointer.
the sse2 version cuts ZOD fault time in half.
suggestions mickey deraadt.  many many testers. ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.75 2003/11/17 14:55:58 miod Exp $	*/
d1750 1
a1750 1
	call	_C_LABEL(npxdna)
@


1.75
log
@Be sure to not use the cpuid instruction on processors which do not support it;
repairs 80386 support.

Spotted and tested nick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.74 2003/11/15 19:27:50 henning Exp $	*/
d1975 67
@


1.74
log
@diff from andreas@@:
use the cpuid instruction for processor identification where available.
tested by grange@@, tedu@@ and me
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.73 2003/07/29 18:24:36 mickey Exp $	*/
d384 1
a384 1
	jl	2f
d390 1
a390 1
	jne	2f
d398 1
a398 1
2:
d403 1
a403 1
	jbe	3f
d424 1
a424 1
3:
@


1.73
log
@move spl checking wrap over the syscall into trap.c:syscall();
this gives several benefits:
the arguments for a syscall printed are the exact args and not
  some wild guess fetched from the user stack;
the check does not include the AST traps that may be checked
  on their own in the trap() routine should be desired;
kill last use and thus itself the fuword() function and it's glue.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.72 2003/07/11 20:45:18 art Exp $	*/
d141 1
d162 1
d399 26
@


1.72
log
@Set pcb_onfault earlier in 386 version of copyout and clean up
some register handling.
Based on NetBSD. Solves one of the problems on 386.
toby@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.71 2003/06/06 11:11:53 andreas Exp $	*/
a1229 30
/*
 * fuword(caddr_t uaddr);
 * Fetch an int from the user's address space.
 * Not used outside locore anymore.
 */
ASENTRY(fuword)
	movl	4(%esp),%edx
	cmpl	$VM_MAXUSER_ADDRESS-4,%edx
	ja	_ASM_LABEL(fusuaddrfault)
	movl	_C_LABEL(curpcb),%ecx
	movl	$_ASM_LABEL(fusufault),PCB_ONFAULT(%ecx)
	movl	(%edx),%eax
	movl	$0,PCB_ONFAULT(%ecx)
	ret

/*
 * Handle faults from fuword.  Clean up and return -1.
 */
ASENTRY(fusufault)
	movl	$0,PCB_ONFAULT(%ecx)
	movl	$-1,%eax
	ret

/*
 * Handle earlier faults from fuword, due to our of range addresses.
 */
ASENTRY(fusuaddrfault)
	movl	$-1,%eax
	ret

a1859 4
#ifdef DIAGNOSTIC
	movl	_C_LABEL(cpl),%ebx
	movl	TF_EAX(%esp),%esi	# syscall no
#endif /* DIAGNOSTIC */
a1870 1
#ifndef DIAGNOSTIC
a1871 45
#else /* DIAGNOSTIC */
1:	cmpl	_C_LABEL(cpl),%ebx
	jne	3f
	INTRFASTEXIT
3:	sti
	movl	TF_ESP(%esp),%edi	# user stack pointer
	leal	4(%edi),%edi		# parameters (in userspace)
	cmpl	$SYS_syscall,%esi
	jne	5f
	pushl	%edi
	CALL	_ASM_LABEL(fuword)
	movl	%eax,%esi		# indirect syscall no for SYS_syscall
	leal	4(%edi),%edi		# shift parameters
	jmp	6f
5:	
	cmpl	$SYS___syscall,%esi
	jne	6f
	pushl	%edi
	CALL	_ASM_LABEL(fuword)
	movl	%eax,%esi		# indirect syscall no for SYS___syscall
	leal	8(%edi),%edi		# shift parameters (quad alignment)
6:
	leal	8(%edi),%ecx
	pushl	%ecx
	call	_ASM_LABEL(fuword)
	movl	%eax,(%esp)		# 3rd syscall arg
	leal	4(%edi),%ecx
	pushl	%ecx
	call	_ASM_LABEL(fuword)
	movl	%eax,(%esp)		# 2nd syscall arg
	pushl	%edi
	call	_ASM_LABEL(fuword)
	movl	%eax,(%esp)		# 1st syscall arg
	pushl	%esi			# syscall no
	pushl	_C_LABEL(cpl)		# current spl
	pushl	$4f			# format string
	call	_C_LABEL(printf)
	addl	$24,%esp
#if defined(DDB) && 0
	int	$3
#endif /* DDB */
	movl	%ebx,_C_LABEL(cpl)
	jmp	2b
4:	.asciz	"WARNING: SPL (0x%x) NOT LOWERED ON syscall(0x%x, 0x%x, 0x%x, 0x%x...) EXIT\n"
#endif /* DIAGNOSTIC */
@


1.71
log
@Identify Pentium M CPU
Recognize more feature flags
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.70 2003/06/02 23:27:47 millert Exp $	*/
d905 3
d916 2
a917 1
	movl	16(%esp),%edi
a920 1
	pushl	%eax
a928 1
	popl	%eax
d942 2
a943 2
	movb	%al,%cl
	andb	$3,%cl
a1014 2
	movl	_C_LABEL(curpcb),%ecx
	movl	$_C_LABEL(copystr_fault),PCB_ONFAULT(%ecx)
d1032 2
a1033 3
	/* Compute PTE offset for start address. */
	movl	%edi,%eax
	shrl	$PGSHIFT,%eax		# calculate pte address
d1042 4
d1049 1
a1049 2
	/* Simulate a trap. */
	pushl	%eax
a1055 1
	popl	%eax
d1060 1
a1060 1
	jnc	6f
a1063 1
6:	pushl	%eax			# save PT index
a1071 1
	addl	$4,%esp			# discard PT index
a1076 1
	popl	%eax			# restore PT index
a1077 1
	incl	%eax
d1087 3
a1089 1
5:	/*
@


1.70
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.69 2003/04/17 03:42:14 drahn Exp $	*/
d141 2
a142 1
	.globl	_C_LABEL(cpuid_level), _C_LABEL(cpu_feature)
d154 1
d378 1
@


1.69
log
@i386 changes to move to ELF. asm cleanup. Change MAXDSIZ to 512M for 1Gsep.
DARPA funded work.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.68 2003/01/09 22:27:09 miod Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.68
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.67 2002/10/29 01:52:46 art Exp $	*/
d73 4
a76 3
#define	ALIGN_DATA	.align	2
#define	ALIGN_TEXT	.align	2,0x90	/* 4-byte boundaries, NOP-filled */
#define	SUPERALIGN_TEXT	.align	4,0x90	/* 16-byte boundaries better for 486 */
d104 2
a105 2
	movl	%ax,%ds		; \
	movl	%ax,%es
d595 2
a596 2
	movl	%cx,%fs
	movl	%cx,%gs
d602 1
a602 1
	call	%esi
d613 1
a613 1
	call	SIGF_HANDLER(%esp)
d622 2
a623 2
	movl	%cx,%fs
	movl	%dx,%gs
d637 1
a637 1
	call	SVR4_SIGF_HANDLER(%esp)
d646 2
a647 2
	movl	%cx,%fs
	movl	%dx,%gs
d666 1
a666 1
	call	LINUX_SIGF_HANDLER(%esp)
d675 2
a676 2
	movl	%cx,%fs
	movl	%dx,%gs
d693 1
a693 1
	call	FREEBSD_SIGF_HANDLER(%esp)
d1281 3
a1283 3
	movl	%ax,%ds
	movl	%ax,%es
	movl	%ax,%ss
d1531 2
a1532 2
	movl	%fs,%ax
	movl	%gs,%cx
d1591 2
a1592 2
	movl	%ax,%fs
	movl	%cx,%gs
d1655 2
a1656 2
	movl	%cx,%fs
	movl	%cx,%gs
d1692 2
a1693 2
	movl	%fs,%ax
	movl	%gs,%cx
d1718 1
a1718 1
#define	IDTVEC(name)	ALIGN_TEXT; .globl _X/**/name; _X/**/name:
d1824 1
a1824 1
	movl	%ax,%es
@


1.67
log
@Remove some unused globls
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.66 2002/07/24 23:20:11 mickey Exp $	*/
d1234 1
d1236 1
a1236 1
ENTRY(fuword)
d1239 1
a1239 1
	ja	_C_LABEL(fusuaddrfault)
d1241 1
a1241 1
	movl	$_C_LABEL(fusufault),PCB_ONFAULT(%ecx)
d1247 1
a1247 2
 * fusword(caddr_t uaddr);
 * Fetch a short from the user's address space.
d1249 1
a1249 43
ENTRY(fusword)
	movl	4(%esp),%edx
	cmpl	$VM_MAXUSER_ADDRESS-2,%edx
	ja	_C_LABEL(fusuaddrfault)
	movl	_C_LABEL(curpcb),%ecx
	movl	$_C_LABEL(fusufault),PCB_ONFAULT(%ecx)
	movzwl	(%edx),%eax
	movl	$0,PCB_ONFAULT(%ecx)
	ret

/*
 * fuswintr(caddr_t uaddr);
 * Fetch a short from the user's address space.  Can be called during an
 * interrupt.
 */
ENTRY(fuswintr)
	movl	4(%esp),%edx
	cmpl	$VM_MAXUSER_ADDRESS-2,%edx
	ja	_C_LABEL(fusuaddrfault)
	movl	_C_LABEL(curpcb),%ecx
	movl	$_C_LABEL(fusubail),PCB_ONFAULT(%ecx)
	movzwl	(%edx),%eax
	movl	$0,PCB_ONFAULT(%ecx)
	ret

/*
 * fubyte(caddr_t uaddr);
 * Fetch a byte from the user's address space.
 */
ENTRY(fubyte)
	movl	4(%esp),%edx
	cmpl	$VM_MAXUSER_ADDRESS-1,%edx
	ja	_C_LABEL(fusuaddrfault)
	movl	_C_LABEL(curpcb),%ecx
	movl	$_C_LABEL(fusufault),PCB_ONFAULT(%ecx)
	movzbl	(%edx),%eax
	movl	$0,PCB_ONFAULT(%ecx)
	ret

/*
 * Handle faults from [fs]u*().  Clean up and return -1.
 */
ENTRY(fusufault)
d1255 1
a1255 3
 * Handle faults from [fs]u*().  Clean up and return -1.  This differs from
 * fusufault() in that trap() will recognize it and return immediately rather
 * than trying to page fault.
d1257 1
a1257 2
ENTRY(fusubail)
	movl	$0,PCB_ONFAULT(%ecx)
a1260 165
/*
 * Handle earlier faults from [fs]u*(), due to our of range addresses.
 */
ENTRY(fusuaddrfault)
	movl	$-1,%eax
	ret

/*
 * suword(caddr_t uaddr, int x);
 * Store an int in the user's address space.
 */
ENTRY(suword)
	movl	4(%esp),%edx
	cmpl	$VM_MAXUSER_ADDRESS-4,%edx
	ja	_C_LABEL(fusuaddrfault)
	movl	_C_LABEL(curpcb),%ecx
	movl	$_C_LABEL(fusufault),PCB_ONFAULT(%ecx)

#if defined(I386_CPU)
#if defined(I486_CPU) || defined(I586_CPU) || defined(I686_CPU)
	cmpl	$CPUCLASS_386,_C_LABEL(cpu_class)
	jne	2f
#endif /* I486_CPU || I586_CPU || I686_CPU */

	movl	%edx,%eax
	shrl	$PGSHIFT,%eax		# calculate pte address
	testb	$PG_RW,_C_LABEL(PTmap)(,%eax,4)
	jnz	1f

	/* Simulate a trap. */
	pushl	%edx
	pushl	%edx
	call	_C_LABEL(trapwrite)	# trapwrite(addr)
	addl	$4,%esp			# clear parameter from the stack
	popl	%edx
	movl	_C_LABEL(curpcb),%ecx
	testl	%eax,%eax
	jnz	_C_LABEL(fusufault)

1:	/* XXX also need to check the following 3 bytes for validity! */
#endif

2:	movl	8(%esp),%eax
	movl	%eax,(%edx)
	xorl	%eax,%eax
	movl	%eax,PCB_ONFAULT(%ecx)
	ret

/*
 * susword(caddr_t uaddr, short x);
 * Store a short in the user's address space.
 */
ENTRY(susword)
	movl	4(%esp),%edx
	cmpl	$VM_MAXUSER_ADDRESS-2,%edx
	ja	_C_LABEL(fusuaddrfault)
	movl	_C_LABEL(curpcb),%ecx
	movl	$_C_LABEL(fusufault),PCB_ONFAULT(%ecx)

#if defined(I386_CPU)
#if defined(I486_CPU) || defined(I586_CPU) || defined(I686_CPU)
	cmpl	$CPUCLASS_386,_C_LABEL(cpu_class)
	jne	2f
#endif /* I486_CPU || I586_CPU || I686_CPU */

	movl	%edx,%eax
	shrl	$PGSHIFT,%eax		# calculate pte address
	testb	$PG_RW,_C_LABEL(PTmap)(,%eax,4)
	jnz	1f

	/* Simulate a trap. */
	pushl	%edx
	pushl	%edx
	call	_C_LABEL(trapwrite)	# trapwrite(addr)
	addl	$4,%esp			# clear parameter from the stack
	popl	%edx
	movl	_C_LABEL(curpcb),%ecx
	testl	%eax,%eax
	jnz	_C_LABEL(fusufault)

1:	/* XXX also need to check the following byte for validity! */
#endif

2:	movl	8(%esp),%eax
	movw	%ax,(%edx)
	xorl	%eax,%eax
	movl	%eax,PCB_ONFAULT(%ecx)
	ret

/*
 * suswintr(caddr_t uaddr, short x);
 * Store a short in the user's address space.  Can be called during an
 * interrupt.
 */
ENTRY(suswintr)
	movl	4(%esp),%edx
	cmpl	$VM_MAXUSER_ADDRESS-2,%edx
	ja	_C_LABEL(fusuaddrfault)
	movl	_C_LABEL(curpcb),%ecx
	movl	$_C_LABEL(fusubail),PCB_ONFAULT(%ecx)

#if defined(I386_CPU)
#if defined(I486_CPU) || defined(I586_CPU) || defined(I686_CPU)
	cmpl	$CPUCLASS_386,_C_LABEL(cpu_class)
	jne	2f
#endif /* I486_CPU || I586_CPU || I686_CPU */

	movl	%edx,%eax
	shrl	$PGSHIFT,%eax		# calculate pte address
	testb	$PG_RW,_C_LABEL(PTmap)(,%eax,4)
	jnz	1f

	/* Simulate a trap. */
	jmp	_C_LABEL(fusubail)

1:	/* XXX also need to check the following byte for validity! */
#endif

2:	movl	8(%esp),%eax
	movw	%ax,(%edx)
	xorl	%eax,%eax
	movl	%eax,PCB_ONFAULT(%ecx)
	ret

/*
 * subyte(caddr_t uaddr, char x);
 * Store a byte in the user's address space.
 */
ENTRY(subyte)
	movl	4(%esp),%edx
	cmpl	$VM_MAXUSER_ADDRESS-1,%edx
	ja	_C_LABEL(fusuaddrfault)
	movl	_C_LABEL(curpcb),%ecx
	movl	$_C_LABEL(fusufault),PCB_ONFAULT(%ecx)

#if defined(I386_CPU)
#if defined(I486_CPU) || defined(I586_CPU) || defined(I686_CPU)
	cmpl	$CPUCLASS_386,_C_LABEL(cpu_class)
	jne	2f
#endif /* I486_CPU || I586_CPU || I686_CPU */

	movl	%edx,%eax
	shrl	$PGSHIFT,%eax		# calculate pte address
	testb	$PG_RW,_C_LABEL(PTmap)(,%eax,4)
	jnz	1f

	/* Simulate a trap. */
	pushl	%edx
	pushl	%edx
	call	_C_LABEL(trapwrite)	# trapwrite(addr)
	addl	$4,%esp			# clear parameter from the stack
	popl	%edx
	movl	_C_LABEL(curpcb),%ecx
	testl	%eax,%eax
	jnz	_C_LABEL(fusufault)

1:
#endif

2:	movb	8(%esp),%al
	movb	%al,(%edx)
	xorl	%eax,%eax
	movl	%eax,PCB_ONFAULT(%ecx)
	ret

d1918 1
a1918 1
	CALL	_C_LABEL(fuword)
d1926 1
a1926 1
	CALL	_C_LABEL(fuword)
d1932 1
a1932 1
	call	_C_LABEL(fuword)
d1936 1
a1936 1
	call	_C_LABEL(fuword)
d1939 1
a1939 1
	call	_C_LABEL(fuword)
@


1.66
log
@use properly sized regs for the prefix, only matters w/ picky binutils, old gas knows what to do; it's a ddb prettiness anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.65 2002/02/18 23:09:53 mickey Exp $	*/
d1832 1
a1832 2
	.globl	_C_LABEL(proc0),_C_LABEL(uvmspace_free),_C_LABEL(kernel_map)
	.globl	_C_LABEL(uvm_km_free),_C_LABEL(tss_free)
@


1.65
log
@when saving %fs,%gs clear out the upper 16 bits for ddb
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.64 2001/12/04 20:54:11 niklas Exp $	*/
d1737 2
a1738 2
	xorl	%ax, %ax
	xorl	%cx, %cx
d1899 2
a1900 2
	xorl	%ax, %ax
	xorl	%cx, %cx
@


1.64
log
@Now that we found the bug, go back to not stop on SPL NOT LOWERED..
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.63 2001/12/04 01:20:27 marc Exp $	*/
d1736 4
d1898 4
@


1.64.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.64 2001/12/04 20:54:11 niklas Exp $	*/
a1735 4
#ifdef DDB
	xorl	%ax, %ax
	xorl	%cx, %cx
#endif
a1893 4
#ifdef DDB
	xorl	%ax, %ax
	xorl	%cx, %cx
#endif
@


1.64.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.64.2.1 2002/06/11 03:35:53 art Exp $	*/
d1737 2
a1738 2
	xorl	%eax, %eax
	xorl	%ecx, %ecx
d1899 2
a1900 2
	xorl	%eax, %eax
	xorl	%ecx, %ecx
@


1.64.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d73 3
a75 4

#define	ALIGN_DATA	.align  4
#define	ALIGN_TEXT	.align  4,0x90	/* 4-byte boundaries, NOP-filled */
#define	SUPERALIGN_TEXT	.align  16,0x90	/* 16-byte boundaries better for 486 */
d103 2
a104 2
	movw	%ax,%ds		; \
	movw	%ax,%es
d594 2
a595 2
	movw	%cx,%fs
	movw	%cx,%gs
d601 1
a601 1
	call	*%esi
d612 1
a612 1
	call	*SIGF_HANDLER(%esp)
d621 2
a622 2
	movw	%cx,%fs
	movw	%dx,%gs
d636 1
a636 1
	call	*SVR4_SIGF_HANDLER(%esp)
d645 2
a646 2
	movw	%cx,%fs
	movw	%dx,%gs
d665 1
a665 1
	call	*LINUX_SIGF_HANDLER(%esp)
d674 2
a675 2
	movw	%cx,%fs
	movw	%dx,%gs
d692 1
a692 1
	call	*FREEBSD_SIGF_HANDLER(%esp)
a1233 1
 * Not used outside locore anymore.
d1235 1
a1235 1
ASENTRY(fuword)
d1238 1
a1238 1
	ja	_ASM_LABEL(fusuaddrfault)
d1240 1
a1240 1
	movl	$_ASM_LABEL(fusufault),PCB_ONFAULT(%ecx)
d1246 44
a1289 1
 * Handle faults from fuword.  Clean up and return -1.
d1291 1
a1291 1
ASENTRY(fusufault)
d1297 3
a1299 1
 * Handle earlier faults from fuword, due to our of range addresses.
d1301 2
a1302 1
ASENTRY(fusuaddrfault)
d1306 165
d1490 3
a1492 3
	movw	%ax,%ds
	movw	%ax,%es
	movw	%ax,%ss
d1740 2
a1741 2
	movw	%fs,%ax
	movw	%gs,%cx
d1800 2
a1801 2
	movw	%ax,%fs
	movw	%cx,%gs
d1832 2
a1833 1
	.globl	_C_LABEL(proc0)
d1865 2
a1866 2
	movw	%cx,%fs
	movw	%cx,%gs
d1902 2
a1903 2
	movw	%fs,%ax
	movw	%gs,%cx
d1928 1
a1928 1
#define	IDTVEC(name)	ALIGN_TEXT; .globl X/**/name; X/**/name:
d2034 1
a2034 1
	movw	%ax,%es
d2129 1
a2129 1
	CALL	_ASM_LABEL(fuword)
d2137 1
a2137 1
	CALL	_ASM_LABEL(fuword)
d2143 1
a2143 1
	call	_ASM_LABEL(fuword)
d2147 1
a2147 1
	call	_ASM_LABEL(fuword)
d2150 1
a2150 1
	call	_ASM_LABEL(fuword)
@


1.63
log
@part of i386 isr patches; OK niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.62 2001/12/01 07:51:32 niklas Exp $	*/
d2149 1
a2149 1
#if defined(DDB)
@


1.62
log
@Provide more debugging info for the spl not lowered on syscall exit
situation.  And stop in ddb once again so more debugging still can be
carried out.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.61 2001/11/18 20:46:49 aaron Exp $	*/
d1656 1
a1656 1
	movl	$0,_C_LABEL(cpl)	# spl0()
@


1.61
log
@Revert niklas's broken ICU interrupt handling changes; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.59 2001/10/24 04:04:30 mickey Exp $	*/
d2096 1
d2116 31
a2146 1
	pushl	$4f
d2148 2
a2149 2
	addl	$4,%esp
#if defined(DDB) && 0
d2154 1
a2154 1
4:	.asciz	"WARNING: SPL NOT LOWERED ON SYSCALL EXIT\n"
@


1.60
log
@Redo the ICU interrupt handling system to better emulate an APIC system.
This is done by representing the current blockings of interrupts with
a priority level instead of an interrupt mask.  This makes it possible to
share implementations for spl* functions/macros between both ICU
and APIC (a must when going MP) systems.  In this process, assign
soft interrupts their own levels to match the way things will be on
APIC systems where they actually will be real interrupts and not just
bits in a pending mask as they are now.
Heavily inspired by Bill Studenmunds SMP work in NetBSD
@
text
@d1656 1
a1656 1
	movl	$IPL_NONE,_C_LABEL(cpl)	# spl0()
@


1.59
log
@use _C_LABEL for C labels
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.58 2001/09/20 11:57:18 art Exp $	*/
d1656 1
a1656 1
	movl	$0,_C_LABEL(cpl)	# spl0()
@


1.58
log
@Be much more careful about pcb_onfault.
Should solve 2026.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.57 2001/08/26 17:45:00 deraadt Exp $	*/
d123 4
a126 4
	.globl	_PTmap,_PTD,_PTDpde
	.set	_PTmap,(PDSLOT_PTE << PDSHIFT)
	.set	_PTD,(_PTmap + PDSLOT_PTE * NBPG)
	.set	_PTDpde,(_PTD + PDSLOT_PTE * 4)		# XXX 4 == sizeof pde
d132 5
a136 4
	.globl	_APTmap,_APTD,_APTDpde
	.set	_APTmap,(APTDPTDI << PDSHIFT)
	.set	_APTD,(_APTmap + APTDPTDI * NBPG)
	.set	_APTDpde,(_PTD + APTDPTDI * 4)		# XXX 4 == sizeof pde
d143 28
a170 27
	.globl	_cpu,_cpu_id,_cpu_vendor,_cpuid_level,_cpu_feature
	.globl	_cpu_cache_eax,_cpu_cache_ebx,_cpu_cache_ecx,_cpu_cache_edx
	.globl	_cold,_cnvmem,_extmem,_esym
	.globl	_boothowto,_bootdev,_atdevbase
	.globl	_proc0paddr,_curpcb,_PTDpaddr,_dynamic_gdt
	.globl	_bootapiver, _bootargc, _bootargv

_cpu:		.long	0	# are we 386, 386sx, 486, 586 or 686
_cpu_id:	.long	0	# saved from 'cpuid' instruction
_cpu_feature:	.long	0	# feature flags from 'cpuid' instruction
_cpuid_level:	.long	-1	# max. level accepted by 'cpuid' instruction
_cpu_cache_eax:	.long	0
_cpu_cache_ebx:	.long	0
_cpu_cache_ecx:	.long	0
_cpu_cache_edx:	.long	0
_cpu_vendor:	.space	16	# vendor string returned by 'cpuid' instruction
_cold:		.long	1	# cold till we are not
_esym:		.long	0	# ptr to end of syms
_cnvmem:	.long	0	# conventional memory size
_extmem:	.long	0	# extended memory size
_boothowto:	.long	0	# boot flags
_atdevbase:	.long	0	# location of start of iomem in virtual
_bootapiver:	.long	0	# /boot API version
_bootargc:	.long	0	# /boot argc
_bootargv:	.long	0	# /boot argv
_proc0paddr:	.long	0
_PTDpaddr:	.long	0	# paddr of PTD, for libkvm
d180 2
a181 2
	.globl	_kernel_text
	_kernel_text = KERNTEXTOFF
d190 1
a190 1
	movl	%eax,RELOC(_boothowto)
d192 2
a193 2
	movl	%eax,RELOC(_bootdev)
 	movl	16(%esp),%eax
d197 1
a197 6
1: 	movl	%eax,RELOC(_esym)

	movl	20(%esp),%eax
	movl	%eax,RELOC(_extmem)
	movl	24(%esp),%eax
	movl	%eax,RELOC(_cnvmem)
d200 1
a200 1
	movl	%eax,RELOC(_bootapiver)
d202 1
a202 1
	movl	%eax, RELOC(_bootargc)
d204 1
a204 1
	movl	%eax, RELOC(_bootargv)
d245 1
a245 1
	movl	$CPU_NX586,RELOC(_cpu)
d249 1
a249 1
	movl	$CPU_386,RELOC(_cpu)
d268 1
a268 1
is486:	movl	$CPU_486,RELOC(_cpu)
d287 1
a287 1
	movl	$CPU_6x86,RELOC(_cpu)	# set CPU type
d305 1
a305 1
	movl	$CPU_486DLC,RELOC(_cpu) 	# set CPU type
d369 5
a373 5
	movl	%eax,RELOC(_cpuid_level)
	movl	%ebx,RELOC(_cpu_vendor)	# store vendor string
	movl	%edx,RELOC(_cpu_vendor)+4
	movl	%ecx,RELOC(_cpu_vendor)+8
	movl	$0,  RELOC(_cpu_vendor)+12
d377 2
a378 2
	movl	%eax,RELOC(_cpu_id)	# store cpu_id and features
	movl	%edx,RELOC(_cpu_feature)
d380 1
a380 1
	movl	$RELOC(_cpuid_level),%eax
d391 4
a394 4
	movl	%eax,RELOC(_cpu_cache_eax)
	movl	%ebx,RELOC(_cpu_cache_ebx)
	movl	%ecx,RELOC(_cpu_cache_ecx)
	movl	%edx,RELOC(_cpu_cache_edx)
d417 4
a420 4
#define	PROC0PDIR	((0)              * NBPG)
#define	PROC0STACK	((1)              * NBPG)
#define	SYSMAP		((1+UPAGES)       * NBPG)
#define	TABLESIZE	((1+UPAGES) * NBPG) /* + nkpde * NBPG */
d423 3
a425 3
	movl	$RELOC(_edata),%edi
	movl	$_end,%ecx
	subl	$_edata,%ecx
d434 1
a434 1
	movl	$RELOC(_end),%edi
d437 1
a437 1
	movl	RELOC(_esym),%eax
d454 1
a454 1
	movl	RELOC(_nkpde),%ecx		# get nkpde
d462 1
a462 1
2:	
d491 1
a491 1
	leal	(RELOC(_etext)+PGOFSET),%edx
d493 1
a493 1
	
d513 1
a513 1
	movl	RELOC(_nkpde),%ecx
d529 1
a529 1
	movl	RELOC(_nkpde),%ecx			# count of pde s,
d535 1
a535 1
 * Map kernel PDEs: this is the real mapping used 
d538 1
a538 1
	movl	RELOC(_nkpde),%ecx			# count of pde s,
d548 1
a548 1
	movl	%esi,RELOC(_PTDpaddr)
d563 1
a563 1
	movl	_nkpde,%ecx		# for this many pde s,
d571 1
a571 1
	movl	_nkpde,%edx
d575 1
a575 1
	movl	%edx,_atdevbase
d579 1
a579 1
	movl	%eax,_proc0paddr
d582 1
a582 1
	xorl	%ebp,%ebp               # mark end of frames
d584 1
a584 1
	movl	_nkpde,%eax
d589 1
a589 1
	call	_init386		# wire 386 chip for unix operation
d597 1
a597 1
	call 	_main
d626 1
a626 1
	int	$0x80	 		# enter kernel with args on stack
d629 2
a630 2
	.globl	_esigcode
_esigcode:
d648 1
a648 1
	pushl	$1			# setcontext(p) == syscontext(1, p) 
d651 1
a651 1
	int	$0x80	 		# enter kernel with args on stack
d654 2
a655 2
	.globl	_svr4_esigcode
_svr4_esigcode:
d678 1
a678 1
	int	$0x80	 		# enter kernel with args on stack
d681 2
a682 2
	.globl	_linux_esigcode
_linux_esigcode:
d698 1
a698 1
	int	$0x80	 		# enter kernel with args on stack
d701 2
a702 2
	.globl	_freebsd_esigcode
_freebsd_esigcode:
d846 1
a846 1
	jmp	_bcopy
d877 1
a877 1
	jc	_copy_fault
d879 1
a879 1
	ja	_copy_fault
d883 1
a883 1
	cmpl	$CPUCLASS_386,_cpu_class
d906 1
a906 1
	testb	$PG_RW,_PTmap(,%edi,4)
d908 1
a908 1
	
d915 1
a915 1
	
d922 1
a922 1
	call	_trapwrite		# trapwrite(addr)
d928 1
a928 1
	jmp	_copy_fault
d973 1
a973 1
	jc	_copy_fault
d975 1
a975 1
	ja	_copy_fault
d1013 2
a1014 2
	movl	_curpcb,%ecx
	movl	$_copystr_fault,PCB_ONFAULT(%ecx)
d1022 1
a1022 1
	cmpl	$CPUCLASS_386,_cpu_class
d1041 1
a1041 1
	jae	_copystr_fault
d1043 1
a1043 1
	testb	$PG_RW,_PTmap(,%eax,4)
d1050 1
a1050 1
	call	_trapwrite		# trapwrite(addr)
d1055 1
a1055 1
	jnz	_copystr_fault
d1117 1
a1117 1
	jae	_copystr_fault
d1132 2
a1133 2
	movl	_curpcb,%ecx
	movl	$_copystr_fault,PCB_ONFAULT(%ecx)
d1166 1
a1166 1
	jae	_copystr_fault
d1173 1
a1173 1
copystr_return:	
d1175 1
a1175 1
	movl	_curpcb,%ecx
d1238 3
a1240 3
	ja	_fusuaddrfault
	movl	_curpcb,%ecx
	movl	$_fusufault,PCB_ONFAULT(%ecx)
d1244 1
a1244 1
	
d1252 3
a1254 3
	ja	_fusuaddrfault
	movl	_curpcb,%ecx
	movl	$_fusufault,PCB_ONFAULT(%ecx)
d1258 1
a1258 1
	
d1267 3
a1269 3
	ja	_fusuaddrfault
	movl	_curpcb,%ecx
	movl	$_fusubail,PCB_ONFAULT(%ecx)
d1273 1
a1273 1
	
d1281 3
a1283 3
	ja	_fusuaddrfault
	movl	_curpcb,%ecx
	movl	$_fusufault,PCB_ONFAULT(%ecx)
d1320 3
a1322 3
	ja	_fusuaddrfault
	movl	_curpcb,%ecx
	movl	$_fusufault,PCB_ONFAULT(%ecx)
d1326 1
a1326 1
	cmpl	$CPUCLASS_386,_cpu_class
d1332 1
a1332 1
	testb	$PG_RW,_PTmap(,%eax,4)
d1338 1
a1338 1
	call	_trapwrite		# trapwrite(addr)
d1341 1
a1341 1
	movl	_curpcb,%ecx
d1343 1
a1343 1
	jnz	_fusufault
d1353 1
a1353 1
	
d1361 3
a1363 3
	ja	_fusuaddrfault
	movl	_curpcb,%ecx
	movl	$_fusufault,PCB_ONFAULT(%ecx)
d1367 1
a1367 1
	cmpl	$CPUCLASS_386,_cpu_class
d1373 1
a1373 1
	testb	$PG_RW,_PTmap(,%eax,4)
d1379 1
a1379 1
	call	_trapwrite		# trapwrite(addr)
d1382 1
a1382 1
	movl	_curpcb,%ecx
d1384 1
a1384 1
	jnz	_fusufault
d1403 3
a1405 3
	ja	_fusuaddrfault
	movl	_curpcb,%ecx
	movl	$_fusubail,PCB_ONFAULT(%ecx)
d1409 1
a1409 1
	cmpl	$CPUCLASS_386,_cpu_class
d1415 1
a1415 1
	testb	$PG_RW,_PTmap(,%eax,4)
d1419 1
a1419 1
	jmp	_fusubail
d1437 3
a1439 3
	ja	_fusuaddrfault
	movl	_curpcb,%ecx
	movl	$_fusufault,PCB_ONFAULT(%ecx)
d1443 1
a1443 1
	cmpl	$CPUCLASS_386,_cpu_class
d1449 1
a1449 1
	testb	$PG_RW,_PTmap(,%eax,4)
d1455 1
a1455 1
	call	_trapwrite		# trapwrite(addr)
d1458 1
a1458 1
	movl	_curpcb,%ecx
d1460 1
a1460 1
	jnz	_fusufault
d1528 5
a1532 6
 * _whichqs tells which of the 32 queues _qs
 * have processes in them.  Setrq puts processes into queues, Remrq
 * removes them from queues.  The running process is on no queue,
 * other processes are on a queue related to p->p_pri, divided by 4
 * actually to shrink the 0-127 range of priorities into the 32 available
 * queues.
a1534 1
	
d1551 2
a1552 2
	btsl	%edx,_whichqs		# set q full bit
	leal	_qs(,%edx,8),%edx	# locate q hdr
d1561 1
a1561 1
	call	_panic
d1575 1
a1575 1
	btl	%eax,_whichqs
d1588 1
a1588 1
	btrl	%eax,_whichqs		# no; clear bit
d1592 1
a1592 1
	call	_panic
d1598 1
a1598 1
	.globl _apm_cpu_idle,_apm_cpu_busy,_apm_dobusy
d1606 1
a1606 1
	movl	_whichqs,%ecx
d1611 2
a1612 2
	call	_apm_cpu_idle
	cmpl	$0,_apm_dobusy
d1614 1
a1614 1
	call	_apm_cpu_busy
d1618 2
a1619 2
	addl	$1,_pctr_idlcnt
	adcl	$0,_pctr_idlcnt+4
d1623 1
a1623 1
	jmp	_idle
d1628 1
a1628 1
	call	_panic
d1643 1
a1643 1
	pushl	_cpl
d1645 1
a1645 1
	movl	_curproc,%esi
d1654 1
a1654 1
	movl	$0,_curproc
d1656 2
a1657 2
	movl	$0,_cpl			# spl0()
	call	_Xspllower		# process pending interrupts
d1674 1
a1674 1
	movl	_whichqs,%ecx
d1677 1
a1677 1
	jz	_idle			# if none, idle
d1679 1
a1679 1
	leal	_qs(,%ebx,8),%eax	# select q
d1684 1
a1684 1
	je	_switch_error		# not possible
d1694 1
a1694 1
	movl	%ecx,_whichqs		# update q status
d1698 1
a1698 1
	movl	%eax,_want_resched
d1702 1
a1702 1
	jne	_switch_error		# Yes; shouldn't be queued.
d1704 1
a1704 1
	jne	_switch_error		# No; shouldn't be queued.
d1711 1
a1711 1
	movl	%edi,_curproc
d1770 1
a1770 1
	movl	_dynamic_gdt,%eax
d1805 1
a1805 1
	movl	%esi,_curpcb
d1815 1
a1815 1
	popl	_cpl
d1832 1
a1832 1
	movl	$_proc0,%ebx
d1835 1
a1835 1
	movl	$0,_curproc
d1846 1
a1846 1
	movl	_dynamic_gdt,%eax
d1869 1
a1869 1
	movl	%esi,_curpcb
d1877 3
a1879 3
	pushl   %edi			/* exit2(p) */
	call    _C_LABEL(exit2)
	addl    $4,%esp
d1883 1
a1883 1
	movl	$0,_curproc
d1892 1
a1892 1
  
d1919 1
a1919 1
 */ 
d1922 1
a1922 1
#define	TRAP(a)		pushl $(a) ; jmp _alltraps
d1955 2
a1956 2
	pushl	_curproc
	call	_npxdna
d1983 1
a1983 1
	subl	_idt,%eax
d2003 1
a2003 1
	pushl	_cpl			# if_ppl in intrframe
d2006 1
a2006 1
	call	_npxintr
d2035 1
a2035 1
	movl	_cpl,%ebx
d2037 1
a2037 1
	call	_trap
d2040 1
a2040 1
	cmpb	$0,_astpending
d2048 1
a2048 1
5:	movb	$0,_astpending
d2051 1
a2051 1
	call	_trap
d2056 1
a2056 1
1:	cmpl	_cpl,%ebx
d2061 1
a2061 1
	call	_printf
d2066 1
a2066 1
	movl	%ebx,_cpl
d2095 1
a2095 1
	movl	_cpl,%ebx
d2097 1
a2097 1
	call	_syscall
d2100 1
a2100 1
	cmpb	$0,_astpending
d2103 1
a2103 1
	movb	$0,_astpending
d2106 1
a2106 1
	call	_trap
d2111 1
a2111 1
1:	cmpl	_cpl,%ebx
d2116 1
a2116 1
	call	_printf
d2121 1
a2121 1
	movl	%ebx,_cpl
d2159 1
a2159 1
	cmpl	$CPUCLASS_486,_cpu_class
@


1.57
log
@do not panic if spl is wrong, for now; millert & art agree
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.56 2001/05/17 00:18:19 fgsch Exp $	*/
d865 1
a865 2
	movl	_curpcb,%eax
	movl	$_copy_fault,PCB_ONFAULT(%eax)
d867 3
a869 3
	movl	12(%esp),%esi
	movl	16(%esp),%edi
	movl	20(%esp),%eax
d934 4
a937 1
3:	/* bcopy(%esi, %edi, %eax); */
a946 1
	xorl	%eax,%eax
d948 1
d951 1
a951 2
	movl	_curpcb,%edx
	movl	%eax,PCB_ONFAULT(%edx)
d961 3
a963 2
	movl	_curpcb,%eax
	movl	$_copy_fault,PCB_ONFAULT(%eax)
d965 3
a967 3
	movl	12(%esp),%esi
	movl	16(%esp),%edi
	movl	20(%esp),%eax
a989 1
	xorl	%eax,%eax
d991 2
d995 1
a995 2
	movl	_curpcb,%edx
	movl	%eax,PCB_ONFAULT(%edx)
d999 2
a1002 2
	movl	_curpcb,%edx
	movl	$0,PCB_ONFAULT(%edx)
@


1.56
log
@remove bcopyb and bcopyw, they're not used nowdays; mickey@@ aaron@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.55 2001/05/05 23:25:37 art Exp $	*/
d2066 1
a2066 1
#ifdef DDB
d2121 1
a2121 1
#ifdef DDB
@


1.55
log
@PMAP_NEW and UVM are no longer optional on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.54 2001/03/22 23:36:51 niklas Exp $	*/
a737 32
 * bcopyb(caddr_t from, caddr_t to, size_t len);
 * Copy len bytes, one byte at a time.
 */
ENTRY(bcopyb)
	pushl	%esi
	pushl	%edi
	movl	12(%esp),%esi
	movl	16(%esp),%edi
	movl	20(%esp),%ecx
	cmpl	%esi,%edi		# potentially overlapping?
	jnb	1f
	cld				# no; copy forward
	rep
	movsb
	popl	%edi
	popl	%esi
	ret

	ALIGN_TEXT
1:	addl	%ecx,%edi		# copy backward
	addl	%ecx,%esi
	std
	decl	%edi
	decl	%esi
	rep
	movsb
	popl	%edi
	popl	%esi
	cld
	ret

/*
a794 43
/*
 * bcopyw(caddr_t from, caddr_t to, size_t len);
 * Copy len bytes, two bytes at a time.
 */
ENTRY(bcopyw)
	pushl	%esi
	pushl	%edi
	movl	12(%esp),%esi
	movl	16(%esp),%edi
	movl	20(%esp),%ecx
	cmpl	%esi,%edi		# potentially overlapping?
	jnb	1f
	cld				# no; copy forward
	shrl	$1,%ecx			# copy by 16-bit words
	rep
	movsw
	adc	%ecx,%ecx		# any bytes left?
	rep
	movsb
	popl	%edi
	popl	%esi
	ret

	ALIGN_TEXT
1:	addl	%ecx,%edi		# copy backward
	addl	%ecx,%esi
	std
	andl	$1,%ecx			# any fractional bytes?
	decl	%edi
	decl	%esi
	rep
	movsb
	movl	20(%esp),%ecx		# copy remainder by 16-bit words
	shrl	$1,%ecx
	decl	%esi
	decl	%edi
	rep
	movsw
	popl	%edi
	popl	%esi
	cld
	ret

@


1.54
log
@Merge in NetBSD's PMAP_NEW, still disabled
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.53 2001/01/24 09:37:58 hugh Exp $	*/
a123 1
#ifdef PMAP_NEW
a126 7
#else
	.set	_PTmap,(PTDPTDI << PDSHIFT)
	.set	_PTD,(_PTmap + PTDPTDI * NBPG)
	.set	_PTDpde,(_PTD + PTDPTDI * 4)		# XXX 4 == sizeof pde
	.globl	_Sysmap
	.set	_Sysmap,(_PTmap + KPTDI * NBPG)
#endif
a422 1
#ifdef PMAP_NEW
a423 3
#else
#define	TABLESIZE	((1+UPAGES+NKPDE) * NBPG)
#endif
a452 1
#ifdef PMAP_NEW
a472 5
#else
	/* Clear memory for bootstrap tables. */
	movl	%esi, %edi
	movl	$((TABLESIZE + 3) >> 2), %ecx	# size of tables
#endif
a515 1
#ifdef PMAP_NEW
a519 3
#else
	leal	(TABLESIZE)(%esi),%ecx			# end of tables
#endif
a531 1
#ifdef PMAP_NEW
a535 13
#else
/*
 * Install a PDE for temporary double map of kernel text.
 * Maps two pages, in case the kernel is larger than 4M.
 * XXX: should the number of pages to map be decided at run-time?
 */
	leal	(SYSMAP+PG_V|PG_KW)(%esi),%eax		# calc Sysmap physaddr
	movl	%eax,(PROC0PDIR+0*4)(%esi)		# map it in
	addl	$NBPG, %eax				# 2nd Sysmap page
	movl	%eax,(PROC0PDIR+1*4)(%esi)		# map it too
	/* code below assumes %eax == sysmap physaddr, so we adjust it back */
	subl	$NBPG, %eax
#endif
a540 1
#ifdef PMAP_NEW
a543 4
#else
	movl	$NKPDE,%ecx				# count of pde's
	leal	(PROC0PDIR+KPTDI*4)(%esi),%ebx		# map them high
#endif
a547 1
#ifdef PMAP_NEW
a548 3
#else
	movl	%eax,(PROC0PDIR+PTDPTDI*4)(%esi)	# phys addr from above
#endif
a565 1
#ifdef PMAP_NEW
a571 4
#else
	movl	$0,(PROC0PDIR+0*4)(%esi)
	movl	$0,(PROC0PDIR+1*4)(%esi)
#endif
a573 1
#ifdef PMAP_NEW
a577 3
#else
	leal	(TABLESIZE+KERNBASE)(%esi),%edx
#endif
a586 1
#ifdef PMAP_NEW
a590 3
#else
	leal	(TABLESIZE)(%esi),%eax	# skip past stack and page tables
#endif
a768 1
#if defined(UVM)
a825 1
#endif
a1610 1
#ifdef UVM
a1611 3
#else
	.globl	_whichqs,_qs,_cnt,_panic
#endif
a1905 1
#if defined(UVM)
a1907 3
#else
	.globl	_proc0,_vmspace_free,_kernel_map,_kmem_free,_tss_free
#endif
a2082 1
#if defined(UVM)
a2083 3
#else
	incl	_cnt+V_TRAP
#endif
@


1.53
log
@KGDB for i386 from NetBSD via niklas, with tweaks and accommodations.
Tested by various, vetted by mickey & theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.52 2000/06/16 19:11:25 millert Exp $	*/
d123 6
a128 1
	.globl	_PTmap,_PTD,_PTDpde,_Sysmap
d132 1
d134 1
d431 3
d435 1
d449 1
a449 1
	movl	$RELOC(_end),%esi
d456 1
a456 1
	movl	%eax,%esi
d461 1
d465 22
d490 1
d534 6
d541 1
d553 8
a560 1
 *
d571 1
d577 5
d584 1
d589 3
d593 1
d611 8
d621 1
d624 6
d631 1
d641 6
d648 1
@


1.52
log
@Cannot emulate memcmp() with bcmp() due to different return values;
memcmp() will be added to libkern.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.51 2000/06/05 11:02:54 art Exp $	*/
a1986 4
#ifdef KGDB
#define	BPTTRAP(a)	testb $(PSL_I>>8),13(%esp) ; jz 1f ; sti ; 1: ; \
			pushl $(a) ; jmp _bpttraps
#else
a1988 1
#endif
a2136 13

#ifdef KGDB
/*
 * This code checks for a kgdb trap, then falls through
 * to the regular trap code.
 */
NENTRY(bpttraps)
	INTRENTRY
	testb	$SEL_RPL,TF_CS(%esp)
	jne	calltrap
	call	_kgdb_trap_glue		
	jmp	calltrap
#endif /* KGDB */
@


1.51
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.50 2000/05/01 00:43:41 mickey Exp $	*/
a901 9

/*
 * Emulate memcmp() by swapping the first two arguments and calling bcmp()
 */
ENTRY(memcmp)
	movl	4(%esp),%ecx
	xchg	8(%esp),%ecx
	movl	%ecx,4(%esp)
	jmp	_bcmp
@


1.50
log
@cleaner and righter memcmp/memcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.49 2000/04/30 18:48:58 millert Exp $	*/
d1946 6
a1951 18
	/* Thoroughly nuke the old process's resources. */
	pushl	P_ADDR(%edi)
	call	_tss_free
	pushl	P_VMSPACE(%edi)
#if defined(UVM)
	call	_C_LABEL(uvmspace_free)
#else
	call	_vmspace_free
#endif
	pushl	$USPACE
	pushl	P_ADDR(%edi)
	pushl	_kernel_map
#if defined(UVM)
	call	_C_LABEL(uvm_km_free)
#else
	call	_kmem_free
#endif
	addl	$20,%esp
@


1.49
log
@Add memcpy() and memcmp() emulation by swapping the first 2 args
and then calling the b* routine.  This code only gets call when the
kernel is build w/o -O* since otherwise gcc uses its own inline
routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48 1999/03/08 23:47:26 downsj Exp $	*/
d898 4
a901 8
	pushl	%esi
	movl	12(%esp),%ecx
	movl	16(%esp),%esi
	movl	%esi,12(%esp)
	movl	%ecx,16(%esp)
	call	_bcopy
	popl	%esi
	ret
d907 4
a910 8
	pushl	%esi
	movl	12(%esp),%ecx
	movl	16(%esp),%esi
	movl	%esi,12(%esp)
	movl	%ecx,16(%esp)
	call	_bcmp
	popl	%esi
	ret
@


1.48
log
@Add support for CPUID level 2.  This is used to determine the L2 cache size
on Intel processors; print out the correct CPU name and cache size at boot.

Also clean up the feature flags, including PPro errata.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.47 1999/02/26 04:34:31 art Exp $	*/
d892 26
@


1.48.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.54 2001/03/22 23:36:51 niklas Exp $	*/
d123 1
a123 6
	.globl	_PTmap,_PTD,_PTDpde
#ifdef PMAP_NEW
	.set	_PTmap,(PDSLOT_PTE << PDSHIFT)
	.set	_PTD,(_PTmap + PDSLOT_PTE * NBPG)
	.set	_PTDpde,(_PTD + PDSLOT_PTE * 4)		# XXX 4 == sizeof pde
#else
a126 1
	.globl	_Sysmap
a127 1
#endif
a423 3
#ifdef PMAP_NEW
#define	TABLESIZE	((1+UPAGES) * NBPG) /* + nkpde * NBPG */
#else
a424 1
#endif
d438 1
a438 1
	movl	$RELOC(_end),%edi
d445 1
a445 1
	movl	%eax,%edi
a449 1
	movl	%edi,%esi			# edi = esym ? esym : end
a452 22
#ifdef PMAP_NEW
	/*
	 * Calculate the size of the kernel page table directory, and
	 * how many entries it will have.
	 */
	movl	RELOC(_nkpde),%ecx		# get nkpde
	cmpl	$NKPTP_MIN,%ecx			# larger than min?
	jge	1f
	movl	$NKPTP_MIN,%ecx			# set at min
	jmp	2f
1:	cmpl	$NKPTP_MAX,%ecx			# larger than max?
	jle	2f
	movl	$NKPTP_MAX,%ecx
2:	

	/* Clear memory for bootstrap tables. */
	shll	$PGSHIFT,%ecx
	addl	$TABLESIZE,%ecx
	addl	%esi,%ecx			# end of tables
	subl	%edi,%ecx			# size of tables
	shrl	$2,%ecx
#else
a455 1
#endif
a498 6
#ifdef PMAP_NEW
	movl	RELOC(_nkpde),%ecx
	shll	$PGSHIFT,%ecx
	addl	$TABLESIZE,%ecx
	addl	%esi,%ecx				# end of tables
#else
a499 1
#endif
d511 1
a511 8
*/
#ifdef PMAP_NEW
	movl	RELOC(_nkpde),%ecx			# count of pde s,
	leal	(PROC0PDIR+0*4)(%esi),%ebx		# where temp maps!
	leal	(SYSMAP+PG_V|PG_KW)(%esi),%eax		# pte for KPT in proc 0
	fillkpt
#else
/*
a521 1
#endif
a526 5
#ifdef PMAP_NEW
	movl	RELOC(_nkpde),%ecx			# count of pde s,
	leal	(PROC0PDIR+PDSLOT_KERN*4)(%esi),%ebx	# map them high
	leal	(SYSMAP+PG_V|PG_KW)(%esi),%eax		# pte for KPT in proc 0
#else
a528 1
#endif
a532 3
#ifdef PMAP_NEW
	movl	%eax,(PROC0PDIR+PDSLOT_PTE*4)(%esi)	# recursive PD slot
#else
a533 1
#endif
a550 8
#ifdef PMAP_NEW
	movl	_nkpde,%ecx		# for this many pde s,
	leal	(PROC0PDIR+0*4)(%esi),%ebx	# which is where temp maps!
	addl	$(KERNBASE), %ebx	# now use relocated address
1:	movl	$0,(%ebx)
	addl	$4,%ebx	# next pde
	loop	1b
#else
a552 1
#endif
a554 6
#ifdef PMAP_NEW
	movl	_nkpde,%edx
	shll	$PGSHIFT,%edx
	addl	$(TABLESIZE+KERNBASE),%edx
	addl	%esi,%edx
#else
a555 1
#endif
a564 6
#ifdef PMAP_NEW
	movl	_nkpde,%eax
	shll	$PGSHIFT,%eax
	addl	$TABLESIZE,%eax
	addl	%esi,%eax		# skip past stack and page tables
#else
a565 1
#endif
a893 9
/*
 * Emulate memcpy() by swapping the first two arguments and calling bcopy()
 */
ENTRY(memcpy)
	movl	4(%esp),%ecx
	xchg	8(%esp),%ecx
	movl	%ecx,4(%esp)
	jmp	_bcopy

d1928 18
a1945 6
	/*
	 * Schedule the dead process's vmspace and stack to be freed.
	 */
	pushl   %edi			/* exit2(p) */
	call    _C_LABEL(exit2)
	addl    $4,%esp
d1990 4
d1996 1
d2145 13
@


1.48.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.1 2001/04/18 16:07:19 niklas Exp $	*/
d124 1
d128 7
d431 1
d433 3
d465 1
d486 5
d534 1
d539 3
d554 1
d559 13
d577 1
d581 4
d589 1
d591 3
d611 1
d618 4
d624 1
d629 3
d641 1
d646 3
d796 33
d885 1
d888 43
d1671 1
d1673 3
d1970 1
d1973 3
d2151 1
d2153 3
@


1.48.6.3
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.2 2001/07/04 10:16:36 niklas Exp $	*/
a45 2
#include "lapic.h"
#include "ioapic.h"
a69 4
#if NLAPIC > 0 
#include <machine/i82489reg.h>
#endif

a88 65
#define CPL _C_LABEL(lapic_tpr)

#if defined(MULTIPROCESSOR)
#include <machine/i82489reg.h>

#define	GET_CPUINFO(reg)				\
	movzbl	_C_LABEL(lapic_id)+3,reg	;	\
	movl	_C_LABEL(cpu_info)(,reg,4),reg

#define	GET_CURPROC(reg, treg)				\
	GET_CPUINFO(treg)			;	\
	movl	CPU_INFO_CURPROC(treg),reg

#define	PUSH_CURPROC(treg)				\
	GET_CPUINFO(treg)			;	\
	pushl	CPU_INFO_CURPROC(treg)
       
#define	CLEAR_CURPROC(treg)				\
	GET_CPUINFO(treg)			;	\
	movl	$0,CPU_INFO_CURPROC(treg)
       
#define	SET_CURPROC(proc,cpu)				\
	GET_CPUINFO(cpu)			;	\
	movl	proc,CPU_INFO_CURPROC(cpu)	;	\
	movl	cpu,P_CPU(proc)
       
#define	GET_CURPCB(reg)					\
	GET_CPUINFO(reg)			;	\
	movl	CPU_INFO_CURPCB(reg),reg

#define	SET_CURPCB(reg,treg)				\
	GET_CPUINFO(treg)			;	\
	movl	reg,CPU_INFO_CURPCB(treg)

#define	CLEAR_RESCHED(treg)				\
	GET_CPUINFO(treg)			;	\
	xorl	%eax,%eax			;	\
	movl	%eax,CPU_INFO_RESCHED(treg)

#define	CHECK_ASTPENDING(treg)				\
	GET_CPUINFO(treg)			;	\
	cmpl	$0,CPU_INFO_ASTPENDING(treg)
               
#define	CLEAR_ASTPENDING(cireg)				\
	movl	$0,CPU_INFO_ASTPENDING(cireg)

#else

#define	GET_CURPROC(reg,treg)		movl	_C_LABEL(curproc),reg
#define	CLEAR_CURPROC(treg)		movl	$0,_C_LABEL(curproc)
#define	SET_CURPROC(reg,treg)		movl	reg,_C_LABEL(curproc)
#define	PUSH_CURPROC(treg)		pushl	_C_LABEL(curproc)

#define	GET_CURPCB(reg)			movl	_C_LABEL(curpcb),reg    
#define	SET_CURPCB(reg,treg)		movl	reg,_C_LABEL(curpcb)

#define	CHECK_ASTPENDING(treg)		cmpb	$0,_C_LABEL(astpending) 
#define	CLEAR_ASTPENDING(treg)		movb	$0,_C_LABEL(astpending)
       
#define	CLEAR_RESCHED(treg)				\
	xorl	%eax,%eax			;	\
	movl	%eax,_C_LABEL(want_resched)	; 
       
#endif

d146 1
a146 1
	.globl	_proc0paddr,_PTDpaddr,_dynamic_gdt
a147 27
#ifndef MULTIPROCESSOR
	.globl	_curpcb
#endif
	.globl	_lapic_tpr

#if NLAPIC > 0
#ifdef __ELF__
	.align NBPG
#else
	.align 12
#endif
	.globl _local_apic,_lapic_id
_local_apic:
	.space	LAPIC_ID
_lapic_id:
	.long	0x00000000
	.space	LAPIC_TPRI-(LAPIC_ID+4)
_lapic_tpr:
	.space	LAPIC_PPRI-LAPIC_TPRI
_lapic_ppr:
	.space	LAPIC_ISR-LAPIC_PPRI
_lapic_isr:
	.space	NBPG-LAPIC_ISR
#else
_lapic_tpr:
	.long	0
#endif
a605 1
	movl	$0,CPL
d744 1
a744 1
	GET_CURPCB(%eax)		# load curpcb into eax and set on-fault
d764 1
a764 1
	GET_CURPCB(%edx)		# XXX save curpcb?
d788 1
a788 1
	GET_CURPCB(%edx)
d865 1
a865 1
	GET_CURPCB(%eax)
a908 3
	GET_CURPCB(%edx)
	movl	$_C_LABEL(copy_fault),PCB_ONFAULT(%edx)

d935 1
a935 4
3:	GET_CURPCB(%edx)
	movl    $_C_LABEL(copy_fault),PCB_ONFAULT(%edx)

	/* bcopy(%esi, %edi, %eax); */
d949 1
a949 1
	GET_CURPCB(%edx)
d960 1
a960 1
	GET_CURPCB(%eax)
d992 1
a992 1
	GET_CURPCB(%edx)
d999 1
a999 1
	GET_CURPCB(%edx)
d1014 1
a1014 1
	GET_CURPCB(%ecx)
a1032 3
	GET_CURPCB(%eax)
	movl	$6f,PCB_ONFAULT(%eax)

d1091 1
a1091 3
5:	GET_CURPCB(%eax)
	movl	$_C_LABEL(copystr_fault),PCB_ONFAULT(%eax)
	/*
d1133 1
a1133 1
	GET_CURPCB(%ecx)
d1176 1
a1176 1
	GET_CURPCB(%ecx)
d1240 1
a1240 1
	GET_CURPCB(%ecx)
d1254 1
a1254 1
	GET_CURPCB(%ecx)
d1269 1
a1269 1
	GET_CURPCB(%ecx)
d1283 1
a1283 1
	GET_CURPCB(%ecx)
d1322 1
a1322 1
	GET_CURPCB(%ecx)
d1342 1
a1342 1
	GET_CURPCB(%ecx)
d1349 1
a1349 4
2:	GET_CURPCB(%ecx)
	movl	$_C_LABEL(fusufault),PCB_ONFAULT(%ecx)

	movl	8(%esp),%eax
d1363 1
a1363 1
	GET_CURPCB(%ecx)
d1383 1
a1383 1
	GET_CURPCB(%ecx)
d1390 1
a1390 4
2:	GET_CURPCB(%ecx)
	movl	$_C_LABEL(fusufault),PCB_ONFAULT(%ecx)

	movl	8(%esp),%eax
d1405 1
a1405 1
	GET_CURPCB(%ecx)
d1439 1
a1439 1
	GET_CURPCB(%ecx)
d1459 1
a1459 1
	GET_CURPCB(%ecx)
d1466 1
a1466 4
2:	GET_CURPCB(%ecx)
	movl	$_C_LABEL(fusufault),PCB_ONFAULT(%ecx)

	movb	8(%esp),%al
d1646 1
a1646 1
	pushl	CPL
d1648 1
a1648 1
	GET_CURPROC(%esi,%ecx)
d1657 1
a1657 1
	CLEAR_CURPROC(%ecx)
d1659 1
a1659 1
	movl	$0,CPL			# spl0()
d1677 1
a1677 1
	movl	_whichqs,%ecx		# XXX MP
d1700 2
a1701 1
	CLEAR_RESCHED(%ecx)
d1808 1
a1808 1
	SET_CURPCB(%esi, %ecx)
d1818 1
a1818 1
	popl	CPL
d1828 2
a1829 3
 * Switch to the appropriate idle context (proc0's if uniprocessor; the cpu's if
 * multiprocessor) and deallocate the address space and kernel stack for p.
 * Then jump into cpu_switch(), as if we were in the idle proc all along.
d1831 1
a1831 1
	.globl	_C_LABEL(uvmspace_free),_C_LABEL(kernel_map)
a1832 3
#ifndef MULTIPROCESSOR
	.globl	_C_LABEL(proc0)
#endif
a1834 1
#ifndef MULTIPROCESSOR
a1835 5
	movl	P_ADDR(%ebx,%esi)
#else
	GET_CPUINFO(%ebx)
	movl	CPU_INFO_IDLE_PCB(%ebx),%esi
#endif
d1838 1
a1838 1
	CLEAR_CURPROC(%ecx)
d1840 1
a1840 1
	/* Restore the idle context. */
d1842 1
d1872 1
a1872 1
	SET_CURPCB(%esi, %ecx)
d1885 2
a1886 2
	xorl	%esi,%esi
	CLEAR_CURPROC(%ecx)
d1958 1
a1958 6
#ifdef MULTIPROCESSOR
	GET_CPUINFO(%eax)
	pushl	%eax
#else
	pushl	_C_LABEL(cpu_info_store)
#endif
a1995 12
#if 0
IDTVEC(intrspurios)
	/*
	 * The Pentium Pro local APIC may erroneously call this vector for a
	 * default IR7.  Just ignore it.
	 *
	 * (The local APIC does this when CPL is raised while it's on the 
	 * way to delivering an interrupt.. presumably enough has been set 
	 * up that it's inconvenient to abort delivery completely..)
	 */
	iret
#endif
d2006 1
a2006 1
	pushl	CPL			# if_ppl in intrframe
d2038 1
a2038 1
	movl	CPL,%ebx
d2043 1
a2043 1
	CHECK_ASTPENDING(%ecx)
d2051 1
a2051 1
5:	CLEAR_ASTPENDING(%ecx)
d2058 2
a2059 2
#else 
1:	cmpl	CPL,%ebx
d2069 1
a2069 1
	movl	%ebx,CPL
d2098 1
a2098 10
	movzbl	CPL,%ebx
	testl	%ebx,%ebx
	jz	1f
	pushl	$5f
	call	_printf
	addl	$4,%esp
#ifdef DDB
	int	$3
#endif
1:
d2103 1
a2103 1
	CHECK_ASTPENDING(%ecx)
d2106 1
a2106 1
	CLEAR_ASTPENDING(%ecx)
d2114 1
a2114 1
1:	cmpl	CPL,%ebx
d2124 1
a2124 1
	movl	%ebx,CPL
a2126 1
5:	.asciz	"WARNING: SPL NOT ZERO ON SYSCALL ENTRY\n"
a2202 4

#if NLAPIC > 0 
#include <i386/i386/apicvec.s>
#endif
@


1.48.6.4
log
@curproc is per-cpu in MULTIPROCESSOR
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1832 1
a1832 1
	SET_CURPROC(%edi,%ecx)
@


1.48.6.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.4 2001/10/27 09:47:29 niklas Exp $	*/
d194 4
a197 4
	.globl	_C_LABEL(PTmap), _C_LABEL(PTD), _C_LABEL(PTDpde)
	.set	_C_LABEL(PTmap), (PDSLOT_PTE << PDSHIFT)
	.set	_C_LABEL(PTD), (_C_LABEL(PTmap) + PDSLOT_PTE * NBPG)
	.set	_C_LABEL(PTDpde), (_C_LABEL(PTD) + PDSLOT_PTE * 4)	# XXX 4 == sizeof pde
d203 4
a206 5
	.globl	_C_LABEL(APTmap), _C_LABEL(APTD), _C_LABEL(APTDpde)
	.set	_C_LABEL(APTmap), (APTDPTDI << PDSHIFT)
	.set	_C_LABEL(APTD), (_C_LABEL(APTmap) + APTDPTDI * NBPG)
	# XXX 4 == sizeof pde
	.set	_C_LABEL(APTDpde), (_C_LABEL(PTD) + APTDPTDI * 4)
d213 6
a218 10
	.globl	_C_LABEL(cpu), _C_LABEL(cpu_id), _C_LABEL(cpu_vendor)
	.globl	_C_LABEL(cpuid_level), _C_LABEL(cpu_feature)
	.globl	_C_LABEL(cpu_cache_eax), _C_LABEL(cpu_cache_ebx)
	.globl	_C_LABEL(cpu_cache_ecx), _C_LABEL(cpu_cache_edx)
	.globl	_C_LABEL(cold), _C_LABEL(cnvmem), _C_LABEL(extmem)
	.globl	_C_LABEL(esym)
	.globl	_C_LABEL(boothowto), _C_LABEL(bootdev), _C_LABEL(atdevbase)
	.globl	_C_LABEL(proc0paddr), _C_LABEL(PTDpaddr)
	.globl	_C_LABEL(dynamic_gdt)
	.globl	_C_LABEL(bootapiver), _C_LABEL(bootargc), _C_LABEL(bootargv)
d220 1
a220 1
	.globl	_C_LABEL(curpcb)
d222 1
a222 1
	.globl	_C_LABEL(lapic_tpr)
d230 2
a231 2
	.globl _C_LABEL(local_apic), _C_LABEL(lapic_id)
_C_LABEL(local_apic):
d233 1
a233 1
_C_LABEL(lapic_id):
d236 1
a236 1
_C_LABEL(lapic_tpr):
d238 1
a238 1
_C_LABEL(lapic_ppr):
d240 1
a240 1
_C_LABEL(lapic_isr):
d243 1
a243 1
_C_LABEL(lapic_tpr):
d247 20
a266 20
_C_LABEL(cpu):		.long	0	# are we 386, 386sx, 486, 586 or 686
_C_LABEL(cpu_id):	.long	0	# saved from 'cpuid' instruction
_C_LABEL(cpu_feature):	.long	0	# feature flags from 'cpuid' insn
_C_LABEL(cpuid_level):	.long	-1	# max. level accepted by 'cpuid' insn
_C_LABEL(cpu_cache_eax):.long	0
_C_LABEL(cpu_cache_ebx):.long	0
_C_LABEL(cpu_cache_ecx):.long	0
_C_LABEL(cpu_cache_edx):.long	0
_C_LABEL(cpu_vendor): .space 16 # vendor string returned by 'cpuid' instruction
_C_LABEL(cold):		.long	1	# cold till we are not
_C_LABEL(esym):		.long	0	# ptr to end of syms
_C_LABEL(cnvmem):	.long	0	# conventional memory size
_C_LABEL(extmem):	.long	0	# extended memory size
_C_LABEL(boothowto):	.long	0	# boot flags
_C_LABEL(atdevbase):	.long	0	# location of start of iomem in virtual
_C_LABEL(bootapiver):	.long	0	# /boot API version
_C_LABEL(bootargc):	.long	0	# /boot argc
_C_LABEL(bootargv):	.long	0	# /boot argv
_C_LABEL(proc0paddr):	.long	0
_C_LABEL(PTDpaddr):	.long	0	# paddr of PTD, for libkvm
d276 2
a277 2
	.globl	_C_LABEL(kernel_text)
	_C_LABEL(kernel_text) = KERNTEXTOFF
d286 1
a286 1
	movl	%eax,RELOC(_C_LABEL(boothowto))
d288 2
a289 2
	movl	%eax,RELOC(_C_LABEL(bootdev))
	movl	16(%esp),%eax
d293 6
a298 1
1:	movl	%eax,RELOC(_C_LABEL(esym))
d301 1
a301 1
	movl	%eax,RELOC(_C_LABEL(bootapiver))
d303 1
a303 1
	movl	%eax, RELOC(_C_LABEL(bootargc))
d305 1
a305 1
	movl	%eax, RELOC(_C_LABEL(bootargv))
d346 1
a346 1
	movl	$CPU_NX586,RELOC(_C_LABEL(cpu))
d350 1
a350 1
	movl	$CPU_386,RELOC(_C_LABEL(cpu))
d369 1
a369 1
is486:	movl	$CPU_486,RELOC(_C_LABEL(cpu))
d388 1
a388 1
	movl	$CPU_6x86,RELOC(_C_LABEL(cpu))	# set CPU type
d406 1
a406 1
	movl	$CPU_486DLC,RELOC(_C_LABEL(cpu))	# set CPU type
d470 5
a474 5
	movl	%eax,RELOC(_C_LABEL(cpuid_level))
	movl	%ebx,RELOC(_C_LABEL(cpu_vendor))	# store vendor string
	movl	%edx,RELOC(_C_LABEL(cpu_vendor))+4
	movl	%ecx,RELOC(_C_LABEL(cpu_vendor))+8
	movl	$0,  RELOC(_C_LABEL(cpu_vendor))+12
d478 2
a479 2
	movl	%eax,RELOC(_C_LABEL(cpu_id))	# store cpu_id and features
	movl	%edx,RELOC(_C_LABEL(cpu_feature))
d481 1
a481 1
	movl	$RELOC(_C_LABEL(cpuid_level)),%eax
d492 4
a495 4
	movl	%eax,RELOC(_C_LABEL(cpu_cache_eax))
	movl	%ebx,RELOC(_C_LABEL(cpu_cache_ebx))
	movl	%ecx,RELOC(_C_LABEL(cpu_cache_ecx))
	movl	%edx,RELOC(_C_LABEL(cpu_cache_edx))
d518 4
a521 4
#define	PROC0PDIR	((0)		* NBPG)
#define	PROC0STACK	((1)		* NBPG)
#define	SYSMAP		((1+UPAGES)	* NBPG)
#define	TABLESIZE	((1+UPAGES) * NBPG) /* + _C_LABEL(nkpde) * NBPG */
d524 3
a526 3
	movl	$RELOC(_C_LABEL(edata)),%edi
	movl	$_C_LABEL(end),%ecx
	subl	$_C_LABEL(edata),%ecx
d535 1
a535 1
	movl	$RELOC(_C_LABEL(end)),%edi
d538 1
a538 1
	movl	RELOC(_C_LABEL(esym)),%eax
d555 1
a555 1
	movl	RELOC(_C_LABEL(nkpde)),%ecx	# get nkpde
d563 1
a563 1
2:
d592 1
a592 1
	leal	(RELOC(_C_LABEL(etext))+PGOFSET),%edx
d594 1
a594 1

d614 1
a614 1
	movl	RELOC(_C_LABEL(nkpde)),%ecx
d630 1
a630 1
	movl	RELOC(_C_LABEL(nkpde)),%ecx		# count of pde s,
d636 1
a636 1
 * Map kernel PDEs: this is the real mapping used
d639 1
a639 1
	movl	RELOC(_C_LABEL(nkpde)),%ecx		# count of pde s,
d649 1
a649 1
	movl	%esi,RELOC(_C_LABEL(PTDpaddr))
d664 1
a664 1
	movl	_C_LABEL(nkpde),%ecx		# for this many pde s,
d672 1
a672 1
	movl	_C_LABEL(nkpde),%edx
d676 1
a676 1
	movl	%edx,_C_LABEL(atdevbase)
d680 1
a680 1
	movl	%eax,_C_LABEL(proc0paddr)
d683 1
a683 1
	xorl	%ebp,%ebp		# mark end of frames
d685 1
a685 1
	movl	_C_LABEL(nkpde),%eax
d690 1
a690 1
	call	_C_LABEL(init386)	# wire 386 chip for unix operation
d698 1
a698 1
	call	_C_LABEL(main)
d728 1
a728 1
	int	$0x80			# enter kernel with args on stack
d731 2
a732 2
	.globl	_C_LABEL(esigcode)
_C_LABEL(esigcode):
d750 1
a750 1
	pushl	$1			# setcontext(p) == syscontext(1, p)
d753 1
a753 1
	int	$0x80			# enter kernel with args on stack
d756 2
a757 2
	.globl	_C_LABEL(svr4_esigcode)
_C_LABEL(svr4_esigcode):
d780 1
a780 1
	int	$0x80			# enter kernel with args on stack
d783 2
a784 2
	.globl	_C_LABEL(linux_esigcode)
_C_LABEL(linux_esigcode):
d800 1
a800 1
	int	$0x80			# enter kernel with args on stack
d803 2
a804 2
	.globl	_C_LABEL(freebsd_esigcode)
_C_LABEL(freebsd_esigcode):
d948 1
a948 1
	jmp	_C_LABEL(bcopy)
d964 2
a965 1
	pushl	$0	
d967 3
a969 3
	movl	16(%esp),%esi
	movl	20(%esp),%edi
	movl	24(%esp),%eax
d980 1
a980 1
	jc	_C_LABEL(copy_fault)
d982 1
a982 1
	ja	_C_LABEL(copy_fault)
d986 1
a986 1
	cmpl	$CPUCLASS_386,_C_LABEL(cpu_class)
d1012 1
a1012 1
	testb	$PG_RW,_C_LABEL(PTmap)(,%edi,4)
d1014 1
a1014 1

d1021 1
a1021 1

d1028 1
a1028 1
	call	_C_LABEL(trapwrite)	# trapwrite(addr)
d1034 1
a1034 1
	jmp	_C_LABEL(copy_fault)
d1038 1
a1038 1
	movl	$_C_LABEL(copy_fault),PCB_ONFAULT(%edx)
d1050 1
a1051 1
	popl	PCB_ONFAULT(%edx)
d1054 2
a1055 1
	xorl	%eax,%eax
d1066 1
a1066 2
	pushl	$0
	movl	$_C_LABEL(copy_fault),PCB_ONFAULT(%eax)
d1068 3
a1070 3
	movl	16(%esp),%esi
	movl	20(%esp),%edi
	movl	24(%esp),%eax
d1079 1
a1079 1
	jc	_C_LABEL(copy_fault)
d1081 1
a1081 1
	ja	_C_LABEL(copy_fault)
d1093 1
a1094 2
	GET_CURPCB(%edx)
	popl	PCB_ONFAULT(%edx)
d1097 2
a1098 1
	xorl	%eax,%eax
a1101 2
	GET_CURPCB(%edx)
	popl	PCB_ONFAULT(%edx)
d1104 2
d1120 1
a1120 1
	movl	$_C_LABEL(copystr_fault),PCB_ONFAULT(%ecx)
d1128 1
a1128 1
	cmpl	$CPUCLASS_386,_C_LABEL(cpu_class)
d1150 1
a1150 1
	jae	_C_LABEL(copystr_fault)
d1152 1
a1152 1
	testb	$PG_RW,_C_LABEL(PTmap)(,%eax,4)
d1159 1
a1159 1
	call	_C_LABEL(trapwrite)	# trapwrite(addr)
d1164 1
a1164 1
	jnz	_C_LABEL(copystr_fault)
d1228 1
a1228 1
	jae	_C_LABEL(copystr_fault)
a1244 1
	movl	$_C_LABEL(copystr_fault),PCB_ONFAULT(%ecx)
d1277 1
a1277 1
	jae	_C_LABEL(copystr_fault)
d1284 1
a1284 1
copystr_return:
d1349 1
a1349 1
	ja	_C_LABEL(fusuaddrfault)
d1351 1
a1351 1
	movl	$_C_LABEL(fusufault),PCB_ONFAULT(%ecx)
d1355 1
a1355 1

d1363 1
a1363 1
	ja	_C_LABEL(fusuaddrfault)
d1365 1
a1365 1
	movl	$_C_LABEL(fusufault),PCB_ONFAULT(%ecx)
d1369 1
a1369 1

d1378 1
a1378 1
	ja	_C_LABEL(fusuaddrfault)
d1380 1
a1380 1
	movl	$_C_LABEL(fusubail),PCB_ONFAULT(%ecx)
d1384 1
a1384 1

d1392 1
a1392 1
	ja	_C_LABEL(fusuaddrfault)
d1394 1
a1394 1
	movl	$_C_LABEL(fusufault),PCB_ONFAULT(%ecx)
d1431 1
a1431 1
	ja	_C_LABEL(fusuaddrfault)
d1433 1
a1433 1
	movl	$_C_LABEL(fusufault),PCB_ONFAULT(%ecx)
d1437 1
a1437 1
	cmpl	$CPUCLASS_386,_C_LABEL(cpu_class)
d1443 1
a1443 1
	testb	$PG_RW,_C_LABEL(PTmap)(,%eax,4)
d1449 1
a1449 1
	call	_C_LABEL(trapwrite)	# trapwrite(addr)
d1454 1
a1454 1
	jnz	_C_LABEL(fusufault)
d1467 1
a1467 1

d1475 1
a1475 1
	ja	_C_LABEL(fusuaddrfault)
d1477 1
a1477 1
	movl	$_C_LABEL(fusufault),PCB_ONFAULT(%ecx)
d1481 1
a1481 1
	cmpl	$CPUCLASS_386,_C_LABEL(cpu_class)
d1487 1
a1487 1
	testb	$PG_RW,_C_LABEL(PTmap)(,%eax,4)
d1493 1
a1493 1
	call	_C_LABEL(trapwrite)	# trapwrite(addr)
d1498 1
a1498 1
	jnz	_C_LABEL(fusufault)
d1520 1
a1520 1
	ja	_C_LABEL(fusuaddrfault)	
d1522 1
a1522 1
	movl	$_C_LABEL(fusubail),PCB_ONFAULT(%ecx)
d1526 1
a1526 1
	cmpl	$CPUCLASS_386,_C_LABEL(cpu_class)
d1532 1
a1532 1
	testb	$PG_RW,_C_LABEL(PTmap)(,%eax,4)
d1536 1
a1536 1
	jmp	_C_LABEL(fusubail)
d1554 1
a1554 1
	ja	_C_LABEL(fusuaddrfault)
d1556 1
a1556 1
	movl	$_C_LABEL(fusufault),PCB_ONFAULT(%ecx)
d1560 1
a1560 1
	cmpl	$CPUCLASS_386,_C_LABEL(cpu_class)
d1566 1
a1566 1
	testb	$PG_RW,_C_LABEL(PTmap)(,%eax,4)
d1572 1
a1572 1
	call	_C_LABEL(trapwrite)	# trapwrite(addr)
d1577 1
a1577 1
	jnz	_C_LABEL(fusufault)
d1648 6
a1653 5
 * whichqs tells which of the 32 queues qs have processes in them.
 * Setrq puts processes into queues, Remrq removes them from queues.
 * The running process is on no queue, other processes are on a queue
 * related to p->p_pri, divided by 4 actually to shrink the 0-127 range
 * of priorities into the 32 available queues.
d1656 1
d1673 2
a1674 2
	btsl	%edx,_C_LABEL(whichqs)		# set q full bit
	leal	_C_LABEL(qs)(,%edx,8),%edx	# locate q hdr
d1683 1
a1683 1
	call	_C_LABEL(panic)
d1697 1
a1697 1
	btl	%eax,_C_LABEL(whichqs)
d1710 1
a1710 1
	btrl	%eax,_C_LABEL(whichqs)		# no; clear bit
d1714 1
a1714 1
	call	_C_LABEL(panic)
d1720 1
a1720 1
	.globl _C_LABEL(apm_cpu_idle),_C_LABEL(apm_cpu_busy),_C_LABEL(apm_dobusy)
d1728 1
a1728 1
	movl	_C_LABEL(whichqs),%ecx
d1733 2
a1734 2
	call	_C_LABEL(apm_cpu_idle)
	cmpl	$0,_C_LABEL(apm_dobusy)
d1736 1
a1736 1
	call	_C_LABEL(apm_cpu_busy)
d1740 2
a1741 2
	addl	$1,_C_LABEL(pctr_idlcnt)
	adcl	$0,_C_LABEL(pctr_idlcnt)+4
d1745 1
a1745 1
	jmp	_C_LABEL(idle)
d1750 1
a1750 1
	call	_C_LABEL(panic)
d1779 1
a1779 1
	call	_C_LABEL(Xspllower)	# process pending interrupts
d1796 1
a1796 1
	movl	_C_LABEL(whichqs),%ecx	# XXX MP
d1799 1
a1799 1
	jz	_C_LABEL(idle)		# if none, idle
d1801 1
a1801 1
	leal	_C_LABEL(qs)(,%ebx,8),%eax	# select q
d1806 1
a1806 1
	je	_C_LABEL(switch_error)	# not possible
d1816 1
a1816 1
	movl	%ecx,_C_LABEL(whichqs)	# update q status
d1823 1
a1823 1
	jne	_C_LABEL(switch_error)	# Yes; shouldn't be queued.
d1825 1
a1825 1
	jne	_C_LABEL(switch_error)	# No; shouldn't be queued.
d1891 1
a1891 1
	movl	_C_LABEL(dynamic_gdt),%eax
d1958 1
a1958 1
	movl	$_C_LABEL(proc0),%ebx
d1976 1
a1976 1
	movl	_C_LABEL(dynamic_gdt),%eax
d2007 3
a2009 3
	pushl	%edi			/* exit2(p) */
	call	_C_LABEL(exit2)
	addl	$4,%esp
d2022 1
a2022 1

d2049 1
a2049 1
 */
d2052 1
a2052 1
#define	TRAP(a)		pushl $(a) ; jmp _C_LABEL(alltraps)
d2091 1
a2091 1
	call	_C_LABEL(npxdna)
d2118 1
a2118 1
	subl	_C_LABEL(idt),%eax
d2153 1
a2153 1
	call	_C_LABEL(npxintr)
d2184 1
a2184 1
	call	_C_LABEL(trap)
d2198 1
a2198 1
	call	_C_LABEL(trap)
d2208 1
a2208 1
	call	_C_LABEL(printf)
d2210 1
a2210 1
#if defined(DDB) && 0
d2253 1
a2253 1
	call	_C_LABEL(syscall)
d2262 1
a2262 1
	call	_C_LABEL(trap)
d2272 1
a2272 1
	call	_C_LABEL(printf)
d2274 1
a2274 1
#if defined(DDB) && 0
d2316 1
a2316 1
	cmpl	$CPUCLASS_486,_C_LABEL(cpu_class)
@


1.48.6.6
log
@Re-enable code that was disabled during merge/import. Handle spurious interrupts on some lapics (again).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.5 2001/10/31 03:01:12 nate Exp $	*/
d2126 2
a2127 1
IDTVEC(intrspurious)
d2137 1
@


1.48.6.7
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1776 1
a1776 1
	movl	$IPL_NONE,CPL		# spl0()
@


1.48.6.8
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.7 2001/11/13 21:00:51 niklas Exp $	*/
d2242 1
a2242 1
	call	_C_LABEL(printf)
d2244 1
a2244 1
#if defined(DDB) && 0
a2247 1
	movl	TF_EAX(%esp),%esi	# syscall no
d2267 1
a2267 31
	movl	TF_ESP(%esp),%edi	# user stack pointer
	leal	4(%edi),%edi		# parameters (in userspace)
	cmpl	$SYS_syscall,%esi
	jne	5f
	pushl	%edi
	CALL	_C_LABEL(fuword)
	movl	%eax,%esi		# indirect syscall no for SYS_syscall
	leal	4(%edi),%edi		# shift parameters
	jmp	6f
5:	
	cmpl	$SYS___syscall,%esi
	jne	6f
	pushl	%edi
	CALL	_C_LABEL(fuword)
	movl	%eax,%esi		# indirect syscall no for SYS___syscall
	leal	8(%edi),%edi		# shift parameters (quad alignment)
6:
	leal	8(%edi),%ecx
	pushl	%ecx
	call	_C_LABEL(fuword)
	movl	%eax,(%esp)		# 3rd syscall arg
	leal	4(%edi),%ecx
	pushl	%ecx
	call	_C_LABEL(fuword)
	movl	%eax,(%esp)		# 2nd syscall arg
	pushl	%edi
	call	_C_LABEL(fuword)
	movl	%eax,(%esp)		# 1st syscall arg
	pushl	%esi			# syscall no
	pushl	_C_LABEL(cpl)		# current spl
	pushl	$4f			# format string
d2269 1
a2269 1
	addl	$24,%esp
d2275 1
a2275 1
4:	.asciz	"WARNING: SPL (0x%x) NOT LOWERED ON syscall(0x%x, 0x%x, 0x%x, 0x%x...) EXIT\n"
@


1.48.6.9
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a1854 4
#ifdef DDB
	xorl	%ax, %ax
	xorl	%cx, %cx
#endif
a2021 4
#ifdef DDB
	xorl	%ax, %ax
	xorl	%cx, %cx
#endif
@


1.48.6.10
log
@Sync the SMP branch with 3.3
@
text
@a1344 1
 * Not used outside locore anymore.
d1346 1
a1346 1
ASENTRY(fuword)
d1349 1
a1349 1
	ja	_ASM_LABEL(fusuaddrfault)
d1351 1
a1351 1
	movl	$_ASM_LABEL(fusufault),PCB_ONFAULT(%ecx)
d1357 2
a1358 1
 * Handle faults from fuword.  Clean up and return -1.
d1360 53
a1412 1
ASENTRY(fusufault)
d1418 1
a1418 1
 * Handle earlier faults from fuword, due to our of range addresses.
d1420 1
a1420 1
ASENTRY(fusuaddrfault)
d1424 167
d1856 2
a1857 2
	xorl	%eax, %eax
	xorl	%ecx, %ecx
d1952 2
d2027 2
a2028 2
	xorl	%eax, %eax
	xorl	%ecx, %ecx
d2281 1
a2281 1
	CALL	_ASM_LABEL(fuword)
d2289 1
a2289 1
	CALL	_ASM_LABEL(fuword)
d2295 1
a2295 1
	call	_ASM_LABEL(fuword)
d2299 1
a2299 1
	call	_ASM_LABEL(fuword)
d2302 1
a2302 1
	call	_ASM_LABEL(fuword)
@


1.48.6.11
log
@Typo, reported by Hans-Joerg Hoexer <Hans-Joerg.Hoexer@@yerbouti.franken.de>.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.10 2003/03/27 23:26:55 niklas Exp $	*/
d1740 1
a1740 1
	movl	P_ADDR(%ebx),%esi
@


1.48.6.12
log
@Move TSS selector from the PCB to MD part of proc and to cpu_info.
Maintain a list of CPUs and provide an iterator for it.
Ifdef out IPI debugging.  Call pmap_{de,}activate as part of context switching.
Mostly from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.11 2003/04/06 09:43:12 niklas Exp $	*/
a1505 5
	pushl	%esi
	call	_C_LABEL(pmap_deactivate)
	addl	$4,%esp

2:	
d1524 1
a1524 1
	jmp	2b
a1632 4
	pushl	%esi
	call	_C_LABEL(pmap_deactivate)
	addl	$4,%esp

a1672 10
	/*
	 * Activate the address space.  We're curproc, so %cr3 will
	 * be reloaded, but we're not yet curpcb, so the LDT won't
	 * be reloaded, although the PCB copy of the selector will
	 * be refreshed from the pmap.
	 */
	pushl	%edi
	call	_C_LABEL(pmap_activate)
	addl	$4,%esp
	
d1675 5
a1679 1
	movl	P_MD_TSS_SEL(%edi),%edx
a1740 1
	movl	P_MD_TSS_SEL(%ebx),%dx
a1743 1
	movl	CPU_INFO_IDLE_TSS_SEL(%ebx),%edx
d1758 1
@


1.48.6.13
log
@Do not deactivate the pmap while idling until we actually do have biglock in place
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.13 2003/04/14 14:02:49 niklas Exp $	*/
d1506 5
d1529 1
a1529 1
	jmp	_C_LABEL(idle)
@


1.48.6.14
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.13 2003/04/15 03:55:50 niklas Exp $	*/
d79 3
a81 4

#define	ALIGN_DATA	.align  4
#define	ALIGN_TEXT	.align  4,0x90	/* 4-byte boundaries, NOP-filled */
#define	SUPERALIGN_TEXT	.align  16,0x90	/* 16-byte boundaries better for 486 */
d174 2
a175 2
	movw	%ax,%ds		; \
	movw	%ax,%es
d695 2
a696 2
	movw	%cx,%fs
	movw	%cx,%gs
d702 1
a702 1
	call	*%esi
d714 1
a714 1
	call	*SIGF_HANDLER(%esp)
d723 2
a724 2
	movw	%cx,%fs
	movw	%dx,%gs
d738 1
a738 1
	call	*SVR4_SIGF_HANDLER(%esp)
d747 2
a748 2
	movw	%cx,%fs
	movw	%dx,%gs
d767 1
a767 1
	call	*LINUX_SIGF_HANDLER(%esp)
d776 2
a777 2
	movw	%cx,%fs
	movw	%dx,%gs
d794 1
a794 1
	call	*FREEBSD_SIGF_HANDLER(%esp)
d1243 1
d1391 3
a1393 3
	movw	%ax,%ds
	movw	%ax,%es
	movw	%ax,%ss
d1644 2
a1645 2
	movw	%fs,%ax
	movw	%gs,%cx
d1710 2
a1711 2
	movw	%ax,%fs
	movw	%cx,%gs
d1783 2
a1784 2
	movw	%cx,%fs
	movw	%cx,%gs
d1820 2
a1821 2
	movw	%fs,%ax
	movw	%gs,%cx
d1846 1
a1846 1
#define	IDTVEC(name)	ALIGN_TEXT; .globl X/**/name; X/**/name:
d1967 1
a1967 1
	movw	%ax,%es
@


1.48.6.15
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.14 2003/05/13 19:42:07 ho Exp $	*/
d223 1
a223 1
	.globl	_C_LABEL(gdt)
a701 4
#ifdef MULTIPROCESSOR
	call	_C_LABEL(proc_trampoline_mp)
#endif
	movl	$IPL_NONE,CPL
d705 1
a1505 32
	/*
	 * idling:	save old context.
	 *
	 * Registers:
	 *   %eax, %ebx, %ecx - scratch
	 *   %esi - old proc, then old pcb
	 *   %edi - idle pcb
	 *   %edx - idle TSS selector
	 */

	pushl	%esi
	call	_C_LABEL(pmap_deactivate)	# pmap_deactivate(oldproc)
	addl	$4,%esp

	movl	P_ADDR(%esi),%esi

	/* Save stack pointers. */
	movl	%esp,PCB_ESP(%esi)
	movl	%ebp,PCB_EBP(%esi)

	/* Find idle PCB for this CPU */
#ifndef MULTIPROCESSOR
	movl	$_C_LABEL(proc0),%ebx
	movl	P_ADDR(%ebx),%edi
	movl	P_MD_TSS_SEL(%ebx),%edx
#else
	GET_CPUINFO(%ebx)
	movl	CPU_INFO_IDLE_PCB(%ebx),%edi
	movl	CPU_INFO_IDLE_TSS_SEL(%ebx),%edx
#endif

	/* Restore the idle context (avoid interrupts) */
d1507 3
a1509 29

	/* Restore stack pointers. */
	movl	PCB_ESP(%edi),%esp
	movl	PCB_EBP(%edi),%ebp


	/* Switch address space. */
	movl	PCB_CR3(%edi),%ecx
	movl	%ecx,%cr3

	/* Switch TSS. Reset "task busy" flag before loading. */
#ifdef MULTIPROCESSOR
	movl	CPU_INFO_GDT(%ebx),%eax
#else
	movl	_C_LABEL(gdt),%eax
#endif
	andl	$~0x0200,4-SEL_KPL(%eax,%edx,1)
	ltr	%dx

	/* We're always in the kernel, so we don't need the LDT. */

	/* Restore cr0 (including FPU state). */
	movl	PCB_CR0(%edi),%ecx
	movl	%ecx,%cr0

	/* Record new pcb. */
	SET_CURPCB(%edi,%ecx)

	xorl	%esi,%esi
a1510 11
	
#if defined(MULTIPROCESSOR) || defined(LOCKDEBUG)	
	call	_C_LABEL(sched_unlock_idle)
#endif

	movl	$IPL_NONE,CPL		# spl0()
	call	_C_LABEL(Xspllower)	# process pending interrupts

ENTRY(idle_loop)
	cmpl	$0,_C_LABEL(whichqs)
	jnz	_C_LABEL(idle_exit)
d1524 1
a1524 1
	jmp	_C_LABEL(idle_loop)
a1525 16
ENTRY(idle_exit)
	movl	$IPL_HIGH,CPL		# splhigh
#if defined(MULTIPROCESSOR) || defined(LOCKDEBUG)	
	call	_C_LABEL(sched_lock_idle)
#endif
#if 1
	GET_CPUINFO(%ebx)
	leal	CPU_INFO_NAME(%ebx),%ebx
	pushl	%ebx
	pushl	$1f
	call	_C_LABEL(printf)
	addl	$8,%esp
#endif
	jmp	switch_search
1:	.asciz	"%s: unidle\n"
		
d1557 3
d1574 4
a1577 2
	movl	_C_LABEL(whichqs),%ecx
	bsfl	%ecx,%ebx		# find a full q
d1579 1
d1581 1
a1610 1
	movb	$SONPROC,P_STAT(%edi)	# p->p_stat = SONPROC
d1613 3
d1688 1
a1688 6
#ifdef MULTIPROCESSOR
	GET_CPUINFO(%ebx)
	movl	CPU_INFO_GDT(%ebx),%eax
#else
	movl	_C_LABEL(gdt),%eax
#endif
a1724 12
#if 1
	pushl	%edi
	GET_CPUINFO(%ebx)
	leal	CPU_INFO_NAME(%ebx),%ebx
	pushl	%ebx
	pushl	$1f
	call	_C_LABEL(printf)
	addl	$0xc,%esp
#endif
#if defined(MULTIPROCESSOR) || defined(LOCKDEBUG)     
	call    _C_LABEL(sched_unlock_idle)
#endif
d1736 1
a1736 1
1:	.asciz	"%s: scheduled %x\n"
d1769 1
a1769 5
#ifdef MULTIPROCESSOR
	movl	CPU_INFO_GDT(%ebx),%eax
#else
	movl	_C_LABEL(gdt),%eax
#endif
@


1.48.6.16
log
@LAPIC access need to be 32 bits, also load %fs with CPU segment
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.15 2003/05/15 04:08:02 niklas Exp $	*/
a1396 2
	movl	$GSEL(GCPU_SEL, SEL_KPL),%eax
	movw	%ax,%fs
d2136 1
a2136 1
	movl	CPL,%ebx
@


1.48.6.17
log
@LAPIC access need to be 32 bits, a forgotten place
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.16 2003/05/15 17:47:15 niklas Exp $	*/
d102 1
a102 2
	movl	_C_LABEL(lapic_id),reg	;		\
	shrl	$LAPIC_ID_SHIFT,reg	; 		\
@


1.48.6.18
log
@#if 0 debugging code
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.17 2003/05/15 18:48:58 niklas Exp $	*/
d1606 1
a1606 1
#if 0
d1812 1
a1812 1
#if 0
@


1.48.6.19
log
@A missed _C_LABEL(cpl). niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.18 2003/05/18 17:16:42 niklas Exp $	*/
d2198 1
a2198 1
	pushl	CPL			# current spl
@


1.48.6.20
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.19 2003/05/25 17:32:07 ho Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
d217 1
a217 2
	.globl	_C_LABEL(cpuid_level)
	.globl	_C_LABEL(cpu_feature), _C_LABEL(cpu_ecxfeature)
d256 2
a257 3
_C_LABEL(cpu_feature):	.long	0	# feature flags from 'cpuid' instruction
_C_LABEL(cpu_ecxfeature):.long	0	# extended feature flags from 'cpuid'
_C_LABEL(cpuid_level):	.long	-1	# max. lvl accepted by 'cpuid' insn
a481 1
	movl	%ecx,RELOC(_C_LABEL(cpu_ecxfeature))
@


1.48.6.21
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a212 1
	.globl	_C_LABEL(cpu_brandstr)
d260 1
a260 2
_C_LABEL(cpu_vendor): .space 16	# vendor string returned by 'cpuid' instruction
_C_LABEL(cpu_brandstr):	.space 48 # brand string returned by 'cpuid'
d484 1
a484 1
	jl	1f
d490 1
a490 1
	jne	1f
a497 26
1:
	/* Check if brand identification string is supported */
	movl	$0x80000000,%eax
	cpuid
	cmpl	$0x80000000,%eax
	jbe	2f
	movl	$0x80000002,%eax
	cpuid
	movl	%eax,RELOC(_C_LABEL(cpu_brandstr))
	movl	%ebx,RELOC(_C_LABEL(cpu_brandstr))+4
	movl	%ecx,RELOC(_C_LABEL(cpu_brandstr))+8
	movl	%edx,RELOC(_C_LABEL(cpu_brandstr))+12
	movl	$0x80000003,%eax
	cpuid
	movl	%eax,RELOC(_C_LABEL(cpu_brandstr))+16
	movl	%ebx,RELOC(_C_LABEL(cpu_brandstr))+20
	movl	%ecx,RELOC(_C_LABEL(cpu_brandstr))+24
	movl	%edx,RELOC(_C_LABEL(cpu_brandstr))+28
	movl	$0x80000004,%eax
	cpuid
	movl	%eax,RELOC(_C_LABEL(cpu_brandstr))+32
	movl	%ebx,RELOC(_C_LABEL(cpu_brandstr))+36
	movl	%ecx,RELOC(_C_LABEL(cpu_brandstr))+40
	andl	$0x00ffffff,%edx	/* Shouldn't be necessary */
	movl	%edx,RELOC(_C_LABEL(cpu_brandstr))+44

d1012 1
a1012 1
	movl	$2f, PCB_ONFAULT(%edx)
d1022 1
a1022 2
	movl	20(%esp),%edi
	movl	24(%esp),%eax
d1026 1
d1035 1
d1049 2
a1050 2
	movl	%eax,%ecx
	andl	$3,%ecx
d1122 2
d1141 6
a1146 2
	GET_CURPCB(%ecx)
	movl	$6f, PCB_ONFAULT(%eax)
a1154 4
	/* Compute PTE offset for start address. */
	movl	%edi,%eax
	shrl	$PGSHIFT,%eax		# calculate pte address

d1158 2
a1159 1
6:	/* Simulate a trap. */
d1166 1
d1171 1
a1171 1
	jnc	3f
d1175 1
d1184 1
d1190 1
d1192 1
d1345 30
d1989 1
a1989 1
	call	*_C_LABEL(npxdna_func)
d2137 13
d2161 1
d2163 46
a2283 67

#if defined(I686_CPU) && !defined(SMALL_KERNEL)
ENTRY(sse2_pagezero)
	pushl	%ebx
	movl	8(%esp),%ecx
	movl	%ecx,%eax
	addl	$4096,%eax
	xor	%ebx,%ebx
1:
	movnti	%ebx,(%ecx)
	addl	$4,%ecx
	cmpl	%ecx,%eax
	jne	1b
	sfence
	popl	%ebx
	ret

ENTRY(i686_pagezero)
	pushl	%edi
	pushl	%ebx

	movl	12(%esp), %edi
	movl	$1024, %ecx
	cld

	ALIGN_TEXT
1:
	xorl	%eax, %eax
	repe
	scasl
	jnz	2f

	popl	%ebx
	popl	%edi
	ret

	ALIGN_TEXT

2:
	incl	%ecx
	subl	$4, %edi

	movl	%ecx, %edx
	cmpl	$16, %ecx

	jge	3f

	movl	%edi, %ebx
	andl	$0x3f, %ebx
	shrl	%ebx
	shrl	%ebx
	movl	$16, %ecx
	subl	%ebx, %ecx

3:
	subl	%ecx, %edx
	rep
	stosl

	movl	%edx, %ecx
	testl	%edx, %edx
	jnz	1b

	popl	%ebx
	popl	%edi
	ret
#endif
@


1.48.6.22
log
@Fix scheduler logic for case when no former proc exist when entering idle loop
@
text
@a1499 4
	/* Skip context saving if we have none. */
	testl %esi,%esi
	jz	1f

d1563 1
a1563 2

1:
@


1.48.6.23
log
@typo in ifndef MULTIPROCESSOR case
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.22 2004/02/20 22:21:05 niklas Exp $	*/
d1843 1
a1843 1
	movl	P_MD_TSS_SEL(%ebx),%edx
@


1.48.6.24
log
@Moving vector.s from isa to i386 in preparation for a merged (for all kind of sources) interrupt system
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.23 2004/03/14 17:47:43 niklas Exp $	*/
d2144 1
a2144 1
#include <i386/i386/vector.s>
@


1.48.6.25
log
@oops, need to set trap on FP ops bit if FP context on other cpu (NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.24 2004/03/16 18:29:34 niklas Exp $	*/
a1795 11
#ifdef MULTIPROCESSOR
	/* 
	 * If our floating point registers are on a different CPU,
	 * clear CR0_TS so we'll trap rather than reuse bogus state.
	 */
	GET_CPUINFO(%ebx)
	cmpl	PCB_FPCPU(%esi),%ebx
	jz	1f
	orl	$CR0_TS,%ecx
1:	
#endif	
@


1.48.6.26
log
@Provide a frame for DDB in copy{in,out}{,str} funcs
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.25 2004/04/06 13:31:05 niklas Exp $	*/
a988 7
/* Frame pointer reserve on stack. */
#ifdef DDB
#define FPADD 4
#else
#define FPADD 0
#endif

a993 4
#ifdef DDB
	pushl	%ebp
	movl	%esp,%ebp
#endif
d998 3
a1000 3
	movl	16+FPADD(%esp),%esi
	movl	20+FPADD(%esp),%edi
	movl	24+FPADD(%esp),%eax
d1050 2
a1051 2
	movl	20+FPADD(%esp),%edi
	movl	24+FPADD(%esp),%eax
a1084 3
#ifdef DDB
	leave
#endif
a1091 4
#ifdef DDB
	pushl	%ebp
	movl	%esp,%ebp
#endif
d1098 3
a1100 3
	movl	16+FPADD(%esp),%esi
	movl	20+FPADD(%esp),%edi
	movl	24+FPADD(%esp),%eax
a1128 3
#ifdef DDB
	leave
#endif
a1146 4
#ifdef DDB
	pushl	%ebp
	movl	%esp,%ebp
#endif
d1150 3
a1152 3
	movl	12+FPADD(%esp),%esi		# esi = from
	movl	16+FPADD(%esp),%edi		# edi = to
	movl	20+FPADD(%esp),%edx		# edx = maxlen
d1231 1
a1231 1
	movl	%eax,20+FPADD(%esp)
a1262 4
#ifdef DDB
	pushl	%ebp
	movl	%esp,%ebp
#endif
d1268 3
a1270 3
	movl	12+FPADD(%esp),%esi		# %esi = from
	movl	16+FPADD(%esp),%edi		# %edi = to
	movl	20+FPADD(%esp),%edx		# %edx = maxlen
d1280 1
a1280 1
	movl	%eax,20+FPADD(%esp)
d1310 1
a1310 1
	movl	20+FPADD(%esp),%ecx
d1312 1
a1312 1
	movl	24+FPADD(%esp),%edx
a1318 3
#ifdef DDB
	leave
#endif
a1327 4
#ifdef DDB
	pushl	%ebp
	movl	%esp,%ebp
#endif
d1331 3
a1333 3
	movl	12+FPADD(%esp),%esi		# esi = from
	movl	16+FPADD(%esp),%edi		# edi = to
	movl	20+FPADD(%esp),%edx		# edx = maxlen
d1353 1
a1353 1
	movl	20+FPADD(%esp),%ecx
d1355 1
a1355 1
	movl	24+FPADD(%esp),%edx
a1361 3
#ifdef DDB
	leave
#endif
@


1.48.6.27
log
@In !MULTIPROCESSOR replace cpu_info_store with cpu_info_primary,
like it should be, and a missing dollar (10x niklas!).

ok niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.26 2004/04/15 15:44:56 niklas Exp $	*/
d2031 1
a2031 1
	pushl	$_C_LABEL(cpu_info_primary)
@


1.48.6.28
log
@typo in i386 codepath
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1192 1
a1192 1
	movl	$6f, PCB_ONFAULT(%ecx)
@


1.48.6.29
log
@Do the DDB prologue for kcopy too. Fix copy_fault to deal with the changed
stack frame layout. Fixes the error case of copy{in,out}

We run too high quality software, we never tickle the error case.

ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.48.6.28 2004/06/08 07:33:12 niklas Exp $	*/
a867 8

/* Frame pointer reserve on stack. */
#ifdef DDB
#define FPADD 4
#else
#define FPADD 0
#endif

a872 4
#ifdef DDB
	pushl	%ebp
	movl	%esp,%ebp
#endif
d879 3
a881 3
	movl	16+FPADD(%esp),%esi
	movl	20+FPADD(%esp),%edi
	movl	24+FPADD(%esp),%ecx
d890 1
a890 1
	movl	24+FPADD(%esp),%ecx
a899 3
#ifdef DDB
	leave
#endif
d911 1
a911 1
	movl	24+FPADD(%esp),%ecx	# copy remainder by 32-bit words
a923 3
#ifdef DDB
	leave
#endif
d989 7
a1157 3
#ifdef DDB
	leave
#endif
@


1.48.6.30
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a100 4
#else
#define	GET_CPUINFO(reg)				\
	leal	_C_LABEL(cpu_info_primary),reg
#endif
d138 19
@


1.47
log
@add kcopy (uvm)
cnt.foo -> uvmexp.bar
kmem allocation changes for uvm
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.46 1999/02/12 19:40:12 deraadt Exp $	*/
d144 1
d151 1
a151 1
_cpu_id:	.long	0	# saved from `cpuid' instruction
d154 5
a158 1
_cpu_vendor:	.space	16	# vendor string returned by `cpuid' instruction
d383 16
@


1.46
log
@do not accept T_TRCTRAP DDB inside the osyscall stub; weingart
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.45 1998/09/06 20:09:58 millert Exp $	*/
d723 60
d1558 3
d1562 2
a1563 1

d1857 4
d1862 1
d1911 3
d1915 1
d1919 3
d1923 1
d2055 3
d2059 1
@


1.45
log
@Preserve symbol table if ksyms is in the kernel but DDB is not.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.44 1998/08/18 22:29:10 marc Exp $	*/
d2070 1
@


1.44
log
@halt processor when idle if either APM is enabled or PCTR is not enabled;
my idle portable: approx 320000 instructions per second
my portable during a make build: as high as 21000000 instructions per second
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.43 1998/05/10 18:29:49 deraadt Exp $	*/
d47 1
d418 1
a418 1
#if defined(DDB) && !defined(SYMTAB_SPACE)
@


1.43
log
@80386 specific fix for copyoutstr crossing a page boundary; drochner@@zelux6.zel.kfa-juelich.de
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.42 1998/02/26 20:53:23 weingart Exp $	*/
d1580 2
a1581 2
#else /* NAPM == 0 */
#if NPCTR > 0
d1584 1
a1584 1
#else /* NPCTR == 0 */
d1586 1
a1586 2
#endif /* NPCTR == 0 */
#endif /* NAPM == 0 */
@


1.42
log
@Fix boot flags not working.  The latest gas patches, which caught some
problems in our locore (which were then fixed), caused this latest bug
to appear.  Basically the clearing of the BSS was being done after the
boothowto integer was already filled in.

The new bootblocks already clear the BSS, so the clearing of the BSS
could well be removed from locore.  However, for backwards compatibility
we might still need it in there for a while.  (I believe the 2.1 boot-
blocks did not clear the BSS).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.41 1998/02/22 00:34:52 niklas Exp $	*/
d1021 1
a1021 1
	jnc	3f
d1025 1
d1034 1
d1040 1
@


1.41
log
@style nits
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.40 1998/02/17 12:07:21 deraadt Exp $	*/
d157 1
@


1.40
log
@fix the thing gas freaks out about; weingart will fix better if required
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.39 1998/01/29 11:30:27 niklas Exp $	*/
d405 4
a408 4
	movl	$_end, %ecx
	subl	$_edata, %ecx
	addl	$3, %ecx
	shrl	$2, %ecx
@


1.39
log
@Make profiling work, mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.38 1997/12/17 08:54:47 downsj Exp $	*/
d405 4
a408 1
	movl	$(((_end-_edata)+3)>>2),%ecx
@


1.38
log
@New CPU detection code, from NetBSD, with some machdep changes from myself.

Add I686_CPU to your configs if you have a PPro...
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.37 1997/12/09 03:36:39 deraadt Exp $	*/
d69 3
d75 2
a136 17
#ifdef        GPROF
#define       PENTRY(name)    \
	ENTRY(name) \
	pushl	%ebp; \
	movl	%esp,%ebp; \
	pushl	%ebx; \
	pushl	_cpl; \
	movl	$0,_cpl; \
	call	_Xspllower; \
	call	mcount; \
	popl	_cpl; \
	leal	4(%esp),%esp; \
	popl	%ebp
#endif
#define	ENTRY(name)	.globl _/**/name; ALIGN_TEXT; _/**/name:
#define	ALTENTRY(name)	.globl _/**/name; _/**/name:

d551 1
a551 1
ENTRY(proc_trampoline)
d563 1
a563 1
ENTRY(sigcode)
d587 1
a587 1
ENTRY(svr4_sigcode)
d616 1
a616 1
ENTRY(linux_sigcode)
d643 1
a643 1
ENTRY(freebsd_sigcode)
d765 1
a765 5
#ifdef        GPROF
ENTRY(ovbcopy)
	jmp _bcopy
PENTRY(bcopy)
#else
a766 2
ALTENTRY(ovbcopy)
#endif
d772 4
a775 2
	cmpl	%esi,%edi		# potentially overlapping? */
	jnb	1f
a818 3
#ifdef        GPROF
PENTRY(copyout)
#else
a819 1
#endif
a913 3
#ifdef        GPROF
PENTRY(copyin)
#else
a914 1
#endif
d1201 1
a1201 1
 * fusword(u_short *uaddr);
d1310 1
a1310 1
 * susword(u_short *uaddr, short x);
d1436 1
a1436 1
ENTRY(lgdt)
d1496 1
a1496 1
ENTRY(setrunqueue)
d1527 1
a1527 1
ENTRY(remrunqueue)
d1584 1
a1584 1
ENTRY(switch_error)
d1988 1
a1988 1
ENTRY(resume_iret)
d1990 1
a1990 1
ENTRY(resume_pop_ds)
d1993 1
a1993 1
ENTRY(resume_pop_es)
d1997 1
a1997 1
ENTRY(alltraps)
d2042 1
a2042 1
ENTRY(bpttraps)
a2111 3
#ifdef        GPROF
PENTRY(bzero)
#else
a2112 1
#endif
@


1.37
log
@Intel P5 f00f workaround; weingart & who knows who else
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.36 1997/10/22 23:37:12 mickey Exp $	*/
d154 2
a155 1
	.globl	_cpu,_cpu_vendor,_cold,_cnvmem,_extmem,_esym
d161 3
d237 21
d280 21
a300 2
	 * Check for Cyrix CPU by seeing if the flags change during a divide.
	 * This is documented in the Cx486SLC/e SMM Programmer's Guide.
a313 1

a314 2
	movl	$0x69727943,RELOC(_cpu_vendor)	# store vendor string
	movb	$0x78,RELOC(_cpu_vendor)+4
d378 1
d382 1
d386 2
a387 13
	rorl	$8,%eax			# extract family type
	andl	$15,%eax
	cmpl	$5,%eax
	jb	is486			# less than a Pentium
	movl	$CPU_586,RELOC(_cpu)
	je	3f			# Pentium
	movl	$CPU_686,RELOC(_cpu)	# else Pentium Pro
3:

	xorl %eax,%eax
	xorl %edx,%edx
	movl $0x10,%ecx
	.byte 0xf, 0x30			# wrmsr (or trap on non-pentium :-)
d863 1
a863 1
#if defined(I486_CPU) || defined(I586_CPU)
d866 1
a866 1
#endif /* I486_CPU || I586_CPU */
d1003 1
a1003 1
#if defined(I486_CPU) || defined(I586_CPU)
d1006 1
a1006 1
#endif /* I486_CPU || I586_CPU */
d1068 1
a1068 1
#if defined(I486_CPU) || defined(I586_CPU)
d1099 1
a1099 1
#endif /* I486_CPU || I586_CPU */
d1304 1
a1304 1
#if defined(I486_CPU) || defined(I586_CPU)
d1307 1
a1307 1
#endif /* I486_CPU || I586_CPU */
d1345 1
a1345 1
#if defined(I486_CPU) || defined(I586_CPU)
d1348 1
a1348 1
#endif /* I486_CPU || I586_CPU */
d1387 1
a1387 1
#if defined(I486_CPU) || defined(I586_CPU)
d1390 1
a1390 1
#endif /* I486_CPU || I586_CPU */
d1421 1
a1421 1
#if defined(I486_CPU) || defined(I586_CPU)
d1424 1
a1424 1
#endif /* I486_CPU || I586_CPU */
d2164 1
a2164 1
#if defined(I386_CPU) || defined(I586_CPU)
@


1.36
log
@support new libsa
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.35 1997/10/19 06:34:22 mickey Exp $	*/
d1934 13
@


1.35
log
@no, not good. will be fixed soon
xyu te6e B poT, teo
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.34 1997/10/18 00:33:13 weingart Exp $	*/
a45 1
#include "bios.h"
d156 3
a158 4
	.globl	_bootapiver,_proc0paddr,_curpcb,_PTDpaddr,_dynamic_gdt
#if NBIOS > 0
	.globl	_BIOS_vars
#endif
d166 3
a168 1
_bootapiver:	.long	0
d206 4
a209 10
#if NBIOS > 0
	orl	%eax, %eax
	jz	1f	/* old boots */
	movl	28(%esp), %esi
	movl	$RELOC(_BIOS_vars), %edi
	movl	32(%esp), %ecx
	cld
	rep;	movsb
1:
#endif /* NBIOS */
@


1.34
log
@Copy in bios_diskinfo array from /boot space.
Add length field for checksum to same.
Start of making /boot deduce bsd dev_t for
all BIOS drives.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.33 1997/09/29 03:42:26 mickey Exp $	*/
a159 1
	.globl	_bios_diskinfo
a213 10

	/* Copy bios_diskinfo as well */
	clc
	movl	28(%esp), %eax		/* Get boot_data */
	addl	$BOOT_DATA, %eax
	movl	(%eax), %esi
	movl	$RELOC(_bios_diskinfo), %edi
	movl	$BOOT_SIZE*16, %ecx
	cld
	rep;	movsb
a1566 1
	hlt
@


1.33
log
@apm0 at bios0
configs will be updated
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.32 1997/09/25 00:13:54 mickey Exp $	*/
d160 1
d213 10
@


1.32
log
@fix the bug i did in apmcall w/ that i386.diff
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.31 1997/09/21 04:27:55 mickey Exp $	*/
d215 1
a215 1
#endif /* APM */
a2167 66
	
#if NAPM > 0
/*
 * int apmcall(int function, struct apmregs *regs):
 * 	call the APM protected mode bios function FUNCTION for BIOS selection
 * 	WHICHBIOS.
 *	Fills in *regs with registers as returned by APM.
 *	returns nonzero if error returned by APM.
 */
	.globl	_apminfo
ENTRY(apmcall)
	pushl	%ebp
	movl	%esp,%ebp
	pushl	%esi
	pushl	%edi
	pushl	%ebx
	
#if defined(DEBUG) || defined(DIAGNOSTIC)
	pushl	%ds		
	pushl	%es
	pushl	%fs
	pushl	%gs
	pushfl
	cli
	pushl	%ds
	xorl	%ax,%ax
	movl	%ax,%ds
	movl	%ax,%es
	movl	%ax,%fs
	movl	%ax,%gs
#endif
	movb	%cs:8(%ebp),%al
	movb	$0x53,%ah
	movl	%cs:12(%ebp),%ebx
	movw	%cs:APMREG_CX(%ebx),%cx
	movw	%cs:APMREG_DX(%ebx),%dx
	movw	%cs:APMREG_BX(%ebx),%bx
	lcall	%cs:(_apminfo+APM_CALL)
#if defined(DEBUG) || defined(DIAGNOSTIC)
	popl	%ds
#endif
	movl	12(%ebp),%esi
	movw	%ax,APMREG_AX(%esi)
	movw	%bx,APMREG_BX(%esi)
	movw	%cx,APMREG_CX(%esi)
	movw	%dx,APMREG_DX(%esi)
		/* todo: do something with %edi? */
	setc	%al
	movzbl	%al, %eax

#if defined(DEBUG) || defined(DIAGNOSTIC)
	popfl
	popl	%gs
	popl	%fs
	popl	%es
	popl	%ds
#endif

	popl	%ebx
	popl	%edi
	popl	%esi
	popl	%ebp
	ret
#endif /* APM */


@


1.31
log
@support new boots
add to your config:
bios0 at mainbus0
apm0 at mainbus0	# (if you are using APM)
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.30 1997/09/11 10:45:43 deraadt Exp $	*/
a2176 1
	.data
a2177 2
apmstatus:	.long 0
	.text
d2206 1
a2207 7
	setc	apmstatus
	popfl
#if defined(DEBUG) || defined(DIAGNOSTIC)
	popl	%gs
	popl	%fs
	popl	%es
	popl	%ds		# see above
d2214 12
a2225 6
/* todo: do something with %edi? */
	movl	$1, %eax
	cmpl	$0,apmstatus
	jne	1f
	xorl	%eax,%eax
1:	
@


1.30
log
@toast BDB; netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.29 1997/07/25 17:15:22 mickey Exp $	*/
d46 1
d157 3
a159 10
	.globl	_cyloffset,_proc0paddr,_curpcb,_PTDpaddr,_dynamic_gdt
#if NAPM > 0
#include <machine/apmvar.h>
	.globl	_apminfo
	.globl	_apm_current_gdt_pdesc	/* current GDT pseudo desc. */
	.globl	_bootstrap_gdt
_apm_current_gdt_pdesc:	
	.word	0, 0, 0
_bootstrap_gdt:	
	.space SIZEOF_GDTE * BOOTSTRAP_GDT_NUM
d168 1
a168 1
_cyloffset:	.long	0
d185 1
a185 1
	 * Load parameters from stack (howto, bootdev, unit, cyloffset, esym).
a192 2
	movl	12(%esp),%eax
	movl	%eax,RELOC(_cyloffset)
d204 8
a211 29
#if NAPM > 0

	/*
	 * Setup APM BIOS:
	 *
	 * APM BIOS initialization should be done from real mode or V86 mode.
	 *
	 * (by HOSOKAWA, Tatsumi <hosokawa@@mt.cs.keio.ac.jp>)
	 */

	/*
	 * Cleanup %fs and %gs:
	 *
	 * Some BIOS bootstrap routine store junk value into %fs
	 * and %gs.
	 */

	xorl	%eax, %eax
	movw	%ax, %fs
	movw	%ax, %gs

	/* get GDT base */
	sgdt	RELOC(_apm_current_gdt_pdesc)

	/* copy GDT to _bootstrap_gdt */
	xorl	%ecx, %ecx
	movw	RELOC(_apm_current_gdt_pdesc), %cx
	movl	RELOC(_apm_current_gdt_pdesc)+2, %esi
	lea	RELOC(_bootstrap_gdt), %edi
d213 2
a214 64
	rep
	movsb

	/* setup GDT pseudo descriptor */
	movw	$(SIZEOF_GDTE*BOOTSTRAP_GDT_NUM), %ax
	movw	%ax, RELOC(_apm_current_gdt_pdesc)
	leal	RELOC(_bootstrap_gdt), %eax
	movl	%eax, RELOC(_apm_current_gdt_pdesc)+2

	/* load new GDTR */
	lgdt	RELOC(_apm_current_gdt_pdesc)

	/* 
	 * Copy APM initializer under 1MB boundary:
	 *
	 * APM initializer program must switch the CPU to real mode.
	 * But NetBSD kernel runs above 1MB boundary. So we must 
	 * copy the initializer code to conventional memory.
	 */
	movl	RELOC(_apm_init_image_size), %ecx	/* size */
	lea	RELOC(_apm_init_image), %esi		/* source */
	movl	$ APM_OURADDR, %edi			/* destination */
	cld
	rep
	movsb

	/* setup GDT for APM initializer */
	lea	RELOC(_bootstrap_gdt), %ecx
	movl	$(APM_OURADDR), %eax	/* use %ax for 15..0 */
	movl	%eax, %ebx
	shrl	$16, %ebx		/* use %bl for 23..16 */
					/* use %bh for 31..24 */
#define APM_SETUP_GDT(index, attrib) \
	movl	$(index), %si ; \
	lea	0(%ecx,%esi,8), %edx ; \
	movw	$0xffff, (%edx) ; \
	movw	%ax, 2(%edx) ; \
	movb	%bl, 4(%edx) ; \
	movw	$(attrib), 5(%edx) ; \
	movb	%bh, 7(%edx)

	APM_SETUP_GDT(APM_INIT_CS_INDEX  , CS32_ATTRIB)
	APM_SETUP_GDT(APM_INIT_DS_INDEX  , DS32_ATTRIB)
	APM_SETUP_GDT(APM_INIT_CS16_INDEX, CS16_ATTRIB)

	/*
	 * Call the initializer:
	 *
	 * direct intersegment call to conventional memory code
	 */
	.byte	0x9a		/* actually, lcall $APM_INIT_CS_SEL, $0 */
	.long	0
	.word	APM_INIT_CS_SEL

	movw	%ax,RELOC(_apminfo+APM_DETAIL)
	movw	%di,RELOC(_apminfo+APM_DETAIL)+2
	movl	%ebx,RELOC(_apminfo+APM_ENTRY)
	movw	%cx,RELOC(_apminfo+APM_CODE32)
	shrl	$16, %ecx
	movw	%cx,RELOC(_apminfo+APM_CODE16)
	movw	%dx,RELOC(_apminfo+APM_DATA)
	movw	%si,RELOC(_apminfo+APM_CODE32_LEN)
	shrl	$16, %esi
	movw	%si,RELOC(_apminfo+APM_DATA_LEN)
d2177 2
d2180 1
d2193 3
d2197 1
a2197 1
/*	movl	%ax,%ds		# can't toss %ds, we need it for apmstatus*/
a2207 3
	pushfl
	cli
	pushl	%ds
d2234 2
a2235 11
		
_apm_init_image:
	.globl	_apm_init_image

8:
#include "lib/apm_init/apm_init.inc"
9:

_apm_init_image_size:
	.globl	_apm_init_image_size
	.long	9b - 8b
a2236 1
#endif /* APM */
@


1.29
log
@correct return value on apmcall failure
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.28 1997/07/18 06:49:26 mickey Exp $	*/
a67 1
#include <i386/isa/debug.h>
@


1.28
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.s,v 1.27 1997/07/18 05:32:27 mickey Exp $	*/
d2313 1
@


1.27
log
@use isa's definition for IOM_*
Id
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 1
a67 1
#inclide <dev/isa/isareg.h>
@


1.26
log
@map two pages of Sysmap rather than 1.
fixes ramdisk loading problem (kernel > 4M).
some comments.
@
text
@d1 1
d67 1
a68 6

/* XXX temporary kluge; these should not be here */
#define	IOM_BEGIN	0x0a0000	/* start of I/O memory "hole" */
#define	IOM_END		0x100000	/* end of I/O memory "hole" */
#define	IOM_SIZE	(IOM_END - IOM_BEGIN)

@


1.25
log
@define kernel_text, just like other ports.
@
text
@d192 1
a192 1
	_kernel_text = start
d494 1
a494 1
	movl	$RELOC(_end),%edi
d501 1
a501 1
	movl	%eax,%edi
d506 2
a507 3
	movl	%edi,%esi			# edi = esym ? esym : end
	addl	$PGOFSET,%esi			# page align up
	andl	$~PGOFSET,%esi
d510 3
a512 4
	leal	(TABLESIZE)(%esi),%ecx		# end of tables
	subl	%edi,%ecx			# size of tables
	shrl	$2,%ecx
	xorl	%eax,%eax
d567 15
d583 2
a584 6
	/* Install a PDE for temporary double map of kernel text. */
	leal	(SYSMAP+PG_V|PG_KW)(%esi),%eax		# pte for KPT in proc 0,
	movl	%eax,(PROC0PDIR+0*4)(%esi)		# which is where temp maps!
	/* Map kernel PDEs. */
	movl	$NKPDE,%ecx				# for this many pde s,
	leal	(PROC0PDIR+KPTDI*4)(%esi),%ebx		# offset of pde for kernel
d589 1
a589 1
	movl	%eax,(PROC0PDIR+PTDPTDI*4)(%esi)	# which is where PTmap maps!
d608 1
@


1.24
log
@Set up intrframe correctly for FPU exceptions again
@
text
@d172 1
a172 1
_cpu:		.long	0	# are we 386, 386sx, or 486
d191 2
@


1.23
log
@Don't push _cpl before calling _npxintr, it is never used (or popped off
the stack!)
@
text
@d2039 2
a2040 4
#if 0
	pushl	_cpl			# this is apparently not used for anything
#endif
	pushl	%esp
d2043 1
a2043 1
	addl	$8,%esp
@


1.22
log
@More siginfo implementations (alpha and mips might even work)
move "siginfo_t *" to 2nd arg of signal handler as 1003.1b requires.
I really wish I had 1003.1b documentation.
@
text
@d2039 3
a2041 1
	pushl	_cpl
@


1.21
log
@NetBSD PR#2910: Recognize Pentium Pro machines
@
text
@d2043 1
a2043 1
	addl	$4,%esp
@


1.20
log
@remrq -> remrunqueue
@
text
@d448 3
@


1.19
log
@avoid long lines
@
text
@d1603 1
a1603 1
 * remrq(struct proc *p);
d1606 1
a1606 1
ENTRY(remrq)
d1630 1
a1630 1
3:	.asciz	"remrq"
@


1.18
log
@Get memory configuration from boot blocks or /boot when it becomes
available.  Use MEM_COMPUTE option to use old behavior.  Use EXTMEM_SIZE
to override extended memory size.
@
text
@d159 2
a160 1
	.globl	_cpu,_cpu_vendor,_cold,_cnvmem,_extmem,_esym,_boothowto,_bootdev,_atdevbase
@


1.17
log
@repair fusword/susword protos
@
text
@d159 1
a159 1
	.globl	_cpu,_cpu_vendor,_cold,_esym,_boothowto,_bootdev,_atdevbase
d175 2
d208 5
@


1.16
log
@profiling macro needs semicolons, obviously hasn't been used in a long time
@
text
@d1272 1
a1272 1
 * fusword(caddr_t uaddr);
d1381 1
a1381 1
 * susword(caddr_t uaddr, short x);
@


1.15
log
@someone send me an i386 assembler book
@
text
@d140 9
a148 9
	pushl	%ebp \
	movl	%esp,%ebp \
	pushl	%ebx \
	pushl	_cpl \
	movl	$0,_cpl \
	call	_Xspllower \
	call	mcount \
	popl	_cpl \
	leal	4(%esp),%esp \
@


1.14
log
@spin processing ast events before going back to userland; my fix
@
text
@d2077 1
a2077 1
	j	2b
d2144 1
a2144 1
	j	2b
@


1.13
log
@Added a pctr pseudo-device for accessing the Pentium performance counters,
and a program pctrctl to set the counter functions.
@
text
@d2077 1
d2144 1
@


1.12
log
@Reset the cycle counter at boot on P5 or better wether or not we have been
configured for NTP
@
text
@d45 1
a1639 1
#endif
a1640 1
#if NAPM > 0
d1644 9
a1652 2
1:	
#endif
@


1.11
log
@sync with 0504; prototype changes
@
text
@a439 1
#ifdef NTP
a443 1
#endif
@


1.10
log
@Use MSR 0x10, not 10 to clear the Pentium instruction counter; from David
Mazieres.  Dunno how this could have worked with 10...
@
text
@d1 1
a1 1
/*	$NetBSD: locore.s,v 1.144 1996/04/03 05:48:35 mycroft Exp $	*/
d1916 2
a1917 3
 * savectx(struct pcb *pcb, int altreturn);
 * Update pcb, saving current processor state and arranging for alternate
 * return in cpu_switch() if altreturn is true.
@


1.9
log
@Zero the instruction counter on Pentium's after detecting one if we have
NTP code compiled in; prevents division errors in microtime()
@
text
@d443 1
a443 1
	movl $10,%ecx
@


1.8
log
@from CMU(CODA or MACH, by Robert Baron):
Under the GPROF conditional emit a call to mcount for bcopy, bzero,
copyin, and copyout, so they can be profiled.  During a kernel build
these 4 routines account for 14% of the time in the kernel.
@
text
@d440 7
@


1.7
log
@Pull in John Kohl's [jtk@@netbsd.org] most recent (15Apr96) APM and PCMCIA work
(original PCMCIA framework  by Stefan Grefen [grefen@@convex.com]).
@
text
@d136 14
d818 5
d825 1
d876 3
d880 1
d975 3
d979 1
d2159 3
d2163 1
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d44 1
d146 10
d192 96
d473 1
a473 1
	movl	%edi,%esi			# edi = esym ?: end
d1591 3
d1604 3
d1608 6
d2197 75
@


1.5
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 1
a1 1
/*	$NetBSD: locore.s,v 1.143 1996/02/02 02:36:40 mycroft Exp $	*/
a2 2
#undef DIAGNOSTIC
#define DIAGNOSTIC
@


1.4
log
@SIGBUS is an alignment fault. SIGSEGV is an access violation
@
text
@d1 1
a1 1
/*	$NetBSD: locore.s,v 1.142 1996/01/07 03:59:28 mycroft Exp $	*/
d45 1
a45 1
#include "assym.s"
d1890 1
a1890 1
 * This will cause the process to get a SIGSEGV.
@


1.3
log
@from netbsd:
Deal with GCC's dead code elimination being suboptimal.
Modify splraise() to allow better optimization.
Make cpl, ipending, and astpending volatile.
Make sure interrupts are disabled before jumping to a resume point,
to prevent races.
Make FPU faults use INTRFASTEXIT, and remove INTREXIT.
Build the frame for recursive interrupts manually, and make sure to
disable interrupts to avoid races.
VS: ----------------------------------------------------------------------
@
text
@d1890 1
a1890 1
 * This will cause the process to get a SIGBUS.
@


1.2
log
@clear segment registers that some roms fail to
@
text
@d1 1
a1 1
/*	$NetBSD: locore.s,v 1.139.2.1 1995/10/24 16:32:42 mycroft Exp $	*/
a103 2
#define	INTREXIT \
	jmp	_Xdoreti
d1531 1
a1531 1
	call	_spllower		# process pending interrupts
d1878 1
a1878 1
	INTREXIT
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: locore.s,v 1.139 1995/10/11 04:19:40 mycroft Exp $	*/
d479 5
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

