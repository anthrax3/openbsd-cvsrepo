head	1.36;
access;
symbols
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.31.0.4
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.6
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.29.0.6
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.27.0.8
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.6
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.4
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.26.0.4
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.25.0.8
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.10
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.6
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.4
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.23.0.4
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.16.0.8
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.6
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.14
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.12
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.10
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.8
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.6
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.4
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2017.07.19.14.34.10;	author kettenis;	state Exp;
branches;
next	1.35;
commitid	es0BDttRZ5dMyViE;

1.35
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.34;
commitid	2Gtqjzrin9LL2yHk;

1.34
date	2017.03.03.20.49.47;	author bluhm;	state Exp;
branches;
next	1.33;
commitid	HvXIPFg1fj3hCUTx;

1.33
date	2016.03.14.23.08.05;	author krw;	state Exp;
branches;
next	1.32;
commitid	kCz5QgxnxRMKOzNf;

1.32
date	2016.02.27.13.08.07;	author mpi;	state Exp;
branches;
next	1.31;
commitid	hnv9KfQtxhCytAnd;

1.31
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.30;
commitid	uzzBR7hz9ncd4O6G;

1.30
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2013.07.04.19.06.48;	author sf;	state Exp;
branches;
next	1.28;

1.28
date	2013.05.12.20.47.44;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2011.04.04.22.37.30;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2010.04.01.19.48.50;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2007.11.16.16.16.06;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.11.14.17.52.36;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2006.11.29.22.40.13;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2006.10.24.19.03.10;	author marco;	state Exp;
branches;
next	1.21;

1.21
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.11.13.21.11;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.08.21.04.57;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.07.23.15.01;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.05.14.46.46;	author marco;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.20.20.18.53;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.02.16.29.55;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.21.22.41.11;	author andreas;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.18.02.43.12;	author andreas;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.32;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.18.23.26.18;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.07.05.14.26.34;	author hugh;	state Exp;
branches;
next	1.7;

1.7
date	99.12.30.16.36.38;	author deraadt;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	96.05.07.07.21.34;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.16.24;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.18.19.18.06;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.04.17.05.18.50;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.03.11.11.16.42;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.32;	author deraadt;	state Exp;
branches;
next	;

1.7.2.1
date	2001.04.18.16.07.14;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.05.17.16.07.37;	author andreas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2003.05.18.17.41.15;	author niklas;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2003.06.07.11.11.36;	author ho;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Add a enter_ddb() "accessop" to wsdisplay(4) to allow KMS drivers to bypass
the modeset lock when entering ddb.  This avoids triggering various asserts
when the kernel panics while running X.

ok deraadt@@
@
text
@/*	$OpenBSD: db_interface.c,v 1.35 2017/04/30 16:45:45 mpi Exp $	*/
/*	$NetBSD: db_interface.c,v 1.22 1996/05/03 19:42:00 christos Exp $	*/

/*
 * Mach Operating System
 * Copyright (c) 1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 *
 *	db_interface.c,v 2.4 1991/02/05 17:11:13 mrt (CMU)
 */

/*
 * Interface to new debugger.
 */
#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/systm.h>
#include <sys/mutex.h>

#include <uvm/uvm_extern.h>

#include <dev/cons.h>

#include <machine/db_machdep.h>

#include <ddb/db_sym.h>
#include <ddb/db_command.h>
#include <ddb/db_extern.h>
#include <ddb/db_access.h>
#include <ddb/db_output.h>
#include <ddb/db_run.h>
#include <ddb/db_var.h>

#include "acpi.h"
#if NACPI > 0
#include <dev/acpi/acpidebug.h>
#endif /* NACPI > 0 */

#include "wsdisplay.h"
#if NWSDISPLAY > 0
#include <dev/wscons/wsdisplayvar.h>
#endif

extern label_t	*db_recover;
extern char *trap_type[];
extern int trap_types;

#ifdef MULTIPROCESSOR
extern volatile int ddb_state;
boolean_t	 db_switch_cpu;
long		 db_switch_to_cpu;
#endif

db_regs_t	ddb_regs;
int	db_active = 0;

void kdbprinttrap(int, int);
void db_sysregs_cmd(db_expr_t, int, db_expr_t, char *);
#ifdef MULTIPROCESSOR
void db_cpuinfo_cmd(db_expr_t, int, db_expr_t, char *);
void db_startproc_cmd(db_expr_t, int, db_expr_t, char *);
void db_stopproc_cmd(db_expr_t, int, db_expr_t, char *);
void db_ddbproc_cmd(db_expr_t, int, db_expr_t, char *);
#endif /* MULTIPROCESSOR */

/*
 * Print trap reason.
 */
void
kdbprinttrap(int type, int code)
{
	db_printf("kernel: ");
	if (type >= trap_types || type < 0)
		db_printf("type %d", type);
	else
		db_printf("%s", trap_type[type]);
	db_printf(" trap, code=%x\n", code);
}

/*
 *  db_ktrap - field a TRACE or BPT trap
 */
int
db_ktrap(int type, int code, db_regs_t *regs)
{
	int s;

#if NWSDISPLAY > 0
	wsdisplay_enter_ddb();
#endif

	switch (type) {
	case T_BPTFLT:	/* breakpoint */
	case T_TRCTRAP:	/* single_step */
	case T_NMI:	/* NMI */
	case T_NMI|T_USER:
	case -1:	/* keyboard interrupt */
		break;
	default:
		if (!db_panic)
			return (0);

		kdbprinttrap(type, code);
		if (db_recover != 0) {
			db_error("Faulted in DDB; continuing...\n");
			/*NOTREACHED*/
		}
	}

#ifdef MULTIPROCESSOR
	mtx_enter(&ddb_mp_mutex);
	if (ddb_state == DDB_STATE_EXITING)
		ddb_state = DDB_STATE_NOT_RUNNING;
	mtx_leave(&ddb_mp_mutex);
	while (db_enter_ddb()) {
#endif /* MULTIPROCESSOR */

	/* XXX Should switch to kdb`s own stack here. */

	ddb_regs = *regs;
	if (KERNELMODE(regs->tf_cs, regs->tf_eflags)) {
		/*
		 * Kernel mode - esp and ss not saved
		 */
		ddb_regs.tf_esp = (int)&regs->tf_esp;	/* kernel stack pointer */
		__asm__("movw %%ss,%w0" : "=r" (ddb_regs.tf_ss));
	}
	ddb_regs.tf_cs &= 0xffff;
	ddb_regs.tf_ds &= 0xffff;
	ddb_regs.tf_es &= 0xffff;
	ddb_regs.tf_fs &= 0xffff;
	ddb_regs.tf_gs &= 0xffff;
	ddb_regs.tf_ss &= 0xffff;

	s = splhigh();
	db_active++;
	cnpollc(TRUE);
	db_trap(type, code);
	cnpollc(FALSE);
	db_active--;
	splx(s);

	regs->tf_fs     = ddb_regs.tf_fs & 0xffff;
	regs->tf_gs     = ddb_regs.tf_gs & 0xffff;
	regs->tf_es     = ddb_regs.tf_es & 0xffff;
	regs->tf_ds     = ddb_regs.tf_ds & 0xffff;
	regs->tf_edi    = ddb_regs.tf_edi;
	regs->tf_esi    = ddb_regs.tf_esi;
	regs->tf_ebp    = ddb_regs.tf_ebp;
	regs->tf_ebx    = ddb_regs.tf_ebx;
	regs->tf_edx    = ddb_regs.tf_edx;
	regs->tf_ecx    = ddb_regs.tf_ecx;
	regs->tf_eax    = ddb_regs.tf_eax;
	regs->tf_eip    = ddb_regs.tf_eip;
	regs->tf_cs     = ddb_regs.tf_cs & 0xffff;
	regs->tf_eflags = ddb_regs.tf_eflags;
	if (!KERNELMODE(regs->tf_cs, regs->tf_eflags)) {
		/* ring transit - saved esp and ss valid */
		regs->tf_esp    = ddb_regs.tf_esp;
		regs->tf_ss     = ddb_regs.tf_ss & 0xffff;
	}


#ifdef MULTIPROCESSOR
		if (!db_switch_cpu)
			ddb_state = DDB_STATE_EXITING;
	}
#endif /* MULTIPROCESSOR */
	return (1);
}

void
db_sysregs_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	int64_t idtr, gdtr;
	uint32_t cr;
	uint16_t ldtr, tr;

	__asm__ volatile("sidt %0" : "=m" (idtr));
	db_printf("idtr:   0x%08llx/%04llx\n", idtr >> 16, idtr & 0xffff);

	__asm__ volatile("sgdt %0" : "=m" (gdtr));
	db_printf("gdtr:   0x%08llx/%04llx\n", gdtr >> 16, gdtr & 0xffff);

	__asm__ volatile("sldt %0" : "=g" (ldtr));
	db_printf("ldtr:   0x%04x\n", ldtr);

	__asm__ volatile("str %0" : "=g" (tr));
	db_printf("tr:     0x%04x\n", tr);

	__asm__ volatile("movl %%cr0,%0" : "=r" (cr));
	db_printf("cr0:    0x%08x\n", cr);

	__asm__ volatile("movl %%cr2,%0" : "=r" (cr));
	db_printf("cr2:    0x%08x\n", cr);

	__asm__ volatile("movl %%cr3,%0" : "=r" (cr));
	db_printf("cr3:    0x%08x\n", cr);

	__asm__ volatile("movl %%cr4,%0" : "=r" (cr));
	db_printf("cr4:    0x%08x\n", cr);
}

#ifdef MULTIPROCESSOR
void
db_cpuinfo_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	int i;

	for (i = 0; i < MAXCPUS; i++) {
		if (cpu_info[i] != NULL) {
			db_printf("%c%4d: ", (i == cpu_number()) ? '*' : ' ',
			    cpu_info[i]->ci_dev.dv_unit);
			switch(cpu_info[i]->ci_ddb_paused) {
			case CI_DDB_RUNNING:
				db_printf("running\n");
				break;
			case CI_DDB_SHOULDSTOP:
				db_printf("stopping\n");
				break;
			case CI_DDB_STOPPED:
				db_printf("stopped\n");
				break;
			case CI_DDB_ENTERDDB:
				db_printf("entering ddb\n");
				break;
			case CI_DDB_INDDB:
				db_printf("ddb\n");
				break;
			default:
				db_printf("? (%d)\n",
				    cpu_info[i]->ci_ddb_paused);
				break;
			}
		}
	}
}

void
db_startproc_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	int i;

	if (have_addr) {
		if (addr >= 0 && addr < MAXCPUS &&
		    cpu_info[addr] != NULL && addr != cpu_number())
			db_startcpu(addr);
		else
			db_printf("Invalid cpu %d\n", (int)addr);
	} else {
		for (i = 0; i < MAXCPUS; i++) {
			if (cpu_info[i] != NULL && i != cpu_number())
				db_startcpu(i);
		}
	}
}

void
db_stopproc_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	int i;

	if (have_addr) {
		if (addr >= 0 && addr < MAXCPUS &&
		    cpu_info[addr] != NULL && addr != cpu_number())
			db_stopcpu(addr);
		else
			db_printf("Invalid cpu %d\n", (int)addr);
	} else {
		for (i = 0; i < MAXCPUS; i++) {
			if (cpu_info[i] != NULL && i != cpu_number()) {
				db_stopcpu(i);
			}
		}
	}
}

void
db_ddbproc_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	if (have_addr) {
		if (addr >= 0 && addr < MAXCPUS &&
		    cpu_info[addr] != NULL && addr != cpu_number()) {
			db_stopcpu(addr);
			db_switch_to_cpu = addr;
			db_switch_cpu = 1;
			db_cmd_loop_done = 1;
		} else {
			db_printf("Invalid cpu %d\n", (int)addr);
		}
	} else {
		db_printf("CPU not specified\n");
	}
}
#endif /* MULTIPROCESSOR */

#if NACPI > 0
struct db_command db_acpi_cmds[] = {
	{ "disasm",	db_acpi_disasm,		CS_OWN,	NULL },
	{ "showval",	db_acpi_showval,	CS_OWN,	NULL },
	{ "tree",	db_acpi_tree,		0,	NULL },
	{ "trace",	db_acpi_trace,		0,	NULL },
	{ NULL,		NULL,			0,	NULL }
};
#endif /* NACPI > 0 */

struct db_command db_machine_command_table[] = {
	{ "sysregs",	db_sysregs_cmd,		0,	0 },
#ifdef MULTIPROCESSOR
	{ "cpuinfo",	db_cpuinfo_cmd,		0,	0 },
	{ "startcpu",	db_startproc_cmd,	0,	0 },
	{ "stopcpu",	db_stopproc_cmd,	0,	0 },
	{ "ddbcpu",	db_ddbproc_cmd,		0,	0 },
#endif /* MULTIPROCESSOR */
#if NACPI > 0
	{ "acpi",	NULL,			0,	db_acpi_cmds },
#endif /* NACPI > 0 */
	{ NULL, }
};

void
db_machine_init(void)
{
#ifdef MULTIPROCESSOR
	int i;
#endif /* MULTIPROCESSOR */

	db_machine_commands_install(db_machine_command_table);
#ifdef MULTIPROCESSOR
	for (i = 0; i < MAXCPUS; i++) {
		if (cpu_info[i] != NULL)
			cpu_info[i]->ci_ddb_paused = CI_DDB_RUNNING;
	}
#endif /* MULTIPROCESSOR */
}

void
db_enter(void)
{
	__asm__("int $3");
}
@


1.35
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.34 2017/03/03 20:49:47 bluhm Exp $	*/
d109 1
a109 1
	wsdisplay_switchtoconsole();
@


1.34
log
@Whan an amd64 machine got an NMI, the current process in user land
was killed with SIGBUS.  Better drop to ddb regardless wether a
user process is currently scheduled or not.  NMI signals hardware
failure or a debug button.  The code in i386 trap() has always been
that way.  The switch in db_ktrap() must also not depend on the
fact wether kernel or user land is running.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.33 2016/03/14 23:08:05 krw Exp $	*/
d358 1
a358 1
Debugger(void)
@


1.33
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.32 2016/02/27 13:08:07 mpi Exp $	*/
d116 1
@


1.32
log
@Rename kdb_trap() into db_ktrap().

The goal is to include it in the list of functions that must not be
instrumented.  All ddb(8) functions should be in this list and have
their names start with 'db_'.

ok visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.31 2014/09/14 14:17:23 jsg Exp $	*/
d337 1
a337 1
	{ (char *)0, }
@


1.31
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.30 2014/03/29 18:09:29 guenther Exp $	*/
d101 1
a101 1
 *  kdb_trap - field a TRACE or BPT trap
d104 1
a104 1
kdb_trap(int type, int code, db_regs_t *regs)
@


1.30
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.29 2013/07/04 19:06:48 sf Exp $	*/
a35 1
#include <sys/proc.h>
@


1.29
log
@format string fix

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.28 2013/05/12 20:47:44 kettenis Exp $	*/
d199 1
a199 1
	__asm__ __volatile__("sidt %0" : "=m" (idtr));
d202 1
a202 1
	__asm__ __volatile__("sgdt %0" : "=m" (gdtr));
d205 1
a205 1
	__asm__ __volatile__("sldt %0" : "=g" (ldtr));
d208 1
a208 1
	__asm__ __volatile__("str %0" : "=g" (tr));
d211 1
a211 1
	__asm__ __volatile__("movl %%cr0,%0" : "=r" (cr));
d214 1
a214 1
	__asm__ __volatile__("movl %%cr2,%0" : "=r" (cr));
d217 1
a217 1
	__asm__ __volatile__("movl %%cr3,%0" : "=r" (cr));
d220 1
a220 1
	__asm__ __volatile__("movl %%cr4,%0" : "=r" (cr));
@


1.28
log
@Tell wsdisplay(4) to switch back to the console screen upon entering ddb(4).
This gives users a decent chance to see panic messages and interact with ddb(4)
when they're running X on hardware for which we have a KMS driver.  Currently
that means inteldrm(4).

ok jsg@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.27 2011/04/04 22:37:30 miod Exp $	*/
d200 1
a200 2
	db_printf("idtr:   0x%08x/%04x\n",
	    (unsigned int)(idtr >> 16), idtr & 0xffff);
d203 1
a203 2
	db_printf("gdtr:   0x%08x/%04x\n",
	    (unsigned int)(gdtr >> 16), gdtr & 0xffff);
@


1.27
log
@Make sure to clear the upper bits of the segment selectors in ddb_regs
before entering ddb for real, so that `show registers' displays (what passes
for) sane values for them.
Noticed & prodded by mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.26 2010/04/01 19:48:50 kettenis Exp $	*/
d60 5
d108 4
@


1.26
log
@Don't index cpu_info by apic id, but by device unit number instead.  Recent
Intel CPUs come up with apic id's >= 32, even on systems with less than 32
logical CPUs.

ok krw@@, marco@@; tested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.25 2007/11/16 16:16:06 deraadt Exp $	*/
d139 6
@


1.25
log
@fix the bus_space #define nightmare, so that amd64 and i386 are much more
uniform. as a result shared code like acpi needs less #ifdef's
ok marco kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.24 2007/11/14 17:52:36 miod Exp $	*/
a79 1
int db_cpuid2apic(int);
a211 13
int
db_cpuid2apic(int id)
{
	int apic;

	for (apic = 0; apic < MAXCPUS; apic++) {
		if (cpu_info[apic] != NULL &&
		    cpu_info[apic]->ci_dev.dv_unit == id)
			return (apic);
	}
	return (-1);
}

d249 1
a249 1
	int apic;
d252 3
a254 4
		apic = db_cpuid2apic(addr);
		if (apic >= 0 && apic < MAXCPUS &&
		    cpu_info[apic] != NULL && apic != cpu_number())
			db_startcpu(apic);
d258 3
a260 4
		for (apic = 0; apic < MAXCPUS; apic++) {
			if (cpu_info[apic] != NULL && apic != cpu_number()) {
				db_startcpu(apic);
			}
d268 1
a268 1
	int apic;
d271 3
a273 4
		apic = db_cpuid2apic(addr);
		if (apic >= 0 && apic < MAXCPUS &&
		    cpu_info[apic] != NULL && apic != cpu_number())
			db_stopcpu(apic);
d277 3
a279 3
		for (apic = 0; apic < MAXCPUS; apic++) {
			if (cpu_info[apic] != NULL && apic != cpu_number()) {
				db_stopcpu(apic);
a287 2
	int apic;

d289 4
a292 5
		apic = db_cpuid2apic(addr);
		if (apic >= 0 && apic < MAXCPUS &&
		    cpu_info[apic] != NULL && apic != cpu_number()) {
			db_stopcpu(apic);
			db_switch_to_cpu = apic;
@


1.24
log
@Be consistent in db_cmd_loop_done declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.23 2006/11/29 22:40:13 miod Exp $	*/
d218 1
a218 1
	for (apic = 0; apic < I386_MAXPROCS; apic++) {
d231 1
a231 1
	for (i = 0; i < I386_MAXPROCS; i++) {
d267 1
a267 1
		if (apic >= 0 && apic < I386_MAXPROCS &&
d273 1
a273 1
		for (apic = 0; apic < I386_MAXPROCS; apic++) {
d288 1
a288 1
		if (apic >= 0 && apic < I386_MAXPROCS &&
d294 1
a294 1
		for (apic = 0; apic < I386_MAXPROCS; apic++) {
d309 1
a309 1
		if (apic >= 0 && apic < I386_MAXPROCS &&
d357 1
a357 1
	for (i = 0; i < I386_MAXPROCS; i++) {
@


1.23
log
@Nuke all commons but one, and enable --warn-common in LINKFLAGS.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.22 2006/10/24 19:03:10 marco Exp $	*/
d52 1
a62 1
extern boolean_t db_cmd_loop_done;
@


1.22
log
@Hook brand new trace function into ddb.  Now users can send useful traces
without enabling acpi debug.  Usage "machine acpi trace".

ok jordan
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.21 2006/09/19 11:06:33 jsg Exp $	*/
d70 1
@


1.21
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.20 2006/05/11 13:21:11 mickey Exp $	*/
d328 1
@


1.20
log
@kill trainling spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.19 2006/03/08 21:04:57 marco Exp $	*/
d86 1
a86 2
kdbprinttrap(type, code)
	int type, code;
d100 1
a100 3
kdb_trap(type, code, regs)
	int type, code;
	db_regs_t *regs;
d178 1
a178 5
db_sysregs_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
d347 1
a347 1
db_machine_init()
d363 1
a363 1
Debugger()
@


1.19
log
@Glue showval into ddb.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.18 2006/03/07 23:15:01 marco Exp $	*/
d4 1
a4 1
/* 
d8 1
a8 1
 * 
d14 1
a14 1
 * 
d18 1
a18 1
 * 
d20 1
a20 1
 * 
d25 1
a25 1
 * 
@


1.18
log
@Add hooks for "machine acpi disasm"

ok jordan
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.17 2006/03/05 14:46:46 marco Exp $	*/
d333 1
@


1.17
log
@Hook acpi to ddb since we need to be able to do some live debugging.

Lots and lots of help from miod@@ and deraadt@@
ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.16 2004/07/20 20:18:53 art Exp $	*/
d332 1
@


1.16
log
@Use mutex instead of SIMPLELOCK for protecting ddb on mp systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.15 2004/07/02 16:29:55 niklas Exp $	*/
d54 5
d330 7
d345 3
@


1.15
log
@Maintain %f and %gs over traps.  Mostly from NetBSD.  Preparation for SMP
speedups.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.14 2004/06/21 22:41:11 andreas Exp $	*/
d39 1
d120 1
a120 2
	s = splhigh();
	SIMPLE_LOCK(&ddb_mp_slock);
d123 1
a123 2
	SIMPLE_UNLOCK(&ddb_mp_slock);
	splx(s);
a348 1
	SIMPLE_LOCK_INIT(&ddb_mp_slock);
@


1.14
log
@Make 'machine ddbcpu' work, and use CPU device number instead of APIC id
KNF lesson and ok from niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.13 2004/06/13 21:49:15 niklas Exp $	*/
d147 2
@


1.13
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 3
a61 3
extern boolean_t	 db_switch_cpu;
extern long		 db_switch_to_cpu;

d73 1
d118 10
d165 6
d213 15
a227 5
void db_cpuinfo_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
d234 1
a234 1
			    i);
d260 2
a261 5
void db_startproc_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
d263 1
a263 1
	int i;
d266 4
a269 3
		if (addr >= 0 && addr < I386_MAXPROCS
		    && cpu_info[addr] != NULL && addr != cpu_number())
			db_startcpu(addr);
d273 3
a275 3
		for (i = 0; i < I386_MAXPROCS; i++) {
			if (cpu_info[i] != NULL && i != cpu_number()) {
				db_startcpu(i);
d281 2
a282 5
void db_stopproc_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
d284 1
a284 1
	int i;
d287 4
a290 3
		if (addr >= 0 && addr < I386_MAXPROCS
		    && cpu_info[addr] != NULL && addr != cpu_number())
			db_stopcpu(addr);
d294 3
a296 3
		for (i = 0; i < I386_MAXPROCS; i++) {
			if (cpu_info[i] != NULL && i != cpu_number()) {
				db_stopcpu(i);
d302 2
a303 5
void db_ddbproc_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
d305 2
d308 5
a312 3
		if (addr >= 0 && addr < I386_MAXPROCS
		    && cpu_info[addr] != NULL && addr != cpu_number()) {
			db_switch_to_cpu = addr;
@


1.12
log
@Add 'machine sysregs' command to ddb for 1386; show idtr, gdtr, ldtr, tr
and cr0-ct4
OK by niklas@@ and more or less by ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.11 2002/03/14 01:26:32 millert Exp $	*/
d56 7
d68 6
d125 1
a125 1
		asm("movw %%ss,%w0" : "=r" (ddb_regs.tf_ss));
d195 105
d302 6
d314 3
d319 7
d331 1
a331 1
	asm("int $3");
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.10 2002/02/18 23:26:18 mickey Exp $	*/
d60 1
d142 50
@


1.10
log
@copy the segment regs w/ zeroing upper 16 bits
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.9 2001/11/06 19:53:14 miod Exp $	*/
d59 1
a59 1
void kdbprinttrap __P((int, int));
@


1.9
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.8 2000/07/05 14:26:34 hugh Exp $	*/
d122 2
a123 2
	regs->tf_es     = ddb_regs.tf_es;
	regs->tf_ds     = ddb_regs.tf_ds;
d132 1
a132 1
	regs->tf_cs     = ddb_regs.tf_cs;
d137 1
a137 1
		regs->tf_ss     = ddb_regs.tf_ss;
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.9 2001/11/06 19:53:14 miod Exp $	*/
d59 1
a59 1
void kdbprinttrap(int, int);
d122 2
a123 2
	regs->tf_es     = ddb_regs.tf_es & 0xffff;
	regs->tf_ds     = ddb_regs.tf_ds & 0xffff;
d132 1
a132 1
	regs->tf_cs     = ddb_regs.tf_cs & 0xffff;
d137 1
a137 1
		regs->tf_ss     = ddb_regs.tf_ss & 0xffff;
@


1.8
log
@Decouple memory access functions from db_interface.c so they can be
shared with upcoming KGDB. As per NetBSD.
Ok'd by niklas.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.7 1999/12/30 16:36:38 deraadt Exp $	*/
d40 1
a40 1
#include <vm/vm.h>
@


1.7
log
@when db_panic is set, ignore ddb errors that come through the kdb_trap()
interface as well; assar@@stacken.kth.se
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.6 1996/05/07 07:21:34 deraadt Exp $	*/
a140 65
}

/*
 * Read bytes from kernel address space for debugger.
 */
void
db_read_bytes(addr, size, data)
	vm_offset_t	addr;
	register size_t	size;
	register char	*data;
{
	register char	*src;

	src = (char *)addr;
	while (size-- > 0)
		*data++ = *src++;
}

pt_entry_t *pmap_pte __P((pmap_t, vm_offset_t));

/*
 * Write bytes to kernel address space for debugger.
 */
void
db_write_bytes(addr, size, data)
	vm_offset_t	addr;
	register size_t	size;
	register char	*data;
{
	register char	*dst;

	register pt_entry_t *ptep0 = 0;
	pt_entry_t	oldmap0 = { 0 };
	vm_offset_t	addr1;
	register pt_entry_t *ptep1 = 0;
	pt_entry_t	oldmap1 = { 0 };
	extern char	etext;

	if (addr >= VM_MIN_KERNEL_ADDRESS &&
	    addr < (vm_offset_t)&etext) {
		ptep0 = pmap_pte(pmap_kernel(), addr);
		oldmap0 = *ptep0;
		*(int *)ptep0 |= /* INTEL_PTE_WRITE */ PG_RW;

		addr1 = i386_trunc_page(addr + size - 1);
		if (i386_trunc_page(addr) != addr1) {
			/* data crosses a page boundary */
			ptep1 = pmap_pte(pmap_kernel(), addr1);
			oldmap1 = *ptep1;
			*(int *)ptep1 |= /* INTEL_PTE_WRITE */ PG_RW;
		}
		pmap_update();
	}

	dst = (char *)addr;

	while (size-- > 0)
		*dst++ = *data++;

	if (ptep0) {
		*ptep0 = oldmap0;
		if (ptep1)
			*ptep1 = oldmap1;
		pmap_update();
	}
@


1.7.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.8 2000/07/05 14:26:34 hugh Exp $	*/
d141 65
@


1.7.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
a40 1
#include <uvm/uvm_extern.h>
@


1.7.2.3
log
@Merge in trunk
@
text
@d122 2
a123 2
	regs->tf_es     = ddb_regs.tf_es & 0xffff;
	regs->tf_ds     = ddb_regs.tf_ds & 0xffff;
d132 1
a132 1
	regs->tf_cs     = ddb_regs.tf_cs & 0xffff;
d137 1
a137 1
		regs->tf_ss     = ddb_regs.tf_ss & 0xffff;
@


1.7.2.4
log
@Merge in -current from about a week ago
@
text
@d59 1
a59 1
void kdbprinttrap(int, int);
@


1.7.2.5
log
@Some i386-specific stuff:
Stop other CPUs when entering ddb
'machine sysregs' shows system registers not usually used by applications
'machine cpuinfo' shows the status of the processors
'machine startcpu n' starts CPU n
'machine stopcpu n' stops CPU n
'machine ddbcpu n' transfers ddb control to CPU n (not very useful yet
though since the second processor can't use the keyboard...)

Niklas said that I should test this first to at least make sure it
compiles, but I'm too anxious to do my first commit. :)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.7.2.4 2002/03/28 10:31:04 niklas Exp $	*/
a55 7
extern boolean_t db_cmd_loop_done;

#ifdef MULTIPROCESSOR
extern boolean_t	 db_switch_cpu;
extern long		 db_switch_to_cpu;

#endif
a59 7
void db_sysregs_cmd(db_expr_t, int, db_expr_t, char *);
#ifdef MULTIPROCESSOR
void db_cpuinfo_cmd(db_expr_t, int, db_expr_t, char *);
void db_startproc_cmd(db_expr_t, int, db_expr_t, char *);
void db_stopproc_cmd(db_expr_t, int, db_expr_t, char *);
void db_ddbproc_cmd(db_expr_t, int, db_expr_t, char *);
#endif /* MULTIPROCESSOR */
d111 1
a111 1
		__asm__("movw %%ss,%w0" : "=r" (ddb_regs.tf_ss));
a143 171
db_sysregs_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	int64_t idtr, gdtr;
	uint32_t cr;
	uint16_t ldtr, tr;

	__asm__ __volatile__("sidt %0" : "=m" (idtr));
	db_printf("idtr:   0x%08x/%04x\n",
	    (unsigned int)(idtr >> 16), idtr & 0xffff);

	__asm__ __volatile__("sgdt %0" : "=m" (gdtr));
	db_printf("gdtr:   0x%08x/%04x\n",
	    (unsigned int)(gdtr >> 16), gdtr & 0xffff);

	__asm__ __volatile__("sldt %0" : "=g" (ldtr));
	db_printf("ldtr:   0x%04x\n", ldtr);

	__asm__ __volatile__("str %0" : "=g" (tr));
	db_printf("tr:     0x%04x\n", tr);

	__asm__ __volatile__("movl %%cr0,%0" : "=r" (cr));
	db_printf("cr0:    0x%08x\n", cr);

	__asm__ __volatile__("movl %%cr2,%0" : "=r" (cr));
	db_printf("cr2:    0x%08x\n", cr);

	__asm__ __volatile__("movl %%cr3,%0" : "=r" (cr));
	db_printf("cr3:    0x%08x\n", cr);

	__asm__ __volatile__("movl %%cr4,%0" : "=r" (cr));
	db_printf("cr4:    0x%08x\n", cr);
}

#ifdef MULTIPROCESSOR
void db_cpuinfo_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	int i;

	for (i = 0; i < I386_MAXPROCS; i++) {
		if (cpu_info[i] != NULL) {
			db_printf("%c%4d: ", (i == cpu_number()) ? '*' : ' ',
			    i);
			switch(cpu_info[i]->ci_ddb_paused) {
			case CI_DDB_RUNNING:
				db_printf("running\n");
				break;
			case CI_DDB_SHOULDSTOP:
				db_printf("stopping\n");
				break;
			case CI_DDB_STOPPED:
				db_printf("stopped\n");
				break;
			case CI_DDB_ENTERDDB:
				db_printf("entering ddb\n");
				break;
			case CI_DDB_INDDB:
				db_printf("ddb\n");
				break;
			default:
				db_printf("? (%d)\n",
				    cpu_info[i]->ci_ddb_paused);
				break;
			}
		}
	}
}

void db_startproc_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	int i;

	if (have_addr) {
		if (addr >= 0 && addr < I386_MAXPROCS
		    && cpu_info[addr] != NULL && addr != cpu_number())
			db_startcpu(addr);
		else
			db_printf("Invalid cpu %d\n", (int)addr);
	} else {
		for (i = 0; i < I386_MAXPROCS; i++) {
			if (cpu_info[i] != NULL && i != cpu_number()) {
				db_startcpu(i);
			}
		}
	}
}

void db_stopproc_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	int i;

	if (have_addr) {
		if (addr >= 0 && addr < I386_MAXPROCS
		    && cpu_info[addr] != NULL && addr != cpu_number())
			db_stopcpu(addr);
		else
			db_printf("Invalid cpu %d\n", (int)addr);
	} else {
		for (i = 0; i < I386_MAXPROCS; i++) {
			if (cpu_info[i] != NULL && i != cpu_number()) {
				db_stopcpu(i);
			}
		}
	}
}

void db_ddbproc_cmd(addr, have_addr, count, modif)
	db_expr_t addr;
	int have_addr;
	db_expr_t count;
	char *modif;
{
	if (have_addr) {
		if (addr >= 0 && addr < I386_MAXPROCS
		    && cpu_info[addr] != NULL && addr != cpu_number()) {
			db_switch_to_cpu = addr;
			db_switch_cpu = 1;
			db_cmd_loop_done = 1;
		} else {
			db_printf("Invalid cpu %d\n", (int)addr);
		}
	} else {
		db_printf("CPU not specified\n");
	}
}
#endif /* MULTIPROCESSOR */

struct db_command db_machine_command_table[] = {
	{ "sysregs",	db_sysregs_cmd,		0,	0 },
#ifdef MULTIPROCESSOR
	{ "cpuinfo",	db_cpuinfo_cmd,		0,	0 },
	{ "startcpu",	db_startproc_cmd,	0,	0 },
	{ "stopcpu",	db_stopproc_cmd,	0,	0 },
	{ "ddbcpu",	db_ddbproc_cmd,		0,	0 },
#endif /* MULTIPROCESSOR */
	{ (char *)0, }
};

void
db_machine_init()
{
#ifdef MULTIPROCESSOR
	int i;
#endif /* MULTIPROCESSOR */

	db_machine_commands_install(db_machine_command_table);
#ifdef MULTIPROCESSOR
	for (i = 0; i < I386_MAXPROCS; i++) {
		if (cpu_info[i] != NULL)
			cpu_info[i]->ci_ddb_paused = CI_DDB_RUNNING;
	}
	simple_lock_init(&ddb_mp_slock);
#endif /* MULTIPROCESSOR */
}

void
d146 1
a146 1
	__asm__("int $3");
@


1.7.2.6
log
@Go back to defining simplelocks as noops, even if MULTIPROCESSOR.  Instead use
a new real simple recursive-lock capable lock implementation for the few
necessary locks (kernel, scheduler, tlb shootdown, printf and ddb MP).
This because we cannot trust the old fine-grained locks spread out all over
our kernel, and not really tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.7.2.5 2003/05/17 16:07:37 andreas Exp $	*/
d324 1
a324 1
	SIMPLE_LOCK_INIT(&ddb_mp_slock);
@


1.7.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.7.2.6 2003/05/18 17:41:15 niklas Exp $	*/
@


1.6
log
@sync with 0504; prototype changes
@
text
@d1 1
a1 1
/*	$OpenBSD: db_interface.c,v 1.5 1996/04/21 22:16:24 deraadt Exp $	*/
d51 1
a51 1

a85 5
#if 0
	if ((boothowto&RB_KDB) == 0)
		return(0);
#endif

d89 1
d93 3
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: db_interface.c,v 1.4 1996/04/18 19:18:06 niklas Exp $	*/
/*	$NetBSD: db_interface.c,v 1.21 1996/03/30 07:57:16 mycroft Exp $	*/
d38 1
a38 1
#include <sys/systm.h> /* just for boothowto --eichin */
d42 2
d46 7
d59 2
d82 1
a82 1
	register db_regs_t *regs;
d150 1
a150 1
	register int	size;
d156 1
a156 1
	while (--size >= 0)
d168 1
a168 1
	register int	size;
d198 1
a198 1
	while (--size >= 0)
@


1.4
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD: db_interface.c,v 1.3 1996/04/17 05:18:50 mickey Exp $	*/
/*	$NetBSD: db_interface.c,v 1.20 1996/03/15 00:07:18 chuck Exp $	*/
d45 2
d51 15
d68 1
a130 17
}

extern char *trap_type[];
extern int trap_types;

/*
 * Print trap reason.
 */
kdbprinttrap(type, code)
	int type, code;
{
	db_printf("kernel: ");
	if (type >= trap_types || type < 0)
		db_printf("type %d", type);
	else
		db_printf("%s", trap_type[type]);
	db_printf(" trap, code=%x\n", code);
@


1.3
log
@Cleanups & fixes from latest NetBSD primarily to run doscmd, etc.
GENERIC added to the compile/.cvsignore (it is used for 'make links'
for example), thus conf/GENERIC should appear magically ...
@
text
@d1 2
a2 2
/*	$OpenBSD: db_interface.c,v 1.2 1996/03/11 11:16:42 mickey Exp $	*/
/*	$NetBSD: db_interface.c,v 1.18 1995/10/10 04:45:03 mycroft Exp $	*/
@


1.2
log
@Debbuger changed towards the latest Mach.
Some minor changes for Linux ;) emulation.
Small bug fixes from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d197 1
a197 1
int
@


1.1
log
@Initial revision
@
text
@d1 1
d15 1
a15 1
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS 
d26 2
a27 2
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
a38 1
#include <setjmp.h>
d44 1
a44 1
extern jmp_buf	*db_recover;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
