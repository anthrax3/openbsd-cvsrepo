head	1.40;
access;
symbols
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.40.0.6
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.32.0.2
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.31.0.10
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.8
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.6
	OPENBSD_5_0:1.31.0.4
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	UBC_SYNC_A:1.1
	UBC_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.40
date	2015.07.18.19.21.03;	author sf;	state Exp;
branches;
next	1.39;
commitid	fKIY1z4O2YV68kXY;

1.39
date	2015.07.18.19.19.14;	author sf;	state Exp;
branches;
next	1.38;
commitid	2xGM1gJBLGHVxwpd;

1.38
date	2015.04.12.18.37.53;	author mlarkin;	state Exp;
branches;
next	1.37;
commitid	5ST94uMTezmXYdhY;

1.37
date	2014.09.21.16.14.52;	author sf;	state Exp;
branches;
next	1.36;
commitid	21xJ8BIHPTUlmyiK;

1.36
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.35;
commitid	uzzBR7hz9ncd4O6G;

1.35
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2014.01.24.21.20.23;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2013.10.26.16.55.12;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2013.06.02.18.16.42;	author gerhard;	state Exp;
branches;
next	1.31;

1.31
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	2010.07.25.21.43.35;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2010.07.23.07.21.02;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	2010.06.26.23.24.43;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2010.04.01.19.48.50;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.10.17.04.39;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.03.00.49.12;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2008.08.13.15.46.21;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.22;

1.22
date	2008.04.26.14.33.27;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.18.20.20.35;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2008.01.26.11.18.42;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.29.10.53.54;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.07.08.37.38;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2007.08.01.13.18.18;	author martin;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.25.15.55.26;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.12.20.22.58;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.19.09.29.33;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.20.21.15.01;	author tom;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.19.11.59.00;	author tom;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.23.21.17.18;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.20.17.50.40;	author gwk;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.29.09.54.16;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.27.15.37.51;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.13.18.42.16;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.10.21.09.22;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.28.02.00.20;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.28.01.41.53;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.14.00.06.32;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.13.21.49.15;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.14.10.02.26;	author ho;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.07.14.10.02.26;	author ho;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.07.15.15.10.55;	author ho;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.07.16.21.39.43;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.10.27.09.46.09;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2001.10.31.12.00.43;	author ho;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2001.11.13.21.00.51;	author niklas;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.1.2.9;

1.1.2.9
date	2004.06.07.19.35.42;	author art;	state Exp;
branches;
next	1.1.2.10;

1.1.2.10
date	2004.06.13.07.31.56;	author deraadt;	state Exp;
branches;
next	1.1.2.11;

1.1.2.11
date	2004.06.13.18.46.04;	author art;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Make {x86,i82489,x2apic,i386}_ipi return void

They always returned 0

ok mlarkin@@ kettenis@@
@
text
@/*	$OpenBSD: lapic.c,v 1.39 2015/07/18 19:19:14 sf Exp $	*/
/* $NetBSD: lapic.c,v 1.1.2.8 2000/02/23 06:10:50 sommerfeld Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/cpuvar.h>
#include <machine/pmap.h>
#include <machine/vmparam.h>
#include <machine/mpbiosvar.h>
#include <machine/pcb.h>
#include <machine/specialreg.h>
#include <machine/segments.h>

#include <machine/apicvar.h>
#include <machine/i82489reg.h>
#include <machine/i82489var.h>
#include <machine/pctr.h>

#include <dev/ic/i8253reg.h>

struct evcount clk_count;
#ifdef MULTIPROCESSOR
struct evcount ipi_count;
#endif

void	lapic_delay(int);
static u_int32_t lapic_gettick(void);
void	lapic_clockintr(void *);
void	lapic_initclocks(void);
void	lapic_map(paddr_t);

void
lapic_map(paddr_t lapic_base)
{
	int s;
	vaddr_t va = (vaddr_t)&local_apic;

	disable_intr();
	s = lapic_tpr;

	/*
	 * Map local apic.  If we have a local apic, it's safe to assume
	 * we're on a 486 or better and can use invlpg and non-cacheable PTE's
	 *
	 * Whap the PTE "by hand" rather than calling pmap_kenter_pa because
	 * the latter will attempt to invoke TLB shootdown code just as we
	 * might have changed the value of cpu_number()..
	 */

	pmap_pte_set(va, lapic_base, PG_RW | PG_V | PG_N);
	invlpg(va);

#ifdef MULTIPROCESSOR
	cpu_init_first();
#endif

	lapic_tpr = s;
	enable_intr();
}

/*
 * enable local apic
 */
void
lapic_enable(void)
{
	i82489_writereg(LAPIC_SVR, LAPIC_SVR_ENABLE | LAPIC_SPURIOUS_VECTOR);
}

void
lapic_disable(void)
{
	i82489_writereg(LAPIC_SVR, 0);
}

void
lapic_set_softvectors(void)
{
	idt_vec_set(LAPIC_SOFTCLOCK_VECTOR, Xintrsoftclock);
	idt_vec_set(LAPIC_SOFTNET_VECTOR, Xintrsoftnet);
	idt_vec_set(LAPIC_SOFTTTY_VECTOR, Xintrsofttty);
}

void
lapic_set_lvt(void)
{
	struct cpu_info *ci = curcpu();
	int i;
	struct mp_intr_map *mpi;

#ifdef MULTIPROCESSOR
	if (mp_verbose) {
		apic_format_redir(ci->ci_dev.dv_xname, "prelint", 0, 0,
		    i82489_readreg(LAPIC_LVINT0));
		apic_format_redir(ci->ci_dev.dv_xname, "prelint", 1, 0,
		    i82489_readreg(LAPIC_LVINT1));
	}
#endif

	if (strcmp(cpu_vendor, "AuthenticAMD") == 0) {
		/*
		 * Detect the presence of C1E capability mostly on latest
		 * dual-cores (or future) k8 family. This mis-feature renders
		 * the local APIC timer dead, so we disable it by reading
		 * the Interrupt Pending Message register and clearing both
		 * C1eOnCmpHalt (bit 28) and SmiOnCmpHalt (bit 27).
		 * 
		 * Reference:
		 *   "BIOS and Kernel Developer's Guide for AMD NPT
		 *    Family 0Fh Processors"
		 *   #32559 revision 3.00
		 */
		if ((cpu_id & 0x00000f00) == 0x00000f00 &&
		    (cpu_id & 0x0fff0000) >= 0x00040000) {
			uint64_t msr;

			msr = rdmsr(MSR_INT_PEN_MSG);
			if (msr & (IPM_C1E_CMP_HLT|IPM_SMI_CMP_HLT)) {
				msr &= ~(IPM_C1E_CMP_HLT|IPM_SMI_CMP_HLT);
				wrmsr(MSR_INT_PEN_MSG, msr);
			}
		}
	}

	for (i = 0; i < mp_nintrs; i++) {
		mpi = &mp_intrs[i];
		if (mpi->ioapic == NULL && (mpi->cpu_id == MPS_ALL_APICS
					    || mpi->cpu_id == ci->ci_apicid)) {
#ifdef DIAGNOSTIC
			if (mpi->ioapic_pin > 1)
				panic("lapic_set_lvt: bad pin value %d",
				    mpi->ioapic_pin);
#endif
			if (mpi->ioapic_pin == 0)
				i82489_writereg(LAPIC_LVINT0, mpi->redir);
			else
				i82489_writereg(LAPIC_LVINT1, mpi->redir);
		}
	}

#ifdef MULTIPROCESSOR
	if (mp_verbose) {
		apic_format_redir(ci->ci_dev.dv_xname, "timer", 0, 0,
		    i82489_readreg(LAPIC_LVTT));
		apic_format_redir(ci->ci_dev.dv_xname, "pcint", 0, 0,
		    i82489_readreg(LAPIC_PCINT));
		apic_format_redir(ci->ci_dev.dv_xname, "lint", 0, 0,
		    i82489_readreg(LAPIC_LVINT0));
		apic_format_redir(ci->ci_dev.dv_xname, "lint", 1, 0,
		    i82489_readreg(LAPIC_LVINT1));
		apic_format_redir(ci->ci_dev.dv_xname, "err", 0, 0,
		    i82489_readreg(LAPIC_LVERR));
	}
#endif
}

/*
 * Initialize fixed idt vectors for use by local apic.
 */
void
lapic_boot_init(paddr_t lapic_base)
{
	static int clk_irq = 0;
#ifdef MULTIPROCESSOR
	static int ipi_irq = 0;
#endif

	lapic_map(lapic_base);

#ifdef MULTIPROCESSOR
	idt_vec_set(LAPIC_IPI_VECTOR, Xintripi);
	idt_vec_set(LAPIC_IPI_INVLTLB, Xintripi_invltlb);
	idt_vec_set(LAPIC_IPI_INVLPG, Xintripi_invlpg);
	idt_vec_set(LAPIC_IPI_INVLRANGE, Xintripi_invlrange);
	idt_vec_set(LAPIC_IPI_RELOADCR3, Xintripi_reloadcr3);
#endif
	idt_vec_set(LAPIC_SPURIOUS_VECTOR, Xintrspurious);
	idt_vec_set(LAPIC_TIMER_VECTOR, Xintrltimer);

	evcount_attach(&clk_count, "clock", &clk_irq);
#ifdef MULTIPROCESSOR
	evcount_attach(&ipi_count, "ipi", &ipi_irq);
#endif
}

static __inline u_int32_t
lapic_gettick(void)
{
	return i82489_readreg(LAPIC_CCR_TIMER);
}

#include <sys/kernel.h>		/* for hz */

u_int32_t lapic_tval;

/*
 * this gets us up to a 4GHz busclock....
 */
u_int32_t lapic_per_second;
u_int32_t lapic_frac_usec_per_cycle;
u_int64_t lapic_frac_cycle_per_usec;
u_int32_t lapic_delaytab[26];

void
lapic_clockintr(void *arg)
{
	struct clockframe *frame = arg;

	hardclock(frame);

	clk_count.ec_count++;
}

void
lapic_startclock(void)
{
	/*
	 * Start local apic countdown timer running, in repeated mode.
	 *
	 * Mask the clock interrupt and set mode,
	 * then set divisor,
	 * then unmask and set the vector.
	 */
	i82489_writereg(LAPIC_LVTT, LAPIC_LVTT_TM|LAPIC_LVTT_M);
	i82489_writereg(LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
	i82489_writereg(LAPIC_ICR_TIMER, lapic_tval);
	i82489_writereg(LAPIC_LVTT, LAPIC_LVTT_TM|LAPIC_TIMER_VECTOR);
}

void
lapic_initclocks(void)
{
	lapic_startclock();

	i8254_inittimecounter_simple();
}

extern int gettick(void);	/* XXX put in header file */

static __inline void
wait_next_cycle(void)
{
	unsigned int tick, tlast;

	tlast = (1 << 16);	/* i8254 counter has 16 bits at most */
	for (;;) {
		tick = gettick();
		if (tick > tlast)
			return;
		tlast = tick;
	}
}

/*
 * Calibrate the local apic count-down timer (which is running at
 * bus-clock speed) vs. the i8254 counter/timer (which is running at
 * a fixed rate).
 *
 * The Intel MP spec says: "An MP operating system may use the IRQ8
 * real-time clock as a reference to determine the actual APIC timer clock
 * speed."
 *
 * We're actually using the IRQ0 timer.  Hmm.
 */
void
lapic_calibrate_timer(struct cpu_info *ci)
{
	unsigned int startapic, endapic;
	u_int64_t dtick, dapic, tmp;
	int i, ef = read_eflags();

	if (mp_verbose)
		printf("%s: calibrating local timer\n", ci->ci_dev.dv_xname);

	/*
	 * Configure timer to one-shot, interrupt masked,
	 * large positive number.
	 */
	i82489_writereg(LAPIC_LVTT, LAPIC_LVTT_M);
	i82489_writereg(LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
	i82489_writereg(LAPIC_ICR_TIMER, 0x80000000);

	disable_intr();

	/* wait for current cycle to finish */
	wait_next_cycle();

	startapic = lapic_gettick();

	/* wait the next hz cycles */
	for (i = 0; i < hz; i++)
		wait_next_cycle();

	endapic = lapic_gettick();
	write_eflags(ef);

	dtick = hz * TIMER_DIV(hz);
	dapic = startapic-endapic;

	/*
	 * there are TIMER_FREQ ticks per second.
	 * in dtick ticks, there are dapic bus clocks.
	 */
	tmp = (TIMER_FREQ * dapic) / dtick;

	lapic_per_second = tmp;

	printf("%s: apic clock running at %lldMHz\n",
	    ci->ci_dev.dv_xname, tmp / (1000 * 1000));

	if (lapic_per_second != 0) {
		/*
		 * reprogram the apic timer to run in periodic mode.
		 * XXX need to program timer on other cpu's, too.
		 */
		lapic_tval = (lapic_per_second * 2) / hz;
		lapic_tval = (lapic_tval / 2) + (lapic_tval & 0x1);

		i82489_writereg(LAPIC_LVTT, LAPIC_LVTT_TM | LAPIC_LVTT_M |
		    LAPIC_TIMER_VECTOR);
		i82489_writereg(LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
		i82489_writereg(LAPIC_ICR_TIMER, lapic_tval);

		/*
		 * Compute fixed-point ratios between cycles and
		 * microseconds to avoid having to do any division
		 * in lapic_delay.
		 */

		tmp = (1000000 * (u_int64_t)1 << 32) / lapic_per_second;
		lapic_frac_usec_per_cycle = tmp;

		tmp = (lapic_per_second * (u_int64_t)1 << 32) / 1000000;

		lapic_frac_cycle_per_usec = tmp;

		/*
		 * Compute delay in cycles for likely short delays in usec.
		 */
		for (i = 0; i < 26; i++)
			lapic_delaytab[i] = (lapic_frac_cycle_per_usec * i) >>
			    32;

		/*
		 * Now that the timer's calibrated, use the apic timer routines
		 * for all our timing needs..
		 */
		delay_func = lapic_delay;
		initclock_func = lapic_initclocks;
	}
}

/*
 * delay for N usec.
 */

void
lapic_delay(int usec)
{
	int32_t tick, otick;
	int64_t deltat;		/* XXX may want to be 64bit */

	otick = lapic_gettick();

	if (usec <= 0)
		return;
	if (usec <= 25)
		deltat = lapic_delaytab[usec];
	else
		deltat = (lapic_frac_cycle_per_usec * usec) >> 32;

	while (deltat > 0) {
		tick = lapic_gettick();
		if (tick > otick)
			deltat -= lapic_tval - (tick - otick);
		else
			deltat -= otick - tick;
		otick = tick;
	}
}

/*
 * XXX the following belong mostly or partly elsewhere..
 */

static __inline void i82489_icr_wait(void);

static __inline void
i82489_icr_wait(void)
{
#ifdef DIAGNOSTIC
	unsigned j = 100000;
#endif /* DIAGNOSTIC */

	while ((i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY) != 0) {
		__asm volatile("pause": : :"memory");
#ifdef DIAGNOSTIC
		j--;
		if (j == 0)
			panic("i82489_icr_wait: busy");
#endif /* DIAGNOSTIC */
	}
}

#ifdef MULTIPROCESSOR
void
i386_ipi_init(int target)
{
	if ((target & LAPIC_DEST_MASK) == 0)
		i82489_writereg(LAPIC_ICRHI, target << LAPIC_ID_SHIFT);

	i82489_writereg(LAPIC_ICRLO, (target & LAPIC_DEST_MASK) |
	    LAPIC_DLMODE_INIT | LAPIC_LVL_ASSERT );

	i82489_icr_wait();

	i8254_delay(10000);

	i82489_writereg(LAPIC_ICRLO, (target & LAPIC_DEST_MASK) |
	     LAPIC_DLMODE_INIT | LAPIC_LVL_TRIG | LAPIC_LVL_DEASSERT);

	i82489_icr_wait();
}

void
i386_ipi(int vec, int target, int dl)
{
	int s;

	s = splhigh();

	i82489_icr_wait();

	if ((target & LAPIC_DEST_MASK) == 0)
		i82489_writereg(LAPIC_ICRHI, target << LAPIC_ID_SHIFT);

	i82489_writereg(LAPIC_ICRLO,
	    (target & LAPIC_DEST_MASK) | vec | dl | LAPIC_LVL_ASSERT);

	i82489_icr_wait();

	splx(s);
}
#endif /* MULTIPROCESSOR */
@


1.39
log
@Make *_ipi_init return void on i386/amd64

They always returned 0

ok mlarkin@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.38 2015/04/12 18:37:53 mlarkin Exp $	*/
d462 1
a462 1
int
a479 2

	return 0;
@


1.38
log
@
Bring PAE code back to life, in a different form. This diff (via bluhm then
to deraadt, then myself) brings the PAE pmap on i386 (not touched in any
significant way for years) closer to the current non-PAE pmap and allows
us to take a big next step toward better i386 W^X in the kernel (similar to
what we did a few months ago on amd64). Unlike the original PAE pmap, this
diff will not be supporting > 4GB physical memory on i386 - this effort is
specifically geared toward providing W^X (via NX) only.

There still seems to be a bug removing certain pmap entries when PAE is
enabled, so I'm leaving PAE mode disabled for the moment until we can
figure out what is going on, but with this diff in the tree hopefully
others can help.

The pmap functions now operate through function pointers, due to the need
to support both non-PAE and PAE forms. My unscientific testing showed
less than 0.3% (a third of a percent) slowdown with this approach during
a base build.

Discussed for months with guenther, kettenis, and deraadt.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.37 2014/09/21 16:14:52 sf Exp $	*/
d443 1
a443 1
int
a445 1

a459 2

	return 0;
@


1.37
log
@Don't check LAPIC_DLSTAT_BUSY again after an IPI

Depending on DIAGNOSTICS, i82489_icr_wait() will either spin or panic in
this case. Therefore there is no need to check the flag again.

On virtualization, this saves one VMEXIT per IPI.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.36 2014/09/14 14:17:23 jsg Exp $	*/
a72 1
	pt_entry_t *pte;
d87 1
a87 2
	pte = kvtopte(va);
	*pte = lapic_base | PG_RW | PG_V | PG_N;
@


1.36
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.35 2014/03/29 18:09:29 guenther Exp $	*/
d464 1
a464 1
	return (i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY) ? EBUSY : 0;
d470 1
a470 1
	int result, s;
a483 2
	result = (i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY) ? EBUSY : 0;

d486 1
a486 1
	return result;
@


1.35
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.34 2014/01/24 21:20:23 kettenis Exp $	*/
a35 1
#include <sys/proc.h>
@


1.34
log
@Disable lapic when halting CPUs.  Allegedly this is necessary to make
suspend work on some machines.

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.33 2013/10/26 16:55:12 kettenis Exp $	*/
d436 1
a436 1
		__asm __volatile("pause": : :"memory");
@


1.33
log
@Remove unused variable.

From Sebastien Marie.
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.32 2013/06/02 18:16:42 gerhard Exp $	*/
d108 6
@


1.32
log
@Fix a bug where the calibration loop could show wrong CPU frequencies.
In case the 'starttick' had a rather large value, the code could miss
one or more cycles of the i8254 timer.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.31 2010/09/20 06:33:47 matthew Exp $	*/
a236 1
u_int64_t scaled_pentium_mhz;
a369 2

		scaled_pentium_mhz = (1ULL << 32) / cpuspeed;
@


1.31
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.30 2010/07/25 21:43:35 deraadt Exp $	*/
d275 14
d303 1
a303 2
	unsigned int starttick, tick1, tick2, endtick;
	unsigned int startapic, apic1, apic2, endapic;
d319 4
a322 1
	starttick = gettick();
d325 3
a327 12
	for (i = 0; i < hz; i++) {
		i8254_delay(2);
		do {
			tick1 = gettick();
			apic1 = lapic_gettick();
		} while (tick1 < starttick);
		i8254_delay(2);
		do {
			tick2 = gettick();
			apic2 = lapic_gettick();
		} while (tick2 > starttick);
	}
a328 1
	endtick = gettick();
d332 1
a332 1
	dtick = hz * TIMER_DIV(hz) + (starttick-endtick);
@


1.30
log
@in the clock drivers, seperate the soft-state and hard-state which was
all jumbled up in the same functions. the rtc (mc chip) and clock (i8243)
startup was also mixed up.  they the soft state and hardware state can
be started in the right order, and it is easy to restart just the
neccessary parts upon resume.  tested in numerous cases:
(apic, pic) * (GENERIC.MP, GENERIC) * (mp, non-mp) * (i386, amd64)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.29 2010/07/23 07:21:02 matthew Exp $	*/
d214 1
a214 1
	evcount_attach(&clk_count, "clock", (void *)&clk_irq, &evcount_intr);
d216 1
a216 1
	evcount_attach(&ipi_count, "ipi", (void *)&ipi_irq, &evcount_intr);
@


1.29
log
@Omit more IPI code from non-MP kernels.  Found using --gc-sections.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.28 2010/06/26 23:24:43 guenther Exp $	*/
d250 1
a250 1
lapic_initclocks(void)
d265 8
a273 1
extern void (*initclock_func)(void); /* XXX put in header file */
@


1.28
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.27 2010/04/01 19:48:50 kettenis Exp $	*/
d60 1
d62 1
d198 1
d200 1
d215 1
d217 1
d429 1
d475 1
@


1.27
log
@Don't index cpu_info by apic id, but by device unit number instead.  Recent
Intel CPUs come up with apic id's >= 32, even on systems with less than 32
logical CPUs.

ok krw@@, marco@@; tested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.26 2009/08/10 17:04:39 deraadt Exp $	*/
a36 1
#include <sys/user.h>
@


1.26
log
@use splhigh instead of splclock to block in the i386_ipi
fixes stability problems on some machines; ie. crashes in
in cpu_idle_cycle
from netbsd, via dhill
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.25 2009/06/03 00:49:12 art Exp $	*/
d93 1
a93 1
	cpu_init_first();	/* catch up to changed cpu_number() */
@


1.25
log
@Just like on amd64. Instead of keeping a bitmap of which cpus a pmap
is active on, save a curpmap pointer in cpu_info. This lets us simplify
a few things and do lazy context switching from a user process to a
kernel thread. There's a new IPI introduced for forcing a cr3 reload
when we're tearing down a dead pmap.

kettenis@@ ok (after I polished a few minor things)
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.24 2008/08/13 15:46:21 art Exp $	*/
d451 1
a451 1
	s = splclock();
@


1.24
log
@Disable the fantastics mis-feature on some newer Turion CPUs called C1E.
This "power saving" disables the apic when both cpu cores hit the hlt
instruction which kills our timer.

From FreeBSD.

(poked by kettenis)
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.23 2008/06/26 05:42:10 ray Exp $	*/
d206 1
@


1.23
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.22 2008/04/26 14:33:27 kettenis Exp $	*/
d132 25
@


1.22
log
@Remove softast; it's no longer used.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.21 2008/04/18 20:20:35 kettenis Exp $	*/
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.21
log
@Now that i386 has a per-process astpending, we can garbage collect ipi_ast
and do an ipi_nop cross-call from signotify() instead.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.20 2008/01/26 11:18:42 kettenis Exp $	*/
a121 1
	idt_vec_set(LAPIC_SOFTAST_VECTOR, Xintrsoftast);
@


1.20
log
@Unify i386 and amd64 lapic code, and calibrate lapic timer with interrupts
disabled (as suggested by mickey).

ok krw@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.19 2007/11/29 10:53:54 deraadt Exp $	*/
a185 1
	idt_vec_set(LAPIC_IPI_AST, Xintripi_ast);
@


1.19
log
@outdated comment
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.18 2007/09/07 08:37:38 art Exp $	*/
a46 1
#include <sys/timetc.h>
d71 1
a71 1
static __inline u_int32_t lapic_gettick(void);
d74 1
a74 1
void 	lapic_map(paddr_t);
d77 1
a77 2
lapic_map(lapic_base)
	paddr_t lapic_base;
d111 1
a111 1
lapic_enable()
d117 1
a117 1
lapic_set_softvectors()
d126 1
a126 1
lapic_set_lvt()
d199 1
a199 1
lapic_gettick()
d201 1
a201 1
	return (i82489_readreg(LAPIC_CCR_TIMER));
d228 1
a228 1
lapic_initclocks()
d263 1
a263 2
	int i;
	char tbuf[9];
d276 1
d280 2
a281 3
	DELAY(2);		/* using "old" delay here.. */

	for (i=0; i<hz; i++) {
d286 1
a286 1

d295 1
d308 2
a309 35
#if 0
	humanize_number(tbuf, sizeof(tbuf), tmp, "Hz", 1000);
#else /* XXX: from NetBSD sources... sigh. */
	{
		/* prefixes are: (none), Kilo, Mega, Giga, Tera, Peta, Exa */
		static const char prefixes[] = " KMGTPE";

		int             i;
		u_int64_t       max;
		size_t          suffixlen;

		if (tbuf == NULL)
			goto out;
		if (sizeof(tbuf) > 0)
			tbuf[0] = '\0';
		suffixlen = sizeof "Hz" - 1;
		/* check if enough room for `x y' + suffix + `\0' */
		if (sizeof(tbuf) < 4 + suffixlen)
			goto out;

		max = 1;
		for (i = 0; i < sizeof(tbuf) - suffixlen - 3; i++)
			max *= 10;
		for (i = 0; tmp >= max && i < sizeof(prefixes); i++)
			tmp /= 1000;

		snprintf(tbuf, sizeof(tbuf), "%qu%s%c%s",
		    (unsigned long long)tmp, i == 0 ? "" : " ", prefixes[i],
		    "Hz");
	out:
		;
	}
#endif

	printf("%s: apic clock running at %s\n", ci->ci_dev.dv_xname, tbuf);
d388 19
d408 1
a408 2
i386_ipi_init(target)
	int target;
a409 1
	unsigned j;
d417 1
a417 5
	for (j = 100000; j > 0; j--) {
		__asm __volatile("pause": : :"memory");
		if ((i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY) == 0)
			break;
	}
d419 1
a419 1
	delay(10000);
d424 1
a424 5
	for (j = 100000; j > 0; j--) {
		__asm __volatile("pause": : :"memory");
		if ((i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY) == 0)
			break;
	}
d426 1
a426 1
	return (i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY)?EBUSY:0;
d430 1
a430 2
i386_ipi(vec,target,dl)
	int vec,target,dl;
d432 5
a436 1
	unsigned j;
d444 1
a444 4
	for (j = 100000;
	     j > 0 && (i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY);
	     j--)
		SPINLOCK_SPIN_HOOK;
d446 5
a450 1
	return (i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY) ? EBUSY : 0;
@


1.18
log
@Remove some left-overs from the TSC based microtime. We don't need
to synchronize the tsc between CPUs anymore. While here, also remove
the slow TLB IPI since it's been dead for a while.

noticed by mickey
toby@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.17 2007/08/01 13:18:18 martin Exp $	*/
a71 1
void	lapic_microtime(struct timeval *);
d362 1
a362 1
		 * in lapic_delay and lapic_microtime.
@


1.17
log
@switch i386 to use the MI i8253 header file and remove the now obsolete MD
timerreg.h

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.16 2007/05/25 15:55:26 art Exp $	*/
d221 1
a221 2
lapic_clockintr(arg)
	void *arg;
a222 1
	struct cpu_info *ci = curcpu();
a224 4
	if (CPU_IS_PRIMARY(ci)) {
		ci->ci_tscbase = rdtsc();
		i386_broadcast_ipi(I386_IPI_MICROSET);
	}
a418 39

#define LAPIC_TICK_THRESH 200

/*
 * An IPI handler to record current timer value
 */
void
i386_ipi_microset(struct cpu_info *ci)
{
	ci->ci_tscbase = rdtsc();
}

#if 0
/*
 * XXX need to make work correctly on other than cpu 0.
 */
void
lapic_microtime(tv)
	struct timeval *tv;
{
	struct cpu_info *ci = curcpu();
	struct timeval now;
	u_int64_t tmp;

	disable_intr();
	now = time;
	tmp = rdtsc() - ci->ci_tscbase;
	enable_intr();

	now.tv_usec += (tmp * scaled_pentium_mhz) >> 32;

	while (now.tv_usec >= 1000000) {
		now.tv_sec += 1;
		now.tv_usec -= 1000000;
	}

	*tv = now;
}
#endif
@


1.16
log
@Replace the overdesigned and overcomplicated tlb shootdown code with
very simple and dumb fast tlb IPI handlers that have in the order of
the same amount of instructions as the old code had function calls.

All TLB shootdowns are reorganized so that we always shoot the,
without looking at PG_U and when we're shooting a range (primarily in
pmap_remove), we shoot the range when there are 32 or less pages in
it, otherwise we just nuke the whole TLB (this might need tweaking if
someone is interested in micro-optimization). The IPIs are not handled
through the normal interrupt vectoring code, they are not blockable
and they only shoot one page or a range of pages or the whole tlb.

This gives a 15% reduction in system time on my dual-core laptop
during a kernel compile and an 18% reduction in real time on a quad
machine doing bulk ports build.

Tested by many, in snaps for a week, no slowdowns reported (although not
everyone is seeing such huge wins).
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.15 2007/04/12 20:22:58 art Exp $	*/
d66 1
a66 1
#include <i386/isa/timerreg.h>	/* XXX for TIMER_FREQ */
@


1.15
log
@Faster signal delivery on i386/MP.

We need to poke the other CPU so that it processes the AST immediately
and doesn't wait for the next interrupt or syscall.

Since IPIs really shouldn't process ASTs, we need to trigger a soft
interrupt on the destination CPU to process the AST. But since we can't
send soft interrupts to other CPUs, we send an IPI, that triggers a soft
interrupt that in turn processes the AST.

Also, this marks the beginning of moving to slightly better IPI mechanism
of short and optimized IPIs instead of the large and complicated IPI
infrastructure we're using now.

tested by many, ok tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.14 2007/03/19 09:29:33 art Exp $	*/
a181 1
	extern void Xintripi_ast(void);
d190 3
@


1.14
log
@Move i386 to timecounters. This is more or less the same code as amd64.

The "lapic" timer is ripped out since it wasn't actually a lapic timer,
but a hacked up tsc timer with some synchronization for MP. There is no
tsc timer right now since they are very unreliable on MP systems, systems
with apm, and systems that change the cpu clock. Which basically means
every modern machine out there. We're running with the i8259 timer now.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.13 2007/02/20 21:15:01 tom Exp $	*/
d125 1
d180 1
a180 2
lapic_boot_init(lapic_base)
	paddr_t lapic_base;
d182 1
d190 1
@


1.13
log
@Revert PAE pmap for now, until the strange bug is found.  This stops
the freezes many of us are seeing (especially on amd64 machines running
OpenBSD/i386).

Much testing by nick@@ (as always - thanks!), hugh@@, ian@@, kettenis@@
and Sam Smith (s (at) msmith (dot) net).

Requested by, input from, and ok deraadt@@  ok art@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.12 2007/02/19 11:59:00 tom Exp $	*/
d47 1
d263 1
a263 2
lapic_calibrate_timer(ci)
	struct cpu_info *ci;
a388 1
		microtime_func = lapic_microtime;
d398 1
a398 2
lapic_delay(usec)
	int usec;
d433 1
d459 1
@


1.12
log
@Remove unused variable lapic_timer

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.11 2007/01/23 21:17:18 kettenis Exp $	*/
d81 2
a83 1
	int s;
d97 2
a98 1
	pmap_pte_set(va, lapic_base, PG_RW | PG_V | PG_N);
@


1.11
log
@Handle not-all-lapics intterupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.10 2006/12/20 17:50:40 gwk Exp $	*/
a201 1
int lapic_timer = 0;
@


1.10
log
@"#ifdef is a tool of the weak!"
Rename pentium_mhz to cpuspeed which is consistant with amd64 making
shared ACPI code less nasty.
ok marco, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.9 2006/05/29 09:54:16 mickey Exp $	*/
a115 2
extern struct mp_intr_map *lapic_ints[]; /* XXX header file? */

a126 1
#ifdef MULTIPROCESSOR
d128 2
d131 2
a132 1
	if (0) {
d139 16
a154 4
	if (lapic_ints[0])
		i82489_writereg(LAPIC_LVINT0, lapic_ints[0]->redir);
	if (lapic_ints[1])
		i82489_writereg(LAPIC_LVINT1, lapic_ints[1]->redir);
d157 1
a157 1
	if (0) {
@


1.9
log
@implement reliable microtime on smp (joint work w/ otto):
send a bcast ipi from the cpu0 to all others to timestamp tsc
on every clock intr. this way using local tsc provides accurate
microtime() measurements. thus gettimeofday test passes now.
otto@@ deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.8 2006/04/27 15:37:51 mickey Exp $	*/
d362 1
a362 1
		scaled_pentium_mhz = (1ULL << 32) / pentium_mhz;
@


1.8
log
@implement separate PAE pmap that allows access to 64g of physmem
if supported by the cpu(s). currently not enabled by default and
not compiled into ramdisks. this grows paddr_t to 64bit but yet
leaves bus_addr_t at 32bits. measures are taken to favour dmaable
memory allocation from below 4g line such that buffer cache is
already allocated form below, pool backend allocator prefers lower
memory and then finally bounce buffers are used as last resort.
PAE is engaged only if global variable cpu_pae is manually set
to non-zero and there is physical memory present above 4g.
simplify pcibios address math to use u_long as we always will
be in the 32bit space.
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.7 2006/03/13 18:42:16 mickey Exp $	*/
d63 1
d200 1
d206 1
d209 4
d362 2
d385 2
a386 1
void lapic_delay(usec)
d414 9
d425 2
a426 2

void lapic_microtime(tv)
d429 1
d431 1
a431 3
	u_int32_t tick;
	u_int32_t usec;
	u_int32_t tmp;
a433 1
	tick = lapic_gettick();
d435 1
d438 1
a438 2
	tmp = lapic_tval - tick;
	usec = ((u_int64_t)tmp * lapic_frac_usec_per_cycle) >> 32;
a439 1
	now.tv_usec += usec;
@


1.7
log
@time-bind and lower power in lock spinning and a couple of other ipi loops by using pause insn; brad@@ ok tedu@@ ok and feedback krw@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.6 2006/03/10 21:09:22 mickey Exp $	*/
d80 1
a81 2
	pt_entry_t *pte;
	vaddr_t va = (vaddr_t)&local_apic;
d95 1
a95 2
	pte = kvtopte(va);
	*pte = lapic_base | PG_RW | PG_V | PG_N;
@


1.6
log
@provide a counter for ipis
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.5 2004/06/28 02:00:20 deraadt Exp $	*/
d444 1
a444 1
	if ((target & LAPIC_DEST_MASK) == 0) {
a445 1
	}
d450 2
a451 1
	for (j = 100000; j > 0; j--)
d454 1
d461 2
a462 1
	for (j = 100000; j > 0; j--)
d465 1
d485 1
a485 1
		;
@


1.5
log
@move from unsafe ev_count32 to safe ev_count; aaron ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.4 2004/06/28 01:41:53 aaron Exp $	*/
d67 1
d169 1
d180 1
@


1.4
log
@Use new event counter API for interrupt counting on i386.  deraadt@@ tholo@@
drahn@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.3 2004/06/14 00:06:32 deraadt Exp $	*/
d207 1
a207 1
	clk_count.ec_count32++;
@


1.3
log
@knock out some useless crud
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.2 2004/06/13 21:49:15 niklas Exp $	*/
d66 2
d167 2
d176 2
d206 2
@


1.2
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d130 1
a130 1
	if (mp_verbose) {
d143 1
a143 1
	if (mp_verbose) {
@


1.1
log
@file lapic.c was initially added on branch SMP.
@
text
@d1 474
@


1.1.2.1
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@a0 471
/* $NetBSD: lapic.c,v 1.1.2.8 2000/02/23 06:10:50 sommerfeld Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by RedBack Networks Inc.
 *
 * Author: Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <vm/vm.h>
#include <vm/vm_kern.h>
#include <vm/vm_page.h>
 
#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/cpuvar.h>
#include <machine/pmap.h>
#include <machine/vmparam.h>
#include <machine/mpbiosvar.h>
#include <machine/pcb.h>
#include <machine/specialreg.h>
#include <machine/segments.h>

#include <machine/apicvar.h>
#include <machine/i82489reg.h>
#include <machine/i82489var.h>

#include <i386/isa/timerreg.h>	/* XXX for TIMER_FREQ */

void		lapic_delay __P((int));
void		lapic_microtime __P((struct timeval *));
static u_int32_t lapic_gettick __P((void));
void		lapic_clockintr __P((void *));
void		lapic_initclocks __P((void));
static void 	lapic_map __P((paddr_t));

static void
lapic_map(lapic_base)
	paddr_t lapic_base;
{
	int s;
	pt_entry_t *pte;
	vaddr_t va = (vaddr_t)&local_apic;

	disable_intr();
	s = lapic_tpr;

	/*
	 * Map local apic.  If we have a local apic, it's safe to assume
	 * we're on a 486 or better and can use invlpg and non-cacheable PTE's
	 *
	 * Whap the PTE "by hand" rather than calling pmap_kenter_pa because
	 * the latter will attempt to invoke TLB shootdown code just as we
	 * might have changed the value of cpu_number()..
	 */

	pte = kvtopte(va);
	*pte = lapic_base | PG_RW | PG_V | PG_N;
	invlpg(va);

#ifdef MULTIPROCESSOR
	cpu_init_first();	/* catch up to changed cpu_number() */
#endif

	lapic_tpr = s;
	enable_intr();
}

/*
 * enable local apic
 */
void
lapic_enable()
{
	i82489_writereg(LAPIC_SVR, LAPIC_SVR_ENABLE | LAPIC_SPURIOUS_VECTOR);
}

extern struct mp_intr_map *lapic_ints[]; /* XXX header file? */

void
lapic_set_lvt ()
{
#ifdef MULTIPROCESSOR
	struct cpu_info *ci = curcpu();
	
	if (mp_verbose) {
		apic_format_redir (ci->ci_dev.dv_xname, "prelint", 0, 0,
		    i82489_readreg(LAPIC_LVINT0));
		apic_format_redir (ci->ci_dev.dv_xname, "prelint", 1, 0,
		    i82489_readreg(LAPIC_LVINT1));
	}
#endif
	if (lapic_ints[0])
		i82489_writereg(LAPIC_LVINT0, lapic_ints[0]->redir);
	if (lapic_ints[1])	
		i82489_writereg(LAPIC_LVINT1, lapic_ints[1]->redir);

#ifdef MULTIPROCESSOR
	if (mp_verbose) {
		apic_format_redir (ci->ci_dev.dv_xname, "timer", 0, 0,
		    i82489_readreg(LAPIC_LVTT));
		apic_format_redir (ci->ci_dev.dv_xname, "pcint", 0, 0,
		    i82489_readreg(LAPIC_PCINT));
		apic_format_redir (ci->ci_dev.dv_xname, "lint", 0, 0,
		    i82489_readreg(LAPIC_LVINT0));
		apic_format_redir (ci->ci_dev.dv_xname, "lint", 1, 0,
		    i82489_readreg(LAPIC_LVINT1));
		apic_format_redir (ci->ci_dev.dv_xname, "err", 0, 0,
		    i82489_readreg(LAPIC_LVERR));
	}
#endif
}

/*
 * Initialize fixed idt vectors for use by local apic.
 */
void
lapic_boot_init(lapic_base)
	paddr_t lapic_base;
{
	lapic_map(lapic_base);

#ifdef MULTIPROCESSOR
	idt_vec_set(LAPIC_IPI_VECTOR, Xintripi);
#endif
	/* idt_vec_set(LAPIC_SPURIOUS_VECTOR, Xintrspurious); */
	idt_vec_set(LAPIC_TIMER_VECTOR, Xintrltimer);

	idt_vec_set(LAPIC_SOFTCLOCK_VECTOR, Xintrsoftclock);
	idt_vec_set(LAPIC_SOFTNET_VECTOR, Xintrsoftnet);
	idt_vec_set(LAPIC_SOFTTTY_VECTOR, Xintrsofttty);

}

static inline u_int32_t lapic_gettick()
{
	return i82489_readreg(LAPIC_CCR_TIMER);
}

#include <sys/kernel.h>		/* for hz */

int lapic_timer = 0;
u_int32_t lapic_tval;

/*
 * this gets us up to a 4GHz busclock....
 */
u_int32_t lapic_per_second;
u_int32_t lapic_frac_usec_per_cycle;
u_int64_t lapic_frac_cycle_per_usec;
u_int32_t lapic_delaytab[26];

void
lapic_clockintr (arg)
	void *arg;
{
	struct clockframe *frame = arg;
	
	hardclock(frame);
}

void
lapic_initclocks ()
{
	/*
	 * Start local apic countdown timer running, in repeated mode.
	 *
	 * Mask the clock interrupt and set mode,
	 * then set divisor,
	 * then unmask and set the vector.
	 */
	i82489_writereg (LAPIC_LVTT, LAPIC_LVTT_TM|LAPIC_LVTT_M);
	i82489_writereg (LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
	i82489_writereg (LAPIC_ICR_TIMER, lapic_tval);
	i82489_writereg (LAPIC_LVTT, LAPIC_LVTT_TM|LAPIC_TIMER_VECTOR);
}

extern int gettick __P((void));	/* XXX put in header file */
extern void (*initclock_func) __P((void)); /* XXX put in header file */

/*
 * Calibrate the local apic count-down timer (which is running at
 * bus-clock speed) vs. the i8254 counter/timer (which is running at
 * a fixed rate).
 *
 * The Intel MP spec says: "An MP operating system may use the IRQ8
 * real-time clock as a reference to determine the actual APIC timer clock
 * speed."
 *
 * We're actually using the IRQ0 timer.  Hmm.
 */
void
lapic_calibrate_timer(ci)
	struct cpu_info *ci;
{
	unsigned int starttick, tick1, tick2, endtick;
	unsigned int startapic, apic1, apic2, endapic;
	u_int64_t dtick, dapic, tmp;
	int i;
	char tbuf[9];
	
	printf("%s: calibrating local timer\n", ci->ci_dev.dv_xname);
	
	/*
	 * Configure timer to one-shot, interrupt masked,
	 * large positive number.
	 */
	i82489_writereg (LAPIC_LVTT, LAPIC_LVTT_M);
	i82489_writereg (LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
	i82489_writereg (LAPIC_ICR_TIMER, 0x80000000);
	
	starttick = gettick();
	startapic = lapic_gettick();

	DELAY(2);		/* using "old" delay here.. */
	
	for (i=0; i<hz; i++) {
		do {
			tick1 = gettick();
			apic1 = lapic_gettick();
		} while (tick1 < starttick);

		do {
			tick2 = gettick();
			apic2 = lapic_gettick();
		} while (tick2 > starttick);
	}
	
	endtick = gettick();
	endapic = lapic_gettick();

	dtick = hz * TIMER_DIV(hz) + (starttick-endtick);
	dapic = startapic-endapic;

	/*
	 * there are TIMER_FREQ ticks per second.
	 * in dtick ticks, there are dapic bus clocks.
	 */
	tmp = (TIMER_FREQ * dapic) / dtick;

	lapic_per_second = tmp;

#if 0
	humanize_number(tbuf, sizeof(tbuf), tmp, "Hz", 1000);
#else /* XXX: from NetBSD sources... sigh. */
	{
	  /* prefixes are: (none), Kilo, Mega, Giga, Tera, Peta, Exa */
	  static const char prefixes[] = " KMGTPE";
	  
	  int             i;
	  u_int64_t       max;
	  size_t          suffixlen;
	  
	  if (tbuf == NULL)
	    goto out;
	  if (sizeof(tbuf) > 0)
	    tbuf[0] = '\0';
	  suffixlen = strlen("Hz");
	  /* check if enough room for `x y' + suffix + `\0' */
	  if (sizeof(tbuf) < 4 + suffixlen)
	    goto out;
	  
	  max = 1;
	  for (i = 0; i < sizeof(tbuf) - suffixlen - 3; i++)
	    max *= 10;
	  for (i = 0; tmp >= max && i < sizeof(prefixes); i++)
	    tmp /= 1000;
	  
	  snprintf(tbuf, sizeof(tbuf), "%qu%s%c%s", (unsigned long long)tmp,
		   i == 0 ? "" : " ", prefixes[i], "Hz");
	out:
	}
#endif
	   
	printf("%s: apic clock running at %s\n", ci->ci_dev.dv_xname, tbuf);

	if (lapic_per_second != 0) {
		/*
		 * reprogram the apic timer to run in periodic mode.
		 * XXX need to program timer on other cpu's, too.
		 */
		lapic_tval = (lapic_per_second * 2) / hz;
		lapic_tval = (lapic_tval / 2) + (lapic_tval & 0x1);
	
		i82489_writereg (LAPIC_LVTT, LAPIC_LVTT_TM|LAPIC_LVTT_M
		    |LAPIC_TIMER_VECTOR);
		i82489_writereg (LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
		i82489_writereg (LAPIC_ICR_TIMER, lapic_tval);

		/*
		 * Compute fixed-point ratios between cycles and
		 * microseconds to avoid having to do any division
		 * in lapic_delay and lapic_microtime.
		 */

		tmp = (1000000 * (u_int64_t)1<<32) / lapic_per_second;
		lapic_frac_usec_per_cycle = tmp;
		
		tmp = (lapic_per_second * (u_int64_t)1<<32) / 1000000;
		
		lapic_frac_cycle_per_usec = tmp;
	
		/*
		 * Compute delay in cycles for likely short delays in usec.
		 */
		for (i=0; i<26; i++)
			lapic_delaytab[i] = (lapic_frac_cycle_per_usec * i) >>
			    32;

		/*
		 * Now that the timer's calibrated, use the apic timer routines
		 * for all our timing needs..
		 */
		delay_func = lapic_delay;
		microtime_func = lapic_microtime;
		initclock_func = lapic_initclocks;
	}
}

/*
 * delay for N usec.
 */

void lapic_delay(usec)
	int usec;
{
	int32_t tick, otick;
	int64_t deltat;		/* XXX may want to be 64bit */
	
	otick = lapic_gettick();

	if (usec <= 0)
		return;
	if (usec <= 25)
		deltat = lapic_delaytab[usec];
	else
		deltat = (lapic_frac_cycle_per_usec * usec) >> 32;

	while (deltat > 0) {
		tick = lapic_gettick();
		if (tick > otick)
			deltat -= lapic_tval - (tick - otick);
		else
			deltat -= otick - tick;
		otick = tick;
	}
}

#define LAPIC_TICK_THRESH 200

/*
 * XXX need to make work correctly on other than cpu 0.
 */

void lapic_microtime (tv)
	struct timeval *tv;
{
	struct timeval now;
	u_int32_t tick;
	u_int32_t usec;
	u_int32_t tmp;
	
	disable_intr();
	tick = lapic_gettick();
	now = time;
	enable_intr();

	tmp = lapic_tval - tick;
	usec = ((u_int64_t)tmp * lapic_frac_usec_per_cycle) >> 32;
	
	now.tv_usec += usec;
	while (now.tv_usec >= 1000000) {
		now.tv_sec += 1;
		now.tv_usec -= 1000000;
	}
	
	*tv = now;
}

/*
 * XXX the following belong mostly or partly elsewhere..
 */

int
i386_ipi_init(target)
	int target;
{
	unsigned j;

	if ((target&LAPIC_DEST_MASK)==0) {
		i82489_writereg(LAPIC_ICRHI, target<<LAPIC_ID_SHIFT);
	}

	i82489_writereg(LAPIC_ICRLO, (target & LAPIC_DEST_MASK) |
	    LAPIC_DLMODE_INIT | LAPIC_LVL_ASSERT );

	for (j=100000; j > 0; j--)
		if ((i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY) == 0)
			break;
    
	delay(10000);
	
	i82489_writereg(LAPIC_ICRLO, (target & LAPIC_DEST_MASK) |
	     LAPIC_DLMODE_INIT | LAPIC_LVL_TRIG | LAPIC_LVL_DEASSERT);
    
	for (j=100000; j > 0; j--)
		if ((i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY) == 0)
			break;

	return (i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY)?EBUSY:0;
}

int
i386_ipi(vec,target,dl)
	int vec,target,dl;
{
	unsigned j;

	if ((target & LAPIC_DEST_MASK) == 0)
		i82489_writereg(LAPIC_ICRHI, target << LAPIC_ID_SHIFT);

	i82489_writereg(LAPIC_ICRLO,
	    (target & LAPIC_DEST_MASK) | vec | dl | LAPIC_LVL_ASSERT);

	for (j=100000;
	     j > 0 && (i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY);
	     j--)
		;

	return (i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY)?EBUSY:0;
}

@


1.1.2.2
log
@Add $OpenBSD$.
@
text
@a0 1
/*	$OpenBSD$	*/
@


1.1.2.3
log
@KNF
remove statics
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.1.2.2 2001/07/15 15:10:55 ho Exp $	*/
d70 6
a75 6
void	lapic_delay __P((int));
void	lapic_microtime __P((struct timeval *));
static __inline u_int32_t lapic_gettick __P((void));
void	lapic_clockintr __P((void *));
void	lapic_initclocks __P((void));
void 	lapic_map __P((paddr_t));
d77 1
a77 1
void
d121 1
a121 1
lapic_set_lvt()
d127 1
a127 1
		apic_format_redir(ci->ci_dev.dv_xname, "prelint", 0, 0,
d129 1
a129 1
		apic_format_redir(ci->ci_dev.dv_xname, "prelint", 1, 0,
d140 1
a140 1
		apic_format_redir(ci->ci_dev.dv_xname, "timer", 0, 0,
d142 1
a142 1
		apic_format_redir(ci->ci_dev.dv_xname, "pcint", 0, 0,
d144 1
a144 1
		apic_format_redir(ci->ci_dev.dv_xname, "lint", 0, 0,
d146 1
a146 1
		apic_format_redir(ci->ci_dev.dv_xname, "lint", 1, 0,
d148 1
a148 1
		apic_format_redir(ci->ci_dev.dv_xname, "err", 0, 0,
d175 1
a175 2
static __inline u_int32_t
lapic_gettick()
d177 1
a177 1
	return (i82489_readreg(LAPIC_CCR_TIMER));
d336 1
a336 1
		tmp = (1000000 * (u_int64_t)1 << 32) / lapic_per_second;
d339 1
a339 1
		tmp = (lapic_per_second * (u_int64_t)1 << 32) / 1000000;
d346 1
a346 1
		for (i = 0; i < 26; i++)
@


1.1.2.4
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.1.2.3 2001/07/16 21:39:43 niklas Exp $	*/
d51 1
a51 1

d125 1
a125 1

d135 1
a135 1
	if (lapic_ints[1])
d199 1
a199 1

d242 1
a242 1

d244 1
a244 1

d252 1
a252 1

d257 1
a257 1

d269 1
a269 1

d288 24
a311 25
		/* prefixes are: (none), Kilo, Mega, Giga, Tera, Peta, Exa */
		static const char prefixes[] = " KMGTPE";

		int             i;
		u_int64_t       max;
		size_t          suffixlen;

		if (tbuf == NULL)
			goto out;
		if (sizeof(tbuf) > 0)
			tbuf[0] = '\0';
		suffixlen = sizeof "Hz" - 1;
		/* check if enough room for `x y' + suffix + `\0' */
		if (sizeof(tbuf) < 4 + suffixlen)
			goto out;

		max = 1;
		for (i = 0; i < sizeof(tbuf) - suffixlen - 3; i++)
			max *= 10;
		for (i = 0; tmp >= max && i < sizeof(prefixes); i++)
			tmp /= 1000;

		snprintf(tbuf, sizeof(tbuf), "%qu%s%c%s",
		    (unsigned long long)tmp, i == 0 ? "" : " ", prefixes[i],
		    "Hz");
d315 1
a315 1

d325 1
a325 1

d339 1
a339 1

d341 1
a341 1

d343 1
a343 1

d370 1
a370 1

d403 1
a403 1

d411 1
a411 1

d417 1
a417 1

d431 2
a432 2
	if ((target & LAPIC_DEST_MASK) == 0) {
		i82489_writereg(LAPIC_ICRHI, target << LAPIC_ID_SHIFT);
d438 1
a438 1
	for (j = 100000; j > 0; j--)
d441 1
a441 1

d443 1
a443 1

d446 2
a447 2

	for (j = 100000; j > 0; j--)
d466 1
a466 1
	for (j = 100000;
d473 1
@


1.1.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
@


1.1.2.6
log
@Re-enable code that was disabled during merge/import. Handle spurious interrupts on some lapics (again).
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.1.2.5 2001/10/31 03:01:12 nate Exp $	*/
d165 1
a165 1
	idt_vec_set(LAPIC_SPURIOUS_VECTOR, Xintrspurious);
@


1.1.2.7
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 3
a119 8
lapic_set_softvectors()
{
	idt_vec_set(LAPIC_SOFTCLOCK_VECTOR, Xintrsoftclock);
	idt_vec_set(LAPIC_SOFTNET_VECTOR, Xintrsoftnet);
	idt_vec_set(LAPIC_SOFTTTY_VECTOR, Xintrsofttty);
}

void
d167 5
@


1.1.2.8
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.1.2.7 2001/11/13 21:00:51 niklas Exp $	*/
d194 1
a194 1
lapic_clockintr(arg)
d203 1
a203 1
lapic_initclocks()
d212 4
a215 4
	i82489_writereg(LAPIC_LVTT, LAPIC_LVTT_TM|LAPIC_LVTT_M);
	i82489_writereg(LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
	i82489_writereg(LAPIC_ICR_TIMER, lapic_tval);
	i82489_writereg(LAPIC_LVTT, LAPIC_LVTT_TM|LAPIC_TIMER_VECTOR);
d248 3
a250 3
	i82489_writereg(LAPIC_LVTT, LAPIC_LVTT_M);
	i82489_writereg(LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
	i82489_writereg(LAPIC_ICR_TIMER, 0x80000000);
d326 4
a329 4
		i82489_writereg(LAPIC_LVTT, LAPIC_LVTT_TM | LAPIC_LVTT_M |
		    LAPIC_TIMER_VECTOR);
		i82489_writereg(LAPIC_DCR_TIMER, LAPIC_DCRT_DIV1);
		i82489_writereg(LAPIC_ICR_TIMER, lapic_tval);
d396 1
a396 1
void lapic_microtime(tv)
d471 1
a471 1
	return (i82489_readreg(LAPIC_ICRLO) & LAPIC_DLSTAT_BUSY) ? EBUSY : 0;
@


1.1.2.9
log
@Statement after label.
niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.1.2.8 2003/05/15 04:08:02 niklas Exp $	*/
a312 1
		;
@


1.1.2.10
log
@pretty print in dmesg -- when it is easier on the eyes glaring problems
jump out; art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.1.2.9 2004/06/07 19:35:42 art Exp $	*/
d242 1
a242 2
	if (mp_verbose)
		printf("%s: calibrating local timer\n", ci->ci_dev.dv_xname);
@


1.1.2.11
log
@un__Pee
@
text
@d1 1
a1 1
/*	$OpenBSD: lapic.c,v 1.1.2.10 2004/06/13 07:31:56 deraadt Exp $	*/
d66 6
a71 6
void	lapic_delay(int);
void	lapic_microtime(struct timeval *);
static __inline u_int32_t lapic_gettick(void);
void	lapic_clockintr(void *);
void	lapic_initclocks(void);
void 	lapic_map(paddr_t);
d218 2
a219 2
extern int gettick(void);	/* XXX put in header file */
extern void (*initclock_func)(void); /* XXX put in header file */
@


