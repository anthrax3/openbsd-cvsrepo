head	1.71;
access;
symbols
	OPENBSD_5_5:1.70.0.4
	OPENBSD_5_5_BASE:1.70
	OPENBSD_5_4:1.69.0.2
	OPENBSD_5_4_BASE:1.69
	OPENBSD_5_3:1.68.0.2
	OPENBSD_5_3_BASE:1.68
	OPENBSD_5_2:1.67.0.4
	OPENBSD_5_2_BASE:1.67
	OPENBSD_5_1_BASE:1.67
	OPENBSD_5_1:1.67.0.2
	OPENBSD_5_0:1.66.0.2
	OPENBSD_5_0_BASE:1.66
	OPENBSD_4_9:1.56.0.2
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.55.0.6
	OPENBSD_4_8_BASE:1.55
	OPENBSD_4_7:1.55.0.2
	OPENBSD_4_7_BASE:1.55
	OPENBSD_4_6:1.55.0.4
	OPENBSD_4_6_BASE:1.55
	OPENBSD_4_5:1.53.0.4
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.53.0.2
	OPENBSD_4_4_BASE:1.53
	OPENBSD_4_3:1.51.0.2
	OPENBSD_4_3_BASE:1.51
	OPENBSD_4_2:1.49.0.8
	OPENBSD_4_2_BASE:1.49
	OPENBSD_4_1:1.49.0.6
	OPENBSD_4_1_BASE:1.49
	OPENBSD_4_0:1.49.0.4
	OPENBSD_4_0_BASE:1.49
	OPENBSD_3_9:1.49.0.2
	OPENBSD_3_9_BASE:1.49
	OPENBSD_3_8:1.47.0.6
	OPENBSD_3_8_BASE:1.47
	OPENBSD_3_7:1.47.0.4
	OPENBSD_3_7_BASE:1.47
	OPENBSD_3_6:1.47.0.2
	OPENBSD_3_6_BASE:1.47
	SMP_SYNC_A:1.46
	SMP_SYNC_B:1.46
	OPENBSD_3_5:1.45.0.2
	OPENBSD_3_5_BASE:1.45
	OPENBSD_3_4:1.41.0.2
	OPENBSD_3_4_BASE:1.41
	UBC_SYNC_A:1.38
	OPENBSD_3_3:1.37.0.4
	OPENBSD_3_3_BASE:1.37
	OPENBSD_3_2:1.37.0.2
	OPENBSD_3_2_BASE:1.37
	OPENBSD_3_1:1.36.0.2
	OPENBSD_3_1_BASE:1.36
	UBC_SYNC_B:1.37
	UBC:1.35.0.2
	UBC_BASE:1.35
	OPENBSD_3_0:1.34.0.12
	OPENBSD_3_0_BASE:1.34
	OPENBSD_2_9:1.34.0.10
	OPENBSD_2_9_BASE:1.34
	OPENBSD_2_8:1.34.0.8
	OPENBSD_2_8_BASE:1.34
	OPENBSD_2_7:1.34.0.6
	OPENBSD_2_7_BASE:1.34
	SMP:1.34.0.4
	SMP_BASE:1.34
	kame_19991208:1.34
	OPENBSD_2_6:1.34.0.2
	OPENBSD_2_6_BASE:1.34
	OPENBSD_2_5:1.33.0.2
	OPENBSD_2_5_BASE:1.33
	OPENBSD_2_4:1.32.0.2
	OPENBSD_2_4_BASE:1.32
	OPENBSD_2_3:1.30.0.2
	OPENBSD_2_3_BASE:1.30
	OPENBSD_2_2:1.26.0.2
	OPENBSD_2_2_BASE:1.26
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.71
date	2014.06.09.15.51.40;	author jsing;	state dead;
branches;
next	1.70;
commitid	PoCfQX0AWtUJ5qUn;

1.70
date	2013.11.13.04.11.34;	author krw;	state Exp;
branches;
next	1.69;

1.69
date	2013.06.11.16.42.08;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2013.01.16.15.35.33;	author naddy;	state Exp;
branches;
next	1.67;

1.67
date	2011.11.13.14.52.30;	author jsing;	state Exp;
branches;
next	1.66;

1.66
date	2011.07.19.01.08.35;	author krw;	state Exp;
branches;
next	1.65;

1.65
date	2011.07.05.18.34.10;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2011.07.05.17.38.54;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2011.07.03.19.21.48;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2011.04.24.22.44.22;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2011.03.19.11.55.58;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2011.03.17.12.53.44;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2011.03.14.22.14.40;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2011.03.13.00.13.52;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2011.03.08.17.24.31;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2011.01.23.14.57.08;	author jsing;	state Exp;
branches;
next	1.55;

1.55
date	2009.05.30.23.13.18;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2009.04.23.16.39.18;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2008.08.04.15.58.13;	author reyk;	state Exp;
branches;
next	1.52;

1.52
date	2008.06.25.15.26.44;	author reyk;	state Exp;
branches;
next	1.51;

1.51
date	2008.01.24.12.09.54;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2008.01.05.19.50.48;	author otto;	state Exp;
branches;
next	1.49;

1.49
date	2006.02.14.17.16.19;	author aaron;	state Exp;
branches;
next	1.48;

1.48
date	2006.01.13.17.53.09;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2004.07.15.21.44.16;	author tom;	state Exp;
branches;
next	1.46;

1.46
date	2004.05.05.04.33.56;	author mickey;	state Exp;
branches;
next	1.45;

1.45
date	2004.02.22.09.03.05;	author tom;	state Exp;
branches;
next	1.44;

1.44
date	2004.02.21.00.29.57;	author tom;	state Exp;
branches;
next	1.43;

1.43
date	2004.01.26.23.21.49;	author tom;	state Exp;
branches;
next	1.42;

1.42
date	2004.01.20.23.02.26;	author tom;	state Exp;
branches;
next	1.41;

1.41
date	2003.08.25.23.27.43;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2003.08.15.21.17.27;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2003.08.08.07.37.28;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.17.03.43.18;	author drahn;	state Exp;
branches;
next	1.37;

1.37
date	2002.05.03.13.59.08;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2002.03.14.01.26.34;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	99.05.23.17.19.22;	author aaron;	state Exp;
branches
	1.34.4.1;
next	1.33;

1.33
date	98.12.16.03.04.09;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	98.04.25.18.32.35;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	98.04.20.07.25.15;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	98.04.18.07.39.38;	author deraadt;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	98.04.02.10.50.31;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	98.03.11.15.36.44;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	98.03.01.21.58.12;	author weingart;	state Exp;
branches;
next	1.26;

1.26
date	97.10.28.10.06.34;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	97.10.26.02.41.19;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	97.10.25.23.42.37;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	97.10.25.23.04.05;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	97.10.24.00.53.30;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	97.10.22.23.34.41;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	97.10.15.15.54.52;	author weingart;	state Exp;
branches;
next	1.19;

1.19
date	97.10.12.19.39.48;	author weingart;	state Exp;
branches;
next	1.18;

1.18
date	97.10.07.08.56.18;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	97.10.03.21.36.07;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.10.03.20.58.06;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.09.30.22.10.50;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.09.30.21.59.43;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.09.24.23.10.03;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.09.21.23.15.59;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.09.14.01.15.23;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.09.04.22.36.23;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.09.02.19.13.18;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.08.30.02.13.48;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.08.29.20.08.36;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.08.23.14.31.49;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.08.22.20.03.17;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.07.17.22.47.01;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.03.31.23.06.24;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	97.03.31.03.12.07;	author weingart;	state Exp;
branches;
next	1.1;

1.1
date	96.12.03.13.17.08;	author mickey;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	96.12.03.13.17.09;	author mickey;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	96.12.15.15.49.37;	author mickey;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	96.12.16.15.21.15;	author mickey;	state Exp;
branches;
next	;

1.30.2.1
date	98.04.20.07.26.32;	author deraadt;	state Exp;
branches;
next	;

1.34.4.1
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.34.4.2;

1.34.4.2
date	2002.03.28.10.31.05;	author niklas;	state Exp;
branches;
next	1.34.4.3;

1.34.4.3
date	2003.03.27.23.26.56;	author niklas;	state Exp;
branches;
next	1.34.4.4;

1.34.4.4
date	2003.05.13.19.42.09;	author ho;	state Exp;
branches;
next	1.34.4.5;

1.34.4.5
date	2004.02.19.10.48.43;	author niklas;	state Exp;
branches;
next	1.34.4.6;

1.34.4.6
date	2004.06.05.23.09.00;	author niklas;	state Exp;
branches;
next	;

1.35.2.1
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2003.05.19.21.45.12;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.71
log
@Remove {amd64,i386}/stand/installboot - we now use usr.sbin/installboot
and these have been unhooked from the build for a while now.
@
text
@/*	$OpenBSD: installboot.c,v 1.70 2013/11/13 04:11:34 krw Exp $	*/
/*	$NetBSD: installboot.c,v 1.5 1995/11/17 23:23:50 gwr Exp $ */

/*
 * Copyright (c) 2011 Joel Sing <jsing@@openbsd.org>
 * Copyright (c) 2010 Otto Moerbeek <otto@@openbsd.org>
 * Copyright (c) 2003 Tom Cosgrove <tom.cosgrove@@arches-consulting.com>
 * Copyright (c) 1997 Michael Shalayeff
 * Copyright (c) 1994 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Paul Kranenburg.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/mount.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/disklabel.h>
#include <sys/dkio.h>
#include <sys/ioctl.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>
#include <sys/reboot.h>

#include <dev/biovar.h>
#include <dev/softraidvar.h>

#include <uvm/uvm_extern.h>
#include <sys/sysctl.h>

#include <machine/cpu.h>
#include <machine/biosvar.h>

#include <err.h>
#include <a.out.h>
#include <sys/exec_elf.h>
#include <fcntl.h>
#include <nlist.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

struct	sym_data {
	char		*sym_name;		/* Must be initialised */
	int		sym_size;		/* And this one */
	int		sym_set;		/* Rest set at runtime */
	u_int32_t	sym_value;
};

extern	char *__progname;
int	verbose, nowrite = 0;
char	*boot, *proto, *dev, *realdev;
char	*protostore;
long	protosize;
struct sym_data pbr_symbols[] = {
	{"_fs_bsize_p",	2},
	{"_fs_bsize_s",	2},
	{"_fsbtodb",	1},
	{"_p_offset",	4},
	{"_inodeblk",	4},
	{"_inodedbl",	4},
	{"_nblocks",	2},
	{NULL}
};

#define INODESEG	0x07e0	/* where we will put /boot's inode's block */
#define BOOTSEG		0x07c0	/* biosboot loaded here */

#define INODEOFF  ((INODESEG-BOOTSEG) << 4)

#define SR_FS_BLOCKSIZE	(16 * 1024)

static char	*loadproto(char *, long *);
static int	getbootparams(char *, int, struct disklabel *);
static void	devread(int, void *, daddr_t, size_t, char *);
static void	sym_set_value(struct sym_data *, char *, u_int32_t);
static void	pbr_set_symbols(char *, char *, struct sym_data *);
static void	usage(void);
static u_int	findopenbsd(int, struct disklabel *);
static void	write_bootblocks(int devfd, struct disklabel *);

static int	sr_volume(int, int *, int *);
static void	sr_installboot(int);
static void	sr_installpbr(int, int, int);

static void
usage(void)
{
	fprintf(stderr, "usage: %s [-nv] boot biosboot device\n", __progname);
	exit(1);
}

/*
 * Read information about /boot's inode and filesystem parameters, then
 * put biosboot (partition boot record) on the target drive with these
 * parameters patched in.
 */
int
main(int argc, char *argv[])
{
	int	vol = -1, ndisks = 0, disk;
	int	c;
	int	devfd;
	struct	disklabel dl;

	while ((c = getopt(argc, argv, "vn")) != -1) {
		switch (c) {
		case 'n':
			/* Do not actually write the bootblock to disk. */
			nowrite = 1;
			break;
		case 'v':
			/* Give more information. */
			verbose = 1;
			break;
		default:
			usage();
		}
	}

	if (argc - optind < 3)
		usage();

	boot = argv[optind];
	proto = argv[optind + 1];
	realdev = dev = argv[optind + 2];

	/* Open raw disk device. */
	if ((devfd = opendev(dev, (nowrite? O_RDONLY:O_RDWR),
	    OPENDEV_PART, &realdev)) < 0)
		err(1, "open: %s", realdev);

	if (verbose)
		fprintf(stderr, "boot: %s proto: %s device: %s\n",
		    boot, proto, realdev);

	/* Load proto blocks into core. */
	if ((protostore = loadproto(proto, &protosize)) == NULL)
		exit(1);

	/* XXX - Paranoia: Make sure size is aligned! */
	if (protosize & (DEV_BSIZE - 1))
		errx(1, "proto %s bad size=%ld", proto, protosize);

	if (protosize > SBSIZE - DEV_BSIZE)
		errx(1, "proto bootblocks too big");

	if (sr_volume(devfd, &vol, &ndisks)) {

		/* Install boot loader into softraid volume. */
		sr_installboot(devfd);

		/* Install biosboot on each disk that is part of this volume. */
		for (disk = 0; disk < ndisks; disk++)
			sr_installpbr(devfd, vol, disk);

	} else {

		/* Get and check disklabel. */
		if (ioctl(devfd, DIOCGDINFO, &dl) != 0)
			err(1, "disklabel: %s", realdev);
		if (dl.d_magic != DISKMAGIC)
			err(1, "bad disklabel magic=0x%08x", dl.d_magic);

		/* Warn on unknown disklabel types. */
		if (dl.d_type == 0)
			warnx("disklabel type unknown");

		/* Get bootstrap parameters to patch into proto. */
		if (getbootparams(boot, devfd, &dl) != 0)
			exit(1);

		/* Write boot blocks to device. */
		write_bootblocks(devfd, &dl);

	}

	(void)close(devfd);

	return 0;
}

void
write_bootblocks(int devfd, struct disklabel *dl)
{
	struct stat	sb;
	u_int8_t	*secbuf;
	u_int		start = 0;

	/* Write patched proto bootblock(s) into the superblock. */
	if (fstat(devfd, &sb) < 0)
		err(1, "stat: %s", realdev);

	if (!S_ISCHR(sb.st_mode))
		errx(1, "%s: not a character device", realdev);

	/* Patch the parameters into the proto bootstrap sector. */
	pbr_set_symbols(proto, protostore, pbr_symbols);

	if (!nowrite) {
		/* Sync filesystems (to clean in-memory superblock?). */
		sync(); sleep(1);
	}

	/*
	 * Find OpenBSD partition. Floppies are special, getting an
	 * everything-in-one biosboot starting at sector 0.
	 */
	if (dl->d_type != DTYPE_FLOPPY) {
		start = findopenbsd(devfd, dl);
		if (start == (u_int)-1)
 			errx(1, "no OpenBSD partition");
	}

	if (verbose)
		fprintf(stderr, "%s will be written at sector %u\n", proto,
		    start);

	if (start + (protosize / dl->d_secsize) > BOOTBIOS_MAXSEC)
		warnx("%s extends beyond sector %u. OpenBSD might not boot.",
		    proto, BOOTBIOS_MAXSEC);

	if (!nowrite) {
		if (lseek(devfd, (off_t)start * dl->d_secsize, SEEK_SET) < 0)
			err(1, "seek bootstrap");
		secbuf = calloc(1, dl->d_secsize);
		bcopy(protostore, secbuf, protosize);
		if (write(devfd, secbuf, dl->d_secsize) != dl->d_secsize)
			err(1, "write bootstrap");
		free(secbuf);
	}
}

u_int
findopenbsd(int devfd, struct disklabel *dl)
{
	struct		dos_mbr mbr;
	u_int		mbroff = DOSBBSECTOR;
	u_int		mbr_eoff = DOSBBSECTOR; /* Offset of extended part. */
	struct		dos_partition *dp;
	u_int8_t	*secbuf;
	int		i, maxebr = DOS_MAXEBR, nextebr;

again:
	if (!maxebr--) {
		if (verbose)
			fprintf(stderr, "Traversed more than %d Extended Boot "
			    "Records (EBRs)\n",
			    DOS_MAXEBR);
		return ((u_int)-1);
	}
		
	if (verbose)
		fprintf(stderr, "%s boot record (%cBR) at sector %u\n",
		    (mbroff == DOSBBSECTOR) ? "master" : "extended",
		    (mbroff == DOSBBSECTOR) ? 'M' : 'E', mbroff);

	secbuf = malloc(dl->d_secsize); 
	if (lseek(devfd, (off_t)mbroff * dl->d_secsize, SEEK_SET) < 0 ||
	    read(devfd, secbuf, dl->d_secsize) < sizeof(mbr))
		err(4, "can't read boot record");
	bcopy(secbuf, &mbr, sizeof(mbr));
	free(secbuf);

	if (mbr.dmbr_sign != DOSMBR_SIGNATURE)
		errx(1, "invalid boot record signature (0x%04X) @@ sector %u",
		    mbr.dmbr_sign, mbroff);

	nextebr = 0;
	for (i = 0; i < NDOSPART; i++) {
		dp = &mbr.dmbr_parts[i];
		if (!dp->dp_size)
			continue;

		if (verbose)
			fprintf(stderr,
			    "\tpartition %d: type 0x%02X offset %u size %u\n",
			    i, dp->dp_typ, dp->dp_start, dp->dp_size);

		if (dp->dp_typ == DOSPTYP_OPENBSD) {
			if (dp->dp_start > (dp->dp_start + mbroff))
				continue;
			return (dp->dp_start + mbroff);
		}

		if (!nextebr && (dp->dp_typ == DOSPTYP_EXTEND ||
		    dp->dp_typ == DOSPTYP_EXTENDL)) {
			nextebr = dp->dp_start + mbr_eoff;
			if (nextebr < dp->dp_start)
				nextebr = (u_int)-1;
			if (mbr_eoff == DOSBBSECTOR)
				mbr_eoff = dp->dp_start;
		}
	}

	if (nextebr && nextebr != (u_int)-1) {
		mbroff = nextebr;
		goto again;
	}

	return ((u_int)-1);
}

/*
 * Load the prototype boot sector (biosboot) into memory.
 */
static char *
loadproto(char *fname, long *size)
{
	int	fd;
	size_t	tdsize;		/* text+data size */
	char	*bp;
	Elf_Ehdr eh;
	Elf_Word phsize;
	Elf_Phdr *ph;

	if ((fd = open(fname, O_RDONLY)) < 0)
		err(1, "%s", fname);

	if (read(fd, &eh, sizeof(eh)) != sizeof(eh))
		errx(1, "%s: read failed", fname);

	if (!IS_ELF(eh))
		errx(1, "%s: bad magic: 0x%02x%02x%02x%02x",
		    fname,
		    eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		    eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);

	/*
	 * We have to include the exec header in the beginning of
	 * the buffer, and leave extra space at the end in case
	 * the actual write to disk wants to skip the header.
	 */

	/* Program load header. */
	if (eh.e_phnum != 1)
		errx(1, "%s: %u ELF load sections (only support 1)",
		    fname, eh.e_phnum);

	phsize = eh.e_phnum * sizeof(Elf_Phdr);
	ph = malloc(phsize);
	if (ph == NULL)
		err(1, NULL);

	lseek(fd, eh.e_phoff, SEEK_SET);

	if (read(fd, ph, phsize) != phsize)
		errx(1, "%s: can't read header", fname);

	tdsize = ph->p_filesz;

	/*
	 * Allocate extra space here because the caller may copy
	 * the boot block starting at the end of the exec header.
	 * This prevents reading beyond the end of the buffer.
	 */
	if ((bp = calloc(tdsize, 1)) == NULL) {
		err(1, NULL);
	}

	/* Read the rest of the file. */
	lseek(fd, ph->p_offset, SEEK_SET);
	if (read(fd, bp, tdsize) != tdsize) {
		errx(1, "%s: read failed", fname);
	}

	*size = tdsize;	/* not aligned to DEV_BSIZE */

	close(fd);
	return bp;
}

static void
devread(int fd, void *buf, daddr_t blk, size_t size, char *msg)
{
	if (lseek(fd, dbtob((off_t)blk), SEEK_SET) != dbtob((off_t)blk))
		err(1, "%s: devread: lseek", msg);

	if (read(fd, buf, size) != size)
		err(1, "%s: devread: read", msg);
}

static char sblock[SBSIZE];

/*
 * Read information about /boot's inode, then put this and filesystem
 * parameters from the superblock into pbr_symbols.
 */
static int
getbootparams(char *boot, int devfd, struct disklabel *dl)
{
	int		fd;
	struct stat	statbuf, sb;
	struct statfs	statfsbuf;
	struct partition *pp;
	struct fs	*fs;
	char		*buf;
	u_int		blk, *ap;
	struct ufs1_dinode	*ip;
	int		ndb;
	int		mib[3];
	size_t		size;
	dev_t		dev;

	/*
	 * Open 2nd-level boot program and record enough details about
	 * where it is on the filesystem represented by `devfd'
	 * (inode block, offset within that block, and various filesystem
	 * parameters essentially taken from the superblock) for biosboot
	 * to be able to load it later.
	 */

	/* Make sure the (probably new) boot file is on disk. */
	sync(); sleep(1);

	if ((fd = open(boot, O_RDONLY)) < 0)
		err(1, "open: %s", boot);

	if (fstatfs(fd, &statfsbuf) != 0)
		err(1, "statfs: %s", boot);

	if (strncmp(statfsbuf.f_fstypename, "ffs", MFSNAMELEN) &&
	    strncmp(statfsbuf.f_fstypename, "ufs", MFSNAMELEN) )
		errx(1, "%s: not on an FFS filesystem", boot);

#if 0
	if (read(fd, &eh, sizeof(eh)) != sizeof(eh))
		errx(1, "read: %s", boot);

	if (!IS_ELF(eh)) {
		errx(1, "%s: bad magic: 0x%02x%02x%02x%02x",
		    boot,
		    eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		    eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
	}
#endif

	if (fsync(fd) != 0)
		err(1, "fsync: %s", boot);

	if (fstat(fd, &statbuf) != 0)
		err(1, "fstat: %s", boot);

	if (fstat(devfd, &sb) != 0)
		err(1, "fstat: %s", realdev);

	/* Check devices. */
	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_CHR2BLK;
	mib[2] = sb.st_rdev;
	size = sizeof(dev);
	if (sysctl(mib, 3, &dev, &size, NULL, 0) >= 0) {
		if (statbuf.st_dev / MAXPARTITIONS != dev / MAXPARTITIONS)
			errx(1, "cross-device install");
	}

	pp = &dl->d_partitions[DISKPART(statbuf.st_dev)];
	close(fd);

	/* Read superblock. */
	devread(devfd, sblock, DL_SECTOBLK(dl, DL_GETPOFFSET(pp)) + SBLOCK,
	    SBSIZE, "superblock");
	fs = (struct fs *)sblock;

	/* Sanity-check super-block. */
	if (fs->fs_magic != FS_MAGIC)
		errx(1, "Bad magic number in superblock");
	if (fs->fs_inopb <= 0)
		err(1, "Bad inopb=%d in superblock", fs->fs_inopb);

	/* Read inode. */
	if ((buf = malloc(fs->fs_bsize)) == NULL)
		err(1, NULL);

	blk = fsbtodb(fs, ino_to_fsba(fs, statbuf.st_ino));

	devread(devfd, buf, DL_SECTOBLK(dl, DL_GETPOFFSET(pp)) + blk,
	    fs->fs_bsize, "inode");
	ip = (struct ufs1_dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);

	/*
	 * Have the inode.  Figure out how many filesystem blocks (not disk
	 * sectors) there are for biosboot to load.
	 */
	ndb = howmany(ip->di_size, fs->fs_bsize);
	if (ndb <= 0)
		errx(1, "No blocks to load");

	/*
	 * Now set the values that will need to go into biosboot
	 * (the partition boot record, a.k.a. the PBR).
	 */
	sym_set_value(pbr_symbols, "_fs_bsize_p", (fs->fs_bsize / 16));
	sym_set_value(pbr_symbols, "_fs_bsize_s", (fs->fs_bsize / 
	    dl->d_secsize));

	/*
	 * fs_fsbtodb is the shift to convert fs_fsize to DEV_BSIZE. The
	 * ino_to_fsba() return value is the number of fs_fsize units.
	 * Calculate the shift to convert fs_fsize into physical sectors,
	 * which are added to p_offset to get the sector address BIOS
	 * will use.
	 *
	 * N.B.: ASSUMES fs_fsize is a power of 2 of d_secsize.
	 */
	sym_set_value(pbr_symbols, "_fsbtodb",
	    ffs(fs->fs_fsize / dl->d_secsize) - 1);

	if (pp->p_offseth != 0)
		errx(1, "partition offset too high");
	sym_set_value(pbr_symbols, "_p_offset", pp->p_offset);
	sym_set_value(pbr_symbols, "_inodeblk",
	    ino_to_fsba(fs, statbuf.st_ino));
	ap = ip->di_db;
	sym_set_value(pbr_symbols, "_inodedbl",
	    ((((char *)ap) - buf) + INODEOFF));
	sym_set_value(pbr_symbols, "_nblocks", ndb);

	if (verbose) {
		fprintf(stderr, "%s is %d blocks x %d bytes\n",
		    boot, ndb, fs->fs_bsize);
		fprintf(stderr, "fs block shift %u; part offset %llu; "
		    "inode block %lld, offset %u\n",
		    ffs(fs->fs_fsize / dl->d_secsize) - 1,
		    DL_GETPOFFSET(pp), ino_to_fsba(fs, statbuf.st_ino),
		    (unsigned int)((((char *)ap) - buf) + INODEOFF));
	}

	return 0;
}

static void
sym_set_value(struct sym_data *sym_list, char *sym, u_int32_t value)
{
	struct sym_data *p;

	for (p = sym_list; p->sym_name != NULL; p++) {
		if (strcmp(p->sym_name, sym) == 0)
			break;
	}

	if (p->sym_name == NULL)
		errx(1, "%s: no such symbol", sym);

	p->sym_value = value;
	p->sym_set = 1;
}

/*
 * Write the parameters stored in sym_list into the in-memory copy of
 * the prototype biosboot (proto), ready for it to be written to disk.
 */
static void
pbr_set_symbols(char *fname, char *proto, struct sym_data *sym_list)
{
	struct sym_data *sym;
	struct nlist	*nl;
	char		*vp;
	u_int32_t	*lp;
	u_int16_t	*wp;
	u_int8_t	*bp;

	for (sym = sym_list; sym->sym_name != NULL; sym++) {
		if (!sym->sym_set)
			errx(1, "%s not set", sym->sym_name);

		/* Allocate space for 2; second is null-terminator for list. */
		nl = calloc(2, sizeof(struct nlist));
		if (nl == NULL)
			err(1, NULL);

		nl->n_un.n_name = sym->sym_name;

		if (nlist(fname, nl) != 0)
			errx(1, "%s: symbol %s not found",
			    fname, sym->sym_name);

		if (nl->n_type != (N_TEXT))
			errx(1, "%s: %s: wrong type (%x)",
			    fname, sym->sym_name, nl->n_type);

		/* Get a pointer to where the symbol's value needs to go. */
		vp = proto + nl->n_value;

		switch (sym->sym_size) {
		case 4:					/* u_int32_t */
			lp = (u_int32_t *) vp;
			*lp = sym->sym_value;
			break;
		case 2:					/* u_int16_t */
			if (sym->sym_value >= 0x10000)	/* out of range */
				errx(1, "%s: symbol out of range (%u)",
				    sym->sym_name, sym->sym_value);
			wp = (u_int16_t *) vp;
			*wp = (u_int16_t) sym->sym_value;
			break;
		case 1:					/* u_int16_t */
			if (sym->sym_value >= 0x100)	/* out of range */
				errx(1, "%s: symbol out of range (%u)",
				    sym->sym_name, sym->sym_value);
			bp = (u_int8_t *) vp;
			*bp = (u_int8_t) sym->sym_value;
			break;
		default:
			errx(1, "%s: bad symbol size %d",
			    sym->sym_name, sym->sym_size);
			/* NOTREACHED */
		}

		free(nl);
	}
}

int
sr_volume(int devfd, int *vol, int *disks)
{
	struct	bioc_inq bi;
	struct	bioc_vol bv;
	int	rv, i;

	/* Get volume information. */
	memset(&bi, 0, sizeof(bi));
	rv = ioctl(devfd, BIOCINQ, &bi);
	if (rv == -1)
		return 0;

	/* XXX - softraid volumes will always have a "softraid0" controller. */
	if (strncmp(bi.bi_dev, "softraid0", sizeof("softraid0")))
		return 0;

	/* Locate specific softraid volume. */
	for (i = 0; i < bi.bi_novol; i++) {

		memset(&bv, 0, sizeof(bv));
		bv.bv_volid = i;
		rv = ioctl(devfd, BIOCVOL, &bv);
		if (rv == -1)
			err(1, "BIOCVOL");

		if (strncmp(dev, bv.bv_dev, sizeof(bv.bv_dev)) == 0) {
			*vol = i;
			*disks = bv.bv_nodisk;
			break;
		}

	}

	if (verbose)
		fprintf(stderr, "%s: softraid volume with %i disk(s)\n",
		    dev, *disks);

	return 1;
}

void
sr_installboot(int devfd)
{
	struct bioc_installboot bb;
	struct stat sb;
	struct ufs1_dinode *ino_p;
	uint32_t bootsize, inodeblk, inodedbl;
	uint16_t bsize = SR_FS_BLOCKSIZE;
	uint16_t nblocks;
	uint8_t bshift = 5;		/* fragsize == blocksize */
	int fd, i, rv;
	u_char *p;

	/*
	 * Install boot loader into softraid boot loader storage area.
	 *
	 * In order to allow us to reuse the existing biosboot we construct
	 * a fake FFS filesystem with a single inode, which points to the
	 * boot loader.
	 */

	nblocks = howmany(SR_BOOT_LOADER_SIZE, SR_FS_BLOCKSIZE / DEV_BSIZE);
	inodeblk = nblocks - 1;
	bootsize = nblocks * SR_FS_BLOCKSIZE;

	p = malloc(bootsize);
	if (p == NULL)
		err(1, NULL);
	
	memset(p, 0, bootsize);
	fd = open(boot, O_RDONLY, 0);
	if (fd == -1)
		err(1, NULL);

	if (fstat(fd, &sb) == -1)
		err(1, NULL);

	nblocks = howmany(sb.st_blocks, SR_FS_BLOCKSIZE / DEV_BSIZE);
	if (sb.st_blocks * S_BLKSIZE > bootsize - sizeof(struct ufs1_dinode))
		errx(1, "boot code will not fit");

	/* We only need to fill the direct block array. */
	ino_p = (struct ufs1_dinode *)&p[bootsize - sizeof(struct ufs1_dinode)];

	ino_p->di_mode = sb.st_mode;
	ino_p->di_nlink = 1;
	ino_p->di_inumber = 0xfeebfaab;
	ino_p->di_size = read(fd, p, sb.st_blocks * S_BLKSIZE);
	ino_p->di_blocks = nblocks;
	for (i = 0; i < nblocks; i++)
		ino_p->di_db[i] = i;

	inodedbl = ((u_char*)&ino_p->di_db[0] -
	    &p[bootsize - SR_FS_BLOCKSIZE]) + INODEOFF;

	bb.bb_bootldr = p;
	bb.bb_bootldr_size = bootsize;
	bb.bb_bootblk = "XXX";
	bb.bb_bootblk_size = sizeof("XXX");
	strncpy(bb.bb_dev, dev, sizeof(bb.bb_dev));
	if (!nowrite) {
		if (verbose)
			fprintf(stderr, "%s: installing boot loader on "
			    "softraid volume\n", dev);
		rv = ioctl(devfd, BIOCINSTALLBOOT, &bb);
		if (rv != 0)
			errx(1, "softraid installboot failed");
	}

	/*
	 * Set the values that will need to go into biosboot
	 * (the partition boot record, a.k.a. the PBR).
	 */
	sym_set_value(pbr_symbols, "_fs_bsize_p", (bsize / 16));
	sym_set_value(pbr_symbols, "_fs_bsize_s", (bsize / 512));
	sym_set_value(pbr_symbols, "_fsbtodb", bshift);
	sym_set_value(pbr_symbols, "_inodeblk", inodeblk);
	sym_set_value(pbr_symbols, "_inodedbl", inodedbl);
	sym_set_value(pbr_symbols, "_nblocks", nblocks);

	if (verbose)
		fprintf(stderr, "%s is %d blocks x %d bytes\n",
		    boot, nblocks, bsize);

	close(fd);
}

void
sr_installpbr(int devfd, int vol, int disk)
{
	struct bioc_disk bd;
	struct disklabel dl;
	struct partition *pp;
	uint32_t poffset;
	char *realdiskdev;
	char part;
	int diskfd;
	int rv;

	/* Get device name for this disk/chunk. */
	memset(&bd, 0, sizeof(bd));
	bd.bd_volid = vol;
	bd.bd_diskid = disk;
	rv = ioctl(devfd, BIOCDISK, &bd);
	if (rv == -1)
		err(1, "BIOCDISK");

	/* Check disk status. */
	if (bd.bd_status != BIOC_SDONLINE && bd.bd_status != BIOC_SDREBUILD) {
		fprintf(stderr, "softraid chunk %u not online - skipping...\n",
		    disk);
		return;	
	}

	if (strlen(bd.bd_vendor) < 1)
		errx(1, "invalid disk name");
	part = bd.bd_vendor[strlen(bd.bd_vendor) - 1];
	if (part < 'a' || part >= 'a' + MAXPARTITIONS)
		errx(1, "invalid partition %c\n", part);
	bd.bd_vendor[strlen(bd.bd_vendor) - 1] = '\0';

	/* Open this device and check its disklabel. */
	if ((diskfd = opendev(bd.bd_vendor, (nowrite? O_RDONLY:O_RDWR),
	    OPENDEV_PART, &realdiskdev)) < 0)
		err(1, "open: %s", realdiskdev);

	/* Get and check disklabel. */
	if (ioctl(diskfd, DIOCGDINFO, &dl) != 0)
		err(1, "disklabel: %s", realdev);
	if (dl.d_magic != DISKMAGIC)
		err(1, "bad disklabel magic=0x%08x", dl.d_magic);

	/* Warn on unknown disklabel types. */
	if (dl.d_type == 0)
		warnx("disklabel type unknown");

	/* Determine poffset and set symbol value. */
	pp = &dl.d_partitions[part - 'a'];
	if (pp->p_offseth != 0)
		errx(1, "partition offset too high");
	poffset = pp->p_offset; 		/* Offset of RAID partition. */
	poffset += SR_BOOT_LOADER_OFFSET;	/* SR boot loader area. */
	sym_set_value(pbr_symbols, "_p_offset", poffset);

	if (verbose)
		fprintf(stderr, "%s%c: installing boot blocks on %s, "
		    "part offset %u\n", bd.bd_vendor, part, realdiskdev,
		    poffset);

	/* Write boot blocks to device. */
	write_bootblocks(diskfd, &dl);

	close(diskfd);
}
@


1.70
log
@Use DL_GETPOFFSET() to get partition offset, except where we
explicitly check p_offseth before assigning p_offset to
local variables. Add missing check for p_offseth.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.69 2013/06/11 16:42:08 deraadt Exp $	*/
@


1.69
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.68 2013/01/16 15:35:33 naddy Exp $	*/
d488 1
a488 1
	devread(devfd, sblock, DL_SECTOBLK(dl, pp->p_offset) + SBLOCK,
d504 1
a504 1
	devread(devfd, buf, DL_SECTOBLK(dl, pp->p_offset) + blk,
d536 2
d549 1
a549 1
		fprintf(stderr, "fs block shift %u; part offset %u; "
d552 1
a552 2
		    pp->p_offset,
		    ino_to_fsba(fs, statbuf.st_ino),
@


1.68
log
@properly distinguish /boot and biosboot in informational and error messages
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.67 2011/11/13 14:52:30 jsing Exp $	*/
d102 1
a102 1
static void	devread(int, void *, daddr64_t, size_t, char *);
d401 1
a401 1
devread(int fd, void *buf, daddr64_t blk, size_t size, char *msg)
@


1.67
log
@If a softraid chunk is offline we are not necessarily going to have the
disk/partition name - in this case print the chunk number instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.65 2011/07/05 18:34:10 krw Exp $	*/
d234 1
a234 1
	 * everything-in-one /boot starting at sector 0.
d243 2
a244 1
		fprintf(stderr, "/boot will be written at sector %u\n", start);
d247 2
a248 2
		warnx("/boot extends beyond sector %u. OpenBSD might not boot.",
		    BOOTBIOS_MAXSEC);
d352 1
a352 1
		    boot,
d365 1
a365 1
		    boot, eh.e_phnum);
d375 1
a375 1
		errx(1, "%s: can't read header", boot);
@


1.66
log
@Warn about but don't prevent installboot from installing /boot when
the OpenBSD partition starts at >128G. This restores previous
behaviour but adds the warning.

ok deraadt@@ guenther@@
@
text
@d789 2
a790 2
		fprintf(stderr, "softraid disk %s not online - skipping...\n",
		    bd.bd_vendor);
d795 1
a795 1
		errx(1, "invalid disk name %s", bd.bd_vendor);
@


1.65
log
@Don't write /boot to sector 0 on non-floppy devices. Non-floppy
devices must have an OpenBSD MBR partition to install /boot into.
But search anything except floppy devices (e.g. vnd) for such a
partition.

Feedback & ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.64 2011/07/05 17:38:54 krw Exp $	*/
d242 3
d246 1
a246 1
		errx(1, "invalid location: all of /boot must be < sector %u.",
a247 3

	if (verbose)
		fprintf(stderr, "/boot will be written at sector %u\n", start);
@


1.64
log
@More non-512-byte sector groundwork. Don't let disklabel hint that
a ffs frag size can be less than the d_secsize of the disk.  Make
sure amd64 writedisklabel() puts the disklabel where readdoslabel()
will read it. Tweak i386/amd64 installboot/biosboot so sectors are
indeed used where sectors are claimed.

Lets me fdisk, newfs, mount and installboot onto 2048 and 4096
byte sector devices. Other filesystem utilites will still hold
surprises.

Note that actually booting from such devices will await BIOSen that
acknowledge such devices as bootable.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.63 2011/07/03 19:21:48 krw Exp $	*/
d232 5
a236 3
	if (dl->d_type != 0 && dl->d_type != DTYPE_FLOPPY &&
	    dl->d_type != DTYPE_VND) {
		/* Find OpenBSD partition. */
@


1.63
log
@Change name of pointer to partition from pl to pp, as is used everywhere else, No
functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.62 2011/04/24 22:44:22 krw Exp $	*/
d214 1
d240 1
a240 1
	if (start + (protosize / DEV_BSIZE) > BOOTBIOS_MAXSEC)
d248 5
a252 2
		if (lseek(devfd, (off_t)start * dl->d_secsize, SEEK_SET) < 0 ||
		    write(devfd, protostore, protosize) != protosize)
d254 1
d265 1
d282 1
d284 1
a284 1
	    read(devfd, &mbr, sizeof(mbr)) != sizeof(mbr))
d286 2
d485 2
a486 1
	devread(devfd, sblock, pp->p_offset + SBLOCK, SBSIZE, "superblock");
d501 2
a502 1
	devread(devfd, buf, pp->p_offset + blk, fs->fs_bsize, "inode");
d518 15
a532 2
	sym_set_value(pbr_symbols, "_fs_bsize_s", (fs->fs_bsize / 512));
	sym_set_value(pbr_symbols, "_fsbtodb", fs->fs_fsbtodb);
d545 3
a547 2
		    "inode block %lld, offset %ld\n",
		    fs->fs_fsbtodb, pp->p_offset,
d549 1
a549 1
		    ((((char *)ap) - buf) + INODEOFF));
@


1.62
log
@Don't leak fd's in sr_installboot(). From cppcheck via Amit Kulkarni.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.61 2011/03/19 11:55:58 krw Exp $	*/
d410 1
a410 1
	struct partition *pl;
d472 1
a472 1
	pl = &dl->d_partitions[DISKPART(statbuf.st_dev)];
d476 1
a476 1
	devread(devfd, sblock, pl->p_offset + SBLOCK, SBSIZE, "superblock");
d491 1
a491 1
	devread(devfd, buf, pl->p_offset + blk, fs->fs_bsize, "inode");
d509 1
a509 1
	sym_set_value(pbr_symbols, "_p_offset", pl->p_offset);
d522 1
a522 1
		    fs->fs_fsbtodb, pl->p_offset,
@


1.61
log
@Make amd64/i386 installboot error out if /boot would cross the
BOOTBIOS_MAXSEC line.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.60 2011/03/17 12:53:44 krw Exp $	*/
d736 2
@


1.60
log
@Make the various findopenbsd() functions non-recursive, eliminating
a global, a couple of parameters, and opening up possibility of
traversing much longer EBR lists without blowing the stack.

Make seach algorithm the same as used in kern/subr_disk.c by checking
all primary partitions in the MBR/EBR before moving to next EBR. This
makes it more likely that everybody finds the same OpenBSD partition.

Largely from a diff posted to tech@@ by ucsavl.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.59 2011/03/14 22:14:40 krw Exp $	*/
d238 4
@


1.59
log
@Clamp BIOS io attempts to < 2 ^28 - 1 sectors (a.k.a. 128GB for
512-byte sectors) as some BIOSen get confused when we ask for sectors
higher up.

Uss u_int throughout the boot code to calculate sector addresses,
since 32 bits is enough to do 28  ^ 1 - 1 arithmetic. Add checks
for wraparound.

I can now install and boot from the 7th extended partition below
128GB.

Much feedback & guidance from deraadt@@. Also from weingart@@ on
BIOS io.

ok deraadt@@ (less a couple of minor tweaks found in testing)
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.58 2011/03/13 00:13:52 deraadt Exp $	*/
d106 1
a106 1
static u_int	findopenbsd(int, struct disklabel *, u_int, int *);
a112 2
static u_int	mbr_eoff; /* Offset of the MBR extended partition. */

d213 1
a213 1
	struct		stat sb;
a214 1
	int		n = 8;
d234 1
a234 2
		mbr_eoff = DOSBBSECTOR;	/* Offset of MBR extended partition. */
		start = findopenbsd(devfd, dl, DOSBBSECTOR, &n);
d250 1
a250 1
findopenbsd(int devfd, struct disklabel *dl, u_int mbroff, int *n)
d253 2
d256 1
a256 6
	u_int		start = (u_int)-1;
	int		i;

	/* Limit the number of recursions */
	if (!(*n)--)
		return (-1);
d258 9
d280 1
d294 1
a294 2
			start = dp->dp_start + mbroff;
			break;
d297 5
a301 3
		if (dp->dp_typ == DOSPTYP_EXTEND ||
		    dp->dp_typ == DOSPTYP_EXTENDL) {
			mbroff = dp->dp_start + mbr_eoff;
a303 5
			if (mbroff < dp->dp_start)
				continue;
			start = findopenbsd(devfd, dl, mbroff, n);
			if (start != (u_int)-1)
				break;
d307 6
a312 1
	return (start);
@


1.58
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.57 2011/03/08 17:24:31 krw Exp $	*/
d106 1
a106 1
static daddr64_t findopenbsd(int, struct disklabel *, daddr64_t, int *);
d113 1
a113 1
static daddr64_t mbr_eoff; /* Offset of the MBR extended partition. */
d216 1
a216 1
	daddr64_t	start = 0;
d237 3
a239 3
		mbr_eoff = 0;	/* Offset of MBR extended partition. */
		start = findopenbsd(devfd, dl, (daddr64_t)DOSBBSECTOR, &n);
		if (start == -1)
d244 1
a244 2
		fprintf(stderr, "/boot will be written at sector %lld\n",
		    (long long)start);
d253 2
a254 2
daddr64_t
findopenbsd(int devfd, struct disklabel *dl, daddr64_t mbroff, int *n)
d258 1
a258 1
	daddr64_t	start = -1;
d266 3
a268 4
		fprintf(stderr, "%s boot record (%cBR) at sector %lld\n",
		    (mbroff == (off_t)DOSBBSECTOR) ? "master" : "extended",
		    (mbroff == (off_t)DOSBBSECTOR) ? 'M' : 'E',
		    (long long)mbroff);
d270 1
a270 1
	if (lseek(devfd, mbroff * dl->d_secsize, SEEK_SET) < 0 ||
d275 2
a276 2
		errx(1, "invalid boot record signature (0x%04X) @@ sector %lld",
		    mbr.dmbr_sign, (long long)mbroff);
d285 1
a285 1
			    "\tpartition %d: type 0x%02X offset %d size %d\n",
d289 3
a291 1
			start = (daddr64_t)dp->dp_start + mbroff;
d297 5
a301 3
			mbroff = (daddr64_t)dp->dp_start + mbr_eoff;
			if (!mbr_eoff)
				mbr_eoff = (daddr64_t)dp->dp_start;
d303 1
a303 1
			if (start != -1)
@


1.57
log
@Fix extended partition searching so we don't get lost. The offset
of the next EBR is relative to the start of the extended partition
described in the first MBR, not relative to the EBR specifying the
offset in its extended partition entry.

Clean up installboot -v output. Use daddr64_t for all sector numbers.

Not a complete fix, but better than what we had. More tweaks to
come.

Inspired by a diff and cluebat from uscav on tech@@ a few weeks
ago.

Feedback from matthew@@, weingart@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.56 2011/01/23 14:57:08 jsing Exp $	*/
d102 1
a102 1
static void	devread(int, void *, daddr_t, size_t, char *);
d379 1
a379 1
devread(int fd, void *buf, daddr_t blk, size_t size, char *msg)
d403 1
a403 1
	daddr_t		blk, *ap;
@


1.56
log
@Add support to installboot(8) for installing biosboot(8) and boot(8) on
softraid volumes. If installboot is run on a softraid volume, a fake
single inode FFS filesystem is constructed to contain boot(8). This is
then installed onto the softraid volume via the BIOCINSTALLBOOT ioctl.
biosboot(8) is then patched and installed onto each disk that is a member
of the softraid volume.

Joint work with otto@@ who came up with the concept of constructing a fake
FFS filesystem and wrote the code to do so.

No objection from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.54 2009/04/23 16:39:18 deraadt Exp $	*/
d106 1
a106 1
static long	findopenbsd(int, struct disklabel *, off_t, int *);
d113 2
d215 3
a217 4
	struct	stat sb;
	off_t	startoff = 0;
	long	start = 0;
	int	n = 8;
d237 2
a238 1
		start = findopenbsd(devfd, dl, (off_t)DOSBBSECTOR, &n);
a240 1
		startoff = (off_t)start * dl->d_secsize;
d243 4
d248 1
a248 1
		if (lseek(devfd, startoff, SEEK_SET) < 0 ||
d254 2
a255 2
long
findopenbsd(int devfd, struct disklabel *dl, off_t mbroff, int *n)
d259 2
a260 2
	off_t		startoff;
	long		start;
d266 6
d274 1
a274 1
		err(4, "can't read master boot record");
d277 2
a278 1
		errx(1, "broken MBR");
d280 2
a281 2
	for (dp = mbr.dmbr_parts; dp < &mbr.dmbr_parts[NDOSPART];
	    dp++) {
d284 6
d291 5
a295 7
			if (verbose)
				fprintf(stderr,
				    "using MBR partition %ld: type 0x%02X offset %d\n",
				    (long)(dp - mbr.dmbr_parts),
				    dp->dp_typ, dp->dp_start);
			return (dp->dp_start + mbroff);
		} else if (dp->dp_typ == DOSPTYP_EXTEND ||
d297 4
a300 7
			if (verbose)
				fprintf(stderr,
				    "extended partition %ld: type 0x%02X offset %d\n",
				    (long)(dp - mbr.dmbr_parts),
				    dp->dp_typ, dp->dp_start);
			startoff = (off_t)dp->dp_start + mbroff;
			start = findopenbsd(devfd, dl, startoff, n);
d302 1
a302 1
				return (start);
d306 1
a306 1
	return (-1);
@


1.55
log
@Without -v, be quiet
ok toby
@
text
@d5 2
d50 3
d80 2
d98 2
d107 5
d128 1
a130 3
	char	*protostore;
	long	protosize;
	struct	stat sb;
a131 3
	off_t	startoff = 0;
	long	start = 0;
	int	n = 8;
d155 1
a155 1
	/* Open and check raw disk device. */
a163 11
	if (ioctl(devfd, DIOCGDINFO, &dl) != 0)
		err(1, "disklabel: %s", realdev);

	/* Check disklabel. */
	if (dl.d_magic != DISKMAGIC)
		err(1, "bad disklabel magic=0x%08x", dl.d_magic);

	/* Warn on unknown disklabel types. */
	if (dl.d_type == 0)
		warnx("disklabel type unknown");

a171 1
	/* Write patched proto bootblock(s) into the superblock. */
d175 44
a224 4
	/* Get bootstrap parameters that are to be patched into proto. */
	if (getbootparams(boot, devfd, &dl) != 0)
		exit(1);

d233 2
a234 2
	if (dl.d_type != 0 && dl.d_type != DTYPE_FLOPPY &&
	    dl.d_type != DTYPE_VND) {
d236 1
a236 1
		start = findopenbsd(devfd, &dl, (off_t)DOSBBSECTOR, &n);
d239 1
a239 1
		startoff = (off_t)start * dl.d_secsize;
a246 4

	(void)close(devfd);

	return 0;
a519 3
	if (p->sym_set)
		errx(1, "%s already set", p->sym_name);

d587 194
@


1.54
log
@-v was printing some information which is irrelevant or duplicate.  This
shrinks the output of installboot by a few lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.53 2008/08/04 15:58:13 reyk Exp $	*/
d240 5
a244 4
			fprintf(stderr,
			    "using MBR partition %ld: type 0x%02X offset %d\n",
			    (long)(dp - mbr.dmbr_parts),
			    dp->dp_typ, dp->dp_start);
d248 5
a252 4
			fprintf(stderr,
			    "extended partition %ld: type 0x%02X offset %d\n",
			    (long)(dp - mbr.dmbr_parts),
			    dp->dp_typ, dp->dp_start);
@


1.53
log
@fix extended partition support by handling chained EBRs correctly
(using a recursion limit).  now OpenBSD can be installed in a
subsequent DOS/Linux-compatible extended partition.

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.52 2008/06/25 15:26:44 reyk Exp $	*/
d151 3
a153 5
	if (verbose) {
		fprintf(stderr, "boot: %s\n", boot);
		fprintf(stderr, "proto: %s\n", proto);
		fprintf(stderr, "device: %s\n", realdev);
	}
d240 2
a241 2
			fprintf(stderr, "using MBR partition %ld: "
			    "type %d (0x%02x) offset %d (0x%x)\n",
d243 1
a243 2
			    dp->dp_typ, dp->dp_typ,
			    dp->dp_start, dp->dp_start);
d247 2
a248 2
			fprintf(stderr, "extended partition %ld: "
			    "type %d (0x%02x) offset %d (0x%x)\n",
d250 1
a250 2
			    dp->dp_typ, dp->dp_typ,
			    dp->dp_start, dp->dp_start);
a324 5

	if (verbose) {
		fprintf(stderr, "%s: entry point %#x\n", fname, eh.e_entry);
		fprintf(stderr, "proto bootblock size %ld\n", *size);
	}
@


1.52
log
@allow to install and boot the OpenBSD A6 partition and disklabel in an
extended DOS partition.  the concept of extended partitions is very
simple, it is just another mbr at the partition offset (well, the
standard "EBR" is a linked list with a few limitations, but this diff
works with both variants).

this diff has been in the snapshots for a while.

with input from weingart@@ and krw@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.51 2008/01/24 12:09:54 krw Exp $	*/
d230 1
a230 1
	if (lseek(devfd, mbroff, SEEK_SET) < 0 ||
a240 1
		startoff = (off_t)dp->dp_start * dl->d_secsize;
d247 1
a247 1
			break;
d255 1
d258 1
a258 1
				return (dp->dp_start + start);
a260 3
	/* Don't check for old part number, that is ;-p */
	if (dp >= &mbr.dmbr_parts[NDOSPART])
		return (-1);
d262 1
a262 1
	return (dp->dp_start);
@


1.51
log
@"read(..., ..., sizeof Y) < sizeof Y" is a dangerous idiom because it
does an unsigned comparison and read() can return -1. Use '!=' instead
of '<' since read() can't return more than 'sizeof Y'. Not perfect
(that would require a separate test for -1) but a very common usage.

ok toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.50 2008/01/05 19:50:48 otto Exp $	*/
d97 1
a119 2
	struct	dos_mbr mbr;
	struct	dos_partition *dp;
d121 2
a199 7
		if (lseek(devfd, (off_t)DOSBBSECTOR, SEEK_SET) < 0 ||
		    read(devfd, &mbr, sizeof(mbr)) != sizeof(mbr))
			err(4, "can't read master boot record");

		if (mbr.dmbr_sign != DOSMBR_SIGNATURE)
			errx(1, "broken MBR");

d201 4
a204 15
		for (dp = mbr.dmbr_parts; dp < &mbr.dmbr_parts[NDOSPART];
		    dp++) {
			if (dp->dp_size && dp->dp_typ == DOSPTYP_OPENBSD) {
				startoff = (off_t)dp->dp_start * dl.d_secsize;
				fprintf(stderr, "using MBR partition %ld: "
				    "type %d (0x%02x) offset %d (0x%x)\n",
				    (long)(dp - mbr.dmbr_parts),
				    dp->dp_typ, dp->dp_typ,
				    dp->dp_start, dp->dp_start);
				break;
			}
		}
		/* Don't check for old part number, that is ;-p */
		if (dp >= &mbr.dmbr_parts[NDOSPART])
			errx(1, "no OpenBSD partition");
d216 50
@


1.50
log
@handle 64-bit blkno in format string
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.49 2006/02/14 17:16:19 aaron Exp $	*/
d200 1
a200 1
		    read(devfd, &mbr, sizeof(mbr)) < sizeof(mbr))
@


1.49
log
@Fix botched format string specifiers.  From adobriyan at gmail.com.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.48 2006/01/13 17:53:09 millert Exp $	*/
d442 1
a442 1
		    "inode block %u, offset %ld\n",
@


1.48
log
@Fix printf format string due to types change
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.47 2004/07/15 21:44:16 tom Exp $	*/
d161 1
a161 1
		err(1, "bad disklabel magic=%0x8x", dl.d_magic);
@


1.47
log
@"mib[4] is too much and mib[3] would be enough" (left over from when
another sysctl() - which did require mib[4] - was removed).

From Andrey Matveev - andrushock (at) vniigim (dot) ru - via mickey@@.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.46 2004/05/05 04:33:56 mickey Exp $	*/
d442 1
a442 1
		    "inode block %u, offset %u\n",
@


1.46
log
@errx shall be used here
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.45 2004/02/22 09:03:05 tom Exp $	*/
d337 1
a337 1
	int		mib[4];
@


1.45
log
@Remove #if 0'd code.

requested by weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.44 2004/02/21 00:29:57 tom Exp $	*/
d173 1
a173 1
		err(1, "proto %s bad size=%ld", proto, protosize);
@


1.44
log
@Tidy up installboot -v output.

requested by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.43 2004/01/26 23:21:49 tom Exp $	*/
a532 6

#if 0
		if (verbose)
			fprintf(stderr, "%s = %u\n",
			    sym->sym_name, sym->sym_value);
#endif
@


1.43
log
@Major overhaul of biosboot and installboot, using EDD (LBA) reads if
the BIOS supports it.  File location data now geometry-independent
(biosboot groks part of the inode), so installboot loses -h and -s.

Many thanks to all those brave enough to try the snapshots.  Thanks
for the test reports, everyone.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.42 2004/01/20 23:02:26 tom Exp $	*/
a421 3
	if (verbose)
		fprintf(stderr, "%s is %d blocks x %d bytes\n",
		    boot, ndb, fs->fs_bsize);
d438 10
d534 1
d538 1
@


1.42
log
@Check the values given to -h and -s.  Closes PR 3640.

ok weingart@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.41 2003/08/25 23:27:43 tedu Exp $	*/
d5 1
d65 7
d73 1
a73 1
int	verbose, nowrite, nheads, nsectors, userspec = 0;
d75 9
a83 6
struct nlist nl[] = {
#define X_BLOCK_COUNT	0
	{{"_block_count"}},
#define X_BLOCK_TABLE	1
	{{"_block_table"}},
	{{NULL}}
d86 2
a87 3
u_int8_t *block_count_p;	/* block count var. in prototype image */
u_int8_t *block_table_p;	/* block number array in prototype image */
int	maxblocknum;		/* size of this array */
d89 1
a89 1
int biosdev;
d91 2
a92 2
char		*loadprotoblocks(char *, long *);
int		loadblocknums(char *, int, struct disklabel *);
d94 2
a96 1
static int	record_block(u_int8_t *, daddr_t, u_int, struct disklabel *);
d101 1
a101 2
	fprintf(stderr, "usage: %s [-n] [-v] [-s sec-per-track] [-h track-per-cyl] "
	    "boot biosboot device\n", __progname);
d105 5
d117 5
a121 9
	struct stat sb;
	struct disklabel dl;
	struct dos_mbr mbr;
	struct dos_partition *dp;
	off_t startoff = 0;
	int mib[4];
	size_t size;
	dev_t devno;
	bios_diskinfo_t di;
d123 1
a123 2
	nsectors = nheads = -1;
	while ((c = getopt(argc, argv, "vnh:s:")) != -1) {
a124 12
		case 'h':
			nheads = atoi(optarg);
			if (nheads < 1 || nheads > 256)
				errx(1, "invalid value for -h");
			userspec = 1;
			break;
		case 's':
			nsectors = atoi(optarg);
			if (nsectors < 1 || nsectors > 63)
				errx(1, "invalid value for -s");
			userspec = 1;
			break;
d126 1
a126 1
			/* Do not actually write the bootblock to disk */
d130 1
a130 1
			/* Chat */
d138 1
a138 1
	if (argc - optind < 3) {
a139 1
	}
d145 1
a145 1
	/* Open and check raw disk device */
d147 1
a147 1
			     OPENDEV_PART, &realdev)) < 0)
d159 1
a159 1
	/* check disklabel */
d163 1
a163 1
	/* warn on unknown disklabel types */
d167 2
a168 2
	/* Load proto blocks into core */
	if ((protostore = loadprotoblocks(proto, &protosize)) == NULL)
d175 1
a175 1
	/* Write patched proto bootblocks into the superblock */
d183 1
a183 1
		errx(1, "%s: Not a character device", realdev);
d185 3
a187 19
	if (nheads == -1 || nsectors == -1) {
		mib[0] = CTL_MACHDEP;
		mib[1] = CPU_CHR2BLK;
		mib[2] = sb.st_rdev;
		size = sizeof(devno);
		if(sysctl(mib, 3, &devno, &size, NULL, 0) >= 0) {
			devno = MAKEBOOTDEV(major(devno), 0, 0,
			    DISKUNIT(devno), RAW_PART);
			mib[0] = CTL_MACHDEP;
			mib[1] = CPU_BIOS;
			mib[2] = BIOS_DISKINFO;
			mib[3] = devno;
			size = sizeof(di);
			if(sysctl(mib, 4, &di, &size, NULL, 0) >= 0) {
				nheads = di.bios_heads;
				nsectors = di.bios_sectors;
			}
		}
	}
d189 2
a190 2
	if (nheads == -1 || nsectors == -1)
		errx(1, "Unable to get BIOS geometry, must specify -h and -s");
d192 4
a195 6
	/* Extract and load block numbers */
	if (loadblocknums(boot, devfd, &dl) != 0)
		exit(1);

	/* Sync filesystems (to clean in-memory superblock?) */
	sync(); sleep(1);
d207 2
a208 1
		for (dp = mbr.dmbr_parts; dp < &mbr.dmbr_parts[NDOSPART]; dp++) {
d212 4
a215 4
					"type %d (0x%02x) offset %d (0x%x)\n",
					(long)(dp - mbr.dmbr_parts),
					dp->dp_typ, dp->dp_typ,
					dp->dp_start, dp->dp_start);
d219 1
a219 1
		/* don't check for old part number, that is ;-p */
d235 5
a239 2
char *
loadprotoblocks(char *fname, long *size)
a243 1
	struct	nlist *nlp;
d248 2
a249 2
	fd = -1;
	bp = NULL;
d251 2
a252 13
	/* Locate block number array in proto file */
	if (nlist(fname, nl) != 0) {
		warnx("nlist: %s: symbols not found", fname);
		return NULL;
	}
	/* Validate symbol types (global data). */
	for (nlp = nl; nlp->n_un.n_name; nlp++) {
		if (nlp->n_type != (N_TEXT)) {
			warnx("nlist: %s: wrong type %x", nlp->n_un.n_name,
			nlp->n_type);
			return NULL;
		}
	}
d254 1
a254 9
	if ((fd = open(fname, O_RDONLY)) < 0) {
		warn("open: %s", fname);
		return NULL;
	}
	if (read(fd, &eh, sizeof(eh)) != sizeof(eh)) {
		warn("read: %s", fname);
		goto bad;
	}
	if (!IS_ELF(eh)) {
d256 3
a258 4
		boot,
		eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
	}
d266 5
a270 4
	/* program load header */
	if (eh.e_phnum != 1) {
		errx(1, "%s: only supports one ELF load section", boot);
	}
d273 3
a275 4
	if (ph == NULL) {
		errx(1, "%s: unable to allocate program header space",
		    boot);
	}
d278 2
a279 3
	if (read(fd, ph, phsize) != phsize) {
		errx(1, "%s: unable to read program header space", boot);
	}
d289 1
a289 2
		warnx("malloc: %s: no memory", fname);
		goto bad;
d291 1
d295 1
a295 2
		warn("read: %s", fname);
		goto bad;
a299 5
	/* Calculate the symbols' locations within the proto file */
	block_count_p = (u_int8_t *) (bp + nl[X_BLOCK_COUNT].n_value);
	block_table_p = (u_int8_t *) (bp + nl[X_BLOCK_TABLE].n_value);
	maxblocknum = *block_count_p;

a302 2
		fprintf(stderr, "room for %d filesystem blocks at %#lx\n",
			maxblocknum, nl[X_BLOCK_TABLE].n_value);
a306 7

 bad:
	if (bp)
		free(bp);
	if (fd >= 0)
		close(fd);
	return NULL;
d321 6
a326 2
int
loadblocknums(char *boot, int devfd, struct disklabel *dl)
d328 1
a328 1
	int		i, fd;
d337 1
a337 2
	u_int8_t	*bt;
	int mib[4];
d339 1
a339 1
	dev_t dev;
d342 5
a346 2
	 * Open 2nd-level boot program and record the block numbers
	 * it occupies on the filesystem represented by `devfd'.
d359 2
a360 3
	    strncmp(statfsbuf.f_fstypename, "ufs", MFSNAMELEN) ) {
		errx(1, "%s: must be on an FFS filesystem", boot);
	}
d363 1
a363 1
	if (read(fd, &eh, sizeof(eh)) != sizeof(eh)) {
a364 1
	}
d368 3
a370 3
		boot,
		eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
d383 1
a383 1
	/* check devices */
d388 1
a388 1
	if (sysctl(mib, 3, &dev, &size, NULL, 0) >= 0)
d391 1
d396 1
a396 1
	/* Read superblock */
d406 1
a406 1
	/* Read inode */
d408 1
a408 1
		errx(1, "No memory for filesystem block");
d411 1
d416 2
a417 1
	 * Have the inode.  Figure out how many blocks we need.
d423 2
a424 13
		fprintf(stderr, "Will load %d blocks of size %d each.\n",
			ndb, fs->fs_bsize);

	if ((dl->d_type != 0 && dl->d_type != DTYPE_FLOPPY &&
	    dl->d_type != DTYPE_VND) || userspec ) {
		/* adjust disklabel w/ synthetic geometry */
		dl->d_nsectors = nsectors;
		dl->d_secpercyl = dl->d_nsectors * nheads;
	}

	if (verbose)
		fprintf(stderr, "Using disk geometry of %u sectors and %u heads.\n",
			dl->d_nsectors, dl->d_secpercyl/dl->d_nsectors);
d427 2
a428 1
	 * Get the block numbers; we don't handle fragments
d430 6
d437 15
a451 23
	bt = block_table_p;
	for (i = 0; i < NDADDR && *ap && ndb; i++, ap++, ndb--) {
		bt += record_block(bt, pl->p_offset + fsbtodb(fs, *ap),
					    fs->fs_bsize / 512, dl);
		if ((bt - block_table_p) / 4 > maxblocknum)
			errx(1, "Too many blocks");
	}
	if (ndb != 0) {

		/*
		 * Just one level of indirections; there isn't much room
		 * for more in the 2nd-level /boot anyway.
		 */
		blk = fsbtodb(fs, ip->di_ib[0]);
		devread(devfd, buf, pl->p_offset + blk, fs->fs_bsize,
			"indirect block");
		ap = (daddr_t *)buf;
		for (; i < NINDIR(fs) && *ap && ndb; i++, ap++, ndb--) {
			bt += record_block(bt, pl->p_offset + fsbtodb(fs, *ap),
					   fs->fs_bsize / 512, dl);
			if ((bt - block_table_p) / 4 > maxblocknum)
				errx(1, "Too many blocks");
		}
d454 2
a455 7
	/* write out remaining piece */
	bt += record_block(bt, 0, 0, dl);
	/* and again */
	bt += record_block(bt, 0, 0, dl);
	*block_count_p = (bt - block_table_p) / 4;
	if (*block_count_p > maxblocknum)
		errx(1, "Too many blocks");
d457 2
a458 3
	if (verbose)
		fprintf(stderr, "%s: %d entries total\n",
			boot, *block_count_p);
d460 2
a461 1
	return 0;
d464 6
a469 2
static int
record_block(u_int8_t *bt, daddr_t blk, u_int bs, struct disklabel *dl)
d471 53
a523 2
	static u_int ss = 0, l = 0, i = 0; /* start and len of group */
	int ret = 0;
d525 1
a525 23
	/* printf("%u, %u\n", blk, bs); */
	if (ss == 0) { /* very beginning */
		ss = blk;
		l = bs;
		return 0;
	} else if (l == 0)
		return 0;

	/* record on track boundary or non-contig blocks or last call */
	if ((ss + l) != blk ||
	    (ss % dl->d_nsectors + l) >= dl->d_nsectors) {
		register u_int c = ss / dl->d_secpercyl,
			s = ss % dl->d_nsectors + 1;

		/* nsectors */
		if ((ss % dl->d_nsectors + l) >= dl->d_nsectors)
			bt[3] = dl->d_nsectors - s + 1;
		else
			bt[3] = l; /* non-contig or last block piece */

		bt[2] = (ss % dl->d_secpercyl) / dl->d_nsectors; /* head */
		*(u_int16_t *)bt = (s & 0x3f) | /* sect, cyl */
			((c & 0xff) << 8) | ((c & 0x300) >> 2);
d528 2
a529 18
			fprintf(stderr, "%2d: %2d @@(%d %d %d) (%d-%d)\n",
				i, bt[3], c, bt[2], s, ss, ss + bt[3] - 1);
		i++;

		ss += bt[3];
		l -= bt[3];
		if ((ss + l) != blk) {
			/* printf ("l=%u\n", l); */
		 	if (l)
				ret += record_block(bt + 4, 0, 0, dl);
			ss = blk;
			l = bs;
		} else
			l += bs;

		ret += 4;
	} else {
		l += bs;
a530 2

	return ret;
@


1.41
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.40 2003/08/15 21:17:27 deraadt Exp $	*/
d117 2
d123 2
@


1.40
log
@no newline in errx; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.39 2003/08/08 07:37:28 deraadt Exp $	*/
d381 1
a381 1
	struct dinode	*ip;
d457 1
a457 1
	ip = (struct dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);
@


1.39
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.38 2003/04/17 03:43:18 drahn Exp $	*/
d302 1
a302 1
		errx(1, "%s: only supports one ELF load section\n", boot);
d307 1
a307 1
		errx(1, "%s: unable to allocate program header space\n",
d310 1
a310 1
	lseek(fd,  eh.e_phoff, SEEK_SET);
d313 1
a313 1
		errx(1, "%s: unable to read program header space\n", boot);
@


1.38
log
@i386 ELF bootloader. developed with weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.37 2002/05/03 13:59:08 espie Exp $	*/
d88 1
a88 1
usage()
d96 1
a96 3
main(argc, argv)
	int argc;
	char *argv[];
d252 1
a252 3
loadprotoblocks(fname, size)
	char *fname;
	long *size;
d293 1
d360 1
a360 6
devread(fd, buf, blk, size, msg)
	int	fd;
	void	*buf;
	daddr_t	blk;
	size_t	size;
	char	*msg;
d372 1
a372 4
loadblocknums(boot, devfd, dl)
	char	*boot;
	int	devfd;
	struct disklabel *dl;
d525 1
a525 5
record_block(bt, blk, bs, dl)
	u_int8_t *bt;
	daddr_t blk;
	u_int bs;
	struct disklabel *dl;
@


1.37
log
@ptrdiff_t and size_t fixes.
okay mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.36 2002/03/14 01:26:34 millert Exp $	*/
d55 1
d174 1
a174 1
		err(1, "proto bootblock bad size=%ld", protosize);
d262 3
a264 1
	struct	exec eh;
d276 3
a278 2
		if (nlp->n_type != (N_TEXT | N_EXT)) {
			warnx("nlist: %s: wrong type", nlp->n_un.n_name);
d291 5
a295 3
	if (N_GETMAGIC(eh) != OMAGIC) {
		warn("bad magic: 0x%x", eh.a_midmag);
		goto bad;
d302 18
a319 1
	tdsize = eh.a_text + eh.a_data;
d331 1
d345 1
a345 1
		fprintf(stderr, "%s: entry point %#x\n", fname, eh.a_entry);
a394 1
	struct exec	eh;
d418 1
d423 5
a427 2
	if (N_GETMAGIC(eh) != ZMAGIC) {
		errx(1, "%s: bad magic: 0x%x", boot, eh.a_midmag);
d429 1
@


1.36
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.35 2001/11/06 19:53:14 miod Exp $	*/
d108 2
a109 1
	int mib[4], size;
d228 1
a228 1
				fprintf(stderr, "using MBR partition %d: "
d230 1
a230 1
					dp - mbr.dmbr_parts,
d372 2
a373 1
	int mib[4], size;
@


1.35
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.34 1999/05/23 17:19:22 aaron Exp $	*/
d80 5
a84 6
char		*loadprotoblocks __P((char *, long *));
int		loadblocknums __P((char *, int, struct disklabel *));
static void	devread __P((int, void *, daddr_t, size_t, char *));
static void	usage __P((void));
static int	record_block
	__P((u_int8_t *, daddr_t, u_int, struct disklabel *));
@


1.35.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.35 2001/11/06 19:53:14 miod Exp $	*/
d80 6
a85 5
char		*loadprotoblocks(char *, long *);
int		loadblocknums(char *, int, struct disklabel *);
static void	devread(int, void *, daddr_t, size_t, char *);
static void	usage(void);
static int	record_block(u_int8_t *, daddr_t, u_int, struct disklabel *);
d109 1
a109 2
	int mib[4];
	size_t size;
d228 1
a228 1
				fprintf(stderr, "using MBR partition %ld: "
d230 1
a230 1
					(long)(dp - mbr.dmbr_parts),
d372 1
a372 2
	int mib[4];
	size_t		size;
@


1.35.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a54 1
#include <sys/exec_elf.h>
d173 1
a173 1
		err(1, "proto %s bad size=%ld", proto, protosize);
d261 1
a261 3
	Elf_Ehdr eh;
	Elf_Word phsize;
	Elf_Phdr *ph;
d273 2
a274 3
		if (nlp->n_type != (N_TEXT)) {
			warnx("nlist: %s: wrong type %x", nlp->n_un.n_name,
			nlp->n_type);
d287 3
a289 5
	if (!IS_ELF(eh)) {
		errx(1, "%s: bad magic: 0x%02x%02x%02x%02x",
		boot,
		eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
d296 1
a296 18

	/* program load header */
	if (eh.e_phnum != 1) {
		errx(1, "%s: only supports one ELF load section\n", boot);
	}
	phsize = eh.e_phnum * sizeof(Elf_Phdr);
	ph = malloc(phsize);
	if (ph == NULL) {
		errx(1, "%s: unable to allocate program header space\n",
		    boot);
	}
	lseek(fd,  eh.e_phoff, SEEK_SET);

	if (read(fd, ph, phsize) != phsize) {
		errx(1, "%s: unable to read program header space\n", boot);
	}

	tdsize = ph->p_filesz;
a307 1
	lseek(fd, ph->p_offset, SEEK_SET);
d321 1
a321 1
		fprintf(stderr, "%s: entry point %#x\n", fname, eh.e_entry);
d371 1
a394 1
#if 0
d399 2
a400 5
	if (!IS_ELF(eh)) {
		errx(1, "%s: bad magic: 0x%02x%02x%02x%02x",
		boot,
		eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
a401 1
#endif
@


1.34
log
@getopt(3) returns -1, not EOF
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.33 1998/12/16 03:04:09 mickey Exp $	*/
d47 1
a47 1
#include <vm/vm.h>
@


1.34.4.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
#include <uvm/uvm_extern.h>
@


1.34.4.2
log
@Merge in -current from about a week ago
@
text
@d80 6
a85 5
char		*loadprotoblocks(char *, long *);
int		loadblocknums(char *, int, struct disklabel *);
static void	devread(int, void *, daddr_t, size_t, char *);
static void	usage(void);
static int	record_block(u_int8_t *, daddr_t, u_int, struct disklabel *);
@


1.34.4.3
log
@Sync the SMP branch with 3.3
@
text
@d108 1
a108 2
	int mib[4];
	size_t size;
d227 1
a227 1
				fprintf(stderr, "using MBR partition %ld: "
d229 1
a229 1
					(long)(dp - mbr.dmbr_parts),
d371 1
a371 2
	int mib[4];
	size_t		size;
@


1.34.4.4
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.34.4.3 2003/03/27 23:26:56 niklas Exp $	*/
a54 1
#include <sys/exec_elf.h>
d173 1
a173 1
		err(1, "proto %s bad size=%ld", proto, protosize);
d261 1
a261 3
	Elf_Ehdr eh;
	Elf_Word phsize;
	Elf_Phdr *ph;
d273 2
a274 3
		if (nlp->n_type != (N_TEXT)) {
			warnx("nlist: %s: wrong type %x", nlp->n_un.n_name,
			nlp->n_type);
d287 3
a289 5
	if (!IS_ELF(eh)) {
		errx(1, "%s: bad magic: 0x%02x%02x%02x%02x",
		boot,
		eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
d296 1
a296 18

	/* program load header */
	if (eh.e_phnum != 1) {
		errx(1, "%s: only supports one ELF load section\n", boot);
	}
	phsize = eh.e_phnum * sizeof(Elf_Phdr);
	ph = malloc(phsize);
	if (ph == NULL) {
		errx(1, "%s: unable to allocate program header space\n",
		    boot);
	}
	lseek(fd,  eh.e_phoff, SEEK_SET);

	if (read(fd, ph, phsize) != phsize) {
		errx(1, "%s: unable to read program header space\n", boot);
	}

	tdsize = ph->p_filesz;
a307 1
	lseek(fd, ph->p_offset, SEEK_SET);
d321 1
a321 1
		fprintf(stderr, "%s: entry point %#x\n", fname, eh.e_entry);
d371 1
a394 1
#if 0
d399 2
a400 5
	if (!IS_ELF(eh)) {
		errx(1, "%s: bad magic: 0x%02x%02x%02x%02x",
		boot,
		eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
a401 1
#endif
@


1.34.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a4 1
 * Copyright (c) 2003 Tom Cosgrove <tom.cosgrove@@arches-consulting.com>
a63 7
struct	sym_data {
	char		*sym_name;		/* Must be initialised */
	int		sym_size;		/* And this one */
	int		sym_set;		/* Rest set at runtime */
	u_int32_t	sym_value;
};

d65 1
a65 1
int	verbose, nowrite = 0;
d67 6
a72 9
struct sym_data pbr_symbols[] = {
	{"_fs_bsize_p",	2},
	{"_fs_bsize_s",	2},
	{"_fsbtodb",	1},
	{"_p_offset",	4},
	{"_inodeblk",	4},
	{"_inodedbl",	4},
	{"_nblocks",	2},
	{NULL}
d75 3
a77 2
#define INODESEG	0x07e0	/* where we will put /boot's inode's block */
#define BOOTSEG		0x07c0	/* biosboot loaded here */
d79 1
a79 1
#define INODEOFF  ((INODESEG-BOOTSEG) << 4)
d81 2
a82 2
static char	*loadproto(char *, long *);
static int	getbootparams(char *, int, struct disklabel *);
a83 2
static void	sym_set_value(struct sym_data *, char *, u_int32_t);
static void	pbr_set_symbols(char *, char *, struct sym_data *);
d85 1
d88 1
a88 1
usage(void)
d90 2
a91 1
	fprintf(stderr, "usage: %s [-nv] boot biosboot device\n", __progname);
a94 5
/*
 * Read information about /boot's inode and filesystem parameters, then
 * put biosboot (partition boot record) on the target drive with these
 * parameters patched in.
 */
d96 3
a98 1
main(int argc, char *argv[])
d104 9
a112 5
	struct	stat sb;
	struct	disklabel dl;
	struct	dos_mbr mbr;
	struct	dos_partition *dp;
	off_t	startoff = 0;
d114 2
a115 1
	while ((c = getopt(argc, argv, "vn")) != -1) {
d117 8
d126 1
a126 1
			/* Do not actually write the bootblock to disk. */
d130 1
a130 1
			/* Give more information. */
d138 1
a138 1
	if (argc - optind < 3)
d140 1
d146 1
a146 1
	/* Open and check raw disk device. */
d148 1
a148 1
	    OPENDEV_PART, &realdev)) < 0)
d160 1
a160 1
	/* Check disklabel. */
d164 1
a164 1
	/* Warn on unknown disklabel types. */
d168 2
a169 2
	/* Load proto blocks into core. */
	if ((protostore = loadproto(proto, &protosize)) == NULL)
d176 1
a176 1
	/* Write patched proto bootblock(s) into the superblock. */
d184 1
a184 1
		errx(1, "%s: not a character device", realdev);
d186 25
a210 2
	/* Get bootstrap parameters that are to be patched into proto. */
	if (getbootparams(boot, devfd, &dl) != 0)
d213 2
a214 7
	/* Patch the parameters into the proto bootstrap sector. */
	pbr_set_symbols(proto, protostore, pbr_symbols);

	if (!nowrite) {
		/* Sync filesystems (to clean in-memory superblock?). */
		sync(); sleep(1);
	}
d226 1
a226 2
		for (dp = mbr.dmbr_parts; dp < &mbr.dmbr_parts[NDOSPART];
		    dp++) {
d230 4
a233 4
				    "type %d (0x%02x) offset %d (0x%x)\n",
				    (long)(dp - mbr.dmbr_parts),
				    dp->dp_typ, dp->dp_typ,
				    dp->dp_start, dp->dp_start);
d237 1
a237 1
		/* Don't check for old part number, that is ;-p */
d253 4
a256 5
/*
 * Load the prototype boot sector (biosboot) into memory.
 */
static char *
loadproto(char *fname, long *size)
d261 1
d266 2
a267 2
	if ((fd = open(fname, O_RDONLY)) < 0)
		err(1, "%s", fname);
d269 13
a281 2
	if (read(fd, &eh, sizeof(eh)) != sizeof(eh))
		errx(1, "%s: read failed", fname);
d283 9
a291 1
	if (!IS_ELF(eh))
d293 4
a296 4
		    boot,
		    eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		    eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);

d303 4
a306 5
	/* Program load header. */
	if (eh.e_phnum != 1)
		errx(1, "%s: %u ELF load sections (only support 1)",
		    boot, eh.e_phnum);

d309 5
a313 2
	if (ph == NULL)
		err(1, NULL);
d315 3
a317 4
	lseek(fd, eh.e_phoff, SEEK_SET);

	if (read(fd, ph, phsize) != phsize)
		errx(1, "%s: can't read header", boot);
d327 2
a328 1
		err(1, NULL);
a329 1

d333 2
a334 1
		errx(1, "%s: read failed", fname);
d339 5
d347 2
d353 7
d363 6
a368 1
devread(int fd, void *buf, daddr_t blk, size_t size, char *msg)
d379 5
a383 6
/*
 * Read information about /boot's inode, then put this and filesystem
 * parameters from the superblock into pbr_symbols.
 */
static int
getbootparams(char *boot, int devfd, struct disklabel *dl)
d385 1
a385 1
	int		fd;
d392 1
a392 1
	struct ufs1_dinode	*ip;
d394 2
a395 1
	int		mib[4];
d397 1
a397 1
	dev_t		dev;
d400 2
a401 5
	 * Open 2nd-level boot program and record enough details about
	 * where it is on the filesystem represented by `devfd'
	 * (inode block, offset within that block, and various filesystem
	 * parameters essentially taken from the superblock) for biosboot
	 * to be able to load it later.
d414 3
a416 2
	    strncmp(statfsbuf.f_fstypename, "ufs", MFSNAMELEN) )
		errx(1, "%s: not on an FFS filesystem", boot);
d419 1
a419 1
	if (read(fd, &eh, sizeof(eh)) != sizeof(eh))
d421 1
d425 3
a427 3
		    boot,
		    eh.e_ident[EI_MAG0], eh.e_ident[EI_MAG1],
		    eh.e_ident[EI_MAG2], eh.e_ident[EI_MAG3]);
d440 1
a440 1
	/* Check devices. */
d445 1
a445 1
	if (sysctl(mib, 3, &dev, &size, NULL, 0) >= 0) {
a447 1
	}
d452 1
a452 1
	/* Read superblock. */
d462 1
a462 1
	/* Read inode. */
d464 1
a464 1
		err(1, NULL);
a466 1

d468 1
a468 1
	ip = (struct ufs1_dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);
d471 1
a471 2
	 * Have the inode.  Figure out how many filesystem blocks (not disk
	 * sectors) there are for biosboot to load.
d477 13
a489 2
		fprintf(stderr, "%s is %d blocks x %d bytes\n",
		    boot, ndb, fs->fs_bsize);
d492 1
a492 2
	 * Now set the values that will need to go into biosboot
	 * (the partition boot record, a.k.a. the PBR).
a493 6
	sym_set_value(pbr_symbols, "_fs_bsize_p", (fs->fs_bsize / 16));
	sym_set_value(pbr_symbols, "_fs_bsize_s", (fs->fs_bsize / 512));
	sym_set_value(pbr_symbols, "_fsbtodb", fs->fs_fsbtodb);
	sym_set_value(pbr_symbols, "_p_offset", pl->p_offset);
	sym_set_value(pbr_symbols, "_inodeblk",
	    ino_to_fsba(fs, statbuf.st_ino));
d495 23
a517 15
	sym_set_value(pbr_symbols, "_inodedbl",
	    ((((char *)ap) - buf) + INODEOFF));
	sym_set_value(pbr_symbols, "_nblocks", ndb);

	return 0;
}

static void
sym_set_value(struct sym_data *sym_list, char *sym, u_int32_t value)
{
	struct sym_data *p;

	for (p = sym_list; p->sym_name != NULL; p++) {
		if (strcmp(p->sym_name, sym) == 0)
			break;
d520 7
a526 2
	if (p->sym_name == NULL)
		errx(1, "%s: no such symbol", sym);
d528 3
a530 2
	if (p->sym_set)
		errx(1, "%s already set", p->sym_name);
d532 1
a532 2
	p->sym_value = value;
	p->sym_set = 1;
d535 6
a540 6
/*
 * Write the parameters stored in sym_list into the in-memory copy of
 * the prototype biosboot (proto), ready for it to be written to disk.
 */
static void
pbr_set_symbols(char *fname, char *proto, struct sym_data *sym_list)
d542 2
a543 53
	struct sym_data *sym;
	struct nlist	*nl;
	char		*vp;
	u_int32_t	*lp;
	u_int16_t	*wp;
	u_int8_t	*bp;

	for (sym = sym_list; sym->sym_name != NULL; sym++) {
		if (!sym->sym_set)
			errx(1, "%s not set", sym->sym_name);

		/* Allocate space for 2; second is null-terminator for list. */
		nl = calloc(2, sizeof(struct nlist));
		if (nl == NULL)
			err(1, NULL);

		nl->n_un.n_name = sym->sym_name;

		if (nlist(fname, nl) != 0)
			errx(1, "%s: symbol %s not found",
			    fname, sym->sym_name);

		if (nl->n_type != (N_TEXT))
			errx(1, "%s: %s: wrong type (%x)",
			    fname, sym->sym_name, nl->n_type);

		/* Get a pointer to where the symbol's value needs to go. */
		vp = proto + nl->n_value;

		switch (sym->sym_size) {
		case 4:					/* u_int32_t */
			lp = (u_int32_t *) vp;
			*lp = sym->sym_value;
			break;
		case 2:					/* u_int16_t */
			if (sym->sym_value >= 0x10000)	/* out of range */
				errx(1, "%s: symbol out of range (%u)",
				    sym->sym_name, sym->sym_value);
			wp = (u_int16_t *) vp;
			*wp = (u_int16_t) sym->sym_value;
			break;
		case 1:					/* u_int16_t */
			if (sym->sym_value >= 0x100)	/* out of range */
				errx(1, "%s: symbol out of range (%u)",
				    sym->sym_name, sym->sym_value);
			bp = (u_int8_t *) vp;
			*bp = (u_int8_t) sym->sym_value;
			break;
		default:
			errx(1, "%s: bad symbol size %d",
			    sym->sym_name, sym->sym_size);
			/* NOTREACHED */
		}
d545 23
a567 1
		free(nl);
d570 18
a587 2
			fprintf(stderr, "%s = %u\n",
			    sym->sym_name, sym->sym_value);
d589 2
@


1.34.4.6
log
@Merge with the trunk
@
text
@d173 1
a173 1
		errx(1, "proto %s bad size=%ld", proto, protosize);
d422 3
a440 10
	if (verbose) {
		fprintf(stderr, "%s is %d blocks x %d bytes\n",
		    boot, ndb, fs->fs_bsize);
		fprintf(stderr, "fs block shift %u; part offset %u; "
		    "inode block %u, offset %u\n",
		    fs->fs_fsbtodb, pl->p_offset,
		    ino_to_fsba(fs, statbuf.st_ino),
		    ((((char *)ap) - buf) + INODEOFF));
	}

d526 4
@


1.33
log
@cast multipliers in boot record byte offset calculation to
off_t to avoid overflow for partitions starting at high cylinders.
spotted and tested by WHS <wouters@@cistron.nl>, 10x!
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.32 1998/04/25 18:32:35 millert Exp $	*/
d114 1
a114 1
	while ((c = getopt(argc, argv, "vnh:s:")) != EOF) {
@


1.32
log
@fix some more printf's where a long arg was specified that is u_int32_t
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.31 1998/04/20 07:25:15 mickey Exp $	*/
d227 1
a227 1
				startoff = dp->dp_start * dl.d_secsize;
@


1.31
log
@fix the problem w/ /boot being fragmented in a non-contig
blocks. fixed by flushing the previous blocks completely
before starting new record for a new block(s) location.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.30 1998/04/18 07:39:38 deraadt Exp $	*/
d288 1
a288 1
		warn("bad magic: 0x%lx", eh.a_midmag);
d321 1
a321 1
		fprintf(stderr, "%s: entry point %#lx\n", fname, eh.a_entry);
d399 1
a399 1
		errx(1, "%s: bad magic: 0x%lx", boot, eh.a_midmag);
@


1.30
log
@i386 bootblocks that work for 2.3. A tale too long to tell
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.29 1998/04/02 10:50:31 deraadt Exp $	*/
d461 1
d516 1
d543 1
d545 6
a550 5
		if ((ss % dl->d_nsectors + l) >= dl->d_nsectors) {
			ss += bt[3];
			l -= bt[3];
			l += bs;
		} else {
d553 2
a554 1
		}
d556 1
a556 2
		i++;
		ret = 4;
@


1.30.2.1
log
@fix release branch:
fix the problem w/ /boot being fragmented in a non-contig
blocks. fixed by flushing the previous blocks completely
before starting new record for a new block(s) location.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.31 1998/04/20 07:25:15 mickey Exp $	*/
a460 1

a514 1
	/* printf("%u, %u\n", blk, bs); */
a540 1
		i++;
d542 5
a546 6
		ss += bt[3];
		l -= bt[3];
		if ((ss + l) != blk) {
			/* printf ("l=%u\n", l); */
		 	if (l)
				ret += record_block(bt + 4, 0, 0, dl);
d549 1
a549 2
		} else
			l += bs;
d551 2
a552 1
		ret += 4;
@


1.29
log
@remove the last uses of spt and tpc
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.28 1998/03/11 15:36:44 deraadt Exp $	*/
a446 2
	if (ndb > maxblocknum)
		errx(1, "Too many blocks");
d466 1
a466 1
	for (i = 0; i < NDADDR && *ap && ndb; i++, ap++, ndb--)
d469 3
d482 1
a482 1
		for (; i < NINDIR(fs) && *ap && ndb; i++, ap++, ndb--)
d485 3
d495 2
@


1.28
log
@make usage message much prettier
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.27 1998/03/01 21:58:12 weingart Exp $	*/
d461 1
a461 1
		fprintf(stderr, "Using disk geometry of %u spt and %u tpc.\n",
@


1.27
log
@Fix int overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.26 1997/10/28 10:06:34 deraadt Exp $	*/
d90 2
a91 2
	fprintf(stderr, "usage: %s [-n] [-v] [-s <spt>] [-h <tpc>] "
		"<boot> <proto> <device>\n", __progname);
@


1.26
log
@use RAW_PART, not 0
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.25 1997/10/26 02:41:19 mickey Exp $	*/
d346 1
a346 1
	if (lseek(fd, dbtob(blk), SEEK_SET) != dbtob(blk))
@


1.25
log
@don't freak out on old kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.24 1997/10/25 23:42:37 mickey Exp $	*/
d191 2
a192 2
			devno = MAKEBOOTDEV(major(devno),0,0,DISKUNIT(devno),0);

@


1.24
log
@fix install on unit!=0
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.23 1997/10/25 23:04:05 mickey Exp $	*/
d190 2
a191 3
		if(sysctl(mib, 3, &devno, &size, NULL, 0) < 0)
			err(1, "mapping device number");
		devno = MAKEBOOTDEV(major(devno), 0, 0, DISKUNIT(devno), 0);
d193 10
a202 10
		mib[0] = CTL_MACHDEP;
		mib[1] = CPU_BIOS;
		mib[2] = BIOS_DISKINFO;
		mib[3] = devno;
		size = sizeof(di);
		if(sysctl(mib, 4, &di, &size, NULL, 0) < 0)
			errx(1, "Unable to get BIOS geometry, "
				"must specify -h and -s");
		nheads = di.bios_heads;
		nsectors = di.bios_sectors;
d205 3
d410 2
d416 3
a418 4
	if (sysctl(mib, 3, &dev, &size, NULL, 0) < 0)
		err(1, "can't map device number");
	if (statbuf.st_dev / MAXPARTITIONS != dev / MAXPARTITIONS)
		errx(1, "cross-device install");
@


1.23
log
@use geometry
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.22 1997/10/24 00:53:30 mickey Exp $	*/
d192 1
a192 1
		devno = MAKEBOOTDEV(major(devno), 0, 0, minor(devno), 0);
@


1.22
log
@use real boot device
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.21 1997/10/22 23:34:41 mickey Exp $	*/
d45 1
d110 2
a149 28
	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_BIOS;
	mib[2] = BIOS_DEV;
	size = sizeof(biosdev);

	if ((nheads == -1 || nsectors == -1) &&
	    sysctl(mib, 3, &biosdev, &size, NULL, 0) != -1) {

		if (biosdev & 0x80) {
			bios_diskinfo_t di;

			mib[2] = BIOS_DISKINFO;
			mib[3] = biosdev;
			size = sizeof(di);

			if (sysctl(mib, 4, &di, &size, NULL, 0) == -1)
				err(1, "sysctl");

			if (nheads == -1)
				nheads = di.bios_heads;
			if (nsectors == -1)
				nsectors = di.bios_sectors;
		}
	}

	if (nheads == -1 || nsectors == -1)
		errx(1, "Unable to get BIOS geometry, must specify -h and -s");

d185 21
d370 2
d408 8
a415 4

	printf("%x,%x\n", statbuf.st_dev/MAXPARTITIONS, major(sb.st_rdev));
	if (statbuf.st_rdev / MAXPARTITIONS != sb.st_rdev / MAXPARTITIONS)
		/* errx(1, "cross-device install") */;
@


1.21
log
@newer, better stuff; some parts by toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.20 1997/10/15 15:54:52 weingart Exp $	*/
d159 1
a159 1
			mib[3] = 0xa0000004;
@


1.20
log
@Honour users request for geo all the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.19 1997/10/12 19:39:48 weingart Exp $	*/
d5 1
d142 5
d156 1
a156 1
			u_int geo;
d158 3
a160 2
			mib[2] = BIOS_GEOMETRY;
			size = sizeof(geo);
d162 1
a162 1
			if (sysctl(mib, 3, &geo, &size, NULL, 0) == -1)
d166 1
a166 1
				nheads = BIOSNHEADS(geo);
d168 1
a168 1
				nsectors = BIOSNSECTS(geo);
a174 5
	/* Open and check raw disk device */
	if ((devfd = opendev(dev, (nowrite? O_RDONLY:O_RDWR),
			     OPENDEV_PART, &realdev)) < 0)
		err(1, "open: %s", realdev);

d217 2
a218 1
	if (dl.d_type != 0 && dl.d_type < DTYPE_FLOPPY) {
d364 1
a364 1
	struct stat	statbuf;
d407 7
@


1.19
log
@One more sanity check.  If no blocks to load,
complain bitterly.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.18 1997/10/07 08:56:18 mickey Exp $	*/
d62 1
a62 1
int	verbose, nowrite, nheads, nsectors;
d114 1
d118 1
d438 2
a439 2
	if (dl->d_type != 0 && dl->d_type != DTYPE_FLOPPY &&
	    dl->d_type != DTYPE_VND ) {
@


1.18
log
@better fix for floppy boot
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.17 1997/10/03 21:36:07 deraadt Exp $	*/
d428 2
@


1.17
log
@if we booted from the floppy, the geometry is for the hard disk
bail completely if the geometry information is not available
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.16 1997/10/03 20:58:06 deraadt Exp $	*/
d147 1
a147 1
		if (biosdev == 0 || (biosdev & 0x80)) {
d434 2
a435 1
	if (dl->d_type != 0 && dl->d_type < DTYPE_FLOPPY) {
@


1.16
log
@avoid sign extension on bios geometry!
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.15 1997/09/30 22:10:50 deraadt Exp $	*/
d147 1
a147 1
		if (biosdev & 0x80) {
d161 3
a163 1
	} else if (nheads == -1 || nsectors == -1)
@


1.15
log
@fix sysctl() call. This code was never tested was it
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.14 1997/09/30 21:59:43 millert Exp $	*/
d142 1
a142 1
	size = sizeof(int);
d148 1
a148 1
			int geo;
d151 1
a151 1
			size = sizeof(int);
@


1.14
log
@Don't blithely use geometry from the disk.  Get it from sysctl or
the user.
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.13 1997/09/24 23:10:03 mickey Exp $	*/
d145 1
a145 1
	    sysctl(mib, 2, &biosdev, &size, NULL, 0) != -1) {
d153 1
a153 1
			if (sysctl(mib, 2, &geo, &size, NULL, 0) == -1)
@


1.13
log
@avoid bogus warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.12 1997/09/21 23:15:59 mickey Exp $	*/
d161 2
a162 1
	}
d434 2
a435 4
		if (nsectors > 0)
			dl->d_nsectors = nsectors;
		if (nheads > 0)
			dl->d_secpercyl = dl->d_nsectors * nheads;
@


1.12
log
@machdep.bios
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.11 1997/09/14 01:15:23 mickey Exp $	*/
d62 1
a62 1
int	verbose, nowrite, heads, nsectors;
a75 1
#ifdef CPU_BIOS
a76 1
#endif
d107 1
d109 1
a109 1
	nsectors = heads = -1;
d113 1
a113 1
			heads = atoi(optarg);
d139 4
a142 8
#ifdef CPU_BIOS
	if (heads == -1 || nsectors == -1) {
		int mib[3], size;

		mib[0] = CTL_MACHDEP;
		mib[1] = CPU_BIOS;
		mib[2] = BIOS_DEV;
		size = sizeof(int);
d144 2
a145 2
		if (sysctl(mib, 2, &biosdev, &size, NULL, 0) == -1)
			err(1, "sysctl");
d156 4
a159 2
			heads = BIOSNHEADS(geo);
			nsectors = BIOSNSECTS(geo);
a161 1
#endif
d435 2
a436 2
		if (heads > 0)
			dl->d_secpercyl = dl->d_nsectors * heads;
@


1.11
log
@print used geometry when verbose
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.10 1997/09/04 22:36:23 mickey Exp $	*/
d76 1
a76 1
#ifdef CPU_BIOSDEV
d140 1
a140 1
#ifdef CPU_BIOSDEV
d145 2
a146 1
		mib[1] = CPU_BIOSDEV;
d155 1
a155 1
			mib[1] = CPU_BIOSGEOMETRY;
@


1.10
log
@warn about unknown disklabel types, doc it in BUGS
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.9 1997/09/02 19:13:18 mickey Exp $	*/
d442 3
@


1.9
log
@sync usage() to man
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.8 1997/08/30 02:13:48 mickey Exp $	*/
d183 4
@


1.8
log
@don't muck w/ MBR on !hd
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.7 1997/08/29 20:08:36 mickey Exp $	*/
d61 1
d90 2
a91 2
	fprintf(stderr,
		"usage: installboot [-n] [-v] <boot> <proto> <device>\n");
@


1.7
log
@install on raw partition
accept short device names (ie sd0)
print -v output on stderr
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.6 1997/08/23 14:31:49 mickey Exp $	*/
d107 1
d208 19
a226 16
	if (lseek(devfd, (off_t)DOSBBSECTOR, SEEK_SET) < 0 ||
	    read(devfd, &mbr, sizeof(mbr)) < sizeof(mbr))
		err(4, "can't read master boot record");

	if (mbr.dmbr_sign != DOSMBR_SIGNATURE)
		errx(1, "broken MBR");

	/* Find OpenBSD partition. */
	for (dp = mbr.dmbr_parts; dp < &mbr.dmbr_parts[NDOSPART]; dp++) {
		if (dp->dp_size && dp->dp_typ == DOSPTYP_OPENBSD) {
			fprintf(stderr, "using MBR partition %d: "
				"type %d (0x%02x) offset %d (0x%x)\n",
				dp - mbr.dmbr_parts,
				dp->dp_typ, dp->dp_typ,
				dp->dp_start, dp->dp_start);
			break;
d228 3
a231 3
	/* don't check for old part number, that is ;-p */
	if (dp >= &mbr.dmbr_parts[NDOSPART])
		errx(1, "no OpenBSD partition");
d234 1
a234 1
		if (lseek(devfd, dp->dp_start * dl.d_secsize, SEEK_SET) < 0 ||
@


1.6
log
@don't use bios geometry for floppy and psudo-disks
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.5 1997/08/22 20:03:17 mickey Exp $	*/
d59 1
d62 1
a62 1
char	*boot, *proto, *dev;
d73 1
a73 1
int	maxblocknum;	/* size of this array */
d80 1
a80 1
int		loadblocknums __P((char *, int));
d104 3
d136 1
a136 7
	dev = argv[optind + 2];

	if (verbose) {
		printf("boot: %s\n", boot);
		printf("proto: %s\n", proto);
		printf("device: %s\n", dev);
	}
d164 18
d190 3
a192 3
	/* Open and check raw disk device */
	if ((devfd = open(dev, O_RDONLY, 0)) < 0)
		err(1, "open: %s", dev);
d195 1
a195 1
		err(1, "stat: %s", dev);
d198 1
a198 1
		errx(1, "%s: Not a character device", dev);
d201 1
a201 1
	if (loadblocknums(boot, devfd) != 0)
d204 2
a205 1
	(void)close(devfd);
d207 27
a233 2
	if (nowrite)
		return 0;
d235 1
a235 9
	/* Write patched proto bootblocks into the superblock */
	if (protosize > SBSIZE - DEV_BSIZE)
		errx(1, "proto bootblocks too big");

	if ((devfd = open(dev, (nowrite? O_RDONLY:O_RDWR), 0)) < 0)
		err(1, "open: %s", dev);

	/* Sync filesystems (to clean in-memory superblock?) */
	sync();
a236 3
	if (write(devfd, protostore, protosize) != protosize)
		err(1, "write bootstrap");
	(void)close(devfd);
d309 3
a311 3
		printf("%s: entry point %#lx\n", fname, eh.a_entry);
		printf("proto bootblock size %ld\n", *size);
		printf("room for %d filesystem blocks at %#lx\n",
d344 1
a344 1
loadblocknums(boot, devfd)
d347 1
a351 1
	struct disklabel dl;
a368 13
	if (ioctl(devfd, DIOCGDINFO, &dl) != 0)
		err(1, "disklabel: %s", dev);

	/* check disklabel */
	if (dl.d_magic != DISKMAGIC)
		err(1, "bad disklabel magic=%0x8x", dl.d_magic);

	/* get partition pointer */
	if (fstat(devfd, &statbuf) < 0)
		err(1, "stat: %s", dev);

	pl = &dl.d_partitions[DISKPART(statbuf.st_rdev)];

d394 1
d398 1
a398 1
	devread(devfd, sblock, SBLOCK, SBSIZE, "superblock");
d412 1
a412 1
	devread(devfd, buf, blk, fs->fs_bsize, "inode");
d422 2
a423 2
		printf("Will load %d blocks of size %d each.\n",
			   ndb, fs->fs_bsize);
d425 1
a425 1
	if (dl.d_type != 0 && dl.d_type < DTYPE_FLOPPY) {
d428 1
a428 1
			dl.d_nsectors = nsectors;
d430 1
a430 1
			dl.d_secpercyl = dl.d_nsectors * heads;
d440 1
a440 1
					    fs->fs_bsize / 512, &dl);
d448 2
a449 1
		devread(devfd, buf, blk, fs->fs_bsize, "indirect block");
d453 1
a453 1
					   fs->fs_bsize / 512, &dl);
d457 1
a457 1
	bt += record_block(bt, 0, 0, &dl);
d459 1
a459 1
	bt += record_block(bt, 0, 0, &dl);
d463 2
a464 1
		printf("%s: %d entries total\n", boot, *block_count_p);
d503 2
a504 2
			printf("%2d: %2d @@(%d %d %d) (%d-%d)\n",
			       i, bt[3], c, bt[2], s, ss, ss + bt[3] - 1);
@


1.5
log
@fetch bios geometry for the boot hd
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.4 1997/07/17 22:47:01 mickey Exp $	*/
d406 7
a412 5
	/* adjust disklabel w/ synthetic geometry */
	if (nsectors > 0)
		dl.d_nsectors = nsectors;
	if (heads > 0)
		dl.d_secpercyl = dl.d_nsectors * heads;
@


1.4
log
@take partition in an account
add -h -s, to fake BIOS geometry
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.3 1997/03/31 23:06:24 mickey Exp $	*/
d44 7
d74 3
d139 26
@


1.3
log
@commit all my mods to the last imported libsa stuff....
including:
- disklabel support;
- better boot cmd line
- smaller size (using some compilation switches ;)
- no more relocations in /boot, it's loaded in the place;
- better disk performance (maybe were already in there)
- installboot -n does not require write perms for device
- more debugs
- missing parts in libsa (such as cd9660 and so)
- i don't like 2 files for exec_i386 (sorry, toby, let's discuss maybe?)
tricks and tails:
- joined .text and .data (saves you a page)
- prot mode switching still in biosboot (it's freezed for awhile)
- biosdisk internals changed
- biosdev is not passed propery to the kernel (i'll fix it soon)
- sure i missed smth here to note (use the source, Luke!)
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.1.2.3 1996/12/16 15:21:15 mickey Exp $	*/
d53 1
a53 1
int	verbose, nowrite;
d92 1
d94 2
a95 1
	while ((c = getopt(argc, argv, "vn")) != EOF) {
d97 6
d142 6
d278 2
a279 2
char	*boot;
int	devfd;
d285 1
d309 6
d370 6
d382 1
a382 1
		bt += record_block(bt, fsbtodb(fs, *ap),
d388 1
a388 1
		 * for more in the 1st-level bootblocks anyway.
d394 1
a394 1
			bt += record_block(bt, fsbtodb(fs, *ap),
@


1.2
log
@Initial /boot stuff (from Mickey)
@
text
@d147 1
a147 1
	if ((devfd = open(dev, O_RDWR, 0)) < 0)
@


1.1
log
@file installboot.c was initially added on branch new.
@
text
@d1 436
@


1.1.2.1
log
@new hierarchy. raw /boot loading, just 1(one) boot stage.
@
text
@a0 449
/*	$OpenBSD$	*/
/*	$NetBSD: installboot.c,v 1.5 1995/11/17 23:23:50 gwr Exp $ */

/*
 * Copyright (c) 1994 Paul Kranenburg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Paul Kranenburg.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/mount.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/disklabel.h>
#include <sys/dkio.h>
#include <sys/ioctl.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ffs/fs.h>
#include <err.h>
#include <a.out.h>
#include <fcntl.h>
#include <nlist.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

int	verbose, nowrite;
char	*boot, *proto, *dev;
struct nlist nl[] = {
#define X_BLOCK_COUNT	0
	{"_block_count"},
#define X_BLOCK_TABLE	1
	{"_block_table"},
#define X_ENTRY_POINT	2
	{"_entry_point"},
	{NULL}
};

u_int8_t *block_count_p;	/* block count var. in prototype image */
u_int8_t *block_table_p;	/* block number array in prototype image */
u_int32_t *entry_point_p;	/* entry point for the /boot */
int	maxblocknum;	/* size of this array */


char		*loadprotoblocks __P((char *, long *));
int		loadblocknums __P((char *, int));
static void	devread __P((int, void *, daddr_t, size_t, char *));
static void	usage __P((void));
static int	record_block
	__P((u_int8_t *, daddr_t, u_int, struct disklabel *));

static void
usage()
{
	fprintf(stderr,
		"usage: installboot [-n] [-v] <boot> <proto> <device>\n");
	exit(1);
}

int
main(argc, argv)
	int argc;
	char *argv[];
{
	int	c;
	int	devfd;
	char	*protostore;
	long	protosize;

	while ((c = getopt(argc, argv, "vn")) != EOF) {
		switch (c) {
		case 'n':
			/* Do not actually write the bootblock to disk */
			nowrite = 1;
			break;
		case 'v':
			/* Chat */
			verbose = 1;
			break;
		default:
			usage();
		}
	}

	if (argc - optind < 3) {
		usage();
	}

	boot = argv[optind];
	proto = argv[optind + 1];
	dev = argv[optind + 2];

	if (verbose) {
		printf("boot: %s\n", boot);
		printf("proto: %s\n", proto);
		printf("device: %s\n", dev);
	}

	/* Load proto blocks into core */
	if ((protostore = loadprotoblocks(proto, &protosize)) == NULL)
		exit(1);

	/* XXX - Paranoia: Make sure size is aligned! */
	if (protosize & (DEV_BSIZE - 1))
		err(1, "proto bootblock bad size=%ld", protosize);

	/* Open and check raw disk device */
	if ((devfd = open(dev, O_RDONLY, 0)) < 0)
		err(1, "open: %s", dev);

	/* Extract and load block numbers */
	if (loadblocknums(boot, devfd) != 0)
		exit(1);

	(void)close(devfd);

	if (nowrite)
		return 0;

	/* Write patched proto bootblocks into the superblock */
	if (protosize > SBSIZE - DEV_BSIZE)
		errx(1, "proto bootblocks too big");

	if ((devfd = open(dev, O_RDWR, 0)) < 0)
		err(1, "open: %s", dev);

	/*
	if (lseek(devfd, DEV_BSIZE, SEEK_SET) != DEV_BSIZE)
		err(1, "lseek bootstrap");
	*/

	/* Sync filesystems (to clean in-memory superblock?) */
	sync();

	if (write(devfd, protostore, protosize) != protosize)
		err(1, "write bootstrap");
	(void)close(devfd);
	return 0;
}

char *
loadprotoblocks(fname, size)
	char *fname;
	long *size;
{
	int	fd;
	size_t	tdsize;		/* text+data size */
	char	*bp;
	struct	nlist *nlp;
	struct	exec eh;

	fd = -1;
	bp = NULL;

	/* Locate block number array in proto file */
	if (nlist(fname, nl) != 0) {
		warnx("nlist: %s: symbols not found", fname);
		return NULL;
	}
	/* Validate symbol types (global data). */
	for (nlp = nl; nlp->n_un.n_name; nlp++) {
		if (nlp->n_type != (N_TEXT | N_EXT)) {
			warnx("nlist: %s: wrong type", nlp->n_un.n_name);
			return NULL;
		}
	}

	if ((fd = open(fname, O_RDONLY)) < 0) {
		warn("open: %s", fname);
		return NULL;
	}
	if (read(fd, &eh, sizeof(eh)) != sizeof(eh)) {
		warn("read: %s", fname);
		goto bad;
	}
	if (N_GETMAGIC(eh) != OMAGIC) {
		warn("bad magic: 0x%lx", eh.a_midmag);
		goto bad;
	}
	/*
	 * We have to include the exec header in the beginning of
	 * the buffer, and leave extra space at the end in case
	 * the actual write to disk wants to skip the header.
	 */
	tdsize = eh.a_text + eh.a_data;

	/*
	 * Allocate extra space here because the caller may copy
	 * the boot block starting at the end of the exec header.
	 * This prevents reading beyond the end of the buffer.
	 */
	if ((bp = calloc(tdsize, 1)) == NULL) {
		warnx("malloc: %s: no memory", fname);
		goto bad;
	}
	/* Read the rest of the file. */
	if (read(fd, bp, tdsize) != tdsize) {
		warn("read: %s", fname);
		goto bad;
	}

	*size = tdsize;	/* not aligned to DEV_BSIZE */

	/* Calculate the symbols' locations within the proto file */
	block_count_p = (u_int8_t *) (bp + nl[X_BLOCK_COUNT].n_value);
	block_table_p = (u_int8_t *) (bp + nl[X_BLOCK_TABLE].n_value);
	entry_point_p = (u_int32_t *) (bp + nl[X_ENTRY_POINT].n_value);
	maxblocknum = *block_count_p;

	if (verbose) {
		printf("%s: entry point %#lx\n", fname, eh.a_entry);
		printf("proto bootblock size %ld\n", *size);
		printf("room for %d filesystem blocks at %#lx\n",
			maxblocknum, nl[X_BLOCK_TABLE].n_value);
	}

	close(fd);
	return bp;

 bad:
	if (bp)
		free(bp);
	if (fd >= 0)
		close(fd);
	return NULL;
}

static void
devread(fd, buf, blk, size, msg)
	int	fd;
	void	*buf;
	daddr_t	blk;
	size_t	size;
	char	*msg;
{
	if (lseek(fd, dbtob(blk), SEEK_SET) != dbtob(blk))
		err(1, "%s: devread: lseek", msg);

	if (read(fd, buf, size) != size)
		err(1, "%s: devread: read", msg);
}

static char sblock[SBSIZE];

int
loadblocknums(boot, devfd)
char	*boot;
int	devfd;
{
	int		i, fd;
	struct stat	statbuf;
	struct statfs	statfsbuf;
	struct disklabel dl;
	struct fs	*fs;
	char		*buf;
	daddr_t		blk, *ap;
	struct dinode	*ip;
	int		ndb;
	u_int8_t	*bt;
	struct exec	eh;

	/*
	 * Open 2nd-level boot program and record the block numbers
	 * it occupies on the filesystem represented by `devfd'.
	 */

	/* Make sure the (probably new) boot file is on disk. */
	sync(); sleep(1);

	if (ioctl(devfd, DIOCGDINFO, &dl) != 0)
		err(1, "disklabel: %s", dev);

	/* check disklabel */
	if (dl.d_magic != DISKMAGIC)
		err(1, "bad disklabel magic=%0x8x", dl.d_magic);

	if ((fd = open(boot, O_RDONLY)) < 0)
		err(1, "open: %s", boot);

	if (fstatfs(fd, &statfsbuf) != 0)
		err(1, "statfs: %s", boot);

	if (strncmp(statfsbuf.f_fstypename, "ffs", MFSNAMELEN) &&
	    strncmp(statfsbuf.f_fstypename, "ufs", MFSNAMELEN) ) {
		errx(1, "%s: must be on an FFS filesystem", boot);
	}

	if (read(fd, &eh, sizeof(eh)) != sizeof(eh)) {
		errx(1, "read: %s", boot);
	}

	if (N_GETMAGIC(eh) != OMAGIC) {
		errx(1, "%s: bad magic: 0x%lx", boot, eh.a_midmag);
	}

	*entry_point_p = eh.a_entry;

	if (fsync(fd) != 0)
		err(1, "fsync: %s", boot);

	if (fstat(fd, &statbuf) != 0)
		err(1, "fstat: %s", boot);

	close(fd);

	/* Read superblock */
	devread(devfd, sblock, SBLOCK, SBSIZE, "superblock");
	fs = (struct fs *)sblock;

	/* Sanity-check super-block. */
	if (fs->fs_magic != FS_MAGIC)
		errx(1, "Bad magic number in superblock");
	if (fs->fs_inopb <= 0)
		err(1, "Bad inopb=%d in superblock", fs->fs_inopb);

	/* Read inode */
	if ((buf = malloc(fs->fs_bsize)) == NULL)
		errx(1, "No memory for filesystem block");

	blk = fsbtodb(fs, ino_to_fsba(fs, statbuf.st_ino));
	devread(devfd, buf, blk, fs->fs_bsize, "inode");
	ip = (struct dinode *)(buf) + ino_to_fsbo(fs, statbuf.st_ino);

	/*
	 * Have the inode.  Figure out how many blocks we need.
	 */
	ndb = howmany(ip->di_size, fs->fs_bsize);
	if (ndb > maxblocknum)
		errx(1, "Too many blocks");
	if (verbose)
		printf("Will load %d blocks of size %d each.\n",
			   ndb, fs->fs_bsize);

	/*
	 * Get the block numbers; we don't handle fragments
	 */
	ap = ip->di_db;
	bt = block_table_p;
	for (i = 0; i < NDADDR && *ap && ndb; i++, ap++, ndb--)
		bt += record_block(bt, fsbtodb(fs, *ap),
					    fs->fs_bsize / 512, &dl);
	if (ndb != 0) {

		/*
		 * Just one level of indirections; there isn't much room
		 * for more in the 1st-level bootblocks anyway.
		 */
		blk = fsbtodb(fs, ip->di_ib[0]);
		devread(devfd, buf, blk, fs->fs_bsize, "indirect block");
		ap = (daddr_t *)buf;
		for (; i < NINDIR(fs) && *ap && ndb; i++, ap++, ndb--)
			bt += record_block(bt, fsbtodb(fs, *ap),
					   fs->fs_bsize / 512, &dl);
	}

	/* write out remaining piece */
	bt += record_block(block_table_p, 0, 0, &dl);
	/* and again */
	bt += record_block(block_table_p, 0, 0, &dl);
	*block_count_p = (bt - block_table_p) / 4;

	if (verbose) {
		printf("%s: %d entries total\n", boot, *block_count_p);
		printf("%s: entry point %#x\n", boot, *entry_point_p);
	}

	return 0;
}

static int
record_block(bt, blk, bs, dl)
	u_int8_t *bt;
	daddr_t blk;
	u_int bs;
	struct disklabel *dl;
{
	static int ss = 0, l = 0, i = 0; /* start and len of group */
	int ret = 0;

	if (ss == 0) { /* very beginning */
		ss = blk;
		l = bs;
		return 0;
	} else if (l == 0)
		return 0;

	/* record on track boundary or non-contig blocks or last call */
	if ((ss + l) != blk ||
	    (ss % dl->d_nsectors + l) >= dl->d_nsectors) {
		register u_int c = ss / dl->d_secpercyl,
			s = ss % dl->d_nsectors + 1;

		/* nsectors */
		if ((ss % dl->d_nsectors + l) >= dl->d_nsectors)
			bt[0] = dl->d_nsectors - s + 1;
		else
			bt[0] = l; /* non-contig or last block piece */

		bt[1] = (ss % dl->d_secpercyl) / dl->d_nsectors; /* head */
		*(u_int16_t *)(bt + 2) = (s & 0x3f) | /* sect, cyl */
			((c & 0xff) << 8) | ((c & 0x300) >> 2);

		if (verbose)
			printf("%2d: %2d @@(%d %d %d) (%d-%d)\n",
			       i, bt[0], c, bt[1], s, ss, ss + bt[0] - 1);

		if ((ss % dl->d_nsectors + l) >= dl->d_nsectors) {
			ss += bt[0];
			l -= bt[0];
			l += bs;
		} else {
			ss = blk;
			l = bs;
		}

		i++;
		ret = 4;
	} else {
		l += bs;
	}

	return ret;
}
@


1.1.2.2
log
@protected mode problems fixed for biosboot (now it works!!!)
libsa.a(cd9660.o) requires libkern.a -- removed from conf.c
installboot changed according to the biosboot changes.
-Wall in libsa/Makefile, cleanup!
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.1.2.1 1996/12/03 13:17:09 mickey Exp $	*/
d383 1
a383 1
	bt += record_block(bt, 0, 0, &dl);
d385 1
a385 1
	bt += record_block(bt, 0, 0, &dl);
d421 1
a421 1
			bt[3] = dl->d_nsectors - s + 1;
d423 1
a423 1
			bt[3] = l; /* non-contig or last block piece */
d425 2
a426 2
		bt[2] = (ss % dl->d_secpercyl) / dl->d_nsectors; /* head */
		*(u_int16_t *)bt = (s & 0x3f) | /* sect, cyl */
d431 1
a431 1
			       i, bt[3], c, bt[2], s, ss, ss + bt[3] - 1);
d434 2
a435 2
			ss += bt[3];
			l -= bt[3];
@


1.1.2.3
log
@no need for entry point, parse exec_header in biosboot
@
text
@d1 1
a1 1
/*	$OpenBSD: installboot.c,v 1.1.2.2 1996/12/15 15:49:37 mickey Exp $	*/
d57 1
a57 1
	{{"_block_count"}},
d59 4
a62 2
	{{"_block_table"}},
	{{NULL}}
d67 1
d233 1
d322 2
d388 1
a388 1
	if (verbose)
d390 2
@

