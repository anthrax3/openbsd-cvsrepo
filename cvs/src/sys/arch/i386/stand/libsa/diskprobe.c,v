head	1.44;
access;
symbols
	OPENBSD_6_2:1.44.0.2
	OPENBSD_6_2_BASE:1.44
	OPENBSD_6_1:1.41.0.4
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.40.0.4
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.39.0.8
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.39.0.4
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.34.0.4
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.2
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.32.0.10
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.8
	OPENBSD_5_0:1.32.0.6
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.4
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.2
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.31.0.4
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.30.0.2
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.29.0.6
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.4
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.27.0.10
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.8
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.6
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.4
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.6
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.18
	UBC:1.17.0.14
	UBC_BASE:1.17
	OPENBSD_3_0:1.17.0.12
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.17.0.10
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_8:1.17.0.8
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.17.0.6
	OPENBSD_2_7_BASE:1.17
	SMP:1.17.0.4
	SMP_BASE:1.17
	kame_19991208:1.17
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.15.0.6
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.15.0.4
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10;
locks; strict;
comment	@ * @;


1.44
date	2017.07.21.01.21.42;	author yasuoka;	state Exp;
branches;
next	1.43;
commitid	KhnY4tzd0VFPT3wU;

1.43
date	2017.06.22.01.26.28;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	3zTTK26TGx1N4rA8;

1.42
date	2017.06.19.22.50.50;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	qxUetDs8y9dCgVHx;

1.41
date	2016.09.11.15.54.11;	author jsing;	state Exp;
branches;
next	1.40;
commitid	m28Q0aUDbVqwDb3p;

1.40
date	2015.09.02.04.09.24;	author yasuoka;	state Exp;
branches;
next	1.39;
commitid	1T0xGkKNIiRZnTmz;

1.39
date	2014.07.12.20.58.31;	author tedu;	state Exp;
branches;
next	1.38;
commitid	oom7i9cmOZl8jGW7;

1.38
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.37;
commitid	uKVPYMN2MLxdZxzH;

1.37
date	2013.11.05.15.17.56;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2013.11.05.13.55.58;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2013.11.05.00.51.58;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2012.11.01.00.55.38;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2012.10.31.13.55.58;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2010.04.23.15.25.20;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2009.05.21.23.45.48;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2008.12.10.23.41.19;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.18.22.11.20;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2006.09.26.23.33.04;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.23.00.21.49;	author tom;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.19.13.48.18;	author tom;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.09.19.12.13;	author tom;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.16.22.53.13;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.23.18.33.45;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.19.05.25.12;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.11.06.23.09;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.04.17.04.05;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.31.00.15.29;	author weingart;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.34;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	99.10.03.20.37.25;	author ho;	state Exp;
branches
	1.17.4.1
	1.17.14.1;
next	1.16;

1.16
date	99.05.20.12.56.40;	author aaron;	state Exp;
branches;
next	1.15;

1.15
date	98.04.18.07.39.50;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.02.24.22.06.50;	author weingart;	state Exp;
branches;
next	1.13;

1.13
date	97.12.22.04.39.22;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.11.30.21.51.42;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.10.29.23.12.46;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.10.28.23.32.08;	author deraadt;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	97.10.26.23.19.54;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.10.26.10.00.32;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.10.25.02.07.10;	author weingart;	state Exp;
branches;
next	1.6;

1.6
date	97.10.24.22.22.57;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.10.24.01.38.51;	author weingart;	state Exp;
branches;
next	1.4;

1.4
date	97.10.23.15.13.29;	author weingart;	state Exp;
branches;
next	1.3;

1.3
date	97.10.22.23.34.38;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	97.10.18.00.33.15;	author weingart;	state Exp;
branches;
next	1.1;

1.1
date	97.10.17.18.46.56;	author weingart;	state Exp;
branches;
next	;

1.10.2.1
date	97.10.29.23.15.21;	author niklas;	state Exp;
branches;
next	;

1.17.4.1
date	2002.03.28.10.31.05;	author niklas;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2003.06.07.11.11.38;	author ho;	state Exp;
branches;
next	1.17.4.3;

1.17.4.3
date	2004.02.19.10.48.43;	author niklas;	state Exp;
branches;
next	1.17.4.4;

1.17.4.4
date	2004.06.05.23.09.01;	author niklas;	state Exp;
branches;
next	;

1.17.14.1
date	2002.06.11.03.35.55;	author art;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Check the hibernation signature for softraid disks and select valid bsd
for unhibernation.  reported by Natasha Kerensikova.  tested by Theo Buehler.

ok deraadt
@
text
@/*	$OpenBSD: diskprobe.c,v 1.43 2017/06/22 01:26:28 deraadt Exp $	*/

/*
 * Copyright (c) 1997 Tobias Weingartner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/* We want the disk type names from disklabel.h */
#undef DKTYPENAMES

#include <sys/param.h>
#include <sys/queue.h>
#include <sys/reboot.h>
#include <sys/disklabel.h>
#include <sys/hibernate.h>

#include <lib/libz/zlib.h>
#include <machine/biosvar.h>
#include <stand/boot/bootarg.h>

#include "disk.h"
#include "biosdev.h"
#include "libsa.h"

#ifdef SOFTRAID
#include "softraid_i386.h"
#endif
#ifdef EFIBOOT
#include "efidev.h"
#endif

#define MAX_CKSUMLEN MAXBSIZE / DEV_BSIZE	/* Max # of blks to cksum */

/* Local Prototypes */
static int disksum(int);

int bootdev_has_hibernate(void);		/* export for loadfile() */

/* List of disk devices we found/probed */
struct disklist_lh disklist;

/* Pointer to boot device */
struct diskinfo *bootdev_dip;

extern int debug;
extern int bios_bootdev;
extern int bios_cddev;

#ifndef EFIBOOT
static void
diskinfo_init(struct diskinfo *dip)
{
	bzero(dip, sizeof(*dip));
	dip->diskio = biosd_diskio;
	dip->strategy = biosstrategy;
}

/* Probe for all BIOS floppies */
static void
floppyprobe(void)
{
	struct diskinfo *dip;
	int i;

	/* Floppies */
	for (i = 0; i < 4; i++) {
		dip = alloc(sizeof(struct diskinfo));
		diskinfo_init(dip);

		if (bios_getdiskinfo(i, &dip->bios_info)) {
#ifdef BIOS_DEBUG
			if (debug)
				printf(" <!fd%u>", i);
#endif
			free(dip, 0);
			break;
		}

		printf(" fd%u", i);

		/* Fill out best we can - (fd?) */
		dip->bios_info.bsd_dev = MAKEBOOTDEV(2, 0, 0, i, RAW_PART);

		/*
		 * Delay reading the disklabel until we're sure we want
		 * to boot from the floppy. Doing this avoids a delay
		 * (sometimes very long) when trying to read the label
		 * and the drive is unplugged.
		 */
		dip->bios_info.flags |= BDI_BADLABEL;

		/* Add to queue of disks */
		TAILQ_INSERT_TAIL(&disklist, dip, list);
	}
}

/* Probe for all BIOS hard disks */
static void
hardprobe(void)
{
	struct diskinfo *dip;
	int i;
	u_int bsdunit, type;
	u_int scsi = 0, ide = 0;
	const char *dc = (const char *)((0x40 << 4) + 0x75);

	/* Hard disks */
	for (i = 0x80; i < (0x80 + *dc); i++) {
		dip = alloc(sizeof(struct diskinfo));
		diskinfo_init(dip);

		if (bios_getdiskinfo(i, &dip->bios_info)) {
#ifdef BIOS_DEBUG
			if (debug)
				printf(" <!hd%u>", i&0x7f);
#endif
			free(dip, 0);
			break;
		}

		printf(" hd%u%s", i&0x7f, (dip->bios_info.bios_edd > 0?"+":""));

		/* Try to find the label, to figure out device type */
		if ((bios_getdisklabel(&dip->bios_info, &dip->disklabel)) ) {
			printf("*");
			bsdunit = ide++;
			type = 0;	/* XXX let it be IDE */
		} else {
			/* Best guess */
			switch (dip->disklabel.d_type) {
			case DTYPE_SCSI:
				type = 4;
				bsdunit = scsi++;
				dip->bios_info.flags |= BDI_GOODLABEL;
				break;

			case DTYPE_ESDI:
			case DTYPE_ST506:
				type = 0;
				bsdunit = ide++;
				dip->bios_info.flags |= BDI_GOODLABEL;
				break;

			default:
				dip->bios_info.flags |= BDI_BADLABEL;
				type = 0;	/* XXX Suggest IDE */
				bsdunit = ide++;
			}
		}

		dip->bios_info.checksum = 0; /* just in case */
		/* Fill out best we can */
		dip->bsddev = dip->bios_info.bsd_dev =
		    MAKEBOOTDEV(type, 0, 0, bsdunit, RAW_PART);
		check_hibernate(dip);

		/* Add to queue of disks */
		TAILQ_INSERT_TAIL(&disklist, dip, list);
	}
}
#endif

#ifdef EFIBOOT
static void
efi_hardprobe(void)
{
	int		 n;
	struct diskinfo	*dip, *dipt;
	u_int		 bsdunit, type = 0;
	u_int		 scsi= 0, ide = 0;
	extern struct disklist_lh
			 efi_disklist;

	n = 0;
	TAILQ_FOREACH_SAFE(dip, &efi_disklist, list, dipt) {
		TAILQ_REMOVE(&efi_disklist, dip, list);
		printf(" hd%u", n);

		dip->bios_info.bios_number = 0x80 | n;
		/* Try to find the label, to figure out device type */
		if ((efi_getdisklabel(dip->efi_info, &dip->disklabel))) {
			printf("*");
			bsdunit = ide++;
		} else {
			/* Best guess */
			switch (dip->disklabel.d_type) {
			case DTYPE_SCSI:
				type = 4;
				bsdunit = scsi++;
				dip->bios_info.flags |= BDI_GOODLABEL;
				break;

			case DTYPE_ESDI:
			case DTYPE_ST506:
				type = 0;
				bsdunit = ide++;
				dip->bios_info.flags |= BDI_GOODLABEL;
				break;

			default:
				dip->bios_info.flags |= BDI_BADLABEL;
				type = 0;	/* XXX Suggest IDE */
				bsdunit = ide++;
			}
		}

		dip->bios_info.checksum = 0; /* just in case */
		/* Fill out best we can */
		dip->bsddev = dip->bios_info.bsd_dev =
		    MAKEBOOTDEV(type, 0, 0, bsdunit, RAW_PART);
		check_hibernate(dip);

		/* Add to queue of disks */
		TAILQ_INSERT_TAIL(&disklist, dip, list);
		n++;
	}
}
#endif

/* Probe for all BIOS supported disks */
u_int32_t bios_cksumlen;
void
diskprobe(void)
{
	struct diskinfo *dip;
	int i;

	/* These get passed to kernel */
	bios_diskinfo_t *bios_diskinfo;

	/* Init stuff */
	TAILQ_INIT(&disklist);

#ifndef EFIBOOT
	/* Do probes */
	floppyprobe();
#ifdef BIOS_DEBUG
	if (debug)
		printf(";");
#endif
	hardprobe();
#else
	efi_hardprobe();
#endif

#ifdef SOFTRAID
	srprobe();
#endif

	/* Checksumming of hard disks */
	for (i = 0; disksum(i++) && i < MAX_CKSUMLEN; )
		;
	bios_cksumlen = i;

	/* Get space for passing bios_diskinfo stuff to kernel */
	for (i = 0, dip = TAILQ_FIRST(&disklist); dip;
	    dip = TAILQ_NEXT(dip, list))
		i++;
	bios_diskinfo = alloc(++i * sizeof(bios_diskinfo_t));

	/* Copy out the bios_diskinfo stuff */
	for (i = 0, dip = TAILQ_FIRST(&disklist); dip;
	    dip = TAILQ_NEXT(dip, list))
		bios_diskinfo[i++] = dip->bios_info;

	bios_diskinfo[i++].bios_number = -1;
	/* Register for kernel use */
	addbootarg(BOOTARG_CKSUMLEN, sizeof(u_int32_t), &bios_cksumlen);
	addbootarg(BOOTARG_DISKINFO, i * sizeof(bios_diskinfo_t),
	    bios_diskinfo);
}

#ifndef EFIBOOT
void
cdprobe(void)
{
	struct diskinfo *dip;
	int cddev = bios_cddev & 0xff;

	/* Another BIOS boot device... */

	if (bios_cddev == -1)			/* Not been set, so don't use */
		return;

	dip = alloc(sizeof(struct diskinfo));
	diskinfo_init(dip);

#if 0
	if (bios_getdiskinfo(cddev, &dip->bios_info)) {
		printf(" <!cd0>");	/* XXX */
		free(dip, 0);
		return;
	}
#endif

	printf(" cd0");

	dip->bios_info.bios_number = cddev;
	dip->bios_info.bios_edd = 1;		/* Use the LBA calls */
	dip->bios_info.flags |= BDI_GOODLABEL | BDI_EL_TORITO;
	dip->bios_info.checksum = 0;		 /* just in case */
	dip->bios_info.bsd_dev =
	    MAKEBOOTDEV(6, 0, 0, 0, RAW_PART);

	/* Create an imaginary disk label */
	dip->disklabel.d_secsize = 2048;
	dip->disklabel.d_ntracks = 1;
	dip->disklabel.d_nsectors = 100;
	dip->disklabel.d_ncylinders = 1;
	dip->disklabel.d_secpercyl = dip->disklabel.d_ntracks *
	    dip->disklabel.d_nsectors;
	if (dip->disklabel.d_secpercyl == 0) {
		dip->disklabel.d_secpercyl = 100;
		/* as long as it's not 0, since readdisklabel divides by it */
	}

	strncpy(dip->disklabel.d_typename, "ATAPI CD-ROM",
	    sizeof(dip->disklabel.d_typename));
	dip->disklabel.d_type = DTYPE_ATAPI;

	strncpy(dip->disklabel.d_packname, "fictitious",
	    sizeof(dip->disklabel.d_packname));
	DL_SETDSIZE(&dip->disklabel, 100);

	dip->disklabel.d_bbsize = 2048;
	dip->disklabel.d_sbsize = 2048;

	/* 'a' partition covering the "whole" disk */
	DL_SETPOFFSET(&dip->disklabel.d_partitions[0], 0);
	DL_SETPSIZE(&dip->disklabel.d_partitions[0], 100);
	dip->disklabel.d_partitions[0].p_fstype = FS_UNUSED;

	/* The raw partition is special */
	DL_SETPOFFSET(&dip->disklabel.d_partitions[RAW_PART], 0);
	DL_SETPSIZE(&dip->disklabel.d_partitions[RAW_PART], 100);
	dip->disklabel.d_partitions[RAW_PART].p_fstype = FS_UNUSED;

	dip->disklabel.d_npartitions = MAXPARTITIONS;

	dip->disklabel.d_magic = DISKMAGIC;
	dip->disklabel.d_magic2 = DISKMAGIC;
	dip->disklabel.d_checksum = dkcksum(&dip->disklabel);

	/* Add to queue of disks */
	TAILQ_INSERT_TAIL(&disklist, dip, list);
}
#endif


/* Find info on given BIOS disk */
struct diskinfo *
dklookup(int dev)
{
	struct diskinfo *dip;

	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
		if (dip->bios_info.bios_number == dev)
			return dip;

	return NULL;
}

void
dump_diskinfo(void)
{
	struct diskinfo *dip;

	printf("Disk\tBIOS#\tType\tCyls\tHeads\tSecs\tFlags\tChecksum\n");
	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)) {
		bios_diskinfo_t *bdi = &dip->bios_info;
		int d = bdi->bios_number;
		int u = d & 0x7f;
		char c;

		if (bdi->flags & BDI_EL_TORITO) {
			c = 'c';
			u = 0;
		} else {
		    	c = (d & 0x80) ? 'h' : 'f';
		}

		printf("%cd%d\t0x%x\t%s\t%d\t%d\t%d\t0x%x\t0x%x\n",
		    c, u, d,
		    (bdi->flags & BDI_BADLABEL)?"*none*":"label",
		    bdi->bios_cylinders, bdi->bios_heads, bdi->bios_sectors,
		    bdi->flags, bdi->checksum);
	}
}

/* Find BIOS portion on given BIOS disk
 * XXX - Use dklookup() instead.
 */
bios_diskinfo_t *
bios_dklookup(int dev)
{
	struct diskinfo *dip;

	dip = dklookup(dev);
	if (dip)
		return &dip->bios_info;

	return NULL;
}

/*
 * Checksum one more block on all harddrives
 *
 * Use the adler32() function from libz,
 * as it is quick, small, and available.
 */
int
disksum(int blk)
{
	struct diskinfo *dip, *dip2;
	int st, reprobe = 0;
	char buf[DEV_BSIZE];

	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)) {
		bios_diskinfo_t *bdi = &dip->bios_info;

		/* Skip this disk if it is not a HD or has had an I/O error */
		if (!(bdi->bios_number & 0x80) || bdi->flags & BDI_INVALID)
			continue;

		/* Adler32 checksum */
		st = dip->diskio(F_READ, dip, blk, 1, buf);
		if (st) {
			bdi->flags |= BDI_INVALID;
			continue;
		}
		bdi->checksum = adler32(bdi->checksum, buf, DEV_BSIZE);

		for (dip2 = TAILQ_FIRST(&disklist); dip2 != dip;
				dip2 = TAILQ_NEXT(dip2, list)) {
			bios_diskinfo_t *bd = &dip2->bios_info;
			if ((bd->bios_number & 0x80) &&
			    !(bd->flags & BDI_INVALID) &&
			    bdi->checksum == bd->checksum)
				reprobe = 1;
		}
	}

	return reprobe;
}

int
bootdev_has_hibernate(void)
{
	return ((bootdev_dip->bios_info.flags & BDI_HIBVALID)? 1 : 0);
}

void
check_hibernate(struct diskinfo *dip)
{
	daddr_t sec;
	int error;
	union hibernate_info hib;

	/* read hibernate */
	if (dip->disklabel.d_partitions[1].p_fstype != FS_SWAP ||
	    DL_GETPSIZE(&dip->disklabel.d_partitions[1]) == 0)
		return;

	sec = DL_GETPOFFSET(&dip->disklabel.d_partitions[1]) +
	    DL_GETPSIZE(&dip->disklabel.d_partitions[1]) -
            (sizeof(union hibernate_info) / DEV_BSIZE);

	error = dip->strategy(dip, F_READ, (daddr32_t)sec, sizeof hib, &hib, NULL);
	if (error == 0 && hib.magic == HIBERNATE_MAGIC)
		dip->bios_info.flags |= BDI_HIBVALID; /* Hibernate present */
}
@


1.43
log
@Only print the magic '&' letter on a disk if the hibernate partition is
valid.  This is an undocumented little debugging diagnostic, much like
the '*'.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.42 2017/06/19 22:50:50 deraadt Exp $	*/
a57 1
static void check_hibernate(struct diskinfo *);
d474 1
a474 1
static void
d491 2
a492 5
	if (error == 0 && hib.magic == HIBERNATE_MAGIC)	{
		/* Hibernate present */
		dip->bios_info.flags |= BDI_HIBVALID;
		printf("&");
	}
@


1.42
log
@As early as possible, create a link /bsd.booted to the /bsd kernel we
presume we booted from.  If you boot from another kernel, we cannot help
you later with hibernate, sorry -- The kernel does not get a useable
filename from the bootblocks.

In the bootblocks, detect a live hibernate signature and boot from
/bsd.booted instead.

with yasuoka, lots of discussion with mlarkin, ok tom
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.41 2016/09/11 15:54:11 jsing Exp $	*/
d492 2
a493 1
	if (error == 0 && hib.magic == HIBERNATE_MAGIC)	/* Hibernate present */
d495 2
a496 1
	printf("&");
@


1.41
log
@Rename softraid boot files, which are currently in an MD location. This
will allow us to bring in a MI softraid.{c,h} in lib/libsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.40 2015/09/02 04:09:24 yasuoka Exp $	*/
d37 1
d58 3
d176 1
a176 1
		dip->bios_info.bsd_dev =
d178 1
d232 1
a232 1
		dip->bios_info.bsd_dev =
d234 1
d467 28
@


1.40
log
@Bring the boot changes on amd64 to i386.  alloca is deleted.
Also fix the boot from BIOS and bump the version.

input and ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.16 2015/09/02 01:52:26 yasuoka Exp $	*/
d47 1
a47 1
#include "softraid.h"
@


1.39
log
@revert more free fallout
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.38 2014/07/12 18:44:42 tedu Exp $	*/
d49 3
d68 9
d87 1
a87 1
		bzero(dip, sizeof(*dip));
a115 1

d129 1
a129 1
		bzero(dip, sizeof(*dip));
d179 17
d197 39
d251 1
d259 3
d290 1
a290 1

d303 1
a303 1
	bzero(dip, sizeof(*dip));
d364 1
d433 1
a433 1
	char *buf;
a434 1
	buf = alloca(DEV_BSIZE);
d443 1
a443 1
		st = biosd_io(F_READ, bdi, blk, 1, buf);
@


1.38
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.37 2013/11/05 15:17:56 krw Exp $	*/
d82 1
a82 1
			free(dip, 0, 0);
d125 1
a125 1
			free(dip, 0, 0);
d237 1
a237 1
		free(dip, 0, 0);
@


1.37
log
@Sigh. How many typos can be made in one diff. Fix DL_SETPSOFFSET() to
be DL_SETPOFFSET().
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.36 2013/11/05 13:55:58 krw Exp $	*/
d82 1
a82 1
			free(dip, 0);
d125 1
a125 1
			free(dip, 0);
d237 1
a237 1
		free(dip, 0);
@


1.36
log
@DL_SETDSIZE() and DL_SETPSIZE() are not the same thing. Use the latter
to set partition size. Fixes tree breakage found by Scott McEachern.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.35 2013/11/05 00:51:58 krw Exp $	*/
d275 1
a275 1
	DL_SETPSOFFSET(&dip->disklabel.d_partitions[0], 0);
d280 1
a280 1
	DL_SETPSOFFSET(&dip->disklabel.d_partitions[RAW_PART], 0);
@


1.35
log
@Replace direct references to p_size, p_offset and d_secperunit with
DL_[GET|SET]PSIZE(), DL_[GET|SET]POFFSET(), DL_[GET|SET]DSIZE() in
order to get|set correct value that includes the high bits of the
value.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.34 2012/11/01 00:55:38 jsing Exp $	*/
d276 1
a276 1
	DL_SETDSIZE(&dip->disklabel.d_partitions[0], 100);
d281 1
a281 1
	DL_SETDSIZE(&dip->disklabel.d_partitions[RAW_PART], 100);
@


1.34
log
@Fix merge errors.

Found the hard way by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.33 2012/10/31 13:55:58 jsing Exp $	*/
d269 1
a269 1
	dip->disklabel.d_secperunit = 100;
d275 2
a276 2
	dip->disklabel.d_partitions[0].p_offset = 0;
	dip->disklabel.d_partitions[0].p_size = 100;
d280 2
a281 2
	dip->disklabel.d_partitions[RAW_PART].p_offset = 0;
	dip->disklabel.d_partitions[RAW_PART].p_size = 100;
@


1.33
log
@Bring softraid support to i386/stand/libsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.11 2012/10/27 15:43:42 jsing Exp $	*/
d37 1
d42 1
a43 1
#include "disk.h"
d45 4
@


1.32
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.30 2008/12/10 23:41:19 krw Exp $	*/
d37 2
d40 2
a41 2
#include <machine/biosvar.h>
#include <lib/libz/zlib.h>
a42 1
#include "biosdev.h"
d186 4
@


1.31
log
@The only value that d_npartitions should have is MAXPARTITIONS.
@
text
@a259 2
	dip->disklabel.d_rpm = 300;
	dip->disklabel.d_interleave = 1;
@


1.30
log
@When booting from a CD on i386/amd64, assume the root filesystem
is on the CD rather than always asking for its location.  Behaviour
pointed out at OpenCON by Stephan Rickauer.

Tested by Stephan. nick@@ has no objections.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.29 2007/06/18 22:11:20 krw Exp $	*/
d276 1
a276 1
	dip->disklabel.d_npartitions = RAW_PART + 1;
@


1.29
log
@Calculate the disklabel checksum *after* filling in all the fields in
the disklabel.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.28 2006/09/26 23:33:04 krw Exp $	*/
d239 1
a239 1
	    MAKEBOOTDEV(0, 0, 0, 0xff, RAW_PART);
@


1.28
log
@Zap D_REMOVABLE flag from disklabel. If you didn't already know that
floppies and cd's were removable, displaying that fact in disklabel
output was unlikely to help. And the display in disklabel was the only
use of D_REMOVABLE in the tree.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.27 2004/06/23 00:21:49 tom Exp $	*/
a265 4
	dip->disklabel.d_magic = DISKMAGIC;
	dip->disklabel.d_magic2 = DISKMAGIC;
	dip->disklabel.d_checksum = dkcksum(&dip->disklabel);

d277 4
@


1.27
log
@Enter cdboot, a CD-specific second-stage bootrap.

Testing krw@@ and todd@@, thanks.

assistance, testing and ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.26 2004/03/19 13:48:18 tom Exp $	*/
a261 1
	dip->disklabel.d_flags = D_REMOVABLE;
@


1.26
log
@Enter pxeboot, derived from the NetBSD implementation.  Initially
intended to support network installs using bsd.rd over TFTP.

Thanks to the many who tested, including Diana Eichert.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.25 2004/03/09 19:12:13 tom Exp $	*/
d56 2
d210 78
d310 9
d321 1
a321 1
		    (d & 0x80)?'h':'f', d & 0x7F, d,
@


1.25
log
@Spacing and KNF.  Partly from Joris Vink <nimadeus at pandora dot be>.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.24 2003/12/16 22:53:13 deraadt Exp $	*/
a173 1
	printf("disk:");
a204 2

	printf("\n");
@


1.24
log
@a bit more shrinking.  do not bother printing the drive bus interfaces,
saves more space.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.23 2003/10/23 18:33:45 fgsch Exp $	*/
d16 2
a17 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
d65 1
a65 1
	for(i = 0; i < 4; i++) {
d69 1
a69 1
		if(bios_getdiskinfo(i, &dip->bios_info)) {
d112 1
a112 1
		if(bios_getdiskinfo(i, &dip->bios_info)) {
d124 1
a124 1
		if((bios_getdisklabel(&dip->bios_info, &dip->disklabel)) ) {
d153 2
a154 1
		dip->bios_info.bsd_dev = MAKEBOOTDEV(type, 0, 0, bsdunit, RAW_PART);
d191 2
a192 1
	for(i = 0, dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
d197 2
a198 1
	for(i = 0, dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
d204 2
a205 1
	addbootarg(BOOTARG_DISKINFO, i * sizeof(bios_diskinfo_t), bios_diskinfo);
d217 3
a219 3
	for(dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
		if(dip->bios_info.bios_number == dev)
			return(dip);
d221 1
a221 1
	return(NULL);
d230 1
a230 1
	for(dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)){
d236 1
a236 1
			(bdi->flags & BDI_BADLABEL)?"*none*":"label",
d251 2
a252 2
	if(dip)
		return(&dip->bios_info);
d254 1
a254 1
	return(NULL);
d271 1
a271 1
	for(dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)){
d286 2
a287 2
		for(dip2 = TAILQ_FIRST(&disklist); dip2 != dip;
				dip2 = TAILQ_NEXT(dip2, list)){
d296 1
a296 1
	return (reprobe);
a297 1

@


1.23
log
@- delay reading the disklabel for floppies until after we're sure it's
the boot device. this fixes a delay (sometimes very long) if the bios
correctly reports a floppy but it's unplugged.
- bump version.

original idea from mdw@@,  tested by nick@@, toby@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.22 2003/09/19 05:25:12 fgsch Exp $	*/
d31 1
a31 1
#define DKTYPENAMES
a224 2
	(void)fstypenames, (void)fstypesnames;

d232 1
a232 2
			(bdi->flags & BDI_BADLABEL)?"*none*":
				dktypenames[B_TYPE(dip->disklabel.d_type)],
@


1.22
log
@- some bios return a valid geometry for inexistent hd's so before
  getting the geometry check the number of attached drives from
  the bios area at 40:75.
- bump version.

from toby@@. we want people to test this, specially those with ghost
drives showing up.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.20 2003/06/04 17:04:05 deraadt Exp $	*/
d82 8
a89 4
		if((bios_getdisklabel(&dip->bios_info, &dip->disklabel)) != 0) 
			dip->bios_info.flags |= BDI_BADLABEL;
		else
			dip->bios_info.flags |= BDI_GOODLABEL;
@


1.21
log
@ansification and knf and protos
@
text
@d101 1
d104 1
a104 1
	for(i = 0x80; i < 0x88; i++) {
@


1.20
log
@fix some 3/4 for toby
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.19 2003/05/31 00:15:29 weingart Exp $	*/
d59 1
a59 1
floppyprobe()
d95 1
a95 1
hardprobe()
d159 1
a159 1
diskprobe()
d204 1
a204 2
dklookup(dev)
	int dev;
d216 1
a216 1
dump_diskinfo()
d240 1
a240 2
bios_dklookup(dev)
	register int dev;
d258 1
a258 2
disksum(blk)
	int blk;
@


1.19
log
@First lba support in /boot.  Not complete lba boot support, but it's the
first step on the way there.  Ok deraadt@@, espie@@, todd@@, and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.18 2002/03/14 01:26:34 millert Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Tobias Weingartner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.17 1999/10/03 20:37:25 ho Exp $	*/
a269 1
	int hpc, spt, dev;
a270 1
	int cyl, head, sect;
a279 4
		dev = bdi->bios_number;
		hpc = bdi->bios_heads;
		spt = bdi->bios_sectors;

d281 1
a281 2
		btochs(blk, cyl, head, sect, hpc, spt);
		st = biosd_io(F_READ, dev, cyl, head, sect, 1, buf);
@


1.17
log
@Add missing bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.16 1999/05/20 12:56:40 aaron Exp $	*/
d52 1
a52 1
static int disksum __P((int));
@


1.17.14.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.17 1999/10/03 20:37:25 ho Exp $	*/
d52 1
a52 1
static int disksum(int);
@


1.17.4.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
a52 1
static int disksum(int);
@


1.17.4.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.17.4.1 2002/03/28 10:31:05 niklas Exp $	*/
d15 5
d270 1
d272 1
d282 4
d287 2
a288 1
		st = biosd_io(F_READ, bdi, blk, 1, buf);
@


1.17.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 1
a31 1
#undef DKTYPENAMES
d59 1
a59 1
floppyprobe(void)
d82 4
a85 8

		/*
		 * Delay reading the disklabel until we're sure we want
		 * to boot from the floppy. Doing this avoids a delay
		 * (sometimes very long) when trying to read the label
		 * and the drive is unplugged.
		 */
		dip->bios_info.flags |= BDI_BADLABEL;
d95 1
a95 1
hardprobe(void)
a100 1
	const char *dc = (const char *)((0x40 << 4) + 0x75);
d103 1
a103 1
	for (i = 0x80; i < (0x80 + *dc); i++) {
d159 1
a159 1
diskprobe(void)
d204 2
a205 1
dklookup(int dev)
d217 1
a217 1
dump_diskinfo(void)
d221 2
d230 2
a231 1
			(bdi->flags & BDI_BADLABEL)?"*none*":"label",
d241 2
a242 1
bios_dklookup(int dev)
d260 2
a261 1
disksum(int blk)
@


1.17.4.4
log
@Merge with the trunk
@
text
@d16 2
a17 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
d65 1
a65 1
	for (i = 0; i < 4; i++) {
d69 1
a69 1
		if (bios_getdiskinfo(i, &dip->bios_info)) {
d112 1
a112 1
		if (bios_getdiskinfo(i, &dip->bios_info)) {
d124 1
a124 1
		if ((bios_getdisklabel(&dip->bios_info, &dip->disklabel)) ) {
d153 1
a153 2
		dip->bios_info.bsd_dev =
		    MAKEBOOTDEV(type, 0, 0, bsdunit, RAW_PART);
d173 1
d190 1
a190 2
	for (i = 0, dip = TAILQ_FIRST(&disklist); dip;
	    dip = TAILQ_NEXT(dip, list))
d195 1
a195 2
	for (i = 0, dip = TAILQ_FIRST(&disklist); dip;
	    dip = TAILQ_NEXT(dip, list))
d201 3
a203 2
	addbootarg(BOOTARG_DISKINFO, i * sizeof(bios_diskinfo_t),
	    bios_diskinfo);
d213 3
a215 3
	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list))
		if (dip->bios_info.bios_number == dev)
			return dip;
d217 1
a217 1
	return NULL;
d226 1
a226 1
	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)) {
d232 1
a232 1
		    (bdi->flags & BDI_BADLABEL)?"*none*":"label",
d247 2
a248 2
	if (dip)
		return &dip->bios_info;
d250 1
a250 1
	return NULL;
d267 1
a267 1
	for (dip = TAILQ_FIRST(&disklist); dip; dip = TAILQ_NEXT(dip, list)) {
d282 2
a283 2
		for (dip2 = TAILQ_FIRST(&disklist); dip2 != dip;
				dip2 = TAILQ_NEXT(dip2, list)) {
d292 1
a292 1
	return reprobe;
d294 1
@


1.16
log
@fix some typos; kwesterback@@home.com
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.15 1998/04/18 07:39:50 deraadt Exp $	*/
d110 1
@


1.15
log
@i386 bootblocks that work for 2.3. A tale too long to tell
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.14 1998/02/24 22:06:50 weingart Exp $	*/
d98 1
a98 1
/* Probe for all BIOS floppies */
d241 1
a241 1
/* Find BIOS protion on given BIOS disk
@


1.14
log
@Changes/updates to /boot stuff.  More to come.
Fixes many divide by zero and pointer bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.13 1997/12/22 04:39:22 mickey Exp $	*/
d55 1
a55 1
static struct disklist_lh disklist;
d60 1
d76 2
a77 1
			printf(" <!fd%u>", i);
d113 2
a114 1
			printf(" <!hd%u>", i&0x7f);
d161 1
a169 1
	static u_int32_t bios_cksumlen;
d178 2
a179 1
	printf(";");
d263 1
a263 1
static int
@


1.13
log
@fix debug drive printing
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.12 1997/11/30 21:51:42 mickey Exp $	*/
a177 1

@


1.12
log
@big diskinfo changes from toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.11 1997/10/29 23:12:46 niklas Exp $	*/
d111 1
a111 1
			printf(" <!hd%u>", i);
@


1.11
log
@Limit checksumming correctly at MAXBSIZE.
Don't involve floppies or bad block disks ever in uniqueness tests
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.10 1997/10/28 23:32:08 deraadt Exp $	*/
d35 3
d39 1
d45 1
d54 5
a58 3
/* These get passed to kernel */
bios_diskinfo_t bios_diskinfo[16];
u_int32_t bios_cksumlen;
d60 4
a63 3
/* Probe for all BIOS disks */
void
diskprobe()
d65 2
a66 5
	struct disklabel label;
	register u_int i;
	register bios_diskinfo_t *pdi;
	u_int type;
	u_int scsi = 0, ide = 0, bsdunit;
d68 4
a71 2
	printf("Probing disks:");
	pdi = bios_diskinfo;
d73 1
a73 3
	/* Floppies */
	for(i = 0; i < 4; i++, pdi++) {
		if(bios_getinfo(i, pdi)) {
d77 1
d79 3
a81 2
		} else
			printf(" fd%u", i);
d84 8
a91 1
		pdi->bsd_dev = MAKEBOOTDEV(2, 0, 0, i, RAW_PART);
d93 2
d96 8
a103 3
#ifdef BIOS_DEBUG
	printf(";");
#endif
d106 2
a107 1
	for(i = 0; i < 8; i++, pdi++) {
d109 1
a109 1
		if(bios_getinfo(i | 0x80, pdi)) {
d113 1
d117 1
a117 1
		printf(" hd%u%s", i, (pdi->bios_edd > 0?"+":""));
d120 1
a120 1
		if((bios_getdisklabel(i | 0x80, &label)) ) {
d126 1
a126 1
			switch (label.d_type) {
d130 1
a130 1
				pdi->flags |= BDI_GOODLABEL;
d137 1
a137 1
				pdi->flags |= BDI_GOODLABEL;
d141 1
a141 1
				pdi->flags |= BDI_BADLABEL;
d147 1
a147 1
		pdi->checksum = 0; /* just in case */
d149 4
a152 1
		pdi->bsd_dev = MAKEBOOTDEV(type, 0, 0, bsdunit, RAW_PART);
d154 25
a179 2
	/* End of list */
	pdi->bios_number = -1;
d184 12
d197 1
a197 3
	addbootarg(BOOTARG_DISKINFO, (pdi - bios_diskinfo + 1) *
				     sizeof(bios_diskinfo[0]), bios_diskinfo);

d202 1
d204 37
d245 1
a245 1
	register int i;
d247 3
a249 3
	for(i = 0; bios_diskinfo[i].bios_number != -1; i++)
		if(bios_diskinfo[i].bios_number == dev)
			return(&bios_diskinfo[i]);
d264 1
a264 1
	bios_diskinfo_t *bdi, *bd;
d271 3
a273 1
	for (bdi = bios_diskinfo; bdi->bios_number != -1; bdi++) {
d291 3
a293 1
		for (bd = bios_diskinfo; bd != bdi; bd++)
d298 1
d303 1
@


1.10
log
@attempt to number the bsd_dev units of each drive uniquely for scsi and ide.
hence ide 0, 1, 2, 3... scsi 0, 1, 2, 3... this makes the initial bsd_dev
values closer to the correct value they will have inside the kernel after
dkcsum has corrected them.
XXX if a drive has no label, it becomes known as an IDE drive, and scsi
drives after it get renumbered incorretcly. sorry.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.9 1997/10/26 23:19:54 mickey Exp $	*/
d132 1
a132 1
	for (i = 0; disksum(i) && i < MAX_CKSUMLEN; i++)
d134 1
a134 1
	bios_cksumlen = i + 1;
d193 3
a195 1
			if (bdi->checksum == bd->checksum)
@


1.10.2.1
log
@Merge in 1.10 to 1.11 from the trunk;
Limit checksumming correctly at MAXBSIZE.
Don't involve floppies or bad block disks ever in uniqueness tests
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.11 1997/10/29 23:12:46 niklas Exp $	*/
d132 1
a132 1
	for (i = 0; disksum(i++) && i < MAX_CKSUMLEN; )
d134 1
a134 1
	bios_cksumlen = i;
d193 1
a193 3
			if ((bd->bios_number & 0x80) &&
			    !(bd->flags & BDI_INVALID) &&
			    bdi->checksum == bd->checksum)
@


1.9
log
@smaller, faster, better (;
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.8 1997/10/26 10:00:32 niklas Exp $	*/
d61 1
d99 1
d106 1
d113 1
d120 1
d126 1
a126 1
		pdi->bsd_dev = MAKEBOOTDEV(type, 0, 0, i, RAW_PART);
@


1.8
log
@Max out checksumming at MAXBSIZE
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.7 1997/10/25 02:07:10 weingart Exp $	*/
a56 1
	u_int drive, i = 0, rv;
d58 3
a60 1
	u_int unit, type;
d63 1
d66 2
a67 4
	for(drive = 0; drive < 4; drive++) {
		rv = bios_getinfo(drive, &bios_diskinfo[i]);

		if(rv) {
d69 1
a69 1
			printf(" <!fd%u>", drive);
d72 2
a73 3
		}

		printf(" fd%u", drive);
d76 1
a76 2
		bios_diskinfo[i].bsd_dev = MAKEBOOTDEV(2, 0, 0, drive, 0);
		i++;
d80 1
a80 1
	printf("/");
d84 1
a84 2
	for(drive = 0x80; drive < 0x88; drive++) {
		rv = bios_getinfo(drive, &bios_diskinfo[i]);
d86 1
a86 1
		if(rv) {
d88 1
a88 1
			printf(" <!hd%u>", drive);
d93 1
a93 2
		unit = drive - 0x80;
		printf(" hd%u%s", unit, (bios_diskinfo[i].bios_edd > 0?"+":""));
d96 1
a96 1
		if((bios_getdisklabel(drive, &label)) ) {
d104 1
a104 1
				bios_diskinfo[i].flags |= BDI_GOODLABEL;
d110 1
a110 1
				bios_diskinfo[i].flags |= BDI_GOODLABEL;
d114 1
a114 1
				bios_diskinfo[i].flags |= BDI_BADLABEL;
d119 1
d121 1
a121 2
		bios_diskinfo[i].bsd_dev = MAKEBOOTDEV(type, 0, 0, unit, 0);
		i++;
d125 1
a125 4
	bios_diskinfo[i].bios_number = -1;
	addbootarg(BOOTARG_DISKINFO,
		   (i + 1) * sizeof(bios_diskinfo[0]), bios_diskinfo);

d131 3
@


1.7
log
@Fix disk probe.  Get rid of EDD check, it goes haywire on
some machines.  Thinkpad 760ED is one of them.  IBM/MS
extention, and IBM does not support it.  Nice.
Add some more debug statements for BIOS_DEBUG.
Init EDD flags to "not supported" for now.

Change 'machine memory' back to display the type of each
range it displays.

Testing by todd@@ (thanks).
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.6 1997/10/24 22:22:57 mickey Exp $	*/
d44 1
a44 1
#define MAX_CKSUMLEN 32		/* Max amount of diskblocks used in cksum */
@


1.6
log
@checksumming stuff from niklas
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.5 1997/10/24 01:38:51 weingart Exp $	*/
d80 4
@


1.5
log
@Fix hang on disk probe.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.4 1997/10/23 15:13:29 weingart Exp $	*/
d44 1
d47 1
a47 1
static void disksum __P((bios_diskinfo_t*));
d51 1
d67 6
a72 1
		if(rv) break;
d85 6
a90 1
		if(rv) break;
d101 2
a102 1
			if (label.d_type == DTYPE_SCSI)
d104 5
a108 1
			else
d110 7
a120 1
		disksum(&bios_diskinfo[i]);
d129 6
d152 2
a153 15
/* Find given sum in diskinfo array */
static bios_diskinfo_t *
find_sum(sum)
	u_int32_t sum;
{
	int i;

	for(i = 0; bios_diskinfo[i].bios_number != -1; i++)
		if(bios_diskinfo[i].checksum == sum)
			return(&bios_diskinfo[i]);

	return(NULL);
}

/* Checksum given drive until different
d158 3
a160 3
static void
disksum(bdi)
	bios_diskinfo_t *bdi;
d162 2
a163 2
	u_int32_t sum;
	int len, st;
d166 1
d169 8
a176 11
	dev = bdi->bios_number;
	hpc = bdi->bios_heads;
	spt = bdi->bios_sectors;

	/* Adler32 checksum */
	sum = adler32(0, NULL, 0);
	for(len = 0; len < 32; len++){
		int cyl, head, sect;
		bios_diskinfo_t *bd;

		btochs(len, cyl, head, sect, hpc, spt);
d178 2
d181 5
a185 3
		if(st) break;

		sum = adler32(sum, buf, DEV_BSIZE);
d187 3
a189 3
		/* Do a minimum of 8 sectors */
		if((len >= 8) && ((bd = find_sum(sum)) == NULL))
			break;
d192 1
a192 7
	if(st) {
		bdi->checksum = 0;
		bdi->checklen = 0;
	} else {
		bdi->checksum = sum;
		bdi->checklen = len;
	}
a193 1

@


1.4
log
@Better BIOS diskprobe.  Cleanup and re-org by mickey.
Fix bug in BIOS memprobe.  Cleanup and re-org by mickey.
Do checksum of HD devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.3 1997/10/22 23:34:38 mickey Exp $	*/
d65 1
a65 2
		if( (rv & 0x00FF)) break;
		if(!(rv & 0xFF00)) break;
d78 1
a78 2
		if( (rv & 0x00FF)) continue;
		if(!(rv & 0xFF00)) continue;
d169 1
a169 1
		/* Do a minimum of 8 sectors (floppy is slow...) */
@


1.3
log
@newer, better stuff; some parts by toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.2 1997/10/18 00:33:15 weingart Exp $	*/
d40 1
d44 4
a50 26
#if notyet
/* Checksum given buffer */
static u_int32_t
bufsum(buf, len)
	void *buf;
	int len;
{
	u_int32_t sum = 0;
	u_int8_t *p = buf;

	while(len--){
		sum += p[len];
	}
	return(sum);
}

/* Checksum given drive until different */
void
disksum(pos)
	int pos;
{
	u_int32_t sum;
	int len, i;
}
#endif

d65 2
a66 2
		if( (rv & 0x00FF)) continue;
		if(!(rv & 0xFF00)) continue;
a71 3
#if 0
		disksum(&bios_diskinfo[i]);
#endif
a98 1
#if 0
a99 1
#endif
d124 61
@


1.2
log
@Copy in bios_diskinfo array from /boot space.
Add length field for checksum to same.
Start of making /boot deduce bsd dev_t for
all BIOS drives.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskprobe.c,v 1.1 1997/10/17 18:46:56 weingart Exp $	*/
d37 2
a42 3

extern struct BIOS_vars BIOS_vars;

d46 6
a51 5

/* Find info on given BIOS disk */
bios_diskinfo_t *
diskfind(dev)
	int dev;
d53 2
a54 1
	int i;
d56 5
a60 3
	for(i = 0; bios_diskinfo[i].bios_number != -1; i++)
		if(bios_diskinfo[i].bios_number == dev)
			return(&bios_diskinfo[i]);
d62 7
a68 1
	return(NULL);
d70 1
d76 3
a78 1
	int drive, i = 0;
d83 5
a87 2
	for(drive = 0; drive < 4; drive++){
		u_int32_t p = biosdinfo(drive);
d89 1
a89 14
		if(BIOSNSECTS(p) < 2) continue;
		if(p){
			u_int32_t t = biosdprobe(drive);
			if(t & 0x00FF) continue;
			if(!(t & 0xFF00)) continue;

			printf(" fd%d", drive);

			/* Fill out best we can */
			bios_diskinfo[i].bsd_dev = MAKEBOOTDEV(2, 0, 0, 0, 0);	/* fd? */
			bios_diskinfo[i].bios_number = drive;
			bios_diskinfo[i].bios_cylinders = BIOSNTRACKS(p);
			bios_diskinfo[i].bios_heads = BIOSNHEADS(p);
			bios_diskinfo[i].bios_sectors = BIOSNSECTS(p);
d91 6
a96 2
			i++;
		}
d100 5
a104 2
	for(drive = 0x80; drive < 0x88; drive++){
		u_int32_t p = biosdinfo(drive);
d106 2
a107 14
		if(BIOSNSECTS(p) < 2) continue;
		if(p){
			u_int32_t t = biosdprobe(drive);
			if(t & 0x00FF) continue;
			if(!(t & 0xFF00)) continue;

			printf(" hd%d", drive - 128);

			/* Fill out best we can */
			bios_diskinfo[i].bsd_dev = -1;		/* XXX - fill in */
			bios_diskinfo[i].bios_number = drive;
			bios_diskinfo[i].bios_cylinders = BIOSNTRACKS(p);
			bios_diskinfo[i].bios_heads = BIOSNHEADS(p);
			bios_diskinfo[i].bios_sectors = BIOSNSECTS(p);
d109 10
a118 1
			i++;
d120 7
d131 2
a132 3

	/* XXX - This needs a better place! */
	BIOS_vars.boot_data = bios_diskinfo;
d137 13
@


1.1
log
@Cleanup, make it all compile.
Move APM stuff to apmprobe.c
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 1
d42 2
d48 15
d83 1
a83 1
			bios_diskinfo[i].bsd_major = 2;		/* fd? */
d106 1
a106 1
			bios_diskinfo[i].bsd_major = -1;		/* XXX - fill in */
d118 3
@

