head	1.57;
access;
symbols
	OPENBSD_6_2:1.57.0.8
	OPENBSD_6_2_BASE:1.57
	OPENBSD_6_1:1.57.0.6
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.57.0.2
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.56.0.2
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.53.0.8
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.53.0.2
	OPENBSD_5_7_BASE:1.53
	OPENBSD_5_6:1.53.0.4
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.52.0.6
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.52.0.2
	OPENBSD_5_4_BASE:1.52
	OPENBSD_5_3:1.51.0.2
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.50.0.8
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.6
	OPENBSD_5_0:1.50.0.4
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.47.0.2
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.45.0.14
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.10
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.45.0.8
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.45.0.6
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.45.0.4
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.45.0.2
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.44.0.6
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.44.0.4
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.44.0.2
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.42.0.6
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.42.0.4
	OPENBSD_3_6_BASE:1.42
	SMP_SYNC_A:1.42
	SMP_SYNC_B:1.42
	OPENBSD_3_5:1.42.0.2
	OPENBSD_3_5_BASE:1.42
	OPENBSD_3_4:1.39.0.2
	OPENBSD_3_4_BASE:1.39
	UBC_SYNC_A:1.37
	OPENBSD_3_3:1.37.0.4
	OPENBSD_3_3_BASE:1.37
	OPENBSD_3_2:1.37.0.2
	OPENBSD_3_2_BASE:1.37
	OPENBSD_3_1:1.35.0.2
	OPENBSD_3_1_BASE:1.35
	UBC_SYNC_B:1.37
	UBC:1.34.0.10
	UBC_BASE:1.34
	OPENBSD_3_0:1.34.0.8
	OPENBSD_3_0_BASE:1.34
	OPENBSD_2_9:1.34.0.6
	OPENBSD_2_9_BASE:1.34
	OPENBSD_2_8:1.34.0.4
	OPENBSD_2_8_BASE:1.34
	OPENBSD_2_7:1.34.0.2
	OPENBSD_2_7_BASE:1.34
	SMP:1.33.0.4
	SMP_BASE:1.33
	kame_19991208:1.33
	OPENBSD_2_6:1.33.0.2
	OPENBSD_2_6_BASE:1.33
	OPENBSD_2_5:1.31.0.2
	OPENBSD_2_5_BASE:1.31
	OPENBSD_2_4:1.30.0.2
	OPENBSD_2_4_BASE:1.30
	OPENBSD_2_3:1.27.0.2
	OPENBSD_2_3_BASE:1.27
	OPENBSD_2_2:1.24.0.2
	OPENBSD_2_2_BASE:1.24
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5;
locks; strict;
comment	@ * @;


1.57
date	2016.06.10.18.36.06;	author jcs;	state Exp;
branches;
next	1.56;
commitid	x57WcyDUhZLxQO5Z;

1.56
date	2015.10.08.14.46.05;	author tedu;	state Exp;
branches;
next	1.55;
commitid	8K1b8WK0PMVfXg5l;

1.55
date	2015.09.18.13.30.56;	author miod;	state Exp;
branches;
next	1.54;
commitid	1BEcCDYd9p5DIl0g;

1.54
date	2015.09.02.04.09.24;	author yasuoka;	state Exp;
branches;
next	1.53;
commitid	1T0xGkKNIiRZnTmz;

1.53
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.52;

1.52
date	2013.03.21.21.51.00;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2012.10.30.14.06.29;	author jsing;	state Exp;
branches;
next	1.50;

1.50
date	2010.12.06.22.51.46;	author jasper;	state Exp;
branches;
next	1.49;

1.49
date	2010.12.06.22.11.01;	author jasper;	state Exp;
branches;
next	1.48;

1.48
date	2010.12.06.18.44.49;	author jasper;	state Exp;
branches;
next	1.47;

1.47
date	2010.07.02.00.36.52;	author weingart;	state Exp;
branches;
next	1.46;

1.46
date	2009.11.30.16.33.20;	author canacar;	state Exp;
branches;
next	1.45;

1.45
date	2006.09.18.21.14.15;	author mpf;	state Exp;
branches;
next	1.44;

1.44
date	2005.05.03.13.18.04;	author tom;	state Exp;
branches;
next	1.43;

1.43
date	2005.05.03.13.02.44;	author tom;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.09.19.12.13;	author tom;	state Exp;
branches;
next	1.41;

1.41
date	2004.01.09.21.15.00;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2003.11.03.06.35.34;	author david;	state Exp;
branches;
next	1.39;

1.39
date	2003.08.11.06.23.09;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2003.06.03.20.22.12;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.20.20.22.58;	author weingart;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.03.13.58.11;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.15.19.55.15;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2000.03.05.18.40.59;	author niklas;	state Exp;
branches
	1.34.10.1;
next	1.33;

1.33
date	99.09.30.06.29.57;	author downsj;	state Exp;
branches
	1.33.4.1;
next	1.32;

1.32
date	99.08.25.00.54.19;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	99.01.24.16.07.39;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	98.08.31.20.53.10;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	98.06.08.19.27.33;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	98.06.08.18.56.45;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	98.04.18.07.39.54;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	98.02.24.22.06.56;	author weingart;	state Exp;
branches;
next	1.25;

1.25
date	97.11.30.21.51.47;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	97.10.23.15.13.30;	author weingart;	state Exp;
branches;
next	1.23;

1.23
date	97.10.22.23.34.40;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	97.10.22.00.14.25;	author weingart;	state Exp;
branches;
next	1.21;

1.21
date	97.10.22.00.05.07;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	97.10.21.23.47.26;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	97.10.20.20.20.45;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	97.10.20.14.56.09;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	97.10.20.14.47.42;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	97.10.17.18.46.58;	author weingart;	state Exp;
branches;
next	1.15;

1.15
date	97.10.17.15.03.28;	author weingart;	state Exp;
branches;
next	1.14;

1.14
date	97.10.12.21.01.01;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	97.10.12.20.14.27;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.09.17.17.56.10;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.09.02.17.00.42;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.08.22.20.13.44;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.08.12.19.12.09;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.08.07.01.11.07;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.08.05.16.26.05;	author weingart;	state Exp;
branches;
next	1.6;

1.6
date	97.08.04.21.49.42;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.04.17.17.21.16;	author weingart;	state Exp;
branches;
next	1.4;

1.4
date	97.04.15.06.43.15;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.04.09.08.39.39;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	97.03.31.23.06.30;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	97.03.31.03.12.14;	author weingart;	state Exp;
branches;
next	;

1.33.4.1
date	2000.02.19.17.53.10;	author niklas;	state Exp;
branches;
next	1.33.4.2;

1.33.4.2
date	2000.02.20.10.27.56;	author niklas;	state Exp;
branches;
next	1.33.4.3;

1.33.4.3
date	2000.03.24.09.07.49;	author niklas;	state Exp;
branches;
next	1.33.4.4;

1.33.4.4
date	2002.03.06.01.01.01;	author niklas;	state Exp;
branches;
next	1.33.4.5;

1.33.4.5
date	2003.03.27.23.26.56;	author niklas;	state Exp;
branches;
next	1.33.4.6;

1.33.4.6
date	2003.06.07.11.11.38;	author ho;	state Exp;
branches;
next	1.33.4.7;

1.33.4.7
date	2004.02.19.10.48.43;	author niklas;	state Exp;
branches;
next	1.33.4.8;

1.33.4.8
date	2004.06.05.23.09.01;	author niklas;	state Exp;
branches;
next	1.33.4.9;

1.33.4.9
date	2004.06.08.21.14.50;	author drahn;	state Exp;
branches;
next	;

1.34.10.1
date	2002.06.11.03.35.55;	author art;	state Exp;
branches;
next	1.34.10.2;

1.34.10.2
date	2002.10.29.00.28.04;	author art;	state Exp;
branches;
next	;


desc
@@


1.57
log
@fix some typos in comments

from Tom Cosgrove
@
text
@/*	$OpenBSD: memprobe.c,v 1.56 2015/10/08 14:46:05 tedu Exp $	*/

/*
 * Copyright (c) 1997-1999 Michael Shalayeff
 * Copyright (c) 1997-1999 Tobias Weingartner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <machine/biosvar.h>
#include <dev/isa/isareg.h>
#include <stand/boot/bootarg.h>
#include "libsa.h"

u_int cnvmem, extmem;		/* XXX - compatibility */

bios_memmap_t bios_memmap[64];	/* This is easier */
#ifndef EFIBOOT
/*
 * Check gateA20
 *
 * A sanity check.
 */
static __inline int
checkA20(void)
{
	register char *p = (char *)0x100000;
	register char *q = (char *)0x000000;
	int st;

	/* Simple check */
	if (*p != *q)
		return 1;

	/* Complex check */
	*p = ~(*p);
	st = (*p != *q);
	*p = ~(*p);

	return st;
}

/*
 * BIOS int 15, AX=E820
 *
 * This is the "preferred" method.
 */
static __inline bios_memmap_t *
bios_E820(bios_memmap_t *mp)
{
	int rc, off = 0, sig, gotcha = 0;

	do {
		BIOS_regs.biosr_es = ((u_int)(mp) >> 4);
		__asm volatile(DOINT(0x15) "; setc %b1"
		    : "=a" (sig), "=d" (rc), "=b" (off)
		    : "0" (0xE820), "1" (0x534d4150), "b" (off),
		      "c" (sizeof(*mp)), "D" (((u_int)mp) & 0xf)
		    : "cc", "memory");
		off = BIOS_regs.biosr_bx;

		if (rc & 0xff || sig != 0x534d4150)
			break;
		gotcha++;
		if (!mp->type)
			mp->type = BIOS_MAP_RES;
		mp++;
	} while (off);

	if (!gotcha)
		return NULL;
#ifdef DEBUG
	printf("0x15[E820] ");
#endif
	return mp;
}

/*
 * BIOS int 15, AX=8800
 *
 * Only used if int 15, AX=E801 does not work.
 * Machines with this are restricted to 64MB.
 */
static __inline bios_memmap_t *
bios_8800(bios_memmap_t *mp)
{
	int rc, mem;

	__asm volatile(DOINT(0x15) "; setc %b0"
	    : "=c" (rc), "=a" (mem) : "a" (0x8800));

	if (rc & 0xff)
		return NULL;
#ifdef DEBUG
	printf("0x15[8800] ");
#endif
	/* Fill out a BIOS_MAP */
	mp->addr = 1024 * 1024;		/* 1MB */
	mp->size = (mem & 0xffff) * 1024;
	mp->type = BIOS_MAP_FREE;

	return ++mp;
}

/*
 * BIOS int 0x12 Get Conventional Memory
 *
 * Only used if int 15, AX=E820 does not work.
 */
static __inline bios_memmap_t *
bios_int12(bios_memmap_t *mp)
{
	int mem;
#ifdef DEBUG
	printf("0x12 ");
#endif
	__asm volatile(DOINT(0x12) : "=a" (mem) :: "%ecx", "%edx", "cc");

	/* Fill out a bios_memmap_t */
	mp->addr = 0;
	mp->size = (mem & 0xffff) * 1024;
	mp->type = BIOS_MAP_FREE;

	return ++mp;
}


/*
 * addrprobe(kloc): Probe memory at address kloc * 1024.
 *
 * This is a hack, but it seems to work ok.  Maybe this is
 * the *real* way that you are supposed to do probing???
 *
 * Modify the original a bit.  We write everything first, and
 * then test for the values.  This should croak on machines that
 * return values just written on non-existent memory...
 *
 * BTW: These machines are pretty broken IMHO.
 *
 * XXX - Does not detect aliased memory.
 */
const u_int addrprobe_pat[] = {
	0x00000000, 0xFFFFFFFF,
	0x01010101, 0x10101010,
	0x55555555, 0xCCCCCCCC
};
static int
addrprobe(u_int kloc)
{
	volatile u_int *loc;
	register u_int i, ret = 0;
	u_int save[nitems(addrprobe_pat)];

	/* Get location */
	loc = (int *)(intptr_t)(kloc * 1024);

	save[0] = *loc;
	/* Probe address */
	for (i = 0; i < nitems(addrprobe_pat); i++) {
		*loc = addrprobe_pat[i];
		if (*loc != addrprobe_pat[i])
			ret++;
	}
	*loc = save[0];

	if (!ret) {
		/* Write address */
		for (i = 0; i < nitems(addrprobe_pat); i++) {
			save[i] = loc[i];
			loc[i] = addrprobe_pat[i];
		}

		/* Read address */
		for (i = 0; i < nitems(addrprobe_pat); i++) {
			if (loc[i] != addrprobe_pat[i])
				ret++;
			loc[i] = save[i];
		}
	}

	return ret;
}

/*
 * Probe for all extended memory.
 *
 * This is only used as a last resort.  If we resort to this
 * routine, we are getting pretty desperate.  Hopefully nobody
 * has to rely on this after all the work above.
 *
 * XXX - Does not detect aliased memory.
 * XXX - Could be destructive, as it does write.
 */
static __inline bios_memmap_t *
badprobe(bios_memmap_t *mp)
{
	u_int64_t ram;
#ifdef DEBUG
	printf("scan ");
#endif
	/*
	 * probe extended memory
	 *
	 * There is no need to do this in assembly language.  This is
	 * much easier to debug in C anyways.
	 */
	for (ram = 1024; ram < 512 * 1024; ram += 4)
		if (addrprobe(ram))
			break;

	mp->addr = 1024 * 1024;
	mp->size = (ram - 1024) * 1024;
	mp->type = BIOS_MAP_FREE;

	return ++mp;
}

bios_memmap_t bios_memmap[64];	/* This is easier */

void
memprobe(void)
{
	bios_memmap_t *pm = bios_memmap, *im;

#ifdef DEBUG
	printf(" mem(");
#else
	printf(" mem[");
#endif

	if ((pm = bios_E820(bios_memmap)) == NULL) {
		im = bios_int12(bios_memmap);
		pm = bios_8800(im);
		if (pm == NULL)
			pm = badprobe(im);
		if (pm == NULL) {
			printf(" No Extended memory detected.");
			pm = im;
		}
	}
	pm->type = BIOS_MAP_END;

	/* XXX - gotta peephole optimize the list */

	/* Remove APM needed RAM */
	apmfixmem();

#ifdef DEBUG
	printf(")[");
#endif

	/* XXX - Compatibility, remove later (smpprobe() relies on it) */
	extmem = cnvmem = 0;
	for (im = bios_memmap; im->type != BIOS_MAP_END; im++) {
		/* Count only "good" memory chunks 12K and up in size */
		if ((im->type == BIOS_MAP_FREE) && (im->size >= 12 * 1024)) {
			if (im->size > 1024 * 1024)
				printf("%uM ", (u_int)(im->size /
				    (1024 * 1024)));
			else
				printf("%uK ", (u_int)im->size / 1024);

			/*
			 * Compute compatibility values:
			 * cnvmem -- is the upper boundary of conventional
			 *	memory (below IOM_BEGIN (=640k))
			 * extmem -- is the size of the contiguous extended
			 *	memory segment starting at 1M
			 *
			 * We ignore "good" memory in the 640K-1M hole.
			 * We drop "machine {cnvmem,extmem}" commands.
			 */
			if (im->addr < IOM_BEGIN)
				cnvmem = max(cnvmem,
				    im->addr + im->size) / 1024;
			if (im->addr >= IOM_END)
				extmem += im->size / 1024;
		}
	}

	/* Check if gate A20 is on */
	printf("a20=o%s] ", checkA20()? "n" : "ff!");
}
#endif

void
dump_biosmem(bios_memmap_t *tm)
{
	register bios_memmap_t *p;
	register u_int total = 0;

	if (tm == NULL)
		tm = bios_memmap;

	for (p = tm; p->type != BIOS_MAP_END; p++) {
		printf("Region %ld: type %u at 0x%llx for %uKB\n",
		    (long)(p - tm), p->type, p->addr,
		    (u_int)(p->size / 1024));

		if (p->type == BIOS_MAP_FREE)
			total += p->size / 1024;
	}

	printf("Low ram: %dKB  High ram: %dKB\n", cnvmem, extmem);
	printf("Total free memory: %uKB\n", total);
}

int
mem_limit(long long ml)
{
	register bios_memmap_t *p;

	for (p = bios_memmap; p->type != BIOS_MAP_END; p++) {
		register int64_t sp = p->addr, ep = p->addr + p->size;

		if (p->type != BIOS_MAP_FREE)
			continue;

		/* Wholly above limit, nuke it */
		if ((sp >= ml) && (ep >= ml)) {
			bcopy (p + 1, p, (char *)bios_memmap +
			       sizeof(bios_memmap) - (char *)p);
		} else if ((sp < ml) && (ep >= ml)) {
			p->size -= (ep - ml);
		}
	}
	return 0;
}

int
mem_delete(long long sa, long long ea)
{
	register bios_memmap_t *p;

	for (p = bios_memmap; p->type != BIOS_MAP_END; p++) {
		if (p->type == BIOS_MAP_FREE) {
			register int64_t sp = p->addr, ep = p->addr + p->size;

			/* can we eat it as a whole? */
			if ((sa - sp) <= PAGE_SIZE && (ep - ea) <= PAGE_SIZE) {
				bcopy(p + 1, p, (char *)bios_memmap +
				    sizeof(bios_memmap) - (char *)p);
				break;
			/* eat head or legs */
			} else if (sa <= sp && sp < ea) {
				p->addr = ea;
				p->size = ep - ea;
				break;
			} else if (sa < ep && ep <= ea) {
				p->size = sa - sp;
				break;
			} else if (sp < sa && ea < ep) {
				/* bite in half */
				bcopy(p, p + 1, (char *)bios_memmap +
				    sizeof(bios_memmap) - (char *)p -
				    sizeof(bios_memmap[0]));
				p[1].addr = ea;
				p[1].size = ep - ea;
				p->size = sa - sp;
				break;
			}
		}
	}
	return 0;
}

int
mem_add(long long sa, long long ea)
{
	register bios_memmap_t *p;

	for (p = bios_memmap; p->type != BIOS_MAP_END; p++) {
		if (p->type == BIOS_MAP_FREE) {
			register int64_t sp = p->addr, ep = p->addr + p->size;

			/* is it already there? */
			if (sp <= sa && ea <= ep) {
				break;
			/* join head or legs */
			} else if (sa < sp && sp <= ea) {
				p->addr = sa;
				p->size = ep - sa;
				break;
			} else if (sa <= ep && ep < ea) {
				p->size = ea - sp;
				break;
			} else if (ea < sp) {
				/* insert before */
				bcopy(p, p + 1, (char *)bios_memmap +
				    sizeof(bios_memmap) - (char *)(p - 1));
				p->addr = sa;
				p->size = ea - sa;
				break;
			}
		}
	}

	/* meaning add new item at the end of the list */
	if (p->type == BIOS_MAP_END) {
		p[1] = p[0];
		p->type = BIOS_MAP_FREE;
		p->addr = sa;
		p->size = ea - sa;
	}

	return 0;
}

void
mem_pass(void)
{
	bios_memmap_t *p;

	for (p = bios_memmap; p->type != BIOS_MAP_END; p++)
		;
	addbootarg(BOOTARG_MEMMAP, (p - bios_memmap + 1) * sizeof *bios_memmap,
	    bios_memmap);
}
@


1.56
log
@16 years after E801 memprobe was disabled, probably safe to delete it.
ok deraadt jung kettenis ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.55 2015/09/18 13:30:56 miod Exp $	*/
d289 1
a289 1
			 * extmem -- is the size of the contignous extended
d341 1
a341 1
		/* Wholy above limit, nuke it */
@


1.55
log
@Remove support for building the boot blocks with DEBUGFLAGS=-D_TEST, which is
supposed to create a userland binary in order to test non-boot related
functionality. This feature has been bitrotting in a non-compiling state
for years, and causes a too-many-ifdefs disease now that there are intrusive
EFI changes.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.54 2015/09/02 04:09:24 yasuoka Exp $	*/
a99 59
#if 0
/*
 * BIOS int 15, AX=E801
 *
 * Only used if int 15, AX=E820 does not work.
 * This should work for more than 64MB on most
 * modern machines.  However, there is always
 * an exception, the older IBM machine do not
 * like this call.
 */
static __inline bios_memmap_t *
bios_E801(bios_memmap_t *mp)
{
	int rc, m1, m2, m3, m4;
	u_int8_t *info;

	/* Test for possibility of 0xE801 */
	info =  getSYSCONFaddr();
	if (!info)
		return NULL;
	/* XXX - Should test model/submodel/rev here */
	printf("model(%d,%d,%d)", info[2], info[3], info[4]);

	/* Check for 94 or later bios */
	info = (void *)0xFFFFB;
	if (info[0] == '9' && info[1] <= '3')
		return NULL;

	/* We might have this call */
	__asm volatile(DOINT(0x15) "; mov %%ax, %%si; setc %b0"
	    : "=a" (rc), "=S" (m1), "=b" (m2), "=c" (m3), "=d" (m4)
	    : "0" (0xE801));

	/* Test for failure */
	if (rc & 0xff)
		return NULL;

	/* Fixup for screwed up machines */
	if (m1 == 0) {
		m1 = m3;
		m2 = m4;
	}
#ifdef DEBUG
	printf("0x15[E801] ");
#endif
	/* Fill out BIOS map */
	mp->addr = (1024 * 1024);	/* 1MB */
	mp->size = (m1 & 0xffff) * 1024;
	mp->type = BIOS_MAP_FREE;

	mp++;
	mp->addr = (1024 * 1024) * 16;	/* 16MB */
	mp->size = (m2 & 0xffff) * 64L * 1024;
	mp->type = BIOS_MAP_FREE;

	return ++mp;
}
#endif

d255 1
a255 5
#if 0
		pm = bios_E801(im);
		if (pm == NULL)
#endif
			pm = bios_8800(im);
@


1.54
log
@Bring the boot changes on amd64 to i386.  alloca is deleted.
Also fix the boot from BIOS and bump the version.

input and ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.14 2015/09/02 01:52:26 yasuoka Exp $	*/
d299 2
a300 1
#ifndef _TEST
a368 1
#endif
@


1.53
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.52 2013/03/21 21:51:00 deraadt Exp $	*/
d39 2
a40 1

d236 1
a236 1
	loc = (int *)(kloc * 1024);
a298 1
bios_memmap_t bios_memmap[64];	/* This is easier */
d368 1
@


1.52
log
@NBPG -> PAGE_SIZE, PGSHIFT -> PAGE_SHIFT, PGOFSET -> PAGE_MASK
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.51 2012/10/30 14:06:29 jsing Exp $	*/
d76 1
a76 1
		__asm __volatile(DOINT(0x15) "; setc %b1"
d128 1
a128 1
	__asm __volatile(DOINT(0x15) "; mov %%ax, %%si; setc %b0"
d169 1
a169 1
	__asm __volatile(DOINT(0x15) "; setc %b0"
d197 1
a197 1
	__asm __volatile(DOINT(0x12) : "=a" (mem) :: "%ecx", "%edx", "cc");
d230 1
a230 1
	__volatile u_int *loc;
@


1.51
log
@Apply a bunch of style(9) and whitespace fixes to i386/amd64 libsa, making
the code actually diffable. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.49 2010/12/06 22:11:01 jasper Exp $	*/
d424 1
a424 1
			if ((sa - sp) <= NBPG && (ep - ea) <= NBPG) {
@


1.50
log
@- properly remove NENTS now after fixing the fallout.

ok deraadt@@
@
text
@d40 2
a41 1
/* Check gateA20
d64 2
a65 1
/* BIOS int 15, AX=E820
a75 1

d79 1
a79 1
		      "c" (sizeof(*mp)), "D" (((u_int)mp) & 0xF)
d100 2
a101 1
/* BIOS int 15, AX=E801
d158 2
a159 1
/* BIOS int 15, AX=8800
d185 2
a186 1
/* BIOS int 0x12 Get Conventional Memory
d208 2
a209 1
/* addrprobe(kloc): Probe memory at address kloc * 1024.
d264 2
a265 1
/* Probe for all extended memory.
d281 2
a282 1
	/* probe extended memory
d340 1
a340 1
		if ((im->type == BIOS_MAP_FREE) && (im->size >= 12*1024)) {
@


1.49
log
@- partially revert previous NENTS removal for arches which got busted.
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.48 2010/12/06 18:44:49 jasper Exp $	*/
d227 1
a227 1
	u_int save[NENTS(addrprobe_pat)];
d234 1
a234 1
	for (i = 0; i < NENTS(addrprobe_pat); i++) {
d243 1
a243 1
		for (i = 0; i < NENTS(addrprobe_pat); i++) {
d249 1
a249 1
		for (i = 0; i < NENTS(addrprobe_pat); i++) {
@


1.48
log
@- drop NENTS(), which was yet another copy of nitems().
no binary change


ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.47 2010/07/02 00:36:52 weingart Exp $	*/
d227 1
a227 1
	u_int save[nitems(addrprobe_pat)];
d234 1
a234 1
	for (i = 0; i < nitems(addrprobe_pat); i++) {
d243 1
a243 1
		for (i = 0; i < nitems(addrprobe_pat); i++) {
d249 1
a249 1
		for (i = 0; i < nitems(addrprobe_pat); i++) {
@


1.47
log
@Add ability to limit memory presented to kernel with
'machine memory =128M' style commands.  Thanks to
phessler for finding a small man page niggle.  Bumped
version strings to a nice round fraction, and make them
the same across the board.  Easier to identify boot
binary versions that way.

ok thib@@, tedu@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.46 2009/11/30 16:33:20 canacar Exp $	*/
d227 1
a227 1
	u_int save[NENTS(addrprobe_pat)];
d234 1
a234 1
	for (i = 0; i < NENTS(addrprobe_pat); i++) {
d243 1
a243 1
		for (i = 0; i < NENTS(addrprobe_pat); i++) {
d249 1
a249 1
		for (i = 0; i < NENTS(addrprobe_pat); i++) {
@


1.46
log
@Bump up array size to prevent overflow when probing memory
on machines reporting > 32 memory regions. ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.45 2006/09/18 21:14:15 mpf Exp $	*/
d383 22
@


1.45
log
@boot(8) ``machine memory'' support for > 4G.
Convert parser to strtoll(3) and use 64bit printf.
With help from mickey@@
i386 and amd64 tests by me, alpha test by mickey@@
OK mickey@@, miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.44 2005/05/03 13:18:04 tom Exp $	*/
d291 1
a291 1
bios_memmap_t bios_memmap[32];	/* This is easier */
@


1.44
log
@The return value from getEBDAaddr() (info) is not used in bios_E820(),
so nuke it.  amd64 no longer needs biosprobe.c listed in SRCS.  Trims
100 bytes from the boot blocks.

Bump versions on boot, cdboot and pxeboot, as I'm getting cautious in
my old age.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.43 2005/05/03 13:02:44 tom Exp $	*/
a371 5
	/* libsa printf does not handle quad args, so we use long
	 * instead.  Note, since we're unlikely to support more than
	 * 4G of RAM on a x86 box, this not likely to cause a problem.
	 * If/when we do, libsa may need to be updated some...
	 */
d373 2
a374 2
		printf("Region %ld: type %u at 0x%x for %uKB\n",
		    (long)(p - tm), p->type, (u_int)p->addr,
d386 1
a386 1
mem_delete(long sa, long ea)
d423 1
a423 1
mem_add(long sa, long ea)
@


1.43
log
@Convert the size of a memory chunk from bytes to megabytes before
casting to a 32-bit value, not after.  Corrects the display of large
memory chunks in the probing: line (mem[615K 3518M 0M a20=on] becomes
mem[615K 3518M 12288M a20=on]).

Bump version on boot, cdboot and pxeboot accordingly.

"looks ok to me" weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.42 2004/03/09 19:12:13 tom Exp $	*/
a69 1
	void *info;
a70 1
	info = getEBDAaddr();
@


1.42
log
@Spacing and KNF.  Partly from Joris Vink <nimadeus at pandora dot be>.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.41 2004/01/09 21:15:00 deraadt Exp $	*/
d337 2
a338 1
				printf("%uM ", (u_int)im->size / (1024 * 1024));
@


1.41
log
@spelling; jjy2+@@pitt.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.40 2003/11/03 06:35:34 david Exp $	*/
d17 2
a18 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
d52 2
a53 2
	if(*p != *q)
		return(1);
d60 1
a60 1
	return(st);
d76 1
d78 5
a82 5
				: "=a" (sig), "=d" (rc), "=b" (off)
				: "0" (0xE820), "1" (0x534d4150), "b" (off),
				  "c" (sizeof(*mp)), "D" (((u_int)mp) & 0xF)
				: "cc", "memory");
			off = BIOS_regs.biosr_bx;
d84 6
a89 6
			if (rc & 0xff || sig != 0x534d4150)
				break;
			gotcha++;
			if (!mp->type)
				mp->type = BIOS_MAP_RES;
			mp++;
d93 1
a93 1
		return (NULL);
d97 1
a97 1
	return (mp);
d117 2
a118 1
	if(!info) return(NULL);
d124 2
a125 1
	if(info[0] == '9' && info[1] <= '3') return(NULL);
d129 2
a130 2
		: "=a" (rc), "=S" (m1), "=b" (m2), "=c" (m3), "=d" (m4)
		: "0" (0xE801));
d133 2
a134 2
	if(rc & 0xff)
		return (NULL);
d137 1
a137 1
	if(m1 == 0){
d169 1
a169 1
		: "=c" (rc), "=a" (mem) : "a" (0x8800));
d171 2
a172 2
	if(rc & 0xff)
		return (NULL);
d236 1
a236 1
	for(i = 0; i < NENTS(addrprobe_pat); i++){
d238 1
a238 1
		if(*loc != addrprobe_pat[i])
d245 1
a245 1
		for(i = 0; i < NENTS(addrprobe_pat); i++) {
d251 2
a252 2
		for(i = 0; i < NENTS(addrprobe_pat); i++) {
			if(loc[i] != addrprobe_pat[i])
d282 2
a283 2
	for(ram = 1024; ram < 512 * 1024; ram += 4)
		if(addrprobe(ram))
d306 1
a306 1
	if(!(pm = bios_E820(bios_memmap))) {
d310 1
a310 1
		if (!pm)
d313 1
a313 1
		if (!pm)
d315 2
a316 2
		if (!pm) {
			printf (" No Extended memory detected.");
d333 1
a333 1
	for(im = bios_memmap; im->type != BIOS_MAP_END; im++) {
d351 1
a351 1
			if(im->addr < IOM_BEGIN)
d354 1
a354 1
			if(im->addr >= IOM_END)
d370 1
a370 1
	if (!tm)
d378 2
a379 2
	for(p = tm; p->type != BIOS_MAP_END; p++) {
		printf("Region %ld: type %u at 0x%x for %uKB\n", 
d383 1
a383 1
		if(p->type == BIOS_MAP_FREE)
d402 2
a403 2
				bcopy (p + 1, p, (char *)bios_memmap +
				       sizeof(bios_memmap) - (char *)p);
d415 3
a417 3
				bcopy (p, p + 1, (char *)bios_memmap +
				       sizeof(bios_memmap) - (char *)p -
				       sizeof(bios_memmap[0]));
d450 2
a451 2
				bcopy (p, p + 1, (char *)bios_memmap +
				       sizeof(bios_memmap) - (char *)(p - 1));
@


1.40
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.39 2003/08/11 06:23:09 deraadt Exp $	*/
d65 1
a65 1
 * This is the "prefered" method.
@


1.39
log
@ansification and knf and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.38 2003/06/03 20:22:12 mickey Exp $	*/
d261 1
a261 1
 * routine, we are getting pretty desparate.  Hopefully nobody
@


1.38
log
@three four kills
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.37 2002/06/20 20:22:58 weingart Exp $	*/
d68 1
a68 2
bios_E820(mp)
	register bios_memmap_t *mp;
d109 1
a109 2
bios_E801(mp)
	register bios_memmap_t *mp;
d161 1
a161 2
bios_8800(mp)
	register bios_memmap_t *mp;
d186 1
a186 2
bios_int12(mp)
	register bios_memmap_t *mp;
d222 1
a222 2
addrprobe(kloc)
	u_int kloc;
d268 1
a268 2
badprobe(mp)
	register bios_memmap_t *mp;
d293 1
a293 1
memprobe()
d362 1
a362 2
dump_biosmem(tm)
	bios_memmap_t *tm;
d389 1
a389 2
mem_delete(sa, ea)
	long sa, ea;
d426 1
a426 2
mem_add(sa, ea)
	long sa, ea;
d468 1
a468 1
mem_pass()
d475 1
a475 1
		bios_memmap);
@


1.37
log
@Fix 4GB memory probing and other memory probing issues.
Outstanding issue is with Compaq 16MB detection problem.
ok deraadt@@, and various people from the 'net.
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.36 2002/05/03 13:58:11 espie Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Tobias Weingartner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.36
log
@no guarantee that ptrdiff_t is int and not long, so cast.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.35 2002/02/15 19:55:15 mickey Exp $	*/
d5 1
a5 1
 * Copyright (c) 1997 Tobias Weingartner
d76 1
d78 1
a104 4
/* XXX Disabled until it is shown it is needed, and a version that does not
 * confuse the AT&T Globalyst 580 comes up.  Ask niklas@@openbsd.org if you
 * want to know details.
 */
d109 4
a112 1
 * This should work for more than 64MB.
d118 2
a119 1
	int rc, m1, m2;
d121 14
a134 3
	/* Test for 0xE801 */
	__asm __volatile(DOINT(0x15) "; setc %b1"
		: "=a" (m1), "=b" (m2), "=c" (rc) : "0" (0xE801));
d136 1
a136 1
	/* Make a memory map from info */
d139 6
d328 1
d330 1
a330 2
	pm->type = BIOS_MAP_END;
	/* gotta peephole optimize the list */
d332 2
a333 1
	apmcheck();
d382 5
d389 1
a389 1
		    (long)(p - tm), p->type, (u_int)p->addr, 
d408 1
a408 1
			register int32_t sp = p->addr, ep = p->addr + p->size;
d446 1
a446 1
			register int32_t sp = p->addr, ep = p->addr + p->size;
@


1.35
log
@fix the possible 4G overflow issues
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.34 2000/03/05 18:40:59 niklas Exp $	*/
d363 3
a365 2
		printf("Region %d: type %u at 0x%x for %uKB\n", p - tm,
			p->type, (u_int)p->addr, (u_int)(p->size / 1024));
@


1.34
log
@D not forget our memmap changes, ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.33 1999/09/30 06:29:57 downsj Exp $	*/
d136 1
a136 1
	mp->size = (m2 & 0xffff) * 64 * 1024;
d262 1
a262 1
	int ram;
d340 2
a341 1
				cnvmem = max(cnvmem, im->addr + im->size);
d343 1
a343 1
				extmem += im->size;
a345 2
	cnvmem /= 1024;
	extmem /= 1024;
d364 1
a364 1
			p->type, (u_int)p->addr, (u_int)p->size / 1024);
@


1.34.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.34 2000/03/05 18:40:59 niklas Exp $	*/
d136 1
a136 1
	mp->size = (m2 & 0xffff) * 64L * 1024;
d262 1
a262 1
	u_int64_t ram;
d340 1
a340 2
				cnvmem = max(cnvmem,
				    im->addr + im->size) / 1024;
d342 1
a342 1
				extmem += im->size / 1024;
d345 2
d364 2
a365 3
		printf("Region %ld: type %u at 0x%x for %uKB\n", 
		    (long)(p - tm), p->type, (u_int)p->addr, 
		    (u_int)(p->size / 1024));
@


1.34.10.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.34.10.1 2002/06/11 03:35:55 art Exp $	*/
d5 1
a5 1
 * Copyright (c) 1997-1999 Tobias Weingartner
a75 1
	void *info;
a76 1
	info = getEBDAaddr();
d103 4
d111 1
a111 4
 * This should work for more than 64MB on most
 * modern machines.  However, there is always
 * an exception, the older IBM machine do not
 * like this call.
d117 1
a117 2
	int rc, m1, m2, m3, m4;
	u_int8_t *info;
d119 3
a121 14
	/* Test for possibility of 0xE801 */
	info =  getSYSCONFaddr();
	if(!info) return(NULL);
	/* XXX - Should test model/submodel/rev here */
	printf("model(%d,%d,%d)", info[2], info[3], info[4]);

	/* Check for 94 or later bios */
	info = (void *)0xFFFFB;
	if(info[0] == '9' && info[1] <= '3') return(NULL);

	/* We might have this call */
	__asm __volatile(DOINT(0x15) "; mov %%ax, %%si; setc %b0"
		: "=a" (rc), "=S" (m1), "=b" (m2), "=c" (m3), "=d" (m4)
		: "0" (0xE801));
d123 1
a123 1
	/* Test for failure */
a125 6

	/* Fixup for screwed up machines */
	if(m1 == 0){
		m1 = m3;
		m2 = m4;
	}
d309 1
d311 1
d313 1
a313 4
	/* XXX - gotta peephole optimize the list */

	/* Remove APM needed RAM */
	apmfixmem();
a361 5
	/* libsa printf does not handle quad args, so we use long
	 * instead.  Note, since we're unlikely to support more than
	 * 4G of RAM on a x86 box, this not likely to cause a problem.
	 * If/when we do, libsa may need to be updated some...
	 */
d364 1
a364 1
		    (long)(p - tm), p->type, (u_int)p->addr,
d383 1
a383 1
			register int64_t sp = p->addr, ep = p->addr + p->size;
d421 1
a421 1
			register int64_t sp = p->addr, ep = p->addr + p->size;
@


1.33
log
@Change extmem counter to include *all* extended memory segments.

Obviously, the kernel does not (and can not) know where the ACPI and such
pages are, since the boot -> kernel API does not support passing the
information.

This will stomp on them, once again, but we can NOT limit half the PCs
in existance to only 64MB of RAM.

Approved by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.32 1999/08/25 00:54:19 mickey Exp $	*/
a314 4
	/* Register in global var */
	addbootarg(BOOTARG_MEMMAP, 
		(pm - bios_memmap + 1) * sizeof(*bios_memmap), bios_memmap);

d456 10
@


1.33.4.1
log
@First SMP branch commit.  Probe SMP systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.33 1999/09/30 06:29:57 downsj Exp $	*/
d43 1
@


1.33.4.2
log
@Use shared (with kernel) header.  Feed MP info to kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.33.4.1 2000/02/19 17:53:10 niklas Exp $	*/
d352 1
a352 1
	printf("a20=o%s]", checkA20()? "n" : "ff!");
@


1.33.4.3
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d314 4
a458 10
void
mem_pass()
{
	bios_memmap_t *p;

	for (p = bios_memmap; p->type != BIOS_MAP_END; p++)
		;
	addbootarg(BOOTARG_MEMMAP, (p - bios_memmap + 1) * sizeof *bios_memmap,
		bios_memmap);
}
@


1.33.4.4
log
@Merge in trunk
@
text
@d135 1
a135 1
	mp->size = (m2 & 0xffff) * 64L * 1024;
d261 1
a261 1
	u_int64_t ram;
d339 1
a339 2
				cnvmem = max(cnvmem,
				    im->addr + im->size) / 1024;
d341 1
a341 1
				extmem += im->size / 1024;
d344 2
d364 1
a364 1
			p->type, (u_int)p->addr, (u_int)(p->size / 1024));
@


1.33.4.5
log
@Sync the SMP branch with 3.3
@
text
@d5 1
a5 1
 * Copyright (c) 1997-1999 Tobias Weingartner
a74 1
	void *info;
a75 1
	info = getEBDAaddr();
d102 4
d110 1
a110 4
 * This should work for more than 64MB on most
 * modern machines.  However, there is always
 * an exception, the older IBM machine do not
 * like this call.
d116 1
a116 2
	int rc, m1, m2, m3, m4;
	u_int8_t *info;
d118 3
a120 14
	/* Test for possibility of 0xE801 */
	info =  getSYSCONFaddr();
	if(!info) return(NULL);
	/* XXX - Should test model/submodel/rev here */
	printf("model(%d,%d,%d)", info[2], info[3], info[4]);

	/* Check for 94 or later bios */
	info = (void *)0xFFFFB;
	if(info[0] == '9' && info[1] <= '3') return(NULL);

	/* We might have this call */
	__asm __volatile(DOINT(0x15) "; mov %%ax, %%si; setc %b0"
		: "=a" (rc), "=S" (m1), "=b" (m2), "=c" (m3), "=d" (m4)
		: "0" (0xE801));
d122 1
a122 1
	/* Test for failure */
a124 6

	/* Fixup for screwed up machines */
	if(m1 == 0){
		m1 = m3;
		m2 = m4;
	}
d308 1
d310 1
d312 1
a312 4
	/* XXX - gotta peephole optimize the list */

	/* Remove APM needed RAM */
	apmfixmem();
a360 5
	/* libsa printf does not handle quad args, so we use long
	 * instead.  Note, since we're unlikely to support more than
	 * 4G of RAM on a x86 box, this not likely to cause a problem.
	 * If/when we do, libsa may need to be updated some...
	 */
d362 2
a363 3
		printf("Region %ld: type %u at 0x%x for %uKB\n", 
		    (long)(p - tm), p->type, (u_int)p->addr,
		    (u_int)(p->size / 1024));
d381 1
a381 1
			register int64_t sp = p->addr, ep = p->addr + p->size;
d419 1
a419 1
			register int64_t sp = p->addr, ep = p->addr + p->size;
@


1.33.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.33.4.5 2003/03/27 23:26:56 niklas Exp $	*/
d16 5
@


1.33.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d64 1
a64 1
 * This is the "preferred" method.
d67 2
a68 1
bios_E820(bios_memmap_t *mp)
d109 2
a110 1
bios_E801(bios_memmap_t *mp)
d162 2
a163 1
bios_8800(bios_memmap_t *mp)
d188 2
a189 1
bios_int12(bios_memmap_t *mp)
d225 2
a226 1
addrprobe(u_int kloc)
d265 1
a265 1
 * routine, we are getting pretty desperate.  Hopefully nobody
d272 2
a273 1
badprobe(bios_memmap_t *mp)
d298 1
a298 1
memprobe(void)
d367 2
a368 1
dump_biosmem(bios_memmap_t *tm)
d395 2
a396 1
mem_delete(long sa, long ea)
d433 2
a434 1
mem_add(long sa, long ea)
d476 1
a476 1
mem_pass(void)
d483 1
a483 1
	    bios_memmap);
@


1.33.4.8
log
@Merge with the trunk
@
text
@d17 2
a18 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
d51 2
a52 2
	if (*p != *q)
		return 1;
d59 1
a59 1
	return st;
a74 1

d76 5
a80 5
		    : "=a" (sig), "=d" (rc), "=b" (off)
		    : "0" (0xE820), "1" (0x534d4150), "b" (off),
		      "c" (sizeof(*mp)), "D" (((u_int)mp) & 0xF)
		    : "cc", "memory");
		off = BIOS_regs.biosr_bx;
d82 6
a87 6
		if (rc & 0xff || sig != 0x534d4150)
			break;
		gotcha++;
		if (!mp->type)
			mp->type = BIOS_MAP_RES;
		mp++;
d91 1
a91 1
		return NULL;
d95 1
a95 1
	return mp;
d115 1
a115 2
	if (!info)
		return NULL;
d121 1
a121 2
	if (info[0] == '9' && info[1] <= '3')
		return NULL;
d125 2
a126 2
	    : "=a" (rc), "=S" (m1), "=b" (m2), "=c" (m3), "=d" (m4)
	    : "0" (0xE801));
d129 2
a130 2
	if (rc & 0xff)
		return NULL;
d133 1
a133 1
	if (m1 == 0) {
d165 1
a165 1
	    : "=c" (rc), "=a" (mem) : "a" (0x8800));
d167 2
a168 2
	if (rc & 0xff)
		return NULL;
d232 1
a232 1
	for (i = 0; i < NENTS(addrprobe_pat); i++) {
d234 1
a234 1
		if (*loc != addrprobe_pat[i])
d241 1
a241 1
		for (i = 0; i < NENTS(addrprobe_pat); i++) {
d247 2
a248 2
		for (i = 0; i < NENTS(addrprobe_pat); i++) {
			if (loc[i] != addrprobe_pat[i])
d278 2
a279 2
	for (ram = 1024; ram < 512 * 1024; ram += 4)
		if (addrprobe(ram))
d302 1
a302 1
	if ((pm = bios_E820(bios_memmap)) == NULL) {
d306 1
a306 1
		if (pm == NULL)
d309 1
a309 1
		if (pm == NULL)
d311 2
a312 2
		if (pm == NULL) {
			printf(" No Extended memory detected.");
d329 1
a329 1
	for (im = bios_memmap; im->type != BIOS_MAP_END; im++) {
d347 1
a347 1
			if (im->addr < IOM_BEGIN)
d350 1
a350 1
			if (im->addr >= IOM_END)
d366 1
a366 1
	if (tm == NULL)
d374 2
a375 2
	for (p = tm; p->type != BIOS_MAP_END; p++) {
		printf("Region %ld: type %u at 0x%x for %uKB\n",
d379 1
a379 1
		if (p->type == BIOS_MAP_FREE)
d398 2
a399 2
				bcopy(p + 1, p, (char *)bios_memmap +
				    sizeof(bios_memmap) - (char *)p);
d411 3
a413 3
				bcopy(p, p + 1, (char *)bios_memmap +
				    sizeof(bios_memmap) - (char *)p -
				    sizeof(bios_memmap[0]));
d446 2
a447 2
				bcopy(p, p + 1, (char *)bios_memmap +
				    sizeof(bios_memmap) - (char *)(p - 1));
@


1.33.4.9
log
@fold out -smp branch changes from i386/stand. use the -current stat bits.
@
text
@a38 1

d359 1
a359 1
	printf("a20=o%s] ", checkA20()? "n" : "ff!");
@


1.32
log
@give better support to the bios memory maps.
provide memory maps editing through the machine memory command.
rearrange probing in machdep, so it provides less output,
also giving a shot for apm to fix the memory maps.
changes to kernel are minimal, only that is required due
to the api version bits addition and such cosmetic changes.
tested on all critical kernel,boot combinations; niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.31 1999/01/24 16:07:39 niklas Exp $	*/
d294 1
d326 1
a326 1
		/* Count only "good" memory chunks 4K and up in size */
d345 2
a346 2
			if(im->addr == IOM_END)
				extmem = im->size;
@


1.31
log
@The E801 probe has several problems.  Disable for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.30 1998/08/31 20:53:10 mickey Exp $	*/
d4 2
a5 1
 * Copyright (c) 1997 Tobias Weingartner, Michael Shalayeff
a42 1
bios_memmap_t *memory_map;
d52 2
a53 2
	char *p = (char *)0x100000;
	char *q = (char *)0x000000;
d90 1
a90 2
			mp->size >>= 10; /* / 1024 */
			if (mp->type == 0)
d98 1
a98 1
	printf(" 0x15[E820]");
d127 1
a127 1
	printf(" 0x15[E801]");
d131 1
a131 1
	mp->size = (m1 & 0xffff);
d136 1
a136 1
	mp->size = (m2 & 0xffff) * 64;
d160 1
a160 1
	printf(" 0x15[8800]");
d164 1
a164 1
	mp->size = mem & 0xffff;
d180 1
a180 1
	printf(" 0x12");
d186 1
a186 1
	mp->size = mem & 0xffff;
d264 1
a264 1
	printf(" Scan");
d276 1
a276 1
	mp->size = ram - 1024;
d283 1
d288 1
d290 3
a292 1
	printf("Probing memory:");
d308 1
a308 3
#ifdef DEBUG
	printf("\n");
#endif
d310 4
a316 2
	memory_map = bios_memmap; /* XXX for 'machine mem' command only */
	printf("memory:");
d318 5
a322 1
	/* XXX - Compatibility, remove later */
d326 16
a341 4
		if ((im->type == BIOS_MAP_FREE) && (im->size >= 4)) {
			printf(" %luK", (u_long)im->size);

			/* We ignore "good" memory in the 640K-1M hole */
d343 3
a345 3
				cnvmem += im->size;
			if(im->addr >= IOM_END)
				extmem += im->size;
d348 2
d352 69
a420 4
	if(checkA20())
		printf(" [A20 on]");
	else
		printf(" [A20 off!]");
d422 35
a456 1
	printf("\n");
d458 1
@


1.30
log
@better debug printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.29 1998/06/08 19:27:33 mickey Exp $	*/
d104 5
d122 1
a122 1
		: "=a" (m1), "=c" (rc), "=d" (m2) : "0" (0xE801));
d142 1
a142 1

d293 1
d296 1
@


1.29
log
@use named constatnts
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.28 1998/06/08 18:56:45 mickey Exp $	*/
d99 1
a99 1
	printf("0x15[E820]");
d123 1
a123 1
	printf("0x15[E801]");
d156 1
a156 1
	printf("0x15[8800]");
d176 1
a176 1
	printf(", 0x12\n");
d260 1
a260 1
	printf("Scan");
d284 1
a284 1
	printf("Probing memory: ");
d294 1
a294 1
			printf ("No Extended memory detected.");
@


1.28
log
@typos
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.27 1998/04/18 07:39:54 deraadt Exp $	*/
d37 1
d316 1
a316 1
			if(im->addr < 0xA0000)
d318 1
a318 1
			if(im->addr >= 0x100000)
@


1.27
log
@i386 bootblocks that work for 2.3. A tale too long to tell
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.26 1998/02/24 22:06:56 weingart Exp $	*/
d250 1
a250 1
 * XXX - Does not detect aliases memory.
d310 1
a310 1
		/* Count only "good" memory chunks 4K an up in size */
@


1.26
log
@Changes/updates to /boot stuff.  More to come.
Fixes many divide by zero and pointer bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.25 1997/11/30 21:51:47 mickey Exp $	*/
d201 5
a210 5
	static const u_int pat[] = {
		0x00000000, 0xFFFFFFFF,
		0x01010101, 0x10101010,
		0x55555555, 0xCCCCCCCC
	};
d212 1
a212 1
	u_int save[NENTS(pat)];
d219 3
a221 3
	for(i = 0; i < NENTS(pat); i++){
		*loc = pat[i];
		if(*loc != pat[i])
d228 1
a228 1
		for(i = 0; i < NENTS(pat); i++) {
d230 1
a230 1
			loc[i] = pat[i];
d234 2
a235 2
		for(i = 0; i < NENTS(pat); i++) {
			if(loc[i] != pat[i])
d277 1
d281 1
a281 2
	static bios_memmap_t bm[32];	/* This is easier */
	bios_memmap_t *pm = bm, *im;
d285 2
a286 2
	if(!(pm = bios_E820(bm))) {
		im = bios_int12(bm);
d302 3
a304 2
	addbootarg(BOOTARG_MEMMAP, (pm - bm + 1) * sizeof(*bm), bm);
	memory_map = bm; /* XXX for 'machine mem' command only */
d309 1
a309 1
	for(im = bm; im->type != BIOS_MAP_END; im++) {
@


1.25
log
@big diskinfo changes from toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.24 1997/10/23 15:13:30 weingart Exp $	*/
a39 1
static int addrprobe __P((u_int));
d43 24
d309 2
a310 1
		if (im->type == BIOS_MAP_FREE) {
d313 2
a314 1
			if(im->addr < 0x100000)
d316 1
a316 1
			else
d320 7
@


1.24
log
@Better BIOS diskprobe.  Cleanup and re-org by mickey.
Fix bug in BIOS memprobe.  Cleanup and re-org by mickey.
Do checksum of HD devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.23 1997/10/22 23:34:40 mickey Exp $	*/
d281 1
a281 1
	printf("mem0:");
@


1.23
log
@newer, better stuff; some parts by toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.21 1997/10/22 00:05:07 mickey Exp $	*/
a258 1
	int total = 0;
d283 2
a284 1
	/* Get total free memory */
a286 1
			total += im->size;
d288 5
a295 10

	/* XXX - Compatibility, remove later */
	for(im = bm; im->type != BIOS_MAP_END; im++)
		if ((im->addr & 0xFFFFF) == im->addr &&
		   im->type == BIOS_MAP_FREE) {
			cnvmem = im->size; 
			break;		/* Take the first region */
		}

	extmem = total - cnvmem;
@


1.22
log
@Cleanup.
@
text
@d279 3
a282 1
	memory_map = bm;
@


1.21
log
@remap  0-->reserved; toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.20 1997/10/21 23:47:26 mickey Exp $	*/
a278 2
	/* Register in global var */
	addbootarg(BOOTARG_MEMMAP, (pm - bm + 1) * sizeof(*bm), bm);
d280 1
@


1.20
log
@fix by toby again
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.19 1997/10/20 20:20:45 mickey Exp $	*/
d67 2
@


1.19
log
@change types
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.18 1997/10/20 14:56:09 mickey Exp $	*/
d37 1
a42 1
u_int memap_size = 0;
d52 1
a52 1
	int rc = 0, off = 0, sig;
d55 1
a55 1
		BIOS_regs.biosr_es = ((unsigned)(mp) >> 4);
d59 1
a59 1
				  "c" (sizeof(*mp)), "D" (((unsigned)mp) & 0xF)
d64 2
a65 1
				return (NULL);
d70 3
d74 1
a74 1

d96 1
a96 1

d98 1
a98 1

d129 1
a129 1

d131 1
a131 1

d149 1
a149 1

d151 1
a151 1

d233 1
a233 1

d235 1
d258 1
a258 1

d260 1
a260 1

d262 10
a271 6
		pm = bios_E801(pm);
		if(!pm)
			pm = bios_8800(pm);
		if(!pm)
			pm = badprobe(pm);
		pm = bios_int12(pm);
d273 3
a275 1

d278 2
a279 3
	memory_map = bm;
	memap_size = pm - bm + 1;
	printf("\nmem0:");
d285 1
a285 1
			printf(" %luK", (long)im->size);
@


1.18
log
@even better memprobe
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.17 1997/10/20 14:47:42 mickey Exp $	*/
d41 2
a42 1
struct _bios_memmap *memory_map;
d48 1
a48 1
static __inline struct _bios_memmap *
d50 1
a50 1
	register struct _bios_memmap *mp;
d79 1
a79 1
static __inline struct _bios_memmap *
d81 1
a81 1
	register struct _bios_memmap *mp;
d114 1
a114 1
static __inline struct _bios_memmap *
d116 1
a116 1
	register struct _bios_memmap *mp;
d140 1
a140 1
static __inline struct _bios_memmap *
d142 1
a142 1
	struct _bios_memmap *mp;
d150 1
a150 1
	/* Fill out a _bios_memmap */
d224 1
a224 1
struct _bios_memmap *
d226 1
a226 1
	register struct _bios_memmap *mp;
d250 2
a251 2
	static struct _bios_memmap bm[32];	/* This is easier */
	struct _bios_memmap *pm = bm, *im;
d268 1
@


1.17
log
@get ready for the fix in memprobe
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.16 1997/10/17 18:46:58 weingart Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997 Tobias Weingartner
d40 2
a41 14
u_int cnvmem, extmem;		/* XXX - remove */
bios_memmap_t *memory_map;

struct E820_desc_t {
	u_int32_t addr_lo;
	u_int32_t addr_hi;
	u_int32_t size_lo;
	u_int32_t size_hi;
	u_int32_t type;
} __attribute__ ((packed));
static struct E820_desc_t Desc;


#define E820_MAX_MAPENT	10
d47 3
a49 2
bios_memmap_t *
bios_E820()
d51 1
a51 4
	static bios_memmap_t bm[E820_MAX_MAPENT];		/* This is easier */
	int E820Present = 0;
	int eax = 0, count = 0;
	volatile int ebx = 0;
d54 15
a68 41
		BIOS_regs.biosr_es = ((unsigned)(&Desc) >> 4);
		__asm __volatile(
			"movl %2, %%ebx\n\t"
			"movl $0x534D4150, %%edx\n\t"
			DOINT(0x15) "\n\t"
			"movl %%eax, %%edx\n\t"
			"setc %b0\n\t"
			"movzbl %b0, %0\n\t"
			"cmpl $0x534D4150, %%edx\n\t"
			"je 1f\n\t"
			"incl %%eax\n\t"
			"1:\n\t"
			: "=a" (eax)
			: "0" (0xE820),
			  "1" (ebx),
			  "c" (sizeof(Desc)),
			  "D" ((unsigned)(&Desc) & 0xF)
			: "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi", "cc", "memory");
			ebx = BIOS_regs.biosr_bx;

			if(eax) break;		/* Not present, or done */

			/* We are ignoring the upper 32 bits in the 64 bit
			 * integer returned.  If anyone has a PC where the
			 * upper 32 bits are not zeros, *please* tell me! ;)
			 *
			 * NOTE: the BIOS_MAP_* numbers are the same, save for
			 * the "zero" case, which we remap to reserved.
			 */
			bm[count].addr = Desc.addr_lo;
			bm[count].size = Desc.size_lo;
			bm[count].type = (Desc.type)?Desc.type:BIOS_MAP_RES;

			E820Present = 1;
	} while((++count < E820_MAX_MAPENT) && (ebx != 0));	/* Do not re-oder! */

	if(E820Present){
		printf("int 0x15 [E820]\n");
		bm[count].type = BIOS_MAP_END;
		return(bm);
	}
d70 1
a70 1
	return(NULL);
a72 1

d78 3
a80 2
bios_memmap_t *
bios_E801()
d82 1
a82 2
	static bios_memmap_t bm[3];
	int eax, edx = 0;
d85 2
a86 7
	__asm __volatile(
		DOINT(0x15) "\n\t"
		"setc %b0\n\t"
		"movzbl %b0, %0\n\t"
		: "=a" (eax)
		: "a" (0xE801)
		);
d89 2
a90 21
	if(!eax){
		printf("int 0x15 [E801], ");

		__asm __volatile(
			DOINT(0x15) "\n\t"
			: "=a" (eax), "=d" (edx)
			: "a" (0xE801)
			);

		/* Make sure only valid bits */
		eax &= 0xFFFF;
		edx &= 0xFFFF;

		/* Fill out BIOS map */
		bm[0].addr = (1024 * 1024);			/* 1MB */
		bm[0].size = eax * 1024;
		bm[0].type = BIOS_MAP_FREE;

		bm[1].addr = (1024 * 1024) * 16;	/* 16MB */
		bm[1].size = (edx * 1024) * 64;
		bm[1].type = BIOS_MAP_FREE;
d92 1
a92 1
		bm[2].type = BIOS_MAP_END;
d94 9
a102 2
		return(bm);
	}
d104 1
a104 1
	return(NULL);
d113 3
a115 2
bios_memmap_t *
bios_8800()
d117 1
a117 2
	static bios_memmap_t bm[2];
	int eax, mem;
d119 2
a120 8
	__asm __volatile(
		DOINT(0x15) "\n\t"
		"movl %%eax, %%ecx\n\t"
		"setc %b0\n\t"
		"movzbl %b0, %0\n\t"
		: "=a" (eax), "=c" (mem)
		: "a" (0x8800)
		);
d122 2
a123 1
	if(eax) return(NULL);
d125 1
a125 1
	printf("int 0x15 [8800], ");
d128 3
a130 5
	bm[0].addr = 1024*1024;		/* 1MB */
	bm[0].size = (mem & 0xFFFF) * 1024;
	bm[0].type = BIOS_MAP_FREE;

	bm[1].type = BIOS_MAP_END;
d132 1
a132 1
	return(bm);
a134 1

d139 3
a141 2
bios_memmap_t *
bios_int12()
a142 1
	static bios_memmap_t bm[2];
d145 1
a145 5
	printf("int 0x12\n");

	__asm __volatile(DOINT(0x12) : "=a" (mem)
			 :: "%ecx", "%edx", "cc");
	mem &= 0xffff;
d147 1
a147 4
	/* Fill out a BIOS_MAP */
	bm[0].addr = 0;
	bm[0].size = mem * 1024;
	bm[0].type = BIOS_MAP_FREE;
d149 4
a152 1
	bm[1].type = BIOS_MAP_END;
d154 1
a154 1
	return(bm);
a213 1

d223 3
a225 2
bios_memmap_t *
badprobe()
a226 1
	static bios_memmap_t bm[2];
d229 1
a229 1
	printf("Physical, ");
d235 1
a235 1
	for(ram = 1024; ram < 512*1024; ram += 4)
d239 3
a241 3
	bm[0].addr = 1024 * 1024;
	bm[0].size = (ram - 1024) * 1024;
	bm[0].type = BIOS_MAP_FREE;
d243 1
a243 3
	bm[1].type = BIOS_MAP_END;

	return(bm);
a245 41

int
count(map)
	bios_memmap_t *map;
{
	int i;

	for(i = 0; map[i].type != BIOS_MAP_END; i++) ;

	return(i);
}


bios_memmap_t *
combine(a, b)
	bios_memmap_t *a, *b;
{
	bios_memmap_t *res;
	int size, i;

	/* Sanity checks */
	if(!b) return(a);
	if(!a) return(b);

	size = (count(a) + count(b) + 1) * sizeof(bios_memmap_t);
	res = alloc(size);

	/* Again */
	if(!res) return(NULL);		/* We are in deep doggie-doo */

	for(i = 0; a[i].type != BIOS_MAP_END; i++)
		res[i] = a[i];
	size = count(a);
	for(; b[i - size].type != BIOS_MAP_END; i++)
		res[i] = b[i - size];

	res[i].type = BIOS_MAP_END;
	return(res);
}


d249 3
a251 2
	bios_memmap_t *tm, *em, *bm;	/* total, extended, base */
	int count, total = 0;
a253 1
	tm = em = bm = NULL;
d255 7
a261 8
	tm = bios_E820();
	if(!tm){
		em = bios_E801();
		if(!em) em = bios_8800();
		if(!em) em = badprobe();
		bm = bios_int12();

		tm = combine(bm, em);
d264 1
d266 2
a267 2
	memory_map = tm;
	printf("mem0:");
d270 4
a273 5
	for(count = 0; tm[count].type != BIOS_MAP_END; count++) {
		if(tm[count].type == BIOS_MAP_FREE) {
			total += tm[count].size;

			printf(" %luKB", (long)tm[count].size/1024);
d279 5
a283 5
	cnvmem = extmem = 0;
	for(count = 0; tm[count].type != BIOS_MAP_END; count++) {
		if((tm[count].addr < 0xFFFFF) && (tm[count].type == BIOS_MAP_FREE)){

			cnvmem += tm[count].size; 
a284 1
		if((tm[count].addr > 0xFFFFF) && (tm[count].type == BIOS_MAP_FREE)){
d286 1
a286 5
			extmem += tm[count].size; 
		}
	}
	cnvmem /= 1024;
	extmem /= 1024;
a287 1

@


1.16
log
@Cleanup, make it all compile.
Move APM stuff to apmprobe.c
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.15 1997/10/17 15:03:28 weingart Exp $	*/
d388 1
a388 1
			printf(" %dKB", tm[count].size/1024);
@


1.15
log
@Use BIOS to probe for memory map.
Probe for BIOS supported disks.
Use BIOS to get geometry for supported disks.

All in preparation to passing the whole thing
to the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.14 1997/10/12 21:01:01 mickey Exp $	*/
d41 1
a41 1
struct BIOS_MAP *memory_map;
d59 1
a59 1
struct BIOS_MAP *
d62 1
a62 1
	static struct BIOS_MAP bm[E820_MAX_MAPENT];		/* This is easier */
d119 1
a119 1
struct BIOS_MAP *
d122 1
a122 1
	static struct BIOS_MAP bm[3];
d171 1
a171 1
struct BIOS_MAP *
d174 1
a174 1
	static struct BIOS_MAP bm[2];
d205 1
a205 1
struct BIOS_MAP *
d208 1
a208 1
	static struct BIOS_MAP bm[2];
d294 1
a294 1
struct BIOS_MAP *
d297 1
a297 1
	static struct BIOS_MAP bm[2];
d322 1
a322 1
	struct BIOS_MAP *map;
d332 1
a332 1
struct BIOS_MAP *
d334 1
a334 1
	struct BIOS_MAP *a, *b;
d336 1
a336 1
	struct BIOS_MAP *res;
d343 1
a343 1
	size = (count(a) + count(b) + 1) * sizeof(struct BIOS_MAP);
d363 1
a363 1
	struct BIOS_MAP *tm, *em, *bm;	/* total, extended, base */
@


1.14
log
@safe memprobe; preserve memory contents
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.13 1997/10/12 20:14:27 mickey Exp $	*/
d40 2
a41 1
u_int cnvmem, extmem;
d43 18
a60 2
void
memprobe()
d62 51
a112 1
	int ram;
d114 10
a123 3
	__asm __volatile(DOINT(0x12) : "=a" (cnvmem)
			 :: "%ecx", "%edx", "cc");
	cnvmem &= 0xffff;
d125 31
a155 1
	printf("%d Kb conventional memory.\n", cnvmem);
d157 1
a157 6
	/* probe extended memory
	 *
	 * There is no need to do this in assembly language.  This is
	 * much easier to debug in C anyways.
	 */
	for(ram = 1024; ram < 512*1024; ram += 4){
d159 1
a159 4
		if(!(ram % 64))
			printf("Probing memory: %d KB\r", ram-1024);
		if(addrprobe(ram))
			break;
d162 63
a224 2
	printf("%d Kb extended memory.\n", ram-1024);
	extmem = ram - 1024;
d227 1
d238 2
d284 124
@


1.13
log
@KNF; types
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.12 1997/09/17 17:56:10 mickey Exp $	*/
d85 1
a85 1
	__volatile u_int *loc, i;
d91 2
d97 1
d102 1
a102 1
			return (1);
d104 1
d106 14
a119 8
	/* Write address */
	for(i = 0; i < NENTS(pat); i++)
		loc[i] = pat[i];

	/* Read address */
	for(i = 0; i < NENTS(pat); i++)
		if(loc[i] != pat[i])
			return (1);
d121 1
a121 1
	return (0);
@


1.12
log
@pass cnvmem,extmem the old way they were....
don't put 'em in biosvars
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.11 1997/09/02 17:00:42 mickey Exp $	*/
d39 1
a39 1
static int addrprobe __P((int));
d81 6
a86 3
static int addrprobe(int kloc){
	volatile int *loc, i;
	static const int pat[] = {
@


1.11
log
@whine about conv memory
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.10 1997/08/22 20:13:44 mickey Exp $	*/
d40 1
d47 1
a47 1
	__asm __volatile(DOINT(0x12) : "=a" (BIOS_vars.bios_cnvmem)
d49 1
a49 1
	BIOS_vars.bios_cnvmem &= 0xffff;
d51 1
a51 1
	printf("%d Kb conventional memory.\n", BIOS_vars.bios_cnvmem);
d67 1
a67 1
	BIOS_vars.bios_extmem = ram - 1024;
@


1.10
log
@put values into BIOS_vars so kernel will get 'em soon
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.9 1997/08/12 19:12:09 mickey Exp $	*/
d50 2
d65 1
a65 1
	printf("Found %d KB extended memory.\n", ram-1024);
@


1.9
log
@better regs
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.8 1997/08/07 01:11:07 mickey Exp $	*/
d46 3
a48 2
	__asm __volatile(DOINT(0x12) : "=a" (cnvmem) :: "%ecx", "%edx", "cc");
	cnvmem &= 0xffff;
d64 1
a64 1
	extmem = ram - 1024;
@


1.8
log
@call BIOS from C
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.7 1997/08/05 16:26:05 weingart Exp $	*/
d46 1
a46 2
	__asm volatile(DOINT(0x12) "\n\t" : "=a" (cnvmem));

@


1.7
log
@Less verbose.
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.6 1997/08/04 21:49:42 mickey Exp $	*/
d36 1
a37 1
#include "biosdev.h"
d46 3
a48 1
	cnvmem = biosmem();
d57 1
a57 1
		if(!(ram % 1024))
@


1.6
log
@comment typo
clean syntax
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.5 1997/04/17 17:21:16 weingart Exp $	*/
d55 4
a58 2
		printf("Probing memory: %d KB\r", ram-1024);
		if(addrprobe(ram)) break;
d61 1
a61 1
	printf("\n");
@


1.5
log
@New memprobe for weird machines... please test.
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.4 1997/04/15 06:43:15 mickey Exp $	*/
d72 1
a72 1
 * BTW: These machines are pretty boken IMHO.
d76 1
a76 1
	static int pat[] = {
d86 1
a86 1
	for(i = 0; i < sizeof(pat)/sizeof(pat[0]); i++){
d88 2
a89 1
		if(*loc != pat[i]) return(1);
d93 1
a93 1
	for(i = 0; i < sizeof(pat)/sizeof(pat[0]); i++){
a94 1
	}
d97 3
a99 3
	for(i = 0; i < sizeof(pat)/sizeof(pat[0]); i++){
		if(loc[i] != pat[i]) return(1);
	}
d101 1
a101 1
	return(0);
@


1.4
log
@copyright to toby (;
@
text
@d1 1
a1 1
/*	$OpenBSD: memprobe.c,v 1.3 1997/04/09 08:39:39 mickey Exp $	*/
d50 1
a50 1
	 * There is no need to do this in assembly language.  This are
d67 6
d89 10
@


1.3
log
@emulate bios calls. more debugging stuff. some fixes.
@
text
@d1 33
a33 1
/*	$OpenBSD: memprobe.c,v 1.2 1997/03/31 23:06:30 mickey Exp $	*/
@


1.2
log
@commit all my mods to the last imported libsa stuff....
including:
- disklabel support;
- better boot cmd line
- smaller size (using some compilation switches ;)
- no more relocations in /boot, it's loaded in the place;
- better disk performance (maybe were already in there)
- installboot -n does not require write perms for device
- more debugs
- missing parts in libsa (such as cd9660 and so)
- i don't like 2 files for exec_i386 (sorry, toby, let's discuss maybe?)
tricks and tails:
- joined .text and .data (saves you a page)
- prot mode switching still in biosboot (it's freezed for awhile)
- biosdisk internals changed
- biosdev is not passed propery to the kernel (i'll fix it soon)
- sure i missed smth here to note (use the source, Luke!)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d14 1
a14 2
	cnvmem = biosmem(0);
	extmem = biosmem(1);
@


1.1
log
@Initial /boot stuff (from Mickey)
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d4 2
a5 1
#include <libsa.h>
d7 24
a56 18

/* memprobe():  return probed memory size in KB for extended memory
 *
 * There is no need to do this in assembly language.  This are
 * much easier to debug in C anyways.
 */
int memprobe(void){
	int ram;

	for(ram = 1024; ram < 512*1024; ram += 4){

		printf("Probing memory: %d KB\r", ram-1024);
		if(addrprobe(ram)) break;
	}

	printf("\n");
	return(ram-1024);
}
@

