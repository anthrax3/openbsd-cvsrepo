head	1.95;
access;
symbols
	OPENBSD_6_1:1.95.0.4
	OPENBSD_6_1_BASE:1.95
	OPENBSD_6_0:1.92.0.4
	OPENBSD_6_0_BASE:1.92
	OPENBSD_5_9:1.92.0.2
	OPENBSD_5_9_BASE:1.92
	OPENBSD_5_8:1.89.0.8
	OPENBSD_5_8_BASE:1.89
	OPENBSD_5_7:1.89.0.2
	OPENBSD_5_7_BASE:1.89
	OPENBSD_5_6:1.89.0.4
	OPENBSD_5_6_BASE:1.89
	OPENBSD_5_5:1.88.0.4
	OPENBSD_5_5_BASE:1.88
	OPENBSD_5_4:1.87.0.2
	OPENBSD_5_4_BASE:1.87
	OPENBSD_5_3:1.86.0.2
	OPENBSD_5_3_BASE:1.86
	OPENBSD_5_2:1.84.0.6
	OPENBSD_5_2_BASE:1.84
	OPENBSD_5_1_BASE:1.84
	OPENBSD_5_1:1.84.0.4
	OPENBSD_5_0:1.84.0.2
	OPENBSD_5_0_BASE:1.84
	OPENBSD_4_9:1.77.0.4
	OPENBSD_4_9_BASE:1.77
	OPENBSD_4_8:1.77.0.2
	OPENBSD_4_8_BASE:1.77
	OPENBSD_4_7:1.76.0.6
	OPENBSD_4_7_BASE:1.76
	OPENBSD_4_6:1.76.0.8
	OPENBSD_4_6_BASE:1.76
	OPENBSD_4_5:1.76.0.4
	OPENBSD_4_5_BASE:1.76
	OPENBSD_4_4:1.76.0.2
	OPENBSD_4_4_BASE:1.76
	OPENBSD_4_3:1.72.0.4
	OPENBSD_4_3_BASE:1.72
	OPENBSD_4_2:1.72.0.2
	OPENBSD_4_2_BASE:1.72
	OPENBSD_4_1:1.70.0.2
	OPENBSD_4_1_BASE:1.70
	OPENBSD_4_0:1.69.0.10
	OPENBSD_4_0_BASE:1.69
	OPENBSD_3_9:1.69.0.8
	OPENBSD_3_9_BASE:1.69
	OPENBSD_3_8:1.69.0.6
	OPENBSD_3_8_BASE:1.69
	OPENBSD_3_7:1.69.0.4
	OPENBSD_3_7_BASE:1.69
	OPENBSD_3_6:1.69.0.2
	OPENBSD_3_6_BASE:1.69
	SMP_SYNC_A:1.68
	SMP_SYNC_B:1.68
	OPENBSD_3_5:1.68.0.2
	OPENBSD_3_5_BASE:1.68
	OPENBSD_3_4:1.61.0.2
	OPENBSD_3_4_BASE:1.61
	UBC_SYNC_A:1.55
	OPENBSD_3_3:1.54.0.6
	OPENBSD_3_3_BASE:1.54
	OPENBSD_3_2:1.54.0.4
	OPENBSD_3_2_BASE:1.54
	OPENBSD_3_1:1.54.0.2
	OPENBSD_3_1_BASE:1.54
	UBC_SYNC_B:1.54
	UBC:1.52.0.18
	UBC_BASE:1.52
	OPENBSD_3_0:1.52.0.16
	OPENBSD_3_0_BASE:1.52
	OPENBSD_2_9:1.52.0.14
	OPENBSD_2_9_BASE:1.52
	OPENBSD_2_8:1.52.0.12
	OPENBSD_2_8_BASE:1.52
	OPENBSD_2_7:1.52.0.10
	OPENBSD_2_7_BASE:1.52
	SMP:1.52.0.8
	SMP_BASE:1.52
	kame_19991208:1.52
	OPENBSD_2_6:1.52.0.6
	OPENBSD_2_6_BASE:1.52
	OPENBSD_2_5:1.52.0.4
	OPENBSD_2_5_BASE:1.52
	OPENBSD_2_4:1.52.0.2
	OPENBSD_2_4_BASE:1.52
	OPENBSD_2_3:1.51.0.2
	OPENBSD_2_3_BASE:1.51
	OPENBSD_2_2:1.46.0.2
	OPENBSD_2_2_BASE:1.46
	OPENBSD_2_1:1.15.0.2
	OPENBSD_2_1_BASE:1.15;
locks; strict;
comment	@ * @;


1.95
date	2016.09.18.15.13.10;	author jsing;	state Exp;
branches;
next	1.94;
commitid	s8Pq67pV4HEOyHxM;

1.94
date	2016.09.11.17.52.47;	author jsing;	state Exp;
branches;
next	1.93;
commitid	OIt9eg6fQy6pFToA;

1.93
date	2016.09.11.15.54.11;	author jsing;	state Exp;
branches;
next	1.92;
commitid	m28Q0aUDbVqwDb3p;

1.92
date	2015.10.01.20.28.12;	author krw;	state Exp;
branches;
next	1.91;
commitid	clda1fEydcUmLYPS;

1.91
date	2015.09.19.21.07.04;	author semarie;	state Exp;
branches;
next	1.90;
commitid	9KMPSlP02LD1SpJP;

1.90
date	2015.09.02.04.09.24;	author yasuoka;	state Exp;
branches;
next	1.89;
commitid	1T0xGkKNIiRZnTmz;

1.89
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.88;

1.88
date	2013.12.28.02.40.41;	author jsing;	state Exp;
branches;
next	1.87;

1.87
date	2013.03.23.16.08.29;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2012.11.01.00.55.38;	author jsing;	state Exp;
branches;
next	1.85;

1.85
date	2012.10.31.13.55.58;	author jsing;	state Exp;
branches;
next	1.84;

1.84
date	2011.07.19.01.08.35;	author krw;	state Exp;
branches;
next	1.83;

1.83
date	2011.03.17.12.53.44;	author krw;	state Exp;
branches;
next	1.82;

1.82
date	2011.03.15.14.00.26;	author krw;	state Exp;
branches;
next	1.81;

1.81
date	2011.03.14.22.14.40;	author krw;	state Exp;
branches;
next	1.80;

1.80
date	2011.03.13.00.13.53;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2011.03.11.21.08.25;	author krw;	state Exp;
branches;
next	1.78;

1.78
date	2011.03.08.17.24.31;	author krw;	state Exp;
branches;
next	1.77;

1.77
date	2010.08.11.13.11.57;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2008.08.12.22.48.31;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2008.08.04.15.58.13;	author reyk;	state Exp;
branches;
next	1.74;

1.74
date	2008.06.25.15.32.18;	author reyk;	state Exp;
branches;
next	1.73;

1.73
date	2008.06.25.15.26.44;	author reyk;	state Exp;
branches;
next	1.72;

1.72
date	2007.05.27.00.57.17;	author tom;	state Exp;
branches;
next	1.71;

1.71
date	2007.04.04.14.36.05;	author jmc;	state Exp;
branches;
next	1.70;

1.70
date	2006.10.12.12.14.17;	author krw;	state Exp;
branches;
next	1.69;

1.69
date	2004.06.23.00.21.49;	author tom;	state Exp;
branches;
next	1.68;

1.68
date	2004.03.09.19.12.12;	author tom;	state Exp;
branches;
next	1.67;

1.67
date	2003.11.27.00.33.24;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2003.09.20.05.23.42;	author fgsch;	state Exp;
branches;
next	1.65;

1.65
date	2003.09.19.04.17.00;	author fgsch;	state Exp;
branches;
next	1.64;

1.64
date	2003.09.18.08.24.11;	author fgsch;	state Exp;
branches;
next	1.63;

1.63
date	2003.09.18.06.55.55;	author fgsch;	state Exp;
branches;
next	1.62;

1.62
date	2003.09.16.03.43.11;	author fgsch;	state Exp;
branches;
next	1.61;

1.61
date	2003.09.11.17.39.35;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2003.08.11.06.23.09;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.27.05.13.19;	author weingart;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.03.20.22.11;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2003.05.31.15.17.43;	author weingart;	state Exp;
branches;
next	1.56;

1.56
date	2003.05.31.00.15.29;	author weingart;	state Exp;
branches;
next	1.55;

1.55
date	2003.04.17.03.43.18;	author drahn;	state Exp;
branches;
next	1.54;

1.54
date	2002.03.14.03.15.54;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	2002.03.14.01.26.34;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	98.06.11.02.30.57;	author mickey;	state Exp;
branches
	1.52.8.1
	1.52.18.1;
next	1.51;

1.51
date	98.04.18.07.39.42;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	98.02.24.22.06.46;	author weingart;	state Exp;
branches;
next	1.49;

1.49
date	97.11.30.21.51.38;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	97.11.05.02.02.25;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	97.11.01.16.35.19;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	97.10.28.23.33.49;	author deraadt;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	97.10.26.22.33.00;	author mickey;	state Exp;
branches;
next	1.44;

1.44
date	97.10.25.02.07.08;	author weingart;	state Exp;
branches;
next	1.43;

1.43
date	97.10.24.22.49.58;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	97.10.24.17.16.53;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	97.10.24.01.38.50;	author weingart;	state Exp;
branches;
next	1.40;

1.40
date	97.10.23.15.13.26;	author weingart;	state Exp;
branches;
next	1.39;

1.39
date	97.10.22.23.34.36;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	97.10.18.00.33.15;	author weingart;	state Exp;
branches;
next	1.37;

1.37
date	97.10.17.15.03.21;	author weingart;	state Exp;
branches;
next	1.36;

1.36
date	97.10.07.08.56.19;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	97.09.24.22.42.59;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	97.09.17.17.50.40;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	97.09.03.13.56.11;	author weingart;	state Exp;
branches;
next	1.32;

1.32
date	97.09.03.04.59.58;	author weingart;	state Exp;
branches;
next	1.31;

1.31
date	97.09.03.04.32.43;	author weingart;	state Exp;
branches;
next	1.30;

1.30
date	97.09.02.23.06.54;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	97.09.02.22.42.25;	author weingart;	state Exp;
branches;
next	1.28;

1.28
date	97.09.02.19.24.29;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	97.08.29.19.29.39;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	97.08.22.20.13.42;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	97.08.21.20.36.15;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	97.08.12.19.30.13;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	97.08.12.19.24.57;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	97.08.07.11.49.15;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	97.08.06.18.49.14;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	97.08.04.21.53.34;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	97.07.21.15.33.32;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	97.07.18.00.30.15;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	97.05.31.15.34.56;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	97.05.30.02.21.52;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	97.04.30.18.10.07;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	97.04.23.14.49.23;	author weingart;	state Exp;
branches;
next	1.13;

1.13
date	97.04.23.06.49.06;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.04.20.19.01.35;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.04.18.06.54.40;	author weingart;	state Exp;
branches;
next	1.10;

1.10
date	97.04.18.04.23.51;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.04.18.01.28.01;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.04.17.19.03.20;	author weingart;	state Exp;
branches;
next	1.7;

1.7
date	97.04.15.20.50.35;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.04.15.06.25.18;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.04.09.08.39.15;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.04.08.22.48.27;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.03.31.23.06.26;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	97.03.31.03.12.09;	author weingart;	state Exp;
branches;
next	1.1;

1.1
date	96.10.29.09.22.49;	author mickey;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	96.10.29.09.22.50;	author mickey;	state Exp;
branches;
next	;

1.46.2.1
date	97.11.02.08.29.03;	author deraadt;	state Exp;
branches;
next	;

1.52.8.1
date	2002.03.28.10.31.05;	author niklas;	state Exp;
branches;
next	1.52.8.2;

1.52.8.2
date	2003.05.13.19.42.09;	author ho;	state Exp;
branches;
next	1.52.8.3;

1.52.8.3
date	2003.06.07.11.11.38;	author ho;	state Exp;
branches;
next	1.52.8.4;

1.52.8.4
date	2004.02.19.10.48.43;	author niklas;	state Exp;
branches;
next	1.52.8.5;

1.52.8.5
date	2004.06.05.23.09.01;	author niklas;	state Exp;
branches;
next	;

1.52.18.1
date	2002.06.11.03.35.55;	author art;	state Exp;
branches;
next	1.52.18.2;

1.52.18.2
date	2003.05.19.21.45.12;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.95
log
@Fix a bug in the bounce buffer handling of BIOS disk I/O.

Currently, if a buffer crosses a 64KB boundary, a bounce buffer is
allocated, however it is assumed that this new buffer does not cross the
64KB boundary. In the case of i386 fdboot, it just so happens that (due to
the size of fdboot and heap allocations) UFS gets allocated a 4KB buffer
that crosses a 64KB boundary, then biosd_io() allocates a bounce buffer,
which also crosses a 64KB boundary. At this point the BIOS gets grumpy and
refuses to read from the disk.

Further clean up to come from tom@@.
@
text
@/*	$OpenBSD: biosdev.c,v 1.94 2016/09/11 17:52:47 jsing Exp $	*/

/*
 * Copyright (c) 1996 Michael Shalayeff
 * Copyright (c) 2003 Tobias Weingartner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/disklabel.h>
#include <isofs/cd9660/iso.h>
#include <lib/libsa/saerrno.h>
#include <machine/biosvar.h>
#include <machine/tss.h>

#include "biosdev.h"
#include "debug.h"
#include "disk.h"
#include "libsa.h"

#ifdef SOFTRAID
#include <dev/softraidvar.h>
#include <lib/libsa/softraid.h>
#include "softraid_i386.h"
#endif

static const char *biosdisk_err(u_int);
static int biosdisk_errno(u_int);

int CHS_rw (int, int, int, int, int, int, void *);
static int EDD_rw (int, int, u_int32_t, u_int32_t, void *);

static int biosd_io(int, bios_diskinfo_t *, u_int, int, void *);
static u_int findopenbsd(bios_diskinfo_t *, const char **);

extern int debug;
int bios_bootdev;
int bios_cddev = -1;		/* Set by srt0 if coming from CD */

struct EDD_CB {
	u_int8_t  edd_len;	/* size of packet */
	u_int8_t  edd_res1;	/* reserved */
	u_int8_t  edd_nblk;	/* # of blocks to transfer */
	u_int8_t  edd_res2;	/* reserved */
	u_int16_t edd_off;	/* address of buffer (offset) */
	u_int16_t edd_seg;	/* address of buffer (segment) */
	u_int64_t edd_daddr;	/* starting block */
};

/*
 * reset disk system
 */
static int
biosdreset(int dev)
{
	int rv;

	__asm volatile (DOINT(0x13) "; setc %b0" : "=a" (rv)
	    : "0" (0), "d" (dev) : "%ecx", "cc");

	return ((rv & 0xff)? rv >> 8 : 0);
}

/*
 * Fill out a bios_diskinfo_t for this device.
 * Return 0 if all ok.
 * Return 1 if not ok.
 */
int
bios_getdiskinfo(int dev, bios_diskinfo_t *pdi)
{
	u_int rv;

	/* Just reset, don't check return code */
	rv = biosdreset(dev);

#ifdef BIOS_DEBUG
	if (debug)
		printf("getinfo: try #8, 0x%x, %p\n", dev, pdi);
#endif
	__asm volatile (DOINT(0x13) "\n\t"
	    "setc %b0; movzbl %h1, %1\n\t"
	    "movzbl %%cl, %3; andb $0x3f, %b3\n\t"
	    "xchgb %%cl, %%ch; rolb $2, %%ch"
	    : "=a" (rv), "=d" (pdi->bios_heads),
	      "=c" (pdi->bios_cylinders),
	      "=b" (pdi->bios_sectors)
	    : "0" (0x0800), "1" (dev) : "cc");

#ifdef BIOS_DEBUG
	if (debug) {
		printf("getinfo: got #8\n");
		printf("disk 0x%x: %d,%d,%d\n", dev, pdi->bios_cylinders,
		    pdi->bios_heads, pdi->bios_sectors);
	}
#endif
	if (rv & 0xff)
		return 1;

	/* Fix up info */
	pdi->bios_number = dev;
	pdi->bios_heads++;
	pdi->bios_cylinders &= 0x3ff;
	pdi->bios_cylinders++;

	/* NOTE:
	 * This currently hangs/reboots some machines
	 * The IBM ThinkPad 750ED for one.
	 *
	 * Funny that an IBM/MS extension would not be
	 * implemented by an IBM system...
	 *
	 * Future hangs (when reported) can be "fixed"
	 * with getSYSCONFaddr() and an exceptions list.
	 */
	if (dev & 0x80 && (dev == 0x80 || dev == 0x81 || dev == bios_bootdev)) {
		int bm;

#ifdef BIOS_DEBUG
		if (debug)
			printf("getinfo: try #41, 0x%x\n", dev);
#endif
		/* EDD support check */
		__asm volatile(DOINT(0x13) "; setc %b0"
			 : "=a" (rv), "=c" (bm)
			 : "0" (0x4100), "b" (0x55aa), "d" (dev) : "cc");
		if (!(rv & 0xff) && (BIOS_regs.biosr_bx & 0xffff) == 0xaa55)
			pdi->bios_edd = (bm & 0xffff) | ((rv & 0xff) << 16);
		else
			pdi->bios_edd = -1;

#ifdef BIOS_DEBUG
		if (debug) {
			printf("getinfo: got #41\n");
			printf("disk 0x%x: 0x%x\n", dev, bm);
		}
#endif
		/*
		 * If extended disk access functions are not supported
		 * there is not much point on doing EDD.
		 */
		if (!(pdi->bios_edd & EXT_BM_EDA))
			pdi->bios_edd = -1;
	} else
		pdi->bios_edd = -1;

	/* Skip sanity check for CHS options in EDD mode. */
	if (pdi->bios_edd != -1)
		return 0;

	/* Sanity check */
	if (!pdi->bios_cylinders || !pdi->bios_heads || !pdi->bios_sectors)
		return 1;

	/* CD-ROMs sometimes return heads == 1 */
	if (pdi->bios_heads < 2)
		return 1;

	return 0;
}

/*
 * Read/Write a block from given place using the BIOS.
 */
int
CHS_rw(int rw, int dev, int cyl, int head, int sect, int nsect, void *buf)
{
	int rv;

	rw = rw == F_READ ? 2 : 3;
	BIOS_regs.biosr_es = (u_int32_t)buf >> 4;
	__asm volatile ("movb %b7, %h1\n\t"
	    "movb %b6, %%dh\n\t"
	    "andl $0xf, %4\n\t"
	    /* cylinder; the highest 2 bits of cyl is in %cl */
	    "xchgb %%ch, %%cl\n\t"
	    "rorb  $2, %%cl\n\t"
	    "orb %b5, %%cl\n\t"
	    "inc %%cx\n\t"
	    DOINT(0x13) "\n\t"
	    "setc %b0"
	    : "=a" (rv)
	    : "0" (nsect), "d" (dev), "c" (cyl),
	      "b" (buf), "m" (sect), "m" (head),
	      "m" (rw)
	    : "cc", "memory");

	return ((rv & 0xff)? rv >> 8 : 0);
}

static __inline int
EDD_rw(int rw, int dev, u_int32_t daddr, u_int32_t nblk, void *buf)
{
	int rv;
	volatile static struct EDD_CB cb;

	/* Zero out reserved stuff */
	cb.edd_res1 = 0;
	cb.edd_res2 = 0;

	/* Fill in parameters */
	cb.edd_len = sizeof(cb);
	cb.edd_nblk = nblk;
	cb.edd_seg = ((u_int32_t)buf >> 4) & 0xffff;
	cb.edd_off = (u_int32_t)buf & 0xf;
	cb.edd_daddr = daddr;

	/* if offset/segment are zero, punt */
	if (!cb.edd_seg && !cb.edd_off)
		return 1;

	/* Call extended read/write (with disk packet) */
	BIOS_regs.biosr_ds = (u_int32_t)&cb >> 4;
	__asm volatile (DOINT(0x13) "; setc %b0" : "=a" (rv)
	    : "0" ((rw == F_READ)? 0x4200: 0x4300),
	      "d" (dev), "S" ((int) (&cb) & 0xf) : "%ecx", "cc");
	return ((rv & 0xff)? rv >> 8 : 0);
}

/*
 * Read given sector, handling retry/errors/etc.
 */
int
biosd_io(int rw, bios_diskinfo_t *bd, u_int off, int nsect, void *buf)
{
	int dev = bd->bios_number;
	int j, error;
	void *bb, *bb1 = NULL;
	int bbsize = nsect * DEV_BSIZE;

	if (bd->flags & BDI_EL_TORITO) {	/* It's a CD device */
		dev &= 0xff;			/* Mask out this flag bit */

		/*
		 * sys/lib/libsa/cd9600.c converts 2,048-byte CD sectors
		 * to DEV_BSIZE blocks before calling the device strategy
		 * routine.  However, the El Torito spec says that the
		 * BIOS will work in 2,048-byte sectors.  So shift back.
		 */
		off /= (ISO_DEFAULT_BLOCK_SIZE / DEV_BSIZE);
		nsect /= (ISO_DEFAULT_BLOCK_SIZE / DEV_BSIZE);
	}

	/*
	 * Use a bounce buffer to not cross 64k DMA boundary, and to
	 * not access 1 MB or above.
	 */
	if (((((u_int32_t)buf) & ~0xffff) !=
	    (((u_int32_t)buf + bbsize) & ~0xffff)) ||
	    (((u_int32_t)buf) >= 0x100000)) {
		bb = bb1 = alloc(bbsize * 2);
		if ((((u_int32_t)bb) & ~0xffff) !=
		    (((u_int32_t)bb + bbsize - 1) & ~0xffff))
			bb = (void *)(((u_int32_t)bb + bbsize - 1) & ~0xffff);
		if (rw != F_READ)
			bcopy(buf, bb, bbsize);
	} else
		bb = buf;

	/* Try to do operation up to 5 times */
	for (error = 1, j = 5; j-- && error; ) {
		/* CHS or LBA access? */
		if (bd->bios_edd != -1) {
			error = EDD_rw(rw, dev, off, nsect, bb);
		} else {
			int cyl, head, sect;
			size_t i, n;
			char *p = bb;

			/* Handle track boundaries */
			for (error = i = 0; error == 0 && i < nsect;
			    i += n, off += n, p += n * DEV_BSIZE) {

				btochs(off, cyl, head, sect, bd->bios_heads,
				    bd->bios_sectors);

				if ((sect + (nsect - i)) >= bd->bios_sectors)
					n = bd->bios_sectors - sect;
				else
					n = nsect - i;

				error = CHS_rw(rw, dev, cyl, head, sect, n, p);

				/* ECC corrected */
				if (error == 0x11)
					error = 0;
			}
		}
		switch (error) {
		case 0x00:	/* No errors */
		case 0x11:	/* ECC corrected */
			error = 0;
			break;

		default:	/* All other errors */
#ifdef BIOS_DEBUG
			if (debug)
				printf("\nBIOS error 0x%x (%s)\n",
				    error, biosdisk_err(error));
#endif
			biosdreset(dev);
			break;
		}
	}

	if (bb != buf && rw == F_READ)
		bcopy(bb, buf, bbsize);
	free(bb1, bbsize * 2);

#ifdef BIOS_DEBUG
	if (debug) {
		if (error != 0)
			printf("=0x%x(%s)", error, biosdisk_err(error));
		putchar('\n');
	}
#endif

	return error;
}

int
biosd_diskio(int rw, struct diskinfo *dip, u_int off, int nsect, void *buf)
{
	return biosd_io(rw, &dip->bios_info, off, nsect, buf);
}
/*
 * Try to read the bsd label on the given BIOS device.
 */
static u_int
findopenbsd(bios_diskinfo_t *bd, const char **err)
{
	struct dos_mbr mbr;
	struct dos_partition *dp;
	u_int mbroff = DOSBBSECTOR;
	u_int mbr_eoff = DOSBBSECTOR;	/* Offset of MBR extended partition. */
	int error, i, maxebr = DOS_MAXEBR, nextebr;

again:
	if (!maxebr--) {
		*err = "too many extended partitions";
		return (-1);
	}

	/* Read MBR */
	bzero(&mbr, sizeof(mbr));
	error = biosd_io(F_READ, bd, mbroff, 1, &mbr);
	if (error) {
		*err = biosdisk_err(error);
		return (-1);
	}

	/* check mbr signature */
	if (mbr.dmbr_sign != DOSMBR_SIGNATURE) {
		*err = "bad MBR signature\n";
		return (-1);
	}

	/* Search for OpenBSD partition */
	nextebr = 0;
	for (i = 0; i < NDOSPART; i++) {
		dp = &mbr.dmbr_parts[i];
		if (!dp->dp_size)
			continue;
#ifdef BIOS_DEBUG
		if (debug)
			printf("found partition %u: "
			    "type %u (0x%x) offset %u (0x%x)\n",
			    (int)(dp - mbr.dmbr_parts),
			    dp->dp_typ, dp->dp_typ,
			    dp->dp_start, dp->dp_start);
#endif
		if (dp->dp_typ == DOSPTYP_OPENBSD) {
			if (dp->dp_start > (dp->dp_start + mbroff))
				continue;
			return (dp->dp_start + mbroff);
		}

		/*
		 * Record location of next ebr if and only if this is the first
		 * extended partition in this boot record!
		 */
		if (!nextebr && (dp->dp_typ == DOSPTYP_EXTEND ||
		    dp->dp_typ == DOSPTYP_EXTENDL)) {
			nextebr = dp->dp_start + mbr_eoff;
			if (nextebr < dp->dp_start)
				nextebr = (u_int)-1;
			if (mbr_eoff == DOSBBSECTOR)
				mbr_eoff = dp->dp_start;
		}
	}

	if (nextebr && nextebr != (u_int)-1) {
		mbroff = nextebr;
		goto again;
	}

	return (-1);
}

const char *
bios_getdisklabel(bios_diskinfo_t *bd, struct disklabel *label)
{
	u_int start = 0;
	char buf[DEV_BSIZE];
	const char *err = NULL;
	int error;

	/* Sanity check */
	if (bd->bios_edd == -1 &&
	    (bd->bios_heads == 0 || bd->bios_sectors == 0))
		return "failed to read disklabel";

	/* MBR is a harddisk thing */
	if (bd->bios_number & 0x80) {
		start = findopenbsd(bd, &err);
		if (start == (u_int)-1) {
			if (err != NULL)
				return (err);
 			return "no OpenBSD partition\n";
		}
	}

	/* Load BSD disklabel */
#ifdef BIOS_DEBUG
	if (debug)
		printf("loading disklabel @@ %u\n", start + DOS_LABELSECTOR);
#endif
	/* read disklabel */
	error = biosd_io(F_READ, bd, start + DOS_LABELSECTOR, 1, buf);

	if (error)
		return "failed to read disklabel";

	/* Fill in disklabel */
	return (getdisklabel(buf, label));
}

int
biosopen(struct open_file *f, ...)
{
#ifdef SOFTRAID
	struct sr_boot_volume *bv;
#endif
	register char *cp, **file;
	dev_t maj, unit, part;
	struct diskinfo *dip;
	int biosdev, devlen;
	const char *st;
	va_list ap;
	char *dev;

	va_start(ap, f);
	cp = *(file = va_arg(ap, char **));
	va_end(ap);

#ifdef BIOS_DEBUG
	if (debug)
		printf("%s\n", cp);
#endif

	f->f_devdata = NULL;

	/* Search for device specification. */
	dev = cp;
	if (cp[4] == ':')
		devlen = 2;
	else if (cp[5] == ':')
		devlen = 3;
	else
		return ENOENT;
	cp += devlen;

	/* Get unit. */
	if ('0' <= *cp && *cp <= '9')
		unit = *cp++ - '0';
	else {
		printf("Bad unit number\n");
		return EUNIT;
	}

	/* Get partition. */
	if ('a' <= *cp && *cp <= 'p')
		part = *cp++ - 'a';
	else {
		printf("Bad partition\n");
		return EPART;
	}

	/* Get filename. */
	cp++;	/* skip ':' */
	if (*cp != 0)
		*file = cp;
	else
		f->f_flags |= F_RAW;

#ifdef SOFTRAID
	/* Intercept softraid disks. */
	if (strncmp("sr", dev, 2) == 0) {

		/* Create a fake diskinfo for this softraid volume. */
		SLIST_FOREACH(bv, &sr_volumes, sbv_link)
			if (bv->sbv_unit == unit)
				break;
		if (bv == NULL) {
			printf("Unknown device: sr%d\n", unit);
			return EADAPT;
		}

		if (bv->sbv_level == 'C' && bv->sbv_keys == NULL)
			if (sr_crypto_decrypt_keys(bv) != 0)
				return EPERM;

		if (bv->sbv_diskinfo == NULL) {
			dip = alloc(sizeof(struct diskinfo));
			bzero(dip, sizeof(*dip));
			bv->sbv_diskinfo = dip;
			dip->sr_vol = bv;
			dip->bios_info.flags |= BDI_BADLABEL;
		}

		dip = bv->sbv_diskinfo;

		if (dip->bios_info.flags & BDI_BADLABEL) {
			/* Attempt to read disklabel. */
			bv->sbv_part = 'c';
			if (sr_getdisklabel(bv, &dip->disklabel))
				return ERDLAB;
			dip->bios_info.flags &= ~BDI_BADLABEL;
		}

		bv->sbv_part = part + 'a';

		bootdev_dip = dip;
		f->f_devdata = dip;

		return 0;
	}
#endif
 
	for (maj = 0; maj < nbdevs &&
	    strncmp(dev, bdevs[maj], devlen); maj++);
	if (maj >= nbdevs) {
		printf("Unknown device: ");
		for (cp = *file; *cp != ':'; cp++)
			putchar(*cp);
		putchar('\n');
		return EADAPT;
	}

	biosdev = unit;
	switch (maj) {
	case 0:  /* wd */
	case 4:  /* sd */
	case 17: /* hd */
		biosdev |= 0x80;
		break;
	case 2:  /* fd */
		break;
	case 6:  /* cd */
		biosdev = bios_bootdev & 0xff;
		break;
	default:
		return ENXIO;
	}

	/* Find device */
	bootdev_dip = dip = dklookup(biosdev);

	/* Fix up bootdev */
	{ dev_t bsd_dev;
		bsd_dev = dip->bios_info.bsd_dev;
		dip->bsddev = MAKEBOOTDEV(B_TYPE(bsd_dev), B_ADAPTOR(bsd_dev),
		    B_CONTROLLER(bsd_dev), unit, part);
		dip->bootdev = MAKEBOOTDEV(B_TYPE(bsd_dev), B_ADAPTOR(bsd_dev),
		    B_CONTROLLER(bsd_dev), B_UNIT(bsd_dev), part);
	}

#if 0
	dip->bios_info.bsd_dev = dip->bootdev;
	bootdev = dip->bootdev;
#endif

#ifdef BIOS_DEBUG
	if (debug) {
		printf("BIOS geometry: heads=%u, s/t=%u; EDD=%d\n",
		    dip->bios_info.bios_heads, dip->bios_info.bios_sectors,
		    dip->bios_info.bios_edd);
	}
#endif

	/* Try for disklabel again (might be removable media) */
	if (dip->bios_info.flags & BDI_BADLABEL) {
		st = bios_getdisklabel(&dip->bios_info, &dip->disklabel);
#ifdef BIOS_DEBUG
		if (debug && st)
			printf("%s\n", st);
#endif
		if (!st) {
			dip->bios_info.flags &= ~BDI_BADLABEL;
			dip->bios_info.flags |= BDI_GOODLABEL;
		} else
			return ERDLAB;
	}

	f->f_devdata = dip;

	return 0;
}

const u_char bidos_errs[] =
/* ignored	"\x00" "successful completion\0" */
		"\x01" "invalid function/parameter\0"
		"\x02" "address mark not found\0"
		"\x03" "write-protected\0"
		"\x04" "sector not found\0"
		"\x05" "reset failed\0"
		"\x06" "disk changed\0"
		"\x07" "drive parameter activity failed\0"
		"\x08" "DMA overrun\0"
		"\x09" "data boundary error\0"
		"\x0A" "bad sector detected\0"
		"\x0B" "bad track detected\0"
		"\x0C" "invalid media\0"
		"\x0E" "control data address mark detected\0"
		"\x0F" "DMA arbitration level out of range\0"
		"\x10" "uncorrectable CRC or ECC error on read\0"
/* ignored	"\x11" "data ECC corrected\0" */
		"\x20" "controller failure\0"
		"\x31" "no media in drive\0"
		"\x32" "incorrect drive type in CMOS\0"
		"\x40" "seek failed\0"
		"\x80" "operation timed out\0"
		"\xAA" "drive not ready\0"
		"\xB0" "volume not locked in drive\0"
		"\xB1" "volume locked in drive\0"
		"\xB2" "volume not removable\0"
		"\xB3" "volume in use\0"
		"\xB4" "lock count exceeded\0"
		"\xB5" "valid eject request failed\0"
		"\xBB" "undefined error\0"
		"\xCC" "write fault\0"
		"\xE0" "status register error\0"
		"\xFF" "sense operation failed\0"
		"\x00" "\0";

static const char *
biosdisk_err(u_int error)
{
	register const u_char *p = bidos_errs;

	while (*p && *p != error)
		while (*p++);

	return ++p;
}

const struct biosdisk_errors {
	u_char error;
	u_char errno;
} tab[] = {
	{ 0x01, EINVAL },
	{ 0x03, EROFS },
	{ 0x08, EINVAL },
	{ 0x09, EINVAL },
	{ 0x0A, EBSE },
	{ 0x0B, EBSE },
	{ 0x0C, ENXIO },
	{ 0x0D, EINVAL },
	{ 0x10, EECC },
	{ 0x20, EHER },
	{ 0x31, ENXIO },
	{ 0x32, ENXIO },
	{ 0x00, EIO }
};

static int
biosdisk_errno(u_int error)
{
	register const struct biosdisk_errors *p;

	if (error == 0)
		return 0;

	for (p = tab; p->error && p->error != error; p++);

	return p->errno;
}

int
biosstrategy(void *devdata, int rw, daddr32_t blk, size_t size, void *buf,
    size_t *rsize)
{
	struct diskinfo *dip = (struct diskinfo *)devdata;
	bios_diskinfo_t *bd = &dip->bios_info;
	u_int8_t error = 0;
	size_t nsect;

#ifdef SOFTRAID
	/* Intercept strategy for softraid volumes. */
	if (dip->sr_vol)
		return sr_strategy(dip->sr_vol, rw, blk, size, buf, rsize);
#endif

	nsect = (size + DEV_BSIZE - 1) / DEV_BSIZE;
	blk += dip->disklabel.d_partitions[B_PARTITION(dip->bsddev)].p_offset;

	/* Read all, sub-functions handle track boundaries */
	if (blk < 0)
		error = EINVAL;
	else
		error = biosd_io(rw, bd, blk, nsect, buf);

#ifdef BIOS_DEBUG
	if (debug) {
		if (error != 0)
			printf("=0x%x(%s)", error, biosdisk_err(error));
		putchar('\n');
	}
#endif

	if (rsize != NULL)
		*rsize = nsect * DEV_BSIZE;

	return (biosdisk_errno(error));
}

int
biosclose(struct open_file *f)
{
	f->f_devdata = NULL;

	return 0;
}

int
biosioctl(struct open_file *f, u_long cmd, void *data)
{
	return 0;
}
@


1.94
log
@Switch i386 boot code to libsa MI softraid.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.93 2016/09/11 15:54:11 jsing Exp $	*/
d274 4
a277 5
		/*
		 * XXX we believe that all the io is buffered
		 * by fs routines, so no big reads anyway
		 */
		bb = bb1 = alloc(bbsize);
d331 1
a331 1
	free(bb1, bbsize);
@


1.93
log
@Rename softraid boot files, which are currently in an MD location. This
will allow us to bring in a MI softraid.{c,h} in lib/libsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.92 2015/10/01 20:28:12 krw Exp $	*/
d46 1
@


1.92
log
@Use DOS_LABELSECTOR rather than LABELSECTOR to indicate offset into an
OpenBSD partition when accessing the disklabel. For these files both
are '1', but this makes the usage consistent across all archs.

ok guenther@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.91 2015/09/19 21:07:04 semarie Exp $	*/
d46 1
a46 1
#include "softraid.h"
@


1.91
log
@trivial "if(x) free(x)" replacement by "free(x)"

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.90 2015/09/02 04:09:24 yasuoka Exp $	*/
a444 1
	start = LABELSECTOR + start;
d449 1
a449 1
		printf("loading disklabel @@ %u\n", start);
d452 1
a452 1
	error = biosd_io(F_READ, bd, start, 1, buf);
@


1.90
log
@Bring the boot changes on amd64 to i386.  alloca is deleted.
Also fix the boot from BIOS and bump the version.

input and ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.23 2015/09/02 01:52:26 yasuoka Exp $	*/
d331 1
a331 2
	if (bb1 != NULL)
		free(bb1, bbsize);
@


1.89
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.88 2013/12/28 02:40:41 jsing Exp $	*/
d55 1
d250 1
a250 1
	void *bb;
d277 1
a277 1
		bb = alloca(bbsize);
d331 2
d345 5
d428 1
a428 1
	char *buf;
a448 1
	buf = alloca(DEV_BSIZE);
@


1.88
log
@If we fail to decrypt the softraid keys, return EPERM rather than falling
through and failing when we attempt to read and validate the disklabel.
Also return ENOTSUP rather than EPERM if an attempt is made to write to a
softraid volume.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.87 2013/03/23 16:08:29 deraadt Exp $	*/
d79 1
a79 1
	__asm __volatile (DOINT(0x13) "; setc %b0" : "=a" (rv)
d102 1
a102 1
	__asm __volatile (DOINT(0x13) "\n\t"
d145 1
a145 1
		__asm __volatile(DOINT(0x13) "; setc %b0"
d193 1
a193 1
	__asm __volatile ("movb %b7, %h1\n\t"
d235 1
a235 1
	__asm __volatile (DOINT(0x13) "; setc %b0" : "=a" (rv)
@


1.87
log
@Avoid using DEV_BSHIFT, and use DEV_BSIZE instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.86 2012/11/01 00:55:38 jsing Exp $	*/
d528 2
a529 1
			sr_crypto_decrypt_keys(bv);
@


1.86
log
@Fix merge errors.

Found the hard way by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.85 2012/10/31 13:55:58 jsing Exp $	*/
d261 2
a262 2
		off >>= (ISO_DEFAULT_BLOCK_SHIFT - DEV_BSHIFT);
		nsect >>= (ISO_DEFAULT_BLOCK_SHIFT - DEV_BSHIFT);
@


1.85
log
@Bring softraid support to i386/stand/libsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.15 2011/03/17 12:53:44 krw Exp $	*/
d43 5
@


1.84
log
@Warn about but don't prevent installboot from installing /boot when
the OpenBSD partition starts at >128G. This restores previous
behaviour but adds the warning.

ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.83 2011/03/17 12:53:44 krw Exp $	*/
d34 3
d38 3
a40 3
#include <machine/biosvar.h>
#include <lib/libsa/saerrno.h>
#include <isofs/cd9660/iso.h>
a41 1
#include "debug.h"
a42 1
#include "biosdev.h"
a55 8
#if 0
struct biosdisk {
	bios_diskinfo_t *bios_info;
	dev_t	bsddev;
	struct disklabel disklabel;
};
#endif

d338 1
a338 1
 * Try to read the bsd label on the given BIOS device
d454 4
a457 2
	va_list ap;
	register char	*cp, **file;
d460 4
a463 1
	int biosdev;
a474 8
	/* search for device specification */
	cp += 2;
	if (cp[2] != ':') {
		if (cp[3] != ':')
			return ENOENT;
		else
			cp++;
	}
d476 9
a484 9
	for (maj = 0; maj < nbdevs && strncmp(*file, bdevs[maj], cp - *file); )
	    maj++;
	if (maj >= nbdevs) {
		printf("Unknown device: ");
		for (cp = *file; *cp != ':'; cp++)
			putchar(*cp);
		putchar('\n');
		return EADAPT;
	}
d486 1
a486 1
	/* get unit */
d493 2
a494 1
	/* get partition */
d498 1
a498 1
		printf("Bad partition id\n");
d502 1
d509 53
d605 1
a605 2
		const char *st = bios_getdisklabel(&dip->bios_info,
		    &dip->disklabel);
d710 8
a717 4
	nsect = (size + DEV_BSIZE-1) / DEV_BSIZE;
	if (rsize != NULL)
		blk += dip->disklabel.
			d_partitions[B_PARTITION(dip->bsddev)].p_offset;
@


1.83
log
@Make the various findopenbsd() functions non-recursive, eliminating
a global, a couple of parameters, and opening up possibility of
traversing much longer EBR lists without blowing the stack.

Make seach algorithm the same as used in kern/subr_disk.c by checking
all primary partitions in the MBR/EBR before moving to next EBR. This
makes it more likely that everybody finds the same OpenBSD partition.

Largely from a diff posted to tech@@ by ucsavl.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.82 2011/03/15 14:00:26 krw Exp $	*/
a218 4

	/* Some (most?) BIOSen get confused by i/o above 2 ^ 28 - 1 sector. */
	if ((daddr + nblk) > BOOTBIOS_MAXSEC)
		return (1); /* Invalid function/parameter. */
@


1.82
log
@Bunch of white space and style adjustments to make amd64 version
the same as i386 version. No change to .o file except for the one
%lld -> %u format fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.81 2011/03/14 22:14:40 krw Exp $	*/
d49 1
a49 1
static u_int findopenbsd(bios_diskinfo_t *, u_int, const char **, int *);
a53 1
u_int mbr_eoff;			/* Offset of MBR extended partition. */
d352 1
a352 1
findopenbsd(bios_diskinfo_t *bd, u_int mbroff, const char **err, int *n)
d356 3
a358 2
	u_int start = (u_int)-1;
	int error, i;
d360 2
a361 2
	/* Limit the number of recursions */
	if (!(*n)--) {
d381 1
d397 1
a397 2
			start = dp->dp_start + mbroff;
			break;
d400 9
a408 3
		if (dp->dp_typ == DOSPTYP_EXTEND ||
		    dp->dp_typ == DOSPTYP_EXTENDL) {
			mbroff = dp->dp_start + mbr_eoff;
a410 5
			if (mbroff < dp->dp_start)
				continue;
			start = findopenbsd(bd, mbroff, err, n);
			if (start != (u_int)-1)
				break;
d414 6
a419 1
	return (start);
a428 1
	int n = 8;
d437 1
a437 2
		mbr_eoff = DOSBBSECTOR;
		start = findopenbsd(bd, DOSBBSECTOR, &err, &n);
@


1.81
log
@Clamp BIOS io attempts to < 2 ^28 - 1 sectors (a.k.a. 128GB for
512-byte sectors) as some BIOSen get confused when we ask for sectors
higher up.

Uss u_int throughout the boot code to calculate sector addresses,
since 32 bits is enough to do 28  ^ 1 - 1 arithmetic. Add checks
for wraparound.

I can now install and boot from the 7th extended partition below
128GB.

Much feedback & guidance from deraadt@@. Also from weingart@@ on
BIOS io.

ok deraadt@@ (less a couple of minor tweaks found in testing)
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.80 2011/03/13 00:13:53 deraadt Exp $	*/
a37 1
#include "libsa.h"
d40 1
d357 1
a357 1
	u_int start = (u_int)-1; 
d409 1
a409 1
				break;	
d446 1
a446 1
		printf("loading disklabel @@ %lld\n", start);
d559 1
a559 1
	if (dip->bios_info.flags & BDI_BADLABEL){
@


1.80
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.79 2011/03/11 21:08:25 krw Exp $	*/
d47 1
a47 1
static int EDD_rw (int, int, u_int64_t, u_int32_t, void *);
d49 1
a49 2
static daddr64_t findopenbsd(bios_diskinfo_t *, daddr64_t, const char **,
    int *);
d54 1
a54 1
daddr64_t mbr_eoff;		/* Offset of MBR extended partition. */
d216 1
a216 1
EDD_rw(int rw, int dev, u_int64_t daddr, u_int32_t nblk, void *buf)
d221 4
d252 1
a252 1
biosd_io(int rw, bios_diskinfo_t *bd, daddr32_t off, int nsect, void *buf)
d352 2
a353 2
static daddr64_t
findopenbsd(bios_diskinfo_t *bd, daddr64_t mbroff, const char **err, int *n)
d357 1
a357 1
	daddr64_t start = -1; 
d394 3
a396 1
			start = (daddr64_t)dp->dp_start + mbroff;
d402 5
a406 3
			mbroff = (daddr64_t)dp->dp_start + mbr_eoff;
			if (!mbr_eoff)
				mbr_eoff = (daddr64_t)dp->dp_start;
d408 1
a408 1
			if (start != -1)
d419 1
a419 1
	daddr64_t start = 0;
d432 3
a434 3
		mbr_eoff = 0;
		start = findopenbsd(bd, (daddr64_t)DOSBBSECTOR, &err, &n);
		if (start == -1) {
d449 1
a449 1
	error = biosd_io(F_READ, bd, (daddr32_t)start, 1, buf);
d672 4
a675 1
	error = biosd_io(rw, bd, blk, nsect, buf);
@


1.79
log
@Zap stack garbage before passing buffer to biosd_io(), which may
be lied to by the BIOS about successfully reading data.

ok deraadt@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.78 2011/03/08 17:24:31 krw Exp $	*/
d38 1
a40 1
#include "libsa.h"
d249 1
a249 1
biosd_io(int rw, bios_diskinfo_t *bd, daddr_t off, int nsect, void *buf)
d442 1
a442 1
	error = biosd_io(F_READ, bd, (daddr_t)start, 1, buf);
d651 1
a651 1
biosstrategy(void *devdata, int rw, daddr_t blk, size_t size, void *buf,
@


1.78
log
@Fix extended partition searching so we don't get lost. The offset
of the next EBR is relative to the start of the extended partition
described in the first MBR, not relative to the EBR specifying the
offset in its extended partition entry.

Clean up installboot -v output. Use daddr64_t for all sector numbers.

Not a complete fix, but better than what we had. More tweaks to
come.

Inspired by a diff and cluebat from uscav on tech@@ a few weeks
ago.

Feedback from matthew@@, weingart@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.77 2010/08/11 13:11:57 deraadt Exp $	*/
d364 1
@


1.77
log
@De-inline CHS_rw.  Somehow the merger of two monster __asm __inline statements
into one function is generating broken code; it might be because of missing
register clobbers.
This is a workaround... it'd be nice to know the real problem
work done with mlarkin and pirofti
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.76 2008/08/12 22:48:31 deraadt Exp $	*/
d49 2
a50 1
static daddr_t findopenbsd(bios_diskinfo_t *, daddr_t, const char **, int *);
d55 1
d349 2
a350 2
static daddr_t
findopenbsd(bios_diskinfo_t *bd, daddr_t mbroff, const char **err, int *n)
a351 1
	int error, i;
d354 2
a355 1
	daddr_t off;
d390 5
a394 2
			return (dp->dp_start + mbroff);
		} else if (dp->dp_typ == DOSPTYP_EXTEND ||
d396 6
a401 3
			off = findopenbsd(bd, dp->dp_start + mbroff, err, n);
			if (off != -1)
				return (off);
d405 1
a405 1
	return (-1);
d411 1
a411 1
	daddr_t off = 0;
d424 3
a426 2
		off = findopenbsd(bd, DOSBBSECTOR, &err, &n);
		if (off == -1) {
d432 1
a432 1
	off = LABELSECTOR + off;
d438 1
a438 1
		printf("loading disklabel @@ %u\n", off);
d441 1
a441 1
	error = biosd_io(F_READ, bd, off, 1, buf);
@


1.76
log
@Fix multiple addition error recently introduced for when extended partitions
are just before an OpenBSD partition in a MBR; done with kettenis & otto
ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.75 2008/08/04 15:58:13 reyk Exp $	*/
d46 1
a46 1
static int CHS_rw (int, int, int, int, int, int, void *);
d188 1
a188 1
static __inline int
@


1.75
log
@fix extended partition support by handling chained EBRs correctly
(using a recursion limit).  now OpenBSD can be installed in a
subsequent DOS/Linux-compatible extended partition.

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.74 2008/06/25 15:32:18 reyk Exp $	*/
d348 1
a348 1
findopenbsd(bios_diskinfo_t *bd, daddr_t off, const char **err, int *n)
d353 1
d358 1
a358 1
		return (0);
d362 1
a362 1
	error = biosd_io(F_READ, bd, off, 1, &mbr);
d365 1
a365 1
		return (0);
d371 1
a371 1
		return (0);
d377 2
d388 1
a388 2
			off = dp->dp_start + off;
			break;
d391 3
a393 3
			off = findopenbsd(bd, dp->dp_start + off, err, n);
			if (off != 0)
				break;
d397 1
a397 12
#ifdef BIOS_DEBUG
	if (debug)
		printf("using offset %u\n", off);
#endif

	if (off == 0) {
		if (*err == NULL)
			*err = "no OpenBSD partition\n";
		return (0);
	}

	return (off);
d417 1
a417 1
		if (off == 0) {
@


1.74
log
@this diff changes the bootloader to skip the CHS sanity check if LBA
(EDD) is found and OK. it will also fix chainloading into OpenBSD from
grub in a few scenarios where grub doesn't report the CHS correctly
but the LBA. and we don't need CHS if there is LBA.

this has been in the snapshots for a while.

with input from weingart@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.73 2008/06/25 15:26:44 reyk Exp $	*/
d49 1
a49 2
static daddr_t findopenbsd(bios_diskinfo_t *, daddr_t, daddr_t *,
    const char **, int *);
d348 1
a348 2
findopenbsd(bios_diskinfo_t *bd, daddr_t off, daddr_t *roff, const char **err,
    int *n)
d374 1
a374 1
	for (off = 0, i = 0; off == 0 && i < NDOSPART; i++) {
d384 4
a387 3
		if (dp->dp_typ == DOSPTYP_OPENBSD)
			off = dp->dp_start;
		else if (dp->dp_typ == DOSPTYP_EXTEND ||
d389 1
a389 1
			off = findopenbsd(bd, dp->dp_start, roff, err, n);
d391 1
a391 1
				*roff = dp->dp_start;
d412 1
a412 1
	daddr_t off = 0, roff = 0;
d425 1
a425 1
		off = findopenbsd(bd, DOSBBSECTOR, &roff, &err, &n);
d432 1
a432 1
	off = LABELSECTOR + off + roff;
@


1.73
log
@allow to install and boot the OpenBSD A6 partition and disklabel in an
extended DOS partition.  the concept of extended partitions is very
simple, it is just another mbr at the partition offset (well, the
standard "EBR" is a linked list with a few limitations, but this diff
works with both variants).

this diff has been in the snapshots for a while.

with input from weingart@@ and krw@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.72 2007/05/27 00:57:17 tom Exp $	*/
a129 8
	/* Sanity check */
	if (!pdi->bios_cylinders || !pdi->bios_heads || !pdi->bios_sectors)
		return 1;

	/* CD-ROMs sometimes return heads == 1 */
	if (pdi->bios_heads < 2)
		return 1;

d171 12
d420 2
a421 1
	if (bd->bios_heads == 0 || bd->bios_sectors == 0)
@


1.72
log
@When deciding whether to allocate a bounce buffer, we need one if
we are going to read exactly at 1 MB (i.e. fix an off-by-one that
is already correct in the amd64 version of this file).

ok toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.71 2007/04/04 14:36:05 jmc Exp $	*/
d49 3
d344 62
d409 1
a409 1
	daddr_t off = LABELSECTOR;
d411 3
a413 2
	struct dos_mbr mbr;
	int error, i;
d421 8
a428 17
		/* Read MBR */
		error = biosd_io(F_READ, bd, DOSBBSECTOR, 1, &mbr);
		if (error)
			return (biosdisk_err(error));

		/* check mbr signature */
		if (mbr.dmbr_sign != DOSMBR_SIGNATURE)
			return "bad MBR signature\n";

		/* Search for OpenBSD partition */
		for (off = 0, i = 0; off == 0 && i < NDOSPART; i++)
			if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_OPENBSD)
				off = mbr.dmbr_parts[i].dp_start + LABELSECTOR;
		if (off == 0)
			return "no OpenBSD partition\n";
	} else
		off = LABELSECTOR;
@


1.71
log
@Thinkpad -> ThinkPad; from Igor Sobrado
ok millert jasper mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.70 2006/10/12 12:14:17 krw Exp $	*/
d263 1
a263 1
	 * not access above 1 MB.
d267 1
a267 1
	    (((u_int32_t)buf) > 0x100000)) {
@


1.70
log
@Don't try to boot from a NetBSD MBR partition when no OpenBSD MBR
partition is found. Change error message to 'no OpenBSD partition'.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.69 2004/06/23 00:21:49 tom Exp $	*/
d137 1
a137 1
	 * The IBM Thinkpad 750ED for one.
@


1.69
log
@Enter cdboot, a CD-specific second-stage bootrap.

Testing krw@@ and todd@@, thanks.

assistance, testing and ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.68 2004/03/09 19:12:12 tom Exp $	*/
a367 8

		/* just in case */
		if (off == 0)
			for (off = 0, i = 0; off == 0 && i < NDOSPART; i++)
				if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_NETBSD)
					off = mbr.dmbr_parts[i].dp_start +
					    LABELSECTOR;

d369 1
a369 1
			return "no BSD partition\n";
@


1.68
log
@Spacing and KNF.  Partly from Joris Vink <nimadeus at pandora dot be>.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.67 2003/11/27 00:33:24 espie Exp $	*/
d37 1
d51 1
d246 4
d251 17
a267 3
	/* use a bounce buffer to not cross 64k DMA boundary */
	if ((((u_int32_t)buf) & ~0xffff) !=
	    (((u_int32_t)buf + nsect * DEV_BSIZE) & ~0xffff)) {
d272 1
a272 1
		bb = alloca(nsect * DEV_BSIZE);
d274 1
a274 1
			bcopy(buf, bb, nsect * DEV_BSIZE);
d325 1
a325 1
		bcopy(bb, buf, nsect * DEV_BSIZE);
d464 3
@


1.67
log
@gcc3 wants "m" operands to be lvalues.
okay toby, mickey.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.66 2003/09/20 05:23:42 fgsch Exp $	*/
d17 2
a18 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
d60 7
a66 7
	u_int8_t  edd_len;   /* size of packet */
	u_int8_t  edd_res1;  /* reserved */
	u_int8_t  edd_nblk;  /* # of blocks to transfer */
	u_int8_t  edd_res2;  /* reserved */
	u_int16_t edd_off;   /* address of buffer (offset) */
	u_int16_t edd_seg;   /* address of buffer (segment) */
	u_int64_t edd_daddr; /* starting block */
d76 1
d78 3
a80 2
			  : "0" (0), "d" (dev) : "%ecx", "cc");
	return (rv & 0xff)? rv >> 8 : 0;
d101 7
a107 7
			  "setc %b0; movzbl %h1, %1\n\t"
			  "movzbl %%cl, %3; andb $0x3f, %b3\n\t"
			  "xchgb %%cl, %%ch; rolb $2, %%ch"
			  : "=a" (rv), "=d" (pdi->bios_heads),
			    "=c" (pdi->bios_cylinders),
			    "=b" (pdi->bios_sectors)
			  : "0" (0x0800), "1" (dev) : "cc");
d113 1
a113 1
			pdi->bios_heads, pdi->bios_sectors);
d117 1
a117 1
		return (1);
d127 1
a127 1
		return(1);
d131 1
a131 1
		return(1);
d174 1
a174 1
	return(0);
d188 14
a201 14
			  "movb %b6, %%dh\n\t"
			  "andl $0xf, %4\n\t"
			  /* cylinder; the highest 2 bits of cyl is in %cl */
			  "xchgb %%ch, %%cl\n\t"
			  "rorb  $2, %%cl\n\t"
			  "orb %b5, %%cl\n\t"
			  "inc %%cx\n\t"
			  DOINT(0x13) "\n\t"
			  "setc %b0"
			  : "=a" (rv)
			  : "0" (nsect), "d" (dev), "c" (cyl),
			    "b" (buf), "m" (sect), "m" (head),
			    "m" (rw)
			  : "cc", "memory");
d203 1
a203 1
	return (rv & 0xff)? rv >> 8 : 0;
d225 1
a225 1
		return (1);
d230 3
a232 3
			  : "0" ((rw == F_READ)? 0x4200: 0x4300),
			    "d" (dev), "S" ((int) (&cb) & 0xf) : "%ecx", "cc");
	return (rv & 0xff)? rv >> 8 : 0;
d254 1
a254 1
			bcopy (buf, bb, nsect * DEV_BSIZE);
d259 1
a259 1
	for (error = 1, j = 5; j-- && error;) {
d270 4
a273 1
 					i += n, off += n, p += n * DEV_BSIZE) {
a274 1
				btochs(off, cyl, head, sect, bd->bios_heads, bd->bios_sectors);
d297 1
a297 1
					error, biosdisk_err(error));
d305 1
a305 1
		bcopy (bb, buf, nsect * DEV_BSIZE);
d315 1
a315 1
	return (error);
d330 2
a331 2
	if(bd->bios_heads == 0 || bd->bios_sectors == 0)
		return("failed to read disklabel");
d338 1
a338 1
			return(biosdisk_err(error));
d342 1
a342 1
			return("bad MBR signature\n");
d353 2
a354 1
					off = mbr.dmbr_parts[i].dp_start + LABELSECTOR;
d357 1
a357 1
			return("no BSD partition\n");
d370 2
a371 2
	if(error)
		return("failed to read disklabel");
d382 1
a382 1
	dev_t	maj, unit, part;
d405 2
a406 2
	for (maj = 0; maj < nbdevs && 
	     strncmp(*file, bdevs[maj], cp - *file); maj++);
d429 1
a429 1
		
d456 1
a456 1
			B_CONTROLLER(bsd_dev), unit, part);
d458 1
a458 1
			B_CONTROLLER(bsd_dev), B_UNIT(bsd_dev), part);
d469 2
a470 2
			dip->bios_info.bios_heads, dip->bios_info.bios_sectors,
			dip->bios_info.bios_edd);
d475 1
a475 1
	if(dip->bios_info.flags & BDI_BADLABEL){
d486 1
a486 1
			return (ERDLAB);
d494 1
a494 1
const u_char bidos_errs[] = 
d536 1
a536 1
		while(*p++);
d554 1
a554 1
	{ 0x20, EHER },	
d565 1
a565 1
	if (!error)
d601 1
a601 1
	return biosdisk_errno(error);
d608 1
a616 1

@


1.66
log
@move the checks after we fixed the hd info.
from Thorsten Glaser <tg-v2003 at netcologne dot de> via toby@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.65 2003/09/19 04:17:00 fgsch Exp $	*/
d183 1
d198 1
a198 1
			    "m" ((rw == F_READ)? 2: 3)
@


1.65
log
@add debug info around #41; toby@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.64 2003/09/18 08:24:11 fgsch Exp $	*/
d117 6
a129 6

	/* Fix up info */
	pdi->bios_number = dev;
	pdi->bios_heads++;
	pdi->bios_cylinders &= 0x3ff;
	pdi->bios_cylinders++;
@


1.64
log
@- move checks earlier to catch inexistent devices before testing for edd.
- bump version.
toby@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.63 2003/09/18 06:55:55 fgsch Exp $	*/
d96 1
a96 1
		printf("getinfo: try #8, %x,%p\n", dev, pdi);
d143 5
d157 6
@


1.63
log
@- pass the correct device to bios_getdisklabel().
- don't blindly return but check whether bios_getdisklabel() failed and
  act according.

this fixes (at some extent) booting from a floppy if it wasn't inserted
during floppyprobe(). toby@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.60 2003/08/11 06:23:09 deraadt Exp $	*/
d117 8
a159 8

	/* Sanity check */
	if (!pdi->bios_cylinders || !pdi->bios_heads || !pdi->bios_sectors)
		return(1);

	/* CD-ROMs sometimes return heads == 1 */
	if (pdi->bios_heads < 2)
		return(1);
@


1.62
log
@document extension support bitmap definition; requested by deraadt@@.
toby@@ ok.
@
text
@d459 3
a461 1
		const char *st = bios_getdisklabel((void *)biosdev, &dip->disklabel);
d464 6
a469 2

		return ERDLAB;
@


1.61
log
@handle case where bios EDD support only supports a subset; from fgsch,
ok toby, and now tested for lots of machines
@
text
@d148 1
a148 1
		if (!(pdi->bios_edd & 1))
@


1.60
log
@ansification and knf and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.59 2003/06/27 05:13:19 weingart Exp $	*/
d142 7
@


1.59
log
@Fix hang in EDD detection routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.59 2003/06/23 04:27:52 deraadt Exp $	*/
d73 1
a73 2
biosdreset(dev)
	int dev;
d87 1
a87 3
bios_getdiskinfo(dev, pdi)
	int dev;
	bios_diskinfo_t *pdi;
d161 1
a161 4
CHS_rw(rw, dev, cyl, head, sect, nsect, buf)
	int rw, dev, cyl, head;
	int sect, nsect;
	void * buf;
d164 1
d186 1
a186 5
EDD_rw(rw, dev, daddr, nblk, buf)
	int rw, dev;
	u_int64_t daddr;
	u_int32_t nblk;
	void *buf;
d218 1
a218 6
biosd_io(rw, bd, off, nsect, buf)
	int rw;
	bios_diskinfo_t *bd;
	daddr_t off;
	int nsect;
	void* buf;
d299 1
a299 3
bios_getdisklabel(bd, label)
	bios_diskinfo_t *bd;
	struct disklabel *label;
d501 1
a501 2
biosdisk_err(error)
	u_int error;
d529 1
d531 1
a531 2
biosdisk_errno(error)
	u_int error;
d544 2
a545 7
biosstrategy(devdata, rw, blk, size, buf, rsize)
	void *devdata;
	int rw;
	daddr_t blk;
	size_t size;
	void *buf;
	size_t *rsize;
d575 1
a575 2
biosclose(f)
	struct open_file *f;
d582 1
a582 4
biosioctl(f, cmd, data)
	struct open_file *f;
	u_long cmd;
	void *data;
@


1.58
log
@three four kills
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.57 2003/05/31 15:17:43 weingart Exp $	*/
d49 1
d92 1
a92 1
	u_int rv, secl, sech;
a125 16
	/*
	 * NOTE: This seems to hang on certain machines.  Use function #8
	 * first, and verify with #21 IFF #8 succeeds first.
	 * Do not try this for floppy 0 (to support CD-ROM boot).
	 */
	if (dev) {
		__asm __volatile (DOINT(0x13) ";setc %b0"
				: "=a" (rv), "=d" (secl), "=c" (sech)
				: "0" (0x15FF), "1" (dev), "2" (0xFFFF)
				: "cc");
		if (!(rv & 0xff00))
			return (1);
		if (rv & 0xff)
			return (1);
	}

d136 1
a136 1
	if (dev & 0x80) {
@


1.57
log
@Unpeeing as pointed out by Dries Schellekens.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.56 2003/05/31 00:15:29 weingart Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.56
log
@First lba support in /boot.  Not complete lba boot support, but it's the
first step on the way there.  Ok deraadt@@, espie@@, todd@@, and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.55 2003/04/17 03:43:18 drahn Exp $	*/
d50 2
a51 2
static int CHS_rw __P((int, int, int, int, int, int, void *));
static int EDD_rw __P((int, int, u_int64_t, u_int32_t, void *));
@


1.55
log
@i386 ELF bootloader. developed with weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.54 2002/03/14 03:15:54 millert Exp $	*/
d5 1
d50 3
d65 5
a69 3
	u_int8_t  edd_res;   /* reserved */
	u_int16_t edd_nblk;  /* # of blocks to transfer */
	u_int32_t edd_buf;   /* address of buffer */
d96 1
a96 1
	u_int rv;
d99 1
a99 1
	biosdreset(dev);
d122 1
a122 1
		return(1);
d130 16
a145 1
#if 0
d152 3
d159 1
a159 1
		__asm __volatile("int $2;" DOINT(0x13) "; setc %b0"
d161 1
a161 2
			 : "0" (0x4100), "2" (0x55aa), "d" (dev) : "cc");
		DUMP_REGS;
d163 1
a163 1
			pdi->bios_edd = bm & 0xffff;
a167 3
#else
	pdi->bios_edd = -1;
#endif
d169 1
a169 15
	/*
	 * NOTE: This seems to hang on certain machines.  Use function #8
	 * first, and verify with #21 IFF #8 succeeds first.
	 * Do not try this for floppy 0 (to support CD-ROM boot).
	 */
	if (dev) {
		__asm __volatile (DOINT(0x13) "; setc %b0"
			: "=a" (rv) : "0" (0x1500), "d" (dev) : "%ecx", "cc");
		if(!(rv & 0xff00))
			return(1);
		if(rv & 0xff)
			return(1);
	}

	/* XXX - Sanity check */
d184 1
a184 1
biosd_rw(rw, dev, cyl, head, sect, nsect, buf)
d210 1
a210 1
int
d218 5
a222 1
	struct EDD_CB cb;
d224 1
d227 2
a228 1
	cb.edd_buf = (u_int32_t)buf;
d231 6
d239 1
a239 1
			    "d" (dev), "S" (&cb) : "%ecx", "cc");
d247 6
a252 4
biosd_io(rw, dev, cyl, head, sect, nsect, buf)
	int rw, dev, cyl, head;
	int sect, nsect;
	void * buf;
d254 1
a257 7
#ifdef BIOS_DEBUG
	if (debug)
		printf("biosd_io(%s,%x,%u,%u,%u,%u,%p)\n",
		       (rw==F_READ?"reading":"writing"), dev,
			   cyl, head, sect, nsect, buf);
#endif

d270 1
a270 4
#ifdef BIOS_DEBUG
	if (debug)
		printf(" (%d,%d,%d,%d)@@%p", cyl, head, sect, nsect, bb);
#endif
d272 27
a298 2
	for (error = 1, j = 5; j-- && error;)
		switch (error = biosd_rw(rw, dev, cyl, head, sect, nsect, bb)) {
d313 1
d326 1
a326 1
	return biosdisk_errno(error);
a339 1
	int cyl, head, sect;
d342 1
a342 1
	/* XXX - Sanity check */
d346 1
a346 1
	/* MBR is a hard thing */
d349 2
a350 6
		btochs(DOSBBSECTOR, cyl, head, sect,
		       bd->bios_heads, bd->bios_sectors);

		error = biosd_io(F_READ, bd->bios_number,
				 cyl, head, sect, 1, &mbr);
		if(error)
d380 1
a380 2
	btochs(off, cyl, head, sect, bd->bios_heads, bd->bios_sectors);
	error = biosd_io(F_READ, bd->bios_number, cyl, head, sect, 1, buf);
d589 2
d592 1
a592 3
	struct diskinfo *dip = (struct diskinfo *)devdata;
	register size_t i, nsect, n, spt, tpc;
	int dev;
d599 2
a600 22
	/* handle floppies w/ different from drive geometry */
	if (!(dip->bios_info.bios_number & 0x80) &&
	    dip->disklabel.d_nsectors != 0)
		spt = dip->disklabel.d_nsectors;
	else
		spt = dip->bios_info.bios_sectors;

	tpc = dip->bios_info.bios_heads;
	dev = dip->bios_info.bios_number;

	for (i = 0; error == 0 && i < nsect;
	     i += n, blk += n, buf += n * DEV_BSIZE) {
		register int	cyl, hd, sect;

		btochs(blk, cyl, hd, sect, tpc, spt);
		if ((sect + (nsect - i)) >= spt)
			n = spt - sect;
		else
			n = nsect - i;
		
		error = biosd_io(rw, dev, cyl, hd, sect, n, buf);
	}
d611 1
a611 1
		*rsize = i * DEV_BSIZE;
@


1.54
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.53 2002/03/14 01:26:34 millert Exp $	*/
d192 1
a192 1
			  "incl %%cx\n\t"
@


1.53
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.52 1998/06/11 02:30:57 mickey Exp $	*/
d181 1
a181 1
	void* buf;
d232 1
a232 1
	void* buf;
d457 1
a457 1
		const char *st = bios_getdisklabel((void*)biosdev, &dip->disklabel);
@


1.52
log
@put missed changes that support booting from floppy (;
i applodgize for any inconvinience this memory hole caused to people.

ps. i would like to know the snapshots schedule to issue extra testing
cycles to ensure i did not forget anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.51 1998/04/18 07:39:42 deraadt Exp $	*/
d46 2
a47 2
static const char *biosdisk_err __P((u_int));
static int biosdisk_errno __P((u_int));
@


1.52.18.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.52 1998/06/11 02:30:57 mickey Exp $	*/
d46 2
a47 2
static const char *biosdisk_err(u_int);
static int biosdisk_errno(u_int);
d181 1
a181 1
	void * buf;
d232 1
a232 1
	void * buf;
d457 1
a457 1
		const char *st = bios_getdisklabel((void *)biosdev, &dip->disklabel);
@


1.52.18.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d192 1
a192 1
			  "inc %%cx\n\t"
@


1.52.8.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 2
a47 2
static const char *biosdisk_err(u_int);
static int biosdisk_errno(u_int);
d181 1
a181 1
	void * buf;
d232 1
a232 1
	void * buf;
d457 1
a457 1
		const char *st = bios_getdisklabel((void *)biosdev, &dip->disklabel);
@


1.52.8.2
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.52.8.1 2002/03/28 10:31:05 niklas Exp $	*/
d192 1
a192 1
			  "inc %%cx\n\t"
@


1.52.8.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.52.8.2 2003/05/13 19:42:09 ho Exp $	*/
a4 1
 * Copyright (c) 2003 Tobias Weingartner
d15 5
a48 3
static int CHS_rw (int, int, int, int, int, int, void *);
static int EDD_rw (int, int, u_int64_t, u_int32_t, void *);

d61 3
a63 5
	u_int8_t  edd_res1;  /* reserved */
	u_int8_t  edd_nblk;  /* # of blocks to transfer */
	u_int8_t  edd_res2;  /* reserved */
	u_int16_t edd_off;   /* address of buffer (offset) */
	u_int16_t edd_seg;   /* address of buffer (segment) */
d90 1
a90 1
	u_int rv, secl, sech;
d93 1
a93 1
	rv = biosdreset(dev);
d116 1
a116 1
		return (1);
d124 1
a124 16
	/*
	 * NOTE: This seems to hang on certain machines.  Use function #8
	 * first, and verify with #21 IFF #8 succeeds first.
	 * Do not try this for floppy 0 (to support CD-ROM boot).
	 */
	if (dev) {
		__asm __volatile (DOINT(0x13) ";setc %b0"
				: "=a" (rv), "=d" (secl), "=c" (sech)
				: "0" (0x15FF), "1" (dev), "2" (0xFFFF)
				: "cc");
		if (!(rv & 0xff00))
			return (1);
		if (rv & 0xff)
			return (1);
	}

a130 3
	 *
	 * Future hangs (when reported) can be "fixed"
	 * with getSYSCONFaddr() and an exceptions list.
d135 1
a135 1
		__asm __volatile(DOINT(0x13) "; setc %b0"
d137 2
a138 1
			 : "0" (0x4100), "b" (0x55aa), "d" (dev) : "cc");
d140 1
a140 1
			pdi->bios_edd = (bm & 0xffff) | ((rv & 0xff) << 16);
d145 3
d149 15
a163 1
	/* Sanity check */
d178 1
a178 1
CHS_rw(rw, dev, cyl, head, sect, nsect, buf)
d204 1
a204 1
static __inline int
d212 1
a212 5
	volatile static struct EDD_CB cb;

	/* Zero out reserved stuff */
	cb.edd_res1 = 0;
	cb.edd_res2 = 0;
a213 1
	/* Fill in parameters */
d216 1
a216 2
	cb.edd_seg = ((u_int32_t)buf >> 4) & 0xffff;
	cb.edd_off = (u_int32_t)buf & 0xf;
a218 6
	/* if offset/segment are zero, punt */
	if (!cb.edd_seg && !cb.edd_off)
		return (1);

	/* Call extended read/write (with disk packet) */
	BIOS_regs.biosr_ds = (u_int32_t)&cb >> 4;
d221 1
a221 1
			    "d" (dev), "S" ((int) (&cb) & 0xf) : "%ecx", "cc");
d229 4
a232 6
biosd_io(rw, bd, off, nsect, buf)
	int rw;
	bios_diskinfo_t *bd;
	daddr_t off;
	int nsect;
	void* buf;
a233 1
	int dev = bd->bios_number;
d237 7
d256 4
a259 1

d261 2
a262 27
	for (error = 1, j = 5; j-- && error;) {
		/* CHS or LBA access? */
		if (bd->bios_edd != -1) {
			error = EDD_rw(rw, dev, off, nsect, bb);
		} else {
			int cyl, head, sect;
			size_t i, n;
			char *p = bb;

			/* Handle track boundaries */
			for (error = i = 0; error == 0 && i < nsect;
 					i += n, off += n, p += n * DEV_BSIZE) {

				btochs(off, cyl, head, sect, bd->bios_heads, bd->bios_sectors);
				if ((sect + (nsect - i)) >= bd->bios_sectors)
					n = bd->bios_sectors - sect;
				else
					n = nsect - i;

				error = CHS_rw(rw, dev, cyl, head, sect, n, p);

				/* ECC corrected */
				if (error == 0x11)
					error = 0;
			}
		}
		switch (error) {
a276 1
	}
d289 1
a289 1
	return (error);
d303 1
d306 1
a306 1
	/* Sanity check */
d310 1
a310 1
	/* MBR is a harddisk thing */
d313 6
a318 2
		error = biosd_io(F_READ, bd, DOSBBSECTOR, 1, &mbr);
		if (error)
d348 2
a349 1
	error = biosd_io(F_READ, bd, off, 1, buf);
d558 1
d560 2
a561 3
	bios_diskinfo_t *bd = &dip->bios_info;
	u_int8_t error = 0;
	size_t nsect;
d568 22
a589 2
	/* Read all, sub-functions handle track boundaries */
	error = biosd_io(rw, bd, blk, nsect, buf);
d600 1
a600 1
		*rsize = nsect * DEV_BSIZE;
@


1.52.8.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a48 1
int bios_bootdev;
d72 2
a73 1
biosdreset(int dev)
d87 3
a89 1
bios_getdiskinfo(int dev, bios_diskinfo_t *pdi)
d91 1
a91 1
	u_int rv;
d98 1
a98 1
		printf("getinfo: try #8, 0x%x, %p\n", dev, pdi);
d125 15
a139 7
	/* Sanity check */
	if (!pdi->bios_cylinders || !pdi->bios_heads || !pdi->bios_sectors)
		return(1);

	/* CD-ROMs sometimes return heads == 1 */
	if (pdi->bios_heads < 2)
		return(1);
d151 1
a151 1
	if (dev & 0x80 && (dev == 0x80 || dev == 0x81 || dev == bios_bootdev)) {
a152 5

#ifdef BIOS_DEBUG
		if (debug)
			printf("getinfo: try #41, 0x%x\n", dev);
#endif
a160 13

#ifdef BIOS_DEBUG
		if (debug) {
			printf("getinfo: got #41\n");
			printf("disk 0x%x: 0x%x\n", dev, bm);
		}
#endif
		/*
		 * If extended disk access functions are not supported
		 * there is not much point on doing EDD.
		 */
		if (!(pdi->bios_edd & EXT_BM_EDA))
			pdi->bios_edd = -1;
d164 8
d179 4
a182 1
CHS_rw(int rw, int dev, int cyl, int head, int sect, int nsect, void *buf)
a184 2

	rw = rw == F_READ ? 2 : 3;
d199 1
a199 1
			    "m" (rw)
d206 5
a210 1
EDD_rw(int rw, int dev, u_int64_t daddr, u_int32_t nblk, void *buf)
d242 6
a247 1
biosd_io(int rw, bios_diskinfo_t *bd, daddr_t off, int nsect, void *buf)
d328 3
a330 1
bios_getdisklabel(bios_diskinfo_t *bd, struct disklabel *label)
d483 1
a483 3
		const char *st = bios_getdisklabel(&dip->bios_info,
		    &dip->disklabel);
#ifdef BIOS_DEBUG
d486 2
a487 6
#endif
		if (!st) {
			dip->bios_info.flags &= ~BDI_BADLABEL;
			dip->bios_info.flags |= BDI_GOODLABEL;
		} else
			return (ERDLAB);
d532 2
a533 1
biosdisk_err(u_int error)
a560 1

d562 2
a563 1
biosdisk_errno(u_int error)
d576 7
a582 2
biosstrategy(void *devdata, int rw, daddr_t blk, size_t size, void *buf,
    size_t *rsize)
d612 2
a613 1
biosclose(struct open_file *f)
d620 4
a623 1
biosioctl(struct open_file *f, u_long cmd, void *data)
@


1.52.8.5
log
@Merge with the trunk
@
text
@d17 2
a18 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
d60 7
a66 7
	u_int8_t  edd_len;	/* size of packet */
	u_int8_t  edd_res1;	/* reserved */
	u_int8_t  edd_nblk;	/* # of blocks to transfer */
	u_int8_t  edd_res2;	/* reserved */
	u_int16_t edd_off;	/* address of buffer (offset) */
	u_int16_t edd_seg;	/* address of buffer (segment) */
	u_int64_t edd_daddr;	/* starting block */
a75 1

d77 2
a78 3
	    : "0" (0), "d" (dev) : "%ecx", "cc");

	return ((rv & 0xff)? rv >> 8 : 0);
d99 7
a105 7
	    "setc %b0; movzbl %h1, %1\n\t"
	    "movzbl %%cl, %3; andb $0x3f, %b3\n\t"
	    "xchgb %%cl, %%ch; rolb $2, %%ch"
	    : "=a" (rv), "=d" (pdi->bios_heads),
	      "=c" (pdi->bios_cylinders),
	      "=b" (pdi->bios_sectors)
	    : "0" (0x0800), "1" (dev) : "cc");
d111 1
a111 1
		    pdi->bios_heads, pdi->bios_sectors);
d115 1
a115 1
		return 1;
d125 1
a125 1
		return 1;
d129 1
a129 1
		return 1;
d172 1
a172 1
	return 0;
d186 14
a199 14
	    "movb %b6, %%dh\n\t"
	    "andl $0xf, %4\n\t"
	    /* cylinder; the highest 2 bits of cyl is in %cl */
	    "xchgb %%ch, %%cl\n\t"
	    "rorb  $2, %%cl\n\t"
	    "orb %b5, %%cl\n\t"
	    "inc %%cx\n\t"
	    DOINT(0x13) "\n\t"
	    "setc %b0"
	    : "=a" (rv)
	    : "0" (nsect), "d" (dev), "c" (cyl),
	      "b" (buf), "m" (sect), "m" (head),
	      "m" (rw)
	    : "cc", "memory");
d201 1
a201 1
	return ((rv & 0xff)? rv >> 8 : 0);
d223 1
a223 1
		return 1;
d228 3
a230 3
	    : "0" ((rw == F_READ)? 0x4200: 0x4300),
	      "d" (dev), "S" ((int) (&cb) & 0xf) : "%ecx", "cc");
	return ((rv & 0xff)? rv >> 8 : 0);
d252 1
a252 1
			bcopy(buf, bb, nsect * DEV_BSIZE);
d257 1
a257 1
	for (error = 1, j = 5; j-- && error; ) {
d268 1
a268 4
			    i += n, off += n, p += n * DEV_BSIZE) {

				btochs(off, cyl, head, sect, bd->bios_heads,
				    bd->bios_sectors);
d270 1
d293 1
a293 1
				    error, biosdisk_err(error));
d301 1
a301 1
		bcopy(bb, buf, nsect * DEV_BSIZE);
d311 1
a311 1
	return error;
d326 2
a327 2
	if (bd->bios_heads == 0 || bd->bios_sectors == 0)
		return "failed to read disklabel";
d334 1
a334 1
			return (biosdisk_err(error));
d338 1
a338 1
			return "bad MBR signature\n";
d349 1
a349 2
					off = mbr.dmbr_parts[i].dp_start +
					    LABELSECTOR;
d352 1
a352 1
			return "no BSD partition\n";
d365 2
a366 2
	if (error)
		return "failed to read disklabel";
d377 1
a377 1
	dev_t maj, unit, part;
d400 2
a401 2
	for (maj = 0; maj < nbdevs && strncmp(*file, bdevs[maj], cp - *file); )
	    maj++;
d424 1
a424 1

d451 1
a451 1
		    B_CONTROLLER(bsd_dev), unit, part);
d453 1
a453 1
		    B_CONTROLLER(bsd_dev), B_UNIT(bsd_dev), part);
d464 2
a465 2
		    dip->bios_info.bios_heads, dip->bios_info.bios_sectors,
		    dip->bios_info.bios_edd);
d470 1
a470 1
	if (dip->bios_info.flags & BDI_BADLABEL){
d481 1
a481 1
			return ERDLAB;
d489 1
a489 1
const u_char bidos_errs[] =
d531 1
a531 1
		while (*p++);
d549 1
a549 1
	{ 0x20, EHER },
d560 1
a560 1
	if (error == 0)
d596 1
a596 1
	return (biosdisk_errno(error));
a602 1

d611 1
@


1.51
log
@i386 bootblocks that work for 2.3. A tale too long to tell
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.50 1998/02/24 22:06:46 weingart Exp $	*/
d310 14
a323 2
	/* Read MBR */
	btochs(DOSBBSECTOR, cyl, head, sect, bd->bios_heads, bd->bios_sectors);
d325 1
a325 15
	error = biosd_io(F_READ, bd->bios_number, cyl, head, sect, 1, &mbr);
	if(error)
		return(biosdisk_err(error));

	/* check mbr signature */
	if (mbr.dmbr_sign != DOSMBR_SIGNATURE)
		return("bad MBR signature\n");

	/* Search for OpenBSD partition */
	for (off = 0, i = 0; off == 0 && i < NDOSPART; i++)
		if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_OPENBSD)
			off = mbr.dmbr_parts[i].dp_start + LABELSECTOR;

	/* just in case */
	if (off == 0)
d327 1
a327 1
			if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_NETBSD)
d330 10
a339 2
	if (off == 0)
		return("no BSD partition\n");
@


1.50
log
@Changes/updates to /boot stuff.  More to come.
Fixes many divide by zero and pointer bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.49 1997/11/30 21:51:38 mickey Exp $	*/
d96 2
a97 1
	printf("getinfo: try #8, %x,%p\n", dev, pdi);
d109 5
a113 3
	printf("getinfo: got #8\n");
	printf("disk 0x%x: %d,%d,%d\n", dev, pdi->bios_cylinders,
		pdi->bios_heads, pdi->bios_sectors);
d270 3
a272 1
			printf("\nBIOS error 0x%x (%s)\n", error, biosdisk_err(error));
d463 1
a463 5
static const char *
biosdisk_err(error)
	u_int error;
{
	static const u_char errs[] = 
d498 6
a503 1
	register const u_char *p = errs;
d511 18
a532 18
	static const struct biosdisk_errors {
		u_char error;
		u_char errno;
	} tab[] = {
		{ 0x01, EINVAL },
		{ 0x03, EROFS },
		{ 0x08, EINVAL },
		{ 0x09, EINVAL },
		{ 0x0A, EBSE },
		{ 0x0B, EBSE },
		{ 0x0C, ENXIO },
		{ 0x0D, EINVAL },
		{ 0x10, EECC },
		{ 0x20, EHER },	
		{ 0x31, ENXIO },
		{ 0x32, ENXIO },
		{ 0x00, EIO }
	};
@


1.49
log
@big diskinfo changes from toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.48 1997/11/05 02:02:25 mickey Exp $	*/
d92 2
a93 3
	rv = biosdreset(dev);
	if(rv)
		return(1);
d107 8
a119 5
#ifdef BIOS_DEBUG
	printf("getinfo: got #8\n");
#endif
	if (rv & 0xff || !pdi->bios_cylinders)
		return(1);
d149 1
a149 1
	 * don't try this for a:
d160 8
d300 4
@


1.48
log
@don't try #21 for a: only
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.47 1997/11/01 16:35:19 mickey Exp $	*/
d41 1
d51 1
d57 1
d68 13
d86 1
a86 1
bios_getinfo(dev, pdi)
d91 5
a161 13
 * reset disk system
 */
static __inline int
biosdreset(dev)
	int dev;
{
	int rv;
	__asm __volatile (DOINT(0x13) "; setc %b0" : "=a" (rv)
			  : "0" (0), "d" (dev) : "%ecx", "cc");
	return (rv & 0xff)? rv >> 8 : 0;
}

/*
d256 1
d258 1
d281 2
a282 2
bios_getdisklabel(dev, label)
	int dev;
a285 1
	bios_diskinfo_t *bd;
a291 1
	bd = bios_dklookup(dev);
d294 1
a294 1
	error = biosd_io(F_READ, dev, cyl, head, sect, 1, &mbr);
d324 1
a324 1
	error = biosd_io(F_READ, dev, cyl, head, sect, 1, buf);
a337 1
	const char *st;
d339 1
a339 1
	register struct biosdisk *bd;
d405 2
a406 2
	bd = alloc(sizeof(*bd));
	bzero(bd, sizeof(bd));
d408 8
a415 2
	if (!(bd->bios_info = bios_dklookup(biosdev)))
		return ENXIO;
d417 4
a420 5
	bootdev = bd->bios_info->bsd_dev;
	bd->bsddev = MAKEBOOTDEV(B_TYPE(bootdev), B_ADAPTOR(bootdev),
		B_CONTROLLER(bootdev), unit, part);
	bootdev = MAKEBOOTDEV(B_TYPE(bootdev), B_ADAPTOR(bootdev),
		B_CONTROLLER(bootdev), B_UNIT(bootdev), part);
d425 2
a426 2
			bd->bios_info->bios_heads, bd->bios_info->bios_sectors,
			bd->bios_info->bios_edd);
d430 4
a433 3
	/* Get disklabel from drive */
	if ((st = bios_getdisklabel(biosdev, &bd->disklabel)) != NULL) {
		if (debug)
d439 1
a439 1
	f->f_devdata = bd;
d533 1
a533 1
	struct biosdisk *bd = (struct biosdisk *)devdata;
d539 2
a540 2
		blk += bd->disklabel.
			d_partitions[B_PARTITION(bd->bsddev)].p_offset;
d543 3
a545 3
	if (!(bd->bios_info->bios_number & 0x80) &&
	    bd->disklabel.d_nsectors != 0)
		spt = bd->disklabel.d_nsectors;
d547 1
a547 1
		spt = bd->bios_info->bios_sectors;
d549 2
a550 2
	tpc = bd->bios_info->bios_heads;
	dev = bd->bios_info->bios_number;
d583 1
a583 1
	free(f->f_devdata, 0);
@


1.47
log
@don't try function #21 for floppies
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.46 1997/10/28 23:33:49 deraadt Exp $	*/
d126 1
a126 1
	 * don't try this for floppies.
d128 1
a128 1
	if (dev & 0x80) {
@


1.46
log
@do not replace unit number in bootdev. please talk to me about this.
this makes it so that when booting sd0 on a wd0/sd0/sd1 system the kernel
doesn't get told we are booting from sd1 (ie. scsi, but it is hd1..).
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.45 1997/10/26 22:33:00 mickey Exp $	*/
d117 1
a117 1
	}else
d126 1
d128 8
a135 6
	__asm __volatile (DOINT(0x13) "; setc %b0"
		: "=a" (rv) : "0" (0x1500), "d" (dev) : "%ecx", "cc");
	if(!(rv & 0xff00))
		return(1);
	if(rv & 0xff)
		return(1);
@


1.46.2.1
log
@rev 1.46->1.47 into branch: do not try function #21 for floppies
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.47 1997/11/01 16:35:19 mickey Exp $	*/
d117 1
a117 1
	} else
a125 1
	 * don't try this for floppies.
d127 6
a132 8
	if (dev & 0x80) {
		__asm __volatile (DOINT(0x13) "; setc %b0"
			: "=a" (rv) : "0" (0x1500), "d" (dev) : "%ecx", "cc");
		if(!(rv & 0xff00))
			return(1);
		if(rv & 0xff)
			return(1);
	}
@


1.45
log
@we don't need that extra var (st)
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.44 1997/10/25 02:07:08 weingart Exp $	*/
d402 1
a402 1
	bd->bsddev = bootdev = MAKEBOOTDEV(B_TYPE(bootdev), B_ADAPTOR(bootdev),
d404 2
@


1.44
log
@Fix disk probe.  Get rid of EDD check, it goes haywire on
some machines.  Thinkpad 760ED is one of them.  IBM/MS
extention, and IBM does not support it.  Nice.
Add some more debug statements for BIOS_DEBUG.
Init EDD flags to "not supported" for now.

Change 'machine memory' back to display the type of each
range it displays.

Testing by todd@@ (thanks).
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.43 1997/10/24 22:49:58 mickey Exp $	*/
d274 1
a274 1
	char *st, *buf;
d319 1
a319 2
	st = getdisklabel(buf, label); 
	return(st);
@


1.43
log
@don't touch ed,ds
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.42 1997/10/24 17:16:53 mickey Exp $	*/
d41 1
d65 3
a67 3
 * return a word that represents the max number
 * of sectors and heads for this device
 *
d74 1
a74 1
	u_int rv, bm;
d98 8
d107 1
d109 1
a109 1
		__asm __volatile(DOINT(0x13) "; setc %b0"
d112 1
d117 5
a121 1
	}
@


1.42
log
@fix cylinders in getdiskinfo
get EDD fot hd* only
more debug
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.41 1997/10/24 01:38:50 weingart Exp $	*/
a76 1
	BIOS_regs.biosr_ds = BIOS_regs.biosr_es = 0;
@


1.41
log
@Fix hang on disk probe.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.40 1997/10/23 15:13:26 weingart Exp $	*/
d73 5
a77 1
	u_int rv, bm, sgn;
d81 1
a81 1
			  "xchgb %%cl, %%ch; rorb $2, %%ch"
d92 4
a95 2

	if (rv & 0xff)
d98 10
a107 8
	/* EDD support check */
	__asm __volatile(DOINT(0x13) "; setc %b0"
		 : "=a" (rv), "=c" (bm), "=b" (sgn)
		 : "0" (0x4400), "2" (0x55aa) : "%edx", "cc");
	if (!(rv & 0xff) && (sgn & 0xffff) == 0xaa55)
		pdi->bios_edd = bm & 0xffff;
	else
		pdi->bios_edd = -1;
a114 1

d117 1
a117 1
	if(rv & 0x00ff)
@


1.40
log
@Better BIOS diskprobe.  Cleanup and re-org by mickey.
Fix bug in BIOS memprobe.  Cleanup and re-org by mickey.
Do checksum of HD devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.39 1997/10/22 23:34:36 mickey Exp $	*/
d90 1
a90 1
		return (rv & 0xff) >> 8;
d108 6
a113 1
	return rv & 0xffff;
@


1.39
log
@newer, better stuff; some parts by toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.38 1997/10/18 00:33:15 weingart Exp $	*/
d83 1
d85 3
a87 1
	pdi->bios_heads++;	/* make it number of heads */
@


1.38
log
@Copy in bios_diskinfo array from /boot space.
Add length field for checksum to same.
Start of making /boot deduce bsd dev_t for
all BIOS drives.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.37 1997/10/17 15:03:21 weingart Exp $	*/
d44 3
a47 1
extern bios_diskinfo_t bios_diskinfo[];
d51 1
a51 1
	int	edd_flags;
d55 8
d68 2
a69 2
u_int32_t
biosdinfo(dev)
d71 1
d73 15
a87 9
	u_int f, rv;
	__asm __volatile (DOINT(0x13) "; setc %b0\n\t"
			  /* form a word with ntrack/nhead/nsect packed */
			  "shll	$16, %1; movw %%cx, %w1"
			  /* "movb %%cl, %b1; andb $0x3f, %b1" */
			  : "=a" (f), "=d" (rv)
			  : "0" (0x800), "1" (dev) : "%ecx", "cc");
	return (f & 0xff)? 0 : rv;
}
d89 8
a96 14
/*
 * Probe if given bios disk exists.
 *
 * NOTE: This seems to hang on certain machines.  Use biosdinfo()
 * first, and verify with biosdprobe() IFF biosdinfo() succeeds
 * first.
 *
 * XXX - biosdinfo() and biosdprobe() should be integrated into 1 fcn.
 */
u_int32_t
biosdprobe(dev)
	int dev;
{
	u_int32_t val = 0;
d98 6
a103 7
	__asm __volatile (
		DOINT(0x13) "\n\t"
		"setc %b0 \n\t"
		: "=a" (val)
		: "0" (0x1500),
		  "d" (dev)
		: "%ecx", "%edx", "cc");
d105 1
a105 1
	return(val & 0xffff);
d124 1
a124 1
int
a150 14
/*
 * check the features supported by the bios for the drive
 */
static __inline int
EDDcheck (dev)
	int dev;
{
	int rv, bm, sgn;
	__asm __volatile(DOINT(0x13) "; setc %b0"
			 : "=a" (rv), "=c" (bm), "=b" (sgn)
			 : "0" (0x4400), "2" (0x55aa) : "%edx", "cc");
	return ((rv & 0xff) && (sgn & 0xffff) == 0xaa55)? bm & 0xffff : -1;
}

d172 67
a238 1
char *
d243 3
a245 1
	char *st, buf[DEV_BSIZE];
d247 25
a271 1
	int error;
d273 18
a290 2
	error = biosd_rw(F_READ, dev, 0, 0, 1, 1, &mbr);
	st = getdisklabel(buf, label);
d299 1
d302 1
a302 3
	daddr_t off = LABELSECTOR;
	u_int8_t *buf;
	int i, biosdev;
d354 1
a354 3
	bd = alloc(sizeof(*bd));
	bzero(bd, sizeof(bd));

d359 1
a359 4
		biosdev = unit | 0x80;
		if (maj == 17)
			unit = 0;
		maj = 17;
a361 1
		biosdev = unit;
a362 12
	case 7:  /* mcd */
	case 15: /* scd */
	case 6:  /* cd */
	case 18: /* acd */
#ifdef BIOS_DEBUG
		printf("Booting from CD is not yet supported\n");
#endif
	case 3:  /* wt */
#ifdef BIOS_DEBUG
		if (maj == 3)
			printf("Booting from Wangtek is not supported\n");
#endif
a363 1
		free(bd, 0);
d367 4
a370 2
	bd->bios_info = diskfind(biosdev);
	if (!bd->bios_info)
d373 3
a375 5
	/* Get EDD stuff */
	bd->edd_flags = EDDcheck(biosdev);

	/* maj is fixed later w/ disklabel read */
	bootdev = MAKEBOOTDEV(maj, 0, 0, unit, part);
d380 2
a381 2
		       BIOSNHEADS(bd->dinfo), BIOSNSECTS(bd->dinfo),
		       bd->edd_flags);
d385 4
a388 43
	if (maj == 17) {	/* hd, wd, sd */
		struct dos_mbr	mbr;

		if ((errno = biosstrategy(bd, F_READ, DOSBBSECTOR,
		    DEV_BSIZE, &mbr, NULL)) != 0) {
#ifdef BIOS_DEBUG
			if (debug)
				printf("cannot read MBR\n");
#endif
			free(bd, 0);
			return errno;
		}

		/* check mbr signature */
		if (mbr.dmbr_sign != DOSMBR_SIGNATURE) {
#ifdef BIOS_DEBUG
			if (debug)
				printf("bad MBR signature\n");
#endif
			free(bd, 0);
			return ERDLAB;
		}

		for (off = 0, i = 0; off == 0 && i < NDOSPART; i++)
			if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_OPENBSD)
				off = mbr.dmbr_parts[i].dp_start + LABELSECTOR;

		/* just in case */
		if (off == 0)
			for (off = 0, i = 0; off == 0 && i < NDOSPART; i++)
				if (mbr.dmbr_parts[i].dp_typ == DOSPTYP_NETBSD)
					off = mbr.dmbr_parts[i].dp_start +
						LABELSECTOR;

		if (off == 0) {
#ifdef BIOS_DEBUG
			if (debug)
				printf("no BSD partition\n");
#endif
			free(bd, 0);
			return ERDLAB;
		}
	}
a389 13
	buf = alloca(DEV_BSIZE);
#ifdef BIOS_DEBUG
	if (debug)
		printf("loading disklabel @@ %u\n", off);
#endif
	/* read disklabel */
	if ((errno = biosstrategy(bd, F_READ, off,
				  DEV_BSIZE, buf, NULL)) != 0) {
#ifdef BIOS_DEBUG
		if (debug)
			printf("failed to read disklabel\n");
#endif
		free(bd, 0);
a392 19
	if ((cp = getdisklabel(buf, &bd->disklabel)) != NULL) {
#ifdef BIOS_DEBUG
		if (debug)
			printf("%s\n", cp);
#endif
		free(bd, 0);
		return EUNLAB;
	}

	if (maj == 17) { /* figure out what it's exactly */
		switch (bd->disklabel.d_type) {
		case DTYPE_SCSI:  maj = 4;  break;
		default:          maj = 0;  break;
		}
	}

	/* and again w/ fixed maj */
	bootdev = MAKEBOOTDEV(maj, 0, 0, unit, part);

d398 1
a398 1
static __inline const char *
d445 1
a445 1
static __inline int
d487 3
a489 2
	register struct biosdisk *bd = (struct biosdisk *)devdata;
	register size_t i, nsect, n, spt;
a491 1
#if 0
a494 9
#endif

#ifdef BIOS_DEBUG
	if (debug)
		printf("biosstrategy(%p,%s,%u,%u,%p,%p), dev=%x:%x\n"
		       "biosdread:",
		       bd, (rw==F_READ?"reading":"writing"), blk, size,
		       buf, rsize, bd->biosdev, bd->bsddev);
#endif
d497 2
a498 1
	if (!(bd->bios_info->bios_number & 0x80) && bd->disklabel.d_nsectors != 0)
d503 3
d508 1
a508 2
		register int	cyl, hd, sect, j;
		void *bb;
d510 1
a510 1
		btochs(blk, cyl, hd, sect, (bd->bios_info->bios_heads), spt);
d516 1
a516 34
		/* use a bounce buffer to not cross 64k DMA boundary */
		if ((((u_int32_t)buf) & ~0xffff) !=
		    (((u_int32_t)buf + n * DEV_BSIZE) & ~0xffff)) {
			/*
			 * XXX we believe that all the io is buffered
			 * by fs routines, so no big reads anyway
			 */
			bb = alloca(n * DEV_BSIZE);
			if (rw != F_READ)
				bcopy (buf, bb, n * DEV_BSIZE);
		} else
			bb = buf;
#ifdef BIOS_DEBUG
		if (debug)
			printf(" (%d,%d,%d,%d)@@%p", cyl, hd, sect, n, bb);
#endif
		/* Try to do operation up to 5 times */
		for (error = 1, j = 5; j-- && error;)
			switch (error = biosd_rw(rw, bd->bios_info->bios_number,
						 cyl, hd, sect, n, bb)) {
			case 0x00:	/* No errors */
			case 0x11:	/* ECC corrected */
				error = 0;
				break;

			default:	/* All other errors */
				printf("\nBIOS error 0x%x (%s)\n", error,
				       biosdisk_err(error));
				biosdreset(bd->bios_info->bios_number);
				break;
			}

		if (bb != buf && rw == F_READ)
			bcopy (bb, buf, n * DEV_BSIZE);
@


1.37
log
@Use BIOS to probe for memory map.
Probe for BIOS supported disks.
Use BIOS to get geometry for supported disks.

All in preparation to passing the whole thing
to the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.36 1997/10/07 08:56:19 mickey Exp $	*/
d45 1
d48 1
a48 3
	u_int32_t	dinfo;
	dev_t	bsddev;
	int	biosdev;
d111 4
a114 1
__inline int
d176 14
d199 1
a199 1
	int i;
d258 1
a258 1
		bd->biosdev = unit | 0x80;
d264 1
a264 1
		bd->biosdev = unit;
d283 7
a289 8
	bd->dinfo = biosdinfo(bd->biosdev);
	if (!bd->dinfo)
		bd->dinfo = 0x01014f12; /* fake geometry */
	/* pass c: geometry for floppy */
	BIOS_vars.bios_geometry = (bd->biosdev & 0x80)? bd->dinfo
		: biosdinfo(0x80);
	BIOS_vars.bios_dev = (bd->biosdev & 0x80)? bd->biosdev : 0x80;
		
d291 1
a291 2
	bootdev = bd->bsddev = MAKEBOOTDEV(maj, 0, 0, unit, part);
	bd->edd_flags = EDDcheck(bd->biosdev);
d378 1
a378 1
	bootdev = bd->bsddev = MAKEBOOTDEV(maj, 0, 0, unit, part);
d478 1
d482 1
d493 1
a493 1
	if (!(bd->biosdev & 0x80) && bd->disklabel.d_nsectors != 0)
d496 1
a496 1
		spt = BIOSNSECTS(bd->dinfo);
d503 1
a503 1
		btochs(blk, cyl, hd, sect, BIOSNHEADS(bd->dinfo), spt);
d527 1
a527 1
			switch (error = biosd_rw(rw, bd->biosdev,
d537 1
a537 1
				biosdreset(bd->biosdev);
@


1.36
log
@better fix for floppy boot
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.35 1997/09/24 22:42:59 mickey Exp $	*/
a54 1
 *
d60 2
a61 1
biosdinfo(int dev)
d74 26
d103 2
a104 1
biosdreset(int dev)
d112 5
a116 2
static __inline int
biosd_rw(int rw, int dev, int cyl, int head, int sect, int nsect, void* buf)
d143 2
a144 1
EDDcheck (int dev)
d154 5
a158 1
EDD_rw(int rw, int dev, u_int64_t daddr, u_int32_t nblk, void *buf)
d370 1
d372 2
a373 1
biosdisk_err(u_int error)
d419 2
a420 1
biosdisk_errno(u_int error)
d451 7
a457 2
biosstrategy(void *devdata, int rw,
	daddr_t blk, size_t size, void *buf, size_t *rsize)
d544 2
a545 1
biosclose(struct open_file *f)
d552 4
a555 1
biosioctl(struct open_file *f, u_long cmd, void *data)
@


1.35
log
@overflow can bite anyways, increment word
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.34 1997/09/17 17:50:40 mickey Exp $	*/
a231 1
	BIOS_vars.bios_dev = bd->biosdev;
d238 1
@


1.34
log
@unsigneds
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.33 1997/09/03 13:56:11 weingart Exp $	*/
d97 1
a97 1
			  "incb %%cl\n\t"
@


1.33
log
@Fix fake geo (again)
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.32 1997/09/03 04:59:58 weingart Exp $	*/
d63 1
a63 1
	int f, rv;
@


1.32
log
@Fix fake geo
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.31 1997/09/03 04:32:43 weingart Exp $	*/
d235 1
a235 1
		bd->dinfo = 0x01014f11; /* fake geometry */
@


1.31
log
@1st part of pretty "machine diskinfo" stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.30 1997/09/02 23:06:54 mickey Exp $	*/
d47 1
a47 1
	u_int	dinfo;
d235 1
a235 1
		bd->dinfo = 0x0118; /* fake geometry */
@


1.30
log
@change biosdinfo() to return fail value. use fake geo, where needed
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.29 1997/09/02 22:42:25 weingart Exp $	*/
d60 1
a60 1
u_int16_t
d65 3
a67 2
			  /* form a word w/ nhead/nsect packed */
			  "movb %%cl, %b1; andb $0x3f, %b1"
@


1.29
log
@Add "machine diskinfo" command.  Needs work.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.28 1997/09/02 19:24:29 mickey Exp $	*/
d69 1
a69 1
	return (f & 0xff)? 0x0118 : rv;
d233 2
@


1.28
log
@provide two separate interfaces for bios errors mappings:\n error->msg, error->errno
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.27 1997/08/29 19:29:39 mickey Exp $	*/
d60 1
a60 1
static u_int16_t
@


1.27
log
@we have MBR struct and signature defined elsewhere now
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.26 1997/08/22 20:13:42 mickey Exp $	*/
d49 2
a50 2
	u_int8_t biosdev;
	int edd_flags;
d61 1
a61 2
biosdinfo(dev)
	u_int8_t dev;
d63 2
a64 5
	u_int16_t rv;
	u_int8_t f;
	__asm __volatile ("movb $8, %%ah\n\t"
			  DOINT(0x13) "\n\t"
			  "setc %b0\n\t"
d66 1
a66 2
			  "movb %%cl, %b1\n\t"
			  "andb $0x3f, %b1"
d68 2
a69 5
			  : "1" (dev) : "%ecx", "cc");
	if (f)
		return 0x0118; /* ds/hd 3" is the default */
	else
		return rv;
d76 1
a76 2
biosdreset(dev)
	u_int8_t dev;
d79 3
a81 5
	__asm __volatile (DOINT(0x13) "\n\t"
			  "setc %b0"
			  : "=a" (rv)
			  : "0" (0), "id" (dev) : "%ecx", "cc");
	return rv;
d85 1
a85 4
biosd_rw(rw, dev, cyl, head, sect, nsect, buf)
	u_int8_t dev;
	int cyl, head, sect, nsect;
	void *buf;
d112 1
a112 2
EDDcheck (dev)
	u_int8_t dev;
d114 2
a115 5
	u_int8_t rv;
	u_int16_t bm, sgn;
	__asm __volatile("movb $0x44, %%ah\n\t"
			 DOINT(0x13) "\n\t"
			 "setc %b0"
d117 2
a118 6
			 : "2" (0x55aa)
			 : "%edx", "cc");
	if (!rv && sgn == 0xaa55)
		return bm;
	else
		return -1;
d122 1
a122 1
EDD_rw(int rw, u_int8_t dev, u_int64_t daddr, u_int32_t nblk, void *buf)
d124 1
a124 1
	u_int16_t rv;
d132 3
a134 7
	__asm __volatile ("movb %b3, %%ah\n\t"
			  DOINT(0x13) "\n\t"
			  "setc %b0"
			  : "=a" (rv)
			  : "d" (dev), "S" (&cb),
			    "0" ((rw == F_READ)? 0x4200: 0x4300)
			  : "%ecx", "cc");
d206 1
a206 1
		bd->biosdev = (u_int8_t)(unit | 0x80);
d212 1
a212 1
		bd->biosdev = (u_int8_t)unit;
d218 1
a218 1
#ifdef DEBUG
d222 1
a222 1
#ifdef DEBUG
d232 1
a232 1
	bd->dinfo = biosdinfo((dev_t)bd->biosdev);
d239 1
a239 1
	bd->edd_flags = EDDcheck((dev_t)bd->biosdev);
d254 1
a254 1
#ifdef DEBUG
d264 1
a264 1
#ifdef DEBUG
d284 1
a284 1
#ifdef DEBUG
d301 1
a301 1
#ifdef DEBUG
d310 1
a310 1
#ifdef DEBUG
d332 68
d401 7
a407 41
/* BIOS disk errors translation table */
static const struct bd_error {
	u_int8_t bd_id;
	int	unix_id;
	char	*msg;
} bd_errors[] = {
	{ 0x00, 0      , "successful completion" },
	{ 0x01, EINVAL , "invalid function or parameter" },
	{ 0x02, EIO    , "address mark not found" },
	{ 0x03, EROFS  , "disk write-protected" },
	{ 0x04, EIO    , "sector not found/read error" },
	{ 0x05, EIO    , "reset failed" },
	{ 0x06, EIO    , "disk changed" },
	{ 0x07, EIO    , "drive parameter activity failed" },
	{ 0x08, EINVAL , "DMA overrun" },
	{ 0x09, EINVAL , "data boundary error" },
	{ 0x0A, EBSE   , "bad sector detected" },
	{ 0x0B, EBSE   , "bad track detected" },
	{ 0x0C, ENXIO  , "unsupported track or invalid media" },
	{ 0x0D, EINVAL , "invalid number of sectors on format" },
	{ 0x0E, EIO    , "control data address mark detected" },
	{ 0x0F, EIO    , "DMA arbitration level out of range" },
	{ 0x10, EECC   , "uncorrectable CRC or ECC error on read" },
	{ 0x11, 0      , "data ECC corrected" },
	{ 0x20, EIO    , "controller failure" },
	{ 0x31, ENXIO  , "no media in drive" },
	{ 0x32, ENXIO  , "incorrect drive type stored in CMOS" },
	{ 0x40, EIO    , "seek failed" },
	{ 0x80, EIO    , "operation timed out" },
	{ 0xAA, EIO    , "drive not ready" },
	{ 0xB0, EIO    , "volume not locked in drive" },
	{ 0xB1, EIO    , "volume locked in drive" },
	{ 0xB2, EIO    , "volume not removable" },
	{ 0xB3, EDEADLK, "volume in use" },
	{ 0xB4, ENOLCK , "lock count exceeded" },
	{ 0xB5, EINVAL , "valid eject request failed" },
	{ 0xBB, EIO    , "undefined error" },
	{ 0xCC, EROFS  , "write fault" },
	{ 0xE0, EIO    , "status register error" },
	{ 0xFF, EIO    , "sense operation failed" }
};
a415 1
	register const struct bd_error *p = bd_errors;
d422 1
a422 1
#ifdef	BIOS_DEBUG
d459 1
a459 1
#ifdef	BIOS_DEBUG
d473 2
a474 5
				for (p = bd_errors;
				     p < &bd_errors[NENTS(bd_errors)] &&
					     p->bd_id != error; p++);
				printf("\nBIOS error %x (%s)\n",
				       p->bd_id, p->msg);
d483 1
a483 1
#ifdef	BIOS_DEBUG
d485 2
a486 6
		if (error != 0) {
			for (p = bd_errors;
			     p < &bd_errors[NENTS(bd_errors)] &&
				     p->bd_id != error; p++);
			printf("=%x(%s)", p->bd_id, p->msg);
		}
d494 1
a494 1
	return p->unix_id;
@


1.26
log
@put values into BIOS_vars so kernel will get 'em soon
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.25 1997/08/21 20:36:15 mickey Exp $	*/
d276 2
a277 5
		struct {
			u_int8_t		mboot[DOSPARTOFF];
			struct dos_partition	dparts[NDOSPART];
			u_int16_t		signature;
		}	mbr;
d289 1
a289 1
		if (mbr.signature != 0xaa55) {
d299 2
a300 2
			if (mbr.dparts[i].dp_typ == DOSPTYP_OPENBSD)
				off = mbr.dparts[i].dp_start + LABELSECTOR;
d305 2
a306 2
				if (mbr.dparts[i].dp_typ == DOSPTYP_NETBSD)
					off = mbr.dparts[i].dp_start +
@


1.25
log
@BIOS_regs in machdep.c, so they won't get lost w/o biosdev.c
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.24 1997/08/12 19:30:13 mickey Exp $	*/
d257 6
a262 2
	bd->edd_flags = EDDcheck((dev_t)bd->biosdev);
	bootdev_geometry = bd->dinfo = biosdinfo((dev_t)bd->biosdev);
d265 1
@


1.24
log
@inline biosd_rw
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.23 1997/08/12 19:24:57 mickey Exp $	*/
a44 2

struct BIOS_regs	BIOS_regs;
@


1.23
log
@call BIOS inline (add struct EDD_cb into biosvar.h)
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.22 1997/08/07 11:49:15 niklas Exp $	*/
d97 1
a97 1
static int
@


1.22
log
@grammar & spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.20 1997/08/04 21:53:34 mickey Exp $	*/
a49 6
	struct {
		u_int8_t		mboot[DOSPARTOFF];
		struct dos_partition	dparts[NDOSPART];
		u_int16_t		signature;
	}	mbr;
	struct disklabel disklabel;
d53 1
d56 110
d234 3
a237 1
		bd->biosdev = (u_int8_t)(unit | 0x80);
d273 5
d279 1
a279 1
		    DEV_BSIZE, &bd->mbr, NULL)) != 0) {
d289 1
a289 1
		if (bd->mbr.signature != 0xaa55) {
d299 2
a300 2
			if (bd->mbr.dparts[i].dp_typ == DOSPTYP_OPENBSD)
				off = bd->mbr.dparts[i].dp_start + LABELSECTOR;
d305 2
a306 2
				if (bd->mbr.dparts[i].dp_typ == DOSPTYP_NETBSD)
					off = bd->mbr.dparts[i].dp_start +
d326 1
a326 1
	    DEV_BSIZE, buf, NULL)) != 0) {
d360 1
a360 1
const struct bd_error {
a399 1
const int bd_nents = NENTS(bd_errors);
d417 2
a418 1
		printf("biosstrategy(%p,%s,%u,%u,%p,%p), dev=%x:%x\nbiosread:",
d457 3
a459 7
		for (error = 1, j = 5; error && (j > 0); j--) {
			if(rw == F_READ)
				error = biosread(bd->biosdev, cyl, hd, sect, n, bb);
			else
				error = bioswrite(bd->biosdev, cyl, hd, sect, n, bb);

			switch (error) {
d466 3
a468 2
				for (p = bd_errors; p < &bd_errors[bd_nents] &&
					p->bd_id != error; p++);
d470 1
a470 1
					p->bd_id, p->msg);
a473 1
		}
d482 3
a484 2
			for (p = bd_errors; p < &bd_errors[bd_nents] &&
			     p->bd_id != error; p++);
a506 1

@


1.21
log
@fix hd major basing on disklabel d_type info
@
text
@d140 1
a140 1
		printf("no any CD supported at this time\n");
d145 1
a145 1
			printf("Wangtek is unsupported\n");
d331 4
a334 2
			/* XXX we beleive that all the io is buffered
			   by fs routines, so no big reads anyway */
@


1.20
log
@remember boot device geometry
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.19 1997/07/21 15:33:32 mickey Exp $	*/
a123 2
	/* XXX for exec stuff */
	bootdev = bd->bsddev = MAKEBOOTDEV(maj, 0, 0, unit, part);
d154 2
d231 10
@


1.19
log
@correct 'hd' device handling
search for DOSTYP_NETBSD in case there is no DOSTYP_OPENBSD in mbr
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.18 1997/07/18 00:30:15 mickey Exp $	*/
d38 1
d155 1
a155 1
	bd->dinfo = biosdinfo((dev_t)bd->biosdev);
@


1.18
log
@proper includes
const
allocate sapace to pass bios regs to/from call
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.17 1997/05/31 15:34:56 mickey Exp $	*/
d39 1
d90 1
a90 1
	for (maj = 0; maj < NENTS(bdevs) && 
d92 1
a92 1
	if (maj >= NENTS(bdevs)) {
d97 1
a97 1
		return ENXIO;
d105 1
a105 1
		return ENXIO;
d112 1
a112 1
		return ENXIO;
d130 1
d164 1
a164 1
	if (maj == 0 || maj == 4) {	/* wd, sd */
d182 1
a182 1
			return EINVAL;
d189 7
d202 1
a202 1
			return EINVAL;
d219 1
a219 1
		return errno;
d228 1
a228 1
		return EINVAL;
d252 2
a253 2
	{ 0x0A, EIO    , "bad sector detected" },
	{ 0x0B, EIO    , "bad track detected" },
d258 1
a258 1
	{ 0x10, EIO    , "uncorrectable CRC or ECC error on read" },
@


1.17
log
@<string.h> bye-bye
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.16 1997/05/30 02:21:52 mickey Exp $	*/
d38 2
a39 1
#include <libsa.h>
d44 2
d268 1
a268 1
int	bd_nents = NENTS(bd_errors);
@


1.16
log
@EDD support functions, EDD detection code.
com prototypes changes
some indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.14 1997/04/23 14:49:23 weingart Exp $	*/
a37 1
#include <string.h>
@


1.15
log
@solve the bounce buffer problem!
@
text
@d54 1
d149 1
d154 3
a156 2
		printf("BIOS geometry: heads: %u, s/t: %u\n",
			BIOSNHEADS(bd->dinfo), BIOSNSECTS(bd->dinfo));
@


1.14
log
@Clean up disk reset code
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.13 1997/04/23 06:49:06 mickey Exp $	*/
d192 1
a192 1
	buf = alloc(DEV_BSIZE);
a203 1
		free(buf, 0);
a212 1
		free(buf, 0);
a216 1
	free(buf,0);
d306 3
a308 1
			bb = alloc(n * DEV_BSIZE);
d340 2
a341 5
		if (bb != buf) {
			if (rw == F_READ)
				bcopy (bb, buf, n * DEV_BSIZE);
			free (bb, n * DEV_BSIZE);
		}
@


1.13
log
@implement 'hd' device (i guess nobody will boot from 'rd')
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.12 1997/04/20 19:01:35 mickey Exp $	*/
d336 1
a336 1
				biosdreset();
@


1.12
log
@indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.11 1997/04/18 06:54:40 weingart Exp $	*/
d123 3
a125 2
	case 0:	/* wd */
	case 4: /* sd */
d128 1
a128 1
	case 2: /* fd */
d131 4
a134 1
	case 3: /* wt */
d136 5
a140 1
		if (debug)
@


1.11
log
@Clean up error handling a little.  There is a small
problem with marginal disks.  This code does not
like them at all.  I'm too frazzled right now to
figure this out.  This should give better error
messages...
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.10 1997/04/18 04:23:51 mickey Exp $	*/
d326 2
a327 1
				printf("\nBIOS error %x (%s)\n", p->bd_id, p->msg);
@


1.10
log
@fix a bug
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.9 1997/04/18 01:28:01 mickey Exp $	*/
d310 6
a315 4
		for (error = 1, j = 5; error && j--;) {
			error = (rw == F_READ)?
				  biosread (bd->biosdev, cyl, hd, sect, n, bb)
				: bioswrite(bd->biosdev, cyl, hd, sect, n, bb);
d323 6
a328 9
			default:
#ifdef	BIOS_DEBUG
				if (debug) {
					for (p = bd_errors; p < &bd_errors[bd_nents] &&
			     			p->bd_id != error; p++);
					printf("\nBIOS error %x (%s)\n", p->bd_id, p->msg);
				}
#endif
				continue;
@


1.9
log
@no more 60k limit!
no more explicit real<-->prot switching!
fix 2.88 floppy drives.....
kbd fixes coming soon!
test it!
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.8 1997/04/17 19:03:20 weingart Exp $	*/
d282 1
a282 1
	if (!(bd->biosdev & 0x80))
@


1.8
log
@Fix error handling from bios & typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.7 1997/04/15 20:50:35 mickey Exp $	*/
d266 1
a266 1
	register size_t i, nsect, n;
d281 6
d292 3
a294 4
		btochs(blk, cyl, hd, sect, 
			BIOSNHEADS(bd->dinfo), BIOSNSECTS(bd->dinfo));
		if ((sect + (nsect - i)) >= BIOSNSECTS(bd->dinfo))
			n = BIOSNSECTS(bd->dinfo) - sect;
@


1.7
log
@pass bootdev to kernel...
all the future devices have to copy it into global var...
in the current state i can boot any kernel i have....
testers?
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.6 1997/04/15 06:25:18 mickey Exp $	*/
d293 1
a293 1
		/* use a bounce buffer to not to cross 64k DMA boundary */
d311 1
a311 5
			case 0x06:	/* disk changed */
				printf ("disk changed\n");
			default:
				continue;

d315 10
@


1.6
log
@do bounce-buffering to avoid DMA overrun
somebody, test it!
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.5 1997/04/09 08:39:15 mickey Exp $	*/
d119 2
a120 1
	bd->bsddev = MAKEBOOTDEV(maj, 0, 0, unit, part);
@


1.5
log
@emulate bios calls. more debugging stuff. some fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.4 1997/04/08 22:48:27 mickey Exp $	*/
d282 2
a283 1
		register int	cyl, hd, sect;
d291 9
d302 1
a302 1
			printf(" (%d,%d,%d,%d)@@%p", cyl, hd, sect, n, buf);
d304 10
a313 4
		if (rw == F_READ)
			error = biosread (bd->biosdev, cyl, hd, sect, n, buf);
		else
			error = bioswrite(bd->biosdev, cyl, hd, sect, n, buf);
d315 5
a319 3
		if (error != 0) {
			for (p = bd_errors; p < &bd_errors[bd_nents] &&
			     p->bd_id != error; p++);
d321 4
a324 2
			if (error == 0x11) /* ECC corrected */
				error = 0;
d330 3
a332 1
		if (error != 0)
d334 1
@


1.4
log
@use new device names: fd(0,a) -> fd0a
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.3 1997/03/31 23:06:26 mickey Exp $	*/
d217 1
a217 1
static const struct bd_error {
@


1.3
log
@commit all my mods to the last imported libsa stuff....
including:
- disklabel support;
- better boot cmd line
- smaller size (using some compilation switches ;)
- no more relocations in /boot, it's loaded in the place;
- better disk performance (maybe were already in there)
- installboot -n does not require write perms for device
- more debugs
- missing parts in libsa (such as cd9660 and so)
- i don't like 2 files for exec_i386 (sorry, toby, let's discuss maybe?)
tricks and tails:
- joined .text and .data (saves you a page)
- prot mode switching still in biosboot (it's freezed for awhile)
- biosdisk internals changed
- biosdev is not passed propery to the kernel (i'll fix it soon)
- sure i missed smth here to note (use the source, Luke!)
@
text
@d1 1
a1 1
/*	$OpenBSD: biosdev.c,v 1.1.2.1 1996/10/29 09:22:50 mickey Exp $	*/
d60 1
a60 2
	register char	*p, *cp, *fname, **file;
	char	devname[sizeof(bdevs[0])];
a65 1
	size_t rsize;
d68 1
a68 1
	cp = fname = *(file = va_arg(ap, char **));
d78 17
a94 16
	for ( p = devname; *cp != 0 && *cp != '(';)
		*p++ = *cp++;
	*p = '\0';
	if (*cp != 0) {
		if (*cp++ == '(') {
			for (maj = 0; maj < NENTS(bdevs) && 
				strncmp(devname, bdevs[maj], sizeof(devname));
				maj++);
			if (maj >= NENTS(bdevs)) {
				printf("Unknown device: %s\n", devname);
				return ENXIO;
			}
		} else {
			printf("Syntax error\n");
			return EINVAL;
		}
d96 34
a129 31
		/* get unit */
		if ('0' <= *cp && *cp <= '9')
			unit = *cp++ - '0';
		else {
			printf("Bad unit number\n");
			return ENXIO;
		}
		cp++;	/* skip ',' */
		/* get partition */
		if ('a' <= *cp && *cp <= 'p')
			part = *cp++ - 'a';
		else {
			printf("Bad partition id\n");
			return ENXIO;
		}
		cp++;	/* skip ')' */
		if (*cp != 0)
			*file = cp;

		bd = alloc(sizeof(*bd));
		bzero(bd, sizeof(bd));

		switch (maj) {
		case 0:	/* wd */
		case 4: /* sd */
			bd->biosdev = (u_int8_t)(unit | 0x80);
			break;
		case 2: /* fd */
			bd->biosdev = (u_int8_t)unit;
			break;
		case 3: /* wt */
d131 2
a132 2
			if (debug)
				printf("Wangtek is unsupported\n");
d134 4
a137 4
		default:
			free(bd, 0);
			return ENXIO;
		}
d139 1
a139 5
		bd->bsddev = MAKEBOOTDEV(maj, 0, 0, unit, part);
		bd->dinfo = biosdinfo((dev_t)bd->biosdev);

	} else
		return ENOENT;
d150 1
a150 1
		    DEV_BSIZE, &bd->mbr, &rsize)) != 0) {
d169 2
a170 2
		for (off = 0, i = 0; i < NDOSPART; i++)
			if (bd->mbr.dparts[i].dp_typ == DOSPTYP_OPENBSD) {
a171 2
				break;
			}
d190 1
a190 1
	    DEV_BSIZE, buf, &rsize)) != 0) {
d200 1
a200 1
	if ((p = getdisklabel(buf, &bd->disklabel)) != NULL) {
d203 1
a203 1
			printf("%s\n", p);
d269 3
a271 1
	blk += bd->disklabel.d_partitions[B_PARTITION(bd->bsddev)].p_offset;
a282 4
#if 0
		/* fight seg boundary error XXX */
		static u_int8_t bbuf[DEV_BSIZE];
#endif
d294 1
a294 1
		if (rw == F_READ) {
d296 1
a296 3
			/* bcopy(bbuf, buf, sizeof(bbuf)); */
		} else {
			/* bcopy(buf, bbuf, sizeof(bbuf)); */
d298 1
a298 1
		}
d316 2
a317 1
	*rsize = i * DEV_BSIZE;
@


1.2
log
@Initial /boot stuff (from Mickey)
@
text
@d36 3
d42 1
a42 1
dev_t	maj, unit, part;
d44 1
a44 5
int
biosstrategy(void *devdata, int rw,
	daddr_t blk, size_t size, void *buf, size_t *rsize)
{
	int	error = 0;
d46 9
a54 52
	register size_t i, nsect;
	void *local_buf, *lb;			/* 1MB real mode stuff */

	/* We need a buffer below 1MB 
	 *
	 * Note: not really needed for the gzip stuff,
	 * as it already allocates buffers below 1MB,
	 * but just to make sure (in case using oread()
	 */
	lb = local_buf = alloc(size);

#ifdef	BIOS_DEBUG
	printf("biosstrategy: %s %d bytes @@ %d -> %p\n",
		(rw==F_READ?"reading":"writing"), size, blk, buf);
#endif

	dinfo = biosdinfo(bootdev);
	nsect = (size + DEV_BSIZE-1) / DEV_BSIZE;
	for (i = 0; error == 0 && i < nsect; ) {
		register int	cyl, hd, sect, n;

		btochs(blk, cyl, hd, sect, 
			BIOSNHEADS(dinfo), BIOSNSECTS(dinfo));
		if ((sect + (nsect - i)) >= BIOSNSECTS(dinfo))
			n = BIOSNSECTS(dinfo) - sect;
		else
			n = nsect - i;
#ifdef	BIOS_DEBUG
		printf("biosread: dev=%x, cyl=%d, hd=%d, sc=%d, n=%d, buf=%lx",
			bootdev, cyl, hd, sect, n, (u_long)local_buf);
#endif
		if (rw == F_READ)
			error = biosread (bootdev, cyl, hd, sect, n, local_buf);
		else
			error = bioswrite(bootdev, cyl, hd, sect, n, local_buf);
#ifdef	BIOS_DEBUG
		printf(", ret=%x\n", error);
#endif
		local_buf += n * DEV_BSIZE;
		i += n;
		blk += n;
	}

	/* Copy to final location */
	memcpy(buf, lb, size);
	free(lb, size);

	/* Amount we read */
	*rsize = i * DEV_BSIZE;

	return error;
}
d60 8
a67 2
	register char	*cp, *fname, **file;
	static const char *devs[] = {"wd", "hd", "fd", "wt", "sd", NULL};
d73 6
d80 3
a82 2
	while (*cp != 0 && *cp != '(')
		cp++;
d85 6
a90 10
			char **devp = (char **)devs;

			for (; *devp != NULL && 
				(fname[0] != (*devp)[0] ||
				 fname[1] != (*devp)[1]); devp++)
				;
			if (*devp == NULL) {
				printf("Unknown device");
				errno = ENXIO;
				return -1;
d92 1
a92 4
			maj = devp - (char **)devs;
		}
		/* check syntax */
		if (cp[1] != ',' || cp[3] != ')') {
d94 1
a94 2
			errno = EINVAL;
			return -1;
d102 1
a102 2
			errno = ENXIO;
			return -1;
d110 1
a110 2
			errno = ENXIO;
			return -1;
d116 3
d120 3
a122 7
		case 0:
		case 4:
			bootdev = unit | 0x80;
			break;
		case 1:
			bootdev = unit | 0x80;
			unit = 0;
d124 2
a125 2
		case 2:
			bootdev = unit;
d127 1
a127 1
		case 3:
d129 2
a130 1
			printf("Wangtek is unsupported\n");
a131 2
			errno = ENXIO;
			return -1;
d133 51
a183 1
			break;
d185 1
d187 15
d204 13
d220 109
d332 1
a332 1

@


1.1
log
@file biosdev.c was initially added on branch new.
@
text
@d1 197
@


1.1.2.1
log
@support libsa
@
text
@a0 108
/*	$OpenBSD: biosdev.c,v 1.1.2.2 1996/10/16 10:20:47 mickey Exp $	*/

/*
 * Copyright (c) 1996 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <libsa.h>
#include "biosdev.h"

const char	*devs[] = {"wd", "hd", "fd", "wt", "sd", NULL};

dev_t	maj, unit, part;

int
biosstrategy(void *devdata, int rw,
	daddr_t blk, size_t size, void *buf, size_t *rsize)
{
	int	error = 0;
	u_int	dinfo;
	register size_t i, nsect;

#ifdef	BIOS_DEBUG
	printf("biosstrategy: %s %d bytes @@ %d\n",
		(rw==F_READ?"reading":"writing"), size, blk);
#endif

	dinfo = biosdinfo(bootdev);
	nsect = (size + DEV_BSIZE-1) / DEV_BSIZE;
	for (i = 0; error == 0 && i < nsect; ) {
		register int	cyl, hd, sect, n;

		btochs(blk, cyl, hd, sect, 
			BIOSNHEADS(dinfo), BIOSNSECTS(dinfo));
		if ((sect + (nsect - i)) >= BIOSNSECTS(dinfo))
			n = BIOSNSECTS(dinfo) - sect;
		else
			n = nsect - i;
#ifdef	BIOS_DEBUG
		printf("biosread: dev=%x, cyl=%d, hd=%d, sc=%d, n=%d, buf=%lx",
			bootdev, cyl, hd, sect, n, (u_long)buf);
#endif
		if (rw == F_READ)
			error = biosread (bootdev, cyl, hd, sect, n, buf);
		else
			error = bioswrite(bootdev, cyl, hd, sect, n, buf);
#ifdef	BIOS_DEBUG
		printf(", ret=%x\n", error);
#endif
		buf += n * DEV_BSIZE;
		i += n;
		blk += n;
	}

	*rsize = i * DEV_BSIZE;

	return error;
}

int
biosopen(struct open_file *f, ...)
{

	return 0;
}

int
biosclose(struct open_file *f)
{

	return 0;
}

int
biosioctl(struct open_file *f, u_long cmd, void *data)
{

	return 0;
}

@

