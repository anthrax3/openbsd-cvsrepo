head	1.36;
access;
symbols
	OPENBSD_6_2:1.36.0.22
	OPENBSD_6_2_BASE:1.36
	OPENBSD_6_1:1.36.0.20
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.16
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.12
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.14
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.6
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.36.0.10
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.8
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.4
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.36.0.2
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.32.0.24
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.22
	OPENBSD_5_0:1.32.0.20
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.18
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.16
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.12
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.14
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.10
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.8
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.6
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.4
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.31.0.6
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.4
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.28.0.6
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.4
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.24.0.10
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.8
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.24.0.6
	OPENBSD_3_1_BASE:1.24
	UBC_SYNC_B:1.24
	UBC:1.24.0.4
	UBC_BASE:1.24
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9:1.23.0.14
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_8:1.23.0.12
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.23.0.10
	OPENBSD_2_7_BASE:1.23
	SMP:1.23.0.8
	SMP_BASE:1.23
	kame_19991208:1.23
	OPENBSD_2_6:1.23.0.6
	OPENBSD_2_6_BASE:1.23
	OPENBSD_2_5:1.23.0.4
	OPENBSD_2_5_BASE:1.23
	OPENBSD_2_4:1.23.0.2
	OPENBSD_2_4_BASE:1.23
	OPENBSD_2_3:1.21.0.2
	OPENBSD_2_3_BASE:1.21
	OPENBSD_2_2:1.18.0.2
	OPENBSD_2_2_BASE:1.18
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4;
locks; strict;
comment	@# @;


1.36
date	2012.10.31.13.55.58;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2012.10.09.12.39.12;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2012.10.09.11.39.57;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2012.10.08.12.46.37;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2006.12.26.19.30.44;	author tom;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.31.23.08.47;	author jmc;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.30.16.14.35;	author tom;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.25.23.09.04;	author tom;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.19.13.48.18;	author tom;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.13.23.54.07;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.03.20.22.12;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.17.03.43.18;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.17.13.10.09;	author deraadt;	state Exp;
branches
	1.24.4.1;
next	1.23;

1.23
date	98.09.25.06.48.52;	author mickey;	state Exp;
branches
	1.23.8.1;
next	1.22;

1.22
date	98.09.16.03.40.32;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	98.04.18.07.39.51;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	98.02.25.12.28.24;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	98.02.24.22.06.52;	author weingart;	state Exp;
branches;
next	1.18;

1.18
date	97.10.24.22.22.26;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	97.10.19.22.48.36;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	97.10.17.15.03.24;	author weingart;	state Exp;
branches;
next	1.15;

1.15
date	97.09.02.17.05.12;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	97.08.13.04.03.30;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	97.08.02.22.23.09;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.08.01.21.06.03;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.07.31.20.15.08;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.07.30.19.40.58;	author flipk;	state Exp;
branches;
next	1.9;

1.9
date	97.07.29.16.48.40;	author flipk;	state Exp;
branches;
next	1.8;

1.8
date	97.07.28.23.03.31;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.07.24.21.50.10;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.07.18.00.48.19;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.05.29.05.32.07;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.04.18.01.28.02;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.04.09.08.39.37;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	97.04.07.01.21.54;	author weingart;	state Exp;
branches;
next	1.1;

1.1
date	97.04.05.18.56.27;	author mickey;	state Exp;
branches;
next	;

1.23.8.1
date	2001.10.31.03.01.13;	author nate;	state Exp;
branches;
next	1.23.8.2;

1.23.8.2
date	2003.05.13.19.42.09;	author ho;	state Exp;
branches;
next	1.23.8.3;

1.23.8.3
date	2003.06.07.11.11.38;	author ho;	state Exp;
branches;
next	1.23.8.4;

1.23.8.4
date	2004.02.19.10.48.43;	author niklas;	state Exp;
branches;
next	1.23.8.5;

1.23.8.5
date	2004.06.05.23.09.01;	author niklas;	state Exp;
branches;
next	;

1.24.4.1
date	2003.05.19.21.45.12;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Bring softraid support to i386/stand/libsa.
@
text
@/*	$OpenBSD: gidt.S,v 1.35 2012/10/09 12:39:12 jsing Exp $	*/

/*
 * Copyright (c) 1997 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

	.file "gidt.S"

#include <machine/asm.h>
#define _LOCORE
#include <machine/trap.h>
#include <debug_md.h>
#undef _LOCORE
#include <assym.h>

#include "gidt.h"

#ifdef GIDT_DEBUG
#define	gidt_debug0		; \
	mov	$0xb8000, %eax	; \
	mov	$0x47314730, (%eax)
#define	gidt_debug1		; \
	mov	$(0xb8000 - LINKADDR), %eax	; \
	mov	$0x4f314f30, (%eax)
#define	gidt_debug2		; \
	mov	$0xb8004, %eax	; \
	mov	$0x47334732, (%eax)
#define	gidt_debug3		; \
	mov	$0xb8004, %eax	; \
	mov	$0x4f334f32, (%eax)
#define gidt_debug4		; \
	movl	$0xb8008, %eax	; \
	movl	$0x47344733, (%eax)
#else
#define gidt_debug0 /* gidt_debug0 */
#define gidt_debug1 /* gidt_debug1 */
#define gidt_debug2 /* gidt_debug2 */
#define gidt_debug3 /* gidt_debug3 */
#define gidt_debug4 /* gidt_debug4 */
#endif

#define prot2real						\
	gidt_debug0;						\
								\
	ljmp	$S16TEXT, $1f - LINKADDR;			\
1:								\
	.code16;						\
	movw	$S16DATA, %ax;					\
	movw	%ax, %ds;					\
	movw	%ax, %es;					\
	gidt_debug1;						\
								\
	movl	%cr0, %eax;	/* disable pmmm */		\
	andl 	$~CR0_PE, %eax;					\
	movl	%eax, %cr0;					\
								\
	/* reload real cs:ip */					\
	data32 ljmp	$(LINKADDR >> 4), $1f - LINKADDR;	\
1:								\
	movw	%cs, %ax;	/* setup: %ds, %es, %ss = %cs */ \
	movw	%ax, %ds;					\
	movw	%ax, %es;					\
	xorw	%ax, %ax;					\
	movw	%ax, %ss;					\
								\
	gidt_debug2;						\
								\
	data32 addr32 lidt (Idtr_real - LINKADDR); /* load idtr for real mode */

#define real2prot						\
	gidt_debug3;						\
								\
	movw	$LINKADDR >> 4, %ax;				\
	movw	%ax, %ds;					\
	data32 addr32 lgdt (Gdtr - LINKADDR); 	/* load the gdtr */	\
								\
	movl	%cr0, %eax;	/* enable pmmm */		\
	orl	$CR0_PE, %eax;					\
	movl	%eax, %cr0;					\
								\
	data32 ljmp	$S32TEXT, $1f;   /* reload %cs,flush pipeline */\
1:								\
	.code32;						\
	/* reload 32bit %ds, %ss, %es */			\
	mov	$S32DATA, %eax;					\
	mov	%ax, %ds;					\
	mov	%ax, %ss;					\
	mov	%ax, %es;					\
								\
	gidt_debug4;						\
								\
	/* load idtr for debugger and DOS/BIOS iface */		\
	lidt	Idtr;


	.globl	_C_LABEL(BIOS_regs)

	.text
	.code32
	.globl	_ASM_LABEL(pmm_init)
	.globl	_C_LABEL(_rtt)

ENTRY(_rtt)
#ifdef SOFTRAID
	call	_C_LABEL(sr_clear_keys)
#endif
#ifdef GIDT_DEBUG
	movl	$0xb8000, %ebx
	movl	$0x4f514f51, (%ebx)
#endif
	movw	$0x1234, %ax
	movw	%ax, 0x472	/* warm boot */

	/* Try to use the KBD to reboot system */
	movb	$0xfe, %al
	outb	%al, $0x64

	movl	$0x5000, %ecx
1:	inb	$0x84, %al
	loop	1b

	movb	$0xfe, %al
	outb	%al, $0x64

#ifdef GIDT_DEBUG
	movl	$0xb8000, %ebx
	movl	$0x07310731, (%ebx)
#endif

	/* Try to cause a triple fault... */
	lidt	Idtr_reset
	xorl	%eax, %eax
	divl	%eax, %eax

	/* Again... */
	int $0x8

	/* Again... */
	movl	$0, %esp	/* segment violation */
	ret

#define IPROC(n)	X##n
#define IEMU(n)		IPROC(emu##n)

create_idt_entry:
	movw	%ax, (%ebx)
	movw	$S32TEXT, 2(%ebx)
	movw	$((0x80|SDT_SYS386TGT) << 8), 4(%ebx)
	shr	$16, %eax
	movw	%ax, 6(%ebx)
	addl	$8, %ebx
	ret

	.align	8, 0x90
pmm_init:

#define idte(e)	\
	movl $IPROC(e), %eax; call create_idt_entry
#define idtb(b)	idte(emu##b)

	/* Build interrupt descriptor table. */
	/* Maskable interrupts (32-255) */
	movl	$idt, %ebx
	movl	$Idtr, %eax
	movw	$(640 - 1), (%eax)
	movl	%ebx, 2(%eax)

	/* Internal (0-31) */
	idte(de); idte(db); idte(nmi); idte(bp); idte(of); idte(br)
	idte(ud); idte(nm); idte(df);  idte(fo); idte(ts); idte(np)
	idte(ss); idte(gp); idte(pf);  idte(xx); idte(mf); idte(ac)
	idte(mc)
	idte(xx); idte(xx); idte(xx);  idte(xx); idte(xx); idte(xx)
	idte(xx); idte(xx); idte(xx);  idte(xx); idte(xx); idte(xx)
	idte(xx) 
	/* BIOS entry points (32-63) */
	idtb(0);  idtb(1);  idtb(2);  idtb(3);  idtb(4);  idtb(5)
	idtb(6);  idtb(7);  idtb(8);  idtb(9);  idtb(10); idtb(11)
	idtb(12); idtb(13); idtb(14); idtb(15); idtb(16); idtb(17)
	idtb(18); idtb(19); idtb(20); idtb(21); idtb(22); idtb(23)
	idtb(24); idtb(25); idtb(26); idtb(27); idtb(28); idtb(29)
	idtb(30); idtb(31); idtb(32); idtb(33); idtb(34); idtb(35)
	idtb(36); idtb(37); idtb(38); idtb(39); idtb(40); idtb(41)
	idtb(42); idtb(43); idtb(44); idtb(45); idtb(46); idtb(47)
	/* DOS entry points (64-80) */

#undef idtb
#undef idte

	/* load idtr for interrupts */
	lidt	Idtr
	ret

	.bss
	.align 8, 0x90
idt:
	/* IDT has 80 entries at 8 bytes each. */
	.space  640

	.globl	Idtr
Idtr:	.word	0  // 640 - 1
	.long	0  // idt
	.word	0

	.text
	.align	8
	.globl	Idtr_real
Idtr_real:
	.word	1023
	.long	0
	.word	0

	.align	8
Idtr_reset:
	.long	0, 0

	.align	8
gdt:
		/* 0x00 : null */
	.space	8
		/* 0x08 : flat code */
	.word	0xFFFF			# lolimit
	.word	0			# lobase
	.byte	0			# midbase
	.byte	SDT_MEMERAC | 0 | 0x80	# RXAC, dpl = 0, present
	.byte	0xf | 0 | 0x40 | 0x80	# hilimit, xx, 32bit, 4k granularity
	.byte	0			# hibase
		/* 0x10 : flat data */
	.word	0xFFFF			# lolimit
	.word	0			# lobase
	.byte	0			# midbase
	.byte	SDT_MEMRWA | 0 | 0x80	# RWA, dpl = 0, present
	.byte	0xf | 0 | 0x40 | 0x80	# hilimit, xx, 32bit, 4k granularity
	.byte	0			# hibase
		/* 0x18 : 16 bit code */
	.word	0xFFFF			# lolimit
	.word	(LINKADDR & 0xffff)	# lobase
	.byte	(LINKADDR >> 16) & 0xff	# midbase
	.byte	SDT_MEMERAC | 0 | 0x80	# RXAC, dpl = 0, present
	.byte	0x0 | 0 | 0 | 0		# hilimit, xx, 16bit, byte granularity
	.byte	(LINKADDR >> 20) & 0xff	# hibase
		/* 0x20 : 16 bit data */
	.word	0xFFFF			# lolimit
	.word	(LINKADDR & 0xffff)	# lobase
	.byte	(LINKADDR >> 16) & 0xff	# midbase
	.byte	SDT_MEMRWA | 0 | 0x80	# RWA, dpl = 0, present
	.byte	0x0 | 0 | 0 | 0		# hilimit, xx, 16bit, byte granularity
	.byte	(LINKADDR >> 20) & 0xff	# hibase

.globl Gdtr
Gdtr:	.word	. - gdt - 1
	.long	gdt
	.word	0

#define IENTRY(name,type) \
IPROC(name): \
	pushl	$type ; \
	jmp	1f
#define IENTRY_ERR(name,err,type) \
IPROC(name): \
	pushl	$err ; \
	pushl	$type ; \
	jmp	1f

IPROC(xx):
	pushl	$1
	pushl	$T_RESERVED
	jmp	1f

IENTRY_ERR(de,0,T_DIVIDE)	/* #DE divide by zero */
IENTRY_ERR(db,0,T_TRCTRAP)	/* #DB debug */
IENTRY_ERR(nmi,0,T_NMI)		/* NMI */
IENTRY_ERR(bp,0,T_BPTFLT)	/* #BP breakpoint */
IENTRY_ERR(of,0,T_OFLOW)	/* #OF overflow */
IENTRY_ERR(br,0,T_BOUND)	/* #BR BOUND range exceeded */
IENTRY_ERR(ud,0,T_PRIVINFLT)	/* #UD invalid opcode */
IENTRY_ERR(nm,0,T_DNA)		/* #NM device not available */
IENTRY(df,T_DOUBLEFLT)		/* #DF double fault */
IENTRY_ERR(fo,0,T_FPOPFLT)	/* #FO coprocessor segment overrun */
IENTRY(ts,T_TSSFLT)		/* #TS invalid TSS */
IENTRY(np,T_SEGNPFLT)		/* #NP segment not present */
IENTRY(ss,T_STKFLT)		/* #SS stack fault */
IENTRY(gp,T_PROTFLT)		/* #GP general protection */
IENTRY(pf,T_PAGEFLT)		/* #PF page fault */
IENTRY_ERR(mf,0,T_ARITHTRAP)	/* #MF floating point error */
IENTRY(ac,T_ALIGNFLT)		/* #AC alignment check */
IENTRY(mc,T_MACHK)		/* #MC machine check */

	.globl	alltraps
1:	/* save on jumps */
	jmp	alltraps

#define	IEMUENT(n)	IEMU(n): pushl $n; jmp 1f

IEMUENT(0);  IEMUENT(1);  IEMUENT(2);  IEMUENT(3)
IEMUENT(4);  IEMUENT(5);  IEMUENT(6);  IEMUENT(7)
IEMUENT(8);  IEMUENT(9);  IEMUENT(10); IEMUENT(11)
IEMUENT(12); IEMUENT(13); IEMUENT(14); IEMUENT(15)
IEMUENT(16); IEMUENT(17); IEMUENT(18); IEMUENT(19)
IEMUENT(20); IEMUENT(21); IEMUENT(22); IEMUENT(23)
IEMUENT(24); IEMUENT(25); IEMUENT(26); IEMUENT(27)
IEMUENT(28); IEMUENT(29); IEMUENT(30); IEMUENT(31)
1:	jmp	EMUh	/* redirect for short jumps */
IEMUENT(32); IEMUENT(33); IEMUENT(34); IEMUENT(35)
IEMUENT(36); IEMUENT(37); IEMUENT(38); IEMUENT(39)
IEMUENT(40); IEMUENT(41); IEMUENT(42); IEMUENT(43)
IEMUENT(44); IEMUENT(45); IEMUENT(46); IEMUENT(47)
1:	jmp	EMUh

/*
 * entry point for BIOS real-mode interface
 * all the magic for real-prot mode switching is here
 *
 * Note: Once in real mode access to .data or .bss should be avoided since it
 * may not be reachable within the current segment. The following code also
 * assumes that .text is writeable.
 *
 * Call:	%eax, %ecx, %edx, %ebx, %ebp, %esi, %edi, %es, %ds
 * Return:	%eax, %edx, %ecx, %eflags (as returned from BIOS)
 *
 */
	.globl	EMUh
	.align	8, 0x90
EMUh:
	/* save %eax */
	mov	%eax, 5f
	pop	%eax

	pusha
	push	%ds
	push	%es
	push	%fs
	push	%gs

	/* save BIOS int vector */
	mov	%al, intno

	/* Load BIOS registers prior to switching to real mode. */
	movl	_C_LABEL(BIOS_regs)+BIOSR_ES, %eax
	mov	%eax, 7f
	movl	_C_LABEL(BIOS_regs)+BIOSR_DS, %eax
	mov	%eax, 6f

	prot2real

	push	%ds

	# data32 movl $Leax, %eax
	.byte	0x66, 0xb8
7:	.long	0x90909090
	mov	%ax, %es

	# data32 movl $Leax, %eax
	.byte	0x66, 0xb8
6:	.long	0x90909090
	mov	%ax, %ds

	# data32 movl $Leax, %eax
	.byte	0x66, 0xb8
5:	.long	0x90909090

	;sti
	int	$0
intno	= . - 1
	;cli

	pop	%ds

	/* Preserve BX and ES for protected mode. */
	addr32 movl %eax, (2f - LINKADDR)
	movl	%ebx, %eax
	addr32 movl %eax, (4f - LINKADDR)
	movl	%es, %eax
	addr32 movl %eax, (3f - LINKADDR)
	addr32 movl (2f - LINKADDR), %eax

	movb	%ah, %bh
	lahf
	xchgb	%ah, %bh

	/* Preserve AX for protected mode. */
	addr32 movl %eax, (2f - LINKADDR)

	real2prot

	# movl $Leax, %eax
	.byte	0xb8
4:	.long	0x90909090
	movl	%eax, _C_LABEL(BIOS_regs)+BIOSR_BX

	# movl $Leax, %eax
	.byte	0xb8
3:	.long	0x90909090
	movl	%eax, _C_LABEL(BIOS_regs)+BIOSR_ES

	# movl $Leax, %eax
	.byte	0xb8
2:	.long	0x90909090

	/* pass BIOS return values back to caller */
	movl	%eax, 0xb*4(%esp)
	movl	%ecx, 0xa*4(%esp)
	movl	%edx, 0x9*4(%esp)
	movb	%bh , 0xe*4(%esp)

	/* clear NT flag in eflags */
	/* Martin Fredriksson <martin@@gbg.netman.se> */
	pushf
	pop	%eax
	and	$0xffffbfff, %eax
	push	%eax
	popf

	/* save registers into save area */
	movl	%eax, _C_LABEL(BIOS_regs)+BIOSR_AX
	movl	%ecx, _C_LABEL(BIOS_regs)+BIOSR_CX
	movl	%edx, _C_LABEL(BIOS_regs)+BIOSR_DX
	movl	%ebp, _C_LABEL(BIOS_regs)+BIOSR_BP
	movl	%esi, _C_LABEL(BIOS_regs)+BIOSR_SI
	movl	%edi, _C_LABEL(BIOS_regs)+BIOSR_DI

	pop	%gs
	pop	%fs
	pop	%es
	pop	%ds
	popa
	iret

/* Call buffer at 07c0:0000 in real mode to simulate a BIOS boot */
ENTRY(bootbuf)
	pop	%eax		/* Don't need return address */
	pop	%esi		/* Buffer */
	pop	%edx		/* Device */
	prot2real		/* Switch */

	/* Set up stack */
	cli
	xor	%ax, %ax
	mov	%ax, %ss
	mov	$0xfffc, %esp
	sti

	/* Jump to buffer */
	ljmp	$0x0, $0x7c00

	.end
@


1.35
log
@Put the real mode IDT and the GDT back in .text - having them in .data only
works if .data is within the same segment.
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.34 2012/10/09 11:39:57 jsing Exp $	*/
d127 3
@


1.34
log
@Dynamically build the Interrupt Descriptor Table (IDT), instead of using
a static table. This allows the IDT to be placed in .bss and avoids the
"relocation truncated" errors that result from the linker trying to put
a 32-bit address into a 16-bit hole.

With input from Marco Peereboom.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.33 2012/10/08 12:46:37 jsing Exp $	*/
d225 1
a225 1
	.data
a274 1
	.text
@


1.33
log
@Avoid accessing .data or .bss from real mode, since they may not be within
the current segment. Load and store the necessary BIOS registers from
protected mode, preserving the register values across the real mode and
protected mode switches by directly patching instructions. This allows for
boot(8) to be larger than 64KB.
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.31 2005/05/31 23:08:47 jmc Exp $	*/
d151 1
a151 1
	lidt    Idtr_reset
d162 12
a175 3
	/* load idtr for interrupts */
	lidt	Idtr
	ret
d177 10
d188 1
a188 13
#ifdef __STDC__
#define IPROC(n)	X##n
#define IEMU(n)		IPROC(emu##n)
#else
#define IPROC(n)	X/**/n
#define IEMU(n)		IPROC(emu/**/n)
#endif
	.align 8, 0x90
idt:
#define idte(e)	\
	.short	IPROC(e); .short (S32TEXT); \
	.short	((0x80|SDT_SYS386TGT) << 8); .short (LINKADDR >> 16)
/* internal (0-31) */
d196 1
a196 8
		/* Maskable interrupts (32-255) */
		/* BIOS entry points (32-63) */
		/* DOS entry points (64-80) */
#ifdef __STDC__
#define idtb(b)	idte(emu##b)
#else
#define idtb(b)	idte(emu/**/b)
#endif
d205 3
d209 11
d221 2
a222 2
Idtr:	.word	. - idt - 1
	.long	idt
d225 1
d228 4
a231 3
Idtr_real:	.word	1023
		.long	0
		.word	0
d234 2
a235 1
Idtr_reset:	.long	0, 0
d275 1
@


1.32
log
@There is a single 'p', not a double, in 'triple'.
@
text
@d317 4
d329 1
a329 1
	mov	%eax, 3f
d341 6
d351 9
a359 4
	addr32  movw (_C_LABEL(BIOS_regs)+(BIOSR_ES) - LINKADDR), %ax
	movw	%ax, %es
	addr32  movw (_C_LABEL(BIOS_regs)+(BIOSR_DS) - LINKADDR), %ax
	movw	%ax, %ds
d363 1
a363 1
3:	.long	0x90909090
d372 8
a379 3
	addr32 movl %ebx, (_C_LABEL(BIOS_regs)+(BIOSR_BX) - LINKADDR)
	movw	%es, %bx
	addr32 movw %bx, (_C_LABEL(BIOS_regs)+(BIOSR_ES) - LINKADDR)
d384 1
d390 12
a401 2
	.byte 0xb8
2:	.long 0x90909090
d447 1
a447 1
	ljmp $0x0, $0x7c00
@


1.31
log
@spelling corrections in comments;
from charlie root;
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.30 2005/04/30 16:14:35 tom Exp $	*/
d150 1
a150 1
	/* Try to cause a tripple fault... */
@


1.30
log
@Ensure we save the %ebx register returned from the BIOS call, not just
%bx.  Fixes problem introduced in gidt.S r1.29, which could lead to an
incomplete memory map, and "too little memory available; running in
degraded mode", as found by Roy Morris rmorris (at) internetsecure (dot)
com.  (Thanks for the report, and for testing the fix.)

Bump version on boot, cdboot and pxeboot accordingly.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.29 2005/04/25 23:09:04 tom Exp $	*/
d283 2
a284 2
IENTRY(ts,T_TSSFLT)		/* #TS innvalid TSS */
IENTRY(np,T_SEGNPFLT)		/* #NP segmant not present */
@


1.29
log
@[OpenBSD]

Make boot code use real mode with 64K segments instead of 1M
segments.  Improves stability with some disk controller cards.
Also explicitly state operand size on some moves.

Bump version on boot, cdboot and pxeboot accordingly.

"just get them in" beck@@ ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.28 2004/03/19 13:48:18 tom Exp $	*/
d357 1
a357 1
	addr32 movw %bx, (_C_LABEL(BIOS_regs)+(BIOSR_BX) - LINKADDR)
@


1.28
log
@Enter pxeboot, derived from the NetBSD implementation.  Initially
intended to support network installs using bsd.rd over TFTP.

Thanks to the many who tested, including Diana Eichert.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.27 2004/01/13 23:54:07 millert Exp $	*/
d72 2
a73 2
	mov	%ax, %ds;					\
	mov	%ax, %es;					\
d83 5
a87 4
	xor	%ax, %ax;	/* setup: %ds, %es, %ss */	\
	mov	%ax, %ds;					\
	mov	%ax, %es;					\
	mov	%ax, %ss;					\
d91 1
a91 1
	data32 addr32 lidt Idtr_real;	/* load idtr for real mode */
d96 3
a98 1
	data32 addr32 lgdt Gdtr;	/* load the gdtr */	\
d243 1
a243 1
	.byte	0xf | 0 | 0 | 0		# hilimit, xx, 16bit, byte granularity
d250 1
a250 1
	.byte	0xf | 0 | 0 | 0		# hilimit, xx, 16bit, byte granularity
d341 4
a344 4
	addr32  mov _C_LABEL(BIOS_regs)+(BIOSR_ES), %eax
	mov	%ax, %es
	addr32  mov _C_LABEL(BIOS_regs)+(BIOSR_DS), %eax
	mov	%ax, %ds
d357 3
a359 3
	addr32 mov %ebx, _C_LABEL(BIOS_regs)+(BIOSR_BX)
	mov	%es, %bx
	addr32 mov %ebx, _C_LABEL(BIOS_regs)+(BIOSR_ES)
d364 1
a364 1
	addr32 mov %eax, 2f
d373 3
a375 3
	mov	%eax, 0xb*4(%esp)
	mov	%ecx, 0xa*4(%esp)
	mov	%edx, 0x9*4(%esp)
d387 6
a392 6
	mov	%eax, _C_LABEL(BIOS_regs)+BIOSR_AX
	mov	%ecx, _C_LABEL(BIOS_regs)+BIOSR_CX
	mov	%edx, _C_LABEL(BIOS_regs)+BIOSR_DX
	mov	%ebp, _C_LABEL(BIOS_regs)+BIOSR_BP
	mov	%esi, _C_LABEL(BIOS_regs)+BIOSR_SI
	mov	%edi, _C_LABEL(BIOS_regs)+BIOSR_DI
@


1.27
log
@Allow building w/o -traditional.  OK weingart@@ and mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.26 2003/06/03 20:22:12 mickey Exp $	*/
d39 1
a39 5
#define	SNULL	0x00
#define S32TEXT	0x08
#define	S32DATA	0x10
#define S16TEXT	0x18
#define	S16DATA	0x20
d203 1
d209 1
@


1.26
log
@three four kills
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.25 2003/04/17 03:43:18 drahn Exp $	*/
d170 4
d176 1
d193 3
d197 1
@


1.25
log
@i386 ELF bootloader. developed with weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.24 2001/09/17 13:10:09 deraadt Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.24
log
@genassym changes
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.23 1998/09/25 06:48:52 mickey Exp $	*/
a43 3
#define addr32  .byte 0x67
#define data32  .byte 0x66

d52 2
a53 2
	movl	$0xb8000, %eax	; \
	movl	$0x47314730, (%eax)
d55 2
a56 5
	data32			; \
	movl	$(0xb8000 - LINKADDR), %eax	; \
	data32			; \
	addr32			; \
	movl	$0x4f314f30, (%eax)
d58 2
a59 5
	data32			; \
	movl	$0xb8004, %eax	; \
	data32			; \
	addr32			; \
	movl	$0x47334732, (%eax)
d61 2
a62 5
	data32			; \
	movl	$0xb8004, %eax	; \
	data32			; \
	addr32			; \
	movl	$0x4f334f32, (%eax)
d77 1
a77 5
	movl	$S16DATA, %ax;					\
	/* ljmp	$S16TEXT, $1f */;				\
	.byte	0xea;		/* Change to 16bit mode */	\
	.long	1f - LINKADDR;					\
	.word	S16TEXT;					\
d79 4
a82 2
	movl	%ax, %ds;					\
	movl	%ax, %es;					\
a85 1
	data32;							\
d89 2
a90 4
	/* ljmp	(LINKADDR >> 4), $1f */;			\
	.byte	0xea;		/* load real mode cs:ip */	\
	.word	1f;						\
	.word	(LINKADDR >> 4);				\
d92 4
a95 5
	data32;							\
	xorl	%eax, %eax;	/* setup: %ds, %es, %ss */	\
	movl	%ax, %ds;					\
	movl	%ax, %es;					\
	movl	%ax, %ss;					\
d99 1
a99 3
	addr32;							\
	data32;							\
	lidt	Idtr_real;	/* load idtr for real mode */
d104 1
a104 3
	addr32;							\
	data32;							\
	lgdt	Gdtr;		/* load the gdtr */		\
a106 1
	data32;							\
d110 1
a110 2
	data32;							\
	ljmp	$S32TEXT, $1f;   /* reload %cs,flush pipeline */\
d112 1
d114 4
a117 4
	movl	$S32DATA, %eax;					\
	movl	%ax, %ds;					\
	movl	%ax, %ss;					\
	movl	%ax, %es;					\
d128 1
d168 1
a168 1
	.align	3, 0x90
a169 11
	/* reload new gdt */
	lgdt	Gdtr
	ljmp	$S32TEXT, $1f
1:	
	movl	$S32DATA, %eax
	movl	%eax, %ds
	movl	%eax, %ss
	movl	%eax, %es
	movl	%eax, %fs
	movl	%eax, %gs

d174 1
d177 1
a177 1
	.align 3
d180 3
a182 2
	.word IPROC(e), S32TEXT, (0x80|SDT_SYS386TGT) << 8, (LINKADDR >> 16)
		/* internal (0-31) */
d207 1
a207 1
	.align	3
d212 1
a212 1
	.align	3
d215 1
a215 1
	.align	3
d248 1
d317 1
a317 1
	.align	3, 0x90
d320 2
a321 2
	movl	%eax, 3f
	popl	%eax
d323 5
a327 5
	pushal
	pushl	%ds
	pushl	%es
	pushl	%fs
	pushl	%gs
d330 1
a330 1
	movb	%al, intno
d334 1
a334 1
	pushl	%ds
d336 8
a343 11
	addr32
	movl	_C_LABEL(BIOS_regs)+(BIOSR_ES), %eax
	movl	%ax, %es
	addr32
	movl	_C_LABEL(BIOS_regs)+(BIOSR_DS), %eax
	movl	%ax, %ds

	data32
	# movl	$Leax, %eax
	.byte	0xb8
3:	.long	0x90909090	/* restore %eax */
d350 1
a350 1
	popl	%ds
d352 4
a355 7
	addr32
	data32
	movl	%ebx, _C_LABEL(BIOS_regs)+(BIOSR_BX)
	movl	%es, %bx
	addr32
	movl	%bx, _C_LABEL(BIOS_regs)+(BIOSR_ES)
	movb	%ah, %bh	/* save flags to return to caller */
d359 1
a359 3
	addr32
	data32
	movl	%eax, 2f	/* save %eax */
d363 3
a365 3
	# movl	$Leax, %eax
	.byte	0xb8
2:	.long	0x90909090	/* eax */
d368 3
a370 3
	movl	%eax, 0xb*4(%esp)
	movl	%ecx, 0xa*4(%esp)
	movl	%edx, 0x9*4(%esp)
d376 3
a378 3
	popl	%eax
	andl	$0xffffbfff, %eax
	pushl	%eax
d382 12
a393 12
	movl	%eax, _C_LABEL(BIOS_regs)+BIOSR_AX
	movl	%ecx, _C_LABEL(BIOS_regs)+BIOSR_CX
	movl	%edx, _C_LABEL(BIOS_regs)+BIOSR_DX
	movl	%ebp, _C_LABEL(BIOS_regs)+BIOSR_BP
	movl	%esi, _C_LABEL(BIOS_regs)+BIOSR_SI
	movl	%edi, _C_LABEL(BIOS_regs)+BIOSR_DI

	popl	%gs
	popl	%fs
	popl	%es
	popl	%ds
	popal
d398 3
a400 3
	popl	%eax		/* Don't need return address */
	popl	%esi		/* Buffer */
	popl	%edx		/* Device */
d405 3
a407 4
	xorl	%ax, %ax
	movl	%ax, %ss
	data32
	movl	$0xfffc, %esp
a410 1
	addr32
d413 1
@


1.24.4.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 3
d55 2
a56 2
	mov	$0xb8000, %eax	; \
	mov	$0x47314730, (%eax)
d58 5
a62 2
	mov	$(0xb8000 - LINKADDR), %eax	; \
	mov	$0x4f314f30, (%eax)
d64 5
a68 2
	mov	$0xb8004, %eax	; \
	mov	$0x47334732, (%eax)
d70 5
a74 2
	mov	$0xb8004, %eax	; \
	mov	$0x4f334f32, (%eax)
d89 5
a93 1
	ljmp	$S16TEXT, $1f - LINKADDR;			\
d95 2
a96 4
	.code16;						\
	movw	$S16DATA, %ax;					\
	mov	%ax, %ds;					\
	mov	%ax, %es;					\
d100 1
d104 4
a107 2
	/* reload real cs:ip */					\
	data32 ljmp	$(LINKADDR >> 4), $1f - LINKADDR;	\
d109 5
a113 4
	xor	%ax, %ax;	/* setup: %ds, %es, %ss */	\
	mov	%ax, %ds;					\
	mov	%ax, %es;					\
	mov	%ax, %ss;					\
d117 3
a119 1
	data32 addr32 lidt Idtr_real;	/* load idtr for real mode */
d124 3
a126 1
	data32 addr32 lgdt Gdtr;	/* load the gdtr */	\
d129 1
d133 2
a134 1
	data32 ljmp	$S32TEXT, $1f;   /* reload %cs,flush pipeline */\
a135 1
	.code32;						\
d137 4
a140 4
	mov	$S32DATA, %eax;					\
	mov	%ax, %ds;					\
	mov	%ax, %ss;					\
	mov	%ax, %es;					\
a150 1
	.code32
d190 1
a190 1
	.align	8, 0x90
d192 11
a206 1

d209 1
a209 1
	.align 8, 0x90
d212 2
a213 3
	.short	IPROC(e); .short (S32TEXT); \
	.short	((0x80|SDT_SYS386TGT) << 8); .short (LINKADDR >> 16)
/* internal (0-31) */
d238 1
a238 1
	.align	8
d243 1
a243 1
	.align	8
d246 1
a246 1
	.align	8
a278 1
.globl Gdtr
d347 1
a347 1
	.align	8, 0x90
d350 2
a351 2
	mov	%eax, 3f
	pop	%eax
d353 5
a357 5
	pusha
	push	%ds
	push	%es
	push	%fs
	push	%gs
d360 1
a360 1
	mov	%al, intno
d364 1
a364 1
	push	%ds
d366 11
a376 8
	addr32  mov _C_LABEL(BIOS_regs)+(BIOSR_ES), %eax
	mov	%ax, %es
	addr32  mov _C_LABEL(BIOS_regs)+(BIOSR_DS), %eax
	mov	%ax, %ds

	# data32 movl $Leax, %eax
	.byte	0x66, 0xb8
3:	.long	0x90909090
d383 1
a383 1
	pop	%ds
d385 7
a391 4
	addr32 mov %ebx, _C_LABEL(BIOS_regs)+(BIOSR_BX)
	mov	%es, %bx
	addr32 mov %ebx, _C_LABEL(BIOS_regs)+(BIOSR_ES)
	movb	%ah, %bh
d395 3
a397 1
	addr32 mov %eax, 2f
d401 3
a403 3
	# movl $Leax, %eax
	.byte 0xb8
2:	.long 0x90909090
d406 3
a408 3
	mov	%eax, 0xb*4(%esp)
	mov	%ecx, 0xa*4(%esp)
	mov	%edx, 0x9*4(%esp)
d414 3
a416 3
	pop	%eax
	and	$0xffffbfff, %eax
	push	%eax
d420 12
a431 12
	mov	%eax, _C_LABEL(BIOS_regs)+BIOSR_AX
	mov	%ecx, _C_LABEL(BIOS_regs)+BIOSR_CX
	mov	%edx, _C_LABEL(BIOS_regs)+BIOSR_DX
	mov	%ebp, _C_LABEL(BIOS_regs)+BIOSR_BP
	mov	%esi, _C_LABEL(BIOS_regs)+BIOSR_SI
	mov	%edi, _C_LABEL(BIOS_regs)+BIOSR_DI

	pop	%gs
	pop	%fs
	pop	%es
	pop	%ds
	popa
d436 3
a438 3
	pop	%eax		/* Don't need return address */
	pop	%esi		/* Buffer */
	pop	%edx		/* Device */
d443 4
a446 3
	xor	%ax, %ax
	mov	%ax, %ss
	mov	$0xfffc, %esp
d450 1
a452 1
	.end
@


1.23
log
@from Martin Fredriksson <martin@@gbg.netman.se>:
clean NT bit in eflags after switching back into prot mode.
solves bug in 2940UW and HP recent motherboards bios combination.
some more flags should be set/clean at that point.
leave that for later investigation.
light optimize.
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.22 1998/09/16 03:40:32 mickey Exp $	*/
d367 1
a367 1
	movl	_C_LABEL(BIOS_regs)+(biosr_es), %eax
d370 1
a370 1
	movl	_C_LABEL(BIOS_regs)+(biosr_ds), %eax
d387 1
a387 1
	movl	%ebx, _C_LABEL(BIOS_regs)+(biosr_bx)
d390 1
a390 1
	movl	%bx, _C_LABEL(BIOS_regs)+(biosr_es)
d420 6
a425 6
	movl	%eax, _C_LABEL(BIOS_regs)+biosr_ax
	movl	%ecx, _C_LABEL(BIOS_regs)+biosr_cx
	movl	%edx, _C_LABEL(BIOS_regs)+biosr_dx
	movl	%ebp, _C_LABEL(BIOS_regs)+biosr_bp
	movl	%esi, _C_LABEL(BIOS_regs)+biosr_si
	movl	%edi, _C_LABEL(BIOS_regs)+biosr_di
@


1.23.8.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.23 1998/09/25 06:48:52 mickey Exp $	*/
d367 1
a367 1
	movl	_C_LABEL(BIOS_regs)+(BIOSR_ES), %eax
d370 1
a370 1
	movl	_C_LABEL(BIOS_regs)+(BIOSR_DS), %eax
d387 1
a387 1
	movl	%ebx, _C_LABEL(BIOS_regs)+(BIOSR_BX)
d390 1
a390 1
	movl	%bx, _C_LABEL(BIOS_regs)+(BIOSR_ES)
d420 6
a425 6
	movl	%eax, _C_LABEL(BIOS_regs)+BIOSR_AX
	movl	%ecx, _C_LABEL(BIOS_regs)+BIOSR_CX
	movl	%edx, _C_LABEL(BIOS_regs)+BIOSR_DX
	movl	%ebp, _C_LABEL(BIOS_regs)+BIOSR_BP
	movl	%esi, _C_LABEL(BIOS_regs)+BIOSR_SI
	movl	%edi, _C_LABEL(BIOS_regs)+BIOSR_DI
@


1.23.8.2
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.23.8.1 2001/10/31 03:01:13 nate Exp $	*/
d44 3
d55 2
a56 2
	mov	$0xb8000, %eax	; \
	mov	$0x47314730, (%eax)
d58 5
a62 2
	mov	$(0xb8000 - LINKADDR), %eax	; \
	mov	$0x4f314f30, (%eax)
d64 5
a68 2
	mov	$0xb8004, %eax	; \
	mov	$0x47334732, (%eax)
d70 5
a74 2
	mov	$0xb8004, %eax	; \
	mov	$0x4f334f32, (%eax)
d89 5
a93 1
	ljmp	$S16TEXT, $1f - LINKADDR;			\
d95 2
a96 4
	.code16;						\
	movw	$S16DATA, %ax;					\
	mov	%ax, %ds;					\
	mov	%ax, %es;					\
d100 1
d104 4
a107 2
	/* reload real cs:ip */					\
	data32 ljmp	$(LINKADDR >> 4), $1f - LINKADDR;	\
d109 5
a113 4
	xor	%ax, %ax;	/* setup: %ds, %es, %ss */	\
	mov	%ax, %ds;					\
	mov	%ax, %es;					\
	mov	%ax, %ss;					\
d117 3
a119 1
	data32 addr32 lidt Idtr_real;	/* load idtr for real mode */
d124 3
a126 1
	data32 addr32 lgdt Gdtr;	/* load the gdtr */	\
d129 1
d133 2
a134 1
	data32 ljmp	$S32TEXT, $1f;   /* reload %cs,flush pipeline */\
a135 1
	.code32;						\
d137 4
a140 4
	mov	$S32DATA, %eax;					\
	mov	%ax, %ds;					\
	mov	%ax, %ss;					\
	mov	%ax, %es;					\
a150 1
	.code32
d190 1
a190 1
	.align	8, 0x90
d192 11
a206 1

d209 1
a209 1
	.align 8, 0x90
d212 2
a213 3
	.short	IPROC(e); .short (S32TEXT); \
	.short	((0x80|SDT_SYS386TGT) << 8); .short (LINKADDR >> 16)
/* internal (0-31) */
d238 1
a238 1
	.align	8
d243 1
a243 1
	.align	8
d246 1
a246 1
	.align	8
a278 1
.globl Gdtr
d347 1
a347 1
	.align	8, 0x90
d350 2
a351 2
	mov	%eax, 3f
	pop	%eax
d353 5
a357 5
	pusha
	push	%ds
	push	%es
	push	%fs
	push	%gs
d360 1
a360 1
	mov	%al, intno
d364 1
a364 1
	push	%ds
d366 11
a376 8
	addr32  mov _C_LABEL(BIOS_regs)+(BIOSR_ES), %eax
	mov	%ax, %es
	addr32  mov _C_LABEL(BIOS_regs)+(BIOSR_DS), %eax
	mov	%ax, %ds

	# data32 movl $Leax, %eax
	.byte	0x66, 0xb8
3:	.long	0x90909090
d383 1
a383 1
	pop	%ds
d385 7
a391 4
	addr32 mov %ebx, _C_LABEL(BIOS_regs)+(BIOSR_BX)
	mov	%es, %bx
	addr32 mov %ebx, _C_LABEL(BIOS_regs)+(BIOSR_ES)
	movb	%ah, %bh
d395 3
a397 1
	addr32 mov %eax, 2f
d401 3
a403 3
	# movl $Leax, %eax
	.byte 0xb8
2:	.long 0x90909090
d406 3
a408 3
	mov	%eax, 0xb*4(%esp)
	mov	%ecx, 0xa*4(%esp)
	mov	%edx, 0x9*4(%esp)
d414 3
a416 3
	pop	%eax
	and	$0xffffbfff, %eax
	push	%eax
d420 12
a431 12
	mov	%eax, _C_LABEL(BIOS_regs)+BIOSR_AX
	mov	%ecx, _C_LABEL(BIOS_regs)+BIOSR_CX
	mov	%edx, _C_LABEL(BIOS_regs)+BIOSR_DX
	mov	%ebp, _C_LABEL(BIOS_regs)+BIOSR_BP
	mov	%esi, _C_LABEL(BIOS_regs)+BIOSR_SI
	mov	%edi, _C_LABEL(BIOS_regs)+BIOSR_DI

	pop	%gs
	pop	%fs
	pop	%es
	pop	%ds
	popa
d436 3
a438 3
	pop	%eax		/* Don't need return address */
	pop	%esi		/* Buffer */
	pop	%edx		/* Device */
d443 4
a446 3
	xor	%ax, %ax
	mov	%ax, %ss
	mov	$0xfffc, %esp
d450 1
a452 1
	.end
@


1.23.8.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.23.8.2 2003/05/13 19:42:09 ho Exp $	*/
d15 5
@


1.23.8.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a169 4
#ifdef __STDC__
#define IPROC(n)	X##n
#define IEMU(n)		IPROC(emu##n)
#else
a171 1
#endif
a187 3
#ifdef __STDC__
#define idtb(b)	idte(emu##b)
#else
a188 1
#endif
@


1.23.8.5
log
@Merge with the trunk
@
text
@d39 5
a43 1
#include "gidt.h"
a206 1
	.globl	Idtr
a211 1
	.globl	Idtr_real
@


1.22
log
@fix comments
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.21 1998/04/18 07:39:51 deraadt Exp $	*/
d410 8
@


1.21
log
@i386 bootblocks that work for 2.3. A tale too long to tell
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.20 1998/02/25 12:28:24 mickey Exp $	*/
d134 1
a134 1
	ljmp	$S32TEXT, $1f;   /* reload %cs flush pipeline */\
d374 1
a374 1
	# movl	Leax, %eax
d401 1
a401 1
	# movl	Leax, %eax
@


1.20
log
@32bit careness
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.19 1998/02/24 22:06:52 weingart Exp $	*/
d56 1
a56 2
	movl	$0x47314730, (%eax)		; \
	movw	$S16DATA, %ax
a57 2
	movl	%ax, %ds	; \
	movl	%ax, %es	; \
d89 1
d95 2
d109 1
d151 2
a152 2
	.globl	pmm_init
	.globl	__rtt
d154 1
a154 1
__rtt:
d160 1
a160 1
	movw	%ax, 0x472	# warm boot
d187 1
a187 1
	movl	$0, %esp	# segment violation
d190 1
d194 1
a194 1
	ljmp	$8, $1f
d196 6
a201 6
	movw	$S32DATA, %ax
	movl	%ax, %ds
	movl	%ax, %ss
	movl	%ax, %es
	movl	%ax, %fs
	movl	%ax, %gs
d238 1
d243 1
d246 1
d346 2
a347 1
.globl EMUh
@


1.19
log
@Changes/updates to /boot stuff.  More to come.
Fixes many divide by zero and pointer bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.18 1997/10/24 22:22:26 mickey Exp $	*/
d425 1
a425 1
	prot2real			/* Switch */
d429 3
a431 3
	xorl	%eax, %eax
	pushl	%ax
	popl	%ss
@


1.18
log
@better segments
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.17 1997/10/19 22:48:36 mickey Exp $	*/
d219 1
a219 1
		/*	Maskable interrupts (32-255) */
d341 1
d423 1
d425 11
a435 2
	popl	%eax		/* Partition - Not used, overwritten */
	prot2real		/* Switch */
d437 1
a437 2
	data32
	ljmp $0x7c0, $0x000
@


1.17
log
@fix 'ma boot' cmd; toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.16 1997/10/17 15:03:24 weingart Exp $	*/
d263 1
a263 1
	.byte	SDT_MEMERA | 0 | 0x80	# RXAC, dpl = 0, present
d270 1
a270 1
	.byte	SDT_MEMRWA | 0 | 0x80	# RXAC, dpl = 0, present
d371 1
a371 1
	sti
d374 1
a374 1
	cli
@


1.16
log
@Use BIOS to probe for memory map.
Probe for BIOS supported disks.
Use BIOS to get geometry for supported disks.

All in preparation to passing the whole thing
to the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.15 1997/09/02 17:05:12 mickey Exp $	*/
d425 2
@


1.15
log
@s/DEBUG/GIDT_DEBUG/
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.14 1997/08/13 04:03:30 mickey Exp $	*/
d418 8
@


1.14
log
@split off START into LINKADDR and LOADADDR (we will need reloctable boot)
BOOTREL as a linear address, not segment one
more heap (;
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.13 1997/08/02 22:23:09 mickey Exp $	*/
d53 1
a53 1
#ifdef	GIDT_DEBUG
d154 1
a154 1
#ifdef DEBUG
d172 1
a172 1
#ifdef DEBUG
@


1.13
log
@move kentry() in boot
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.12 1997/08/01 21:06:03 mickey Exp $	*/
d62 1
a62 1
	movl	$(0xb8000 - START), %eax	; \
d94 1
a94 1
	.long	1f - START;					\
d104 1
a104 1
	/* ljmp	(START >> 4), $1f */;				\
d107 1
a107 1
	.word	(START >> 4);					\
d210 1
a210 1
	.word IPROC(e), S32TEXT, (0x80|SDT_SYS386TGT) << 8, (START >> 16)
d261 2
a262 2
	.word	(START & 0xffff)	# lobase
	.byte	(START >> 16) & 0xff	# midbase
d265 1
a265 1
	.byte	(START >> 20) & 0xff	# hibase
d268 2
a269 2
	.word	(START & 0xffff)	# lobase
	.byte	(START >> 16) & 0xff	# midbase
d272 1
a272 1
	.byte	(START >> 20) & 0xff	# hibase
@


1.12
log
@no <machine/psl.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.11 1997/07/31 20:15:08 mickey Exp $	*/
a230 2
		/* kernel entry point */
	idte(kent)
a410 22

	popl	%gs
	popl	%fs
	popl	%es
	popl	%ds
	popal
	iret

	.globl	_C_LABEL(kentry)

IPROC(kent):
	pushal
	pushl	%ds
	pushl	%es
	pushl	%fs
	pushl	%gs

	/* call kent */
	pushl	%edx
	pushl	%eax
	call	_C_LABEL(kentry)
	addl	$8, %esp
@


1.11
log
@optimize emulation handler
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.10 1997/07/30 19:40:58 flipk Exp $	*/
a37 1
#include <machine/psl.h>
@


1.10
log
@mickey has pieces he has not committed.
if he puts the tree in an unbuildable state again..
anyway, all these problems came from the fact that etc/genassym.cf
wasn't even being used, and assym.h is where key defines were supposed
to be coming from. now we actually include etc/genassym.cf in the
genassym.sh processing, and remove the #includes i had in place to
work around it. now if mickey had committed machine/biosvar.h, etc/Makefile,
and these asm files all at the same time, there wouldn't have been
a problem....
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.9 1997/07/29 16:48:40 flipk Exp $	*/
a40 1
#include <machine/segments.h>
d340 1
a340 1
 * Call:	%eax, %ecx, %edx, %ebx, %ebp, %esi, %edi, %es
d345 4
a354 3
	/* save %eax */
	movl	%eax, 3f

a355 1
	movb	12*4(%esp), %al
a356 1
	movl	%eax, 2f
d360 2
d365 3
d379 2
d405 1
a405 1
	movb	%bh , 0xf*4(%esp)
a419 1
	addl	$4, %esp
@


1.9
log
@Test before you Commit!!
1) missing include files in biosboot.S and gidt.S
2) macros in apm_init.S, biosdisk.S, gidt.S wrong case
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.8 1997/07/28 23:03:31 mickey Exp $	*/
a40 2
#include <machine/biosvar.h>
#include <machine/specialreg.h>
d363 1
a363 1
	movl	_C_LABEL(BIOS_regs)+(BIOSR_ES), %eax
d378 1
a378 1
	movl	%ebx, _C_LABEL(BIOS_regs)+(BIOSR_BX)
d381 1
a381 1
	movl	%bx, _C_LABEL(BIOS_regs)+(BIOSR_ES)
d403 6
a408 6
	movl	%eax, _C_LABEL(BIOS_regs)+BIOSR_AX
	movl	%ecx, _C_LABEL(BIOS_regs)+BIOSR_CX
	movl	%edx, _C_LABEL(BIOS_regs)+BIOSR_DX
	movl	%ebp, _C_LABEL(BIOS_regs)+BIOSR_BP
	movl	%esi, _C_LABEL(BIOS_regs)+BIOSR_SI
	movl	%edi, _C_LABEL(BIOS_regs)+BIOSR_DI
@


1.8
log
@assym.h
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.7 1997/07/24 21:50:10 mickey Exp $	*/
d42 2
d365 1
a365 1
	movl	_C_LABEL(BIOS_regs)+(biosr_es), %eax
d380 1
a380 1
	movl	%ebx, _C_LABEL(BIOS_regs)+(biosr_bx)
d383 1
a383 1
	movl	%bx, _C_LABEL(BIOS_regs)+(biosr_es)
d405 6
a410 6
	movl	%eax, _C_LABEL(BIOS_regs)+biosr_ax
	movl	%ecx, _C_LABEL(BIOS_regs)+biosr_cx
	movl	%edx, _C_LABEL(BIOS_regs)+biosr_dx
	movl	%ebp, _C_LABEL(BIOS_regs)+biosr_bp
	movl	%esi, _C_LABEL(BIOS_regs)+biosr_si
	movl	%edi, _C_LABEL(BIOS_regs)+biosr_di
@


1.7
log
@symbolic segnames
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.6 1997/07/18 00:48:19 mickey Exp $	*/
a39 2
#include <machine/segments.h>
#include <machine/specialreg.h>
d44 1
d363 1
a363 1
	movl	_C_LABEL(BIOS_regs)+(BIOSR_ES), %eax
d378 1
a378 1
	movl	%ebx, _C_LABEL(BIOS_regs)+(BIOSR_BX)
d381 1
a381 1
	movl	%bx, _C_LABEL(BIOS_regs)+(BIOSR_ES)
d403 6
a408 6
	movl	%eax, _C_LABEL(BIOS_regs)+BIOSR_AX
	movl	%ecx, _C_LABEL(BIOS_regs)+BIOSR_CX
	movl	%edx, _C_LABEL(BIOS_regs)+BIOSR_DX
	movl	%ebp, _C_LABEL(BIOS_regs)+BIOSR_BP
	movl	%esi, _C_LABEL(BIOS_regs)+BIOSR_SI
	movl	%edi, _C_LABEL(BIOS_regs)+BIOSR_DI
@


1.6
log
@save %fs %gs
save some 2-3k
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.5 1997/05/29 05:32:07 mickey Exp $	*/
d50 6
d59 2
a60 1
	movl	$0x47314730, (%eax)
d62 2
d95 1
a95 3
	movl	$0x20, %eax;					\
								\
	/* ljmp	$0x18, $1f */;					\
d98 1
a98 1
	.word	0x18;						\
a99 3
	movl	%ax, %ds;					\
	movl	%ax, %es;					\
								\
d136 1
a136 1
	ljmp	$0x08, $1f;   /* reload %cs flushing pipeline */\
d139 1
a139 1
	movl	$0x10, %eax;					\
d197 1
a197 1
	movw	$0x10, %ax
d212 2
a213 1
#define idte(e)	.word IPROC(e), 0x8, (0x80|SDT_SYS386TGT) << 8, (START >> 16)
@


1.5
log
@better style, move pmm init code completely into gidt.S
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.4 1997/04/18 01:28:02 mickey Exp $	*/
d43 1
d50 98
d150 37
d190 1
a190 1
	lgdt	_Gdtr
d199 1
a199 2
	/* init idt */
	call	idt_init
d201 1
a201 1
	lidt	_Idtr_prot
d204 37
a240 1
	.data
a241 1
	.align	3
d274 1
a274 1
_Gdtr:	.word	. - gdt - 1
a277 58
	.align 3
_Idtr_real:
	.word	1023
	.long	0

	.align 3
idt:
	.space 32*8, 0	/* internal (0-31) */
			/*	Maskable interrupts (32-255) */
	.space 32*8, 0	/* BIOS entry points (32-63) */
	.space 16*8, 0	/* DOS entry points (64-80) */

_Idtr_prot:
	.word	. - idt - 1
	.long	idt

	.text
#define IPROC(n)	X/**/n
#define IBIOS(n)	IPROC(bios/**/n)
#define IDOS(n)		IPROC(dos/**/n)

idt_init:
	pushl	%edi

	movl	$idt, %edi

#define	fixe(p)								\
	movl	$ IPROC(p), %eax;					\
	stosw; 					/* lo offset handler */	\
	movw	$0x8, (%edi);			/* handler %cs */	\
	incl %edi; incl %edi;						\
	incl %edi;				/* reserved */		\
	movb	$(0x80|SDT_SYS386TGT), (%edi);	/* 32bit trap gate */	\
	incl %edi;							\
	shrl	$16, %eax;						\
	stosw;					/* hi offset handler */

	fixe(de); fixe(db); fixe(nmi); fixe(bp); fixe(of); fixe(br)
	fixe(ud); fixe(nm); fixe(df);  fixe(fo); fixe(ts); fixe(np)
	fixe(ss); fixe(gp); fixe(pf);  fixe(xx); fixe(mf); fixe(ac)
	fixe(mc)
	fixe(xx); fixe(xx); fixe(xx);  fixe(xx); fixe(xx); fixe(xx)
	fixe(xx); fixe(xx); fixe(xx);  fixe(xx); fixe(xx); fixe(xx)
	fixe(xx) 

#define fixb(b) fixe(bios/**/b)
	fixb(0);  fixb(1);  fixb(2);  fixb(3);  fixb(4);  fixb(5)
	fixb(6);  fixb(7);  fixb(8);  fixb(9);  fixb(10); fixb(11)
	fixb(12); fixb(13); fixb(14); fixb(15); fixb(16); fixb(17)
	fixb(18); fixb(19); fixb(20); fixb(21); fixb(22); fixb(23)
	fixb(24); fixb(25); fixb(26); fixb(27); fixb(28); fixb(29)
	fixb(30); fixb(31)

#define fixd(d) fixe(dos/**/b)

	popl	%edi
	ret

d316 1
a316 1
#define	IBIOSENT(n)	IBIOS(n): pushl $n; jmp BIOSh
d318 14
a331 8
IBIOSENT(0);  IBIOSENT(1);  IBIOSENT(2);  IBIOSENT(3)
IBIOSENT(4);  IBIOSENT(5);  IBIOSENT(6);  IBIOSENT(7)
IBIOSENT(8);  IBIOSENT(9);  IBIOSENT(10); IBIOSENT(11)
IBIOSENT(12); IBIOSENT(13); IBIOSENT(14); IBIOSENT(15)
IBIOSENT(16); IBIOSENT(17); IBIOSENT(18); IBIOSENT(19)
IBIOSENT(20); IBIOSENT(21); IBIOSENT(22); IBIOSENT(23)
IBIOSENT(24); IBIOSENT(25); IBIOSENT(26); IBIOSENT(27)
IBIOSENT(28); IBIOSENT(29); IBIOSENT(30); IBIOSENT(31)
d337 1
a337 1
 * Call:	%eax, %ecx, %edx, %ebx, %ebp, %esi, %ds, %di==real mode %es
d341 1
a341 2
	.globl	BIOSh
BIOSh:
d345 2
d349 1
a349 1
	movl	%eax, 2f
d352 1
a352 1
	movb	10*4(%esp), %al
d354 1
d356 1
a356 42
	/* setup 16bit labels in ljmps */

#ifdef	GIDT_DEBUG
	movl	$0xb8000, %eax
	movl	$0x47314730, (%eax)
#endif
	movl	$0x20, %eax

	# ljmp	$0x18, $2f
	.byte	0xea		/* Change to 16bit mode */
	.long	1f - START
	.word	0x18
1:
	movl	%ax, %ds
#ifdef	GIDT_DEBUG
	data32
	movl	$(0xb8000 - START), %eax
	data32
	addr32
	movl	$0x4f314f30, (%eax)
#endif
	movl	%cr0, %eax	/* disable prot mode memory management */
	data32
	andl 	$~CR0_PE, %eax
	movl	%eax, %cr0

	# ljmp	(START >> 16), $4f
	.byte	0xea		/* load real mode cs:ip */
	.word	1f
	.word	(START >> 4)
1:
	xorl	%eax, %eax	/* setup: %ds, %es, %ss */
	movl	%ax, %ds
	movl	%ax, %ss
	movl	%di, %es
#ifdef	GIDT_DEBUG
	data32
	movl	$0xb8004, %eax
	data32
	addr32
	movl	$0x47334732, (%eax)
#endif
d359 2
a360 2
	data32
	lidt	_Idtr_real	/* load idtr for DOS/BIOS operations */
d365 1
a365 1
2:	.long	0x90909090	/* restore %eax */
a367 1

d370 1
d372 6
a381 2
	cli			/* no maskable interrupts in prot mode */

d386 1
a386 11
#ifdef	GIDT_DEBUG
	data32
	movl	$0xb8004, %eax
	data32
	addr32
	movl	$0x4f334f32, (%eax)
#endif

	addr32
	data32
	lgdt	_C_LABEL(Gdtr)	/* load the gdtr */
d388 3
a390 4
	movl	%cr0, %eax	/* enable prot mode memory management */
	data32
	orl	$CR0_PE, %eax
	movl	%eax, %cr0 
d392 13
a404 7
	data32
	ljmp	$0x08, $1f	/* reload %cs, and flush pipeline */
1:
	/* reload 32bit %ds, %ss, %es */
	movl	$0x10, %eax
	movl	%ax, %ds
	movl	%ax, %ss
d406 7
a412 4
#ifdef	GIDT_DEBUG
	movl	$0xb8008, %eax
	movl	$0x47344733, (%eax)
#endif
d414 1
a414 2
	/* load idtr for debugger and DOS/BIOS iface */
	lidt	_Idtr_prot
d416 6
a421 3
	# movl	Leax, %eax
	.byte	0xb8
2:	.long	0x90909090	/* eax */
d423 5
a427 5
	/* pass BIOS return values back to caller */
	movl	%eax, 0x9*4(%esp)
	movl	%ecx, 0x8*4(%esp)
	movl	%edx, 0x7*4(%esp)
	movb	%bh , 0xd*4(%esp)
d429 2
a433 1
	incl %esp; incl %esp; incl %esp; incl %esp
@


1.4
log
@no more 60k limit!
no more explicit real<-->prot switching!
fix 2.88 floppy drives.....
kbd fixes coming soon!
test it!
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.3 1997/04/09 08:39:37 mickey Exp $	*/
d49 20
a69 1
	.globl	_Gdtr
a107 1
	.globl	_Idtr_real
a112 7
	.globl	_Idtr_reset
	.align 3
_Idtr_reset:
	.word	0
	.long	0

	.globl	_Idtr_prot
a128 1
	.globl	idt_init
@


1.3
log
@emulate bios calls. more debugging stuff. some fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.2 1997/04/07 01:21:54 weingart Exp $	*/
d34 3
a50 1
	.globl	_codeseg
d72 2
a73 2
	.word	0			# lobase
	.byte	0			# midbase
d75 10
a84 2
	.byte	0x0 | 0 | 0 | 0		# hilimit, xx, 16bit, byte granularity
	.byte	0			# hibase
a88 2
_codeseg:	.long	0

d103 5
a107 47
idt:	/*
	 * We beleive that all the boot code fits into
	 * 64k, so no need for high 16 bit of procedure address (;
	 *
	 */
#define IPROC(n)	X/**/n
#define IDTENTRY(proc) \
	.word	IPROC(proc)		/* lo offset handler */ ; \
	.word	0x8			/* handler %cs */ ; \
	.byte	0			/* reserved */ ; \
	.byte	0x80 | SDT_SYS386TGT /* present, dpl=0, 32bit trap gate */ ; \
	.word	0			/* hi offset handler */

	IDTENTRY(de)	/* #DE divide by zero */
	IDTENTRY(db)	/* #DB debug */
	IDTENTRY(nmi)	/* NMI */
	IDTENTRY(bp)	/* #BP breakpoint */
	IDTENTRY(of)	/* #OF overflow */
	IDTENTRY(br)	/* #BR BOUND range exceeded */
	IDTENTRY(ud)	/* #UD invalid opcode */
	IDTENTRY(nm)	/* #NM device not available */
	IDTENTRY(df)	/* #DF double fault */
	IDTENTRY(fo)	/* #FO coprocessor segment overrun */
	IDTENTRY(ts)	/* #TS innvalid TSS */
	IDTENTRY(np)	/* #NP segmant not present */
	IDTENTRY(ss)	/* #SS stack fault */
	IDTENTRY(gp)	/* #GP general protection */
	IDTENTRY(pf)	/* #PF page fault */
	IDTENTRY(xx)	/*	Intel reserved */
	IDTENTRY(mf)	/* #MF floating point error */
	IDTENTRY(ac)	/* #AC alignment check */
	IDTENTRY(mc)	/* #MC machine check */
			/*	Intel reserved (19-31) */
	IDTENTRY(xx); IDTENTRY(xx); IDTENTRY(xx); IDTENTRY(xx)
	IDTENTRY(xx); IDTENTRY(xx); IDTENTRY(xx); IDTENTRY(xx)
	IDTENTRY(xx); IDTENTRY(xx); IDTENTRY(xx); IDTENTRY(xx)
	IDTENTRY(xx)
			/*	Maskable interrupts(32-255) */
			/*	BIOS entry points (32-63) */
#define IBIOS(n)	IPROC(bios/**/n)
#define IDTBIOS(n)	IDTENTRY(bios/**/n)
	IDTBIOS(0);  IDTBIOS(1);  IDTBIOS(2);  IDTBIOS(3);  IDTBIOS(4)
	IDTBIOS(5);  IDTBIOS(6);  IDTBIOS(7);  IDTBIOS(8);  IDTBIOS(9)
	IDTBIOS(10); IDTBIOS(11); IDTBIOS(12); IDTBIOS(13); IDTBIOS(14)
	IDTBIOS(15); IDTBIOS(16); IDTBIOS(17); IDTBIOS(18); IDTBIOS(19)
	IDTBIOS(20); IDTBIOS(21); IDTBIOS(22); IDTBIOS(23)
			/*	DOS entry points */
d114 41
d168 1
a168 1
	pushl	$256
d171 18
a188 18
IENTRY_ERR(de,0,T_DIVIDE)
IENTRY_ERR(db,0,T_TRCTRAP)
IENTRY_ERR(nmi,0,T_NMI)
IENTRY_ERR(bp,0,T_BPTFLT)
IENTRY_ERR(of,0,T_OFLOW)
IENTRY_ERR(br,0,T_BOUND)
IENTRY_ERR(ud,0,T_PRIVINFLT)
IENTRY_ERR(nm,0,T_DNA)
IENTRY(df,T_DOUBLEFLT)
IENTRY_ERR(fo,0,T_FPOPFLT)
IENTRY(ts,T_TSSFLT)
IENTRY(np,T_SEGNPFLT)
IENTRY(ss,T_STKFLT)
IENTRY(gp,T_PROTFLT)
IENTRY(pf,T_PAGEFLT)
IENTRY_ERR(mf,0,T_ARITHTRAP)
IENTRY(ac,T_ALIGNFLT)
IENTRY(mc,T_MACHK)
d194 1
a194 1
#define	IBIOSENT(n)	IBIOS(n): pushl %eax; movb $n, %al ; jmp 1f
d202 2
d205 10
a214 5
	.text
	.globl	_real_to_prot, _prot_to_real
1:
	movb	%al, intno
	popl	%eax
d219 8
a226 1
	call	_prot_to_real
d228 32
d261 18
d281 1
a281 1
intno = . - 1
d283 1
a283 1
	movb	%ah, %bh
d287 19
d307 22
a328 1
	call	_real_to_prot
d334 1
a334 1
	movb	%bh , 0xc*4(%esp)
d339 1
@


1.2
log
@Reset stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: gidt.S,v 1.1 1997/04/05 18:56:27 mickey Exp $	*/
d38 1
d43 2
d58 1
a58 1
	.byte	SDT_MEMERA | 0 | 0x80	# RWXA, dpl = 0, present
d72 2
a73 2
	.byte	SDT_MEMERA | 0 | 0x80	# RWXA, dpl = 0, present
	.byte	0xf | 0 | 0 | 0		# hilimit, xx, 16bit, byte granularity
d133 9
d144 1
a144 1
	.word	. - idt
a147 1
	.globl	alltraps
d152 1
a152 1
	jmp	alltraps
d157 1
a157 1
	jmp	alltraps
d162 1
a162 1
	jmp	alltraps
d182 47
@


1.1
log
@put gdt & idt in the separate file.
print trapno in dump_regs.
no more NO_IDTR.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 6
a90 1

@

