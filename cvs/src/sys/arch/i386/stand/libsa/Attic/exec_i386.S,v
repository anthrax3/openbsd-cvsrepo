head	1.3;
access;
symbols
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	UBC_SYNC_A:1.3
	UBC_SYNC_B:1.3
	SMP:1.3.0.2;
locks; strict;
comment	@# @;


1.3
date	97.04.04.17.24.47;	author weingart;	state dead;
branches;
next	1.2;

1.2
date	97.03.31.23.08.37;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.10.29.09.23.03;	author mickey;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	96.10.29.09.23.04;	author mickey;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	96.12.03.13.13.47;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Nuke.
@
text
@/*	$OpenBSD: exec_i386.S,v 1.2 1997/03/31 23:08:37 mickey Exp $	*/

#include <machine/asm.h>

/*
 * machdep_start(phyaddr)
 *	start the program on protected mode where phyaddr is the entry point
 */
	.globl	_cnvmem, _extmem
ENTRY(machdep_start)
	pushl	%ebp
	movl	%esp, %ebp

	# get things we need into registers
	movl	8(%ebp), %ecx		# entry offset 
	movl	12(%ebp), %edi		# howto
	movl	16(%ebp), %edx		# loadaddr
	movl	24(%ebp), %esi		# esym

	# make a new stack at 0:0x90000 (big segs)
	movl	$0x10, %eax
	movw	%ax, %ss
	movl	$0x90000, %eax
	movl	%eax, %esp
	
	# push some number of args onto the stack
	pushl	_cnvmem
	pushl	_extmem
	pushl	%esi		# esym
	pushl	$0		# cyloff
	pushl	$0		# bootdev
	pushl	%edi		# howto
	pushl	$0		# dummy 'return' address
	
	# push on our entry address
	movl	0x8, %eax		# segment
	pushw	%ax
	andl	$0xffffff, %ecx
	pushl	%ecx

	# convert the PC (and code seg)
	lret
@


1.2
log
@missed additions to the last commit
and....
it compiles and runs ok on my machine.
*** TEST IT !!! ***
some pieces into MI libsa coming in a minute (if line won't drop ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.S,v 1.1.2.2 1996/12/03 13:13:47 mickey Exp $	*/
@


1.1
log
@file exec_i386.S was initially added on branch new.
@
text
@d1 42
@


1.1.2.1
log
@support libsa
@
text
@a0 45

#include <machine/asm.h>

/*
 * machdep_start(phyaddr)
 *	start the program on protected mode where phyaddr is the entry point
 */
ENTRY(machdep_start)
	pushl	%ebp
	movl	%esp, %ebp

	# get things we need into registers
	movl	8(%ebp), %ecx		# entry offset 
	movl	12(%ebp), %edi		# howto
	movl	24(%ebp), %esi		# esym

	cli
	# make a new stack at 0:0x80000 (big segs)
	movl	$0x10, %ebx
	movw	%bx, %ss
	movl	$0x80000, %ebx
	movl	%ebx, %esp
	sti
	
	# push some number of args onto the stack
	pushl	%esi		# esym
	movl	$_cyloffset, %eax
	pushl	%eax		# cyloff
	movl	$_bootdev, %eax
	pushl	%eax		# bootdev
	pushl	%edi		# howto
	pushl	$0		# dummy 'return' address
	
	# push on our entry address
	pushw	$0x8			# segment
	pushl	%ecx

	# convert over the other data segs
	movl	$0x10, %ebx
	movl	%bx, %ds
	movl	%bx, %es

	# convert the PC (and code seg)
	lret

@


1.1.2.2
log
@standalone build, some changes and cleanups, debugs and so.
@
text
@a0 1
/*	$OpenBSD$	*/
d8 1
a8 1
ENTRY(machdep_exec)
a14 1
	movl	16(%ebp), %edx		# loadaddr
d17 1
d19 5
a23 4
	movl	$0x10, %eax
	movw	%ax, %ss
	movl	$0x90000, %eax
	movl	%eax, %esp
d35 1
a35 2
	movl	0x8, %eax		# segment
	pushw	%ax
a36 4
	movl	fmt, %eax
	pushl	%eax
	call	_printf
	popl	%eax
d39 1
a39 1
	movw	$0x10, %bx
d45 1
a45 2
fmt:
	.asciz	"%x\n"
@
