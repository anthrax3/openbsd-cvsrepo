head	1.36;
access;
symbols
	OPENBSD_6_2:1.36.0.4
	OPENBSD_6_2_BASE:1.36
	OPENBSD_6_1:1.36.0.6
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.2
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.35.0.6
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.8
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.34.0.8
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.4
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.2
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.33.0.2
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.16
	OPENBSD_5_0:1.31.0.14
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.12
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.10
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.6
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.31.0.8
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.4
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.27.0.12
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.10
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.8
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.6
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.4
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.20.0.10
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.20.0.8
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.20
	UBC:1.20.0.6
	UBC_BASE:1.20
	OPENBSD_3_0:1.20.0.4
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.17.0.6
	OPENBSD_2_7_BASE:1.17
	SMP:1.17.0.4
	SMP_BASE:1.17
	kame_19991208:1.17
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.16.0.4
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13;
locks; strict;
comment	@ * @;


1.36
date	2016.05.27.05.37.51;	author beck;	state Exp;
branches;
next	1.35;
commitid	hGj7TtravhkHshT2;

1.35
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2012.10.30.14.06.29;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2012.06.10.21.03.35;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2012.06.03.13.17.47;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2008.04.20.01.46.35;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2008.01.23.16.37.56;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2007.04.27.10.08.34;	author tom;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.02.16.29.27;	author tom;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.09.19.12.12;	author tom;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.16.03.10.18;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.11.27.00.32.45;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.11.06.23.09;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.07.07.42.51;	author weingart;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.03.20.22.11;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.17.20.58.27;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.03.03.34.13;	author aaron;	state Exp;
branches
	1.20.6.1;
next	1.19;

1.19
date	2000.10.18.15.22.35;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.08.01.51.32;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	99.08.25.00.54.19;	author mickey;	state Exp;
branches
	1.17.4.1
	1.17.6.1;
next	1.16;

1.16
date	98.05.28.20.52.39;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	98.05.16.07.32.17;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.04.18.07.39.41;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.10.24.22.21.15;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.10.07.08.18.48;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.10.07.07.59.59;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.09.24.06.02.44;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.09.20.22.40.42;	author flipk;	state Exp;
branches;
next	1.8;

1.8
date	97.09.02.20.36.57;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.08.31.06.56.39;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.08.22.00.25.58;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.08.21.21.52.12;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.08.13.15.17.04;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.08.13.14.24.01;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.08.12.23.34.21;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	97.08.12.21.39.01;	author mickey;	state Exp;
branches;
next	;

1.17.4.1
date	2001.04.18.16.08.42;	author niklas;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2003.03.27.23.26.56;	author niklas;	state Exp;
branches;
next	1.17.4.3;

1.17.4.3
date	2003.06.07.11.11.38;	author ho;	state Exp;
branches;
next	1.17.4.4;

1.17.4.4
date	2004.02.19.10.48.43;	author niklas;	state Exp;
branches;
next	1.17.4.5;

1.17.4.5
date	2004.06.05.23.09.01;	author niklas;	state Exp;
branches;
next	;

1.17.6.1
date	2000.10.20.16.36.26;	author jason;	state Exp;
branches;
next	;

1.20.6.1
date	2003.05.19.21.45.12;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Modify com_init to match the com driver initializaiton, and add
a short delay so that baud rate changes on the console have
a chance of working.  Lots of help from theo on this one.

Makes my serial console on my APU work for an unattended
reboot instead of hanging when garbage is echoed to the tty.
ok deraadt@@
@
text
@/*	$OpenBSD: bioscons.c,v 1.35 2014/03/29 18:09:29 guenther Exp $	*/

/*
 * Copyright (c) 1997-1999 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <machine/biosvar.h>
#include <machine/pio.h>
#include <dev/isa/isareg.h>
#include <dev/ic/mc146818reg.h>
#include <dev/ic/comreg.h>
#include <dev/ic/ns16450reg.h>
/* #include <i386/isa/nvram.h> */
#include <dev/cons.h>
#include <lib/libsa/stand.h>
#include "debug.h"
#include "biosdev.h"

/* XXX cannot trust NVRAM on this.  Maybe later we make a real probe.  */
#if 0
#define PRESENT_MASK (NVRAM_EQUIPMENT_KBD|NVRAM_EQUIPMENT_DISPLAY)
#else
#define PRESENT_MASK 0
#endif

void
pc_probe(struct consdev *cn)
{
	cn->cn_pri = CN_MIDPRI;
	cn->cn_dev = makedev(12, 0);
	printf(" pc%d", minor(cn->cn_dev));

#if 0
	outb(IO_RTC, NVRAM_EQUIPMENT);
	if ((inb(IO_RTC+1) & PRESENT_MASK) == PRESENT_MASK) {
		cn->cn_pri = CN_MIDPRI;
		/* XXX from i386/conf.c */
		cn->cn_dev = makedev(12, 0);
		printf(" pc%d", minor(cn->cn_dev));
	}
#endif
}

void
pc_init(struct consdev *cn)
{
}

int
pc_getc(dev_t dev)
{
	register int rv;

	if (dev & 0x80) {
		__asm volatile(DOINT(0x16) "; setnz %b0" : "=a" (rv) :
		    "0" (0x100) : "%ecx", "%edx", "cc" );
		return (rv & 0xff);
	}

	/*
	 * Wait for a character to actually become available.  Appears to
	 * be necessary on (at least) the Intel Mac Mini.
	 */
	do {
		__asm volatile(DOINT(0x16) "; setnz %b0" : "=a" (rv) :
		    "0" (0x100) : "%ecx", "%edx", "cc" );
	} while ((rv & 0xff) == 0);

	__asm volatile(DOINT(0x16) : "=a" (rv) : "0" (0x000) :
	    "%ecx", "%edx", "cc" );

	return (rv & 0xff);
}

int
pc_getshifts(dev_t dev)
{
	register int rv;

	__asm volatile(DOINT(0x16) : "=a" (rv) : "0" (0x200) :
	    "%ecx", "%edx", "cc" );

	return (rv & 0xff);
}

void
pc_putc(dev_t dev, int c)
{
	__asm volatile(DOINT(0x10) : : "a" (c | 0xe00), "b" (1) :
	    "%ecx", "%edx", "cc" );
}

const int comports[4] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8 };

void
com_probe(struct consdev *cn)
{
	register int i, n;

	/* get equip. (9-11 # of coms) */
	__asm volatile(DOINT(0x11) : "=a" (n) : : "%ecx", "%edx", "cc");
	n >>= 9;
	n &= 7;
	for (i = 0; i < n; i++)
		printf(" com%d", i);

	cn->cn_pri = CN_LOWPRI;
	/* XXX from i386/conf.c */
	cn->cn_dev = makedev(8, 0);
}

int com_speed = -1;
int com_addr = -1;

void
com_init(struct consdev *cn)
{
	int port = (com_addr == -1) ? comports[minor(cn->cn_dev)] : com_addr;
	time_t tt = getsecs() + 1;
	u_long i = 1;

	outb(port + com_ier, 0);
	if (com_speed == -1)
		comspeed(cn->cn_dev, 9600); /* default speed is 9600 baud */
	outb(port + com_mcr, MCR_DTR | MCR_RTS);
	outb(port + com_fifo, FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST |
	    FIFO_TRIGGER_1);
	(void) inb(port + com_iir);

	/* A few ms delay for the chip, using the getsecs() API */
	while (!(i++ % 1000) && getsecs() < tt)
		;

	/* drain the input buffer */
	while (inb(port + com_lsr) & LSR_RXRDY)
		(void)inb(port + com_data);
}

int
com_getc(dev_t dev)
{
	int port = (com_addr == -1) ? comports[minor(dev & 0x7f)] : com_addr;

	if (dev & 0x80)
		return (inb(port + com_lsr) & LSR_RXRDY);

	while ((inb(port + com_lsr) & LSR_RXRDY) == 0)
		;

	return (inb(port + com_data) & 0xff);
}

/* call with sp == 0 to query the current speed */
int
comspeed(dev_t dev, int sp)
{
	int port = (com_addr == -1) ? comports[minor(dev)] : com_addr;
	int i, newsp;
	int err;

	if (sp <= 0)
		return com_speed;
	/* valid baud rate? */
	if (115200 < sp || sp < 75)
		return -1;

	/*
	 * Accepted speeds:
	 *   75 150 300 600 1200 2400 4800 9600 19200 38400 76800 and
	 *   14400 28800 57600 115200
	 */
	for (i = sp; i != 75 && i != 14400; i >>= 1)
		if (i & 1)
			return -1;

/* ripped screaming from dev/ic/com.c */
#define divrnd(n, q)    (((n)*2/(q)+1)/2)       /* divide and round off */
	newsp = divrnd((COM_FREQ / 16), sp);
	if (newsp <= 0)
		return -1;
	err = divrnd((COM_FREQ / 16) * 1000, sp * newsp) - 1000;
	if (err < 0)
		err = -err;
	if (err > COM_TOLERANCE)
		return -1;
#undef  divrnd

	if (com_speed != -1 && cn_tab && cn_tab->cn_dev == dev &&
	    com_speed != sp) {
		printf("com%d: changing speed to %d baud in 5 seconds, "
		    "change your terminal to match!\n\a",
		    minor(dev), sp);
		sleep(5);
	}

	outb(port + com_cfcr, LCR_DLAB);
	outb(port + com_dlbl, newsp);
	outb(port + com_dlbh, newsp>>8);
	outb(port + com_cfcr, LCR_8BITS);
	if (com_speed != -1)
		printf("\ncom%d: %d baud\n", minor(dev), sp);

	newsp = com_speed;
	com_speed = sp;
	return newsp;
}

void
com_putc(dev_t dev, int c)
{
	int port = (com_addr == -1) ? comports[minor(dev)] : com_addr;

	while ((inb(port + com_lsr) & LSR_TXRDY) == 0)
		;

	outb(port + com_data, c);
}
@


1.35
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.34 2012/10/30 14:06:29 jsing Exp $	*/
d142 2
d151 5
@


1.34
log
@Apply a bunch of style(9) and whitespace fixes to i386/amd64 libsa, making
the code actually diffable. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.32 2012/06/03 13:17:47 kettenis Exp $	*/
d78 1
a78 1
		__asm __volatile(DOINT(0x16) "; setnz %b0" : "=a" (rv) :
d88 1
a88 1
		__asm __volatile(DOINT(0x16) "; setnz %b0" : "=a" (rv) :
d92 1
a92 1
	__asm __volatile(DOINT(0x16) : "=a" (rv) : "0" (0x000) :
d103 1
a103 1
	__asm __volatile(DOINT(0x16) : "=a" (rv) : "0" (0x200) :
d112 1
a112 1
	__asm __volatile(DOINT(0x10) : : "a" (c | 0xe00), "b" (1) :
d124 1
a124 1
	__asm __volatile(DOINT(0x11) : "=a" (n) : : "%ecx", "%edx", "cc");
@


1.33
log
@Always allow serial console, even if the BIOS doesn't report the presence of
any serial ports.  Otherwise the new code to use puc(4) ports as serial
console isn't all that useful.

ok sthen@@, miod@@
@
text
@d231 1
a231 1
         
@


1.32
log
@Add support for serial consoles at non-standard addresses.  This implements
a new "machine comaddr" command that makes it possible to configure the
io port used to access the serial port.  This can be used to use serial ports
on a puc(4) device as serial console.
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.31 2008/04/20 01:46:35 dlg Exp $	*/
d129 4
a132 5
	if (n) {
		cn->cn_pri = CN_LOWPRI;
		/* XXX from i386/conf.c */
		cn->cn_dev = makedev(8, 0);
	}
@


1.31
log
@rewrite the serial port handling to manipulate the hardware directly
rather than relying on calls into the bios to work.

this is a result of me getting pissed off with solaris and linux
being able to cope the serial bios redirection on dracs, iloms, and
ilos. trying to do the same thing with openbsds boot loader caused
weird behaviour like machine hangs or no visible output. talking
to the serial chips directly is more reliable.

tested by many

ok sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.29 2007/04/27 10:08:34 tom Exp $	*/
d137 1
d142 1
a142 1
	int port = comports[minor(cn->cn_dev)];
d159 1
a159 1
	int port = comports[minor(dev & 0x7f)];
d174 1
d213 4
a216 4
	outb(comports[minor(dev)] + com_cfcr, LCR_DLAB);
	outb(comports[minor(dev)] + com_dlbl, newsp);
	outb(comports[minor(dev)] + com_dlbh, newsp>>8);
	outb(comports[minor(dev)] + com_cfcr, LCR_8BITS);
d228 1
a228 1
	int port = comports[minor(dev)];
@


1.30
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d136 2
d141 1
a141 1
	register int unit = minor(cn->cn_dev);
d143 10
a152 3
	/* let bios do necessary init first, 9600-N-1 */
	__asm __volatile(DOINT(0x14) : : "a" (0xe3), "d" (unit) :
	    "%ecx", "cc" );
d158 1
a158 1
	register int rv;
d160 2
a161 5
	if (dev & 0x80) {
		__asm __volatile(DOINT(0x14) : "=a" (rv) :
		    "0" (0x300), "d" (minor(dev&0x7f)) : "%ecx", "cc" );
		return ((rv & 0x100) == 0x100);
	}
d163 2
a164 4
	do
		__asm __volatile(DOINT(0x14) : "=a" (rv) :
		    "0" (0x200), "d" (minor(dev)) : "%ecx", "cc" );
	while (rv & 0x8000);
d166 1
a166 1
	return (rv & 0xff);
a169 1
int com_speed = 9600;  /* default speed is 9600 baud */
d203 2
a204 1
	if (cn_tab && cn_tab->cn_dev == dev && com_speed != sp) {
d215 2
a216 1
	printf("\ncom%d: %d baud\n", minor(dev), sp);
d226 1
a226 3
	register int rv;

	dev = minor(dev) & 0x7f;
d228 4
a231 9
	/* check online (DSR) */
	__asm __volatile(DOINT(0x14) : "=a" (rv) :
	    "0" (0x300), "d" (dev) : "%ecx", "cc" );
	if ( (rv & 0x20) == 0)
		return;

	/* send character */
	__asm __volatile(DOINT(0x14) : "=a" (rv) :
	    "0" (c | 0x100), "d" (dev) : "%ecx", "cc" );
@


1.29
log
@Check for Control key held down when starting, and don't read boot.conf
if it is.  This gives a way to recover from "switching to com0" when
there's no serial cable handy.

Bump version numbers.

A similar change will be made to amd64 boot soon.

ok toby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.28 2007/01/02 16:29:27 tom Exp $	*/
d52 1
a52 1
	cn->cn_pri = CN_INTERNAL;
d59 1
a59 1
		cn->cn_pri = CN_INTERNAL;
d130 1
a130 1
		cn->cn_pri = CN_NORMAL;
@


1.28
log
@Fix the keyboard problem seen on Intel Macs, where only the first
keypress is seen by boot.

It appears that on the Intel Mac, we have to issue the "check for
keystroke" BIOS call before the "get keystroke" call will get it
(unlike any other BIOS I have seen in over 20 years).

It would not have been possible to fix this problem without the
donation from Steven N. Fettig (steve (at) anywheretechnology.com);
many thanks.

Bump versions of boot, cdboot and pxeboot accordingly.

Testing kettenis@@, otto@@, and others; ok weingart@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.27 2004/03/09 19:12:12 tom Exp $	*/
d93 11
@


1.27
log
@Spacing and KNF.  Partly from Joris Vink <nimadeus at pandora dot be>.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.26 2003/12/16 03:10:18 deraadt Exp $	*/
d82 9
@


1.26
log
@shorten terminal baud rate change strings
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.25 2003/11/27 00:32:45 espie Exp $	*/
d85 1
d151 1
a151 1
        int err;
d208 1
a208 1
	if ( !(rv & 0x20) )
a214 1

@


1.25
log
@Bad #undef, spotted by gcc3.
okay toby, mickey.
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.24 2003/08/11 06:23:09 deraadt Exp $	*/
d179 4
a182 6
	if (cn_tab && cn_tab->cn_dev == dev && com_speed != sp)
	{
		printf("com%d: changing speed to %d baud\n\a"
		       "com%d: change your terminal to match!\n\a"
		       "com%d: will change speed in 5 seconds....\n\a",
		       minor(dev), sp, minor(dev), minor(dev));
d190 1
a190 1
	printf("\ncom%d: console is at %d baud\n", minor(dev), sp);
@


1.24
log
@ansification and knf and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.23 2003/07/07 07:42:51 weingart Exp $	*/
d177 1
a177 1
#undef  divrnd(n, q)
@


1.23
log
@Fix for PR 3177.
Diff from Otto Moerbeek <otto at drijf.net>, testing by same.
Looked over, and other (outline testing) by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.22 2003/06/03 20:22:11 mickey Exp $	*/
d40 1
d50 1
a50 2
pc_probe(cn)
	struct consdev *cn;
d68 1
a68 2
pc_init(cn)
	struct consdev *cn;
d73 1
a73 2
pc_getc(dev)
	dev_t dev;
d89 1
a89 3
pc_putc(dev, c)
	dev_t dev;
	int c;
d98 1
a98 2
com_probe(cn)
	struct consdev *cn;
d116 1
a116 2
com_init(cn)
	struct consdev *cn;
d126 1
a126 2
com_getc(dev)
	dev_t dev;
d147 1
a147 3
comspeed(dev, sp)
	dev_t dev;
	int sp;
d200 1
a200 3
com_putc(dev, c)
	dev_t dev;
	int c;
@


1.22
log
@three four kills
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.21 2003/01/17 20:58:27 mickey Exp $	*/
d167 6
a172 1
	for (i = sp; i != 75; i >>= 1)
@


1.21
log
@allow setting com baudrate up to 115200; req and testing by Sourabh Ladha <ladha@@mail.eecis.udel.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.20 2001/03/03 03:34:13 aaron Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.20
log
@Fix typo, "edx" -> "%edx", so that the %edx register is properly protected
from clobbering; mickey@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.19 2000/10/18 15:22:35 mickey Exp $	*/
d169 1
a169 1
	if (sp > 38400 || sp < 75)
@


1.20.6.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d169 1
a169 1
	if (115200 < sp || sp < 75)
@


1.19
log
@before sending a character check for DSR state.
from: Martin Portmann <map@@infinitum.ch>
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.18 2000/06/08 01:51:32 mickey Exp $	*/
d91 1
a91 1
	    "%ecx", "edx", "cc" );
@


1.18
log
@move cnspeed func and comspeed proto in places
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.17 1999/08/25 00:54:19 mickey Exp $	*/
d215 9
d225 1
a225 1
	    "d" (minor(dev)), "0" (c | 0x100) : "%ecx", "cc" );
@


1.17
log
@give better support to the bios memory maps.
provide memory maps editing through the machine memory command.
rearrange probing in machdep, so it provides less output,
also giving a shot for apm to fix the memory maps.
changes to kernel are minimal, only that is required due
to the api version bits addition and such cosmetic changes.
tested on all critical kernel,boot combinations; niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.16 1998/05/28 20:52:39 mickey Exp $	*/
a44 13

int comspeed __P((dev_t, int));

int
cnspeed(dev, sp)
	dev_t	dev;
	int	sp;
{
	if (major(dev) == 8)	/* comN */
		return comspeed(dev, sp);
	/* pc0 and anything else */
	return 9600;
}
@


1.17.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.20 2001/03/03 03:34:13 aaron Exp $	*/
d46 13
d104 1
a104 1
	    "%ecx", "%edx", "cc" );
a227 9
	dev = minor(dev) & 0x7f;

	/* check online (DSR) */
	__asm __volatile(DOINT(0x14) : "=a" (rv) :
	    "0" (0x300), "d" (dev) : "%ecx", "cc" );
	if ( !(rv & 0x20) )
		return;

	/* send character */
d229 1
a229 1
	    "0" (c | 0x100), "d" (dev) : "%ecx", "cc" );
@


1.17.4.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d169 1
a169 1
	if (115200 < sp || sp < 75)
@


1.17.4.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.17.4.2 2003/03/27 23:26:56 niklas Exp $	*/
d15 5
@


1.17.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a39 1
#include "biosdev.h"
d49 2
a50 1
pc_probe(struct consdev *cn)
d68 2
a69 1
pc_init(struct consdev *cn)
d74 2
a75 1
pc_getc(dev_t dev)
d91 3
a93 1
pc_putc(dev_t dev, int c)
d102 2
a103 1
com_probe(struct consdev *cn)
d121 2
a122 1
com_init(struct consdev *cn)
d132 2
a133 1
com_getc(dev_t dev)
d154 3
a156 1
comspeed(dev_t dev, int sp)
d167 1
a167 6
	/*
	 * Accepted speeds:
	 *   75 150 300 600 1200 2400 4800 9600 19200 38400 76800 and
	 *   14400 28800 57600 115200
	 */
	for (i = sp; i != 75 && i != 14400; i >>= 1)
d181 1
a181 1
#undef  divrnd
d183 6
a188 4
	if (cn_tab && cn_tab->cn_dev == dev && com_speed != sp) {
		printf("com%d: changing speed to %d baud in 5 seconds, "
		    "change your terminal to match!\n\a",
		    minor(dev), sp);
d196 1
a196 1
	printf("\ncom%d: %d baud\n", minor(dev), sp);
d204 3
a206 1
com_putc(dev_t dev, int c)
@


1.17.4.5
log
@Merge with the trunk
@
text
@a84 1

d150 1
a150 1
	int err;
d207 1
a207 1
	if ( (rv & 0x20) == 0)
d214 1
@


1.17.6.1
log
@Pull in patch from current:
Fix (mickey):
before sending a character check for DSR state.
from: Martin Portmann <map@@infinitum.ch>
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.17 1999/08/25 00:54:19 mickey Exp $	*/
a227 9
	dev = minor(dev) & 0x7f;

	/* check online (DSR) */
	__asm __volatile(DOINT(0x14) : "=a" (rv) :
	    "0" (0x300), "d" (dev) : "%ecx", "cc" );
	if ( !(rv & 0x20) )
		return;

	/* send character */
d229 1
a229 1
	    "0" (c | 0x100), "d" (dev) : "%ecx", "cc" );
@


1.16
log
@cleanup the Makefiles a bit.
make machine link in a smart way, remove unused bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.15 1998/05/16 07:32:17 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997 Michael Shalayeff
d17 1
a17 1
 *	This product includes software developed by Michael Shalayeff.
d21 11
a31 12
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
d72 1
a72 1
	printf("pc%d ", minor(cn->cn_dev));
d80 1
a80 1
		printf("pc%d ", minor(cn->cn_dev));
a88 1
	printf("\nusing pc%d console\n", minor(cn->cn_dev));
d130 1
a130 1
		printf("com%d ", i);
@


1.15
log
@shorten device probe messages to 2 lines
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.14 1998/04/18 07:39:41 deraadt Exp $	*/
d42 1
a42 1
#include <i386/isa/nvram.h>
@


1.14
log
@i386 bootblocks that work for 2.3. A tale too long to tell
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.13 1997/10/24 22:21:15 mickey Exp $	*/
d73 1
a73 1
	printf("pc%d detected\n", minor(cn->cn_dev));
d81 1
a81 1
		printf("pc%d detected\n", minor(cn->cn_dev));
d90 1
a90 1
	printf("using pc%d console\n", minor(cn->cn_dev));
d132 1
a132 1
		printf("com%d detected\n", i);
d216 1
a216 1
	printf("com%d: console is at %d baud\n", minor(dev), sp);
@


1.13
log
@space by niklas
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.12 1997/10/07 08:18:48 mickey Exp $	*/
d45 1
d71 5
d83 1
d119 1
a119 1
static const int comports[4] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8 };
d172 1
a177 1
	static int com_speed = 9600;  /* default speed is 9600 baud */
d233 1
@


1.12
log
@use sleep(), remove unused function proto
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.11 1997/10/07 07:59:59 mickey Exp $	*/
d120 1
a120 1
	 /* get equip. (9-11 # of coms) */
@


1.11
log
@let's keep it MI; 10x phil for the MD implementation
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.10 1997/09/24 06:02:44 mickey Exp $	*/
a65 3
int com_setsp __P((int));
static const int comports[4] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8 };

d112 2
a171 1
	time_t tt;
d202 1
a202 3
		/* let the \n get out and the
		   user change the terminal */
		for (tt = getsecs() + 5; getsecs() < tt;);
@


1.10
log
@we have no bus here
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.9 1997/09/20 22:40:42 flipk Exp $	*/
d46 13
a66 1
static int com_speed = 9600;  /* default speed is 9600 baud */
a142 2
	/* now just set the speed */
	(void)com_setsp(com_speed);
d165 5
a169 4
/* ripped screaming from dev/ic/com.c */
static int
comspeed(speed)
	int speed;
d171 4
a174 2
#define divrnd(n, q)    (((n)*2/(q)+1)/2)       /* divide and round off */
        int x, err;
d176 4
a179 3
	if (speed == 0)
		return 0;
	if (speed < 0)
d181 9
a189 2
	x = divrnd((COM_FREQ / 16), speed);
	if (x <= 0)
d191 1
a191 1
	err = divrnd((COM_FREQ / 16) * 1000, speed * x) - 1000;
a195 1
	return x;
a196 8
}

/* call with sp == 0 to query the current speed */
int
com_setsp(sp)
	int sp;
{
	int unit, i, newsp = comspeed(sp);
d198 1
a198 4
	if (sp == 0)
		return com_speed;
	/* valid baud rate? */
	if (sp > 38400 || sp < 75)
d200 18
a217 33
	badspeed:
		printf("invalid terminal speed %d\n", sp);
		return 0;
	}
	for (i=sp; i != 75; i >>= 1)
		if (i & 1)
			goto badspeed;
	/* is current console a com device? */
	if (cn_tab && cn_tab->cn_getc == com_getc)
	{
		time_t tt;
		unit = minor(cn_tab->cn_dev);
		if (com_speed != sp)
		{
			printf("com%d: changing speed from %d to %d\n"
			       "com%d: change your terminal to match!\n"
			       "com%d: will change speed in 5 seconds....\n",
			       unit, com_speed, sp,
			       unit, unit);
			/* let the \n get out and the
			   user change the terminal */
			for (tt = getsecs() + 5; getsecs() < tt;);
		}
		outb(comports[unit] + com_cfcr, LCR_DLAB);
		outb(comports[unit] + com_dlbl, newsp);
		outb(comports[unit] + com_dlbh, newsp>>8);
		outb(comports[unit] + com_cfcr, LCR_8BITS);
		printf("using com%d console at %d baud\n", unit, sp);
	} else {
		printf("speed on next com device will be %d\n"
		       "change your terminal to match!\n", sp);
	}
	return com_speed = sp;
@


1.9
log
@- add 'stty [baudrate]' command to /boot, for serial consoles
- switch baud rates using i/o instead of bios, since bios commands
have only a limited bitwidth for baudrate, and max out at 9600
- when switching console devices, print msg to both old device and new
- fix timeout bug in com_getc() (dev | 0x80 was reading gobbledygook)
- document 'stty' command in boot(8)
- wording and cleanup in man pages
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.8 1997/09/02 20:36:57 mickey Exp $	*/
a37 1
#include <machine/bus.h>
d214 4
a217 8
		bus_space_write_1(I386_BUS_SPACE_IO, comports[unit],
				  com_cfcr, LCR_DLAB);
		bus_space_write_1(I386_BUS_SPACE_IO, comports[unit],
				  com_dlbl, newsp);
		bus_space_write_1(I386_BUS_SPACE_IO, comports[unit],
				  com_dlbh, newsp>>8);
		bus_space_write_1(I386_BUS_SPACE_IO, comports[unit], 
				  com_cfcr, LCR_8BITS);
@


1.8
log
@don't use direct regnames
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.7 1997/08/31 06:56:39 mickey Exp $	*/
d38 1
d41 2
d54 4
d129 1
a129 1
	/* 9600-N-1 */
d132 2
a133 1
	printf("using com%d console\n", unit);
d144 1
a144 1
		    "0" (0x300), "d" (minor(dev)) : "%ecx", "cc" );
d154 75
@


1.7
log
@consistancy
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.6 1997/08/22 00:25:58 mickey Exp $	*/
d78 1
a78 1
		__asm __volatile(DOINT(0x16) "; setnz %%al" : "=a" (rv) :
@


1.6
log
@byte returns
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.5 1997/08/21 21:52:12 mickey Exp $	*/
d79 1
a79 1
		    "a" (0x100) : "%ecx", "%edx", "cc" );
d83 1
a83 1
	__asm __volatile(DOINT(0x16) : "=a" (rv) : "a" (0) :
d85 1
a85 1
	return (rv &0xff);
d136 1
a136 1
		    "a" (0x300), "d" (minor(dev)) : "%ecx", "cc" );
d142 1
a142 1
		    "a" (0x200), "d" (minor(dev)) : "%ecx", "cc" );
d156 1
a156 1
	    "d" (minor(dev)), "a" (c | 0x100) : "%ecx", "cc" );
@


1.5
log
@print gray on black, not black on black
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.4 1997/08/13 15:17:04 mickey Exp $	*/
d80 1
a80 1
		return (rv);
d85 1
a85 1
	return (rv);
@


1.4
log
@better rv types
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.3 1997/08/13 14:24:01 niklas Exp $	*/
d93 1
a93 1
	__asm __volatile(DOINT(0x10) : : "a" (c | 0xe00), "b" (0) :
@


1.3
log
@s/kbd/pc/ for consistency with kernel.  Do even better __asms for BIOS calls.
Adapt to new console probing and setting API.  Do not try to probe pc0 via
the NVRAM.  Fix some other buglets.
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.2 1997/08/12 23:34:21 mickey Exp $	*/
d75 1
a75 1
	u_int8_t rv;
d120 1
a120 1
	int unit = minor(cn->cn_dev);
d141 1
a141 1
		__asm __volatile(DOINT(0x14) "\n\t" : "=a" (rv) :
d153 1
a153 1
	int rv;
d155 1
a155 1
	__asm __volatile(DOINT(0x14) "\n\t" : "=a" (rv) :
@


1.2
log
@_you_, hear?! never touch anything when doing commits!
@
text
@d1 1
a1 1
/*	$OpenBSD: bioscons.c,v 1.1 1997/08/12 21:39:01 mickey Exp $	*/
d42 1
d44 2
d47 3
d52 1
a52 1
kbd_probe(cn)
d60 1
d65 1
a65 1
kbd_init(cn)
d68 1
a68 1
	/* nothing */
d72 1
a72 1
kbd_getc(dev)
d78 3
a80 5
		__asm volatile("movb $1, %%ah\n\t"
			       DOINT(0x16) "\n\t"
			       "setnz %%al"
			       : "=a" (rv) :: "%ecx", "%edx", "cc" );
		return rv;
d83 3
a85 4
	__asm __volatile("xorl %%eax, %%eax\n\t"
			 DOINT(0x16)
			 : "=a" (rv) :: "%ecx", "edx", "cc" );
	return rv;
d89 1
a89 1
kbd_putc(dev, c)
d93 2
a94 3
	__asm __volatile("movb $0x0e, %%ah\n\t"
		       DOINT(0x10)
		       :: "a" (c), "b" (0) : "%ecx", "%edx", "cc" );
d102 3
a104 2
	__asm __volatile(DOINT(0x11) "\n\t" /* get equipment (9-11 # of coms) */
		       : "=a" (n) :: "%ecx", "%edx", "cc");
d108 6
a113 1
		;
d120 6
a125 3
	__asm volatile("movb $0xe2, %%al\n\t"
		       DOINT(0x14) "\n\t"
		       :: "d" (minor(cn->cn_dev)) : "%ecx", "cc" );
a132 3
	__asm volatile("movl $2, %%al\n\t"
		       DOINT(0x14) "\n\t"
		       : "=a" (rv): "d" (minor(dev)) : "%ecx", "cc" );
d134 5
a138 2
	if (!(rv & 0x8000))
		return 0;
d140 4
a143 2
	if (minor(dev) & 0x80)
		return 1;
d154 3
a156 3
	__asm volatile("movb $1, %%ah\n\t"
		       DOINT(0x14) "\n\t"
		       : "=a" (rv): "d" (minor(dev)), "a" (c) : "%ecx", "cc" );
@


1.1
log
@new cons
do inline BIOS calls
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 12
a80 13
	__asm volatile("movb $1, %%ah\n\t"
		       DOINT(0x16) "\n\t"
		       "setz %%al"
		       : "=a" (rv) :: "%ecx", "%edx", "cc" );
	if (rv)
		return 0;

	if (minor(dev) & 0x80)
		return 1;

	__asm volatile("xorl %%eax, %%eax\n\t"
		       DOINT(0x16) "\n\t"
		       : "=a" (rv) :: "%ecx", "edx", "cc" );
d89 1
a89 2
	__asm volatile("movb $0x0e, %%ah\n\t"
		       "movl $0, %%ebx\n\t"
d91 1
a91 1
		       :: "a" (c) : "%ecx", "%edx", "cc" );
d99 1
a99 1
	__asm volatile(DOINT(0x11) "\n\t" /* get equipment (9-11 # of coms) */
@
