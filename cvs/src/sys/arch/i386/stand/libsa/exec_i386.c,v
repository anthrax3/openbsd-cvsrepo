head	1.44;
access;
symbols
	OPENBSD_6_1:1.44.0.2
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.42.0.4
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.39.0.14
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.6
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.39.0.10
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.8
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.4
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.2
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.36.0.2
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.2
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.33.0.8
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.6
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.4
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.32.0.8
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.6
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.4
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.31.0.4
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.30.0.10
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.30.0.8
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.30.0.6
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.4
	OPENBSD_3_6_BASE:1.30
	SMP_SYNC_A:1.30
	SMP_SYNC_B:1.30
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.27
	OPENBSD_3_3:1.26.0.16
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.26.0.14
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.26.0.12
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.26
	UBC:1.26.0.10
	UBC_BASE:1.26
	OPENBSD_3_0:1.26.0.8
	OPENBSD_3_0_BASE:1.26
	OPENBSD_2_9:1.26.0.6
	OPENBSD_2_9_BASE:1.26
	OPENBSD_2_8:1.26.0.4
	OPENBSD_2_8_BASE:1.26
	OPENBSD_2_7:1.26.0.2
	OPENBSD_2_7_BASE:1.26
	SMP:1.24.0.8
	SMP_BASE:1.24
	kame_19991208:1.24
	OPENBSD_2_6:1.24.0.6
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.24.0.4
	OPENBSD_2_5_BASE:1.24
	OPENBSD_2_4:1.24.0.2
	OPENBSD_2_4_BASE:1.24
	OPENBSD_2_3:1.20.0.2
	OPENBSD_2_3_BASE:1.20
	OPENBSD_2_2:1.19.0.2
	OPENBSD_2_2_BASE:1.19
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8;
locks; strict;
comment	@ * @;


1.44
date	2016.09.11.17.52.47;	author jsing;	state Exp;
branches;
next	1.43;
commitid	OIt9eg6fQy6pFToA;

1.43
date	2016.09.11.15.54.11;	author jsing;	state Exp;
branches;
next	1.42;
commitid	m28Q0aUDbVqwDb3p;

1.42
date	2015.09.18.13.30.56;	author miod;	state Exp;
branches;
next	1.41;
commitid	1BEcCDYd9p5DIl0g;

1.41
date	2015.09.02.04.25.39;	author yasuoka;	state Exp;
branches;
next	1.40;
commitid	JNBvTwj7Fk2t01MI;

1.40
date	2015.09.02.04.09.24;	author yasuoka;	state Exp;
branches;
next	1.39;
commitid	1T0xGkKNIiRZnTmz;

1.39
date	2012.11.01.00.55.38;	author jsing;	state Exp;
branches;
next	1.38;

1.38
date	2012.10.31.13.55.58;	author jsing;	state Exp;
branches;
next	1.37;

1.37
date	2012.10.30.14.06.29;	author jsing;	state Exp;
branches;
next	1.36;

1.36
date	2012.06.03.13.17.47;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2012.01.11.15.58.27;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2011.04.26.17.33.17;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2009.04.30.13.47.16;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.27.17.46.56;	author tom;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.27.20.34.21;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.19.13.48.18;	author tom;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.09.19.12.13;	author tom;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.03.20.22.11;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2003.04.17.03.43.18;	author drahn;	state Exp;
branches;
next	1.26;

1.26
date	2000.03.05.18.40.59;	author niklas;	state Exp;
branches
	1.26.10.1;
next	1.25;

1.25
date	2000.02.18.17.10.10;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	98.09.27.17.41.18;	author mickey;	state Exp;
branches
	1.24.8.1;
next	1.23;

1.23
date	98.07.20.18.14.56;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	98.05.25.19.20.54;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	98.05.18.22.07.29;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	97.11.30.21.51.43;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	97.10.25.07.00.26;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	97.10.22.23.34.38;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	97.09.19.17.20.43;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	97.09.17.17.56.10;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	97.09.04.20.44.36;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	97.09.04.19.58.14;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	97.08.22.20.13.43;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.08.21.20.18.52;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.08.13.03.41.46;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.08.04.21.53.35;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.07.18.00.50.53;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.04.15.20.50.36;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.04.15.20.01.56;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.04.11.19.14.18;	author weingart;	state Exp;
branches;
next	1.5;

1.5
date	97.04.09.08.39.36;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.04.04.17.23.29;	author weingart;	state Exp;
branches;
next	1.3;

1.3
date	97.03.31.23.06.29;	author mickey;	state dead;
branches;
next	1.2;

1.2
date	97.03.31.05.52.25;	author weingart;	state Exp;
branches;
next	1.1;

1.1
date	97.03.31.03.12.13;	author weingart;	state Exp;
branches;
next	;

1.24.8.1
date	2000.02.20.11.56.49;	author niklas;	state Exp;
branches;
next	1.24.8.2;

1.24.8.2
date	2000.03.24.09.07.47;	author niklas;	state Exp;
branches;
next	1.24.8.3;

1.24.8.3
date	2003.05.13.19.42.09;	author ho;	state Exp;
branches;
next	1.24.8.4;

1.24.8.4
date	2003.06.07.11.11.38;	author ho;	state Exp;
branches;
next	1.24.8.5;

1.24.8.5
date	2004.06.05.23.09.01;	author niklas;	state Exp;
branches;
next	;

1.26.10.1
date	2003.05.19.21.45.12;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Switch i386 boot code to libsa MI softraid.
@
text
@/*	$OpenBSD: exec_i386.c,v 1.43 2016/09/11 15:54:11 jsing Exp $	*/

/*
 * Copyright (c) 1997-1998 Michael Shalayeff
 * Copyright (c) 1997 Tobias Weingartner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/disklabel.h>
#include <dev/cons.h>
#include <lib/libsa/loadfile.h>
#include <machine/biosvar.h>
#include <stand/boot/bootarg.h>

#include "disk.h"
#include "libsa.h"

#ifdef SOFTRAID
#include <dev/softraidvar.h>
#include <lib/libsa/softraid.h>
#include "softraid_i386.h"
#endif

#ifdef EFIBOOT
#include "efiboot.h"
#endif

typedef void (*startfuncp)(int, int, int, int, int, int, int, int)
    __attribute__ ((noreturn));

char *bootmac = NULL;

void
run_loadfile(u_long *marks, int howto)
{
	u_long entry;
#ifdef EXEC_DEBUG
	extern int debug;
#endif
	dev_t bootdev = bootdev_dip->bootdev;
	size_t ac = BOOTARG_LEN;
	caddr_t av = (caddr_t)BOOTARG_OFF;
	bios_consdev_t cd;
	extern int com_speed; /* from bioscons.c */
	extern int com_addr;
	bios_ddb_t ddb;
	extern int db_console;
	bios_bootduid_t bootduid;
#ifdef SOFTRAID
	bios_bootsr_t bootsr;
	struct sr_boot_volume *bv;
#endif

#ifdef EFIBOOT
	if ((av = alloc(ac)) == NULL)
		panic("alloc for bootarg");
	efi_makebootargs();
#endif
	if (sa_cleanup != NULL)
		(*sa_cleanup)();

	cd.consdev = cn_tab->cn_dev;
	cd.conspeed = com_speed;
	cd.consaddr = com_addr;
	cd.consfreq = 0;
	addbootarg(BOOTARG_CONSDEV, sizeof(cd), &cd);

	if (bootmac != NULL)
		addbootarg(BOOTARG_BOOTMAC, sizeof(bios_bootmac_t), bootmac);

	if (db_console != -1) {
		ddb.db_console = db_console;
		addbootarg(BOOTARG_DDB, sizeof(ddb), &ddb);
	}

	bcopy(bootdev_dip->disklabel.d_uid, &bootduid.duid, sizeof(bootduid));
	addbootarg(BOOTARG_BOOTDUID, sizeof(bootduid), &bootduid);

#ifdef SOFTRAID
	if (bootdev_dip->sr_vol != NULL) {
		bv = bootdev_dip->sr_vol;
		bzero(&bootsr, sizeof(bootsr));
		bcopy(&bv->sbv_uuid, &bootsr.uuid, sizeof(bootsr.uuid));
		if (bv->sbv_maskkey != NULL)
			bcopy(bv->sbv_maskkey, &bootsr.maskkey,
			    sizeof(bootsr.maskkey));
		addbootarg(BOOTARG_BOOTSR, sizeof(bios_bootsr_t), &bootsr);
		explicit_bzero(&bootsr, sizeof(bootsr));
	}

	sr_clear_keys();
#endif

	/* Pass memory map to the kernel */
	mem_pass();

#ifdef __amd64__
	/*
	 * This code may be used both for 64bit and 32bit.  Make sure the
	 * bootarg is 32bit always on even on amd64.
	 */
	makebootargs32(av, &ac);
#else
	makebootargs(av, &ac);
#endif

	entry = marks[MARK_ENTRY] & 0x0fffffff;

	printf("entry point at 0x%x\n", (int)entry);

#if defined(EFIBOOT)
	efi_cleanup();
#endif
#if defined(EFIBOOT) && defined(__amd64__)
	(*run_i386)((u_long)run_i386, entry, howto, bootdev, BOOTARG_APIVER,
	    marks[MARK_END], extmem, cnvmem, ac, (intptr_t)av);
#else
	/* stack and the gung is ok at this point, so, no need for asm setup */
	(*(startfuncp)entry)(howto, bootdev, BOOTARG_APIVER, marks[MARK_END],
	    extmem, cnvmem, ac, (int)av);
	/* not reached */
#endif
}
@


1.43
log
@Rename softraid boot files, which are currently in an MD location. This
will allow us to bring in a MI softraid.{c,h} in lib/libsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.42 2015/09/18 13:30:56 miod Exp $	*/
d43 1
@


1.42
log
@Remove support for building the boot blocks with DEBUGFLAGS=-D_TEST, which is
supposed to create a userland binary in order to test non-boot related
functionality. This feature has been bitrotting in a non-compiling state
for years, and causes a too-many-ifdefs disease now that there are intrusive
EFI changes.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.41 2015/09/02 04:25:39 yasuoka Exp $	*/
d43 1
a43 1
#include "softraid.h"
@


1.41
log
@Fix the bios boot to pass the bootargs properly.

ok deraddt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.40 2015/09/02 04:09:24 yasuoka Exp $	*/
a58 1
#ifndef _TEST
a143 1
#endif
@


1.40
log
@Bring the boot changes on amd64 to i386.  alloca is deleted.
Also fix the boot from BIOS and bump the version.

input and ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.13 2015/09/02 01:52:26 yasuoka Exp $	*/
d120 1
d126 3
@


1.39
log
@Fix merge errors.

Found the hard way by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.38 2012/10/31 13:55:58 jsing Exp $	*/
d46 4
d77 5
d120 5
a124 1
	makebootargs(av, &ac);
d130 7
d141 1
@


1.38
log
@Bring softraid support to i386/stand/libsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.11 2012/10/27 15:43:42 jsing Exp $	*/
d40 5
@


1.37
log
@Apply a bunch of style(9) and whitespace fixes to i386/amd64 libsa, making
the code actually diffable. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.35 2012/01/11 15:58:27 jsing Exp $	*/
d32 1
d34 2
d37 1
a37 2
#include <machine/biosvar.h>
#include <sys/disklabel.h>
a39 1
#include <lib/libsa/loadfile.h>
d51 3
d63 4
d87 15
@


1.36
log
@Add support for serial consoles at non-standard addresses.  This implements
a new "machine comaddr" command that makes it possible to configure the
io port used to access the serial port.  This can be used to use serial ports
on a puc(4) device as serial console.
@
text
@d87 2
a88 1
	printf("entry point at 0x%x\n", (int) entry);
d90 2
a91 2
	(*(startfuncp)entry)(howto, bootdev, BOOTARG_APIVER,
	    marks[MARK_END], extmem, cnvmem, ac, (int)av);
@


1.35
log
@Pass the DUID of the boot disk via bootduid instead of rootduid, since it
is the DUID that we booted from, which is not always going to be the same
as the DUID that we mount root on.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.34 2011/04/26 17:33:17 jsing Exp $	*/
d55 1
d65 2
@


1.34
log
@Make amd64/i386 boot(8) pass the DUID of the selected boot device to the
kernel so that it can use it to identify the root disk. This will be
needed in order to correctly boot from a softraid volume.

ok deraadt@@ marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.31 2006/03/27 20:34:21 mickey Exp $	*/
d57 1
a57 1
	bios_rootduid_t rootduid;
d74 2
a75 2
	bcopy(bootdev_dip->disklabel.d_uid, &rootduid.duid, sizeof(rootduid));
	addbootarg(BOOTARG_ROOTDUID, sizeof(rootduid), &rootduid);
@


1.33
log
@add support for passing db_console from the bootloader to the kernel.

based on the same change in amd64.
@
text
@d57 1
d73 3
@


1.32
log
@We don't want to pass the PXE MAC address to the kernel when booting
from a local disk, since the MAC address causes the kernel to look for
root on NFS.  Do this by remembering (not adding to boot arguments) the
MAC address when opening the PXE device, and clearing this if we happen
to load a file off a non-network disk.

"works as advertised for me" todd@@;
"stop sitting on this/no objections" deraadt@@
@
text
@d55 2
d67 5
@


1.31
log
@kill unused extern in ifdef DEBUG even
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.30 2004/03/19 13:48:18 tom Exp $	*/
d43 2
d62 3
@


1.30
log
@Enter pxeboot, derived from the NetBSD implementation.  Initially
intended to support network installs using bsd.rd over TFTP.

Thanks to the many who tested, including Diana Eichert.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.29 2004/03/09 19:12:13 tom Exp $	*/
a47 3
#ifdef EXEC_DEBUG
	extern int debug;
#endif
@


1.29
log
@Spacing and KNF.  Partly from Joris Vink <nimadeus at pandora dot be>.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.28 2003/06/03 20:22:11 mickey Exp $	*/
d56 3
@


1.28
log
@three four kills
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.27 2003/04/17 03:43:18 drahn Exp $	*/
d17 2
a18 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
d41 1
a41 1
	__attribute__ ((noreturn));
d71 1
a71 1
		marks[MARK_END], extmem, cnvmem, ac, (int)av);
@


1.27
log
@i386 ELF bootloader. developed with weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.26 2000/03/05 18:40:59 niklas Exp $	*/
a15 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 *	This product includes software developed by Tobias Weingartner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.26
log
@D not forget our memmap changes, ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.25 2000/02/18 17:10:10 mickey Exp $	*/
d44 1
a44 1
#include <lib/libsa/exec.h>
d50 1
a50 4
machdep_exec(xp, howto, loadaddr)
	struct x_param *xp;
	int howto;
	void *loadaddr;
d52 1
d72 1
a72 14
#ifdef EXEC_DEBUG
	if (debug) {
		struct exec *x = (void *)loadaddr;
		printf("exec {\n\ta_midmag = %x\n\ta_text = %x\n\ta_data = %x\n"
		       "\ta_bss = %x\n\ta_syms = %x\n\ta_entry = %x\n"
		       "\ta_trsize = %x\n\ta_drsize = %x\n}\n",
		       x->a_midmag, x->a_text, x->a_data, x->a_bss, x->a_syms,
		       x->a_entry, x->a_trsize, x->a_drsize);

		printf("/bsd(%x,%u,%p)\n", BOOTARG_APIVER, ac, av);
		getchar();
	}
#endif
	xp->xp_entry &= 0xffffff;
d74 1
a74 1
	printf("entry point at 0x%x\n", xp->xp_entry);
d76 2
a77 2
	(*(startfuncp)xp->xp_entry)(howto, bootdev, BOOTARG_APIVER,
		xp->xp_end, extmem, cnvmem, ac, (int)av);
@


1.26.10.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
#include <lib/libsa/loadfile.h>
d50 4
a53 1
run_loadfile(u_long *marks, int howto)
a54 1
	u_long entry;
d74 14
a87 1
	entry = marks[MARK_ENTRY] & 0x0fffffff;
d89 1
a89 1
	printf("entry point at 0x%x\n", (int) entry);
d91 2
a92 2
	(*(startfuncp)entry)(howto, bootdev, BOOTARG_APIVER,
		marks[MARK_END], extmem, cnvmem, ac, (int)av);
@


1.25
log
@full support for a serial console.
iface addition: pass serial speed from /boot.
tested on 4 /boot+kernel permutations.
also, niklas@@ said he likes it
bugs: any printfs before cninit() will go to the
default console, which is mon/kbd, but are usually
only sorts of debugging messages (like bios_memmap load).
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.24 1998/09/27 17:41:18 mickey Exp $	*/
d68 3
@


1.24
log
@#ifdef and if() debugging stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.23 1998/07/20 18:14:56 mickey Exp $	*/
d62 6
@


1.24.8.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.25 2000/02/18 17:10:10 mickey Exp $	*/
a61 6
	bios_consdev_t cd;
	extern int com_speed; /* from bioscons.c */

	cd.consdev = cn_tab->cn_dev;
	cd.conspeed = com_speed;
	addbootarg(BOOTARG_CONSDEV, sizeof(cd), &cd);
@


1.24.8.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a67 3

	/* Pass memory map to the kernel */
	mem_pass();
@


1.24.8.3
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.24.8.2 2000/03/24 09:07:47 niklas Exp $	*/
d44 1
a44 1
#include <lib/libsa/loadfile.h>
d50 4
a53 1
run_loadfile(u_long *marks, int howto)
a54 1
	u_long entry;
d74 14
a87 1
	entry = marks[MARK_ENTRY] & 0x0fffffff;
d89 1
a89 1
	printf("entry point at 0x%x\n", (int) entry);
d91 2
a92 2
	(*(startfuncp)entry)(howto, bootdev, BOOTARG_APIVER,
		marks[MARK_END], extmem, cnvmem, ac, (int)av);
@


1.24.8.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.24.8.3 2003/05/13 19:42:09 ho Exp $	*/
d16 6
@


1.24.8.5
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d17 2
a18 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
d41 1
a41 1
    __attribute__ ((noreturn));
a56 3
	if (sa_cleanup != NULL)
		(*sa_cleanup)();

d71 1
a71 1
	    marks[MARK_END], extmem, cnvmem, ac, (int)av);
@


1.23
log
@new exec framework
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.22 1998/05/25 19:20:54 mickey Exp $	*/
d56 3
d62 1
a62 3
#ifdef EXEC_DEBUG
	struct exec *x;
#endif
d66 11
a76 9
	x = (void *)loadaddr;
	printf("exec {\n\ta_midmag = %x\n\ta_text = %x\n\ta_data = %x\n"
	       "\ta_bss = %x\n\ta_syms = %x\n\ta_entry = %x\n"
	       "\ta_trsize = %x\n\ta_drsize = %x\n}\n",
	       x->a_midmag, x->a_text, x->a_data, x->a_bss, x->a_syms,
	       x->a_entry, x->a_trsize, x->a_drsize);

	printf("/bsd(%x,%u,%p)\n", BOOTARG_APIVER, ac, av);
	getchar();
@


1.22
log
@put support for test /boot environment back; some CLEANFILES and spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.21 1998/05/18 22:07:29 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997 Michael Shalayeff
a37 2
#include <sys/exec.h>
#include <sys/reboot.h>
d44 1
a44 2

#define round_to_size(x) (((int)(x) + sizeof(int) - 1) & ~(sizeof(int) - 1))
d47 1
a47 1
    __attribute__ ((noreturn));
d50 2
a51 2
machdep_start(startaddr, howto, loadaddr, ssym, esym)
	char *startaddr, *loadaddr, *ssym, *esym;
d53 1
d66 3
a68 3
	printf("exec {\n\ta_midmag = %lx\n\ta_text = %lx\n\ta_data = %lx\n"
	       "\ta_bss = %lx\n\ta_syms = %lx\n\ta_entry = %lx\n"
	       "\ta_trsize = %lx\n\ta_drsize = %lx\n}\n",
d72 1
a72 3
	printf("/bsd(%x,%x,%x,%x,%x,%x,%d,%p)\n",
	       howto, bootdev, BOOTARG_APIVER, round_to_size(esym),
	       extmem, cnvmem, ac, av);
d75 1
a75 1
	(int)startaddr &= 0xffffff;
d77 1
a77 1
	printf("entry point at %p\n", startaddr);
d79 2
a80 2
	(*(startfuncp)startaddr)(howto, bootdev, BOOTARG_APIVER,
	    round_to_size(esym), extmem, cnvmem, ac, (int)av);
@


1.21
log
@start using new apiver things
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.20 1997/11/30 21:51:43 mickey Exp $	*/
d57 1
d86 1
@


1.20
log
@big diskinfo changes from toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.19 1997/10/25 07:00:26 mickey Exp $	*/
d74 1
a74 1
	       howto, bootdev, BOOT_APIVER, round_to_size(esym),
d82 1
a82 1
	(*(startfuncp)startaddr)(howto, bootdev, BOOT_APIVER,
@


1.19
log
@new bootarg
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.18 1997/10/22 23:34:38 mickey Exp $	*/
d43 2
d57 1
@


1.18
log
@newer, better stuff; some parts by toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.17 1997/09/19 17:20:43 niklas Exp $	*/
d55 2
a56 2
	size_t argc;
	void *argv = makebootargs(&argc);
d59 2
d62 1
d72 1
a72 1
	       extmem, cnvmem, argc, argv);
d80 1
a80 1
	    round_to_size(esym), extmem, cnvmem, argc, (int)argv);
@


1.17
log
@Make newer gcc happy
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.16 1997/09/17 17:56:10 mickey Exp $	*/
d41 1
d55 2
d67 1
a67 1
	printf("/bsd(%x,%x,%x,%x,%x,%x,%x)\n",
d69 1
a69 1
	       extmem, cnvmem, (int)&BIOS_vars, sizeof(BIOS_vars));
d74 1
a74 1
	printf("entry point at 0x%x\n", (int)startaddr);
d77 1
a77 2
	    round_to_size(esym), extmem, cnvmem, (int)&BIOS_vars,
	    sizeof (BIOS_vars));
@


1.16
log
@pass cnvmem,extmem the old way they were....
don't put 'em in biosvars
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.15 1997/09/04 20:44:36 mickey Exp $	*/
d46 3
d73 3
a75 3
	(*(int __attribute__((noreturn))(*)(int,int,int,int,int,int,int,int))
	 startaddr)(howto, bootdev, BOOT_APIVER, round_to_size(esym),
		    extmem, cnvmem, (int)&BIOS_vars, sizeof(BIOS_vars));
a77 1

@


1.15
log
@s/DEBUG/EXEC_DEBUG/
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.14 1997/09/04 19:58:14 mickey Exp $	*/
d63 1
a63 2
	       BIOS_vars.bios_extmem, BIOS_vars.bios_cnvmem,
	       (int)&BIOS_vars);
a65 3
	if (cn_tab != NULL)
		BIOS_vars.boot_consdev = cn_tab->cn_dev;

d70 1
a70 1
	(*(int __attribute__((noreturn))(*)(int,int,int,int,int,int,int))
d72 1
a72 2
		    BIOS_vars.bios_extmem, BIOS_vars.bios_cnvmem,
		    (int)&BIOS_vars);
@


1.14
log
@support boot API version number
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.13 1997/08/22 20:13:43 mickey Exp $	*/
d51 1
a51 1
#ifdef DEBUG
@


1.13
log
@put values into BIOS_vars so kernel will get 'em soon
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.12 1997/08/21 20:18:52 mickey Exp $	*/
d62 1
a62 1
	       howto, bootdev, 0, round_to_size(esym),
d75 1
a75 1
	 startaddr)(howto, bootdev, 0, round_to_size(esym),
@


1.12
log
@missing )
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.11 1997/08/13 03:41:46 mickey Exp $	*/
d40 1
a43 2
int	bootdev, bootdev_geometry;

d61 4
a64 3
	printf("/bsd(%x,%x,%x,%x,%x,%x,%x,%x)\n",
		howto, bootdev, 0, round_to_size(esym),
		extmem, cnvmem, (int)&apminfo, (int)&kentry);
d67 2
d74 4
a77 3
	(*(int __attribute__((noreturn))(*)(int,int,int,int,int,int,int,int))
		startaddr)(howto, bootdev, 0, round_to_size(esym),
			   extmem, cnvmem, (int)&apminfo, (int)&kentry);
@


1.11
log
@print kernel arguments
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.10 1997/08/04 21:53:35 mickey Exp $	*/
d62 1
a62 1
	printf("/bsd(%x,%x,%x,%x,%x,%x,%x,%x\n",
@


1.10
log
@remember boot device geometry
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.9 1997/07/18 00:50:53 mickey Exp $	*/
d62 3
@


1.9
log
@pass apm info to the kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.8 1997/04/15 20:50:36 mickey Exp $	*/
d40 1
d43 1
a43 1
dev_t	bootdev;
d69 1
a69 1
	(*(int __attribute__((noreturn))(*)(int,int,int,int,int,int,int))
d71 1
a71 1
			   extmem, cnvmem, (int)&apminfo);
@


1.8
log
@pass bootdev to kernel...
all the future devices have to copy it into global var...
in the current state i can boot any kernel i have....
testers?
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.7 1997/04/15 20:01:56 mickey Exp $	*/
d40 1
a40 1
#include <libsa.h>
d68 3
a70 2
	(*(int __attribute__((noreturn))(*)(int,int,int,int,int,int))startaddr)(
		howto, bootdev, 0, round_to_size(esym), extmem, cnvmem);
@


1.7
log
@no more assembly setup. all the gung is ok already in srt0.S
this is what we were talking about, toby (;
and this shaves a couple of dozens of bytes!
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_i386.c,v 1.6 1997/04/11 19:14:18 weingart Exp $	*/
d42 1
a42 1
static int bootdev;
@


1.6
log
@Works with .gz kernels now
@
text
@d1 1
d3 33
a35 1
/* $OpenBSD: exec_i386.c,v 1.5 1997/04/09 08:39:36 mickey Exp $ */
a41 3
#include <biosdev.h>

int startprog(void *, void *);
a45 1

a50 2
	static int argv[9];

d55 5
a59 10
	printf("exec {\n");
	printf("  a_midmag = %lx\n", x->a_midmag);
	printf("  a_text = %lx\n", x->a_text);
	printf("  a_data = %lx\n", x->a_data);
	printf("  a_bss = %lx\n", x->a_bss);
	printf("  a_syms = %lx\n", x->a_syms);
	printf("  a_entry = %lx\n", x->a_entry);
	printf("  a_trsize = %lx\n", x->a_trsize);
	printf("  a_drsize = %lx\n", x->a_drsize);
	printf("}\n");
a65 36
	/*
	 *  We now pass the various bootstrap parameters to the loaded
	 *  image via the argument list
	 *
	 *  arg0 = 8 (magic)
	 *  arg1 = boot flags
	 *  arg2 = boot device
	 *  arg3 = start of symbol table (0 if not loaded)
	 *  arg4 = end of symbol table (0 if not loaded)
	 *  arg5 = transfer address from image
	 *  arg6 = transfer address for next image pointer
	 *  arg7 = conventional memory size (640)
	 *  arg8 = extended memory size (8196)
	 */
	argv[0] = 8;
	argv[1] = howto;
	argv[2] = bootdev;
	argv[3] = (int)ssym;
	argv[4] = (int)round_to_size(esym);
	argv[5] = (int)startaddr;
	argv[6] = 0;
	argv[7] = cnvmem;
	argv[8] = extmem;

#ifdef DEBUG
	{ int i;
		for(i = 0; i <= argv[0]; i++)
			printf("argv[%d] = %x\n", i, argv[i]);

		getchar();
	}
#endif

	/****************************************************************/
	/* copy that first page and overwrite any BIOS variables        */
	/****************************************************************/
d67 4
a70 1
	startprog(startaddr, argv);
@


1.5
log
@emulate bios calls. more debugging stuff. some fixes.
@
text
@d2 1
a2 1
/* $OpenBSD: exec_i386.c,v 1.4 1997/04/04 17:23:29 weingart Exp $ */
d10 1
d14 3
d23 2
a26 2

#ifdef DEBUG
d62 1
a62 1
	argv[4] = (int)esym;
@


1.4
log
@Replace exec_i386.S with these two files.  Startprog.S is a
stopgap measure, to be removed once I get locore.s done.
@
text
@d2 1
a2 1
/* $OpenBSD: exec_i386.c,v 1.3 1997/03/31 23:06:29 mickey dead $ */
d61 2
a62 2
	argv[7] = biosmem(0);
	argv[8] = biosmem(1);
@


1.3
log
@commit all my mods to the last imported libsa stuff....
including:
- disklabel support;
- better boot cmd line
- smaller size (using some compilation switches ;)
- no more relocations in /boot, it's loaded in the place;
- better disk performance (maybe were already in there)
- installboot -n does not require write perms for device
- more debugs
- missing parts in libsa (such as cd9660 and so)
- i don't like 2 files for exec_i386 (sorry, toby, let's discuss maybe?)
tricks and tails:
- joined .text and .data (saves you a page)
- prot mode switching still in biosboot (it's freezed for awhile)
- biosdisk internals changed
- biosdev is not passed propery to the kernel (i'll fix it soon)
- sure i missed smth here to note (use the source, Luke!)
@
text
@d2 1
a2 1
/* $OpenBSD: exec_i386.c,v 1.2 1997/03/31 05:52:25 weingart Exp $ */
d9 3
d47 1
a47 1
	 *  arg3 = Cylinder offset (XXX - used to be ssym)
d56 3
a58 3
	argv[2] = bootdev;		/* Boot device */
	argv[3] = 0;			/* Cyl offset */
	argv[4] = 0;
d61 2
a62 2
	argv[7] = memsize(0);
	argv[8] = memsize(1);
@


1.2
log
@Move closer to boot/.  Add some debug stuff
@
text
@d2 1
a2 1
/* $OpenBSD: exec_i386.c,v 1.1 1997/03/31 03:12:13 weingart Exp $ */
@


1.1
log
@Initial /boot stuff (from Mickey)
@
text
@d2 1
a2 1
/* $OpenBSD$ */
d16 18
a33 1
	static int (*x_entry)() = 0;
a34 1
	x_entry = (void *)startaddr;
d44 1
a44 1
	 *  arg3 = start of symbol table (0 if not loaded)
d53 3
a55 3
	argv[2] = 0;		/* Boot device */
	argv[3] = 0;		/* Cyl offset */
	argv[4] = (int)esym;
d57 12
a68 3
	argv[6] = (int)&x_entry;
	argv[7] = 0;
	argv[8] = 0;
@
