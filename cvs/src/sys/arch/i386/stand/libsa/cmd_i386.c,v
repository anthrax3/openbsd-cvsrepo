head	1.36;
access;
symbols
	OPENBSD_6_2:1.36.0.8
	OPENBSD_6_2_BASE:1.36
	OPENBSD_6_1:1.36.0.6
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.2
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.33.0.10
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.33.0.6
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.32.0.4
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.2
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.31.0.2
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.8
	OPENBSD_5_0:1.30.0.6
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.4
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.29.0.12
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.14
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.10
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.8
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.6
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.4
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.28.0.12
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.10
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.8
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.6
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.4
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.24.0.6
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.4
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	UBC_SYNC_B:1.24
	UBC:1.22.0.14
	UBC_BASE:1.22
	OPENBSD_3_0:1.22.0.12
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9:1.22.0.10
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_8:1.22.0.8
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.22.0.6
	OPENBSD_2_7_BASE:1.22
	SMP:1.22.0.4
	SMP_BASE:1.22
	kame_19991208:1.22
	OPENBSD_2_6:1.22.0.2
	OPENBSD_2_6_BASE:1.22
	OPENBSD_2_5:1.21.0.4
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.21.0.2
	OPENBSD_2_4_BASE:1.21
	OPENBSD_2_3:1.20.0.2
	OPENBSD_2_3_BASE:1.20
	OPENBSD_2_2:1.18.0.2
	OPENBSD_2_2_BASE:1.18;
locks; strict;
comment	@ * @;


1.36
date	2016.06.10.18.36.06;	author jcs;	state Exp;
branches;
next	1.35;
commitid	x57WcyDUhZLxQO5Z;

1.35
date	2015.09.18.13.30.56;	author miod;	state Exp;
branches;
next	1.34;
commitid	1BEcCDYd9p5DIl0g;

1.34
date	2015.09.02.04.09.24;	author yasuoka;	state Exp;
branches;
next	1.33;
commitid	1T0xGkKNIiRZnTmz;

1.33
date	2013.10.23.05.05.19;	author mlarkin;	state Exp;
branches;
next	1.32;

1.32
date	2012.10.30.14.06.29;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2012.06.03.13.17.47;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2010.07.02.00.36.52;	author weingart;	state Exp;
branches;
next	1.29;

1.29
date	2006.09.18.21.14.15;	author mpf;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.09.19.12.12;	author tom;	state Exp;
branches;
next	1.27;

1.27
date	2003.08.11.06.23.09;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.03.20.22.11;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.31.00.15.29;	author weingart;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.03.15.54;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.01.26.34;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	99.08.25.00.54.19;	author mickey;	state Exp;
branches
	1.22.4.1
	1.22.14.1;
next	1.21;

1.21
date	98.05.25.19.20.51;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	98.02.24.22.06.47;	author weingart;	state Exp;
branches;
next	1.19;

1.19
date	97.11.30.21.51.41;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	97.10.25.02.07.09;	author weingart;	state Exp;
branches;
next	1.17;

1.17
date	97.10.24.22.22.56;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	97.10.23.15.13.27;	author weingart;	state Exp;
branches;
next	1.15;

1.15
date	97.10.22.23.34.37;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	97.10.21.02.42.31;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	97.10.20.14.56.09;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.10.20.14.47.42;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.10.17.18.46.55;	author weingart;	state Exp;
branches;
next	1.10;

1.10
date	97.10.17.15.03.23;	author weingart;	state Exp;
branches;
next	1.9;

1.9
date	97.10.09.22.23.00;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.10.02.04.30.23;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.09.26.18.07.12;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.09.17.19.55.36;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.09.03.04.32.44;	author weingart;	state Exp;
branches;
next	1.4;

1.4
date	97.09.02.23.06.55;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.09.02.22.43.17;	author weingart;	state Exp;
branches;
next	1.2;

1.2
date	97.09.02.22.42.26;	author weingart;	state Exp;
branches;
next	1.1;

1.1
date	97.09.02.20.58.15;	author mickey;	state Exp;
branches;
next	;

1.22.4.1
date	2002.03.28.10.31.05;	author niklas;	state Exp;
branches;
next	1.22.4.2;

1.22.4.2
date	2003.06.07.11.11.38;	author ho;	state Exp;
branches;
next	1.22.4.3;

1.22.4.3
date	2004.02.19.10.48.43;	author niklas;	state Exp;
branches;
next	1.22.4.4;

1.22.4.4
date	2004.06.05.23.09.01;	author niklas;	state Exp;
branches;
next	;

1.22.14.1
date	2002.06.11.03.35.55;	author art;	state Exp;
branches;
next	;


desc
@@


1.36
log
@fix some typos in comments

from Tom Cosgrove
@
text
@/*	$OpenBSD: cmd_i386.c,v 1.35 2015/09/18 13:30:56 miod Exp $	*/

/*
 * Copyright (c) 1997-1999 Michael Shalayeff
 * Copyright (c) 1997 Tobias Weingartner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <machine/biosvar.h>
#include <sys/disklabel.h>
#include "disk.h"
#include "debug.h"
#include "biosdev.h"
#include "libsa.h"
#include <cmd.h>

#ifdef EFIBOOT
#include "efiboot.h"
#endif

extern const char version[];

int Xboot(void);
int Xcomaddr(void);
int Xdiskinfo(void);
int Xmemory(void);
int Xregs(void);

/* From gidt.S */
int bootbuf(void *, int);

const struct cmd_table cmd_machine[] = {
	{ "boot",	CMDT_CMD, Xboot },
	{ "comaddr",	CMDT_CMD, Xcomaddr },
	{ "diskinfo",	CMDT_CMD, Xdiskinfo },
	{ "memory",	CMDT_CMD, Xmemory },
#ifdef EFIBOOT
	{ "video",	CMDT_CMD, Xvideo_efi },
	{ "exit",	CMDT_CMD, Xexit_efi },
	{ "poweroff",	CMDT_CMD, Xpoweroff_efi },
#endif
#ifdef DEBUG
	{ "regs",	CMDT_CMD, Xregs },
#endif
	{ NULL, 0 }
};

int
Xdiskinfo(void)
{
	dump_diskinfo();
	return 0;
}

#ifdef DEBUG
int
Xregs(void)
{
	DUMP_REGS;
	return 0;
}
#endif

int
Xboot(void)
{
#ifdef EFIBOOT
	printf("Not supported yet\n");
#else
	int dev, part, st;
	struct diskinfo *dip;
	char buf[DEV_BSIZE], *dest = (void *)BOOTBIOS_ADDR;

	if (cmd.argc != 2) {
		printf("machine boot {fd,hd}<0123>[abcd]\n");
		printf("Where [0123] is the disk number,"
		    " and [abcd] is the partition.\n");
		return 0;
	}

	/* Check arg */
	if (cmd.argv[1][0] != 'f' && cmd.argv[1][0] != 'h')
		goto bad;
	if (cmd.argv[1][1] != 'd')
		goto bad;
	if (cmd.argv[1][2] < '0' || cmd.argv[1][2] > '3')
		goto bad;
	if ((cmd.argv[1][3] < 'a' || cmd.argv[1][3] > 'd') &&
	    cmd.argv[1][3] != '\0')
		goto bad;

	printf("Booting from %s ", cmd.argv[1]);

	dev = (cmd.argv[1][0] == 'h')?0x80:0;
	dev += (cmd.argv[1][2] - '0');
	part = (cmd.argv[1][3] - 'a');

	if (part > 0)
		printf("[%x,%d]\n", dev, part);
	else
		printf("[%x]\n", dev);

	/* Read boot sector from device */
	dip = dklookup(dev);
	st = dip->diskio(F_READ, dip, 0, 1, buf);
	if (st)
		goto bad;

	/* Frob boot flag in buffer from HD */
	if ((dev & 0x80) && (part > 0)){
		int i, j;

		for (i = 0, j = DOSPARTOFF; i < 4; i++, j += 16)
			if (part == i)
				buf[j] |= 0x80;
			else
				buf[j] &= ~0x80;
	}

	/* Load %dl, ljmp */
	bcopy(buf, dest, DEV_BSIZE);
	bootbuf(dest, dev);

bad:
	printf("Invalid device!\n");
#endif
	return 0;
}

int
Xmemory(void)
{
	if (cmd.argc >= 2) {
		int i;
		/* parse the memory specs */

		for (i = 1; i < cmd.argc; i++) {
			char *p;
			long long addr, size;

			p = cmd.argv[i];

			size = strtoll(p + 1, &p, 0);
			/* Size the size */
			switch (*p) {
				case 'G':
				case 'g':
					size *= 1024;
				case 'M':
				case 'm':
					size *= 1024;
				case 'K':
				case 'k':
					size *= 1024;
					p++;
			}

			/* Handle (possibly non-existent) address part */
			switch (*p) {
				case '@@':
					addr = strtoll(p + 1, NULL, 0);
					break;

				/* Adjust address if we don't need it */
				default:
					if (cmd.argv[i][0] == '=')
						addr = -1;
					else
						addr = 0;
			}

			if (addr == 0 || size == 0) {
				printf("bad language\n");
				return 0;
			} else {
				switch (cmd.argv[i][0]) {
				case '-':
					mem_delete(addr, addr + size);
					break;
				case '+':
					mem_add(addr, addr + size);
					break;
				case '=':
					mem_limit(size);
					break;
				default :
					printf("bad OP\n");
					return 0;
				}
			}
		}
	}

	dump_biosmem(NULL);

	return 0;
}

int
Xcomaddr(void)
{
	extern int com_addr;

	if (cmd.argc >= 2)
		com_addr = (int)strtol(cmd.argv[1], NULL, 0);

	return 0;
}
@


1.35
log
@Remove support for building the boot blocks with DEBUGFLAGS=-D_TEST, which is
supposed to create a userland binary in order to test non-boot related
functionality. This feature has been bitrotting in a non-compiling state
for years, and causes a too-many-ifdefs disease now that there are intrusive
EFI changes.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.34 2015/09/02 04:09:24 yasuoka Exp $	*/
d182 1
a182 1
			/* Handle (possibly non-existant) address part */
@


1.34
log
@Bring the boot changes on amd64 to i386.  alloca is deleted.
Also fix the boot from BIOS and bump the version.

input and ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.7 2015/09/02 01:52:26 yasuoka Exp $	*/
a74 1
#ifndef _TEST
a75 1
#endif
a93 1
#ifndef _TEST
a149 1
#endif
@


1.33
log
@

Allow uppercase "K/M/G" specification in "machine memory" boot command.

ok guenther, dlg, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.32 2012/10/30 14:06:29 jsing Exp $	*/
d41 3
d61 5
d93 3
d98 1
a98 1
	bios_diskinfo_t *bd = NULL;
d131 2
a132 2
	bd = bios_dklookup(dev);
	st = biosd_io(F_READ, bd, 0, 1, buf);
d153 1
@


1.32
log
@Apply a bunch of style(9) and whitespace fixes to i386/amd64 libsa, making
the code actually diffable. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.30 2010/07/02 00:36:52 weingart Exp $	*/
d163 1
d166 1
d169 1
@


1.31
log
@Add support for serial consoles at non-standard addresses.  This implements
a new "machine comaddr" command that makes it possible to configure the
io port used to access the serial port.  This can be used to use serial ports
on a puc(4) device as serial console.
@
text
@d161 1
a161 1
			switch(*p) {
d172 1
a172 1
			switch(*p) {
@


1.30
log
@Add ability to limit memory presented to kernel with
'machine memory =128M' style commands.  Thanks to
phessler for finding a small man page niggle.  Bumped
version strings to a nice round fraction, and make them
the same across the board.  Easier to identify boot
binary versions that way.

ok thib@@, tedu@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.29 2006/09/18 21:14:15 mpf Exp $	*/
d45 1
d55 1
d208 11
@


1.29
log
@boot(8) ``machine memory'' support for > 4G.
Convert parser to strtoll(3) and use 64bit printf.
With help from mickey@@
i386 and amd64 tests by me, alpha test by mickey@@
OK mickey@@, miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.28 2004/03/09 19:12:12 tom Exp $	*/
d158 26
a183 5
			if (*p && *p == '@@')
				addr = strtoll(p + 1, NULL, 0);
			else
				addr = 0;
			if (addr == 0 && (*p != '@@' || size == 0)) {
d193 3
@


1.28
log
@Spacing and KNF.  Partly from Joris Vink <nimadeus at pandora dot be>.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.27 2003/08/11 06:23:09 deraadt Exp $	*/
d153 1
a153 1
			long addr, size;
d157 1
a157 1
			size = strtol(p + 1, &p, 0);
d159 1
a159 1
				addr = strtol(p + 1, NULL, 0);
@


1.27
log
@ansification and knf and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.26 2003/06/03 20:22:11 mickey Exp $	*/
d17 2
a18 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
d53 3
a55 3
	{ "boot",     CMDT_CMD, Xboot },
	{ "diskinfo", CMDT_CMD, Xdiskinfo },
	{ "memory",   CMDT_CMD, Xmemory },
d57 1
a57 1
	{ "regs",     CMDT_CMD, Xregs },
d88 1
a88 1
	if(cmd.argc != 2) {
d91 1
a91 1
			" and [abcd] is the partition.\n");
d96 1
a96 1
	if(cmd.argv[1][0] != 'f' && cmd.argv[1][0] != 'h')
d98 1
a98 1
	if(cmd.argv[1][1] != 'd')
d100 1
a100 1
	if(cmd.argv[1][2] < '0' || cmd.argv[1][2] > '3')
d102 2
a103 1
	if((cmd.argv[1][3] < 'a' || cmd.argv[1][3] > 'd') && cmd.argv[1][3] != '\0')
d120 2
a121 1
	if(st) goto bad;
d124 1
a124 1
	if((dev & 0x80) && (part > 0)){
d127 2
a128 2
		for(i = 0, j = DOSPARTOFF; i < 4; i++, j += 16)
			if(part == i)
d163 1
a163 1
				printf ("bad language\n");
d174 1
a174 1
					printf ("bad OP\n");
@


1.26
log
@three four kills
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.25 2003/05/31 00:15:29 weingart Exp $	*/
d63 1
a63 1
Xdiskinfo()
d73 1
a73 1
Xregs()
d81 1
a81 1
Xboot()
d143 1
a143 1
Xmemory()
@


1.25
log
@First lba support in /boot.  Not complete lba boot support, but it's the
first step on the way there.  Ok deraadt@@, espie@@, todd@@, and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.24 2002/03/14 03:15:54 millert Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.24
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.23 2002/03/14 01:26:34 millert Exp $	*/
d90 1
d122 2
a123 1
	st = biosd_io(F_READ, dev, 0, 0, 0, 1, buf);
@


1.23
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.22 1999/08/25 00:54:19 mickey Exp $	*/
d55 1
a55 1
int bootbuf(void*, int);
d90 1
a90 1
	char buf[DEV_BSIZE], *dest = (void*)BOOTBIOS_ADDR;
@


1.22
log
@give better support to the bios memory maps.
provide memory maps editing through the machine memory command.
rearrange probing in machdep, so it provides less output,
also giving a shot for apm to fix the memory maps.
changes to kernel are minimal, only that is required due
to the api version bits addition and such cosmetic changes.
tested on all critical kernel,boot combinations; niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.21 1998/05/25 19:20:51 mickey Exp $	*/
d49 4
a52 4
int Xboot __P((void));
int Xdiskinfo __P((void));
int Xmemory __P((void));
int Xregs __P((void));
d55 1
a55 1
int bootbuf __P((void*, int));
@


1.22.14.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.22 1999/08/25 00:54:19 mickey Exp $	*/
d49 4
a52 4
int Xboot(void);
int Xdiskinfo(void);
int Xmemory(void);
int Xregs(void);
d55 1
a55 1
int bootbuf(void *, int);
d90 1
a90 1
	char buf[DEV_BSIZE], *dest = (void *)BOOTBIOS_ADDR;
@


1.22.4.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 4
a52 4
int Xboot(void);
int Xdiskinfo(void);
int Xmemory(void);
int Xregs(void);
d55 1
a55 1
int bootbuf(void *, int);
d90 1
a90 1
	char buf[DEV_BSIZE], *dest = (void *)BOOTBIOS_ADDR;
@


1.22.4.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.22.4.1 2002/03/28 10:31:05 niklas Exp $	*/
d16 5
a89 1
	bios_diskinfo_t *bd = NULL;
d121 1
a121 2
	bd = bios_dklookup(dev);
	st = biosd_io(F_READ, bd, 0, 1, buf);
@


1.22.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 1
a63 1
Xdiskinfo(void)
d73 1
a73 1
Xregs(void)
d81 1
a81 1
Xboot(void)
d143 1
a143 1
Xmemory(void)
@


1.22.4.4
log
@Merge with the trunk
@
text
@d17 2
a18 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
d53 3
a55 3
	{ "boot",	CMDT_CMD, Xboot },
	{ "diskinfo",	CMDT_CMD, Xdiskinfo },
	{ "memory",	CMDT_CMD, Xmemory },
d57 1
a57 1
	{ "regs",	CMDT_CMD, Xregs },
d88 1
a88 1
	if (cmd.argc != 2) {
d91 1
a91 1
		    " and [abcd] is the partition.\n");
d96 1
a96 1
	if (cmd.argv[1][0] != 'f' && cmd.argv[1][0] != 'h')
d98 1
a98 1
	if (cmd.argv[1][1] != 'd')
d100 1
a100 1
	if (cmd.argv[1][2] < '0' || cmd.argv[1][2] > '3')
d102 1
a102 2
	if ((cmd.argv[1][3] < 'a' || cmd.argv[1][3] > 'd') &&
	    cmd.argv[1][3] != '\0')
d119 1
a119 2
	if (st)
		goto bad;
d122 1
a122 1
	if ((dev & 0x80) && (part > 0)){
d125 2
a126 2
		for (i = 0, j = DOSPARTOFF; i < 4; i++, j += 16)
			if (part == i)
d161 1
a161 1
				printf("bad language\n");
d172 1
a172 1
					printf("bad OP\n");
@


1.21
log
@put support for test /boot environment back; some CLEANFILES and spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.20 1998/02/24 22:06:47 weingart Exp $	*/
d4 2
a5 1
 * Copyright (c) 1997 Michael Shalayeff, Tobias Weingartner
a35 1
#ifndef _TEST
d49 4
a52 6
static int Xboot __P((void));
static int Xdiskinfo __P((void));
static int Xmemory __P((void));
static int Xregs __P((void));
static int Xcnvmem __P((void));
static int Xextmem __P((void));
d61 1
d63 1
a63 2
	{ "cnvmem",   CMDT_CMD, Xcnvmem},
	{ "extmem",   CMDT_CMD, Xextmem},
d67 1
a67 26

/* Set size of conventional ram */
static int
Xcnvmem()
{
	if (cmd.argc != 2)
		printf("cnvmem %d\n", cnvmem);
	else
		cnvmem = strtol(cmd.argv[1], NULL, 0);

	return 0;
}

/* Set size of extended ram */
static int
Xextmem()
{
	if (cmd.argc != 2)
		printf("extmem %d\n", extmem);
	else
		extmem = strtol(cmd.argv[1], NULL, 0);

	return 0;
}

static int
d70 1
d72 1
a72 1

d76 2
a77 1
static int
d83 1
d85 1
a85 1
static int
d88 1
d90 1
a90 1
	char buf[DEV_BSIZE], *dest = (void*)0x7c00;
d141 1
d145 1
a145 1
static int
d148 32
a179 9
	bios_memmap_t *tm = memory_map;
	int count, total = 0;

	for(count = 0; tm[count].type != BIOS_MAP_END; count++){
		printf("Region %d: type %u at 0x%lx for %luKB\n", count,
			tm[count].type, (long)tm[count].addr, (long)tm[count].size);

		if(tm[count].type == BIOS_MAP_FREE)
			total += tm[count].size;
d182 1
a182 2
	printf("Low ram: %dKB  High ram: %dKB\n", cnvmem, extmem);
	printf("Total free memory: %dKB\n", total);
a185 1
#endif
@


1.20
log
@Changes/updates to /boot stuff.  More to come.
Fixes many divide by zero and pointer bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.19 1997/11/30 21:51:41 mickey Exp $	*/
d35 1
d64 2
a65 2
	{"cnvmem",    CMDT_CMD, Xcnvmem},
	{"extmem",    CMDT_CMD, Xextmem},
d186 1
@


1.19
log
@big diskinfo changes from toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.18 1997/10/25 02:07:09 weingart Exp $	*/
d45 4
d50 1
d52 2
a53 2
static int Xboot __P((void));
static int Xmemory __P((void));
d56 1
a56 1
int bootbuf __P((int, int));
d59 1
d61 1
d63 2
a64 2
	{ "boot",     CMDT_CMD, Xboot },
	{ "memory",   CMDT_CMD, Xmemory },
d68 25
d112 1
a112 1
	char *buf = (void *)0x7c00;
d115 3
a117 1
		printf("machine boot {fd,hd}[0123][abcd]\n");
d128 1
a128 1
	if(cmd.argv[1][3] < 'a' || cmd.argv[1][3] > 'd')
d137 4
a140 1
	printf("[%x,%d]\n", dev, part);
d143 1
a143 1
	st = biosd_io(F_READ, dev, 0, 0, 1, 1, buf);
d147 1
a147 1
	if(dev & 0x80){
d152 1
a152 1
				buf[j] = 0x80;
d154 1
a154 1
				buf[j] = 0x00;
a156 2
	printf("%x %x %x %x %x\n", buf[0], buf[1], buf[2], buf[3], buf[4]);

d158 2
a159 1
	bootbuf(dev, part);
@


1.18
log
@Fix disk probe.  Get rid of EDD check, it goes haywire on
some machines.  Thinkpad 760ED is one of them.  IBM/MS
extention, and IBM does not support it.  Nice.
Add some more debug statements for BIOS_DEBUG.
Init EDD flags to "not supported" for now.

Change 'machine memory' back to display the type of each
range it displays.

Testing by todd@@ (thanks).
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.17 1997/10/24 22:22:56 mickey Exp $	*/
d36 2
d39 1
a39 1
#include <machine/biosvar.h>
d64 1
a64 15
	int i;

	printf(
	    "Disk\tBIOS#\tBSD#\t\tCyls\tHeads\tSecs\tFlags\tChecksum(%d)\n",
	    bios_cksumlen);
	for(i = 0; bios_diskinfo[i].bios_number != -1 && i < 10; i++){
		int d = bios_diskinfo[i].bios_number;

		printf(
		    "%cd%d\t0x%x\t0x%x\t%d\t%d\t%d\t0x%x\t0x%x\n",
		    (d & 0x80)?'h':'f', (d & 0x80)?d - 128:d, d,
		    bios_diskinfo[i].bsd_dev, bios_diskinfo[i].bios_cylinders,
		    bios_diskinfo[i].bios_heads, bios_diskinfo[i].bios_sectors,
		    bios_diskinfo[i].flags, bios_diskinfo[i].checksum);
	}
@


1.17
log
@checksumming stuff from niklas
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.16 1997/10/23 15:13:27 weingart Exp $	*/
d142 1
a142 1
int
d146 5
a150 1
	int total = 0;
d152 2
a153 5
	printf ("Map:");
	for(; tm->type != BIOS_MAP_END; tm++){
		printf(" [%luK]@@0x%lx", (long)tm->size, (long)tm->addr);
		if(tm->type == BIOS_MAP_FREE)
			total += tm->size;
d156 2
a157 1
	printf("\nTotal: %uK, Low: %uK, High: %uK\n", total, cnvmem, extmem);
@


1.16
log
@Better BIOS diskprobe.  Cleanup and re-org by mickey.
Fix bug in BIOS memprobe.  Cleanup and re-org by mickey.
Do checksum of HD devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.15 1997/10/22 23:34:37 mickey Exp $	*/
d64 3
a66 1
	printf("Disk\tBIOS#\t    BSD#\tCylinders\tHeads\tSectors\tChecksum\n");
d70 6
a75 8
		printf("%cd%d\t 0x%x\t0x%x\t %s%d   \t%d\t%d\t0x%x[%d]\n",
			(d & 0x80)?'h':'f', (d & 0x80)?d - 128:d, d,
			bios_diskinfo[i].bsd_dev,
			(bios_diskinfo[i].bios_cylinders < 100)?"  ":" ",
			bios_diskinfo[i].bios_cylinders,
			bios_diskinfo[i].bios_heads,
			bios_diskinfo[i].bios_sectors,
			bios_diskinfo[i].checksum, bios_diskinfo[i].checklen);
@


1.15
log
@newer, better stuff; some parts by toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.14 1997/10/21 02:42:31 mickey Exp $	*/
d64 1
a64 1
	printf("Disk\tBIOS#\t    BSD#\tCylinders\tHeads\tSectors\n");
d68 1
a68 1
		printf("%cd%d\t 0x%x\t0x%x\t %s%d   \t%d\t%d\n",
d74 2
a75 1
			bios_diskinfo[i].bios_sectors);
@


1.14
log
@temp fix, sorry
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.13 1997/10/20 14:56:09 mickey Exp $	*/
a50 6
/* From probedisk.c */
extern bios_diskinfo_t bios_diskinfo[];

/* From probemem.c */
extern bios_memmap_t *memory_map;

d117 1
a117 1
	st = biosd_rw(F_READ, dev, 0, 0, 1, 1, buf);
@


1.13
log
@even better memprobe
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.12 1997/10/20 14:47:42 mickey Exp $	*/
d123 1
a123 1
	st = biosd_io(F_READ, dev, 0, 0, 1, 1, buf);
@


1.12
log
@get ready for the fix in memprobe
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.11 1997/10/17 18:46:55 weingart Exp $	*/
d70 1
a70 1
	printf("Disk\tBIOS#\tCylinders\tHeads\tSectors\n");
d74 1
a74 1
		printf("%cd%d\t 0x%x\t %s%d   \t%d\t%d\n",
d76 1
d123 1
a123 1
	st = biosd_rw(F_READ, dev, 0, 0, 1, 1, buf);
d151 1
a151 1
	int count, total = 0;
d153 5
a157 6
	for(count = 0; tm[count].type != BIOS_MAP_END; count++){
		printf("Region %d: type %u at 0x%lx for %luKB\n", count,
			tm[count].type, (long)tm[count].addr, (long)tm[count].size/1024);

		if(tm[count].type == BIOS_MAP_FREE)
			total += tm[count].size;
d160 1
a160 2
	printf("Low ram: %dKB  High ram: %dKB\n", cnvmem, extmem);
	printf("Total free memory: %dKB\n", total/1024);
a163 1

@


1.11
log
@Cleanup, make it all compile.
Move APM stuff to apmprobe.c
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.10 1997/10/17 15:03:23 weingart Exp $	*/
d153 2
a154 2
		printf("Region %d: type %u at 0x%x for %uKB\n", count,
			tm[count].type, tm[count].addr, tm[count].size/1024);
@


1.10
log
@Use BIOS to probe for memory map.
Probe for BIOS supported disks.
Use BIOS to get geometry for supported disks.

All in preparation to passing the whole thing
to the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.9 1997/10/09 22:23:00 deraadt Exp $	*/
d54 2
d149 1
a149 1
	struct BIOS_MAP *tm = memory_map;
@


1.9
log
@Heads... not Tracks
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.8 1997/10/02 04:30:23 mickey Exp $	*/
d36 1
d45 9
d58 2
a65 1
	u_int32_t di;
d68 10
a77 5
	printf("Disk\tCylinders\tHeads\tSectors\n");
	for(i = 0x80; i < 0x84; i++){
		if ((di = biosdinfo(i)))
			printf("0x%x\t  %d   \t%d\t%d\n", i,
			       BIOSNTRACKS(di), BIOSNHEADS(di), BIOSNSECTS(di));
d89 75
@


1.8
log
@better 'machine di' table; toddf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.7 1997/09/26 18:07:12 mickey Exp $	*/
d57 1
a57 1
	printf("Disk\tCylinders\tTracks\tSectors\n");
@


1.7
log
@nice diskinfo; terms consistancy by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.6 1997/09/17 19:55:36 mickey Exp $	*/
d57 1
a57 1
	printf("Disk\tCylinders  Tracks\tSectors\n");
d60 1
a60 1
			printf("0x%02x\t%9d  %d\t%d\n", i,
@


1.6
log
@regs command is MD
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.5 1997/09/03 04:32:44 weingart Exp $	*/
d57 1
d60 2
a61 2
			printf("\tDisk 0x%x => Tracks %d, Heads %d, Sectors %d\n",
				i, BIOSNTRACKS(di), BIOSNHEADS(di), BIOSNSECTS(di));
@


1.5
log
@1st part of pretty "machine diskinfo" stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.4 1997/09/02 23:06:55 mickey Exp $	*/
d37 1
d43 1
d47 1
d66 6
@


1.4
log
@change biosdinfo() to return fail value. use fake geo, where needed
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.3 1997/09/02 22:43:17 weingart Exp $	*/
d51 1
a51 1
	u_int16_t di;
d54 4
a57 4
	for(i = 0x80; i < 0x85; i++){
		if (!(di = biosdinfo(i)))
			printf("\tDisk 0x%x => Heads %d, Sectors %d\n",
			       i, BIOSNHEADS(di), BIOSNSECTS(di));
@


1.3
log
@Pretty.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.2 1997/09/02 22:42:26 weingart Exp $	*/
d55 3
a57 3
		di = biosdinfo(i);
		printf("\tDisk 0x%x => Heads %d, Sectors %d\n",
			i, BIOSNHEADS(di), BIOSNSECTS(di));
@


1.2
log
@Add "machine diskinfo" command.  Needs work.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd_i386.c,v 1.1 1997/09/02 20:58:15 mickey Exp $	*/
d56 1
a56 1
		printf("\t0x%x => Heads %d, Sectors %d\n",
@


1.1
log
@machine diskinfo command, toby is filling w/ meat at the moment
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 2
d51 9
@

