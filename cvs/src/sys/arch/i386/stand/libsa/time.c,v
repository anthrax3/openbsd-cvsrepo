head	1.19;
access;
symbols
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.12
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.8
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.4
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.8
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.4
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.16.0.34
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.32
	OPENBSD_5_0:1.16.0.30
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.28
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.26
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.22
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.24
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.20
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.18
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.16
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.14
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.12
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.10
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.8
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.6
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.24
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.22
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.20
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.12.0.18
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.16
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.14
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.12.0.12
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.10
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.8
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.6
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.19
date	2014.09.23.17.59.25;	author brad;	state Exp;
branches;
next	1.18;
commitid	Vgs4iHSTU7s64ljY;

1.18
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2012.10.30.14.06.29;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.17.15.11.31;	author tom;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.09.19.12.13;	author tom;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.11.06.23.09;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.03.20.22.12;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	98.05.30.01.53.44;	author mickey;	state Exp;
branches
	1.12.8.1;
next	1.11;

1.11
date	98.04.18.07.39.57;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.10.12.21.04.23;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.09.02.20.51.21;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.08.31.07.54.18;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.08.12.23.39.58;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.08.12.19.05.55;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.07.17.23.00.27;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.07.08.03.41.00;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.05.31.15.36.41;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	97.04.29.00.16.13;	author mickey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	97.04.28.07.39.01;	author weingart;	state Exp;
branches;
next	;

1.2.2.1
date	97.06.01.09.53.10;	author deraadt;	state Exp;
branches;
next	;

1.12.8.1
date	2003.06.07.11.11.38;	author ho;	state Exp;
branches;
next	1.12.8.2;

1.12.8.2
date	2004.02.19.10.48.43;	author niklas;	state Exp;
branches;
next	1.12.8.3;

1.12.8.3
date	2004.06.05.23.09.01;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Fix constraint.

We need a register here, and not a generic memory reference.  We get lucky
with GCC that it chooses a register for "p", but we can't blame clang for
choosing a memory reference if we allow it to do so.

Pointed out by LLVM.

time.c:80:17: error: unexpected token in memory operand

ok kettenis@@
@
text
@/*	$OpenBSD: time.c,v 1.18 2014/03/29 18:09:29 guenther Exp $	*/

/*
 * Copyright (c) 1997 Michael Shalayeff
 * Copyright (c) 1997 Tobias Weingartner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/time.h>
#include <machine/biosvar.h>
#include <machine/pio.h>
#include "libsa.h"
#include "biosdev.h"

#define isleap(y) ((((y) % 4) == 0 && ((y) % 100) != 0) || ((y) % 400) == 0)

/*
 * Convert from bcd (packed) to int
 */
static __inline u_int8_t
bcdtoint(u_int8_t c)
{
	return ((c & 0xf0) / 8) * 5 + (c & 0x0f);
}

/*
 * Quick compute of time in seconds since the Epoch
 */
const u_short monthcount[] = {
	0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
};

static __inline time_t
compute(int year, u_int8_t month, u_int8_t day, u_int8_t hour,
    u_int8_t min, u_int8_t sec)
{
	/* Number of days per month */
	register time_t tt;

	/* Compute days */
	tt = (year - 1970) * 365 + monthcount[month] + day - 1;

	/* Compute for leap year */
	for (month <= 2 ? year-- : 0; year >= 1970; year--)
		if (isleap(year))
			tt++;

	/* Plus the time */
	tt = sec + 60 * (min + 60 * (tt * 24 + hour));

	return tt;
}

static int
bios_time_date(int f, u_int8_t *b)
{
	__asm volatile(DOINT(0x1a) "\n\t"
	    "setc %b0\n\t"
	    "movb %%ch, 0(%2)\n\t"
	    "movb %%cl, 1(%2)\n\t"
	    "movb %%dh, 2(%2)\n\t"
	    "movb %%dl, 3(%2)\n\t"
	    : "=a" (f)
	    : "0" (f), "r" (b) : "%ecx", "%edx", "cc");

	if (f & 0xff)
		return -1;
	else {
		b[0] = bcdtoint(b[0]);
		b[1] = bcdtoint(b[1]);
		b[2] = bcdtoint(b[2]);
		b[3] = bcdtoint(b[3]);
		return 0;
	}
}

static __inline int
biosdate(u_int8_t *b)
{
	return bios_time_date(4 << 8, b);
}

static __inline int
biostime(u_int8_t *b)
{
	return bios_time_date(2 << 8, b);
}

/*
 * Return time since epoch
 */
time_t
getsecs(void)
{
	u_int8_t timebuf[4], datebuf[4];

	/* Query BIOS for time & date */
	if (!biostime(timebuf) && !biosdate(datebuf)) {
#ifdef notdef
		int dst;

		dst = timebuf[3];
#endif
		/* Convert to seconds since Epoch */
		return compute(datebuf[0] * 100 + datebuf[1], datebuf[2],
		    datebuf[3], timebuf[0], timebuf[1], timebuf[2]);
	} else
		errno = EIO;

	return 1;
}

u_int
sleep(u_int i)
{
	register time_t t;

	/*
	 * Loop for the requested number of seconds, polling BIOS,
	 * so that it may handle interrupts.
	 */
	for (t = getsecs() + i; getsecs() < t; cnischar())
		;

	return 0;
}
@


1.18
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.17 2012/10/30 14:06:29 jsing Exp $	*/
d86 1
a86 1
	    : "0" (f), "p" (b) : "%ecx", "%edx", "cc");
@


1.17
log
@Apply a bunch of style(9) and whitespace fixes to i386/amd64 libsa, making
the code actually diffable. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.15 2004/03/09 19:12:13 tom Exp $	*/
d79 1
a79 1
	__asm __volatile(DOINT(0x1a) "\n\t"
@


1.16
log
@Calculate time_t correctly from (day, month, year): 1/1/70 is 0, not 1.

ok deraadt@@
@
text
@a44 1

d87 1
d127 2
a128 3
		return (compute(datebuf[0] * 100 + datebuf[1],
		    datebuf[2], datebuf[3],
		    timebuf[0], timebuf[1], timebuf[2]));
d144 2
a145 1
	for (t = getsecs() + i; getsecs() < t; cnischar());
@


1.15
log
@Spacing and KNF.  Partly from Joris Vink <nimadeus at pandora dot be>.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.14 2003/08/11 06:23:09 deraadt Exp $	*/
d64 1
a64 1
	tt = (year - 1970) * 365 + monthcount[month] + day;
@


1.14
log
@ansification and knf and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.13 2003/06/03 20:22:12 mickey Exp $	*/
d53 1
a53 2
	0, 0, 31, 59, 90, 120, 151, 181,
	212, 243, 273, 304, 334, 365
d67 2
a68 2
	for(month <= 2? year--:0;year >= 1970;year--)
		if(isleap(year))
d81 7
a87 7
		       "setc %b0\n\t"
		       "movb %%ch, 0(%2)\n\t"
		       "movb %%cl, 1(%2)\n\t"
		       "movb %%dh, 2(%2)\n\t"
		       "movb %%dl, 3(%2)\n\t"
		       : "=a" (f)
		       : "0" (f), "p" (b) : "%ecx", "%edx", "cc");
d120 1
a120 1
	if(!biostime(timebuf) && !biosdate(datebuf)) {
d127 3
a129 3
		return compute(datebuf[0] * 100 + datebuf[1],
			       datebuf[2], datebuf[3],
			       timebuf[0], timebuf[1], timebuf[2]);
d133 1
a133 1
	return(1);
d141 4
a144 2
	/* loop for that number of seconds, polling BIOS,
	   so that it may handle interrupts */
@


1.13
log
@three four kills
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.12 1998/05/30 01:53:44 mickey Exp $	*/
d43 1
a43 2
bcdtoint(c)
	register u_int8_t c;
d56 1
d58 2
a59 3
compute(year, month, day, hour, min, sec)
	int year;
	u_int8_t month, day, hour, min, sec;
d79 1
a79 3
bios_time_date(f, b)
	int f;
	register u_int8_t *b;
d101 1
a101 2
biosdate(b)
	register u_int8_t *b;
d107 1
a107 2
biostime(b)
	register u_int8_t *b;
d138 1
a138 2
sleep(i)
	u_int i;
@


1.12
log
@kill the hack!
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.11 1998/04/18 07:39:57 deraadt Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Tobias Weingartner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.12.8.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.12 1998/05/30 01:53:44 mickey Exp $	*/
d16 5
@


1.12.8.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 2
a44 1
bcdtoint(u_int8_t c)
a56 1

d58 3
a60 2
compute(int year, u_int8_t month, u_int8_t day, u_int8_t hour,
    u_int8_t min, u_int8_t sec)
d80 3
a82 1
bios_time_date(int f, u_int8_t *b)
d104 2
a105 1
biosdate(u_int8_t *b)
d111 2
a112 1
biostime(u_int8_t *b)
d143 2
a144 1
sleep(u_int i)
@


1.12.8.3
log
@Merge with the trunk
@
text
@d53 2
a54 1
	0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
d68 2
a69 2
	for (month <= 2 ? year-- : 0; year >= 1970; year--)
		if (isleap(year))
d82 7
a88 7
	    "setc %b0\n\t"
	    "movb %%ch, 0(%2)\n\t"
	    "movb %%cl, 1(%2)\n\t"
	    "movb %%dh, 2(%2)\n\t"
	    "movb %%dl, 3(%2)\n\t"
	    : "=a" (f)
	    : "0" (f), "p" (b) : "%ecx", "%edx", "cc");
d121 1
a121 1
	if (!biostime(timebuf) && !biosdate(datebuf)) {
d128 3
a130 3
		return (compute(datebuf[0] * 100 + datebuf[1],
		    datebuf[2], datebuf[3],
		    timebuf[0], timebuf[1], timebuf[2]));
d134 1
a134 1
	return 1;
d142 2
a143 4
	/*
	 * Loop for the requested number of seconds, polling BIOS,
	 * so that it may handle interrupts.
	 */
@


1.11
log
@i386 bootblocks that work for 2.3. A tale too long to tell
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.10 1997/10/12 21:04:23 mickey Exp $	*/
a144 25
}

/*
 * Return time since epoch
 */
void
time_print(void)
{
	u_int8_t timebuf[4], datebuf[4];

	/* Query BIOS for time & date */
	if(!biostime(timebuf) && !biosdate(datebuf)) {
#ifdef notdef
		int dst;

		dst = timebuf[3];
#endif
		/* Convert to sane values */
		printf("%d/%d/%d - %d:%d:%d\n",
		       datebuf[3], datebuf[2], datebuf[0] * 100 + datebuf[1],
		       timebuf[0], timebuf[1], timebuf[2]);
	} else
		printf("no idea (in BIOS)\n");

	return;
@


1.10
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.9 1997/09/02 20:51:21 mickey Exp $	*/
d58 4
a67 4
	static const u_short monthcount[] = {
		0, 0, 31, 59, 90, 120, 151, 181,
		212, 243, 273, 304, 334, 365
	};
@


1.9
log
@debug last consistency ci
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.8 1997/08/31 07:54:18 mickey Exp $	*/
d48 3
a50 1
bcdtoint(register u_int8_t c) {
d85 3
a87 1
bios_time_date(int f, register u_int8_t *b)
d109 2
a110 1
biosdate(register u_int8_t *b)
d116 2
a117 1
biostime(register u_int8_t *b)
@


1.8
log
@consistency
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.7 1997/08/12 23:39:58 mickey Exp $	*/
d87 4
a90 4
		       "movb %%ch, 0(%1)\n\t"
		       "movb %%cl, 1(%1)\n\t"
		       "movb %%dh, 2(%1)\n\t"
		       "movb %%dl, 3(%1)\n\t"
@


1.7
log
@poll BIOS as said in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.6 1997/08/12 19:05:55 mickey Exp $	*/
d92 1
a92 1
		       : "p" (b), "0" (f) : "%ecx", "%edx", "cc");
@


1.6
log
@move that inline
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.5 1997/07/17 23:00:27 mickey Exp $	*/
d174 1
a174 1
	for (t = getsecs() + i; getsecs() < t; );
@


1.5
log
@proper includes
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.4 1997/07/08 03:41:00 mickey Exp $	*/
d4 1
d37 2
d47 2
a48 2
static int
bcdtoint(register char c){
d50 1
a50 1
	return ((c & 0xf0) >> 4) * 10 + (c & 0x0f);
a52 6
/* Number of days per month */
static char monthcount[] = {
	31, 28, 31, 30, 31, 30, 31,
	31, 30, 31, 30, 31, 30, 31
};

d56 10
a65 2
static time_t
compute(int year, int month, int day, int hour, int min, int sec) {
a66 1
	register int i;
d68 2
a69 6
	/* Compute years of seconds */
	tt = (year - 1970) * (365 * 24 * 60 * 60);

	/* Compute days of seconds */
	for(i = 1; i < month; i++)
		day += monthcount[i];
d72 3
a74 4
	for(i = 1970; i < year; i++)
		if(isleap(i))
			day++;
	tt += day * (24 * 60 * 60);
d77 1
a77 1
	tt += sec + 60 * (min + 60 * hour);
d82 33
d120 3
a122 3
getsecs(void) {

	char timebuf[4], datebuf[4];
d129 1
a129 1
		dst = bcdtoint(timebuf[3]);
d132 3
a134 4
		return compute(bcdtoint(datebuf[0])*100 + bcdtoint(datebuf[1]),
			       bcdtoint(datebuf[2]), bcdtoint(datebuf[3]),
			       bcdtoint(timebuf[0]), bcdtoint(timebuf[1]),
			       bcdtoint(timebuf[2]));
a140 1

d145 3
a147 2
time_print(void) {
	char timebuf[4], datebuf[4];
d154 1
a154 1
		dst = bcdtoint(timebuf[3]);
d158 2
a159 4
		       bcdtoint(datebuf[3]), bcdtoint(datebuf[2]),
		       bcdtoint(datebuf[0]) * 100 + bcdtoint(datebuf[1]),
		       bcdtoint(timebuf[0]), bcdtoint(timebuf[1]),
		       bcdtoint(timebuf[2]));
d161 1
a161 1
		printf("Error in biostime() or biosdate().\n");
d174 1
a174 1
	for (t = getsecs() + i; getsecs() < t; ischar());
@


1.4
log
@optimize
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.3 1997/05/31 15:36:41 mickey Exp $	*/
a34 1
#include <libsa.h>
d36 1
@


1.3
log
@add sleep(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.2 1997/04/29 00:16:13 mickey Exp $	*/
a40 1

d44 2
a45 7
static int bcdtoint(char c){
	int tens;
	int ones;

	tens = (c & 0xf0) >> 4;
	tens *= 10;
	ones = c & 0x0f;
d47 1
a47 1
	return (tens + ones);
a49 1

d51 1
a51 1
static int monthcount[] = {
d60 3
a62 3
compute(int year, int month, int day, int hour, int min, int sec){
	int yearsec, daysec, timesec;
	int i;
d65 1
a65 2
	yearsec = year - 1970;
	yearsec *= (365 * 24 * 60 * 60);
d68 2
a69 5
	daysec = 0;
	for(i = 1; i < month; i++){
		daysec += monthcount[i];
	}
	daysec += day;
d72 1
a72 1
	for(i = 1970; i < year; i++){
d74 2
a75 3
			daysec += 1;
	}
	daysec *= (24 * 60 * 60);
d78 1
a78 3
	timesec = sec;
	timesec += (min * 60);
	timesec += (hour * 60 * 60);
d80 1
a80 2
	/* Return sum */
	return (yearsec + daysec + timesec);
d87 3
a89 1
time_t getsecs(void){
a90 2
	int st1, st2;
	time_t tt = 0;
d93 2
a94 7
	st1 = biostime(timebuf);
	st2 = biosdate(datebuf);

	/* Convert to seconds since Epoch */
	if(!st1 && !st2){
		int year, month, day;
		int hour, min, sec;
a97 12
		sec = bcdtoint(timebuf[2]);
		min = bcdtoint(timebuf[1]);
		hour = bcdtoint(timebuf[0]);

		year = bcdtoint(datebuf[0]);
		year *= 100;
		year += bcdtoint(datebuf[1]);
		month = bcdtoint(datebuf[2]);
		day = bcdtoint(datebuf[3]);
#ifdef notdef
		printf("%d/%d/%d - %d:%d:%d\n",
		       day, month, year, hour, min, sec);
d99 7
a105 3
		tt = compute(year, month, day, hour, min, sec);
		return(tt);
	}
d114 2
a115 1
void time_print(void){
a116 1
	int st1, st2;
d119 2
a120 7
	st1 = biostime(timebuf);
	st2 = biosdate(datebuf);

	/* Convert to sane values */
	if (!st1 && !st2) {
		int year, month, day;
		int hour, min, sec;
d124 7
a130 12
		sec = bcdtoint(timebuf[2]);
		min = bcdtoint(timebuf[1]);
		hour = bcdtoint(timebuf[0]);

		year = bcdtoint(datebuf[0]);
		year *= 100;
		year += bcdtoint(datebuf[1]);
		month = bcdtoint(datebuf[2]);
		day = bcdtoint(datebuf[3]);

		printf("%d/%d/%d - %d:%d:%d\n", day, month, year, hour, min, sec);

d145 1
a145 1
	for (t = getsecs(); (getsecs() - t) < i; ischar());
@


1.2
log
@ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.1 1997/04/28 07:39:01 weingart Exp $	*/
d127 4
a130 3

		printf("%d/%d/%d - %d:%d:%d\n", day, month, year, hour, min, sec);

d175 12
@


1.2.2.1
log
@2.1 laptop kbd fixes from mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: time.c,v 1.3 1997/05/31 15:36:41 mickey Exp $	*/
d127 3
a129 4
#ifdef notdef
		printf("%d/%d/%d - %d:%d:%d\n",
		       day, month, year, hour, min, sec);
#endif
a173 12
u_int
sleep(i)
	u_int i;
{
	register time_t t;

	/* loop for that number of seconds, polling BIOS,
	   so that it may handle interrupts */
	for (t = getsecs(); (getsecs() - t) < i; ischar());

	return 0;
}
@


1.1
log
@Add getsecs().  Use biostime & biosdate routines.
Parse and convert to seconds since epoch.  Please
test, there is a new command "time", which should
print the current time (according to the BIOS) on
the console.
@
text
@d1 33
a33 1
/* $OpenBSD$ */
@
