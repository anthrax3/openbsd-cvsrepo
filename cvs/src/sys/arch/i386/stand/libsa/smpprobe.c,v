head	1.6;
access;
symbols
	OPENBSD_6_0:1.6.0.52
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.48
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.50
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.42
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.46
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.44
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.40
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.38
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.36
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.34
	OPENBSD_5_0:1.6.0.32
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.30
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.28
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.24
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.26
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.22
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.20
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.18
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.16
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.14
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.12
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.24
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.22
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.20
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.18
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.16
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.14
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.12
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.10
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.8
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.6
date	2004.03.09.19.12.13;	author tom;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.11.06.23.09;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.04.17.04.05;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.09.27.17.42.07;	author mickey;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	98.04.18.07.39.55;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	98.02.24.22.07.46;	author weingart;	state Exp;
branches;
next	;

1.3.8.1
date	2000.02.19.17.53.11;	author niklas;	state Exp;
branches;
next	1.3.8.2;

1.3.8.2
date	2000.02.20.10.27.56;	author niklas;	state Exp;
branches;
next	1.3.8.3;

1.3.8.3
date	2003.06.07.11.11.38;	author ho;	state Exp;
branches;
next	1.3.8.4;

1.3.8.4
date	2004.02.19.10.48.43;	author niklas;	state Exp;
branches;
next	1.3.8.5;

1.3.8.5
date	2004.06.05.23.09.01;	author niklas;	state Exp;
branches;
next	1.3.8.6;

1.3.8.6
date	2004.06.08.21.14.50;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Spacing and KNF.  Partly from Joris Vink <nimadeus at pandora dot be>.

ok henning@@, deraadt@@
@
text
@/*	$OpenBSD: smpprobe.c,v 1.5 2003/08/11 06:23:09 deraadt Exp $	*/

/*
 * Copyright (c) 1997 Tobias Weingartner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <machine/biosvar.h>
#include "libsa.h"

extern int debug;

extern u_int cnvmem, extmem;
#define	MP_FLOAT_SIG	0x5F504D5F	/* _MP_ */
#define	MP_CONF_SIG	0x504D4350	/* PCMP */

typedef struct _mp_float {
	u_int32_t signature;
	u_int32_t conf_addr;
	u_int8_t length;
	u_int8_t spec_rev;
	u_int8_t checksum;
	u_int8_t feature[5];
} mp_float_t;


static __inline int
mp_checksum(u_int8_t *ptr, int len)
{
	register int i, sum = 0;

#ifdef DEBUG
	printf("Checksum %p for %d\n", ptr, len);
#endif

	for (i = 0; i < len; i++)
		sum += *(ptr + i);

	return (!(sum & 0xff));
}


static mp_float_t *
mp_probefloat(u_int8_t *ptr, int len)
{
	mp_float_t *mpp = NULL;
	int i;

#ifdef DEBUG
	if (debug)
		printf("Checking %p for %d\n", ptr, len);
#endif
	for (i = 0; i < 1024; i++) {
		mp_float_t *tmp = (mp_float_t*)(ptr + i);

		if (tmp->signature == MP_FLOAT_SIG) {
			printf("Found possible MP signature at: %p\n", ptr);

			mpp = tmp;
			break;
		}
		if ((tmp->signature == MP_FLOAT_SIG) &&
		    mp_checksum((u_int8_t *)tmp, tmp->length*16)) {
#ifdef DEBUG
			if (debug)
				printf("Found valid MP signature at: %p\n",
				    ptr);
#endif
			mpp = tmp;
			break;
		}
	}

	return mpp;
}


void
smpprobe(void)
{
	mp_float_t *mp = NULL;

	/* Check EBDA */
	if (!(mp = mp_probefloat((void *)((*((u_int32_t*)0x4e)) * 16), 1024)) &&
		/* Check BIOS ROM 0xE0000 - 0xFFFFF */
	    !(mp = mp_probefloat((void *)(0xE0000), 0x1FFFF)) &&
		/* Check last 1K of base RAM */
	    !(mp = mp_probefloat((void *)(cnvmem * 1024), 1024)) &&
		/* Check last 1K of extended RAM XXX */
	    !(mp = mp_probefloat((void *)(extmem * 1024 - 1024), 1024))) {
		/* No valid MP signature found */
#if DEBUG
		if (debug)
			printf("No valid MP signature found.\n");
#endif
		return;
	}

	/* Valid MP signature found */
	printf(" smp");

#if DEBUG
	if (debug)
		printf("Floating Structure:\n"
		    "\tSignature: %x\n"
		    "\tConfig at: %x\n"
		    "\tLength: %d\n"
		    "\tRev: 1.%d\n"
		    "\tFeature: %x %x %x %x %x\n",
		    mp->signature, mp->conf_addr, mp->length, mp->spec_rev,
		    mp->feature[0], mp->feature[1], mp->feature[2],
		    mp->feature[3], mp->feature[4]);
#endif
}
@


1.5
log
@ansification and knf and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: smpprobe.c,v 1.4 2003/06/04 17:04:05 deraadt Exp $	*/
d16 2
a17 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
d76 1
a76 1
	for(i = 0; i < 1024; i++){
d79 1
a79 1
		if(tmp->signature == MP_FLOAT_SIG){
d85 2
a86 2
		if((tmp->signature == MP_FLOAT_SIG) &&
			mp_checksum((u_int8_t *)tmp, tmp->length*16)){
d89 2
a90 1
				printf("Found valid MP signature at: %p\n", ptr);
d97 1
a97 1
	return (mpp);
d124 1
d128 8
a135 8
		"\tSignature: %x\n"
		"\tConfig at: %x\n"
		"\tLength: %d\n"
		"\tRev: 1.%d\n"
		"\tFeature: %x %x %x %x %x\n",
		mp->signature, mp->conf_addr, mp->length, mp->spec_rev,
		mp->feature[0], mp->feature[1], mp->feature[2],
		mp->feature[3], mp->feature[4]);
a137 1

@


1.4
log
@fix some 3/4 for toby
@
text
@d1 1
a1 1
/*	$OpenBSD: smpprobe.c,v 1.3 1998/09/27 17:42:07 mickey Exp $	*/
d51 1
a51 3
mp_checksum(ptr, len)
	u_int8_t *ptr;
	int len;
d67 1
a67 3
mp_probefloat(ptr, len)
	u_int8_t *ptr;
	int len;
d78 1
d86 1
a86 1
			mp_checksum(tmp, tmp->length*16)){
d101 1
a101 1
smpprobe()
@


1.3
log
@some inline
@
text
@d1 1
a1 1
/*	$OpenBSD: smpprobe.c,v 1.2 1998/04/18 07:39:55 deraadt Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Tobias Weingartner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.3.8.1
log
@First SMP branch commit.  Probe SMP systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: smpprobe.c,v 1.3 1998/09/27 17:42:07 mickey Exp $	*/
d41 3
a43 3
extern u_int cnvmem;
#define	MP_FLOAT_SIG	0x5F504D5F	/* "_MP_" little endian*/
#define	MP_CONF_SIG	0x504D4350	/* "PCMP" little endian */
d69 1
a69 1
	return ((sum & 0xff) == 0);
d78 1
a78 1
	mp_float_t *mpp;
d85 10
a94 3
	for (i = 0, mpp = (mp_float_t *)ptr; i < len;
	    i += sizeof(mp_float_t), mpp++) {
		if (mpp->signature == MP_FLOAT_SIG) {
d97 1
a97 8
				printf("Found possible MP signature at: %p\n",
				    mpp);
#endif
			if (mp_checksum(mpp, mpp->length * 16)) {
#ifdef DEBUG
				if (debug)
					printf("Found valid MP signature at: "
					    "%p\n", ptr);
d99 2
a100 2
				break;
			}
d104 1
a104 1
	return (i < len ? mpp : NULL);
d114 3
a116 3
	if (!(mp = mp_probefloat((void *)((*((u_int16_t*)0x40e)) * 16), 1024)) &&
		/* Check BIOS ROM 0xF0000 - 0xFFFFF */
	    !(mp = mp_probefloat((void *)(0xF0000), 0xFFFF)) &&
d118 3
a120 1
	    !(mp = mp_probefloat((void *)(cnvmem * 1024), 1024))) {
@


1.3.8.2
log
@Use shared (with kernel) header.  Feed MP info to kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: smpprobe.c,v 1.3.8.1 2000/02/19 17:53:11 niklas Exp $	*/
a36 2
#include <machine/mp.h>
#include <stand/boot/bootarg.h>
d42 12
d72 2
a73 1
struct mp_float *
d78 1
a78 1
	struct mp_float *mpp;
d85 3
a87 4
	for (i = 0, mpp = (struct mp_float *)ptr; i < len;
	    i += sizeof *mpp, mpp++) {
		if (bcmp(mpp->signature, MPF_SIGNATURE,
		    sizeof mpp->signature) == 0) {
d111 1
a111 1
	struct mp_float *mp = NULL;
d114 1
a114 2
	if (!(mp = mp_probefloat((void *)((*((u_int16_t*)0x40e)) * 16),
	    1024)) &&
a128 2
	addbootarg(BOOTARG_SMPINFO, mp->length * sizeof *mp, mp);

d132 8
a139 9
		    "\tSignature: %c%c%c%c\n"
		    "\tConfig at: %x\n"
		    "\tLength: %d\n"
		    "\tRev: 1.%d\n"
		    "\tFeature: %x %x %x %x %x\n",
		    mp->signature[0], mp->signature[1], mp->signature[2],
		    mp->signature[3], mp->pointer, mp->length, mp->revision,
		    mp->feature1, mp->feature2, mp->feature3, mp->feature4,
		    mp->feature5);
@


1.3.8.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: smpprobe.c,v 1.3.8.2 2000/02/20 10:27:56 niklas Exp $	*/
d15 5
@


1.3.8.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 3
a43 1
mp_checksum(u_int8_t *ptr, int len)
d57 4
a60 3

static mp_float_t *
mp_probefloat(u_int8_t *ptr, int len)
d78 1
a78 1
			if (mp_checksum((u_int8_t *)mpp, mpp->length * 16)) {
d94 1
a94 1
smpprobe(void)
@


1.3.8.5
log
@Merge with the trunk
@
text
@d16 2
a17 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
d66 4
a69 11
	for (i = 0; i < 1024; i++) {
		mp_float_t *tmp = (mp_float_t*)(ptr + i);

		if (tmp->signature == MP_FLOAT_SIG) {
			printf("Found possible MP signature at: %p\n", ptr);

			mpp = tmp;
			break;
		}
		if ((tmp->signature == MP_FLOAT_SIG) &&
		    mp_checksum((u_int8_t *)tmp, tmp->length*16)) {
d72 2
a73 2
				printf("Found valid MP signature at: %p\n",
				    ptr);
d86 1
a86 1
	return mpp;
d112 1
d117 1
a117 1
		    "\tSignature: %x\n"
d122 4
a125 3
		    mp->signature, mp->conf_addr, mp->length, mp->spec_rev,
		    mp->feature[0], mp->feature[1], mp->feature[2],
		    mp->feature[3], mp->feature[4]);
d128 1
@


1.3.8.6
log
@fold out -smp branch changes from i386/stand. use the -current stat bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: smpprobe.c,v 1.3.8.5 2004/06/05 23:09:01 niklas Exp $	*/
d32 2
d38 1
a38 13
extern u_int cnvmem, extmem;
#define	MP_FLOAT_SIG	0x5F504D5F	/* _MP_ */
#define	MP_CONF_SIG	0x504D4350	/* PCMP */

typedef struct _mp_float {
	u_int32_t signature;
	u_int32_t conf_addr;
	u_int8_t length;
	u_int8_t spec_rev;
	u_int8_t checksum;
	u_int8_t feature[5];
} mp_float_t;

d52 1
a52 1
	return (!(sum & 0xff));
d59 1
a59 1
	mp_float_t *mpp = NULL;
d82 8
a89 2
			mpp = tmp;
			break;
d100 1
a100 1
	mp_float_t *mp = NULL;
d103 4
a106 3
	if (!(mp = mp_probefloat((void *)((*((u_int32_t*)0x4e)) * 16), 1024)) &&
		/* Check BIOS ROM 0xE0000 - 0xFFFFF */
	    !(mp = mp_probefloat((void *)(0xE0000), 0x1FFFF)) &&
d108 1
a108 3
	    !(mp = mp_probefloat((void *)(cnvmem * 1024), 1024)) &&
		/* Check last 1K of extended RAM XXX */
	    !(mp = mp_probefloat((void *)(extmem * 1024 - 1024), 1024))) {
@


1.2
log
@i386 bootblocks that work for 2.3. A tale too long to tell
@
text
@d1 1
a1 1
/*	$OpenBSD: smpprobe.c,v 1.1 1998/02/24 22:07:46 weingart Exp $	*/
d55 1
a55 1
static int
@


1.1
log
@Ooops, forgot these two here.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 2
d42 2
a43 2
#define MP_FLOAT_SIG 0x5F504D5F		/* _MP_ */
#define MP_CONF_SIG 0x504D4350		/* PCMP */
d60 1
a60 1
	int i, sum = 0;
d66 1
a66 1
	for(i = 0; i < len; i++){
a67 2
	}
	sum &= 0xFF;
d69 1
a69 1
	return(!sum);
d82 2
a83 1
	printf("Checking %p for %d\n", ptr, len);
a94 1

d96 2
a97 1
			printf("Found valid MP signature at: %p\n", ptr);
d104 1
a104 1
	return(mpp);
a110 2
	u_int32_t *ptr;
	u_int16_t *seg;
d114 8
a121 20
	seg = (void *)((0x40 * 16) + 0x0E);		/* 40:0E */
	ptr = (void *)((*seg) * 16);			/* Segment => Linear */
	mp = mp_probefloat(ptr, 1024);

	/* Check BIOS ROM 0xE0000 - 0xFFFFF */
	ptr = (void *)(0xE0000);
	mp = mp_probefloat(ptr, 0x1FFFF);
	if(mp) goto end;

	/* Check last 1K of base RAM */
	ptr = (void *)(cnvmem * 1024);
	mp = mp_probefloat(ptr, 1024);
	if(mp) goto end;

	/* Check last 1K of extended RAM */
	ptr = (void *)(extmem * 1024 - 1024);		/* XXX */
	mp = mp_probefloat(ptr, 1024);
	if(mp) goto end;

	/* No valid MP signature found */
d123 2
a124 1
	printf("No valid MP signature found.\n");
d126 2
a127 1
	return;
a129 1
end:
d132 8
a139 6
	printf("Floating Structure:\n");
	printf("\tSignature: %x\n", mp->signature);
	printf("\tConfig at: %x\n", mp->conf_addr);
	printf("\tLength: %d\n", mp->length);
	printf("\tRev: 1.%d\n", mp->spec_rev);
	printf("\tFeature: %x %x %x %x %x\n",
@


