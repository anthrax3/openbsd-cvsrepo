head	1.41;
access;
symbols
	OPENBSD_6_1:1.41.0.24
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.41.0.22
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.41.0.18
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.41.0.20
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.12
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.41.0.16
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.41.0.14
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.41.0.10
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.41.0.8
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.6
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.4
	OPENBSD_5_0:1.41.0.2
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.40.0.6
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.40.0.4
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.39.0.10
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.6
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.39.0.4
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.2
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.38.0.2
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.37.0.14
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.37.0.12
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.37.0.10
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.37.0.8
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.37.0.6
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.37.0.4
	OPENBSD_3_6_BASE:1.37
	SMP_SYNC_A:1.37
	SMP_SYNC_B:1.37
	OPENBSD_3_5:1.37.0.2
	OPENBSD_3_5_BASE:1.37
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	UBC_SYNC_A:1.33
	OPENBSD_3_3:1.32.0.4
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.32.0.2
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.29.0.2
	OPENBSD_3_1_BASE:1.29
	UBC_SYNC_B:1.32
	UBC:1.28.0.18
	UBC_BASE:1.28
	OPENBSD_3_0:1.28.0.16
	OPENBSD_3_0_BASE:1.28
	OPENBSD_2_9:1.28.0.14
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_8:1.28.0.12
	OPENBSD_2_8_BASE:1.28
	OPENBSD_2_7:1.28.0.10
	OPENBSD_2_7_BASE:1.28
	SMP:1.28.0.8
	SMP_BASE:1.28
	kame_19991208:1.28
	OPENBSD_2_6:1.28.0.6
	OPENBSD_2_6_BASE:1.28
	OPENBSD_2_5:1.28.0.4
	OPENBSD_2_5_BASE:1.28
	OPENBSD_2_4:1.28.0.2
	OPENBSD_2_4_BASE:1.28
	OPENBSD_2_3:1.27.0.2
	OPENBSD_2_3_BASE:1.27
	OPENBSD_2_2:1.20.0.2
	OPENBSD_2_2_BASE:1.20
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8;
locks; strict;
comment	@# @;


1.41
date	2011.07.05.17.38.54;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2009.09.30.19.03.17;	author weingart;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.07.09.43.35;	author weingart;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.31.23.34.46;	author weingart;	state Exp;
branches;
next	1.37;

1.37
date	2004.02.10.00.35.16;	author tom;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.26.23.21.49;	author tom;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.27.18.27.53;	author weingart;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.03.20.22.11;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2003.04.17.03.43.18;	author drahn;	state Exp;
branches;
next	1.32;

1.32
date	2002.08.28.20.15.34;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.25.23.28.58;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.25.22.37.15;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2002.02.21.18.39.46;	author tdeval;	state Exp;
branches;
next	1.28;

1.28
date	98.07.04.08.56.41;	author deraadt;	state Exp;
branches
	1.28.8.1
	1.28.18.1;
next	1.27;

1.27
date	98.04.18.07.39.35;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	98.04.13.00.37.41;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	98.04.11.22.48.48;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	98.04.03.19.09.18;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	98.03.30.07.00.29;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	98.02.24.22.06.39;	author weingart;	state Exp;
branches;
next	1.21;

1.21
date	97.11.05.02.12.54;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	97.09.05.17.58.49;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	97.08.29.22.26.58;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	97.08.29.21.16.48;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	97.08.29.20.10.56;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	97.08.29.19.47.23;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	97.08.13.04.03.28;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	97.08.07.09.07.54;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	97.07.31.20.04.40;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.07.30.19.40.45;	author flipk;	state Exp;
branches;
next	1.11;

1.11
date	97.07.29.16.48.38;	author flipk;	state Exp;
branches;
next	1.10;

1.10
date	97.07.28.23.02.17;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.05.29.04.31.48;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.04.29.00.10.05;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.04.15.08.00.44;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.04.14.19.09.10;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.04.14.10.58.31;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.04.11.19.09.59;	author weingart;	state Exp;
branches;
next	1.3;

1.3
date	97.03.31.23.06.19;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	97.03.31.03.12.01;	author weingart;	state Exp;
branches;
next	1.1;

1.1
date	96.12.03.13.16.53;	author mickey;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	96.12.03.13.16.54;	author mickey;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	96.12.15.15.49.34;	author mickey;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	96.12.16.15.19.29;	author mickey;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	97.01.03.21.44.32;	author mickey;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	97.02.07.07.11.01;	author mickey;	state Exp;
branches;
next	;

1.28.8.1
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.28.8.2;

1.28.8.2
date	2003.03.27.23.26.56;	author niklas;	state Exp;
branches;
next	1.28.8.3;

1.28.8.3
date	2003.05.13.19.42.09;	author ho;	state Exp;
branches;
next	1.28.8.4;

1.28.8.4
date	2003.06.07.11.11.38;	author ho;	state Exp;
branches;
next	1.28.8.5;

1.28.8.5
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	1.28.8.6;

1.28.8.6
date	2004.06.05.23.09.00;	author niklas;	state Exp;
branches;
next	;

1.28.18.1
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	1.28.18.2;

1.28.18.2
date	2002.10.29.00.28.04;	author art;	state Exp;
branches;
next	1.28.18.3;

1.28.18.3
date	2003.05.19.21.45.12;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.41
log
@More non-512-byte sector groundwork. Don't let disklabel hint that
a ffs frag size can be less than the d_secsize of the disk.  Make
sure amd64 writedisklabel() puts the disklabel where readdoslabel()
will read it. Tweak i386/amd64 installboot/biosboot so sectors are
indeed used where sectors are claimed.

Lets me fdisk, newfs, mount and installboot onto 2048 and 4096
byte sector devices. Other filesystem utilites will still hold
surprises.

Note that actually booting from such devices will await BIOSen that
acknowledge such devices as bootable.

ok guenther@@
@
text
@/*	$OpenBSD: biosboot.S,v 1.40 2009/09/30 19:03:17 weingart Exp $	*/

/*
 * Copyright (c) 2003 Tobias Weingartner
 * Copyright (c) 2003 Tom Cosgrove <tom.cosgrove@@arches-consulting.com>
 * Copyright (c) 1997 Michael Shalayeff, Tobias Weingartner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
	.file	"biosboot.S"

#include <machine/asm.h>
#include <assym.h>

/* Error indicators */
#define PBR_READ_ERROR			'R'
#define PBR_CANT_BOOT			'X'
#define PBR_BAD_MAGIC			'M'
#define PBR_TOO_MANY_INDIRECTS		'I'

#define CHAR_BLOCK_READ		'.'
#define CHAR_CHS_READ		';'

/*
 * Memory layout:
 *
 * 0x00000 -> 0x07BFF	our stack		(to  31k)
 * 0x07A00 -> 0x07BFF	typical MBR loc		(at  30k5)
 * 0x07C00 -> 0x07DFF	our code		(at  31k)
 * 0x07E00 -> ...    	/boot inode block	(at  31k5)
 * 0x07E00 -> ...    	(indirect block if nec)
 * 0x40000 -> ...	/boot			(at 256k)
 *
 * The BIOS loads the MBR at physical address 0x07C00.  It then relocates
 * itself to (typically) 0x07A00.
 *
 * The MBR then loads us at physical address 0x07C00.
 *
 * We use a long jmp to normalise our address to seg:offset 07C0:0000.
 * (In real mode on x86, segment registers contain a base address in
 * paragraphs (16 bytes).  0000:00010 is the same as 0001:0000.)
 *
 * We set the stack to start at 0000:7BFC (grows down on i386)
 *
 * We then read the inode for /boot into memory just above us at
 * 07E0:0000, and run through the direct block table (and the first
 * indirect block table, if necessary).
 *
 * We load /boot at seg:offset 4000:0000.
 *
 * Previous versions limited the size of /boot to 64k (loaded in a single
 * segment).  This version does not have this limitation.
 */
#define INODESEG	0x07e0	/* where we put /boot's inode's block */
#define INDIRECTSEG	0x07e0	/* where we put indirect table, if nec */
#define BOOTSEG		0x07c0	/* biosboot loaded here */
#define BOOTSTACKOFF  ((BOOTSEG << 4) - 4)  /* stack starts here, grows down */
#define LFMAGIC		0x464c  /* LFMAGIC (last two bytes of \7fELF) */
#define ELFMAGIC    0x464c457f  /* ELFMAGIC ("\7fELF") */

#define INODEOFF  ((INODESEG-BOOTSEG) << 4)

/*
 * The data passed by installboot is:
 *
 * inodeblk	uint32	the filesystem block that holds /boot's inode
 * inodedbl	uint32	the memory offset to the beginning of the
 *			direct block list (di_db[]).  (This is the
 *			offset within the block + $INODEOFF, which is
 *			where we load the block to.)
 * fs_bsize_p	uint16	the filesystem block size _in paragraphs_
 *			(i.e. fs_bsize / 16)
 * fs_bsize_s	uint16	the number of disk sectors in a filesystem
 *			block (i.e. fs_bsize / d_secsize). Directly written
 *			into the LBA command block, at lba_count.
 *			XXX LIMITED TO 127 BY PHOENIX EDD SPEC.
 * fsbtodb	uint8	shift count to convert filesystem blocks to
 *			disk blocks (sectors).  Note that this is NOT
 *			log2 fs_bsize, since fragmentation allows
 *			the trailing part of a file to use part of a
 *			filesystem block.  In other words, filesystem
 *			block numbers can point into the middle of
 *			filesystem blocks.
 * p_offset	uint32	the starting disk block (sector) of the
 *			filesystem
 * nblocks	uint16	the number of filesystem blocks to read.
 *			While this can be calculated as
 *			howmany(di_size, fs_bsize) it takes us too
 *			many code bytes to do it.
 *
 * All of these are patched directly into the code where they are used
 * (once only, each), to save space.
 *
 * One more symbol is exported, in anticipation of a "-c" flag in
 * installboot to force CHS reads:
 *
 * force_chs	uint8	set to the value 1 to force biosboot to use CHS
 *			reads (this will of course cause the boot sequence
 *			to fail if /boot is above 8 GB).
 */

	.globl	inodeblk, inodedbl, fs_bsize_p, fsbtodb, p_offset, nblocks
	.globl	fs_bsize_s, force_chs
	.type	inodeblk, @@function
	.type	inodedbl, @@function
	.type	fs_bsize_p, @@function
	.type	fs_bsize_s, @@function
	.type	fsbtodb, @@function
	.type	p_offset, @@function
	.type	nblocks, @@function
	.type	force_chs, @@function


/* Clobbers %ax, maybe more */
#define	putc(c)		movb	$c, %al;	call	Lchr

/* Clobbers %ax, %si, maybe more */
#define	puts(s)		movw	$s, %si;	call	Lmessage


	.text
	.code16
	.globl	_start
_start:
	jmp	begin
	nop

	/*
	 * BIOS Parameter Block.  Read by many disk utilities.
	 *
	 * We would have liked biosboot to go from the superblock to
	 * the root directory to the inode for /boot, thence to read
	 * its blocks into memory.
	 *
	 * As code and data space is quite tight in the 512-byte
	 * partition boot sector, we instead get installboot to pass
	 * us some pre-processed fields.
	 *
	 * We would have liked to put these in the BIOS parameter block,
	 * as that seems to be the right place to put them (it's really
	 * the equivalent of the superblock for FAT filesystems), but
	 * caution prevents us.
	 *
	 * For now, these fields are either directly in the code (when they
	 * are used once only) or at the end of this sector.
	 */

	. = _start + 3

	.asciz	"OpenBSD"

	/* BPB */
	. = _start + 0x0b
bpb:	.word	DEV_BSIZE			/* sector size */
	.byte	2				/* sectors/cluster */
	.word	0				/* reserved sectors */
	.byte	0				/* # of FAT */
	.word	0				/* root entries */
	.word	0				/* small sectors */
	.byte	0xf8				/* media type (hd) */
	.word	0				/* sectors/fat */
	.word	0				/* sectors per track */
	.word	0				/* # of heads */

	/* EBPB */
	. = _start + 0x1c
ebpb:	.long	16			/* hidden sectors */
	.long	0			/* large sectors */
	.word	0			/* physical disk */
	.byte	0x29			/* signature, needed by NT */
	.space	4, 0			/* volume serial number */
	.asciz	"UNIX LABEL"
	.asciz	"UFS 4.4"

	/* boot code */
	. = _start + 0x3e

begin:
	/* Fix up %cs just in case */
	ljmp	$BOOTSEG, $main

	/*
	 * Come here if we have to do a CHS boot, but we get an error from
	 * BIOS get drive parameters, or it returns nsectors == 0 (in which
	 * case we can't do the division we need to convert LBA sector
	 * number to CHS).
	 */
cant_boot:
	movb	$PBR_CANT_BOOT, %al
	jmp	err_print_crlf

main:
	/* Set up stack */
	xorw	%ax, %ax
	movw	%ax, %ss
	movw	$BOOTSTACKOFF, %sp

	/* Set up needed data segment reg */
	pushw	%cs
	popw	%ds			/* Now %cs == %ds, != %ss (%ss == 0) */

#ifdef SERIAL
	/* Initialize the serial port to 9600 baud, 8N1 */
	push	%dx
	movw	$0x00e3, %ax
	movw	SERIAL, %dx
	int	$0x14
	pop	%dx
#endif

#ifdef BDEBUG
	putc('R')
#endif

	/*
	 * We're going to print our sign-on message.
	 *
	 * We're now LBA-aware, and will use LBA to load /boot if the
	 * BIOS says it's available.  However, we have seen machines
	 * where CHS is required even when LBA is available.  Therefore
	 * we provide a way to force CHS use:
	 *
	 * If the SHIFT key is held down on entry, force CHS reads.
	 */
	movw	$load_msg+1, %si	/* "Loading" */
	movb	%dl, %dh

	/*
	 * BIOS call "INT 0x16 Get Keyboard Shift Flags
	 *	Call with	%ah = 0x02
	 *	Return:
	 *			%al = shift flags
	 *			%ah - undefined by many BIOSes
	 */
	movb	$0x02, %ah
	int	$0x16

	/*
	 * We provide the ability to force CHS use without having to hold
	 * down the SHIFT key each boot.  Just set the byte at force_chs
	 * to 1 (more accurately any value with either of the bottom two
	 * bits set, but the use of 1 is recommended).
	 */
force_chs = .+1
	orb	$0, %al

	testb	$0x3, %al		/* Either shift key down? */
	jz	no_force_chs

	decw	%si			/* "!Loading" indicates forced CHS */
	xorb	%dh, %dh		/* Pretend a floppy, so no LBA use */

no_force_chs:
	/* Print pretty message */
	call	Lmessage

	/*
	 * We will use LBA reads if we have LBA support, so find out.
	 */

	/*
	 * But don't even try on floppies, OR if forcing to CHS.
	 *
	 * (We're really testing %dl, but use %dh so we can force the
	 * top bit to zero to force CHS boot.)
	 */
	testb	$0x80, %dh
	jz	no_lba

	/*
	 * BIOS call "INT 0x13 Extensions Installation Check"
	 *	Call with	%ah = 0x41
	 *			%bx = 0x55AA
	 *			%dl = drive (0x80 for 1st hd, 0x81 for 2nd, etc)
	 *	Return:
	 *			carry set: failure
	 *				%ah = error code (0x01, invalid func)
	 *			carry clear: success
	 *				%bx = 0xAA55 (must verify)
	 *				%ah = major version of extensions
	 *				%al   (internal use)
	 *				%cx = capabilities bitmap
	 *					0x0001 - extnd disk access funcs
	 *					0x0002 - rem. drive ctrl funcs
	 *					0x0004 - EDD functions with EBP
	 *				%dx   (extension version?)
	 */

	pushw	%dx			/* Save the drive number (%dl) */
	movw	$0x55AA, %bx
	movb	$0x41, %ah
	int	$0x13
	popw	%dx			/* Retrieve drive number */

	jc	no_lba			/* Did the command work? Jump if not */
	cmpw	$0xAA55, %bx		/* Check that bl, bh exchanged */
	jne	no_lba			/* If not, don't have EDD extensions */
	testb	$0x01, %cl		/* And do we have "read" available? */
	jz	no_lba			/* Again, use CHS if not */

	/* We have LBA support, so that's the vector to use */

	movw	$load_lba, load_fsblock
	jmp	get_going

no_lba:
	pushw	%dx

	/*
	 * BIOS call "INT 0x13 Function 0x08" to get drive parameters
	 *	Call with        %ah = 0x08
	 *                       %dl = drive (0x80 for 1st hd, 0x81 for 2nd...)
	 *       Return:
	 *                       carry set: failure
	 *                           %ah = err code
	 *                       carry clear: success
	 *                           %ah = 0x00
	 *                           %al = 0x00 (some BIOSes)
	 *                           %ch = 0x00 (some BIOSes)
	 *                           %ch = max-cylinder & 0xFF
	 *                           %cl = max sector | rest of max-cyl bits
	 *                           %dh = max head number
	 *                           %dl = number of drives
	 *                                 (according to Ralph Brown Int List)
	 */
	movb	$0x08, %ah
	int	$0x13			/* We need to know heads & sectors */

	jc	cant_boot		/* If error, can't boot */

	movb	%dh, maxheads		/* Remember this */

	andb	$0x3F, %cl
	jz	cant_boot
	movb	%cl, nsectors

	putc(CHAR_CHS_READ)		/* Indicate (subtly) CHS reads */

	popw	%dx			/* Retrieve the drive number */

get_going:
	/*
	 * Older versions of biosboot used to set up the destination
	 * segment, and increase the target offset every time a number
	 * of blocks was read.  That limits /boot to 64k.
	 *
	 * In order to support /boots > 64k, we always read to offset
	 * 0000 in the target segment, and just increase the target segment
	 * each time.
	 */

	/*
	 * We would do movl inodeblk, %eax  here, but that instruction
	 * is 4 bytes long; add 4 bytes for data takes 8 bytes.  Using
	 * a load immediate takes 6 bytes, and we just get installboot
	 * to patch here, rather than data anywhere else.
	 */
inodeblk = .+2
	movl	$0x90909090, %eax	/* mov $inodeblk, %eax */

	movw	$INODESEG, %bx		/* Where to put /boot's inode */

	/*
	 * %eax - filesystem block to read
	 * %bx  - target segment (target offset is 0000)
	 * %dl  - BIOS drive number
	 */
	call	*load_fsblock		/* This will crash'n'burn on errs */

	/*
	 * We now have /boot's inode in memory.
	 *
	 * /usr/include/ufs/ufs/dinode.h for the details:
	 *
	 * Offset  8 (decimal): 64-bit file size (only use low 32 bits)
	 * Offset 40 (decimal): list of NDADDR (12) direct disk blocks
	 * Offset 88 (decimal): list of NIADDR (3) indirect disk blocks
	 *
	 * NOTE: list of indirect blocks immediately follows list of
	 * direct blocks.  We use this fact in the code.
	 *
	 * We only support loading from direct blocks plus the first
	 * indirect block.  This is the same as the previous biosboot/
	 * installboot limit.  Note that, with default 16,384-bytes
	 * filesystem blocks, the direct block list supports files up
	 * to 192 KB.  /boot is currently around 60 KB.
	 *
	 * The on-disk format can't change (filesystems with this format
	 * already exist) so okay to hardcode offsets here.
	 *
	 * The nice thing about doing things with filesystem blocks
	 * rather than sectors is that filesystem blocks numbers have
	 * 32 bits, so fit into a single register (even if "e"d).
	 *
	 * Note that this code does need updating if booting from a new
	 * filesystem is required.
	 */
#define NDADDR	12
#define di_db	40			/* Not used; addr put in by instboot */
#define di_ib	88			/* Not used; run on from direct blks */

	/*
	 * Register usage:
	 *
	 * %eax - block number for load_fsblock
	 * %bx  - target segment (target offset is 0000) for load_fsblock
	 * %dl  - BIOS drive number for load_fsblock
	 * %esi - points to block table in inode/indirect block
	 * %cx  - number of blocks to load within loop (i.e. from current
	 *	  block list, which is either the direct block list di_db[]
	 *	  or the indirect block list)
	 * %di  - total number of blocks to load
	 */

	/*
	 * We would do movl inodedbl, %esi  here, but that instruction
	 * is 4 bytes long; add 4 bytes for data takes 8 bytes.  Using
	 * a load immediate takes 6 bytes, and we just get installboot
	 * to patch here, rather than in data anywhere else.
	 */
inodedbl = .+2
	movl	$0x90909090, %esi	/* mov $inodedbl, %esi */
					/* Now esi -> di_db[] */

nblocks = .+1
	movw	$0x9090, %di		/* mov nblocks, %di */
	movw	%di, %cx
	cmpw	$NDADDR, %cx
	jc	1f
	movw	$NDADDR, %cx
1:					/* %cx = min(nblocks, $NADDR) */

	movw	$(LOADADDR >> 4), %bx	/* Target segment for /boot */

load_blocks:
	putc(CHAR_BLOCK_READ)		/* Show progress indicator */

	cld

	/* Get the next filesystem block number into %eax */
	lodsl			/* %eax = *(%si++), make sure 0x66 0xad */

	pushal				/* Save all 32-bit registers */

	/*
	 * Read a single filesystem block (will almost certainly be multiple
	 * disk sectors)
	 *
	 * %eax - filesystem block to read
	 * %bx  - target segment (target offset is 0000)
	 * %dl  - BIOS drive number
	 */
	call	*load_fsblock		/* This will crash'n'burn on errs */

	popal				/* Restore 32-bit registers */

	/*
	 * We want to put addw fs_bsize_p, %bx, which takes 4 bytes
	 * of code and two bytes of data.
	 *
	 * Instead, use an immediate load, and have installboot patch
	 * here directly.
	 */
	/* Move on one filesystem block */
fs_bsize_p = .+2
	addw	$0x9090, %bx		/* addw $fs_bsize_p, %bx */

	decw	%di
	loop	load_blocks

	/* %cx == 0 ... important it stays this way (used later) */

	/*
	 * Finished reading a set of blocks.
	 *
	 * This was either the direct blocks, and there may or may not
	 * be indirect blocks to read, or it was the indirect blocks,
	 * and we may or may not have read in all of /boot.  (Ideally
	 * will have read in all of /boot.)
	 */
	orw	%di, %di
	jz	done_load		/* No more sectors to read */

	/* We have more blocks to load */

	/* We only support a single indirect block (the same as previous
	 * versions of installboot.  This is required for the boot floppies.
	 *
	 * We use a bit of the code to store a flag that indicates
	 * whether we have read the first indirect block or not.
	 *
	 * If we've already read the indirect list, we can't load this /boot.
	 *
	 * indirect	uint8	0 => running through load_blocks loop reading
	 *			direct blocks.  If != 0, we're reading the
	 *			indirect blocks.  Must use a field that is
	 *			initialised to 0.
	 */
indirect = .+2
	movw	$PBR_TOO_MANY_INDIRECTS, %ax	/* movb $PRB_TOO..., %al */
						/* movb indirect, %ah */
	orb	%ah, %ah
	jnz	err_print_crlf

	incb	indirect		/* No need to worry about wrap */
					/* around, as this will only be done */
					/* once before we fail */

	/* Okay, let's read in the indirect block */

	lodsl				/* Get blk num of 1st indirect blk */

	pushw	%bx			/* Remember where we got to */
	movw	$INODESEG, %bx
	call	*load_fsblock		/* This will crash'n'burn on errs */
	popw	%bx			/* Indirect blocks get added on to */
					/* just after where we got to */
	movl	$INODEOFF, %esi
	movw	%di, %cx		/* How many blocks left to read */

	jmp	load_blocks

done_load:
	puts(crlf)

	/* %cx == 0 from loop above... keep it that way */

	/*
	 * Check the magic signature at the beginning of /boot.
	 * Since /boot is now ELF, this should be 0x7F E L F.
	 */
	movw	$(LOADADDR >> 4), %ax	/* Target segment */
	movw	%ax, %es

	/*
	 * We cheat a little here, and only check the L and F.
	 *
	 * (Saves 3 bytes of code... the two signature bytes we
	 * don't check, and the operand size prefix that's not
	 * needed.)
	 */
	cmpw	$LFMAGIC, %es:2(,1)
	je	exec_boot

	movb	$PBR_BAD_MAGIC, %al

err_print:
	movw	$err_txt, %si
err_print2:
	movb	%al, err_id
err_stop:
	call	Lmessage
stay_stopped:
	sti				/* Ensure Ctl-Alt-Del will work */
	hlt				/* (don't require power cycle) */
	jmp	stay_stopped		/* Just to make sure :-) */

exec_boot:
	/* At this point we could try to use the entry point in
	 * the image we just loaded.  But if we do that, we also
	 * have to potentially support loading that image where it
	 * is supposed to go.  Screw it, just assume that the image
	 * is sane.
	 */
#ifdef BDEBUG
	putc('P')
#endif

	/* %cx == 0 from loop above... keep it that way */

	/*
	 * We want to do movzbl %dl, %eax ; pushl %eax to zero-extend the
	 * drive number to 32 bits and pass it to /boot.  However, this
	 * takes 6 bytes.
	 *
	 * Doing it this way saves 2 bytes.
	 */
	pushw	%cx
	movb	%dl, %cl
	pushw	%cx

	pushl	$BOOTMAGIC	/* use some magic */

	/* jmp	/boot */
	ljmp $(LINKADDR >> 4), $0
	/* not reached */


/*
 * Load a single filesystem block into memory using CHS calls.
 *
 * Input:	%eax - 32-bit filesystem block number
 * 		%bx  - target segment (target offset is 0000)
 * 		%dl  - BIOS drive number
 *
 * Output:	block successfully read in (panics if not)
 *		all general purpose registers may have been trashed
 */
load_chs:
	/*
	 * BIOS call "INT 0x13 Function 0x2" to read sectors from disk into
	 * memory.
	 *	Call with        %ah = 0x42
	 *                       %ah = 0x2
	 *                       %al = number of sectors
	 *                       %ch = cylinder & 0xFF
	 *                       %cl = sector (0-63) | rest of cylinder bits
	 *                       %dh = head
	 *                       %dl = drive (0x80 for 1st hd, 0x81 for 2nd...)
	 *                       %es:%bx = segment:offset of buffer
	 *       Return:
	 *                       carry set: failure
	 *                           %ah = err code
	 *                           %al = number of sectors transferred
	 *                       carry clear: success
	 *                           %al = 0x0 OR number of sectors transferred
	 *                                 (depends on BIOS!)
	 *                                 (according to Ralph Brown Int List)
	 */

	/* Convert the filesystem block into a sector value */
	call	fsbtosector
	movl	lba_sector, %eax	/* we can only use 24 bits, really */

	movw	fs_bsize_s, %cx	/* sectors per filesystem block */

	/*
	 * Some BIOSes require that reads don't cross track boundaries.
	 * Therefore we do all CHS reads single-sector.
	 */
calc_chs:
	pushal
	movw	%bx, %es	/* Set up target segment */

	pushw	%dx		/* Save drive number (in %dl) */
	xorl	%edx, %edx
	movl	%edx, %ecx

nsectors = .+1
	movb	$0x90, %cl	/* movb $nsectors, %cl */
				/* Doing it this way saves 4-2 = 2 bytes code */
				/* bytes (no data, since we would overload) */

	divl	%ecx, %eax
				/* Now have sector number in %dl */
	pushw	%dx		/* Remember for later */

	xorl	%edx, %edx

maxheads = .+1
	movb	$0x90, %cl	/* movb $maxheads, %cl; 0 <= maxheads <= 255 */
				/* Doing it this way saves 4-2 = 2 code */
				/* bytes (no data, since we would overload */

	incw	%cx		/* Number of heads is 1..256, no "/0" worries */

	divl	%ecx, %eax
				/* Have head number in %dl */
				/* Cylinder number in %ax */
	movb	%al, %ch	/* Bottom 8 bits of cyl number */
	shlb	$6, %ah		/* Move up top 2 bits of cyl number */
	movb	%ah, %cl	/* Top 2 bits of cyl number in here */

	popw	%bx		/* (pushed %dx, but need %dl for now */
	incb	%bl		/* Sector numbers run from 1, not 0 */
	orb	%bl, %cl	/* Or the sector number into top bits cyl */

				/* Remember, %dl has head number */
	popw	%ax
				/* %al has BIOS drive number -> %dl */

	movb	%dl, %dh	/* Now %dh has head number (from 0) */
	movb	%al, %dl	/* Now %dl has BIOS drive number */

	xorw	%bx, %bx	/* Set up target offset */

	movw	$0x0201, %ax	/* %al = 1 - read one sector at a time */
				/* %ah = 2 - int 0x13 function for CHS read */

	call	do_int_13	/* saves us 1 byte :-) */

	/* Get the next sector */

	popal
	incl	%eax
	addw	$32, %bx	/* Number of segments/paras in a sector */
	loop	calc_chs

	ret

	/* read error */
read_error:
	movb	$PBR_READ_ERROR, %al
err_print_crlf:
	movw	$err_txt_crlf, %si
	jmp	err_print2


/*
 * Load a single filesystem block into memory using LBA calls.
 *
 * Input:	%eax - 32-bit filesystem block number
 * 		%bx  - target segment (target offset is 0000)
 * 		%dl  - BIOS drive number
 *
 * Output:	block successfully read in (panics if not)
 *		all general purpose registers may have been trashed
 */
load_lba:
	/*
	 * BIOS call "INT 0x13 Extensions Extended Read"
	 *	Call with	%ah = 0x42
	 *			%dl = drive (0x80 for 1st hd, 0x81 for 2nd, etc)
	 *			%ds:%si = segment:offset of command packet
	 *	Return:
	 *			carry set: failure
	 *				%ah = error code (0x01, invalid func)
	 *				command packet's sector count field set
	 *				to the number of sectors successfully
	 *				transferred
	 *			carry clear: success
	 *				%ah = 0 (success)
	 *	Command Packet:
	 *			0x0000	BYTE	packet size (0x10 or 0x18)
	 *			0x0001	BYTE	reserved (should be 0)
	 *			0x0002	WORD	sectors to transfer (max 127)
	 *			0x0004	DWORD	seg:offset of transfer buffer
	 *			0x0008	QWORD	starting sector number
	 */
	call	fsbtosector		/* Set up lba_sector & lba_sector+4 */

	/* movb	%dh, lba_count		<- XXX done by installboot */
	movw	%bx, lba_seg
	movw	$lba_command, %si
	movb	$0x42, %ah
do_int_13:
	int	$0x13
	jc	read_error

	ret


/*
 * Converts a given filesystem block number into a disk sector
 * at lba_sector and lba_sector+4.
 *
 * Input:	%eax - 32-bit filesystem block number
 *
 * Output:	lba_sector and lba_sector+4 set up
 *		XXX
 */
fsbtosector:
	/*
	 * We want to do
	 *
	 * movb	fsbtodb, %ch		/# Shift counts we'll need #/
	 * movb	$32, %cl
	 *
	 * which is 6 bytes of code + 1 byte of data.
	 *
	 * We'll actually code it with an immediate 16-bit load into %cx,
	 * which is just 3 bytes of data (saves 4 bytes).
	 */
fsbtodb = .+2
	movw	$0x9020, %cx		/* %ch = fsbtodb, %cl = 0x20 */

	pushl	%eax
	subb	%ch, %cl
	shrl	%cl, %eax
	movl	%eax, lba_sector+4
	popl	%eax

	movb	%ch, %cl
	shll	%cl, %eax

	/*
	 * And add p_offset, which is the block offset to the start
	 * of the filesystem.
	 *
	 * We would do addl p_offset, %eax, which is 5 bytes of code
	 * and 4 bytes of data, but it's more efficient to have
	 * installboot patch directly in the code (this variable is
	 * only used here) for 6 bytes of code (but no data).
	 */
p_offset = .+2
	addl	$0x90909090, %eax	/* addl $p_offset, %eax */

	movl	%eax, lba_sector
	jnc	1f

	incl	lba_sector+4
1:
	ret


/*
 * Display string
 */
Lmessage:
	cld
1:
	lodsb			/* load a byte into %al */
	orb	%al, %al
	jz	1f
	call	Lchr
	jmp	1b

/*
 *	Lchr: write the character in %al to console
 */
Lchr:
#ifdef SERIAL
	pushw	%dx
	movb	$0x01, %ah
	xorw	%dx, %dx
	movb	SERIAL, %dl
	int	$0x14
	popw	%dx
#else
	pushw	%bx
	movb	$0x0e, %ah
	xorw	%bx, %bx
	incw	%bx		/* movw $0x01, %bx */
	int	$0x10
	popw	%bx
#endif
1:
	ret

	/* .data */

/* vector to the routine to read a particular filesystem block for us */
load_fsblock:
	.word	load_chs


/* This next block is used for the EDD command packet used to read /boot
 * sectors.
 *
 * lba_count is set up for us by installboot.  It is the number of sectors
 * in a filesystem block.  (Max value 127.)
 *
 * XXX The EDD limit of 127 sectors in one read means that we currently
 *     restrict filesystem blocks to 127 sectors, or < 64 KB.  That is
 *     effectively a 32 KB block limit, as filesystem block sizes are
 *     powers of two.  The default filesystem block size is 16 KB.
 *
 *     I say we run with this limitation and see where it bites us...
 */

lba_command:
	.byte	0x10			/* size of command packet */
	.byte	0x00			/* reserved */
fs_bsize_s:
lba_count:
	.word	0			/* sectors to transfer, max 127 */
	.word	0			/* target buffer, offset */
lba_seg:
	.word	0			/* target buffer, segment */
lba_sector:
	.long	0, 0			/* sector number */

load_msg:
	.asciz	"!Loading"
err_txt_crlf:
	.ascii	"\r\n"
err_txt:
	.ascii	"ERR "
err_id:
	.ascii	"?"
crlf:	.asciz	"\r\n"

	. = 0x200 - 2
	/* a little signature */
	.word	DOSMBR_SIGNATURE
@


1.40
log
@Fix comments to match reality.
Thank you Vladimir Kirillov <proger () hackndev ! com>
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.39 2007/09/07 09:43:35 weingart Exp $	*/
d94 2
a95 2
 * fs_bsize_s	uint16	the number of 512-byte sectors in a filesystem
 *			block (i.e. fs_bsize / 512).  Directly written
@


1.39
log
@Comment fix.  It's 0x7F ELF, not 0xFF ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.38 2007/05/31 23:34:46 weingart Exp $	*/
d48 1
a48 1
 * 0x00000 -> 0x079FF	our stack		(to  30k5)
d64 1
a64 1
 * We set the stack to start at 0000:79FC (grows down on i386)
@


1.38
log
@It's the time to squash antique bugs.  This has been there
for some time.  I can't believe it took a re-read for future
functionality plus something I wrote and kjell@@ saved from '97
for me to find this.

ok tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.37 2004/02/10 00:35:16 tom Exp $	*/
d551 1
a551 1
	 * Since /boot is now ELF, this should be 0xFF E L F.
@


1.37
log
@Enable interrupts before halt when we error out.  Allows use of
Ctl-Alt-Del to reboot in case of failure.

Much testing nick@@; thanks.

ok weingart@@, deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.36 2004/01/26 23:21:49 tom Exp $	*/
d193 1
a193 1
	.ascii	"UNIX LABEL"
@


1.36
log
@Major overhaul of biosboot and installboot, using EDD (LBA) reads if
the BIOS supports it.  File location data now geometry-independent
(biosboot groks part of the inode), so installboot loses -h and -s.

Many thanks to all those brave enough to try the snapshots.  Thanks
for the test reports, everyone.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.35 2003/06/27 18:27:53 weingart Exp $	*/
d575 2
a576 2
	cli
	hlt
@


1.35
log
@Cleanup biosboot to remove uneeded 32-bit opcodes, initializations of
32-bit segment registers, and other things not really necessary. Cleanup
some comments while there as well.  Tweak blocktable to max size these
changes allow us.  This should help in shrinking the code some, making
future changes easier.

nate@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.34 2003/06/03 20:22:11 mickey Exp $	*/
d5 1
d36 5
a40 1
#define	BLKCNT	63
d42 35
d78 55
a132 2
#define BOOTSTACK	0xfffc	/* stack starts here */
#define LFMAGIC		0x464c  /* LFMAGIC (only uses two bytes of \7fELF */
d135 5
a139 9
/* Clobbers %al - maybe more */
#define putc(c)			\
	movb	$c, %al;	\
	call	Lchr;

/* Clobbers %esi - maybe more */
#define	puts(s)			\
	mov	$s, %si;	\
	call	Lmessage
d146 1
a146 1
	jmp	1f
d149 20
d170 1
d172 1
d175 10
a184 10
bpb:	.word	DEV_BSIZE	/* sector size */
	.byte	1		/* sectors/cluster */
	.word	0		/* reserved sectors */
	.byte	0		/* # of FAT */
	.word	0		/* root entries */
	.word	0		/* small sectors */
	.byte	0xf8		/* media type (hd) */
	.word	0		/* sectors/fat */
	.word	0		/* sectors per track */
	.word	0		/* # of heads */
d188 6
a193 6
ebpb:	.long	16		/* hidden sectors */
	.long	0		/* large sectors */
	.word	0		/* physical disk */
	.byte	0x29		/* signature, needed by NT */
	.space	4, 0		/* volume serial number */
	.asciz	"UNIX LABEL"
d199 1
a199 1
1:
d201 1
a201 1
	ljmp	$BOOTSEG, $1f
d203 15
a217 10
load_msg:
	.asciz	"reading boot"

1:
	/* set up stack (%ss:%sp) */
	cli			/* disable interrupts w/o stack */
	xor	%ax, %ax
	mov	%ax, %ss
	mov	$BOOTSTACK, %sp
	sti			/* we have stack, do ints */
d220 2
a221 2
	mov	$BOOTSEG, %ax
	mov	%ax, %ds
d224 1
a224 1
	# Initialize the serial port to 9600 baud, 8N1.
d226 2
a227 2
	mov	$0x00e3, %ax
	mov	SERIAL, %dx
d236 39
d276 1
a276 1
	puts(load_msg)
d278 31
a308 8
	/* set up %es, (where we will load /boot to) */
	mov	$(LOADADDR >> 4), %ax
	mov	%ax, %es

	xorw	%bx, %bx		/* put it at %es:0 */
	movb	block_count, %cl	/* how many to read */
	movzbw	%cl, %cx
	movw	$block_table, %si
d310 3
a312 11
1:
	push	%cx
	putc('.')		/* show progress indicator */
	cld
	lodsw	/* word */	/* cylinder/sector */
	mov	%ax, %cx
	lodsb			/* head */
	movb	%al, %dh
	lodsb			/* # of sectors to load */
	movb	$0x2, %ah
	push	%ax
d314 139
a452 1
	jnc	3f
d454 1
a454 13
	/* read error */
	puts(2f)
	jmp	halt
2:	.asciz	"\r\nRead error\r\n"

3:	/* read next block */

	pop	%ax
	movzbw	%al, %ax
	shl	$9, %ax		/* 512 bytes sectors */
	add	%ax, %bx
	pop	%cx
	loop	1b
d456 2
a457 1
	puts(2f)
a458 1
	xor	%si, %si
a459 4
	/* check /boot magic */
	es;lodsw;es;lodsw	/* no need for high word */
	cmp	$LFMAGIC, %ax
	je	3f
d461 114
a574 2
	puts(1f)
halt:
a575 1
99:
d577 1
a577 3
	jmp 99b
1:	.ascii	"Bad magic"
2:	.asciz	"\r\n"
d579 2
a580 1
3:	/* At this point we could try to use the entry point in
d590 13
a602 2
	movzbl	%dl, %eax	/* drive number is in the lowest byte */
	pushl	%eax
d609 208
a820 1
	push	%ax
d823 2
a824 2
	lodsb			# load a byte into %al
	testb	%al, %al
d829 3
a831 3
#
#	Lchr: write the character in %al to console
#
d833 2
a834 11
	push	%ax

#ifndef SERIAL
	push	%bx
	movb	$0x0e, %ah
	xor	%bx, %bx
	inc	%bx		/* movw $0x01, %bx */
	int	$0x10
	pop	%bx
#else
	push	%dx
d836 1
a836 1
	xor	%dx, %dx
d839 8
a846 1
	pop	%dx
a848 1
	pop	%ax
d851 42
a892 11
	#.data
	.globl	block_table, block_count
	.type block_count, @@function
	.type block_table, @@function
block_count:
	.byte	BLKCNT	/* entries in block_table */
block_table:
	.word	0	/* cylinder/sector */
	.byte	0	/* head */
	.byte	0	/* nsect */
	. = block_table + BLKCNT*4
@


1.34
log
@three four kills
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.33 2003/04/17 03:43:18 drahn Exp $	*/
d4 1
d35 1
a35 1
#define	BLKCNT	52
d37 1
a37 1
#define BOOTSEG		0x07c0	/* boot loaded here */
d90 1
a90 1
	data32 ljmp	$BOOTSEG, $1f
d96 1
a96 1
	/* set up stack (%ss:%esp) */
d100 1
a100 1
	movl	$BOOTSTACK, %esp
d103 1
a103 1
	/* Set up other segment regs */
a105 3
	mov	%ax, %es
	mov	%ax, %fs
	mov	%ax, %gs
d127 1
a127 1
	xorl	%ebx, %ebx		/* put it at %es:0 */
d129 1
a129 1
	movzbl	%cl, %ecx
d154 1
a154 1
	movzbl	%al, %eax
a187 5
#ifdef	BDEBUG
	movl	$0xb8004, %ebx
	movl	$0x074f0747, (%ebx)
#endif

a192 1
	/* data32 */
@


1.33
log
@i386 ELF bootloader. developed with weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.32 2002/08/28 20:15:34 mickey Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.32
log
@ancient file name in .file; from pbastos@@rdc.puc-rio.br
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.31 2002/06/25 23:28:58 mickey Exp $	*/
d39 1
a39 4
#define addr32  .byte 0x67
#define data32  .byte 0x66

#define	BLKCNT	12
d43 1
a43 1
#define ZMAGIC		0x0b01	/* ZMAGIC */
d49 1
a49 2
	.byte	0xe8;		\
	.word	Lchr - . - 2
d53 2
a54 4
	data32;			\
	movl	$s, %esi;	\
	.byte	0xe8;		\
	.word	Lmessage - . - 2
d58 3
a60 2
	.globl	start
start:
d64 1
a64 1
	. = start + 3
d67 1
a67 1
	. = start + 0x0b
d80 1
a80 1
	. = start + 0x1c
d90 1
a90 1
	. = start + 0x3e
d94 1
a94 2
	data32
	ljmp	$BOOTSEG, $1f
d102 2
a103 3
	xorl	%ax, %ax
	movl	%ax, %ss
	data32
d108 5
a112 7
	# movw	$BOOTSEG, %ax
	.byte	0xb8
	.word	BOOTSEG
	movl	%ax, %ds
	movl	%ax, %es
	movl	%ax, %fs
	movl	%ax, %gs
d116 3
a118 7
	pushl	%dx
	# movw	$0x00e3, %ax
	.byte	0xb8
	.word	0x00e3
	# movw	SERIAL, %dx
	.byte	0xba
	.word	SERIAL
d120 1
a120 1
	popl	%dx
d131 2
a132 4
	# movw	$(LOADADDR >> 4), %ax
	.byte	0xb8
	.word	LOADADDR >> 4
	movl	%ax, %es
a133 1
	data32
d135 1
a135 2
	addr32
	movb	_block_count, %cl	/* how many to read */
d137 1
a137 3
	# movw	$_block_table, %si
	.byte	0xbe
	.word	_block_table
d140 1
a140 1
	pushl	%cx
d143 2
a144 2
	lodsl	/* word */	/* cylinder/sector */
	movl	%ax, %cx
d149 1
a149 1
	pushl	%ax
d160 1
a160 2
	popl	%ax
	data32
d162 3
a164 3
	shll	$9, %ax		/* 512 bytes sectors */
	addl	%ax, %bx
	popl	%cx
d169 1
a169 1
	xorl	%si, %si
d172 2
a173 4
	es;lodsl;es;lodsl	/* no need for high word */
	# cmpw	$ZMAGIC, %ax
	.byte	0x3d
	.word	ZMAGIC
d179 1
d181 1
a194 34
	/* change to protected mode */
	/* guarantee that interrupts are disabled when in prot mode */
	cli

	/* load the gdtr */
	addr32
	data32
	lgdt	Gdtr

	/* set the PE bit of CR0 */
	movl	%cr0, %eax
	data32
	orl	$CR0_PE, %eax
	movl	%eax, %cr0 

	/*
	 * make intrasegment jump to flush the processor pipeline and
	 * reload CS register
	 */
	data32
	ljmp	$8, $(BOOTSEG << 4) + 1f

1:	/*
	 * 32bit mode
	 * set up %ds, %ss, %es, etc
	 */
	movl	$0x10, %eax
	movl	%ax, %ds
	movl	%ax, %ss
	movl	%ax, %es
	movl	%ax, %fs
	movl	%ax, %gs
	movl	$BOOTSTACK, %esp

d205 2
a206 1
	ljmp	$8, $(LOADADDR + 0x20)
d213 1
a213 2
	data32
	pushl	%eax
d219 1
a219 3
	# call	Lchr
	.byte	0xe8
	.word	Lchr - . - 2
d226 1
a226 2
	data32
	pushl	%eax
d229 1
a229 2
	data32
	pushl	%ebx
d231 2
a232 2
	xorl	%bx, %bx
	incl	%bx		/* movw $0x01, %bx */
d234 1
a234 2
	data32
	popl	%ebx
d236 1
a236 2
	data32
	pushl	%edx
d238 1
a238 1
	xorl	%dx, %dx
d241 1
a241 2
	data32
	popl	%edx
d244 1
a244 2
	data32
	popl	%eax
d247 7
a253 24
	.align	3
1:		/* 0x00 : null */
	.long	0, 0
		/* 0x08 : flat code */
	.word	0xFFFF			# lolimit
	.word	0			# lobase
	.byte	0			# midbase
	.byte	SDT_MEMERAC | 0 | 0x80	# RWXAC, dpl = 0, present
	.byte	0xf | 0 | 0x40 | 0x80	# hilimit, xx, 32bit, 4k granularity
	.byte	0			# hibase
		/* 0x10 : flat data */
	.word	0xFFFF			# lolimit
	.word	0			# lobase
	.byte	0			# midbase
	.byte	SDT_MEMRWA | 0 | 0x80	# RWA, dpl = 0, present
	.byte	0xf | 0 | 0x40 | 0x80	# hilimit, xx, 32bit, 4k granularity
	.byte	0			# hibase
Gdtr:	.word	. - 1b
	.long	(BOOTSEG << 4) + 1b

	.globl	_block_table, _block_count
_block_count:
	.byte	BLKCNT	/* entries in _block_table */
_block_table:
d257 1
a257 1
	. = _block_table + BLKCNT*4
@


1.31
log
@and kill a now bogus comment
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.30 2002/06/25 22:37:15 mickey Exp $	*/
d34 1
a34 1
	.file	"bootbios.S"
@


1.30
log
@this monkey has not been a mbr for a couple of years already
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.29 2002/02/21 18:39:46 tdeval Exp $	*/
d42 1
a42 1
#define	BLKCNT	12	/* Max without colliding with the partition table */
@


1.29
log
@Pasto. Ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.28 1998/07/04 08:56:41 deraadt Exp $	*/
a337 18
#ifdef BEMBR
	. = 0x1b8
	.space	4, 0	/* NT registry offset from James C. Cortilier III */

	. = DOSPARTOFF
	.globl	_partitions
	/* throw in a partition in case we are block0 as well */
	/* flag, head, sec, cyl, typ, ehead, esect, ecyl, start, len */
_partitions:
	.byte   DOSACTIVE, 0, 1, 0, DOSPTYP_OPENBSD, 255, 255, 255
	.long   0,50000
	.byte   0,0,0,0,0,0,0,0
	.long   0,0
	.byte   0,0,0,0,0,0,0,0
	.long   0,0
	.byte   0,0,0,0,0,0,0,0
	.long   0,0
#endif
@


1.28
log
@add nop; fixes Kapok Computer AMI WinBIOS boot sector detection garbage
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.27 1998/04/18 07:39:35 deraadt Exp $	*/
a341 3
 	. = DOSPARTOFF
 	.globl	_partitions
 	/* throw in a partition in case we are block0 as well */
@


1.28.18.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.28 1998/07/04 08:56:41 deraadt Exp $	*/
d342 3
@


1.28.18.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.28.18.1 2002/06/11 03:35:54 art Exp $	*/
d34 1
a34 1
	.file	"biosboot.S"
d42 1
a42 1
#define	BLKCNT	12
d338 18
@


1.28.18.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 4
a42 1
#define	BLKCNT	52
d46 1
a46 1
#define LFMAGIC		0x464c  /* LFMAGIC (only uses two bytes of \7fELF */
d52 2
a53 1
	call	Lchr;
d57 4
a60 2
	mov	$s, %si;	\
	call	Lmessage
d64 2
a65 3
	.code16
	.globl	_start
_start:
d69 1
a69 1
	. = _start + 3
d72 1
a72 1
	. = _start + 0x0b
d85 1
a85 1
	. = _start + 0x1c
d95 1
a95 1
	. = _start + 0x3e
d99 2
a100 1
	data32 ljmp	$BOOTSEG, $1f
d108 3
a110 2
	xor	%ax, %ax
	mov	%ax, %ss
d115 7
a121 5
	mov	$BOOTSEG, %ax
	mov	%ax, %ds
	mov	%ax, %es
	mov	%ax, %fs
	mov	%ax, %gs
d125 7
a131 3
	push	%dx
	mov	$0x00e3, %ax
	mov	SERIAL, %dx
d133 1
a133 1
	pop	%dx
d144 4
a147 2
	mov	$(LOADADDR >> 4), %ax
	mov	%ax, %es
d149 1
d151 2
a152 1
	movb	block_count, %cl	/* how many to read */
d154 3
a156 1
	movw	$block_table, %si
d159 1
a159 1
	push	%cx
d162 2
a163 2
	lodsw	/* word */	/* cylinder/sector */
	mov	%ax, %cx
d168 1
a168 1
	push	%ax
d179 2
a180 1
	pop	%ax
d182 3
a184 3
	shl	$9, %ax		/* 512 bytes sectors */
	add	%ax, %bx
	pop	%cx
d189 1
a189 1
	xor	%si, %si
d192 4
a195 2
	es;lodsw;es;lodsw	/* no need for high word */
	cmp	$LFMAGIC, %ax
a200 1
99:
a201 1
	jmp 99b
d215 34
d259 1
a259 2
	/* data32 */
	ljmp $(LINKADDR >> 4), $0
d266 2
a267 1
	push	%ax
d273 3
a275 1
	call	Lchr
d282 2
a283 1
	push	%ax
d286 2
a287 1
	push	%bx
d289 2
a290 2
	xor	%bx, %bx
	inc	%bx		/* movw $0x01, %bx */
d292 2
a293 1
	pop	%bx
d295 2
a296 1
	push	%dx
d298 1
a298 1
	xor	%dx, %dx
d301 2
a302 1
	pop	%dx
d305 2
a306 1
	pop	%ax
d309 24
a332 7
	#.data
	.globl	block_table, block_count
	.type block_count, @@function
	.type block_table, @@function
block_count:
	.byte	BLKCNT	/* entries in block_table */
block_table:
d336 1
a336 1
	. = block_table + BLKCNT*4
@


1.28.8.1
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d342 3
@


1.28.8.2
log
@Sync the SMP branch with 3.3
@
text
@d34 1
a34 1
	.file	"biosboot.S"
d42 1
a42 1
#define	BLKCNT	12
d338 18
@


1.28.8.3
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.28.8.2 2003/03/27 23:26:56 niklas Exp $	*/
d39 4
a42 1
#define	BLKCNT	52
d46 1
a46 1
#define LFMAGIC		0x464c  /* LFMAGIC (only uses two bytes of \7fELF */
d52 2
a53 1
	call	Lchr;
d57 4
a60 2
	mov	$s, %si;	\
	call	Lmessage
d64 2
a65 3
	.code16
	.globl	_start
_start:
d69 1
a69 1
	. = _start + 3
d72 1
a72 1
	. = _start + 0x0b
d85 1
a85 1
	. = _start + 0x1c
d95 1
a95 1
	. = _start + 0x3e
d99 2
a100 1
	data32 ljmp	$BOOTSEG, $1f
d108 3
a110 2
	xor	%ax, %ax
	mov	%ax, %ss
d115 7
a121 5
	mov	$BOOTSEG, %ax
	mov	%ax, %ds
	mov	%ax, %es
	mov	%ax, %fs
	mov	%ax, %gs
d125 7
a131 3
	push	%dx
	mov	$0x00e3, %ax
	mov	SERIAL, %dx
d133 1
a133 1
	pop	%dx
d144 4
a147 2
	mov	$(LOADADDR >> 4), %ax
	mov	%ax, %es
d149 1
d151 2
a152 1
	movb	block_count, %cl	/* how many to read */
d154 3
a156 1
	movw	$block_table, %si
d159 1
a159 1
	push	%cx
d162 2
a163 2
	lodsw	/* word */	/* cylinder/sector */
	mov	%ax, %cx
d168 1
a168 1
	push	%ax
d179 2
a180 1
	pop	%ax
d182 3
a184 3
	shl	$9, %ax		/* 512 bytes sectors */
	add	%ax, %bx
	pop	%cx
d189 1
a189 1
	xor	%si, %si
d192 4
a195 2
	es;lodsw;es;lodsw	/* no need for high word */
	cmp	$LFMAGIC, %ax
a200 1
99:
a201 1
	jmp 99b
d215 34
d259 1
a259 2
	/* data32 */
	ljmp $(LINKADDR >> 4), $0
d266 2
a267 1
	push	%ax
d273 3
a275 1
	call	Lchr
d282 2
a283 1
	push	%ax
d286 2
a287 1
	push	%bx
d289 2
a290 2
	xor	%bx, %bx
	inc	%bx		/* movw $0x01, %bx */
d292 2
a293 1
	pop	%bx
d295 2
a296 1
	push	%dx
d298 1
a298 1
	xor	%dx, %dx
d301 2
a302 1
	pop	%dx
d305 2
a306 1
	pop	%ax
d309 24
a332 7
	#.data
	.globl	block_table, block_count
	.type block_count, @@function
	.type block_table, @@function
block_count:
	.byte	BLKCNT	/* entries in block_table */
block_table:
d336 1
a336 1
	. = block_table + BLKCNT*4
@


1.28.8.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.28.8.3 2003/05/13 19:42:09 ho Exp $	*/
d15 5
@


1.28.8.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a3 2
 * Copyright (c) 2003 Tobias Weingartner
 * Copyright (c) 2003 Tom Cosgrove <tom.cosgrove@@arches-consulting.com>
d34 1
a34 5
/* Error indicators */
#define PBR_READ_ERROR			'R'
#define PBR_CANT_BOOT			'X'
#define PBR_BAD_MAGIC			'M'
#define PBR_TOO_MANY_INDIRECTS		'I'
d36 3
a38 2
#define CHAR_BLOCK_READ		'.'
#define CHAR_CHS_READ		';'
a39 36
/*
 * Memory layout:
 *
 * 0x00000 -> 0x079FF	our stack		(to  30k5)
 * 0x07A00 -> 0x07BFF	typical MBR loc		(at  30k5)
 * 0x07C00 -> 0x07DFF	our code		(at  31k)
 * 0x07E00 -> ...    	/boot inode block	(at  31k5)
 * 0x07E00 -> ...    	(indirect block if nec)
 * 0x40000 -> ...	/boot			(at 256k)
 *
 * The BIOS loads the MBR at physical address 0x07C00.  It then relocates
 * itself to (typically) 0x07A00.
 *
 * The MBR then loads us at physical address 0x07C00.
 *
 * We use a long jmp to normalise our address to seg:offset 07C0:0000.
 * (In real mode on x86, segment registers contain a base address in
 * paragraphs (16 bytes).  0000:00010 is the same as 0001:0000.)
 *
 * We set the stack to start at 0000:79FC (grows down on i386)
 *
 * We then read the inode for /boot into memory just above us at
 * 07E0:0000, and run through the direct block table (and the first
 * indirect block table, if necessary).
 *
 * We load /boot at seg:offset 4000:0000.
 *
 * Previous versions limited the size of /boot to 64k (loaded in a single
 * segment).  This version does not have this limitation.
 */
#define INODESEG	0x07e0	/* where we put /boot's inode's block */
#define INDIRECTSEG	0x07e0	/* where we put indirect table, if nec */
#define BOOTSEG		0x07c0	/* biosboot loaded here */
#define BOOTSTACKOFF  ((BOOTSEG << 4) - 4)  /* stack starts here, grows down */
#define LFMAGIC		0x464c  /* LFMAGIC (last two bytes of \7fELF) */
#define ELFMAGIC    0x464c457f  /* ELFMAGIC ("\7fELF") */
d41 4
a44 1
#define INODEOFF  ((INODESEG-BOOTSEG) << 4)
d46 4
a49 56
/*
 * The data passed by installboot is:
 *
 * inodeblk	uint32	the filesystem block that holds /boot's inode
 * inodedbl	uint32	the memory offset to the beginning of the
 *			direct block list (di_db[]).  (This is the
 *			offset within the block + $INODEOFF, which is
 *			where we load the block to.)
 * fs_bsize_p	uint16	the filesystem block size _in paragraphs_
 *			(i.e. fs_bsize / 16)
 * fs_bsize_s	uint16	the number of 512-byte sectors in a filesystem
 *			block (i.e. fs_bsize / 512).  Directly written
 *			into the LBA command block, at lba_count.
 *			XXX LIMITED TO 127 BY PHOENIX EDD SPEC.
 * fsbtodb	uint8	shift count to convert filesystem blocks to
 *			disk blocks (sectors).  Note that this is NOT
 *			log2 fs_bsize, since fragmentation allows
 *			the trailing part of a file to use part of a
 *			filesystem block.  In other words, filesystem
 *			block numbers can point into the middle of
 *			filesystem blocks.
 * p_offset	uint32	the starting disk block (sector) of the
 *			filesystem
 * nblocks	uint16	the number of filesystem blocks to read.
 *			While this can be calculated as
 *			howmany(di_size, fs_bsize) it takes us too
 *			many code bytes to do it.
 *
 * All of these are patched directly into the code where they are used
 * (once only, each), to save space.
 *
 * One more symbol is exported, in anticipation of a "-c" flag in
 * installboot to force CHS reads:
 *
 * force_chs	uint8	set to the value 1 to force biosboot to use CHS
 *			reads (this will of course cause the boot sequence
 *			to fail if /boot is above 8 GB).
 */

	.globl	inodeblk, inodedbl, fs_bsize_p, fsbtodb, p_offset, nblocks
	.globl	fs_bsize_s, force_chs
	.type	inodeblk, @@function
	.type	inodedbl, @@function
	.type	fs_bsize_p, @@function
	.type	fs_bsize_s, @@function
	.type	fsbtodb, @@function
	.type	p_offset, @@function
	.type	nblocks, @@function
	.type	force_chs, @@function


/* Clobbers %ax, maybe more */
#define	putc(c)		movb	$c, %al;	call	Lchr

/* Clobbers %ax, %si, maybe more */
#define	puts(s)		movw	$s, %si;	call	Lmessage
d56 1
a56 1
	jmp	begin
a58 20
	/*
	 * BIOS Parameter Block.  Read by many disk utilities.
	 *
	 * We would have liked biosboot to go from the superblock to
	 * the root directory to the inode for /boot, thence to read
	 * its blocks into memory.
	 *
	 * As code and data space is quite tight in the 512-byte
	 * partition boot sector, we instead get installboot to pass
	 * us some pre-processed fields.
	 *
	 * We would have liked to put these in the BIOS parameter block,
	 * as that seems to be the right place to put them (it's really
	 * the equivalent of the superblock for FAT filesystems), but
	 * caution prevents us.
	 *
	 * For now, these fields are either directly in the code (when they
	 * are used once only) or at the end of this sector.
	 */

a59 1

a60 1

d63 10
a72 10
bpb:	.word	DEV_BSIZE			/* sector size */
	.byte	2				/* sectors/cluster */
	.word	0				/* reserved sectors */
	.byte	0				/* # of FAT */
	.word	0				/* root entries */
	.word	0				/* small sectors */
	.byte	0xf8				/* media type (hd) */
	.word	0				/* sectors/fat */
	.word	0				/* sectors per track */
	.word	0				/* # of heads */
d76 6
a81 6
ebpb:	.long	16			/* hidden sectors */
	.long	0			/* large sectors */
	.word	0			/* physical disk */
	.byte	0x29			/* signature, needed by NT */
	.space	4, 0			/* volume serial number */
	.ascii	"UNIX LABEL"
d87 1
a87 1
begin:
d89 4
a92 1
	ljmp	$BOOTSEG, $main
d94 14
a107 19
	/*
	 * Come here if we have to do a CHS boot, but we get an error from
	 * BIOS get drive parameters, or it returns nsectors == 0 (in which
	 * case we can't do the division we need to convert LBA sector
	 * number to CHS).
	 */
cant_boot:
	movb	$PBR_CANT_BOOT, %al
	jmp	err_print_crlf

main:
	/* Set up stack */
	xorw	%ax, %ax
	movw	%ax, %ss
	movw	$BOOTSTACKOFF, %sp

	/* Set up needed data segment reg */
	pushw	%cs
	popw	%ds			/* Now %cs == %ds, != %ss (%ss == 0) */
d110 1
a110 1
	/* Initialize the serial port to 9600 baud, 8N1 */
d112 2
a113 2
	movw	$0x00e3, %ax
	movw	SERIAL, %dx
a121 39
	/*
	 * We're going to print our sign-on message.
	 *
	 * We're now LBA-aware, and will use LBA to load /boot if the
	 * BIOS says it's available.  However, we have seen machines
	 * where CHS is required even when LBA is available.  Therefore
	 * we provide a way to force CHS use:
	 *
	 * If the SHIFT key is held down on entry, force CHS reads.
	 */
	movw	$load_msg+1, %si	/* "Loading" */
	movb	%dl, %dh

	/*
	 * BIOS call "INT 0x16 Get Keyboard Shift Flags
	 *	Call with	%ah = 0x02
	 *	Return:
	 *			%al = shift flags
	 *			%ah - undefined by many BIOSes
	 */
	movb	$0x02, %ah
	int	$0x16

	/*
	 * We provide the ability to force CHS use without having to hold
	 * down the SHIFT key each boot.  Just set the byte at force_chs
	 * to 1 (more accurately any value with either of the bottom two
	 * bits set, but the use of 1 is recommended).
	 */
force_chs = .+1
	orb	$0, %al

	testb	$0x3, %al		/* Either shift key down? */
	jz	no_force_chs

	decw	%si			/* "!Loading" indicates forced CHS */
	xorb	%dh, %dh		/* Pretend a floppy, so no LBA use */

no_force_chs:
d123 1
a123 5
	call	Lmessage

	/*
	 * We will use LBA reads if we have LBA support, so find out.
	 */
d125 8
a132 8
	/*
	 * But don't even try on floppies, OR if forcing to CHS.
	 *
	 * (We're really testing %dl, but use %dh so we can force the
	 * top bit to zero to force CHS boot.)
	 */
	testb	$0x80, %dh
	jz	no_lba
d134 11
a144 22
	/*
	 * BIOS call "INT 0x13 Extensions Installation Check"
	 *	Call with	%ah = 0x41
	 *			%bx = 0x55AA
	 *			%dl = drive (0x80 for 1st hd, 0x81 for 2nd, etc)
	 *	Return:
	 *			carry set: failure
	 *				%ah = error code (0x01, invalid func)
	 *			carry clear: success
	 *				%bx = 0xAA55 (must verify)
	 *				%ah = major version of extensions
	 *				%al   (internal use)
	 *				%cx = capabilities bitmap
	 *					0x0001 - extnd disk access funcs
	 *					0x0002 - rem. drive ctrl funcs
	 *					0x0004 - EDD functions with EBP
	 *				%dx   (extension version?)
	 */

	pushw	%dx			/* Save the drive number (%dl) */
	movw	$0x55AA, %bx
	movb	$0x41, %ah
d146 1
a146 1
	popw	%dx			/* Retrieve drive number */
d148 13
a160 119
	jc	no_lba			/* Did the command work? Jump if not */
	cmpw	$0xAA55, %bx		/* Check that bl, bh exchanged */
	jne	no_lba			/* If not, don't have EDD extensions */
	testb	$0x01, %cl		/* And do we have "read" available? */
	jz	no_lba			/* Again, use CHS if not */

	/* We have LBA support, so that's the vector to use */

	movw	$load_lba, load_fsblock
	jmp	get_going

no_lba:
	pushw	%dx

	/*
	 * BIOS call "INT 0x13 Function 0x08" to get drive parameters
	 *	Call with        %ah = 0x08
	 *                       %dl = drive (0x80 for 1st hd, 0x81 for 2nd...)
	 *       Return:
	 *                       carry set: failure
	 *                           %ah = err code
	 *                       carry clear: success
	 *                           %ah = 0x00
	 *                           %al = 0x00 (some BIOSes)
	 *                           %ch = 0x00 (some BIOSes)
	 *                           %ch = max-cylinder & 0xFF
	 *                           %cl = max sector | rest of max-cyl bits
	 *                           %dh = max head number
	 *                           %dl = number of drives
	 *                                 (according to Ralph Brown Int List)
	 */
	movb	$0x08, %ah
	int	$0x13			/* We need to know heads & sectors */

	jc	cant_boot		/* If error, can't boot */

	movb	%dh, maxheads		/* Remember this */

	andb	$0x3F, %cl
	jz	cant_boot
	movb	%cl, nsectors

	putc(CHAR_CHS_READ)		/* Indicate (subtly) CHS reads */

	popw	%dx			/* Retrieve the drive number */

get_going:
	/*
	 * Older versions of biosboot used to set up the destination
	 * segment, and increase the target offset every time a number
	 * of blocks was read.  That limits /boot to 64k.
	 *
	 * In order to support /boots > 64k, we always read to offset
	 * 0000 in the target segment, and just increase the target segment
	 * each time.
	 */

	/*
	 * We would do movl inodeblk, %eax  here, but that instruction
	 * is 4 bytes long; add 4 bytes for data takes 8 bytes.  Using
	 * a load immediate takes 6 bytes, and we just get installboot
	 * to patch here, rather than data anywhere else.
	 */
inodeblk = .+2
	movl	$0x90909090, %eax	/* mov $inodeblk, %eax */

	movw	$INODESEG, %bx		/* Where to put /boot's inode */

	/*
	 * %eax - filesystem block to read
	 * %bx  - target segment (target offset is 0000)
	 * %dl  - BIOS drive number
	 */
	call	*load_fsblock		/* This will crash'n'burn on errs */

	/*
	 * We now have /boot's inode in memory.
	 *
	 * /usr/include/ufs/ufs/dinode.h for the details:
	 *
	 * Offset  8 (decimal): 64-bit file size (only use low 32 bits)
	 * Offset 40 (decimal): list of NDADDR (12) direct disk blocks
	 * Offset 88 (decimal): list of NIADDR (3) indirect disk blocks
	 *
	 * NOTE: list of indirect blocks immediately follows list of
	 * direct blocks.  We use this fact in the code.
	 *
	 * We only support loading from direct blocks plus the first
	 * indirect block.  This is the same as the previous biosboot/
	 * installboot limit.  Note that, with default 16,384-bytes
	 * filesystem blocks, the direct block list supports files up
	 * to 192 KB.  /boot is currently around 60 KB.
	 *
	 * The on-disk format can't change (filesystems with this format
	 * already exist) so okay to hardcode offsets here.
	 *
	 * The nice thing about doing things with filesystem blocks
	 * rather than sectors is that filesystem blocks numbers have
	 * 32 bits, so fit into a single register (even if "e"d).
	 *
	 * Note that this code does need updating if booting from a new
	 * filesystem is required.
	 */
#define NDADDR	12
#define di_db	40			/* Not used; addr put in by instboot */
#define di_ib	88			/* Not used; run on from direct blks */

	/*
	 * Register usage:
	 *
	 * %eax - block number for load_fsblock
	 * %bx  - target segment (target offset is 0000) for load_fsblock
	 * %dl  - BIOS drive number for load_fsblock
	 * %esi - points to block table in inode/indirect block
	 * %cx  - number of blocks to load within loop (i.e. from current
	 *	  block list, which is either the direct block list di_db[]
	 *	  or the indirect block list)
	 * %di  - total number of blocks to load
	 */
d162 1
a162 22
	/*
	 * We would do movl inodedbl, %esi  here, but that instruction
	 * is 4 bytes long; add 4 bytes for data takes 8 bytes.  Using
	 * a load immediate takes 6 bytes, and we just get installboot
	 * to patch here, rather than in data anywhere else.
	 */
inodedbl = .+2
	movl	$0x90909090, %esi	/* mov $inodedbl, %esi */
					/* Now esi -> di_db[] */

nblocks = .+1
	movw	$0x9090, %di		/* mov nblocks, %di */
	movw	%di, %cx
	cmpw	$NDADDR, %cx
	jc	1f
	movw	$NDADDR, %cx
1:					/* %cx = min(nblocks, $NADDR) */

	movw	$(LOADADDR >> 4), %bx	/* Target segment for /boot */

load_blocks:
	putc(CHAR_BLOCK_READ)		/* Show progress indicator */
d164 1
d166 4
d171 2
a172 114
	/* Get the next filesystem block number into %eax */
	lodsl			/* %eax = *(%si++), make sure 0x66 0xad */

	pushal				/* Save all 32-bit registers */

	/*
	 * Read a single filesystem block (will almost certainly be multiple
	 * disk sectors)
	 *
	 * %eax - filesystem block to read
	 * %bx  - target segment (target offset is 0000)
	 * %dl  - BIOS drive number
	 */
	call	*load_fsblock		/* This will crash'n'burn on errs */

	popal				/* Restore 32-bit registers */

	/*
	 * We want to put addw fs_bsize_p, %bx, which takes 4 bytes
	 * of code and two bytes of data.
	 *
	 * Instead, use an immediate load, and have installboot patch
	 * here directly.
	 */
	/* Move on one filesystem block */
fs_bsize_p = .+2
	addw	$0x9090, %bx		/* addw $fs_bsize_p, %bx */

	decw	%di
	loop	load_blocks

	/* %cx == 0 ... important it stays this way (used later) */

	/*
	 * Finished reading a set of blocks.
	 *
	 * This was either the direct blocks, and there may or may not
	 * be indirect blocks to read, or it was the indirect blocks,
	 * and we may or may not have read in all of /boot.  (Ideally
	 * will have read in all of /boot.)
	 */
	orw	%di, %di
	jz	done_load		/* No more sectors to read */

	/* We have more blocks to load */

	/* We only support a single indirect block (the same as previous
	 * versions of installboot.  This is required for the boot floppies.
	 *
	 * We use a bit of the code to store a flag that indicates
	 * whether we have read the first indirect block or not.
	 *
	 * If we've already read the indirect list, we can't load this /boot.
	 *
	 * indirect	uint8	0 => running through load_blocks loop reading
	 *			direct blocks.  If != 0, we're reading the
	 *			indirect blocks.  Must use a field that is
	 *			initialised to 0.
	 */
indirect = .+2
	movw	$PBR_TOO_MANY_INDIRECTS, %ax	/* movb $PRB_TOO..., %al */
						/* movb indirect, %ah */
	orb	%ah, %ah
	jnz	err_print_crlf

	incb	indirect		/* No need to worry about wrap */
					/* around, as this will only be done */
					/* once before we fail */

	/* Okay, let's read in the indirect block */

	lodsl				/* Get blk num of 1st indirect blk */

	pushw	%bx			/* Remember where we got to */
	movw	$INODESEG, %bx
	call	*load_fsblock		/* This will crash'n'burn on errs */
	popw	%bx			/* Indirect blocks get added on to */
					/* just after where we got to */
	movl	$INODEOFF, %esi
	movw	%di, %cx		/* How many blocks left to read */

	jmp	load_blocks

done_load:
	puts(crlf)

	/* %cx == 0 from loop above... keep it that way */

	/*
	 * Check the magic signature at the beginning of /boot.
	 * Since /boot is now ELF, this should be 0xFF E L F.
	 */
	movw	$(LOADADDR >> 4), %ax	/* Target segment */
	movw	%ax, %es

	/*
	 * We cheat a little here, and only check the L and F.
	 *
	 * (Saves 3 bytes of code... the two signature bytes we
	 * don't check, and the operand size prefix that's not
	 * needed.)
	 */
	cmpw	$LFMAGIC, %es:2(,1)
	je	exec_boot

	movb	$PBR_BAD_MAGIC, %al

err_print:
	movw	$err_txt, %si
err_print2:
	movb	%al, err_id
err_stop:
	call	Lmessage
stay_stopped:
d174 1
d176 3
a178 1
	jmp	stay_stopped		/* Just to make sure :-) */
d180 1
a180 2
exec_boot:
	/* At this point we could try to use the entry point in
d190 4
a193 12
	/* %cx == 0 from loop above... keep it that way */

	/*
	 * We want to do movzbl %dl, %eax ; pushl %eax to zero-extend the
	 * drive number to 32 bits and pass it to /boot.  However, this
	 * takes 6 bytes.
	 *
	 * Doing it this way saves 2 bytes.
	 */
	pushw	%cx
	movb	%dl, %cl
	pushw	%cx
d195 2
d200 1
a203 208

/*
 * Load a single filesystem block into memory using CHS calls.
 *
 * Input:	%eax - 32-bit filesystem block number
 * 		%bx  - target segment (target offset is 0000)
 * 		%dl  - BIOS drive number
 *
 * Output:	block successfully read in (panics if not)
 *		all general purpose registers may have been trashed
 */
load_chs:
	/*
	 * BIOS call "INT 0x13 Function 0x2" to read sectors from disk into
	 * memory.
	 *	Call with        %ah = 0x42
	 *                       %ah = 0x2
	 *                       %al = number of sectors
	 *                       %ch = cylinder & 0xFF
	 *                       %cl = sector (0-63) | rest of cylinder bits
	 *                       %dh = head
	 *                       %dl = drive (0x80 for 1st hd, 0x81 for 2nd...)
	 *                       %es:%bx = segment:offset of buffer
	 *       Return:
	 *                       carry set: failure
	 *                           %ah = err code
	 *                           %al = number of sectors transferred
	 *                       carry clear: success
	 *                           %al = 0x0 OR number of sectors transferred
	 *                                 (depends on BIOS!)
	 *                                 (according to Ralph Brown Int List)
	 */

	/* Convert the filesystem block into a sector value */
	call	fsbtosector
	movl	lba_sector, %eax	/* we can only use 24 bits, really */

	movw	fs_bsize_s, %cx	/* sectors per filesystem block */

	/*
	 * Some BIOSes require that reads don't cross track boundaries.
	 * Therefore we do all CHS reads single-sector.
	 */
calc_chs:
	pushal
	movw	%bx, %es	/* Set up target segment */

	pushw	%dx		/* Save drive number (in %dl) */
	xorl	%edx, %edx
	movl	%edx, %ecx

nsectors = .+1
	movb	$0x90, %cl	/* movb $nsectors, %cl */
				/* Doing it this way saves 4-2 = 2 bytes code */
				/* bytes (no data, since we would overload) */

	divl	%ecx, %eax
				/* Now have sector number in %dl */
	pushw	%dx		/* Remember for later */

	xorl	%edx, %edx

maxheads = .+1
	movb	$0x90, %cl	/* movb $maxheads, %cl; 0 <= maxheads <= 255 */
				/* Doing it this way saves 4-2 = 2 code */
				/* bytes (no data, since we would overload */

	incw	%cx		/* Number of heads is 1..256, no "/0" worries */

	divl	%ecx, %eax
				/* Have head number in %dl */
				/* Cylinder number in %ax */
	movb	%al, %ch	/* Bottom 8 bits of cyl number */
	shlb	$6, %ah		/* Move up top 2 bits of cyl number */
	movb	%ah, %cl	/* Top 2 bits of cyl number in here */

	popw	%bx		/* (pushed %dx, but need %dl for now */
	incb	%bl		/* Sector numbers run from 1, not 0 */
	orb	%bl, %cl	/* Or the sector number into top bits cyl */

				/* Remember, %dl has head number */
	popw	%ax
				/* %al has BIOS drive number -> %dl */

	movb	%dl, %dh	/* Now %dh has head number (from 0) */
	movb	%al, %dl	/* Now %dl has BIOS drive number */

	xorw	%bx, %bx	/* Set up target offset */

	movw	$0x0201, %ax	/* %al = 1 - read one sector at a time */
				/* %ah = 2 - int 0x13 function for CHS read */

	call	do_int_13	/* saves us 1 byte :-) */

	/* Get the next sector */

	popal
	incl	%eax
	addw	$32, %bx	/* Number of segments/paras in a sector */
	loop	calc_chs

	ret

	/* read error */
read_error:
	movb	$PBR_READ_ERROR, %al
err_print_crlf:
	movw	$err_txt_crlf, %si
	jmp	err_print2


/*
 * Load a single filesystem block into memory using LBA calls.
 *
 * Input:	%eax - 32-bit filesystem block number
 * 		%bx  - target segment (target offset is 0000)
 * 		%dl  - BIOS drive number
 *
 * Output:	block successfully read in (panics if not)
 *		all general purpose registers may have been trashed
 */
load_lba:
	/*
	 * BIOS call "INT 0x13 Extensions Extended Read"
	 *	Call with	%ah = 0x42
	 *			%dl = drive (0x80 for 1st hd, 0x81 for 2nd, etc)
	 *			%ds:%si = segment:offset of command packet
	 *	Return:
	 *			carry set: failure
	 *				%ah = error code (0x01, invalid func)
	 *				command packet's sector count field set
	 *				to the number of sectors successfully
	 *				transferred
	 *			carry clear: success
	 *				%ah = 0 (success)
	 *	Command Packet:
	 *			0x0000	BYTE	packet size (0x10 or 0x18)
	 *			0x0001	BYTE	reserved (should be 0)
	 *			0x0002	WORD	sectors to transfer (max 127)
	 *			0x0004	DWORD	seg:offset of transfer buffer
	 *			0x0008	QWORD	starting sector number
	 */
	call	fsbtosector		/* Set up lba_sector & lba_sector+4 */

	/* movb	%dh, lba_count		<- XXX done by installboot */
	movw	%bx, lba_seg
	movw	$lba_command, %si
	movb	$0x42, %ah
do_int_13:
	int	$0x13
	jc	read_error

	ret


/*
 * Converts a given filesystem block number into a disk sector
 * at lba_sector and lba_sector+4.
 *
 * Input:	%eax - 32-bit filesystem block number
 *
 * Output:	lba_sector and lba_sector+4 set up
 *		XXX
 */
fsbtosector:
	/*
	 * We want to do
	 *
	 * movb	fsbtodb, %ch		/# Shift counts we'll need #/
	 * movb	$32, %cl
	 *
	 * which is 6 bytes of code + 1 byte of data.
	 *
	 * We'll actually code it with an immediate 16-bit load into %cx,
	 * which is just 3 bytes of data (saves 4 bytes).
	 */
fsbtodb = .+2
	movw	$0x9020, %cx		/* %ch = fsbtodb, %cl = 0x20 */

	pushl	%eax
	subb	%ch, %cl
	shrl	%cl, %eax
	movl	%eax, lba_sector+4
	popl	%eax

	movb	%ch, %cl
	shll	%cl, %eax

	/*
	 * And add p_offset, which is the block offset to the start
	 * of the filesystem.
	 *
	 * We would do addl p_offset, %eax, which is 5 bytes of code
	 * and 4 bytes of data, but it's more efficient to have
	 * installboot patch directly in the code (this variable is
	 * only used here) for 6 bytes of code (but no data).
	 */
p_offset = .+2
	addl	$0x90909090, %eax	/* addl $p_offset, %eax */

	movl	%eax, lba_sector
	jnc	1f

	incl	lba_sector+4
1:
	ret


d208 1
d211 2
a212 2
	lodsb			/* load a byte into %al */
	orb	%al, %al
d217 3
a219 3
/*
 *	Lchr: write the character in %al to console
 */
d221 11
a231 2
#ifdef SERIAL
	pushw	%dx
d233 1
a233 1
	xorw	%dx, %dx
d236 1
a236 8
	popw	%dx
#else
	pushw	%bx
	movb	$0x0e, %ah
	xorw	%bx, %bx
	incw	%bx		/* movw $0x01, %bx */
	int	$0x10
	popw	%bx
d239 1
d242 11
a252 42
	/* .data */

/* vector to the routine to read a particular filesystem block for us */
load_fsblock:
	.word	load_chs


/* This next block is used for the EDD command packet used to read /boot
 * sectors.
 *
 * lba_count is set up for us by installboot.  It is the number of sectors
 * in a filesystem block.  (Max value 127.)
 *
 * XXX The EDD limit of 127 sectors in one read means that we currently
 *     restrict filesystem blocks to 127 sectors, or < 64 KB.  That is
 *     effectively a 32 KB block limit, as filesystem block sizes are
 *     powers of two.  The default filesystem block size is 16 KB.
 *
 *     I say we run with this limitation and see where it bites us...
 */

lba_command:
	.byte	0x10			/* size of command packet */
	.byte	0x00			/* reserved */
fs_bsize_s:
lba_count:
	.word	0			/* sectors to transfer, max 127 */
	.word	0			/* target buffer, offset */
lba_seg:
	.word	0			/* target buffer, segment */
lba_sector:
	.long	0, 0			/* sector number */

load_msg:
	.asciz	"!Loading"
err_txt_crlf:
	.ascii	"\r\n"
err_txt:
	.ascii	"ERR "
err_id:
	.ascii	"?"
crlf:	.asciz	"\r\n"
@


1.28.8.6
log
@Merge with the trunk
@
text
@d575 2
a576 2
	sti				/* Ensure Ctl-Alt-Del will work */
	hlt				/* (don't require power cycle) */
@


1.27
log
@i386 bootblocks that work for 2.3. A tale too long to tell
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.26 1998/04/13 00:37:41 deraadt Exp $	*/
d67 1
@


1.26
log
@the problem is in /boot, not in biosboot
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.24 1998/04/03 19:09:18 deraadt Exp $	*/
d42 1
a42 1
#define	BLKCNT	14	/* Max without colliding with the partition table */
d57 1
a57 1
	data32;				\
d135 1
a135 1
#ifdef DEBUG
d159 1
a176 1
	putc('.')		/* show progress indicator */
d179 2
a180 1
	movzbl	%al, %ax
d210 1
a210 1
#ifdef DEBUG
d240 1
a240 1
	movw	$0x10, %eax
d248 1
a248 1
#ifdef	DEBUG
@


1.25
log
@Well, the changes make do not work
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.23 1998/03/30 07:00:29 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997 Michael Shalayeff
d42 1
a42 1
#define	BLKCNT	12	/* Max without colliding with the partition table */
d48 4
a51 3
#ifdef DEBUG
#define DBGMSG(msg)		\
	movb    $msg, %al;	\
d54 2
a55 5
#define GO_RELOC	'R'	/* running relocated code */
#define REAL2PROT	'P'	/* switch to protected mode */
#else /* !DEBUG */
#define DBGMSG(msg)	/* */
#endif /* !DEBUG */
d57 1
a57 1
	data32;			\
a58 1
	/* call	Lmessage */;	\
d62 1
a63 1

d96 10
a105 1
1:	/* set up stack (%ss:%esp) */
d107 1
a107 3
	# movw	$(BOOTREL >> 4), %ax
	.byte	0xb8
	.word	BOOTREL >> 4
a108 1
	movl	%ax, %es	/* relocate there */
d113 2
a114 1
	# movw	$BOOTSEG, %ax	/* we are here */
a117 24
	xorl	%si, %si
	xorl	%di, %di
	# movw	$0x100, %cx	/* 512 bytes to move */
	.byte	0xb9
	.word	0x100
	cld
	rep;	movsl

	/* jump to relocated code */
	data32
	ljmp $(BOOTREL >> 4), $2f
1:	.asciz	"loading /boot"

2:	DBGMSG(GO_RELOC)

	nop
	/* set up %ds */
	pushl	%cs
	popl	%ds

	/* set up %es, (where we will load /boot to) */
	# movw	$(LOADADDR >> 4), %ax
	.byte	0xb8
	.word	LOADADDR >> 4
d119 2
d134 13
a146 1
	puts(1b)
d176 1
a176 4
	movb	$'.', %al
	# call	Lchr		/* show progress indicator */
	.byte	0xe8
	.word	Lchr - . - 2
d202 9
a210 6
3:
#if notdef
	data32;es;lodsl	/* text size */
	data32;es;lodsl	/* data size */
	data32;es;lodsl	/* bss  size */
	data32;es;lodsl	/* syms size */
a211 4
	data32
	addl	16(%esi), %edi	/* entry */

	DBGMSG(REAL2PROT)
d233 1
a233 1
	ljmp	$8, $1f+BOOTREL
d237 1
a237 1
	 * set up %ds, %ss, %es
d325 1
a325 1
	.long	BOOTREL + 1b
d334 1
a334 1
	# . = _block_table + BLKCNT*4
@


1.24
log
@new changes from weingart: -DDEBUG not needed anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.22 1998/02/24 22:06:39 weingart Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997 Michael Shalayeff, Tobias Weingartner
d42 1
a42 1
#define	BLKCNT	14	/* Max without colliding with the partition table */
d48 3
a50 4

/* Clobbers %al - maybe more */
#define putc(c)			\
	movb	$c, %al;	\
d53 5
a57 2

/* Clobbers %esi - maybe more */
d59 1
a59 1
	data32;				\
d61 1
d65 1
a66 1
	.text
d99 1
a99 10
1:
	/* Fix up %cs just in case */
	data32
	ljmp	$BOOTSEG, $1f

load_msg:
	.asciz	"reading boot"

1:
	/* set up stack (%ss:%esp) */
d101 3
a103 1
	xorl	%ax, %ax
d105 1
d110 1
a110 2
	/* Set up other segment regs */
	# movw	$BOOTSEG, %ax
d114 24
a138 2
	movl	%ax, %fs
	movl	%ax, %gs
d152 1
a152 13

#ifdef DEBUG
	putc('R')
#endif

	/* Print pretty message */
	puts(load_msg)

	/* set up %es, (where we will load /boot to) */
	# movw	$(LOADADDR >> 4), %ax
	.byte	0xb8
	.word	LOADADDR >> 4
	movl	%ax, %es
d182 4
a185 1
	putc('.')		/* show progress indicator */
d211 9
d221 1
a221 9
3:	/* At this point we could try to use the entry point in
	 * the image we just loaded.  But if we do that, we also
	 * have to potentially support loading that image where it
	 * is supposed to go.  Screw it, just assume that the image
	 * is sane.
	 */
#ifdef DEBUG
	putc('P')
#endif
d243 1
a243 1
	ljmp	$8, $(BOOTSEG << 4) + 1f
d247 1
a247 1
	 * set up %ds, %ss, %es, etc
d335 1
a335 1
	.long	(BOOTSEG << 4) + 1b
d344 1
a344 1
	. = _block_table + BLKCNT*4
@


1.23
log
@temporary fixes to the bootblocks
@
text
@d4 1
a4 1
 * Copyright (c) 1997 Michael Shalayeff
d42 1
a42 1
#define	BLKCNT	12	/* Max without colliding with the partition table */
d48 4
a51 3
#ifdef DEBUG
#define DBGMSG(msg)		\
	movb    $msg, %al;	\
d54 2
a55 5
#define GO_RELOC	'R'	/* running relocated code */
#define REAL2PROT	'P'	/* switch to protected mode */
#else /* !DEBUG */
#define DBGMSG(msg)	/* */
#endif /* !DEBUG */
d57 1
a57 1
	data32;			\
a58 1
	/* call	Lmessage */;	\
d62 1
a63 1

d96 10
a105 1
1:	/* set up stack (%ss:%esp) */
d107 1
a107 3
	# movw	$(BOOTREL >> 4), %ax
	.byte	0xb8
	.word	BOOTREL >> 4
a108 1
	movl	%ax, %es	/* relocate there */
d113 2
a114 1
	# movw	$BOOTSEG, %ax	/* we are here */
a117 24
	xorl	%si, %si
	xorl	%di, %di
	# movw	$0x100, %cx	/* 512 bytes to move */
	.byte	0xb9
	.word	0x100
	cld
	rep;	movsl

	/* jump to relocated code */
	data32
	ljmp $(BOOTREL >> 4), $2f
1:	.asciz	"loading /boot"

2:	DBGMSG(GO_RELOC)

	nop
	/* set up %ds */
	pushl	%cs
	popl	%ds

	/* set up %es, (where we will load /boot to) */
	# movw	$(LOADADDR >> 4), %ax
	.byte	0xb8
	.word	LOADADDR >> 4
d119 2
d134 13
a146 1
	puts(1b)
d176 1
a176 4
	movb	$'.', %al
	# call	Lchr		/* show progress indicator */
	.byte	0xe8
	.word	Lchr - . - 2
d202 9
a210 6
3:
#if notdef
	data32;es;lodsl	/* text size */
	data32;es;lodsl	/* data size */
	data32;es;lodsl	/* bss  size */
	data32;es;lodsl	/* syms size */
a211 4
	data32
	addl	16(%esi), %edi	/* entry */

	DBGMSG(REAL2PROT)
d233 1
a233 1
	ljmp	$8, $1f+BOOTREL
d237 1
a237 1
	 * set up %ds, %ss, %es
d325 1
a325 1
	.long	BOOTREL + 1b
d334 1
a334 1
	# . = _block_table + BLKCNT*4
@


1.22
log
@Changes/updates to /boot stuff.  More to come.
Fixes many divide by zero and pointer bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.21 1997/11/05 02:12:54 mickey Exp $	*/
a41 1
#ifdef	DEBUG
a42 3
#else
#define	BLKCNT	16
#endif
d252 3
@


1.21
log
@define puts()
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.20 1997/09/05 17:58:49 mickey Exp $	*/
d97 1
a97 1
	.asciz	"NO LABEL  "
d182 1
a182 1
	jmp	5f
d210 1
a210 1
5:
@


1.20
log
@copycenter
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.19 1997/08/29 22:26:58 mickey Exp $	*/
d62 6
d156 1
a156 6

	data32
	movl	$1b, %esi
	# call	Lmessage
	.byte	0xe8
	.word	Lmessage - . - 2
d181 1
a181 2
       	data32
	movl    $2f, %esi
d198 1
a198 5
	data32
	movl    $2f, %esi	/* new line */
	# call	Lmessage
	.byte	0xe8
	.word	Lmessage - . - 2
d209 1
a209 2
	data32
	movl	$1f, %esi
a210 3
	# call	Lmessage
	.byte	0xe8
	.word	Lmessage - . - 2
@


1.19
log
@ifdef partition table and NT s# w/ BEMBR
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.18 1997/08/29 21:16:48 mickey Exp $	*/
d3 31
@


1.18
log
@use symbolic name for signature value
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.17 1997/08/29 20:10:56 mickey Exp $	*/
d315 3
a317 1
	.globl	_block_table
d322 1
a322 4
	. = _block_table + BLKCNT*4
	.globl	_block_count
_block_count:
	.byte	BLKCNT	/* entries in _block_table */
d324 7
d344 1
a344 1
	
@


1.17
log
@don't need NT stuff here, since we are mbr when we have the whole disk
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.16 1997/08/29 19:47:23 mickey Exp $	*/
d341 1
a341 1
	.word	0xaa55
@


1.16
log
@don't use private defines, use ones exported from includes
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.15 1997/08/13 04:03:28 mickey Exp $	*/
a324 2
	. = 0x1b8
	.space	4, 0	/* (MBR) NT registry offset from James C. Cortilier III */
@


1.15
log
@split off START into LINKADDR and LOADADDR (we will need reloctable boot)
BOOTREL as a linear address, not segment one
more heap (;
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.14 1997/08/07 09:07:54 niklas Exp $	*/
a20 6
/*
 * Partition table values
 */
#define BOOTABLE	0x80	/* flag of boot_ind, means bootable partition */
#define OPENBSDPART	0xA6	/* OpenBSD partition type */

d327 1
a327 1
	. = 446
d332 1
a332 1
	.byte   BOOTABLE, 0, 1, 0,OPENBSDPART, 255, 255, 255
@


1.14
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.13 1997/07/31 20:04:40 mickey Exp $	*/
d74 1
a74 1
	# movw	$BOOTREL, %ax
d76 1
a76 1
	.word	BOOTREL
d97 1
a97 1
	ljmp $BOOTREL, $2f
d108 1
a108 1
	# movw	$(START >> 4), %ax
d110 1
a110 1
	.word	START >> 4
d230 1
a230 1
	ljmp	$8, $1f+(BOOTREL << 4)
d251 1
a251 1
	ljmp	$8, $(START + 0x20)
d319 1
a319 1
	.long	(BOOTREL << 4) + 1b
@


1.13
log
@more locals, returns, savings, gifts, and discounts
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.12 1997/07/30 19:40:45 flipk Exp $	*/
d323 1
a323 1
	.word	0	/* cyllinder/sector */
@


1.12
log
@mickey has pieces he has not committed.
if he puts the tree in an unbuildable state again..
anyway, all these problems came from the fact that etc/genassym.cf
wasn't even being used, and assym.h is where key defines were supposed
to be coming from. now we actually include etc/genassym.cf in the
genassym.sh processing, and remove the #includes i had in place to
work around it. now if mickey had committed machine/biosvar.h, etc/Makefile,
and these asm files all at the same time, there wouldn't have been
a problem....
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.11 1997/07/29 16:48:38 flipk Exp $	*/
a5 3
#define _LOCORE
#include <machine/segments.h>
#undef _LOCORE
d24 2
a25 2
BOOTABLE=	0x80	# value of boot_ind, means bootable partition
OPENBSDPART=	0xA6	# OpenBSD partition type
d31 1
a31 1
	.word	Lchr
d35 1
a35 1
#define DBGMSG(msg)
d102 1
d130 1
a130 1
	.word	Lmessage - .
d157 1
a157 1
	jmp	halt
d164 1
a164 1
	.word	Lchr
d177 1
a177 1
	.word	Lmessage - .
d190 1
a190 1
halt:
d193 1
a193 1
	.word	Lmessage - .
d254 16
a295 20
	data32
	popl	%eax
	data32
	ret

/*
 * Display string
 */
Lmessage:
	data32
	pushl	%eax
	cld
1:
	lodsb			# load a byte into %al
	testb	%al, %al
	jz	1f
	# call	Lchr
	.byte	0xe8
	.word	Lchr - .
	jmp	1b
a298 1
	data32
d302 1
a302 1
gdt:		/* 0x00 : null */
d318 2
a319 2
Gdtr:	.word	. - gdt
	.long	(BOOTREL << 4) + gdt
@


1.11
log
@Test before you Commit!!
1) missing include files in biosboot.S and gidt.S
2) macros in apm_init.S, biosdisk.S, gidt.S wrong case
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.10 1997/07/28 23:02:17 mickey Exp $	*/
a5 2
#include <machine/param.h>
#include <machine/specialreg.h>
@


1.10
log
@use assym.h
poke BPBs in for bios and dos
some values have to be filled out by fdisk/installboot
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.9 1997/05/29 04:31:48 mickey Exp $	*/
d6 5
@


1.9
log
@add small piece of NT support from James C. Cortilier III
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.8 1997/04/29 00:10:05 mickey Exp $	*/
d6 1
a6 4
#include <machine/specialreg.h>
#define _LOCORE
#include <machine/segments.h>
#undef _LOCORE
d11 5
a15 2
/* Better use 32, 48 does not seem to compile */
#define	BLKCNT	20	/* Max without colliding with the partition table */
d30 2
a31 2
	data32;			\
	call    chr
d42 31
a72 1
	/* set up stack (%ss:%esp) */
d127 3
a129 2
	data32
	call	message
d161 3
a163 2
	data32
	call	chr		/* show progress indicator */
d174 3
a176 2
	data32
	call	message
d190 3
a192 2
	data32
	call	message
d254 1
a254 1
#	chr: write the character in %al to console
d256 1
a256 1
chr:
d287 1
a287 1
message:
d295 3
a297 2
	data32
	call	chr
d336 1
a336 1
	.space	4, 0	/* NT registry offset from James C. Cortilier III */
@


1.8
log
@.mk changes faster then i type....
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.7 1997/04/15 08:00:44 deraadt Exp $	*/
d300 2
@


1.7
log
@partition table in biosboot too. Max 28 BLKCNT, too
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.5 1997/04/14 10:58:31 deraadt Exp $	*/
d15 1
a15 8
#define	BLKCNT	28		/* Max without colliding with the partition table */
#if 0
#ifdef	DEBUG
#define	BLKCNT	32
#else
#define	BLKCNT	48
#endif
#endif
@


1.6
log
@no need for partition table....
mbr is for that stuff.....
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.4 1997/04/11 19:09:59 weingart Exp $	*/
d15 3
d19 4
d28 6
d307 15
a321 1
	. = 0x200 - 4
d323 1
a323 2
	.ascii	"boot"

@


1.5
log
@add signature! fake partition 0 for floppy until fdisk(8) has -f flag. max 16 BLKCNT
@
text
@a14 3
#define	BLKCNT	16
#if 0
#ifdef	DEBUG
a15 4
#else
#define	BLKCNT	48
#endif
#endif
d294 1
a294 15
	/* partitions 0 */
	. = 446
	.globl	_partitions
_partitions:
	.word	0x0080
	.word	0x0001
	.word	0x01a6
	.word	0x4f12
	.word	0x0000
	.word	0x0000
	.word	0x0b40
	.word	0x0000
	.word	0x0000
	
	. = 0x200 - 2
d296 2
a297 1
	.word	0xaa55
@


1.4
log
@Works with .gz kernels now
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.3 1997/03/31 23:06:19 mickey Exp $	*/
d15 1
a15 1
#define	BLKCNT	32
d301 15
a315 1
	. = 0x200 - 4
d317 1
a317 2
	.ascii	"boot"

@


1.3
log
@commit all my mods to the last imported libsa stuff....
including:
- disklabel support;
- better boot cmd line
- smaller size (using some compilation switches ;)
- no more relocations in /boot, it's loaded in the place;
- better disk performance (maybe were already in there)
- installboot -n does not require write perms for device
- more debugs
- missing parts in libsa (such as cd9660 and so)
- i don't like 2 files for exec_i386 (sorry, toby, let's discuss maybe?)
tricks and tails:
- joined .text and .data (saves you a page)
- prot mode switching still in biosboot (it's freezed for awhile)
- biosdisk internals changed
- biosdev is not passed propery to the kernel (i'll fix it soon)
- sure i missed smth here to note (use the source, Luke!)
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.1.2.5 1997/02/07 07:11:01 mickey Exp $	*/
d14 3
d21 1
@


1.2
log
@Initial /boot stuff (from Mickey)
@
text
@d20 2
a21 3
#define BIOSSEG		0x07c0	/* boot loaded here */
#define BOOTSEG		0x1000	/* /boot placement */
#define BOOTSTACK	0xfffc	/* /boot stack */
d29 2
a30 2
#define CHAR_M	'M'	/* magic check */
#define CHAR_P	'P'	/* switch to protected mode */
d39 1
a39 6
	/* adjust %cs */
	data32
	ljmp $BIOSSEG, $2f
1:	.asciz	"loading /boot"

2:	/* set up stack (%ss:%esp) */
d41 3
a43 2
	data32
	movl	$BOOTSEG, %ax
d45 1
d50 18
a67 2
	/* set up %es, (where we will load /boot to) */
	movl	%ax, %es
d73 6
d82 6
a87 3
	movl	$0x00e3, %ax
	data32
	movl	SERIAL, %edx
d102 3
a104 2
	data32
	movl	$_block_table, %esi
d107 1
a107 1
	pushl	%ecx
d131 1
a131 2
	data32
	movzbl	%al, %eax
d134 1
a134 1
	popl	%ecx
d142 1
a142 5
#if 0
	DBGMSG(CHAR_M)
#endif

	xorl	%esi, %esi
d167 1
a167 2
#if 0
	data32;addr32
a168 3
	data32
	subl	$REL, %edi
#endif
d170 1
a170 3
#if 0
	DBGMSG(CHAR_P)
#endif
d192 1
a192 1
	ljmp	$8, $1f+(BIOSSEG << 4)
d198 1
a198 1
	movl	$0x10, %eax
a200 3
	movl	%ax, %es
	movl	%ax, %fs
	movl	%ax, %gs
a202 1
#if 0
d204 1
a204 1
	movl	$0xb8000, %ebx
a206 1
#endif
d210 1
a210 18

#if 0
#ifdef DEBUG
	movl	$0x10000, %ebx
	movl	(%ebx), %ecx
	/* cmpw $ZMAGIC, %ax */
	.byte	0x3d
	.word	ZMAGIC
je	1f
	movl	$0xb8004, %ebx
	movl	$0x07500748, (%ebx)
	jne	2f
1:
	movl	$0xb8004, %ebx
	movl	$0x074f0747, (%ebx)
2:
#endif
#endif
d213 1
a213 1
	ljmp	$0x8, $(REL << 4) + 0x20
a266 3
	.align	2
Gdtr:	.word	3 * 8 - 1
	.long	(BIOSSEG << 4) + 2f
d268 1
a268 1
2:		/* 0x00 : null */
d284 2
@


1.1
log
@file biosboot.S was initially added on branch new.
@
text
@d1 312
@


1.1.2.1
log
@new hierarchy. raw /boot loading, just 1(one) boot stage.
@
text
@a0 265
/*	$OpenBSD: start.S,v 1.4.2.5 1996/10/28 12:14:29 mickey Exp $	*/

	.file	"bootbios.S"

#include <machine/asm.h>
#include <machine/specialreg.h>

#define addr32  .byte 0x67
#define data32  .byte 0x66

#define	BLKCNT	48

#define BOOTSEG		0x6000	/* boot placement */
#define BOOTSTACK	0xfffc	/* boot stack */

#ifdef DEBUG
#define DBGMSG(msg)		\
	movb    $msg, %al;	\
	data32;			\
	call    chr
#else /* !DEBUG */
#define DBGMSG(msg)
#endif /* !DEBUG */

	.text

	.globl	start
start:
	# start (aka boot1) is loaded at 0x0:0x7c00 but we want 0x6c0:0x1000
	# ljmp to the next instruction to adjust %cs
	data32
	ljmp $0x7c0, $2f
1:	.asciz	"loading /boot"

2:	/* set up stack(%ss:%esp) */
	cli			/* disable interrupts w/o stack */
	data32
	movl	$BOOTSEG, %ax
	movl	%ax, %ss
	data32
	movl	$BOOTSTACK, %esp
	sti			/* we have stack, do ints */

	/* set up %es, (where we will load /boot to) */
	movl	%ax, %es

	/* set up %ds */
	pushl	%cs
	popl	%ds


#ifdef SERIAL
	# Initialize the serial port to 9600 baud, 8N1.
	pushl	%dx
	movl	$0x00e3, %ax
	movl	SERIAL, %dx
	int	$0x14
	popl	%dx
#endif

	data32
	movl	$1b, %esi
	data32
	call	message

	data32
	xorl	%ebx, %ebx		/* put it at %es:0 */
	addr32
	movb	_block_count, %cl	/* how many to read */
	movzbl	%cl, %ecx
	decl	%ecx			/* loop requires sizeof()-1 */
	data32
	movl	$_block_table, %esi

1:
	pushl	%ecx
/*
# BIOS call "INT 0x13 Function 0x2" to read sectors from disk into memory
#       Call with       %ah = 0x2
#                       %al = number of sectors
#                       %ch = cylinder
#                       %cl = sector
#                       %dh = head
#                       %dl = drive (0x80 for hard disk, 0x0 for floppy disk)
#                       %es:%bx = segment:offset of buffer
#       Return:
#                       %al = 0x0 on success; err code on failure
*/
	movb	$'.', %al
	data32
	call	chr		/* show progress indicator */
	# movb	(%si), %al
	.byte   0x8a, 0x44, 0	/* # of sectors to load */
	incl	%esi
	# movb	(%si), %dh
	.byte   0x8a, 0x74, 0	/* head */
	incl	%esi
	# movw	(%si), %cx
	.byte   0x8b, 0x4c, 0	/* cylinder/sector */
	incl	%esi
	incl	%esi
	movb	$0x2, %ah
	int	$0x13
	jnc	4f
	/* read error */
       	data32
	movl    $2f, %esi
	data32
	call	message
	cli
	hlt
2:	.ascii	"Read error"
3:	.asciz	"\r\n"
4:	/* read next block */
	shll	$1, %ax
	addb	%al, %bh
	popl	%ecx
	loop	1b

       	data32
	movl    $3b, %esi	/* new line */
	data32
	call	message

	/* change to protected mode */
	/* guarantee that interrupt is disabled when in prot mode */
	cli

	/* load the gdtr */
	addr32
	data32
	lgdt	Gdtr

	/* set the PE bit of CR0 */
	movl	%cr0, %eax
	data32
	orl	$CR0_PE, %eax
	movl	%eax, %cr0 

	/*
	 * make intrasegment jump to flush the processor pipeline and
	 * reload CS register
	 */
	data32
	ljmp	$0x18, $1f

1:	/*
	 * USE16 mode
	 * set up the protected mode segment registers : DS, SS, ES
	 */
	movb	$0x10, %al
	movzbl	%al, %eax
	movl	%ax, %ds
	movl	%ax, %ss
	movl	%ax, %es

	data32
	movzbl	%dl, %edx	/* discard head (%dh) and random high bits */
	data32
	pushl	%edx

	/* jump to the /boot and switch in USE32 mode */
	/* ljmp $0x08, _entry_point */
	data32
	.byte	0xea
	.globl	_entry_point
_entry_point:
	.long	0	/* /boot entry point */
	.word	0x0008	/* flat code */

#
#	chr: write the character in %al to console
#
chr:
/*
#ifndef SERIAL
# BIOS call "INT 10H Function 0Eh" to write character to console
#	Call with	%ah = 0x0e
#			%al = character
#			%bh = page
#			%bl = foreground color
#else
# BIOS call "INT 14H Function 01h" to write character to console
#	Call with	%ah = 0x01
#			%al = character
#			%dx = port number
#endif
*/
	data32
	pushl	%eax

#ifndef SERIAL
	data32
	pushl	%ebx
	movb	$0x0e, %ah
	xorl	%bx, %bx
	incl	%bx		/* movw $0x01, %bx */
	int	$0x10
	data32
	popl	%ebx
#else
	data32
	pushl	%edx
	movb	$0x01, %ah
	xorl	%dx, %dx
	movb	SERIAL, %dl
	int	$0x14
	data32
	popl	%edx
#endif
	data32
	popl	%eax
	data32
	ret

/*
 * Display string
 */
message:
	data32
	pushl	%eax
	cld
1:
	lodsb			# load a byte into %al
	testb	%al, %al
	jz	1f
	data32
	call	chr
	jmp	1b
1:
	data32
	popl	%eax
	data32
	ret

Gdtr:
	.word	2f + 4 * 8 - 1
	.long	2f
2:	/* Gdt */
	.word	0, 0
	.byte	0, 0, 0, 0		/* 0x0 : null */
	.word	0xFFFF, 0
	.byte	0, 0x9E, 0xCF, 0	/* 0x08 : flat code */
		/* 0x9F? */
	.word	0xFFFF, 0
	.byte	0, 0x92, 0xCF, 0	/* 0x10 : flat data */
		/* 0x93? */
	.word	0xFFFF, 0x7c00
	.byte	0, 0x9E, 0x00, 0	/* 0x18 : boot code 16 bits */

	.align	2
	.globl	_block_table
_block_table:
	.byte	0	/* nsect */
	.byte	0	/* head */
	.word	0	/* cyllinder/sector */
	. = _block_table + BLKCNT*4
	.globl	_block_count
_block_count:
	.byte	BLKCNT	/* entries in _block_table */

	/* a little signature */
	. = 0x200 - 4
	.ascii	"boot"

@


1.1.2.2
log
@protected mode problems fixed for biosboot (now it works!!!)
libsa.a(cd9660.o) requires libkern.a -- removed from conf.c
installboot changed according to the biosboot changes.
-Wall in libsa/Makefile, cleanup!
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.1.2.1 1996/12/03 13:16:54 mickey Exp $	*/
a6 3
#define _LOCORE
#include <machine/segments.h>
#undef _LOCORE
d13 2
a14 3
#define BIOSSEG		0x07c0	/* boot loaded here */
#define BOOTSEG		0x1000	/* /boot placement */
#define BOOTSTACK	0xfffc	/* /boot stack */
d32 1
a32 1
	ljmp $BIOSSEG, $2f
a44 2
	# decl	%ax
	# decl	%ax		/* strip off a.out hdr (2par == 32 byte) */
d51 1
d82 1
a82 1
#                       %cl = sector/cylinder(2 high bits)
d92 10
a101 6

	lodsl	/* word */	/* cylinder/sector */
	movl	%ax, %cx
	lodsb			/* head */
	movb	%al, %dh
	lodsb			/* # of sectors to load */
a104 1

a113 1

a124 2
	/* TODO: check /boot integrity */

d126 1
a126 1
	/* guarantee that interrupts are disabled when in prot mode */
d145 1
a145 1
	ljmp	$8, $1f+(BIOSSEG << 4)
d148 1
a148 1
	 * USE32 mode
d151 2
a152 1
	movl	$0x10, %eax
d157 4
a160 2
	movb	%dl, %al	/* discard head (%dh) and random high bits */
	pushl	%eax
d162 4
a165 4
	hlt
	/* jump to the /boot */
	/* jmp _entry_point */
	.byte	0xe9
d169 1
d237 2
a238 2
	.word	3f - 1
	.long	(BIOSSEG << 4) + 2f
d240 11
a250 17
		/* 0x00 : null */
	.long	0, 0
		/* 0x08 : flat code */
	.word	0xFFFF			# lolimit
	.word	0			# lobase
	.byte	0			# midbase
	.byte	SDT_MEMERAC | 0 | 0x80	# RWXAC, dpl = 0, present
	.byte	0xf | 0 | 0x40 | 0x80	# hilimit, xx, 32bit, 4k granularity
	.byte	0			# hibase
		/* 0x10 : flat data */
	.word	0xFFFF			# lolimit
	.word	0			# lobase
	.byte	0			# midbase
	.byte	SDT_MEMRWA | 0 | 0x80	# RWA, dpl = 0, present
	.byte	0xf | 0 | 0x40 | 0x80	# hilimit, xx, 32bit, 4k granularity
	.byte	0			# hibase
3:
d254 2
a256 2
	.byte	0	/* head */
	.byte	0	/* nsect */
d262 1
a263 1
	/* a little signature */
@


1.1.2.3
log
@rewrite Makefile using <bsd.prog.mk>
check loaded /boot magic, call /boot, not jmp.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.1.2.2 1996/12/15 15:49:34 mickey Exp $	*/
a18 1
#define OMAGIC		0x0701	/* OMAGIC */
d49 2
d105 1
a105 1
	jnc	3f
d110 6
a115 2
	jmp	halt
2:	.asciz	"Read error\r\n"
d117 3
a119 3
3:	/* read next block */
	shll	$9, %ax		/* 512 bytes sectors */
	addl	%ax, %bx
d123 2
d126 1
a126 3
	xorl	%esi, %esi
	data32
	xorl	%eax, %eax
d128 1
a128 20
	/* check /boot integrity */
	es
	lodsl
	es
	lodsl
	# cmpw	$OMAGIC, %ax
	.byte	0x3d
	.word	OMAGIC
	je	3f

	data32
	movl	$1f, %esi
	jmp	halt
1:	.ascii	"Bad magic"
2:	.asciz	"\r\n"

3:	data32
	movl    $2b, %esi	/* new line */
	data32
	call	message
d164 1
d166 5
a170 6
	call	%es:20(%ebx)
halt:
	data32
	call	message
	cli
	hlt
@


1.1.2.4
log
@do the right call now.
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.1.2.3 1996/12/16 15:19:29 mickey Exp $	*/
d14 1
a14 1
#define	BLKCNT	40
d124 4
a127 1
	es;lodsl;es;lodsl	/* no need for high word */
a143 17
#if 0
	data32;es;lodsl	/* text size */
	data32;es;lodsl	/* data size */
	data32;es;lodsl	/* bss  size */
	data32;es;lodsl	/* syms size */
#else
	data32
	addl	$16, %esi
#endif
	data32
	es;lodsl		/* entry */
	data32
	addl	$0x20, %eax	/* struct exec */
	data32
	addr32
	movl	%eax, entry_point

d178 2
a179 5
	/* call	/boot */
	.byte	0x9a
entry_point:
	.long	0
	.word	8
d181 1
@


1.1.2.5
log
@latest changes and fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: biosboot.S,v 1.1.2.4 1997/01/03 21:44:32 mickey Exp $	*/
d14 1
a14 5
#ifdef	DEBUG
#define	BLKCNT	32
#else
#define	BLKCNT	48
#endif
d19 1
a19 1
#define ZMAGIC		0x0b01	/* ZMAGIC */
a25 2
#define CHAR_M	'M'	/* magic check */
#define CHAR_P	'P'	/* switch to protected mode */
d34 1
a34 1
	# start (aka boot1) is loaded at 0x0:0x7c00 but we want 0x7c0:0x0
d43 1
a43 1
	movl	$BOOTSEG+0x1000, %ax
d60 1
a60 2
	data32
	movl	SERIAL, %edx
a96 1
	cld
a102 1
	pushl	%ax
d110 1
a110 1
2:	.asciz	"\r\nRead error\r\n"
a112 3
	popl	%ax
	data32
	movzbl	%al, %eax
d119 1
a119 1
	movl    $2f, %esi	/* new line */
d121 1
a121 3
	call	message

	DBGMSG(CHAR_M)
a122 3
	cld
	data32
	xorl	%esi, %esi
d125 1
a125 1
	# cmpw	$ZMAGIC, %ax
d127 1
a127 1
	.word	ZMAGIC
d135 6
a140 1
3:
d146 3
a149 2
	es;data32;addr32
	movl	16(%esi), %edi	/* entry */
d151 6
a156 3
	addl	32, %edi	/* struct exec */

	DBGMSG(CHAR_P)
d187 1
a187 2
	movl	$(BOOTSEG << 4) + 0x10000 + BOOTSTACK, %eax
	movl	%eax, %esp
d189 1
a189 1
	movzbl	%dl, %eax	/* discard head (%dh) and random high bits */
a191 5
#ifdef	DEBUG
	movl	$0xb8000, %ebx
	movw	$0x4740, (%ebx)
#endif

d193 4
a196 2
	call	(%edi)
	jmp	1f
d199 1
a199 1
1:	cli
d201 1
d267 2
a268 2
	.align	2
Gdtr:	.word	3 * 8 - 1
d270 2
a271 2
	.align	3
2:		/* 0x00 : null */
d287 2
a288 1

@

