head	1.17;
access;
symbols
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	UBC_SYNC_A:1.17
	UBC_SYNC_B:1.17
	SMP:1.17.0.2
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8;
locks; strict;
comment	@ * @;


1.17
date	97.09.21.10.02.10;	author mickey;	state dead;
branches;
next	1.16;

1.16
date	97.09.02.21.37.38;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	97.08.22.00.41.27;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	97.08.21.22.04.31;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	97.08.13.04.35.42;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.08.06.18.45.01;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.07.21.15.36.17;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.07.18.00.52.08;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.05.31.15.48.24;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.04.26.17.50.07;	author mickey;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	97.04.21.20.03.30;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.04.14.10.48.04;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.04.05.23.27.35;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.04.04.04.47.45;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.03.31.23.06.20;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	97.03.31.03.12.03;	author weingart;	state Exp;
branches;
next	1.1;

1.1
date	96.12.03.13.16.57;	author mickey;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	96.12.03.13.16.58;	author mickey;	state Exp;
branches;
next	;

1.8.2.1
date	97.06.01.09.53.04;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@/boot engine is in sys/stand/boot/ now (;
use it, reuse it, i can't imagine any brokenness ...
@
text
@/*	$OpenBSD: boot.c,v 1.16 1997/09/02 21:37:38 mickey Exp $	*/

/*
 * Copyright (c) 1997 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/stat.h>
#include <libsa.h>
#include "cmd.h"

const char *const kernels[] = {
	"/bsd",  "/bsd.gz",
	"/obsd", "/obsd.gz",
	NULL
};

extern	const char version[];
struct cmd_state cmd;

void
boot(bootdev)
	dev_t	bootdev;
{
	register const char *bootfile = kernels[0];
	register int i = 0, f;

	machdep();

	devboot(bootdev, cmd.bootdev);
	strncpy(cmd.image, bootfile, sizeof(cmd.image));
	cmd.boothowto = 0;
	cmd.conf = "/etc/boot.conf";
	cmd.addr = (void *)0x100000;
	cmd.timeout = 5;

	f = read_conf();

	printf(">> OpenBSD BOOT %s\n", version);

	while (1) {
		if (f <= 0) /* no boot.conf, or no boot cmd in there */
			do {
				printf("boot> ");
			} while(!getcmd());
		f = 0;

		printf("booting %s: ", cmd.path);
		exec(cmd.path, cmd.addr, cmd.boothowto);

		if (kernels[++i] == NULL)
			bootfile = kernels[i=0];
		else
			bootfile = kernels[i];

		cmd.timeout++;
		printf(" failed(%d). will try %s\n", errno, bootfile);
		strncpy(cmd.image, bootfile, sizeof(cmd.image));
	}
}

#ifdef _TEST
int
main()
{
	boot(0);
	return 0;
}
#endif
@


1.16
log
@dead vars
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.15 1997/08/22 00:41:27 mickey Exp $	*/
@


1.15
log
@theo said we don't need 'cd' command
remove c-r, it won't work anyways
fix c-u
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.14 1997/08/21 22:04:31 mickey Exp $	*/
a47 1
u_int	cnvmem, extmem;
@


1.14
log
@boothowto is local to boot
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.13 1997/08/13 04:35:42 mickey Exp $	*/
d42 2
a43 2
	"bsd",	"bsd.gz",
	"obsd",	"obsd.gz",
a63 1
	cmd.cwd[0] = '/'; cmd.cwd[1] = '\0';
@


1.13
log
@print boot message on the right console
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.12 1997/08/06 18:45:01 mickey Exp $	*/
a47 1
int	boothowto;
d60 1
d62 1
a66 1
	devboot(bootdev, cmd.bootdev);
d70 1
a70 1
	printf(">> OpenBSD BOOT: %u/%u k [%s]\n", cnvmem, extmem, version);
d80 1
a80 1
		exec(cmd.path, cmd.addr, boothowto);
@


1.12
log
@cmd is global anyways, don't pass it to handlers
add echo command
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.11 1997/07/21 15:36:17 mickey Exp $	*/
a60 2
	printf(">> OpenBSD BOOT: %u/%u k [%s]\n", cnvmem, extmem, version);

d69 3
@


1.11
log
@indent (;
supply fake arg for boot() in testing main()
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.10 1997/07/18 00:52:08 mickey Exp $	*/
d70 1
a70 1
	f = read_conf(&cmd);
d75 1
a75 1
			} while(!getcmd(&cmd));
@


1.10
log
@most of the stuff is no in libsa, very tiny srt0
boot calls machdep()
move to .bss again (;
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.9 1997/05/31 15:48:24 mickey Exp $	*/
d68 1
a69 1
	devboot(bootdev, cmd.bootdev);
d96 1
a96 1
	boot();
@


1.9
log
@usleep won't work on some weird laptops
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.8 1997/04/26 17:50:07 mickey Exp $	*/
a38 1
#include <debug.h>
d41 1
a41 1
char *kernels[] = {
d50 1
a50 3
struct cmd_state cmd = {
	"", "bsd", "/etc/boot.conf", "/", (void *)0x100000, 5, ""
};
d56 1
a56 1
	register char *bootfile = kernels[0];
d59 1
a59 12
#ifdef DEBUG
	*(u_int16_t*)0xb8148 = 0x4730;
#endif
	gateA20(1);
	cons_probe();	/* call console init before any io */
#ifndef _TEST
	memprobe();
#endif
#ifdef DEBUG
	*(u_int16_t*)0xb8148 = 0x4f31;
#endif
	debug_init();
d62 6
@


1.8
log
@boot.conf support
ttyname function in cons.c
rdonly var 'tty' to view tty settings
serial console soon
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.7 1997/04/21 20:03:30 mickey Exp $	*/
d52 1
a52 1
	"", "bsd", "/etc/boot.conf", "/", (void *)0x100000, 50, ""
d94 1
a94 1
		cmd.timeout += 20;
@


1.8.2.1
log
@2.1 laptop kbd fixes from mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.9 1997/05/31 15:48:24 mickey Exp $	*/
d52 1
a52 1
	"", "bsd", "/etc/boot.conf", "/", (void *)0x100000, 5, ""
d94 1
a94 1
		cmd.timeout++;
@


1.7
log
@rewrite command processing.
two levels of commands from now (set has it's own {device,image,addr,howto})
all the combinations of {device,path,image,options} is now possible on boot.
move cmd_state init into .data again, no more memory limits
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.6 1997/04/14 10:48:04 deraadt Exp $	*/
d52 1
a52 1
	"", "", "/", (void *)0x100000, 50, ""
d60 1
a60 1
	register int i = 0;
d66 1
a72 1
	cons_probe();
d78 1
d80 5
a84 5
		strncpy(cmd.image, bootfile, sizeof(cmd.image));

		do {
			printf("boot> ");
		} while(!getcmd(&cmd));
d96 1
@


1.6
log
@kill extra linefeeding
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.5 1997/04/05 23:27:35 mickey Exp $	*/
d51 3
a59 1
	register struct cmd_state *cmd;
d77 1
a77 9
	/* XXX init cmd here to cut on .data !!! */
	cmd = (struct cmd_state *)alloc(sizeof(*cmd));
	devboot(bootdev, cmd->bootdev);
	cmd->image[0] = '\0';
	cmd->cwd[0] = '/';
	cmd->cwd[1] = '\0';
	cmd->addr = (void *)0x100000;
	cmd->timeout = 50;

d79 1
a79 1
		strncpy(cmd->image, bootfile, sizeof(cmd->image));
d83 1
a83 4
		} while(!getcmd(cmd) && !execmd(cmd));

		if (cmd->rc < 0)
			break;
d85 2
a86 2
		printf("booting %s: ", cmd->path);
		exec(cmd->path, cmd->addr, boothowto);
d93 1
a93 1
		cmd->timeout += 20;
@


1.5
log
@devboot is no longer in boot.c
missed from last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.4 1997/04/04 04:47:45 mickey Exp $	*/
d42 5
a46 4
char *kernels[] = { "bsd",     "bsd.gz",
		    "obsd",    "obsd.gz",
		    "bsd.old", "bsd.old.gz",
		  NULL };
d58 1
a58 1
	register int i;
d73 1
a73 1
	printf("\n>> OpenBSD BOOT: %u/%u k [%s]\n", cnvmem, extmem, version);
d84 1
a84 2
	for (i = 0;;) {

d94 2
a95 2
		printf("\nbooting %s: ", cmd->path);
		exec (cmd->path, cmd->addr, boothowto);
d97 1
a97 1
		if(kernels[++i] == NULL)
d103 1
a103 2

		printf(" failed(%d)\nwill try %s\n", errno, bootfile);
@


1.4
log
@dump regs w/ NMI (int 2)
more debugging is on the way
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.3 1997/03/31 23:06:20 mickey Exp $	*/
a50 2
void	devboot __P((dev_t, char *));

a105 32
}

void
devboot(bootdev, p)
	dev_t bootdev;
	char *p;
{
#ifdef _TEST
	*p++ = '/';
	*p++ = 'd';
	*p++ = 'e';
	*p++ = 'v';
	*p++ = '/';
	*p++ = 'r';
#endif
	if (bootdev & 0x80)
		*p++ = 'h';
	else
		*p++ = 'f';
	*p++ = 'd';
#ifndef _TEST
	*p++ = '(';
#endif
	*p++ = '0' + (bootdev & 0x7f);
#ifndef _TEST
	*p++ = ',';
#endif
	*p++ = 'a';
#ifndef _TEST
	*p++ = ')';
#endif
	*p = '\0';
@


1.3
log
@commit all my mods to the last imported libsa stuff....
including:
- disklabel support;
- better boot cmd line
- smaller size (using some compilation switches ;)
- no more relocations in /boot, it's loaded in the place;
- better disk performance (maybe were already in there)
- installboot -n does not require write perms for device
- more debugs
- missing parts in libsa (such as cd9660 and so)
- i don't like 2 files for exec_i386 (sorry, toby, let's discuss maybe?)
tricks and tails:
- joined .text and .data (saves you a page)
- prot mode switching still in biosboot (it's freezed for awhile)
- biosdisk internals changed
- biosdev is not passed propery to the kernel (i'll fix it soon)
- sure i missed smth here to note (use the source, Luke!)
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.1.2.1 1996/12/03 13:16:58 mickey Exp $	*/
d39 1
d72 1
@


1.2
log
@Initial /boot stuff (from Mickey)
@
text
@d2 1
a37 2
#include <a.out.h>
#include <sys/disklabel.h>
d41 8
a48 19
/*
 * Boot program, loaded by boot block from remaing 7.5K of boot area.
 * Sifts through disklabel and attempts to load an program image of
 * a standalone program off the disk. If keyboard is hit during load,
 * or if an error is encounter, try alternate files.
 */

char *kernels[] = {
	"bsd", "bsd.gz",
	"obsd", "obsd.gz",
	"bsd.old", "bsd.old.gz",
	NULL
};

int	retry = 0;
extern	char version[];
extern dev_t bootdev;
extern int boothowto;
int	cnvmem, extmem, probemem;
d50 1
a50 2
void	boot ();
struct cmd_state cmd;
a51 4
/*
 * Boot program... loads /boot out of filesystem indicated by arguements.
 * We assume an autoboot unless we detect a misconfiguration.
 */
d53 2
a54 1
boot()
d57 1
d60 3
a62 4

	/* Get memory size */
	cnvmem = memsize(0);
	extmem = memsize(1);
d64 7
a70 1
	probemem = memprobe();
d72 1
d75 7
a81 15
	strncpy(cmd.bootdev,
#ifdef _TEST
		"/dev/rfd0a",
#else
		"fd(0,a)",
#endif
		sizeof(cmd.bootdev));
	cmd.image[0] = '\0';
	cmd.cwd[0] = '/';
	cmd.cwd[1] = '\0';
	cmd.addr = (void *)0x100000;
	cmd.timeout = 50000;

	printf("\n>> OpenBSD BOOT: %d/%d (%d) k [%s]\n",
		cnvmem, extmem, probemem, version);
d85 1
a85 1
		strncpy(cmd.image, bootfile, sizeof(cmd.image));
d89 4
a92 1
		} while(!getcmd(&cmd) && !execmd(&cmd));
d94 2
a95 3
		sprintf(cmd.path, "%s%s%s", cmd.bootdev, cmd.cwd, bootfile);
		printf("\nbooting %s: ", cmd.path);
		exec (cmd.path, cmd.addr, boothowto);
d102 1
a102 1
		cmd.timeout += 20;
d106 32
@


1.1
log
@file boot.c was initially added on branch new.
@
text
@d1 130
@


1.1.2.1
log
@new hierarchy. raw /boot loading, just 1(one) boot stage.
@
text
@a0 203
/*	$OpenBSD: boot.c,v 1.3.4.3 1996/10/29 09:15:46 mickey Exp $	*/
/*	$NetBSD: boot.c,v 1.6 1994/10/27 04:21:49 cgd Exp $	*/

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifdef lint
char copyright[] =
"@@(#) Copyright (c) 1990 The Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

#ifdef lint
#ifdef notdef
static char sccsid[] = "@@(#)boot.c	7.3 (Berkeley) 5/4/91";
#endif
static char rcsid[] = "$NetBSD: boot.c,v 1.6 1994/10/27 04:21:49 cgd Exp $";
#endif /* not lint */

#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/stat.h>
#include <a.out.h>
#include <sys/disklabel.h>
#include <libsa.h>

/*
 * Boot program, loaded by boot block from remaing 7.5K of boot area.
 * Sifts through disklabel and attempts to load an program image of
 * a standalone program off the disk. If keyboard is hit during load,
 * or if an error is encounter, try alternate files.
 */

char *kernels[] = { "bsd.z", "obsd.z", "bsd.old.z",
		  "bsd", "obsd", "bsd.old",
		  NULL };

int	retry = 0;
extern struct disklabel disklabel;
extern	char version[];
static unsigned char *biosparams = (char *) 0x9ff00; /* XXX */
int	cnvmem, extmem;

#ifndef HZ
#define HZ 100
#endif
int	hz = HZ;

void	copyunix (char*, int, long);
void	wait (int);

struct disklabel disklabel;

/*
 * Boot program... loads /boot out of filesystem indicated by arguements.
 * We assume an autoboot unless we detect a misconfiguration.
 */
void
boot(dev, unit, off)
{
	register struct disklabel *lp;
	register int io;
	register char **bootfile = kernels;
	int howto = 0;

	*((int *)0xb8004) = 0xa55a5aa5;
	asm("hlt");

	/* init system clock */
	/* startrtclock(); */

#ifdef	DEBUG
	printf("cyl %x %x hd %x sect %x ",
		biosparams[0], biosparams[1], biosparams[2], biosparams[0xe]);
	printf("dev %x unit %x off %d\n", dev, unit, off);
#endif

	/* are we a disk, if so look at disklabel and do things */
	lp = &disklabel;

	printf("\n"
		">> OpenBSD BOOT: %d/%d k [%s]\n"
		"use ? for file list, or carriage return for defaults\n"
		"use hd(1,a)/bsd to boot sd0 when wd0 is also installed\n",
		cnvmem, extmem, version);

	asm("hlt");

	if (lp->d_magic == DISKMAGIC) {
	    /*
	     * Synthesize bootdev from dev, unit, type and partition
	     * information from the block 0 bootstrap.
	     * It's dirty work, but someone's got to do it.
	     * This will be used by the filesystem primatives, and
	     * drivers. Ultimately, opendev will be created corresponding
	     * to which drive to pass to top level bootstrap.
	     */
	    for (io = 0; io < lp->d_npartitions; io++) {
		int sn;

		if (lp->d_partitions[io].p_size == 0)
			continue;
		if (lp->d_type == DTYPE_SCSI)
			sn = off;
		else
			sn = off * lp->d_secpercyl;
		if (lp->d_partitions[io].p_offset == sn)
			break;
	    }

	    if (io == lp->d_npartitions) goto screwed;
            cyloffset = off;
	} else {
screwed:
		/* probably a bad or non-existant disklabel */
		io = 0 ;
		howto |= RB_SINGLE|RB_ASKNAME ;
	}

	/* construct bootdev */
	/* currently, PC has no way of booting off alternate controllers */
	bootdev = MAKEBOOTDEV(/*i_dev*/ dev, /*i_adapt*/0, /*i_ctlr*/0,
	    unit, /*i_part*/io);

	for (;;) {

		copyunix(*bootfile, howto, off);

		if(*++bootfile == NULL) bootfile = kernels;
		printf("will try %s\n", *bootfile);

		wait(1<<((retry++) + 10));
	}
}

/*ARGSUSED*/
void
copyunix(name, howto, off)
	char	*name;
	int	howto;
	long	off;
{
	int	f;
	struct stat sb;
	char	*addr = NULL, *loadaddr;

	printf("loading %s: ", name);

	/* read file */
	if (stat(name, &sb) < 0)
		return;

	if ((f = open(name, 1)) < 0)
		return;

	/* exec */
	execz(addr, loadaddr, 0);

	return;
}

int
zread(f, loadaddr, size)
	int	f;
	void	*loadaddr;
	size_t	size;
{

	return -1;
}
@
