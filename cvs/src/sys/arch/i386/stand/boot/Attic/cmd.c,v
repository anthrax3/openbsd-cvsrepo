head	1.34;
access;
symbols
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	UBC_SYNC_A:1.34
	UBC_SYNC_B:1.34
	SMP:1.34.0.2
	OPENBSD_2_1:1.13.0.2
	OPENBSD_2_1_BASE:1.13;
locks; strict;
comment	@ * @;


1.34
date	97.09.21.10.02.11;	author mickey;	state dead;
branches;
next	1.33;

1.33
date	97.09.20.22.40.37;	author flipk;	state Exp;
branches;
next	1.32;

1.32
date	97.09.17.19.55.34;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	97.09.02.21.02.15;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	97.09.02.20.48.17;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	97.08.22.00.41.27;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	97.08.21.22.17.56;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	97.08.21.22.15.17;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	97.08.21.22.04.32;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	97.08.21.21.40.24;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	97.08.21.19.07.29;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	97.08.13.14.24.00;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	97.08.13.03.49.28;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	97.08.12.22.10.43;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	97.08.12.21.51.35;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	97.08.06.18.45.02;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	97.07.01.20.02.22;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	97.06.06.18.23.43;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	97.06.06.16.26.56;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	97.05.31.15.48.25;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	97.05.31.01.35.58;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	97.04.28.07.39.00;	author weingart;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	97.04.26.17.50.07;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.04.21.20.20.25;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.04.21.20.03.30;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.04.17.21.47.37;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.04.16.22.14.15;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.04.15.08.32.51;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.04.11.19.12.56;	author weingart;	state Exp;
branches;
next	1.5;

1.5
date	97.04.08.22.48.29;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.04.07.01.26.00;	author weingart;	state Exp;
branches;
next	1.3;

1.3
date	97.04.01.04.50.33;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	97.03.31.23.06.21;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	97.03.31.03.12.03;	author weingart;	state Exp;
branches;
next	;

1.13.2.1
date	97.06.01.09.53.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.34
log
@/boot engine is in sys/stand/boot/ now (;
use it, reuse it, i can't imagine any brokenness ...
@
text
@/*	$OpenBSD: cmd.c,v 1.33 1997/09/20 22:40:37 flipk Exp $	*/

/*
 * Copyright (c) 1997 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <libsa.h>
#include <biosdev.h>
#include <sys/reboot.h>
#include "cmd.h"

extern int debug;

#define CTRL(c)	((c)&0x1f)

static int Xaddr __P((void));
static int Xboot __P((void));
static int Xdevice __P((void));
#ifdef DEBUG
static int Xdebug __P((void));
#endif
static int Xhelp __P((void));
static int Ximage __P((void));
static int Xls __P((void));
static int Xreboot __P((void));
static int Xset __P((void));
static int Xstty __P((void));
static int Xhowto __P((void));
static int Xtty __P((void));
static int Xtime __P((void));
static int Xecho __P((void));
#ifdef MACHINE_CMD
static int Xmachine __P((void));
extern const struct cmd_table MACHINE_CMD[];
#endif

static const struct cmd_table cmd_set[] = {
	{"addr",   CMDT_VAR, Xaddr},
	{"howto",  CMDT_VAR, Xhowto},
#ifdef DEBUG	
	{"debug",  CMDT_VAR, Xdebug},
#endif
	{"device", CMDT_VAR, Xdevice},
	{"tty",    CMDT_VAR, Xtty},
	{"image",  CMDT_VAR, Ximage},
	{NULL,0}
};

static const struct cmd_table cmd_table[] = {
	{"boot",   CMDT_CMD, Xboot}, /* XXX must be first */
	{"echo",   CMDT_CMD, Xecho},
	{"help",   CMDT_CMD, Xhelp},
	{"ls",     CMDT_CMD, Xls},
#ifdef MACHINE_CMD
	{"machine",CMDT_MDC, Xmachine},
#endif
	{"reboot", CMDT_CMD, Xreboot},
	{"set",    CMDT_SET, Xset},
	{"stty",   CMDT_CMD, Xstty},
	{"time",   CMDT_CMD, Xtime},
	{NULL, 0},
};

extern const char version[];
static void ls __P((char *, register struct stat *));
static int readline __P((register char *, int));
char *nextword __P((register char *));
static int bootparse __P((int));
static char *whatcmd
	__P((register const struct cmd_table **ct, register char *));
static int docmd __P((void));
static char *qualify __P((char *));

static char cmd_buf[133];

int
getcmd()
{
	cmd.cmd = NULL;

	if (!readline(cmd_buf, cmd.timeout))
		cmd.cmd = cmd_table;

	return docmd();
}

int
read_conf()
{
#ifndef INSECURE
	struct stat sb;
#endif
	int fd, eof = 0;

	if ((fd = open(qualify(cmd.conf), 0)) < 0) {
		if (errno != ENOENT && errno != ENXIO) {
			printf("open(%s): %s\n", cmd.path, strerror(errno));
			return 0;
		}
		return -1;
	}

#ifndef INSECURE
	(void) fstat(fd, &sb);
	if (sb.st_uid || (sb.st_mode & 2)) {
		printf("non-secure %s, will not proceed\n", cmd.path);
		close(fd);
		return -1;
	}
#endif

	do {
		register char *p = cmd_buf;

		cmd.cmd = NULL;

		do
			eof = read(fd, p, 1);
		while (eof > 0 && *p++ != '\n');

		if (eof < 0)
			printf("%s: %s\n", cmd.path, strerror(errno));
		else
			*--p = '\0';

	} while (eof > 0 && !(eof = docmd()));

	close(fd);
	return eof;
}

static int
docmd()
{
	register char *p = NULL;
	const struct cmd_table *ct, *cs;

	cmd.argc = 1;
	if (cmd.cmd == NULL) {

		/* command */
		for (p = cmd_buf; *p && (*p == ' ' || *p == '\t'); p++)
			;
		if (*p == '#' || *p == '\0') { /* comment or empty string */
#ifdef DEBUG
			printf("rem\n");
#endif
			return 0;
		}
		ct = cmd_table;
		cs = NULL;
		cmd.argv[cmd.argc] = p; /* in case it's shortcut boot */
		p = whatcmd(&ct, p);
		if (ct == NULL) {
			cmd.argc++;
			ct = cmd_table;
		} else if (ct->cmd_type == CMDT_SET && p != NULL) {
			cs = cmd_set;
#ifdef MACHINE_CMD
		} else if (ct->cmd_type == CMDT_MDC && p != NULL) {
			cs = MACHINE_CMD;
#endif
		}

		if (cs != NULL) {
			p = whatcmd(&cs, p);
			if (cs == NULL) {
				printf("%s: syntax error\n", ct->cmd_name);
				return 0;
			}
			ct = cs;
		}
		cmd.cmd = ct;
	}

	cmd.argv[0] = ct->cmd_name;
	while (p && cmd.argc+1 < sizeof(cmd.argv) / sizeof(cmd.argv[0])) {
		cmd.argv[cmd.argc++] = p;
		p = nextword(p);
	}
	cmd.argv[cmd.argc] = NULL;

	return (*cmd.cmd->cmd_exec)();
}

static char *
whatcmd(ct, p)
	register const struct cmd_table **ct;
	register char *p;
{
	register char *q;
	register int l;

	q = nextword(p);

	for (l = 0; p[l]; l++)
		;

	while ((*ct)->cmd_name != NULL && strncmp(p, (*ct)->cmd_name, l))
		(*ct)++;

	if ((*ct)->cmd_name == NULL)
		*ct = NULL;

	return q;
}

static int
readline(buf, to)
	register char *buf;
	int	to;
{
	register char *p = buf, *pe = buf, ch;
	time_t tt;

	for (tt = getsecs() + to; getsecs() < tt && !cnischar(); )
		;

	if (!cnischar())
		return 0;

	while (1) {
		switch ((ch = getchar())) {
		case CTRL('u'):
			while (pe-- > buf)
				putchar('\177');
			p = pe = buf;
			continue;
		case '\n':
		case '\r':
			pe[1] = *pe = '\0';
			break;
		case '\b':
		case '\177':
			if (p > buf) {
				putchar('\177');
				p--;
				pe--;
			}
			continue;
		default:
			pe++;
			*p++ = ch;
			continue;
		}
		break;
	}

	return pe - buf;
}

/*
 * Search for spaces/tabs after the current word. If found, \0 the
 * first one.  Then pass a pointer to the first character of the
 * next word, or NULL if there is no next word. 
 */
char *
nextword(p)
	register char *p;
{
	/* skip blanks */
	while (*p && *p != '\t' && *p != ' ')
		p++;
	if (*p) {
		*p++ = '\0';
		while (*p == '\t' || *p == ' ')
			p++;
	}
	if (*p == '\0')
		p = NULL;
	return p;
}

#ifdef DEBUG
static int
Xdebug()
{
	if (cmd.argc !=2)
		printf(debug? "on": "off");
	else
		debug = (cmd.argv[1][0] == '0' ||
			 (cmd.argv[1][0] == 'o' && cmd.argv[1][1] == 'f'))?
			 0: 1;
	return 0;
}
#endif

static void
print_help(register const struct cmd_table *ct)
{
	for (; ct->cmd_name != NULL; ct++)
		printf(" %s", ct->cmd_name);
	putchar('\n');
}

static int
Xhelp()
{
	printf("commands:");
	print_help(cmd_table);
#ifdef MACHINE_CMD
	return Xmachine();
#else
	return 0;
#endif
}

#ifdef MACHINE_CMD
static int
Xmachine()
{
	printf("machine:");
	print_help(MACHINE_CMD);
	return 0;
}
#endif

static int
Xecho()
{
	register int i;
	for (i = 1; i < cmd.argc; i++)
		printf(cmd.argv[i]), putchar(' ');
	putchar('\n');
	return 0;
}

/* called only w/ no arguments */
static int
Xset()
{
	register const struct cmd_table *ct;

	printf("OpenBSD boot[%s]\n", version);
	for (ct = cmd_set; ct->cmd_name != NULL; ct++) {
		printf("%s\t ", ct->cmd_name);
		(*ct->cmd_exec)();
		putchar('\n');
	}
	return 0;
}

static int
Xstty()
{
	int sp;
	char *cp;
	if (cmd.argc == 1)
		printf("com speed is %d\n", com_setsp(0));
	else {
		sp = 0;
		for (cp = cmd.argv[1]; *cp && isdigit(*cp); cp++)
			sp = sp*10 + (*cp - '0');
		com_setsp(sp);
	}

	return 0;
}

static int
Xdevice()
{
	if (cmd.argc != 2)
		printf(cmd.bootdev);
	else
		strncpy(cmd.bootdev, cmd.argv[1], sizeof(cmd.bootdev));
	return 0;
}

static int
Ximage()
{
	if (cmd.argc != 2)
		printf(cmd.image);
	else
		strncpy(cmd.image, cmd.argv[1], sizeof(cmd.image));
	return 0;
}

static int
Xaddr()
{
	register char *p;

	if (cmd.argc != 2)
		printf("%p", cmd.addr);
	else {
		register u_long a;

		p = cmd.argv[1];
		if (p[0] == '0' && p[1] == 'x')
			p += 2;
		for (a = 0; *p != '\0'; p++) {
			a <<= 4;
			a |= (isdigit(*p)? *p - '0':
			      10 + tolower(*p) - 'a') & 0xf;
		}
		cmd.addr = (void *)a;
	}
	return 0;
}

static int
Xtty()
{
	dev_t dev;

	if (cmd.argc == 1)
		printf(ttyname(0));
	else {
		dev = ttydev(cmd.argv[1]);
		if (dev == NODEV)
			printf("%s not a console device\n", cmd.argv[1]);
		else {
			printf("switching console to %s\n", cmd.argv[1]);
			if (cnset(dev))
				printf("%s console not present\n",
				       cmd.argv[1]);
		}
	}
	return 0;
}

static int
Xtime()
{
	if (cmd.argc == 1)
		time_print();
	else {
	}

	return 0;
}

static int
Xls()
{
	struct stat sb;
	register char *p;
	int fd;

	if (stat(qualify((cmd.argv[1]? cmd.argv[1]: "/.")), &sb) < 0) {
		printf("stat(%s): %s\n", cmd.path, strerror(errno));
		return 0;
	}

	if ((sb.st_mode & S_IFMT) != S_IFDIR)
		ls(cmd.path, &sb);
	else {
		if ((fd = opendir(cmd.path)) < 0) {
			printf ("opendir(%s): %s\n", cmd.path,
				strerror(errno));
			return 0;
		}

		/* no strlen in lib !!! */
		for (p = cmd.path; *p; p++);
		*p++ = '/';
		*p = '\0';

		while(readdir(fd, p) >= 0) {
			if (stat(cmd.path, &sb) < 0)
				printf("stat(%s): %s\n", cmd.path,
				       strerror(errno));
			else
				ls(p, &sb);
		}
		closedir (fd);
	}
	return 0;
}

#define lsrwx(mode,s) \
	putchar ((mode) & S_IROTH? 'r' : '-'); \
	putchar ((mode) & S_IWOTH? 'w' : '-'); \
	putchar ((mode) & S_IXOTH? *(s): (s)[1]);

static void
ls(name, sb)
	register char *name;
	register struct stat *sb;
{
	putchar("-fc-d-b---l-s-w-"[(sb->st_mode & S_IFMT) >> 12]);
	lsrwx(sb->st_mode >> 6, (sb->st_mode & S_ISUID? "sS" : "x-"));
	lsrwx(sb->st_mode >> 3, (sb->st_mode & S_ISUID? "sS" : "x-"));
	lsrwx(sb->st_mode     , (sb->st_mode & S_ISTXT? "tT" : "x-"));

	printf (" %u,%u\t%lu\t%s\n", sb->st_uid, sb->st_gid,
		(u_long)sb->st_size, name);
}
#undef lsrwx

static int
Xhowto()
{
	if (cmd.argc < 2) {
		if (cmd.boothowto) {
			putchar('-');
			if (cmd.boothowto & RB_ASKNAME)
				putchar('a');
			if (cmd.boothowto & RB_HALT)
				putchar('b');
			if (cmd.boothowto & RB_CONFIG)
				putchar('c');
			if (cmd.boothowto & RB_SINGLE)
				putchar('s');
			if (cmd.boothowto & RB_KDB)
				putchar('d');
		}
	} else
		bootparse(1);
	return 0;
}

static int
Xboot()
{
	if (cmd.argc > 1 && cmd.argv[1][0] != '-') {
		qualify((cmd.argv[1]? cmd.argv[1]: cmd.image));
		if (bootparse(2))
			return 0;
	} else {
		if (bootparse(1))
			return 0;
		sprintf(cmd.path, "%s:%s", cmd.bootdev, cmd.image);
	}

	return 1;
}

/*
 * Qualifies the path adding neccessary dev
 */

static char *
qualify(name)
	char *name;
{
	register char *p;

	for (p = name; *p; p++)
		if (*p == ':')
			break;
	if (*p == ':')
		strncpy(cmd.path, name, sizeof(cmd.path));
	else
		sprintf(cmd.path, "%s:%s", cmd.bootdev, name);
	return cmd.path;
}

static int
bootparse(i)
	int i;
{
	register char *cp;
	int howto = cmd.boothowto;

	for (; i < cmd.argc; i++) {
		cp = cmd.argv[i];
		if (*cp == '-') {
			while (*++cp) {
				switch (*cp) {
				case 'a':
					howto |= RB_ASKNAME;
					break;
				case 'b':
					howto |= RB_HALT;
					break;
				case 'c':
					howto |= RB_CONFIG;
					break;
				case 's':
					howto |= RB_SINGLE;
					break;
				case 'd':
					howto |= RB_KDB;
					break;
				default:
					printf("howto: bad option: %c\n", *cp);
					return 1;
				}
			}
		} else {
			printf("boot: illegal argument %s\n", cmd.argv[i]);
			return 1;
		}
	}
	cmd.boothowto = howto;
	return 0;
}

static int
Xreboot()
{
	printf("Rebooting...\n");
	exit();
	return 0; /* just in case */
}

@


1.33
log
@- add 'stty [baudrate]' command to /boot, for serial consoles
- switch baud rates using i/o instead of bios, since bios commands
have only a limited bitwidth for baudrate, and max out at 9600
- when switching console devices, print msg to both old device and new
- fix timeout bug in com_getc() (dev | 0x80 was reading gobbledygook)
- document 'stty' command in boot(8)
- wording and cleanup in man pages
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.32 1997/09/17 19:55:34 mickey Exp $	*/
@


1.32
log
@regs command is MD
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.31 1997/09/02 21:02:15 mickey Exp $	*/
d37 1
d56 1
d88 1
d373 17
d443 6
a448 2
		else if (cnset(dev))
			printf("%s console not present\n", cmd.argv[1]);
@


1.31
log
@Xregs is DUMP_REGS -- dependable
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.30 1997/09/02 20:48:17 mickey Exp $	*/
a36 1
#include <debug.h>
a49 3
#ifdef DUMP_REGS
static int Xregs __P((void));
#endif
a84 3
#ifdef DUMP_REGS
	{"regs",   CMDT_CMD, Xregs},
#endif
a604 8
#ifdef DUMP_REGS
static int
Xregs()
{
	DUMP_REGS;
	return 0;
}
#endif
@


1.30
log
@machine(MD) command set support
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.29 1997/08/22 00:41:27 mickey Exp $	*/
d50 2
@


1.29
log
@theo said we don't need 'cd' command
remove c-r, it won't work anyways
fix c-u
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.28 1997/08/21 22:17:56 mickey Exp $	*/
d61 4
a64 9

struct cmd_table {
	char *cmd_name;
	char cmd_type;
#define CMDT_CMD 0
#define CMDT_VAR 1
#define CMDT_SET 2
	int (*cmd_exec) __P((void));
};
d83 3
d87 1
a87 1
#ifdef DEBUG
a165 1
	const struct cmd_table *ct;
d167 1
d182 1
d189 8
a196 1
			const struct cmd_table *cs = cmd_set;
d319 8
a329 2
	register const struct cmd_table *ct;

d331 7
a337 3
	for (ct = cmd_table; ct->cmd_name != NULL; ct++)
		printf(" %s", ct->cmd_name);
	putchar('\n');
d339 6
d347 1
d610 1
a610 1
#ifdef DEBUG
@


1.28
log
@correct dev:<need cwd>name case in qualify()
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.27 1997/08/21 22:15:17 mickey Exp $	*/
a46 1
static int Xcd __P((void));
a84 1
	{"cd",     CMDT_CMD, Xcd},
a248 4
		case CTRL('r'):
			while (pe > buf)
				putchar('\177');
			printf(buf);
d250 1
a250 2
			while (pe >= buf) {
				pe--;
a251 1
			}
a342 1
	printf("cwd\t%s\n", cmd.cwd);
d512 1
a512 1
		sprintf(cmd.path, "%s:%s%s", cmd.bootdev, cmd.cwd, cmd.image);
d519 1
a519 1
 * Qualifies the path adding neccessary dev&|cwd
d532 2
a533 5
		if (p[1] == '/')
			sprintf(cmd.path, "%s", name);
		else
			sprintf(cmd.path, "%s%s", cmd.cwd, name);
	else if (name[0] == '/')
a534 2
	else
		sprintf(cmd.path, "%s:%s%s", cmd.bootdev, cmd.cwd, name);
a575 51
	return 0;
}

static int
Xcd()
{
	register char *p, *q;
	struct stat sb;

	/* cd home */
	if (cmd.argc == 1) {
		cmd.cwd[0] = '/';
		cmd.cwd[1] = '\0';
		return 0;
	}

	/* cd '.' */
	if (cmd.argv[1][0] == '.' && cmd.argv[1][1] == '\0')
		return 0;

	/* cd '..' */
	if (cmd.argv[1][0] == '.' && cmd.argv[1][1] == '.'
	    && cmd.argv[1][2] == '\0') {
		/* strrchr(cmd.cwd, '/'); */
		for (p = cmd.cwd; *++p;);
		for (p--; *--p != '/';);
		p[1] = '\0';
		return 0;
	}

	/* cd dir */
	sprintf(cmd.path, "%s:%s%s", cmd.bootdev, cmd.cwd, cmd.argv[1]);

	if (stat(cmd.path, &sb) < 0) {
		printf("stat(%s): %s\n", cmd.argv[1], strerror(errno));
		return 0;
	}

	if (!S_ISDIR(sb.st_mode)) {
		printf("boot: %s: not a dir\n", cmd.argv[1]);
		return 0;
	}

	/* change dir */
	for (p = cmd.cwd; *p; p++);
	for (q = cmd.argv[1]; (*p++ = *q++) != '\0';);
	if (p[-2] != '/') {
		p[-1] = '/';
		p[0] = '\0';
	}

@


1.27
log
@print ttyname w/o format string
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.26 1997/08/21 22:04:32 mickey Exp $	*/
d544 1
a544 1
			sprintf(cmd.path, "%s%s%s", name, cmd.cwd, name);
@


1.26
log
@boothowto is local to boot
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.25 1997/08/21 21:40:24 mickey Exp $	*/
d409 1
a409 1
		printf("%s", ttyname(0));
@


1.25
log
@no need for \n
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.24 1997/08/21 19:07:29 mickey Exp $	*/
d493 1
a493 1
		if (boothowto) {
d495 1
a495 1
			if (boothowto & RB_ASKNAME)
d497 1
a497 1
			if (boothowto & RB_HALT)
d499 1
a499 1
			if (boothowto & RB_CONFIG)
d501 1
a501 1
			if (boothowto & RB_SINGLE)
d503 1
a503 1
			if (boothowto & RB_KDB)
d557 1
a557 1
	int howto = boothowto;
d589 1
a589 1
	boothowto = howto;
@


1.24
log
@kill unused commands, yes we are not an operating system
sutisfied?
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.23 1997/08/13 14:24:00 niklas Exp $	*/
d409 1
a409 1
		printf("%s\n", ttyname(0));
@


1.23
log
@s/kbd/pc/ for consistency with kernel.  Do even better __asms for BIOS calls.
Adapt to new console probing and setting API.  Do not try to probe pc0 via
the NVRAM.  Fix some other buglets.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.22 1997/08/13 03:49:28 mickey Exp $	*/
a47 1
static int Xcp __P((void));
d51 1
a55 1
static int Xnope __P((void));
a56 1
static int Xregs __P((void));
a60 1
static int Xdmesg __P((void));
a86 2
	{"cp",     CMDT_CMD, Xcp},
	{"dmesg",  CMDT_CMD, Xdmesg},
a89 1
	{"nope",   CMDT_CMD, Xnope},
d91 1
d93 1
a431 6
Xdmesg()
{
	return 0;
}

static int
d652 1
d659 1
a659 14

static int
Xnope()
{
	return 0;
}

static int
Xcp()
{
	printf("cp: no writable filesystems\n");
	return 0;
}

@


1.22
log
@remove unused include
more const
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.21 1997/08/12 22:10:43 mickey Exp $	*/
d267 1
d271 1
d410 2
d413 1
a413 1
		printf(ttyname(0));
d415 5
a420 1

@


1.21
log
@slite rewrite
set/print vars in a consistent (by niklas@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.20 1997/08/12 21:51:35 mickey Exp $	*/
a39 3
#ifndef _TEST0
#include <biosdev.h>
#endif
d75 1
a75 1
static struct cmd_table cmd_set[] = {
d87 1
a87 1
static struct cmd_table cmd_table[] = {
@


1.20
log
@new cons
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.19 1997/08/06 18:45:02 mickey Exp $	*/
d40 1
a40 1
#ifndef _TEST
d71 4
a75 1
	const struct cmd_table *cmd_table;
d78 3
a80 3
static const struct cmd_table cmd_set[] = {
	{"addr",      Xaddr},
	{"boothowto", Xhowto},
d82 1
a82 1
	{"debug",     Xdebug},
d84 3
a86 3
	{"device",    Xdevice},
	{"tty",       Xtty},
	{"image",     Ximage},
d90 13
a102 13
static const struct cmd_table cmd_table[] = {
	{"boot",   Xboot}, /* XXX must be first */
	{"cd",     Xcd},
	{"cp",     Xcp},
	{"dmesg",  Xdmesg},
	{"echo",   Xecho},
	{"help",   Xhelp},
	{"ls",     Xls},
	{"nope",   Xnope},
	{"reboot", Xreboot},
	{"regs",   Xregs},
	{"set",    Xset, cmd_set},
	{"time",   Xtime},
d198 2
a199 2
		} else if (ct->cmd_table != NULL && p != NULL) {
			const struct cmd_table *cs = ct->cmd_table;
d317 1
a317 1
		printf("debug\t%s\n", (debug? "on": "off"));
d331 1
a331 1
	printf("commands: ");
d357 2
a358 1
	for (ct = cmd_set; ct->cmd_name != NULL; ct++)
d360 2
d369 1
a369 1
		printf("device\t%s\n", cmd.bootdev);
d379 1
a379 1
		printf("image\t%s\n", cmd.image);
d391 1
a391 1
		printf("addr\t%p\n", cmd.addr);
d412 1
a412 1
		printf("tty\t%s\n", ttyname(0));
a497 1
		printf("boothowto=");
a510 1
		putchar('\n');
@


1.19
log
@cmd is global anyways, don't pass it to handlers
add echo command
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.18 1997/07/01 20:02:22 mickey Exp $	*/
d247 1
a247 1
	for (tt = getsecs() + to; getsecs() < tt && !ischar(); )
d250 1
a250 1
	if (!ischar())
@


1.18
log
@smooth char waiting loop
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.17 1997/06/06 18:23:43 mickey Exp $	*/
d48 5
a52 5
static int Xaddr __P((register struct cmd_state *));
static int Xboot __P((register struct cmd_state *));
static int Xcd __P((register struct cmd_state *));
static int Xcp __P((register struct cmd_state *));
static int Xdevice __P((register struct cmd_state *));
d54 1
a54 1
static int Xdebug __P((register struct cmd_state *));
d56 12
a67 11
static int Xhelp __P((register struct cmd_state *));
static int Ximage __P((register struct cmd_state *));
static int Xls __P((register struct cmd_state *));
static int Xnope __P((register struct cmd_state *));
static int Xreboot __P((register struct cmd_state *));
static int Xregs __P((register struct cmd_state *));
static int Xset __P((register struct cmd_state *));
static int Xhowto __P((register struct cmd_state *));
static int Xtty __P((register struct cmd_state *));
static int Xtime __P((register struct cmd_state *));
static int Xdmesg __P((register struct cmd_state *));
d71 1
a71 1
	int (*cmd_exec) __P((register struct cmd_state *));
d92 1
d107 1
a107 1
static int bootparse __P((register struct cmd_state *, int));
d109 3
a111 3
	__P((register const struct cmd_table **, register char *));
static int docmd __P((register struct cmd_state *));
static char *qualify __P((register struct cmd_state *, char *));
d116 1
a116 2
getcmd(cmd)
	register struct cmd_state *cmd;
d118 1
a118 1
	cmd->cmd = NULL;
d120 2
a121 2
	if (!readline(cmd_buf, cmd->timeout))
		cmd->cmd = cmd_table;
d123 1
a123 1
	return docmd(cmd);
d127 1
a127 2
read_conf(cmd)
	register struct cmd_state *cmd;
d134 1
a134 1
	if ((fd = open(qualify(cmd, cmd->conf), 0)) < 0) {
d136 1
a136 1
			printf("open(%s): %s\n", cmd->path, strerror(errno));
d145 1
a145 1
		printf("non-secure %s, will not proceed\n", cmd->path);
d154 1
a154 1
		cmd->cmd = NULL;
d161 1
a161 1
			printf("%s: %s\n", cmd->path, strerror(errno));
d165 1
a165 1
	} while (eof > 0 && !(eof = docmd(cmd)));
d172 1
a172 2
docmd(cmd)
	register struct cmd_state *cmd;
d177 2
a178 2
	cmd->argc = 1;
	if (cmd->cmd == NULL) {
d190 1
a190 1
		cmd->argv[cmd->argc] = p; /* in case it's shortcut boot */
d193 1
a193 1
			cmd->argc++;
d204 1
a204 1
		cmd->cmd = ct;
d207 3
a209 3
	cmd->argv[0] = ct->cmd_name;
	while (p && cmd->argc+1 < sizeof(cmd->argv) / sizeof(cmd->argv[0])) {
		cmd->argv[cmd->argc++] = p;
d212 1
a212 1
	cmd->argv[cmd->argc] = NULL;
d214 1
a214 1
	return (*cmd->cmd->cmd_exec)(cmd);
d311 1
a311 2
Xdebug(cmd)
	struct cmd_state *cmd;
d313 2
a314 2
	if (cmd->argc !=2)
		printf("debug=%s\n", (debug? "on": "off"));
d316 2
a317 2
		debug = (cmd->argv[1][0] == '0' ||
			 (cmd->argv[1][0] == 'o' && cmd->argv[1][1] == 'f'))?
d324 1
a324 2
Xhelp(cmd)
	register struct cmd_state *cmd;
d336 10
d348 1
a348 2
Xset(cmd)
	register struct cmd_state *cmd;
d353 1
a353 1
	printf("cwd=%s\n", cmd->cwd);
d355 1
a355 1
		(*ct->cmd_exec)(cmd);
d360 1
a360 2
Xdevice(cmd)
	register struct cmd_state *cmd;
d362 2
a363 2
	if (cmd->argc != 2)
		printf("device=%s\n", cmd->bootdev);
d365 1
a365 1
		strncpy(cmd->bootdev, cmd->argv[1], sizeof(cmd->bootdev));
d370 1
a370 2
Ximage(cmd)
	register struct cmd_state *cmd;
d372 2
a373 2
	if (cmd->argc != 2)
		printf("image=%s\n", cmd->image);
d375 1
a375 1
		strncpy(cmd->image, cmd->argv[1], sizeof(cmd->image));
d380 1
a380 2
Xaddr(cmd)
	register struct cmd_state *cmd;
d384 2
a385 2
	if (cmd->argc != 2)
		printf("addr=%p\n", cmd->addr);
d389 1
a389 1
		p = cmd->argv[1];
d397 1
a397 1
		cmd->addr = (void *)a;
d403 1
a403 2
Xtty(cmd)
	register struct cmd_state *cmd;
d405 2
a406 2
	if (cmd->argc == 1)
		printf("tty=%s\n", ttyname(0));
d414 1
a414 2
Xtime(cmd)
	register struct cmd_state *cmd;
d416 1
a416 1
	if (cmd->argc == 1)
d425 1
a425 2
Xdmesg(cmd)
	register struct cmd_state *cmd;
d431 1
a431 2
Xls(cmd)
	register struct cmd_state *cmd;
d437 2
a438 2
	if (stat(qualify(cmd, (cmd->argv[1]? cmd->argv[1]: "/.")), &sb) < 0) {
		printf("stat(%s): %s\n", cmd->path, strerror(errno));
d443 1
a443 1
		ls(cmd->path, &sb);
d445 2
a446 2
		if ((fd = opendir(cmd->path)) < 0) {
			printf ("opendir(%s): %s\n", cmd->path,
d452 1
a452 1
		for (p = cmd->path; *p; p++);
d457 3
a459 3
			if (stat(cmd->path, &sb) < 0)
				printf("stat(%s): %s\n", cmd->path,
					strerror(errno));
d489 1
a489 2
Xhowto(cmd)
	register struct cmd_state *cmd;
d491 1
a491 1
	if (cmd->argc < 2) {
d508 1
a508 1
		bootparse(cmd, 1);
d513 1
a513 2
Xboot(cmd)
	register struct cmd_state *cmd;
d515 3
a517 3
	if (cmd->argc > 1 && cmd->argv[1][0] != '-') {
		qualify(cmd, (cmd->argv[1]? cmd->argv[1]: cmd->image));
		if (bootparse(cmd, 2))
d520 1
a520 1
		if (bootparse(cmd, 1))
d522 1
a522 2
		sprintf(cmd->path, "%s:%s%s", cmd->bootdev,
			cmd->cwd, cmd->image);
d533 1
a533 2
qualify(cmd, name)
	register struct cmd_state *cmd;
d543 1
a543 1
			sprintf(cmd->path, "%s", name);
d545 1
a545 1
			sprintf(cmd->path, "%s%s%s", name, cmd->cwd, name);
d547 1
a547 1
		sprintf(cmd->path, "%s:%s", cmd->bootdev, name);
d549 2
a550 2
		sprintf(cmd->path, "%s:%s%s", cmd->bootdev, cmd->cwd, name);
	return cmd->path;
d554 1
a554 2
bootparse(cmd, i)
	register struct cmd_state *cmd;
d560 2
a561 2
	for (; i < cmd->argc; i++) {
		cp = cmd->argv[i];
d586 1
a586 1
			printf("boot: illegal argument %s\n", cmd->argv[i]);
d595 1
a595 2
Xcd(cmd)
	register struct cmd_state *cmd;
d601 3
a603 3
	if (cmd->argc == 1) {
		cmd->cwd[0] = '/';
		cmd->cwd[1] = '\0';
d608 1
a608 1
	if (cmd->argv[1][0] == '.' && cmd->argv[1][1] == '\0')
d612 4
a615 4
	if (cmd->argv[1][0] == '.' && cmd->argv[1][1] == '.'
	    && cmd->argv[1][2] == '\0') {
		/* strrchr(cmd->cwd, '/'); */
		for (p = cmd->cwd; *++p;);
d622 1
a622 2
	sprintf(cmd->path, "%s:%s%s",
		cmd->bootdev, cmd->cwd, cmd->argv[1]);
d624 2
a625 2
	if (stat(cmd->path, &sb) < 0) {
		printf("stat(%s): %s\n", cmd->argv[1], strerror(errno));
d630 1
a630 1
		printf("boot: %s: not a dir\n", cmd->argv[1]);
d635 2
a636 2
	for (p = cmd->cwd; *p; p++);
	for (q = cmd->argv[1]; (*p++ = *q++) != '\0';);
d646 1
a646 2
Xreboot(cmd)
	register struct cmd_state *cmd;
d654 1
a654 2
Xregs(cmd)
	register struct cmd_state *cmd;
d661 1
a661 2
Xnope(cmd)
	register struct cmd_state *cmd;
d667 1
a667 2
Xcp(cmd)
	register struct cmd_state *cmd;
@


1.17
log
@use destructive erase
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.16 1997/06/06 16:26:56 kstailey Exp $	*/
d246 1
a246 1
	register int i;
d248 1
a248 4
	for (i = to; i-- && !ischar(); )
#ifndef _TEST
		sleep(1);
#else
d250 2
a251 2
#endif
	if (i < 0)
@


1.16
log
@fix twiddle() without breaking backspace
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.15 1997/05/31 15:48:25 mickey Exp $	*/
d261 1
a261 1
				putchar('\b');
d266 1
a266 1
				putchar('\b');
@


1.15
log
@usleep won't work on some weird laptops
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.13 1997/04/28 07:39:00 weingart Exp $	*/
d275 1
a275 1
				putchar('\b');
@


1.14
log
@usleep is void now
@
text
@d66 1
d90 1
d135 1
a135 1
		if (errno != ENOENT) {
d245 2
a246 2
	char *p = buf, *pe = buf, ch;
	int i;
d250 1
a250 1
		usleep(100000);
d423 7
@


1.13
log
@Add getsecs().  Use biostime & biosdate routines.
Parse and convert to seconds since epoch.  Please
test, there is a new command "time", which should
print the current time (according to the BIOS) on
the console.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.12 1997/04/26 17:50:07 mickey Exp $	*/
a35 1
#include <string.h>
d248 1
a248 5
		if ((to = usleep(100000))) {
			printf ("usleep failed (%d)\n", to);
			i = 1;
			break;
		}
@


1.13.2.1
log
@2.1 laptop kbd fixes from mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.15 1997/05/31 15:48:25 mickey Exp $	*/
d36 1
d134 1
a134 1
		if (errno != ENOENT && errno != ENXIO) {
a216 3
int strncmp __P((char *, char *, int));
int sleep __P((int));

d244 2
a245 2
	register char *p = buf, *pe = buf, ch;
	register int i;
d249 5
a253 1
		sleep(1);
@


1.12
log
@boot.conf support
ttyname function in cons.c
rdonly var 'tty' to view tty settings
serial console soon
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.11 1997/04/21 20:20:25 mickey Exp $	*/
d66 1
d96 1
d411 12
@


1.11
log
@usleep testing code
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.10 1997/04/21 20:03:30 mickey Exp $	*/
d49 5
a53 5
static int Xaddr __P((struct cmd_state *));
static int Xboot __P((struct cmd_state *));
static int Xcd __P((struct cmd_state *));
static int Xcp __P((struct cmd_state *));
static int Xdevice __P((struct cmd_state *));
d55 1
a55 1
static int Xdebug __P((struct cmd_state *));
d57 9
a65 8
static int Xhelp __P((struct cmd_state *));
static int Ximage __P((struct cmd_state *));
static int Xls __P((struct cmd_state *));
static int Xnope __P((struct cmd_state *));
static int Xreboot __P((struct cmd_state *));
static int Xregs __P((struct cmd_state *));
static int Xset __P((struct cmd_state *));
static int Xhowto __P((struct cmd_state *));
d69 1
a69 1
	int (*cmd_exec)(struct cmd_state *);
d73 1
a73 1
const struct cmd_table cmd_set[] = {
d80 1
d85 1
a85 1
const struct cmd_table cmd_table[] = {
d102 1
a102 1
static int bootparse __P((struct cmd_state *, int));
d105 4
a108 1
char cmd_buf[133];
d112 59
a170 1
	struct cmd_state *cmd;
d173 1
a173 1
	register char *p;
d176 1
a176 5

	if (!readline(cmd_buf, cmd->timeout)) {
		cmd->cmd = cmd_table;
		p = NULL;
	} else {
d181 6
d260 4
a267 2
				putchar(' ');
				putchar('\b');
a276 2
				putchar(' ');
				putchar('\b');
d331 1
a331 1
	struct cmd_state *cmd;
d346 1
a346 1
	struct cmd_state *cmd;
d359 1
a359 1
	struct cmd_state *cmd;
d370 1
a370 1
	struct cmd_state *cmd;
d381 1
a381 1
	struct cmd_state *cmd;
d404 12
d417 1
a417 1
	struct cmd_state *cmd;
d423 1
a423 6
	if (cmd->argv[1] != NULL)
		strncpy (cmd->path, cmd->argv[1], sizeof(cmd->path));
	else
		sprintf(cmd->path, "%s:%s/.", cmd->bootdev, cmd->cwd);

	if (stat(cmd->path, &sb) < 0) {
d459 1
a459 1
void
d461 1
a461 1
	char *name;
d476 1
a476 1
	struct cmd_state *cmd;
d501 1
a501 1
	struct cmd_state *cmd;
d504 1
a504 14
		register char *p;

		for (p = cmd->argv[1]; *p; p++)
			if (*p == ':')
				break;
		if (*p == ':')
			sprintf(cmd->path, "%s", cmd->argv[1]);
		else if (cmd->argv[1][0] == '/')
			sprintf(cmd->path, "%s:%s", cmd->bootdev,
				cmd->argv[1]);
		else
			sprintf(cmd->path, "%s:%s%s", cmd->bootdev,
				cmd->cwd, cmd->argv[1]);

d517 26
d545 1
a545 1
	struct cmd_state *cmd;
d587 1
a587 1
	struct cmd_state *cmd;
d640 1
a640 1
	struct cmd_state *cmd;
d649 1
a649 1
	struct cmd_state *cmd;
d657 1
a657 1
	struct cmd_state *cmd;
d664 1
a664 1
	struct cmd_state *cmd;
@


1.10
log
@rewrite command processing.
two levels of commands from now (set has it's own {device,image,addr,howto})
all the combinations of {device,path,image,options} is now possible on boot.
move cmd_state init into .data again, no more memory limits
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.9 1997/04/17 21:47:37 deraadt Exp $	*/
d182 5
a186 1
		usleep(100000);
@


1.9
log
@make "boot> -a" work like "boot> bsd -a"; ie. flags shortcut
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.8 1997/04/16 22:14:15 deraadt Exp $	*/
d49 18
a66 1
const struct cmd_table {
d68 7
a74 6
	int cmd_id;
} cmd_table[] = {
	{"addr",   CMD_ADDR},
	{"boot",   CMD_BOOT},
	{"cd",     CMD_CD},
	{"device", CMD_DEVICE},
d76 1
a76 1
	{"debug",  CMD_DEBUG},
d78 15
a92 7
	{"help",   CMD_HELP},
	{"image",  CMD_IMAGE},
	{"ls",     CMD_LS},
	{"nope",   CMD_NOPE},
	{"reboot", CMD_REBOOT},
	{"regs",   CMD_REGS},
	{"set",    CMD_SET},
d100 4
a103 3
int bootparse __P((struct cmd_state *));

char *cmd_buf = NULL;
d109 2
a110 3
	register const struct cmd_table *ct = cmd_table;
	register char *p, *q;
	int l;
a111 4
	if (cmd_buf == NULL)
		cmd_buf = alloc(133);

	cmd->rc = 0;
d115 3
a117 7
		printf("\n");
		cmd->cmd = CMD_BOOT;
		cmd->argv[0] = cmd_table[CMD_BOOT].cmd_name;
		cmd->argv[1] = NULL;
		cmd->rc = 1;
		return 0;
	}
d119 17
a135 17
	/* command */
	for (q = cmd_buf; *q && (*q == ' ' || *q == '\t'); q++)
		;
	p = nextword(q);

	for (l = 0; q[l]; l++)
		;
	while (ct->cmd_name != NULL && strncmp(q, ct->cmd_name, l))
		ct++;

	if (ct->cmd_name == NULL) {
		cmd->cmd = CMD_BOOT;
		cmd->argv[0] = cmd_table[CMD_BOOT].cmd_name;
		if (q && *q) {
			if (*q == '-')
				cmd->argv[cmd->argc++] = NULL;	/* XXX */
			cmd->argv[cmd->argc++] = q;
d137 1
a137 3
	} else {
		cmd->cmd = ct->cmd_id;
		cmd->argv[0] = ct->cmd_name;
d139 2
d146 24
a169 1
	return bootparse(cmd);
d245 3
a247 2
int
execmd(cmd)
d250 8
a257 13
	struct stat sb;
	int fd;
	register char *p, *q;
	register const struct cmd_table *ct;

	cmd->rc = 0;
	switch (cmd->cmd) {

#ifdef DEBUG
	case CMD_DEBUG:
		debug = !debug;
		printf("debug is %s\n", debug? "on": "off");
		break;
d260 5
a264 6
	case CMD_HELP:
		printf("commands: ");
		for (ct = cmd_table; ct->cmd_name != NULL; ct++)
			printf(" %s", ct->cmd_name);
		putchar('\n');
		break;
d266 4
a269 8
	case CMD_DEVICE:
		if (cmd->argc != 2)
			printf("device: device name required\n");
		else {
			strncpy(cmd->bootdev, cmd->argv[1],
				sizeof(cmd->bootdev));
		}
		break;
d271 2
a272 8
	case CMD_IMAGE:
		if (cmd->argc != 2)
			printf("image: pathname required\n");
		else {
			strncpy(cmd->image, cmd->argv[1],
				sizeof(cmd->image));
		}
		break;
d274 6
a279 14
	case CMD_ADDR:
		if (cmd->argc != 2)
			printf("addr: address required\n");
		else {
			register u_long a;

			p = cmd->argv[1];
			if (p[0] == '0' && p[1] == 'x')
				p += 2;
			for (a = 0; *p != '\0'; p++) {
				a <<= 4;
				a |= (isdigit(*p)? *p - '0':
				      10 + tolower(*p) - 'a') & 0xf;
			}
d281 6
a286 3
			cmd->addr = (void *)a;
		}
		break;
d288 10
a297 8
	case CMD_LS:
		{
			if (cmd->argv[1] != NULL)
				strncpy (cmd->path, cmd->argv[1],
					 sizeof(cmd->path));
			else
				sprintf(cmd->path, "%s:%s/.",
					cmd->bootdev, cmd->cwd);
d299 10
a308 4
			if (stat(cmd->path, &sb) < 0) {
				printf("stat(%s): %d\n", cmd->path, errno);
				break;
			}
d310 5
a314 22
			if ((sb.st_mode & S_IFMT) != S_IFDIR)
				ls(cmd->path, &sb);
			else {
				if ((fd = opendir(cmd->path)) < 0) {
					printf ("opendir(%s): %d\n",
						cmd->path, errno);
					break;
				}

				/* no strlen in lib !!! */
				for (p = cmd->path; *p; p++);
				*p++ = '/';
				*p = '\0';

				while(readdir(fd, p) >= 0) {

					if (stat(cmd->path, &sb) < 0)
						printf("stat(%s): %d\n",
						       cmd->path, errno);
					else
						ls(p, &sb);
				}
d316 12
a327 2
				closedir (fd);
			}
d329 4
a332 1
		break;
d334 7
a340 6
	case CMD_CD:
		if (cmd->argc == 1) {
			cmd->cwd[0] = '/';
			cmd->cwd[1] = '\0';
			break;
		}
d342 4
a345 2
		if (cmd->argv[1][0] == '.' && cmd->argv[1][1] == '\0')
			break;
d347 4
a350 8
		if (cmd->argv[1][0] == '.' && cmd->argv[1][1] == '.'
		    && cmd->argv[1][2] == '\0') {
			/* strrchr(cmd->cwd, '/'); */
			for (p = cmd->cwd; *++p;);
			for (p--; *--p != '/';);
			p[1] = '\0';
			break;
		}
d352 20
a371 5
		sprintf(cmd->path, "%s:%s%s",
			cmd->bootdev, cmd->cwd, cmd->argv[1]);
		if (stat(cmd->path, &sb) < 0) {
			printf("stat(%s): %d\n", cmd->argv[1], errno);
			break;
d373 1
a373 65

		if (!S_ISDIR(sb.st_mode)) {
			printf("boot: %s: not a dir\n", cmd->argv[1]);
			break;
		}

		/* change dir */
		for (p = cmd->cwd; *p; p++);
		for (q = cmd->argv[1]; (*p++ = *q++) != '\0';);
		if (p[-2] != '/') {
			p[-1] = '/';
			p[0] = '\0';
		}
		break;

	case CMD_SET:
		printf("OpenBSD/i386 boot version %s(debug is %s)\n"
		       "device:\t%s\n"
		       "cwd:\t%s\n"
		       "image:\t%s\n"
		       "load at:\t%p\n"
		       "timeout:\t%d\n",
		       version,
#ifdef DEBUG
		       (debug? "on": "off"),
#else
				"not present",
#endif
		       cmd->bootdev, cmd->cwd, cmd->image,
		       cmd->addr, cmd->timeout);
		break;

	case CMD_REBOOT:
		printf("Rebooting...\n");
		cmd->rc = -1;
		break;

	case CMD_REGS:
		DUMP_REGS;
		break;

	case CMD_BOOT:
		/* XXX "boot -s" will not work as this is written */
		if (cmd->argc > 1 && cmd->argv[1]) {
			char *p;

			for (p = cmd->argv[1]; *p; p++)
				if (*p == ':')
					break;
			if (*p == ':')
				sprintf(cmd->path, "%s", cmd->argv[1]);
			else 
				sprintf(cmd->path, "%s:%s", cmd->bootdev,
				    cmd->argv[1]);
		} else
			sprintf(cmd->path, "%s:%s%s", cmd->bootdev,
				cmd->cwd, cmd->image);
		cmd->rc = !bootparse(cmd);
		break;

	case CMD_ERROR:
	default:
		printf ("%s: invalid command\n", cmd->argv[0]);
	case CMD_NOPE:
		break;
d375 1
a375 2

	return cmd->rc;
d396 1
d398 27
a424 2
int
bootparse(cmd)
d427 30
a456 1
	char *cp;
d458 3
d462 1
a462 1
	for (i = 2; i < cmd->argc; i++) {
d468 1
a468 1
					boothowto |= RB_ASKNAME;
d471 1
a471 1
					boothowto |= RB_HALT;
d474 1
a474 1
					boothowto |= RB_CONFIG;
d477 1
a477 1
					boothowto |= RB_SINGLE;
d480 1
a480 1
					boothowto |= RB_KDB;
d482 3
d492 1
d495 86
@


1.8
log
@add RB_KDB support
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.7 1997/04/15 08:32:51 deraadt Exp $	*/
d93 1
a104 1
printf("cmd=%s\n", q);
d114 3
a116 1
		if (q && *q)
d118 1
a124 1
printf("argN=%s\n", p);
d377 1
a377 1
		if (cmd->argc > 1) {
@


1.7
log
@mostly repair option arg handling for booting
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.6 1997/04/11 19:12:56 weingart Exp $	*/
d444 3
@


1.6
log
@Works with .gz kernels now
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.5 1997/04/08 22:48:29 mickey Exp $	*/
d39 1
a71 1
static char *skipblnk __P((register char *));
d73 2
d83 2
a84 1
	register char *p = cmd_buf, *q; /* input */
d87 1
a87 1
		p = cmd_buf = alloc(133);
d96 1
a99 2
	p = skipblnk(cmd_buf);

d101 4
a104 2
	for ( q = p; *p != '\0' && *p != ' ' && *p != '\t'; p++);
	*p = '\0';
d106 3
a108 1
	while (ct->cmd_name != NULL && strncmp(q, ct->cmd_name, (p - q)))
d114 5
a118 4
		cmd->argv[1] = skipblnk(cmd_buf);
		cmd->argv[2] = NULL;
		cmd->argc++;
		return 0;
d120 4
a123 6

	cmd->cmd = ct->cmd_id;
	cmd->argv[0] = ct->cmd_name;
	for (p++; *(p = skipblnk(p)) != '\0'; *p++ = '\0') {
		cmd->argv[cmd->argc++] = q = p;
		for (; *p && *p != '\t' && *p != ' '; p++);
d126 1
a126 2

	return cmd->rc;
d147 1
a147 1
		switch (ch = getchar()) {
d149 1
a149 1
			while (pe > buf) {
d180 5
d186 1
a186 1
skipblnk(p)
d190 1
a190 1
	while (*p == '\t' || *p == ' ')
d192 7
a198 1

d374 13
a386 3
		if (cmd->argc > 1)
			strncpy(cmd->path, cmd->argv[1], sizeof(cmd->path));
		else
d389 1
a389 1
		cmd->rc = 1;
d421 33
@


1.5
log
@use new device names: fd(0,a) -> fd0a
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.4 1997/04/07 01:26:00 weingart Exp $	*/
d342 2
@


1.4
log
@Reboot stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.3 1997/04/01 04:50:33 mickey Exp $	*/
d256 1
a256 1
				sprintf(cmd->path, "%s%s/.",
d311 1
a311 1
		sprintf(cmd->path, "%s%s%s",
d360 1
a360 1
			sprintf(cmd->path, "%s%s%s", cmd->bootdev,
@


1.3
log
@^U hotkey in readline
sample regs command to show the registers
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d348 1
@


1.2
log
@commit all my mods to the last imported libsa stuff....
including:
- disklabel support;
- better boot cmd line
- smaller size (using some compilation switches ;)
- no more relocations in /boot, it's loaded in the place;
- better disk performance (maybe were already in there)
- installboot -n does not require write perms for device
- more debugs
- missing parts in libsa (such as cd9660 and so)
- i don't like 2 files for exec_i386 (sorry, toby, let's discuss maybe?)
tricks and tails:
- joined .text and .data (saves you a page)
- prot mode switching still in biosboot (it's freezed for awhile)
- biosdisk internals changed
- biosdev is not passed propery to the kernel (i'll fix it soon)
- sure i missed smth here to note (use the source, Luke!)
@
text
@d38 1
d46 2
d64 1
d126 2
a127 2
readline(p, to)
	register char *p;
d130 1
a130 1
	char *buf = p, ch;
d144 9
d154 1
a154 1
			p[1] = *p = '\0';
d162 1
d166 1
d172 2
a173 1
	return p - buf;
d349 4
@


1.1
log
@Initial /boot stuff (from Mickey)
@
text
@d39 3
d43 3
a45 1
static struct cmd_table {
d53 3
d65 4
a68 3
extern char version[];
void ls __P((char *, register struct stat *));
char skipblnk __P((void));
d70 1
a70 1
char cmd_buf[133];
d74 1
a74 1
	register struct cmd_state *cmd;
d76 5
a80 4
	register struct cmd_table *ct = cmd_table;
	register char *p = cmd_buf; /* input */
	register char ch;
	int len;
d85 1
a85 3
	for (len = cmd->timeout; len-- && !ischar(); );

	if (len < 0) {
d92 1
a92 1
	ch = skipblnk();
d94 2
a95 3
	for (len = 0; ch != '\n' &&
		     ch != ' ' && ch != '\t'; len++, ch = getchar())
		*p++ = ch;
d98 1
a98 7
	if (len == 0 && ch == '\n') {
		cmd->cmd = CMD_NOPE;
		return 0;
	}

	while (ct->cmd_name != NULL &&
	       strncmp(cmd_buf, ct->cmd_name, len))
d102 5
a106 2
		cmd->cmd = CMD_ERROR;
		cmd->argv[0] = ct->cmd_name;
d112 5
a116 2
	if (ct->cmd_name != NULL) {
		while (ch != '\n') {
d118 2
a119 1
			ch = skipblnk();
d121 28
a148 9
			if (ch != '\n') {
				cmd->argv[cmd->argc] = p;
				*p++ = ch;
				for (len = 0; (ch = getchar()) != '\n' &&
					     ch != ' ' && ch != '\t'; len++)
					*p++ = ch;
				*p++ = '\0';
				if (len != 0)
					cmd->argc++;
d150 4
d155 1
a155 1
		cmd->argv[cmd->argc] = NULL;
d157 1
a157 2

	return cmd->rc;
d160 3
a162 2
char
skipblnk()
a163 2
	register char ch;

d165 2
a166 2
	while ((ch = getchar()) != '\n' &&
	       (ch == ' ' || ch == '\t'));
d168 1
a168 1
	return ch;
d173 1
a173 1
	register struct cmd_state *cmd;
d178 1
a178 1
	register struct cmd_table *ct;
d181 1
d183 6
a188 1
	switch (cmd->cmd) {
d236 6
a241 3
			q = cmd->argv[1] == NULL? "." : cmd->argv[1];
			sprintf(cmd->path, "%s%s%s",
				cmd->bootdev, cmd->cwd, q);
d249 1
a249 1
				ls(q, &sb);
d257 2
a258 1
				p = cmd->path + strlen(cmd->path);
d262 1
a262 1
				while(readdir(fd, p) >= 0 && *p != '\0') {
d264 1
a264 1
					if (stat(cmd->path, &sb) < 0) {
d267 2
a268 3
						break;
					}
					ls(p, &sb);
d317 1
a317 1
		printf("OpenBSD boot version %s\n"
d323 5
a327 1
		       version, cmd->bootdev, cmd->cwd, cmd->image,
d332 1
a332 1
		exit(1);
d336 6
a341 1
		return 1;
d369 2
a370 2
	printf (" %s\tuid=%u\tgid=%u\t%lu\n", name, sb->st_uid, sb->st_gid,
		(u_long)sb->st_size);
@
