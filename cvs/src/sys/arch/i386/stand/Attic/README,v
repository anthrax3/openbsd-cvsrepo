head	1.14;
access;
symbols
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.28
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.26
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.24
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.22
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.12.0.20
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.18
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.16
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.12.0.14
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.12
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.10
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.8
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.6
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.4
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6;
locks; strict;
comment	@# @;


1.14
date	2004.06.22.23.40.37;	author weingart;	state dead;
branches;
next	1.13;

1.13
date	2003.11.08.19.17.28;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	98.02.24.22.06.37;	author weingart;	state Exp;
branches
	1.12.10.1;
next	1.11;

1.11
date	97.10.17.15.03.16;	author weingart;	state Exp;
branches;
next	1.10;

1.10
date	97.09.02.21.41.29;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.08.27.20.35.21;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.07.18.01.24.47;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.05.31.16.08.34;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.04.21.19.42.03;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.04.21.19.40.44;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.04.11.19.21.50;	author weingart;	state Exp;
branches;
next	1.3;

1.3
date	97.04.07.01.20.08;	author weingart;	state Exp;
branches;
next	1.2;

1.2
date	97.03.31.23.06.04;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	97.03.31.03.11.59;	author weingart;	state Exp;
branches;
next	;

1.12.10.1
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Remove... almost 10 years, and things have changed enough that this
is more historic than anything else.  If ya want it, find it in the
Attic.

ok tom@@
@
text
@$OpenBSD: README,v 1.13 2003/11/08 19:17:28 jmc Exp $

# hmm, no copyright

Ok, just a couple quick pointers to people hacking on this stuff.  These
are things that I have found out, and hopefully will make things easier
for the next dude.

First of all, don't trust gas to get the opcodes right.  Look at the
listing (-Wa,a), and check them.  In particular, check for EIP relative
and absolute addressing.  Some of this stuff is pretty hairy in that way.

Debugging this stuff is hell.  Remember that stores directly to video
memory will go a long way towards tracking how far things are getting,
especially when you don't have the BIOS handy.  (movl %0x07410741, 0xb8000)


The basics of the /boot system is the following:

biosboot: 512 bytes of the first sector on the disk/partition.  This loads
/boot (or whatever you did with installboot) into ram.

boot: starts protected mode, and process simple command line.
There is some magic here in terms of the placement and size of the various
segments, as this piece of code has to switch between real and protected
mode many times to load the next piece of the puzzle, /bsd.gz.

bsd: The kernel itself, can be gzipped if ya want.


The basic steps at creating a boot floppy for yourself, and checking things
out are the following:

1.) Compile a kernel you wish to use.
2.) Compile the new stand stuff.
3.) Mount floppy.
4.) Copy boot and kernel to floppy.  (Kernel could be gzipped if needed)
5.) Run installboot on floppy.
6.) Unmount floppy.
7.) Test...

A quick pasto for ya:
> natasha# mount /dev/fd0a /mnt
> natasha# cp boot/obj/boot /mnt
> natasha# gzip -9c bsd > /mnt/bsd.gz
> natasha# installboot -v /mnt/boot biosboot /dev/rfd0a
> boot: /mnt/boot
> proto: biosboot/obj/biosboot
> device: /dev/rfd0a
> 
> biosboot/obj/biosboot: entry point 0
> proto bootblock size 512
> room for 32 filesystem blocks at 0x138
> Will load 9 blocks of size 4096 each.
>  0:  4 @@(2 1 15) (104-107)
>  1: 18 @@(3 0 1) (108-125)
>  2: 18 @@(3 1 1) (126-143)
>  3: 18 @@(4 0 1) (144-161)
>  4: 14 @@(4 1 1) (162-175)
> /mnt/boot: 5 entries total
> natasha# umount /mnt
> natasha# 


Sun Apr  6 20:16:55 CDT 1997
----------------------------

Ok, from general comments on icb leads me to believe this stuff has a ways
to go.  First of all, there are a lot of debug frobs to video memory at
0xb8000 when DEBUG* is defined.  Also, if you boot a kernel, and find that
you get a scrolling screen, press pause to get it to stop.  You should then
be able to read the register dump.

Note, currently gzipped kernel do not work.  Do not know the reason, we are
working on resolving that.


Fri Apr 11 14:18:41 CDT 1997
----------------------------

Ok, yeah, the .gz kernel gets to the probe (and then cacks later due to
no swap).  Things should start working nicer from now on.  The problem
was with -DSAVE_MEMORY, I believe that the stuff in libsa/cread.c was
not (and still is not with the define) being done right.  I suspect
the inflateInit2(), which had a parameter changed from -15 to -11.
The problem manifested itself by loading a corrupted kernel.  On the
other hand, it checksummed ok though, so there might be a small bug in
the libz stuff.  Also, I don't understand libz, but I do know that
things work without -DSAVE_MEMORY, and don't with it defined.


Mon Apr 21 15:25:42 EDT 1997
----------------------------

Now memory limits are not a concern. No more restrictions on placement
and size of code/data. It would be an idea to move PMMM code from kernel
into /boot to use low memory somehow.  Also remember that the upper 64k is
used by apm, so do not grow heap too much... Low 64k is used for real mode
IDT, BIOS data, stack for /boot, so stack is big enough (about 60k).
All the magic w/ prot-real mode interface now in one place <libsa/gidt.S>.
BIOS (and DOS soon) interrupt entry points are now just as simple as
they are in real mode (just use a macro BIOSINT, which shifts int number
by 0x20, that all! ;).


Sat May 31 12:06:37 EDT 1997
----------------------------

usleep(int15,f86) BIOS call is not supported well in all the BIOSes,
especially some laptop BIOSes and Compaq machines. Everybody is encouraged
to use sleep instead, it's known to work.


Thu Jul 17 21:24:42 EDT 1997
----------------------------

Return to the way when code has to be less than 64k, or better say that
whole gidt.S code must be in the 1st 64k of /boot .text section.
This saves about 2k of code (idt initialization).
APM information is now gathered and passed to the locore.s upon kernel
startup as a pointer to the struct apm_connect_info.


Wed Aug 27 16:30:51 EDT 1997
----------------------------

BIOS boot device number is passed to the kernel along with BIOS geometry
for that drive and other info. APM connect info is passed as well not in
that apm0 structure, so apm0 will become a slave on bios0 soon.
To get your /boot installed properly on a hardrive you have to load /bsd
from that hd/partition (since only boot drive geometry is passed).


Mon Oct 13 16:41:18 CDT 1997
----------------------------

Clean up memprobe some, adding support for querying the BIOS for the
memory map.  Resort to the old invasive probe if all else fails.  Add
preliminary support for passing a memory map to the kernel, instead of
cnvmem/extmem.  This should make weird boards easier to support in the
future.


Tue Jan  6 19:51:43 CST 1998
----------------------------

Query and pass PCI BIOS information to the kernel.  This should help in
determening the correct configuration mode to use.  Pass in cnvmem/extmem
as the user sets the amount of memory with the 'set memory' command, or
the amount calculated by the memory find/probe routines.

@


1.13
log
@typos from Jonathon Gray;
@
text
@d1 1
a1 1
$OpenBSD: README,v 1.12 1998/02/24 22:06:37 weingart Exp $
@


1.12
log
@Changes/updates to /boot stuff.  More to come.
Fixes many divide by zero and pointer bugs.
@
text
@d1 1
a1 1
$OpenBSD: README,v 1.11 1997/10/17 15:03:16 weingart Exp $
d117 1
a117 1
Return to the way when code has to be less then 64k, or better say that
@


1.12.10.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
$OpenBSD$
d117 1
a117 1
Return to the way when code has to be less than 64k, or better say that
@


1.11
log
@Use BIOS to probe for memory map.
Probe for BIOS supported disks.
Use BIOS to get geometry for supported disks.

All in preparation to passing the whole thing
to the kernel.
@
text
@d1 1
a1 1
$OpenBSD: README,v 1.10 1997/09/02 21:41:29 kstailey Exp $
a131 4
The passed geometry will be used for all the drives, if you
will try to installboot on other disks (floppies and pseudo-disks will
honor the disklabel), that might be useful on some bioses,
esp. SCSI HAs which use fixed translated geometry for all the drives.
d142 9
@


1.10
log
@correct spelling
@
text
@d1 1
a1 1
$OpenBSD: README,v 1.9 1997/08/27 20:35:21 mickey Exp $
d95 4
a98 4
Now memory limits are not in concern. No any restrictions on placement
and sizes of code/data. It would be an idea to move PMMM code from kernel
into /boot to use low memory somehow, then remember that upper 64k are
used by apm, so do not grow too much... Low 64k are used for real mode
d102 1
a102 1
they are in real mode (just use a macro BIOSINT, which shifts int#
d117 1
a117 1
Return to the way when code have to be less then 64k, or better say that
d121 1
a121 1
startup as pointer to the struct apm_connect_info.
d127 3
a129 3
BIOS boot device number is passed to kernel along with BIOS geometry for that
drive and other info. APM connect info is passed as well not in that
apm0 structure, so apm0 will become a slave on bios0 soon.
d136 11
@


1.9
log
@notes on recent changes w/ hd:/boot support
@
text
@d1 1
a1 1
$OpenBSD: README,v 1.8 1997/07/18 01:24:47 mickey Exp $
d87 1
a87 1
other hand, it checksumed ok though, so there might be a small bug in
d89 1
a89 1
things work withouth -DSAVE_MEMORY, and don't with it defined.
d134 2
a135 2
honour the disklabel), that might be usefull on some bioses,
esp. SCSI HAs wich use fixed translated geometry for all the drives.
@


1.8
log
@notes about pmmm changes, apm
@
text
@d1 1
a1 1
$OpenBSD: README,v 1.7 1997/05/31 16:08:34 mickey Exp $
d122 14
@


1.7
log
@note about usleep
@
text
@d1 1
a1 1
$OpenBSD: README,v 1.6 1997/04/21 19:42:03 mickey Exp $
d112 10
@


1.6
log
@copyright (;
@
text
@d1 1
a1 1
$OpenBSD: README,v 1.5 1997/04/21 19:40:44 mickey Exp $
d104 8
@


1.5
log
@some comments on recent stuff
@
text
@d1 1
a1 1
$OpenBSD: README,v 1.4 1997/04/11 19:21:50 weingart Exp $
d3 1
@


1.4
log
@Various comments
@
text
@d1 1
a1 1
$OpenBSD: README,v 1.3 1997/04/07 01:20:08 weingart Exp $
d90 13
@


1.3
log
@Clarifications.
@
text
@d1 1
a1 1
$OpenBSD: README,v 1.2 1997/03/31 23:06:04 mickey Exp $
d75 14
@


1.2
log
@commit all my mods to the last imported libsa stuff....
including:
- disklabel support;
- better boot cmd line
- smaller size (using some compilation switches ;)
- no more relocations in /boot, it's loaded in the place;
- better disk performance (maybe were already in there)
- installboot -n does not require write perms for device
- more debugs
- missing parts in libsa (such as cd9660 and so)
- i don't like 2 files for exec_i386 (sorry, toby, let's discuss maybe?)
tricks and tails:
- joined .text and .data (saves you a page)
- prot mode switching still in biosboot (it's freezed for awhile)
- biosdisk internals changed
- biosdev is not passed propery to the kernel (i'll fix it soon)
- sure i missed smth here to note (use the source, Luke!)
@
text
@d1 1
a1 1
$OpenBSD: README,v 1.1 1997/03/31 03:11:59 weingart Exp $
d62 13
@


1.1
log
@Initial /boot stuff (from Mickey)
@
text
@d1 1
a1 1
$OpenBSD$
d22 4
a25 4
boot: relocates itself, and starts protected mode.  There is some magic here
in terms of the placement and size of the various segments, as this piece of
code has to switch between real and protected mode many times to load the
next piece of the puzzle, /bsd.gz.
@

