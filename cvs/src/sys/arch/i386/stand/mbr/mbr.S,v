head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.24
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.22
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.18
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.14
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.16
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.8
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.12
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.10
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.6
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.4
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.20
	OPENBSD_5_0:1.21.0.18
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.16
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.14
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.10
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.12
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.8
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.6
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.4
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.20.0.14
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.12
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.10
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.8
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.6
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.4
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.16.0.6
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.16
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.13.0.18
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.13.0.16
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.13.0.14
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.12
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.10
	SMP_BASE:1.13
	kame_19991208:1.13
	OPENBSD_2_6:1.13.0.8
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.6
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.4
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@# @;


1.23
date	2012.06.04.16.17.04;	author mglocker;	state Exp;
branches;
next	1.22;

1.22
date	2012.05.29.04.22.57;	author mglocker;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.25.14.10.17;	author tom;	state Exp;
branches;
next	1.20;

1.20
date	2004.02.10.00.35.15;	author tom;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.05.00.08.23;	author tom;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.03.20.22.12;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.17.03.43.19;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.08.23.14.51;	author kjell;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.15.21.28.45;	author mickey;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.12.15.21.16.10;	author kjell;	state Exp;
branches;
next	1.13;

1.13
date	98.03.11.13.05.07;	author graichen;	state Exp;
branches
	1.13.10.1;
next	1.12;

1.12
date	97.11.05.02.14.18;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.08.29.19.47.24;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.08.13.02.22.02;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.08.13.00.21.45;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.08.09.21.03.47;	author weingart;	state Exp;
branches;
next	1.7;

1.7
date	97.08.08.22.46.13;	author weingart;	state Exp;
branches;
next	1.6;

1.6
date	97.08.08.17.13.13;	author weingart;	state Exp;
branches;
next	1.5;

1.5
date	97.08.08.16.50.19;	author weingart;	state Exp;
branches;
next	1.4;

1.4
date	97.08.08.16.42.13;	author weingart;	state Exp;
branches;
next	1.3;

1.3
date	97.08.07.11.49.59;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.08.01.18.39.45;	author weingart;	state Exp;
branches;
next	1.1;

1.1
date	97.03.31.03.12.19;	author weingart;	state Exp;
branches;
next	;

1.13.10.1
date	2002.03.06.01.01.01;	author niklas;	state Exp;
branches;
next	1.13.10.2;

1.13.10.2
date	2003.05.13.19.42.09;	author ho;	state Exp;
branches;
next	1.13.10.3;

1.13.10.3
date	2003.06.07.11.11.38;	author ho;	state Exp;
branches;
next	1.13.10.4;

1.13.10.4
date	2004.02.19.10.48.43;	author niklas;	state Exp;
branches;
next	1.13.10.5;

1.13.10.5
date	2004.06.05.23.09.01;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.01.31.22.55.12;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2003.05.19.21.45.12;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Fix serial port output.

OK weingart@@
@
text
@/*	$OpenBSD: mbr.S,v 1.22 2012/05/29 04:22:57 mglocker Exp $	*/

/*
 * Copyright (c) 1997 Michael Shalayeff and Tobias Weingartner
 * Copyright (c) 2003 Tom Cosgrove <tom.cosgrove@@arches-consulting.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
/* Copyright (c) 1996 VaX#n8 (vax@@linkdead.paranoia.com)
 * last edited 9 July 1996
 * many thanks to Erich Boleyn (erich@@uruk.org) for putting up with
 * all my questions, and for his work on GRUB
 * You may use this code or fragments thereof in a manner consistent
 * with the other copyrights as long as you retain my pseudonym and
 * this copyright notice in the file.
 */

	.file	"mbr.S"

#include <machine/asm.h>
#include <assym.h>

/*
 * Memory layout:
 *
 * 0x07C00 -> 0x07DFF	BIOS loads us here	(at  31k)
 * 0x07E00 -> 0x17BFC	our stack		(to  95k)
 *
 * 0x07A00 -> 0x07BFF	we relocate to here	(at  30k5)
 *
 * 0x07C00 -> 0x07DFF	we load PBR here	(at  31k)
 *
 * The BIOS loads us at physical address 0x07C00.  We use a long jmp to
 * normalise our address to seg:offset 07C0:0000.  We then relocate to
 * 0x07A00, seg:offset 07A0:0000.
 *
 * We use a long jmp to normalise our address to seg:offset 07A0:0000
 * We set the stack to start at 07C0:FFFC (grows down on i386)
 * The partition boot record (PBR) loads /boot at seg:offset 4000:0000
 */
#define BOOTSEG		0x7c0	/* segment where we are loaded */
#define BOOTRELOCSEG	0x7a0	/* segment where we relocate to */
#define BOOTSTACKOFF	0xfffc	/* stack starts here, grows down */
#define PARTSZ		16	/* each partition table entry is 16 bytes */

#define CHAR_LBA_READ	'.'
#define CHAR_CHS_READ	';'
#define CHAR_SHIFT_SEEN	0x07	/* Use BEL */

#define MBR_FLAGS_FORCE_CHS	0x0001

#ifdef DEBUG
#define CHAR_S		'S'	/* started */
#define CHAR_R		'R'	/* relocated */
#define CHAR_L		'L'	/* looking for bootable partition */
#define CHAR_B		'B'	/* loading boot */
#define CHAR_G		'G'	/* jumping to boot */

#define DBGMSG(c)	movb	$c, %al;	call	Lchr
#else /* !DEBUG */
#define DBGMSG(c)
#endif /* !DEBUG */

/* Clobbers %al - maybe more */
#define	putc(c)		movb	$c, %al;	call	Lchr

/* Clobbers %esi - maybe more */
#define	puts(s)		movw	$s, %si;	call	Lmessage


	.text
	.code16

	.globl	start
start:
	/* Adjust %cs to be right */
	ljmp 	$BOOTSEG, $1f
1:
	/* Set up stack */
	movw	%cs, %ax

	/*
	 * We don't need to disable and re-enable interrupts around the
	 * the load of ss and sp.
	 *
	 * From 80386 Programmer's Reference Manual:
	 * "A MOV into SS inhibits all interrupts until after the execution
	 * of the next instruction (which is presumably a MOV into eSP)"
	 *
	 * According to Hamarsoft's 86BUGS list (which is distributed with
	 * Ralph Brown's Interrupt List), some early 8086/88 processors
	 * failed to disable interrupts following a load into a segment
	 * register, but this was fixed with later steppings.
	 *
	 * Accordingly, this code will fail on very early 8086/88s, but
	 * nick@@ will just have to live with it.  Others will note that
	 * we require an 80386 (or compatible) or above processor, anyway.
	 */
	/* cli */
	movw	%ax, %ss
	movw	$BOOTSTACKOFF, %sp
	/* sti */			/* XXX not necessary; see above */

	/* Set up data segment */
	movw	%ax, %ds
	DBGMSG(CHAR_S)

	/*
	 * On the PC architecture, the boot record (originally on a floppy
	 * disk) is loaded at 0000:7C00 (hex) and execution starts at the
	 * beginning.
	 *
	 * When hard disk support was added, a scheme to partition disks into
	 * four separate partitions was used, to allow multiple operating
	 * systems to be installed on the one disk.  The boot sectors of the
	 * operating systems on each partition would of course expect to be
	 * loaded at 0000:7C00.
	 *
	 * The first sector of the hard disk is the master boot record (MBR).
	 * It is this which defines the partitions and says which one is
	 * bootable.  Of course, the BIOS loads the MBR at 0000:7C00, the
	 * same location where the MBR needs to load the partition boot
	 * record (PBR, called biosboot in OpenBSD).
	 *
	 * Therefore, the MBR needs to relocate itself before loading the PBR.
	 *
	 * Make it so.
	 */
	movw	$BOOTRELOCSEG, %ax
	movw	%ax, %es
	xorw	%si, %si
	xorw	%di, %di
	movw	$0x200, %cx		/* Bytes in MBR, relocate it all */
	cld
	rep
	movsb

	/* Jump to relocated self */
	ljmp $BOOTRELOCSEG, $reloc
reloc:
	DBGMSG(CHAR_R)

	/* Set up %es and %ds */
	pushw	%ds
	popw	%es	/* next boot is at the same place as we were loaded */
	pushw	%cs
	popw	%ds	/* and %ds is at the %cs */

#ifdef SERIAL
	/* Initialize the serial port to 9600 baud, 8N1.
	 */
	pushw	%dx
	xorw	%ax, %ax
	movb	$0xe3, %ax
	movw	$SERIAL, %dx
	int	$0x14
	popw	%dx
#endif

	/*
	 * If the SHIFT key is held down on entry, force CHS read
	 */

	/*
	 * BIOS call "INT 0x16 Get Keyboard Shift Flags
	 *	Call with	%ah = 0x02
	 *	Return:
	 *			%al = shift flags
	 *			%ah - undefined by many BIOSes
	 */
	movb	$0x02, %ah
	int	$0x16
	testb	$0x3, %al	/* Either shift key down? */
	jz	no_shift

	putc(CHAR_SHIFT_SEEN)	/* Signal that shift key was seen */

	orb	$MBR_FLAGS_FORCE_CHS, flags

no_shift:
	/* BIOS passes us drive number in %dl
	 *
	 * XXX - This is not always true.  We currently check if %dl
	 * points to a HD, and if not we complain, and set it to point
	 * to the first HDD.  Note, this is not 100% correct, since
	 * there is a possibility that you boot from HD #2, and still
	 * get (%dl & 0x80) == 0x00, these type of systems will lose.
	 */
	testb	$0x80, %dl
	jnz	drive_ok

	/* MBR on floppy or old BIOS
	 * Note: MBR (this code) should never be on a floppy.  It does
	 * not belong there, so %dl should never be 0x00.
	 *
	 * Here we simply complain (should we?), and then hardcode the
	 * boot drive to 0x80.
	 */
	puts(efdmbr)

	/* If we are passed bogus data, set it to HD #1
	 */
	movb	$0x80, %dl

drive_ok:
	/* Find the first active partition.
	 * Note: this should be the only active partition.  We currently
	 * don't check for that.
	 */
	movw	$pt, %si

	movw	$NDOSPART, %cx
find_active:
	DBGMSG(CHAR_L)
	movb	(%si), %al

	cmpb	$DOSACTIVE, %al
	je	found

	addw	$PARTSZ, %si
	loop	find_active

	/* No bootable partition */
no_part:
	movw	$enoboot, %si

err_stop:
	call	Lmessage

stay_stopped:
	sti				/* Ensure Ctl-Alt-Del will work */
	hlt				/* (don't require power cycle) */
	/* Just to make sure */
	jmp	stay_stopped

found:
	/*
	 * Found bootable partition
	 */

	DBGMSG(CHAR_B)

	/* Store the drive number (from %dl) in decimal */
	movb	%dl, %al
	andb	$0x0F, %al
	addb	$'0', %al
	movb	%al, drive_num

	/*
	 * Store the partition number, in decimal.
	 *
	 * We started with cx = 4; if found we want part '0'
	 *                 cx = 3;                  part '1'
	 *                 cx = 2;                  part '2'
	 *                 cx = 1;                  part '3'
	 *
	 * We'll come into this with no other values for cl.
	 */
	movb	$'0'+4, %al
	subb	%cl, %al
	movb	%al, part_num

	/*
	 * Tell operator what partition we're trying to boot.
	 *
	 * Using drive X, partition Y
	 * - this used to be printed out after successfully loading the
	 *   partition boot record; we now print it out before
	 */
	pushw	%si
	movw	$info, %si
	testb	$MBR_FLAGS_FORCE_CHS, flags
	jnz	1f
	incw	%si
1:
	call	Lmessage
	popw	%si

	/*
	 * Partition table entry format:
	 *
	 * 0x00	BYTE boot indicator (0x80 = active, 0x00 = inactive)
	 * 0x01	BYTE start head
	 * 0x02	WORD start cylinder, sector
	 * 0x04	BYTE system type (0xA6 = OpenBSD)
	 * 0x05 BYTE end head
	 * 0x06	WORD end cylinder, sector
	 * 0x08	LONG start LBA sector
	 * 0x0C	LONG number of sectors in partition
	 *
	 * In the case of a partition that extends beyond the 8GB boundary,
	 * the LBA values will be correct, the CHS values will have their
	 * maximums (typically (C,H,S) = (1023,255,63)).
	 *
	 * %ds:%si points to the active partition table entry.
	 */

	/* We will load the partition boot sector (biosboot) where we
	 * were originally loaded.  We'll check to make sure something
	 * valid comes in.  So that we don't find ourselves, zero out
	 * the signature at the end.
	 */
	movw	$0, %es:signature(,1)

	/*
	 * Have we been instructed to ignore LBA?
	 */
	testb	$MBR_FLAGS_FORCE_CHS, flags
	jnz	do_chs

	/*
	 * We will use the LBA sector number if we have LBA support,
	 * so find out.
	 */

	/*
	 * BIOS call "INT 0x13 Extensions Installation Check"
	 *	Call with	%ah = 0x41
	 *			%bx = 0x55AA
	 *			%dl = drive (0x80 for 1st hd, 0x81 for 2nd, etc)
	 *	Return:
	 *			carry set: failure
	 *				%ah = error code (0x01, invalid func)
	 *			carry clear: success
	 *				%bx = 0xAA55 (must verify)
	 *				%ah = major version of extensions
	 *				%al   (internal use)
	 *				%cx = capabilities bitmap
	 *					0x0001 - extnd disk access funcs
	 *					0x0002 - rem. drive ctrl funcs
	 *					0x0004 - EDD functions with EBP
	 *				%dx   (extension version?)
	 */

	movb	%dl, (%si)		/* Store drive here temporarily */
					/* (This call trashes %dl) */
					/*
					 * XXX This is actually the correct
					 *     place to store this.  The 0x80
					 *     value used to indicate the
					 *     active partition is by intention
					 *     the same as the BIOS drive value
					 *     for the first hard disk (0x80).
					 *     At one point, 0x81 would go here
					 *     for the second hard disk; the
					 *     0x80 value is often used as a
					 *     bit flag for testing, rather
					 *     than an exact byte value.
					 */
	movw	$0x55AA, %bx
	movb	$0x41, %ah
	int	$0x13

	movb	(%si), %dl		/* Get back drive number */

	jc	do_chs			/* Did the command work? Jump if not */
	cmpw	$0xAA55, %bx		/* Check that bl, bh exchanged */
	jne	do_chs			/* If not, don't have EDD extensions */
	testb	$0x01, %cl		/* And do we have "read" available? */
	jz	do_chs			/* Again, use CHS if not */

do_lba:
	/*
	 * BIOS call "INT 0x13 Extensions Extended Read"
	 *	Call with	%ah = 0x42
	 *			%dl = drive (0x80 for 1st hd, 0x81 for 2nd, etc)
	 *			%ds:%si = segment:offset of command packet
	 *	Return:
	 *			carry set: failure
	 *				%ah = error code (0x01, invalid func)
	 *				command packet's sector count field set
	 *				to the number of sectors successfully
	 *				transferred
	 *			carry clear: success
	 *				%ah = 0 (success)
	 *	Command Packet:
	 *			0x0000	BYTE	packet size (0x10 or 0x18)
	 *			0x0001	BYTE	reserved (should be 0)
	 *			0x0002	WORD	sectors to transfer (max 127)
	 *			0x0004	DWORD	seg:offset of transfer buffer
	 *			0x0008	QWORD	starting sector number
	 */
	movb	$CHAR_LBA_READ, %al
	call	Lchr

	/* Load LBA sector number from active partition table entry */
	movl	8(%si), %ecx
	movl	%ecx, lba_sector

	pushw	%si			/* We'll need %si later */

	movb	$0x42, %ah
	movw	$lba_command, %si
	int	$0x13

	popw	%si			/* (get back %si) flags unchanged */

	jnc	booting_os		/* If it worked, run the pbr we got */

	/*
	 * LBA read failed, fall through to try CHS read
	 */

do_chs:
	/*
	 * BIOS call "INT 0x13 Function 0x2" to read sectors from disk into
	 * memory
	 *       Call with       %ah = 0x2
	 *                       %al = number of sectors
	 *                       %ch = cylinder & 0xFF
	 *                       %cl = sector (0-63) | rest of cylinder bits
	 *                       %dh = head
	 *                       %dl = drive (0x80 for hard disk)
	 *                       %es:%bx = segment:offset of buffer
	 *       Return:
	 *                       carry set: failure
	 *                           %ah = err code
	 *                           %al = number of sectors transferred
	 *                       carry clear: success
	 *                           %al = 0x0 OR number of sectors transferred
	 *                                 (depends on BIOS!)
	 *                                 (according to Ralph Brown Int List)
	 */
	movb	$CHAR_CHS_READ, %al
	call	Lchr

	/* Load values from active partition table entry */
	movb	1(%si), %dh		/* head */
	movw	2(%si), %cx		/* sect, cyl */
	movw	$0x201, %ax		/* function and number of blocks */
	xorw	%bx, %bx		/* put it at %es:0 */
	int	$0x13
	jnc	booting_os

read_error:
	movw	$eread, %si
	jmp	err_stop

booting_os:
	puts(crlf)
	DBGMSG(CHAR_G)

	/*
	 * Make sure the pbr we loaded has a valid signature at the end.
	 * This also ensures that something did load where we were expecting
	 * it, as there's still a copy of our code there...
	 */
	cmpw	$DOSMBR_SIGNATURE, %es:signature(,1)
	jne	missing_os

	/* jump to the new code (%ds:%si is at the right point) */
	ljmp	$0, $BOOTSEG << 4
	/* not reached */

missing_os:
	movw	$enoos, %si
	jmp	err_stop

/*
 * Display string
 */
Lmessage:
	pushw	%ax
	cld
1:
	lodsb			/* %al = *%si++ */
	testb	%al, %al
	jz	1f
	call    Lchr
	jmp	1b

/*
 *	Lchr: write the error message in %ds:%si to console
 */
Lchr:
	pushw	%ax

#ifdef SERIAL
	pushw	%dx
	movb	$0x01, %ah
	movw	$SERIAL, %dx
	int	$0x14
	popw	%dx
#else
	pushw	%bx
	movb	$0x0e, %ah
	movw	$1, %bx
	int	$0x10
	popw	%bx
#endif
1:	popw	%ax
	ret

/* command packet for LBA read of boot sector */
lba_command:
	.byte	0x10			/* size of command packet */
	.byte	0x00			/* reserved */
	.word	0x0001			/* sectors to transfer, just 1 */
	.word	0			/* target buffer, offset */
	.word	BOOTSEG			/* target buffer, segment */
lba_sector:
	.long	0, 0			/* sector number */

/* Info messages */
info:	.ascii		"!Using drive "
drive_num:
	.byte		'X'
	.ascii		", partition "
part_num:
	.asciz		"Y"

/* Error messages */
efdmbr:	.asciz		"MBR on floppy or old BIOS\r\n"
eread:	.asciz		"\r\nRead error\r\n"
enoos:	.asciz		"No O/S\r\n"
enoboot: .ascii		"No active partition"	/* runs into crlf... */
crlf:	.asciz		"\r\n"

endofcode:
	nop

/* We're going to store a flags word here */

	. = 0x1b4
flags:
	.word	0x0000
	.ascii	"Ox"			/* Indicate that the two bytes */
					/* before us are the flags word */

/* (MBR) NT disk signature offset */
	. = 0x1b8
	.space  4, 0

/* partition table */
/* flag, head, sec, cyl, type, ehead, esect, ecyl, start, len */
	. = DOSPARTOFF	/* starting address of partition table */
pt:
	.byte	0x0,0,0,0,0,0,0,0
	.long	0,0
	.byte	0x0,0,0,0,0,0,0,0
	.long	0,0
	.byte	0x0,0,0,0,0,0,0,0
	.long	0,0
	.byte	DOSACTIVE,0,1,0,DOSPTYP_OPENBSD,255,255,255
	.long	0,0x7FFFFFFF
/* the last 2 bytes in the sector 0 contain the signature */
	. = 0x1fe
signature:
	.short	DOSMBR_SIGNATURE
	. = 0x200
@


1.22
log
@Remove unused define CHAR_CHS_FORCE.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.21 2007/06/25 14:10:17 tom Exp $	*/
d173 1
d178 1
d502 1
a502 1
	movw	SERIAL, %dx
@


1.21
log
@"of of" is wrong - it should be "off of" - but "from" is even nicer
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.20 2004/02/10 00:35:15 tom Exp $	*/
a68 1
#define CHAR_CHS_FORCE	'!'
@


1.20
log
@Enable interrupts before halt when we error out.  Allows use of
Ctl-Alt-Del to reboot in case of failure.

Much testing nick@@; thanks.

ok weingart@@, deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.19 2004/01/05 00:08:23 tom Exp $	*/
d206 1
a206 1
	 * there is a possibility that you boot of of HD #2, and still
@


1.19
log
@Major overhaul of our master boot record.

We now use EDD calls if the disk supports it, so we can boot partitions
that start above the 8 GB CHS limit.  Of itself, this change does not
remove the current 8 GB limit for OpenBSD/i386.

Much testing nick@@; thanks.

ok weingart@@, deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.18 2003/06/03 20:22:12 mickey Exp $	*/
d60 1
a60 1
 * We load the partition boot record (PBR) /boot at seg:offset 4000:0000
d251 2
a252 2
	cli
	hlt
@


1.18
log
@three four kills
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.17 2003/04/17 03:43:19 drahn Exp $	*/
d5 1
d44 27
a70 2
#define data32	.byte 0x66
#define addr32	.byte 0x67
d72 1
a72 3
#define BOOTBIOS	0x7c0	/* segment where we are loaded */
#define BOOTRELOC	0x7a0	/* segment where to relocate */
#define PARTSZ		16	/* each partition table entry is 16 bytes */
d81 1
a81 5
#define DBGMSG(msg)		\
	movb    $msg, %al;	\
	/* call    Lchr */;	\
	.byte	0xe8;		\
	.word	Lchr - . - 2
d83 1
a83 1
#define DBGMSG(msg)
d85 7
a91 6
#define	puts(s)			\
	data32;			\
	movl	$s, %esi;	\
	/* call Lmessage */;	\
	.byte	0xe8;		\
	.word	Lmessage - . - 2
d94 1
d99 1
a99 2
	data32
	ljmp 	$BOOTBIOS, $1f
d102 23
a124 6
	movl	%cs, %eax
	cli
	mov	%ax, %ss
	data32
	movl	$0xfffc, %esp
	sti
d127 1
a127 1
	mov	%ax, %ds
d130 26
a155 10
	/* Relocate 512 bytes so we can load PBS here  */
	data32
	movl	$BOOTRELOC, %eax
	movl	%eax, %es
	data32
	xorl	%esi, %esi
	data32
	xorl	%edi, %edi
	data32
	movl	$0x200, %ecx
d161 1
a161 2
	data32
	ljmp $BOOTRELOC, $reloc
d166 4
a169 4
	pushl	%ds
	popl	%es	/* next boot is at the same place as we were loaded */
	pushl	%cs
	popl	%ds	/* and %ds is at the %cs */
a172 10
	 * Do we need to do this?  Most things at this level
	 * do not know or care (on a PC) where the output is
	 * happening to go.  I think if we are headless,
	 * /boot should figure (as it does now) that out.
	 *
	 * If there is a problem with this stage of the boot
	 * process, connect up a monitor and kbd, and see what
	 * is going on.  Left here for the time being.
	 *
	 * --Toby.
d174 1
a174 1
	xorl	%eax, %eax
d176 1
a176 2
	data32
	movl	$SERIAL, %dx
d180 22
a201 13
	/* bootstrap passes us drive number in %dl
	 *
	 * XXX - This is not always true.  We currently
	 * check if %dl points to a HD, and if not we
	 * complain, and set it to point to the first
	 * HDD.  Note, this is not 100% correct, since
	 * there is a possibility that you boot of of
	 * HD #2, and still get (%dl & 0x80) == 0x00,
	 * these type of systems will loose.  I don't
	 * know of any like this, but I've come to the
	 * conclusion, that if it can exist, it will,
	 * someplace in the PC world.  If anyone knows
	 * how to fix this, speak up!
d203 5
a207 1
	 * Toby - Thu Jul 31 21:01:00 CDT 1997
d210 1
a210 1
	jnz	1f
d213 9
a221 15
	 * Note: MBR (this code) should never
	 * be on a floppy.  It does not belong
	 * there, so %dl should never be 0x00.
	 *
	 * Here we simply complain (should we?),
	 * and then hardcode the boot drive to
	 * 0x80.
	 */
	puts(fdmbr)

	/* If we are passed bogus data, set it to HD #1.
	 * We should load the value from a hard coded
	 * location in this sector.  Maybe I'll write
	 * that next, since my machines seem to be one
	 * of the weird ones...
d225 9
a233 28
	/* Do we need to check our signature?  The BIOS will
	 * check it for us, I doubt there is a need for us to
	 * do the same thing over again.  If we fail here,
	 * something terrible is wrong.  However, I doubt we
	 * can recover anyways.  The message might be nice
	 * for the (l)user though.
	 */
1:	xor	%bx, %bx
	# cmpw	$DOSMBR_SIGNATURE, (%bx)
	.byte	0x81, 0xbf
	.word	signature
	.word	DOSMBR_SIGNATURE
	je	sigok
	puts(esig)

	/* find the first active partition
	 * Note: this should be the only active
	 * partition.  We currently don't check
	 * for that, but we really should.  If
	 * and when I feel up to it, I'll add
	 * that code.
	 */
sigok:
	data32
	movl	$pt, %esi
	data32
	movl	$NDOSPART, %ecx
1:
d235 2
a236 2
	# movb	(%si), %al
	.byte	0x8a, 0x44, 0x00
d239 3
a241 3
	data32
	addl	$PARTSZ, %esi
	loop	1b
d245 2
a246 1
	puts(noboot)
d248 3
d254 1
a254 1
	jmp	err_stop
a255 1
	/* Found bootable partition */
d257 4
a261 17
	pushl	%eax
	/* Save drive and partition */
	movl	%edx, %eax
	andl	$0x0F, %eax
	orl	$0x30, %eax
	#movb	%al, adrive
	.byte	0xA2
	.word	adrive

	movl	%ecx, %eax
	decl	%eax
	xorl	$0x03, %eax
	andl	$0x0F, %eax
	orl	$0x30, %eax
	#movb	%al, aprtn
	.byte	0xA2
	.word	aprtn
d263 183
a445 1
	popl	%eax
d448 6
a453 6
	# movb	1(%si), %dh	# head
	.byte   0x8a, 0x74, 0x01
	# movw	2(%si), %cx	# sect, cyl
	.byte   0x8b, 0x4c, 0x02
	# movb	4(%si), %al	# partition type
	.byte   0x8a, 0x44, 0x04
d455 2
a456 18
/*
# BIOS call "INT 0x13 Function 0x2" to read sectors from disk into memory
#       Call with       %ah = 0x2
#                       %al = number of sectors
#                       %ch = cylinder
#                       %cl = sector
#                       %dh = head
#                       %dl = drive (0x80 for hard disk, 0x0 for floppy disk)
#                       %es:%bx = segment:offset of buffer
#       Return:
#                       %al = 0x0 on success; err code on failure
*/
	data32
	movl	$0x200 | 1, %eax	/* number of blocks */
	xor	%bx, %bx		/* put it at %es:0 */
	int	$0x13
	jnc	1f
	puts(eread)
d459 2
a460 1
1:
a461 1
	puts(info)
d463 10
a472 3
	# jump to the new code (%ds:%si is at the right point)
	data32
	ljmp	$0, $BOOTBIOS << 4
d475 4
d483 1
a483 1
	pushl	%eax
d486 1
a486 1
	lodsb			# load a byte into %al
d489 1
a489 3
	/* call	Lchr */
	.byte	0xe8
	.word	Lchr - . - 2
d492 3
a494 3
#
#	Lchr: write the error message in %ds:%si to console
#
d496 1
a496 1
	pushl	%eax
d498 8
a505 2
#ifndef SERIAL
	pushl	%ebx
d507 1
a507 2
	xor	%bx, %bx
	inc	%bx		/* movw $0x01, %bx */
d509 1
a509 8
	popl	%ebx
#else
	pushl	%edx
	movb	$0x01, %ah
	data32
	movl	SERIAL, %dx
	int	$0x14
	popl	%edx
d511 1
a511 1
1:	popl	%eax
d514 10
d525 6
a530 5
info:	.ascii		"Using Drive: "
adrive:	.byte		'X'
	.ascii		" Partition: "
aprtn:	.byte		'Y'
	.asciz		"\r\n"
d533 5
a537 4
fdmbr:	.asciz		"MBR on floppy or old BIOS\r\n"
eread:	.asciz		"Read error\r\n"
noboot: .asciz		"No active partition\r\n"
esig:	.asciz		"Invalid Signature\r\n"
d542 9
a550 1
/* (MBR) NT registry offset */
d556 1
a556 1
	. = DOSPARTOFF	# starting address of partition table
a570 1

@


1.17
log
@i386 ELF bootloader. developed with weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.16 2002/01/08 23:14:51 kjell Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.16
log
@Fix 16 vs. 32-bit mismatch. Solves the most common MBR hang.
This is from Mickey's tree. I inadvertently committed it
without his permission last time. ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.15 2001/12/15 21:28:45 mickey Exp $	*/
d86 1
a86 1
	movl	%cs, %ax
d88 1
a88 1
	movl	%ax, %ss
d94 1
a94 1
	movl	%ax, %ds
d100 1
a100 1
	movl	%ax, %es
d136 1
a136 1
	xorl	%ax, %ax
d188 1
a188 1
1:	xorl	%bx, %bx
d230 1
a230 1
	pushl	%ax
d232 3
a234 3
	movl	%dx, %ax
	andl	$0x0F, %ax
	orl	$0x30, %ax
d239 5
a243 5
	movl	%cx, %ax
	decl	%ax
	xor	$0x03, %ax
	andl	$0x0F, %ax
	orl	$0x30, %ax
d248 1
a248 1
	popl	%ax
d272 1
a272 1
	xorl	%bx, %bx		/* put it at %es:0 */
d311 2
a312 2
	xorl	%bx, %bx
	incl	%bx		/* movw $0x01, %bx */
@


1.15
log
@first i gave you one of the reasons it mmakes thing better.
second i did not see the final diff.
third i never said you should commit this.
fourth, 10x for running around offending lusers i'm
trying to resolve their problems with.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.13 1998/03/11 13:05:07 graichen Exp $	*/
d64 3
a66 2
	data32;			\
	call    chr
d297 3
a299 2
	data32
	call	chr
d303 1
a303 1
#	chr: write the error message in %ds:%si to console
d305 1
a305 1
chr:
a323 1
	data32
@


1.15.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.16 2002/01/08 23:14:51 kjell Exp $	*/
d64 2
a65 3
	/* call    Lchr */;	\
	.byte	0xe8;		\
	.word	Lchr - . - 2
d296 2
a297 3
	/* call	Lchr */
	.byte	0xe8
	.word	Lchr - . - 2
d301 1
a301 1
#	Lchr: write the error message in %ds:%si to console
d303 1
a303 1
Lchr:
d322 1
@


1.15.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 1
a86 1
	movl	%cs, %eax
d88 1
a88 1
	mov	%ax, %ss
d94 1
a94 1
	mov	%ax, %ds
d100 1
a100 1
	movl	%eax, %es
d136 1
a136 1
	xorl	%eax, %eax
d188 1
a188 1
1:	xor	%bx, %bx
d230 1
a230 1
	pushl	%eax
d232 3
a234 3
	movl	%edx, %eax
	andl	$0x0F, %eax
	orl	$0x30, %eax
d239 5
a243 5
	movl	%ecx, %eax
	decl	%eax
	xorl	$0x03, %eax
	andl	$0x0F, %eax
	orl	$0x30, %eax
d248 1
a248 1
	popl	%eax
d272 1
a272 1
	xor	%bx, %bx		/* put it at %es:0 */
d311 2
a312 2
	xor	%bx, %bx
	inc	%bx		/* movw $0x01, %bx */
@


1.14
log
@Fix a long-standing alignment bug by removing the 32-but call/return
on Lchr. Notice Lmessage is using Lchr's return, and it has always
been a 16-bit call.

This should be the root of many (most?) of the Drive:0 Partition:3
hangs.

tip o the hat to mickey, who fixed it without necessarily knowing it,
and toby, who put the final nail in.

gas sucks.
@
text
@d64 2
a65 3
	/* call    Lchr */;	\
	.byte	0xe8;		\
	.word	Lchr - . - 2
d296 2
a297 3
	/* call	Lchr */
	.byte	0xe8
	.word	Lchr - . - 2
d301 1
a301 1
#	Lchr: write the error message in %ds:%si to console
d303 1
a303 1
Lchr:
d322 1
@


1.13
log
@remove wrong end of comment which breaks compilation with -DSERIAL
enabled
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.12 1997/11/05 02:14:18 mickey Exp $	*/
d64 3
a66 2
	data32;			\
	call    chr
d297 3
a299 2
	data32
	call	chr
d303 1
a303 1
#	chr: write the error message in %ds:%si to console
d305 1
a305 1
chr:
a323 1
	data32
@


1.13.10.1
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d64 2
a65 3
	/* call    Lchr */;	\
	.byte	0xe8;		\
	.word	Lchr - . - 2
d296 2
a297 3
	/* call	Lchr */
	.byte	0xe8
	.word	Lchr - . - 2
d301 1
a301 1
#	Lchr: write the error message in %ds:%si to console
d303 1
a303 1
Lchr:
d322 1
@


1.13.10.2
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.13.10.1 2002/03/06 01:01:01 niklas Exp $	*/
d86 1
a86 1
	movl	%cs, %eax
d88 1
a88 1
	mov	%ax, %ss
d94 1
a94 1
	mov	%ax, %ds
d100 1
a100 1
	movl	%eax, %es
d136 1
a136 1
	xorl	%eax, %eax
d188 1
a188 1
1:	xor	%bx, %bx
d230 1
a230 1
	pushl	%eax
d232 3
a234 3
	movl	%edx, %eax
	andl	$0x0F, %eax
	orl	$0x30, %eax
d239 5
a243 5
	movl	%ecx, %eax
	decl	%eax
	xorl	$0x03, %eax
	andl	$0x0F, %eax
	orl	$0x30, %eax
d248 1
a248 1
	popl	%eax
d272 1
a272 1
	xor	%bx, %bx		/* put it at %es:0 */
d311 2
a312 2
	xor	%bx, %bx
	inc	%bx		/* movw $0x01, %bx */
@


1.13.10.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.13.10.2 2003/05/13 19:42:09 ho Exp $	*/
d15 5
@


1.13.10.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a4 1
 * Copyright (c) 2003 Tom Cosgrove <tom.cosgrove@@arches-consulting.com>
d43 5
a47 21
/*
 * Memory layout:
 *
 * 0x07C00 -> 0x07DFF	BIOS loads us here	(at  31k)
 * 0x07E00 -> 0x17BFC	our stack		(to  95k)
 *
 * 0x07A00 -> 0x07BFF	we relocate to here	(at  30k5)
 *
 * 0x07C00 -> 0x07DFF	we load PBR here	(at  31k)
 *
 * The BIOS loads us at physical address 0x07C00.  We use a long jmp to
 * normalise our address to seg:offset 07C0:0000.  We then relocate to
 * 0x07A00, seg:offset 07A0:0000.
 *
 * We use a long jmp to normalise our address to seg:offset 07A0:0000
 * We set the stack to start at 07C0:FFFC (grows down on i386)
 * We load the partition boot record (PBR) /boot at seg:offset 4000:0000
 */
#define BOOTSEG		0x7c0	/* segment where we are loaded */
#define BOOTRELOCSEG	0x7a0	/* segment where we relocate to */
#define BOOTSTACKOFF	0xfffc	/* stack starts here, grows down */
a49 7
#define CHAR_LBA_READ	'.'
#define CHAR_CHS_READ	';'
#define CHAR_CHS_FORCE	'!'
#define CHAR_SHIFT_SEEN	0x07	/* Use BEL */

#define MBR_FLAGS_FORCE_CHS	0x0001

d57 5
a61 1
#define DBGMSG(c)	movb	$c, %al;	call	Lchr
d63 1
a63 1
#define DBGMSG(c)
d65 6
a70 7

/* Clobbers %al - maybe more */
#define	putc(c)		movb	$c, %al;	call	Lchr

/* Clobbers %esi - maybe more */
#define	puts(s)		movw	$s, %si;	call	Lmessage

a72 1
	.code16
d77 2
a78 1
	ljmp 	$BOOTSEG, $1f
d81 6
a86 23
	movw	%cs, %ax

	/*
	 * We don't need to disable and re-enable interrupts around the
	 * the load of ss and sp.
	 *
	 * From 80386 Programmer's Reference Manual:
	 * "A MOV into SS inhibits all interrupts until after the execution
	 * of the next instruction (which is presumably a MOV into eSP)"
	 *
	 * According to Hamarsoft's 86BUGS list (which is distributed with
	 * Ralph Brown's Interrupt List), some early 8086/88 processors
	 * failed to disable interrupts following a load into a segment
	 * register, but this was fixed with later steppings.
	 *
	 * Accordingly, this code will fail on very early 8086/88s, but
	 * nick@@ will just have to live with it.  Others will note that
	 * we require an 80386 (or compatible) or above processor, anyway.
	 */
	/* cli */
	movw	%ax, %ss
	movw	$BOOTSTACKOFF, %sp
	/* sti */			/* XXX not necessary; see above */
d89 1
a89 1
	movw	%ax, %ds
d92 10
a101 26
	/*
	 * On the PC architecture, the boot record (originally on a floppy
	 * disk) is loaded at 0000:7C00 (hex) and execution starts at the
	 * beginning.
	 *
	 * When hard disk support was added, a scheme to partition disks into
	 * four separate partitions was used, to allow multiple operating
	 * systems to be installed on the one disk.  The boot sectors of the
	 * operating systems on each partition would of course expect to be
	 * loaded at 0000:7C00.
	 *
	 * The first sector of the hard disk is the master boot record (MBR).
	 * It is this which defines the partitions and says which one is
	 * bootable.  Of course, the BIOS loads the MBR at 0000:7C00, the
	 * same location where the MBR needs to load the partition boot
	 * record (PBR, called biosboot in OpenBSD).
	 *
	 * Therefore, the MBR needs to relocate itself before loading the PBR.
	 *
	 * Make it so.
	 */
	movw	$BOOTRELOCSEG, %ax
	movw	%ax, %es
	xorw	%si, %si
	xorw	%di, %di
	movw	$0x200, %cx		/* Bytes in MBR, relocate it all */
d107 2
a108 1
	ljmp $BOOTRELOCSEG, $reloc
d113 4
a116 4
	pushw	%ds
	popw	%es	/* next boot is at the same place as we were loaded */
	pushw	%cs
	popw	%ds	/* and %ds is at the %cs */
d120 10
d131 1
a131 1
	xorw	%ax, %ax
d133 2
a134 1
	movw	$SERIAL, %dx
d138 13
a150 22
	/*
	 * If the SHIFT key is held down on entry, force CHS read
	 */

	/*
	 * BIOS call "INT 0x16 Get Keyboard Shift Flags
	 *	Call with	%ah = 0x02
	 *	Return:
	 *			%al = shift flags
	 *			%ah - undefined by many BIOSes
	 */
	movb	$0x02, %ah
	int	$0x16
	testb	$0x3, %al	/* Either shift key down? */
	jz	no_shift

	putc(CHAR_SHIFT_SEEN)	/* Signal that shift key was seen */

	orb	$MBR_FLAGS_FORCE_CHS, flags

no_shift:
	/* BIOS passes us drive number in %dl
d152 1
a152 5
	 * XXX - This is not always true.  We currently check if %dl
	 * points to a HD, and if not we complain, and set it to point
	 * to the first HDD.  Note, this is not 100% correct, since
	 * there is a possibility that you boot of of HD #2, and still
	 * get (%dl & 0x80) == 0x00, these type of systems will lose.
d155 1
a155 1
	jnz	drive_ok
d158 15
a172 9
	 * Note: MBR (this code) should never be on a floppy.  It does
	 * not belong there, so %dl should never be 0x00.
	 *
	 * Here we simply complain (should we?), and then hardcode the
	 * boot drive to 0x80.
	 */
	puts(efdmbr)

	/* If we are passed bogus data, set it to HD #1
d176 28
a203 9
drive_ok:
	/* Find the first active partition.
	 * Note: this should be the only active partition.  We currently
	 * don't check for that.
	 */
	movw	$pt, %si

	movw	$NDOSPART, %cx
find_active:
d205 2
a206 2
	movb	(%si), %al

d209 3
a211 3

	addw	$PARTSZ, %si
	loop	find_active
d215 1
a215 2
	movw	$enoboot, %si

a216 3
	call	Lmessage

stay_stopped:
d220 1
a220 1
	jmp	stay_stopped
d222 1
a223 4
	/*
	 * Found bootable partition
	 */

d225 17
d243 1
a243 5
	/* Store the drive number (from %dl) in decimal */
	movb	%dl, %al
	andb	$0x0F, %al
	addb	$'0', %al
	movb	%al, drive_num
d245 7
a251 13
	/*
	 * Store the partition number, in decimal.
	 *
	 * We started with cx = 4; if found we want part '0'
	 *                 cx = 3;                  part '1'
	 *                 cx = 2;                  part '2'
	 *                 cx = 1;                  part '3'
	 *
	 * We'll come into this with no other values for cl.
	 */
	movb	$'0'+4, %al
	subb	%cl, %al
	movb	%al, part_num
d253 15
a267 169
	/*
	 * Tell operator what partition we're trying to boot.
	 *
	 * Using drive X, partition Y
	 * - this used to be printed out after successfully loading the
	 *   partition boot record; we now print it out before
	 */
	pushw	%si
	movw	$info, %si
	testb	$MBR_FLAGS_FORCE_CHS, flags
	jnz	1f
	incw	%si
1:
	call	Lmessage
	popw	%si

	/*
	 * Partition table entry format:
	 *
	 * 0x00	BYTE boot indicator (0x80 = active, 0x00 = inactive)
	 * 0x01	BYTE start head
	 * 0x02	WORD start cylinder, sector
	 * 0x04	BYTE system type (0xA6 = OpenBSD)
	 * 0x05 BYTE end head
	 * 0x06	WORD end cylinder, sector
	 * 0x08	LONG start LBA sector
	 * 0x0C	LONG number of sectors in partition
	 *
	 * In the case of a partition that extends beyond the 8GB boundary,
	 * the LBA values will be correct, the CHS values will have their
	 * maximums (typically (C,H,S) = (1023,255,63)).
	 *
	 * %ds:%si points to the active partition table entry.
	 */

	/* We will load the partition boot sector (biosboot) where we
	 * were originally loaded.  We'll check to make sure something
	 * valid comes in.  So that we don't find ourselves, zero out
	 * the signature at the end.
	 */
	movw	$0, %es:signature(,1)

	/*
	 * Have we been instructed to ignore LBA?
	 */
	testb	$MBR_FLAGS_FORCE_CHS, flags
	jnz	do_chs

	/*
	 * We will use the LBA sector number if we have LBA support,
	 * so find out.
	 */

	/*
	 * BIOS call "INT 0x13 Extensions Installation Check"
	 *	Call with	%ah = 0x41
	 *			%bx = 0x55AA
	 *			%dl = drive (0x80 for 1st hd, 0x81 for 2nd, etc)
	 *	Return:
	 *			carry set: failure
	 *				%ah = error code (0x01, invalid func)
	 *			carry clear: success
	 *				%bx = 0xAA55 (must verify)
	 *				%ah = major version of extensions
	 *				%al   (internal use)
	 *				%cx = capabilities bitmap
	 *					0x0001 - extnd disk access funcs
	 *					0x0002 - rem. drive ctrl funcs
	 *					0x0004 - EDD functions with EBP
	 *				%dx   (extension version?)
	 */

	movb	%dl, (%si)		/* Store drive here temporarily */
					/* (This call trashes %dl) */
					/*
					 * XXX This is actually the correct
					 *     place to store this.  The 0x80
					 *     value used to indicate the
					 *     active partition is by intention
					 *     the same as the BIOS drive value
					 *     for the first hard disk (0x80).
					 *     At one point, 0x81 would go here
					 *     for the second hard disk; the
					 *     0x80 value is often used as a
					 *     bit flag for testing, rather
					 *     than an exact byte value.
					 */
	movw	$0x55AA, %bx
	movb	$0x41, %ah
	int	$0x13

	movb	(%si), %dl		/* Get back drive number */

	jc	do_chs			/* Did the command work? Jump if not */
	cmpw	$0xAA55, %bx		/* Check that bl, bh exchanged */
	jne	do_chs			/* If not, don't have EDD extensions */
	testb	$0x01, %cl		/* And do we have "read" available? */
	jz	do_chs			/* Again, use CHS if not */

do_lba:
	/*
	 * BIOS call "INT 0x13 Extensions Extended Read"
	 *	Call with	%ah = 0x42
	 *			%dl = drive (0x80 for 1st hd, 0x81 for 2nd, etc)
	 *			%ds:%si = segment:offset of command packet
	 *	Return:
	 *			carry set: failure
	 *				%ah = error code (0x01, invalid func)
	 *				command packet's sector count field set
	 *				to the number of sectors successfully
	 *				transferred
	 *			carry clear: success
	 *				%ah = 0 (success)
	 *	Command Packet:
	 *			0x0000	BYTE	packet size (0x10 or 0x18)
	 *			0x0001	BYTE	reserved (should be 0)
	 *			0x0002	WORD	sectors to transfer (max 127)
	 *			0x0004	DWORD	seg:offset of transfer buffer
	 *			0x0008	QWORD	starting sector number
	 */
	movb	$CHAR_LBA_READ, %al
	call	Lchr

	/* Load LBA sector number from active partition table entry */
	movl	8(%si), %ecx
	movl	%ecx, lba_sector

	pushw	%si			/* We'll need %si later */

	movb	$0x42, %ah
	movw	$lba_command, %si
	int	$0x13

	popw	%si			/* (get back %si) flags unchanged */

	jnc	booting_os		/* If it worked, run the pbr we got */

	/*
	 * LBA read failed, fall through to try CHS read
	 */

do_chs:
	/*
	 * BIOS call "INT 0x13 Function 0x2" to read sectors from disk into
	 * memory
	 *       Call with       %ah = 0x2
	 *                       %al = number of sectors
	 *                       %ch = cylinder & 0xFF
	 *                       %cl = sector (0-63) | rest of cylinder bits
	 *                       %dh = head
	 *                       %dl = drive (0x80 for hard disk)
	 *                       %es:%bx = segment:offset of buffer
	 *       Return:
	 *                       carry set: failure
	 *                           %ah = err code
	 *                           %al = number of sectors transferred
	 *                       carry clear: success
	 *                           %al = 0x0 OR number of sectors transferred
	 *                                 (depends on BIOS!)
	 *                                 (according to Ralph Brown Int List)
	 */
	movb	$CHAR_CHS_READ, %al
	call	Lchr

	/* Load values from active partition table entry */
	movb	1(%si), %dh		/* head */
	movw	2(%si), %cx		/* sect, cyl */
	movw	$0x201, %ax		/* function and number of blocks */
	xorw	%bx, %bx		/* put it at %es:0 */
d269 2
a270 4
	jnc	booting_os

read_error:
	movw	$eread, %si
d273 1
a273 2
booting_os:
	puts(crlf)
d275 1
d277 3
a279 10
	/*
	 * Make sure the pbr we loaded has a valid signature at the end.
	 * This also ensures that something did load where we were expecting
	 * it, as there's still a copy of our code there...
	 */
	cmpw	$DOSMBR_SIGNATURE, %es:signature(,1)
	jne	missing_os

	/* jump to the new code (%ds:%si is at the right point) */
	ljmp	$0, $BOOTSEG << 4
a281 4
missing_os:
	movw	$enoos, %si
	jmp	err_stop

d286 1
a286 1
	pushw	%ax
d289 1
a289 1
	lodsb			/* %al = *%si++ */
d292 3
a294 1
	call    Lchr
d297 3
a299 3
/*
 *	Lchr: write the error message in %ds:%si to console
 */
d301 1
a301 1
	pushw	%ax
d303 9
a311 2
#ifdef SERIAL
	pushw	%dx
d313 2
a314 1
	movw	SERIAL, %dx
d316 1
a316 7
	popw	%dx
#else
	pushw	%bx
	movb	$0x0e, %ah
	movw	$1, %bx
	int	$0x10
	popw	%bx
d318 1
a318 1
1:	popw	%ax
a320 10
/* command packet for LBA read of boot sector */
lba_command:
	.byte	0x10			/* size of command packet */
	.byte	0x00			/* reserved */
	.word	0x0001			/* sectors to transfer, just 1 */
	.word	0			/* target buffer, offset */
	.word	BOOTSEG			/* target buffer, segment */
lba_sector:
	.long	0, 0			/* sector number */

d322 5
a326 6
info:	.ascii		"!Using drive "
drive_num:
	.byte		'X'
	.ascii		", partition "
part_num:
	.asciz		"Y"
d329 4
a332 5
efdmbr:	.asciz		"MBR on floppy or old BIOS\r\n"
eread:	.asciz		"\r\nRead error\r\n"
enoos:	.asciz		"No O/S\r\n"
enoboot: .ascii		"No active partition"	/* runs into crlf... */
crlf:	.asciz		"\r\n"
d337 1
a337 9
/* We're going to store a flags word here */

	. = 0x1b4
flags:
	.word	0x0000
	.ascii	"Ox"			/* Indicate that the two bytes */
					/* before us are the flags word */

/* (MBR) NT disk signature offset */
d343 1
a343 1
	. = DOSPARTOFF	/* starting address of partition table */
d358 1
@


1.13.10.5
log
@Merge with the trunk
@
text
@d60 1
a60 1
 * The partition boot record (PBR) loads /boot at seg:offset 4000:0000
d251 2
a252 2
	sti				/* Ensure Ctl-Alt-Del will work */
	hlt				/* (don't require power cycle) */
@


1.12
log
@define puts()
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.11 1997/08/29 19:47:24 mickey Exp $	*/
d123 1
a123 1
	/* Initialize the serial port to 9600 baud, 8N1. */
@


1.11
log
@don't use private defines, use ones exported from includes
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.10 1997/08/13 02:22:02 mickey Exp $	*/
d69 6
d170 1
a170 4
	data32
	movl	$fdmbr, %esi
	data32
	call	message
d193 1
a193 4
	data32
	movl	$esig, %esi
	data32
	call	message
d219 1
a219 4
	data32
	movl	$noboot, %esi
	data32
	call	message
d274 1
a274 4
	data32
	movl    $eread, %esi
	data32
	call	message
d279 1
a279 4
	data32
	movl	$info, %esi
	data32
	call	message
d289 1
a289 1
message:
d301 1
a301 1
#	message: write the error message in %ds:%si to console
@


1.10
log
@reuse ret code for both message and chr
some tab adjustment (4-pos tab is not good ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.9 1997/08/13 00:21:45 niklas Exp $	*/
d46 1
a46 1
#include <machine/specialreg.h>
a52 2
#define SIGNATURE	0xaa55	/* MBR signature */
#define NUMPART		4	/* number of partitions in partition table */
a53 2
#define BSDPART		0xA6	/* OpenBSD partition */
#define BOOTABLE	0x80	/* bootable partition */
d185 1
a185 1
	# cmpw	$SIGNATURE, (%bx)
d188 1
a188 1
	.word	SIGNATURE
d206 1
a206 1
	movl	$NUMPART, %ecx
d211 1
a211 1
	cmpb	$BOOTABLE, %al
d356 1
a356 1
	. = 0x1be	# starting address of partition table
d364 1
a364 1
	.byte	BOOTABLE,0,1,0,BSDPART,255,255,255
d369 1
a369 1
	.short	SIGNATURE
@


1.9
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.8 1997/08/09 21:03:47 weingart Exp $	*/
d5 28
a33 1

d61 1
a61 1
#define CHAR_R		'R' /* relocated */
d193 1
a193 1
	je		sigok
d216 1
a216 1
	je		found
d231 1
a231 1
	jmp		err_stop
d240 1
a240 1
	orl		$0x30, %ax
d247 1
a247 1
	xor		$0x03, %ax
d249 1
a249 1
	orl		$0x30, %ax
d280 1
a280 1
	jnc		1f
d285 1
a285 2
	jmp		err_stop

d299 14
a316 14
/*
#ifndef SERIAL
# BIOS call "INT 10H Function 0Eh" to write character to console
#	Call with	%ah = 0x0e
#			%al = character
#			%bh = page
#			%bl = foreground color
#else
# BIOS call "INT 14H Function 01h" to write character to console
#	Call with	%ah = 0x01
#			%al = character
#			%dx = port number
#endif
*/
d334 1
a334 1
	popl	%eax
a337 17
/*
 * Display string
 */
message:
	pushl	%ax
	cld
1:
	lodsb			# load a byte into %al
	testb	%al, %al
	jz	1f
	data32
	call	chr
	jmp	1b
1:
	popl	%ax
	ret

d341 1
a341 1
		.ascii		" Partition: "
d343 1
a343 1
		.asciz		"\r\n"
@


1.8
log
@Fix boot message
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.7 1997/08/08 22:46:13 weingart Exp $	*/
d268 1
a268 1
	# jump to the new code (%ds:%si is at he right point)
@


1.7
log
@Sync up
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.6 1997/08/08 17:13:13 weingart Exp $	*/
a208 1
#if 0
d214 3
a216 1
	movb	%al, adrive
d223 3
a225 1
	movb	%al, aprtn
a227 1
#endif
a262 1
#if 1
a266 1
#endif
@


1.6
log
@Temporary fix
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.5 1997/08/08 16:50:19 weingart Exp $	*/
d210 2
a211 10
	pushl	%edx
	pushl	%esi
	pushl	%ecx

	/* Print out drive and partition */
	data32
	movl	$drive, %esi
	data32
	call	message

d215 1
a215 7
	data32
	call	chr

	data32
	movl	$partn, %esi
	data32
	call	message
d217 1
a217 1
	popl	%eax
d222 1
a222 2
	data32
	call	chr
d224 1
a224 8
	data32
	movl	$newln, %esi
	data32
	call	message

	/* Restore %esi and %edx */
	popl	%esi
	popl	%edx
d261 6
d330 5
a334 3
drive:	.asciz		"Using Drive: "
partn:	.asciz		" Partition: "
newln:	.asciz		"\r\n"
@


1.5
log
@More pedantic
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.4 1997/08/08 16:42:13 weingart Exp $	*/
d209 1
d232 1
d247 1
@


1.4
log
@Thanks Niklas (nuke push/pop)
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.3 1997/08/07 11:49:59 niklas Exp $	*/
d72 1
a72 1
	xorl	%si, %si
d74 1
a74 1
	xorl	%di, %di
d183 1
a183 1
	movl	$NUMPART, %cx
a219 1
	xor		$0x03, %ax
d231 1
d272 1
a272 1
	movl    $eread, %si
@


1.3
log
@grammar
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.2 1997/08/01 18:39:45 weingart Exp $	*/
a208 1
	pushl	%eax
d220 1
a244 1
	popl	%eax
@


1.2
log
@First pass at MBR.  Couple of bugs yet, but I can't work
them out until I get my SCSI disks up.

Note: There are currently 4 bytes left with the debugging
version.  Be careful.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbr.S,v 1.1 1997/03/31 03:12:19 weingart Exp $	*/
d123 1
a123 1
	 * conclusion, that if it can exists, it will,
@


1.1
log
@Initial /boot stuff (from Mickey)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1997 Michael Shalayeff
d16 1
a16 16
/*	$OpenBSD: start.S,v 1.4.2.5 1996/10/28 12:14:29 mickey Exp $	*/

/*
 * Copyright (c) 1996 Michael Shalayeff
 */

/* Copyright (c) 1996 VaX#n8 (vax@@linkdead.paranoia.com)
 * last edited 9 July 1996
 * many thanks to Erich Boleyn (erich@@uruk.org) for putting up with
 * all my questions, and for his work on GRUB
 * You may use this code or fragments thereof in a manner consistent
 * with the other copyrights as long as you retain my pseudonym and
 * this copyright notice in the file.
 */

	.file	"start.S"
a29 1
#define OLDBSDPART	0xA5	/* {386,Net,Free}BSD partition */
d34 2
a35 3
#define CHAR_L		'L'	/* looking up bootable partition */
#define CHAR_P		'P'	/* partition table corrupted */
#define CHAR_O		'O'	/* force OpenBSD load */
d51 5
d57 1
a57 2
	# set up stack(%ss:%esp)
	cli			/* disable interrupts w/o stack */
d61 3
a63 2
	sti			/* we have stack, do ints */
	/* setup %ds */
d65 1
d67 1
a67 1
	/* relocate the code to leave the space for boot stage */
d71 1
d73 1
d75 2
a76 2
	xorl	%cx, %cx
	incb	%ch	/* movl $0x100, %ecx */
d79 1
a79 1
	movsw
d81 1
a81 1
	# jump to the relocated code
d83 3
a85 3
	ljmp $BOOTRELOC, $1f
1:
	DBGMSG(CHAR_S)
d87 1
a87 1
	/* setup %es, %ds */
d94 12
a105 1
	# Initialize the serial port to 9600 baud, 8N1.
d107 1
a107 1
       	movb	$0xe3, %ax
d113 16
a128 1
	/* bootstrap passes us drive number in %dl */
d132 9
a140 1
	/* mbr on floppy ??? */
d146 15
d166 5
a170 2
	je	1f
	DBGMSG(CHAR_P)
d172 8
a179 2
	/* find the first active partition */
1:	DBGMSG(CHAR_L)
d185 1
d189 1
a189 1
	je	2f
a192 1
	jmp	1f	/* no bootable -- find $BSDPART */
d194 19
a212 5
2:	# test if bootable is ours
	# movb	4(%si), %al	# partition type
	.byte   0x8a, 0x44, 0x04
	cmpb	$BSDPART, %al
	je	found
d214 1
a214 1
	/* else: ask! */
d216 1
a216 1
	movl	$prompt, %esi
d220 5
a224 10
	# BIOS call: read char from kbd
	#	return: %ah == scancode, %al == ascii
	xorl	%ax, %ax
	int	$0x16

	/* load active, if not */
	cmpb	'n', %al
	je	found
	cmpb	'N', %al
	je	found
a225 3
1:
	/* else: find OpenBSD partition */
	DBGMSG(CHAR_O)
d227 1
a227 1
	movl	$pt, %esi
d229 5
a233 6
	movl	$NUMPART, %ecx
1:
	# movb	(%si), %al
	.byte	0x8a, 0x44, 0x00
	cmpb	$BSDPART, %al
	je	found
d235 2
a236 2
	addl	$PARTSZ, %esi
	loop	1b
d238 1
a238 2
	movl	$enoboot, %esi
err_stop:
a240 2
	cli
	hlt
d242 6
a247 2
found:
	DBGMSG(CHAR_B)
d271 1
d274 4
a277 1
	jc	err_stop
d279 1
d322 1
a322 1
	popl	%ax
d343 4
a346 1
/* error messages */
d348 2
a349 1
fdmbr:	.asciz		"MBR on fd?\r\n"
d351 2
a352 2
enoboot: .asciz		"No partition to boot\r\n"
prompt:	.asciz		"OpenBSD? "
d357 5
a361 1
/* throw in a partition table */
d372 1
a372 1
	.long	0,50000
d378 1
@

