head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.8
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.6
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.2
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.20.0.18
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.20
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.12
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.16
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.14
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.10
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.8
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.16.0.4
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.14.0.12
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.10
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.8
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.6
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.4
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.8.0.6
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.12
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.10
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.8
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2016.03.15.03.17.51;	author guenther;	state Exp;
branches;
next	1.20;
commitid	hTA8iQcFPhTNwQXL;

1.20
date	2011.03.23.16.54.35;	author pirofti;	state Exp;
branches;
next	1.19;

1.19
date	2011.03.12.03.52.26;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.24.20.26.30;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.01.17.30.27;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.14.20.43.55;	author weingart;	state Exp;
branches;
next	1.15;

1.15
date	2008.09.01.17.30.56;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.12.22.39.21;	author weingart;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.13.21.49.16;	author niklas;	state Exp;
branches
	1.13.4.1
	1.13.6.1;
next	1.12;

1.12
date	2003.11.16.20.30.06;	author avsm;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.27.47;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.31.02.30.29;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.06.17.18.58;	author deraadt;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	2000.08.05.22.07.32;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.12.09.03.36.42;	author deraadt;	state Exp;
branches
	1.6.10.1;
next	1.5;

1.5
date	97.04.17.03.44.51;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.04.29.14.13.54;	author hvozda;	state Exp;
branches;
next	1.3;

1.3
date	96.03.19.21.09.29;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.21.15.04.15;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.36;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.36;	author deraadt;	state Exp;
branches;
next	;

1.6.10.1
date	2001.04.18.16.07.44;	author niklas;	state Exp;
branches;
next	1.6.10.2;

1.6.10.2
date	2001.07.14.10.02.41;	author ho;	state Exp;
branches;
next	1.6.10.3;

1.6.10.3
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.6.10.4;

1.6.10.4
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.6.10.5;

1.6.10.5
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.6.10.6;

1.6.10.6
date	2003.06.07.11.11.37;	author ho;	state Exp;
branches;
next	1.6.10.7;

1.6.10.7
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	;

1.8.6.1
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	1.8.6.2;

1.8.6.2
date	2002.10.29.00.28.04;	author art;	state Exp;
branches;
next	;

1.13.4.1
date	2006.01.13.00.49.21;	author brad;	state Exp;
branches;
next	;

1.13.6.1
date	2006.01.13.01.56.55;	author brad;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Burn more LDT deadwood: stop allocating one for each idle thread,
load the ldt register with the null selector (disabling use of it),
stop reloading it on every context switch, and blow away the table
itself, as well as the pcb and pmap bits that were used to track
it (making sure to keep pcb_savefpu correctly aligned).

testing naddy@@
ok kettenis@@ mpi@@ mlarkin@@
@
text
@/*	$OpenBSD: segments.h,v 1.20 2011/03/23 16:54:35 pirofti Exp $	*/
/*	$NetBSD: segments.h,v 1.23 1996/02/01 22:31:03 mycroft Exp $	*/

/*-
 * Copyright (c) 1995 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1989, 1990 William F. Jolitz
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)segments.h	7.1 (Berkeley) 5/9/91
 */

/*
 * 386 Segmentation Data Structures and definitions
 *	William F. Jolitz (william@@ernie.berkeley.edu) 6/20/1989
 */

#ifndef _MACHINE_SEGMENTS_H_
#define _MACHINE_SEGMENTS_H_

/*
 * Selectors
 */

#define	ISPL(s)		((s) & SEL_RPL)	/* what is the priority level of a selector */
#define	SEL_KPL		0		/* kernel privilege level */	
#define	SEL_UPL		3		/* user privilege level */	
#define	SEL_RPL		3		/* requester's privilege level mask */
#define	ISLDT(s)	((s) & SEL_LDT)	/* is it local or global */
#define	SEL_LDT		4		/* local descriptor table */	
#define	IDXSEL(s)	(((s) >> 3) & 0x1fff)		/* index of selector */
#define	GSEL(s,r)	(((s) << 3) | r)		/* a global selector */
#define	LSEL(s,r)	(((s) << 3) | r | SEL_LDT)	/* a local selector */

#ifdef VM86
#define	USERMODE(c, f)		(ISPL(c) == SEL_UPL || ((f) & PSL_VM) != 0)
#define	KERNELMODE(c, f)	(ISPL(c) == SEL_KPL && ((f) & PSL_VM) == 0)
#else
#define	USERMODE(c, f)		(ISPL(c) == SEL_UPL)
#define	KERNELMODE(c, f)	(ISPL(c) == SEL_KPL)
#endif

#ifndef _LOCORE

/*
 * Memory and System segment descriptors
 */
struct segment_descriptor {
	unsigned sd_lolimit:16;		/* segment extent (lsb) */
	unsigned sd_lobase:24;		/* segment base address (lsb) */
	unsigned sd_type:5;		/* segment type */
	unsigned sd_dpl:2;		/* segment descriptor priority level */
	unsigned sd_p:1;		/* segment descriptor present */
	unsigned sd_hilimit:4;		/* segment extent (msb) */
	unsigned sd_xx:2;		/* unused */
	unsigned sd_def32:1;		/* default 32 vs 16 bit size */
	unsigned sd_gran:1;		/* limit granularity (byte/page) */
	unsigned sd_hibase:8;		/* segment base address (msb) */
} __packed;

/*
 * Gate descriptors (e.g. indirect descriptors)
 */
struct gate_descriptor {
	unsigned gd_looffset:16;	/* gate offset (lsb) */
	unsigned gd_selector:16;	/* gate segment selector */
	unsigned gd_stkcpy:5;		/* number of stack wds to cpy */
	unsigned gd_xx:3;		/* unused */
	unsigned gd_type:5;		/* segment type */
	unsigned gd_dpl:2;		/* segment descriptor priority level */
	unsigned gd_p:1;		/* segment descriptor present */
	unsigned gd_hioffset:16;	/* gate offset (msb) */
} __packed;

/*
 * Generic descriptor
 */
union descriptor {
	struct segment_descriptor sd;
	struct gate_descriptor gd;
} __packed;

/*
 * region descriptors, used to load gdt/idt tables before segments yet exist.
 */
struct region_descriptor {
	unsigned rd_limit:16;		/* segment extent */
	unsigned rd_base:32;		/* base address  */
} __packed;

#ifdef _KERNEL
extern union descriptor *gdt;
extern struct gate_descriptor idt_region[];
extern struct gate_descriptor *idt;

void setgate(struct gate_descriptor *, void *, int, int, int, int);
void setregion(struct region_descriptor *, void *, size_t);
void setsegment(struct segment_descriptor *, void *, size_t, int, int,
    int, int);
void unsetgate(struct gate_descriptor *);
void cpu_init_idt(void);

int idt_vec_alloc(int, int);
void idt_vec_set(int, void (*)(void));
void idt_vec_free(int);

#endif /* _KERNEL */

#endif /* !_LOCORE */

/* system segments and gate types */
#define	SDT_SYSNULL	 0	/* system null */
#define	SDT_SYS286TSS	 1	/* system 286 TSS available */
#define	SDT_SYSLDT	 2	/* system local descriptor table */
#define	SDT_SYS286BSY	 3	/* system 286 TSS busy */
#define	SDT_SYS286CGT	 4	/* system 286 call gate */
#define	SDT_SYSTASKGT	 5	/* system task gate */
#define	SDT_SYS286IGT	 6	/* system 286 interrupt gate */
#define	SDT_SYS286TGT	 7	/* system 286 trap gate */
#define	SDT_SYSNULL2	 8	/* system null again */
#define	SDT_SYS386TSS	 9	/* system 386 TSS available */
#define	SDT_SYSNULL3	10	/* system null again */
#define	SDT_SYS386BSY	11	/* system 386 TSS busy */
#define	SDT_SYS386CGT	12	/* system 386 call gate */
#define	SDT_SYSNULL4	13	/* system null again */
#define	SDT_SYS386IGT	14	/* system 386 interrupt gate */
#define	SDT_SYS386TGT	15	/* system 386 trap gate */

/* memory segment types */
#define	SDT_MEMRO	16	/* memory read only */
#define	SDT_MEMROA	17	/* memory read only accessed */
#define	SDT_MEMRW	18	/* memory read write */
#define	SDT_MEMRWA	19	/* memory read write accessed */
#define	SDT_MEMROD	20	/* memory read only expand dwn limit */
#define	SDT_MEMRODA	21	/* memory read only expand dwn limit accessed */
#define	SDT_MEMRWD	22	/* memory read write expand dwn limit */
#define	SDT_MEMRWDA	23	/* memory read write expand dwn limit acessed */
#define	SDT_MEME	24	/* memory execute only */
#define	SDT_MEMEA	25	/* memory execute only accessed */
#define	SDT_MEMER	26	/* memory execute read */
#define	SDT_MEMERA	27	/* memory execute read accessed */
#define	SDT_MEMEC	28	/* memory execute only conforming */
#define	SDT_MEMEAC	29	/* memory execute only accessed conforming */
#define	SDT_MEMERC	30	/* memory execute read conforming */
#define	SDT_MEMERAC	31	/* memory execute read accessed conforming */

/* is memory segment descriptor pointer ? */
#define ISMEMSDP(s)	((s->d_type) >= SDT_MEMRO && \
			 (s->d_type) <= SDT_MEMERAC)

/* is 286 gate descriptor pointer ? */
#define IS286GDP(s)	((s->d_type) >= SDT_SYS286CGT && \
			 (s->d_type) < SDT_SYS286TGT)

/* is 386 gate descriptor pointer ? */
#define IS386GDP(s)	((s->d_type) >= SDT_SYS386CGT && \
			 (s->d_type) < SDT_SYS386TGT)

/* is gate descriptor pointer ? */
#define ISGDP(s)	(IS286GDP(s) || IS386GDP(s))

/* is segment descriptor pointer ? */
#define ISSDP(s)	(ISMEMSDP(s) || !ISGDP(s))

/* is system segment descriptor pointer ? */
#define ISSYSSDP(s)	(!ISMEMSDP(s) && !ISGDP(s))

/*
 * Segment Protection Exception code bits
 */
#define	SEGEX_EXT	0x01	/* recursive or externally induced */
#define	SEGEX_IDT	0x02	/* interrupt descriptor table */
#define	SEGEX_TI	0x04	/* local descriptor table */

/*
 * Entries in the Interrupt Descriptor Table (IDT)
 */
#define	NIDT	256
#define	NRSVIDT	32		/* reserved entries for cpu exceptions */

/*
 * Entries in the Global Descriptor Table (GDT)
 */
#define	GNULL_SEL	0	/* Null descriptor */
#define	GCODE_SEL	1	/* Kernel code descriptor */
#define	GDATA_SEL	2	/* Kernel data descriptor */
#define	GLDT_SEL	3	/* Default LDT descriptor (UNUSED) */
#define	GCPU_SEL	4	/* per-CPU segment */
#define	GUCODE_SEL	5	/* User code descriptor (a stack short) */
#define	GUDATA_SEL	6	/* User data descriptor */
#define	GAPM32CODE_SEL	7	/* 32 bit APM code descriptor */
#define	GAPM16CODE_SEL	8	/* 16 bit APM code descriptor */
#define	GAPMDATA_SEL	9	/* APM data descriptor */
#define	GICODE_SEL	10	/* Interrupt code descriptor (same as Kernel code) */
#define	GUFS_SEL	11	/* User per-thread (%fs) descriptor */
#define	GUGS_SEL	12	/* User per-thread (%gs) descriptor */
#define	NGDT		13

/*
 * Entries in the Local Descriptor Table (LDT)
 */
#define	NLDT		17

#endif /* _MACHINE_SEGMENTS_H_ */
@


1.20
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.19 2011/03/12 03:52:26 guenther Exp $	*/
d119 1
a119 1
extern union descriptor *gdt, ldt[];
a128 3
void cpu_default_ldt(struct cpu_info *);
void cpu_alloc_ldt(struct cpu_info *);
void cpu_init_ldt(struct cpu_info *);
d214 1
a214 1
#define	GLDT_SEL	3	/* Default LDT descriptor */
@


1.19
log
@Provide distinct segments for the %fs and %gs selectors to use by
default, with per-rthread base offsets and with sysarch() functions,
I386_{GET,SET}_{FS,GS}BASE, for fetching and setting those base
offsets.  This is necessary for both rthread and Linux compat support.

suggestions from kettenis@@, prodding from pirofti@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.18 2010/12/24 20:26:30 tedu Exp $	*/
d45 2
a46 2
#ifndef _I386_SEGMENTS_H_
#define _I386_SEGMENTS_H_
d234 1
a234 1
#endif /* _I386_SEGMENTS_H_ */
@


1.18
log
@the bsdi ldt entry is no longer interesting. from valdimir kirillov
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.17 2010/07/01 17:30:27 tedu Exp $	*/
d218 1
a218 1
#define	GUCODE1_SEL	4	/* User code descriptor */
d225 3
a227 2
#define GCPU_SEL	11	/* per-CPU segment */
#define	NGDT		12
@


1.17
log
@another day, another compat gets removed.  today is ibcs2's turn
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.16 2008/11/14 20:43:55 weingart Exp $	*/
a230 1
#define	LBSDICALLS_SEL	16	/* BSDI system call gate */
@


1.16
log
@Garbage collect the LDT segments, and simply use the GDT segments.
The beginning of i386 segment review/cleanup.

Tested by various people.
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.15 2008/09/01 17:30:56 deraadt Exp $	*/
a230 2
#define	LSYS5CALLS_SEL	0	/* iBCS system call gate */
#define	LSYS5SIGR_SEL	1	/* iBCS sigreturn gate */
@


1.15
log
@Avoid #pragma pack(1) and unify everything towards using __packed.
This requires that structures defined within __packed structures must
independently request that they themselves become __packed, too.
worked on with toby
 CVS: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.14 2006/01/12 22:39:21 weingart Exp $	*/
a232 3
#define	LUCODE1_SEL	2	/* User code descriptor */
#define	LUCODE_SEL	3	/* User code descriptor (a stack short) */
#define	LUDATA_SEL	4	/* User data descriptor */
@


1.14
log
@Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.13 2004/06/13 21:49:16 niklas Exp $	*/
a71 4
#if __GNUC__ == 2 && __GNUC_MINOR__ < 7
#pragma pack(1)
#endif

a116 4

#if __GNUC__ == 2 && __GNUC_MINOR__ < 7
#pragma pack(4)
#endif
@


1.13
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d137 3
@


1.13.6.1
log
@MFC:
Fix by weingart@@

Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.13 2004/06/13 21:49:16 niklas Exp $	*/
a136 3
void cpu_default_ldt(struct cpu_info *);
void cpu_alloc_ldt(struct cpu_info *);
void cpu_init_ldt(struct cpu_info *);
@


1.13.4.1
log
@MFC:
Fix by weingart@@

Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.13 2004/06/13 21:49:16 niklas Exp $	*/
a136 3
void cpu_default_ldt(struct cpu_info *);
void cpu_alloc_ldt(struct cpu_info *);
void cpu_init_ldt(struct cpu_info *);
@


1.12
log
@convert __attribute__((__packed__)) to __packed so that parsers unaware
of gcc extensions have more of a chance.
ok mcbride@@, no objections from millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.11 2003/06/02 23:27:47 millert Exp $	*/
d127 1
a127 1
extern union descriptor gdt[], ldt[];
d135 7
d230 2
a231 1
#define	NGDT		11
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.10 2002/07/31 02:30:29 mickey Exp $	*/
d90 1
a90 1
} __attribute__((__packed__));
d104 1
a104 1
} __attribute__((__packed__));
d112 1
a112 1
} __attribute__((__packed__));
d120 1
a120 1
} __attribute__((__packed__));
@


1.10
log
@support for changing stack execution protection through mprotect()
by emulating the page execution protection bit and accounting
for pages mapped executable on the stack and swapping the
global user code descriptors for the process accordingly.
this is tested w/ the regress test and art@@ looked over it.

there is still a mistery how executable mappings on fault
works on i386 since no prot_exec faults ever happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.9 2002/03/14 01:26:33 millert Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.8 2000/12/06 17:18:58 deraadt Exp $	*/
d220 8
a227 7
#define	GUCODE_SEL	4	/* User code descriptor */
#define	GUDATA_SEL	5	/* User data descriptor */
#define	GAPM32CODE_SEL	6	/* 32 bit APM code descriptor */
#define	GAPM16CODE_SEL	7	/* 16 bit APM code descriptor */
#define	GAPMDATA_SEL	8	/* APM data descriptor */
#define	GICODE_SEL	9	/* Interrupt code descriptor (same as Kernel code) */
#define	NGDT		10
d234 3
a236 2
#define	LUCODE_SEL	2	/* User code descriptor */
#define	LUDATA_SEL	3	/* User data descriptor */
@


1.8
log
@use __x__ formats for __attribute__ arguments; guenther@@gac.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.7 2000/08/05 22:07:32 niklas Exp $	*/
d135 4
a138 4
void setgate __P((struct gate_descriptor *, void *, int, int, int, int));
void setregion __P((struct region_descriptor *, void *, size_t));
void setsegment __P((struct segment_descriptor *, void *, size_t, int, int,
    int, int));
@


1.8.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.8 2000/12/06 17:18:58 deraadt Exp $	*/
d135 4
a138 4
void setgate(struct gate_descriptor *, void *, int, int, int, int);
void setregion(struct region_descriptor *, void *, size_t);
void setsegment(struct segment_descriptor *, void *, size_t, int, int,
    int, int);
@


1.8.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.8.6.1 2002/06/11 03:35:54 art Exp $	*/
d220 7
a226 8
#define	GUCODE1_SEL	4	/* User code descriptor */
#define	GUCODE_SEL	5	/* User code descriptor (a stack short) */
#define	GUDATA_SEL	6	/* User data descriptor */
#define	GAPM32CODE_SEL	7	/* 32 bit APM code descriptor */
#define	GAPM16CODE_SEL	8	/* 16 bit APM code descriptor */
#define	GAPMDATA_SEL	9	/* APM data descriptor */
#define	GICODE_SEL	10	/* Interrupt code descriptor (same as Kernel code) */
#define	NGDT		11
d233 2
a234 3
#define	LUCODE1_SEL	2	/* User code descriptor */
#define	LUCODE_SEL	3	/* User code descriptor (a stack short) */
#define	LUDATA_SEL	4	/* User data descriptor */
@


1.7
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.23 1996/02/01 22:31:03 mycroft Exp $	*/
d94 1
a94 1
} __attribute__((packed));
d108 1
a108 1
} __attribute__((packed));
d116 1
a116 1
} __attribute__((packed));
d124 1
a124 1
} __attribute__((packed));
@


1.6
log
@Intel P5 f00f workaround; weingart & who knows who else
@
text
@d1 1
@


1.6.10.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@a0 1
/*	$OpenBSD: segments.h,v 1.8 2000/12/06 17:18:58 deraadt Exp $	*/
d93 1
a93 1
} __attribute__((__packed__));
d107 1
a107 1
} __attribute__((__packed__));
d115 1
a115 1
} __attribute__((__packed__));
d123 1
a123 1
} __attribute__((__packed__));
@


1.6.10.2
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.6.10.1 2001/04/18 16:07:44 niklas Exp $	*/
a138 7
void unsetgate __P((struct gate_descriptor *));
void cpu_init_idt __P((void));

int idt_vec_alloc __P((int, int));
void idt_vec_set __P((int, void (*)(void)));
void idt_vec_free __P((int));

@


1.6.10.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d135 10
a144 10
void setgate(struct gate_descriptor *, void *, int, int, int, int);
void setregion(struct region_descriptor *, void *, size_t);
void setsegment(struct segment_descriptor *, void *, size_t, int, int,
    int, int);
void unsetgate(struct gate_descriptor *);
void cpu_init_idt(void);

int idt_vec_alloc(int, int);
void idt_vec_set(int, void (*)(void));
void idt_vec_free(int);
@


1.6.10.4
log
@Sync the SMP branch with 3.3
@
text
@d227 7
a233 8
#define	GUCODE1_SEL	4	/* User code descriptor */
#define	GUCODE_SEL	5	/* User code descriptor (a stack short) */
#define	GUDATA_SEL	6	/* User data descriptor */
#define	GAPM32CODE_SEL	7	/* 32 bit APM code descriptor */
#define	GAPM16CODE_SEL	8	/* 16 bit APM code descriptor */
#define	GAPMDATA_SEL	9	/* APM data descriptor */
#define	GICODE_SEL	10	/* Interrupt code descriptor (same as Kernel code) */
#define	NGDT		11
d240 2
a241 3
#define	LUCODE1_SEL	2	/* User code descriptor */
#define	LUCODE_SEL	3	/* User code descriptor (a stack short) */
#define	LUDATA_SEL	4	/* User data descriptor */
@


1.6.10.5
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.6.10.4 2003/03/27 23:26:55 niklas Exp $	*/
d131 1
a131 1
extern union descriptor *gdt, ldt[];
d234 1
a234 2
#define GCPU_SEL	11	/* per-CPU segment */
#define	NGDT		12
@


1.6.10.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: segments.h,v 1.6.10.5 2003/05/15 04:08:02 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6.10.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d90 1
a90 1
} __packed;
d104 1
a104 1
} __packed;
d112 1
a112 1
} __packed;
d120 1
a120 1
} __packed;
@


1.5
log
@Do interrupt time accounting by running interrupt handlers with a seperate
code segment selector (otherwise identical to the standard kernel code
selector); idea by Dave Richards <richards@@zso.dec.com>
@
text
@d131 2
a132 1
extern struct gate_descriptor idt[];
@


1.4
log
@Pull in John Kohl's [jtk@@netbsd.org] most recent (15Apr96) APM and PCMCIA work
(original PCMCIA framework  by Stefan Grefen [grefen@@convex.com]).
@
text
@d133 1
a133 1
void setgate __P((struct gate_descriptor *, void *, int, int, int));
d220 5
a224 4
#define	GAPM32CODE_SEL	6
#define	GAPM16CODE_SEL	7
#define	GAPMDATA_SEL	8
#define	NGDT		9
@


1.3
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d220 4
a223 1
#define	NGDT 		6
@


1.2
log
@from netbsd; use __attribute__((packed)) if it is available
@
text
@d1 1
a1 1
/*	$NetBSD: segments.h,v 1.22 1995/12/20 18:09:24 mycroft Exp $	*/
d73 1
a73 1
#ifndef LOCORE
d139 1
a139 1
#endif /* !LOCORE */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: segments.h,v 1.20 1995/10/12 17:57:01 mycroft Exp $	*/
d75 1
a75 1
#if __GNUC__ >= 2
d93 1
a93 1
};
d107 1
a107 1
};
d115 1
a115 1
};
d123 1
a123 1
};
d125 1
a125 1
#if __GNUC__ >= 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
