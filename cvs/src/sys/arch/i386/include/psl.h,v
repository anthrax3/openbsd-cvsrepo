head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.18
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.14
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.10
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.12
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.4
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.8
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.6
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.19.0.8
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.6
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.16.0.28
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.26
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.22
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.24
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.20
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.18
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.16
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.14
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.12
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.10
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.8
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.6
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.11.0.8
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.6
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.11.0.4
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.16
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.14
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.12
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.10
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.8
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.6
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2013.05.16.19.26.04;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2011.06.08.22.57.59;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2011.04.16.00.40.58;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2011.03.23.16.54.35;	author pirofti;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.28.01.41.53;	author aaron;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.02.23.02.42;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.01.19.05.23;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.27.47;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.05.22.07.32;	author niklas;	state Exp;
branches
	1.11.8.1;
next	1.10;

1.10
date	97.03.31.17.28.07;	author deraadt;	state Exp;
branches
	1.10.14.1;
next	1.9;

1.9
date	96.06.24.23.51.58;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	96.06.22.17.36.53;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.05.25.22.17.45;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.07.07.22.10;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.03.19.21.09.28;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.02.20.04.35.27;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.01.08.18.52.01;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.08.09.33.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.36;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.36;	author deraadt;	state Exp;
branches;
next	;

1.10.14.1
date	2001.04.18.16.07.42;	author niklas;	state Exp;
branches;
next	1.10.14.2;

1.10.14.2
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.10.14.3;

1.10.14.3
date	2003.06.07.11.11.37;	author ho;	state Exp;
branches;
next	1.10.14.4;

1.10.14.4
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	;

1.11.8.1
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Implement a mechanism to establish interrupt handlers that don't grab the
kernel lock upon entry through a new IPL_MPSAFE flag/level.
@
text
@/*	$OpenBSD: psl.h,v 1.19 2011/06/08 22:57:59 kettenis Exp $	*/
/*	$NetBSD: psl.h,v 1.30 1996/05/13 01:28:05 mycroft Exp $	*/

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)psl.h	5.2 (Berkeley) 1/18/91
 */

#ifndef _MACHINE_PSL_H_
#define _MACHINE_PSL_H_

/*
 * 386 processor status longword.
 */
#define	PSL_C		0x00000001	/* carry flag */
#define	PSL_PF		0x00000004	/* parity flag */
#define	PSL_AF		0x00000010	/* auxiliary carry flag */
#define	PSL_Z		0x00000040	/* zero flag */
#define	PSL_N		0x00000080	/* sign flag */
#define	PSL_T		0x00000100	/* trap flag */
#define	PSL_I		0x00000200	/* interrupt enable flag */
#define	PSL_D		0x00000400	/* direction flag */
#define	PSL_V		0x00000800	/* overflow flag */
#define	PSL_IOPL	0x00003000	/* i/o privilege level */
#define	PSL_NT		0x00004000	/* nested task */
#define	PSL_RF		0x00010000	/* resume flag */
#define	PSL_VM		0x00020000	/* virtual 8086 mode */
#define	PSL_AC		0x00040000	/* alignment check flag */
#define	PSL_VIF		0x00080000	/* virtual interrupt enable flag */
#define	PSL_VIP		0x00100000	/* virtual interrupt pending flag */
#define	PSL_ID		0x00200000	/* identification flag */
#define	PSL_XCRYPT	0x40000000	/* VIA xcrypt: operation loaded */

#define	PSL_MBO		0x00000002	/* must be one bits */
#define	PSL_MBZ		0xffc08028	/* must be zero bits */

#define	PSL_USERSET	(PSL_MBO | PSL_I)
#ifdef VM86
#define	PSL_USERSTATIC	(PSL_MBO | PSL_MBZ | PSL_I | PSL_IOPL | PSL_NT | PSL_VIF | PSL_VIP)
#else
#define	PSL_USERSTATIC	(PSL_MBO | PSL_MBZ | PSL_I | PSL_IOPL | PSL_NT | PSL_VM | PSL_VIF | PSL_VIP)
#endif

#ifdef _KERNEL
#include <machine/intr.h>

#ifndef _LOCORE

#include <sys/evcount.h>

/*
 * Interrupt handler chains.  isa_intr_establish() inserts a handler into
 * the list.  The handler is called with its (single) argument.
 */

struct intrhand {
	int		(*ih_fun)(void *);
	void		*ih_arg;
	int		ih_level;
	int		ih_flags;
	struct intrhand	*ih_next;
	int		ih_pin;
	int		ih_irq;
	struct evcount	ih_count;
	int		ih_vec;
};

extern int intr_shared_edge;	/* This system has shared edge interrupts */

#endif /* _LOCORE */
#endif /* _KERNEL */
 
#endif /* !_MACHINE_PSL_H_ */
@


1.19
log
@Ateempt to make pci_intr_disestablish() work for MSIs.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.18 2011/04/16 00:40:58 deraadt Exp $	*/
d89 1
@


1.18
log
@More than a decade ago, interrupt handlers on sparc started returning 0
(interrupt was not for me), 1 (positive interrupt was for me), or -1
(i am not sure...).  We have continued with this practice in as many
drivers as possible, throughout the tree.

This makes some of the architectures use that information in their
interrupt handler calling code -- if 1 is returned (and we know
this specific machine does not have edge-shared interrupts), we
finish servicing other possible handlers on the same pin.  If the
interrupt pin remains asserted (from a different device), we will
end up back in the interrupt servicing code of course... but this is
cheaper than calling all the chained interrupts on a pin.

This does of course count on shared level interrupts being properly
sorted by IPL.

There have been some concerns about starvation of drivers which
incorrectly return 1.  Those drivers should be hunted down so that
they return -1.

ok and help from various people.  In snaps for about a week now.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.17 2011/03/23 16:54:35 pirofti Exp $	*/
d88 1
d90 1
a90 1
	int		ih_level;
d93 1
@


1.17
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.16 2004/06/28 01:41:53 aaron Exp $	*/
d93 2
@


1.16
log
@Use new event counter API for interrupt counting on i386.  deraadt@@ tholo@@
drahn@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.15 2004/02/02 23:02:42 deraadt Exp $	*/
d38 2
a39 2
#ifndef _I386_PSL_H_
#define _I386_PSL_H_
d97 1
a97 1
#endif /* !_I386_PSL_H_ */
@


1.15
log
@PSL_XCRYPT is 0x40000000
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.14 2004/02/01 19:05:23 deraadt Exp $	*/
d78 2
d86 6
a91 7
	int	(*ih_fun)(void *);
	void	*ih_arg;
	u_long	ih_count;
	struct	intrhand *ih_next;
	int	ih_level;
	int	ih_irq;
	char	*ih_what;
@


1.14
log
@Enable FXSR all the time, and cope with NPX/FXSR conversions; from netbsd.
Pass SSE/SSE2/XCRYPT flags out via syctl, and prepare for being able to do
xcrypt-* in userland; ok naddy, tested a lot by pvalchev and jolan, also
works on amd64 in 32bit mode
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.13 2003/06/02 23:27:47 millert Exp $	*/
d61 1
a61 1
#define	PSL_XCRYPT	0x20000000	/* VIA xcrypt: operation loaded */
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.12 2002/03/14 01:26:33 millert Exp $	*/
d61 1
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.11 2000/08/05 22:07:32 niklas Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.30 1996/05/13 01:28:05 mycroft Exp $	*/
d87 1
a87 1
	int	(*ih_fun) __P((void *));
@


1.11.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.11 2000/08/05 22:07:32 niklas Exp $	*/
d87 1
a87 1
	int	(*ih_fun)(void *);
@


1.10
log
@do not let PSL_NT be set in VM86 mode; netbsd
@
text
@d1 1
@


1.10.14.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@a0 1
/*	$OpenBSD: psl.h,v 1.11 2000/08/05 22:07:32 niklas Exp $	*/
@


1.10.14.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d87 1
a87 1
	int	(*ih_fun)(void *);
@


1.10.14.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: psl.h,v 1.10.14.2 2002/03/28 10:31:04 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.10.14.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a60 1
#define	PSL_XCRYPT	0x40000000	/* VIA xcrypt: operation loaded */
@


1.9
log
@struct intrhand protected by _KERNEL; some user-mode assembly code
can't deal with the file without this
@
text
@d70 1
a70 1
#define	PSL_USERSTATIC	(PSL_MBO | PSL_MBZ | PSL_I | PSL_IOPL | PSL_VIF | PSL_VIP)
d72 1
a72 1
#define	PSL_USERSTATIC	(PSL_MBO | PSL_MBZ | PSL_I | PSL_IOPL | PSL_VM | PSL_VIF | PSL_VIP)
@


1.8
log
@Move struct intrhand to <machine/psl.h> [again] so user-level programs can
get at it.
@
text
@a76 1
#endif
d96 1
@


1.7
log
@sync
@
text
@d79 19
@


1.6
log
@sync with 0504; prototype changes
@
text
@d1 1
a1 1
/*	$NetBSD: psl.h,v 1.28 1996/05/03 19:26:31 christos Exp $	*/
d76 2
a77 125

/* Interrupt priority `levels'; not mutually exclusive. */
#define	IPL_NONE	-1
#define	IPL_BIO		0	/* block I/O */
#define	IPL_NET		1	/* network */
#define	IPL_TTY		2	/* terminal */
#define	IPL_CLOCK	3	/* clock */
#define	IPL_IMP		4	/* memory allocation */

/* Interrupt sharing types. */
#define	IST_NONE	0	/* none */
#define	IST_PULSE	1	/* pulsed */
#define	IST_EDGE	2	/* edge-triggered */
#define	IST_LEVEL	3	/* level-triggered */

/* Soft interrupt masks. */
#define	SIR_CLOCK	31
#define	SIR_CLOCKMASK	((1 << SIR_CLOCK))
#define	SIR_NET		30
#define	SIR_NETMASK	((1 << SIR_NET) | SIR_CLOCKMASK)
#define	SIR_TTY		29
#define	SIR_TTYMASK	((1 << SIR_TTY) | SIR_CLOCKMASK)
#define	SIR_ALLMASK	(SIR_CLOCKMASK | SIR_NETMASK | SIR_TTYMASK)

#ifndef _LOCORE

volatile int cpl, ipending, astpending;
int imask[5];

extern void Xspllower __P((void));

static __inline int splraise __P((int));
static __inline int spllower __P((int));
static __inline void splx __P((int));
static __inline void softintr __P((int));

/*
 * Add a mask to cpl, and return the old value of cpl.
 */
static __inline int
splraise(ncpl)
	register int ncpl;
{
	register int ocpl = cpl;

	cpl = ocpl | ncpl;
	return (ocpl);
}

/*
 * Restore a value to cpl (unmasking interrupts).  If any unmasked
 * interrupts are pending, call Xspllower() to process them.
 */
static __inline void
splx(ncpl)
	register int ncpl;
{

	cpl = ncpl;
	if (ipending & ~ncpl)
		Xspllower();
}

/*
 * Same as splx(), but we return the old value of spl, for the
 * benefit of some splsoftclock() callers.
 */
static __inline int
spllower(ncpl)
	register int ncpl;
{
	register int ocpl = cpl;

	cpl = ncpl;
	if (ipending & ~ncpl)
		Xspllower();
	return (ocpl);
}

/*
 * Hardware interrupt masks
 */
#define	splbio()	splraise(imask[IPL_BIO])
#define	splnet()	splraise(imask[IPL_NET])
#define	spltty()	splraise(imask[IPL_TTY])
#define	splclock()	splraise(imask[IPL_CLOCK])
#define	splimp()	splraise(imask[IPL_IMP])
#define	splstatclock()	splclock()

/*
 * Software interrupt masks
 *
 * NOTE: splsoftclock() is used by hardclock() to lower the priority from
 * clock to softclock before it calls softclock().
 */
#define	splsoftclock()	spllower(SIR_CLOCKMASK)
#define	splsoftnet()	splraise(SIR_NETMASK)
#define	splsofttty()	splraise(SIR_TTYMASK)

/*
 * Miscellaneous
 */
#define	splhigh()	splraise(-1)
#define	spl0()		spllower(0)

/*
 * Software interrupt registration
 *
 * We hand-code this to ensure that it's atomic.
 */
static __inline void
softintr(mask)
	register int mask;
{

	__asm __volatile("orl %0,_ipending" : : "ir" (mask));
}

#define	setsoftast()	(astpending = 1)
#define	setsoftclock()	softintr(1 << SIR_CLOCK)
#define	setsoftnet()	softintr(1 << SIR_NET)
#define	setsofttty()	softintr(1 << SIR_TTY)

#endif /* !_LOCORE */
#endif /* _KERNEL */
@


1.5
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 1
a1 1
/*	$NetBSD: psl.h,v 1.27 1996/02/01 22:30:56 mycroft Exp $	*/
d106 5
@


1.4
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 1
a1 1
/*	$NetBSD: psl.h,v 1.26 1996/01/07 21:48:35 mycroft Exp $	*/
d100 1
a100 16
#ifndef LOCORE

/*
 * Interrupt handler chains.  isa_intr_establish() inserts a handler into
 * the list.  The handler is called with its (single) argument.
 */

struct intrhand {
	int	(*ih_fun)();
	void	*ih_arg;
	u_long	ih_count;
	struct	intrhand *ih_next;
	int	ih_level;
	int	ih_irq;
	char	*ih_what;
};
d194 1
a194 1
#endif /* !LOCORE */
@


1.3
log
@from netbsd; Hand-code softintr()
@
text
@d102 15
@


1.2
log
@from netbsd:
Deal with GCC's dead code elimination being suboptimal.
Modify splraise() to allow better optimization.
Make cpl, ipending, and astpending volatile.
Make sure interrupts are disabled before jumping to a resume point,
to prevent races.
Make FPU faults use INTRFASTEXIT, and remove INTREXIT.
Build the frame for recursive interrupts manually, and make sure to
disable interrupts to avoid races.
VS: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$NetBSD: psl.h,v 1.25 1996/01/07 03:59:32 mycroft Exp $	*/
d178 2
d181 8
a188 1
#define	softintr(n)	(ipending |= (1 << (n)))
d190 3
a192 3
#define	setsoftclock()	softintr(SIR_CLOCK)
#define	setsoftnet()	softintr(SIR_NET)
#define	setsofttty()	softintr(SIR_TTY)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: psl.h,v 1.22 1995/10/11 04:20:23 mycroft Exp $	*/
d102 4
a105 1
int cpl, ipending, astpending, imask[5];
d115 2
a116 1
	cpl |= ncpl;
d120 13
a132 1
extern void spllower __P((void));
d135 2
a136 6
 * Restore a value to cpl (unmasking interrupts).  If any unmasked
 * interrupts are pending, call spllower() to process them.
 *
 * NOTE: We go to the trouble of returning the old value of cpl for
 * the benefit of some splsoftclock() callers.  This extra work is
 * usually optimized away by the compiler.
d139 1
a139 1
splx(ncpl)
d143 1
d146 1
a146 1
		spllower();
d166 1
a166 1
#define	splsoftclock()	splx(SIR_CLOCKMASK)
d174 1
a174 1
#define	spl0()		splx(0)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
