head	1.14;
access;
symbols
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.12
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.8
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.10
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.6
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.10
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.8
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.6
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.11.0.4
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.9.0.4
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.6.0.4
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.3.0.4
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.2.0.8
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	UBC_SYNC_A:1.1
	UBC_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.14
date	2014.01.24.21.20.23;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2011.06.25.19.20.41;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2011.03.23.16.54.35;	author pirofti;	state Exp;
branches;
next	1.11;

1.11
date	2010.07.25.21.43.37;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.03.00.49.12;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.8;

1.8
date	2008.04.26.14.33.27;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2008.04.18.20.20.35;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.26.22.09.17;	author weingart;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.25.15.55.27;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2007.04.12.20.22.58;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.29.15.02.27;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.13.21.49.16;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.14.10.02.37;	author ho;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.07.14.10.02.37;	author ho;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.07.15.15.13.29;	author ho;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.07.16.21.40.50;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.10.27.09.57.31;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2004.03.30.09.10.44;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Disable lapic when halting CPUs.  Allegedly this is necessary to make
suspend work on some machines.

ok deraadt@@, mlarkin@@
@
text
@/*	$OpenBSD: i82489var.h,v 1.13 2011/06/25 19:20:41 jsg Exp $	*/
/*	$NetBSD: i82489var.h,v 1.1.2.2 2000/02/21 18:46:14 sommerfeld Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Frank van der Linden.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_I82489VAR_H_
#define _MACHINE_I82489VAR_H_

static __inline__ u_int32_t i82489_readreg(int);
static __inline__ void i82489_writereg(int, u_int32_t);

#ifdef _KERNEL
extern volatile u_int32_t local_apic[];
#endif

static __inline__ u_int32_t
i82489_readreg(int reg)
{
	return *((volatile u_int32_t *)(((volatile u_int8_t *)local_apic)
	    + reg));
}

static __inline__ void
i82489_writereg(int reg, u_int32_t val)
{
	*((volatile u_int32_t *)(((volatile u_int8_t *)local_apic) + reg)) =
	    val;
	/*
	 * intel xeon errata p53:
	 *   write to a lapic register sometimes may appear to have not occured
	 * workaround:
	 *   follow write with a read [from id register]
	 */
	val = *((volatile u_int32_t *)(((volatile u_int8_t *)local_apic) +
	    LAPIC_ID));
}

/*
 * "spurious interrupt vector"; vector used by interrupt which was
 * aborted because the CPU masked it after it happened but before it
 * was delivered.. "Oh, sorry, i caught you at a bad time".
 * Low-order 4 bits must be all ones.
 */
extern void i386_spurious(void);
extern void Xintrspurious(void);
#define LAPIC_SPURIOUS_VECTOR		0xef

/*
 * Vector used for inter-processor interrupts.
 */
extern void Xintripi(void);
#define LAPIC_IPI_VECTOR		IPL_IPI

/*
 * Vector used for local apic timer interrupts.
 */

extern void Xintrltimer(void);
#define LAPIC_TIMER_VECTOR		IPL_CLOCK

/*
 * Vectors to be used for self-soft-interrupts.
 */

#define LAPIC_SOFTCLOCK_VECTOR		IPL_SOFTCLOCK
#define LAPIC_SOFTNET_VECTOR		IPL_SOFTNET
#define LAPIC_SOFTTTY_VECTOR		IPL_SOFTTTY

/*
 * Special IPI vectors. We can use IDT 0xf0 - 0xff for this.
 */
#define LAPIC_IPI_OFFSET		0xf0
#define LAPIC_IPI_INVLTLB		(LAPIC_IPI_OFFSET + 0)
#define LAPIC_IPI_INVLPG		(LAPIC_IPI_OFFSET + 1)
#define LAPIC_IPI_INVLRANGE		(LAPIC_IPI_OFFSET + 2)
#define LAPIC_IPI_RELOADCR3		(LAPIC_IPI_OFFSET + 3)

extern void Xintripi_invltlb(void);
extern void Xintripi_invlpg(void);
extern void Xintripi_invlrange(void);
extern void Xintripi_reloadcr3(void);

extern void Xintrsoftclock(void);
extern void Xintrsoftnet(void);
extern void Xintrsofttty(void);

extern void (*apichandler[])(void);

struct cpu_info;

extern void lapic_boot_init(paddr_t);
extern void lapic_startclock(void);
extern void lapic_initclocks(void);
extern void lapic_set_lvt(void);
extern void lapic_set_softvectors(void);
extern void lapic_enable(void);
extern void lapic_disable(void);
extern void lapic_calibrate_timer(struct cpu_info *);

#define lapic_cpu_number() 	(i82489_readreg(LAPIC_ID)>>LAPIC_ID_SHIFT)

#endif
@


1.13
log
@ansi, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: i82489var.h,v 1.12 2011/03/23 16:54:35 pirofti Exp $	*/
d124 1
@


1.12
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82489var.h,v 1.11 2010/07/25 21:43:37 deraadt Exp $	*/
d44 1
a44 2
i82489_readreg(reg)
	int reg;
d51 1
a51 3
i82489_writereg(reg, val)
	int reg;
	u_int32_t val;
@


1.11
log
@in the clock drivers, seperate the soft-state and hard-state which was
all jumbled up in the same functions. the rtc (mc chip) and clock (i8243)
startup was also mixed up.  they the soft state and hardware state can
be started in the right order, and it is easy to restart just the
neccessary parts upon resume.  tested in numerous cases:
(apic, pic) * (GENERIC.MP, GENERIC) * (mp, non-mp) * (i386, amd64)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: i82489var.h,v 1.10 2009/06/03 00:49:12 art Exp $	*/
d33 2
a34 2
#ifndef _I386_I82489VAR_H_
#define _I386_I82489VAR_H_
@


1.10
log
@Just like on amd64. Instead of keeping a bitmap of which cpus a pmap
is active on, save a curpmap pointer in cpu_info. This lets us simplify
a few things and do lazy context switching from a user process to a
kernel thread. There's a new IPI introduced for forcing a cr3 reload
when we're tearing down a dead pmap.

kettenis@@ ok (after I polished a few minor things)
@
text
@d1 1
a1 1
/*	$OpenBSD: i82489var.h,v 1.9 2008/06/26 05:42:10 ray Exp $	*/
d122 1
@


1.9
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82489var.h,v 1.8 2008/04/26 14:33:27 kettenis Exp $	*/
d106 1
d111 1
@


1.8
log
@Remove softast; it's no longer used.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82489var.h,v 1.7 2008/04/18 20:20:35 kettenis Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.7
log
@Now that i386 has a per-process astpending, we can garbage collect ipi_ast
and do an ipi_nop cross-call from signotify() instead.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82489var.h,v 1.6 2007/05/26 22:09:17 weingart Exp $	*/
a104 1
#define LAPIC_SOFTAST_VECTOR		IPL_SOFTAST
a120 1
extern void Xintrsoftast(void);
@


1.6
log
@Move cpu_info/curcpu to be mapped by the %fs segment.  Extra input and
debugging by tom@@, art@@, kettenis@@, and others.  Testing by many others.

ok art@@, kettenis@@, tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82489var.h,v 1.5 2007/05/25 15:55:27 art Exp $	*/
d111 3
a113 4
#define LAPIC_IPI_AST			(LAPIC_IPI_OFFSET + 0)
#define LAPIC_IPI_INVLTLB		(LAPIC_IPI_OFFSET + 1)
#define LAPIC_IPI_INVLPG		(LAPIC_IPI_OFFSET + 2)
#define LAPIC_IPI_INVLRANGE		(LAPIC_IPI_OFFSET + 3)
a114 1
extern void Xintripi_ast(void);
@


1.5
log
@Replace the overdesigned and overcomplicated tlb shootdown code with
very simple and dumb fast tlb IPI handlers that have in the order of
the same amount of instructions as the old code had function calls.

All TLB shootdowns are reorganized so that we always shoot the,
without looking at PG_U and when we're shooting a range (primarily in
pmap_remove), we shoot the range when there are 32 or less pages in
it, otherwise we just nuke the whole TLB (this might need tweaking if
someone is interested in micro-optimization). The IPIs are not handled
through the normal interrupt vectoring code, they are not blockable
and they only shoot one page or a range of pages or the whole tlb.

This gives a 15% reduction in system time on my dual-core laptop
during a kernel compile and an 18% reduction in real time on a quad
machine doing bulk ports build.

Tested by many, in snaps for a week, no slowdowns reported (although not
everyone is seeing such huge wins).
@
text
@d1 1
a1 1
/*	$OpenBSD: i82489var.h,v 1.4 2007/04/12 20:22:58 art Exp $	*/
d136 2
@


1.4
log
@Faster signal delivery on i386/MP.

We need to poke the other CPU so that it processes the AST immediately
and doesn't wait for the next interrupt or syscall.

Since IPIs really shouldn't process ASTs, we need to trigger a soft
interrupt on the destination CPU to process the AST. But since we can't
send soft interrupts to other CPUs, we send an IPI, that triggers a soft
interrupt that in turn processes the AST.

Also, this marks the beginning of moving to slightly better IPI mechanism
of short and optimized IPIs instead of the large and complicated IPI
infrastructure we're using now.

tested by many, ok tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82489var.h,v 1.3 2006/03/29 15:02:27 mickey Exp $	*/
d112 8
@


1.3
log
@workaround for intel errata p53 -- follow lapic writes w/ a read; toby@@ kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: i82489var.h,v 1.2 2004/06/13 21:49:16 niklas Exp $	*/
d105 7
d116 1
@


1.2
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 8
@


1.1
log
@file i82489var.h was initially added on branch SMP.
@
text
@d1 113
@


1.1.2.1
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@a0 110
/*	$NetBSD: i82489var.h,v 1.1.2.2 2000/02/21 18:46:14 sommerfeld Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Frank van der Linden.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _I386_I82489REG_H_
#define _I386_I82489REG_H_

static __inline__ u_int32_t i82489_readreg __P((int));
static __inline__ void i82489_writereg __P((int, u_int32_t));

#ifdef _KERNEL
extern volatile u_int32_t local_apic[];
#endif

static __inline__ u_int32_t
i82489_readreg(reg)
	int reg;
{
	return *((volatile u_int32_t *)(((volatile u_int8_t *)local_apic)
	    + reg));
}

static __inline__ void
i82489_writereg(reg, val)
	int reg;
	u_int32_t val;
{
	*((volatile u_int32_t *)(((volatile u_int8_t *)local_apic) + reg)) = val;
}

/*
 * "spurious interrupt vector"; vector used by interrupt which was
 * aborted because the CPU masked it after it happened but before it
 * was delivered.. "Oh, sorry, i caught you at a bad time".
 * Low-order 4 bits must be all ones.
 */
extern void i386_spurious(void);
extern void Xintrspurious(void);
#define LAPIC_SPURIOUS_VECTOR		0xef

/*
 * Vector used for inter-processor interrupts.
 */
extern void Xintripi(void);
#define LAPIC_IPI_VECTOR			0xe0

/*
 * Vector used for local apic timer interrupts.
 */

extern void Xintrltimer(void);
#define LAPIC_TIMER_VECTOR		0xd0

/*
 * Vectors to be used for self-soft-interrupts.
 */

#define LAPIC_SOFTCLOCK_VECTOR		SIR_CLOCK
#define LAPIC_SOFTNET_VECTOR		SIR_NET
#define LAPIC_SOFTTTY_VECTOR		SIR_TTY

extern void Xintrsoftclock(void);
extern void Xintrsoftnet(void);
extern void Xintrsofttty(void);

extern void (*apichandler[]) __P((void));

struct cpu_info;

extern void lapic_boot_init __P((paddr_t));
extern void lapic_set_lvt __P((void));
extern void lapic_enable __P((void));
extern void lapic_calibrate_timer __P((struct cpu_info *ci));

#endif

@


1.1.2.2
log
@Add $OpenBSD$.
@
text
@a0 1
/*	$OpenBSD$	*/
@


1.1.2.3
log
@KNF
Move LAPIC vectors where OpenBSD can have them.
Correct multiple include protection constant name
@
text
@d1 1
a1 1
/*	$OpenBSD: i82489var.h,v 1.1.2.2 2001/07/15 15:13:29 ho Exp $	*/
d40 2
a41 2
#ifndef _I386_I82489VAR_H_
#define _I386_I82489VAR_H_
d63 1
a63 2
	*((volatile u_int32_t *)(((volatile u_int8_t *)local_apic) + reg)) =
	    val;
d80 1
a80 1
#define LAPIC_IPI_VECTOR		0xe0
d93 3
a95 3
#define LAPIC_SOFTCLOCK_VECTOR		(NRSVIDT + (IPL_HIGH + 1) * 16)
#define LAPIC_SOFTNET_VECTOR		(NRSVIDT + (IPL_HIGH + 1) * 16 + 1)
#define LAPIC_SOFTTTY_VECTOR		(NRSVIDT + (IPL_HIGH + 1) * 16 + 2)
d108 1
a108 1
extern void lapic_calibrate_timer __P((struct cpu_info *));
d111 1
@


1.1.2.4
log
@New interrupt and spl* system, mostly from NetBSD's i386 MP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: i82489var.h,v 1.1.2.3 2001/07/16 21:40:50 niklas Exp $	*/
d81 1
a81 1
#define LAPIC_IPI_VECTOR		IPL_IPI
d88 1
a88 1
#define LAPIC_TIMER_VECTOR		IPL_CLOCK
d94 3
a96 3
#define LAPIC_SOFTCLOCK_VECTOR		IPL_SOFTCLOCK
#define LAPIC_SOFTNET_VECTOR		IPL_SOFTNET
#define LAPIC_SOFTTTY_VECTOR		IPL_SOFTTTY
@


1.1.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a107 1
extern void lapic_set_softvectors __P((void));
@


1.1.2.6
log
@unpee, and declare lapic_initclocks
@
text
@d1 1
a1 1
/*	$OpenBSD: i82489var.h,v 1.1.2.5 2001/11/13 21:00:52 niklas Exp $	*/
d43 2
a44 2
static __inline__ u_int32_t i82489_readreg(int);
static __inline__ void i82489_writereg(int, u_int32_t);
d102 1
a102 1
extern void (*apichandler[])(void);
d106 5
a110 6
extern void lapic_boot_init(paddr_t);
extern void lapic_initclocks(void);
extern void lapic_set_lvt(void);
extern void lapic_set_softvectors(void);
extern void lapic_enable(void);
extern void lapic_calibrate_timer(struct cpu_info *);
@


