head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.28
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.26
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.22
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.18
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.20
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.12
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.16
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.14
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.10
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.8
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.6
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.9.0.12
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.10
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.6
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.8
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.4
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.8.0.26
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.24
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.22
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.20
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.18
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.16
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.14
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.12
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.10
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.8
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.7.0.26
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.24
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.22
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.20
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.18
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.16
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.14
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.12
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.10
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.8
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.6
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.4
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.10
date	2011.06.25.19.20.41;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.05.30.09.30.11;	author deraadt;	state Exp;
branches
	1.7.16.1
	1.7.26.1;
next	1.6;

1.6
date	96.05.07.07.22.11;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.02.13.44.03;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.16.48;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.18.19.21.42;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.04.17.05.19.04;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.01.11.17.59.08;	author deraadt;	state Exp;
branches;
next	;

1.7.16.1
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	;

1.7.26.1
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	;


desc
@@


1.10
log
@ansi, no binary change
@
text
@/*	$OpenBSD: vm86.h,v 1.9 2008/06/26 05:42:10 ray Exp $	*/
/*	$NetBSD: vm86.h,v 1.8 1996/05/03 19:26:32 christos Exp $	*/

#undef	VM86_USE_VIF

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by John T. Kohl and Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#define SETFLAGS(targ, new, newmask) (targ) = ((targ) & ~(newmask)) | ((new) & (newmask))

#define VM86_TYPE(x)	((x) & 0xff)
#define VM86_ARG(x)	(((x) & 0xff00) >> 8)
#define	VM86_MAKEVAL(type,arg) ((type) | (((arg) & 0xff) << 8))
#define		VM86_STI	0
#define		VM86_INTx	1
#define		VM86_SIGNAL	2
#define		VM86_UNKNOWN	3

#define	VM86_REALFLAGS	(~PSL_USERSTATIC)
#define	VM86_VIRTFLAGS	(PSL_USERSTATIC & ~(PSL_MBO | PSL_MBZ))

struct vm86_regs {
	struct sigcontext vmsc;
};

struct vm86_kern {			/* kernel uses this stuff */
	struct vm86_regs regs;
	unsigned long ss_cpu_type;
};
#define cpu_type substr.ss_cpu_type

/*
 * Kernel keeps copy of user-mode address of this, but doesn't copy it in.
 */
struct vm86_struct {
	struct vm86_kern substr;
	unsigned long screen_bitmap;	/* not used/supported (yet) */
	unsigned long flags;		/* not used/supported (yet) */
	unsigned char int_byuser[32];	/* 256 bits each: pass control to user */
	unsigned char int21_byuser[32];	/* otherwise, handle directly */
};

#define VCPU_086		0
#define VCPU_186		1
#define VCPU_286		2
#define VCPU_386		3
#define VCPU_486		4
#define VCPU_586		5

#ifdef _KERNEL
int i386_vm86(struct proc *, char *, register_t *);
void vm86_gpfault(struct proc *, int);
void vm86_return(struct proc *, int);
static __inline void clr_vif(struct proc *);
static __inline void set_vif(struct proc *);
static __inline void set_vflags(struct proc *, int);
static __inline int get_vflags(struct proc *);
static __inline void set_vflags_short(struct proc *, int);
static __inline int get_vflags_short(struct proc *);

static __inline void
clr_vif(p)
	struct proc *p;
{
	struct pcb *pcb = &p->p_addr->u_pcb;

#ifndef VM86_USE_VIF
	pcb->vm86_eflags &= ~PSL_I;
#else
	pcb->vm86_eflags &= ~PSL_VIF;
#endif
}

static __inline void
set_vif(struct proc *p)
{
	struct pcb *pcb = &p->p_addr->u_pcb;

#ifndef VM86_USE_VIF
	pcb->vm86_eflags |= PSL_I;
	if ((pcb->vm86_eflags & (PSL_I|PSL_VIP)) == (PSL_I|PSL_VIP))
#else
	pcb->vm86_eflags |= PSL_VIF;
	if ((pcb->vm86_eflags & (PSL_VIF|PSL_VIP)) == (PSL_VIF|PSL_VIP))
#endif
		vm86_return(p, VM86_STI);
}

static __inline void
set_vflags(struct proc *p, int flags)
{
	struct trapframe *tf = p->p_md.md_regs;
	struct pcb *pcb = &p->p_addr->u_pcb;

	flags &= ~pcb->vm86_flagmask;
	SETFLAGS(pcb->vm86_eflags, flags, VM86_VIRTFLAGS);
	SETFLAGS(tf->tf_eflags, flags, VM86_REALFLAGS);
#ifndef VM86_USE_VIF
	if ((pcb->vm86_eflags & (PSL_I|PSL_VIP)) == (PSL_I|PSL_VIP))
#else
	if ((pcb->vm86_eflags & (PSL_VIF|PSL_VIP)) == (PSL_VIF|PSL_VIP))
#endif
		vm86_return(p, VM86_STI);
}

static __inline int
get_vflags(struct proc *p)
{
	struct trapframe *tf = p->p_md.md_regs;
	struct pcb *pcb = &p->p_addr->u_pcb;
	int flags = PSL_MBO;

	SETFLAGS(flags, pcb->vm86_eflags, VM86_VIRTFLAGS);
	SETFLAGS(flags, tf->tf_eflags, VM86_REALFLAGS);
	return (flags);
}

static __inline void
set_vflags_short(struct proc *p, int flags)
{
	struct trapframe *tf = p->p_md.md_regs;
	struct pcb *pcb = &p->p_addr->u_pcb;

	flags &= ~pcb->vm86_flagmask;
	SETFLAGS(pcb->vm86_eflags, flags, VM86_VIRTFLAGS & 0xffff);
	SETFLAGS(tf->tf_eflags, flags, VM86_REALFLAGS & 0xffff);
#ifndef VM86_USE_VIF
	if ((pcb->vm86_eflags & (PSL_I|PSL_VIP)) == (PSL_I|PSL_VIP))
		vm86_return(p, VM86_STI);
#endif
}

static __inline int
get_vflags_short(struct proc *p)
{
	struct trapframe *tf = p->p_md.md_regs;
	struct pcb *pcb = &p->p_addr->u_pcb;
	int flags = PSL_MBO;

	SETFLAGS(flags, pcb->vm86_eflags, VM86_VIRTFLAGS & 0xffff);
	SETFLAGS(flags, tf->tf_eflags, VM86_REALFLAGS & 0xffff);
	return (flags);
}
#else
int i386_vm86(struct vm86_struct *vmcp);
#endif
@


1.9
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vm86.h,v 1.8 2002/03/14 01:26:33 millert Exp $	*/
d101 1
a101 2
set_vif(p)
	struct proc *p;
d116 1
a116 3
set_vflags(p, flags)
	struct proc *p;
	int flags;
d133 1
a133 2
get_vflags(p)
	struct proc *p;
d145 1
a145 3
set_vflags_short(p, flags)
	struct proc *p;
	int flags;
d160 1
a160 2
get_vflags_short(p)
	struct proc *p;
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vm86.h,v 1.7 1996/05/30 09:30:11 deraadt Exp $	*/
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.7
log
@clean & sync
@
text
@d84 9
a92 9
int i386_vm86 __P((struct proc *, char *, register_t *));
void vm86_gpfault __P((struct proc *, int));
void vm86_return __P((struct proc *, int));
static __inline void clr_vif __P((struct proc *));
static __inline void set_vif __P((struct proc *));
static __inline void set_vflags __P((struct proc *, int));
static __inline int get_vflags __P((struct proc *));
static __inline void set_vflags_short __P((struct proc *, int));
static __inline int get_vflags_short __P((struct proc *));
d185 1
a185 1
int i386_vm86 __P((struct vm86_struct *vmcp));
@


1.7.26.1
log
@Sync UBC branch to -current
@
text
@d84 9
a92 9
int i386_vm86(struct proc *, char *, register_t *);
void vm86_gpfault(struct proc *, int);
void vm86_return(struct proc *, int);
static __inline void clr_vif(struct proc *);
static __inline void set_vif(struct proc *);
static __inline void set_vflags(struct proc *, int);
static __inline int get_vflags(struct proc *);
static __inline void set_vflags_short(struct proc *, int);
static __inline int get_vflags_short(struct proc *);
d185 1
a185 1
int i386_vm86(struct vm86_struct *vmcp);
@


1.7.16.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 9
a92 9
int i386_vm86(struct proc *, char *, register_t *);
void vm86_gpfault(struct proc *, int);
void vm86_return(struct proc *, int);
static __inline void clr_vif(struct proc *);
static __inline void set_vif(struct proc *);
static __inline void set_vflags(struct proc *, int);
static __inline int get_vflags(struct proc *);
static __inline void set_vflags_short(struct proc *, int);
static __inline int get_vflags_short(struct proc *);
d185 1
a185 1
int i386_vm86(struct vm86_struct *vmcp);
@


1.6
log
@sync with 0504; prototype changes
@
text
@d1 1
a1 1
/*	$OpenBSD: vm86.h,v 1.4 1996/04/21 22:16:48 deraadt Exp $	*/
a53 3

#define	VM86_SETDIRECT	(~PSL_USERSTATIC)
#define	VM86_GETDIRECT	(VM86_SETDIRECT|PSL_MBO|PSL_MBZ)
@


1.5
log
@Remove BIOSSEG.
Don't mess with the flags when entering a software interrupt.
Use IF, not VIF.
NOTE: These changes break dosemu, but are required for proper emulation.
@
text
@d2 1
a2 1
/*	$NetBSD: vm86.h,v 1.6 1996/04/18 10:04:32 mycroft Exp $	*/
d4 1
a4 1
#define	VM86_USE_VIF
a78 2
#define BIOSSEG		0x0f000

d90 6
d97 1
a97 1
static __inline__ void
d110 1
a110 1
static __inline__ void
d126 1
a126 1
static __inline__ void
d145 1
a145 1
static __inline__ int
d158 1
a158 1
static __inline__ void
d175 1
a175 1
static __inline__ int
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: vm86.h,v 1.3 1996/04/18 19:21:42 niklas Exp $	*/
/*	$NetBSD: vm86.h,v 1.5 1996/04/12 05:57:45 mycroft Exp $	*/
d52 2
a53 2
#define	VM86_SETDIRECT	(~PSL_USERSTATIC)
#define	VM86_GETDIRECT	(VM86_SETDIRECT|PSL_MBO|PSL_MBZ)
d131 2
a132 2
	SETFLAGS(pcb->vm86_eflags, flags, ~VM86_GETDIRECT);
	SETFLAGS(tf->tf_eflags, flags, VM86_SETDIRECT);
d147 1
a147 1
	int flags = 0;
d149 2
a150 2
	SETFLAGS(flags, pcb->vm86_eflags, ~VM86_GETDIRECT);
	SETFLAGS(flags, tf->tf_eflags, VM86_GETDIRECT);
d163 2
a164 2
	SETFLAGS(pcb->vm86_eflags, flags, ~VM86_GETDIRECT & 0xffff);
	SETFLAGS(tf->tf_eflags, flags, VM86_SETDIRECT & 0xffff);
d177 1
a177 1
	int flags = 0;
d179 2
a180 2
	SETFLAGS(flags, pcb->vm86_eflags, ~VM86_GETDIRECT & 0xffff);
	SETFLAGS(flags, tf->tf_eflags, VM86_GETDIRECT & 0xffff);
@


1.3
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD: vm86.h,v 1.2 1996/04/17 05:19:04 mickey Exp $	*/
/*	$NetBSD: vm86.h,v 1.4 1996/04/11 10:07:25 mycroft Exp $	*/
d55 3
d130 2
a131 1
	SETFLAGS(pcb->vm86_eflags, flags, pcb->vm86_flagmask | ~VM86_GETDIRECT);
d149 1
a149 1
	SETFLAGS(flags, pcb->vm86_eflags, pcb->vm86_flagmask | ~VM86_GETDIRECT);
d162 2
a163 1
	SETFLAGS(pcb->vm86_eflags, flags, (pcb->vm86_flagmask | ~VM86_GETDIRECT) & 0xffff);
d179 1
a179 1
	SETFLAGS(flags, pcb->vm86_eflags, (pcb->vm86_flagmask | ~VM86_GETDIRECT) & 0xffff);
@


1.2
log
@Cleanups & fixes from latest NetBSD primarily to run doscmd, etc.
GENERIC added to the compile/.cvsignore (it is used for 'make links'
for example), thus conf/GENERIC should appear magically ...
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@from netbsd; VM86 support, by John Kohl, touched up a bit by charles
@
text
@d1 2
a2 1
/*	$NetBSD: vm86.h,v 1.1 1996/01/08 13:51:45 mycroft Exp $	*/
d4 35
a38 25
/*
 *  Copyright (c) 1995 John T. Kohl
 *  All rights reserved.
 * 
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
a39 1
 * 
a42 2
#define VM86_EFLAGS(p)	((p)->p_addr->u_pcb.vm86_eflags)
#define VM86_FLAGMASK(p) ((p)->p_addr->u_pcb.vm86_flagmask)
d52 3
d88 90
@
