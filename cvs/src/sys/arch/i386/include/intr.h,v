head	1.47;
access;
symbols
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.47.0.4
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.44.0.4
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.43.0.14
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.43.0.10
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.8
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.6
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.4
	OPENBSD_5_0:1.43.0.2
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.41.0.2
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.39.0.4
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.38.0.4
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.36.0.2
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.27.0.4
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.2
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.25.0.4
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.17
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.4
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.47
date	2015.09.13.12.28.31;	author kettenis;	state Exp;
branches;
next	1.46;
commitid	AIBHsFOWHdAQ1DwO;

1.46
date	2015.07.19.18.53.49;	author sf;	state Exp;
branches;
next	1.45;
commitid	Hi0HvjMg10KWPunS;

1.45
date	2015.07.16.05.10.14;	author guenther;	state Exp;
branches;
next	1.44;
commitid	vUE3LzynpntlHxEC;

1.44
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2011.07.05.17.11.07;	author oga;	state Exp;
branches;
next	1.42;

1.42
date	2011.03.23.16.54.35;	author pirofti;	state Exp;
branches;
next	1.41;

1.41
date	2010.12.27.19.51.27;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2010.12.21.14.56.23;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2009.08.13.13.24.48;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2009.04.19.17.50.18;	author oga;	state Exp;
branches;
next	1.37;

1.37
date	2009.03.15.19.40.40;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2008.09.28.20.43.31;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2008.05.07.20.42.02;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2008.04.25.19.50.08;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.07.08.37.38;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.25.15.55.27;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.16.19.37.06;	author thib;	state Exp;
branches;
next	1.30;

1.30
date	2007.04.21.21.06.15;	author gwk;	state Exp;
branches;
next	1.29;

1.29
date	2007.04.03.10.14.47;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2007.03.23.16.03.52;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.29.09.54.20;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.12.02.04.15;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.19.15.29.47;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2005.01.07.02.03.17;	author pascoe;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.24.21.22.01;	author pvalchev;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.16.18.27.26;	author grange;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.13.21.49.16;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.23.00.06.01;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.17.03.42.14;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.11.07.16.11;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.19.16.23.29;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.11.05.03.13;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.22.18.43.45;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.29.07.35.18;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.14.08.35.12;	author niklas;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.12.13.23.38.27;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.04.00.00.36;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.18.20.46.49;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.12.20.28.20;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.24.17.05.36;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.05.22.07.31;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.06.15.29.53;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	99.07.26.02.38.17;	author csapuntz;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	99.07.23.13.18.04;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.08.06.23.33.29;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.05.25.22.17.46;	author deraadt;	state Exp;
branches;
next	;

1.4.4.1
date	2001.04.18.16.07.33;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.07.04.10.16.47;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2001.07.14.10.02.38;	author ho;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2001.10.27.09.57.31;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2001.10.28.22.41.19;	author niklas;	state Exp;
branches;
next	1.4.4.6;

1.4.4.6
date	2001.10.29.08.41.00;	author niklas;	state Exp;
branches;
next	1.4.4.7;

1.4.4.7
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.4.4.8;

1.4.4.8
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.4.4.9;

1.4.4.9
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.4.4.10;

1.4.4.10
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.4.4.11;

1.4.4.11
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.4.4.12;

1.4.4.12
date	2003.04.05.20.41.11;	author niklas;	state Exp;
branches;
next	1.4.4.13;

1.4.4.13
date	2003.04.06.14.04.33;	author niklas;	state Exp;
branches;
next	1.4.4.14;

1.4.4.14
date	2003.05.13.19.42.08;	author ho;	state Exp;
branches;
next	1.4.4.15;

1.4.4.15
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.4.4.16;

1.4.4.16
date	2003.05.15.17.46.30;	author niklas;	state Exp;
branches;
next	1.4.4.17;

1.4.4.17
date	2003.05.17.16.07.37;	author andreas;	state Exp;
branches;
next	1.4.4.18;

1.4.4.18
date	2003.05.25.19.24.31;	author ho;	state Exp;
branches;
next	1.4.4.19;

1.4.4.19
date	2004.02.20.22.19.55;	author niklas;	state Exp;
branches;
next	1.4.4.20;

1.4.4.20
date	2004.03.18.02.07.52;	author niklas;	state Exp;
branches;
next	1.4.4.21;

1.4.4.21
date	2004.06.06.22.26.34;	author niklas;	state Exp;
branches;
next	1.4.4.22;

1.4.4.22
date	2004.06.10.11.40.25;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.10.29.00.28.04;	author art;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.47
log
@intr_barrier(9) for i386.
@
text
@/*	$OpenBSD: intr.h,v 1.46 2015/07/19 18:53:49 sf Exp $	*/
/*	$NetBSD: intr.h,v 1.5 1996/05/13 06:11:28 mycroft Exp $	*/

/*
 * Copyright (c) 1996 Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_INTR_H_
#define _MACHINE_INTR_H_

#include <machine/intrdefs.h>

#ifndef _LOCORE
#include <sys/mutex.h>
#include <machine/cpu.h>

extern volatile u_int32_t lapic_tpr;	/* Current interrupt priority level. */

extern int imask[];	/* Bitmasks telling what interrupts are blocked. */
extern int iunmask[];	/* Bitmasks telling what interrupts are accepted. */

#define IMASK(level) imask[IPL(level)]
#define IUNMASK(level) iunmask[IPL(level)]

extern void Xspllower(void);

extern int splraise(int);
extern int spllower(int);
extern void splx(int);
extern void softintr(int);

/*
 * compiler barrier: prevent reordering of instructions.
 * XXX something similar will move to <sys/cdefs.h>
 * or thereabouts.
 * This prevents the compiler from reordering code around
 * this "instruction", acting as a sequence point for code generation.
 */

#define	__splbarrier() __asm volatile("":::"memory")

/* SPL asserts */
#ifdef DIAGNOSTIC
/*
 * Although this function is implemented in MI code, it must be in this MD
 * header because we don't want this header to include MI includes.
 */
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void splassert_check(int, const char *);
#define splassert(__wantipl) do {			\
	if (splassert_ctl > 0) {			\
		splassert_check(__wantipl, __func__);	\
	}						\
} while (0)
#define splsoftassert(wantipl) splassert(wantipl)
#else
#define splassert(wantipl)	do { /* nada */ } while (0)
#define splsoftassert(wantipl)	do { /* nada */ } while (0)
#endif

/*
 * Define the splraise and splx code in macros, so that the code can be
 * reused in a profiling build in a way that does not cause recursion.
 */
#define _SPLRAISE(ocpl, ncpl) 		\
	ocpl = lapic_tpr;		\
	if (ncpl > ocpl)		\
		lapic_tpr = ncpl


#define _SPLX(ncpl) 			\
	lapic_tpr = ncpl;		\
	if (curcpu()->ci_ipending & IUNMASK(ncpl))	\
		Xspllower()

/*
 * Hardware interrupt masks
 */
#define	splbio()	splraise(IPL_BIO)
#define	splnet()	splraise(IPL_NET)
#define	spltty()	splraise(IPL_TTY)
#define	splaudio()	splraise(IPL_AUDIO)
#define	splclock()	splraise(IPL_CLOCK)
#define	splstatclock()	splclock()
#define splipi()	splraise(IPL_IPI)

/*
 * Software interrupt masks
 */
#define	splsoftclock()		splraise(IPL_SOFTCLOCK)
#define	splsoftnet()		splraise(IPL_SOFTNET)
#define	splsofttty()		splraise(IPL_SOFTTTY)

/*
 * Miscellaneous
 */
#define	splvm()		splraise(IPL_VM)
#define	splhigh()	splraise(IPL_HIGH)
#define	splsched()	splraise(IPL_SCHED)
#define spllock() 	splhigh()
#define	spl0()		spllower(IPL_NONE)

#include <machine/pic.h>

struct cpu_info;

void intr_barrier(void *);

#ifdef MULTIPROCESSOR
void i386_send_ipi(struct cpu_info *, int);
int i386_fast_ipi(struct cpu_info *, int);
void i386_broadcast_ipi(int);
void i386_ipi_handler(void);
void i386_setperf_ipi(struct cpu_info *);

extern void (*ipifunc[I386_NIPI])(struct cpu_info *);
#endif

#endif /* !_LOCORE */

/*
 * Generic software interrupt support.
 */

#define	I386_SOFTINTR_SOFTCLOCK		0
#define	I386_SOFTINTR_SOFTNET		1
#define	I386_SOFTINTR_SOFTTTY		2
#define	I386_NSOFTINTR			3

#ifndef _LOCORE
#include <sys/queue.h>

struct i386_soft_intrhand {
	TAILQ_ENTRY(i386_soft_intrhand)
		sih_q;
	struct i386_soft_intr *sih_intrhead;
	void	(*sih_fn)(void *);
	void	*sih_arg;
	int	sih_pending;
};

struct i386_soft_intr {
	TAILQ_HEAD(, i386_soft_intrhand)
			softintr_q;
	int		softintr_ssir;
	struct mutex	softintr_lock;
};

void	*softintr_establish(int, void (*)(void *), void *);
void	softintr_disestablish(void *);
void	softintr_init(void);
void	softintr_dispatch(int);

#define	softintr_schedule(arg)						\
do {									\
	struct i386_soft_intrhand *__sih = (arg);			\
	struct i386_soft_intr *__si = __sih->sih_intrhead;		\
									\
	mtx_enter(&__si->softintr_lock);				\
	if (__sih->sih_pending == 0) {					\
		TAILQ_INSERT_TAIL(&__si->softintr_q, __sih, sih_q);	\
		__sih->sih_pending = 1;					\
		softintr(__si->softintr_ssir);				\
	}								\
	mtx_leave(&__si->softintr_lock);				\
} while (/*CONSTCOND*/ 0)
#endif /* _LOCORE */

#endif /* !_MACHINE_INTR_H_ */
@


1.46
log
@Make i386_send_ipi() return void

Nobody uses its return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.45 2015/07/16 05:10:14 guenther Exp $	*/
d132 2
@


1.45
log
@Move grab/release of the kernel_lock for softintrs from the ASM stubs to
softintr_dispatch().  Delete traces of long superseded stats code.

ok beck@@ mpi@@ uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.44 2014/03/29 18:09:29 guenther Exp $	*/
d134 1
a134 1
int i386_send_ipi(struct cpu_info *, int);
@


1.44
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.43 2011/07/05 17:11:07 oga Exp $	*/
a137 4
void i386_intlock(int);
void i386_intunlock(int);
void i386_softintlock(void);
void i386_softintunlock(void);
@


1.43
log
@N: Thou shalt not call hardclock() with biglock held.

i386 disobeys the Nth commandment. Fix this. While here, make i386 and amd64
definitions of iplclock and statclock match.

ok art@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.42 2011/03/23 16:54:35 pirofti Exp $	*/
d65 1
a65 1
#define	__splbarrier() __asm __volatile("":::"memory")
@


1.42
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.41 2010/12/27 19:51:27 guenther Exp $	*/
d110 1
a110 1
#define	splstatclock()	splhigh()
@


1.41
log
@Eliminate x86_multicast_ipi() as unused and broken (doesn't handle #cpu>32).
The i386 version was removed some time ago, so kill its declaration too.
ok tedu@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.40 2010/12/21 14:56:23 claudio Exp $	*/
d33 2
a34 2
#ifndef _I386_INTR_H_
#define _I386_INTR_H_
d197 1
a197 1
#endif /* !_I386_INTR_H_ */
@


1.40
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.39 2009/08/13 13:24:48 kettenis Exp $	*/
a136 1
void i386_multicast_ipi(int, int);
@


1.39
log
@Make the i386 APIC code closer to the amd64 version.  Many whitespace fixes,
some additional code.

ok toby@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.38 2009/04/19 17:50:18 oga Exp $	*/
a127 3

#define	setsoftnet()	softintr(SIR_NET)
#define	setsofttty()	softintr(SIR_TTY)
@


1.38
log
@Switch the softinterrupt code on x86 over to mutexes instead of
simplelocks + splhigh().

First part of making it possible to make mpsafe softinterrupts.

"oh yes, definitely" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.37 2009/03/15 19:40:40 miod Exp $	*/
d131 2
@


1.37
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.36 2008/09/28 20:43:31 brad Exp $	*/
d39 1
d174 3
a176 3
		softintr_q;
	int softintr_ssir;
	struct simplelock softintr_slock;
a178 12
#define	i386_softintr_lock(si, s)					\
do {									\
	(s) = splhigh();						\
	simple_lock(&si->softintr_slock);				\
} while (/*CONSTCOND*/ 0)

#define	i386_softintr_unlock(si, s)					\
do {									\
	simple_unlock(&si->softintr_slock);				\
	splx((s));							\
} while (/*CONSTCOND*/ 0)

a187 1
	int __s;							\
d189 1
a189 1
	i386_softintr_lock(__si, __s);					\
d195 1
a195 1
	i386_softintr_unlock(__si, __s);					\
@


1.36
log
@Always include machine/cpu.h and remove i82489reg.h/i82489var.h.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.35 2008/05/07 20:42:02 kettenis Exp $	*/
d80 1
d82 2
a83 1
#define splassert(wantipl) do { /* nada */ } while (0)
@


1.35
log
@Move i386 to __HAVE_GENERIC_SOFT_INTERRUPTS

ok dlg@@, tested by dlg@@, oga@@, jsg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.34 2008/04/25 19:50:08 kettenis Exp $	*/
a38 4

#ifdef MULTIPROCESSOR
#include <machine/i82489reg.h>
#include <machine/i82489var.h>
a39 1
#endif
@


1.34
log
@Make ipending per-cpu.  Should fix PR 5788.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.33 2007/09/07 08:37:38 art Exp $	*/
d59 1
a59 1
extern void softintr(int, int);
d131 2
a132 3
#define	setsoftclock()	softintr(1 << SIR_CLOCK, IPL_SOFTCLOCK)
#define	setsoftnet()	softintr(1 << SIR_NET, IPL_SOFTNET)
#define	setsofttty()	softintr(1 << SIR_TTY, IPL_SOFTTTY)
d152 61
@


1.33
log
@Remove some left-overs from the TSC based microtime. We don't need
to synchronize the tsc between CPUs anymore. While here, also remove
the slow TLB IPI since it's been dead for a while.

noticed by mickey
toby@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.32 2007/05/25 15:55:27 art Exp $	*/
a47 1
extern volatile u_int32_t ipending;	/* Interrupts pending. */
d101 1
a101 1
	if (ipending & IUNMASK(ncpl))	\
@


1.32
log
@Replace the overdesigned and overcomplicated tlb shootdown code with
very simple and dumb fast tlb IPI handlers that have in the order of
the same amount of instructions as the old code had function calls.

All TLB shootdowns are reorganized so that we always shoot the,
without looking at PG_U and when we're shooting a range (primarily in
pmap_remove), we shoot the range when there are 32 or less pages in
it, otherwise we just nuke the whole TLB (this might need tweaking if
someone is interested in micro-optimization). The IPIs are not handled
through the normal interrupt vectoring code, they are not blockable
and they only shoot one page or a range of pages or the whole tlb.

This gives a 15% reduction in system time on my dual-core laptop
during a kernel compile and an 18% reduction in real time on a quad
machine doing bulk ports build.

Tested by many, in snaps for a week, no slowdowns reported (although not
everyone is seeing such huge wins).
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.31 2007/05/16 19:37:06 thib Exp $	*/
a143 1
void i386_ipi_microset(struct cpu_info *);
@


1.31
log
@splassert_ctl defaults to 1 now, so dont wrap the checks for
splassert_ctl > 0 in __predict_false().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.30 2007/04/21 21:06:15 gwk Exp $	*/
d140 1
@


1.30
log
@Introduce a smp aware hw.setperf mechanism, it will scale all CPUs or
cores by the same amount, i.e. if you do hw.setperf=50 both cores will
be scaled to the opearting state corresponing to 50%. Tested by many with
est (mainly on core2duo machines like X60 thinkpads). Only enable est
during GENERIC.MP build no one tested powernow.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.29 2007/04/03 10:14:47 art Exp $	*/
d82 1
a82 1
	if (__predict_false(splassert_ctl > 0)) {	\
@


1.29
log
@Make the ast on i386 per-process instead of per-cpu. This makes
signal delivery more reliable in some cases when a process switches
cpu.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.28 2007/03/23 16:03:52 art Exp $	*/
d148 1
@


1.28
log
@Remove duplicated defines from intr.h that are already defined in
intrdefs.h that is inlucded first thing in intr.h.

eyeballed for sanity by pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.27 2006/05/29 09:54:20 mickey Exp $	*/
a131 1
#define	setsoftast()	(astpending = 1)
@


1.27
log
@implement reliable microtime on smp (joint work w/ otto):
send a bcast ipi from the cpu0 to all others to timestamp tsc
on every clock intr. this way using local tsc provides accurate
microtime() measurements. thus gettimeofday test passes now.
otto@@ deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.26 2006/03/12 02:04:15 brad Exp $	*/
a135 11

#define I386_IPI_HALT		0x00000001
#define I386_IPI_MICROSET	0x00000002
#define I386_IPI_FLUSH_FPU	0x00000004
#define I386_IPI_SYNCH_FPU	0x00000008
#define I386_IPI_TLB		0x00000010
#define I386_IPI_MTRR		0x00000020
#define I386_IPI_GDT		0x00000040
#define I386_IPI_DDB		0x00000080	/* synchronize while in ddb */

#define I386_NIPI	8
@


1.26
log
@remove IPL_IMP and splimp().
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.25 2005/04/19 15:29:47 mickey Exp $	*/
d155 1
@


1.25
log
@nothing uses spllowersoftclock() anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.24 2005/01/07 02:03:17 pascoe Exp $	*/
a126 1
#define splimp()	splvm()
@


1.24
log
@Fix profiled kernel builds on i386 by moving splraise/splx code into macros
permitting non-recursive reuse in mcount.

Should be a no-op for normal builds.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.23 2004/12/24 21:22:01 pvalchev Exp $	*/
a117 3
 *
 * NOTE: spllowersoftclock() is used by hardclock() to lower the priority from
 * clock to softclock before it calls softclock().
a118 1
#define	spllowersoftclock()	spllower(IPL_SOFTCLOCK)
@


1.23
log
@Rewrite intlock/intunlock not to pass around interrupt frame directly
without copying which is against C conventions and broke GENERIC.MP
with a gcc3 optimization
From niklas, tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.22 2004/06/16 18:27:26 grange Exp $	*/
d89 15
@


1.22
log
@We need __splbarrier to compile kernel, tho it should be
replaced with a real gcc barrier.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.21 2004/06/13 21:49:16 niklas Exp $	*/
d145 2
a146 2
void i386_intlock(struct intrframe);
void i386_intunlock(struct intrframe);
@


1.21
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d61 10
@


1.20
log
@workaround gcc brokenness by outlining spl functions.
finally solves vfs corruption.  hint and ok art@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.19 2003/04/17 03:42:14 drahn Exp $	*/
d36 1
a36 20
/*
 * Intel APICs (advanced programmable interrupt controllers) have
 * bytesized priority registers where the upper nibble is the actual
 * interrupt priority level (a.k.a. IPL).  Interrupt vectors are
 * closely tied to these levels as interrupts whose vectors' upper
 * nibble is lower than or equal to the current level are blocked.
 * Not all 256 possible vectors are available for interrupts in
 * APIC systems, only
 *
 * For systems where instead the older ICU (interrupt controlling
 * unit, a.k.a. PIC or 82C59) is used, the IPL is not directly useful,
 * since the interrupt blocking is handled via interrupt masks instead
 * of levels.  However the IPL is easily used as an offset into arrays
 * of masks.
 */
#define IPLSHIFT 4	/* The upper nibble of vectors is the IPL.	*/
#define NIPL 16		/* Four bits of information gives as much.	*/
#define IPL(level) ((level) >> IPLSHIFT)	/* Extract the IPL.	*/
/* XXX Maybe this IDTVECOFF definition should be elsewhere? */
#define IDTVECOFF 0x20	/* The lower 32 IDT vectors are reserved.	*/
d38 1
a38 5
/*
 * This macro is only defined for 0 <= x < 14, i.e. there are fourteen
 * distinct priority levels available for interrupts.
 */
#define MAKEIPL(priority) (IDTVECOFF + ((priority) << IPLSHIFT))
d40 5
a44 34
/*
 * Interrupt priority levels.
 * XXX We are somewhat sloppy about what we mean by IPLs, sometimes
 * XXX we refer to the eight-bit value suitable for storing into APICs'
 * XXX priority registers, other times about the four-bit entity found
 * XXX in the former values' upper nibble, which can be used as offsets
 * XXX in various arrays of our implementation.  We are hoping that
 * XXX the context will provide enough information to not make this
 * XXX sloppy naming a real problem.
 */
#define	IPL_NONE	0		/* nothing */
#define	IPL_SOFTCLOCK	MAKEIPL(0)	/* timeouts */
#define	IPL_SOFTNET	MAKEIPL(1)	/* protocol stacks */
#define	IPL_BIO		MAKEIPL(2)	/* block I/O */
#define	IPL_NET		MAKEIPL(3)	/* network */
#define	IPL_SOFTTTY	MAKEIPL(4)	/* delayed terminal handling */
#define	IPL_TTY		MAKEIPL(5)	/* terminal */
#define	IPL_VM		MAKEIPL(6)	/* memory allocation */
#define IPL_IMP		IPL_VM		/* XXX - should not be here. */
#define	IPL_AUDIO	MAKEIPL(7)	/* audio */
#define	IPL_CLOCK	MAKEIPL(8)	/* clock */
#define	IPL_STATCLOCK	MAKEIPL(9)	/* statclock */
#define	IPL_HIGH	MAKEIPL(9)	/* everything */

/* Interrupt sharing types. */
#define	IST_NONE	0	/* none */
#define	IST_PULSE	1	/* pulsed */
#define	IST_EDGE	2	/* edge-triggered */
#define	IST_LEVEL	3	/* level-triggered */

/* Soft interrupt masks. */
#define	SIR_CLOCK	31
#define	SIR_NET		30
#define	SIR_TTY		29
d46 1
a46 1
#ifndef _LOCORE
d48 3
a50 5
volatile int cpl;	/* Current interrupt priority level.		*/
volatile int ipending;	/* Interrupts pending.				*/
volatile int astpending;/* Asynchronous software traps (softints) pending. */
int imask[NIPL];	/* Bitmasks telling what interrupts are blocked. */
int iunmask[NIPL];	/* Bitmasks telling what interrupts are accepted. */
d57 4
a60 4
int splraise(int);
int spllower(int);
void splx(int);
void softintr(int);
d89 1
d108 2
d113 29
a141 3
#define	setsoftclock()	softintr(1 << SIR_CLOCK)
#define	setsoftnet()	softintr(1 << SIR_NET)
#define	setsofttty()	softintr(1 << SIR_TTY)
@


1.19
log
@i386 changes to move to ELF. asm cleanup. Change MAXDSIZ to 512M for 1Gsep.
DARPA funded work.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.18 2002/12/11 07:16:11 art Exp $	*/
d111 4
a114 4
static __inline int splraise(int);
static __inline int spllower(int);
#define SPLX_DECL void splx(int);
static __inline void softintr(int);
a134 57
 * Raise current interrupt priority level, and return the old one.
 */
static __inline int
splraise(ncpl)
	int ncpl;
{
	int ocpl = cpl;

	if (ncpl > ocpl)
		cpl = ncpl;
	__asm __volatile("":::"memory");
	return (ocpl);
}

/*
 * Restore an old interrupt priority level.  If any thereby unmasked
 * interrupts are pending, call Xspllower() to process them.
 */
#define SPLX_BODY							\
void									\
splx(ncpl)								\
	int ncpl;							\
{									\
	__asm __volatile("":::"memory");				\
	cpl = ncpl;							\
	if (ipending & IUNMASK(ncpl))					\
		Xspllower();						\
}

/* If SMALL_KERNEL make splx out of line, otherwise inline it.  */
#ifdef SMALL_KERNEL
#define SPLX_INLINED_BODY
#define SPLX_OUTLINED_BODY	SPLX_BODY
SPLX_DECL
#else
#define SPLX_INLINED_BODY	static __inline SPLX_BODY
#define SPLX_OUTLINED_BODY
static __inline SPLX_DECL
#endif

SPLX_INLINED_BODY

/*
 * Same as splx(), but we return the old value of spl, for the
 * benefit of some splsoftclock() callers.
 */
static __inline int
spllower(ncpl)
	int ncpl;
{
	int ocpl = cpl;

	splx(ncpl);
	return (ocpl);
}

/*
a161 13

/*
 * Software interrupt registration
 *
 * We hand-code this to ensure that it's atomic.
 */
static __inline void
softintr(mask)
	int mask;
{
	__asm __volatile("orl %1, %0" : "=m"(ipending) : "ir" (mask));

}
@


1.18
log
@Some people say that "__asm __volatile("")" is not enough.
Use "__asm __volatile("":::"memory")" to completly avoid reordering.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.17 2002/07/19 16:23:29 art Exp $	*/
d229 2
a230 1
	__asm __volatile("orl %0,_ipending" : : "ir" (mask));
@


1.17
log
@Define an IPL_VM and mark IPL_IMP as "not to be used".
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.16 2002/06/11 05:03:13 art Exp $	*/
d145 1
a145 1
	__asm __volatile("");
d158 1
a158 1
	__asm __volatile("");						\
@


1.16
log
@define IPL_STATCLOCK
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.15 2002/05/22 18:43:45 art Exp $	*/
d80 2
a81 1
#define	IPL_IMP		MAKEIPL(6)	/* memory allocation */
d215 2
a216 2
#define	splimp()	splraise(IPL_IMP)
#define	splvm()		splraise(IPL_IMP)
@


1.15
log
@Implement splassert. Even simpler than on the sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.14 2002/04/29 07:35:18 miod Exp $	*/
d83 1
@


1.14
log
@Define placeholders for art's splassert() debugging stuff on all arches.
Currently as no-ops everywhere.

ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.13 2002/03/14 01:26:33 millert Exp $	*/
d115 16
a130 1
#define	splassert(wantipl)	/* nothing */
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.12 2001/12/14 08:35:12 niklas Exp $	*/
d113 3
@


1.12
log
@SMALL_KERNEL -> outline splx
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.11 2001/12/13 23:38:27 niklas Exp $	*/
d107 1
a107 1
extern void Xspllower __P((void));
d109 4
a112 4
static __inline int splraise __P((int));
static __inline int spllower __P((int));
#define SPLX_DECL void splx __P((int));
static __inline void softintr __P((int));
@


1.12.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.12 2001/12/14 08:35:12 niklas Exp $	*/
d107 1
a107 1
extern void Xspllower(void);
d109 4
a112 22
static __inline int splraise(int);
static __inline int spllower(int);
#define SPLX_DECL void splx(int);
static __inline void softintr(int);

/* SPL asserts */
#ifdef DIAGNOSTIC
/*
 * Although this function is implemented in MI code, it must be in this MD
 * header because we don't want this header to include MI includes.
 */
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void splassert_check(int, const char *);
#define splassert(__wantipl) do {			\
	if (__predict_false(splassert_ctl > 0)) {	\
		splassert_check(__wantipl, __func__);	\
	}						\
} while (0)
#else
#define splassert(wantipl) do { /* nada */ } while (0)
#endif
@


1.12.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.12.2.1 2002/06/11 03:35:54 art Exp $	*/
d80 1
a80 2
#define	IPL_VM		MAKEIPL(6)	/* memory allocation */
#define IPL_IMP		IPL_VM		/* XXX - should not be here. */
a82 1
#define	IPL_STATCLOCK	MAKEIPL(9)	/* statclock */
d213 2
a214 2
#define	splvm()		splraise(IPL_VM)
#define splimp()	splvm()
@


1.12.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d145 1
a145 1
	__asm __volatile("":::"memory");
d158 1
a158 1
	__asm __volatile("":::"memory");				\
d229 1
a229 2
	__asm __volatile("orl %1, %0" : "=m"(ipending) : "ir" (mask));

@


1.11
log
@remover registers. bracket spl regions with asm volatiles
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.10 2001/12/04 00:00:36 niklas Exp $	*/
d111 1
a111 1
static __inline void splx __P((int));
d133 9
a141 8
static __inline void
splx(ncpl)
	int ncpl;
{
	__asm __volatile("");
	cpl = ncpl;
	if (ipending & IUNMASK(ncpl))
		Xspllower();
d143 13
@


1.10
log
@New try at a level based irq system.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.8 2001/11/12 20:28:20 niklas Exp $	*/
d119 1
a119 1
	register int ncpl;
d121 1
a121 1
	register int ocpl = cpl;
d125 1
d135 1
a135 1
	register int ncpl;
d137 1
d149 1
a149 1
	register int ncpl;
d151 1
a151 1
	register int ocpl = cpl;
d193 1
a193 1
	register int mask;
@


1.9
log
@Revert niklas's broken ICU interrupt handling changes; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.7 2001/06/24 17:05:36 miod Exp $	*/
d36 48
a83 13
/* Interrupt priority `levels'; not mutually exclusive. */
#define	IPL_NONE	0	/* nothing */
#define	IPL_BIO		1	/* block I/O */
#define	IPL_NET		2	/* network */
#define	IPL_TTY		3	/* terminal */
#define	IPL_IMP		4	/* memory allocation */
#define	IPL_AUDIO	5	/* audio */
#define	IPL_CLOCK	6	/* clock */
#define	IPL_HIGH	7	/* everything */

#ifndef _LOCORE
int imask[IPL_HIGH+1];
#endif
a92 1
#define	SIR_CLOCKMASK	((1 << SIR_CLOCK))
a93 1
#define	SIR_NETMASK	((1 << SIR_NET) | SIR_CLOCKMASK)
a94 2
#define	SIR_TTYMASK	((1 << SIR_TTY) | SIR_CLOCKMASK)
#define	SIR_ALLMASK	(SIR_CLOCKMASK | SIR_NETMASK | SIR_TTYMASK)
d98 8
a105 1
volatile int cpl, ipending, astpending;
d115 1
a115 1
 * Add a mask to cpl, and return the old value of cpl.
d123 2
a124 1
	cpl = ocpl | ncpl;
d129 1
a129 1
 * Restore a value to cpl (unmasking interrupts).  If any unmasked
a135 1

d137 1
a137 1
	if (ipending & ~ncpl)
d151 1
a151 3
	cpl = ncpl;
	if (ipending & ~ncpl)
		Xspllower();
d158 5
a162 5
#define	splbio()	splraise(imask[IPL_BIO])
#define	splnet()	splraise(imask[IPL_NET])
#define	spltty()	splraise(imask[IPL_TTY])
#define	splaudio()	splraise(imask[IPL_AUDIO])
#define	splclock()	splraise(imask[IPL_CLOCK])
d171 4
a174 4
#define	spllowersoftclock()	spllower(SIR_CLOCKMASK)
#define	splsoftclock()		splraise(SIR_CLOCKMASK)
#define	splsoftnet()		splraise(SIR_NETMASK)
#define	splsofttty()		splraise(SIR_TTYMASK)
d179 4
a182 4
#define	splimp()	splraise(imask[IPL_IMP])
#define	splvm()		splraise(imask[IPL_IMP])
#define	splhigh()	splraise(imask[IPL_HIGH])
#define	spl0()		spllower(0)
a192 1

@


1.8
log
@Redo the ICU interrupt handling system to better emulate an APIC system.
This is done by representing the current blockings of interrupts with
a priority level instead of an interrupt mask.  This makes it possible to
share implementations for spl* functions/macros between both ICU
and APIC (a must when going MP) systems.  In this process, assign
soft interrupts their own levels to match the way things will be on
APIC systems where they actually will be real interrupts and not just
bits in a pending mask as they are now.
Heavily inspired by Bill Studenmunds SMP work in NetBSD
@
text
@d36 13
a48 48
/*
 * Intel APICs (advanced programmable interrupt controllers) have
 * bytesized priority registers where the upper nibble is the actual
 * interrupt priority level (a.k.a. IPL).  Interrupt vectors are
 * closely tied to these levels as interrupts whose vectors' upper
 * nibble is lower than or equal to the current level are blocked.
 * Not all 256 possible vectors are available for interrupts in
 * APIC systems, only
 *
 * For systems where instead the older ICU (interrupt controlling
 * unit, a.k.a. PIC or 82C59) is used, the IPL is not directly useful,
 * since the interrupt blocking is handled via interrupt masks instead
 * of levels.  However the IPL is easily used as an offset into arrays
 * of masks.
 */
#define IPLSHIFT 4	/* The upper nibble of vectors is the IPL.	*/
#define NIPL 16		/* Four bits of information gives as much.	*/
#define IPL(level) ((level) >> IPLSHIFT)	/* Extract the IPL.	*/
/* XXX Maybe this IDTVECOFF definition should be elsewhere? */
#define IDTVECOFF 0x20	/* The lower 32 IDT vectors are reserved.	*/

/*
 * This macro is only defined for 0 <= x < 14, i.e. there are fourteen
 * distinct priority levels available for interrupts.
 */
#define MAKEIPL(priority) (IDTVECOFF + ((priority) << IPLSHIFT))

/*
 * Interrupt priority levels.
 * XXX We are somewhat sloppy about what we mean by IPLs, sometimes
 * XXX we refer to the eight-bit value suitable for storing into APICs'
 * XXX priority registers, other times about the four-bit entity found
 * XXX in the former values' upper nibble, which can be used as offsets
 * XXX in various arrays of our implementation.  We are hoping that
 * XXX the context will provide enough information to not make this
 * XXX sloppy naming a real problem.
 */
#define	IPL_NONE	0		/* nothing */
#define	IPL_SOFTCLOCK	MAKEIPL(0)	/* timeouts */
#define	IPL_SOFTNET	MAKEIPL(1)	/* protocol stacks */
#define	IPL_BIO		MAKEIPL(2)	/* block I/O */
#define	IPL_NET		MAKEIPL(3)	/* network */
#define	IPL_SOFTTTY	MAKEIPL(4)	/* delayed terminal handling */
#define	IPL_TTY		MAKEIPL(5)	/* terminal */
#define	IPL_IMP		MAKEIPL(6)	/* memory allocation */
#define	IPL_AUDIO	MAKEIPL(7)	/* audio */
#define	IPL_CLOCK	MAKEIPL(8)	/* clock */
#define	IPL_HIGH	MAKEIPL(9)	/* everything */
d58 1
d60 1
d62 2
d67 1
a67 8
volatile int cpl;	/* Current interrupt priority level.		*/
volatile int ipending;	/* Interrupts pending.				*/
volatile int astpending;/* Asynchronous software traps (softints) pending. */
int imask[NIPL];	/* Bitmasks telling what interrupts are blocked. */
int iunmask[NIPL];	/* Bitmasks telling what interrupts are accepted. */

#define IMASK(level) imask[IPL(level)]
#define IUNMASK(level) iunmask[IPL(level)]
d77 1
a77 1
 * Raise current interrupt priority level, and return the old one.
d85 1
a85 2
	if (ncpl > ocpl)
		cpl = ncpl;
d90 1
a90 1
 * Restore an old interrupt priority level.  If any thereby unmasked
d97 1
d99 1
a99 1
	if (ipending & IUNMASK(ncpl))
d113 3
a115 1
	splx(ncpl);
d122 5
a126 5
#define	splbio()	splraise(IPL_BIO)
#define	splnet()	splraise(IPL_NET)
#define	spltty()	splraise(IPL_TTY)
#define	splaudio()	splraise(IPL_AUDIO)
#define	splclock()	splraise(IPL_CLOCK)
d135 4
a138 4
#define	spllowersoftclock()	spllower(IPL_SOFTCLOCK)
#define	splsoftclock()		splraise(IPL_SOFTCLOCK)
#define	splsoftnet()		splraise(IPL_SOFTNET)
#define	splsofttty()		splraise(IPL_SOFTTTY)
d143 4
a146 4
#define	splimp()	splraise(IPL_IMP)
#define	splvm()		splraise(IPL_IMP)
#define	splhigh()	splraise(IPL_HIGH)
#define	spl0()		spllower(IPL_NONE)
d157 1
@


1.7
log
@Define splvm() for arches who don't already provide it, with the same
definition as splimp().
art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.6 2000/08/05 22:07:31 niklas Exp $	*/
d36 48
a83 13
/* Interrupt priority `levels'; not mutually exclusive. */
#define	IPL_NONE	0	/* nothing */
#define	IPL_BIO		1	/* block I/O */
#define	IPL_NET		2	/* network */
#define	IPL_TTY		3	/* terminal */
#define	IPL_IMP		4	/* memory allocation */
#define	IPL_AUDIO	5	/* audio */
#define	IPL_CLOCK	6	/* clock */
#define	IPL_HIGH	7	/* everything */

#ifndef _LOCORE
int imask[IPL_HIGH+1];
#endif
a92 1
#define	SIR_CLOCKMASK	((1 << SIR_CLOCK))
a93 1
#define	SIR_NETMASK	((1 << SIR_NET) | SIR_CLOCKMASK)
a94 2
#define	SIR_TTYMASK	((1 << SIR_TTY) | SIR_CLOCKMASK)
#define	SIR_ALLMASK	(SIR_CLOCKMASK | SIR_NETMASK | SIR_TTYMASK)
d98 8
a105 1
volatile int cpl, ipending, astpending;
d115 1
a115 1
 * Add a mask to cpl, and return the old value of cpl.
d123 2
a124 1
	cpl = ocpl | ncpl;
d129 1
a129 1
 * Restore a value to cpl (unmasking interrupts).  If any unmasked
a135 1

d137 1
a137 1
	if (ipending & ~ncpl)
d151 1
a151 3
	cpl = ncpl;
	if (ipending & ~ncpl)
		Xspllower();
d158 5
a162 5
#define	splbio()	splraise(imask[IPL_BIO])
#define	splnet()	splraise(imask[IPL_NET])
#define	spltty()	splraise(imask[IPL_TTY])
#define	splaudio()	splraise(imask[IPL_AUDIO])
#define	splclock()	splraise(imask[IPL_CLOCK])
d171 4
a174 4
#define	spllowersoftclock()	spllower(SIR_CLOCKMASK)
#define	splsoftclock()		splraise(SIR_CLOCKMASK)
#define	splsoftnet()		splraise(SIR_NETMASK)
#define	splsofttty()		splraise(SIR_TTYMASK)
d179 4
a182 4
#define	splimp()	splraise(imask[IPL_IMP])
#define	splvm()		splraise(imask[IPL_IMP])
#define	splhigh()	splraise(imask[IPL_HIGH])
#define	spl0()		spllower(0)
a192 1

@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.5 1996/05/13 06:11:28 mycroft Exp $	*/
d144 1
@


1.5
log
@Change splsoftclock() to raise the spl, instead of lowering it.
Add spllowersoftclock() for the former behaviour. Update comment. (art@@ ok)
@
text
@d1 1
@


1.4
log
@

Some people don't have enough RAM in their PCs and expect swapping to
work.

Fix an array bounds problem with the imask[] array.
@
text
@d131 1
a131 1
 * NOTE: splsoftclock() is used by hardclock() to lower the priority from
d134 4
a137 3
#define	splsoftclock()	spllower(SIR_CLOCKMASK)
#define	splsoftnet()	splraise(SIR_NETMASK)
#define	splsofttty()	splraise(SIR_TTYMASK)
@


1.4.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@a0 1
/*	$OpenBSD: intr.h,v 1.6 2000/08/05 22:07:31 niklas Exp $	*/
d131 1
a131 1
 * NOTE: spllowersoftclock() is used by hardclock() to lower the priority from
d134 3
a136 4
#define	spllowersoftclock()	spllower(SIR_CLOCKMASK)
#define	splsoftclock()		splraise(SIR_CLOCKMASK)
#define	splsoftnet()		splraise(SIR_NETMASK)
#define	splsofttty()		splraise(SIR_TTYMASK)
@


1.4.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4.4.1 2001/04/18 16:07:33 niklas Exp $	*/
a143 1
#define	splvm()		splraise(imask[IPL_IMP])
@


1.4.4.3
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4.4.2 2001/07/04 10:16:47 niklas Exp $	*/
d46 4
d67 1
a67 17
#ifdef MULTIPROCESSOR
#include <machine/i82489reg.h>
#include <machine/i82489var.h>
#endif

extern volatile u_int32_t lapic_tpr;
volatile u_int32_t ipending;

#ifndef MULTIPROCESSOR
volatile u_int32_t astpending;
#endif

int imask[IPL_HIGH+1];
int iunmask[IPL_HIGH+1];

#define IMASK(level) imask[(level)]
#define IUNMASK(level) iunmask[(level)]
d74 1
a74 1
static __inline void softintr __P((int, int));
d83 1
a83 1
	register int ocpl = lapic_tpr;
d85 1
a85 2
	if (ncpl > ocpl)
		lapic_tpr = ncpl;
d97 3
a99 2
	lapic_tpr = ncpl;
	if (ipending & IUNMASK(ncpl))
d111 1
a111 1
	register int ocpl = lapic_tpr;
d113 2
a114 5
	splx(ncpl);

/* XXX - instead of splx() call above.
	lapic_tpr = ncpl;
	if (ipending & IUNMASK(ncpl))
a115 1
*/
d154 2
a155 3
softintr(sir, vec)
	register int sir;
	register int vec;
d157 2
a158 5
	__asm __volatile("orl %0,_ipending" : : "ir" (sir));
#ifdef MULTIPROCESSOR
	i82489_writereg(LAPIC_ICRLO,
	    vec | LAPIC_DLMODE_FIXED | LAPIC_LVL_ASSERT | LAPIC_DEST_SELF);
#endif
d162 3
a164 18
#define	setsoftclock()	softintr(1 << SIR_CLOCK,SIR_CLOCK)
#define	setsoftnet()	softintr(1 << SIR_NET,SIR_NET)
#define	setsofttty()	softintr(1 << SIR_TTY,SIR_TTY)

#define I386_IPI_HALT	0x00000001
#define I386_IPI_TLB	0x00000002
#define I386_IPI_FPSAVE	0x00000004

/* the following are for debugging.. */
#define I386_IPI_GMTB	0x00000010
#define I386_IPI_NYCHI	0x00000020

#define I386_NIPI	6

struct cpu_info;
void i386_send_ipi (struct cpu_info *, int);
void i386_broadcast_ipi (int);
void i386_ipi_handler (void);
@


1.4.4.4
log
@New interrupt and spl* system, mostly from NetBSD's i386 MP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 8
a44 13
#define	IPL_NONE	0x00			/* nothing */
#define	IPL_SOFTCLOCK	(NRSVIDT + 0x10)	/* timeouts */
#define	IPL_SOFTNET	(NRSVIDT + 0x20)	/* protocol stacks */
#define	IPL_BIO		(NRSVIDT + 0x30)	/* block I/O */
#define	IPL_NET		(NRSVIDT + 0x40)	/* network */
#define	IPL_SOFTTTY	(NRSVIDT + 0x50)	/* delayed terminal handling */
#define	IPL_TTY		(NRSVIDT + 0x60)	/* terminal */
#define	IPL_IMP		(NRSVIDT + 0x70)	/* memory allocation */
#define	IPL_AUDIO	(NRSVIDT + 0x80)	/* audio */
#define	IPL_CLOCK	(NRSVIDT + 0x90)	/* clock */
#define	IPL_HIGH	(NRSVIDT + 0xa0)	/* everything, except... */
#define	IPL_IPI		(NRSVIDT + 0xb0)	/* interprocessor interrupt */
#define NIPL		12
d75 2
a76 2
int imask[NIPL];
int iunmask[NIPL];
d78 2
a79 3
#define CPSHIFT 4
#define IMASK(level) imask[level >> CPSHIFT]
#define IUNMASK(level) iunmask[level >> CPSHIFT]
d138 5
a142 5
#define	splbio()	splraise(IPL_BIO)
#define	splnet()	splraise(IPL_NET)
#define	spltty()	splraise(IPL_TTY)
#define	splaudio()	splraise(IPL_AUDIO)
#define	splclock()	splraise(IPL_CLOCK)
d151 4
a154 4
#define	spllowersoftclock()	spllower(IPL_SOFTCLOCK)
#define	splsoftclock()		splraise(IPL_SOFTCLOCK)
#define	splsoftnet()		splraise(IPL_SOFTNET)
#define	splsofttty()		splraise(IPL_SOFTTTY)
d159 4
a162 4
#define	splimp()	splraise(IPL_IMP)
#define	splvm()		splraise(IPL_IMP)
#define	splhigh()	splraise(IPL_HIGH)
#define	spl0()		spllower(IPL_NONE)
d182 3
a184 3
#define	setsoftclock()	softintr(1 << SIR_CLOCK,IPL_CLOCK)
#define	setsoftnet()	softintr(1 << SIR_NET,IPL_NET)
#define	setsofttty()	softintr(1 << SIR_TTY,IPL_TTY)
@


1.4.4.5
log
@Soft interrupts should have the low IPLs assigned to them!
@
text
@d188 3
a190 3
#define	setsoftclock()	softintr(1 << SIR_CLOCK,IPL_SOFTCLOCK)
#define	setsoftnet()	softintr(1 << SIR_NET,IPL_SOFTNET)
#define	setsofttty()	softintr(1 << SIR_TTY,IPL_SOFTTTY)
@


1.4.4.6
log
@Oops, NIPL is the number of priority levels, not the number of levels actually used!
@
text
@d49 1
a49 1
#define NIPL		16
@


1.4.4.7
log
@Merge in -current
@
text
@d36 14
a49 49
/*
 * Intel APICs (advanced programmable interrupt controllers) have
 * bytesized priority registers where the upper nibble is the actual
 * interrupt priority level (a.k.a. IPL).  Interrupt vectors are
 * closely tied to these levels as interrupts whose vectors' upper
 * nibble is lower than or equal to the current level are blocked.
 * Not all 256 possible vectors are available for interrupts in
 * APIC systems, only
 *
 * For systems where instead the older ICU (interrupt controlling
 * unit, a.k.a. PIC or 82C59) is used, the IPL is not directly useful,
 * since the interrupt blocking is handled via interrupt masks instead
 * of levels.  However the IPL is easily used as an offset into arrays
 * of masks.
 */
#define IPLSHIFT 4	/* The upper nibble of vectors is the IPL.	*/
#define NIPL 16		/* Four bits of information gives as much.	*/
#define IPL(level) ((level) >> IPLSHIFT)	/* Extract the IPL.	*/
/* XXX Maybe this IDTVECOFF definition should be elsewhere? */
#define IDTVECOFF 0x20	/* The lower 32 IDT vectors are reserved.	*/

/*
 * This macro is only defined for 0 <= x < 14, i.e. there are fourteen
 * distinct priority levels available for interrupts.
 */
#define MAKEIPL(priority) (IDTVECOFF + ((priority) << IPLSHIFT))

/*
 * Interrupt priority levels.
 * XXX We are somewhat sloppy about what we mean by IPLs, sometimes
 * XXX we refer to the eight-bit value suitable for storing into APICs'
 * XXX priority registers, other times about the four-bit entity found
 * XXX in the former values' upper nibble, which can be used as offsets
 * XXX in various arrays of our implementation.  We are hoping that
 * XXX the context will provide enough information to not make this
 * XXX sloppy naming a real problem.
 */
#define	IPL_NONE	0		/* nothing */
#define	IPL_SOFTCLOCK	MAKEIPL(0)	/* timeouts */
#define	IPL_SOFTNET	MAKEIPL(1)	/* protocol stacks */
#define	IPL_BIO		MAKEIPL(2)	/* block I/O */
#define	IPL_NET		MAKEIPL(3)	/* network */
#define	IPL_SOFTTTY	MAKEIPL(4)	/* delayed terminal handling */
#define	IPL_TTY		MAKEIPL(5)	/* terminal */
#define	IPL_IMP		MAKEIPL(6)	/* memory allocation */
#define	IPL_AUDIO	MAKEIPL(7)	/* audio */
#define	IPL_CLOCK	MAKEIPL(8)	/* clock */
#define	IPL_HIGH	MAKEIPL(9)	/* everything */
#define	IPL_IPI		MAKEIPL(10)	/* interprocessor interrupt */
d59 1
d61 1
d63 2
d74 1
a75 2
volatile int cpl;	/* Current interrupt priority level.		*/
volatile u_int32_t ipending;/* Interrupts pending.			*/
d77 1
a77 1
volatile u_int32_t astpending;/* Async software traps (softints) pending. */
a78 2
int imask[NIPL];	/* Bitmasks telling what interrupts are blocked. */
int iunmask[NIPL];	/* Bitmasks telling what interrupts are accepted. */
d80 6
a85 2
#define IMASK(level) imask[IPL(level)]
#define IUNMASK(level) iunmask[IPL(level)]
d95 1
a95 1
 * Raise current interrupt priority level, and return the old one.
d109 1
a109 1
 * Restore an old interrupt priority level.  If any thereby unmasked
d188 3
a190 3
#define	setsoftclock()	softintr(1 << SIR_CLOCK, IPL_SOFTCLOCK)
#define	setsoftnet()	softintr(1 << SIR_NET, IPL_SOFTNET)
#define	setsofttty()	softintr(1 << SIR_TTY, IPL_SOFTTTY)
@


1.4.4.8
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4.4.7 2001/11/13 21:00:52 niklas Exp $	*/
@


1.4.4.9
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d121 1
a121 1
#define SPLX_DECL void splx __P((int));
d129 1
a129 1
	int ncpl;
d131 1
a131 1
	int ocpl = lapic_tpr;
a134 1
	__asm __volatile("");
d142 7
a148 9
#define SPLX_BODY							\
void									\
splx(ncpl)								\
	int ncpl;							\
{									\
	__asm __volatile("");						\
	lapic_tpr = ncpl;						\
	if (ipending & IUNMASK(ncpl))					\
		Xspllower();						\
a150 13
/* If SMALL_KERNEL make splx out of line, otherwise inline it.  */
#ifdef SMALL_KERNEL
#define SPLX_INLINED_BODY
#define SPLX_OUTLINED_BODY	SPLX_BODY
SPLX_DECL
#else
#define SPLX_INLINED_BODY	static __inline SPLX_BODY
#define SPLX_OUTLINED_BODY
static __inline SPLX_DECL
#endif

SPLX_INLINED_BODY

d157 1
a157 1
	int ncpl;
d159 1
a159 1
	int ocpl = lapic_tpr;
@


1.4.4.10
log
@Merge in -current from about a week ago
@
text
@d117 1
a117 1
extern void Xspllower(void);
d119 4
a122 4
static __inline int splraise(int);
static __inline int spllower(int);
#define SPLX_DECL void splx(int);
static __inline void softintr(int, int);
@


1.4.4.11
log
@Sync the SMP branch with 3.3
@
text
@d80 1
a80 2
#define	IPL_VM		MAKEIPL(6)	/* memory allocation */
#define IPL_IMP		IPL_VM		/* XXX - should not be here. */
a82 1
#define	IPL_STATCLOCK	MAKEIPL(9)	/* statclock */
a123 18
/* SPL asserts */
#ifdef DIAGNOSTIC
/*
 * Although this function is implemented in MI code, it must be in this MD
 * header because we don't want this header to include MI includes.
 */
void splassert_fail(int, int, const char *);
extern int splassert_ctl;
void splassert_check(int, const char *);
#define splassert(__wantipl) do {			\
	if (__predict_false(splassert_ctl > 0)) {	\
		splassert_check(__wantipl, __func__);	\
	}						\
} while (0)
#else
#define splassert(wantipl) do { /* nada */ } while (0)
#endif

d135 1
a135 1
	__asm __volatile("":::"memory");
d148 1
a148 1
	__asm __volatile("":::"memory");				\
d211 2
a212 2
#define	splvm()		splraise(IPL_VM)
#define splimp()	splvm()
@


1.4.4.12
log
@splipi() def
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4.4.11 2003/03/27 23:26:55 niklas Exp $	*/
a215 1
#define splipi()	splraise(IPL_IPI)
@


1.4.4.13
log
@fix i386_ipi_send return type
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4.4.12 2003/04/05 20:41:11 niklas Exp $	*/
d270 1
a270 1
int i386_send_ipi (struct cpu_info *, int);
@


1.4.4.14
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4.4.13 2003/04/06 14:04:33 niklas Exp $	*/
d247 1
a247 1
	__asm __volatile("orl %0,ipending" : : "ir" (sir));
@


1.4.4.15
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4.4.14 2003/05/13 19:42:08 ho Exp $	*/
a83 1
#define	IPL_SCHED	IPL_CLOCK
a103 1
#include <machine/cpu.h>
a234 1
#define	splsched()	splraise(IPL_SCHED)
d270 3
a272 17

#ifdef MULTIPROCESSOR
int i386_send_ipi(struct cpu_info *, int);
void i386_broadcast_ipi(int);
void i386_multicast_ipi(int, int);
void i386_ipi_handler(void);
void i386_intlock(struct intrframe);
void i386_intunlock(struct intrframe);
void i386_softintlock(void);
void i386_softintunlock(void);

#ifdef notyet
extern void (*ipifunc[I386_NIPI])(struct cpu_info *);
#else
extern void (*ipifunc[I386_NIPI])(void);
#endif
#endif
@


1.4.4.16
log
@provide spllock for lockmgr
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4.4.15 2003/05/15 04:08:02 niklas Exp $	*/
a237 1
#define spllock() 	splhigh()
@


1.4.4.17
log
@Some i386-specific stuff:
Stop other CPUs when entering ddb
'machine sysregs' shows system registers not usually used by applications
'machine cpuinfo' shows the status of the processors
'machine startcpu n' starts CPU n
'machine stopcpu n' stops CPU n
'machine ddbcpu n' transfers ddb control to CPU n (not very useful yet
though since the second processor can't use the keyboard...)

Niklas said that I should test this first to at least make sure it
compiles, but I'm too anxious to do my first commit. :)
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4.4.16 2003/05/15 17:46:30 niklas Exp $	*/
d271 1
a271 3
#define I386_IPI_DDB	0x00000040	/* syncronize while in ddb */

#define I386_NIPI	7
@


1.4.4.18
log
@Fix splassert in the SMP branch. Remove the old 'cpl' variable. While here,
remove a bunch of commons from intr.h. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4.4.17 2003/05/17 16:07:37 andreas Exp $	*/
d108 1
a108 1
extern volatile u_int32_t lapic_tpr;	/* Current interrupt priority level. */
d110 2
a111 1
extern volatile u_int32_t ipending;	/* Interrupts pending. */
d113 1
a113 1
extern volatile u_int32_t astpending;	/* Async software traps (softints) pending. */
d115 2
a116 2
extern int imask[];	/* Bitmasks telling what interrupts are blocked. */
extern int iunmask[];	/* Bitmasks telling what interrupts are accepted. */
d200 6
@


1.4.4.19
log
@Import NetBSD updates to NPX logic, and IPI API
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d256 3
a258 8
#define I386_IPI_HALT		0x00000001
#define I386_IPI_MICROSET	0x00000002
#define I386_IPI_FLUSH_FPU	0x00000004
#define I386_IPI_SYNCH_FPU	0x00000008
#define I386_IPI_TLB		0x00000010
#define I386_IPI_MTRR		0x00000020
#define I386_IPI_GDT		0x00000040
#define I386_IPI_DDB		0x00000080	/* synchronize while in ddb */
d260 7
a266 1
#define I386_NIPI	8
d280 1
d282 3
@


1.4.4.20
log
@move out constant defs to its own header a la NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: intr.h,v 1.4.4.19 2004/02/20 22:19:55 niklas Exp $	*/
d36 63
a98 1
#include <machine/intrdefs.h>
@


1.4.4.21
log
@spl outlining
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 4
a63 4
extern int splraise(int);
extern int spllower(int);
extern void splx(int);
extern void softintr(int, int);
d84 57
d171 17
@


1.4.4.22
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d49 3
@


1.3
log
@From NetBSD; let i386 run audio at a high IPL
@
text
@d45 4
a66 1
int imask[7];
@


1.2
log
@splstatclock to splhigh; problem pointed out by gopal
@
text
@d36 4
a39 4
#define	IPL_BIO		0	/* block I/O */
#define	IPL_NET		1	/* network */
#define	IPL_TTY		2	/* terminal */
#define	IPL_CLOCK	3	/* clock */
d41 3
a43 2
#define	IPL_NONE	5	/* nothing */
#define	IPL_HIGH	6	/* everything */
d121 1
a122 1
#define	splimp()	splraise(imask[IPL_IMP])
d138 2
a139 1
#define	splhigh()	splraise(-1)
@


1.1
log
@sync
@
text
@d122 1
a122 1
#define	splstatclock()	splclock()
@
