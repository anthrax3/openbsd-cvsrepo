head	1.155;
access;
symbols
	OPENBSD_6_1_BASE:1.155
	OPENBSD_6_0:1.147.0.2
	OPENBSD_6_0_BASE:1.147
	OPENBSD_5_9:1.145.0.2
	OPENBSD_5_9_BASE:1.145
	OPENBSD_5_8:1.144.0.4
	OPENBSD_5_8_BASE:1.144
	OPENBSD_5_7:1.137.0.2
	OPENBSD_5_7_BASE:1.137
	OPENBSD_5_6:1.134.0.4
	OPENBSD_5_6_BASE:1.134
	OPENBSD_5_5:1.132.0.4
	OPENBSD_5_5_BASE:1.132
	OPENBSD_5_4:1.130.0.2
	OPENBSD_5_4_BASE:1.130
	OPENBSD_5_3:1.127.0.2
	OPENBSD_5_3_BASE:1.127
	OPENBSD_5_2:1.122.0.2
	OPENBSD_5_2_BASE:1.122
	OPENBSD_5_1_BASE:1.121
	OPENBSD_5_1:1.121.0.2
	OPENBSD_5_0:1.120.0.2
	OPENBSD_5_0_BASE:1.120
	OPENBSD_4_9:1.117.0.2
	OPENBSD_4_9_BASE:1.117
	OPENBSD_4_8:1.113.0.2
	OPENBSD_4_8_BASE:1.113
	OPENBSD_4_7:1.109.0.2
	OPENBSD_4_7_BASE:1.109
	OPENBSD_4_6:1.108.0.4
	OPENBSD_4_6_BASE:1.108
	OPENBSD_4_5:1.107.0.2
	OPENBSD_4_5_BASE:1.107
	OPENBSD_4_4:1.103.0.2
	OPENBSD_4_4_BASE:1.103
	OPENBSD_4_3:1.99.0.2
	OPENBSD_4_3_BASE:1.99
	OPENBSD_4_2:1.95.0.2
	OPENBSD_4_2_BASE:1.95
	OPENBSD_4_1:1.87.0.2
	OPENBSD_4_1_BASE:1.87
	OPENBSD_4_0:1.80.0.2
	OPENBSD_4_0_BASE:1.80
	OPENBSD_3_9:1.74.0.2
	OPENBSD_3_9_BASE:1.74
	OPENBSD_3_8:1.68.0.2
	OPENBSD_3_8_BASE:1.68
	OPENBSD_3_7:1.67.0.4
	OPENBSD_3_7_BASE:1.67
	OPENBSD_3_6:1.67.0.2
	OPENBSD_3_6_BASE:1.67
	SMP_SYNC_A:1.60
	SMP_SYNC_B:1.60
	OPENBSD_3_5:1.58.0.2
	OPENBSD_3_5_BASE:1.58
	OPENBSD_3_4:1.51.0.2
	OPENBSD_3_4_BASE:1.51
	UBC_SYNC_A:1.47
	OPENBSD_3_3:1.45.0.2
	OPENBSD_3_3_BASE:1.45
	OPENBSD_3_2:1.43.0.2
	OPENBSD_3_2_BASE:1.43
	OPENBSD_3_1:1.41.0.2
	OPENBSD_3_1_BASE:1.41
	UBC_SYNC_B:1.43
	UBC:1.40.0.2
	UBC_BASE:1.40
	OPENBSD_3_0:1.38.0.2
	OPENBSD_3_0_BASE:1.38
	OPENBSD_2_9:1.34.0.2
	OPENBSD_2_9_BASE:1.34
	OPENBSD_2_8:1.31.0.2
	OPENBSD_2_8_BASE:1.31
	OPENBSD_2_7:1.29.0.4
	OPENBSD_2_7_BASE:1.29
	SMP:1.29.0.2
	SMP_BASE:1.29
	kame_19991208:1.28
	OPENBSD_2_6:1.28.0.2
	OPENBSD_2_6_BASE:1.28
	OPENBSD_2_5:1.26.0.2
	OPENBSD_2_5_BASE:1.26
	OPENBSD_2_4:1.24.0.2
	OPENBSD_2_4_BASE:1.24
	OPENBSD_2_3:1.21.0.2
	OPENBSD_2_3_BASE:1.21
	OPENBSD_2_2:1.17.0.2
	OPENBSD_2_2_BASE:1.17
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.155
date	2017.03.16.10.02.03;	author mpi;	state Exp;
branches;
next	1.154;
commitid	rweVgzyW1Z54hiV5;

1.154
date	2017.03.11.11.55.03;	author mpi;	state Exp;
branches;
next	1.153;
commitid	eXDj5wwfsbdFBB4L;

1.153
date	2017.03.02.10.38.10;	author natano;	state Exp;
branches;
next	1.152;
commitid	EeVoCYFCx2tYicZQ;

1.152
date	2017.02.06.09.13.41;	author mpi;	state Exp;
branches;
next	1.151;
commitid	wTgEeyM3ktFNF2jh;

1.151
date	2017.01.03.09.48.15;	author mlarkin;	state Exp;
branches;
next	1.150;
commitid	rOPSd8O2Di7WnNkY;

1.150
date	2016.10.21.06.20.58;	author mlarkin;	state Exp;
branches;
next	1.149;
commitid	szRuKZ9HgqvwYLcM;

1.149
date	2016.10.14.04.53.26;	author mlarkin;	state Exp;
branches;
next	1.148;
commitid	HlziCr2juunzjZBF;

1.148
date	2016.07.28.21.57.57;	author kettenis;	state Exp;
branches;
next	1.147;
commitid	h0GHFDGWnEdswfbK;

1.147
date	2016.03.15.03.17.51;	author guenther;	state Exp;
branches;
next	1.146;
commitid	hTA8iQcFPhTNwQXL;

1.146
date	2016.03.03.12.41.30;	author naddy;	state Exp;
branches;
next	1.145;
commitid	Ykztt9UU7jxBEqeD;

1.145
date	2015.12.07.06.34.14;	author jsg;	state Exp;
branches;
next	1.144;
commitid	SlCrK8YSV6f5HTmS;

1.144
date	2015.07.13.17.45.01;	author mikeb;	state Exp;
branches;
next	1.143;
commitid	zrjFB8VvK0ekXjjA;

1.143
date	2015.07.02.01.33.59;	author dlg;	state Exp;
branches;
next	1.142;
commitid	HBmwORlhlW47BLMN;

1.142
date	2015.06.13.21.41.42;	author guenther;	state Exp;
branches;
next	1.141;
commitid	niRu91s4TwItA66c;

1.141
date	2015.06.07.06.24.59;	author guenther;	state Exp;
branches;
next	1.140;
commitid	TPuT1ptKkvRzlUfp;

1.140
date	2015.05.28.20.10.58;	author guenther;	state Exp;
branches;
next	1.139;
commitid	nRKEXgw8UCVd37E0;

1.139
date	2015.04.18.22.16.21;	author kettenis;	state Exp;
branches;
next	1.138;
commitid	yRnPx9jjsPnb6oP6;

1.138
date	2015.04.12.18.37.54;	author mlarkin;	state Exp;
branches;
next	1.137;
commitid	5ST94uMTezmXYdhY;

1.137
date	2014.12.16.21.40.05;	author tedu;	state Exp;
branches;
next	1.136;
commitid	jcOSmQbbYkvaksK2;

1.136
date	2014.12.02.18.13.10;	author tedu;	state Exp;
branches;
next	1.135;
commitid	ZYUxNRICiD9sC1vn;

1.135
date	2014.09.12.09.52.45;	author kettenis;	state Exp;
branches;
next	1.134;
commitid	fg3shv1MuGeLLh3b;

1.134
date	2014.07.11.10.53.07;	author uebayasi;	state Exp;
branches;
next	1.133;
commitid	CaCLs5fTSVpJlqFi;

1.133
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.132;

1.132
date	2014.02.13.23.11.06;	author kettenis;	state Exp;
branches;
next	1.131;

1.131
date	2013.10.09.01.48.41;	author guenther;	state Exp;
branches;
next	1.130;

1.130
date	2013.05.31.17.00.58;	author tedu;	state Exp;
branches;
next	1.129;

1.129
date	2013.03.31.17.07.03;	author deraadt;	state Exp;
branches;
next	1.128;

1.128
date	2013.03.12.09.37.16;	author mpi;	state Exp;
branches;
next	1.127;

1.127
date	2013.02.12.08.06.22;	author mpi;	state Exp;
branches;
next	1.126;

1.126
date	2013.02.11.17.05.25;	author mpi;	state Exp;
branches;
next	1.125;

1.125
date	2012.12.02.07.03.31;	author guenther;	state Exp;
branches;
next	1.124;

1.124
date	2012.11.10.09.45.05;	author mglocker;	state Exp;
branches;
next	1.123;

1.123
date	2012.10.09.04.40.36;	author jsg;	state Exp;
branches;
next	1.122;

1.122
date	2012.03.27.06.44.01;	author jsg;	state Exp;
branches;
next	1.121;

1.121
date	2011.11.02.23.53.44;	author jsg;	state Exp;
branches;
next	1.120;

1.120
date	2011.05.23.09.54.20;	author claudio;	state Exp;
branches;
next	1.119;

1.119
date	2011.04.22.15.48.43;	author kettenis;	state Exp;
branches;
next	1.118;

1.118
date	2011.03.23.16.54.35;	author pirofti;	state Exp;
branches;
next	1.117;

1.117
date	2010.10.02.23.13.28;	author deraadt;	state Exp;
branches;
next	1.116;

1.116
date	2010.09.28.20.27.54;	author miod;	state Exp;
branches;
next	1.115;

1.115
date	2010.09.24.13.21.30;	author matthew;	state Exp;
branches;
next	1.114;

1.114
date	2010.08.11.21.22.44;	author kettenis;	state Exp;
branches;
next	1.113;

1.113
date	2010.08.05.21.10.09;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2010.07.25.21.43.37;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2010.07.21.14.08.09;	author kettenis;	state Exp;
branches;
next	1.110;

1.110
date	2010.05.23.22.41.49;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2009.12.09.14.27.34;	author oga;	state Exp;
branches;
next	1.108;

1.108
date	2009.06.03.00.49.12;	author art;	state Exp;
branches;
next	1.107;

1.107
date	2009.02.16.15.44.25;	author jsg;	state Exp;
branches;
next	1.106;

1.106
date	2008.11.22.18.12.32;	author art;	state Exp;
branches;
next	1.105;

1.105
date	2008.10.15.23.23.47;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2008.09.28.20.32.17;	author brad;	state Exp;
branches;
next	1.103;

1.103
date	2008.07.18.23.43.31;	author art;	state Exp;
branches;
next	1.102;

1.102
date	2008.06.09.20.43.43;	author miod;	state Exp;
branches;
next	1.101;

1.101
date	2008.04.18.20.20.35;	author kettenis;	state Exp;
branches;
next	1.100;

1.100
date	2008.04.13.11.35.55;	author thib;	state Exp;
branches;
next	1.99;

1.99
date	2007.11.28.17.05.09;	author tedu;	state Exp;
branches;
next	1.98;

1.98
date	2007.11.16.16.16.06;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2007.11.03.03.37.08;	author weingart;	state Exp;
branches;
next	1.96;

1.96
date	2007.09.07.08.37.38;	author art;	state Exp;
branches;
next	1.95;

1.95
date	2007.06.07.11.20.58;	author dim;	state Exp;
branches;
next	1.94;

1.94
date	2007.05.29.21.01.56;	author tedu;	state Exp;
branches;
next	1.93;

1.93
date	2007.05.26.22.09.17;	author weingart;	state Exp;
branches;
next	1.92;

1.92
date	2007.04.21.21.06.15;	author gwk;	state Exp;
branches;
next	1.91;

1.91
date	2007.04.12.20.22.58;	author art;	state Exp;
branches;
next	1.90;

1.90
date	2007.04.03.10.14.47;	author art;	state Exp;
branches;
next	1.89;

1.89
date	2007.03.19.09.29.33;	author art;	state Exp;
branches;
next	1.88;

1.88
date	2007.03.15.10.22.29;	author art;	state Exp;
branches;
next	1.87;

1.87
date	2007.02.20.21.15.01;	author tom;	state Exp;
branches;
next	1.86;

1.86
date	2006.12.24.20.30.35;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2006.12.20.17.50.40;	author gwk;	state Exp;
branches;
next	1.84;

1.84
date	2006.12.12.23.14.27;	author dim;	state Exp;
branches;
next	1.83;

1.83
date	2006.11.29.20.03.20;	author dim;	state Exp;
branches;
next	1.82;

1.82
date	2006.11.29.12.26.13;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2006.11.26.15.13.21;	author dim;	state Exp;
branches;
next	1.80;

1.80
date	2006.07.25.19.16.51;	author kettenis;	state Exp;
branches;
next	1.79;

1.79
date	2006.06.12.13.18.18;	author dim;	state Exp;
branches;
next	1.78;

1.78
date	2006.05.29.09.54.20;	author mickey;	state Exp;
branches;
next	1.77;

1.77
date	2006.05.19.19.43.41;	author dim;	state Exp;
branches;
next	1.76;

1.76
date	2006.05.09.09.38.35;	author otto;	state Exp;
branches;
next	1.75;

1.75
date	2006.04.27.15.37.53;	author mickey;	state Exp;
branches;
next	1.74;

1.74
date	2006.01.12.22.39.21;	author weingart;	state Exp;
branches;
next	1.73;

1.73
date	2005.11.04.06.55.36;	author tedu;	state Exp;
branches;
next	1.72;

1.72
date	2005.10.28.07.03.41;	author tedu;	state Exp;
branches;
next	1.71;

1.71
date	2005.09.25.20.48.23;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2005.09.20.23.00.34;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2005.09.20.21.04.15;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2005.05.27.10.41.11;	author kjell;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2004.08.05.03.07.47;	author dlg;	state Exp;
branches
	1.67.4.1;
next	1.66;

1.66
date	2004.07.14.05.34.14;	author tedu;	state Exp;
branches;
next	1.65;

1.65
date	2004.06.25.08.41.19;	author art;	state Exp;
branches;
next	1.64;

1.64
date	2004.06.21.23.12.14;	author art;	state Exp;
branches;
next	1.63;

1.63
date	2004.06.20.08.25.30;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2004.06.20.06.47.31;	author art;	state Exp;
branches;
next	1.61;

1.61
date	2004.06.13.21.49.16;	author niklas;	state Exp;
branches;
next	1.60;

1.60
date	2004.06.06.17.34.37;	author grange;	state Exp;
branches;
next	1.59;

1.59
date	2004.04.02.22.28.41;	author tedu;	state Exp;
branches;
next	1.58;

1.58
date	2004.02.14.15.09.22;	author grange;	state Exp;
branches;
next	1.57;

1.57
date	2004.02.01.19.05.23;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2004.02.01.12.26.45;	author grange;	state Exp;
branches;
next	1.55;

1.55
date	2004.01.06.21.09.20;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2003.12.20.18.23.18;	author tedu;	state Exp;
branches;
next	1.53;

1.53
date	2003.12.19.22.42.13;	author tedu;	state Exp;
branches;
next	1.52;

1.52
date	2003.12.18.23.46.19;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2003.07.28.21.15.28;	author jason;	state Exp;
branches;
next	1.50;

1.50
date	2003.07.07.03.07.18;	author tedu;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.02.23.27.47;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2003.05.27.23.52.01;	author fgsch;	state Exp;
branches;
next	1.47;

1.47
date	2003.05.14.22.08.04;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2003.03.28.00.49.13;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2003.01.16.04.16.00;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2003.01.09.22.27.09;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2002.09.24.00.06.23;	author nordin;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.07.21.33.43;	author nordin;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2001.12.08.02.24.06;	author art;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2001.11.06.18.41.09;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2001.07.13.19.55.41;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.21.12.57.43;	author niklas;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.05.22.33.48;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2001.04.30.13.23.11;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2001.02.19.04.57.02;	author ho;	state Exp;
branches;
next	1.33;

1.33
date	2001.01.25.18.49.34;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2001.01.05.04.27.24;	author marc;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.02.14.09.59;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2000.06.05.12.43.30;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2000.01.29.04.27.48;	author mickey;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	99.09.12.19.44.04;	author weingart;	state Exp;
branches;
next	1.27;

1.27
date	99.07.06.07.59.54;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	99.03.08.23.47.25;	author downsj;	state Exp;
branches;
next	1.25;

1.25
date	99.02.23.04.10.12;	author marc;	state Exp;
branches;
next	1.24;

1.24
date	98.08.30.07.31.32;	author downsj;	state Exp;
branches;
next	1.23;

1.23
date	98.06.04.05.01.45;	author downsj;	state Exp;
branches;
next	1.22;

1.22
date	98.05.25.06.52.36;	author downsj;	state Exp;
branches;
next	1.21;

1.21
date	98.03.01.00.37.33;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	98.02.17.23.49.31;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	97.12.17.08.54.51;	author downsj;	state Exp;
branches;
next	1.18;

1.18
date	97.12.09.03.36.41;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.10.25.21.47.27;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	97.10.25.08.36.42;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	97.09.27.06.31.32;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	97.09.21.23.00.43;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	97.09.21.04.27.58;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.04.20.20.55.01;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	96.10.17.19.17.15;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.10.16.12.27.16;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.08.27.10.46.53;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	96.08.08.18.47.05;	author dm;	state Exp;
branches;
next	1.7;

1.7
date	96.05.10.12.45.18;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.07.07.22.05;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.16.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.17.05.19.02;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.25.23.03.15;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.26.20.30.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.34;	author deraadt;	state Exp;
branches;
next	;

1.29.2.1
date	2001.04.18.16.07.29;	author niklas;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2001.07.04.10.16.46;	author niklas;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2001.07.14.10.02.35;	author ho;	state Exp;
branches;
next	1.29.2.4;

1.29.2.4
date	2001.07.16.21.40.38;	author niklas;	state Exp;
branches;
next	1.29.2.5;

1.29.2.5
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.29.2.6;

1.29.2.6
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.29.2.7;

1.29.2.7
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.29.2.8;

1.29.2.8
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.29.2.9;

1.29.2.9
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.29.2.10;

1.29.2.10
date	2003.04.11.16.12.57;	author niklas;	state Exp;
branches;
next	1.29.2.11;

1.29.2.11
date	2003.05.13.19.42.08;	author ho;	state Exp;
branches;
next	1.29.2.12;

1.29.2.12
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.29.2.13;

1.29.2.13
date	2003.05.16.00.29.39;	author niklas;	state Exp;
branches;
next	1.29.2.14;

1.29.2.14
date	2003.05.17.16.07.37;	author andreas;	state Exp;
branches;
next	1.29.2.15;

1.29.2.15
date	2003.05.18.17.41.16;	author niklas;	state Exp;
branches;
next	1.29.2.16;

1.29.2.16
date	2003.06.07.11.11.37;	author ho;	state Exp;
branches;
next	1.29.2.17;

1.29.2.17
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	1.29.2.18;

1.29.2.18
date	2004.02.20.22.19.55;	author niklas;	state Exp;
branches;
next	1.29.2.19;

1.29.2.19
date	2004.02.21.02.48.01;	author niklas;	state Exp;
branches;
next	1.29.2.20;

1.29.2.20
date	2004.03.14.22.08.21;	author niklas;	state Exp;
branches;
next	1.29.2.21;

1.29.2.21
date	2004.03.18.02.09.28;	author niklas;	state Exp;
branches;
next	1.29.2.22;

1.29.2.22
date	2004.03.30.09.09.40;	author niklas;	state Exp;
branches;
next	1.29.2.23;

1.29.2.23
date	2004.06.05.17.19.54;	author niklas;	state Exp;
branches;
next	1.29.2.24;

1.29.2.24
date	2004.06.05.23.09.00;	author niklas;	state Exp;
branches;
next	1.29.2.25;

1.29.2.25
date	2004.06.06.18.43.16;	author grange;	state Exp;
branches;
next	1.29.2.26;

1.29.2.26
date	2004.06.07.20.27.12;	author art;	state Exp;
branches;
next	1.29.2.27;

1.29.2.27
date	2004.06.07.20.41.10;	author niklas;	state Exp;
branches;
next	1.29.2.28;

1.29.2.28
date	2004.06.08.20.17.09;	author drahn;	state Exp;
branches;
next	1.29.2.29;

1.29.2.29
date	2004.06.10.11.40.25;	author niklas;	state Exp;
branches;
next	1.29.2.30;

1.29.2.30
date	2004.06.13.18.46.04;	author art;	state Exp;
branches;
next	;

1.40.2.1
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2002.10.29.00.28.04;	author art;	state Exp;
branches;
next	1.40.2.3;

1.40.2.3
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;

1.67.4.1
date	2006.01.13.00.49.21;	author brad;	state Exp;
branches;
next	;

1.68.2.1
date	2006.01.13.01.56.55;	author brad;	state Exp;
branches;
next	;


desc
@@


1.155
log
@Typo, from miod@@
@
text
@/*	$OpenBSD: cpu.h,v 1.154 2017/03/11 11:55:03 mpi Exp $	*/
/*	$NetBSD: cpu.h,v 1.35 1996/05/05 19:29:26 christos Exp $	*/

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)cpu.h	5.4 (Berkeley) 5/9/91
 */

#ifndef _MACHINE_CPU_H_
#define _MACHINE_CPU_H_

/*
 * Definitions unique to i386 cpu support.
 */
#ifdef _KERNEL
#include <machine/frame.h>
#include <machine/psl.h>
#include <machine/segments.h>
#include <machine/intrdefs.h>

#ifdef MULTIPROCESSOR
#include <machine/i82489reg.h>
#include <machine/i82489var.h>
#endif

#endif /* _KERNEL */

/*
 * Arguments to hardclock, softclock and statclock
 * encapsulate the previous machine state in an opaque
 * clockframe; for now, use generic intrframe.
 *
 * XXX intrframe has a lot of gunk we don't need.
 */
#define clockframe intrframe

#include <sys/device.h>
#include <sys/sched.h>
#include <sys/sensors.h>

struct intrsource;

/* VMXON region (Intel) */
struct vmxon_region {
	uint32_t	vr_revision;
};

/*
 * VMX for Intel CPUs
 */
struct vmx {
	uint64_t	vmx_cr0_fixed0;
	uint64_t	vmx_cr0_fixed1;
	uint64_t	vmx_cr4_fixed0;
	uint64_t	vmx_cr4_fixed1;
	uint32_t	vmx_vmxon_revision;
	uint32_t	vmx_msr_table_size;
	uint32_t	vmx_cr3_tgt_count;
	uint64_t	vmx_vm_func;
};

/*
 * SVM for AMD CPUs
 */
struct svm {
};

union vmm_cpu_cap {
	struct vmx vcc_vmx;
	struct svm vcc_svm;
};

#ifdef _KERNEL
/* XXX stuff to move to cpuvar.h later */
struct cpu_info {
	struct device ci_dev;		/* our device */
	struct cpu_info *ci_self;	/* pointer to this structure */
	struct schedstate_percpu ci_schedstate; /* scheduler state */
	struct cpu_info *ci_next;	/* next cpu */

	/* 
	 * Public members. 
	 */
	struct proc *ci_curproc; 	/* current owner of the processor */
	cpuid_t ci_cpuid; 		/* our CPU ID */
	u_int ci_apicid;		/* our APIC ID */
	u_int ci_acpi_proc_id;
	u_int32_t ci_randseed;

#if defined(MULTIPROCESSOR)
	struct srp_hazard ci_srp_hazards[SRP_HAZARD_NUM];
#endif

	/*
	 * Private members.
	 */
	struct proc *ci_fpcurproc;	/* current owner of the FPU */
	struct proc *ci_fpsaveproc;
	int ci_fpsaving;		/* save in progress */

	struct pcb *ci_curpcb;		/* VA of current HW PCB */
	struct pcb *ci_idle_pcb;	/* VA of current PCB */
	int ci_idle_tss_sel;		/* TSS selector of idle PCB */
	struct pmap *ci_curpmap;

	struct intrsource *ci_isources[MAX_INTR_SOURCES];
	u_int32_t	ci_ipending;
	int		ci_ilevel;
	int		ci_idepth;
	u_int32_t	ci_imask[NIPL];
	u_int32_t	ci_iunmask[NIPL];
#ifdef DIAGNOSTIC
	int		ci_mutex_level;
#endif

	paddr_t		ci_idle_pcb_paddr; /* PA of idle PCB */
	volatile u_long	ci_flags;	/* flags; see below */
	u_int32_t	ci_ipis; 	/* interprocessor interrupts pending */

	u_int32_t	ci_level;
	u_int32_t	ci_vendor[4];
	u_int32_t	ci_signature;		/* X86 cpuid type */
	u_int32_t	ci_family;		/* extended cpuid family */
	u_int32_t	ci_model;		/* extended cpuid model */
	u_int32_t	ci_feature_flags;	/* X86 CPUID feature bits */
	u_int32_t	ci_feature_sefflags_ebx;/* more CPUID feature bits */
	u_int32_t	ci_feature_sefflags_ecx;/* more CPUID feature bits */
	u_int32_t	ci_feature_tpmflags;	/* thermal & power bits */
	u_int32_t	cpu_class;		/* CPU class */
	u_int32_t	ci_cflushsz;		/* clflush cache-line size */
	u_int32_t	ci_amdcacheinfo[4];	/* AMD cache info */
	u_int32_t	ci_extcacheinfo[4];	/* Intel cache info */

	int		ci_inatomic;

	struct cpu_functions *ci_func;	/* start/stop functions */
	void (*cpu_setup)(struct cpu_info *);	/* proc-dependant init */

	struct device	*ci_acpicpudev;
	volatile u_int	ci_mwait;
#define	MWAIT_IN_IDLE		0x1	/* don't need IPI to wake */
#define	MWAIT_KEEP_IDLING	0x2	/* cleared by other cpus to wake me */
#define	MWAIT_ONLY		0x4	/* set if all idle states use mwait */
#define	MWAIT_IDLING		(MWAIT_IN_IDLE | MWAIT_KEEP_IDLING)

	int		ci_want_resched;

	union descriptor *ci_gdt;

	volatile int ci_ddb_paused;	/* paused due to other proc in ddb */
#define CI_DDB_RUNNING		0
#define CI_DDB_SHOULDSTOP	1
#define CI_DDB_STOPPED		2
#define CI_DDB_ENTERDDB		3
#define CI_DDB_INDDB		4

	struct ksensordev	ci_sensordev;
	struct ksensor		ci_sensor;
#if defined(GPROF) || defined(DDBPROF)
	struct gmonparam	*ci_gmon;
#endif
	u_int32_t		ci_vmm_flags;
#define CI_VMM_VMX		(1 << 0)
#define CI_VMM_SVM		(1 << 1)
#define CI_VMM_RVI		(1 << 2)
#define CI_VMM_EPT		(1 << 3)
#define CI_VMM_DIS		(1 << 4)
	union vmm_cpu_cap	ci_vmm_cap;
	uint64_t		ci_vmxon_region_pa; /* Must be 64 bit */
	struct vmxon_region	*ci_vmxon_region;
};

/*
 * Processor flag notes: The "primary" CPU has certain MI-defined
 * roles (mostly relating to hardclock handling); we distinguish
 * betwen the processor which booted us, and the processor currently
 * holding the "primary" role just to give us the flexibility later to
 * change primaries should we be sufficiently twisted.  
 */

#define	CPUF_BSP	0x0001		/* CPU is the original BSP */
#define	CPUF_AP		0x0002		/* CPU is an AP */
#define	CPUF_SP		0x0004		/* CPU is only processor */
#define	CPUF_PRIMARY	0x0008		/* CPU is active primary processor */
#define	CPUF_APIC_CD	0x0010		/* CPU has apic configured */
#define	CPUF_CONST_TSC	0x0020		/* CPU has constant TSC */

#define	CPUF_PRESENT	0x1000		/* CPU is present */
#define	CPUF_RUNNING	0x2000		/* CPU is running */
#define CPUF_VMM	0x4000		/* CPU is executing in VMM mode */

/*
 * We statically allocate the CPU info for the primary CPU (or,
 * the only CPU on uniprocessors), and the primary CPU is the
 * first CPU on the CPU info list.
 */
extern struct cpu_info cpu_info_primary;
extern struct cpu_info *cpu_info_list;

#define	CPU_INFO_ITERATOR		int
#define	CPU_INFO_FOREACH(cii, ci)	for (cii = 0, ci = cpu_info_list; \
					    ci != NULL; ci = ci->ci_next)

#define CPU_INFO_UNIT(ci)	((ci)->ci_dev.dv_unit)

#ifdef MULTIPROCESSOR

#define MAXCPUS			32	/* because we use a bitmask */

#define CPU_STARTUP(_ci)	((_ci)->ci_func->start(_ci))
#define CPU_STOP(_ci)		((_ci)->ci_func->stop(_ci))
#define CPU_START_CLEANUP(_ci)	((_ci)->ci_func->cleanup(_ci))

static struct cpu_info *curcpu(void);

__inline static struct cpu_info *
curcpu(void)
{
	struct cpu_info *ci;

	/* Can't include sys/param.h for offsetof() since it includes us */
	__asm volatile("movl %%fs:%1, %0" :
		"=r" (ci) : "m"
		(*(struct cpu_info * const *)&((struct cpu_info *)0)->ci_self));
	return ci;
}
#define cpu_number() 		(curcpu()->ci_cpuid)

#define CPU_IS_PRIMARY(ci)	((ci)->ci_flags & CPUF_PRIMARY)

extern struct cpu_info	*cpu_info[MAXCPUS];

extern void cpu_boot_secondary_processors(void);
extern void cpu_init_idle_pcbs(void);

void cpu_kick(struct cpu_info *);
void cpu_unidle(struct cpu_info *);

#define CPU_BUSY_CYCLE()	__asm volatile("pause": : : "memory")

#else /* MULTIPROCESSOR */

#define MAXCPUS			1

#define cpu_number()		0
#define	curcpu()		(&cpu_info_primary)

#define CPU_IS_PRIMARY(ci)	1

#define cpu_kick(ci)
#define cpu_unidle(ci)

#define CPU_BUSY_CYCLE()	do {} while (0)

#endif

#define aston(p)	((p)->p_md.md_astpending = 1)

#define curpcb			curcpu()->ci_curpcb

#define want_resched (curcpu()->ci_want_resched)

/*
 * Preempt the current process if in interrupt from user mode,
 * or after the current trap/syscall if in system mode.
 */
extern void need_resched(struct cpu_info *);
#define clear_resched(ci) (ci)->ci_want_resched = 0

#define	CLKF_USERMODE(frame)	USERMODE((frame)->if_cs, (frame)->if_eflags)
#define	CLKF_PC(frame)		((frame)->if_eip)
#define	CLKF_INTR(frame)	(IDXSEL((frame)->if_cs) == GICODE_SEL)

/*
 * This is used during profiling to integrate system time.
 */
#define	PROC_PC(p)		((p)->p_md.md_regs->tf_eip)
#define	PROC_STACK(p)		((p)->p_md.md_regs->tf_esp)

/*
 * Give a profiling tick to the current process when the user profiling
 * buffer pages are invalid.  On the i386, request an ast to send us
 * through trap(), marking the proc as needing a profiling tick.
 */
#define	need_proftick(p)	aston(p)

/*
 * Notify the current process (p) that it has a signal pending,
 * process as soon as possible.
 */
void signotify(struct proc *);

/*
 * We need a machine-independent name for this.
 */
extern void (*delay_func)(int);
struct timeval;

#define	DELAY(x)		(*delay_func)(x)
#define delay(x)		(*delay_func)(x)

/*
 * High resolution clock support (Pentium only)
 */
void	calibrate_cyclecounter(void);

/*
 * pull in #defines for kinds of processors
 */
#include <machine/cputypes.h>

struct cpu_nocpuid_nameclass {
	int cpu_vendor;
	const char *cpu_vendorname;
	const char *cpu_name;
	int cpu_class;
	void (*cpu_setup)(struct cpu_info *);
};

struct cpu_cpuid_nameclass {
	const char *cpu_id;
	int cpu_vendor;
	const char *cpu_vendorname;
	struct cpu_cpuid_family {
		int cpu_class;
		const char *cpu_models[CPU_MAXMODEL+2];
		void (*cpu_setup)(struct cpu_info *);
	} cpu_family[CPU_MAXFAMILY - CPU_MINFAMILY + 1];
};

struct cpu_cpuid_feature {
	int feature_bit;
	const char *feature_name;
};

/* locore.s */
extern int cpu;
extern int cpu_id;
extern char cpu_vendor[]; /* note: NOT nul-terminated */
extern char cpu_brandstr[];
extern int cpuid_level;
extern int cpu_miscinfo;
extern int cpu_feature;
extern int ecpu_feature;
extern int cpu_ecxfeature;
extern int ecpu_ecxfeature;
extern int cpu_cache_eax;
extern int cpu_cache_ebx;
extern int cpu_cache_ecx;
extern int cpu_cache_edx;
extern int cpu_perf_eax;
extern int cpu_perf_ebx;
extern int cpu_perf_edx;
extern int cpu_apmi_edx;

/* cpu.c */
extern u_int cpu_mwait_size;
extern u_int cpu_mwait_states;

/* machdep.c */
extern int cpu_apmhalt;
extern int cpu_class;
extern char cpu_model[];
extern const struct cpu_nocpuid_nameclass i386_nocpuid_cpus[];
extern const struct cpu_cpuid_nameclass i386_cpuid_cpus[];
extern void (*cpu_idle_enter_fcn)(void);
extern void (*cpu_idle_cycle_fcn)(void);
extern void (*cpu_idle_leave_fcn)(void);

/* apm.c */
extern int cpu_apmwarn;

extern int cpuspeed;

#if !defined(SMALL_KERNEL)
#define BUS66  6667
#define BUS100 10000
#define BUS133 13333
#define BUS166 16667
#define BUS200 20000
#define BUS266 26667
#define BUS333 33333
extern int bus_clock;
#endif

/* F00F bug fix stuff for pentium cpu */
extern int cpu_f00f_bug;
void fix_f00f(void);

/* dkcsum.c */
void	dkcsumattach(void);

extern int i386_use_fxsave;
extern int i386_has_sse;
extern int i386_has_sse2;

extern void (*update_cpuspeed)(void);

/* machdep.c */
void	dumpconf(void);
void	cpu_reset(void);
void	i386_proc0_tss_init(void);
void	i386_init_pcb_tss(struct cpu_info *);
void	cpuid(u_int32_t, u_int32_t *);

/* locore.s */
struct region_descriptor;
void	lgdt(struct region_descriptor *);

struct pcb;
void	savectx(struct pcb *);
void	switch_exit(struct proc *);
void	proc_trampoline(void);

/* clock.c */
extern void (*initclock_func)(void);
void	startclocks(void);
void	rtcdrain(void *);
void	rtcstart(void);
void	rtcstop(void);
void	i8254_delay(int);
void	i8254_initclocks(void);
void	i8254_startclock(void);
void	i8254_inittimecounter(void);
void	i8254_inittimecounter_simple(void);

#if !defined(SMALL_KERNEL)
/* est.c */
void	est_init(struct cpu_info *, int);
void	est_setperf(int);
/* longrun.c */
void	longrun_init(void);
void	longrun_setperf(int);
/* p4tcc.c */
void	p4tcc_init(int, int);
void	p4tcc_setperf(int);
/* powernow.c */
void	k6_powernow_init(void);
void	k6_powernow_setperf(int);
/* powernow-k7.c */
void	k7_powernow_init(void);
void	k7_powernow_setperf(int);
/* powernow-k8.c */
void 	k8_powernow_init(void);
void 	k8_powernow_setperf(int);
/* k1x-pstate.c */
void k1x_init(struct cpu_info *);
void k1x_setperf(int);
#endif

/* npx.c */
void	npxdrop(struct proc *);
void	npxsave_proc(struct proc *, int);
void	npxsave_cpu(struct cpu_info *, int);

/* isa_machdep.c */
void	isa_defaultirq(void);
int	isa_nmi(void);

/* pmap.c */
void	pmap_bootstrap(vaddr_t);

/* vm_machdep.c */
int	kvtop(caddr_t);

#ifdef MULTIPROCESSOR
/* mp_setperf.c */
void	mp_setperf_init(void);
#endif

#ifdef VM86
/* vm86.c */
void	vm86_gpfault(struct proc *, int);
#endif /* VM86 */

int	cpu_paenable(void *);
#endif /* _KERNEL */

/* 
 * CTL_MACHDEP definitions.
 */
#define	CPU_CONSDEV		1	/* dev_t: console terminal device */
#define	CPU_BIOS		2	/* BIOS variables */
#define	CPU_BLK2CHR		3	/* convert blk maj into chr one */
#define	CPU_CHR2BLK		4	/* convert chr maj into blk one */
#define CPU_ALLOWAPERTURE	5	/* allow mmap of /dev/xf86 */
#define CPU_CPUVENDOR		6	/* cpuid vendor string */
#define CPU_CPUID		7	/* cpuid */
#define CPU_CPUFEATURE		8	/* cpuid features */
#define CPU_APMWARN		9	/* APM battery warning percentage */
#define CPU_KBDRESET		10	/* keyboard reset under pcvt */
#define CPU_APMHALT		11	/* halt -p hack */
#define CPU_OSFXSR		13	/* uses FXSAVE/FXRSTOR */
#define CPU_SSE			14	/* supports SSE */
#define CPU_SSE2		15	/* supports SSE2 */
#define CPU_XCRYPT		16	/* supports VIA xcrypt in userland */
#define CPU_LIDSUSPEND		17	/* lid close causes a suspend */
#define CPU_LIDACTION		18	/* action caused by lid close */
#define CPU_FORCEUKBD		19	/* Force ukbd(4) as console keyboard */
#define CPU_MAXID		20	/* number of valid machdep ids */

#define	CTL_MACHDEP_NAMES { \
	{ 0, 0 }, \
	{ "console_device", CTLTYPE_STRUCT }, \
	{ "bios", CTLTYPE_INT }, \
	{ "blk2chr", CTLTYPE_STRUCT }, \
	{ "chr2blk", CTLTYPE_STRUCT }, \
	{ "allowaperture", CTLTYPE_INT }, \
	{ "cpuvendor", CTLTYPE_STRING }, \
	{ "cpuid", CTLTYPE_INT }, \
	{ "cpufeature", CTLTYPE_INT }, \
	{ "apmwarn", CTLTYPE_INT }, \
	{ "kbdreset", CTLTYPE_INT }, \
	{ "apmhalt", CTLTYPE_INT }, \
	{ 0, 0 }, \
	{ "osfxsr", CTLTYPE_INT }, \
	{ "sse", CTLTYPE_INT }, \
	{ "sse2", CTLTYPE_INT }, \
	{ "xcrypt", CTLTYPE_INT }, \
	{ "lidsuspend", CTLTYPE_INT }, \
	{ "lidaction", CTLTYPE_INT }, \
	{ "forceukbd", CTLTYPE_INT }, \
}

/*
 * This needs to be included late since it relies on definitions higher
 * up in this file.
 */
#if defined(MULTIPROCESSOR) && defined(_KERNEL)
#include <sys/mplock.h>
#endif

#endif /* !_MACHINE_CPU_H_ */
@


1.154
log
@Introduce a new knob to force the first USB keyboard as console input.

By setting "machdep.forceukbd=1" you can now use your USB keyboard in
ddb(4) even if your BIOS emulates a pckbd(4).

ok tom@@, kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.153 2017/03/02 10:38:10 natano Exp $	*/
d528 1
a528 1
#define CPU_FORCEUKBD		19	/* Force ukbd(4) as console keybpoard */
@


1.153
log
@Add a new sysctl machdep.lidaction. The sysctl works as follows:

machdep.lidaction=0	# do nothing
machdep.lidaction=1	# suspend
machdep.lidaction=2	# hibernate

lidsuspend is just an alias for lidaction, so if you change one, the
other one will have the same value. The plan is to remove
machdep.lidsuspend eventually when people have upgraded their
/ets/sysctl.conf.

discussed with deraadt, who came up with the new MIB name
no objections mlarkin
ok stsp halex jcs
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.152 2017/02/06 09:13:41 mpi Exp $	*/
d528 2
a529 1
#define CPU_MAXID		19	/* number of valid machdep ids */
d551 1
@


1.152
log
@Implement Dynamic Profiling, a ddb(4) based & gprof compatible kernel
profiling framework, for i386.

Code patching is used to enable probes when entering functions.  The
probes will call a mcount()-like function to match the behavior of a
GPROF kernel.

A new sysctl knob, ddb.profile, need to be set to 1 in securelevel 0
to be able to use this feature.

ok jasper@@, guenther@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.151 2017/01/03 09:48:15 mlarkin Exp $	*/
d527 2
a528 1
#define CPU_MAXID		18	/* number of valid machdep ids */
d549 1
@


1.151
log
@
reduce differences between amd64 and i386 vmm
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.150 2016/10/21 06:20:58 mlarkin Exp $	*/
d188 1
a188 1
#ifdef GPROF
@


1.150
log
@
vmm(4) for i386. Userland changes forthcoming. Note that for the time being,
i386 hosts are limited to running only i386 guests, even if the underlying
hardware supports amd64. This is a restriction I hope to lift moving forward,
but for now please don't report problems running amd64 guests on i386 hosts.

This was a straightforward port of the in-tree amd64 code plus the old rotted
tree I had from last year for i386 support. Changes included converting 64-bit
VMREAD/VMWRITE ops to 2x32-bit ops, and fixing treatment of the TSS, which
differs on i386.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.149 2016/10/14 04:53:26 mlarkin Exp $	*/
d196 1
@


1.149
log
@
cache some more cpuid info. the cached data is presently unused, but will
soon be.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.148 2016/07/28 21:57:57 kettenis Exp $	*/
d72 30
d191 8
d218 1
@


1.148
log
@Store the acpi processor ID/UID in struct cpu_info, and use it to attach
acpicpu(4) drivers to the right cpu(4).

ok mlarkin@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.147 2016/03/15 03:17:51 guenther Exp $	*/
d130 2
@


1.147
log
@Burn more LDT deadwood: stop allocating one for each idle thread,
load the ldt register with the null selector (disabling use of it),
stop reloading it on every context switch, and blow away the table
itself, as well as the pcb and pmap bits that were used to track
it (making sure to keep pcb_savefpu correctly aligned).

testing naddy@@
ok kettenis@@ mpi@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.146 2016/03/03 12:41:30 naddy Exp $	*/
d86 1
@


1.146
log
@Remove option USER_LDT and everything depending on it.
Remove machdep.userldt sysctl.
Remove i386_[gs]et_ldt syscall stub from libi386.
Remove i386_[gs]et_ldt regression test.

ok mlarkin@@ millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.145 2015/12/07 06:34:14 jsg Exp $	*/
a144 2
	union descriptor *ci_ldt;	/* per-cpu default LDT */
	int		ci_ldt_len;	/* in bytes */
d388 2
a389 2
void	i386_proc0_tss_ldt_init(void);
void	i386_init_pcb_tss_ldt(struct cpu_info *);
@


1.145
log
@Add cpuid bits documented in the August 2015 revision of
"Intel Architecture Instruction Set Extensions Programming Reference"
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.144 2015/07/13 17:45:01 mikeb Exp $	*/
a443 7
#ifdef USER_LDT
/* sys_machdep.h */
extern int user_ldt_enable;
int	i386_get_ldt(struct proc *, void *, register_t *);
int	i386_set_ldt(struct proc *, void *, register_t *);
#endif

a480 1
#define CPU_USERLDT		12
d501 1
a501 1
	{ "userldt", CTLTYPE_INT }, \
@


1.144
log
@remove unused isa_nodefaultirq;  ok kettenis, mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.143 2015/07/02 01:33:59 dlg Exp $	*/
d124 2
a125 1
	u_int32_t	ci_feature_sefflags;	/* more CPUID feature bits */
@


1.143
log
@introduce srp, which according to the manpage i wrote is short for
"shared reference pointers".

srp allows concurrent access to a data structure by multiple cpus
while avoiding interlocking cpu opcodes. it manages its own reference
counts and the garbage collection of those data structure to avoid
use after frees.

internally srp is a twisted version of hazard pointers, which are
a relative of RCU.

jmatthew wrote the bulk of a hazard pointer implementation and
changed bpf to use it to allow mpsafe access to bpfilters. however,
at s2k15 we were trying to apply it to other data structures but
the memory overhead of every hazard pointer would have blown out
significantly in several uses cases. a bulk of our time at s2k15
was spent reworking hazard pointers into srp.

this diff adds the srp api and adds the necessary metadata to struct
cpuinfo on our MP architectures. srp on uniprocessor platforms has
alternate code that is optimised because it knows there'll be no
concurrent access to data by multiple cpus.

srp is made available to the system via param.h, so it should be
available everywhere in the kernel.

the docs likely need improvement cos im too close to the implementation.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.142 2015/06/13 21:41:42 guenther Exp $	*/
a451 1
void	isa_nodefaultirq(void);
@


1.142
log
@Parse _CST objects and use the C-states they describe when they're sane.

testing by many, particularly krw@@ and jcs@@
tweaks by kettenis@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.141 2015/06/07 06:24:59 guenther Exp $	*/
d87 4
@


1.141
log
@Enable use of mwait in non-MP boxes and report # of C-substates up to C7,
truncating trailing zeros.

Testing by many as part of a larger change to use ACPI _CST objects
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.140 2015/05/28 20:10:58 guenther Exp $	*/
d130 1
@


1.140
log
@Save the cpuid(6) eax bits in the cpu_info and report the SENSOR and ARAT
bits from it.

ok krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.139 2015/04/18 22:16:21 kettenis Exp $	*/
d133 1
a217 2
extern u_int cpu_mwait_size;

d337 4
@


1.139
log
@It seems that the CPUID lies about the monitor-line size, or at least our
interpretation of it isn't quite right.  So instead of allocating memory
and slicing it based on the parameters returned by CPUID, simply use a member
in struct cpu_info like basically all other OSes out there do.  Our struct
cpu_info is large enough to never cause any overlap.  This makes the
mwait-based idle loop actually work.  We still execute the CPUID instruction
to make sure monitor/mwait is properly supported by the hardware we're
running on.

ok sthen@@, deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.138 2015/04/12 18:37:54 mlarkin Exp $	*/
d121 1
@


1.138
log
@
Bring PAE code back to life, in a different form. This diff (via bluhm then
to deraadt, then myself) brings the PAE pmap on i386 (not touched in any
significant way for years) closer to the current non-PAE pmap and allows
us to take a big next step toward better i386 W^X in the kernel (similar to
what we did a few months ago on amd64). Unlike the original PAE pmap, this
diff will not be supporting > 4GB physical memory on i386 - this effort is
specifically geared toward providing W^X (via NX) only.

There still seems to be a bug removing certain pmap entries when PAE is
enabled, so I'm leaving PAE mode disabled for the moment until we can
figure out what is going on, but with this diff in the tree hopefully
others can help.

The pmap functions now operate through function pointers, due to the need
to support both non-PAE and PAE forms. My unscientific testing showed
less than 0.3% (a third of a percent) slowdown with this approach during
a base build.

Discussed for months with guenther, kettenis, and deraadt.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.137 2014/12/16 21:40:05 tedu Exp $	*/
d129 1
a129 2
	u_int		*ci_mwait;
/* bits in ci_mwait[0] */
d215 2
@


1.137
log
@don't include lock.h by default. poisons namespace. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.136 2014/12/02 18:13:10 tedu Exp $	*/
d461 1
@


1.136
log
@delete all the simplelocks. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.135 2014/09/12 09:52:45 kettenis Exp $	*/
a66 1
#include <sys/lock.h>			/* will also get LOCKDEBUG */
@


1.135
log
@Remove the code that attempts to synchronize P-state transitions between CPUs.
Spinning inside an IPI handler is generally a bad idea as it is very hard to
avoid deadlocks.  As far as I can tell the synchronization isn't necessary.
Multi-core CPUs have hardware mechanisms to do the appropropriate coordination
between cores and coordination between sockets isn't necessary either.

This seems to fix the various hangs and suspend/resume failures that people
have been seeing when running apmd -A or apmd -C.

Tested by many.
ok kspillner@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.134 2014/07/11 10:53:07 uebayasi Exp $	*/
a84 1
	struct simplelock ci_slock;	/* lock on this data structure */
@


1.134
log
@CPU_BUSY_CYCLE(): A new MI statement for busy loop power reduction

The new CPU_BUSY_CYCLE() may be put in a busy loop body so that CPU can reduce
power consumption, as Linux's cpu_relax() and FreeBSD's cpu_spinwait().  To
start minimally, use PAUSE on i386/amd64 and empty on others.  The name is
chosen following the existing cpu_idle_*() functions.  Naming and API may be
polished later.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a148 6

	volatile int ci_setperf_state;
#define CI_SETPERF_READY	0
#define CI_SETPERF_SHOULDSTOP	1
#define CI_SETPERF_INTRANSIT	2
#define CI_SETPERF_DONE		3
@


1.133
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.132 2014/02/13 23:11:06 kettenis Exp $	*/
d228 2
d241 2
@


1.132
log
@Some Linux i915 drm "fast" path code relies on being able to "disable" page
faults to avoid sleeping.  Implement this functionality for i386 and amd64
for faults in the user address space.  If the ci_inatomic flag is set in
struct cpu_info, copyin(9) and copyout(9) will return EFAULT when a user-space
address needs to be faulted in.  Use this to properly implement
__copy_to_user_inatomic() and __copy_from_user_inatomic_nocache() in the
inteldrm(4) code.

ok krw@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.131 2013/10/09 01:48:41 guenther Exp $	*/
d211 1
a211 1
	__asm __volatile("movl %%fs:%1, %0" :
@


1.131
log
@Use monitor/mwait to idle when available.  Make cpu_unidle() do nothing
if it can tell the target CPU isn't actually idling and introduce cpu_kick()
for the cases where we want to force a non-idle CPU into the kernel.

just a port of the amd64 version; testing by many
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.130 2013/05/31 17:00:58 tedu Exp $	*/
d125 2
@


1.130
log
@remove counters for simplelocks
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.129 2013/03/31 17:07:03 deraadt Exp $	*/
d129 6
d223 1
d235 1
@


1.129
log
@try to avoid pulling in pte.h and other more crazy things.  Checked against
the things that libkvm needs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.128 2013/03/12 09:37:16 mpi Exp $	*/
a87 4
#if defined(DIAGNOSTIC) || defined(LOCKDEBUG)
	u_long ci_spin_locks;		/* # of spin locks held */
	u_long ci_simple_locks;		/* # of simple locks held */
#endif
@


1.128
log
@Fix kernel profiling on MP systems by using per-CPU buffers and teach
kgmon(8) to deal with them, this time without public header changes.

Previously various CPUs were iterating over the same global buffer at
the same time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok deraadt@@, mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.127 2013/02/12 08:06:22 mpi Exp $	*/
d44 1
d54 2
@


1.127
log
@Back out per-CPU kernel profiling, it shouldn't modify a public header
at this moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.126 2013/02/11 17:05:25 mpi Exp $	*/
d151 3
@


1.126
log
@Fix kernel profiling on MP systems by using per-CPU buffer. Previously
various CPUs were iterating over the same global buffer at the same
time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.125 2012/12/02 07:03:31 guenther Exp $	*/
a150 3
#ifdef GPROF
	struct gmonparam	*ci_gmon;
#endif
@


1.125
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.124 2012/11/10 09:45:05 mglocker Exp $	*/
d151 3
@


1.124
log
@Recent x86 CPUs come with a constant time stamp counter.  If this is
the case we verify if the CPU supports a specific version of the
architectural performance monitoring feature and read out the current
frequency from the fixed-function performance counter of the unhalted
core.

My initial motivation to implement this was the Soekris net6501-70
which comes with an Intel Atom E6xx 1.60GHz CPU.  It has a constant
time stamp counter plus speed step support and boots on the lowest
frequency of 600MHz.  This caused hw.cpuspeed and hw.setperf to
reflect the wrong values.

The diff is a cooperation work with jsg@@.  The fixed-function
performance counter read code comes from a former diff of him.

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.123 2012/10/09 04:40:36 jsg Exp $	*/
d251 1
@


1.123
log
@Enable Supervisor Mode Execution Protection (SMEP), found in recent
Intel chips.  If the kernel is tricked into running code from a user
page while in supervisor mode we'll now get a page fault and panic
instead of running it.

suggestions and ok guenther@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.122 2012/03/27 06:44:01 jsg Exp $	*/
d166 1
d323 4
@


1.122
log
@Make the bus_clock calculations happen later in the boot process so
they can be conditionally called in future.

This makes the i386 speedstep code closer to the amd64 code
(though still with the added complications of VIA support and the
*_update_cpuspeed callbacks)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.121 2011/11/02 23:53:44 jsg Exp $	*/
d123 1
@


1.121
log
@display AMD/extended (0x80000001) cpuid flags and remove the
Cyrix 3DNOW flag from normal cpuid flags as it will show up in
extended flags.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.120 2011/05/23 09:54:20 claudio Exp $	*/
d391 1
a391 1
void	est_init(const char *, int);
@


1.120
log
@AMD K10/K11 pstate driver allows setperf and apm to change CPU
frequencies on newer AMD systems.
Driver written by Bryan Steele / brynet gmail.com adjusted for i386
by myself. Put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.119 2011/04/22 15:48:43 kettenis Exp $	*/
d314 1
d316 1
@


1.119
log
@Remove unused structure member.

ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.118 2011/03/23 16:54:35 pirofti Exp $	*/
d406 3
@


1.118
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.117 2010/10/02 23:13:28 deraadt Exp $	*/
a115 1
	int		sc_apic_version;/* local APIC version */
@


1.117
log
@make ci_flags volatile; some future MD code will depend on this.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.116 2010/09/28 20:27:54 miod Exp $	*/
d38 2
a39 2
#ifndef _I386_CPU_H_
#define _I386_CPU_H_
d495 1
a495 1
#endif /* !_I386_CPU_H_ */
@


1.116
log
@Implement a per-cpu held mutex counter if DIAGNOSTIC on all non-x86 platforms,
to complete matthew@@'s commit of a few days ago, and drop __HAVE_CPU_MUTEX_LEVEL
define. With help from, and ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.115 2010/09/24 13:21:30 matthew Exp $	*/
d114 1
a114 1
	u_long		ci_flags;	/* flags; see below */
@


1.115
log
@Add stricter asserts to DIAGNOSTIC kernels to help catch mutex and
rwlock misuse.  In particular, this commit makes the following
changes:

  1. i386 and amd64 now count the number of active mutexes so that
assertwaitok(9) can detect attempts to sleep while holding a mutex.

  2. i386 and amd64 check that we actually hold mutexes when passed to
mtx_leave().

  3. Calls to rw_exit*() now call rw_assert_{rd,wr}lock() as
appropriate.

ok krw@@, oga@@; "sounds good to me" deraadt@@; assembly bits double
checked by pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.114 2010/08/11 21:22:44 kettenis Exp $	*/
a110 1
#define __HAVE_CPU_MUTEX_LEVEL
@


1.114
log
@Disable the RTC the periodic interrupt.  Leaving it enabled causes the
Dell Inspirion 4150 to wake up immediately even though RTC_EN isn't set
in the PM1 Enable register.

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.113 2010/08/05 21:10:09 deraadt Exp $	*/
d109 4
@


1.113
log
@new i386/amd64 machdep.lidsuspend sysctl which decides whether a lid
close causes a suspend.  resumes are not tied to this; they happen
unconditionally.  this is a temporary knob for the 4.8 release; afterwards
it will move to a more convenient place
much moaning discussing where to put the knob with kettenis
tested by various including phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.112 2010/07/25 21:43:37 deraadt Exp $	*/
d378 1
@


1.112
log
@in the clock drivers, seperate the soft-state and hard-state which was
all jumbled up in the same functions. the rtc (mc chip) and clock (i8243)
startup was also mixed up.  they the soft state and hardware state can
be started in the right order, and it is easy to restart just the
neccessary parts upon resume.  tested in numerous cases:
(apic, pic) * (GENERIC.MP, GENERIC) * (mp, non-mp) * (i386, amd64)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.111 2010/07/21 14:08:09 kettenis Exp $	*/
d459 2
a460 1
#define CPU_MAXID		17	/* number of valid machdep ids */
d480 1
@


1.111
log
@Make sure that the FPU IPIs shoot down the right FPU context and not the FPU
context of some random process that happened to be switched onto the FPU
after the decision was made to send the IPI.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.110 2010/05/23 22:41:49 deraadt Exp $	*/
d374 2
a375 2
void	initrtclock(void);
void	startrtclock(void);
d377 1
d380 1
a382 1

@


1.110
log
@seteconf() died years ago
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.109 2009/12/09 14:27:34 oga Exp $	*/
d95 1
@


1.109
log
@Detect the cache line size for the clflush instruction when we identify
the cpu.

ok kettenis@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.108 2009/06/03 00:49:12 art Exp $	*/
a434 5

#ifdef GENERIC
/* swapgeneric.c */
void	setconf(void);
#endif /* GENERIC */
@


1.108
log
@Just like on amd64. Instead of keeping a bitmap of which cpus a pmap
is active on, save a curpmap pointer in cpu_info. This lets us simplify
a few things and do lazy context switching from a user process to a
kernel thread. There's a new IPI introduced for forcing a cr3 reload
when we're tearing down a dead pmap.

kettenis@@ ok (after I polished a few minor things)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.107 2009/02/16 15:44:25 jsg Exp $	*/
d121 1
@


1.107
log
@Store conditionally extended cpuid family/model values
in seperate variables in struct cpu_info instead
of duplicating the process of extracting it from the signature.

Use this value when determining the bus clock on P6/family 0x6
chips, which fixes speedstep on bernd@@'s ThinkPad x200s.

Discussed with several, 'just do it' weingart@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.106 2008/11/22 18:12:32 art Exp $	*/
a96 2
	volatile u_int32_t ci_tlb_ipi_mask;

d100 1
@


1.106
log
@The last parts of cpu_unidle. i386, amd64 and sparc64
In short, make cpu_unidle do what signotify used to do and
make signotify use cpu_unidle.
Also, include a cpu_unidle in need_resched, it won't change much right now
but will be needed in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.105 2008/10/15 23:23:47 deraadt Exp $	*/
d118 2
@


1.105
log
@make random(9) return per-cpu values (by saving the seed in the cpuinfo),
which are uniform for the profclock on each cpu in a SMP system (but using
a different seed for each cpu).  on all cpus, avoid seeding with a value out
of the [0, 2^31-1] range (since that is not stable)
ok kettenis drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.104 2008/09/28 20:32:17 brad Exp $	*/
d208 2
d218 2
@


1.104
log
@Remove "XXX for now" NLAPIC define. Already provided via lapic.h.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.103 2008/07/18 23:43:31 art Exp $	*/
d89 1
@


1.103
log
@Add a macro that clears the want_resched flag that need_resched sets.
Right now when mi_switch picks up the same proc, we didn't clear the
flag which would mean that every time we service an AST we would attempt
a context switch. For some architectures, amd64 being probably the
most extreme, that meant attempting to context switch for every
trap and interrupt.

Now we clear_resched explicitly after every context switch, even if it
didn't do anything. Which also allows us to remove some more code
in cpu_switchto (not done yet).

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.102 2008/06/09 20:43:43 miod Exp $	*/
a51 4

/* XXX for now... */
#define NLAPIC 1

@


1.102
log
@Remove fillw(). Bonus points if you do not remember what it was used for.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.101 2008/04/18 20:20:35 kettenis Exp $	*/
d233 1
@


1.101
log
@Now that i386 has a per-process astpending, we can garbage collect ipi_ast
and do an ipi_nop cross-call from signotify() instead.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.100 2008/04/13 11:35:55 thib Exp $	*/
a361 1
void	fillw(short, void *, size_t);
@


1.100
log
@garbage collect the cpus_running global variable;

pointed out by and ok drahn@@, toby@@;
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.99 2007/11/28 17:05:09 tedu Exp $	*/
d222 2
a242 2
void aston(struct proc *);

d254 1
a254 1
#define signotify(p)		aston(p)
@


1.99
log
@quite a bit of simplification by removing cpu classes.
also assume that 386 cpus are really unknown, and promote them to 486
instead of panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.98 2007/11/16 16:16:06 deraadt Exp $	*/
a206 1
extern u_long		 cpus_running;
@


1.98
log
@fix the bus_space #define nightmare, so that amd64 and i386 are much more
uniform. as a result shared code like acpi needs less #ifdef's
ok marco kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.97 2007/11/03 03:37:08 weingart Exp $	*/
a265 1
#if defined(I586_CPU) || defined(I686_CPU)
a269 1
#endif
a326 1
#if defined(I586_CPU) || defined(I686_CPU)
a327 1
#endif
a339 1
#ifdef I586_CPU
a342 1
#endif
d380 1
a381 1
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
a383 2
#endif

a384 1
#if !defined(SMALL_KERNEL) && defined(I586_CPU)
a386 2
#endif

a387 1
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
a389 3
#endif

#if !defined(SMALL_KERNEL) && defined(I586_CPU)
a392 2
#endif
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
@


1.97
log
@APM switchto cleanup diff.  This uses the switchto functionality to
significantly clean up the APM idle loop things.  I actually can make
sense of what the APM idle loop is supposed to do.

Ok gwk@@, beck@@, and theo says ramdisks compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.96 2007/09/07 08:37:38 art Exp $	*/
d183 1
a183 1
#define I386_MAXPROCS		32	/* because we use a bitmask */
d206 1
a206 1
extern struct cpu_info	*cpu_info[I386_MAXPROCS];
d214 1
a214 1
#define I386_MAXPROCS		1
@


1.96
log
@Remove some left-overs from the TSC based microtime. We don't need
to synchronize the tsc between CPUs anymore. While here, also remove
the slow TLB IPI since it's been dead for a while.

noticed by mickey
toby@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.95 2007/06/07 11:20:58 dim Exp $	*/
d315 1
d322 4
@


1.95
log
@Replace magic bus clock constants in est related files with defines.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.94 2007/05/29 21:01:56 tedu Exp $	*/
a116 1
	u_int64_t	ci_tscbase;
@


1.94
log
@add support for core cpu temperature sensors.
from a diff by pierre riteau, but updated to look like the amd64 version
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.93 2007/05/26 22:09:17 weingart Exp $	*/
d327 10
@


1.93
log
@Move cpu_info/curcpu to be mapped by the %fs segment.  Extra input and
debugging by tom@@, art@@, kettenis@@, and others.  Testing by many others.

ok art@@, kettenis@@, tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.92 2007/04/21 21:06:15 gwk Exp $	*/
d70 1
d74 1
d146 3
a302 1
#ifdef _KERNEL
@


1.92
log
@Introduce a smp aware hw.setperf mechanism, it will scale all CPUs or
cores by the same amount, i.e. if you do hw.setperf=50 both cores will
be scaled to the opearting state corresponing to 50%. Tested by many with
est (mainly on core2duo machines like X60 thinkpads). Only enable est
during GENERIC.MP build no one tested powernow.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.91 2007/04/12 20:22:58 art Exp $	*/
d185 14
a198 2
#define cpu_number()		(i82489_readreg(LAPIC_ID)>>LAPIC_ID_SHIFT)
#define	curcpu()		(cpu_info[cpu_number()])
@


1.91
log
@Faster signal delivery on i386/MP.

We need to poke the other CPU so that it processes the AST immediately
and doesn't wait for the next interrupt or syscall.

Since IPIs really shouldn't process ASTs, we need to trigger a soft
interrupt on the destination CPU to process the AST. But since we can't
send soft interrupts to other CPUs, we send an IPI, that triggers a soft
interrupt that in turn processes the AST.

Also, this marks the beginning of moving to slightly better IPI mechanism
of short and optimized IPIs instead of the large and complicated IPI
infrastructure we're using now.

tested by many, ok tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.90 2007/04/03 10:14:47 art Exp $	*/
d68 1
a68 1
#include <sys/lock.h>                  /* will also get LOCKDEBUG */
d79 1
a79 1
	
d116 1
a116 1
	
d138 6
d410 5
@


1.90
log
@Make the ast on i386 per-process instead of per-cpu. This makes
signal delivery more reliable in some cases when a process switches
cpu.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.89 2007/03/19 09:29:33 art Exp $	*/
d220 1
a220 1
#define aston(p)		((p)->p_md.md_astpending = 1)
d233 1
a233 1
#define	signotify(p)		aston(p)
@


1.89
log
@Move i386 to timecounters. This is more or less the same code as amd64.

The "lapic" timer is ripped out since it wasn't actually a lapic timer,
but a hacked up tsc timer with some synchronization for MP. There is no
tsc timer right now since they are very unreliable on MP systems, systems
with apm, and systems that change the cpu clock. Which basically means
every modern machine out there. We're running with the i8259 timer now.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.88 2007/03/15 10:22:29 art Exp $	*/
a126 1
	int		ci_astpending;
a203 1
#define astpending (curcpu()->ci_astpending)
d220 2
d227 1
a227 1
#define	need_proftick(p)	setsoftast()
d233 1
a233 1
#define	signotify(p)		setsoftast()
@


1.88
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.87 2007/02/20 21:15:01 tom Exp $	*/
a239 1
extern void (*microtime_func)(struct timeval *);
a242 1
#define microtime(tv)		(*microtime_func)(tv)
a248 13
#ifndef	HZ
extern u_quad_t pentium_base_tsc;
#define CPU_CLOCKUPDATE()						\
	do {								\
		if (cpuspeed) {						\
			__asm __volatile("cli\n"			\
					 "rdtsc\n"			\
					 : "=A" (pentium_base_tsc)	\
					 : );				\
			__asm __volatile("sti"); 			\
		}							\
	} while (0)
#endif
a344 1
void	i8254_microtime(struct timeval *);
d346 3
@


1.87
log
@Revert PAE pmap for now, until the strange bug is found.  This stops
the freezes many of us are seeing (especially on amd64 machines running
OpenBSD/i386).

Much testing by nick@@ (as always - thanks!), hugh@@, ian@@, kettenis@@
and Sam Smith (s (at) msmith (dot) net).

Requested by, input from, and ok deraadt@@  ok art@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.86 2006/12/24 20:30:35 miod Exp $	*/
d227 1
a227 1
#define	need_proftick(p)	((p)->p_flag |= P_OWEUPC, setsoftast())
@


1.86
log
@Define PROC_PC. Then, since profiling information is being reported in
statclock(), do not bother doing this in userret() anymore. As a result,
userret() does not need its pc and ticks arguments, simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.85 2006/12/20 17:50:40 gwk Exp $	*/
a421 4

#ifndef SMALL_KERNEL
int	cpu_paenable(void *);
#endif /* !SMALL_KERNEL */
@


1.85
log
@"#ifdef is a tool of the weak!"
Rename pentium_mhz to cpuspeed which is consistant with amd64 making
shared ACPI code less nasty.
ok marco, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.84 2006/12/12 23:14:27 dim Exp $	*/
d216 5
@


1.84
log
@Complete gwk's previous patch to stop setperf methods from returning
errors to userland: make all cpu_setperf functions return void.

Tested by many, ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.83 2006/11/29 20:03:20 dim Exp $	*/
d250 1
a250 1
		if (pentium_mhz) {					\
d314 1
a314 1
extern int pentium_mhz;
@


1.83
log
@Remove all the extern cpu_{id,model,whatever} declarations from most
stuff in arch/i386/i386.  This should prevent more screwups like the
one I did before in ichpcib.c...

ok dlg@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.82 2006/11/29 12:26:13 miod Exp $	*/
d361 1
a361 1
int     est_setperf(int);
d367 1
a367 1
int	longrun_setperf(int);
d373 1
a373 1
int     p4tcc_setperf(int);
d379 1
a379 1
int	k6_powernow_setperf(int);
d384 1
a384 1
int	k7_powernow_setperf(int);
d387 1
a387 1
int 	k8_powernow_setperf(int);
@


1.82
log
@Remove cpu_swapin() and cpu_swapout(), they are no longer necessary (except
for cpu_swapin() on hppa* which is kept).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.81 2006/11/26 15:13:21 dim Exp $	*/
d291 1
d293 4
a296 1
extern int cpu_class;
d300 5
a304 1
extern int cpu_apmwarn;
d306 2
a307 1
extern int cpuid_level;
d310 2
@


1.81
log
@Save misc info (ebx) register from cpuid with eax=1, so we can use it
later for some identifications.

"slap it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.80 2006/07/25 19:16:51 kettenis Exp $	*/
a58 6
 * definitions of cpu-dependent requirements
 * referenced in generic code
 */
#define	cpu_swapin(p)			/* nothing */

/*
a198 6

/*
 * definitions of cpu-dependent requirements
 * referenced in generic code
 */
#define	cpu_swapin(p)			/* nothing */
@


1.80
log
@Kill option GPL_MATH_EMULATE.

ok deraadt@@ and many others.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.79 2006/06/12 13:18:18 dim Exp $	*/
d305 1
@


1.79
log
@Some more improvements to EST:
- If an unknown EST CPU is encountered, use the known highest and lowest
  (and if different, the current) power state to generate a fake power
  state table on the fly.  Thanks to canacar for the idea.
- Calculate system bus clock speed before calling est_init(); it is
  needed to display proper MHz values from MSR values.
- Also use the bus clock to identify EST CPU's, which is needed to
  differentiate e.g. Pentium M 715 and 760, which unfortunately have
  exactly the same MSR values.
- Store power states directly as MSR values.

Tested by many, "so when does it go in?" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.78 2006/05/29 09:54:20 mickey Exp $	*/
a393 5

#if defined(GPL_MATH_EMULATE)
/* math_emulate.c */
int	math_emulate(struct trapframe *);
#endif
@


1.78
log
@implement reliable microtime on smp (joint work w/ otto):
send a bcast ipi from the cpu0 to all others to timestamp tsc
on every clock intr. this way using local tsc provides accurate
microtime() measurements. thus gettimeofday test passes now.
otto@@ deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.77 2006/05/19 19:43:41 dim Exp $	*/
d315 1
@


1.77
log
@Reimplement the Enhanced SpeedStep CPU detection by using the
quintuplet { vendor, MHz_hi, mV_hi, MHz_lo, mV_lo }, which works much
better than parsing the branding string.  It also makes it easier to add
new models later.

Shouldn't break any CPU's which previously worked okay with EST; if
there's any trouble, please let me know!

Also adds quite a number of VIA C7-M models, and a few more Pentium M
models, all from FreeBSD.

"go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.76 2006/05/09 09:38:35 otto Exp $	*/
d117 5
a121 4
	paddr_t ci_idle_pcb_paddr;	/* PA of idle PCB */
	u_long ci_flags;		/* flags; see below */
	u_int32_t ci_ipis; 		/* interprocessor interrupts pending */
	int sc_apic_version;  		/* local APIC version */
@


1.76
log
@Move the sti to after the memory write. We do not want execution of
this and microtime() to interleave. ok deraadt@@ toby@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.75 2006/04/27 15:37:53 mickey Exp $	*/
d358 1
a358 1
void	est_init(const char *);
@


1.75
log
@implement separate PAE pmap that allows access to 64g of physmem
if supported by the cpu(s). currently not enabled by default and
not compiled into ramdisks. this grows paddr_t to 64bit but yet
leaves bus_addr_t at 32bits. measures are taken to favour dmaable
memory allocation from below 4g line such that buffer cache is
already allocated form below, pool backend allocator prefers lower
memory and then finally bounce buffers are used as last resort.
PAE is engaged only if global variable cpu_pae is manually set
to non-zero and there is physical memory present above 4g.
simplify pcibios address math to use u_long as we always will
be in the 32bit space.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.74 2006/01/12 22:39:21 weingart Exp $	*/
a263 1
					 "sti\n"			\
d266 1
@


1.74
log
@Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.73 2005/11/04 06:55:36 tedu Exp $	*/
d420 4
@


1.73
log
@only build powernow pieces as appropriate for config'd cpu types
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.72 2005/10/28 07:03:41 tedu Exp $	*/
d135 2
@


1.72
log
@update support for powernow (cool and quiet) on k7, and add support
for k8.  preliminary and not well tested yet.  from freebsd via
gordon klok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.71 2005/09/25 20:48:23 miod Exp $	*/
d372 1
a372 1
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
d376 2
@


1.71
log
@Turn CPU_INFO_FOREACH into a real construct, like all queue(3) iterators,
instead of the contents of a for() loop. No functional change.
From the m88k SMP tree; ok art@@ deraadt@@

[complete diff this time]
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.70 2005/09/20 23:00:34 deraadt Exp $	*/
d372 2
d376 2
a377 1
void	k7_powernow_init(uint32_t);
d379 4
a382 1

@


1.70
log
@unbreak tree, how did you do that miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.68 2005/05/27 10:41:11 kjell Exp $	*/
d170 2
a171 2
#define	CPU_INFO_FOREACH(cii, ci)	cii = 0, ci = cpu_info_list; \
					ci != NULL; ci = ci->ci_next
@


1.69
log
@Turn CPU_INFO_FOREACH into a real construct, like all queue(3) iterators,
instead of the contents of a for() loop. No functional change.
From the m88k SMP tree; ok art@@ deraadt@@
@
text
@d170 2
a171 2
#define	CPU_INFO_FOREACH(cii, ci)	for (cii = 0, ci = cpu_info_list; \
					    ci != NULL; ci = ci->ci_next)
@


1.68
log
@Enable SSE instructions on secondary (i386) processors in
a multiprocessor boot.

This fixes the hardware AES (and likely RNG) instruction on the dual VIA,
which was failing because the SSE/SSE2 extensions are never enabled on
any processor but the boot processor.

Much assistance from niklas, and the eureka moment from theo.

"commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.67 2004/08/05 03:07:47 dlg Exp $	*/
d170 2
a171 2
#define	CPU_INFO_FOREACH(cii, ci)	cii = 0, ci = cpu_info_list; \
					ci != NULL; ci = ci->ci_next
@


1.68.2.1
log
@MFC:
Fix by weingart@@

Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.68 2005/05/27 10:41:11 kjell Exp $	*/
a134 2
	union descriptor *ci_ldt;	/* per-cpu default LDT */
	int		ci_ldt_len;	/* in bytes */
@


1.67
log
@spelling nit from Chris Pascoe

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.66 2004/07/14 05:34:14 tedu Exp $	*/
d129 1
a129 1
	void (*cpu_setup)(const char *, int, int);	/* proc-dependant init */
d280 1
a280 1
	void (*cpu_setup)(const char *, int, int);
d290 1
a290 1
		void (*cpu_setup)(const char *, int, int);
@


1.67.4.1
log
@MFC:
Fix by weingart@@

Move to using gdt only (no more ldt in general case) but with a variable
limit selector, so that the w^x line can float much more dynamically.
Much work done by tom.  Tested by various people.  Addresses concerns of
(Julien Tinnes) <julien ATHOST cr0.org>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.67 2004/08/05 03:07:47 dlg Exp $	*/
a134 2
	union descriptor *ci_ldt;	/* per-cpu default LDT */
	int		ci_ldt_len;	/* in bytes */
@


1.66
log
@setperf driver for powernow in amd k7 cpus.  derived from a diff to
tech-i386@@netbsd by martin vegiard, and adapted to fit in here.
as yet untested.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.65 2004/06/25 08:41:19 art Exp $	*/
d217 1
a217 1
 * Preemt the current process if in interrupt from user monre,
@


1.65
log
@Instead of accessing ci_dev (that's an MI field), provide a marco that
translates a cpu_info structure into a human-readable cpu number.

drahn@@ deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.64 2004/06/21 23:12:14 art Exp $	*/
d374 2
@


1.64
log
@Put back the moving of schedstate_percpu into sched.h. This time expose
it to userland so that i386 builds (other architectures didn't show the
problem).

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.63 2004/06/20 08:25:30 deraadt Exp $	*/
d172 2
@


1.63
log
@nope, tree breakage in libpthread.  too tough to run a make build?
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.61 2004/06/13 21:49:16 niklas Exp $	*/
d75 1
a75 1
#include <sys/proc.h>
@


1.62
log
@Move schedstate_percpu into sched.h so that we don't have to include
proc.h in cpu.h on __HAVE_CPU_INFO architectures. cpu.h is usually included
in param.h.

This also removes the horrible kludge with ifdef SYS_PROC_H in sched.h
by simply converting the inline functions into macros.

With a few suggestions from nordin@@

deraadt@@ ok
@
text
@d75 1
a75 1
#include <sys/sched.h>
@


1.61
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d75 1
a75 1
#include <sys/proc.h>
@


1.60
log
@Don't touch any hardware registers while fetching hw.cpuspeed and
just return current pentium_mhz value. Update this value in
all hw.setperf hoos either via its own private methods or using
global update_cpuspeed hook, if registered.
Also implement update_cpuspeed hook for Pentium 3.

Tested by millert@@, Gabriel Kihlman <gk@@stacken.kth.se> and me on
various i386 machines.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.59 2004/04/02 22:28:41 tedu Exp $	*/
d44 1
a45 1
#include <machine/frame.h>
d47 10
d73 140
a212 3
#define	CLKF_USERMODE(frame)	USERMODE((frame)->if_cs, (frame)->if_eflags)
#define	CLKF_PC(frame)		((frame)->if_eip)
#define	CLKF_INTR(frame)	(IDXSEL((frame)->if_cs) == GICODE_SEL)
d215 1
a215 1
 * Preempt the current process if in interrupt from user mode,
d218 5
a222 2
int	want_resched;		/* resched() was called */
#define	need_resched()		(want_resched = 1, setsoftast())
d240 7
a246 2
#define	DELAY(x)		delay(x)
void	delay(int);
d331 1
d348 3
d375 3
a377 2
void	npxdrop(void);
void	npxsave(void);
d393 1
d454 8
@


1.59
log
@K6-2/3 powernow driver.  not without quirks, but mostly working.
testing by david@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.58 2004/02/14 15:09:22 grange Exp $	*/
d170 2
a195 1
int     est_cpuspeed(int *);
a201 1
int	longrun_cpuspeed(int *);
@


1.58
log
@Simplify hw.{cpuspeed,setperf} api moving all the sysctl stuff
from the underlying callbacks.

Testing hppa mickey@@, ppc drahn@@
Ok markus@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.57 2004/02/01 19:05:23 deraadt Exp $	*/
d210 4
@


1.57
log
@Enable FXSR all the time, and cope with NPX/FXSR conversions; from netbsd.
Pass SSE/SSE2/XCRYPT flags out via syctl, and prepare for being able to do
xcrypt-* in userland; ok naddy, tested a lot by pvalchev and jolan, also
works on amd64 in 32bit mode
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.56 2004/02/01 12:26:45 grange Exp $	*/
d194 2
a195 2
int     est_cpuspeed(void *, size_t *, void *, size_t);
int     est_setperf(void *, size_t *, void *, size_t);
d201 2
a202 2
int	longrun_cpuspeed(void *, size_t *, void *, size_t);
int	longrun_setperf(void *, size_t *, void *, size_t);
d208 1
a208 1
int     p4tcc_setperf(void *, size_t *, void *, size_t);
@


1.56
log
@Sync user ldt code with NetBSD:
- finally remove it from pcb, it's a pmap thing only
- more sanity checks
- better lockin
- may be something else

Fixes panics when using apps requiring it (mplayer-win32 e.g.).
Problem found and test espie@@.
OKs from miod@@ (sshhh, don't tell anyone) and art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.55 2004/01/06 21:09:20 tedu Exp $	*/
d166 4
d264 5
a268 1
#define	CPU_MAXID		13	/* number of valid machdep ids */
d284 4
@


1.55
log
@adjust pentium_mhz when cpu speed changes.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.54 2003/12/20 18:23:18 tedu Exp $	*/
a218 1
void	i386_user_cleanup(struct pcb *);
@


1.54
log
@add pentium 4 thermal control circuit (tcc) driver.  can use this to
limit power consumption with the hw.setperf sysctl.
tested by beck and grange
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.53 2003/12/19 22:42:13 tedu Exp $	*/
d196 1
@


1.53
log
@
add cpu_ecxfeature to cpu.h, and stop locally externing it and cpu_feature.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.52 2003/12/18 23:46:19 tedu Exp $	*/
d198 6
@


1.52
log
@add new hw sysctls, cpuspeed and setperf to control cpu frequency.
convert longrun support to use new sysctls.
add enhanced speedstep support, based on code by Michael Eriksson.
idea, help testing & ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.51 2003/07/28 21:15:28 jason Exp $	*/
d146 1
@


1.51
log
@nuke more MATH_EMULATE
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.50 2003/07/07 03:07:18 tedu Exp $	*/
d186 13
d253 1
a253 2
#define	CPU_LONGRUN		13	/* LongRun status */
#define	CPU_MAXID		14	/* number of valid machdep ids */
a268 1
	{ "longrun", CTLTYPE_STRUCT }, \
@


1.50
log
@function for cpuid instruction.  pulled from longrun into generic code.
ok deraadt mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.49 2003/06/02 23:27:47 millert Exp $	*/
d190 1
a190 1
#if defined(MATH_EMULATE) || defined(GPL_MATH_EMULATE)
@


1.49
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.48 2003/05/27 23:52:01 fgsch Exp $	*/
d169 1
@


1.48
log
@change .byte for the correct opcodes now that gas can handle'em.
art@@ toby@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.47 2003/05/14 22:08:04 tedu Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.47
log
@Support for Transmeta CPU power management, called LongRun.
option LONGRUN enables a new sysctl, allowing a userland program
to read the current CPU frequency and voltage and also set
the mininum and maximum frequencies to operate between, and switch
between performance mode and battery mode.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.46 2003/03/28 00:49:13 miod Exp $	*/
d108 1
a108 1
					 ".byte 0xf, 0x31\n"		\
@


1.46
log
@Add a sysctl to option USER_LDT, to control its behaviour, which will be
disabled by default.

Enable with sysctl -w machdep.userldt=1

This will allow people to use the few ports that require this functionality
to work without requiring the user to recompile a kernel.

The option USER_LDT remains in order to not increase size on the
installation media. It is now enabled in GENERIC.

Per espie@@'s idea, but my diff was much simpler than his; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.45 2003/01/16 04:16:00 art Exp $	*/
d243 2
a244 1
#define	CPU_MAXID		13	/* number of valid machdep ids */
d260 1
@


1.45
log
@Getting rid of vm_offset_t
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.44 2003/01/09 22:27:09 miod Exp $	*/
d200 1
d242 2
a243 1
#define	CPU_MAXID		12	/* number of valid machdep ids */
d258 1
@


1.44
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.43 2002/09/24 00:06:23 nordin Exp $	*/
d210 1
a210 1
void	pmap_bootstrap(vm_offset_t);
@


1.43
log
@Restore pentium_microtime, testing by henning@@, millert@@. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.42 2002/06/07 21:33:43 nordin Exp $	*/
a177 2
short	fusword(u_short *);
int	susword(u_short *t, u_short);
@


1.42
log
@Remove obsolete CLKF_BASEPRI(). ok niklas@@, miod@@ and art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.41 2002/03/14 01:26:33 millert Exp $	*/
d104 1
a104 1
#define CPU_CLOCKUPDATE(otime, ntime)					\
a107 4
					 "movl (%3), %%eax\n"		\
					 "movl %%eax, (%2)\n"		\
					 "movl 4(%3), %%eax\n"		\
					 "movl %%eax, 4(%2)\n"		\
d110 2
a111 7
					 "#%0 %1 %2 %3"			\
					 : "=m" (*otime),		\
					 "=A" (pentium_base_tsc)	\
					 : "c" (otime), "b" (ntime));	\
		}							\
		else {							\
			*(otime) = *(ntime);				\
@


1.41
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.40 2001/12/08 02:24:06 art Exp $	*/
a67 1
#define	CLKF_BASEPRI(frame)	((frame)->if_ppl == 0)
@


1.40
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.39 2001/11/06 18:41:09 art Exp $	*/
d96 1
a96 1
void	delay __P((int));
d102 1
a102 1
void	calibrate_cyclecounter __P((void));
d137 1
a137 1
	void (*cpu_setup) __P((const char *, int, int));
d147 1
a147 1
		void (*cpu_setup) __P((const char *, int, int));
d173 1
a173 1
void fix_f00f __P((void));
d177 1
a177 1
void	dkcsumattach __P((void));
d180 3
a182 3
void	dumpconf __P((void));
void	cpu_reset __P((void));
void	i386_proc0_tss_ldt_init __P((void));
d186 4
a189 4
void	lgdt __P((struct region_descriptor *));
void	fillw __P((short, void *, size_t));
short	fusword __P((u_short *));
int	susword __P((u_short *t, u_short));
d192 3
a194 3
void	savectx __P((struct pcb *));
void	switch_exit __P((struct proc *));
void	proc_trampoline __P((void));
d197 3
a199 3
void	initrtclock __P((void));
void	startrtclock __P((void));
void	rtcdrain __P((void *));
d202 2
a203 2
void	npxdrop __P((void));
void	npxsave __P((void));
d207 1
a207 1
int	math_emulate __P((struct trapframe *));
d212 3
a214 3
void	i386_user_cleanup __P((struct pcb *));
int	i386_get_ldt __P((struct proc *, void *, register_t *));
int	i386_set_ldt __P((struct proc *, void *, register_t *));
d218 2
a219 2
void	isa_defaultirq __P((void));
int	isa_nmi __P((void));
d222 1
a222 1
void	pmap_bootstrap __P((vm_offset_t));
d225 1
a225 1
int	kvtop __P((caddr_t));
d229 1
a229 1
void	vm86_gpfault __P((struct proc *, int));
d234 1
a234 1
void	setconf __P((void));
@


1.40.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.40 2001/12/08 02:24:06 art Exp $	*/
d68 1
d96 1
a96 1
void	delay(int);
d102 1
a102 1
void	calibrate_cyclecounter(void);
d137 1
a137 1
	void (*cpu_setup)(const char *, int, int);
d147 1
a147 1
		void (*cpu_setup)(const char *, int, int);
d173 1
a173 1
void fix_f00f(void);
d177 1
a177 1
void	dkcsumattach(void);
d180 3
a182 3
void	dumpconf(void);
void	cpu_reset(void);
void	i386_proc0_tss_ldt_init(void);
d186 4
a189 4
void	lgdt(struct region_descriptor *);
void	fillw(short, void *, size_t);
short	fusword(u_short *);
int	susword(u_short *t, u_short);
d192 3
a194 3
void	savectx(struct pcb *);
void	switch_exit(struct proc *);
void	proc_trampoline(void);
d197 3
a199 3
void	initrtclock(void);
void	startrtclock(void);
void	rtcdrain(void *);
d202 2
a203 2
void	npxdrop(void);
void	npxsave(void);
d207 1
a207 1
int	math_emulate(struct trapframe *);
d212 3
a214 3
void	i386_user_cleanup(struct pcb *);
int	i386_get_ldt(struct proc *, void *, register_t *);
int	i386_set_ldt(struct proc *, void *, register_t *);
d218 2
a219 2
void	isa_defaultirq(void);
int	isa_nmi(void);
d222 1
a222 1
void	pmap_bootstrap(vm_offset_t);
d225 1
a225 1
int	kvtop(caddr_t);
d229 1
a229 1
void	vm86_gpfault(struct proc *, int);
d234 1
a234 1
void	setconf(void);
@


1.40.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.40.2.1 2002/06/11 03:35:53 art Exp $	*/
d104 1
a104 1
#define CPU_CLOCKUPDATE()						\
d108 4
d114 7
a120 2
					 : "=A" (pentium_base_tsc)	\
					 : );				\
@


1.40.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d178 2
a201 1
extern int user_ldt_enable;
d212 1
a212 1
void	pmap_bootstrap(vaddr_t);
d243 1
a243 3
#define CPU_USERLDT		12
#define	CPU_LONGRUN		13	/* LongRun status */
#define	CPU_MAXID		14	/* number of valid machdep ids */
a257 2
	{ "userldt", CTLTYPE_INT }, \
	{ "longrun", CTLTYPE_STRUCT }, \
@


1.39
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.38 2001/07/13 19:55:41 deraadt Exp $	*/
a222 1
vm_offset_t pmap_map __P((vm_offset_t, vm_offset_t, vm_offset_t, int));
@


1.38
log
@delete duplicate definitions
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.37 2001/06/21 12:57:43 niklas Exp $	*/
a231 3

/* trap.c */
void	child_return __P((struct proc *, struct trapframe));
@


1.37
log
@Finish what Theo started (a char * to void * conversion)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.36 2001/05/05 22:33:48 art Exp $	*/
a125 1
void	delay __P((int));
a179 1
void	delay __P((int));
@


1.36
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.35 2001/04/30 13:23:11 art Exp $	*/
d215 2
a216 2
int	i386_get_ldt __P((struct proc *, char *, register_t *));
int	i386_set_ldt __P((struct proc *, char *, register_t *));
@


1.35
log
@Move proc0's TSS and LDT initialization to a separate function
that's called at the end of configure instead of cpu_startup.

Inspired by NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.34 2001/02/19 04:57:02 ho Exp $	*/
a175 3

/* autoconf.c */
void	configure __P((void));
@


1.34
log
@Avoid losing rtc after suspend/resume on some laptops. Ok provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.33 2001/01/25 18:49:34 mickey Exp $	*/
d187 1
@


1.33
log
@constify cpuid tables
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.32 2001/01/05 04:27:24 marc Exp $	*/
d203 1
@


1.32
log
@
Add i386 specific sysctl to modify halt -p processing, required to make
powerdown work correctly on some processors.   Idea from mickey@@ and
smcho@@tsp.korea.ac.kr.   Tested my me and angelos@@.

Note: If you want to try these out you'll need to

  cd /sys/arch/i386/include &&
sudo install -m 444 -o root -g root cpu.h /usr/include/i386
cd /usr/src/sbin/sysctl && make obj && make && sudo make install

to get a sysctl that understands the new variable (machdep.apmhalt).
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.31 2000/08/02 14:09:59 deraadt Exp $	*/
d164 2
a165 2
extern struct cpu_nocpuid_nameclass i386_nocpuid_cpus[];
extern struct cpu_cpuid_nameclass i386_cpuid_cpus[];
@


1.31
log
@permit build with HZ user-defined; <wd@@ics.nara-wu.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.30 2000/06/05 12:43:30 art Exp $	*/
d162 1
d259 2
a260 1
#define	CPU_MAXID		11	/* number of valid machdep ids */
d274 1
@


1.30
log
@Argh. forgot this when committing the reaper stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29 2000/01/29 04:27:48 mickey Exp $	*/
d103 1
d124 1
@


1.29
log
@separate clock init, to be called upon resume from apm sleeps
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.28 1999/09/12 19:44:04 weingart Exp $	*/
a56 1
#define	cpu_wait(p)			/* nothing */
@


1.29.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.34 2001/02/19 04:57:02 ho Exp $	*/
d57 1
a103 1
#ifndef	HZ
a124 1
#endif
a160 1
extern int cpu_apmhalt;
d162 2
a163 2
extern const struct cpu_nocpuid_nameclass i386_nocpuid_cpus[];
extern const struct cpu_cpuid_nameclass i386_cpuid_cpus[];
a200 1
void	rtcdrain __P((void *));
d257 1
a257 2
#define CPU_APMHALT		11	/* halt -p hack */
#define	CPU_MAXID		12	/* number of valid machdep ids */
a270 1
	{ "apmhalt", CTLTYPE_INT }, \
@


1.29.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.1 2001/04/18 16:07:29 niklas Exp $	*/
d177 3
a186 1
void	i386_proc0_tss_ldt_init __P((void));
d217 2
a218 2
int	i386_get_ldt __P((struct proc *, void *, register_t *));
int	i386_set_ldt __P((struct proc *, void *, register_t *));
@


1.29.2.3
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.2 2001/07/04 10:16:46 niklas Exp $	*/
a51 9
#ifdef MULTIPROCESSOR
#include <machine/i82489reg.h>
#include <machine/i82489var.h>

/* XXX for now... */
#define NLAPIC 1

#endif

d67 4
a70 82
#include <sys/device.h>
#include <sys/lock.h>                  /* will also get LOCKDEBUG */
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/sched.h>

/* XXX stuff to move to cpuvar.h later */
struct cpu_info {
	struct device ci_dev;		/* pointer to our device */
	struct schedstate_percpu ci_schedstate; /* scheduler state */
	
	/* 
	 * Public members. 
	 */
	struct proc *ci_curproc; 	/* current owner of the processor */
	struct simplelock ci_slock;	/* lock on this data structure */
	cpuid_t ci_cpuid; 		/* our CPU ID */
#if defined(DIAGNOSTIC) || defined(LOCKDEBUG)
	u_long ci_spin_locks;		/* # of spin locks held */
	u_long ci_simple_locks;		/* # of simple locks held */
#endif

	/*
	 * Private members.
	 */
	struct proc *ci_fpcurproc;	/* current owner of the FPU */
	int ci_fpsaving;		/* save in progress */
	struct pcb *ci_curpcb;		/* VA of current HW PCB */
	struct pcb *ci_idle_pcb;	/* VA of current PCB */

	paddr_t ci_idle_pcb_paddr;	/* PA of idle PCB */
	u_long ci_flags;		/* flags; see below */
	u_int32_t ci_ipis; 		/* interprocessor interrupts pending */
	int sc_apic_version;  		/* local APIC version */
	
	u_int32_t	ci_level;
	u_int32_t	ci_vendor[4];
	u_int32_t	ci_signature;		/* X86 cpuid type */
	u_int32_t	ci_feature_flags;	/* X86 CPUID feature bits */
	u_int32_t	cpu_class;		/* CPU class */

	struct cpu_functions *ci_func;	/* start/stop functions */
	void (*cpu_setup) __P((const char *, int, int));	/* proc-dependant init */

	int		ci_want_resched;
	int		ci_astpending;
};
	
/*
 * Processor flag notes: The "primary" CPU has certain MI-defined
 * roles (mostly relating to hardclock handling); we distinguish
 * betwen the processor which booted us, and the processor currently
 * holding the "primary" role just to give us the flexibility later to
 * change primaries should we be sufficiently twisted.  
 */

#define	CPUF_BSP	0x0001		/* CPU is the original BSP */
#define	CPUF_AP		0x0002		/* CPU is an AP */
#define	CPUF_SP		0x0004		/* CPU is only processor */
#define	CPUF_PRIMARY	0x0008		/* CPU is active primary processor */
#define	CPUF_APIC_CD	0x0010		/* CPU has apic configured */

#define	CPUF_PRESENT	0x1000		/* CPU is present */
#define	CPUF_RUNNING	0x2000		/* CPU is running */

#ifdef MULTIPROCESSOR

#define I386_MAXPROCS		0x10
#define CPU_STARTUP(_ci)	((_ci)->ci_func->start(_ci))
#define CPU_STOP(_ci)		((_ci)->ci_func->stop(_ci))

#define cpu_number()		(i82489_readreg(LAPIC_ID)>>LAPIC_ID_SHIFT)
#define curcpu()		(cpu_info[cpu_number()])
#define curpcb			curcpu()->ci_curpcb

extern struct cpu_info	*cpu_info[I386_MAXPROCS];
extern u_long		 cpus_running;

extern void cpu_boot_secondary_processors __P((void));

#define want_resched (curcpu()->ci_want_resched)
#define astpending (curcpu()->ci_astpending)
a72 15
 * Preemt the current process if in interrupt from user monre,
 * or after the current trap/syscall if in system mode.
 */
extern void need_resched __P((void));

extern void (*delay_func) __P((int));
struct timeval;
extern void (*microtime_func) __P((struct timeval *));

#define	DELAY(x)	(*delay_func)(x)
#define delay(x)	(*delay_func)(x)
#define microtime(tv)	(*microtime_func)(tv)

#else /* MULTIPROCESSOR */
/*
a78 22
#define cpu_number()		0

/*
 * We need a machine-independent name for this.
 */
#define	DELAY(x)		delay(x)
void	delay __P((int));

/*
 * definitions of cpu-dependent requirements
 * referenced in generic code
 */
#define	cpu_swapin(p)			/* nothing */
#define	cpu_wait(p)			/* nothing */

#endif /* MULTIPROCESSOR */

#define	CLKF_USERMODE(frame)	USERMODE((frame)->if_cs, (frame)->if_eflags)
#define	CLKF_BASEPRI(frame)	((frame)->if_ppl == 0)
#define	CLKF_PC(frame)		((frame)->if_eip)
#define	CLKF_INTR(frame)	(IDXSEL((frame)->if_cs) == GICODE_SEL)

d92 6
d181 1
a181 1
/* XXX MULTIPROCESSOR void	delay __P((int)); */
a184 1
void	i386_init_pcb_tss_ldt __P((struct pcb *));
a201 3
void	i8254_delay __P((int));
void	i8254_microtime __P((struct timeval *));
void	i8254_initclocks __P((void));
d204 2
a205 3
void	npxdrop __P((struct proc *));
void	npxsave_proc __P((struct proc *));
void	npxsave_cpu __P((struct cpu_info *));
@


1.29.2.4
log
@Declare isa_nodefaultirq
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a343 1
void	isa_nodefaultirq __P((void));
@


1.29.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.4 2001/07/16 21:40:38 niklas Exp $	*/
d244 1
d299 1
@


1.29.2.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d356 3
@


1.29.2.7
log
@Merge in trunk
@
text
@d347 1
@


1.29.2.8
log
@Merge in -current from about a week ago
@
text
@d187 1
a187 1
void	delay(int);
d220 1
a220 1
void	calibrate_cyclecounter(void);
d255 1
a255 1
	void (*cpu_setup)(const char *, int, int);
d265 1
a265 1
		void (*cpu_setup)(const char *, int, int);
d291 1
a291 1
void fix_f00f(void);
d295 1
a295 1
void	dkcsumattach(void);
d298 4
a301 4
void	dumpconf(void);
void	cpu_reset(void);
void	i386_proc0_tss_ldt_init(void);
void	i386_init_pcb_tss_ldt(struct pcb *);
d305 4
a308 4
void	lgdt(struct region_descriptor *);
void	fillw(short, void *, size_t);
short	fusword(u_short *);
int	susword(u_short *t, u_short);
d311 3
a313 3
void	savectx(struct pcb *);
void	switch_exit(struct proc *);
void	proc_trampoline(void);
d316 6
a321 6
void	initrtclock(void);
void	startrtclock(void);
void	rtcdrain(void *);
void	i8254_delay(int);
void	i8254_microtime(struct timeval *);
void	i8254_initclocks(void);
d324 3
a326 3
void	npxdrop(struct proc *);
void	npxsave_proc(struct proc *);
void	npxsave_cpu(struct cpu_info *);
d330 1
a330 1
int	math_emulate(struct trapframe *);
d335 3
a337 3
void	i386_user_cleanup(struct pcb *);
int	i386_get_ldt(struct proc *, void *, register_t *);
int	i386_set_ldt(struct proc *, void *, register_t *);
d341 3
a343 3
void	isa_defaultirq(void);
void	isa_nodefaultirq(void);
int	isa_nmi(void);
d346 1
a346 1
void	pmap_bootstrap(vm_offset_t);
d349 1
a349 1
int	kvtop(caddr_t);
d353 1
a353 1
void	vm86_gpfault(struct proc *, int);
d358 1
a358 1
void	setconf(void);
@


1.29.2.9
log
@Sync the SMP branch with 3.3
@
text
@d199 1
d223 1
a223 1
#define CPU_CLOCKUPDATE()						\
d227 4
d233 7
a239 2
					 : "=A" (pentium_base_tsc)	\
					 : );				\
d307 2
d346 1
a346 1
void	pmap_bootstrap(vaddr_t);
@


1.29.2.10
log
@Move TSS selector from the PCB to MD part of proc and to cpu_info.
Maintain a list of CPUs and provide an iterator for it.
Ifdef out IPI debugging.  Call pmap_{de,}activate as part of context switching.
Mostly from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.9 2003/03/27 23:26:55 niklas Exp $	*/
d84 1
a84 1
	struct device ci_dev;		/* our device */
a85 1
	struct cpu_info *ci_next;	/* next cpu */
a104 1
	int ci_idle_tss_sel;		/* TSS selector of idle PCB */
a121 2

	volatile u_int32_t ci_tlb_ipi_mask;
a140 12
/*
 * We statically allocate the CPU info for the primary CPU (or,
 * the only CPU on uniprocessors), and the primary CPU is the
 * first CPU on the CPU info list.
 */
extern struct cpu_info cpu_info_primary;
extern struct cpu_info *cpu_info_list;

#define	CPU_INFO_ITERATOR		int
#define	CPU_INFO_FOREACH(cii, ci)	cii = 0, ci = cpu_info_list; \
					ci != NULL; ci = ci->ci_next

a154 1
extern void cpu_init_idle_pcbs __P((void));
d291 1
a291 1
void	i386_init_pcb_tss_ldt(struct cpu_info *);
@


1.29.2.11
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.10 2003/04/11 16:12:57 niklas Exp $	*/
a339 1
extern int user_ldt_enable;
d382 1
a382 2
#define CPU_USERLDT		12
#define	CPU_MAXID		13	/* number of valid machdep ids */
a396 1
	{ "userldt", CTLTYPE_INT }, \
@


1.29.2.12
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.11 2003/05/13 19:42:08 ho Exp $	*/
d48 1
a49 1
#include <machine/psl.h>
a103 3

	volatile u_int32_t ci_tlb_ipi_mask;

d125 1
a125 1
	union descriptor *ci_gdt;
@


1.29.2.13
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d387 1
a387 2
#define	CPU_LONGRUN		13	/* LongRun status */
#define	CPU_MAXID		14	/* number of valid machdep ids */
a402 1
	{ "longrun", CTLTYPE_STRUCT }, \
@


1.29.2.14
log
@Some i386-specific stuff:
Stop other CPUs when entering ddb
'machine sysregs' shows system registers not usually used by applications
'machine cpuinfo' shows the status of the processors
'machine startcpu n' starts CPU n
'machine stopcpu n' stops CPU n
'machine ddbcpu n' transfers ddb control to CPU n (not very useful yet
though since the second processor can't use the keyboard...)

Niklas said that I should test this first to at least make sure it
compiles, but I'm too anxious to do my first commit. :)
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.13 2003/05/16 00:29:39 niklas Exp $	*/
a128 7

	volatile int ci_ddb_paused;	/* paused due to other proc in ddb */
#define CI_DDB_RUNNING		0
#define CI_DDB_SHOULDSTOP	1
#define CI_DDB_STOPPED		2
#define CI_DDB_ENTERDDB		3
#define CI_DDB_INDDB		4
d130 1
a130 1

@


1.29.2.15
log
@Go back to defining simplelocks as noops, even if MULTIPROCESSOR.  Instead use
a new real simple recursive-lock capable lock implementation for the few
necessary locks (kernel, scheduler, tlb shootdown, printf and ddb MP).
This because we cannot trust the old fine-grained locks spread out all over
our kernel, and not really tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.14 2003/05/17 16:07:37 andreas Exp $	*/
a75 5
/* XXX Needs to be before lock.h inclusion. */
#ifdef MULTIPROCESSOR
#define cpu_number()		(i82489_readreg(LAPIC_ID)>>LAPIC_ID_SHIFT)
#endif

d173 1
@


1.29.2.16
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.15 2003/05/18 17:41:16 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
d257 1
a257 1
					 "rdtsc\n"			\
@


1.29.2.17
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a294 1
extern int cpu_ecxfeature;
a313 4
extern int i386_use_fxsave;
extern int i386_has_sse;
extern int i386_has_sse2;

a318 1
void	cpuid(u_int32_t, u_int32_t *);
a337 20
/* est.c */
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
void	est_init(const char *);
int     est_cpuspeed(void *, size_t *, void *, size_t);
int     est_setperf(void *, size_t *, void *, size_t);
#endif

/* longrun.c */
#if !defined(SMALL_KERNEL) && defined(I586_CPU)
void	longrun_init(void);
int	longrun_cpuspeed(void *, size_t *, void *, size_t);
int	longrun_setperf(void *, size_t *, void *, size_t);
#endif

/* p4tcc.c */
#if !defined(SMALL_KERNEL) && defined(I686_CPU)
void	p4tcc_init(int, int);
int     p4tcc_setperf(void *, size_t *, void *, size_t);
#endif

d343 1
a343 1
#if defined(GPL_MATH_EMULATE)
d351 1
d394 2
a395 5
#define CPU_OSFXSR		13	/* uses FXSAVE/FXRSTOR */
#define CPU_SSE			14	/* supports SSE */
#define CPU_SSE2		15	/* supports SSE2 */
#define CPU_XCRYPT		16	/* supports VIA xcrypt in userland */
#define CPU_MAXID		17	/* number of valid machdep ids */
d411 1
a411 4
	{ "osfxsr", CTLTYPE_INT }, \
	{ "sse", CTLTYPE_INT }, \
	{ "sse2", CTLTYPE_INT }, \
	{ "xcrypt", CTLTYPE_INT }, \
@


1.29.2.18
log
@Import NetBSD updates to NPX logic, and IPI API
@
text
@d366 2
a367 2
void	npxsave_proc(struct proc *, int);
void	npxsave_cpu(struct cpu_info *, int);
@


1.29.2.19
log
@only get sys/systm in _KERNEL
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.18 2004/02/20 22:19:55 niklas Exp $	*/
a78 1
#ifdef _KERNEL
a79 1
#endif
@


1.29.2.20
log
@Some merged code from NetBSD, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.19 2004/02/21 02:48:01 niklas Exp $	*/
a96 1
	u_int ci_apicid;		/* our APIC ID */
@


1.29.2.21
log
@Add some fields to cpu_info to manage interrupts, also a self pointer
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.20 2004/03/14 22:08:21 niklas Exp $	*/
d72 5
a84 2
struct intrsource;

a87 1
	struct cpu_info *ci_self;	/* pointer to this structure */
a114 7
	struct intrsource *ci_isources[MAX_INTR_SOURCES];
	u_int32_t	ci_ipending;
	int		ci_ilevel;
	int		ci_idepth;
	u_int32_t	ci_imask[NIPL];
	u_int32_t	ci_iunmask[NIPL];

d173 1
a173 2
#define I386_MAXPROCS		32	/* because we use a bitmask */

a175 1
#define CPU_START_CLEANUP(_ci)	((_ci)->ci_func->cleanup(_ci))
a176 5
#ifdef MULTIPROCESSOR
#define cpu_number()		(i82489_readreg(LAPIC_ID)>>LAPIC_ID_SHIFT)
#else
#define cpu_number()		0
#endif
a446 8

/*
 * This needs to be included late since it relies on definitions higher
 * up in this file.
 */
#if defined(MULTIPROCESSOR) && defined(_KERNEL)
#include <sys/mplock.h>
#endif
@


1.29.2.22
log
@Macro for checking if this is the boot cpu
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.21 2004/03/18 02:09:28 niklas Exp $	*/
a190 2

#define CPU_IS_PRIMARY(ci)	((ci)->ci_flags & CPUF_PRIMARY)
@


1.29.2.23
log
@Make a few scheduling globals per-cpu, mostly NetBSD code
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.22 2004/03/30 09:09:40 niklas Exp $	*/
a202 4
#define runtime (curcpu()->ci_schedstate.spc_runtime)
#define rrticks (curcpu()->ci_schedstate.spc_rrticks)
#define schedclk (curcpu()->ci_schedstate.spc_schedticks)

d207 1
a207 1
extern void need_resched __P((struct cpu_info *));
d223 1
a223 1
#define	need_resched(ci)	(want_resched = 1, setsoftast())
@


1.29.2.24
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d368 2
a369 2
int     est_cpuspeed(int *);
int     est_setperf(int);
d375 2
a376 2
int	longrun_cpuspeed(int *);
int	longrun_setperf(int);
d382 1
a382 1
int     p4tcc_setperf(int);
a383 4

void	k6_powernow_init(void);
int	k6_powernow_setperf(int);

@


1.29.2.25
log
@Remove redundant #ifdef MULTIPROCESSOR and add some missing
defines for !MULTIPROCESSOR.

ok niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.24 2004/06/05 23:09:00 niklas Exp $	*/
d184 1
d186 3
d213 3
a215 1
#else /* MULTIPROCESSOR */
d217 3
a219 1
#define I386_MAXPROCS		1
d221 1
d230 6
a235 1
#define	curcpu()		(&cpu_info_primary)
d244 1
a244 1
#endif /* !MULTIPROCESSOR */
a261 11

/*
 * We need a machine-independent name for this.
 */
extern void (*delay_func)(int);
struct timeval;
extern void (*microtime_func)(struct timeval *);

#define	DELAY(x)		(*delay_func)(x)
#define delay(x)		(*delay_func)(x)
#define microtime(tv)		(*microtime_func)(tv)
@


1.29.2.26
log
@Err. Actually free the tss in !MP case too. 8k forks is not enough for
anyone.
markus@@ niklas@@ ok
grange@@ "blame me"
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.25 2004/06/06 18:43:16 grange Exp $	*/
d228 1
@


1.29.2.27
log
@sync to head
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a335 2
extern void (*update_cpuspeed)(void);

d364 1
d371 1
@


1.29.2.28
log
@fix includes:
The following patches clean up the build for userland, systat/vmstat build,
systm.h and sched.h should not be picked up by these userland programs,
but they define _KERNEL.

intrdefs.h is needed to build the kernel after the include removals
(interdefs.h is present in cpu.h on amd64 too)

add 'struct cpu_info' to quiet a bunch of warnings in userland in npx.h
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.27 2004/06/07 20:41:10 niklas Exp $	*/
a46 1
#include <machine/intrdefs.h>
d74 3
d78 1
@


1.29.2.29
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d182 2
a183 1
#define	curcpu()		(cpu_info[cpu_number()])
d193 13
d210 7
a219 2
#define CPU_IS_PRIMARY(ci)	1

d226 1
a226 12
#endif

#define curpcb			curcpu()->ci_curpcb

#define want_resched (curcpu()->ci_want_resched)
#define astpending (curcpu()->ci_astpending)

/*
 * Preemt the current process if in interrupt from user monre,
 * or after the current trap/syscall if in system mode.
 */
extern void need_resched __P((struct cpu_info *));
@


1.29.2.30
log
@un__Pee
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.29.2.29 2004/06/10 11:40:25 niklas Exp $	*/
d129 1
a129 1
	void (*cpu_setup)(const char *, int, int);	/* proc-dependant init */
d189 2
a190 2
extern void cpu_boot_secondary_processors(void);
extern void cpu_init_idle_pcbs(void);
d218 1
a218 1
extern void need_resched(struct cpu_info *);
@


1.28
log
@Fix rootdev handling, use disk checksums to find the device we were booted
from.  Hopefully this will fix all the hangs/panics where the root device
was not found.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.27 1999/07/06 07:59:54 deraadt Exp $	*/
d199 1
@


1.27
log
@for CTRL-ALT-DEL, send SIGUSR1 to initproc
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.26 1999/03/08 23:47:25 downsj Exp $	*/
d177 3
@


1.26
log
@Add support for CPUID level 2.  This is used to determine the L2 cache size
on Intel processors; print out the correct CPU name and cache size at boot.

Also clean up the feature flags, including PPro errata.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.25 1999/02/23 04:10:12 marc Exp $	*/
d252 2
a253 1
#define	CPU_MAXID		10	/* number of valid machdep ids */
d266 1
@


1.25
log
@apm battery status messages now suppressed until battery life
falls below 'machdep.apmwarn' percent.  This defaults to 10 percent
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.24 1998/08/30 07:31:32 downsj Exp $	*/
d137 1
a137 1
	void (*cpu_setup) __P((const char *, int));
d147 1
a147 1
		void (*cpu_setup) __P((const char *, int));
@


1.24
log
@Add extra cpu_setup argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.23 1998/06/04 05:01:45 downsj Exp $	*/
d160 1
d251 2
a252 1
#define	CPU_MAXID		9	/* number of valid machdep ids */
d264 1
@


1.23
log
@cpuid return values for sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.22 1998/05/25 06:52:36 downsj Exp $	*/
d137 1
a137 1
	void (*cpu_setup) __P((const char *));
d147 1
a147 1
		void (*cpu_setup) __P((const char *));
@


1.22
log
@Add support for feature bit listing; fix #defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.21 1998/03/01 00:37:33 niklas Exp $	*/
d247 4
a250 1
#define	CPU_MAXID		6	/* number of valid machdep ids */
d259 3
@


1.21
log
@Merge of MACHINE_NEW_CONTIG (aka MNN) code from Chuck Cranor,
<chuck@@openbsd.org>. This code is as of yet disabled on all platforms,
actually not yet supported on more than mvme68k, although other
platforms are expected soon, as code is already available.
This code makes handling of multiple physical memory regions
consistent over all platforms, as well as keeping the performance of
maintaining a single continuous memory chunk.  It is also a
requirement for the upcoming UVM replacement VM system.

What I did in this merge: just declared the pmap_map function in a
MD include file per port that needs it.  It's not an exported pmap
interface, says Chuck.  It ended up in differnt include files on
differnet ports, as I tried to follow the current policy on a per-arch
basis.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.20 1998/02/17 23:49:31 matthieu Exp $	*/
d149 5
@


1.20
log
@add an in-kernel /dev/xf86 aperture driver. the 'machdep.allowaperture'
sysctl controls whether it is permitted to access it. This sysctl can only
be manipulated when securelevel=0, hence in sysctl.conf
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.19 1997/12/17 08:54:51 downsj Exp $	*/
d211 4
@


1.19
log
@New CPU detection code, from NetBSD, with some machdep changes from myself.

Add I686_CPU to your configs if you have a PPro...
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.18 1997/12/09 03:36:41 deraadt Exp $	*/
d237 2
a238 1
#define	CPU_MAXID		5	/* number of valid machdep ids */
d246 1
@


1.18
log
@Intel P5 f00f workaround; weingart & who knows who else
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.17 1997/10/25 21:47:27 mickey Exp $	*/
d99 1
a99 1
#ifdef I586_CPU
d132 17
a148 3
struct cpu_nameclass {
	char *cpu_name;
	int  cpu_class;
d154 6
a159 2
extern struct cpu_nameclass i386_cpus[];
#ifdef I586_CPU
d161 1
d163 1
@


1.17
log
@fix blk2chr,chr2blk
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.16 1997/10/25 08:36:42 mickey Exp $	*/
d143 4
@


1.16
log
@do blk<-->chr dev_t conversions through the sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: cpu.h,v 1.15 1997/09/27 06:31:32 mickey Exp $	*/
d219 2
a220 2
	{ "blk2chr", CTLTYPE_INT }, \
	{ "chr2blk", CTLTYPE_INT }, \
@


1.15
log
@add ID, we have mods here
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d211 3
a213 1
#define	CPU_MAXID		3	/* number of valid machdep ids */
d219 2
@


1.14
log
@branch the bios tree inside the machdep
@
text
@d1 1
@


1.13
log
@support new boots
add to your config:
bios0 at mainbus0
apm0 at mainbus0	# (if you are using APM)
@
text
@d209 2
a210 5
#define	CPU_BIOSDEV		2	/* int: BIOS boot device */
#define	CPU_BIOSGEOMETRY	3	/* int: BIOS boot device geometry */
#define	CPU_CNVMEM		4	/* int: amount of conventional memory */
#define	CPU_EXTMEM		5	/* int: amount of extended memory */
#define	CPU_MAXID		6	/* number of valid machdep ids */
d215 1
a215 4
	{ "biosdev", CTLTYPE_INT }, \
	{ "biosgeo", CTLTYPE_INT }, \
	{ "cnvmem", CTLTYPE_INT }, \
	{ "extmem", CTLTYPE_INT }, \
@


1.12
log
@Allow kern_clock.c to see interrupt frames on i386
@
text
@d209 5
a213 1
#define	CPU_MAXID		2	/* number of valid machdep ids */
d218 4
@


1.11
log
@kvtop proto
@
text
@d70 1
a70 1
#define	CLKF_INTR(frame)	(0)	/* XXX should have an interrupt stack */
@


1.10
log
@decl calibrate_cyclecounter, fusword, susword
@
text
@d187 3
@


1.9
log
@Add:
	* GPL_MATH_EMULATE: fpemul
	* ALWAYS_MATH_EMULATE: causes npx probe to always fail.
	* better fp context in struct pcb.
@
text
@d102 1
d156 2
@


1.8
log
@Added a pctr pseudo-device for accessing the Pentium performance counters,
and a program pctrctl to set the counter functions.
@
text
@d168 1
a168 1
#ifdef MATH_EMULATE
@


1.7
log
@proto fillw
@
text
@d102 19
a120 21
#define CPU_CLOCKUPDATE(otime, ntime) \
	do { \
		if (pentium_mhz) { \
			__asm __volatile("cli\n" \
					 "movl (%2), %%eax\n" \
					 "movl %%eax, (%1)\n" \
					 "movl 4(%2), %%eax\n" \
					 "movl %%eax, 4(%1)\n" \
					 "movl $0x10, %%ecx\n" \
					 "xorl %%eax, %%eax\n" \
					 "movl %%eax, %%edx\n" \
					 ".byte 0xf, 0x30\n" \
					 "sti\n" \
					 "#%0%1%2" \
					 : "=m" (*otime) \
					 : "c" (otime), "b" (ntime) \
					 : "ax", "cx", "dx"); \
		} \
		else { \
			*(otime) = *(ntime); \
		} \
@


1.6
log
@sync with 0504; prototype changes
@
text
@d1 1
a1 1
/*	$NetBSD: cpu.h,v 1.34 1996/05/03 19:22:49 christos Exp $	*/
d156 1
a156 1
void	fillw __P((int, caddr_t, size_t));
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$NetBSD: cpu.h,v 1.33 1996/03/29 00:23:28 mycroft Exp $	*/
d144 29
d174 26
@


1.4
log
@Cleanups & fixes from latest NetBSD primarily to run doscmd, etc.
GENERIC added to the compile/.cvsignore (it is used for 'make links'
for example), thus conf/GENERIC should appear magically ...
@
text
@d1 1
a1 1
/*	$NetBSD: cpu.h,v 1.32 1995/12/24 01:08:02 mycroft Exp $	*/
d96 1
@


1.3
log
@Allow use of Pentium cycle counter for high-precision time keeping;
from FreeBSD
@
text
@d124 1
@


1.2
log
@from netbsd; Enable paging of the user area
@
text
@d97 28
d139 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: cpu.h,v 1.31 1995/10/11 04:20:02 mycroft Exp $	*/
a56 1
#define	cpu_swapout(p)			panic("cpu_swapout: can't get here");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

