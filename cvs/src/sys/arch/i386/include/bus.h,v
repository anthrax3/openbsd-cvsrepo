head	1.67;
access;
symbols
	OPENBSD_6_1:1.66.0.12
	OPENBSD_6_1_BASE:1.66
	OPENBSD_6_0:1.66.0.8
	OPENBSD_6_0_BASE:1.66
	OPENBSD_5_9:1.66.0.4
	OPENBSD_5_9_BASE:1.66
	OPENBSD_5_8:1.66.0.6
	OPENBSD_5_8_BASE:1.66
	OPENBSD_5_7:1.66.0.2
	OPENBSD_5_7_BASE:1.66
	OPENBSD_5_6:1.61.0.4
	OPENBSD_5_6_BASE:1.61
	OPENBSD_5_5:1.60.0.4
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.58.0.2
	OPENBSD_5_4_BASE:1.58
	OPENBSD_5_3:1.57.0.2
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.54.0.6
	OPENBSD_5_2_BASE:1.54
	OPENBSD_5_1_BASE:1.54
	OPENBSD_5_1:1.54.0.4
	OPENBSD_5_0:1.54.0.2
	OPENBSD_5_0_BASE:1.54
	OPENBSD_4_9:1.53.0.2
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.52.0.2
	OPENBSD_4_8_BASE:1.52
	OPENBSD_4_7:1.51.0.2
	OPENBSD_4_7_BASE:1.51
	OPENBSD_4_6:1.49.0.4
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.46.0.2
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.43.0.2
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.42.0.2
	OPENBSD_4_3_BASE:1.42
	OPENBSD_4_2:1.40.0.4
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.40.0.2
	OPENBSD_4_1_BASE:1.40
	OPENBSD_4_0:1.39.0.2
	OPENBSD_4_0_BASE:1.39
	OPENBSD_3_9:1.37.0.4
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.37.0.2
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.36.0.4
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.36.0.2
	OPENBSD_3_6_BASE:1.36
	SMP_SYNC_A:1.36
	SMP_SYNC_B:1.36
	OPENBSD_3_5:1.35.0.4
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	UBC_SYNC_A:1.35
	OPENBSD_3_3:1.34.0.2
	OPENBSD_3_3_BASE:1.34
	OPENBSD_3_2:1.33.0.4
	OPENBSD_3_2_BASE:1.33
	OPENBSD_3_1:1.33.0.2
	OPENBSD_3_1_BASE:1.33
	UBC_SYNC_B:1.33
	UBC:1.31.0.2
	UBC_BASE:1.31
	OPENBSD_3_0:1.30.0.2
	OPENBSD_3_0_BASE:1.30
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_8:1.22.0.2
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.20.0.2
	OPENBSD_2_7_BASE:1.20
	SMP:1.18.0.4
	SMP_BASE:1.18
	kame_19991208:1.18
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.67
date	2017.05.08.00.27.45;	author dlg;	state Exp;
branches;
next	1.66;
commitid	miRwMNEodfMJO0uz;

1.66
date	2015.02.27.18.59.43;	author guenther;	state Exp;
branches;
next	1.65;
commitid	3WcclmwzF3bKhD1B;

1.65
date	2015.01.24.15.13.55;	author kettenis;	state Exp;
branches;
next	1.64;
commitid	Ol0pICcR5PormuCL;

1.64
date	2014.10.17.20.37.57;	author sthen;	state Exp;
branches;
next	1.63;
commitid	s7jB18TtgTTta5r7;

1.63
date	2014.10.17.19.35.32;	author sthen;	state Exp;
branches;
next	1.62;
commitid	FcjWDvloUpMtxk2V;

1.62
date	2014.10.17.01.46.26;	author dlg;	state Exp;
branches;
next	1.61;
commitid	IJJrXsuNXPDjHg1o;

1.61
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.60;

1.60
date	2013.12.23.20.32.31;	author kettenis;	state Exp;
branches;
next	1.59;

1.59
date	2013.12.12.21.04.50;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2013.03.17.21.49.00;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2013.01.29.01.15.57;	author dlg;	state Exp;
branches;
next	1.56;

1.56
date	2012.12.04.20.51.10;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2012.09.30.10.17.46;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2011.03.23.16.54.35;	author pirofti;	state Exp;
branches;
next	1.53;

1.53
date	2010.09.06.19.05.48;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2010.04.08.00.55.25;	author oga;	state Exp;
branches;
next	1.51;

1.51
date	2009.07.30.21.39.15;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2009.07.26.18.48.55;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2009.06.06.05.43.13;	author oga;	state Exp;
branches;
next	1.48;

1.48
date	2009.04.20.00.42.06;	author oga;	state Exp;
branches;
next	1.47;

1.47
date	2009.03.10.15.03.17;	author oga;	state Exp;
branches;
next	1.46;

1.46
date	2009.02.05.01.13.21;	author oga;	state Exp;
branches;
next	1.45;

1.45
date	2008.12.03.15.46.06;	author oga;	state Exp;
branches;
next	1.44;

1.44
date	2008.11.22.17.45.20;	author oga;	state Exp;
branches;
next	1.43;

1.43
date	2008.06.26.05.42.10;	author ray;	state Exp;
branches;
next	1.42;

1.42
date	2007.09.01.03.41.17;	author marco;	state Exp;
branches;
next	1.41;

1.41
date	2007.08.22.21.28.41;	author marco;	state Exp;
branches;
next	1.40;

1.40
date	2007.02.20.21.15.01;	author tom;	state Exp;
branches;
next	1.39;

1.39
date	2006.04.27.15.37.53;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2006.04.27.15.17.16;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.25.18.29.58;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.04.17.06.33;	author grange;	state Exp;
branches;
next	1.35;

1.35
date	2003.04.17.03.42.14;	author drahn;	state Exp;
branches;
next	1.34;

1.34
date	2003.01.16.04.16.00;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.07.18.08.08;	author jason;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.05.17.25.57;	author art;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2001.07.30.14.15.59;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.25.23.03.43;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.08.18.19.44;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2001.02.06.23.13.31;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2001.02.06.23.01.32;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.04.06.51.14;	author aaron;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.04.01.49.21;	author aaron;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.03.21.55.37;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2000.08.05.22.03.36;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.27.16.33.39;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.08.05.50.50;	author aaron;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.15.03.56.49;	author todd;	state Exp;
branches;
next	1.18;

1.18
date	99.09.17.09.57.12;	author espie;	state Exp;
branches
	1.18.4.1;
next	1.17;

1.17
date	99.08.09.12.05.29;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	99.08.04.23.17.40;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.03.09.15.39.07;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	99.01.31.14.56.01;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	98.10.04.22.33.41;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	98.09.06.23.10.57;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	98.02.08.04.14.13;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	98.01.20.18.40.17;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	98.01.17.09.58.39;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.07.05.19.29.51;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.11.28.23.37.38;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.11.12.22.46.27;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.07.31.01.45.53;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.05.07.07.22.03;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.27.22.18.16;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.22.16.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.04.18.19.21.33;	author niklas;	state Exp;
branches;
next	;

1.18.4.1
date	2000.03.24.09.07.40;	author niklas;	state Exp;
branches;
next	1.18.4.2;

1.18.4.2
date	2001.04.18.16.07.29;	author niklas;	state Exp;
branches;
next	1.18.4.3;

1.18.4.3
date	2001.07.04.10.16.46;	author niklas;	state Exp;
branches;
next	1.18.4.4;

1.18.4.4
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.18.4.5;

1.18.4.5
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.18.4.6;

1.18.4.6
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.18.4.7;

1.18.4.7
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.18.4.8;

1.18.4.8
date	2003.05.13.19.42.08;	author ho;	state Exp;
branches;
next	1.18.4.9;

1.18.4.9
date	2004.06.05.23.09.00;	author niklas;	state Exp;
branches;
next	;

1.31.2.1
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.67
log
@add a BUS_DMA_64BIT flag to bus_dma on all our archs.

this is so drivers can advertise that they can handle 64 dma addresses
to the platform. it may choose to handle dmamaps differently based
on this flag.

tweaks and ok tom@@
ok kettenis@@
@
text
@/*	$OpenBSD: bus.h,v 1.66 2015/02/27 18:59:43 guenther Exp $	*/
/*	$NetBSD: bus.h,v 1.6 1996/11/10 03:19:25 thorpej Exp $	*/

/*-
 * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1996 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1996 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1996 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_BUS_H_
#define _MACHINE_BUS_H_

#include <sys/mutex.h>
#include <sys/tree.h>

#include <machine/pio.h>

/*
 * Bus address and size types
 */
typedef u_long bus_addr_t;
typedef u_long bus_size_t;

/*
 * Access methods for bus resources and address space.
 */
struct	i386_bus_space_ops;
typedef	const struct i386_bus_space_ops *bus_space_tag_t;
typedef	u_long bus_space_handle_t;

int	bus_space_map(bus_space_tag_t t, bus_addr_t addr,
	    bus_size_t size, int flags, bus_space_handle_t *bshp);
/* like bus_space_map(), but without extent map checking/allocation */
int	_bus_space_map(bus_space_tag_t t, bus_addr_t addr,
	    bus_size_t size, int flags, bus_space_handle_t *bshp);
void	bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size);
/* like bus_space_unmap(), but without extent map deallocation */
void	_bus_space_unmap(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, bus_addr_t *);
int	bus_space_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp);
paddr_t	bus_space_mmap(bus_space_tag_t, bus_addr_t, off_t, int, int);

int	bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart,
	    bus_addr_t rend, bus_size_t size, bus_size_t align,
	    bus_size_t boundary, int flags, bus_addr_t *addrp,
	    bus_space_handle_t *bshp);
void	bus_space_free(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size);

struct i386_bus_space_ops {

/*
 *	u_intN_t bus_space_read_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset);
 *
 * Read a 1, 2, 4, or 8 byte quantity from bus space
 * described by tag/handle/offset.
 */
	u_int8_t	(*read_1)(bus_space_handle_t, bus_size_t);
	u_int16_t	(*read_2)(bus_space_handle_t, bus_size_t);
	u_int32_t	(*read_4)(bus_space_handle_t, bus_size_t);

#define bus_space_read_1(_t, _h, _o) ((_t)->read_1((_h), (_o)))
#define bus_space_read_2(_t, _h, _o) ((_t)->read_2((_h), (_o)))
#define bus_space_read_4(_t, _h, _o) ((_t)->read_4((_h), (_o)))

#define bus_space_read_raw_2(t, h, o) \
    bus_space_read_2((t), (h), (o))
#define bus_space_read_raw_4(t, h, o) \
    bus_space_read_4((t), (h), (o))

#if 0
/* Cause a link error for bus_space_read_8 and bus_space_read_raw_8 */
#define	bus_space_read_8(t, h, o)	!!! bus_space_read_8 unimplemented !!!
#define	bus_space_read_raw_8(t, h, o)	!!! bus_space_read_raw_8 unimplemented !!!
#endif

/*
 *	void bus_space_read_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
 *
 * Read `count' 1, 2, 4, or 8 byte quantities from bus space
 * described by tag/handle/offset and copy into buffer provided.
 */

	void		(*read_multi_1)(bus_space_handle_t, bus_size_t,
			    u_int8_t *, bus_size_t);
	void		(*read_multi_2)(bus_space_handle_t, bus_size_t,
			    u_int16_t *, bus_size_t);
	void		(*read_multi_4)(bus_space_handle_t, bus_size_t,
			    u_int32_t *, bus_size_t);

#define bus_space_read_multi_1(_t, _h, _o, _a, _c) \
	((_t)->read_multi_1((_h), (_o), (_a), (_c)))
#define bus_space_read_multi_2(_t, _h, _o, _a, _c) \
	((_t)->read_multi_2((_h), (_o), (_a), (_c)))
#define bus_space_read_multi_4(_t, _h, _o, _a, _c) \
	((_t)->read_multi_4((_h), (_o), (_a), (_c)))

#if 0	/* Cause a link error for bus_space_read_multi_8 */
#define	bus_space_read_multi_8	!!! bus_space_read_multi_8 unimplemented !!!
#endif

/*
 *	void bus_space_read_raw_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_int8_t *addr, size_t count);
 *
 * Read `count' bytes in 2, 4 or 8 byte wide quantities from bus space
 * described by tag/handle/offset and copy into buffer provided.  The buffer
 * must have proper alignment for the N byte wide entities.  Furthermore
 * possible byte-swapping should be done by these functions.
 */

#define	bus_space_read_raw_multi_2(t, h, o, a, c) \
    bus_space_read_multi_2((t), (h), (o), (u_int16_t *)(a), (c) >> 1)
#define	bus_space_read_raw_multi_4(t, h, o, a, c) \
    bus_space_read_multi_4((t), (h), (o), (u_int32_t *)(a), (c) >> 2)

#if 0	/* Cause a link error for bus_space_read_raw_multi_8 */
#define	bus_space_read_raw_multi_8 \
    !!! bus_space_read_raw_multi_8 unimplemented !!!
#endif

/*
 *	void bus_space_read_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
 *
 * Read `count' 1, 2, 4, or 8 byte quantities from bus space
 * described by tag/handle and starting at `offset' and copy into
 * buffer provided.
 */

	void		(*read_region_1)(bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t);
	void		(*read_region_2)(bus_space_handle_t,
			    bus_size_t, u_int16_t *, bus_size_t);
	void		(*read_region_4)(bus_space_handle_t,
			    bus_size_t, u_int32_t *, bus_size_t);

#define bus_space_read_region_1(_t, _h, _o, _a, _c) \
	((_t)->read_region_1((_h), (_o), (_a), (_c)))
#define bus_space_read_region_2(_t, _h, _o, _a, _c) \
	((_t)->read_region_2((_h), (_o), (_a), (_c)))
#define bus_space_read_region_4(_t, _h, _o, _a, _c) \
	((_t)->read_region_4((_h), (_o), (_a), (_c)))

#if 0	/* Cause a link error for bus_space_read_region_8 */
#define	bus_space_read_region_8	!!! bus_space_read_region_8 unimplemented !!!
#endif

/*
 *	void bus_space_read_raw_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_int8_t *addr, size_t count);
 *
 * Read `count' bytes in 2, 4 or 8 byte wide quantities from bus space
 * described by tag/handle and starting at `offset' and copy into
 * buffer provided.  The buffer must have proper alignment for the N byte
 * wide entities.  Furthermore possible byte-swapping should be done by
 * these functions.
 */

#define bus_space_read_raw_region_2(_t, _h, _o, _a, _c) \
	((_t)->read_region_2((_h), (_o), (u_int16_t *)(_a), (_c) >> 1))
#define bus_space_read_raw_region_4(_t, _h, _o, _a, _c) \
	((_t)->read_region_4((_h), (_o), (u_int32_t *)(_a), (_c) >> 2))

#if 0	/* Cause a link error for bus_space_read_raw_region_8 */
#define	bus_space_read_raw_region_8 \
    !!! bus_space_read_raw_region_8 unimplemented !!!
#endif

/*
 *	void bus_space_write_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t value);
 *
 * Write the 1, 2, 4, or 8 byte value `value' to bus space
 * described by tag/handle/offset.
 */

	void		(*write_1)(bus_space_handle_t, bus_size_t, u_int8_t);
	void		(*write_2)(bus_space_handle_t, bus_size_t, u_int16_t);
	void		(*write_4)(bus_space_handle_t, bus_size_t, u_int32_t);

#define bus_space_write_1(_t, _h, _o, _v) \
	((_t)->write_1((_h), (_o), (_v)))
#define bus_space_write_2(_t, _h, _o, _v) \
	((_t)->write_2((_h), (_o), (_v)))
#define bus_space_write_4(_t, _h, _o, _v) \
	((_t)->write_4((_h), (_o), (_v)))

#define bus_space_write_raw_2(t, h, o, v) \
    bus_space_write_2((t), (h), (o), (v))
#define bus_space_write_raw_4(t, h, o, v) \
    bus_space_write_4((t), (h), (o), (v))

#if 0
/* Cause a link error for bus_space_write_8 and bus_space_write_raw_8  */
#define	bus_space_write_8	!!! bus_space_write_8 not implemented !!!
#define	bus_space_write_raw_8	!!! bus_space_write_raw_8 not implemented !!!
#endif

/*
 *	void bus_space_write_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
 *
 * Write `count' 1, 2, 4, or 8 byte quantities from the buffer
 * provided to bus space described by tag/handle/offset.
 */

	void		(*write_multi_1)(bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t);
	void		(*write_multi_2)(bus_space_handle_t,
			    bus_size_t, const u_int16_t *, bus_size_t);
	void		(*write_multi_4)(bus_space_handle_t,
			    bus_size_t, const u_int32_t *, bus_size_t);

#define bus_space_write_multi_1(_t, _h, _o, _a, _c) \
	((_t)->write_multi_1((_h), (_o), (_a), (_c)))
#define bus_space_write_multi_2(_t, _h, _o, _a, _c) \
	((_t)->write_multi_2((_h), (_o), (_a), (_c)))
#define bus_space_write_multi_4(_t, _h, _o, _a, _c) \
	((_t)->write_multi_4((_h), (_o), (_a), (_c)))

#if 0	/* Cause a link error for bus_space_write_multi_8 */
#define	bus_space_write_multi_8(t, h, o, a, c)				\
			!!! bus_space_write_multi_8 unimplemented !!!
#endif

/*
 *	void bus_space_write_raw_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_int8_t *addr, size_t count);
 *
 * Write `count' bytes in 2, 4 or 8 byte wide quantities from the buffer
 * provided to bus space described by tag/handle/offset.  The buffer
 * must have proper alignment for the N byte wide entities.  Furthermore
 * possible byte-swapping should be done by these functions.
 */

#define bus_space_write_raw_multi_2(_t, _h, _o, _a, _c) \
	((_t)->write_multi_2((_h), (_o), (const u_int16_t *)(_a), (_c) >> 1))
#define bus_space_write_raw_multi_4(_t, _h, _o, _a, _c) \
	((_t)->write_multi_4((_h), (_o), (const u_int32_t *)(_a), (_c) >> 2))

#if 0	/* Cause a link error for bus_space_write_raw_multi_8 */
#define	bus_space_write_raw_multi_8 \
    !!! bus_space_write_raw_multi_8 unimplemented !!!
#endif

/*
 *	void bus_space_write_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
 *
 * Write `count' 1, 2, 4, or 8 byte quantities from the buffer provided
 * to bus space described by tag/handle starting at `offset'.
 */

	void		(*write_region_1)(bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t);
	void		(*write_region_2)(bus_space_handle_t,
			    bus_size_t, const u_int16_t *, bus_size_t);
	void		(*write_region_4)(bus_space_handle_t,
			    bus_size_t, const u_int32_t *, bus_size_t);

#define bus_space_write_region_1(_t, _h, _o, _a, _c) \
	((_t)->write_region_1((_h), (_o), (_a), (_c)))
#define bus_space_write_region_2(_t, _h, _o, _a, _c) \
	((_t)->write_region_2((_h), (_o), (_a), (_c)))
#define bus_space_write_region_4(_t, _h, _o, _a, _c) \
	((_t)->write_region_4((_h), (_o), (_a), (_c)))

#if 0	/* Cause a link error for bus_space_write_region_8 */
#define	bus_space_write_region_8					\
			!!! bus_space_write_region_8 unimplemented !!!
#endif

/*
 *	void bus_space_write_raw_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_int8_t *addr, size_t count);
 *
 * Write `count' bytes in 2, 4 or 8 byte wide quantities to bus space
 * described by tag/handle and starting at `offset' from the
 * buffer provided.  The buffer must have proper alignment for the N byte
 * wide entities.  Furthermore possible byte-swapping should be done by
 * these functions.
 */

#define bus_space_write_raw_region_2(_t, _h, _o, _a, _c) \
	((_t)->write_region_2((_h), (_o), (const u_int16_t *)(_a), (_c) >> 1))
#define bus_space_write_raw_region_4(_t, _h, _o, _a, _c) \
	((_t)->write_region_4((_h), (_o), (const u_int32_t *)(_a), (_c) >> 2))

#if 0	/* Cause a link error for bus_space_write_raw_region_8 */
#define	bus_space_write_raw_region_8 \
    !!! bus_space_write_raw_region_8 unimplemented !!!
#endif

/*
 *	void bus_space_set_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t val, size_t count);
 *
 * Write the 1, 2, 4, or 8 byte value `val' to bus space described
 * by tag/handle/offset `count' times.
 */

	void		(*set_multi_1)(bus_space_handle_t,
			    bus_size_t, u_int8_t, size_t);
	void		(*set_multi_2)(bus_space_handle_t,
			    bus_size_t, u_int16_t, size_t);
	void		(*set_multi_4)(bus_space_handle_t,
			    bus_size_t, u_int32_t, size_t);

#define bus_space_set_multi_1(_t, _h, _o, _a, _c) \
	((_t)->set_multi_1((_h), (_o), (_a), (_c)))
#define bus_space_set_multi_2(_t, _h, _o, _a, _c) \
	((_t)->set_multi_2((_h), (_o), (_a), (_c)))
#define bus_space_set_multi_4(_t, _h, _o, _a, _c) \
	((_t)->set_multi_4((_h), (_o), (_a), (_c)))

#if 0	/* Cause a link error for bus_space_set_multi_8 */
#define	bus_space_set_multi_8					\
			!!! bus_space_set_multi_8 unimplemented !!!
#endif

/*
 *	void bus_space_set_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t val, size_t count);
 *
 * Write `count' 1, 2, 4, or 8 byte value `val' to bus space described
 * by tag/handle starting at `offset'.
 */

	void		(*set_region_1)(bus_space_handle_t,
			    bus_size_t, u_int8_t, size_t);
	void		(*set_region_2)(bus_space_handle_t,
			    bus_size_t, u_int16_t, size_t);
	void		(*set_region_4)(bus_space_handle_t,
			    bus_size_t, u_int32_t, size_t);

#define bus_space_set_region_1(_t, _h, _o, _a, _c) \
	((_t)->set_region_1((_h), (_o), (_a), (_c)))
#define bus_space_set_region_2(_t, _h, _o, _a, _c) \
	((_t)->set_region_2((_h), (_o), (_a), (_c)))
#define bus_space_set_region_4(_t, _h, _o, _a, _c) \
	((_t)->set_region_4((_h), (_o), (_a), (_c)))

#if 0	/* Cause a link error for bus_space_set_region_8 */
#define	bus_space_set_region_8					\
			!!! bus_space_set_region_8 unimplemented !!!
#endif

/*
 *	void bus_space_copy_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh1, bus_size_t off1,
 *	    bus_space_handle_t bsh2, bus_size_t off2,
 *	    size_t count);
 *
 * Copy `count' 1, 2, 4, or 8 byte values from bus space starting
 * at tag/bsh1/off1 to bus space starting at tag/bsh2/off2.
 */

	void		(*copy_1)(bus_space_handle_t,
			    bus_size_t, bus_space_handle_t, bus_size_t, size_t);
	void		(*copy_2)(bus_space_handle_t,
			    bus_size_t, bus_space_handle_t, bus_size_t, size_t);
	void		(*copy_4)(bus_space_handle_t,
			    bus_size_t, bus_space_handle_t, bus_size_t, size_t);

#define bus_space_copy_1(_t, _h1, _o1, _h2, _o2, _c) \
	((_t)->copy_1((_h1), (_o1), (_h2), (_o2), (_c)))
#define bus_space_copy_2(_t, _h1, _o1, _h2, _o2, _c) \
	((_t)->copy_2((_h1), (_o1), (_h2), (_o2), (_c)))
#define bus_space_copy_4(_t, _h1, _o1, _h2, _o2, _c) \
	((_t)->copy_4((_h1), (_o1), (_h2), (_o2), (_c)))

#if 0	/* Cause a link error for bus_space_copy_8 */
#define	bus_space_copy_8					\
			!!! bus_space_copy_8 unimplemented !!!
#endif

#define	i386_space_copy1(a1, a2, cnt, movs, df)		\
	__asm volatile(df "\n\trep\n\t" movs :		\
	    "+S" (a1), "+D" (a2), "+c" (cnt)	:: "memory", "cc");

#define	i386_space_copy(a1, a2, sz, cnt) do {				\
	if ((void *)(a1) < (void *)(a2)) {				\
		a1 += ((cnt) - 1) * (sz); a2 += ((cnt) - 1) * (sz);	\
		switch (sz) {						\
		case 1:	i386_space_copy1(a1,a2,cnt,"movsb","std");break;\
		case 2:	i386_space_copy1(a1,a2,cnt,"movsw","std");break;\
		case 4:	i386_space_copy1(a1,a2,cnt,"movsl","std");break;\
		}							\
		__asm volatile("cld");	/* must restore before func ret */ \
	} else								\
		switch (sz) {						\
		case 1:	i386_space_copy1(a1,a2,cnt,"movsb","cld");break;\
		case 2:	i386_space_copy1(a1,a2,cnt,"movsw","cld");break;\
		case 4:	i386_space_copy1(a1,a2,cnt,"movsl","cld");break;\
		}							\
} while (0)

/*
 *	void *bus_space_vaddr(bus_space_tag_t, bus_space_handle_t);
 *
 * Get the kernel virtual address for the mapped bus space.
 * Only allowed for regions mapped with BUS_SPACE_MAP_LINEAR.
 */
	void *		(*vaddr)(bus_space_handle_t);

#define bus_space_vaddr(_t, _h) \
	((_t)->vaddr((_h)))
};

/*
 * Bus read/write barrier methods.
 *
 *	void bus_space_barrier(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    bus_size_t len, int flags);
 *
 * Note: the i386 does not currently require barriers, but we must
 * provide the flags to MI code.
 */
#define	bus_space_barrier(t, h, o, l, f) do {				\
	((void)((void)(t), (void)(h), (void)(o), (void)(l), (void)(f)));\
	__asm volatile("" : : : "memory");				\
} while (0)
#define	BUS_SPACE_BARRIER_READ	0x01		/* force read barrier */
#define	BUS_SPACE_BARRIER_WRITE	0x02		/* force write barrier */

#define	BUS_SPACE_MAP_CACHEABLE		0x0001
#define	BUS_SPACE_MAP_LINEAR		0x0002
#define	BUS_SPACE_MAP_PREFETCHABLE	0x0008

/*
 * Values for the i386 bus space tag, not to be used directly by MI code.
 */

/* space is i/o space */
extern const struct i386_bus_space_ops i386_bus_space_io_ops;
#define	I386_BUS_SPACE_IO	(&i386_bus_space_io_ops)

/* space is mem space */
extern const struct i386_bus_space_ops i386_bus_space_mem_ops;
#define I386_BUS_SPACE_MEM	(&i386_bus_space_mem_ops)

/*
 * Flags used in various bus DMA methods.
 */
#define	BUS_DMA_WAITOK		0x0000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x0001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x0002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x0004	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x0010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x0020
#define	BUS_DMA_BUS3		0x0040
#define	BUS_DMA_24BIT		0x0080	/* isadma map */
#define	BUS_DMA_STREAMING	0x0100	/* hint: sequential, unidirectional */
#define	BUS_DMA_READ		0x0200	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x0400	/* mapping is memory -> device only */
#define	BUS_DMA_NOCACHE		0x0800	/* map memory uncached */
#define	BUS_DMA_ZERO		0x1000	/* dmamem_alloc return zeroed mem */
#define	BUS_DMA_64BIT		0x2000	/* device handles 64bit dva */

/* Forwards needed by prototypes below. */
struct mbuf;
struct proc;
struct uio;

/*
 * Operations performed by bus_dmamap_sync().
 */
#define BUS_DMASYNC_PREREAD	0x01
#define BUS_DMASYNC_POSTREAD	0x02
#define BUS_DMASYNC_PREWRITE	0x04
#define BUS_DMASYNC_POSTWRITE	0x08

typedef struct bus_dma_tag		*bus_dma_tag_t;
typedef struct bus_dmamap		*bus_dmamap_t;

/*
 *	bus_dma_segment_t
 *
 *	Describes a single contiguous DMA transaction.  Values
 *	are suitable for programming into DMA registers.
 */
struct bus_dma_segment {
	bus_addr_t	ds_addr;	/* DMA address */
	bus_size_t	ds_len;		/* length of transfer */
	/*
	 * Ugh. need this so can pass alignment down from bus_dmamem_alloc
	 * to scatter gather maps. only the first one is used so the rest is
	 * wasted space. bus_dma could do with fixing the api for this.
	 */
	 bus_size_t	_ds_boundary;	/* don't cross */
	 bus_size_t	_ds_align;	/* align to me */
};
typedef struct bus_dma_segment	bus_dma_segment_t;

/*
 *	bus_dma_tag_t
 *
 *	A machine-dependent opaque type describing the implementation of
 *	DMA for a given bus.
 */

struct bus_dma_tag {
	void	*_cookie;		/* cookie used in the guts */

	/*
	 * DMA mapping methods.
	 */
	int	(*_dmamap_create)(bus_dma_tag_t, bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t, bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t, bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t, bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	void	(*_dmamap_unload)(bus_dma_tag_t, bus_dmamap_t);
	void	(*_dmamap_sync)(bus_dma_tag_t, bus_dmamap_t,
		    bus_addr_t, bus_size_t, int);

	/*
	 * DMA memory utility functions.
	 */
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	int	(*_dmamem_alloc_range)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int,
		    bus_addr_t, bus_addr_t);
	void	(*_dmamem_free)(bus_dma_tag_t,
		    bus_dma_segment_t *, int);
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int);
};

#define	bus_dmamap_create(t, s, n, m, b, f, p)			\
	(*(t)->_dmamap_create)((t), (s), (n), (m), (b), (f), (p))
#define	bus_dmamap_destroy(t, p)				\
	(*(t)->_dmamap_destroy)((t), (p))
#define	bus_dmamap_load(t, m, b, s, p, f)			\
	(*(t)->_dmamap_load)((t), (m), (b), (s), (p), (f))
#define	bus_dmamap_load_mbuf(t, m, b, f)			\
	(*(t)->_dmamap_load_mbuf)((t), (m), (b), (f))
#define	bus_dmamap_load_uio(t, m, u, f)				\
	(*(t)->_dmamap_load_uio)((t), (m), (u), (f))
#define	bus_dmamap_load_raw(t, m, sg, n, s, f)			\
	(*(t)->_dmamap_load_raw)((t), (m), (sg), (n), (s), (f))
#define	bus_dmamap_unload(t, p)					\
	(*(t)->_dmamap_unload)((t), (p))
#define	bus_dmamap_sync(t, p, o, l, ops)			\
	(*(t)->_dmamap_sync)((t), (p), (o), (l), (ops))

#define	bus_dmamem_alloc(t, s, a, b, sg, n, r, f)		\
	(*(t)->_dmamem_alloc)((t), (s), (a), (b), (sg), (n), (r), (f))
#define	bus_dmamem_alloc_range(t, s, a, b, sg, n, r, f, l, h)	\
	(*(t)->_dmamem_alloc_range)((t), (s), (a), (b), (sg),	\
		(n), (r), (f), (l), (h))
#define	bus_dmamem_free(t, sg, n)				\
	(*(t)->_dmamem_free)((t), (sg), (n))
#define	bus_dmamem_map(t, sg, n, s, k, f)			\
	(*(t)->_dmamem_map)((t), (sg), (n), (s), (k), (f))
#define	bus_dmamem_unmap(t, k, s)				\
	(*(t)->_dmamem_unmap)((t), (k), (s))
#define	bus_dmamem_mmap(t, sg, n, o, p, f)			\
	(*(t)->_dmamem_mmap)((t), (sg), (n), (o), (p), (f))

/*
 *	bus_dmamap_t
 *
 *	Describes a DMA mapping.
 */
struct bus_dmamap {
	/*
	 * PRIVATE MEMBERS: not for use by machine-independent code.
	 */
	bus_size_t	_dm_size;	/* largest DMA transfer mappable */
	int		_dm_segcnt;	/* number of segs this map can map */
	bus_size_t	_dm_maxsegsz;	/* largest possible segment */
	bus_size_t	_dm_boundary;	/* don't cross this */
	int		_dm_flags;	/* misc. flags */

	void		*_dm_cookie;	/* cookie for bus-specific functions */

	/*
	 * PUBLIC MEMBERS: these are used by machine-independent code.
	 */
	bus_size_t	dm_mapsize;	/* size of the mapping */
	int		dm_nsegs;	/* # valid segments in mapping */
	bus_dma_segment_t dm_segs[1];	/* segments; variable length */
};

int	_bus_dmamap_create(bus_dma_tag_t, bus_size_t, int, bus_size_t,
	    bus_size_t, int, bus_dmamap_t *);
void	_bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	_bus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	_bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
int	_bus_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
int	_bus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	_bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int);

int	_bus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size,
	    bus_size_t alignment, bus_size_t boundary,
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);
void	_bus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs);
int	_bus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, size_t size, caddr_t *kvap, int flags);
void	_bus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva,
	    size_t size);
paddr_t	_bus_dmamem_mmap(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, off_t off, int prot, int flags);

int	_bus_dmamem_alloc_range(bus_dma_tag_t tag, bus_size_t size,
	    bus_size_t alignment, bus_size_t boundary,
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags,
	    paddr_t low, paddr_t high);

#endif /* _MACHINE_BUS_H_ */
@


1.66
log
@Fix uvm_fault() seen with bwi (and some other devices?) on older non-apic i386

reported by Michael (lesniewskister (at) gmail.com)
ok miod@@ (who did all the hard work)
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.65 2015/01/24 15:13:55 kettenis Exp $	*/
d531 1
@


1.65
log
@Add bus_dmamem_alloc_range(9) to allow drivers to allocate DMA'able memory
within a range that is more (or less) restrictive than the default range.

ok deraadt@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.64 2014/10/17 20:37:57 sthen Exp $	*/
d461 1
@


1.64
log
@reinstate i386/bus_space diff now that serial consoles are fixed in
sys/arch/i386/i386/bios.c, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.62 2014/10/17 01:46:26 dlg Exp $	*/
d599 3
d630 3
@


1.63
log
@backout i386/bus_space diff for now, req'd by deraadt@@ - problems at boot

|	i386/bus_space.c:1.5->1.6
|	i386/machdep.c:1.551->1.552
|	include/bus.h:1.61->1.62
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.61 2014/03/29 18:09:29 guenther Exp $	*/
a74 6
 * Values for the i386 bus space tag, not to be used directly by MI code.
 */
#define	I386_BUS_SPACE_IO	0	/* space is i/o space */
#define I386_BUS_SPACE_MEM	1	/* space is mem space */

/*
d83 2
a84 1
typedef	int bus_space_tag_t;
d108 2
d117 7
a123 8
u_int8_t	bus_space_read_1(bus_space_tag_t, bus_space_handle_t,
		    bus_size_t);

u_int16_t	bus_space_read_2(bus_space_tag_t, bus_space_handle_t,
		    bus_size_t);

u_int32_t	bus_space_read_4(bus_space_tag_t, bus_space_handle_t,
		    bus_size_t);
d145 13
a157 11
#define	bus_space_read_raw_multi_2(t, h, o, a, c) \
    bus_space_read_multi_2((t), (h), (o), (u_int16_t *)(a), (c) >> 1)
#define	bus_space_read_raw_multi_4(t, h, o, a, c) \
    bus_space_read_multi_4((t), (h), (o), (u_int32_t *)(a), (c) >> 2)

void	bus_space_read_multi_1(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    u_int8_t *, bus_size_t);
void	bus_space_read_multi_2(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    u_int16_t *, bus_size_t);
void	bus_space_read_multi_4(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    u_int32_t *, bus_size_t);
d194 13
a206 6
void	bus_space_read_region_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int8_t *, bus_size_t);
void	bus_space_read_region_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int16_t *, bus_size_t);
void	bus_space_read_region_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int32_t *, bus_size_t);
d224 4
a227 4
#define	bus_space_read_raw_region_2(t, h, o, a, c) \
    bus_space_read_region_2((t), (h), (o), (u_int16_t *)(a), (c) >> 1)
#define	bus_space_read_raw_region_4(t, h, o, a, c) \
    bus_space_read_region_4((t), (h), (o), (u_int32_t *)(a), (c) >> 2)
d243 10
a252 6
void	bus_space_write_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int8_t);
void	bus_space_write_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int16_t);
void	bus_space_write_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int32_t);
d274 13
a286 6
void	bus_space_write_multi_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int8_t *, bus_size_t);
void	bus_space_write_multi_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int16_t *, bus_size_t);
void	bus_space_write_multi_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int32_t *, bus_size_t);
d304 4
a307 4
#define	bus_space_write_raw_multi_2(t, h, o, a, c) \
    bus_space_write_multi_2((t), (h), (o), (const u_int16_t *)(a), (c) >> 1)
#define	bus_space_write_raw_multi_4(t, h, o, a, c) \
    bus_space_write_multi_4((t), (h), (o), (const u_int32_t *)(a), (c) >> 2)
d323 13
a335 6
void	bus_space_write_region_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int8_t *, bus_size_t);
void	bus_space_write_region_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int16_t *, bus_size_t);
void	bus_space_write_region_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int32_t *, bus_size_t);
d354 4
a357 4
#define	bus_space_write_raw_region_2(t, h, o, a, c) \
    bus_space_write_region_2((t), (h), (o), (const u_int16_t *)(a), (c) >> 1)
#define	bus_space_write_raw_region_4(t, h, o, a, c) \
    bus_space_write_region_4((t), (h), (o), (const u_int32_t *)(a), (c) >> 2)
d373 13
a385 6
void	bus_space_set_multi_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int8_t, size_t);
void	bus_space_set_multi_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int16_t, size_t);
void	bus_space_set_multi_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int32_t, size_t);
a399 6
void	bus_space_set_region_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int8_t, size_t);
void	bus_space_set_region_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int16_t, size_t);
void	bus_space_set_region_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int32_t, size_t);
d401 13
d430 13
a442 6
void	bus_space_copy_1(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	     bus_space_handle_t, bus_size_t, bus_size_t);
void	bus_space_copy_2(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	     bus_space_handle_t, bus_size_t, bus_size_t);
void	bus_space_copy_4(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	     bus_space_handle_t, bus_size_t, bus_size_t);
d470 12
d503 1
a503 4
 *	void *bus_space_vaddr(bus_space_tag_t, bus_space_handle_t);
 *
 * Get the kernel virtual address for the mapped bus space.
 * Only allowed for regions mapped with BUS_SPACE_MAP_LINEAR.
d505 8
a512 2
#define bus_space_vaddr(t, h) \
	((t) == I386_BUS_SPACE_IO ? (void *)(NULL) : (void *)(h))
@


1.62
log
@bring the twisting of bus_space from amd64 over to i386. this is:

src/sys/arch/amd64/amd64/bus_space.c r1.22
src/sys/arch/amd64/include/bus.h r1.27

instead of using the tag as an identifier for IO or memory mappings
that was checked inside the api, turn it into a pointer to a structure
of function pointers. the api then generally becomes a set of macros
that deref the function pointers on the callers behalf. the idea
is that following a pointer to very small functions is cheap compared
to doing compares continuously.

the kernel is smaller and the api is more cache friendly now.

the porting of this code from amd64 to i386 was done by kimberley manning
requested by and ok tedu@@
@
text
@d75 6
d89 1
a89 2
struct	i386_bus_space_ops;
typedef	const struct i386_bus_space_ops *bus_space_tag_t;
a112 2
struct i386_bus_space_ops {

d120 8
a127 7
	u_int8_t	(*read_1)(bus_space_handle_t, bus_size_t);
	u_int16_t	(*read_2)(bus_space_handle_t, bus_size_t);
	u_int32_t	(*read_4)(bus_space_handle_t, bus_size_t);

#define bus_space_read_1(_t, _h, _o) ((_t)->read_1((_h), (_o)))
#define bus_space_read_2(_t, _h, _o) ((_t)->read_2((_h), (_o)))
#define bus_space_read_4(_t, _h, _o) ((_t)->read_4((_h), (_o)))
d149 11
a159 13
	void		(*read_multi_1)(bus_space_handle_t, bus_size_t,
			    u_int8_t *, bus_size_t);
	void		(*read_multi_2)(bus_space_handle_t, bus_size_t,
			    u_int16_t *, bus_size_t);
	void		(*read_multi_4)(bus_space_handle_t, bus_size_t,
			    u_int32_t *, bus_size_t);

#define bus_space_read_multi_1(_t, _h, _o, _a, _c) \
	((_t)->read_multi_1((_h), (_o), (_a), (_c)))
#define bus_space_read_multi_2(_t, _h, _o, _a, _c) \
	((_t)->read_multi_2((_h), (_o), (_a), (_c)))
#define bus_space_read_multi_4(_t, _h, _o, _a, _c) \
	((_t)->read_multi_4((_h), (_o), (_a), (_c)))
d196 6
a201 13
	void		(*read_region_1)(bus_space_handle_t,
			    bus_size_t, u_int8_t *, bus_size_t);
	void		(*read_region_2)(bus_space_handle_t,
			    bus_size_t, u_int16_t *, bus_size_t);
	void		(*read_region_4)(bus_space_handle_t,
			    bus_size_t, u_int32_t *, bus_size_t);

#define bus_space_read_region_1(_t, _h, _o, _a, _c) \
	((_t)->read_region_1((_h), (_o), (_a), (_c)))
#define bus_space_read_region_2(_t, _h, _o, _a, _c) \
	((_t)->read_region_2((_h), (_o), (_a), (_c)))
#define bus_space_read_region_4(_t, _h, _o, _a, _c) \
	((_t)->read_region_4((_h), (_o), (_a), (_c)))
d219 4
a222 4
#define bus_space_read_raw_region_2(_t, _h, _o, _a, _c) \
	((_t)->read_region_2((_h), (_o), (u_int16_t *)(_a), (_c) >> 1))
#define bus_space_read_raw_region_4(_t, _h, _o, _a, _c) \
	((_t)->read_region_4((_h), (_o), (u_int32_t *)(_a), (_c) >> 2))
d238 6
a243 10
	void		(*write_1)(bus_space_handle_t, bus_size_t, u_int8_t);
	void		(*write_2)(bus_space_handle_t, bus_size_t, u_int16_t);
	void		(*write_4)(bus_space_handle_t, bus_size_t, u_int32_t);

#define bus_space_write_1(_t, _h, _o, _v) \
	((_t)->write_1((_h), (_o), (_v)))
#define bus_space_write_2(_t, _h, _o, _v) \
	((_t)->write_2((_h), (_o), (_v)))
#define bus_space_write_4(_t, _h, _o, _v) \
	((_t)->write_4((_h), (_o), (_v)))
d265 6
a270 13
	void		(*write_multi_1)(bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t);
	void		(*write_multi_2)(bus_space_handle_t,
			    bus_size_t, const u_int16_t *, bus_size_t);
	void		(*write_multi_4)(bus_space_handle_t,
			    bus_size_t, const u_int32_t *, bus_size_t);

#define bus_space_write_multi_1(_t, _h, _o, _a, _c) \
	((_t)->write_multi_1((_h), (_o), (_a), (_c)))
#define bus_space_write_multi_2(_t, _h, _o, _a, _c) \
	((_t)->write_multi_2((_h), (_o), (_a), (_c)))
#define bus_space_write_multi_4(_t, _h, _o, _a, _c) \
	((_t)->write_multi_4((_h), (_o), (_a), (_c)))
d288 4
a291 4
#define bus_space_write_raw_multi_2(_t, _h, _o, _a, _c) \
	((_t)->write_multi_2((_h), (_o), (const u_int16_t *)(_a), (_c) >> 1))
#define bus_space_write_raw_multi_4(_t, _h, _o, _a, _c) \
	((_t)->write_multi_4((_h), (_o), (const u_int32_t *)(_a), (_c) >> 2))
d307 6
a312 13
	void		(*write_region_1)(bus_space_handle_t,
			    bus_size_t, const u_int8_t *, bus_size_t);
	void		(*write_region_2)(bus_space_handle_t,
			    bus_size_t, const u_int16_t *, bus_size_t);
	void		(*write_region_4)(bus_space_handle_t,
			    bus_size_t, const u_int32_t *, bus_size_t);

#define bus_space_write_region_1(_t, _h, _o, _a, _c) \
	((_t)->write_region_1((_h), (_o), (_a), (_c)))
#define bus_space_write_region_2(_t, _h, _o, _a, _c) \
	((_t)->write_region_2((_h), (_o), (_a), (_c)))
#define bus_space_write_region_4(_t, _h, _o, _a, _c) \
	((_t)->write_region_4((_h), (_o), (_a), (_c)))
d331 4
a334 4
#define bus_space_write_raw_region_2(_t, _h, _o, _a, _c) \
	((_t)->write_region_2((_h), (_o), (const u_int16_t *)(_a), (_c) >> 1))
#define bus_space_write_raw_region_4(_t, _h, _o, _a, _c) \
	((_t)->write_region_4((_h), (_o), (const u_int32_t *)(_a), (_c) >> 2))
d350 6
a355 13
	void		(*set_multi_1)(bus_space_handle_t,
			    bus_size_t, u_int8_t, size_t);
	void		(*set_multi_2)(bus_space_handle_t,
			    bus_size_t, u_int16_t, size_t);
	void		(*set_multi_4)(bus_space_handle_t,
			    bus_size_t, u_int32_t, size_t);

#define bus_space_set_multi_1(_t, _h, _o, _a, _c) \
	((_t)->set_multi_1((_h), (_o), (_a), (_c)))
#define bus_space_set_multi_2(_t, _h, _o, _a, _c) \
	((_t)->set_multi_2((_h), (_o), (_a), (_c)))
#define bus_space_set_multi_4(_t, _h, _o, _a, _c) \
	((_t)->set_multi_4((_h), (_o), (_a), (_c)))
d370 6
a376 13
	void		(*set_region_1)(bus_space_handle_t,
			    bus_size_t, u_int8_t, size_t);
	void		(*set_region_2)(bus_space_handle_t,
			    bus_size_t, u_int16_t, size_t);
	void		(*set_region_4)(bus_space_handle_t,
			    bus_size_t, u_int32_t, size_t);

#define bus_space_set_region_1(_t, _h, _o, _a, _c) \
	((_t)->set_region_1((_h), (_o), (_a), (_c)))
#define bus_space_set_region_2(_t, _h, _o, _a, _c) \
	((_t)->set_region_2((_h), (_o), (_a), (_c)))
#define bus_space_set_region_4(_t, _h, _o, _a, _c) \
	((_t)->set_region_4((_h), (_o), (_a), (_c)))
d393 6
a398 13
	void		(*copy_1)(bus_space_handle_t,
			    bus_size_t, bus_space_handle_t, bus_size_t, size_t);
	void		(*copy_2)(bus_space_handle_t,
			    bus_size_t, bus_space_handle_t, bus_size_t, size_t);
	void		(*copy_4)(bus_space_handle_t,
			    bus_size_t, bus_space_handle_t, bus_size_t, size_t);

#define bus_space_copy_1(_t, _h1, _o1, _h2, _o2, _c) \
	((_t)->copy_1((_h1), (_o1), (_h2), (_o2), (_c)))
#define bus_space_copy_2(_t, _h1, _o1, _h2, _o2, _c) \
	((_t)->copy_2((_h1), (_o1), (_h2), (_o2), (_c)))
#define bus_space_copy_4(_t, _h1, _o1, _h2, _o2, _c) \
	((_t)->copy_4((_h1), (_o1), (_h2), (_o2), (_c)))
a425 12
 *	void *bus_space_vaddr(bus_space_tag_t, bus_space_handle_t);
 *
 * Get the kernel virtual address for the mapped bus space.
 * Only allowed for regions mapped with BUS_SPACE_MAP_LINEAR.
 */
	void *		(*vaddr)(bus_space_handle_t);

#define bus_space_vaddr(_t, _h) \
	((_t)->vaddr((_h)))
};

/*
d447 4
a450 1
 * Values for the i386 bus space tag, not to be used directly by MI code.
d452 2
a453 8

/* space is i/o space */
extern const struct i386_bus_space_ops i386_bus_space_io_ops;
#define	I386_BUS_SPACE_IO	(&i386_bus_space_io_ops)

/* space is mem space */
extern const struct i386_bus_space_ops i386_bus_space_mem_ops;
#define I386_BUS_SPACE_MEM	(&i386_bus_space_mem_ops)
@


1.61
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.60 2013/12/23 20:32:31 kettenis Exp $	*/
a74 6
 * Values for the i386 bus space tag, not to be used directly by MI code.
 */
#define	I386_BUS_SPACE_IO	0	/* space is i/o space */
#define I386_BUS_SPACE_MEM	1	/* space is mem space */

/*
d83 2
a84 1
typedef	int bus_space_tag_t;
d108 2
d117 7
a123 8
u_int8_t	bus_space_read_1(bus_space_tag_t, bus_space_handle_t,
		    bus_size_t);

u_int16_t	bus_space_read_2(bus_space_tag_t, bus_space_handle_t,
		    bus_size_t);

u_int32_t	bus_space_read_4(bus_space_tag_t, bus_space_handle_t,
		    bus_size_t);
d145 13
a157 11
#define	bus_space_read_raw_multi_2(t, h, o, a, c) \
    bus_space_read_multi_2((t), (h), (o), (u_int16_t *)(a), (c) >> 1)
#define	bus_space_read_raw_multi_4(t, h, o, a, c) \
    bus_space_read_multi_4((t), (h), (o), (u_int32_t *)(a), (c) >> 2)

void	bus_space_read_multi_1(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    u_int8_t *, bus_size_t);
void	bus_space_read_multi_2(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    u_int16_t *, bus_size_t);
void	bus_space_read_multi_4(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	    u_int32_t *, bus_size_t);
d194 13
a206 6
void	bus_space_read_region_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int8_t *, bus_size_t);
void	bus_space_read_region_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int16_t *, bus_size_t);
void	bus_space_read_region_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int32_t *, bus_size_t);
d224 4
a227 4
#define	bus_space_read_raw_region_2(t, h, o, a, c) \
    bus_space_read_region_2((t), (h), (o), (u_int16_t *)(a), (c) >> 1)
#define	bus_space_read_raw_region_4(t, h, o, a, c) \
    bus_space_read_region_4((t), (h), (o), (u_int32_t *)(a), (c) >> 2)
d243 10
a252 6
void	bus_space_write_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int8_t);
void	bus_space_write_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int16_t);
void	bus_space_write_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int32_t);
d274 13
a286 6
void	bus_space_write_multi_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int8_t *, bus_size_t);
void	bus_space_write_multi_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int16_t *, bus_size_t);
void	bus_space_write_multi_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int32_t *, bus_size_t);
d304 4
a307 4
#define	bus_space_write_raw_multi_2(t, h, o, a, c) \
    bus_space_write_multi_2((t), (h), (o), (const u_int16_t *)(a), (c) >> 1)
#define	bus_space_write_raw_multi_4(t, h, o, a, c) \
    bus_space_write_multi_4((t), (h), (o), (const u_int32_t *)(a), (c) >> 2)
d323 13
a335 6
void	bus_space_write_region_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int8_t *, bus_size_t);
void	bus_space_write_region_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int16_t *, bus_size_t);
void	bus_space_write_region_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, const u_int32_t *, bus_size_t);
d354 4
a357 4
#define	bus_space_write_raw_region_2(t, h, o, a, c) \
    bus_space_write_region_2((t), (h), (o), (const u_int16_t *)(a), (c) >> 1)
#define	bus_space_write_raw_region_4(t, h, o, a, c) \
    bus_space_write_region_4((t), (h), (o), (const u_int32_t *)(a), (c) >> 2)
d373 13
a385 6
void	bus_space_set_multi_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int8_t, size_t);
void	bus_space_set_multi_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int16_t, size_t);
void	bus_space_set_multi_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int32_t, size_t);
a399 6
void	bus_space_set_region_1(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int8_t, size_t);
void	bus_space_set_region_2(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int16_t, size_t);
void	bus_space_set_region_4(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, u_int32_t, size_t);
d401 13
d430 13
a442 6
void	bus_space_copy_1(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	     bus_space_handle_t, bus_size_t, bus_size_t);
void	bus_space_copy_2(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	     bus_space_handle_t, bus_size_t, bus_size_t);
void	bus_space_copy_4(bus_space_tag_t, bus_space_handle_t, bus_size_t,
	     bus_space_handle_t, bus_size_t, bus_size_t);
d470 12
d503 1
a503 4
 *	void *bus_space_vaddr(bus_space_tag_t, bus_space_handle_t);
 *
 * Get the kernel virtual address for the mapped bus space.
 * Only allowed for regions mapped with BUS_SPACE_MAP_LINEAR.
d505 8
a512 2
#define bus_space_vaddr(t, h) \
	((t) == I386_BUS_SPACE_IO ? (void *)(NULL) : (void *)(h))
@


1.60
log
@Add an instruction barrier to bus_space_barrier().  From David Hill.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.59 2013/12/12 21:04:50 kettenis Exp $	*/
d406 1
a406 1
	__asm __volatile(df "\n\trep\n\t" movs :	\
d437 1
a437 1
	__asm __volatile("" : : : "memory");				\
@


1.59
log
@Remove the scatter/gather dma implementation as it is no longer used.

ok krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.58 2013/03/17 21:49:00 kettenis Exp $	*/
d435 4
a438 2
#define	bus_space_barrier(t, h, o, l, f)	\
	((void)((void)(t), (void)(h), (void)(o), (void)(l), (void)(f)))
@


1.58
log
@Add an interface to rebind AGP DMA mappings.  To be used by the upcoming KMS
support to reload bindings after suspend/resume and to update cachability
flags in the address translation table entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.57 2013/01/29 01:15:57 dlg Exp $	*/
a468 8
#define	BUS_DMA_SG		0x2000	/* Internal. memory is for SG map */

/* types for _dm_buftype */
#define	BUS_BUFTYPE_INVALID	0
#define	BUS_BUFTYPE_LINEAR	1
#define	BUS_BUFTYPE_MBUF	2
#define	BUS_BUFTYPE_UIO		3
#define	BUS_BUFTYPE_RAW		4
a630 60

struct extent;

/* Scatter gather bus_dma functions. */
struct sg_cookie {
	struct mutex	 sg_mtx;
	struct extent	*sg_ex;
	void		*sg_hdl;
	void		(*bind_page)(void *, bus_addr_t, paddr_t, int);
	void		(*unbind_page)(void *, bus_addr_t);
	void		(*flush_tlb)(void *);
};

/* 
 * per-map DVMA page table
 */
struct sg_page_entry {
	SPLAY_ENTRY(sg_page_entry)	spe_node;
	paddr_t				spe_pa;
	bus_addr_t			spe_va;
};

/* for sg_dma this will be in the map's dm_cookie. */
struct sg_page_map {
	SPLAY_HEAD(sg_page_tree, sg_page_entry) spm_tree;

	void			*spm_origbuf;	/* pointer to original data */
	int			 spm_buftype;	/* type of data */
	struct proc		*spm_proc;	/* proc that owns the mapping */

	int			 spm_maxpage;	/* Size of allocated page map */
	int			 spm_pagecnt;	/* Number of entries in use */
	bus_addr_t		 spm_start;	/* dva when bound */
	bus_size_t		 spm_size;	/* size of bound map */
	struct sg_page_entry	 spm_map[1];
};

struct sg_cookie	*sg_dmatag_init(char *, void *, bus_addr_t, bus_size_t,
			    void (*)(void *, vaddr_t, paddr_t, int),
			    void (*)(void *, vaddr_t), void (*)(void *));
void	sg_dmatag_destroy(struct sg_cookie *);
int	sg_dmamap_create(bus_dma_tag_t, bus_size_t, int, bus_size_t,
	    bus_size_t, int, bus_dmamap_t *);
void	sg_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
void	sg_dmamap_set_alignment(bus_dma_tag_t, bus_dmamap_t, u_long);
int	sg_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *, bus_size_t,
	    struct proc *, int);
int	sg_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
int	sg_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t, struct uio *, int);
int	sg_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t, bus_dma_segment_t *,
	    int, bus_size_t, int);
void	sg_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
int	sg_dmamap_load_buffer(bus_dma_tag_t, bus_dmamap_t, void *, bus_size_t,
	    struct proc *, int, int *, int);
int	sg_dmamap_load_physarray(bus_dma_tag_t, bus_dmamap_t, paddr_t *,
	    int, int, int *, int);
void	sg_dmamap_reload(bus_dma_tag_t, bus_dmamap_t, int);
int	sg_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t, bus_size_t,
	    bus_dma_segment_t *, int, int *, int);
@


1.57
log
@the bus_space api implies that there's a bus endianness that it will
swap for you to the hosts endianness. sometimes you dont want this hand
holding and just want raw access to the registers. bus_space does have
stuff to do this already, but they deal with buffers which can be awkward
if you just want to get or set a single register.

this adds the following to i386 and amd64:

bus_space_read_raw_2() bus_space_read_raw_4() bus_space_read_raw_8()
bus_space_write_raw_2() bus_space_write_raw_4() bus_space_write_raw_8()

sparc64 already implements this, even though it wasnt part of the
official api. how handy.

i'll do other archs as i can.

kettenis@@ and miod@@ seem ok with this
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.56 2012/12/04 20:51:10 kettenis Exp $	*/
d696 1
a698 1

@


1.56
log
@Implement bus_space_mmap(9).

ok miod@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.55 2012/09/30 10:17:46 miod Exp $	*/
d129 7
a135 1
#if 0	/* Cause a link error for bus_space_read_8 */
d137 1
d245 7
a251 1
#if 0	/* Cause a link error for bus_space_write_8 */
d253 1
@


1.55
log
@Remove duplicated chunk; noticed by David Gilmore
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.54 2011/03/23 16:54:35 pirofti Exp $	*/
d104 1
@


1.54
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.53 2010/09/06 19:05:48 kettenis Exp $	*/
a126 4

#if 0	/* Cause a link error for bus_space_read_8 */
#define	bus_space_read_8(t, h, o)	!!! bus_space_read_8 unimplemented !!!
#endif
@


1.53
log
@Make sure bus_dmamap_sync() always involves a function call, to prevent the
compiler from doing stupid things like reordering stores around it.  There is
some debate whether this will be enough for newer versions of GCC and LLVM.
If this is indeed deemed necessary, this will be addressed in a future diff.

ok miod@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.52 2010/04/08 00:55:25 oga Exp $	*/
d66 2
a67 2
#ifndef _I386_BUS_H_
#define _I386_BUS_H_
d689 1
a689 1
#endif /* _I386_BUS_H_ */
@


1.52
log
@On amd64, move the bus_dma buftype stuff that is only used by sg_dma
into the sg_dma code instead of main bus_dma. Add identical code to i386
since this will be used in the next commit.

ok kettenis@@ back in december.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.51 2009/07/30 21:39:15 miod Exp $	*/
d559 1
a559 2
	(void)((t)->_dmamap_sync ?				\
	    (*(t)->_dmamap_sync)((t), (p), (o), (l), (ops)) : (void)0)
@


1.51
log
@Get rid of the obsolet BUS_BARRIER_xxx constants for bus_space_barrier(), only
provide and use BUS_SPACE_BARRIER_xxx.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.50 2009/07/26 18:48:55 miod Exp $	*/
d70 1
d460 7
d640 24
@


1.50
log
@Make sure all platforms understand the flags argument of bus_space_map() and
bus_space_alloc() as a bitmask of flags, and not a boolean controlling
cacheability; and make sure the three MI BUS_SPACE_MAP_xxx values documented
in the manual page are defined on all platforms as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.49 2009/06/06 05:43:13 oga Exp $	*/
d427 1
a427 3
/* Compatibility defines */
#define	BUS_BARRIER_READ	BUS_SPACE_BARRIER_READ
#define	BUS_BARRIER_WRITE	BUS_SPACE_BARRIER_WRITE
@


1.49
log
@It might be a good idea to commit all the diff. *sigh*.

now this builds
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.48 2009/04/20 00:42:06 oga Exp $	*/
d92 1
a92 1
	    bus_size_t size, int cacheable, bus_space_handle_t *bshp);
d95 1
a95 1
	    bus_size_t size, int cacheable, bus_space_handle_t *bshp);
d106 1
a106 1
	    bus_size_t boundary, int cacheable, bus_addr_t *addrp,
@


1.48
log
@Add a BUS_DMA_ZERO flag for bus_dmamem_alloc() to return zeroed memory.

Saves every damned driver calling bzero(), and continues the M_ZERO,
PR_ZERO symmetry.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.47 2009/03/10 15:03:17 oga Exp $	*/
d69 2
d459 1
d486 7
d623 36
@


1.47
log
@remove the _BUS_DMA_PRIVATE define from amd64 and i386.

a define needed to get to ``private'' functions that needs to be defined
5 or more times isn't much use and may cause namespace issues anyway.
Other archs will probably follow.

Discussed in portugal.  "Hell yes" weingart@@, ok kettenis@@, no
objections miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.46 2009/02/05 01:13:21 oga Exp $	*/
d444 13
a456 12
#define	BUS_DMA_WAITOK		0x000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x004	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x020
#define	BUS_DMA_BUS3		0x040
#define	BUS_DMA_24BIT		0x080	/* isadma map */
#define	BUS_DMA_STREAMING	0x100	/* hint: sequential, unidirectional */
#define	BUS_DMA_READ		0x200	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x400	/* mapping is memory -> device only */
#define	BUS_DMA_NOCACHE		0x800	/* map memory uncached */
@


1.46
log
@add MD PMAP_NOCACHE flag to i386 and use it to implement the
BUS_DMA_NOCACHE flag with guarantees that the dma memory will be mapped
uncached. Some broken/odd hardware needs this.

discussion with miod, toby, art and kettenis. ok miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.45 2008/12/03 15:46:06 oga Exp $	*/
a580 1
#ifdef _BUS_DMA_PRIVATE
a611 1
#endif /* _BUS_DMA_PRIVATE */
@


1.45
log
@Remove the x86 and i386 prefixes to the bus_dma types. It's really quite
pointless and just makes the code different for no reason. This moves i386 and
amd64 bus_dma to being a lot closer to identical.

suggestion to just remove the prefix instead of merge them from deraadt@@.

no objections art@@, kettenis@@, ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.44 2008/11/22 17:45:20 oga Exp $	*/
d455 1
@


1.44
log
@same change as for amd64. Move bus_space_* functions from inlines and
defines into real functions. since machdep.c is cluttered as it is move them
into bus_space.c (like amd64). a later commit will move the stuff from machdep
across too. since machdep.c is cluttered as it is move them into bus_space.c
(like amd64). a later commit will move the stuff from machdep across too.

some shrinkage stats:
GENERIC.MP 209.66kb
RAMDISK 50.84kb
RAMDISKB 50.04kb
RAMDISC 36.28kb
RAMDISK_CD 168.03kb

don't fill it up all at once!

claudio found no network performance hit. toby thought the code went
looked alright. art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.43 2008/06/26 05:42:10 ray Exp $	*/
d469 2
a470 2
typedef struct i386_bus_dma_tag		*bus_dma_tag_t;
typedef struct i386_bus_dmamap		*bus_dmamap_t;
d478 1
a478 1
struct i386_bus_dma_segment {
d482 1
a482 1
typedef struct i386_bus_dma_segment	bus_dma_segment_t;
d491 1
a491 1
struct i386_bus_dma_tag {
d560 1
a560 1
struct i386_bus_dmamap {
d580 1
a580 1
#ifdef _I386_BUS_DMA_PRIVATE
d612 1
a612 1
#endif /* _I386_BUS_DMA_PRIVATE */
@


1.43
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.42 2007/09/01 03:41:17 marco Exp $	*/
d116 2
d119 9
a127 11
#define	bus_space_read_1(t, h, o)					\
	((t) == I386_BUS_SPACE_IO ? (inb((h) + (o))) :			\
	    (*(volatile u_int8_t *)((h) + (o))))

#define	bus_space_read_2(t, h, o)					\
	((t) == I386_BUS_SPACE_IO ? (inw((h) + (o))) :			\
	    (*(volatile u_int16_t *)((h) + (o))))

#define	bus_space_read_4(t, h, o)					\
	((t) == I386_BUS_SPACE_IO ? (inl((h) + (o))) :			\
	    (*(volatile u_int32_t *)((h) + (o))))
d142 11
a152 41
#define	bus_space_read_multi_1(t, h, o, a, cnt) do {			\
	if ((t) == I386_BUS_SPACE_IO) {					\
		insb((h) + (o), (a), (cnt));				\
	} else {void *_addr=(a); int _cnt=(cnt);			\
		__asm __volatile("					\
			cld					;	\
		1:	movb (%2),%%al				;	\
			stosb					;	\
			loop 1b"				:	\
		    "+D" (_addr), "+c" (_cnt) : "r" ((h) + (o))	:	\
		    "%eax", "memory", "cc");				\
	}								\
} while (0)

#define	bus_space_read_multi_2(t, h, o, a, cnt) do {			\
	if ((t) == I386_BUS_SPACE_IO) {					\
		insw((h) + (o), (a), (cnt));				\
	} else {void *_addr=(a); int _cnt=(cnt);			\
		__asm __volatile("					\
			cld					;	\
		1:	movw (%2),%%ax				;	\
			stosw					;	\
			loop 1b"				:	\
		    "+D" (_addr), "+c" (_cnt) : "r" ((h) + (o))	:	\
		    "%eax", "memory", "cc");				\
	}								\
} while (0)

#define	bus_space_read_multi_4(t, h, o, a, cnt) do {			\
	if ((t) == I386_BUS_SPACE_IO) {					\
		insl((h) + (o), (a), (cnt));				\
	} else {void *_addr=(a); int _cnt=(cnt);			\
		__asm __volatile("					\
			cld					;	\
		1:	movl (%2),%%eax				;	\
			stosl					;	\
			loop 1b"				:	\
		    "+D" (_addr), "+c" (_cnt) : "r" ((h) + (o))	:	\
		    "%eax", "memory", "cc");				\
	}								\
} while (0)
d189 6
a194 44
#define	bus_space_read_region_1(t, h, o, a, cnt) do {			\
	int _cnt = (cnt);	void *_addr = (a); int _port = (h)+(o);	\
	if ((t) == I386_BUS_SPACE_IO) {					\
		__asm __volatile("					\
			cld					;	\
		1:	inb %w2,%%al				;	\
			stosb					;	\
			incl %2					;	\
			loop 1b"				:	\
		    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::	\
		    "%eax", "memory", "cc");				\
	} else								\
		i386_space_copy(_port, _addr, 1, _cnt);			\
} while (0)

#define	bus_space_read_region_2(t, h, o, a, cnt) do {			\
	int _cnt = (cnt);	void *_addr = (a); int _port = (h)+(o);	\
	if ((t) == I386_BUS_SPACE_IO) {					\
		__asm __volatile("					\
			cld					;	\
		1:	inw %w2,%%ax				;	\
			stosw					;	\
			addl $2,%2				;	\
			loop 1b"				:	\
		    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::	\
		    "%eax", "memory", "cc");				\
	} else								\
		i386_space_copy(_port, _addr, 2, _cnt);			\
} while (0)

#define	bus_space_read_region_4(t, h, o, a, cnt) do {			\
	int _cnt = (cnt);	void *_addr = (a); int _port = (h)+(o);	\
	if ((t) == I386_BUS_SPACE_IO) {					\
		__asm __volatile("					\
			cld					;	\
		1:	inl %w2,%%eax				;	\
			stosl					;	\
			addl $4,%2				;	\
			loop 1b"				:	\
		    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::	\
		    "%eax", "memory", "cc");				\
	} else								\
		i386_space_copy(_port, _addr, 4, _cnt);			\
} while (0)
d231 6
a236 20
#define	bus_space_write_1(t, h, o, v)	do {				\
	if ((t) == I386_BUS_SPACE_IO)					\
		outb((h) + (o), (v));					\
	else								\
		((void)(*(volatile u_int8_t *)((h) + (o)) = (v)));	\
} while (0)

#define	bus_space_write_2(t, h, o, v)	do {				\
	if ((t) == I386_BUS_SPACE_IO)					\
		outw((h) + (o), (v));					\
	else								\
		((void)(*(volatile u_int16_t *)((h) + (o)) = (v)));	\
} while (0)

#define	bus_space_write_4(t, h, o, v)	do {				\
	if ((t) == I386_BUS_SPACE_IO)					\
		outl((h) + (o), (v));					\
	else								\
		((void)(*(volatile u_int32_t *)((h) + (o)) = (v)));	\
} while (0)
d251 6
a256 41
#define	bus_space_write_multi_1(t, h, o, a, cnt) do {			\
	if ((t) == I386_BUS_SPACE_IO) {					\
		outsb((h) + (o), (a), (cnt));				\
	} else {const void *_addr=(a); int _cnt=(cnt);			\
		__asm __volatile("					\
			cld					;	\
		1:	lodsb					;	\
			movb %%al,(%2)				;	\
			loop 1b"				:	\
		    "+S" (_addr), "+c" (_cnt) : "r" ((h) + (o))	:	\
		    "%eax", "memory", "cc");				\
	}								\
} while (0)

#define bus_space_write_multi_2(t, h, o, a, cnt) do {			\
	if ((t) == I386_BUS_SPACE_IO) {					\
		outsw((h) + (o), (a), (cnt));				\
	} else {const void *_addr=(a); int _cnt=(cnt);			\
		__asm __volatile("					\
			cld					;	\
		1:	lodsw					;	\
			movw %%ax,(%2)				;	\
			loop 1b"				:	\
		    "+S" (_addr), "+c" (_cnt) : "r" ((h) + (o))	:	\
		    "%eax", "memory", "cc");				\
	}								\
} while (0)

#define bus_space_write_multi_4(t, h, o, a, cnt) do {			\
	if ((t) == I386_BUS_SPACE_IO) {					\
		outsl((h) + (o), (a), (cnt));				\
	} else {const void *_addr=(a); int _cnt=(cnt);			\
		__asm __volatile("					\
			cld					;	\
		1:	lodsl					;	\
			movl %%eax,(%2)				;	\
			loop 1b"				:	\
		    "+S" (_addr), "+c" (_cnt) : "r" ((h) + (o))	:	\
		    "%eax", "memory", "cc");				\
	}								\
} while (0)
d293 6
a298 44
#define	bus_space_write_region_1(t, h, o, a, cnt) do {			\
	int _port = (h)+(o); const void *_addr=(a); int _cnt=(cnt);	\
	if ((t) == I386_BUS_SPACE_IO) {					\
		__asm __volatile("					\
			cld					;	\
		1:	lodsb					;	\
			outb %%al,%w0				;	\
			incl %0					;	\
			loop 1b"				:	\
		    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::	\
		    "%eax", "memory", "cc");				\
	} else								\
		i386_space_copy(_addr, _port, 1, _cnt);			\
} while (0)

#define	bus_space_write_region_2(t, h, o, a, cnt) do {			\
	int _port = (h)+(o); const void *_addr=(a); int _cnt=(cnt);	\
	if ((t) == I386_BUS_SPACE_IO) {					\
		__asm __volatile("					\
			cld					;	\
		1:	lodsw					;	\
			outw %%ax,%w0				;	\
			addl $2,%0				;	\
			loop 1b"				:	\
		    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::	\
		    "%eax", "memory", "cc");				\
	} else								\
		i386_space_copy(_addr, _port, 2, _cnt);			\
} while (0)

#define	bus_space_write_region_4(t, h, o, a, cnt) do {			\
	int _port = (h)+(o); const void *_addr=(a); int _cnt=(cnt);	\
	if ((t) == I386_BUS_SPACE_IO) {					\
		__asm __volatile("					\
			cld					;	\
		1:	lodsl					;	\
			outl %%eax,%w0				;	\
			addl $4,%0				;	\
			loop 1b"				:	\
		    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::	\
		    "%eax", "memory", "cc");				\
	} else								\
		i386_space_copy(_addr, _port, 4, _cnt);			\
} while (0)
d336 6
a341 56
#define	bus_space_set_multi_1(t, h, o, v, cnt) do {			\
	int _cnt=(cnt);							\
	if ((t) == I386_BUS_SPACE_IO) {					\
		__asm __volatile("					\
			cld					;	\
		1:	outb %b2, %w1				;	\
			loop 1b"				:	\
		    "+c" (_cnt) : "d" ((h) + (o)), "a" ((v))	:	\
		    "cc");						\
	} else {							\
		__asm __volatile("					\
			cld					;	\
		1:	movb %b2, (%1)				;	\
			loop 1b"				:	\
		    "+c" (_cnt) : "D" ((h) + (o)), "a" ((v))	:	\
		    "cc", "memory");					\
	}								\
} while (0)

#define	bus_space_set_multi_2(t, h, o, v, cnt) do {			\
	int _cnt=(cnt);							\
	if ((t) == I386_BUS_SPACE_IO) {					\
		__asm __volatile("					\
			cld					;	\
		1:	outw %w2, %w1				;	\
			loop 1b"				:	\
		    "+c" (_cnt) : "d" ((h) + (o)), "a" ((v))	:	\
		    "cc");						\
	} else {							\
		__asm __volatile("					\
			cld					;	\
		1:	movw %w2, (%1)				;	\
			loop 1b"				:	\
		    "+c" (_cnt) : "D" ((h) + (o)), "a" ((v))	:	\
		    "cc", "memory");					\
	}								\
} while (0)

#define	bus_space_set_multi_4(t, h, o, v, cnt) do {			\
	int _cnt=(cnt);							\
	if ((t) == I386_BUS_SPACE_IO) {					\
		__asm __volatile("					\
			cld					;	\
		1:	outl %2,%w1				;	\
			loop 1b"				:	\
		    "+c" (_cnt) : "d" ((h) + (o)), "a" ((v))	:	\
		    "cc");						\
	} else {							\
		__asm __volatile("					\
			cld					;	\
		1:	movl %2,(%1)				;	\
			loop 1b"				:	\
		    "+c" (_cnt) : "D" ((h) + (o)), "a" ((v))	:	\
		    "cc", "memory");					\
	}								\
} while (0)
d356 6
a362 56
#define	bus_space_set_region_1(t, h, o, v, cnt) do {			\
	int _port = (h)+(o); int _cnt = (cnt);				\
	if ((t) == I386_BUS_SPACE_IO) {					\
		__asm __volatile("					\
		1:	outb %%al,%w0				;	\
			incl %0					;	\
			loop 1b"				:	\
		    "+d" (_port), "+c" (_cnt) : "a" ((v))	:	\
		    "cc");						\
	} else {							\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			stosb"					:	\
		    "+D" (_port), "+c" (_cnt) : "a" ((v))	:	\
		    "memory", "cc");					\
	}								\
} while (0)

#define	bus_space_set_region_2(t, h, o, v, cnt) do {			\
	int _port = (h)+(o); int _cnt = (cnt);				\
	if ((t) == I386_BUS_SPACE_IO) {					\
		__asm __volatile("					\
		1:	outw %%ax,%w0				;	\
			addl $2, %0				;	\
			loop 1b"				:	\
		    "+d" (_port), "+c" (_cnt) : "a" ((v))	:	\
		    "cc");						\
	} else {							\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			stosw"					:	\
		    "+D" (_port), "+c" (_cnt) : "a" ((v))	:	\
		    "memory", "cc");					\
	}								\
} while (0)

#define	bus_space_set_region_4(t, h, o, v, cnt) do {			\
	int _port = (h)+(o); int _cnt = (cnt);				\
	if ((t) == I386_BUS_SPACE_IO) {					\
		__asm __volatile("					\
		1:	outl %%eax,%w0				;	\
			addl $4, %0				;	\
			loop 1b"				:	\
		    "+d" (_port), "+c" (_cnt) : "a" ((v))	:	\
		    "cc");						\
	} else {							\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			stosl"					:	\
		    "+D" (_port), "+c" (_cnt) : "a" ((v))	:	\
		    "memory", "cc");					\
	}								\
} while (0)
d379 6
a384 50
#define	bus_space_copy_1(t, h1, o1, h2, o2, cnt) do {			\
	int _port1 = (h1)+(o1); int _port2 = (h2)+(o2); int _cnt=(cnt);	\
	if ((t) == I386_BUS_SPACE_IO) {					\
		__asm __volatile("					\
		1:	movl %k1,%%edx				;	\
			inb  %%dx,%%al				;	\
			movl %k0,%%edx				;	\
			outb %%al,%%dx				;	\
			incl %0					;	\
			incl %1					;	\
			loop 1b"				:	\
		    "+D" (_port2), "+S" (_port1), "+c" ((_cnt))	::	\
		    "%edx", "%eax", "cc");				\
	} else								\
		i386_space_copy(_port1, _port2, 1, _cnt);		\
} while (0)

#define	bus_space_copy_2(t, h1, o1, h2, o2, cnt) do {			\
	int _port1 = (h1)+(o1); int _port2 = (h2)+(o2); int _cnt=(cnt);	\
	if ((t) == I386_BUS_SPACE_IO) {					\
		__asm __volatile("					\
		1:	movl %k1,%%edx				;	\
			inw  %%dx,%%ax				;	\
			movl %k0,%%edx				;	\
			outw %%ax,%%dx				;	\
			addl $2, %0				;	\
			addl $2, %1				;	\
			loop 1b"				:	\
		    "+D" (_port2), "+ES" (_port1), "+c" ((_cnt))	::	\
		    "%edx", "%eax", "cc");				\
	} else								\
		i386_space_copy(_port1, _port2, 2, _cnt);		\
} while (0)

#define	bus_space_copy_4(t, h1, o1, h2, o2, cnt) do {			\
	int _port1 = (h1)+(o1); int _port2 = (h2)+(o2); int _cnt=(cnt);	\
	if ((t) == I386_BUS_SPACE_IO) {					\
		__asm __volatile("					\
		1:	movl %k1,%%edx				;	\
			inl  %%dx,%%eax				;	\
			movl %k0,%%edx				;	\
			outl %%eax,%%dx				;	\
			addl $4, %0				;	\
			addl $4, %1				;	\
			loop 1b"				:	\
		    "+D" (_port2), "+ES" (_port1), "+c" ((_cnt))	::	\
		    "%edx", "%eax", "cc");				\
	} else								\
		i386_space_copy(_port1, _port2, 4, _cnt);		\
} while (0)
@


1.42
log
@Remove stale comments; prompted by millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.41 2007/08/22 21:28:41 marco Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.41
log
@Add bus_space_vaddr to i386 arch.

Comments and ok kettenis, art & miod
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.40 2007/02/20 21:15:01 tom Exp $	*/
a742 1
 *  (XXX not enforced)
@


1.40
log
@Revert PAE pmap for now, until the strange bug is found.  This stops
the freezes many of us are seeing (especially on amd64 machines running
OpenBSD/i386).

Much testing by nick@@ (as always - thanks!), hugh@@, ian@@, kettenis@@
and Sam Smith (s (at) msmith (dot) net).

Requested by, input from, and ok deraadt@@  ok art@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.38 2006/04/27 15:17:16 mickey Exp $	*/
d734 13
@


1.39
log
@implement separate PAE pmap that allows access to 64g of physmem
if supported by the cpu(s). currently not enabled by default and
not compiled into ramdisks. this grows paddr_t to 64bit but yet
leaves bus_addr_t at 32bits. measures are taken to favour dmaable
memory allocation from below 4g line such that buffer cache is
already allocated form below, pool backend allocator prefers lower
memory and then finally bounce buffers are used as last resort.
PAE is engaged only if global variable cpu_pae is manually set
to non-zero and there is physical memory present above 4g.
simplify pcibios address math to use u_long as we always will
be in the 32bit space.
@
text
@d744 1
a744 1
#define	BUS_DMA_64BIT		0x040	/* large memory high segment is ok */
a773 1
	paddr_t		ds_addr2;	/* replacement store */
a774 2
	vaddr_t		ds_va;		/* mapped loaded data */
	vaddr_t		ds_va2;		/* mapped replacement data */
a864 5

	struct vm_page	**_dm_pages;	/* replacement pages */
	vaddr_t		_dm_pgva;	/* those above -- mapped */
	int		_dm_npages;	/* number of pages allocated */
	int		_dm_nused;	/* number of pages replaced */
@


1.38
log
@from PAE work:
add a BUS_DMA_24BIT flag to signify that dmamap being created
is for the isadma use (thus already backed up by the bounce
buffers). later also to be used for dmamem allocation.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.37 2005/05/25 18:29:58 jason Exp $	*/
d744 1
a744 1
#define	BUS_DMA_BUS3		0x040
d774 1
d776 2
d868 5
@


1.37
log
@comment typo
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.36 2004/05/04 17:06:33 grange Exp $	*/
d745 1
a745 1
#define	BUS_DMA_BUS4		0x080
@


1.36
log
@Move _bus_space_unmap() to machdep.c so it can be used not
only by the rbus code. Also knf it and sync with bus_space_unmap().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.35 2003/04/17 03:42:14 drahn Exp $	*/
d856 1
a856 1
	 * PRIVATE MEMBERS: not for use my machine-independent code.
@


1.35
log
@i386 changes to move to ELF. asm cleanup. Change MAXDSIZ to 512M for 1Gsep.
DARPA funded work.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.34 2003/01/16 04:16:00 art Exp $	*/
d103 3
@


1.34
log
@Getting rid of vm_offset_t
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.33 2002/03/14 01:26:33 millert Exp $	*/
d642 1
a642 1
		1:	movl %w1,%%dx				;	\
d644 1
a644 1
			movl %w0,%%dx				;	\
d659 1
a659 1
		1:	movl %w1,%%dx				;	\
d661 1
a661 1
			movl %w0,%%dx				;	\
d666 1
a666 1
		    "+D" (_port2), "+S" (_port1), "+c" ((_cnt))	::	\
d676 1
a676 1
		1:	movl %w1,%%dx				;	\
d678 1
a678 1
			movl %w0,%%dx				;	\
d683 1
a683 1
		    "+D" (_port2), "+S" (_port1), "+c" ((_cnt))	::	\
@


1.33
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.32 2002/03/07 18:08:08 jason Exp $	*/
d902 1
a902 1
	    vm_offset_t low, vm_offset_t high);
@


1.32
log
@Clean up BUS_DMA_* flags, and make sure all arch's define:
BUS_DMA_READ, BUS_DMA_WRITE, and BUS_DMA_STREAMING
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.31 2001/11/05 17:25:57 art Exp $	*/
d96 2
a97 2
int	bus_space_map __P((bus_space_tag_t t, bus_addr_t addr,
	    bus_size_t size, int cacheable, bus_space_handle_t *bshp));
d99 6
a104 6
int	_bus_space_map __P((bus_space_tag_t t, bus_addr_t addr,
	    bus_size_t size, int cacheable, bus_space_handle_t *bshp));
void	bus_space_unmap __P((bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size));
int	bus_space_subregion __P((bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp));
d106 1
a106 1
int	bus_space_alloc __P((bus_space_tag_t t, bus_addr_t rstart,
d109 3
a111 3
	    bus_space_handle_t *bshp));
void	bus_space_free __P((bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size));
d114 2
a115 2
 *	u_intN_t bus_space_read_N __P((bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset));
d138 1
a138 1
 *	void bus_space_read_multi_N __P((bus_space_tag_t tag,
d140 1
a140 1
 *	    u_intN_t *addr, size_t count));
d193 1
a193 1
 *	void bus_space_read_raw_multi_N __P((bus_space_tag_t tag,
d195 1
a195 1
 *	    u_int8_t *addr, size_t count));
d214 1
a214 1
 *	void bus_space_read_region_N __P((bus_space_tag_t tag,
d216 1
a216 1
 *	    u_intN_t *addr, size_t count));
d273 1
a273 1
 *	void bus_space_read_raw_region_N __P((bus_space_tag_t tag,
d275 1
a275 1
 *	    u_int8_t *addr, size_t count));
d295 1
a295 1
 *	void bus_space_write_N __P((bus_space_tag_t tag,
d297 1
a297 1
 *	    u_intN_t value));
d329 1
a329 1
 *	void bus_space_write_multi_N __P((bus_space_tag_t tag,
d331 1
a331 1
 *	    const u_intN_t *addr, size_t count));
d385 1
a385 1
 *	void bus_space_write_raw_multi_N __P((bus_space_tag_t tag,
d387 1
a387 1
 *	    const u_int8_t *addr, size_t count));
d406 1
a406 1
 *	void bus_space_write_region_N __P((bus_space_tag_t tag,
d408 1
a408 1
 *	    const u_intN_t *addr, size_t count));
d465 1
a465 1
 *	void bus_space_write_raw_region_N __P((bus_space_tag_t tag,
d467 1
a467 1
 *	    const u_int8_t *addr, size_t count));
d487 1
a487 1
 *	void bus_space_set_multi_N __P((bus_space_tag_t tag,
d489 1
a489 1
 *	    u_intN_t val, size_t count));
d558 1
a558 1
 *	void bus_space_set_region_N __P((bus_space_tag_t tag,
d560 1
a560 1
 *	    u_intN_t val, size_t count));
d629 1
a629 1
 *	void bus_space_copy_N __P((bus_space_tag_t tag,
d632 1
a632 1
 *	    size_t count));
d717 1
a717 1
 *	void bus_space_barrier __P((bus_space_tag_t tag,
d719 1
a719 1
 *	    bus_size_t len, int flags));
d788 14
a801 14
	int	(*_dmamap_create) __P((bus_dma_tag_t, bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *));
	void	(*_dmamap_destroy) __P((bus_dma_tag_t, bus_dmamap_t));
	int	(*_dmamap_load) __P((bus_dma_tag_t, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int));
	int	(*_dmamap_load_mbuf) __P((bus_dma_tag_t, bus_dmamap_t,
		    struct mbuf *, int));
	int	(*_dmamap_load_uio) __P((bus_dma_tag_t, bus_dmamap_t,
		    struct uio *, int));
	int	(*_dmamap_load_raw) __P((bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int));
	void	(*_dmamap_unload) __P((bus_dma_tag_t, bus_dmamap_t));
	void	(*_dmamap_sync) __P((bus_dma_tag_t, bus_dmamap_t,
		    bus_addr_t, bus_size_t, int));
d806 9
a814 9
	int	(*_dmamem_alloc) __P((bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int));
	void	(*_dmamem_free) __P((bus_dma_tag_t,
		    bus_dma_segment_t *, int));
	int	(*_dmamem_map) __P((bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int));
	void	(*_dmamem_unmap) __P((bus_dma_tag_t, caddr_t, size_t));
	paddr_t	(*_dmamem_mmap) __P((bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int));
d872 14
a885 14
int	_bus_dmamap_create __P((bus_dma_tag_t, bus_size_t, int, bus_size_t,
	    bus_size_t, int, bus_dmamap_t *));
void	_bus_dmamap_destroy __P((bus_dma_tag_t, bus_dmamap_t));
int	_bus_dmamap_load __P((bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int));
int	_bus_dmamap_load_mbuf __P((bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int));
int	_bus_dmamap_load_uio __P((bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int));
int	_bus_dmamap_load_raw __P((bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int));
void	_bus_dmamap_unload __P((bus_dma_tag_t, bus_dmamap_t));
void	_bus_dmamap_sync __P((bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int));
d887 1
a887 1
int	_bus_dmamem_alloc __P((bus_dma_tag_t tag, bus_size_t size,
d889 9
a897 9
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags));
void	_bus_dmamem_free __P((bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs));
int	_bus_dmamem_map __P((bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, size_t size, caddr_t *kvap, int flags));
void	_bus_dmamem_unmap __P((bus_dma_tag_t tag, caddr_t kva,
	    size_t size));
paddr_t	_bus_dmamem_mmap __P((bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, off_t off, int prot, int flags));
d899 1
a899 1
int	_bus_dmamem_alloc_range __P((bus_dma_tag_t tag, bus_size_t size,
d902 1
a902 1
	    vm_offset_t low, vm_offset_t high));
@


1.31
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.30 2001/07/30 14:15:59 art Exp $	*/
d735 11
a745 8
#define	BUS_DMA_WAITOK		0x00	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x01	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x02	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x04	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x10	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x20
#define	BUS_DMA_BUS3		0x40
#define	BUS_DMA_BUS4		0x80
@


1.31.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.31 2001/11/05 17:25:57 art Exp $	*/
d96 2
a97 2
int	bus_space_map(bus_space_tag_t t, bus_addr_t addr,
	    bus_size_t size, int cacheable, bus_space_handle_t *bshp);
d99 6
a104 6
int	_bus_space_map(bus_space_tag_t t, bus_addr_t addr,
	    bus_size_t size, int cacheable, bus_space_handle_t *bshp);
void	bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size);
int	bus_space_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp);
d106 1
a106 1
int	bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart,
d109 3
a111 3
	    bus_space_handle_t *bshp);
void	bus_space_free(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size);
d114 2
a115 2
 *	u_intN_t bus_space_read_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset);
d138 1
a138 1
 *	void bus_space_read_multi_N(bus_space_tag_t tag,
d140 1
a140 1
 *	    u_intN_t *addr, size_t count);
d193 1
a193 1
 *	void bus_space_read_raw_multi_N(bus_space_tag_t tag,
d195 1
a195 1
 *	    u_int8_t *addr, size_t count);
d214 1
a214 1
 *	void bus_space_read_region_N(bus_space_tag_t tag,
d216 1
a216 1
 *	    u_intN_t *addr, size_t count);
d273 1
a273 1
 *	void bus_space_read_raw_region_N(bus_space_tag_t tag,
d275 1
a275 1
 *	    u_int8_t *addr, size_t count);
d295 1
a295 1
 *	void bus_space_write_N(bus_space_tag_t tag,
d297 1
a297 1
 *	    u_intN_t value);
d329 1
a329 1
 *	void bus_space_write_multi_N(bus_space_tag_t tag,
d331 1
a331 1
 *	    const u_intN_t *addr, size_t count);
d385 1
a385 1
 *	void bus_space_write_raw_multi_N(bus_space_tag_t tag,
d387 1
a387 1
 *	    const u_int8_t *addr, size_t count);
d406 1
a406 1
 *	void bus_space_write_region_N(bus_space_tag_t tag,
d408 1
a408 1
 *	    const u_intN_t *addr, size_t count);
d465 1
a465 1
 *	void bus_space_write_raw_region_N(bus_space_tag_t tag,
d467 1
a467 1
 *	    const u_int8_t *addr, size_t count);
d487 1
a487 1
 *	void bus_space_set_multi_N(bus_space_tag_t tag,
d489 1
a489 1
 *	    u_intN_t val, size_t count);
d558 1
a558 1
 *	void bus_space_set_region_N(bus_space_tag_t tag,
d560 1
a560 1
 *	    u_intN_t val, size_t count);
d629 1
a629 1
 *	void bus_space_copy_N(bus_space_tag_t tag,
d632 1
a632 1
 *	    size_t count);
d717 1
a717 1
 *	void bus_space_barrier(bus_space_tag_t tag,
d719 1
a719 1
 *	    bus_size_t len, int flags);
d735 8
a742 11
#define	BUS_DMA_WAITOK		0x000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x004	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x020
#define	BUS_DMA_BUS3		0x040
#define	BUS_DMA_BUS4		0x080
#define	BUS_DMA_STREAMING	0x100	/* hint: sequential, unidirectional */
#define	BUS_DMA_READ		0x200	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x400	/* mapping is memory -> device only */
d785 14
a798 14
	int	(*_dmamap_create)(bus_dma_tag_t, bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t, bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t, bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t, bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	void	(*_dmamap_unload)(bus_dma_tag_t, bus_dmamap_t);
	void	(*_dmamap_sync)(bus_dma_tag_t, bus_dmamap_t,
		    bus_addr_t, bus_size_t, int);
d803 9
a811 9
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	void	(*_dmamem_free)(bus_dma_tag_t,
		    bus_dma_segment_t *, int);
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int);
d869 14
a882 14
int	_bus_dmamap_create(bus_dma_tag_t, bus_size_t, int, bus_size_t,
	    bus_size_t, int, bus_dmamap_t *);
void	_bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	_bus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	_bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
int	_bus_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
int	_bus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	_bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int);
d884 1
a884 1
int	_bus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size,
d886 9
a894 9
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);
void	_bus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs);
int	_bus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, size_t size, caddr_t *kvap, int flags);
void	_bus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva,
	    size_t size);
paddr_t	_bus_dmamem_mmap(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, off_t off, int prot, int flags);
d896 1
a896 1
int	_bus_dmamem_alloc_range(bus_dma_tag_t tag, bus_size_t size,
d899 1
a899 1
	    vm_offset_t low, vm_offset_t high);
@


1.31.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d642 1
a642 1
		1:	movl %k1,%%edx				;	\
d644 1
a644 1
			movl %k0,%%edx				;	\
d659 1
a659 1
		1:	movl %k1,%%edx				;	\
d661 1
a661 1
			movl %k0,%%edx				;	\
d666 1
a666 1
		    "+D" (_port2), "+ES" (_port1), "+c" ((_cnt))	::	\
d676 1
a676 1
		1:	movl %k1,%%edx				;	\
d678 1
a678 1
			movl %k0,%%edx				;	\
d683 1
a683 1
		    "+D" (_port2), "+ES" (_port1), "+c" ((_cnt))	::	\
d902 1
a902 1
	    paddr_t low, paddr_t high);
@


1.30
log
@Change:
int bus_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t, int, int, int, int);
to:
paddr_t bus_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t, int, int, off_t, int);

To allow mmaping offsets larger than INT_MAX. And to simply make more sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.29 2001/06/25 23:03:43 mickey Exp $	*/
d750 1
a750 3
 *	bus_dmasync_op_t
 *
 *	Operations performed by bus_dmamap_sync().
d752 4
a755 6
typedef enum {
	BUS_DMASYNC_PREREAD,
	BUS_DMASYNC_POSTREAD,
	BUS_DMASYNC_PREWRITE,
	BUS_DMASYNC_POSTWRITE,
} bus_dmasync_op_t;
d798 1
a798 1
		    bus_dmasync_op_t));
d828 1
a828 1
#define	bus_dmamap_sync(t, p, o)				\
d830 1
a830 1
	    (*(t)->_dmamap_sync)((t), (p), (o)) : (void)0)
d881 2
a882 1
void	_bus_dmamap_sync __P((bus_dma_tag_t, bus_dmamap_t, bus_dmasync_op_t));
@


1.29
log
@fix some constraints and spillage
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.28 2001/05/08 18:19:44 jason Exp $	*/
d814 2
a815 2
	int	(*_dmamem_mmap) __P((bus_dma_tag_t, bus_dma_segment_t *,
		    int, int, int, int));
d896 2
a897 2
int	_bus_dmamem_mmap __P((bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, int off, int prot, int flags));
@


1.28
log
@From netbsd: implementations of _bus_dmamap_load_mbuf() and
_bus_dmamap_load_uio().
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.27 2001/02/06 23:13:31 mickey Exp $	*/
d56 1
a56 1
 *      This product includes software developed by Christopher G. Demetriou
d154 2
a155 3
			loop 1b"				: 	\
		    "=D" (_addr), "=c" (_cnt)			:	\
		    "r" ((h) + (o)), "0" (_addr), "1" (_cnt)	:	\
d169 1
a169 2
		    "=D" (_addr), "=c" (_cnt)			:	\
		    "r" ((h) + (o)), "0" (_addr), "1" (_cnt)	:	\
d183 1
a183 2
		    "=D" (_addr), "=c" (_cnt)			:	\
		    "r" ((h) + (o)), "0" (_addr), "1" (_cnt)	:	\
d231 2
a232 3
			loop 1b"				: 	\
		    "=D" (_addr), "=c" (_cnt), "=d" (_port)	:	\
		    "0" (_addr), "1" (_cnt), "2" (_port)	:	\
d246 2
a247 3
			loop 1b"				: 	\
		    "=D" (_addr), "=c" (_cnt), "=d" (_port)	:	\
		    "0" (_addr), "1" (_cnt), "2" (_port)	:	\
d261 2
a262 3
			loop 1b"				: 	\
		    "=D" (_addr), "=c" (_cnt), "=d" (_port)	:	\
		    "0" (_addr), "1" (_cnt), "2" (_port)	:	\
d345 2
a346 3
			loop 1b"				: 	\
		    "=S" (_addr), "=c" (_cnt)			:	\
		    "r" ((h) + (o)), "0" (_addr), "1" (_cnt)	:	\
d359 2
a360 3
			loop 1b"				: 	\
		    "=S" (_addr), "=c" (_cnt)			:	\
		    "r" ((h) + (o)), "0" (_addr), "1" (_cnt)	:	\
d373 2
a374 3
			loop 1b"				: 	\
		    "=S" (_addr), "=c" (_cnt)			:	\
		    "r" ((h) + (o)), "0" (_addr), "1" (_cnt)	:	\
d422 2
a423 3
			loop 1b"				: 	\
		    "=d" (_port), "=S" (_addr), "=c" (_cnt)	:	\
		    "0" (_port), "1" (_addr), "2" (_cnt)	:	\
d437 2
a438 3
			loop 1b"				: 	\
		    "=d" (_port), "=S" (_addr), "=c" (_cnt)	:	\
		    "0" (_port), "1" (_addr), "2" (_cnt)	:	\
d452 2
a453 3
			loop 1b"				: 	\
		    "=d" (_port), "=S" (_addr), "=c" (_cnt)	:	\
		    "0" (_port), "1" (_addr), "2" (_cnt)	:	\
d500 4
a503 5
		1:	outb %%al,%w1				;	\
			loop 1b"				: 	\
		    "=c" (_cnt)					:	\
		    "d" ((h) + (o)), "0" ((_cnt)), "a" ((v))	:	\
		    "%eax", "cc");					\
d507 4
a510 5
		1:	movb %%al,(%1)				;	\
			loop 1b"				: 	\
		    "=c" (_cnt)					:	\
		    "D" ((h) + (o)), "0" ((_cnt)), "a" ((v))	:	\
		    "%eax", "cc");					\
d519 4
a522 5
		1:	outw %%ax,%w1				;	\
			loop 1b"				: 	\
		    "=c" (_cnt)					:	\
		    "d" ((h) + (o)), "0" ((_cnt)), "a" ((v))	:	\
		    "%eax", "cc");					\
d526 4
a529 5
		1:	movw %%ax,(%1)				;	\
			loop 1b"				: 	\
		    "=c" (_cnt)					:	\
		    "D" ((h) + (o)), "0" ((_cnt)), "a" ((v))	:	\
		    "%eax", "cc");					\
d538 4
a541 5
		1:	outl %%eax,%w1				;	\
			loop 1b"				: 	\
		    "=c" (_cnt)					:	\
		    "d" ((h) + (o)), "0" ((_cnt)), "a" ((v))	:	\
		    "%eax", "cc");					\
d545 4
a548 5
		1:	movl %%eax,(%1)				;	\
			loop 1b"				: 	\
		    "=c" (_cnt)					:	\
		    "D" ((h) + (o)), "0" ((_cnt)), "a" ((v))	:	\
		    "%eax", "cc");					\
d572 2
a573 3
			loop 1b"				: 	\
		    "=d" (_port), "=c" (_cnt)			:	\
		    "0" (_port), "1" (_cnt), "a" ((v))		:	\
d580 1
a580 2
		    "=D" (_port), "=c" (_cnt)			:	\
		    "0" (_port), "1" (_cnt), "a" ((v))		:	\
d591 2
a592 3
			loop 1b"				: 	\
		    "=d" (_port), "=c" (_cnt)			:	\
		    "0" (_port), "1" (_cnt), "a" ((v))		:	\
d599 1
a599 2
		    "=D" (_port), "=c" (_cnt)			:	\
		    "0" (_port), "1" (_cnt), "a" ((v))		:	\
d610 2
a611 3
			loop 1b"				: 	\
		    "=d" (_port), "=c" (_cnt)			:	\
		    "0" (_port), "1" (_cnt), "a" ((v))		:	\
d618 1
a618 2
		    "=D" (_port), "=c" (_cnt)			:	\
		    "0" (_port), "1" (_cnt), "a" ((v))		:	\
d648 2
a649 3
			loop 1b"				: 	\
		    "=D" (_port2), "=S" (_port1), "=c" ((_cnt))	:	\
		    "0" (_port2), "1" (_port1), "2" ((_cnt))	:	\
d665 2
a666 3
			loop 1b"				: 	\
		    "=D" (_port2), "=S" (_port1), "=c" ((_cnt))	:	\
		    "0" (_port2), "1" (_port1), "2" ((_cnt))	:	\
d682 2
a683 3
			loop 1b"				: 	\
		    "=D" (_port2), "=S" (_port1), "=c" ((_cnt))	:	\
		    "0" (_port2), "1" (_port1), "2" ((_cnt))	:	\
@


1.27
log
@missed ) in if()
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.26 2001/02/06 23:01:32 mickey Exp $	*/
d894 1
@


1.26
log
@i can be stooooopid
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.25 2001/02/04 06:51:14 aaron Exp $	*/
d726 1
a726 1
	if ((void *)(a1) < (void *)(a2) {				\
@


1.25
log
@Fix an off-by-{1,2,4} error in i386_space_copy(). Console is now working much
more nicely, but not perfect yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.24 2001/02/04 01:49:21 aaron Exp $	*/
d726 2
a727 3
	int _len = (sz) * (cnt);					\
	if ((void *)(a2) < ((void *)(a1) + _len)) {			\
		a1 += (_len - (sz)); a2 += (_len - (sz));		\
@


1.24
log
@Minor indent botch.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.23 2001/02/03 21:55:37 mickey Exp $	*/
d728 1
a728 1
		a1 += _len; a2 += _len;					\
@


1.23
log
@make overlaping bus space copy operations work; solves vga's scrolling problems
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.22 2000/08/05 22:03:36 niklas Exp $	*/
d695 1
a695 1
		i386_space_copy(_port1, _port2, 2, _cnt);			\
@


1.22
log
@pasto
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.21 2000/07/27 16:33:39 mickey Exp $	*/
d238 2
a239 9
	} else {							\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			movsb"					:	\
		    "=D" (_addr), "=c" (_cnt), "=S" (_port)	:	\
		    "0" (_addr), "1" (_cnt), "2" (_port)	:	\
		    "memory", "cc");					\
	}								\
d254 2
a255 9
	} else {							\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			movsw"					:	\
		    "=D" (_addr), "=c" (_cnt), "=S" (_port)	:	\
		    "0" (_addr), "1" (_cnt), "2" (_port)	:	\
		    "memory", "cc");					\
	}								\
d270 2
a271 9
	} else {							\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			movsl"					:	\
		    "=D" (_addr), "=c" (_cnt), "=S" (_port)	:	\
		    "0" (_addr), "1" (_cnt), "2" (_port)	:	\
		    "memory", "cc");					\
	}								\
d435 2
a436 9
	} else {							\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			movsb"					:	\
		    "=D" (_port), "=S" (_addr), "=c" (_cnt)	:	\
		    "0" (_port), "1" (_addr), "2" (_cnt)	:	\
		    "memory", "cc");					\
	}								\
d451 2
a452 9
	} else {							\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			movsw"					:	\
		    "=D" (_port), "=S" (_addr), "=c" (_cnt)	:	\
		    "0" (_port), "1" (_addr), "2" (_cnt)	:	\
		    "memory", "cc");					\
	}								\
d467 2
a468 9
	} else {							\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			movsl"					:	\
		    "=D" (_port), "=S" (_addr), "=c" (_cnt)	:	\
		    "0" (_port), "1" (_addr), "2" (_cnt)	:	\
		    "memory", "cc");					\
	}								\
d676 2
a677 9
	} else {							\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			movsb"					:	\
		    "=D" (_port2), "=S" (_port1), "=c" ((_cnt))	:	\
		    "0" (_port2), "1" (_port1), "2" ((_cnt))	:	\
		    "memory", "cc");					\
	}								\
d694 2
a695 9
	} else {							\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			movsw"					:	\
		    "=D" (_port2), "=S" (_port1), "=c" ((_cnt))	:	\
		    "0" (_port2), "1" (_port1), "2" ((_cnt))	:	\
		    "memory", "cc");					\
	}								\
d712 2
a713 9
	} else {							\
		__asm __volatile("					\
			cld					;	\
			repne					;	\
			movsl"					:	\
		    "=D" (_port2), "=S" (_port1), "=c" ((_cnt))	:	\
		    "0" (_port2), "1" (_port1), "2" ((_cnt))	:	\
		    "memory", "cc");					\
	}								\
d720 21
@


1.21
log
@fix espie@@'s screwup; frenchies can't type! noticed by aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.20 2000/04/08 05:50:50 aaron Exp $	*/
d779 1
a779 1
#if 0	/* Cause a link error for bus_space_copy_region_8 */
@


1.20
log
@Initial check-in for support of 32-bit CardBus PC Cards; from NetBSD. On many
machines, this code needs the new PCIBIOS* options enabled in the kernel config
file to work, but your mileage may vary. Included is a working 3c575 driver for
3Com 10/100 CardBus PC Card NICs (tested only with the 'C' revision). The 3c575
is the pccard version of the PCI EtherLink XL cards, and thus the xl driver has
been split into /sys/dev/ic.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.19 2000/03/15 03:56:49 todd Exp $	*/
d748 1
a748 1
		    "=D" (_port2), "=S" (_port1), "=c" (_(cnt))	:	\
@


1.19
log
@implimented -> implemented
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.18 1999/09/17 09:57:12 espie Exp $	*/
d97 3
@


1.18
log
@Avoid aliasing problems in K&R C.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.17 1999/08/09 12:05:29 mickey Exp $	*/
d408 1
a408 1
			!!! bus_space_write_multi_8 unimplimented !!!
@


1.18.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d408 1
a408 1
			!!! bus_space_write_multi_8 unimplemented !!!
@


1.18.4.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.27 2001/02/06 23:13:31 mickey Exp $	*/
a97 3
/* like bus_space_map(), but without extent map checking/allocation */
int	_bus_space_map __P((bus_space_tag_t t, bus_addr_t addr,
	    bus_size_t size, int cacheable, bus_space_handle_t *bshp));
d235 9
a243 2
	} else								\
		i386_space_copy(_port, _addr, 1, _cnt);			\
d258 9
a266 2
	} else								\
		i386_space_copy(_port, _addr, 2, _cnt);			\
d281 9
a289 2
	} else								\
		i386_space_copy(_port, _addr, 4, _cnt);			\
d453 9
a461 2
	} else								\
		i386_space_copy(_addr, _port, 1, _cnt);			\
d476 9
a484 2
	} else								\
		i386_space_copy(_addr, _port, 2, _cnt);			\
d499 9
a507 2
	} else								\
		i386_space_copy(_addr, _port, 4, _cnt);			\
d715 9
a723 2
	} else								\
		i386_space_copy(_port1, _port2, 1, _cnt);		\
d740 9
a748 2
	} else								\
		i386_space_copy(_port1, _port2, 2, _cnt);		\
d765 9
a773 2
	} else								\
		i386_space_copy(_port1, _port2, 4, _cnt);		\
d776 1
a776 1
#if 0	/* Cause a link error for bus_space_copy_8 */
a779 20

#define	i386_space_copy1(a1, a2, cnt, movs, df)		\
	__asm __volatile(df "\n\trep\n\t" movs :	\
	    "+S" (a1), "+D" (a2), "+c" (cnt)	:: "memory", "cc");

#define	i386_space_copy(a1, a2, sz, cnt) do {				\
	if ((void *)(a1) < (void *)(a2)) {				\
		a1 += ((cnt) - 1) * (sz); a2 += ((cnt) - 1) * (sz);	\
		switch (sz) {						\
		case 1:	i386_space_copy1(a1,a2,cnt,"movsb","std");break;\
		case 2:	i386_space_copy1(a1,a2,cnt,"movsw","std");break;\
		case 4:	i386_space_copy1(a1,a2,cnt,"movsl","std");break;\
		}							\
	} else								\
		switch (sz) {						\
		case 1:	i386_space_copy1(a1,a2,cnt,"movsb","cld");break;\
		case 2:	i386_space_copy1(a1,a2,cnt,"movsw","cld");break;\
		case 4:	i386_space_copy1(a1,a2,cnt,"movsl","cld");break;\
		}							\
} while (0)
@


1.18.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.18.4.2 2001/04/18 16:07:29 niklas Exp $	*/
d56 1
a56 1
 *	This product includes software developed by Christopher G. Demetriou
d154 3
a156 2
			loop 1b"				:	\
		    "+D" (_addr), "+c" (_cnt) : "r" ((h) + (o))	:	\
d170 2
a171 1
		    "+D" (_addr), "+c" (_cnt) : "r" ((h) + (o))	:	\
d185 2
a186 1
		    "+D" (_addr), "+c" (_cnt) : "r" ((h) + (o))	:	\
d234 3
a236 2
			loop 1b"				:	\
		    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::	\
d250 3
a252 2
			loop 1b"				:	\
		    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::	\
d266 3
a268 2
			loop 1b"				:	\
		    "+D" (_addr), "+c" (_cnt), "+d" (_port)	::	\
d351 3
a353 2
			loop 1b"				:	\
		    "+S" (_addr), "+c" (_cnt) : "r" ((h) + (o))	:	\
d366 3
a368 2
			loop 1b"				:	\
		    "+S" (_addr), "+c" (_cnt) : "r" ((h) + (o))	:	\
d381 3
a383 2
			loop 1b"				:	\
		    "+S" (_addr), "+c" (_cnt) : "r" ((h) + (o))	:	\
d431 3
a433 2
			loop 1b"				:	\
		    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::	\
d447 3
a449 2
			loop 1b"				:	\
		    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::	\
d463 3
a465 2
			loop 1b"				:	\
		    "+d" (_port), "+S" (_addr), "+c" (_cnt)	::	\
d512 5
a516 4
		1:	outb %b2, %w1				;	\
			loop 1b"				:	\
		    "+c" (_cnt) : "d" ((h) + (o)), "a" ((v))	:	\
		    "cc");						\
d520 5
a524 4
		1:	movb %b2, (%1)				;	\
			loop 1b"				:	\
		    "+c" (_cnt) : "D" ((h) + (o)), "a" ((v))	:	\
		    "cc", "memory");					\
d533 5
a537 4
		1:	outw %w2, %w1				;	\
			loop 1b"				:	\
		    "+c" (_cnt) : "d" ((h) + (o)), "a" ((v))	:	\
		    "cc");						\
d541 5
a545 4
		1:	movw %w2, (%1)				;	\
			loop 1b"				:	\
		    "+c" (_cnt) : "D" ((h) + (o)), "a" ((v))	:	\
		    "cc", "memory");					\
d554 5
a558 4
		1:	outl %2,%w1				;	\
			loop 1b"				:	\
		    "+c" (_cnt) : "d" ((h) + (o)), "a" ((v))	:	\
		    "cc");						\
d562 5
a566 4
		1:	movl %2,(%1)				;	\
			loop 1b"				:	\
		    "+c" (_cnt) : "D" ((h) + (o)), "a" ((v))	:	\
		    "cc", "memory");					\
d590 3
a592 2
			loop 1b"				:	\
		    "+d" (_port), "+c" (_cnt) : "a" ((v))	:	\
d599 2
a600 1
		    "+D" (_port), "+c" (_cnt) : "a" ((v))	:	\
d611 3
a613 2
			loop 1b"				:	\
		    "+d" (_port), "+c" (_cnt) : "a" ((v))	:	\
d620 2
a621 1
		    "+D" (_port), "+c" (_cnt) : "a" ((v))	:	\
d632 3
a634 2
			loop 1b"				:	\
		    "+d" (_port), "+c" (_cnt) : "a" ((v))	:	\
d641 2
a642 1
		    "+D" (_port), "+c" (_cnt) : "a" ((v))	:	\
d672 3
a674 2
			loop 1b"				:	\
		    "+D" (_port2), "+S" (_port1), "+c" ((_cnt))	::	\
d690 3
a692 2
			loop 1b"				:	\
		    "+D" (_port2), "+S" (_port1), "+c" ((_cnt))	::	\
d708 3
a710 2
			loop 1b"				:	\
		    "+D" (_port2), "+S" (_port1), "+c" ((_cnt))	::	\
a893 1
	bus_size_t	dm_mapsize;	/* size of the mapping */
@


1.18.4.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.18.4.3 2001/07/04 10:16:46 niklas Exp $	*/
d814 2
a815 2
	paddr_t	(*_dmamem_mmap) __P((bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int));
d896 2
a897 2
paddr_t	_bus_dmamem_mmap __P((bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, off_t off, int prot, int flags));
@


1.18.4.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d750 3
a752 1
 * Operations performed by bus_dmamap_sync().
d754 6
a759 4
#define BUS_DMASYNC_PREREAD	0x01
#define BUS_DMASYNC_POSTREAD	0x02
#define BUS_DMASYNC_PREWRITE	0x04
#define BUS_DMASYNC_POSTWRITE	0x08
d802 1
a802 1
		    bus_addr_t, bus_size_t, int));
d832 1
a832 1
#define	bus_dmamap_sync(t, p, o, l, ops)			\
d834 1
a834 1
	    (*(t)->_dmamap_sync)((t), (p), (o), (l), (ops)) : (void)0)
d885 1
a885 2
void	_bus_dmamap_sync __P((bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int));
@


1.18.4.6
log
@Merge in -current from about a week ago
@
text
@d96 2
a97 2
int	bus_space_map(bus_space_tag_t t, bus_addr_t addr,
	    bus_size_t size, int cacheable, bus_space_handle_t *bshp);
d99 6
a104 6
int	_bus_space_map(bus_space_tag_t t, bus_addr_t addr,
	    bus_size_t size, int cacheable, bus_space_handle_t *bshp);
void	bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size);
int	bus_space_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp);
d106 1
a106 1
int	bus_space_alloc(bus_space_tag_t t, bus_addr_t rstart,
d109 3
a111 3
	    bus_space_handle_t *bshp);
void	bus_space_free(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size);
d114 2
a115 2
 *	u_intN_t bus_space_read_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset);
d138 1
a138 1
 *	void bus_space_read_multi_N(bus_space_tag_t tag,
d140 1
a140 1
 *	    u_intN_t *addr, size_t count);
d193 1
a193 1
 *	void bus_space_read_raw_multi_N(bus_space_tag_t tag,
d195 1
a195 1
 *	    u_int8_t *addr, size_t count);
d214 1
a214 1
 *	void bus_space_read_region_N(bus_space_tag_t tag,
d216 1
a216 1
 *	    u_intN_t *addr, size_t count);
d273 1
a273 1
 *	void bus_space_read_raw_region_N(bus_space_tag_t tag,
d275 1
a275 1
 *	    u_int8_t *addr, size_t count);
d295 1
a295 1
 *	void bus_space_write_N(bus_space_tag_t tag,
d297 1
a297 1
 *	    u_intN_t value);
d329 1
a329 1
 *	void bus_space_write_multi_N(bus_space_tag_t tag,
d331 1
a331 1
 *	    const u_intN_t *addr, size_t count);
d385 1
a385 1
 *	void bus_space_write_raw_multi_N(bus_space_tag_t tag,
d387 1
a387 1
 *	    const u_int8_t *addr, size_t count);
d406 1
a406 1
 *	void bus_space_write_region_N(bus_space_tag_t tag,
d408 1
a408 1
 *	    const u_intN_t *addr, size_t count);
d465 1
a465 1
 *	void bus_space_write_raw_region_N(bus_space_tag_t tag,
d467 1
a467 1
 *	    const u_int8_t *addr, size_t count);
d487 1
a487 1
 *	void bus_space_set_multi_N(bus_space_tag_t tag,
d489 1
a489 1
 *	    u_intN_t val, size_t count);
d558 1
a558 1
 *	void bus_space_set_region_N(bus_space_tag_t tag,
d560 1
a560 1
 *	    u_intN_t val, size_t count);
d629 1
a629 1
 *	void bus_space_copy_N(bus_space_tag_t tag,
d632 1
a632 1
 *	    size_t count);
d717 1
a717 1
 *	void bus_space_barrier(bus_space_tag_t tag,
d719 1
a719 1
 *	    bus_size_t len, int flags);
d735 8
a742 11
#define	BUS_DMA_WAITOK		0x000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x004	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x020
#define	BUS_DMA_BUS3		0x040
#define	BUS_DMA_BUS4		0x080
#define	BUS_DMA_STREAMING	0x100	/* hint: sequential, unidirectional */
#define	BUS_DMA_READ		0x200	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x400	/* mapping is memory -> device only */
d785 14
a798 14
	int	(*_dmamap_create)(bus_dma_tag_t, bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t, bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t, bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t, bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t, bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(bus_dma_tag_t, bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	void	(*_dmamap_unload)(bus_dma_tag_t, bus_dmamap_t);
	void	(*_dmamap_sync)(bus_dma_tag_t, bus_dmamap_t,
		    bus_addr_t, bus_size_t, int);
d803 9
a811 9
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	void	(*_dmamem_free)(bus_dma_tag_t,
		    bus_dma_segment_t *, int);
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int);
d869 14
a882 14
int	_bus_dmamap_create(bus_dma_tag_t, bus_size_t, int, bus_size_t,
	    bus_size_t, int, bus_dmamap_t *);
void	_bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	_bus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	_bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
int	_bus_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
int	_bus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	_bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t,
	    bus_size_t, int);
d884 1
a884 1
int	_bus_dmamem_alloc(bus_dma_tag_t tag, bus_size_t size,
d886 9
a894 9
	    bus_dma_segment_t *segs, int nsegs, int *rsegs, int flags);
void	_bus_dmamem_free(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs);
int	_bus_dmamem_map(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, size_t size, caddr_t *kvap, int flags);
void	_bus_dmamem_unmap(bus_dma_tag_t tag, caddr_t kva,
	    size_t size);
paddr_t	_bus_dmamem_mmap(bus_dma_tag_t tag, bus_dma_segment_t *segs,
	    int nsegs, off_t off, int prot, int flags);
d896 1
a896 1
int	_bus_dmamem_alloc_range(bus_dma_tag_t tag, bus_size_t size,
d899 1
a899 1
	    vm_offset_t low, vm_offset_t high);
@


1.18.4.7
log
@Sync the SMP branch with 3.3
@
text
@d902 1
a902 1
	    paddr_t low, paddr_t high);
@


1.18.4.8
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.18.4.7 2003/03/27 23:26:55 niklas Exp $	*/
d642 1
a642 1
		1:	movl %k1,%%edx				;	\
d644 1
a644 1
			movl %k0,%%edx				;	\
d659 1
a659 1
		1:	movl %k1,%%edx				;	\
d661 1
a661 1
			movl %k0,%%edx				;	\
d666 1
a666 1
		    "+D" (_port2), "+ES" (_port1), "+c" ((_cnt))	::	\
d676 1
a676 1
		1:	movl %k1,%%edx				;	\
d678 1
a678 1
			movl %k0,%%edx				;	\
d683 1
a683 1
		    "+D" (_port2), "+ES" (_port1), "+c" ((_cnt))	::	\
@


1.18.4.9
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a102 3
/* like bus_space_unmap(), but without extent map deallocation */
void	_bus_space_unmap(bus_space_tag_t, bus_space_handle_t,
	    bus_size_t, bus_addr_t *);
@


1.17
log
@missing const in bus_space_write_region_*; niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.16 1999/08/04 23:17:40 niklas Exp $	*/
d143 1
a143 1
#define	bus_space_read_multi_1(t, h, o, a, c) do {			\
d145 2
a146 2
		insb((h) + (o), (a), (c));				\
	} else {void *_addr=(a); int _cnt=(c);				\
d158 1
a158 1
#define	bus_space_read_multi_2(t, h, o, a, c) do {			\
d160 2
a161 2
		insw((h) + (o), (a), (c));				\
	} else {void *_addr=(a); int _cnt=(c);				\
d173 1
a173 1
#define	bus_space_read_multi_4(t, h, o, a, c) do {			\
d175 2
a176 2
		insl((h) + (o), (a), (c));				\
	} else {void *_addr=(a); int _cnt=(c);				\
d223 2
a224 2
#define	bus_space_read_region_1(t, h, o, a, c) do {			\
	int _cnt = (c);	void *_addr = (a); int _port = (h)+(o);		\
d246 2
a247 2
#define	bus_space_read_region_2(t, h, o, a, c) do {			\
	int _cnt = (c);	void *_addr = (a); int _port = (h)+(o);		\
d269 2
a270 2
#define	bus_space_read_region_4(t, h, o, a, c) do {			\
	int _cnt = (c);	void *_addr = (a); int _port = (h)+(o);		\
d361 1
a361 1
#define	bus_space_write_multi_1(t, h, o, a, c) do {			\
d363 2
a364 2
		outsb((h) + (o), (a), (c));				\
	} else {const void *_addr=(a); int _cnt=(c);			\
d376 1
a376 1
#define bus_space_write_multi_2(t, h, o, a, c) do {			\
d378 2
a379 2
		outsw((h) + (o), (a), (c));				\
	} else {const void *_addr=(a); int _cnt=(c);			\
d391 1
a391 1
#define bus_space_write_multi_4(t, h, o, a, c) do {			\
d393 2
a394 2
		outsl((h) + (o), (a), (c));				\
	} else {const void *_addr=(a); int _cnt=(c);			\
d441 2
a442 2
#define	bus_space_write_region_1(t, h, o, a, c) do {			\
	int _port = (h)+(o); const void *_addr=(a); int _cnt=(c);	\
d464 2
a465 2
#define	bus_space_write_region_2(t, h, o, a, c) do {			\
	int _port = (h)+(o); const void *_addr=(a); int _cnt=(c);	\
d487 2
a488 2
#define	bus_space_write_region_4(t, h, o, a, c) do {			\
	int _port = (h)+(o); const void *_addr=(a); int _cnt=(c);	\
d546 2
a547 2
#define	bus_space_set_multi_1(t, h, o, v, c) do {			\
	int _cnt=(c);							\
d567 2
a568 2
#define	bus_space_set_multi_2(t, h, o, v, c) do {			\
	int _cnt=(c);							\
d588 2
a589 2
#define	bus_space_set_multi_4(t, h, o, v, c) do {			\
	int _cnt=(c);							\
d623 2
a624 2
#define	bus_space_set_region_1(t, h, o, v, c) do {			\
	int _port = (h)+(o); int _cnt = (c);				\
d644 2
a645 2
#define	bus_space_set_region_2(t, h, o, v, c) do {			\
	int _port = (h)+(o); int _cnt = (c);				\
d665 2
a666 2
#define	bus_space_set_region_4(t, h, o, v, c) do {			\
	int _port = (h)+(o); int _cnt = (c);				\
d701 2
a702 2
#define	bus_space_copy_1(t, h1, o1, h2, o2, c) do {			\
	int _port1 = (h1)+(o1); int _port2 = (h2)+(o2); int _cnt=(c);	\
d712 2
a713 2
		    "=D" (_port2), "=S" (_port1), "=c" ((c))	:	\
		    "0" (_port2), "1" (_port1), "2" ((c))	:	\
d720 2
a721 2
		    "=D" (_port2), "=S" (_port1), "=c" ((c))	:	\
		    "0" (_port2), "1" (_port1), "2" ((c))	:	\
d726 2
a727 2
#define	bus_space_copy_2(t, h1, o1, h2, o2, c) do {			\
	int _port1 = (h1)+(o1); int _port2 = (h2)+(o2); int _cnt=(c);	\
d737 2
a738 2
		    "=D" (_port2), "=S" (_port1), "=c" ((c))	:	\
		    "0" (_port2), "1" (_port1), "2" ((c))	:	\
d745 2
a746 2
		    "=D" (_port2), "=S" (_port1), "=c" ((c))	:	\
		    "0" (_port2), "1" (_port1), "2" ((c))	:	\
d751 2
a752 2
#define	bus_space_copy_4(t, h1, o1, h2, o2, c) do {			\
	int _port1 = (h1)+(o1); int _port2 = (h2)+(o2); int _cnt=(c);	\
d762 2
a763 2
		    "=D" (_port2), "=S" (_port1), "=c" ((c))	:	\
		    "0" (_port2), "1" (_port1), "2" ((c))	:	\
d770 2
a771 2
		    "=D" (_port2), "=S" (_port1), "=c" ((c))	:	\
		    "0" (_port2), "1" (_port1), "2" ((c))	:	\
@


1.16
log
@Match bus_dma api with NetBSD; deprecate BUS_DMAMEM_NOSYNC, introduce
BUS_DMA_COHERENT as a hint instead, currently ignored.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.15 1999/03/09 15:39:07 mickey Exp $	*/
d442 1
a442 1
	int _port = (h)+(o); void *_addr=(a); int _cnt=(c);		\
d465 1
a465 1
	int _port = (h)+(o); void *_addr=(a); int _cnt=(c);		\
d488 1
a488 1
	int _port = (h)+(o); void *_addr=(a); int _cnt=(c);		\
@


1.15
log
@add more 'cc' usage, actually overestimating gcc's smartness; also fix currently unused bus macros. kids tested mother approved
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.14 1999/01/31 14:56:01 espie Exp $	*/
d805 1
a805 1
#define	BUS_DMAMEM_NOSYNC	0x04	/* map memory to not require sync */
@


1.14
log
@Fix clobbers so that GENERIC may compile with egcs.

Historically, the documentation of extended asm was lacking, namely you
should NOT specify the same register as an input, and a clobber.
If the register is clobbered, it should be specified as an output as well,
e.g., by linking input and output through the "number" notation.

(Beware of lvalues, some local variables needed...)

In older versions, up-to egcs1.1.1, the compiler did not even warn about
it, but it was liable to output bad code. Newer egcs are pickier and
simply refuse to swallow such code.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.13 1998/10/04 22:33:41 niklas Exp $	*/
d154 1
a154 1
		    "%eax", "memory");					\
d169 1
a169 1
		    "%eax", "memory");					\
d184 1
a184 1
		    "%eax", "memory");					\
d547 1
d551 1
a551 1
		1:	outb %%al,%w0				;	\
d553 3
a555 3
								:	\
		    "d" ((h) + (o)), "c" ((c)), "a" ((v))	:	\
		    "%edx", "%ecx", "%eax");				\
d559 1
a559 1
		1:	movb %%al,(%0)				;	\
d561 3
a563 3
								:	\
		    "D" ((h) + (o)), "c" ((c)), "a" ((v))	:	\
		    "%edi", "%ecx", "%eax");				\
d568 1
d572 1
a572 1
		1:	outw %%ax,%w0				;	\
d574 3
a576 3
								:	\
		    "d" ((h) + (o)), "c" ((c)), "a" ((v))	:	\
		    "%edx", "%ecx", "%eax");				\
d580 1
a580 1
		1:	movw %%ax,(%0)				;	\
d582 3
a584 3
								:	\
		    "D" ((h) + (o)), "c" ((c)), "a" ((v))	:	\
		    "%edi", "%ecx", "%eax");				\
d589 1
d593 1
a593 1
		1:	outl %%eax,%w0				;	\
d595 3
a597 3
								:	\
		    "d" ((h) + (o)), "c" ((c)), "a" ((v))	:	\
		    "%edx", "%ecx", "%eax");				\
d601 1
a601 1
		1:	movl %%eax,(%0)				;	\
d603 3
a605 3
								:	\
		    "D" ((h) + (o)), "c" ((c)), "a" ((v))	:	\
		    "%edi", "%ecx", "%eax");				\
d631 2
a632 1
		    "0" (_port), "1" (_cnt), "a" ((v)));		\
d640 1
a640 1
		    "memory");						\
d652 2
a653 1
		    "0" (_port), "1" (_cnt), "a" ((v)));		\
d661 1
a661 1
		    "memory");						\
d673 2
a674 1
		    "0" (_port), "1" (_cnt), "a" ((v)));		\
d682 1
a682 1
		    "memory");						\
d702 1
d708 1
a708 1
			outl %%al,%%dx				;	\
d712 3
a714 3
								:	\
		    "D" ((h2)+(o2)), "S" ((h1)+(o1)), "c" ((c))	:	\
		    "%edi", "%esi", "%ecx", "%edx", "%eax", "memory");	\
d720 3
a722 3
								:	\
		    "D" ((h2)+(o2)), "S" ((h1)+(o1)), "c" ((c))	:	\
		    "%edi", "%esi", "%ecx", "memory");			\
d727 1
d737 3
a739 3
								:	\
		    "D" ((h2)+(o2)), "S" ((h1)+(o1)), "c" ((c))	:	\
		    "%edi", "%esi", "%ecx", "%edx", "%eax", "memory");	\
d745 3
a747 3
								:	\
		    "D" ((h2)+(o2)), "S" ((h1)+(o1)), "c" ((c))	:	\
		    "%edi", "%esi", "%ecx", "memory");			\
d752 1
d762 3
a764 3
								:	\
		    "D" ((h2)+(o2)), "S" ((h1)+(o1)), "c" ((c))	:	\
		    "%edi", "%esi", "%ecx", "%edx", "%eax", "memory");	\
d770 3
a772 3
								:	\
		    "D" ((h2)+(o2)), "S" ((h1)+(o1)), "c" ((c))	:	\
		    "%edi", "%esi", "%ecx", "memory");			\
@


1.13
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.12 1998/09/06 23:10:57 niklas Exp $	*/
d146 1
a146 1
	} else {							\
d149 1
a149 1
		1:	movb (%0),%%al				;	\
d152 3
a154 3
								:	\
		    "r" ((h) + (o)), "D" ((a)), "c" ((c))	:	\
		    "%edi", "%ecx", "%eax", "memory");			\
d161 1
a161 1
	} else {							\
d164 1
a164 1
		1:	movw (%0),%%ax				;	\
d167 3
a169 3
								:	\
		    "r" ((h) + (o)), "D" ((a)), "c" ((c))	:	\
		    "%edi", "%ecx", "%eax", "memory");			\
d176 1
a176 1
	} else {							\
d179 1
a179 1
		1:	movl (%0),%%eax				;	\
d182 3
a184 3
								:	\
		    "r" ((h) + (o)), "D" ((a)), "c" ((c))	:	\
		    "%edi", "%ecx", "%eax", "memory");			\
d224 1
d228 1
a228 1
		1:	inb %w0,%%al				;	\
d230 1
a230 1
			incl %0					;	\
d232 3
a234 3
								:	\
		    "d" ((h) + (o)), "D" ((a)), "c" ((c))	:	\
		    "%edx", "%edi", "%ecx", "%eax", "memory");		\
d240 3
a242 3
								:	\
		    "S" ((h) + (o)), "D" ((a)), "c" ((c))	:	\
		    "%esi", "%edi", "%ecx", "memory");			\
d247 1
d251 1
a251 1
		1:	inw %w0,%%ax				;	\
d253 1
a253 1
			addl $2,%0				;	\
d255 3
a257 3
								:	\
		    "d" ((h) + (o)), "D" ((a)), "c" ((c))	:	\
		    "%edx", "%edi", "%ecx", "%eax", "memory");		\
d263 3
a265 3
								:	\
		    "S" ((h) + (o)), "D" ((a)), "c" ((c))	:	\
		    "%esi", "%edi", "%ecx", "memory");			\
d270 1
d274 1
a274 1
		1:	inl %w0,%%eax				;	\
d276 1
a276 1
			addl $4,%0				;	\
d278 3
a280 3
								:	\
		    "d" ((h) + (o)), "D" ((a)), "c" ((c))	:	\
		    "%edx", "%edi", "%ecx", "%eax", "memory");		\
d286 3
a288 3
								:	\
		    "S" ((h) + (o)), "D" ((a)), "c" ((c))	:	\
		    "%esi", "%edi", "%ecx", "memory");			\
d364 1
a364 1
	} else {							\
d368 1
a368 1
			movb %%al,(%0)				;	\
d370 3
a372 3
								:	\
		    "r" ((h) + (o)), "S" ((a)), "c" ((c))	:	\
		    "%esi", "%ecx", "%eax");				\
d379 1
a379 1
	} else {							\
d383 1
a383 1
			movw %%ax,(%0)				;	\
d385 3
a387 3
								:	\
		    "r" ((h) + (o)), "S" ((a)), "c" ((c))	:	\
		    "%esi", "%ecx", "%eax");				\
d394 1
a394 1
	} else {							\
d398 1
a398 1
			movl %%eax,(%0)				;	\
d400 3
a402 3
								:	\
		    "r" ((h) + (o)), "S" ((a)), "c" ((c))	:	\
		    "%esi", "%ecx", "%eax");				\
d442 1
d450 3
a452 3
								:	\
		    "d" ((h) + (o)), "S" ((a)), "c" ((c))	:	\
		    "%edx", "%esi", "%ecx", "%eax", "memory");		\
d458 3
a460 3
								:	\
		    "D" ((h) + (o)), "S" ((a)), "c" ((c))	:	\
		    "%edi", "%esi", "%ecx", "memory");			\
d465 1
d473 3
a475 3
								:	\
		    "d" ((h) + (o)), "S" ((a)), "c" ((c))	:	\
		    "%edx", "%esi", "%ecx", "%eax", "memory");		\
d481 3
a483 3
								:	\
		    "D" ((h) + (o)), "S" ((a)), "c" ((c))	:	\
		    "%edi", "%esi", "%ecx", "memory");			\
d488 1
d496 3
a498 3
								:	\
		    "d" ((h) + (o)), "S" ((a)), "c" ((c))	:	\
		    "%edx", "%esi", "%ecx", "%eax", "memory");		\
d504 3
a506 3
								:	\
		    "D" ((h) + (o)), "S" ((a)), "c" ((c))	:	\
		    "%edi", "%esi", "%ecx", "memory");			\
d621 1
d627 2
a628 3
								:	\
		    "d" ((h) + (o)), "c" ((c)), "a" ((v))	:	\
		    "%edx", "%ecx", "%eax");				\
d634 3
a636 3
								:	\
		    "D" ((h) + (o)), "c" ((c)), "a" ((v))	:	\
		    "%edi", "%ecx", "%eax", "memory");			\
d641 1
d647 2
a648 3
								:	\
		    "d" ((h) + (o)), "c" ((c)), "a" ((v))	:	\
		    "%edx", "%ecx", "%eax");				\
d654 3
a656 3
								:	\
		    "D" ((h) + (o)), "c" ((c)), "a" ((v))	:	\
		    "%edi", "%ecx", "%eax", "memory");			\
d661 1
d667 2
a668 3
								:	\
		    "d" ((h) + (o)), "c" ((c)), "a" ((v))	:	\
		    "%edx", "%ecx", "%eax");				\
d674 3
a676 3
								:	\
		    "D" ((h) + (o)), "c" ((c)), "a" ((v))	:	\
		    "%edi", "%ecx", "%eax", "memory");			\
@


1.12
log
@compat with NetBSD + more *_raw_* extensions I need
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.11 1998/02/08 04:14:13 niklas Exp $	*/
d600 1
a600 1
#if 0	/* Cause a link error for bus_space_set_region_8 */
@


1.11
log
@Forward declare struct proc
@
text
@d294 22
d411 1
a411 1
 *	    u_int8_t *addr, size_t count));
d420 1
a420 1
    bus_space_write_multi_2((t), (h), (o), (u_int16_t *)(a), (c) >> 1)
d422 1
a422 1
    bus_space_write_multi_4((t), (h), (o), (u_int32_t *)(a), (c) >> 2)
d510 22
d778 5
a782 2
#define	BUS_BARRIER_READ	0x01		/* force read barrier */
#define	BUS_BARRIER_WRITE	0x02		/* force write barrier */
@


1.10
log
@Merge bus_dma support from NetBSD, mostly by Jason Thorpe.  Only i386 uses it
 so far, the other archs gets placeholders for now.  I wrote a compatibility
layer for OpenBSD's old isadma code so we can still use our old
driver sources.  They will however get changed to native bus_dma use,
on a case by case basis.   Oh yes, I almost forgot, I kept our notion
of isadma being a device so DMA-less ISA-busses still work
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.9 1998/01/17 09:58:39 niklas Exp $	*/
d751 1
@


1.9
log
@Merge from NetBSD, thorpej@@netbsd.org says:

Two things pointed out by Chris Demetriou <cgd@@cs.cmu.edu>:
- The boundary argument to bus_space_alloc() should be a bus_size_t, not
  a bus_addr_t.
- The buffer arguments in the "multiple write" methods should have
  const qualifiers.

And one from me:
- Make bus_space_barrier() eat up the arguments passed to it so that
  the compiler doesn't needlessly whine.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.8 1997/07/05 19:29:51 mickey Exp $	*/
d4 37
d736 171
@


1.8
log
@implement unimplemented.....
implement unimplemented.....
implement unimplemented.....
in cc -S it looks like it should....
in cc -S it looks like it should....
in cc -S it looks like it should....
@
text
@d1 2
a2 2
/*	$OpenBSD: bus.h,v 1.7 1996/11/28 23:37:38 niklas Exp $	*/
/*	$NetBSD: bus.h,v 1.5 1996/10/21 22:26:19 thorpej Exp $	*/
d68 1
a68 1
	    bus_addr_t boundary, int cacheable, bus_addr_t *addrp,
d293 1
a293 1
 *	    u_intN_t *addr, size_t count));
d373 1
a373 1
 *	    u_intN_t *addr, size_t count));
d695 2
a696 1
#define	bus_space_barrier(t, h, o, l, f)
@


1.7
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.6 1996/11/12 22:46:27 niklas Exp $	*/
d452 2
a453 1
 *	    bus_space_handle_t bsh, u_intN_t val, size_t count));
d459 64
a522 1
	/* XXX IMPLEMENT bus_space_set_multi_N() XXX */
d526 2
a527 1
 *	    bus_space_handle_t bsh, u_intN_t val, size_t count));
d533 64
a596 1
	/* XXX IMPLEMENT bus_space_set_region_N() XXX */
d608 76
a683 1
	/* XXX IMPLEMENT bus_space_copy_N() XXX */
@


1.6
log
@Arrival of new bus.h from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.5 1996/10/21 22:26:19 thorpej Exp $	*/
d156 21
d347 21
@


1.5
log
@Do our extensions to the bus.h interface slightly different
@
text
@d1 2
a2 2
/*	$OpenBSD: bus.h,v 1.2 1996/04/21 22:16:46 deraadt Exp $	*/
/*	$NetBSD: bus.h,v 1.3 1996/05/03 19:22:18 christos Exp $	*/
d5 2
d42 1
a42 1
 * I/O addresses (in bus space)
d44 2
a45 2
typedef u_long bus_io_addr_t;
typedef u_long bus_io_size_t;
d48 1
a48 1
 * Memory addresses (in bus space)
d50 183
a232 85
typedef u_long bus_mem_addr_t;
typedef u_long bus_mem_size_t;

/*
 * Access methods for bus resources, I/O space, and memory space.
 */
typedef void *bus_chipset_tag_t;
typedef u_long bus_io_handle_t;
typedef caddr_t bus_mem_handle_t;

#define bus_io_map(t, port, size, iohp)					\
    ((void) t, *iohp = port, 0)
#define bus_io_unmap(t, ioh, size)

#define	bus_io_read_1(t, h, o)		((void) t, inb((h) + (o)))
#define	bus_io_read_2(t, h, o)		((void) t, inw((h) + (o)))
#define	bus_io_read_4(t, h, o)		((void) t, inl((h) + (o)))
#if 0 /* Cause a link error for bus_io_read_8 */
#define	bus_io_read_8(t, h, o)		!!! bus_io_read_8 unimplemented !!!
#endif

#define	bus_io_read_multi_1(t, h, o, a, c)	\
					((void) t, insb((h) + (o), (a), (c)))
#define	bus_io_read_multi_2(t, h, o, a, c)	\
					((void) t, insw((h) + (o), (a), (c)))
#define	bus_io_read_multi_4(t, h, o, a, c)	\
					((void) t, insl((h) + (o), (a), (c)))
#if 0 /* Cause a link error for bus_io_read_multi_8 */
#define	bus_io_read_multi_8(t, h, o, a, c)	\
				!!! bus_io_read_multi_8 unimplemented !!!
#endif

#define	bus_io_write_1(t, h, o, v)	((void) t, outb((h) + (o), (v)))
#define	bus_io_write_2(t, h, o, v)	((void) t, outw((h) + (o), (v)))
#define	bus_io_write_4(t, h, o, v)	((void) t, outl((h) + (o), (v)))
#if 0 /* Cause a link error for bus_io_write_8 */
#define	bus_io_write_8(t, h, o, v)	!!! bus_io_write_8 unimplemented !!!
#endif

#define	bus_io_write_multi_1(t, h, o, a, c)	\
					((void) t, outsb((h) + (o), (a), (c)))
#define	bus_io_write_multi_2(t, h, o, a, c)	\
					((void) t, outsw((h) + (o), (a), (c)))
#define	bus_io_write_multi_4(t, h, o, a, c)	\
					((void) t, outsl((h) + (o), (a), (c)))
#if 0 /* Cause a link error for bus_io_write_multi_8 */
#define	bus_io_write_multi_8(t, h, o, a, c)	\
				!!! bus_io_write_multi_8 unimplimented !!!
#endif

int	bus_mem_map __P((bus_chipset_tag_t t, bus_mem_addr_t bpa,
	    bus_mem_size_t size, int cacheable, bus_mem_handle_t *mhp));
void	bus_mem_unmap __P((bus_chipset_tag_t t, bus_mem_handle_t memh,
	    bus_mem_size_t size));

#define	bus_mem_read_1(t, h, o)	((void) t, (*(volatile u_int8_t *)((h) + (o))))
#define	bus_mem_read_2(t, h, o)	((void) t, (*(volatile u_int16_t *)((h) + (o))))
#define	bus_mem_read_4(t, h, o)	((void) t, (*(volatile u_int32_t *)((h) + (o))))
#define	bus_mem_read_8(t, h, o)	((void) t, (*(volatile u_int64_t *)((h) + (o))))

#define	bus_mem_write_1(t, h, o, v)					\
    ((void) t, ((void)(*(volatile u_int8_t *)((h) + (o)) = (v))))
#define	bus_mem_write_2(t, h, o, v)					\
    ((void) t, ((void)(*(volatile u_int16_t *)((h) + (o)) = (v))))
#define	bus_mem_write_4(t, h, o, v)					\
    ((void) t, ((void)(*(volatile u_int32_t *)((h) + (o)) = (v))))
#define	bus_mem_write_8(t, h, o, v)					\
    ((void) t, ((void)(*(volatile u_int64_t *)((h) + (o)) = (v))))

#define	bus_io_read_raw_multi_2(t, h, o, a, c)	\
    ((void) t, insw((h) + (o), (a), (c) >> 1))
#define	bus_io_read_raw_multi_4(t, h, o, a, c)	\
    ((void) t, insl((h) + (o), (a), (c) >> 2))
#if 0 /* Cause a link error for bus_io_read_raw_multi_8 */
#define	bus_io_read_raw_multi_8(t, h, o, a, c)	\
				!!! bus_io_read_multi_8 unimplemented !!!
#endif

#define	bus_io_write_raw_multi_2(t, h, o, a, c)	\
    ((void) t, outsw((h) + (o), (a), (c) >> 1))
#define	bus_io_write_raw_multi_4(t, h, o, a, c)	\
    ((void) t, outsl((h) + (o), (a), (c) >> 2))
#if 0 /* Cause a link error for bus_io_write_raw_multi_8 */
#define	bus_io_write_raw_multi_8(t, h, o, a, c)	\
				!!! bus_io_write_multi_8 unimplimented !!!
d234 219
@


1.4
log
@sync with 0504; prototype changes
@
text
@d117 8
a124 4
/* These are extensions to the general NetBSD bus interface.  */
#define bus_to_host_2(t, v) (v)
#define bus_to_host_4(t, v) (v)
#define bus_to_host_8(t, v) (v)
d126 8
a133 3
#define bus_from_host_2(t, v) (v)
#define bus_from_host_4(t, v) (v)
#define bus_from_host_8(t, v) (v)
@


1.3
log
@Extend the bus.h interface with endian conversion functions and use
where relevant.
@
text
@d2 1
a2 1
/*	$NetBSD: bus.h,v 1.2 1996/04/05 23:59:37 thorpej Exp $	*/
d59 1
a59 1
    (*iohp = port, 0)
d62 3
a64 3
#define	bus_io_read_1(t, h, o)		inb((h) + (o))
#define	bus_io_read_2(t, h, o)		inw((h) + (o))
#define	bus_io_read_4(t, h, o)		inl((h) + (o))
d70 1
a70 1
					insb((h) + (o), (a), (c))
d72 1
a72 1
					insw((h) + (o), (a), (c))
d74 1
a74 1
					insl((h) + (o), (a), (c))
d80 3
a82 3
#define	bus_io_write_1(t, h, o, v)	outb((h) + (o), (v))
#define	bus_io_write_2(t, h, o, v)	outw((h) + (o), (v))
#define	bus_io_write_4(t, h, o, v)	outl((h) + (o), (v))
d88 1
a88 1
					outsb((h) + (o), (a), (c))
d90 1
a90 1
					outsw((h) + (o), (a), (c))
d92 1
a92 1
					outsl((h) + (o), (a), (c))
d103 4
a106 4
#define	bus_mem_read_1(t, h, o)		(*(volatile u_int8_t *)((h) + (o)))
#define	bus_mem_read_2(t, h, o)		(*(volatile u_int16_t *)((h) + (o)))
#define	bus_mem_read_4(t, h, o)		(*(volatile u_int32_t *)((h) + (o)))
#define	bus_mem_read_8(t, h, o)		(*(volatile u_int64_t *)((h) + (o)))
d109 1
a109 1
    ((void)(*(volatile u_int8_t *)((h) + (o)) = (v)))
d111 1
a111 1
    ((void)(*(volatile u_int16_t *)((h) + (o)) = (v)))
d113 1
a113 1
    ((void)(*(volatile u_int32_t *)((h) + (o)) = (v)))
d115 1
a115 1
    ((void)(*(volatile u_int64_t *)((h) + (o)) = (v)))
@


1.2
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.1 1996/04/18 19:21:33 niklas Exp $	*/
d116 9
@


1.1
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: bus.h,v 1.1 1996/03/08 20:11:23 cgd Exp $	*/
d69 11
d85 11
@
