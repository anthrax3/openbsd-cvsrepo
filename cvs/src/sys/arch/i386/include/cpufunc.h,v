head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.2
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.22.0.10
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.6
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.8
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.19.0.4
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.14.0.10
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.6
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.10
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.8
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.6
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2017.02.06.09.13.41;	author mpi;	state Exp;
branches;
next	1.22;
commitid	wTgEeyM3ktFNF2jh;

1.22
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2013.12.06.22.56.20;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2013.10.09.01.48.41;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2012.12.05.23.20.12;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2011.03.23.16.54.35;	author pirofti;	state Exp;
branches;
next	1.17;

1.17
date	2010.08.19.19.31.53;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.09.14.28.46;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.13.13.24.48;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.28.17.05.09;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.17.17.38.37;	author tom;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.13.21.49.16;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.28.13.22.44;	author avsm;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.24.09.03.20;	author grange;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.27.23.52.01;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.18.20.37.42;	author espie;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2000.07.05.14.19.29;	author hugh;	state Exp;
branches;
next	1.5;

1.5
date	99.11.20.11.18.59;	author matthieu;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.10.26.03.44.17;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.09.11.10.45.46;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.09.04.22.40.44;	author chuck;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.35;	author deraadt;	state Exp;
branches;
next	;

1.5.2.1
date	2001.04.18.16.07.30;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2003.04.15.03.53.47;	author niklas;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2003.06.07.11.11.37;	author ho;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.35.53;	author art;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Implement Dynamic Profiling, a ddb(4) based & gprof compatible kernel
profiling framework, for i386.

Code patching is used to enable probes when entering functions.  The
probes will call a mcount()-like function to match the behavior of a
GPROF kernel.

A new sysctl knob, ddb.profile, need to be set to 1 in securelevel 0
to be able to use this feature.

ok jasper@@, guenther@@, mlarkin@@
@
text
@/*	$OpenBSD: cpufunc.h,v 1.22 2014/03/29 18:09:29 guenther Exp $	*/
/*	$NetBSD: cpufunc.h,v 1.8 1994/10/27 04:15:59 cgd Exp $	*/

/*
 * Copyright (c) 1993 Charles Hannum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Charles Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_CPUFUNC_H_
#define	_MACHINE_CPUFUNC_H_

#ifdef _KERNEL

/*
 * Functions to provide access to i386-specific instructions.
 */

#include <sys/types.h>

#include <machine/specialreg.h>

static __inline void invlpg(u_int);
static __inline void lidt(void *);
static __inline void lldt(u_short);
static __inline void ltr(u_short);
static __inline void lcr0(u_int);
static __inline u_int rcr0(void);
static __inline u_int rcr2(void);
static __inline void lcr3(u_int);
static __inline u_int rcr3(void);
static __inline void lcr4(u_int);
static __inline u_int rcr4(void);
static __inline void tlbflush(void);
static __inline void tlbflushg(void);
static __inline void disable_intr(void);
static __inline void enable_intr(void);
static __inline u_int read_eflags(void);
static __inline void write_eflags(u_int);
static __inline void wbinvd(void);
static __inline void clflush(u_int32_t addr);
static __inline void mfence(void);
static __inline void wrmsr(u_int, u_int64_t);
static __inline u_int64_t rdmsr(u_int);
static __inline void breakpoint(void);

static __inline void 
invlpg(u_int addr)
{ 
        __asm volatile("invlpg (%0)" : : "r" (addr) : "memory");
}  

static __inline void
lidt(void *p)
{
	__asm volatile("lidt (%0)" : : "r" (p) : "memory");
}

static __inline void
lldt(u_short sel)
{
	__asm volatile("lldt %0" : : "r" (sel));
}

static __inline void
ltr(u_short sel)
{
	__asm volatile("ltr %0" : : "r" (sel));
}

static __inline void
lcr0(u_int val)
{
	__asm volatile("movl %0,%%cr0" : : "r" (val));
}

static __inline u_int
rcr0(void)
{
	u_int val;
	__asm volatile("movl %%cr0,%0" : "=r" (val));
	return val;
}

static __inline u_int
rcr2(void)
{
	u_int val;
	__asm volatile("movl %%cr2,%0" : "=r" (val));
	return val;
}

static __inline void
lcr3(u_int val)
{
	__asm volatile("movl %0,%%cr3" : : "r" (val));
}

static __inline u_int
rcr3(void)
{
	u_int val;
	__asm volatile("movl %%cr3,%0" : "=r" (val));
	return val;
}

static __inline void
lcr4(u_int val)
{
	__asm volatile("movl %0,%%cr4" : : "r" (val));
}

static __inline u_int
rcr4(void)
{
	u_int val;
	__asm volatile("movl %%cr4,%0" : "=r" (val));
	return val;
}

static __inline void
tlbflush(void)
{
	u_int val;
	__asm volatile("movl %%cr3,%0" : "=r" (val));
	__asm volatile("movl %0,%%cr3" : : "r" (val));
}

static __inline void
tlbflushg(void)
{
	/*
	 * Big hammer: flush all TLB entries, including ones from PTE's
	 * with the G bit set.  This should only be necessary if TLB
	 * shootdown falls far behind.
	 *
	 * Intel Architecture Software Developer's Manual, Volume 3,
	 *	System Programming, section 9.10, "Invalidating the
	 * Translation Lookaside Buffers (TLBS)":
	 * "The following operations invalidate all TLB entries, irrespective
	 * of the setting of the G flag:
	 * ...
	 * "(P6 family processors only): Writing to control register CR4 to
	 * modify the PSE, PGE, or PAE flag."
	 *
	 * (the alternatives not quoted above are not an option here.)
	 *
	 * If PGE is not in use, we reload CR3 for the benefit of
	 * pre-P6-family processors.
	 */

	if (cpu_feature & CPUID_PGE) {
		u_int cr4 = rcr4();
		lcr4(cr4 & ~CR4_PGE);
		lcr4(cr4);
	} else
		tlbflush();
}

#ifdef notyet
void	setidt(int idx, /*XXX*/caddr_t func, int typ, int dpl);
#endif


/* XXXX ought to be in psl.h with spl() functions */

static __inline void
disable_intr(void)
{
	__asm volatile("cli");
}

static __inline void
enable_intr(void)
{
	__asm volatile("sti");
}

static __inline u_int
read_eflags(void)
{
	u_int ef;

	__asm volatile("pushfl; popl %0" : "=r" (ef));
	return (ef);
}

static __inline void
write_eflags(u_int ef)
{
	__asm volatile("pushl %0; popfl" : : "r" (ef));
}

static inline u_long
intr_disable(void)
{
	u_long ef;

	ef = read_eflags();
	disable_intr();
	return (ef);
}

static inline void
intr_restore(u_long ef)
{
	write_eflags(ef);
}

static __inline void
wbinvd(void)
{
        __asm volatile("wbinvd");
}

static __inline void
clflush(u_int32_t addr)
{
	__asm volatile("clflush %0" : "+m" (*(volatile char *)addr));
}

static __inline void
mfence(void)
{
	__asm volatile("mfence" : : : "memory");
}

static __inline void
wrmsr(u_int msr, u_int64_t newval)
{
        __asm volatile("wrmsr" : : "A" (newval), "c" (msr));
}

static __inline u_int64_t
rdmsr(u_int msr)
{
        u_int64_t rv;

        __asm volatile("rdmsr" : "=A" (rv) : "c" (msr));
        return (rv);
}

static __inline void
monitor(const volatile void *addr, u_long extensions, u_int hints)
{
	__asm volatile("monitor"
	    : : "a" (addr), "c" (extensions), "d" (hints));
}

static __inline void
mwait(u_long extensions, u_int hints)
{
	__asm volatile("mwait" : : "a" (hints), "c" (extensions));
}

/* 
 * Some of the undocumented AMD64 MSRs need a 'passcode' to access.
 *
 * See LinuxBIOSv2: src/cpu/amd/model_fxx/model_fxx_init.c
 */

#define	OPTERON_MSR_PASSCODE	0x9c5a203a
 
static __inline u_int64_t
rdmsr_locked(u_int msr, u_int code)
{
	uint64_t rv;
	__asm volatile("rdmsr"
	    : "=A" (rv)
	    : "c" (msr), "D" (code));
	return (rv);
}

static __inline void
wrmsr_locked(u_int msr, u_int code, u_int64_t newval)
{
	__asm volatile("wrmsr"
	    :
	    : "A" (newval), "c" (msr), "D" (code));
}

/* Break into DDB/KGDB. */
static __inline void
breakpoint(void)
{
	__asm volatile("int $3");
}

#define read_psl()	read_eflags()
#define write_psl(x)	write_eflags(x)

void amd64_errata(struct cpu_info *);

#endif /* _KERNEL */
#endif /* !_MACHINE_CPUFUNC_H_ */
@


1.22
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.21 2013/12/06 22:56:20 kettenis Exp $	*/
d216 16
@


1.21
log
@Make clflush() flush the cache line specified by the address we pass it
instead of the cache line containing the local variable used to specify the
address.  Fixes the gnome corruption and hangs people have been experiencing
for the last couple of months or so.

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.20 2013/10/09 01:48:41 guenther Exp $	*/
d74 1
a74 1
        __asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
d80 1
a80 1
	__asm __volatile("lidt (%0)" : : "r" (p) : "memory");
d86 1
a86 1
	__asm __volatile("lldt %0" : : "r" (sel));
d92 1
a92 1
	__asm __volatile("ltr %0" : : "r" (sel));
d98 1
a98 1
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
d105 1
a105 1
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
d113 1
a113 1
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
d120 1
a120 1
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
d127 1
a127 1
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
d134 1
a134 1
	__asm __volatile("movl %0,%%cr4" : : "r" (val));
d141 1
a141 1
	__asm __volatile("movl %%cr4,%0" : "=r" (val));
d149 2
a150 2
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
d194 1
a194 1
	__asm __volatile("cli");
d200 1
a200 1
	__asm __volatile("sti");
d208 1
a208 1
	__asm __volatile("pushfl; popl %0" : "=r" (ef));
d215 1
a215 1
	__asm __volatile("pushl %0; popfl" : : "r" (ef));
d221 1
a221 1
        __asm __volatile("wbinvd");
d227 1
a227 1
	__asm __volatile("clflush %0" : "+m" (*(volatile char *)addr));
d233 1
a233 1
	__asm __volatile("mfence" : : : "memory");
d239 1
a239 1
        __asm __volatile("wrmsr" : : "A" (newval), "c" (msr));
d247 1
a247 1
        __asm __volatile("rdmsr" : "=A" (rv) : "c" (msr));
d254 1
a254 1
	__asm __volatile("monitor"
d261 1
a261 1
	__asm __volatile("mwait" : : "a" (hints), "c" (extensions));
d294 1
a294 1
	__asm __volatile("int $3");
@


1.20
log
@Use monitor/mwait to idle when available.  Make cpu_unidle() do nothing
if it can tell the target CPU isn't actually idling and introduce cpu_kick()
for the cases where we want to force a non-idle CPU into the kernel.

just a port of the amd64 version; testing by many
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.19 2012/12/05 23:20:12 deraadt Exp $	*/
d227 1
a227 1
	__asm __volatile("clflush %0" : "+m" (addr));
@


1.19
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.18 2011/03/23 16:54:35 pirofti Exp $	*/
d249 13
@


1.18
log
@Normalize sentinel. Use _MACHINE_*_H_ and _<ARCH>_*_H_ properly and consitently.

Discussed and okay drahn@@. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.17 2010/08/19 19:31:53 kettenis Exp $	*/
a42 1
#include <sys/cdefs.h>
@


1.17
log
@Add "memory" clobber to lidt inline asm, to prevent the GCC optimizer from
getting stupid ideas like optimizing away stores to the descriptor that we're
setting.  This may be overkill, but this code is far from performance
critical and it may prevent future surprises.  Fixes instant reboots
with bsd.rd on Pentiums with the F00F bug.

Thanks to espie@@, for narrowing the issue down enough for me to find the
problem.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.16 2009/12/09 14:28:46 oga Exp $	*/
d34 2
a35 2
#ifndef _I386_CPUFUNC_H_
#define	_I386_CPUFUNC_H_
d291 1
a291 1
#endif /* !_I386_CPUFUNC_H_ */
@


1.16
log
@add cpufunc functions for the clflush instruction and the mfence
instruction.

ok kettenis@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.15 2009/08/13 13:24:48 kettenis Exp $	*/
d81 1
a81 1
	__asm __volatile("lidt (%0)" : : "r" (p));
@


1.15
log
@Make the i386 APIC code closer to the amd64 version.  Many whitespace fixes,
some additional code.

ok toby@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.14 2007/11/28 17:05:09 tedu Exp $	*/
d66 2
d225 11
@


1.14
log
@quite a bit of simplification by removing cpu classes.
also assume that 386 cpus are really unknown, and promote them to 486
instead of panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.13 2007/02/17 17:38:37 tom Exp $	*/
d271 3
@


1.13
log
@Bring in the AMD errata checks from amd64.

Changes to either copy of amd64errata.c must be replicated in the other.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.12 2004/06/13 21:49:16 niklas Exp $	*/
a174 1
#if defined(I686_CPU)
a179 1
#endif
a271 1
#ifdef I686_CPU
a272 1
#endif
@


1.12
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d241 26
d273 4
@


1.11
log
@guard cpu register functions from userland, otherwise they appear when
including stuff like <sys/sysctl.h>
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.10 2003/10/24 09:03:20 grange Exp $	*/
d46 2
d60 1
d150 33
@


1.10
log
@No need to have several implementations of {read,write}_eflags(),
put it to cpufunc.h.
ok weingart@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.9 2003/05/27 23:52:01 fgsch Exp $	*/
d37 2
d212 1
@


1.9
log
@change .byte for the correct opcodes now that gas can handle'em.
art@@ toby@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.8 2002/03/14 01:26:33 millert Exp $	*/
d58 2
d164 15
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.7 2001/08/18 20:37:42 espie Exp $	*/
d174 1
a174 1
        __asm __volatile(".byte 0x0f, 0x30" : : "A" (newval), "c" (msr));
d182 1
a182 1
        __asm __volatile(".byte 0x0f, 0x32" : "=A" (rv) : "c" (msr));
@


1.7
log
@Fix functions to match prototypes. Old K&R doesn't make sense with inline
stuff anyways.
Ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.6 2000/07/05 14:19:29 hugh Exp $	*/
d44 18
a61 18
static __inline void invlpg __P((u_int));
static __inline void lidt __P((void *));
static __inline void lldt __P((u_short));
static __inline void ltr __P((u_short));
static __inline void lcr0 __P((u_int));
static __inline u_int rcr0 __P((void));
static __inline u_int rcr2 __P((void));
static __inline void lcr3 __P((u_int));
static __inline u_int rcr3 __P((void));
static __inline void lcr4 __P((u_int));
static __inline u_int rcr4 __P((void));
static __inline void tlbflush __P((void));
static __inline void disable_intr __P((void));
static __inline void enable_intr __P((void));
static __inline void wbinvd __P((void));
static __inline void wrmsr __P((u_int, u_int64_t));
static __inline u_int64_t rdmsr __P((u_int));
static __inline void breakpoint __P((void));
d146 1
a146 1
void	setidt	__P((int idx, /*XXX*/caddr_t func, int typ, int dpl));
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.7 2001/08/18 20:37:42 espie Exp $	*/
d44 18
a61 18
static __inline void invlpg(u_int);
static __inline void lidt(void *);
static __inline void lldt(u_short);
static __inline void ltr(u_short);
static __inline void lcr0(u_int);
static __inline u_int rcr0(void);
static __inline u_int rcr2(void);
static __inline void lcr3(u_int);
static __inline u_int rcr3(void);
static __inline void lcr4(u_int);
static __inline u_int rcr4(void);
static __inline void tlbflush(void);
static __inline void disable_intr(void);
static __inline void enable_intr(void);
static __inline void wbinvd(void);
static __inline void wrmsr(u_int, u_int64_t);
static __inline u_int64_t rdmsr(u_int);
static __inline void breakpoint(void);
d146 1
a146 1
void	setidt(int idx, /*XXX*/caddr_t func, int typ, int dpl);
@


1.6
log
@Add a breakpoint() inline for use with KGDB.
Ok'd by mickey.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.5 1999/11/20 11:18:59 matthieu Exp $	*/
d58 4
a63 1
#ifdef __cplusplus
a64 4
#else
invlpg(addr)
	u_int addr;
#endif
a69 1
#ifdef __cplusplus
a70 4
#else
lidt(p)
	void *p;
#endif
a75 1
#ifdef __cplusplus
a76 4
#else
lldt(sel)
	u_short sel;
#endif
a81 1
#ifdef __cplusplus
a82 4
#else
ltr(sel)
	u_short sel;
#endif
a87 1
#ifdef __cplusplus
a88 4
#else
lcr0(val)
	u_int val;
#endif
a93 1
#ifdef __cplusplus
a94 3
#else
rcr0()
#endif
a101 1
#ifdef __cplusplus
a102 3
#else
rcr2()
#endif
a109 1
#ifdef __cplusplus
a110 4
#else
lcr3(val)
	u_int val;
#endif
a115 1
#ifdef __cplusplus
a116 3
#else
rcr3()
#endif
a123 1
#ifdef __cplusplus
a124 4
#else
lcr4(val)
	u_int val;
#endif
a129 1
#ifdef __cplusplus
a130 3
#else
rcr4()
#endif
a137 1
#ifdef __cplusplus
a138 3
#else
tlbflush()
#endif
a152 1
#ifdef __cplusplus
a153 3
#else
disable_intr()
#endif
a158 1
#ifdef __cplusplus
a159 3
#else
enable_intr()
#endif
@


1.5
log
@add MTRR support from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.4 1999/10/26 03:44:17 downsj Exp $	*/
d243 7
@


1.5.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.6 2000/07/05 14:19:29 hugh Exp $	*/
a242 7
}

/* Break into DDB/KGDB. */
static __inline void
breakpoint(void)
{
	__asm __volatile("int $3");
@


1.5.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.5.2.1 2001/04/18 16:07:30 niklas Exp $	*/
a57 4
static __inline void wbinvd __P((void));
static __inline void wrmsr __P((u_int, u_int64_t));
static __inline u_int64_t rdmsr __P((u_int));
static __inline void breakpoint __P((void));
d60 1
d62 4
d71 1
d73 4
d82 1
d84 4
d93 1
d95 4
d104 1
d106 4
d115 1
d117 3
d127 1
d129 3
d139 1
d141 4
d150 1
d152 3
d162 1
d164 4
d173 1
d175 3
d185 1
d187 3
d204 1
d206 3
d214 1
d216 3
@


1.5.2.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 18
a61 18
static __inline void invlpg(u_int);
static __inline void lidt(void *);
static __inline void lldt(u_short);
static __inline void ltr(u_short);
static __inline void lcr0(u_int);
static __inline u_int rcr0(void);
static __inline u_int rcr2(void);
static __inline void lcr3(u_int);
static __inline u_int rcr3(void);
static __inline void lcr4(u_int);
static __inline u_int rcr4(void);
static __inline void tlbflush(void);
static __inline void disable_intr(void);
static __inline void enable_intr(void);
static __inline void wbinvd(void);
static __inline void wrmsr(u_int, u_int64_t);
static __inline u_int64_t rdmsr(u_int);
static __inline void breakpoint(void);
d146 1
a146 1
void	setidt(int idx, /*XXX*/caddr_t func, int typ, int dpl);
@


1.5.2.4
log
@Add TLB shootdown logic, mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.5.2.4 2003/04/14 14:02:52 niklas Exp $	*/
a43 2
#include <machine/specialreg.h>

a55 1
static __inline void tlbflushg(void);
a142 33
}

static __inline void
tlbflushg(void)
{
	/*
	 * Big hammer: flush all TLB entries, including ones from PTE's
	 * with the G bit set.  This should only be necessary if TLB
	 * shootdown falls far behind.
	 *
	 * Intel Architecture Software Developer's Manual, Volume 3,
	 *	System Programming, section 9.10, "Invalidating the
	 * Translation Lookaside Buffers (TLBS)":
	 * "The following operations invalidate all TLB entries, irrespective
	 * of the setting of the G flag:
	 * ...
	 * "(P6 family processors only): Writing to control register CR4 to
	 * modify the PSE, PGE, or PAE flag."
	 *
	 * (the alternatives not quoted above are not an option here.)
	 *
	 * If PGE is not in use, we reload CR3 for the benefit of
	 * pre-P6-family processors.
	 */

#if defined(I686_CPU)
	if (cpu_feature & CPUID_PGE) {
		u_int cr4 = rcr4();
		lcr4(cr4 & ~CR4_PGE);
		lcr4(cr4);
	} else
#endif
		tlbflush();
@


1.5.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cpufunc.h,v 1.5.2.4 2003/04/15 03:53:47 niklas Exp $	*/
d210 1
a210 1
        __asm __volatile("wrmsr" : : "A" (newval), "c" (msr));
d218 1
a218 1
        __asm __volatile("rdmsr" : "=A" (rv) : "c" (msr));
@


1.5.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a36 2
#ifdef _KERNEL

a60 2
static __inline u_int read_eflags(void);
static __inline void write_eflags(u_int);
a199 15
static __inline u_int
read_eflags(void)
{
	u_int ef;

	__asm __volatile("pushfl; popl %0" : "=r" (ef));
	return (ef);
}

static __inline void
write_eflags(u_int ef)
{
	__asm __volatile("pushl %0; popfl" : : "r" (ef));
}

a228 1
#endif /* _KERNEL */
@


1.4
log
@Clean up function declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d221 22
@


1.3
log
@toast BDB; netbsd
@
text
@d1 1
d44 15
d60 1
d62 4
d71 1
d73 4
d82 1
d84 4
d93 1
d95 4
d104 1
d106 4
d115 1
d117 3
d127 1
d129 3
d139 1
d141 4
d150 1
d152 3
d162 1
d164 4
d173 1
d175 3
d185 1
d187 3
d204 1
d206 3
d214 1
d216 3
@


1.2
log
@add invlpg and %cr4 read/write
@
text
@a42 10
static __inline int bdb(void)
{
	extern int bdb_exists;

	if (!bdb_exists)
		return (0);
	__asm __volatile("int $3");
	return (1);
}

@


1.1
log
@Initial revision
@
text
@d53 6
d110 14
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
