head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.4
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.5.0.4
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.3.0.4
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.2
	OPENBSD_5_9_BASE:1.3;
locks; strict;
comment	@# @;


1.7
date	2017.06.21.20.08.53;	author deraadt;	state Exp;
branches;
next	1.6;
commitid	Dg8ECkEnytHgsqe9;

1.6
date	2017.05.31.19.18.18;	author deraadt;	state Exp;
branches;
next	1.5;
commitid	HlDgymhwBU2bW7Tm;

1.5
date	2016.10.18.18.44.47;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	WbyZEzzTpGprdfaE;

1.4
date	2016.09.03.13.13.07;	author deraadt;	state Exp;
branches;
next	1.3;
commitid	MO2vedHMyHNyR6Mg;

1.3
date	2016.02.20.19.59.01;	author mlarkin;	state Exp;
branches;
next	1.2;
commitid	YdhhS211QfzgRU4H;

1.2
date	2015.08.15.19.01.39;	author mlarkin;	state Exp;
branches;
next	1.1;
commitid	Wx8F77BQbywDpfDz;

1.1
date	2015.08.12.06.19.25;	author mlarkin;	state Exp;
branches;
next	;
commitid	laQtIfN3a82NKYjy;


desc
@@


1.7
log
@Fill space between sections with traps, rather than nops.
@
text
@/*	$OpenBSD: ld.script,v 1.6 2017/05/31 19:18:18 deraadt Exp $	*/

/*
 * Copyright (c) 2015 Mike Larkin <mlarkin@@openbsd.org>
 * Copyright (c) 2009 Tobias Weingartner <weingart@@tepid.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
OUTPUT_ARCH(i386)

/* Define how we want out ELF binary to look like. */
PHDRS
{
	text PT_LOAD FILEHDR PHDRS;
	rodata PT_LOAD;
	data PT_LOAD;
	bss PT_LOAD;
	openbsd_randomize PT_OPENBSD_RANDOMIZE;
}

/*
 * If we want the text/rodata/data sections aligned on 2M boundaries,
 * we could use the following instead.  Note, file size would increase
 * due to necessary padding.
 *
 *__ALIGN_SIZE = 0x200000;
 */
__ALIGN_SIZE = 0x1000;
__kernel_base_virt = 0xd0200000 + SIZEOF_HEADERS;
__kernel_base_phys = __kernel_base_virt & 0xfffffff;

/* We use physical address to jump to kernel */
start_phys = LOADADDR(.text) + (start - __kernel_base_virt);
ENTRY(start_phys)
SECTIONS
{
	__kernel_text_virt = __kernel_base_virt;
	__kernel_text_phys = __kernel_base_phys;
	.text (__kernel_text_virt) : AT (__kernel_text_phys)
	{
		__text_start = ABSOLUTE(.) & 0xfffff000;
		__text_size = SIZEOF(.text);
		__text_load = LOADADDR(.text);
		locore0.o(.text)
		*(.text .text.*)
	} :text =0xcccccccc
	PROVIDE (__etext = .);
	PROVIDE (etext = .);
	_etext = .;

	/* Move rodata to the next page, so we can nuke X and W bit on them */
	. = ALIGN(__ALIGN_SIZE);
	__kernel_rodata_virt = .;
	__kernel_rodata_phys = . & 0xfffffff;
	.rodata (__kernel_rodata_virt) : AT (__kernel_rodata_phys)
	{
		__rodata_start = ABSOLUTE(.);
		__rodata_size = SIZEOF(.rodata);
		__rodata_load = LOADADDR(.rodata);
		*(.rodata .rodata.*)
		*(.codepatch)
		*(.codepatchend)
	} :rodata =0xcccccccc
	. = ALIGN(0x1000);
	__kernel_randomdata_phys = . & 0xfffffff;
	.openbsd.randomdata : AT (__kernel_randomdata_phys)
	{
		*(.openbsd.randomdata)
	} :rodata :openbsd_randomize =0xcccccccc
	. = ALIGN(0x1000);
	PROVIDE (erodata = .);
	_erodata = .;

	/* Move data to the next page, so we can add W bit on them */
	. = ALIGN(__ALIGN_SIZE);
	__kernel_data_virt = .;
	__kernel_data_phys = . & 0xfffffff;
	.data (__kernel_data_virt) : AT (__kernel_data_phys)
	{
		__data_start = ABSOLUTE(.);
		__data_size = SIZEOF(.data);
		__data_load = LOADADDR(.data);
		*(.data .data.*)
	} :data =0xcccccccc
	. = ALIGN(0x1000);
	PROVIDE (edata = .);
	_edata = .;

	/* BSS starts right after padded data */
	__kernel_bss_virt = .;
	__kernel_bss_phys = . & 0xfffffff;
	.bss (__kernel_bss_virt) : AT (__kernel_bss_phys)
	{
		__bss_start = ABSOLUTE(.);
		__bss_size = SIZEOF(.bss);
		__bss_load = LOADADDR(.bss);
		*(.bss .bss.*)
		*(COMMON)
		/* Align after .bss to ensure correct alignment even if the
		 * .bss section disappears because there are no input sections.
		 */
		. = ALIGN(0x1000);
	} :bss
	__kernel_bss_end = .;
	. = ALIGN(0x1000);
	_end = .;
	PROVIDE (end = .);
	__kernel_end_phys = . & 0xfffffff;

	/* XXX - hack alert, since we are not C++, nuke these */
	/DISCARD/ :
	{
		*(.note.GNU-stack)
		*(.eh_frame)
	}
}
@


1.6
log
@Split early startup code out of locore.S into locore0.S.  Adjust link
run so that this locore0.o is always at the start of the executable.
But randomize the link order of all other .o files in the kernel, so
that their exec/rodata/data/bss segments land all over the place.
Late during kernel boot, unmap the early startup code.

As a result, the internal layout of every newly build bsd kernel is
different from past kernels.  Internal relative offsets are not known
to an outside attacker.  The only known offsets are in the startup code,
which has been unmapped.

Ramdisk kernels cannot be compiled like this, because they are gzip'd.
When the internal pointer references change, the compression dictionary
bloats and results in poorer compression.

ok kettenis mlarkin visa, also thanks to tedu for getting me back to this
@
text
@d1 1
a1 1
/*	$OpenBSD: ld.script,v 1.5 2016/10/18 18:44:47 deraadt Exp $	*/
d58 1
a58 1
	} :text
d75 1
a75 1
	} :rodata
d81 1
a81 1
	} :rodata :openbsd_randomize
d96 1
a96 1
	} :data
@


1.5
log
@put .openbsd.randomdata into rodata, since i386 can handle it
@
text
@d1 1
a1 1
/*	$OpenBSD: ld.script,v 1.4 2016/09/03 13:13:07 deraadt Exp $	*/
d56 1
a56 1
		locore.o(.text)
@


1.4
log
@Make .openbsd.randomdata section RO.  Highlight is that the stack protector
cookie becomes readonly, spraying over it in KVA becomes more difficult.
amd64 version from guenther, i386 version by myself
ok guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ld.script,v 1.3 2016/02/20 19:59:01 mlarkin Exp $	*/
d81 1
a81 1
	} :data :openbsd_randomize
@


1.3
log
@
Fixes a boot issue on non-ACPI i386 machines that need X permissions on
the BIOS region in the ISA hole.

Also fix a separate unrelated issue relating to placing R/O (no X)
permissions on the kernel symbol area on bsd.rd.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ld.script,v 1.2 2015/08/15 19:01:39 mlarkin Exp $	*/
d30 1
a30 1
	openbsd_randomize 0x65a3dbe6; /* PT_OPENBSD_RANDOMIZE */
d76 7
a96 6
	. = ALIGN(0x1000);
	__kernel_randomdata_phys = . & 0xfffffff;
	.openbsd.randomdata : AT (__kernel_randomdata_phys)
	{
		*(.openbsd.randomdata)
	} :data :openbsd_randomize
@


1.2
log
@
Increase the size of the masks used in i386 ldscript to account for larger
sections that may be encountered when using larger than normal ramdisks.
No binary change.

Requested by and diff provided by
Nathanael Rensen <nathanael at list.polymorpheus.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ld.script,v 1.1 2015/08/12 06:19:25 mlarkin Exp $	*/
d116 1
a116 1
	. = ALIGN(0x200000);
@


1.1
log
@
Use a linker script when building i386 kernels to allow section padding on
PAGE_SIZE boundaries. This is required to enforce proper separation of
sections when adding page protections (coming shortly).

This was in snaps before release with no reported side effects.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ld.script,v 1.3 2015/04/28 22:29:24 kettenis Exp $	*/
d42 1
a42 1
__kernel_base_phys = __kernel_base_virt & 0xffffff;
d66 1
a66 1
	__kernel_rodata_phys = . & 0xffffff;
d82 1
a82 1
	__kernel_data_phys = . & 0xffffff;
d91 1
a91 1
	__kernel_randomdata_phys = . & 0xffffff;
d102 1
a102 1
	__kernel_bss_phys = . & 0xffffff;
d119 1
a119 1
	__kernel_end_phys = . & 0xffffff;
@

