head	1.82;
access;
symbols
	OPENBSD_6_2:1.82.0.2
	OPENBSD_6_2_BASE:1.82
	OPENBSD_6_1:1.81.0.8
	OPENBSD_6_1_BASE:1.81
	OPENBSD_6_0:1.81.0.4
	OPENBSD_6_0_BASE:1.81
	OPENBSD_5_9:1.81.0.2
	OPENBSD_5_9_BASE:1.81
	OPENBSD_5_8:1.80.0.6
	OPENBSD_5_8_BASE:1.80
	OPENBSD_5_7:1.80.0.2
	OPENBSD_5_7_BASE:1.80
	OPENBSD_5_6:1.79.0.4
	OPENBSD_5_6_BASE:1.79
	OPENBSD_5_5:1.77.0.4
	OPENBSD_5_5_BASE:1.77
	OPENBSD_5_4:1.76.0.2
	OPENBSD_5_4_BASE:1.76
	OPENBSD_5_3:1.73.0.2
	OPENBSD_5_3_BASE:1.73
	OPENBSD_5_2:1.68.0.4
	OPENBSD_5_2_BASE:1.68
	OPENBSD_5_1_BASE:1.68
	OPENBSD_5_1:1.68.0.2
	OPENBSD_5_0:1.63.0.2
	OPENBSD_5_0_BASE:1.63
	OPENBSD_4_9:1.58.0.2
	OPENBSD_4_9_BASE:1.58
	OPENBSD_4_8:1.53.0.2
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.50.0.2
	OPENBSD_4_7_BASE:1.50
	OPENBSD_4_6:1.48.0.4
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.44.0.2
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.40.0.2
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.39.0.4
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.4
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.23.0.6
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.4
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.23
	UBC:1.22.0.2
	UBC_BASE:1.22
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	SMP:1.14.0.6
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.4
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.82
date	2017.09.08.05.36.51;	author deraadt;	state Exp;
branches;
next	1.81;
commitid	uRv5pa9QDlZaYgwD;

1.81
date	2015.09.01.06.01.24;	author deraadt;	state Exp;
branches;
next	1.80;
commitid	sjMHb60Eu7lEqMDW;

1.80
date	2015.01.24.15.13.55;	author kettenis;	state Exp;
branches;
next	1.79;
commitid	Ol0pICcR5PormuCL;

1.79
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.78;
commitid	uKVPYMN2MLxdZxzH;

1.78
date	2014.04.19.11.53.42;	author kettenis;	state Exp;
branches;
next	1.77;

1.77
date	2013.11.06.10.40.36;	author mpi;	state Exp;
branches;
next	1.76;

1.76
date	2013.07.10.21.31.12;	author kettenis;	state Exp;
branches;
next	1.75;

1.75
date	2013.05.30.16.19.25;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2013.05.16.19.26.04;	author kettenis;	state Exp;
branches;
next	1.73;

1.73
date	2012.09.25.10.32.54;	author sthen;	state Exp;
branches;
next	1.72;

1.72
date	2012.09.22.11.02.36;	author sthen;	state Exp;
branches;
next	1.71;

1.71
date	2012.09.21.14.07.46;	author kettenis;	state Exp;
branches;
next	1.70;

1.70
date	2012.09.19.23.03.12;	author kettenis;	state Exp;
branches;
next	1.69;

1.69
date	2012.09.07.19.23.53;	author kettenis;	state Exp;
branches;
next	1.68;

1.68
date	2011.12.04.20.08.09;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2011.12.04.17.38.44;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2011.10.23.21.18.14;	author kettenis;	state Exp;
branches;
next	1.65;

1.65
date	2011.10.21.18.16.13;	author kettenis;	state Exp;
branches;
next	1.64;

1.64
date	2011.10.13.18.09.33;	author kettenis;	state Exp;
branches;
next	1.63;

1.63
date	2011.06.08.22.57.59;	author kettenis;	state Exp;
branches;
next	1.62;

1.62
date	2011.05.30.19.24.28;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2011.05.29.10.47.42;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2011.05.21.15.14.57;	author kettenis;	state Exp;
branches;
next	1.59;

1.59
date	2011.04.22.15.02.35;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2011.01.10.16.26.27;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2011.01.09.11.38.10;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2011.01.04.21.17.49;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2010.12.04.17.06.31;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2010.09.06.19.05.48;	author kettenis;	state Exp;
branches;
next	1.53;

1.53
date	2010.07.08.20.56.31;	author jordan;	state Exp;
branches;
next	1.52;

1.52
date	2010.07.01.06.29.32;	author jordan;	state Exp;
branches;
next	1.51;

1.51
date	2010.06.29.22.08.28;	author jordan;	state Exp;
branches;
next	1.50;

1.50
date	2009.09.28.15.58.30;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.48;

1.48
date	2009.04.29.18.28.37;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2009.04.13.21.22.38;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2009.04.11.17.13.33;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2009.03.10.15.03.17;	author oga;	state Exp;
branches;
next	1.44;

1.44
date	2009.01.27.15.33.59;	author oga;	state Exp;
branches;
next	1.43;

1.43
date	2008.12.28.18.26.53;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2008.12.07.14.33.26;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2008.12.03.15.46.07;	author oga;	state Exp;
branches;
next	1.40;

1.40
date	2008.06.26.05.42.11;	author ray;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.21.22.10.45;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2007.02.20.21.15.01;	author tom;	state Exp;
branches;
next	1.37;

1.37
date	2006.12.20.18.59.50;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2006.12.11.19.47.37;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2006.11.11.21.47.52;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2006.09.19.11.06.34;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2006.06.25.07.44.54;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2006.06.02.19.39.49;	author pascoe;	state Exp;
branches;
next	1.31;

1.31
date	2006.04.27.15.37.55;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.23.09.24.57;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.28.17.22.28;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2005.07.28.16.51.07;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2005.06.27.02.36.06;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.23.17.43.18;	author aaron;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.13.21.49.16;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.04.08.01.08;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.09.11.20.05.24;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.27.08.20.04;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.27.04.59.40;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2000.10.25.19.13.12;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.17.22.08.10;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.05.19.07.44;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	99.01.11.05.11.26;	author millert;	state Exp;
branches
	1.14.6.1;
next	1.13;

1.13
date	98.07.09.19.26.42;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.02.24.22.02.11;	author weingart;	state Exp;
branches;
next	1.11;

1.11
date	98.01.20.18.40.23;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.06.18.19.07.01;	author dm;	state Exp;
branches;
next	1.9;

1.9
date	96.11.28.23.37.42;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.04.21.22.17.32;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.18.19.22.22;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.03.22.18.29.50;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.03.20.00.43.58;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.19.21.09.58;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.20.04.35.38;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.28.00;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.52;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.52;	author deraadt;	state Exp;
branches;
next	;

1.14.6.1
date	2000.03.24.09.07.46;	author niklas;	state Exp;
branches;
next	1.14.6.2;

1.14.6.2
date	2001.04.18.16.08.28;	author niklas;	state Exp;
branches;
next	1.14.6.3;

1.14.6.3
date	2001.07.14.10.02.45;	author ho;	state Exp;
branches;
next	1.14.6.4;

1.14.6.4
date	2001.07.16.21.41.55;	author niklas;	state Exp;
branches;
next	1.14.6.5;

1.14.6.5
date	2001.10.31.03.01.13;	author nate;	state Exp;
branches;
next	1.14.6.6;

1.14.6.6
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.14.6.7;

1.14.6.7
date	2002.03.28.10.31.05;	author niklas;	state Exp;
branches;
next	1.14.6.8;

1.14.6.8
date	2003.05.13.19.42.08;	author ho;	state Exp;
branches;
next	1.14.6.9;

1.14.6.9
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.14.6.10;

1.14.6.10
date	2004.03.23.08.02.56;	author niklas;	state Exp;
branches;
next	1.14.6.11;

1.14.6.11
date	2004.06.11.15.00.12;	author grange;	state Exp;
branches;
next	;

1.22.2.1
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2003.05.19.21.45.12;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.82
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: pci_machdep.c,v 1.81 2015/09/01 06:01:24 deraadt Exp $	*/
/*	$NetBSD: pci_machdep.c,v 1.28 1997/06/06 23:29:17 thorpej Exp $	*/

/*-
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1996 Christopher G. Demetriou.  All rights reserved.
 * Copyright (c) 1994 Charles Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Machine-specific functions for PCI autoconfiguration.
 *
 * On PCs, there are two methods of generating PCI configuration cycles.
 * We try to detect the appropriate mechanism for this machine and set
 * up a few function pointers to access the correct method directly.
 *
 * The configuration method can be hard-coded in the config file by
 * using `options PCI_CONF_MODE=N', where `N' is the configuration mode
 * as defined section 3.6.4.1, `Generating Configuration Cycles'.
 */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/extent.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/pio.h>
#include <machine/i8259.h>
#include <machine/biosvar.h>

#include "bios.h"
#if NBIOS > 0
extern bios_pciinfo_t *bios_pciinfo;
#endif

#include <dev/isa/isavar.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/ppbreg.h>

#include "ioapic.h"

#include <machine/i82093var.h>
#include <machine/i82489reg.h>
#include <machine/i82489var.h>
#if NIOAPIC > 0
#include <machine/mpbiosvar.h>
#endif

#include "pcibios.h"
#if NPCIBIOS > 0
#include <i386/pci/pcibiosvar.h>
#endif

int pci_mode = -1;

/*
 * Memory Mapped Configuration space access.
 *
 * Since mapping the whole configuration space will cost us up to
 * 256MB of kernel virtual memory, we use seperate mappings per bus.
 * The mappings are created on-demand, such that we only use kernel
 * virtual memory for busses that are actually present.
 */
bus_addr_t pci_mcfg_addr;
int pci_mcfg_min_bus, pci_mcfg_max_bus;
bus_space_tag_t pci_mcfgt = I386_BUS_SPACE_MEM;
bus_space_handle_t pci_mcfgh[256];
void pci_mcfg_map_bus(int);

struct mutex pci_conf_lock = MUTEX_INITIALIZER(IPL_HIGH);

#define	PCI_CONF_LOCK()							\
do {									\
	mtx_enter(&pci_conf_lock);					\
} while (0)

#define	PCI_CONF_UNLOCK()						\
do {									\
	mtx_leave(&pci_conf_lock);					\
} while (0)

#define	PCI_MODE1_ENABLE	0x80000000UL
#define	PCI_MODE1_ADDRESS_REG	0x0cf8
#define	PCI_MODE1_DATA_REG	0x0cfc

#define	PCI_MODE2_ENABLE_REG	0x0cf8
#define	PCI_MODE2_FORWARD_REG	0x0cfa

#define _m1tag(b, d, f) \
	(PCI_MODE1_ENABLE | ((b) << 16) | ((d) << 11) | ((f) << 8))
#define _qe(bus, dev, fcn, vend, prod) \
	{_m1tag(bus, dev, fcn), PCI_ID_CODE(vend, prod)}
struct {
	u_int32_t tag;
	pcireg_t id;
} pcim1_quirk_tbl[] = {
	_qe(0, 0, 0, PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_TRIFLEX1),
	/* XXX Triflex2 not tested */
	_qe(0, 0, 0, PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_TRIFLEX2),
	_qe(0, 0, 0, PCI_VENDOR_COMPAQ, PCI_PRODUCT_COMPAQ_TRIFLEX4),
	/* Triton needed for Connectix Virtual PC */
	_qe(0, 0, 0, PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82437FX),
	/* Connectix Virtual PC 5 has a 440BX */
	_qe(0, 0, 0, PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82443BX_NOAGP),
	{0, 0xffffffff} /* patchable */
};
#undef _m1tag
#undef _qe

/*
 * PCI doesn't have any special needs; just use the generic versions
 * of these functions.
 */
struct bus_dma_tag pci_bus_dma_tag = {
	NULL,			/* _cookie */
	_bus_dmamap_create, 
	_bus_dmamap_destroy,
	_bus_dmamap_load,
	_bus_dmamap_load_mbuf,
	_bus_dmamap_load_uio,
	_bus_dmamap_load_raw,
	_bus_dmamap_unload,
	_bus_dmamap_sync,
	_bus_dmamem_alloc,
	_bus_dmamem_alloc_range,
	_bus_dmamem_free,
	_bus_dmamem_map,
	_bus_dmamem_unmap,
	_bus_dmamem_mmap,
};

void
pci_attach_hook(struct device *parent, struct device *self,
    struct pcibus_attach_args *pba)
{
	pci_chipset_tag_t pc = pba->pba_pc;
	pcitag_t tag;
	pcireg_t id, class;

#if NBIOS > 0
	if (pba->pba_bus == 0)
		printf(": configuration mode %d (%s)",
			pci_mode, (bios_pciinfo?"bios":"no bios"));
#else
	if (pba->pba_bus == 0)
		printf(": configuration mode %d", pci_mode);
#endif

	if (pba->pba_bus != 0)
		return;

	/*
	 * Machines that use the non-standard method of generating PCI
	 * configuration cycles are way too old to support MSI.
	 */
	if (pci_mode == 2)
		return;

	/*
	 * In order to decide whether the system supports MSI we look
	 * at the host bridge, which should be device 0 function 0 on
	 * bus 0.  It is better to not enable MSI on systems that
	 * support it than the other way around, so be conservative
	 * here.  So we don't enable MSI if we don't find a host
	 * bridge there.  We also deliberately don't enable MSI on
	 * chipsets from low-end manifacturers like VIA and SiS.
	 */
	tag = pci_make_tag(pc, 0, 0, 0);
	id = pci_conf_read(pc, tag, PCI_ID_REG);
	class = pci_conf_read(pc, tag, PCI_CLASS_REG);

	if (PCI_CLASS(class) != PCI_CLASS_BRIDGE ||
	    PCI_SUBCLASS(class) != PCI_SUBCLASS_BRIDGE_HOST)
		return;

	switch (PCI_VENDOR(id)) {
	case PCI_VENDOR_INTEL:
		/*
		 * For Intel platforms, MSI support was introduced
		 * with the new Pentium 4 processor interrupt delivery
		 * mechanism, so we blacklist all PCI chipsets that
		 * support Pentium III and earlier CPUs.
		 */
		switch (PCI_PRODUCT(id)) {
		case PCI_PRODUCT_INTEL_PCMC: /* 82434LX/NX */
		case PCI_PRODUCT_INTEL_82437FX:
		case PCI_PRODUCT_INTEL_82437MX:
		case PCI_PRODUCT_INTEL_82437VX:
		case PCI_PRODUCT_INTEL_82439HX:
		case PCI_PRODUCT_INTEL_82439TX:
		case PCI_PRODUCT_INTEL_82440BX:
		case PCI_PRODUCT_INTEL_82440BX_AGP:
		case PCI_PRODUCT_INTEL_82440MX_HB:
		case PCI_PRODUCT_INTEL_82441FX:
		case PCI_PRODUCT_INTEL_82443BX:
		case PCI_PRODUCT_INTEL_82443BX_AGP:
		case PCI_PRODUCT_INTEL_82443BX_NOAGP:
		case PCI_PRODUCT_INTEL_82443GX:
		case PCI_PRODUCT_INTEL_82443LX:
		case PCI_PRODUCT_INTEL_82443LX_AGP:
		case PCI_PRODUCT_INTEL_82810_HB:
		case PCI_PRODUCT_INTEL_82810E_HB:
		case PCI_PRODUCT_INTEL_82815_HB:
		case PCI_PRODUCT_INTEL_82820_HB:
		case PCI_PRODUCT_INTEL_82830M_HB:
		case PCI_PRODUCT_INTEL_82840_HB:
			break;
		default:
			pba->pba_flags |= PCI_FLAGS_MSI_ENABLED;
			break;
		}
		break;
	case PCI_VENDOR_NVIDIA:
		/*
		 * Since NVIDIA chipsets are completely undocumented,
		 * we have to make a guess here.  We assume that all
		 * chipsets that support PCIe include support for MSI,
		 * since support for MSI is mandated by the PCIe
		 * standard.
		 */
		switch (PCI_PRODUCT(id)) {
		case PCI_PRODUCT_NVIDIA_NFORCE_PCHB:
		case PCI_PRODUCT_NVIDIA_NFORCE2_PCHB:
			break;
		default:
			pba->pba_flags |= PCI_FLAGS_MSI_ENABLED;
			break;
		}
		break;
	case PCI_VENDOR_AMD:
		/*
		 * The AMD-750 and AMD-760 chipsets don't support MSI.
		 */
		switch (PCI_PRODUCT(id)) {
		case PCI_PRODUCT_AMD_SC751_SC:
		case PCI_PRODUCT_AMD_761_PCHB:
		case PCI_PRODUCT_AMD_762_PCHB:
			break;
		default:
			pba->pba_flags |= PCI_FLAGS_MSI_ENABLED;
			break;
		}
		break;
	}

	/*
	 * Don't enable MSI on a HyperTransport bus.  In order to
	 * determine that bus 0 is a HyperTransport bus, we look at
	 * device 24 function 0, which is the HyperTransport
	 * host/primary interface integrated on most 64-bit AMD CPUs.
	 * If that device has a HyperTransport capability, bus 0 must
	 * be a HyperTransport bus and we disable MSI.
	 */
	tag = pci_make_tag(pc, 0, 24, 0);
	if (pci_get_capability(pc, tag, PCI_CAP_HT, NULL, NULL))
		pba->pba_flags &= ~PCI_FLAGS_MSI_ENABLED;
}

int
pci_bus_maxdevs(pci_chipset_tag_t pc, int busno)
{

	/*
	 * Bus number is irrelevant.  If Configuration Mechanism 2 is in
	 * use, can only have devices 0-15 on any bus.  If Configuration
	 * Mechanism 1 is in use, can have devices 0-31 (i.e. the `normal'
	 * range).
	 */
	if (pci_mode == 2)
		return (16);
	else
		return (32);
}

pcitag_t
pci_make_tag(pci_chipset_tag_t pc, int bus, int device, int function)
{
	pcitag_t tag;

	switch (pci_mode) {
	case 1:
		if (bus >= 256 || device >= 32 || function >= 8)
			panic("pci_make_tag: bad request");

		tag.mode1 = PCI_MODE1_ENABLE |
		    	(bus << 16) | (device << 11) | (function << 8);
		break;
	case 2:
		if (bus >= 256 || device >= 16 || function >= 8)
			panic("pci_make_tag: bad request");

		tag.mode2.port = 0xc000 | (device << 8);
		tag.mode2.enable = 0xf0 | (function << 1);
		tag.mode2.forward = bus;
		break;
	default:
		panic("pci_make_tag: mode not configured");
	}

	return tag;
}

void
pci_decompose_tag(pci_chipset_tag_t pc, pcitag_t tag, int *bp, int *dp, int *fp)
{
	switch (pci_mode) {
	case 1:
		if (bp != NULL)
			*bp = (tag.mode1 >> 16) & 0xff;
		if (dp != NULL)
			*dp = (tag.mode1 >> 11) & 0x1f;
		if (fp != NULL)
			*fp = (tag.mode1 >> 8) & 0x7;
		break;
	case 2:
		if (bp != NULL)
			*bp = tag.mode2.forward & 0xff;
		if (dp != NULL)
			*dp = (tag.mode2.port >> 8) & 0xf;
		if (fp != NULL)
			*fp = (tag.mode2.enable >> 1) & 0x7;
		break;
	default:
		panic("pci_decompose_tag: mode not configured");
	}
}

int
pci_conf_size(pci_chipset_tag_t pc, pcitag_t tag)
{
	int bus;

	if (pci_mcfg_addr) {
		pci_decompose_tag(pc, tag, &bus, NULL, NULL);
		if (bus >= pci_mcfg_min_bus && bus <= pci_mcfg_max_bus)
			return PCIE_CONFIG_SPACE_SIZE;
	}

	return PCI_CONFIG_SPACE_SIZE;
}

void
pci_mcfg_map_bus(int bus)
{
	if (pci_mcfgh[bus])
		return;

	if (bus_space_map(pci_mcfgt, pci_mcfg_addr + (bus << 20), 1 << 20,
	    0, &pci_mcfgh[bus]))
		panic("pci_conf_read: cannot map mcfg space");
}

pcireg_t
pci_conf_read(pci_chipset_tag_t pc, pcitag_t tag, int reg)
{
	pcireg_t data;
	int bus;

	KASSERT((reg & 0x3) == 0);

	if (pci_mcfg_addr && reg >= PCI_CONFIG_SPACE_SIZE) {
		pci_decompose_tag(pc, tag, &bus, NULL, NULL);
		if (bus >= pci_mcfg_min_bus && bus <= pci_mcfg_max_bus) {
			pci_mcfg_map_bus(bus);
			data = bus_space_read_4(pci_mcfgt, pci_mcfgh[bus],
			    (tag.mode1 & 0x000ff00) << 4 | reg);
			return data;
		}
	}

	PCI_CONF_LOCK();
	switch (pci_mode) {
	case 1:
		outl(PCI_MODE1_ADDRESS_REG, tag.mode1 | reg);
		data = inl(PCI_MODE1_DATA_REG);
		outl(PCI_MODE1_ADDRESS_REG, 0);
		break;
	case 2:
		outb(PCI_MODE2_ENABLE_REG, tag.mode2.enable);
		outb(PCI_MODE2_FORWARD_REG, tag.mode2.forward);
		data = inl(tag.mode2.port | reg);
		outb(PCI_MODE2_ENABLE_REG, 0);
		break;
	default:
		panic("pci_conf_read: mode not configured");
	}
	PCI_CONF_UNLOCK();

	return data;
}

void
pci_conf_write(pci_chipset_tag_t pc, pcitag_t tag, int reg, pcireg_t data)
{
	int bus;

	KASSERT((reg & 0x3) == 0);

	if (pci_mcfg_addr && reg >= PCI_CONFIG_SPACE_SIZE) {
		pci_decompose_tag(pc, tag, &bus, NULL, NULL);
		if (bus >= pci_mcfg_min_bus && bus <= pci_mcfg_max_bus) {
			pci_mcfg_map_bus(bus);
			bus_space_write_4(pci_mcfgt, pci_mcfgh[bus],
			    (tag.mode1 & 0x000ff00) << 4 | reg, data);
			return;
		}
	}

	PCI_CONF_LOCK();
	switch (pci_mode) {
	case 1:
		outl(PCI_MODE1_ADDRESS_REG, tag.mode1 | reg);
		outl(PCI_MODE1_DATA_REG, data);
		outl(PCI_MODE1_ADDRESS_REG, 0);
		break;
	case 2:
		outb(PCI_MODE2_ENABLE_REG, tag.mode2.enable);
		outb(PCI_MODE2_FORWARD_REG, tag.mode2.forward);
		outl(tag.mode2.port | reg, data);
		outb(PCI_MODE2_ENABLE_REG, 0);
		break;
	default:
		panic("pci_conf_write: mode not configured");
	}
	PCI_CONF_UNLOCK();
}

int
pci_mode_detect(void)
{

#ifdef PCI_CONF_MODE
#if (PCI_CONF_MODE == 1) || (PCI_CONF_MODE == 2)
	return (pci_mode = PCI_CONF_MODE);
#else
#error Invalid PCI configuration mode.
#endif
#else
	u_int32_t sav, val;
	int i;
	pcireg_t idreg;

	if (pci_mode != -1)
		return (pci_mode);

#if NBIOS > 0
	/*
	 * If we have PCI info passed from the BIOS, use the mode given there
	 * for all of this code.  If not, pass on through to the previous tests
	 * to try and divine the correct mode.
	 */
	if (bios_pciinfo != NULL) {
		if (bios_pciinfo->pci_chars & 0x2)
			return (pci_mode = 2);

		if (bios_pciinfo->pci_chars & 0x1)
			return (pci_mode = 1);

		/* We should never get here, but if we do, fall through... */
	}
#endif

	/*
	 * We try to divine which configuration mode the host bridge wants.
	 *
	 * This should really be done using the PCI BIOS.  If we get here, the
	 * PCI BIOS does not exist, or the boot blocks did not provide the
	 * information.
	 */

	sav = inl(PCI_MODE1_ADDRESS_REG);

	pci_mode = 1; /* assume this for now */
	/*
	 * catch some known buggy implementations of mode 1
	 */
	for (i = 0; i < sizeof(pcim1_quirk_tbl) / sizeof(pcim1_quirk_tbl[0]);
	     i++) {
		pcitag_t t;

		if (!pcim1_quirk_tbl[i].tag)
			break;
		t.mode1 = pcim1_quirk_tbl[i].tag;
		idreg = pci_conf_read(0, t, PCI_ID_REG); /* needs "pci_mode" */
		if (idreg == pcim1_quirk_tbl[i].id) {
#ifdef DEBUG
			printf("known mode 1 PCI chipset (%08x)\n",
			       idreg);
#endif
			return (pci_mode);
		}
	}

	/*
	 * Strong check for standard compliant mode 1:
	 * 1. bit 31 ("enable") can be set
	 * 2. byte/word access does not affect register
 	 */
	outl(PCI_MODE1_ADDRESS_REG, PCI_MODE1_ENABLE);
	outb(PCI_MODE1_ADDRESS_REG + 3, 0);
	outw(PCI_MODE1_ADDRESS_REG + 2, 0);
	val = inl(PCI_MODE1_ADDRESS_REG);
	if ((val & 0x80fffffc) != PCI_MODE1_ENABLE) {
#ifdef DEBUG
		printf("pci_mode_detect: mode 1 enable failed (%x)\n",
		       val);
#endif
		goto not1;
	}
	outl(PCI_MODE1_ADDRESS_REG, 0);
	val = inl(PCI_MODE1_ADDRESS_REG);
	if ((val & 0x80fffffc) != 0)
		goto not1;
	return (pci_mode);
not1:
	outl(PCI_MODE1_ADDRESS_REG, sav);
 
	/*
	 * This mode 2 check is quite weak (and known to give false
	 * positives on some Compaq machines).
	 * However, this doesn't matter, because this is the
	 * last test, and simply no PCI devices will be found if
	 * this happens.
	 */
	outb(PCI_MODE2_ENABLE_REG, 0);
	outb(PCI_MODE2_FORWARD_REG, 0);
	if (inb(PCI_MODE2_ENABLE_REG) != 0 ||
	    inb(PCI_MODE2_FORWARD_REG) != 0)
		goto not2;
	return (pci_mode = 2);
not2:
	return (pci_mode = 0);
#endif
}

int
pci_intr_map_msi(struct pci_attach_args *pa, pci_intr_handle_t *ihp)
{
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t tag = pa->pa_tag;

	if ((pa->pa_flags & PCI_FLAGS_MSI_ENABLED) == 0 || mp_busses == NULL ||
	    pci_get_capability(pc, tag, PCI_CAP_MSI, NULL, NULL) == 0)
		return 1;

	ihp->tag = tag;
	ihp->line = APIC_INT_VIA_MSG;
	ihp->pin = 0;
	return 0;
}

int
pci_intr_map(struct pci_attach_args *pa, pci_intr_handle_t *ihp)
{
	int pin = pa->pa_rawintrpin;
	int line = pa->pa_intrline;
#if NIOAPIC > 0
	struct mp_intr_map *mip;
	int bus, dev, func;
#endif

	if (pin == 0) {
		/* No IRQ used. */
		goto bad;
	}

	if (pin > PCI_INTERRUPT_PIN_MAX) {
		printf("pci_intr_map: bad interrupt pin %d\n", pin);
		goto bad;
	}

	ihp->tag = pa->pa_tag;
	ihp->line = line;
	ihp->pin = pin;

#if NIOAPIC > 0
	pci_decompose_tag (pa->pa_pc, pa->pa_tag, &bus, &dev, &func);

	if (!(ihp->line & PCI_INT_VIA_ISA) && mp_busses != NULL) {
		int mpspec_pin = (dev << 2) | (pin - 1);

		if (bus < mp_nbusses) {
			for (mip = mp_busses[bus].mb_intrs;
			     mip != NULL; mip = mip->next) {
				if (&mp_busses[bus] == mp_isa_bus ||
				    &mp_busses[bus] == mp_eisa_bus)
					continue;
				if (mip->bus_pin == mpspec_pin) {
					ihp->line = mip->ioapic_ih | line;
					return 0;
				}
			}
		}

		if (pa->pa_bridgetag) {
			int swizpin = PPB_INTERRUPT_SWIZZLE(pin, dev);
			if (pa->pa_bridgeih[swizpin - 1].line != -1) {
				ihp->line = pa->pa_bridgeih[swizpin - 1].line;
				ihp->line |= line;
				return 0;
			}
		}
		/*
		 * No explicit PCI mapping found. This is not fatal,
		 * we'll try the ISA (or possibly EISA) mappings next.
		 */
	}
#endif

#if NPCIBIOS > 0
	pci_intr_header_fixup(pa->pa_pc, pa->pa_tag, ihp);
	line = ihp->line & APIC_INT_LINE_MASK;
#endif

	/*
	 * Section 6.2.4, `Miscellaneous Functions', says that 255 means
	 * `unknown' or `no connection' on a PC.  We assume that a device with
	 * `no connection' either doesn't have an interrupt (in which case the
	 * pin number should be 0, and would have been noticed above), or
	 * wasn't configured by the BIOS (in which case we punt, since there's
	 * no real way we can know how the interrupt lines are mapped in the
	 * hardware).
	 *
	 * XXX
	 * Since IRQ 0 is only used by the clock, and we can't actually be sure
	 * that the BIOS did its job, we also recognize that as meaning that
	 * the BIOS has not configured the device.
	 */
	if (line == 0 || line == I386_PCI_INTERRUPT_LINE_NO_CONNECTION)
		goto bad;

	if (line >= ICU_LEN) {
		printf("pci_intr_map: bad interrupt line %d\n", line);
		goto bad;
	}
	if (line == 2) {
		printf("pci_intr_map: changed line 2 to line 9\n");
		line = 9;
	}

#if NIOAPIC > 0
	if (!(ihp->line & PCI_INT_VIA_ISA) && mp_busses != NULL) {
		if (mip == NULL && mp_isa_bus) {
			for (mip = mp_isa_bus->mb_intrs; mip != NULL;
			    mip = mip->next) {
				if (mip->bus_pin == line) {
					ihp->line = mip->ioapic_ih | line;
					return 0;
				}
			}
		}
		if (mip == NULL && mp_eisa_bus) {
			for (mip = mp_eisa_bus->mb_intrs;  mip != NULL;
			    mip = mip->next) {
				if (mip->bus_pin == line) {
					ihp->line = mip->ioapic_ih | line;
					return 0;
				}
			}
		}
		if (mip == NULL) {
			printf("pci_intr_map: "
			    "bus %d dev %d func %d pin %d; line %d\n",
			    bus, dev, func, pin, line);
			printf("pci_intr_map: no MP mapping found\n");
		}
	}
#endif

	return 0;

bad:
	ihp->line = -1;
	return 1;
}

const char *
pci_intr_string(pci_chipset_tag_t pc, pci_intr_handle_t ih)
{
	static char irqstr[64];
	int line = ih.line & APIC_INT_LINE_MASK;

	if (ih.line & APIC_INT_VIA_MSG)
		return ("msi");

#if NIOAPIC > 0
	if (ih.line & APIC_INT_VIA_APIC) {
		snprintf(irqstr, sizeof irqstr, "apic %d int %d",
		     APIC_IRQ_APIC(ih.line), APIC_IRQ_PIN(ih.line));
		return (irqstr);
	}
#endif

	if (line == 0 || line >= ICU_LEN || line == 2)
		panic("pci_intr_string: bogus handle 0x%x", line);

	snprintf(irqstr, sizeof irqstr, "irq %d", line);
	return (irqstr);
}

#include "acpiprt.h"
#if NACPIPRT > 0
void	acpiprt_route_interrupt(int bus, int dev, int pin);
#endif

extern struct intrhand *apic_intrhand[256];
extern int apic_maxlevel[256];

void *
pci_intr_establish(pci_chipset_tag_t pc, pci_intr_handle_t ih, int level,
    int (*func)(void *), void *arg, const char *what)
{
	void *ret;
	int bus, dev;
	int l = ih.line & APIC_INT_LINE_MASK;
	pcitag_t tag = ih.tag;
	int irq = ih.line;

	if (ih.line & APIC_INT_VIA_MSG) {
		struct intrhand *ih;
		pcireg_t reg, addr;
		int off, vec;
		int flags;

		flags = level & IPL_MPSAFE;
		level &= ~IPL_MPSAFE;

		KASSERT(level <= IPL_TTY || flags & IPL_MPSAFE);

		if (pci_get_capability(pc, tag, PCI_CAP_MSI, &off, &reg) == 0)
			panic("%s: no msi capability", __func__);

		vec = idt_vec_alloc(level, level + 15);
		if (vec == 0)
			return (NULL);

		ih = malloc(sizeof(*ih), M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
		if (ih == NULL)
			panic("%s: can't malloc handler info", __func__);

		ih->ih_fun = func;
		ih->ih_arg = arg;
		ih->ih_next = NULL;
		ih->ih_level = level;
		ih->ih_flags = flags;
		ih->ih_irq = irq;
		ih->ih_pin = tag.mode1;
		ih->ih_vec = vec;
		evcount_attach(&ih->ih_count, what, &ih->ih_vec);

		apic_maxlevel[vec] = level;
		apic_intrhand[vec] = ih;
		idt_vec_set(vec, apichandler[vec & 0xf]);

		addr = 0xfee00000UL | (cpu_info_primary.ci_apicid << 12);

		if (reg & PCI_MSI_MC_C64) {
			pci_conf_write(pc, tag, off + PCI_MSI_MA, addr);
			pci_conf_write(pc, tag, off + PCI_MSI_MAU32, 0);
			pci_conf_write(pc, tag, off + PCI_MSI_MD64, vec);
		} else {
			pci_conf_write(pc, tag, off + PCI_MSI_MA, addr);
			pci_conf_write(pc, tag, off + PCI_MSI_MD32, vec);
		}
		pci_conf_write(pc, tag, off, reg | PCI_MSI_MC_MSIE);
		return (ih);
	}

	pci_decompose_tag(pc, ih.tag, &bus, &dev, NULL);
#if NACPIPRT > 0
	acpiprt_route_interrupt(bus, dev, ih.pin);
#endif

#if NIOAPIC > 0
	if (l != -1 && ih.line & APIC_INT_VIA_APIC)
		return (apic_intr_establish(ih.line, IST_LEVEL, level, func, 
		    arg, what));
#endif
	if (l == 0 || l >= ICU_LEN || l == 2)
		panic("pci_intr_establish: bogus handle 0x%x", l);

	ret = isa_intr_establish(NULL, l, IST_LEVEL, level, func, arg, what);
#if NPCIBIOS > 0
	if (ret)
		pci_intr_route_link(pc, &ih);
#endif
	return (ret);
}

void
pci_intr_disestablish(pci_chipset_tag_t pc, void *cookie)
{
	struct intrhand *ih = cookie;

	if (ih->ih_irq & APIC_INT_VIA_MSG) {
		pcitag_t tag = { .mode1 = ih->ih_pin };
		pcireg_t reg;
		int off;
		
		if (pci_get_capability(pc, tag, PCI_CAP_MSI, &off, &reg))
			pci_conf_write(pc, tag, off, reg &= ~PCI_MSI_MC_MSIE);

		apic_maxlevel[ih->ih_vec] = 0;
		apic_intrhand[ih->ih_vec] = NULL;
		idt_vec_free(ih->ih_vec);

		evcount_detach(&ih->ih_count);
		free(ih, M_DEVBUF, sizeof *ih);
		return;
	}

	/* XXX oh, unroute the pci int link? */
	isa_intr_disestablish(NULL, cookie);
}

struct extent *pciio_ex;
struct extent *pcimem_ex;
struct extent *pcibus_ex;

void
pci_init_extents(void)
{
	bios_memmap_t *bmp;
	u_int64_t size;

	if (pciio_ex == NULL) {
		/*
		 * We only have 64K of addressable I/O space.
		 * However, since BARs may contain garbage, we cover
		 * the full 32-bit address space defined by PCI of
		 * which we only make the first 64K available.
		 */
		pciio_ex = extent_create("pciio", 0, 0xffffffff, M_DEVBUF,
		    NULL, 0, EX_NOWAIT | EX_FILLED);
		if (pciio_ex == NULL)
			return;
		extent_free(pciio_ex, 0, 0x10000, M_NOWAIT);
	}

	if (pcimem_ex == NULL) {
		pcimem_ex = extent_create("pcimem", 0, 0xffffffff, M_DEVBUF,
		    NULL, 0, EX_NOWAIT);
		if (pcimem_ex == NULL)
			return;

		for (bmp = bios_memmap; bmp->type != BIOS_MAP_END; bmp++) {
			/*
			 * Ignore address space beyond 4G.
			 */
			if (bmp->addr >= 0x100000000ULL)
				continue;
			size = bmp->size;
			if (bmp->addr + size >= 0x100000000ULL)
				size = 0x100000000ULL - bmp->addr;

			/* Ignore zero-sized regions. */
			if (size == 0)
				continue;

			if (extent_alloc_region(pcimem_ex, bmp->addr, size,
			    EX_NOWAIT))
				printf("memory map conflict 0x%llx/0x%llx\n",
				    bmp->addr, bmp->size);
		}

		/* Take out the video buffer area and BIOS areas. */
		extent_alloc_region(pcimem_ex, IOM_BEGIN, IOM_SIZE,
		    EX_CONFLICTOK | EX_NOWAIT);
	}

	if (pcibus_ex == NULL) {
		pcibus_ex = extent_create("pcibus", 0, 0xff, M_DEVBUF,
		    NULL, 0, EX_NOWAIT);
	}
}

#include "acpi.h"
#if NACPI > 0
void acpi_pci_match(struct device *, struct pci_attach_args *);
pcireg_t acpi_pci_min_powerstate(pci_chipset_tag_t, pcitag_t);
void acpi_pci_set_powerstate(pci_chipset_tag_t, pcitag_t, int, int);
#endif

void
pci_dev_postattach(struct device *dev, struct pci_attach_args *pa)
{
#if NACPI > 0
	acpi_pci_match(dev, pa);
#endif
}

pcireg_t
pci_min_powerstate(pci_chipset_tag_t pc, pcitag_t tag)
{
#if NACPI > 0
	return acpi_pci_min_powerstate(pc, tag);
#else
	return pci_get_powerstate(pc, tag);
#endif
}

void
pci_set_powerstate_md(pci_chipset_tag_t pc, pcitag_t tag, int state, int pre)
{
#if NACPI > 0
	acpi_pci_set_powerstate(pc, tag, state, pre);
#endif
}
@


1.81
log
@fairly simple sizes for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.80 2015/01/24 15:13:55 kettenis Exp $	*/
a75 1
#include <sys/types.h>
@


1.80
log
@Add bus_dmamem_alloc_range(9) to allow drivers to allocate DMA'able memory
within a range that is more (or less) restrictive than the default range.

ok deraadt@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.79 2014/07/12 18:44:42 tedu Exp $	*/
d871 1
a871 1
		free(ih, M_DEVBUF, 0);
@


1.79
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.78 2014/04/19 11:53:42 kettenis Exp $	*/
d188 1
@


1.78
log
@Don't panic if we're trying to disestablish an MSI but the hardware is gone.

tested by & ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.77 2013/11/06 10:40:36 mpi Exp $	*/
d870 1
a870 1
		free(ih, M_DEVBUF);
@


1.77
log
@Add support for Power Resources for Dx states and the necessary hook
for PCI devices.  This hook should be called twice, before and after
changing the power state of a PCI device.

Before setting the device to the new state, the ACPI layer will notify
every power resources linked to the device for that state and make sure
they are turned "_ON".  After changing the state of the device, it will
decrement the reference of every power resources linked to that device
for the old state and turn them "_OFF" if they are no longer referenced.

This fixes the no-USB after resume problem seen on various ThinkPad,
problem initialy diagnosed with Alexander Polakov.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.76 2013/07/10 21:31:12 kettenis Exp $	*/
d862 2
a863 4
		if (pci_get_capability(pc, tag, PCI_CAP_MSI, &off, &reg) == 0)
			panic("%s: no msi capability", __func__);

		pci_conf_write(pc, tag, off, reg &= ~PCI_MSI_MC_MSIE);
@


1.76
log
@To prevent lock ordering problems with the kernel lock, we need to make sure
we block all interrupts that can grab the kernel lock.  The simplest way to
achieve this is to make sure mutexes always raise the ipl to the highest
level that has interrupts that grab the kernel lock.  This will allow us
to have "mpsafe" interrupt handlers at lower priority levels.

No change for non-MULTIPROCESSOR kernels.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.75 2013/05/30 16:19:25 deraadt Exp $	*/
d944 2
a955 4
#if NACPI > 0
pcireg_t acpi_pci_min_powerstate(pci_chipset_tag_t, pcitag_t);
#endif

d963 8
@


1.75
log
@If ACPI is not compiled in, pci_min_powerstate() has no facts to support
is should return D3.  It should return the current power state.
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.74 2013/05/16 19:26:04 kettenis Exp $	*/
d789 2
@


1.74
log
@Implement a mechanism to establish interrupt handlers that don't grab the
kernel lock upon entry through a new IPL_MPSAFE flag/level.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.73 2012/09/25 10:32:54 sthen Exp $	*/
d962 1
a962 1
	return PCI_PMCSR_STATE_D3;
@


1.73
log
@Make sure we send MSIs to the primary CPU like we do on amd64.

This is a fixed version reinstating the previous commit, fix from
Christian Ehrhardt, same fix from brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.72 2012/09/22 11:02:36 sthen Exp $	*/
d785 4
d805 1
@


1.72
log
@revert previous, breaks the tree
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.71 2012/09/21 14:07:46 kettenis Exp $	*/
d783 1
a783 1
		pcireg_t reg;
d810 2
d813 1
a813 1
			pci_conf_write(pc, tag, off + PCI_MSI_MA, 0xfee00000);
d817 1
a817 1
			pci_conf_write(pc, tag, off + PCI_MSI_MA, 0xfee00000);
@


1.71
log
@Make sure we send MSIs to the primary CPU like we do on amd64.

Based on a diff from Christian Ehrhardt.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.70 2012/09/19 23:03:12 kettenis Exp $	*/
d783 1
a783 1
		pcireg_t reg, addr;
a809 2
		addr = 0xfee00000UL | (cpu_info_primary.apicid << 12);

d811 1
a811 1
			pci_conf_write(pc, tag, off + PCI_MSI_MA, addr);
d815 1
a815 1
			pci_conf_write(pc, tag, off + PCI_MSI_MA, addr);
@


1.70
log
@Set up PCI bus number resource accounting for the main PCI bus hierarchy.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.69 2012/09/07 19:23:53 kettenis Exp $	*/
d783 1
a783 1
		pcireg_t reg;
d810 2
d813 1
a813 1
			pci_conf_write(pc, tag, off + PCI_MSI_MA, 0xfee00000);
d817 1
a817 1
			pci_conf_write(pc, tag, off + PCI_MSI_MA, 0xfee00000);
@


1.69
log
@Implement pci_min_powerstate().
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.68 2011/12/04 20:08:09 kettenis Exp $	*/
d873 1
d924 5
@


1.68
log
@Slightly different fix for the problem fixed by the previous commit for better
diffability with the amd64 codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.67 2011/12/04 17:38:44 miod Exp $	*/
d936 14
@


1.67
log
@Do not check for an HyperTransport bus if we are using mode #2. Prevents a
safety panic from occuring.
Found the hard way by nick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.66 2011/10/23 21:18:14 kettenis Exp $	*/
d215 7
d308 11
a318 13
	if (pci_mode != 2) {
		/*
		 * Don't enable MSI on a HyperTransport bus.  In order to
		 * determine that bus 0 is a HyperTransport bus, we look at
		 * device 24 function 0, which is the HyperTransport
		 * host/primary interface integrated on most 64-bit AMD CPUs.
		 * If that device has a HyperTransport capability, bus 0 must
		 * be a HyperTransport bus and we disable MSI.
		 */
		tag = pci_make_tag(pc, 0, 24, 0);
		if (pci_get_capability(pc, tag, PCI_CAP_HT, NULL, NULL))
			pba->pba_flags &= ~PCI_FLAGS_MSI_ENABLED;
	}
@


1.66
log
@Remove comment; the question can be answerd affirmative.  Fix a coding style
nit while I'm there.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.65 2011/10/21 18:16:13 kettenis Exp $	*/
d301 13
a313 11
	/*
	 * Don't enable MSI on a HyperTransport bus.  In order to
	 * determine that bus 0 is a HyperTransport bus, we look at
	 * device 24 function 0, which is the HyperTransport
	 * host/primary interface integrated on most 64-bit AMD CPUs.
	 * If that device has a HyperTransport capability, bus 0 must
	 * be a HyperTransport bus and we disable MSI.
	 */
	tag = pci_make_tag(pc, 0, 24, 0);
	if (pci_get_capability(pc, tag, PCI_CAP_HT, NULL, NULL))
		pba->pba_flags &= ~PCI_FLAGS_MSI_ENABLED;
d323 1
a323 1
	 * Mechanism 1 is in use, can have devices 0-32 (i.e. the `normal'
@


1.65
log
@Add bounds checks for access to mp_busses.  Also make sure that we don't
accidentally use ISA or EISA interrupt mappings on PCI busses.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.64 2011/10/13 18:09:33 kettenis Exp $	*/
d635 1
a635 6
		/*
		 * Assumes 1:1 mapping between PCI bus numbers and
		 * the numbers given by the MP bios.
		 * XXX Is this a valid assumption?
		 */
		int mpspec_pin = (dev<<2)|(pin-1);
@


1.64
log
@I'm sick and tired of people doing misalgned reads and writes to PCI config
space and not noticing because they only test on amd64.  So enforce alignment
there as well, at least for a little while such that we find those bugs and
force people to fix them.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.63 2011/06/08 22:57:59 kettenis Exp $	*/
d642 10
a651 4
		for (mip = mp_busses[bus].mb_intrs; mip != NULL; mip=mip->next) {
			if (mip->bus_pin == mpspec_pin) {
				ihp->line = mip->ioapic_ih | line;
				return 0;
@


1.63
log
@Ateempt to make pci_intr_disestablish() work for MSIs.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.62 2011/05/30 19:24:28 kettenis Exp $	*/
d414 2
d451 2
@


1.62
log
@Enable MSI on selected hardware.  For now this means:

- Intel chipset supporting Pentium 4 or later.
- Any AMD chipset made in this century.
- Any NVIDIA chipset that has PCIe.

Explicitly disable MSI on chipsets that connect to the CPU over HyperTransport.
Enabling MSI on those systems is handled by the HyperTransport support code
in our PCI subsystem.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.61 2011/05/29 10:47:42 kettenis Exp $	*/
d767 1
d789 4
a792 2
		ih->ih_irq = vec;
		evcount_attach(&ih->ih_count, what, &ih->ih_irq);
d834 21
@


1.61
log
@Don't attempt to use MSI if we're not running in APIC mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.60 2011/05/21 15:14:57 kettenis Exp $	*/
d198 3
d210 102
@


1.60
log
@First stab at supporting Message Signaled Interrupts on i386.  Still work in
progress.  The code is effectively disabled as long as PCI_FLAGS_MSI_ENABLED
doesn't get set for the root PCI bus.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.59 2011/04/22 15:02:35 kettenis Exp $	*/
d488 1
a488 1
	if ((pa->pa_flags & PCI_FLAGS_MSI_ENABLED) == 0 ||
@


1.59
log
@Stop printing the PCI interrupt line programmed by the BIOS for APIC
interrupts.  It is irreleveant, confuses people and the information is
available in pcidump(8) output anyway.

ok oga@@, jsg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.58 2011/01/10 16:26:27 kettenis Exp $	*/
d106 2
d483 16
d628 3
d651 3
d661 40
@


1.58
log
@Only use MMCFG extended PCIe config space.  Gets us back the on-CPU PCI devices on AMD Family 0Fh processors.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.57 2011/01/09 11:38:10 kettenis Exp $	*/
d612 2
a613 2
		snprintf(irqstr, sizeof irqstr, "apic %d int %d (irq %d)",
		     APIC_IRQ_APIC(ih.line), APIC_IRQ_PIN(ih.line), line);
@


1.57
log
@Only use memory mapped extended PCIe config space access for the busses
advertised in the MCFG table, and fall back on the traditional method for
other busses.  Fixes issue reported by henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.56 2011/01/04 21:17:49 kettenis Exp $	*/
d307 1
a307 1
	if (pci_mcfg_addr) {
d343 1
a343 1
	if (pci_mcfg_addr) {
@


1.56
log
@Add support for Memory Mapped Configuration space access.  This gives us
access to PCIe extended configuration space access on modern i386 and amd64
machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.55 2010/12/04 17:06:31 miod Exp $	*/
d129 1
a227 9
	if (pci_mcfg_addr) {
		if (bus < pci_mcfg_min_bus  || bus > pci_mcfg_max_bus ||
		    device >= 32 || function >= 8)
			panic("pci_make_tag: bad request");

		tag.mode1 = (bus << 20) | (device << 15) | (function << 12);
		return tag;
	}

a253 10
	if (pci_mcfg_addr) {
		if (bp != NULL)
			*bp = (tag.mode1 >> 20) & 0xff;
		if (dp != NULL)
			*dp = (tag.mode1 >> 15) & 0x1f;
		if (fp != NULL)
			*fp = (tag.mode1 >> 12) & 0x7;
		return;
	}

d279 7
a285 2
	if (pci_mcfg_addr)
		return PCIE_CONFIG_SPACE_SIZE;
d290 11
d309 6
a314 7
		if (pci_mcfgh[bus] == 0 &&
		    bus_space_map(pci_mcfgt, pci_mcfg_addr + (bus << 20),
		    1 << 20, 0, &pci_mcfgh[bus]))
			panic("pci_conf_read: cannot map mcfg space");
		data = bus_space_read_4(pci_mcfgt, pci_mcfgh[bus],
		    (tag.mode1 & 0x000ff000) | reg);
		return data;
d345 6
a350 7
		if (pci_mcfgh[bus] == 0 &&
		    bus_space_map(pci_mcfgt, pci_mcfg_addr + (bus << 20),
		    1 << 20, 0, &pci_mcfgh[bus]))
			panic("pci_conf_write: cannot map mcfg space");
		bus_space_write_4(pci_mcfgt, pci_mcfgh[bus],
		    (tag.mode1 & 0x000ff000) | reg, data);
		return;
@


1.55
log
@Introduce a new pci routine, pci_conf_size(), which returns the size of a
given pcitag_t configuration address space. Currently, all pci controllers
will return the usual 0x100 bytes of PCI configuration space, but this will
eventually change on PCIe-capable controlers.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.54 2010/09/06 19:05:48 kettenis Exp $	*/
d117 13
d227 9
d262 9
d297 3
d307 12
d344 12
@


1.54
log
@Make sure bus_dmamap_sync() always involves a function call, to prevent the
compiler from doing stupid things like reordering stores around it.  There is
some debate whether this will be enough for newer versions of GCC and LLVM.
If this is indeed deemed necessary, this will be addressed in a future diff.

ok miod@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.53 2010/07/08 20:56:31 jordan Exp $	*/
d261 6
@


1.53
log
@Add mapping for ACPI device to PCI bdf (match autoconf tree)
Simplify resource parsing function to use buffer argument
Convert namespace linked lists to use queue macros
ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.52 2010/07/01 06:29:32 jordan Exp $	*/
d170 1
a170 1
	NULL,			/* _dmamap_sync */
@


1.52
log
@Backout recent AML changes, breaks on R210 and others
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.51 2010/06/29 22:08:28 jordan Exp $	*/
d670 1
a670 1
	//acpi_pci_match(dev, pa);
@


1.51
log
@Add support for mapping ACPI to PCI devices
ok kettenis, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.50 2009/09/28 15:58:30 kettenis Exp $	*/
d670 1
a670 1
	acpi_pci_match(dev, pa);
@


1.50
log
@Make video buffer area and BIOS areas unavailable for PCI resource allocation.
This should prevent problems on systems where these areas are not reserved in
the BIOS memory map.

ok miod@@, oga@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.49 2009/08/22 02:54:50 mk Exp $	*/
d659 13
@


1.49
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.48 2009/04/29 18:28:37 kettenis Exp $	*/
d654 4
@


1.48
log
@Extend pciio extents to cover the while 32-bit address space.  The processor
can only address the first 64K but BARs can contain garbage and addresses
beyond the end of the extent would cause a panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.47 2009/04/13 21:22:38 kettenis Exp $	*/
d572 1
a572 1
    int (*func)(void *), void *arg, char *what)
@


1.47
log
@Ignore zero-sized regions from the BIOS memory map when reserving root PCI
bus address space.  Fixes a problem reported by david@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.46 2009/04/11 17:13:33 kettenis Exp $	*/
d615 13
a627 3
	if (pciio_ex == NULL)
		pciio_ex = extent_create("pciio", 0, 0xffff, M_DEVBUF,
		    NULL, 0, EX_NOWAIT);
@


1.46
log
@Create extents for resource accounting on the root PCI bus and populate them
based on the BIOS memory map.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.45 2009/03/10 15:03:17 oga Exp $	*/
d634 4
@


1.45
log
@remove the _BUS_DMA_PRIVATE define from amd64 and i386.

a define needed to get to ``private'' functions that needs to be defined
5 or more times isn't much use and may cause namespace issues anyway.
Other archs will probably follow.

Discussed in portugal.  "Hell yes" weingart@@, ok kettenis@@, no
objections miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.44 2009/01/27 15:33:59 oga Exp $	*/
d82 2
d90 1
a93 1
#include <machine/biosvar.h>
d604 37
@


1.44
log
@Switch the amd64 PCI_CONF_LOCK from being a simplelock and splhigh to a
mutex with ipl set to IPL_HIGH. While i'm here, unify the code with
i386, by giving the same lock to the i386 code.

This lock is mostly for MP, but could actually prevent a race where a
process is doing pci_conf_{read,write}, and then an interrupt fire and
also does pci_conf_{read,write}. Since this is a two stage process, the
interrupt could race with the one, causing the value to the written to
the wrong place, or the wrong value to be written.

Tested by many. "go ahead" kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.43 2008/12/28 18:26:53 kettenis Exp $	*/
a84 1
#define _BUS_DMA_PRIVATE
@


1.43
log
@Remove confusion between "raw" and "swizzled" interrupt pins.  Remove some
#ifdef __i386__ code that can go now things have been cleaned up.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.42 2008/12/07 14:33:26 kettenis Exp $	*/
d116 12
d267 1
d283 1
d292 1
d308 1
@


1.42
log
@Make acpiprt(4) check whether the current interrupt routing is "possible" and
pick a new one from the list of possible routings if it isn't or if a pin is
currently not routed.  Delay re-routing interrupts until we establish a
handler for it.  This prevents us from messing with unused interrupt pins
which may have fatal consequences (some machines spontaniously reboot).

The heuristics for picking an interrupt from the list of possibe ones
probably needs some tweaking still, but this makes several NVIDIA-based
boards work much better than before.

tested by many, ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.41 2008/12/03 15:46:07 oga Exp $	*/
d406 1
a406 1
	int pin = pa->pa_intrpin;
a408 1
	int rawpin = pa->pa_rawintrpin;
a412 5
#if (NPCIBIOS > 0) || (NIOAPIC > 0)
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t intrtag = pa->pa_intrtag;
#endif

d423 1
a423 1
	ihp->tag = pa->pa_intrtag;
d428 1
a428 1
	pci_decompose_tag (pc, intrtag, &bus, &dev, &func);
d446 3
a448 3
			int pin = PPB_INTERRUPT_SWIZZLE(rawpin, dev);
			if (pa->pa_bridgeih[pin - 1].line != -1) {
				ihp->line = pa->pa_bridgeih[pin - 1].line;
d461 1
a461 1
	pci_intr_header_fixup(pc, intrtag, ihp);
@


1.41
log
@Remove the x86 and i386 prefixes to the bus_dma types. It's really quite
pointless and just makes the code different for no reason. This moves i386 and
amd64 bus_dma to being a lot closer to identical.

suggestion to just remove the prefix instead of merge them from deraadt@@.

no objections art@@, kettenis@@, ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.40 2008/06/26 05:42:11 ray Exp $	*/
d429 1
d554 5
d564 1
d566 5
@


1.40
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.39 2007/05/21 22:10:45 kettenis Exp $	*/
d85 1
a85 1
#define _I386_BUS_DMA_PRIVATE
d148 1
a148 1
struct i386_bus_dma_tag pci_bus_dma_tag = {
@


1.39
log
@Implement deep interrupt swizzling by mapping all four PCI interrupt pins
for PCI-PCI bridges and passing the mapping to the attached bus device.
MD code can use these when mapping PCI device interrupts.  This diff adds
such code for amd64 and i386.  This fixes interrupt mapping for devices that
sit behind two PCI-PCI bridges where the firmware only provides a mapping
for the first PCI-PCI bridge.

tested by sturm@@, krw@@, and a few others, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.38 2007/02/20 21:15:01 tom Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.38
log
@Revert PAE pmap for now, until the strange bug is found.  This stops
the freezes many of us are seeing (especially on amd64 machines running
OpenBSD/i386).

Much testing by nick@@ (as always - thanks!), hugh@@, ian@@, kettenis@@
and Sam Smith (s (at) msmith (dot) net).

Requested by, input from, and ok deraadt@@  ok art@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.37 2006/12/20 18:59:50 kettenis Exp $	*/
d107 1
d413 2
d416 1
a424 2
	int pin = pa->pa_intrpin;
	int line = pa->pa_intrline;
d431 1
a431 1
	if (pin > 4) {
a455 2
		if (mip == NULL && pa->pa_bridgetag) {
			int bridgebus, bridgedev;
d457 6
a462 9
			pci_decompose_tag(pc, *pa->pa_bridgetag,
			    &bridgebus, &bridgedev, NULL);
			mpspec_pin = (bridgedev << 2)|((pin + dev - 1) & 0x3);
			for (mip = mp_busses[bridgebus].mb_intrs; mip != NULL;
			    mip = mip->next) {
				if (mip->bus_pin == mpspec_pin) {
					ihp->line = mip->ioapic_ih | line;
					return 0;
				}
d491 1
a491 2
	if (line == 0 || line == 255) {
		printf("pci_intr_map: no mapping for pin %c\n", '@@' + pin);
d493 8
a500 9
	} else {
		if (line >= ICU_LEN) {
			printf("pci_intr_map: bad interrupt line %d\n", line);
			goto bad;
		}
		if (line == 2) {
			printf("pci_intr_map: changed line 2 to line 9\n");
			line = 9;
		}
d502 1
@


1.37
log
@Don't bail out on a bad interrupt line if we have a valid apic interrupt pin
for a pci device.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.36 2006/12/11 19:47:37 kettenis Exp $	*/
d116 1
d118 1
@


1.36
log
@On i386, swizzle interrupts for devices for which we don't have explicit
inetrrupt routing information.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.35 2006/11/11 21:47:52 kettenis Exp $	*/
d434 39
a505 2
	pci_decompose_tag (pc, intrtag, &bus, &dev, &func);

a506 27
		/*
		 * Assumes 1:1 mapping between PCI bus numbers and
		 * the numbers given by the MP bios.
		 * XXX Is this a valid assumption?
		 */
		int mpspec_pin = (dev<<2)|(pin-1);

		for (mip = mp_busses[bus].mb_intrs; mip != NULL; mip=mip->next) {
			if (mip->bus_pin == mpspec_pin) {
				ihp->line = mip->ioapic_ih | line;
				return 0;
			}
		}
		if (mip == NULL && pa->pa_bridgetag) {
			int bridgebus, bridgedev;

			pci_decompose_tag(pc, *pa->pa_bridgetag,
			    &bridgebus, &bridgedev, NULL);
			mpspec_pin = (bridgedev << 2)|((pin + dev - 1) & 0x3);
			for (mip = mp_busses[bridgebus].mb_intrs; mip != NULL;
			    mip = mip->next) {
				if (mip->bus_pin == mpspec_pin) {
					ihp->line = mip->ioapic_ih | line;
					return 0;
				}
			}
		}
a546 3
	if (line == 0 || line >= ICU_LEN || line == 2)
		panic("pci_intr_string: bogus handle 0x%x", line);

d554 3
@


1.35
log
@Get rid of magic isa and eisa bus numbers in mpbios code.  Pave the way for
alternative sources for interrupt information.

ok gwk@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.34 2006/09/19 11:06:34 jsg Exp $	*/
d481 14
@


1.34
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.33 2006/06/25 07:44:54 brad Exp $	*/
d483 3
a485 3
		if (mip == NULL && mp_isa_bus != -1) {
			for (mip = mp_busses[mp_isa_bus].mb_intrs; mip != NULL;
			    mip=mip->next) {
d492 3
a494 3
		if (mip == NULL && mp_eisa_bus != -1) {
			for (mip = mp_busses[mp_eisa_bus].mb_intrs;
			    mip != NULL; mip=mip->next) {
@


1.33
log
@reorganize the code to be more sane.

ok toby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.32 2006/06/02 19:39:49 pascoe Exp $	*/
d170 2
a171 3
pci_attach_hook(parent, self, pba)
	struct device *parent, *self;
	struct pcibus_attach_args *pba;
d185 1
a185 3
pci_bus_maxdevs(pc, busno)
	pci_chipset_tag_t pc;
	int busno;
d201 1
a201 3
pci_make_tag(pc, bus, device, function)
	pci_chipset_tag_t pc;
	int bus, device, function;
d229 1
a229 4
pci_decompose_tag(pc, tag, bp, dp, fp)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int *bp, *dp, *fp;
d255 1
a255 4
pci_conf_read(pc, tag, reg)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg;
d279 1
a279 5
pci_conf_write(pc, tag, reg, data)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg;
	pcireg_t data;
d300 1
a300 1
pci_mode_detect()
d408 1
a408 3
pci_intr_map(pa, ihp)
	struct pci_attach_args *pa;
	pci_intr_handle_t *ihp;
d518 1
a518 3
pci_intr_string(pc, ih)
	pci_chipset_tag_t pc;
	pci_intr_handle_t ih;
d539 2
a540 6
pci_intr_establish(pc, ih, level, func, arg, what)
	pci_chipset_tag_t pc;
	pci_intr_handle_t ih;
	int level, (*func)(void *);
	void *arg;
	char *what;
d562 1
a562 3
pci_intr_disestablish(pc, cookie)
	pci_chipset_tag_t pc;
	void *cookie;
@


1.32
log
@Spelling.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.31 2006/04/27 15:37:55 mickey Exp $	*/
a209 1
#ifndef PCI_CONF_MODE
d212 6
a217 1
		goto mode1;
d219 7
a225 1
		goto mode2;
a228 13
#endif

#if !defined(PCI_CONF_MODE) || (PCI_CONF_MODE == 1)
#ifndef PCI_CONF_MODE
mode1:
#endif
	if (bus >= 256 || device >= 32 || function >= 8)
		panic("pci_make_tag: bad request");

	tag.mode1 = PCI_MODE1_ENABLE |
		    (bus << 16) | (device << 11) | (function << 8);
	return tag;
#endif
a229 10
#if !defined(PCI_CONF_MODE) || (PCI_CONF_MODE == 2)
#ifndef PCI_CONF_MODE
mode2:
#endif
	if (bus >= 256 || device >= 16 || function >= 8)
		panic("pci_make_tag: bad request");

	tag.mode2.port = 0xc000 | (device << 8);
	tag.mode2.enable = 0xf0 | (function << 1);
	tag.mode2.forward = bus;
a230 1
#endif
a239 1
#ifndef PCI_CONF_MODE
d242 7
a248 1
		goto mode1;
d250 7
a256 1
		goto mode2;
a259 26
#endif

#if !defined(PCI_CONF_MODE) || (PCI_CONF_MODE == 1)
#ifndef PCI_CONF_MODE
mode1:
#endif
	if (bp != NULL)
		*bp = (tag.mode1 >> 16) & 0xff;
	if (dp != NULL)
		*dp = (tag.mode1 >> 11) & 0x1f;
	if (fp != NULL)
		*fp = (tag.mode1 >> 8) & 0x7;
	return;
#endif

#if !defined(PCI_CONF_MODE) || (PCI_CONF_MODE == 2)
#ifndef PCI_CONF_MODE
mode2:
#endif
	if (bp != NULL)
		*bp = tag.mode2.forward & 0xff;
	if (dp != NULL)
		*dp = (tag.mode2.port >> 8) & 0xf;
	if (fp != NULL)
		*fp = (tag.mode2.enable >> 1) & 0x7;
#endif
a269 1
#ifndef PCI_CONF_MODE
d272 4
a275 1
		goto mode1;
d277 5
a281 1
		goto mode2;
a284 11
#endif

#if !defined(PCI_CONF_MODE) || (PCI_CONF_MODE == 1)
#ifndef PCI_CONF_MODE
mode1:
#endif
	outl(PCI_MODE1_ADDRESS_REG, tag.mode1 | reg);
	data = inl(PCI_MODE1_DATA_REG);
	outl(PCI_MODE1_ADDRESS_REG, 0);
	return data;
#endif
a285 8
#if !defined(PCI_CONF_MODE) || (PCI_CONF_MODE == 2)
#ifndef PCI_CONF_MODE
mode2:
#endif
	outb(PCI_MODE2_ENABLE_REG, tag.mode2.enable);
	outb(PCI_MODE2_FORWARD_REG, tag.mode2.forward);
	data = inl(tag.mode2.port | reg);
	outb(PCI_MODE2_ENABLE_REG, 0);
a286 1
#endif
a296 1
#ifndef PCI_CONF_MODE
d299 4
a302 1
		goto mode1;
d304 5
a308 1
		goto mode2;
a311 21
#endif

#if !defined(PCI_CONF_MODE) || (PCI_CONF_MODE == 1)
#ifndef PCI_CONF_MODE
mode1:
#endif
	outl(PCI_MODE1_ADDRESS_REG, tag.mode1 | reg);
	outl(PCI_MODE1_DATA_REG, data);
	outl(PCI_MODE1_ADDRESS_REG, 0);
	return;
#endif

#if !defined(PCI_CONF_MODE) || (PCI_CONF_MODE == 2)
#ifndef PCI_CONF_MODE
mode2:
#endif
	outb(PCI_MODE2_ENABLE_REG, tag.mode2.enable);
	outb(PCI_MODE2_FORWARD_REG, tag.mode2.forward);
	outl(tag.mode2.port | reg, data);
	outb(PCI_MODE2_ENABLE_REG, 0);
#endif
@


1.31
log
@implement separate PAE pmap that allows access to 64g of physmem
if supported by the cpu(s). currently not enabled by default and
not compiled into ramdisks. this grows paddr_t to 64bit but yet
leaves bus_addr_t at 32bits. measures are taken to favour dmaable
memory allocation from below 4g line such that buffer cache is
already allocated form below, pool backend allocator prefers lower
memory and then finally bounce buffers are used as last resort.
PAE is engaged only if global variable cpu_pae is manually set
to non-zero and there is physical memory present above 4g.
simplify pcibios address math to use u_long as we always will
be in the 32bit space.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.30 2005/11/23 09:24:57 mickey Exp $	*/
d394 1
a394 1
	 * to try and devine the correct mode.
@


1.30
log
@resolve a couple of problems in mpbios-mapped interrupts:
- synthesise isa mappings (as 1-1) should those be missing in mpbios;
- for rcc osb* firce "special" ints into isa mappings always.
niklas@@ ok and testing by many since
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.29 2005/07/28 17:22:28 brad Exp $	*/
a115 1
#if NPCIBIOS > 0
a116 1
#endif
@


1.29
log
@rev 1.46

Add quirk for Connectix Virtual PC 5 (for Windows at least) emulated
PCI bridge (440BX).

From minoura NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.28 2005/07/28 16:51:07 brad Exp $	*/
d110 1
a111 1
#include <machine/i82093var.h>
d513 1
a513 1
	line = ihp->line;
d546 1
a546 1
	if (mp_busses != NULL) {
d600 1
d602 2
a603 2
	if (ih.line == 0 || (ih.line  & 0xff) >= ICU_LEN || ih.line == 2)
		panic("pci_intr_string: bogus handle 0x%x", ih.line);
d608 1
a608 2
		     APIC_IRQ_APIC(ih.line), APIC_IRQ_PIN(ih.line),
		     ih.line & 0xff);
d613 1
a613 1
	snprintf(irqstr, sizeof irqstr, "irq %d", ih.line);
d626 1
d629 1
a629 1
	if (ih.line != -1 && ih.line & APIC_INT_VIA_APIC)
d633 2
a634 2
	if (ih.line == 0 || ih.line >= ICU_LEN || ih.line == 2)
		panic("pci_intr_establish: bogus handle 0x%x", ih.line);
d636 1
a636 2
	ret = isa_intr_establish(NULL, ih.line, IST_LEVEL, level, func, arg,
	    what);
@


1.28
log
@rev 1.32

redo the PCI configuration mode detection - should make some less
standard compliant PCI chipsets work (Compaq, Connectix emulated Triton)

From drochner NetBSD

Tested by a number of end-users and a few developers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.27 2005/06/27 02:36:06 brad Exp $	*/
d143 2
@


1.27
log
@rev 1.41

delint: don't try & return something from void pci_intr_disestablish()

From NetBSD

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.26 2004/12/23 17:43:18 aaron Exp $	*/
d106 1
d129 19
d383 4
d388 1
a388 1
		return pci_mode;
d408 1
a408 3
	 * We try to divine which configuration mode the host bridge wants.  We
	 * try mode 2 first, because our probe for mode 1 is likely to succeed
	 * for mode 2 also.
d414 55
a474 1

a475 9
	outl(PCI_MODE1_ADDRESS_REG, PCI_MODE1_ENABLE);
	if (inl(PCI_MODE1_ADDRESS_REG) != PCI_MODE1_ENABLE)
		goto not1;
	outl(PCI_MODE1_ADDRESS_REG, 0);
	if (inl(PCI_MODE1_ADDRESS_REG) != 0)
		goto not1;
	return (pci_mode = 1);

not1:
@


1.26
log
@Allow an i386 MP kernel to build without pcibios.  miod@@ ok

-#if NPCIBIOS > 0
+#if (NPCIBIOS > 0) || (NIOAPIC > 0)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.25 2004/06/13 21:49:16 niklas Exp $	*/
d581 1
a581 1
	return (isa_intr_disestablish(NULL, cookie));
@


1.25
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d423 1
a423 1
#if NPCIBIOS > 0
@


1.24
log
@snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.23 2002/03/14 01:26:33 millert Exp $	*/
d95 1
a102 1
#include <i386/isa/icu.h>
d107 7
d418 5
d474 43
d530 1
a530 1
	static char irqstr[8];		/* 4 + 2 + NULL + sanity */
d532 1
a532 1
	if (ih.line == 0 || ih.line >= ICU_LEN || ih.line == 2)
d535 9
a545 1
	
d558 5
d566 2
a567 2
	ret = isa_intr_establish(NULL, ih.line,
	    IST_LEVEL, level, func, arg, what);
d572 1
a572 1
	return ret;
d581 1
a581 1
	return isa_intr_disestablish(NULL, cookie);
@


1.23
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.22 2001/11/06 19:53:14 miod Exp $	*/
d480 1
a480 1
	sprintf(irqstr, "irq %d", ih.line);
@


1.22
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.21 2001/09/11 20:05:24 miod Exp $	*/
d489 1
a489 1
	int level, (*func) __P((void *));
@


1.22.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.22 2001/11/06 19:53:14 miod Exp $	*/
d489 1
a489 1
	int level, (*func)(void *);
@


1.22.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d480 1
a480 1
	snprintf(irqstr, sizeof irqstr, "irq %d", ih.line);
@


1.21
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.20 2001/08/27 08:20:04 art Exp $	*/
d90 1
a90 1
#include <vm/vm.h>
@


1.20
log
@Let this build without pcibios.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.19 2001/08/25 10:13:29 art Exp $	*/
a90 1
#include <vm/vm_kern.h>
@


1.19
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.18 2001/01/27 04:59:40 mickey Exp $	*/
d412 1
d415 1
@


1.18
log
@change interrupt routing strategy from simple
run through the devices and programming the icu
and pci headers before real pci bus autoconf starts
and include all devices present on all pci busses,
to a per attached device routing in pci_intr_map().
this solves several cases of premature interrupts hanging
system due to absent interrupt handlers during autoconf.
10x for testing: millert@@ krw@@ aaron@@ chris@@ tholo@@ brad@@ jason@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.17 2000/10/25 19:13:12 mickey Exp $	*/
d408 2
a409 4
pci_intr_map(pc, intrtag, pin, line, ihp)
	pci_chipset_tag_t pc;
	pcitag_t intrtag;
	int pin, line;
d412 5
@


1.17
log
@put back using bios_pciinfo, we will rework it later on
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.16 2000/08/17 22:08:10 mickey Exp $	*/
d108 5
a413 1

d424 7
a458 1
	*ihp = line;
d462 1
a462 1
	*ihp = -1;
d473 2
a474 2
	if (ih == 0 || ih >= ICU_LEN || ih == 2)
		panic("pci_intr_string: bogus handle 0x%x", ih);
d476 1
a476 1
	sprintf(irqstr, "irq %d", ih);
d489 1
d491 2
a492 2
	if (ih == 0 || ih >= ICU_LEN || ih == 2)
		panic("pci_intr_establish: bogus handle 0x%x", ih);
d494 7
a500 1
	return isa_intr_establish(NULL, ih, IST_LEVEL, level, func, arg, what);
d508 1
a508 1

@


1.16
log
@pcibios tells us everything, no bios_pciinfo
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.15 2000/03/05 19:07:44 mickey Exp $	*/
d97 6
d144 5
d151 1
d355 17
d378 2
a379 1
	 * PCI BIOS does not exist, or it was disabled in kernel config.
@


1.15
log
@export bios_pciinfo for the whole _KERNEL, there will be more files to use it
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.14 1999/01/11 05:11:26 millert Exp $	*/
a96 5
#include "bios.h"
#if NBIOS > 0
#include <machine/biosvar.h>
#endif

a137 5
#if NBIOS > 0
	if (pba->pba_bus == 0)
		printf(": configuration mode %d (%s)",
			pci_mode, (bios_pciinfo?"bios":"no bios"));
#else
a139 1
#endif
a342 17
#if NBIOS > 0
	/*
	 * If we have PCI info passed from the BIOS, use the mode given there
	 * for all of this code.  If not, pass on through to the previous tests
	 * to try and devine the correct mode.
	 */
	if (bios_pciinfo != NULL) {
		if (bios_pciinfo->pci_chars & 0x2)
			return (pci_mode = 2);

		if (bios_pciinfo->pci_chars & 0x1)
			return (pci_mode = 1);

		/* We should never get here, but if we do, fall through... */
	}
#endif

d349 1
a349 2
	 * PCI BIOS does not exist, or the boot blocks did not provide the
	 * information.
@


1.14
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.13 1998/07/09 19:26:42 deraadt Exp $	*/
a99 1
extern bios_pciinfo_t *bios_pciinfo;
@


1.14.6.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d100 1
@


1.14.6.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.18 2001/01/27 04:59:40 mickey Exp $	*/
a99 1
extern bios_pciinfo_t *bios_pciinfo;
a106 5
#include "pcibios.h"
#if NPCIBIOS > 0
#include <i386/pci/pcibiosvar.h>
#endif

d408 1
a418 7
	ihp->line = line;
	ihp->pin = pin;
#if NPCIBIOS > 0
	pci_intr_header_fixup(pc, intrtag, ihp);
	line = ihp->line;
#endif

d447 1
d451 1
a451 1
	ihp->line = -1;
d462 2
a463 2
	if (ih.line == 0 || ih.line >= ICU_LEN || ih.line == 2)
		panic("pci_intr_string: bogus handle 0x%x", ih.line);
d465 1
a465 1
	sprintf(irqstr, "irq %d", ih.line);
a477 1
	void *ret;
d479 2
a480 2
	if (ih.line == 0 || ih.line >= ICU_LEN || ih.line == 2)
		panic("pci_intr_establish: bogus handle 0x%x", ih.line);
d482 1
a482 7
	ret = isa_intr_establish(NULL, ih.line,
	    IST_LEVEL, level, func, arg, what);
#if NPCIBIOS > 0
	if (ret)
		pci_intr_route_link(pc, &ih);
#endif
	return ret;
d490 1
a490 1
	/* XXX oh, unroute the pci int link? */
@


1.14.6.3
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.14.6.2 2001/04/18 16:08:28 niklas Exp $	*/
a107 7
#include "ioapic.h"

#if NIOAPIC > 0
#include <machine/i82093var.h>
#include <machine/mpbiosvar.h>
#endif

a413 5
#if NIOAPIC > 0
	struct mp_intr_map *mip;
	int bus, dev, func;
#endif

a457 25
#if NIOAPIC > 0
	pci_decompose_tag (pc, intrtag, &bus, &dev, &func);
#if 0
	printf("pci_intr_map: bus %d dev %d func %d pin %d; line %d\n",
		bus, dev, func, pin, line);
#endif

	if (mp_busses != NULL) {
		/*
		 * Assumes 1:1 mapping between PCI bus numbers and
		 * the numbers given by the MP bios.
		 * XXX Is this a valid assumption?
		 */
		int mpspec_pin = (dev<<2)|(pin-1);

		for (mip = mp_busses[bus].mb_intrs; mip != NULL; mip=mip->next) {
			if (mip->bus_pin == mpspec_pin) {
				ihp->line = mip->ioapic_ih | line;
				return 0;
			}
		}
		if (mip == NULL)
			printf("pci_intr_map: no MP mapping found\n");
	}
#endif
d471 1
a471 1
	static char irqstr[64];
d476 1
a476 11
#if NIOAPIC > 0
	if (ih.line & APIC_INT_VIA_APIC)
		sprintf(irqstr, "apic %d int %d (irq %d)",
			APIC_IRQ_APIC(ih.line),
			APIC_IRQ_PIN(ih.line),
			ih.line & 0xff);
	else
		sprintf(irqstr, "irq %d", ih.line & 0xff);
#else
	sprintf(irqstr, "irq %d", ih.line & 0xff);
#endif
d478 1
a490 5
#if NIOAPIC > 0
	if (ih.line != -1 && ih.line & APIC_INT_VIA_APIC)
		return apic_intr_establish(ih.line, IST_LEVEL, level, func, 
					   arg);
#endif
@


1.14.6.4
log
@KNF
Correct check for bogus interrupts.
Simplify logic
Add name to APIC interupt establishments a la OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d510 1
a510 1
	if (ih.line == 0 || (ih.line  & 0xff) >= ICU_LEN || ih.line == 2)
d514 1
a514 1
	if (ih.line & APIC_INT_VIA_APIC) {
d516 7
a522 4
		     APIC_IRQ_APIC(ih.line), APIC_IRQ_PIN(ih.line),
		     ih.line & 0xff);
		return (irqstr);
	}
a523 2

	sprintf(irqstr, "irq %d", ih.line & 0xff);
d539 2
a540 2
		return (apic_intr_establish(ih.line, IST_LEVEL, level, func, 
		    arg, what));
d545 2
a546 2
	ret = isa_intr_establish(NULL, ih.line, IST_LEVEL, level, func, arg,
	    what);
d551 1
a551 1
	return (ret);
d560 1
a560 1
	return (isa_intr_disestablish(NULL, cookie));
@


1.14.6.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.14.6.4 2001/07/16 21:41:55 niklas Exp $	*/
d91 1
d415 4
a418 2
pci_intr_map(pa, ihp)
	struct pci_attach_args *pa;
a424 7

#if NPCIBIOS > 0
	pci_chipset_tag_t pc = pa->pa_pc;
	pcitag_t intrtag = pa->pa_intrtag;
#endif
	int pin = pa->pa_intrpin;
	int line = pa->pa_intrline;
@


1.14.6.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d90 1
a90 1
#include <uvm/uvm_extern.h>
@


1.14.6.7
log
@Merge in -current from about a week ago
@
text
@d534 1
a534 1
	int level, (*func)(void *);
@


1.14.6.8
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.14.6.7 2002/03/28 10:31:05 niklas Exp $	*/
d519 1
a519 1
		snprintf(irqstr, sizeof irqstr, "apic %d int %d (irq %d)",
d526 1
a526 1
	snprintf(irqstr, sizeof irqstr, "irq %d", ih.line);
@


1.14.6.9
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.14.6.8 2003/05/13 19:42:08 ho Exp $	*/
d476 4
d495 1
a495 14
		if (mip == NULL && mp_isa_bus != -1) {
			for (mip = mp_busses[mp_isa_bus].mb_intrs; mip != NULL;
			    mip=mip->next) {
				if (mip->bus_pin == line) {
					ihp->line = mip->ioapic_ih | line;
					return 0;
				}
			}
		}
		/* XXX scan the EISA bus too */
		if (mip == NULL) {
			printf("pci_intr_map: "
			    "bus %d dev %d func %d pin %d; line %d\n",
			    bus, dev, func, pin, line);
a496 1
		}
@


1.14.6.10
log
@a small step towards an integrated PIC/APIC system: move isa/icu.h to
include/i8259.h, and adapt the ACK/MASK/UNMASK macros so we can
reuse the API for APICs.  From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.14.6.9 2003/05/15 04:08:02 niklas Exp $	*/
a94 1
#include <machine/i8259.h>
d102 1
@


1.14.6.11
log
@In pci_intr_map() search for eisa mp mappings too; from netbsd.
Tested by pb@@, ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.14.6.10 2004/03/23 08:02:56 niklas Exp $	*/
d500 1
a500 9
		if (mip == NULL && mp_eisa_bus != -1) {
			for (mip = mp_busses[mp_eisa_bus].mb_intrs;
			    mip != NULL; mip=mip->next) {
				if (mip->bus_pin == line) {
					ihp->line = mip->ioapic_ih | line;
					return 0;
				}
			}
		}
@


1.13
log
@fix support for pci mode 1; mochid@@yo.rim.or.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.12 1998/02/24 22:02:11 weingart Exp $	*/
d464 1
a464 1
		panic("pci_intr_string: bogus handle 0x%x\n", ih);
d481 1
a481 1
		panic("pci_intr_establish: bogus handle 0x%x\n", ih);
@


1.12
log
@First commit of /boot changes/fixes.  More to come.
Add BIOS PCI probe stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.11 1998/01/20 18:40:23 niklas Exp $	*/
d327 1
@


1.11
log
@Merge bus_dma support from NetBSD, mostly by Jason Thorpe.  Only i386 uses it
 so far, the other archs gets placeholders for now.  I wrote a compatibility
layer for OpenBSD's old isadma code so we can still use our old
driver sources.  They will however get changed to native bus_dma use,
on a case by case basis.   Oh yes, I almost forgot, I kept our notion
of isadma being a device so DMA-less ISA-busses still work
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.10 1997/06/18 19:07:01 dm Exp $	*/
d95 1
d97 5
a101 1
#include <machine/pio.h>
d144 5
d151 1
d354 17
d376 3
a378 2
	 * XXX
	 * This should really be done using the PCI BIOS.
a379 1

@


1.10
log
@csapuntz@@lcs.mit.edu: Port of NetBSD tulip driver.  Works with new (21140-AC-based) SMC Etherpower cards.
@
text
@d1 39
a39 2
/*	$OpenBSD: pci_machdep.c,v 1.9 1996/11/28 23:37:42 niklas Exp $	*/
/*	$NetBSD: pci_machdep.c,v 1.26 1996/10/24 12:32:29 fvdl Exp $	*/
d93 3
d111 21
@


1.9
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_machdep.c,v 1.26 1996/10/24 12:32:29 fvdl Exp $	*/
d141 44
@


1.8
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 1
/*	$NetBSD: pci_machdep.c,v 1.23 1996/04/11 22:15:33 cgd Exp $	*/
d119 1
d121 1
d131 1
d133 1
d164 1
d166 1
d174 1
d176 1
d205 1
d207 1
d214 1
d216 1
@


1.7
log
@Merge of NetBSD 960317
@
text
@d1 1
a1 1
/*	$NetBSD: pci_machdep.c,v 1.20 1996/03/04 19:39:31 cgd Exp $	*/
d4 1
d71 28
d100 2
a101 1
pci_make_tag(bus, device, function)
d140 2
a141 1
pci_conf_read(tag, reg)
d177 2
a178 1
pci_conf_write(tag, reg, data)
d256 5
a260 115
pci_map_io(tag, reg, iobasep)
	pcitag_t tag;
	int reg;
	int *iobasep;
{
	pcireg_t address;
	int iobase;

	if (reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3))
		panic("pci_map_io: bad request");

	address = pci_conf_read(tag, reg);

	if (PCI_MAPREG_TYPE(address) != PCI_MAPREG_TYPE_IO)
		panic("pci_map_io: not an I/O mapping register");

	iobase = PCI_MAPREG_IO_ADDR(address);
	*iobasep = iobase;

	return 0;
}

int
pci_map_mem(tag, reg, vap, pap)
	pcitag_t tag;
	int reg;
	vm_offset_t *vap, *pap;
{
	pcireg_t address, mask;
	int cachable;
	vm_size_t size;
	vm_offset_t va, pa;

	if (reg < PCI_MAPREG_START || reg >= PCI_MAPREG_END || (reg & 3))
		panic("pci_map_mem: bad request");

	/*
	 * Section 6.2.5.1, `Address Maps', tells us that:
	 *
	 * 1) The builtin software should have already mapped the device in a
	 * reasonable way.
	 *
	 * 2) A device which wants 2^n bytes of memory will hardwire the bottom
	 * n bits of the address to 0.  As recommended, we write all 1s and see
	 * what we get back.
	 */
	address = pci_conf_read(tag, reg);
	pci_conf_write(tag, reg, 0xffffffff);
	mask = pci_conf_read(tag, reg);
	pci_conf_write(tag, reg, address);

	if (PCI_MAPREG_TYPE(address) == PCI_MAPREG_TYPE_IO)
		panic("pci_map_mem: I/O mapping register");

	switch (address & PCI_MAPREG_MEM_TYPE_MASK) {
	case PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_MEM_TYPE_32BIT_1M:
		break;
	case PCI_MAPREG_MEM_TYPE_64BIT:
		printf("pci_map_mem: 64-bit memory mapping register\n");
		return EOPNOTSUPP;
	default:
		printf("pci_map_mem: reserved mapping register type\n");
		return EINVAL;
	}

	pa = PCI_MAPREG_MEM_ADDR(address);
	size = ~PCI_MAPREG_MEM_ADDR(mask) + 1;
	if (size < NBPG)
		size = NBPG;

	va = kmem_alloc_pageable(kernel_map, size);
	if (va == 0) {
		printf("pci_map_mem: not enough memory\n");
		return ENOMEM;
	}

	/*
	 * Tell the driver where we mapped it.
	 *
	 * If the region is smaller than one page, adjust the virtual address
	 * to the same page offset as the physical address.
	 */
	*vap = va + (pa & PGOFSET);
	*pap = pa;

#if 1
	printf("pci_map_mem: mapping memory at virtual %08x, physical %08x\n", *vap, *pap);
#endif

	/* Map the space into the kernel page table. */
	cachable = PCI_MAPREG_MEM_CACHEABLE(address);
	pa &= ~PGOFSET;
	while (size) {
		pmap_enter(pmap_kernel(), va, pa, VM_PROT_READ | VM_PROT_WRITE,
		    TRUE);
		if (!cachable)
			pmap_changebit(pa, PG_N, ~0);
		else
			pmap_changebit(pa, 0, ~PG_N);
		va += NBPG;
		pa += NBPG;
		size -= NBPG;
	}

	return 0;
}

void *
pci_map_int(tag, level, func, arg, what)
	pcitag_t tag;
	int level;
	int (*func) __P((void *));
	void *arg;
	char *what;
a261 7
	pcireg_t data;
	int pin, line;

	data = pci_conf_read(tag, PCI_INTERRUPT_REG);

	pin = PCI_INTERRUPT_PIN(data);
	line = PCI_INTERRUPT_LINE(data);
d265 1
a265 1
		return 0;
d269 2
a270 2
		printf("pci_map_int: bad interrupt pin %d\n", pin);
		return NULL;
d288 2
a289 2
		printf("pci_map_int: no mapping for pin %c\n", '@@' + pin);
		return NULL;
d292 2
a293 2
			printf("pci_map_int: bad interrupt line %d\n", line);
			return NULL;
d296 1
a296 1
			printf("pci_map_int: changed line 2 to line 9\n");
d301 43
a343 3
#if 1
	printf("pci_map_int: pin %c mapped to line %d\n", '@@' + pin, line);
#endif
d345 1
a345 1
	return isa_intr_establish(line, IST_LEVEL, level, func, arg, what);
@


1.6
log
@Fix previous changes; accept and forward a device name, do not just use
a generic name "pci" for interrupt statistics
@
text
@d1 1
a1 1
/*	$NetBSD: pci_machdep.c,v 1.18 1995/12/24 02:30:34 mycroft Exp $	*/
a62 43
int pcimatch __P((struct device *, void *, void *));
void pciattach __P((struct device *, struct device *, void *));

struct cfdriver pcicd = {
	NULL, "pci", pcimatch, pciattach, DV_DULL, sizeof(struct device)
};

int
pcimatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{

	if (pci_mode_detect() == 0)
		return 0;
	return 1;
}

void
pciattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	int bus, device;

	printf(": configuration mode %d\n", pci_mode);

#if 0
	for (bus = 0; bus <= 255; bus++)
#else
	/*
	 * XXX
	 * Some current chipsets do wacky things with bus numbers > 0.
	 * This seems like a violation of protocol, but the PCI BIOS does
	 * allow one to query the maximum bus number, and eventually we
	 * should do so.
	 */
	for (bus = 0; bus <= 0; bus++)
#endif
		for (device = 0; device <= (pci_mode == 2 ? 15 : 31); device++)
			pci_attach_subdev(self, bus, device);
}

d232 1
a232 1
	if (reg < PCI_MAP_REG_START || reg >= PCI_MAP_REG_END || (reg & 3))
d237 2
a238 2
	if ((address & PCI_MAP_IO) == 0)
		panic("pci_map_io: attempt to I/O map a memory region");
d240 1
a240 1
	iobase = address & PCI_MAP_IO_ADDRESS_MASK;
d257 1
a257 1
	if (reg < PCI_MAP_REG_START || reg >= PCI_MAP_REG_END || (reg & 3))
d275 2
a276 2
	if ((address & PCI_MAP_IO) != 0)
		panic("pci_map_mem: attempt to memory map an I/O region");
d278 3
a280 3
	switch (address & PCI_MAP_MEMORY_TYPE_MASK) {
	case PCI_MAP_MEMORY_TYPE_32BIT:
	case PCI_MAP_MEMORY_TYPE_32BIT_1M:
d282 2
a283 2
	case PCI_MAP_MEMORY_TYPE_64BIT:
		printf("pci_map_mem: attempt to map 64-bit region\n");
d286 1
a286 1
		printf("pci_map_mem: reserved mapping type\n");
d290 2
a291 2
	pa = address & PCI_MAP_MEMORY_ADDRESS_MASK;
	size = -(mask & PCI_MAP_MEMORY_ADDRESS_MASK);
d315 1
a315 1
	cachable = !!(address & PCI_MAP_MEMORY_CACHABLE);
@


1.5
log
@Fix back wrong patches.
@
text
@d376 1
a376 1
pci_map_int(tag, level, func, arg)
d381 1
d433 1
a433 1
	return isa_intr_establish(line, IST_LEVEL, level, func, arg, "pci");
@


1.4
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d432 1
a432 1
	return isa_intr_establish(line, IST_LEVEL, level, func, arg);
@


1.3
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d376 1
a376 1
pci_map_int(tag, level, func, arg, what)
a380 1
	char *what;
d432 1
a432 1
	return isa_intr_establish(line, IST_LEVEL, level, func, arg, what);
@


1.2
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
@
text
@d376 1
a376 1
pci_map_int(tag, level, func, arg)
d381 1
d433 1
a433 1
	return isa_intr_establish(line, IST_LEVEL, level, func, arg);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: pci_machdep.c,v 1.17 1995/07/27 21:39:59 cgd Exp $	*/
a62 2
static isa_intrlevel	pcilevel_to_isa __P((pci_intrlevel level));

d378 1
a378 1
	pci_intrlevel level;
d432 1
a432 28
	return isa_intr_establish(line, ISA_IST_LEVEL, pcilevel_to_isa(level),
	    func, arg);
}

static isa_intrlevel
pcilevel_to_isa(level)
	pci_intrlevel level;
{

	switch (level) {
	case PCI_IPL_NONE:
		return (ISA_IPL_NONE);

	case PCI_IPL_BIO:
		return (ISA_IPL_BIO);

	case PCI_IPL_NET:
		return (ISA_IPL_NET);

	case PCI_IPL_TTY:
		return (ISA_IPL_TTY);

	case PCI_IPL_CLOCK:
		return (ISA_IPL_CLOCK);

	default:
		panic("pcilevel_to_isa: unknown level %d\n", level);
	}
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

