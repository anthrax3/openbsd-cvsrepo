head	1.28;
access;
symbols
	OPENBSD_6_0:1.28.0.8
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.4
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.8
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.6
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.2
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.25.0.10
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.8
	OPENBSD_5_0:1.25.0.6
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.4
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.23.0.8
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.10
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.6
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.28
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.27;
commitid	uzzBR7hz9ncd4O6G;

1.27
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2012.08.16.18.42.04;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.08.20.17.54;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2008.01.04.00.23.25;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2007.11.28.17.05.09;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.17.22.13.56;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.07.05.32.38;	author gwk;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.02.18.39.57;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.29.02.40.24;	author tom;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.26.00.27.43;	author gwk;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.12.23.14.27;	author dim;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.29.20.03.20;	author dim;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.29.16.03.00;	author dim;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.28.11.31.34;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.27.16.27.52;	author dim;	state Exp;
branches;
next	1.11;

1.11
date	2006.09.19.00.20.17;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.06.02.04.20;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.11.03.42.19;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2005.07.25.05.25.03;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.05.19.11.01;	author grange;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.05.18.58.40;	author grange;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.26.18.37.54;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.25.13.58.44;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.06.17.34.37;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.07.04.35.59;	author grange;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2004.05.06.19.47.03;	author grange;	state Exp;
branches;
next	;

1.2.2.1
date	2004.06.05.23.09.00;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2004.06.07.20.41.11;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.28
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@/*	$OpenBSD: ichpcib.c,v 1.27 2013/05/30 16:15:01 deraadt Exp $	*/
/*
 * Copyright (c) 2004 Alexander Yurchenko <grange@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Special driver for the Intel ICHx/ICHx-M LPC bridges that attaches
 * instead of pcib(4). In addition to the core pcib(4) functionality this
 * driver provides support for the Intel SpeedStep technology and
 * power management timer.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/sysctl.h>
#include <sys/timetc.h>

#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/pci/ichreg.h>

#include <machine/cpu.h>
#include <machine/cpufunc.h>

struct ichpcib_softc {
	struct device sc_dev;

	bus_space_tag_t sc_pm_iot;
	bus_space_handle_t sc_pm_ioh;
};

int	ichpcib_match(struct device *, void *, void *);
void	ichpcib_attach(struct device *, struct device *, void *);

int	ichss_present(struct pci_attach_args *);
void	ichss_setperf(int);

/* arch/i386/pci/pcib.c */
void    pcibattach(struct device *, struct device *, void *);

u_int	ichpcib_get_timecount(struct timecounter *tc);

struct timecounter ichpcib_timecounter = {
	ichpcib_get_timecount,	/* get_timecount */
	0,			/* no poll_pps */
	0xffffff,		/* counter_mask */
	3579545,		/* frequency */
	"ICHPM",		/* name */
	1000			/* quality */
};

struct cfattach ichpcib_ca = {
	sizeof(struct ichpcib_softc), ichpcib_match, ichpcib_attach
};

struct cfdriver ichpcib_cd = {
	NULL, "ichpcib", DV_DULL
};

#ifndef SMALL_KERNEL
static const char p4hint[] = "Mobile Intel(R) Pentium(R) 4";
struct ichpcib_softc *ichss_sc;
extern int setperf_prio;
#endif	/* !SMALL_KERNEL */

const struct pci_matchid ichpcib_devices[] = {
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_6300ESB_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_6321ESB_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801AA_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801AB_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801BA_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801BAM_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801CA_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801CAM_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801DB_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801DBM_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801E_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801EB_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801FB_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801FBM_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801GB_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801GBM_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801GH_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801GHM_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801H_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801HBM_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801IB_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801IH_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801IO_LPC },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801IR_LPC }
};

int
ichpcib_match(struct device *parent, void *match, void *aux)
{
	if (pci_matchbyid((struct pci_attach_args *)aux, ichpcib_devices,
	    sizeof(ichpcib_devices) / sizeof(ichpcib_devices[0])))
		return (2);	/* supersede pcib(4) */
	return (0);
}

void
ichpcib_attach(struct device *parent, struct device *self, void *aux)
{
	struct ichpcib_softc *sc = (struct ichpcib_softc *)self;
	struct pci_attach_args *pa = aux;
	pcireg_t cntl, pmbase;

	/* Check if power management I/O space is enabled */
	cntl = pci_conf_read(pa->pa_pc, pa->pa_tag, ICH_ACPI_CNTL);
	if ((cntl & ICH_ACPI_CNTL_ACPI_EN) == 0) {
		printf(": PM disabled");
		goto corepcib;
	}

	/* Map power management I/O space */
	sc->sc_pm_iot = pa->pa_iot;
	pmbase = pci_conf_read(pa->pa_pc, pa->pa_tag, ICH_PMBASE);
	if (bus_space_map(sc->sc_pm_iot, PCI_MAPREG_IO_ADDR(pmbase),
	    ICH_PMSIZE, 0, &sc->sc_pm_ioh) != 0)
		goto corepcib;

	/* Register new timecounter */
	ichpcib_timecounter.tc_priv = sc;
	tc_init(&ichpcib_timecounter);

	printf(": %s-bit timer at %lluHz",
	    (ichpcib_timecounter.tc_counter_mask == 0xffffffff ? "32" : "24"),
	    (unsigned long long)ichpcib_timecounter.tc_frequency);

#ifndef SMALL_KERNEL
	/* Check for SpeedStep */
	if (ichss_present(pa)) {
		printf(": SpeedStep");

		/* Enable SpeedStep */
		pci_conf_write(pa->pa_pc, pa->pa_tag, ICH_GEN_PMCON1,
		    pci_conf_read(pa->pa_pc, pa->pa_tag, ICH_GEN_PMCON1) |
			ICH_GEN_PMCON1_SS_EN);

		/* Hook into hw.setperf sysctl */
		ichss_sc = sc;
		cpu_setperf = ichss_setperf;
		setperf_prio = 2;
	}
#endif /* !SMALL_KERNEL */

corepcib:
	/* Provide core pcib(4) functionality */
	pcibattach(parent, self, aux);
}

#ifndef SMALL_KERNEL
int
ichss_present(struct pci_attach_args *pa)
{
	pcitag_t br_tag;
	pcireg_t br_id, br_class;
	struct cpu_info *ci;
	int family, model, stepping, brandid, ret;

	ret = 0;
	if (setperf_prio > 2)
		return (ret);

	ci = curcpu();
	family = (ci->ci_signature >> 8) & 15;
	model = (ci->ci_signature >> 4) & 15;
	stepping = ci->ci_signature & 15;
	brandid = cpu_miscinfo & 0xff; /* XXX should put this in ci */

	/*
	 * This form of SpeedStep works only with certain Intel processors.
	 * However, other processors can be coupled with these ICH southbridges
	 * causing false positives. This heuristic comes partly from the 
	 * Linux speedstep-ich driver.
	 */
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801DBM_LPC ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801CAM_LPC ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801BAM_LPC) {
		if (family == 15 && model == 2) {
			switch(stepping) {
			case 4:
				if (brandid == 14 || brandid == 15)
					ret = 1;
				break;
			case 7:
				if (brandid == 14)
					ret = 1;
				break;
			case 9:
				if (brandid == 14 && strncasecmp(cpu_model,
				    p4hint, sizeof(p4hint)-1) == 0) {
					ret = 1;
				}
				break;
			}
		} else if (family == 6 && model == 11) {
			if (stepping == 1)
				ret = 1;
		}

		/*
		 * Old revisions of the 82815 hostbridge found on
		 * Dell Inspirons 8000 and 8100 don't support
		 * SpeedStep.
		 */
		if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801BAM_LPC) {
			/*
			 * XXX: dev 0 func 0 is not always a hostbridge,
			 * should be converted to use pchb(4) hook.
			 */
			br_tag = pci_make_tag(pa->pa_pc, pa->pa_bus, 0, 0);
			br_id = pci_conf_read(pa->pa_pc, br_tag, PCI_ID_REG);
			br_class = pci_conf_read(pa->pa_pc, br_tag, PCI_CLASS_REG);

			if (PCI_PRODUCT(br_id) == PCI_PRODUCT_INTEL_82815_HB &&
			    PCI_REVISION(br_class) < 5) {
				ret = 0;
			}
		}
	}

	return (ret);
}

void
ichss_setperf(int level)
{
	struct ichpcib_softc *sc = ichss_sc;
	u_int8_t state, ostate, cntl;
	int s;

#ifdef DIAGNOSTIC
	if (sc == NULL) {
		printf("%s: no ichss_sc", __func__);
		return;
	}
#endif

	s = splhigh();
	state = bus_space_read_1(sc->sc_pm_iot, sc->sc_pm_ioh, ICH_PM_SS_CNTL);
	ostate = state;

	/* Only two states are available */
	if (level <= 50)
		state |= ICH_PM_SS_STATE_LOW;
	else
		state &= ~ICH_PM_SS_STATE_LOW;

	/*
	 * An Intel SpeedStep technology transition _always_ occur on
	 * writes to the ICH_PM_SS_CNTL register, even if the value
	 * written is the same as the previous value. So do the write
	 * only if the state has changed.
	 */
	if (state != ostate) {
		/* Disable bus mastering arbitration */
		cntl = bus_space_read_1(sc->sc_pm_iot, sc->sc_pm_ioh,
		    ICH_PM_CNTL);
		bus_space_write_1(sc->sc_pm_iot, sc->sc_pm_ioh, ICH_PM_CNTL,
		    cntl | ICH_PM_ARB_DIS);

		/* Do the transition */
		bus_space_write_1(sc->sc_pm_iot, sc->sc_pm_ioh, ICH_PM_SS_CNTL,
		    state);

		/* Restore bus mastering arbitration state */
		bus_space_write_1(sc->sc_pm_iot, sc->sc_pm_ioh, ICH_PM_CNTL,
		    cntl);

		if (update_cpuspeed != NULL)
			update_cpuspeed();
	}
	splx(s);
}
#endif	/* !SMALL_KERNEL */

u_int
ichpcib_get_timecount(struct timecounter *tc)
{
	struct ichpcib_softc *sc = tc->tc_priv;
	u_int u1, u2, u3;

	u2 = bus_space_read_4(sc->sc_pm_iot, sc->sc_pm_ioh, ICH_PM_TMR);
	u3 = bus_space_read_4(sc->sc_pm_iot, sc->sc_pm_ioh, ICH_PM_TMR);
	do {
		u1 = u2;
		u2 = u3;
		u3 = bus_space_read_4(sc->sc_pm_iot, sc->sc_pm_ioh,
		    ICH_PM_TMR);
	} while (u1 > u2 || u2 > u3);

	return (u2);
}
@


1.27
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.26 2012/08/16 18:42:04 tedu Exp $	*/
a27 1
#include <sys/proc.h>
@


1.26
log
@we are past the point where timecounters may disappear
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.25 2010/07/08 20:17:54 deraadt Exp $	*/
d71 1
a71 5
	sizeof(struct ichpcib_softc),
	ichpcib_match,
	ichpcib_attach,
	NULL,
	config_activate_children
@


1.25
log
@use config_activate_children to get down to the isa bus activation code
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.24 2010/04/20 22:05:41 tedu Exp $	*/
a29 1
#ifdef __HAVE_TIMECOUNTER
a30 1
#endif
a58 1
#ifdef __HAVE_TIMECOUNTER
a68 1
#endif	/* __HAVE_TIMECOUNTER */
a144 1
#ifdef __HAVE_TIMECOUNTER
a151 1
#endif	/* __HAVE_TIMECOUNTER */
a300 1
#ifdef __HAVE_TIMECOUNTER
a317 1
#endif	/* __HAVE_TIMECOUNTER */
@


1.24
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.23 2008/01/04 00:23:25 kettenis Exp $	*/
d77 3
a79 1
	ichpcib_attach
@


1.23
log
@Clean up Intel host bridge PCI IDs.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.22 2007/11/28 17:05:09 tedu Exp $	*/
d28 1
@


1.22
log
@quite a bit of simplification by removing cpu classes.
also assume that 386 cpus are really unknown, and promote them to 486
instead of panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.21 2007/10/17 22:13:56 brad Exp $	*/
d242 1
a242 1
			if (PCI_PRODUCT(br_id) == PCI_PRODUCT_INTEL_82815_FULL_HUB &&
@


1.21
log
@Add the Intel ICH9 chipset.

Tested by damien@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.20 2007/09/07 05:32:38 gwk Exp $	*/
a296 1
#ifdef I686_CPU
a298 1
#endif
@


1.20
log
@Modify the heuristic for detection of speedstep to recognize a compatible
mobile Intel Pentium 3 as found in Dell c610 fixes pr5565.

ok beck, toby
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.19 2007/06/02 18:39:57 jsg Exp $	*/
d109 5
a113 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801HBM_LPC }
@


1.19
log
@Match on ICH8M.
Tested by Daniel Dickman <didickman@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.18 2007/05/29 02:40:24 tom Exp $	*/
d181 1
a181 1
	int family, model, stepping, brandid;
d183 1
d185 1
a185 1
		return (0);
d194 4
a197 6
	 * This form of SpeedStep works only on Intel Mobile Pentium 4.
	 * Intel Celeron processors don't support it.  However, they
	 * can be coupled with ICH southbridges that do, causing false
	 * positives.  So we ensure that we are running on Intel Mobile
	 * Pentium 4.
	 * This heuristic comes from the Linux speedstep-ich driver.
d199 24
a222 6
	if (!(family == 15 && model == 2 &&
	    ((stepping == 4 && (brandid == 14 || brandid == 15)) ||
	    (stepping == 7 && brandid == 14) ||
	    (stepping == 9 && (brandid == 14 || strncasecmp(cpu_model, p4hint,
	    sizeof(p4hint) - 1) == 0)))))
		return (0);
a223 4
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801DBM_LPC ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801CAM_LPC)
		return (1);
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801BAM_LPC) {
d229 14
a242 12
		/*
		 * XXX: dev 0 func 0 is not always a hostbridge,
		 * should be converted to use pchb(4) hook.
		 */
		br_tag = pci_make_tag(pa->pa_pc, pa->pa_bus, 0, 0);
		br_id = pci_conf_read(pa->pa_pc, br_tag, PCI_ID_REG);
		br_class = pci_conf_read(pa->pa_pc, br_tag, PCI_CLASS_REG);

		if (PCI_PRODUCT(br_id) == PCI_PRODUCT_INTEL_82815_FULL_HUB &&
		    PCI_REVISION(br_class) < 5)
			return (0);
		return (1);
d245 1
a245 1
	return (0);
@


1.18
log
@Fix compilation of kernels without I686_CPU: piixpcib is always
needed (not just for I686_CPU), but it and ichpcib only call the
update_cpuspeed functions for I686_CPU.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.17 2007/03/26 00:27:43 gwk Exp $	*/
d108 2
a109 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801H_LPC }
@


1.17
log
@ichss_cookie is a bad name, and should not be a void pointer.
Spotted by Stefan Sperling <stsp AT tsp.in-berlin.de> when reviewing
his piix speedstep diff.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.16 2006/12/12 23:14:27 dim Exp $	*/
d277 1
d280 1
@


1.16
log
@Complete gwk's previous patch to stop setperf methods from returning
errors to userland: make all cpu_setperf functions return void.

Tested by many, ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.15 2006/11/29 20:03:20 dim Exp $	*/
d85 1
a85 1
static void *ichss_cookie;	/* XXX */
d162 1
a162 1
		ichss_cookie = sc;
d235 1
a235 1
	struct ichpcib_softc *sc = ichss_cookie;
d241 1
a241 1
		printf("%s: no cookie", __func__);
@


1.15
log
@Remove all the extern cpu_{id,model,whatever} declarations from most
stuff in arch/i386/i386.  This should prevent more screwups like the
one I did before in ichpcib.c...

ok dlg@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.14 2006/11/29 16:03:00 dim Exp $	*/
d55 1
a55 1
int	ichss_setperf(int);
d232 1
a232 1
int
d242 1
a242 1
		return (EFAULT);
a280 2

	return (0);
@


1.14
log
@Fix cpu_model string screwup.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.13 2006/11/28 11:31:34 deraadt Exp $	*/
a83 1
extern char cpu_model[];
@


1.13
log
@acpi may steal the timer and speedstep functionality, in which case we
cannot io map the device.  rest of the attach() functionality is still
safely intact.  we simply do not have to warn about mapping failing.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.12 2006/11/27 16:27:52 dim Exp $	*/
d84 1
a84 1
extern char *cpu_model;
@


1.12
log
@Only use the ichpcib speedstep feature if we're running on a (Mobile) Pentium 4,
since Celerons don't support it.

prodded by gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.11 2006/09/19 00:20:17 brad Exp $	*/
d139 1
a139 2
	    ICH_PMSIZE, 0, &sc->sc_pm_ioh) != 0) {
		printf(": failed to map I/O space");
a140 1
	}
@


1.11
log
@add 82801GHM and 82801H
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.10 2006/08/06 02:04:20 brad Exp $	*/
d41 3
d84 2
d162 1
a162 1
		    ICH_GEN_PMCON1_SS_EN);
d169 1
a169 1
#endif	/* !SMALL_KERNEL */
d182 2
d186 21
@


1.10
log
@add the Intel 6321ESB LPC
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.9 2005/12/11 03:42:19 brad Exp $	*/
d103 2
@


1.9
log
@add a few Intel PCI-ISA bridges.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.8 2005/07/25 05:25:03 jsg Exp $	*/
d87 1
@


1.8
log
@ichpcib(4) support for 82801FB (ICH6) as found in marco@@'s Dell d810.
Tested by and ok marco@@, ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.7 2004/10/05 19:11:01 grange Exp $	*/
d86 1
d95 1
d98 4
a101 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_6300ESB_LPC }
@


1.7
log
@Support for 6300ESB (timecounter, not SpeedStep of course).
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.6 2004/10/05 18:58:40 grange Exp $	*/
d95 1
@


1.6
log
@- check if pm space is enabled
- switch to pci_matchbyid()
- minor nits
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.5 2004/09/26 18:37:54 grange Exp $	*/
d94 2
a95 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801EB_LPC }
@


1.5
log
@Minor tweaks to unify with other timecounters.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.4 2004/09/25 13:58:44 grange Exp $	*/
a34 1
#include <dev/pci/pcidevs.h>
d37 1
d85 12
d100 3
a102 22
	struct pci_attach_args *pa = aux;

	if (PCI_CLASS(pa->pa_class) != PCI_CLASS_BRIDGE ||
	    PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_BRIDGE_ISA) {
		return (0);
	}

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL) {
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_INTEL_82801AA_LPC:	/* ICH */
		case PCI_PRODUCT_INTEL_82801AB_LPC:	/* ICH0 */
		case PCI_PRODUCT_INTEL_82801BA_LPC:	/* ICH2 */
		case PCI_PRODUCT_INTEL_82801BAM_LPC:	/* ICH2-M */
		case PCI_PRODUCT_INTEL_82801CA_LPC:	/* ICH3-S */
		case PCI_PRODUCT_INTEL_82801CAM_LPC:	/* ICH3-M */
		case PCI_PRODUCT_INTEL_82801DB_LPC:	/* ICH4 */
		case PCI_PRODUCT_INTEL_82801DBM_LPC:	/* ICH4-M */
		case PCI_PRODUCT_INTEL_82801EB_LPC:	/* ICH5 */
			return (2);	/* supersede pcib(4) */
		}
	}

d111 8
a118 1
	pcireg_t pmbase;
d130 1
a130 1
	/* Hook into the kern_tc */
d133 4
@


1.4
log
@Timecounter support for Intel ICH chips, not enabled
on any platform yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.3 2004/06/06 17:34:37 grange Exp $	*/
d64 2
a65 2
	14318180 / 4,		/* frequency */
	"ICH",			/* name */
@


1.3
log
@Don't touch any hardware registers while fetching hw.cpuspeed and
just return current pentium_mhz value. Update this value in
all hw.setperf hoos either via its own private methods or using
global update_cpuspeed hook, if registered.
Also implement update_cpuspeed hook for Pentium 3.

Tested by millert@@, Gabriel Kihlman <gk@@stacken.kth.se> and me on
various i386 machines.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.2 2004/05/07 04:35:59 grange Exp $	*/
d21 2
a22 1
 * driver provides support for the Intel SpeedStep technology.
d29 3
d57 13
a115 1
#ifndef SMALL_KERNEL
d129 7
d150 1
a152 1
#endif	/* !SMALL_KERNEL */
d246 20
@


1.2
log
@This chunk was not supposed to be commited now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichpcib.c,v 1.1 2004/05/06 19:47:03 grange Exp $	*/
d214 3
@


1.2.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2.2.2
log
@sync to head
@
text
@a213 3

		if (update_cpuspeed != NULL)
			update_cpuspeed();
@


1.1
log
@Move speedstep code to a separate ichpcib(4) driver.
It attaches instead of pcib(4) and provides its usual
functionality (attaching isa bus) by calling pcibattach()
in the attach routine.

ok miod deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a213 3

		if (update_cpuspeed != NULL)
			update_cpuspeed();
@

