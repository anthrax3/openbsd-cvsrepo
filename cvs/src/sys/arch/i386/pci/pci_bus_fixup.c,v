head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.42
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.38
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.40
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.32
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.36
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.34
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.30
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.28
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.26
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.24
	OPENBSD_5_0:1.9.0.22
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.20
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.18
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.14
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.16
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.12
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.26
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.24
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.22
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.20
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.18
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.16
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.14
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.12
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.10
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.8.0.8
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_9_BASE:1.8
	SMP:1.8.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.9
date	2006.08.18.22.18.18;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.27.04.59.40;	author mickey;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.01.24.23.16.14;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.31.18.56.42;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.08.19.12.47;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.07.22.22.57;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.28.03.37.59;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.27.08.35.21;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.26.22.38.37;	author mickey;	state Exp;
branches;
next	;

1.8.2.1
date	2001.04.18.16.08.27;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Don't renumber the PCI bus if we don't need to.  Fixes some machines (Dell
PowerEdge 2900, 2950) that otherwise lock up at the end of autoconf.

ok dlg@@, marco@@
@
text
@/*	$OpenBSD: pci_bus_fixup.c,v 1.8 2001/01/27 04:59:40 mickey Exp $	*/
/*	$NetBSD: pci_bus_fixup.c,v 1.1 1999/11/17 07:32:58 thorpej Exp $  */

/*
 * Copyright (c) 1999, by UCHIYAMA Yasushi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the developer may NOT be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
 */

/*
 * PCI bus renumbering support.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/ppbreg.h>

#include <i386/pci/pcibiosvar.h>

int	pci_bus_check(pci_chipset_tag_t, int);
int	pci_bus_assign(pci_chipset_tag_t, int);
void	pcibus_print_devid(pci_chipset_tag_t, pcitag_t);

int
pci_bus_check(pci_chipset_tag_t pc, int bus)
{
	int device, maxdevs, function, nfuncs, bus_max, bus_sub;
	const struct pci_quirkdata *qd;
	pcireg_t reg;
	pcitag_t tag;

	bus_max = bus;

	maxdevs = pci_bus_maxdevs(pc, bus);
	for (device = 0; device < maxdevs; device++) {
		tag = pci_make_tag(pc, bus, device, 0);
		reg = pci_conf_read(pc, tag, PCI_ID_REG);

		/* can't be that many */
		if (bus_max == 255)
			break;

		/* Invalid vendor ID value? */
		if (PCI_VENDOR(reg) == PCI_VENDOR_INVALID)
			continue;
		/* XXX Not invalid, but we've done this ~forever. */
		if (PCI_VENDOR(reg) == 0)
			continue;

		qd = pci_lookup_quirkdata(PCI_VENDOR(reg), PCI_PRODUCT(reg));

		reg = pci_conf_read(pc, tag, PCI_BHLC_REG);
		if (PCI_HDRTYPE_MULTIFN(reg) ||
		    (qd != NULL &&
		     (qd->quirks & PCI_QUIRK_MULTIFUNCTION) != 0))
			nfuncs = 8;
		else
			nfuncs = 1;

		for (function = 0; function < nfuncs; function++) {
			tag = pci_make_tag(pc, bus, device, function);
			reg = pci_conf_read(pc, tag, PCI_ID_REG);

			/* Invalid vendor ID value? */
			if (PCI_VENDOR(reg) == PCI_VENDOR_INVALID)
				continue;
			/* XXX Not invalid, but we've done this ~forever. */
			if (PCI_VENDOR(reg) == 0)
				continue;

			reg = pci_conf_read(pc, tag, PCI_CLASS_REG);
			if (PCI_CLASS(reg) == PCI_CLASS_BRIDGE &&
			    (PCI_SUBCLASS(reg) == PCI_SUBCLASS_BRIDGE_PCI ||
			     PCI_SUBCLASS(reg) == PCI_SUBCLASS_BRIDGE_CARDBUS)) {

				reg = pci_conf_read(pc, tag, PPB_REG_BUSINFO);
				if (PPB_BUSINFO_PRIMARY(reg) != bus) {
					if (pcibios_flags & PCIBIOS_VERBOSE) {
						pcibus_print_devid(pc, tag);
						printf("Mismatched primary bus: "
						    "primary %d, secondary %d, "
						    "subordinate %d\n",
						    PPB_BUSINFO_PRIMARY(reg),
						    PPB_BUSINFO_SECONDARY(reg),
						    PPB_BUSINFO_SUBORDINATE(reg));
					}
					return (-1);
				}
				if (PPB_BUSINFO_SECONDARY(reg) <= bus) {
					if (pcibios_flags & PCIBIOS_VERBOSE) {
						pcibus_print_devid(pc, tag);
						printf("Incorrect secondary bus: "
						    "primary %d, secondary %d, "
						    "subordinate %d\n",
						    PPB_BUSINFO_PRIMARY(reg),
						    PPB_BUSINFO_SECONDARY(reg),
						    PPB_BUSINFO_SUBORDINATE(reg));
					}
					return (-1);
				}

				/* Scan subordinate bus. */
				bus_sub = pci_bus_check(pc,
				    PPB_BUSINFO_SECONDARY(reg));
				if (bus_sub == -1)
					return (-1);

				if (PPB_BUSINFO_SUBORDINATE(reg) < bus_sub) {
					if (pcibios_flags & PCIBIOS_VERBOSE) {
						pcibus_print_devid(pc, tag);
						printf("Incorrect subordinate bus %d: "
						    "primary %d, secondary %d, "
						    "subordinate %d\n", bus_sub,
						    PPB_BUSINFO_PRIMARY(reg),
						    PPB_BUSINFO_SECONDARY(reg),
						    PPB_BUSINFO_SUBORDINATE(reg));
					}
					return (-1);
				}

				bus_max = (bus_sub > bus_max) ?
				    bus_sub : bus_max;
			}
		}
	}

	return (bus_max);	/* last # of subordinate bus */
}

int
pci_bus_assign(pci_chipset_tag_t pc, int bus)
{
	static int bridge_cnt;
	int bridge, device, maxdevs, function, nfuncs, bus_max, bus_sub;
	const struct pci_quirkdata *qd;
	pcireg_t reg;
	pcitag_t tag;

	bus_max = bus;

	maxdevs = pci_bus_maxdevs(pc, bus);
	for (device = 0; device < maxdevs; device++) {
		tag = pci_make_tag(pc, bus, device, 0);
		reg = pci_conf_read(pc, tag, PCI_ID_REG);

		/* can't be that many */
		if (bus_max == 255)
			break;

		/* Invalid vendor ID value? */
		if (PCI_VENDOR(reg) == PCI_VENDOR_INVALID)
			continue;
		/* XXX Not invalid, but we've done this ~forever. */
		if (PCI_VENDOR(reg) == 0)
			continue;

		qd = pci_lookup_quirkdata(PCI_VENDOR(reg), PCI_PRODUCT(reg));

		reg = pci_conf_read(pc, tag, PCI_BHLC_REG);
		if (PCI_HDRTYPE_MULTIFN(reg) ||
		    (qd != NULL &&
		     (qd->quirks & PCI_QUIRK_MULTIFUNCTION) != 0))
			nfuncs = 8;
		else
			nfuncs = 1;

		for (function = 0; function < nfuncs; function++) {
			tag = pci_make_tag(pc, bus, device, function);
			reg = pci_conf_read(pc, tag, PCI_ID_REG);

			/* Invalid vendor ID value? */
			if (PCI_VENDOR(reg) == PCI_VENDOR_INVALID)
				continue;
			/* XXX Not invalid, but we've done this ~forever. */
			if (PCI_VENDOR(reg) == 0)
				continue;

			reg = pci_conf_read(pc, tag, PCI_CLASS_REG);
			if (PCI_CLASS(reg) == PCI_CLASS_BRIDGE &&
			    (PCI_SUBCLASS(reg) == PCI_SUBCLASS_BRIDGE_PCI ||
			     PCI_SUBCLASS(reg) == PCI_SUBCLASS_BRIDGE_CARDBUS)) {
				/* Assign the bridge's secondary bus #. */
				bus_max++;

				reg = pci_conf_read(pc, tag, PPB_REG_BUSINFO);
				reg &= 0xff000000;
				reg |= bus | (bus_max << 8) | (0xff << 16);
				pci_conf_write(pc, tag, PPB_REG_BUSINFO, reg);

				/* Scan subordinate bus. */
				bus_sub = pci_bus_assign(pc, bus_max);

				/* Configure the bridge. */
				reg &= 0xff000000;
				reg |= bus | (bus_max << 8) | (bus_sub << 16);
				pci_conf_write(pc, tag, PPB_REG_BUSINFO, reg);

				if (pcibios_flags & PCIBIOS_VERBOSE) {
					/* Assign the bridge #. */
					bridge = bridge_cnt++;

					printf("PCI bridge %d: primary %d, "
					    "secondary %d, subordinate %d\n",
					    bridge, bus, bus_max, bus_sub);
				}

				/* Next bridge's secondary bus #. */
				bus_max = (bus_sub > bus_max) ?
				    bus_sub : bus_max;
			}
		}
	}

	return (bus_max);	/* last # of subordinate bus */
}

int
pci_bus_fixup(pci_chipset_tag_t pc, int bus)
{
	int bus_max;

	bus_max = pci_bus_check(pc, bus);
	if (bus_max != -1)
		return (bus_max);

	if (pcibios_flags & PCIBIOS_VERBOSE)
		printf("PCI bus renumbering needed\n");
	return pci_bus_assign(pc, bus);
}

void
pcibus_print_devid(pci_chipset_tag_t pc, pcitag_t tag)
{
	int bus, device, function;	
	pcireg_t id;

	id = pci_conf_read(pc, tag, PCI_ID_REG);
	pci_decompose_tag(pc, tag, &bus, &device, &function);
	printf("%03d:%02d:%d %04x:%04x\n", bus, device, function, 
	       PCI_VENDOR(id), PCI_PRODUCT(id));
}
@


1.8
log
@change interrupt routing strategy from simple
run through the devices and programming the icu
and pci headers before real pci bus autoconf starts
and include all devices present on all pci busses,
to a per attached device routing in pci_intr_map().
this solves several cases of premature interrupts hanging
system due to absent interrupt handlers during autoconf.
10x for testing: millert@@ krw@@ aaron@@ chris@@ tholo@@ brad@@ jason@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_bus_fixup.c,v 1.7 2001/01/24 23:16:14 mickey Exp $	*/
d47 110
d158 1
a158 3
pci_bus_fixup(pc, bus)
	pci_chipset_tag_t pc;
	int bus;
a166 1
	bus_sub = 0;
a168 1

d218 1
a218 1
				bus_sub = pci_bus_fixup(pc, bus_max);
d242 26
@


1.8.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_bus_fixup.c,v 1.8 2001/01/27 04:59:40 mickey Exp $	*/
@


1.7
log
@elliminate pci_bus_fixup.h by moving
pci_bus_fixup() proto into pcibiosvar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_bus_fixup.c,v 1.6 2000/10/31 18:56:42 deraadt Exp $	*/
a51 1
#ifdef PCIBIOSVERBOSE
d53 1
a53 3
	int bridge;
#endif
	int device, maxdevs, function, nfuncs, bus_max, bus_sub;
d119 8
a126 8
#ifdef PCIBIOSVERBOSE
				/* Assign the bridge #. */
				bridge = bridge_cnt++;

				printf("PCI bridge %d: primary %d, "
				    "secondary %d, subordinate %d\n",
				    bridge, bus, bus_max, bus_sub);
#endif
@


1.6
log
@rename pcibios.h to pcibiosvar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_bus_fixup.c,v 1.5 2000/08/08 19:12:47 mickey Exp $	*/
a44 1
#include <i386/pci/pci_bus_fixup.h>
@


1.5
log
@sync w/ netbsd almost -current code (;
fixes quite a few problems.
adds new option PCIBIOS_ADDR_FIXUP.
numerous extra fixes by me, also pointed out by other ppl,
such as avoid panics, ifdef on pciverbose, not diagnostic,
some other smaller knits; some have been forwarded back
to netbsd developers, some will go soon too.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_bus_fixup.c,v 1.4 2000/04/07 22:22:57 aaron Exp $	*/
d46 1
a46 1
#include <i386/pci/pcibios.h>
@


1.4
log
@Need <sys/device.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_bus_fixup.c,v 1.3 2000/03/28 03:37:59 mickey Exp $	*/
d53 1
a53 1
	static int bus_total;
d55 3
a57 1
	int device, maxdevs, function, nfuncs, bridge, bus_max, bus_sub;
a64 3
	if (++bus_total > 256)
		panic("pci_bus_fixup: more than 256 PCI busses?");

d71 4
a106 3
				/* Assign the bridge #. */
				bridge = bridge_cnt++;

d124 3
@


1.3
log
@fix netbsd rcsids up.
also, from the 3rd try make proper openbsd rcsids, rediculous
3 commits just to add proper openbsd rcsids.
i think someone forgot to _look_ at the diffs before commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_bus_fixup.c,v 1.2 2000/03/27 08:35:21 brad Exp $	*/
d36 1
@


1.2
log
@add missing OpenBSD RCS IDs
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD$	*/
@


1.1
log
@from netbsd: pci interrupt routing code.
also, change a few pcidevs names to match netbsd (and more descriptive).
tested on a bunch of laptops, helps resolving 'pin X unmapped'
problems for (usually) usb and cardbus cntrollers.
@
text
@d1 1
@

