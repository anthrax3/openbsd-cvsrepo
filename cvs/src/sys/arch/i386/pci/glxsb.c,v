head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.4
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.25.0.4
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.24.0.4
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.2
	OPENBSD_5_0:1.23.0.4
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7;
locks; strict;
comment	@ * @;


1.31
date	2017.02.07.17.25.45;	author patrick;	state Exp;
branches;
next	1.30;
commitid	dMJlqKWYCJoMV7JN;

1.30
date	2015.09.08.08.33.26;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	t59bsVfEDCZAKIKs;

1.29
date	2014.12.09.06.58.28;	author doug;	state Exp;
branches;
next	1.28;
commitid	yWAxzpQP2PPpYlfT;

1.28
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.27;
commitid	uKVPYMN2MLxdZxzH;

1.27
date	2013.10.29.21.44.50;	author mikeb;	state Exp;
branches;
next	1.26;

1.26
date	2013.08.25.22.50.04;	author mikeb;	state Exp;
branches;
next	1.25;

1.25
date	2012.12.05.23.20.12;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2012.01.13.09.53.24;	author mikeb;	state Exp;
branches;
next	1.23;

1.23
date	2011.01.12.17.15.23;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2011.01.11.15.42.05;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2010.12.15.23.34.23;	author mikeb;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.20.02.46.50;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.02.02.40.15;	author blambert;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2010.01.10.12.43.07;	author markus;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2009.10.30.18.18.09;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.05.07.44.07;	author blambert;	state Exp;
branches;
next	1.15;

1.15
date	2008.09.19.10.44.11;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.09.07.07.15;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2007.12.09.21.30.24;	author hshoexer;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.14.19.10.44;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.18.22.02.18;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.10.23.04.46;	author henric;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.07.15.00.19;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.07.09.48.23;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2007.02.12.14.31.45;	author tom;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.19.19.59.09;	author tom;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.02.22.51.49;	author tom;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.19.13.41.27;	author tom;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.19.02.08.10;	author tom;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.17.16.06.16;	author tom;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.26.08.37.14;	author tom;	state Exp;
branches;
next	;

1.18.2.1
date	2010.12.20.14.08.39;	author jasper;	state Exp;
branches;
next	;

1.19.2.1
date	2010.12.17.16.25.14;	author jasper;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Reduce the per-packet allocation costs for crypto operations (cryptop)
by pre-allocating two cryptodesc objects and storing them in an array
instead of a linked list.  If more than two cryptodesc objects are
required use mallocarray to fetch them.  Adapt the drivers to the new
API.

This change results in one pool-get per ESP packet instead of three.
It also simplifies softraid crypto where more cryptodesc objects are
allocated than used.

From, with and ok markus@@, ok bluhm@@
"looks sane" mpi@@
@
text
@/*	$OpenBSD: glxsb.c,v 1.30 2015/09/08 08:33:26 deraadt Exp $	*/

/*
 * Copyright (c) 2006 Tom Cosgrove <tom@@openbsd.org>
 * Copyright (c) 2003, 2004 Theo de Raadt
 * Copyright (c) 2003 Jason Wright
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Driver for the security block on the AMD Geode LX processors
 * http://www.amd.com/files/connectivitysolutions/geode/geode_lx/33234d_lx_ds.pdf
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/types.h>
#include <sys/timeout.h>

#include <machine/bus.h>
#include <machine/cpufunc.h>

#include <dev/rndvar.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#ifdef CRYPTO
#include <crypto/cryptodev.h>
#include <crypto/rijndael.h>
#include <crypto/xform.h>
#include <crypto/cryptosoft.h>
#endif

#define SB_GLD_MSR_CAP		0x58002000	/* RO - Capabilities */
#define SB_GLD_MSR_CONFIG	0x58002001	/* RW - Master Config */
#define SB_GLD_MSR_SMI		0x58002002	/* RW - SMI */
#define SB_GLD_MSR_ERROR	0x58002003	/* RW - Error */
#define SB_GLD_MSR_PM		0x58002004	/* RW - Power Mgmt */
#define SB_GLD_MSR_DIAG		0x58002005	/* RW - Diagnostic */
#define SB_GLD_MSR_CTRL		0x58002006	/* RW - Security Block Cntrl */

						/* For GLD_MSR_CTRL: */
#define SB_GMC_DIV0		0x0000		/* AES update divisor values */
#define SB_GMC_DIV1		0x0001
#define SB_GMC_DIV2		0x0002
#define SB_GMC_DIV3		0x0003
#define SB_GMC_DIV_MASK		0x0003
#define SB_GMC_SBI		0x0004		/* AES swap bits */
#define SB_GMC_SBY		0x0008		/* AES swap bytes */
#define SB_GMC_TW		0x0010		/* Time write (EEPROM) */
#define SB_GMC_T_SEL0		0x0000		/* RNG post-proc: none */
#define SB_GMC_T_SEL1		0x0100		/* RNG post-proc: LFSR */
#define SB_GMC_T_SEL2		0x0200		/* RNG post-proc: whitener */
#define SB_GMC_T_SEL3		0x0300		/* RNG LFSR+whitener */
#define SB_GMC_T_SEL_MASK	0x0300
#define SB_GMC_T_NE		0x0400		/* Noise (generator) Enable */
#define SB_GMC_T_TM		0x0800		/* RNG test mode */
						/*     (deterministic) */

/* Security Block configuration/control registers (offsets from base) */

#define SB_CTL_A		0x0000		/* RW - SB Control A */
#define SB_CTL_B		0x0004		/* RW - SB Control B */
#define SB_AES_INT		0x0008		/* RW - SB AES Interrupt */
#define SB_SOURCE_A		0x0010		/* RW - Source A */
#define SB_DEST_A		0x0014		/* RW - Destination A */
#define SB_LENGTH_A		0x0018		/* RW - Length A */
#define SB_SOURCE_B		0x0020		/* RW - Source B */
#define SB_DEST_B		0x0024		/* RW - Destination B */
#define SB_LENGTH_B		0x0028		/* RW - Length B */
#define SB_WKEY			0x0030		/* WO - Writable Key 0-3 */
#define SB_WKEY_0		0x0030		/* WO - Writable Key 0 */
#define SB_WKEY_1		0x0034		/* WO - Writable Key 1 */
#define SB_WKEY_2		0x0038		/* WO - Writable Key 2 */
#define SB_WKEY_3		0x003C		/* WO - Writable Key 3 */
#define SB_CBC_IV		0x0040		/* RW - CBC IV 0-3 */
#define SB_CBC_IV_0		0x0040		/* RW - CBC IV 0 */
#define SB_CBC_IV_1		0x0044		/* RW - CBC IV 1 */
#define SB_CBC_IV_2		0x0048		/* RW - CBC IV 2 */
#define SB_CBC_IV_3		0x004C		/* RW - CBC IV 3 */
#define SB_RANDOM_NUM		0x0050		/* RW - Random Number */
#define SB_RANDOM_NUM_STATUS	0x0054		/* RW - Random Number Status */
#define SB_EEPROM_COMM		0x0800		/* RW - EEPROM Command */
#define SB_EEPROM_ADDR		0x0804		/* RW - EEPROM Address */
#define SB_EEPROM_DATA		0x0808		/* RW - EEPROM Data */
#define SB_EEPROM_SEC_STATE	0x080C		/* RW - EEPROM Security State */

						/* For SB_CTL_A and _B */
#define SB_CTL_ST		0x0001		/* Start operation (enc/dec) */
#define SB_CTL_ENC		0x0002		/* Encrypt (0 is decrypt) */
#define SB_CTL_DEC		0x0000		/* Decrypt */
#define SB_CTL_WK		0x0004		/* Use writable key (we set) */
#define SB_CTL_DC		0x0008		/* Destination coherent */
#define SB_CTL_SC		0x0010		/* Source coherent */
#define SB_CTL_CBC		0x0020		/* CBC (0 is ECB) */

						/* For SB_AES_INT */
#define SB_AI_DISABLE_AES_A	0x00001		/* Disable AES A compl int */
#define SB_AI_ENABLE_AES_A	0x00000		/* Enable AES A compl int */
#define SB_AI_DISABLE_AES_B	0x00002		/* Disable AES B compl int */
#define SB_AI_ENABLE_AES_B	0x00000		/* Enable AES B compl int */
#define SB_AI_DISABLE_EEPROM	0x00004		/* Disable EEPROM op comp int */
#define SB_AI_ENABLE_EEPROM	0x00000		/* Enable EEPROM op compl int */
#define SB_AI_AES_A_COMPLETE	0x10000		/* AES A operation complete */
#define SB_AI_AES_B_COMPLETE	0x20000		/* AES B operation complete */
#define SB_AI_EEPROM_COMPLETE	0x40000		/* EEPROM operation complete */

#define SB_RNS_TRNG_VALID	0x0001		/* in SB_RANDOM_NUM_STATUS */

#define SB_MEM_SIZE		0x0810		/* Size of memory block */

#define SB_AES_ALIGN		0x0010		/* Source and dest buffers */
						/* must be 16-byte aligned */
#define SB_AES_BLOCK_SIZE	0x0010

/*
 * The Geode LX security block AES acceleration doesn't perform scatter-
 * gather: it just takes source and destination addresses.  Therefore the
 * plain- and ciphertexts need to be contiguous.  To this end, we allocate
 * a buffer for both, and accept the overhead of copying in and out.  If
 * the number of bytes in one operation is bigger than allowed for by the
 * buffer (buffer is twice the size of the max length, as it has both input
 * and output) then we have to perform multiple encryptions/decryptions.
 */
#define GLXSB_MAX_AES_LEN	16384

#ifdef CRYPTO
struct glxsb_dma_map {
	bus_dmamap_t		dma_map;
	bus_dma_segment_t	dma_seg;
	int			dma_nsegs;
	int			dma_size;
	caddr_t			dma_vaddr;
	uint32_t		dma_paddr;
};
struct glxsb_session {
	uint32_t	ses_key[4];
	int		ses_klen;
	int		ses_used;
	struct swcr_data *ses_swd_auth;
	struct swcr_data *ses_swd_enc;
};
#endif /* CRYPTO */

struct glxsb_softc {
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	struct timeout		sc_to;

#ifdef CRYPTO
	bus_dma_tag_t		sc_dmat;
	struct glxsb_dma_map	sc_dma;
	int32_t			sc_cid;
	int			sc_nsessions;
	struct glxsb_session	*sc_sessions;
#endif /* CRYPTO */

	uint64_t		save_gld_msr;	
};

int	glxsb_match(struct device *, void *, void *);
void	glxsb_attach(struct device *, struct device *, void *);
int	glxsb_activate(struct device *, int);
void	glxsb_rnd(void *);

struct cfattach glxsb_ca = {
	sizeof(struct glxsb_softc), glxsb_match, glxsb_attach, NULL,
	glxsb_activate
};

struct cfdriver glxsb_cd = {
	NULL, "glxsb", DV_DULL
};


#ifdef CRYPTO

#define GLXSB_SESSION(sid)		((sid) & 0x0fffffff)
#define	GLXSB_SID(crd,ses)		(((crd) << 28) | ((ses) & 0x0fffffff))

static struct glxsb_softc *glxsb_sc;

int glxsb_crypto_setup(struct glxsb_softc *);
int glxsb_crypto_newsession(uint32_t *, struct cryptoini *);
int glxsb_crypto_process(struct cryptop *);
int glxsb_crypto_freesession(uint64_t);
static __inline void glxsb_aes(struct glxsb_softc *, uint32_t, uint32_t,
    uint32_t, void *, int, void *);

int glxsb_dma_alloc(struct glxsb_softc *, int, struct glxsb_dma_map *);
void glxsb_dma_pre_op(struct glxsb_softc *, struct glxsb_dma_map *);
void glxsb_dma_post_op(struct glxsb_softc *, struct glxsb_dma_map *);
void glxsb_dma_free(struct glxsb_softc *, struct glxsb_dma_map *);

#endif /* CRYPTO */


int
glxsb_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_AMD &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AMD_GEODE_LX_CRYPTO)
		return (1);

	return (0);
}

void
glxsb_attach(struct device *parent, struct device *self, void *aux)
{
	struct glxsb_softc *sc = (void *) self;
	struct pci_attach_args *pa = aux;
	bus_addr_t membase;
	bus_size_t memsize;
	uint64_t msr;
#ifdef CRYPTO
	uint32_t intr;
#endif

	msr = rdmsr(SB_GLD_MSR_CAP);
	if ((msr & 0xFFFF00) != 0x130400) {
		printf(": unknown ID 0x%x\n", (int) ((msr & 0xFFFF00) >> 16));
		return;
	}

	/* printf(": revision %d", (int) (msr & 0xFF)); */

	/* Map in the security block configuration/control registers */
	if (pci_mapreg_map(pa, PCI_MAPREG_START,
	    PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0, &sc->sc_iot,
	    &sc->sc_ioh, &membase, &memsize, SB_MEM_SIZE)) {
		printf(": can't find mem space\n");
		return;
	}

	/*
	 * Configure the Security Block.
	 *
	 * We want to enable the noise generator (T_NE), and enable the
	 * linear feedback shift register and whitener post-processing
	 * (T_SEL = 3).  Also ensure that test mode (deterministic values)
	 * is disabled.
	 */
	msr = rdmsr(SB_GLD_MSR_CTRL);
	msr &= ~(SB_GMC_T_TM | SB_GMC_T_SEL_MASK);
	msr |= SB_GMC_T_NE | SB_GMC_T_SEL3;
#if 0
	msr |= SB_GMC_SBI | SB_GMC_SBY;		/* for AES, if necessary */
#endif
	wrmsr(SB_GLD_MSR_CTRL, msr);

	/* Install a periodic collector for the "true" (AMD's word) RNG */
	timeout_set(&sc->sc_to, glxsb_rnd, sc);
	glxsb_rnd(sc);
	printf(": RNG");

#ifdef CRYPTO
	/* We don't have an interrupt handler, so disable completion INTs */
	intr = SB_AI_DISABLE_AES_A | SB_AI_DISABLE_AES_B |
	    SB_AI_DISABLE_EEPROM | SB_AI_AES_A_COMPLETE |
	    SB_AI_AES_B_COMPLETE | SB_AI_EEPROM_COMPLETE;
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, SB_AES_INT, intr);

	sc->sc_dmat = pa->pa_dmat;

	if (glxsb_crypto_setup(sc))
		printf(" AES");
#endif

	printf("\n");
}

int
glxsb_activate(struct device *self, int act)
{
	struct glxsb_softc *sc = (struct glxsb_softc *)self;

	switch (act) {
	case DVACT_QUIESCE:
		/* XXX should wait for current crypto op to finish */
		break;
	case DVACT_SUSPEND:
		sc->save_gld_msr = rdmsr(SB_GLD_MSR_CTRL);
		break;
	case DVACT_RESUME:
		wrmsr(SB_GLD_MSR_CTRL, sc->save_gld_msr);
		break;
	}
	return (0);
}

void
glxsb_rnd(void *v)
{
	struct glxsb_softc *sc = v;
	uint32_t status, value;

	status = bus_space_read_4(sc->sc_iot, sc->sc_ioh, SB_RANDOM_NUM_STATUS);
	if (status & SB_RNS_TRNG_VALID) {
		value = bus_space_read_4(sc->sc_iot, sc->sc_ioh, SB_RANDOM_NUM);
		add_true_randomness(value);
	}

	timeout_add_msec(&sc->sc_to, 10);
}

#ifdef CRYPTO
int
glxsb_crypto_setup(struct glxsb_softc *sc)
{
	int algs[CRYPTO_ALGORITHM_MAX + 1];

	/* Allocate a contiguous DMA-able buffer to work in */
	if (glxsb_dma_alloc(sc, GLXSB_MAX_AES_LEN * 2, &sc->sc_dma) != 0)
		return 0;

	bzero(algs, sizeof(algs));
	algs[CRYPTO_AES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_MD5_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA1_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_RIPEMD160_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA2_256_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA2_384_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA2_512_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;

	sc->sc_cid = crypto_get_driverid(0);
	if (sc->sc_cid < 0)
		return 0;

	crypto_register(sc->sc_cid, algs, glxsb_crypto_newsession,
	    glxsb_crypto_freesession, glxsb_crypto_process);

	sc->sc_nsessions = 0;

	glxsb_sc = sc;

	return 1;
}

int
glxsb_crypto_newsession(uint32_t *sidp, struct cryptoini *cri)
{
	struct glxsb_softc *sc = glxsb_sc;
	struct glxsb_session *ses = NULL;
	struct auth_hash	*axf;
	struct enc_xform	*txf;
	struct cryptoini	*c;
	struct swcr_data	*swd;
	int sesn, i;

	if (sc == NULL || sidp == NULL || cri == NULL)
		return (EINVAL);

	for (sesn = 0; sesn < sc->sc_nsessions; sesn++) {
		if (sc->sc_sessions[sesn].ses_used == 0) {
			ses = &sc->sc_sessions[sesn];
			break;
		}
	}

	if (ses == NULL) {
		sesn = sc->sc_nsessions;
		ses = mallocarray(sesn + 1, sizeof(*ses), M_DEVBUF,
		    M_NOWAIT);
		if (ses == NULL)
			return (ENOMEM);
		if (sesn != 0) {
			bcopy(sc->sc_sessions, ses, sesn * sizeof(*ses));
			explicit_bzero(sc->sc_sessions, sesn * sizeof(*ses));
			free(sc->sc_sessions, M_DEVBUF, sesn * sizeof(*ses));
		}
		sc->sc_sessions = ses;
		ses = &sc->sc_sessions[sesn];
		sc->sc_nsessions++;
	}

	bzero(ses, sizeof(*ses));
	ses->ses_used = 1;

	for (c = cri; c != NULL; c = c->cri_next) {
		switch (c->cri_alg) {
		case CRYPTO_AES_CBC:

			if (c->cri_klen != 128) {
				swd = malloc(sizeof(struct swcr_data),
				    M_CRYPTO_DATA, M_NOWAIT|M_ZERO);
				if (swd == NULL) {
					glxsb_crypto_freesession(sesn);
					return (ENOMEM);
				}
				ses->ses_swd_enc = swd;
				txf = &enc_xform_rijndael128;
				if (txf->ctxsize > 0) {
					swd->sw_kschedule =
					    malloc(txf->ctxsize,
						M_CRYPTO_DATA,
						M_NOWAIT|M_ZERO);
					if (swd->sw_kschedule == NULL) {
						glxsb_crypto_freesession(sesn);
						return (EINVAL);
					}
				}
				if (txf->setkey(swd->sw_kschedule, c->cri_key,
				    c->cri_klen / 8) < 0) {
					glxsb_crypto_freesession(sesn);
					return (EINVAL);
				}
				swd->sw_exf = txf;
				break;
			}

			ses->ses_klen = c->cri_klen;

			/* Copy the key (Geode LX wants the primary key only) */
			bcopy(c->cri_key, ses->ses_key, sizeof(ses->ses_key));
			break;

		case CRYPTO_MD5_HMAC:
			axf = &auth_hash_hmac_md5_96;
			goto authcommon;
		case CRYPTO_SHA1_HMAC:
			axf = &auth_hash_hmac_sha1_96;
			goto authcommon;
		case CRYPTO_RIPEMD160_HMAC:
			axf = &auth_hash_hmac_ripemd_160_96;
			goto authcommon;
		case CRYPTO_SHA2_256_HMAC:
			axf = &auth_hash_hmac_sha2_256_128;
			goto authcommon;
		case CRYPTO_SHA2_384_HMAC:
			axf = &auth_hash_hmac_sha2_384_192;
			goto authcommon;
		case CRYPTO_SHA2_512_HMAC:
			axf = &auth_hash_hmac_sha2_512_256;
		authcommon:
			swd = malloc(sizeof(struct swcr_data), M_CRYPTO_DATA,
			    M_NOWAIT|M_ZERO);
			if (swd == NULL) {
				glxsb_crypto_freesession(sesn);
				return (ENOMEM);
			}
			ses->ses_swd_auth = swd;

			swd->sw_ictx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if (swd->sw_ictx == NULL) {
				glxsb_crypto_freesession(sesn);
				return (ENOMEM);
			}

			swd->sw_octx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if (swd->sw_octx == NULL) {
				glxsb_crypto_freesession(sesn);
				return (ENOMEM);
			}

			for (i = 0; i < c->cri_klen / 8; i++)
				c->cri_key[i] ^= HMAC_IPAD_VAL;

			axf->Init(swd->sw_ictx);
			axf->Update(swd->sw_ictx, c->cri_key, c->cri_klen / 8);
			axf->Update(swd->sw_ictx, hmac_ipad_buffer,
			    axf->blocksize - (c->cri_klen / 8));

			for (i = 0; i < c->cri_klen / 8; i++)
				c->cri_key[i] ^= (HMAC_IPAD_VAL ^
				    HMAC_OPAD_VAL);

			axf->Init(swd->sw_octx);
			axf->Update(swd->sw_octx, c->cri_key, c->cri_klen / 8);
			axf->Update(swd->sw_octx, hmac_opad_buffer,
			    axf->blocksize - (c->cri_klen / 8));

			for (i = 0; i < c->cri_klen / 8; i++)
				c->cri_key[i] ^= HMAC_OPAD_VAL;

			swd->sw_axf = axf;
			swd->sw_alg = c->cri_alg;

			break;
		default:
			glxsb_crypto_freesession(sesn);
			return (EINVAL);
		}
	}

	*sidp = GLXSB_SID(0, sesn);
	return (0);
}

int
glxsb_crypto_freesession(uint64_t tid)
{
	struct glxsb_softc *sc = glxsb_sc;
	struct swcr_data *swd;
	struct auth_hash *axf;
	struct enc_xform *txf;
	int sesn;
	uint32_t sid = ((uint32_t)tid) & 0xffffffff;

	if (sc == NULL)
		return (EINVAL);
	sesn = GLXSB_SESSION(sid);
	if (sesn >= sc->sc_nsessions)
		return (EINVAL);
	if ((swd = sc->sc_sessions[sesn].ses_swd_enc)) {
		txf = swd->sw_exf;

		if (swd->sw_kschedule) {
			explicit_bzero(swd->sw_kschedule, txf->ctxsize);
			free(swd->sw_kschedule, M_CRYPTO_DATA, 0);
		}
		free(swd, M_CRYPTO_DATA, 0);
	}
	if ((swd = sc->sc_sessions[sesn].ses_swd_auth)) {
		axf = swd->sw_axf;

		if (swd->sw_ictx) {
			explicit_bzero(swd->sw_ictx, axf->ctxsize);
			free(swd->sw_ictx, M_CRYPTO_DATA, 0);
		}
		if (swd->sw_octx) {
			explicit_bzero(swd->sw_octx, axf->ctxsize);
			free(swd->sw_octx, M_CRYPTO_DATA, 0);
		}
		free(swd, M_CRYPTO_DATA, sizeof *swd);
	}
	explicit_bzero(&sc->sc_sessions[sesn], sizeof(sc->sc_sessions[sesn]));
	return (0);
}

/*
 * Must be called at splnet() or higher
 */
static __inline void
glxsb_aes(struct glxsb_softc *sc, uint32_t control, uint32_t psrc,
    uint32_t pdst, void *key, int len, void *iv)
{
	uint32_t status;
	int i;

	if (len & 0xF) {
		printf("%s: len must be a multiple of 16 (not %d)\n",
		    sc->sc_dev.dv_xname, len);
		return;
	}

	/* Set the source */
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, SB_SOURCE_A, psrc);

	/* Set the destination address */
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, SB_DEST_A, pdst);

	/* Set the data length */
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, SB_LENGTH_A, len);

	/* Set the IV */
	if (iv != NULL) {
		bus_space_write_region_4(sc->sc_iot, sc->sc_ioh,
		    SB_CBC_IV, iv, 4);
		control |= SB_CTL_CBC;
	}

	/* Set the key */
	bus_space_write_region_4(sc->sc_iot, sc->sc_ioh, SB_WKEY, key, 4);

	/* Ask the security block to do it */
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, SB_CTL_A,
	    control | SB_CTL_WK | SB_CTL_DC | SB_CTL_SC | SB_CTL_ST);

	/*
	 * Now wait until it is done.
	 *
	 * We do a busy wait.  Obviously the number of iterations of
	 * the loop required to perform the AES operation depends upon
	 * the number of bytes to process.
	 *
	 * On a 500 MHz Geode LX we see
	 *
	 *	length (bytes)	typical max iterations
	 *	    16		   12
	 *	    64		   22
	 *	   256		   59
	 *	  1024		  212
	 *	  8192		1,537
	 *
	 * Since we have a maximum size of operation defined in
	 * GLXSB_MAX_AES_LEN, we use this constant to decide how long
	 * to wait.  Allow an order of magnitude longer than it should
	 * really take, just in case.
	 */
	for (i = 0; i < GLXSB_MAX_AES_LEN * 10; i++) {
		status = bus_space_read_4(sc->sc_iot, sc->sc_ioh, SB_CTL_A);

		if ((status & SB_CTL_ST) == 0)		/* Done */
			return;
	}

	printf("%s: operation failed to complete\n", sc->sc_dev.dv_xname);
}

static int
glxsb_crypto_swauth(struct cryptop *crp, struct cryptodesc *crd,
    struct swcr_data *sw, caddr_t buf)
{
	int	type;

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		type = CRYPTO_BUF_MBUF;
	else
		type = CRYPTO_BUF_IOV;
		
	return (swcr_authcompute(crp, crd, sw, buf, type));
}

static int
glxsb_crypto_swenc(struct cryptop *crp, struct cryptodesc *crd,
    struct swcr_data *sw, caddr_t buf)
{
	int	type;

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		type = CRYPTO_BUF_MBUF;
	else
		type = CRYPTO_BUF_IOV;
		
	return (swcr_encdec(crd, sw, buf, type));
}

static int
glxsb_crypto_encdec(struct cryptop *crp, struct cryptodesc *crd,
    struct glxsb_session *ses, struct glxsb_softc *sc, caddr_t buf)
{
	char *op_src, *op_dst;
	uint32_t op_psrc, op_pdst;
	uint8_t op_iv[SB_AES_BLOCK_SIZE];
	int err = 0;
	int len, tlen, xlen;
	int offset;
	uint32_t control;

	if (crd == NULL || (crd->crd_len % SB_AES_BLOCK_SIZE) != 0) {
		err = EINVAL;
		goto out;
	}

	/* How much of our buffer will we need to use? */
	xlen = crd->crd_len > GLXSB_MAX_AES_LEN ?
	    GLXSB_MAX_AES_LEN : crd->crd_len;

	/*
	 * XXX Check if we can have input == output on Geode LX.
	 * XXX In the meantime, use two separate (adjacent) buffers.
	 */
	op_src = sc->sc_dma.dma_vaddr;
	op_dst = sc->sc_dma.dma_vaddr + xlen;

	op_psrc = sc->sc_dma.dma_paddr;
	op_pdst = sc->sc_dma.dma_paddr + xlen;

	if (crd->crd_flags & CRD_F_ENCRYPT) {
		control = SB_CTL_ENC;
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crd->crd_iv, op_iv, sizeof(op_iv));
		else
			arc4random_buf(op_iv, sizeof(op_iv));

		if ((crd->crd_flags & CRD_F_IV_PRESENT) == 0) {
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				err = m_copyback((struct mbuf *)crp->crp_buf,
				    crd->crd_inject, sizeof(op_iv), op_iv,
				    M_NOWAIT);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copyback((struct uio *)crp->crp_buf,
				    crd->crd_inject, sizeof(op_iv), op_iv);
			else
				bcopy(op_iv,
				    crp->crp_buf + crd->crd_inject, sizeof(op_iv));
			if (err)
				goto out;
		}
	} else {
		control = SB_CTL_DEC;
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crd->crd_iv, op_iv, sizeof(op_iv));
		else {
			if (crp->crp_flags & CRYPTO_F_IMBUF)
				m_copydata((struct mbuf *)crp->crp_buf,
				    crd->crd_inject, sizeof(op_iv), op_iv);
			else if (crp->crp_flags & CRYPTO_F_IOV)
				cuio_copydata((struct uio *)crp->crp_buf,
				    crd->crd_inject, sizeof(op_iv), op_iv);
			else
				bcopy(crp->crp_buf + crd->crd_inject,
				    op_iv, sizeof(op_iv));
		}
	}

	offset = 0;
	tlen = crd->crd_len;

	/* Process the data in GLXSB_MAX_AES_LEN chunks */
	while (tlen > 0) {
		len = (tlen > GLXSB_MAX_AES_LEN) ? GLXSB_MAX_AES_LEN : tlen;

		if (crp->crp_flags & CRYPTO_F_IMBUF)
			m_copydata((struct mbuf *)crp->crp_buf,
			    crd->crd_skip + offset, len, op_src);
		else if (crp->crp_flags & CRYPTO_F_IOV)
			cuio_copydata((struct uio *)crp->crp_buf,
			    crd->crd_skip + offset, len, op_src);
		else
			bcopy(crp->crp_buf + crd->crd_skip + offset, op_src,
			    len);

		glxsb_dma_pre_op(sc, &sc->sc_dma);

		glxsb_aes(sc, control, op_psrc, op_pdst, ses->ses_key,
		    len, op_iv);

		glxsb_dma_post_op(sc, &sc->sc_dma);

		if (crp->crp_flags & CRYPTO_F_IMBUF)
			err = m_copyback((struct mbuf *)crp->crp_buf,
			    crd->crd_skip + offset, len, op_dst, M_NOWAIT);
		else if (crp->crp_flags & CRYPTO_F_IOV)
			cuio_copyback((struct uio *)crp->crp_buf,
			    crd->crd_skip + offset, len, op_dst);
		else
			bcopy(op_dst, crp->crp_buf + crd->crd_skip + offset,
			    len);
		if (err)
			break;

		offset += len;
		tlen -= len;

		if (tlen > 0) {
			/* Copy out last block for use as next iteration */
			if (crd->crd_flags & CRD_F_ENCRYPT)
				bcopy(op_dst + len - sizeof(op_iv), op_iv,
				    sizeof(op_iv));
			else
				bcopy(op_src + len - sizeof(op_iv), op_iv,
				    sizeof(op_iv));
		}
	}

	/* All AES processing has now been done. */
	explicit_bzero(sc->sc_dma.dma_vaddr, xlen * 2);

out:
	return (err);
}

int
glxsb_crypto_process(struct cryptop *crp)
{
	struct glxsb_softc *sc = glxsb_sc;
	struct glxsb_session *ses;
	struct cryptodesc *crd;
	int sesn,err = 0;
	int s, i;

	s = splnet();

	if (crp == NULL || crp->crp_callback == NULL) {
		err = EINVAL;
		goto out;
	}
	if (crp->crp_ndesc < 1) {
		err = EINVAL;
		goto out;
	}

	sesn = GLXSB_SESSION(crp->crp_sid);
	if (sesn >= sc->sc_nsessions) {
		err = EINVAL;
		goto out;
	}
	ses = &sc->sc_sessions[sesn];
	if (ses->ses_used == 0) {
		err = EINVAL;
		goto out;
	}

	for (i = 0; i < crp->crp_ndesc; i++) {
		crd = &crp->crp_desc[i];
		switch (crd->crd_alg) {
		case CRYPTO_AES_CBC:
			if (ses->ses_swd_enc) {
				if ((err = glxsb_crypto_swenc(crp, crd, ses->ses_swd_enc,
				    crp->crp_buf)) != 0)
					goto out;
			} else if ((err = glxsb_crypto_encdec(crp, crd, ses, sc,
			    crp->crp_buf)) != 0)
				goto out;
			break;

		case CRYPTO_MD5_HMAC:
		case CRYPTO_SHA1_HMAC:
		case CRYPTO_RIPEMD160_HMAC:
		case CRYPTO_SHA2_256_HMAC:
		case CRYPTO_SHA2_384_HMAC:
		case CRYPTO_SHA2_512_HMAC:
			if ((err = glxsb_crypto_swauth(crp, crd, ses->ses_swd_auth,
			    crp->crp_buf)) != 0)
				goto out;
			break;

		default:
			err = EINVAL;
			goto out;
		}
	}

out:
	crp->crp_etype = err;
	crypto_done(crp);
	splx(s);
	return (err);
}

int
glxsb_dma_alloc(struct glxsb_softc *sc, int size, struct glxsb_dma_map *dma)
{
	int rc;

	dma->dma_nsegs = 1;
	dma->dma_size = size;

	rc = bus_dmamap_create(sc->sc_dmat, size, dma->dma_nsegs, size,
	    0, BUS_DMA_NOWAIT, &dma->dma_map);
	if (rc != 0) {
		printf("%s: couldn't create DMA map for %d bytes (%d)\n",
		    sc->sc_dev.dv_xname, size, rc);

		goto fail0;
	}

	rc = bus_dmamem_alloc(sc->sc_dmat, size, SB_AES_ALIGN, 0,
	    &dma->dma_seg, dma->dma_nsegs, &dma->dma_nsegs, BUS_DMA_NOWAIT);
	if (rc != 0) {
		printf("%s: couldn't allocate DMA memory of %d bytes (%d)\n",
		    sc->sc_dev.dv_xname, size, rc);

		goto fail1;
	}

	rc = bus_dmamem_map(sc->sc_dmat, &dma->dma_seg, 1, size,
	    &dma->dma_vaddr, BUS_DMA_NOWAIT);
	if (rc != 0) {
		printf("%s: couldn't map DMA memory for %d bytes (%d)\n",
		    sc->sc_dev.dv_xname, size, rc);

		goto fail2;
	}

	rc = bus_dmamap_load(sc->sc_dmat, dma->dma_map, dma->dma_vaddr,
	    size, NULL, BUS_DMA_NOWAIT);
	if (rc != 0) {
		printf("%s: couldn't load DMA memory for %d bytes (%d)\n",
		    sc->sc_dev.dv_xname, size, rc);

		goto fail3;
	}

	dma->dma_paddr = dma->dma_map->dm_segs[0].ds_addr;

	return 0;

fail3:
	bus_dmamem_unmap(sc->sc_dmat, dma->dma_vaddr, size);
fail2:
	bus_dmamem_free(sc->sc_dmat, &dma->dma_seg, dma->dma_nsegs);
fail1:
	bus_dmamap_destroy(sc->sc_dmat, dma->dma_map);
fail0:
	return rc;
}

void
glxsb_dma_pre_op(struct glxsb_softc *sc, struct glxsb_dma_map *dma)
{
	bus_dmamap_sync(sc->sc_dmat, dma->dma_map, 0, dma->dma_size,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
}

void
glxsb_dma_post_op(struct glxsb_softc *sc, struct glxsb_dma_map *dma)
{
	bus_dmamap_sync(sc->sc_dmat, dma->dma_map, 0, dma->dma_size,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
}

void
glxsb_dma_free(struct glxsb_softc *sc, struct glxsb_dma_map *dma)
{
	bus_dmamap_unload(sc->sc_dmat, dma->dma_map);
	bus_dmamem_unmap(sc->sc_dmat, dma->dma_vaddr, dma->dma_size);
	bus_dmamem_free(sc->sc_dmat, &dma->dma_seg, dma->dma_nsegs);
	bus_dmamap_destroy(sc->sc_dmat, dma->dma_map);
}

#endif /* CRYPTO */
@


1.30
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.29 2014/12/09 06:58:28 doug Exp $	*/
d781 1
a781 1
	int s;
d789 1
a789 2
	crd = crp->crp_desc;
	if (crd == NULL) {
d805 2
a806 1
	for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
@


1.29
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.28 2014/07/12 18:44:42 tedu Exp $	*/
d387 1
a387 1
			free(sc->sc_sessions, M_DEVBUF, 0);
d544 1
a544 1
		free(swd, M_CRYPTO_DATA, 0);
@


1.28
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.27 2013/10/29 21:44:50 mikeb Exp $	*/
d380 2
a381 1
		ses = malloc((sesn + 1) * sizeof(*ses), M_DEVBUF, M_NOWAIT);
@


1.27
log
@unbreak glxsb(4) by properly allocating it's key schedule;
reduce pctr.h usage while here.  ok jsing, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.26 2013/08/25 22:50:04 mikeb Exp $	*/
d386 1
a386 1
			free(sc->sc_sessions, M_DEVBUF);
d528 1
a528 1
			free(swd->sw_kschedule, M_CRYPTO_DATA);
d530 1
a530 1
		free(swd, M_CRYPTO_DATA);
d537 1
a537 1
			free(swd->sw_ictx, M_CRYPTO_DATA);
d541 1
a541 1
			free(swd->sw_octx, M_CRYPTO_DATA);
d543 1
a543 1
		free(swd, M_CRYPTO_DATA);
@


1.26
log
@one change missed by jsging's commit is needed to unbreak the build;
spotted by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.25 2012/12/05 23:20:12 deraadt Exp $	*/
d35 1
a35 1
#include <machine/pctr.h>
d401 2
a402 2
				swd = malloc(sizeof(struct swcr_data), M_CRYPTO_DATA,
				    M_NOWAIT|M_ZERO);
d409 11
a419 1
				if (txf->setkey(&(swd->sw_kschedule), c->cri_key,
@


1.25
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.24 2012/01/13 09:53:24 mikeb Exp $	*/
d516 4
a519 2
		if (swd->sw_kschedule)
			txf->zerokey(&(swd->sw_kschedule));
@


1.24
log
@handle m_copyback errors, this code is too sensitive for such
failures to be neglected;  ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.23 2011/01/12 17:15:23 deraadt Exp $	*/
a25 1
#include <sys/cdefs.h>
@


1.23
log
@use explicit_bzero() for the session, in drivers where struct session
contains key material (note, that is not true in all drivers... hence
not always neccessary)
discussed with mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.22 2011/01/11 15:42:05 deraadt Exp $	*/
d676 1
a676 1
				m_copyback((struct mbuf *)crp->crp_buf,
d685 2
d730 1
a730 1
			m_copyback((struct mbuf *)crp->crp_buf,
d738 2
@


1.22
log
@for key material that is being being discarded, convert bzero() to
explicit_bzero() where required
ok markus mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.21 2010/12/15 23:34:23 mikeb Exp $	*/
d386 1
a386 1
			bzero(sc->sc_sessions, sesn * sizeof(*ses));
d534 1
a534 1
	bzero(&sc->sc_sessions[sesn], sizeof(sc->sc_sessions[sesn]));
@


1.21
log
@Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.

Original commit message by angelos:

Don't keep the last blocksize-bytes of ciphertext for use as the next
plaintext's IV, in CBC mode. Use arc4random() to acquire fresh IVs per
message.

with and ok deraadt, ok markus, djm
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.20 2010/09/20 02:46:50 deraadt Exp $	*/
d525 1
a525 1
			bzero(swd->sw_ictx, axf->ctxsize);
d529 1
a529 1
			bzero(swd->sw_octx, axf->ctxsize);
d752 1
a752 1
	bzero(sc->sc_dma.dma_vaddr, xlen * 2);
@


1.20
log
@Write the start of an activate function.  QUIESCE should wait for the
current crypto operation to finish but doesn't do that yet.
The suspend and resume operations assume that SB_GLD_MSR_CTRL gets
trashed
ok pirofti
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.19 2010/07/02 02:40:15 blambert Exp $	*/
a152 1
	uint8_t		ses_iv[SB_AES_BLOCK_SIZE];
a418 1
			arc4random_buf(ses->ses_iv, sizeof(ses->ses_iv));
d642 1
a642 1
	uint8_t op_iv[SB_AES_BLOCK_SIZE], *piv;
d672 1
a672 1
			bcopy(ses->ses_iv, op_iv, sizeof(op_iv));
a704 1
	piv = op_iv;
d740 7
a746 18
		if (tlen <= 0) {	/* Ideally, just == 0 */
			/* Finished - put the IV in session IV */
			piv = ses->ses_iv;
		}

		/*
		 * Copy out last block for use as next iteration/session IV.
		 *
		 * piv is set to op_iv[] before the loop starts, but is
		 * set to ses->ses_iv if we're going to exit the loop this
		 * time.
		 */
		if (crd->crd_flags & CRD_F_ENCRYPT) {
			bcopy(op_dst + len - sizeof(op_iv), piv, sizeof(op_iv));
		} else {
			/* Decryption, only need this if another iteration */
			if (tlen > 0) {
				bcopy(op_src + len - sizeof(op_iv), piv,
a747 1
			}
@


1.19
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.18 2010/01/10 12:43:07 markus Exp $	*/
d174 2
d180 1
d184 2
a185 1
	sizeof(struct glxsb_softc), glxsb_match, glxsb_attach
d290 19
@


1.19.2.1
log
@Backport from -current, original commit by mikeb@@:
------
Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.
------

ok deraadt@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.19 2010/07/02 02:40:15 blambert Exp $	*/
d153 1
d397 1
d621 1
a621 1
	uint8_t op_iv[SB_AES_BLOCK_SIZE];
d651 1
a651 1
			arc4random_buf(op_iv, sizeof(op_iv));
d684 1
d720 18
a737 7
		if (tlen > 0) {
			/* Copy out last block for use as next iteration */
			if (crd->crd_flags & CRD_F_ENCRYPT)
				bcopy(op_dst + len - sizeof(op_iv), op_iv,
				    sizeof(op_iv));
			else
				bcopy(op_src + len - sizeof(op_iv), op_iv,
d739 1
@


1.18
log
@Fix two bugs in IPsec/HMAC-SHA2:
(1) use correct (message) block size of 128 byte (instead of 64
    bytes) for HMAC-SHA512/384 (RFC4634).
(2) RFC4868 specifies that HMAC-SHA-{256,384,512} is truncated to
    nnn/2 bits, while we still use 96 bits. 96 bits have been
    specified in draft-ietf-ipsec-ciph-sha-256-00 while
    draft-ietf-ipsec-ciph-sha-256-01 changed it to 128 bits.

WARNING: this change makes IPsec with SHA-256 (the default)
incompatible with older OpenBSD versions and other IPsec-implementations
that share this bug.

ok+tests naddy, fries; requested by reyk/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.17 2009/10/30 18:18:09 deraadt Exp $	*/
d656 2
a657 1
				    crd->crd_inject, sizeof(op_iv), op_iv);
d709 1
a709 1
			    crd->crd_skip + offset, len, op_dst);
@


1.18.2.1
log
@Backport from -current, original commit by mikeb@@:
------
Bring CBC oracle attack countermeasure from r1.32 of cryptosoft.c to
the hardware crypto accelerator land.  This fixes aes-ni, via xcrypt,
glxsb(4), hifn(4), safe(4) and ubsec(4) drivers.
------
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.18 2010/01/10 12:43:07 markus Exp $	*/
d153 1
d397 1
d621 1
a621 1
	uint8_t op_iv[SB_AES_BLOCK_SIZE];
d651 1
a651 1
			arc4random_buf(op_iv, sizeof(op_iv));
d683 1
d719 18
a736 7
		if (tlen > 0) {
			/* Copy out last block for use as next iteration */
			if (crd->crd_flags & CRD_F_ENCRYPT)
				bcopy(op_dst + len - sizeof(op_iv), op_iv,
				    sizeof(op_iv));
			else
				bcopy(op_src + len - sizeof(op_iv), op_iv,
d738 1
@


1.17
log
@correct interrupt status bits; patfbsd@@davenulle.org
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.16 2009/08/05 07:44:07 blambert Exp $	*/
d414 1
a414 1
			axf = &auth_hash_hmac_sha2_256_96;
d417 1
a417 1
			axf = &auth_hash_hmac_sha2_384_96;
d420 1
a420 1
			axf = &auth_hash_hmac_sha2_512_96;
d450 1
a450 1
			    HMAC_BLOCK_LEN - (c->cri_klen / 8));
d459 1
a459 1
			    HMAC_BLOCK_LEN - (c->cri_klen / 8));
@


1.16
log
@timeout_add -> timeout_add_msec

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.15 2008/09/19 10:44:11 markus Exp $	*/
d113 9
a121 9
#define SB_AI_DISABLE_AES_A	0x0001		/* Disable AES A compl int */
#define SB_AI_ENABLE_AES_A	0x0000		/* Enable AES A compl int */
#define SB_AI_DISABLE_AES_B	0x0002		/* Disable AES B compl int */
#define SB_AI_ENABLE_AES_B	0x0000		/* Enable AES B compl int */
#define SB_AI_DISABLE_EEPROM	0x0004		/* Disable EEPROM op comp int */
#define SB_AI_ENABLE_EEPROM	0x0000		/* Enable EEPROM op compl int */
#define SB_AI_AES_A_COMPLETE	0x0100		/* AES A operation complete */
#define SB_AI_AES_B_COMPLETE	0x0200		/* AES B operation complete */
#define SB_AI_EEPROM_COMPLETE	0x0400		/* EEPROM operation complete */
@


1.15
log
@AES with keysize != 128 bit is not supported in hardware, so we need
to switch to the software implementation; ok hshoexer, tom
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.14 2008/06/09 07:07:15 djm Exp $	*/
a292 1
	extern int hz;
d300 1
a300 1
	timeout_add(&sc->sc_to, (hz > 100) ? (hz / 100) : 1);
@


1.14
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.13 2007/12/09 21:30:24 hshoexer Exp $	*/
d156 2
a157 1
	struct swcr_data *ses_swd;
d343 1
d379 1
d381 15
a395 2
				glxsb_crypto_freesession(sesn);
				return (EINVAL);
d429 1
a429 1
			ses->ses_swd = swd;
d485 1
d494 8
a501 2
	if (sc->sc_sessions[sesn].ses_swd) {
		swd = sc->sc_sessions[sesn].ses_swd;
d603 14
d785 5
a789 1
			if ((err = glxsb_crypto_encdec(crp, crd, ses, sc,
d800 1
a800 1
			if ((err = glxsb_crypto_swauth(crp, crd, ses->ses_swd,
@


1.13
log
@FREE -> free

ok gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.12 2007/11/14 19:10:44 markus Exp $	*/
d382 1
a382 1
			arc4random_bytes(ses->ses_iv, sizeof(ses->ses_iv));
@


1.12
log
@do not process requests linked to unused sessions. (crypto_freesession
might happen between enqueuing a crypto request and scheduling of
the crypto thread); ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.11 2007/09/18 22:02:18 djm Exp $	*/
d489 1
a489 1
		FREE(swd, M_CRYPTO_DATA);
@


1.11
log
@arc4random_bytes() is the preferred interface for generating nonces;
"looks ok" markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.10 2007/09/10 23:04:46 henric Exp $	*/
d740 4
@


1.10
log
@Remove unused "extern" declaration.

ok tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.9 2007/09/07 15:00:19 art Exp $	*/
d382 1
a382 1
			get_random_bytes(ses->ses_iv, sizeof(ses->ses_iv));
@


1.9
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.8 2007/08/07 09:48:23 markus Exp $	*/
a193 1
extern int i386_has_xcrypt;
@


1.8
log
@provide software version of HMAC, so IPsec can actually use the crypto HW;
improves IPsec w/ AES/SHA1 from 17Mbit/s to 30Mbit/s on 500Mhz machine;
code similar to i386/via.c; ok tom, hshoexer, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.7 2007/02/12 14:31:45 tom Exp $	*/
d408 2
a409 3
			MALLOC(swd, struct swcr_data *,
			    sizeof(struct swcr_data), M_CRYPTO_DATA,
			    M_NOWAIT);
a413 1
			bzero(swd, sizeof(struct swcr_data));
@


1.7
log
@Enable the AES acceleration.  Won't be picked up for IPsec, since we
don't support the other required operations in the driver, but will be
used by OpenSSL.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.6 2007/01/19 19:59:09 tom Exp $	*/
d45 2
d156 1
d316 6
d342 4
a345 1
	int sesn;
d347 1
a347 3
	if (sc == NULL || sidp == NULL || cri == NULL ||
	    cri->cri_next != NULL || cri->cri_alg != CRYPTO_AES_CBC ||
	    cri->cri_klen != 128)
d375 56
a430 2
	get_random_bytes(ses->ses_iv, sizeof(ses->ses_iv));
	ses->ses_klen = cri->cri_klen;
d432 29
a460 2
	/* Copy the key (Geode LX wants the primary key only) */
	bcopy(cri->cri_key, ses->ses_key, sizeof(ses->ses_key));
d470 2
d480 14
d568 17
a584 2
int
glxsb_crypto_process(struct cryptop *crp)
a585 3
	struct glxsb_softc *sc = glxsb_sc;
	struct glxsb_session *ses;
	struct cryptodesc *crd;
d589 1
a589 1
	int sesn, err = 0;
a592 15
	int s;

	s = splnet();

	if (crp == NULL || crp->crp_callback == NULL) {
		err = EINVAL;
		goto out;
	}
	crd = crp->crp_desc;
	if (crd == NULL || crd->crd_next != NULL ||
	    crd->crd_alg != CRYPTO_AES_CBC ||
	    (crd->crd_len % SB_AES_BLOCK_SIZE) != 0) {
		err = EINVAL;
		goto out;
	}
d594 1
a594 2
	sesn = GLXSB_SESSION(crp->crp_sid);
	if (sesn >= sc->sc_nsessions) {
a597 1
	ses = &sc->sc_sessions[sesn];
d710 58
a768 1
	bzero(sc->sc_dma.dma_vaddr, xlen * 2);
@


1.6
log
@Update comment (on how long we wait for operation to complete) reflect
reality, and remove the maxpolls stuff at the same time.  Still disabled
in-tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.5 2007/01/02 22:51:49 tom Exp $	*/
a41 1
#undef CRYPTO			/* XXX AES support not yet ready XXX */
@


1.5
log
@Use bus_space_write_region_4() instead of doing the same thing bit by
bit (well, uint32 by uint32).  Inspired by a claudio commit to malo.c.

Still disabled (awaiting a code review), but works for me here.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.4 2006/11/19 13:41:27 tom Exp $	*/
a169 2

	int			maxpolls;	/* XXX */
d449 2
a450 2
	 * to wait.  Allow a couple of orders of magnitude longer than
	 * it should really take, just in case.
d455 1
a455 6
		if ((status & SB_CTL_ST) == 0) {	/* Done */
			if (i > sc->maxpolls) {	/* XXX */
				sc->maxpolls = i;
				printf("%s: maxpolls now %d (len = %d)\n",
				    sc->sc_dev.dv_xname, i, len);
			}
a456 1
		}
@


1.4
log
@Handle operations larger than will fit in the buffer we allocate,
by processing in a loop.  And bump the size of this buffer (32KB
taken by the driver shouldn't be a problem).

Also reduce the places we hard-code the AES block size of 16.

Still disabled (doing more testing), but I want to commit before
the aged hard disk I have in the system here dies.

(This commit from the Geode system with the AES enabled.)
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.3 2006/11/19 02:08:10 tom Exp $	*/
a199 2
static void glxsb_bus_space_write_consec_16(bus_space_tag_t,
    bus_space_handle_t, bus_size_t, uint32_t *);
a393 10
static void
glxsb_bus_space_write_consec_16(bus_space_tag_t iot, bus_space_handle_t ioh,
    bus_size_t offset, uint32_t *dp)
{
	bus_space_write_4(iot, ioh, offset +  0, dp[0]);
	bus_space_write_4(iot, ioh, offset +  4, dp[1]);
	bus_space_write_4(iot, ioh, offset +  8, dp[2]);
	bus_space_write_4(iot, ioh, offset + 12, dp[3]);
}

d421 2
a422 2
		glxsb_bus_space_write_consec_16(sc->sc_iot, sc->sc_ioh,
		    SB_CBC_IV, iv);
d427 1
a427 1
	glxsb_bus_space_write_consec_16(sc->sc_iot, sc->sc_ioh, SB_WKEY, key);
@


1.3
log
@Improve the AES acceleration, by allocating a contiguous DMA-able
buffer on attach, and using it for encrypt/decrypt operations.  Still
disabled, since the driver cannot currently handle an operation larger
than supported by this buffer.  (Interactive ssh does work with this
code, however.)

"commit, of course" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.2 2006/11/17 16:06:16 tom Exp $	*/
d128 1
d139 1
a139 1
#define GLXSB_MAX_AES_LEN	8192
d152 1
a152 1
	uint8_t		ses_iv[16];
d490 1
a490 1
	uint8_t op_iv[16];
d492 2
d506 1
a506 1
	    (crd->crd_len % 16) != 0) {
a510 8
	/* XXX TEMP TEMP TEMP need to handle this properly */
	if (crd->crd_len > GLXSB_MAX_AES_LEN) {
		printf("%s: operation too big: %d > %d\n",
		    sc->sc_dev.dv_xname, crd->crd_len, GLXSB_MAX_AES_LEN);
		err = ENOMEM;
		goto out;
	}

d518 4
d527 1
a527 1
	op_dst = sc->sc_dma.dma_vaddr + crd->crd_len;
d530 1
a530 1
	op_pdst = sc->sc_dma.dma_paddr + crd->crd_len;
d535 1
a535 1
			bcopy(crd->crd_iv, op_iv, 16);
d537 1
a537 1
			bcopy(ses->ses_iv, op_iv, 16);
d542 1
a542 1
				    crd->crd_inject, 16, op_iv);
d545 1
a545 1
				    crd->crd_inject, 16, op_iv);
d548 1
a548 1
				    crp->crp_buf + crd->crd_inject, 16);
d553 1
a553 1
			bcopy(crd->crd_iv, op_iv, 16);
d557 1
a557 1
				    crd->crd_inject, 16, op_iv);
d560 1
a560 1
				    crd->crd_inject, 16, op_iv);
d563 1
a563 1
				    op_iv, 16);
d567 7
a573 24
	if (crp->crp_flags & CRYPTO_F_IMBUF)
		m_copydata((struct mbuf *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, op_src);
	else if (crp->crp_flags & CRYPTO_F_IOV)
		cuio_copydata((struct uio *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, op_src);
	else
		bcopy(crp->crp_buf + crd->crd_skip, op_src, crd->crd_len);

	glxsb_dma_pre_op(sc, &sc->sc_dma);

	glxsb_aes(sc, control, op_psrc, op_pdst, ses->ses_key,
	    crd->crd_len, op_iv);

	glxsb_dma_post_op(sc, &sc->sc_dma);

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		m_copyback((struct mbuf *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, op_dst);
	else if (crp->crp_flags & CRYPTO_F_IOV)
		cuio_copyback((struct uio *)crp->crp_buf,
		    crd->crd_skip, crd->crd_len, op_dst);
	else
		bcopy(op_dst, crp->crp_buf + crd->crd_skip, crd->crd_len);
a574 2
	/* copy out last block for use as next session IV */
	if (crd->crd_flags & CRD_F_ENCRYPT) {
d577 1
a577 1
			    crd->crd_skip + crd->crd_len - 16, 16, ses->ses_iv);
d580 18
a597 1
			    crd->crd_skip + crd->crd_len - 16, 16, ses->ses_iv);
d599 27
a625 2
			bcopy(crp->crp_buf + crd->crd_skip + crd->crd_len - 16,
			    ses->ses_iv, 16);
d628 1
a628 1
	bzero(sc->sc_dma.dma_vaddr, crd->crd_len * 2);
d630 1
@


1.2
log
@Add code for AES acceleration.  This is currently disabled with
`#undef CRYPTO' since it doesn't work properly yet.  Committing in
order to get it into the tree.

"get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glxsb.c,v 1.1 2006/10/26 08:37:14 tom Exp $	*/
d42 1
a42 1
#undef CRYPTO
d126 14
d141 8
d164 2
d201 7
a207 2
static __inline void glxsb_aes(struct glxsb_softc *, uint32_t, void *, void *,
    void *, int, void *);
d280 2
d311 4
d409 2
a410 2
glxsb_aes(struct glxsb_softc *sc, uint32_t control, void *src, void *dst,
    void *key, int len, void *iv)
d412 1
a412 1
	uint32_t intr;
a413 8
	extern paddr_t vtophys(vaddr_t);
	static int re_check = 0;

	if (re_check) {
		panic("glxsb: call again :(\n");
	} else {
		re_check = 1;
	}
d416 2
a417 2
		printf("glxsb: len must be a multiple of 16 (not %d)\n", len);
		re_check = 0;
d422 1
a422 2
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, SB_SOURCE_A,
	    (uint32_t) vtophys((vaddr_t) src));
d425 1
a425 2
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, SB_DEST_A,
	    (uint32_t) vtophys((vaddr_t) dst));
d447 17
a463 3
	 * We do a busy wait: typically the SB completes after 7 or 8
	 * iterations (yet to see more than 9).  Wait up to a hundred
	 * just in case.
d465 2
a466 2
	for (i = 0; i < 100; i++) {
		intr = bus_space_read_4(sc->sc_iot, sc->sc_ioh, SB_AES_INT);
d468 2
a469 5
		if (intr & SB_AI_AES_A_COMPLETE) {	/* Done */
			bus_space_write_4(sc->sc_iot, sc->sc_ioh, SB_AES_INT,
			    intr);

			if (i > sc->maxpolls)	/* XXX */
d471 3
a473 1
			re_check = 0;
d478 1
a478 2
	re_check = 0;
	printf("glxsb: operation failed to complete\n");
d487 2
a488 3
	char *op_buf = NULL;
	char *op_src;			/* Source and dest buffers must */
	char *op_dst;			/* be 16-byte aligned */
d508 8
d525 1
a525 2
	 * XXX In the meantime, allocate space for two separate 
	 *     (adjacent) buffers
d527 5
a531 7
	op_buf = malloc(crd->crd_len * 2, M_DEVBUF, M_NOWAIT);
	if (op_buf == NULL) {
		err = ENOMEM;
		goto out;
	}
	op_src = op_buf;
	op_dst = op_buf + crd->crd_len;
d577 3
a579 1
	glxsb_aes(sc, control, op_src, op_dst, ses->ses_key,
d582 2
d606 2
a608 4
	if (op_buf != NULL) {
		bzero(op_buf, crd->crd_len * 2);
		free(op_buf, M_DEVBUF);
	}
d613 81
@


1.1
log
@Driver for the AMD Geode LX series processor security block.
Currently just uses the RNG; AES support to be added later.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d5 2
d30 2
d42 6
d85 1
d90 1
d102 20
d126 9
d140 8
d163 20
d203 3
d234 3
d242 14
a255 1
	printf(": RNG\n");
d273 300
@

