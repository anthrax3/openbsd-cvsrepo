head	1.89;
access;
symbols
	OPENBSD_6_1:1.89.0.14
	OPENBSD_6_1_BASE:1.89
	OPENBSD_6_0:1.89.0.10
	OPENBSD_6_0_BASE:1.89
	OPENBSD_5_9:1.89.0.6
	OPENBSD_5_9_BASE:1.89
	OPENBSD_5_8:1.89.0.8
	OPENBSD_5_8_BASE:1.89
	OPENBSD_5_7:1.89.0.2
	OPENBSD_5_7_BASE:1.89
	OPENBSD_5_6:1.89.0.4
	OPENBSD_5_6_BASE:1.89
	OPENBSD_5_5:1.88.0.4
	OPENBSD_5_5_BASE:1.88
	OPENBSD_5_4:1.87.0.4
	OPENBSD_5_4_BASE:1.87
	OPENBSD_5_3:1.87.0.2
	OPENBSD_5_3_BASE:1.87
	OPENBSD_5_2:1.85.0.8
	OPENBSD_5_2_BASE:1.85
	OPENBSD_5_1_BASE:1.85
	OPENBSD_5_1:1.85.0.6
	OPENBSD_5_0:1.85.0.4
	OPENBSD_5_0_BASE:1.85
	OPENBSD_4_9:1.85.0.2
	OPENBSD_4_9_BASE:1.85
	OPENBSD_4_8:1.83.0.2
	OPENBSD_4_8_BASE:1.83
	OPENBSD_4_7:1.80.0.2
	OPENBSD_4_7_BASE:1.80
	OPENBSD_4_6:1.77.0.4
	OPENBSD_4_6_BASE:1.77
	OPENBSD_4_5:1.75.0.2
	OPENBSD_4_5_BASE:1.75
	OPENBSD_4_4:1.73.0.2
	OPENBSD_4_4_BASE:1.73
	OPENBSD_4_3:1.66.0.2
	OPENBSD_4_3_BASE:1.66
	OPENBSD_4_2:1.56.0.2
	OPENBSD_4_2_BASE:1.56
	OPENBSD_4_1:1.54.0.2
	OPENBSD_4_1_BASE:1.54
	OPENBSD_4_0:1.52.0.2
	OPENBSD_4_0_BASE:1.52
	OPENBSD_3_9:1.51.0.2
	OPENBSD_3_9_BASE:1.51
	OPENBSD_3_8:1.49.0.2
	OPENBSD_3_8_BASE:1.49
	OPENBSD_3_7:1.45.0.2
	OPENBSD_3_7_BASE:1.45
	OPENBSD_3_6:1.41.0.4
	OPENBSD_3_6_BASE:1.41
	SMP_SYNC_A:1.41
	SMP_SYNC_B:1.41
	OPENBSD_3_5:1.41.0.2
	OPENBSD_3_5_BASE:1.41
	OPENBSD_3_4:1.39.0.2
	OPENBSD_3_4_BASE:1.39
	UBC_SYNC_A:1.38
	OPENBSD_3_3:1.38.0.2
	OPENBSD_3_3_BASE:1.38
	OPENBSD_3_2:1.37.0.2
	OPENBSD_3_2_BASE:1.37
	OPENBSD_3_1:1.29.0.2
	OPENBSD_3_1_BASE:1.29
	UBC_SYNC_B:1.37
	UBC:1.27.0.6
	UBC_BASE:1.27
	OPENBSD_3_0:1.27.0.4
	OPENBSD_3_0_BASE:1.27
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_8:1.23.0.2
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	SMP:1.6.0.10
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.8
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6;
locks; strict;
comment	@ * @;


1.89
date	2014.03.26.14.41.41;	author mpi;	state Exp;
branches;
next	1.88;

1.88
date	2013.12.06.21.03.05;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2012.10.08.21.47.48;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2012.09.19.23.03.12;	author kettenis;	state Exp;
branches;
next	1.85;

1.85
date	2010.08.31.17.13.46;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2010.08.31.16.17.18;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2010.08.07.06.10.06;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2010.06.24.00.06.57;	author kettenis;	state Exp;
branches;
next	1.81;

1.81
date	2010.04.02.19.23.05;	author kettenis;	state Exp;
branches;
next	1.80;

1.80
date	2010.02.09.19.36.05;	author kettenis;	state Exp;
branches;
next	1.79;

1.79
date	2009.11.23.15.33.37;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2009.09.18.20.17.17;	author kettenis;	state Exp;
branches;
next	1.77;

1.77
date	2009.04.11.14.59.59;	author kettenis;	state Exp;
branches;
next	1.76;

1.76
date	2009.03.31.21.57.57;	author kettenis;	state Exp;
branches;
next	1.75;

1.75
date	2008.11.09.15.11.19;	author oga;	state Exp;
branches;
next	1.74;

1.74
date	2008.09.26.21.15.53;	author mikeb;	state Exp;
branches;
next	1.73;

1.73
date	2008.07.07.07.54.48;	author bernd;	state Exp;
branches;
next	1.72;

1.72
date	2008.06.26.05.42.11;	author ray;	state Exp;
branches;
next	1.71;

1.71
date	2008.06.25.18.54.06;	author oga;	state Exp;
branches;
next	1.70;

1.70
date	2008.06.05.09.45.14;	author brad;	state Exp;
branches;
next	1.69;

1.69
date	2008.04.28.06.17.47;	author brad;	state Exp;
branches;
next	1.68;

1.68
date	2008.03.23.08.36.41;	author damien;	state Exp;
branches;
next	1.67;

1.67
date	2008.03.16.19.00.28;	author oga;	state Exp;
branches;
next	1.66;

1.66
date	2008.01.04.00.23.25;	author kettenis;	state Exp;
branches;
next	1.65;

1.65
date	2007.12.18.22.56.45;	author kettenis;	state Exp;
branches;
next	1.64;

1.64
date	2007.12.01.15.16.45;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2007.11.29.11.12.57;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2007.11.27.15.40.56;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2007.11.26.19.52.09;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2007.11.26.15.35.17;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2007.11.26.10.35.42;	author reyk;	state Exp;
branches;
next	1.58;

1.58
date	2007.11.25.17.11.12;	author oga;	state Exp;
branches;
next	1.57;

1.57
date	2007.11.16.15.31.19;	author mikeb;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.01.22.45.17;	author biorn;	state Exp;
branches;
next	1.55;

1.55
date	2007.05.31.22.35.48;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2006.12.14.17.36.12;	author kettenis;	state Exp;
branches;
next	1.53;

1.53
date	2006.09.19.11.06.34;	author jsg;	state Exp;
branches;
next	1.52;

1.52
date	2006.03.13.20.10.49;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2006.02.14.13.42.54;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2005.12.29.04.26.17;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2005.06.14.20.35.45;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2005.05.29.17.29.37;	author grange;	state Exp;
branches;
next	1.47;

1.47
date	2005.05.29.17.27.16;	author grange;	state Exp;
branches;
next	1.46;

1.46
date	2005.05.19.19.41.01;	author grange;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.09.21.53.49;	author hshoexer;	state Exp;
branches;
next	1.44;

1.44
date	2005.01.13.00.43.01;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2005.01.12.18.19.05;	author grange;	state Exp;
branches;
next	1.42;

1.42
date	2004.11.23.13.33.14;	author grange;	state Exp;
branches;
next	1.41;

1.41
date	2003.11.07.16.43.08;	author mickey;	state Exp;
branches;
next	1.40;

1.40
date	2003.10.05.02.26.03;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2003.06.03.20.10.32;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2003.01.08.01.46.07;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2002.09.23.04.11.31;	author nate;	state Exp;
branches;
next	1.36;

1.36
date	2002.08.22.23.03.48;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2002.07.12.20.17.03;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.12.15.52.54;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2002.05.10.17.15.07;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2002.05.06.19.23.47;	author nate;	state Exp;
branches;
next	1.31;

1.31
date	2002.04.28.20.36.23;	author nate;	state Exp;
branches;
next	1.30;

1.30
date	2002.04.24.23.02.20;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.31.23.38.53;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.22.23.11.21;	author deraadt;	state Exp;
branches
	1.27.6.1;
next	1.26;

1.26
date	2000.12.29.17.00.54;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2000.12.25.19.44.43;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2000.11.08.13.12.40;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.23.20.07.30;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.23.19.04.19;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2000.10.23.16.33.20;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.19.16.37.37;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.15.02.00.33;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.02.02.21.13;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2000.07.18.15.17.19;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.15.20.35.57;	author ho;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.13.00.38.46;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.05.00.26.28;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.04.05.35.45;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.01.19.34.22;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.27.00.41.06;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.26.18.39.29;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.26.18.38.47;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.21.22.48.52;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.10.20.07.47;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	98.03.03.07.36.44;	author deraadt;	state Exp;
branches
	1.6.10.1;
next	1.5;

1.5
date	98.01.22.19.15.36;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.01.20.18.40.22;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.01.10.13.34.01;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	98.01.07.11.03.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	98.01.06.02.35.20;	author deraadt;	state Exp;
branches;
next	;

1.6.10.1
date	2001.04.18.16.08.26;	author niklas;	state Exp;
branches;
next	1.6.10.2;

1.6.10.2
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.6.10.3;

1.6.10.3
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.6.10.4;

1.6.10.4
date	2003.03.27.23.26.56;	author niklas;	state Exp;
branches;
next	1.6.10.5;

1.6.10.5
date	2003.06.07.11.11.38;	author ho;	state Exp;
branches;
next	1.6.10.6;

1.6.10.6
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	;

1.27.6.1
date	2002.01.31.22.55.12;	author niklas;	state Exp;
branches;
next	1.27.6.2;

1.27.6.2
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	1.27.6.3;

1.27.6.3
date	2002.10.29.00.28.04;	author art;	state Exp;
branches;
next	1.27.6.4;

1.27.6.4
date	2003.05.19.21.45.12;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.89
log
@No need to include <sys/lock.h> when only <sys/rwlock.h> is needed,
so remove the former and include the latter instead of pulling it
in <dev/pci/agpvar.h>.  This header already requires various other
types anyway.  While here remove unneeded headers.
@
text
@/*	$OpenBSD: pchb.c,v 1.88 2013/12/06 21:03:05 deraadt Exp $ */
/*	$NetBSD: pchb.c,v 1.65 2007/08/15 02:26:13 markd Exp $	*/

/*
 * Copyright (c) 2000 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1996, 1998, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/rwlock.h>

#include <machine/bus.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <dev/pci/agpvar.h>
#include <dev/pci/ppbreg.h>

#include <dev/rndvar.h>

#include <dev/ic/i82802reg.h>

#include "agp.h"

#define PCISET_INTEL_BRIDGETYPE_MASK	0x3
#define PCISET_INTEL_TYPE_COMPAT	0x1
#define PCISET_INTEL_TYPE_AUX		0x2

#define PCISET_INTEL_BUSCONFIG_REG	0x48
#define PCISET_INTEL_BRIDGE_NUMBER(reg)	(((reg) >> 8) & 0xff)
#define PCISET_INTEL_PCI_BUS_NUMBER(reg)	(((reg) >> 16) & 0xff)

#define PCISET_INTEL_SDRAMC_REG	0x74
#define PCISET_INTEL_SDRAMC_IPDLT	(1 << 24)

/* XXX should be in dev/ic/i82424{reg.var}.h */
#define I82424_CPU_BCTL_REG		0x53
#define I82424_PCI_BCTL_REG		0x54

#define I82424_BCTL_CPUMEM_POSTEN	0x01
#define I82424_BCTL_CPUPCI_POSTEN	0x02
#define I82424_BCTL_PCIMEM_BURSTEN	0x01
#define I82424_BCTL_PCI_BURSTEN		0x02

/* XXX should be in dev/ic/amd64htreg.h */
#define AMD64HT_LDT0_BUS	0x94
#define AMD64HT_LDT0_TYPE	0x98
#define AMD64HT_LDT1_BUS	0xb4
#define AMD64HT_LDT1_TYPE	0xb8
#define AMD64HT_LDT2_BUS	0xd4
#define AMD64HT_LDT2_TYPE	0xd8
#define AMD64HT_LDT3_BUS	0xf4
#define AMD64HT_LDT3_TYPE	0xf8

#define AMD64HT_NUM_LDT		4

#define AMD64HT_LDT_TYPE_MASK		0x0000001f
#define  AMD64HT_LDT_INIT_COMPLETE	0x00000002
#define  AMD64HT_LDT_NC			0x00000004

#define AMD64HT_LDT_SEC_BUS_NUM(reg)	(((reg) >> 8) & 0xff)

struct pchb_softc {
	struct device sc_dev;

	bus_space_tag_t sc_bt;
	bus_space_handle_t sc_bh;

	/* rng stuff */
	int sc_rng_active;
	int sc_rng_ax;
	int sc_rng_i;
	struct timeout sc_rng_to;
};

int	pchbmatch(struct device *, void *, void *);
void	pchbattach(struct device *, struct device *, void *);
int	pchbactivate(struct device *, int);

struct cfattach pchb_ca = {
	sizeof(struct pchb_softc), pchbmatch, pchbattach, NULL,
	pchbactivate
};

struct cfdriver pchb_cd = {
	NULL, "pchb", DV_DULL
};

int	pchb_print(void *, const char *);
void	pchb_rnd(void *);
void	pchb_amd64ht_attach(struct device *, struct pci_attach_args *, int);

int
pchbmatch(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

#ifdef __i386__
	/* XXX work around broken via82x866 chipsets */
	const struct pci_matchid via_devices[] = {
		{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT82C586_PWR },
		{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT82C596 },
		{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT82C596B_PM },
		{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT82C686A_SMB }
	};
	if (pci_matchbyid(pa, via_devices,
	    sizeof(via_devices) / sizeof(via_devices[0])))
		return (0);
#endif /* __i386__ */

	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_BRIDGE_HOST)
		return (1);

	return (0);
}

void
pchbattach(struct device *parent, struct device *self, void *aux)
{
	struct pchb_softc *sc = (struct pchb_softc *)self;
	struct pci_attach_args *pa = aux;
	struct pcibus_attach_args pba;
	pcireg_t bcreg, bir;
	u_char bdnum, pbnum;
	pcitag_t tag;
	int i, r;
	int doattach = 0;

	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_AMD:
		printf("\n");
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_AMD_AMD64_0F_HT:
		case PCI_PRODUCT_AMD_AMD64_10_HT:
			for (i = 0; i < AMD64HT_NUM_LDT; i++)
				pchb_amd64ht_attach(self, pa, i);
			break;
		}
		break;
#ifdef __i386__
	case PCI_VENDOR_RCC:
		{
			/*
			 * The variable below is a bit vector representing the
			 * Serverworks busses that have already been attached.
			 * Bit 0 represents bus 0 and so forth.  The initial
			 * value is 1 because we never actually want to
			 * attach bus 0 since bus 0 is the mainbus.
			 */
			static u_int32_t rcc_bus_visited = 1;

			printf("\n");
			bdnum = pci_conf_read(pa->pa_pc, pa->pa_tag, 0x44);
			if (bdnum >= (sizeof(rcc_bus_visited) * 8) ||
			    (rcc_bus_visited & (1 << bdnum)))
				break;

			rcc_bus_visited |= 1 << bdnum;

			/*
			 * This host bridge has a second PCI bus.
			 * Configure it.
			 */
			pbnum = bdnum;
			doattach = 1;
			break;
		}
#endif
	case PCI_VENDOR_INTEL:
		switch (PCI_PRODUCT(pa->pa_id)) {
#ifdef __i386__
		case PCI_PRODUCT_INTEL_82452_HB:
			bcreg = pci_conf_read(pa->pa_pc, pa->pa_tag, 0x40);
			pbnum = PCISET_INTEL_BRIDGE_NUMBER(bcreg);
			if (pbnum != 0xff) {
				pbnum++;
				doattach = 1;
			}
			break;
		case PCI_PRODUCT_INTEL_82443BX_AGP:     /* 82443BX AGP (PAC) */
		case PCI_PRODUCT_INTEL_82443BX_NOAGP:   /* 82443BX Host-PCI (no AGP) */
			/*
			 * An incorrect address may be driven on the
			 * DRAM bus, resulting in memory data being
			 * fetched from the wrong location.  This is
			 * the workaround.
			 */
			if (PCI_REVISION(pa->pa_class) < 0x3) {
				bcreg = pci_conf_read(pa->pa_pc, pa->pa_tag,
				    PCISET_INTEL_SDRAMC_REG);
				bcreg |= PCISET_INTEL_SDRAMC_IPDLT;
				pci_conf_write(pa->pa_pc, pa->pa_tag,
				    PCISET_INTEL_SDRAMC_REG, bcreg);
			}
			break;
		case PCI_PRODUCT_INTEL_PCI450_PB:
			bcreg = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    PCISET_INTEL_BUSCONFIG_REG);
			bdnum = PCISET_INTEL_BRIDGE_NUMBER(bcreg);
			pbnum = PCISET_INTEL_PCI_BUS_NUMBER(bcreg);
			switch (bdnum & PCISET_INTEL_BRIDGETYPE_MASK) {
			default:
				printf(": bdnum=%x (reserved)", bdnum);
				break;
			case PCISET_INTEL_TYPE_COMPAT:
				printf(": Compatibility PB (bus %d)", pbnum);
				break;
			case PCISET_INTEL_TYPE_AUX:
				printf(": Auxiliary PB (bus %d)", pbnum);
				doattach = 1;
			}
			break;
		case PCI_PRODUCT_INTEL_CDC:
			bcreg = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    I82424_CPU_BCTL_REG);
			if (bcreg & I82424_BCTL_CPUPCI_POSTEN) {
				bcreg &= ~I82424_BCTL_CPUPCI_POSTEN;
				pci_conf_write(pa->pa_pc, pa->pa_tag,
				    I82424_CPU_BCTL_REG, bcreg);
				printf(": disabled CPU-PCI write posting");
			}
			break;
		case PCI_PRODUCT_INTEL_82454NX:
			pbnum = 0;
			switch (pa->pa_device) {
			case 18: /* PXB 0 bus A - primary bus */
				break;
			case 19: /* PXB 0 bus B */
				/* read SUBA0 from MIOC */
				tag = pci_make_tag(pa->pa_pc, 0, 16, 0);
				bcreg = pci_conf_read(pa->pa_pc, tag, 0xd0);
				pbnum = ((bcreg & 0x0000ff00) >> 8) + 1;
				break;
			case 20: /* PXB 1 bus A */
				/* read BUSNO1 from MIOC */
				tag = pci_make_tag(pa->pa_pc, 0, 16, 0);
				bcreg = pci_conf_read(pa->pa_pc, tag, 0xd0);
				pbnum = (bcreg & 0xff000000) >> 24;
				break;
			case 21: /* PXB 1 bus B */
				/* read SUBA1 from MIOC */
				tag = pci_make_tag(pa->pa_pc, 0, 16, 0);
				bcreg = pci_conf_read(pa->pa_pc, tag, 0xd4);
				pbnum = (bcreg & 0x000000ff) + 1;
				break;
			}
			if (pbnum != 0)
				doattach = 1;
			break;
		/* RNG */
		case PCI_PRODUCT_INTEL_82810_HB:
		case PCI_PRODUCT_INTEL_82810_DC100_HB:
		case PCI_PRODUCT_INTEL_82810E_HB:
		case PCI_PRODUCT_INTEL_82815_HB:
		case PCI_PRODUCT_INTEL_82820_HB:
		case PCI_PRODUCT_INTEL_82840_HB:
		case PCI_PRODUCT_INTEL_82850_HB:
		case PCI_PRODUCT_INTEL_82860_HB:
#endif /* __i386__ */
		case PCI_PRODUCT_INTEL_82915G_HB:
		case PCI_PRODUCT_INTEL_82945G_HB:
		case PCI_PRODUCT_INTEL_82925X_HB:
		case PCI_PRODUCT_INTEL_82955X_HB:
			sc->sc_bt = pa->pa_memt;
			if (bus_space_map(sc->sc_bt, I82802_IOBASE,
			    I82802_IOSIZE, 0, &sc->sc_bh))
				break;

			/* probe and init rng */
			if (!(bus_space_read_1(sc->sc_bt, sc->sc_bh,
			    I82802_RNG_HWST) & I82802_RNG_HWST_PRESENT))
				break;

			/* enable RNG */
			bus_space_write_1(sc->sc_bt, sc->sc_bh,
			    I82802_RNG_HWST,
			    bus_space_read_1(sc->sc_bt, sc->sc_bh,
			    I82802_RNG_HWST) | I82802_RNG_HWST_ENABLE);

			/* see if we can read anything */
			for (i = 1000; i-- &&
			    !(bus_space_read_1(sc->sc_bt, sc->sc_bh,
			    I82802_RNG_RNGST) & I82802_RNG_RNGST_DATAV); )
				DELAY(10);

			if (!(bus_space_read_1(sc->sc_bt, sc->sc_bh,
			    I82802_RNG_RNGST) & I82802_RNG_RNGST_DATAV))
				break;

			r = bus_space_read_1(sc->sc_bt, sc->sc_bh,
			    I82802_RNG_DATA);

			timeout_set(&sc->sc_rng_to, pchb_rnd, sc);
			sc->sc_rng_i = 4;
			pchb_rnd(sc);
			sc->sc_rng_active = 1;
			break;
		}
		printf("\n");
		break;
	case PCI_VENDOR_VIATECH:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_VIATECH_VT8251_PCIE_0:
			/*
			 * Bump the host bridge into PCI-PCI bridge
			 * mode by clearing magic bit on the VLINK
			 * device.  This allows us to read the bus
			 * number for the PCI bus attached to this
			 * host bridge.
			 */
			tag = pci_make_tag(pa->pa_pc, 0, 17, 7);
			bcreg = pci_conf_read(pa->pa_pc, tag, 0xfc);
			bcreg &= ~0x00000004; /* XXX Magic */
			pci_conf_write(pa->pa_pc, tag, 0xfc, bcreg);

			bir = pci_conf_read(pa->pa_pc,
			    pa->pa_tag, PPB_REG_BUSINFO);
			pbnum = PPB_BUSINFO_PRIMARY(bir);
			if (pbnum > 0)
				doattach = 1;

			/* Switch back to host bridge mode. */
			bcreg |= 0x00000004; /* XXX Magic */
			pci_conf_write(pa->pa_pc, tag, 0xfc, bcreg);
			break;
		}
		printf("\n");
		break;
	default:
		printf("\n");
		break;
	}

#if NAGP > 0
	/*
	 * Intel IGD have an odd interface and attach at vga, however,
	 * in that mode they don't have the AGP cap bit, so this
	 * test should be sufficient
	 */
	if (pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_AGP,
	    NULL, NULL) != 0) {
		struct agp_attach_args	aa;
		aa.aa_busname = "agp";
		aa.aa_pa = pa;

		config_found(self, &aa, agpdev_print);
	}
#endif /* NAGP > 0 */

	if (doattach == 0)
		return;

	bzero(&pba, sizeof(pba));
	pba.pba_busname = "pci";
	pba.pba_iot = pa->pa_iot;
	pba.pba_memt = pa->pa_memt;
	pba.pba_dmat = pa->pa_dmat;
	pba.pba_busex = pa->pa_busex;
	pba.pba_domain = pa->pa_domain;
	pba.pba_bus = pbnum;
	pba.pba_pc = pa->pa_pc;
	config_found(self, &pba, pchb_print);
}

int
pchbactivate(struct device *self, int act)
{
	struct pchb_softc *sc = (struct pchb_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_RESUME:
		/* re-enable RNG, if we have it */
		if (sc->sc_rng_active)
			bus_space_write_1(sc->sc_bt, sc->sc_bh,
			    I82802_RNG_HWST,
			    bus_space_read_1(sc->sc_bt, sc->sc_bh,
			    I82802_RNG_HWST) | I82802_RNG_HWST_ENABLE);
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}


int
pchb_print(void *aux, const char *pnp)
{
	struct pcibus_attach_args *pba = aux;

	if (pnp)
		printf("%s at %s", pba->pba_busname, pnp);
	printf(" bus %d", pba->pba_bus);
	return (UNCONF);
}

/*
 * Should do FIPS testing as per:
 *	http://csrc.nist.gov/publications/fips/fips140-1/fips1401.pdf
 */
void
pchb_rnd(void *v)
{
	struct pchb_softc *sc = v;

	/*
	 * Don't wait for data to be ready. If it's not there, we'll check
	 * next time.
	 */
	if ((bus_space_read_1(sc->sc_bt, sc->sc_bh, I82802_RNG_RNGST) &
	    I82802_RNG_RNGST_DATAV)) {

		sc->sc_rng_ax = (sc->sc_rng_ax << 8) |
		    bus_space_read_1(sc->sc_bt, sc->sc_bh, I82802_RNG_DATA);

		if (!sc->sc_rng_i--) {
			sc->sc_rng_i = 4;
			add_true_randomness(sc->sc_rng_ax);
		}
	}

	timeout_add(&sc->sc_rng_to, 1);
}

void
pchb_amd64ht_attach(struct device *self, struct pci_attach_args *pa, int i)
{
	struct pcibus_attach_args pba;
	pcireg_t type, bus;
	int reg;

	reg = AMD64HT_LDT0_TYPE + i * 0x20;
	type = pci_conf_read(pa->pa_pc, pa->pa_tag, reg);
	if ((type & AMD64HT_LDT_INIT_COMPLETE) == 0 ||
	    (type & AMD64HT_LDT_NC) == 0)
		return;

	reg = AMD64HT_LDT0_BUS + i * 0x20;
	bus = pci_conf_read(pa->pa_pc, pa->pa_tag, reg);
	if (AMD64HT_LDT_SEC_BUS_NUM(bus) > 0) {
		bzero(&pba, sizeof(pba));
		pba.pba_busname = "pci";
		pba.pba_iot = pa->pa_iot;
		pba.pba_memt = pa->pa_memt;
		pba.pba_dmat = pa->pa_dmat;
		pba.pba_busex = pa->pa_busex;
		pba.pba_domain = pa->pa_domain;
		pba.pba_bus = AMD64HT_LDT_SEC_BUS_NUM(bus);
		pba.pba_pc = pa->pa_pc;
		config_found(self, &pba, pchb_print);
	}
}
@


1.88
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.87 2012/10/08 21:47:48 deraadt Exp $ */
d62 1
@


1.87
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.86 2012/09/19 23:03:12 kettenis Exp $ */
a425 9
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);
		break;
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		break;
d433 3
@


1.86
log
@Set up PCI bus number resource accounting for the main PCI bus hierarchy.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.85 2010/08/31 17:13:46 deraadt Exp $ */
d430 3
@


1.85
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.84 2010/08/31 16:17:18 deraadt Exp $ */
d412 1
d506 1
@


1.84
log
@pchbactivate should return result of config_activate_children
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.83 2010/08/07 06:10:06 deraadt Exp $ */
d425 3
@


1.83
log
@On resume, re-activate the host RNG on the host bridges that need it.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.82 2010/06/24 00:06:57 kettenis Exp $ */
d422 1
d426 1
a426 1
		config_activate_children(self, act);
d435 1
a435 1
		config_activate_children(self, act);
d438 1
a438 1
	return (0);
@


1.82
log
@The new AMD Opteron CPUs have up to 4 HyperTransport links instead of 3.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.81 2010/04/02 19:23:05 kettenis Exp $ */
d123 1
d131 1
d135 1
a135 1
	config_activate_children
d350 1
d417 23
@


1.81
log
@For the VT8251 host bridge, only attach the pci bus is non-zero, otherwise
keep attaching bus 0 forever.

tested by mk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.80 2010/02/09 19:36:05 kettenis Exp $ */
d105 2
d108 1
a108 1
#define AMD64HT_NUM_LDT		3
@


1.80
log
@Switching the strange VIA VT8251 PCIE host bridge into a PCI-PCI bridge
didn't quite work since the bridge seems to end up largely unconfigured, and
our PCI resource configuration code isn't quite smart enough (yet) to fix
things up.  So instead switch it only into PCI-PCI bridge mode long enough to
snoop the bus number, and attach pci(4) using that number.

This is probably safer anyway, since ACPI may not like us switching things
around behind its back.  Fixes PR 6253 & 6304.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.79 2009/11/23 15:33:37 deraadt Exp $ */
d368 2
a369 1
			doattach = 1;
@


1.79
log
@pchb must walk children too
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.78 2009/09/18 20:17:17 kettenis Exp $ */
d70 1
d173 1
a173 1
	pcireg_t bcreg;
d352 1
a352 1
		case PCI_PRODUCT_VIATECH_VT8251_VLINK:
d354 5
a358 5
			 * For some strange reason, the VIA VT8251
			 * chipset can be configured to its PCIe
			 * bridge show up as a host bridge.  We whack
			 * it into PCI bridge mode here such that we
			 * can see the devices behind it.
d360 2
a361 1
			bcreg = pci_conf_read(pa->pa_pc, pa->pa_tag, 0xfc);
d363 10
a372 1
			pci_conf_write(pa->pa_pc, pa->pa_tag, 0xfc, bcreg);
d397 1
a397 1
#ifdef __i386__
a409 1
#endif /* __i386__ */
@


1.78
log
@For some dark reason there's a bit on the VLINK device of this chipset
that makes the PCIE device show up as a host bridge instead of a
PCI-PCI bridge.  As a result any devices sitting behind it won't be
detected.  Whack the device into PCI-PCI mode such that we can walk the
PCI bus hierarchy the normal way and detect all devices.  Fixes PR 6215.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.77 2009/04/11 14:59:59 kettenis Exp $ */
d129 2
a130 1
	sizeof(struct pchb_softc), pchbmatch, pchbattach
@


1.77
log
@There is no support for building multi-socket machines in AMD Family 11h
processors, so the registers to configure addition HyperTransport links
are absent.  Don't try attaching addition pci busses on these processors
to avoid probing non-existant registers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.76 2009/03/31 21:57:57 kettenis Exp $ */
d344 17
@


1.76
log
@bzero pci attach args
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.75 2008/11/09 15:11:19 oga Exp $ */
a182 1
		case PCI_PRODUCT_AMD_AMD64_11_HT:
@


1.75
log
@Rework that way that agp attaches.

previously, we had a static list of pcidevs and which agp driver would
be interanlly attached. Instead, split the agp drivers so they work like
audio(4), where we attach a driver, which sets up some callbacks and
initial state, then attaches the interface (agp(4)). Since this allows
us to attach different drivers in different places, and give them
/proper/ probe functions move most of the drivers back to attaching at
pchb, where they should, and intagp (formerly agp_i810) stays attaching
at vga, since it's part of the intel integrated graphics chips.

Diff shrinks the kernel slightly, gets rid of the annoying "no integrated
graphics" warning, and allows more cleanup later.

Tested by many. fix for alpha build (the only other vga_pci.c consumer)
suggested by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.74 2008/09/26 21:15:53 mikeb Exp $ */
a213 1
			pba.pba_bridgetag = NULL;
d373 1
a379 1
	pba.pba_bridgetag = NULL;
d440 1
a446 1
		pba.pba_bridgetag = NULL;
@


1.74
log
@Attach agp(4) to the Intel Q35 integrated video.
Tested on ASUS P5E-VM DO motherboard.

ok oga
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.73 2008/07/07 07:54:48 bernd Exp $ */
d174 1
a174 1
	int has_agp = 0, i, r;
a180 6
#ifdef __i386__
		case PCI_PRODUCT_AMD_SC751_SC:
		case PCI_PRODUCT_AMD_762_PCHB:
			has_agp = 1; /* XXX is this detected otherwise */
			break;
#endif /* __i386__ */
d300 1
a300 32
#endif /* __i386__ */

		/*
		 * As for Intel AGP, the host bridge is either in GFX mode
		 * (internal graphics) or in AGP mode. In GFX mode, we pretend
		 * to have AGP because the graphics memory access is very
		 * similar and the AGP GATT code will deal with this. In the
		 * latter case, the pci_get_capability(PCI_CAP_AGP) test below
		 * will fire, so we do no harm by already setting the flag.
		 */

		/* AGP only */
#ifdef __i386__
		case PCI_PRODUCT_INTEL_82830M_HB:
		case PCI_PRODUCT_INTEL_82845G_HB:
		case PCI_PRODUCT_INTEL_82855GM_HB:
		case PCI_PRODUCT_INTEL_82865G_HB:
#endif /* __i386__ */
		case PCI_PRODUCT_INTEL_82915GM_HB:
		case PCI_PRODUCT_INTEL_82945GM_HB:
		case PCI_PRODUCT_INTEL_82945GME_HB:
		case PCI_PRODUCT_INTEL_82G965_HB:
		case PCI_PRODUCT_INTEL_82Q965_HB:
		case PCI_PRODUCT_INTEL_82GM965_HB:
		case PCI_PRODUCT_INTEL_82G33_HB:
		case PCI_PRODUCT_INTEL_82G35_HB:
		case PCI_PRODUCT_INTEL_82Q35_HB:
			has_agp = 1;
			break;

		/* AGP + RNG */
#ifdef __i386__
a304 8
#endif /* __i386__ */
		case PCI_PRODUCT_INTEL_82915G_HB:
		case PCI_PRODUCT_INTEL_82945G_HB:
			has_agp = 1;
			/* FALLTHROUGH */

		/* RNG only */
#ifdef __i386__
d310 2
d357 3
a359 2
	 * If we haven't detected AGP yet (via a product ID),
	 * then check for AGP capability on the device.
d361 8
a368 4
	if (has_agp ||
	    pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_AGP,
	    NULL, NULL) != 0)
		agp_set_pchb(pa);
@


1.73
log
@Add AGP and hostbridge support for the Intel 82945GME chipset.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.72 2008/06/26 05:42:11 ray Exp $ */
d332 1
@


1.72
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.71 2008/06/25 18:54:06 oga Exp $ */
d326 1
@


1.71
log
@Support the Intel G35 which apparently works similarly to the 965.

Initial information, half the diff, and testing from Andrew Lutomirski,
thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.70 2008/06/05 09:45:14 brad Exp $ */
a43 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.70
log
@Allow pchb(4) to find additional non-coherent HyperTransport links
with 10h and 11h families of AMD CPU's.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.69 2008/04/28 06:17:47 brad Exp $ */
d337 1
@


1.69
log
@Sync PCI ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.68 2008/03/23 08:36:41 damien Exp $ */
d195 2
@


1.68
log
@Add AGP support for the Intel G33 chipset.
Tested on i386 with a Gigabyte G33M-DS2R motherboard (Intel GMA 3100).
Based on NetBSD code.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.67 2008/03/16 19:00:28 oga Exp $ */
d194 1
a194 1
		case PCI_PRODUCT_AMD_AMD64_HT:
@


1.67
log
@Make agp(4) attach at vga(4) instead of pchb(4). This is because sometimes
agp and drm need to use the same memory mapping, the best way to deal
with that is to allow them to share (that's coming later), for this to
work cleanly we move the attach point of agp.

Ideally most agp drivers would attach at pchb, with only agp_i810
(and any that work similarly) attaching at vga, but this will do for
now.

ok kettenis@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.66 2008/01/04 00:23:25 kettenis Exp $ */
d334 1
@


1.66
log
@Clean up Intel host bridge PCI IDs.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.65 2007/12/18 22:56:45 kettenis Exp $ */
d82 2
a143 1
int	agpbus_print(void *, const char *);
a177 1
	struct agpbus_attach_args apa;
d399 1
d406 3
a408 5
	    NULL, NULL) != 0) {
		apa.apa_busname = "agp";
		apa.apa_pci_args = *pa;
		config_found(self, &apa, agpbus_print);
	}
a432 8
	return (UNCONF);
}

int
agpbus_print(void *vaa, const char *pnp)
{
	if (pnp)
		printf("agp at %s", pnp);
@


1.65
log
@Remove bogus #ifdef __i386__, such that we properly initialize the bus number
for pci busses off secundary CPUs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.64 2007/12/01 15:16:45 deraadt Exp $ */
d324 4
a327 4
		case PCI_PRODUCT_INTEL_82830MP_IO_1:
		case PCI_PRODUCT_INTEL_82845G:
		case PCI_PRODUCT_INTEL_82852GM_HPB:
		case PCI_PRODUCT_INTEL_82865_IO_1:
d330 4
a333 4
		case PCI_PRODUCT_INTEL_82945GM_MCH:
		case PCI_PRODUCT_INTEL_82965GM_MCH:
		case PCI_PRODUCT_INTEL_82965_MCH:
		case PCI_PRODUCT_INTEL_82Q963_HB:
d339 4
a342 4
		case PCI_PRODUCT_INTEL_82810E_MCH:
		case PCI_PRODUCT_INTEL_82810_DC100_MCH:
		case PCI_PRODUCT_INTEL_82810_MCH:
		case PCI_PRODUCT_INTEL_82815_FULL_HUB:
d345 1
a345 1
		case PCI_PRODUCT_INTEL_82945GP_MCH:
d351 1
a351 4
		case PCI_PRODUCT_INTEL_82815_DC100_HUB:
		case PCI_PRODUCT_INTEL_82815_NOAGP_HUB:
		case PCI_PRODUCT_INTEL_82815_NOGRAPH_HUB:
		case PCI_PRODUCT_INTEL_82820_MCH:
@


1.64
log
@Don't double attach serverworks subsidiary pci busses, introduced by
oga during the agp merge.  Lost a few follicles over this one..
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.63 2007/11/29 11:12:57 deraadt Exp $ */
a495 1
#ifdef __i386__
a496 1
#else
a497 1
#endif
@


1.63
log
@repair case of agp & subsidiary busses; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.62 2007/11/27 15:40:56 deraadt Exp $ */
a424 3
	config_found(self, &pba, pchb_print);
	pba.pba_bridgetag = NULL;
	memset(&pba.pba_intrtag, 0, sizeof(pba.pba_intrtag));
@


1.62
log
@Unify amd64 and i386 code further; ok oga kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.61 2007/11/26 19:52:09 deraadt Exp $ */
d182 1
d226 2
a227 1
			goto doattach;
d238 1
a238 1
				goto doattach;
d271 1
a271 1
				goto doattach;
d309 1
a309 1
				goto doattach;
d414 3
a416 2
	return;
doattach:
@


1.61
log
@First step towards unifying pchb between i386 and amd64
Light testing, mostly mechanical
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.60 2007/11/26 15:35:17 deraadt Exp $ */
a170 8
/*
 * The variable below is a bit vector representing the Serverworks
 * busses that have already been attached.  Bit 0 represents bus 0 and
 * so forth.  The initial value is 1 because we never actually want to
 * attach bus 0 since bus 0 is the mainbus.
 */
u_int32_t rcc_bus_visited = 1;

d181 1
a181 5
	int doattach = 0, has_agp = 0, i, r;

	/*
	 * configure certain chipsets which have auxiliary PCI buses.
	 */
d187 1
d192 1
d199 1
d201 15
a215 5
		printf("\n");
		bdnum = pci_conf_read(pa->pa_pc, pa->pa_tag, 0x44);
		if (bdnum >= (sizeof(rcc_bus_visited) * 8) ||
		    (rcc_bus_visited & (1 << bdnum)))
			break;
d217 1
a217 1
		rcc_bus_visited |= 1 << bdnum;
d219 9
a227 8
		/*
		 * This host bridge has a second PCI bus.
		 * Configure it.
		 */
		pbnum = bdnum;
		pba.pba_bridgetag = NULL;
		doattach = 1;
		break;
d230 1
d236 1
a236 1
				doattach = 1;
d269 1
a269 7

				/*
				 * This host bridge has a second PCI bus.
				 * Configure it.
				 */
				doattach = 1;
				break;
d306 2
a307 3
			if (pbnum != 0) {
				doattach = 1;
			}
d309 13
a321 4
		case PCI_PRODUCT_INTEL_82810_MCH:
		case PCI_PRODUCT_INTEL_82810_DC100_MCH:
		case PCI_PRODUCT_INTEL_82810E_MCH:
		case PCI_PRODUCT_INTEL_82815_FULL_HUB:
d326 1
a326 1
		case PCI_PRODUCT_INTEL_82915G_HB:
a327 1
		case PCI_PRODUCT_INTEL_82945GP_MCH:
d329 2
a331 11
		case PCI_PRODUCT_INTEL_82965_MCH:
		case PCI_PRODUCT_INTEL_82965GM_MCH:
			/*
			 * The host bridge is either in GFX mode (internal
			 * graphics) or in AGP mode. In GFX mode, we pretend
			 * to have AGP because the graphics memory access
			 * is very similar and the AGP GATT code will
			 * deal with this. In the latter case, the
			 * pci_get_capability(PCI_CAP_AGP) test below will
			 * fire, so we do no harm by already setting the flag.
			 */
a333 7
		}
		printf("\n");
		break;
	default:
		printf("\n");
		break;
	}
d335 4
a338 7
	/*
	 * Now set up RNG.  this isn't in previous switch since only
	 * some of the rng devices need special attention for AGP
	 */
	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_INTEL:
		switch (PCI_PRODUCT(pa->pa_id)) {
d340 9
a348 2
		case PCI_PRODUCT_INTEL_82810_DC100_MCH:
		case PCI_PRODUCT_INTEL_82810E_MCH:
d350 1
a351 2
		case PCI_PRODUCT_INTEL_82815_FULL_HUB:
		case PCI_PRODUCT_INTEL_82815_NOAGP_HUB:
d356 1
a356 1
		case PCI_PRODUCT_INTEL_82915G_HB:
a357 1
		case PCI_PRODUCT_INTEL_82945GP_MCH:
d393 5
d411 16
a426 15

	if (doattach) {
		pba.pba_busname = "pci";
		pba.pba_iot = pa->pa_iot;
		pba.pba_memt = pa->pa_memt;
		pba.pba_dmat = pa->pa_dmat;
		pba.pba_domain = pa->pa_domain;
		pba.pba_bus = pbnum;
		pba.pba_bridgetag = NULL;
		pba.pba_pc = pa->pa_pc;
		config_found(self, &pba, pchb_print);
		pba.pba_bridgetag = NULL;
		memset(&pba.pba_intrtag, 0, sizeof(pba.pba_intrtag));
		config_found(self, &pba, pchb_print);
	}
d496 1
d498 1
d500 2
@


1.60
log
@correct newlines surrounding the sub-bus configuration, and unify
pchb's further
ok reyk oga
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.59 2007/11/26 10:35:42 reyk Exp $ */
a67 1
#include <sys/proc.h>
a75 1
#include <dev/pci/agpreg.h>
d121 2
a122 2
	bus_space_tag_t bt;
	bus_space_handle_t bh;
d125 3
a127 3
	int ax;
	int i;
	struct timeout sc_tmo;
a132 3
int	pchb_print(void *, const char *);
int	agpbus_print(void *, const char *);

d141 3
a143 1
void pchb_rnd(void *v);
a145 7
const struct pci_matchid via_devices[] = {
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT82C586_PWR },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT82C596 },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT82C596B_PM },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT82C686A_SMB }
};

d151 1
d153 6
d162 1
d189 1
a189 4
	int doattach, has_agp, i, r;

	doattach = 0;
	has_agp = 0;
d369 3
a371 3
			sc->bt = pa->pa_memt;
			if (bus_space_map(sc->bt, I82802_IOBASE, I82802_IOSIZE,
			    0, &sc->bh))
d375 1
a375 1
			if (!(bus_space_read_1(sc->bt, sc->bh,
d380 4
a383 3
			bus_space_write_1(sc->bt, sc->bh, I82802_RNG_HWST,
			    bus_space_read_1(sc->bt, sc->bh, I82802_RNG_HWST) |
			    I82802_RNG_HWST_ENABLE);
d387 3
a389 3
			    !(bus_space_read_1(sc->bt,sc->bh,I82802_RNG_RNGST)&
			      I82802_RNG_RNGST_DATAV);
			    DELAY(10));
d391 1
a391 1
			if (!(bus_space_read_1(sc->bt, sc->bh,
d395 2
a396 1
			r = bus_space_read_1(sc->bt, sc->bh, I82802_RNG_DATA);
d398 2
a399 2
			timeout_set(&sc->sc_tmo, pchb_rnd, sc);
			sc->i = 4;
a401 2
		default:
			break;
d411 1
a411 1
			       NULL, NULL) != 0) {
d465 1
a465 1
	if ((bus_space_read_1(sc->bt, sc->bh, I82802_RNG_RNGST) &
d468 2
a469 2
		sc->ax = (sc->ax << 8) |
		    bus_space_read_1(sc->bt, sc->bh, I82802_RNG_DATA);
d471 3
a473 3
		if (!sc->i--) {
			sc->i = 4;
			add_true_randomness(sc->ax);
d477 1
a477 1
	timeout_add(&sc->sc_tmo, 1);
@


1.59
log
@fix new agp code on amd64
- internal intel graphics semi-agp chipsets need special handling in pchb.c
- re-add the i965GM device
- use the correct major device id for /dev/agp0 on amd64 (not the i386 one)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.58 2007/11/25 17:11:12 oga Exp $ */
d147 1
a147 1
void	pchb_amd64ht_attach (struct device *, struct pci_attach_args *, int);
d202 1
d206 1
a206 1
			has_agp =1; /* XXX is this detected otherwise */
a208 1
			printf("\n");
d215 1
d345 4
a349 2
		default:
			break;
a416 1
		printf("\n");
a419 1
		printf("\n");
a430 1
		printf("\n");
d486 1
a486 1
pchb_amd64ht_attach (struct device *self, struct pci_attach_args *pa, int i)
@


1.58
log
@Make agp attach as a device. This means that many more agp bridges
actually get detected and attached. Also adds a kernel api for
manipulating agp.

Enable this on i386 and amd64.

"I think you should commit it" deraadt@@, ok matthieu. Looked over by
several others.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d331 1
@


1.57
log
@Remove microtime calls and RNG benchmarking from the pchb attachment
code.  This is due to the fact that we do timecounter initialization
after autoconf(9).

ok deraadt
@
text
@d1 2
a2 2
/*	$OpenBSD: pchb.c,v 1.56 2007/06/01 22:45:17 biorn Exp $	*/
/*	$NetBSD: pchb.c,v 1.6 1997/06/06 23:29:16 thorpej Exp $	*/
d30 1
a30 1
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
d77 3
d136 1
d187 1
d191 4
a194 2
	int neednl = 1;
	int i, r;
d197 1
a197 2
	 * Print out a description, and configure certain chipsets which
	 * have auxiliary PCI buses.
a200 7
#ifdef PCIAGP
	case PCI_VENDOR_ALI:
	case PCI_VENDOR_SIS:
	case PCI_VENDOR_VIATECH:
		pciagp_set_pchb(pa);
		break;
#endif
a202 1
#ifdef PCIAGP
d205 1
a205 1
			pciagp_set_pchb(pa);
a206 1
#endif
a207 1
			neednl = 0;
d226 1
a226 7
		neednl = 0;
		pba.pba_busname = "pci";
		pba.pba_iot = pa->pa_iot;
		pba.pba_memt = pa->pa_memt;
		pba.pba_dmat = pa->pa_dmat;
		pba.pba_domain = pa->pa_domain;
		pba.pba_bus = bdnum;
d228 1
a228 3
		pba.pba_pc = pa->pa_pc;
		printf("\n");
		config_found(self, &pba, pchb_print);
a230 3
#ifdef PCIAGP
		pciagp_set_pchb(pa);
#endif
d232 8
a269 1
				neednl = 0;
d275 1
a275 9
				pba.pba_busname = "pci";
				pba.pba_iot = pa->pa_iot;
				pba.pba_memt = pa->pa_memt;
				pba.pba_dmat = pa->pa_dmat;
				pba.pba_domain = pa->pa_domain;
				pba.pba_bus = pbnum;
				pba.pba_pc = pa->pa_pc;
				printf("\n");
				config_found(self, &pba, pchb_print);
d279 10
d314 1
a314 9
				pba.pba_busname = "pci";
				pba.pba_iot = pa->pa_iot;
				pba.pba_memt = pa->pa_memt;
				pba.pba_dmat = pa->pa_dmat;
				pba.pba_domain = pa->pa_domain;
				pba.pba_bus = pbnum;
				pba.pba_pc = pa->pa_pc;
				printf("\n");
				config_found(self, &pba, pchb_print);
d317 28
a344 9
		case PCI_PRODUCT_INTEL_CDC:
			bcreg = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    I82424_CPU_BCTL_REG);
			if (bcreg & I82424_BCTL_CPUPCI_POSTEN) {
				bcreg &= ~I82424_BCTL_CPUPCI_POSTEN;
				pci_conf_write(pa->pa_pc, pa->pa_tag,
				    I82424_CPU_BCTL_REG, bcreg);
				printf(": disabled CPU-PCI write posting");
			}
d346 9
d405 8
a412 1
	if (neednl)
d414 21
d445 8
@


1.56
log
@Revert INTEL_82915GM part of tedu's commit as it hung my T43

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.55 2007/05/31 22:35:48 tedu Exp $	*/
a182 1
	struct timeval tv1, tv2;
a381 19

			/* benchmark the RNG */
			microtime(&tv1);
			for (i = 8 * 1024; i--; ) {
				while(!(bus_space_read_1(sc->bt, sc->bh,
				    I82802_RNG_RNGST) & I82802_RNG_RNGST_DATAV))
					;
				r = bus_space_read_1(sc->bt, sc->bh,
				    I82802_RNG_DATA);
			}
			microtime(&tv2);

			timersub(&tv2, &tv1, &tv1);
			if (tv1.tv_sec)
				tv1.tv_usec += 1000000 * tv1.tv_sec;
			printf(": rng active");
			if (tv1.tv_usec != 0)
				printf(", %dKb/sec",
				    8 * 1000000 / tv1.tv_usec);
@


1.55
log
@some more pchb that have rnd powers, IDs from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.54 2006/12/14 17:36:12 kettenis Exp $	*/
a353 1
		case PCI_PRODUCT_INTEL_82915GM_HB:
@


1.54
log
@Make pci subsystem aware of domains.  Each host bridge gets assigned a unique
domain number such that we can distinguish between busses with the same bus
number that are behind different host bridges.  Domains can be accessed by
using different device nodes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.53 2006/09/19 11:06:34 jsg Exp $	*/
d353 5
@


1.53
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.52 2006/03/13 20:10:49 brad Exp $	*/
d236 1
d288 1
d325 1
d470 1
@


1.52
log
@* Add "pcitag_t *pba_bridgetag" to pci_attach_args.  This is set to
  NULL for root PCI busses.  For busses behind a bridge, it points to
  a persistent copy of the bridge's pcitag_t.  This can be very useful
  for machine-dependent PCI bus enumeration code.

From NetBSD

ok grange@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.51 2006/02/14 13:42:54 kettenis Exp $	*/
d153 1
a153 3
pchbmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d178 1
a178 3
pchbattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d409 1
a409 3
pchb_print(aux, pnp)
	void *aux;
	const char *pnp;
d424 1
a424 2
pchb_rnd(v)
	void *v;
@


1.51
log
@Find additional noncoherent HyperTransport links by looking at the
HyperTransport configuration on AMD Athlon 64 & Opteron CPU's.  This makes us
detect the missing PCI busses on various Opteron systems.
tested by krw@@, brad@@; ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.50 2005/12/29 04:26:17 brad Exp $	*/
d241 1
@


1.50
log
@remove bad newline for the secondary PCI bus with the 82450KX/GX chipset
which was introduced in rev 1.11.

thanks to marco@@ for pointing out the issue, testing and ok'ing the diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.49 2005/06/14 20:35:45 deraadt Exp $	*/
d101 16
d143 1
d206 1
d209 1
d214 7
a222 1
#endif
d451 26
@


1.49
log
@back out SMM lockdown patch until some other solution is found.
SMM lockdown breaks apm on a few machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.45 2005/03/09 21:53:49 hshoexer Exp $	*/
d254 1
a254 1
				printf(": Auxiliary PB (bus %d)\n", pbnum);
@


1.48
log
@Lock SMM space on Intel E7xxx chipsets, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.47 2005/05/29 17:27:16 grange Exp $	*/
a79 1
#include <dev/ic/i82810reg.h>
a378 34
			break;
		}

		/* Lock down SMM space on i82810 and later chipsets */
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_INTEL_82810_MCH:
		case PCI_PRODUCT_INTEL_82810_DC100_MCH:
		case PCI_PRODUCT_INTEL_82810E_MCH:
		case PCI_PRODUCT_INTEL_82815_DC100_HUB:
		case PCI_PRODUCT_INTEL_82815_NOGRAPH_HUB:
		case PCI_PRODUCT_INTEL_82815_FULL_HUB:
		case PCI_PRODUCT_INTEL_82815_NOAGP_HUB:
			bcreg = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    I82810_SMRAM);
			bcreg |= I82810_SMRAM_D_LCK;
			pci_conf_write(pa->pa_pc, pa->pa_tag,
			    I82810_SMRAM, bcreg);
			break;
		case PCI_PRODUCT_INTEL_82820_MCH:
		case PCI_PRODUCT_INTEL_82840_HB:
		case PCI_PRODUCT_INTEL_82845_HB:
		case PCI_PRODUCT_INTEL_82845G:
		case PCI_PRODUCT_INTEL_82850_HB:
		case PCI_PRODUCT_INTEL_82855PE:
		case PCI_PRODUCT_INTEL_82860_HB:
		case PCI_PRODUCT_INTEL_82875P_HB:
		case PCI_PRODUCT_INTEL_E7221_HB:
		case PCI_PRODUCT_INTEL_E7501_HB:
		case PCI_PRODUCT_INTEL_E7710_SMCH:
			bcreg = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    I82820_SMRAM);
			bcreg |= (I82820_SMRAM_D_LCK << I82820_SMRAM_SHIFT);
			pci_conf_write(pa->pa_pc, pa->pa_tag,
			    I82820_SMRAM, bcreg);
@


1.47
log
@Remove debug printf I left.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.46 2005/05/19 19:41:01 grange Exp $	*/
d406 3
@


1.46
log
@Lock down SMM space on i82810 MCH and later chips in case BIOS
didn't it already for us.

Reported by loic.duflot@@sgdn.pm.gouv.fr via deraadt@@.

ok deraadt@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.45 2005/03/09 21:53:49 hshoexer Exp $	*/
a407 1
			printf(": SMRAM 0x%x", bcreg);
@


1.45
log
@access to the configuration address register of the 82443BX host bridge needs
to be 32bit aligned.

deraadt@@ just commit
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.44 2005/01/13 00:43:01 brad Exp $	*/
d80 1
d380 32
@


1.44
log
@HTML page does not seem to exist anymore so point to the PDF for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.43 2005/01/12 18:19:05 grange Exp $	*/
d89 2
a90 2
#define PCISET_INTEL_SDRAMC_REG	0x76
#define PCISET_INTEL_SDRAMC_IPDLT	(1 << 8)
@


1.43
log
@Intel 82443BX DRAM address errata seems to be fixed in the latest revisions
of the chipset.

Inspired from netbsd pr by scottr@@NetBSD.org.
ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.42 2004/11/23 13:33:14 grange Exp $	*/
d401 1
a401 1
 *	http://csrc.nist.gov/publications/fips/fips140-1/fips1401.htm
@


1.42
log
@Use pci_matchbyid() for matching crazy VIA power management controllers
and add a few ones.

``valiay'' mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.41 2003/11/07 16:43:08 mickey Exp $	*/
d233 7
a239 5
			bcreg = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    PCISET_INTEL_SDRAMC_REG);
			bcreg |= PCISET_INTEL_SDRAMC_IPDLT;
			pci_conf_write(pa->pa_pc, pa->pa_tag,
			    PCISET_INTEL_SDRAMC_REG, bcreg);
@


1.41
log
@update the ref to fips; from jared yanovich
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.40 2003/10/05 02:26:03 mickey Exp $	*/
d128 7
d143 2
a144 2
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VIATECH &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VT82C686A_SMB)
@


1.40
log
@do not panic if microtime does not work to measure rng performance; from andrisp@@hipo.lv
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.39 2003/06/03 20:10:32 mickey Exp $	*/
d392 1
a392 1
 *	http://csrc.nist.gov/fips/fips1401.htm
@


1.39
log
@three four kill
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.38 2003/01/08 01:46:07 mickey Exp $	*/
d360 4
a363 2
			printf(": rng active, %dKb/sec",
			    8 * 1000000 / tv1.tv_usec);
@


1.38
log
@do not match on via866 smbus controller; reported and tested by grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.37 2002/09/23 04:11:31 nate Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.37
log
@For serverworks chipsets: instead of trying to prevent attaching the same bus
multiple times by restricting matches based on device id and revision, keep
track of the bus numbers that were attached, and don't reattach them a
second time.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.36 2002/08/22 23:03:48 deraadt Exp $	*/
d139 5
@


1.36
log
@match more serverworks "double bridges", based on discussions with nate and
brad
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.35 2002/07/12 20:17:03 mickey Exp $	*/
d147 8
d192 3
a194 27
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_RCC_CNB20HE:
			if ((sc->sc_dev.dv_unit == 0 &&
			    PCI_REVISION(pa->pa_class) == 0x23) ||
			    sc->sc_dev.dv_unit != 0)
				break;
		case PCI_PRODUCT_RCC_CIOB20:
		case PCI_PRODUCT_RCC_CNB20LE:
		case PCI_PRODUCT_RCC_CMIC_HE:
		case PCI_PRODUCT_RCC_XX5:
		case PCI_PRODUCT_RCC_CIOBX2:
			bdnum = pci_conf_read(pa->pa_pc, pa->pa_tag, 0x44);
			if (bdnum == 0)
				break;
			/*
			 * This host bridge has a second PCI bus.
			 * Configure it.
			 */
			neednl = 0;
			pba.pba_busname = "pci";
			pba.pba_iot = pa->pa_iot;
			pba.pba_memt = pa->pa_memt;
			pba.pba_dmat = pa->pa_dmat;
			pba.pba_bus = bdnum;
			pba.pba_pc = pa->pa_pc;
			printf("\n");
			config_found(self, &pba, pchb_print);
d196 16
a211 1
		}
@


1.35
log
@support for the agp gart on various agp chipsets.
only i810 driver was tested though.
based on the netbsd's lkm, initially ported
by hunter@@dg.net.ua and later made into shape by mickey.
testing by art@@ and millert@@ .
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.34 2002/06/12 15:52:54 mickey Exp $	*/
d193 2
@


1.34
log
@pci revision is in the class field, not the id (some ppl just refuse to follow the rules)' pt out by patrik@@lindergren.com
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.33 2002/05/10 17:15:07 mickey Exp $	*/
d168 15
d213 3
d307 2
a309 2
		case PCI_PRODUCT_INTEL_82810_DC100_MCH:
		case PCI_PRODUCT_INTEL_82810_MCH:
a310 1
		case PCI_PRODUCT_INTEL_82815_NOAGP_HUB:
d313 1
@


1.33
log
@on ServerWorks CNB20HE Host:
do not synthesyse secondary pci bus on the pchb0 rev 0x23
OR
pchb1 w/ any revision.
prompted by frisco@@blackant.net in pr#2642
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.32 2002/05/06 19:23:47 nate Exp $	*/
d172 1
a172 1
			    PCI_REVISION(pa->pa_id) == 0x23) ||
@


1.32
log
@Try to deal with the pci shadow bus issue by disabling a specific chip
revision of the CNB20HE that always seems to be involved in the shadow bus.

This is definately not the right way to do things.  The correct way is
to try to figure out that the bus is being detected for the second time.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.31 2002/04/28 20:36:23 nate Exp $	*/
d171 3
a173 1
			if (PCI_REVISION(pa->pa_id) == 0x23)
@


1.31
log
@Machines with the Serverworks CNB20HE chipset also have a CIOB20 i/o bridge.
Instead of attaching pci busses to the CNB20HE, attach them to the CIOB20.
This fixes problems where many of these machines will not attach a second
pci bus.  This also like Theo's previous diff prevents the shadow bus
from appearing.  Ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.30 2002/04/24 23:02:20 deraadt Exp $	*/
d170 3
@


1.30
log
@be much more picky about which RCC products are multi-bridges
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.29 2002/03/14 01:26:33 millert Exp $	*/
d170 1
a170 1
		case PCI_PRODUCT_RCC_CNB20HE:
@


1.29
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.28 2001/12/31 23:38:53 mickey Exp $	*/
d169 20
a188 3
		bdnum = pci_conf_read(pa->pa_pc, pa->pa_tag, 0x44);

		if (bdnum == 0)
d190 1
a190 13
		/*
		 * This host bridge has a second PCI bus.
		 * Configure it.
		 */
		neednl = 0;
		pba.pba_busname = "pci";
		pba.pba_iot = pa->pa_iot;
		pba.pba_memt = pa->pa_memt;
		pba.pba_dmat = pa->pa_dmat;
		pba.pba_bus = bdnum;
		pba.pba_pc = pa->pa_pc;
		printf("\n");
		config_found(self, &pba, pchb_print);
@


1.28
log
@man says bus_space_map() returns non-zero, not negative on failure
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.27 2001/01/22 23:11:21 deraadt Exp $	*/
d118 2
a119 2
int	pchbmatch __P((struct device *, void *, void *));
void	pchbattach __P((struct device *, struct device *, void *));
d121 1
a121 1
int	pchb_print __P((void *, const char *));
d131 1
a131 1
void pchb_rnd __P((void *v));
@


1.27
log
@this should make i850 and i860 hubs do RNG
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.26 2000/12/29 17:00:54 mickey Exp $	*/
d292 1
a292 1
			    0, &sc->bh) < 0)
@


1.27.6.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.28 2001/12/31 23:38:53 mickey Exp $	*/
d292 1
a292 1
			    0, &sc->bh))
@


1.27.6.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.27.6.1 2002/01/31 22:55:12 niklas Exp $	*/
d118 2
a119 2
int	pchbmatch(struct device *, void *, void *);
void	pchbattach(struct device *, struct device *, void *);
d121 1
a121 1
int	pchb_print(void *, const char *);
d131 1
a131 1
void pchb_rnd(void *v);
d169 3
a171 25
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_RCC_CNB20HE:
			if ((sc->sc_dev.dv_unit == 0 &&
			    PCI_REVISION(pa->pa_id) == 0x23) ||
			    sc->sc_dev.dv_unit != 0)
				break;
		case PCI_PRODUCT_RCC_CIOB20:
		case PCI_PRODUCT_RCC_CNB20LE:
		case PCI_PRODUCT_RCC_CMIC_HE:
			bdnum = pci_conf_read(pa->pa_pc, pa->pa_tag, 0x44);
			if (bdnum == 0)
				break;
			/*
			 * This host bridge has a second PCI bus.
			 * Configure it.
			 */
			neednl = 0;
			pba.pba_busname = "pci";
			pba.pba_iot = pa->pa_iot;
			pba.pba_memt = pa->pa_memt;
			pba.pba_dmat = pa->pa_dmat;
			pba.pba_bus = bdnum;
			pba.pba_pc = pa->pa_pc;
			printf("\n");
			config_found(self, &pba, pchb_print);
d173 13
a185 1
		}
@


1.27.6.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.27.6.2 2002/06/11 03:35:54 art Exp $	*/
a146 8
/*
 * The variable below is a bit vector representing the Serverworks
 * busses that have already been attached.  Bit 0 represents bus 0 and
 * so forth.  The initial value is 1 because we never actually want to
 * attach bus 0 since bus 0 is the mainbus.
 */
u_int32_t rcc_bus_visited = 1;

d168 1
a168 7
#ifdef PCIAGP
	case PCI_VENDOR_ALI:
	case PCI_VENDOR_SIS:
	case PCI_VENDOR_VIATECH:
		pciagp_set_pchb(pa);
		break;
	case PCI_VENDOR_AMD:
d170 24
a193 3
		case PCI_PRODUCT_AMD_SC751_SC:
		case PCI_PRODUCT_AMD_762_PCHB:
			pciagp_set_pchb(pa);
a196 23
#endif
	case PCI_VENDOR_RCC:
		bdnum = pci_conf_read(pa->pa_pc, pa->pa_tag, 0x44);
		if (bdnum >= (sizeof(rcc_bus_visited) * 8) ||
		    (rcc_bus_visited & (1 << bdnum)))
			break;

		rcc_bus_visited |= 1 << bdnum;

		/*
		 * This host bridge has a second PCI bus.
		 * Configure it.
		 */
		neednl = 0;
		pba.pba_busname = "pci";
		pba.pba_iot = pa->pa_iot;
		pba.pba_memt = pa->pa_memt;
		pba.pba_dmat = pa->pa_dmat;
		pba.pba_bus = bdnum;
		pba.pba_pc = pa->pa_pc;
		printf("\n");
		config_found(self, &pba, pchb_print);
		break;
a197 3
#ifdef PCIAGP
		pciagp_set_pchb(pa);
#endif
d289 2
a291 2
		case PCI_PRODUCT_INTEL_82810_DC100_MCH:
		case PCI_PRODUCT_INTEL_82810E_MCH:
d293 1
a295 1
		case PCI_PRODUCT_INTEL_82815_NOAGP_HUB:
@


1.27.6.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a138 5

	/* XXX work around broken via82x866 chipsets */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VIATECH &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VT82C686A_SMB)
		return (0);
@


1.26
log
@kiss in the rng; all those evil voices kept me pushing for it...
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.25 2000/12/25 19:44:43 mickey Exp $	*/
d288 2
@


1.25
log
@always read new byte from rng, then decide wheather to start a new cycle
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.24 2000/11/08 13:12:40 art Exp $	*/
d155 1
d160 1
a160 1
	int i;
d294 18
a311 10
			if (bus_space_read_1(sc->bt, sc->bh,
			    I82802_RNG_HWST) & I82802_RNG_HWST_PRESENT) {
				int r;

				/* enable RNG */
				bus_space_write_1(sc->bt, sc->bh,
						I82802_RNG_HWST,
				    bus_space_read_1(sc->bt, sc->bh,
						I82802_RNG_HWST) |
				    I82802_RNG_HWST_ENABLE);
d313 10
a322 37
				/*
				 * see if we can read anything,
				 * and it passed the test
				 */
				for (i = 1000; i-- &&
		    !(bus_space_read_1(sc->bt, sc->bh, I82802_RNG_RNGST) &
		      I82802_RNG_RNGST_DATAV); DELAY(10));

				if (bus_space_read_1(sc->bt, sc->bh,
				    I82802_RNG_RNGST) & I82802_RNG_RNGST_DATAV
				    && (r = bus_space_read_1(sc->bt, sc->bh,
					I82802_RNG_DATA)) != 0
				    /*&& runfipstest()>=0*/) {
					struct timeval tv1, tv2;

					/* benchmark the RNG */
					microtime(&tv1);
					for (i = 8 * 1024; i--; ) {
						while(!(bus_space_read_1(sc->bt,
						    sc->bh, I82802_RNG_RNGST) &
						    I82802_RNG_RNGST_DATAV));
						(void)bus_space_read_1(sc->bt,
						    sc->bh, I82802_RNG_DATA);
					}
					microtime(&tv2);

					timersub(&tv2, &tv1, &tv1);
					if (tv1.tv_sec)
						tv1.tv_usec +=
						    1000000 * tv1.tv_sec;
					printf(": rng active, %dKb/sec",
					    8 * 1000000 / tv1.tv_usec);

					timeout_set(&sc->sc_tmo, pchb_rnd, sc);
					sc->i = 4;
					pchb_rnd(sc);
				}
d324 11
@


1.24
log
@Don't busy-wait for random data.
Remove unnecessary splhigh.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.23 2000/10/23 20:07:30 deraadt Exp $	*/
a372 1
	int ret;
d378 10
a387 10
	if (!(bus_space_read_1(sc->bt, sc->bh, I82802_RNG_RNGST) &
	    I82802_RNG_RNGST_DATAV))
		goto out;
	ret = bus_space_read_1(sc->bt, sc->bh, I82802_RNG_DATA);

	if (sc->i--) {
		sc->ax = (sc->ax << 8) | ret;
	} else {
		sc->i = 4;
		add_true_randomness(sc->ax);
d389 1
a389 1
out:
@


1.23
log
@ok, i think all i82802-using host bridges are in here now
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.22 2000/10/23 19:04:19 deraadt Exp $	*/
d373 1
a373 1
	int s, ret;
d375 7
a381 3
	s = splhigh();
	while (!(bus_space_read_1(sc->bt, sc->bh, I82802_RNG_RNGST) &
	    I82802_RNG_RNGST_DATAV));
a385 1
		splx(s);
a387 1
		splx(s);
d390 1
@


1.22
log
@Kbit
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.20 2000/10/19 16:37:37 deraadt Exp $	*/
d278 2
d281 5
a285 1
		case PCI_PRODUCT_INTEL_82810E_MCH:
a286 2
		case PCI_PRODUCT_INTEL_82820_MCH:
		case PCI_PRODUCT_INTEL_82815_HUB:
@


1.21
log
@i820 also does rng; art tested
@
text
@d330 1
a330 1
					printf(": rng active, %dK/sec",
@


1.20
log
@find RNG on i815 hub
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.19 2000/09/15 02:00:33 mickey Exp $	*/
d281 1
@


1.19
log
@enable hw rng for vanilla 810; 10x for testing to Stephan Somogyi <somogyi@@gyroscope.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.18 2000/08/02 02:21:13 mickey Exp $	*/
d281 1
@


1.18
log
@add yauc about fips; also some ugly spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.17 2000/07/18 15:17:19 mickey Exp $	*/
d278 1
@


1.17
log
@do not include random number in dmesg, per deraadt's suggestion.
instead, print rng number generation speed, measured.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.16 2000/06/15 20:35:57 ho Exp $	*/
d95 1
a95 1
#define PCISET_INTEL_SDRAMC_IPDLT	(1 << 8)  
d357 4
a360 1

@


1.16
log
@i840 chipset also has the true RNG (i82802 FWH). mickey@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.15 2000/06/13 00:38:46 deraadt Exp $	*/
d310 1
a310 1
					printf (": RNG(%x)", r);
d312 19
d332 1
a332 2
					timeout_set(&sc->sc_tmo, pchb_rnd, sc);
					timeout_add(&sc->sc_tmo, 1);
d363 1
a363 1
	int s, ret = -1;
d366 11
a376 12
	if (bus_space_read_1(sc->bt, sc->bh, I82802_RNG_RNGST) &
	    I82802_RNG_RNGST_DATAV)
		ret = bus_space_read_1(sc->bt, sc->bh, I82802_RNG_DATA);
	splx(s);

	if (ret >= 0) {
		if (sc->i--)
			sc->ax = (sc->ax << 8) + ret;
		else {
			sc->i = 4;
			add_true_randomness(sc->ax);
		}
@


1.15
log
@dmesg repair around pci sub-bus config
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.14 2000/05/05 00:26:28 deraadt Exp $	*/
d279 1
@


1.14
log
@451NX machines now probe all pci busses; M.Drochner@@fz-juelich.de
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.12 2000/05/01 19:34:22 deraadt Exp $	*/
a175 1
		printf("\n");
d183 1
d228 1
d264 1
@


1.13
log
@assume all pchb made by ServerWorks act the same
@
text
@d157 1
d230 34
@


1.12
log
@another RCC host bridge with a pci behind it
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.11 2000/04/27 00:41:06 deraadt Exp $	*/
d167 3
a169 23
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_RCC_ROSB4:
		case PCI_PRODUCT_RCC_CNB20HE:
		case PCI_PRODUCT_RCC_CNB20LE:
		case PCI_PRODUCT_RCC_CMIC_HE:
			bdnum = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    0x44);

			if (bdnum == 0)
				break;
			/*
			 * This host bridge has a second PCI bus.
			 * Configure it.
			 */
			printf(": has pci bus %d\n", bdnum);
			neednl = 0;
			pba.pba_busname = "pci";
			pba.pba_iot = pa->pa_iot;
			pba.pba_memt = pa->pa_memt;
			pba.pba_dmat = pa->pa_dmat;
			pba.pba_bus = bdnum;
			pba.pba_pc = pa->pa_pc;
			config_found(self, &pba, pchb_print);
d171 13
a183 1
		}
@


1.11
log
@newline manglings
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.10 2000/04/26 18:39:29 deraadt Exp $	*/
d171 1
@


1.10
log
@properly probe sub-pci busses for RCC ServerWorks chipsets
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.8 2000/04/21 22:48:52 mickey Exp $	*/
d157 1
d180 2
a181 1
			printf(": has pci bus %d", bdnum);
d221 3
a223 1
				printf(": Auxiliary PB (bus %d)", pbnum);
d291 2
a292 1
	printf("\n");
@


1.9
log
@add errata for 82443BX identified by smurph
@
text
@d165 25
@


1.8
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.7 2000/04/10 20:07:47 mickey Exp $	*/
d86 10
a95 7
#define PCISET_BRIDGETYPE_MASK	0x3
#define PCISET_TYPE_COMPAT	0x1
#define PCISET_TYPE_AUX		0x2

#define PCISET_BUSCONFIG_REG	0x48
#define PCISET_BRIDGE_NUMBER(reg)	(((reg) >> 8) & 0xff)
#define PCISET_PCI_BUS_NUMBER(reg)	(((reg) >> 16) & 0xff)
d167 14
d183 4
a186 4
			    PCISET_BUSCONFIG_REG);
			bdnum = PCISET_BRIDGE_NUMBER(bcreg);
			pbnum = PCISET_PCI_BUS_NUMBER(bcreg);
			switch (bdnum & PCISET_BRIDGETYPE_MASK) {
d190 1
a190 1
			case PCISET_TYPE_COMPAT:
d193 1
a193 1
			case PCISET_TYPE_AUX:
@


1.7
log
@add support for true RNG presented on the i82802 FWH.
it produces 1 byte at a time and has no ready irq, thus timeout driven.
in fact w/ default hz=100 it produces up to 60% of
gross entropy production in an average loaded desktop system.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d280 1
a280 1
			add_true_randomness(ret);
@


1.6
log
@fix attach message
@
text
@d1 1
d4 30
a69 1
#include <sys/types.h>
d73 2
d80 3
d84 1
a84 1
#include <dev/pci/pcidevs.h>
d103 12
d121 1
a121 1
	sizeof(struct device), pchbmatch, pchbattach
d128 1
d149 1
d154 1
d202 39
d259 25
@


1.6.10.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@a0 1
/*	$OpenBSD: pchb.c,v 1.27 2001/01/22 23:11:21 deraadt Exp $	*/
a2 30
/*
 * Copyright (c) 2000 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
d39 1
a42 2
#include <sys/proc.h>
#include <sys/timeout.h>
d48 1
d51 7
a57 14
#include <dev/rndvar.h>

#include <dev/ic/i82802reg.h>

#define PCISET_INTEL_BRIDGETYPE_MASK	0x3
#define PCISET_INTEL_TYPE_COMPAT	0x1
#define PCISET_INTEL_TYPE_AUX		0x2

#define PCISET_INTEL_BUSCONFIG_REG	0x48
#define PCISET_INTEL_BRIDGE_NUMBER(reg)	(((reg) >> 8) & 0xff)
#define PCISET_INTEL_PCI_BUS_NUMBER(reg)	(((reg) >> 16) & 0xff)

#define PCISET_INTEL_SDRAMC_REG	0x76
#define PCISET_INTEL_SDRAMC_IPDLT	(1 << 8)
a67 12
struct pchb_softc {
	struct device sc_dev;

	bus_space_tag_t bt;
	bus_space_handle_t bh;

	/* rng stuff */
	int ax;
	int i;
	struct timeout sc_tmo;
};

d74 1
a74 1
	sizeof(struct pchb_softc), pchbmatch, pchbattach
a80 1
void pchb_rnd __P((void *v));
a100 1
	struct pchb_softc *sc = (struct pchb_softc *)self;
a102 1
	struct timeval tv1, tv2;
a104 3
	pcitag_t tag;
	int neednl = 1;
	int i, r;
a111 19
	case PCI_VENDOR_RCC:
		bdnum = pci_conf_read(pa->pa_pc, pa->pa_tag, 0x44);

		if (bdnum == 0)
			break;
		/*
		 * This host bridge has a second PCI bus.
		 * Configure it.
		 */
		neednl = 0;
		pba.pba_busname = "pci";
		pba.pba_iot = pa->pa_iot;
		pba.pba_memt = pa->pa_memt;
		pba.pba_dmat = pa->pa_dmat;
		pba.pba_bus = bdnum;
		pba.pba_pc = pa->pa_pc;
		printf("\n");
		config_found(self, &pba, pchb_print);
		break;
a113 14
		case PCI_PRODUCT_INTEL_82443BX_AGP:     /* 82443BX AGP (PAC) */
		case PCI_PRODUCT_INTEL_82443BX_NOAGP:   /* 82443BX Host-PCI (no AGP) */
			/*
			 * An incorrect address may be driven on the
			 * DRAM bus, resulting in memory data being
			 * fetched from the wrong location.  This is
			 * the workaround.
			 */
			bcreg = pci_conf_read(pa->pa_pc, pa->pa_tag,
			    PCISET_INTEL_SDRAMC_REG);
			bcreg |= PCISET_INTEL_SDRAMC_IPDLT;
			pci_conf_write(pa->pa_pc, pa->pa_tag,
			    PCISET_INTEL_SDRAMC_REG, bcreg);
			break;
d116 4
a119 4
			    PCISET_INTEL_BUSCONFIG_REG);
			bdnum = PCISET_INTEL_BRIDGE_NUMBER(bcreg);
			pbnum = PCISET_INTEL_PCI_BUS_NUMBER(bcreg);
			switch (bdnum & PCISET_INTEL_BRIDGETYPE_MASK) {
d123 1
a123 1
			case PCISET_INTEL_TYPE_COMPAT:
d126 2
a127 4
			case PCISET_INTEL_TYPE_AUX:
				printf(": Auxiliary PB (bus %d)\n", pbnum);
				neednl = 0;

a137 1
				printf("\n");
a141 35
		case PCI_PRODUCT_INTEL_82454NX:
			pbnum = 0;
			switch (pa->pa_device) {
			case 18: /* PXB 0 bus A - primary bus */
				break;
			case 19: /* PXB 0 bus B */
				/* read SUBA0 from MIOC */
				tag = pci_make_tag(pa->pa_pc, 0, 16, 0);
				bcreg = pci_conf_read(pa->pa_pc, tag, 0xd0);
				pbnum = ((bcreg & 0x0000ff00) >> 8) + 1;
				break;
			case 20: /* PXB 1 bus A */
				/* read BUSNO1 from MIOC */
				tag = pci_make_tag(pa->pa_pc, 0, 16, 0);
				bcreg = pci_conf_read(pa->pa_pc, tag, 0xd0);
				pbnum = (bcreg & 0xff000000) >> 24;
				break;
			case 21: /* PXB 1 bus B */
				/* read SUBA1 from MIOC */
				tag = pci_make_tag(pa->pa_pc, 0, 16, 0);
				bcreg = pci_conf_read(pa->pa_pc, tag, 0xd4);
				pbnum = (bcreg & 0x000000ff) + 1;
				break;
			}
			if (pbnum != 0) {
				pba.pba_busname = "pci";
				pba.pba_iot = pa->pa_iot;
				pba.pba_memt = pa->pa_memt;
				pba.pba_dmat = pa->pa_dmat;
				pba.pba_bus = pbnum;
				pba.pba_pc = pa->pa_pc;
				printf("\n");
				config_found(self, &pba, pchb_print);
			}
			break;
a151 59
		case PCI_PRODUCT_INTEL_82810E_MCH:
		case PCI_PRODUCT_INTEL_82810_DC100_MCH:
		case PCI_PRODUCT_INTEL_82810_MCH:
		case PCI_PRODUCT_INTEL_82815_DC100_HUB:
		case PCI_PRODUCT_INTEL_82815_NOAGP_HUB:
		case PCI_PRODUCT_INTEL_82815_NOGRAPH_HUB:
		case PCI_PRODUCT_INTEL_82815_FULL_HUB:
		case PCI_PRODUCT_INTEL_82820_MCH:
		case PCI_PRODUCT_INTEL_82840_HB:
		case PCI_PRODUCT_INTEL_82850_HB:
		case PCI_PRODUCT_INTEL_82860_HB:
			sc->bt = pa->pa_memt;
			if (bus_space_map(sc->bt, I82802_IOBASE, I82802_IOSIZE,
			    0, &sc->bh) < 0)
				break;

			/* probe and init rng */
			if (!(bus_space_read_1(sc->bt, sc->bh,
			    I82802_RNG_HWST) & I82802_RNG_HWST_PRESENT))
				break;

			/* enable RNG */
			bus_space_write_1(sc->bt, sc->bh, I82802_RNG_HWST,
			    bus_space_read_1(sc->bt, sc->bh, I82802_RNG_HWST) |
			    I82802_RNG_HWST_ENABLE);

			/* see if we can read anything */
			for (i = 1000; i-- &&
			    !(bus_space_read_1(sc->bt,sc->bh,I82802_RNG_RNGST)&
			      I82802_RNG_RNGST_DATAV);
			    DELAY(10));

			if (!(bus_space_read_1(sc->bt, sc->bh,
			    I82802_RNG_RNGST) & I82802_RNG_RNGST_DATAV))
				break;

			r = bus_space_read_1(sc->bt, sc->bh, I82802_RNG_DATA);

			/* benchmark the RNG */
			microtime(&tv1);
			for (i = 8 * 1024; i--; ) {
				while(!(bus_space_read_1(sc->bt, sc->bh,
				    I82802_RNG_RNGST) & I82802_RNG_RNGST_DATAV))
					;
				r = bus_space_read_1(sc->bt, sc->bh,
				    I82802_RNG_DATA);
			}
			microtime(&tv2);

			timersub(&tv2, &tv1, &tv1);
			if (tv1.tv_sec)
				tv1.tv_usec += 1000000 * tv1.tv_sec;
			printf(": rng active, %dKb/sec",
			    8 * 1000000 / tv1.tv_usec);

			timeout_set(&sc->sc_tmo, pchb_rnd, sc);
			sc->i = 4;
			pchb_rnd(sc);
			break;
d156 1
a156 2
	if (neednl)
		printf("\n");
a169 29
}

/*
 * Should do FIPS testing as per:
 *	http://csrc.nist.gov/fips/fips1401.htm
 */
void
pchb_rnd(v)
	void *v;
{
	struct pchb_softc *sc = v;

	/*
	 * Don't wait for data to be ready. If it's not there, we'll check
	 * next time.
	 */
	if ((bus_space_read_1(sc->bt, sc->bh, I82802_RNG_RNGST) &
	    I82802_RNG_RNGST_DATAV)) {

		sc->ax = (sc->ax << 8) |
		    bus_space_read_1(sc->bt, sc->bh, I82802_RNG_DATA);

		if (!sc->i--) {
			sc->i = 4;
			add_true_randomness(sc->ax);
		}
	}

	timeout_add(&sc->sc_tmo, 1);
@


1.6.10.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d292 1
a292 1
			    0, &sc->bh))
@


1.6.10.3
log
@Merge in -current from about a week ago
@
text
@d118 2
a119 2
int	pchbmatch(struct device *, void *, void *);
void	pchbattach(struct device *, struct device *, void *);
d121 1
a121 1
int	pchb_print(void *, const char *);
d131 1
a131 1
void pchb_rnd(void *v);
@


1.6.10.4
log
@Sync the SMP branch with 3.3
@
text
@a139 5
	/* XXX work around broken via82x866 chipsets */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VIATECH &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VT82C686A_SMB)
		return (0);

a146 8
/*
 * The variable below is a bit vector representing the Serverworks
 * busses that have already been attached.  Bit 0 represents bus 0 and
 * so forth.  The initial value is 1 because we never actually want to
 * attach bus 0 since bus 0 is the mainbus.
 */
u_int32_t rcc_bus_visited = 1;

a167 15
#ifdef PCIAGP
	case PCI_VENDOR_ALI:
	case PCI_VENDOR_SIS:
	case PCI_VENDOR_VIATECH:
		pciagp_set_pchb(pa);
		break;
	case PCI_VENDOR_AMD:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_AMD_SC751_SC:
		case PCI_PRODUCT_AMD_762_PCHB:
			pciagp_set_pchb(pa);
			break;
		}
		break;
#endif
d170 2
a171 2
		if (bdnum >= (sizeof(rcc_bus_visited) * 8) ||
		    (rcc_bus_visited & (1 << bdnum)))
a172 3

		rcc_bus_visited |= 1 << bdnum;

a187 3
#ifdef PCIAGP
		pciagp_set_pchb(pa);
#endif
d279 2
a281 2
		case PCI_PRODUCT_INTEL_82810_DC100_MCH:
		case PCI_PRODUCT_INTEL_82810E_MCH:
d283 1
a285 1
		case PCI_PRODUCT_INTEL_82815_NOAGP_HUB:
@


1.6.10.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pchb.c,v 1.6.10.4 2003/03/27 23:26:56 niklas Exp $	*/
d16 5
@


1.6.10.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d360 2
a361 4
			printf(": rng active");
			if (tv1.tv_usec != 0)
				printf(", %dKb/sec",
				    8 * 1000000 / tv1.tv_usec);
d390 1
a390 1
 *	http://csrc.nist.gov/publications/fips/fips140-1/fips1401.htm
@


1.5
log
@Switch off CPU-PCI write posting for the Saturn chipset; it is known
to cause problems with PCI busmasters; fvdl
@
text
@d116 1
a116 1
					      PCISET_BUSCONFIG_REG);
d121 1
a121 1
				printf(": bdnum=%x (reserved)\n", bdnum);
d124 1
a124 1
				printf(": Compatibility PB (bus %d)\n", pbnum);
d127 1
a127 1
				printf(": Auxiliary PB (bus %d)\n", pbnum);
d149 1
a149 1
				printf(": disabled CPU-PCI write posting\n");
a152 1
			printf("\n");
d156 1
@


1.4
log
@Merge bus_dma support from NetBSD, mostly by Jason Thorpe.  Only i386 uses it
 so far, the other archs gets placeholders for now.  I wrote a compatibility
layer for OpenBSD's old isadma code so we can still use our old
driver sources.  They will however get changed to native bus_dma use,
on a case by case basis.   Oh yes, I almost forgot, I kept our notion
of isadma being a device so DMA-less ISA-busses still work
@
text
@d59 9
d81 1
d140 10
@


1.3
log
@catch all pci host bridges
@
text
@d1 1
a1 1
/*	$NetBSD: pchb.c,v 1.9 1997/10/09 08:48:33 jtc Exp $	*/
d125 1
@


1.2
log
@now this is really pretty
@
text
@d79 3
a81 81
	/*
	 * Match all known PCI host chipsets.
	 */
	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_INTEL:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_INTEL_CDC:
		case PCI_PRODUCT_INTEL_PCMC:
		case PCI_PRODUCT_INTEL_82437FX:
		case PCI_PRODUCT_INTEL_82437MX:
		case PCI_PRODUCT_INTEL_82437VX:
		case PCI_PRODUCT_INTEL_82439HX:
		case PCI_PRODUCT_INTEL_82439TX:
		case PCI_PRODUCT_INTEL_82441FX:
		case PCI_PRODUCT_INTEL_82443LX:
		case PCI_PRODUCT_INTEL_PCI450_PB:
		case PCI_PRODUCT_INTEL_PCI450_MC:
			return (1);
		}
		break;
	case PCI_VENDOR_UMC:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_UMC_UM8881F:
		case PCI_PRODUCT_UMC_UM8891N:
			return (1);
		}
		break;
	case PCI_VENDOR_ACC:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_ACC_2188:
			return (1);
		}
		break;
	case PCI_VENDOR_ACER:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_ACER_M1435:
			return (1);
		}
		break;
	case PCI_VENDOR_ALI:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_ALI_M1445:
		case PCI_PRODUCT_ALI_M1451:
		case PCI_PRODUCT_ALI_M1461:
			return (1);
		}
		break;
	case PCI_VENDOR_COMPAQ:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_COMPAQ_TRIFLEX1:
		case PCI_PRODUCT_COMPAQ_TRIFLEX2:
		case PCI_PRODUCT_COMPAQ_TRIFLEX4:
			return (1);
		}
		break;
	case PCI_VENDOR_NEXGEN:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_NEXGEN_NX82C501:
			return (1);
		}
		break;
	case PCI_VENDOR_NKK:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_NKK_NDR4600:
			return (1);
		}
		break;
	case PCI_VENDOR_TOSHIBA:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_TOSHIBA_R4X00:
			return (1);
		}
		break;
	case PCI_VENDOR_VIATECH:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_VIATECH_VT82C570M:
		case PCI_PRODUCT_VIATECH_VT82C595:
			return (1);
		}
		break;
	}
@


1.1
log
@pchb support
@
text
@d189 1
a189 1
				printf(", bdnum=%x (reserved)\n", bdnum);
d192 1
a192 1
				printf(", Compatibility PB (bus %d)\n", pbnum);
d195 1
a195 1
				printf(", Auxiliary PB (bus %d)\n", pbnum);
@

