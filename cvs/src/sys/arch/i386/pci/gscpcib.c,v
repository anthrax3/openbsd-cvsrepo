head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.32
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.30
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.26
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.28
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.20
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.24
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.22
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.18
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.16
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.14
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.12
	OPENBSD_5_0:1.6.0.10
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.8
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.6
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.10
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.8
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.6
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.4
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.4.0.4
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.2
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.6
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.11.20.57.40;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.05.15.32.46;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2004.10.05.19.02.33;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.05.15.21.01;	author grange;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2004.06.03.18.22.21;	author grange;	state Exp;
branches;
next	;

1.2.2.1
date	2004.06.05.23.09.00;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.6
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@/*	$OpenBSD: gscpcib.c,v 1.5 2006/12/11 20:57:40 deraadt Exp $	*/
/*
 * Copyright (c) 2004 Alexander Yurchenko <grange@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Special driver for the National Semiconductor Geode SC1100 PCI-ISA bridge
 * that attaches instead of pcib(4). In addition to the core pcib(4)
 * functionality this driver provides support for the GPIO interface.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/gpio.h>
#include <sys/kernel.h>

#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/gpio/gpiovar.h>

#include <i386/pci/gscpcibreg.h>

struct gscpcib_softc {
	struct device sc_dev;

	/* GPIO interface */
	bus_space_tag_t sc_gpio_iot;
	bus_space_handle_t sc_gpio_ioh;
	struct gpio_chipset_tag sc_gpio_gc;
	gpio_pin_t sc_gpio_pins[GSCGPIO_NPINS];
};

int	gscpcib_match(struct device *, void *, void *);
void	gscpcib_attach(struct device *, struct device *, void *);

int	gscpcib_gpio_pin_read(void *, int);
void	gscpcib_gpio_pin_write(void *, int, int);
void	gscpcib_gpio_pin_ctl(void *, int, int);

/* arch/i386/pci/pcib.c */
void    pcibattach(struct device *, struct device *, void *);

struct cfattach gscpcib_ca = {
	sizeof (struct gscpcib_softc),
	gscpcib_match,
	gscpcib_attach
};

struct cfdriver gscpcib_cd = {
	NULL, "gscpcib", DV_DULL
};

int
gscpcib_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	if (PCI_CLASS(pa->pa_class) != PCI_CLASS_BRIDGE ||
	    PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_BRIDGE_ISA)
		return (0);

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_NS &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NS_SC1100_ISA)
		return (2);	/* supersede pcib(4) */

	return (0);
}

void
gscpcib_attach(struct device *parent, struct device *self, void *aux)
{
#ifndef SMALL_KERNEL
	struct gscpcib_softc *sc = (struct gscpcib_softc *)self;
	struct pci_attach_args *pa = aux;
	struct gpiobus_attach_args gba;
	pcireg_t gpiobase;
	int i;
	int gpio_present = 0;

	/* Map GPIO I/O space */
	gpiobase = pci_conf_read(pa->pa_pc, pa->pa_tag, GSCGPIO_BASE);
	sc->sc_gpio_iot = pa->pa_iot;
	if (PCI_MAPREG_IO_ADDR(gpiobase) == 0 ||
	    bus_space_map(sc->sc_gpio_iot, PCI_MAPREG_IO_ADDR(gpiobase),
	    GSCGPIO_SIZE, 0, &sc->sc_gpio_ioh)) {
		printf(": can't map GPIO i/o space");
		goto corepcib;
	}

	/* Initialize pins array */
	for (i = 0; i < GSCGPIO_NPINS; i++) {
		sc->sc_gpio_pins[i].pin_num = i;
		sc->sc_gpio_pins[i].pin_caps = GPIO_PIN_INPUT |
		    GPIO_PIN_OUTPUT | GPIO_PIN_OPENDRAIN |
		    GPIO_PIN_PUSHPULL | GPIO_PIN_TRISTATE |
		    GPIO_PIN_PULLUP;

		/* Read initial state */
		sc->sc_gpio_pins[i].pin_state = gscpcib_gpio_pin_read(sc, i) ?
		    GPIO_PIN_HIGH : GPIO_PIN_LOW;
	}

	/* Create controller tag */
	sc->sc_gpio_gc.gp_cookie = sc;
	sc->sc_gpio_gc.gp_pin_read = gscpcib_gpio_pin_read;
	sc->sc_gpio_gc.gp_pin_write = gscpcib_gpio_pin_write;
	sc->sc_gpio_gc.gp_pin_ctl = gscpcib_gpio_pin_ctl;

	gba.gba_name = "gpio";
	gba.gba_gc = &sc->sc_gpio_gc;
	gba.gba_pins = sc->sc_gpio_pins;
	gba.gba_npins = GSCGPIO_NPINS;

	gpio_present = 1;

corepcib:
#endif	/* !SMALL_KERNEL */
	/* Provide core pcib(4) functionality */
	pcibattach(parent, self, aux);

#ifndef SMALL_KERNEL
	/* Attach GPIO framework */
	if (gpio_present)
		config_found(&sc->sc_dev, &gba, gpiobus_print);
#endif	/* !SMALL_KERNEL */
}

#ifndef SMALL_KERNEL
static __inline void
gscpcib_gpio_pin_select(struct gscpcib_softc *sc, int pin)
{
	bus_space_write_4(sc->sc_gpio_iot, sc->sc_gpio_ioh, GSCGPIO_SEL, pin);
}

int
gscpcib_gpio_pin_read(void *arg, int pin)
{
	struct gscpcib_softc *sc = arg;
	int reg, shift;
	u_int32_t data;

	reg = (pin < 32 ? GSCGPIO_GPDI0 : GSCGPIO_GPDI1);
	shift = pin % 32;
	data = bus_space_read_4(sc->sc_gpio_iot, sc->sc_gpio_ioh, reg);

	return ((data >> shift) & 0x1);
}

void
gscpcib_gpio_pin_write(void *arg, int pin, int value)
{
	struct gscpcib_softc *sc = arg;
	int reg, shift;
	u_int32_t data;

	reg = (pin < 32 ? GSCGPIO_GPDO0 : GSCGPIO_GPDO1);
	shift = pin % 32;
	data = bus_space_read_4(sc->sc_gpio_iot, sc->sc_gpio_ioh, reg);
	if (value == 0)
		data &= ~(1 << shift);
	else if (value == 1)
		data |= (1 << shift);

	bus_space_write_4(sc->sc_gpio_iot, sc->sc_gpio_ioh, reg, data);
}

void
gscpcib_gpio_pin_ctl(void *arg, int pin, int flags)
{
	struct gscpcib_softc *sc = arg;
	u_int32_t conf;

	gscpcib_gpio_pin_select(sc, pin);
	conf = bus_space_read_4(sc->sc_gpio_iot, sc->sc_gpio_ioh,
	    GSCGPIO_CONF);

	conf &= ~(GSCGPIO_CONF_OUTPUTEN | GSCGPIO_CONF_PUSHPULL |
	    GSCGPIO_CONF_PULLUP);
	if ((flags & GPIO_PIN_TRISTATE) == 0)
		conf |= GSCGPIO_CONF_OUTPUTEN;
	if (flags & GPIO_PIN_PUSHPULL)
		conf |= GSCGPIO_CONF_PUSHPULL;
	if (flags & GPIO_PIN_PULLUP)
		conf |= GSCGPIO_CONF_PULLUP;
	bus_space_write_4(sc->sc_gpio_iot, sc->sc_gpio_ioh,
	    GSCGPIO_CONF, conf);
}
#endif	/* !SMALL_KERNEL */
@


1.5
log
@do not bus_space_map devices which are at address 0; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: gscpcib.c,v 1.4 2006/01/05 15:32:46 grange Exp $	*/
d103 1
a103 1
		printf(": failed to map GPIO I/O space");
@


1.4
log
@Don't change pins state on attach.
@
text
@d1 1
a1 1
/*	$OpenBSD: gscpcib.c,v 1.3 2004/10/05 19:02:33 grange Exp $	*/
d100 2
a101 1
	if (bus_space_map(sc->sc_gpio_iot, PCI_MAPREG_IO_ADDR(gpiobase),
@


1.3
log
@Includes nit.
@
text
@d1 1
a1 1
/*	$OpenBSD: gscpcib.c,v 1.2 2004/06/05 15:21:01 grange Exp $	*/
d114 3
a116 5
		/* safe defaults */
		sc->sc_gpio_pins[i].pin_flags = GPIO_PIN_TRISTATE;
		sc->sc_gpio_pins[i].pin_state = GPIO_PIN_LOW;
		gscpcib_gpio_pin_ctl(sc, i, sc->sc_gpio_pins[i].pin_flags);
		gscpcib_gpio_pin_write(sc, i, sc->sc_gpio_pins[i].pin_state);
@


1.2
log
@Replace NGPIO button with SMALL_KERNEL.
@
text
@d1 1
a1 1
/*	$OpenBSD: gscpcib.c,v 1.1 2004/06/03 18:22:21 grange Exp $	*/
a31 1
#include <dev/pci/pcidevs.h>
d34 1
@


1.2.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@gscpcib(4) -- National Semiconductor Geode SC1100 PCI-ISA bridge driver.
Besides the core pcib(4) functionality, the gscpcib driver provides
support for the GPIO interface of this device.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a39 2
#include "gpio.h"

d89 1
a89 1
#if NGPIO > 0
d135 1
a135 1
#endif
d139 1
a139 1
#if NGPIO > 0
d143 1
a143 1
#endif
d146 1
a146 1
#if NGPIO > 0
d206 1
a206 1
#endif
@

