head	1.48;
access;
symbols
	OPENBSD_6_2:1.48.0.10
	OPENBSD_6_2_BASE:1.48
	OPENBSD_6_1:1.48.0.8
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.48.0.4
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.45.0.2
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.43.0.4
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.40.0.12
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.40.0.10
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.40.0.8
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.6
	OPENBSD_5_0:1.40.0.4
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.40.0.2
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.39.0.10
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.6
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.39.0.8
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.4
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.39.0.2
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.38.0.2
	OPENBSD_4_3_BASE:1.38
	OPENBSD_4_2:1.37.0.2
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.32.0.6
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.32.0.4
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.32.0.2
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	SMP_SYNC_A:1.29
	SMP_SYNC_B:1.29
	OPENBSD_3_5:1.29.0.4
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.27.0.4
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.27.0.2
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.27
	UBC:1.24.0.4
	UBC_BASE:1.24
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9:1.23.0.4
	OPENBSD_2_9_BASE:1.23
	SMP:1.23.0.2
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.48
date	2015.09.08.08.33.26;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	t59bsVfEDCZAKIKs;

1.47
date	2015.09.08.04.28.34;	author semarie;	state Exp;
branches;
next	1.46;
commitid	Ajpcv6B3UUP5Q4Cd;

1.46
date	2015.07.17.21.36.56;	author mlarkin;	state Exp;
branches;
next	1.45;
commitid	myTLft2DQvq03Jlf;

1.45
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.44;
commitid	uKVPYMN2MLxdZxzH;

1.44
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2013.11.28.19.30.46;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2013.10.01.20.22.12;	author sf;	state Exp;
branches;
next	1.41;

1.41
date	2013.10.01.20.05.58;	author sf;	state Exp;
branches;
next	1.40;

1.40
date	2010.11.20.20.11.19;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2008.06.26.05.42.11;	author ray;	state Exp;
branches;
next	1.38;

1.38
date	2007.12.05.19.17.13;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2007.03.19.05.32.05;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2007.02.20.21.15.01;	author tom;	state Exp;
branches;
next	1.35;

1.35
date	2006.11.29.22.40.13;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.09.19.11.06.34;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2006.04.27.15.37.55;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2005.01.08.18.17.58;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2005.01.04.21.19.15;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2004.08.09.19.52.06;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.03.20.10.32;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.17.03.42.14;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.12.21.17.06;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.21.22.47.02;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.12.19.12.44;	author mickey;	state Exp;
branches
	1.24.4.1;
next	1.23;

1.23
date	2001.02.28.20.33.30;	author mickey;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2001.01.27.20.54.41;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.27.04.59.40;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.25.00.07.40;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.24.23.40.29;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.24.23.16.14;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2000.10.31.18.56.42;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.16.03.35.19;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.16.03.22.06;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.22.02.00.43;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.20.19.39.55;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2000.09.07.20.50.39;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.05.21.44.14;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.04.17.13.28;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.04.17.00.17;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.04.16.58.41;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.17.20.15.40;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.08.19.12.48;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.06.18.42.18;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.06.18.32.15;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.28.03.37.59;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.27.08.35.22;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.26.22.38.38;	author mickey;	state Exp;
branches;
next	;

1.23.2.1
date	2001.04.18.16.08.29;	author niklas;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2001.07.04.10.18.05;	author niklas;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2002.03.28.10.31.05;	author niklas;	state Exp;
branches;
next	1.23.2.4;

1.23.2.4
date	2003.03.27.23.26.56;	author niklas;	state Exp;
branches;
next	1.23.2.5;

1.23.2.5
date	2003.05.13.19.42.08;	author ho;	state Exp;
branches;
next	1.23.2.6;

1.23.2.6
date	2003.06.07.11.11.38;	author ho;	state Exp;
branches;
next	;

1.24.4.1
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	1.24.4.2;

1.24.4.2
date	2002.10.29.00.28.04;	author art;	state Exp;
branches;
next	1.24.4.3;

1.24.4.3
date	2003.05.19.21.45.12;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.48
log
@sizes for free(); ok semarie
@
text
@/*	$OpenBSD: pcibios.c,v 1.47 2015/09/08 04:28:34 semarie Exp $	*/
/*	$NetBSD: pcibios.c,v 1.5 2000/08/01 05:23:59 uch Exp $	*/

/*
 * Copyright (c) 2000 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1999, by UCHIYAMA Yasushi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the developer may NOT be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
 */

/*
 * Interface to the PCI BIOS and PCI Interrupt Routing table.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <dev/isa/isareg.h>
#include <i386/isa/isa_machdep.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <i386/pci/pcibiosvar.h>

#include <machine/biosvar.h>

int pcibios_flags;
int pcibios_present;

struct pcibios_pir_header pcibios_pir_header;
struct pcibios_intr_routing *pcibios_pir_table;
int pcibios_pir_table_nentries;
int pcibios_flags = 0;

struct bios32_entry pcibios_entry;
struct bios32_entry_info pcibios_entry_info;

struct pcibios_intr_routing *pcibios_pir_init(struct pcibios_softc *);

int	pcibios_get_status(struct pcibios_softc *,
	    u_int32_t *, u_int32_t *, u_int32_t *,
	    u_int32_t *, u_int32_t *, u_int32_t *, u_int32_t *);
int	pcibios_get_intr_routing(struct pcibios_softc *,
	    struct pcibios_intr_routing *, int *, u_int16_t *);

int	pcibios_return_code(struct pcibios_softc *, u_int16_t, const char *);

void	pcibios_print_exclirq(struct pcibios_softc *);
void	pcibios_print_pir_table(void);

#define	PCI_IRQ_TABLE_START	0xf0000
#define	PCI_IRQ_TABLE_END	0xfffff

struct cfdriver pcibios_cd = {
	NULL, "pcibios", DV_DULL
};

int pcibiosprobe(struct device *, void *, void *);
void pcibiosattach(struct device *, struct device *, void *);

struct cfattach pcibios_ca = {
	sizeof(struct pcibios_softc), pcibiosprobe, pcibiosattach
};

int
pcibiosprobe(struct device *parent, void *match, void *aux)
{
	struct bios_attach_args *ba = aux;
	u_int32_t rev_maj, rev_min, mech1, mech2, scmech1, scmech2, maxbus;
	int rv;

	if (strcmp(ba->ba_name, "pcibios"))
		return 0;

	rv = bios32_service(PCIBIOS_SIGNATURE, &pcibios_entry,
		&pcibios_entry_info);

	PCIBIOS_PRINTV(("pcibiosprobe: 0x%hx:0x%x at 0x%x[0x%x]\n",
	    pcibios_entry.segment, pcibios_entry.offset,
	    pcibios_entry_info.bei_base, pcibios_entry_info.bei_size));

	return rv &&
	    pcibios_get_status(NULL, &rev_maj, &rev_min, &mech1, &mech2,
	        &scmech1, &scmech2, &maxbus) == PCIBIOS_SUCCESS;
}

void
pcibiosattach(struct device *parent, struct device *self, void *aux)
{
	struct pcibios_softc *sc = (struct pcibios_softc *)self;
	u_int32_t rev_maj, rev_min, mech1, mech2, scmech1, scmech2;

	pcibios_flags = sc->sc_dev.dv_cfdata->cf_flags;

	pcibios_get_status((struct pcibios_softc *)self, &rev_maj,
	    &rev_min, &mech1, &mech2,
	    &scmech1, &scmech2, &sc->max_bus);

	printf(": rev %d.%d @@ 0x%x/0x%x\n",
	    rev_maj, rev_min >> 4, pcibios_entry_info.bei_base,
	    pcibios_entry_info.bei_size);

	PCIBIOS_PRINTV(("%s: config mechanism %s%s, special cycles %s%s, "
	    "last bus %d\n", sc->sc_dev.dv_xname,
	    mech1 ? "[1]" : "[x]", mech2 ? "[2]" : "[x]",
	    scmech1 ? "[1]" : "[x]", scmech2 ? "[2]" : "[x]", sc->max_bus));

	/*
	 * The PCI BIOS tells us the config mechanism; fill it in now
	 * so that pci_mode_detect() doesn't have to look for it.
	 */
	pci_mode = mech1 ? 1 : 2;

	pcibios_present = 1;

	/*
	 * Find the PCI IRQ Routing table.
	 */

	if (!(pcibios_flags & PCIBIOS_INTR_FIXUP) &&
	    pcibios_pir_init((struct pcibios_softc *)self) != NULL) {
		int rv;

		/*
		 * Fixup interrupt routing.
		 */
		rv = pci_intr_fixup(sc, NULL, I386_BUS_SPACE_IO);
		switch (rv) {
		case -1:
			/* Non-fatal error. */
			printf("%s: Warning, unable to fix up PCI interrupt "
			    "routing\n", sc->sc_dev.dv_xname);
			break;

		case 1:
			/* Fatal error. */
			printf("%s: interrupt fixup failed\n", sc->sc_dev.dv_xname);
			return;
		}

		/*
		 * XXX Clear `pciirq' from the ISA interrupt allocation
		 * XXX mask.
		 */
	}

	if (!(pcibios_flags & PCIBIOS_BUS_FIXUP)) {
		sc->max_bus = pci_bus_fixup(NULL, 0);
		printf("%s: PCI bus #%d is the last bus\n",
		    sc->sc_dev.dv_xname, sc->max_bus);
	}

	if (!(pcibios_flags & PCIBIOS_ADDR_FIXUP))
		pci_addr_fixup(sc, NULL, sc->max_bus);

	bios32_cleanup();
}

struct pcibios_intr_routing *
pcibios_pir_init(struct pcibios_softc *sc)
{
	paddr_t pa;

	pcibios_pir_table = NULL;
	for (pa = PCI_IRQ_TABLE_START; pa < PCI_IRQ_TABLE_END; pa += 16) {
		u_int8_t *p, cksum;
		struct pcibios_pir_header *pirh;
		int i;

		p = ISA_HOLE_VADDR(pa);
		pirh = (struct pcibios_pir_header *)p;
		/*
		 * Some laptops (such as the Toshiba Libretto L series)
		 * use _PIR instead of the standard $PIR for the signature
		 * so we check for that too.
		 */
		if (pirh->signature != BIOS32_MAKESIG('$', 'P', 'I', 'R') &&
		    pirh->signature != BIOS32_MAKESIG('_', 'P', 'I', 'R'))
			continue;
		
		if (pirh->tablesize < sizeof(*pirh))
			continue;

		cksum = 0;
		for (i = 0; i < pirh->tablesize; i++)
			cksum += p[i];

		printf("%s: PCI IRQ Routing Table rev %d.%d @@ 0x%lx/%d "
		    "(%zd entries)\n", sc->sc_dev.dv_xname,
		    pirh->version >> 8, pirh->version & 0xff, pa,
		    pirh->tablesize, (pirh->tablesize - sizeof(*pirh)) / 16);

		if (cksum != 0) {
			printf("%s: bad IRQ table checksum\n",
			    sc->sc_dev.dv_xname);
			continue;
		}

		if (pirh->tablesize % 16 != 0) {
			printf("%s: bad IRQ table size\n", sc->sc_dev.dv_xname);
			continue;
		}

		if (pirh->version != 0x0100) {
			printf("%s: unsupported IRQ table version\n",
			    sc->sc_dev.dv_xname);
			continue;
		}

		/*
		 * We can handle this table!  Make a copy of it.
		 */
		pcibios_pir_header = *pirh;
		pcibios_pir_table =
		    malloc(pirh->tablesize - sizeof(*pirh), M_DEVBUF, M_NOWAIT);
		if (pcibios_pir_table == NULL) {
			printf("%s: no memory for $PIR\n", sc->sc_dev.dv_xname);
			return NULL;
		}
		bcopy(p + sizeof(*pirh), pcibios_pir_table,
		    pirh->tablesize - sizeof(*pirh));
		pcibios_pir_table_nentries =
		    (pirh->tablesize - sizeof(*pirh)) / 16;

	}

	/*
	 * If there was no PIR table found, try using the PCI BIOS
	 * Get Interrupt Routing call.
	 *
	 * XXX The interface to this call sucks; just allocate enough
	 * XXX room for 32 entries.
	 */
	if (pcibios_pir_table == NULL) {

		pcibios_pir_table_nentries = 32;
		pcibios_pir_table = mallocarray(pcibios_pir_table_nentries,
		    sizeof(*pcibios_pir_table), M_DEVBUF, M_NOWAIT);
		if (pcibios_pir_table == NULL) {
			printf("%s: no memory for $PIR\n", sc->sc_dev.dv_xname);
			return NULL;
		}
		if (pcibios_get_intr_routing(sc, pcibios_pir_table,
		    &pcibios_pir_table_nentries,
		    &pcibios_pir_header.exclusive_irq) != PCIBIOS_SUCCESS) {
			printf("%s: PCI IRQ Routing information unavailable.\n",
			    sc->sc_dev.dv_xname);
			free(pcibios_pir_table, M_DEVBUF,
			    pcibios_pir_table_nentries *
			    sizeof(*pcibios_pir_table));
			pcibios_pir_table = NULL;
			pcibios_pir_table_nentries = 0;
			return NULL;
		}
		printf("%s: PCI BIOS has %d Interrupt Routing table entries\n",
		    sc->sc_dev.dv_xname, pcibios_pir_table_nentries);
	}

	pcibios_print_exclirq(sc);
	if (pcibios_flags & PCIBIOS_INTRDEBUG)
		pcibios_print_pir_table();
	return pcibios_pir_table;
}

int
pcibios_get_status(struct pcibios_softc *sc, u_int32_t *rev_maj,
    u_int32_t *rev_min, u_int32_t *mech1, u_int32_t *mech2, u_int32_t *scmech1,
    u_int32_t *scmech2, u_int32_t *maxbus)
{
	u_int32_t ax, bx, cx, edx;
	int rv;

	__asm volatile("pushl	%%es\n\t"
			 "pushl	%%ds\n\t"
			 "movw	4(%%edi), %%cx\n\t"
			 "movl	%%ecx, %%ds\n\t"
			 "lcall	*%%cs:(%%edi)\n\t"
			 "pop	%%ds\n\t"
			 "pop	%%es\n\t"
			 "jc	1f\n\t"
			 "xor	%%ah, %%ah\n"
		    "1:"
		: "=a" (ax), "=b" (bx), "=c" (cx), "=d" (edx)
		: "0" (0xb101), "D" (&pcibios_entry)
		: "cc", "memory");

	rv = pcibios_return_code(sc, ax, "pcibios_get_status");
	if (rv != PCIBIOS_SUCCESS)
		return (rv);

	if (edx != BIOS32_MAKESIG('P', 'C', 'I', ' '))
		return (PCIBIOS_SERVICE_NOT_PRESENT);	/* XXX */

	/*
	 * Fill in the various pieces of info we're looking for.
	 */
	*mech1 = ax & 1;
	*mech2 = ax & (1 << 1);
	*scmech1 = ax & (1 << 4);
	*scmech2 = ax & (1 << 5);
	*rev_maj = (bx >> 8) & 0xff;
	*rev_min = bx & 0xff;
	*maxbus = cx & 0xff;

	return (PCIBIOS_SUCCESS);
}

int
pcibios_get_intr_routing(struct pcibios_softc *sc,
    struct pcibios_intr_routing *table, int *nentries, u_int16_t *exclirq)
{
	u_int32_t ax, bx;
	int rv;
	struct {
		u_int16_t size;
		u_int32_t offset;
		u_int16_t segment;
	} __packed args;

	args.size = *nentries * sizeof(*table);
	args.offset = (u_int32_t)table;
	args.segment = GSEL(GDATA_SEL, SEL_KPL);

	memset(table, 0, args.size);

	__asm volatile("pushl	%%es\n\t"
			 "pushl	%%ds\n\t"
			 "movw	4(%%esi), %%cx\n\t"
			 "movl	%%ecx, %%ds\n\t"
			 "lcall	*%%cs:(%%esi)\n\t"
			 "popl	%%ds\n\t"
			 "popl	%%es\n\t"
			 "jc	1f\n\t"
			 "xor	%%ah, %%ah\n"
		    "1:\n"
		: "=a" (ax), "=b" (bx)
		: "0" (0xb10e), "1" (0), "D" (&args), "S" (&pcibios_entry)
		: "%ecx", "%edx", "cc", "memory");

	rv = pcibios_return_code(sc, ax, "pcibios_get_intr_routing");
	if (rv != PCIBIOS_SUCCESS)
		return (rv);

	*nentries = args.size / sizeof(*table);
	*exclirq |= bx;

	return (PCIBIOS_SUCCESS);
}

int
pcibios_return_code(struct pcibios_softc *sc, u_int16_t ax, const char *func)
{
	const char *errstr;
	int rv = ax >> 8;
	char *nam;

	if (sc)
		nam = sc->sc_dev.dv_xname;
	else
		nam = "pcibios0";

	switch (rv) {
	case PCIBIOS_SUCCESS:
		return (PCIBIOS_SUCCESS);

	case PCIBIOS_SERVICE_NOT_PRESENT:
		errstr = "service not present";
		break;

	case PCIBIOS_FUNCTION_NOT_SUPPORTED:
		errstr = "function not supported";
		break;

	case PCIBIOS_BAD_VENDOR_ID:
		errstr = "bad vendor ID";
		break;

	case PCIBIOS_DEVICE_NOT_FOUND:
		errstr = "device not found";
		break;

	case PCIBIOS_BAD_REGISTER_NUMBER:
		errstr = "bad register number";
		break;

	case PCIBIOS_SET_FAILED:
		errstr = "set failed";
		break;

	case PCIBIOS_BUFFER_TOO_SMALL:
		errstr = "buffer too small";
		break;

	default:
		printf("%s: %s - unknown return code 0x%x\n",
		    nam, func, rv);
		return (rv);
	}

	printf("%s: %s - %s\n", nam, func, errstr);
	return (rv);
}

void
pcibios_print_exclirq(struct pcibios_softc *sc)
{
	int i;

	if (pcibios_pir_header.exclusive_irq) {
		printf("%s: PCI Exclusive IRQs:", sc->sc_dev.dv_xname);
		for (i = 0; i < 16; i++) {
			if (pcibios_pir_header.exclusive_irq & (1 << i))
				printf(" %d", i);
		}
		printf("\n");
	}
}

void
pcibios_print_pir_table(void)
{
	int i, j;

	for (i = 0; i < pcibios_pir_table_nentries; i++) {
		printf("PIR Entry %d:\n", i);
		printf("\tBus: %d  Device: %d\n",
		    pcibios_pir_table[i].bus,
		    PIR_DEVFUNC_DEVICE(pcibios_pir_table[i].device));
		for (j = 0; j < 4; j++) {
			printf("\t\tINT%c: link 0x%02x bitmap 0x%04x\n",
			    'A' + j,
			    pcibios_pir_table[i].linkmap[j].link,
			    pcibios_pir_table[i].linkmap[j].bitmap);
		}
	}
}

void
pci_device_foreach(struct pcibios_softc *sc, pci_chipset_tag_t pc, int maxbus,
    void (*func)(struct pcibios_softc *, pci_chipset_tag_t, pcitag_t))
{
	const struct pci_quirkdata *qd;
	int bus, device, function, maxdevs, nfuncs;
	pcireg_t id, bhlcr;
	pcitag_t tag;

	for (bus = 0; bus <= maxbus; bus++) {
		maxdevs = pci_bus_maxdevs(pc, bus);
		for (device = 0; device < maxdevs; device++) {
			tag = pci_make_tag(pc, bus, device, 0);
			id = pci_conf_read(pc, tag, PCI_ID_REG);

			/* Invalid vendor ID value? */
			if (PCI_VENDOR(id) == PCI_VENDOR_INVALID)
				continue;
			/* XXX Not invalid, but we've done this ~forever. */
			if (PCI_VENDOR(id) == 0)
				continue;

			qd = pci_lookup_quirkdata(PCI_VENDOR(id),
			    PCI_PRODUCT(id));

			bhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);
			if (PCI_HDRTYPE_MULTIFN(bhlcr) ||
			    (qd != NULL &&
			     (qd->quirks & PCI_QUIRK_MULTIFUNCTION) != 0))
				nfuncs = 8;
			else
				nfuncs = 1;

			for (function = 0; function < nfuncs; function++) {
				tag = pci_make_tag(pc, bus, device, function);
				id = pci_conf_read(pc, tag, PCI_ID_REG);

				/* Invalid vendor ID value? */
				if (PCI_VENDOR(id) == PCI_VENDOR_INVALID)
					continue;
				/*
				 * XXX Not invalid, but we've done this
				 * ~forever.
				 */
				if (PCI_VENDOR(id) == 0)
					continue;
				(*func)(sc, pc, tag);
			}
		}
	}
}
@


1.47
log
@convert several malloc(9) to mallocarray(9).

ok deraadt@@ guenther@@ "re-wrap the long lines" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.46 2015/07/17 21:36:56 mlarkin Exp $	*/
d324 3
a326 1
			free(pcibios_pir_table, M_DEVBUF, 0);
@


1.46
log
@
Include executable mapping for BIOS32 pages. Fixes a problem where mappings
done in this region using PAE w/NX caused #PFs (as they lacked the exec
permission previously).

Also unmap the region when we're finished. No sense in leaving extra
executable regions lying around.

Fixes non-ACPI uniprocessor i386 machines that have NX/PAE (these would
previously panic in pcibiosattach).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.45 2014/07/12 18:44:42 tedu Exp $	*/
d313 1
a313 1
		pcibios_pir_table = malloc(pcibios_pir_table_nentries *
@


1.45
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.44 2014/03/29 18:09:29 guenther Exp $	*/
d231 2
@


1.44
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.43 2013/11/28 19:30:46 brad Exp $	*/
d322 1
a322 1
			free(pcibios_pir_table, M_DEVBUF);
@


1.43
log
@Appease LLVM's integrated assembler.

error: ambiguous instructions require an explicit suffix (could be 'cmpb', 'cmpw', 'cmpl', or 'cmpq'
error: unknown token in expression

cmp -> cmpl, %cs:* -> *%cs:

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.42 2013/10/01 20:22:12 sf Exp $	*/
d345 1
a345 1
	__asm __volatile("pushl	%%es\n\t"
d398 1
a398 1
	__asm __volatile("pushl	%%es\n\t"
@


1.42
log
@Format string fixes: %hu/%hd for uint16_t, %u/%d/%x for uint32_t

- despite the name, ntohl returns uint32_t, not long
- also fix some %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.41 2013/10/01 20:05:58 sf Exp $	*/
d349 1
a349 1
			 "lcall	%%cs:*(%%edi)\n\t"
d402 1
a402 1
			 "lcall	%%cs:*(%%esi)\n\t"
@


1.41
log
@Use %z* for size_t

while there, fix a few %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.40 2010/11/20 20:11:19 miod Exp $	*/
d154 1
a154 1
	PCIBIOS_PRINTV(("pcibiosprobe: 0x%lx:0x%lx at 0x%lx[0x%lx]\n",
d175 1
a175 1
	printf(": rev %d.%d @@ 0x%lx/0x%lx\n",
@


1.40
log
@__attribute__((packed)) -> __packed. The ioprbs.c chunk was commented out, and
uncommenting it is intentional.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.39 2008/06/26 05:42:11 ray Exp $	*/
d263 1
a263 1
		    "(%d entries)\n", sc->sc_dev.dv_xname,
@


1.39
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.38 2007/12/05 19:17:13 deraadt Exp $	*/
d390 1
a390 1
	} __attribute__((__packed__)) args;
@


1.38
log
@Hang acpi(4) below bios(4) instead of mainbus(4).  This lets us move acpi(4)
before pcibios(4), and then.... if acpi(4) attaches, skip pcibios(4) since
it messes the machines up.  Fixes claudio's HP dl320 G5, and almost assuredly
others.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.37 2007/03/19 05:32:05 deraadt Exp $	*/
a44 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.37
log
@typo fixes; didickman@@gmail
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.36 2007/02/20 21:15:01 tom Exp $	*/
d155 1
a155 1
	if (strcmp(ba->bios_dev, "pcibios"))
@


1.36
log
@Revert PAE pmap for now, until the strange bug is found.  This stops
the freezes many of us are seeing (especially on amd64 machines running
OpenBSD/i386).

Much testing by nick@@ (as always - thanks!), hugh@@, ian@@, kettenis@@
and Sam Smith (s (at) msmith (dot) net).

Requested by, input from, and ok deraadt@@  ok art@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.35 2006/11/29 22:40:13 miod Exp $	*/
d374 1
a374 1
	 * Fill in the various pieces if info we're looking for.
@


1.35
log
@Nuke all commons but one, and enable --warn-common in LINKFLAGS.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.34 2006/09/19 11:06:34 jsg Exp $	*/
d269 1
a269 1
		printf("%s: PCI IRQ Routing Table rev %d.%d @@ 0x%llx/%d "
@


1.34
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.33 2006/04/27 15:37:55 mickey Exp $	*/
d110 1
@


1.33
log
@implement separate PAE pmap that allows access to 64g of physmem
if supported by the cpu(s). currently not enabled by default and
not compiled into ramdisks. this grows paddr_t to 64bit but yet
leaves bus_addr_t at 32bits. measures are taken to favour dmaable
memory allocation from below 4g line such that buffer cache is
already allocated form below, pool backend allocator prefers lower
memory and then finally bounce buffers are used as last resort.
PAE is engaged only if global variable cpu_pae is manually set
to non-zero and there is physical memory present above 4g.
simplify pcibios address math to use u_long as we always will
be in the 32bit space.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.32 2005/01/08 18:17:58 mickey Exp $	*/
d148 1
a148 3
pcibiosprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d170 1
a170 3
pcibiosattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d240 1
a240 2
pcibios_pir_init(sc)
	struct pcibios_softc *sc;
d344 3
a346 4
pcibios_get_status(sc, rev_maj, rev_min, mech1, mech2, scmech1, scmech2, maxbus)
	struct pcibios_softc *sc;
	u_int32_t *rev_maj, *rev_min, *mech1, *mech2, *scmech1, *scmech2,
	    *maxbus;
d387 2
a388 5
pcibios_get_intr_routing(sc, table, nentries, exclirq)
	struct pcibios_softc *sc;
	struct pcibios_intr_routing *table;
	int *nentries;
	u_int16_t *exclirq;
d429 1
a429 4
pcibios_return_code(sc, ax, func)
	struct pcibios_softc *sc;
	u_int16_t ax;
	const char *func;
d483 1
a483 2
pcibios_print_exclirq(sc)
	struct pcibios_softc *sc;
d498 1
a498 1
pcibios_print_pir_table()
d517 2
a518 5
pci_device_foreach(sc, pc, maxbus, func)
	struct pcibios_softc *sc;
	pci_chipset_tag_t pc;
	int maxbus;
	void (*func)(struct pcibios_softc *, pci_chipset_tag_t, pcitag_t);
@


1.32
log
@replace magic numbers w/ a proper sizeof; from peter@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.31 2005/01/04 21:19:15 espie Exp $	*/
d273 1
a273 1
		printf("%s: PCI IRQ Routing Table rev %d.%d @@ 0x%lx/%d "
@


1.31
log
@silence real gcc 3.3.5
okay mickey@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.30 2004/08/09 19:52:06 deraadt Exp $	*/
d300 1
a300 1
		    malloc(pirh->tablesize - 32, M_DEVBUF, M_NOWAIT);
d305 4
a308 2
		bcopy(p + 32, pcibios_pir_table, pirh->tablesize - 32);
		pcibios_pir_table_nentries = (pirh->tablesize - 32) / 16;
@


1.30
log
@rev not rev.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.29 2003/06/03 20:10:32 mickey Exp $	*/
d255 2
a256 1
		pirh = (struct pcibios_pir_header *)p = ISA_HOLE_VADDR(pa);
@


1.29
log
@three four kill
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.28 2003/04/17 03:42:14 drahn Exp $	*/
d185 1
a185 1
	printf(": rev. %d.%d @@ 0x%lx/0x%lx\n",
d272 1
a272 1
		printf("%s: PCI IRQ Routing Table rev. %d.%d @@ 0x%lx/%d "
@


1.28
log
@i386 changes to move to ELF. asm cleanup. Change MAXDSIZ to 512M for 1Gsep.
DARPA funded work.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.27 2002/07/12 21:17:06 mickey Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.27
log
@check upon the pir length prior to using it, ignore short tables; from henric@@attbi.com
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.26 2002/03/21 22:47:02 millert Exp $	*/
d361 1
a361 1
			 "movw	4(%%edi), %%ecx\n\t"
d363 1
a363 1
			 "lcall	%%cs:(%%edi)\n\t"
d417 1
a417 1
			 "movw	4(%%esi), %%ecx\n\t"
d419 1
a419 1
			 "lcall	%%cs:(%%esi)\n\t"
@


1.26
log
@Some laptops (such as the Toshiba Libretto L series) use _PIR instead
of the standard $PIR for the signature so for that too.  From NetBSD and
FreeBSD.  mickey@@ says commitski
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.25 2002/03/14 01:26:33 millert Exp $	*/
d270 3
d280 1
a280 1
		    pirh->tablesize, (pirh->tablesize - 32) / 16);
d288 1
a288 1
		if (pirh->tablesize < 32 || (pirh->tablesize % 16) != 0) {
@


1.25
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.24 2001/05/12 19:12:44 mickey Exp $	*/
d261 7
a267 1
		if (pirh->signature != BIOS32_MAKESIG('$', 'P', 'I', 'R'))
@


1.24
log
@always print the icu we've found
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.23 2001/02/28 20:33:30 mickey Exp $	*/
d125 1
a125 1
struct pcibios_intr_routing *pcibios_pir_init __P((struct pcibios_softc *));
d127 1
a127 1
int	pcibios_get_status __P((struct pcibios_softc *,
d129 3
a131 3
	    u_int32_t *, u_int32_t *, u_int32_t *, u_int32_t *));
int	pcibios_get_intr_routing __P((struct pcibios_softc *,
	    struct pcibios_intr_routing *, int *, u_int16_t *));
d133 1
a133 1
int	pcibios_return_code __P((struct pcibios_softc *, u_int16_t, const char *));
d135 2
a136 2
void	pcibios_print_exclirq __P((struct pcibios_softc *));
void	pcibios_print_pir_table __P((void));
d145 2
a146 2
int pcibiosprobe __P((struct device *, void *, void *));
void pcibiosattach __P((struct device *, struct device *, void *));
d527 1
a527 1
	void (*func) __P((struct pcibios_softc *, pci_chipset_tag_t, pcitag_t));
@


1.24.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.24 2001/05/12 19:12:44 mickey Exp $	*/
d125 1
a125 1
struct pcibios_intr_routing *pcibios_pir_init(struct pcibios_softc *);
d127 1
a127 1
int	pcibios_get_status(struct pcibios_softc *,
d129 3
a131 3
	    u_int32_t *, u_int32_t *, u_int32_t *, u_int32_t *);
int	pcibios_get_intr_routing(struct pcibios_softc *,
	    struct pcibios_intr_routing *, int *, u_int16_t *);
d133 1
a133 1
int	pcibios_return_code(struct pcibios_softc *, u_int16_t, const char *);
d135 2
a136 2
void	pcibios_print_exclirq(struct pcibios_softc *);
void	pcibios_print_pir_table(void);
d145 2
a146 2
int pcibiosprobe(struct device *, void *, void *);
void pcibiosattach(struct device *, struct device *, void *);
d261 1
a261 7
		/*
		 * Some laptops (such as the Toshiba Libretto L series)
		 * use _PIR instead of the standard $PIR for the signature
		 * so we check for that too.
		 */
		if (pirh->signature != BIOS32_MAKESIG('$', 'P', 'I', 'R') &&
		    pirh->signature != BIOS32_MAKESIG('_', 'P', 'I', 'R'))
d527 1
a527 1
	void (*func)(struct pcibios_softc *, pci_chipset_tag_t, pcitag_t);
@


1.24.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.24.4.1 2002/06/11 03:35:54 art Exp $	*/
a269 3
		if (pirh->tablesize < sizeof(*pirh))
			continue;

d277 1
a277 1
		    pirh->tablesize, (pirh->tablesize - sizeof(*pirh)) / 16);
d285 1
a285 1
		if (pirh->tablesize % 16 != 0) {
@


1.24.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d361 1
a361 1
			 "movw	4(%%edi), %%cx\n\t"
d363 1
a363 1
			 "lcall	%%cs:*(%%edi)\n\t"
d417 1
a417 1
			 "movw	4(%%esi), %%cx\n\t"
d419 1
a419 1
			 "lcall	%%cs:*(%%esi)\n\t"
@


1.23
log
@shorter thus better printings
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.22 2001/01/27 20:54:41 mickey Exp $	*/
d218 1
a218 1
		rv = pci_intr_fixup(NULL, I386_BUS_SPACE_IO);
a255 1
		char devinfo[256];
a302 9
		printf("%s: PCI Interrupt Router at %03d:%02d:%01d",
		    sc->sc_dev.dv_xname, pirh->router_bus,
		    PIR_DEVFUNC_DEVICE(pirh->router_devfunc),
		    PIR_DEVFUNC_FUNCTION(pirh->router_devfunc));
		if (pirh->compat_router != 0) {
			pci_devinfo(pirh->compat_router, 0, 0, devinfo);
			printf(" (%s)", devinfo);
		}
		printf("\n");
@


1.23.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.23 2001/02/28 20:33:30 mickey Exp $	*/
@


1.23.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.23.2.1 2001/04/18 16:08:29 niklas Exp $	*/
d218 1
a218 1
		rv = pci_intr_fixup(sc, NULL, I386_BUS_SPACE_IO);
d256 1
d304 9
@


1.23.2.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d125 1
a125 1
struct pcibios_intr_routing *pcibios_pir_init(struct pcibios_softc *);
d127 1
a127 1
int	pcibios_get_status(struct pcibios_softc *,
d129 3
a131 3
	    u_int32_t *, u_int32_t *, u_int32_t *, u_int32_t *);
int	pcibios_get_intr_routing(struct pcibios_softc *,
	    struct pcibios_intr_routing *, int *, u_int16_t *);
d133 1
a133 1
int	pcibios_return_code(struct pcibios_softc *, u_int16_t, const char *);
d135 2
a136 2
void	pcibios_print_exclirq(struct pcibios_softc *);
void	pcibios_print_pir_table(void);
d145 2
a146 2
int pcibiosprobe(struct device *, void *, void *);
void pcibiosattach(struct device *, struct device *, void *);
d527 1
a527 1
	void (*func)(struct pcibios_softc *, pci_chipset_tag_t, pcitag_t);
@


1.23.2.4
log
@Sync the SMP branch with 3.3
@
text
@d261 1
a261 7
		/*
		 * Some laptops (such as the Toshiba Libretto L series)
		 * use _PIR instead of the standard $PIR for the signature
		 * so we check for that too.
		 */
		if (pirh->signature != BIOS32_MAKESIG('$', 'P', 'I', 'R') &&
		    pirh->signature != BIOS32_MAKESIG('_', 'P', 'I', 'R'))
a263 3
		if (pirh->tablesize < sizeof(*pirh))
			continue;

d271 1
a271 1
		    pirh->tablesize, (pirh->tablesize - sizeof(*pirh)) / 16);
d279 1
a279 1
		if (pirh->tablesize % 16 != 0) {
@


1.23.2.5
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.23.2.4 2003/03/27 23:26:56 niklas Exp $	*/
d361 1
a361 1
			 "movw	4(%%edi), %%cx\n\t"
d363 1
a363 1
			 "lcall	%%cs:*(%%edi)\n\t"
d417 1
a417 1
			 "movw	4(%%esi), %%cx\n\t"
d419 1
a419 1
			 "lcall	%%cs:*(%%esi)\n\t"
@


1.23.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.23.2.5 2003/05/13 19:42:08 ho Exp $	*/
d16 5
@


1.22
log
@patchable no verbose default pcibios_flags
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.21 2001/01/27 04:59:40 mickey Exp $	*/
d190 1
a190 1
	printf(": rev. %d.%d found at 0x%lx[0x%lx]\n",
d269 2
a270 2
		printf("%s: PCI IRQ Routing Table rev. %d.%d found at 0x%lx, "
		    "size %d bytes (%d entries)\n", sc->sc_dev.dv_xname,
@


1.21
log
@change interrupt routing strategy from simple
run through the devices and programming the icu
and pci headers before real pci bus autoconf starts
and include all devices present on all pci busses,
to a per attached device routing in pci_intr_map().
this solves several cases of premature interrupts hanging
system due to absent interrupt handlers during autoconf.
10x for testing: millert@@ krw@@ aaron@@ chris@@ tholo@@ brad@@ jason@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.20 2001/01/25 00:07:40 mickey Exp $	*/
d120 1
a174 2

int pcibios_flags = -1;
@


1.20
log
@put pci_intr_fixup.h into pcibiosvar.h; billions of tiny headers for nothing
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.19 2001/01/24 23:40:29 mickey Exp $	*/
a69 1

a114 4
#ifdef PCIBIOSVERBOSE
int	pcibiosverbose = 1;
#endif

a119 1
int pcibios_max_bus;
a123 4
struct pcibios_softc {
	struct  device sc_dev;
};

a134 1
#ifdef PCIINTR_DEBUG
a135 1
#endif
d166 3
a168 7
#ifdef PCIBIOSVERBOSE
	printf("pcibiosprobe: 0x%lx:0x%lx at 0x%lx[0x%lx]\n",
	    pcibios_entry.segment,
	    pcibios_entry.offset,
	    pcibios_entry_info.bei_base,
	    pcibios_entry_info.bei_size);
#endif
d189 1
a189 1
	    &scmech1, &scmech2, &pcibios_max_bus);
d194 5
a198 9
#ifdef PCIBIOSVERBOSE
	printf("%s: config mechanism %s%s, special cycles %s%s, last bus %d\n",
	    sc->sc_dev.dv_xname,
	    mech1 ? "[1]" : "[x]",
	    mech2 ? "[2]" : "[x]",
	    scmech1 ? "[1]" : "[x]",
	    scmech2 ? "[2]" : "[x]",
	    pcibios_max_bus);
#endif
a214 1
		u_int16_t pciirq;
d219 1
a219 1
		rv = pci_intr_fixup(NULL, I386_BUS_SPACE_IO, &pciirq);
d240 1
a240 1
		pcibios_max_bus = pci_bus_fixup(NULL, 0);
d242 1
a242 1
		    sc->sc_dev.dv_xname, pcibios_max_bus);
d246 1
a246 1
		pci_addr_fixup(NULL, pcibios_max_bus);
d347 2
a348 3
#ifdef PCIINTR_DEBUG
	pcibios_print_pir_table();
#endif
d436 1
a436 1
	*exclirq = bx;
a513 1
#ifdef PCIINTR_DEBUG
a531 1
#endif
d534 2
a535 1
pci_device_foreach(pc, maxbus, func)
d538 1
a538 1
	void (*func) __P((pci_chipset_tag_t, pcitag_t));
d582 1
a582 1
				(*func)(pc, tag);
@


1.19
log
@put pci_addr_fixup.h into pcibiosvar.h as well,
all it had were a struct and a proto.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.18 2001/01/24 23:16:14 mickey Exp $	*/
a112 1
#include <i386/pci/pci_intr_fixup.h>
@


1.18
log
@elliminate pci_bus_fixup.h by moving
pci_bus_fixup() proto into pcibiosvar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.17 2000/10/31 18:56:42 deraadt Exp $	*/
a113 1
#include <i386/pci/pci_addr_fixup.h>
@


1.17
log
@rename pcibios.h to pcibiosvar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.16 2000/10/16 03:35:19 mickey Exp $	*/
a113 1
#include <i386/pci/pci_bus_fixup.h>
@


1.16
log
@protect %edx when calling bios
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.15 2000/10/16 03:22:06 mickey Exp $	*/
d112 1
a112 1
#include <i386/pci/pcibios.h>
@


1.15
log
@a little verbosity on probe, a little caution on bios calls
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.14 2000/09/22 02:00:43 mickey Exp $	*/
d454 1
a454 1
		: "%ecx", "cc", "memory");
@


1.14
log
@this follows the dox, saying that %ds should be loaded w/
the proper segment address/selector as returned from bios32_service().
both %cs and %ds have to be the same value (hmm, same descs?),
sincw some bioses are pic, and care only about offsets against the segs.
huge, enormous, 10X to brad@@ for providing an incredibly usefull
testbed and invaluable time of his, for resets and incouraging comments (;
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.13 2000/09/20 19:39:55 mickey Exp $	*/
d173 7
d181 9
a189 3
	return (!strcmp(ba->bios_dev, "pcibios") &&
	    bios32_service(PCIBIOS_SIGNATURE, &pcibios_entry,
		&pcibios_entry_info) &&
d191 1
a191 1
	        &scmech1, &scmech2, &maxbus) == PCIBIOS_SUCCESS);
d386 3
a388 2
	__asm __volatile("pushl	%%ds\n\t"
			 "movl	4(%%edi), %%ecx\n\t"
d392 1
d444 1
a444 1
			 "movl	4(%%esi), %%ecx\n\t"
@


1.13
log
@check out the bios device name we are probed w/ to not probe on apm
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.12 2000/09/07 20:50:39 mickey Exp $	*/
d131 1
a171 1
	struct bios32_entry_info ei;
d175 2
a176 1
	    bios32_service(PCIBIOS_SIGNATURE, &pcibios_entry, &ei) &&
a188 1
	struct bios32_entry_info ei;
a192 1
	bios32_service(PCIBIOS_SIGNATURE, &pcibios_entry, &ei);
d197 3
a199 2
	printf(": rev. %d.%d found at 0x%lx\n", rev_maj, rev_min >> 4,
	    ei.bei_entry);
d373 5
a377 1
	__asm __volatile("lcall	(%%edi)\n\t"
d427 7
a433 3
	__asm __volatile("pushl	%%ds\n\t"
			 "pushl	%%es\n\t"
			 "lcall	(%%esi)\n\t"
d436 1
a436 3
		    "1:\n\t"
			 "popl	%%es\n\t"
			 "popl	%%ds"
d439 1
a439 1
		: "cc", "memory");
@


1.12
log
@do not call pcibios_pir_init() if intr_fixup was disabled; also, sync w/ latetest netbsd developments
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.11 2000/09/05 21:44:14 mickey Exp $	*/
d170 1
d174 2
a175 1
	return (bios32_service(PCIBIOS_SIGNATURE, &pcibios_entry, &ei) &&
@


1.11
log
@init pcibios_flags to -1, so if pcibios is disabled in ukc all looks disabled
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.10 2000/09/04 17:13:28 mickey Exp $	*/
d136 1
a136 1
void	pcibios_pir_init __P((struct pcibios_softc *));
a218 1
	pcibios_pir_init((struct pcibios_softc *)self);
d221 1
a221 1
	    pcibios_pir_table != NULL) {
d258 1
a258 1
void
a261 1
	char devinfo[256];
a262 5
	caddr_t p;
	unsigned char cksum;
	u_int16_t tablesize;
	u_int8_t rev_maj, rev_min;
	int i;
d264 1
d266 7
a272 2
		p = (caddr_t)ISA_HOLE_VADDR(pa);
		if (*(int *)p != BIOS32_MAKESIG('$', 'P', 'I', 'R'))
a274 4
		rev_min = *(p + 4);
		rev_maj = *(p + 5);
		tablesize = *(u_int16_t *)(p + 6);

d276 2
a277 2
		for (i = 0; i < tablesize; i++)
			cksum += *(unsigned char *)(p + i);
d280 3
a282 3
		    "size %d bytes (%d entries)\n",
		    sc->sc_dev.dv_xname, rev_maj, rev_min, pa,
		    tablesize, (tablesize - 32) / 16);
d290 2
a291 3
		if (tablesize < 32 || (tablesize % 16) != 0) {
			printf("%s: bad IRQ table size\n",
			    sc->sc_dev.dv_xname);
d295 1
a295 1
		if (rev_maj != 1 || rev_min != 0) {
d304 3
a306 3
		bcopy(p, &pcibios_pir_header, 32);
		pcibios_pir_table = malloc(tablesize - 32, M_DEVBUF,
		    M_NOWAIT);
d308 2
a309 3
			printf("%s: no memory for $PIR\n",
			    sc->sc_dev.dv_xname);
			return;
d311 2
a312 2
		bcopy(p + 32, pcibios_pir_table, tablesize - 32);
		pcibios_pir_table_nentries = (tablesize - 32) / 16;
d315 5
a319 6
		    sc->sc_dev.dv_xname, pcibios_pir_header.router_bus,
		    PIR_DEVFUNC_DEVICE(pcibios_pir_header.router_devfunc),
		    PIR_DEVFUNC_FUNCTION(pcibios_pir_header.router_devfunc));
		if (pcibios_pir_header.compat_router != 0) {
			pci_devinfo(pcibios_pir_header.compat_router, 0, 0,
			    devinfo);
a322 5
		pcibios_print_exclirq(sc);
#ifdef PCIINTR_DEBUG
		pcibios_print_pir_table();
#endif
		return;
a331 3
	pcibios_pir_table_nentries = 32;
	pcibios_pir_table = malloc(pcibios_pir_table_nentries *
	    sizeof(*pcibios_pir_table), M_DEVBUF, M_NOWAIT);
d333 20
a352 3
		printf("%s: no memory for $PIR\n",
		    sc->sc_dev.dv_xname);
		return;
d354 1
a354 12
	if (pcibios_get_intr_routing(sc, pcibios_pir_table,
	    &pcibios_pir_table_nentries,
	    &pcibios_pir_header.exclusive_irq) != PCIBIOS_SUCCESS) {
		printf("%s: No PCI IRQ Routing information available.\n",
		    sc->sc_dev.dv_xname);
		free(pcibios_pir_table, M_DEVBUF);
		pcibios_pir_table = NULL;
		pcibios_pir_table_nentries = 0;
		return;
	}
	printf("%s: PCI BIOS has %d Interrupt Routing table entries\n",
	    sc->sc_dev.dv_xname, pcibios_pir_table_nentries);
d359 1
d368 1
a368 2
	u_int16_t ax, bx, cx;
	u_int32_t edx;
d371 4
a374 4
	__asm __volatile("lcall (%%edi)					; \
			jc 1f						; \
			xor %%ah, %%ah					; \
		1:"
d376 2
a377 1
		: "0" (0xb101), "D" (&pcibios_entry));
d407 1
a407 1
	u_int16_t ax, bx;
d411 1
a411 1
		caddr_t offset;
d416 1
a416 1
	args.offset = (caddr_t)table;
d421 8
a428 5
	__asm __volatile("lcall (%%esi)					; \
			jc 1f						; \
			xor %%ah, %%ah					; \
		1:	movw %w2, %%ds					; \
			movw %w2, %%es"
d430 2
a431 2
		: "r" GSEL(GDATA_SEL, SEL_KPL), "0" (0xb10e), "1" (0),
		  "D" (&args), "S" (&pcibios_entry));
@


1.10
log
@update netbsd rcsid, which we seem to be up to
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.9 2000/09/04 17:00:17 deraadt Exp $	*/
d178 1
a178 1
int pcibios_flags;
@


1.9
log
@fix dmesg output
@
text
@d1 2
a2 2
/*	$OpenBSD: pcibios.c,v 1.8 2000/09/04 16:58:41 mickey Exp $	*/
/*	$NetBSD: pcibios.c,v 1.4 2000/07/18 11:15:25 soda Exp $	*/
@


1.8
log
@export pcibios config flags
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.7 2000/08/17 20:15:40 mickey Exp $	*/
d132 3
a134 1
void	pcibios_pir_init __P((void));
d136 4
a139 1
int	pcibios_get_status __P((u_int32_t *, u_int32_t *, u_int32_t *,
d141 2
a142 2
int	pcibios_get_intr_routing __P((struct pcibios_intr_routing *,
	    int *, u_int16_t *));
d144 1
a144 1
int	pcibios_return_code __P((u_int16_t, const char *));
d146 1
a146 1
void	pcibios_print_exclirq __P((void));
a153 4
struct pcibios_softc {
	struct  device sc_dev;
};

d174 1
a174 1
	    pcibios_get_status(&rev_maj, &rev_min, &mech1, &mech2,
d192 2
a193 1
	pcibios_get_status(&rev_maj, &rev_min, &mech1, &mech2,
d219 1
a219 1
	pcibios_pir_init();
d233 2
a234 2
			printf("Warning: unable to fix up PCI interrupt "
			    "routing\n");
d239 1
a239 1
			printf("pcibios_init: interrupt fixup failed\n");
d251 2
a252 1
		printf("PCI bus #%d is the last bus\n", pcibios_max_bus);
d260 2
a261 1
pcibios_pir_init()
d284 3
a286 2
		printf("PCI IRQ Routing Table rev. %d.%d found at 0x%lx, "
		    "size %d bytes (%d entries)\n", rev_maj, rev_min, pa,
d290 2
a291 1
			printf("pcibios_pir_init: bad IRQ table checksum\n");
d296 2
a297 1
			printf("pcibios_pir_init: bad IRQ table size\n");
d302 2
a303 2
			printf("pcibios_pir_init: unsupported IRQ table "
			    "version\n");
d314 2
a315 1
			printf("pcibios_pir_init: no memory for $PIR\n");
d321 2
a322 2
		printf("PCI Interrupt Router at %03d:%02d:%01d",
		    pcibios_pir_header.router_bus,
d331 1
a331 1
		pcibios_print_exclirq();
d349 2
a350 1
		printf("pcibios_pir_init: no memory for $PIR\n");
d353 1
a353 1
	if (pcibios_get_intr_routing(pcibios_pir_table,
d356 2
a357 1
		printf("No PCI IRQ Routing information available.\n");
d363 3
a365 3
	printf("PCI BIOS has %d Interrupt Routing table entries\n",
	    pcibios_pir_table_nentries);
	pcibios_print_exclirq();
d372 2
a373 1
pcibios_get_status(rev_maj, rev_min, mech1, mech2, scmech1, scmech2, maxbus)
d388 1
a388 1
	rv = pcibios_return_code(ax, "pcibios_get_status");
d410 2
a411 1
pcibios_get_intr_routing(table, nentries, exclirq)
d439 1
a439 1
	rv = pcibios_return_code(ax, "pcibios_get_intr_routing");
d450 2
a451 1
pcibios_return_code(ax, func)
d457 6
d497 2
a498 1
		printf("%s: unknown return code 0x%x\n", func, rv);
d502 1
a502 1
	printf("%s: %s\n", func, errstr);
d507 2
a508 1
pcibios_print_exclirq()
d513 1
a513 1
		printf("PCI Exclusive IRQs:");
@


1.7
log
@pcibios0 at bios0 flags 0x0000
this is now a real device, which looks in flags for disabling
address, interrupt or bus fixup.
bios0's flags are to disable bios32 and pcibios probing.
since boot_config support editing flags, it's posible
to adjust pcibios functionality in the generic kernel
upon boot time. man is coming.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.6 2000/08/08 19:12:48 mickey Exp $	*/
d177 2
d187 2
a188 1
	int flags = sc->sc_dev.dv_cfdata->cf_flags;
d219 1
a219 1
	if (!(flags & PCIBIOS_INTR_FIXUP) &&
d247 1
a247 1
	if (!(flags & PCIBIOS_BUS_FIXUP)) {
d252 1
a252 1
	if (!(flags & PCIBIOS_ADDR_FIXUP))
@


1.6
log
@sync w/ netbsd almost -current code (;
fixes quite a few problems.
adds new option PCIBIOS_ADDR_FIXUP.
numerous extra fixes by me, also pointed out by other ppl,
such as avoid panics, ifdef on pciverbose, not diagnostic,
some other smaller knits; some have been forwarded back
to netbsd developers, some will go soon too.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.5 2000/07/06 18:42:18 mickey Exp $	*/
d4 30
a112 1
#ifdef PCIBIOS_INTR_FIXUP
a113 2
#endif
#ifdef PCIBIOS_BUS_FIXUP
a114 2
#endif
#ifdef PCIBIOS_ADDR_FIXUP
a115 1
#endif
a116 3
#ifdef __NetBSD__
#include <machine/bios32.h>
#elif __OpenBSD__
a117 1
#endif
d149 28
d178 3
a180 1
pcibios_init()
d182 1
d185 1
d187 3
a189 21
	if (bios32_service(BIOS32_MAKESIG('$', 'P', 'C', 'I'),
	    &pcibios_entry, &ei) == 0) {
		/*
		 * No PCI BIOS found; will fall back on old
		 * mechanism.
		 */
		return;
	}

	/*
	 * We've located the PCI BIOS service; get some information
	 * about it.
	 */
	if (pcibios_get_status(&rev_maj, &rev_min, &mech1, &mech2,
	    &scmech1, &scmech2, &pcibios_max_bus) != PCIBIOS_SUCCESS) {
		/*
		 * We can't use the PCI BIOS; will fall back on old
		 * mechanism.
		 */
		return;
	}
d191 1
a191 1
	printf("PCI BIOS rev. %d.%d found at 0x%lx\n", rev_maj, rev_min >> 4,
d194 2
a195 2
	printf("pcibios: config mechanism %s%s, special cycles %s%s, "
	    "last bus %d\n",
a200 1

d216 2
a217 2
#ifdef PCIBIOS_INTR_FIXUP
	if (pcibios_pir_table != NULL) {
a242 1
#endif
d244 4
a247 6
#ifdef PCIBIOS_BUS_FIXUP
	pcibios_max_bus = pci_bus_fixup(NULL, 0);
#ifdef PCIBIOSVERBOSE
	printf("PCI bus #%d is the last bus\n", pcibios_max_bus);
#endif
#endif
d249 2
a250 3
#ifdef PCIBIOS_ADDR_FIXUP
	pci_addr_fixup(NULL, pcibios_max_bus);
#endif
@


1.5
log
@dummy me, forgot \n in panic->printf transition
@
text
@d1 2
a2 2
/*	$OpenBSD: pcibios.c,v 1.4 2000/07/06 18:32:15 mickey Exp $	*/
/*	$NetBSD: pcibios.c,v 1.2 1999/11/17 07:33:41 thorpej Exp $	*/
d80 1
d89 3
d99 4
d218 4
d283 2
a284 2
		    (pcibios_pir_header.router_devfunc >> 3) & 0x1f,
		    pcibios_pir_header.router_devfunc & 7);
d479 1
a479 1
		    pcibios_pir_table[i].device >> 3);
d489 54
@


1.4
log
@don't panic for nothing
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.3 2000/03/28 03:37:59 mickey Exp $	*/
d193 1
a193 1
			printf("pcibios_init: interrupt fixup failed");
@


1.3
log
@fix netbsd rcsids up.
also, from the 3rd try make proper openbsd rcsids, rediculous
3 commits just to add proper openbsd rcsids.
i think someone forgot to _look_ at the diffs before commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcibios.c,v 1.2 2000/03/27 08:35:22 brad Exp $	*/
d193 2
a194 2
			panic("pcibios_init: interrupt fixup failed");
			break;
@


1.2
log
@add missing OpenBSD RCS IDs
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: pcibios.c,v 1.1 1999/11/17 01:16:37 thorpej Exp $	*/
@


1.1
log
@from netbsd: pci interrupt routing code.
also, change a few pcidevs names to match netbsd (and more descriptive).
tested on a bunch of laptops, helps resolving 'pin X unmapped'
problems for (usually) usb and cardbus cntrollers.
@
text
@d1 1
@

