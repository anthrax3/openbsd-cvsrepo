head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.10
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.12
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.8
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.4
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.8
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.4
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.17.0.10
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.8
	OPENBSD_5_0:1.17.0.6
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.4
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.16.0.4
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.10.0.6
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	UBC:1.1.0.6
	UBC_SYNC_A:1.1
	SMP:1.1.0.4
	OPENBSD_3_3:1.1.0.2
	OPENBSD_3_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.12.10.12.27.56;	author mikeb;	state Exp;
branches;
next	1.20;
commitid	v6PAeA18rydwc5Vx;

1.20
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.19;
commitid	uzzBR7hz9ncd4O6G;

1.19
date	2014.06.29.01.01.20;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	JGrnYVidTgBVOphO;

1.18
date	2012.10.17.22.32.01;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.14.07.58.45;	author grange;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.26.05.42.11;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.28.17.05.09;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.23.11.55.11;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.12.23.14.27;	author dim;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.21.19.34.34;	author grange;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.09.11.17.59;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.06.17.34.37;	author grange;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.05.15.06.22;	author grange;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.04.18.56.03;	author grange;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.14.15.09.22;	author grange;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.24.10.35.59;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.07.13.01.18;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.01.18.17.10;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.07.16.59.37;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.17.02.29;	author markus;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2004.06.05.23.09.00;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2004.06.07.20.41.11;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.06.10.11.40.25;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Convert watchdog(4) devices to use autoconf(9) framework.

ok deraadt, tests on glxpcib and ok mpi
@
text
@/*	$OpenBSD: elan520.c,v 1.20 2014/09/14 14:17:23 jsg Exp $	*/
/*	$NetBSD: elan520.c,v 1.4 2002/10/02 05:47:15 thorpej Exp $	*/

/*-
 * Copyright (c) 2002 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Device driver for the AMD Elan SC520 System Controller.  This attaches
 * where the "pchb" driver might normally attach, and provides support for
 * extra features on the SC520, such as the watchdog timer and GPIO.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/gpio.h>
#include <sys/sysctl.h>
#include <sys/time.h>
#include <sys/timetc.h>

#include <machine/bus.h>

#include <machine/cpufunc.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/gpio/gpiovar.h>

#include <arch/i386/pci/elan520reg.h>

struct elansc_softc {
	struct device		sc_dev;
	bus_space_tag_t		sc_memt;
	bus_space_handle_t	sc_memh;

	/* GPIO interface */
	struct gpio_chipset_tag sc_gpio_gc;
	gpio_pin_t sc_gpio_pins[ELANSC_PIO_NPINS];

	/* GP timer */
	struct timecounter	sc_tc;
} *elansc;

int	elansc_match(struct device *, void *, void *);
void	elansc_attach(struct device *, struct device *, void *);
int	elansc_activate(struct device *, int);
void	elansc_update_cpuspeed(void);
void	elansc_setperf(int);
int	elansc_cpuspeed(int *);

void	elansc_wdogctl(struct elansc_softc *, int, uint16_t);
#define elansc_wdogctl_reset(sc)	elansc_wdogctl(sc, 1, 0)
#define elansc_wdogctl_write(sc, val)	elansc_wdogctl(sc, 0, val)
int	elansc_wdogctl_cb(void *, int);

int	elansc_gpio_pin_read(void *, int);
void	elansc_gpio_pin_write(void *, int, int);
void	elansc_gpio_pin_ctl(void *, int, int);

u_int	elansc_tc_read(struct timecounter *);

struct cfattach elansc_ca = {
	sizeof(struct elansc_softc), elansc_match, elansc_attach,
	NULL, elansc_activate
};

struct cfdriver elansc_cd = {
	NULL, "elansc", DV_DULL
};

int
elansc_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_AMD &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AMD_ELANSC520)
		return (10);	/* beat pchb */

	return (0);
}

static const char *elansc_speeds[] = {
	"(reserved 00)",
	"100MHz",
	"133MHz",
	"(reserved 11)",
};

#define RSTBITS "\20\x07SCP\x06HRST\x05SRST\x04WDT\x03SD\x02PRGRST\x01PWRGOOD"

void
elansc_attach(struct device *parent, struct device *self, void *aux)
{
	struct elansc_softc *sc = (void *) self;
	struct pci_attach_args *pa = aux;
	struct gpiobus_attach_args gba;
	struct timecounter *tc;
	uint16_t rev, data;
	uint8_t ressta, cpuctl, tmr;
	int pin, reg, shift;

	sc->sc_memt = pa->pa_memt;
	if (bus_space_map(sc->sc_memt, MMCR_BASE_ADDR, NBPG, 0,
	    &sc->sc_memh) != 0) {
		printf(": unable to map registers\n");
		return;
	}

	rev = bus_space_read_2(sc->sc_memt, sc->sc_memh, MMCR_REVID);
	cpuctl = bus_space_read_1(sc->sc_memt, sc->sc_memh, MMCR_CPUCTL);
	ressta = bus_space_read_1(sc->sc_memt, sc->sc_memh, MMCR_RESSTA);

	printf(": product %d stepping %d.%d, CPU clock %s, reset %b\n",
	    (rev & REVID_PRODID) >> REVID_PRODID_SHIFT,
	    (rev & REVID_MAJSTEP) >> REVID_MAJSTEP_SHIFT,
	    (rev & REVID_MINSTEP),
	    elansc_speeds[cpuctl & CPUCTL_CPU_CLK_SPD_MASK],
	    ressta, RSTBITS);

	/*
	 * Determine cause of the last reset, and issue a warning if it
	 * was due to watchdog expiry.
	 */
	if (ressta & RESSTA_WDT_RST_DET)
		printf("%s: WARNING: LAST RESET DUE TO WATCHDOG EXPIRATION!\n",
		    sc->sc_dev.dv_xname);
	bus_space_write_1(sc->sc_memt, sc->sc_memh, MMCR_RESSTA, ressta);

	/* Set up the watchdog registers with some defaults. */
	elansc_wdogctl_write(sc, WDTMRCTL_WRST_ENB | WDTMRCTL_EXP_SEL30);

	/* ...and clear it. */
	elansc_wdogctl_reset(sc);

	wdog_register(elansc_wdogctl_cb, sc);
	elansc = sc;
	cpu_setperf = elansc_setperf;
	cpu_cpuspeed = elansc_cpuspeed;
	elansc_update_cpuspeed();

	/* Initialize GPIO pins array */
	for (pin = 0; pin < ELANSC_PIO_NPINS; pin++) {
		sc->sc_gpio_pins[pin].pin_num = pin;
		sc->sc_gpio_pins[pin].pin_caps = GPIO_PIN_INPUT |
		    GPIO_PIN_OUTPUT;

		/* Read initial state */
		reg = (pin < 16 ? MMCR_PIODIR15_0 : MMCR_PIODIR31_16);
		shift = pin % 16;
		data = bus_space_read_2(sc->sc_memt, sc->sc_memh, reg);
		if ((data & (1 << shift)) == 0)
			sc->sc_gpio_pins[pin].pin_flags = GPIO_PIN_INPUT;
		else
			sc->sc_gpio_pins[pin].pin_flags = GPIO_PIN_OUTPUT;
		if (elansc_gpio_pin_read(sc, pin) == 0)
			sc->sc_gpio_pins[pin].pin_state = GPIO_PIN_LOW;
		else
			sc->sc_gpio_pins[pin].pin_state = GPIO_PIN_HIGH;
	}

	/* Create controller tag */
	sc->sc_gpio_gc.gp_cookie = sc;
	sc->sc_gpio_gc.gp_pin_read = elansc_gpio_pin_read;
	sc->sc_gpio_gc.gp_pin_write = elansc_gpio_pin_write;
	sc->sc_gpio_gc.gp_pin_ctl = elansc_gpio_pin_ctl;

	gba.gba_name = "gpio";
	gba.gba_gc = &sc->sc_gpio_gc;
	gba.gba_pins = sc->sc_gpio_pins;
	gba.gba_npins = ELANSC_PIO_NPINS;

	/* Attach GPIO framework */
	config_found(&sc->sc_dev, &gba, gpiobus_print);

	/* Disable GP1/2, clear the current count, and set the period to max */
	bus_space_write_2(sc->sc_memt, sc->sc_memh, GPTMR1CTL,
		GPTMRCTL_ENB_WR | GPTMRCTL_CONT_CMP |
		GPTMRCTL_PSC_SEL | GPTMRCTL_RTG);
	bus_space_write_2(sc->sc_memt, sc->sc_memh, GPTMR1CNT, 0);
	bus_space_write_2(sc->sc_memt, sc->sc_memh, GPTMR1MAXCMPA, 0);

	bus_space_write_2(sc->sc_memt, sc->sc_memh, GPTMR2CTL,
		GPTMRCTL_ENB_WR | GPTMRCTL_CONT_CMP);
	bus_space_write_2(sc->sc_memt, sc->sc_memh, GPTMR2CNT, 0);
	bus_space_write_2(sc->sc_memt, sc->sc_memh, GPTMR2MAXCMPA, 0);

	tmr = bus_space_read_1(sc->sc_memt, sc->sc_memh, SWTMRCFG);

	/* Enable GP1/2 */
	bus_space_write_2(sc->sc_memt, sc->sc_memh, GPTMR1CTL,
		GPTMRCTL_ENB | GPTMRCTL_ENB_WR | GPTMRCTL_CONT_CMP |
		GPTMRCTL_PSC_SEL | GPTMRCTL_RTG);
	bus_space_write_2(sc->sc_memt, sc->sc_memh, GPTMR2CTL,
		GPTMRCTL_ENB | GPTMRCTL_ENB_WR | GPTMRCTL_CONT_CMP);

	/* Attach timer */
	tc = &sc->sc_tc;
	tc->tc_get_timecount = elansc_tc_read;
	tc->tc_poll_pps = NULL;
	tc->tc_counter_mask = ~0;
	tc->tc_frequency = (tmr & 1) ? (33000000 / 4) : (33333333 / 4);
	tc->tc_name = sc->sc_dev.dv_xname;
	tc->tc_quality = 1000;
	tc->tc_priv = sc;
	tc_init(tc);
}

int
elansc_activate(struct device *self, int act)
{
	switch (act) {
	case DVACT_POWERDOWN:
		wdog_shutdown(self);
		break;
	}

	return (0);
}

u_int
elansc_tc_read(struct timecounter *tc)
{
	struct elansc_softc *sc = tc->tc_priv;
	u_int32_t m1, m2, l;

	do {
		m1 = bus_space_read_2(sc->sc_memt, sc->sc_memh, GPTMR1CNT);
		l = bus_space_read_2(sc->sc_memt, sc->sc_memh, GPTMR2CNT);
		m2 = bus_space_read_2(sc->sc_memt, sc->sc_memh, GPTMR1CNT);
	} while (m1 != m2);

	return ((m1 << 16) | l);
}

void
elansc_wdogctl(struct elansc_softc *sc, int do_reset, uint16_t val)
{
	int s;
	uint8_t echo_mode;

	s = splhigh();

	/* Switch off GP bus echo mode. */
	echo_mode = bus_space_read_1(sc->sc_memt, sc->sc_memh, MMCR_GPECHO);
	bus_space_write_1(sc->sc_memt, sc->sc_memh, MMCR_GPECHO,
	    echo_mode & ~GPECHO_GP_ECHO_ENB);

	if (do_reset) {
		/* Reset the watchdog. */
		bus_space_write_2(sc->sc_memt, sc->sc_memh, MMCR_WDTMRCTL,
		    WDTMRCTL_RESET1);
		bus_space_write_2(sc->sc_memt, sc->sc_memh, MMCR_WDTMRCTL,
		    WDTMRCTL_RESET2);
	} else {
		/* Unlock the register. */
		bus_space_write_2(sc->sc_memt, sc->sc_memh, MMCR_WDTMRCTL,
		    WDTMRCTL_UNLOCK1);
		bus_space_write_2(sc->sc_memt, sc->sc_memh, MMCR_WDTMRCTL,
		    WDTMRCTL_UNLOCK2);

		/* Write the value. */
		bus_space_write_2(sc->sc_memt, sc->sc_memh, MMCR_WDTMRCTL,
		   val);
	}

	/* Switch GP bus echo mode back. */
	bus_space_write_1(sc->sc_memt, sc->sc_memh, MMCR_GPECHO, echo_mode);

	splx(s);
}

static const struct {
	int	period;		/* whole seconds */
	uint16_t exp;		/* exponent select */
} elansc_wdog_periods[] = {
	{ 1,	WDTMRCTL_EXP_SEL25 },
	{ 2,	WDTMRCTL_EXP_SEL26 },
	{ 4,	WDTMRCTL_EXP_SEL27 },
	{ 8,	WDTMRCTL_EXP_SEL28 },
	{ 16,	WDTMRCTL_EXP_SEL29 },
	{ 32,	WDTMRCTL_EXP_SEL30 },
};

int
elansc_wdogctl_cb(void *self, int period)
{
	struct elansc_softc *sc = self;
	int i;

	if (period == 0) {
		elansc_wdogctl_write(sc,
		    WDTMRCTL_WRST_ENB | WDTMRCTL_EXP_SEL30);
	} else {
		for (i = 0; i < (sizeof(elansc_wdog_periods) /
		    sizeof(elansc_wdog_periods[0])) - 1; i++)
			if (elansc_wdog_periods[i].period >= period)
				break;
		period = elansc_wdog_periods[i].period;
		elansc_wdogctl_write(sc, WDTMRCTL_ENB |
		    WDTMRCTL_WRST_ENB | elansc_wdog_periods[i].exp);
		elansc_wdogctl_reset(sc);
	}
	return (period);
}

void
elansc_update_cpuspeed(void)
{
	static const int elansc_mhz[] = { 0, 100, 133, 999 };
	uint8_t cpuctl;

	cpuctl = bus_space_read_1(elansc->sc_memt, elansc->sc_memh,
	    MMCR_CPUCTL);
	cpuspeed = elansc_mhz[cpuctl & CPUCTL_CPU_CLK_SPD_MASK];
}

void
elansc_setperf(int level)
{
	uint32_t eflags;
	uint8_t cpuctl, speed;

	level = (level > 50) ? 100 : 0;

	cpuctl = bus_space_read_1(elansc->sc_memt, elansc->sc_memh,
	    MMCR_CPUCTL);
	speed = (level == 100) ? 2 : 1;
	if ((cpuctl & CPUCTL_CPU_CLK_SPD_MASK) == speed)
		return;

	eflags = read_eflags();
	disable_intr();
	bus_space_write_1(elansc->sc_memt, elansc->sc_memh, MMCR_CPUCTL,
	    (cpuctl & ~CPUCTL_CPU_CLK_SPD_MASK) | speed);
	enable_intr();
	write_eflags(eflags);

	elansc_update_cpuspeed();
}

int
elansc_cpuspeed(int *freq)
{
	*freq = cpuspeed;
	return (0);
}

int
elansc_gpio_pin_read(void *arg, int pin)
{
	struct elansc_softc *sc = arg;
	int reg, shift;
	u_int16_t data;

	reg = (pin < 16 ? MMCR_PIODATA15_0 : MMCR_PIODATA31_16);
	shift = pin % 16;
	data = bus_space_read_2(sc->sc_memt, sc->sc_memh, reg);

	return ((data >> shift) & 0x1);
}

void
elansc_gpio_pin_write(void *arg, int pin, int value)
{
	struct elansc_softc *sc = arg;
	int reg, shift;
	u_int16_t data;

	reg = (pin < 16 ? MMCR_PIODATA15_0 : MMCR_PIODATA31_16);
	shift = pin % 16;
	data = bus_space_read_2(sc->sc_memt, sc->sc_memh, reg);
	if (value == 0)
		data &= ~(1 << shift);
	else if (value == 1)
		data |= (1 << shift);

	bus_space_write_2(sc->sc_memt, sc->sc_memh, reg, data);
}

void
elansc_gpio_pin_ctl(void *arg, int pin, int flags)
{
	struct elansc_softc *sc = arg;
	int reg, shift;
	u_int16_t data;

	reg = (pin < 16 ? MMCR_PIODIR15_0 : MMCR_PIODIR31_16);
	shift = pin % 16;
	data = bus_space_read_2(sc->sc_memt, sc->sc_memh, reg);
	if (flags & GPIO_PIN_INPUT)
		data &= ~(1 << shift);
	if (flags & GPIO_PIN_OUTPUT)
		data |= (1 << shift);

	bus_space_write_2(sc->sc_memt, sc->sc_memh, reg, data);
}
@


1.20
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.19 2014/06/29 01:01:20 deraadt Exp $	*/
d73 1
d90 2
a91 1
	sizeof(struct elansc_softc), elansc_match, elansc_attach
d234 12
@


1.19
log
@Don't ridiculously assume that sysctl.h will (through a set of extremely
unfortunate circumstances) pull machine/cpufunc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.18 2012/10/17 22:32:01 deraadt Exp $	*/
a42 1
#include <sys/proc.h>
@


1.18
log
@Swap arguments to wdog_register() since it is nicer, and prepare
wdog_shutdown() for external usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.17 2010/04/20 22:05:41 tedu Exp $	*/
d49 2
@


1.17
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.16 2009/01/14 07:58:45 grange Exp $	*/
d160 1
a160 1
	wdog_register(sc, elansc_wdogctl_cb);
@


1.16
log
@int cpuspeed is global. ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.15 2008/06/26 05:42:11 ray Exp $	*/
d43 1
@


1.15
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.14 2007/11/28 17:05:09 tedu Exp $	*/
a92 2

static int cpuspeed;
@


1.14
log
@quite a bit of simplification by removing cpu classes.
also assume that 386 cpus are really unknown, and promote them to 486
instead of panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.13 2007/05/23 11:55:11 markus Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.13
log
@timecounter support (e.g. soekris net4501); ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.12 2006/12/12 23:14:27 dim Exp $	*/
a329 1
#ifdef I586_CPU
a330 1
#endif
a334 1
#ifdef I586_CPU
a335 1
#endif
@


1.12
log
@Complete gwk's previous patch to stop setperf methods from returning
errors to userland: make all cpu_setperf functions return void.

Tested by many, ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.11 2005/10/21 19:34:34 grange Exp $	*/
d51 2
d71 3
d91 2
d130 4
a133 5
	uint16_t rev;
	uint8_t ressta, cpuctl;
	int pin;
	int reg, shift;
	u_int16_t data;
d207 47
@


1.11
log
@amd elan is not a pentium, it's i486, so don't touch pentium_mhz
varibale, it's used by microtime to check if we're running on a pentium
cpu (which has rdtsc instruction). fixes pr 4568. tested by oc@@symacx.com.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.10 2004/06/09 11:17:59 djm Exp $	*/
d74 1
a74 1
int	elansc_setperf(int);
d289 1
a289 1
int
d301 1
a301 1
		return (0);
a310 2

	return (0);
@


1.10
log
@fix compilation for !I586_CPU case; ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.9 2004/06/06 17:34:37 grange Exp $	*/
d75 1
d94 2
d165 2
d285 1
a285 1
	pentium_mhz = elansc_mhz[cpuctl & CPUCTL_CPU_CLK_SPD_MASK];
d312 7
@


1.9
log
@Don't touch any hardware registers while fetching hw.cpuspeed and
just return current pentium_mhz value. Update this value in
all hw.setperf hoos either via its own private methods or using
global update_cpuspeed hook, if registered.
Also implement update_cpuspeed hook for Pentium 3.

Tested by millert@@, Gabriel Kihlman <gk@@stacken.kth.se> and me on
various i386 machines.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.8 2004/06/05 15:06:22 grange Exp $	*/
d272 1
d274 1
d279 1
d281 1
@


1.8
log
@GPIO support for AMD Elan SC520 found on Soekris net45x1 boards.

Test and ok markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.7 2004/06/04 18:56:03 grange Exp $	*/
d73 1
a73 1
int	elansc_cpuspeed(int *);
a160 1
	cpu_cpuspeed = elansc_cpuspeed;
d269 2
a270 2
int
elansc_cpuspeed(int *freq)
d277 1
a277 2
	*freq = elansc_mhz[cpuctl & CPUCTL_CPU_CLK_SPD_MASK];
	return (0);
d300 2
@


1.7
log
@Kill sys/cdefs.h
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.6 2004/02/14 15:09:22 grange Exp $	*/
d49 1
d57 2
d65 4
d81 4
d119 1
d122 3
d163 34
d304 50
@


1.6
log
@Simplify hw.{cpuspeed,setperf} api moving all the sysctl stuff
from the underlying callbacks.

Testing hppa mickey@@, ppc drahn@@
Ok markus@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.5 2003/12/24 10:35:59 markus Exp $	*/
a45 1
#include <sys/cdefs.h>
@


1.5
log
@setperf and cpuspeed support; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.4 2003/10/07 13:01:18 markus Exp $	*/
d67 2
a68 2
int	elansc_cpuspeed(void *, size_t *, void *, size_t);
int	elansc_setperf(void *, size_t *, void *, size_t);
d223 1
a223 1
elansc_cpuspeed(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
d230 2
a231 2
	return (sysctl_rdint(oldp, oldlenp, newp,
	    elansc_mhz[cpuctl & CPUCTL_CPU_CLK_SPD_MASK]));
d235 1
a235 1
elansc_setperf(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
a236 2
	static int level = 100;
	int error;
a239 4
	if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &level)))
		return (error);
	if (newp == NULL)
		return (0);
@


1.4
log
@remove extra \n
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.3 2003/09/01 18:17:10 markus Exp $	*/
d50 1
d63 1
a63 1
};
d67 2
d146 3
d220 42
@


1.3
log
@remove unused sc_echobug code; ok fgs, mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.2 2003/08/07 16:59:37 mickey Exp $	*/
a107 2

	printf("\n");
@


1.2
log
@better dmesg output and do some spaces; markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: elan520.c,v 1.1 2003/01/21 17:02:29 markus Exp $	*/
a43 3
 *
 * Information about the GP bus echo bug work-around is from code posted
 * to the "soekris-tech" mailing list by Jasper Wallace.
a61 1
	int			sc_echobug;
a129 17
	 * SC520 rev A1 has a bug that affects the watchdog timer.  If
	 * the GP bus echo mode is enabled, writing to the watchdog control
	 * register is blocked.
	 *
	 * The BIOS in some systems (e.g. the Soekris net4501) enables
	 * GP bus echo for various reasons, so we need to switch it off
	 * when we talk to the watchdog timer.
	 *
	 * XXX The step 1.1 (B1?) in my Soekris net4501 also has this
	 * XXX problem, so we'll just enable it for all Elan SC520s
	 * XXX for now.  --thorpej@@netbsd.org
	 */
	if (1 || rev == ((PRODID_ELAN_SC520 << REVID_PRODID_SHIFT) |
	   (0 << REVID_MAJSTEP_SHIFT) | (1)))
		sc->sc_echobug = 1;

	/*
d155 4
a158 7
	/* Switch off GP bus echo mode if we need to. */
	if (sc->sc_echobug) {
		echo_mode = bus_space_read_1(sc->sc_memt, sc->sc_memh,
		    MMCR_GPECHO);
		bus_space_write_1(sc->sc_memt, sc->sc_memh,
		    MMCR_GPECHO, echo_mode & ~GPECHO_GP_ECHO_ENB);
	}
d179 1
a179 3
	if (sc->sc_echobug)
		bus_space_write_1(sc->sc_memt, sc->sc_memh, MMCR_GPECHO,
		    echo_mode);
@


1.1
log
@add elan520 from netbsd; adapted to watchdog sysctl interface;
ok mickey@@, jakob@@, henric@@, fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: $	*/
d81 1
a81 1
        NULL, "elansc", DV_DULL
d118 1
a118 1
		printf("%s: unable to map registers\n", sc->sc_dev.dv_xname);
d126 1
a126 3
	printf("%s: product %d stepping %d.%d, CPU clock %s"
	    ", reset %b",
	    sc->sc_dev.dv_xname,
a131 2

	printf("\n");
@


1.1.4.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 3
a52 1
#include <sys/sysctl.h>
d65 2
a66 1
} *elansc;
a69 2
int	elansc_cpuspeed(void *, size_t *, void *, size_t);
int	elansc_setperf(void *, size_t *, void *, size_t);
d81 1
a81 1
	NULL, "elansc", DV_DULL
d113 2
d118 1
a118 1
		printf(": unable to map registers\n");
d126 3
a128 1
	printf(": product %d stepping %d.%d, CPU clock %s, reset %b\n",
d135 19
a169 3
	elansc = sc;
	cpu_cpuspeed = elansc_cpuspeed;
	cpu_setperf = elansc_setperf;
d180 7
a186 4
	/* Switch off GP bus echo mode. */
	echo_mode = bus_space_read_1(sc->sc_memt, sc->sc_memh, MMCR_GPECHO);
	bus_space_write_1(sc->sc_memt, sc->sc_memh, MMCR_GPECHO,
	    echo_mode & ~GPECHO_GP_ECHO_ENB);
d207 3
a209 1
	bus_space_write_1(sc->sc_memt, sc->sc_memh, MMCR_GPECHO, echo_mode);
a245 42
}

int
elansc_cpuspeed(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
{
	static const int elansc_mhz[] = { 0, 100, 133, 999 };
	uint8_t cpuctl;

	cpuctl = bus_space_read_1(elansc->sc_memt, elansc->sc_memh,
	    MMCR_CPUCTL);
	return (sysctl_rdint(oldp, oldlenp, newp,
	    elansc_mhz[cpuctl & CPUCTL_CPU_CLK_SPD_MASK]));
}

int
elansc_setperf(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
{
	static int level = 100;
	int error;
	uint32_t eflags;
	uint8_t cpuctl, speed;

	if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &level)))
		return (error);
	if (newp == NULL)
		return (0);
	level = (level > 50) ? 100 : 0;

	cpuctl = bus_space_read_1(elansc->sc_memt, elansc->sc_memh,
	    MMCR_CPUCTL);
	speed = (level == 100) ? 2 : 1;
	if ((cpuctl & CPUCTL_CPU_CLK_SPD_MASK) == speed)
		return (0);

	eflags = read_eflags();
	disable_intr();
	bus_space_write_1(elansc->sc_memt, elansc->sc_memh, MMCR_CPUCTL,
	    (cpuctl & ~CPUCTL_CPU_CLK_SPD_MASK) | speed);
	enable_intr();
	write_eflags(eflags);

	return (0);
@


1.1.4.2
log
@Merge with the trunk
@
text
@d46 1
a49 1
#include <sys/gpio.h>
a56 2
#include <dev/gpio/gpiovar.h>

a62 4

	/* GPIO interface */
	struct gpio_chipset_tag sc_gpio_gc;
	gpio_pin_t sc_gpio_pins[ELANSC_PIO_NPINS];
d67 2
a68 2
int	elansc_cpuspeed(int *);
int	elansc_setperf(int);
a74 4
int	elansc_gpio_pin_read(void *, int);
void	elansc_gpio_pin_write(void *, int, int);
void	elansc_gpio_pin_ctl(void *, int, int);

a108 1
	struct gpiobus_attach_args gba;
a110 3
	int pin;
	int reg, shift;
	u_int16_t data;
a148 34

	/* Initialize GPIO pins array */
	for (pin = 0; pin < ELANSC_PIO_NPINS; pin++) {
		sc->sc_gpio_pins[pin].pin_num = pin;
		sc->sc_gpio_pins[pin].pin_caps = GPIO_PIN_INPUT |
		    GPIO_PIN_OUTPUT;

		/* Read initial state */
		reg = (pin < 16 ? MMCR_PIODIR15_0 : MMCR_PIODIR31_16);
		shift = pin % 16;
		data = bus_space_read_2(sc->sc_memt, sc->sc_memh, reg);
		if ((data & (1 << shift)) == 0)
			sc->sc_gpio_pins[pin].pin_flags = GPIO_PIN_INPUT;
		else
			sc->sc_gpio_pins[pin].pin_flags = GPIO_PIN_OUTPUT;
		if (elansc_gpio_pin_read(sc, pin) == 0)
			sc->sc_gpio_pins[pin].pin_state = GPIO_PIN_LOW;
		else
			sc->sc_gpio_pins[pin].pin_state = GPIO_PIN_HIGH;
	}

	/* Create controller tag */
	sc->sc_gpio_gc.gp_cookie = sc;
	sc->sc_gpio_gc.gp_pin_read = elansc_gpio_pin_read;
	sc->sc_gpio_gc.gp_pin_write = elansc_gpio_pin_write;
	sc->sc_gpio_gc.gp_pin_ctl = elansc_gpio_pin_ctl;

	gba.gba_name = "gpio";
	gba.gba_gc = &sc->sc_gpio_gc;
	gba.gba_pins = sc->sc_gpio_pins;
	gba.gba_npins = ELANSC_PIO_NPINS;

	/* Attach GPIO framework */
	config_found(&sc->sc_dev, &gba, gpiobus_print);
d223 1
a223 1
elansc_cpuspeed(int *freq)
d230 2
a231 2
	*freq = elansc_mhz[cpuctl & CPUCTL_CPU_CLK_SPD_MASK];
	return (0);
d235 1
a235 1
elansc_setperf(int level)
d237 2
d242 4
a261 50
}

int
elansc_gpio_pin_read(void *arg, int pin)
{
	struct elansc_softc *sc = arg;
	int reg, shift;
	u_int16_t data;

	reg = (pin < 16 ? MMCR_PIODATA15_0 : MMCR_PIODATA31_16);
	shift = pin % 16;
	data = bus_space_read_2(sc->sc_memt, sc->sc_memh, reg);

	return ((data >> shift) & 0x1);
}

void
elansc_gpio_pin_write(void *arg, int pin, int value)
{
	struct elansc_softc *sc = arg;
	int reg, shift;
	u_int16_t data;

	reg = (pin < 16 ? MMCR_PIODATA15_0 : MMCR_PIODATA31_16);
	shift = pin % 16;
	data = bus_space_read_2(sc->sc_memt, sc->sc_memh, reg);
	if (value == 0)
		data &= ~(1 << shift);
	else if (value == 1)
		data |= (1 << shift);

	bus_space_write_2(sc->sc_memt, sc->sc_memh, reg, data);
}

void
elansc_gpio_pin_ctl(void *arg, int pin, int flags)
{
	struct elansc_softc *sc = arg;
	int reg, shift;
	u_int16_t data;

	reg = (pin < 16 ? MMCR_PIODIR15_0 : MMCR_PIODIR31_16);
	shift = pin % 16;
	data = bus_space_read_2(sc->sc_memt, sc->sc_memh, reg);
	if (flags & GPIO_PIN_INPUT)
		data &= ~(1 << shift);
	if (flags & GPIO_PIN_OUTPUT)
		data |= (1 << shift);

	bus_space_write_2(sc->sc_memt, sc->sc_memh, reg, data);
@


1.1.4.3
log
@sync to head
@
text
@d73 1
a73 1
void	elansc_update_cpuspeed(void);
d161 1
d270 2
a271 2
void
elansc_update_cpuspeed(void)
d278 2
a279 1
	pentium_mhz = elansc_mhz[cpuctl & CPUCTL_CPU_CLK_SPD_MASK];
a301 2

	elansc_update_cpuspeed();
@


1.1.4.4
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@a271 1
#ifdef I586_CPU
a272 1
#endif
a276 1
#ifdef I586_CPU
a277 1
#endif
@


