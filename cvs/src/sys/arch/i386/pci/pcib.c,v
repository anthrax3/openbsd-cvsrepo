head	1.24;
access;
symbols
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.14
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.10
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.12
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.4
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.8
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.6
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.12
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.10
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.8
	OPENBSD_5_0:1.23.0.6
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.4
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.6
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.4
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.19.0.8
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.6
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.4
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.6
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.24
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.08.20.17.54;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2009.05.18.17.50.24;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.26.05.42.11;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2006.09.19.11.06.34;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.07.02.24.18;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2004.10.03.11.11.37;	author grange;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.08.05.10.12;	author grange;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.06.22.38.44;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.06.19.47.03;	author grange;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.27.21.46.44;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.27.21.15.45;	author grange;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.19.21.38.44;	author grange;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.19.21.35.56;	author grange;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.18.21.08.01;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.27.04.59.40;	author mickey;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	2000.03.27.08.35.22;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.26.22.38.37;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.09.17.08.05;	author millert;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.09.13.13.08.13;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.07.18.00.57.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	98.11.24.03.12.04;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	98.07.03.08.15.10;	author deraadt;	state Exp;
branches;
next	;

1.5.2.1
date	2001.04.18.16.08.29;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.03.28.10.31.05;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.06.07.11.11.38;	author ho;	state Exp;
branches;
next	;

1.8.6.1
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@/*	$OpenBSD: pcib.c,v 1.23 2010/07/08 20:17:54 deraadt Exp $	*/
/*	$NetBSD: pcib.c,v 1.6 1997/06/06 23:29:16 thorpej Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <dev/isa/isavar.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>

#include <dev/pci/pcidevs.h>

#include "isa.h"
#include "pcibios.h"
#if NPCIBIOS > 0
#include <i386/pci/pcibiosvar.h>
#endif

int	pcibmatch(struct device *, void *, void *);
void	pcibattach(struct device *, struct device *, void *);
void	pcib_callback(struct device *);
int	pcib_print(void *, const char *);

struct cfattach pcib_ca = {
	sizeof(struct device), pcibmatch, pcibattach
};

struct cfdriver pcib_cd = {
	NULL, "pcib", DV_DULL
};

int
pcibmatch(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	switch (PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_INTEL:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_INTEL_SIO:
		case PCI_PRODUCT_INTEL_82371MX:
		case PCI_PRODUCT_INTEL_82371AB_ISA:
		case PCI_PRODUCT_INTEL_82440MX_ISA:
			/* The above bridges mis-identify themselves */
			return (1);
		}
		break;
	case PCI_VENDOR_SIS:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_SIS_85C503:
			/* mis-identifies itself as a miscellaneous prehistoric */
			return (1);
		}
		break;
	case PCI_VENDOR_VIATECH:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_VIATECH_VT82C686A_SMB:
			/* mis-identifies itself as a ISA bridge */
			return (0);
		}
		break;
	}

	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_BRIDGE_ISA)
		return (1);

	return (0);
}

void
pcibattach(struct device *parent, struct device *self, void *aux)
{
	/*
	 * Cannot attach isa bus now; must postpone for various reasons
	 */
	printf("\n");

	config_defer(self, pcib_callback);
}

void
pcib_callback(struct device *self)
{
	struct isabus_attach_args iba;

#if NPCIBIOS > 0
	pci_intr_post_fixup();
#endif

	/*
	 * Attach the ISA bus behind this bridge.
	 */
	memset(&iba, 0, sizeof(iba));
	iba.iba_busname = "isa";
	iba.iba_iot = I386_BUS_SPACE_IO;
	iba.iba_memt = I386_BUS_SPACE_MEM;
#if NISADMA > 0
	iba.iba_dmat = &isa_bus_dma_tag;
#endif
	config_found(self, &iba, pcib_print);
}

int
pcib_print(void *aux, const char *pnp)
{
	/* Only ISAs can attach to pcib's; easy. */
	if (pnp)
		printf("isa at %s", pnp);
	return (UNCONF);
}
@


1.23
log
@use config_activate_children to get down to the isa bus activation code
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.22 2009/05/18 17:50:24 jsg Exp $	*/
d57 1
a57 2
	sizeof(struct device), pcibmatch, pcibattach, NULL,
	config_activate_children
@


1.22
log
@Add missing breaks so we don't fallthrough into
unwanted matching logic.
ok oga@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.21 2008/06/26 05:42:11 ray Exp $	*/
d57 2
a58 1
	sizeof(struct device), pcibmatch, pcibattach
@


1.21
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.20 2006/09/19 11:06:34 jsg Exp $	*/
d79 1
d86 1
d93 1
@


1.20
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.19 2005/01/07 02:24:18 brad Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.19
log
@rev 1.26

The VIA Technologies VT82C686A SMBus Controller claims to be a PCI/ISA
bridge, ignore it.

From NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.18 2004/10/03 11:11:37 grange Exp $	*/
d72 1
a72 3
pcibmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d108 1
a108 3
pcibattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d119 1
a119 2
pcib_callback(self)
	struct device *self;
d141 1
a141 3
pcib_print(aux, pnp)
	void *aux;
	const char *pnp;
@


1.18
log
@Kill <sys/types.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.17 2004/05/08 05:10:12 grange Exp $	*/
a77 4
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_BRIDGE &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_BRIDGE_ISA)
		return (1);

d94 6
d101 4
@


1.17
log
@Put back ichpcib(4), it works now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.16 2004/05/06 22:38:44 deraadt Exp $	*/
a39 1
#include <sys/types.h>
@


1.16
log
@back out kernel breakage.  Be more careful damnit
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.14 2004/02/27 21:46:44 grange Exp $	*/
a43 1
#include <sys/sysctl.h>
a52 2
#include <dev/pci/ichreg.h>

a63 12
int	ichss_match(void *);
int	ichss_attach(struct device *, void *);
int	ichss_setperf(int);

struct pcib_softc {
	struct device sc_dev;

	/* For power management capable bridges */
	bus_space_tag_t sc_pmt;
	bus_space_handle_t sc_pmh;
};

d65 1
a65 1
	sizeof(struct pcib_softc), pcibmatch, pcibattach
a71 2
extern int setperf_prio;

a108 9
#ifndef SMALL_KERNEL
	/*
	 * Detect and activate SpeedStep on ICHx-M chipsets.
	 */
	if (setperf_prio < 2 && ichss_match(aux) &&
	    ichss_attach(self, aux) == 0)
		printf(": SpeedStep");
#endif

a149 110

#ifndef SMALL_KERNEL
static void *ichss_cookie;	/* XXX */

int
ichss_match(void *aux)
{
	struct pci_attach_args *pa = aux;
	pcitag_t br_tag;
	pcireg_t br_id, br_class;

	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801DBM_LPC ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801CAM_LPC)
		return (1);
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801BAM_LPC) {
		/*
		 * Old revisions of the 82815 hostbridge found on
		 * Dell Inspirons 8000 and 8100 don't support
		 * SpeedStep.
		 */
		/* XXX: dev 0 func 0 is not always a hostbridge */
		br_tag = pci_make_tag(pa->pa_pc, pa->pa_bus, 0, 0);
		br_id = pci_conf_read(pa->pa_pc, br_tag, PCI_ID_REG);
		br_class = pci_conf_read(pa->pa_pc, br_tag, PCI_CLASS_REG);

		if (PCI_PRODUCT(br_id) == PCI_PRODUCT_INTEL_82815_FULL_HUB &&
		    PCI_REVISION(br_class) < 5)
			return (0);
		return (1);
	}

	return (0);
}

int
ichss_attach(struct device *self, void *aux)
{
	struct pcib_softc *sc = (struct pcib_softc *)self;
	struct pci_attach_args *pa = aux;
	pcireg_t pmbase;

	/* Map power management I/O space */
	sc->sc_pmt = pa->pa_iot;
	pmbase = pci_conf_read(pa->pa_pc, pa->pa_tag, ICH_PMBASE);
	if (bus_space_map(sc->sc_pmt, PCI_MAPREG_IO_ADDR(pmbase),
	    ICH_PMSIZE, 0, &sc->sc_pmh) != 0)
		return (1);

	/* Enable SpeedStep */
	pci_conf_write(pa->pa_pc, pa->pa_tag, ICH_GEN_PMCON1,
	    pci_conf_read(pa->pa_pc, pa->pa_tag, ICH_GEN_PMCON1) |
	    ICH_GEN_PMCON1_SS_EN);

	/* Hook into hw.setperf sysctl */
	ichss_cookie = sc;
	cpu_setperf = ichss_setperf;
	setperf_prio = 2;

	return (0);
}

int
ichss_setperf(int level)
{
	struct pcib_softc *sc = ichss_cookie;
	u_int8_t state, ostate, cntl;
	int s;

#ifdef DIAGNOSTIC
	if (sc == NULL) {
		printf("%s: no cookie", __func__);
		return (EFAULT);
	}
#endif

	s = splhigh();
	state = bus_space_read_1(sc->sc_pmt, sc->sc_pmh, ICH_PM_SS_CNTL);
	ostate = state;

	/* Only two states are available */
	if (level <= 50)
		state |= ICH_PM_SS_STATE_LOW;
	else
		state &= ~ICH_PM_SS_STATE_LOW;

	/*
	 * An Intel SpeedStep technology transition _always_ occur on
	 * writes to the ICH_PM_SS_CNTL register, even if the value
	 * written is the same as the previous value. So do the write
	 * only if the state has changed.
	 */
	if (state != ostate) {
		/* Disable bus mastering arbitration */
		cntl = bus_space_read_1(sc->sc_pmt, sc->sc_pmh, ICH_PM_CNTL);
		bus_space_write_1(sc->sc_pmt, sc->sc_pmh, ICH_PM_CNTL,
		    cntl | ICH_PM_ARB_DIS);

		/* Do the transition */
		bus_space_write_1(sc->sc_pmt, sc->sc_pmh, ICH_PM_SS_CNTL,
		    state);

		/* Restore bus mastering arbitration state */
		bus_space_write_1(sc->sc_pmt, sc->sc_pmh, ICH_PM_CNTL,
		    cntl);
	}
	splx(s);

	return (0);
}
#endif	/* !SMALL_KERNEL */
@


1.15
log
@Move speedstep code to a separate ichpcib(4) driver.
It attaches instead of pcib(4) and provides its usual
functionality (attaching isa bus) by calling pcibattach()
in the attach routine.

ok miod deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.10 2003/05/18 21:08:01 henning Exp $	*/
d44 1
d54 2
d67 12
d80 1
a80 1
	sizeof(struct device), pcibmatch, pcibattach
d87 2
d126 9
d176 110
@


1.14
log
@Move setperf_prio to the machdep code, requested by deraadt@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.13 2004/02/27 21:15:45 grange Exp $	*/
a43 1
#include <sys/sysctl.h>
a52 2
#include <dev/pci/ichreg.h>

a63 12
int	ichss_match(void *);
int	ichss_attach(struct device *, void *);
int	ichss_setperf(int);

struct pcib_softc {
	struct device sc_dev;

	/* For power management capable bridges */
	bus_space_tag_t sc_pmt;
	bus_space_handle_t sc_pmh;
};

d65 1
a65 1
	sizeof(struct pcib_softc), pcibmatch, pcibattach
a71 2
extern int setperf_prio;

a108 9
#ifndef SMALL_KERNEL
	/*
	 * Detect and activate SpeedStep on ICHx-M chipsets.
	 */
	if (setperf_prio < 2 && ichss_match(aux) &&
	    ichss_attach(self, aux) == 0)
		printf(": SpeedStep");
#endif

a149 110

#ifndef SMALL_KERNEL
static void *ichss_cookie;	/* XXX */

int
ichss_match(void *aux)
{
	struct pci_attach_args *pa = aux;
	pcitag_t br_tag;
	pcireg_t br_id, br_class;

	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801DBM_LPC ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801CAM_LPC)
		return (1);
	if (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801BAM_LPC) {
		/*
		 * Old revisions of the 82815 hostbridge found on
		 * Dell Inspirons 8000 and 8100 don't support
		 * SpeedStep.
		 */
		/* XXX: dev 0 func 0 is not always a hostbridge */
		br_tag = pci_make_tag(pa->pa_pc, pa->pa_bus, 0, 0);
		br_id = pci_conf_read(pa->pa_pc, br_tag, PCI_ID_REG);
		br_class = pci_conf_read(pa->pa_pc, br_tag, PCI_CLASS_REG);

		if (PCI_PRODUCT(br_id) == PCI_PRODUCT_INTEL_82815_FULL_HUB &&
		    PCI_REVISION(br_class) < 5)
			return (0);
		return (1);
	}

	return (0);
}

int
ichss_attach(struct device *self, void *aux)
{
	struct pcib_softc *sc = (struct pcib_softc *)self;
	struct pci_attach_args *pa = aux;
	pcireg_t pmbase;

	/* Map power management I/O space */
	sc->sc_pmt = pa->pa_iot;
	pmbase = pci_conf_read(pa->pa_pc, pa->pa_tag, ICH_PMBASE);
	if (bus_space_map(sc->sc_pmt, PCI_MAPREG_IO_ADDR(pmbase),
	    ICH_PMSIZE, 0, &sc->sc_pmh) != 0)
		return (1);

	/* Enable SpeedStep */
	pci_conf_write(pa->pa_pc, pa->pa_tag, ICH_GEN_PMCON1,
	    pci_conf_read(pa->pa_pc, pa->pa_tag, ICH_GEN_PMCON1) |
	    ICH_GEN_PMCON1_SS_EN);

	/* Hook into hw.setperf sysctl */
	ichss_cookie = sc;
	cpu_setperf = ichss_setperf;
	setperf_prio = 2;

	return (0);
}

int
ichss_setperf(int level)
{
	struct pcib_softc *sc = ichss_cookie;
	u_int8_t state, ostate, cntl;
	int s;

#ifdef DIAGNOSTIC
	if (sc == NULL) {
		printf("%s: no cookie", __func__);
		return (EFAULT);
	}
#endif

	s = splhigh();
	state = bus_space_read_1(sc->sc_pmt, sc->sc_pmh, ICH_PM_SS_CNTL);
	ostate = state;

	/* Only two states are available */
	if (level <= 50)
		state |= ICH_PM_SS_STATE_LOW;
	else
		state &= ~ICH_PM_SS_STATE_LOW;

	/*
	 * An Intel SpeedStep technology transition _always_ occur on
	 * writes to the ICH_PM_SS_CNTL register, even if the value
	 * written is the same as the previous value. So do the write
	 * only if the state has changed.
	 */
	if (state != ostate) {
		/* Disable bus mastering arbitration */
		cntl = bus_space_read_1(sc->sc_pmt, sc->sc_pmh, ICH_PM_CNTL);
		bus_space_write_1(sc->sc_pmt, sc->sc_pmh, ICH_PM_CNTL,
		    cntl | ICH_PM_ARB_DIS);

		/* Do the transition */
		bus_space_write_1(sc->sc_pmt, sc->sc_pmh, ICH_PM_SS_CNTL,
		    state);

		/* Restore bus mastering arbitration state */
		bus_space_write_1(sc->sc_pmt, sc->sc_pmh, ICH_PM_CNTL,
		    cntl);
	}
	splx(s);

	return (0);
}
#endif	/* !SMALL_KERNEL */
@


1.13
log
@Introduce simple priorities mechanism so that concurrent
hw.setperf handlers don't override each other.
Problem reported and tested by danh@@.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.12 2004/02/19 21:38:44 grange Exp $	*/
d86 2
@


1.12
log
@millert@@ suggested to use setperf=50 as a threshold for
the low perfomance state.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.11 2004/02/19 21:35:56 grange Exp $	*/
d128 2
a129 1
	if (ichss_match(aux) && ichss_attach(self, aux) == 0)
d230 1
@


1.11
log
@SpeedStep support for those Pentium processors which have
SpeedStep only as a chipset feature. This diff is for ICHx-M chipsets,
with 2 perfomance states available.

Tested by provos@@, sturm@@, millert@@
Ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.10 2003/05/18 21:08:01 henning Exp $	*/
d252 1
a252 1
	if (level < 50)
@


1.10
log
@match on Intel 82440MX PCI-ISA which misidentifies itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.9 2002/03/14 01:26:33 millert Exp $	*/
d44 1
d54 2
d67 12
d80 1
a80 1
	sizeof(struct device), pcibmatch, pcibattach
d124 8
d173 109
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.8 2001/01/27 04:59:40 mickey Exp $	*/
d89 1
@


1.8
log
@change interrupt routing strategy from simple
run through the devices and programming the icu
and pci headers before real pci bus autoconf starts
and include all devices present on all pci busses,
to a per attached device routing in pci_intr_map().
this solves several cases of premature interrupts hanging
system due to absent interrupt handlers during autoconf.
10x for testing: millert@@ krw@@ aaron@@ chris@@ tholo@@ brad@@ jason@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.7 2000/03/27 08:35:22 brad Exp $	*/
d59 4
a62 4
int	pcibmatch __P((struct device *, void *, void *));
void	pcibattach __P((struct device *, struct device *, void *));
void	pcib_callback __P((struct device *));
int	pcib_print __P((void *, const char *));
@


1.8.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.8 2001/01/27 04:59:40 mickey Exp $	*/
d59 4
a62 4
int	pcibmatch(struct device *, void *, void *);
void	pcibattach(struct device *, struct device *, void *);
void	pcib_callback(struct device *);
int	pcib_print(void *, const char *);
@


1.7
log
@add missing OpenBSD RCS IDs
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 4
d121 4
@


1.6
log
@from netbsd: pci interrupt routing code.
also, change a few pcidevs names to match netbsd (and more descriptive).
tested on a bunch of laptops, helps resolving 'pin X unmapped'
problems for (usually) usb and cardbus cntrollers.
@
text
@d1 1
@


1.5
log
@Change an instance of #if NISA that should be #if NISADMA
@
text
@d83 1
a83 1
		case PCI_PRODUCT_INTEL_82371AB:
@


1.5.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@a0 1
/*	$OpenBSD: pcib.c,v 1.8 2001/01/27 04:59:40 mickey Exp $	*/
a52 4
#include "pcibios.h"
#if NPCIBIOS > 0
#include <i386/pci/pcibiosvar.h>
#endif
d83 1
a83 1
		case PCI_PRODUCT_INTEL_82371AB_ISA:
a115 4

#if NPCIBIOS > 0
	pci_intr_post_fixup();
#endif
@


1.5.2.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 4
a62 4
int	pcibmatch(struct device *, void *, void *);
void	pcibattach(struct device *, struct device *, void *);
void	pcib_callback(struct device *);
int	pcib_print(void *, const char *);
@


1.5.2.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pcib.c,v 1.5.2.2 2002/03/28 10:31:05 niklas Exp $	*/
a88 1
		case PCI_PRODUCT_INTEL_82440MX_ISA:
@


1.4
log
@isa0 at pcib?; netbsd via peter
@
text
@d124 1
a124 1
#if NISA > 0
@


1.3
log
@SIS_85C503 misidenties itself; g.mcgarry@@qut.edu.au
@
text
@d45 1
d52 2
d56 1
a56 1

a66 1

d107 32
@


1.2
log
@deal with busses which misidentify; enami@@netbsd
@
text
@d85 6
@


1.1
log
@add stupid pcib driver
@
text
@d76 11
@

