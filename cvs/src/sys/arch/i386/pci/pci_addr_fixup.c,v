head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.14
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.10
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.6
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.8
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.22.0.14
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.12
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.10
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.8
	OPENBSD_5_0:1.22.0.6
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.21.0.12
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.14
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.10
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.8
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.6
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.4
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.14.0.14
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.12
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.10
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.8
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.6
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.14
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_9_BASE:1.9
	SMP:1.9.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5;
locks; strict;
comment	@ * @;


1.25
date	2014.05.04.20.09.15;	author sf;	state Exp;
branches;
next	1.24;

1.24
date	2013.10.02.21.06.17;	author sf;	state Exp;
branches;
next	1.23;

1.23
date	2013.10.01.19.41.33;	author sf;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.02.16.11.19;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.20.21.15.01;	author tom;	state Exp;
branches;
next	1.20;

1.20
date	2006.09.19.11.06.34;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2006.08.14.22.48.28;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.07.13.18.02.18;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.27.15.37.55;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.22.09.09.58;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.13.14.23.26;	author martin;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.14.21.34.58;	author todd;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.04.06.32.06;	author mickey;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.07.05.10.00.33;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.17.21.11.12;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.15.03.55.19;	author mickey;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.01.27.04.59.39;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.25.01.00.58;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.24.23.40.28;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.31.18.56.42;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.16.16.24.36;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.20.17.29.47;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.07.20.50.38;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.08.08.19.12.47;	author mickey;	state Exp;
branches;
next	;

1.9.2.1
date	2001.04.18.16.08.26;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.07.04.10.18.04;	author niklas;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2002.03.28.10.31.05;	author niklas;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2003.03.27.23.26.56;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.10.29.00.28.04;	author art;	state Exp;
branches;
next	;


desc
@@


1.25
log
@format string fixes for bus_addr_t and bus_size_t

bus_addr_t and bus_size_t are u_long everywhere

ok kettenis@@
@
text
@/*	$OpenBSD: pci_addr_fixup.c,v 1.24 2013/10/02 21:06:17 sf Exp $	*/
/*	$NetBSD: pci_addr_fixup.c,v 1.7 2000/08/03 20:10:45 nathanw Exp $	*/

/*-
 * Copyright (c) 2000 UCHIYAMA Yasushi.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/extent.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <i386/pci/pcibiosvar.h>

typedef int (*pciaddr_resource_manage_func_t)(struct pcibios_softc *, pci_chipset_tag_t, pcitag_t, int,
	struct extent *, int, bus_addr_t *, bus_size_t);
void	pciaddr_resource_manage(struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t, pciaddr_resource_manage_func_t);
void	pciaddr_resource_reserve(struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t);
void	pciaddr_resource_reserve_disabled(struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t);
int	pciaddr_do_resource_reserve(struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t, int, struct extent *, int,
    bus_addr_t *, bus_size_t);
int	pciaddr_do_resource_reserve_disabled(struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t, int, struct extent *, int, u_long *,
    bus_size_t);
void	pciaddr_resource_allocate(struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t);
int	pciaddr_do_resource_allocate(struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t, int, struct extent *, int, bus_addr_t *,
    bus_size_t);
bus_addr_t pciaddr_ioaddr(u_int32_t);
void	pciaddr_print_devid(pci_chipset_tag_t, pcitag_t);

int	pciaddr_device_is_agp(pci_chipset_tag_t, pcitag_t);

#define PCIADDR_MEM_START	0x0
#define PCIADDR_MEM_END		0xffffffff
#define PCIADDR_PORT_START	0x0
#define PCIADDR_PORT_END	0xffff

/* for ISA devices */
#define PCIADDR_ISAPORT_RESERVE	0x5800 /* empirical value */
#define PCIADDR_ISAMEM_RESERVE	(16 * 1024 * 1024)

void
pci_addr_fixup(struct pcibios_softc *sc, pci_chipset_tag_t pc, int maxbus)
{
	extern paddr_t avail_end;
	const char *verbose_header = 
		"[%s]-----------------------\n"
		"  device vendor product\n"
		"  register space address    size\n"
		"--------------------------------------------\n";
	const char *verbose_footer = 
		"--------------------------[%3d devices bogus]\n";

	const struct {
		bus_addr_t start;
		bus_size_t size;
		char *name;
	} system_reserve [] = {
		{ 0xfec00000, 0x100000, "I/O APIC" },
		{ 0xfee00000, 0x100000, "Local APIC" },
		{ 0xfffe0000, 0x20000, "BIOS PROM" },
		{ 0, 0, 0 }, /* terminator */
	}, *srp;
	paddr_t start;
	int error;

	sc->extent_mem = extent_create("PCI I/O memory space",
	    PCIADDR_MEM_START, PCIADDR_MEM_END, M_DEVBUF, 0, 0, EX_NOWAIT);
	KASSERT(sc->extent_mem);
	sc->extent_port = extent_create("PCI I/O port space",
	    PCIADDR_PORT_START, PCIADDR_PORT_END, M_DEVBUF, 0, 0, EX_NOWAIT);
	KASSERT(sc->extent_port);

	/* 
	 * 1. check & reserve system BIOS setting.
	 */
	PCIBIOS_PRINTV((verbose_header, "System BIOS Setting"));
	pci_device_foreach(sc, pc, maxbus, pciaddr_resource_reserve);
	pci_device_foreach(sc, pc, maxbus, pciaddr_resource_reserve_disabled);
	PCIBIOS_PRINTV((verbose_footer, sc->nbogus));

	/* 
	 * 2. reserve non-PCI area.
	 */
	for (srp = system_reserve; srp->size; srp++) {
		error = extent_alloc_region(sc->extent_mem, srp->start,
		    srp->size, EX_NOWAIT| EX_MALLOCOK);	
		if (error != 0)
			printf("WARNING: can't reserve area for %s.\n",
			       srp->name);
	}

	/* 
	 * 3. determine allocation space 
	 */
	start = round_page(avail_end + 1);
	if (start < PCIADDR_ISAMEM_RESERVE)
		start = PCIADDR_ISAMEM_RESERVE;
	sc->mem_alloc_start = (start + 0x100000 + 1) & ~(0x100000 - 1);
	sc->port_alloc_start = PCIADDR_ISAPORT_RESERVE;
	PCIBIOS_PRINTV((" Physical memory end: 0x%08lx\n PCI memory mapped I/O "
	    "space start: 0x%08lx\n", avail_end, sc->mem_alloc_start));

	/* 
	 * 4. do fixup 
	 */
	PCIBIOS_PRINTV((verbose_header, "PCIBIOS fixup stage"));
	sc->nbogus = 0;
	pci_device_foreach(sc, pc, maxbus, pciaddr_resource_allocate);
	PCIBIOS_PRINTV((verbose_footer, sc->nbogus));

}

void
pciaddr_resource_reserve(struct pcibios_softc *sc, pci_chipset_tag_t pc,
    pcitag_t tag)
{
	if (pcibios_flags & PCIBIOS_VERBOSE)
		pciaddr_print_devid(pc, tag);
	pciaddr_resource_manage(sc, pc, tag, pciaddr_do_resource_reserve);
}

void
pciaddr_resource_reserve_disabled(struct pcibios_softc *sc,
    pci_chipset_tag_t pc, pcitag_t tag)
{
	if (pcibios_flags & PCIBIOS_VERBOSE)
		pciaddr_print_devid(pc, tag);
	pciaddr_resource_manage(sc, pc, tag,
	    pciaddr_do_resource_reserve_disabled);
}

void
pciaddr_resource_allocate(struct pcibios_softc *sc, pci_chipset_tag_t pc,
    pcitag_t tag)
{
	if (pcibios_flags & PCIBIOS_VERBOSE)
		pciaddr_print_devid(pc, tag);
	pciaddr_resource_manage(sc, pc, tag, pciaddr_do_resource_allocate);
}

void
pciaddr_resource_manage(struct pcibios_softc *sc, pci_chipset_tag_t pc,
    pcitag_t tag, pciaddr_resource_manage_func_t func)
{
	struct extent *ex;
	pcireg_t val, mask;
	bus_addr_t addr;
	bus_size_t size;
	int error, mapreg, type, reg_start, reg_end, width;

	val = pci_conf_read(pc, tag, PCI_BHLC_REG);
	switch (PCI_HDRTYPE_TYPE(val)) {
	default:
		printf("WARNING: unknown PCI device header 0x%x.\n",
		    PCI_HDRTYPE_TYPE(val));
		sc->nbogus++;
		return;
	case 0: 
		reg_start = PCI_MAPREG_START;
		reg_end   = PCI_MAPREG_END;
		break;
	case 1: /* PCI-PCI bridge */
		reg_start = PCI_MAPREG_START;
		reg_end   = PCI_MAPREG_PPB_END;
		break;
	case 2: /* PCI-CardBus bridge */
		reg_start = PCI_MAPREG_START;
		reg_end   = PCI_MAPREG_PCB_END;
		break;
	}
	error = 0;
    
	for (mapreg = reg_start; mapreg < reg_end; mapreg += width) {
		/* inquire PCI device bus space requirement */
		val = pci_conf_read(pc, tag, mapreg);
		pci_conf_write(pc, tag, mapreg, ~0);

		mask = pci_conf_read(pc, tag, mapreg);
		pci_conf_write(pc, tag, mapreg, val);
	
		type = PCI_MAPREG_TYPE(val);
		width = 4;
		if (type == PCI_MAPREG_TYPE_MEM) {
			if (PCI_MAPREG_MEM_TYPE(val) == 
			    PCI_MAPREG_MEM_TYPE_64BIT) {
				/* XXX We could examine the upper 32 bits
				 * XXX of the BAR here, but we are totally 
				 * XXX unprepared to handle a non-zero value, 
				 * XXX either here or anywhere else in 
				 * XXX i386-land. 
				 * XXX So just arrange to not look at the
				 * XXX upper 32 bits, lest we misinterpret
				 * XXX it as a 32-bit BAR set to zero. 
				 */
			    width = 8;
			}
			addr = PCI_MAPREG_MEM_ADDR(val);
			size = PCI_MAPREG_MEM_SIZE(mask);
			ex = sc->extent_mem;
		} else {
			/* XXX some devices give 32bit value */
			addr = PCI_MAPREG_IO_ADDR(val) & PCIADDR_PORT_END;
			size = PCI_MAPREG_IO_SIZE(mask);
			ex = sc->extent_port;
		}
	
		if (!size) /* unused register */
			continue;

		/* reservation/allocation phase */
		error += (*func) (sc, pc, tag, mapreg, ex, type, &addr, size);

		PCIBIOS_PRINTV(("\t%02xh %s 0x%08x 0x%08x\n", 
				mapreg, type ? "port" : "mem ", 
				(unsigned int)addr, (unsigned int)size));
	}

	if (error)
		sc->nbogus++;

	PCIBIOS_PRINTV(("\t\t[%s]\n", error ? "NG" : "OK"));
}

int
pciaddr_do_resource_allocate(struct pcibios_softc *sc, pci_chipset_tag_t pc,
    pcitag_t tag, int mapreg, struct extent *ex, int type, bus_addr_t *addr,
    bus_size_t size)
{
	bus_addr_t start;
	int error;
	
	if (*addr) /* no need to allocate */
		return (0);

	/* XXX Don't allocate if device is AGP device to avoid conflict. */
	if (pciaddr_device_is_agp(pc, tag)) 
		return (0);
	
	start = (type == PCI_MAPREG_TYPE_MEM ? sc->mem_alloc_start
		: sc->port_alloc_start);
	if (start < ex->ex_start || start + size - 1 >= ex->ex_end) {
		PCIBIOS_PRINTV(("No available resources. fixup failed\n"));
		return (1);
	}
	error = extent_alloc_subregion(ex, start, ex->ex_end, size, size, 0, 0,
	    EX_FAST|EX_NOWAIT|EX_MALLOCOK, addr);
	if (error) {
		PCIBIOS_PRINTV(("No available resources. fixup failed\n"));
		return (1);
	}

	/* write new address to PCI device configuration header */
	pci_conf_write(pc, tag, mapreg, *addr);
	/* check */
	if (pcibios_flags & PCIBIOS_VERBOSE) {
		printf("pci_addr_fixup: ");
		pciaddr_print_devid(pc, tag);
	}

	if (pciaddr_ioaddr(pci_conf_read(pc, tag, mapreg)) != *addr) {
		pci_conf_write(pc, tag, mapreg, 0); /* clear */
		PCIBIOS_PRINTV(("fixup failed. (new address=%#lx)\n", *addr));
		return (1);
	}
	PCIBIOS_PRINTV(("new address 0x%08lx\n", *addr));

	return (0);
}

int
pciaddr_do_resource_reserve(struct pcibios_softc *sc, pci_chipset_tag_t pc,
    pcitag_t tag, int mapreg, struct extent *ex, int type, bus_addr_t *addr,
    bus_size_t size)
{
	pcireg_t val;
	int error;

	if (*addr == 0)
		return (0);

	val = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	if (type == PCI_MAPREG_TYPE_MEM &&
	    (val & PCI_COMMAND_MEM_ENABLE) != PCI_COMMAND_MEM_ENABLE)
		return (0);
	if (type == PCI_MAPREG_TYPE_IO &&
	    (val & PCI_COMMAND_IO_ENABLE) != PCI_COMMAND_IO_ENABLE)
		return (0);

	error = extent_alloc_region(ex, *addr, size, EX_NOWAIT | EX_MALLOCOK);
	if (error) {
		PCIBIOS_PRINTV(("Resource conflict.\n"));
		pci_conf_write(pc, tag, mapreg, 0); /* clear */
		return (1);
	}

	return (0);
}

int
pciaddr_do_resource_reserve_disabled(struct pcibios_softc *sc,
    pci_chipset_tag_t pc, pcitag_t tag, int mapreg, struct extent *ex, int type,
    u_long *addr, bus_size_t size)
{
	pcireg_t val;
	int error;

	if (*addr == 0)
		return (0);

	val = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	if (type == PCI_MAPREG_TYPE_MEM &&
	    (val & PCI_COMMAND_MEM_ENABLE) == PCI_COMMAND_MEM_ENABLE)
		return (0);
	if (type == PCI_MAPREG_TYPE_IO &&
	    (val & PCI_COMMAND_IO_ENABLE) == PCI_COMMAND_IO_ENABLE)
		return (0);

	PCIBIOS_PRINTV(("disabled %s space at addr 0x%lx size 0x%lx\n",
	    type == PCI_MAPREG_TYPE_MEM ? "mem" : "io", *addr, size));

	error = extent_alloc_region(ex, *addr, size, EX_NOWAIT | EX_MALLOCOK);
	if (error) {
		PCIBIOS_PRINTV(("Resource conflict.\n"));
		pci_conf_write(pc, tag, mapreg, 0); /* clear */
		return (1);
	}

	return (0);
}

bus_addr_t
pciaddr_ioaddr(u_int32_t val)
{
	return ((PCI_MAPREG_TYPE(val) == PCI_MAPREG_TYPE_MEM)
		? PCI_MAPREG_MEM_ADDR(val)
		: (PCI_MAPREG_IO_ADDR(val) & PCIADDR_PORT_END));
}

void
pciaddr_print_devid(pci_chipset_tag_t pc, pcitag_t tag)
{
	int bus, device, function;	
	pcireg_t id;
	
	id = pci_conf_read(pc, tag, PCI_ID_REG);
	pci_decompose_tag(pc, tag, &bus, &device, &function);
	printf("%03d:%02d:%d %04x:%04x\n", bus, device, function, 
	       PCI_VENDOR(id), PCI_PRODUCT(id));
}

int
pciaddr_device_is_agp(pci_chipset_tag_t pc, pcitag_t tag)
{
	pcireg_t class, status, rval;
	int off;

	/* Check AGP device. */
	class = pci_conf_read(pc, tag, PCI_CLASS_REG);
	if (PCI_CLASS(class) == PCI_CLASS_DISPLAY) {
		status = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
		if (status & PCI_STATUS_CAPLIST_SUPPORT) {
			rval = pci_conf_read(pc, tag, PCI_CAPLISTPTR_REG);
			for (off = PCI_CAPLIST_PTR(rval);
			    off != 0;
			    off = PCI_CAPLIST_NEXT(rval) ) {
				rval = pci_conf_read(pc, tag, off);
				if (PCI_CAPLIST_CAP(rval) == PCI_CAP_AGP) 
					return (1);
			}
		}
	}
	return (0);
}
@


1.24
log
@Format string fixes: Use %l* for paddr_t
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.23 2013/10/01 19:41:33 sf Exp $	*/
d140 1
a140 1
	    "space start: 0x%08x\n", avail_end, sc->mem_alloc_start));
d301 1
a301 1
		PCIBIOS_PRINTV(("fixup failed. (new address=%#x)\n", *addr));
d304 1
a304 1
	PCIBIOS_PRINTV(("new address 0x%08x\n", *addr));
d357 1
a357 1
	PCIBIOS_PRINTV(("disabled %s space at addr 0x%lx size 0x%x\n",
@


1.23
log
@format string fix: it's u_long *addr
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.22 2010/07/02 16:11:19 jsg Exp $	*/
d139 1
a139 1
	PCIBIOS_PRINTV((" Physical memory end: 0x%08x\n PCI memory mapped I/O "
@


1.22
log
@remove unused pciaddr_search function.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.21 2007/02/20 21:15:01 tom Exp $	*/
d357 1
a357 1
	PCIBIOS_PRINTV(("disabled %s space at addr 0x%x size 0x%x\n",
@


1.21
log
@Revert PAE pmap for now, until the strange bug is found.  This stops
the freezes many of us are seeing (especially on amd64 machines running
OpenBSD/i386).

Much testing by nick@@ (as always - thanks!), hugh@@, ian@@, kettenis@@
and Sam Smith (s (at) msmith (dot) net).

Requested by, input from, and ok deraadt@@  ok art@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.20 2006/09/19 11:06:34 jsg Exp $	*/
a411 36
}


struct extent *
pciaddr_search(int mem_port, bus_addr_t *startp, bus_size_t size)
{
	extern struct cfdriver pcibios_cd;
	struct pcibios_softc *sc;

	sc = (struct pcibios_softc *)device_lookup(&pcibios_cd, 0);
	if (sc && !(pcibios_flags & PCIBIOS_ADDR_FIXUP)) {
		struct extent_region *rp;
		struct extent *ex = mem_port? sc->extent_mem : sc->extent_port;

		/* Search the PCI I/O memory space extent for free
		 * space that will accommodate size.  Remember that the
		 * extent stores allocated space and we're searching
		 * for the gaps.
		 *
		 * If we're at the end or the gap between this region
		 * and the next region big enough, then we're done
		 */
		for (rp = LIST_FIRST(&ex->ex_regions);
		    rp && *startp + size > rp->er_start;
		    rp = LIST_NEXT(rp, er_link)) {
			bus_addr_t new_start;

			new_start = (rp->er_end - 1 + size) & ~(size - 1);
			if (new_start > *startp)
				*startp = new_start;
		}

		return (ex);
	}

	return (NULL);
@


1.20
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.19 2006/08/14 22:48:28 deraadt Exp $	*/
d48 1
a48 1
	struct extent *, int, u_long *, bus_size_t);
d55 3
a57 2
int	pciaddr_do_resource_reserve(struct pcibios_softc *, pci_chipset_tag_t,
    pcitag_t, int, struct extent *, int, u_long *, bus_size_t);
d63 3
a65 2
int	pciaddr_do_resource_allocate(struct pcibios_softc *, pci_chipset_tag_t,
    pcitag_t, int, struct extent *, int, u_long *, bus_size_t);
d186 1
a186 1
	u_long addr;
d265 1
a265 1
    pcitag_t tag, int mapreg, struct extent *ex, int type, u_long *addr,
d311 1
a311 1
    pcitag_t tag, int mapreg, struct extent *ex, int type, u_long *addr,
@


1.19
log
@say which type of header is unknown
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.18 2006/07/13 18:02:18 kettenis Exp $	*/
d79 1
a79 4
pci_addr_fixup(sc, pc, maxbus)
	struct pcibios_softc *sc;
	pci_chipset_tag_t pc;
	int maxbus;
d151 2
a152 4
pciaddr_resource_reserve(sc, pc, tag)
	struct pcibios_softc *sc;
	pci_chipset_tag_t pc;
	pcitag_t tag;
d160 2
a161 4
pciaddr_resource_reserve_disabled(sc, pc, tag)
	struct pcibios_softc *sc;
	pci_chipset_tag_t pc;
	pcitag_t tag;
d170 2
a171 4
pciaddr_resource_allocate(sc, pc, tag)
	struct pcibios_softc *sc;
	pci_chipset_tag_t pc;
	pcitag_t tag;
d179 2
a180 5
pciaddr_resource_manage(sc, pc, tag, func)
	struct pcibios_softc *sc;
	pci_chipset_tag_t pc;
	pcitag_t tag;
	pciaddr_resource_manage_func_t func;
d262 3
a264 8
pciaddr_do_resource_allocate(sc, pc, tag, mapreg, ex, type, addr, size)
	struct pcibios_softc *sc;
	pci_chipset_tag_t pc;
	pcitag_t tag;
	struct extent *ex;
	int mapreg, type;
	u_long *addr;
	bus_size_t size;
d308 3
a310 8
pciaddr_do_resource_reserve(sc, pc, tag, mapreg, ex, type, addr, size)
	struct pcibios_softc *sc;
	pci_chipset_tag_t pc;
	pcitag_t tag;
	struct extent *ex;
	int type, mapreg;
	u_long *addr;
	bus_size_t size;
d337 3
a339 8
pciaddr_do_resource_reserve_disabled(sc, pc, tag, mapreg, ex, type, addr, size)
	struct pcibios_softc *sc;
	pci_chipset_tag_t pc;
	pcitag_t tag;
	struct extent *ex;
	int type, mapreg;
	u_long *addr;
	bus_size_t size;
d369 1
a369 2
pciaddr_ioaddr(val)
	u_int32_t val;
d377 1
a377 3
pciaddr_print_devid(pc, tag)
	pci_chipset_tag_t pc;
	pcitag_t tag;
d389 1
a389 3
pciaddr_device_is_agp(pc, tag)
	pci_chipset_tag_t pc;
	pcitag_t tag;
d414 1
a414 4
pciaddr_search(mem_port, startp, size)
	int mem_port;
	bus_addr_t *startp;
	bus_size_t size;
@


1.18
log
@Switch to a three-phase pci resource fixup:
1. Reserve resources for enabled devices.
2. Reserve resources for disabled devices.
3. Allocate resources.
This way we no longer need to enable/disable devices during fixup.
Based on an earlier patch by drahn@@.

ok deraadt@@, drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.17 2006/04/27 15:37:55 mickey Exp $	*/
d203 2
a204 1
		printf("WARNING: unknown PCI device header.\n");
@


1.17
log
@implement separate PAE pmap that allows access to 64g of physmem
if supported by the cpu(s). currently not enabled by default and
not compiled into ramdisks. this grows paddr_t to 64bit but yet
leaves bus_addr_t at 32bits. measures are taken to favour dmaable
memory allocation from below 4g line such that buffer cache is
already allocated form below, pool backend allocator prefers lower
memory and then finally bounce buffers are used as last resort.
PAE is engaged only if global variable cpu_pae is manually set
to non-zero and there is physical memory present above 4g.
simplify pcibios address math to use u_long as we always will
be in the 32bit space.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.16 2005/11/22 09:09:58 mickey Exp $	*/
d53 2
d57 3
d118 1
a142 3
	if (sc->nbogus == 0)
		return; /* no need to fixup */

d161 13
a173 1
	pciaddr_resource_manage(sc, pc, tag, pciaddr_do_resource_reserve);	
d265 1
a265 11
    
	/* enable/disable PCI device */
	val = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);	
	if (error == 0)
		val |= (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
			PCI_COMMAND_MASTER_ENABLE);
	else
		val &= ~(PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
			 PCI_COMMAND_MASTER_ENABLE);
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, val);
    
d333 1
d337 14
d352 31
@


1.16
log
@repair verbose printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.15 2005/11/13 14:23:26 martin Exp $	*/
d48 1
a48 1
	struct extent *, int, bus_addr_t *, bus_size_t);
d53 2
a54 3
int	pciaddr_do_resource_reserve(struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t, int, struct extent *, int,
    bus_addr_t *, bus_size_t);
d57 2
a58 3
int	pciaddr_do_resource_allocate(struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t, int, struct extent *, int, bus_addr_t *,
    bus_size_t);
d181 1
a181 1
	bus_addr_t addr;
d274 1
a274 1
	bus_addr_t *addr;
d325 1
a325 1
	bus_addr_t *addr;
@


1.15
log
@convert more MD macros to their MI counterparts, this time
i386_round_page(), i386_trunc_page(), i386_btop() and i386_ptob()
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.14 2002/06/14 21:34:58 todd Exp $	*/
d305 1
a305 2
	if (!pcibios_flags & PCIBIOS_VERBOSE)
	{
d312 1
a312 1
		printf("fixup failed. (new address=%#x)\n", *addr);
d315 1
a315 2
	if (!pcibios_flags & PCIBIOS_VERBOSE)
		printf("new address 0x%08x\n", *addr);
@


1.14
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.13 2002/03/14 01:26:33 millert Exp $	*/
d37 2
d131 1
a131 1
	start = i386_round_page(avail_end + 1);
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.12 2001/12/04 06:32:06 mickey Exp $	*/
d410 1
a410 1
		 * space that will accomodate size.  Remember that the
@


1.12
log
@missing \n
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.11 2001/07/05 10:00:33 art Exp $	*/
d45 7
a51 8
typedef int (*pciaddr_resource_manage_func_t) 
	__P((struct pcibios_softc *, pci_chipset_tag_t, pcitag_t, int,
	struct extent *, int, bus_addr_t *, bus_size_t));
void	pciaddr_resource_manage __P((struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t, pciaddr_resource_manage_func_t));
void	pciaddr_resource_reserve __P((struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t));
int	pciaddr_do_resource_reserve __P((struct pcibios_softc *,
d53 4
a56 4
    bus_addr_t *, bus_size_t));
void	pciaddr_resource_allocate __P((struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t));
int	pciaddr_do_resource_allocate __P((struct pcibios_softc *,
d58 3
a60 3
    bus_size_t));
bus_addr_t pciaddr_ioaddr __P((u_int32_t));
void	pciaddr_print_devid __P((pci_chipset_tag_t, pcitag_t));
d62 1
a62 1
int	pciaddr_device_is_agp __P((pci_chipset_tag_t, pcitag_t));
@


1.12.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.12 2001/12/04 06:32:06 mickey Exp $	*/
d45 8
a52 7
typedef int (*pciaddr_resource_manage_func_t)(struct pcibios_softc *, pci_chipset_tag_t, pcitag_t, int,
	struct extent *, int, bus_addr_t *, bus_size_t);
void	pciaddr_resource_manage(struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t, pciaddr_resource_manage_func_t);
void	pciaddr_resource_reserve(struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t);
int	pciaddr_do_resource_reserve(struct pcibios_softc *,
d54 4
a57 4
    bus_addr_t *, bus_size_t);
void	pciaddr_resource_allocate(struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t);
int	pciaddr_do_resource_allocate(struct pcibios_softc *,
d59 3
a61 3
    bus_size_t);
bus_addr_t pciaddr_ioaddr(u_int32_t);
void	pciaddr_print_devid(pci_chipset_tag_t, pcitag_t);
d63 1
a63 1
int	pciaddr_device_is_agp(pci_chipset_tag_t, pcitag_t);
@


1.12.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.12.2.1 2002/06/11 03:35:54 art Exp $	*/
d410 1
a410 1
		 * space that will accommodate size.  Remember that the
@


1.11
log
@Get rid of the wrapper macros around extent_alloc*1
Pass the right amount of arguments and rename them back to their right names.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.10 2001/06/17 21:11:12 mickey Exp $	*/
d189 1
a189 1
		printf("WARNING: unknown PCI device header.");
@


1.10
log
@Don't pciaddr_do_resource_allocate if device is AGP to avoid conflict.
from Masanori Kanaoka <kanaoka@@netbsd.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.9 2001/03/15 03:55:19 mickey Exp $	*/
d294 1
a294 1
	error = extent_alloc_subregion(ex, start, ex->ex_end, size, size, 0,
@


1.9
log
@make sure pcibios ever attached; found by aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.8 2001/01/27 04:59:39 mickey Exp $	*/
d63 2
d283 4
d368 27
@


1.9.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.9 2001/03/15 03:55:19 mickey Exp $	*/
@


1.9.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.9.2.1 2001/04/18 16:08:26 niklas Exp $	*/
a62 2
int	pciaddr_device_is_agp __P((pci_chipset_tag_t, pcitag_t));

a280 4

	/* XXX Don't allocate if device is AGP device to avoid conflict. */
	if (pciaddr_device_is_agp(pc, tag)) 
		return (0);
a361 27

int
pciaddr_device_is_agp(pc, tag)
	pci_chipset_tag_t pc;
	pcitag_t tag;
{
	pcireg_t class, status, rval;
	int off;

	/* Check AGP device. */
	class = pci_conf_read(pc, tag, PCI_CLASS_REG);
	if (PCI_CLASS(class) == PCI_CLASS_DISPLAY) {
		status = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
		if (status & PCI_STATUS_CAPLIST_SUPPORT) {
			rval = pci_conf_read(pc, tag, PCI_CAPLISTPTR_REG);
			for (off = PCI_CAPLIST_PTR(rval);
			    off != 0;
			    off = PCI_CAPLIST_NEXT(rval) ) {
				rval = pci_conf_read(pc, tag, off);
				if (PCI_CAPLIST_CAP(rval) == PCI_CAP_AGP) 
					return (1);
			}
		}
	}
	return (0);
}

@


1.9.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.9.2.2 2001/07/04 10:18:04 niklas Exp $	*/
d294 1
a294 1
	error = extent_alloc_subregion(ex, start, ex->ex_end, size, size, 0, 0,
@


1.9.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.9.2.3 2001/10/31 03:01:12 nate Exp $	*/
d189 1
a189 1
		printf("WARNING: unknown PCI device header.\n");
@


1.9.2.5
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 8
a52 7
typedef int (*pciaddr_resource_manage_func_t)(struct pcibios_softc *, pci_chipset_tag_t, pcitag_t, int,
	struct extent *, int, bus_addr_t *, bus_size_t);
void	pciaddr_resource_manage(struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t, pciaddr_resource_manage_func_t);
void	pciaddr_resource_reserve(struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t);
int	pciaddr_do_resource_reserve(struct pcibios_softc *,
d54 4
a57 4
    bus_addr_t *, bus_size_t);
void	pciaddr_resource_allocate(struct pcibios_softc *,
    pci_chipset_tag_t, pcitag_t);
int	pciaddr_do_resource_allocate(struct pcibios_softc *,
d59 3
a61 3
    bus_size_t);
bus_addr_t pciaddr_ioaddr(u_int32_t);
void	pciaddr_print_devid(pci_chipset_tag_t, pcitag_t);
d63 1
a63 1
int	pciaddr_device_is_agp(pci_chipset_tag_t, pcitag_t);
@


1.9.2.6
log
@Sync the SMP branch with 3.3
@
text
@d410 1
a410 1
		 * space that will accommodate size.  Remember that the
@


1.8
log
@change interrupt routing strategy from simple
run through the devices and programming the icu
and pci headers before real pci bus autoconf starts
and include all devices present on all pci busses,
to a per attached device routing in pci_intr_map().
this solves several cases of premature interrupts hanging
system due to absent interrupt handlers during autoconf.
10x for testing: millert@@ krw@@ aaron@@ chris@@ tholo@@ brad@@ jason@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.7 2001/01/25 01:00:58 mickey Exp $	*/
d372 2
a373 3
	sc = pcibios_cd.cd_devs[0];

	if (!(pcibios_flags & PCIBIOS_ADDR_FIXUP)) {
@


1.7
log
@make code for searching in pcibios's addr allocation
extents common for both io and mem and private to pcibios.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.6 2001/01/24 23:40:28 mickey Exp $	*/
a44 2
struct pciaddr pciaddr;

d46 14
a59 12
	(pci_chipset_tag_t, pcitag_t, int, struct extent *, int,
	 bus_addr_t *, bus_size_t);
void	pciaddr_resource_manage __P((pci_chipset_tag_t, pcitag_t,
				     pciaddr_resource_manage_func_t));
void	pciaddr_resource_reserve __P((pci_chipset_tag_t, pcitag_t));
int	pciaddr_do_resource_reserve __P((pci_chipset_tag_t, pcitag_t, int,
					 struct extent *, int, bus_addr_t *,
					 bus_size_t));
void	pciaddr_resource_allocate __P((pci_chipset_tag_t, pcitag_t));
int	pciaddr_do_resource_allocate __P((pci_chipset_tag_t, pcitag_t, int,
					  struct extent *, int,	bus_addr_t *,
					  bus_size_t));
d73 2
a74 1
pci_addr_fixup(pc, maxbus)
a78 1
#ifdef PCIBIOSVERBOSE
d86 1
a86 1
#endif
d100 6
a105 10
	pciaddr.extent_mem = extent_create("PCI I/O memory space",
					   PCIADDR_MEM_START, 
					   PCIADDR_MEM_END,
					   M_DEVBUF, 0, 0, EX_NOWAIT);
	KASSERT(pciaddr.extent_mem);
	pciaddr.extent_port = extent_create("PCI I/O port space",
					    PCIADDR_PORT_START,
					    PCIADDR_PORT_END,
					    M_DEVBUF, 0, 0, EX_NOWAIT);
	KASSERT(pciaddr.extent_port);
d111 2
a112 2
	pci_device_foreach(pc, maxbus, pciaddr_resource_reserve);
	PCIBIOS_PRINTV((verbose_footer, pciaddr.nbogus));
d118 3
a120 4
		error = extent_alloc_region(pciaddr.extent_mem, srp->start,
					    srp->size, 
					    EX_NOWAIT| EX_MALLOCOK);	
		if (error != 0) {
a122 1
		}
d131 2
a132 2
	pciaddr.mem_alloc_start = (start + 0x100000 + 1) & ~(0x100000 - 1);
	pciaddr.port_alloc_start = PCIADDR_ISAPORT_RESERVE;
d134 1
a134 2
			"space start: 0x%08x\n", (unsigned)avail_end, 
			(unsigned)pciaddr.mem_alloc_start));
d136 1
a136 1
	if (pciaddr.nbogus == 0)
d143 3
a145 4
	pciaddr.nbogus = 0;
	/* XXX bus #0 only */
	pci_device_foreach(pc, 0, pciaddr_resource_allocate);
	PCIBIOS_PRINTV((verbose_footer, pciaddr.nbogus));
d150 2
a151 1
pciaddr_resource_reserve(pc, tag)
d155 1
a155 2
#ifdef PCIBIOSVERBOSE
	if (pcibiosverbose)
d157 1
a157 2
#endif
	pciaddr_resource_manage(pc, tag, pciaddr_do_resource_reserve);	
d161 2
a162 1
pciaddr_resource_allocate(pc, tag)
d166 1
a166 2
#ifdef PCIBIOSVERBOSE
	if (pcibiosverbose)
d168 1
a168 2
#endif
	pciaddr_resource_manage(pc, tag, pciaddr_do_resource_allocate);
d172 2
a173 1
pciaddr_resource_manage(pc, tag, func)
d182 1
a182 1
	int error, useport, usemem, mapreg, type, reg_start, reg_end, width;
d188 1
a188 1
		pciaddr.nbogus++;
d203 1
a203 1
	error = useport = usemem = 0;
d229 1
d231 1
a231 1
			ex = pciaddr.extent_mem;
d233 2
d236 1
a236 1
			ex = pciaddr.extent_port;
a237 1
		addr = pciaddr_ioaddr(val);
a241 5
		if (type == PCI_MAPREG_TYPE_MEM)
			++usemem;
		else
			++useport;

d243 1
a243 1
		error += (*func) (pc, tag, mapreg, ex, type, &addr, size);
d261 1
a261 1
		pciaddr.nbogus++;
d267 2
a268 1
pciaddr_do_resource_allocate(pc, tag, mapreg, ex, type, addr, size)
d282 2
a283 2
	start = type == PCI_MAPREG_TYPE_MEM ? pciaddr.mem_alloc_start
		: pciaddr.port_alloc_start;
d298 1
a298 3
#ifdef PCIBIOSVERBOSE
	if (!pcibiosverbose)
#endif 
d306 1
a306 1
		printf("fixup failed. (new address=%#x)\n", (unsigned)*addr);
d309 1
a309 3
#ifdef PCIBIOSVERBOSE
	if (!pcibiosverbose)
#endif 
d316 2
a317 1
pciaddr_do_resource_reserve(pc, tag, mapreg, ex, type, addr, size)
d346 1
a346 1
		: PCI_MAPREG_IO_ADDR(val));
d359 1
a359 1
	printf("%03d:%02d:%d 0x%04x 0x%04x ", bus, device, function, 
d369 5
d376 1
a376 2
		struct extent *ex = mem_port?
		    pciaddr.extent_mem : pciaddr.extent_port;
@


1.6
log
@put pci_addr_fixup.h into pcibiosvar.h as well,
all it had were a struct and a proto.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.5 2000/10/31 18:56:42 deraadt Exp $	*/
d375 35
@


1.5
log
@rename pcibios.h to pcibiosvar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.4 2000/10/16 16:24:36 mickey Exp $	*/
a43 1
#include <i386/pci/pci_addr_fixup.h>
@


1.4
log
@less newlines in verbose print
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.3 2000/09/20 17:29:47 niklas Exp $	*/
d43 1
a43 1
#include <i386/pci/pcibios.h>
@


1.3
log
@Extend the region in which we allow mapping unmapped PCI devices.
The former code only allowed one fixed up device mapping.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.2 2000/09/07 20:50:38 mickey Exp $	*/
d258 1
a258 1
		PCIBIOS_PRINTV(("\n\t%02xh %s 0x%08x 0x%08x", 
d276 1
a276 1
	PCIBIOS_PRINTV(("\n\t\t[%s]\n", error ? "NG" : "OK"));
@


1.2
log
@do not call pcibios_pir_init() if intr_fixup was disabled; also, sync w/ latetest netbsd developments
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d300 2
a301 3
	error = extent_alloc_subregion(ex, start, start + size - 1, size,
				       size, 0,
				       EX_FAST|EX_NOWAIT|EX_MALLOCOK, addr);
d345 1
a345 1
	error = extent_alloc_region(ex, *addr, size, EX_NOWAIT| EX_MALLOCOK);
@


1.1
log
@sync w/ netbsd almost -current code (;
fixes quite a few problems.
adds new option PCIBIOS_ADDR_FIXUP.
numerous extra fixes by me, also pointed out by other ppl,
such as avoid panics, ifdef on pciverbose, not diagnostic,
some other smaller knits; some have been forwarded back
to netbsd developers, some will go soon too.
@
text
@d1 2
a2 1
/*	$NetBSD: pci_addr_fixup.c,v 1.3 2000/05/31 16:38:55 uch Exp $	*/
d74 1
a74 1
pci_addr_fixup(pc, bus)
d76 1
a76 1
	int bus;
d100 1
a100 1
	
d116 1
a116 1
	pci_device_foreach(pc, bus, pciaddr_resource_reserve);
d152 2
a153 1
	pci_device_foreach(pc, bus, pciaddr_resource_allocate);
d192 1
a192 1
	int error, useport, usemem, mapreg, type, reg_start, reg_end;
d215 1
a215 1
	for (mapreg = reg_start; mapreg < reg_end; mapreg += 4) {
d224 1
d226 13
d312 3
a314 1
	if (!pcibiosverbose) {
d318 1
a318 1
#endif 
d324 4
a327 1
	PCIBIOS_PRINTV(("new address 0x%08x\n", (unsigned)*addr));
@

