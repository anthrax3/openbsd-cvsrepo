head	1.18;
access;
symbols
	OPENBSD_6_0:1.18.0.30
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.26
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.28
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.20
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.24
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.22
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.18
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.16
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.14
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.12
	OPENBSD_5_0:1.18.0.10
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.8
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.6
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.17.0.6
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.8
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.5.0.10
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.8
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.6
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.18
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.17;

1.17
date	2007.11.25.16.40.04;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.10.17.47.54;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.25.23.02.24;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.08.01.01.36.23;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.24.23.39.40;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.15.23.01.00;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.28.00.34.54;	author smurph;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.19.21.07.25;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.19.02.49.20;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.04.36.32;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.22.02.57.17;	author smurph;	state Exp;
branches
	1.5.10.1;
next	1.4;

1.4
date	99.01.11.05.11.24;	author millert;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	96.11.28.23.37.39;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.11.12.20.30.00;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.10.04.02.51.20;	author deraadt;	state Exp;
branches;
next	;

1.4.6.1
date	2000.03.24.09.07.41;	author niklas;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.4.6.4;

1.4.6.4
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.4.6.5;

1.4.6.5
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	;

1.5.10.1
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	1.5.10.2;

1.5.10.2
date	2002.10.29.00.28.04;	author art;	state Exp;
branches;
next	;


desc
@@


1.18
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@/*	$OpenBSD: ahc_isa.c,v 1.17 2007/11/25 16:40:04 jmc Exp $	*/
/*	$NetBSD: ahc_isa.c,v 1.5 1996/10/21 22:27:39 thorpej Exp $	*/

/*
 * Product specific probe and attach routines for:
 * 	284X VLbus SCSI controllers
 *
 * Copyright (c) 1996 Jason R. Thorpe.
 * All rights reserved.
 *
 * Copyright (c) 1995, 1996 Christopher G. Demetriou.
 * All rights reserved.
 *
 * Copyright (c) 1994, 1995, 1996 Justin T. Gibbs.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * This front-end driver is really sort of a hack.  The AHA-284X likes
 * to masquerade as an EISA device.  However, on VLbus machines with
 * no EISA signature in the BIOS, the EISA bus will never be scanned.
 * This is intended to catch the 284X controllers on those systems
 * by looking in "EISA i/o space" for 284X controllers.
 *
 * This relies heavily on i/o port accounting.  We also just use the
 * EISA macros for everything ... it's a real waste to redefine them.
 *
 * Note: there isn't any #ifdef for FreeBSD in this file, since the
 * FreeBSD EISA driver handles all cases of the 284X.
 *
 *	-- Jason R. Thorpe <thorpej@@NetBSD.ORG>
 *	   July 12, 1996
 *
 * TODO: some code could be shared with ahc_eisa.c, but it would probably
 * be a logistical mightmare to even try.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/queue.h>
#include <sys/malloc.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/isa/isavar.h>

#include <dev/eisa/eisareg.h>
#include <dev/eisa/eisavar.h>
#include <dev/eisa/eisadevs.h>

#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
#include <dev/ic/smc93cx6var.h>

#ifdef DEBUG
#define bootverbose	1
#else
#define bootverbose	0
#endif

/* IO port address setting range as EISA slot number */
#define AHC_ISA_MIN_SLOT	0x1	/* from iobase = 0x1c00 */
#define AHC_ISA_MAX_SLOT	0xe	/* to   iobase = 0xec00 */

#define AHC_ISA_SLOT_OFFSET	0xc00	/* offset from EISA IO space */
#define AHC_ISA_IOSIZE		0x100

/*
 * I/O port offsets
 */
#define	AHC_ISA_VID		(EISA_SLOTOFF_VID - AHC_ISA_SLOT_OFFSET)
#define	AHC_ISA_PID		(EISA_SLOTOFF_PID - AHC_ISA_SLOT_OFFSET)
#define	AHC_ISA_PRIMING		AHC_ISA_VID	/* enable vendor/product ID */

/*
 * AHC_ISA_PRIMING register values (write)
 */
#define	AHC_ISA_PRIMING_VID(index)	(AHC_ISA_VID + (index))
#define	AHC_ISA_PRIMING_PID(index)	(AHC_ISA_PID + (index))

int	ahc_isa_irq(bus_space_tag_t, bus_space_handle_t);
int	ahc_isa_idstring(bus_space_tag_t, bus_space_handle_t, char *);
int	ahc_isa_match(struct isa_attach_args *, bus_addr_t);

int	ahc_isa_probe(struct device *, void *, void *);
void	ahc_isa_attach(struct device *, struct device *, void *);
void	aha2840_load_seeprom(struct ahc_softc *ahc);

struct cfattach ahc_isa_ca = {
	sizeof(struct ahc_softc), ahc_isa_probe, ahc_isa_attach
};

/*
 * This keeps track of which slots are to be checked next if the
 * iobase locator is a wildcard.  A simple static variable isn't enough,
 * since it's conceivable that a system might have more than one ISA
 * bus.
 *
 * The "bus" member is the unit number of the parent ISA bus, e.g. "0"
 * for "isa0".
 */
struct ahc_isa_slot {
	LIST_ENTRY(ahc_isa_slot)	link;
	int				bus;
	int				slot;
};
static LIST_HEAD(, ahc_isa_slot) ahc_isa_all_slots;
static int ahc_isa_slot_initialized;

/*
 * Return irq setting of the board, otherwise -1.
 */
int
ahc_isa_irq(bus_space_tag_t iot, bus_space_handle_t ioh)
{
	int irq;
	u_char intdef;
	u_char hcntrl;
	
	/* Pause the card preseving the IRQ type */
	hcntrl = bus_space_read_1(iot, ioh, HCNTRL) & IRQMS;
	bus_space_write_1(iot, ioh, HCNTRL, hcntrl | PAUSE);

	intdef = bus_space_read_1(iot, ioh, INTDEF);
	switch (irq = (intdef & VECTOR)) {
	case 9:
	case 10:
	case 11:
	case 12:
	case 14:
	case 15:
		break;
	default:
		printf("ahc_isa_irq: illegal irq setting %d\n", intdef);
		return -1;
	}

	/* Note that we are going and return (to probe) */
	return irq;
}

int
ahc_isa_idstring(bus_space_tag_t iot, bus_space_handle_t ioh, char *idstring)
{
	u_int8_t vid[EISA_NVIDREGS], pid[EISA_NPIDREGS];
	int i;

	/* Get the vendor ID bytes */
	for (i = 0; i < EISA_NVIDREGS; i++) {
		bus_space_write_1(iot, ioh, AHC_ISA_PRIMING,
		    AHC_ISA_PRIMING_VID(i));
		vid[i] = bus_space_read_1(iot, ioh, AHC_ISA_VID + i);
	}

	/* Check for device existence */
	if (EISA_VENDID_NODEV(vid)) {
#if 0
		printf("ahc_isa_idstring: no device at 0x%lx\n",
		    ioh); /* XXX knows about ioh guts */
		printf("\t(0x%x, 0x%x)\n", vid[0], vid[1]);
#endif
		return (0);
	}

	/* And check that the firmware didn't biff something badly */
	if (EISA_VENDID_IDDELAY(vid)) {
		printf("ahc_isa_idstring: BIOS biffed it at 0x%lx\n",
		    ioh);	/* XXX knows about ioh guts */
		return (0);
	}

	/* Get the product ID bytes */
	for (i = 0; i < EISA_NPIDREGS; i++) {
		bus_space_write_1(iot, ioh, AHC_ISA_PRIMING,
		    AHC_ISA_PRIMING_PID(i));
		pid[i] = bus_space_read_1(iot, ioh, AHC_ISA_PID + i);
	}

	/* Create the ID string from the vendor and product IDs */
	idstring[0] = EISA_VENDID_0(vid);
	idstring[1] = EISA_VENDID_1(vid);
	idstring[2] = EISA_VENDID_2(vid);
	idstring[3] = EISA_PRODID_0(pid);
	idstring[4] = EISA_PRODID_1(pid);
	idstring[5] = EISA_PRODID_2(pid);
	idstring[6] = EISA_PRODID_3(pid);
	idstring[7] = '\0';		/* sanity */

	return (1);
}

int
ahc_isa_match(struct isa_attach_args *ia, bus_addr_t iobase)
{
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh;
	int irq;
	char idstring[EISA_IDSTRINGLEN];

	/*
	 * Get a mapping for the while slot-specific address
	 * space.  If we can't, assume nothing's there, but
	 * warn about it.
	 */
	if (bus_space_map(iot, iobase, AHC_ISA_IOSIZE, 0, &ioh)) {
#if 0
		/*
		 * Don't print anything out here, since this could
		 * be common on machines configured to look for
		 * ahc_eisa and ahc_isa.
		 */
		printf("ahc_isa_match: can't map i/o space for 0x%x\n",
		    iobase);
#endif
		return (0);
	}

	if (!ahc_isa_idstring(iot, ioh, idstring))
		irq = -1;	/* cannot get the ID string */
	else if (strcmp(idstring, "ADP7756") &&
	    strcmp(idstring, "ADP7757"))
		irq = -1;	/* unknown ID strings */
	else
		irq = ahc_isa_irq(iot, ioh);

	bus_space_unmap(iot, ioh, AHC_ISA_IOSIZE);

	if (irq < 0)
		return (0);

	if (ia->ia_irq != IRQUNK &&
	    ia->ia_irq != irq) {
		printf("ahc_isa_match: irq mismatch (kernel %d, card %d)\n",
		       ia->ia_irq, irq);
		return (0);
	}

	/* We have a match */
	ia->ia_iobase = iobase;
	ia->ia_irq = irq;
	ia->ia_iosize = AHC_ISA_IOSIZE;
	ia->ia_msize = 0;
	return (1);
}

/*
 * Check the slots looking for a board we recognise
 * If we find one, note its address (slot) and call
 * the actual probe routine to check it out.
 */
int
ahc_isa_probe(struct device *parent, void *match, void *aux)
{       
	struct isa_attach_args *ia = aux;
	struct ahc_isa_slot *as;

	if (ahc_isa_slot_initialized == 0) {
		LIST_INIT(&ahc_isa_all_slots);
		ahc_isa_slot_initialized = 1;
	}

	if (ia->ia_iobase != IOBASEUNK)
		return (ahc_isa_match(ia, ia->ia_iobase));

	/*
	 * Find this bus's state.  If we don't yet have a slot
	 * marker, allocate and initialize one.
	 */
	LIST_FOREACH(as, &ahc_isa_all_slots, link)
		if (as->bus == parent->dv_unit)
			goto found_slot_marker;

	/*
	 * Don't have one, so make one.
	 */
	as = (struct ahc_isa_slot *)
	    malloc(sizeof(struct ahc_isa_slot), M_DEVBUF, M_NOWAIT);
	if (as == NULL)
		panic("ahc_isa_probe: can't allocate slot marker");

	as->bus = parent->dv_unit;
	as->slot = AHC_ISA_MIN_SLOT;
	LIST_INSERT_HEAD(&ahc_isa_all_slots, as, link);

 found_slot_marker:

	for (; as->slot <= AHC_ISA_MAX_SLOT; as->slot++) {
		if (ahc_isa_match(ia, EISA_SLOT_ADDR(as->slot) +
		    AHC_ISA_SLOT_OFFSET)) {
			as->slot++; /* next slot to search */
			return (1);
		}
	}

	/* No matching cards were found. */
	return (0);
}

void
ahc_isa_attach(struct device *parent, struct device *self, void *aux)
{
	struct ahc_softc *ahc = (void *)self;
	struct isa_attach_args *ia = aux;
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh;
	int irq;
	char idstring[EISA_IDSTRINGLEN];
	const char *model;
	u_int intdef;
	
	ahc_set_name(ahc, ahc->sc_dev.dv_xname);
	ahc_set_unit(ahc, ahc->sc_dev.dv_unit);
	
	/* set dma tags */
	ahc->parent_dmat = ia->ia_dmat;
	
	ahc->chip = AHC_VL; /* We are a VL Bus Controller */  
	
	if (bus_space_map(iot, ia->ia_iobase, ia->ia_iosize, 0, &ioh))
		panic("ahc_isa_attach: can't map slot i/o addresses");
	if (!ahc_isa_idstring(iot, ioh, idstring))
		panic("ahc_isa_attach: could not read ID string");
	if ((irq = ahc_isa_irq(iot, ioh)) < 0)
		panic("ahc_isa_attach: ahc_isa_irq failed!");

	if (strcmp(idstring, "ADP7756") == 0) {
		model = EISA_PRODUCT_ADP7756;
	} else if (strcmp(idstring, "ADP7757") == 0) {
		model = EISA_PRODUCT_ADP7757;
	} else {
		panic("ahc_isa_attach: Unknown device type %s", idstring);
	}
	printf(": %s\n", model);
	
	ahc->channel = 'A';
	ahc->chip = AHC_AIC7770;
	ahc->features = AHC_AIC7770_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
	ahc->flags |= AHC_PAGESCBS;
	
	/* set tag and handle */
	ahc->tag = iot;
	ahc->bsh = ioh;

#ifdef DEBUG
	/*
	 * Tell the user what type of interrupts we're using.
	 * useful for debugging irq problems
	 */
	printf( "%s: Using %s Interrupts\n", ahc_name(ahc),
	    ahc->pause & IRQMS ?  "Level Sensitive" : "Edge Triggered");
#endif

	if (ahc_reset(ahc, /*reinit*/FALSE) != 0)
		return;
	
	/* See if we are edge triggered */
	intdef = ahc_inb(ahc, INTDEF);
	if ((intdef & EDGE_TRIG) != 0)
		ahc->flags |= AHC_EDGE_INTERRUPT;

	/*
	 * Now that we know we own the resources we need, do the 
	 * card initialization.
	 */
	aha2840_load_seeprom(ahc);

	/*      
	 * See if we have a Rev E or higher aic7770. Anything below a
	 * Rev E will have a R/O autoflush disable configuration bit.
	 * It's still not clear exactly what is differenent about the Rev E.
	 * We think it allows 8 bit entries in the QOUTFIFO to support
	 * "paging" SCBs so you can have more than 4 commands active at
	 * once.
	 */     
	{
		char *id_string;
		u_char sblkctl;
		u_char sblkctl_orig;

		sblkctl_orig = ahc_inb(ahc, SBLKCTL);
		sblkctl = sblkctl_orig ^ AUTOFLUSHDIS;
		ahc_outb(ahc, SBLKCTL, sblkctl);
		sblkctl = ahc_inb(ahc, SBLKCTL);
		if(sblkctl != sblkctl_orig)
		{
			id_string = "aic7770 >= Rev E, ";
			/*
			 * Ensure autoflush is enabled
			 */
			sblkctl &= ~AUTOFLUSHDIS;
			ahc_outb(ahc, SBLKCTL, sblkctl);

			/* Allow paging on this adapter */
			ahc->flags |= AHC_PAGESCBS;
		}
		else
			id_string = "aic7770 <= Rev C, ";

		printf("%s: %s", ahc_name(ahc), id_string);
	}

	/* Setup the FIFO threshold and the bus off time */
	{
		u_char hostconf = ahc_inb(ahc, HOSTCONF);
		ahc_outb(ahc, BUSSPD, hostconf & DFTHRSH);
		ahc_outb(ahc, BUSTIME, (hostconf << 2) & BOFF);
	}

	/*
	 * Generic aic7xxx initialization.
	 */
	if(ahc_init(ahc)){
		ahc_free(ahc);
		return;
	}
	
	/*
	 * Link this softc in with all other ahc instances.
	 */
	ahc_softc_insert(ahc);

	/*
	 * Enable the board's BUS drivers
	 */
	ahc_outb(ahc, BCTL, ENABLE);

	/*
	 * The IRQMS bit enables level sensitive interrupts only allow
	 * IRQ sharing if its set.
	 */
	ahc->ih = isa_intr_establish(ia->ia_ic, irq,
	    ahc->pause & IRQMS ? IST_LEVEL : IST_EDGE, IPL_BIO, ahc_platform_intr,
	    ahc, ahc->sc_dev.dv_xname);
	if (ahc->ih == NULL) {
		printf("%s: couldn't establish interrupt\n",
		       ahc->sc_dev.dv_xname);
		ahc_free(ahc);
		return;
	}

	ahc_intr_enable(ahc, TRUE);
	
	/* Attach sub-devices - always succeeds */
	ahc_attach(ahc);
}

/*
 * Read the 284x SEEPROM.
 */
void
aha2840_load_seeprom(struct ahc_softc *ahc)
{
	struct	  seeprom_descriptor sd;
	struct	  seeprom_config sc;
	u_int16_t checksum = 0;
	u_int8_t  scsi_conf;
	int	  have_seeprom;

	sd.sd_tag = ahc->tag;
	sd.sd_bsh = ahc->bsh;
	sd.sd_regsize = 1;
	sd.sd_control_offset = SEECTL_2840;
	sd.sd_status_offset = STATUS_2840;
	sd.sd_dataout_offset = STATUS_2840;		
	sd.sd_chip = C46;
	sd.sd_MS = 0;
	sd.sd_RDY = EEPROM_TF;
	sd.sd_CS = CS_2840;
	sd.sd_CK = CK_2840;
	sd.sd_DO = DO_2840;
	sd.sd_DI = DI_2840;

	if (bootverbose)
		printf("%s: Reading SEEPROM...", ahc_name(ahc));
	have_seeprom = read_seeprom(&sd, 
				    (u_int16_t *)&sc, 
				    /*start_addr*/0,
				    sizeof(sc)/2);

	if (have_seeprom) {
		/* Check checksum */
		int i;
		int maxaddr = (sizeof(sc)/2) - 1;
		u_int16_t *scarray = (u_int16_t *)&sc;

		for (i = 0; i < maxaddr; i++)
			checksum = checksum + scarray[i];
		if (checksum != sc.checksum) {
			if(bootverbose)
				printf ("checksum error\n");
			have_seeprom = 0;
		} else if (bootverbose) {
			printf("done.\n");
		}
	}

	if (!have_seeprom) {
		if (bootverbose)
			printf("%s: No SEEPROM available\n", ahc_name(ahc));
		ahc->flags |= AHC_USEDEFAULTS;
	} else {
		/*
		 * Put the data we've collected down into SRAM
		 * where ahc_init will find it.
		 */
		int i;
		int max_targ = (ahc->features & AHC_WIDE) != 0 ? 16 : 8;
		u_int16_t discenable;

		discenable = 0;
		for (i = 0; i < max_targ; i++){
	                u_int8_t target_settings;
			target_settings = (sc.device_flags[i] & CFXFER) << 4;
			if (sc.device_flags[i] & CFSYNCH)
				target_settings |= SOFS;
			if (sc.device_flags[i] & CFWIDEB)
				target_settings |= WIDEXFER;
			if (sc.device_flags[i] & CFDISC)
				discenable |= (0x01 << i);
			ahc_outb(ahc, TARG_SCSIRATE + i, target_settings);
		}
		ahc_outb(ahc, DISC_DSB, ~(discenable & 0xff));
		ahc_outb(ahc, DISC_DSB + 1, ~((discenable >> 8) & 0xff));

		ahc->our_id = sc.brtime_id & CFSCSIID;

		scsi_conf = (ahc->our_id & 0x7);
		if (sc.adapter_control & CFSPARITY)
			scsi_conf |= ENSPCHK;
		if (sc.adapter_control & CFRESETB)
			scsi_conf |= RESET_SCSI;

		if (sc.bios_control & CF284XEXTEND)		
			ahc->flags |= AHC_EXTENDED_TRANS_A;
		/* Set SCSICONF info */
		ahc_outb(ahc, SCSICONF, scsi_conf);

		if (sc.adapter_control & CF284XSTERM)
			ahc->flags |= AHC_TERM_ENB_A;
	}
}
@


1.17
log
@spelling fixes, from Martynas Venckus;
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_isa.c,v 1.16 2007/04/10 17:47:54 miod Exp $	*/
d246 1
a246 1
		printf("ahc_isa_match: can't map I/O space for 0x%x\n",
d354 1
a354 1
		panic("ahc_isa_attach: could not map slot I/O addresses");
@


1.16
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_isa.c,v 1.15 2006/09/19 11:06:33 jsg Exp $	*/
d382 1
a382 1
	 * usefull for debugging irq problems
@


1.15
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_isa.c,v 1.14 2004/12/25 23:02:24 miod Exp $	*/
d282 1
a282 1
 * If we find one, note it's address (slot) and call
@


1.14
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_isa.c,v 1.13 2004/08/01 01:36:23 krw Exp $	*/
d148 1
a148 3
ahc_isa_irq(iot, ioh)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d177 1
a177 4
ahc_isa_idstring(iot, ioh, idstring)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	char *idstring;
d227 1
a227 3
ahc_isa_match(ia, iobase)
	struct isa_attach_args *ia;
	bus_addr_t iobase;
d286 1
a286 3
ahc_isa_probe(parent, match, aux)
        struct device *parent;
        void *match, *aux; 
d334 1
a334 3
ahc_isa_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
@


1.13
log
@Fold in relevant bits of the most recent two updates from
gibbs@@freebsd.

Large commit messages detailing all changes can be read at revisions
1.97 and 1.100 of aic7xxx.c:

www.freebsd.org/cgi/cvsweb.cgi/src/sys/dev/aic7xxx/aic7xxx.c

Tested by marco, nate and pefo. Fixed broken system for nate.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_isa.c,v 1.12 2003/12/24 23:39:40 krw Exp $	*/
d312 1
a312 2
	for (as = ahc_isa_all_slots.lh_first; as != NULL;
	    as = as->link.le_next)
@


1.12
log
@Sync ahc with NetBSD, which was in turn updated from FreeBSD by Pascal
Renauld of Network Storage Solutions, Inc. Many fixes, wider device
support. In particular, the notorious 'Target 0' problem seems to be
fixed.

Does *not* include any updates to isa or eisa code beyond what was
necessary to compile.

Known issues:

1) Tagged Queuing is probably not optimal.

2) PPR negotiation may not be fully functional.

3) No support yet for freezing devices or channels.

4) The mechanism for preventing 'A' and 'B' channel confusion during probe
can fail if scsibus > 254 found.

5) Requeuing I/O's not working. A workaround will be committed almost
immediately. At the moment timeouts, SCSI message rejects, aborting
SCB's and trying to freeze a device may cause incomplete i/o's to be
reported as complete.

6) Verbosity and probe messages need work.

7) Last disk on bus seems to go through an extra re-negotiation.

8) >16 devices on an adapter will trigger the usual problems of total
openings exceeding available SCB's under heavy load.

Tested by deraadt@@, beck@@, miod@@, naddy@@, drahn@@, marc@@ amoung
others.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_isa.c,v 1.11 2003/08/15 23:01:00 fgsch Exp $	*/
d400 1
a400 1
	if (ahc_reset(ahc) != 0)
@


1.11
log
@- remove ahc dependency, convert smc93cx6 into an attribute.
- support for 8 and 32 bit registers.
from NetBSD.
deraadt@@ and krw@@ testing and ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_isa.c,v 1.10 2002/06/28 00:34:54 smurph Exp $	*/
a84 1
#include <dev/ic/aic7xxxreg.h>
a355 6
	/* 
	 * We really don't allocate our softc, but 
	 * we need to do the initialization. And this 
	 * also allocates the platform_data structure.
	 */
	ahc_alloc(ahc, ahc->sc_dev.dv_xname);
a361 2
	ahc->buffer_dmat = ia->ia_dmat;
        ahc->shared_data_dmat = ia->ia_dmat;
a381 1
	ahc->channel_b = 'B';
a463 3
	/* Special func to force negotiation */
	ahc_force_neg(ahc);
	
d478 1
a478 1
	ahc->platform_data->ih = isa_intr_establish(ia->ia_ic, irq,
d481 1
a481 1
	if (ahc->platform_data->ih == NULL) {
@


1.10
log
@Return of new ahc
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_isa.c,v 1.9 2002/03/19 21:07:25 millert Exp $	*/
d519 3
@


1.9
log
@remove __P
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_isa.c,v 1.8 2002/03/19 02:49:20 millert Exp $	*/
d86 2
a87 1
#include <dev/ic/aic7xxxvar.h>
a105 1
#define INTDEF			0x5cul	/* Interrupt Definition Register */
d162 1
a162 1
	switch (irq = (intdef & 0xf)) {
a348 1
	ahc_chip chip;
d356 18
a373 4
	u_char channel = 'A';

	ahc->sc_dmat = ia->ia_dmat;
	chip = AHC_VL; /* We are a VL Bus Controller */  
a382 1
		chip |= AHC_AIC7770;
a384 1
		chip |= AHC_AIC7770;
d389 11
a399 2

	ahc_construct(ahc, iot, ioh, chip, AHC_FNONE, AHC_AIC7770_FE, channel);
a409 2
	ahc->channel = 'A';
	ahc->channel_b = 'B';
d412 6
d437 1
a437 1
		sblkctl_orig = AHC_INB(ahc, SBLKCTL);
d439 2
a440 2
		AHC_OUTB(ahc, SBLKCTL, sblkctl);
		sblkctl = AHC_INB(ahc, SBLKCTL);
d448 1
a448 1
			AHC_OUTB(ahc, SBLKCTL, sblkctl);
d461 3
a463 3
		u_char hostconf = AHC_INB(ahc, HOSTCONF);
		AHC_OUTB(ahc, BUSSPD, hostconf & DFTHRSH);
		AHC_OUTB(ahc, BUSTIME, (hostconf << 2) & BOFF);
d473 8
d485 1
a485 1
	AHC_OUTB(ahc, BCTL, ENABLE);
d491 2
a492 2
	ahc->sc_ih = isa_intr_establish(ia->ia_ic, irq,
	    ahc->pause & IRQMS ? IST_LEVEL : IST_EDGE, IPL_BIO, ahc_intr,
d494 1
a494 1
	if (ahc->sc_ih == NULL) {
d501 2
a518 2
	sd.sd_tag = ahc->sc_iot;
	sd.sd_bsh = ahc->sc_ioh;
d532 2
a533 2
	have_seeprom = read_seeprom(&sd,
				    (u_int16_t *)&sc,
@


1.8
log
@revert to older ahc driver until the new one's bugs are fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_isa.c,v 1.5 2000/03/22 02:57:17 smurph Exp $	*/
d116 7
a122 7
int	ahc_isa_irq __P((bus_space_tag_t, bus_space_handle_t));
int	ahc_isa_idstring __P((bus_space_tag_t, bus_space_handle_t, char *));
int	ahc_isa_match __P((struct isa_attach_args *, bus_addr_t));

int	ahc_isa_probe __P((struct device *, void *, void *));
void	ahc_isa_attach __P((struct device *, struct device *, void *));
void	aha2840_load_seeprom __P((struct ahc_softc *ahc));
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_isa.c,v 1.6 2002/02/16 04:36:32 smurph Exp $	*/
d86 2
a87 3
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
#include <dev/ic/aic7xxx_93cx6.h>
d105 1
d116 7
a122 7
int	ahc_isa_irq(bus_space_tag_t, bus_space_handle_t);
int	ahc_isa_idstring(bus_space_tag_t, bus_space_handle_t, char *);
int	ahc_isa_match(struct isa_attach_args *, bus_addr_t);

int	ahc_isa_probe(struct device *, void *, void *);
void	ahc_isa_attach(struct device *, struct device *, void *);
void	aha2840_load_seeprom(struct ahc_softc *ahc);
d162 1
a162 1
	switch (irq = (intdef & VECTOR)) {
d349 1
d357 4
a360 18
	u_int intdef;
	/* 
	 * We really don't allocate our softc, but 
	 * we need to do the initialization. And this 
	 * also allocates the platform_data structure.
	 */
	ahc_alloc(ahc, ahc->sc_dev.dv_xname);
	
	ahc_set_name(ahc, ahc->sc_dev.dv_xname);
	ahc_set_unit(ahc, ahc->sc_dev.dv_unit);
	
	/* set dma tags */
	ahc->parent_dmat = ia->ia_dmat;
	ahc->buffer_dmat = ia->ia_dmat;
        ahc->shared_data_dmat = ia->ia_dmat;
	
	ahc->chip = AHC_VL; /* We are a VL Bus Controller */  
	
d370 1
d373 1
d378 2
a379 11
	
	ahc->channel = 'A';
	ahc->channel_b = 'B';
	ahc->chip = AHC_AIC7770;
	ahc->features = AHC_AIC7770_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
	ahc->flags |= AHC_PAGESCBS;
	
	/* set tag and handle */
	ahc->tag = iot;
	ahc->bsh = ioh;
d390 2
a393 6
	
	/* See if we are edge triggered */
	intdef = ahc_inb(ahc, INTDEF);
	if ((intdef & EDGE_TRIG) != 0)
		ahc->flags |= AHC_EDGE_INTERRUPT;

d413 1
a413 1
		sblkctl_orig = ahc_inb(ahc, SBLKCTL);
d415 2
a416 2
		ahc_outb(ahc, SBLKCTL, sblkctl);
		sblkctl = ahc_inb(ahc, SBLKCTL);
d424 1
a424 1
			ahc_outb(ahc, SBLKCTL, sblkctl);
d437 3
a439 3
		u_char hostconf = ahc_inb(ahc, HOSTCONF);
		ahc_outb(ahc, BUSSPD, hostconf & DFTHRSH);
		ahc_outb(ahc, BUSTIME, (hostconf << 2) & BOFF);
a448 8
	
	/* Special func to force negotiation */
	ahc_force_neg(ahc);
	
	/*
	 * Link this softc in with all other ahc instances.
	 */
	ahc_softc_insert(ahc);
d453 1
a453 1
	ahc_outb(ahc, BCTL, ENABLE);
d459 2
a460 2
	ahc->platform_data->ih = isa_intr_establish(ia->ia_ic, irq,
	    ahc->pause & IRQMS ? IST_LEVEL : IST_EDGE, IPL_BIO, ahc_platform_intr,
d462 1
a462 1
	if (ahc->platform_data->ih == NULL) {
a468 2
	ahc_intr_enable(ahc, TRUE);
	
d485 2
d500 2
a501 2
	have_seeprom = read_seeprom(&sd, 
				    (u_int16_t *)&sc, 
@


1.6
log
@New port of FreeBSD's ahc driver
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_isa.c,v 1.5 2000/03/22 02:57:17 smurph Exp $	*/
d116 7
a122 7
int	ahc_isa_irq __P((bus_space_tag_t, bus_space_handle_t));
int	ahc_isa_idstring __P((bus_space_tag_t, bus_space_handle_t, char *));
int	ahc_isa_match __P((struct isa_attach_args *, bus_addr_t));

int	ahc_isa_probe __P((struct device *, void *, void *));
void	ahc_isa_attach __P((struct device *, struct device *, void *));
void	aha2840_load_seeprom __P((struct ahc_softc *ahc));
@


1.5
log
@new ahc driver.  Adds support for newer Adaptec controllers.  This represents two months of work.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_isa.c,v 1.4 1999/01/11 05:11:24 millert Exp $	*/
d86 3
a88 2
#include <dev/ic/aic7xxxvar.h>
#include <dev/ic/smc93cx6var.h>
a105 1
#define INTDEF			0x5cul	/* Interrupt Definition Register */
d162 1
a162 1
	switch (irq = (intdef & 0xf)) {
a348 1
	ahc_chip chip;
d356 18
a373 4
	u_char channel = 'A';

	ahc->sc_dmat = ia->ia_dmat;
	chip = AHC_VL; /* We are a VL Bus Controller */  
a382 1
		chip |= AHC_AIC7770;
a384 1
		chip |= AHC_AIC7770;
d389 11
a399 2

	ahc_construct(ahc, iot, ioh, chip, AHC_FNONE, AHC_AIC7770_FE, channel);
a409 2
	ahc->channel = 'A';
	ahc->channel_b = 'B';
d412 6
d437 1
a437 1
		sblkctl_orig = AHC_INB(ahc, SBLKCTL);
d439 2
a440 2
		AHC_OUTB(ahc, SBLKCTL, sblkctl);
		sblkctl = AHC_INB(ahc, SBLKCTL);
d448 1
a448 1
			AHC_OUTB(ahc, SBLKCTL, sblkctl);
d461 3
a463 3
		u_char hostconf = AHC_INB(ahc, HOSTCONF);
		AHC_OUTB(ahc, BUSSPD, hostconf & DFTHRSH);
		AHC_OUTB(ahc, BUSTIME, (hostconf << 2) & BOFF);
d473 8
d485 1
a485 1
	AHC_OUTB(ahc, BCTL, ENABLE);
d491 2
a492 2
	ahc->sc_ih = isa_intr_establish(ia->ia_ic, irq,
	    ahc->pause & IRQMS ? IST_LEVEL : IST_EDGE, IPL_BIO, ahc_intr,
d494 1
a494 1
	if (ahc->sc_ih == NULL) {
d501 2
a518 2
	sd.sd_tag = ahc->sc_iot;
	sd.sd_bsh = ahc->sc_ioh;
d532 2
a533 2
	have_seeprom = read_seeprom(&sd,
				    (u_int16_t *)&sc,
@


1.5.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_isa.c,v 1.5 2000/03/22 02:57:17 smurph Exp $	*/
d116 7
a122 7
int	ahc_isa_irq(bus_space_tag_t, bus_space_handle_t);
int	ahc_isa_idstring(bus_space_tag_t, bus_space_handle_t, char *);
int	ahc_isa_match(struct isa_attach_args *, bus_addr_t);

int	ahc_isa_probe(struct device *, void *, void *);
void	ahc_isa_attach(struct device *, struct device *, void *);
void	aha2840_load_seeprom(struct ahc_softc *ahc);
@


1.5.10.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_isa.c,v 1.5.10.1 2002/06/11 03:35:54 art Exp $	*/
d86 1
a86 2
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
d105 1
d162 1
a162 1
	switch (irq = (intdef & VECTOR)) {
d349 1
d357 4
a360 18
	u_int intdef;
	/* 
	 * We really don't allocate our softc, but 
	 * we need to do the initialization. And this 
	 * also allocates the platform_data structure.
	 */
	ahc_alloc(ahc, ahc->sc_dev.dv_xname);
	
	ahc_set_name(ahc, ahc->sc_dev.dv_xname);
	ahc_set_unit(ahc, ahc->sc_dev.dv_unit);
	
	/* set dma tags */
	ahc->parent_dmat = ia->ia_dmat;
	ahc->buffer_dmat = ia->ia_dmat;
        ahc->shared_data_dmat = ia->ia_dmat;
	
	ahc->chip = AHC_VL; /* We are a VL Bus Controller */  
	
d370 1
d373 1
d378 2
a379 11
	
	ahc->channel = 'A';
	ahc->channel_b = 'B';
	ahc->chip = AHC_AIC7770;
	ahc->features = AHC_AIC7770_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
	ahc->flags |= AHC_PAGESCBS;
	
	/* set tag and handle */
	ahc->tag = iot;
	ahc->bsh = ioh;
d390 2
a393 6
	
	/* See if we are edge triggered */
	intdef = ahc_inb(ahc, INTDEF);
	if ((intdef & EDGE_TRIG) != 0)
		ahc->flags |= AHC_EDGE_INTERRUPT;

d413 1
a413 1
		sblkctl_orig = ahc_inb(ahc, SBLKCTL);
d415 2
a416 2
		ahc_outb(ahc, SBLKCTL, sblkctl);
		sblkctl = ahc_inb(ahc, SBLKCTL);
d424 1
a424 1
			ahc_outb(ahc, SBLKCTL, sblkctl);
d437 3
a439 3
		u_char hostconf = ahc_inb(ahc, HOSTCONF);
		ahc_outb(ahc, BUSSPD, hostconf & DFTHRSH);
		ahc_outb(ahc, BUSTIME, (hostconf << 2) & BOFF);
a448 8
	
	/* Special func to force negotiation */
	ahc_force_neg(ahc);
	
	/*
	 * Link this softc in with all other ahc instances.
	 */
	ahc_softc_insert(ahc);
d453 1
a453 1
	ahc_outb(ahc, BCTL, ENABLE);
d459 2
a460 2
	ahc->platform_data->ih = isa_intr_establish(ia->ia_ic, irq,
	    ahc->pause & IRQMS ? IST_LEVEL : IST_EDGE, IPL_BIO, ahc_platform_intr,
d462 1
a462 1
	if (ahc->platform_data->ih == NULL) {
a468 2
	ahc_intr_enable(ahc, TRUE);
	
d485 2
d500 2
a501 2
	have_seeprom = read_seeprom(&sd, 
				    (u_int16_t *)&sc, 
@


1.4
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_isa.c,v 1.3 1996/11/28 23:37:39 niklas Exp $	*/
d87 7
d122 1
d125 1
a125 1
	sizeof(struct ahc_data), ahc_isa_probe, ahc_isa_attach
d155 5
a160 1
	ahc_reset("ahc_isa", iot, ioh);
d276 1
a276 1
		    ia->ia_irq, irq);
d349 2
a350 2
	ahc_type type;
	struct ahc_data *ahc = (void *)self;
d357 1
d359 2
d370 1
a370 1
		type = AHC_284;
d373 1
a373 1
		type = AHC_284;
d379 1
a379 1
	ahc_construct(ahc, iot, ioh, type, AHC_FNONE);
d390 4
a396 13
	 *
	 * First, the aic7770 card specific setup.
	 */

	/* XXX
	 * On AHA-284x,
	 * all values are automagically intialized at
	 * POST for these cards, so we can always rely
	 * on the Scratch Ram values.  However, we should
	 * read the SEEPROM here (Dan has the code to do
	 * it) so we can say what kind of translation the
	 * BIOS is using.  Printing out the geometry could
	 * save a lot of users the grief of failed installs.
d398 1
d471 95
@


1.4.6.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a86 7
#include <dev/ic/smc93cx6var.h>

#ifdef DEBUG
#define bootverbose	1
#else
#define bootverbose	0
#endif
a114 1
void	aha2840_load_seeprom __P((struct ahc_softc *ahc));
d117 1
a117 1
	sizeof(struct ahc_softc), ahc_isa_probe, ahc_isa_attach
a146 5
	u_char hcntrl;
	
	/* Pause the card preseving the IRQ type */
	hcntrl = bus_space_read_1(iot, ioh, HCNTRL) & IRQMS;
	bus_space_write_1(iot, ioh, HCNTRL, hcntrl | PAUSE);
d148 1
d264 1
a264 1
		       ia->ia_irq, irq);
d337 2
a338 2
	ahc_chip chip;
	struct ahc_softc *ahc = (void *)self;
a344 1
	u_char channel = 'A';
a345 2
	ahc->sc_dmat = ia->ia_dmat;
	chip = AHC_VL; /* We are a VL Bus Controller */  
d355 1
a355 1
		chip |= AHC_AIC7770;
d358 1
a358 1
		chip |= AHC_AIC7770;
d364 1
a364 1
	ahc_construct(ahc, iot, ioh, chip, AHC_FNONE, AHC_AIC7770_FE, channel);
a374 4
	ahc->channel = 'A';
	ahc->channel_b = 'B';
	if (ahc_reset(ahc) != 0)
		return;
d378 13
a391 1
	aha2840_load_seeprom(ahc);
a463 95
}

/*
 * Read the 284x SEEPROM.
 */
void
aha2840_load_seeprom(struct ahc_softc *ahc)
{
	struct	  seeprom_descriptor sd;
	struct	  seeprom_config sc;
	u_int16_t checksum = 0;
	u_int8_t  scsi_conf;
	int	  have_seeprom;

	sd.sd_tag = ahc->sc_iot;
	sd.sd_bsh = ahc->sc_ioh;
	sd.sd_control_offset = SEECTL_2840;
	sd.sd_status_offset = STATUS_2840;
	sd.sd_dataout_offset = STATUS_2840;		
	sd.sd_chip = C46;
	sd.sd_MS = 0;
	sd.sd_RDY = EEPROM_TF;
	sd.sd_CS = CS_2840;
	sd.sd_CK = CK_2840;
	sd.sd_DO = DO_2840;
	sd.sd_DI = DI_2840;

	if (bootverbose)
		printf("%s: Reading SEEPROM...", ahc_name(ahc));
	have_seeprom = read_seeprom(&sd,
				    (u_int16_t *)&sc,
				    /*start_addr*/0,
				    sizeof(sc)/2);

	if (have_seeprom) {
		/* Check checksum */
		int i;
		int maxaddr = (sizeof(sc)/2) - 1;
		u_int16_t *scarray = (u_int16_t *)&sc;

		for (i = 0; i < maxaddr; i++)
			checksum = checksum + scarray[i];
		if (checksum != sc.checksum) {
			if(bootverbose)
				printf ("checksum error\n");
			have_seeprom = 0;
		} else if (bootverbose) {
			printf("done.\n");
		}
	}

	if (!have_seeprom) {
		if (bootverbose)
			printf("%s: No SEEPROM available\n", ahc_name(ahc));
		ahc->flags |= AHC_USEDEFAULTS;
	} else {
		/*
		 * Put the data we've collected down into SRAM
		 * where ahc_init will find it.
		 */
		int i;
		int max_targ = (ahc->features & AHC_WIDE) != 0 ? 16 : 8;
		u_int16_t discenable;

		discenable = 0;
		for (i = 0; i < max_targ; i++){
	                u_int8_t target_settings;
			target_settings = (sc.device_flags[i] & CFXFER) << 4;
			if (sc.device_flags[i] & CFSYNCH)
				target_settings |= SOFS;
			if (sc.device_flags[i] & CFWIDEB)
				target_settings |= WIDEXFER;
			if (sc.device_flags[i] & CFDISC)
				discenable |= (0x01 << i);
			ahc_outb(ahc, TARG_SCSIRATE + i, target_settings);
		}
		ahc_outb(ahc, DISC_DSB, ~(discenable & 0xff));
		ahc_outb(ahc, DISC_DSB + 1, ~((discenable >> 8) & 0xff));

		ahc->our_id = sc.brtime_id & CFSCSIID;

		scsi_conf = (ahc->our_id & 0x7);
		if (sc.adapter_control & CFSPARITY)
			scsi_conf |= ENSPCHK;
		if (sc.adapter_control & CFRESETB)
			scsi_conf |= RESET_SCSI;

		if (sc.bios_control & CF284XEXTEND)		
			ahc->flags |= AHC_EXTENDED_TRANS_A;
		/* Set SCSICONF info */
		ahc_outb(ahc, SCSICONF, scsi_conf);

		if (sc.adapter_control & CF284XSTERM)
			ahc->flags |= AHC_TERM_ENB_A;
	}
@


1.4.6.2
log
@Merge in trunk
@
text
@d86 2
a87 3
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
#include <dev/ic/aic7xxx_93cx6.h>
d105 1
d162 1
a162 1
	switch (irq = (intdef & VECTOR)) {
d349 1
d357 4
a360 18
	u_int intdef;
	/* 
	 * We really don't allocate our softc, but 
	 * we need to do the initialization. And this 
	 * also allocates the platform_data structure.
	 */
	ahc_alloc(ahc, ahc->sc_dev.dv_xname);
	
	ahc_set_name(ahc, ahc->sc_dev.dv_xname);
	ahc_set_unit(ahc, ahc->sc_dev.dv_unit);
	
	/* set dma tags */
	ahc->parent_dmat = ia->ia_dmat;
	ahc->buffer_dmat = ia->ia_dmat;
        ahc->shared_data_dmat = ia->ia_dmat;
	
	ahc->chip = AHC_VL; /* We are a VL Bus Controller */  
	
d370 1
d373 1
d378 2
a379 11
	
	ahc->channel = 'A';
	ahc->channel_b = 'B';
	ahc->chip = AHC_AIC7770;
	ahc->features = AHC_AIC7770_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
	ahc->flags |= AHC_PAGESCBS;
	
	/* set tag and handle */
	ahc->tag = iot;
	ahc->bsh = ioh;
d390 2
a393 6
	
	/* See if we are edge triggered */
	intdef = ahc_inb(ahc, INTDEF);
	if ((intdef & EDGE_TRIG) != 0)
		ahc->flags |= AHC_EDGE_INTERRUPT;

d413 1
a413 1
		sblkctl_orig = ahc_inb(ahc, SBLKCTL);
d415 2
a416 2
		ahc_outb(ahc, SBLKCTL, sblkctl);
		sblkctl = ahc_inb(ahc, SBLKCTL);
d424 1
a424 1
			ahc_outb(ahc, SBLKCTL, sblkctl);
d437 3
a439 3
		u_char hostconf = ahc_inb(ahc, HOSTCONF);
		ahc_outb(ahc, BUSSPD, hostconf & DFTHRSH);
		ahc_outb(ahc, BUSTIME, (hostconf << 2) & BOFF);
a448 8
	
	/* Special func to force negotiation */
	ahc_force_neg(ahc);
	
	/*
	 * Link this softc in with all other ahc instances.
	 */
	ahc_softc_insert(ahc);
d453 1
a453 1
	ahc_outb(ahc, BCTL, ENABLE);
d459 2
a460 2
	ahc->platform_data->ih = isa_intr_establish(ia->ia_ic, irq,
	    ahc->pause & IRQMS ? IST_LEVEL : IST_EDGE, IPL_BIO, ahc_platform_intr,
d462 1
a462 1
	if (ahc->platform_data->ih == NULL) {
a468 2
	ahc_intr_enable(ahc, TRUE);
	
d485 2
d500 2
a501 2
	have_seeprom = read_seeprom(&sd, 
				    (u_int16_t *)&sc, 
@


1.4.6.3
log
@Merge in -current from about a week ago
@
text
@d86 3
a88 2
#include <dev/ic/aic7xxxvar.h>
#include <dev/ic/smc93cx6var.h>
a105 1
#define INTDEF			0x5cul	/* Interrupt Definition Register */
d116 7
a122 7
int	ahc_isa_irq(bus_space_tag_t, bus_space_handle_t);
int	ahc_isa_idstring(bus_space_tag_t, bus_space_handle_t, char *);
int	ahc_isa_match(struct isa_attach_args *, bus_addr_t);

int	ahc_isa_probe(struct device *, void *, void *);
void	ahc_isa_attach(struct device *, struct device *, void *);
void	aha2840_load_seeprom(struct ahc_softc *ahc);
d162 1
a162 1
	switch (irq = (intdef & 0xf)) {
a348 1
	ahc_chip chip;
d356 18
a373 4
	u_char channel = 'A';

	ahc->sc_dmat = ia->ia_dmat;
	chip = AHC_VL; /* We are a VL Bus Controller */  
a382 1
		chip |= AHC_AIC7770;
a384 1
		chip |= AHC_AIC7770;
d389 11
a399 2

	ahc_construct(ahc, iot, ioh, chip, AHC_FNONE, AHC_AIC7770_FE, channel);
a409 2
	ahc->channel = 'A';
	ahc->channel_b = 'B';
d412 6
d437 1
a437 1
		sblkctl_orig = AHC_INB(ahc, SBLKCTL);
d439 2
a440 2
		AHC_OUTB(ahc, SBLKCTL, sblkctl);
		sblkctl = AHC_INB(ahc, SBLKCTL);
d448 1
a448 1
			AHC_OUTB(ahc, SBLKCTL, sblkctl);
d461 3
a463 3
		u_char hostconf = AHC_INB(ahc, HOSTCONF);
		AHC_OUTB(ahc, BUSSPD, hostconf & DFTHRSH);
		AHC_OUTB(ahc, BUSTIME, (hostconf << 2) & BOFF);
d473 8
d485 1
a485 1
	AHC_OUTB(ahc, BCTL, ENABLE);
d491 2
a492 2
	ahc->sc_ih = isa_intr_establish(ia->ia_ic, irq,
	    ahc->pause & IRQMS ? IST_LEVEL : IST_EDGE, IPL_BIO, ahc_intr,
d494 1
a494 1
	if (ahc->sc_ih == NULL) {
d501 2
a518 2
	sd.sd_tag = ahc->sc_iot;
	sd.sd_bsh = ahc->sc_ioh;
d532 2
a533 2
	have_seeprom = read_seeprom(&sd,
				    (u_int16_t *)&sc,
@


1.4.6.4
log
@Sync the SMP branch with 3.3
@
text
@d86 1
a86 2
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
d105 1
d162 1
a162 1
	switch (irq = (intdef & VECTOR)) {
d349 1
d357 4
a360 18
	u_int intdef;
	/* 
	 * We really don't allocate our softc, but 
	 * we need to do the initialization. And this 
	 * also allocates the platform_data structure.
	 */
	ahc_alloc(ahc, ahc->sc_dev.dv_xname);
	
	ahc_set_name(ahc, ahc->sc_dev.dv_xname);
	ahc_set_unit(ahc, ahc->sc_dev.dv_unit);
	
	/* set dma tags */
	ahc->parent_dmat = ia->ia_dmat;
	ahc->buffer_dmat = ia->ia_dmat;
        ahc->shared_data_dmat = ia->ia_dmat;
	
	ahc->chip = AHC_VL; /* We are a VL Bus Controller */  
	
d370 1
d373 1
d378 2
a379 11
	
	ahc->channel = 'A';
	ahc->channel_b = 'B';
	ahc->chip = AHC_AIC7770;
	ahc->features = AHC_AIC7770_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
	ahc->flags |= AHC_PAGESCBS;
	
	/* set tag and handle */
	ahc->tag = iot;
	ahc->bsh = ioh;
d390 2
a393 6
	
	/* See if we are edge triggered */
	intdef = ahc_inb(ahc, INTDEF);
	if ((intdef & EDGE_TRIG) != 0)
		ahc->flags |= AHC_EDGE_INTERRUPT;

d413 1
a413 1
		sblkctl_orig = ahc_inb(ahc, SBLKCTL);
d415 2
a416 2
		ahc_outb(ahc, SBLKCTL, sblkctl);
		sblkctl = ahc_inb(ahc, SBLKCTL);
d424 1
a424 1
			ahc_outb(ahc, SBLKCTL, sblkctl);
d437 3
a439 3
		u_char hostconf = ahc_inb(ahc, HOSTCONF);
		ahc_outb(ahc, BUSSPD, hostconf & DFTHRSH);
		ahc_outb(ahc, BUSTIME, (hostconf << 2) & BOFF);
a448 8
	
	/* Special func to force negotiation */
	ahc_force_neg(ahc);
	
	/*
	 * Link this softc in with all other ahc instances.
	 */
	ahc_softc_insert(ahc);
d453 1
a453 1
	ahc_outb(ahc, BCTL, ENABLE);
d459 2
a460 2
	ahc->platform_data->ih = isa_intr_establish(ia->ia_ic, irq,
	    ahc->pause & IRQMS ? IST_LEVEL : IST_EDGE, IPL_BIO, ahc_platform_intr,
d462 1
a462 1
	if (ahc->platform_data->ih == NULL) {
a468 2
	ahc_intr_enable(ahc, TRUE);
	
d485 2
d500 2
a501 2
	have_seeprom = read_seeprom(&sd, 
				    (u_int16_t *)&sc, 
@


1.4.6.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d85 1
d357 6
d369 2
d391 1
d474 3
d491 1
a491 1
	ahc->ih = isa_intr_establish(ia->ia_ic, irq,
d494 1
a494 1
	if (ahc->ih == NULL) {
a518 3
	sd.sd_tag = ahc->tag;
	sd.sd_bsh = ahc->bsh;
	sd.sd_regsize = 1;
@


1.3
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_isa.c,v 1.2 1996/11/12 20:30:00 niklas Exp $	*/
d360 1
a360 1
		panic("ahc_isa_attach: Unknown device type %s\n", idstring);
@


1.2
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 2
a2 2
/*	$OpenBSD: ahc_isa.c,v 1.1 1996/10/04 02:51:20 deraadt Exp $	*/
/*	$NetBSD: ahc_isa.c,v 1.1 1996/08/05 21:14:29 soda Exp $	*/
d73 1
a73 1
#include <machine/bus.old.h>
d109 3
a111 3
int	ahc_isa_irq __P((bus_chipset_tag_t, bus_io_handle_t));
int	ahc_isa_idstring __P((bus_chipset_tag_t, bus_io_handle_t, char *));
int	ahc_isa_match __P((struct isa_attach_args *, bus_io_addr_t));
d141 3
a143 3
ahc_isa_irq(bc, ioh)
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d148 2
a149 2
	ahc_reset("ahc_isa", bc, ioh);
	intdef = bus_io_read_1(bc, ioh, INTDEF);
d168 3
a170 3
ahc_isa_idstring(bc, ioh, idstring)
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d178 1
a178 1
		bus_io_write_1(bc, ioh, AHC_ISA_PRIMING,
d180 1
a180 1
		vid[i] = bus_io_read_1(bc, ioh, AHC_ISA_VID + i);
d202 1
a202 1
		bus_io_write_1(bc, ioh, AHC_ISA_PRIMING,
d204 1
a204 1
		pid[i] = bus_io_read_1(bc, ioh, AHC_ISA_PID + i);
d223 1
a223 1
	bus_io_addr_t iobase;
d225 2
a226 2
	bus_chipset_tag_t bc = ia->ia_bc;
	bus_io_handle_t ioh;
d235 1
a235 1
	if (bus_io_map(bc, iobase, AHC_ISA_IOSIZE, &ioh)) {
d248 1
a248 1
	if (!ahc_isa_idstring(bc, ioh, idstring))
d254 1
a254 1
		irq = ahc_isa_irq(bc, ioh);
d256 1
a256 1
	bus_io_unmap(bc, ioh, AHC_ISA_IOSIZE);
d340 2
a341 2
	bus_chipset_tag_t bc = ia->ia_bc;
	bus_io_handle_t ioh;
d346 1
a346 1
	if (bus_io_map(bc, ia->ia_iobase, ia->ia_iosize, &ioh))
d348 1
a348 1
	if (!ahc_isa_idstring(bc, ioh, idstring))
d350 1
a350 1
	if ((irq = ahc_isa_irq(bc, ioh)) < 0)
d364 1
a364 1
	ahc_construct(ahc, bc, ioh, type, AHC_FNONE);
d366 1
d373 1
@


1.1
log
@ahc on eisa, netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d73 1
a73 1
#include <machine/bus.h>
@
