head	1.83;
access;
symbols
	OPENBSD_6_2:1.83.0.6
	OPENBSD_6_2_BASE:1.83
	OPENBSD_6_1:1.83.0.4
	OPENBSD_6_1_BASE:1.83
	OPENBSD_6_0:1.82.0.4
	OPENBSD_6_0_BASE:1.82
	OPENBSD_5_9:1.82.0.2
	OPENBSD_5_9_BASE:1.82
	OPENBSD_5_8:1.80.0.4
	OPENBSD_5_8_BASE:1.80
	OPENBSD_5_7:1.79.0.2
	OPENBSD_5_7_BASE:1.79
	OPENBSD_5_6:1.77.0.4
	OPENBSD_5_6_BASE:1.77
	OPENBSD_5_5:1.75.0.6
	OPENBSD_5_5_BASE:1.75
	OPENBSD_5_4:1.75.0.2
	OPENBSD_5_4_BASE:1.75
	OPENBSD_5_3:1.72.0.8
	OPENBSD_5_3_BASE:1.72
	OPENBSD_5_2:1.72.0.6
	OPENBSD_5_2_BASE:1.72
	OPENBSD_5_1_BASE:1.72
	OPENBSD_5_1:1.72.0.4
	OPENBSD_5_0:1.72.0.2
	OPENBSD_5_0_BASE:1.72
	OPENBSD_4_9:1.71.0.2
	OPENBSD_4_9_BASE:1.71
	OPENBSD_4_8:1.69.0.2
	OPENBSD_4_8_BASE:1.69
	OPENBSD_4_7:1.68.0.2
	OPENBSD_4_7_BASE:1.68
	OPENBSD_4_6:1.67.0.4
	OPENBSD_4_6_BASE:1.67
	OPENBSD_4_5:1.66.0.2
	OPENBSD_4_5_BASE:1.66
	OPENBSD_4_4:1.63.0.2
	OPENBSD_4_4_BASE:1.63
	OPENBSD_4_3:1.61.0.2
	OPENBSD_4_3_BASE:1.61
	OPENBSD_4_2:1.60.0.2
	OPENBSD_4_2_BASE:1.60
	OPENBSD_4_1:1.57.0.2
	OPENBSD_4_1_BASE:1.57
	OPENBSD_4_0:1.54.0.4
	OPENBSD_4_0_BASE:1.54
	OPENBSD_3_9:1.54.0.2
	OPENBSD_3_9_BASE:1.54
	OPENBSD_3_8:1.51.0.4
	OPENBSD_3_8_BASE:1.51
	OPENBSD_3_7:1.51.0.2
	OPENBSD_3_7_BASE:1.51
	OPENBSD_3_6:1.50.0.2
	OPENBSD_3_6_BASE:1.50
	SMP_SYNC_A:1.48
	SMP_SYNC_B:1.48
	OPENBSD_3_5:1.48.0.4
	OPENBSD_3_5_BASE:1.48
	OPENBSD_3_4:1.48.0.2
	OPENBSD_3_4_BASE:1.48
	UBC_SYNC_A:1.47
	OPENBSD_3_3:1.47.0.2
	OPENBSD_3_3_BASE:1.47
	OPENBSD_3_2:1.46.0.2
	OPENBSD_3_2_BASE:1.46
	OPENBSD_3_1:1.45.0.2
	OPENBSD_3_1_BASE:1.45
	UBC_SYNC_B:1.46
	UBC:1.44.0.2
	UBC_BASE:1.44
	OPENBSD_3_0:1.38.0.2
	OPENBSD_3_0_BASE:1.38
	OPENBSD_2_9:1.35.0.4
	OPENBSD_2_9_BASE:1.35
	OPENBSD_2_8:1.35.0.2
	OPENBSD_2_8_BASE:1.35
	OPENBSD_2_7:1.34.0.6
	OPENBSD_2_7_BASE:1.34
	SMP:1.34.0.4
	SMP_BASE:1.34
	kame_19991208:1.34
	OPENBSD_2_6:1.34.0.2
	OPENBSD_2_6_BASE:1.34
	OPENBSD_2_5:1.33.0.2
	OPENBSD_2_5_BASE:1.33
	OPENBSD_2_4:1.31.0.2
	OPENBSD_2_4_BASE:1.31
	OPENBSD_2_3:1.28.0.2
	OPENBSD_2_3_BASE:1.28
	OPENBSD_2_2:1.22.0.2
	OPENBSD_2_2_BASE:1.22
	OPENBSD_2_1:1.20.0.2
	OPENBSD_2_1_BASE:1.20
	OPENBSD_2_0:1.16.0.2
	OPENBSD_2_0_BASE:1.16
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.83
date	2016.09.22.10.25.34;	author jsg;	state Exp;
branches;
next	1.82;
commitid	R6y4RKV4KYCSMHhM;

1.82
date	2015.09.27.10.12.09;	author semarie;	state Exp;
branches;
next	1.81;
commitid	1dIhYMDj5NezOASM;

1.81
date	2015.09.01.06.01.26;	author deraadt;	state Exp;
branches;
next	1.80;
commitid	sjMHb60Eu7lEqMDW;

1.80
date	2015.07.13.17.45.01;	author mikeb;	state Exp;
branches;
next	1.79;
commitid	zrjFB8VvK0ekXjjA;

1.79
date	2015.01.24.15.13.55;	author kettenis;	state Exp;
branches;
next	1.78;
commitid	Ol0pICcR5PormuCL;

1.78
date	2014.12.22.03.14.59;	author deraadt;	state Exp;
branches;
next	1.77;
commitid	Ti9NtP6cTSeecQSf;

1.77
date	2014.07.13.21.51.12;	author kettenis;	state Exp;
branches;
next	1.76;
commitid	9A5SNRwpm0B73qKM;

1.76
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.75;
commitid	uKVPYMN2MLxdZxzH;

1.75
date	2013.07.14.18.22.08;	author kettenis;	state Exp;
branches;
next	1.74;

1.74
date	2013.07.10.21.31.12;	author kettenis;	state Exp;
branches;
next	1.73;

1.73
date	2013.05.16.19.26.04;	author kettenis;	state Exp;
branches;
next	1.72;

1.72
date	2011.04.16.00.40.58;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2010.11.20.20.58.51;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.69;

1.69
date	2010.03.25.22.44.57;	author oga;	state Exp;
branches;
next	1.68;

1.68
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.67;

1.67
date	2009.03.10.15.03.17;	author oga;	state Exp;
branches;
next	1.66;

1.66
date	2008.12.11.17.07.14;	author oga;	state Exp;
branches;
next	1.65;

1.65
date	2008.12.10.20.26.56;	author oga;	state Exp;
branches;
next	1.64;

1.64
date	2008.12.03.15.46.06;	author oga;	state Exp;
branches;
next	1.63;

1.63
date	2008.06.26.05.42.11;	author ray;	state Exp;
branches;
next	1.62;

1.62
date	2008.04.26.14.33.27;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2007.09.07.15.00.19;	author art;	state Exp;
branches;
next	1.60;

1.60
date	2007.04.28.03.55.40;	author jsg;	state Exp;
branches;
next	1.59;

1.59
date	2007.04.12.20.22.58;	author art;	state Exp;
branches;
next	1.58;

1.58
date	2007.03.22.19.31.59;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.56;

1.56
date	2006.11.11.21.47.52;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2006.09.19.11.06.33;	author jsg;	state Exp;
branches;
next	1.54;

1.54
date	2005.11.24.08.37.08;	author mickey;	state Exp;
branches;
next	1.53;

1.53
date	2005.11.23.09.32.46;	author mickey;	state Exp;
branches;
next	1.52;

1.52
date	2005.11.23.09.24.54;	author mickey;	state Exp;
branches;
next	1.51;

1.51
date	2004.11.29.20.15.40;	author pat;	state Exp;
branches;
next	1.50;

1.50
date	2004.06.28.01.41.53;	author aaron;	state Exp;
branches;
next	1.49;

1.49
date	2004.06.13.21.49.16;	author niklas;	state Exp;
branches;
next	1.48;

1.48
date	2003.06.02.23.27.47;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2003.01.16.04.17.10;	author art;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.10.22.27.33;	author niklas;	state Exp;
branches;
next	1.45;

1.45
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2001.12.06.21.09.13;	author niklas;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2001.12.04.00.00.36;	author niklas;	state Exp;
branches;
next	1.42;

1.42
date	2001.11.18.20.46.49;	author aaron;	state Exp;
branches;
next	1.41;

1.41
date	2001.11.12.20.28.20;	author niklas;	state Exp;
branches;
next	1.40;

1.40
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.05.17.25.57;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2001.07.30.14.15.59;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.25.00.43.12;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.08.08.08.55;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2000.07.06.08.44.28;	author ho;	state Exp;
branches;
next	1.34;

1.34
date	99.07.23.13.18.04;	author niklas;	state Exp;
branches
	1.34.4.1;
next	1.33;

1.33
date	98.12.31.09.17.52;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	98.12.27.00.27.16;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	98.07.17.22.00.00;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	98.06.29.02.12.58;	author downsj;	state Exp;
branches;
next	1.29;

1.29
date	98.06.27.22.42.22;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	98.02.22.21.35.30;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	98.01.20.18.40.20;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	97.12.25.12.49.04;	author downsj;	state Exp;
branches;
next	1.25;

1.25
date	97.12.25.06.13.04;	author downsj;	state Exp;
branches;
next	1.24;

1.24
date	97.12.21.14.44.32;	author downsj;	state Exp;
branches;
next	1.23;

1.23
date	97.12.09.03.36.42;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.09.24.22.28.16;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	97.09.22.21.03.55;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	97.04.17.03.44.52;	author tholo;	state Exp;
branches;
next	1.19;

1.19
date	97.01.04.14.05.50;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	96.12.12.07.44.55;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	96.10.16.12.46.27;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.08.26.06.52.29;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.05.25.22.17.49;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.05.07.07.22.17;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.04.22.20.03.07;	author hannken;	state Exp;
branches;
next	1.12;

1.12
date	96.04.21.22.16.54;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.04.19.05.41.52;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	96.04.18.17.12.16;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	96.04.18.12.00.25;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.03.20.00.31.03;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.03.19.21.09.35;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.02.25.06.00.27;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.02.20.04.35.30;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	95.12.31.21.00.09;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.27.22.10.37;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.28.16.43.56;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.37;	author deraadt;	state Exp;
branches;
next	;

1.34.4.1
date	2001.04.18.16.07.52;	author niklas;	state Exp;
branches;
next	1.34.4.2;

1.34.4.2
date	2001.07.04.10.16.54;	author niklas;	state Exp;
branches;
next	1.34.4.3;

1.34.4.3
date	2001.07.14.10.02.42;	author ho;	state Exp;
branches;
next	1.34.4.4;

1.34.4.4
date	2001.07.16.21.41.13;	author niklas;	state Exp;
branches;
next	1.34.4.5;

1.34.4.5
date	2001.10.28.08.16.45;	author niklas;	state Exp;
branches;
next	1.34.4.6;

1.34.4.6
date	2001.10.29.08.59.11;	author niklas;	state Exp;
branches;
next	1.34.4.7;

1.34.4.7
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.34.4.8;

1.34.4.8
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.34.4.9;

1.34.4.9
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.34.4.10;

1.34.4.10
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.34.4.11;

1.34.4.11
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.34.4.12;

1.34.4.12
date	2003.03.27.23.26.55;	author niklas;	state Exp;
branches;
next	1.34.4.13;

1.34.4.13
date	2003.05.25.19.24.32;	author ho;	state Exp;
branches;
next	1.34.4.14;

1.34.4.14
date	2003.06.07.11.11.37;	author ho;	state Exp;
branches;
next	1.34.4.15;

1.34.4.15
date	2004.03.23.08.02.56;	author niklas;	state Exp;
branches;
next	1.34.4.16;

1.34.4.16
date	2004.06.07.19.19.18;	author art;	state Exp;
branches;
next	1.34.4.17;

1.34.4.17
date	2004.06.11.15.01.46;	author grange;	state Exp;
branches;
next	;

1.44.2.1
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2002.10.29.00.28.04;	author art;	state Exp;
branches;
next	1.44.2.3;

1.44.2.3
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.83
log
@Fix indentation.  No binary change.
@
text
@/*	$OpenBSD: isa_machdep.c,v 1.82 2015/09/27 10:12:09 semarie Exp $	*/
/*	$NetBSD: isa_machdep.c,v 1.22 1997/06/12 23:57:32 thorpej Exp $	*/

/*-
 * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1993, 1994, 1996, 1997
 *	Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1991 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)isa.c	7.2 (Berkeley) 5/13/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/proc.h>

#include <uvm/uvm_extern.h>

#include "ioapic.h"

#if NIOAPIC > 0
#include <machine/i82093var.h>
#include <machine/mpbiosvar.h>
#endif

#include <machine/bus.h>

#include <machine/intr.h>
#include <machine/pio.h>
#include <machine/cpufunc.h>
#include <machine/i8259.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>
#include <i386/isa/isa_machdep.h>

#include "isadma.h"

extern	paddr_t avail_end;

#define	IDTVEC(name)	__CONCAT(X,name)
/* default interrupt vector table entries */
typedef int (*vector)(void);
extern vector IDTVEC(intr)[];
void isa_strayintr(int);
void intr_calculatemasks(void);
int fakeintr(void *);

#if NISADMA > 0
int	_isa_bus_dmamap_create(bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *);
void	_isa_bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	_isa_bus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	_isa_bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
int	_isa_bus_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
int	_isa_bus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	_isa_bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_isa_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t,
	    bus_addr_t, bus_size_t, int);

int	_isa_bus_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t,
	    bus_size_t, bus_dma_segment_t *, int, int *, int);

int	_isa_dma_check_buffer(void *, bus_size_t, int, bus_size_t,
	    struct proc *);
int	_isa_dma_alloc_bouncebuf(bus_dma_tag_t, bus_dmamap_t,
	    bus_size_t, int);
void	_isa_dma_free_bouncebuf(bus_dma_tag_t, bus_dmamap_t);

/*
 * Entry points for ISA DMA.  These are mostly wrappers around
 * the generic functions that understand how to deal with bounce
 * buffers, if necessary.
 */
struct bus_dma_tag isa_bus_dma_tag = {
	NULL,			/* _cookie */
	_isa_bus_dmamap_create,
	_isa_bus_dmamap_destroy,
	_isa_bus_dmamap_load,
	_isa_bus_dmamap_load_mbuf,
	_isa_bus_dmamap_load_uio,
	_isa_bus_dmamap_load_raw,
	_isa_bus_dmamap_unload,
	_isa_bus_dmamap_sync,
	_isa_bus_dmamem_alloc,
	_bus_dmamem_alloc_range,
	_bus_dmamem_free,
	_bus_dmamem_map,
	_bus_dmamem_unmap,
	_bus_dmamem_mmap,
};
#endif /* NISADMA > 0 */

/*
 * Fill in default interrupt table (in case of spurious interrupt
 * during configuration of kernel, setup interrupt control unit
 */
void
isa_defaultirq(void)
{
	int i;

	/* icu vectors */
	for (i = 0; i < ICU_LEN; i++)
		setgate(&idt[ICU_OFFSET + i], IDTVEC(intr)[i], 0,
		    SDT_SYS386IGT, SEL_KPL, GICODE_SEL);
  
	/* initialize 8259's */
	outb(IO_ICU1, 0x11);		/* reset; program device, four bytes */
	outb(IO_ICU1+1, ICU_OFFSET);	/* starting at this vector index */
	outb(IO_ICU1+1, 1 << IRQ_SLAVE); /* slave on line 2 */
#ifdef AUTO_EOI_1
	outb(IO_ICU1+1, 2 | 1);		/* auto EOI, 8086 mode */
#else
	outb(IO_ICU1+1, 1);		/* 8086 mode */
#endif
	outb(IO_ICU1+1, 0xff);		/* leave interrupts masked */
	outb(IO_ICU1, 0x68);		/* special mask mode (if available) */
	outb(IO_ICU1, 0x0a);		/* Read IRR by default. */
#ifdef REORDER_IRQ
	outb(IO_ICU1, 0xc0 | (3 - 1));	/* pri order 3-7, 0-2 (com2 first) */
#endif

	outb(IO_ICU2, 0x11);		/* reset; program device, four bytes */
	outb(IO_ICU2+1, ICU_OFFSET+8);	/* staring at this vector index */
	outb(IO_ICU2+1, IRQ_SLAVE);
#ifdef AUTO_EOI_2
	outb(IO_ICU2+1, 2 | 1);		/* auto EOI, 8086 mode */
#else
	outb(IO_ICU2+1, 1);		/* 8086 mode */
#endif
	outb(IO_ICU2+1, 0xff);		/* leave interrupts masked */
	outb(IO_ICU2, 0x68);		/* special mask mode (if available) */
	outb(IO_ICU2, 0x0a);		/* Read IRR by default. */
}

/*
 * Handle a NMI, possibly a machine check.
 * return true to panic system, false to ignore.
 */
int
isa_nmi(void)
{
	/* This is historic garbage; these ports are not readable */
	log(LOG_CRIT, "No-maskable interrupt, may be parity error\n");
	return(0);
}

u_long  intrstray[ICU_LEN];

/*
 * Caught a stray interrupt, notify
 */
void
isa_strayintr(int irq)
{
        /*
         * Stray interrupts on irq 7 occur when an interrupt line is raised
         * and then lowered before the CPU acknowledges it.  This generally
         * means either the device is screwed or something is cli'ing too
         * long and it's timing out.
         */
	if (++intrstray[irq] <= 5)
		log(LOG_ERR, "stray interrupt %d%s\n", irq,
		    intrstray[irq] >= 5 ? "; stopped logging" : "");
}

int intrtype[ICU_LEN], intrmask[ICU_LEN], intrlevel[ICU_LEN];
int iminlevel[ICU_LEN], imaxlevel[ICU_LEN];
struct intrhand *intrhand[ICU_LEN];

int imask[NIPL];	/* Bitmask telling what interrupts are blocked. */
int iunmask[NIPL];	/* Bitmask telling what interrupts are accepted. */

/*
 * Recalculate the interrupt masks from scratch.
 * We could code special registry and deregistry versions of this function that
 * would be faster, but the code would be nastier, and we don't expect this to
 * happen very much anyway.
 */
void
intr_calculatemasks(void)
{
	int irq, level, unusedirqs;
	struct intrhand *q;

	/* First, figure out which levels each IRQ uses. */
	unusedirqs = 0xffff;
	for (irq = 0; irq < ICU_LEN; irq++) {
		int levels = 0;
		for (q = intrhand[irq]; q; q = q->ih_next)
			levels |= 1 << IPL(q->ih_level);
		intrlevel[irq] = levels;
		if (levels)
			unusedirqs &= ~(1 << irq);
	}

	/* Then figure out which IRQs use each level. */
	for (level = 0; level < NIPL; level++) {
		int irqs = 0;
		for (irq = 0; irq < ICU_LEN; irq++)
			if (intrlevel[irq] & (1 << level))
				irqs |= 1 << irq;
		imask[level] = irqs | unusedirqs;
	}

	/*
	 * Initialize soft interrupt masks to block themselves.
	 */
	IMASK(IPL_SOFTCLOCK) |= 1 << SIR_CLOCK;
	IMASK(IPL_SOFTNET) |= 1 << SIR_NET;
	IMASK(IPL_SOFTTTY) |= 1 << SIR_TTY;

	/*
	 * Enforce a hierarchy that gives slow devices a better chance at not
	 * dropping data.
	 */
	for (level = 0; level < NIPL - 1; level++)
		imask[level + 1] |= imask[level];

	/* And eventually calculate the complete masks. */
	for (irq = 0; irq < ICU_LEN; irq++) {
		int irqs = 1 << irq;
		int minlevel = IPL_NONE;
		int maxlevel = IPL_NONE;

		if (intrhand[irq] == NULL) {
			maxlevel = IPL_HIGH;
			irqs = IMASK(IPL_HIGH);
		} else {
			for (q = intrhand[irq]; q; q = q->ih_next) {
				irqs |= IMASK(q->ih_level);
				if (minlevel == IPL_NONE ||
				    q->ih_level < minlevel)
					minlevel = q->ih_level;
				if (q->ih_level > maxlevel)
					maxlevel = q->ih_level;
			}
		}
		if (irqs != IMASK(maxlevel))
			panic("irq %d level %x mask mismatch: %x vs %x", irq,
			    maxlevel, irqs, IMASK(maxlevel));

		intrmask[irq] = irqs;
		iminlevel[irq] = minlevel;
		imaxlevel[irq] = maxlevel;

#if 0
		printf("irq %d: level %x, mask 0x%x (%x)\n", irq,
		    imaxlevel[irq], intrmask[irq], IMASK(imaxlevel[irq]));
#endif
	}

	/* Lastly, determine which IRQs are actually in use. */
	{
		int irqs = 0;
		for (irq = 0; irq < ICU_LEN; irq++)
			if (intrhand[irq])
				irqs |= 1 << irq;
		if (irqs >= 0x100) /* any IRQs >= 8 in use */
			irqs |= 1 << IRQ_SLAVE;
		imen = ~irqs;
		SET_ICUS();
	}

	/* For speed of splx, provide the inverse of the interrupt masks. */
	for (irq = 0; irq < ICU_LEN; irq++)
		iunmask[irq] = ~imask[irq];
}

int
fakeintr(arg)
	void *arg;
{
	return 0;
}

#define	LEGAL_IRQ(x)	((x) >= 0 && (x) < ICU_LEN && (x) != 2)

int
isa_intr_alloc(isa_chipset_tag_t ic, int mask, int type, int *irq)
{
	int i, bestirq, count;
	int tmp;
	struct intrhand **p, *q;

	if (type == IST_NONE)
		panic("intr_alloc: bogus type");

	bestirq = -1;
	count = -1;

	/* some interrupts should never be dynamically allocated */
	mask &= 0xdef8;

	/*
	 * XXX some interrupts will be used later (6 for fdc, 12 for pms).
	 * the right answer is to do "breadth-first" searching of devices.
	 */
	mask &= 0xefbf;

	for (i = 0; i < ICU_LEN; i++) {
		if (LEGAL_IRQ(i) == 0 || (mask & (1<<i)) == 0)
			continue;

		switch(intrtype[i]) {
		case IST_NONE:
			/*
			 * if nothing's using the irq, just return it
			 */
			*irq = i;
			return (0);

		case IST_EDGE:
		case IST_LEVEL:
			if (type != intrtype[i])
				continue;
			/*
			 * if the irq is shareable, count the number of other
			 * handlers, and if it's smaller than the last irq like
			 * this, remember it
			 *
			 * XXX We should probably also consider the
			 * interrupt level and stick IPL_TTY with other
			 * IPL_TTY, etc.
			 */
			for (p = &intrhand[i], tmp = 0; (q = *p) != NULL;
			     p = &q->ih_next, tmp++)
				;
			if ((bestirq == -1) || (count > tmp)) {
				bestirq = i;
				count = tmp;
			}
			break;

		case IST_PULSE:
			/* this just isn't shareable */
			continue;
		}
	}

	if (bestirq == -1)
		return (1);

	*irq = bestirq;

	return (0);
}

/*
 * Just check to see if an IRQ is available/can be shared.
 * 0 = interrupt not available
 * 1 = interrupt shareable
 * 2 = interrupt all to ourself
 */
int
isa_intr_check(isa_chipset_tag_t ic, int irq, int type)
{
	if (!LEGAL_IRQ(irq) || type == IST_NONE)
		return (0);

	switch (intrtype[irq]) {
	case IST_NONE:
		return (2);
		break;
	case IST_LEVEL:
		if (type != intrtype[irq])
			return (0);
		return (1);
		break;
	case IST_EDGE:
	case IST_PULSE:
		if (type != IST_NONE)
			return (0);
	}
	return (1);
}

/*
 * Set up an interrupt handler to start being called.
 * XXX PRONE TO RACE CONDITIONS, UGLY, 'INTERESTING' INSERTION ALGORITHM.
 */
void *
isa_intr_establish(isa_chipset_tag_t ic, int irq, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, const char *ih_what)
{
	struct intrhand **p, *q, *ih;
	static struct intrhand fakehand = {fakeintr};
	int flags;

#if NIOAPIC > 0
	struct mp_intr_map *mip;

	if (mp_busses != NULL) {
		int mpspec_pin = irq;
		int airq;

		if (mp_isa_bus == NULL)
			panic("no isa bus");

		for (mip = mp_isa_bus->mb_intrs; mip != NULL;
		    mip = mip->next) {
			if (mip->bus_pin == mpspec_pin) {
				airq = mip->ioapic_ih | irq;
				break;
			}
		}
		if (mip == NULL && mp_eisa_bus) {
			for (mip = mp_eisa_bus->mb_intrs; mip != NULL;
			    mip = mip->next) {
				if (mip->bus_pin == mpspec_pin) {
					airq = mip->ioapic_ih | irq;
					break;
				}
			}
		}

		/* no MP mapping found -- invent! */
 		if (mip == NULL)
			airq = mpbios_invent(irq, type, mp_isa_bus->mb_idx);

		return (apic_intr_establish(airq, type, level, ih_fun,
		    ih_arg, ih_what));
 	}
#endif

	flags = level & IPL_MPSAFE;
	level &= ~IPL_MPSAFE;

	KASSERT(level <= IPL_TTY || level >= IPL_CLOCK || flags & IPL_MPSAFE);

	/* no point in sleeping unless someone can free memory. */
	ih = malloc(sizeof *ih, M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL) {
		printf("%s: isa_intr_establish: can't malloc handler info\n",
		    ih_what);
		return (NULL);
	}

	if (!LEGAL_IRQ(irq) || type == IST_NONE) {
		printf("%s: isa_intr_establish: bogus irq or type\n", ih_what);
		free(ih, M_DEVBUF, sizeof *ih);
		return (NULL);
	}
	switch (intrtype[irq]) {
	case IST_NONE:
		intrtype[irq] = type;
		break;
	case IST_EDGE:
		intr_shared_edge = 1;
		/* FALLTHROUGH */
	case IST_LEVEL:
		if (type == intrtype[irq])
			break;
	case IST_PULSE:
		if (type != IST_NONE) {
			/*printf("%s: intr_establish: can't share %s with %s, irq %d\n",
			    ih_what, isa_intr_typename(intrtype[irq]),
			    isa_intr_typename(type), irq);*/
			free(ih, M_DEVBUF, sizeof *ih);
			return (NULL);
		}
		break;
	}

	/*
	 * Figure out where to put the handler.
	 * This is O(N^2), but we want to preserve the order, and N is
	 * generally small.
	 */
	for (p = &intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
		;

	/*
	 * Actually install a fake handler momentarily, since we might be doing
	 * this with interrupts enabled and don't want the real routine called
	 * until masking is set up.
	 */
	fakehand.ih_level = level;
	*p = &fakehand;

	intr_calculatemasks();

	/*
	 * Poke the real handler in now.
	 */
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_next = NULL;
	ih->ih_level = level;
	ih->ih_flags = flags;
	ih->ih_irq = irq;
	evcount_attach(&ih->ih_count, ih_what, &ih->ih_irq);
	*p = ih;

	return (ih);
}

/*
 * Deregister an interrupt handler.
 */
void
isa_intr_disestablish(isa_chipset_tag_t ic, void *arg)
{
	struct intrhand *ih = arg;
	int irq = ih->ih_irq;
	struct intrhand **p, *q;

#if NIOAPIC > 0
	if (irq & APIC_INT_VIA_APIC) {
		apic_intr_disestablish(arg);
		return;
	}
#endif

	if (!LEGAL_IRQ(irq))
		panic("intr_disestablish: bogus irq %d", irq);

	/*
	 * Remove the handler from the chain.
	 * This is O(n^2), too.
	 */
	for (p = &intrhand[irq]; (q = *p) != NULL && q != ih; p = &q->ih_next)
		;
	if (q)
		*p = q->ih_next;
	else
		panic("intr_disestablish: handler not registered");
	evcount_detach(&ih->ih_count);
	free(ih, M_DEVBUF, sizeof *ih);

	intr_calculatemasks();

	if (intrhand[irq] == NULL)
		intrtype[irq] = IST_NONE;
}

void
isa_attach_hook(struct device *parent, struct device *self,
    struct isabus_attach_args *iba)
{
	extern int isa_has_been_seen;

	/*
	 * Notify others that might need to know that the ISA bus
	 * has now been attached.
	 */
	if (isa_has_been_seen)
		panic("isaattach: ISA bus already seen!");
	isa_has_been_seen = 1;
}

#if NISADMA > 0
/**********************************************************************
 * bus.h dma interface entry points
 **********************************************************************/

#ifdef ISA_DMA_STATS
#define	STAT_INCR(v)	(v)++
#define	STAT_DECR(v)	do { \
		if ((v) == 0) \
			printf("%s:%d -- Already 0!\n", __FILE__, __LINE__); \
		else \
			(v)--; \
		} while (0)
u_long	isa_dma_stats_loads;
u_long	isa_dma_stats_bounces;
u_long	isa_dma_stats_nbouncebufs;
#else
#define	STAT_INCR(v)
#define	STAT_DECR(v)
#endif

/*
 * Create an ISA DMA map.
 */
int
_isa_bus_dmamap_create(bus_dma_tag_t t, bus_size_t size, int nsegments,
    bus_size_t maxsegsz, bus_size_t boundary, int flags, bus_dmamap_t *dmamp)
{
	struct isa_dma_cookie *cookie;
	bus_dmamap_t map;
	int error, cookieflags;
	void *cookiestore;
	size_t cookiesize;

	/* Call common function to create the basic map. */
	error = _bus_dmamap_create(t, size, nsegments, maxsegsz, boundary,
	    flags, dmamp);
	if (error)
		return (error);

	map = *dmamp;
	map->_dm_cookie = NULL;

	cookiesize = sizeof(struct isa_dma_cookie);

	/*
	 * ISA only has 24-bits of address space.  This means
	 * we can't DMA to pages over 16M.  In order to DMA to
	 * arbitrary buffers, we use "bounce buffers" - pages
	 * in memory below the 16M boundary.  On DMA reads,
	 * DMA happens to the bounce buffers, and is copied into
	 * the caller's buffer.  On writes, data is copied into
	 * the bounce buffer, and the DMA happens from those
	 * pages.  To software using the DMA mapping interface,
	 * this looks simply like a data cache.
	 *
	 * If we have more than 16M of RAM in the system, we may
	 * need bounce buffers.  We check and remember that here.
	 *
	 * There are exceptions, however.  VLB devices can do
	 * 32-bit DMA, and indicate that here.
	 *
	 * ...or, there is an opposite case.  The most segments
	 * a transfer will require is (maxxfer / NBPG) + 1.  If
	 * the caller can't handle that many segments (e.g. the
	 * ISA DMA controller), we may have to bounce it as well.
	 */
	cookieflags = 0;
	if ((avail_end > ISA_DMA_BOUNCE_THRESHOLD &&
	    (flags & ISABUS_DMA_32BIT) == 0) ||
	    ((map->_dm_size / NBPG) + 1) > map->_dm_segcnt) {
		cookieflags |= ID_MIGHT_NEED_BOUNCE;
		cookiesize += (sizeof(bus_dma_segment_t) * map->_dm_segcnt);
	}

	/*
	 * Allocate our cookie.
	 */
	if ((cookiestore = malloc(cookiesize, M_DEVBUF,
	    ((flags & BUS_DMA_NOWAIT) ? M_NOWAIT : M_WAITOK)|M_ZERO)) == NULL) {
		error = ENOMEM;
		goto out;
	}
	cookie = (struct isa_dma_cookie *)cookiestore;
	cookie->id_flags = cookieflags;
	map->_dm_cookie = cookie;

	if (cookieflags & ID_MIGHT_NEED_BOUNCE) {
		/*
		 * Allocate the bounce pages now if the caller
		 * wishes us to do so.
		 */
		if ((flags & BUS_DMA_ALLOCNOW) == 0)
			goto out;

		error = _isa_dma_alloc_bouncebuf(t, map, size, flags);
	}

 out:
	if (error) {
		free(map->_dm_cookie, M_DEVBUF, cookiesize);
		_bus_dmamap_destroy(t, map);
	}
	return (error);
}

/*
 * Destroy an ISA DMA map.
 */
void
_isa_bus_dmamap_destroy(bus_dma_tag_t t, bus_dmamap_t map)
{
	struct isa_dma_cookie *cookie = map->_dm_cookie;

	/*
	 * Free any bounce pages this map might hold.
	 */
	if (cookie->id_flags & ID_HAS_BOUNCE)
		_isa_dma_free_bouncebuf(t, map);

	free(cookie, M_DEVBUF, 0);
	_bus_dmamap_destroy(t, map);
}

/*
 * Load an ISA DMA map with a linear buffer.
 */
int
_isa_bus_dmamap_load(bus_dma_tag_t t, bus_dmamap_t map, void *buf,
    bus_size_t buflen, struct proc *p, int flags)
{
	struct isa_dma_cookie *cookie = map->_dm_cookie;
	int error;

	STAT_INCR(isa_dma_stats_loads);

	/*
	 * Check to see if we might need to bounce the transfer.
	 */
	if (cookie->id_flags & ID_MIGHT_NEED_BOUNCE) {
		/*
		 * Check if all pages are below the bounce
		 * threshold.  If they are, don't bother bouncing.
		 */
		if (_isa_dma_check_buffer(buf, buflen,
		    map->_dm_segcnt, map->_dm_boundary, p) == 0)
			return (_bus_dmamap_load(t, map, buf, buflen,
			    p, flags));

		STAT_INCR(isa_dma_stats_bounces);

		/*
		 * Allocate bounce pages, if necessary.
		 */
		if ((cookie->id_flags & ID_HAS_BOUNCE) == 0) {
			error = _isa_dma_alloc_bouncebuf(t, map, buflen,
			    flags);
			if (error)
				return (error);
		}

		/*
		 * Cache a pointer to the caller's buffer and
		 * load the DMA map with the bounce buffer.
		 */
		cookie->id_origbuf = buf;
		cookie->id_origbuflen = buflen;
		error = _bus_dmamap_load(t, map, cookie->id_bouncebuf,
		    buflen, p, flags);
		
		if (error) {
			/*
			 * Free the bounce pages, unless our resources
			 * are reserved for our exclusive use.
			 */
			if ((map->_dm_flags & BUS_DMA_ALLOCNOW) == 0)
				_isa_dma_free_bouncebuf(t, map);
		}

		/* ...so _isa_bus_dmamap_sync() knows we're bouncing */
		cookie->id_flags |= ID_IS_BOUNCING;
	} else {
		/*
		 * Just use the generic load function.
		 */
		error = _bus_dmamap_load(t, map, buf, buflen, p, flags); 
	}

	return (error);
}

/*
 * Like _isa_bus_dmamap_load(), but for mbufs.
 */
int
_isa_bus_dmamap_load_mbuf(bus_dma_tag_t t, bus_dmamap_t map, struct mbuf *m,
    int flags)
{

	panic("_isa_bus_dmamap_load_mbuf: not implemented");
}

/*
 * Like _isa_bus_dmamap_load(), but for uios.
 */
int
_isa_bus_dmamap_load_uio(bus_dma_tag_t t, bus_dmamap_t map, struct uio *uio,
    int flags)
{

	panic("_isa_bus_dmamap_load_uio: not implemented");
}

/*
 * Like _isa_bus_dmamap_load(), but for raw memory allocated with
 * bus_dmamem_alloc().
 */
int
_isa_bus_dmamap_load_raw(bus_dma_tag_t t, bus_dmamap_t map,
    bus_dma_segment_t *segs, int nsegs, bus_size_t size, int flags)
{

	panic("_isa_bus_dmamap_load_raw: not implemented");
}

/*
 * Unload an ISA DMA map.
 */
void
_isa_bus_dmamap_unload(bus_dma_tag_t t, bus_dmamap_t map)
{
	struct isa_dma_cookie *cookie = map->_dm_cookie;

	/*
	 * If we have bounce pages, free them, unless they're
	 * reserved for our exclusive use.
	 */
	if ((cookie->id_flags & ID_HAS_BOUNCE) &&
	    (map->_dm_flags & BUS_DMA_ALLOCNOW) == 0)
		_isa_dma_free_bouncebuf(t, map);

	cookie->id_flags &= ~ID_IS_BOUNCING;

	/*
	 * Do the generic bits of the unload.
	 */
	_bus_dmamap_unload(t, map);
}

/*
 * Synchronize an ISA DMA map.
 */
void
_isa_bus_dmamap_sync(bus_dma_tag_t t, bus_dmamap_t map, bus_addr_t offset,
    bus_size_t len, int op)
{
	struct isa_dma_cookie *cookie = map->_dm_cookie;

#ifdef DEBUG
	if ((op & (BUS_DMASYNC_PREWRITE|BUS_DMASYNC_POSTREAD)) != 0) {
		if (offset >= map->dm_mapsize)
			panic("_isa_bus_dmamap_sync: bad offset");
		if (len == 0 || (offset + len) > map->dm_mapsize)
			panic("_isa_bus_dmamap_sync: bad length");
	}
#endif
#ifdef DIAGNOSTIC
	if ((op & (BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE)) != 0 &&
	    (op & (BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE)) != 0)
		panic("_isa_bus_dmamap_sync: mix PRE and POST");
#endif /* DIAGNOSTIC */

	/* PREREAD and POSTWRITE are no-ops */
	if (op & BUS_DMASYNC_PREWRITE) {
		/*
		 * If we're bouncing this transfer, copy the
		 * caller's buffer to the bounce buffer.
		 */
		if (cookie->id_flags & ID_IS_BOUNCING)
			memcpy(cookie->id_bouncebuf + offset,
			    (char *)cookie->id_origbuf + offset, len);
	}

	_bus_dmamap_sync(t, map, offset, len, op);

	if (op & BUS_DMASYNC_POSTREAD) {
		/*
		 * If we're bouncing this transfer, copy the
		 * bounce buffer to the caller's buffer.
		 */
		if (cookie->id_flags & ID_IS_BOUNCING)
			memcpy(cookie->id_origbuf + offset,
			    (char *)cookie->id_bouncebuf + offset, len);
	}
}

/*
 * Allocate memory safe for ISA DMA.
 */
int
_isa_bus_dmamem_alloc(bus_dma_tag_t t, bus_size_t size, bus_size_t alignment,
    bus_size_t boundary, bus_dma_segment_t *segs, int nsegs, int *rsegs,
    int flags)
{
	int error;

	/* Try in ISA addressable region first */
	error = _bus_dmamem_alloc_range(t, size, alignment, boundary,
	    segs, nsegs, rsegs, flags, 0, ISA_DMA_BOUNCE_THRESHOLD);
	if (!error)
		return (error);

	/* Otherwise try anywhere (we'll bounce later) */
	error = _bus_dmamem_alloc_range(t, size, alignment, boundary,
	    segs, nsegs, rsegs, flags, (bus_addr_t)0, (bus_addr_t)-1);
	return (error);
}


/**********************************************************************
 * ISA DMA utility functions
 **********************************************************************/

/*
 * Return 0 if all pages in the passed buffer lie within the DMA'able
 * range RAM.
 */
int
_isa_dma_check_buffer(void *buf, bus_size_t buflen, int segcnt,
    bus_size_t boundary, struct proc *p)
{
	vaddr_t vaddr = (vaddr_t)buf;
	vaddr_t endva;
	paddr_t pa, lastpa;
	u_long pagemask = ~(boundary - 1);
	pmap_t pmap;
	int nsegs;

	endva = round_page(vaddr + buflen);

	nsegs = 1;
	lastpa = 0;

	if (p != NULL)
		pmap = p->p_vmspace->vm_map.pmap;
	else
		pmap = pmap_kernel();

	for (; vaddr < endva; vaddr += NBPG) {
		/*
		 * Get physical address for this segment.
		 */
		pmap_extract(pmap, (vaddr_t)vaddr, &pa);
		pa = trunc_page(pa);

		/*
		 * Is it below the DMA'able threshold?
		 */
		if (pa > ISA_DMA_BOUNCE_THRESHOLD)
			return (EINVAL);

		if (lastpa) {
			/*
			 * Check excessive segment count.
			 */
			if (lastpa + NBPG != pa) {
				if (++nsegs > segcnt)
					return (EFBIG);
			}

			/*
			 * Check boundary restriction.
			 */
			if (boundary) {
				if ((lastpa ^ pa) & pagemask)
					return (EINVAL);
			}
		}
		lastpa = pa;
	}

	return (0);
}

int
_isa_dma_alloc_bouncebuf(bus_dma_tag_t t, bus_dmamap_t map, bus_size_t size, int flags)
{
	struct isa_dma_cookie *cookie = map->_dm_cookie;
	int error = 0;

	cookie->id_bouncebuflen = round_page(size);
	error = _bus_dmamem_alloc_range(t, cookie->id_bouncebuflen,
	    NBPG, map->_dm_boundary, cookie->id_bouncesegs,
	    map->_dm_segcnt, &cookie->id_nbouncesegs, flags,
	    0, ISA_DMA_BOUNCE_THRESHOLD);
	if (error)
		goto out;
	error = _bus_dmamem_map(t, cookie->id_bouncesegs,
	    cookie->id_nbouncesegs, cookie->id_bouncebuflen,
	    (caddr_t *)&cookie->id_bouncebuf, flags);

 out:
	if (error) {
		_bus_dmamem_free(t, cookie->id_bouncesegs,
		    cookie->id_nbouncesegs);
		cookie->id_bouncebuflen = 0;
		cookie->id_nbouncesegs = 0;
	} else {
		cookie->id_flags |= ID_HAS_BOUNCE;
		STAT_INCR(isa_dma_stats_nbouncebufs);
	}

	return (error);
}

void
_isa_dma_free_bouncebuf(bus_dma_tag_t t, bus_dmamap_t map)
{
	struct isa_dma_cookie *cookie = map->_dm_cookie;

	STAT_DECR(isa_dma_stats_nbouncebufs);

	_bus_dmamem_unmap(t, cookie->id_bouncebuf,
	    cookie->id_bouncebuflen);
	_bus_dmamem_free(t, cookie->id_bouncesegs,
	    cookie->id_nbouncesegs);
	cookie->id_bouncebuflen = 0;
	cookie->id_nbouncesegs = 0;
	cookie->id_flags &= ~ID_HAS_BOUNCE;
}
#endif /* NISADMA > 0 */
@


1.82
log
@free(x, 0) cleanup:
  - set size argument of free()
  - remove pointless if expression around free() call

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.81 2015/09/01 06:01:26 deraadt Exp $	*/
d459 3
a461 3
 	if (mp_busses != NULL) {
 		int mpspec_pin = irq;
 		int airq;
d466 7
a472 7
 		for (mip = mp_isa_bus->mb_intrs; mip != NULL;
 		    mip = mip->next) {
 			if (mip->bus_pin == mpspec_pin) {
 				airq = mip->ioapic_ih | irq;
 				break;
 			}
 		}
@


1.81
log
@fairly simple sizes for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.80 2015/07/13 17:45:01 mikeb Exp $	*/
d718 1
a718 2
		if (map->_dm_cookie != NULL)
			free(map->_dm_cookie, M_DEVBUF, 0);
@


1.80
log
@remove unused isa_nodefaultirq;  ok kettenis, mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.79 2015/01/24 15:13:55 kettenis Exp $	*/
d507 1
a507 1
		free(ih, M_DEVBUF, 0);
d525 1
a525 1
			free(ih, M_DEVBUF, 0);
d595 1
a595 1
	free(ih, M_DEVBUF, 0);
@


1.79
log
@Add bus_dmamem_alloc_range(9) to allow drivers to allocate DMA'able memory
within a range that is more (or less) restrictive than the default range.

ok deraadt@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.78 2014/12/22 03:14:59 deraadt Exp $	*/
a199 10
}

void
isa_nodefaultirq(void)
{
	int i;

	/* icu vectors */
	for (i = 0; i < ICU_LEN; i++)
		unsetgate(&idt[ICU_OFFSET + i]);
@


1.78
log
@bcopy -> memcpy, as in amd64
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.77 2014/07/13 21:51:12 kettenis Exp $	*/
d151 1
d943 1
a943 1
	    segs, nsegs, rsegs, flags, (paddr_t)0, (paddr_t)-1);
@


1.77
log
@The correct place to call _bus_dmamap_sync() is after we copy data *to* the
bounce buffer and before we copy data *from* the bounce buffer.  Currently
_bus_dmamap_sync() is a no-op, but keeping it #ifdef'ed out in the wrong
place makes no sense.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.76 2014/07/12 18:44:42 tedu Exp $	*/
d907 2
a908 3
			bcopy((char *)cookie->id_origbuf + offset,
			    cookie->id_bouncebuf + offset,
			    len);
d919 2
a920 3
			bcopy((char *)cookie->id_bouncebuf + offset,
			    cookie->id_origbuf + offset,
			    len);
@


1.76
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.75 2013/07/14 18:22:08 kettenis Exp $	*/
d910 5
a914 1
	} else if (op & BUS_DMASYNC_POSTREAD) {
a923 5

#if 0
	/* This is a noop anyhow, so why bother calling it? */
	_bus_dmamap_sync(t, map, op);
#endif
@


1.75
log
@IPL_VM is "mpsafe" now as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.74 2013/07/10 21:31:12 kettenis Exp $	*/
d516 1
a516 1
		free(ih, M_DEVBUF);
d534 1
a534 1
			free(ih, M_DEVBUF);
d604 1
a604 1
	free(ih, M_DEVBUF);
d728 1
a728 1
			free(map->_dm_cookie, M_DEVBUF);
d748 1
a748 1
	free(cookie, M_DEVBUF);
@


1.74
log
@To prevent lock ordering problems with the kernel lock, we need to make sure
we block all interrupts that can grab the kernel lock.  The simplest way to
achieve this is to make sure mutexes always raise the ipl to the highest
level that has interrupts that grab the kernel lock.  This will allow us
to have "mpsafe" interrupt handlers at lower priority levels.

No change for non-MULTIPROCESSOR kernels.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.73 2013/05/16 19:26:04 kettenis Exp $	*/
d504 1
a504 1
	KASSERT(level <= IPL_VM || level >= IPL_CLOCK || flags & IPL_MPSAFE);
@


1.73
log
@Implement a mechanism to establish interrupt handlers that don't grab the
kernel lock upon entry through a new IPL_MPSAFE flag/level.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.72 2011/04/16 00:40:58 deraadt Exp $	*/
d503 2
@


1.72
log
@More than a decade ago, interrupt handlers on sparc started returning 0
(interrupt was not for me), 1 (positive interrupt was for me), or -1
(i am not sure...).  We have continued with this practice in as many
drivers as possible, throughout the tree.

This makes some of the architectures use that information in their
interrupt handler calling code -- if 1 is returned (and we know
this specific machine does not have edge-shared interrupts), we
finish servicing other possible handlers on the same pin.  If the
interrupt pin remains asserted (from a different device), we will
end up back in the interrupt servicing code of course... but this is
cheaper than calling all the chained interrupts on a pin.

This does of course count on shared level interrupts being properly
sorted by IPL.

There have been some concerns about starvation of drivers which
incorrectly return 1.  Those drivers should be hunted down so that
they return -1.

ok and help from various people.  In snaps for about a week now.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.71 2010/11/20 20:58:51 miod Exp $	*/
d463 1
d500 4
d563 1
@


1.71
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.70 2010/09/20 06:33:47 matthew Exp $	*/
d517 2
@


1.70
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.69 2010/03/25 22:44:57 oga Exp $	*/
d669 1
a669 1
	 * but bounce buffer, and the DMA happens from those
@


1.69
log
@Make the i386 and amd64 bus_dma functions for isa less stupid:

1) when you have a wrapper function in a dmatag that just calls the
_bus_dmamem original, you don't need it, just put the original function
in the tag

2) don't trunc_page the avail_end/ISA_BOUNCE_THRESHOLD stuff (see icb
for a discussion of why this is wrong about 00:00 gmt). make i386 and
amd64 both do this the same (the amd64 way is cleaner and makes the
third diff actually possible without a lot of pain). just do
dmamem_alloc_range(0, threshold) and if that fails do a alloc_range(0,
-1) and assume we'll bounce to pick up the pieces. Also using avail_end
for alloc_range is not nice (miod has been trying to avoid these abuses
iirc), so just use (paddr_t)-1, which is equivalent since you want "any"
memory.

3) now this is the funny one. consider point 2. then considering why
using the same bloody function to allocate your bouncebuffer is just
f'ing wrong. instead allocate with alloc_range(0, threshold) to make
sure that our bouncebuffer is actually uner 16megs.

ok deraadt@@, kettenis@@. Tested by several people.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.68 2009/08/22 02:54:50 mk Exp $	*/
d557 1
a557 2
	evcount_attach(&ih->ih_count, ih_what, (void *)&ih->ih_irq,
	    &evcount_intr);
@


1.68
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.67 2009/03/10 15:03:17 oga Exp $	*/
a127 7
void	_isa_bus_dmamem_free(bus_dma_tag_t,
	    bus_dma_segment_t *, int);
int	_isa_bus_dmamem_map(bus_dma_tag_t, bus_dma_segment_t *,
	    int, size_t, caddr_t *, int);
void	_isa_bus_dmamem_unmap(bus_dma_tag_t, caddr_t, size_t);
paddr_t	_isa_bus_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t *,
	    int, off_t, int, int);
d151 4
a154 4
	_isa_bus_dmamem_free,
	_isa_bus_dmamem_map,
	_isa_bus_dmamem_unmap,
	_isa_bus_dmamem_mmap,
d926 1
a926 1
	paddr_t high;
d928 5
a932 4
	if (avail_end > ISA_DMA_BOUNCE_THRESHOLD)
		high = trunc_page(ISA_DMA_BOUNCE_THRESHOLD);
	else
		high = trunc_page(avail_end);
d934 4
a937 23
	return (_bus_dmamem_alloc_range(t, size, alignment, boundary,
	    segs, nsegs, rsegs, flags, 0, high));
}

/*
 * Free memory safe for ISA DMA.
 */
void
_isa_bus_dmamem_free(bus_dma_tag_t t, bus_dma_segment_t *segs, int nsegs)
{

	_bus_dmamem_free(t, segs, nsegs);
}

/*
 * Map ISA DMA-safe memory into kernel virtual address space.
 */
int
_isa_bus_dmamem_map(bus_dma_tag_t t, bus_dma_segment_t *segs, int nsegs,
    size_t size, caddr_t *kvap, int flags)
{

	return (_bus_dmamem_map(t, segs, nsegs, size, kvap, flags));
a939 20
/*
 * Unmap ISA DMA-safe memory from kernel virtual address space.
 */
void
_isa_bus_dmamem_unmap(bus_dma_tag_t t, caddr_t kva, size_t size)
{

	_bus_dmamem_unmap(t, kva, size);
}

/*
 * mmap(2) ISA DMA-safe memory.
 */
paddr_t
_isa_bus_dmamem_mmap(bus_dma_tag_t t, bus_dma_segment_t *segs, int nsegs,
    off_t off, int prot, int flags)
{

	return (_bus_dmamem_mmap(t, segs, nsegs, off, prot, flags));
}
d1013 1
a1013 1
	error = _isa_bus_dmamem_alloc(t, cookie->id_bouncebuflen,
d1015 2
a1016 1
	    map->_dm_segcnt, &cookie->id_nbouncesegs, flags);
d1019 1
a1019 1
	error = _isa_bus_dmamem_map(t, cookie->id_bouncesegs,
d1025 1
a1025 1
		_isa_bus_dmamem_free(t, cookie->id_bouncesegs,
d1044 1
a1044 1
	_isa_bus_dmamem_unmap(t, cookie->id_bouncebuf,
d1046 1
a1046 1
	_isa_bus_dmamem_free(t, cookie->id_bouncesegs,
@


1.67
log
@remove the _BUS_DMA_PRIVATE define from amd64 and i386.

a define needed to get to ``private'' functions that needs to be defined
5 or more times isn't much use and may cause namespace issues anyway.
Other archs will probably follow.

Discussed in portugal.  "Hell yes" weingart@@, ok kettenis@@, no
objections miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.66 2008/12/11 17:07:14 oga Exp $	*/
d466 1
a466 1
    int (*ih_fun)(void *), void *ih_arg, char *ih_what)
@


1.66
log
@Kill the $ARCH prefix for isa_dma_cookie. With this change, the i386 and
amd64 isa dma code is identical save for some formatting, and a slight
difference in bus_dmamem_alloc.

"Die x86_!" krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.65 2008/12/10 20:26:56 oga Exp $	*/
a85 1
#define _BUS_DMA_PRIVATE
@


1.65
log
@both x86 platforms isa bus_dma implementations handle bus_dmamap_sync
incorrectly.

The spec (manpage) states that using two PRE or two POST ops together is
entirely valid, but mixing pre and post is invalid. The way this was
handled before with a switch statement meant that only individual
commands actually would be recognised, so move to just checking the
commands indidually using "if (op & $command)". Additionally, add a
DIAGNOSTIC check and panic for the mixing of pre and post operations
(this is done on several other architectures already).

tested by several people; thanks!

ok dlg@@, kettenis@@, "the diff made sense" deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.64 2008/12/03 15:46:06 oga Exp $	*/
d654 1
a654 1
	struct i386_isa_dma_cookie *cookie;
d669 1
a669 1
	cookiesize = sizeof(struct i386_isa_dma_cookie);
d709 1
a709 1
	cookie = (struct i386_isa_dma_cookie *)cookiestore;
d739 1
a739 1
	struct i386_isa_dma_cookie *cookie = map->_dm_cookie;
d758 1
a758 1
	struct i386_isa_dma_cookie *cookie = map->_dm_cookie;
d858 1
a858 1
	struct i386_isa_dma_cookie *cookie = map->_dm_cookie;
d883 1
a883 1
	struct i386_isa_dma_cookie *cookie = map->_dm_cookie;
d1055 1
a1055 1
	struct i386_isa_dma_cookie *cookie = map->_dm_cookie;
d1085 1
a1085 1
	struct i386_isa_dma_cookie *cookie = map->_dm_cookie;
@


1.64
log
@Remove the x86 and i386 prefixes to the bus_dma types. It's really quite
pointless and just makes the code different for no reason. This moves i386 and
amd64 bus_dma to being a lot closer to identical.

suggestion to just remove the prefix instead of merge them from deraadt@@.

no objections art@@, kettenis@@, ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.63 2008/06/26 05:42:11 ray Exp $	*/
d893 5
d899 2
a900 8
	switch (op) {
	case BUS_DMASYNC_PREREAD:
		/*
		 * Nothing to do for pre-read.
		 */
		break;

	case BUS_DMASYNC_PREWRITE:
d909 1
a909 3
		break;

	case BUS_DMASYNC_POSTREAD:
a917 7
		break;

	case BUS_DMASYNC_POSTWRITE:
		/*
		 * Nothing to do for post-write.
		 */
		break;
@


1.63
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.62 2008/04/26 14:33:27 kettenis Exp $	*/
d86 1
a86 1
#define _I386_BUS_DMA_PRIVATE
d148 1
a148 1
struct i386_bus_dma_tag isa_bus_dma_tag = {
@


1.62
log
@Remove softast; it's no longer used.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.61 2007/09/07 15:00:19 art Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.61
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.60 2007/04/28 03:55:40 jsg Exp $	*/
a298 1
	IMASK(IPL_SOFTAST) |= 1 << SIR_AST;
@


1.60
log
@Remove a duplicate copyright statement.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.59 2007/04/12 20:22:58 art Exp $	*/
d713 1
a713 1
	    (flags & BUS_DMA_NOWAIT) ? M_NOWAIT : M_WAITOK)) == NULL) {
a716 1
	bzero(cookiestore, cookiesize);
@


1.59
log
@Faster signal delivery on i386/MP.

We need to poke the other CPU so that it processes the AST immediately
and doesn't wait for the next interrupt or syscall.

Since IPIs really shouldn't process ASTs, we need to trigger a soft
interrupt on the destination CPU to process the AST. But since we can't
send soft interrupts to other CPUs, we send an IPI, that triggers a soft
interrupt that in turn processes the AST.

Also, this marks the beginning of moving to slightly better IPI mechanism
of short and optimized IPIs instead of the large and complicated IPI
infrastructure we're using now.

tested by many, ok tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.58 2007/03/22 19:31:59 miod Exp $	*/
a2 37

/*-
 * Copyright (c) 1996, 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
@


1.58
log
@Do not define ISA_DMA_STATS by default; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.57 2006/12/29 13:04:37 pedro Exp $	*/
d336 1
@


1.57
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.56 2006/11/11 21:47:52 kettenis Exp $	*/
a2 2

#define ISA_DMA_STATS
@


1.56
log
@Get rid of magic isa and eisa bus numbers in mpbios code.  Pave the way for
alternative sources for interrupt information.

ok gwk@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.55 2006/09/19 11:06:33 jsg Exp $	*/
d954 1
a954 1
			bcopy(cookie->id_origbuf + offset,
d965 1
a965 1
			bcopy(cookie->id_bouncebuf + offset,
@


1.55
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.54 2005/11/24 08:37:08 mickey Exp $	*/
a522 1
 		int bus = mp_isa_bus;
d525 4
a528 1
 		for (mip = mp_busses[bus].mb_intrs; mip != NULL; 
d535 3
a537 3
		if (mip == NULL && mp_eisa_bus != -1) {
			for (mip = mp_busses[mp_eisa_bus].mb_intrs;
			    mip != NULL; mip=mip->next) {
d547 1
a547 1
			airq = mpbios_invent(irq, type, mp_isa_bus);
@


1.54
log
@repair indent that cvs has scrwed make it extra confusing
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.53 2005/11/23 09:32:46 mickey Exp $	*/
d217 1
a217 1
isa_defaultirq()
d256 1
a256 1
isa_nodefaultirq()
d270 1
a270 1
isa_nmi()
d283 1
a283 2
isa_strayintr(irq)
	int irq;
d310 1
a310 1
intr_calculatemasks()
d409 1
a409 5
isa_intr_alloc(ic, mask, type, irq)
	isa_chipset_tag_t ic;
	int mask;
	int type;
	int *irq;
d485 1
a485 4
isa_intr_check(ic, irq, type)
	isa_chipset_tag_t ic;	/* Not used. */
	int irq;
	int type;
d512 2
a513 8
isa_intr_establish(ic, irq, type, level, ih_fun, ih_arg, ih_what)
	isa_chipset_tag_t ic;
	int irq;
	int type;
	int level;
	int (*ih_fun)(void *);
	void *ih_arg;
	char *ih_what;
d620 1
a620 3
isa_intr_disestablish(ic, arg)
	isa_chipset_tag_t ic;
	void *arg;
d656 2
a657 3
isa_attach_hook(parent, self, iba)
	struct device *parent, *self;
	struct isabus_attach_args *iba;
d695 2
a696 8
_isa_bus_dmamap_create(t, size, nsegments, maxsegsz, boundary, flags, dmamp)
	bus_dma_tag_t t;
	bus_size_t size;
	int nsegments;
	bus_size_t maxsegsz;
	bus_size_t boundary;
	int flags;
	bus_dmamap_t *dmamp;
d782 1
a782 3
_isa_bus_dmamap_destroy(t, map)
	bus_dma_tag_t t;
	bus_dmamap_t map;
d800 2
a801 7
_isa_bus_dmamap_load(t, map, buf, buflen, p, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map; 
	void *buf;
	bus_size_t buflen;
	struct proc *p;
	int flags;
d867 2
a868 5
_isa_bus_dmamap_load_mbuf(t, map, m, flags)  
	bus_dma_tag_t t;
	bus_dmamap_t map;
	struct mbuf *m;
	int flags;
d878 2
a879 5
_isa_bus_dmamap_load_uio(t, map, uio, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	struct uio *uio;
	int flags;
d890 2
a891 7
_isa_bus_dmamap_load_raw(t, map, segs, nsegs, size, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	bus_dma_segment_t *segs;
	int nsegs;
	bus_size_t size;
	int flags;
d901 1
a901 3
_isa_bus_dmamap_unload(t, map)
	bus_dma_tag_t t;
	bus_dmamap_t map;
d925 2
a926 6
_isa_bus_dmamap_sync(t, map, offset, len, op)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	bus_addr_t offset;
	bus_size_t len;
	int op;
d985 3
a987 7
_isa_bus_dmamem_alloc(t, size, alignment, boundary, segs, nsegs, rsegs, flags)
	bus_dma_tag_t t;
	bus_size_t size, alignment, boundary;
	bus_dma_segment_t *segs;
	int nsegs;
	int *rsegs;
	int flags;
d1004 1
a1004 4
_isa_bus_dmamem_free(t, segs, nsegs)
	bus_dma_tag_t t;
	bus_dma_segment_t *segs;
	int nsegs;
d1014 2
a1015 7
_isa_bus_dmamem_map(t, segs, nsegs, size, kvap, flags)
	bus_dma_tag_t t;
	bus_dma_segment_t *segs;
	int nsegs;
	size_t size;
	caddr_t *kvap;
	int flags;
d1025 1
a1025 4
_isa_bus_dmamem_unmap(t, kva, size)
	bus_dma_tag_t t;
	caddr_t kva;
	size_t size;
d1035 2
a1036 6
_isa_bus_dmamem_mmap(t, segs, nsegs, off, prot, flags)
	bus_dma_tag_t t;
	bus_dma_segment_t *segs;
	int nsegs;
	off_t off;
	int prot, flags;
d1051 2
a1052 6
_isa_dma_check_buffer(buf, buflen, segcnt, boundary, p)
	void *buf;
	bus_size_t buflen;
	int segcnt;
	bus_size_t boundary;
	struct proc *p;
d1108 1
a1108 5
_isa_dma_alloc_bouncebuf(t, map, size, flags)
	bus_dma_tag_t t;
	bus_dmamap_t map;
	bus_size_t size;
	int flags;
d1138 1
a1138 3
_isa_dma_free_bouncebuf(t, map)
	bus_dma_tag_t t;
	bus_dmamap_t map;
@


1.53
log
@prioritise <16m memory for isa bus_dma'ble memorble memory allocations
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.52 2005/11/23 09:24:54 mickey Exp $	*/
d561 2
a562 2
			return (apic_intr_establish(airq, type, level, ih_fun,
			    ih_arg, ih_what));
@


1.52
log
@resolve a couple of problems in mpbios-mapped interrupts:
- synthesise isa mappings (as 1-1) should those be missing in mpbios;
- for rcc osb* firce "special" ints into isa mappings always.
niklas@@ ok and testing by many since
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.51 2004/11/29 20:15:40 pat Exp $	*/
a145 5

/*
 * ISA can only DMA to 0-16M.
 */
#define	ISA_DMA_BOUNCE_THRESHOLD	0x00ffffff
@


1.51
log
@plug memory leaks on error

ok canacar markus millert
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.50 2004/06/28 01:41:53 aaron Exp $	*/
d561 2
d564 2
a565 2
			printf("isa_intr_establish: no MP mapping found\n");
 		else
@


1.50
log
@Use new event counter API for interrupt counting on i386.  deraadt@@ tholo@@
drahn@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.49 2004/06/13 21:49:16 niklas Exp $	*/
d578 1
d594 1
@


1.49
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a620 1
	ih->ih_count = 0;
d624 2
a625 1
	ih->ih_what = ih_what;
d663 1
@


1.48
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.47 2003/01/16 04:17:10 art Exp $	*/
d125 7
d138 1
a143 1
#include <i386/isa/icu.h>
d260 10
d306 3
d318 1
a318 1
	int irq, level;
d322 1
d324 1
a324 1
		register int levels = 0;
d328 2
d334 1
a334 1
		register int irqs = 0;
d338 1
a338 1
		imask[level] = irqs;
d357 1
a357 1
		register int irqs = 1 << irq;
d361 12
a372 6
		for (q = intrhand[irq]; q; q = q->ih_next) {
			irqs |= IMASK(q->ih_level);
			if (minlevel == IPL_NONE || q->ih_level < minlevel)
				minlevel = q->ih_level;
			if (q->ih_level > maxlevel)
				maxlevel = q->ih_level;
d374 4
d381 5
d390 1
a390 1
		register int irqs = 0;
d537 31
d573 1
a573 1
		return NULL;
d577 2
a578 2
		printf("%s: intr_establish: bogus irq or type\n", ih_what);
		return NULL;
d593 1
a593 1
			return NULL;
d643 7
d651 1
a651 1
		panic("intr_disestablish: bogus irq");
@


1.47
log
@getting rid of vm_offset_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.46 2002/06/10 22:27:33 niklas Exp $	*/
d97 1
a97 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.46
log
@old bouncebuffering api not used anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.45 2002/03/14 01:26:33 millert Exp $	*/
d149 1
a149 1
extern	vm_offset_t avail_end;
d968 1
a968 1
	vm_offset_t high;
d1052 3
a1054 2
	vm_offset_t vaddr = (vm_offset_t)buf;
	vm_offset_t pa, lastpa, endva;
d1073 1
a1073 1
		pmap_extract(pmap, (vm_offset_t)vaddr, &pa);
@


1.45
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.44 2001/12/06 21:09:13 niklas Exp $	*/
a1154 102

#ifdef __ISADMA_COMPAT
/*
 * setup (addr, nbytes) for an ISA dma transfer.
 * flags&ISADMA_MAP_WAITOK	may wait
 * flags&ISADMA_MAP_BOUNCE	may use a bounce buffer if necessary
 * flags&ISADMA_MAP_CONTIG	result must be physically contiguous
 * flags&ISADMA_MAP_8BIT	must not cross 64k boundary
 * flags&ISADMA_MAP_16BIT	must not cross 128k boundary
 *
 * returns the number of used phys entries, 0 on failure.
 * if flags&ISADMA_MAP_CONTIG result is 1 on sucess!
 */
int
isadma_map(addr, nbytes, phys, flags)
	caddr_t addr;
	vm_size_t nbytes;
	struct isadma_seg *phys;
	int flags;
{
	bus_dma_tag_t dmat = ((struct isa_softc *)isa_dev)->sc_dmat;
	bus_dmamap_t dmam;
	int i;

/* XXX if this turns out to be too low, convert the driver to real bus_dma */
#define ISADMA_MAX_SEGMENTS 64
#define ISADMA_MAX_SEGSZ 0xffffff

	if (bus_dmamap_create(dmat, nbytes,
	    (flags & ISADMA_MAP_CONTIG) ? 1 : ISADMA_MAX_SEGMENTS,
	    ISADMA_MAX_SEGSZ,
	    (flags & ISADMA_MAP_8BIT) ? 0xffff :
	    ((flags & ISADMA_MAP_16BIT) ? 0x1ffff : 0),
	    (flags & ISADMA_MAP_WAITOK) ? BUS_DMA_WAITOK : BUS_DMA_NOWAIT,
	    &dmam) != 0)
		return (0);
	if (bus_dmamap_load(dmat, dmam, addr, nbytes, 0,
	    (flags & ISADMA_MAP_WAITOK) ? BUS_DMA_WAITOK : BUS_DMA_NOWAIT) !=
	     0) {
		bus_dmamap_destroy(dmat, dmam);
		return (0);
	}
	for (i = 0; i < dmam->dm_nsegs; i++) {
		phys[i].addr = dmam->dm_segs[i].ds_addr;
		phys[i].length = dmam->dm_segs[i].ds_len;
	}
	phys[0].dmam = dmam;
	return (dmam->dm_nsegs);
}

/*
 * undo a ISA dma mapping. Simply return the bounced segments to the pool.
 */
void
isadma_unmap(addr, nbytes, nphys, phys)
	caddr_t addr;
	vm_size_t nbytes;
	int nphys;
	struct isadma_seg *phys;
{
	bus_dma_tag_t dmat = ((struct isa_softc *)isa_dev)->sc_dmat;
	bus_dmamap_t dmam = phys[0].dmam;

	if (dmam == NULL)
		return;
	bus_dmamap_unload(dmat, dmam);
	bus_dmamap_destroy(dmat, dmam);
	phys[0].dmam = NULL;
}

/*
 * copy bounce buffer to buffer where needed
 */
void
isadma_copyfrombuf(addr, nbytes, nphys, phys)
	caddr_t addr;
	vm_size_t nbytes;
	int nphys;
	struct isadma_seg *phys;
{
	bus_dma_tag_t dmat = ((struct isa_softc *)isa_dev)->sc_dmat;
	bus_dmamap_t dmam = phys[0].dmam;

	bus_dmamap_sync(dmat, dmam, 0, dmam->dm_mapsize, BUS_DMASYNC_POSTREAD);
}

/*
 * copy buffer to bounce buffer where needed
 */
void
isadma_copytobuf(addr, nbytes, nphys, phys)
	caddr_t addr;
	vm_size_t nbytes;
	int nphys;
	struct isadma_seg *phys;
{
	bus_dma_tag_t dmat = ((struct isa_softc *)isa_dev)->sc_dmat;
	bus_dmamap_t dmam = phys[0].dmam;

	bus_dmamap_sync(dmat, dmam, 0, dmam->dm_mapsize, BUS_DMASYNC_PREWRITE);
}
#endif /* __ISADMA_COMPAT */
@


1.44
log
@Shave never used fastvec code
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.43 2001/12/04 00:00:36 niklas Exp $	*/
d153 1
a153 1
typedef int (*vector) __P((void));
d155 3
a157 3
void isa_strayintr __P((int));
void intr_calculatemasks __P((void));
int fakeintr __P((void *));
d160 30
a189 30
int	_isa_bus_dmamap_create __P((bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *));
void	_isa_bus_dmamap_destroy __P((bus_dma_tag_t, bus_dmamap_t));
int	_isa_bus_dmamap_load __P((bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int));
int	_isa_bus_dmamap_load_mbuf __P((bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int));
int	_isa_bus_dmamap_load_uio __P((bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int));
int	_isa_bus_dmamap_load_raw __P((bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int));
void	_isa_bus_dmamap_unload __P((bus_dma_tag_t, bus_dmamap_t));
void	_isa_bus_dmamap_sync __P((bus_dma_tag_t, bus_dmamap_t,
	    bus_addr_t, bus_size_t, int));

int	_isa_bus_dmamem_alloc __P((bus_dma_tag_t, bus_size_t, bus_size_t,
	    bus_size_t, bus_dma_segment_t *, int, int *, int));
void	_isa_bus_dmamem_free __P((bus_dma_tag_t,
	    bus_dma_segment_t *, int));
int	_isa_bus_dmamem_map __P((bus_dma_tag_t, bus_dma_segment_t *,
	    int, size_t, caddr_t *, int));
void	_isa_bus_dmamem_unmap __P((bus_dma_tag_t, caddr_t, size_t));
paddr_t	_isa_bus_dmamem_mmap __P((bus_dma_tag_t, bus_dma_segment_t *,
	    int, off_t, int, int));

int	_isa_dma_check_buffer __P((void *, bus_size_t, int, bus_size_t,
	    struct proc *));
int	_isa_dma_alloc_bouncebuf __P((bus_dma_tag_t, bus_dmamap_t,
	    bus_size_t, int));
void	_isa_dma_free_bouncebuf __P((bus_dma_tag_t, bus_dmamap_t));
d496 1
a496 1
	int (*ih_fun) __P((void *));
@


1.44.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.44 2001/12/06 21:09:13 niklas Exp $	*/
d153 1
a153 1
typedef int (*vector)(void);
d155 3
a157 3
void isa_strayintr(int);
void intr_calculatemasks(void);
int fakeintr(void *);
d160 30
a189 30
int	_isa_bus_dmamap_create(bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *);
void	_isa_bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	_isa_bus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	_isa_bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
int	_isa_bus_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
int	_isa_bus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	_isa_bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_isa_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t,
	    bus_addr_t, bus_size_t, int);

int	_isa_bus_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t,
	    bus_size_t, bus_dma_segment_t *, int, int *, int);
void	_isa_bus_dmamem_free(bus_dma_tag_t,
	    bus_dma_segment_t *, int);
int	_isa_bus_dmamem_map(bus_dma_tag_t, bus_dma_segment_t *,
	    int, size_t, caddr_t *, int);
void	_isa_bus_dmamem_unmap(bus_dma_tag_t, caddr_t, size_t);
paddr_t	_isa_bus_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t *,
	    int, off_t, int, int);

int	_isa_dma_check_buffer(void *, bus_size_t, int, bus_size_t,
	    struct proc *);
int	_isa_dma_alloc_bouncebuf(bus_dma_tag_t, bus_dmamap_t,
	    bus_size_t, int);
void	_isa_dma_free_bouncebuf(bus_dma_tag_t, bus_dmamap_t);
d496 1
a496 1
	int (*ih_fun)(void *);
@


1.44.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.44.2.1 2002/06/11 03:35:54 art Exp $	*/
d1155 102
@


1.44.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d149 1
a149 1
extern	paddr_t avail_end;
d968 1
a968 1
	paddr_t high;
d1052 2
a1053 3
	vaddr_t vaddr = (vaddr_t)buf;
	vaddr_t endva;
	paddr_t pa, lastpa;
d1072 1
a1072 1
		pmap_extract(pmap, (vaddr_t)vaddr, &pa);
@


1.43
log
@New try at a level based irq system.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.41 2001/11/12 20:28:20 niklas Exp $	*/
d154 1
a154 1
extern vector IDTVEC(intr)[], IDTVEC(fast)[];
a288 1
int fastvec;
@


1.42
log
@Revert niklas's broken ICU interrupt handling changes; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.40 2001/11/06 19:53:14 miod Exp $	*/
d132 1
d225 2
a226 2
		setgate(&idt[ICU_OFFSET + i], IDTVEC(intr)[i], 0, SDT_SYS386IGT,
		    SEL_KPL, GICODE_SEL);
a263 1

d269 2
a270 1
u_long	intrstray[ICU_LEN] = {0};
d291 1
d310 1
a310 1
			levels |= 1 << q->ih_level;
d315 1
a315 1
	for (level = 0; level < 5; level++) {
d320 1
a320 1
		imask[level] = irqs | SIR_ALLMASK;
d324 1
a324 2
	 * There are tty, network and disk drivers that use free() at interrupt
	 * time, so imp > (tty | net | bio).
d326 3
a328 2
	imask[IPL_IMP] |= imask[IPL_TTY] | imask[IPL_NET] | imask[IPL_BIO];
	imask[IPL_AUDIO] |= imask[IPL_IMP];
d334 2
a335 8
	imask[IPL_TTY] |= imask[IPL_NET] | imask[IPL_BIO];
	imask[IPL_NET] |= imask[IPL_BIO];

	/*
	 * These are pseudo-levels.
	 */
	imask[IPL_NONE] = 0x00000000;
	imask[IPL_HIGH] = 0xffffffff;
d340 13
a352 3
		for (q = intrhand[irq]; q; q = q->ih_next)
			irqs |= imask[q->ih_level];
		intrmask[irq] = irqs | SIR_ALLMASK;
d366 4
a375 1

@


1.41
log
@Redo the ICU interrupt handling system to better emulate an APIC system.
This is done by representing the current blockings of interrupts with
a priority level instead of an interrupt mask.  This makes it possible to
share implementations for spl* functions/macros between both ICU
and APIC (a must when going MP) systems.  In this process, assign
soft interrupts their own levels to match the way things will be on
APIC systems where they actually will be real interrupts and not just
bits in a pending mask as they are now.
Heavily inspired by Bill Studenmunds SMP work in NetBSD
@
text
@a131 1
#include <machine/intr.h>
d224 2
a225 2
		setgate(&idt[ICU_OFFSET + i], IDTVEC(intr)[i], 0,
		    SDT_SYS386IGT, SEL_KPL, GICODE_SEL);
d263 1
d269 1
a269 2
u_long  intrstray[ICU_LEN];

a289 1
int ilevel[ICU_LEN];
d308 1
a308 1
			levels |= 1 << IPL(q->ih_level);
d313 1
a313 1
	for (level = 0; level < NIPL; level++) {
d318 1
a318 1
		imask[level] = irqs;
d322 2
a323 1
	 * Initialize soft interrupt masks to block themselves.
d325 2
a326 3
	IMASK(IPL_SOFTCLOCK) |= 1 << SIR_CLOCK;
	IMASK(IPL_SOFTNET) |= 1 << SIR_NET;
	IMASK(IPL_SOFTTTY) |= 1 << SIR_TTY;
d332 8
a339 2
	for (level = 0; level < NIPL - 1; level++)
		imask[level + 1] |= imask[level];
d344 3
a346 9
		int level = IPL_NONE;

		for (q = intrhand[irq]; q; q = q->ih_next) {
			irqs |= IMASK(q->ih_level);
			if (q->ih_level > level)
				level = q->ih_level;
		}
		intrmask[irq] = irqs;
		ilevel[irq] = level;
a359 4

	/* For speed of splx, provide the inverse of the interrupt masks. */
	for (irq = 0; irq < ICU_LEN; irq++)
		iunmask[irq] = ~imask[irq];
d366 1
@


1.40
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.39 2001/11/05 17:25:57 art Exp $	*/
d132 1
d225 2
a226 2
		setgate(&idt[ICU_OFFSET + i], IDTVEC(intr)[i], 0, SDT_SYS386IGT,
		    SEL_KPL, GICODE_SEL);
a263 1

d269 2
a270 1
u_long	intrstray[ICU_LEN] = {0};
d291 1
d310 1
a310 1
			levels |= 1 << q->ih_level;
d315 1
a315 1
	for (level = 0; level < 5; level++) {
d320 1
a320 1
		imask[level] = irqs | SIR_ALLMASK;
d324 1
a324 2
	 * There are tty, network and disk drivers that use free() at interrupt
	 * time, so imp > (tty | net | bio).
d326 3
a328 2
	imask[IPL_IMP] |= imask[IPL_TTY] | imask[IPL_NET] | imask[IPL_BIO];
	imask[IPL_AUDIO] |= imask[IPL_IMP];
d334 2
a335 8
	imask[IPL_TTY] |= imask[IPL_NET] | imask[IPL_BIO];
	imask[IPL_NET] |= imask[IPL_BIO];

	/*
	 * These are pseudo-levels.
	 */
	imask[IPL_NONE] = 0x00000000;
	imask[IPL_HIGH] = 0xffffffff;
d340 9
a348 3
		for (q = intrhand[irq]; q; q = q->ih_next)
			irqs |= imask[q->ih_level];
		intrmask[irq] = irqs | SIR_ALLMASK;
d362 4
a371 1

@


1.39
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.38 2001/07/30 14:15:59 art Exp $	*/
d127 1
a127 1
#include <vm/vm.h>
@


1.38
log
@Change:
int bus_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t, int, int, int, int);
to:
paddr_t bus_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t, int, int, off_t, int);

To allow mmaping offsets larger than INT_MAX. And to simply make more sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.37 2001/06/25 00:43:12 mickey Exp $	*/
d172 1
a172 1
	    bus_dmasync_op_t));
d888 1
a888 1
_isa_bus_dmamap_sync(t, map, op)
d891 3
a893 1
	bus_dmasync_op_t op;
d897 9
d919 3
a921 2
			bcopy(cookie->id_origbuf, cookie->id_bouncebuf,
			    cookie->id_origbuflen);
d930 3
a932 2
			bcopy(cookie->id_bouncebuf, cookie->id_origbuf,
			    cookie->id_origbuflen);
d1230 1
a1230 1
	bus_dmamap_sync(dmat, dmam, BUS_DMASYNC_POSTREAD);
d1246 1
a1246 1
	bus_dmamap_sync(dmat, dmam, BUS_DMASYNC_PREWRITE);
@


1.37
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.36 2001/06/08 08:08:55 art Exp $	*/
d181 2
a182 2
int	_isa_bus_dmamem_mmap __P((bus_dma_tag_t, bus_dma_segment_t *,
	    int, int, int, int));
d1003 1
a1003 1
int
d1007 3
a1009 1
	int nsegs, off, prot, flags;
@


1.36
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.35 2000/07/06 08:44:28 ho Exp $	*/
a493 1
	extern int cold;
@


1.35
log
@Don't include <vm/vm.h> twice. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.34 1999/07/23 13:18:04 niklas Exp $	*/
d1050 1
a1050 1
		pa = pmap_extract(pmap, (vm_offset_t)vaddr);
@


1.34
log
@From NetBSD; let i386 run audio at a high IPL
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.33 1998/12/31 09:17:52 deraadt Exp $	*/
a139 2

#include <vm/vm.h>
@


1.34.4.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.35 2000/07/06 08:44:28 ho Exp $	*/
d140 2
@


1.34.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.34.4.1 2001/04/18 16:07:52 niklas Exp $	*/
d494 1
d1050 1
a1050 1
		pmap_extract(pmap, (vm_offset_t)vaddr, &pa);
@


1.34.4.3
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.34.4.2 2001/07/04 10:16:54 niklas Exp $	*/
a128 7
#include "ioapic.h"

#if NIOAPIC > 0
#include <machine/i82093var.h>
#include <machine/mpbiosvar.h>
#endif

a494 22
#if NIOAPIC > 0
	struct mp_intr_map *mip;

 	if (mp_busses != NULL) {
 		int mpspec_pin = irq;
 		int bus = mp_isa_bus;
 		int airq;

 		for (mip = mp_busses[bus].mb_intrs; mip != NULL; 
 		     mip=mip->next) {
 			if (mip->bus_pin == mpspec_pin) {
 				airq = mip->ioapic_ih | irq;
 				break;
 			}
 		}
 		if (mip == NULL)
			printf("isa_intr_establish: no MP mapping found\n");
 		else
			return apic_intr_establish (airq, type, level, ih_fun,
 						    ih_arg);
 	}
#endif
@


1.34.4.4
log
@KNF
isa_nodefaultirq new function to undo isa_defaultirq
Add name to APIC interupt establishments a la OpenBSD
Do interrupt disestablishment for ioapic interrupts correctly.
Improve pnaic message.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d231 2
a232 2
		setgate(&idt[ICU_OFFSET + i], IDTVEC(intr)[i], 0,
		    SDT_SYS386IGT, SEL_KPL, GICODE_SEL);
a262 10
void
isa_nodefaultirq()
{
	int i;

	/* icu vectors */
	for (i = 0; i < ICU_LEN; i++)
		unsetgate(&idt[ICU_OFFSET + i]);
}

d373 1
d511 1
a511 1
 		    mip = mip->next) {
d520 2
a521 2
			return (apic_intr_establish(airq, type, level, ih_fun,
			    ih_arg, ih_what));
d529 1
a529 1
		return (NULL);
d534 1
a534 1
		return (NULL);
d549 1
a549 1
			return (NULL);
a598 7
#if NIOAPIC > 0
	if (irq & APIC_INT_VIA_APIC) {
		apic_intr_disestablish(arg);
		return;
	}
#endif

d600 1
a600 1
		panic("intr_disestablish: bogus irq %d", irq);
@


1.34.4.5
log
@Some vestiges from the old interrupt system was left; new code from NetBSD
@
text
@a306 1
int ilevel[ICU_LEN];
d325 1
a325 1
			levels |= 1 << q->ih_level >> 4;
d330 1
a330 1
	for (level = 0; level < IPL_HIGH >> 4; level++) {
d342 2
a343 3
	imask[IPL_IMP >> 4] |= imask[IPL_TTY >> 4] | imask[IPL_NET >> 4] |
	    imask[IPL_BIO >> 4];
	imask[IPL_AUDIO >> 4] |= imask[IPL_IMP >> 4];
d349 2
a350 2
	imask[IPL_TTY >> 4] |= imask[IPL_NET >> 4] | imask[IPL_BIO >> 4];
	imask[IPL_NET >> 4] |= imask[IPL_BIO >> 4];
d355 2
a356 2
	imask[IPL_NONE >> 4] = 0x00000000;
	imask[IPL_HIGH >> 4] = 0xffffffff;
a358 1
	/* And eventually calculate the complete masks. */
d360 3
a362 19
		int irqs = 1 << irq;
		int level = 0;

		if (intrhand[irq] == NULL) {
			level = IPL_HIGH;
			irqs = IMASK(IPL_HIGH);
		} else {
			for (q = intrhand[irq]; q; q = q->ih_next) {
				irqs |= IMASK(q->ih_level);
				if (q->ih_level > level)
					level = q->ih_level;
			}
		}
		if (irqs != IMASK(level))
			panic("irq %d level %x mask mismatch: %x vs %x", irq, level, irqs, IMASK(level));
		
		ilevel[irq] = level;

		/* XXX NetBSD does not have SIR_ALLMASK, why do we?  */
a363 4
#if 0
		printf("irq %d: level %x, mask 0x%x (%x)\n",
		    irq, ilevel[irq], intrmask[irq], IMASK(ilevel[irq]));
#endif
a376 2
	for (irq = 0; irq < ICU_LEN; irq++)
		iunmask[irq] = ~imask[irq];
d542 1
a542 1
		printf("%s: isa_intr_establish: bogus irq or type\n", ih_what);
@


1.34.4.6
log
@Even more code from NetBSD needed for calculating correct interrupt masks
@
text
@d319 1
a319 1
	int irq, level, unusedirqs;
a322 1
	unusedirqs = 0xffff;
d324 1
a324 1
		int levels = 0;
d326 1
a326 1
			levels |= 1 << (q->ih_level>>CPSHIFT);
a327 2
		if (levels)
			unusedirqs &= ~(1 << irq);
d331 2
a332 2
	for (level = 0; level < NIPL; level++) {
		int irqs = 0;
d336 1
a336 1
		imask[level] = irqs | unusedirqs;
d340 2
a341 1
	 * Initialize soft interrupt masks to block themselves.
d343 3
a345 13
#if 0
	IMASK(IPL_AST) |= 1 << SIR_AST;
#endif
	IMASK(IPL_SOFTCLOCK) |= 1 << SIR_CLOCK;
	IMASK(IPL_SOFTNET) |= 1 << SIR_NET;
	
#if 0
	/*
	 * IPL_NONE is used for hardware interrupts that are never blocked,
	 * and do not block anything else.
	 */
	IMASK(IPL_NONE) = 0;
#endif
d351 2
a352 8
	for (level = 0; level<(NIPL-1); level++)
		imask[level+1] |= imask[level];
	
#if 0
	IMASK(IPL_SOFTCLOCK) |= IMASK(IPL_NONE);
	IMASK(IPL_SOFTNET) |= IMASK(IPL_SOFTCLOCK);
	IMASK(IPL_BIO) |= IMASK(IPL_SOFTNET);
	IMASK(IPL_NET) |= IMASK(IPL_BIO);
d355 1
a355 2
	 * There are tty, network and disk drivers that use free() at interrupt
	 * time, so imp > (tty | net | bio).
d357 2
a358 15
	IMASK(IPL_IMP) |= IMASK(IPL_TTY);

	IMASK(IPL_AUDIO) |= IMASK(IPL_IMP);

	/*
	 * Since run queues may be manipulated by both the statclock and tty,
	 * network, and disk drivers, clock > imp.
	 */
	IMASK(IPL_CLOCK) |= IMASK(IPL_AUDIO);

	/*
	 * IPL_HIGH must block everything that can manipulate a run queue.
	 */
	IMASK(IPL_HIGH) |= IMASK(IPL_CLOCK);
#endif
d360 1
d380 3
a382 1
		intrmask[irq] = irqs;
d391 1
a391 1
		int irqs = 0;
d398 1
@


1.34.4.7
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.34.4.4 2001/07/16 21:41:13 niklas Exp $	*/
d188 2
a189 2
paddr_t	_isa_bus_dmamem_mmap __P((bus_dma_tag_t, bus_dma_segment_t *,
	    int, off_t, int, int));
d1101 1
a1101 1
paddr_t
d1105 1
a1105 3
	int nsegs;
	off_t off;
	int prot, flags;
@


1.34.4.8
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d127 1
a127 1
#include <uvm/uvm_extern.h>
a138 1
#include <machine/intr.h>
d179 1
a179 1
	    bus_addr_t, bus_size_t, int));
d280 1
d286 1
a286 2
u_long  intrstray[ICU_LEN];

d327 1
a327 1
			levels |= 1 << IPL(q->ih_level);
d345 3
d350 8
a357 1
	IMASK(IPL_SOFTTTY) |= 1 << SIR_TTY;
d363 28
a390 2
	for (level = 0; level < NIPL - 1; level++)
		imask[level + 1] |= imask[level];
d395 1
a395 1
		int level = IPL_NONE;
d408 3
a410 3
			panic("irq %d level %x mask mismatch: %x vs %x", irq,
			    level, irqs, IMASK(level));

a411 2
		ilevel[irq] = level;

d413 2
a414 2
		printf("irq %d: level %x, mask 0x%x (%x)\n", irq, ilevel[irq],
		    intrmask[irq], IMASK(ilevel[irq]));
a427 2

	/* For speed of splx, provide the inverse of the interrupt masks. */
d986 1
a986 1
_isa_bus_dmamap_sync(t, map, offset, len, op)
d989 1
a989 3
	bus_addr_t offset;
	bus_size_t len;
	int op;
a992 9
#ifdef DEBUG
	if ((op & (BUS_DMASYNC_PREWRITE|BUS_DMASYNC_POSTREAD)) != 0) {
		if (offset >= map->dm_mapsize)
			panic("_isa_bus_dmamap_sync: bad offset");
		if (len == 0 || (offset + len) > map->dm_mapsize)
			panic("_isa_bus_dmamap_sync: bad length");
	}
#endif

d1006 2
a1007 3
			bcopy(cookie->id_origbuf + offset,
			    cookie->id_bouncebuf + offset,
			    len);
d1016 2
a1017 3
			bcopy(cookie->id_bouncebuf + offset,
			    cookie->id_origbuf + offset,
			    len);
d1315 1
a1315 1
	bus_dmamap_sync(dmat, dmam, 0, dmam->dm_mapsize, BUS_DMASYNC_POSTREAD);
d1331 1
a1331 1
	bus_dmamap_sync(dmat, dmam, 0, dmam->dm_mapsize, BUS_DMASYNC_PREWRITE);
@


1.34.4.9
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.34.4.8 2001/11/13 21:00:52 niklas Exp $	*/
d308 1
a308 1
int iminlevel[ICU_LEN], imaxlevel[ICU_LEN];
d360 1
a360 2
		int minlevel = IPL_NONE;
		int maxlevel = IPL_NONE;
d363 1
a363 1
			maxlevel = IPL_HIGH;
d368 2
a369 5
				if (minlevel == IPL_NONE ||
				    q->ih_level < minlevel)
					minlevel = q->ih_level;
				if (q->ih_level > maxlevel)
					maxlevel = q->ih_level;
d372 1
a372 1
		if (irqs != IMASK(maxlevel))
d374 1
a374 1
			    maxlevel, irqs, IMASK(maxlevel));
d377 1
a377 2
		iminlevel[irq] = minlevel;
		imaxlevel[irq] = maxlevel;
d380 2
a381 2
		printf("irq %d: level %x, mask 0x%x (%x)\n", irq,
		    imaxlevel[irq], intrmask[irq], IMASK(imaxlevel[irq]));
@


1.34.4.10
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d161 1
a161 1
extern vector IDTVEC(intr)[];
d306 1
@


1.34.4.11
log
@Merge in -current from about a week ago
@
text
@d160 1
a160 1
typedef int (*vector)(void);
d162 3
a164 3
void isa_strayintr(int);
void intr_calculatemasks(void);
int fakeintr(void *);
d167 30
a196 30
int	_isa_bus_dmamap_create(bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *);
void	_isa_bus_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	_isa_bus_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	_isa_bus_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t,
	    struct mbuf *, int);
int	_isa_bus_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t,
	    struct uio *, int);
int	_isa_bus_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	_isa_bus_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_isa_bus_dmamap_sync(bus_dma_tag_t, bus_dmamap_t,
	    bus_addr_t, bus_size_t, int);

int	_isa_bus_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t,
	    bus_size_t, bus_dma_segment_t *, int, int *, int);
void	_isa_bus_dmamem_free(bus_dma_tag_t,
	    bus_dma_segment_t *, int);
int	_isa_bus_dmamem_map(bus_dma_tag_t, bus_dma_segment_t *,
	    int, size_t, caddr_t *, int);
void	_isa_bus_dmamem_unmap(bus_dma_tag_t, caddr_t, size_t);
paddr_t	_isa_bus_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t *,
	    int, off_t, int, int);

int	_isa_dma_check_buffer(void *, bus_size_t, int, bus_size_t,
	    struct proc *);
int	_isa_dma_alloc_bouncebuf(bus_dma_tag_t, bus_dmamap_t,
	    bus_size_t, int);
void	_isa_dma_free_bouncebuf(bus_dma_tag_t, bus_dmamap_t);
d530 1
a530 1
	int (*ih_fun)(void *);
@


1.34.4.12
log
@Sync the SMP branch with 3.3
@
text
@d156 1
a156 1
extern	paddr_t avail_end;
d1031 1
a1031 1
	paddr_t high;
d1115 2
a1116 3
	vaddr_t vaddr = (vaddr_t)buf;
	vaddr_t endva;
	paddr_t pa, lastpa;
d1135 1
a1135 1
		pmap_extract(pmap, (vaddr_t)vaddr, &pa);
d1218 102
@


1.34.4.13
log
@Fix splassert in the SMP branch. Remove the old 'cpl' variable. While here,
remove a bunch of commons from intr.h. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.34.4.12 2003/03/27 23:26:55 niklas Exp $	*/
a308 3

int imask[NIPL];	/* Bitmask telling what interrupts are blocked. */
int iunmask[NIPL];	/* Bitmask telling what interrupts are accepted. */
@


1.34.4.14
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.34.4.13 2003/05/25 19:24:32 ho Exp $	*/
d97 5
a101 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.34.4.15
log
@a small step towards an integrated PIC/APIC system: move isa/icu.h to
include/i8259.h, and adapt the ACK/MASK/UNMASK macros so we can
reuse the API for APICs.  From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.34.4.14 2003/06/07 11:11:37 ho Exp $	*/
a137 1
#include <machine/i8259.h>
d143 1
@


1.34.4.16
log
@Don't forget to tell the icu to unmask the interrupts after recalculating
the masks. Should solve the "press any key to continue" problem.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.34.4.15 2004/03/23 08:02:56 niklas Exp $	*/
a396 1
		SET_ICUS();
@


1.34.4.17
log
@In isa_intr_establish() search for eisa mp mappings too; from netbsd.
Ok niklas@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.34.4.16 2004/06/07 19:19:18 art Exp $	*/
a551 9
		if (mip == NULL && mp_eisa_bus != -1) {
			for (mip = mp_busses[mp_eisa_bus].mb_intrs;
			    mip != NULL; mip=mip->next) {
				if (mip->bus_pin == mpspec_pin) {
					airq = mip->ioapic_ih | irq;
					break;
				}
			}
		}
@


1.33
log
@semantic change: prefer unshared intr, settle for level shared. this will still fail in some cases
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.32 1998/12/27 00:27:16 deraadt Exp $	*/
d328 1
@


1.32
log
@new priority mechanism for pcmcia interrupt allocation, ie. "best effort"
for machines low on interrupts. work by fgsch, and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.31 1998/07/17 22:00:00 deraadt Exp $	*/
d449 3
a451 1
 * 0 = no match, 1 = ok match, 2 = great match
d469 1
a469 1
		return (2);
@


1.31
log
@make isa_intr_establish() once again not panic
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.29 1998/06/27 22:42:22 deraadt Exp $	*/
d449 1
d462 1
a463 1
	case IST_EDGE:
d467 1
d469 1
@


1.30
log
@Add and use isa_intr_check().
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.28 1998/02/22 21:35:30 niklas Exp $	*/
d494 5
a498 5
	if (ih == NULL)
		panic("isa_intr_establish: can't malloc handler info");

	if (!LEGAL_IRQ(irq) || type == IST_NONE)
		panic("intr_establish: bogus irq or type");
d500 4
d513 6
a518 4
		if (type != IST_NONE)
			panic("intr_establish: can't share %s with %s, irq %d",
			    isa_intr_typename(intrtype[irq]),
			    isa_intr_typename(type), irq);
@


1.29
log
@make isa_intr_establish not panic, but return NULL for failure
@
text
@d448 27
d494 5
a498 5
	if (ih == NULL) {
		printf("%s: isa_intr_establish: can't malloc handler info\n",
		    ih_what);
		return NULL;
	}
a499 4
	if (!LEGAL_IRQ(irq) || type == IST_NONE) {
		printf("%s: intr_establish: bogus irq or type\n", ih_what);
		return NULL;
	}
d509 4
a512 6
		if (type != IST_NONE) {
			/*printf("%s: intr_establish: can't share %s with %s, irq %d\n",
			    ih_what, isa_intr_typename(intrtype[irq]),
			    isa_intr_typename(type), irq);*/
			return NULL;
		}
@


1.28
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.27 1998/01/20 18:40:20 niklas Exp $	*/
d467 5
a471 5
	if (ih == NULL)
		panic("isa_intr_establish: can't malloc handler info");

	if (!LEGAL_IRQ(irq) || type == IST_NONE)
		panic("intr_establish: bogus irq or type");
d473 4
d486 6
a491 4
		if (type != IST_NONE)
			panic("intr_establish: can't share %s with %s, irq %d",
			    isa_intr_typename(intrtype[irq]),
			    isa_intr_typename(type), irq);
@


1.27
log
@Merge bus_dma support from NetBSD, mostly by Jason Thorpe.  Only i386 uses it
 so far, the other archs gets placeholders for now.  I wrote a compatibility
layer for OpenBSD's old isadma code so we can still use our old
driver sources.  They will however get changed to native bus_dma use,
on a case by case basis.   Oh yes, I almost forgot, I kept our notion
of isadma being a device so DMA-less ISA-busses still work
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.26 1997/12/25 12:49:04 downsj Exp $	*/
d154 1
a154 1
typedef (*vector) __P((void));
@


1.26
log
@If you're going to panic, at least print the IRQ so the user knows what to
look for in their BIOS...
@
text
@d1 41
a41 2
/*	$OpenBSD: isa_machdep.c,v 1.25 1997/12/25 06:13:04 downsj Exp $	*/
/*	$NetBSD: isa_machdep.c,v 1.14 1996/05/12 23:06:18 mycroft Exp $	*/
d129 3
d141 11
d160 54
a213 4
vm_offset_t bounce_alloc __P((vm_size_t, vm_offset_t, int));
caddr_t bounce_vaddr __P((vm_offset_t));
void bounce_free __P((vm_offset_t, vm_size_t));
void isadma_copyfrombuf __P((caddr_t, vm_size_t, int, struct isadma_seg *));
d216 1
a216 1
 * Fill in default interrupt table (in case of spuruious interrupt
d571 21
d593 1
a593 1
 * ISA DMA and bounce buffer management
d595 24
d620 1
a620 1
#define MAX_CHUNK 256		/* number of low memory segments */
d622 50
a671 1
static u_int32_t bitmap[MAX_CHUNK / 32 + 1];
d673 21
a693 3
#define set(i) (bitmap[(i) >> 5] |= (1 << (i)))
#define clr(i) (bitmap[(i) >> 5] &= ~(1 << (i)))
#define bit(i) ((bitmap[(i) >> 5] & (1 << (i))) != 0)
d695 5
a699 7
static int bit_ptr = -1;	/* last segment visited */
static int chunk_size = 0;	/* size (bytes) of one low mem segment */
static int chunk_num = 0;	/* actual number of low mem segments */
#ifdef DIAGNOSTIC
int bounce_alloc_cur = 0;
int bounce_alloc_max = 0;
#endif
d701 3
a703 2
vm_offset_t isaphysmem;		/* base address of low mem arena */
int isaphysmempgs;		/* number of pages of low mem arena */
d706 1
a706 2
 * if addr is the physical address of an allocated bounce buffer return the
 * corresponding virtual address, 0 otherwise
d708 38
d747 29
d777 9
a785 3
caddr_t
bounce_vaddr(addr)
	vm_offset_t addr;
a786 1
	int i;
d788 13
a800 5
	if (addr < vtophys(isaphysmem) ||
	    addr >= vtophys(isaphysmem + chunk_num*chunk_size) ||
	    ((i = (int)(addr-vtophys(isaphysmem))) % chunk_size) != 0 ||
	    bit(i/chunk_size))
		return(0);
d802 1
a802 1
	return((caddr_t) (isaphysmem + (addr - vtophys(isaphysmem))));
d806 2
a807 4
 * alloc a low mem segment of size nbytes. Alignment constraint is:
 *   (addr & pmask) == ((addr+size-1) & pmask)
 * if waitok, call may wait for memory to become available.
 * returns 0 on failure
d809 12
d822 34
a855 5
vm_offset_t
bounce_alloc(nbytes, pmask, waitok)
	vm_size_t nbytes;
	vm_offset_t pmask;
	int waitok;
d857 39
a895 46
	int i, l;
	vm_offset_t a, b, c, r;
	vm_size_t n;
	int nunits, opri;

	opri = splbio();

	if (bit_ptr < 0) {	/* initialize low mem arena */
		if ((chunk_size = isaphysmempgs*NBPG/MAX_CHUNK) & 1)
			chunk_size--;
		chunk_num =  (isaphysmempgs*NBPG) / chunk_size;
		for(i = 0; i < chunk_num; i++)
			set(i);
		bit_ptr = 0;
	}

	nunits = (nbytes+chunk_size-1)/chunk_size;

	/*
	 * set a=start, b=start with address constraints, c=end
	 * check if this request may ever succeed.
	 */

	a = isaphysmem;
	b = (isaphysmem + ~pmask) & pmask;
	c = isaphysmem + chunk_num*chunk_size;
	n = nunits*chunk_size;
	if (a + n >= c || (pmask != 0 && a + n >= b && b + n >= c)) {
		splx(opri);
		return(0);
	}

	for (;;) {
		i = bit_ptr;
		l = -1;
		do{
			if (bit(i) && l >= 0 && (i - l + 1) >= nunits){
				r = vtophys(isaphysmem + (i - nunits + 1)*chunk_size);
				if (((r ^ (r + nbytes - 1)) & pmask) == 0) {
					for (l = i - nunits + 1; l <= i; l++)
						clr(l);
					bit_ptr = i;
#ifdef DIAGNOSTIC
					bounce_alloc_cur += nunits*chunk_size;
					bounce_alloc_max = max(bounce_alloc_max,
							       bounce_alloc_cur);
d897 34
a930 12
					splx(opri);
					return(r);
				}
			} else if (bit(i) && l < 0)
				l = i;
			else if (!bit(i))
				l = -1;
			if (++i == chunk_num) {
				i = 0;
				l = -1;
			}
		} while(i != bit_ptr);
d932 1
a932 7
		if (waitok)
			tsleep((caddr_t) &bit_ptr, PRIBIO, "physmem", 0);
		else {
			splx(opri);
			return(0);
		}
	}
d935 2
a936 2
/* 
 * return a segent of the low mem arena to the free pool
d938 9
d948 6
d955 37
a991 3
bounce_free(addr, nbytes)
	vm_offset_t addr;
	vm_size_t nbytes;
d993 15
a1007 2
	int i, j, opri;
	vm_offset_t vaddr;
d1009 12
a1020 1
	opri = splbio();
d1022 19
a1040 2
	if ((vaddr = (vm_offset_t) bounce_vaddr(addr)) == 0)
		panic("bounce_free: bad address");
d1042 2
a1043 2
	i = (int) (vaddr - isaphysmem)/chunk_size;
	j = i + (nbytes + chunk_size - 1)/chunk_size;
d1045 9
a1053 3
#ifdef DIAGNOSTIC
	bounce_alloc_cur -= (j - i)*chunk_size;
#endif
d1055 19
a1073 5
	while (i < j) {
		if (bit(i))
			panic("bounce_free: already free");
		set(i);
		i++;
d1076 19
a1094 2
	wakeup((caddr_t) &bit_ptr);
	splx(opri);
d1097 1
a1108 1

d1116 3
a1118 12
	vm_offset_t pmask, thiskv, thisphys, nextphys;
	vm_size_t datalen;
	int seg, waitok, i;

	if (flags & ISADMA_MAP_8BIT)
		pmask = ~((64*1024) - 1);
	else if (flags & ISADMA_MAP_16BIT)
		pmask = ~((128*1024) - 1);
	else
		pmask = 0;

	waitok = (flags & ISADMA_MAP_WAITOK) != 0;
d1120 17
a1136 39
	thiskv = (vm_offset_t) addr;
	datalen = nbytes;
	thisphys = vtophys(thiskv);
	seg = 0;

	while (datalen > 0 && (seg == 0 || (flags & ISADMA_MAP_CONTIG) == 0)) {
		phys[seg].length = 0;
		phys[seg].addr = thisphys;

		nextphys = thisphys;
		while (datalen > 0 && thisphys == nextphys) {
			nextphys = trunc_page(thisphys) + NBPG;
			phys[seg].length += min(nextphys - thisphys, datalen);
			datalen -= min(nextphys - thisphys, datalen);
			thiskv = trunc_page(thiskv) + NBPG;
			if (datalen)
				thisphys = vtophys(thiskv);
		}

		if (phys[seg].addr + phys[seg].length > 0xffffff) {
			if (flags & ISADMA_MAP_CONTIG) {
				phys[seg].length = nbytes;
				datalen = 0;
			}
			if ((flags & ISADMA_MAP_BOUNCE) == 0)
				phys[seg].addr = 0;
			else
				phys[seg].addr = bounce_alloc(phys[seg].length,
							      pmask, waitok);
			if (phys[seg].addr == 0) {
				for (i = 0; i < seg; i++)
					if (bounce_vaddr(phys[i].addr))
						bounce_free(phys[i].addr,
							    phys[i].length);
				return 0;
			}
		}

		seg++;
d1138 3
a1140 10

	/* check all constraints */
	if (datalen ||
	    ((phys[0].addr ^ (phys[0].addr + phys[0].length - 1)) & pmask) != 0 ||
	    ((phys[0].addr & 1) && (flags & ISADMA_MAP_16BIT))) {
		if ((flags & ISADMA_MAP_BOUNCE) == 0)
			return 0;
		if ((phys[0].addr = bounce_alloc(nbytes, pmask, waitok)) == 0)
			return 0;
		phys[0].length = nbytes;
d1142 2
a1143 2

	return seg;
a1148 1

d1156 2
a1157 1
	int i;
d1159 5
a1163 3
	for (i = 0; i < nphys; i++)
		if (bounce_vaddr(phys[i].addr))
			bounce_free(phys[i].addr, phys[i].length);
a1168 1

d1176 2
a1177 2
	int i;
	caddr_t vaddr;
d1179 1
a1179 6
	for (i = 0; i < nphys; i++) {
		vaddr = bounce_vaddr(phys[i].addr);
		if (vaddr)
			bcopy(vaddr, addr, phys[i].length);
		addr += phys[i].length;
	}
a1184 1

d1192 2
a1193 2
	int i;
	caddr_t vaddr;
d1195 1
a1195 6
	for (i = 0; i < nphys; i++) {
		vaddr = bounce_vaddr(phys[i].addr);
		if (vaddr)
			bcopy(addr, vaddr, phys[i].length);
		addr += phys[i].length;
	}
d1197 2
@


1.25
log
@isa_has_been_seen; NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.24 1997/12/21 14:44:32 downsj Exp $	*/
d380 1
a380 1
			panic("intr_establish: can't share %s with %s",
d382 1
a382 1
			    isa_intr_typename(type));
@


1.24
log
@ISA PnP supporting code from NetBSD, and a pccom driver that supports ISA PnP.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.23 1997/12/09 03:36:42 deraadt Exp $	*/
d457 9
a465 1
	/* Nothing to do. */
@


1.23
log
@Intel P5 f00f workaround; weingart & who knows who else
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.22 1997/09/24 22:28:16 niklas Exp $	*/
d5 39
a43 1
 * Copyright (c) 1993, 1994 Charles Hannum.
d270 74
d371 3
@


1.22
log
@Revert, as we won't have enough time to test this fully before release.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.20 1997/04/17 03:44:52 tholo Exp $	*/
a64 1
extern struct gate_descriptor idt[];
@


1.21
log
@Use vm_page_alloc_memory API. Some cleanup.
@
text
@a65 3

extern vm_map_t kernel_map;

d70 5
d362 2
a363 2
int isadma_alloc_cur = 0;
int isadma_alloc_max = 0;
d366 2
a367 2
vm_offset_t isadma_mem;		/* base address (virtual) of low mem arena */
int isadma_pages;		/* number of pages of low mem arena */
d370 2
a371 1
 * called from cpu_startup to setup the bounce buffer.
a372 26
void
isadma_init()
{
	struct pglist pglist;
	vm_size_t sz;
	vm_page_t pg;
	vm_offset_t off;

	TAILQ_INIT(&pglist);

	/*
	 * Get some continuous physical memory situated below 16MB as that is
	 * the ISA DMA limit.
	 */
	isadma_pages =
	    ctob(physmem) >= 0x1000000 ? DMA_BOUNCE : DMA_BOUNCE_LOW;
	sz = isadma_pages << PGSHIFT;
	if (vm_page_alloc_memory(sz, 0, 0x1000000, 0, 0, &pglist, 1, 0))
		panic("isadma_init: no physical memory for bounce buffer");

	/*
	 * Find some space in the kernel virtual memory for our bounce buffer.
	 */
	isadma_mem = vm_map_min(kernel_map);
	if (vm_map_find(kernel_map, NULL, 0, &isadma_mem, sz, TRUE))
		panic("isadma_init: no virtual memory for bounce buffer");
a373 19
	/*
	 * Now map the physical bounce buffer into the virtual addresspace.
	 */
	for (pg = pglist.tqh_first, off = isadma_mem; pg != NULL;
	    pg = pg->pageq.tqe_next, off += PAGE_SIZE)
		pmap_enter(pmap_kernel(), off, VM_PAGE_TO_PHYS(pg),
		    VM_PROT_DEFAULT, TRUE);

	/*
	 * Finally, wire it down so it never will be paged out.
	 * XXX Is this really needed?  we have already told pmap_enter.
	 */
	vm_map_pageable(kernel_map, isadma_mem, isadma_mem + sz, FALSE);

#if 0
	printf("ISA DMA bounce buffer: pa 0x%08x va 0x%08x sz 0x%08x",
	    VM_PAGE_TO_PHYS(pglist.tqh_first), isadma_mem, sz);
#endif
}
a374 4
/*
 * if addr is the physical address of an allocated bounce buffer return the
 * corresponding virtual address, 0 otherwise
 */
d376 1
a376 1
isadma_vaddr(addr)
d381 3
a383 3
	if (addr < vtophys(isadma_mem) ||
	    addr >= vtophys(isadma_mem + chunk_num * chunk_size) ||
	    ((i = (int)(addr-vtophys(isadma_mem))) % chunk_size) != 0 ||
d385 1
a385 1
		return (0);
d387 1
a387 1
	return ((caddr_t)(isadma_mem + (addr - vtophys(isadma_mem))));
d391 1
a391 1
 * Allocate a low mem segment of size nbytes. Alignment constraint is:
d393 2
a394 2
 * If waitok, call may wait for memory to become available.
 * Returns 0 on failure.
d396 1
d398 1
a398 1
isadma_alloc(nbytes, pmask, waitok)
d411 1
a411 1
		if ((chunk_size = isadma_pages * NBPG / MAX_CHUNK) & 1)
d413 1
a413 1
		chunk_num =  (isadma_pages * NBPG) / chunk_size;
d419 1
a419 1
	nunits = (nbytes + chunk_size - 1) / chunk_size;
d426 4
a429 4
	a = isadma_mem;
	b = (isadma_mem + ~pmask) & pmask;
	c = isadma_mem + chunk_num * chunk_size;
	n = nunits * chunk_size;
d439 2
a440 3
			if (bit(i) && l >= 0 && (i - l + 1) >= nunits) {
				r = vtophys(isadma_mem +
				    (i - nunits + 1) * chunk_size);
d446 3
a448 5
					isadma_alloc_cur +=
					    nunits * chunk_size;
					isadma_alloc_max =
					    max(isadma_alloc_max,
					    isadma_alloc_cur);
d461 1
a461 1
		} while (i != bit_ptr);
d464 1
a464 1
			tsleep((caddr_t)&bit_ptr, PRIBIO, "physmem", 0);
d477 1
a477 1
isadma_free(addr, nbytes)
d486 2
a487 2
	if ((vaddr = (vm_offset_t)isadma_vaddr(addr)) == 0)
		panic("isadma_free: bad address");
d489 2
a490 2
	i = (int)(vaddr - isadma_mem) / chunk_size;
	j = i + (nbytes + chunk_size - 1) / chunk_size;
d493 1
a493 1
	isadma_alloc_cur -= (j - i) * chunk_size;
d498 1
a498 1
			panic("isadma_free: already free");
d503 1
a503 1
	wakeup((caddr_t)&bit_ptr);
d509 5
a513 5
 * flags & ISADMA_MAP_WAITOK	may wait
 * flags & ISADMA_MAP_BOUNCE	may use a bounce buffer if necessary
 * flags & ISADMA_MAP_CONTIG	result must be physically contiguous
 * flags & ISADMA_MAP_8BIT	must not cross 64k boundary
 * flags & ISADMA_MAP_16BIT	must not cross 128k boundary
d516 1
a516 1
 * if flags & ISADMA_MAP_CONTIG result is 1 on sucess!
d566 2
a567 2
				phys[seg].addr = isadma_alloc(phys[seg].length,
				    pmask, waitok);
d570 4
a573 4
					if (isadma_vaddr(phys[i].addr))
						isadma_free(phys[i].addr,
						    phys[i].length);
				return (0);
d582 2
a583 2
	    ((phys[0].addr ^ (phys[0].addr + phys[0].length - 1)) & pmask) !=
	    0 || ((phys[0].addr & 1) && (flags & ISADMA_MAP_16BIT))) {
d586 1
a586 1
		if ((phys[0].addr = isadma_alloc(nbytes, pmask, waitok)) == 0)
d608 2
a609 2
		if (isadma_vaddr(phys[i].addr))
			isadma_free(phys[i].addr, phys[i].length);
d627 1
a627 1
		vaddr = isadma_vaddr(phys[i].addr);
d649 1
a649 1
		vaddr = isadma_vaddr(phys[i].addr);
@


1.20
log
@Do interrupt time accounting by running interrupt handlers with a seperate
code segment selector (otherwise identical to the standard kernel code
selector); idea by Dave Richards <richards@@zso.dec.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.19 1997/01/04 14:05:50 niklas Exp $	*/
d66 3
a72 5
vm_offset_t bounce_alloc __P((vm_size_t, vm_offset_t, int));
caddr_t bounce_vaddr __P((vm_offset_t));
void bounce_free __P((vm_offset_t, vm_size_t));
void isadma_copyfrombuf __P((caddr_t, vm_size_t, int, struct isadma_seg *));

d360 2
a361 2
int bounce_alloc_cur = 0;
int bounce_alloc_max = 0;
d364 52
a415 2
vm_offset_t isaphysmem;		/* base address of low mem arena */
int isaphysmempgs;		/* number of pages of low mem arena */
a420 2


d422 1
a422 1
bounce_vaddr(addr)
d427 3
a429 3
	if (addr < vtophys(isaphysmem) ||
	    addr >= vtophys(isaphysmem + chunk_num*chunk_size) ||
	    ((i = (int)(addr-vtophys(isaphysmem))) % chunk_size) != 0 ||
d431 1
a431 1
		return(0);
d433 1
a433 1
	return((caddr_t) (isaphysmem + (addr - vtophys(isaphysmem))));
d437 1
a437 1
 * alloc a low mem segment of size nbytes. Alignment constraint is:
d439 2
a440 2
 * if waitok, call may wait for memory to become available.
 * returns 0 on failure
a441 1

d443 1
a443 1
bounce_alloc(nbytes, pmask, waitok)
d456 1
a456 1
		if ((chunk_size = isaphysmempgs*NBPG/MAX_CHUNK) & 1)
d458 1
a458 1
		chunk_num =  (isaphysmempgs*NBPG) / chunk_size;
d464 1
a464 1
	nunits = (nbytes+chunk_size-1)/chunk_size;
d471 4
a474 4
	a = isaphysmem;
	b = (isaphysmem + ~pmask) & pmask;
	c = isaphysmem + chunk_num*chunk_size;
	n = nunits*chunk_size;
d484 3
a486 2
			if (bit(i) && l >= 0 && (i - l + 1) >= nunits){
				r = vtophys(isaphysmem + (i - nunits + 1)*chunk_size);
d492 5
a496 3
					bounce_alloc_cur += nunits*chunk_size;
					bounce_alloc_max = max(bounce_alloc_max,
							       bounce_alloc_cur);
d509 1
a509 1
		} while(i != bit_ptr);
d512 1
a512 1
			tsleep((caddr_t) &bit_ptr, PRIBIO, "physmem", 0);
d525 1
a525 1
bounce_free(addr, nbytes)
d534 2
a535 2
	if ((vaddr = (vm_offset_t) bounce_vaddr(addr)) == 0)
		panic("bounce_free: bad address");
d537 2
a538 2
	i = (int) (vaddr - isaphysmem)/chunk_size;
	j = i + (nbytes + chunk_size - 1)/chunk_size;
d541 1
a541 1
	bounce_alloc_cur -= (j - i)*chunk_size;
d546 1
a546 1
			panic("bounce_free: already free");
d551 1
a551 1
	wakeup((caddr_t) &bit_ptr);
d557 5
a561 5
 * flags&ISADMA_MAP_WAITOK	may wait
 * flags&ISADMA_MAP_BOUNCE	may use a bounce buffer if necessary
 * flags&ISADMA_MAP_CONTIG	result must be physically contiguous
 * flags&ISADMA_MAP_8BIT	must not cross 64k boundary
 * flags&ISADMA_MAP_16BIT	must not cross 128k boundary
d564 1
a564 1
 * if flags&ISADMA_MAP_CONTIG result is 1 on sucess!
d614 2
a615 2
				phys[seg].addr = bounce_alloc(phys[seg].length,
							      pmask, waitok);
d618 4
a621 4
					if (bounce_vaddr(phys[i].addr))
						bounce_free(phys[i].addr,
							    phys[i].length);
				return 0;
d630 2
a631 2
	    ((phys[0].addr ^ (phys[0].addr + phys[0].length - 1)) & pmask) != 0 ||
	    ((phys[0].addr & 1) && (flags & ISADMA_MAP_16BIT))) {
d634 1
a634 1
		if ((phys[0].addr = bounce_alloc(nbytes, pmask, waitok)) == 0)
d656 2
a657 2
		if (bounce_vaddr(phys[i].addr))
			bounce_free(phys[i].addr, phys[i].length);
d675 1
a675 1
		vaddr = bounce_vaddr(phys[i].addr);
d697 1
a697 1
		vaddr = bounce_vaddr(phys[i].addr);
@


1.19
log
@Remove extra blank line
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.18 1996/12/12 07:44:55 deraadt Exp $	*/
d87 1
a87 1
		    SEL_KPL);
@


1.18
log
@32 bit cleanup, because this code is going to be copied by other ports soon
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.17 1996/10/16 12:46:27 deraadt Exp $	*/
a342 1

@


1.17
log
@the Wall thing, you know
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.16 1996/08/26 06:52:29 deraadt Exp $	*/
d353 1
a353 1
static unsigned long bitmap[MAX_CHUNK / 32 + 1];
@


1.16
log
@ports 61 and 70 are not a part of reality
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.15 1996/05/25 22:17:49 deraadt Exp $	*/
d48 1
d70 5
d375 2
a376 1
static caddr_t
d398 1
a398 1
static vm_offset_t
d431 1
a431 1
	if (a + n >= c || pmask != 0 && a + n >= b && b + n >= c) {
d477 1
a477 1
static void
d628 2
a629 1
		if (vaddr = bounce_vaddr(phys[i].addr))
d650 2
a651 1
		if (vaddr = bounce_vaddr(phys[i].addr))
@


1.15
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.14 1996/05/07 07:22:17 deraadt Exp $	*/
d120 2
a121 1
	log(LOG_CRIT, "NMI port 61 %x, port 70 %x\n", inb(0x61), inb(0x70));
@


1.14
log
@sync with 0504; prototype changes
@
text
@d1 2
a2 2
/*	$OpenBSD: isa_machdep.c,v 1.13 1996/04/22 20:03:07 hannken Exp $	*/
/*	$NetBSD: isa_machdep.c,v 1.13 1996/05/03 19:14:55 christos Exp $	*/
d163 1
a163 2
			if (q->ih_level != IPL_NONE)
				levels |= 1 << q->ih_level;
d189 6
d199 1
a199 2
			if (q->ih_level != IPL_NONE)
				irqs |= imask[q->ih_level];
@


1.13
log
@Update aha.c to use bounce buffers, fix typos in isadma.c, update bounce buffers
@
text
@d1 2
a2 2
/*	$OpenBSD: isa_machdep.c,v 1.12 1996/04/21 22:16:54 deraadt Exp $	*/
/*	$NetBSD: isa_machdep.c,v 1.12 1996/04/11 22:11:32 cgd Exp $	*/
d44 1
d62 1
a62 1
typedef (*vector)();
d65 3
@


1.12
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: isa_machdep.c,v 1.11 1996/04/19 05:41:52 mickey Exp $	*/
d347 4
d356 2
a357 1
 * check if addr is from our low mem arena
d360 2
a361 2
static int
bounce_isbounced(addr)
d364 1
a364 3
	return(addr >= vtophys(isaphysmem) &&
	       addr < vtophys(isaphysmem)+isaphysmempgs*NBPG);
}
d366 5
a370 3
/*
 * return the virtual address of addr. addr must be from low mem arena
 */
d372 1
a372 5
static caddr_t
bounce_to_virt(addr)
	vm_offset_t addr;
{
	return((caddr_t)(isaphysmem+(addr-vtophys(isaphysmem))));
d425 2
a426 2
				r = vtophys(isaphysmem+(i-nunits+1)*chunk_size);
				if (((r ^ (r+nbytes-1)) & pmask) == 0) {
d430 5
d471 1
a471 3
	vaddr = (vm_offset_t)bounce_to_virt(addr);
	if (vaddr < isaphysmem || vaddr >= isaphysmem+chunk_num*chunk_size ||
	    ((i = (int)(vaddr-isaphysmem)) % chunk_size) != 0)
d474 6
a479 2
	i /= chunk_size;
	j = i + (nbytes+chunk_size-1)/chunk_size;
d488 1
a488 1
	wakeup((caddr_t)&bit_ptr);
d493 1
a493 1
 * setup (addr,nbytes) for an ISA dma transfer.
d516 1
a516 1
		pmask = ~((64*1024)-1);
d518 1
a518 1
		pmask = ~((128*1024)-1);
d524 1
a524 1
	thiskv = (vm_offset_t)addr;
a529 3
		if (thisphys == 0)
			panic("isadma_map: no physical page present");

d536 2
a537 2
			phys[seg].length += min(nextphys-thisphys, datalen);
			datalen -= min(nextphys-thisphys, datalen);
d543 1
a543 1
		if (phys[seg].addr+phys[seg].length > 0xffffff) {
d551 2
a552 3
				phys[seg].addr =
				    bounce_alloc(phys[seg].length, pmask,
						 waitok);
d555 1
a555 1
					if (bounce_isbounced(phys[i].addr))
d567 1
a567 1
	    ((phys[0].addr ^ (phys[0].addr+phys[0].length-1)) & pmask) != 0 ||
d593 1
a593 1
		if (bounce_isbounced(phys[i].addr))
d609 1
d612 2
a613 4
		if (bounce_isbounced(phys[i].addr)) {
			bcopy(bounce_to_virt(phys[i].addr), addr,
			    phys[i].length);
		}
d630 1
d633 2
a634 4
		if (bounce_isbounced(phys[i].addr)) {
			bcopy(addr, bounce_to_virt(phys[i].addr),
			    phys[i].length);
		}
@


1.11
log
@Fix intrstray a bit again.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: isa_machdep.c,v 1.11 1996/02/28 01:49:35 cgd Exp $	*/
d223 2
a224 1
isa_intr_establish(irq, type, level, ih_fun, ih_arg, ih_what)
d294 2
a295 1
isa_intr_disestablish(arg)
d321 9
@


1.10
log
@Merge of NetBSD 960317
@
text
@a127 4
	static u_long strays;

	intrstray[irq]++;

d134 1
a134 1
	if (++strays <= 5)
d136 1
a136 1
		    strays >= 5 ? "; stopped logging" : "");
@


1.9
log
@Add stray interrupts counters.
@
text
@d1 2
a2 1
/*	$NetBSD: isa_machdep.c,v 1.10 1996/02/09 02:26:00 mycroft Exp $	*/
a63 29

int isamatch __P((struct device *, void *, void *));
void isaattach __P((struct device *, struct device *, void *));

struct cfdriver isacd = {
	NULL, "isa", isamatch, isaattach, DV_DULL, sizeof(struct isa_softc), 1
};

int
isamatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{

	return (1);
}

void
isaattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct isa_softc *sc = (struct isa_softc *)self;

	printf("\n");

	TAILQ_INIT(&sc->sc_subdevs);
	config_scan(isascan, self);
}
@


1.8
log
@Fix back wrong patches.
@
text
@d148 1
d157 2
@


1.7
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d252 1
a252 1
isa_intr_establish(irq, type, level, ih_fun, ih_arg)
d258 1
d312 1
@


1.6
log
@Stop loggin stray interrupts when we say we do
@
text
@d1 1
a1 1
/*	$NetBSD: isa_machdep.c,v 1.8 1995/10/09 06:34:47 mycroft Exp $	*/
a147 2
int intrstray[ICU_LEN];

d155 2
d163 1
a163 1
	if (intrstray[irq]++ <= 5)
d165 1
a165 1
		    intrstray[irq] > 5 ? "; stopped logging" : "");
d202 5
a206 6
#include "sl.h"
#include "ppp.h"
#if NSL > 0 || NPPP > 0
	/* In the presence of SLIP or PPP, imp > tty. */
	imask[IPL_IMP] |= imask[IPL_TTY];
#endif
d209 2
a210 2
	 * There are network and disk drivers that use free() at interrupt
	 * time, so imp > (net | bio).
d212 2
a213 1
	imask[IPL_IMP] |= imask[IPL_NET] | imask[IPL_BIO];
d252 1
a252 1
isa_intr_establish(irq, type, level, ih_fun, ih_arg, ih_what)
a257 1
	char *ih_what;
a310 1
	ih->ih_what = ih_what;
@


1.5
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d165 1
a165 1
		    intrstray[irq] >= 5 ? "; stopped logging" : "");
@


1.4
log
@whoops; we need these include files for bounce buffers
@
text
@d148 2
a156 2
	static u_long strays;

d163 1
a163 1
	if (++strays <= 5)
d165 1
a165 1
		    strays >= 5 ? "; stopped logging" : "");
d252 1
a252 1
isa_intr_establish(irq, type, level, ih_fun, ih_arg)
d258 1
d312 1
@


1.3
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
@
text
@d47 2
d54 1
@


1.2
log
@i386 isa bounce buffers by hannken@@eis.cs.tu-bs.de
@
text
@a46 2
#include <vm/vm.h>

a51 1
#include <dev/isa/isadmavar.h>
d242 2
d251 2
a252 2
	isa_intrtype type;
	isa_intrlevel level;
a255 1
	int mask;
d265 1
a265 3
	mask = 1 << irq;

	if (irq < 0 || irq > ICU_LEN || type == ISA_IST_NONE)
a266 2
	if (fastvec & mask)
		panic("intr_establish: irq is already fast vector");
d269 2
a270 2
	case ISA_IST_EDGE:
	case ISA_IST_LEVEL:
d273 2
a274 2
	case ISA_IST_PULSE:
		if (type != ISA_IST_NONE)
d294 1
a294 24
	switch (level) {
	case ISA_IPL_NONE:
		fakehand.ih_level = IPL_NONE;
		break;

	case ISA_IPL_BIO:
		fakehand.ih_level = IPL_BIO;
		break;

	case ISA_IPL_NET:
		fakehand.ih_level = IPL_NET;
		break;

	case ISA_IPL_TTY:
		fakehand.ih_level = IPL_TTY;
		break;

	case ISA_IPL_CLOCK:
		fakehand.ih_level = IPL_CLOCK;
		break;

	default:
		panic("isa_intr_establish: bad interrupt level %d", level);
	}
d306 1
a306 1
	ih->ih_level = fakehand.ih_level;
d321 1
a321 1
	int irq, mask;
d324 1
a324 4
	irq = ih->ih_irq;
	mask = 1 << irq;

	if (irq < 0 || irq > ICU_LEN)
a325 2
	if (fastvec & mask)
		fastvec &= ~mask;
d342 1
a342 1
		intrtype[irq] = ISA_IST_NONE;
@


1.1
log
@Initial revision
@
text
@d47 2
d54 1
d377 305
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
