head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.6
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.19.0.34
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.36
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.28
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.32
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.30
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.26
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.24
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.22
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.20
	OPENBSD_5_0:1.19.0.18
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.16
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.14
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.10
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.12
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.8
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.6
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.10
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.8
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.10
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.8
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.6
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.16
	UBC:1.15.0.4
	UBC_BASE:1.15
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.2
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.10
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.8
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.6
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.4
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2016.06.05.20.02.36;	author bru;	state Exp;
branches;
next	1.19;
commitid	yQU8JfyotYfDAe86;

1.19
date	2007.04.10.22.37.17;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.09.19.11.06.34;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2004.06.13.21.49.16;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.07.19.24.27;	author jason;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2001.02.20.23.53.27;	author jbm;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.20.23.04.05;	author jbm;	state dead;
branches;
next	1.12;

1.12
date	2000.05.16.18.12.14;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	99.11.22.07.26.04;	author matthieu;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	99.08.22.08.16.20;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	99.01.13.07.26.01;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.05.25.22.17.50;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.05.07.07.22.20;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.16.58;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.03.20.00.31.05;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.19.21.09.37;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.20.04.35.32;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.10.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.38;	author deraadt;	state Exp;
branches;
next	;

1.11.2.1
date	2001.04.18.16.07.53;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	;

1.15.4.1
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Use the new input functions of wsmouse in mouse and touchscreen drivers.

ok stsp@@ kettenis@@
@
text
@/* $OpenBSD: mms.c,v 1.19 2007/04/10 22:37:17 miod Exp $ */
/*	$NetBSD: mms.c,v 1.35 2000/01/08 02:57:25 takemura Exp $	*/

/*-
 * Copyright (c) 1993, 1994 Charles M. Hannum.
 * Copyright (c) 1992, 1993 Erik Forsberg.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
 * NO EVENT SHALL I BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/device.h>

#include <machine/intr.h>
#include <machine/bus.h>

#include <dev/isa/isavar.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsmousevar.h>

#define	MMS_ADDR	0	/* offset for register select */
#define	MMS_DATA	1	/* offset for InPort data */
#define	MMS_IDENT	2	/* offset for identification register */
#define	MMS_NPORTS	4

struct mms_softc {		/* driver status information */
	struct device sc_dev;
	void *sc_ih;

	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;

	int sc_enabled; /* device is open */

	struct device *sc_wsmousedev;
};

int mmsprobe(struct device *, void *, void *);
void mmsattach(struct device *, struct device *, void *);
int mmsintr(void *);

struct cfattach mms_ca = {
	sizeof(struct mms_softc), mmsprobe, mmsattach
};

int	mms_enable(void *);
int	mms_ioctl(void *, u_long, caddr_t, int, struct proc *);
void	mms_disable(void *);

const struct wsmouse_accessops mms_accessops = {
	mms_enable,
	mms_ioctl,
	mms_disable,
};

int
mmsprobe(struct device *parent, void *match, void *aux)
{
	struct isa_attach_args *ia = aux;
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh;
	int rv;

	/* Disallow wildcarded i/o address. */
	if (ia->ia_iobase == IOBASEUNK)
		return 0;

	/* Map the i/o space. */
	if (bus_space_map(iot, ia->ia_iobase, MMS_NPORTS, 0, &ioh))
		return 0;

	rv = 0;

	/* Read identification register to see if present */
	if (bus_space_read_1(iot, ioh, MMS_IDENT) != 0xde)
		goto out;

	/* Seems it was there; reset. */
	bus_space_write_1(iot, ioh, MMS_ADDR, 0x87);

	rv = 1;
	ia->ia_iosize = MMS_NPORTS;
	ia->ia_msize = 0;

out:
	bus_space_unmap(iot, ioh, MMS_NPORTS);
	return rv;
}

void
mmsattach(struct device *parent, struct device *self, void *aux)
{
	struct mms_softc *sc = (void *)self;
	struct isa_attach_args *ia = aux;
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh;
	struct wsmousedev_attach_args a;

	printf("\n");

	if (bus_space_map(iot, ia->ia_iobase, MMS_NPORTS, 0, &ioh)) {
		printf("%s: can't map i/o space\n", sc->sc_dev.dv_xname);
		return;
	}

	/* Other initialization was done by mmsprobe. */
	sc->sc_iot = iot;
	sc->sc_ioh = ioh;
	sc->sc_enabled = 0;

	sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_PULSE,
	    IPL_TTY, mmsintr, sc, sc->sc_dev.dv_xname);

	a.accessops = &mms_accessops;
	a.accesscookie = sc;

	/*
	 * Attach the wsmouse, saving a handle to it.
	 * Note that we don't need to check this pointer against NULL
	 * here or in psmintr, because if this fails lms_enable() will
	 * never be called, so lmsintr() will never be called.
	 */
	sc->sc_wsmousedev = config_found(self, &a, wsmousedevprint);
}

int
mms_enable(void *v)
{
	struct mms_softc *sc = v;

	if (sc->sc_enabled)
		return EBUSY;

	sc->sc_enabled = 1;

	/* Enable interrupts. */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, MMS_ADDR, 0x07);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, MMS_DATA, 0x09);

	return 0;
}

void
mms_disable(void *v)
{
	struct mms_softc *sc = v;

	/* Disable interrupts. */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, MMS_ADDR, 0x87);

	sc->sc_enabled = 0;
}

int
mms_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
#if 0
	struct mms_softc *sc = v;
#endif

	switch (cmd) {
	case WSMOUSEIO_GTYPE:
		*(u_int *)data = WSMOUSE_TYPE_MMS;
		return (0);
	}
	return (-1);
}

int
mmsintr(void *arg)
{
	struct mms_softc *sc = arg;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_char status;
	signed char dx, dy;
	u_int buttons;
	int changed;

	if (!sc->sc_enabled)
		/* Interrupts are not expected. */
		return 0;

	/* Freeze InPort registers (disabling interrupts). */
	bus_space_write_1(iot, ioh, MMS_ADDR, 0x07);
	bus_space_write_1(iot, ioh, MMS_DATA, 0x29);

	bus_space_write_1(iot, ioh, MMS_ADDR, 0x00);
	status = bus_space_read_1(iot, ioh, MMS_DATA);

	if (status & 0x40) {
		bus_space_write_1(iot, ioh, MMS_ADDR, 1);
		dx = bus_space_read_1(iot, ioh, MMS_DATA);
		/* Bounding at -127 avoids a bug in XFree86. */
		dx = (dx == -128) ? -127 : dx;

		bus_space_write_1(iot, ioh, MMS_ADDR, 2);
		dy = bus_space_read_1(iot, ioh, MMS_DATA);
		dy = (dy == -128) ? 127 : -dy;
	} else
		dx = dy = 0;

	/* Unfreeze InPort registers (reenabling interrupts). */
	bus_space_write_1(iot, ioh, MMS_ADDR, 0x07);
	bus_space_write_1(iot, ioh, MMS_DATA, 0x09);

	buttons = ((status & 0x04) ? 0x1 : 0) |
		((status & 0x02) ? 0x2 : 0) |
		((status & 0x01) ? 0x4 : 0);
	changed = status & 0x38;

	if (dx || dy || changed)
		WSMOUSE_INPUT(sc->sc_wsmousedev, buttons, dx, dy, 0, 0);

	return -1;
}

struct cfdriver mms_cd = {
	NULL, "mms", DV_DULL
};
@


1.19
log
@Add support for a fourth axis on wsmouse devices, e.g. on the Apple Might
Mouse.  Currently limited to USB mice.

Adapted from a diff from Gareth <garf@@loveandnature.co.za> on tech@@
@
text
@d1 1
a1 1
/* $OpenBSD: mms.c,v 1.18 2006/09/19 11:06:34 jsg Exp $ */
d232 1
a232 2
		wsmouse_input(sc->sc_wsmousedev,
			      buttons, dx, dy, 0, 0, WSMOUSE_INPUT_DELTA);
@


1.18
log
@ansi/deregister
@
text
@d1 1
a1 1
/* $OpenBSD: mms.c,v 1.17 2004/06/13 21:49:16 niklas Exp $ */
d233 1
a233 1
			      buttons, dx, dy, 0, WSMOUSE_INPUT_DELTA);
@


1.17
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d76 1
a76 4
mmsprobe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d110 1
a110 3
mmsattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d146 1
a146 2
mms_enable(v)
	void *v;
d163 1
a163 2
mms_disable(v)
	void *v;
d174 1
a174 6
mms_ioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d189 1
a189 2
mmsintr(arg)
	void *arg;
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mms.c,v 1.15 2001/08/07 19:24:27 jason Exp $ */
@


1.15
log
@tag fixes; Denis Afonin <dfa@@solo.ee>
@
text
@d1 1
a1 1
/*	$OpenBSD: mms.c,v 1.14 2001/02/20 23:53:27 jbm Exp $ */
d57 3
a59 3
int mmsprobe __P((struct device *, void *, void *));
void mmsattach __P((struct device *, struct device *, void *));
int mmsintr __P((void *));
d65 3
a67 3
int	mms_enable __P((void *));
int	mms_ioctl __P((void *, u_long, caddr_t, int, struct proc *));
void	mms_disable __P((void *));
@


1.15.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mms.c,v 1.15 2001/08/07 19:24:27 jason Exp $ */
d57 3
a59 3
int mmsprobe(struct device *, void *, void *);
void mmsattach(struct device *, struct device *, void *);
int mmsintr(void *);
d65 3
a67 3
int	mms_enable(void *);
int	mms_ioctl(void *, u_long, caddr_t, int, struct proc *);
void	mms_disable(void *);
@


1.14
log
@Import of wsmouse-compatible lms and mms drivers from NetBSD.
Remove creation of non-wsmouse device in MAKEDEV (/dev/lms{0,1}, /dev/mms{0,1}
/dev/psm0, /dev/pms0).
Remove cdevsw[] entries for the devices above, as new mouse protocols are only
accessible trough /dev/wsmouse. aaron@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
@


1.13
log
@Remove old (non wsmouse) lms and mms drivers. Remove the commented olms and
omms entries in GENERIC. aaron@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: mms.c,v 1.12 2000/05/16 18:12:14 mickey Exp $	*/
/*	$NetBSD: mms.c,v 1.24 1996/05/12 23:12:18 mycroft Exp $	*/
d5 1
a5 1
 * Copyright (c) 1993, 1994 Charles Hannum.
a27 1
#include <sys/kernel.h>
a28 2
#include <sys/buf.h>
#include <sys/malloc.h>
a29 6
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/select.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/vnode.h>
a31 1
#include <machine/cpu.h>
d33 1
a33 3
#include <machine/pio.h>
#include <machine/mouse.h>
#include <machine/conf.h>
d36 3
a38 1
#include <dev/rndvar.h>
a44 3
#define	MMS_CHUNK	128	/* chunk size for read */
#define	MMS_BSIZE	1020	/* buffer size */

d49 6
a54 10
	struct clist sc_q;
	struct selinfo sc_rsel;
	struct proc *sc_io;     /* process that opened mms (can get SIGIO) */
	char   sc_async;        /* send SIGIO on input ready */
	int sc_iobase;		/* I/O port base */
	u_char sc_state;	/* mouse driver state */
#define	MMS_OPEN	0x01	/* device is open */
#define	MMS_ASLP	0x02	/* waiting for mouse data */
	u_char sc_status;	/* mouse button status */
	int sc_x, sc_y;		/* accumulated motion in the X,Y axis */
d65 8
a72 2
struct cfdriver mms_cd = {
	NULL, "mms", DV_TTY
a74 2
#define	MMSUNIT(dev)	(minor(dev))

d78 2
a79 1
	void *match, *aux;
d82 13
a94 1
	int iobase = ia->ia_iobase;
d97 2
a98 2
	if (inb(iobase + MMS_IDENT) != 0xde)
		return 0;
d101 1
a101 1
	outb(iobase + MMS_ADDR, 0x87);
d103 1
d106 4
a109 1
	return 1;
d119 3
a121 1
	int iobase = ia->ia_iobase;
d125 5
d131 3
a133 2
	sc->sc_iobase = iobase;
	sc->sc_state = 0;
d137 11
d151 2
a152 5
mmsopen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d154 1
a154 8
	int unit = MMSUNIT(dev);
	struct mms_softc *sc;

	if (unit >= mms_cd.cd_ndevs)
		return ENXIO;
	sc = mms_cd.cd_devs[unit];
	if (!sc)
		return ENXIO;
d156 1
a156 1
	if (sc->sc_state & MMS_OPEN)
d159 1
a159 8
	if (clalloc(&sc->sc_q, MMS_BSIZE, 0) == -1)
		return ENOMEM;

	sc->sc_state |= MMS_OPEN;
	sc->sc_status = 0;
	sc->sc_x = sc->sc_y = 0;
	sc->sc_async = 0;
	sc->sc_io = p;
d162 2
a163 2
	outb(sc->sc_iobase + MMS_ADDR, 0x07);
	outb(sc->sc_iobase + MMS_DATA, 0x09);
d168 3
a170 6
int
mmsclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d172 1
a172 1
	struct mms_softc *sc = mms_cd.cd_devs[MMSUNIT(dev)];
d175 1
a175 1
	outb(sc->sc_iobase + MMS_ADDR, 0x87);
d177 1
a177 6
	sc->sc_state &= ~MMS_OPEN;
	sc->sc_io = NULL;

	clfree(&sc->sc_q);

	return 0;
d181 2
a182 50
mmsread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct mms_softc *sc = mms_cd.cd_devs[MMSUNIT(dev)];
	int s;
	int error = 0;
	size_t length;
	u_char buffer[MMS_CHUNK];

	/* Block until mouse activity occured. */

	s = spltty();
	while (sc->sc_q.c_cc == 0) {
		if (flag & IO_NDELAY) {
			splx(s);
			return EWOULDBLOCK;
		}
		sc->sc_state |= MMS_ASLP;
		error = tsleep((caddr_t)sc, PZERO | PCATCH, "mmsrea", 0);
		if (error) {
			sc->sc_state &= ~MMS_ASLP;
			splx(s);
			return error;
		}
	}
	splx(s);

	/* Transfer as many chunks as possible. */

	while (sc->sc_q.c_cc > 0 && uio->uio_resid > 0) {
		length = min(sc->sc_q.c_cc, uio->uio_resid);
		if (length > sizeof(buffer))
			length = sizeof(buffer);

		/* Remove a small chunk from the input queue. */
		(void) q_to_b(&sc->sc_q, buffer, length);

		/* Copy the data to the user process. */
		if ((error = uiomove(buffer, length, uio)) != 0)
			break;
	}

	return error;
}

int
mmsioctl(dev, cmd, addr, flag, p)
	dev_t dev;
d184 1
a184 1
	caddr_t addr;
d188 3
a190 4
	struct mms_softc *sc = mms_cd.cd_devs[MMSUNIT(dev)];
	struct mouseinfo info;
	int s;
	int error;
d193 2
a194 1
	case FIONBIO:           /* we will remove this someday (soon???) */
a195 51

	case FIOASYNC:
		sc->sc_async = *(int *)addr != 0;
		break;

	case TIOCSPGRP:
		if (*(int *)addr != sc->sc_io->p_pgid)
			return (EPERM);
		break;

	case MOUSEIOCREAD:
		s = spltty();

		info.status = sc->sc_status;
		if (sc->sc_x || sc->sc_y)
			info.status |= MOVEMENT;

		if (sc->sc_x > 127)
			info.xmotion = 127;
		else if (sc->sc_x < -127)
			/* Bounding at -127 avoids a bug in XFree86. */
			info.xmotion = -127;
		else
			info.xmotion = sc->sc_x;

		if (sc->sc_y > 127)
			info.ymotion = 127;
		else if (sc->sc_y < -127)
			info.ymotion = -127;
		else
			info.ymotion = sc->sc_y;

		/* Reset historical information. */
		sc->sc_x = sc->sc_y = 0;
		sc->sc_status &= ~BUTCHNGMASK;
		ndflush(&sc->sc_q, sc->sc_q.c_cc);

		splx(s);
		error = copyout(&info, addr, sizeof(struct mouseinfo));
		break;

	case MOUSEIOCSRAW:
		error = ENODEV;
		break;

	case MOUSEIOCSCOOKED:	/* Do nothing. */
		break;

	default:
		error = EINVAL;
		break;
d197 1
a197 2

	return error;
d205 6
a210 4
	int iobase = sc->sc_iobase;
	u_char buttons, changed, status;
	char dx, dy;
	u_char buffer[5];
d212 1
a212 1
	if ((sc->sc_state & MMS_OPEN) == 0)
d217 2
a218 2
	outb(iobase + MMS_ADDR, 0x07);
	outb(iobase + MMS_DATA, 0x29);
d220 2
a221 2
	outb(iobase + MMS_ADDR, 0x00);
	status = inb(iobase + MMS_DATA);
d224 3
a226 2
		outb(iobase + MMS_ADDR, 1);
		dx = inb(iobase + MMS_DATA);
d228 3
a230 2
		outb(iobase + MMS_ADDR, 2);
		dy = inb(iobase + MMS_DATA);
d236 2
a237 28
	outb(iobase + MMS_ADDR, 0x07);
	outb(iobase + MMS_DATA, 0x09);

	buttons = status & BUTSTATMASK;
	changed = status & BUTCHNGMASK;
	sc->sc_status = buttons | (sc->sc_status & ~BUTSTATMASK) | changed;

	if (dx || dy || changed) {
		/* Update accumulated movements. */
		sc->sc_x += dx;
		sc->sc_y += dy;

		/* Add this event to the queue. */
		buffer[0] = 0x80 | (buttons ^ BUTSTATMASK);
		buffer[1] = dx;
		buffer[2] = dy;
		buffer[3] = buffer[4] = 0;
		(void) b_to_q(buffer, sizeof buffer, &sc->sc_q);
		add_mouse_randomness(*(u_int32_t*)buffer);

		if (sc->sc_state & MMS_ASLP) {
			sc->sc_state &= ~MMS_ASLP;
			wakeup((caddr_t)sc);
		}
		selwakeup(&sc->sc_rsel);
		if (sc->sc_async) {
			psignal(sc->sc_io, SIGIO); 
		}
d239 8
a246 1
	}
d251 3
a253 23
int
mmsselect(dev, rw, p)
	dev_t dev;
	int rw;
	struct proc *p;
{
	struct mms_softc *sc = mms_cd.cd_devs[MMSUNIT(dev)];
	int s;
	int ret;

	if (rw == FWRITE)
		return 0;

	s = spltty();
	if (!sc->sc_q.c_cc) {
		selrecord(p, &sc->sc_rsel);
		ret = 0;
	} else
		ret = 1;
	splx(s);

	return ret;
}
@


1.12
log
@supply entropy from mouse; provos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mms.c,v 1.11 1999/11/22 07:26:04 matthieu Exp $	*/
@


1.11
log
@add support for asynchronous I/O (through SIGIO)
@
text
@d1 1
a1 1
/*	$OpenBSD: mms.c,v 1.10 1999/08/22 08:16:20 downsj Exp $	*/
d48 1
d352 1
@


1.11.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 2
/* $OpenBSD: mms.c,v 1.14 2001/02/20 23:53:27 jbm Exp $ */
/*	$NetBSD: mms.c,v 1.35 2000/01/08 02:57:25 takemura Exp $	*/
d5 1
a5 1
 * Copyright (c) 1993, 1994 Charles M. Hannum.
d28 1
d30 2
d33 6
d41 1
d43 3
a45 1
#include <machine/bus.h>
a48 3
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsmousevar.h>

d54 3
d61 10
a70 6
	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;

	int sc_enabled; /* device is open */

	struct device *sc_wsmousedev;
d81 2
a82 8
int	mms_enable __P((void *));
int	mms_ioctl __P((void *, u_long, caddr_t, int, struct proc *));
void	mms_disable __P((void *));

const struct wsmouse_accessops mms_accessops = {
	mms_enable,
	mms_ioctl,
	mms_disable,
d85 2
d90 1
a90 2
	void *match;
	void *aux;
d93 1
a93 3
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh;
	int rv;
d95 2
a96 2
	/* Disallow wildcarded i/o address. */
	if (ia->ia_iobase == IOBASEUNK)
a98 10
	/* Map the i/o space. */
	if (bus_space_map(iot, ia->ia_iobase, MMS_NPORTS, 0, &ioh))
		return 0;

	rv = 0;

	/* Read identification register to see if present */
	if (bus_space_read_1(iot, ioh, MMS_IDENT) != 0xde)
		goto out;

d100 1
a100 1
	bus_space_write_1(iot, ioh, MMS_ADDR, 0x87);
a101 1
	rv = 1;
d104 1
a104 4

out:
	bus_space_unmap(iot, ioh, MMS_NPORTS);
	return rv;
d114 1
a114 3
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh;
	struct wsmousedev_attach_args a;
a117 5
	if (bus_space_map(iot, ia->ia_iobase, MMS_NPORTS, 0, &ioh)) {
		printf("%s: can't map i/o space\n", sc->sc_dev.dv_xname);
		return;
	}

d119 2
a120 3
	sc->sc_iot = iot;
	sc->sc_ioh = ioh;
	sc->sc_enabled = 0;
a123 11

	a.accessops = &mms_accessops;
	a.accesscookie = sc;

	/*
	 * Attach the wsmouse, saving a handle to it.
	 * Note that we don't need to check this pointer against NULL
	 * here or in psmintr, because if this fails lms_enable() will
	 * never be called, so lmsintr() will never be called.
	 */
	sc->sc_wsmousedev = config_found(self, &a, wsmousedevprint);
d127 5
a131 2
mms_enable(v)
	void *v;
d133 8
a140 1
	struct mms_softc *sc = v;
d142 1
a142 1
	if (sc->sc_enabled)
d145 8
a152 1
	sc->sc_enabled = 1;
d155 2
a156 2
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, MMS_ADDR, 0x07);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, MMS_DATA, 0x09);
d161 6
a166 3
void
mms_disable(v)
	void *v;
d168 1
a168 1
	struct mms_softc *sc = v;
d171 1
a171 1
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, MMS_ADDR, 0x87);
d173 6
a178 1
	sc->sc_enabled = 0;
d182 50
a231 2
mms_ioctl(v, cmd, data, flag, p)
	void *v;
d233 1
a233 1
	caddr_t data;
d237 4
a240 3
#if 0
	struct mms_softc *sc = v;
#endif
d243 1
a243 2
	case WSMOUSEIO_GTYPE:
		*(u_int *)data = WSMOUSE_TYPE_MMS;
d245 51
d297 2
a298 1
	return (-1);
d306 4
a309 6
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_char status;
	signed char dx, dy;
	u_int buttons;
	int changed;
d311 1
a311 1
	if (!sc->sc_enabled)
d316 2
a317 2
	bus_space_write_1(iot, ioh, MMS_ADDR, 0x07);
	bus_space_write_1(iot, ioh, MMS_DATA, 0x29);
d319 2
a320 2
	bus_space_write_1(iot, ioh, MMS_ADDR, 0x00);
	status = bus_space_read_1(iot, ioh, MMS_DATA);
d323 2
a324 3
		bus_space_write_1(iot, ioh, MMS_ADDR, 1);
		dx = bus_space_read_1(iot, ioh, MMS_DATA);
		/* Bounding at -127 avoids a bug in XFree86. */
d326 2
a327 3

		bus_space_write_1(iot, ioh, MMS_ADDR, 2);
		dy = bus_space_read_1(iot, ioh, MMS_DATA);
d333 27
a359 2
	bus_space_write_1(iot, ioh, MMS_ADDR, 0x07);
	bus_space_write_1(iot, ioh, MMS_DATA, 0x09);
d361 1
a361 8
	buttons = ((status & 0x04) ? 0x1 : 0) |
		((status & 0x02) ? 0x2 : 0) |
		((status & 0x01) ? 0x4 : 0);
	changed = status & 0x38;

	if (dx || dy || changed)
		wsmouse_input(sc->sc_wsmousedev,
			      buttons, dx, dy, 0, WSMOUSE_INPUT_DELTA);
d366 23
a388 3
struct cfdriver mms_cd = {
	NULL, "mms", DV_DULL
};
@


1.11.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: mms.c,v 1.11.2.1 2001/04/18 16:07:53 niklas Exp $ */
@


1.11.2.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d57 3
a59 3
int mmsprobe(struct device *, void *, void *);
void mmsattach(struct device *, struct device *, void *);
int mmsintr(void *);
d65 3
a67 3
int	mms_enable(void *);
int	mms_ioctl(void *, u_long, caddr_t, int, struct proc *);
void	mms_disable(void *);
@


1.10
log
@Add noop MOUSEIOCSCOOKED and ENODEV MOUSEIOCSRAW ioctls, as suggested by
Matthieu Herrb.
@
text
@d1 1
a1 1
/*	$OpenBSD: mms.c,v 1.9 1999/01/13 07:26:01 niklas Exp $	*/
d37 1
d63 2
d151 2
d174 1
d243 12
d357 4
@


1.9
log
@RCSIds
@
text
@d1 1
a1 1
/*	$OpenBSD: mms.c,v 1.24 1996/05/12 23:12:18 mycroft Exp $	*/
d266 7
@


1.8
log
@sync
@
text
@d1 1
@


1.7
log
@sync with 0504; prototype changes
@
text
@d1 1
a1 1
/*	$NetBSD: mms.c,v 1.23 1996/05/03 20:11:57 christos Exp $	*/
d40 1
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$NetBSD: mms.c,v 1.22 1996/04/11 22:15:20 cgd Exp $	*/
d42 1
d122 1
a122 1
mmsopen(dev, flag)
d125 2
d155 1
a155 1
mmsclose(dev, flag)
d158 2
d181 1
a181 1
	int error;
d194 2
a195 1
		if (error = tsleep((caddr_t)sc, PZERO | PCATCH, "mmsrea", 0)) {
d214 1
a214 1
		if (error = uiomove(buffer, length, uio))
d222 1
a222 1
mmsioctl(dev, cmd, addr, flag)
d227 1
@


1.5
log
@Fix back wrong patches.
@
text
@d1 1
a1 1
/*	$NetBSD: mms.c,v 1.20 1995/12/24 02:30:19 mycroft Exp $	*/
d71 6
a76 2
struct cfdriver mmscd = {
	NULL, "mms", mmsprobe, mmsattach, DV_TTY, sizeof(struct mms_softc)
d116 2
a117 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, IST_PULSE, IPL_TTY, mmsintr,
	    sc, sc->sc_dev.dv_xname);
d128 1
a128 1
	if (unit >= mmscd.cd_ndevs)
d130 1
a130 1
	sc = mmscd.cd_devs[unit];
d156 1
a156 1
	struct mms_softc *sc = mmscd.cd_devs[MMSUNIT(dev)];
d174 1
a174 1
	struct mms_softc *sc = mmscd.cd_devs[MMSUNIT(dev)];
d222 1
a222 1
	struct mms_softc *sc = mmscd.cd_devs[MMSUNIT(dev)];
d334 1
a334 1
	struct mms_softc *sc = mmscd.cd_devs[MMSUNIT(dev)];
@


1.4
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d113 1
a113 1
	    sc);
@


1.3
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 1
a1 1
/*	$NetBSD: mms.c,v 1.19 1995/10/05 22:06:51 mycroft Exp $	*/
d113 1
a113 1
	    sc, sc->sc_dev.dv_xname);
@


1.2
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
@
text
@d113 1
a113 1
	    sc);
@


1.1
log
@Initial revision
@
text
@d112 2
a113 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_PULSE, ISA_IPL_TTY,
	    mmsintr, sc);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
