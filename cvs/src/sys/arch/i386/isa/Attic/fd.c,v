head	1.24;
access;
symbols
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	UBC_SYNC_A:1.24
	UBC_SYNC_B:1.24
	SMP:1.24.0.2
	OPENBSD_2_0:1.22.0.2
	OPENBSD_2_0_BASE:1.22
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	96.10.26.06.15.02;	author downsj;	state dead;
branches;
next	1.23;

1.23
date	96.10.16.12.46.22;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	96.09.23.15.31.53;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	96.09.01.20.58.26;	author downsj;	state Exp;
branches;
next	1.20;

1.20
date	96.08.29.18.03.27;	author downsj;	state Exp;
branches;
next	1.19;

1.19
date	96.08.07.15.54.41;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	96.06.20.07.51.37;	author downsj;	state Exp;
branches;
next	1.17;

1.17
date	96.06.09.19.40.28;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.06.01.09.36.52;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.05.25.22.17.48;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.05.07.07.22.16;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.04.21.22.16.52;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.04.18.17.12.13;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	96.03.20.00.31.02;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	96.03.19.21.09.32;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.02.20.12.07.04;	author hannken;	state Exp;
branches;
next	1.8;

1.8
date	96.02.20.04.35.29;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.02.02.19.28.41;	author dm;	state Exp;
branches;
next	1.6;

1.6
date	96.01.15.00.58.16;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.01.12.20.20.23;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.12.30.08.25.42;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.27.22.10.36;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.28.16.43.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.37;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@floppy driver is now in dev/isa.  Not in files.isa yet, though, since arc
changes are still needed.
@
text
@/*	$OpenBSD: fd.c,v 1.23 1996/10/16 12:46:22 deraadt Exp $	*/
/*	$NetBSD: fd.c,v 1.90 1996/05/12 23:12:03 mycroft Exp $	*/

/*-
 * Copyright (c) 1993, 1994, 1995 Charles Hannum.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Don Ahn.
 *
 * Portions Copyright (c) 1993, 1994 by
 *  jc@@irbs.UUCP (John Capo)
 *  vak@@zebub.msk.su (Serge Vakulenko)
 *  ache@@astral.msk.su (Andrew A. Chernov)
 *  joerg_wunsch@@uriah.sax.de (Joerg Wunsch)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)fd.c	7.4 (Berkeley) 5/25/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/dkstat.h>
#include <sys/disk.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/uio.h>
#include <sys/mtio.h>
#include <sys/proc.h>
#include <sys/syslog.h>
#include <sys/queue.h>

#include <machine/cpu.h>
#include <machine/bus.h>
#include <machine/conf.h>
#include <machine/intr.h>
#include <machine/ioctl_fd.h>

#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>
#include <i386/isa/fdreg.h>

#include <dev/ic/mc146818reg.h>			/* for NVRAM access */
#include <i386/isa/nvram.h>

#include <i386/isa/fdlink.h>

/* XXX misuse a flag to identify format operation */
#define B_FORMAT B_XXX

#define b_cylin b_resid

/* fd_type struct now in ioctl_fd.h */

/* The order of entries in the following table is important -- BEWARE! */
struct fd_type fd_types[] = {
        { 18,2,36,2,0xff,0xcf,0x1b,0x6c,80,2880,1,FDC_500KBPS,"1.44MB"    }, /* 1.44MB diskette */
        { 15,2,30,2,0xff,0xdf,0x1b,0x54,80,2400,1,FDC_500KBPS, "1.2MB"    }, /* 1.2 MB AT-diskettes */
        {  9,2,18,2,0xff,0xdf,0x23,0x50,40, 720,2,FDC_300KBPS, "360KB/AT" }, /* 360kB in 1.2MB drive */
        {  9,2,18,2,0xff,0xdf,0x2a,0x50,40, 720,1,FDC_250KBPS, "360KB/PC" }, /* 360kB PC diskettes */
        {  9,2,18,2,0xff,0xdf,0x2a,0x50,80,1440,1,FDC_250KBPS, "720KB"    }, /* 3.5" 720kB diskette */
        {  9,2,18,2,0xff,0xdf,0x23,0x50,80,1440,1,FDC_300KBPS, "720KB/x"  }, /* 720kB in 1.2MB drive */
        {  9,2,18,2,0xff,0xdf,0x2a,0x50,40, 720,2,FDC_250KBPS, "360KB/x"  }, /* 360kB in 720kB drive */
};

/* software state, per disk (with up to 4 disks per ctlr) */
struct fd_softc {
	struct device sc_dev;
	struct disk sc_dk;

	struct fd_type *sc_deftype;	/* default type descriptor */
	struct fd_type *sc_type;	/* current type descriptor */

	daddr_t	sc_blkno;	/* starting block number */
	int sc_bcount;		/* byte count left */
 	int sc_opts;			/* user-set options */
	int sc_skip;		/* bytes already transferred */
	int sc_nblks;		/* number of blocks currently tranferring */
	int sc_nbytes;		/* number of bytes currently tranferring */

	int sc_drive;		/* physical unit number */
	int sc_flags;
#define	FD_OPEN		0x01		/* it's open */
#define	FD_MOTOR	0x02		/* motor should be on */
#define	FD_MOTOR_WAIT	0x04		/* motor coming up */
	int sc_cylin;		/* where we think the head is */

	void *sc_sdhook;	/* saved shutdown hook for drive. */

	TAILQ_ENTRY(fd_softc) sc_drivechain;
	int sc_ops;		/* I/O ops since last switch */
	struct buf sc_q;	/* head of buf chain */
};

/* floppy driver configuration */
int fdprobe __P((struct device *, void *, void *));
void fdattach __P((struct device *, struct device *, void *));

struct cfattach fd_ca = {
	sizeof(struct fd_softc), fdprobe, fdattach
};

struct cfdriver fd_cd = {
	NULL, "fd", DV_DISK
};

void fdgetdisklabel __P((struct fd_softc *));
int fd_get_parms __P((struct fd_softc *));
void fdstrategy __P((struct buf *));
void fdstart __P((struct fd_softc *));
int fdintr __P((struct fdc_softc *));

struct dkdriver fddkdriver = { fdstrategy };

void fd_set_motor __P((struct fdc_softc *fdc, int reset));
void fd_motor_off __P((void *arg));
void fd_motor_on __P((void *arg));
void fdfinish __P((struct fd_softc *fd, struct buf *bp));
int fdformat __P((dev_t, struct fd_formb *, struct proc *));
__inline struct fd_type *fd_dev_to_type __P((struct fd_softc *, dev_t));
void fdretry __P((struct fd_softc *));
void fdtimeout __P((void *));

int
fdprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct fdc_softc *fdc = (void *)parent;
	struct cfdata *cf = match;
	struct fdc_attach_args *fa = aux;
	int drive = fa->fa_drive;
	bus_chipset_tag_t bc = fdc->sc_bc;
	bus_io_handle_t ioh = fdc->sc_ioh;
	int n;

	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != drive)
		return 0;
	/*
	 * XXX
	 * This is to work around some odd interactions between this driver
	 * and SMC Ethernet cards.
	 */
	if (cf->cf_loc[0] == -1 && drive >= 2)
		return 0;

	/*
	 * We want to keep the flags config gave us.
	 */
	fa->fa_flags = cf->cf_flags;

	/* select drive and turn on motor */
	bus_io_write_1(bc, ioh, fdout, drive | FDO_FRST | FDO_MOEN(drive));
	/* wait for motor to spin up */
	delay(250000);
	out_fdc(bc, ioh, NE7CMD_RECAL);
	out_fdc(bc, ioh, drive);
	/* wait for recalibrate */
	delay(2000000);
	out_fdc(bc, ioh, NE7CMD_SENSEI);
	n = fdcresult(fdc);
#ifdef FD_DEBUG
	{
		int i;
		printf("fdprobe: status");
		for (i = 0; i < n; i++)
			printf(" %x", fdc->sc_status[i]);
		printf("\n");
	}
#endif
	if (n != 2 || (fdc->sc_status[0] & 0xf8) != 0x20)
		return 0;
	/* turn off motor */
	bus_io_write_1(bc, ioh, fdout, FDO_FRST);

	return 1;
}

/*
 * Controller is working, and drive responded.  Attach it.
 */
void
fdattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct fdc_softc *fdc = (void *)parent;
	struct fd_softc *fd = (void *)self;
	struct fdc_attach_args *fa = aux;
	struct fd_type *type = fa->fa_deftype;
	int drive = fa->fa_drive;

	if (!type || (fa->fa_flags & 0x10)) {
		/* The config has overridden this. */
		switch (fa->fa_flags & 0x07) {
		/* 1 is reserved for 2.88MB */
		case 2:	/* 1.44MB */
			type = &fd_types[0];
			break;
		case 3: /* 1.2MB */
			type = &fd_types[1];
			break;
		case 4: /* 720K */
			type = &fd_types[4];
			break;
		case 5: /* 360K */
			type = &fd_types[3];
			break;
		}
	}

	if (type)
		printf(": %s %d cyl, %d head, %d sec\n", type->name,
		    type->tracks, type->heads, type->sectrac);
	else
		printf(": density unknown\n");

	fd->sc_cylin = -1;
	fd->sc_drive = drive;
	fd->sc_deftype = type;
	fdc->sc_fd[drive] = fd;

	/*
	 * Initialize and attach the disk structure.
	 */
	fd->sc_dk.dk_name = fd->sc_dev.dv_xname;
	fd->sc_dk.dk_driver = &fddkdriver;
	disk_attach(&fd->sc_dk);

	dk_establish(&fd->sc_dk, &fd->sc_dev);
	/* Needed to power off if the motor is on when we halt. */
	fd->sc_sdhook = shutdownhook_establish(fd_motor_off, fd);
}

/*
 * Translate nvram type into internal data structure.  Return NULL for
 * none/unknown/unusable.
 */
struct fd_type *
fd_nvtotype(fdc, nvraminfo, drive)
	char *fdc;
	int nvraminfo, drive;
{
	int type;

	type = (drive == 0 ? nvraminfo : nvraminfo << 4) & 0xf0;
	switch (type) {
	case NVRAM_DISKETTE_NONE:
		return NULL;
	case NVRAM_DISKETTE_12M:
		return &fd_types[1];
	case NVRAM_DISKETTE_TYPE5:
	case NVRAM_DISKETTE_TYPE6:
		/* XXX We really ought to handle 2.88MB format. */
	case NVRAM_DISKETTE_144M:
		return &fd_types[0];
	case NVRAM_DISKETTE_360K:
		return &fd_types[3];
	case NVRAM_DISKETTE_720K:
		return &fd_types[4];
	default:
		printf("%s: drive %d: unknown device type 0x%x\n",
		    fdc, drive, type);
		return NULL;
	}
}

__inline struct fd_type *
fd_dev_to_type(fd, dev)
	struct fd_softc *fd;
	dev_t dev;
{
	int type = FDTYPE(dev);

	if (type > (sizeof(fd_types) / sizeof(fd_types[0])))
		return NULL;
	return type ? &fd_types[type - 1] : fd->sc_deftype;
}

void
fdstrategy(bp)
	register struct buf *bp;	/* IO operation to perform */
{
	struct fd_softc *fd;
	int unit = FDUNIT(bp->b_dev);
	int sz;
 	int s;

	/* Valid unit, controller, and request? */
	if (unit >= fd_cd.cd_ndevs ||
	    (fd = fd_cd.cd_devs[unit]) == 0 ||
	    bp->b_blkno < 0 ||
	    ((bp->b_bcount % FDC_BSIZE) != 0 &&
	     (bp->b_flags & B_FORMAT) == 0)) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/* If it's a null transfer, return immediately. */
	if (bp->b_bcount == 0)
		goto done;

	sz = howmany(bp->b_bcount, FDC_BSIZE);

	if (bp->b_blkno + sz > fd->sc_type->size) {
		sz = fd->sc_type->size - bp->b_blkno;
		if (sz == 0)
			/* If exactly at end of disk, return EOF. */
			goto done;
		if (sz < 0) {
			/* If past end of disk, return EINVAL. */
			bp->b_error = EINVAL;
			goto bad;
		}
		/* Otherwise, truncate request. */
		bp->b_bcount = sz << DEV_BSHIFT;
	}

 	bp->b_cylin = bp->b_blkno / (FDC_BSIZE / DEV_BSIZE) / fd->sc_type->seccyl;

#ifdef FD_DEBUG
	printf("fdstrategy: b_blkno %d b_bcount %d blkno %d cylin %d sz %d\n",
	    bp->b_blkno, bp->b_bcount, fd->sc_blkno, bp->b_cylin, sz);
#endif

	/* Queue transfer on drive, activate drive and controller if idle. */
	s = splbio();
	disksort(&fd->sc_q, bp);
	untimeout(fd_motor_off, fd); /* a good idea */
	if (!fd->sc_q.b_active)
		fdstart(fd);
#ifdef DIAGNOSTIC
	else {
		struct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;
		if (fdc->sc_state == DEVIDLE) {
			printf("fdstrategy: controller inactive\n");
			fdcstart(fdc);
		}
	}
#endif
	splx(s);
	return;

bad:
	bp->b_flags |= B_ERROR;
done:
	/* Toss transfer; we're done early. */
	bp->b_resid = bp->b_bcount;
	biodone(bp);
}

void
fdstart(fd)
	struct fd_softc *fd;
{
	struct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;
	int active = fdc->sc_drives.tqh_first != 0;

	/* Link into controller queue. */
	fd->sc_q.b_active = 1;
	TAILQ_INSERT_TAIL(&fdc->sc_drives, fd, sc_drivechain);

	/* If controller not already active, start it. */
	if (!active)
		fdcstart(fdc);
}

void
fdfinish(fd, bp)
	struct fd_softc *fd;
	struct buf *bp;
{
	struct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;

	/*
	 * Move this drive to the end of the queue to give others a `fair'
	 * chance.  We only force a switch if N operations are completed while
	 * another drive is waiting to be serviced, since there is a long motor
	 * startup delay whenever we switch.
	 */
	if (fd->sc_drivechain.tqe_next && ++fd->sc_ops >= 8) {
		fd->sc_ops = 0;
		TAILQ_REMOVE(&fdc->sc_drives, fd, sc_drivechain);
		if (bp->b_actf) {
			TAILQ_INSERT_TAIL(&fdc->sc_drives, fd, sc_drivechain);
		} else
			fd->sc_q.b_active = 0;
	}
	bp->b_resid = fd->sc_bcount;
	fd->sc_skip = 0;
	fd->sc_q.b_actf = bp->b_actf;

	biodone(bp);
	/* turn off motor 5s from now */
	timeout(fd_motor_off, fd, 5 * hz);
	fdc->sc_state = DEVIDLE;
}

int
fdread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{

	return (physio(fdstrategy, NULL, dev, B_READ, minphys, uio));
}

int
fdwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{

	return (physio(fdstrategy, NULL, dev, B_WRITE, minphys, uio));
}

void
fd_set_motor(fdc, reset)
	struct fdc_softc *fdc;
	int reset;
{
	struct fd_softc *fd;
	u_char status;
	int n;

	if ((fd = fdc->sc_drives.tqh_first) != NULL)
		status = fd->sc_drive;
	else
		status = 0;
	if (!reset)
		status |= FDO_FRST | FDO_FDMAEN;
	for (n = 0; n < 4; n++)
		if ((fd = fdc->sc_fd[n]) && (fd->sc_flags & FD_MOTOR))
			status |= FDO_MOEN(n);
	bus_io_write_1(fdc->sc_bc, fdc->sc_ioh, fdout, status);
}

void
fd_motor_off(arg)
	void *arg;
{
	struct fd_softc *fd = arg;
	int s;

	s = splbio();
	fd->sc_flags &= ~(FD_MOTOR | FD_MOTOR_WAIT);
	fd_set_motor((struct fdc_softc *)fd->sc_dev.dv_parent, 0);
	splx(s);
}

void
fd_motor_on(arg)
	void *arg;
{
	struct fd_softc *fd = arg;
	struct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;
	int s;

	s = splbio();
	fd->sc_flags &= ~FD_MOTOR_WAIT;
	if ((fdc->sc_drives.tqh_first == fd) && (fdc->sc_state == MOTORWAIT))
		(void) fdintr(fdc);
	splx(s);
}

int
fdopen(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
{
 	int unit;
	struct fd_softc *fd;
	struct fd_type *type;

	unit = FDUNIT(dev);
	if (unit >= fd_cd.cd_ndevs)
		return ENXIO;
	fd = fd_cd.cd_devs[unit];
	if (fd == 0)
		return ENXIO;
	type = fd_dev_to_type(fd, dev);
	if (type == NULL)
		return ENXIO;

	if ((fd->sc_flags & FD_OPEN) != 0 &&
	    fd->sc_type != type)
		return EBUSY;

	fd->sc_type = type;
	fd->sc_cylin = -1;
	fd->sc_flags |= FD_OPEN;

	return 0;
}

int
fdclose(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
{
	struct fd_softc *fd = fd_cd.cd_devs[FDUNIT(dev)];

	fd->sc_flags &= ~FD_OPEN;
	fd->sc_opts &= ~FDOPT_NORETRY;
	return 0;
}

int
fdsize(dev)
	dev_t dev;
{

	/* Swapping to floppies would not make sense. */
	return -1;
}

int
fddump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
{

	/* Not implemented. */
	return ENXIO;
}

/*
 * Called from the controller.
 */
int
fdintr(fdc)
	struct fdc_softc *fdc;
{
#define	st0	fdc->sc_status[0]
#define	cyl	fdc->sc_status[1]
	struct fd_softc *fd;
	struct buf *bp;
	bus_chipset_tag_t bc = fdc->sc_bc;
	bus_io_handle_t ioh = fdc->sc_ioh;
	int read, head, sec, i, nblks;
	struct fd_type *type;
	struct fd_formb *finfo = NULL;

loop:
	/* Is there a transfer to this drive?  If not, deactivate drive. */
	fd = fdc->sc_drives.tqh_first;
	if (fd == NULL) {
		fdc->sc_state = DEVIDLE;
		return 1;
	}

	bp = fd->sc_q.b_actf;
	if (bp == NULL) {
		fd->sc_ops = 0;
		TAILQ_REMOVE(&fdc->sc_drives, fd, sc_drivechain);
		fd->sc_q.b_active = 0;
		goto loop;
	}

	if (bp->b_flags & B_FORMAT)
	    finfo = (struct fd_formb *)bp->b_data;

	switch (fdc->sc_state) {
	case DEVIDLE:
		fdc->sc_errors = 0;
		fd->sc_skip = 0;
		fd->sc_bcount = bp->b_bcount;
		fd->sc_blkno = bp->b_blkno / (FDC_BSIZE / DEV_BSIZE);
		untimeout(fd_motor_off, fd);
		if ((fd->sc_flags & FD_MOTOR_WAIT) != 0) {
			fdc->sc_state = MOTORWAIT;
			return 1;
		}
		if ((fd->sc_flags & FD_MOTOR) == 0) {
			/* Turn on the motor, being careful about pairing. */
			struct fd_softc *ofd = fdc->sc_fd[fd->sc_drive ^ 1];
			if (ofd && ofd->sc_flags & FD_MOTOR) {
				untimeout(fd_motor_off, ofd);
				ofd->sc_flags &= ~(FD_MOTOR | FD_MOTOR_WAIT);
			}
			fd->sc_flags |= FD_MOTOR | FD_MOTOR_WAIT;
			fd_set_motor(fdc, 0);
			fdc->sc_state = MOTORWAIT;
			/* Allow .25s for motor to stabilize. */
			timeout(fd_motor_on, fd, hz / 4);
			return 1;
		}
		/* Make sure the right drive is selected. */
		fd_set_motor(fdc, 0);

		/* fall through */
	case DOSEEK:
	doseek:
		if (fd->sc_cylin == bp->b_cylin)
			goto doio;

		out_fdc(bc, ioh, NE7CMD_SPECIFY);/* specify command */
		out_fdc(bc, ioh, fd->sc_type->steprate);
		out_fdc(bc, ioh, 6);		/* XXX head load time == 6ms */

		out_fdc(bc, ioh, NE7CMD_SEEK);	/* seek function */
		out_fdc(bc, ioh, fd->sc_drive);	/* drive number */
		out_fdc(bc, ioh, bp->b_cylin * fd->sc_type->step);

		fd->sc_cylin = -1;
		fdc->sc_state = SEEKWAIT;

		fd->sc_dk.dk_seek++;
		disk_busy(&fd->sc_dk);

		timeout(fdtimeout, fd, 4 * hz);
		return 1;

	case DOIO:
	doio:
		type = fd->sc_type;
		if (finfo)
		    fd->sc_skip = (char *)&(finfo->fd_formb_cylno(0)) -
			(char *)finfo;
		sec = fd->sc_blkno % type->seccyl;
		nblks = type->seccyl - sec;
		nblks = min(nblks, fd->sc_bcount / FDC_BSIZE);
		nblks = min(nblks, FDC_MAXIOSIZE / FDC_BSIZE);
		fd->sc_nblks = nblks;
		fd->sc_nbytes = finfo ? bp->b_bcount : nblks * FDC_BSIZE;
		head = sec / type->sectrac;
		sec -= head * type->sectrac;
#ifdef DIAGNOSTIC
		{int block;
		 block = (fd->sc_cylin * type->heads + head) * type->sectrac + sec;
		 if (block != fd->sc_blkno) {
			 printf("fdintr: block %d != blkno %d\n", block, fd->sc_blkno);
#ifdef DDB
			 Debugger();
#endif
		 }}
#endif
		read = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;
#ifdef NEWCONFIG
		at_dma(read, bp->b_data + fd->sc_skip, fd->sc_nbytes,
		    fdc->sc_drq);
#else
		isa_dmastart(read, bp->b_data + fd->sc_skip, fd->sc_nbytes,
		    fdc->sc_drq);
#endif
		bus_io_write_1(bc, ioh, fdctl, type->rate);
#ifdef FD_DEBUG
		printf("fdintr: %s drive %d track %d head %d sec %d nblks %d\n",
		    read ? "read" : "write", fd->sc_drive, fd->sc_cylin, head,
		    sec, nblks);
#endif
		if (finfo) {
                        /* formatting */
			if (out_fdc(bc, ioh, NE7CMD_FORMAT) < 0) {
			    fdc->sc_errors = 4;
			    fdretry(fd);
			    goto loop;
			}
                        out_fdc(bc, ioh, (head << 2) | fd->sc_drive);
                        out_fdc(bc, ioh, finfo->fd_formb_secshift);
                        out_fdc(bc, ioh, finfo->fd_formb_nsecs);
                        out_fdc(bc, ioh, finfo->fd_formb_gaplen);
                        out_fdc(bc, ioh, finfo->fd_formb_fillbyte);
		} else {
			if (read)
				out_fdc(bc, ioh, NE7CMD_READ);	/* READ */
			else
				out_fdc(bc, ioh, NE7CMD_WRITE);	/* WRITE */
			out_fdc(bc, ioh, (head << 2) | fd->sc_drive);
			out_fdc(bc, ioh, fd->sc_cylin);		/* track */
			out_fdc(bc, ioh, head);
			out_fdc(bc, ioh, sec + 1);		/* sector +1 */
			out_fdc(bc, ioh, type->secsize);	/* sector size */
			out_fdc(bc, ioh, type->sectrac);	/* sectors/track */
			out_fdc(bc, ioh, type->gap1);		/* gap1 size */
			out_fdc(bc, ioh, type->datalen);	/* data length */
		}
		fdc->sc_state = IOCOMPLETE;

		disk_busy(&fd->sc_dk);

		/* allow 2 seconds for operation */
		timeout(fdtimeout, fd, 2 * hz);
		return 1;				/* will return later */

	case SEEKWAIT:
		untimeout(fdtimeout, fd);
		fdc->sc_state = SEEKCOMPLETE;
		/* allow 1/50 second for heads to settle */
		timeout(fdcpseudointr, fdc, hz / 50);
		return 1;

	case SEEKCOMPLETE:
		disk_unbusy(&fd->sc_dk, 0);	/* no data on seek */

		/* Make sure seek really happened. */
		out_fdc(bc, ioh, NE7CMD_SENSEI);
		if (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 ||
		    cyl != bp->b_cylin * fd->sc_type->step) {
#ifdef FD_DEBUG
			fdcstatus(&fd->sc_dev, 2, "seek failed");
#endif
			fdretry(fd);
			goto loop;
		}
		fd->sc_cylin = bp->b_cylin;
		goto doio;

	case IOTIMEDOUT:
#ifdef NEWCONFIG
		at_dma_abort(fdc->sc_drq);
#else
		isa_dmaabort(fdc->sc_drq);
#endif
	case SEEKTIMEDOUT:
	case RECALTIMEDOUT:
	case RESETTIMEDOUT:
		fdretry(fd);
		goto loop;

	case IOCOMPLETE: /* IO DONE, post-analyze */
		untimeout(fdtimeout, fd);

		disk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid));

		if (fdcresult(fdc) != 7 || (st0 & 0xf8) != 0) {
#ifdef NEWCONFIG
			at_dma_abort(fdc->sc_drq);
#else
			isa_dmaabort(fdc->sc_drq);
#endif
#ifdef FD_DEBUG
			fdcstatus(&fd->sc_dev, 7, bp->b_flags & B_READ ?
			    "read failed" : "write failed");
			printf("blkno %d nblks %d\n",
			    fd->sc_blkno, fd->sc_nblks);
#endif
			fdretry(fd);
			goto loop;
		}
#ifdef NEWCONFIG
		at_dma_terminate(fdc->sc_drq);
#else
		read = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;
		isa_dmadone(read, bp->b_data + fd->sc_skip, fd->sc_nbytes,
		    fdc->sc_drq);
#endif
		if (fdc->sc_errors) {
			diskerr(bp, "fd", "soft error", LOG_PRINTF,
			    fd->sc_skip / FDC_BSIZE, (struct disklabel *)NULL);
			printf("\n");
			fdc->sc_errors = 0;
		}
		fd->sc_blkno += fd->sc_nblks;
		fd->sc_skip += fd->sc_nbytes;
		fd->sc_bcount -= fd->sc_nbytes;
		if (!finfo && fd->sc_bcount > 0) {
			bp->b_cylin = fd->sc_blkno / fd->sc_type->seccyl;
			goto doseek;
		}
		fdfinish(fd, bp);
		goto loop;

	case DORESET:
		/* try a reset, keep motor on */
		fd_set_motor(fdc, 1);
		delay(100);
		fd_set_motor(fdc, 0);
		fdc->sc_state = RESETCOMPLETE;
		timeout(fdtimeout, fd, hz / 2);
		return 1;			/* will return later */

	case RESETCOMPLETE:
		untimeout(fdtimeout, fd);
		/* clear the controller output buffer */
		for (i = 0; i < 4; i++) {
			out_fdc(bc, ioh, NE7CMD_SENSEI);
			(void) fdcresult(fdc);
		}

		/* fall through */
	case DORECAL:
		out_fdc(bc, ioh, NE7CMD_RECAL);	/* recalibrate function */
		out_fdc(bc, ioh, fd->sc_drive);
		fdc->sc_state = RECALWAIT;
		timeout(fdtimeout, fd, 5 * hz);
		return 1;			/* will return later */

	case RECALWAIT:
		untimeout(fdtimeout, fd);
		fdc->sc_state = RECALCOMPLETE;
		/* allow 1/30 second for heads to settle */
		timeout(fdcpseudointr, fdc, hz / 30);
		return 1;			/* will return later */

	case RECALCOMPLETE:
		out_fdc(bc, ioh, NE7CMD_SENSEI);
		if (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 || cyl != 0) {
#ifdef FD_DEBUG
			fdcstatus(&fd->sc_dev, 2, "recalibrate failed");
#endif
			fdretry(fd);
			goto loop;
		}
		fd->sc_cylin = 0;
		goto doseek;

	case MOTORWAIT:
		if (fd->sc_flags & FD_MOTOR_WAIT)
			return 1;		/* time's not up yet */
		goto doseek;

	default:
		fdcstatus(&fd->sc_dev, 0, "stray interrupt");
		return 1;
	}
#ifdef DIAGNOSTIC
	panic("fdintr: impossible");
#endif
#undef	st0
#undef	cyl
}

void
fdtimeout(arg)
	void *arg;
{
	struct fd_softc *fd = arg;
	struct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;
	int s;

	s = splbio();
#ifdef DEBUG
	log(LOG_ERR,"fdtimeout: state %d\n", fdc->sc_state);
#endif
	fdcstatus(&fd->sc_dev, 0, "timeout");

	if (fd->sc_q.b_actf)
		fdc->sc_state++;
	else
		fdc->sc_state = DEVIDLE;

	(void) fdintr(fdc);
	splx(s);
}

void
fdretry(fd)
	struct fd_softc *fd;
{
	struct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;
	struct buf *bp = fd->sc_q.b_actf;

	if (fd->sc_opts & FDOPT_NORETRY)
	    goto fail;
	switch (fdc->sc_errors) {
	case 0:
		/* try again */
		fdc->sc_state = DOSEEK;
		break;

	case 1: case 2: case 3:
		/* didn't work; try recalibrating */
		fdc->sc_state = DORECAL;
		break;

	case 4:
		/* still no go; reset the bastard */
		fdc->sc_state = DORESET;
		break;

	default:
	fail:
		diskerr(bp, "fd", "hard error", LOG_PRINTF,
		    fd->sc_skip / FDC_BSIZE, (struct disklabel *)NULL);
		printf(" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\n",
		    fdc->sc_status[0], NE7_ST0BITS,
		    fdc->sc_status[1], NE7_ST1BITS,
		    fdc->sc_status[2], NE7_ST2BITS,
		    fdc->sc_status[3], fdc->sc_status[4], fdc->sc_status[5]);

		bp->b_flags |= B_ERROR;
		bp->b_error = EIO;
		fdfinish(fd, bp);
	}
	fdc->sc_errors++;
}

int
fdioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
{
	struct fd_softc *fd = fd_cd.cd_devs[FDUNIT(dev)];
	struct disklabel buffer;
	int error;

	switch (cmd) {
	case MTIOCTOP:
		if (((struct mtop *)addr)->mt_op != MTOFFL)
			return EIO;
		return (0);
	case DIOCGDINFO:
		bzero(&buffer, sizeof(buffer));

		buffer.d_secpercyl = fd->sc_type->seccyl;
		buffer.d_type = DTYPE_FLOPPY;
		buffer.d_secsize = FDC_BSIZE;

		if (readdisklabel(dev, fdstrategy, &buffer, NULL) != NULL)
			return EINVAL;

		*(struct disklabel *)addr = buffer;
		return 0;

	case DIOCWLABEL:
		if ((flag & FWRITE) == 0)
			return EBADF;
		/* XXX do something */
		return 0;

	case DIOCWDINFO:
		if ((flag & FWRITE) == 0)
			return EBADF;

		error = setdisklabel(&buffer, (struct disklabel *)addr, 0, NULL);
		if (error)
			return error;

		error = writedisklabel(dev, fdstrategy, &buffer, NULL);
		return error;

        case FD_FORM:
                if((flag & FWRITE) == 0)
                        return EBADF;  /* must be opened for writing */
                else if(((struct fd_formb *)addr)->format_version !=
                        FD_FORMAT_VERSION)
                        return EINVAL; /* wrong version of formatting prog */
                else
                        return fdformat(dev, (struct fd_formb *)addr, p);
                break;

        case FD_GTYPE:                  /* get drive type */
                *(struct fd_type *)addr = *fd->sc_type;
		return 0;

        case FD_GOPTS:                  /* get drive options */
                *(int *)addr = fd->sc_opts;
                return 0;
                
        case FD_SOPTS:                  /* set drive options */
                fd->sc_opts = *(int *)addr;
		return 0;

	default:
		return ENOTTY;
	}

#ifdef DIAGNOSTIC
	panic("fdioctl: impossible");
#endif
}

int
fdformat(dev, finfo, p)
        dev_t dev;
        struct fd_formb *finfo;
        struct proc *p;
{
        int rv = 0, s;
	struct fd_softc *fd = fd_cd.cd_devs[FDUNIT(dev)];
	struct fd_type *type = fd->sc_type;
        struct buf *bp;

        /* set up a buffer header for fdstrategy() */
        bp = (struct buf *)malloc(sizeof(struct buf), M_TEMP, M_NOWAIT);
        if(bp == 0)
                return ENOBUFS;
        bzero((void *)bp, sizeof(struct buf));
        bp->b_flags = B_BUSY | B_PHYS | B_FORMAT;
        bp->b_proc = p;
        bp->b_dev = dev;

        /*
         * calculate a fake blkno, so fdstrategy() would initiate a
         * seek to the requested cylinder
         */
        bp->b_blkno = (finfo->cyl * (type->sectrac * type->heads)
                + finfo->head * type->sectrac) * FDC_BSIZE / DEV_BSIZE;

        bp->b_bcount = sizeof(struct fd_idfield_data) * finfo->fd_formb_nsecs;
        bp->b_data = (caddr_t)finfo;
        
#ifdef DEBUG
	printf("fdformat: blkno %x count %x\n", bp->b_blkno, bp->b_bcount);
#endif

        /* now do the format */
        fdstrategy(bp);

        /* ...and wait for it to complete */
        s = splbio();
        while(!(bp->b_flags & B_DONE))
        {
                rv = tsleep((caddr_t)bp, PRIBIO, "fdform", 0);
                if(rv == EWOULDBLOCK)
		    /*break*/;
        }
        splx(s);
        
        if(rv == EWOULDBLOCK) {
                /* timed out */
                rv = EIO;
		/* XXX what to do to the buf? it will eventually fall
		   out as finished, but ... ?*/
		/*biodone(bp);*/
	}
        if(bp->b_flags & B_ERROR)
                rv = bp->b_error;
        free(bp, M_TEMP);
        return rv;
}
@


1.23
log
@the Wall thing, you know
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.22 1996/09/23 15:31:53 mickey Exp $	*/
@


1.22
log
@propagte FD{UNIT,PART} definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.21 1996/09/01 20:58:26 downsj Exp $	*/
d62 1
d144 1
@


1.21
log
@initial commit of split fdc/fd drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.20 1996/08/29 18:03:27 downsj Exp $	*/
a78 3

#define FDUNIT(dev)	(minor(dev) / 8)
#define FDTYPE(dev)	(minor(dev) % 8)
@


1.20
log
@Add `flags' specification to floppy devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.19 1996/08/07 15:54:41 deraadt Exp $	*/
d78 2
a87 53
enum fdc_state {
	DEVIDLE = 0,
	MOTORWAIT,
	DOSEEK,
	SEEKWAIT,
	SEEKTIMEDOUT,
	SEEKCOMPLETE,
	DOIO,
	IOCOMPLETE,
	IOTIMEDOUT,
	DORESET,
	RESETCOMPLETE,
	RESETTIMEDOUT,
	DORECAL,
	RECALWAIT,
	RECALTIMEDOUT,
	RECALCOMPLETE,
};

/* software state, per controller */
struct fdc_softc {
	struct device sc_dev;		/* boilerplate */
	struct isadev sc_id;
	void *sc_ih;

	bus_chipset_tag_t sc_bc;	/* ISA chipset identifier */
	bus_io_handle_t   sc_ioh;	/* ISA io handle */

	int sc_drq;

	struct fd_softc *sc_fd[4];	/* pointers to children */
	TAILQ_HEAD(drivehead, fd_softc) sc_drives;
	enum fdc_state sc_state;
	int sc_errors;			/* number of retries so far */
	u_char sc_status[7];		/* copy of registers */
};

/* controller driver configuration */
int fdcprobe __P((struct device *, void *, void *));
int fdprint __P((void *, char *));
#ifdef NEWCONFIG
void fdcforceintr __P((void *));
#endif
void fdcattach __P((struct device *, struct device *, void *));

struct cfattach fdc_ca = {
	sizeof(struct fdc_softc), fdcprobe, fdcattach
};

struct cfdriver fdc_cd = {
	NULL, "fdc", DV_DULL
};

a148 1
struct fd_type *fd_nvtotype __P((char *, int, int));
a151 8
int fdcresult __P((struct fdc_softc *fdc));
int out_fdc __P((bus_chipset_tag_t bc, bus_io_handle_t ioh, u_char x));
void fdcstart __P((struct fdc_softc *fdc));
void fdcstatus __P((struct device *dv, int n, char *s));
void fdctimeout __P((void *arg));
void fdcpseudointr __P((void *arg));
int fdcintr __P((void *));
void fdcretry __P((struct fdc_softc *fdc));
d155 2
a156 156

int
fdcprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	register struct isa_attach_args *ia = aux;
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
	int rv;

	bc = ia->ia_bc;
	rv = 0;

	/* Map the i/o space. */
	if (bus_io_map(bc, ia->ia_iobase, FDC_NPORT, &ioh))
		return 0;

	/* reset */
	bus_io_write_1(bc, ioh, fdout, 0);
	delay(100);
	bus_io_write_1(bc, ioh, fdout, FDO_FRST);

	/* see if it can handle a command */
	if (out_fdc(bc, ioh, NE7CMD_SPECIFY) < 0)
		goto out;
	out_fdc(bc, ioh, 0xdf);
	out_fdc(bc, ioh, 2);

#ifdef NEWCONFIG
	if (ia->ia_iobase == IOBASEUNK || ia->ia_drq == DRQUNK)
		return 0;

	if (ia->ia_irq == IRQUNK) {
		ia->ia_irq = isa_discoverintr(fdcforceintr, aux);
		if (ia->ia_irq == IRQNONE)
			goto out;

		/* reset it again */
		bus_io_write_1(bc, ioh, fdout, 0);
		delay(100);
		bus_io_write_1(bc, ioh, fdout, FDO_FRST);
	}
#endif

	rv = 1;
	ia->ia_iosize = FDC_NPORT;
	ia->ia_msize = 0;

 out:
	bus_io_unmap(bc, ioh, FDC_NPORT);
	return rv;
}

#ifdef NEWCONFIG
/*
 * XXX This is broken, and needs fixing.  In general, the interface needs
 * XXX to change.
 */
void
fdcforceintr(aux)
	void *aux;
{
	struct isa_attach_args *ia = aux;
	int iobase = ia->ia_iobase;

	/* the motor is off; this should generate an error with or
	   without a disk drive present */
	out_fdc(bc, ioh, NE7CMD_SEEK);
	out_fdc(bc, ioh, 0);
	out_fdc(bc, ioh, 0);
}
#endif

/*
 * Arguments passed between fdcattach and fdprobe.
 */
struct fdc_attach_args {
	int fa_drive;
	int fa_flags;
	struct fd_type *fa_deftype;
};

/*
 * Print the location of a disk drive (called just before attaching the
 * the drive).  If `fdc' is not NULL, the drive was found but was not
 * in the system config file; print the drive name as well.
 * Return QUIET (config_find ignores this if the device was configured) to
 * avoid printing `fdN not configured' messages.
 */
int
fdprint(aux, fdc)
	void *aux;
	char *fdc;
{
	register struct fdc_attach_args *fa = aux;

	if (!fdc)
		printf(" drive %d", fa->fa_drive);
	return QUIET;
}

void
fdcattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct fdc_softc *fdc = (void *)self;
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
	struct isa_attach_args *ia = aux;
	struct fdc_attach_args fa;
	int type;

	bc = ia->ia_bc;

	/* Re-map the I/O space. */
	if (bus_io_map(bc, ia->ia_iobase, FDC_NPORT, &ioh))
		panic("fdcattach: couldn't map I/O ports");

	fdc->sc_bc = bc;
	fdc->sc_ioh = ioh;

	fdc->sc_drq = ia->ia_drq;
	fdc->sc_state = DEVIDLE;
	TAILQ_INIT(&fdc->sc_drives);

	printf("\n");

#ifdef NEWCONFIG
	at_setup_dmachan(fdc->sc_drq, FDC_MAXIOSIZE);
	isa_establish(&fdc->sc_id, &fdc->sc_dev);
#endif
	fdc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_BIO, fdcintr, fdc, fdc->sc_dev.dv_xname);

	/*
	 * The NVRAM info only tells us about the first two disks on the
	 * `primary' floppy controller.
	 */
	if (fdc->sc_dev.dv_unit == 0)
		type = mc146818_read(NULL, NVRAM_DISKETTE); /* XXX softc */
	else
		type = -1;

	/* physical limit: four drives per controller. */
	for (fa.fa_drive = 0; fa.fa_drive < 4; fa.fa_drive++) {
		fa.fa_flags = 0;
		if (type >= 0 && fa.fa_drive < 2)
			fa.fa_deftype = fd_nvtotype(fdc->sc_dev.dv_xname,
			    type, fa.fa_drive);
		else
			fa.fa_deftype = NULL;		/* unknown */
		(void)config_found(self, (void *)&fa, fdprint);
	}
}
d498 1
a498 1
		(void) fdcintr(fdc);
a502 45
fdcresult(fdc)
	struct fdc_softc *fdc;
{
	bus_chipset_tag_t bc = fdc->sc_bc;
	bus_io_handle_t ioh = fdc->sc_ioh;
	u_char i;
	int j = 100000,
	    n = 0;

	for (; j; j--) {
		i = bus_io_read_1(bc, ioh, fdsts) &
		    (NE7_DIO | NE7_RQM | NE7_CB);
		if (i == NE7_RQM)
			return n;
		if (i == (NE7_DIO | NE7_RQM | NE7_CB)) {
			if (n >= sizeof(fdc->sc_status)) {
				log(LOG_ERR, "fdcresult: overrun\n");
				return -1;
			}
			fdc->sc_status[n++] = bus_io_read_1(bc, ioh, fddata);
		}
	}
	log(LOG_ERR, "fdcresult: timeout\n");
	return -1;
}

int
out_fdc(bc, ioh, x)
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
	u_char x;
{
	int i = 100000;

	while ((bus_io_read_1(bc, ioh, fdsts) & NE7_DIO) && i-- > 0);
	if (i <= 0)
		return -1;
	while ((bus_io_read_1(bc, ioh, fdsts) & NE7_RQM) == 0 && i-- > 0);
	if (i <= 0)
		return -1;
	bus_io_write_1(bc, ioh, fddata, x);
	return 0;
}

int
d548 3
a550 3
void
fdcstart(fdc)
	struct fdc_softc *fdc;
d553 2
a554 9
#ifdef DIAGNOSTIC
	/* only got here if controller's drive queue was inactive; should
	   be in idle state */
	if (fdc->sc_state != DEVIDLE) {
		printf("fdcstart: not idle\n");
		return;
	}
#endif
	(void) fdcintr(fdc);
d557 6
a562 5
void
fdcstatus(dv, n, s)
	struct device *dv;
	int n;
	char *s;
a563 1
	struct fdc_softc *fdc = (void *)dv->dv_parent;
d565 2
a566 65
	if (n == 0) {
		out_fdc(fdc->sc_bc, fdc->sc_ioh, NE7CMD_SENSEI);
		(void) fdcresult(fdc);
		n = 2;
	}

	printf("%s: %s", dv->dv_xname, s);

	switch (n) {
	case 0:
		printf("\n");
		break;
	case 2:
		printf(" (st0 %b cyl %d)\n",
		    fdc->sc_status[0], NE7_ST0BITS,
		    fdc->sc_status[1]);
		break;
	case 7:
		printf(" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\n",
		    fdc->sc_status[0], NE7_ST0BITS,
		    fdc->sc_status[1], NE7_ST1BITS,
		    fdc->sc_status[2], NE7_ST2BITS,
		    fdc->sc_status[3], fdc->sc_status[4], fdc->sc_status[5]);
		break;
#ifdef DIAGNOSTIC
	default:
		printf("\nfdcstatus: weird size");
		break;
#endif
	}
}

void
fdctimeout(arg)
	void *arg;
{
	struct fdc_softc *fdc = arg;
	struct fd_softc *fd = fdc->sc_drives.tqh_first;
	int s;

	s = splbio();
#ifdef DEBUG
	log(LOG_ERR,"fdctimeout: state %d\n", fdc->sc_state);
#endif
	fdcstatus(&fd->sc_dev, 0, "timeout");

	if (fd->sc_q.b_actf)
		fdc->sc_state++;
	else
		fdc->sc_state = DEVIDLE;

	(void) fdcintr(fdc);
	splx(s);
}

void
fdcpseudointr(arg)
	void *arg;
{
	int s;

	/* Just ensure it has the right spl. */
	s = splbio();
	(void) fdcintr(arg);
	splx(s);
d569 3
d573 2
a574 2
fdcintr(arg)
	void *arg;
a575 1
	struct fdc_softc *fdc = arg;
d587 1
a587 1
	/* Is there a drive for the controller to do a transfer with? */
d591 1
a591 1
 		return 1;
a593 1
	/* Is there a transfer to this drive?  If not, deactivate drive. */
d653 1
a653 1
		timeout(fdctimeout, fdc, 4 * hz);
d674 1
a674 1
			 printf("fdcintr: block %d != blkno %d\n", block, fd->sc_blkno);
d690 1
a690 1
		printf("fdcintr: %s drive %d track %d head %d sec %d nblks %d\n",
d698 1
a698 1
			    fdcretry(fdc);
d725 1
a725 1
		timeout(fdctimeout, fdc, 2 * hz);
d729 1
a729 1
		untimeout(fdctimeout, fdc);
d745 1
a745 1
			fdcretry(fdc);
d760 1
a760 1
		fdcretry(fdc);
d764 1
a764 1
		untimeout(fdctimeout, fdc);
d780 1
a780 1
			fdcretry(fdc);
d812 1
a812 1
		timeout(fdctimeout, fdc, hz / 2);
d816 1
a816 1
		untimeout(fdctimeout, fdc);
d828 1
a828 1
		timeout(fdctimeout, fdc, 5 * hz);
d832 1
a832 1
		untimeout(fdctimeout, fdc);
d844 1
a844 1
			fdcretry(fdc);
d860 1
a860 1
	panic("fdcintr: impossible");
d867 2
a868 2
fdcretry(fdc)
	struct fdc_softc *fdc;
d870 21
d892 3
a894 4
	struct buf *bp;

	fd = fdc->sc_drives.tqh_first;
	bp = fd->sc_q.b_actf;
a928 21
}

int
fdsize(dev)
	dev_t dev;
{

	/* Swapping to floppies would not make sense. */
	return -1;
}

int
fddump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
{

	/* Not implemented. */
	return ENXIO;
@


1.19
log
@correct b_resid handling; pointed out by banshee@@gabriella.abattoir.com
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.18 1996/06/20 07:51:37 downsj Exp $	*/
d294 1
d362 1
d395 5
d441 18
a458 1
	/* XXX Allow `flags' to override device type? */
@


1.18
log
@fdformat support:
	patches taken from jtk's dosemu for NetBSD 1.1 and updated for
	the current driver.  Some of the code is based an older FreeBSD
	version of the driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.17 1996/06/09 19:40:28 deraadt Exp $	*/
d531 1
a531 1
		if (sz == 0) {
a532 1
			bp->b_resid = bp->b_bcount;
a533 1
		}
d572 1
@


1.17
log
@support MTIOCTOP's MTOFFL to mean "eject"
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.16 1996/06/01 09:36:52 deraadt Exp $	*/
d12 6
d59 1
d69 1
d81 3
d139 1
a139 19
/*
 * Floppies come in various flavors, e.g., 1.2MB vs 1.44MB; here is how
 * we tell them apart.
 */
struct fd_type {
	int	sectrac;	/* sectors per track */
	int	heads;		/* number of heads */
	int	seccyl;		/* sectors per cylinder */
	int	secsize;	/* size code for sectors */
	int	datalen;	/* data len when secsize = 0 */
	int	steprate;	/* step rate and head unload time */
	int	gap1;		/* gap len between sectors */
	int	gap2;		/* formatting gap */
	int	tracks;		/* total num of tracks */
	int	size;		/* size of disk in sectors */
	int	step;		/* steps per cylinder */
	int	rate;		/* transfer speed code */
	char	*name;
};
d162 1
d213 1
d517 2
a518 1
	    (bp->b_bcount % FDC_BSIZE) != 0) {
d780 1
d849 3
d888 1
d907 3
d964 3
d972 1
a972 1
		fd->sc_nbytes = nblks * FDC_BSIZE;
d999 26
a1024 12
		if (read)
			out_fdc(bc, ioh, NE7CMD_READ);	/* READ */
		else
			out_fdc(bc, ioh, NE7CMD_WRITE);	/* WRITE */
		out_fdc(bc, ioh, (head << 2) | fd->sc_drive);
		out_fdc(bc, ioh, fd->sc_cylin);		/* track */
		out_fdc(bc, ioh, head);
		out_fdc(bc, ioh, sec + 1);		/* sector +1 */
		out_fdc(bc, ioh, type->secsize);	/* sector size */
		out_fdc(bc, ioh, type->sectrac);	/* sectors/track */
		out_fdc(bc, ioh, type->gap1);		/* gap1 size */
		out_fdc(bc, ioh, type->datalen);	/* data length */
d1104 1
a1104 1
		if (fd->sc_bcount > 0) {
d1181 2
d1200 1
d1284 22
d1313 60
@


1.16
log
@all ports have dk_establish()
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.15 1996/05/25 22:17:48 deraadt Exp $	*/
d54 1
d1226 4
@


1.15
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.14 1996/05/07 07:22:16 deraadt Exp $	*/
a457 2
#ifdef NEWCONFIG
	/* XXX Need to do some more fiddling with sc_dk. */
a458 1
#endif
@


1.14
log
@sync with 0504; prototype changes
@
text
@d1 2
a2 2
/*	$OpenBSD: fd.c,v 1.13 1996/04/21 22:16:52 deraadt Exp $	*/
/*	$NetBSD: fd.c,v 1.88 1996/05/03 19:14:53 christos Exp $	*/
d58 1
a58 1
#include <machine/pio.h>
d60 1
d99 3
a101 1
	int sc_iobase;
d210 1
a210 1
int out_fdc __P((int iobase, u_char x));
d226 10
a235 1
	int iobase = ia->ia_iobase;
d238 1
a238 1
	outb(iobase + fdout, 0);
d240 1
a240 1
	outb(iobase + fdout, FDO_FRST);
d243 4
a246 4
	if (out_fdc(iobase, NE7CMD_SPECIFY) < 0)
		return 0;
	out_fdc(iobase, 0xdf);
	out_fdc(iobase, 2);
d249 1
a249 1
	if (iobase == IOBASEUNK || ia->ia_drq == DRQUNK)
d255 1
a255 1
			return 0;
d258 1
a258 1
		outb(iobase + fdout, 0);
d260 1
a260 1
		outb(iobase + fdout, FDO_FRST);
d264 1
d267 4
a270 1
	return 1;
d274 4
d287 3
a289 3
	out_fdc(iobase, NE7CMD_SEEK);
	out_fdc(iobase, 0);
	out_fdc(iobase, 0);
d326 2
d332 9
a340 1
	fdc->sc_iobase = ia->ia_iobase;
d383 2
a384 1
	int iobase = fdc->sc_iobase;
d398 1
a398 1
	outb(iobase + fdout, drive | FDO_FRST | FDO_MOEN(drive));
d401 2
a402 2
	out_fdc(iobase, NE7CMD_RECAL);
	out_fdc(iobase, drive);
d405 1
a405 1
	out_fdc(iobase, NE7CMD_SENSEI);
d419 1
a419 1
	outb(iobase + fdout, FDO_FRST);
d668 1
a668 1
	outb(fdc->sc_iobase + fdout, status);
d703 2
a704 1
	int iobase = fdc->sc_iobase;
d710 2
a711 1
		i = inb(iobase + fdsts) & (NE7_DIO | NE7_RQM | NE7_CB);
d719 1
a719 1
			fdc->sc_status[n++] = inb(iobase + fddata);
d727 3
a729 2
out_fdc(iobase, x)
	int iobase;
d734 1
a734 1
	while ((inb(iobase + fdsts) & NE7_DIO) && i-- > 0);
d737 1
a737 1
	while ((inb(iobase + fdsts) & NE7_RQM) == 0 && i-- > 0);
d740 1
a740 1
	outb(iobase + fddata, x);
d814 1
a814 1
		out_fdc(fdc->sc_iobase, NE7CMD_SENSEI);
d886 2
a887 1
	int iobase = fdc->sc_iobase;
d942 7
a948 7
		out_fdc(iobase, NE7CMD_SPECIFY);/* specify command */
		out_fdc(iobase, fd->sc_type->steprate);
		out_fdc(iobase, 6);		/* XXX head load time == 6ms */

		out_fdc(iobase, NE7CMD_SEEK);	/* seek function */
		out_fdc(iobase, fd->sc_drive);	/* drive number */
		out_fdc(iobase, bp->b_cylin * fd->sc_type->step);
d988 1
a988 1
		outb(iobase + fdctl, type->rate);
d995 1
a995 1
			out_fdc(iobase, NE7CMD_READ);	/* READ */
d997 9
a1005 9
			out_fdc(iobase, NE7CMD_WRITE);	/* WRITE */
		out_fdc(iobase, (head << 2) | fd->sc_drive);
		out_fdc(iobase, fd->sc_cylin);		/* track */
		out_fdc(iobase, head);
		out_fdc(iobase, sec + 1);		/* sector +1 */
		out_fdc(iobase, type->secsize);		/* sector size */
		out_fdc(iobase, type->sectrac);		/* sectors/track */
		out_fdc(iobase, type->gap1);		/* gap1 size */
		out_fdc(iobase, type->datalen);		/* data length */
d1025 1
a1025 1
		out_fdc(iobase, NE7CMD_SENSEI);
d1105 1
a1105 1
			out_fdc(iobase, NE7CMD_SENSEI);
d1111 2
a1112 2
		out_fdc(iobase, NE7CMD_RECAL);	/* recalibrate function */
		out_fdc(iobase, fd->sc_drive);
d1125 1
a1125 1
		out_fdc(iobase, NE7CMD_SENSEI);
@


1.13
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: fd.c,v 1.12 1996/04/18 17:12:13 niklas Exp $	*/
/*	$NetBSD: fd.c,v 1.87 1996/04/11 22:15:16 cgd Exp $	*/
a45 1
#include <sys/conf.h>
d59 1
d110 1
d215 1
d468 1
a468 1
inline struct fd_type *
d600 1
a600 1
fdread(dev, uio)
d603 1
d610 1
a610 1
fdwrite(dev, uio)
d613 1
d628 1
a628 1
	if (fd = fdc->sc_drives.tqh_first)
d711 1
a711 1
Fdopen(dev, flags)
d714 2
d743 1
a743 1
fdclose(dev, flags)
d746 2
a777 1
	int iobase = fdc->sc_iobase;
d853 1
a853 1
	int read, head, trac, sec, i, s, nblks;
d1181 1
a1181 1
fdioctl(dev, cmd, addr, flag)
d1186 1
@


1.12
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: fd.c,v 1.85 1996/03/04 04:01:03 mycroft Exp $	*/
d115 6
a120 2
struct cfdriver fdccd = {
	NULL, "fdc", fdcprobe, fdcattach, DV_DULL, sizeof(struct fdc_softc)
d186 6
a191 2
struct cfdriver fdcd = {
	NULL, "fd", fdprobe, fdattach, DV_DISK, sizeof(struct fd_softc)
d319 2
a320 2
	fdc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_BIO, fdcintr,
	    fdc, fdc->sc_dev.dv_xname);
d488 2
a489 2
	if (unit >= fdcd.cd_ndevs ||
	    (fd = fdcd.cd_devs[unit]) == 0 ||
d716 1
a716 1
	if (unit >= fdcd.cd_ndevs)
d718 1
a718 1
	fd = fdcd.cd_devs[unit];
d741 1
a741 1
	struct fd_softc *fd = fdcd.cd_devs[FDUNIT(dev)];
d1180 1
a1180 1
	struct fd_softc *fd = fdcd.cd_devs[FDUNIT(dev)];
@


1.11
log
@Fix back wrong patches.
@
text
@d1 2
a2 1
/*	$NetBSD: fd.c,v 1.84 1996/02/10 18:31:13 thorpej Exp $	*/
d930 1
a930 1
		read = bp->b_flags & B_READ;
d1022 1
a1022 1
		read = bp->b_flags & B_READ;
@


1.10
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d311 1
a311 1
	    fdc);
@


1.9
log
@Fix disk_unbusy panic (from NetBSD)
@
text
@d311 1
a311 1
	    fdc, fdc->sc_dev.dv_xname);
d934 2
a935 2
		isadma_start(bp->b_data + fd->sc_skip, fd->sc_nbytes,
		    fdc->sc_drq, read ? ISADMA_START_READ : ISADMA_START_WRITE);
d990 1
a990 1
		isadma_abort(fdc->sc_drq);
d1007 1
a1007 1
			isadma_abort(fdc->sc_drq);
d1021 3
a1023 1
		isadma_done(fdc->sc_drq);
@


1.8
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 1
a1 1
/*	$NetBSD: fd.c,v 1.82 1996/01/07 22:02:28 thorpej Exp $	*/
d1112 1
a1112 2
		fdc->sc_state = SEEKCOMPLETE;
		disk_busy(&fd->sc_dk);
@


1.7
log
@hannken: Fix disk_unbusy panic when booting from floppies
@
text
@d311 1
a311 1
	    fdc);
@


1.6
log
@from netbsd:
Balance calls to disk_busy() and disk_unbusy() properly to avoid
dk_busy < 0 panics.  Count seeks.
@
text
@d1113 1
@


1.5
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@a551 3
	/* Instrumentation. */
	disk_busy(&fd->sc_dk);

a581 2
	disk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid));

d901 4
d956 3
d971 2
d1000 3
@


1.4
log
@from perry:
fixed my own pr 1758 -- the floppy drive motor was not being turned off
at halt time, especially if a floppy was mounted. Added a shutdown hook
to turn off the motor. Per a request by mycroft, the cookie from the hook
is saved in a new member I added to the fd_softc structure.
@
text
@d1 1
a1 1
/*	$NetBSD: fd.c,v 1.79 1995/08/21 06:56:14 mycroft Exp $	*/
d152 1
a152 1
	struct dkdevice sc_dk;
d408 5
d414 2
d552 3
d584 3
@


1.3
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
@
text
@d170 2
d413 2
@


1.2
log
@i386 isa bounce buffers by hannken@@eis.cs.tu-bs.de
@
text
@d308 2
a309 2
	fdc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE, ISA_IPL_BIO,
	    fdcintr, fdc);
@


1.1
log
@Initial revision
@
text
@d918 2
a919 2
		isa_dmastart(read, bp->b_data + fd->sc_skip, fd->sc_nbytes,
		    fdc->sc_drq);
d969 1
a969 1
		isa_dmaabort(fdc->sc_drq);
d983 1
a983 1
			isa_dmaabort(fdc->sc_drq);
d997 1
a997 3
		read = bp->b_flags & B_READ;
		isa_dmadone(read, bp->b_data + fd->sc_skip, fd->sc_nbytes,
		    fdc->sc_drq);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
