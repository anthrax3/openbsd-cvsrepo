head	1.29;
access;
symbols
	SMP_SYNC_A:1.29
	SMP_SYNC_B:1.29
	UBC_SYNC_A:1.29
	UBC_SYNC_B:1.29
	OPENBSD_2_8:1.27.0.2
	OPENBSD_2_8_BASE:1.27
	OPENBSD_2_7:1.25.0.4
	OPENBSD_2_7_BASE:1.25
	SMP:1.25.0.2
	SMP_BASE:1.25
	kame_19991208:1.24
	OPENBSD_2_6:1.23.0.2
	OPENBSD_2_6_BASE:1.23
	OPENBSD_2_5:1.21.0.4
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.21.0.2
	OPENBSD_2_4_BASE:1.21
	OPENBSD_2_3:1.18.0.2
	OPENBSD_2_3_BASE:1.18
	OPENBSD_2_2:1.17.0.2
	OPENBSD_2_2_BASE:1.17
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2001.02.21.20.40.01;	author jbm;	state dead;
branches;
next	1.28;

1.28
date	2000.12.19.06.58.39;	author csapuntz;	state Exp;
branches;
next	1.27;

1.27
date	2000.09.21.15.52.47;	author mickey;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2000.05.16.18.12.14;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2000.01.15.17.40.20;	author deraadt;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	99.11.22.07.13.56;	author matthieu;	state Exp;
branches;
next	1.23;

1.23
date	99.05.22.02.11.25;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	99.05.21.18.52.09;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	98.08.07.20.34.27;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	98.06.29.02.13.00;	author downsj;	state Exp;
branches;
next	1.19;

1.19
date	98.06.27.22.42.47;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	98.04.01.20.21.00;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	97.08.29.22.49.06;	author kstailey;	state Exp;
branches;
next	1.16;

1.16
date	97.08.29.22.40.16;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	97.05.30.19.51.27;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.05.30.19.31.26;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.05.30.07.35.00;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.10.13.04.25.12;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	96.10.13.00.55.49;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	96.08.17.05.57.23;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.25.22.17.52;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.10.12.46.22;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.17.02;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.18.17.12.20;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.03.20.00.31.08;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.19.21.09.40;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.20.04.35.35;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.10.43;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.38;	author deraadt;	state Exp;
branches;
next	;

1.25.2.1
date	2001.04.18.16.07.55;	author niklas;	state dead;
branches;
next	;

1.27.2.1
date	2000.12.22.19.48.45;	author jason;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Remove old (non-wsmouse) pms driver. aaron@@ ok.
@
text
@/*	$OpenBSD: pms.c,v 1.28 2000/12/19 06:58:39 csapuntz Exp $	*/
/*	$NetBSD: pms.c,v 1.29 1996/05/12 23:12:42 mycroft Exp $	*/

/*-
 * Copyright (c) 1996, Jason Downs.
 * Copyright (c) 1994 Charles Hannum.
 * Copyright (c) 1992, 1993 Erik Forsberg.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
 * NO EVENT SHALL I BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * XXXX
 * This is a hack.  This driver should really be combined with the
 * keyboard driver, since they go through the same buffer and use the
 * same I/O ports.  Frobbing the mouse and keyboard at the same time
 * may result in dropped characters and/or corrupted mouse events.
 */

#include "pms.h"
#if NPMS > 1
#error Only one PS/2 style mouse may be configured into your system.
#endif

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/select.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/vnode.h>
#include <sys/device.h>

#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/pio.h>
#include <machine/mouse.h>
#include <machine/conf.h>

#include <dev/isa/isavar.h>
#include <dev/rndvar.h>

#define	PMS_DATA	0x60	/* offset for data port, read-write */
#define	PMS_CNTRL	0x64	/* offset for control port, write-only */
#define	PMS_STATUS	0x64	/* offset for status port, read-only */
#define	PMS_NPORTS	8

/* status bits */
#define	PMS_OBUF_FULL	0x01
#define	PMS_IBUF_FULL	0x02

/* controller commands */
#define	PMS_INT_ENABLE	0x47	/* enable controller interrupts */
#define	PMS_INT_DISABLE	0x45	/* disable controller interrupts */
#define	PMS_AUX_ENABLE	0xa8	/* enable auxiliary port */
#define	PMS_AUX_DISABLE	0xa7	/* disable auxiliary port */
#define	PMS_AUX_TEST	0xa9	/* test auxiliary port */

#define	PMS_8042_CMD	0x65

/* mouse commands */
#define	PMS_SET_SCALE11	0xe6	/* set scaling 1:1 */
#define	PMS_SET_SCALE21 0xe7	/* set scaling 2:1 */
#define	PMS_SET_RES	0xe8	/* set resolution */
#define	PMS_GET_SCALE	0xe9	/* get scaling factor */
#define	PMS_SET_STREAM	0xea	/* set streaming mode */
#define	PMS_SET_SAMPLE	0xf3	/* set sampling rate */
#define	PMS_DEV_ENABLE	0xf4	/* mouse on */
#define	PMS_DEV_DISABLE	0xf5	/* mouse off */
#define	PMS_RESET	0xff	/* reset */

#define	PMS_CHUNK	128	/* chunk size for read */
#define	PMS_BSIZE	1020	/* buffer size */

struct pms_softc {		/* driver status information */
	struct device sc_dev;
	void *sc_ih;

	struct clist sc_q;
	struct selinfo sc_rsel;
	struct proc *sc_io;	/* process that opened pms (can get SIGIO) */
	char   sc_async;	/* send SIGIO on input ready */
	u_char sc_state;	/* mouse driver state */
#define	PMS_OPEN	0x01	/* device is open */
#define	PMS_ASLP	0x02	/* waiting for mouse data */
	u_char sc_flags;	/* mouse driver flags */
#define PMS_RAW		0x01	/* device is in raw mode */
	u_char sc_status;	/* mouse button status */
	int sc_x, sc_y;		/* accumulated motion in the X,Y axis */
};

int pmsprobe __P((struct device *, void *, void *));
void pmsattach __P((struct device *, struct device *, void *));
int pmsintr __P((void *));

struct cfattach pms_ca = {
	sizeof(struct pms_softc), pmsprobe, pmsattach,
};

struct cfdriver pms_cd = {
	NULL, "pms", DV_TTY
};

#define	PMSUNIT(dev)	(minor(dev) / 2)
#define PMSTYPE(dev)	(minor(dev) % 2)

#define	FLUSHQ(q) {							\
	if ((q)->c_cc)							\
		ndflush(q, (q)->c_cc);					\
}

static __inline void pms_flush __P((void));
static __inline void pms_dev_cmd __P((u_char));
static __inline void pms_pit_cmd __P((u_char));
static __inline void pms_aux_cmd __P((u_char));

static __inline void
pms_flush()
{
	u_char c;

	while ((c = inb(PMS_STATUS) & 0x03) != 0)
		if ((c & PMS_OBUF_FULL) == PMS_OBUF_FULL) {
			/* XXX - delay is needed to prevent some keyboards from
			   wedging when the system boots */
			delay(6);
			(void) inb(PMS_DATA);
		}
}

static __inline void
pms_dev_cmd(value)
	u_char value;
{

	pms_flush();
	outb(PMS_CNTRL, 0xd4);
	pms_flush();
	outb(PMS_DATA, value);
}

static __inline void
pms_aux_cmd(value)
	u_char value;
{

	pms_flush();
	outb(PMS_CNTRL, value);
}

static __inline void
pms_pit_cmd(value)
	u_char value;
{

	pms_flush();
	outb(PMS_CNTRL, 0x60);
	pms_flush();
	outb(PMS_DATA, value);
}

/*
 * XXX needs more work yet.  We should have a `pckbd_attach_args' that
 * provides the parent's io port and our irq.
 */
int
pmsprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;
	u_char x;

	/*
	 * We only attach to the keyboard controller via
	 * the console drivers. (We really wish we could be the
	 * child of a real keyboard controller driver.)
	 */
	if ((parent == NULL) ||
	   ((strcmp(parent->dv_cfdata->cf_driver->cd_name, "pc") != 0) &&
	    (strcmp(parent->dv_cfdata->cf_driver->cd_name, "vt") != 0)))
		return (0);

	/* Can't wildcard IRQ. */
	if (cf->cf_loc[0] == -1)
		return (0);

	/*pms_dev_cmd(PMS_RESET);*/
	pms_aux_cmd(PMS_AUX_TEST);
	delay(4000);
	x = inb(PMS_DATA);
	pms_pit_cmd(PMS_INT_DISABLE);
	if (x & 0x04)
		return (0);

	/* Make sure the IRQ is available. */
	if (!isa_intr_check((isa_chipset_tag_t)0, cf->cf_loc[0], IST_EDGE)) {
		printf ("%s%d: irq %d already in use\n", cf->cf_driver->cd_name,
		    cf->cf_unit, cf->cf_loc[0]);
		return (0);
	}

	return (1);
}

void
pmsattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pms_softc *sc = (void *)self;
	int irq = self->dv_cfdata->cf_loc[0];
	isa_chipset_tag_t ic = aux;			/* XXX */

	printf(" irq %d", irq);
#ifdef INTELLIMOUSE
	printf(": IntelliMouse");
#endif
	printf("\n");

	/* Other initialization was done by pmsprobe. */
	sc->sc_state = 0;

	sc->sc_ih = isa_intr_establish(ic, irq, IST_EDGE, IPL_TTY,
	    pmsintr, sc, sc->sc_dev.dv_xname);

	pms_pit_cmd(PMS_INT_ENABLE);
}

int
pmsopen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	int unit = PMSUNIT(dev);
	struct pms_softc *sc;

	if (unit >= pms_cd.cd_ndevs)
		return ENXIO;
	sc = pms_cd.cd_devs[unit];
	if (!sc)
		return ENXIO;

	if (sc->sc_state & PMS_OPEN)
		return EBUSY;

	if (clalloc(&sc->sc_q, PMS_BSIZE, 0) == -1)
		return ENOMEM;

	sc->sc_state |= PMS_OPEN;
	sc->sc_status = 0;
	sc->sc_flags = (PMSTYPE(dev) ? PMS_RAW : 0);
	sc->sc_x = sc->sc_y = 0;
	sc->sc_async = 0;
	sc->sc_io = p;

	/* Enable interrupts. */
	pms_dev_cmd(PMS_DEV_ENABLE);
	pms_aux_cmd(PMS_AUX_ENABLE);
#if 0
	pms_dev_cmd(PMS_SET_RES);
	pms_dev_cmd(3);		/* 8 counts/mm */
	pms_dev_cmd(PMS_SET_SCALE21);
	pms_dev_cmd(PMS_SET_SAMPLE);
	pms_dev_cmd(100);	/* 100 samples/sec */
	pms_dev_cmd(PMS_SET_STREAM);
#endif
#ifdef INTELLIMOUSE
	/* The Micro$oft IntelliMouse has a wheel that you can turn or
	 * click stuck in between the left and right buttons.
	 * By default this mouse acts like a two-button PS/2 mouse.
	 * If you set the sampling rate to 200, then 100, then 80
	 * it changes to a 4-byte-per-packet format and the wheel
	 * acts like a middle button if you click it.  Turing the
	 * wheel modifies the fourth byte in the packet.
	 */
	pms_dev_cmd(PMS_SET_SAMPLE);
	pms_dev_cmd(200);	/* 200 samples/sec */
	pms_dev_cmd(PMS_SET_SAMPLE);
	pms_dev_cmd(100);	/* 100 samples/sec */
	pms_dev_cmd(PMS_SET_SAMPLE);
	pms_dev_cmd(80);	/* 80 samples/sec */
#endif
	pms_pit_cmd(PMS_INT_ENABLE);

	return 0;
}

int
pmsclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	struct pms_softc *sc = pms_cd.cd_devs[PMSUNIT(dev)];

	/* Disable interrupts. */
	/* pms_dev_cmd(PMS_DEV_DISABLE); */
#if 0
	pms_pit_cmd(PMS_INT_DISABLE);
	pms_aux_cmd(PMS_AUX_DISABLE);
#endif
	sc->sc_state &= ~PMS_OPEN;
	sc->sc_io = NULL;

	clfree(&sc->sc_q);

	return 0;
}

int
pmsread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct pms_softc *sc = pms_cd.cd_devs[PMSUNIT(dev)];
	int s;
	int error = 0;
	size_t length;
	u_char buffer[PMS_CHUNK];

	/* Block until mouse activity occured. */

	s = spltty();
	while (sc->sc_q.c_cc == 0) {
		if (flag & IO_NDELAY) {
			splx(s);
			return EWOULDBLOCK;
		}
		sc->sc_state |= PMS_ASLP;
		error = tsleep((caddr_t)sc, PZERO | PCATCH, "pmsrea", 0);
		if (error) {
			sc->sc_state &= ~PMS_ASLP;
			splx(s);
			return error;
		}
	}
	splx(s);

	/* Transfer as many chunks as possible. */

	while (sc->sc_q.c_cc > 0 && uio->uio_resid > 0) {
		length = min(sc->sc_q.c_cc, uio->uio_resid);
		if (length > sizeof(buffer))
			length = sizeof(buffer);

		/* Remove a small chunk from the input queue. */
		(void) q_to_b(&sc->sc_q, buffer, length);

		/* Copy the data to the user process. */
		if ((error = uiomove(buffer, length, uio)) != 0)
			break;
	}

	return error;
}

int
pmswrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct pms_softc *sc = pms_cd.cd_devs[PMSUNIT(dev)];
	int i, n;
	int error;
	int s;
	u_char wrbuf[32];


	if (!(sc->sc_flags & PMS_RAW)) 
	    return ENODEV;
	
	error = 0;
	/* Only allow a small number of bytes per write. */
	n = min(sizeof(wrbuf), uio->uio_resid);
	error = uiomove(wrbuf, n, uio);
	if (error)
		return error;
	s = spltty();
	for(i = 0; i < n; i++)
		pms_dev_cmd(wrbuf[i]);
	splx(s);

	return error;
}

int
pmsioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
{
	struct pms_softc *sc = pms_cd.cd_devs[PMSUNIT(dev)];
	struct mouseinfo info;
	int s;
	int error;

	error = 0;
	switch (cmd) {

	case FIONBIO:		/* we will remove this someday (soon???) */
		return (0);

	case FIOASYNC:
		sc->sc_async = *(int *)addr != 0;
		break;

	case TIOCSPGRP:
		if (*(int *)addr != sc->sc_io->p_pgid)
			return (EPERM);
		break;

	case MOUSEIOCREAD:
		s = spltty();

		info.status = sc->sc_status;
		if (sc->sc_x || sc->sc_y)
			info.status |= MOVEMENT;

		if (sc->sc_x > 127)
			info.xmotion = 127;
		else if (sc->sc_x < -127)
			/* Bounding at -127 avoids a bug in XFree86. */
			info.xmotion = -127;
		else
			info.xmotion = sc->sc_x;

		if (sc->sc_y > 127)
			info.ymotion = 127;
		else if (sc->sc_y < -127)
			info.ymotion = -127;
		else
			info.ymotion = sc->sc_y;

		/* Reset historical information. */
		sc->sc_x = sc->sc_y = 0;
		sc->sc_status &= ~BUTCHNGMASK;
		ndflush(&sc->sc_q, sc->sc_q.c_cc);

		splx(s);
		error = copyout(&info, addr, sizeof(struct mouseinfo));
		break;
	case MOUSEIOCSRAW:
		if (!(sc->sc_flags & PMS_RAW)) {
			FLUSHQ(&sc->sc_q);
			sc->sc_flags |= PMS_RAW;
		}
		break;
	case MOUSEIOCSCOOKED:
		if (sc->sc_flags & PMS_RAW) {
			FLUSHQ(&sc->sc_q);
			sc->sc_flags &= ~PMS_RAW;
		}
		break;
	default:
		error = EINVAL;
		break;
	}

	return error;
}

/* Masks for the first byte of a packet */
#define PS2LBUTMASK 0x01
#define PS2RBUTMASK 0x02
#define PS2MBUTMASK 0x04

int
pmsintr(arg)
	void *arg;
{
	struct pms_softc *sc = arg;
	static int state = 0;
	static u_char buttons;
	u_char changed;
	static char dx, dy;
	u_char buffer[5];

	if ((sc->sc_state & PMS_OPEN) == 0) {
		/* Interrupts are not expected.  Discard the byte. */
		pms_flush();
		return 0;
	}

	if (!(sc->sc_flags & PMS_RAW)) {
		switch (state) {
		case 0:
			buttons = inb(PMS_DATA);
			if ((buttons & 0xc0) == 0)
				++state;
			break;
		case 1:
			dx = inb(PMS_DATA);
			/* Bounding at -127 avoids a bug in XFree86. */
			dx = (dx == -128) ? -127 : dx;
			++state;
			break;
		case 2:
			dy = inb(PMS_DATA);
			dy = (dy == -128) ? -127 : dy;
#ifdef INTELLIMOUSE
			++state;
#else
			state = 0;
#endif
			buttons = ((buttons & PS2LBUTMASK) << 2) |
			  	((buttons & (PS2RBUTMASK | PS2MBUTMASK)) >> 1);
			changed = ((buttons ^ sc->sc_status) & BUTSTATMASK) << 3;
			sc->sc_status = buttons |
			    (sc->sc_status & ~BUTSTATMASK) | changed;

			if (dx || dy || changed) {
				/* Update accumulated movements. */
				sc->sc_x += dx;
				sc->sc_y += dy;

				/* Add this event to the queue. */
				buffer[0] = 0x80 | (buttons ^ BUTSTATMASK);
				buffer[1] = dx;
				buffer[2] = dy;
				buffer[3] = buffer[4] = 0;
				(void) b_to_q(buffer, sizeof buffer, &sc->sc_q);
				add_mouse_randomness(*(u_int32_t*)buffer);

				if (sc->sc_state & PMS_ASLP) {
					sc->sc_state &= ~PMS_ASLP;
					wakeup((caddr_t)sc);
				}
				selwakeup(&sc->sc_rsel);
				if (sc->sc_async) {
				    	psignal(sc->sc_io, SIGIO); 
				}

			}

			break;
#ifdef INTELLIMOUSE		/* discard fourth "wheel" byte */
		case 3:
			state = 0;
			inb(PMS_DATA);
			break;
#endif
		}
	} else {
		buffer[0] = inb(PMS_DATA);
		(void) b_to_q(buffer, 1, &sc->sc_q);
		add_mouse_randomness(*(u_int32_t*)buffer);
		
		if (sc->sc_state & PMS_ASLP) {
			sc->sc_state &= ~PMS_ASLP;
			wakeup((caddr_t)sc);
		}
		selwakeup(&sc->sc_rsel);
		if (sc->sc_async) {
		    	psignal(sc->sc_io, SIGIO); 
		}

	}

	return -1;
}

int
pmsselect(dev, rw, p)
	dev_t dev;
	int rw;
	struct proc *p;
{
	struct pms_softc *sc = pms_cd.cd_devs[PMSUNIT(dev)];
	int s;
	int ret;

	if (rw == FWRITE)
		return 0;

	s = spltty();
	if (!sc->sc_q.c_cc) {
		selrecord(p, &sc->sc_rsel);
		ret = 0;
	} else
		ret = 1;
	splx(s);

	return ret;
}
@


1.28
log
@

This fixes keyboard lock-ups I was getting wiggling the mouse in
console mode while using my omnicube KVM switch.

The keyboard lock-ups were caused by the keyboard/mouse interface controller's
input buffer filling up. This was caused because the mouse was
sending data to the computer and the pms driver wasn't draining it.

The driver used to rely on the fact that it could disable the mouse
device when the mouse driver was closed. Disabling the mouse device
prevents it from sending data to the computer.

At the same time pms disabled the mouse device, pms disabled interrupt
notification of the arrival of new data.

This regime doesn't work so well with KVM switches which re-enable the mouse.
In this case, the mouse will send data to the computer but the keyboard/moust
interface controller won't raise an interrupt (because pms disabled
interrupts). pms will never read from the input buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.27 2000/09/21 15:52:47 mickey Exp $	*/
@


1.27
log
@oops forgot the other case in the pmsintr for add_mouse_randomness() call
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.26 2000/05/16 18:12:14 mickey Exp $	*/
d247 2
d323 1
d326 1
a326 1

@


1.27.2.1
log
@Pull in patch from current:
Errata (015):
Some machines locked up while trying to use the mouse in console mode.  This
patch solves that problem.
Fix (csapuntz):
This fixes keyboard lock-ups I was getting wiggling the mouse in
console mode while using my omnicube KVM switch.

The keyboard lock-ups were caused by the keyboard/mouse interface controller's
input buffer filling up. This was caused because the mouse was
sending data to the computer and the pms driver wasn't draining it.

The driver used to rely on the fact that it could disable the mouse
device when the mouse driver was closed. Disabling the mouse device
prevents it from sending data to the computer.

At the same time pms disabled the mouse device, pms disabled interrupt
notification of the arrival of new data.

This regime doesn't work so well with KVM switches which re-enable the mouse.
In this case, the mouse will send data to the computer but the keyboard/moust
interface controller won't raise an interrupt (because pms disabled
interrupts). pms will never read from the input buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.28 2000/12/19 06:58:39 csapuntz Exp $	*/
a246 2

	pms_pit_cmd(PMS_INT_ENABLE);
a320 1
#if 0
d323 1
a323 1
#endif
@


1.26
log
@supply entropy from mouse; provos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.25 2000/01/15 17:40:20 deraadt Exp $	*/
d572 1
@


1.25
log
@set the delay to 4000.  this is needed by the Compaq AP400; kos@@flirble.org
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.24 1999/11/22 07:13:56 matthieu Exp $	*/
d62 1
d548 1
@


1.25.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.25 2000/01/15 17:40:20 deraadt Exp $	*/
@


1.24
log
@add support for asynchronous I/O (through SIGIO)
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.23 1999/05/22 02:11:25 deraadt Exp $	*/
d210 1
a210 1
	delay(2000);
@


1.23
log
@reportedly 2000 works also
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.22 1999/05/21 18:52:09 deraadt Exp $	*/
d51 1
d101 2
d274 2
d324 1
d424 13
d553 4
d576 4
@


1.22
log
@longer delay in pms probe for thinkpads; joshp@@ioactive.com
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.21 1998/08/07 20:34:27 deraadt Exp $	*/
d207 1
a207 1
	delay(6000);
@


1.21
log
@fix PMS_INT_DISABLE
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.20 1998/06/29 02:13:00 downsj Exp $	*/
d207 1
a207 1
	delay(1000);
@


1.20
log
@Add and use isa_intr_check().
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.18 1998/04/01 20:21:00 matthieu Exp $	*/
d73 1
a73 1
#define	PMS_INT_DISABLE	0x65	/* disable controller interrupts */
@


1.19
log
@have pmsprobe() attempt interrupt establishment; fail probe if interrupt  in use
@
text
@a188 1
	void *ih;
d211 1
a211 1
		return 0;
d213 6
a218 4
	ih = isa_intr_establish(aux, cf->cf_loc[0],
	    IST_EDGE, IPL_TTY, pmsintr, NULL, pms_cd.cd_name);
	if (ih == NULL)
		return 0;
d220 1
a220 2
	isa_intr_disestablish(aux, ih);
	return 1;
@


1.18
log
@Add a write function and make the raw mode real raw in the PS/2 driver
to support extended PS/2 protocol under XFree86.
From NetBSD port-i386/5130 by Lennart Augustsson <augustss@@cs.chalmers.se>,
adapted to OpenBSD by myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.17 1997/08/29 22:49:06 kstailey Exp $	*/
d189 1
d214 6
@


1.17
log
@Print "IntelliMouse" at probe time if "option INTELLIMOUSE" is in da house.
Move init code to pmsopen() since pmsclose() clobbers it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.16 1997/08/29 22:40:16 kstailey Exp $	*/
d367 30
a537 1
		/* read data port */
a538 43

		/* emulate old state machine for the ioctl's sake. */
		switch (state) {
		case 0:
			buttons = buffer[0];
			if ((buttons & 0xc0) == 0)
				++state;
			break;
		case 1:
			dx = buffer[0];
			/* Bounding at -127 avoids a bug in XFree86. */
			dx = (dx == -128) ? -127 : dx;
			++state;
			break;
		case 2:
			dy = buffer[0];
			dy = (dy == -128) ? -127 : dy;
#ifdef INTELLIMOUSE
			++state;
#else
			state = 0;
#endif

			buttons = ((buttons & PS2LBUTMASK) << 2) |
			  	((buttons & (PS2RBUTMASK | PS2MBUTMASK)) >> 1);
			changed = ((buttons ^ sc->sc_status) & BUTSTATMASK) << 3;
			sc->sc_status = buttons |
			    (sc->sc_status & ~BUTSTATMASK) | changed;

			if (dx || dy || changed) {
				/* Update accumulated movements. */
				sc->sc_x += dx;
				sc->sc_y += dy;
			}
			break;
#ifdef INTELLIMOUSE		/* discard fourth "wheel" byte */
		case 3:
			state = 0;
			return 0; /* XXX 0? -1? */
#endif
		}

		/* add raw data to the queue. */
d540 1
a540 1

@


1.16
log
@M$ IntelliMouse support
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.15 1997/05/30 19:51:27 deraadt Exp $	*/
d225 5
a229 1
	printf(" irq %d\n", irq);
a235 17

#ifdef INTELLIMOUSE
	/* The Micro$oft IntelliMouse has a wheel that you can turn or
	 * click stuck in between the left and right buttons.
	 * By default this mouse acts like a two-button PS/2 mouse.
	 * If you set the sampling rate to 200, then 100, then 80
	 * it changes to a 4-byte-per-packet format and the wheel
	 * acts like a middle button if you click it.  Turing the
	 * wheel modifies the fourth byte in the packet.
	 */
	pms_dev_cmd(PMS_SET_SAMPLE);
	pms_dev_cmd(200);	/* 200 samples/sec */
	pms_dev_cmd(PMS_SET_SAMPLE);
	pms_dev_cmd(100);	/* 100 samples/sec */
	pms_dev_cmd(PMS_SET_SAMPLE);
	pms_dev_cmd(80);	/* 80 samples/sec */
#endif
d275 16
@


1.15
log
@sigh
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.12 1996/10/13 04:25:12 downsj Exp $	*/
d232 17
d466 3
d470 1
a470 1

d474 2
a475 1
			sc->sc_status = buttons | (sc->sc_status & ~BUTSTATMASK) | changed;
d497 6
d524 3
d528 1
d533 2
a534 1
			sc->sc_status = buttons | (sc->sc_status & ~BUTSTATMASK) | changed;
d542 5
@


1.14
log
@argh
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.13 1997/05/30 07:35:00 deraadt Exp $	*/
a436 10
			/* Re-enable if mouse is disconnected and reconnected. */
			if (buttons == 0xaa) {
				pms_dev_cmd(PMS_DEV_ENABLE);
				break;
			}

			/* For GlidePoint tapping feature. treat as LBUTTON */
			if ((buttons & (PS2LBUTMASK|PS2RBUTMASK|PS2MBUTMASK)) == 0)
				buttons |= PS2LBUTMASK;

@


1.13
log
@glidepoint & hot-swap support; koji@@math.human.nagoya-u.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.12 1996/10/13 04:25:12 downsj Exp $	*/
d444 1
a444 1
			if ((buttons & PS2BUTMASK) == 0)
@


1.12
log
@Clean up ioctl and flush the input buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.11 1996/10/13 00:55:49 downsj Exp $	*/
d437 10
@


1.11
log
@provide split raw/cooked (translated) input modes.  cooked mode is default,
raw mode is set by using an ioctl or opening minor dev 1.

MAKEDEV created pms0r with minor dev 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.10 1996/08/17 05:57:23 deraadt Exp $	*/
d124 5
d359 1
d392 4
a395 1
		sc->sc_flags |= PMS_RAW;
d398 4
a401 1
		sc->sc_flags &= ~PMS_RAW;
@


1.10
log
@do not reset/disable for fails on some laptops; rees@@umich.edu from someone else
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.9 1996/05/25 22:17:52 deraadt Exp $	*/
d5 1
d103 2
d121 2
a122 1
#define	PMSUNIT(dev)	(minor(dev))
d253 1
d385 6
a390 1

d421 41
a461 1
	switch (state) {
d463 17
a479 3
	case 0:
		buttons = inb(PMS_DATA);
		if ((buttons & 0xc0) == 0)
d481 18
a498 1
		break;
d500 2
a501 6
	case 1:
		dx = inb(PMS_DATA);
		/* Bounding at -127 avoids a bug in XFree86. */
		dx = (dx == -128) ? -127 : dx;
		++state;
		break;
d503 3
a505 27
	case 2:
		dy = inb(PMS_DATA);
		dy = (dy == -128) ? -127 : dy;
		state = 0;

		buttons = ((buttons & PS2LBUTMASK) << 2) |
			  ((buttons & (PS2RBUTMASK | PS2MBUTMASK)) >> 1);
		changed = ((buttons ^ sc->sc_status) & BUTSTATMASK) << 3;
		sc->sc_status = buttons | (sc->sc_status & ~BUTSTATMASK) | changed;

		if (dx || dy || changed) {
			/* Update accumulated movements. */
			sc->sc_x += dx;
			sc->sc_y += dy;

			/* Add this event to the queue. */
			buffer[0] = 0x80 | (buttons ^ BUTSTATMASK);
			buffer[1] = dx;
			buffer[2] = dy;
			buffer[3] = buffer[4] = 0;
			(void) b_to_q(buffer, sizeof buffer, &sc->sc_q);

			if (sc->sc_state & PMS_ASLP) {
				sc->sc_state &= ~PMS_ASLP;
				wakeup((caddr_t)sc);
			}
			selwakeup(&sc->sc_rsel);
d507 1
a507 2

		break;
@


1.9
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: pms.c,v 1.8 1996/05/10 12:46:22 deraadt Exp $	*/
d196 1
a196 1
	pms_dev_cmd(PMS_RESET);
d277 1
a277 1
	pms_dev_cmd(PMS_DEV_DISABLE);
@


1.8
log
@simple cleanup
@
text
@d1 2
a2 2
/*	$OpenBSD: pms.c,v 1.6 1996/04/18 17:12:20 niklas Exp $	*/
/*	$NetBSD: pms.c,v 1.28 1996/05/05 19:46:18 christos Exp $	*/
d54 1
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d2 1
a2 1
/*	$NetBSD: pms.c,v 1.27 1996/04/11 22:15:27 cgd Exp $	*/
d56 1
d119 6
a124 1
static inline void
d129 1
a129 1
	while (c = inb(PMS_STATUS) & 0x03)
d138 1
a138 1
static inline void
d149 1
a149 1
static inline void
d158 1
a158 1
static inline void
d225 1
a225 1
pmsopen(dev, flag)
d228 2
d267 1
a267 1
pmsclose(dev, flag)
d270 2
d295 1
a295 1
	int error;
d308 2
a309 1
		if (error = tsleep((caddr_t)sc, PZERO | PCATCH, "pmsrea", 0)) {
d328 1
a328 1
		if (error = uiomove(buffer, length, uio))
d336 1
a336 1
pmsioctl(dev, cmd, addr, flag)
d341 1
@


1.6
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: pms.c,v 1.25 1996/03/16 06:08:50 thorpej Exp $	*/
d108 6
a113 2
struct cfdriver pmscd = {
	NULL, "pms", pmsprobe, pmsattach, DV_TTY, sizeof(struct pms_softc)
d207 1
d214 2
a215 2
	sc->sc_ih = isa_intr_establish(irq, IST_EDGE, IPL_TTY, pmsintr,
	    sc, sc->sc_dev.dv_xname);
d226 1
a226 1
	if (unit >= pmscd.cd_ndevs)
d228 1
a228 1
	sc = pmscd.cd_devs[unit];
d263 1
a263 1
	struct pms_softc *sc = pmscd.cd_devs[PMSUNIT(dev)];
d283 1
a283 1
	struct pms_softc *sc = pmscd.cd_devs[PMSUNIT(dev)];
d331 1
a331 1
	struct pms_softc *sc = pmscd.cd_devs[PMSUNIT(dev)];
d454 1
a454 1
	struct pms_softc *sc = pmscd.cd_devs[PMSUNIT(dev)];
@


1.5
log
@Fix back wrong patches.
@
text
@d1 2
a2 1
/*	$NetBSD: pms.c,v 1.24 1995/12/24 02:30:28 mycroft Exp $	*/
d159 4
d168 1
a168 1
	struct isa_attach_args *ia = aux;
d171 13
a183 2
	if (ia->ia_iobase != 0x60)
		return 0;
a192 2
	ia->ia_iosize = PMS_NPORTS;
	ia->ia_msize = 0;
d202 1
a202 1
	struct isa_attach_args *ia = aux;
d204 1
a204 1
	printf("\n");
d209 1
a209 1
	sc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_TTY, pmsintr,
@


1.4
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d196 1
a196 1
	    sc);
@


1.3
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 1
a1 1
/*	$NetBSD: pms.c,v 1.23 1995/10/05 22:06:54 mycroft Exp $	*/
d196 1
a196 1
	    sc, sc->sc_dev.dv_xname);
@


1.2
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
@
text
@d196 1
a196 1
	    sc);
@


1.1
log
@Initial revision
@
text
@d195 2
a196 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE, ISA_IPL_TTY,
	    pmsintr, sc);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
