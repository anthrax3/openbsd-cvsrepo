head	1.13;
access;
symbols
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	UBC_SYNC_A:1.13
	UBC_SYNC_B:1.13
	SMP:1.13.0.2
	OPENBSD_2_4:1.12.0.6
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.4
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	99.01.02.00.02.54;	author niklas;	state dead;
branches;
next	1.12;

1.12
date	97.10.24.00.00.01;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	96.10.18.15.48.10;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	96.07.27.11.16.10;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.28.10.28.15;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.10.12.46.23;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.05.01.00.16.19;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.17.04;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.03.19.21.09.41;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.04.10.31.21;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.04.48.01;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.02.26.10.26.50;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.38;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Midi & sequencer support from NetBSD, mostly by Lennart Augustsson
@
text
@/*	$OpenBSD: spkr.c,v 1.12 1997/10/24 00:00:01 mickey Exp $ */
/*	$NetBSD: spkr.c,v 1.23.4.1 1996/07/15 22:15:11 fvdl Exp $	*/

/*
 * spkr.c -- device driver for console speaker on 80386
 *
 * v1.1 by Eric S. Raymond (esr@@snark.thyrsus.com) Feb 1990
 *      modified for 386bsd by Andrew A. Chernov <ache@@astral.msk.su>
 *      386bsd only clean version, all SYSV stuff removed
 *      use hz value from param.c
 */

#include "spkr.h"
#if NSPKR > 0
#if NSPKR > 1
#error only one speaker device per system
#endif

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/uio.h>
#include <sys/proc.h>

#include <machine/cpu.h>
#include <machine/pio.h>
#include <machine/spkr.h>
#include <machine/conf.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#include <i386/isa/timerreg.h>
#include <i386/isa/spkrreg.h>

int spkrprobe __P((struct device *, void *, void *));
void spkrattach __P((struct device *, struct device *, void *));

struct spkr_softc {
	struct device sc_dev;
};

struct cfattach spkr_ca = {
	sizeof(struct spkr_softc), spkrprobe, spkrattach
};

struct cfdriver spkr_cd = {
	NULL, "spkr", DV_TTY
};

/**************** MACHINE DEPENDENT PART STARTS HERE *************************
 *
 * This section defines a function tone() which causes a tone of given
 * frequency and duration from the 80x86's console speaker.
 * Another function endtone() is defined to force sound off, and there is
 * also a rest() entry point to do pauses.
 *
 * Audible sound is generated using the Programmable Interval Timer (PIT) and
 * Programmable Peripheral Interface (PPI) attached to the 80x86's speaker. The
 * PPI controls whether sound is passed through at all; the PIT's channel 2 is
 * used to generate clicks (a square wave) of whatever frequency is desired.
 */

/*
 * Magic numbers for timer control. 
 */
#define PIT_MODE	(TIMER_SEL2|TIMER_16BIT|TIMER_SQWAVE)

static void endtone __P((void *));
static void tone __P((u_int, u_int));
static void endrest __P((void *));
static void rest __P((int));
static void playinit __P((void));
static void playtone __P((int, int, int));
static void playstring __P((char *, int));

static void
endtone(v)
    void *v;
{
    wakeup(endtone);
    outb(PITAUX_PORT, inb(PITAUX_PORT) & ~PIT_SPKR);
}

static
void tone(hz, ticks)
/* emit tone of frequency hz for given number of ticks */
    u_int hz, ticks;
{
    u_int divisor = TIMER_DIV(hz);
    int sps;

#ifdef SPKR_DEBUG
    printf("tone: hz=%d ticks=%d\n", hz, ticks);
#endif /* SPKR_DEBUG */

    /* set timer to generate clicks at given frequency in Hertz */
    sps = spltty();
    outb(TIMER_MODE, PIT_MODE);		/* prepare timer */
    outb(TIMER_CNTR2, (unsigned char) divisor);  /* send lo byte */
    outb(TIMER_CNTR2, (divisor >> 8));	/* send hi byte */
    splx(sps);

    /* turn the speaker on */
    outb(PITAUX_PORT, inb(PITAUX_PORT) | PIT_SPKR);

    /*
     * Set timeout to endtone function, then give up the timeslice.
     * This is so other processes can execute while the tone is being
     * emitted.
     */
    timeout(endtone, NULL, ticks);
    sleep(endtone, PZERO - 1);
}

static void
endrest(v)
/* end a rest */
	void *v;
{
    wakeup(endrest);
}

static void
rest(ticks)
/* rest for given number of ticks */
    int	ticks;
{
    /*
     * Set timeout to endrest function, then give up the timeslice.
     * This is so other processes can execute while the rest is being
     * waited out.
     */
#ifdef SPKR_DEBUG
    printf("rest: %d\n", ticks);
#endif /* SPKR_DEBUG */
    timeout(endrest, NULL, ticks);
    sleep(endrest, PZERO - 1);
}

/**************** PLAY STRING INTERPRETER BEGINS HERE **********************
 *
 * Play string interpretation is modelled on IBM BASIC 2.0's PLAY statement;
 * M[LNS] are missing and the ~ synonym and octave-tracking facility is added.
 * Requires tone(), rest(), and endtone(). String play is not interruptible
 * except possibly at physical block boundaries.
 */

typedef int	bool;
#define TRUE	1
#define FALSE	0

#define toupper(c)	((c) - ' ' * (((c) >= 'a') && ((c) <= 'z')))
#define isdigit(c)	(((c) >= '0') && ((c) <= '9'))
#define dtoi(c)		((c) - '0')

static int octave;	/* currently selected octave */
static int whole;	/* whole-note time at current tempo, in ticks */
static int value;	/* whole divisor for note time, quarter note = 1 */
static int fill;	/* controls spacing of notes */
static bool octtrack;	/* octave-tracking on? */
static bool octprefix;	/* override current octave-tracking state? */

/*
 * Magic number avoidance...
 */
#define SECS_PER_MIN	60	/* seconds per minute */
#define WHOLE_NOTE	4	/* quarter notes per whole note */
#define MIN_VALUE	64	/* the most we can divide a note by */
#define DFLT_VALUE	4	/* default value (quarter-note) */
#define FILLTIME	8	/* for articulation, break note in parts */
#define STACCATO	6	/* 6/8 = 3/4 of note is filled */
#define NORMAL		7	/* 7/8ths of note interval is filled */
#define LEGATO		8	/* all of note interval is filled */
#define DFLT_OCTAVE	4	/* default octave */
#define MIN_TEMPO	32	/* minimum tempo */
#define DFLT_TEMPO	120	/* default tempo */
#define MAX_TEMPO	255	/* max tempo */
#define NUM_MULT	3	/* numerator of dot multiplier */
#define DENOM_MULT	2	/* denominator of dot multiplier */

/* letter to half-tone:  A   B  C  D  E  F  G */
static int notetab[8] = {9, 11, 0, 2, 4, 5, 7};

/*
 * This is the American Standard A440 Equal-Tempered scale with frequencies
 * rounded to nearest integer. Thank Goddess for the good ol' CRC Handbook...
 * our octave 0 is standard octave 2.
 */
#define OCTAVE_NOTES	12	/* semitones per octave */
static int pitchtab[] =
{
/*        C     C#    D     D#    E     F     F#    G     G#    A     A#    B*/
/* 0 */   65,   69,   73,   78,   82,   87,   93,   98,  103,  110,  117,  123,
/* 1 */  131,  139,  147,  156,  165,  175,  185,  196,  208,  220,  233,  247,
/* 2 */  262,  277,  294,  311,  330,  349,  370,  392,  415,  440,  466,  494,
/* 3 */  523,  554,  587,  622,  659,  698,  740,  784,  831,  880,  932,  988,
/* 4 */ 1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1975,
/* 5 */ 2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951,
/* 6 */ 4186, 4435, 4698, 4978, 5274, 5588, 5920, 6272, 6644, 7040, 7459, 7902,
};
#define NOCTAVES (sizeof(pitchtab) / sizeof(pitchtab[0]) / OCTAVE_NOTES)

static void
playinit()
{
    octave = DFLT_OCTAVE;
    whole = (hz * SECS_PER_MIN * WHOLE_NOTE) / DFLT_TEMPO;
    fill = NORMAL;
    value = DFLT_VALUE;
    octtrack = FALSE;
    octprefix = TRUE;	/* act as though there was an initial O(n) */
}

static void
playtone(pitch, value, sustain)
/* play tone of proper duration for current rhythm signature */
    int	pitch, value, sustain;
{
    register int	sound, silence, snum = 1, sdenom = 1;

    /* this weirdness avoids floating-point arithmetic */
    for (; sustain; sustain--)
    {
	snum *= NUM_MULT;
	sdenom *= DENOM_MULT;
    }

    if (pitch == -1)
	rest(whole * snum / (value * sdenom));
    else
    {
	sound = (whole * snum) / (value * sdenom)
		- (whole * (FILLTIME - fill)) / (value * FILLTIME);
	silence = whole * (FILLTIME-fill) * snum / (FILLTIME * value * sdenom);

#ifdef SPKR_DEBUG
	printf("playtone: pitch %d for %d ticks, rest for %d ticks\n",
			pitch, sound, silence);
#endif /* SPKR_DEBUG */

	tone(pitchtab[pitch], sound);
	if (fill != LEGATO)
	    rest(silence);
    }
}

static void
playstring(cp, slen)
/* interpret and play an item from a notation string */
    char	*cp;
    int		slen;
{
    int		pitch, lastpitch = OCTAVE_NOTES * DFLT_OCTAVE;

#define GETNUM(cp, v)	for(v=0; isdigit(cp[1]) && slen > 0; ) \
				{v = v * 10 + (*++cp - '0'); slen--;}
    for (; slen--; cp++)
    {
	int		sustain, timeval, tempo;
	register char	c = toupper(*cp);

#ifdef SPKR_DEBUG
	printf("playstring: %c (%x)\n", c, c);
#endif /* SPKR_DEBUG */

	switch (c)
	{
	case 'A':  case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':

	    /* compute pitch */
	    pitch = notetab[c - 'A'] + octave * OCTAVE_NOTES;

	    /* this may be followed by an accidental sign */
	    if (slen > 0 && (cp[1] == '#' || cp[1] == '+'))
	    {
		++pitch;
		++cp;
		slen--;
	    }
	    else if (slen > 0 && cp[1] == '-')
	    {
		--pitch;
		++cp;
		slen--;
	    }

	    /*
	     * If octave-tracking mode is on, and there has been no octave-
	     * setting prefix, find the version of the current letter note
	     * closest to the last regardless of octave.
	     */
	    if (octtrack && !octprefix)
	    {
		if (abs(pitch-lastpitch) > abs(pitch+OCTAVE_NOTES-lastpitch))
		{
		    ++octave;
		    pitch += OCTAVE_NOTES;
		}

		if (abs(pitch-lastpitch) > abs((pitch-OCTAVE_NOTES)-lastpitch))
		{
		    --octave;
		    pitch -= OCTAVE_NOTES;
		}
	    }
	    octprefix = FALSE;
	    lastpitch = pitch;

	    /* ...which may in turn be followed by an override time value */
	    GETNUM(cp, timeval);
	    if (timeval <= 0 || timeval > MIN_VALUE)
		timeval = value;

	    /* ...and/or sustain dots */
	    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)
	    {
		slen--;
		sustain++;
	    }

	    /* time to emit the actual tone */
	    playtone(pitch, timeval, sustain);
	    break;

	case 'O':
	    if (slen > 0 && (cp[1] == 'N' || cp[1] == 'n'))
	    {
		octprefix = octtrack = FALSE;
		++cp;
		slen--;
	    }
	    else if (slen > 0 && (cp[1] == 'L' || cp[1] == 'l'))
	    {
		octtrack = TRUE;
		++cp;
		slen--;
	    }
	    else
	    {
		GETNUM(cp, octave);
		if (octave >= NOCTAVES)
		    octave = DFLT_OCTAVE;
		octprefix = TRUE;
	    }
	    break;

	case '>':
	    if (octave < NOCTAVES - 1)
		octave++;
	    octprefix = TRUE;
	    break;

	case '<':
	    if (octave > 0)
		octave--;
	    octprefix = TRUE;
	    break;

	case 'N':
	    GETNUM(cp, pitch);
	    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)
	    {
		slen--;
		sustain++;
	    }
	    playtone(pitch - 1, value, sustain);
	    break;

	case 'L':
	    GETNUM(cp, value);
	    if (value <= 0 || value > MIN_VALUE)
		value = DFLT_VALUE;
	    break;

	case 'P':
	case '~':
	    /* this may be followed by an override time value */
	    GETNUM(cp, timeval);
	    if (timeval <= 0 || timeval > MIN_VALUE)
		timeval = value;
	    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)
	    {
		slen--;
		sustain++;
	    }
	    playtone(-1, timeval, sustain);
	    break;

	case 'T':
	    GETNUM(cp, tempo);
	    if (tempo < MIN_TEMPO || tempo > MAX_TEMPO)
		tempo = DFLT_TEMPO;
	    whole = (hz * SECS_PER_MIN * WHOLE_NOTE) / tempo;
	    break;

	case 'M':
	    if (slen > 0 && (cp[1] == 'N' || cp[1] == 'n'))
	    {
		fill = NORMAL;
		++cp;
		slen--;
	    }
	    else if (slen > 0 && (cp[1] == 'L' || cp[1] == 'l'))
	    {
		fill = LEGATO;
		++cp;
		slen--;
	    }
	    else if (slen > 0 && (cp[1] == 'S' || cp[1] == 's'))
	    {
		fill = STACCATO;
		++cp;
		slen--;
	    }
	    break;
	}
    }
}

/******************* UNIX DRIVER HOOKS BEGIN HERE **************************
 *
 * This section implements driver hooks to run playstring() and the tone(),
 * endtone(), and rest() functions defined above.
 */

static int spkr_active;	/* exclusion flag */
static struct buf *spkr_inbuf; /* incoming buf */

int
spkrprobe (parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct cfdata *cf = match;
#include "vt.h"
#include "pc.h"
#if NPC > 0
	extern struct cfattach pc_ca;
#endif
#if NVT > 0
	extern struct cfattach vt_ca;
#endif
	/*
	 * We only attach to the keyboard controller via
	 * the console drivers. (We really wish we could be the
	 * child of a real keyboard controller driver.)
	 */
	if ((parent == NULL) || (parent->dv_cfdata == NULL) ||
	   (
#if NPC > 0
	    (parent->dv_cfdata->cf_attach != &pc_ca)
#endif
#if NPC > 0 && NVT > 0	/* XXX could we have both of them ??? */
	    &&
#endif
#if NVT > 0
	    (parent->dv_cfdata->cf_attach != &vt_ca)
#endif
#if NPC == 0 && NVT == 0
	    1
#endif
	   ))
		return (0);
	if (cf->cf_loc[1] != PITAUX_PORT)
		return (0);
	return (1);
}

static int spkr_attached = 0;

void
spkrattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	printf(" port 0x%x\n", self->dv_cfdata->cf_loc[1]);
	spkr_attached = 1;
}

int
spkropen(dev, flags, mode, p)
    dev_t dev;
    int	flags;
    int mode;
    struct proc *p;
{
#ifdef SPKR_DEBUG
    printf("spkropen: entering with dev = %x\n", dev);
#endif /* SPKR_DEBUG */

    if (minor(dev) != 0 || !spkr_attached)
	return(ENXIO);
    else if (spkr_active)
	return(EBUSY);
    else
    {
	playinit();
	spkr_inbuf = geteblk(DEV_BSIZE);
	spkr_active = 1;
    }
    return(0);
}

int
spkrwrite(dev, uio, flags)
    dev_t dev;
    struct uio *uio;
    int flags;
{
    register int n;
    char *cp;
    int error;
#ifdef SPKR_DEBUG
    printf("spkrwrite: entering with dev = %x, count = %d\n",
		dev, uio->uio_resid);
#endif /* SPKR_DEBUG */

    if (minor(dev) != 0 || !spkr_attached)
	return(ENXIO);
    else
    {
	n = min(DEV_BSIZE, uio->uio_resid);
	cp = spkr_inbuf->b_data;
	error = uiomove(cp, n, uio);
	if (!error)
		playstring(cp, n);
	return(error);
    }
}

int spkrclose(dev, flags, mode, p)
    dev_t	dev;
    int flags;
    int mode;
    struct proc *p;
{
#ifdef SPKR_DEBUG
    printf("spkrclose: entering with dev = %x\n", dev);
#endif /* SPKR_DEBUG */

    if (minor(dev) != 0)
	return(ENXIO);
    else
    {
	endtone(NULL);
	brelse(spkr_inbuf);
	spkr_active = 0;
    }
    return(0);
}

int spkrioctl(dev, cmd, data, flag, p)
    dev_t dev;
    u_long cmd;
    caddr_t data;
    int	flag;
    struct proc *p;
{
#ifdef SPKR_DEBUG
    printf("spkrioctl: entering with dev = %x, cmd = %lx\n", dev, cmd);
#endif /* SPKR_DEBUG */

    if (minor(dev) != 0)
	return(ENXIO);
    else if (cmd == SPKRTONE)
    {
	tone_t	*tp = (tone_t *)data;

	if (tp->frequency == 0)
	    rest(tp->duration);
	else
	    tone(tp->frequency, tp->duration);
    }
    else if (cmd == SPKRTUNE)
    {
	tone_t  *tp = (tone_t *)(*(caddr_t *)data);
	tone_t ttp;
	int error;

	for (; ; tp++) {
	    error = copyin(tp, &ttp, sizeof(tone_t));
	    if (error)
		    return(error);
	    if (ttp.duration == 0)
		    break;
	    if (ttp.frequency == 0)
		rest(ttp.duration);
	    else
		tone(ttp.frequency, ttp.duration);
	}
    }
    else
	return(EINVAL);
    return(0);
}

#endif  /* NSPEAKER > 0 */
/* spkr.c ends here */
@


1.12
log
@s/DEBUG/SPKR_DEBUG/g
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.11 1996/10/18 15:48:10 mickey Exp $ */
@


1.11
log
@-Wall happiness
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.10 1996/07/27 11:16:10 deraadt Exp $ */
d95 1
a95 1
#ifdef DEBUG
d97 1
a97 1
#endif /* DEBUG */
d136 1
a136 1
#ifdef DEBUG
d138 1
a138 1
#endif /* DEBUG */
d239 1
a239 1
#ifdef DEBUG
d242 1
a242 1
#endif /* DEBUG */
d265 1
a265 1
#ifdef DEBUG
d267 1
a267 1
#endif /* DEBUG */
d492 1
a492 1
#ifdef DEBUG
d494 1
a494 1
#endif /* DEBUG */
d518 1
a518 1
#ifdef DEBUG
d521 1
a521 1
#endif /* DEBUG */
d542 1
a542 1
#ifdef DEBUG
d544 1
a544 1
#endif /* DEBUG */
d564 1
a564 1
#ifdef DEBUG
d566 1
a566 1
#endif /* DEBUG */
@


1.10
log
@jtk; One more fix as pointed out by enami tsugutomo <enami@@ba2.so-net.or.jp>:
check slen before accessing cp[1] in GETNUM macro.
fix PRs 219, 2295, 2612: speaker bugs on i386 port: remove overruns due to
faulty bounds checking; repair faulty octave limiting.
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.9 1996/05/28 10:28:15 deraadt Exp $ */
d439 8
a446 1
	extern struct cfattach pc_ca, vt_ca;
a453 2
#include "vt.h"
#include "pc.h"
@


1.9
log
@fix pccons/pcvt messup
@
text
@d1 2
a2 2
/*	$OpenBSD: spkr.c,v 1.8 1996/05/10 12:46:23 deraadt Exp $ */
/*	$NetBSD: spkr.c,v 1.23 1996/05/05 19:31:25 christos Exp $	*/
d77 1
a77 1
static void playstring __P((char *, size_t));
d204 1
d254 1
a254 1
    size_t	slen;
d277 1
a277 1
	    if (cp[1] == '#' || cp[1] == '+')
d283 1
a283 1
	    else if (cp[1] == '-')
d318 1
a318 1
	    for (sustain = 0; cp[1] == '.'; cp++)
d329 1
a329 1
	    if (cp[1] == 'N' || cp[1] == 'n')
d335 1
a335 1
	    else if (cp[1] == 'L' || cp[1] == 'l')
d344 1
a344 1
		if (octave >= sizeof(pitchtab) / OCTAVE_NOTES)
d351 1
a351 1
	    if (octave < sizeof(pitchtab) / OCTAVE_NOTES - 1)
d364 1
a364 1
	    for (sustain = 0; cp[1] == '.'; cp++)
d384 1
a384 1
	    for (sustain = 0; cp[1] == '.'; cp++)
d400 1
a400 1
	    if (cp[1] == 'N' || cp[1] == 'n')
d406 1
a406 1
	    else if (cp[1] == 'L' || cp[1] == 'l')
d412 1
a412 1
	    else if (cp[1] == 'S' || cp[1] == 's')
d510 1
a510 1
    register unsigned n;
@


1.8
log
@simple cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.6 1996/04/21 22:17:04 deraadt Exp $ */
d448 1
a448 1
#if NPC
d451 1
a451 1
#if NPC && NVT	/* XXX could we have both of them ??? */
d454 1
a454 1
#if NVT
d457 1
a457 1
#if !NCP && !NVT
@


1.7
log
@we don't need ia_iosize setting, since no isa_attach_args
stuff passed.
@
text
@d2 1
a2 1
/*	$NetBSD: spkr.c,v 1.22 1996/03/18 01:26:12 jtk Exp $	*/
d20 1
d26 1
d31 1
d71 11
a81 3

static int endtone()
/* turn off the speaker, ending current tone */
d83 1
a83 1
    wakeup((caddr_t)endtone);
d87 2
a88 1
static void tone(hz, ticks)
d90 1
a90 1
unsigned int hz, ticks;
d92 1
a92 1
    unsigned int divisor = TIMER_DIV(hz);
d114 2
a115 2
    timeout((caddr_t)endtone, (caddr_t)NULL, ticks);
    sleep((caddr_t)endtone, PZERO - 1);
d118 2
a119 1
static int endrest()
d121 1
d123 1
a123 1
    wakeup((caddr_t)endrest);
d126 2
a127 1
static void rest(ticks)
d129 1
a129 1
int	ticks;
d139 2
a140 2
    timeout((caddr_t)endrest, (caddr_t)NULL, ticks);
    sleep((caddr_t)endrest, PZERO - 1);
d205 2
a206 1
static void playinit()
d216 2
a217 1
static void playtone(pitch, value, sustain)
d219 1
a219 1
int	pitch, value, sustain;
d249 2
a250 10
static int abs(n)
int n;
{
    if (n < 0)
	return(-n);
    else
	return(n);
}

static void playstring(cp, slen)
d252 2
a253 2
char	*cp;
size_t	slen;
d431 2
a432 1
int spkrprobe (parent, match, aux)
a436 1
    	register struct isa_attach_args *ia = aux;
d479 6
a484 2
int spkropen(dev)
dev_t	dev;
d503 5
a507 3
int spkrwrite(dev, uio)
dev_t	dev;
struct uio *uio;
d530 5
a534 2
int spkrclose(dev)
dev_t	dev;
d544 1
a544 1
	endtone();
d552 5
a556 5
dev_t	dev;
u_long	cmd;
caddr_t data;
int	flag;
struct	proc *p;
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d429 1
d435 17
a451 3
	if ((parent == NULL) ||
	   ((strcmp(parent->dv_cfdata->cf_driver->cd_name, "pc") != 0) &&
	    (strcmp(parent->dv_cfdata->cf_driver->cd_name, "vt") != 0)))
a454 2

	ia->ia_iosize = 1;
@


1.5
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 1
d42 6
a47 2
struct cfdriver spkrcd = {
	NULL, "spkr", spkrprobe, spkrattach, DV_TTY, sizeof(struct spkr_softc)
d441 1
d489 1
a489 1
    if (minor(dev) != 0)
@


1.4
log
@fixes of the 960217 import.
@
text
@d1 1
a1 1
/*	$NetBSD: spkr.c,v 1.18 1996/02/22 05:53:28 scottr Exp $	*/
d14 3
d417 18
a434 3
int spkrprobe (struct device *parent, void *match, void *aux)
{
	struct isa_attach_args *ia = aux;
d436 1
a436 2
	ia->ia_iosize = 0;
	return 1;
d439 7
a445 1
void spkrattach (struct device *parent, struct device *self, void *aux)
d447 2
a448 1
	printf("\n");
d458 1
a458 1
    if (minor(dev) != 0)
@


1.3
log
@Set ia_iosize to 0 to keep probe silent
@
text
@d27 1
@


1.2
log
@From NetBSD
Move the speaker to the 'new' config.
@
text
@d415 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: spkr.c,v 1.17 1994/10/30 21:44:18 cgd Exp $	*/
d12 2
a13 2
#include "speaker.h"
#if NSPEAKER > 0
d18 1
d26 1
a26 1
#include <i386/isa/isareg.h>
d30 11
a58 4
void
speakerattach()
{
}
d412 10
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
