head	1.67;
access;
symbols
	OPENBSD_4_4:1.64.0.2
	OPENBSD_4_4_BASE:1.64
	OPENBSD_4_3:1.62.0.2
	OPENBSD_4_3_BASE:1.62
	OPENBSD_4_2:1.61.0.2
	OPENBSD_4_2_BASE:1.61
	OPENBSD_4_1:1.57.0.2
	OPENBSD_4_1_BASE:1.57
	OPENBSD_4_0:1.54.0.2
	OPENBSD_4_0_BASE:1.54
	OPENBSD_3_9:1.50.0.2
	OPENBSD_3_9_BASE:1.50
	OPENBSD_3_8:1.46.0.4
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.46.0.2
	OPENBSD_3_7_BASE:1.46
	OPENBSD_3_6:1.45.0.4
	OPENBSD_3_6_BASE:1.45
	SMP_SYNC_A:1.45
	SMP_SYNC_B:1.45
	OPENBSD_3_5:1.45.0.2
	OPENBSD_3_5_BASE:1.45
	OPENBSD_3_4:1.44.0.2
	OPENBSD_3_4_BASE:1.44
	UBC_SYNC_A:1.42
	OPENBSD_3_3:1.42.0.6
	OPENBSD_3_3_BASE:1.42
	OPENBSD_3_2:1.42.0.4
	OPENBSD_3_2_BASE:1.42
	OPENBSD_3_1:1.42.0.2
	OPENBSD_3_1_BASE:1.42
	UBC_SYNC_B:1.42
	UBC:1.40.0.4
	UBC_BASE:1.40
	OPENBSD_3_0:1.40.0.2
	OPENBSD_3_0_BASE:1.40
	OPENBSD_2_9:1.37.0.2
	OPENBSD_2_9_BASE:1.37
	OPENBSD_2_8:1.35.0.2
	OPENBSD_2_8_BASE:1.35
	OPENBSD_2_7:1.34.0.4
	OPENBSD_2_7_BASE:1.34
	SMP:1.34.0.2
	SMP_BASE:1.34
	kame_19991208:1.34
	OPENBSD_2_6:1.32.0.2
	OPENBSD_2_6_BASE:1.32
	OPENBSD_2_5:1.29.0.2
	OPENBSD_2_5_BASE:1.29
	OPENBSD_2_4:1.26.0.2
	OPENBSD_2_4_BASE:1.26
	OPENBSD_2_3:1.23.0.2
	OPENBSD_2_3_BASE:1.23
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.67
date	2008.11.24.09.29.06;	author deraadt;	state dead;
branches;
next	1.66;

1.66
date	2008.11.23.17.59.00;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.64;

1.64
date	2008.04.12.10.47.22;	author kettenis;	state Exp;
branches;
next	1.63;

1.63
date	2008.03.29.15.26.47;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2008.01.23.16.37.56;	author jsing;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.09.14.32.17;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2007.05.08.21.28.11;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.08.21.18.18;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2007.05.08.20.33.07;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2007.02.15.18.39.26;	author mickey;	state Exp;
branches;
next	1.56;

1.56
date	2006.12.28.20.50.21;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2006.09.19.11.06.34;	author jsg;	state Exp;
branches;
next	1.54;

1.54
date	2006.07.31.11.06.20;	author mickey;	state Exp;
branches;
next	1.53;

1.53
date	2006.06.23.06.27.08;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2006.06.15.15.44.45;	author jason;	state Exp;
branches;
next	1.51;

1.51
date	2006.04.27.19.31.43;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2006.01.01.11.59.39;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2005.11.21.18.16.36;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2005.10.24.14.22.34;	author fgsch;	state Exp;
branches;
next	1.47;

1.47
date	2005.09.26.22.32.05;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.23.17.50.24;	author markus;	state Exp;
branches;
next	1.45;

1.45
date	2003.10.03.16.44.49;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2003.08.15.20.32.13;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.02.23.27.47;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2002.01.30.20.45.34;	author nordin;	state Exp;
branches;
next	1.40;

1.40
date	2001.08.08.19.07.17;	author mickey;	state Exp;
branches
	1.40.4.1;
next	1.39;

1.39
date	2001.07.23.14.28.46;	author jason;	state Exp;
branches;
next	1.38;

1.38
date	2001.07.04.23.14.51;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.15.17.52.20;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2001.01.24.09.38.01;	author hugh;	state Exp;
branches;
next	1.35;

1.35
date	2000.08.16.19.15.35;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	99.11.28.12.07.02;	author downsj;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	99.10.26.12.29.00;	author downsj;	state Exp;
branches;
next	1.32;

1.32
date	99.08.08.01.34.15;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	99.07.26.12.31.44;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	99.05.21.16.06.13;	author rees;	state Exp;
branches;
next	1.29;

1.29
date	99.02.08.23.43.54;	author rees;	state Exp;
branches;
next	1.28;

1.28
date	99.01.21.08.55.08;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	99.01.11.05.11.25;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	98.10.07.02.10.52;	author downsj;	state Exp;
branches;
next	1.25;

1.25
date	98.06.28.01.47.23;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	98.05.14.05.54.44;	author downsj;	state Exp;
branches;
next	1.23;

1.23
date	98.04.05.07.36.42;	author downsj;	state Exp;
branches;
next	1.22;

1.22
date	98.02.23.11.40.32;	author downsj;	state Exp;
branches;
next	1.21;

1.21
date	98.02.22.21.35.31;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	98.02.05.16.48.28;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	98.02.02.22.21.20;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	98.01.19.06.48.24;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.12.26.09.35.40;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.12.25.14.33.14;	author downsj;	state Exp;
branches;
next	1.15;

1.15
date	97.12.25.09.19.39;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	97.12.21.14.44.34;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	97.10.07.06.49.49;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.09.03.20.55.29;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.07.07.17.08.04;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.12.18.16.51.45;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.12.11.13.28.06;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.11.30.11.54.32;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.11.28.23.37.41;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.11.12.20.30.05;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.11.09.21.56.22;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.10.22.01.11.52;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.08.29.12.58.32;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.07.28.05.07.06;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.07.07.00.05.49;	author downsj;	state Exp;
branches;
next	;

1.34.2.1
date	2001.04.18.16.07.54;	author niklas;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.34.2.4;

1.34.2.4
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.34.2.5;

1.34.2.5
date	2003.06.07.11.11.38;	author ho;	state Exp;
branches;
next	1.34.2.6;

1.34.2.6
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	;

1.40.4.1
date	2002.01.31.22.55.12;	author niklas;	state Exp;
branches;
next	1.40.4.2;

1.40.4.2
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	;


desc
@@


1.67
log
@die die die
@
text
@@


1.66
log
@pccom can finally die; ok kettenis dlg drahn, tested by okan
@
text
@@


1.65
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@a0 1686
/*	$OpenBSD: pccom.c,v 1.64 2008/04/12 10:47:22 kettenis Exp $	*/
/*	$NetBSD: com.c,v 1.82.4.1 1996/06/02 09:08:00 mrg Exp $	*/

/*
 * Copyright (c) 1997 - 1999, Jason Downs.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name(s) of the author(s) nor the name OpenBSD
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1993, 1994, 1995, 1996
 *	Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1991 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)com.c	7.5 (Berkeley) 5/16/91
 */

/*
 * PCCOM driver, uses National Semiconductor NS16450/NS16550AF UART
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/selinfo.h>
#include <sys/tty.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/types.h>
#include <sys/device.h>
#include <sys/vnode.h>
#include <sys/timeout.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/cons.h>
#include <dev/isa/isavar.h>
#include <dev/ic/comreg.h>
#include <dev/ic/ns16550reg.h>
#define	com_lcr	com_cfcr
#ifdef DDB
#include <ddb/db_var.h>
#endif

#include "pccomvar.h"
#include "pccom.h"

/* XXX: These belong elsewhere */
cdev_decl(com);

static u_char tiocm_xxx2mcr(int);

void pccom_xr16850_fifo_init(bus_space_tag_t, bus_space_handle_t);

/*
 * XXX the following two cfattach structs should be different, and possibly
 * XXX elsewhere.
 */
int	comprobe(struct device *, void *, void *);
void	comattach(struct device *, struct device *, void *);
void	compwroff(struct com_softc *);

#if NPCCOM_ISA
struct cfattach pccom_isa_ca = {
	sizeof(struct com_softc), comprobe, comattach
};
#endif

#if NPCCOM_ISAPNP
struct cfattach pccom_isapnp_ca = {
	sizeof(struct com_softc), comprobe, comattach
};
#endif

#if NPCCOM_COMMULTI
struct cfattach pccom_commulti_ca = {
	sizeof(struct com_softc), comprobe, comattach
};
#endif

struct cfdriver pccom_cd = {
	NULL, "pccom", DV_TTY
};

void cominit(bus_space_tag_t, bus_space_handle_t, int);

#ifndef CONSPEED
#define	CONSPEED B9600
#endif

int	comdefaultrate = TTYDEF_SPEED;
int	comconsrate = CONSPEED;
int	comconsinit;
int	comconsattached;
bus_addr_t comconsaddr;
bus_space_tag_t comconsiot;
bus_space_handle_t comconsioh;
tcflag_t comconscflag = TTYDEF_CFLAG;

int	commajor;
int	comsopen = 0;

#ifdef KGDB
#include <sys/kgdb.h>

bus_addr_t com_kgdb_addr;
bus_space_tag_t com_kgdb_iot;
bus_space_handle_t com_kgdb_ioh;

int	com_kgdb_getc(void *);
void	com_kgdb_putc(void *, int);
#endif /* KGDB */

#define	DEVUNIT(x)	(minor(x) & 0x7f)
#define	DEVCUA(x)	(minor(x) & 0x80)

/* Macros for determining bus type. */
#if NPCCOM_ISA || NPCCOM_PCMCIA
#define IS_ISA(parent) \
	(!strcmp((parent)->dv_cfdata->cf_driver->cd_name, "isa") || \
	 !strcmp((parent)->dv_cfdata->cf_driver->cd_name, "pcmcia"))
#elif NPCCOM_ISA
#define IS_ISA(parent) \
	!strcmp((parent)->dv_cfdata->cf_driver->cd_name, "isa")
#elif NPCCOM_ISAPNP
#define IS_ISA(parent) 0
#endif

#if NPCCOM_ISAPNP
#define IS_ISAPNP(parent) \
	 !strcmp((parent)->dv_cfdata->cf_driver->cd_name, "isapnp")
#else
#define IS_ISAPNP(parent)	0
#endif

int
comspeed(long freq, long speed)
{
#define	divrnd(n, q)	(((n)*2/(q)+1)/2)	/* divide and round off */

	int x, err;

	if (speed == 0)
		return 0;
	if (speed < 0)
		return -1;
	x = divrnd((freq / 16), speed);
	if (x <= 0)
		return -1;
	err = divrnd((quad_t)freq * 1000 / 16, speed * x) - 1000;
	if (err < 0)
		err = -err;
	if (err > COM_TOLERANCE)
		return -1;
	return x;

#undef	divrnd
}

int
comprobe1(bus_space_tag_t iot, bus_space_handle_t ioh)
{
	int i, k;

	/* force access to id reg */
	bus_space_write_1(iot, ioh, com_lcr, 0);
	bus_space_write_1(iot, ioh, com_iir, 0);
	for (i = 0; i < 32; i++) {
		k = bus_space_read_1(iot, ioh, com_iir);
		if (k & 0x38) {
			bus_space_read_1(iot, ioh, com_data); /* cleanup */
		} else
			break;
	}
	if (i >= 32) 
	    return 0;

	return 1;
}

int
comprobe(struct device *parent, void *match, void *aux)
{
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int iobase, needioh;
	int rv = 1;

	/*
	 * XXX should be broken out into functions for isa probe and
	 * XXX for commulti probe, with a helper function that contains
	 * XXX most of the interesting stuff.
	 */
/* #if NPCCOM_ISA || NPCCOM_PCMCIA || NPCCOM_ISAPNP */
#if NPCCOM_ISA || NPCCOM_ISAPNP
	if (IS_ISA(parent) || IS_ISAPNP(parent)) {
		struct isa_attach_args *ia = aux;

		iot = ia->ia_iot;
		iobase = ia->ia_iobase;
		if (IS_ISAPNP(parent)) {
			ioh = ia->ia_ioh;
			needioh = 0;
		} else
			needioh = 1;
	} else
#endif
#if NPCCOM_COMMULTI
	if (1) {
		struct cfdata *cf = match;
		struct commulti_attach_args *ca = aux;
 
		if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != ca->ca_slave)
			return (0);

		iot = ca->ca_iot;
		iobase = ca->ca_iobase;
		ioh = ca->ca_ioh;
		needioh = 0;
	} else
#endif
		return(0);			/* This cannot happen */

#ifdef KGDB
	if (iobase == com_kgdb_addr)
		goto out;
#endif /* KGDB */

	/* if it's in use as console, it's there. */
	if (iobase == comconsaddr && !comconsattached)
		goto out;

	if (needioh && bus_space_map(iot, iobase, COM_NPORTS, 0, &ioh)) {
		rv = 0;
		goto out;
	}
	rv = comprobe1(iot, ioh);
	if (needioh)
		bus_space_unmap(iot, ioh, COM_NPORTS);

out:
/* #if NPCCOM_ISA || NPCCOM_PCMCIA */
#if NPCCOM_ISA
	if (rv) {
		struct isa_attach_args *ia = aux;

		ia->ia_iosize = COM_NPORTS;
		ia->ia_msize = 0;
	}
#endif
	return (rv);
}

void
comattach(struct device *parent, struct device *self, void *aux)
{
	struct com_softc *sc = (void *)self;
	bus_addr_t iobase;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int irq;

	/*
	 * XXX should be broken out into functions for isa attach and
	 * XXX for commulti attach, with a helper function that contains
	 * XXX most of the interesting stuff.
	 */
/* #if NPCCOM_ISA || NPCCOM_PCMCIA || NPCCOM_ISAPNP */
#if NPCCOM_ISA || NPCCOM_ISAPNP
	if (IS_ISA(parent) || IS_ISAPNP(parent)) {
		struct isa_attach_args *ia = aux;

		/*
		 * We're living on an isa.
		 */
		iobase = ia->ia_iobase;
		iot = ia->ia_iot;
		if (IS_ISAPNP(parent)) {
			/* No console support! */
			ioh = ia->ia_ioh;
		} else {
#ifdef KGDB
			if ((iobase != comconsaddr) &&
			    (iobase != com_kgdb_addr)) {
#else
	       		if (iobase != comconsaddr) {
#endif /* KGDB */
				if (bus_space_map(iot, iobase, COM_NPORTS, 0, &ioh))
					panic("comattach: io mapping failed");
			} else
#ifdef KGDB
				if (iobase == comconsaddr) {
					ioh = comconsioh;
				} else {
					ioh = com_kgdb_ioh;
				}
#else
				ioh = comconsioh;
#endif /* KGDB */
		}
		irq = ia->ia_irq;
	} else
#endif
#if NPCCOM_COMMULTI
	if (1) {
		struct commulti_attach_args *ca = aux;

		/*
		 * We're living on a commulti.
		 */
		iobase = ca->ca_iobase;
		iot = ca->ca_iot;
		ioh = ca->ca_ioh;
		irq = IRQUNK;

		if (ca->ca_noien)
			SET(sc->sc_hwflags, COM_HW_NOIEN);
	} else
#endif
		panic("comattach: impossible");

	sc->sc_iot = iot;
	sc->sc_ioh = ioh;
	sc->sc_iobase = iobase;
	sc->sc_frequency = COM_FREQ;

	sc->sc_hwflags = 0;
	sc->sc_swflags = 0;

	if (irq != IRQUNK) {
		/* disable interrupts */
		bus_space_write_1(iot, ioh, com_ier, 0);

/* #if NPCCOM_ISA || NPCCOM_PCMCIA || NPCCOM_ISAPNP */
#if NPCCOM_ISA || NPCCOM_ISAPNP
		if (IS_ISA(parent) || IS_ISAPNP(parent)) {
			struct isa_attach_args *ia = aux;

#ifdef KGDB
			if (iobase == com_kgdb_addr) {
				sc->sc_ih = isa_intr_establish(ia->ia_ic, irq,
				    IST_EDGE, IPL_HIGH, kgdbintr, sc,
				    sc->sc_dev.dv_xname);
			} else {
				sc->sc_ih = isa_intr_establish(ia->ia_ic, irq,
				    IST_EDGE, IPL_HIGH, comintr, sc,
				    sc->sc_dev.dv_xname);
			}
#else
			sc->sc_ih = isa_intr_establish(ia->ia_ic, irq,
			    IST_EDGE, IPL_HIGH, comintr, sc,
			    sc->sc_dev.dv_xname);
#endif /* KGDB */
		} else
#endif
			panic("comattach: IRQ but can't have one");
	}

	com_attach_subr(sc);
}

int
com_detach(struct device *self, int flags)
{
	struct com_softc *sc = (struct com_softc *)self;
	int maj, mn;

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == comopen)
			break;

	/* Nuke the vnodes for any open instances. */
	mn = self->dv_unit;
	vdevgone(maj, mn, mn, VCHR);

	/* XXX a symbolic constant for the cua bit would be nicer. */
	mn |= 0x80;
	vdevgone(maj, mn, mn, VCHR);

	/* Detach and free the tty. */
	if (sc->sc_tty) {
		ttyfree(sc->sc_tty);
	}

	timeout_del(&sc->sc_dtr_tmo);
	timeout_del(&sc->sc_diag_tmo);

	return (0);
}

int
com_activate(struct device *self, enum devact act)
{
	struct com_softc *sc = (struct com_softc *)self;
	int s, rv = 0;

	/* XXX splserial, when we get that.  */
	s = spltty();
	switch (act) {
	case DVACT_ACTIVATE:
		break;

	case DVACT_DEACTIVATE:
#ifdef KGDB
		if (sc->sc_hwflags & (COM_HW_CONSOLE|COM_HW_KGDB)) {
#else
		if (sc->sc_hwflags & COM_HW_CONSOLE) {
#endif /* KGDB */
			rv = EBUSY;
			break;
		}

		if (sc->disable != NULL && sc->enabled != 0) {
			(*sc->disable)(sc);
			sc->enabled = 0;
		}
		break;
	}
	splx(s);
	return (rv);
}

int
comopen(dev_t dev, int flag, int mode, struct proc *p)
{
	int unit = DEVUNIT(dev);
	struct com_softc *sc;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	struct tty *tp;
	int s;
	int error = 0;
 
	if (unit >= pccom_cd.cd_ndevs)
		return ENXIO;
	sc = pccom_cd.cd_devs[unit];
	if (!sc)
		return ENXIO;

#ifdef KGDB
	/*
	 * If this is the kgdb port, no other use is permitted.
	 */
	if (ISSET(sc->sc_hwflags, COM_HW_KGDB))
		return (EBUSY);
#endif /* KGDB */

	s = spltty();
	if (!sc->sc_tty) {
		tp = sc->sc_tty = ttymalloc();
	} else
		tp = sc->sc_tty;
	splx(s);

	tp->t_oproc = comstart;
	tp->t_param = comparam;
	tp->t_hwiflow = comhwiflow;
	tp->t_dev = dev;
	if (!ISSET(tp->t_state, TS_ISOPEN)) {
		SET(tp->t_state, TS_WOPEN);
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
			tp->t_cflag = comconscflag;
			tp->t_ispeed = tp->t_ospeed = comconsrate;
		} else {
			tp->t_cflag = TTYDEF_CFLAG;
			tp->t_ispeed = tp->t_ospeed = comdefaultrate;
		}
		if (ISSET(sc->sc_swflags, COM_SW_CLOCAL))
			SET(tp->t_cflag, CLOCAL);
		if (ISSET(sc->sc_swflags, COM_SW_CRTSCTS))
			SET(tp->t_cflag, CRTSCTS);
		if (ISSET(sc->sc_swflags, COM_SW_MDMBUF))
			SET(tp->t_cflag, MDMBUF);
		tp->t_lflag = TTYDEF_LFLAG;

		s = spltty();

		iot = sc->sc_iot;
		ioh = sc->sc_ioh;

		/*
		 * Wake up the sleepy heads.
		 */
		switch (sc->sc_uarttype) {
		case COM_UART_ST16650:
		case COM_UART_ST16650V2:
		case COM_UART_ST16C654:
		case COM_UART_XR16850:
		case COM_UART_OX16C950:
			bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
			bus_space_write_1(iot, ioh, com_efr, EFR_ECB);
			bus_space_write_1(iot, ioh, com_ier, 0);
			bus_space_write_1(iot, ioh, com_efr, 0);
			bus_space_write_1(iot, ioh, com_lcr, 0);
			break;
		case COM_UART_TI16750:
			bus_space_write_1(iot, ioh, com_ier, 0);
			break;
		}

		sc->sc_initialize = 1;
		comparam(tp, &tp->t_termios);
		ttsetwater(tp);

		sc->sc_rxput = sc->sc_rxget = sc->sc_tbc = 0;

		if (ISSET(sc->sc_hwflags, COM_HW_FIFO)) {
			u_int8_t fifo = FIFO_ENABLE|FIFO_RCV_RST|FIFO_XMT_RST;
			u_int8_t lcr;

			switch (sc->sc_uarttype) {
			case COM_UART_ST16650V2:
				if (tp->t_ispeed <= 1200)
					fifo |= FIFO_RCV_TRIGGER_8|FIFO_XMT_TRIGGER_8; /* XXX */
				else
					fifo |= FIFO_RCV_TRIGGER_28|FIFO_XMT_TRIGGER_30;
				break;
			case COM_UART_ST16C654:
				if (tp->t_ispeed <= 1200)
					fifo |= FIFO_RCV3_TRIGGER_8|FIFO_XMT3_TRIGGER_8; /* XXX */
				else
					fifo |= FIFO_RCV3_TRIGGER_60|FIFO_XMT3_TRIGGER_56;
				break;
			case COM_UART_XR16850:
			case COM_UART_OX16C950:
				pccom_xr16850_fifo_init(iot, ioh);
				if (tp->t_ispeed <= 1200)
					fifo |= FIFO_RCV3_TRIGGER_8|FIFO_XMT3_TRIGGER_8; /* XXX */
				else
					fifo |= FIFO_RCV3_TRIGGER_60|FIFO_XMT3_TRIGGER_56;
				break;
			case COM_UART_TI16750:
				fifo |= FIFO_ENABLE_64BYTE;
				lcr = bus_space_read_1(iot, ioh, com_lcr);
				bus_space_write_1(iot, ioh, com_lcr,
				    lcr | LCR_DLAB);
			default:
				if (tp->t_ispeed <= 1200)
					fifo |= FIFO_TRIGGER_1;
				else
					fifo |= FIFO_TRIGGER_8;
			}

			/*
			 * (Re)enable and drain FIFOs.
			 *
			 * Certain SMC chips cause problems if the FIFOs are
			 * enabled while input is ready. Turn off the FIFO
			 * if necessary to clear the input. Test the input
			 * ready bit after enabling the FIFOs to handle races
			 * between enabling and fresh input.
			 *
			 * Set the FIFO threshold based on the receive speed.
			 */
			for (;;) {
			 	bus_space_write_1(iot, ioh, com_fifo, 0);
				delay(100);
				(void) bus_space_read_1(iot, ioh, com_data);
				bus_space_write_1(iot, ioh, com_fifo, fifo |
				    FIFO_RCV_RST | FIFO_XMT_RST);
				delay(100);
				if(!ISSET(bus_space_read_1(iot, ioh,
				    com_lsr), LSR_RXRDY))
				    	break;
			}
			if (sc->sc_uarttype == COM_UART_TI16750)
				bus_space_write_1(iot, ioh, com_lcr, lcr);
		}

		/* flush any pending I/O */
		while (ISSET(bus_space_read_1(iot, ioh, com_lsr), LSR_RXRDY))
			(void) bus_space_read_1(iot, ioh, com_data);
		/* you turn me on, baby */
		sc->sc_mcr = MCR_DTR | MCR_RTS;
		if (!ISSET(sc->sc_hwflags, COM_HW_NOIEN))
			SET(sc->sc_mcr, MCR_IENABLE);
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		sc->sc_ier = IER_ERXRDY | IER_ERLS | IER_EMSC;
		bus_space_write_1(iot, ioh, com_ier, sc->sc_ier);

		sc->sc_msr = bus_space_read_1(iot, ioh, com_msr);
		if (ISSET(sc->sc_swflags, COM_SW_SOFTCAR) || DEVCUA(dev) ||
		    ISSET(sc->sc_msr, MSR_DCD) || ISSET(tp->t_cflag, MDMBUF))
			SET(tp->t_state, TS_CARR_ON);
		else
			CLR(tp->t_state, TS_CARR_ON);
	} else if (ISSET(tp->t_state, TS_XCLUDE) && p->p_ucred->cr_uid != 0)
		return EBUSY;
	else
		s = spltty();

	if (DEVCUA(dev)) {
		if (ISSET(tp->t_state, TS_ISOPEN)) {
			/* Ah, but someone already is dialed in... */
			splx(s);
			return EBUSY;
		}
		sc->sc_cua = 1;		/* We go into CUA mode */
	} else {
		/* tty (not cua) device; wait for carrier if necessary */
		if (ISSET(flag, O_NONBLOCK)) {
			if (sc->sc_cua) {
				/* Opening TTY non-blocking... but the CUA is busy */
				splx(s);
				return EBUSY;
			}
		} else {
			while (sc->sc_cua ||
			       (!ISSET(tp->t_cflag, CLOCAL) &&
				!ISSET(tp->t_state, TS_CARR_ON))) {
				SET(tp->t_state, TS_WOPEN);
				error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH, ttopen, 0);
				/*
				 * If TS_WOPEN has been reset, that means the cua device
				 * has been closed.  We don't want to fail in that case,
				 * so just go around again.
				 */
				if (error && ISSET(tp->t_state, TS_WOPEN)) {
					CLR(tp->t_state, TS_WOPEN);
					if (!sc->sc_cua && !ISSET(tp->t_state, TS_ISOPEN))
						compwroff(sc);
					splx(s);
					return error;
				}
			}
		}
	}
	splx(s);
	return (*linesw[tp->t_line].l_open)(dev, tp);
}
 
int
comclose(dev_t dev, int flag, int mode, struct proc *p)
{
	int unit = DEVUNIT(dev);
	struct com_softc *sc = pccom_cd.cd_devs[unit];
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct tty *tp = sc->sc_tty;
	int s;

	/* XXX This is for cons.c. */
	if (!ISSET(tp->t_state, TS_ISOPEN))
		return 0;

	(*linesw[tp->t_line].l_close)(tp, flag);
	s = spltty();
	if (ISSET(tp->t_state, TS_WOPEN)) {
		/* tty device is waiting for carrier; drop dtr then re-raise */
		CLR(sc->sc_mcr, MCR_DTR | MCR_RTS);
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		timeout_add_sec(&sc->sc_dtr_tmo, 2);
	} else {
		/* no one else waiting; turn off the uart */
		compwroff(sc);
	}
	CLR(tp->t_state, TS_BUSY | TS_FLUSH);
	sc->sc_cua = 0;
	splx(s);
	ttyclose(tp);

#ifdef notyet /* XXXX */
	if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
		ttyfree(tp);
		sc->sc_tty = 0;
	}
#endif
	return 0;
}

void
compwroff(struct com_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct tty *tp = sc->sc_tty;

	CLR(sc->sc_lcr, LCR_SBREAK);
	bus_space_write_1(iot, ioh, com_lcr, sc->sc_lcr);
	bus_space_write_1(iot, ioh, com_ier, 0);
	if (ISSET(tp->t_cflag, HUPCL) &&
	    !ISSET(sc->sc_swflags, COM_SW_SOFTCAR)) {
		/* XXX perhaps only clear DTR */
		sc->sc_mcr = 0;
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
	}

	/*
	 * Turn FIFO off; enter sleep mode if possible.
	 */
	bus_space_write_1(iot, ioh, com_fifo, 0);
	delay(100);
	(void) bus_space_read_1(iot, ioh, com_data);
	delay(100);
	bus_space_write_1(iot, ioh, com_fifo,
			  FIFO_RCV_RST | FIFO_XMT_RST);

	switch (sc->sc_uarttype) {
	case COM_UART_ST16650:
	case COM_UART_ST16650V2:
	case COM_UART_ST16C654:
	case COM_UART_XR16850:
	case COM_UART_OX16C950:
		bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
		bus_space_write_1(iot, ioh, com_efr, EFR_ECB);
		bus_space_write_1(iot, ioh, com_ier, IER_SLEEP);
		bus_space_write_1(iot, ioh, com_lcr, 0);
		break;
	case COM_UART_TI16750:
		bus_space_write_1(iot, ioh, com_ier, IER_SLEEP);
		break;
	}
}

void
com_raisedtr(void *arg)
{
	struct com_softc *sc = arg;

	SET(sc->sc_mcr, MCR_DTR | MCR_RTS);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_mcr, sc->sc_mcr);
}

int
comread(dev_t dev, struct uio *uio, int flag)
{
	struct com_softc *sc = pccom_cd.cd_devs[DEVUNIT(dev)];
	struct tty *tp = sc->sc_tty;
 
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}
 
int
comwrite(dev_t dev, struct uio *uio, int flag)
{
	struct com_softc *sc = pccom_cd.cd_devs[DEVUNIT(dev)];
	struct tty *tp = sc->sc_tty;
 
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

struct tty *
comtty(dev_t dev)
{
	struct com_softc *sc = pccom_cd.cd_devs[DEVUNIT(dev)];
	struct tty *tp = sc->sc_tty;

	return (tp);
}
 
static u_char
tiocm_xxx2mcr(int data)
{
	u_char m = 0;

	if (ISSET(data, TIOCM_DTR))
		SET(m, MCR_DTR);
	if (ISSET(data, TIOCM_RTS))
		SET(m, MCR_RTS);
	return m;
}

int
comioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	int unit = DEVUNIT(dev);
	struct com_softc *sc = pccom_cd.cd_devs[unit];
	struct tty *tp = sc->sc_tty;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int error;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;

	switch (cmd) {
	case TIOCSBRK:
		SET(sc->sc_lcr, LCR_SBREAK);
		bus_space_write_1(iot, ioh, com_lcr, sc->sc_lcr);
		break;
	case TIOCCBRK:
		CLR(sc->sc_lcr, LCR_SBREAK);
		bus_space_write_1(iot, ioh, com_lcr, sc->sc_lcr);
		break;
	case TIOCSDTR:
		SET(sc->sc_mcr, sc->sc_dtr);
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		break;
	case TIOCCDTR:
		CLR(sc->sc_mcr, sc->sc_dtr);
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		break;
	case TIOCMSET:
		CLR(sc->sc_mcr, MCR_DTR | MCR_RTS);
	case TIOCMBIS:
		SET(sc->sc_mcr, tiocm_xxx2mcr(*(int *)data));
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		break;
	case TIOCMBIC:
		CLR(sc->sc_mcr, tiocm_xxx2mcr(*(int *)data));
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		break;
	case TIOCMGET: {
		u_char m;
		int bits = 0;

		m = sc->sc_mcr;
		if (ISSET(m, MCR_DTR))
			SET(bits, TIOCM_DTR);
		if (ISSET(m, MCR_RTS))
			SET(bits, TIOCM_RTS);
		m = sc->sc_msr;
		if (ISSET(m, MSR_DCD))
			SET(bits, TIOCM_CD);
		if (ISSET(m, MSR_CTS))
			SET(bits, TIOCM_CTS);
		if (ISSET(m, MSR_DSR))
			SET(bits, TIOCM_DSR);
		if (ISSET(m, MSR_RI | MSR_TERI))
			SET(bits, TIOCM_RI);
		if (bus_space_read_1(iot, ioh, com_ier))
			SET(bits, TIOCM_LE);
		*(int *)data = bits;
		break;
	}
	case TIOCGFLAGS: {
		int driverbits, userbits = 0;

		driverbits = sc->sc_swflags;
		if (ISSET(driverbits, COM_SW_SOFTCAR))
			SET(userbits, TIOCFLAG_SOFTCAR);
		if (ISSET(driverbits, COM_SW_CLOCAL))
			SET(userbits, TIOCFLAG_CLOCAL);
		if (ISSET(driverbits, COM_SW_CRTSCTS))
			SET(userbits, TIOCFLAG_CRTSCTS);
		if (ISSET(driverbits, COM_SW_MDMBUF))
			SET(userbits, TIOCFLAG_MDMBUF);

		*(int *)data = userbits;
		break;
	}
	case TIOCSFLAGS: {
		int userbits, driverbits = 0;

		error = suser(p, 0); 
		if (error != 0)
			return(EPERM); 

		userbits = *(int *)data;
		if (ISSET(userbits, TIOCFLAG_SOFTCAR) ||
		    ISSET(sc->sc_hwflags, COM_HW_CONSOLE))
			SET(driverbits, COM_SW_SOFTCAR);
		if (ISSET(userbits, TIOCFLAG_CLOCAL))
			SET(driverbits, COM_SW_CLOCAL);
		if (ISSET(userbits, TIOCFLAG_CRTSCTS))
			SET(driverbits, COM_SW_CRTSCTS);
		if (ISSET(userbits, TIOCFLAG_MDMBUF))
			SET(driverbits, COM_SW_MDMBUF);

		sc->sc_swflags = driverbits;
		break;
	}
	default:
		return ENOTTY;
	}

	return 0;
}

int
comparam(struct tty *tp, struct termios *t)
{
	struct com_softc *sc = pccom_cd.cd_devs[DEVUNIT(tp->t_dev)];
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int ospeed = comspeed(sc->sc_frequency, t->c_ospeed);
	u_int8_t lcr;
	tcflag_t oldcflag;
	int s;

	/* check requested parameters */
	if (ospeed < 0 || (t->c_ispeed && t->c_ispeed != t->c_ospeed))
		return EINVAL;

	lcr = ISSET(sc->sc_lcr, LCR_SBREAK);

	switch (ISSET(t->c_cflag, CSIZE)) {
	case CS5:
		SET(lcr, LCR_5BITS);
		break;
	case CS6:
		SET(lcr, LCR_6BITS);
		break;
	case CS7:
		SET(lcr, LCR_7BITS);
		break;
	case CS8:
		SET(lcr, LCR_8BITS);
		break;
	}
	if (ISSET(t->c_cflag, PARENB)) {
		SET(lcr, LCR_PENAB);
		if (!ISSET(t->c_cflag, PARODD))
			SET(lcr, LCR_PEVEN);
	}
	if (ISSET(t->c_cflag, CSTOPB))
		SET(lcr, LCR_STOPB);

	sc->sc_lcr = lcr;

	s = spltty();

	if (ospeed == 0) {
		CLR(sc->sc_mcr, MCR_DTR);
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
	}

	/*
	 * Set the FIFO threshold based on the receive speed, if we are
	 * changing it.
	 */
	if (sc->sc_initialize || (tp->t_ispeed != t->c_ispeed)) {
		sc->sc_initialize = 0;

		if (ospeed != 0) {
			/*
			 * Make sure the transmit FIFO is empty before
			 * proceeding.  If we don't do this, some revisions
			 * of the UART will hang.  Interestingly enough,
			 * even if we do this while the last character is
			 * still being pushed out, they don't hang.  This
			 * seems good enough.
			 */
			while (ISSET(tp->t_state, TS_BUSY)) {
				int error;

				++sc->sc_halt;
				error = ttysleep(tp, &tp->t_outq,
				    TTOPRI | PCATCH, "comprm", 0);
				--sc->sc_halt;
				if (error) {
					splx(s);
					comstart(tp);
					return (error);
				}
			}

			bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
			bus_space_write_1(iot, ioh, com_dlbl, ospeed);
			bus_space_write_1(iot, ioh, com_dlbh, ospeed >> 8);
			bus_space_write_1(iot, ioh, com_lcr, lcr);
			SET(sc->sc_mcr, MCR_DTR);
			bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		} else
			bus_space_write_1(iot, ioh, com_lcr, lcr);

		if (ISSET(sc->sc_hwflags, COM_HW_FIFO)) {
			u_int8_t fifo = FIFO_ENABLE;
			u_int8_t lcr2;

			switch (sc->sc_uarttype) {
			case COM_UART_ST16650V2:
				if (t->c_ispeed <= 1200)
					fifo |= FIFO_RCV_TRIGGER_8|FIFO_XMT_TRIGGER_8; /* XXX */
				else
					fifo |= FIFO_RCV_TRIGGER_28|FIFO_XMT_TRIGGER_30;
				break;
			case COM_UART_ST16C654:
			case COM_UART_XR16850:
			case COM_UART_OX16C950:
				if (t->c_ispeed <= 1200)
					fifo |= FIFO_RCV3_TRIGGER_8|FIFO_XMT3_TRIGGER_8; /* XXX */
				else
					fifo |= FIFO_RCV3_TRIGGER_60|FIFO_XMT3_TRIGGER_56;
				break;
			case COM_UART_TI16750:
				fifo |= FIFO_ENABLE_64BYTE;
				lcr2 = bus_space_read_1(iot, ioh, com_lcr);
				bus_space_write_1(iot, ioh, com_lcr,
				    lcr2 | LCR_DLAB);
			default:
				if (t->c_ispeed <= 1200)
					fifo |= FIFO_TRIGGER_1;
				else
					fifo |= FIFO_TRIGGER_8;
			}
			bus_space_write_1(iot, ioh, com_fifo, fifo);

			if (sc->sc_uarttype == COM_UART_TI16750)
				bus_space_write_1(iot, ioh, com_lcr, lcr2);
		}
	} else
		bus_space_write_1(iot, ioh, com_lcr, lcr);

	/* When not using CRTSCTS, RTS follows DTR. */
	if (!ISSET(t->c_cflag, CRTSCTS)) {
		if (ISSET(sc->sc_mcr, MCR_DTR)) {
			if (!ISSET(sc->sc_mcr, MCR_RTS)) {
				SET(sc->sc_mcr, MCR_RTS);
				bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
			}
		} else {
			if (ISSET(sc->sc_mcr, MCR_RTS)) {
				CLR(sc->sc_mcr, MCR_RTS);
				bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
			}
		}
		sc->sc_dtr = MCR_DTR | MCR_RTS;
	} else
		sc->sc_dtr = MCR_DTR;

	/* and copy to tty */
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	oldcflag = tp->t_cflag;
	tp->t_cflag = t->c_cflag;

	/*
	 * If DCD is off and MDMBUF is changed, ask the tty layer if we should
	 * stop the device.
	 */
	if (!ISSET(sc->sc_msr, MSR_DCD) &&
	    !ISSET(sc->sc_swflags, COM_SW_SOFTCAR) &&
	    ISSET(oldcflag, MDMBUF) != ISSET(tp->t_cflag, MDMBUF) &&
	    (*linesw[tp->t_line].l_modem)(tp, 0) == 0) {
		CLR(sc->sc_mcr, sc->sc_dtr);
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
	}

	/* Just to be sure... */
	splx(s);
	comstart(tp);
	return 0;
}

/*
 * (un)block input via hw flowcontrol
 */
int
comhwiflow(struct tty *tp, int block)
{
	struct com_softc *sc = pccom_cd.cd_devs[DEVUNIT(tp->t_dev)];
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int	s;

/*
 * XXX
 * Is spltty needed at all ? sc->sc_mcr is only in comsoft() not comintr()
 */
	s = spltty();
	if (block) {
		/* When not using CRTSCTS, RTS follows DTR. */
		if (ISSET(tp->t_cflag, MDMBUF)) {
			CLR(sc->sc_mcr, (MCR_DTR | MCR_RTS));
			bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		}
		else {
			CLR(sc->sc_mcr, MCR_RTS);
			bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		}
	}
	else {
		/* When not using CRTSCTS, RTS follows DTR. */
		if (ISSET(tp->t_cflag, MDMBUF)) {
			SET(sc->sc_mcr, (MCR_DTR | MCR_RTS));
			bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		}
		else {
			SET(sc->sc_mcr, MCR_RTS);
			bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		}
	}
	splx(s);
	return 1;
}

void
comstart(struct tty *tp)
{
	struct com_softc *sc = pccom_cd.cd_devs[DEVUNIT(tp->t_dev)];
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int s, count;

	s = spltty();
	if (ISSET(tp->t_state, TS_BUSY))
		goto out;
	if (ISSET(tp->t_state, TS_TIMEOUT | TS_TTSTOP) || sc->sc_halt > 0)
		goto stopped;
	if (ISSET(tp->t_cflag, CRTSCTS) && !ISSET(sc->sc_msr, MSR_CTS))
		goto stopped;
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (ISSET(tp->t_state, TS_ASLEEP)) {
			CLR(tp->t_state, TS_ASLEEP);
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}
	count = ndqb(&tp->t_outq, 0);
	splhigh();
	if (count > 0) {
		int n;

		SET(tp->t_state, TS_BUSY);
		if (!ISSET(sc->sc_ier, IER_ETXRDY)) {
			SET(sc->sc_ier, IER_ETXRDY);
			bus_space_write_1(iot, ioh, com_ier, sc->sc_ier);
		}
		n = sc->sc_fifolen;
		if (n > count)
			n = count;
		sc->sc_tba = tp->t_outq.c_cf;
		while (--n >= 0) {
			bus_space_write_1(iot, ioh, com_data, *sc->sc_tba++);
			--count;
		}
		sc->sc_tbc = count;
		goto out;
	}
stopped:
	if (ISSET(sc->sc_ier, IER_ETXRDY)) {
		CLR(sc->sc_ier, IER_ETXRDY);
		bus_space_write_1(iot, ioh, com_ier, sc->sc_ier);
	}
out:
	splx(s);
	return;
}

/*
 * Stop output on a line.
 */
int
comstop(struct tty *tp, int flag)
{
	int s;
	struct com_softc *sc = pccom_cd.cd_devs[DEVUNIT(tp->t_dev)];

	s = splhigh();
	if (ISSET(tp->t_state, TS_BUSY)) {
		sc->sc_tbc = 0;
		if (!ISSET(tp->t_state, TS_TTSTOP))
			SET(tp->t_state, TS_FLUSH);
	}
	splx(s);
	return 0;
}

void
comdiag(void *arg)
{
	struct com_softc *sc = arg;
	int overflows;
	int s;

	s = spltty();
	overflows = sc->sc_overflows;
	sc->sc_overflows = 0;
	splx(s);

	if (overflows)
		log(LOG_WARNING, "%s: %d silo overflow%s\n",
		    sc->sc_dev.dv_xname, overflows, overflows == 1 ? "" : "s");
}

#ifdef PCCOM_DEBUG
int	maxcc = 0;
#endif

void
comsoft(void)
{
	struct com_softc	*sc;
	struct tty *tp;
	struct linesw	*line;
	int	unit, s, c;
	u_int rxget;
	static int lsrmap[8] = {
		0,      TTY_PE,
		TTY_FE, TTY_PE|TTY_FE,
		TTY_FE, TTY_PE|TTY_FE,
		TTY_FE, TTY_PE|TTY_FE
	};

	for (unit = 0; unit < pccom_cd.cd_ndevs; unit++) {
		sc = pccom_cd.cd_devs[unit];
		if (sc == NULL)
			continue;
		tp = sc->sc_tty;
/*
 * XXX only use (tp == NULL) ???
 */
		if (tp == NULL || !ISSET(tp->t_state, TS_ISOPEN | TS_WOPEN))
			continue;
	 	line = &linesw[tp->t_line];
/*
 * XXX where do we _really_ need spltty(), if at all ???
 */
		s = spltty();
		rxget = sc->sc_rxget;
		while (rxget != sc->sc_rxput) {
			u_int8_t lsr;

			lsr = sc->sc_rxbuf[rxget];
			rxget = (rxget + 1) & RBUFMASK;
			if (ISSET(lsr, LSR_RCV_MASK)) {
				c = sc->sc_rxbuf[rxget];
				if (ISSET(lsr, LSR_OE)) {
					sc->sc_overflows++;
					if (sc->sc_errors++ == 0)
						timeout_add_sec(
						    &sc->sc_diag_tmo, 60);
				}
				rxget = (rxget + 1) & RBUFMASK;
				c |= lsrmap[(lsr & (LSR_BI|LSR_FE|LSR_PE)) >> 2];
				line->l_rint(c, tp);
			}
			else if (ISSET(lsr, LSR_TXRDY)) {
				CLR(tp->t_state, TS_BUSY);
				if (ISSET(tp->t_state, TS_FLUSH))
					CLR(tp->t_state, TS_FLUSH);
				else
					ndflush(&tp->t_outq,
				 	(int)(sc->sc_tba - tp->t_outq.c_cf));
				if (sc->sc_halt > 0)
					wakeup(&tp->t_outq);
				line->l_start(tp);
			}
			else if (lsr == 0) {
				u_int8_t msr;

				msr = sc->sc_rxbuf[rxget];
				rxget = (rxget + 1) & RBUFMASK;
				if (ISSET(msr, MSR_DDCD) &&
		    		   !ISSET(sc->sc_swflags, COM_SW_SOFTCAR)) {
					if (ISSET(msr, MSR_DCD))
						line->l_modem(tp, 1);
					else if (line->l_modem(tp, 0) == 0) {
						CLR(sc->sc_mcr, sc->sc_dtr);
						bus_space_write_1(sc->sc_iot,
							       sc->sc_ioh,
							       com_mcr,
							       sc->sc_mcr);
					}
				}
				if (ISSET(msr, MSR_DCTS) &&
				    ISSET(msr, MSR_CTS) &&
				    ISSET(tp->t_cflag, CRTSCTS))
					line->l_start(tp);
			}
		}
		sc->sc_rxget = rxget;
/*
 * XXX this is the place where we could unblock the input
 */
		splx(s);
	}
}

#ifdef KGDB

/*
 * If a line break is set, or data matches one of the characters
 * gdb uses to signal a connection, then start up kgdb. Just gobble
 * any other data. Done in a stand alone function because comintr
 * does tty stuff and we don't have one.
 */

int
kgdbintr(void *arg)
{
	struct com_softc *sc = arg;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_char lsr, data, msr, delta;

	if (!ISSET(sc->sc_hwflags, COM_HW_KGDB))
		return(0);

	for (;;) {
		lsr = bus_space_read_1(iot, ioh, com_lsr);
		if (ISSET(lsr, LSR_RXRDY)) {
			do {
				data = bus_space_read_1(iot, ioh, com_data);
				if (data == 3 || data == '$' || data == '+' ||
				    ISSET(lsr, LSR_BI)) {
					kgdb_connect(1);
					data = 0;
				}
				lsr = bus_space_read_1(iot, ioh, com_lsr);
			} while (ISSET(lsr, LSR_RXRDY));

		}
		if (ISSET(lsr, LSR_BI|LSR_FE|LSR_PE|LSR_OE))
			printf("weird lsr %02x\n", lsr);

		msr = bus_space_read_1(iot, ioh, com_msr);

		if (msr != sc->sc_msr) {
			delta = msr ^ sc->sc_msr;
			sc->sc_msr = msr;
			if (ISSET(delta, MSR_DCD)) {
				if (!ISSET(sc->sc_swflags, COM_SW_SOFTCAR)) {
					CLR(sc->sc_mcr, sc->sc_dtr);
					bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
				}
			}
		}
		if (ISSET(bus_space_read_1(iot, ioh, com_iir), IIR_NOPEND))
			return (1);
	}
}
#endif /* KGDB */

int
comintr(void *arg)
{
	struct com_softc *sc = arg;
	struct tty *tp = sc->sc_tty;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int8_t lsr, c;
	u_int	rxput;

	if (!sc->sc_tty)
		return (0);	/* can't do squat. */

	if (ISSET(bus_space_read_1(iot, ioh, com_iir), IIR_NOPEND))
		return (0);

	rxput = sc->sc_rxput;
	do {
		u_int8_t msr, delta;

		for (;;) {
			lsr = bus_space_read_1(iot, ioh, com_lsr);
			if (!ISSET(lsr, LSR_RCV_MASK))
				break;
			c = bus_space_read_1(iot, ioh, com_data);
			if (ISSET(lsr, LSR_BI)) {
#ifdef DDB
				if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
					if (db_console)
			 			Debugger();
					continue;
				}
#endif
				c = 0;
 			}

			sc->sc_rxbuf[rxput] = lsr;
			rxput = (rxput + 1) & RBUFMASK;
			sc->sc_rxbuf[rxput] = c;
			rxput = (rxput + 1) & RBUFMASK;
		}
		msr = bus_space_read_1(iot, ioh, com_msr);
		delta = msr ^ sc->sc_msr;

		ttytstamp(tp, sc->sc_msr & MSR_CTS, msr & MSR_CTS,
		    sc->sc_msr & MSR_DCD, msr & MSR_DCD);

		if (!ISSET(delta, MSR_DCD | MSR_CTS | MSR_RI | MSR_DSR))
			continue;
		sc->sc_msr = msr;
/*
 * stop output straight away if CTS drops and RTS/CTS flowcontrol is used
 * XXX what about DTR/DCD flowcontrol (ISSET(t_cflag, MDMBUF))
 */
		msr = (msr & 0xf0) | (delta >> 4);
		if (ISSET(tp->t_cflag, CRTSCTS) && ISSET(msr, MSR_DCTS)) {
			if (!ISSET(msr, MSR_CTS))
				sc->sc_tbc = 0;
		}
		sc->sc_rxbuf[rxput] = 0;
		rxput = (rxput + 1) & RBUFMASK;
		sc->sc_rxbuf[rxput] = msr;
		rxput = (rxput + 1) & RBUFMASK;
	} while (!ISSET(bus_space_read_1(iot, ioh, com_iir), IIR_NOPEND));
	if (ISSET(lsr, LSR_TXRDY)) {
		if (sc->sc_tbc > 0) {
			int	n;

			n = sc->sc_fifolen;
			if (n > sc->sc_tbc)
				n = sc->sc_tbc;
			while (--n >= 0) {
				bus_space_write_1(iot, ioh, com_data, *sc->sc_tba++);
				--sc->sc_tbc;
			}
		}
		else if (ISSET(tp->t_state, TS_BUSY)) {
			sc->sc_rxbuf[rxput] = lsr;
			rxput = (rxput + 1) & RBUFMASK;
		}
	}
	if (sc->sc_rxput != rxput) {
/*
 * XXX
 * This is the place to do input flow control by dropping RTS or DTR.
 * However, 115200 bps transfers get maxcc only up to 112 while there's
 * room for 512 so should we bother ?
 */
#ifdef PCCOM_DEBUG
		int	cc;

		cc = rxput - sc->sc_rxget;
		if (cc < 0)
			cc += RBUFSIZE;
		if (cc > maxcc)
			maxcc = cc;
#endif
		sc->sc_rxput = rxput;
		setsofttty();
	}
	return 1;
}

void
pccom_xr16850_fifo_init(bus_space_tag_t iot, bus_space_handle_t ioh)
{
	u_int8_t lcr, efr, fctl;

	lcr = bus_space_read_1(iot, ioh, com_lcr);
	bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
	efr = bus_space_read_1(iot, ioh, com_efr);
	bus_space_write_1(iot, ioh, com_efr, efr | EFR_ECB);
	fctl = bus_space_read_1(iot, ioh, com_fctl);
	bus_space_write_1(iot, ioh, com_fctl, fctl | FCTL_TRIGGER3);
	bus_space_write_1(iot, ioh, com_lcr, lcr);
}

/*
 * Following are all routines needed for PCCOM to act as console
 */

void
comcnprobe(struct consdev *cp)
{
	/* XXX NEEDS TO BE FIXED XXX */
	bus_space_tag_t iot = 0;
	bus_space_handle_t ioh;
	int found;

	if (bus_space_map(iot, CONADDR, COM_NPORTS, 0, &ioh))
		return;
	found = comprobe1(iot, ioh);
	bus_space_unmap(iot, ioh, COM_NPORTS);
	if (!found)
		return;

	/* locate the major number */
	for (commajor = 0; commajor < nchrdev; commajor++)
		if (cdevsw[commajor].d_open == comopen)
			break;

	/* initialize required fields */
	cp->cn_dev = makedev(commajor, CONUNIT);
#if defined(COMCONSOLE) || defined(PCCOMCONSOLE)
	cp->cn_pri = CN_HIGHPRI;	/* Force a serial port console */
#else
	cp->cn_pri = CN_LOWPRI;
#endif
}

/*
 * The following functions are polled getc and putc routines, shared
 * by the console and kgdb glue.
 */

int
com_common_getc(bus_space_tag_t iot, bus_space_handle_t ioh)
{
	int s = splhigh();
	u_char stat, c;

	/* block until a character becomes available */
	while (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_RXRDY))
		continue;

	c = bus_space_read_1(iot, ioh, com_data);
	/* clear any interrupts generated by this transmission */
	stat = bus_space_read_1(iot, ioh, com_iir);
	splx(s);
	return (c);
}

void
com_common_putc(bus_space_tag_t iot, bus_space_handle_t ioh, int c)
{
	int s = splhigh();
	int timo;

	/* wait for any pending transmission to finish */
	timo = 150000;
	while (!ISSET(bus_space_read_1(iot, ioh, com_lsr), LSR_TXRDY) && --timo)
		continue;

	bus_space_write_1(iot, ioh, com_data, c);

	/* wait for this transmission to complete */
	timo = 1500000;
	while (!ISSET(bus_space_read_1(iot, ioh, com_lsr), LSR_TXRDY) && --timo)
		continue;

	splx(s);
}

/*
 * Following are all routines needed for COM to act as console
 */

void
comcninit(struct consdev *cp)
{
	comconsiot = I386_BUS_SPACE_IO;

#ifdef CONADDR_OVERRIDE
	comconsaddr = CONADDR;
#else
	const int comports[4] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8 };
	int unit = minor(cp->cn_dev);

	if (unit >= 0 && unit < 4)
		comconsaddr = comports[unit];
	else
		comconsaddr = CONADDR;
#endif

	if (bus_space_map(comconsiot, comconsaddr, COM_NPORTS, 0, &comconsioh))
		panic("comcninit: mapping failed");

	cominit(comconsiot, comconsioh, comconsrate);
	comconsinit = 0;
}

void
cominit(bus_space_tag_t iot, bus_space_handle_t ioh, int rate)
{
	int s = splhigh();
	u_int8_t stat;

	bus_space_write_1(iot, ioh, com_lcr, LCR_DLAB);
	rate = comspeed(COM_FREQ, rate); /* XXX not comdefaultrate? */
	bus_space_write_1(iot, ioh, com_dlbl, rate);
	bus_space_write_1(iot, ioh, com_dlbh, rate >> 8);
	bus_space_write_1(iot, ioh, com_lcr, LCR_8BITS);
	bus_space_write_1(iot, ioh, com_mcr, MCR_DTR | MCR_RTS);
	bus_space_write_1(iot, ioh, com_ier, IER_ERXRDY | IER_ETXRDY);
	bus_space_write_1(iot, ioh, com_fifo,
	    FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_4);
	stat = bus_space_read_1(iot, ioh, com_iir);
	splx(s);
}

int
comcngetc(dev_t dev)
{
	return (com_common_getc(comconsiot, comconsioh));
}

/*
 * Console kernel output character routine.
 */
void
comcnputc(dev_t dev, int c)
{
#if 0
	/* XXX not needed? */
	bus_space_tag_t iot = comconsiot;
	bus_space_handle_t ioh = comconsioh;

	if (comconsinit == 0) {
		cominit(iot, ioh, comdefaultrate);
		comconsinit = 1;
	}
#endif
	com_common_putc(comconsiot, comconsioh, c);
}

void
comcnpollc(dev_t dev, int on)
{

}

#ifdef KGDB
int
com_kgdb_attach(bus_space_tag_t iot, bus_addr_t iobase, int rate, int frequency,
    tcflag_t cflag)
{
	if (iot == comconsiot && iobase == comconsaddr) {
		return (EBUSY); /* cannot share with console */
	}

	com_kgdb_iot = iot;
	com_kgdb_addr = iobase;

	if (bus_space_map(com_kgdb_iot, com_kgdb_addr, COM_NPORTS, 0,
	    &com_kgdb_ioh))
		panic("com_kgdb_attach: mapping failed");

	/* XXX We currently don't respect KGDBMODE? */
	cominit(com_kgdb_iot, com_kgdb_ioh, rate);

	kgdb_attach(com_kgdb_getc, com_kgdb_putc, NULL);
	kgdb_dev = 123; /* unneeded, only to satisfy some tests */

	return (0);
}

/* ARGSUSED */
int
com_kgdb_getc(void *arg)
{

	return (com_common_getc(com_kgdb_iot, com_kgdb_ioh));
}

/* ARGSUSED */
void
com_kgdb_putc(void *arg, int c)
{

	return (com_common_putc(com_kgdb_iot, com_kgdb_ioh, c));
}
#endif /* KGDB */
@


1.64
log
@Initialize comconsiot in comcninit().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.63 2008/03/29 15:26:47 krw Exp $	*/
d707 1
a707 1
		timeout_add(&sc->sc_dtr_tmo, hz * 2);
d1271 2
a1272 1
						timeout_add(&sc->sc_diag_tmo, 60 * hz);
@


1.63
log
@Fix amd64 and i386 serial console handling for non-default speeds. Bring
i386 pccom into line with com. Problem reported and first diff by Markus
Hennecke, who also tested and corrected subsequent diffs. Boot messages
and console now work with his 57K serial connections.

Suggestions and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.62 2008/01/23 16:37:56 jsing Exp $	*/
d1574 1
a1574 5

#if 0
	XXX NEEDS TO BE FIXED XXX
	comconsiot = ???;
#endif
@


1.62
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.61 2007/05/09 14:32:17 deraadt Exp $	*/
a141 3
#if defined(COMCONSOLE) || defined(PCCOMCONSOLE)
int	comdefaultrate = CONSPEED;		/* XXX why set default? */
#else
d143 1
a143 2
#endif
bus_addr_t comconsaddr;
d146 1
d516 1
a516 1
		if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE))
d518 2
a519 1
		else
d521 2
a529 1
		tp->t_ispeed = tp->t_ospeed = comdefaultrate;
d1595 1
a1595 1
	cominit(comconsiot, comconsioh, comdefaultrate);
@


1.61
log
@unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.60 2007/05/08 21:28:11 deraadt Exp $	*/
d1519 1
a1519 1
	cp->cn_pri = CN_REMOTE;		/* Force a serial port console */
d1521 1
a1521 1
	cp->cn_pri = CN_NORMAL;
@


1.60
log
@backout while the amd64 puc situation is rethought
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.57 2007/02/15 18:39:26 mickey Exp $	*/
a155 1
int	comevents = 0;
@


1.59
log
@move com_activate() to where it belongs
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.58 2007/05/08 20:33:07 deraadt Exp $	*/
d156 1
d415 62
@


1.58
log
@put more foo_detach() routines where they are used
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.57 2007/02/15 18:39:26 mickey Exp $	*/
a155 1
int	comevents = 0;
a413 32
}

int
com_activate(struct device *self, enum devact act)
{
	struct com_softc *sc = (struct com_softc *)self;
	int s, rv = 0;

	/* XXX splserial, when we get that.  */
	s = spltty();
	switch (act) {
	case DVACT_ACTIVATE:
		break;

	case DVACT_DEACTIVATE:
#ifdef KGDB
		if (sc->sc_hwflags & (COM_HW_CONSOLE|COM_HW_KGDB)) {
#else
		if (sc->sc_hwflags & COM_HW_CONSOLE) {
#endif /* KGDB */
			rv = EBUSY;
			break;
		}

		if (sc->disable != NULL && sc->enabled != 0) {
			(*sc->disable)(sc);
			sc->enabled = 0;
		}
		break;
	}
	splx(s);
	return (rv);
@


1.57
log
@break into ddb right from comintr() w/o softtty (same as com(4) does); miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.56 2006/12/28 20:50:21 miod Exp $	*/
a414 30
}

int
com_detach(struct device *self, int flags)
{
	struct com_softc *sc = (struct com_softc *)self;
	int maj, mn;

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == comopen)
			break;

	/* Nuke the vnodes for any open instances. */
	mn = self->dv_unit;
	vdevgone(maj, mn, mn, VCHR);

	/* XXX a symbolic constant for the cua bit would be nicer. */
	mn |= 0x80;
	vdevgone(maj, mn, mn, VCHR);

	/* Detach and free the tty. */
	if (sc->sc_tty) {
		ttyfree(sc->sc_tty);
	}

	timeout_del(&sc->sc_dtr_tmo);
	timeout_del(&sc->sc_diag_tmo);

	return (0);
@


1.56
log
@Support for ST16C654 chips, however these aren't detected as such, so the
attachment code has to know better for now;
from Alexei G. Malinin (alexei.malinin@@inetcomm.ru)
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.55 2006/09/19 11:06:34 jsg Exp $	*/
d1269 1
a1269 13
				if (ISSET(lsr, LSR_BI)) {
#ifdef DDB
					if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
						if (db_console)
					 		Debugger();
						rxget = (rxget + 1) & RBUFMASK;
						continue;
 					}
#endif
					c = 0;
				}
				else
					c = sc->sc_rxbuf[rxget];
d1383 1
a1383 1
	u_int8_t lsr;
d1400 12
d1414 1
a1414 1
			sc->sc_rxbuf[rxput] = bus_space_read_1(iot, ioh, com_data);
@


1.55
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.54 2006/07/31 11:06:20 mickey Exp $	*/
d544 1
d575 6
d758 1
d1029 1
@


1.54
log
@puc@@cardbus (only added (commented out) to whom has puc@@pci enabled)
tested on puc@@pci by fkr and meself on the cardbus.
still needs a bit more work but generally works.
deraadt@@ ok and some input from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.53 2006/06/23 06:27:08 miod Exp $	*/
d192 1
a192 3
comspeed(freq, speed)
	long freq;
	long speed;
d216 1
a216 3
comprobe1(iot, ioh)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d237 1
a237 3
comprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d310 1
a310 3
comattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d418 1
a418 3
com_detach(self, flags)
	struct device *self;
	int flags;
d448 1
a448 3
com_activate(self, act)
	struct device *self;
	enum devact act;
d480 1
a480 4
comopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d683 1
a683 4
comclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d722 1
a722 2
compwroff(sc)
	struct com_softc *sc;
d765 1
a765 2
com_raisedtr(arg)
	void *arg;
d774 1
a774 4
comread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d783 1
a783 4
comwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d792 1
a792 2
comtty(dev)
	dev_t dev;
d801 1
a801 2
tiocm_xxx2mcr(data)
	int data;
d813 1
a813 6
comioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d924 1
a924 3
comparam(tp, t)
	struct tty *tp;
	struct termios *t;
d1092 1
a1092 3
comhwiflow(tp, block)
	struct tty *tp;
	int block;
d1131 1
a1131 2
comstart(tp)
	struct tty *tp;
d1187 1
a1187 3
comstop(tp, flag)
	struct tty *tp;
	int flag;
d1203 1
a1203 2
comdiag(arg)
	void *arg;
d1224 1
a1224 1
comsoft()
d1334 1
a1334 2
kgdbintr(arg)
	void *arg;
d1380 1
a1380 2
comintr(arg)
	void	*arg;
d1471 1
a1471 3
pccom_xr16850_fifo_init(iot, ioh)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d1489 1
a1489 2
comcnprobe(cp)
	struct consdev *cp;
d1523 1
a1523 3
com_common_getc(iot, ioh)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d1540 1
a1540 4
com_common_putc(iot, ioh, c)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int c;
d1565 1
a1565 2
comcninit(cp)
	struct consdev *cp;
d1593 1
a1593 4
cominit(iot, ioh, rate)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int rate;
d1612 1
a1612 2
comcngetc(dev)
	dev_t dev;
d1621 1
a1621 3
comcnputc(dev, c)
	dev_t dev;
	int c;
d1637 1
a1637 3
comcnpollc(dev, on)
	dev_t dev;
	int on;
d1644 2
a1645 5
com_kgdb_attach(iot, iobase, rate, frequency, cflag)
	bus_space_tag_t iot;
	bus_addr_t iobase;
	int rate, frequency;
	tcflag_t cflag;
d1669 1
a1669 2
com_kgdb_getc(arg)
	void *arg;
d1677 1
a1677 3
com_kgdb_putc(arg, c)
	void *arg;
	int c;
@


1.53
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.52 2006/06/15 15:44:45 jason Exp $	*/
d560 1
d590 1
d771 1
d1057 1
@


1.52
log
@make the clock error calculation match dev/ic/com.c so that things with,
say, a 10x clock work.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.51 2006/04/27 19:31:43 deraadt Exp $	*/
a468 1
		rv = EOPNOTSUPP;
@


1.51
log
@2 lines of code in most drivers, to do the timestamping; ok miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.50 2006/01/01 11:59:39 miod Exp $	*/
d207 1
a207 1
	err = divrnd((freq / 16) * 1000, speed * x) - 1000;
@


1.50
log
@Let cons_init() and cons_init_bell() initialize the whole consdev structure,
thus removing the need for drivers to initialize cn_pri to CN_DEAD when
hardware probe fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.49 2005/11/21 18:16:36 millert Exp $	*/
d1450 4
@


1.49
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.48 2005/10/24 14:22:34 fgsch Exp $	*/
d1535 1
a1535 2
	if (bus_space_map(iot, CONADDR, COM_NPORTS, 0, &ioh)) {
		cp->cn_pri = CN_DEAD;
a1536 1
	}
d1539 1
a1539 2
	if (!found) {
		cp->cn_pri = CN_DEAD;
a1540 1
	}
@


1.48
log
@fix compilation for KGDB; looked by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.47 2005/09/26 22:32:05 miod Exp $	*/
d70 1
a70 1
#include <sys/select.h>
@


1.47
log
@Share com probe code between com and pccom; allows us to get rid of awkward
code duplication in cardbus, pcmcia and puc attachments.

Joint effort with fgs@@; blessed deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.46 2004/12/23 17:50:24 markus Exp $	*/
d147 1
a147 1
int	comconsaddr;
d161 3
a163 4
static	int com_kgdb_addr;
static	bus_space_tag_t com_kgdb_iot;
static	bus_space_handle_t com_kgdb_ioh;
static	int com_kgdb_attached;
d321 1
a321 1
	int iobase, irq;
d324 1
a424 18
#ifdef KGDB
void
com_enable_debugport(sc)
	struct com_softc *sc;
{
	int s;

	/* Turn on line break interrupt, set carrier. */
	s = splhigh();
	SET(sc->sc_ier, IER_ERXRDY);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_ier, sc->sc_ier);
	SET(sc->sc_mcr, MCR_DTR | MCR_RTS | MCR_IENABLE);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_mcr, sc->sc_mcr);

	splx(s);
}
#endif /* KGDB */

d1703 1
a1703 1
	int iobase;
@


1.46
log
@make com[123] work for console on i386, but allow override with CONADDR/CONUNIT
ok mickey, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.45 2003/10/03 16:44:49 miod Exp $	*/
a90 3
#ifdef COM_HAYESP
#include <dev/ic/hayespreg.h>
#endif
a100 1
bdev_decl(com);
a240 65
#ifdef COM_HAYESP
int
comprobeHAYESP(hayespioh, sc)
	bus_space_handle_t hayespioh;
	struct com_softc *sc;
{
	char	val, dips;
	int	combaselist[] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8 };
	bus_space_tag_t iot = sc->sc_iot;

	/*
	 * Hayes ESP cards have two iobases.  One is for compatibility with
	 * 16550 serial chips, and at the same ISA PC base addresses.  The
	 * other is for ESP-specific enhanced features, and lies at a
	 * different addressing range entirely (0x140, 0x180, 0x280, or 0x300).
	 */

	/* Test for ESP signature */
	if ((bus_space_read_1(iot, hayespioh, 0) & 0xf3) == 0)
		return 0;

	/*
	 * ESP is present at ESP enhanced base address; unknown com port
	 */

	/* Get the dip-switch configurations */
	bus_space_write_1(iot, hayespioh, HAYESP_CMD1, HAYESP_GETDIPS);
	dips = bus_space_read_1(iot, hayespioh, HAYESP_STATUS1);

	/* Determine which com port this ESP card services: bits 0,1 of  */
	/*  dips is the port # (0-3); combaselist[val] is the com_iobase */
	if (sc->sc_iobase != combaselist[dips & 0x03])
		return 0;

	printf(": ESP");

 	/* Check ESP Self Test bits. */
	/* Check for ESP version 2.0: bits 4,5,6 == 010 */
	bus_space_write_1(iot, hayespioh, HAYESP_CMD1, HAYESP_GETTEST);
	val = bus_space_read_1(iot, hayespioh, HAYESP_STATUS1); /* Clear reg 1 */
	val = bus_space_read_1(iot, hayespioh, HAYESP_STATUS2);
	if ((val & 0x70) < 0x20) {
		printf("-old (%o)", val & 0x70);
		/* we do not support the necessary features */
		return 0;
	}

	/* Check for ability to emulate 16550: bit 8 == 1 */
	if ((dips & 0x80) == 0) {
		printf(" slave");
		/* XXX Does slave really mean no 16550 support?? */
		return 0;
	}

	/*
	 * If we made it this far, we are a full-featured ESP v2.0 (or
	 * better), at the correct com port address.
	 */

	SET(sc->sc_hwflags, COM_HW_HAYESP);
	printf(", 1024 byte fifo\n");
	return 1;
}
#endif

a324 5
#ifdef COM_HAYESP
	int	hayesp_ports[] = { 0x140, 0x180, 0x280, 0x300, 0 };
	int	*hayespp;
#endif
	u_int8_t lcr;
a330 2
	sc->sc_hwflags = 0;
	sc->sc_swflags = 0;
d390 2
a391 2
	timeout_set(&sc->sc_dtr_tmo, com_raisedtr, sc);
	timeout_set(&sc->sc_diag_tmo, comdiag, sc);
d393 3
a395 59
	if (iobase == comconsaddr) {
		comconsattached = 1;

		/* 
		 * Need to reset baud rate, etc. of next print so reset
		 * comconsinit.  Also make sure console is always "hardwired".
		 */
		delay(1000);			/* wait for output to finish */
		comconsinit = 0;
		SET(sc->sc_hwflags, COM_HW_CONSOLE);
		SET(sc->sc_swflags, COM_SW_SOFTCAR);
	}

#ifdef COM_HAYESP
	/* Look for a Hayes ESP board. */
	for (hayespp = hayesp_ports; *hayespp != 0; hayespp++) {
		bus_space_handle_t hayespioh;

#define	HAYESP_NPORTS	8			/* XXX XXX XXX ??? ??? ??? */
		if (bus_space_map(iot, *hayespp, HAYESP_NPORTS, 0, &hayespioh))
			continue;
		if (comprobeHAYESP(hayespioh, sc)) {
			sc->sc_hayespbase = *hayespp;
			sc->sc_hayespioh = hayespioh;
			sc->sc_fifolen = 1024;
			break;
		}
		bus_space_unmap(iot, hayespioh, HAYESP_NPORTS);
	}
	/* No ESP; look for other things. */
	if (*hayespp == 0) {
#endif

	/*
	 * Probe for all known forms of UART.
	 */
	lcr = bus_space_read_1(iot, ioh, com_lcr);

	bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
	bus_space_write_1(iot, ioh, com_efr, 0);
	bus_space_write_1(iot, ioh, com_lcr, 0);

	bus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE);
	delay(100);

	switch(bus_space_read_1(iot, ioh, com_iir) >> 6) {
	case 0:
		sc->sc_uarttype = COM_UART_16450;
		break;
	case 2:
		sc->sc_uarttype = COM_UART_16550;
		break;
	case 3:
		sc->sc_uarttype = COM_UART_16550A;
		break;
	default:
		sc->sc_uarttype = COM_UART_UNKNOWN;
		break;
	}
a396 120
	if (sc->sc_uarttype == COM_UART_16550A) { /* Probe for ST16650s */
		bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
		if (bus_space_read_1(iot, ioh, com_efr) == 0) {
			sc->sc_uarttype = COM_UART_ST16650;
		} else {
			bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
			if (bus_space_read_1(iot, ioh, com_efr) == 0)
				sc->sc_uarttype = COM_UART_ST16650V2;
		}
	}

	if (sc->sc_uarttype == COM_UART_ST16650V2) {	/* Probe for XR16850s */
		u_int8_t dlbl, dlbh;

		/* Enable latch access and get the current values. */
		bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
		dlbl = bus_space_read_1(iot, ioh, com_dlbl);
		dlbh = bus_space_read_1(iot, ioh, com_dlbh);

		/* Zero out the latch divisors */
		bus_space_write_1(iot, ioh, com_dlbl, 0);
		bus_space_write_1(iot, ioh, com_dlbh, 0);

		if (bus_space_read_1(iot, ioh, com_dlbh) == 0x10) {
			sc->sc_uarttype = COM_UART_XR16850;
			sc->sc_uartrev = bus_space_read_1(iot, ioh, com_dlbl);
		}

		/* Reset to original. */
		bus_space_write_1(iot, ioh, com_dlbl, dlbl);
		bus_space_write_1(iot, ioh, com_dlbh, dlbh);
	}

	if (sc->sc_uarttype == COM_UART_16550A) { /* Probe for TI16750s */
		bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
		bus_space_write_1(iot, ioh, com_fifo,
		    FIFO_ENABLE | FIFO_ENABLE_64BYTE);
		if ((bus_space_read_1(iot, ioh, com_iir) >> 5) == 7) {
#if 0
			bus_space_write_1(iot, ioh, com_lcr, 0);
			if ((bus_space_read_1(iot, ioh, com_iir) >> 5) == 6)
#endif
				sc->sc_uarttype = COM_UART_TI16750;
		}
		bus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE);
	}

	/* Reset the LCR (latch access is probably enabled). */
	bus_space_write_1(iot, ioh, com_lcr, lcr);
	if (sc->sc_uarttype == COM_UART_16450) { /* Probe for 8250 */
		u_int8_t scr0, scr1, scr2;

		scr0 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, 0xa5);
		scr1 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, 0x5a);
		scr2 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, scr0);

		if ((scr1 != 0xa5) || (scr2 != 0x5a))
			sc->sc_uarttype = COM_UART_8250;
	}

	/*
	 * Print UART type and initialize ourself.
	 */
	sc->sc_fifolen = 1;	/* default */
	switch (sc->sc_uarttype) {
	case COM_UART_UNKNOWN:
		printf(": unknown uart\n");
		break;
	case COM_UART_8250:
		printf(": ns8250, no fifo\n");
		break;
	case COM_UART_16450:
		printf(": ns16450, no fifo\n");
		break;
	case COM_UART_16550:
		printf(": ns16550, no working fifo\n");
		break;
	case COM_UART_16550A:
		printf(": ns16550a, 16 byte fifo\n");
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 16;
		break;
	case COM_UART_ST16650:
		printf(": st16650, no working fifo\n");
		break;
	case COM_UART_ST16650V2:
		printf(": st16650, 32 byte fifo\n");
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 32;
		break;
	case COM_UART_TI16750:
		printf(": ti16750, 64 byte fifo\n");
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 64;
		break;
	case COM_UART_XR16850:
		printf(": xr16850 (rev %d), 128 byte fifo\n", sc->sc_uartrev);
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 128;
		break;
	default:
		panic("comattach: bad fifo type");
	}

	/* clear and disable fifo */
	bus_space_write_1(iot, ioh, com_fifo, FIFO_RCV_RST | FIFO_XMT_RST);
	(void)bus_space_read_1(iot, ioh, com_data);
	bus_space_write_1(iot, ioh, com_fifo, 0);
#ifdef COM_HAYESP
	}
#endif

	/* disable interrupts */
	bus_space_write_1(iot, ioh, com_ier, 0);
	bus_space_write_1(iot, ioh, com_mcr, 0);

	if (irq != IRQUNK) {
d422 1
a422 27
#ifdef KGDB
	/*
	 * Allow kgdb to "take over" this port.  If this is
	 * the kgdb device, it has exclusive use.
	 */

	if (iot == com_kgdb_iot && iobase == com_kgdb_addr &&
	    !ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
		printf("%s: kgdb\n", sc->sc_dev.dv_xname);
		SET(sc->sc_hwflags, COM_HW_KGDB);
		com_enable_debugport(sc);
		com_kgdb_attached = 1;
	}
#endif /* KGDB */

	/* XXX maybe move up some? */
	if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE))
		printf("%s: console\n", sc->sc_dev.dv_xname);

	/*
	 * If there are no enable/disable functions, assume the device
	 * is always enabled.
	 */
#ifdef notyet
	if (!sc->enable)
#endif
		sc->enabled = 1;
a595 32
#ifdef COM_HAYESP
		/* Setup the ESP board */
		if (ISSET(sc->sc_hwflags, COM_HW_HAYESP)) {
			bus_space_handle_t hayespioh = sc->sc_hayespioh;

			bus_space_write_1(iot, ioh, com_fifo,
			     FIFO_DMA_MODE|FIFO_ENABLE|
			     FIFO_RCV_RST|FIFO_XMT_RST|FIFO_TRIGGER_8);

			/* Set 16550 compatibility mode */
			bus_space_write_1(iot, hayespioh, HAYESP_CMD1, HAYESP_SETMODE);
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2, 
			     HAYESP_MODE_FIFO|HAYESP_MODE_RTS|
			     HAYESP_MODE_SCALE);

			/* Set RTS/CTS flow control */
			bus_space_write_1(iot, hayespioh, HAYESP_CMD1, HAYESP_SETFLOWTYPE);
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2, HAYESP_FLOW_RTS);
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2, HAYESP_FLOW_CTS);

			/* Set flow control levels */
			bus_space_write_1(iot, hayespioh, HAYESP_CMD1, HAYESP_SETRXFLOW);
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2, 
			     HAYESP_HIBYTE(HAYESP_RXHIWMARK));
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2,
			     HAYESP_LOBYTE(HAYESP_RXHIWMARK));
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2,
			     HAYESP_HIBYTE(HAYESP_RXLOWMARK));
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2,
			     HAYESP_LOBYTE(HAYESP_RXLOWMARK));
		} else
#endif
d1061 1
a1061 2
		if (!ISSET(sc->sc_hwflags, COM_HW_HAYESP) &&
		    ISSET(sc->sc_hwflags, COM_HW_FIFO)) {
@


1.45
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.44 2003/08/15 20:32:13 tedu Exp $	*/
d1950 2
d1953 9
@


1.44
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.43 2003/06/02 23:27:47 millert Exp $	*/
a743 1
		tty_detach(sc->sc_tty);
a818 1
		tty_attach(tp);
@


1.43
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.42 2002/03/14 01:26:33 millert Exp $	*/
d1259 1
a1259 1
		error = suser(p->p_ucred, &p->p_acflag); 
@


1.42
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.41 2002/01/30 20:45:34 nordin Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.41
log
@Move SET/CLR/ISSET macros to param.h. fgsch@@ and millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.40 2001/08/08 19:07:17 mickey Exp $	*/
d110 1
a110 1
static u_char tiocm_xxx2mcr __P((int));
d112 1
a112 1
void pccom_xr16850_fifo_init __P((bus_space_tag_t, bus_space_handle_t));
d118 3
a120 3
int	comprobe __P((struct device *, void *, void *));
void	comattach __P((struct device *, struct device *, void *));
void	compwroff __P((struct com_softc *));
d144 1
a144 1
void cominit __P((bus_space_tag_t, bus_space_handle_t, int));
d174 2
a175 2
int	com_kgdb_getc __P((void *));
void	com_kgdb_putc __P((void *, int));
@


1.40
log
@move the com_raisedtr proto for timeout_set
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.39 2001/07/23 14:28:46 jason Exp $	*/
a179 5

/* Macros to clear/set/test flags. */
#define	SET(t, f)	(t) |= (f)
#define	CLR(t, f)	(t) &= ~(f)
#define	ISSET(t, f)	((t) & (f))
@


1.40.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.41 2002/01/30 20:45:34 nordin Exp $	*/
d180 5
@


1.40.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.40.4.1 2002/01/31 22:55:12 niklas Exp $	*/
d110 1
a110 1
static u_char tiocm_xxx2mcr(int);
d112 1
a112 1
void pccom_xr16850_fifo_init(bus_space_tag_t, bus_space_handle_t);
d118 3
a120 3
int	comprobe(struct device *, void *, void *);
void	comattach(struct device *, struct device *, void *);
void	compwroff(struct com_softc *);
d144 1
a144 1
void cominit(bus_space_tag_t, bus_space_handle_t, int);
d174 2
a175 2
int	com_kgdb_getc(void *);
void	com_kgdb_putc(void *, int);
@


1.39
log
@reorder operations a bit for st16550{v2}, xr16850, ti16750:
	wake them up and then initialize them
This fixes a comatose st16650 problem on addcom (detected as st16550).
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.38 2001/07/04 23:14:51 espie Exp $	*/
a120 1
void	com_raisedtr __P((void *));
@


1.38
log
@Make preprocessor happier, don't give it untasty tokens at end of input.
Ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.37 2001/03/15 17:52:20 deraadt Exp $	*/
a858 6
		sc->sc_initialize = 1;
		comparam(tp, &tp->t_termios);
		ttsetwater(tp);

		sc->sc_rxput = sc->sc_rxget = sc->sc_tbc = 0;

d879 6
@


1.37
log
@support puc devices with higher speeds (not tested yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.36 2001/01/24 09:38:01 hugh Exp $	*/
d229 1
a229 1
#undef	divrnd(n, q)
@


1.36
log
@KGDB for i386 from NetBSD via niklas, with tweaks and accommodations.
Tested by various, vetted by mickey & theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.35 2000/08/16 19:15:35 mickey Exp $	*/
d207 2
a208 1
comspeed(speed)
d219 1
a219 1
	x = divrnd((COM_FREQ / 16), speed);
d222 1
a222 1
	err = divrnd((COM_FREQ / 16) * 1000, speed * x) - 1000;
d243 5
a247 5
	    k = bus_space_read_1(iot, ioh, com_iir);
	    if (k & 0x38) {
		bus_space_read_1(iot, ioh, com_data); /* cleanup */
	    } else
		break;
d474 1
d1302 1
a1302 1
	int ospeed = comspeed(t->c_ospeed);
d1981 1
a1981 1
	rate = comspeed(rate); /* XXX not comdefaultrate? */
@


1.35
log
@morth to use new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.34 1999/11/28 12:07:02 downsj Exp $	*/
d168 10
a177 5
#include <machine/remote-sl.h>
extern int kgdb_dev;
extern int kgdb_rate;
extern int kgdb_debug_init;
#endif
d364 5
d430 4
d435 1
d439 7
d447 1
d662 11
d676 1
d683 11
a693 16
	if (kgdb_dev == makedev(commajor, unit)) {
		if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE))
			kgdb_dev = -1;	/* can't debug over console port */
		else {
			cominit(iot, ioh, kgdb_rate);
			if (kgdb_debug_init) {
				/*
				 * Print prefix of device name,
				 * let kgdb_connect print the rest.
				 */
				printf("%s: ", sc->sc_dev.dv_xname);
				kgdb_connect(1);
			} else
				printf("%s: kgdb enabled\n",
				    sc->sc_dev.dv_xname);
		}
d695 1
a695 1
#endif
d711 18
d778 1
a778 1
#ifdef notyet
d781 2
a782 2
		if (sc->sc_hwflags & (COM_HW_CONSOLE)) {
#endif
d817 8
d1701 56
d1899 52
d1960 3
a1962 1
	if (bus_space_map(comconsiot, CONADDR, COM_NPORTS, 0, &comconsioh))
a1965 1
	comconsaddr = CONADDR;
d1979 1
a1979 1
	rate = comspeed(comdefaultrate);
d1983 1
d1985 2
a1986 1
	bus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_4);
d1995 1
a1995 11
	int s = splhigh();
	bus_space_tag_t iot = comconsiot;
	bus_space_handle_t ioh = comconsioh;
	u_int8_t stat, c;

	while (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_RXRDY))
		;
	c = bus_space_read_1(iot, ioh, com_data);
	stat = bus_space_read_1(iot, ioh, com_iir);
	splx(s);
	return c;
d2006 2
a2007 1
	int s = splhigh();
a2009 2
	u_int8_t stat;
	register int timo;
a2010 3
#ifdef KGDB
	if (dev != kgdb_dev)
#endif
d2015 2
a2016 12
	/* wait for any pending transmission to finish */
	timo = 50000;
	while (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_TXRDY) && --timo)
		;
	bus_space_write_1(iot, ioh, com_data, c);
	/* wait for this transmission to complete */
	timo = 1500000;
	while (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_TXRDY) && --timo)
		;
	/* clear any interrupts generated by this transmission */
	stat = bus_space_read_1(iot, ioh, com_iir);
	splx(s);
d2026 48
@


1.34
log
@Enable TI16750 UART support.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.33 1999/10/26 12:29:00 downsj Exp $	*/
d86 1
d451 3
d708 2
a709 2
	untimeout(com_raisedtr, sc);
	untimeout(comdiag, sc);
d1001 1
a1001 1
		timeout(com_raisedtr, sc, hz * 2);
d1597 1
a1597 1
						timeout(comdiag, sc, 60 * hz);
@


1.34.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.37 2001/03/15 17:52:20 deraadt Exp $	*/
a85 1
#include <sys/timeout.h>
d167 5
a171 10
#include <sys/kgdb.h>

static	int com_kgdb_addr;
static	bus_space_tag_t com_kgdb_iot;
static	bus_space_handle_t com_kgdb_ioh;
static	int com_kgdb_attached;

int	com_kgdb_getc __P((void *));
void	com_kgdb_putc __P((void *, int));
#endif /* KGDB */
d201 1
a201 2
comspeed(freq, speed)
	long freq;
d212 1
a212 1
	x = divrnd((freq / 16), speed);
d215 1
a215 1
	err = divrnd((freq / 16) * 1000, speed * x) - 1000;
d236 5
a240 5
		k = bus_space_read_1(iot, ioh, com_iir);
		if (k & 0x38) {
			bus_space_read_1(iot, ioh, com_data); /* cleanup */
		} else
			break;
a357 5
#ifdef KGDB
	if (iobase == com_kgdb_addr)
		goto out;
#endif /* KGDB */

a418 4
#ifdef KGDB
			if ((iobase != comconsaddr) &&
			    (iobase != com_kgdb_addr)) {
#else
a419 1
#endif /* KGDB */
a422 7
#ifdef KGDB
				if (iobase == comconsaddr) {
					ioh = comconsioh;
				} else {
					ioh = com_kgdb_ioh;
				}
#else
a423 1
#endif /* KGDB */
a448 4
	sc->sc_frequency = COM_FREQ;

	timeout_set(&sc->sc_dtr_tmo, com_raisedtr, sc);
	timeout_set(&sc->sc_diag_tmo, comdiag, sc);
a634 11
#ifdef KGDB
			if (iobase == com_kgdb_addr) {
				sc->sc_ih = isa_intr_establish(ia->ia_ic, irq,
				    IST_EDGE, IPL_HIGH, kgdbintr, sc,
				    sc->sc_dev.dv_xname);
			} else {
				sc->sc_ih = isa_intr_establish(ia->ia_ic, irq,
				    IST_EDGE, IPL_HIGH, comintr, sc,
				    sc->sc_dev.dv_xname);
			}
#else
a637 1
#endif /* KGDB */
d644 16
a659 11
	/*
	 * Allow kgdb to "take over" this port.  If this is
	 * the kgdb device, it has exclusive use.
	 */

	if (iot == com_kgdb_iot && iobase == com_kgdb_addr &&
	    !ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
		printf("%s: kgdb\n", sc->sc_dev.dv_xname);
		SET(sc->sc_hwflags, COM_HW_KGDB);
		com_enable_debugport(sc);
		com_kgdb_attached = 1;
d661 1
a661 1
#endif /* KGDB */
a676 18
#ifdef KGDB
void
com_enable_debugport(sc)
	struct com_softc *sc;
{
	int s;

	/* Turn on line break interrupt, set carrier. */
	s = splhigh();
	SET(sc->sc_ier, IER_ERXRDY);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_ier, sc->sc_ier);
	SET(sc->sc_mcr, MCR_DTR | MCR_RTS | MCR_IENABLE);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_mcr, sc->sc_mcr);

	splx(s);
}
#endif /* KGDB */

d704 2
a705 2
	timeout_del(&sc->sc_dtr_tmo);
	timeout_del(&sc->sc_diag_tmo);
d726 1
a726 1
#ifdef KGDB
d729 2
a730 2
		if (sc->sc_hwflags & COM_HW_CONSOLE) {
#endif /* KGDB */
a764 8
#ifdef KGDB
	/*
	 * If this is the kgdb port, no other use is permitted.
	 */
	if (ISSET(sc->sc_hwflags, COM_HW_KGDB))
		return (EBUSY);
#endif /* KGDB */

d997 1
a997 1
		timeout_add(&sc->sc_dtr_tmo, hz * 2);
d1240 1
a1240 1
	int ospeed = comspeed(sc->sc_frequency, t->c_ospeed);
d1593 1
a1593 1
						timeout_add(&sc->sc_diag_tmo, 60 * hz);
a1640 56
#ifdef KGDB

/*
 * If a line break is set, or data matches one of the characters
 * gdb uses to signal a connection, then start up kgdb. Just gobble
 * any other data. Done in a stand alone function because comintr
 * does tty stuff and we don't have one.
 */

int
kgdbintr(arg)
	void *arg;
{
	struct com_softc *sc = arg;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_char lsr, data, msr, delta;

	if (!ISSET(sc->sc_hwflags, COM_HW_KGDB))
		return(0);

	for (;;) {
		lsr = bus_space_read_1(iot, ioh, com_lsr);
		if (ISSET(lsr, LSR_RXRDY)) {
			do {
				data = bus_space_read_1(iot, ioh, com_data);
				if (data == 3 || data == '$' || data == '+' ||
				    ISSET(lsr, LSR_BI)) {
					kgdb_connect(1);
					data = 0;
				}
				lsr = bus_space_read_1(iot, ioh, com_lsr);
			} while (ISSET(lsr, LSR_RXRDY));

		}
		if (ISSET(lsr, LSR_BI|LSR_FE|LSR_PE|LSR_OE))
			printf("weird lsr %02x\n", lsr);

		msr = bus_space_read_1(iot, ioh, com_msr);

		if (msr != sc->sc_msr) {
			delta = msr ^ sc->sc_msr;
			sc->sc_msr = msr;
			if (ISSET(delta, MSR_DCD)) {
				if (!ISSET(sc->sc_swflags, COM_SW_SOFTCAR)) {
					CLR(sc->sc_mcr, sc->sc_dtr);
					bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
				}
			}
		}
		if (ISSET(bus_space_read_1(iot, ioh, com_iir), IIR_NOPEND))
			return (1);
	}
}
#endif /* KGDB */

a1782 52
/*
 * The following functions are polled getc and putc routines, shared
 * by the console and kgdb glue.
 */

int
com_common_getc(iot, ioh)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
{
	int s = splhigh();
	u_char stat, c;

	/* block until a character becomes available */
	while (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_RXRDY))
		continue;

	c = bus_space_read_1(iot, ioh, com_data);
	/* clear any interrupts generated by this transmission */
	stat = bus_space_read_1(iot, ioh, com_iir);
	splx(s);
	return (c);
}

void
com_common_putc(iot, ioh, c)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int c;
{
	int s = splhigh();
	int timo;

	/* wait for any pending transmission to finish */
	timo = 150000;
	while (!ISSET(bus_space_read_1(iot, ioh, com_lsr), LSR_TXRDY) && --timo)
		continue;

	bus_space_write_1(iot, ioh, com_data, c);

	/* wait for this transmission to complete */
	timo = 1500000;
	while (!ISSET(bus_space_read_1(iot, ioh, com_lsr), LSR_TXRDY) && --timo)
		continue;

	splx(s);
}

/*
 * Following are all routines needed for COM to act as console
 */

d1792 1
a1792 3
	comconsaddr = CONADDR;

	if (bus_space_map(comconsiot, comconsaddr, COM_NPORTS, 0, &comconsioh))
d1796 1
d1810 1
a1810 1
	rate = comspeed(COM_FREQ, rate); /* XXX not comdefaultrate? */
a1813 1
	bus_space_write_1(iot, ioh, com_mcr, MCR_DTR | MCR_RTS);
d1815 1
a1815 2
	bus_space_write_1(iot, ioh, com_fifo,
	    FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_4);
d1824 11
a1834 1
	return (com_common_getc(comconsiot, comconsioh));
d1845 1
a1845 2
#if 0
	/* XXX not needed? */
d1848 2
d1851 3
d1858 12
a1869 2
#endif
	com_common_putc(comconsiot, comconsioh, c);
a1878 48

#ifdef KGDB
int
com_kgdb_attach(iot, iobase, rate, frequency, cflag)
	bus_space_tag_t iot;
	int iobase;
	int rate, frequency;
	tcflag_t cflag;
{
	if (iot == comconsiot && iobase == comconsaddr) {
		return (EBUSY); /* cannot share with console */
	}

	com_kgdb_iot = iot;
	com_kgdb_addr = iobase;

	if (bus_space_map(com_kgdb_iot, com_kgdb_addr, COM_NPORTS, 0,
	    &com_kgdb_ioh))
		panic("com_kgdb_attach: mapping failed");

	/* XXX We currently don't respect KGDBMODE? */
	cominit(com_kgdb_iot, com_kgdb_ioh, rate);

	kgdb_attach(com_kgdb_getc, com_kgdb_putc, NULL);
	kgdb_dev = 123; /* unneeded, only to satisfy some tests */

	return (0);
}

/* ARGSUSED */
int
com_kgdb_getc(arg)
	void *arg;
{

	return (com_common_getc(com_kgdb_iot, com_kgdb_ioh));
}

/* ARGSUSED */
void
com_kgdb_putc(arg, c)
	void *arg;
	int c;
{

	return (com_common_putc(com_kgdb_iot, com_kgdb_ioh, c));
}
#endif /* KGDB */
@


1.34.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.34.2.1 2001/04/18 16:07:54 niklas Exp $	*/
d121 1
d229 1
a229 1
#undef	divrnd
d859 6
a884 6

		sc->sc_initialize = 1;
		comparam(tp, &tp->t_termios);
		ttsetwater(tp);

		sc->sc_rxput = sc->sc_rxget = sc->sc_tbc = 0;
@


1.34.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d180 5
@


1.34.2.4
log
@Merge in -current from about a week ago
@
text
@d110 1
a110 1
static u_char tiocm_xxx2mcr(int);
d112 1
a112 1
void pccom_xr16850_fifo_init(bus_space_tag_t, bus_space_handle_t);
d118 3
a120 3
int	comprobe(struct device *, void *, void *);
void	comattach(struct device *, struct device *, void *);
void	compwroff(struct com_softc *);
d144 1
a144 1
void cominit(bus_space_tag_t, bus_space_handle_t, int);
d174 2
a175 2
int	com_kgdb_getc(void *);
void	com_kgdb_putc(void *, int);
@


1.34.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.34.2.4 2002/03/28 10:31:04 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.34.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d744 1
d820 1
d1259 1
a1259 1
		error = suser(p, 0); 
@


1.33
log
@Update my copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.32 1999/08/08 01:34:15 niklas Exp $	*/
a542 1
#ifdef notyet
d548 1
d551 1
a555 1
#endif
a602 1
#ifdef notyet
a607 1
#endif
a818 1
#ifdef notyet
a821 1
#endif
a873 1
#ifdef notyet
a878 1
#endif
a907 1
#ifndef notyet
a909 1
#endif
a1052 1
#ifdef notyet
a1055 1
#endif
a1323 1
#ifdef notyet
a1324 1
#endif
a1338 1
#ifdef notyet
a1343 1
#endif
a1351 1
#ifdef notyet
a1353 1
#endif
@


1.32
log
@Detach support for com; NetBSD and me
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.31 1999/07/26 12:31:44 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1997 - 1998, Jason Downs.  All rights reserved.
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Jason Downs for the
 *      OpenBSD system.
 * 4. Neither the name(s) of the author(s) nor the name OpenBSD
@


1.31
log
@Remove obsolete detach code that has been dead for very long
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.30 1999/05/21 16:06:13 rees Exp $	*/
d89 1
d672 77
@


1.30
log
@Don't turn off uart when closing cua device if tty is waiting.
Instead just drop dtr briefly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.29 1999/02/08 23:43:54 rees Exp $	*/
a121 2
void	com_absent_notify __P((struct com_softc *sc));
void	comstart_pending __P((void *));
a202 219
#if 0
#if NPCCOM_PCMCIA
#include <dev/pcmcia/pcmciavar.h>

int	com_pcmcia_match __P((struct device *, void *, void *));
void	com_pcmcia_attach __P((struct device *, struct device *, void *));
int	com_pcmcia_detach __P((struct device *));

struct cfattach pccom_pcmcia_ca = {
	sizeof(struct com_softc), com_pcmcia_match, comattach,
	com_pcmcia_detach
};

int	com_pcmcia_mod __P((struct pcmcia_link *pc_link, struct device *self,
	    struct pcmcia_conf *pc_cf, struct cfdata *cf));

/* additional setup needed for pcmcia devices */
/* modify config entry */
int 
com_pcmcia_mod(pc_link, self, pc_cf, cf)
    struct pcmcia_link *pc_link;
    struct device *self;
    struct pcmcia_conf *pc_cf; 
    struct cfdata *cf;
{               
    int err; 
    if (!(err = PCMCIA_BUS_CONFIG(pc_link->adapter, pc_link, self,
				  pc_cf, cf))) {
        pc_cf->memwin = 0;
	if (pc_cf->cfgtype == 0) 
	    pc_cf->cfgtype = CFGENTRYID; /* determine from ioaddr */
    }
    return err;
}

int com_pcmcia_isa_attach __P((struct device *, void *, void *,
			       struct pcmcia_link *));
int com_pcmcia_remove __P((struct pcmcia_link *, struct device *));

static struct pcmcia_com {
    struct pcmcia_device pcd;
} pcmcia_com =  {
    {"PCMCIA Modem card", com_pcmcia_mod, com_pcmcia_isa_attach,
     NULL, com_pcmcia_remove}
};          


struct pcmciadevs pcmcia_com_devs[] = {
  { "pccom", 0,
  NULL, "*MODEM*", NULL, NULL,
  NULL, (void *)&pcmcia_com 
  },
  { "pccom", 0,
  NULL, "*Modem*", NULL, NULL,
  NULL, (void *)&pcmcia_com   
  },
  { "pccom", 0,
  NULL, "*modem*", NULL, NULL,
  NULL, (void *)&pcmcia_com   
  },
  { "pccom", 0,
  NULL, NULL, "*MODEM*", NULL,
  NULL, (void *)&pcmcia_com 
  },
  { "pccom", 0,
  NULL, NULL, "*Modem*", NULL,
  NULL, (void *)&pcmcia_com   
  },
  { "pccom", 0,
  NULL, NULL, "*modem*", NULL,
  NULL, (void *)&pcmcia_com   
  },
  { "pccom", 0,
  NULL, NULL, NULL, "*MODEM*",
  NULL, (void *)&pcmcia_com 
  },
  { "pccom", 0,
  NULL, NULL, NULL, "*Modem*",
  NULL, (void *)&pcmcia_com   
  },
  { "pccom", 0,
  NULL, NULL, NULL, "*modem*",
  NULL, (void *)&pcmcia_com   
  },
  {NULL}
};
#define ncom_pcmcia_devs sizeof(pcmcia_com_devs)/sizeof(pcmcia_com_devs[0])

int
com_pcmcia_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	return pcmcia_slave_match(parent, match, aux, pcmcia_com_devs,
				  ncom_pcmcia_devs);
}

int
com_pcmcia_isa_attach(parent, match, aux, pc_link)
	struct device *parent;
	void *match;
	void *aux;
	struct pcmcia_link *pc_link;
{
	struct isa_attach_args *ia = aux;
	struct com_softc *sc = match;

	int rval;
	if ((rval = comprobe(parent, sc->sc_dev.dv_cfdata, ia))) {
		if (ISSET(pc_link->flags, PCMCIA_REATTACH)) {
#ifdef PCCOM_DEBUG
			printf("comreattach, hwflags=%x\n", sc->sc_hwflags);
#endif
			sc->sc_hwflags = COM_HW_REATTACH |
				(sc->sc_hwflags & (COM_HW_ABSENT_PENDING|COM_HW_CONSOLE));
		} else
			sc->sc_hwflags = 0;
		sc->sc_ic = ia->ia_ic;
	}
	return rval;
}


/*
 * Called by config_detach attempts, shortly after com_pcmcia_remove
 * was called.
 */
int
com_pcmcia_detach(self)
	struct device *self;
{
	struct com_softc *sc = (void *)self;

	if (ISSET(sc->sc_hwflags, COM_HW_ABSENT_PENDING)) {
		/* don't let it really be detached, it is still open */
		return EBUSY;
	}
	return 0;		/* OK! */
}

/*
 * called by pcmcia framework to accept/reject remove attempts.
 * If we return 0, then the detach will proceed.
 */
int
com_pcmcia_remove(pc_link, self)
	struct pcmcia_link *pc_link;
	struct device *self;
{
	struct com_softc *sc = (void *)self;
	struct tty *tp;
	int s;

	if (!sc->sc_tty)
		goto ok;
	tp = sc->sc_tty;

	/* not in use ?  if so, return "OK" */
	if (!ISSET(tp->t_state, TS_ISOPEN) &&
	    !ISSET(tp->t_state, TS_WOPEN)) {
		ttyfree(sc->sc_tty);
		sc->sc_tty = NULL;
    ok:
		isa_intr_disestablish(sc->sc_ic, sc->sc_ih);
		sc->sc_ih = NULL;
		SET(sc->sc_hwflags, COM_HW_ABSENT);
		return 0;		/* OK! */
	}
	/*
	 * Not easily removed.  Put device into a dead state, clean state
	 * as best we can.  notify all waiters.
	 */
	SET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING);
#ifdef PCCOM_DEBUG
	printf("pending detach flags %x\n", sc->sc_hwflags);
#endif

	s = spltty();
	com_absent_notify(sc);
	splx(s);

	return 0;
}

#if 0
void
com_pcmcia_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pcmcia_attach_args *paa = aux;
	
	printf("com_pcmcia_attach %p %p %p\n", parent, self, aux);
	delay(2000000);
	if (!pcmcia_configure(parent, self, paa->paa_link)) {
		struct com_softc *sc = (void *)self;
		sc->sc_hwflags |= COM_HW_ABSENT;
		printf(": not attached\n");
	}
}
#endif
#endif
#endif

/*
 * must be called at spltty() or higher.
 */
void
com_absent_notify(sc)
	struct com_softc *sc;
{
	struct tty *tp = sc->sc_tty;

	if (tp) {
		CLR(tp->t_state, TS_CARR_ON|TS_BUSY);
		ttyflush(tp, FREAD|FWRITE);
	}
}

d406 1
a406 7
	if (ISSET(sc->sc_hwflags, COM_HW_REATTACH)) {
		int s;
		s = spltty();
		com_absent_notify(sc);
		splx(s);
	} else
	    sc->sc_hwflags = 0;
d690 1
a690 1
	if (!sc || ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING))
d927 8
a934 10
	if (!ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING)) {
		if (ISSET(tp->t_state, TS_WOPEN)) {
			/* tty device is waiting for carrier; drop dtr then re-raise */
			CLR(sc->sc_mcr, MCR_DTR | MCR_RTS);
			bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
			timeout(com_raisedtr, sc, hz * 2);
		} else {
			/* no one else waiting; turn off the uart */
			compwroff(sc);
		}
a939 7
#ifdef PCCOM_DEBUG
	/* mark it ready for more use if reattached earlier */
	if (ISSET(sc->sc_hwflags, COM_HW_ABSENT_PENDING)) {
	    printf("comclose pending cleared\n");
	}
#endif
	CLR(sc->sc_hwflags, COM_HW_ABSENT_PENDING);
a1013 7
	if (ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING)) {
		int s = spltty();
		com_absent_notify(sc);
		splx(s);
		return EIO;
	}

a1025 7
	if (ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING)) {
		int s = spltty();
		com_absent_notify(sc);
		splx(s);
		return EIO;
	}

a1066 7
	if (ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING)) {
		int s = spltty();
		com_absent_notify(sc);
		splx(s);
		return EIO;
	}

a1180 7
	if (ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING)) {
		int s = spltty();
		com_absent_notify(sc);
		splx(s);
		return EIO;
	}

a1340 12
void
comstart_pending(arg)
	void *arg;
{
	struct com_softc *sc = arg;
	int s;

	s = spltty();
	com_absent_notify(sc);
	splx(s);
}

a1394 10
	if (ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING)) {
		/*
		 * not quite good enough: if caller is ttywait() it will
		 * go to sleep immediately, so hang out a bit and then
		 * prod caller again.
		 */
		com_absent_notify(sc);
		timeout(comstart_pending, sc, 1);
		goto out;
	}
d1594 1
a1594 1
	if (ISSET(sc->sc_hwflags, COM_HW_ABSENT) || !sc->sc_tty)
@


1.29
log
@Fix cua device to not block on open.
Turn off chip (and dtr) on interrupted open.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.28 1999/01/21 08:55:08 niklas Exp $	*/
d125 1
d1115 7
a1121 3
				error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH,
						 ttopen, 0);
				if (error) {
d1143 2
d1154 11
a1164 2
	if (!ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING))
		compwroff(sc);
d1200 2
a1201 1
		bus_space_write_1(iot, ioh, com_mcr, 0);
d1229 10
@


1.28
log
@Remove remnicients of old pcmcia code, allow both pccom & com at pcmcia
work again
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.27 1999/01/11 05:11:25 millert Exp $	*/
d124 1
a1100 9
	}

	/* wait for carrier if necessary */
	if (ISSET(flag, O_NONBLOCK)) {
		if (!DEVCUA(dev) && sc->sc_cua) {
			/* Opening TTY non-blocking... but the CUA is busy */
			splx(s);
			return EBUSY;
		}
d1102 4
a1105 14
		while (sc->sc_cua ||
		    (!ISSET(tp->t_cflag, CLOCAL) &&
		    !ISSET(tp->t_state, TS_CARR_ON))) {
			SET(tp->t_state, TS_WOPEN);
			error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH,
			    ttopen, 0);
			if (!DEVCUA(dev) && sc->sc_cua && error == EINTR)
				continue;
			if (error) {
				/* XXX should turn off chip if we're the
				   only waiter */
				if (DEVCUA(dev))
					sc->sc_cua = 0;
				CLR(tp->t_state, TS_WOPEN);
d1107 16
a1122 1
				return error;
a1123 2
			if (!DEVCUA(dev) && sc->sc_cua)
				continue;
a1126 1

a1138 2
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
d1147 2
a1148 37
	if (!ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING)) {
		/* can't do any of this stuff .... */
		CLR(sc->sc_lcr, LCR_SBREAK);
		bus_space_write_1(iot, ioh, com_lcr, sc->sc_lcr);
		bus_space_write_1(iot, ioh, com_ier, 0);
		if (ISSET(tp->t_cflag, HUPCL) &&
		    !ISSET(sc->sc_swflags, COM_SW_SOFTCAR)) {
			/* XXX perhaps only clear DTR */
			bus_space_write_1(iot, ioh, com_mcr, 0);
		}

		/*
	 	 * Turn FIFO off; enter sleep mode if possible.
	 	 */
		bus_space_write_1(iot, ioh, com_fifo, 0);
		delay(100);
		(void) bus_space_read_1(iot, ioh, com_data);
		delay(100);
		bus_space_write_1(iot, ioh, com_fifo,
		    FIFO_RCV_RST | FIFO_XMT_RST);

		switch (sc->sc_uarttype) {
		case COM_UART_ST16650:
		case COM_UART_ST16650V2:
		case COM_UART_XR16850:
			bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
			bus_space_write_1(iot, ioh, com_efr, EFR_ECB);
			bus_space_write_1(iot, ioh, com_ier, IER_SLEEP);
			bus_space_write_1(iot, ioh, com_lcr, 0);
			break;
#ifdef notyet
		case COM_UART_TI16750:
			bus_space_write_1(iot, ioh, com_ier, IER_SLEEP);
			break;
#endif
		}
	}
d1169 45
a1213 1
 
@


1.27
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.26 1998/10/07 02:10:52 downsj Exp $	*/
d203 1
d405 1
d550 2
a551 1
#if NPCCOM_ISA || NPCCOM_PCMCIA || NPCCOM_ISAPNP
d593 2
a594 1
#if NPCCOM_ISA || NPCCOM_PCMCIA
d633 2
a634 1
#if NPCCOM_ISA || NPCCOM_PCMCIA || NPCCOM_ISAPNP
d860 2
a861 1
#if NPCCOM_ISA || NPCCOM_PCMCIA || NPCCOM_ISAPNP
@


1.26
log
@Fix trigger level initializations; fixes mouse for XFree86.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.25 1998/06/28 01:47:23 angelos Exp $	*/
d839 1
a839 1
		panic("comattach: bad fifo type\n");
@


1.25
log
@Accept Modem and modem as match strings for PCMCIA modem cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.24 1998/05/14 05:54:44 downsj Exp $	*/
d1012 1
a1012 1
					fifo |= FIFO_RCV_TRIGGER_8|FIFO_XMT_TRIGGER_8;
d1019 1
a1019 1
					fifo |= FIFO_RCV3_TRIGGER_8|FIFO_XMT3_TRIGGER_8;
d1496 2
a1497 2
				if (tp->t_ispeed <= 1200)
					fifo |= FIFO_RCV_TRIGGER_8|FIFO_XMT_TRIGGER_8;
d1502 2
a1503 2
				if (tp->t_ispeed <= 1200)
					fifo |= FIFO_RCV3_TRIGGER_8|FIFO_XMT3_TRIGGER_8;
d1515 1
a1515 1
				if (tp->t_ispeed <= 1200)
@


1.24
log
@* Better XR16C850 support.
* Copyright.
* General cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.23 1998/04/05 07:36:42 downsj Exp $	*/
d255 8
d267 8
d277 8
@


1.23
log
@Support for the XR16850; currently just treat it like an ST16650V2 with
bigger FIFOs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.22 1998/02/23 11:40:32 downsj Exp $	*/
d4 31
d114 2
d687 1
a687 1
	bus_space_write_1(iot, ioh, com_lcr, 0xbf);
d714 1
a714 1
			bus_space_write_1(iot, ioh, com_lcr, 0xbf); /* magic */
d721 1
a721 1
		u_char dlbl, dlbh;
d802 1
d808 1
d936 1
a936 1
			bus_space_write_1(iot, ioh, com_lcr, 0xbf);
d942 1
d946 1
d985 16
a1000 5
			if (tp->t_ispeed <= 1200)
				fifo |= FIFO_TRIGGER_1;
			else
				fifo |= FIFO_TRIGGER_8;
			if (sc->sc_uarttype == COM_UART_TI16750) {
d1005 6
d1035 1
d1038 1
d1150 1
a1150 1
			bus_space_write_1(iot, ioh, com_lcr, 0xbf);
d1155 1
d1159 1
d1376 1
a1376 1
	u_char lcr;
d1465 22
a1486 1
			if (sc->sc_uarttype == COM_UART_TI16750) {
d1488 14
a1501 9
				    lcr | LCR_DLAB);
				bus_space_write_1(iot, ioh, com_fifo,
				    FIFO_ENABLE | FIFO_ENABLE_64BYTE |
				    (t->c_ispeed <= 1200 ? FIFO_TRIGGER_1 : FIFO_TRIGGER_8));
				bus_space_write_1(iot, ioh, com_lcr, lcr);
			} else
				bus_space_write_1(iot, ioh, com_fifo,
				    FIFO_ENABLE |
				    (t->c_ispeed <= 1200 ? FIFO_TRIGGER_1 : FIFO_TRIGGER_8));
d1742 1
a1742 1
			u_char	lsr;
d1781 1
a1781 1
				u_char	msr;
d1819 1
a1819 1
	u_char	lsr;
d1830 1
a1830 1
		u_char	msr, delta;
d1899 16
d1977 1
a1977 1
	u_char stat;
d1997 1
a1997 1
	u_char stat, c;
d2018 1
a2018 1
	u_char stat;
@


1.22
log
@New probe routine, add support for ST16650 (works).

Tested with some 16450 and 16550 UARTs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.21 1998/02/22 21:35:31 niklas Exp $	*/
d681 1
a681 1
			bus_space_write_1(iot, ioh, com_lcr, 0xbf);
d687 22
d723 1
d774 5
d900 1
d1093 1
@


1.21
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.20 1998/02/05 16:48:28 deraadt Exp $	*/
d557 1
d649 10
a658 4
	sc->sc_fifolen = 1;
	/* look for a NS 16550AF UART with FIFOs */
	bus_space_write_1(iot, ioh, com_fifo,
	    FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_14);
d660 98
a757 11
	if (ISSET(bus_space_read_1(iot, ioh, com_iir), IIR_FIFO_MASK) ==
	    IIR_FIFO_MASK) {
		if (ISSET(bus_space_read_1(iot, ioh, com_fifo),
		    FIFO_TRIGGER_14) == FIFO_TRIGGER_14) {
			SET(sc->sc_hwflags, COM_HW_FIFO);
			printf(": ns16550a, working fifo\n");
			sc->sc_fifolen = 16;
		} else
			printf(": ns16550, broken fifo\n");
	} else
		printf(": ns8250 or ns16450, no fifo\n");
d865 18
d916 14
d945 2
a946 4
				bus_space_write_1(iot, ioh, com_fifo,
				    FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST |
				    (tp->t_ispeed <= 1200 ?
				    FIFO_TRIGGER_1 : FIFO_TRIGGER_8));
d952 2
d1050 23
a1074 4
/*
 * FIFO off
 */
	bus_space_write_1(iot, ioh, com_fifo, 0);
d1348 1
a1348 1
			 * even if we do this will the last character is
d1376 13
a1388 4
		    ISSET(sc->sc_hwflags, COM_HW_FIFO))
			bus_space_write_1(iot, ioh, com_fifo,
			    FIFO_ENABLE |
			    (t->c_ispeed <= 1200 ? FIFO_TRIGGER_1 : FIFO_TRIGGER_8));
a1488 1

d1707 3
@


1.20
log
@rename ddb.panic_ddb, and add ddb.console. Now you can stop console ddb entry
with a sysctl. There will be architectures and drivers that lack function,
and I trust the maintainers of those will forget to add the code..
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.19 1998/02/02 22:21:20 deraadt Exp $	*/
d654 3
a656 3
	    IIR_FIFO_MASK)
		if (ISSET(bus_space_read_1(iot, ioh, com_fifo), FIFO_TRIGGER_14) ==
		    FIFO_TRIGGER_14) {
d662 1
a662 1
	else
@


1.19
log
@support non-ISA case
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.18 1998/01/19 06:48:24 deraadt Exp $	*/
d70 3
d1483 2
a1484 1
				 		Debugger();
@


1.18
log
@fix ifdef; marc@@snafu.org
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.17 1997/12/26 09:35:40 deraadt Exp $	*/
d156 2
@


1.17
log
@print pnp device id in isapnp_print
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.16 1997/12/25 14:33:14 downsj Exp $	*/
d1654 1
a1654 1
#if defined(COMCONSOLE) || defined(PCCOMSONSOLE)
@


1.16
log
@pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.15 1997/12/25 09:19:39 downsj Exp $	*/
a577 2

			printf(" <%s, %s>", ia->ipa_devident, ia->ipa_devclass);
@


1.15
log
@Update for new isapnp configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.14 1997/12/21 14:44:34 downsj Exp $	*/
d529 1
a529 1
	if (rv && IS_ISA(parent)) {
d578 2
@


1.14
log
@ISA PnP supporting code from NetBSD, and a pccom driver that supports ISA PnP.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.13 1997/10/07 06:49:49 mickey Exp $	*/
a63 2
#include <dev/isa/isapnpreg.h>
#include <dev/isa/isapnpvar.h>
d486 2
a487 2
#if NPCCOM_ISA || NPCCOM_PCMCIA
	if (IS_ISA(parent)) {
d492 5
a496 12
		needioh = 1;
	} else
#endif
#if NPCCOM_ISAPNP
	if (IS_ISAPNP(parent)) {
		struct isapnp_attach_args *ipa = aux;

		/* XXX: is the modem always on region 0? */
		iot = ipa->ipa_iot;
		iobase = ipa->ipa_io[0].base;
		ioh = ipa->ipa_io[0].h;
		needioh = 0;
d566 2
a567 2
#if NPCCOM_ISA || NPCCOM_PCMCIA
	if (IS_ISA(parent)) {
d575 10
a584 5
	       	if (iobase != comconsaddr) {
			if (bus_space_map(iot, iobase, COM_NPORTS, 0, &ioh))
				panic("comattach: io mapping failed");
		} else
			ioh = comconsioh;
a587 13
#if NPCCOM_ISAPNP
	if (IS_ISAPNP(parent)) {
		struct isapnp_attach_args *ipa = aux;

		/*
		 * We're living on ISA PnP.  No console support.
		 */
		iobase = ipa->ipa_io[0].base;
		iot = ipa->ipa_iot;
		ioh = ipa->ipa_io[0].h;
		irq = ipa->ipa_irq[0].num;
	} else
#endif
d669 2
a670 2
#if NPCCOM_ISA || NPCCOM_PCMCIA
		if (IS_ISA(parent)) {
a673 9
			    IST_EDGE, IPL_HIGH, comintr, sc,
			    sc->sc_dev.dv_xname);
		} else
#endif
#if NPCCOM_ISAPNP
		if (IS_ISAPNP(parent)) {
			struct isapnp_attach_args *ipa = aux;

			sc->sc_ih = isa_intr_establish(ipa->ipa_ic, irq,
@


1.13
log
@make it compile
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.12 1997/09/03 20:55:29 deraadt Exp $	*/
d62 1
d64 2
d97 6
d150 17
a482 8
#if NPCCOM_ISA || NPCCOM_PCMCIA
#define IS_ISA(parent) \
	(!strcmp((parent)->dv_cfdata->cf_driver->cd_name, "isa") || \
	 !strcmp((parent)->dv_cfdata->cf_driver->cd_name, "pcmcia"))
#elif NPCCOM_ISA
#define IS_ISA(parent) \
	!strcmp((parent)->dv_cfdata->cf_driver->cd_name, "isa")
#endif
d497 11
d584 2
a585 2
	        if (iobase != comconsaddr) {
	                if (bus_space_map(iot, iobase, COM_NPORTS, 0, &ioh))
d588 1
a588 1
	                ioh = comconsioh;
d592 13
d695 9
a1651 1
#include <dev/cons.h>
@


1.12
log
@fix cua/tty locking
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.11 1997/07/07 17:08:04 niklas Exp $	*/
a165 2
    struct pcmciadevs *dev = pc_link->device;
    struct ed_softc *sc = (void *)self; 
d224 1
a224 1
	if (rval = comprobe(parent, sc->sc_dev.dv_cfdata, ia)) {
@


1.11
log
@Mirror com changes
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.10 1996/12/18 16:51:45 millert Exp $	*/
d841 3
a843 3
		while (!(DEVCUA(dev) && sc->sc_cua) &&
		    !ISSET(tp->t_cflag, CLOCAL) &&
		    !ISSET(tp->t_state, TS_CARR_ON)) {
d847 2
d858 2
@


1.10
log
@Make pccom compile.  This stull really needs to be merged into the
normal com driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.9 1996/12/11 13:28:06 deraadt Exp $	*/
d362 1
a362 1
comprobe1(iot, ioh, iobase)
a364 1
	int iobase;
d505 1
a505 1
	rv = comprobe1(iot, ioh, iobase);
d1614 1
a1614 1
	found = comprobe1(iot, ioh, CONADDR);
@


1.9
log
@TS_WOPEN on cua close, like com.c
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.8 1996/11/30 11:54:32 downsj Exp $	*/
d63 1
a63 2
#include <dev/isa/comreg.h>
#include <dev/isa/comvar.h>
d70 1
a72 61
struct com_softc {
	struct device sc_dev;
	void *sc_ih;
	bus_space_tag_t sc_iot;
	isa_chipset_tag_t sc_ic;
	struct tty *sc_tty;

	int sc_overflows;
	int sc_floods;
	int sc_errors;

	int sc_halt;

	int sc_iobase;
#ifdef COM_HAYESP
	int sc_hayespbase;
#endif

	bus_space_handle_t sc_ioh;
	bus_space_handle_t sc_hayespioh;

	u_char sc_hwflags;
#define	COM_HW_NOIEN	0x01
#define	COM_HW_FIFO	0x02
#define	COM_HW_HAYESP	0x04
#define	COM_HW_ABSENT_PENDING	0x08	/* reattached, awaiting close/reopen */
#define	COM_HW_ABSENT	0x10		/* configure actually failed, or removed */
#define	COM_HW_REATTACH	0x20		/* reattaching */
#define	COM_HW_CONSOLE	0x40
	u_char sc_swflags;
#define	COM_SW_SOFTCAR	0x01
#define	COM_SW_CLOCAL	0x02
#define	COM_SW_CRTSCTS	0x04
#define	COM_SW_MDMBUF	0x08
	int	sc_fifolen;
	u_char sc_msr, sc_mcr, sc_lcr, sc_ier;
	u_char sc_dtr;

	u_char	sc_cua;

 	u_char	sc_initialize;		/* force initialization */
 
#define RBUFSIZE 512
#define RBUFMASK 511
 	u_int sc_rxget;
 	volatile u_int sc_rxput;
 	u_char sc_rxbuf[RBUFSIZE];
 	u_char *sc_tba;
 	int sc_tbc;
};

#ifdef COM_HAYESP
int comprobeHAYESP __P((bus_space_handle_t hayespioh, struct com_softc *sc));
#endif
void	comdiag		__P((void *));
int	comspeed	__P((long));
int	comparam	__P((struct tty *, struct termios *));
void	comstart	__P((struct tty *));
void 	comsoft		__P((void));
int	comhwiflow	__P((struct tty *, int));

a75 7

struct consdev;
void	comcnprobe	__P((struct consdev *));
void	comcninit	__P((struct consdev *));
int	comcngetc	__P((dev_t));
void	comcnputc	__P((dev_t, int));
void	comcnpollc	__P((dev_t, int));
@


1.8
log
@bus changes
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.7 1996/11/28 23:37:41 niklas Exp $	*/
d921 1
@


1.7
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.6 1996/11/12 20:30:05 niklas Exp $	*/
d59 1
a60 1
#include <machine/bus.h>
d570 1
a570 1
	if (needioh && bus_space_map(iot, iobase, COM_NPORTS, &ioh)) {
d627 1
a627 1
	                if (bus_space_map(iot, iobase, COM_NPORTS, &ioh))
d675 1
a675 1
		if (bus_space_map(iot, *hayespp, HAYESP_NPORTS, &hayespioh))
d1678 1
a1678 1
	if (bus_space_map(iot, CONADDR, COM_NPORTS, &ioh)) {
d1712 1
a1712 1
	if (bus_space_map(comconsiot, CONADDR, COM_NPORTS, &comconsioh))
@


1.6
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.5 1996/11/09 21:56:22 tholo Exp $	*/
d60 1
a60 1
#include <machine/bus.old.h>
d76 2
a77 1
	bus_chipset_tag_t sc_bc;
d91 2
a92 2
	bus_io_handle_t sc_ioh;
	bus_io_handle_t sc_hayespioh;
d125 1
a125 1
int comprobeHAYESP __P((bus_io_handle_t hayespioh, struct com_softc *sc));
d127 1
a127 1
void	comdiag	__P((void *));
d172 1
a172 1
void cominit __P((bus_chipset_tag_t, bus_io_handle_t, int));
d186 2
a187 2
bus_chipset_tag_t comconsbc;
bus_io_handle_t comconsioh;
d303 1
d349 1
a349 1
		isa_intr_disestablish(sc->sc_bc, sc->sc_ih);
d430 3
a432 3
comprobe1(bc, ioh, iobase)
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d438 2
a439 2
	bus_io_write_1(bc, ioh, com_lcr, 0);
	bus_io_write_1(bc, ioh, com_iir, 0);
d441 1
a441 1
	    k = bus_io_read_1(bc, ioh, com_iir);
d443 1
a443 1
		bus_io_read_1(bc, ioh, com_data); /* cleanup */
d456 1
a456 1
	bus_io_handle_t hayespioh;
d461 1
a461 1
	bus_chipset_tag_t bc = sc->sc_bc;
d471 1
a471 1
	if ((bus_io_read_1(bc, hayespioh, 0) & 0xf3) == 0)
d479 2
a480 2
	bus_io_write_1(bc, hayespioh, HAYESP_CMD1, HAYESP_GETDIPS);
	dips = bus_io_read_1(bc, hayespioh, HAYESP_STATUS1);
d491 3
a493 3
	bus_io_write_1(bc, hayespioh, HAYESP_CMD1, HAYESP_GETTEST);
	val = bus_io_read_1(bc, hayespioh, HAYESP_STATUS1); /* Clear reg 1 */
	val = bus_io_read_1(bc, hayespioh, HAYESP_STATUS2);
d523 2
a524 2
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d545 1
a545 1
		bc = ia->ia_bc;
d558 1
a558 1
		bc = ca->ca_bc;
d570 1
a570 1
	if (needioh && bus_io_map(bc, iobase, COM_NPORTS, &ioh)) {
d574 1
a574 1
	rv = comprobe1(bc, ioh, iobase);
d576 1
a576 1
		bus_io_unmap(bc, ioh, COM_NPORTS);
d597 2
a598 2
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d625 1
a625 1
		bc = ia->ia_bc;
d627 1
a627 1
	                if (bus_io_map(bc, iobase, COM_NPORTS, &ioh))
d642 1
a642 1
		bc = ca->ca_bc;
d652 1
a652 1
	sc->sc_bc = bc;
d672 1
a672 1
		bus_io_handle_t hayespioh;
d675 1
a675 1
		if (bus_io_map(bc, *hayespp, HAYESP_NPORTS, &hayespioh))
d683 1
a683 1
		bus_io_unmap(bc, hayespioh, HAYESP_NPORTS);
d691 1
a691 1
	bus_io_write_1(bc, ioh, com_fifo,
d694 1
a694 1
	if (ISSET(bus_io_read_1(bc, ioh, com_iir), IIR_FIFO_MASK) ==
d696 1
a696 1
		if (ISSET(bus_io_read_1(bc, ioh, com_fifo), FIFO_TRIGGER_14) ==
d705 1
a705 1
	bus_io_write_1(bc, ioh, com_fifo, 0);
d711 2
a712 2
	bus_io_write_1(bc, ioh, com_ier, 0);
	bus_io_write_1(bc, ioh, com_mcr, 0);
d732 1
a732 1
			cominit(bc, ioh, kgdb_rate);
d760 2
a761 2
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d810 1
a810 1
		bc = sc->sc_bc;
d815 1
a815 1
			bus_io_handle_t hayespioh = sc->sc_hayespioh;
d817 1
a817 1
			bus_io_write_1(bc, ioh, com_fifo,
d822 2
a823 2
			bus_io_write_1(bc, hayespioh, HAYESP_CMD1, HAYESP_SETMODE);
			bus_io_write_1(bc, hayespioh, HAYESP_CMD2, 
d828 3
a830 3
			bus_io_write_1(bc, hayespioh, HAYESP_CMD1, HAYESP_SETFLOWTYPE);
			bus_io_write_1(bc, hayespioh, HAYESP_CMD2, HAYESP_FLOW_RTS);
			bus_io_write_1(bc, hayespioh, HAYESP_CMD2, HAYESP_FLOW_CTS);
d833 2
a834 2
			bus_io_write_1(bc, hayespioh, HAYESP_CMD1, HAYESP_SETRXFLOW);
			bus_io_write_1(bc, hayespioh, HAYESP_CMD2, 
d836 1
a836 1
			bus_io_write_1(bc, hayespioh, HAYESP_CMD2,
d838 1
a838 1
			bus_io_write_1(bc, hayespioh, HAYESP_CMD2,
d840 1
a840 1
			bus_io_write_1(bc, hayespioh, HAYESP_CMD2,
d857 1
a857 1
			 	bus_io_write_1(bc, ioh, com_fifo, 0);
d859 2
a860 2
				(void) bus_io_read_1(bc, ioh, com_data);
				bus_io_write_1(bc, ioh, com_fifo,
d865 1
a865 1
				if(!ISSET(bus_io_read_1(bc, ioh,
d872 2
a873 2
		while (ISSET(bus_io_read_1(bc, ioh, com_lsr), LSR_RXRDY))
			(void) bus_io_read_1(bc, ioh, com_data);
d878 1
a878 1
		bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d880 1
a880 1
		bus_io_write_1(bc, ioh, com_ier, sc->sc_ier);
d882 1
a882 1
		sc->sc_msr = bus_io_read_1(bc, ioh, com_msr);
d940 2
a941 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d953 2
a954 2
		bus_io_write_1(bc, ioh, com_lcr, sc->sc_lcr);
		bus_io_write_1(bc, ioh, com_ier, 0);
d958 1
a958 1
			bus_io_write_1(bc, ioh, com_mcr, 0);
d965 1
a965 1
	bus_io_write_1(bc, ioh, com_fifo, 0);
d1058 2
a1059 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d1079 1
a1079 1
		bus_io_write_1(bc, ioh, com_lcr, sc->sc_lcr);
d1083 1
a1083 1
		bus_io_write_1(bc, ioh, com_lcr, sc->sc_lcr);
d1087 1
a1087 1
		bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1091 1
a1091 1
		bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1097 1
a1097 1
		bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1101 1
a1101 1
		bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1121 1
a1121 1
		if (bus_io_read_1(bc, ioh, com_ier))
d1176 2
a1177 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d1224 1
a1224 1
		bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1257 4
a1260 4
			bus_io_write_1(bc, ioh, com_lcr, lcr | LCR_DLAB);
			bus_io_write_1(bc, ioh, com_dlbl, ospeed);
			bus_io_write_1(bc, ioh, com_dlbh, ospeed >> 8);
			bus_io_write_1(bc, ioh, com_lcr, lcr);
d1262 1
a1262 1
			bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1264 1
a1264 1
			bus_io_write_1(bc, ioh, com_lcr, lcr);
d1268 1
a1268 1
			bus_io_write_1(bc, ioh, com_fifo,
d1272 1
a1272 1
		bus_io_write_1(bc, ioh, com_lcr, lcr);
d1279 1
a1279 1
				bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1284 1
a1284 1
				bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1306 1
a1306 1
		bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1336 2
a1337 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d1349 1
a1349 1
			bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1353 1
a1353 1
			bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1360 1
a1360 1
			bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1364 1
a1364 1
			bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1377 2
a1378 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d1413 1
a1413 1
			bus_io_write_1(bc, ioh, com_ier, sc->sc_ier);
d1420 1
a1420 1
			bus_io_write_1(bc, ioh, com_data, *sc->sc_tba++);
d1429 1
a1429 1
		bus_io_write_1(bc, ioh, com_ier, sc->sc_ier);
d1559 1
a1559 1
						bus_io_write_1(sc->sc_bc,
d1585 2
a1586 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d1590 1
a1590 1
	if (ISSET(bus_io_read_1(bc, ioh, com_iir), IIR_NOPEND))
d1598 1
a1598 1
			lsr = bus_io_read_1(bc, ioh, com_lsr);
d1603 1
a1603 1
			sc->sc_rxbuf[rxput] = bus_io_read_1(bc, ioh, com_data);
d1606 1
a1606 1
		msr = bus_io_read_1(bc, ioh, com_msr);
d1624 1
a1624 1
	} while (!ISSET(bus_io_read_1(bc, ioh, com_iir), IIR_NOPEND));
d1633 1
a1633 1
				bus_io_write_1(bc, ioh, com_data, *sc->sc_tba++);
d1674 2
a1675 2
	bus_chipset_tag_t bc = 0;
	bus_io_handle_t ioh;
d1678 1
a1678 1
	if (bus_io_map(bc, CONADDR, COM_NPORTS, &ioh)) {
d1682 2
a1683 2
	found = comprobe1(bc, ioh, CONADDR);
	bus_io_unmap(bc, ioh, COM_NPORTS);
d1710 1
a1710 1
	comconsbc = ???;
d1712 1
a1712 1
	if (bus_io_map(comconsbc, CONADDR, COM_NPORTS, &comconsioh))
d1715 1
a1715 1
	cominit(comconsbc, comconsioh, comdefaultrate);
d1721 3
a1723 3
cominit(bc, ioh, rate)
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d1729 1
a1729 1
	bus_io_write_1(bc, ioh, com_lcr, LCR_DLAB);
d1731 6
a1736 6
	bus_io_write_1(bc, ioh, com_dlbl, rate);
	bus_io_write_1(bc, ioh, com_dlbh, rate >> 8);
	bus_io_write_1(bc, ioh, com_lcr, LCR_8BITS);
	bus_io_write_1(bc, ioh, com_ier, IER_ERXRDY | IER_ETXRDY);
	bus_io_write_1(bc, ioh, com_fifo, FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_4);
	stat = bus_io_read_1(bc, ioh, com_iir);
d1745 2
a1746 2
	bus_chipset_tag_t bc = comconsbc;
	bus_io_handle_t ioh = comconsioh;
d1749 1
a1749 1
	while (!ISSET(stat = bus_io_read_1(bc, ioh, com_lsr), LSR_RXRDY))
d1751 2
a1752 2
	c = bus_io_read_1(bc, ioh, com_data);
	stat = bus_io_read_1(bc, ioh, com_iir);
d1766 2
a1767 2
	bus_chipset_tag_t bc = comconsbc;
	bus_io_handle_t ioh = comconsioh;
d1775 1
a1775 1
		cominit(bc, ioh, comdefaultrate);
d1780 1
a1780 1
	while (!ISSET(stat = bus_io_read_1(bc, ioh, com_lsr), LSR_TXRDY) && --timo)
d1782 1
a1782 1
	bus_io_write_1(bc, ioh, com_data, c);
d1785 1
a1785 1
	while (!ISSET(stat = bus_io_read_1(bc, ioh, com_lsr), LSR_TXRDY) && --timo)
d1788 1
a1788 1
	stat = bus_io_read_1(bc, ioh, com_iir);
@


1.5
log
@Proper break handling
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.4 1996/10/22 01:11:52 downsj Exp $	*/
d60 1
a60 1
#include <machine/bus.h>
@


1.4
log
@patch com speed initialization
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.3 1996/08/29 12:58:32 deraadt Exp $	*/
d1514 1
d1516 5
a1520 6
 				if (ISSET(lsr, LSR_BI) &&
				    ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
			 		Debugger();
					rxget = (rxget + 1) & RBUFMASK;
					continue;
 				}
d1522 4
a1530 1
				c = sc->sc_rxbuf[rxget];
@


1.3
log
@sunos-like cua behaviour; inspired by budd@@cs.bu.edu in his scn.c
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.2 1996/07/28 05:07:06 downsj Exp $	*/
d112 2
d802 1
d1229 3
a1231 5
#if 1
	if (tp->t_ispeed != t->c_ispeed) {
#else
	if (1) {
#endif
@


1.2
log
@pccom and com are now mutually exclusive; pccom moves to major 8, the
same as com.

Also various function renaming and such so that multiport drivers should
now be able to link with pccom.  pccomvar.h is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccom.c,v 1.1 1996/07/07 00:05:49 downsj Exp $	*/
d110 2
d198 2
a199 1
#define	PCCOMUNIT(x)	(minor(x))
d754 1
a754 1
	int unit = PCCOMUNIT(dev);
d768 1
d774 1
d878 1
a878 1
		if (ISSET(sc->sc_swflags, COM_SW_SOFTCAR) ||
d888 9
d898 9
a906 2
	if (!ISSET(flag, O_NONBLOCK))
		while (!ISSET(tp->t_cflag, CLOCAL) &&
d914 2
d920 1
d932 1
a932 1
	int unit = PCCOMUNIT(dev);
d961 1
d987 1
a987 1
	struct com_softc *sc = pccom_cd.cd_devs[PCCOMUNIT(dev)];
d1006 1
a1006 1
	struct com_softc *sc = pccom_cd.cd_devs[PCCOMUNIT(dev)];
d1023 1
a1023 1
	struct com_softc *sc = pccom_cd.cd_devs[PCCOMUNIT(dev)];
d1050 1
a1050 1
	int unit = PCCOMUNIT(dev);
d1170 1
a1170 1
	struct com_softc *sc = pccom_cd.cd_devs[PCCOMUNIT(tp->t_dev)];
d1332 1
a1332 1
	struct com_softc *sc = pccom_cd.cd_devs[PCCOMUNIT(tp->t_dev)];
d1373 1
a1373 1
	struct com_softc *sc = pccom_cd.cd_devs[PCCOMUNIT(tp->t_dev)];
d1442 1
a1442 1
	struct com_softc *sc = pccom_cd.cd_devs[PCCOMUNIT(tp->t_dev)];
@


1.1
log
@Integrate the i386 specific com driver from Onno van der Linden,
<onno@@simplex.nl>, as a seperate driver.  This is the OpenBSD com.c, with
his changes integrated and the functions renamed.

This driver should work with pcmcia, but hasn't been tested.  It will not
work the multiport boards.

Simply switch 'com' to 'pccom' in your conf and change the major number of
your devices in order to use this.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d64 1
a64 1
#include <arch/i386/isa/pccomvar.h>
d66 1
a66 1
#ifdef PCCOM_HAYESP
d73 1
a73 1
struct pccom_softc {
d86 1
a86 1
#ifdef PCCOM_HAYESP
d119 2
a120 2
#ifdef PCCOM_HAYESP
int pccomprobeHAYESP __P((bus_io_handle_t hayespioh, struct pccom_softc *sc));
d122 6
a127 6
void	pccomdiag	__P((void *));
int	pccomspeed	__P((long));
int	pccomparam	__P((struct tty *, struct termios *));
void	pccomstart	__P((struct tty *));
void 	pccomsoft	__P((void));
int	pccomhwiflow	__P((struct tty *, int));
d130 2
a131 2
cdev_decl(pccom);
bdev_decl(pccom);
d134 5
a138 5
void	pccomcnprobe	__P((struct consdev *));
void	pccomcninit	__P((struct consdev *));
int	pccomcngetc	__P((dev_t));
void	pccomcnputc	__P((dev_t, int));
void	pccomcnpollc	__P((dev_t, int));
d146 4
a149 4
int	pccomprobe __P((struct device *, void *, void *));
void	pccomattach __P((struct device *, struct device *, void *));
void	pccom_absent_notify __P((struct pccom_softc *sc));
void	pccomstart_pending __P((void *));
d153 1
a153 1
	sizeof(struct pccom_softc), pccomprobe, pccomattach
d159 1
a159 1
	sizeof(struct pccom_softc), pccomprobe, pccomattach
d167 1
a167 1
void pccominit __P((bus_chipset_tag_t, bus_io_handle_t, int));
d173 2
a174 2
#ifdef PCCOMCONSOLE
int	pccomdefaultrate = CONSPEED;		/* XXX why set default? */
d176 1
a176 1
int	pccomdefaultrate = TTYDEF_SPEED;
d178 10
a187 10
int	pccomconsaddr;
int	pccomconsinit;
int	pccomconsattached;
bus_chipset_tag_t pccomconsbc;
bus_io_handle_t pccomconsioh;
tcflag_t pccomconscflag = TTYDEF_CFLAG;

int	pccommajor;
int	pccomsopen = 0;
int	pccomevents = 0;
d206 3
a208 3
int	pccom_pcmcia_match __P((struct device *, void *, void *));
void	pccom_pcmcia_attach __P((struct device *, struct device *, void *));
int	pccom_pcmcia_detach __P((struct device *));
d211 2
a212 2
	sizeof(struct pccom_softc), pccom_pcmcia_match, pccomattach,
	pccom_pcmcia_detach
d215 1
a215 1
int	pccom_pcmcia_mod __P((struct pcmcia_link *pc_link, struct device *self,
d221 1
a221 1
pccom_pcmcia_mod(pc_link, self, pc_cf, cf)
d239 1
a239 1
int pccom_pcmcia_isa_attach __P((struct device *, void *, void *,
d241 1
a241 1
int pccom_pcmcia_remove __P((struct pcmcia_link *, struct device *));
d243 1
a243 1
static struct pcmcia_pccom {
d245 3
a247 3
} pcmcia_pccom =  {
    {"PCMCIA Modem card", pccom_pcmcia_mod, pccom_pcmcia_isa_attach,
     NULL, pccom_pcmcia_remove}
d251 1
a251 1
struct pcmciadevs pcmcia_pccom_devs[] = {
d254 1
a254 1
  NULL, (void *)&pcmcia_pccom 
d258 1
a258 1
  NULL, (void *)&pcmcia_pccom 
d262 1
a262 1
  NULL, (void *)&pcmcia_pccom 
d266 1
a266 1
#define npccom_pcmcia_devs sizeof(pcmcia_pccom_devs)/sizeof(pcmcia_pccom_devs[0])
d269 1
a269 1
pccom_pcmcia_match(parent, match, aux)
d273 2
a274 2
	return pcmcia_slave_match(parent, match, aux, pcmcia_pccom_devs,
				  npccom_pcmcia_devs);
d278 1
a278 1
pccom_pcmcia_isa_attach(parent, match, aux, pc_link)
d285 1
a285 1
	struct pccom_softc *sc = match;
d288 1
a288 1
	if (rval = pccomprobe(parent, sc->sc_dev.dv_cfdata, ia)) {
d291 1
a291 1
			printf("pccomreattach, hwflags=%x\n", sc->sc_hwflags);
d303 1
a303 1
 * Called by config_detach attempts, shortly after pccom_pcmcia_remove
d307 1
a307 1
pccom_pcmcia_detach(self)
d310 1
a310 1
	struct pccom_softc *sc = (void *)self;
d324 1
a324 1
pccom_pcmcia_remove(pc_link, self)
d328 1
a328 1
	struct pccom_softc *sc = (void *)self;
d357 1
a357 1
	pccom_absent_notify(sc);
d365 1
a365 1
pccom_pcmcia_attach(parent, self, aux)
d371 1
a371 1
	printf("pccom_pcmcia_attach %p %p %p\n", parent, self, aux);
d374 1
a374 1
		struct pccom_softc *sc = (void *)self;
d386 2
a387 2
pccom_absent_notify(sc)
	struct pccom_softc *sc;
d398 1
a398 1
pccomspeed(speed)
d423 1
a423 1
pccomprobe1(bc, ioh, iobase)
d446 1
a446 1
#ifdef PCCOM_HAYESP
d448 1
a448 1
pccomprobeHAYESP(hayespioh, sc)
d450 1
a450 1
	struct pccom_softc *sc;
d512 1
a512 1
pccomprobe(parent, match, aux)
d546 1
a546 1
		struct pccommulti_attach_args *ca = aux;
d560 1
a560 1
	if (iobase == pccomconsaddr && !pccomconsattached)
d567 1
a567 1
	rv = pccomprobe1(bc, ioh, iobase);
d584 1
a584 1
pccomattach(parent, self, aux)
d588 1
a588 1
	struct pccom_softc *sc = (void *)self;
d592 1
a592 1
#ifdef PCCOM_HAYESP
d605 1
a605 1
		pccom_absent_notify(sc);
d619 1
a619 1
	        if (iobase != pccomconsaddr) {
d621 1
a621 1
				panic("pccomattach: io mapping failed");
d623 1
a623 1
	                ioh = pccomconsioh;
d629 1
a629 1
		struct pccommulti_attach_args *ca = aux;
d632 1
a632 1
		 * We're living on a pccommulti.
d643 1
a643 1
		panic("pccomattach: impossible");
d649 2
a650 2
	if (iobase == pccomconsaddr) {
		pccomconsattached = 1;
d654 1
a654 1
		 * pccomconsinit.  Also make sure console is always "hardwired".
d657 1
a657 1
		pccomconsinit = 0;
d662 1
a662 1
#ifdef PCCOM_HAYESP
d670 1
a670 1
		if (pccomprobeHAYESP(hayespioh, sc)) {
d699 1
a699 1
#ifdef PCCOM_HAYESP
d713 1
a713 1
			    IST_EDGE, IPL_HIGH, pccomintr, sc,
d717 1
a717 1
			panic("pccomattach: IRQ but can't have one");
d721 1
a721 1
	if (kgdb_dev == makedev(pccommajor, unit)) {
d725 1
a725 1
			pccominit(bc, ioh, kgdb_rate);
d746 1
a746 1
pccomopen(dev, flag, mode, p)
d752 1
a752 1
	struct pccom_softc *sc;
d771 3
a773 3
	tp->t_oproc = pccomstart;
	tp->t_param = pccomparam;
	tp->t_hwiflow = pccomhwiflow;
d781 1
a781 1
			tp->t_cflag = pccomconscflag;
d791 1
a791 1
		tp->t_ispeed = tp->t_ospeed = pccomdefaultrate;
d795 1
a795 1
		pccomparam(tp, &tp->t_termios);
d802 1
a802 1
#ifdef PCCOM_HAYESP
d903 1
a903 1
pccomclose(dev, flag, mode, p)
d909 1
a909 1
	struct pccom_softc *sc = pccom_cd.cd_devs[unit];
d942 1
a942 1
	    printf("pccomclose pending cleared\n");
d957 1
a957 1
pccomread(dev, uio, flag)
d962 1
a962 1
	struct pccom_softc *sc = pccom_cd.cd_devs[PCCOMUNIT(dev)];
d967 1
a967 1
		pccom_absent_notify(sc);
d976 1
a976 1
pccomwrite(dev, uio, flag)
d981 1
a981 1
	struct pccom_softc *sc = pccom_cd.cd_devs[PCCOMUNIT(dev)];
d986 1
a986 1
		pccom_absent_notify(sc);
d995 1
a995 1
pccomtty(dev)
d998 1
a998 1
	struct pccom_softc *sc = pccom_cd.cd_devs[PCCOMUNIT(dev)];
d1018 1
a1018 1
pccomioctl(dev, cmd, data, flag, p)
d1026 1
a1026 1
	struct pccom_softc *sc = pccom_cd.cd_devs[unit];
d1034 1
a1034 1
		pccom_absent_notify(sc);
d1141 1
a1141 1
pccomparam(tp, t)
d1145 1
a1145 1
	struct pccom_softc *sc = pccom_cd.cd_devs[PCCOMUNIT(tp->t_dev)];
d1148 1
a1148 1
	int ospeed = pccomspeed(t->c_ospeed);
d1155 1
a1155 1
		pccom_absent_notify(sc);
d1220 1
a1220 1
				    TTOPRI | PCATCH, "pccomprm", 0);
d1224 1
a1224 1
					pccomstart(tp);
d1283 1
a1283 1
	pccomstart(tp);
d1288 1
a1288 1
pccomstart_pending(arg)
d1291 1
a1291 1
	struct pccom_softc *sc = arg;
d1295 1
a1295 1
	pccom_absent_notify(sc);
d1303 1
a1303 1
pccomhwiflow(tp, block)
d1307 1
a1307 1
	struct pccom_softc *sc = pccom_cd.cd_devs[PCCOMUNIT(tp->t_dev)];
d1314 1
a1314 1
 * Is spltty needed at all ? sc->sc_mcr is only in pccomsoft() not pccomintr()
d1345 1
a1345 1
pccomstart(tp)
d1348 1
a1348 1
	struct pccom_softc *sc = pccom_cd.cd_devs[PCCOMUNIT(tp->t_dev)];
d1360 2
a1361 2
		pccom_absent_notify(sc);
		timeout(pccomstart_pending, sc, 1);
d1412 1
a1412 1
pccomstop(tp, flag)
d1417 1
a1417 1
	struct pccom_softc *sc = pccom_cd.cd_devs[PCCOMUNIT(tp->t_dev)];
d1430 1
a1430 1
pccomdiag(arg)
d1433 1
a1433 1
	struct pccom_softc *sc = arg;
d1452 1
a1452 1
pccomsoft()
d1454 1
a1454 1
	struct pccom_softc	*sc;
d1499 1
a1499 1
						timeout(pccomdiag, sc, 60 * hz);
d1549 1
a1549 1
pccomintr(arg)
d1552 1
a1552 1
	struct pccom_softc *sc = arg;
d1639 1
a1639 1
pccomcnprobe(cp)
d1651 1
a1651 1
	found = pccomprobe1(bc, ioh, CONADDR);
d1659 2
a1660 2
	for (pccommajor = 0; pccommajor < nchrdev; pccommajor++)
		if (cdevsw[pccommajor].d_open == pccomopen)
d1664 2
a1665 2
	cp->cn_dev = makedev(pccommajor, CONUNIT);
#ifdef	PCCOMCONSOLE
d1673 1
a1673 1
pccomcninit(cp)
d1679 1
a1679 1
	pccomconsbc = ???;
d1681 2
a1682 2
	if (bus_io_map(pccomconsbc, CONADDR, COM_NPORTS, &pccomconsioh))
		panic("pccomcninit: mapping failed");
d1684 3
a1686 3
	pccominit(pccomconsbc, pccomconsioh, pccomdefaultrate);
	pccomconsaddr = CONADDR;
	pccomconsinit = 0;
d1690 1
a1690 1
pccominit(bc, ioh, rate)
d1699 1
a1699 1
	rate = pccomspeed(pccomdefaultrate);
d1710 1
a1710 1
pccomcngetc(dev)
d1714 2
a1715 2
	bus_chipset_tag_t bc = pccomconsbc;
	bus_io_handle_t ioh = pccomconsioh;
d1730 1
a1730 1
pccomcnputc(dev, c)
d1735 2
a1736 2
	bus_chipset_tag_t bc = pccomconsbc;
	bus_io_handle_t ioh = pccomconsioh;
d1743 3
a1745 3
	if (pccomconsinit == 0) {
		pccominit(bc, ioh, pccomdefaultrate);
		pccomconsinit = 1;
d1762 1
a1762 1
pccomcnpollc(dev, on)
@
