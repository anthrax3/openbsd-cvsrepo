head	1.51;
access;
symbols
	SMP_SYNC_A:1.51
	SMP_SYNC_B:1.51
	UBC_SYNC_A:1.51
	OPENBSD_3_1:1.50.0.2
	OPENBSD_3_1_BASE:1.50
	UBC_SYNC_B:1.51
	UBC:1.48.0.2
	UBC_BASE:1.48
	OPENBSD_3_0:1.47.0.2
	OPENBSD_3_0_BASE:1.47
	OPENBSD_2_9:1.46.0.2
	OPENBSD_2_9_BASE:1.46
	OPENBSD_2_8:1.45.0.2
	OPENBSD_2_8_BASE:1.45
	OPENBSD_2_7:1.43.0.2
	OPENBSD_2_7_BASE:1.43
	SMP:1.42.0.6
	SMP_BASE:1.42
	kame_19991208:1.42
	OPENBSD_2_6:1.42.0.4
	OPENBSD_2_6_BASE:1.42
	OPENBSD_2_5:1.42.0.2
	OPENBSD_2_5_BASE:1.42
	OPENBSD_2_4:1.41.0.2
	OPENBSD_2_4_BASE:1.41
	OPENBSD_2_3:1.40.0.2
	OPENBSD_2_3_BASE:1.40
	OPENBSD_2_2:1.34.0.4
	OPENBSD_2_2_BASE:1.34
	OPENBSD_2_1:1.34.0.2
	OPENBSD_2_1_BASE:1.34
	OPENBSD_2_0:1.29.0.2
	OPENBSD_2_0_BASE:1.29
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.51
date	2002.06.17.23.10.56;	author matthieu;	state dead;
branches;
next	1.50;

1.50
date	2002.03.14.03.15.54;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2001.11.01.12.13.46;	author art;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2001.05.16.05.07.48;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2000.11.13.15.53.34;	author aaron;	state Exp;
branches;
next	1.45;

1.45
date	2000.07.19.16.40.17;	author mickey;	state Exp;
branches;
next	1.44;

1.44
date	2000.07.19.13.46.20;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2000.03.23.17.17.33;	author aaron;	state Exp;
branches;
next	1.42;

1.42
date	98.11.20.15.57.25;	author deraadt;	state Exp;
branches
	1.42.6.1;
next	1.41;

1.41
date	98.07.09.18.22.25;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	98.03.16.09.12.39;	author downsj;	state Exp;
branches;
next	1.39;

1.39
date	98.02.22.13.03.00;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	98.02.22.13.02.26;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	98.02.05.16.48.30;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	97.11.06.02.26.45;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	97.11.05.09.38.54;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	97.03.03.12.01.15;	author downsj;	state Exp;
branches;
next	1.33;

1.33
date	96.12.29.12.25.59;	author graichen;	state Exp;
branches;
next	1.32;

1.32
date	96.12.20.07.24.49;	author graichen;	state Exp;
branches;
next	1.31;

1.31
date	96.12.05.04.40.26;	author tholo;	state Exp;
branches;
next	1.30;

1.30
date	96.10.16.12.46.30;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	96.09.23.15.12.40;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	96.09.06.08.40.48;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	96.09.01.19.40.56;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	96.09.01.16.39.59;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	96.08.29.09.26.08;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	96.08.28.11.21.06;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	96.08.27.07.32.04;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	96.08.10.21.28.20;	author tholo;	state Exp;
branches;
next	1.21;

1.21
date	96.07.19.23.00.08;	author dm;	state Exp;
branches;
next	1.20;

1.20
date	96.07.16.10.58.34;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	96.06.25.18.32.03;	author tholo;	state Exp;
branches;
next	1.18;

1.18
date	96.06.16.13.41.34;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	96.06.16.13.39.32;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.06.10.07.35.35;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.05.25.22.17.51;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.05.10.12.46.20;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.05.09.14.19.47;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.05.07.07.22.23;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.04.24.18.16.55;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	96.04.24.12.40.11;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.04.22.20.12.16;	author hannken;	state Exp;
branches;
next	1.8;

1.8
date	96.04.21.22.17.01;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.18.17.12.18;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.03.29.12.05.39;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.03.20.00.31.07;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.19.21.09.39;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.20.04.35.34;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.10.42;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.38;	author deraadt;	state Exp;
branches;
next	;

1.42.6.1
date	2000.03.24.09.07.42;	author niklas;	state Exp;
branches;
next	1.42.6.2;

1.42.6.2
date	2001.04.18.16.07.55;	author niklas;	state Exp;
branches;
next	1.42.6.3;

1.42.6.3
date	2001.07.04.10.16.55;	author niklas;	state Exp;
branches;
next	1.42.6.4;

1.42.6.4
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.42.6.5;

1.42.6.5
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.42.6.6;

1.42.6.6
date	2003.03.27.23.26.55;	author niklas;	state dead;
branches;
next	;

1.48.2.1
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	1.48.2.2;

1.48.2.2
date	2002.10.29.00.28.04;	author art;	state dead;
branches;
next	;


desc
@@


1.51
log
@remove old pccons console driver. Not used anymore and not maintained.
ok millert@@, miod@@.
@
text
@/*	$OpenBSD: pccons.c,v 1.50 2002/03/14 03:15:54 millert Exp $	*/
/*	$NetBSD: pccons.c,v 1.99.4.1 1996/06/04 20:03:53 cgd Exp $	*/

/*-
 * Copyright (c) 1993, 1994, 1995 Charles Hannum.  All rights reserved.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz and Don Ahn.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pccons.c	5.11 (Berkeley) 5/21/91
 */

/*
 * code to work keyboard & display for PC-style console
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/select.h>
#include <sys/fcntl.h>
#include <sys/tty.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/timeout.h>
#ifdef DDB
#include <ddb/db_var.h>
#endif

#include <dev/cons.h>

#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/pio.h>
#include <machine/pc/display.h>
#include <machine/pccons.h>
#include <machine/conf.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#include <dev/ic/mc6845.h>
#include <i386/isa/isa_machdep.h>
#include <i386/isa/kbdreg.h>

#define	XFREE86_BUG_COMPAT

#ifndef BEEP_FREQ
#define BEEP_FREQ 1500
#endif
#ifndef BEEP_TIME
#define BEEP_TIME (hz/5)
#endif

#define PCBURST 128

static u_short *Crtat;			/* pointer to backing store */
static u_short *crtat;			/* pointer to current char */
static volatile u_char ack, nak;	/* Don't ask. */
static u_char async, kernel, polling;	/* Really, you don't want to know. */
static u_char lock_state = 0x00,	/* all off */
	      old_lock_state = 0xff,
	      typematic_rate = 0xff,	/* don't update until set by user */
	      old_typematic_rate = 0xff;
static u_short cursor_shape = 0xffff,	/* don't update until set by user */
	       old_cursor_shape = 0xffff;
static pccons_keymap_t	scan_codes[KB_NUM_KEYS];/* keyboard translation table */
static int pc_blank = 300;
#ifdef XSERVER
int pc_xmode = 0;
#endif
struct timeout pccons_aup_tmo;
struct timeout pccons_blank_tmo;

#define	PCUNIT(x)	(minor(x))

static struct video_state {
	int 	cx, cy;		/* escape parameters */
	int 	row, col;	/* current cursor position */
	int 	nrow, ncol, nchr;	/* current screen geometry */
	int	offset;		/* Saved cursor pos */
	u_char	state;		/* parser state */
#define	VSS_ESCAPE	1
#define	VSS_EBRACE	2
#define VSS_EBRACEQ	3
#define	VSS_EPARAM	4
	char	so;		/* in standout mode? */
	char	color;		/* color or mono display */
	char	at, save_at;	/* normal attributes */
	char	so_at, save_so;	/* standout attributes */
} vs;

struct pc_softc {
	struct	device sc_dev;
	void	*sc_ih;
	struct	tty *sc_tty;
};

int pcprobe(struct device *, void *, void *);
void pcattach(struct device *, struct device *, void *);
int pcintr(void *);
static void screen_restore(int);
static void screen_blank(void *);

struct cfattach pc_ca = {
	sizeof(struct pc_softc), pcprobe, pcattach
};

struct cfdriver pc_cd = {
	NULL, "pc", DV_TTY
};

#define	COL		80
#define	ROW		25
#define	CHR		2

static unsigned int addr_6845 = MONO_BASE;

void pcinit(void);
char *sget(void);
void sput(u_char *, int);
#ifdef XSERVER
void pc_xmode_on(void);
void pc_xmode_off(void);
#endif

void	pcstart(struct tty *);
int	pcparam(struct tty *, struct termios *);

int kbd_cmd(u_char, u_char);
void set_cursor_shape(void);
#ifdef XSERVER
void get_cursor_shape(void);
#endif
void do_async_update(void *);
void async_update(void);

static __inline int kbd_wait_output(void);
static __inline int kbd_wait_input(void);
static __inline void kbd_flush_input(void);
static u_char kbc_get8042cmd(void);
static int kbc_put8042cmd(u_char);

void pccnprobe(struct consdev *);
void pccninit(struct consdev *);
void pccnputc(dev_t, char);
int pccngetc(dev_t);
void pccnpollc(dev_t, int);

/* wait 7+ us for keyboard controller; ~1.25us per inb() */
#define	KBD_DELAY \
	{ u_char x = inb(0x84); (void) x; } \
	{ u_char x = inb(0x84); (void) x; } \
	{ u_char x = inb(0x84); (void) x; } \
	{ u_char x = inb(0x84); (void) x; } \
	{ u_char x = inb(0x84); (void) x; } \
	{ u_char x = inb(0x84); (void) x; } \
	{ u_char x = inb(0x84); (void) x; } \
	{ u_char x = inb(0x84); (void) x; }

static __inline int
kbd_wait_output()
{
	u_int i;

	for (i = 100000; i; i--)
		if ((inb(IO_KBD + KBSTATP) & KBS_IBF) == 0) {
			KBD_DELAY;
			return 1;
		}
	return 0;
}

static __inline int
kbd_wait_input()
{
	u_int i;

	for (i = 100000; i; i--)
		if ((inb(IO_KBD + KBSTATP) & KBS_DIB) != 0) {
			KBD_DELAY;
			return 1;
		}
	return 0;
}

static __inline void
kbd_flush_input()
{
	u_int i;

	for (i = 10; i; i--) {
		if ((inb(IO_KBD + KBSTATP) & KBS_DIB) == 0)
			return;
		KBD_DELAY;
		(void) inb(IO_KBD + KBDATAP);
	}
}

#if 1
/*
 * Get the current command byte.
 */
static u_char
kbc_get8042cmd()
{

	if (!kbd_wait_output())
		return -1;
	outb(IO_KBD + KBCMDP, K_RDCMDBYTE);
	if (!kbd_wait_input())
		return -1;
	return inb(IO_KBD + KBDATAP);
}
#endif

/*
 * Pass command byte to keyboard controller (8042).
 */
static int
kbc_put8042cmd(val)
	u_char val;
{

	if (!kbd_wait_output())
		return 0;
	outb(IO_KBD + KBCMDP, K_LDCMDBYTE);
	if (!kbd_wait_output())
		return 0;
	outb(IO_KBD + KBOUTP, val);
	return 1;
}

/*
 * Pass command to keyboard itself
 */
int
kbd_cmd(val, polling)
	u_char val;
	u_char polling;
{
	u_int retries = 3;
	register u_int i;

	do {
		if (!kbd_wait_output())
			return 0;
		ack = nak = 0;
		outb(IO_KBD + KBOUTP, val);
		if (polling)
			for (i = 100000; i; i--) {
				if (inb(IO_KBD + KBSTATP) & KBS_DIB) {
					register u_char c;

					KBD_DELAY;
					c = inb(IO_KBD + KBDATAP);
					if (c == KBR_ACK || c == KBR_ECHO) {
						ack = 1;
						return 1;
					}
					if (c == KBR_RESEND) {
						nak = 1;
						break;
					}
#ifdef DIAGNOSTIC
					printf("kbd_cmd: input char %x lost\n", c);
#endif
				}
			}
		else
			for (i = 100000; i; i--) {
				(void) inb(IO_KBD + KBSTATP);
				if (ack)
					return 1;
				if (nak)
					break;
			}
		if (!nak)
			return 0;
	} while (--retries);
	return 0;
}

void
set_cursor_shape()
{
	outb(addr_6845, CRTC_CURSTART);
	outb(addr_6845+1, cursor_shape >> 8);
	outb(addr_6845, CRTC_CUREND);
	outb(addr_6845+1, cursor_shape);
	old_cursor_shape = cursor_shape;
}

#ifdef XSERVER
void
get_cursor_shape()
{
	outb(addr_6845, CRTC_CURSTART);
	cursor_shape = inb(addr_6845+1) << 8;
	outb(addr_6845, CRTC_CUREND);
	cursor_shape |= inb(addr_6845+1);

	/*
	 * real 6845's, as found on, MDA, Hercules or CGA cards, do
	 * not support reading the cursor shape registers. the 6845
	 * tri-states it's data bus. This is _normally_ read by the
	 * cpu as either 0x00 or 0xff.. in which case we just use
	 * a line cursor.
	 */
	if (cursor_shape == 0x0000 || cursor_shape == 0xffff)
		cursor_shape = 0x0b10;
	else
		cursor_shape &= 0x1f1f;
}
#endif /* XSERVER */

void
do_async_update(v)
	void *v;
{
	u_char poll = v ? 1 : 0;
	int pos;
	static int old_pos = -1;

	async = 0;

	if (lock_state != old_lock_state) {
		old_lock_state = lock_state;
		if (!kbd_cmd(KBC_MODEIND, poll) ||
		    !kbd_cmd(lock_state, poll)) {
			printf("pc: timeout updating leds\n");
			(void) kbd_cmd(KBC_ENABLE, poll);
		}
	}
	if (typematic_rate != old_typematic_rate) {
		old_typematic_rate = typematic_rate;
		if (!kbd_cmd(KBC_TYPEMATIC, poll) ||
		    !kbd_cmd(typematic_rate, poll)) {
			printf("pc: timeout updating typematic rate\n");
			(void) kbd_cmd(KBC_ENABLE, poll);
		}
	}

#ifdef XSERVER
	if (pc_xmode > 0)
		return;
#endif

	pos = crtat - Crtat;
	if (pos != old_pos) {
		register int iobase = addr_6845;
		outb(iobase, CRTC_CURSORH);
		outb(iobase+1, pos >> 8);
		outb(iobase, CRTC_CURSORL);
		outb(iobase+1, pos);
		old_pos = pos;
	}
	if (cursor_shape != old_cursor_shape)
		set_cursor_shape();
}

void
async_update()
{

	if (kernel || polling) {
		if (async)
			timeout_del(&pccons_aup_tmo);
		do_async_update((void *)1);
	} else {
		if (async)
			return;
		async = 1;
		timeout_add(&pccons_aup_tmo, 1);
	}
}

/*
 * these are both bad jokes
 */
int
pcprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct isa_attach_args *ia = aux;
	u_int i;

	/* Enable interrupts and keyboard, etc. */
	if (!kbc_put8042cmd(CMDBYTE)) {
		printf("pcprobe: command error\n");
		return 0;
	}

#if 1
	/* Flush any garbage. */
	kbd_flush_input();
	/* Reset the keyboard. */
	if (!kbd_cmd(KBC_RESET, 1)) {
#ifdef DIAGNOSTIC
		printf("pcprobe: reset error %d\n", 1);
		/* XXX - this would make some - maybe very
		   broken - but usable keyboards unusable 
		goto lose; 
		*/
#endif
	}
	for (i = 600000; i; i--)
		if ((inb(IO_KBD + KBSTATP) & KBS_DIB) != 0) {
			KBD_DELAY;
			break;
		}
	if (i == 0 || inb(IO_KBD + KBDATAP) != KBR_RSTDONE) {
#ifdef DIAGNOSTIC
		printf("pcprobe: reset error %d\n", 2);
		/* XXX - this would make some - maybe very
		   broken - but usable keyboards unusable 
		goto lose; 
		*/
#endif
	}
	/*
	 * Some keyboards seem to leave a second ack byte after the reset.
	 * This is kind of stupid, but we account for them anyway by just
	 * flushing the buffer.
	 */
	kbd_flush_input();
	/* Just to be sure. */
	if (!kbd_cmd(KBC_ENABLE, 1)) {
		printf("pcprobe: reset error %d\n", 3);
		goto lose;
	}

	/*
	 * Some keyboard/8042 combinations do not seem to work if the keyboard
	 * is set to table 1; in fact, it would appear that some keyboards just
	 * ignore the command altogether.  So by default, we use the AT scan
	 * codes and have the 8042 translate them.  Unfortunately, this is
	 * known to not work on some PS/2 machines.  We try desparately to deal
	 * with this by checking the (lack of a) translate bit in the 8042 and
	 * attempting to set the keyboard to XT mode.  If this all fails, well,
	 * tough luck.
	 *
	 * XXX It would perhaps be a better choice to just use AT scan codes
	 * and not bother with this.
	 */
	if (kbc_get8042cmd() & KC8_TRANS) {
		/* The 8042 is translating for us; use AT codes. */
		if (!kbd_cmd(KBC_SETTABLE, 1) || !kbd_cmd(2, 1)) {
			printf("pcprobe: reset error %d\n", 4);
			goto lose;
		}
	} else {
		/* Stupid 8042; set keyboard to XT codes. */
		if (!kbd_cmd(KBC_SETTABLE, 1) || !kbd_cmd(1, 1)) {
			printf("pcprobe: reset error %d\n", 5);
			goto lose;
		}
	}

lose:
	/*
	 * Technically, we should probably fail the probe.  But we'll be nice
	 * and allow keyboard-less machines to boot with the console.
	 */
#endif

	ia->ia_iosize = 16;
	ia->ia_msize = 0;
	return 1;
}

void
pcattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pc_softc *sc = (void *)self;
	struct isa_attach_args *ia = aux;

	if (crtat == 0)
		pcinit();

	printf(": %s\n", vs.color ? "color" : "mono");
	do_async_update((void *)1);
	screen_restore(0);

	sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_TTY, pcintr, sc, sc->sc_dev.dv_xname);

	/*
	 * Look for children of the keyboard controller.
	 * XXX Really should decouple keyboard controller
	 * from the console code.
	 */
	while (config_found(self, ia->ia_ic, NULL) != NULL)	/* XXX */
		/* will break when no more children */ ;
}

int
pcopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	struct pc_softc *sc;
	int unit = PCUNIT(dev);
	struct tty *tp;
	int s;

	if (unit >= pc_cd.cd_ndevs)
		return ENXIO;
	sc = pc_cd.cd_devs[unit];
	if (sc == 0)
		return ENXIO;

	s = spltty();
	if (!sc->sc_tty) {
		tp = sc->sc_tty = ttymalloc();
		tty_attach(tp);
	} else
		tp = sc->sc_tty;
	splx(s);

	tp->t_oproc = pcstart;
	tp->t_param = pcparam;
	tp->t_dev = dev;
	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN;
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
		pcparam(tp, &tp->t_termios);
		ttsetwater(tp);
	} else if (tp->t_state&TS_XCLUDE && p->p_ucred->cr_uid != 0)
		return EBUSY;
	tp->t_state |= TS_CARR_ON;

	return ((*linesw[tp->t_line].l_open)(dev, tp));
}

int
pcclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	struct pc_softc *sc = pc_cd.cd_devs[PCUNIT(dev)];
	struct tty *tp = sc->sc_tty;

	(*linesw[tp->t_line].l_close)(tp, flag);
	ttyclose(tp);
#ifdef notyet /* XXX */
	ttyfree(tp);
#endif
	return(0);
}

int
pcread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct pc_softc *sc = pc_cd.cd_devs[PCUNIT(dev)];
	struct tty *tp = sc->sc_tty;

	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
pcwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct pc_softc *sc = pc_cd.cd_devs[PCUNIT(dev)];
	struct tty *tp = sc->sc_tty;

	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

struct tty *
pctty(dev)
	dev_t dev;
{
	struct pc_softc *sc = pc_cd.cd_devs[PCUNIT(dev)];
	struct tty *tp = sc->sc_tty;

	return (tp);
}

/*
 * Got a console receive interrupt -
 * the console processor wants to give us a character.
 * Catch the character, and see who it goes to.
 */
int
pcintr(arg)
	void *arg;
{
	struct pc_softc *sc = arg;
	register struct tty *tp = sc->sc_tty;
	u_char *cp;

	if ((inb(IO_KBD + KBSTATP) & KBS_DIB) == 0)
		return 0;
	if (polling)
		return 1;
	do {
		cp = sget();
		if (!tp || (tp->t_state & TS_ISOPEN) == 0)
			return 1;
		if (cp)
			do
				(*linesw[tp->t_line].l_rint)(*cp++, tp);
			while (*cp);
	} while (inb(IO_KBD + KBSTATP) & KBS_DIB);
	return 1;
}

int
pcioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	struct pc_softc *sc = pc_cd.cd_devs[PCUNIT(dev)];
	struct tty *tp = sc->sc_tty;
	int error;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;

	switch (cmd) {
#ifdef XSERVER
	case CONSOLE_X_MODE_ON:
		pc_xmode_on();
		ttyflush(tp, FREAD);
		return 0;
	case CONSOLE_X_MODE_OFF:
		pc_xmode_off();
		ttyflush(tp, FREAD);
		return 0;
	case CONSOLE_X_BELL:
		/*
		 * If set, data is a pointer to a length 2 array of
		 * integers.  data[0] is the pitch in Hz and data[1]
		 * is the duration in msec.
		 */
		if (data)
			sysbeep(((int *)data)[0],
				(((int *)data)[1] * hz) / 1000);
		else
			sysbeep(BEEP_FREQ, BEEP_TIME);
		return 0;
#endif /* XSERVER */
	case CONSOLE_SET_TYPEMATIC_RATE: {
 		u_char	rate;

 		if (!data)
			return EINVAL;
		rate = *((u_char *)data);
		/*
		 * Check that it isn't too big (which would cause it to be
		 * confused with a command).
		 */
		if (rate & 0x80)
			return EINVAL;
		typematic_rate = rate;
		async_update();
		return 0;
 	}
	case CONSOLE_SET_KEYMAP: {
		pccons_keymap_t *map = (pccons_keymap_t *) data;
		int i;

		if (!data)
			return EINVAL;
		for (i = 0; i < KB_NUM_KEYS; i++)
			if (map[i].unshift[KB_CODE_SIZE-1] ||
			    map[i].shift[KB_CODE_SIZE-1] ||
			    map[i].ctl[KB_CODE_SIZE-1] ||
			    map[i].altgr[KB_CODE_SIZE-1] ||
			    map[i].shift_altgr[KB_CODE_SIZE-1])
				return EINVAL;

		bcopy(data, scan_codes, sizeof(pccons_keymap_t[KB_NUM_KEYS]));
		return 0;
	}
	case CONSOLE_GET_KEYMAP:
		if (!data)
			return EINVAL;
		bcopy(scan_codes, data, sizeof(pccons_keymap_t[KB_NUM_KEYS]));
		return 0;
	case CONSOLE_SET_BLANK:
		pc_blank = *((int *)data);
		screen_restore(0);
		return 0;
	default:
		return ENOTTY;
	}

#ifdef DIAGNOSTIC
	panic("pcioctl: impossible");
#endif
}

void
pcstart(tp)
	struct tty *tp;
{
	struct clist *cl;
	int s, len;
	u_char buf[PCBURST];

	s = spltty();
	if (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP))
		goto out;
	tp->t_state |= TS_BUSY;
	splx(s);
	/*
	 * We need to do this outside spl since it could be fairly
	 * expensive and we don't want our serial ports to overflow.
	 */
	cl = &tp->t_outq;
	len = q_to_b(cl, buf, PCBURST);
	sput(buf, len);
	s = spltty();
	tp->t_state &= ~TS_BUSY;
	if (cl->c_cc) {
		tp->t_state |= TS_TIMEOUT;
		timeout_add(&tp->t_rstrt_to, 1);
	}
	if (cl->c_cc <= tp->t_lowat) {
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup(cl);
		}
		selwakeup(&tp->t_wsel);
	}
out:
	splx(s);
}

int
pcstop(tp, flag)
	struct tty *tp;
	int flag;
{
	return 0;
}

void
pccnprobe(cp)
	struct consdev *cp;
{
	int maj;

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == pcopen)
			break;

	/* initialize required fields */
	cp->cn_dev = makedev(maj, 0);
	cp->cn_pri = CN_INTERNAL;
}

/* ARGSUSED */
void
pccninit(cp)
	struct consdev *cp;
{

	/*
	 * For now, don't screw with it.
	 */
	/* crtat = 0; */
}

/* ARGSUSED */
void
pccnputc(dev, c)
	dev_t dev;
	char c;
{
	u_char oldkernel = kernel;

	kernel = 1;
	if (c == '\n')
		sput("\r\n", 2);
	else
		sput(&c, 1);
	kernel = oldkernel;
}

/* ARGSUSED */
int
pccngetc(dev)
	dev_t dev;
{
	register char *cp;

#ifdef XSERVER
	if (pc_xmode > 0)
		return 0;
#endif

	do {
		/* wait for byte */
		while ((inb(IO_KBD + KBSTATP) & KBS_DIB) == 0);
		/* see if it's worthwhile */
		cp = sget();
	} while (!cp);
	if (*cp == '\r')
		return '\n';
	return *cp;
}

void
pccnpollc(dev, on)
	dev_t dev;
	int on;
{

	polling = on;
	if (!on) {
		int unit;
		struct pc_softc *sc;
		int s;

		/*
		 * If disabling polling on a device that's been configured,
		 * make sure there are no bytes left in the FIFO, holding up
		 * the interrupt line.  Otherwise we won't get any further
		 * interrupts.
		 */
		unit = PCUNIT(dev);
		if (pc_cd.cd_ndevs > unit) {
			sc = pc_cd.cd_devs[unit];
			if (sc != 0) {
				s = spltty();
				pcintr(sc);
				splx(s);
			}
		}
	}
}	

/*
 * Set line parameters.
 */
int
pcparam(tp, t)
	struct tty *tp;
	struct termios *t;
{

	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;
	return 0;
}

void
pcinit()
{
	u_short volatile *cp;
	u_short was;
	unsigned cursorat;

	timeout_set(&pccons_aup_tmo, do_async_update, NULL);
	timeout_set(&pccons_blank_tmo, screen_blank, NULL);

	cp = ISA_HOLE_VADDR(CGA_BUF);
	was = *cp;
	*cp = (u_short) 0xA55A;
	if (*cp != 0xA55A) {
		cp = ISA_HOLE_VADDR(MONO_BUF);
		addr_6845 = MONO_BASE;
		vs.color = 0;
	} else {
		*cp = was;
		addr_6845 = CGA_BASE;
		vs.color = 1;
	}

	/* Extract cursor location */
	outb(addr_6845, CRTC_CURSORH);
	cursorat = inb(addr_6845+1) << 8;
	outb(addr_6845, CRTC_CURSORL);
	cursorat |= inb(addr_6845+1);

#ifdef FAT_CURSOR
	cursor_shape = 0x0012;
#endif

	Crtat = (u_short *)cp;
	crtat = (u_short *)(cp + cursorat);

	vs.ncol = COL;
	vs.nrow = ROW;
	vs.nchr = COL * ROW;
	vs.at = FG_LIGHTGREY | BG_BLACK;

	if (vs.color == 0)
		vs.so_at = FG_BLACK | BG_LIGHTGREY;
	else
		vs.so_at = FG_YELLOW | BG_BLACK;

	fillw((vs.at << 8) | ' ', crtat, vs.nchr - cursorat);
}

#define	wrtchar(c, at) do {\
	char *cp = (char *)crtat; *cp++ = (c); *cp = (at); crtat++; vs.col++; \
} while (0)

/* translate ANSI color codes to standard pc ones */
static char fgansitopc[] = {
	FG_BLACK, FG_RED, FG_GREEN, FG_BROWN, FG_BLUE,
	FG_MAGENTA, FG_CYAN, FG_LIGHTGREY
};

static char bgansitopc[] = {
	BG_BLACK, BG_RED, BG_GREEN, BG_BROWN, BG_BLUE,
	BG_MAGENTA, BG_CYAN, BG_LIGHTGREY
};

/*
 * iso latin to ibm 437 encoding iso2ibm437[char-128)]
 * characters not available are displayed as a caret
 */
static u_char iso2ibm437[] = {
	   4,     4,     4,     4,     4,     4,     4,     4,	/* 128 */
	   4,     4,     4,     4,     4,     4,     4,     4,	/* 136 */
	   4,     4,     4,     4,     4,     4,     4,     4,	/* 144 */
	   4,     4,     4,     4,     4,     4,     4,     4,	/* 152 */
	0xff,  0xad,  0x9b,  0x9c,     4,  0x9d,     4,  0x15,	/* 160 */
	   4,     4,  0xa6,  0xae,  0xaa,     4,     4,     4,	/* 168 */
	0xf8,  0xf1,  0xfd,     4,     4,  0xe6,     4,  0xfa,	/* 176 */
	   4,     4,  0xa7,  0xaf,  0xac,  0xab,     4,  0xa8,	/* 184 */
	   4,     4,     4,     4,  0x8e,  0x8f,  0x92,  0x80,	/* 192 */
	   4,  0x90,     4,     4,     4,     4,     4,     4,	/* 200 */
	   4,  0xa5,     4,     4,     4,     4,  0x99,     4,	/* 208 */
	   4,     4,     4,     4,  0x9a,     4,     4,  0xe1,	/* 216 */
	0x85,  0xa0,  0x83,     4,  0x84,  0x86,  0x91,  0x87,	/* 224 */
	0x8a,  0x82,  0x88,  0x89,  0x8d,  0xa1,  0x8c,  0x8b,	/* 232 */
	   4,  0xa4,  0x95,  0xa2,  0x93,     4,  0x94,  0xf6,	/* 240 */
	   4,  0x97,  0xa3,  0x96,  0x81,     4,     4,  0x98	/* 248 */
};

static u_short screen_backup[ROW*COL];
static int screen_saved = 0;
static u_short *saved_Crtat;

static void
screen_blank(arg)
	void *arg;
{
	if (! screen_saved) {
		bcopy(Crtat, screen_backup, ROW*COL*CHR);
		bzero(Crtat, ROW*COL*CHR);
		saved_Crtat = Crtat;
		Crtat = screen_backup;
		crtat = Crtat + (crtat - saved_Crtat);

#if 0
		/* write a little blinking square to bootom, left */
		saved_Crtat[(ROW - 1)*COL] =
			((FG_BLINK | FG_LIGHTGREY | BG_BLACK) << 8) | 220;
#endif
		screen_saved = 1;
	}
}

static void
screen_restore(perm)
	int perm;
{
	timeout_del(&pccons_blank_tmo);
	if (screen_saved) {
		Crtat = saved_Crtat;
		crtat = Crtat + (crtat - screen_backup);
		bcopy(screen_backup, Crtat, ROW*COL*CHR);
		screen_saved = 0;
	}
	if (!perm && (pc_blank > 0))
		timeout_add(&pccons_blank_tmo, pc_blank * hz);
}

/*
 * `pc3' termcap emulation.
 */
void
sput(cp, n)
	u_char *cp;
	int n;
{
	u_char c, scroll = 0;

#ifdef XSERVER
	if (pc_xmode > 0)
		return;
#endif

	if (crtat == 0)
		pcinit();

	while (n--) {
		if (!(c = *cp++))
			continue;

		switch (c) {
		case 0x1B:
			if (vs.state >= VSS_ESCAPE) {
				wrtchar(c, vs.so_at); 
				vs.state = 0;
				goto maybe_scroll;
			} else
				vs.state = VSS_ESCAPE;
			break;
		case 0x9B:	/* CSI */
			vs.cx = vs.cy = 0;
			vs.state = VSS_EBRACE;
			break;

		case '\t': {
			int inccol = 8 - (vs.col & 7);
			crtat += inccol;
			vs.col += inccol;
		}
		maybe_scroll:
			if (vs.col >= COL) {
				vs.col -= COL;
				scroll = 1;
			}
			break;

		case '\b':
			if (crtat <= Crtat)
				break;
			--crtat;
			if (--vs.col < 0)
				vs.col += COL;	/* non-destructive backspace */
			break;

		case '\r':
			crtat -= vs.col;
			vs.col = 0;
			break;

		case '\n':
			crtat += vs.ncol;
			scroll = 1;
			break;

		default:
			switch (vs.state) {
			case 0:
				if (c == '\a')
					sysbeep(BEEP_FREQ, BEEP_TIME);
				else {
					/*
					 * If we're outputting multiple printed
					 * characters, just blast them to the
					 * screen until we reach the end of the
					 * buffer or a control character.  This
					 * saves time by short-circuiting the
					 * switch.
					 * If we reach the end of the line, we
					 * break to do a scroll check.
					 */
					for (;;) {
						if (c & 0x80) 
							c = iso2ibm437[c&0x7f];
						if (vs.so)
							wrtchar(c, vs.so_at);
						else
							wrtchar(c, vs.at);
						if (vs.col >= vs.ncol) {
							vs.col = 0;
							scroll = 1;
							break;
						}
						if (!n || (c = *cp) < ' ')
							break;
						n--, cp++;
					}
				}
				break;
			case VSS_ESCAPE:
				switch (c) {
					case '[': /* Start ESC [ sequence */
						vs.cx = vs.cy = 0;
						vs.state = VSS_EBRACE;
						break;
					case 'c': /* Create screen & home */
						fillw((vs.at << 8) | ' ',
						    Crtat, vs.nchr);
						crtat = Crtat;
						vs.col = 0;
						vs.state = 0;
						break;
					case '7': /* save cursor pos */
						vs.offset = crtat - Crtat;
						vs.state = 0;
						break;
					case '8': /* restore cursor pos */
						crtat = Crtat + vs.offset;
						vs.row = vs.offset / vs.ncol;
						vs.col = vs.offset % vs.ncol;
						vs.state = 0;
						break;
					default: /* Invalid, clear state */
						wrtchar(c, vs.so_at); 
						vs.state = 0;
						goto maybe_scroll;
				}
				break;
			case VSS_EBRACEQ: {
				char *col;

				switch (c) {
				case 'D':
					break;
				case 'E':
					break;
				case 'F':
					col = &vs.at;
do_fg:
					*col = (*col & 0xf0) | (vs.cx & 0x0f);
					break;
				case 'G':
					col = &vs.at;
do_bg:
					*col = (*col & 0x0f) | ((vs.cx & 0x0f) << 4);
					break;
				case 'H':
					col = &vs.so_at;
					goto do_fg;
				case 'I':
					col = &vs.so_at;
					goto do_bg;
				case 'J':
					break;
				case 'K':
					break;
				case 'k':
					break;
				case 'l':
					break;
				case 'M':
					break;
				case 'R':
					vs.at = vs.save_at;
					vs.so_at = vs.save_so;
					break;
				case 'S':
					vs.save_at = vs.at;
					vs.save_so = vs.so_at;
					break;
				default:
					if ((c >= '0') && (c <= '9')) {
						vs.cx *= 10;
						vs.cx += c - '0';
					} else
						vs.state = 0;
					break;
				}
				vs.state = 0;
				break;
			}
			default: /* VSS_EBRACE or VSS_EPARAM */
				switch (c) {
					int pos;
				case 'm':
					if (!vs.cx)
						vs.so = 0;
					else
						vs.so = 1;
					vs.state = 0;
					break;
				case 'A': { /* back cx rows */
					int cx = vs.cx;
					if (cx <= 0)
						cx = 1;
					else
						cx %= vs.nrow;
					pos = crtat - Crtat;
					pos -= vs.ncol * cx;
					if (pos < 0)
						pos += vs.nchr;
					crtat = Crtat + pos;
					vs.state = 0;
					break;
				}
				case 'B': { /* down cx rows */
					int cx = vs.cx;
					if (cx <= 0)
						cx = 1;
					else
						cx %= vs.nrow;
					pos = crtat - Crtat;
					pos += vs.ncol * cx;
					if (pos >= vs.nchr) 
						pos -= vs.nchr;
					crtat = Crtat + pos;
					vs.state = 0;
					break;
				}
				case 'C': { /* right cursor */
					int cx = vs.cx,
					    col = vs.col;
					if (cx <= 0)
						cx = 1;
					else
						cx %= vs.ncol;
					pos = crtat - Crtat;
					pos += cx;
					col += cx;
					if (col >= vs.ncol) {
						pos -= vs.ncol;
						col -= vs.ncol;
					}
					vs.col = col;
					crtat = Crtat + pos;
					vs.state = 0;
					break;
				}
				case 'D': { /* left cursor */
					int cx = vs.cx,
					    col = vs.col;
					if (cx <= 0)
						cx = 1;
					else
						cx %= vs.ncol;
					pos = crtat - Crtat;
					pos -= cx;
					col -= cx;
					if (col < 0) {
						pos += vs.ncol;
						col += vs.ncol;
					}
					vs.col = col;
					crtat = Crtat + pos;
					vs.state = 0;
					break;
				}
				case 'J': /* Clear ... */
					switch (vs.cx) {
					case 0:
						/* ... to end of display */
						fillw((vs.at << 8) | ' ', 
						    crtat,
						    Crtat + vs.nchr - crtat);
						break;
					case 1:
						/* ... to next location */
						fillw((vs.at << 8) | ' ',
						    Crtat, crtat - Crtat + 1);
						break;
					case 2:
						/* ... whole display */
						fillw((vs.at << 8) | ' ',
						    Crtat, vs.nchr);
						break;
					}
					vs.state = 0;
					break;
				case 'K': /* Clear line ... */
					switch (vs.cx) {
					case 0:
						/* ... current to EOL */
						fillw((vs.at << 8) | ' ',
						    crtat, vs.ncol - vs.col);
						break;
					case 1:
						/* ... beginning to next */
						fillw((vs.at << 8) | ' ',
						    crtat - vs.col, vs.col + 1);
						break;
					case 2:
						/* ... entire line */
						fillw((vs.at << 8) | ' ',
						    crtat - vs.col, vs.ncol);
						break;
					}
					vs.state = 0;
					break;
				case 'f': /* in system V consoles */
				case 'H': { /* Cursor move */
					int cx = vs.cx,
					    cy = vs.cy;
					if (!cx || !cy) {
						crtat = Crtat;
						vs.col = 0;
					} else {
						if (cx > vs.nrow)
							cx = vs.nrow;
						if (cy > vs.ncol)
							cy = vs.ncol;
						crtat = Crtat +
						    (cx - 1) * vs.ncol + cy - 1;
						vs.col = cy - 1;
					}
					vs.state = 0;
					break;
				}
				case 'M': { /* delete cx rows */
					u_short *crtAt = crtat - vs.col;
					int cx = vs.cx,
					    row = (crtAt - Crtat) / vs.ncol,
					    nrow = vs.nrow - row;
					if (cx <= 0)
						cx = 1;
					else if (cx > nrow)
						cx = nrow;
					if (cx < nrow)
						bcopy(crtAt + vs.ncol * cx,
						    crtAt, vs.ncol * (nrow -
						    cx) * CHR);
					fillw((vs.at << 8) | ' ',
					    crtAt + vs.ncol * (nrow - cx),
					    vs.ncol * cx);
					vs.state = 0;
					break;
				}
				case 'S': { /* scroll up cx lines */
					int cx = vs.cx;
					if (cx <= 0)
						cx = 1;
					else if (cx > vs.nrow)
						cx = vs.nrow;
					if (cx < vs.nrow)
						bcopy(Crtat + vs.ncol * cx,
						    Crtat, vs.ncol * (vs.nrow -
						    cx) * CHR);
					fillw((vs.at << 8) | ' ',
					    Crtat + vs.ncol * (vs.nrow - cx),
					    vs.ncol * cx);
#if 0
					crtat -= vs.ncol * cx; /* XXX */
#endif
					vs.state = 0;
					break;
				}
				case 'L': { /* insert cx rows */
					u_short *crtAt = crtat - vs.col;
					int cx = vs.cx,
					    row = (crtAt - Crtat) / vs.ncol,
					    nrow = vs.nrow - row;
					if (cx <= 0)
						cx = 1;
					else if (cx > nrow)
						cx = nrow;
					if (cx < nrow)
						bcopy(crtAt,
						    crtAt + vs.ncol * cx,
						    vs.ncol * (nrow - cx) *
						    CHR);
					fillw((vs.at << 8) | ' ', 
					    crtAt, vs.ncol * cx);
					vs.state = 0;
					break;
				}
				case 'T': { /* scroll down cx lines */
					int cx = vs.cx;
					if (cx <= 0)
						cx = 1;
					else if (cx > vs.nrow)
						cx = vs.nrow;
					if (cx < vs.nrow)
						bcopy(Crtat,
						    Crtat + vs.ncol * cx,
						    vs.ncol * (vs.nrow - cx) *
						    CHR);
					fillw((vs.at << 8) | ' ', 
					    Crtat, vs.ncol * cx);
#if 0
					crtat += vs.ncol * cx; /* XXX */
#endif
					vs.state = 0;
					break;
				}
				case ';': /* Switch params in cursor def */
					vs.state = VSS_EPARAM;
					break;
				case 'r':
					vs.so_at = (vs.cx & FG_MASK) |
					    ((vs.cy << 4) & BG_MASK);
					vs.state = 0;
					break;
				case 's': /* save cursor pos */
					vs.offset = crtat - Crtat;
					vs.state = 0;
					break;
				case 'u': /* restore cursor pos */
					crtat = Crtat + vs.offset;
					vs.row = vs.offset / vs.ncol;
					vs.col = vs.offset % vs.ncol;
					vs.state = 0;
					break;
				case 'x': /* set attributes */
					switch (vs.cx) {
					case 0:
						vs.at = FG_LIGHTGREY | BG_BLACK;
						break;
					case 1:
						/* ansi background */
						if (!vs.color)
							break;
						vs.at &= FG_MASK;
						vs.at |= bgansitopc[vs.cy & 7];
						break;
					case 2:
						/* ansi foreground */
						if (!vs.color)
							break;
						vs.at &= BG_MASK;
						vs.at |= fgansitopc[vs.cy & 7];
						break;
					case 3:
						/* pc text attribute */
						if (vs.state >= VSS_EPARAM)
							vs.at = vs.cy;
						break;
					}
					vs.state = 0;
					break;
				case '_': /* set cursor type */
					if (vs.cx == 2)
						vs.cx = 14;
					else if (vs.cx)
						vs.cx = 1;
					else
						vs.cx = 12;
					cursor_shape = (vs.cx << 8) | 13;
					set_cursor_shape();
					break;
				case '=':
					vs.state = VSS_EBRACEQ;
					break;
					
				default: /* Only numbers valid here */
					if ((c >= '0') && (c <= '9')) {
						if (vs.state >= VSS_EPARAM) {
							vs.cy *= 10;
							vs.cy += c - '0';
						} else {
							vs.cx *= 10;
							vs.cx += c - '0';
						}
					} else
						vs.state = 0;
					break;
				}
				break;
			}
		}
		if (scroll) {
			scroll = 0;
			/* scroll check */
			if (crtat >= Crtat + vs.nchr) {
				if (!kernel) {
					int s = spltty();
					if (lock_state & KB_SCROLL)
						tsleep(&lock_state,
						    PUSER, "pcputc", 0);
					splx(s);
				}
				bcopy(Crtat + vs.ncol, Crtat,
				    (vs.nchr - vs.ncol) * CHR);
				fillw((vs.at << 8) | ' ',
				    Crtat + vs.nchr - vs.ncol,
				    vs.ncol);
				crtat -= vs.ncol;
			}
		}
	}
	async_update();
}

/* the unshifted code for KB_SHIFT keys is used by X to distinguish between 
   left and right shift when reading the keyboard map */
static pccons_keymap_t	scan_codes[KB_NUM_KEYS] = {
/*  type       unshift   shift     control   altgr     shift_altgr scancode */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 0 unused */
  { KB_ASCII,  "\033",   "\033",   "\033",   "",       "", }, /* 1 ESCape */
  { KB_ASCII,  "1",      "!",      "!",      "",       "", }, /* 2 1 */
  { KB_ASCII,  "2",      "@@",      "\000",   "",       "", }, /* 3 2 */
  { KB_ASCII,  "3",      "#",      "#",      "",       "", }, /* 4 3 */
  { KB_ASCII,  "4",      "$",      "$",      "",       "", }, /* 5 4 */
  { KB_ASCII,  "5",      "%",      "%",      "",       "", }, /* 6 5 */
  { KB_ASCII,  "6",      "^",      "\036",   "",       "", }, /* 7 6 */
  { KB_ASCII,  "7",      "&",      "&",      "",       "", }, /* 8 7 */
  { KB_ASCII,  "8",      "*",      "\010",   "",       "", }, /* 9 8 */
  { KB_ASCII,  "9",      "(",      "(",      "",       "", }, /* 10 9 */
  { KB_ASCII,  "0",      ")",      ")",      "",       "", }, /* 11 0 */
  { KB_ASCII,  "-",      "_",      "\037",   "",       "", }, /* 12 - */
  { KB_ASCII,  "=",      "+",      "+",      "",       "", }, /* 13 = */
  { KB_ASCII,  "\177",   "\177",   "\010",   "",       "", }, /* 14 backspace */
  { KB_ASCII,  "\t",     "\t",     "\t",     "",       "", }, /* 15 tab */
  { KB_ASCII,  "q",      "Q",      "\021",   "",       "", }, /* 16 q */
  { KB_ASCII,  "w",      "W",      "\027",   "",       "", }, /* 17 w */
  { KB_ASCII,  "e",      "E",      "\005",   "",       "", }, /* 18 e */
  { KB_ASCII,  "r",      "R",      "\022",   "",       "", }, /* 19 r */
  { KB_ASCII,  "t",      "T",      "\024",   "",       "", }, /* 20 t */
  { KB_ASCII,  "y",      "Y",      "\031",   "",       "", }, /* 21 y */
  { KB_ASCII,  "u",      "U",      "\025",   "",       "", }, /* 22 u */
  { KB_ASCII,  "i",      "I",      "\011",   "",       "", }, /* 23 i */
  { KB_ASCII,  "o",      "O",      "\017",   "",       "", }, /* 24 o */
  { KB_ASCII,  "p",      "P",      "\020",   "",       "", }, /* 25 p */
  { KB_ASCII,  "[",      "{",      "\033",   "",       "", }, /* 26 [ */
  { KB_ASCII,  "]",      "}",      "\035",   "",       "", }, /* 27 ] */
  { KB_ASCII,  "\r",     "\r",     "\n",     "",       "", }, /* 28 return */
  { KB_CTL,    "",       "",       "",       "",       "", }, /* 29 control */
  { KB_ASCII,  "a",      "A",      "\001",   "",       "", }, /* 30 a */
  { KB_ASCII,  "s",      "S",      "\023",   "",       "", }, /* 31 s */
  { KB_ASCII,  "d",      "D",      "\004",   "",       "", }, /* 32 d */
  { KB_ASCII,  "f",      "F",      "\006",   "",       "", }, /* 33 f */
  { KB_ASCII,  "g",      "G",      "\007",   "",       "", }, /* 34 g */
  { KB_ASCII,  "h",      "H",      "\010",   "",       "", }, /* 35 h */
  { KB_ASCII,  "j",      "J",      "\n",     "",       "", }, /* 36 j */
  { KB_ASCII,  "k",      "K",      "\013",   "",       "", }, /* 37 k */
  { KB_ASCII,  "l",      "L",      "\014",   "",       "", }, /* 38 l */
  { KB_ASCII,  ";",      ":",      ";",      "",       "", }, /* 39 ; */
  { KB_ASCII,  "'",      "\"",     "'",      "",       "", }, /* 40 ' */
  { KB_ASCII,  "`",      "~",      "`",      "",       "", }, /* 41 ` */
  { KB_SHIFT,  "\001",   "",       "",       "",       "", }, /* 42 shift */
  { KB_ASCII,  "\\",     "|",      "\034",   "",       "", }, /* 43 \ */
  { KB_ASCII,  "z",      "Z",      "\032",   "",       "", }, /* 44 z */
  { KB_ASCII,  "x",      "X",      "\030",   "",       "", }, /* 45 x */
  { KB_ASCII,  "c",      "C",      "\003",   "",       "", }, /* 46 c */
  { KB_ASCII,  "v",      "V",      "\026",   "",       "", }, /* 47 v */
  { KB_ASCII,  "b",      "B",      "\002",   "",       "", }, /* 48 b */
  { KB_ASCII,  "n",      "N",      "\016",   "",       "", }, /* 49 n */
  { KB_ASCII,  "m",      "M",      "\r",     "",       "", }, /* 50 m */
  { KB_ASCII,  ",",      "<",      "<",      "",       "", }, /* 51 , */
  { KB_ASCII,  ".",      ">",      ">",      "",       "", }, /* 52 . */
  { KB_ASCII,  "/",      "?",      "\037",   "",       "", }, /* 53 / */
  { KB_SHIFT,  "\002",   "",       "",       "",       "", }, /* 54 shift */
  { KB_KP,     "*",      "*",      "*",      "",       "", }, /* 55 kp * */
  { KB_ALT,    "",       "",       "",       "",       "", }, /* 56 alt */
  { KB_ASCII,  " ",      " ",      "\000",   "",       "", }, /* 57 space */
  { KB_CAPS,   "",       "",       "",       "",       "", }, /* 58 caps */
  { KB_FUNC,   "\033[M", "\033[Y", "\033[k", "",       "", }, /* 59 f1 */
  { KB_FUNC,   "\033[N", "\033[Z", "\033[l", "",       "", }, /* 60 f2 */
  { KB_FUNC,   "\033[O", "\033[a", "\033[m", "",       "", }, /* 61 f3 */
  { KB_FUNC,   "\033[P", "\033[b", "\033[n", "",       "", }, /* 62 f4 */
  { KB_FUNC,   "\033[Q", "\033[c", "\033[o", "",       "", }, /* 63 f5 */
  { KB_FUNC,   "\033[R", "\033[d", "\033[p", "",       "", }, /* 64 f6 */
  { KB_FUNC,   "\033[S", "\033[e", "\033[q", "",       "", }, /* 65 f7 */
  { KB_FUNC,   "\033[T", "\033[f", "\033[r", "",       "", }, /* 66 f8 */
  { KB_FUNC,   "\033[U", "\033[g", "\033[s", "",       "", }, /* 67 f9 */
  { KB_FUNC,   "\033[V", "\033[h", "\033[t", "",       "", }, /* 68 f10 */
  { KB_NUM,    "",       "",       "",       "",       "", }, /* 69 num lock */
  { KB_SCROLL, "",       "",       "",       "",       "", }, /* 70 scroll lock */
  { KB_KP,     "7",      "\033[H", "7",      "",       "", }, /* 71 kp 7 */
  { KB_KP,     "8",      "\033[A", "8",      "",       "", }, /* 72 kp 8 */
  { KB_KP,     "9",      "\033[I", "9",      "",       "", }, /* 73 kp 9 */
  { KB_KP,     "-",      "-",      "-",      "",       "", }, /* 74 kp - */
  { KB_KP,     "4",      "\033[D", "4",      "",       "", }, /* 75 kp 4 */
  { KB_KP,     "5",      "\033[E", "5",      "",       "", }, /* 76 kp 5 */
  { KB_KP,     "6",      "\033[C", "6",      "",       "", }, /* 77 kp 6 */
  { KB_KP,     "+",      "+",      "+",      "",       "", }, /* 78 kp + */
  { KB_KP,     "1",      "\033[F", "1",      "",       "", }, /* 79 kp 1 */
  { KB_KP,     "2",      "\033[B", "2",      "",       "", }, /* 80 kp 2 */
  { KB_KP,     "3",      "\033[G", "3",      "",       "", }, /* 81 kp 3 */
  { KB_KP,     "0",      "\033[L", "0",      "",       "", }, /* 82 kp 0 */
  { KB_KP,     ",",      "\177",   ",",      "",       "", }, /* 83 kp , */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 84 0 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 85 0 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 86 0 */
  { KB_FUNC,   "\033[W", "\033[i", "\033[u", "",       "", }, /* 87 f11 */
  { KB_FUNC,   "\033[X", "\033[j", "\033[v", "",       "", }, /* 88 f12 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 89 0 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 90 0 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 91 0 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 92 0 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 93 0 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 94 0 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 95 0 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 96 0 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 97 0 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 98 0 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 99 0 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 100 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 101 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 102 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 103 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 104 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 105 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 106 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 107 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 108 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 109 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 110 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 111 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 112 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 113 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 114 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 115 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 116 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 117 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 118 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 119 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 120 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 121 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 122 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 123 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 124 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 125 */
  { KB_NONE,   "",       "",       "",       "",       "", }, /* 126 */
  { KB_NONE,   "",       "",       "",       "",       ""  }, /* 127 */
};

/*
 * Get characters from the keyboard.  If none are present, return NULL.
 */
char *
sget()
{
	u_char dt;
	static u_char extended = 0, shift_state = 0;
	static u_char capchar[2];

top:
	KBD_DELAY;
	dt = inb(IO_KBD + KBDATAP);

	switch (dt) {
	case KBR_ACK:
		ack = 1;
		goto loop;
	case KBR_RESEND:
		nak = 1;
		goto loop;
	}

#ifdef XSERVER
	if (pc_xmode > 0) {
#if defined(DDB) && defined(XSERVER_DDB)
		/* F12 enters the debugger while in X mode */
		if (dt == 88)
			if (db_console)
				Debugger();
#endif
		capchar[0] = dt;
		capchar[1] = 0;
		/*
		 * Check for locking keys.
		 *
		 * XXX Setting the LEDs this way is a bit bogus.  What if the
		 * keyboard has been remapped in X?
		 */
		switch (scan_codes[dt & 0x7f].type) {
		case KB_NUM:
			if (dt & 0x80) {
				shift_state &= ~KB_NUM;
				break;
			}
			if (shift_state & KB_NUM)
				break;
			shift_state |= KB_NUM;
			lock_state ^= KB_NUM;
			async_update();
			break;
		case KB_CAPS:
			if (dt & 0x80) {
				shift_state &= ~KB_CAPS;
				break;
			}
			if (shift_state & KB_CAPS)
				break;
			shift_state |= KB_CAPS;
			lock_state ^= KB_CAPS;
			async_update();
			break;
		case KB_SCROLL:
			if (dt & 0x80) {
				shift_state &= ~KB_SCROLL;
				break;
			}
			if (shift_state & KB_SCROLL)
				break;
			shift_state |= KB_SCROLL;
			lock_state ^= KB_SCROLL;
			if ((lock_state & KB_SCROLL) == 0)
				wakeup(&lock_state);
			async_update();
			break;
		}
		return capchar;
	}
#endif /* XSERVER */

	switch (dt) {
	case KBR_EXTENDED:
		extended = 1;
		goto loop;
	}

#ifdef DDB
	/*
	 * Check for cntl-alt-esc.
	 */
	if (dt == 1 &&
	    (shift_state & (KB_CTL | KB_ALT)) == (KB_CTL | KB_ALT)) {
		screen_restore(1);
		if (db_console)
			Debugger();
		dt |= 0x80;	/* discard esc (ddb discarded ctl-alt) */
	}
#endif

	screen_restore(0);

	/*
	 * Check for make/break.
	 */
	if (dt & 0x80) {
		/*
		 * break
		 */
		dt &= 0x7f;
		switch (scan_codes[dt].type) {
		case KB_NUM:
			shift_state &= ~KB_NUM;
			break;
		case KB_CAPS:
			shift_state &= ~KB_CAPS;
			break;
		case KB_SCROLL:
			shift_state &= ~KB_SCROLL;
			break;
		case KB_SHIFT:
			shift_state &= ~KB_SHIFT;
			break;
		case KB_ALT:
			if (extended)
				shift_state &= ~KB_ALTGR;
			else
				shift_state &= ~KB_ALT;
			break;
		case KB_CTL:
			shift_state &= ~KB_CTL;
			break;
		}
	} else {
		/*
		 * make
		 */
		switch (scan_codes[dt].type) {
		/*
		 * locking keys
		 */
		case KB_NUM:
			if (shift_state & KB_NUM)
				break;
			shift_state |= KB_NUM;
			lock_state ^= KB_NUM;
			async_update();
			break;
		case KB_CAPS:
			if (shift_state & KB_CAPS)
				break;
			shift_state |= KB_CAPS;
			lock_state ^= KB_CAPS;
			async_update();
			break;
		case KB_SCROLL:
			if (shift_state & KB_SCROLL)
				break;
			shift_state |= KB_SCROLL;
			lock_state ^= KB_SCROLL;
			if ((lock_state & KB_SCROLL) == 0)
				wakeup(&lock_state);
			async_update();
			break;
		/*
		 * non-locking keys
		 */
		case KB_SHIFT:
			shift_state |= KB_SHIFT;
			break;
		case KB_ALT:
			if (extended)
				shift_state |= KB_ALTGR;
			else
				shift_state |= KB_ALT;
			break;
		case KB_CTL:
			shift_state |= KB_CTL;
			break;
		case KB_ASCII:
			/* control has highest priority */
			if (shift_state & KB_CTL)
				capchar[0] = scan_codes[dt].ctl[0];
			else if (shift_state & KB_ALTGR) {
				if (shift_state & KB_SHIFT)
					capchar[0] = scan_codes[dt].shift_altgr[0];
				else
					capchar[0] = scan_codes[dt].altgr[0];
			} else {
				if (shift_state & KB_SHIFT)
					capchar[0] = scan_codes[dt].shift[0];
				else
					capchar[0] = scan_codes[dt].unshift[0];
			}
			if ((lock_state & KB_CAPS) && capchar[0] >= 'a' &&
			    capchar[0] <= 'z') {
				capchar[0] -= ('a' - 'A');
			}
			capchar[0] |= (shift_state & KB_ALT);
			extended = 0;
			return capchar;
		case KB_NONE:
			break;
		case KB_FUNC: {
			char *more_chars;
			if (shift_state & KB_SHIFT)
				more_chars = scan_codes[dt].shift;
			else if (shift_state & KB_CTL)
				more_chars = scan_codes[dt].ctl;
			else
				more_chars = scan_codes[dt].unshift;
			extended = 0;
			return more_chars;
		}
		case KB_KP: {
			char *more_chars;
			if (shift_state & (KB_SHIFT | KB_CTL) ||
			    (lock_state & KB_NUM) == 0 || extended)
				more_chars = scan_codes[dt].shift;
			else
				more_chars = scan_codes[dt].unshift;
			extended = 0;
			return more_chars;
		}
		}
	}

	extended = 0;
loop:
	if ((inb(IO_KBD + KBSTATP) & KBS_DIB) == 0)
		return 0;
	goto top;
}

paddr_t
pcmmap(dev, offset, nprot)
	dev_t dev;
	off_t offset;
	int nprot;
{

	if ((u_int)offset > 0x20000)
		return -1;
	return i386_btop(0xa0000 + offset);
}

#ifdef XSERVER
void
pc_xmode_on()
{

	if (pc_xmode)
		return;
	pc_xmode = 1;
	screen_restore(1);

#ifdef XFREE86_BUG_COMPAT
	/* If still unchanged, get current shape. */
	if (cursor_shape == 0xffff)
		get_cursor_shape();
#endif
}

void
pc_xmode_off()
{
	struct trapframe *fp;

	if (pc_xmode == 0)
		return;
	pc_xmode = 0;

#ifdef XFREE86_BUG_COMPAT
	/* XXX It would be hard to justify why the X server doesn't do this. */
	set_cursor_shape();
#endif
	async_update();
	screen_restore(0);

	fp = curproc->p_md.md_regs;
	if (securelevel <= 0)
		fp->tf_eflags &= ~PSL_IOPL;
}
#endif /* XSERVER */
@


1.50
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.49 2002/03/14 01:26:33 millert Exp $	*/
@


1.49
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.48 2001/11/01 12:13:46 art Exp $	*/
d694 2
a695 2
			sysbeep(((int*)data)[0],
				(((int*)data)[1] * hz) / 1000);
@


1.48
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.47 2001/05/16 05:07:48 millert Exp $	*/
d132 5
a136 5
int pcprobe __P((struct device *, void *, void *));
void pcattach __P((struct device *, struct device *, void *));
int pcintr __P((void *));
static void screen_restore __P((int));
static void screen_blank __P((void *));
d152 3
a154 3
void pcinit __P((void));
char *sget __P((void));
void sput __P((u_char *, int));
d156 2
a157 2
void pc_xmode_on __P((void));
void pc_xmode_off __P((void));
d160 2
a161 2
void	pcstart __P((struct tty *));
int	pcparam __P((struct tty *, struct termios *));
d163 2
a164 2
int kbd_cmd __P((u_char, u_char));
void set_cursor_shape __P((void));
d166 1
a166 1
void get_cursor_shape __P((void));
d168 2
a169 2
void do_async_update __P((void *));
void async_update __P((void));
d171 11
a181 11
static __inline int kbd_wait_output __P((void));
static __inline int kbd_wait_input __P((void));
static __inline void kbd_flush_input __P((void));
static u_char kbc_get8042cmd __P((void));
static int kbc_put8042cmd __P((u_char));

void pccnprobe __P((struct consdev *));
void pccninit __P((struct consdev *));
void pccnputc __P((dev_t, char));
int pccngetc __P((dev_t));
void pccnpollc __P((dev_t, int));
@


1.48.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.48 2001/11/01 12:13:46 art Exp $	*/
d132 5
a136 5
int pcprobe(struct device *, void *, void *);
void pcattach(struct device *, struct device *, void *);
int pcintr(void *);
static void screen_restore(int);
static void screen_blank(void *);
d152 3
a154 3
void pcinit(void);
char *sget(void);
void sput(u_char *, int);
d156 2
a157 2
void pc_xmode_on(void);
void pc_xmode_off(void);
d160 2
a161 2
void	pcstart(struct tty *);
int	pcparam(struct tty *, struct termios *);
d163 2
a164 2
int kbd_cmd(u_char, u_char);
void set_cursor_shape(void);
d166 1
a166 1
void get_cursor_shape(void);
d168 2
a169 2
void do_async_update(void *);
void async_update(void);
d171 11
a181 11
static __inline int kbd_wait_output(void);
static __inline int kbd_wait_input(void);
static __inline void kbd_flush_input(void);
static u_char kbc_get8042cmd(void);
static int kbc_put8042cmd(u_char);

void pccnprobe(struct consdev *);
void pccninit(struct consdev *);
void pccnputc(dev_t, char);
int pccngetc(dev_t);
void pccnpollc(dev_t, int);
d694 2
a695 2
			sysbeep(((int *)data)[0],
				(((int *)data)[1] * hz) / 1000);
@


1.48.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.48.2.1 2002/06/11 03:35:54 art Exp $	*/
@


1.47
log
@kill COMPAT_{09,10,11} kernel options.  We still need kern_info_09.c and kern_ipc_10.c for other compat modules.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.46 2000/11/13 15:53:34 aaron Exp $	*/
d1893 1
a1893 1
int
d1896 1
a1896 1
	int offset;
@


1.46
log
@Address the i8042 keyboard controller registers as offsets from IO_KBD; from
NetBSD. This will ease the pain when we bring in the pckbc MI keyboard
driver to be used for wscons/i386 and wscons/alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.45 2000/07/19 16:40:17 mickey Exp $	*/
a1908 3
#ifdef COMPAT_10
	struct trapframe *fp;
#endif
a1918 7
#endif

#ifdef COMPAT_10
	/* This is done by i386_iopl(3) now. */
	fp = curproc->p_md.md_regs;
	if (securelevel <= 0)
		fp->tf_eflags |= PSL_IOPL;
@


1.45
log
@new timeouts; tested
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.44 2000/07/19 13:46:20 art Exp $	*/
d200 1
a200 1
		if ((inb(KBSTATP) & KBS_IBF) == 0) {
d213 1
a213 1
		if ((inb(KBSTATP) & KBS_DIB) != 0) {
d226 1
a226 1
		if ((inb(KBSTATP) & KBS_DIB) == 0)
d229 1
a229 1
		(void) inb(KBDATAP);
d243 1
a243 1
	outb(KBCMDP, K_RDCMDBYTE);
d246 1
a246 1
	return inb(KBDATAP);
d260 1
a260 1
	outb(KBCMDP, K_LDCMDBYTE);
d263 1
a263 1
	outb(KBOUTP, val);
d282 1
a282 1
		outb(KBOUTP, val);
d285 1
a285 1
				if (inb(KBSTATP) & KBS_DIB) {
d289 1
a289 1
					c = inb(KBDATAP);
d305 1
a305 1
				(void) inb(KBSTATP);
d442 1
a442 1
		if ((inb(KBSTATP) & KBS_DIB) != 0) {
d446 1
a446 1
	if (i == 0 || inb(KBDATAP) != KBR_RSTDONE) {
d642 1
a642 1
	if ((inb(KBSTATP) & KBS_DIB) == 0)
d654 1
a654 1
	} while (inb(KBSTATP) & KBS_DIB);
d854 1
a854 1
		while ((inb(KBSTATP) & KBS_DIB) == 0);
d1672 1
a1672 1
	dt = inb(KBDATAP);
d1888 1
a1888 1
	if ((inb(KBSTATP) & KBS_DIB) == 0)
@


1.44
log
@Use t_rstrt_to for ttrstrt timeout.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.43 2000/03/23 17:17:33 aaron Exp $	*/
d59 1
d105 2
d136 1
d401 1
a401 1
			untimeout(do_async_update, NULL);
d407 1
a407 1
		timeout(do_async_update, NULL, 1);
d915 3
a997 1
static void screen_blank __P((void *));
d1023 1
a1023 1
	untimeout(screen_blank, NULL);
d1031 1
a1031 1
		timeout(screen_blank, NULL, pc_blank * hz);
@


1.43
log
@Do not include <sys/callout.h>, it is never needed; art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.42 1998/11/20 15:57:25 deraadt Exp $	*/
d771 1
a771 1
		timeout(ttrstrt, tp, 1);
@


1.42
log
@careful off handling in mmap routines
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.41 1998/07/09 18:22:25 deraadt Exp $	*/
a55 1
#include <sys/callout.h>
@


1.42.6.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
@


1.42.6.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.46 2000/11/13 15:53:34 aaron Exp $	*/
a58 1
#include <sys/timeout.h>
a103 2
struct timeout pccons_aup_tmo;
struct timeout pccons_blank_tmo;
a132 1
static void screen_blank __P((void *));
d196 1
a196 1
		if ((inb(IO_KBD + KBSTATP) & KBS_IBF) == 0) {
d209 1
a209 1
		if ((inb(IO_KBD + KBSTATP) & KBS_DIB) != 0) {
d222 1
a222 1
		if ((inb(IO_KBD + KBSTATP) & KBS_DIB) == 0)
d225 1
a225 1
		(void) inb(IO_KBD + KBDATAP);
d239 1
a239 1
	outb(IO_KBD + KBCMDP, K_RDCMDBYTE);
d242 1
a242 1
	return inb(IO_KBD + KBDATAP);
d256 1
a256 1
	outb(IO_KBD + KBCMDP, K_LDCMDBYTE);
d259 1
a259 1
	outb(IO_KBD + KBOUTP, val);
d278 1
a278 1
		outb(IO_KBD + KBOUTP, val);
d281 1
a281 1
				if (inb(IO_KBD + KBSTATP) & KBS_DIB) {
d285 1
a285 1
					c = inb(IO_KBD + KBDATAP);
d301 1
a301 1
				(void) inb(IO_KBD + KBSTATP);
d397 1
a397 1
			timeout_del(&pccons_aup_tmo);
d403 1
a403 1
		timeout_add(&pccons_aup_tmo, 1);
d438 1
a438 1
		if ((inb(IO_KBD + KBSTATP) & KBS_DIB) != 0) {
d442 1
a442 1
	if (i == 0 || inb(IO_KBD + KBDATAP) != KBR_RSTDONE) {
d638 1
a638 1
	if ((inb(IO_KBD + KBSTATP) & KBS_DIB) == 0)
d650 1
a650 1
	} while (inb(IO_KBD + KBSTATP) & KBS_DIB);
d771 1
a771 1
		timeout_add(&tp->t_rstrt_to, 1);
d850 1
a850 1
		while ((inb(IO_KBD + KBSTATP) & KBS_DIB) == 0);
a910 3
	timeout_set(&pccons_aup_tmo, do_async_update, NULL);
	timeout_set(&pccons_blank_tmo, screen_blank, NULL);

d991 1
d1017 1
a1017 1
	timeout_del(&pccons_blank_tmo);
d1025 1
a1025 1
		timeout_add(&pccons_blank_tmo, pc_blank * hz);
d1666 1
a1666 1
	dt = inb(IO_KBD + KBDATAP);
d1882 1
a1882 1
	if ((inb(IO_KBD + KBSTATP) & KBS_DIB) == 0)
@


1.42.6.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.42.6.2 2001/04/18 16:07:55 niklas Exp $	*/
d1909 3
d1922 7
@


1.42.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1893 1
a1893 1
paddr_t
d1896 1
a1896 1
	off_t offset;
@


1.42.6.5
log
@Merge in -current from about a week ago
@
text
@d132 5
a136 5
int pcprobe(struct device *, void *, void *);
void pcattach(struct device *, struct device *, void *);
int pcintr(void *);
static void screen_restore(int);
static void screen_blank(void *);
d152 3
a154 3
void pcinit(void);
char *sget(void);
void sput(u_char *, int);
d156 2
a157 2
void pc_xmode_on(void);
void pc_xmode_off(void);
d160 2
a161 2
void	pcstart(struct tty *);
int	pcparam(struct tty *, struct termios *);
d163 2
a164 2
int kbd_cmd(u_char, u_char);
void set_cursor_shape(void);
d166 1
a166 1
void get_cursor_shape(void);
d168 2
a169 2
void do_async_update(void *);
void async_update(void);
d171 11
a181 11
static __inline int kbd_wait_output(void);
static __inline int kbd_wait_input(void);
static __inline void kbd_flush_input(void);
static u_char kbc_get8042cmd(void);
static int kbc_put8042cmd(u_char);

void pccnprobe(struct consdev *);
void pccninit(struct consdev *);
void pccnputc(dev_t, char);
int pccngetc(dev_t);
void pccnpollc(dev_t, int);
d694 2
a695 2
			sysbeep(((int *)data)[0],
				(((int *)data)[1] * hz) / 1000);
@


1.42.6.6
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.42.6.5 2002/03/28 10:31:04 niklas Exp $	*/
@


1.41
log
@never set PSL_IOPL at high securelevel (except the one xf86 case, controlled by the aperture driver; problem noted by csapuntz
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.40 1998/03/16 09:12:39 downsj Exp $	*/
d1895 1
a1895 1
	if (offset > 0x20000)
@


1.40
log
@please gcc (couldn't find any reference, so just deleted offending declaration)
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.39 1998/02/22 13:03:00 deraadt Exp $	*/
d1922 2
a1923 1
	fp->tf_eflags |= PSL_IOPL;
d1944 2
a1945 1
	fp->tf_eflags &= ~PSL_IOPL;
@


1.39
log
@fix db_console chunk of code properly
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.38 1998/02/22 13:02:26 deraadt Exp $	*/
a158 2

char	partab[];
@


1.38
log
@fix db_console chunk of code properly
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.37 1998/02/05 16:48:30 deraadt Exp $	*/
d1684 1
a1684 1
		if (dt == 88 && db_console)
@


1.37
log
@rename ddb.panic_ddb, and add ddb.console. Now you can stop console ddb entry
with a sysctl. There will be architectures and drivers that lack function,
and I trust the maintainers of those will forget to add the code..
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.36 1997/11/06 02:26:45 deraadt Exp $	*/
d1747 1
a1747 1
	if (db_console && dt == 1 &&
@


1.36
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.35 1997/11/05 09:38:54 deraadt Exp $	*/
d60 3
d1684 3
a1686 2
		if (dt == 88)
			Debugger();
d1747 2
a1748 1
	if ((dt == 1) && (shift_state & (KB_CTL | KB_ALT)) == (KB_CTL | KB_ALT)) {
d1750 2
a1751 1
		Debugger();
@


1.35
log
@flush tty queue when entering/exiting X; cgd & me
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.34 1997/03/03 12:01:15 downsj Exp $	*/
d53 1
@


1.34
log
@Add a little ioctl at 4am to set the screen blanking.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.33 1996/12/29 12:25:59 graichen Exp $	*/
d676 1
d680 1
@


1.33
log
@add some comments to some things we removed to get also more broken
keyboards working
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.32 1996/12/20 07:24:49 graichen Exp $	*/
d97 1
d731 4
d1021 2
a1022 2
	if (! perm)
		timeout(screen_blank, NULL, 300*hz);
@


1.32
log
@add missing #ifdef COMPAT_10
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.31 1996/12/05 04:40:26 tholo Exp $	*/
d429 4
d443 4
@


1.31
log
@Implement a few more escape sequences that BSD/OS has defined for pccons;
fixes NetBSD PR 2947.  Note that some of the new sequences are accepted but
ignored
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.30 1996/10/16 12:46:30 deraadt Exp $	*/
d1884 1
d1886 1
@


1.30
log
@the Wall thing, you know
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.29 1996/09/23 15:12:40 mickey Exp $	*/
d111 2
a112 1
#define	VSS_EPARAM	3
d115 2
a116 2
	char	at;		/* normal attributes */
	char	so_at;		/* standout attributes */
d1141 53
d1450 13
@


1.29
log
@use <dev/ic/mc6845.h> for CRTC registers definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.28 1996/09/06 08:40:48 mickey Exp $	*/
d974 1
d1441 128
a1568 128
    KB_NONE,   "",       "",       "",       "",       "",  /* 0 unused */
    KB_ASCII,  "\033",   "\033",   "\033",   "",       "",  /* 1 ESCape */
    KB_ASCII,  "1",      "!",      "!",      "",       "",  /* 2 1 */
    KB_ASCII,  "2",      "@@",      "\000",   "",       "",  /* 3 2 */
    KB_ASCII,  "3",      "#",      "#",      "",       "",  /* 4 3 */
    KB_ASCII,  "4",      "$",      "$",      "",       "",  /* 5 4 */
    KB_ASCII,  "5",      "%",      "%",      "",       "",  /* 6 5 */
    KB_ASCII,  "6",      "^",      "\036",   "",       "",  /* 7 6 */
    KB_ASCII,  "7",      "&",      "&",      "",       "",  /* 8 7 */
    KB_ASCII,  "8",      "*",      "\010",   "",       "",  /* 9 8 */
    KB_ASCII,  "9",      "(",      "(",      "",       "",  /* 10 9 */
    KB_ASCII,  "0",      ")",      ")",      "",       "",  /* 11 0 */
    KB_ASCII,  "-",      "_",      "\037",   "",       "",  /* 12 - */
    KB_ASCII,  "=",      "+",      "+",      "",       "",  /* 13 = */
    KB_ASCII,  "\177",   "\177",   "\010",   "",       "",  /* 14 backspace */
    KB_ASCII,  "\t",     "\t",     "\t",     "",       "",  /* 15 tab */
    KB_ASCII,  "q",      "Q",      "\021",   "",       "",  /* 16 q */
    KB_ASCII,  "w",      "W",      "\027",   "",       "",  /* 17 w */
    KB_ASCII,  "e",      "E",      "\005",   "",       "",  /* 18 e */
    KB_ASCII,  "r",      "R",      "\022",   "",       "",  /* 19 r */
    KB_ASCII,  "t",      "T",      "\024",   "",       "",  /* 20 t */
    KB_ASCII,  "y",      "Y",      "\031",   "",       "",  /* 21 y */
    KB_ASCII,  "u",      "U",      "\025",   "",       "",  /* 22 u */
    KB_ASCII,  "i",      "I",      "\011",   "",       "",  /* 23 i */
    KB_ASCII,  "o",      "O",      "\017",   "",       "",  /* 24 o */
    KB_ASCII,  "p",      "P",      "\020",   "",       "",  /* 25 p */
    KB_ASCII,  "[",      "{",      "\033",   "",       "",  /* 26 [ */
    KB_ASCII,  "]",      "}",      "\035",   "",       "",  /* 27 ] */
    KB_ASCII,  "\r",     "\r",     "\n",     "",       "",  /* 28 return */
    KB_CTL,    "",       "",       "",       "",       "",  /* 29 control */
    KB_ASCII,  "a",      "A",      "\001",   "",       "",  /* 30 a */
    KB_ASCII,  "s",      "S",      "\023",   "",       "",  /* 31 s */
    KB_ASCII,  "d",      "D",      "\004",   "",       "",  /* 32 d */
    KB_ASCII,  "f",      "F",      "\006",   "",       "",  /* 33 f */
    KB_ASCII,  "g",      "G",      "\007",   "",       "",  /* 34 g */
    KB_ASCII,  "h",      "H",      "\010",   "",       "",  /* 35 h */
    KB_ASCII,  "j",      "J",      "\n",     "",       "",  /* 36 j */
    KB_ASCII,  "k",      "K",      "\013",   "",       "",  /* 37 k */
    KB_ASCII,  "l",      "L",      "\014",   "",       "",  /* 38 l */
    KB_ASCII,  ";",      ":",      ";",      "",       "",  /* 39 ; */
    KB_ASCII,  "'",      "\"",     "'",      "",       "",  /* 40 ' */
    KB_ASCII,  "`",      "~",      "`",      "",       "",  /* 41 ` */
    KB_SHIFT,  "\001",   "",       "",       "",       "",  /* 42 shift */
    KB_ASCII,  "\\",     "|",      "\034",   "",       "",  /* 43 \ */
    KB_ASCII,  "z",      "Z",      "\032",   "",       "",  /* 44 z */
    KB_ASCII,  "x",      "X",      "\030",   "",       "",  /* 45 x */
    KB_ASCII,  "c",      "C",      "\003",   "",       "",  /* 46 c */
    KB_ASCII,  "v",      "V",      "\026",   "",       "",  /* 47 v */
    KB_ASCII,  "b",      "B",      "\002",   "",       "",  /* 48 b */
    KB_ASCII,  "n",      "N",      "\016",   "",       "",  /* 49 n */
    KB_ASCII,  "m",      "M",      "\r",     "",       "",  /* 50 m */
    KB_ASCII,  ",",      "<",      "<",      "",       "",  /* 51 , */
    KB_ASCII,  ".",      ">",      ">",      "",       "",  /* 52 . */
    KB_ASCII,  "/",      "?",      "\037",   "",       "",  /* 53 / */
    KB_SHIFT,  "\002",   "",       "",       "",       "",  /* 54 shift */
    KB_KP,     "*",      "*",      "*",      "",       "",  /* 55 kp * */
    KB_ALT,    "",       "",       "",       "",       "",  /* 56 alt */
    KB_ASCII,  " ",      " ",      "\000",   "",       "",  /* 57 space */
    KB_CAPS,   "",       "",       "",       "",       "",  /* 58 caps */
    KB_FUNC,   "\033[M", "\033[Y", "\033[k", "",       "",  /* 59 f1 */
    KB_FUNC,   "\033[N", "\033[Z", "\033[l", "",       "",  /* 60 f2 */
    KB_FUNC,   "\033[O", "\033[a", "\033[m", "",       "",  /* 61 f3 */
    KB_FUNC,   "\033[P", "\033[b", "\033[n", "",       "",  /* 62 f4 */
    KB_FUNC,   "\033[Q", "\033[c", "\033[o", "",       "",  /* 63 f5 */
    KB_FUNC,   "\033[R", "\033[d", "\033[p", "",       "",  /* 64 f6 */
    KB_FUNC,   "\033[S", "\033[e", "\033[q", "",       "",  /* 65 f7 */
    KB_FUNC,   "\033[T", "\033[f", "\033[r", "",       "",  /* 66 f8 */
    KB_FUNC,   "\033[U", "\033[g", "\033[s", "",       "",  /* 67 f9 */
    KB_FUNC,   "\033[V", "\033[h", "\033[t", "",       "",  /* 68 f10 */
    KB_NUM,    "",       "",       "",       "",       "",  /* 69 num lock */
    KB_SCROLL, "",       "",       "",       "",       "",  /* 70 scroll lock */
    KB_KP,     "7",      "\033[H", "7",      "",       "",  /* 71 kp 7 */
    KB_KP,     "8",      "\033[A", "8",      "",       "",  /* 72 kp 8 */
    KB_KP,     "9",      "\033[I", "9",      "",       "",  /* 73 kp 9 */
    KB_KP,     "-",      "-",      "-",      "",       "",  /* 74 kp - */
    KB_KP,     "4",      "\033[D", "4",      "",       "",  /* 75 kp 4 */
    KB_KP,     "5",      "\033[E", "5",      "",       "",  /* 76 kp 5 */
    KB_KP,     "6",      "\033[C", "6",      "",       "",  /* 77 kp 6 */
    KB_KP,     "+",      "+",      "+",      "",       "",  /* 78 kp + */
    KB_KP,     "1",      "\033[F", "1",      "",       "",  /* 79 kp 1 */
    KB_KP,     "2",      "\033[B", "2",      "",       "",  /* 80 kp 2 */
    KB_KP,     "3",      "\033[G", "3",      "",       "",  /* 81 kp 3 */
    KB_KP,     "0",      "\033[L", "0",      "",       "",  /* 82 kp 0 */
    KB_KP,     ",",      "\177",   ",",      "",       "",  /* 83 kp , */
    KB_NONE,   "",       "",       "",       "",       "",  /* 84 0 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 85 0 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 86 0 */
    KB_FUNC,   "\033[W", "\033[i", "\033[u", "",       "",  /* 87 f11 */
    KB_FUNC,   "\033[X", "\033[j", "\033[v", "",       "",  /* 88 f12 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 89 0 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 90 0 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 91 0 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 92 0 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 93 0 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 94 0 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 95 0 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 96 0 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 97 0 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 98 0 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 99 0 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 100 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 101 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 102 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 103 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 104 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 105 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 106 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 107 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 108 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 109 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 110 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 111 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 112 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 113 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 114 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 115 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 116 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 117 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 118 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 119 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 120 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 121 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 122 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 123 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 124 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 125 */
    KB_NONE,   "",       "",       "",       "",       "",  /* 126 */
    KB_NONE,   "",       "",       "",       "",       ""   /* 127 */
@


1.28
log
@remove keyboard randomness supply.
not needed w/ adition of tty randomness.
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.27 1996/09/01 19:40:56 deraadt Exp $	*/
d71 1
d313 4
a316 6
	register int iobase = addr_6845;

	outb(iobase, 10);
	outb(iobase+1, cursor_shape >> 8);
	outb(iobase, 11);
	outb(iobase+1, cursor_shape);
d324 4
a327 6
	register int iobase = addr_6845;

	outb(iobase, 10);
	cursor_shape = inb(iobase+1) << 8;
	outb(iobase, 11);
	cursor_shape |= inb(iobase+1);
d378 1
a378 1
		outb(iobase, 14);
d380 1
a380 1
		outb(iobase, 15);
d908 1
a908 1
	outb(addr_6845, 14);
d910 1
a910 1
	outb(addr_6845, 15);
@


1.27
log
@distinguish between left/right shift keys for X; from Mathieu.Herrb@@mipnet.fr
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.26 1996/09/01 16:39:59 deraadt Exp $	*/
a72 5

#include "random.h"
#if NRANDOM > 0
#include <dev/rndvar.h>
#endif
@


1.26
log
@change keymap_t to pccons_keymap_t in pccons
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.25 1996/08/29 09:26:08 deraadt Exp $	*/
d1444 2
d1490 1
a1490 1
    KB_SHIFT,  "",       "",       "",       "",       "",  /* 42 shift */
d1502 1
a1502 1
    KB_SHIFT,  "",       "",       "",       "",       "",  /* 54 shift */
@


1.25
log
@rnd -> random
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.24 1996/08/28 11:21:06 deraadt Exp $	*/
d100 1
a100 1
static keymap_t	scan_codes[KB_NUM_KEYS];/* keyboard translation table */
d708 1
a708 1
		keymap_t *map = (keymap_t *) data;
d721 1
a721 1
		bcopy(data,scan_codes,sizeof(keymap_t[KB_NUM_KEYS]));
d727 1
a727 1
		bcopy(scan_codes,data,sizeof(keymap_t[KB_NUM_KEYS]));
d1444 1
a1444 1
static keymap_t	scan_codes[KB_NUM_KEYS] = {
@


1.24
log
@kill keyboard randomness; it causes random problems
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.23 1996/08/27 07:32:04 deraadt Exp $	*/
d74 2
a75 2
#include "rnd.h"
#if NRND > 0
@


1.23
log
@do not lose in 2 cases; from graichen
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.22 1996/08/10 21:28:20 tholo Exp $	*/
d535 1
d543 1
d549 1
a1588 4

#if NRND > 0
	add_keyboard_randomness(dt);
#endif
@


1.22
log
@Support entropy generation for keyboard generation; already done for PCVT
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.21 1996/07/19 23:00:08 dm Exp $	*/
d434 1
d436 1
a436 1
		goto lose;
d444 1
d446 1
a446 1
		goto lose;
@


1.21
log
@Got rid of blinking square in the screen saver (it prevented fancy monitors
from going into power-saving mode).
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.20 1996/07/16 10:58:34 deraadt Exp $	*/
d74 5
d1584 4
@


1.20
log
@pcvt/pccons too fast for some kbds; netbsd pr#2631; mike.long@@analog.com
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.19 1996/06/25 18:32:03 tholo Exp $	*/
d984 1
d988 1
@


1.19
log
@Implement save/restore cursor position; new curses uses it
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.18 1996/06/16 13:41:34 deraadt Exp $	*/
d175 1
d177 4
@


1.18
log
@leave code out if not XSERVER; netbsd pr#2528; mike.long@@analog.com
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.17 1996/06/16 13:39:32 deraadt Exp $	*/
d106 1
d1032 4
d1049 1
a1049 1
		case '\010':
d1102 26
a1127 13
				if (c == '[') {	/* Start ESC [ sequence */
					vs.cx = vs.cy = 0;
					vs.state = VSS_EBRACE;
				} else if (c == 'c') { /* Clear screen & home */
					fillw((vs.at << 8) | ' ',
					    Crtat, vs.nchr);
					crtat = Crtat;
					vs.col = 0;
					vs.state = 0;
				} else { /* Invalid, clear state */
					wrtchar(c, vs.so_at); 
					vs.state = 0;
					goto maybe_scroll;
d1348 10
@


1.17
log
@init properly incaseof COMCONSOLE; netbsd pr#2510; enami@@ba2.so-net.or.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.16 1996/06/10 07:35:35 deraadt Exp $	*/
d96 1
d98 1
d144 1
d147 1
d156 1
d158 1
d315 1
d338 1
d367 1
d370 1
d655 1
d674 1
d818 1
d821 1
d1010 1
d1013 1
d1554 1
d1608 1
d1773 1
d1816 1
@


1.16
log
@tty_attach()
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.15 1996/05/25 22:17:51 deraadt Exp $	*/
d139 1
d484 3
d865 46
d999 2
a1000 43
	if (crtat == 0) {
		u_short volatile *cp;
		u_short was;
		unsigned cursorat;

		cp = ISA_HOLE_VADDR(CGA_BUF);
		was = *cp;
		*cp = (u_short) 0xA55A;
		if (*cp != 0xA55A) {
			cp = ISA_HOLE_VADDR(MONO_BUF);
			addr_6845 = MONO_BASE;
			vs.color = 0;
		} else {
			*cp = was;
			addr_6845 = CGA_BASE;
			vs.color = 1;
		}

		/* Extract cursor location */
		outb(addr_6845, 14);
		cursorat = inb(addr_6845+1) << 8;
		outb(addr_6845, 15);
		cursorat |= inb(addr_6845+1);

#ifdef FAT_CURSOR
		cursor_shape = 0x0012;
#endif

		Crtat = (u_short *)cp;
		crtat = (u_short *)(cp + cursorat);

		vs.ncol = COL;
		vs.nrow = ROW;
		vs.nchr = COL * ROW;
		vs.at = FG_LIGHTGREY | BG_BLACK;

		if (vs.color == 0)
			vs.so_at = FG_BLACK | BG_LIGHTGREY;
		else
			vs.so_at = FG_YELLOW | BG_BLACK;

		fillw((vs.at << 8) | ' ', crtat, vs.nchr - cursorat);
	}
@


1.15
log
@sync
@
text
@d1 2
a2 2
/*	$OpenBSD: pccons.c,v 1.14 1996/05/10 12:46:20 deraadt Exp $	*/
/*	$NetBSD: pccons.c,v 1.99 1996/05/12 23:12:33 mycroft Exp $	*/
d515 1
a515 1
	if (!sc->sc_tty)
d517 2
a518 1
	else
@


1.14
log
@simple cleanup
@
text
@d1 2
a2 2
/*	$OpenBSD: pccons.c,v 1.13 1996/05/09 14:19:47 deraadt Exp $	*/
/*	$NetBSD: pccons.c,v 1.98 1996/05/05 19:48:15 christos Exp $	*/
d63 1
@


1.13
log
@shift-tab does tab, not some confusing gobbledygook
@
text
@d1 2
a2 2
/*	$OpenBSD: pccons.c,v 1.9 1996/04/22 20:12:16 hannken Exp $	*/
/*	$NetBSD: pccons.c,v 1.97 1996/05/03 19:15:00 christos Exp $	*/
d988 1
a988 1
		fillw((vs.at << 8) | ' ', (caddr_t) crtat, vs.nchr - cursorat);
d1075 1
a1075 1
					    (caddr_t) Crtat, vs.nchr);
d1166 1
a1166 1
						    (caddr_t) crtat,
d1172 1
a1172 2
						    (caddr_t) Crtat,
						    crtat - Crtat + 1);
d1177 1
a1177 2
						    (caddr_t) Crtat,
						    vs.nchr);
d1187 1
a1187 2
						    (caddr_t) crtat,
						    vs.ncol - vs.col);
d1192 1
a1192 2
						    (caddr_t) (crtat - vs.col),
						    vs.col + 1);
d1197 1
a1197 2
						    (caddr_t) (crtat - vs.col),
						    vs.ncol);
d1235 1
a1235 1
					    (caddr_t) (crtAt + vs.ncol * (nrow - cx)),
d1251 1
a1251 1
					    (caddr_t) (Crtat + vs.ncol * (vs.nrow - cx)),
d1274 1
a1274 2
					    (caddr_t) crtAt,
					    vs.ncol * cx);
d1290 1
a1290 2
					    (caddr_t) Crtat,
					    vs.ncol * cx);
d1356 1
a1356 1
						tsleep((caddr_t)&lock_state,
d1363 1
a1363 1
				    (caddr_t) (Crtat + vs.nchr - vs.ncol),
d1574 1
a1574 1
				wakeup((caddr_t)&lock_state);
d1659 1
a1659 1
				wakeup((caddr_t)&lock_state);
@


1.12
log
@sync with 0504; prototype changes
@
text
@d1396 1
a1396 1
    KB_ASCII,  "\t",     "\177\t", "\t",     "",       "",  /* 15 tab */
@


1.11
log
@This is no longer donatate data for rnd device.
@
text
@d2 1
a2 1
/*	$NetBSD: pccons.c,v 1.96 1996/04/11 22:15:25 cgd Exp $	*/
a48 1
#include <sys/conf.h>
d66 1
d143 3
a145 2
void	pcstart();
int	pcparam();
d148 17
a164 1
extern pcopen(dev_t, int, int, struct proc *);
d167 4
a170 4
	{ u_char x = inb(0x84); } \
	{ u_char x = inb(0x84); } \
	{ u_char x = inb(0x84); } \
	{ u_char x = inb(0x84); }
d172 1
a172 1
static inline int
d185 1
a185 1
static inline int
d198 1
a198 1
static inline void
d331 2
a332 2
do_async_update(poll)
	u_char poll;
d334 1
d380 1
a380 1
		do_async_update(1);
d483 1
a483 1
	do_async_update(1);
d709 1
a709 1
	int s, len, n;
d741 1
a741 1
void
d746 1
a746 1

d988 1
a988 1
		fillw((vs.at << 8) | ' ', crtat, vs.nchr - cursorat);
a1035 1
		bypass:
d1074 2
a1075 2
					fillw((vs.at << 8) | ' ', Crtat,
					    vs.nchr);
d1165 2
a1166 1
						fillw((vs.at << 8) | ' ', crtat,
d1171 2
a1172 1
						fillw((vs.at << 8) | ' ', Crtat,
d1177 2
a1178 1
						fillw((vs.at << 8) | ' ', Crtat,
d1188 2
a1189 1
						fillw((vs.at << 8) | ' ', crtat,
d1195 1
a1195 1
						    crtat - vs.col,
d1201 2
a1202 1
						    crtat - vs.col, vs.ncol);
d1240 1
a1240 1
					    crtAt + vs.ncol * (nrow - cx),
d1256 1
a1256 1
					    Crtat + vs.ncol * (vs.nrow - cx),
d1258 3
a1260 1
					/* crtat -= vs.ncol * cx; /* XXX */
d1278 2
a1279 1
					fillw((vs.at << 8) | ' ', crtAt,
d1295 2
a1296 1
					fillw((vs.at << 8) | ' ', Crtat,
d1298 3
a1300 1
					/* crtat += vs.ncol * cx; /* XXX */
d1370 2
a1371 1
				    Crtat + vs.nchr - vs.ncol, vs.ncol);
@


1.10
log
@Reorder includes.
@
text
@a72 5
#include "rnd.h"
#if	NRND
#include <dev/rndvar.h>
#endif

a1503 4

#if	NRND
	add_keyboard_randomness(dt);
#endif
@


1.9
log
@add ioctls to change keymap encoding, screen saver and partial latin1 output
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.8 1996/04/21 22:17:01 deraadt Exp $	*/
d48 1
a56 1
#include <sys/systm.h>
@


1.8
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: pccons.c,v 1.7 1996/04/18 17:12:18 niklas Exp $	*/
d99 1
d127 1
a140 15
/*
 * DANGER WIL ROBINSON -- the values of SCROLL, NUM, CAPS, and ALT are
 * important.
 */
#define	SCROLL		0x0001	/* stop output */
#define	NUM		0x0002	/* numeric shift  cursors vs. numeric */
#define	CAPS		0x0004	/* caps shift -- swaps case of letter */
#define	SHIFT		0x0008	/* keyboard shift */
#define	CTL		0x0010	/* control shift  -- allows ctl function */
#define	ASCII		0x0020	/* ascii code for this key */
#define	ALT		0x0080	/* alternate shift -- alternate chars */
#define	FUNC		0x0100	/* function key */
#define	KP		0x0200	/* Keypad keys */
#define	NONE		0x0400	/* no function */

d471 1
d660 22
d862 60
d1040 2
d1339 1
a1339 1
					if (lock_state & SCROLL)
d1355 130
a1484 137
#define	CODE_SIZE	4		/* Use a max of 4 for now... */
typedef struct {
	u_short	type;
	char unshift[CODE_SIZE];
	char shift[CODE_SIZE];
	char ctl[CODE_SIZE];
} Scan_def;

static Scan_def	scan_codes[] = {
	NONE,	"",		"",		"",		/* 0 unused */
	ASCII,	"\033",		"\033",		"\033",		/* 1 ESCape */
	ASCII,	"1",		"!",		"!",		/* 2 1 */
	ASCII,	"2",		"@@",		"\000",		/* 3 2 */
	ASCII,	"3",		"#",		"#",		/* 4 3 */
	ASCII,	"4",		"$",		"$",		/* 5 4 */
	ASCII,	"5",		"%",		"%",		/* 6 5 */
	ASCII,	"6",		"^",		"\036",		/* 7 6 */
	ASCII,	"7",		"&",		"&",		/* 8 7 */
	ASCII,	"8",		"*",		"\010",		/* 9 8 */
	ASCII,	"9",		"(",		"(",		/* 10 9 */
	ASCII,	"0",		")",		")",		/* 11 0 */
	ASCII,	"-",		"_",		"\037",		/* 12 - */
	ASCII,	"=",		"+",		"+",		/* 13 = */
	ASCII,	"\177",		"\177",		"\010",		/* 14 backspace */
	ASCII,	"\t",		"\177\t",	"\t",		/* 15 tab */
	ASCII,	"q",		"Q",		"\021",		/* 16 q */
	ASCII,	"w",		"W",		"\027",		/* 17 w */
	ASCII,	"e",		"E",		"\005",		/* 18 e */
	ASCII,	"r",		"R",		"\022",		/* 19 r */
	ASCII,	"t",		"T",		"\024",		/* 20 t */
	ASCII,	"y",		"Y",		"\031",		/* 21 y */
	ASCII,	"u",		"U",		"\025",		/* 22 u */
	ASCII,	"i",		"I",		"\011",		/* 23 i */
	ASCII,	"o",		"O",		"\017",		/* 24 o */
	ASCII,	"p",		"P",		"\020",		/* 25 p */
	ASCII,	"[",		"{",		"\033",		/* 26 [ */
	ASCII,	"]",		"}",		"\035",		/* 27 ] */
	ASCII,	"\r",		"\r",		"\n",		/* 28 return */
	CTL,	"",		"",		"",		/* 29 control */
	ASCII,	"a",		"A",		"\001",		/* 30 a */
	ASCII,	"s",		"S",		"\023",		/* 31 s */
	ASCII,	"d",		"D",		"\004",		/* 32 d */
	ASCII,	"f",		"F",		"\006",		/* 33 f */
	ASCII,	"g",		"G",		"\007",		/* 34 g */
	ASCII,	"h",		"H",		"\010",		/* 35 h */
	ASCII,	"j",		"J",		"\n",		/* 36 j */
	ASCII,	"k",		"K",		"\013",		/* 37 k */
	ASCII,	"l",		"L",		"\014",		/* 38 l */
	ASCII,	";",		":",		";",		/* 39 ; */
	ASCII,	"'",		"\"",		"'",		/* 40 ' */
	ASCII,	"`",		"~",		"`",		/* 41 ` */
	SHIFT,	"",		"",		"",		/* 42 shift */
	ASCII,	"\\",		"|",		"\034",		/* 43 \ */
	ASCII,	"z",		"Z",		"\032",		/* 44 z */
	ASCII,	"x",		"X",		"\030",		/* 45 x */
	ASCII,	"c",		"C",		"\003",		/* 46 c */
	ASCII,	"v",		"V",		"\026",		/* 47 v */
	ASCII,	"b",		"B",		"\002",		/* 48 b */
	ASCII,	"n",		"N",		"\016",		/* 49 n */
	ASCII,	"m",		"M",		"\r",		/* 50 m */
	ASCII,	",",		"<",		"<",		/* 51 , */
	ASCII,	".",		">",		">",		/* 52 . */
	ASCII,	"/",		"?",		"\037",		/* 53 / */
	SHIFT,	"",		"",		"",		/* 54 shift */
	KP,	"*",		"*",		"*",		/* 55 kp * */
	ALT,	"",		"",		"",		/* 56 alt */
	ASCII,	" ",		" ",		"\000",		/* 57 space */
	CAPS,	"",		"",		"",		/* 58 caps */
	FUNC,	"\033[M",	"\033[Y",	"\033[k",	/* 59 f1 */
	FUNC,	"\033[N",	"\033[Z",	"\033[l",	/* 60 f2 */
	FUNC,	"\033[O",	"\033[a",	"\033[m",	/* 61 f3 */
	FUNC,	"\033[P",	"\033[b",	"\033[n",	/* 62 f4 */
	FUNC,	"\033[Q",	"\033[c",	"\033[o",	/* 63 f5 */
	FUNC,	"\033[R",	"\033[d",	"\033[p",	/* 64 f6 */
	FUNC,	"\033[S",	"\033[e",	"\033[q",	/* 65 f7 */
	FUNC,	"\033[T",	"\033[f",	"\033[r",	/* 66 f8 */
	FUNC,	"\033[U",	"\033[g",	"\033[s",	/* 67 f9 */
	FUNC,	"\033[V",	"\033[h",	"\033[t",	/* 68 f10 */
	NUM,	"",		"",		"",		/* 69 num lock */
	SCROLL,	"",		"",		"",		/* 70 scroll lock */
	KP,	"7",		"\033[H",	"7",		/* 71 kp 7 */
	KP,	"8",		"\033[A",	"8",		/* 72 kp 8 */
	KP,	"9",		"\033[I",	"9",		/* 73 kp 9 */
	KP,	"-",		"-",		"-",		/* 74 kp - */
	KP,	"4",		"\033[D",	"4",		/* 75 kp 4 */
	KP,	"5",		"\033[E",	"5",		/* 76 kp 5 */
	KP,	"6",		"\033[C",	"6",		/* 77 kp 6 */
	KP,	"+",		"+",		"+",		/* 78 kp + */
	KP,	"1",		"\033[F",	"1",		/* 79 kp 1 */
	KP,	"2",		"\033[B",	"2",		/* 80 kp 2 */
	KP,	"3",		"\033[G",	"3",		/* 81 kp 3 */
	KP,	"0",		"\033[L",	"0",		/* 82 kp 0 */
	KP,	".",		"\177",		".",		/* 83 kp . */
	NONE,	"",		"",		"",		/* 84 0 */
	NONE,	"100",		"",		"",		/* 85 0 */
	NONE,	"101",		"",		"",		/* 86 0 */
	FUNC,	"\033[W",	"\033[i",	"\033[u",	/* 87 f11 */
	FUNC,	"\033[X",	"\033[j",	"\033[v",	/* 88 f12 */
	NONE,	"102",		"",		"",		/* 89 0 */
	NONE,	"103",		"",		"",		/* 90 0 */
	NONE,	"",		"",		"",		/* 91 0 */
	NONE,	"",		"",		"",		/* 92 0 */
	NONE,	"",		"",		"",		/* 93 0 */
	NONE,	"",		"",		"",		/* 94 0 */
	NONE,	"",		"",		"",		/* 95 0 */
	NONE,	"",		"",		"",		/* 96 0 */
	NONE,	"",		"",		"",		/* 97 0 */
	NONE,	"",		"",		"",		/* 98 0 */
	NONE,	"",		"",		"",		/* 99 0 */
	NONE,	"",		"",		"",		/* 100 */
	NONE,	"",		"",		"",		/* 101 */
	NONE,	"",		"",		"",		/* 102 */
	NONE,	"",		"",		"",		/* 103 */
	NONE,	"",		"",		"",		/* 104 */
	NONE,	"",		"",		"",		/* 105 */
	NONE,	"",		"",		"",		/* 106 */
	NONE,	"",		"",		"",		/* 107 */
	NONE,	"",		"",		"",		/* 108 */
	NONE,	"",		"",		"",		/* 109 */
	NONE,	"",		"",		"",		/* 110 */
	NONE,	"",		"",		"",		/* 111 */
	NONE,	"",		"",		"",		/* 112 */
	NONE,	"",		"",		"",		/* 113 */
	NONE,	"",		"",		"",		/* 114 */
	NONE,	"",		"",		"",		/* 115 */
	NONE,	"",		"",		"",		/* 116 */
	NONE,	"",		"",		"",		/* 117 */
	NONE,	"",		"",		"",		/* 118 */
	NONE,	"",		"",		"",		/* 119 */
	NONE,	"",		"",		"",		/* 120 */
	NONE,	"",		"",		"",		/* 121 */
	NONE,	"",		"",		"",		/* 122 */
	NONE,	"",		"",		"",		/* 123 */
	NONE,	"",		"",		"",		/* 124 */
	NONE,	"",		"",		"",		/* 125 */
	NONE,	"",		"",		"",		/* 126 */
	NONE,	"",		"",		"",		/* 127 */
d1529 1
a1529 1
		case NUM:
d1531 1
a1531 1
				shift_state &= ~NUM;
d1534 1
a1534 1
			if (shift_state & NUM)
d1536 2
a1537 2
			shift_state |= NUM;
			lock_state ^= NUM;
d1540 1
a1540 1
		case CAPS:
d1542 1
a1542 1
				shift_state &= ~CAPS;
d1545 1
a1545 1
			if (shift_state & CAPS)
d1547 2
a1548 2
			shift_state |= CAPS;
			lock_state ^= CAPS;
d1551 1
a1551 1
		case SCROLL:
d1553 1
a1553 1
				shift_state &= ~SCROLL;
d1556 1
a1556 1
			if (shift_state & SCROLL)
d1558 3
a1560 3
			shift_state |= SCROLL;
			lock_state ^= SCROLL;
			if ((lock_state & SCROLL) == 0)
d1578 2
a1579 1
	if ((dt == 1) && (shift_state & (CTL | ALT)) == (CTL | ALT)) {
d1585 2
d1596 2
a1597 2
		case NUM:
			shift_state &= ~NUM;
d1599 2
a1600 2
		case CAPS:
			shift_state &= ~CAPS;
d1602 2
a1603 2
		case SCROLL:
			shift_state &= ~SCROLL;
d1605 2
a1606 2
		case SHIFT:
			shift_state &= ~SHIFT;
d1608 5
a1612 2
		case ALT:
			shift_state &= ~ALT;
d1614 2
a1615 2
		case CTL:
			shift_state &= ~CTL;
d1626 2
a1627 2
		case NUM:
			if (shift_state & NUM)
d1629 2
a1630 2
			shift_state |= NUM;
			lock_state ^= NUM;
d1633 2
a1634 2
		case CAPS:
			if (shift_state & CAPS)
d1636 2
a1637 2
			shift_state |= CAPS;
			lock_state ^= CAPS;
d1640 2
a1641 2
		case SCROLL:
			if (shift_state & SCROLL)
d1643 3
a1645 3
			shift_state |= SCROLL;
			lock_state ^= SCROLL;
			if ((lock_state & SCROLL) == 0)
d1652 2
a1653 2
		case SHIFT:
			shift_state |= SHIFT;
d1655 5
a1659 2
		case ALT:
			shift_state |= ALT;
d1661 2
a1662 2
		case CTL:
			shift_state |= CTL;
d1664 1
a1664 1
		case ASCII:
d1666 1
a1666 1
			if (shift_state & CTL)
d1668 12
a1679 5
			else if (shift_state & SHIFT)
				capchar[0] = scan_codes[dt].shift[0];
			else
				capchar[0] = scan_codes[dt].unshift[0];
			if ((lock_state & CAPS) && capchar[0] >= 'a' &&
d1683 1
a1683 1
			capchar[0] |= (shift_state & ALT);
d1686 1
a1686 1
		case NONE:
d1688 1
a1688 1
		case FUNC: {
d1690 1
a1690 1
			if (shift_state & SHIFT)
d1692 1
a1692 1
			else if (shift_state & CTL)
d1699 1
a1699 1
		case KP: {
d1701 2
a1702 2
			if (shift_state & (SHIFT | CTL) ||
			    (lock_state & NUM) == 0 || extended)
d1739 1
d1768 1
@


1.7
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD: pccons.c,v 1.6 1996/03/29 12:05:39 mickey Exp $	*/
/*	$NetBSD: pccons.c,v 1.92 1996/03/16 06:08:46 thorpej Exp $	*/
d127 6
a132 2
struct cfdriver pccd = {
	NULL, "pc", pcprobe, pcattach, DV_TTY, sizeof(struct pc_softc)
d158 2
d485 2
a486 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_TTY, pcintr,
	    sc, sc->sc_dev.dv_xname);
d493 1
a493 1
	while (config_found(self, NULL, NULL))
d507 1
a507 1
	if (unit >= pccd.cd_ndevs)
d509 1
a509 1
	sc = pccd.cd_devs[unit];
d544 1
a544 1
	struct pc_softc *sc = pccd.cd_devs[PCUNIT(dev)];
d561 1
a561 1
	struct pc_softc *sc = pccd.cd_devs[PCUNIT(dev)];
d573 1
a573 1
	struct pc_softc *sc = pccd.cd_devs[PCUNIT(dev)];
d583 1
a583 1
	struct pc_softc *sc = pccd.cd_devs[PCUNIT(dev)];
d626 1
a626 1
	struct pc_softc *sc = pccd.cd_devs[PCUNIT(dev)];
d771 1
d810 2
a811 2
		if (pccd.cd_ndevs > unit) {
			sc = pccd.cd_devs[unit];
d1650 1
d1672 1
@


1.6
log
@Initial commit of random source driver.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: pccons.c,v 1.91 1995/12/24 02:30:25 mycroft Exp $	*/
d481 8
@


1.5
log
@Fix back wrong patches.
@
text
@d1 1
d73 5
d1429 4
@


1.4
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d474 1
a474 1
	    sc);
@


1.3
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 1
a1 1
/*	$NetBSD: pccons.c,v 1.90 1995/10/11 04:20:33 mycroft Exp $	*/
d474 1
a474 1
	    sc, sc->sc_dev.dv_xname);
@


1.2
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
@
text
@d474 1
a474 1
	    sc);
@


1.1
log
@Initial revision
@
text
@d473 2
a474 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE, ISA_IPL_TTY,
	    pcintr, sc);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

