head	1.33;
access;
symbols
	OPENBSD_6_0:1.33.0.6
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.33.0.4
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.31.0.14
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.18
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.16
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.12
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.10
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.8
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.6
	OPENBSD_5_0:1.31.0.4
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.29.0.6
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.8
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.4
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.25.0.4
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.23.0.6
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.4
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.22.0.4
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.18.0.8
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.6
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.4
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.18
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.12.0.6
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.2
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.6
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.8.0.4
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.33
date	2015.07.16.05.10.14;	author guenther;	state Exp;
branches;
next	1.32;
commitid	vUE3LzynpntlHxEC;

1.32
date	2015.06.28.01.11.27;	author guenther;	state Exp;
branches;
next	1.31;
commitid	pmt8zLCdl4eF6ZNV;

1.31
date	2010.12.21.14.56.23;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2010.05.09.12.03.16;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2008.05.21.18.49.47;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2008.05.07.20.42.02;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2008.04.26.14.33.27;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2008.04.25.19.50.08;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.25.21.27.15;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.12.20.22.58;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2005.12.13.16.14.49;	author aaron;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.07.02.03.17;	author pascoe;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.13.21.49.16;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	2003.11.06.21.09.34;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.17.03.42.14;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.04.00.00.36;	author niklas;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.11.18.20.46.49;	author aaron;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.12.20.28.20;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.08.20.01.52;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.21.20.54.32;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.08.11.34.23;	author art;	state Exp;
branches;
next	1.12;

1.12
date	99.12.08.06.50.15;	author itojun;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	99.05.24.23.09.01;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	99.01.07.23.15.58;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.07.23.06.58.34;	author denny;	state Exp;
branches;
next	1.8;

1.8
date	96.08.16.02.54.02;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.08.16.02.51.31;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.28.05.07.05;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.07.07.00.05.48;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.06.30.21.43.42;	author chuck;	state Exp;
branches;
next	1.3;

1.3
date	96.04.30.21.54.40;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.01.08.09.33.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.37;	author deraadt;	state Exp;
branches;
next	;

1.12.2.1
date	2001.04.18.16.07.52;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2001.07.14.10.02.42;	author ho;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2001.07.14.13.40.45;	author ho;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2001.10.27.09.57.31;	author niklas;	state Exp;
branches;
next	1.12.2.5;

1.12.2.5
date	2001.10.28.08.16.45;	author niklas;	state Exp;
branches;
next	1.12.2.6;

1.12.2.6
date	2001.10.30.19.21.17;	author niklas;	state Exp;
branches;
next	1.12.2.7;

1.12.2.7
date	2001.10.30.19.37.04;	author niklas;	state Exp;
branches;
next	1.12.2.8;

1.12.2.8
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.12.2.9;

1.12.2.9
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.12.2.10;

1.12.2.10
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.12.2.11;

1.12.2.11
date	2003.05.13.19.42.08;	author ho;	state Exp;
branches;
next	1.12.2.12;

1.12.2.12
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.12.2.13;

1.12.2.13
date	2003.05.17.19.22.39;	author niklas;	state Exp;
branches;
next	1.12.2.14;

1.12.2.14
date	2003.05.22.09.11.56;	author niklas;	state Exp;
branches;
next	1.12.2.15;

1.12.2.15
date	2003.05.25.19.24.32;	author ho;	state Exp;
branches;
next	1.12.2.16;

1.12.2.16
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	1.12.2.17;

1.12.2.17
date	2004.06.06.18.40.47;	author grange;	state Exp;
branches;
next	1.12.2.18;

1.12.2.18
date	2004.06.10.11.40.25;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Move grab/release of the kernel_lock for softintrs from the ASM stubs to
softintr_dispatch().  Delete traces of long superseded stats code.

ok beck@@ mpi@@ uebayasi@@
@
text
@/*	$OpenBSD: icu.s,v 1.32 2015/06/28 01:11:27 guenther Exp $	*/
/*	$NetBSD: icu.s,v 1.45 1996/01/07 03:59:34 mycroft Exp $	*/

/*-
 * Copyright (c) 1993, 1994, 1995 Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

	.data
	.globl	_C_LABEL(imen)
_C_LABEL(imen):
	.long	0xffff		# interrupt mask enable (all off)

	.text
/*
 * Process pending interrupts.
 *
 * Important registers:
 *   ebx - cpl
 *   esi - address to resume loop at
 *   edi - scratch for Xsoftnet
 */
IDTVEC(spllower)
	pushl	%ebx
	pushl	%esi
	pushl	%edi
	movl	CPL,%ebx		# save priority
	movl	$1f,%esi		# address to resume loop at
1:	movl	%ebx,%eax		# get cpl
	shrl	$4,%eax			# find its mask.
	movl	_C_LABEL(iunmask)(,%eax,4),%eax
	cli
	andl	CPUVAR(IPENDING),%eax	# any non-masked bits left?
	jz	2f
	sti
	bsfl	%eax,%eax
	btrl	%eax,CPUVAR(IPENDING)
	jnc	1b
	jmp	*_C_LABEL(Xrecurse)(,%eax,4)
2:	movl	%ebx,CPL
	sti
	popl	%edi
	popl	%esi
	popl	%ebx
	ret

/*
 * Handle return from interrupt after device handler finishes.
 *
 * Important registers:
 *   ebx - cpl to restore
 *   esi - address to resume loop at
 *   edi - scratch for Xsoftnet
 */
IDTVEC(doreti)
	popl	%ebx			# get previous priority
	movl	$1f,%esi		# address to resume loop at
1:	movl	%ebx,%eax
	shrl	$4,%eax
	movl	_C_LABEL(iunmask)(,%eax,4),%eax
	cli
	andl	CPUVAR(IPENDING),%eax
	jz	2f
	sti
	bsfl    %eax,%eax               # slow, but not worth optimizing
	btrl    %eax,CPUVAR(IPENDING)
	jnc     1b			# some intr cleared the in-memory bit
	cli
	jmp	*_C_LABEL(Xresume)(,%eax,4)
2:	/* Check for ASTs on exit to user mode. */
	CHECK_ASTPENDING(%ecx)
	movl	%ebx,CPL
	je	3f
	testb   $SEL_RPL,TF_CS(%esp)
#ifdef VM86
	jnz	4f
	testl	$PSL_VM,TF_EFLAGS(%esp)
#endif
	jz	3f
4:	CLEAR_ASTPENDING(%ecx)
	sti
	pushl	%esp
	call	_C_LABEL(ast)
	addl	$4,%esp
	cli
	jmp	2b
3:	INTRFASTEXIT


/*
 * Soft interrupt handlers
 */

IDTVEC(softtty)
	movl	$IPL_SOFTTTY,%eax
	movl	%eax,CPL
	sti
	pushl	$I386_SOFTINTR_SOFTTTY
	call	_C_LABEL(softintr_dispatch)
	addl	$4,%esp
	jmp	*%esi

IDTVEC(softnet)
	movl	$IPL_SOFTNET,%eax
	movl	%eax,CPL
	sti
	pushl	$I386_SOFTINTR_SOFTNET
	call	_C_LABEL(softintr_dispatch)
	addl	$4,%esp
	jmp	*%esi
#undef DONETISR

IDTVEC(softclock)
	movl	$IPL_SOFTCLOCK,%eax
	movl	%eax,CPL
	sti
	pushl	$I386_SOFTINTR_SOFTCLOCK
	call	_C_LABEL(softintr_dispatch)
	addl	$4,%esp
	jmp	*%esi

@


1.32
log
@Split AST handling from trap() into ast() and get rid of T_ASTFLT

testing by krw@@, and then many via snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.31 2010/12/21 14:56:23 claudio Exp $	*/
a121 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintlock)
#endif
a124 3
#ifdef MULTIPROCESSOR	
	call	_C_LABEL(i386_softintunlock)
#endif
a130 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintlock)
#endif
a133 3
#ifdef MULTIPROCESSOR	
	call	_C_LABEL(i386_softintunlock)
#endif
a140 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintlock)
#endif
a143 3
#ifdef MULTIPROCESSOR	
	call	_C_LABEL(i386_softintunlock)
#endif
@


1.31
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.30 2010/05/09 12:03:16 kettenis Exp $	*/
a105 2
	movl	$T_ASTFLT,TF_TRAPNO(%esp)	/* XXX undo later. */
	/* Pushed T_ASTFLT into tf_trapno on entry. */
d107 1
a107 1
	call	_C_LABEL(trap)
@


1.30
log
@Make i386 use a pointer to the trap frame like everybody else instead of
the weird "pass by reference" that causes problems with gcc4.

ok nicm@@, tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.29 2008/05/21 18:49:47 kettenis Exp $	*/
a32 2
#include <net/netisr.h>

d34 1
a34 1
	.globl	_C_LABEL(imen),_C_LABEL(netisr)
a36 2
_C_LABEL(netisr):
	.long	0		# scheduling bits for network
a134 7
#define DONETISR(s, c) \
	.globl  _C_LABEL(c)	;\
	testl	$(1 << s),%edi	;\
	jz	1f		;\
	call	_C_LABEL(c)	;\
1:

a141 5
	xorl	%edi,%edi
	xchgl	_C_LABEL(netisr),%edi

#include <net/netisr_dispatch.h>

@


1.29
log
@Switch i386 from pccom to com.  Welcomed by many.

ok dlg@@, jsing@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.28 2008/05/07 20:42:02 kettenis Exp $	*/
d112 1
d114 1
@


1.28
log
@Move i386 to __HAVE_GENERIC_SOFT_INTERRUPTS

ok dlg@@, tested by dlg@@, oga@@, jsg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.27 2008/04/26 14:33:27 kettenis Exp $	*/
a121 2
#include "pccom.h"

a122 1
#if NPCCOM > 0
d129 3
a131 1
	call	_C_LABEL(comsoft)
a133 1
#endif
@


1.27
log
@Remove softast; it's no longer used.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.26 2008/04/25 19:50:08 kettenis Exp $	*/
d155 1
d157 4
d174 3
a176 1
	call	_C_LABEL(softclock)
@


1.26
log
@Make ipending per-cpu.  Should fix PR 5788.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.25 2007/05/25 21:27:15 krw Exp $	*/
a122 6

IDTVEC(softast)
	movl	$IPL_SOFTAST,%eax
	movl	%eax,CPL
	sti
	jmp	*%esi
@


1.25
log
@"interupt" -> "interrupt" in various comments. Mostly from Diego Casati.
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.24 2007/04/12 20:22:58 art Exp $	*/
d36 1
a36 1
	.globl	_C_LABEL(imen),_C_LABEL(ipending),_C_LABEL(netisr)
a38 2
_C_LABEL(ipending):
	.long	0		# interrupts pending
d61 1
a61 1
	andl	_C_LABEL(ipending),%eax		# any non-masked bits left?
d65 1
a65 1
	btrl	%eax,_C_LABEL(ipending)
d90 1
a90 1
	andl	_C_LABEL(ipending),%eax
d94 1
a94 1
	btrl    %eax,_C_LABEL(ipending)
@


1.24
log
@Faster signal delivery on i386/MP.

We need to poke the other CPU so that it processes the AST immediately
and doesn't wait for the next interrupt or syscall.

Since IPIs really shouldn't process ASTs, we need to trigger a soft
interrupt on the destination CPU to process the AST. But since we can't
send soft interrupts to other CPUs, we send an IPI, that triggers a soft
interrupt that in turn processes the AST.

Also, this marks the beginning of moving to slightly better IPI mechanism
of short and optimized IPIs instead of the large and complicated IPI
infrastructure we're using now.

tested by many, ok tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.23 2005/12/13 16:14:49 aaron Exp $	*/
d40 1
a40 1
	.long	0		# interupts pending
@


1.23
log
@Prevent recursive interrupts.  Solves kernel stack overflow on i386 under
heavy network interrupt load (I can reproduce with an ARP flood) with an MP
kernel.  Patch from NetBSD PR20180.

Has been in snapshots for a bit.  Testing by pedro@@, jolan@@.  deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.22 2005/01/07 02:03:17 pascoe Exp $	*/
d125 6
@


1.22
log
@Fix profiled kernel builds on i386 by moving splraise/splx code into macros
permitting non-recursive reuse in mcount.

Should be a no-op for normal builds.
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.21 2004/06/13 21:49:16 niklas Exp $	*/
d62 1
d65 1
d70 3
a72 1
2:	popl	%edi
a86 1
	movl	%ebx,CPL
d91 1
d94 1
d102 1
a102 1
	cli
a137 1
	movl	%ebx,CPL
a160 1
 	movl	%ebx,CPL
a174 1
	movl	%ebx,CPL
@


1.21
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a44 19

#if defined(PROF) || defined(GPROF)
	.globl	_C_LABEL(splhigh), _C_LABEL(splx)

	ALIGN_TEXT
_C_LABEL(splhigh):
	movl	$IPL_HIGH,%eax
	xchgl	%eax,CPL
	ret

	ALIGN_TEXT
_C_LABEL(splx):
	movl	4(%esp),%eax
	movl	%eax,CPL
	testl	%eax,%eax
	jnz	_C_LABEL(Xspllower)
	ret
#endif /* PROF || GPROF */
	
@


1.20
log
@move netisr definition into md code to allow arch provide suitable allocation; tested on most archs
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.19 2003/04/17 03:42:14 drahn Exp $	*/
d36 1
a36 2
	.globl	_C_LABEL(imen), _C_LABEL(cpl), _C_LABEL(ipending)
	.globl	_C_LABEL(astpending), _C_LABEL(netisr)
d39 2
d52 1
a52 1
	xchgl	%eax,_C_LABEL(cpl)
d58 1
a58 1
	movl	%eax,_C_LABEL(cpl)
d76 1
a76 1
	movl	_C_LABEL(cpl),%ebx	# save priority
d81 1
a81 1
	andl	_C_LABEL(ipending),%eax
d102 1
a102 1
	movl	%ebx,_C_LABEL(cpl)
d104 2
a105 2
1:	movl	%ebx,%eax		# get cpl
	shrl	$4,%eax			# find its mask
d115 1
a116 1
	cmpb	$0,_C_LABEL(astpending)
d124 1
a124 1
4:	movb	$0,_C_LABEL(astpending)
d126 1
d129 1
d143 5
a147 1
	movl	%eax,_C_LABEL(cpl)
d149 4
a152 1
	movl	%ebx,_C_LABEL(cpl)
d165 5
a169 1
	movl	%eax,_C_LABEL(cpl)
d173 4
a176 1
	movl	%ebx,_C_LABEL(cpl)
d182 5
a186 1
	movl	%eax,_C_LABEL(cpl)
d188 4
a191 1
	movl	%ebx,_C_LABEL(cpl)
@


1.19
log
@i386 changes to move to ELF. asm cleanup. Change MAXDSIZ to 512M for 1Gsep.
DARPA funded work.
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.18 2001/12/04 00:00:36 niklas Exp $	*/
d40 2
@


1.18
log
@New try at a level based irq system.
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.16 2001/11/12 20:28:20 niklas Exp $	*/
d142 1
a142 1
	jmp	%esi
d158 1
a158 1
	jmp	%esi
d166 1
a166 1
	jmp	%esi
@


1.18.2.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d142 1
a142 1
	jmp	*%esi
d158 1
a158 1
	jmp	*%esi
d166 1
a166 1
	jmp	*%esi
@


1.17
log
@Revert niklas's broken ICU interrupt handling changes; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.15 2001/11/08 20:01:52 mickey Exp $	*/
d48 1
a48 1
	movl	$-1,%eax
d75 3
a77 2
1:	movl	%ebx,%eax
	notl	%eax
d101 3
a103 2
1:	movl	%ebx,%eax
	notl	%eax
d137 1
a137 1
	leal	SIR_TTYMASK(%ebx),%eax
d152 1
a152 1
	leal	SIR_NETMASK(%ebx),%eax
d162 1
a162 1
	leal	SIR_CLOCKMASK(%ebx),%eax
@


1.16
log
@Redo the ICU interrupt handling system to better emulate an APIC system.
This is done by representing the current blockings of interrupts with
a priority level instead of an interrupt mask.  This makes it possible to
share implementations for spl* functions/macros between both ICU
and APIC (a must when going MP) systems.  In this process, assign
soft interrupts their own levels to match the way things will be on
APIC systems where they actually will be real interrupts and not just
bits in a pending mask as they are now.
Heavily inspired by Bill Studenmunds SMP work in NetBSD
@
text
@d48 1
a48 1
	movl	$IPL_HIGH,%eax
d75 2
a76 3
1:	movl	%ebx,%eax		# get cpl
	shrl	$4,%eax			# find its mask.
	movl	_C_LABEL(iunmask)(,%eax,4),%eax
d100 2
a101 3
1:	movl	%ebx,%eax		# get cpl
	shrl	$4,%eax			# find its mask
	movl	_C_LABEL(iunmask)(,%eax,4),%eax
d135 1
a135 1
	movl	$IPL_SOFTTTY,%eax
d150 1
a150 1
	movl	$IPL_SOFTNET,%eax
d160 1
a160 1
	movl	$IPL_SOFTCLOCK,%eax
@


1.15
log
@veli tpyo stolen fmor nkilsa
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.14 2001/09/21 20:54:32 mickey Exp $	*/
d48 1
a48 1
	movl	$-1,%eax
d75 3
a77 2
1:	movl	%ebx,%eax
	notl	%eax
d101 3
a103 2
1:	movl	%ebx,%eax
	notl	%eax
d137 1
a137 1
	leal	SIR_TTYMASK(%ebx),%eax
d152 1
a152 1
	leal	SIR_NETMASK(%ebx),%eax
d162 1
a162 1
	leal	SIR_CLOCKMASK(%ebx),%eax
@


1.14
log
@use _C_LABEL for c labels consistantly throghout the source
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.13 2000/11/08 11:34:23 art Exp $	*/
d57 1
a57 1
	jnz	_C_LBALE(Xspllower)
@


1.13
log
@Use netisr_dispatch.h
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.12 1999/12/08 06:50:15 itojun Exp $	*/
d36 3
a38 2
	.globl	_imen,_cpl,_ipending,_astpending,_netisr
_imen:
d44 1
a44 1
	.globl	_splhigh, _splx
d47 1
a47 1
_splhigh:
d49 1
a49 1
	xchgl	%eax,_cpl
d53 1
a53 1
_splx:
d55 1
a55 1
	movl	%eax,_cpl
d57 1
a57 1
	jnz	_Xspllower
d73 1
a73 1
	movl	_cpl,%ebx		# save priority
d77 1
a77 1
	andl	_ipending,%eax
d80 1
a80 1
	btrl	%eax,_ipending
d82 1
a82 1
	jmp	*_Xrecurse(,%eax,4)
d98 1
a98 1
	movl	%ebx,_cpl
d102 1
a102 1
	andl	_ipending,%eax
d105 1
a105 1
	btrl    %eax,_ipending
d108 1
a108 1
	jmp	*_Xresume(,%eax,4)
d111 1
a111 1
	cmpb	$0,_astpending
d119 1
a119 1
4:	movb	$0,_astpending
d122 1
a122 1
	call	_trap
d136 3
a138 3
	movl	%eax,_cpl
	call	_comsoft
	movl	%ebx,_cpl
d151 1
a151 1
	movl	%eax,_cpl
d153 1
a153 1
	xchgl	_netisr,%edi
d155 1
a155 1
	movl	%ebx,_cpl
d161 3
a163 3
	movl	%eax,_cpl
	call	_softclock
	movl	%ebx,_cpl
d165 1
@


1.12
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.11 1999/05/24 23:09:01 jason Exp $	*/
d141 2
a142 2
#define DONET(s, c) \
	.globl  c		;\
d145 1
a145 1
	call	c		;\
d153 1
a153 39
#ifdef INET
#include "ether.h"
#if NETHER > 0
	DONET(NETISR_ARP, _arpintr)
#endif
	DONET(NETISR_IP, _ipintr)
#endif
#ifdef INET6
	DONET(NETISR_IPV6, _ip6intr)
#endif /* INET6 */
#ifdef NETATALK
	DONET(NETISR_ATALK, _atintr)
#endif
#ifdef IMP
	DONET(NETISR_IMP, _impintr)
#endif
#ifdef IPX
	DONET(NETISR_IPX, _ipxintr)
#endif
#ifdef NS
	DONET(NETISR_NS, _nsintr)
#endif
#ifdef ISO
	DONET(NETISR_ISO, _clnlintr)
#endif
#ifdef CCITT
	DONET(NETISR_CCITT, _ccittintr)
#endif
#ifdef NATM
	DONET(NETISR_NATM, _natmintr)
#endif
#include "ppp.h"
#if NPPP > 0
	DONET(NETISR_PPP, _pppintr)
#endif
#include "bridge.h"
#if NBRIDGE > 0
	DONET(NETISR_BRIDGE, _bridgeintr)
#endif
d156 1
@


1.12.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.13 2000/11/08 11:34:23 art Exp $	*/
d141 2
a142 2
#define DONETISR(s, c) \
	.globl  _C_LABEL(c)	;\
d145 1
a145 1
	call	_C_LABEL(c)	;\
d153 39
a191 1
#include <net/netisr_dispatch.h>
a193 1
#undef DONETISR
@


1.12.2.2
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.12.2.1 2001/04/18 16:07:52 niklas Exp $	*/
d36 1
a36 4
	.globl	_imen,_ipending,_netisr
#ifndef MULTIPROCESSOR
	.globl	_astpending
#endif
d48 1
a48 1
	xchgl	%eax,CPL
d54 1
a54 1
	movl	%eax,CPL
d72 1
a72 1
	movl	CPL,%ebx		# save priority
d97 1
a97 1
	movl	%ebx,CPL
a108 1
	CHECK_ASTPENDING(%ecx)
d110 1
d118 1
a118 1
4:	CLEAR_ASTPENDING(%ecx)
a119 1
	movl	$T_ASTFLT,TF_TRAPNO(%esp)	/* XXX undo later. */
a121 1
	cli
d135 1
a135 1
	movl	%eax,CPL
d137 1
a137 1
	movl	%ebx,CPL
d150 1
a150 1
	movl	%eax,CPL
a152 43
/*-
 * XXX SMP XXX 
 * #ifdef INET
 * #include "ether.h"
 * #if NETHER > 0
 *	DONET(NETISR_ARP, _arpintr)
 * #endif
 *	DONET(NETISR_IP, _ipintr)
 * #endif
 * #ifdef INET6
 *	DONET(NETISR_IPV6, _ip6intr)
 * #endif 
 * #ifdef NETATALK
 *	DONET(NETISR_ATALK, _atintr)
 * #endif
 * #ifdef IMP
 *	DONET(NETISR_IMP, _impintr)
 * #endif
 * #ifdef IPX
 *	DONET(NETISR_IPX, _ipxintr)
 * #endif
 * #ifdef NS
 *	DONET(NETISR_NS, _nsintr)
 * #endif
 * #ifdef ISO
 *	DONET(NETISR_ISO, _clnlintr)
 * #endif
 * #ifdef CCITT
 *	DONET(NETISR_CCITT, _ccittintr)
 * #endif
 * #ifdef NATM
 *	DONET(NETISR_NATM, _natmintr)
 * #endif
 * #include "ppp.h"
 * #if NPPP > 0
 *	DONET(NETISR_PPP, _pppintr)
 * #endif
 * #include "bridge.h"
 * #if NBRIDGE > 0
 *	DONET(NETISR_BRIDGE, _bridgeintr)
 * #endif
 *	movl	%ebx,CPL
 */
d154 1
a154 1
 	movl	%ebx,_cpl 
d160 1
a160 1
	movl	%eax,CPL
d162 1
a162 1
	movl	%ebx,CPL
@


1.12.2.3
log
@Make the GENERIC.MP kernel compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.12.2.2 2001/07/14 10:02:42 ho Exp $	*/
d202 1
a202 1
 	movl	%ebx,CPL
@


1.12.2.4
log
@New interrupt and spl* system, mostly from NetBSD's i386 MP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 1
a50 1
	movl	$IPL_HIGH,%eax
d77 3
a79 4
1:	movl	%ebx,%eax		# get cpl
	shrl	$4,%eax			# find its mask.
	movl	_iunmask(,%eax,4),%eax
	andl	_ipending,%eax		# any non-masked bits left?
d103 1
a103 2
	shrl	$4,%eax
	movl	_iunmask(,%eax,4),%eax
@


1.12.2.5
log
@Some vestiges from the old interrupt system was left; new code from NetBSD
@
text
@d111 1
@


1.12.2.6
log
@run network soft interrupts!
@
text
@d159 43
a201 1

@


1.12.2.7
log
@netisr_dispatch preprocessor magic
@
text
@d159 1
@


1.12.2.8
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.12.2.4 2001/10/27 09:57:31 niklas Exp $	*/
d36 1
a36 1
	.globl	_C_LABEL(imen),_C_LABEL(ipending),_C_LABEL(netisr)
d38 1
a38 1
	.globl	_C_LABEL(astpending)
d40 1
a40 1
_C_LABEL(imen):
d46 1
a46 1
	.globl	_C_LABEL(splhigh), _C_LABEL(splx)
d49 1
a49 1
_C_LABEL(splhigh):
d55 1
a55 1
_C_LABEL(splx):
d59 1
a59 1
	jnz	_C_LBALE(Xspllower)
d79 2
a80 2
	movl	_C_LABEL(iunmask)(,%eax,4),%eax
	andl	_C_LABEL(ipending),%eax		# any non-masked bits left?
d83 1
a83 1
	btrl	%eax,_C_LABEL(ipending)
d85 1
a85 1
	jmp	*_C_LABEL(Xrecurse)(,%eax,4)
d105 2
a106 2
	movl	_C_LABEL(iunmask)(,%eax,4),%eax
	andl	_C_LABEL(ipending),%eax
d109 1
a109 1
	btrl    %eax,_C_LABEL(ipending)
d111 1
a111 2
	cli
	jmp	*_C_LABEL(Xresume)(,%eax,4)
d126 1
a126 1
	call	_C_LABEL(trap)
d142 1
a142 1
	call	_C_LABEL(comsoft)
d158 1
a158 1
	xchgl	_C_LABEL(netisr),%edi
d167 1
a167 1
	call	_C_LABEL(softclock)
a169 1

@


1.12.2.9
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 1
a59 1
	jnz	_C_LABEL(Xspllower)
d141 1
a141 1
	movl	$IPL_SOFTTTY(%ebx),%eax
d156 1
a156 1
	movl	$IPL_SOFTNET,%eax
d166 1
a166 1
	movl	$IPL_SOFTCLOCK,%eax
@


1.12.2.10
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.12.2.9 2001/11/13 21:00:52 niklas Exp $	*/
@


1.12.2.11
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.12.2.10 2001/12/05 00:39:10 niklas Exp $	*/
d141 1
a141 1
	movl	IPL_SOFTTTY(%ebx),%eax
d146 1
a146 1
	jmp	*%esi
d162 1
a162 1
	jmp	*%esi
d170 1
a170 1
	jmp	*%esi
@


1.12.2.12
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.12.2.11 2003/05/13 19:42:08 ho Exp $	*/
a142 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintlock)
#endif
a143 3
#ifdef MULTIPROCESSOR	
	call	_C_LABEL(i386_softintunlock)
#endif
a157 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintlock)
#endif
a160 3
#ifdef MULTIPROCESSOR	
	call	_C_LABEL(i386_softintunlock)
#endif
a167 3
#ifdef MULTIPROCESSOR
	call	_C_LABEL(i386_softintlock)
#endif
a168 3
#ifdef MULTIPROCESSOR	
	call	_C_LABEL(i386_softintunlock)
#endif
@


1.12.2.13
log
@turn on interrupts in the softint handlers as soon as the spl is raised
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.12.2.12 2003/05/15 04:08:02 niklas Exp $	*/
a142 1
	sti
a163 1
	sti
a179 1
	sti
@


1.12.2.14
log
@stupid typo
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.12.2.13 2003/05/17 19:22:39 niklas Exp $	*/
d141 1
a141 1
	movl	$IPL_SOFTTTY,%eax
@


1.12.2.15
log
@Fix splassert in the SMP branch. Remove the old 'cpl' variable. While here,
remove a bunch of commons from intr.h. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.12.2.14 2003/05/22 09:11:56 niklas Exp $	*/
d42 1
a42 6
_C_LABEL(ipending):
	.long	0		# interupts pending
#ifndef MULTIPROCESSOR
_C_LABEL(astpending)
	.long	0		# async software traps (softints) pending
#endif
@


1.12.2.16
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a47 3
_C_LABEL(netisr):
	.long	0		# scheduling bits for network

@


1.12.2.17
log
@Missing semicolon in !MULTIPROCESSOR.

ok niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.12.2.16 2004/02/19 10:48:42 niklas Exp $	*/
d45 1
a45 1
_C_LABEL(astpending):
@


1.12.2.18
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 3
d44 4
@


1.11
log
@Only do basic work in the ethernet interrupt context, and queue packets to
be bridged.  Do the real work in a scheduled netisr.
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.10 1999/01/07 23:15:58 deraadt Exp $	*/
d161 1
a161 1
	DONET(NETISR_IPV6, _ipv6intr)
@


1.10
log
@global decl for *intr() routines, plus add INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.9 1997/07/23 06:58:34 denny Exp $	*/
d187 4
@


1.9
log
@Add AppleTalk netisr. Only tested (indeed, only compiled) on mac68k port.
Add options NETATALK to your config to try it out.
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.8 1996/08/16 02:54:02 deraadt Exp $	*/
d160 3
@


1.8
log
@someone send me an i386 assembler book
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.7 1996/08/16 02:51:31 deraadt Exp $	*/
d159 3
@


1.7
log
@spin processing ast events before going back to userland; my fix
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.6 1996/07/28 05:07:05 downsj Exp $	*/
d122 1
a122 1
	j	2b
@


1.6
log
@pccom and com are now mutually exclusive; pccom moves to major 8, the
same as com.

Also various function renaming and such so that multiport drivers should
now be able to link with pccom.  pccomvar.h is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.5 1996/07/07 00:05:48 downsj Exp $	*/
d122 1
@


1.5
log
@Integrate the i386 specific com driver from Onno van der Linden,
<onno@@simplex.nl>, as a seperate driver.  This is the OpenBSD com.c, with
his changes integrated and the functions renamed.

This driver should work with pcmcia, but hasn't been tested.  It will not
work the multiport boards.

Simply switch 'com' to 'pccom' in your conf and change the major number of
your devices in order to use this.
@
text
@d1 1
a1 1
/*	$OpenBSD: icu.s,v 1.4 1996/06/30 21:43:42 chuck Exp $	*/
d135 1
a135 1
	call	_pccomsoft
@


1.4
log
@add natm intr.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d129 2
d132 6
a137 1
	/* XXXX nothing for now */
@


1.3
log
@add IPX support.
from now IPX fully attached to the system, but only for i386.
other platforms need the same additions.
@
text
@d167 3
@


1.2
log
@from netbsd:
Deal with GCC's dead code elimination being suboptimal.
Modify splraise() to allow better optimization.
Make cpl, ipending, and astpending volatile.
Make sure interrupts are disabled before jumping to a resume point,
to prevent races.
Make FPU faults use INTRFASTEXIT, and remove INTREXIT.
Build the frame for recursive interrupts manually, and make sure to
disable interrupts to avoid races.
VS: ----------------------------------------------------------------------
@
text
@d1 1
d154 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: icu.s,v 1.43 1995/10/11 04:20:31 mycroft Exp $	*/
a66 1
ENTRY(spllower)
d105 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
