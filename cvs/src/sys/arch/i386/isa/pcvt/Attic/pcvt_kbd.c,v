head	1.42;
access;
symbols
	SMP_SYNC_A:1.42
	SMP_SYNC_B:1.42
	UBC_SYNC_A:1.42
	UBC_SYNC_B:1.42
	OPENBSD_2_9:1.40.0.2
	OPENBSD_2_9_BASE:1.40
	OPENBSD_2_8:1.39.0.2
	OPENBSD_2_8_BASE:1.39
	OPENBSD_2_7:1.34.0.2
	OPENBSD_2_7_BASE:1.34
	SMP:1.32.0.2
	SMP_BASE:1.32
	kame_19991208:1.31
	OPENBSD_2_6:1.27.0.2
	OPENBSD_2_6_BASE:1.27
	OPENBSD_2_5:1.19.0.4
	OPENBSD_2_5_BASE:1.19
	OPENBSD_2_4:1.19.0.2
	OPENBSD_2_4_BASE:1.19
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.9.0.4
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.42
date	2001.05.29.22.09.14;	author mickey;	state dead;
branches;
next	1.41;

1.41
date	2001.05.16.12.49.45;	author ho;	state Exp;
branches;
next	1.40;

1.40
date	2001.01.22.18.48.43;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2000.10.16.02.25.22;	author aaron;	state Exp;
branches;
next	1.38;

1.38
date	2000.10.11.21.24.28;	author aaron;	state Exp;
branches;
next	1.37;

1.37
date	2000.10.07.03.12.46;	author aaron;	state Exp;
branches;
next	1.36;

1.36
date	2000.09.01.05.46.02;	author aaron;	state Exp;
branches;
next	1.35;

1.35
date	2000.07.19.13.40.26;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2000.02.28.02.39.15;	author aaron;	state Exp;
branches;
next	1.33;

1.33
date	2000.02.27.20.34.36;	author aaron;	state Exp;
branches;
next	1.32;

1.32
date	2000.01.18.19.34.41;	author aaron;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	99.11.27.21.39.29;	author aaron;	state Exp;
branches;
next	1.30;

1.30
date	99.11.25.21.00.36;	author aaron;	state Exp;
branches;
next	1.29;

1.29
date	99.11.25.20.24.21;	author aaron;	state Exp;
branches;
next	1.28;

1.28
date	99.11.20.18.52.00;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	99.10.07.02.43.08;	author aaron;	state Exp;
branches;
next	1.26;

1.26
date	99.10.05.16.38.20;	author aaron;	state Exp;
branches;
next	1.25;

1.25
date	99.10.04.09.38.19;	author aaron;	state Exp;
branches;
next	1.24;

1.24
date	99.09.27.01.50.19;	author aaron;	state Exp;
branches;
next	1.23;

1.23
date	99.09.21.00.52.42;	author aaron;	state Exp;
branches;
next	1.22;

1.22
date	99.09.08.12.56.42;	author aaron;	state Exp;
branches;
next	1.21;

1.21
date	99.09.06.00.12.40;	author aaron;	state Exp;
branches;
next	1.20;

1.20
date	99.07.06.07.59.54;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	98.09.06.23.00.03;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	98.08.09.06.13.30;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	98.07.12.18.56.06;	author weingart;	state Exp;
branches;
next	1.16;

1.16
date	98.06.30.20.51.12;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.06.25.00.40.29;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	98.02.22.22.06.14;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	98.02.05.16.48.34;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.01.11.06.15.35;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.07.25.22.52.43;	author weingart;	state Exp;
branches;
next	1.10;

1.10
date	97.05.30.01.43.05;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.09.06.08.40.49;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.08.29.09.26.10;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.06.16.13.54.02;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.25.22.17.58;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.07.07.22.30;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.18.17.48.33;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.03.29.12.05.46;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.03.19.21.09.50;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.39;	author deraadt;	state Exp;
branches;
next	;

1.32.2.1
date	2000.03.02.07.04.29;	author niklas;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2001.04.18.16.07.58;	author niklas;	state Exp;
branches;
next	1.32.2.3;

1.32.2.3
date	2001.07.04.10.17.00;	author niklas;	state dead;
branches;
next	;


desc
@@


1.42
log
@remove this used to be great console driver; x11 builds w/o it all fine; aaron@@, todd@@, matthieu@@ ok
@
text
@/*	$OpenBSD: pcvt_kbd.c,v 1.41 2001/05/16 12:49:45 ho Exp $	*/

/*
 * Copyright (c) 1992, 1995 Hellmuth Michaelis and Joerg Wunsch.
 *
 * Copyright (c) 1992, 1993 Brian Dunford-Shore and Holger Veit.
 *
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz and Don Ahn.
 *
 * This code is derived from software contributed to 386BSD by
 * Holger Veit.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Hellmuth Michaelis,
 *	Brian Dunford-Shore and Joerg Wunsch.
 * 4. The name authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * @@(#)pcvt_kbd.c, 3.32, Last Edit-Date: [Tue Oct  3 11:19:48 1995]
 *
 */

/*---------------------------------------------------------------------------*
 *
 *	pcvt_kbd.c	VT220 Driver Keyboard Interface Code
 *	----------------------------------------------------
 *	-hm	------------ Release 3.00 --------------
 *	-hm	integrating NetBSD-current patches
 *	-jw	introduced kbd_emulate_pc() if scanset > 1
 *	-hm	patch from joerg for timeout in kbd_emulate_pc()
 *	-hm	starting to implement alt-shift/ctrl key mappings
 *	-hm	Gateway 2000 Keyboard fix from Brian Moore
 *	-hm	some #if adjusting for NetBSD 0.9
 *	-hm	split off pcvt_kbd.h
 *	-hm	applying Joerg's patches for FreeBSD 2.0
 *	-hm	patch from Martin, PCVT_NO_LED_UPDATE
 *	-hm	PCVT_VT220KEYB patches from Lon Willet
 *	-hm	PR #399, patch from Bill Sommerfeld: Return with PCVT_META_ESC
 *	-hm	allow keyboard-less kernel boot for serial consoles and such ..
 *	-hm	patch from Lon Willett for led-update and showkey()
 *	-hm	patch from Lon Willett to fix mapping of Control-R scancode
 *	-hm	delay patch from Martin Husemann after port-i386 ml-discussion
 *	-hm	added PCVT_NONRESP_KEYB_TRY definition to doreset()
 *	-hm	keyboard code bugfix from Jukka A. Ukkonen (ukkonen@@csc.fi)
 *	-hm	---------------- Release 3.30 -----------------------
 *	-hm	patch from Frank van der Linden for keyboard state per VT
 *	-hm	removed KBDGLEDS and KBDSLEDS ioctls
 *	-hm	---------------- Release 3.32 -----------------------
 *
 *---------------------------------------------------------------------------*/

#include "vt.h"
/* #if NVT > 0 */

#include <sys/ttydefaults.h>	/* CSTOP, CSTART for XON/XOFF scrlck emul. */
#include "pcvt_hdr.h"		/* global include */

#define LEDSTATE_UPDATE_PENDING (1 << 3)
#define LEDSTATE_UPDATING	(1 << 4)

static void fkey1(void), fkey2(void),  fkey3(void),  fkey4(void);
static void fkey5(void), fkey6(void),  fkey7(void),  fkey8(void);
static void fkey9(void), fkey10(void), fkey11(void), fkey12(void);

static void sfkey1(void), sfkey2(void),  sfkey3(void),  sfkey4(void);
static void sfkey5(void), sfkey6(void),  sfkey7(void),  sfkey8(void);
static void sfkey9(void), sfkey10(void), sfkey11(void), sfkey12(void);

static void cfkey1(void), cfkey2(void),  cfkey3(void),  cfkey4(void);
static void cfkey5(void), cfkey6(void),  cfkey7(void),  cfkey8(void);
static void cfkey9(void), cfkey10(void), cfkey11(void), cfkey12(void);

static inline int kbd_wait_output(void);
static inline int kbd_wait_input(void);
int kbd_response(void);

static void	doreset ( void );
static void	ovlinit ( int force );
static void 	settpmrate ( int rate );
static void	setlockkeys ( int snc );
static int	kbc_8042cmd ( int val );
static int	getokeydef ( unsigned key, struct kbd_ovlkey *thisdef );
static int 	getckeydef ( unsigned key, struct kbd_ovlkey *thisdef );
static int	rmkeydef ( int key );
static int	setkeydef ( struct kbd_ovlkey *data );
static u_char *	xlatkey2ascii( U_short key );

#if !PCVT_NO_LED_UPDATE
static int	ledstate  = LEDSTATE_UPDATE_PENDING;	/* keyboard led's */
#endif
static int	tpmrate   = KBD_TPD500|KBD_TPM100;
static u_char	altkpflag = 0;
static u_short	altkpval  = 0;

static u_short *scrollback_savedscreen = (u_short *)0;
static size_t scrnsv_size = (size_t)-1;
static void scrollback_save_screen ( void );
static void scrollback_restore_screen ( void );

extern int kbd_reset;

#include "pcvt_kbd.h"		/* tables etc */

/*---------------------------------------------------------------------------*
 *	function to switch to another virtual screen
 *---------------------------------------------------------------------------*/
static void
do_vgapage(int page)
{
	if (critical_scroll)		/* executing critical region ? */
		switch_page = page;	/* yes, auto switch later */
	else
		vgapage(page);		/* no, switch now */
}

/*
 * This code from Lon Willett enclosed in #if PCVT_UPDLED_LOSES_INTR is
 * disabled because it crashes FreeBSD 1.1.5.1 at boot time.
 * The cause is obviously that the timeout queue is not yet initialized
 * timeout is called from here the first time.
 * Anyway it is a pointer in the right direction so it is included for
 * reference here.
 */

#define PCVT_UPDLED_LOSES_INTR	0	/* disabled for now */

#if PCVT_UPDLED_LOSES_INTR

/*---------------------------------------------------------------------------*
 *	check for lost keyboard interrupts
 *---------------------------------------------------------------------------*/

/*
 * The two commands to change the LEDs generate two KEYB_R_ACK responses
 * from the keyboard, which aren't explicitly checked for (maybe they
 * should be?).  However, when a lot of other I/O is happening, one of
 * the interrupts sometimes gets lost (I'm not sure of the details of
 * how and why and what hardware this happens with).
 *
 * This is a real problem, because normally the keyboard is only polled
 * by pcrint(), and no more interrupts will be generated until the ACK
 * has been read.  So the keyboard is hung.  This code polls a little
 * while after changing the LEDs to make sure that this hasn't happened.
 *
 * XXX Quite possibly we should poll the kbd on a regular basis anyway,
 * in the interest of robustness.  It may be possible that interrupts
 * get lost other times as well.
 */
 /* Previous comment obsolete, update_led() now interrupt driven */

struct timeout kbd_led_intr_to;

static void
check_for_lost_intr (void *arg)
{
	if (inb(CONTROLLER_CTRL) & STATUS_OUTPBF) {
		int opri = spltty();
		(void)pcrint();
		splx(opri);
	}
}

#endif /* PCVT_UPDLED_LOSES_INTR */

/*---------------------------------------------------------------------------*
 *	update keyboard led's
 *---------------------------------------------------------------------------*/
void
update_led(u_char cause)
{
#if !PCVT_NO_LED_UPDATE
	/* Don't update LED's unless necessary. */

	int opri, new_ledstate;

	if (!keyboard_type) return; /* allow disconnected kbd operation */

	opri = spltty();
	new_ledstate = ((vsp->scroll_lock) | (vsp->num_lock * 2) |
			(vsp->caps_lock * 4));
#if 0
	if (new_ledstate != ledstate) {
#endif	/* because of switch_screen() and vgapage() changes */
		if ((cause == KBD_SCROLL) || (cause == KBD_NUM) ||
		    (cause == KBD_CAPS) ||
		    ((cause == 1) && (!do_initialization)) ||
		    ((cause == 2) && (!do_initialization)) ||
		    ((cause == KEYB_R_RESEND) &&
		    (ledstate == LEDSTATE_UPDATE_PENDING))) {

			if (kbd_cmd(KEYB_C_LEDS) != 0) {
				printf("pcvt: kbd led cmd timeout\n");
				goto bail;
			}
			ledstate = LEDSTATE_UPDATE_PENDING;
			if (cause == KEYB_R_RESEND)
				printf("pcvt: kbd led cmd resend\n");
			goto bail;
		}

		/*
		 * For some keyboards or keyboard controllers, it is an
		 * error to issue a command without waiting long enough
		 * for an ACK for the previous command.  The keyboard
		 * gets confused, and responds with KEYB_R_RESEND, but
		 * we ignore that.  Wait for the ACK here.  The busy
		 * waiting doesn't matter much, since we lose anyway by
		 * busy waiting to send the command.
		 *
		 * XXX actually wait for any response, since we can't
		 * handle normal scancodes here.
		 *
		 * XXX all this should be interrupt driven.  Issue only
		 * one command at a time wait for a ACK before proceeding.
		 * Retry after a timeout or on receipt of a KEYB_R_RESEND.
		 * KEYB_R_RESENDs seem to be guaranteed by working
		 * keyboard controllers with broken (or disconnected)
		 * keyboards.  There is another code for keyboard
		 * reconnects.  The keyboard hardware is very simple and
		 * well designed :-).
		 */
		/*
		 * Previous comment obsolete, update_led() now interrupt driven
		 */

		if (((cause == KEYB_R_ACK) &&
			(ledstate == LEDSTATE_UPDATE_PENDING)) ||
		    ((cause == KEYB_R_RESEND) &&
			(ledstate == LEDSTATE_UPDATING))) {

			if (kbd_cmd(new_ledstate) != 0) {
				printf("pcvt: kbd led data timeout\n");
				goto bail;
			}
			ledstate = LEDSTATE_UPDATING;
			if (cause == KEYB_R_RESEND)
				printf("pcvt:kbd led data resend\n");
			goto bail;
		}

		if ((cause == KEYB_R_ACK) && (ledstate == LEDSTATE_UPDATING)) {
			ledstate = new_ledstate;
			goto bail;
		}

#if PCVT_UPDLED_LOSES_INTR
		timeout_add(&kbd_led_intr_to, hz);
#endif /* PCVT_UPDLED_LOSES_INTR */
#if 0
	}
#endif	/* because of switch_screen() and vgapage() changes */
bail:
	splx(opri);
#endif /* !PCVT_NO_LED_UPDATE */
}

/*---------------------------------------------------------------------------*
 *	set typematic rate
 *---------------------------------------------------------------------------*/
static void
settpmrate(int rate)
{
	int opri, response1, response2;

	opri = spltty();
	tpmrate = rate & 0x7f;

	if (kbd_cmd(KEYB_C_TYPEM) != 0) {
		printf("pcvt: kbd tpm cmd timeout\n");
		goto fail;
	}
	response1 = kbd_response();		/* wait for ACK */

	if (kbd_cmd(tpmrate) != 0) {
		printf("pcvt: kbd tpm data timeout\n");
		goto fail;
	}
	response2 = kbd_response();		/* wait for ACK */

	if (response1 != KEYB_R_ACK || response2 != KEYB_R_ACK) {
		printf("pcvt: kbd tpm cmd not ack'd (resp %#x %#x)\n",
		   response1, response2);
	}
fail:
	splx(opri);
}

/*---------------------------------------------------------------------------*
 *	Pass command to keyboard controller (8042)
 *---------------------------------------------------------------------------*/
static inline int
kbd_wait_output()
{
	u_int i;

	/* > 100 msec */
	for (i = 100; i; i--) {
		if ((inb(CONTROLLER_CTRL) & STATUS_INPBF) == 0) {
			PCVT_KBD_DELAY();
			return (1);
		}
		DELAY(1000);
	}
	return (0);
}

static inline int
kbd_wait_input()
{
	u_int i;

	/* > 500 msec */
	for (i = 500; i; i--) {
		if ((inb(CONTROLLER_CTRL) & STATUS_OUTPBF) != 0) {
			PCVT_KBD_DELAY();
			return (1);
		}
		DELAY(1000);
	}
	return (0);
}

static int
kbc_8042cmd(int val)
{
	if (!kbd_wait_output())
		return (-1);
	outb(CONTROLLER_CTRL, val);

	return (0);
}

/*---------------------------------------------------------------------------*
 *	Pass command to keyboard itself
 *---------------------------------------------------------------------------*/
int
kbd_cmd(int val)
{
	if (!kbd_wait_output())
		return (-1);
	outb(CONTROLLER_DATA, val);

	return (0);
}

/*---------------------------------------------------------------------------*
 *	Read response from keyboard
 *	NB: make sure to call spltty() before kbd_cmd(), kbd_response().
 *---------------------------------------------------------------------------*/
int
kbd_response(void)
{
	u_char ch;

	if (!kbd_wait_input())
		return (-1);
	ch = inb(CONTROLLER_DATA);

	return (ch);
}

/*---------------------------------------------------------------------------*
 *	switch to/from PC scan code emulation mode
 *---------------------------------------------------------------------------*/
void
kbd_setmode(int mode)
{
#if PCVT_SCANSET > 1		/* switch only if we are running scancode 2 */
	int cmd;
#if PCVT_USEKBDSEC
	cmd = COMMAND_SYSFLG | COMMAND_IRQEN;
#else
	cmd = COMMAND_INHOVR | COMMAND_SYSFLG | COMMAND_IRQEN;
#endif

	if (mode == K_RAW)		/* switch to scancode 1 ? */
		cmd |= COMMAND_PCSCAN;	/*     yes, setup command */

	kbc_8042cmd(CONTR_WRITE);
	kbd_cmd(cmd);
	
#endif /* PCVT_SCANSET > 1 */

	if (mode == K_RAW)
		shift_down = meta_down = altgr_down = ctrl_down = 0;
}


#ifndef PCVT_NONRESP_KEYB_TRY
#define PCVT_NONRESP_KEYB_TRY	25	/* no of times to try to detect	*/
#endif					/* a nonresponding keyboard	*/

/*---------------------------------------------------------------------------*
 *	try to force keyboard into a known state ..
 *---------------------------------------------------------------------------*/
static
void doreset(void)
{
	int again = 0;
	int once = 0;
	int response, opri;
	unsigned int wait_retries, seen_negative_response;

	/* Enable interrupts and keyboard, etc. */
	if (kbc_8042cmd(CONTR_WRITE) != 0)
		printf("pcvt: timeout controller write cmd\n");

#if PCVT_USEKBDSEC		/* security enabled */

#  if PCVT_SCANSET == 2
#    define KBDINITCMD COMMAND_SYSFLG|COMMAND_IRQEN
#  else /* PCVT_SCANSET != 2 */
#    define KBDINITCMD COMMAND_PCSCAN|COMMAND_SYSFLG|COMMAND_IRQEN
#  endif /* PCVT_SCANSET == 2 */

#else /* ! PCVT_USEKBDSEC */	/* security disabled */

#  if PCVT_SCANSET == 2
#    define KBDINITCMD COMMAND_INHOVR|COMMAND_SYSFLG|COMMAND_IRQEN
#  else /* PCVT_SCANSET != 2 */
#    define KBDINITCMD COMMAND_PCSCAN|COMMAND_INHOVR|COMMAND_SYSFLG\
	|COMMAND_IRQEN
#  endif /* PCVT_SCANSET == 2 */

#endif /* PCVT_USEKBDSEC */

	if (kbd_cmd(KBDINITCMD) != 0)
		printf("pcvt: timeout writing kbd init cmd\n");

	/*
	 * Discard any stale keyboard activity.  The 0.1 boot code isn't
	 * very careful and sometimes leaves a KEYB_R_RESEND.
	 */
	while (1) {
		if (inb(CONTROLLER_CTRL) & STATUS_OUTPBF)
			kbd_response();
		else {
			DELAY(10000);
			if (!(inb(CONTROLLER_CTRL) & STATUS_OUTPBF))
				break;
		}
	}

	/* Start keyboard reset */
	opri = spltty();

	if (kbd_cmd(KEYB_C_RESET) != 0)
		printf("pcvt: kbd reset cmd timeout\n");

	/* Wait for the first response to reset and handle retries */
	while ((response = kbd_response()) != KEYB_R_ACK) {
		if (response < 0) {
			if (!again)	/* print message only once ! */
				printf("pcvt: response != ack\n");
			response = KEYB_R_RESEND;
		}
		if (response == KEYB_R_RESEND) {
			if (!again)	/* print message only once ! */
				printf("pcvt: got KEYB_R_RESEND\n");

			if (++again > PCVT_NONRESP_KEYB_TRY) {
				printf("pcvt: no kbd detected\n");
				keyboard_type = KB_UNKNOWN;
				splx(opri);
				return;
			}

			if ((kbd_cmd(KEYB_C_RESET) != 0) && (once == 0)) {
				once++;		/* print message only once ! */
				printf("pcvt: timeout for loop\n");
			}
		}
	}

	/* Wait for the second response to reset */

	wait_retries = seen_negative_response = 0;

	while ((response = kbd_response()) != KEYB_R_SELFOK) {
		/*
		 *  Let's be a little more tolerant here...
		 *  Receiving a -1 could indicate that the keyboard
		 *  is not ready to answer just yet.
		 *  Such cases have been noticed with e.g. Alps Membrane.
		 */

		if (response < 0)
			seen_negative_response = 1;

		if (seen_negative_response && (wait_retries >= 10)) {
			printf("pcvt: response != OK\n");

			/*
			 * If KEYB_R_SELFOK never arrives, the loop will
			 * finish here unless the keyboard babbles or
			 * STATUS_OUTPBF gets stuck.
			 */
			break;
		}
		wait_retries++;
	}

#if PCVT_SCANSET == 1
	/* 
	 * Pcvt has been compiled for scanset 1, which requires that
	 * the mainboard controller translates. If it is not able to,
	 * try to set the keyboard to XT mode so that pcvt will see AT
	 * scan codes after all. If it fails, we're out of luck.
	 */
	kbc_8042cmd(CONTR_READ);
	response = kbd_response();

	if (!(response & COMMAND_PCSCAN)) {
		if (kbd_cmd(KEYB_C_SCANSET) != 0)
			printf("pcvt: kbd SCANSET cmd timeout\n");
		else if (kbd_cmd(1) != 0)
			printf("pcvt: kbd SCANSET data timeout\n");
		else
			printf("pcvt: kbd set to XT mode\n");
	 }
#endif
	splx(opri);

#if PCVT_KEYBDID

query_kbd_id:
	opri = spltty();

	if (kbd_cmd(KEYB_C_ID) != 0) {
		printf("pcvt: timeout for kbd ID cmd\n");
		keyboard_type = KB_UNKNOWN;
	}
	else {
r_entry:
		if ((response = kbd_response()) == KEYB_R_MF2ID1) {
			switch ((response = kbd_response())) {
			case KEYB_R_RESEND:
				/*
				 *  Let's give other priority levels
				 *  a chance instead of blocking at
				 *  tty level.
				 */
				splx(opri);
				goto query_kbd_id;
					
			case KEYB_R_MF2ID2:
			case KEYB_R_MF2ID2HP:
			case KEYB_R_MF2ID2TP:
			case KEYB_R_MF2ID2TP2:
				keyboard_type = KB_MFII;
				break;

			default:
				printf("pcvt: kbdid (resp 2 = %d)\n", response);
				keyboard_type = KB_UNKNOWN;
				break;
			}
		}
		else if (response == KEYB_R_ACK)
			goto r_entry;
		else if (response == -1)
			keyboard_type = KB_AT;
		else
			printf("pcvt: kbdid (resp 1 = %d)\n", response);
	}
	splx(opri);

#else /* PCVT_KEYBDID */
	keyboard_type = KB_MFII;	/* force it .. */
#endif /* PCVT_KEYBDID */
}

/*---------------------------------------------------------------------------*
 *	init keyboard code
 *---------------------------------------------------------------------------*/
void
kbd_code_init(void)
{
	doreset();
	ovlinit(0);
	keyboard_is_initialized = 1;
#if !PCVT_NO_LED_UPDATE && PCVT_UPDLED_LOSES_INTR
	timeout_set(&kbd_led_intr_to, check_for_lost_intr, NULL);
#endif
}

/*---------------------------------------------------------------------------*
 *	init keyboard code, this initializes the keyboard subsystem
 *	just "a bit" so the very very first ddb session is able to
 *	get proper keystrokes - in other words, it's a hack ....
 *---------------------------------------------------------------------------*/
void
kbd_code_init1(void)
{
	doreset();
	keyboard_is_initialized = 1;
}

/*---------------------------------------------------------------------------*
 *	init keyboard overlay table
 *---------------------------------------------------------------------------*/
static
void ovlinit(int force)
{
	int i;

	if (force || ovlinitflag == 0) {
		if (ovlinitflag == 0)
		    ovltbl = (Ovl_tbl *)malloc(sizeof(Ovl_tbl) * OVLTBL_SIZE,
					       M_DEVBUF, M_WAITOK);

		for(i = 0; i < OVLTBL_SIZE; i++) {
			ovltbl[i].keynum =
			ovltbl[i].type = 0;
			ovltbl[i].unshift[0] =
			ovltbl[i].shift[0] =
			ovltbl[i].ctrl[0] =
			ovltbl[i].altgr[0] = 0;
			ovltbl[i].subu =
			ovltbl[i].subs =
			ovltbl[i].subc =
			ovltbl[i].suba = KBD_SUBT_STR;	/* just strings .. */
		}
		for(i = 0; i <= MAXKEYNUM; i++)
			key2ascii[i].type &= KBD_MASK;

		ovlinitflag = 1;
	}
}

/*---------------------------------------------------------------------------*
 *	get original key definition
 *---------------------------------------------------------------------------*/
static int
getokeydef(unsigned key, Ovl_tbl *thisdef)
{
	if (key == 0 || key > MAXKEYNUM)
		return (EINVAL);

	thisdef->keynum = key;
	thisdef->type = key2ascii[key].type;

	if (key2ascii[key].unshift.subtype == STR) {
		bcopy((u_char *)(key2ascii[key].unshift.what.string),
		    thisdef->unshift, CODE_SIZE);
		thisdef->subu = KBD_SUBT_STR;
	}
	else {
		bcopy("", thisdef->unshift, CODE_SIZE);
		thisdef->subu = KBD_SUBT_FNC;
	}

	if (key2ascii[key].shift.subtype == STR) {
		bcopy((u_char *)(key2ascii[key].shift.what.string),
		    thisdef->shift, CODE_SIZE);
		thisdef->subs = KBD_SUBT_STR;
	}
	else {
		bcopy("", thisdef->shift,CODE_SIZE);
		thisdef->subs = KBD_SUBT_FNC;
	}

	if (key2ascii[key].ctrl.subtype == STR) {
		bcopy((u_char *)(key2ascii[key].ctrl.what.string),
		    thisdef->ctrl, CODE_SIZE);
		thisdef->subc = KBD_SUBT_STR;
	}
	else {
		bcopy("",thisdef->ctrl,CODE_SIZE);
		thisdef->subc = KBD_SUBT_FNC;
	}

	/* deliver at least anything for ALTGR settings ... */
	if (key2ascii[key].unshift.subtype == STR) {
		bcopy((u_char *)(key2ascii[key].unshift.what.string),
		    thisdef->altgr, CODE_SIZE);
		thisdef->suba = KBD_SUBT_STR;
	}
	else {
		bcopy("", thisdef->altgr, CODE_SIZE);
		thisdef->suba = KBD_SUBT_FNC;
	}
	return (0);
}

/*---------------------------------------------------------------------------*
 *	get current key definition
 *---------------------------------------------------------------------------*/
static int
getckeydef(unsigned key, Ovl_tbl *thisdef)
{
	u_short type = key2ascii[key].type;

	if (key > MAXKEYNUM)
		return (EINVAL);

	if (type & KBD_OVERLOAD)
		*thisdef = ovltbl[key2ascii[key].ovlindex];
	else
		getokeydef(key,thisdef);

	return (0);
}

/*---------------------------------------------------------------------------*
 *	translate keynumber and returns ptr to associated ascii string
 *	if key is bound to a function, executes it, and ret empty ptr
 *---------------------------------------------------------------------------*/
static u_char *
xlatkey2ascii(U_short key)
{
	int		n;
	static u_char	capchar[2] = {0, 0};
#if PCVT_META_ESC
	static u_char	metachar[3] = {0x1b, 0, 0};
#else
	static u_char	metachar[2] = {0, 0};
#endif
	static Ovl_tbl	thisdef;
	static u_char altgr_shft_key[KBDMAXOVLKEYSIZE];
	
	void		(*fnc)(void);

	/* ignore the NON-KEY */
	if (key == 0)
		return (0);

	/* get the current ASCII value */
	getckeydef(key & 0x7F, &thisdef);

	thisdef.type &= KBD_MASK;

	if (key & 0x80) {		/* special handling of ALT-KEYPAD */
		/* is the ALT Key released? */
		if (thisdef.type == KBD_META || thisdef.type == KBD_ALTGR) {
			if (altkpflag) { /* have we been in altkp mode? */
				capchar[0] = altkpval;
				altkpflag = 0;
				altkpval = 0;
				return (capchar);
			}
		}
		return (0);
	}

	switch (thisdef.type) {		/* convert the keys */
	case KBD_BREAK:
	case KBD_ASCII:
	case KBD_FUNC:
		fnc = NULL;
		more_chars = NULL;

		if (altgr_down) {
			/* XXX this is hack to support simple AltGr + Shift
	 	 	 * remapping. This should work for KOI-8 keymap style.
			 */
			if (shift_down) {
                		altgr_shft_key[0] = *(u_char*)thisdef.altgr+040;
                		more_chars = (u_char*)altgr_shft_key;
                	}
                	else
				more_chars = (u_char *)thisdef.altgr;
		}
		else if (!ctrl_down && (shift_down || vsp->shift_lock)) {
			if (key2ascii[key].shift.subtype == STR)
				more_chars = (u_char *)thisdef.shift;
			else
				fnc = key2ascii[key].shift.what.func;
		     }
		else if (ctrl_down) {
			if (key2ascii[key].ctrl.subtype == STR)
				more_chars = (u_char *)thisdef.ctrl;
			else
				fnc = key2ascii[key].ctrl.what.func;
		     }
		else {
			if (key2ascii[key].unshift.subtype == STR)
				more_chars = (u_char *)thisdef.unshift;
			else
				fnc = key2ascii[key].unshift.what.func;
		}

		if (fnc)
			(*fnc)();	/* execute function */

		if ((more_chars != NULL) && (more_chars[1] == 0)) {
			if (vsp->caps_lock && more_chars[0] >= 'a'
			   && more_chars[0] <= 'z') {
				capchar[0] = *more_chars - ('a' - 'A');
				more_chars = capchar;
			}
			if (meta_down) {
#if PCVT_META_ESC
				metachar[1] = *more_chars;
#else
				metachar[0] = *more_chars | 0x80;
#endif
				more_chars = metachar;
			}
		}
		return (more_chars);

	case KBD_KP:
		fnc = NULL;
		more_chars = NULL;

		if (meta_down) {
			switch (key) {
			case 95:	/* / */
				altkpflag = 0;
				more_chars = (u_char *)"\033OQ";
				return (more_chars);

			case 100:	/* * */
				altkpflag = 0;
				more_chars = (u_char *)"\033OR";
				return (more_chars);

			case 105:	/* - */
				altkpflag = 0;
		 		more_chars = (u_char *)"\033OS";
				return (more_chars);
			}
		}

		if (meta_down || altgr_down) {
			if ((n = keypad2num[key-91]) >= 0) {
				if (!altkpflag) {
					/* start ALT-KP mode */
					altkpflag = 1;
					altkpval = 0;
				}
				altkpval *= 10;
				altkpval += n;
			}
			else
				altkpflag = 0;
			return (0);
		}

		if (!vsp->num_lock) {
			if (key2ascii[key].shift.subtype == STR)
				more_chars = (u_char *)thisdef.shift;
			else
				fnc = key2ascii[key].shift.what.func;
		}
		else {
			if (key2ascii[key].unshift.subtype == STR)
				more_chars = (u_char *)thisdef.unshift;
			else
				fnc = key2ascii[key].unshift.what.func;
		}

		if (fnc)
			(*fnc)();	/* execute function */

		return (more_chars);

	case KBD_CURSOR:
		fnc = NULL;
		more_chars = NULL;

		if (vsp->ckm) {
			if (key2ascii[key].shift.subtype == STR)
				more_chars = (u_char *)thisdef.shift;
			else
				fnc = key2ascii[key].shift.what.func;
		}
		else {
			if (key2ascii[key].unshift.subtype == STR)
				more_chars = (u_char *)thisdef.unshift;
			else
				fnc = key2ascii[key].unshift.what.func;
		}

		if (fnc)
			(*fnc)();	/* execute function */

		return (more_chars);

	case KBD_NUM:		/*  special kp-num handling */
		more_chars = NULL;

		if (meta_down)
			more_chars = (u_char *)"\033OP"; /* PF1 */
		else {
			vsp->num_lock ^= 1;
			update_led(KBD_NUM);
		}
		return (more_chars);

	case KBD_RETURN:
		more_chars = NULL;

		if (!vsp->num_lock)
			more_chars = (u_char *)thisdef.shift;
		else
			more_chars = (u_char *)thisdef.unshift;

		if (vsp->lnm && (*more_chars == '\r'))
			more_chars = (u_char *)"\r\n"; /* CR LF */

		if (meta_down) {
#if PCVT_META_ESC
			metachar[1] = *more_chars;
#else
			metachar[0] = *more_chars | 0x80;
#endif
			more_chars = metachar;
		}
		return (more_chars);

	case KBD_META:		/* these keys are	*/
	case KBD_ALTGR:		/*  handled directly	*/
	case KBD_SCROLL:	/*  by the keyboard	*/
	case KBD_CAPS:		/*  handler - they are	*/
	case KBD_SHFTLOCK:	/*  ignored here	*/
	case KBD_CTL:
	case KBD_NONE:
	default:
		return (0);
	}
}

/*---------------------------------------------------------------------------*
 *	get keystrokes from the keyboard.
 *	if noblock = 0, wait until a key is pressed.
 *	else return NULL if no characters present.
 *---------------------------------------------------------------------------*/

#if PCVT_KBD_FIFO
extern	u_char	pcvt_kbd_fifo[];
extern	int	pcvt_kbd_rptr;
extern	short	pcvt_kbd_count;
#endif

u_char *
sgetc(int noblock)
{
#if PCVT_KBD_FIFO
	int		s;
#endif
	u_char *cp, dt, key;
	u_short	type;
	static u_char kbd_lastkey = 0; /* last keystroke */
	static char	keybuf[2] = {0}; /* the second 0 is a delimiter! */

	static struct {
		u_char extended: 1;	/* extended prefix seen */
		u_char ext1: 1;		/* extended prefix 1 seen */
		u_char breakseen: 1;	/* break code seen */
		u_char vshift: 1;	/* virtual shift pending */
		u_char vcontrol: 1;	/* virtual control pending */
		u_char sysrq: 1;	/* sysrq pressed */
	} kbd_status = {0};

loop:

#ifdef XSERVER

#if PCVT_KBD_FIFO

	if (noblock == 31337) {
		vsp->scrolling = 1;
		goto scroll_reset;
	}

	/* see if there is data from the keyboard available either from */
	/* the keyboard fifo or from the 8042 keyboard controller	*/

	if ((( noblock) && (pcvt_kbd_count)) ||
	    ((!noblock) && (inb(CONTROLLER_CTRL) & STATUS_OUTPBF))) {
		if (!noblock) {		/* source = 8042 */
			PCVT_KBD_DELAY();	/* 7 us delay */
			dt = inb(CONTROLLER_DATA);	/* get from obuf */
		}
		else {			/* source = keyboard fifo */
			dt = pcvt_kbd_fifo[pcvt_kbd_rptr++];
			s = spltty();
			pcvt_kbd_count--;
			splx(s);
			if (pcvt_kbd_rptr >= PCVT_KBD_FIFO_SZ)
				pcvt_kbd_rptr = 0;
		}

#else /* !PCVT_KB_FIFO */

	/* see if there is data from the keyboard available from the 8042 */
	if (inb(CONTROLLER_CTRL) & STATUS_OUTPBF) {
		PCVT_KBD_DELAY();		/* 7 us delay */
		dt = inb(CONTROLLER_DATA);	/* yes, get data */
#endif /* !PCVT_KBD_FIFO */


		if ((dt == KEYB_R_ACK) || (dt == KEYB_R_RESEND))
			update_led(dt); /* handle ACK/NACK correctly in X */

		/*
		 * If x mode is active, only care for locking keys, then
		 * return the scan code instead of any key translation.
		 * Additionally, this prevents us from any attempts to
		 * execute pcvt internal functions caused by keys (such
		 * as screen flipping).
		 */
 		if (vsp->kbd_state == K_RAW) {
			keybuf[0] = dt;
			return ((u_char *)keybuf);
		}
	}

#else /* !XSERVER */

#  if PCVT_KBD_FIFO

	/* see if there is data from the keyboard available either from */
	/* the keyboard fifo or from the 8042 keyboard controller	*/

	if ((( noblock) && (pcvt_kbd_count)) ||
	    ((!noblock) && (inb(CONTROLLER_CTRL) & STATUS_OUTPBF))) {
		if (!noblock) {		/* source = 8042 */
			PCVT_KBD_DELAY();	/* 7 us delay */
			dt = inb(CONTROLLER_DATA);
		}
		else {			/* source = keyboard fifo */
			dt = pcvt_kbd_fifo[pcvt_kbd_rptr++]; /* yes, get it ! */
			s = spltty();
			pcvt_kbd_count--;
			splx(s);
			if (pcvt_kbd_rptr >= PCVT_KBD_FIFO_SZ)
				pcvt_kbd_rptr = 0;
		}
	}

#else /* !PCVT_KBD_FIFO */

	/* see if there is data from the keyboard available from the 8042 */
	if (inb(CONTROLLER_CTRL) & STATUS_OUTPBF) {
		PCVT_KBD_DELAY();		/* 7 us delay */
		dt = inb(CONTROLLER_DATA);	/* yes, get data ! */
	}

#endif /* !PCVT_KBD_FIFO */

#endif /* !XSERVER */

	else {
		if (noblock)
			return (NULL);
		else
			goto loop;
	}

	/* lets look what we got */
	switch (dt) {
	case KEYB_R_ACK:	/* acknowledge after command has rx'd*/
	case KEYB_R_RESEND:	/* keyboard wants us to resend cmnd */
		update_led(dt);	/* handle ACK/NACK correctly, no X */
		break;
	case KEYB_R_OVERRUN0:	/* keyboard buffer overflow */
#if PCVT_SCANSET == 2
	case KEYB_R_SELFOK:	/* keyboard selftest ok */
#endif /* PCVT_SCANSET == 2 */
	case KEYB_R_ECHO:	/* keyboard response to KEYB_C_ECHO */
	case KEYB_R_SELFBAD:	/* keyboard selftest FAILED */
	case KEYB_R_DIAGBAD:	/* keyboard self diagnostic failure */
	case KEYB_R_OVERRUN1:	/* keyboard buffer overflow */
		break;

	case KEYB_R_EXT1:	/* keyboard extended scancode pfx 2 */
		kbd_status.ext1 = 1;
		/* FALLTHROUGH */

	case KEYB_R_EXT0:	/* keyboard extended scancode pfx 1 */
		kbd_status.extended = 1;
		break;

#if PCVT_SCANSET == 2
	case KEYB_R_BREAKPFX:	/* break code prefix for set 2 and 3 */
		kbd_status.breakseen = 1;
		break;
#endif /* PCVT_SCANSET == 2 */

	default:
		goto regular;	/* regular key */
	}

	if (noblock)
		return (NULL);
	else
		goto loop;

	/* got a normal scan key */
regular:
#if PCVT_SCANSET == 1
	kbd_status.breakseen = dt & 0x80 ? 1 : 0;
	dt &= 0x7f;
#endif	/* PCVT_SCANSET == 1 */

	/*   make a keycode from scan code	*/
	if (dt >= sizeof scantokey / sizeof(u_char))
		key = 0;
	else
		key = kbd_status.extended ? extscantokey[dt] : scantokey[dt];

	if (kbd_status.ext1 && key == 64)
		/* virtual control key */
		key = 129;

	kbd_status.extended = kbd_status.ext1 = 0;

	if ((key == 85) && shift_down &&
	    (kbd_lastkey != 85 || !kbd_status.breakseen)) {
		/* removing of visual regions for mouse console support */
		if (IS_SEL_EXISTS(vsp)) 
			remove_selection(); /* remove current selection before 
					       leaving this screen */
		if (IS_MOUSE_VISIBLE(vsp)) {
			mouse_hide();
			vsp->mouse_flags &= ~MOUSE_VISIBLE;
		}
		/* end of visual regions part */
		if (vsp->scr_offset && vsp->scr_offset >= vsp->row) {
			if (!vsp->scrolling) {
				vsp->scrolling += vsp->row - 1;
				if (vsp->Scrollback) {
					scrollback_save_screen();
					if (vsp->scr_offset == vsp->max_off) {
						bcopy(vsp->Scrollback +
						      vsp->maxcol,
						      vsp->Scrollback,
						      vsp->maxcol *
						      vsp->max_off * CHR);
						vsp->scr_offset--;
					}
					bcopy(vsp->Crtat + vsp->cur_offset -
					      vsp->col, vsp->Scrollback +
				      	      (vsp->scr_offset + 1) *
					      vsp->maxcol, vsp->maxcol * CHR);
				}

				if (vsp->cursor_on)
					sw_cursor(0);
			}

			vsp->scrolling += vsp->screen_rows - 1;
			if (vsp->scrolling > vsp->scr_offset)
				vsp->scrolling = vsp->scr_offset;

			bcopy(vsp->Scrollback + ((vsp->scr_offset -
			      vsp->scrolling) * vsp->maxcol), vsp->Crtat,
			      vsp->screen_rows * vsp->maxcol * CHR);
		}

		kbd_lastkey = 85;
		goto loop;
	}
	else if ((key == 86) && shift_down &&
		(kbd_lastkey != 86 || !kbd_status.breakseen)) {
scroll_reset:
		/* removing of visual regions for mouse console support */
		if (IS_SEL_EXISTS(vsp)) 
			remove_selection(); /* remove current selection before 
					       leaving this screen */
		if (IS_MOUSE_VISIBLE(vsp)) {
			mouse_hide();
			vsp->mouse_flags &= ~MOUSE_VISIBLE;
		}
		/* end of visual regions part */
		if (vsp->scrolling > 0) {
			vsp->scrolling -= vsp->screen_rows - 1;
			if (vsp->scrolling < 0)
				vsp->scrolling = 0;

			if (vsp->scrolling <= vsp->row) {
				vsp->scrolling = 0;
				scrollback_restore_screen();
			}
			else {
				if (vsp->scrolling + 2 < vsp->screen_rows)
					fillw(user_attr | ' ',
					      (caddr_t)vsp->Crtat,
					      vsp->screen_rows * vsp->maxcol);

				bcopy(vsp->Scrollback + ((vsp->scr_offset -
			      	      vsp->scrolling) * vsp->maxcol),
			              vsp->Crtat, (vsp->scrolling + 2 <
				      vsp->screen_rows ? vsp->scrolling + 2 :
				      vsp->screen_rows) * vsp->maxcol * CHR);
			}
		}

		if (vsp->scrolling == 0) {
			if (vsp->cursor_on)
				sw_cursor(1);
		}

		if (noblock == 31337)
			return (NULL);

		if (key != 86)
			goto regular;
		else {
			kbd_lastkey = 86;
			goto loop;
		}
	}
	else if (vsp->scrolling && key != 128 && key != 44 && key != 57 &&
		 key != 85 && key != 86) {
			vsp->scrolling = 1;
			goto scroll_reset;
	     }

	if (kbd_reset && (key == 76) && ctrl_down && (meta_down||altgr_down)) {
		printf("\nconsole halt requested: going down.\n");
		kbd_reset = 0;
		psignal(initproc, SIGUSR1);
	}

#if NDDB > 0 || defined(DDB)		 /*   Check for cntl-alt-esc	*/
  	if ((key == 110) && ctrl_down && (meta_down || altgr_down)) {
 		static u_char in_Debugger;

 		if (!in_Debugger) {
 			in_Debugger = 1;
			if (db_console)
	 			Debugger();
 			in_Debugger = 0;

 			if (noblock)
 				return (NULL);
 			else
 				goto loop;
 		}
 	}
#endif /* NDDB > 0 || defined(DDB) */

	/* look for keys with special handling */
	if (key == 128) {
		/*
		 * virtual shift; sent around PrtScr, and around the arrow
		 * keys if the NumLck LED is on
		 */
		kbd_status.vshift = !kbd_status.breakseen;
		key = 0;	/* no key */
	}
	else if (key == 129) {
		/*
		 * virtual control - the most ugly thingie at all
		 * the Pause key sends:
		 * <virtual control make> <numlock make> <virtual control
		 * break> <numlock break>
		 */
		if (!kbd_status.breakseen)
			kbd_status.vcontrol = 1;
		/* else: let the numlock hook clear this */
		key = 0;	/* no key */
	}
	else if (key == 90) {
		/* NumLock, look whether this is rather a Pause */
		if (kbd_status.vcontrol)
			key = 126;
		/*
		 * if this is the final break code of a Pause key,
		 * clear the virtual control status, too
		 */
		if (kbd_status.vcontrol && kbd_status.breakseen)
			kbd_status.vcontrol = 0;
	}
	else if (key == 127) {
		/*
		 * a SysRq; some keyboards are brain-dead enough to
		 * repeat the SysRq key make code by sending PrtScr
		 * make codes; other keyboards do not repeat SysRq
		 * at all. We keep track of the SysRq state here.
		 */
		kbd_status.sysrq = !kbd_status.breakseen;
	}
	else if (key == 124) {
		/*
		 * PrtScr; look whether this is really PrtScr or rather
		 * a silly repeat of a SysRq key
		 */
		if (kbd_status.sysrq)
			/* ignore the garbage */
			key = 0;
	}

	/* in NOREPEAT MODE ignore the key if it was the same as before */

	if (!kbrepflag && key == kbd_lastkey && !kbd_status.breakseen) {
		if (noblock)
			return (NULL);
		else
			goto loop;
	}

	type = key2ascii[key].type;

	if (type & KBD_OVERLOAD)
		type = ovltbl[key2ascii[key].ovlindex].type;

	type &= KBD_MASK;

	keybuf[0] = 0;
	switch (type) {
	case KBD_SHFTLOCK:
		if (!kbd_status.breakseen && key != kbd_lastkey)
			vsp->shift_lock ^= 1;
		break;

	case KBD_CAPS:
		if (!kbd_status.breakseen && key != kbd_lastkey) {
			vsp->caps_lock ^= 1;
			update_led(KBD_CAPS);
		}
		break;

	case KBD_SCROLL:
		if (!kbd_status.breakseen && key != kbd_lastkey) {
			vsp->scroll_lock ^= 1;
			update_led(KBD_SCROLL);

			if (!(vsp->scroll_lock))
				keybuf[0] = CSTART;
			else
				keybuf[0] = CSTOP;
		}
		break;

	case KBD_SHIFT:
		shift_down = kbd_status.breakseen ? 0 : 1;
		break;

	case KBD_META:
		meta_down = kbd_status.breakseen ? 0 : 0x80;
		break;

	case KBD_ALTGR:
		altgr_down = kbd_status.breakseen ? 0 : 1;
		break;

	case KBD_CTL:
		ctrl_down = kbd_status.breakseen ? 0 : 1;
		break;

	case KBD_NONE:
	default:
		break;			/* deliver a key */
	}

	if (kbd_status.breakseen) {
		key |= 0x80;
		kbd_status.breakseen = 0;
		kbd_lastkey = 0; /* -hv- I know this is a bug with */
	}			 /* N-Key-Rollover, but I ignore that */
	else			 /* because avoidance is too complicated */
		kbd_lastkey = key;

	cp = xlatkey2ascii(key);	/* have a key */

	if (cp)                         /* link ^S/^Q to scrlck led */
		if (((*cp == CSTOP) && (!vsp->scroll_lock)) ||
		    ((*cp == CSTART) && (vsp->scroll_lock))) {
			vsp->scroll_lock ^= 1;
			update_led(KBD_SCROLL);
		}

	if (keybuf[0])                  /* XON/XOFF scrlck emul. */
		cp = (u_char *)keybuf;

	if (cp == NULL && !noblock)
		goto loop;

	return (cp);
}

/*---------------------------------------------------------------------------*
 *	reflect status of locking keys & set led's
 *---------------------------------------------------------------------------*/
static void
setlockkeys(int snc)
{
	vsp->scroll_lock = snc & 1;
	vsp->num_lock	 = (snc & 2) ? 1 : 0;
	vsp->caps_lock	 = (snc & 4) ? 1 : 0;
	update_led(1);
}

/*---------------------------------------------------------------------------*
 *	remove a key definition
 *---------------------------------------------------------------------------*/
static int
rmkeydef(int key)
{
	register Ovl_tbl *ref;

	if (key == 0 || key > MAXKEYNUM)
		return (EINVAL);

	if (key2ascii[key].type & KBD_OVERLOAD) {
		ref = &ovltbl[key2ascii[key].ovlindex];
		ref->keynum = 0;
		ref->type = 0;
		ref->unshift[0] =
		ref->shift[0] =
		ref->ctrl[0] =
		ref->altgr[0] = 0;
		key2ascii[key].type &= KBD_MASK;
	}
	return (0);
}

/*---------------------------------------------------------------------------*
 *	overlay a key
 *---------------------------------------------------------------------------*/
static int
setkeydef(Ovl_tbl *data)
{
	int i;

	if ( data->keynum > MAXKEYNUM		 ||
	    (data->type & KBD_MASK) == KBD_BREAK ||
	    (data->type & KBD_MASK) > KBD_SHFTLOCK)
		return (EINVAL);

	data->unshift[KBDMAXOVLKEYSIZE] =
	data->shift[KBDMAXOVLKEYSIZE] =
	data->ctrl[KBDMAXOVLKEYSIZE] =
	data->altgr[KBDMAXOVLKEYSIZE] = 0;

	data->subu =
	data->subs =
	data->subc =
	data->suba = KBD_SUBT_STR;		/* just strings .. */

	data->type |= KBD_OVERLOAD;		/* mark overloaded */

	/* if key already overloaded, use that slot else find free slot */

	if (key2ascii[data->keynum].type & KBD_OVERLOAD)
		i = key2ascii[data->keynum].ovlindex;
	else {
		for (i = 0; i < OVLTBL_SIZE; i++)
			if (ovltbl[i].keynum==0)
				break;

		if (i == OVLTBL_SIZE)
			return (ENOSPC); /* no space, abuse of ENOSPC(!) */
	}

	ovltbl[i] = *data;		/* copy new data string */

	key2ascii[data->keynum].type |= KBD_OVERLOAD; 	/* mark key */
	key2ascii[data->keynum].ovlindex = i;

	return (0);
}

/*---------------------------------------------------------------------------*
 *	keyboard ioctl's entry
 *---------------------------------------------------------------------------*/
int
kbdioctl(Dev_t dev, u_long cmd, caddr_t data, int flag)
{
	int key;

	switch (cmd) {
	case KBDRESET:
		doreset();
		ovlinit(1);
		settpmrate(KBD_TPD500 | KBD_TPM100);
		setlockkeys(0);
		break;

	case KBDGTPMAT:
		*(int *)data = tpmrate;
		break;

	case KBDSTPMAT:
		settpmrate(*(int *)data);
		break;

	case KBDGREPSW:
		*(int *)data = kbrepflag;
		break;

	case KBDSREPSW:
		kbrepflag = (*(int *)data) & 1;
		break;

	case KBDGLOCK:
		*(int *)data = ( (vsp->scroll_lock) | (vsp->num_lock * 2) |
				 (vsp->caps_lock * 4));
		break;

	case KBDSLOCK:
		setlockkeys(*(int *)data);
		break;

	case KBDGCKEY:
		key = ((Ovl_tbl *)data)->keynum;
		return (getckeydef(key,(Ovl_tbl *)data));

	case KBDSCKEY:
		key = ((Ovl_tbl *)data)->keynum;
		return (setkeydef((Ovl_tbl *)data));

	case KBDGOKEY:
		key = ((Ovl_tbl *)data)->keynum;
		return (getokeydef(key,(Ovl_tbl *)data));

	case KBDRMKEY:
		key = *(int *)data;
		return (rmkeydef(key));

	case KBDDEFAULT:
		ovlinit(1);
		break;

	default:
		/* proceed with vga ioctls */
		return (-1);
	}
	return (0);
}

/*---------------------------------------------------------------------------*
 *	convert ISO-8859 style keycode into IBM 437
 *---------------------------------------------------------------------------*/
static inline u_char
iso2ibm(u_char c)
{
	if (c < 0x80)
		return (c);
	return (iso2ibm437[c - 0x80]);
}

/*---------------------------------------------------------------------------*
 *	build up a USL style keyboard map
 *---------------------------------------------------------------------------*/
void
get_usl_keymap(keymap_t *map)
{
	int i;

	bzero((caddr_t)map, sizeof(keymap_t));

	map->n_keys = 0x59;	/* that many keys we know about */

	for(i = 1; i < N_KEYNUMS; i++) {
		Ovl_tbl kdef;
		u_char c;
		int j;
		int idx = key2scan1[i];

		if (idx == 0 || idx >= map->n_keys)
			continue;

		getckeydef(i, &kdef);
		kdef.type &= KBD_MASK;

		switch (kdef.type) {
		case KBD_ASCII:
		case KBD_RETURN:
			map->key[idx].map[0] = iso2ibm(kdef.unshift[0]);
			map->key[idx].map[1] = iso2ibm(kdef.shift[0]);
			map->key[idx].map[2] = map->key[idx].map[3] =
				iso2ibm(kdef.ctrl[0]);
			map->key[idx].map[4] = map->key[idx].map[5] =
				iso2ibm(c = kdef.altgr[0]);
			/*
			 * XXX this is a hack
			 * since we currently do not map strings to AltGr +
			 * shift, we attempt to use the unshifted AltGr
			 * definition here and try to toggle the case
			 * this should at least work for ISO8859 letters,
			 * but also for (e.g.) russian KOI-8 style
			 */
			if ((c & 0x7f) >= 0x40)
				map->key[idx].map[5] = iso2ibm(c ^ 0x20);
			break;

		case KBD_FUNC:
			/* we are only interested in F1 thru F12 here */
			if (i >= 112 && i <= 123) {
				map->key[idx].map[0] = i - 112 + 27;
				map->key[idx].spcl = 0x80;
			}
			break;

		case KBD_SHIFT:
			c = i == 44 ? 2 /* lSh */ : 3 /* rSh */;
			goto special;

		case KBD_CAPS:
			c = 4;
			goto special;

		case KBD_NUM:
			c = 5;
			goto special;

		case KBD_SCROLL:
			c = 6;
			goto special;

		case KBD_META:
			c = 7;
			goto special;

		case KBD_CTL:
			c = 9;
special:
			for(j = 0; j < NUM_STATES; j++)
				map->key[idx].map[j] = c;
			map->key[idx].spcl = 0xff;
			break;

		default:
			break;
		}
	}
}

/*---------------------------------------------------------------------------*
 *	switch keypad to numeric mode
 *---------------------------------------------------------------------------*/
void
vt_keynum(struct video_state *svsp)
{
	svsp->num_lock = 1;
	update_led(1);
}

/*---------------------------------------------------------------------------*
 *	switch keypad to application mode
 *---------------------------------------------------------------------------*/
void
vt_keyappl(struct video_state *svsp)
{
	svsp->num_lock = 0;
	update_led(1);
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 1
 *---------------------------------------------------------------------------*/
static void
fkey1(void)
{
	if (meta_down)
		more_chars = (u_char *)"\033[23~"; /* F11 */
	else
		more_chars = (u_char *)"\033OP"; /* F1 */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 2
 *---------------------------------------------------------------------------*/
static void
fkey2(void)
{
	if (meta_down)
		more_chars = (u_char *)"\033[24~"; /* F12 */
	else
		more_chars = (u_char *)"\033OQ"; /* F2 */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 3
 *---------------------------------------------------------------------------*/
static void
fkey3(void)
{
	if (meta_down)
		more_chars = (u_char *)"\033[25~"; /* F13 */
	else
		more_chars = (u_char *)"\033OR"; /* F3 */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 4
 *---------------------------------------------------------------------------*/
static void
fkey4(void)
{
	if (meta_down)
		more_chars = (u_char *)"\033[26~"; /* F14 */
	else
		more_chars = (u_char *)"\033OS"; /* F4 */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 5
 *---------------------------------------------------------------------------*/
static void
fkey5(void)
{
	if (meta_down)
		more_chars = (u_char *)"\033[28~"; /* Help */
	else
		more_chars = (u_char *)"\033[17~"; /* F5 */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 6
 *---------------------------------------------------------------------------*/
static void
fkey6(void)
{
	if (meta_down)
		more_chars = (u_char *)"\033[29~"; /* DO */
	else
		more_chars = (u_char *)"\033[18~"; /* F6 */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 7
 *---------------------------------------------------------------------------*/
static void
fkey7(void)
{
	if (meta_down)
		more_chars = (u_char *)"\033[31~"; /* F17 */
	else
		more_chars = (u_char *)"\033[19~"; /* F7 */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 8
 *---------------------------------------------------------------------------*/
static void
fkey8(void)
{
	if (meta_down)
		more_chars = (u_char *)"\033[32~"; /* F18 */
	else
		more_chars = (u_char *)"\033[20~"; /* F8 */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 9
 *---------------------------------------------------------------------------*/
static void
fkey9(void)
{
	if (meta_down)
		more_chars = (u_char *)"\033[33~"; /* F19 */
	else
		more_chars = (u_char *)"\033[21~"; /* F9 */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 10
 *---------------------------------------------------------------------------*/
static void
fkey10(void)
{
	if (meta_down)
		more_chars = (u_char *)"\033[34~"; /* F20 */
	else
		more_chars = (u_char *)"\033[29~"; /* F10 */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 11
 *---------------------------------------------------------------------------*/
static void
fkey11(void)
{
	if (meta_down)
		more_chars = (u_char *)"\0x8FP"; /* PF1 */
	else
		more_chars = (u_char *)"\033[23~"; /* F11 */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 12
 *---------------------------------------------------------------------------*/
static void
fkey12(void)
{
	if (meta_down)
		more_chars = (u_char *)"\0x8FQ"; /* PF2 */
	else
		more_chars = (u_char *)"\033[24~"; /* F12 */
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 1
 *---------------------------------------------------------------------------*/
static void
sfkey1(void)
{
	if (meta_down) {
		if (vsp->ukt.length[6])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[6]]);
		else
			more_chars = (u_char *)"\033[23~"; /* F11 */
	}
	else
		do_vgapage(4);
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 2
 *---------------------------------------------------------------------------*/
static void
sfkey2(void)
{
	if (meta_down) {
		if (vsp->ukt.length[7])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[7]]);
		else
			more_chars = (u_char *)"\033[24~"; /* F12 */
	}
	else
		do_vgapage(5);
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 3
 *---------------------------------------------------------------------------*/
static void
sfkey3(void)
{
	if (meta_down) {
		if (vsp->ukt.length[8])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[8]]);
		else
			more_chars = (u_char *)"\033[25~"; /* F13 */
	}
	else
		do_vgapage(6);
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 4
 *---------------------------------------------------------------------------*/
static void
sfkey4(void)
{
	if (meta_down) {
		if (vsp->ukt.length[9])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[9]]);
		else
			more_chars = (u_char *)"\033[26~"; /* F14 */
	}
	else
		do_vgapage(7);
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 5
 *---------------------------------------------------------------------------*/
static void
sfkey5(void)
{
	if (meta_down) {
		if (vsp->ukt.length[11])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[11]]);
		else
			more_chars = (u_char *)"\033[28~"; /* Help */
	}
	else {
		if (current_video_screen <= 0)
			do_vgapage(totalscreens-1);
		else
			do_vgapage(current_video_screen - 1);
	}
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 6
 *---------------------------------------------------------------------------*/
static void
sfkey6(void)
{
	if (!meta_down) {
		if (vsp->ukt.length[0])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[0]]);
		else
			more_chars = (u_char *)"\033[17~"; /* F6 */
	}
	else if (vsp->ukt.length[12])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[12]]);
	     else
			more_chars = (u_char *)"\033[29~"; /* DO */
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 7
 *---------------------------------------------------------------------------*/
static void
sfkey7(void)
{
	if (!meta_down) {
		if (vsp->ukt.length[1])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[1]]);
		else
			more_chars = (u_char *)"\033[18~"; /* F7 */
	}
	else if (vsp->ukt.length[14])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[14]]);
	     else
			more_chars = (u_char *)"\033[31~"; /* F17 */
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 8
 *---------------------------------------------------------------------------*/
static void
sfkey8(void)
{
	if (!meta_down) {
		if (vsp->ukt.length[2])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[2]]);
		else
			more_chars = (u_char *)"\033[19~"; /* F8 */
	}
	else if (vsp->ukt.length[14])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[15]]);
	     else
			more_chars = (u_char *)"\033[32~"; /* F18 */
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 9
 *---------------------------------------------------------------------------*/
static void
sfkey9(void)
{
	if (!meta_down) {
		if (vsp->ukt.length[3])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[3]]);
		else
			more_chars = (u_char *)"\033[20~"; /* F9 */
	}
	else if (vsp->ukt.length[16])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[16]]);
	     else
			more_chars = (u_char *)"\033[33~"; /* F19 */
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 10
 *---------------------------------------------------------------------------*/
static void
sfkey10(void)
{
	if (!meta_down) {
		if (vsp->ukt.length[4])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[4]]);
		else
			more_chars = (u_char *)"\033[21~"; /* F10 */
	}
	else if (vsp->ukt.length[17])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[17]]);
	     else
			more_chars = (u_char *)"\033[34~"; /* F20 */
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 11
 *---------------------------------------------------------------------------*/
static void
sfkey11(void)
{
	if (!meta_down) {
		if (vsp->ukt.length[6])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[6]]);
		else
			more_chars = (u_char *)"\033[23~"; /* F11 */
	}
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 12
 *---------------------------------------------------------------------------*/
static void
sfkey12(void)
{
	if (!meta_down) {
		if (vsp->ukt.length[7])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[7]]);
		else
			more_chars = (u_char *)"\033[24~"; /* F12 */
	}
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 1
 *---------------------------------------------------------------------------*/
static void
cfkey1(void)
{
	if (meta_down)
		do_vgapage(0);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 2
 *---------------------------------------------------------------------------*/
static void
cfkey2(void)
{
	if (meta_down)
		do_vgapage(1);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 3
 *---------------------------------------------------------------------------*/
static void
cfkey3(void)
{
	if (meta_down)
		do_vgapage(2);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 4
 *---------------------------------------------------------------------------*/
static void
cfkey4(void)
{
	if (meta_down)
		do_vgapage(3);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 5
 *---------------------------------------------------------------------------*/
static void
cfkey5(void)
{
	if (meta_down)
		do_vgapage(4);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 6
 *---------------------------------------------------------------------------*/
static void
cfkey6(void)
{
	if (meta_down)
		do_vgapage(5);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 7
 *---------------------------------------------------------------------------*/
static void
cfkey7(void)
{
	if (meta_down)
		do_vgapage(6);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 8
 *---------------------------------------------------------------------------*/
static void
cfkey8(void)
{
	if (meta_down)
		do_vgapage(7);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 9
 *---------------------------------------------------------------------------*/
static void
cfkey9(void)
{
	if (meta_down)
		do_vgapage(8);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 10
 *---------------------------------------------------------------------------*/
static void
cfkey10(void)
{
	if (meta_down)
		do_vgapage(9);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 11
 *---------------------------------------------------------------------------*/
static void
cfkey11(void)
{
	if (meta_down)
		do_vgapage(10);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 12
 *---------------------------------------------------------------------------*/
static void
cfkey12(void)
{
	if (meta_down)
		do_vgapage(11);
}

/* #endif */	/* NVT > 0 */

static void
scrollback_save_screen(void)
{
	int x = spltty();
	register size_t s;

	s = sizeof(u_short) * vsp->screen_rowsize * vsp->maxcol;

	if (scrollback_savedscreen)
		free(scrollback_savedscreen, M_TEMP);

	scrnsv_size = s;

	if (!(scrollback_savedscreen = (u_short *)malloc(s, M_TEMP, M_NOWAIT))){
		splx(x);
		return;
	}
	bcopy(vsp->Crtat, scrollback_savedscreen, scrnsv_size);
	splx(x);
}

static void
scrollback_restore_screen(void)
{
	if (scrollback_savedscreen)
		bcopy(scrollback_savedscreen, vsp->Crtat, scrnsv_size);
}

/*
 * Function to handle the wheel
 * z == 1 means to scroll to the lower page
 * z == -1 means to scroll to the upper page
 */

void
scrollback_mouse(int z)
{

	/* removing of visual regions for mouse console support */
	
	if (IS_SEL_EXISTS(vsp)) {
		remove_selection(); /* remove current selection before 
				       leaving this screen */
		vsp->mouse_flags &= ~SEL_EXISTS;
	}
	if (IS_MOUSE_VISIBLE(vsp)) {
		mouse_hide();
		vsp->mouse_flags &= ~MOUSE_VISIBLE;
	}
		
	if (z <= -1)
		
	{
		if (vsp->scr_offset && vsp->scr_offset >= vsp->row) {
			if (!vsp->scrolling) {
				vsp->scrolling += vsp->row - 1;
				if (vsp->Scrollback) {
					scrollback_save_screen();
					if (vsp->scr_offset == vsp->max_off) {
						bcopy(vsp->Scrollback +
						      vsp->maxcol,
						      vsp->Scrollback,
						      vsp->maxcol *
						      vsp->max_off * CHR);
						vsp->scr_offset--;
					}
					bcopy(vsp->Crtat + vsp->cur_offset -
					      vsp->col, vsp->Scrollback +
				      	      (vsp->scr_offset + 1) *
					      vsp->maxcol, vsp->maxcol * CHR);
				}

				if (vsp->cursor_on)
					sw_cursor(0);
			}

			vsp->scrolling += vsp->screen_rows - 1;
			if (vsp->scrolling > vsp->scr_offset) {
				vsp->scrolling = vsp->scr_offset;
			}
				
			bcopy(vsp->Scrollback + ((vsp->scr_offset -
			      vsp->scrolling) * vsp->maxcol), vsp->Crtat,
			      vsp->screen_rows * vsp->maxcol * CHR);
		}
	}
	else /* positive z */	
	{
		if (IS_SEL_EXISTS(vsp)) {
			remove_selection();
			vsp->mouse_flags &= ~SEL_EXISTS;
		}
		if (vsp->scrolling > 0) {
			vsp->scrolling -= vsp->screen_rows - 1;
			if (vsp->scrolling < 0)
				vsp->scrolling = 0;

			if (vsp->scrolling <= vsp->row) {
				vsp->scrolling = 0;
				scrollback_restore_screen();
			}
			else {
				if (vsp->scrolling + 2 < vsp->screen_rows)
					fillw(user_attr | ' ',
					      (caddr_t)vsp->Crtat,
					      vsp->screen_rows * vsp->maxcol);

				bcopy(vsp->Scrollback + ((vsp->scr_offset -
			      	      vsp->scrolling) * vsp->maxcol),
			              vsp->Crtat, (vsp->scrolling + 2 <
				      vsp->screen_rows ? vsp->scrolling + 2 :
				      vsp->screen_rows) * vsp->maxcol * CHR);
			}
		}
		if (vsp->scrolling == 0) {
			if (vsp->cursor_on)
				sw_cursor(1);
		}
	}
}
/* ------------------------------- EOF -------------------------------------*/
@


1.41
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.40 2001/01/22 18:48:43 deraadt Exp $	*/
@


1.40
log
@keyboard led update lockup patch; pr 1432, smat@@acm.org
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.39 2000/10/16 02:25:22 aaron Exp $	*/
d632 3
a634 4
		if (ovlinitflag == 0 &&
		   (ovltbl = (Ovl_tbl *)malloc(sizeof(Ovl_tbl) * OVLTBL_SIZE,
					       M_DEVBUF, M_WAITOK)) == NULL)
			panic("pcvt_kbd: malloc of Ovl_tbl failed");
@


1.39
log
@Restore conversion to new timeouts (art@@'s previous commit). They were
whacked by the initial commit for console mouse support. jbm must have been
working with an older revision of PCVT (argh, sorry, should have noticed
this long ago).
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.38 2000/10/11 21:24:28 aaron Exp $	*/
d79 1
d83 1
d173 1
d193 1
a193 1
update_led(void)
d198 3
a200 1
	int opri, new_ledstate, response1, response2;
d205 1
a205 1

d207 15
a221 4
		ledstate = LEDSTATE_UPDATE_PENDING;

		if (kbd_cmd(KEYB_C_LEDS) != 0) {
			printf("pcvt: kbd led cmd timeout\n");
d246 3
a248 1
		response1 = kbd_response();
d250 12
a261 2
		if (kbd_cmd(new_ledstate) != 0) {
			printf("pcvt: kbd led data timeout\n");
a263 1
		response2 = kbd_response();
d265 1
a265 1
		if (response1 == KEYB_R_ACK && response2 == KEYB_R_ACK)
d267 1
a267 3
		else {
			printf("pcvt: kbd led cmd not ack'd (resp %#x %#x)\n",
			    response1, response2);
d273 1
d275 1
d913 1
a913 1
			update_led();
a970 1
#ifdef XSERVER
a971 1
#endif /* XSERVER */
d1019 4
d1080 4
a1088 1
	case KEYB_R_ACK:	/* acknowledge after command has rx'd*/
a1090 1
	case KEYB_R_RESEND:	/* keyboard wants us to resend cmnd */
d1329 1
d1339 1
a1339 1
			update_led();
d1346 1
a1346 1
			update_led();
d1349 3
a1351 1
				wakeup((caddr_t)&(vsp->scroll_lock));
d1386 10
d1411 1
a1411 1
	update_led();
d1657 1
a1657 1
	update_led();
d1667 1
a1667 1
	update_led();
@


1.38
log
@Fix a bogus scan code in pcvt_kbd.h that was preventing the RIGHT_SHIFT+PGUP/DN
key combo to activate scrollback in the console.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.37 2000/10/07 03:12:46 aaron Exp $	*/
d172 1
a172 1
static int lost_intr_timeout_queued = 0;
a176 1
	lost_intr_timeout_queued = 0;
d246 1
a246 5
		if (lost_intr_timeout_queued)
			untimeout(check_for_lost_intr, (void *)NULL);

		timeout(check_for_lost_intr, (void *)NULL, hz);
		lost_intr_timeout_queued = 1;
d579 3
@


1.37
log
@- Add console/X mouse transparency, so you don't have to kill moused to run X.
- Introduce `select units' (by char/word/line). Behaves more like an xterm now.
- Serial mice should now work after this commit.
- Many bug fixes.

Work by Jean-Baptiste.Marchand@@epita.fr, except for the X cohabitation code
which was written by Julien.Montagne@@epita.fr.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.36 2000/09/01 05:46:02 aaron Exp $	*/
d1203 2
a1204 2
	else if (vsp->scrolling && key != 128 && key != 44 && key != 85 &&
		 key != 86) {
@


1.36
log
@Kernel support for new PCVT console mouse features.

- Basic cut/paste functionality.
- Wheel mouse support (wheel rolls page-by-page through scrollback buffer).
- Copybuffer ownership. i.e., if User X logs in the console and selects text,
  when User Y logs in later the buffer cannot be pasted.

Big thanks to Jean-Baptiste Marchand, Julien Montagne, and Jerome Verdon for
implementing this.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.34 2000/02/28 02:39:15 aaron Exp $	*/
d1110 1
a1110 1
		if (IS_SEL_EXISTS(vsp)) {
a1112 2
			vsp->mouse_flags &= ~SEL_EXISTS;
		}
d1157 1
a1157 1
		if (IS_SEL_EXISTS(vsp)) {
a1159 2
			vsp->mouse_flags &= ~SEL_EXISTS;
		}
@


1.35
log
@Use new timeouts for the led intr timeout.
@
text
@d172 1
a172 1
struct timeout kbd_led_intr_to;
d177 1
d247 5
a251 1
		timeout_add(&kbd_led_intr_to, hz);
a583 3
#if !PCVT_NO_LED_UPDATE && PCVT_UPDLED_LOSES_INTR
	timeout_set(&kbd_led_intr_to, check_for_lost_intr, NULL);
#endif
d1109 11
d1158 11
d2145 92
@


1.34
log
@Don't let scrollback happen if scr_offset == 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.33 2000/02/27 20:34:36 aaron Exp $	*/
d172 1
a172 1
static int lost_intr_timeout_queued = 0;
a176 1
	lost_intr_timeout_queued = 0;
d246 1
a246 5
		if (lost_intr_timeout_queued)
			untimeout(check_for_lost_intr, (void *)NULL);

		timeout(check_for_lost_intr, (void *)NULL, hz);
		lost_intr_timeout_queued = 1;
d579 3
@


1.33
log
@Fix a minor off-by-one error.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.32 2000/01/18 19:34:41 aaron Exp $	*/
d1109 1
a1109 1
		if (vsp->scr_offset >= vsp->row) {
@


1.32
log
@Change so unmodified function key presses are passed to the application. Match
function key output characters to those found for the vt220 terminal
description in the termcap database. This makes function keys work in Midnight
Commander, for example. While we're at it, remove the PCVT_VT220KEYB option
altogether.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.31 1999/11/27 21:39:29 aaron Exp $	*/
d1109 1
a1109 1
		if (vsp->scr_offset > vsp->row) {
@


1.32.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1109 1
a1109 1
		if (vsp->scr_offset && vsp->scr_offset >= vsp->row) {
@


1.32.2.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.40 2001/01/22 18:48:43 deraadt Exp $	*/
a78 1
#include <sys/ttydefaults.h>	/* CSTOP, CSTART for XON/XOFF scrlck emul. */
a81 1
#define LEDSTATE_UPDATING	(1 << 4)
a170 1
 /* Previous comment obsolete, update_led() now interrupt driven */
d172 1
a172 1
struct timeout kbd_led_intr_to;
d177 1
d191 1
a191 1
update_led(u_char cause)
d196 1
a196 3
	int opri, new_ledstate;

	if (!keyboard_type) return; /* allow disconnected kbd operation */
d201 1
a201 1
#if 0
d203 4
a206 15
#endif	/* because of switch_screen() and vgapage() changes */
		if ((cause == KBD_SCROLL) || (cause == KBD_NUM) ||
		    (cause == KBD_CAPS) ||
		    ((cause == 1) && (!do_initialization)) ||
		    ((cause == 2) && (!do_initialization)) ||
		    ((cause == KEYB_R_RESEND) &&
		    (ledstate == LEDSTATE_UPDATE_PENDING))) {

			if (kbd_cmd(KEYB_C_LEDS) != 0) {
				printf("pcvt: kbd led cmd timeout\n");
				goto bail;
			}
			ledstate = LEDSTATE_UPDATE_PENDING;
			if (cause == KEYB_R_RESEND)
				printf("pcvt: kbd led cmd resend\n");
d231 1
a231 3
		/*
		 * Previous comment obsolete, update_led() now interrupt driven
		 */
d233 2
a234 12
		if (((cause == KEYB_R_ACK) &&
			(ledstate == LEDSTATE_UPDATE_PENDING)) ||
		    ((cause == KEYB_R_RESEND) &&
			(ledstate == LEDSTATE_UPDATING))) {

			if (kbd_cmd(new_ledstate) != 0) {
				printf("pcvt: kbd led data timeout\n");
				goto bail;
			}
			ledstate = LEDSTATE_UPDATING;
			if (cause == KEYB_R_RESEND)
				printf("pcvt:kbd led data resend\n");
d237 1
d239 1
a239 1
		if ((cause == KEYB_R_ACK) && (ledstate == LEDSTATE_UPDATING)) {
d241 3
a243 1
			goto bail;
d247 5
a251 1
		timeout_add(&kbd_led_intr_to, hz);
a252 1
#if 0
a253 1
#endif	/* because of switch_screen() and vgapage() changes */
a583 3
#if !PCVT_NO_LED_UPDATE && PCVT_UPDLED_LOSES_INTR
	timeout_set(&kbd_led_intr_to, check_for_lost_intr, NULL);
#endif
d888 1
a888 1
			update_led(KBD_NUM);
d946 1
d948 1
a995 4

		if ((dt == KEYB_R_ACK) || (dt == KEYB_R_RESEND))
			update_led(dt); /* handle ACK/NACK correctly in X */

a1052 4
	case KEYB_R_ACK:	/* acknowledge after command has rx'd*/
	case KEYB_R_RESEND:	/* keyboard wants us to resend cmnd */
		update_led(dt);	/* handle ACK/NACK correctly, no X */
		break;
d1058 1
d1061 1
a1108 9
		/* removing of visual regions for mouse console support */
		if (IS_SEL_EXISTS(vsp)) 
			remove_selection(); /* remove current selection before 
					       leaving this screen */
		if (IS_MOUSE_VISIBLE(vsp)) {
			mouse_hide();
			vsp->mouse_flags &= ~MOUSE_VISIBLE;
		}
		/* end of visual regions part */
a1146 9
		/* removing of visual regions for mouse console support */
		if (IS_SEL_EXISTS(vsp)) 
			remove_selection(); /* remove current selection before 
					       leaving this screen */
		if (IS_MOUSE_VISIBLE(vsp)) {
			mouse_hide();
			vsp->mouse_flags &= ~MOUSE_VISIBLE;
		}
		/* end of visual regions part */
d1185 2
a1186 2
	else if (vsp->scrolling && key != 128 && key != 44 && key != 57 &&
		 key != 85 && key != 86) {
a1281 1
	keybuf[0] = 0;
d1291 1
a1291 1
			update_led(KBD_CAPS);
d1298 1
a1298 1
			update_led(KBD_SCROLL);
d1301 1
a1301 3
				keybuf[0] = CSTART;
			else
				keybuf[0] = CSTOP;
a1335 10
	if (cp)                         /* link ^S/^Q to scrlck led */
		if (((*cp == CSTOP) && (!vsp->scroll_lock)) ||
		    ((*cp == CSTART) && (vsp->scroll_lock))) {
			vsp->scroll_lock ^= 1;
			update_led(KBD_SCROLL);
		}

	if (keybuf[0])                  /* XON/XOFF scrlck emul. */
		cp = (u_char *)keybuf;

d1351 1
a1351 1
	update_led(1);
d1597 1
a1597 1
	update_led(1);
d1607 1
a1607 1
	update_led(1);
a2122 92
/*
 * Function to handle the wheel
 * z == 1 means to scroll to the lower page
 * z == -1 means to scroll to the upper page
 */

void
scrollback_mouse(int z)
{

	/* removing of visual regions for mouse console support */
	
	if (IS_SEL_EXISTS(vsp)) {
		remove_selection(); /* remove current selection before 
				       leaving this screen */
		vsp->mouse_flags &= ~SEL_EXISTS;
	}
	if (IS_MOUSE_VISIBLE(vsp)) {
		mouse_hide();
		vsp->mouse_flags &= ~MOUSE_VISIBLE;
	}
		
	if (z <= -1)
		
	{
		if (vsp->scr_offset && vsp->scr_offset >= vsp->row) {
			if (!vsp->scrolling) {
				vsp->scrolling += vsp->row - 1;
				if (vsp->Scrollback) {
					scrollback_save_screen();
					if (vsp->scr_offset == vsp->max_off) {
						bcopy(vsp->Scrollback +
						      vsp->maxcol,
						      vsp->Scrollback,
						      vsp->maxcol *
						      vsp->max_off * CHR);
						vsp->scr_offset--;
					}
					bcopy(vsp->Crtat + vsp->cur_offset -
					      vsp->col, vsp->Scrollback +
				      	      (vsp->scr_offset + 1) *
					      vsp->maxcol, vsp->maxcol * CHR);
				}

				if (vsp->cursor_on)
					sw_cursor(0);
			}

			vsp->scrolling += vsp->screen_rows - 1;
			if (vsp->scrolling > vsp->scr_offset) {
				vsp->scrolling = vsp->scr_offset;
			}
				
			bcopy(vsp->Scrollback + ((vsp->scr_offset -
			      vsp->scrolling) * vsp->maxcol), vsp->Crtat,
			      vsp->screen_rows * vsp->maxcol * CHR);
		}
	}
	else /* positive z */	
	{
		if (IS_SEL_EXISTS(vsp)) {
			remove_selection();
			vsp->mouse_flags &= ~SEL_EXISTS;
		}
		if (vsp->scrolling > 0) {
			vsp->scrolling -= vsp->screen_rows - 1;
			if (vsp->scrolling < 0)
				vsp->scrolling = 0;

			if (vsp->scrolling <= vsp->row) {
				vsp->scrolling = 0;
				scrollback_restore_screen();
			}
			else {
				if (vsp->scrolling + 2 < vsp->screen_rows)
					fillw(user_attr | ' ',
					      (caddr_t)vsp->Crtat,
					      vsp->screen_rows * vsp->maxcol);

				bcopy(vsp->Scrollback + ((vsp->scr_offset -
			      	      vsp->scrolling) * vsp->maxcol),
			              vsp->Crtat, (vsp->scrolling + 2 <
				      vsp->screen_rows ? vsp->scrolling + 2 :
				      vsp->screen_rows) * vsp->maxcol * CHR);
			}
		}
		if (vsp->scrolling == 0) {
			if (vsp->cursor_on)
				sw_cursor(1);
		}
	}
}
@


1.32.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.32.2.2 2001/04/18 16:07:58 niklas Exp $	*/
@


1.31
log
@Shorten printf() strings, KNF, and fix a braino in a switch() statement.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.30 1999/11/25 21:00:36 aaron Exp $	*/
a1609 443
#if !PCVT_VT220KEYB	/* !PCVT_VT220KEYB, HP-like Keyboard layout */

/*---------------------------------------------------------------------------*
 *	function bound to function key 1
 *---------------------------------------------------------------------------*/
static void
fkey1(void)
{
	if (!meta_down)
		more_chars = (u_char *)"\033[17~";	/* F6 */
	else
		more_chars = (u_char *)"\033[26~";	/* F14 */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 2
 *---------------------------------------------------------------------------*/
static void
fkey2(void)
{
	if (!meta_down)
		more_chars = (u_char *)"\033[18~";	/* F7 */
	else
		more_chars = (u_char *)"\033[28~";	/* HELP */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 3
 *---------------------------------------------------------------------------*/
static void
fkey3(void)
{
	if (!meta_down)
		more_chars = (u_char *)"\033[19~";	/* F8 */
	else
		more_chars = (u_char *)"\033[29~";	/* DO */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 4
 *---------------------------------------------------------------------------*/
static void
fkey4(void)
{
	if (!meta_down)
		more_chars = (u_char *)"\033[20~";	/* F9 */
	else
		more_chars = (u_char *)"\033[31~";	/* F17 */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 5
 *---------------------------------------------------------------------------*/
static void
fkey5(void)
{
	if (!meta_down)
		more_chars = (u_char *)"\033[21~";	/* F10 */
	else
		more_chars = (u_char *)"\033[32~";	/* F18 */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 6
 *---------------------------------------------------------------------------*/
static void
fkey6(void)
{
	if (!meta_down)
		more_chars = (u_char *)"\033[23~";	/* F11 */
	else
		more_chars = (u_char *)"\033[33~";	/* F19 */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 7
 *---------------------------------------------------------------------------*/
static void
fkey7(void)
{
	if (!meta_down)
		more_chars = (u_char *)"\033[24~";	/* F12 */
	else
		more_chars = (u_char *)"\033[34~";	/* F20 */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 8
 *---------------------------------------------------------------------------*/
static void
fkey8(void)
{
	if (!meta_down)
		more_chars = (u_char *)"\033[25~";	/* F13 */
	else
		more_chars = (u_char *)"\033[35~";	/* F21 ??!! */
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 9
 *---------------------------------------------------------------------------*/
static void
fkey9(void)
{
	if (meta_down)
		return;
	else
		do_vgapage(0);
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 10
 *---------------------------------------------------------------------------*/
static void
fkey10(void)
{
	if (!meta_down)
		do_vgapage(1);
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 11
 *---------------------------------------------------------------------------*/
static void
fkey11(void)
{
	do_vgapage(2);
}

/*---------------------------------------------------------------------------*
 *	function bound to function key 12
 *---------------------------------------------------------------------------*/
static void
fkey12(void)
{
	if (meta_down) {
		if (current_video_screen + 1 > totalscreens-1)
			do_vgapage(0);
		else
			do_vgapage(current_video_screen + 1);
	}
	else {
		do_vgapage(3);
	}
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 1
 *---------------------------------------------------------------------------*/
static void
sfkey1(void)
{
	if (!meta_down) {
		if (vsp->ukt.length[0])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[0]]);
	}
	else {
		if (vsp->ukt.length[9])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[9]]);
	}
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 2
 *---------------------------------------------------------------------------*/
static void
sfkey2(void)
{
	if (!meta_down) {
		if (vsp->ukt.length[1])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[1]]);
	}
	else {
		if (vsp->ukt.length[11])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[11]]);
	}
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 3
 *---------------------------------------------------------------------------*/
static void
sfkey3(void)
{
	if (!meta_down) {
		if (vsp->ukt.length[2])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[2]]);
	}
	else {
		if (vsp->ukt.length[12])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[12]]);
	}
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 4
 *---------------------------------------------------------------------------*/
static void
sfkey4(void)
{
	if (!meta_down) {
		if (vsp->ukt.length[3])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[3]]);
	}
	else {
		if (vsp->ukt.length[13])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[13]]);
	}
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 5
 *---------------------------------------------------------------------------*/
static void
sfkey5(void)
{
	if (!meta_down) {
		if (vsp->ukt.length[4])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[4]]);
	}
	else {
		if (vsp->ukt.length[14])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[14]]);
	}
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 6
 *---------------------------------------------------------------------------*/
static void
sfkey6(void)
{
	if (!meta_down) {
		if (vsp->ukt.length[6])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[6]]);
	}
	else {
		if (vsp->ukt.length[15])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[15]]);
	}
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 7
 *---------------------------------------------------------------------------*/
static void
sfkey7(void)
{
	if (!meta_down) {
		if (vsp->ukt.length[7])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[7]]);
	}
	else {
		if (vsp->ukt.length[16])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[16]]);
	}
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 8
 *---------------------------------------------------------------------------*/
static void
sfkey8(void)
{
	if (!meta_down) {
		if (vsp->ukt.length[8])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[8]]);
	}
	else {
		if (vsp->ukt.length[17])	/* entry available ? */
			more_chars = (u_char *)
				&(vsp->udkbuf[vsp->ukt.first[17]]);
	}
}
/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 9
 *---------------------------------------------------------------------------*/
static void
sfkey9(void)
{
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 10
 *---------------------------------------------------------------------------*/
static void
sfkey10(void)
{
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 11
 *---------------------------------------------------------------------------*/
static void
sfkey11(void)
{
}

/*---------------------------------------------------------------------------*
 *	function bound to SHIFTED function key 12
 *---------------------------------------------------------------------------*/
static void
sfkey12(void)
{
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 1
 *---------------------------------------------------------------------------*/
static void
cfkey1(void)
{
	if (meta_down)
		do_vgapage(0);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 2
 *---------------------------------------------------------------------------*/
static void
cfkey2(void)
{
	if (meta_down)
		do_vgapage(1);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 3
 *---------------------------------------------------------------------------*/
static void
cfkey3(void)
{
	if (meta_down)
		do_vgapage(2);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 4
 *---------------------------------------------------------------------------*/
static void
cfkey4(void)
{
	if (meta_down)
		do_vgapage(3);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 5
 *---------------------------------------------------------------------------*/
static void
cfkey5(void)
{
	if (meta_down)
		do_vgapage(4);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 6
 *---------------------------------------------------------------------------*/
static void
cfkey6(void)
{
	if (meta_down)
		do_vgapage(5);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 7
 *---------------------------------------------------------------------------*/
static void
cfkey7(void)
{
	if (meta_down)
		do_vgapage(6);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 8
 *---------------------------------------------------------------------------*/
static void
cfkey8(void)
{
	if (meta_down)
		do_vgapage(7);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 9
 *---------------------------------------------------------------------------*/
static void
cfkey9(void)
{
	if (meta_down)
		do_vgapage(8);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 10
 *---------------------------------------------------------------------------*/
static void
cfkey10(void)
{
	if (meta_down)
		do_vgapage(9);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 11
 *---------------------------------------------------------------------------*/
static void
cfkey11(void)
{
	if (meta_down)
		do_vgapage(10);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 12
 *---------------------------------------------------------------------------*/
static void
cfkey12(void)
{
	if (meta_down)
		do_vgapage(11);
}

#else	/* PCVT_VT220  -  VT220-like Keyboard layout */

d1619 1
a1619 1
		do_vgapage(0);
d1631 1
a1631 1
		do_vgapage(1);
d1643 1
a1643 1
		do_vgapage(2);
d1655 1
a1655 1
		do_vgapage(3);
d1666 2
a1667 6
	else {
		if ((current_video_screen + 1) > totalscreens-1)
			do_vgapage(0);
		else
			do_vgapage(current_video_screen + 1);
	}
d1679 1
a1679 1
		more_chars = (u_char *)"\033[17~"; /* F6 */
d1691 1
a1691 1
		more_chars = (u_char *)"\033[18~"; /* F7 */
d1703 1
a1703 1
		more_chars = (u_char *)"\033[19~"; /* F8 */
d1715 1
a1715 1
		more_chars = (u_char *)"\033[20~"; /* F9 */
d1727 1
a1727 1
		more_chars = (u_char *)"\033[21~"; /* F10 */
d1973 121
a2093 1
#endif	/* NVT > 0 */
@


1.30
log
@Whoops, didn't mean to step on espie's toes. Also restore some comments
that shouldn't have been removed.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.29 1999/11/25 20:24:21 aaron Exp $	*/
d206 2
a207 3
			printf("Keyboard LED command timeout\n");
			splx(opri);
			return;
d234 2
a235 3
			printf("Keyboard LED data timeout\n");
			splx(opri);
			return;
d241 4
a244 4
		else
			printf(
			"Keyboard LED command not ACKed (responses %#x %#x)\n",
				response1, response2);
d248 1
a248 1
			untimeout (check_for_lost_intr, (void *)NULL);
d250 1
a250 1
		timeout (check_for_lost_intr, (void *)NULL, hz);
a252 1

d254 1
d269 1
d271 1
a271 1
		printf("Keyboard TYPEMATIC command timeout\n");
d277 1
a277 1
		printf("Keyboard TYPEMATIC data timeout\n");
d283 1
a283 2
		printf(
		   "Keyboard TYPEMATIC command not ACKed (responses %#x %#x)\n",
a287 1
	return;
d302 1
a302 1
			return 1;
d306 1
a306 1
	return 0;
d318 1
a318 1
			return 1;
d322 1
a322 1
	return 0;
d361 1
a361 1
	return ch;
d408 1
a408 1
		printf("pcvt: doreset() - timeout controller write command\n");
d430 1
a430 1
		printf("pcvt: doreset() - timeout writing keyboard init command\n");
d450 1
a450 1
		printf("pcvt: doreset() - keyboard reset command timeout\n");
d456 1
a456 1
				printf("pcvt: doreset() - response != ack and response < 0 [one time only msg]\n");
d461 1
a461 1
				printf("pcvt: doreset() - got KEYB_R_RESEND response ... [one time only msg]\n");
d464 1
a464 1
				printf("pcvt: doreset() - Caution - no PC keyboard detected!\n");
d472 1
a472 1
				printf("pcvt: doreset() - timeout for loop keyboard reset command [one time only msg]\n");
d493 1
a493 1
			printf("pcvt: doreset() - response != OK and response < 0\n");
d517 1
a517 1
			printf("pcvt: doreset() - keyboard SCANSET command timeout\n");
d519 1
a519 1
			printf("pcvt: doreset() - keyboard SCANSET data timeout\n");
d521 1
a521 1
			printf("pcvt: doreset() - keyboard set to XT mode\n");
a523 1

a528 1

d532 1
a532 1
		printf("pcvt: doreset() - timeout for keyboard ID command\n");
d556 1
a556 1
				printf("\npcvt: doreset() - kbdid, response 2 = [%d]\n", response);
d565 2
a566 4
		else {
			printf("\npcvt: doreset() - kbdid, response 1 = [%d]\n",
			    response);
		}
d624 1
a624 1
		for(i=0; i<=MAXKEYNUM; i++)
d626 1
d638 1
a638 1
		return EINVAL;
a673 1

d683 1
a683 1
	return 0;
d695 1
a695 1
		return EINVAL;
d702 1
a702 1
	return 0;
d726 1
a726 1
		return 0;
d740 1
a740 1
				return capchar;
d743 1
a743 1
		return 0;
d838 1
a838 1
			return 0;
d921 1
a921 1
		return 0;
d1046 1
a1046 1
			return NULL;
d1084 1
a1084 1
		return NULL;
d1176 1
a1176 1
			return NULL;
d1208 1
a1208 1
 				return NULL;
d1270 1
a1270 1
			return NULL;
d1339 1
a1339 1
	return cp;
d1363 1
a1363 1
		return EINVAL;
d1375 1
a1375 1
	return 0;
d1389 1
a1389 1
		return EINVAL;
d1413 1
a1413 1
			return ENOSPC;	/* no space, abuse of ENOSPC(!) */
d1421 1
a1421 1
	return 0;
d1467 1
a1467 1
		return getckeydef(key,(Ovl_tbl *)data);
d1471 1
a1471 1
		return setkeydef((Ovl_tbl *)data);
d1475 1
a1475 1
		return getokeydef(key,(Ovl_tbl *)data);
d1479 1
a1479 1
		return rmkeydef(key);
d1487 1
a1487 1
		return -1;
d1489 1
a1489 1
	return 0;
d1499 2
a1500 2
		return c;
	return iso2ibm437[c - 0x80];
d1578 1
a1578 2
			goto special;
		special:
@


1.29
log
@Remove the keyboard mouse emulator, HP emulation mode, and PCVT_SHOWKEYS
debugging cruft. Also fix a bug where you were not able to hold down the
scrollback hotkeys.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.27 1999/10/07 02:43:08 aaron Exp $	*/
d1435 1
a1435 1
kbdioctl(Dev_t dev, int cmd, caddr_t data, int flag)
@


1.28
log
@ioctl arguments are u_long.
Replaces `undefined' code with `defined' behavior...

gcc 2.96 performs switch cases range analysis, warns about unreachable
cases, and weeds them out.

In

switch(i) {
case VALUE:
}

VALUE is first coerced into the type of i.  If i is signed, VALUE is
unsigned and exceeds i range, you lose... the result of the conversion
is undefined.
@
text
@d77 1
a77 1
#if NVT > 0
a98 1

a123 4
#if PCVT_SHOWKEYS
u_char rawkeybuf[80];
#endif

a125 33
#if PCVT_SHOWKEYS
/*---------------------------------------------------------------------------*
 *	keyboard debugging: put kbd communication char into some buffer
 *---------------------------------------------------------------------------*/
static void showkey (char delim, u_char val)
{
	int rki;

	for(rki = 3; rki < 80; rki++)		/* shift left buffer */
		rawkeybuf[rki-3] = rawkeybuf[rki];

	rawkeybuf[77] = delim;		/* delimiter */

	rki = (val & 0xf0) >> 4;	/* ms nibble */

	if(rki <= 9)
		rki = rki + '0';
	else
		rki = rki - 10 + 'A';

	rawkeybuf[78] = rki;

	rki = val & 0x0f;		/* ls nibble */

	if(rki <= 9)
		rki = rki + '0';
	else
		rki = rki - 10 + 'A';

	rawkeybuf[79] = rki;
}
#endif	/* PCVT_SHOWKEYS */

d132 1
a132 1
	if(critical_scroll)		/* executing critical region ? */
a137 1

d178 4
a181 5
	if (inb(CONTROLLER_CTRL) & STATUS_OUTPBF)
	{
		int opri = spltty ();
		(void) pcrint ();
		splx (opri);
a192 1

a193 1

d199 1
a199 2
	new_ledstate = ((vsp->scroll_lock) |
			(vsp->num_lock * 2) |
d202 1
a202 2
	if (new_ledstate != ledstate)
	{
d205 1
a205 2
		if (kbd_cmd(KEYB_C_LEDS) != 0)
		{
d273 1
a273 2
		splx(opri);
		return;
d279 1
a279 2
		splx(opri);
		return;
d288 1
d290 1
a330 1

a343 1

a347 4
#if PCVT_SHOWKEYS
	showkey ('>', val);
#endif	/* PCVT_SHOWKEYS */

a363 4
#if PCVT_SHOWKEYS
	showkey ('<', ch);
#endif	/* PCVT_SHOWKEYS */

d373 1
a373 3
#if PCVT_SCANSET > 1		/* switch only if we are running */
				/*           keyboard scancode 2 */

a374 1

d376 1
a376 1
	cmd =                  COMMAND_SYSFLG | COMMAND_IRQEN;
d381 1
a381 1
	if(mode == K_RAW)		/* switch to scancode 1 ? */
d389 1
a389 1
	if(mode == K_RAW)
d410 1
a410 1
	if(kbc_8042cmd(CONTR_WRITE) != 0)
d432 1
a432 1
	if(kbd_cmd(KBDINITCMD) != 0)
a449 1

d452 2
a453 2
	if(kbd_cmd(KEYB_C_RESET) != 0)
		printf("pcvt: doreset() - timeout for keyboard reset command\n");
d456 3
a458 5
	while((response = kbd_response()) != KEYB_R_ACK)
	{
		if(response < 0)
		{
			if(!again)	/* print message only once ! */
d462 2
a463 3
		if(response == KEYB_R_RESEND)
		{
			if(!again)	/* print message only once ! */
d466 1
a466 2
			if(++again > PCVT_NONRESP_KEYB_TRY)
			{
d473 1
a473 2
			if((kbd_cmd(KEYB_C_RESET) != 0) && (once == 0))
			{
d484 1
a484 2
	while((response = kbd_response()) != KEYB_R_SELFOK)
	{
d492 1
a492 1
		if(response < 0)
d495 1
a495 2
		if(seen_negative_response && (wait_retries >= 10))
		{
d518 1
a518 2
	if (!(response & COMMAND_PCSCAN))
	{
a527 1

d536 1
a536 2
	if(kbd_cmd(KEYB_C_ID) != 0)
	{
d540 1
a540 3
	else
	{

d542 1
a542 2
		if((response = kbd_response()) == KEYB_R_MF2ID1)
		{
d559 1
d566 1
a566 2
		else if(response == KEYB_R_ACK)
		{
d568 1
a568 3
		}
		else if(response == -1)
		{
d570 3
a572 4
		}
		else
		{
			printf("\npcvt: doreset() - kbdid, response 1 = [%d]\n", response);
a574 1

a577 1

a578 1

a579 1

d613 2
a614 3
	if(force || ovlinitflag==0)
	{
		if(ovlinitflag == 0 &&
d619 1
a619 2
		for(i=0; i<OVLTBL_SIZE; i++)
		{
d643 1
a643 1
	if(key == 0 || key > MAXKEYNUM)
d649 1
a649 2
	if(key2ascii[key].unshift.subtype == STR)
	{
d651 1
a651 1
		       thisdef->unshift, CODE_SIZE);
d654 1
a654 2
	else
	{
d659 1
a659 2
	if(key2ascii[key].shift.subtype == STR)
	{
d661 1
a661 1
		       thisdef->shift, CODE_SIZE);
d664 2
a665 3
	else
	{
		bcopy("",thisdef->shift,CODE_SIZE);
d669 1
a669 2
	if(key2ascii[key].ctrl.subtype == STR)
	{
d671 1
a671 1
		       thisdef->ctrl, CODE_SIZE);
d674 1
a674 2
	else
	{
d681 1
a681 2
	if(key2ascii[key].unshift.subtype == STR)
	{
d683 1
a683 1
		       thisdef->altgr, CODE_SIZE);
d686 2
a687 3
	else
	{
		bcopy("",thisdef->altgr, CODE_SIZE);
d701 1
a701 1
	if(key>MAXKEYNUM)
d704 1
a704 1
	if(type & KBD_OVERLOAD)
d719 1
d727 1
a727 3
	int		n;

    static u_char altgr_shft_key[KBDMAXOVLKEYSIZE];
d731 2
a732 1
	if(key==0)			/* ignore the NON-KEY */
d735 2
a736 1
	getckeydef(key&0x7F, &thisdef);	/* get the current ASCII value */
d740 1
a740 2
	if(key&0x80)			/* special handling of ALT-KEYPAD */
	{
d742 2
a743 4
		if(thisdef.type==KBD_META || thisdef.type==KBD_ALTGR)
		{
			if(altkpflag)	/* have we been in altkp mode? */
			{
d753 36
a788 7
	switch(thisdef.type)		/* convert the keys */
	{
		case KBD_BREAK:
		case KBD_ASCII:
		case KBD_FUNC:
			fnc = NULL;
			more_chars = NULL;
d790 2
a791 26
			if(altgr_down)
			{
                if(shift_down) /* XXX this is hack to support simple
                				AltGr + Shift remapping. This should work
                				for KOI-8 keymap style */
                {
                	altgr_shft_key[0] = *(u_char*)thisdef.altgr+040;
                	more_chars = (u_char*)altgr_shft_key;
                }
                else more_chars = (u_char *)thisdef.altgr;
			}
			else if(!ctrl_down && (shift_down || vsp->shift_lock))
			{
				if(key2ascii[key].shift.subtype == STR)
					more_chars = (u_char *)thisdef.shift;
				else
					fnc = key2ascii[key].shift.what.func;
			}

			else if(ctrl_down)
			{
				if(key2ascii[key].ctrl.subtype == STR)
					more_chars = (u_char *)thisdef.ctrl;
				else
					fnc = key2ascii[key].ctrl.what.func;
			}
d793 5
a797 6
			else
			{
				if(key2ascii[key].unshift.subtype == STR)
					more_chars = (u_char *)thisdef.unshift;
				else
					fnc = key2ascii[key].unshift.what.func;
d799 1
a799 14

			if(fnc)
				(*fnc)();	/* execute function */

			if((more_chars != NULL) && (more_chars[1] == 0))
			{
				if(vsp->caps_lock && more_chars[0] >= 'a'
				   && more_chars[0] <= 'z')
				{
					capchar[0] = *more_chars - ('a'-'A');
					more_chars = capchar;
				}
				if(meta_down)
				{
d801 1
a801 1
					metachar[1] = *more_chars;
d803 1
a803 1
					metachar[0] = *more_chars | 0x80;
d805 1
a805 2
					more_chars = metachar;
				}
d807 13
a819 1
			return(more_chars);
d821 9
a829 26
		case KBD_KP:
			fnc = NULL;
			more_chars = NULL;

			if(meta_down)
			{
				switch(key)
				{
					case 95:	/* / */
						altkpflag = 0;
						more_chars =
						 (u_char *)"\033OQ";
						return(more_chars);

					case 100:	/* * */
						altkpflag = 0;
						more_chars =
						 (u_char *)"\033OR";
						return(more_chars);

					case 105:	/* - */
						altkpflag = 0;
						more_chars =
						 (u_char *)"\033OS";
						return(more_chars);
				}
d831 1
d833 6
a838 12
			if(meta_down || altgr_down)
			{
				if((n = keypad2num[key-91]) >= 0)
				{
					if(!altkpflag)
					{
						/* start ALT-KP mode */
						altkpflag = 1;
						altkpval = 0;
					}
					altkpval *= 10;
					altkpval += n;
d840 2
a841 3
				else
					altkpflag = 0;
				return 0;
d843 4
d848 9
a856 7
			if(!(vsp->num_lock))
			{
				if(key2ascii[key].shift.subtype == STR)
					more_chars = (u_char *)thisdef.shift;
				else
					fnc = key2ascii[key].shift.what.func;
			}
d858 2
a859 6
			{
				if(key2ascii[key].unshift.subtype == STR)
					more_chars = (u_char *)thisdef.unshift;
				else
					fnc = key2ascii[key].unshift.what.func;
			}
d861 2
a862 22
			if(fnc)
				(*fnc)();	/* execute function */
			return(more_chars);

		case KBD_CURSOR:
			fnc = NULL;
			more_chars = NULL;

			if(vsp->ckm)
			{
				if(key2ascii[key].shift.subtype == STR)
					more_chars = (u_char *)thisdef.shift;
				else
					fnc = key2ascii[key].shift.what.func;
			}
			else
			{
				if(key2ascii[key].unshift.subtype == STR)
					more_chars = (u_char *)thisdef.unshift;
				else
					fnc = key2ascii[key].unshift.what.func;
			}
d864 1
a864 17
			if(fnc)
				(*fnc)();	/* execute function */
			return(more_chars);

		case KBD_NUM:		/*  special kp-num handling */
			more_chars = NULL;

			if(meta_down)
			{
				more_chars = (u_char *)"\033OP"; /* PF1 */
			}
			else
			{
				vsp->num_lock ^= 1;
				update_led();
			}
			return(more_chars);
d866 3
a868 2
		case KBD_RETURN:
			more_chars = NULL;
d870 2
a871 2
			if(!(vsp->num_lock))
			{
a872 1
			}
d874 4
a877 1
			{
d879 32
a910 7
			}
			if(vsp->lnm && (*more_chars == '\r'))
			{
				more_chars = (u_char *)"\r\n"; /* CR LF */
			}
			if(meta_down)
			{
d912 1
a912 1
				metachar[1] = *more_chars;
d914 1
a914 1
				metachar[0] = *more_chars | 0x80;
d916 3
a918 3
				more_chars = metachar;
			}
			return(more_chars);
d920 9
a928 9
		case KBD_META:		/* these keys are	*/
		case KBD_ALTGR:		/*  handled directly	*/
		case KBD_SCROLL:	/*  by the keyboard	*/
		case KBD_CAPS:		/*  handler - they are	*/
		case KBD_SHFTLOCK:	/*  ignored here	*/
		case KBD_CTL:
		case KBD_NONE:
		default:
			return 0;
a946 5
	u_char		*cp;
	u_char		dt;
	u_char		key;
	u_short		type;

d950 6
d957 1
a957 4
	static u_char	kbd_lastkey = 0; /* last keystroke */

	static struct
	{
a965 4
#ifdef XSERVER
	static char	keybuf[2] = {0}; /* the second 0 is a delimiter! */
#endif /* XSERVER */

d981 2
a982 4
	    ((!noblock) && (inb(CONTROLLER_CTRL) & STATUS_OUTPBF)))
	{
		if (!noblock)		/* source = 8042 */
		{
d986 1
a986 2
		else			/* source = keyboard fifo */
		{
d998 1
a998 3

	if (inb(CONTROLLER_CTRL) & STATUS_OUTPBF)
	{
a1000 1

d1010 1
a1010 3

 		if (vsp->kbd_state == K_RAW)
		{
a1011 228

#if PCVT_EMU_MOUSE
			/*
			 * The (mouse systems) mouse emulator. The mouse
			 * device allocates the first device node that is
			 * not used by a virtual terminal. (E.g., you have
			 * eight vtys, /dev/ttyv0 thru /dev/ttyv7, so the
			 * mouse emulator were /dev/ttyv8.)
			 * Currently the emulator only works if the keyboard
			 * is in raw (PC scan code) mode. This is the typic-
			 * al case when running the X server.
			 * It is activated if the num locks LED is active
			 * for the current vty, and if the mouse device
			 * has been opened by at least one process. It
			 * grabs the numerical keypad events (but only
			 * the "non-extended", so the separate arrow keys
			 * continue to work), and three keys for the "mouse
			 * buttons", preferrably F1 thru F3. Any of the
			 * eight directions (N, NE, E, SE, S, SW, W, NW)
			 * is supported, and frequent key presses (less
			 * than e.g. half a second between key presses)
			 * cause the emulator to accelerate the pointer
			 * movement by 6, while single presses result in
			 * single moves, so each point can be reached.
			 */
			/*
			 * NB: the following code is spagghetti.
			 * Only eat it with lotta tomato ketchup and
			 * Parmesan cheese:-)
			 */
			/*
			 * look whether we will have to steal the keys
			 * and cook them into mouse events
			 */
			if(vsp->num_lock && mouse.opened)
			{
				int button, accel, i;
				enum mouse_dir
				{
					MOUSE_NW, MOUSE_N, MOUSE_NE,
					MOUSE_W,  MOUSE_0, MOUSE_E,
					MOUSE_SW, MOUSE_S, MOUSE_SE
				}
				move;
				struct timeval now;
				/* from sys/kern/kern_time.c */
				extern void timevalsub
					(struct timeval *, struct timeval *);
				dev_t dummy = makedev(0, mouse.minor);
				struct tty *mousetty = get_pccons(dummy);
				/*
				 * strings to send for each mouse event,
				 * indexed by the movement direction and
				 * the "accelerator" value (TRUE for frequent
				 * key presses); note that the first byte
				 * of each string is actually overwritten
				 * by the current button value before sending
				 * the string
				 */
				static u_char mousestrings[2][MOUSE_SE+1][5] =
				{
				{
					/* first, the non-accelerated strings*/
					{0x87,  -1,   1,   0,   0}, /* NW */
					{0x87,   0,   1,   0,   0}, /* N */
					{0x87,   1,   1,   0,   0}, /* NE */
					{0x87,  -1,   0,   0,   0}, /* W */
					{0x87,   0,   0,   0,   0}, /* 0 */
					{0x87,   1,   0,   0,   0}, /* E */
					{0x87,  -1,  -1,   0,   0}, /* SW */
					{0x87,   0,  -1,   0,   0}, /* S */
					{0x87,   1,  -1,   0,   0}  /* SE */
				},
				{
					/* now, 6 steps at once */
					{0x87,  -4,   4,   0,   0}, /* NW */
					{0x87,   0,   6,   0,   0}, /* N */
					{0x87,   4,   4,   0,   0}, /* NE */
					{0x87,  -6,   0,   0,   0}, /* W */
					{0x87,   0,   0,   0,   0}, /* 0 */
					{0x87,   6,   0,   0,   0}, /* E */
					{0x87,  -4,  -4,   0,   0}, /* SW */
					{0x87,   0,  -6,   0,   0}, /* S */
					{0x87,   4,  -4,   0,   0}  /* SE */
				}
				};

				if(dt == 0xe0)
				{
					/* ignore extended scan codes */
					mouse.extendedseen = 1;
					goto no_mouse_event;
				}
				if(mouse.extendedseen)
				{
					mouse.extendedseen = 0;
					goto no_mouse_event;
				}
				mouse.extendedseen = 0;

				/*
				 * Note that we cannot use a switch here
				 * since we want to have the keycodes in
				 * a variable
				 */
				if((dt & 0x7f) == mousedef.leftbutton) {
					button = 4;
					goto do_button;
				}
				else if((dt & 0x7f) == mousedef.middlebutton) {
					button = 2;
					goto do_button;
				}
				else if((dt & 0x7f) == mousedef.rightbutton) {
					button = 1;
				do_button:

					/*
					 * i would really like to give
					 * some acustical support
					 * (pling/plong); i am not sure
					 * whether it is safe to call
					 * sysbeep from within an intr
					 * service, since it calls
					 * timeout in turn which mani-
					 * pulates the spl mask - jw
					 */

# define PLING sysbeep(PCVT_SYSBEEPF / 1500, 2)
# define PLONG sysbeep(PCVT_SYSBEEPF / 1200, 2)

					if(mousedef.stickybuttons)
					{
						if(dt & 0x80) {
							mouse.breakseen = 1;
							return (u_char *)0;
						}
						else if(mouse.buttons == button
							&& !mouse.breakseen) {
							/* ignore repeats */
							return (u_char *)0;
						}
						else
							mouse.breakseen = 0;
						if(mouse.buttons == button) {
							/* release it */
							mouse.buttons = 0;
							PLONG;
						} else {
							/*
							 * eventually, release
							 * any other button,
							 * and stick this one
							 */
							mouse.buttons = button;
							PLING;
						}
					}
					else
					{
						if(dt & 0x80) {
							mouse.buttons &=
								~button;
							PLONG;
						}
						else if((mouse.buttons
							& button) == 0) {
							mouse.buttons |=
								button;
							PLING;
						}
						/*else: ignore same btn press*/
					}
					move = MOUSE_0;
					accel = 0;
				}
# undef PLING
# undef PLONG
				else switch(dt & 0x7f)
				{
				/* the arrow keys - KP 1 thru KP 9 */
				case 0x47:	move = MOUSE_NW; goto do_move;
				case 0x48:	move = MOUSE_N; goto do_move;
				case 0x49:	move = MOUSE_NE; goto do_move;
				case 0x4b:	move = MOUSE_W; goto do_move;
				case 0x4c:	move = MOUSE_0; goto do_move;
				case 0x4d:	move = MOUSE_E; goto do_move;
				case 0x4f:	move = MOUSE_SW; goto do_move;
				case 0x50:	move = MOUSE_S; goto do_move;
				case 0x51:	move = MOUSE_SE;
				do_move:
					if(dt & 0x80)
						/*
						 * arrow key break events are
						 * of no importance for us
						 */
						return (u_char *)0;
					/*
					 * see whether the last move did
					 * happen "recently", i.e. before
					 * less than half a second
					 */
					now = time;

					timersub(&now,&mouse.lastmove,&now);

					mouse.lastmove = time;
					accel = (now.tv_sec == 0
						 && now.tv_usec
						 < mousedef.acceltime);
					break;

				default: /* not a mouse-emulating key */
					goto no_mouse_event;
				}
				mousestrings[accel][move][0] =
					0x80 + (~mouse.buttons & 7);
				/* finally, send the string */
				for(i = 0; i < 5; i++)
					(*linesw[mousetty->t_line].l_rint)
						(mousestrings[accel][move][i],
						 mousetty);
				return (u_char *)0; /* not a kbd event */
			}
no_mouse_event:

#endif /* PCVT_EMU_MOUSE */

d1024 2
a1025 4
	    ((!noblock) && (inb(CONTROLLER_CTRL) & STATUS_OUTPBF)))
	{
		if (!noblock)		/* source = 8042 */
		{
d1029 1
a1029 2
		else			/* source = keyboard fifo */
		{
d1042 1
a1042 3

	if(inb(CONTROLLER_CTRL) & STATUS_OUTPBF)
	{
d1051 2
a1052 3
	else
	{
		if(noblock)
a1057 4
#if PCVT_SHOWKEYS
	showkey (' ', dt);
#endif /* PCVT_SHOWKEYS */

d1059 2
a1060 4
	switch(dt)
	{
		case KEYB_R_OVERRUN0:	/* keyboard buffer overflow */

d1062 1
a1062 1
		case KEYB_R_SELFOK:	/* keyboard selftest ok */
d1064 15
a1078 15

		case KEYB_R_ECHO:	/* keyboard response to KEYB_C_ECHO */
		case KEYB_R_ACK:	/* acknowledge after command has rx'd*/
		case KEYB_R_SELFBAD:	/* keyboard selftest FAILED */
		case KEYB_R_DIAGBAD:	/* keyboard self diagnostic failure */
		case KEYB_R_RESEND:	/* keyboard wants us to resend cmnd */
		case KEYB_R_OVERRUN1:	/* keyboard buffer overflow */
			break;

		case KEYB_R_EXT1:	/* keyboard extended scancode pfx 2 */
			kbd_status.ext1 = 1;
			/* FALLTHROUGH */
		case KEYB_R_EXT0:	/* keyboard extended scancode pfx 1 */
			kbd_status.extended = 1;
			break;
d1081 3
a1083 3
		case KEYB_R_BREAKPFX:	/* break code prefix for set 2 and 3 */
			kbd_status.breakseen = 1;
			break;
d1086 2
a1087 2
		default:
			goto regular;	/* regular key */
d1090 1
a1090 1
	if(noblock)
a1096 1

d1103 1
a1103 1
	if(dt >= sizeof scantokey / sizeof(u_char))
d1108 1
a1108 1
	if(kbd_status.ext1 && key == 64)
d1114 4
a1117 6
	if ((key == 85) && shift_down && kbd_lastkey != 85)
	{
		if (vsp->scr_offset > vsp->row)
		{
			if (!vsp->scrolling)
			{
d1119 1
a1119 2
				if (vsp->Scrollback)
				{
d1121 1
a1121 2
					if (vsp->scr_offset == vsp->max_off)
					{
d1151 2
a1152 2
	else if ((key == 86) && shift_down && kbd_lastkey != 86)
	     {
d1154 1
a1154 2
		if (vsp->scrolling > 0)
		{
d1159 1
a1159 2
			if (vsp->scrolling <= vsp->row)
			{
d1163 1
a1163 2
			else
			{
d1177 1
a1177 2
		if (vsp->scrolling == 0)
		{
a1178 1
			{
a1179 1
			}
d1187 1
a1187 2
		else
		{
d1193 1
a1193 2
		 key != 86)
	     {
d1198 1
a1198 1
	if(kbd_reset && (key == 76) && ctrl_down && (meta_down||altgr_down)) {
d1205 1
a1205 3

  	if((key == 110) && ctrl_down && (meta_down || altgr_down))
 	{
d1208 1
a1208 2
 		if(!in_Debugger)
 		{
d1213 2
a1214 1
 			if(noblock)
d1223 1
a1223 2
	if(key == 128)
	{
d1231 1
a1231 2
	else if(key == 129)
	{
d1238 1
a1238 1
		if(!kbd_status.breakseen)
d1243 1
a1243 2
	else if(key == 90)
	{
d1245 1
a1245 1
		if(kbd_status.vcontrol)
d1251 1
a1251 1
		if(kbd_status.vcontrol && kbd_status.breakseen)
d1254 1
a1254 2
	else if(key == 127)
	{
d1263 1
a1263 2
	else if(key == 124)
	{
d1268 1
a1268 1
		if(kbd_status.sysrq)
d1275 2
a1276 3
	if(!kbrepflag && key == kbd_lastkey && !kbd_status.breakseen)
	{
		if(noblock)
d1284 1
a1284 1
	if(type & KBD_OVERLOAD)
d1289 12
a1300 8
	switch(type)
	{
		case KBD_SHFTLOCK:
			if(!kbd_status.breakseen && key != kbd_lastkey)
			{
				vsp->shift_lock ^= 1;
			}
			break;
d1302 4
a1305 7
		case KBD_CAPS:
			if(!kbd_status.breakseen && key != kbd_lastkey)
			{
				vsp->caps_lock ^= 1;
				update_led();
			}
			break;
d1307 4
a1310 13
		case KBD_SCROLL:
			if(!kbd_status.breakseen && key != kbd_lastkey)
			{
				vsp->scroll_lock ^= 1;
				update_led();

				if(!(vsp->scroll_lock))
				{
					/* someone may be sleeping */
					wakeup((caddr_t)&(vsp->scroll_lock));
				}
			}
			break;
d1312 3
a1314 3
		case KBD_SHIFT:
			shift_down = kbd_status.breakseen ? 0 : 1;
			break;
d1316 3
a1318 3
		case KBD_META:
			meta_down = kbd_status.breakseen ? 0 : 0x80;
			break;
d1320 3
a1322 3
		case KBD_ALTGR:
			altgr_down = kbd_status.breakseen ? 0 : 1;
			break;
d1324 3
a1326 3
		case KBD_CTL:
			ctrl_down = kbd_status.breakseen ? 0 : 1;
			break;
d1328 3
a1330 3
		case KBD_NONE:
		default:
			break;			/* deliver a key */
d1333 1
a1333 2
	if(kbd_status.breakseen)
	{
d1343 1
a1343 1
	if(cp == NULL && !noblock)
d1369 1
a1369 1
	if(key==0 || key > MAXKEYNUM)
d1372 1
a1372 2
	if(key2ascii[key].type & KBD_OVERLOAD)
	{
d1393 1
a1393 1
	if( data->keynum > MAXKEYNUM		 ||
d1412 1
a1412 2
	if(key2ascii[data->keynum].type & KBD_OVERLOAD)
	{
d1414 3
a1416 5
	}
	else
	{
		for(i=0; i<OVLTBL_SIZE; i++)
			if(ovltbl[i].keynum==0)
d1419 1
a1419 1
		if(i==OVLTBL_SIZE)
d1435 1
a1435 1
kbdioctl(Dev_t dev, u_long cmd, caddr_t data, int flag)
d1439 56
a1494 58
	switch(cmd)
	{
		case KBDRESET:
			doreset();
			ovlinit(1);
			settpmrate(KBD_TPD500|KBD_TPM100);
			setlockkeys(0);
			break;

		case KBDGTPMAT:
			*(int *)data = tpmrate;
			break;

		case KBDSTPMAT:
			settpmrate(*(int *)data);
			break;

		case KBDGREPSW:
			*(int *)data = kbrepflag;
			break;

		case KBDSREPSW:
			kbrepflag = (*(int *)data) & 1;
			break;

		case KBDGLOCK:
			*(int *)data = ( (vsp->scroll_lock) |
					 (vsp->num_lock * 2) |
					 (vsp->caps_lock * 4));
			break;

		case KBDSLOCK:
			setlockkeys(*(int *)data);
			break;

		case KBDGCKEY:
			key = ((Ovl_tbl *)data)->keynum;
			return getckeydef(key,(Ovl_tbl *)data);

		case KBDSCKEY:
			key = ((Ovl_tbl *)data)->keynum;
			return setkeydef((Ovl_tbl *)data);

		case KBDGOKEY:
			key = ((Ovl_tbl *)data)->keynum;
			return getokeydef(key,(Ovl_tbl *)data);

		case KBDRMKEY:
			key = *(int *)data;
			return rmkeydef(key);

		case KBDDEFAULT:
			ovlinit(1);
			break;

		default:
			/* proceed with vga ioctls */
			return -1;
a1498 26
#if PCVT_EMU_MOUSE
/*--------------------------------------------------------------------------*
 *	mouse emulator ioctl
 *--------------------------------------------------------------------------*/
int
mouse_ioctl(Dev_t dev, int cmd, caddr_t data)
{
	struct mousedefs *def = (struct mousedefs *)data;

	switch(cmd)
	{
		case KBDMOUSEGET:
			*def = mousedef;
			break;

		case KBDMOUSESET:
			mousedef = *def;
			break;

		default:
			return -1;
	}
	return 0;
}
#endif	/* PCVT_EMU_MOUSE */

d1505 1
a1505 1
	if(c < 0x80)
d1522 1
a1522 2
	for(i = 1; i < N_KEYNUMS; i++)
	{
d1528 1
a1528 1
		if(idx == 0 || idx >= map->n_keys)
d1533 2
a1534 2
		switch(kdef.type)
		{
d1551 1
a1551 1
			if((c & 0x7f) >= 0x40)
d1557 1
a1557 1
			if(i >= 112 && i <= 123) {
d1564 2
a1565 1
			c = i == 44? 2 /* lSh */: 3 /* rSh */; goto special;
d1568 2
a1569 1
			c = 4; goto special;
d1572 2
a1573 1
			c = 5; goto special;
d1576 2
a1577 1
			c = 6; goto special;
d1580 2
a1581 1
			c = 7; goto special;
d1584 2
a1585 1
			c = 9; goto special;
d1626 2
a1627 8
	if(!meta_down)
	{
		if((vsp->vt_pure_mode == M_HPVT)
		   && (vsp->which_fkl == SYS_FKL))
			toggl_columns(vsp);
		else
			more_chars = (u_char *)"\033[17~";	/* F6 */
	}
d1629 1
a1629 5
	{
		if(vsp->vt_pure_mode == M_PUREVT
		   || (vsp->which_fkl == USR_FKL))
			more_chars = (u_char *)"\033[26~";	/* F14 */
	}
d1638 2
a1639 8
	if(!meta_down)
	{
		if((vsp->vt_pure_mode == M_HPVT)
		   && (vsp->which_fkl == SYS_FKL))
			vt_ris(vsp);
		else
			more_chars = (u_char *)"\033[18~";	/* F7 */
	}
d1641 1
a1641 5
	{
		if(vsp->vt_pure_mode == M_PUREVT
		   || (vsp->which_fkl == USR_FKL))
			more_chars = (u_char *)"\033[28~";	/* HELP */
	}
d1650 2
a1651 8
	if(!meta_down)
	{
		if((vsp->vt_pure_mode == M_HPVT)
		   && (vsp->which_fkl == SYS_FKL))
			toggl_24l(vsp);
		else
			more_chars = (u_char *)"\033[19~";	/* F8 */
	}
d1653 1
a1653 5
	{
		if(vsp->vt_pure_mode == M_PUREVT
		   || (vsp->which_fkl == USR_FKL))
			more_chars = (u_char *)"\033[29~";	/* DO */
	}
d1662 2
a1663 16
	if(!meta_down)
	{

#if PCVT_SHOWKEYS
		if((vsp->vt_pure_mode == M_HPVT)
		   && (vsp->which_fkl == SYS_FKL))
			toggl_kbddbg(vsp);
		else
			more_chars = (u_char *)"\033[20~";	/* F9 */
#else
		if(vsp->vt_pure_mode == M_PUREVT
		   || (vsp->which_fkl == USR_FKL))
			more_chars = (u_char *)"\033[20~";	/* F9 */
#endif /* PCVT_SHOWKEYS */

	}
d1665 1
a1665 5
	{
		if(vsp->vt_pure_mode == M_PUREVT
		   || (vsp->which_fkl == USR_FKL))
			more_chars = (u_char *)"\033[31~";	/* F17 */
	}
d1674 2
a1675 8
	if(!meta_down)
	{
		if((vsp->vt_pure_mode == M_HPVT)
		   && (vsp->which_fkl == SYS_FKL))
			toggl_bell(vsp);
		else
			more_chars = (u_char *)"\033[21~";	/* F10 */
	}
d1677 1
a1677 5
	{
		if(vsp->vt_pure_mode == M_PUREVT
		   || (vsp->which_fkl == USR_FKL))
			more_chars = (u_char *)"\033[32~";	/* F18 */
	}
d1686 2
a1687 8
	if(!meta_down)
	{
		if((vsp->vt_pure_mode == M_HPVT)
		   && (vsp->which_fkl == SYS_FKL))
			toggl_sevenbit(vsp);
		else
			more_chars = (u_char *)"\033[23~";	/* F11 */
	}
d1689 1
a1689 5
	{
		if(vsp->vt_pure_mode == M_PUREVT
		   || (vsp->which_fkl == USR_FKL))
			more_chars = (u_char *)"\033[33~";	/* F19 */
	}
d1698 2
a1699 8
	if(!meta_down)
	{
		if((vsp->vt_pure_mode == M_HPVT)
		   && (vsp->which_fkl == SYS_FKL))
			toggl_dspf(vsp);
		else
			more_chars = (u_char *)"\033[24~";	/* F12 */
	}
d1701 1
a1701 5
	{
		if(vsp->vt_pure_mode == M_PUREVT
		   || (vsp->which_fkl == USR_FKL))
			more_chars = (u_char *)"\033[34~";	/* F20 */
	}
d1710 2
a1711 8
	if(!meta_down)
	{
		if((vsp->vt_pure_mode == M_HPVT)
		   && (vsp->which_fkl == SYS_FKL))
			toggl_awm(vsp);
		else
			more_chars = (u_char *)"\033[25~";	/* F13 */
	}
d1713 1
a1713 5
	{
		if(vsp->vt_pure_mode == M_PUREVT
		   || (vsp->which_fkl == USR_FKL))
			more_chars = (u_char *)"\033[35~";	/* F21 ??!! */
	}
d1722 2
a1723 10
	if(meta_down)
	{
		if(vsp->vt_pure_mode == M_PUREVT)
			return;

		if(vsp->labels_on)	/* toggle label display on/off */
			fkl_off(vsp);
		else
			fkl_on(vsp);
	}
a1724 1
	{
a1725 1
	}
d1734 1
a1734 12
	if(meta_down)
	{
		if(vsp->vt_pure_mode != M_PUREVT && vsp->labels_on)
		{
			if(vsp->which_fkl == USR_FKL)
				sw_sfkl(vsp);
			else if(vsp->which_fkl == SYS_FKL)
				sw_ufkl(vsp);
		}
	}
	else
	{
a1735 1
	}
d1744 1
a1744 11
	if(meta_down)
	{
		if(vsp->vt_pure_mode == M_PUREVT)
			set_emulation_mode(vsp, M_HPVT);
		else if(vsp->vt_pure_mode == M_HPVT)
			set_emulation_mode(vsp, M_PUREVT);
	}
	else
	{
		do_vgapage(2);
	}
d1753 2
a1754 3
	if(meta_down)
	{
		if(current_video_screen + 1 > totalscreens-1)
d1759 1
a1759 2
	else
	{
d1770 2
a1771 3
	if(!meta_down)
	{
		if(vsp->ukt.length[0])	/* entry available ? */
d1775 2
a1776 3
	else
	{
		if(vsp->ukt.length[9])	/* entry available ? */
d1788 2
a1789 3
	if(!meta_down)
	{
		if(vsp->ukt.length[1])	/* entry available ? */
d1793 2
a1794 3
	else
	{
		if(vsp->ukt.length[11])	/* entry available ? */
d1806 2
a1807 3
	if(!meta_down)
	{
		if(vsp->ukt.length[2])	/* entry available ? */
d1811 2
a1812 3
	else
	{
		if(vsp->ukt.length[12])	/* entry available ? */
d1824 2
a1825 3
	if(!meta_down)
	{
		if(vsp->ukt.length[3])	/* entry available ? */
d1829 2
a1830 3
	else
	{
		if(vsp->ukt.length[13])	/* entry available ? */
d1842 2
a1843 3
	if(!meta_down)
	{
		if(vsp->ukt.length[4])	/* entry available ? */
d1847 2
a1848 3
	else
	{
		if(vsp->ukt.length[14])	/* entry available ? */
d1860 2
a1861 3
	if(!meta_down)
	{
		if(vsp->ukt.length[6])	/* entry available ? */
d1865 2
a1866 3
	else
	{
		if(vsp->ukt.length[15])	/* entry available ? */
d1878 2
a1879 3
	if(!meta_down)
	{
		if(vsp->ukt.length[7])	/* entry available ? */
d1883 2
a1884 3
	else
	{
		if(vsp->ukt.length[16])	/* entry available ? */
d1896 2
a1897 3
	if(!meta_down)
	{
		if(vsp->ukt.length[8])	/* entry available ? */
d1901 2
a1902 3
	else
	{
		if(vsp->ukt.length[17])	/* entry available ? */
d1945 1
a1945 1
	if(meta_down)
d1955 1
a1955 1
	if(meta_down)
d1965 1
a1965 1
	if(meta_down)
d1975 1
a1975 1
	if(meta_down)
d1985 1
a1985 1
	if(meta_down)
d1995 1
a1995 1
	if(meta_down)
d2005 1
a2005 1
	if(meta_down)
d2015 1
a2015 1
	if(meta_down)
d2025 1
a2025 1
	if(meta_down)
d2035 1
a2035 1
	if(meta_down)
d2045 1
a2045 1
	if(meta_down)
d2055 1
a2055 1
	if(meta_down)
d2067 1
a2067 1
	if(meta_down)
d2079 1
a2079 1
	if(meta_down)
d2091 1
a2091 1
	if(meta_down)
d2103 1
a2103 1
	if(meta_down)
d2115 1
a2115 1
	if(meta_down)
d2117 2
a2118 3
	else
	{
		if((current_video_screen + 1) > totalscreens-1)
d2131 1
a2131 1
	if(meta_down)
d2143 1
a2143 1
	if(meta_down)
d2155 1
a2155 1
	if(meta_down)
d2167 1
a2167 1
	if(meta_down)
d2179 1
a2179 1
	if(meta_down)
d2191 1
a2191 1
	if(meta_down)
d2203 1
a2203 1
	if(meta_down)
d2215 2
a2216 3
	if(meta_down)
	{
		if(vsp->ukt.length[6])	/* entry available ? */
a2222 1
	{
a2223 1
	}
d2232 2
a2233 3
	if(meta_down)
	{
		if(vsp->ukt.length[7])	/* entry available ? */
a2239 1
	{
a2240 1
	}
d2249 2
a2250 3
	if(meta_down)
	{
		if(vsp->ukt.length[8])	/* entry available ? */
a2256 1
	{
a2257 1
	}
d2266 2
a2267 3
	if(meta_down)
	{
		if(vsp->ukt.length[9])	/* entry available ? */
a2273 1
	{
a2274 1
	}
d2283 2
a2284 3
	if(meta_down)
	{
		if(vsp->ukt.length[11])	/* entry available ? */
d2290 2
a2291 3
	else
	{
		if(current_video_screen <= 0)
d2304 2
a2305 3
	if(!meta_down)
	{
		if(vsp->ukt.length[0])	/* entry available ? */
d2311 1
a2311 1
	else if(vsp->ukt.length[12])	/* entry available ? */
d2324 2
a2325 3
	if(!meta_down)
	{
		if(vsp->ukt.length[1])	/* entry available ? */
d2331 1
a2331 1
	else if(vsp->ukt.length[14])	/* entry available ? */
d2344 2
a2345 3
	if(!meta_down)
	{
		if(vsp->ukt.length[2])	/* entry available ? */
d2351 1
a2351 1
	else if(vsp->ukt.length[14])	/* entry available ? */
d2364 2
a2365 3
	if(!meta_down)
	{
		if(vsp->ukt.length[3])	/* entry available ? */
d2371 1
a2371 1
	else if(vsp->ukt.length[16])	/* entry available ? */
d2384 2
a2385 3
	if(!meta_down)
	{
		if(vsp->ukt.length[4])	/* entry available ? */
d2391 1
a2391 1
	else if(vsp->ukt.length[17])	/* entry available ? */
d2404 2
a2405 3
	if(!meta_down)
	{
		if(vsp->ukt.length[6])	/* entry available ? */
d2419 2
a2420 3
	if(!meta_down)
	{
		if(vsp->ukt.length[7])	/* entry available ? */
a2427 133
/*---------------------------------------------------------------------------*
 *	function bound to control function key 1
 *---------------------------------------------------------------------------*/
static void
cfkey1(void)
{
	if(vsp->which_fkl == SYS_FKL)
		toggl_columns(vsp);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 2
 *---------------------------------------------------------------------------*/
static void
cfkey2(void)
{
	if(vsp->which_fkl == SYS_FKL)
		vt_ris(vsp);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 3
 *---------------------------------------------------------------------------*/
static void
cfkey3(void)
{
	if(vsp->which_fkl == SYS_FKL)
		toggl_24l(vsp);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 4
 *---------------------------------------------------------------------------*/
static void
cfkey4(void)
{

#if PCVT_SHOWKEYS
	if(vsp->which_fkl == SYS_FKL)
		toggl_kbddbg(vsp);
#endif /* PCVT_SHOWKEYS */

}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 5
 *---------------------------------------------------------------------------*/
static void
cfkey5(void)
{
	if(vsp->which_fkl == SYS_FKL)
		toggl_bell(vsp);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 6
 *---------------------------------------------------------------------------*/
static void
cfkey6(void)
{
	if(vsp->which_fkl == SYS_FKL)
		toggl_sevenbit(vsp);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 7
 *---------------------------------------------------------------------------*/
static void
cfkey7(void)
{
	if(vsp->which_fkl == SYS_FKL)
		toggl_dspf(vsp);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 8
 *---------------------------------------------------------------------------*/
static void
cfkey8(void)
{
	if(vsp->which_fkl == SYS_FKL)
		toggl_awm(vsp);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 9
 *---------------------------------------------------------------------------*/
static void
cfkey9(void)
{
	if(vsp->labels_on)	/* toggle label display on/off */
	        fkl_off(vsp);
	else
	        fkl_on(vsp);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 10
 *---------------------------------------------------------------------------*/
static void
cfkey10(void)
{
	if(vsp->labels_on)	/* toggle user/system fkey labels */
	{
		if(vsp->which_fkl == USR_FKL)
			sw_sfkl(vsp);
		else if(vsp->which_fkl == SYS_FKL)
			sw_ufkl(vsp);
	}
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 11
 *---------------------------------------------------------------------------*/
static void
cfkey11(void)
{
	if(vsp->vt_pure_mode == M_PUREVT)
	        set_emulation_mode(vsp, M_HPVT);
	else if(vsp->vt_pure_mode == M_HPVT)
	        set_emulation_mode(vsp, M_PUREVT);
}

/*---------------------------------------------------------------------------*
 *	function bound to control function key 12
 *---------------------------------------------------------------------------*/
static void
cfkey12(void)
{
}

#endif	/* PCVT_VT220KEYB */

d2443 1
a2443 2
	if (!(scrollback_savedscreen = (u_short *)malloc(s, M_TEMP, M_NOWAIT)))
	{
@


1.27
log
@Yes, I think I've finally decided how I think scrollback should behave.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.26 1999/10/05 16:38:20 aaron Exp $	*/
d1841 1
a1841 1
kbdioctl(Dev_t dev, int cmd, caddr_t data, int flag)
@


1.26
log
@Add a missing check from last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.25 1999/10/04 09:38:19 aaron Exp $	*/
d1504 1
d1534 1
a1534 1
			if (vsp->scrolling <= 0)
a1535 2
			else if (vsp->scrolling < vsp->screen_rows)
				vsp->scrolling = vsp->screen_rows - 1;
d1544 5
d1551 3
a1553 2
			              vsp->Crtat, vsp->screen_rows *
				      vsp->maxcol * CHR);
@


1.25
log
@Minor calculation tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.24 1999/09/27 01:50:19 aaron Exp $	*/
a1503 1
						vsp->scr_offset--;
d1507 2
a1508 2
				      	      ((vsp->scr_offset + 1) *
					      vsp->maxcol), vsp->maxcol * CHR);
d1533 1
a1533 1
			if (vsp->scrolling < 0)
d1535 2
@


1.24
log
@Fix a display nit in scrollback code.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.23 1999/09/21 00:52:42 aaron Exp $	*/
d1489 1
a1489 1
		if (vsp->scr_offset > (vsp->screen_rows - 1))
d1493 1
a1493 1
				vsp->scrolling += vsp->screen_rows - 2;
d1537 1
a1537 1
			if (vsp->scrolling <= vsp->screen_rows)
@


1.23
log
@Whoops, forgot to adjust a comparison when fixing the off-by-one error.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.22 1999/09/08 12:56:42 aaron Exp $	*/
d1493 1
a1493 1
				vsp->scrolling += vsp->screen_rows - 1;
@


1.22
log
@Remove PCVT_SCROLLBACK option and make it on by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.21 1999/09/06 00:12:40 aaron Exp $	*/
d1489 1
a1489 1
		if (vsp->scr_offset >= (vsp->screen_rows - 1))
@


1.21
log
@Add scrollback support to the pcvt (i386 only) console driver.

Press LEFT_SHIFT+PGUP/PGDN to navigate. Number of buffered pages is currently
only configurable by editing sys/arch/i386/isa/pcvt/pcvt_hdr.h and changing
the SCROLLBACK_PAGES constant.

You must add "option PCVT_SCROLLBACK" to your kernel config file to enable
this support, or uncomment it from sys/arch/i386/conf/GENERIC.

Known issues:
   - Few little buglets when switching line (font) or column modes in scon(1).
   - Can't hold down LEFT_SHIFT+PGUP/PGDN keys. This will be fixed...

Idea from Linux, code by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.20 1999/07/06 07:59:54 deraadt Exp $	*/
a117 1
#ifdef PCVT_SCROLLBACK
a121 1
#endif
a1095 1
#ifdef PCVT_SCROLLBACK
a1099 1
#endif
a1486 1
#ifdef PCVT_SCROLLBACK
a1575 1
#endif
a3145 1
#ifdef PCVT_SCROLLBACK
a3173 1
#endif
@


1.20
log
@for CTRL-ALT-DEL, send SIGUSR1 to initproc
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.19 1998/09/06 23:00:03 niklas Exp $	*/
d118 7
d1098 7
d1430 1
a1430 1
#endif	/* PCVT_SHOWKEYS */
d1491 92
d3151 31
@


1.19
log
@Better keyboard timing code mostly from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.18 1998/08/09 06:13:30 millert Exp $	*/
d118 2
d1477 5
a1481 4
#if PCVT_CTRL_ALT_DEL		/*   Check for cntl-alt-del	*/
	if((key == 76) && ctrl_down && (meta_down||altgr_down))
		cpu_reset();
#endif /* PCVT_CTRL_ALT_DEL */
@


1.18
log
@Wait for ACK's back from the kbd controller when setting typematic rate.
Fixes a hang when starting X windows on pc's with picky kbd controllers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.17 1998/07/12 18:56:06 weingart Exp $	*/
d339 2
a340 2
	for (i = 100000; i; i--) {
		PCVT_KBD_DELAY();
d345 1
d355 2
a356 2
	for (i = 100000; i; i--) {
		PCVT_KBD_DELAY();
d361 1
d490 9
a498 2
	while(inb(CONTROLLER_CTRL) & STATUS_OUTPBF)
		kbd_response();
@


1.17
log
@Fix for the new fast PII-400 machines.  This makes them work, and does not
seem to have an adverse affect on other machines.  Thanks to martin@@ for
testing on the PII-400 (wish I had one...), and millert@@ for testing on
his machines (and finding a bug in my original fix).

pccons & pckbd need fixing too...
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.16 1998/06/30 20:51:12 millert Exp $	*/
d305 3
d309 1
a309 1
	if(kbd_cmd(KEYB_C_TYPEM) != 0)
d311 6
a316 1
	else if(kbd_cmd(tpmrate) != 0)
d318 11
@


1.16
log
@In pccngetc, check that dev is not NODEV [NetBSD]
Disallow KDENABIO icotl if securelevel > 1 [NetBSD]
Only define scrnsv_timeout if PCVT_SCREENSAVER set [NetBSD]
Fix setting of keyboard LED's.  For some keyboard controllers the keyboard
    would hang when pcvt set the LED because pcvt did not wait for the
    ACK to come back. [FreeBSD]
Consolidate keyboard type checks into a switch statement. [me]
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.15 1998/06/25 00:40:29 millert Exp $	*/
d320 2
a321 1
	for (i = 100000; i; i--)
d326 1
d335 2
a336 1
	for (i = 100000; i; i--)
d341 1
@


1.15
log
@Kill PCVT_NETBSD and PCVT_FREEBSD.  We no longer have to modify pcvt
when we increase the OpenBSD version and our pcvt is now meaningfully
diffable against the NetBSD one.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.14 1998/02/22 22:06:14 niklas Exp $	*/
d81 2
d111 3
a113 1
static int	ledstate  = 0;	/* keyboard led's */
d172 1
a172 1
 * abled because it crashes FreeBSD 1.1.5.1 at boot time.
d231 6
a236 3
	int new_ledstate = ((vsp->scroll_lock) |
			    (vsp->num_lock * 2) |
			    (vsp->caps_lock * 4));
d240 3
a242 1
		if(kbd_cmd(KEYB_C_LEDS) != 0)
d245 1
d249 24
a272 1
		if(kbd_cmd(new_ledstate) != 0) {
d274 1
d277 1
d279 6
a284 1
		ledstate = new_ledstate;
d295 1
a475 1

d576 2
a577 6
			if((response = kbd_response()) == KEYB_R_MF2ID2)
			{
				keyboard_type = KB_MFII;
			}
			else if(response == KEYB_R_RESEND)
			{
d585 5
a589 3
			}
			else if(response == KEYB_R_MF2ID2HP)
			{
d591 3
a593 13
			}
			else if(response == KEYB_R_MF2ID2TP)
			{
				keyboard_type = KB_MFII;
			}
			else if(response == KEYB_R_MF2ID2TP2)
			{
				keyboard_type = KB_MFII;
			}
			else
			{
				printf("\npcvt: doreset() - kbdid, response 2 = [%d]\n",
				       response);
d595 1
@


1.14
log
@GCC 2.8 Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.13 1998/02/05 16:48:34 deraadt Exp $	*/
a1274 1
#if PCVT_NETBSD > 100
a1275 3
#else
					timevalsub(&now, &mouse.lastmove);
#endif
a1418 4
#if !(PCVT_NETBSD || PCVT_FREEBSD >= 200)
#include "ddb.h"
#endif /* !(PCVT_NETBSD || PCVT_FREEBSD >= 200) */

a1427 4
#if PCVT_FREEBSD
			/* the string is actually not used... */
			Debugger("kbd");
#else
a1429 1
#endif
@


1.13
log
@rename ddb.panic_ddb, and add ddb.console. Now you can stop console ddb entry
with a sysctl. There will be architectures and drivers that lack function,
and I trust the maintainers of those will forget to add the code..
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.12 1998/01/11 06:15:35 deraadt Exp $	*/
d622 1
a622 1
	register i;
d1637 1
a1637 1
	register i;
@


1.12
log
@scanset probing like pccons does; vons@@usa.net
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.11 1997/07/25 22:52:43 weingart Exp $	*/
d1440 2
a1441 1
 			Debugger();
@


1.11
log
@Typo (from NetBSD #2622)
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.10 1997/05/30 01:43:05 mickey Exp $	*/
d495 22
d555 4
@


1.10
log
@add koi8 support
from Roman Palagin <romanp@@mutant.mybody.ryazan.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.9 1996/09/06 08:40:49 mickey Exp $	*/
d370 1
a370 1
	kbc_cmd(cmd);
@


1.9
log
@remove keyboard randomness supply.
not needed w/ adition of tty randomness.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.8 1996/08/29 09:26:10 deraadt Exp $	*/
d722 3
d760 8
a767 1
				more_chars = (u_char *)thisdef.altgr;
@


1.8
log
@rnd -> random
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.7 1996/06/16 13:54:02 deraadt Exp $	*/
a79 4
#include "random.h"
#if	NRANDOM > 0
#include <dev/rndvar.h>
#endif
a1021 3
#if	NRANDOM > 0
		add_keyboard_randomness(dt)
#endif
@


1.7
log
@pcvt doesn not recognize IBM Thinkpad keyboards; netbsd pr#2468; jhawk@@mit.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.6 1996/05/25 22:17:58 deraadt Exp $	*/
d80 2
a81 2
#include "rnd.h"
#if	NRND
d1026 1
a1026 1
#if	NRND
@


1.6
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_kbd.c,v 1.5 1996/05/07 07:22:30 deraadt Exp $	*/
d533 4
@


1.5
log
@sync with 0504; prototype changes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d966 1
a966 1
#if PCVT_KBD_FIFO && PCVT_SLOW_INTERRUPT
d1006 1
a1006 1
			PCVT_DISABLE_INTR();
d1008 1
a1008 1
			PCVT_ENABLE_INTR();
d1292 1
a1292 1
			PCVT_DISABLE_INTR();
d1294 1
a1294 1
			PCVT_ENABLE_INTR();
@


1.4
log
@Merge of NetBSD 960317
@
text
@d97 5
d722 1
a722 1
	void		(*fnc)();
@


1.3
log
@Initial commit of random source driver.
@
text
@d1 2
d273 26
a301 1
	unsigned timeo;
d303 2
a304 4
	timeo = 100000; 	/* > 100 msec */
	while (inb(CONTROLLER_CTRL) & STATUS_INPBF)
		if (--timeo == 0)
			return (-1);
d306 1
a315 1
	unsigned timeo;
d317 2
a318 4
	timeo = 100000; 	/* > 100 msec */
	while (inb(CONTROLLER_CTRL) & STATUS_INPBF)
		if (--timeo == 0)
			return (-1);
a335 6
	unsigned timeo;

	timeo = 500000; 	/* > 500 msec (KEYB_R_SELFOK requires 87) */
	while (!(inb(CONTROLLER_CTRL) & STATUS_OUTPBF))
		if (--timeo == 0)
			return (-1);
d337 2
a338 1
	PCVT_KBD_DELAY();		/* 7 us delay */
d357 1
a357 1
	int cmd, timeo = 10000;
d369 1
a370 8
	while (inb(CONTROLLER_CTRL) & STATUS_INPBF)
	{
		if (--timeo == 0)
			break;
	}
	
	outb(CONTROLLER_DATA, cmd);

@


1.2
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d78 4
d1006 3
@


1.1
log
@Initial revision
@
text
@d1218 4
d1223 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
