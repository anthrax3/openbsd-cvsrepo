head	1.45;
access;
symbols
	SMP_SYNC_A:1.45
	SMP_SYNC_B:1.45
	UBC_SYNC_A:1.45
	UBC_SYNC_B:1.45
	OPENBSD_2_9:1.44.0.2
	OPENBSD_2_9_BASE:1.44
	OPENBSD_2_8:1.42.0.2
	OPENBSD_2_8_BASE:1.42
	OPENBSD_2_7:1.35.0.2
	OPENBSD_2_7_BASE:1.35
	SMP:1.32.0.2
	SMP_BASE:1.32
	kame_19991208:1.31
	OPENBSD_2_6:1.27.0.2
	OPENBSD_2_6_BASE:1.27
	OPENBSD_2_5:1.21.0.4
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.21.0.2
	OPENBSD_2_4_BASE:1.21
	OPENBSD_2_3:1.18.0.2
	OPENBSD_2_3_BASE:1.18
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	OPENBSD_2_0:1.13.0.2
	OPENBSD_2_0_BASE:1.13
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2001.05.29.22.09.13;	author mickey;	state dead;
branches;
next	1.44;

1.44
date	2001.01.22.18.48.43;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2000.12.21.16.54.53;	author aaron;	state Exp;
branches;
next	1.42;

1.42
date	2000.10.26.22.53.31;	author aaron;	state Exp;
branches;
next	1.41;

1.41
date	2000.10.07.03.12.46;	author aaron;	state Exp;
branches;
next	1.40;

1.40
date	2000.09.28.17.45.42;	author aaron;	state Exp;
branches;
next	1.39;

1.39
date	2000.09.22.17.39.05;	author aaron;	state Exp;
branches;
next	1.38;

1.38
date	2000.09.04.17.59.49;	author aaron;	state Exp;
branches;
next	1.37;

1.37
date	2000.09.01.05.46.01;	author aaron;	state Exp;
branches;
next	1.36;

1.36
date	2000.06.08.22.25.20;	author niklas;	state Exp;
branches;
next	1.35;

1.35
date	2000.03.30.21.02.08;	author aaron;	state Exp;
branches;
next	1.34;

1.34
date	2000.03.23.17.09.48;	author aaron;	state Exp;
branches;
next	1.33;

1.33
date	2000.02.27.19.31.05;	author aaron;	state Exp;
branches;
next	1.32;

1.32
date	2000.01.17.02.47.36;	author aaron;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	99.12.01.09.59.59;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	99.11.25.21.00.36;	author aaron;	state Exp;
branches;
next	1.29;

1.29
date	99.11.25.20.24.21;	author aaron;	state Exp;
branches;
next	1.28;

1.28
date	99.11.20.18.52.00;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	99.10.20.19.15.51;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	99.10.16.18.56.35;	author aaron;	state Exp;
branches;
next	1.25;

1.25
date	99.09.29.22.29.10;	author aaron;	state Exp;
branches;
next	1.24;

1.24
date	99.09.28.20.36.04;	author aaron;	state Exp;
branches;
next	1.23;

1.23
date	99.09.08.12.56.42;	author aaron;	state Exp;
branches;
next	1.22;

1.22
date	99.09.06.00.12.40;	author aaron;	state Exp;
branches;
next	1.21;

1.21
date	98.09.06.23.00.03;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	98.06.30.20.51.11;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	98.06.25.00.40.28;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	98.02.05.16.48.32;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.01.11.06.15.34;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.11.06.02.26.47;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.05.29.01.47.26;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	96.10.17.19.19.02;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	96.07.16.10.58.36;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.06.16.13.54.01;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.05.25.22.17.55;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.05.10.12.46.24;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.07.12.26.29;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.05.07.07.22.27;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.17.09;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.18.17.48.31;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.04.18.04.11.05;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.19.21.09.47;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.06.04.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.04.09.25;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.39;	author deraadt;	state Exp;
branches;
next	;

1.32.2.1
date	2000.03.02.07.04.29;	author niklas;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2000.03.24.09.07.43;	author niklas;	state Exp;
branches;
next	1.32.2.3;

1.32.2.3
date	2001.04.18.16.07.57;	author niklas;	state Exp;
branches;
next	1.32.2.4;

1.32.2.4
date	2001.07.04.10.16.59;	author niklas;	state dead;
branches;
next	;


desc
@@


1.45
log
@remove this used to be great console driver; x11 builds w/o it all fine; aaron@@, todd@@, matthieu@@ ok
@
text
@/*	$OpenBSD: pcvt_hdr.h,v 1.44 2001/01/22 18:48:43 deraadt Exp $	*/

/*
 * Copyright (c) 1992, 1995 Hellmuth Michaelis and Joerg Wunsch.
 *
 * Copyright (c) 1992, 1993 Brian Dunford-Shore.
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by
 *	Hellmuth Michaelis, Brian Dunford-Shore and Joerg Wunsch.
 * 4. The name authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * @@(#)pcvt_hdr.h, 3.32, Last Edit-Date: [Tue Oct  3 11:19:48 1995]
 *
 */

/*---------------------------------------------------------------------------
 *
 *	pcvt_hdr.h	VT220 Driver Global Include File
 *	------------------------------------------------
 *	-hm	------------ Release 3.00 --------------
 *	-hm	integrating NetBSD-current patches
 *	-hm	integrating patches from Thomas Gellekum
 *	-hm	moving vt_selattr() inline into this file
 *	-hm	Michael's keyboard fifo diffs
 *	-hm	documenting some #ifdef's ...
 *	-hm	Joerg's patches for FreeBSD's ttymalloc
 *	-jw	introduced kbd_emulate_pc() if scanset > 1
 *	-hm	moved user configurable items to pcvt_conf.h
 *	-hm	applying Joerg's patches for FreeBSD 2.0
 *	-hm	patch from Onno & Martin for NetBSD-current (post 1.0)
 *	-hm	some adjustments for NetBSD 1.0
 *	-hm	patch from Joerg fixing FreeBSD 2.0 support
 *	-hm	patch from Onno/John for NetBSD-current
 *	-hm	applying patch from Joerg fixing Crtat bug
 *	-hm	removed PCVT_FAKE_SYSCONS10
 *	-hm	added pcstop (patch from Onno)
 *	-hm	multiple X server bugfixes from Lon Willett
 *	-hm	patch from Joerg for FreeBSD pre-2.1
 *	-jw	adding more support for FreeBSD pre-2.1
 *	-hm	patches from Michael for NetBSD-current (Apr/21/95) support
 *	-hm	several NetBSD-current patches from John Kohl
 *	-hm	---------------- Release 3.30 -----------------------
 *	-hm	patch from Thomas Gellekum to support C1 controls
 *	-hm	patch from Frank van der Linden for keyboard state per VT
 *	-hm	---------------- Release 3.32 -----------------------
 *
 *---------------------------------------------------------------------------*/

#define	PCVT_REL "3.32"		/* driver attach announcement	*/
				/* see also: pcvt_ioctl.h	*/

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/fcntl.h>
#include <sys/user.h>
#include <sys/tty.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/msgbuf.h>
#include <sys/malloc.h>
#include <sys/time.h>
#ifdef DDB
#include <ddb/db_var.h>
#endif

#include "pcvt_conf.h"

#include <sys/device.h>

#include <i386/isa/isa_machdep.h>
#include <dev/isa/isavar.h>
#include <machine/cpufunc.h>
#include <machine/intr.h>

#include <i386/isa/icu.h>

#include <dev/isa/isareg.h>

#include <dev/cons.h>
#include <dev/ic/mc146818reg.h>
#include <i386/isa/nvram.h>

#include <machine/stdarg.h>

#include "pcvt_ioctl.h"

#include <machine/pc/display.h>
#include <vm/vm_kern.h>

#ifdef XSERVER

/* PCVT_NULLCHARS is mandatory for X server */
#undef PCVT_NULLCHARS
#define PCVT_NULLCHARS 1

/* PCVT_BACKUP_FONTS is mandatory for XSERVER */
#undef PCVT_BACKUP_FONTS
#define PCVT_BACKUP_FONTS 1

#endif /* XSERVER */

/* PCVT_SCREENSAVER is mandatory for PCVT_PRETTYSCRNS */
#if PCVT_PRETTYSCRNS && !PCVT_SCREENSAVER
#undef PCVT_SCREENSAVER
#define PCVT_SCREENSAVER 1
#endif

/* get the inline inb/outb back again ... */

#include <machine/pio.h>	/* recent NetBSD -currents */
#define NEW_AVERUNNABLE		/* averunnable changes for younger currents */

#if PCVT_SCANSET !=1 && PCVT_SCANSET !=2
#error "Supported keyboard scancode sets are 1 and 2 only (for now)!!!"
#endif

/*---------------------------------------------------------------------------*
 *	Keyboard and Keyboard Controller
 *---------------------------------------------------------------------------*/

#define CONTROLLER_CTRL	0x64	/* W - command, R - status	*/
#define CONTROLLER_DATA	0x60	/* R/W - data			*/

/* commands to control the CONTROLLER (8042) on the mainboard */

#define CONTR_READ	0x20	/* read command byte from controller */
#define CONTR_WRITE	0x60	/* write command to controller, see below */
#define CONTR_SELFTEST	0xaa	/* controller selftest, returns 0x55 when ok */
#define CONTR_IFTEST	0xab	/* interface selftest */
#define CONTR_KBDISABL	0xad	/* disable keyboard */
#define CONTR_KBENABL	0xae	/* enable keyboard */

/* command byte for writing to CONTROLLER (8042) via CONTR_WRITE */

#define	 COMMAND_RES7	0x80	/* bit 7, reserved, always write a ZERO ! */
#define	 COMMAND_PCSCAN	0x40	/* bit 6, 1 = convert to pc scan codes */
#define	 COMMAND_RES5	0x20	/* bit 5, perhaps (!) use 9bit frame
				 * instead of 11 */
#define	 COMMAND_DISABL	0x10	/* bit 4, 1 = disable keyboard */
#define	 COMMAND_INHOVR	0x08	/* bit 3, 1 = override security lock inhibit */
#define	 COMMAND_SYSFLG	0x04	/* bit 2, value stored as "system flag" */
#define	 COMMAND_RES2	0x02	/* bit 1, reserved, always write a ZERO ! */
#define	 COMMAND_IRQEN	0x01	/* bit 0, 1 = enable output buffer full
				 * interrupt */

/* status from CONTROLLER (8042) on the mainboard */

#define	STATUS_PARITY	0x80	/* bit 7, 1 = parity error on last byte */
#define STATUS_RXTIMO	0x40	/* bit 6, 1 = receive timeout error occured */
#define STATUS_TXTIMO	0x20	/* bit 5, 1 = transmit timeout error occured */
#define STATUS_ENABLE	0x10	/* bit 4, 1 = keyboard unlocked */
#define STATUS_WHAT	0x08	/* bit 3, 1 = wrote cmd to 0x64, 0 = wrote
				 * data to 0x60 */
#define STATUS_SYSFLG	0x04	/* bit 2, value stored as "system flag" */
#define STATUS_INPBF	0x02	/* bit 1, 1 = input buffer full (to 8042) */
#define STATUS_OUTPBF	0x01	/* bit 0, 1 = output buffer full (from 8042) */

/* commands to the KEYBOARD (via the 8042 controller on mainboard..) */

#define KEYB_C_RESET	0xff	/* reset keyboard to power-on status */
#define	KEYB_C_RESEND	0xfe	/* resend last byte in case of error */
#define KEYB_C_TYPEM	0xf3	/* set keyboard typematic rate/delay */
#define KEYB_C_ID	0xf2	/* return keyboard id */
#define KEYB_C_SCANSET	0xf0	/* get/set keyboard scancode set */
#define KEYB_C_ECHO	0xee	/* diagnostic, echo 0xee */
#define KEYB_C_LEDS	0xed	/* set/reset numlock,capslock & scroll lock */

/* responses from the KEYBOARD (via the 8042 controller on mainboard..) */

#define	KEYB_R_OVERRUN0	0x00	/* keyboard buffer overflow */
#define KEYB_R_SELFOK	0xaa	/* keyboard selftest ok after KEYB_C_RESET */
#define KEYB_R_EXT0	0xe0	/* keyboard extended scancode prefix 1 */
#define KEYB_R_EXT1	0xe1	/* keyboard extended scancode prefix 2 */
#define KEYB_R_ECHO	0xee	/* keyboard response to KEYB_C_ECHO */
#define KEYB_R_BREAKPFX	0xf0	/* break code prefix for set 2 and 3 */
#define KEYB_R_ACK	0xfa	/* acknowledge after a command has rx'd */
#define KEYB_R_SELFBAD	0xfc	/*keyboard selftest FAILED after KEYB_C_RESET*/
#define KEYB_R_DIAGBAD	0xfd	/* keyboard self diagnostic failure */
#define KEYB_R_RESEND	0xfe	/* keyboard wants command resent or illegal
				 * command rx'd */
#define	KEYB_R_OVERRUN1	0xff	/* keyboard buffer overflow */

#define KEYB_R_MF2ID1	0xab	/* MF II Keyboard id-byte #1 */
#define KEYB_R_MF2ID2	0x41	/* MF II Keyboard id-byte #2 */
#define KEYB_R_MF2ID2HP	0x83	/* MF II Keyboard id-byte #2 from HP keybd's */
#define KEYB_R_MF2ID2TP 0x54	/* MF II Keyboard id-byte #2 from IBM ThinkPad */
#define KEYB_R_MF2ID2TP2 0x84	/* MF II Keyboard id-byte #2 from IBM ThinkPad (340M) */

/* internal Keyboard Type */

#define KB_UNKNOWN	0	/* unknown keyboard type */
#define KB_AT		1	/* AT (84 keys) Keyboard */
#define KB_MFII		2	/* MF II (101/102 keys) Keyboard */

/*---------------------------------------------------------------------------*
 *	CMOS ram access to get the "Equipment Byte"
 *---------------------------------------------------------------------------*/

#define EQ_EGAVGA	NVRAM_EQUIPMENT_EGAVGA
#define EQ_40COLOR	NVRAM_EQUIPMENT_COLOR40
#define EQ_80COLOR	NVRAM_EQUIPMENT_COLOR80
#define EQ_80MONO	NVRAM_EQUIPMENT_MONO80

/*---------------------------------------------------------------------------*
 *	VT220 -> internal color conversion table fields
 *---------------------------------------------------------------------------*/

#define VT_NORMAL	0x00		/* no attributes at all */
#define VT_BOLD		0x01		/* bold attribute */
#define VT_UNDER	0x02		/* underline attribute */
#define VT_BLINK	0x04		/* blink attribute */
#define VT_INVERSE	0x08		/* inverse attribute */

/*---------------------------------------------------------------------------*
 *	VGA GENERAL/EXTERNAL Registers          (3BA or 3DA and 3CA, 3C2, 3CC)
 *---------------------------------------------------------------------------*/

#define GN_MISCOUTR	0x3CC		/* misc output register read */
#define GN_MISCOUTW	0x3C2		/* misc output register write */
#define GN_INPSTAT0	0x3C2		/* input status 0, r/o */
#define GN_INPSTAT1M	0x3BA		/* input status 1, r/o, mono */
#define GN_INPSTAT1C	0x3DA		/* input status 1, r/o, color */
#define GN_FEATR	0x3CA		/* feature control, read */
#define GN_FEATWM	0x3BA		/* feature control, write, mono */
#define GN_FEATWC	0x3DA		/* feature control, write, color */
#define GN_VSUBSYS	0x3C3		/* video subsystem register r/w */
#define GN_DMCNTLM	0x3B8		/* display mode control, r/w, mono */
#define GN_DMCNTLC	0x3D8		/* display mode control, r/w, color */
#define GN_COLORSEL	0x3D9		/* color select register, w/o */
#define GN_HERCOMPAT	0x3BF		/* Hercules compatibility reg, w/o */

/*---------------------------------------------------------------------------*
 *	VGA CRTC Registers			  (3B4 and 3B5 or 3D4 and 3D5)
 *---------------------------------------------------------------------------*/

#define MONO_BASE	0x3B4		/* crtc index register address mono */
#define CGA_BASE	0x3D4		/* crtc index register address color */

#define	CRTC_ADDR	0x00		/* index register */

#define CRTC_HTOTAL	0x00		/* horizontal total */
#define CRTC_HDISPLE	0x01		/* horizontal display end */
#define CRTC_HBLANKS	0x02		/* horizontal blank start */
#define CRTC_HBLANKE	0x03		/* horizontal blank end */
#define CRTC_HSYNCS	0x04		/* horizontal sync start */
#define CRTC_HSYNCE	0x05		/* horizontal sync end */
#define CRTC_VTOTAL	0x06		/* vertical total */
#define CRTC_OVERFLL	0x07		/* overflow low */
#define CRTC_IROWADDR	0x08		/* initial row address */
#define CRTC_MAXROW	0x09		/* maximum row address */
#define CRTC_CURSTART	0x0A		/* cursor start row address */
#define 	CURSOR_ON_BIT 0x20	/* cursor on/off on mda/cga/vga */
#define CRTC_CUREND	0x0B		/* cursor end row address */
#define CRTC_STARTADRH	0x0C		/* linear start address mid */
#define CRTC_STARTADRL	0x0D		/* linear start address low */
#define CRTC_CURSORH	0x0E		/* cursor address mid */
#define CRTC_CURSORL	0x0F		/* cursor address low */
#define CRTC_VSYNCS	0x10		/* vertical sync start */
#define CRTC_VSYNCE	0x11		/* vertical sync end */
#define CRTC_VDE	0x12		/* vertical display end */
#define CRTC_OFFSET	0x13		/* row offset */
#define CRTC_ULOC	0x14		/* underline row address */
#define CRTC_VBSTART	0x15		/* vertical blank start */
#define CRTC_VBEND	0x16		/* vertical blank end */
#define CRTC_MODE	0x17		/* CRTC mode register */
#define CRTC_SPLITL	0x18		/* split screen start low */

/* start of ET4000 extensions */

#define CRTC_RASCAS	0x32		/* ras/cas configuration */
#define CRTC_EXTSTART	0x33		/* extended start address */
#define CRTC_COMPAT6845	0x34		/* 6845 comatibility control */
#define CRTC_OVFLHIGH	0x35		/* overflow high */
#define CRTC_SYSCONF1	0x36		/* video system configuration 1 */
#define CRTC_SYSCONF2	0x36		/* video system configuration 2 */

/* start of WD/Paradise extensions */

#define	CRTC_PR10	0x29		/* r/w unlocking */
#define	CRTC_PR11	0x2A		/* ega switches */
#define	CRTC_PR12	0x2B		/* scratch pad */
#define	CRTC_PR13	0x2C		/* interlace h/2 start */
#define	CRTC_PR14	0x2D		/* interlace h/2 end */
#define	CRTC_PR15	0x2E		/* misc control #1 */
#define	CRTC_PR16	0x2F		/* misc control #2 */
#define	CRTC_PR17	0x30		/* misc control #3 */
					/* 0x31 .. 0x3f reserved */
/* Video 7 */

#define CRTC_V7ID	0x1f		/* identification register */

/* Trident */

#define CRTC_MTEST	0x1e		/* module test register */
#define CRTC_SOFTPROG	0x1f		/* software programming */
#define CRTC_LATCHRDB	0x22		/* latch read back register */
#define CRTC_ATTRSRDB	0x24		/* attribute state read back register*/
#define CRTC_ATTRIRDB	0x26		/* attribute index read back register*/
#define CRTC_HOSTAR	0x27		/* high order start address register */

/*---------------------------------------------------------------------------*
 *	VGA TIMING & SEQUENCER Registers			 (3C4 and 3C5)
 *---------------------------------------------------------------------------*/

#define TS_INDEX	0x3C4		/* index register */
#define TS_DATA		0x3C5		/* data register */

#define TS_SYNCRESET	0x00		/* synchronous reset */
#define TS_MODE		0x01		/* ts mode register */
#define TS_WRPLMASK	0x02		/* write plane mask */
#define TS_FONTSEL	0x03		/* font select register */
#define TS_MEMMODE	0x04		/* memory mode register */

/* ET4000 only */

#define TS_RESERVED	0x05		/* undef, reserved */
#define TS_STATECNTL	0x06		/* state control register */
#define TS_AUXMODE	0x07		/* auxiliary mode control */

/* WD/Paradise only */

#define TS_UNLOCKSEQ	0x06		/* PR20 - unlock sequencer register */
#define TS_DISCFSTAT	0x07		/* PR21 - display config status */
#define TS_MEMFIFOCTL	0x10		/* PR30 - memory i/f & fifo control */
#define TS_SYSIFCNTL	0x11		/* PR31 - system interface control */
#define TS_MISC4	0x12		/* PR32 - misc control #4 */

/* Video 7 */

#define TS_EXTCNTL	0x06		/* extensions control */
#define TS_CLRVDISP	0x30		/* clear vertical display 0x30-0x3f */
#define TS_V7CHIPREV	0x8e		/* chipset revision 0x8e-0x8f */
#define TS_SWBANK	0xe8		/* single/write bank register, rev 5+*/
#define TS_RDBANK	0xe8		/* read bank register, rev 4+ */
#define TS_MISCCNTL	0xe8		/* misc control register, rev 4+ */
#define TS_SWSTROBE	0xea		/* switch strobe */
#define TS_MWRCNTL	0xf3		/* masked write control */
#define TS_MWRMVRAM	0xf4		/* masked write mask VRAM only */
#define TS_BANKSEL	0xf6		/* bank select */
#define TS_SWREADB	0xf7		/* switch readback */
#define TS_PAGESEL	0xf9		/* page select */
#define TS_COMPAT	0xfc		/* compatibility control */
#define TS_16BITCTL	0xff		/* 16 bit interface control */

/* Trident */

#define TS_HWVERS	0x0b		/* hardware version, switch old/new! */
#define TS_CONFPORT1	0x0c		/* config port 1 and 2    - caution! */
#define TS_MODEC2	0x0d		/* old/new mode control 2 - caution! */
#define TS_MODEC1	0x0e		/* old/new mode control 1 - caution! */
#define	TS_PUPM2	0x0f		/* power up mode 2 */

/*---------------------------------------------------------------------------*
 *	VGA GRAPHICS DATA CONTROLLER Registers		    (3CE, 3CF and 3CD)
 *---------------------------------------------------------------------------*/

#define GDC_SEGSEL	0x3CD		/* segment select register */
#define GDC_INDEX	0x3CE		/* index register */
#define GDC_DATA	0x3CF		/* data register */

#define GDC_SETRES	0x00		/* set / reset bits */
#define GDC_ENSETRES	0x01		/* enable set / reset */
#define GDC_COLORCOMP	0x02		/* color compare register */
#define GDC_ROTFUNC	0x03		/* data rotate / function select */
#define GDC_RDPLANESEL	0x04		/* read plane select */
#define GDC_MODE	0x05		/* gdc mode register */
#define GDC_MISC	0x06		/* gdc misc register */
#define GDC_COLORCARE	0x07		/* color care register */
#define GDC_BITMASK	0x08		/* bit mask register */

/* WD/Paradise only */

#define GDC_BANKSWA	0x09		/* PR0A - bank switch a */
#define GDC_BANKSWB	0x0a		/* PR0B - bank switch b */
#define GDC_MEMSIZE	0x0b		/* PR1 memory size */
#define GDC_VIDEOSEL	0x0c		/* PR2 video configuration */
#define GDC_CRTCNTL	0x0d		/* PR3 crt address control */
#define GDC_VIDEOCNTL	0x0e		/* PR4 video control */
#define GDC_PR5GPLOCK	0x0f		/* PR5 gp status and lock */

/* Video 7 */

#define GDC_DATALATCH	0x22		/* gdc data latch */

/*---------------------------------------------------------------------------*
 *	VGA ATTRIBUTE CONTROLLER Registers			 (3C0 and 3C1)
 *---------------------------------------------------------------------------*/

#define ATC_INDEX	0x3C0		/* index register  AND	*/
#define ATC_DATAW	0x3C0		/* data write	   !!!	*/
#define ATC_DATAR	0x3C1		/* data read */

#define ATC_ACCESS	0x20		/* access bit in ATC index register */

#define ATC_PALETTE0	0x00		/* color palette register 0 */
#define ATC_PALETTE1	0x01		/* color palette register 1 */
#define ATC_PALETTE2	0x02		/* color palette register 2 */
#define ATC_PALETTE3	0x03		/* color palette register 3 */
#define ATC_PALETTE4	0x04		/* color palette register 4 */
#define ATC_PALETTE5	0x05		/* color palette register 5 */
#define ATC_PALETTE6	0x06		/* color palette register 6 */
#define ATC_PALETTE7	0x07		/* color palette register 7 */
#define ATC_PALETTE8	0x08		/* color palette register 8 */
#define ATC_PALETTE9	0x09		/* color palette register 9 */
#define ATC_PALETTEA	0x0A		/* color palette register 10 */
#define ATC_PALETTEB	0x0B		/* color palette register 11 */
#define ATC_PALETTEC	0x0C		/* color palette register 12 */
#define ATC_PALETTED	0x0D		/* color palette register 13 */
#define ATC_PALETTEE	0x0E		/* color palette register 14 */
#define ATC_PALETTEF	0x0F		/* color palette register 15 */
#define ATC_MODE	0x10		/* atc mode register */
#define ATC_OVERSCAN	0x11		/* overscan register */
#define ATC_COLPLEN	0x12		/* color plane enable register */
#define ATC_HORPIXPAN	0x13		/* horizontal pixel panning */
#define ATC_COLRESET	0x14		/* color reset */
#define ATC_MISC	0x16		/* misc register (ET3000/ET4000) */

/*---------------------------------------------------------------------------*
 *	VGA palette handling (output DAC palette)
 *---------------------------------------------------------------------------*/

#define VGA_DAC		0x3C6		/* vga dac address */
#define VGA_PMSK	0x3F		/* palette mask, 64 distinct values */
#define NVGAPEL 	256		/* number of palette entries */

/* tab setting */

#define MAXTAB 132		/* no of possible tab stops */

/* escape detection state machine */

#define STATE_INIT	0	/* normal	*/
#define	STATE_ESC	1	/* got ESC	*/
#define STATE_BLANK	2	/* got ESC space*/
#define STATE_HASH	3	/* got ESC #	*/
#define STATE_BROPN	4	/* got ESC (	*/
#define STATE_BRCLO	5	/* got ESC )	*/
#define STATE_CSI	6	/* got ESC [	*/
#define STATE_CSIQM	7	/* got ESC [ ?	*/
#define STATE_AMPSND	8	/* got ESC &	*/
#define STATE_STAR	9	/* got ESC *	*/
#define STATE_PLUS	10	/* got ESC +	*/
#define STATE_DCS	11	/* got ESC P	*/
#define STATE_DQUOTE	12	/* got ESC <Ps> " */
#define STATE_STR	13	/* got ESC !	*/
#define STATE_MINUS	14	/* got ESC -	*/
#define STATE_DOT	15	/* got ESC .	*/
#define STATE_SLASH	16	/* got ESC /	*/

/* for storing escape sequence parameters */

#define MAXPARMS 	10	/* maximum no of parms */

/* terminal responses */

#define DA_VT220	"\033[?62;1;2;6;7;8;9c"

/* sub-states for Device Control String processing */

#define DCS_INIT	0	/* got ESC P ... */
#define DCS_AND_UDK	1	/* got ESC P ... | */
#define DCS_UDK_DEF	2	/* got ESC P ... | fnckey / */
#define DCS_UDK_ESC	3	/* got ESC P ... | fnckey / ... ESC */
#define DCS_DLD_DSCS	4	/* got ESC P ... { */
#define DCS_DLD_DEF	5	/* got ESC P ... { dscs */
#define DCS_DLD_ESC	6	/* got ESC P ... { dscs ... / ... ESC */

/* vt220 user defined keys and vt220 downloadable charset */

#define MAXUDKDEF	300	/* max 256 char + 1 '\0' + space.. */
#define	MAXUDKEYS	18	/* plus holes .. */
#define DSCS_LENGTH	3	/* descriptor length */
#define MAXSIXEL	8	/* sixels forever ! */

/* additionals for function key labels */

#define MAX_LABEL	16
#define MAX_STRING	80
#define MAX_STATUS	160

/* MAX values for screen sizes for possible video adaptors */

#define MAXROW_MDACGA	25		/* MDA/CGA can do 25 x 80 max */
#define MAXCOL_MDACGA	80

#define MAXROW_EGA	43		/* EGA can do 43 x 80 max */
#define MAXCOL_EGA	80

#define MAXROW_VGA	50		/* VGA can do 50 x 80 max */
#define MAXCOL_VGA	80
#define MAXCOL_SVGA	132		/* Super VGA can do 50 x 132 max */

/* switch 80/132 columns */

#define SCR_COL80	80		/* in 80 col mode */
#define SCR_COL132	132		/* in 132 col mode */

#define MAXDECSCA	(((MAXCOL_SVGA * MAXROW_VGA) \
			/ (8 * sizeof(unsigned int)) ) + 1 )

/* screen memory start, monochrome */

#ifndef	MONO_BUF
#  define MONO_BUF	0xfe0B0000		 /* NetBSD-current: isa.h */
#endif

/* screen memory start, color */

#ifndef	CGA_BUF
#  define CGA_BUF	0xfe0B8000		 /* NetBSD-current: isa.h */
#endif

#define	CHR		2		/* bytes per word in screen mem */

#define NVGAFONTS	8		/* number of vga fonts loadable */

#define MAXKEYNUM	127		/* max no of keys in table */

/* charset tables */

#define	CSL	0x0000		/* ega/vga charset, lower half of 512 */
#define	CSH	0x0800		/* ega/vga charset, upper half of 512 */
#define CSSIZE	96		/* (physical) size of a character set */

/* charset designations */

#define D_G0		0	/* designated as G0 */
#define D_G1		1	/* designated as G1 */
#define D_G2		2	/* designated as G2 */
#define D_G3		3	/* designated as G3 */
#define D_G1_96		4	/* designated as G1 for 96-char charsets */
#define D_G2_96		5	/* designated as G2 for 96-char charsets */
#define D_G3_96		6	/* designated as G3 for 96-char charsets */

/* initial default scrollback buffer size (in pages) */
#define SCROLLBACK_PAGES	8

/* variables */

#ifdef EXTERN
#define WAS_EXTERN
#else
#define EXTERN extern
#endif

EXTERN	u_char	*more_chars;		/* response buffer via kbd */
EXTERN	int	char_count;		/* response char count */
EXTERN	u_char	color;			/* color or mono display */
EXTERN	u_char	pcdisp;			/* vt220 or traditional pc features */

EXTERN	u_short	kern_attr;		/* kernel messages char attributes */
EXTERN	u_short	user_attr;		/* character attributes */

EXTERN struct tty *pc_tty[PCVT_NSCREENS];

struct sixels {
	u_char lower[MAXSIXEL];		/* lower half of char */
	u_char upper[MAXSIXEL];		/* upper half of char */
};

struct udkentry {
	u_char	first[MAXUDKEYS];	/* index to first char */
	u_char	length[MAXUDKEYS];	/* length of this entry */
};

/* VGA palette handling */
struct rgb {
	u_char	r, g, b;		/* red/green/blue, valid 0..VGA_PMSK */
};

typedef struct video_state {
	u_short	*Crtat;			/* video page start addr */
	u_short *Memory;		/* malloc'ed memory start address */
	u_short *Scrollback;		/* scrollback buffer */
	int scr_offset;			/* current scrollback offset (lines) */
	short scrolling;		/* current scrollback page */
	u_short max_off;		/* maximum scrollback offset */
	struct tty *vs_tty;		/* pointer to this screen's tty */
	u_char	maxcol;			/* 80 or 132 cols on screen */
	u_char 	row, col;		/* current cursor position */
	u_short	c_attr;			/* current character attributes */
	u_char	vtsgr;			/* current sgr configuration */
	u_short	cur_offset;		/* current cursor position offset */
	u_char	bell_on;		/* flag, bell enabled */
	u_char	sevenbit;		/* flag, data path 7 bits wide */
	u_char	transparent;		/* flag, mk path tmp trnsprnt for ctls*/
	u_char	C1_ctls;		/* flag, process C1 ctls */
	u_char	scrr_beg;		/* scrolling region, begin */
	u_char	scrr_len;		/* scrolling region, length */
	u_char	scrr_end;		/* scrolling region, end */
	u_char	screen_rows;		/* screen size, length - status lines */
	u_char	screen_rowsize; 	/* screen size, length */
	u_char	vga_charset;		/* VGA character set value */
	u_char	lastchar;		/* flag, vt100 behaviour of last char */
	u_char	lastrow;		/* save row, --------- " -----------  */
	u_char	*report_chars;		/* ptr, status reports from terminal */
	u_char	report_count;		/* count, ----------- " ------------ */
	u_char	state;			/* escape sequence state machine */
	u_char	m_awm;			/* flag, vt100 mode, auto wrap */
	u_char	m_om;			/* flag, vt100 mode, origin mode */
	u_char	sc_flag;		/* flag, vt100 mode,saved parms valid */
	u_char	sc_row;			/* saved row */
	u_char	sc_col;			/* saved col */
	u_short sc_cur_offset;		/* saved cursor addr offset */
	u_short	sc_attr;		/* saved attributes */
	u_char	sc_vtsgr;		/* saved sgr configuration */
	u_char	sc_awm;			/* saved auto wrap mode */
	u_char	sc_om;			/* saved origin mode */
	u_short	*sc_G0;			/* save G0 ptr */
	u_short	*sc_G1;			/* save G1 ptr */
	u_short	*sc_G2;			/* save G2 ptr */
	u_short	*sc_G3;			/* save G3 ptr */
	u_short	*sc_GL;			/* save GL ptr */
	u_short	*sc_GR;			/* save GR ptr */
	u_char	sc_sel;			/* selective erase state */
	char	tab_stops[MAXTAB]; 	/* table of active tab stops */
	u_char	parmi;			/* parameter index */
	u_char	parms[MAXPARMS];	/* parameter array */
	u_char	attribute;		/* attribute normal, tx only, local */
	u_char	key;			/* fkey label no */
	u_char	l_len;			/* buffer length's */
	u_char	s_len;
	u_char	m_len;
	u_char	i;			/* help (got short of names ...) */
	u_char	l_buf[MAX_LABEL+1]; 	/* buffers */
	u_char	s_buf[MAX_STRING+1];
	u_char	m_buf[MAX_STATUS+1];
	u_char	openf;			/* we are opened ! */
	u_char	cursor_start;		/* Start of cursor */
	u_char	cursor_end;		/* End of cursor */
	u_char	cursor_on;		/* cursor switched on */
	u_char	ckm;			/* true = cursor key normal mode */
	u_char	irm;			/* true = insert mode */
	u_char	lnm;			/* Line Feed/New Line Mode */
	u_char	dcs_state;		/* dcs escape sequence state machine */
	u_char	udk_def[MAXUDKDEF]; 	/* new definitions for vt220 FKeys */
	u_char	udk_defi;		/* index for FKey definitions */
	u_char	udk_deflow;		/* low or high nibble in sequence */
	u_char	udk_fnckey;		/* function key to assign to */
	u_char	dld_dscs[DSCS_LENGTH];	/* designate soft character set id */
	u_char	dld_dscsi;		/* index for dscs */
	u_char	dld_sixel_lower;	/* upper/lower sixels of character */
	u_char	dld_sixelli;		/* index for lower sixels */
	u_char	dld_sixelui;		/* index for upper sixels */
	struct sixels sixel;		/* structure for storing char sixels */
	u_char	selchar;		/* true = selective attribute on */
	u_int	decsca[MAXDECSCA];	/* Select Character Attrib bit array */
	u_short *GL;			/* ptr to current GL conversion table*/
	u_short *GR;			/* ptr to current GR conversion table*/
	u_short *G0;			/* ptr to current G0 conversion table*/
	u_short *G1;			/* ptr to current G1 conversion table*/
	u_char force24;			/* force 24 lines in DEC 25 and HP 28*/
	u_short *G2;			/* ptr to current G2 conversion table*/
	u_short *G3;			/* ptr to current G3 conversion table*/
	u_char	dld_id[DSCS_LENGTH+1];	/* soft character set id */
	u_char	which[DSCS_LENGTH+1];	/* which set to designate */
	u_char	whichi;			/* index into which ..	*/
	u_char  ss;			/* flag, single shift G2 / G3 -> GL */
	u_short *Gs;			/* ptr to cur. G2/G3 conversion table*/
	u_char	udkbuf[MAXUDKDEF];	/* buffer for user defined keys */
	struct udkentry ukt;		/* index & length for each udk */
	u_char	udkff;			/* index into buffer first free entry*/
	struct rgb palette[NVGAPEL];	/* saved VGA DAC palette */
	u_char	wd132col;		/* we are on a wd vga and in 132 col */
	u_char	scroll_lock; 		/* scroll lock active */
	u_char	caps_lock;		/* caps lock active */
	u_char	shift_lock;		/* shiftlock flag (virtual ..) */
	u_char	num_lock;		/* num lock, true = keypad num mode */
	u_char	abs_write;		/* write outside of scroll region */
	struct vt_mode smode;		/* screen mode */
	struct proc *proc;		/* current process */
	pid_t	pid;			/* current process id */
	unsigned vt_status;		/* state of the vt */
					/*  becoming active */
	int	kbd_state;		/* keyboard raw or translated */
	
	unsigned short mouse; 		/* mouse cursor position */
	unsigned short cursor;		/* selection cursor position ( if 
					different from mouse cursor pos) */
	unsigned short cpy_start; 	/* position of the copy start mark*/
	unsigned short cpy_end;		/* position of the copy end mark */
	unsigned short orig_start;	/* position of the original sel. start*/
	unsigned short orig_end;	/* position of the original sel. end */
#define MOUSE_VISIBLE 	(1 << 0)	/* flag, the mouse cursor is visible */
#define SEL_EXISTS 	(1 << 1)	/* flag, a selection exists */
#define SEL_IN_PROGRESS (1 << 2)	/* flag, a selection is in progress */
#define SEL_EXT_AFTER 	(1 << 3)	/* flag, selection is extended after */
#define BLANK_TO_EOL	(1 << 4)	/* flag, there are only blanks
					   characters to eol */
#define SEL_BY_CHAR	(1 << 5)	/* flag, select character by character*/
#define SEL_BY_WORD	(1 << 6)	/* flag, select word by word */
#define SEL_BY_LINE	(1 << 7)	/* flag, select line by line */
#define IS_MOUSE_VISIBLE(vsp) ((vsp)->mouse_flags & MOUSE_VISIBLE)
#define IS_SEL_EXISTS(vsp) ((vsp)->mouse_flags & SEL_EXISTS)
#define IS_SEL_IN_PROGRESS(vsp) ((vsp)->mouse_flags & SEL_IN_PROGRESS)
#define IS_SEL_EXT_AFTER(vsp) ((vsp)->mouse_flags & SEL_EXT_AFTER)
#define IS_BLANK_TO_EOL(vsp) ((vsp)->mouse_flags & BLANK_TO_EOL)
#define IS_SEL_BY_CHAR(vsp) ((vsp)->mouse_flags & SEL_BY_CHAR)
#define IS_SEL_BY_WORD(vsp) ((vsp)->mouse_flags & SEL_BY_WORD)
#define IS_SEL_BY_LINE(vsp) ((vsp)->mouse_flags & SEL_BY_LINE)
	unsigned char mouse_flags;	/* flags, status of the mouse */
} video_state;

EXTERN video_state vs[PCVT_NSCREENS];	/* parameters for screens */

/* used to be able to pass ERESTART on properly */
#define PCVT_ERESTART (ELAST + 1)

/* possible states for video_state.vt_status: */

#define	VT_WAIT_REL 1			/* wait till process released vt */
#define VT_WAIT_ACK 2			/* wait till process ack vt acquire */
#define VT_GRAFX    4			/* vt runs graphics mode */
#define VT_WAIT_ACT 8			/* a process is sleeping on this vt */

/* struct describing one slot in the font ram */

struct vga_char_state {
	int	loaded;		/* Whether a font is loaded here */
	int	secondloaded;	/* an extension characterset was loaded, */
				/*	the number is found here	 */
	u_char	char_scanlines;	/* Scanlines per character */
	u_char	scr_scanlines;	/* Low byte of scanlines per screen */
	int	screen_size;	/* Screen size in SIZ_YYROWS */
};

EXTERN struct vga_char_state vgacs[NVGAFONTS];	/* Character set states */

#ifdef WAS_EXTERN

struct vt_softc {
	struct	device sc_dev;
	void	*sc_ih;
};

int pcprobe(struct device *, void *, void *);
void pcattach(struct device *, struct device *, void *);

struct cfattach vt_ca = {
	sizeof(struct vt_softc), pcprobe, pcattach
};

struct cfdriver vt_cd = {
	NULL, "vt", DV_TTY
};

u_char fgansitopc[] = {			/* foreground ANSI color -> pc */
	FG_BLACK, FG_RED, FG_GREEN, FG_BROWN, FG_BLUE,
	FG_MAGENTA, FG_CYAN, FG_LIGHTGREY
};

u_char bgansitopc[] = {			/* background ANSI color -> pc */
	BG_BLACK, BG_RED, BG_GREEN, BG_BROWN, BG_BLUE,
	BG_MAGENTA, BG_CYAN, BG_LIGHTGREY
};

struct tty *pcconsp;		/* ptr to current device, see pcattach() */

u_short *Crtat;			/* screen start address */

u_short *Scrollbuffer;		/* scrollback buffer */
u_short scrollback_pages;	/* size of scrollback buffer (pages) */

video_state *vsp 		= &vs[0]; /* ptr to current screen parms */

int	vt_switch_pending	= 0; 		/* if > 0, a vt switch is */
						/* of the old vt + 1 */
u_int	addr_6845		= MONO_BASE;	/* crtc base addr */
u_char	do_initialization	= 1;		/* we have to init ourselves */
u_char	pcvt_is_console		= 0;		/* until we know it */
u_char 	shift_down 		= 0;		/* shift key down flag */
u_char	ctrl_down		= 0; 		/* ctrl key down flag */
u_char	meta_down		= 0; 		/* alt key down flag */
u_char	altgr_down		= 0; 		/* altgr key down flag */
u_char	kbrepflag		= 1;		/* key repeat flag */
u_char	totalscreens		= 1;		/* screens available */
u_char	current_video_screen	= 0;		/* displayed screen no */
u_char	adaptor_type 		= UNKNOWN_ADAPTOR;/* adaptor type */
u_char 	vga_type 		= VGA_UNKNOWN;	/* vga chipset */
u_char	can_do_132col		= 0;		/* vga chipset can 132 cols */
u_char	vga_family		= 0;		/* vga manufacturer */
u_char	totalfonts		= 0;		/* fonts available */
u_char	chargen_access		= 0;		/* synchronize access */
u_char	keyboard_type		= KB_UNKNOWN;	/* type of keyboard */
u_char	keyboard_is_initialized = 0;		/* for ddb sanity */
u_char	kbd_polling		= 0;		/* keyboard is being polled */

u_char	cursor_pos_valid	= 0;		/* sput left a valid position*/

u_char	critical_scroll		= 0;		/* inside scrolling up */
int	switch_page		= -1;		/* which page to switch to */

#if PCVT_SCREENSAVER
u_char	reset_screen_saver	= 1;		/* reset the saver next time */
u_char	scrnsv_active		= 0;		/* active flag */
unsigned scrnsv_timeout		= 0;		/* initially off */
#endif /* PCVT_SCREENSAVER */

#if PCVT_BACKUP_FONTS
u_char *saved_charsets[NVGAFONTS] = {0};	/* backup copy of fonts */
#endif /* PCVT_BACKUP_FONTS */

/*---------------------------------------------------------------------------

	VT220 attributes -> internal emulator attributes conversion tables

	be careful when designing color combinations, because on
	EGA and VGA displays, bit 3 of the attribute byte is used
	for characterset switching, and is no longer available for
	foreground intensity (bold)!

---------------------------------------------------------------------------*/

/* color displays */

u_char sgr_tab_color[16] = {
/*00*/  (BG_BLACK     | FG_LIGHTGREY),             /* normal               */
/*01*/  (BG_BLUE      | FG_LIGHTGREY),             /* bold                 */
/*02*/  (BG_BROWN     | FG_LIGHTGREY),             /* underline            */
/*03*/  (BG_MAGENTA   | FG_LIGHTGREY),             /* bold+underline       */
/*04*/  (BG_BLACK     | FG_LIGHTGREY | FG_BLINK),  /* blink                */
/*05*/  (BG_BLUE      | FG_LIGHTGREY | FG_BLINK),  /* bold+blink           */
/*06*/  (BG_BROWN     | FG_LIGHTGREY | FG_BLINK),  /* underline+blink      */
/*07*/  (BG_MAGENTA   | FG_LIGHTGREY | FG_BLINK),  /* bold+underline+blink */
/*08*/  (BG_LIGHTGREY | FG_BLACK),                 /* invers               */
/*09*/  (BG_LIGHTGREY | FG_BLUE),                  /* bold+invers          */
/*10*/  (BG_LIGHTGREY | FG_BROWN),                 /* underline+invers     */
/*11*/  (BG_LIGHTGREY | FG_MAGENTA),               /* bold+underline+invers*/
/*12*/  (BG_LIGHTGREY | FG_BLACK      | FG_BLINK), /* blink+invers         */
/*13*/  (BG_LIGHTGREY | FG_BLUE       | FG_BLINK), /* bold+blink+invers    */
/*14*/  (BG_LIGHTGREY | FG_BROWN      | FG_BLINK), /* underline+blink+invers*/
/*15*/  (BG_LIGHTGREY | FG_MAGENTA    | FG_BLINK)  /*bold+underl+blink+invers*/
};

/* monochrome displays (VGA version, no intensity) */

u_char sgr_tab_mono[16] = {
/*00*/  (BG_BLACK     | FG_LIGHTGREY),            /* normal               */
/*01*/  (BG_BLACK     | FG_UNDERLINE),            /* bold                 */
/*02*/  (BG_BLACK     | FG_UNDERLINE),            /* underline            */
/*03*/  (BG_BLACK     | FG_UNDERLINE),            /* bold+underline       */
/*04*/  (BG_BLACK     | FG_LIGHTGREY | FG_BLINK), /* blink                */
/*05*/  (BG_BLACK     | FG_UNDERLINE | FG_BLINK), /* bold+blink           */
/*06*/  (BG_BLACK     | FG_UNDERLINE | FG_BLINK), /* underline+blink      */
/*07*/  (BG_BLACK     | FG_UNDERLINE | FG_BLINK), /* bold+underline+blink */
/*08*/  (BG_LIGHTGREY | FG_BLACK),                /* invers               */
/*09*/  (BG_LIGHTGREY | FG_BLACK),                /* bold+invers          */
/*10*/  (BG_LIGHTGREY | FG_BLACK),                /* underline+invers     */
/*11*/  (BG_LIGHTGREY | FG_BLACK),                /* bold+underline+invers*/
/*12*/  (BG_LIGHTGREY | FG_BLACK | FG_BLINK),     /* blink+invers         */
/*13*/  (BG_LIGHTGREY | FG_BLACK | FG_BLINK),     /* bold+blink+invers    */
/*14*/  (BG_LIGHTGREY | FG_BLACK | FG_BLINK),     /* underline+blink+invers*/
/*15*/  (BG_LIGHTGREY | FG_BLACK | FG_BLINK)      /*bold+underl+blink+invers*/
};

/* monochrome displays (MDA version, with intensity) */

u_char sgr_tab_imono[16] = {
/*00*/  (BG_BLACK     | FG_LIGHTGREY),                /* normal               */
/*01*/  (BG_BLACK     | FG_LIGHTGREY | FG_INTENSE),   /* bold                 */
/*02*/  (BG_BLACK     | FG_UNDERLINE),                /* underline            */
/*03*/  (BG_BLACK     | FG_UNDERLINE | FG_INTENSE),   /* bold+underline       */
/*04*/  (BG_BLACK     | FG_LIGHTGREY | FG_BLINK),     /* blink                */
/*05*/  (BG_BLACK     | FG_LIGHTGREY | FG_INTENSE | FG_BLINK), /* bold+blink  */
/*06*/  (BG_BLACK     | FG_UNDERLINE | FG_BLINK),     /* underline+blink      */
/*07*/  (BG_BLACK     | FG_UNDERLINE | FG_BLINK | FG_INTENSE), /* bold+underline+blink */
/*08*/  (BG_LIGHTGREY | FG_BLACK),                    /* invers               */
/*09*/  (BG_LIGHTGREY | FG_BLACK | FG_INTENSE),       /* bold+invers          */
/*10*/  (BG_LIGHTGREY | FG_BLACK),                    /* underline+invers     */
/*11*/  (BG_LIGHTGREY | FG_BLACK | FG_INTENSE),       /* bold+underline+invers*/
/*12*/  (BG_LIGHTGREY | FG_BLACK | FG_BLINK),         /* blink+invers         */
/*13*/  (BG_LIGHTGREY | FG_BLACK | FG_BLINK | FG_INTENSE),/* bold+blink+invers*/
/*14*/  (BG_LIGHTGREY | FG_BLACK | FG_BLINK),         /* underline+blink+invers*/
/*15*/  (BG_LIGHTGREY | FG_BLACK | FG_BLINK | FG_INTENSE) /* bold+underl+blink+invers */
};

#else /* WAS_EXTERN */

extern u_char		vga_type;
extern struct tty	*pcconsp;
extern video_state	*vsp;

extern int		vt_switch_pending;
extern u_int		addr_6845;
extern u_short		*Crtat;
extern struct isa_driver vtdriver;
extern u_char		do_initialization;
extern u_char		pcvt_is_console;
extern u_char		bgansitopc[];
extern u_char		fgansitopc[];
extern u_char 		shift_down;
extern u_char		ctrl_down;
extern u_char		meta_down;
extern u_char		altgr_down;
extern u_char		kbrepflag;
extern u_char		adaptor_type;
extern u_char		current_video_screen;
extern u_char		totalfonts;
extern u_char		totalscreens;
extern u_char		chargen_access;
extern u_char		keyboard_type;
extern u_char		can_do_132col;
extern u_char		vga_family;
extern u_char		keyboard_is_initialized;
extern u_char		kbd_polling;

extern u_short		*Scrollbuffer;
extern u_short		scrollback_pages;

u_char	cursor_pos_valid;

u_char	critical_scroll;
int	switch_page;

#if PCVT_SCREENSAVER
u_char	reset_screen_saver;
u_char	scrnsv_active;
#endif /* PCVT_SCREENSAVER */

extern u_char		sgr_tab_color[];
extern u_char		sgr_tab_mono[];
extern u_char		sgr_tab_imono[];

#if PCVT_SCREENSAVER
extern unsigned		scrnsv_timeout;
#endif /* PCVT_SCREENSAVER */

#if PCVT_BACKUP_FONTS
extern u_char		*saved_charsets[NVGAFONTS];
#endif /* PCVT_BACKUP_FONTS */

#endif	/* WAS_EXTERN */

#define U_short	int
#define U_char	int
#define Dev_t	dev_t

#define	TIMEOUT_FUNC_T	void *

extern void bcopyb(void *from, void *to, u_int length);

int	pcopen ( Dev_t dev, int flag, int mode, struct proc *p );
int	pcclose ( Dev_t dev, int flag, int mode, struct proc *p );
int	pcread ( Dev_t dev, struct uio *uio, int flag );
int	pcwrite ( Dev_t dev, struct uio *uio, int flag );
int	pcioctl ( Dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p );
int	pcmmap ( Dev_t dev, int offset, int nprot );

struct tty *
	pctty ( Dev_t dev );
int	pcintr ( void *arg);
void	pccnprobe ( struct consdev *cp );
void	pccninit ( struct consdev *cp );
void	pccnputc ( Dev_t dev, U_char c );
int	pccngetc ( Dev_t dev );

int	pcparam ( struct tty *tp, struct termios *t );
void	pcstart ( struct tty *tp );
void	pcstop ( struct tty *tp, int flag );

void	switch_screen ( int n, int oldgrafx, int newgrafx );
int	usl_vt_ioctl (Dev_t dev, u_long cmd,caddr_t data,int flag,struct proc *);
int	vt_activate ( int newscreen );
int	vgapage ( int n );
void	get_usl_keymap( keymap_t *map );
void	reset_usl_modes (struct video_state *vsx);

#if PCVT_SCREENSAVER
void 	pcvt_scrnsv_reset ( void );
void 	pcvt_set_scrnsv_tmo ( int );
#endif /* PCVT_SCREENSAVER */

void	async_update ( void );
void	clr_parms ( struct video_state *svsp );
void	cons_highlight ( void );
void	cons_normal ( void );
int	egavga_test ( void );
struct tty *get_pccons ( Dev_t dev );
int	kbd_cmd ( int val );
void	kbd_code_init ( void );
void	kbd_code_init1 ( void );
void	kbd_setmode(int mode);
int	kbdioctl ( Dev_t dev, u_long cmd, caddr_t data, int flag );
void	loadchar ( int fontset, int character, int char_scanlines,
		   u_char *char_table );
void	mda2egaorvga ( void );
void	roll_up ( struct video_state *svsp, int n );
void	select_vga_charset ( int vga_charset );
void	set_2ndcharset ( void );
void	set_charset ( struct video_state *svsp, int curvgacs );
void	set_screen_size ( struct video_state *svsp, int size );
void	reallocate_scrollbuffer ( struct video_state *svsp, int pages );
void	reallocate_copybuffer ( struct video_state *svsp );
u_char *sgetc ( int noblock );
void	sixel_vga ( struct sixels *charsixel, u_char *charvga );
void	sput ( u_char *s, U_char attrib, int len, int page );
void	sw_cursor ( int onoff );
void	toggl_awm ( struct video_state *svsp );
void	toggl_bell ( struct video_state *svsp );
void	toggl_columns ( struct video_state *svsp );
void	toggl_sevenbit ( struct video_state *svsp );
void	update_led ( u_char cause );
void	vga10_vga10 ( u_char *invga, u_char *outvga );
void	vga10_vga14 ( u_char *invga, u_char *outvga );
void	vga10_vga16 ( u_char *invga, u_char *outvga );
void	vga10_vga8 ( u_char *invga, u_char *outvga );
u_char	vga_chipset ( void );
int	vga_col ( struct video_state *svsp, int cols );
void	vga_move_charset ( unsigned n, unsigned char *b, int save_it);
void	vga_screen_off ( void );
void	vga_screen_on ( void );
int	vga_test ( void );
int	vgaioctl ( Dev_t dev, u_long cmd, caddr_t data, int flag );
void	vgapaletteio ( unsigned idx, struct rgb *val, int writeit );
void	vt_aln ( struct video_state *svsp );
void	vt_clearudk ( struct video_state *svsp );
void	vt_clreol ( struct video_state *svsp );
void	vt_clreos ( struct video_state *svsp );
void	vt_clrtab ( struct video_state *svsp );
int	vt_col ( struct video_state *svsp, int cols );
void	vt_coldinit ( void );
void	vt_coldmalloc ( void );
void	vt_cub ( struct video_state *svsp );
void	vt_cud ( struct video_state *svsp );
void	vt_cuf ( struct video_state *svsp );
void	vt_curadr ( struct video_state *svsp );
void	vt_cuu ( struct video_state *svsp );
void	vt_da ( struct video_state *svsp );
void	vt_dch ( struct video_state *svsp );
void	vt_dcsentry ( U_char ch, struct video_state *svsp );
void	vt_designate ( struct video_state *svsp);
void	vt_dl ( struct video_state *svsp );
void	vt_dld ( struct video_state *svsp );
void	vt_dsr ( struct video_state *svsp );
void	vt_ech ( struct video_state *svsp );
void	vt_ic ( struct video_state *svsp );
void	vt_il ( struct video_state *svsp );
void	vt_ind ( struct video_state *svsp );
void	vt_initsel ( struct video_state *svsp );
void	vt_keyappl ( struct video_state *svsp );
void	vt_keynum ( struct video_state *svsp );
void	vt_mc ( struct video_state *svsp );
void	vt_nel ( struct video_state *svsp );
void	vt_rc ( struct video_state *svsp );
void	vt_reqtparm ( struct video_state *svsp );
void	vt_reset_ansi ( struct video_state *svsp );
void	vt_reset_dec_priv_qm ( struct video_state *svsp );
void	vt_ri ( struct video_state *svsp );
void	vt_ris ( struct video_state *svsp );
void	vt_sc ( struct video_state *svsp );
void	vt_scl ( struct video_state *svsp );
void	vt_sca ( struct video_state *svsp );
void	vt_sd ( struct video_state *svsp );
void	vt_sed ( struct video_state *svsp );
void	vt_sel ( struct video_state *svsp );
void	vt_set_ansi ( struct video_state *svsp );
void	vt_set_dec_priv_qm ( struct video_state *svsp );
void	vt_sgr ( struct video_state *svsp );
void	vt_stbm ( struct video_state *svsp );
void	vt_str ( struct video_state *svsp );
void	vt_su ( struct video_state *svsp );
void	vt_tst ( struct video_state *svsp );
void	vt_udk ( struct video_state *svsp );
void	toggl_24l ( struct video_state *svsp );

#ifdef PCVT_INCLUDE_VT_SELATTR

#define INT_BITS	(sizeof(unsigned int) * 8)
#define INT_INDEX(n)	((n) / INT_BITS)
#define BIT_INDEX(n)	((n) % INT_BITS)

/*---------------------------------------------------------------------------*
 *	set selective attribute if appropriate
 *---------------------------------------------------------------------------*/
static __inline void vt_selattr(struct video_state *svsp)
{
	int i;

	i = (svsp->Crtat + svsp->cur_offset) - svsp->Crtat;

	if(svsp->selchar)
		svsp->decsca[INT_INDEX(i)] |=  (1 << BIT_INDEX(i));
	else
		svsp->decsca[INT_INDEX(i)] &= ~(1 << BIT_INDEX(i));
}

#endif /* PCVT_INCLUDE_VT_SELATTR */


/*---------------------------------------------------------------------------*
 *	produce 7 us delay accessing the keyboard controller
 *---------------------------------------------------------------------------*/

#if PCVT_PORTIO_DELAY
				/* use multiple dummy accesses to port    */
				/* 0x84 to produce keyboard controller    */
				/* access delays                          */
#define PCVT_KBD_DELAY()          \
	{ volatile u_char x = inb(0x84); (void) &x;} \
	{ volatile u_char x = inb(0x84); (void) &x;} \
	{ volatile u_char x = inb(0x84); (void) &x;} \
	{ volatile u_char x = inb(0x84); (void) &x;} \
	{ volatile u_char x = inb(0x84); (void) &x;} \
	{ volatile u_char x = inb(0x84); (void) &x;}

#else /* PCVT_PORTIO_DELAY */
				/* use system supplied delay function for */
				/* producing delays for accesssing the    */
				/* keyboard controller                    */
#define PCVT_KBD_DELAY()	delay(7)
#endif /* PCVT_PORTIO_DELAY */

/* mouse console support prototype */

char *Copybuffer; /* buffer that contains mouse selections */
unsigned int Copybuffer_size;
char Paste_avail; /* flag, to indicate whether a selection is in the
			 Copy buffer */

int mouse_ioctl(Dev_t, u_long, caddr_t, int, struct proc *);
void remove_selection(void);
void mouse_hide(void);
void scrollback_mouse(int);

/*---------------------------------- E O F ----------------------------------*/
@


1.44
log
@keyboard led update lockup patch; pr 1432, smat@@acm.org
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.43 2000/12/21 16:54:53 aaron Exp $	*/
@


1.43
log
@People have difficulty spelling 'initial' and derivatives thereof (too many
"i's" I guess).
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.42 2000/10/26 22:53:31 aaron Exp $	*/
d1032 1
a1032 1
void	update_led ( void );
@


1.42
log
@Remove the notion of "Copybuffer ownership" now that copybuffer contents are
always cleared on logout; from Jean-Baptiste.Marchand@@epita.fr.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.41 2000/10/07 03:12:46 aaron Exp $	*/
d279 1
a279 1
#define CRTC_IROWADDR	0x08		/* inital row address */
@


1.41
log
@- Add console/X mouse transparency, so you don't have to kill moused to run X.
- Introduce `select units' (by char/word/line). Behaves more like an xterm now.
- Serial mice should now work after this commit.
- Many bug fixes.

Work by Jean-Baptiste.Marchand@@epita.fr, except for the X cohabitation code
which was written by Julien.Montagne@@epita.fr.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.40 2000/09/28 17:45:42 aaron Exp $	*/
a1146 3
uid_t Copyowner; /* uid of the owner of the selection, useful for verifying
		    permissions on it
		  */
@


1.40
log
@Make mouse support friendly with non-25line mode. Thanks mickey@@ for reporting
the problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.39 2000/09/22 17:39:05 aaron Exp $	*/
d708 2
d712 2
a713 1
	unsigned short cpy_orig;	/* original copy position */
d717 2
a718 1
#define BLANK_TO_EOL	(1 << 3)	/* flag, there are only blanks
d720 3
a722 2
#define IN_SELECTION	(1 << 4)	/* flag, the cursor is currently in
					   the selection */
d726 1
d728 3
a730 1
#define IS_IN_SELECTION(vsp) ((vsp)->mouse_flags & IN_SELECTION)
@


1.39
log
@- Introduce character classes into the console mouse functionality. Lifted from
  xterm sources. Basically, base word boundaries by character classes rather
  than space characters only.
- On any console logout, clear the contents of the Copybuffer. (This will have
  to be documented with an explanation as to why.) Avoids the ability to paste
  the copybuffer at the ``login:'' prompt after someone has logged out.
- Permit copy selection extension under any circumstance as long as the button
  is held down. However, double-click (word selection) does not yet extend
  on word boundaries like xterms do.
- Sanity checks in current_uid().
- From Jean-Baptiste.Marchand@@epita.fr
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.38 2000/09/04 17:59:49 aaron Exp $	*/
d1015 1
d1138 1
@


1.38
log
@- Changes to mouse_copy_extend() to behave more like an xterm.
- Removed some unused code.
- From Jean-Baptiste.Marchand@@epita.fr
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.36 2000/06/08 22:25:20 niklas Exp $	*/
d716 2
d722 1
@


1.37
log
@Kernel support for new PCVT console mouse features.

- Basic cut/paste functionality.
- Wheel mouse support (wheel rolls page-by-page through scrollback buffer).
- Copybuffer ownership. i.e., if User X logs in the console and selects text,
  when User Y logs in later the buffer cannot be pasted.

Big thanks to Jean-Baptiste Marchand, Julien Montagne, and Jerome Verdon for
implementing this.
@
text
@d714 2
d719 1
@


1.36
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.36 2000/06/08 21:12:02 niklas Exp $	*/
d706 12
d1127 14
@


1.35
log
@- Remove some unused code.
- Much needed indent cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.34 2000/03/23 17:09:48 aaron Exp $	*/
d82 1
@


1.34
log
@<sys/callout.h> is no longer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.33 2000/02/27 19:31:05 aaron Exp $	*/
a614 1
	u_char	dis_fnc;		/* flag, display functions enable */
a1002 1
void	toggl_dspf ( struct video_state *svsp );
@


1.33
log
@- Set scr_offset to -1 at driver init, not 0. Fixes a subtle bug.
- Do not decrement scr_offset on vt_clreol().
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.32 2000/01/17 02:47:36 aaron Exp $	*/
a85 1
#include <sys/callout.h>
d88 1
@


1.32
log
@Remove `pc_disp_special'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.31 1999/12/01 09:59:59 deraadt Exp $	*/
d604 1
a604 1
	u_short scr_offset;		/* current scrollback offset (lines) */
@


1.32.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d604 1
a604 1
	int scr_offset;			/* current scrollback offset (lines) */
@


1.32.2.2
log
@Sync with -current
@
text
@d86 1
a88 1
#include <sys/msgbuf.h>
@


1.32.2.3
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.44 2001/01/22 18:48:43 deraadt Exp $	*/
a81 1
#include <sys/signalvar.h>
d278 1
a278 1
#define CRTC_IROWADDR	0x08		/* initial row address */
d615 1
a705 26
	
	unsigned short mouse; 		/* mouse cursor position */
	unsigned short cursor;		/* selection cursor position ( if 
					different from mouse cursor pos) */
	unsigned short cpy_start; 	/* position of the copy start mark*/
	unsigned short cpy_end;		/* position of the copy end mark */
	unsigned short orig_start;	/* position of the original sel. start*/
	unsigned short orig_end;	/* position of the original sel. end */
#define MOUSE_VISIBLE 	(1 << 0)	/* flag, the mouse cursor is visible */
#define SEL_EXISTS 	(1 << 1)	/* flag, a selection exists */
#define SEL_IN_PROGRESS (1 << 2)	/* flag, a selection is in progress */
#define SEL_EXT_AFTER 	(1 << 3)	/* flag, selection is extended after */
#define BLANK_TO_EOL	(1 << 4)	/* flag, there are only blanks
					   characters to eol */
#define SEL_BY_CHAR	(1 << 5)	/* flag, select character by character*/
#define SEL_BY_WORD	(1 << 6)	/* flag, select word by word */
#define SEL_BY_LINE	(1 << 7)	/* flag, select line by line */
#define IS_MOUSE_VISIBLE(vsp) ((vsp)->mouse_flags & MOUSE_VISIBLE)
#define IS_SEL_EXISTS(vsp) ((vsp)->mouse_flags & SEL_EXISTS)
#define IS_SEL_IN_PROGRESS(vsp) ((vsp)->mouse_flags & SEL_IN_PROGRESS)
#define IS_SEL_EXT_AFTER(vsp) ((vsp)->mouse_flags & SEL_EXT_AFTER)
#define IS_BLANK_TO_EOL(vsp) ((vsp)->mouse_flags & BLANK_TO_EOL)
#define IS_SEL_BY_CHAR(vsp) ((vsp)->mouse_flags & SEL_BY_CHAR)
#define IS_SEL_BY_WORD(vsp) ((vsp)->mouse_flags & SEL_BY_WORD)
#define IS_SEL_BY_LINE(vsp) ((vsp)->mouse_flags & SEL_BY_LINE)
	unsigned char mouse_flags;	/* flags, status of the mouse */
a996 1
void	reallocate_copybuffer ( struct video_state *svsp );
d1004 1
d1006 1
a1006 1
void	update_led ( u_char cause );
a1115 12

/* mouse console support prototype */

char *Copybuffer; /* buffer that contains mouse selections */
unsigned int Copybuffer_size;
char Paste_avail; /* flag, to indicate whether a selection is in the
			 Copy buffer */

int mouse_ioctl(Dev_t, u_long, caddr_t, int, struct proc *);
void remove_selection(void);
void mouse_hide(void);
void scrollback_mouse(int);
@


1.32.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.32.2.3 2001/04/18 16:07:57 niklas Exp $	*/
@


1.31
log
@noone needs to see this anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.30 1999/11/25 21:00:36 aaron Exp $	*/
a578 1
EXTERN	u_char	pcdisp_special;		/* are we printing special chars */
@


1.30
log
@Whoops, didn't mean to step on espie's toes. Also restore some comments
that shouldn't have been removed.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.29 1999/11/25 20:24:21 aaron Exp $	*/
a1016 1
char   *vga_string ( int number );
@


1.29
log
@Remove the keyboard mouse emulator, HP emulation mode, and PCVT_SHOWKEYS
debugging cruft. Also fix a bug where you were not able to hold down the
scrollback hotkeys.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.27 1999/10/20 19:15:51 deraadt Exp $	*/
d951 1
a951 1
int	pcioctl ( Dev_t dev, int cmd, caddr_t data, int flag, struct proc *p );
d967 1
a967 1
int	usl_vt_ioctl (Dev_t dev,int cmd,caddr_t data,int flag,struct proc *);
d988 1
a988 1
int	kbdioctl ( Dev_t dev, int cmd, caddr_t data, int flag );
d1019 1
a1019 1
int	vgaioctl ( Dev_t dev, int cmd, caddr_t data, int flag );
@


1.28
log
@ioctl arguments are u_long.
Replaces `undefined' code with `defined' behavior...

gcc 2.96 performs switch cases range analysis, warns about unreachable
cases, and weeds them out.

In

switch(i) {
case VALUE:
}

VALUE is first coerced into the type of i.  If i is signed, VALUE is
unsigned and exceeds i range, you lose... the result of the conversion
is undefined.
@
text
@a454 13
/*---------------------------------------------------------------------------*
 *	function key labels
 *---------------------------------------------------------------------------*/

#define LABEL_LEN	9		/* length of one label */
#define LABEL_MID	8		/* mid-part (row/col)	*/

#define LABEL_ROWH	((4*LABEL_LEN)+1)
#define LABEL_ROWL	((4*LABEL_LEN)+2)
#define LABEL_COLU	((4*LABEL_LEN)+4)
#define LABEL_COLH	((4*LABEL_LEN)+5)
#define LABEL_COLL	((4*LABEL_LEN)+6)

a503 24
/* sub-states for HP-terminal emulator */

#define SHP_INIT	0

/* esc & f family */

#define SHP_AND_F	1
#define SHP_AND_Fa	2
#define SHP_AND_Fak	3
#define SHP_AND_Fak1	4
#define SHP_AND_Fakd	5
#define SHP_AND_FakdL	6
#define SHP_AND_FakdLl	7
#define SHP_AND_FakdLls	8

/* esc & j family */

#define SHP_AND_J	9
#define SHP_AND_JL	10

/* esc & every-thing-else */

#define SHP_AND_ETE	11

a563 5
/* which fkey-labels */

#define SYS_FKL		0	/* in hp mode, sys-fkls are active */
#define USR_FKL		1	/* in hp mode, user-fkls are active */

a583 2
#if !PCVT_EMU_MOUSE

a585 6
#else /* PCVT_EMU_MOUSE */

EXTERN struct tty *pc_tty[PCVT_NSCREENS + 1];

#endif /* PCVT_EMU_MOUSE */

a646 4
	u_char	ufkl[8][17];		/* user fkey-labels */
	u_char	sfkl[8][17];		/* system fkey-labels */
	u_char	labels_on;		/* display fkey labels etc. on/off */
	u_char	which_fkl;		/* which fkey labels are active */
a649 1
	u_char	hp_state;		/* hp escape sequence state machine */
a659 1
	u_char	vt_pure_mode;		/* no fkey labels, row/col, status */
a733 11
#if PCVT_EMU_MOUSE
struct mousestat {
	struct timeval lastmove; /* last time the pointer moved */
	u_char opened;		 /* someone would like to use a mouse */
	u_char minor;		 /* minor device number */
	u_char buttons;		 /* current "buttons" pressed */
	u_char extendedseen;	 /* 0xe0 has been seen, do not use next key */
	u_char breakseen;	 /* key break has been seen for a sticky btn */
};
#endif /* PCVT_EMU_MOUSE */

a768 5
#if PCVT_EMU_MOUSE
struct mousestat	mouse = {{0}};
struct mousedefs	mousedef = {0x3b, 0x3c, 0x3d, 0,     250000};
#endif /* PCVT_EMU_MOUSE */	/*  F1,   F2,   F3,   false, 0.25 sec */

a792 4
#if PCVT_SHOWKEYS
u_char	keyboard_show		= 0;		/* normal display */
#endif /* PCVT_SHOWKEYS */

a887 5
#if PCVT_EMU_MOUSE
extern struct mousestat mouse;
extern struct mousedefs mousedef;
#endif /* PCVT_EMU_MOUSE */

a914 4
#if PCVT_SHOWKEYS
extern u_char		keyboard_show;
#endif /* PCVT_SHOWKEYS */

d951 1
a951 1
int	pcioctl ( Dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p );
d967 1
a967 1
int	usl_vt_ioctl (Dev_t dev, u_long cmd,caddr_t data,int flag,struct proc *);
a972 4
#if PCVT_EMU_MOUSE
int	mouse_ioctl ( Dev_t dev, int cmd, caddr_t data );
#endif /*  PCVT_EMU_MOUSE */

a982 2
void	fkl_off ( struct video_state *svsp );
void	fkl_on ( struct video_state *svsp );
a983 2
void	init_sfkl ( struct video_state *svsp );
void	init_ufkl ( struct video_state *svsp );
d988 1
a988 1
int	kbdioctl ( Dev_t dev, u_long cmd, caddr_t data, int flag );
a995 1
void	set_emulation_mode ( struct video_state *svsp, int mode );
a1001 3
void	sw_sfkl ( struct video_state *svsp );
void	sw_ufkl ( struct video_state *svsp );
void	swritefkl ( int num, u_char *string, struct video_state *svsp );
a1006 1
void 	update_hp ( struct video_state *svsp );
d1019 1
a1019 1
int	vgaioctl ( Dev_t dev, u_long cmd, caddr_t data, int flag );
@


1.27
log
@special character handling; aaron
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.26 1999/10/16 18:56:35 aaron Exp $	*/
d1036 1
a1036 1
int	pcioctl ( Dev_t dev, int cmd, caddr_t data, int flag, struct proc *p );
d1052 1
a1052 1
int	usl_vt_ioctl (Dev_t dev,int cmd,caddr_t data,int flag,struct proc *);
d1081 1
a1081 1
int	kbdioctl ( Dev_t dev, int cmd, caddr_t data, int flag );
d1117 1
a1117 1
int	vgaioctl ( Dev_t dev, int cmd, caddr_t data, int flag );
@


1.26
log
@- Add support for a traditional PC display (16 colors and use the standard IBM
font) and make it the default mode. This is more or less a hack, since pcvt
was developed only to be a vt220 terminal emulator.
- Document new default mode in pcvt(4).
- Add -o option to scon(1) for toggling between the new and legacy modes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.25 1999/09/29 22:29:10 aaron Exp $	*/
d621 1
@


1.25
log
@- Add an ioctl to pcvt that adjusts the size of the scrollback buffer.
- In scon(1), provide a -b option as an interface to this ioctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.24 1999/09/28 20:36:04 aaron Exp $	*/
d620 1
@


1.24
log
@- Reallocate scrollbuffer when changing linemodes, not loading fonts.
- Now reallocate it when switching VTs, too, since different VTs may be in
  different linemodes.
- Also, cut memory usage in half (thinko on my part in malloc calculation).
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.23 1999/09/08 12:56:42 aaron Exp $	*/
d606 1
a606 1
/* scrollback buffer size (in pages) */
d832 1
d992 1
@


1.23
log
@Remove PCVT_SCROLLBACK option and make it on by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.22 1999/09/06 00:12:40 aaron Exp $	*/
d1087 1
@


1.22
log
@Add scrollback support to the pcvt (i386 only) console driver.

Press LEFT_SHIFT+PGUP/PGDN to navigate. Number of buffered pages is currently
only configurable by editing sys/arch/i386/isa/pcvt/pcvt_hdr.h and changing
the SCROLLBACK_PAGES constant.

You must add "option PCVT_SCROLLBACK" to your kernel config file to enable
this support, or uncomment it from sys/arch/i386/conf/GENERIC.

Known issues:
   - Few little buglets when switching line (font) or column modes in scon(1).
   - Can't hold down LEFT_SHIFT+PGUP/PGDN keys. This will be fixed...

Idea from Linux, code by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.21 1998/09/06 23:00:03 niklas Exp $	*/
a605 2
#ifdef PCVT_SCROLLBACK

a608 2
#endif

a651 1
#ifdef PCVT_SCROLLBACK
a655 1
#endif
a830 1
#ifdef PCVT_SCROLLBACK
a831 1
#endif
a989 1
#ifdef PCVT_SCROLLBACK
a990 1
#endif
@


1.21
log
@Better keyboard timing code mostly from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.20 1998/06/30 20:51:11 millert Exp $	*/
d606 7
d656 6
d837 4
d997 4
@


1.20
log
@In pccngetc, check that dev is not NODEV [NetBSD]
Disallow KDENABIO icotl if securelevel > 1 [NetBSD]
Only define scrnsv_timeout if PCVT_SCREENSAVER set [NetBSD]
Fix setting of keyboard LED's.  For some keyboard controllers the keyboard
    would hang when pcvt set the LED because pcvt did not wait for the
    ACK to come back. [FreeBSD]
Consolidate keyboard type checks into a switch statement. [me]
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.19 1998/06/25 00:40:28 millert Exp $	*/
a1191 5
	{ volatile u_char x = inb(0x84); (void) &x;} \
	{ volatile u_char x = inb(0x84); (void) &x;} \
	{ volatile u_char x = inb(0x84); (void) &x;} \
	{ volatile u_char x = inb(0x84); (void) &x;} \
	{ volatile u_char x = inb(0x84); (void) &x;} \
d1198 1
a1198 1
#define PCVT_KBD_DELAY()	delay(11)
@


1.19
log
@Kill PCVT_NETBSD and PCVT_FREEBSD.  We no longer have to modify pcvt
when we increase the OpenBSD version and our pcvt is now meaningfully
diffable against the NetBSD one.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.18 1998/02/05 16:48:32 deraadt Exp $	*/
d865 1
a867 4
#if XSERVER || PCVT_SCREENSAVER
unsigned scrnsv_timeout		= 0;		/* initially off */
#endif /* XSERVER || PCVT_SCREENSAVER */

d999 1
a999 1
#if defined(XSERVER) || PCVT_SCREENSAVER
d1001 1
a1001 1
#endif /* XSERVER || PCVT_SCREENSAVER */
@


1.18
log
@rename ddb.panic_ddb, and add ddb.console. Now you can stop console ddb entry
with a sysctl. There will be architectures and drivers that lack function,
and I trust the maintainers of those will forget to add the code..
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.17 1998/01/11 06:15:34 deraadt Exp $	*/
a96 1
#if PCVT_NETBSD > 9
a97 1
#endif
a98 2
#if PCVT_NETBSD > 9
#if PCVT_NETBSD > 101
a100 3
#else
#include <i386/isa/isavar.h>
#endif
a102 3
#else
#include <i386/isa/isa_device.h>
#endif
a105 2
#if PCVT_NETBSD > 100
#if PCVT_NETBSD > 101
a106 6
#else
#include <i386/isa/isareg.h>
#endif
#else
#include <i386/isa/isa.h>
#endif
a107 1
#if PCVT_NETBSD > 9
a108 1
#if PCVT_NETBSD > 100
a110 9
#endif
#else
#include <i386/i386/cons.h>
#endif

#if PCVT_NETBSD <= 9
#include <machine/psl.h>
#include <machine/frame.h>
#endif /* PCVT_NETBSD <= 9 */
a113 1
#if PCVT_NETBSD > 9
a114 3
#else
#include <machine/pcvt_ioctl.h>
#endif
a116 4
#if PCVT_FREEBSD > 200
#include <machine/clock.h>
#include <machine/md_var.h>
#endif
a118 24
#if PCVT_FREEBSD > 205
#include <sys/devconf.h>
#endif

/* perform option consistency checks */

#if defined PCVT_FREEBSD && PCVT_FREEBSD == 1
# undef PCVT_FREEBSD
# define PCVT_FREEBSD 102	/* assume 1.0 release */
#endif

#if defined PCVT_NETBSD && PCVT_NETBSD == 1
#undef PCVT_NETBSD
#define PCVT_NETBSD 9		/* assume 0.9 release for now */
#endif

#if PCVT_FREEBSD + PCVT_NETBSD == 0
# error "pcvt_hdr.h: You MUST define one of PCVT_{NET,FREE}BSD \
in the config file"
#elif (PCVT_FREEBSD && PCVT_NETBSD)
# error "pcvt_hdr.h: You CAN only define *one* of PCVT_{NET,FREE}BSD \
in the config file"
#endif

a138 4
#if PCVT_NETBSD
#if PCVT_NETBSD == 9
#include <machine/cpufunc.h>	/* NetBSD 0.9 [...and earlier -currents] */
#else
a140 6
#endif /* PCVT_NETBSD == 9 */
#endif /* PCVT_NETBSD */

#if PCVT_FREEBSD >= 200
#define NEW_AVERUNNABLE		/* new averunnable changes for FreeBSD 2.0 */
#endif
a227 1
#if PCVT_NETBSD > 100
a231 7
#else
#define RTC_EQUIPMENT	0x14	/* equipment byte in cmos ram	*/
#define EQ_EGAVGA	0	/* reserved (= ega/vga)		*/
#define EQ_40COLOR	1	/* display = 40 col color	*/
#define EQ_80COLOR	2	/* display = 80 col color	*/
#define EQ_80MONO	3	/* display = 80 col mono	*/
#endif
a569 3
# if PCVT_FREEBSD && (PCVT_FREEBSD > 102)
#  define MONO_BUF	(KERNBASE+0xB0000)
# else
a570 1
# endif
a575 3
# if PCVT_FREEBSD && (PCVT_FREEBSD > 102)
#  define CGA_BUF	(KERNBASE+0xB8000)
# else
a576 1
# endif
a622 1
#if PCVT_NETBSD
a623 5
#elif !(PCVT_FREEBSD > 110 && PCVT_FREEBSD < 200)
EXTERN struct tty pccons[PCVT_NSCREENS];
#else
EXTERN struct tty *pccons[PCVT_NSCREENS];
#endif /* PCVT_NETBSD */
a626 1
#if PCVT_NETBSD
a627 5
#elif !(PCVT_FREEBSD > 110 && PCVT_FREEBSD < 200)
EXTERN struct tty pccons[PCVT_NSCREENS + 1];
#else
EXTERN struct tty *pccons[PCVT_NSCREENS + 1];
#endif
a793 3
#if PCVT_NETBSD > 9

#if PCVT_NETBSD > 101
a797 1
#endif /* PCVT_NETBSD > 101 */
a798 1
#if PCVT_NETBSD > 100
a799 2
#endif
#if PCVT_NETBSD > 9
a800 1
#endif
a801 1
#if PCVT_NETBSD > 110
a808 22
#else /* !PCVT_NETBSD > 110 */
#if PCVT_NETBSD > 101
struct cfdriver vtcd = {
	NULL, "vt", pcprobe, pcattach, DV_TTY, sizeof(struct vt_softc)
};
#else /* !PCVT_NETBSD > 101 */
struct cfdriver vtcd = {
	NULL, "vt", pcprobe, pcattach, DV_TTY, sizeof(struct device)
};
#endif /* PCVT_NETBSD > 101 */
#endif /* PCVT_NETBSD > 110 */

#else /* !PCVT_NETBSD > 9 */

int pcprobe ( struct isa_device *dev );
int pcattach ( struct isa_device *dev );

struct	isa_driver vtdriver = {		/* driver routines */
	pcprobe, pcattach, "vt",
};

#endif /* PCVT_NETBSD > 9 */
a819 8
#if !PCVT_NETBSD
u_short *Crtat	=	(u_short *)MONO_BUF;	/* screen start address */
#if !(PCVT_FREEBSD > 110 && PCVT_FREEBSD < 200)
struct tty *pcconsp =	&pccons[0];		/* ptr to current device */
#else /* PCVT_FREEBSD > 110 */
struct tty *pcconsp;
#endif /* !(PCVT_FREEBSD > 110) */
#else
a821 1
#if PCVT_NETBSD > 101
a822 3
#endif /* PCVT_NETBSD > 101 */

#endif /* PCVT_NETBSD */
a1011 13
/*
 * FreeBSD > 1.0.2 cleaned up the kernel definitions (with the aim of
 * getting ANSI-clean). Since there has been a mixed usage of types like
 * "dev_t" (actually some short) in prototyped and non-prototyped fasion,
 * each of those types is declared as "int" within function prototypes
 * (which is what the compiler would actually promote it to).
 *
 * The macros below are used to clarify which type a parameter ought to
 * be, regardless of its actual promotion to "int".
 */


#define Dev_t	int
a1013 8

/*
 * In FreeBSD >= 2.0, dev_t has type `unsigned long', so promoting it
 * doesn't cause any problems in prototypes.
 */

#if PCVT_FREEBSD >= 200
#undef Dev_t
a1014 1
#endif
a1015 5
/* in FreeBSD > 102 arguments for timeout()/untimeout() are a special type */

#if PCVT_FREEBSD > 102
#define	TIMEOUT_FUNC_T	timeout_func_t
#else
a1016 1
#endif
a1017 1
#if !PCVT_FREEBSD || (PCVT_FREEBSD < 210)
a1018 5
#endif

#if (PCVT_FREEBSD > 0 && PCVT_FREEBSD < 200) || (PCVT_NETBSD > 0 && PCVT_NETBSD <= 110)
extern void fillw(U_short value, void *addr, u_int length);
#endif
a1025 3
#if PCVT_FREEBSD > 205
struct tty *pcdevtotty ( Dev_t dev );
#endif /* PCVT_FREEBSD > 205 */
a1026 2
#if PCVT_NETBSD
#if PCVT_NETBSD > 101
a1032 6
#else
int	pcrint ( void );
int	pccnprobe ( struct consdev *cp );
int	pccninit ( struct consdev *cp );
int	pccnputc ( Dev_t dev, U_char c );
#endif
a1033 1
#endif /* PCVT_NETBSD */
a1038 18
#if PCVT_FREEBSD
/*
 * In FreeBSD > 2.0.6, driver console functions are declared in i386/cons.h
 * and some return void, so don't declare them here.
 */
#if PCVT_FREEBSD <= 205
int	pccnprobe ( struct consdev *cp );
int	pccninit ( struct consdev *cp );
int	pccngetc ( Dev_t dev );
int	pccncheckc ( Dev_t dev );
int	pccnputc ( Dev_t dev, U_char c );
#endif

# if PCVT_FREEBSD < 200
void	consinit ( void );
# endif
#endif /* PCVT_FREEBSD */

a1051 3
#endif /* PCVT_SCREENSAVER */

#if PCVT_SCREENSAVER
a1205 1
#if PCVT_NETBSD > 9
a1206 3
#elif PCVT_FREEBSD || (PCVT_NETBSD <= 9)
#define PCVT_KBD_DELAY()	DELAY(11)
#endif
@


1.17
log
@scanset probing like pccons does; vons@@usa.net
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.16 1997/11/06 02:26:47 deraadt Exp $	*/
d91 3
@


1.16
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.15 1997/05/29 01:47:26 mickey Exp $	*/
d261 1
d284 1
@


1.15
log
@-Wall w/ PCVT_EMU_MOUSE
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.14 1996/10/17 19:19:02 niklas Exp $	*/
d82 1
@


1.14
log
@One too much ifdef..
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.13 1996/07/16 10:58:36 deraadt Exp $	*/
d961 1
a961 1
struct mousestat	mouse = {0};
@


1.13
log
@pcvt/pccons too fast for some kbds; netbsd pr#2631; mike.long@@analog.com
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.12 1996/06/16 13:54:01 deraadt Exp $	*/
a1257 4
#ifdef XSERVER
void	vga_move_charset ( unsigned n, unsigned char *b, int save_it);
#endif /* XSERVER */

d1302 1
@


1.12
log
@pcvt doesn not recognize IBM Thinkpad keyboards; netbsd pr#2468; jhawk@@mit.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.11 1996/05/25 22:17:55 deraadt Exp $	*/
d1401 5
d1413 1
a1413 1
#define PCVT_KBD_DELAY()	delay(7)
d1415 1
a1415 1
#define PCVT_KBD_DELAY()	DELAY(7)
@


1.11
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.10 1996/05/10 12:46:24 deraadt Exp $	*/
d281 1
@


1.10
log
@simple cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_hdr.h,v 1.6 1996/04/18 17:48:31 niklas Exp $	*/
d105 1
a153 13
#endif

/* setup irq disable function to use */

#if !(PCVT_SLOW_INTERRUPT) && (PCVT_NETBSD > 9)
# define PCVT_DISABLE_INTR()	disable_intr()
# define PCVT_ENABLE_INTR()	enable_intr()
# undef PCVT_SLOW_INTERRUPT
#else
# define PCVT_DISABLE_INTR()	s = spltty()
# define PCVT_ENABLE_INTR()	splx(s)
# undef PCVT_SLOW_INTERRUPT
# define PCVT_SLOW_INTERRUPT 1
@


1.9
log
@fillw is in machine/cpu.h now.
@
text
@d1197 1
a1197 1
#if (!PCVT_FREEBSD || (PCVT_FREEBSD < 200)) && (PCVT_NETBSD < 110)
@


1.8
log
@sync with 0504; prototype changes
@
text
@d1197 1
a1197 1
#if !PCVT_FREEBSD || (PCVT_FREEBSD < 200)
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d907 6
a912 2
int pcprobe ();
void pcattach ();
d1407 6
a1412 6
	{ u_char x = inb(0x84); } \
	{ u_char x = inb(0x84); } \
	{ u_char x = inb(0x84); } \
	{ u_char x = inb(0x84); } \
	{ u_char x = inb(0x84); } \
	{ u_char x = inb(0x84); }
@


1.6
log
@Merge of NetBSD 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d910 9
d928 1
@


1.5
log
@Reorder includes to make it compile again.
@
text
@d1 2
a697 6
/* arguments to async_update() */

#define UPDATE_START	0	/* do cursor update and requeue */
#define UPDATE_STOP	1	/* suspend cursor updates */
#define UPDATE_KERN	2	/* do cursor updates for kernel output */

d1259 1
a1259 1
void	async_update ( int arg );
@


1.4
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d76 1
a83 1
#include <sys/systm.h>
@


1.3
log
@from netbsd; Make sure vt_coldinit() is called before vt_coldmalloc()
@
text
@a74 2
#if PCVT_FREEBSD >= 200

a88 18
#else /* ! PCVT_FREEBSD >= 200 */

#include "param.h"
#include "conf.h"
#include "ioctl.h"
#include "proc.h"
#include "user.h"
#include "tty.h"
#include "uio.h"
#include "callout.h"
#include "systm.h"
#include "kernel.h"
#include "syslog.h"
#include "malloc.h"
#include "time.h"

#endif /* PCVT_FREEBSD >= 200 */

d92 1
a92 1
#include "device.h"
d97 2
a98 2
#include "i386/isa/isa_machdep.h"
#include "dev/isa/isavar.h"
d100 1
a100 1
#include "i386/isa/isavar.h"
d102 2
a103 3

#include "i386/cpufunc.h"
#elif PCVT_FREEBSD >= 200
a104 2
#else
#include "i386/isa/isa_device.h"
a106 1
#if PCVT_FREEBSD >= 200
a107 3
#else
#include "i386/isa/icu.h"
#endif
d111 1
a111 1
#include "dev/isa/isareg.h"
d113 1
a113 1
#include "i386/isa/isareg.h"
d115 1
a115 1
#elif PCVT_FREEBSD >= 200
a116 2
#else
#include "i386/isa/isa.h"
d120 1
a120 1
#include "dev/cons.h"
d122 2
a123 2
#include "dev/ic/mc146818reg.h"
#include "i386/isa/nvram.h"
d125 1
a125 1
#elif PCVT_FREEBSD >= 200
a126 2
#else
#include "i386/i386/cons.h"
a129 1
#if PCVT_FREEBSD >= 200
a131 4
#else /* ! PCVT_FREEBSD >= 200 */
#include "machine/psl.h"
#include "machine/frame.h"
#endif /* PCVT_FREEBSD >= 200 */
a133 1
#if PCVT_FREEBSD >= 200
a134 3
#else
#include "machine/stdarg.h"
#endif
d138 1
a138 1
#elif PCVT_FREEBSD >= 200
a139 2
#else
#include "machine/pcvt_ioctl.h"
a141 1
#if PCVT_FREEBSD >= 200
a147 4
#else /* PCVT_FREEBSD >= 200 */
#include "machine/pc/display.h"
#include "vm/vm_kern.h"
#endif /* PCVT_FREEBSD >= 200 */
d208 1
a208 1
#include "machine/cpufunc.h"	/* NetBSD 0.9 [...and earlier -currents] */
d210 1
a210 1
#include "machine/pio.h"	/* recent NetBSD -currents */
d719 1
a719 3
#if PCVT_NETBSD > 100
/* nothing */
#elif PCVT_NETBSD
d729 1
a729 3
#if PCVT_NETBSD > 100
/* nothing */
#elif PCVT_NETBSD
@


1.2
log
@from netbsd:
Prevent endless loop (-> kernel crash) when a signal is sent to a process
waiting for a vt to become active. Move one ifdef XSERVER to the right place.
@
text
@d1370 1
@


1.1
log
@Initial revision
@
text
@d917 3
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
