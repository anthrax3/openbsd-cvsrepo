head	1.37;
access;
symbols
	SMP_SYNC_A:1.37
	SMP_SYNC_B:1.37
	UBC_SYNC_A:1.37
	UBC_SYNC_B:1.37
	OPENBSD_2_9:1.36.0.4
	OPENBSD_2_9_BASE:1.36
	OPENBSD_2_8:1.36.0.2
	OPENBSD_2_8_BASE:1.36
	OPENBSD_2_7:1.29.0.4
	OPENBSD_2_7_BASE:1.29
	SMP:1.29.0.2
	SMP_BASE:1.29
	kame_19991208:1.29
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.22.0.2
	OPENBSD_2_5_BASE:1.22
	OPENBSD_2_4:1.21.0.2
	OPENBSD_2_4_BASE:1.21
	OPENBSD_2_3:1.19.0.2
	OPENBSD_2_3_BASE:1.19
	OPENBSD_2_2:1.16.0.2
	OPENBSD_2_2_BASE:1.16
	OPENBSD_2_1:1.15.0.2
	OPENBSD_2_1_BASE:1.15
	OPENBSD_2_0:1.14.0.2
	OPENBSD_2_0_BASE:1.14
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2001.05.29.22.09.13;	author mickey;	state dead;
branches;
next	1.36;

1.36
date	2000.10.16.02.25.21;	author aaron;	state Exp;
branches;
next	1.35;

1.35
date	2000.10.07.03.12.45;	author aaron;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.28.17.45.42;	author aaron;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.28.15.44.50;	author aaron;	state Exp;
branches;
next	1.32;

1.32
date	2000.09.22.17.39.05;	author aaron;	state Exp;
branches;
next	1.31;

1.31
date	2000.09.01.05.46.01;	author aaron;	state Exp;
branches;
next	1.30;

1.30
date	2000.07.19.13.39.34;	author art;	state Exp;
branches;
next	1.29;

1.29
date	99.12.01.09.59.59;	author deraadt;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	99.11.26.23.06.29;	author aaron;	state Exp;
branches;
next	1.27;

1.27
date	99.11.25.21.00.35;	author aaron;	state Exp;
branches;
next	1.26;

1.26
date	99.11.25.20.24.20;	author aaron;	state Exp;
branches;
next	1.25;

1.25
date	99.11.20.18.52.00;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	99.09.08.12.56.41;	author aaron;	state Exp;
branches;
next	1.23;

1.23
date	99.09.06.00.12.39;	author aaron;	state Exp;
branches;
next	1.22;

1.22
date	98.11.20.15.57.25;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	98.06.30.20.51.08;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	98.06.25.00.40.25;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	98.02.22.21.35.33;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	98.01.04.12.11.37;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.11.05.09.38.55;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.09.18.16.22.44;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.01.27.23.20.59;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.06.10.07.35.40;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.05.25.22.17.55;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.05.07.07.22.26;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.04.24.18.16.57;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	96.04.21.22.17.07;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.04.18.17.48.28;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.03.29.12.05.42;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.03.20.00.36.07;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.03.19.21.09.46;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.02.20.04.35.37;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	95.12.27.22.10.55;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.06.04.25;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.04.09.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.39;	author deraadt;	state Exp;
branches;
next	;

1.29.2.1
date	2001.04.18.16.07.56;	author niklas;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2001.07.04.10.16.57;	author niklas;	state dead;
branches;
next	;


desc
@@


1.37
log
@remove this used to be great console driver; x11 builds w/o it all fine; aaron@@, todd@@, matthieu@@ ok
@
text
@/*	$OpenBSD: pcvt_drv.c,v 1.36 2000/10/16 02:25:21 aaron Exp $	*/
/*
 * Copyright (c) 1992, 1995 Hellmuth Michaelis and Joerg Wunsch.
 *
 * Copyright (c) 1992, 1993 Brian Dunford-Shore and Scott Turner.
 *
 * Copyright (c) 1993 Charles Hannum.
 *
 * All rights reserved.
 *
 * Parts of this code regarding the NetBSD interface were written
 * by Charles Hannum. Parts regarding OpenBSD written by Aaron Campbell.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz and Don Ahn.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by
 *	Hellmuth Michaelis, Brian Dunford-Shore, Joerg Wunsch, Scott Turner
 *	and Charles Hannum.
 * 4. The name authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @@(#)pcvt_drv.c, 3.32, Last Edit-Date: [Tue Oct  3 11:19:47 1995]
 *
 */

/*---------------------------------------------------------------------------*
 *
 *      pcvt_drv.c      VT220 Driver Main Module / OS - Interface
 *      ---------------------------------------------------------
 *      -hm     ------------ Release 3.00 --------------
 *      -hm     integrating NetBSD-current patches
 *      -hm     adding ttrstrt() proto for NetBSD 0.9
 *      -hm     kernel/console output cursor positioning fixed
 *      -hm     kernel/console output switches optional to screen 0
 *      -hm     FreeBSD 1.1 porting
 *      -hm     the NetBSD 0.9 compiler detected a nondeclared var which was
 *               NOT detected by neither the NetBSD-current nor FreeBSD 1.x!
 *      -hm     including Michael's keyboard fifo code
 *      -hm     Joergs patch for FreeBSD tty-malloc code
 *      -hm     adjustments for NetBSD-current
 *      -hm     FreeBSD bugfix from Joerg re timeout/untimeout casts
 *      -jw     including Thomas Gellekum's FreeBSD 1.1.5 patch
 *      -hm     adjusting #if's for NetBSD-current
 *      -hm     applying Joerg's patch for FreeBSD 2.0
 *      -hm     patch from Onno & Martin for NetBSD-current (post 1.0)
 *      -hm     some adjustments for NetBSD 1.0
 *      -hm     NetBSD PR #400: screen size report for new session
 *      -hm     patch from Rafael Boni/Lon Willett for NetBSD-current
 *      -hm     bell patch from Thomas Eberhardt for NetBSD
 *      -hm     multiple X server bugfixes from Lon Willett
 *      -hm     patch from joerg - pcdevtotty for FreeBSD pre-2.1
 *      -hm     delay patch from Martin Husemann after port-i386 ml-discussion
 *      -jw     add some code to provide more FreeBSD pre-2.1 support
 *      -hm     patches from Michael for NetBSD-current (Apr/21/95) support
 *      -hm     merged in changes from FreeBSD 2.0.5-RELEASE
 *      -hm     NetBSD-current patches from John Kohl
 *      -hm     ---------------- Release 3.30 -----------------------
 *      -hm     patch from Joerg in pcopen() to make mouse emulator work again
 *      -hm     patch from Frank van der Linden for keyboard state per VT
 *      -hm     no TS_ASLEEP anymore in FreeBSD 2.1.0 SNAP 950928
 *      -hm     ---------------- Release 3.32 -----------------------
 *
 *---------------------------------------------------------------------------*/

#include "vt.h"
#if NVT > 0

#define EXTERN			/* allocate mem */

#include "pcvt_hdr.h"		/* global include */

static void vgapelinit(void);	/* read initial VGA DAC palette */

void pccnpollc(Dev_t, int);
int pcprobe(struct device *, void *, void *);
void pcattach(struct device *, struct device *, void *);

#if PCVT_KBD_FIFO
struct timeout pcvt_to;
void pcvt_timeout(void *);
#endif

int
pcprobe(struct device *parent, void *match, void *aux)
{
	kbd_code_init();

	((struct isa_attach_args *)aux)->ia_iosize = 16;
	return 1;
}

void
pcattach(struct device *parent, struct device *self, void *aux)
{
	struct isa_attach_args *ia = aux;
	struct vt_softc *sc = (void *) self;
	int maj;
	int i;

	if(do_initialization)
		vt_coldinit();

	vt_coldmalloc();		/* allocate memory for screens */

	printf(": ");

	switch(adaptor_type) {
		case MDA_ADAPTOR:
			printf("mda");
			break;
		case CGA_ADAPTOR:
			printf("cga");
			break;
		case EGA_ADAPTOR:
			printf("ega");
			break;
		case VGA_ADAPTOR:
			printf("vga 80");
			if(can_do_132col)
				printf("/132");
			printf(" col");
			vgapelinit();
			break;
		default:
			printf("unknown");
			break;
	}

	if (color == 0)
		printf(", mono");
	else
		printf(", color");

	printf(", %d scr, ", totalscreens);

	switch(keyboard_type) {
		case KB_AT:
			printf("at-");
			break;
		case KB_MFII:
			printf("mf2-");
			break;
		default:
			printf("unknown ");
			break;
	}

	printf("kbd\n");

	for (maj = 0; maj < nchrdev; maj++) {
		if ((u_int)cdevsw[maj].d_open == (u_int)pcopen)
			break;
	}

	for (i = 0; i < totalscreens; i++) {
		vs[i].vs_tty = ttymalloc();
		vs[i].vs_tty->t_dev = makedev(maj, i);
		tty_attach(vs[i].vs_tty);
	}

	pcconsp = vs[0].vs_tty;

	async_update();

#if PCVT_KBD_FIFO
	timeout_set(&pcvt_to, pcvt_timeout, NULL);
#endif

	sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_TTY, pcintr, (void *)0, sc->sc_dev.dv_xname);

	/*
 	 * Look for children of the keyboard controller.
	 * XXX Really should decouple keyboard controller
	 * from the console code.
	 */
	while (config_found(self, ia->ia_ic, NULL) != NULL)
		/* will break when no more children */ ;
}

/* had a look at the friedl driver */

struct tty *
get_pccons(Dev_t dev)
{
	register int i = minor(dev);

	if(i >= PCVT_NSCREENS)
		return(NULL);

	return(vs[i].vs_tty);
}


/*---------------------------------------------------------------------------*
 *		/dev/ttyc0, /dev/ttyc1, etc.
 *---------------------------------------------------------------------------*/
int
pcopen(Dev_t dev, int flag, int mode, struct proc *p)
{
	register struct tty *tp;
	register struct video_state *vsx;
	int s, retval;
	int winsz = 0;
	int i = minor(dev);

	vsx = &vs[i];

	if (i == PCVTCTL_MINOR) {
		return (0);
	}
	
  	if((tp = get_pccons(dev)) == NULL)
		return ENXIO;

	vsx->openf++;

	tp->t_oproc = pcstart;
	tp->t_param = pcparam;
	tp->t_dev = dev;

	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN;
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
		pcparam(tp, &tp->t_termios);
		ttsetwater(tp);
	}
	else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0)
		return (EBUSY);

	tp->t_state |= TS_CARR_ON;
	tp->t_cflag |= CLOCAL;	/* cannot be a modem (:-) */

	if ((tp->t_state & TS_ISOPEN) == 0)	/* is this a "cold" open ? */
		winsz = 1;			/* yes, set winsize later  */

	retval = ((*linesw[tp->t_line].l_open)(dev, tp));

	if (winsz == 1) {
		/*
		 * The line discipline has clobbered t_winsize if TS_ISOPEN
	         * was clear. (NetBSD PR #400 from Bill Sommerfeld)
	         * We have to do this after calling the open routine, because
	         * it does some other things in other/older *BSD releases -hm
		 */

		s = spltty();

		tp->t_winsize.ws_col = vsx->maxcol;
		tp->t_winsize.ws_row = vsx->screen_rows;
		tp->t_winsize.ws_xpixel = (vsx->maxcol == 80)? 720: 1056;
		tp->t_winsize.ws_ypixel = 400;

		splx(s);
	}

	return(retval);
}

int
pcclose(Dev_t dev, int flag, int mode, struct proc *p)
{
	register struct tty *tp;
	register struct video_state *vsx;
	int i = minor(dev);

	vsx = &vs[i];

	if((tp = get_pccons(dev)) == NULL)
		return ENXIO;

	(*linesw[tp->t_line].l_close)(tp, flag);
	ttyclose(tp);

	vsx->openf = 0;

	reset_usl_modes(vsx);

	/* remove the selection at logout */
	if (Copybuffer)
		bzero(Copybuffer, Copybuffer_size);
	Paste_avail = 0;	
	
	return(0);
}

int
pcread(Dev_t dev, struct uio *uio, int flag)
{
	register struct tty *tp;

	if((tp = get_pccons(dev)) == NULL)
		return ENXIO;

	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
pcwrite(Dev_t dev, struct uio *uio, int flag)
{
	register struct tty *tp;

	if((tp = get_pccons(dev)) == NULL)
		return ENXIO;

	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

struct tty *
pctty(Dev_t dev)
{
	register struct tty *tp;

	if((tp = get_pccons(dev)) == NULL)
		return 0;

	return tp;
}

int
pcioctl(Dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	register int error;
	register struct tty *tp;

	if((error = mouse_ioctl(dev, cmd, data, flag, p)) >= 0)
		return (error);
	
	if((tp = get_pccons(dev)) == NULL)
		return(ENXIO);

	/* note that some ioctl's are global, e.g.  KBSTPMAT: There is
	 * only one keyboard and different repeat rates for instance between
	 * sessions are a suspicious wish. If you really need this make the
	 * appropriate variables arrays
	 */
	
	if((error = usl_vt_ioctl(dev, cmd, data, flag, p)) >= 0)
		return (error == PCVT_ERESTART) ? ERESTART : error;

	if((error = kbdioctl(dev,cmd,data,flag)) >= 0)
		return error;

	if((error = vgaioctl(dev,cmd,data,flag)) >= 0)
		return error;

	if((error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p)) >= 0)
		return (error);

	if((error = ttioctl(tp, cmd, data, flag, p)) >= 0)
		return (error);

	return (ENOTTY);
}

int
pcmmap(Dev_t dev, int offset, int nprot)
{
	if ((u_int)offset > 0x20000)
		return -1;

	return i386_btop((0xa0000 + offset));
}


/*---------------------------------------------------------------------------*
 *
 *	handle a keyboard receive interrupt
 *
 *	NOTE: the keyboard is multiplexed by means of "pcconsp"
 *	between virtual screens. pcconsp - switching is done in
 *	the vgapage() routine
 *
 *---------------------------------------------------------------------------*/

#if PCVT_KBD_FIFO

u_char pcvt_kbd_fifo[PCVT_KBD_FIFO_SZ];
int pcvt_kbd_wptr = 0;
int pcvt_kbd_rptr = 0;
short pcvt_kbd_count= 0;

void
pcvt_timeout(void *arg)
{
	u_char *cp;

#if PCVT_SCREENSAVER
	pcvt_scrnsv_reset();
#endif /* PCVT_SCREENSAVER */
	while (pcvt_kbd_count) {
		if ((cp = sgetc(1)) && (vs[current_video_screen].openf)) {
#if PCVT_NULLCHARS
			if(*cp == '\0') {
				/* pass a NULL character */
				(*linesw[pcconsp->t_line].l_rint)('\0',
				    pcconsp);
			}
/* XXX */		else
#endif /* PCVT_NULLCHARS */

			while (*cp)
				(*linesw[pcconsp->t_line].l_rint)(*cp++ & 0xff,
				    pcconsp);
		}
	}

	return;
}
#endif

int
pcintr(void *arg)
{

#if PCVT_KBD_FIFO
	u_char	dt;
	u_char	ret = -1;
	int	s;

#else /* !PCVT_KBD_FIFO */
	u_char	*cp;
#endif /* PCVT_KBD_FIFO */

#if PCVT_SCREENSAVER
	pcvt_scrnsv_reset();
#endif /* PCVT_SCREENSAVER */
#if PCVT_KBD_FIFO
	if (kbd_polling) {
		if(sgetc(1) == 0)
			return -1;
		else
			return 1;
	}

	while (inb(CONTROLLER_CTRL) & STATUS_OUTPBF) {	/* check 8042 buffer */
		ret = 1;				/* got something */

		PCVT_KBD_DELAY();			/* 7 us delay */

		dt = inb(CONTROLLER_DATA);		/* get it 8042 data */

		if (pcvt_kbd_count >= PCVT_KBD_FIFO_SZ)	/* fifo overflow ? */
			log (LOG_WARNING, "pcvt: keyboard buffer overflow\n");
		else {
			pcvt_kbd_fifo[pcvt_kbd_wptr++] = dt; /* data -> fifo */

			s = spltty();	/* XXX necessary ? */
			pcvt_kbd_count++;		/* update fifo count */
			splx(s);

			if (pcvt_kbd_wptr >= PCVT_KBD_FIFO_SZ)
				pcvt_kbd_wptr = 0;	/* wraparound pointer */
		}
	}

	if (ret == 1) {	/* got data from keyboard ? */
		if (!timeout_pending(&pcvt_to))	/* if not already active .. */
			timeout_add(&pcvt_to, 1);
	}
	return (ret);

#else /* !PCVT_KBD_FIFO */

	if((cp = sgetc(1)) == 0)
		return -1;

	if (kbd_polling)
		return 1;

	if(!(vs[current_video_screen].openf))	/* XXX was vs[minor(dev)] */
		return 1;

#if PCVT_NULLCHARS
	if(*cp == '\0') {
		/* pass a NULL character */
		(*linesw[pcconsp->t_line].l_rint)('\0', pcconsp);
		return 1;
	}
#endif /* PCVT_NULLCHARS */

	while (*cp)
		(*linesw[pcconsp->t_line].l_rint)(*cp++ & 0xff, pcconsp);
	return 1;

#endif /* PCVT_KBD_FIFO */
}


void
pcstart(register struct tty *tp)
{
	int s, len;
	u_char buf[PCVT_PCBURST];

	s = spltty();

	if (tp->t_state & (TS_TIMEOUT|TS_BUSY|TS_TTSTOP))
		goto out;

	if (tp->t_outq.c_cc == 0 && tp->t_wsel.si_selpid == 0) {
		async_update();
		goto low;
	}

	tp->t_state |= TS_BUSY;

	splx(s);

	/*
	 * We need to do this outside spl since it could be fairly
	 * expensive and we don't want our serial ports to overflow.
	 */

	while ((len = q_to_b(&tp->t_outq, buf, PCVT_PCBURST)) != 0) {
		if (vs[minor(tp->t_dev)].scrolling)
			sgetc(31337);
		if (vsp == &vs[minor(tp->t_dev)]) {
			if (IS_SEL_EXISTS(vsp))  
				/* hides a potential selection */
				remove_selection();
			mouse_hide(); /* hides a potential mouse cursor */
		}
		sput(&buf[0], 0, len, minor(tp->t_dev));
	}

	s = spltty();

	tp->t_state &= ~TS_BUSY;

	tp->t_state |= TS_TIMEOUT;
	timeout_add(&tp->t_rstrt_to, 1);

	if (tp->t_outq.c_cc <= tp->t_lowat) {
low:
		if (tp->t_state&TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}

out:
	splx(s);
}

void
pcstop(struct tty *tp, int flag)
{
}


/*---------------------------------------------------------------------------*
 *		/dev/console
 *---------------------------------------------------------------------------*/
void
pccnprobe(struct consdev *cp)
{
	int maj;

	/* locate the major number */

	for (maj = 0; maj < nchrdev; maj++) {
		if ((u_int)cdevsw[maj].d_open == (u_int)pcopen)
			break;
	}

	if (maj == nchrdev) {
		/* we are not in cdevsw[], give up */
		panic("pcvt is not in cdevsw[]");
	}

	/* initialize required fields */

	cp->cn_dev = makedev(maj, 0);
	cp->cn_pri = CN_INTERNAL;
}

void
pccninit(struct consdev *cp)
{

	pcvt_is_console = 1;
}

void
pccnputc(Dev_t dev, U_char c)
{

#if PCVT_SW0CNOUTP

	if(current_video_screen != 0)
		switch_screen(0, 0, 0);

#endif /* PCVT_SW0CNOUTP */

	if (c == '\n')
		sput("\r", 1, 1, 0);

	sput((char *) &c, 1, 1, 0);

 	async_update();
}

int
pccngetc(Dev_t dev)
{
	register int s;
	register u_char *cp;

#ifdef XSERVER
 	if (dev != NODEV && vs[minor(dev)].kbd_state == K_RAW)
		return 0;
#endif /* XSERVER */

	s = spltty();		/* block pcrint while we poll */
	cp = sgetc(0);
	splx(s);
	async_update();
	
	/* this belongs to cons.c */
	if (*cp == '\r')
		return('\n');

	return (*cp);
}

void
pccnpollc(Dev_t dev, int on)
{
	kbd_polling = on;
	if (!on) {
		register int s;

		/*
		 * If disabling polling, make sure there are no bytes left in
		 * the FIFO, holding up the interrupt line.  Otherwise we
		 * won't get any further interrupts.
		 */
		s = spltty();
		pcintr(NULL);
		splx(s);
	}
}

/*---------------------------------------------------------------------------*
 *	Set line parameters
 *---------------------------------------------------------------------------*/
int
pcparam(struct tty *tp, struct termios *t)
{
	register int cflag = t->c_cflag;

        /* and copy to tty */

        tp->t_ispeed = t->c_ispeed;
        tp->t_ospeed = t->c_ospeed;
        tp->t_cflag = cflag;

	return(0);
}

/*----------------------------------------------------------------------*
 *	read initial VGA palette (as stored by VGA ROM BIOS) into
 *	palette save area
 *----------------------------------------------------------------------*/
void
vgapelinit(void)
{
	register unsigned idx;
	register struct rgb *val;

	/* first, read all and store to first screen's save buffer */
	for(idx = 0, val = vs[0].palette; idx < NVGAPEL; idx++, val++)
		vgapaletteio(idx, val, 0 /* read it */);

	/* now, duplicate for remaining screens */
	for(idx = 1; idx < PCVT_NSCREENS; idx++)
		bcopy(vs[0].palette, vs[idx].palette,
		      NVGAPEL * sizeof(struct rgb));
}

#endif	/* NVT > 0 */

@


1.36
log
@Restore conversion to new timeouts (art@@'s previous commit). They were
whacked by the initial commit for console mouse support. jbm must have been
working with an older revision of PCVT (argh, sorry, should have noticed
this long ago).
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.35 2000/10/07 03:12:45 aaron Exp $	*/
@


1.35
log
@- Add console/X mouse transparency, so you don't have to kill moused to run X.
- Introduce `select units' (by char/word/line). Behaves more like an xterm now.
- Serial mice should now work after this commit.
- Many bug fixes.

Work by Jean-Baptiste.Marchand@@epita.fr, except for the X cohabitation code
which was written by Julien.Montagne@@epita.fr.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.34 2000/09/28 17:45:42 aaron Exp $	*/
d100 5
d187 4
a408 1
static u_char pcvt_timeout_scheduled;
d410 1
a410 1
static void
a412 1
	int s;
a414 2
	pcvt_timeout_scheduled = 0;

a432 7

		s = spltty();

		if (!pcvt_kbd_count)
			pcvt_timeout_scheduled = 0;

		splx(s);
d485 2
a486 6
		if (!pcvt_timeout_scheduled) {	/* if not already active .. */
			s = spltty();
			pcvt_timeout_scheduled = 1;	/* flag active */
			timeout((TIMEOUT_FUNC_T)pcvt_timeout, (caddr_t) 0, 1);
			splx(s);
		}
d559 1
a559 1
	timeout(ttrstrt, tp, 1);
@


1.34
log
@Make mouse support friendly with non-25line mode. Thanks mickey@@ for reporting
the problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.33 2000/09/28 15:44:50 aaron Exp $	*/
d552 1
a552 1
			if (IS_SEL_EXISTS(vsp)) { 
a554 2
				vsp->mouse_flags &= ~SEL_EXISTS;
			}
@


1.33
log
@Make sure a Copybuffer has been allocated successfully before we start doing
things with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.32 2000/09/22 17:39:05 aaron Exp $	*/
d299 1
a299 1
		bzero(Copybuffer, (vs[0].maxcol + 1) * vs[0].screen_rows);
@


1.32
log
@- Introduce character classes into the console mouse functionality. Lifted from
  xterm sources. Basically, base word boundaries by character classes rather
  than space characters only.
- On any console logout, clear the contents of the Copybuffer. (This will have
  to be documented with an explanation as to why.) Avoids the ability to paste
  the copybuffer at the ``login:'' prompt after someone has logged out.
- Permit copy selection extension under any circumstance as long as the button
  is held down. However, double-click (word selection) does not yet extend
  on word boundaries like xterms do.
- Sanity checks in current_uid().
- From Jean-Baptiste.Marchand@@epita.fr
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.31 2000/09/01 05:46:01 aaron Exp $	*/
d298 2
a299 1
	bzero(Copybuffer, (vs[0].maxcol + 1) * vs[0].screen_rows);
@


1.31
log
@Kernel support for new PCVT console mouse features.

- Basic cut/paste functionality.
- Wheel mouse support (wheel rolls page-by-page through scrollback buffer).
- Copybuffer ownership. i.e., if User X logs in the console and selects text,
  when User Y logs in later the buffer cannot be pasted.

Big thanks to Jean-Baptiste Marchand, Julien Montagne, and Jerome Verdon for
implementing this.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.29 1999/12/01 09:59:59 deraadt Exp $	*/
d297 4
@


1.30
log
@Convert to use new timeouts.
Use the t_rstrt_to provided by tty.h.
@
text
@a99 6

#if PCVT_KBD_FIFO
struct timeout pcvt_to;
void pcvt_timeout(void *);
#endif

a181 4
#if PCVT_KBD_FIFO
	timeout_set(&pcvt_to, pcvt_timeout, NULL);
#endif

d222 4
d339 3
d350 1
a350 1

d395 1
d397 1
a397 1
void
d400 1
d403 2
a407 1

d423 7
a451 1

d482 5
a486 2
		if (!timeout_pending(&pcvt_to)) {/* if not already active .. */
			timeout_add(&pcvt_to, 1);
d546 8
d562 1
a562 1
	timeout_add(&tp->t_rstrt_to, 1);
d650 1
a650 1

@


1.29
log
@noone needs to see this anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.28 1999/11/26 23:06:29 aaron Exp $	*/
d100 6
d188 4
a397 1
static u_char pcvt_timeout_scheduled;
d399 1
a399 1
static void
a401 1
	int s;
a403 2
	pcvt_timeout_scheduled = 0;

a422 7

		s = spltty();

		if (!pcvt_kbd_count)
			pcvt_timeout_scheduled = 0;

		splx(s);
d476 2
a477 5
		if (!pcvt_timeout_scheduled) {	/* if not already active .. */
			s = spltty();
			pcvt_timeout_scheduled = 1;	/* flag active */
			timeout((TIMEOUT_FUNC_T)pcvt_timeout, (caddr_t) 0, 1);
			splx(s);
d545 1
a545 1
	timeout(ttrstrt, tp, 1);
@


1.29.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.36 2000/10/16 02:25:21 aaron Exp $	*/
a99 5
#if PCVT_KBD_FIFO
struct timeout pcvt_to;
void pcvt_timeout(void *);
#endif

a181 4
#if PCVT_KBD_FIFO
	timeout_set(&pcvt_to, pcvt_timeout, NULL);
#endif

a221 4
	if (i == PCVTCTL_MINOR) {
		return (0);
	}
	
a292 5
	/* remove the selection at logout */
	if (Copybuffer)
		bzero(Copybuffer, Copybuffer_size);
	Paste_avail = 0;	
	
a334 3
	if((error = mouse_ioctl(dev, cmd, data, flag, p)) >= 0)
		return (error);
	
d343 1
a343 1
	
d388 1
d390 1
a390 1
void
d393 1
d396 2
d401 1
d417 7
d446 1
d477 6
a482 2
		if (!timeout_pending(&pcvt_to))	/* if not already active .. */
			timeout_add(&pcvt_to, 1);
a540 6
		if (vsp == &vs[minor(tp->t_dev)]) {
			if (IS_SEL_EXISTS(vsp))  
				/* hides a potential selection */
				remove_selection();
			mouse_hide(); /* hides a potential mouse cursor */
		}
d549 1
a549 1
	timeout_add(&tp->t_rstrt_to, 1);
d637 1
a637 1
	
@


1.29.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.29.2.1 2001/04/18 16:07:56 niklas Exp $	*/
@


1.28
log
@switch_screen() takes three arguments, not two; d@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.27 1999/11/25 21:00:35 aaron Exp $	*/
d135 1
a135 1
			printf("%s, ", (char *)vga_string(vga_type));
d137 2
a138 3
				printf("80/132 col");
			else
				printf("80 col");
@


1.27
log
@Whoops, didn't mean to step on espie's toes. Also restore some comments
that shouldn't have been removed.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.26 1999/11/25 20:24:20 aaron Exp $	*/
d611 1
a611 1
		switch_screen(0, 0);
@


1.26
log
@Remove the keyboard mouse emulator, HP emulation mode, and PCVT_SHOWKEYS
debugging cruft. Also fix a bug where you were not able to hold down the
scrollback hotkeys.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.24 1999/09/08 12:56:41 aaron Exp $	*/
d4 1
d6 1
d48 39
d331 1
a331 1
pcioctl(Dev_t dev, int cmd, caddr_t data, int flag, struct proc *p)
@


1.25
log
@ioctl arguments are u_long.
Replaces `undefined' code with `defined' behavior...

gcc 2.96 performs switch cases range analysis, warns about unreachable
cases, and weeds them out.

In

switch(i) {
case VALUE:
}

VALUE is first coerced into the type of i.  If i is signed, VALUE is
unsigned and exceeds i range, you lose... the result of the conversion
is undefined.
@
text
@a1 1

a3 1
 *
a4 1
 *
d10 1
a10 1
 * by Charles Hannum.
a41 1
 *
a45 39
/*---------------------------------------------------------------------------*
 *
 *	pcvt_drv.c	VT220 Driver Main Module / OS - Interface
 *	---------------------------------------------------------
 *	-hm	------------ Release 3.00 --------------
 *	-hm	integrating NetBSD-current patches
 *	-hm	adding ttrstrt() proto for NetBSD 0.9
 *	-hm	kernel/console output cursor positioning fixed
 *	-hm	kernel/console output switches optional to screen 0
 *	-hm	FreeBSD 1.1 porting
 *	-hm	the NetBSD 0.9 compiler detected a nondeclared var which was
 *		 NOT detected by neither the NetBSD-current nor FreeBSD 1.x!
 *	-hm	including Michael's keyboard fifo code
 *	-hm	Joergs patch for FreeBSD tty-malloc code
 *	-hm	adjustments for NetBSD-current
 *	-hm	FreeBSD bugfix from Joerg re timeout/untimeout casts
 *	-jw	including Thomas Gellekum's FreeBSD 1.1.5 patch
 *	-hm	adjusting #if's for NetBSD-current
 *	-hm	applying Joerg's patch for FreeBSD 2.0
 *	-hm	patch from Onno & Martin for NetBSD-current (post 1.0)
 *	-hm	some adjustments for NetBSD 1.0
 *	-hm	NetBSD PR #400: screen size report for new session
 *	-hm	patch from Rafael Boni/Lon Willett for NetBSD-current
 *	-hm	bell patch from Thomas Eberhardt for NetBSD
 *	-hm	multiple X server bugfixes from Lon Willett
 *	-hm	patch from joerg - pcdevtotty for FreeBSD pre-2.1
 *	-hm	delay patch from Martin Husemann after port-i386 ml-discussion
 *	-jw	add some code to provide more FreeBSD pre-2.1 support
 *	-hm	patches from Michael for NetBSD-current (Apr/21/95) support
 *	-hm	merged in changes from FreeBSD 2.0.5-RELEASE
 *	-hm	NetBSD-current patches from John Kohl
 *	-hm	---------------- Release 3.30 -----------------------
 *	-hm	patch from Joerg in pcopen() to make mouse emulator work again
 *	-hm	patch from Frank van der Linden for keyboard state per VT
 *	-hm	no TS_ASLEEP anymore in FreeBSD 2.1.0 SNAP 950928
 *	-hm	---------------- Release 3.32 -----------------------
 *
 *---------------------------------------------------------------------------*/

a52 6
#ifdef NOTDEF
unsigned	__debug = 0; /*0xffe */;
static		__color;
static		nrow;
#endif

a53 1
int getchar(void);
a58 1

a61 1

d83 1
a83 2
	switch(adaptor_type)
	{
a86 1

a89 1

a92 1

a100 1

d113 1
a113 2
	switch(keyboard_type)
	{
a116 1

a119 1

d132 1
a132 2
	for(i = 0; i < totalscreens; i++)
	{
a137 4
#if PCVT_EMU_MOUSE
	pc_tty[totalscreens] = ttymalloc(); /* the mouse emulator tty */
#endif /* PCVT_EMU_MOUSE */

a160 5
#if PCVT_EMU_MOUSE
	if(i == totalscreens)
		return(pc_tty[i]);
#endif /* PCVT_EMU_MOUSE */

a179 6
#if PCVT_EMU_MOUSE
	if(i == totalscreens)
		vsx = 0;
	else
#endif /* PCVT_EMU_MOUSE */

a184 12
#if PCVT_EMU_MOUSE
	if(i == totalscreens)
	{
		if(mouse.opened == 0)
			mouse.buttons = mouse.extendedseen =
				mouse.breakseen = mouse.lastmove.tv_sec = 0;
		mouse.minor = i;
		mouse.opened++;
	}
	else
#endif /* PCVT_EMU_MOUSE */

d191 1
a191 2
	if ((tp->t_state & TS_ISOPEN) == 0)
	{
d213 1
a213 7
	if(winsz == 1
#if PCVT_EMU_MOUSE
	   && vsx		/* the mouse device has no vsx */
#endif /* PCVT_EMU_MOUSE */
	    )
	{

a240 6
#if PCVT_EMU_MOUSE
	if(i == totalscreens)
		vsx = 0;
	else
#endif /* PCVT_EMU_MOUSE */

a248 6
#if PCVT_EMU_MOUSE
	if(i == totalscreens)
		mouse.opened = 0;
	else
#endif /* PCVT_EMU_MOUSE */

a250 7
#if PCVT_EMU_MOUSE

	if(i == totalscreens)
		return (0);

#endif /* PCVT_EMU_MOUSE */

d290 1
a290 1
pcioctl(Dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
a303 10
#if PCVT_EMU_MOUSE
	if(minor(dev) == totalscreens)
	{
		if((error = mouse_ioctl(dev, cmd, data)) >= 0)
			return error;
		goto do_standard;
	}
#endif /* PCVT_EMU_MOUSE */


a306 71
#ifdef XSERVER
	/*
	 * just for compatibility:
	 * XFree86 < 2.0 and SuperProbe still might use it
	 *
	 * NB: THIS IS A HACK! Do not use it unless you explicitly need.
	 * Especially, since the vty is not put into process-controlled
	 * mode (this would require the application to co-operate), any
	 * attempts to switch vtys while this kind of X mode is active
	 * may cause serious trouble.
	 */
	switch(cmd)
	{
	  case CONSOLE_X_MODE_ON:
	  {
	    int i;

	    if((error = usl_vt_ioctl(dev, KDENABIO, 0, flag, p)) > 0)
	      return error;

	    i = KD_GRAPHICS;
	    if((error = usl_vt_ioctl(dev, KDSETMODE, (caddr_t)&i, flag, p))
	       > 0)
	      return error;

	    i = K_RAW;
	    error = usl_vt_ioctl(dev, KDSKBMODE, (caddr_t)&i, flag, p);
	    ttyflush(tp, FREAD);
	    return error;
	  }

	  case CONSOLE_X_MODE_OFF:
	  {
	    int i;

	    (void)usl_vt_ioctl(dev, KDDISABIO, 0, flag, p);

	    i = KD_TEXT;
	    (void)usl_vt_ioctl(dev, KDSETMODE, (caddr_t)&i, flag, p);

	    i = K_XLATE;
	    (void)usl_vt_ioctl(dev, KDSKBMODE, (caddr_t)&i, flag, p);
	    ttyflush(tp, FREAD);
	    return 0;
	  }


	  case CONSOLE_X_BELL:

		/*
		 * If `data' is non-null, the first int value denotes
		 * the pitch, the second a duration. Otherwise, behaves
		 * like BEL.
		 */

		if (data)
		{
			sysbeep(((int *)data)[0],
				((int *)data)[1] * hz / 1000);
		}
		else
		{
			sysbeep(PCVT_SYSBEEPF / 1493, hz / 4);
		}
		return (0);

	  default: /* fall through */ ;
	}

#endif /* XSERVER */

a312 4
#if PCVT_EMU_MOUSE
do_standard:
#endif /* PCVT_EMU_MOUSE */

d327 1
d348 1
a348 1
static u_char pcvt_timeout_scheduled = 0;
d350 2
a351 1
static	void	pcvt_timeout (void *arg)
d353 1
a354 1
	int	s;
d362 2
a363 6
	while (pcvt_kbd_count)
	{
		if (((cp = sgetc(1)) != 0) &&
		    (vs[current_video_screen].openf))
		{

d365 1
a365 2
			if(*cp == '\0')
			{
d367 2
a368 1
				(*linesw[pcconsp->t_line].l_rint)('\0', pcconsp);
d374 2
a375 1
				(*linesw[pcconsp->t_line].l_rint)(*cp++ & 0xff, pcconsp);
d408 1
a408 2
	if (kbd_polling)
	{
d415 1
a415 2
	while (inb(CONTROLLER_CTRL) & STATUS_OUTPBF)	/* check 8042 buffer */
	{
a422 1
		{
d424 1
a424 3
		}
		else
		{
d436 2
a437 4
	if (ret == 1)	/* got data from keyboard ? */
	{
		if (!pcvt_timeout_scheduled)	/* if not already active .. */
		{
d440 1
a440 1
			timeout((TIMEOUT_FUNC_T)pcvt_timeout, (caddr_t) 0, 1); /* fire off */
d458 1
a458 2
	if(*cp == '\0')
	{
d484 1
a484 3
	if (tp->t_outq.c_cc == 0 &&
	    tp->t_wsel.si_selpid == 0)
	{
d498 1
a498 2
	while ((len = q_to_b(&tp->t_outq, buf, PCVT_PCBURST)) != 0)
	{
d511 1
a511 2
	if (tp->t_outq.c_cc <= tp->t_lowat)
	{
d513 1
a513 2
		if (tp->t_state&TS_ASLEEP)
		{
a532 1

d540 1
a540 2
	for (maj = 0; maj < nchrdev; maj++)
	{
d545 1
a545 2
	if (maj == nchrdev)
	{
a569 1
	{
a570 1
	}
a607 2
	struct vt_softc *sc = NULL;	/* XXX not used */

d618 1
a618 3

		pcintr(sc);

a639 55
/* special characters */
#define bs	8
#define lf	10
#define cr	13
#define cntlc	3
#define del	0177
#define cntld	4

int
getchar(void)
{
	u_char	thechar;
	int	x;

	kbd_polling = 1;

	x = splhigh();

	sput(">", 1, 1, 0);

	async_update();

	thechar = *(sgetc(0));

	kbd_polling = 0;

	splx(x);

	switch (thechar)
	{
		default:
			if (thechar >= ' ')
				sput(&thechar, 1, 1, 0);
			return(thechar);

		case cr:
		case lf:
			sput("\r\n", 1, 2, 0);
			return(lf);

		case bs:
		case del:
			 sput("\b \b", 1, 3, 0);
			 return(thechar);

		case cntlc:
			 sput("^C\r\n", 1, 4, 0) ;
			 cpu_reset();

		case cntld:
			 sput("^D\r\n", 1, 4, 0) ;
			 return(0);
	}
}

a661 1
/*-------------------------- E O F -------------------------------------*/
@


1.24
log
@Remove PCVT_SCROLLBACK option and make it on by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.23 1999/09/06 00:12:39 aaron Exp $	*/
d404 1
a404 1
pcioctl(Dev_t dev, int cmd, caddr_t data, int flag, struct proc *p)
@


1.23
log
@Add scrollback support to the pcvt (i386 only) console driver.

Press LEFT_SHIFT+PGUP/PGDN to navigate. Number of buffered pages is currently
only configurable by editing sys/arch/i386/isa/pcvt/pcvt_hdr.h and changing
the SCROLLBACK_PAGES constant.

You must add "option PCVT_SCROLLBACK" to your kernel config file to enable
this support, or uncomment it from sys/arch/i386/conf/GENERIC.

Known issues:
   - Few little buglets when switching line (font) or column modes in scon(1).
   - Can't hold down LEFT_SHIFT+PGUP/PGDN keys. This will be fixed...

Idea from Linux, code by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.22 1998/11/20 15:57:25 deraadt Exp $	*/
a709 1
#ifdef PCVT_SCROLLBACK
a711 1
#endif
@


1.22
log
@careful off handling in mmap routines
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.21 1998/06/30 20:51:08 millert Exp $	*/
d709 5
d715 1
@


1.21
log
@In pccngetc, check that dev is not NODEV [NetBSD]
Disallow KDENABIO icotl if securelevel > 1 [NetBSD]
Only define scrnsv_timeout if PCVT_SCREENSAVER set [NetBSD]
Fix setting of keyboard LED's.  For some keyboard controllers the keyboard
    would hang when pcvt set the LED because pcvt did not wait for the
    ACK to come back. [FreeBSD]
Consolidate keyboard type checks into a switch statement. [me]
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.20 1998/06/25 00:40:25 millert Exp $	*/
d524 1
a524 1
	if (offset > 0x20000)
@


1.20
log
@Kill PCVT_NETBSD and PCVT_FREEBSD.  We no longer have to modify pcvt
when we increase the OpenBSD version and our pcvt is now meaningfully
diffable against the NetBSD one.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.19 1998/02/22 21:35:33 niklas Exp $	*/
d803 1
a803 1
 	if (vs[minor(dev)].kbd_state == K_RAW)
@


1.19
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.18 1998/01/04 12:11:37 deraadt Exp $	*/
a104 9
#if PCVT_FREEBSD > 205
static struct kern_devconf kdc_vt[];
static inline void
vt_registerdev(struct isa_device *id, const char *name);
static char vt_description[];
#define VT_DESCR_LEN 40
#endif /* PCVT_FREEBSD > 205 */

#if PCVT_NETBSD > 100
a105 2
#endif
#if PCVT_NETBSD > 100
a106 2
#endif
#if PCVT_NETBSD > 9
a107 1
#endif
a109 1
#if PCVT_NETBSD > 100	/* NetBSD-current Feb 20 1995 */
d112 1
a112 9
#else /* !PCVT_NETBSD > 100 */

#if PCVT_NETBSD > 9
int
pcprobe(struct device *parent, struct device *self, void *aux)
#else /* !PCVT_NETBSD > 9 */
int
pcprobe(struct isa_device *dev)
#endif /* PCVT_NETBSD > 9 */
a113 2
#endif /* PCVT_NETBSD > 100 */
{
a115 1
#if PCVT_NETBSD > 9
a117 10
#else /* !PCVT_NETBSD > 9 */

#if PCVT_NETBSD || PCVT_FREEBSD
	return (16);
#else
	return 1;
#endif /* PCVT_NETBSD || PCVT_FREEBSD */

#endif /* PCVT_NETBSD > 9 */

a119 1
#if PCVT_NETBSD > 9
a123 2

#if PCVT_NETBSD > 101
a124 11
#else /* !PCVT_NETBSD > 101 */
	static struct intrhand vthand;
#endif /* PCVT_NETBSD > 101 */

#else /* !PCVT_NETBSD > 9 */
int
pcattach(struct isa_device *dev)
{
#endif /* PCVT_NETBSD > 9 */

#if PCVT_NETBSD >= 120
a125 1
#endif
a132 3
#if PCVT_NETBSD || PCVT_FREEBSD

#if PCVT_NETBSD > 9
a133 3
#else
	printf("vt%d: ", dev->id_unit);
#endif /* PCVT_NETBSD > 9 */
d163 1
a163 1
	if(color == 0)
a186 3
#if PCVT_NETBSD || (PCVT_FREEBSD > 110 && PCVT_FREEBSD < 200)

#if PCVT_NETBSD >= 120
a190 1
#endif /* PCVT_NETBSD >= 120 */
d194 3
a196 19

#if PCVT_NETBSD > 100
	    vs[i].vs_tty = ttymalloc();
#if PCVT_NETBSD >= 120
	    vs[i].vs_tty->t_dev = makedev(maj, i);
	    tty_attach(vs[i].vs_tty);
#endif /* PCVT_NETBSD >= 120 */
#else /* !PCVT_NETBSD > 100 */

#if PCVT_NETBSD
		pc_tty[i] = ttymalloc();
		vs[i].vs_tty = pc_tty[i];
#else /* !PCVT_NETBSD */
		pccons[i] = ttymalloc(pccons[i]);
		vs[i].vs_tty = pccons[i];
#endif /* PCVT_NETBSD */

#endif /* PCVT_NETBSD > 100 */

a199 1
#if PCVT_NETBSD
a200 4
#else /* !PCVT_NETBSD */
	/* the mouse emulator tty */
	pc_tty[totalscreens] = ttymalloc(pccons[totalscreens]);
#endif /* PCVT_NETBSD */
a202 1
#if PCVT_NETBSD
a203 66
#else  /* !PCVT_NETBSD */
	pcconsp = pccons[0];
#endif  /* PCVT_NETBSD */

#endif /* #if PCVT_NETBSD || (PCVT_FREEBSD > 110 && PCVT_FREEBSD < 200) */

#else /* !PCVT_NETBSD && !PCVT_FREEBSD*/

	switch(adaptor_type)
	{
		case MDA_ADAPTOR:
			printf(" <mda");
			break;

		case CGA_ADAPTOR:
			printf(" <cga");
			break;

		case EGA_ADAPTOR:
			printf(" <ega");
			break;

		case VGA_ADAPTOR:
			printf(" <%s,", (char *)vga_string(vga_type));
			if(can_do_132col)
				printf("80/132 col");
			else
				printf("80 col");
			vgapelinit();
			break;

		default:
			printf(" <unknown");
			break;
	}

	if(color == 0)
		printf(",mono");
	else
		printf(",color");

	printf(",%d scr,", totalscreens);

	switch(keyboard_type)
	{
		case KB_AT:
			printf("at-");
			break;

		case KB_MFII:
			printf("mf2-");
			break;

		default:
			printf("unknown ");
			break;
	}

	printf("kbd,[R%s]>", PCVT_REL);

#endif  /* PCVT_NETBSD || PCVT_FREEBSD */

#if !PCVT_NETBSD && !(PCVT_FREEBSD > 110 && PCVT_FREEBSD < 200)
	for(i = 0; i < totalscreens; i++)
		vs[i].vs_tty = &pccons[i];
#endif /* !PCVT_NETBSD && !(PCVT_FREEBSD > 110 && PCVT_FREEBSD < 200) */
a206 10
#if PCVT_FREEBSD > 205
	/* mark the device busy now if we are the console */
	kdc_vt[dev->id_unit].kdc_state =
		pcvt_is_console? DC_IDLE: DC_BUSY;
	vt_registerdev(dev, (char *)vga_string(vga_type));
#endif /* PCVT_FREEBSD > 205 */

#if PCVT_NETBSD > 9

#if PCVT_NETBSD > 101
a209 1
#if PCVT_NETBSD > 110
a216 14
#endif /* PCVT_NETBSD > 110 */
#else /* PCVT_NETBSD > 100 */
	vthand.ih_fun = pcrint;
	vthand.ih_arg = 0;
	vthand.ih_level = IPL_TTY;
	intr_establish(ia->ia_irq, &vthand);
#endif /* PCVT_NETBSD > 100 */

#else /* PCVT_NETBSD > 9 */

	return 1;

#endif /* PCVT_NETBSD > 9 */

a220 27
#if !PCVT_NETBSD

struct tty *
get_pccons(Dev_t dev)
{
	register int i = minor(dev);

#if PCVT_EMU_MOUSE
 	if(i == totalscreens)
#if !(PCVT_FREEBSD > 110 && PCVT_FREEBSD < 200)
 		return(&pccons[i]);
#else
 		return(pccons[i]);
#endif /* !(PCVT_FREEBSD > 110 && PCVT_FREEBSD < 200) */
#endif /* PCVT_EMU_MOUSE */

	if(i >= PCVT_NSCREENS)
		return(NULL);
#if !(PCVT_FREEBSD > 110 && PCVT_FREEBSD < 200)
	return(&pccons[i]);
#else
	return(pccons[i]);
#endif
}

#else

a236 1
#endif /* !PCVT_NETBSD */
a280 2

#if !(PCVT_FREEBSD > 114)
a281 2
#endif /* !(PCVT_FREEBSD > 114) */

a299 1
#if PCVT_NETBSD || (PCVT_FREEBSD >= 200)
a300 3
#else
	retval = ((*linesw[tp->t_line].l_open)(dev, tp, flag));
#endif /* PCVT_NETBSD || (PCVT_FREEBSD >= 200) */
a325 8
#if PCVT_FREEBSD > 205
	if(retval == 0)
	{
		/* XXX currently, only one vt device is supported */
		kdc_vt[0].kdc_state = DC_BUSY;
	}
#endif

a366 8
#if PCVT_FREEBSD > 205
	if(!pcvt_is_console)
	{
		/* XXX currently, only one vt device is supported */
		kdc_vt[0].kdc_state = DC_IDLE;
	}
#endif

a391 1
#if PCVT_NETBSD > 101
a401 1
#endif /* PCVT_NETBSD > 101 */
a487 2

#if PCVT_NETBSD
a489 5
#else /* PCVT_NETBSD */
			sysbeep(PCVT_SYSBEEPF / ((int *)data)[0],
				((int *)data)[1] * hz / 3000);
#endif /* PCVT_NETBSD */

a511 1
#if PCVT_NETBSD > 9 || PCVT_FREEBSD >= 200
a513 4
#else
	if((error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag)) >= 0)
		return(error);
#endif /* PCVT_NETBSD > 9 || PCVT_FREEBSD >= 200 */
a514 1
#if PCVT_NETBSD > 9
a516 4
#else
	if((error = ttioctl(tp, cmd, data, flag)) >= 0)
		return (error);
#endif /* PCVT_NETBSD > 9 */
a528 37
#if PCVT_FREEBSD > 205
struct tty *
pcdevtotty(Dev_t dev)
{
	return get_pccons(dev);
}

static char vt_descr[VT_DESCR_LEN] = "Graphics console: ";

static struct kern_devconf kdc_vt[NVT] = {
    0, 0, 0,        		/* filled in by dev_attach */
    "vt", 0, { MDDT_ISA, 0, "tty" },
    isa_generic_externalize, 0, 0, ISA_EXTERNALLEN,
    &kdc_isa0,      		/* parent */
    0,          		/* parentdata */
    DC_UNCONFIGURED,		/* until we know it better */
    vt_descr
};

static inline void
vt_registerdev(struct isa_device *id, const char *name)
{
    if(id->id_unit)
	kdc_vt[id->id_unit] = kdc_vt[0];

    kdc_vt[id->id_unit].kdc_unit = id->id_unit;
    kdc_vt[id->id_unit].kdc_isa = id;

    /* XXX only vt0 currently allowed */
    strncpy(vt_descr + sizeof("Graphics console: ") - 1,
	    name,
	    VT_DESCR_LEN - sizeof("Graphics console: "));

    dev_attach(&kdc_vt[id->id_unit]);
}

#endif /* PCVT_FREEBSD > 205 */
a589 1
#if PCVT_NETBSD > 101
a591 4
#else
int
pcrint(void)
#endif
a680 6
#if PCVT_NETBSD || PCVT_FREEBSD >= 200

#if PCVT_NETBSD == 9
extern void ttrstrt();
#endif /* PCVT_NETBSD == 9 */

a717 3
#if PCVT_FREEBSD >= 210 && !defined(TS_ASLEEP)
	ttwakeup(tp);
#else
a727 1
#endif
a737 77
#else /* PCVT_NETBSD || PCVT_FREEBSD >= 200 */

void
pcstart(struct tty *tp)
{
	int s;
	unsigned char c;

	s = spltty();

	if (tp->t_state & (TS_TIMEOUT|TS_BUSY|TS_TTSTOP))
	{
		goto out;
	}

	for(;;)
	{

#if !(PCVT_FREEBSD > 114)

#if !(PCVT_FREEBSD > 111)
		if (RB_LEN(&tp->t_out) <= tp->t_lowat)
#else
		if (RB_LEN(tp->t_out) <= tp->t_lowat)
#endif
		{
			if (tp->t_state&TS_ASLEEP)
			{
				tp->t_state &= ~TS_ASLEEP;
#if !(PCVT_FREEBSD > 111)
				wakeup((caddr_t)&tp->t_out);
#else
				wakeup((caddr_t)tp->t_out);
#endif
			}

			if (tp->t_wsel)
			{
				selwakeup(tp->t_wsel, tp->t_state & TS_WCOLL);
				tp->t_wsel = 0;
				tp->t_state &= ~TS_WCOLL;
			}
		}

#else /* PCVT_FREEBSD > 114 */
		if (tp->t_state & (TS_SO_OCOMPLETE | TS_SO_OLOWAT)
		    || tp->t_wsel) {
			ttwwakeup(tp);
		}
#endif /* !PCVT_FREEBSD > 114 */

#if !(PCVT_FREEBSD > 111)
		if (RB_LEN(&tp->t_out) == 0)
#else
		if (RB_LEN(tp->t_out) == 0)
#endif
		{
			goto out;
		}

#if !(PCVT_FREEBSD > 111)
		c = getc(&tp->t_out);
#else
		c = getc(tp->t_out);
#endif

		tp->t_state |= TS_BUSY;	/* patch from Frank Maclachlan */
		splx(s);
		sput(&c, 0, 1, minor(tp->t_dev));
		spltty();
		tp->t_state &= ~TS_BUSY; /* patch from Frank Maclachlan */
	}
out:
	splx(s);
}

#endif /* PCVT_NETBSD || PCVT_FREEBSD >= 200 */
a742 8
#if !PCVT_NETBSD	/* has moved to cons.c in netbsd-current */
void
consinit()		/* init for kernel messages during boot */
{
}
#endif /* PCVT_NETBSD */

#if (PCVT_NETBSD > 101 || PCVT_FREEBSD > 205)
a744 4
#else
int
pccnprobe(struct consdev *cp)
#endif
a765 15

#if !PCVT_NETBSD

#if !(PCVT_FREEBSD > 110 && PCVT_FREEBSD < 200)
	cp->cn_tp = &pccons[0];
#else
	cp->cn_tp = pccons[0];
#endif /* !(PCVT_FREEBSD > 110 && PCVT_FREEBSD < 200) */

#endif /* !PCVT_NETBSD */

#if ((PCVT_NETBSD  &&  (PCVT_NETBSD <= 101)) || \
     (PCVT_FREEBSD && (PCVT_FREEBSD <= 205)))
	return 1;
#endif
a767 1
#if (PCVT_NETBSD > 101 || PCVT_FREEBSD > 205)
a769 4
#else
int
pccninit(struct consdev *cp)
#endif
d771 1
a772 5

#if ((PCVT_NETBSD  &&  (PCVT_NETBSD <= 101)) || \
     (PCVT_FREEBSD && (PCVT_FREEBSD <= 205)))
	return 0;
#endif
a774 1
#if (PCVT_NETBSD > 101 || PCVT_FREEBSD > 205)
a776 4
#else
int
pccnputc(Dev_t dev, U_char c)
#endif
a793 5

#if ((PCVT_NETBSD  &&  (PCVT_NETBSD <= 101)) || \
     (PCVT_FREEBSD && (PCVT_FREEBSD <= 205)))
	return 0;
#endif
a811 1
#if ! (PCVT_FREEBSD >= 201)
a814 1
#endif /* ! (PCVT_FREEBSD >= 201) */
a818 9
#if PCVT_FREEBSD >= 200
int
pccncheckc(Dev_t dev)
{
	return (sgetc(1) != 0);	/* did someone press the "Any" key? */
}
#endif /* PCVT_FREEBSD >= 200 */

#if PCVT_NETBSD >= 100
a821 1
#if PCVT_NETBSD > 110
a822 5
#else	
#if PCVT_NETBSD > 101
	struct vt_softc *sc = vtcd.cd_devs[0];	/* XXX */
#endif
#endif
a834 1
#if PCVT_NETBSD > 101
a835 3
#else
		pcrint();
#endif
a839 1
#endif /* PCVT_NETBSD >= 100 */
@


1.18
log
@quieter on boot
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.17 1997/11/05 09:38:55 deraadt Exp $	*/
d634 1
a634 1
	register error;
@


1.17
log
@flush tty queue when entering/exiting X; cgd & me
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.16 1997/09/18 16:22:44 deraadt Exp $	*/
d242 1
a242 1
	printf("kbd, [R%s]\n", PCVT_REL);
@


1.16
log
@set t_dev before tty_attach(), so that pstat -s doesn't see a dev_t of 0
when the device has not been opened yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.15 1997/01/27 23:20:59 deraadt Exp $	*/
d686 1
d701 1
@


1.15
log
@select subsystem si_pid becomes si_selpid, to not conflict against user/kernel siginfo si_pid #define
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.14 1996/06/10 07:35:40 deraadt Exp $	*/
d174 3
d246 7
d259 1
@


1.14
log
@tty_attach()
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.13 1996/05/25 22:17:55 deraadt Exp $	*/
d973 1
a973 1
	    tp->t_wsel.si_pid == 0)
@


1.13
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.12 1996/05/07 07:22:26 deraadt Exp $	*/
d248 3
@


1.12
log
@sync with 0504; prototype changes
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.10 1996/04/21 22:17:07 deraadt Exp $	*/
a816 2

#if PCVT_SLOW_INTERRUPT
a817 1
#endif
d844 1
a844 1
		PCVT_DISABLE_INTR ();
d849 1
a849 1
		PCVT_ENABLE_INTR ();
a867 2

# if PCVT_SLOW_INTERRUPT
a868 1
# endif
d903 1
a903 1
			PCVT_DISABLE_INTR ();	/* XXX necessary ? */
d905 1
a905 1
			PCVT_ENABLE_INTR ();
d916 1
a916 1
			PCVT_DISABLE_INTR ();
d919 1
a919 1
			PCVT_ENABLE_INTR ();
@


1.11
log
@This is no longer donatate data for rnd device.
@
text
@d103 1
d113 11
d991 1
a991 1
	while (len = q_to_b(&tp->t_outq, buf, PCVT_PCBURST))
@


1.10
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_drv.c,v 1.9 1996/04/18 17:48:28 niklas Exp $	*/
a94 4
#include "rnd.h"
#if	NRND
#include <dev/rndvar.h>
#endif
a888 3
#if	NRND
		add_keyboard_randomness(dt);
#endif
@


1.9
log
@Merge of NetBSD 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d344 2
a345 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_TTY, pcintr,
	    (void *)0, sc->sc_dev.dv_xname);
d353 1
a353 1
	while (config_found(self, NULL, NULL))
d355 1
a355 1
#endif /* PVCT_NETBSD > 110 */
d1238 3
d1243 1
@


1.8
log
@Initial commit of random source driver.
@
text
@d1 2
d332 1
a332 1
	async_update(UPDATE_START);	/* start asynchronous updates */
d346 10
a961 1
	register struct clist *rbp;
d970 7
a980 2
	async_update(UPDATE_KERN);

d986 1
a986 3
	rbp = &tp->t_outq;

	while (len = q_to_b(rbp, buf, PCVT_PCBURST))
d993 2
a994 5
	if (rbp->c_cc)
	{
		tp->t_state |= TS_TIMEOUT;
		timeout(ttrstrt, tp, 1);
	}
d999 1
a999 1
	if (rbp->c_cc <= tp->t_lowat)
d1001 1
d1005 1
a1005 1
			wakeup((caddr_t)rbp);
d1193 1
a1193 1
 	async_update(UPDATE_KERN);
d1215 1
a1215 1
	async_update(UPDATE_KERN);
d1301 1
a1301 1
	async_update(UPDATE_KERN);
@


1.7
log
@Fix back wrong patches.
@
text
@d93 4
d881 3
@


1.6
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d339 1
a339 1
	    (void *)0);
@


1.5
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d339 1
a339 1
	    (void *)0, sc->sc_dev.dv_xname);
@


1.4
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
@
text
@d339 1
a339 1
	    (void *)0);
@


1.3
log
@from netbsd; Make sure vt_coldinit() is called before vt_coldmalloc()
@
text
@d338 2
a339 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE, ISA_IPL_TTY,
				       pcintr, (void *)0);
@


1.2
log
@from netbsd:
Prevent endless loop (-> kernel crash) when a signal is sent to a process
waiting for a vt to become active. Move one ifdef XSERVER to the right place.
@
text
@d162 3
@


1.1
log
@Initial revision
@
text
@a613 1
#ifdef XSERVER
d616 1
a616 1
		return error;
d618 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
