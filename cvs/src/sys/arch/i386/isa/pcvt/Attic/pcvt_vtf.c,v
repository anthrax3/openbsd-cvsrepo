head	1.19;
access;
symbols
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	UBC_SYNC_A:1.19
	UBC_SYNC_B:1.19
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	SMP:1.12.0.2
	SMP_BASE:1.12
	kame_19991208:1.11
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2001.05.29.22.09.17;	author mickey;	state dead;
branches;
next	1.18;

1.18
date	2001.01.22.18.48.44;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.21.16.54.54;	author aaron;	state Exp;
branches;
next	1.16;

1.16
date	2000.05.31.23.31.42;	author aaron;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.12.13.20.41;	author aaron;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2000.03.30.21.02.11;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.14.16.26.23;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.17.02.46.23;	author aaron;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	99.11.27.21.39.29;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	99.11.25.20.24.22;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	99.11.16.21.57.49;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	99.10.20.19.15.52;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.10.16.18.56.36;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	98.11.16.23.47.57;	author weingart;	state Exp;
branches;
next	1.5;

1.5
date	97.05.30.01.43.07;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.05.07.13.07.06;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.05.07.12.26.33;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.04.18.17.48.37;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.40;	author deraadt;	state Exp;
branches;
next	;

1.12.2.1
date	2000.03.24.09.07.44;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2001.04.18.16.08.03;	author niklas;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2001.07.04.10.17.07;	author niklas;	state dead;
branches;
next	;

1.15.2.1
date	2000.07.01.05.03.46;	author jason;	state Exp;
branches;
next	;


desc
@@


1.19
log
@remove this used to be great console driver; x11 builds w/o it all fine; aaron@@, todd@@, matthieu@@ ok
@
text
@/*	$OpenBSD: pcvt_vtf.c,v 1.18 2001/01/22 18:48:44 deraadt Exp $	*/

/*
 * Copyright (c) 1992, 1995 Hellmuth Michaelis and Joerg Wunsch.
 *
 * Copyright (c) 1992, 1993 Brian Dunford-Shore.
 *
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz and Don Ahn.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Hellmuth Michaelis,
 *	Brian Dunford-Shore and Joerg Wunsch.
 * 4. The name authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * @@(#)pcvt_vtf.c, 3.32, Last Edit-Date: [Tue Oct  3 11:19:49 1995]
 *
 */

/*---------------------------------------------------------------------------*
 *
 *	pcvt_vtf.c	VT220 Terminal Emulator Functions
 *	-------------------------------------------------
 *	-hm	------------ Release 3.00 --------------
 *	-hm	integrating NetBSD-current patches
 *	-hm	integrating patch from Thomas Gellekum
 *	-hm	fixed bug fkey labels not properly (re)set after ris
 *	-hm	Michael Havemester fixed NOFASTSCROLL define bug
 *	-hm	set caps/scroll/num_lock in vt_str() and made led_update()
 *	-hm	applying patch from Joerg fixing Crtat bug
 *	-hm	fixing NOFASTSCROLL operation for MDA/Hercules
 *	-jw/hm	fixing bug in roll_up() and roll_down()
 *	-hm	fastscroll/Crtat bugfix from Lon Willett
 *	-hm	patch for non-XSERVER/UCONSOLE compiles from Rafal Boni
 *	-hm	bugfix: PCVT_USL_COMPAT renamed to PCVT_USL_VT_COMPAT ...
 *	-hm	---------------- Release 3.30 -----------------------
 *	-hm	patch from Thomas Gellekum fixes scroll region bug in vt_stbm()
 *	-hm	patch from Thomas Gellekum to support C1 controls
 *	-hm	patch from Thomas Gellekum re updating GL and GR
 *	-hm	---------------- Release 3.32 -----------------------
 *
 *---------------------------------------------------------------------------*/

#include "vt.h"
#if NVT > 0

#define PCVT_INCLUDE_VT_SELATTR	/* get inline function from pcvt_hdr.h */

#include "pcvt_hdr.h"		/* global include */
#include "pcvt_tbl.h"		/* character set conversion tables */

static void clear_dld ( struct video_state *svsp );
static void init_dld ( struct video_state *svsp );
static void init_udk ( struct video_state *svsp );
static void respond ( struct video_state *svsp );
static void roll_down ( struct video_state *svsp, int n );
static void selective_erase ( struct video_state *svsp, u_short *pcrtat,
			      int length );
static void swcsp ( struct video_state *svsp, u_short *ctp );

/*---------------------------------------------------------------------------*
 *	DECSTBM - set top and bottom margins
 *---------------------------------------------------------------------------*/
void
vt_stbm(struct video_state *svsp)
{
	/* both 0 => scrolling region = entire screen */

	if ((svsp->parms[0] == 0) && (svsp->parms[1] == 0)) {
		svsp->cur_offset = 0;
		svsp->scrr_beg = 0;
		svsp->scrr_len = svsp->screen_rows;
		svsp->scrr_end = svsp->scrr_len - 1;
		svsp->col = 0;
		return;
	}

	if (svsp->parms[1] <= svsp->parms[0])
		return;

	/* range parm 1 */

	if (svsp->parms[0] < 1)
		svsp->parms[0] = 1;
	else if (svsp->parms[0] > svsp->screen_rows - 1)
		svsp->parms[0] = svsp->screen_rows - 1;

	/* range parm 2 */

	if (svsp->parms[1] < 2)
		svsp->parms[1] = 2;
	else if (svsp->parms[1] > svsp->screen_rows)
		svsp->parms[1] = svsp->screen_rows;

	svsp->scrr_beg = svsp->parms[0] - 1;	/* begin of scrolling region */
	svsp->scrr_len = svsp->parms[1] - svsp->parms[0] + 1; /* no of lines */
	svsp->scrr_end = svsp->parms[1] - 1;

	/* cursor to first pos */
	if (svsp->m_om)
		svsp->cur_offset = svsp->scrr_beg * svsp->maxcol;
	else
		svsp->cur_offset = 0;

	svsp->abs_write = 0;
	svsp->col = 0;
}

/*---------------------------------------------------------------------------*
 *	SGR - set graphic rendition
 *---------------------------------------------------------------------------*/
void
vt_sgr(struct video_state *svsp)
{
	register int i = 0;
	u_short setcolor = 0;
	char colortouched = 0;

	setcolor = svsp->c_attr;

	do {
		switch(svsp->parms[i++]) {
		case 0:		/* reset to normal attributes */
			svsp->vtsgr = VT_NORMAL;
			if (pcdisp) {
				setcolor = (FG_LIGHTGREY << 8);
				colortouched = 1;
			}
			break;

		case 1:		/* bold */
			svsp->vtsgr |= VT_BOLD;
			if (pcdisp) {
				if ((setcolor >> 8) == 0)
					setcolor = (FG_LIGHTGREY << 8);
				setcolor |= (FG_INTENSE << 8);
				colortouched = 1;
			}
			break;

		case 4:		/* underline */
			svsp->vtsgr |= VT_UNDER;
			if (pcdisp) {
				setcolor &= ~(0x07 << 8);
				setcolor |= (FG_CYAN << 8);
				colortouched = 1;
			}
			break;

		case 5:		/* blinking */
			svsp->vtsgr |= VT_BLINK;
			if (pcdisp) {
				if ((setcolor >> 8) == 0)
					setcolor = (FG_LIGHTGREY << 8);
				setcolor |= (FG_BLINK << 8);
				colortouched = 1;
			}
			break;

		case 7:		/* reverse */
			if (pcdisp && !(svsp->vtsgr & VT_INVERSE)) {
				if ((setcolor >> 8) == 0)
					setcolor = (FG_LIGHTGREY << 8);
				setcolor = (((setcolor >> 8) & 0x88) |
				    ((((setcolor >> 8) >> 4) |
				    ((setcolor >> 8) << 4)) & 0x77)) << 8;
				colortouched = 1;
			}
			svsp->vtsgr |= VT_INVERSE;
			break;

		case 22:	/* not bold */
			svsp->vtsgr &= ~VT_BOLD;
			if (pcdisp) {
				setcolor &= ~(FG_INTENSE << 8);
				colortouched = 1;
			}
			break;

		case 24:	/* not underlined */
			svsp->vtsgr &= ~VT_UNDER;
			if (pcdisp) {
				setcolor &= ~(0x07 << 8);
				setcolor |= (FG_LIGHTGREY << 8);
			}
			break;

		case 25:	/* not blinking */
			svsp->vtsgr &= ~VT_BLINK;
			if (pcdisp) {
				setcolor &= ~(FG_BLINK << 8);
				colortouched = 1;
			}
			break;

		case 27:	/* not reverse */
			if (pcdisp && (svsp->vtsgr & VT_INVERSE)) {
				setcolor = (((setcolor >> 8) & 0x88) |
				    ((((setcolor >> 8) >> 4) |
				    ((setcolor >> 8) << 4)) & 0x77)) << 8;
				colortouched = 1;
			}
			svsp->vtsgr &= ~VT_INVERSE;
			break;

		case 30:	/* foreground colors */
		case 31:
		case 32:
		case 33:
		case 34:
		case 35:
		case 36:
		case 37:
			if (color) {
				colortouched = 1;
			 	setcolor &= ~(FG_MASK << 8);
			 	setcolor |= ((fgansitopc[(svsp->parms[i - 1] -
				    30) & 7]) << 8);
			 	if (pcdisp && (svsp->vtsgr & VT_BOLD))
					setcolor |= (FG_INTENSE << 8);
			}
			break;

		case 40:	/* background colors */
		case 41:
		case 42:
		case 43:
		case 44:
		case 45:
		case 46:
		case 47:
			if (color) {
				colortouched = 1;
				setcolor &= ~(BG_MASK << 8);
				setcolor |= ((bgansitopc[(svsp->parms[i - 1] -
				    40) & 7]) << 8);
			}
			break;
		}
	} while (i <= svsp->parmi);

	if (color) {
		if (colortouched)
			svsp->c_attr = setcolor;
		else
			svsp->c_attr = ((sgr_tab_color[svsp->vtsgr]) << 8);
	}
	else {
		if (adaptor_type == MDA_ADAPTOR)
			svsp->c_attr = ((sgr_tab_imono[svsp->vtsgr]) << 8);
		else
			svsp->c_attr = ((sgr_tab_mono[svsp->vtsgr]) << 8);
	}
}

/*---------------------------------------------------------------------------*
 *	CUU - cursor up
 *---------------------------------------------------------------------------*/
void
vt_cuu(struct video_state *svsp)
{
	register int p = svsp->parms[0];

	if (p <= 0)				/* parameter min */
		p = 1;

	p = min(p, svsp->row - svsp->scrr_beg);

	if (p <= 0)
		return;

	svsp->cur_offset -= (svsp->maxcol * p);

	if (svsp->scr_offset >= p)
		svsp->scr_offset -= p;
}

/*---------------------------------------------------------------------------*
 *	CUD - cursor down
 *---------------------------------------------------------------------------*/
void
vt_cud(struct video_state *svsp)
{
	register int p = svsp->parms[0];

	if (p <= 0)
		p = 1;

	p = min(p, svsp->scrr_end - svsp->row);

	if (p <= 0)
		return;

	svsp->cur_offset += (svsp->maxcol * p);
}

/*---------------------------------------------------------------------------*
 *	CUF - cursor forward
 *---------------------------------------------------------------------------*/
void
vt_cuf(struct video_state *svsp)
{
	register int p = svsp->parms[0];

	if (svsp->col == ((svsp->maxcol) - 1))	/* already at rt margin */
		return;

	if (p <= 0)				/* parameter min = 1 */
		p = 1;
	else if (p > ((svsp->maxcol) - 1))	/* parameter max = 79 */
		p = ((svsp->maxcol) - 1);

	if ((svsp->col + p) > ((svsp->maxcol) - 1)) /* not more than rt margin */
		p = ((svsp->maxcol) - 1) - svsp->col;

	svsp->cur_offset += p;
	svsp->col += p;
}

/*---------------------------------------------------------------------------*
 *	CUB - cursor backward
 *---------------------------------------------------------------------------*/
void
vt_cub(struct video_state *svsp)
{
	register int p = svsp->parms[0];

	if (svsp->col == 0)			/* already at left margin ? */
		return;

	if (p <= 0)				/* parameter min = 1 */
		p = 1;
	else if (p > ((svsp->maxcol) - 1))	/* parameter max = 79 */
		p = ((svsp->maxcol) - 1);

	if ((svsp->col - p) <= 0)		/* not more than left margin */
		p = svsp->col;

	svsp->cur_offset -= p;
	svsp->col -= p;
}

/*---------------------------------------------------------------------------*
 *	ED - erase in display
 *---------------------------------------------------------------------------*/
void
vt_clreos(struct video_state *svsp)
{
	switch(svsp->parms[0]) {
	case 0:
		fillw(user_attr | ' ',
		    (caddr_t)(svsp->Crtat + svsp->cur_offset),
		    svsp->Crtat + (svsp->maxcol * svsp->screen_rows) -
		    (svsp->Crtat + svsp->cur_offset));
		break;

	case 1:
		fillw(user_attr | ' ', (caddr_t)(svsp->Crtat),
		    svsp->Crtat + svsp->cur_offset - svsp->Crtat + 1);
		break;

	case 2:
		fillw(user_attr | ' ', (caddr_t)(svsp->Crtat),
		    svsp->maxcol * svsp->screen_rows);
		break;
	}
}

/*---------------------------------------------------------------------------*
 *	EL - erase in line
 *---------------------------------------------------------------------------*/
void
vt_clreol(struct video_state *svsp)
{
	switch(svsp->parms[0]) {
	case 0:
		fillw(user_attr | ' ',
		    (caddr_t)(svsp->Crtat + svsp->cur_offset),
		    svsp->maxcol - svsp->col);
		break;

	case 1:
		fillw(user_attr | ' ',
		    (caddr_t)(svsp->Crtat + svsp->cur_offset - svsp->col),
		    svsp->col + 1);
		break;

	case 2:
		fillw(user_attr | ' ',
		    (caddr_t)(svsp->Crtat + svsp->cur_offset - svsp->col),
		    svsp->maxcol);
		break;
	}
}

/*---------------------------------------------------------------------------*
 *	CUP - cursor position / HVP - horizontal & vertical position
 *---------------------------------------------------------------------------*/
void
vt_curadr(struct video_state *svsp)
{
	if (svsp->m_om) {	/* relative to scrolling region */
		if ((svsp->parms[0] == 0) && (svsp->parms[1] == 0)) {
			svsp->cur_offset = svsp->scrr_beg * svsp->maxcol;
			svsp->col = 0;
			svsp->abs_write = 0;
			return;
		}

		if (svsp->parms[0] <= 0)
			svsp->parms[0] = 1;
		else if (svsp->parms[0] > svsp->scrr_len)
			svsp->parms[0] = svsp->scrr_len;

		if (svsp->parms[1] <= 0 )
			svsp->parms[1] = 1;
		if (svsp->parms[1] > svsp->maxcol)
			svsp->parms[1] = svsp->maxcol;

		svsp->cur_offset = (svsp->scrr_beg * svsp->maxcol) +
		    ((svsp->parms[0] - 1) * svsp->maxcol) + svsp->parms[1] - 1;
		svsp->col = svsp->parms[1] - 1;
		svsp->abs_write = 0;
	}
	else {	/* relative to screen start */
		if ((svsp->parms[0] == 0) && (svsp->parms[1] == 0)) {
			svsp->cur_offset = 0;
			svsp->col = 0;
			svsp->abs_write = 0;
			return;
		}

		if (svsp->parms[0] <= 0)
			svsp->parms[0] = 1;
		else if (svsp->parms[0] > svsp->screen_rows)
			svsp->parms[0] = svsp->screen_rows;

		if (svsp->parms[1] <= 0 )
			svsp->parms[1] = 1;
		if (svsp->parms[1] > svsp->maxcol)	/* col */
			svsp->parms[1] = svsp->maxcol;

		svsp->cur_offset = (((svsp->parms[0] - 1) * svsp->maxcol) +
		    (svsp->parms[1] - 1));
		svsp->col = svsp->parms[1]-1;

		if (svsp->cur_offset >=
			((svsp->scrr_beg + svsp->scrr_len + 1) * svsp->maxcol))
			svsp->abs_write = 1;
		else
			svsp->abs_write = 0;
	}
}

/*---------------------------------------------------------------------------*
 *	RIS - reset to initial state (hard emulator runtime reset)
 *---------------------------------------------------------------------------*/
void
vt_ris(struct video_state *svsp)
{
	fillw(user_attr | ' ',
	    (caddr_t)(svsp->Crtat), svsp->maxcol * svsp->screen_rows);
	svsp->cur_offset = 0;		/* cursor upper left corner */
	svsp->col = 0;
	svsp->row = 0;
	svsp->lnm = 0;			/* CR only */
	clear_dld(svsp);		/* clear download charset */
	vt_clearudk(svsp);		/* clear user defined keys */
	svsp->selchar = 0;		/* selective attribute off */
	vt_str(svsp);			/* and soft terminal reset */
}

/*---------------------------------------------------------------------------*
 *	DECSTR - soft terminal reset (SOFT emulator runtime reset)
 *---------------------------------------------------------------------------*/
void
vt_str(struct video_state *svsp)
{
	int i;

	clr_parms(svsp);			/* escape parameter init */
	svsp->state = STATE_INIT;		/* initial state */

	svsp->sc_flag = 0;			/* save cursor position */
	svsp->transparent = 0;			/* enable ctrl code processing*/
	svsp->C1_ctls = 0;			/* but only for C0 codes */
	svsp->sevenbit = 0;			/* data path 8 bits wide */

	for (i = 0; i < MAXTAB; i++) {		/* setup tabstops */
		if (!(i % 8))
			svsp->tab_stops[i] = 1;
		else
			svsp->tab_stops[i] = 0;
	}

	svsp->irm = 0;				/* replace mode */
	svsp->m_om = 0;				/* origin mode */
	svsp->m_awm = 1;			/* auto wrap mode */

#if PCVT_INHIBIT_NUMLOCK
	svsp->num_lock = 0;			/* keypad application mode */
#else
	svsp->num_lock = 1;			/* keypad numeric mode */
#endif

	svsp->scroll_lock = 0;			/* reset keyboard modes */
	svsp->caps_lock = 0;

	svsp->ckm = 1;				/* cursor key mode="normal"  */
	svsp->scrr_beg = 0;			/* start of scrolling region */
	svsp->scrr_len = svsp->screen_rows;	/* #lines in scrolling region */
	svsp->abs_write = 0;			/* scrr is complete screen */
	svsp->scrr_end = svsp->scrr_len - 1;

	if (adaptor_type == EGA_ADAPTOR || adaptor_type == VGA_ADAPTOR) {
		svsp->G0 = cse_ascii;		/* G0 = ascii	*/
		svsp->G1 = cse_ascii;		/* G1 = ascii	*/
		svsp->G2 = cse_supplemental;	/* G2 = supplemental */
		svsp->G3 = cse_supplemental;	/* G3 = supplemental */
	}
	else {
		svsp->G0 = csd_ascii;		/* G0 = ascii	*/
		svsp->G1 = csd_ascii;		/* G1 = ascii	*/
		svsp->G2 = csd_supplemental;	/* G2 = supplemental */
		svsp->G3 = csd_supplemental;	/* G3 = supplemental */
	}
	svsp->GL = svsp->G0;			/* GL = G0 */
	svsp->GR = svsp->G2;			/* GR = G2 */

	svsp->vtsgr = VT_NORMAL;		/* no attributes */
	svsp->c_attr = user_attr;		/* reset sgr to normal */

	svsp->selchar = 0;			/* selective attribute off */
	vt_initsel(svsp);

	update_led(2);				/* update keyboard LED's */
}

/*---------------------------------------------------------------------------*
 *	RI - reverse index, move cursor up
 *---------------------------------------------------------------------------*/
void
vt_ri(struct video_state *svsp)
{
	if(svsp->cur_offset >= ((svsp->scrr_beg * svsp->maxcol) + svsp->maxcol))
		svsp->cur_offset -= svsp->maxcol;
	else
		roll_down(svsp, 1);
}

/*---------------------------------------------------------------------------*
 *	IND - index, move cursor down
 *---------------------------------------------------------------------------*/
void
vt_ind(struct video_state *svsp)
{
	if (svsp->cur_offset < (svsp->scrr_end * svsp->maxcol))
		svsp->cur_offset += svsp->maxcol;
	else
		roll_up(svsp, 1);
}

/*---------------------------------------------------------------------------*
 *	NEL - next line, first pos of next line
 *---------------------------------------------------------------------------*/
void
vt_nel(struct video_state *svsp)
{
	if (svsp->cur_offset < (svsp->scrr_end * svsp->maxcol)) {
		svsp->cur_offset += (svsp->maxcol-svsp->col);
		svsp->col = 0;
	}
	else {
		roll_up(svsp, 1);
		svsp->cur_offset -= svsp->col;
		svsp->col = 0;
	}
}

/*---------------------------------------------------------------------------*
 *	set dec private modes, esc [ ? x h
 *---------------------------------------------------------------------------*/
void
vt_set_dec_priv_qm(struct video_state *svsp)
{
	switch (svsp->parms[0]) {
	case 0:		/* error, ignored */
	case 1:		/* CKM - cursor key mode */
		svsp->ckm = 1;
		break;

	case 2:		/* ANM - ansi/vt52 mode */
		break;

	case 3:		/* COLM - column mode */
		vt_col(svsp, SCR_COL132);
		break;

	case 4:		/* SCLM - scrolling mode */
	case 5:		/* SCNM - screen mode */
		break;

	case 6:		/* OM - origin mode */
		svsp->m_om = 1;
		break;

	case 7:		/* AWM - auto wrap mode */
		svsp->m_awm = 1;
		break;

	case 8:		/* ARM - auto repeat mode */
		kbrepflag = 1;
		break;

	case 9:		/* INLM - interlace mode */
	case 10:	/* EDM - edit mode */
	case 11:	/* LTM - line transmit mode */
	case 12:	/* */
	case 13:	/* SCFDM - space compression / field delimiting */
	case 14:	/* TEM - transmit execution mode */
	case 15:	/* */
	case 16:	/* EKEM - edit key execution mode */
		break;

	case 25:	/* TCEM - text cursor enable mode */
		if (vsp == svsp)
			sw_cursor(1);	/* cursor on */
		svsp->cursor_on = 1;
		break;

	case 42:	/* NRCM - 7bit NRC characters */
		break;
	}
}

/*---------------------------------------------------------------------------*
 *	reset dec private modes, esc [ ? x l
 *---------------------------------------------------------------------------*/
void
vt_reset_dec_priv_qm(struct video_state *svsp)
{
	switch (svsp->parms[0]) {
	case 0:		/* error, ignored */
	case 1:		/* CKM - cursor key mode */
		svsp->ckm = 0;
		break;

	case 2:		/* ANM - ansi/vt52 mode */
		break;

	case 3:		/* COLM - column mode */
		vt_col(svsp, SCR_COL80);
		break;

	case 4:		/* SCLM - scrolling mode */
	case 5:		/* SCNM - screen mode */
		break;

	case 6:		/* OM - origin mode */
		svsp->m_om = 0;
		break;

	case 7:		/* AWM - auto wrap mode */
		svsp->m_awm = 0;
		break;

	case 8:		/* ARM - auto repeat mode */
		kbrepflag = 0;
		break;

	case 9:		/* INLM - interlace mode */
	case 10:	/* EDM - edit mode */
	case 11:	/* LTM - line transmit mode */
	case 12:	/* */
	case 13:	/* SCFDM - space compression / field delimiting */
	case 14:	/* TEM - transmit execution mode */
	case 15:	/* */
	case 16:	/* EKEM - edit key execution mode */
		break;

	case 25:	/* TCEM - text cursor enable mode */
		if (vsp == svsp)
			sw_cursor(0);	/* cursor off */
		svsp->cursor_on = 0;
		break;

	case 42:	/* NRCM - 7bit NRC characters */
		break;
	}
}

/*---------------------------------------------------------------------------*
 *	set ansi modes, esc [ x
 *---------------------------------------------------------------------------*/
void
vt_set_ansi(struct video_state *svsp)
{
	switch (svsp->parms[0]) {
	case 0:		/* error, ignored */
	case 1:		/* GATM - guarded area transfer mode */
	case 2:		/* KAM - keyboard action mode */
	case 3:		/* CRM - Control Representation mode */
		break;

	case 4:		/* IRM - insert replacement mode */
		svsp->irm = 1; /* Insert mode */
		break;

	case 5:		/* SRTM - status report transfer mode */
	case 6:		/* ERM - erasue mode */
	case 7:		/* VEM - vertical editing mode */
	case 10:	/* HEM - horizontal editing mode */
	case 11:	/* PUM - position unit mode */
	case 12:	/* SRM - send-receive mode */
	case 13:	/* FEAM - format effector action mode */
	case 14:	/* FETM - format effector transfer mode */
	case 15:	/* MATM - multiple area transfer mode */
	case 16:	/* TTM - transfer termination */
	case 17:	/* SATM - selected area transfer mode */
	case 18:	/* TSM - tabulation stop mode */
	case 19:	/* EBM - editing boundary mode */
		break;

	case 20:	/* LNM - line feed / newline mode */
		svsp->lnm = 1;
		break;
	}
}

/*---------------------------------------------------------------------------*
 *	reset ansi modes, esc [ x
 *---------------------------------------------------------------------------*/
void
vt_reset_ansi(struct video_state *svsp)
{
	switch (svsp->parms[0]) {
	case 0:		/* error, ignored */
	case 1:		/* GATM - guarded area transfer mode */
	case 2:		/* KAM - keyboard action mode */
	case 3:		/* CRM - Control Representation mode */
		break;

	case 4:		/* IRM - insert replacement mode */
		svsp->irm = 0;  /* Replace mode */
		break;

	case 5:		/* SRTM - status report transfer mode */
	case 6:		/* ERM - erasue mode */
	case 7:		/* VEM - vertical editing mode */
	case 10:	/* HEM - horizontal editing mode */
	case 11:	/* PUM - position unit mode */
	case 12:	/* SRM - send-receive mode */
	case 13:	/* FEAM - format effector action mode */
	case 14:	/* FETM - format effector transfer mode */
	case 15:	/* MATM - multiple area transfer mode */
	case 16:	/* TTM - transfer termination */
	case 17:	/* SATM - selected area transfer mode */
	case 18:	/* TSM - tabulation stop mode */
	case 19:	/* EBM - editing boundary mode */
		break;

	case 20:	/* LNM - line feed / newline mode */
		svsp->lnm = 0;
		break;
	}
}

/*---------------------------------------------------------------------------*
 *	clear tab stop(s)
 *---------------------------------------------------------------------------*/
void
vt_clrtab(struct video_state *svsp)
{
	int i;

	if (svsp->parms[0] == 0)
		svsp->tab_stops[svsp->col] = 0;
	else if (svsp->parms[0] == 3) {
		for (i = 0; i < MAXTAB; i++)
			svsp->tab_stops[i] = 0;
	}
}

/*---------------------------------------------------------------------------*
 *	DECSC - save cursor & attributes
 *---------------------------------------------------------------------------*/
void
vt_sc(struct video_state *svsp)
{
	svsp->sc_flag = 1;
	svsp->sc_row = svsp->row;
	svsp->sc_col = svsp->col;
	svsp->sc_cur_offset = svsp->cur_offset;
	svsp->sc_attr = svsp->c_attr;
	svsp->sc_awm = svsp->m_awm;
	svsp->sc_om = svsp->m_om;
	svsp->sc_G0 = svsp->G0;
	svsp->sc_G1 = svsp->G1;
	svsp->sc_G2 = svsp->G2;
	svsp->sc_G3 = svsp->G3;
	svsp->sc_GL = svsp->GL;
	svsp->sc_GR = svsp->GR;
	svsp->sc_sel = svsp->selchar;
	svsp->sc_vtsgr = svsp->vtsgr;
}

/*---------------------------------------------------------------------------*
 *	DECRC - restore cursor & attributes
 *---------------------------------------------------------------------------*/
void
vt_rc(struct video_state *svsp)
{
	if (svsp->sc_flag == 1) {
		svsp->sc_flag = 0;
		svsp->row = svsp->sc_row;
		svsp->col = svsp->sc_col;
		svsp->cur_offset = svsp->sc_cur_offset;
		svsp->c_attr = svsp->sc_attr;
		svsp->m_awm = svsp->sc_awm;
		svsp->m_om = svsp->sc_om;
		svsp->G0 = svsp->sc_G0;
		svsp->G1 = svsp->sc_G1;
		svsp->G2 = svsp->sc_G2;
		svsp->G3 = svsp->sc_G3;
		svsp->GL = svsp->sc_GL;
		svsp->GR = svsp->sc_GR;
		svsp->selchar = svsp->sc_sel;
		svsp->vtsgr = svsp->sc_vtsgr;
	}
}

/*---------------------------------------------------------------------------*
 *	designate a character set as G0, G1, G2 or G3 for 94/96 char sets
 *---------------------------------------------------------------------------*/
void
vt_designate(struct video_state *svsp)
{
	u_short *ctp = NULL;
	u_char ch;

	if (svsp->whichi == 1)
		ch = svsp->which[0];
	else {
		int i;

		if (svsp->dld_id[0] == '\0')
			return;

		if (!(((adaptor_type == EGA_ADAPTOR) ||
		     (adaptor_type == VGA_ADAPTOR)) &&
		     (vgacs[svsp->vga_charset].secondloaded)))
			return;

		for (i = (svsp->whichi) - 1; i >= 0; i--) {
			 if (svsp->which[i] != svsp->dld_id[i])
				return;
		}
#ifdef HAVECSE_DOWNLOADABLE
		ctp = cse_downloadable;
		swcsp(svsp, ctp);
#endif
		return;
	}

	if (((adaptor_type == EGA_ADAPTOR) || (adaptor_type == VGA_ADAPTOR)) &&
	   (vgacs[svsp->vga_charset].secondloaded)) {
		if ((ch == svsp->dld_id[0]) && (svsp->dld_id[1] == '\0')) {
#ifdef HAVECSE_DOWNLOADABLE
			ctp = cse_downloadable;
			swcsp(svsp, ctp);
#endif
			return;
		}

		switch (ch) {
		case 'A': /* British or ISO-Latin-1 */
			switch (svsp->state) {
			case STATE_BROPN: /* designate G0 */
			case STATE_BRCLO: /* designate G1 */
			case STATE_STAR:  /* designate G2 */
			case STATE_PLUS:  /* designate G3 */
#ifdef HAVECSE_BRITISH
				ctp = cse_british;
#endif
				break;

			case STATE_MINUS: /* designate G1 (96)*/
			case STATE_DOT:	  /* designate G2 (96)*/
			case STATE_SLASH: /* designate G3 (96)*/
#ifdef HAVECSE_ISOLATIN
				ctp = cse_isolatin;
#endif
				break;
			}
			break;

		case 'B': /* USASCII */
#ifdef HAVECSE_ASCII
			ctp = cse_ascii;
#endif
			break;

		case 'C': /* Finnish */
		case '5': /* Finnish */
#ifdef HAVECSE_FINNISH
			ctp = cse_finnish;
#endif
			break;

		case 'E': /* Norwegian/Danish */
		case '6': /* Norwegian/Danish */
#ifdef HAVECSE_NORWEGIANDANISH
			ctp = cse_norwegiandanish;
#endif
			break;

		case 'H': /* Swedish */
		case '7': /* Swedish */
#ifdef HAVECSE_SWEDISH
			ctp = cse_swedish;
#endif
			break;

		case 'K': /* German */
#ifdef HAVECSE_GERMAN
			ctp = cse_german;
#endif
			break;

		case 'Q': /* French Canadien */
#ifdef HAVECSE_FRENCHCANADA
			ctp = cse_frenchcanada;
#endif
			break;

		case 'R': /* French */
#ifdef HAVECSE_FRENCH
			ctp = cse_french;
#endif
			break;

   		case 'X': /* KOI8 hack */
#ifdef HAVECSE_KOI8
			ctp = cse_koi8;
#endif			
			break;

		case 'Y': /* Italian */
#ifdef HAVECSE_ITALIAN
			ctp = cse_italian;
#endif
			break;

		case 'Z': /* Spanish */
#ifdef HAVECSE_SPANISH
			ctp = cse_spanish;
#endif
			break;

		case '0': /* special graphics */
#ifdef HAVECSE_SPECIAL
			ctp = cse_special;
#endif
			break;

		case '1': /* alternate ROM */
#ifdef HAVECSE_ALTERNATEROM1
			ctp = cse_alternaterom1;
#endif
			break;

		case '2': /* alt ROM, spec graphics */
#ifdef HAVECSE_ALTERNATEROM2
			ctp = cse_alternaterom2;
#endif
			break;

		case '3': /* HP Roman 8, upper 128 chars*/
#ifdef HAVECSE_ROMAN8
			ctp = cse_roman8;
#endif
			break;

		case '4': /* Dutch */
#ifdef HAVECSE_DUTCH
			ctp = cse_dutch;
#endif
			break;

		case '<': /* DEC Supplemental */
#ifdef HAVECSE_SUPPLEMENTAL
			ctp = cse_supplemental;
#endif
			break;

		case '=': /* Swiss */
#ifdef HAVECSE_SWISS
			ctp = cse_swiss;
#endif
			break;

		case '>': /* DEC Technical */
#ifdef HAVECSE_TECHNICAL
			ctp = cse_technical;
#endif
			break;

		default:
			break;
		}
	}
	else {
		switch (ch) {
		case 'A': /* British or ISO-Latin-1 */
			switch (svsp->state) {
			case STATE_BROPN: /* designate G0 */
			case STATE_BRCLO: /* designate G1 */
			case STATE_STAR:  /* designate G2 */
			case STATE_PLUS:  /* designate G3 */
#ifdef HAVECSD_BRITISH
				ctp = csd_british;
#endif
				break;

			case STATE_MINUS: /* designate G1 (96)*/
			case STATE_DOT:	  /* designate G2 (96)*/
			case STATE_SLASH: /* designate G3 (96)*/
#ifdef HAVECSD_ISOLATIN
				ctp = csd_isolatin;
#endif
				break;
			}
			break;

		case 'B': /* USASCII */
#ifdef HAVECSD_ASCII
			ctp = csd_ascii;
#endif
			break;

		case 'C': /* Finnish */
		case '5': /* Finnish */
#ifdef HAVECSD_FINNISH
			ctp = csd_finnish;
#endif
			break;

		case 'E': /* Norwegian/Danish */
		case '6': /* Norwegian/Danish */
#ifdef HAVECSD_NORWEGIANDANISH
			ctp = csd_norwegiandanish;
#endif
			break;

		case 'H': /* Swedish */
		case '7': /* Swedish */
#ifdef HAVECSD_SWEDISH
			ctp = csd_swedish;
#endif
			break;

		case 'K': /* German */
#ifdef HAVECSD_GERMAN
			ctp = csd_german;
#endif
			break;

		case 'Q': /* French Canadien */
#ifdef HAVECSD_FRENCHCANADA
			ctp = csd_frenchcanada;
#endif
			break;

		case 'R': /* French */
#ifdef HAVECSD_FRENCH
			ctp = csd_french;
#endif
			break;

   		case 'X': /* KOI8 hack */
#ifdef HAVECSD_KOI8
			ctp = csd_koi8;
#endif			
			break;

		case 'Y': /* Italian */
#ifdef HAVECSD_ITALIAN
			ctp = csd_italian;
#endif
			break;

		case 'Z': /* Spanish */
#ifdef HAVECSD_SPANISH
			ctp = csd_spanish;
#endif
			break;

		case '0': /* special graphics */
#ifdef HAVECSD_SPECIAL
			ctp = csd_special;
#endif
			break;

		case '1': /* alternate ROM */
#ifdef HAVECSD_ALTERNATEROM1
			ctp = csd_alternaterom1;
#endif
			break;

		case '2': /* alt ROM, spec graphics */
#ifdef HAVECSD_ALTERNATEROM2
			ctp = csd_alternaterom2;
#endif
			break;

		case '3': /* HP Roman 8, upper 128 chars*/
#ifdef HAVECSD_ROMAN8
			ctp = csd_roman8;
#endif
			break;

		case '4': /* Dutch */
#ifdef HAVECSD_DUTCH
			ctp = csd_dutch;
#endif
			break;

		case '<': /* DEC Supplemental */
#ifdef HAVECSD_SUPPLEMENTAL
			ctp = csd_supplemental;
#endif
			break;

		case '=': /* Swiss */
#ifdef HAVECSD_SWISS
			ctp = csd_swiss;
#endif
			break;

		case '>': /* DEC Technical */
#ifdef HAVECSD_TECHNICAL
			ctp = csd_technical;
#endif
			break;

		default:
			break;
		}
	}
	swcsp(svsp, ctp);
}

/*---------------------------------------------------------------------------*
 *	device attributes
 *---------------------------------------------------------------------------*/
void
vt_da(struct video_state *svsp)
{
	static u_char *response = (u_char *)DA_VT220;

	svsp->report_chars = response;
	svsp->report_count = 18;
	respond(svsp);
}

/*---------------------------------------------------------------------------*
 *	screen alignment display
 *---------------------------------------------------------------------------*/
void
vt_aln(struct video_state *svsp)
{
	register int i;

	svsp->cur_offset = 0;
	svsp->col = 0;

	for (i = 0; i < (svsp->screen_rows*svsp->maxcol); i++) {
		*(svsp->Crtat + svsp->cur_offset) = user_attr | 'E';
		vt_selattr(svsp);
		svsp->cur_offset++;
		svsp->col++;
	}

	svsp->cur_offset = 0;	/* reset everything ! */
	svsp->col = 0;
	svsp->row = 0;
}

/*---------------------------------------------------------------------------*
 *	request terminal parameters
 *---------------------------------------------------------------------------*/
void
vt_reqtparm(struct video_state *svsp)
{
	static u_char *answr = (u_char *)"\033[3;1;1;120;120;1;0x";

	svsp->report_chars = answr;
	svsp->report_count = 20;
	respond(svsp);
}

/*---------------------------------------------------------------------------*
 *	invoke selftest
 *---------------------------------------------------------------------------*/
void
vt_tst(struct video_state *svsp)
{
	clear_dld(svsp);
}

/*---------------------------------------------------------------------------*
 *	device status reports
 *---------------------------------------------------------------------------*/
void
vt_dsr(struct video_state *svsp)
{
	static u_char *answr = (u_char *)"\033[0n";
	static u_char *panswr = (u_char *)"\033[?13n"; /* Printer Unattached */
	static u_char *udkanswr = (u_char *)"\033[?21n"; /* UDK Locked */
	static u_char *langanswr = (u_char *)"\033[?27;1n"; /* North American*/
	static u_char buffer[16];
	int i = 0;

	switch (svsp->parms[0]) {
	case 5:		/* return status */
		svsp->report_chars = answr;
		svsp->report_count = 4;
		respond(svsp);
		break;

	case 6:		/* return cursor position */
		buffer[i++] = 0x1b;
		buffer[i++] = '[';
		if ((svsp->row+1) > 10)
			buffer[i++] = ((svsp->row+1) / 10) + '0';
		buffer[i++] = ((svsp->row+1) % 10) + '0';
		buffer[i++] = ';';
		if ((svsp->col+1) > 10)
			buffer[i++] = ((svsp->col+1) / 10) + '0';
		buffer[i++] = ((svsp->col+1) % 10) + '0';
		buffer[i++] = 'R';
		buffer[i++] = '\0';

		svsp->report_chars = buffer;
		svsp->report_count = i;
		respond(svsp);
		break;

	case 15:	/* return printer status */
		svsp->report_chars = panswr;
		svsp->report_count = 6;
		respond(svsp);
		break;

	case 25:	/* return udk status */
		svsp->report_chars = udkanswr;
		svsp->report_count = 6;
		respond(svsp);
		break;

	case 26:	/* return language status */
		svsp->report_chars = langanswr;
		svsp->report_count = 8;
		respond(svsp);
		break;

	default:	/* nothing else valid */
		break;
	}
}

/*---------------------------------------------------------------------------*
 *	IL - insert line
 *---------------------------------------------------------------------------*/
void
vt_il(struct video_state *svsp)
{
	register int p = svsp->parms[0];

	if ((svsp->row >= svsp->scrr_beg) && (svsp->row <= svsp->scrr_end)) {
		if (p <= 0)
			p = 1;
		else if (p > svsp->scrr_end - svsp->row)
			p = svsp->scrr_end - svsp->row;

		svsp->cur_offset -= svsp->col;
		svsp->col = 0;
		if (svsp->row == svsp->scrr_beg)
			roll_down(svsp, p);
		else {
			bcopy(svsp->Crtat + svsp->cur_offset,
			    svsp->Crtat + svsp->cur_offset + (p * svsp->maxcol),
			    svsp->maxcol * (svsp->scrr_end-svsp->row + 1 - p) *
			    CHR);

			fillw(user_attr | ' ',
			    (caddr_t)(svsp->Crtat + svsp->cur_offset),
			    p * svsp->maxcol);
		}
	}
}

/*---------------------------------------------------------------------------*
 *	ICH - insert character
 *---------------------------------------------------------------------------*/
void
vt_ic(struct video_state *svsp)
{
	register int p = svsp->parms[0];

	if (p <= 0)
		p = 1;
	else if (p > svsp->maxcol-svsp->col)
		p = svsp->maxcol-svsp->col;

	while (p--) {
		bcopy((svsp->Crtat + svsp->cur_offset),
		    (svsp->Crtat + svsp->cur_offset) + 1,
		    (((svsp->maxcol)-1)-svsp->col) * CHR);

		*(svsp->Crtat + svsp->cur_offset) = user_attr | ' ';
		vt_selattr(svsp);
	}
}

/*---------------------------------------------------------------------------*
 *	DL - delete line
 *---------------------------------------------------------------------------*/
void
vt_dl(struct video_state *svsp)
{
	register int p = svsp->parms[0];

	if ((svsp->row >= svsp->scrr_beg) && (svsp->row <= svsp->scrr_end)) {
		if (p <= 0)
			p = 1;
		else if (p > svsp->scrr_end - svsp->row)
			p = svsp->scrr_end - svsp->row;

		svsp->cur_offset -= svsp->col;
		svsp->col = 0;

		if (svsp->row == svsp->scrr_beg)
			roll_up(svsp, p);
		else {
			bcopy(svsp->Crtat + svsp->cur_offset + (p *
			    svsp->maxcol), svsp->Crtat + svsp->cur_offset,
			    svsp->maxcol * (svsp->scrr_end-svsp->row + 1 - p) *
			    CHR);

			fillw(user_attr | ' ',
			    (caddr_t)(svsp->Crtat + ((svsp->scrr_end-p+1) *
			    svsp->maxcol)), p * svsp->maxcol);
		}
	}
}

/*---------------------------------------------------------------------------*
 *	DCH - delete character
 *---------------------------------------------------------------------------*/
void
vt_dch(struct video_state *svsp)
{
	register int p = svsp->parms[0];

	if (p <= 0)
		p = 1;
	else if (p > svsp->maxcol-svsp->col)
		p = svsp->maxcol-svsp->col;

	while (p--) {
		bcopy((svsp->Crtat + svsp->cur_offset) + 1,
		    (svsp->Crtat + svsp->cur_offset),
		    (((svsp->maxcol) - 1) - svsp->col) * CHR);

		*((svsp->Crtat + svsp->cur_offset) +
		    ((svsp->maxcol) - 1) - svsp->col) = user_attr | ' ';
	}
}

/*---------------------------------------------------------------------------*
 *	scroll up
 *---------------------------------------------------------------------------*/
void
vt_su(struct video_state *svsp)
{
	register int p = svsp->parms[0];

	if (p <= 0)
		p = 1;
	else if (p > svsp->screen_rows - 1)
		p = svsp->screen_rows - 1;

	roll_up(svsp, p);
}

/*---------------------------------------------------------------------------*
 *	scroll down
 *---------------------------------------------------------------------------*/
void
vt_sd(struct video_state *svsp)
{
	register int p = svsp->parms[0];

	if (p <= 0)
		p = 1;
	else if (p > svsp->screen_rows-1)
		p = svsp->screen_rows-1;

	roll_down(svsp, p);
}

/*---------------------------------------------------------------------------*
 *	ECH - erase character
 *---------------------------------------------------------------------------*/
void
vt_ech(struct video_state *svsp)
{
	register int p = svsp->parms[0];

	if (p <= 0)
		p = 1;
	else if (p > svsp->maxcol-svsp->col)
		p = svsp->maxcol - svsp->col;

	fillw(user_attr | ' ', (caddr_t)(svsp->Crtat + svsp->cur_offset), p);
}

/*---------------------------------------------------------------------------*
 *	media copy	(NO PRINTER AVAILABLE IN KERNEL ...)
 *---------------------------------------------------------------------------*/
void
vt_mc(struct video_state *svsp)
{
}

/*---------------------------------------------------------------------------*
 *	Device Control String State Machine Entry for:
 *
 *	DECUDK - user-defined keys	and
 *	DECDLD - downloadable charset
 *
 *---------------------------------------------------------------------------*/
void
vt_dcsentry(U_char ch, struct video_state *svsp)
{
	switch (svsp->dcs_state) {
	case DCS_INIT:
		switch (ch) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':	/* parameters */
			svsp->parms[svsp->parmi] *= 10;
			svsp->parms[svsp->parmi] += (ch -'0');
			break;

		case ';':	/* next parameter */
			svsp->parmi = (svsp->parmi + 1 < MAXPARMS) ?
			    svsp->parmi + 1 : svsp->parmi;
			break;

		case '|':	/* DECUDK */
			svsp->transparent = 1;
			init_udk(svsp);
			svsp->dcs_state = DCS_AND_UDK;
			break;

		case '{':	/* DECDLD */
			svsp->transparent = 1;
			init_dld(svsp);
			svsp->dcs_state = DCS_DLD_DSCS;
			break;

		default:	 /* failsafe */
			svsp->transparent = 0;
			svsp->state = STATE_INIT;
			svsp->dcs_state = DCS_INIT;
			break;
		}
		break;

	case DCS_AND_UDK:	 /* DCS ... | */
		switch (ch) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':	/* fkey number */
			svsp->udk_fnckey *= 10;
			svsp->udk_fnckey += (ch -'0');
			break;

		case '/':	/* Key */
			svsp->dcs_state = DCS_UDK_DEF;
			break;

		case 0x1b:	 /* ESC */
			svsp->dcs_state = DCS_UDK_ESC;
			break;

		default:
			svsp->transparent = 0;
			svsp->state = STATE_INIT;
			svsp->dcs_state = DCS_INIT;
			break;
		}
		break;

	case DCS_UDK_DEF:	 /* DCS ... | fnckey / */
		switch (ch) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			if (svsp->udk_deflow) {	/* low nibble */
				svsp->udk_def[svsp->udk_defi] |= (ch - '0');
				svsp->udk_deflow = 0;
				svsp->udk_defi = (svsp->udk_defi + 1 >=
				    MAXUDKDEF) ? svsp->udk_defi :
				    svsp->udk_defi + 1;
			}
			else {			/* high nibble */
				svsp->udk_def[svsp->udk_defi] =
				    ((ch - '0') << 4);
				svsp->udk_deflow = 1;
			}
			break;

		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
			if (svsp->udk_deflow) { 	/* low nibble */
				svsp->udk_def[svsp->udk_defi] |=
				    (ch - 'a' + 10);
				svsp->udk_deflow = 0;
				svsp->udk_defi = (svsp->udk_defi + 1 >=
				    MAXUDKDEF) ? svsp->udk_defi :
				    svsp->udk_defi + 1;
			}
			else {			/* high nibble */
				svsp->udk_def[svsp->udk_defi] =
				    ((ch - 'a' + 10) << 4);
				svsp->udk_deflow = 1;
			}
			break;

		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
			if (svsp->udk_deflow) { 	/* low nibble */
				svsp->udk_def[svsp->udk_defi] |=
				    (ch - 'A' + 10);
				svsp->udk_deflow = 0;
				svsp->udk_defi = (svsp->udk_defi+1 >=
				    MAXUDKDEF) ? svsp->udk_defi :
				    svsp->udk_defi + 1;
			}
			else {			/* high nibble */
				svsp->udk_def[svsp->udk_defi] =
				    ((ch - 'A' + 10) << 4);
				svsp->udk_deflow = 1;
			}
			break;

		case ';':	/* next function key */
			vt_udk(svsp);
			svsp->dcs_state = DCS_AND_UDK;
			break;

		case 0x1b:	 /* ESC */
			svsp->dcs_state = DCS_UDK_ESC;
			break;

		default:
			svsp->transparent = 0;
			svsp->state = STATE_INIT;
			svsp->dcs_state = DCS_INIT;
			break;
		}
		break;

	case DCS_UDK_ESC:	 /* DCS ... | fkey/def ... ESC */
		switch (ch) {
		case '\\':	/* ST */
			vt_udk(svsp);
			svsp->transparent = 0;
			svsp->state = STATE_INIT;
			svsp->dcs_state = DCS_INIT;
			break;

		default:
			svsp->transparent = 0;
			svsp->state = STATE_INIT;
			svsp->dcs_state = DCS_INIT;
			break;
		}
		break;


	case DCS_DLD_DSCS:	 /* got DCS ... { */
		if (ch >= ' ' && ch <= '/') {	/* intermediates ... */
			svsp->dld_dscs[svsp->dld_dscsi] = ch;
			svsp->dld_id[svsp->dld_dscsi] = ch;
			if (svsp->dld_dscsi >= DSCS_LENGTH) {
				svsp->transparent = 0;
				svsp->state = STATE_INIT;
				svsp->dcs_state = DCS_INIT;
				svsp->dld_id[0] = '\0';
			}
			else
				svsp->dld_dscsi++;
		}
		else if (ch >= '0' && ch <= '~') {	/* final .... */
			svsp->dld_dscs[svsp->dld_dscsi] = ch;
			svsp->dld_id[svsp->dld_dscsi++] = ch;
			svsp->dld_id[svsp->dld_dscsi] = '\0';
			svsp->dcs_state = DCS_DLD_DEF;
		}
		else {
			svsp->transparent = 0;
			svsp->state = STATE_INIT;
			svsp->dcs_state = DCS_INIT;
			svsp->dld_id[0] = '\0';
		}
		break;

	case DCS_DLD_DEF:	 /* DCS ... { dscs */
		switch (ch) {
		case 0x1b:	 /* ESC */
			svsp->dcs_state = DCS_DLD_ESC;
			break;

		case '/':	 /* sixel upper / lower divider */
			svsp->dld_sixel_lower = 1;
			break;

		case ';':	 /* character divider */
			vt_dld(svsp);
			svsp->parms[1]++;	/* next char */
			break;

 		default:
			if (svsp->dld_sixel_lower) {
				if (ch >= '?' && ch <= '~') {
					svsp->sixel.lower[svsp->dld_sixelli] =
					    ch - '?';
				}
				svsp->dld_sixelli =
				    (svsp->dld_sixelli + 1 < MAXSIXEL) ?
				    svsp->dld_sixelli + 1 : svsp->dld_sixelli;
			}
			else {
				if (ch >= '?' && ch <= '~') {
					svsp->sixel.upper[svsp->dld_sixelui] =
					    ch - '?';
				}
				svsp->dld_sixelui =
				    (svsp->dld_sixelui + 1 < MAXSIXEL) ?
				    svsp->dld_sixelui+1 : svsp->dld_sixelui;
			}
					break;
		}
		break;

	case DCS_DLD_ESC:	 /* DCS ... { dscs ... / ... ESC */
		switch (ch) {
		case '\\':	/* String Terminator ST */
			vt_dld(svsp);
			svsp->transparent = 0;
			svsp->state = STATE_INIT;
			svsp->dcs_state = DCS_INIT;
			break;

		default:
			svsp->transparent = 0;
			svsp->state = STATE_INIT;
			svsp->dcs_state = DCS_INIT;
			svsp->dld_id[0] = '\0';
			break;
		}
			break;

	default:
		svsp->transparent = 0;
		svsp->state = STATE_INIT;
		svsp->dcs_state = DCS_INIT;
		break;
	}
}

/*---------------------------------------------------------------------------*
 *	User Defineable Keys
 *---------------------------------------------------------------------------*/
void
vt_udk(struct video_state *svsp)
{
	int key, start, max, i;
	int usedff = 0;

	if (svsp->parms[0] != 1) {	/* clear all ? */
		vt_clearudk(svsp);
		svsp->parms[0] = 1;
	}

	if (svsp->udk_fnckey < 17 || svsp->udk_fnckey > 34) {
		init_udk(svsp);
		return;
	}

	key = svsp->udk_fnckey - 17;	/* index into table */

	if (svsp->ukt.length[key] == 0) {		/* never used ? */
		if (svsp->udkff < MAXUDKDEF - 2) {	/* space available ? */
			start = svsp->udkff;		/* next sequential */
			max = MAXUDKDEF - svsp->udkff;	/* space available */
			svsp->ukt.first[key] = start;	/* start entry */
			usedff = 1;			/* flag to update later */
		}
		else {		 			/* no space */
			init_udk(svsp);
			return;
		}
	}
	else {						/* in use, redefine */
		start = svsp->ukt.first[key];		/* start entry */
		max = svsp->ukt.length[key];		/* space available */
	}

	if (max < 2) {				/* hmmm .. */
		init_udk(svsp);
		return;
	}

	max--;		/* adjust for tailing '\0' */

	for (i = 0; i < max && i < svsp->udk_defi; i++)
		svsp->udkbuf[start++] = svsp->udk_def[i];

	svsp->udkbuf[start] = '\0';	/* make it a string, see pcvt_kbd.c */
	svsp->ukt.length[key] = i + 1;	/* count for tailing '\0' */
	if (usedff)
		svsp->udkff += (i + 2);	/* new start location */

	init_udk(svsp);
}

/*---------------------------------------------------------------------------*
 *	clear all User Defineable Keys
 *---------------------------------------------------------------------------*/
void
vt_clearudk(struct video_state *svsp)
{
	register int i;

	for (i = 0; i < MAXUDKEYS; i++) {
		svsp->ukt.first[i] = 0;
		svsp->ukt.length[i] = 0;
	}
	svsp->udkff = 0;
}

/*---------------------------------------------------------------------------*
 *	Down line LoaDable Fonts
 *---------------------------------------------------------------------------*/
void
vt_dld(struct video_state *svsp)
{
	unsigned char vgacharset;
	unsigned char vgachar[16];
	unsigned char vgacharb[16];

	if (vgacs[svsp->vga_charset].secondloaded)
		vgacharset = vgacs[svsp->vga_charset].secondloaded;
	else
		return;

	svsp->parms[1] = (svsp->parms[1] < 1) ? 1 :
	    ((svsp->parms[1] > 0x7E) ? 0x7E : svsp->parms[1]);

	if (svsp->parms[2] != 1) {	/* Erase all characters ? */
		clear_dld(svsp);
		svsp->parms[2] = 1;	/* Only erase all characters once per sequence */
	}

	sixel_vga(&(svsp->sixel), vgachar);

	switch (vgacs[vgacharset].char_scanlines & 0x1F) {
	case 7:
		vga10_vga8(vgachar, vgacharb);
		break;

	case 13:
		vga10_vga14(vgachar, vgacharb);
		break;

	case 15:
		vga10_vga16(vgachar, vgacharb);
		break;

	case 9:
	default:
		vga10_vga10(vgachar, vgacharb);
		break;
	}

	loadchar(vgacharset, svsp->parms[1] + 0xA0, 16, vgacharb);

	init_dld(svsp);
}

/*---------------------------------------------------------------------------*
 *	select compatibility level
 *---------------------------------------------------------------------------*/
void
vt_scl(struct video_state *svsp)
{
	/* poor man's scl. normally this also enables/disables the editing
	 * keypad and the available character sets. we only enable/disable
	 * support for C1 control codes.
	 */

	register int p0, p1;

	p0 = svsp->parms[0];
	p1 = svsp->parms[1];

	vt_str(svsp);

	switch (p0) {
	case 61:
		svsp->sevenbit = 1;
		break;
	case 62:
	/* case 63: vt320 */
	default:
		if (p1 != 1)
			svsp->C1_ctls = 1;
		break;
	}
}

/*---------------------------------------------------------------------------*
 *	select character attributes
 *---------------------------------------------------------------------------*/
void
vt_sca(struct video_state *svsp)
{
	switch (svsp->parms[0]) {
	case 1:
		svsp->selchar = 1;
		break;
	case 0:
	case 2:
	default:
		svsp->selchar = 0;
		break;
	}
}

/*---------------------------------------------------------------------------*
 *	initialize selective attribute bit array
 *---------------------------------------------------------------------------*/
void
vt_initsel(struct video_state *svsp)
{
	register int i;

	for (i = 0; i < MAXDECSCA; i++)
		svsp->decsca[i] = 0;
}

/*---------------------------------------------------------------------------*
 *	DECSEL - selective erase in line
 *---------------------------------------------------------------------------*/
void
vt_sel(struct video_state *svsp)
{
	switch (svsp->parms[0]) {
	case 0:
		selective_erase(svsp, (svsp->Crtat + svsp->cur_offset),
		    svsp->maxcol-svsp->col);
		break;

	case 1:
		selective_erase(svsp, (svsp->Crtat + svsp->cur_offset)-
		    svsp->col, svsp->col + 1);
		break;

	case 2:
		selective_erase(svsp, (svsp->Crtat + svsp->cur_offset)-
		    svsp->col, svsp->maxcol);
		break;
	}
}

/*---------------------------------------------------------------------------*
 *	DECSED - selective erase in display
 *---------------------------------------------------------------------------*/
void
vt_sed(struct video_state *svsp)
{
	switch (svsp->parms[0]) {
	case 0:
		selective_erase(svsp, (svsp->Crtat + svsp->cur_offset),
		    svsp->Crtat + (svsp->maxcol * svsp->screen_rows) -
		    (svsp->Crtat + svsp->cur_offset));
		break;

	case 1:
		selective_erase(svsp, svsp->Crtat,
		    (svsp->Crtat + svsp->cur_offset) - svsp->Crtat + 1);
		break;

	case 2:
		selective_erase(svsp, svsp->Crtat,
		    svsp->maxcol * svsp->screen_rows);
		break;
	}
}

/*---------------------------------------------------------------------------*
 *	scroll screen n lines up
 *---------------------------------------------------------------------------*/
void
roll_up(struct video_state *svsp, int n)
{

#if (PCVT_NOFASTSCROLL==0)

	if (svsp->scrr_beg == 0 &&       /* if scroll region is whole screen */
	   svsp->scrr_len == svsp->screen_rows &&
	   (svsp != vsp ||		  /* and either running in memory */
	    (svsp->screen_rows == svsp->screen_rowsize       /* or no fkeys */

#if (PCVT_MDAFASTSCROLL==0)
		&& adaptor_type != MDA_ADAPTOR   /* and not on MDA/Hercules */
#endif

	  )))

	{
		u_short *Memory =
		    (vsp != svsp || (vsp->vt_status & VT_GRAFX)) ?
				svsp->Memory : Crtat;

		if (svsp->Crtat > (Memory + (svsp->screen_rows - n) *
					svsp->maxcol)) {
			bcopy(svsp->Crtat + svsp->maxcol * n, Memory,
		       	      svsp->maxcol * (svsp->screen_rows - n) * CHR);

			svsp->Crtat = Memory;
		}
		else
			svsp->Crtat += n * svsp->maxcol;
	}
	else
#endif
	{
		bcopy(svsp->Crtat + ((svsp->scrr_beg + n) * svsp->maxcol),
		    svsp->Crtat + (svsp->scrr_beg * svsp->maxcol),
		    svsp->maxcol * (svsp->scrr_len - n) * CHR );
	}

	fillw(user_attr | ' ',
	    (caddr_t)(svsp->Crtat + ((svsp->scrr_end - n + 1) * svsp->maxcol)),
	    n * svsp->maxcol);
}

/*---------------------------------------------------------------------------*
 *	scroll screen n lines down
 *---------------------------------------------------------------------------*/
static void
roll_down(struct video_state *svsp, int n)
{

#if (PCVT_NOFASTSCROLL==0)

	if (svsp->scrr_beg == 0 &&	/* if scroll region is whole screen */
	   svsp->scrr_len == svsp->screen_rows &&
	   (svsp != vsp ||		    /* and either running in memory */
	    (svsp->screen_rows == svsp->screen_rowsize       /* or no fkeys */

#if (PCVT_MDAFASTSCROLL==0)
		&& adaptor_type != MDA_ADAPTOR   /* and not on MDA/Hercules */
#endif

	  )))

	{
		u_short *Memory =
		    (vsp != svsp || (vsp->vt_status & VT_GRAFX)) ?
				svsp->Memory : Crtat;

		if (svsp->Crtat < (Memory + n * svsp->maxcol)) {
			bcopy(svsp->Crtat,
			    Memory + svsp->maxcol * (svsp->screen_rows + n),
			    svsp->maxcol * (svsp->screen_rows - n) * CHR);

			svsp->Crtat = Memory + svsp->maxcol * svsp->screen_rows;
		}
		else
			svsp->Crtat -= n * svsp->maxcol;
	}
	else
#endif
	{
		bcopy(svsp->Crtat + (svsp->scrr_beg * svsp->maxcol),
		    svsp->Crtat + ((svsp->scrr_beg + n) * svsp->maxcol),
		    svsp->maxcol * (svsp->scrr_len - n) * CHR);
	}

	fillw(user_attr | ' ',
	    (caddr_t)(svsp->Crtat + (svsp->scrr_beg * svsp->maxcol)),
	    n * svsp->maxcol);
}

/*---------------------------------------------------------------------------*
 *	switch charset pointers
 *---------------------------------------------------------------------------*/
static void
swcsp(struct video_state *svsp, u_short *ctp)
{
	if (ctp == NULL)
		return;

        /* update GL or GR if the designated charset is currently displayed */
        
	switch (svsp->state) {
	case STATE_BROPN:	/* designate G0 */
		if (svsp->GL == svsp->G0)
			svsp->GL = ctp;
		if (svsp->GR == svsp->G0)
			svsp->GR = ctp;
		svsp->G0 = ctp;
		break;

	case STATE_BRCLO:	/* designate G1 */
	case STATE_MINUS:	/* designate G1 (96) */
		if (svsp->GL == svsp->G1)
			svsp->GL = ctp;
		if (svsp->GR == svsp->G1)
			svsp->GR = ctp;
		svsp->G1 = ctp;
		break;

	case STATE_STAR:	/* designate G2 */
	case STATE_DOT:		/* designate G2 (96) */
		if (svsp->GL == svsp->G2)
			svsp->GL = ctp;
		if (svsp->GR == svsp->G2)
			svsp->GR = ctp;
		svsp->G2 = ctp;
		break;

	case STATE_PLUS:	/* designate G3 */
	case STATE_SLASH:	/* designate G3 (96) */
		if (svsp->GL == svsp->G3)
			svsp->GL = ctp;
		if (svsp->GR == svsp->G3)
			svsp->GR = ctp;
		svsp->G3 = ctp;
		break;
	}
}

/*---------------------------------------------------------------------------*
 *	process terminal responses
 *---------------------------------------------------------------------------*/
static void
respond(struct video_state *svsp)
{
	if (!(svsp->openf))	      /* are we opened ? */
		return;

	while (*svsp->report_chars && svsp->report_count > 0) {
		(*linesw[svsp->vs_tty->t_line].l_rint)
		    (*svsp->report_chars++ & 0xff, svsp->vs_tty);
		svsp->report_count--;
	}
}

/*---------------------------------------------------------------------------*
 *	Initialization for User Defineable Keys
 *---------------------------------------------------------------------------*/
static void
init_udk(struct video_state *svsp)
{
	svsp->udk_defi = 0;
	svsp->udk_deflow = 0;
	svsp->udk_fnckey = 0;
}

/*---------------------------------------------------------------------------*
 *	Clear loaded downloadable (DLD) character set
 *---------------------------------------------------------------------------*/
static void
clear_dld(struct video_state *svsp)
{
	register int i;
	unsigned char vgacharset;
	unsigned char vgachar[16];

	if (vgacs[svsp->vga_charset].secondloaded)
		vgacharset = vgacs[svsp->vga_charset].secondloaded;
	else
		return;

	for (i = 0; i < 16; i++)  /* zeroed character, vt220 has inverted '?' */
		vgachar[i] = 0x00;

	for (i = 1; i <= 94; i++) /* Load (erase) all characters */
		loadchar(vgacharset, i + 0xA0, 16, vgachar);
}

/*---------------------------------------------------------------------------*
 *	Initialization for Down line LoaDable Fonts
 *---------------------------------------------------------------------------*/
static void
init_dld(struct video_state *svsp)
{
	register int i;

	svsp->dld_dscsi = 0;
	svsp->dld_sixel_lower = 0;
	svsp->dld_sixelli = 0;
	svsp->dld_sixelui = 0;

	for (i = 0; i < MAXSIXEL; i++)
		svsp->sixel.lower[i] = svsp->sixel.upper[i] = 0;
}

/*---------------------------------------------------------------------------*
 *	selective erase a region
 *---------------------------------------------------------------------------*/
static void
selective_erase(struct video_state *svsp, u_short *pcrtat, int length)
{
	register int i, j;

	for (j = pcrtat - svsp->Crtat, i = 0; i < length; i++, pcrtat++) {
		if (!(svsp->decsca[INT_INDEX(j+i)] & (1 << BIT_INDEX(j+i)))) {
			*pcrtat &= 0xFF00; /* Keep video character attributes */
			*pcrtat += ' ';	   /* Erase the character */
		}
	}
}

#endif	/* NVT > 0 */

/* ------------------------- E O F ------------------------------------------*/

@


1.18
log
@keyboard led update lockup patch; pr 1432, smat@@acm.org
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_vtf.c,v 1.17 2000/12/21 16:54:54 aaron Exp $	*/
@


1.17
log
@People have difficulty spelling 'initial' and derivatives thereof (too many
"i's" I guess).
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_vtf.c,v 1.16 2000/05/31 23:31:42 aaron Exp $	*/
d560 1
a560 1
	update_led();				/* update keyboard LED's */
a2014 3

/*XXX*/	if (svsp->scroll_lock && svsp->openf && curproc)
		tsleep((caddr_t)&(svsp->scroll_lock), PUSER, "scrlck", 0);
a2062 3

/*XXX*/	if (svsp->scroll_lock && svsp->openf && curproc)
		tsleep((caddr_t)&(svsp->scroll_lock), PUSER, "scrlck", 0);
@


1.16
log
@Sigh... Fix a stupid bug wrt reverse video attributes (when using the newer
"PC Display" functionality -- the default now). Previously the code did
not check the current status of the VT_INVERSE bit when processing a
reverse "off" or "on" request. As a result, two of either operations in a
row would flip the bits, then flip them back again. Thanks to millert@@ who
found the problem when playing with the trn news software.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_vtf.c,v 1.15 2000/04/12 13:20:41 aaron Exp $	*/
d1909 1
a1909 1
 *	initalize selective attribute bit array
@


1.15
log
@When resetting attributes (VT_NORMAL), do a proper color set.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_vtf.c,v 1.14 2000/03/30 21:02:11 aaron Exp $	*/
d185 1
a185 2
			svsp->vtsgr |= VT_INVERSE;
			if (pcdisp) {
d193 1
d221 1
a221 2
			svsp->vtsgr &= ~VT_INVERSE;
			if (pcdisp) {
d227 1
@


1.15.2.1
log
@Pull in patches from current:
Errata:
The PC console driver (PCVT) has two bugs. Display problems can result if
reverse video mode is turned on or off twice in a row. This patch also
fixes a problem with scrolling region handling that has been seen by many
users trying to use the BitchX irc client with the screen program.
Fixes (aaron):
My previous two attempts at fixing the "scrolling region" problem were wrong.
Instead of using cur_offset to determine if we should scroll, calculate based
on the current row. This is how Linux does it, and it seems to work.

Better fix for the scrolling region problem. Fixes PR/1271.

Only scroll up if we've hit the bottom of the scrolling region, not if we're
beyond it. Fixes display problems when using the BitchX irc client under
screen (/usr/ports/misc/screen) sessions.

Sigh... Fix a stupid bug wrt reverse video attributes (when using the newer
"PC Display" functionality -- the default now). Previously the code did
not check the current status of the VT_INVERSE bit when processing a
reverse "off" or "on" request. As a result, two of either operations in a
row would flip the bits, then flip them back again. Thanks to millert@@ who
found the problem when playing with the trn news software.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_vtf.c,v 1.16 2000/05/31 23:31:42 aaron Exp $	*/
d185 2
a186 1
			if (pcdisp && !(svsp->vtsgr & VT_INVERSE)) {
a193 1
			svsp->vtsgr |= VT_INVERSE;
d221 2
a222 1
			if (pcdisp && (svsp->vtsgr & VT_INVERSE)) {
a227 1
			svsp->vtsgr &= ~VT_INVERSE;
@


1.14
log
@- Remove some unused code.
- Much needed indent cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_vtf.c,v 1.13 2000/03/14 16:26:23 aaron Exp $	*/
d149 4
a152 2
			if (pcdisp)
				setcolor = 0;
@


1.13
log
@Fix `blink' and `underline' attribute handling for new PC display mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_vtf.c,v 1.12 2000/01/17 02:46:23 aaron Exp $	*/
a505 1
	svsp->dis_fnc = 0;			/* display functions reset */
a541 2
		svsp->GL = svsp->G0;		/* GL = G0 */
		svsp->GR = svsp->G2;		/* GR = G2 */
a547 2
		svsp->GL = svsp->G0;		/* GL = G0 */
		svsp->GR = svsp->G2;		/* GR = G2 */
d549 2
@


1.12
log
@Remove `pcdisp_special', which was actually a gross hack. Instead, move the
`pcdisp' check in write_char() beyond the 0x20-0x7f character value scope.
This change should fix most problems when intermixing DEC character- and
IBMPC character-based apps in the PCVT console.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_vtf.c,v 1.11 1999/11/27 21:39:29 aaron Exp $	*/
d165 5
d175 2
d204 4
@


1.12.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a164 5
			if (pcdisp) {
				setcolor &= ~(0x07 << 8);
				setcolor |= (FG_CYAN << 8);
				colortouched = 1;
			}
a169 2
				if ((setcolor >> 8) == 0)
					setcolor = (FG_LIGHTGREY << 8);
a196 4
			if (pcdisp) {
				setcolor &= ~(0x07 << 8);
				setcolor |= (FG_LIGHTGREY << 8);
			}
@


1.12.2.2
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_vtf.c,v 1.18 2001/01/22 18:48:44 deraadt Exp $	*/
d149 2
a150 4
			if (pcdisp) {
				setcolor = (FG_LIGHTGREY << 8);
				colortouched = 1;
			}
d183 2
a184 1
			if (pcdisp && !(svsp->vtsgr & VT_INVERSE)) {
a191 1
			svsp->vtsgr |= VT_INVERSE;
d219 2
a220 1
			if (pcdisp && (svsp->vtsgr & VT_INVERSE)) {
a225 1
			svsp->vtsgr &= ~VT_INVERSE;
d506 1
d543 2
d551 2
a553 2
	svsp->GL = svsp->G0;			/* GL = G0 */
	svsp->GR = svsp->G2;			/* GR = G2 */
d561 1
a561 1
	update_led(2);				/* update keyboard LED's */
d1910 1
a1910 1
 *	initialize selective attribute bit array
d2016 3
d2067 3
@


1.12.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_vtf.c,v 1.12.2.2 2001/04/18 16:08:03 niklas Exp $	*/
@


1.11
log
@Shorten printf() strings, KNF, and fix a braino in a switch() statement.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_vtf.c,v 1.10 1999/11/25 20:24:22 aaron Exp $	*/
a1051 1
			pcdisp_special = 0;
a1114 1
			pcdisp_special = 1;
a1144 1
			pcdisp_special = 1;
a1156 1
			pcdisp_special = 1;
@


1.10
log
@Remove the keyboard mouse emulator, HP emulation mode, and PCVT_SHOWKEYS
debugging cruft. Also fix a bug where you were not able to hold down the
scrollback hotkeys.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_vtf.c,v 1.9 1999/11/16 21:57:49 aaron Exp $	*/
d93 1
a93 2
	if((svsp->parms[0] == 0) && (svsp->parms[1] == 0))
	{
d102 1
a102 1
	if(svsp->parms[1] <= svsp->parms[0])
d107 1
a107 1
	if(svsp->parms[0] < 1)
d109 2
a110 2
	else if(svsp->parms[0] > svsp->screen_rows-1)
		svsp->parms[0] = svsp->screen_rows-1;
d114 1
a114 1
	if(svsp->parms[1] < 2)
d116 1
a116 1
	else if(svsp->parms[1] > svsp->screen_rows)
d119 1
a119 1
	svsp->scrr_beg = svsp->parms[0]-1;	/* begin of scrolling region */
d121 1
a121 1
	svsp->scrr_end = svsp->parms[1]-1;
d124 1
a124 1
	if(svsp->m_om)
d145 7
a151 9
	do
	{
		switch(svsp->parms[i++])
		{
			case 0:		/* reset to normal attributes */
				svsp->vtsgr = VT_NORMAL;
				if (pcdisp)
					setcolor = 0;
				break;
d153 9
a161 9
			case 1:		/* bold */
				svsp->vtsgr |= VT_BOLD;
				if (pcdisp) {
					if ((setcolor >> 8) == 0)
						setcolor = (FG_LIGHTGREY << 8);
					setcolor |= (FG_INTENSE << 8);
					colortouched = 1;
				}
				break;
d163 3
a165 3
			case 4:		/* underline */
				svsp->vtsgr |= VT_UNDER;
				break;
d167 7
a173 7
			case 5:		/* blinking */
				svsp->vtsgr |= VT_BLINK;
				if (pcdisp) {
					setcolor |= (FG_BLINK << 8);
					colortouched = 1;
				}
				break;
d175 11
a185 11
			case 7:		/* reverse */
				svsp->vtsgr |= VT_INVERSE;
				if (pcdisp) {
					if ((setcolor >> 8) == 0)
						setcolor = (FG_LIGHTGREY << 8);
					setcolor = (((setcolor>>8) & 0x88) |
					    ((((setcolor>>8) >> 4) |
					    ((setcolor>>8) << 4)) & 0x77)) << 8;
					colortouched = 1;
				}
				break;
d187 7
a193 7
			case 22:	/* not bold */
				svsp->vtsgr &= ~VT_BOLD;
				if (pcdisp) {
					setcolor &= ~(FG_INTENSE << 8);
					colortouched = 1;
				}
				break;
d195 3
a197 3
			case 24:	/* not underlined */
				svsp->vtsgr &= ~VT_UNDER;
				break;
d199 7
a205 7
			case 25:	/* not blinking */
				svsp->vtsgr &= ~VT_BLINK;
				if (pcdisp) {
					setcolor &= ~(FG_BLINK << 8);
					colortouched = 1;
				}
				break;
d207 9
a215 9
			case 27:	/* not reverse */
				svsp->vtsgr &= ~VT_INVERSE;
				if (pcdisp) {
					setcolor = (((setcolor>>8) & 0x88) |
					    ((((setcolor>>8) >> 4) |
					    ((setcolor>>8) << 4)) & 0x77)) << 8;
					colortouched = 1;
				}
				break;
d217 14
a230 14
			case 30:	/* foreground colors */
			case 31:
			case 32:
			case 33:
			case 34:
			case 35:
			case 36:
			case 37:
				if(color)
				{
				 colortouched = 1;
				 setcolor &= ~(FG_MASK<<8);
				 setcolor |= ((fgansitopc[(svsp->parms[i-1]-30) & 7]) << 8);
				 if (pcdisp && svsp->vtsgr & VT_BOLD)
d232 2
a233 2
				}
				break;
d235 15
a249 15
			case 40:	/* background colors */
			case 41:
			case 42:
			case 43:
			case 44:
			case 45:
			case 46:
			case 47:
				if(color)
				{
				 colortouched = 1;
				 setcolor &= ~(BG_MASK<<8);
				 setcolor |= ((bgansitopc[(svsp->parms[i-1]-40) & 7]) << 8);
				}
				break;
d251 4
a254 5
	}
	while(i <= svsp->parmi);
	if(color)
	{
		if(colortouched)
d259 2
a260 3
	else
	{
		if(adaptor_type == MDA_ADAPTOR)
d316 1
a316 1
	if(svsp->col == ((svsp->maxcol)-1))	/* already at right margin */
d319 1
a319 1
	if(p <= 0)				/* parameter min = 1 */
d321 2
a322 2
	else if(p > ((svsp->maxcol)-1))		/* parameter max = 79 */
		p = ((svsp->maxcol)-1);
d324 2
a325 2
	if((svsp->col + p) > ((svsp->maxcol)-1))/* not more than right margin */
		p = ((svsp->maxcol)-1) - svsp->col;
d339 1
a339 1
	if(svsp->col == 0)			/* already at left margin ? */
d342 1
a342 1
	if(p <= 0)				/* parameter min = 1 */
d344 2
a345 2
	else if(p > ((svsp->maxcol)-1))		/* parameter max = 79 */
		p = ((svsp->maxcol)-1);
d347 1
a347 1
	if((svsp->col - p) <= 0)		/* not more than left margin */
d360 17
a376 20
	switch(svsp->parms[0])
	{
		case 0:
			fillw(user_attr | ' ',
				(caddr_t)(svsp->Crtat + svsp->cur_offset),
				svsp->Crtat +
				(svsp->maxcol * svsp->screen_rows) -
				(svsp->Crtat + svsp->cur_offset));
			break;

		case 1:
			fillw(user_attr | ' ', (caddr_t)(svsp->Crtat),
				svsp->Crtat + svsp->cur_offset -
				svsp->Crtat + 1 );
			break;

		case 2:
			fillw(user_attr | ' ', (caddr_t)(svsp->Crtat),
				svsp->maxcol * svsp->screen_rows);
			break;
d386 18
a403 19
	switch(svsp->parms[0])
	{
		case 0:
			fillw(user_attr | ' ',
				(caddr_t)(svsp->Crtat + svsp->cur_offset),
				svsp->maxcol-svsp->col);
			break;

		case 1:
			fillw(user_attr | ' ',(caddr_t)
				(svsp->Crtat + svsp->cur_offset - svsp->col),
				svsp->col + 1);
			break;

		case 2:
			fillw(user_attr | ' ',(caddr_t)
				(svsp->Crtat + svsp->cur_offset - svsp->col),
				svsp->maxcol);
			break;
d413 2
a414 4
	if(svsp->m_om)	/* relative to scrolling region */
	{
		if((svsp->parms[0] == 0) && (svsp->parms[1] == 0))
		{
d421 1
a421 1
		if(svsp->parms[0] <= 0)
d423 1
a423 1
		else if(svsp->parms[0] > svsp->scrr_len)
d426 1
a426 1
		if(svsp->parms[1] <= 0 )
d428 1
a428 1
		if(svsp->parms[1] > svsp->maxcol)
d432 1
a432 2
				   ((svsp->parms[0] - 1) * svsp->maxcol) +
				   svsp->parms[1] - 1;
d436 2
a437 4
	else	/* relative to screen start */
	{
		if((svsp->parms[0] == 0) && (svsp->parms[1] == 0))
		{
d444 1
a444 1
		if(svsp->parms[0] <= 0)
d446 1
a446 1
		else if(svsp->parms[0] > svsp->screen_rows)
d449 1
a449 1
		if(svsp->parms[1] <= 0 )
d451 1
a451 1
		if(svsp->parms[1] > svsp->maxcol)	/* col */
d454 2
a455 2
		svsp->cur_offset = (((svsp->parms[0]-1)*svsp->maxcol) +
				    (svsp->parms[1]-1));
a459 1

d473 1
a473 1
		(caddr_t)(svsp->Crtat), svsp->maxcol * svsp->screen_rows);
a495 1

d497 1
a497 1
	svsp->transparent = 0;			/* enable control code processing */
d501 2
a502 3
	for(i = 0; i < MAXTAB; i++)		/* setup tabstops */
	{
		if(!(i % 8))
d521 1
a521 1
	svsp->ckm = 1;				/* cursor key mode = "normal" ... */
d523 1
a523 1
	svsp->scrr_len = svsp->screen_rows;	/* no. of lines in scrolling region */
d527 1
a527 2
	if(adaptor_type == EGA_ADAPTOR || adaptor_type == VGA_ADAPTOR)
	{
d535 1
a535 2
	else
	{
d571 1
a571 1
	if(svsp->cur_offset < (svsp->scrr_end * svsp->maxcol))
d583 1
a583 2
	if(svsp->cur_offset < (svsp->scrr_end * svsp->maxcol))
	{
d587 1
a587 2
	else
	{
d600 44
a643 39
	switch(svsp->parms[0])
	{
		case 0:		/* error, ignored */
		case 1:		/* CKM - cursor key mode */
			svsp->ckm = 1;
			break;

		case 2:		/* ANM - ansi/vt52 mode */
			break;

		case 3:		/* COLM - column mode */
			vt_col(svsp, SCR_COL132);
			break;

		case 4:		/* SCLM - scrolling mode */
		case 5:		/* SCNM - screen mode */
			break;

		case 6:		/* OM - origin mode */
			svsp->m_om = 1;
			break;

		case 7:		/* AWM - auto wrap mode */
			svsp->m_awm = 1;
			break;

		case 8:		/* ARM - auto repeat mode */
			kbrepflag = 1;
			break;

		case 9:		/* INLM - interlace mode */
		case 10:	/* EDM - edit mode */
		case 11:	/* LTM - line transmit mode */
		case 12:	/* */
		case 13:	/* SCFDM - space compression / field delimiting */
		case 14:	/* TEM - transmit execution mode */
		case 15:	/* */
		case 16:	/* EKEM - edit key execution mode */
			break;
d645 2
a646 8
		case 25:	/* TCEM - text cursor enable mode */
			if(vsp == svsp)
				sw_cursor(1);	/* cursor on */
			svsp->cursor_on = 1;
			break;

		case 42:	/* NRCM - 7bit NRC characters */
			break;
d656 44
a699 13
	switch(svsp->parms[0])
	{
		case 0:		/* error, ignored */
		case 1:		/* CKM - cursor key mode */
			svsp->ckm = 0;
			break;

		case 2:		/* ANM - ansi/vt52 mode */
			break;

		case 3:		/* COLM - column mode */
			vt_col(svsp, SCR_COL80);
			break;
d701 2
a702 34
		case 4:		/* SCLM - scrolling mode */
		case 5:		/* SCNM - screen mode */
			break;

		case 6:		/* OM - origin mode */
			svsp->m_om = 0;
			break;

		case 7:		/* AWM - auto wrap mode */
			svsp->m_awm = 0;
			break;

		case 8:		/* ARM - auto repeat mode */
			kbrepflag = 0;
			break;

		case 9:		/* INLM - interlace mode */
		case 10:	/* EDM - edit mode */
		case 11:	/* LTM - line transmit mode */
		case 12:	/* */
		case 13:	/* SCFDM - space compression / field delimiting */
		case 14:	/* TEM - transmit execution mode */
		case 15:	/* */
		case 16:	/* EKEM - edit key execution mode */
			break;

		case 25:	/* TCEM - text cursor enable mode */
			if(vsp == svsp)
				sw_cursor(0);	/* cursor off */
			svsp->cursor_on = 0;
			break;

		case 42:	/* NRCM - 7bit NRC characters */
			break;
d712 29
a740 30
	switch(svsp->parms[0])
	{
		case 0:		/* error, ignored */
		case 1:		/* GATM - guarded area transfer mode */
		case 2:		/* KAM - keyboard action mode */
		case 3:		/* CRM - Control Representation mode */
			break;

		case 4:		/* IRM - insert replacement mode */
			svsp->irm = 1; /* Insert mode */
			break;

		case 5:		/* SRTM - status report transfer mode */
		case 6:		/* ERM - erasue mode */
		case 7:		/* VEM - vertical editing mode */
		case 10:	/* HEM - horizontal editing mode */
		case 11:	/* PUM - position unit mode */
		case 12:	/* SRM - send-receive mode */
		case 13:	/* FEAM - format effector action mode */
		case 14:	/* FETM - format effector transfer mode */
		case 15:	/* MATM - multiple area transfer mode */
		case 16:	/* TTM - transfer termination */
		case 17:	/* SATM - selected area transfer mode */
		case 18:	/* TSM - tabulation stop mode */
		case 19:	/* EBM - editing boundary mode */
			break;

		case 20:	/* LNM - line feed / newline mode */
			svsp->lnm = 1;
			break;
d750 29
a778 30
	switch(svsp->parms[0])
	{
		case 0:		/* error, ignored */
		case 1:		/* GATM - guarded area transfer mode */
		case 2:		/* KAM - keyboard action mode */
		case 3:		/* CRM - Control Representation mode */
			break;

		case 4:		/* IRM - insert replacement mode */
			svsp->irm = 0;  /* Replace mode */
			break;

		case 5:		/* SRTM - status report transfer mode */
		case 6:		/* ERM - erasue mode */
		case 7:		/* VEM - vertical editing mode */
		case 10:	/* HEM - horizontal editing mode */
		case 11:	/* PUM - position unit mode */
		case 12:	/* SRM - send-receive mode */
		case 13:	/* FEAM - format effector action mode */
		case 14:	/* FETM - format effector transfer mode */
		case 15:	/* MATM - multiple area transfer mode */
		case 16:	/* TTM - transfer termination */
		case 17:	/* SATM - selected area transfer mode */
		case 18:	/* TSM - tabulation stop mode */
		case 19:	/* EBM - editing boundary mode */
			break;

		case 20:	/* LNM - line feed / newline mode */
			svsp->lnm = 0;
			break;
d790 1
a790 1
	if(svsp->parms[0] == 0)
d792 2
a793 3
	else if(svsp->parms[0] == 3)
	{
		for(i=0; i<MAXTAB; i++)
d827 1
a827 2
	if(svsp->sc_flag == 1)
	{
d855 1
a855 1
	if(svsp->whichi == 1)
d857 1
a857 2
	else
	{
d860 1
a860 1
		if(svsp->dld_id[0] == '\0')
d863 1
a863 1
		if(!(((adaptor_type == EGA_ADAPTOR) ||
a865 1
		{
a866 1
		}
d868 2
a869 3
		for(i = (svsp->whichi)-1; i >= 0; i--)
		{
			 if(svsp->which[i] != svsp->dld_id[i])
d879 3
a881 5
	if(((adaptor_type == EGA_ADAPTOR) || (adaptor_type == VGA_ADAPTOR)) &&
	   (vgacs[svsp->vga_charset].secondloaded))
	{
		if((ch == svsp->dld_id[0]) && (svsp->dld_id[1] == '\0'))
		{
d889 7
a895 9
		switch(ch)
		{
			case 'A': /* British or ISO-Latin-1 */
				switch(svsp->state)
				{
					case STATE_BROPN: /* designate G0 */
					case STATE_BRCLO: /* designate G1 */
					case STATE_STAR:  /* designate G2 */
					case STATE_PLUS:  /* designate G3 */
d897 1
a897 1
						ctp = cse_british;
d899 1
a899 1
						break;
d901 3
a903 3
					case STATE_MINUS: /* designate G1 (96)*/
					case STATE_DOT:	  /* designate G2 (96)*/
					case STATE_SLASH: /* designate G3 (96)*/
d905 1
a905 1
						ctp = cse_isolatin;
a906 2
						break;
				}
d908 2
d911 1
a911 1
			case 'B': /* USASCII */
d913 1
a913 1
				ctp = cse_ascii;
d915 1
a915 1
				break;
d917 2
a918 2
			case 'C': /* Finnish */
			case '5': /* Finnish */
d920 1
a920 1
				ctp = cse_finnish;
d922 1
a922 1
				break;
d924 2
a925 2
			case 'E': /* Norwegian/Danish */
			case '6': /* Norwegian/Danish */
d927 1
a927 1
				ctp = cse_norwegiandanish;
d929 1
a929 1
				break;
d931 2
a932 2
			case 'H': /* Swedish */
			case '7': /* Swedish */
d934 1
a934 1
				ctp = cse_swedish;
d936 1
a936 1
				break;
d938 1
a938 1
			case 'K': /* German */
d940 1
a940 1
				ctp = cse_german;
d942 1
a942 1
				break;
d944 1
a944 1
			case 'Q': /* French Canadien */
d946 1
a946 1
				ctp = cse_frenchcanada;
d948 1
a948 1
				break;
d950 1
a950 1
			case 'R': /* French */
d952 1
a952 1
				ctp = cse_french;
d954 1
a954 1
				break;
d956 1
a956 1
   			case 'X': /* KOI8 hack */
d958 1
a958 1
				ctp = cse_koi8;
d960 1
a960 1
				break;
d962 1
a962 1
			case 'Y': /* Italian */
d964 1
a964 1
				ctp = cse_italian;
d966 1
a966 1
				break;
d968 1
a968 1
			case 'Z': /* Spanish */
d970 1
a970 1
				ctp = cse_spanish;
d972 1
a972 1
				break;
d974 1
a974 1
			case '0': /* special graphics */
d976 1
a976 1
				ctp = cse_special;
d978 1
a978 1
				break;
d980 1
a980 1
			case '1': /* alternate ROM */
d982 1
a982 1
				ctp = cse_alternaterom1;
d984 1
a984 1
				break;
d986 1
a986 1
			case '2': /* alt ROM, spec graphics */
d988 1
a988 1
				ctp = cse_alternaterom2;
d990 1
a990 1
				break;
d992 1
a992 1
			case '3': /* HP Roman 8, upper 128 chars*/
d994 1
a994 1
				ctp = cse_roman8;
d996 1
a996 1
				break;
d998 1
a998 1
			case '4': /* Dutch */
d1000 1
a1000 1
				ctp = cse_dutch;
d1002 1
a1002 1
				break;
d1004 1
a1004 1
			case '<': /* DEC Supplemental */
d1006 1
a1006 1
				ctp = cse_supplemental;
d1008 1
a1008 1
				break;
d1010 1
a1010 1
			case '=': /* Swiss */
d1012 1
a1012 1
				ctp = cse_swiss;
d1014 1
a1014 1
				break;
d1016 1
a1016 1
			case '>': /* DEC Technical */
d1018 1
a1018 1
				ctp = cse_technical;
d1020 1
a1020 1
				break;
d1022 2
a1023 2
			default:
				break;
d1026 8
a1033 11
	else
	{
		switch(ch)
		{
			case 'A': /* British or ISO-Latin-1 */
				switch(svsp->state)
				{
					case STATE_BROPN: /* designate G0 */
					case STATE_BRCLO: /* designate G1 */
					case STATE_STAR:  /* designate G2 */
					case STATE_PLUS:  /* designate G3 */
d1035 1
a1035 1
						ctp = csd_british;
d1037 1
a1037 1
						break;
d1039 3
a1041 3
					case STATE_MINUS: /* designate G1 (96)*/
					case STATE_DOT:	  /* designate G2 (96)*/
					case STATE_SLASH: /* designate G3 (96)*/
d1043 1
a1043 1
						ctp = csd_isolatin;
a1044 2
						break;
				}
d1046 2
d1049 1
a1049 1
			case 'B': /* USASCII */
d1051 2
a1052 2
				ctp = csd_ascii;
				pcdisp_special = 0;
d1054 1
a1054 1
				break;
d1056 2
a1057 2
			case 'C': /* Finnish */
			case '5': /* Finnish */
d1059 1
a1059 1
				ctp = csd_finnish;
d1061 1
a1061 1
				break;
d1063 2
a1064 2
			case 'E': /* Norwegian/Danish */
			case '6': /* Norwegian/Danish */
d1066 1
a1066 1
				ctp = csd_norwegiandanish;
d1068 1
a1068 1
				break;
d1070 2
a1071 2
			case 'H': /* Swedish */
			case '7': /* Swedish */
d1073 1
a1073 1
				ctp = csd_swedish;
d1075 1
a1075 1
				break;
d1077 1
a1077 1
			case 'K': /* German */
d1079 1
a1079 1
				ctp = csd_german;
d1081 1
a1081 1
				break;
d1083 1
a1083 1
			case 'Q': /* French Canadien */
d1085 1
a1085 1
				ctp = csd_frenchcanada;
d1087 1
a1087 1
				break;
d1089 1
a1089 1
			case 'R': /* French */
d1091 1
a1091 1
				ctp = csd_french;
d1093 1
a1093 1
				break;
d1095 1
a1095 1
   			case 'X': /* KOI8 hack */
d1097 1
a1097 1
				ctp = csd_koi8;
d1099 1
a1099 1
				break;
d1101 1
a1101 1
			case 'Y': /* Italian */
d1103 1
a1103 1
				ctp = csd_italian;
d1105 1
a1105 1
				break;
d1107 1
a1107 1
			case 'Z': /* Spanish */
d1109 1
a1109 1
				ctp = csd_spanish;
d1111 1
a1111 1
				break;
d1113 1
a1113 1
			case '0': /* special graphics */
d1115 2
a1116 2
				ctp = csd_special;
				pcdisp_special = 1;
d1118 1
a1118 1
				break;
d1120 1
a1120 1
			case '1': /* alternate ROM */
d1122 1
a1122 1
				ctp = csd_alternaterom1;
d1124 1
a1124 1
				break;
d1126 1
a1126 1
			case '2': /* alt ROM, spec graphics */
d1128 1
a1128 1
				ctp = csd_alternaterom2;
d1130 1
a1130 1
				break;
d1132 1
a1132 1
			case '3': /* HP Roman 8, upper 128 chars*/
d1134 1
a1134 1
				ctp = csd_roman8;
d1136 1
a1136 1
				break;
d1138 1
a1138 1
			case '4': /* Dutch */
d1140 1
a1140 1
				ctp = csd_dutch;
d1142 1
a1142 1
				break;
d1144 1
a1144 1
			case '<': /* DEC Supplemental */
d1146 2
a1147 2
				ctp = csd_supplemental;
				pcdisp_special = 1;
d1149 1
a1149 1
				break;
d1151 1
a1151 1
			case '=': /* Swiss */
d1153 1
a1153 1
				ctp = csd_swiss;
d1155 1
a1155 1
				break;
d1157 1
a1157 1
			case '>': /* DEC Technical */
d1159 2
a1160 2
				ctp = csd_technical;
				pcdisp_special = 1;
d1162 1
a1162 1
				break;
d1164 2
a1165 2
			default:
				break;
d1195 1
a1195 2
	for(i=0; i < (svsp->screen_rows*svsp->maxcol); i++)
	{
d1242 42
a1283 20
	switch(svsp->parms[0])
	{
		case 5:		/* return status */
			svsp->report_chars = answr;
			svsp->report_count = 4;
			respond(svsp);
			break;

		case 6:		/* return cursor position */
			buffer[i++] = 0x1b;
			buffer[i++] = '[';
			if((svsp->row+1) > 10)
				buffer[i++] = ((svsp->row+1) / 10) + '0';
			buffer[i++] = ((svsp->row+1) % 10) + '0';
			buffer[i++] = ';';
			if((svsp->col+1) > 10)
				buffer[i++] = ((svsp->col+1) / 10) + '0';
			buffer[i++] = ((svsp->col+1) % 10) + '0';
			buffer[i++] = 'R';
			buffer[i++] = '\0';
d1285 2
a1286 25
			svsp->report_chars = buffer;
			svsp->report_count = i;
			respond(svsp);
			break;

		case 15:	/* return printer status */
			svsp->report_chars = panswr;
			svsp->report_count = 6;
			respond(svsp);
			break;

		case 25:	/* return udk status */
			svsp->report_chars = udkanswr;
			svsp->report_count = 6;
			respond(svsp);
			break;

		case 26:	/* return language status */
			svsp->report_chars = langanswr;
			svsp->report_count = 8;
			respond(svsp);
			break;

		default:	/* nothing else valid */
			break;
d1298 2
a1299 3
	if((svsp->row >= svsp->scrr_beg) && (svsp->row <= svsp->scrr_end))
	{
		if(p <= 0)
d1301 1
a1301 1
		else if(p > svsp->scrr_end - svsp->row)
d1306 1
a1306 1
		if(svsp->row == svsp->scrr_beg)
d1308 9
a1316 9
		else
		{
		    bcopy(svsp->Crtat + svsp->cur_offset,
			  svsp->Crtat + svsp->cur_offset + (p * svsp->maxcol),
			  svsp->maxcol * (svsp->scrr_end-svsp->row+1-p) * CHR );

		    fillw(user_attr | ' ',
			  (caddr_t)(svsp->Crtat + svsp->cur_offset),
			  p * svsp->maxcol);
d1329 1
a1329 1
	if(p <= 0)
d1331 1
a1331 1
	else if(p > svsp->maxcol-svsp->col)
d1334 1
a1334 2
	while(p--)
	{
d1336 2
a1337 2
		      (svsp->Crtat + svsp->cur_offset) + 1,
		      (((svsp->maxcol)-1)-svsp->col) * CHR);
d1352 2
a1353 3
	if((svsp->row >= svsp->scrr_beg) && (svsp->row <= svsp->scrr_end))
	{
		if(p <= 0)
d1355 1
a1355 1
		else if(p > svsp->scrr_end - svsp->row)
d1361 1
a1361 1
		if(svsp->row == svsp->scrr_beg)
d1363 9
a1371 9
		else
		{
		    bcopy(svsp->Crtat + svsp->cur_offset + (p * svsp->maxcol),
			  svsp->Crtat + svsp->cur_offset,
			  svsp->maxcol * (svsp->scrr_end-svsp->row+1-p) * CHR );

		    fillw(user_attr | ' ',(caddr_t)
			  (svsp->Crtat + ((svsp->scrr_end-p+1) * svsp->maxcol)),
			  p * svsp->maxcol);
d1384 1
a1384 1
	if(p <= 0)
d1386 1
a1386 1
	else if(p > svsp->maxcol-svsp->col)
d1389 4
a1392 5
	while(p--)
	{
		bcopy((svsp->Crtat + svsp->cur_offset)+1,
		      (svsp->Crtat + svsp->cur_offset),
		      (((svsp->maxcol)-1) - svsp->col)* CHR );
d1395 1
a1395 1
			((svsp->maxcol)-1)-svsp->col) = user_attr | ' ';
d1407 1
a1407 1
	if(p <= 0)
d1409 2
a1410 2
	else if(p > svsp->screen_rows-1)
		p = svsp->screen_rows-1;
d1423 1
a1423 1
	if(p <= 0)
d1425 1
a1425 1
	else if(p > svsp->screen_rows-1)
d1439 1
a1439 1
	if(p <= 0)
d1441 2
a1442 2
	else if(p > svsp->maxcol-svsp->col)
		p = svsp->maxcol-svsp->col;
d1465 21
a1485 18
	switch(svsp->dcs_state)
	{
		case DCS_INIT:
			switch(ch)
			{
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':	/* parameters */
					svsp->parms[svsp->parmi] *= 10;
					svsp->parms[svsp->parmi] += (ch -'0');
					break;
d1487 5
a1491 5
				case ';':	/* next parameter */
					svsp->parmi =
						(svsp->parmi+1 < MAXPARMS) ?
						svsp->parmi+1 : svsp->parmi;
					break;
d1493 5
a1497 5
				case '|':	/* DECUDK */
					svsp->transparent = 1;
					init_udk(svsp);
					svsp->dcs_state = DCS_AND_UDK;
					break;
d1499 7
a1505 5
				case '{':	/* DECDLD */
					svsp->transparent = 1;
					init_dld(svsp);
					svsp->dcs_state = DCS_DLD_DSCS;
					break;
d1507 14
a1520 6
				default:	 /* failsafe */
					svsp->transparent = 0;
					svsp->state = STATE_INIT;
					svsp->dcs_state = DCS_INIT;
					break;
			}
d1523 3
a1525 16
		case DCS_AND_UDK:	 /* DCS ... | */
			switch(ch)
			{
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':	/* fkey number */
					svsp->udk_fnckey *= 10;
					svsp->udk_fnckey += (ch -'0');
					break;
d1527 3
a1529 3
				case '/':	/* Key */
					svsp->dcs_state = DCS_UDK_DEF;
					break;
d1531 7
a1537 3
				case 0x1b:	 /* ESC */
					svsp->dcs_state = DCS_UDK_ESC;
					break;
d1539 23
a1561 5
				default:
					svsp->transparent = 0;
					svsp->state = STATE_INIT;
					svsp->dcs_state = DCS_INIT;
					break;
d1565 20
a1584 26
		case DCS_UDK_DEF:	 /* DCS ... | fnckey / */
			switch(ch)
			{
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
					if(svsp->udk_deflow)	/* low nibble */
					{
						svsp->udk_def[svsp->udk_defi] |= (ch -'0');
						svsp->udk_deflow = 0;
						svsp->udk_defi = (svsp->udk_defi+1 >= MAXUDKDEF) ?
						svsp->udk_defi : svsp->udk_defi+1;
					}
					else			/* high nibble */
					{
						svsp->udk_def[svsp->udk_defi] = ((ch -'0') << 4);
						svsp->udk_deflow = 1;
					}
					break;
d1586 20
a1605 19
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
					if(svsp->udk_deflow) 	/* low nibble */
					{
						svsp->udk_def[svsp->udk_defi] |= (ch - 'a' + 10);
						svsp->udk_deflow = 0;
						svsp->udk_defi = (svsp->udk_defi+1 >= MAXUDKDEF) ?
						svsp->udk_defi : svsp->udk_defi+1;
					}
					else			/* high nibble */
					{
						svsp->udk_def[svsp->udk_defi] = ((ch - 'a' + 10) << 4);
						svsp->udk_deflow = 1;
					}
					break;
d1607 4
d1612 3
d1616 7
a1622 19
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
					if(svsp->udk_deflow) 	/* low nibble */
					{
						svsp->udk_def[svsp->udk_defi] |= (ch - 'A' + 10);
						svsp->udk_deflow = 0;
						svsp->udk_defi = (svsp->udk_defi+1 >= MAXUDKDEF) ?
						svsp->udk_defi : svsp->udk_defi+1;
					}
					else			/* high nibble */
					{
						svsp->udk_def[svsp->udk_defi] = ((ch - 'A' + 10) << 4);
						svsp->udk_deflow = 1;
					}
					break;
d1624 7
a1630 15
				case ';':	/* next function key */
					vt_udk(svsp);
					svsp->dcs_state = DCS_AND_UDK;
					break;

				case 0x1b:	 /* ESC */
					svsp->dcs_state = DCS_UDK_ESC;
					break;

				default:
					svsp->transparent = 0;
					svsp->state = STATE_INIT;
					svsp->dcs_state = DCS_INIT;
					break;
			}
d1633 4
a1636 16
		case DCS_UDK_ESC:	 /* DCS ... | fkey/def ... ESC */
			switch(ch)
			{
				case '\\':	/* ST */
					vt_udk(svsp);
					svsp->transparent = 0;
					svsp->state = STATE_INIT;
					svsp->dcs_state = DCS_INIT;
					break;

				default:
					svsp->transparent = 0;
					svsp->state = STATE_INIT;
					svsp->dcs_state = DCS_INIT;
					break;
			}
d1638 2
d1642 5
a1646 26
		case DCS_DLD_DSCS:	 /* got DCS ... { */
			if(ch >= ' ' && ch <= '/')	/* intermediates ... */
			{
				svsp->dld_dscs[svsp->dld_dscsi] = ch;
				svsp->dld_id[svsp->dld_dscsi] = ch;
				if(svsp->dld_dscsi >= DSCS_LENGTH)
				{
					svsp->transparent = 0;
					svsp->state = STATE_INIT;
					svsp->dcs_state = DCS_INIT;
					svsp->dld_id[0] = '\0';
				}
				else
				{
					svsp->dld_dscsi++;
				}
			}
			else if(ch >= '0' && ch <= '~')	/* final .... */
			{
				svsp->dld_dscs[svsp->dld_dscsi] = ch;
				svsp->dld_id[svsp->dld_dscsi++] = ch;
				svsp->dld_id[svsp->dld_dscsi] = '\0';
				svsp->dcs_state = DCS_DLD_DEF;
			}
			else
			{
d1652 21
d1675 3
a1677 6
		case DCS_DLD_DEF:	 /* DCS ... { dscs */
			switch(ch)
			{
				case 0x1b:	 /* ESC */
					svsp->dcs_state = DCS_DLD_ESC;
					break;
d1679 4
a1682 3
				case '/':	 /* sixel upper / lower divider */
					svsp->dld_sixel_lower = 1;
					break;
d1684 18
a1701 23
				case ';':	 /* character divider */
					vt_dld(svsp);
					svsp->parms[1]++;	/* next char */
					break;

 				default:
					if (svsp->dld_sixel_lower)
					{
						if(ch >= '?' && ch <= '~')
							svsp->sixel.lower[svsp->dld_sixelli] = ch - '?';
						svsp->dld_sixelli =
						 (svsp->dld_sixelli+1 < MAXSIXEL) ?
						 svsp->dld_sixelli+1 : svsp->dld_sixelli;
					}
					else
					{
						if(ch >= '?' && ch <= '~')
							svsp->sixel.upper[svsp->dld_sixelui] = ch - '?';
						svsp->dld_sixelui =
						 (svsp->dld_sixelui+1 < MAXSIXEL) ?
						 svsp->dld_sixelui+1 : svsp->dld_sixelui;
					}
					break;
a1702 10
			break;

		case DCS_DLD_ESC:	 /* DCS ... { dscs ... / ... ESC */
			switch(ch)
			{
				case '\\':	/* String Terminator ST */
					vt_dld(svsp);
					svsp->transparent = 0;
					svsp->state = STATE_INIT;
					svsp->dcs_state = DCS_INIT;
d1704 2
d1707 7
a1713 7
 				default:
					svsp->transparent = 0;
					svsp->state = STATE_INIT;
					svsp->dcs_state = DCS_INIT;
					svsp->dld_id[0] = '\0';
					break;
			}
d1720 3
d1724 6
d1742 1
a1742 2
	if(svsp->parms[0] != 1)		/* clear all ? */
	{
d1747 1
a1747 2
	if(svsp->udk_fnckey < 17 || svsp->udk_fnckey > 34)
	{
d1754 2
a1755 4
	if(svsp->ukt.length[key] == 0)			/* never used ? */
	{
		if(svsp->udkff < MAXUDKDEF-2)		/* space available ? */
		{
d1761 1
a1761 2
		else					/* no space */
		{
d1766 1
a1766 2
	else						/* in use, redefine */
	{
d1771 1
a1771 2
	if(max < 2)				/* hmmm .. */
	{
d1778 1
a1778 1
	for(i = 0; i < max && i < svsp->udk_defi; i++)
d1782 3
a1784 3
	svsp->ukt.length[key] = i+1;	/* count for tailing '\0' */
	if(usedff)
		svsp->udkff += (i+2);	/* new start location */
d1797 1
a1797 2
	for(i = 0; i < MAXUDKEYS; i++)
	{
d1814 1
a1814 1
	if(vgacs[svsp->vga_charset].secondloaded)
d1820 1
a1820 1
		((svsp->parms[1] > 0x7E) ? 0x7E : svsp->parms[1]);
d1822 1
a1822 2
	if(svsp->parms[2] != 1)   /* Erase all characters ? */
	{
d1824 1
a1824 1
		svsp->parms[2] = 1;   /* Only erase all characters once per sequence */
d1827 1
a1827 1
	sixel_vga(&(svsp->sixel),vgachar);
d1829 4
a1832 5
	switch(vgacs[vgacharset].char_scanlines & 0x1F)
	{
		case 7:
			vga10_vga8(vgachar,vgacharb);
			break;
d1834 3
a1836 4
		case 9:
		default:
			vga10_vga10(vgachar,vgacharb);
			break;
d1838 3
a1840 3
		case 13:
			vga10_vga14(vgachar,vgacharb);
			break;
d1842 4
a1845 3
		case 15:
			vga10_vga16(vgachar,vgacharb);
			break;
d1871 10
a1880 11
	switch(p0)
	{
		case 61:
			svsp->sevenbit = 1;
			break;
		case 62:
		/* case 63: vt320 */
		default:
			if(p1 != 1)
				svsp->C1_ctls = 1;
			break;
d1890 9
a1898 10
	switch(svsp->parms[0])
	{
		case 1:
			svsp->selchar = 1;
			break;
		case 0:
		case 2:
		default:
			svsp->selchar = 0;
			break;
d1910 1
a1910 1
	for(i = 0;i < MAXDECSCA;i++)
d1920 15
a1934 16
	switch(svsp->parms[0])
	{
		case 0:
			selective_erase(svsp, (svsp->Crtat + svsp->cur_offset),
					 svsp->maxcol-svsp->col);
			break;

		case 1:
			selective_erase(svsp, (svsp->Crtat + svsp->cur_offset)-
					svsp->col, svsp->col + 1);
			break;

		case 2:
			selective_erase(svsp, (svsp->Crtat + svsp->cur_offset)-
					svsp->col, svsp->maxcol);
			break;
d1944 16
a1959 17
	switch(svsp->parms[0])
	{
		case 0:
			selective_erase(svsp, (svsp->Crtat + svsp->cur_offset),
			      svsp->Crtat + (svsp->maxcol * svsp->screen_rows) -
			      (svsp->Crtat + svsp->cur_offset));
			break;

		case 1:
			selective_erase(svsp, svsp->Crtat,
			   (svsp->Crtat + svsp->cur_offset) - svsp->Crtat + 1 );
			break;

		case 2:
			selective_erase(svsp, svsp->Crtat,
				svsp->maxcol * svsp->screen_rows);
			break;
d1972 1
a1972 1
	if(svsp->scrr_beg == 0 &&       /* if scroll region is whole screen */
d1988 2
a1989 3
		if(svsp->Crtat > (Memory + (svsp->screen_rows - n) *
					svsp->maxcol))
		{
a1995 1
		{
a1996 1
		}
d2001 3
a2003 3
		bcopy(	svsp->Crtat + ((svsp->scrr_beg + n) * svsp->maxcol),
			svsp->Crtat + (svsp->scrr_beg * svsp->maxcol),
			svsp->maxcol * (svsp->scrr_len - n) * CHR );
d2006 3
a2008 3
	fillw(	user_attr | ' ',(caddr_t)
		(svsp->Crtat + ((svsp->scrr_end - n + 1) * svsp->maxcol)),
		n * svsp->maxcol);
d2010 1
a2010 1
/*XXX*/	if(svsp->scroll_lock && svsp->openf && curproc)
d2023 1
a2023 1
	if(svsp->scrr_beg == 0 &&	/* if scroll region is whole screen */
d2039 1
a2039 2
		if (svsp->Crtat < (Memory + n * svsp->maxcol))
		{
d2041 2
a2042 2
			      Memory + svsp->maxcol * (svsp->screen_rows + n),
		       	      svsp->maxcol * (svsp->screen_rows - n) * CHR);
a2046 1
		{
a2047 1
		}
d2052 3
a2054 3
		bcopy(  svsp->Crtat + (svsp->scrr_beg * svsp->maxcol),
			svsp->Crtat + ((svsp->scrr_beg + n) * svsp->maxcol),
			svsp->maxcol * (svsp->scrr_len - n) * CHR );
d2057 3
a2059 3
	fillw(	user_attr | ' ',(caddr_t)
		(svsp->Crtat + (svsp->scrr_beg * svsp->maxcol)),
		n * svsp->maxcol);
d2061 1
a2061 1
/*XXX*/	if(svsp->scroll_lock && svsp->openf && curproc)
d2071 1
a2071 1
	if(ctp == NULL)
d2076 35
a2110 36
	switch(svsp->state)
	{
		case STATE_BROPN:	/* designate G0 */
                        if (svsp->GL == svsp->G0)
                            svsp->GL = ctp;
                        if (svsp->GR == svsp->G0)
                            svsp->GR = ctp;
			svsp->G0 = ctp;
			break;

		case STATE_BRCLO:	/* designate G1 */
		case STATE_MINUS:	/* designate G1 (96) */
                        if (svsp->GL == svsp->G1)
                            svsp->GL = ctp;
                        if (svsp->GR == svsp->G1)
                            svsp->GR = ctp;
			svsp->G1 = ctp;
			break;

		case STATE_STAR:	/* designate G2 */
		case STATE_DOT:		/* designate G2 (96) */
                        if (svsp->GL == svsp->G2)
                            svsp->GL = ctp;
                        if (svsp->GR == svsp->G2)
                            svsp->GR = ctp;
			svsp->G2 = ctp;
			break;

		case STATE_PLUS:	/* designate G3 */
		case STATE_SLASH:	/* designate G3 (96) */
                        if (svsp->GL == svsp->G3)
                            svsp->GL = ctp;
                        if (svsp->GR == svsp->G3)
                            svsp->GR = ctp;
			svsp->G3 = ctp;
			break;
d2120 1
a2120 1
	if(!(svsp->openf))	      /* are we opened ? */
d2123 1
a2123 2
	while (*svsp->report_chars && svsp->report_count > 0)
	{
d2125 1
a2125 1
			(*svsp->report_chars++ & 0xff, svsp->vs_tty);
d2151 1
a2151 1
	if(vgacs[svsp->vga_charset].secondloaded)
d2156 1
a2156 1
	for(i=0;i < 16;i++)  /* A zeroed character, vt220 has inverted '?' */
d2159 1
a2159 1
	for(i=1;i <= 94;i++) /* Load (erase) all characters */
d2176 1
a2176 1
	for(i = 0;i < MAXSIXEL;i++)
d2188 3
a2190 5
	for(j = pcrtat - svsp->Crtat, i = 0;i < length;i++,pcrtat++)
	{
		if(!(svsp->decsca[INT_INDEX(j+i)] & (1 << BIT_INDEX(j+i))))
		{
			*pcrtat &= 0xFF00; /* Keep the video character attributes */
@


1.9
log
@- Teach vt_cuu (cursor up) about scrollback. Cursor down is much harder...
- Support ANSI save/restore cursor position escape sequences.
- Move the line-wrap check out of the STATE_INIT case so it is executed
regardless of the state. This fixes a subtle bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_vtf.c,v 1.8 1999/10/20 19:15:52 deraadt Exp $	*/
a568 3
	init_ufkl(svsp);			/* init user fkey labels */
	init_sfkl(svsp);			/* init system fkey labels */

a644 1
			swritefkl(7,(u_char *)"AUTOWRAPENABLE *",svsp);
a701 1
			swritefkl(7,(u_char *)"AUTOWRAPENABLE  ",svsp);
@


1.8
log
@special character handling; aaron
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_vtf.c,v 1.7 1999/10/16 18:56:36 aaron Exp $	*/
d289 3
@


1.7
log
@- Add support for a traditional PC display (16 colors and use the standard IBM
font) and make it the default mode. This is more or less a hack, since pcvt
was developed only to be a vt220 terminal emulator.
- Document new default mode in pcvt(4).
- Add -o option to scon(1) for toggling between the new and legacy modes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_vtf.c,v 1.6 1998/11/16 23:47:57 weingart Exp $	*/
d1092 1
d1156 1
d1187 1
d1200 1
@


1.6
log
@Fix attribute handling.  From
John Wright <juggler@@oaktree.co.uk>
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_vtf.c,v 1.5 1997/05/30 01:43:07 mickey Exp $	*/
d152 2
d158 6
d172 4
d180 8
d192 4
d204 4
d212 6
d233 2
@


1.5
log
@add koi8 support
from Roman Palagin <romanp@@mutant.mybody.ryazan.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: pcvt_vtf.c,v 1.4 1996/05/07 13:07:06 mickey Exp $	*/
d144 2
d197 1
d213 1
@


1.4
log
@fix that fillw's stuff again.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d953 6
d1092 6
@


1.3
log
@fillw is in machine/cpu.h now.
@
text
@d325 2
a326 1
			fillw(user_attr | ' ', (caddr_t)svsp->Crtat + svsp->cur_offset,
d333 1
a333 1
			fillw(user_attr | ' ', (caddr_t)svsp->Crtat,
d339 1
a339 1
			fillw(user_attr | ' ', (caddr_t)svsp->Crtat,
d355 1
a355 1
				(caddr_t)svsp->Crtat + svsp->cur_offset,
d360 2
a361 2
			fillw(user_attr | ' ',
				(caddr_t)svsp->Crtat + svsp->cur_offset - svsp->col,
d366 2
a367 2
			fillw(user_attr | ' ',
				(caddr_t)svsp->Crtat + svsp->cur_offset - svsp->col,
d444 2
a445 1
	fillw(user_attr | ' ', (caddr_t)svsp->Crtat, svsp->maxcol * svsp->screen_rows);
d1302 1
a1302 1
			  (caddr_t)svsp->Crtat + svsp->cur_offset,
d1358 2
a1359 2
		    fillw(user_attr | ' ',
			  (caddr_t)svsp->Crtat + ((svsp->scrr_end-p+1) * svsp->maxcol),
d2025 2
a2026 2
	fillw(	user_attr | ' ',
		(caddr_t)svsp->Crtat + ((svsp->scrr_end - n + 1) * svsp->maxcol),
d2079 2
a2080 2
	fillw(	user_attr | ' ',
		(caddr_t)svsp->Crtat + (svsp->scrr_beg * svsp->maxcol),
@


1.2
log
@Merge of NetBSD 960317
@
text
@d325 1
a325 1
			fillw(user_attr | ' ', svsp->Crtat + svsp->cur_offset,
d332 1
a332 1
			fillw(user_attr | ' ', svsp->Crtat,
d338 1
a338 1
			fillw(user_attr | ' ', svsp->Crtat,
d354 1
a354 1
				svsp->Crtat + svsp->cur_offset,
d360 1
a360 1
				svsp->Crtat + svsp->cur_offset - svsp->col,
d366 1
a366 1
				svsp->Crtat + svsp->cur_offset - svsp->col,
d443 1
a443 1
	fillw(user_attr | ' ', svsp->Crtat, svsp->maxcol * svsp->screen_rows);
d1300 1
a1300 1
			  svsp->Crtat + svsp->cur_offset,
d1357 1
a1357 1
			  svsp->Crtat + ((svsp->scrr_end-p+1) * svsp->maxcol),
d1432 1
a1432 1
	fillw(user_attr | ' ', (svsp->Crtat + svsp->cur_offset), p);
d2024 1
a2024 1
		svsp->Crtat + ((svsp->scrr_end - n + 1) * svsp->maxcol),
d2078 1
a2078 1
		svsp->Crtat + (svsp->scrr_beg * svsp->maxcol),
@


1.1
log
@Initial revision
@
text
@d1 2
a2013 8

		if(vsp == svsp && !(vsp->vt_status & VT_GRAFX))
		{
			outb(addr_6845, CRTC_STARTADRH);
			outb(addr_6845+1, (svsp->Crtat - Crtat) >> 8);
			outb(addr_6845, CRTC_STARTADRL);
			outb(addr_6845+1, (svsp->Crtat - Crtat));
		}
a2066 8
		}

		if(vsp == svsp && !(vsp->vt_status & VT_GRAFX))
		{
			outb(addr_6845, CRTC_STARTADRH);
			outb(addr_6845+1, (svsp->Crtat - Crtat) >> 8);
			outb(addr_6845, CRTC_STARTADRL);
			outb(addr_6845+1, (svsp->Crtat - Crtat));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
