head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.6
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.2
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.20.0.34
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.36
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.28
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.32
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.30
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.26
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.24
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.22
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.20
	OPENBSD_5_0:1.20.0.18
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.16
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.14
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.10
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.12
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.8
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.6
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.4
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.20
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.18
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.16
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.14
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.12
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.10
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.8
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.6
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.18
	UBC:1.17.0.4
	UBC_BASE:1.17
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.4
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.2
	SMP_BASE:1.13
	kame_19991208:1.13
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.8
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.6
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2016.06.05.20.02.36;	author bru;	state Exp;
branches;
next	1.20;
commitid	yQU8JfyotYfDAe86;

1.20
date	2007.04.10.22.37.17;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2006.09.19.11.06.34;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.07.19.24.27;	author jason;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	2001.02.20.23.53.27;	author jbm;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.20.23.04.05;	author jbm;	state dead;
branches;
next	1.14;

1.14
date	2000.05.16.18.12.14;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	99.11.22.07.25.38;	author matthieu;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	99.08.22.08.16.20;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	99.01.13.07.26.01;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.11.28.23.37.40;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	96.11.12.20.30.03;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.05.25.22.17.50;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.05.07.07.22.19;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.16.57;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.03.20.00.31.04;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.19.21.09.36;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.20.04.35.31;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.10.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.37;	author deraadt;	state Exp;
branches;
next	;

1.13.2.1
date	2001.04.18.16.07.53;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2001.10.31.03.01.12;	author nate;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	;

1.17.4.1
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Use the new input functions of wsmouse in mouse and touchscreen drivers.

ok stsp@@ kettenis@@
@
text
@/*	$OpenBSD: lms.c,v 1.20 2007/04/10 22:37:17 miod Exp $	*/
/*	$NetBSD: lms.c,v 1.38 2000/01/08 02:57:25 takemura Exp $	*/

/*-
 * Copyright (c) 1993, 1994 Charles M. Hannum.
 * Copyright (c) 1992, 1993 Erik Forsberg.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
 * NO EVENT SHALL I BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/isa/isavar.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsmousevar.h>

#define	LMS_DATA	0       /* offset for data port, read-only */
#define	LMS_SIGN	1       /* offset for signature port, read-write */
#define	LMS_INTR	2       /* offset for interrupt port, read-only */
#define	LMS_CNTRL	2       /* offset for control port, write-only */
#define	LMS_CONFIG	3	/* for configuration port, read-write */
#define	LMS_NPORTS	4

struct lms_softc {		/* driver status information */
	struct device sc_dev;
	void *sc_ih;

	bus_space_tag_t sc_iot;		/* bus i/o space identifier */
	bus_space_handle_t sc_ioh;	/* bus i/o handle */

	int sc_enabled; /* device is open */
	int oldbuttons;	/* mouse button status */

	struct device *sc_wsmousedev;
};

int lmsprobe(struct device *, void *, void *);
void lmsattach(struct device *, struct device *, void *);
int lmsintr(void *);

struct cfattach lms_ca = {
	sizeof(struct lms_softc), lmsprobe, lmsattach
};

int	lms_enable(void *);
int	lms_ioctl(void *, u_long, caddr_t, int, struct proc *);
void	lms_disable(void *);

const struct wsmouse_accessops lms_accessops = {
	lms_enable,
	lms_ioctl,
	lms_disable,
};

int
lmsprobe(struct device *parent, void *match, void *aux)
{
	struct isa_attach_args *ia = aux;
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh;
	int rv;
	
	/* Disallow wildcarded i/o base. */
	if (ia->ia_iobase == IOBASEUNK)
		return 0;

	/* Map the i/o space. */
	if (bus_space_map(iot, ia->ia_iobase, LMS_NPORTS, 0, &ioh))
		return 0;

	rv = 0;

	/* Configure and check for port present. */
	bus_space_write_1(iot, ioh, LMS_CONFIG, 0x91);
	delay(10);
	bus_space_write_1(iot, ioh, LMS_SIGN, 0x0c);
	delay(10);
	if (bus_space_read_1(iot, ioh, LMS_SIGN) != 0x0c)
		goto out;
	bus_space_write_1(iot, ioh, LMS_SIGN, 0x50);
	delay(10);
	if (bus_space_read_1(iot, ioh, LMS_SIGN) != 0x50)
		goto out;

	/* Disable interrupts. */
	bus_space_write_1(iot, ioh, LMS_CNTRL, 0x10);

	rv = 1;
	ia->ia_iosize = LMS_NPORTS;
	ia->ia_msize = 0;

out:
	bus_space_unmap(iot, ioh, LMS_NPORTS);
	return rv;
}

void
lmsattach(struct device *parent, struct device *self, void *aux)
{
	struct lms_softc *sc = (void *)self;
	struct isa_attach_args *ia = aux;
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh;
	struct wsmousedev_attach_args a;

	printf("\n");

	if (bus_space_map(iot, ia->ia_iobase, LMS_NPORTS, 0, &ioh)) {
		printf("%s: can't map i/o space\n", sc->sc_dev.dv_xname);
		return;
	}

	/* Other initialization was done by lmsprobe. */
	sc->sc_iot = iot;
	sc->sc_ioh = ioh;
	sc->sc_enabled = 0;

	sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_PULSE,
	    IPL_TTY, lmsintr, sc, sc->sc_dev.dv_xname);

	a.accessops = &lms_accessops;
	a.accesscookie = sc;

	/*
	 * Attach the wsmouse, saving a handle to it.
	 * Note that we don't need to check this pointer against NULL
	 * here or in psmintr, because if this fails lms_enable() will
	 * never be called, so lmsintr() will never be called.
	 */
	sc->sc_wsmousedev = config_found(self, &a, wsmousedevprint);
}

int
lms_enable(void *v)
{
	struct lms_softc *sc = v;

	if (sc->sc_enabled)
		return EBUSY;

	sc->sc_enabled = 1;
	sc->oldbuttons = 0;

	/* Enable interrupts. */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, LMS_CNTRL, 0);

	return 0;
}

void
lms_disable(void *v)
{
	struct lms_softc *sc = v;

	/* Disable interrupts. */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, LMS_CNTRL, 0x10);

	sc->sc_enabled = 0;
}

int
lms_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
#if 0
	struct lms_softc *sc = v;
#endif

	switch (cmd) {
	case WSMOUSEIO_GTYPE:
		*(u_int *)data = WSMOUSE_TYPE_LMS;
		return (0);
	}
	return (-1);
}

int
lmsintr(void *arg)
{
	struct lms_softc *sc = arg;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_char hi, lo;
	signed char dx, dy;
	u_int buttons;
	int changed;

	if (!sc->sc_enabled)
		/* Interrupts are not expected. */
		return 0;

	bus_space_write_1(iot, ioh, LMS_CNTRL, 0xab);
	hi = bus_space_read_1(iot, ioh, LMS_DATA);
	bus_space_write_1(iot, ioh, LMS_CNTRL, 0x90);
	lo = bus_space_read_1(iot, ioh, LMS_DATA);
	dx = ((hi & 0x0f) << 4) | (lo & 0x0f);
	/* Bounding at -127 avoids a bug in XFree86. */
	dx = (dx == -128) ? -127 : dx;

	bus_space_write_1(iot, ioh, LMS_CNTRL, 0xf0);
	hi = bus_space_read_1(iot, ioh, LMS_DATA);
	bus_space_write_1(iot, ioh, LMS_CNTRL, 0xd0);
	lo = bus_space_read_1(iot, ioh, LMS_DATA);
	dy = ((hi & 0x0f) << 4) | (lo & 0x0f);
	dy = (dy == -128) ? 127 : -dy;

	bus_space_write_1(iot, ioh, LMS_CNTRL, 0);

	buttons = ((hi & 0x80) ? 0 : 0x1) |
		((hi & 0x40) ? 0 : 0x2) |
		((hi & 0x20) ? 0 : 0x4);
	changed = (buttons ^ sc->oldbuttons);
	sc->oldbuttons = buttons;

	if (dx || dy || changed)
		WSMOUSE_INPUT(sc->sc_wsmousedev, buttons, dx, dy, 0, 0);

	return -1;
}

struct cfdriver lms_cd = {
	NULL, "lms", DV_DULL
};
@


1.20
log
@Add support for a fourth axis on wsmouse devices, e.g. on the Apple Might
Mouse.  Currently limited to USB mice.

Adapted from a diff from Gareth <garf@@loveandnature.co.za> on tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lms.c,v 1.19 2006/09/19 11:06:34 jsg Exp $	*/
d238 1
a238 2
		wsmouse_input(sc->sc_wsmousedev,
			      buttons, dx, dy, 0, 0, WSMOUSE_INPUT_DELTA);
@


1.19
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: lms.c,v 1.18 2002/03/14 01:26:33 millert Exp $	*/
d239 1
a239 1
			      buttons, dx, dy, 0, WSMOUSE_INPUT_DELTA);
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: lms.c,v 1.17 2001/08/07 19:24:27 jason Exp $	*/
d79 1
a79 4
lmsprobe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d121 1
a121 3
lmsattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d157 1
a157 2
lms_enable(v)
	void *v;
d174 1
a174 2
lms_disable(v)
	void *v;
d185 1
a185 6
lms_ioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d200 1
a200 2
lmsintr(arg)
	void *arg;
@


1.17
log
@tag fixes; Denis Afonin <dfa@@solo.ee>
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 3
a62 3
int lmsprobe __P((struct device *, void *, void *));
void lmsattach __P((struct device *, struct device *, void *));
int lmsintr __P((void *));
d68 3
a70 3
int	lms_enable __P((void *));
int	lms_ioctl __P((void *, u_long, caddr_t, int, struct proc *));
void	lms_disable __P((void *));
@


1.17.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: lms.c,v 1.17 2001/08/07 19:24:27 jason Exp $	*/
d60 3
a62 3
int lmsprobe(struct device *, void *, void *);
void lmsattach(struct device *, struct device *, void *);
int lmsintr(void *);
d68 3
a70 3
int	lms_enable(void *);
int	lms_ioctl(void *, u_long, caddr_t, int, struct proc *);
void	lms_disable(void *);
@


1.16
log
@Import of wsmouse-compatible lms and mms drivers from NetBSD.
Remove creation of non-wsmouse device in MAKEDEV (/dev/lms{0,1}, /dev/mms{0,1}
/dev/psm0, /dev/pms0).
Remove cdevsw[] entries for the devices above, as new mouse protocols are only
accessible trough /dev/wsmouse. aaron@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD */
@


1.15
log
@Remove old (non wsmouse) lms and mms drivers. Remove the commented olms and
omms entries in GENERIC. aaron@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: lms.c,v 1.14 2000/05/16 18:12:14 mickey Exp $	*/
/*	$NetBSD: lms.c,v 1.30 1996/10/21 22:27:41 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1993, 1994 Charles Hannum.
a27 1
#include <sys/kernel.h>
a28 2
#include <sys/buf.h>
#include <sys/malloc.h>
a29 6
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/select.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/vnode.h>
a31 1
#include <machine/cpu.h>
a33 2
#include <machine/mouse.h>
#include <machine/conf.h>
d36 3
a38 1
#include <dev/rndvar.h>
a46 3
#define	LMS_CHUNK	128	/* chunk size for read */
#define	LMS_BSIZE	1020	/* buffer size */

d54 4
a57 9
	struct clist sc_q;
	struct selinfo sc_rsel;
	struct proc *sc_io;	/* process that opened lms (can get SIGIO) */
	char sc_async;		/* send SIGIO on input ready */
	u_char sc_state;	/* mouse driver state */
#define	LMS_OPEN	0x01	/* device is open */
#define	LMS_ASLP	0x02	/* waiting for mouse data */
	u_char sc_status;	/* mouse button status */
	int sc_x, sc_y;		/* accumulated motion in the X,Y axis */
d68 8
a75 2
struct cfdriver lms_cd = {
	NULL, "lms", DV_TTY
a77 2
#define	LMSUNIT(dev)	(minor(dev))

d81 2
a82 1
	void *match, *aux;
d89 4
d130 3
d136 5
d142 3
a144 4
	sc->sc_iot = ia->ia_iot;
	if (bus_space_map(sc->sc_iot, ia->ia_iobase, LMS_NPORTS, 0,
	    &sc->sc_ioh))
		panic("lmsattach: couldn't map I/O ports");
d148 11
d162 2
a163 5
lmsopen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d165 1
a165 2
	int unit = LMSUNIT(dev);
	struct lms_softc *sc;
d167 1
a167 7
	if (unit >= lms_cd.cd_ndevs)
		return ENXIO;
	sc = lms_cd.cd_devs[unit];
	if (!sc)
		return ENXIO;

	if (sc->sc_state & LMS_OPEN)
d170 2
a171 8
	if (clalloc(&sc->sc_q, LMS_BSIZE, 0) == -1)
		return ENOMEM;

	sc->sc_state |= LMS_OPEN;
	sc->sc_status = 0;
	sc->sc_x = sc->sc_y = 0;
	sc->sc_async = 0;
	sc->sc_io = p;
d179 3
a181 6
int
lmsclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d183 1
a183 1
	struct lms_softc *sc = lms_cd.cd_devs[LMSUNIT(dev)];
d188 1
a188 54
	sc->sc_state &= ~LMS_OPEN;
	sc->sc_io = NULL;

	clfree(&sc->sc_q);

	return 0;
}

int
lmsread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct lms_softc *sc = lms_cd.cd_devs[LMSUNIT(dev)];
	int s;
	int error = 0;
	size_t length;
	u_char buffer[LMS_CHUNK];

	/* Block until mouse activity occured. */

	s = spltty();
	while (sc->sc_q.c_cc == 0) {
		if (flag & IO_NDELAY) {
			splx(s);
			return EWOULDBLOCK;
		}
		sc->sc_state |= LMS_ASLP;
		error = tsleep((caddr_t)sc, PZERO | PCATCH, "lmsrea", 0);
		if (error) {
			sc->sc_state &= ~LMS_ASLP;
			splx(s);
			return error;
		}
	}
	splx(s);

	/* Transfer as many chunks as possible. */

	while (sc->sc_q.c_cc > 0 && uio->uio_resid > 0) {
		length = min(sc->sc_q.c_cc, uio->uio_resid);
		if (length > sizeof(buffer))
			length = sizeof(buffer);

		/* Remove a small chunk from the input queue. */
		(void) q_to_b(&sc->sc_q, buffer, length);

		/* Copy the data to the user process. */
		if ((error = uiomove(buffer, length, uio)) != 0)
			break;
	}

	return error;
d192 2
a193 2
lmsioctl(dev, cmd, addr, flag, p)
	dev_t dev;
d195 1
a195 1
	caddr_t addr;
d199 3
a201 4
	struct lms_softc *sc = lms_cd.cd_devs[LMSUNIT(dev)];
	struct mouseinfo info;
	int s;
	int error;
d204 2
a205 1
	case FIONBIO:		/* we will remove this someday (soon???) */
a206 51
		
	case FIOASYNC:
		sc->sc_async = *(int *)addr != 0;
		break;
		
	case TIOCSPGRP:
		if (*(int *)addr != sc->sc_io->p_pgid)
			return (EPERM);
		break;
		
	case MOUSEIOCREAD:
		s = spltty();

		info.status = sc->sc_status;
		if (sc->sc_x || sc->sc_y)
			info.status |= MOVEMENT;

		if (sc->sc_x > 127)
			info.xmotion = 127;
		else if (sc->sc_x < -127)
			/* Bounding at -127 avoids a bug in XFree86. */
			info.xmotion = -127;
		else
			info.xmotion = sc->sc_x;

		if (sc->sc_y > 127)
			info.ymotion = 127;
		else if (sc->sc_y < -127)
			info.ymotion = -127;
		else
			info.ymotion = sc->sc_y;

		/* Reset historical information. */
		sc->sc_x = sc->sc_y = 0;
		sc->sc_status &= ~BUTCHNGMASK;
		ndflush(&sc->sc_q, sc->sc_q.c_cc);

		splx(s);
		error = copyout(&info, addr, sizeof(struct mouseinfo));
		break;

	case MOUSEIOCSRAW:
		error = ENODEV;
		break;

	case MOUSEIOCSCOOKED:	/* Do nothing. */
		break;

	default:
		error = EINVAL;
		break;
d208 1
a208 2

	return error;
d218 4
a221 3
	u_char hi, lo, buttons, changed;
	char dx, dy;
	u_char buffer[5];
d223 1
a223 1
	if ((sc->sc_state & LMS_OPEN) == 0)
d244 9
a252 27
	buttons = (~hi >> 5) & 0x07;
	changed = ((buttons ^ sc->sc_status) & 0x07) << 3;
	sc->sc_status = buttons | (sc->sc_status & ~BUTSTATMASK) | changed;

	if (dx || dy || changed) {
		/* Update accumulated movements. */
		sc->sc_x += dx;
		sc->sc_y += dy;

		/* Add this event to the queue. */
		buffer[0] = 0x80 | (buttons ^ BUTSTATMASK);
		buffer[1] = dx;
		buffer[2] = dy;
		buffer[3] = buffer[4] = 0;
		(void) b_to_q(buffer, sizeof buffer, &sc->sc_q);
		add_mouse_randomness(*(u_int32_t*)buffer);

		if (sc->sc_state & LMS_ASLP) {
			sc->sc_state &= ~LMS_ASLP;
			wakeup((caddr_t)sc);
		}
		selwakeup(&sc->sc_rsel);
		if (sc->sc_async) {
			psignal(sc->sc_io, SIGIO); 
		}

	}
d257 3
a259 23
int
lmsselect(dev, rw, p)
	dev_t dev;
	int rw;
	struct proc *p;
{
	struct lms_softc *sc = lms_cd.cd_devs[LMSUNIT(dev)];
	int s;
	int ret;

	if (rw == FWRITE)
		return 0;

	s = spltty();
	if (!sc->sc_q.c_cc) {
		selrecord(p, &sc->sc_rsel);
		ret = 0;
	} else
		ret = 1;
	splx(s);

	return ret;
}
@


1.14
log
@supply entropy from mouse; provos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lms.c,v 1.13 1999/11/22 07:25:38 matthieu Exp $	*/
@


1.13
log
@add support for asynchronous I/O (through SIGIO)
@
text
@d1 1
a1 1
/*	$OpenBSD: lms.c,v 1.12 1999/08/22 08:16:20 downsj Exp $	*/
d48 1
d373 1
@


1.13.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 2
a2 2
/* $OpenBSD */
/*	$NetBSD: lms.c,v 1.38 2000/01/08 02:57:25 takemura Exp $	*/
d5 1
a5 1
 * Copyright (c) 1993, 1994 Charles M. Hannum.
d28 1
d30 2
d33 6
d41 1
d44 2
a48 3
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsmousevar.h>

d56 3
d66 9
a74 4
	int sc_enabled; /* device is open */
	int oldbuttons;	/* mouse button status */

	struct device *sc_wsmousedev;
d85 2
a86 8
int	lms_enable __P((void *));
int	lms_ioctl __P((void *, u_long, caddr_t, int, struct proc *));
void	lms_disable __P((void *));

const struct wsmouse_accessops lms_accessops = {
	lms_enable,
	lms_ioctl,
	lms_disable,
d89 2
d94 1
a94 2
	void *match;
	void *aux;
a100 4
	/* Disallow wildcarded i/o base. */
	if (ia->ia_iobase == IOBASEUNK)
		return 0;

a137 3
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh;
	struct wsmousedev_attach_args a;
a140 5
	if (bus_space_map(iot, ia->ia_iobase, LMS_NPORTS, 0, &ioh)) {
		printf("%s: can't map i/o space\n", sc->sc_dev.dv_xname);
		return;
	}

d142 4
a145 3
	sc->sc_iot = iot;
	sc->sc_ioh = ioh;
	sc->sc_enabled = 0;
a148 11

	a.accessops = &lms_accessops;
	a.accesscookie = sc;

	/*
	 * Attach the wsmouse, saving a handle to it.
	 * Note that we don't need to check this pointer against NULL
	 * here or in psmintr, because if this fails lms_enable() will
	 * never be called, so lmsintr() will never be called.
	 */
	sc->sc_wsmousedev = config_found(self, &a, wsmousedevprint);
d152 5
a156 2
lms_enable(v)
	void *v;
d158 2
a159 1
	struct lms_softc *sc = v;
d161 7
a167 1
	if (sc->sc_enabled)
d170 8
a177 2
	sc->sc_enabled = 1;
	sc->oldbuttons = 0;
d185 6
a190 3
void
lms_disable(v)
	void *v;
d192 1
a192 1
	struct lms_softc *sc = v;
d197 54
a250 1
	sc->sc_enabled = 0;
d254 2
a255 2
lms_ioctl(v, cmd, data, flag, p)
	void *v;
d257 1
a257 1
	caddr_t data;
d261 4
a264 3
#if 0
	struct lms_softc *sc = v;
#endif
d267 1
a267 2
	case WSMOUSEIO_GTYPE:
		*(u_int *)data = WSMOUSE_TYPE_LMS;
d269 51
d321 2
a322 1
	return (-1);
d332 3
a334 4
	u_char hi, lo;
	signed char dx, dy;
	u_int buttons;
	int changed;
d336 1
a336 1
	if (!sc->sc_enabled)
d357 26
a382 9
	buttons = ((hi & 0x80) ? 0 : 0x1) |
		((hi & 0x40) ? 0 : 0x2) |
		((hi & 0x20) ? 0 : 0x4);
	changed = (buttons ^ sc->oldbuttons);
	sc->oldbuttons = buttons;

	if (dx || dy || changed)
		wsmouse_input(sc->sc_wsmousedev,
			      buttons, dx, dy, 0, WSMOUSE_INPUT_DELTA);
d387 23
a409 3
struct cfdriver lms_cd = {
	NULL, "lms", DV_DULL
};
@


1.13.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.13.2.3
log
@Merge in -current from about a week ago
@
text
@d60 3
a62 3
int lmsprobe(struct device *, void *, void *);
void lmsattach(struct device *, struct device *, void *);
int lmsintr(void *);
d68 3
a70 3
int	lms_enable(void *);
int	lms_ioctl(void *, u_long, caddr_t, int, struct proc *);
void	lms_disable(void *);
@


1.12
log
@Add noop MOUSEIOCSCOOKED and ENODEV MOUSEIOCSRAW ioctls, as suggested by
Matthieu Herrb.
@
text
@d1 1
a1 1
/*	$OpenBSD: lms.c,v 1.11 1999/01/13 07:26:01 niklas Exp $	*/
d37 1
d68 2
d176 2
d198 1
d267 12
d378 4
@


1.11
log
@RCSIds
@
text
@d1 1
a1 1
/*	$OpenBSD: lms.c,v 1.30 1996/10/21 22:27:41 thorpej Exp $	*/
d290 7
@


1.10
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
@


1.9
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$NetBSD: lms.c,v 1.26 1996/05/12 23:12:11 mycroft Exp $	*/
d40 1
a40 1
#include <machine/bus.old.h>
d61 2
a62 2
	bus_chipset_tag_t sc_bc;	/* bus chipset identifier */
	bus_io_handle_t sc_ioh;		/* bus i/o handle */
d93 2
a94 2
	bus_chipset_tag_t bc = ia->ia_bc;
	bus_io_handle_t ioh;
d98 1
a98 1
	if (bus_io_map(bc, ia->ia_iobase, LMS_NPORTS, &ioh))
d104 1
a104 1
	bus_io_write_1(bc, ioh, LMS_CONFIG, 0x91);
d106 1
a106 1
	bus_io_write_1(bc, ioh, LMS_SIGN, 0x0c);
d108 1
a108 1
	if (bus_io_read_1(bc, ioh, LMS_SIGN) != 0x0c)
d110 1
a110 1
	bus_io_write_1(bc, ioh, LMS_SIGN, 0x50);
d112 1
a112 1
	if (bus_io_read_1(bc, ioh, LMS_SIGN) != 0x50)
d116 1
a116 1
	bus_io_write_1(bc, ioh, LMS_CNTRL, 0x10);
d123 1
a123 1
	bus_io_unmap(bc, ioh, LMS_NPORTS);
d138 3
a140 2
	sc->sc_bc = ia->ia_bc;
	if (bus_io_map(sc->sc_bc, ia->ia_iobase, LMS_NPORTS, &sc->sc_ioh))
d174 1
a174 1
	bus_io_write_1(sc->sc_bc, sc->sc_ioh, LMS_CNTRL, 0);
d189 1
a189 1
	bus_io_write_1(sc->sc_bc, sc->sc_ioh, LMS_CNTRL, 0x10);
d304 2
a305 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d314 4
a317 4
	bus_io_write_1(bc, ioh, LMS_CNTRL, 0xab);
	hi = bus_io_read_1(bc, ioh, LMS_DATA);
	bus_io_write_1(bc, ioh, LMS_CNTRL, 0x90);
	lo = bus_io_read_1(bc, ioh, LMS_DATA);
d322 4
a325 4
	bus_io_write_1(bc, ioh, LMS_CNTRL, 0xf0);
	hi = bus_io_read_1(bc, ioh, LMS_DATA);
	bus_io_write_1(bc, ioh, LMS_CNTRL, 0xd0);
	lo = bus_io_read_1(bc, ioh, LMS_DATA);
d329 1
a329 1
	bus_io_write_1(bc, ioh, LMS_CNTRL, 0);
@


1.8
log
@sync
@
text
@d40 1
a40 1
#include <machine/bus.h>
@


1.7
log
@sync with 0504; prototype changes
@
text
@d1 1
a1 1
/*	$NetBSD: lms.c,v 1.25 1996/05/03 20:12:01 christos Exp $	*/
d41 1
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$NetBSD: lms.c,v 1.24 1996/04/11 22:15:18 cgd Exp $	*/
d42 1
a132 1
	int iobase = ia->ia_iobase;
d146 1
a146 1
lmsopen(dev, flag)
d149 2
d178 1
a178 1
lmsclose(dev, flag)
d181 2
d204 1
a204 1
	int error;
d217 2
a218 1
		if (error = tsleep((caddr_t)sc, PZERO | PCATCH, "lmsrea", 0)) {
d237 1
a237 1
		if (error = uiomove(buffer, length, uio))
d245 1
a245 1
lmsioctl(dev, cmd, addr, flag)
d250 1
@


1.5
log
@Fix back wrong patches.
@
text
@d1 1
a1 1
/*	$NetBSD: lms.c,v 1.21 1995/12/24 02:30:17 mycroft Exp $	*/
d40 1
a40 1
#include <machine/pio.h>
d59 3
a63 1
	int sc_iobase;		/* I/O port base */
d75 6
a80 2
struct cfdriver lmscd = {
	NULL, "lms", lmsprobe, lmsattach, DV_TTY, sizeof(struct lms_softc)
d91 9
a99 1
	int iobase = ia->ia_iobase;
d102 1
a102 1
	outb(iobase + LMS_CONFIG, 0x91);
d104 1
a104 1
	outb(iobase + LMS_SIGN, 0x0c);
d106 3
a108 3
	if (inb(iobase + LMS_SIGN) != 0x0c)
		return 0;
	outb(iobase + LMS_SIGN, 0x50);
d110 2
a111 2
	if (inb(iobase + LMS_SIGN) != 0x50)
		return 0;
d114 1
a114 1
	outb(iobase + LMS_CNTRL, 0x10);
d116 1
d119 4
a122 1
	return 1;
d137 3
a139 2
	sc->sc_iobase = iobase;
	sc->sc_state = 0;
d141 2
a142 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, IST_PULSE, IPL_TTY, lmsintr,
	    sc, sc->sc_dev.dv_xname);
d153 1
a153 1
	if (unit >= lmscd.cd_ndevs)
d155 1
a155 1
	sc = lmscd.cd_devs[unit];
d170 1
a170 1
	outb(sc->sc_iobase + LMS_CNTRL, 0);
d180 1
a180 1
	struct lms_softc *sc = lmscd.cd_devs[LMSUNIT(dev)];
d183 1
a183 1
	outb(sc->sc_iobase + LMS_CNTRL, 0x10);
d198 1
a198 1
	struct lms_softc *sc = lmscd.cd_devs[LMSUNIT(dev)];
d246 1
a246 1
	struct lms_softc *sc = lmscd.cd_devs[LMSUNIT(dev)];
d296 2
a297 1
	int iobase = sc->sc_iobase;
d306 4
a309 4
	outb(iobase + LMS_CNTRL, 0xab);
	hi = inb(iobase + LMS_DATA);
	outb(iobase + LMS_CNTRL, 0x90);
	lo = inb(iobase + LMS_DATA);
d314 4
a317 4
	outb(iobase + LMS_CNTRL, 0xf0);
	hi = inb(iobase + LMS_DATA);
	outb(iobase + LMS_CNTRL, 0xd0);
	lo = inb(iobase + LMS_DATA);
d321 1
a321 1
	outb(iobase + LMS_CNTRL, 0);
d355 1
a355 1
	struct lms_softc *sc = lmscd.cd_devs[LMSUNIT(dev)];
@


1.4
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d123 1
a123 1
	    sc);
@


1.3
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 1
a1 1
/*	$NetBSD: lms.c,v 1.20 1995/10/05 22:06:47 mycroft Exp $	*/
d123 1
a123 1
	    sc, sc->sc_dev.dv_xname);
@


1.2
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
@
text
@d123 1
a123 1
	    sc);
@


1.1
log
@Initial revision
@
text
@d122 2
a123 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_PULSE, ISA_IPL_TTY,
	    lmsintr, sc);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
