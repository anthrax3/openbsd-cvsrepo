head	1.61;
access;
symbols
	OPENBSD_6_1:1.61.0.12
	OPENBSD_6_1_BASE:1.61
	OPENBSD_6_0:1.61.0.8
	OPENBSD_6_0_BASE:1.61
	OPENBSD_5_9:1.61.0.4
	OPENBSD_5_9_BASE:1.61
	OPENBSD_5_8:1.61.0.6
	OPENBSD_5_8_BASE:1.61
	OPENBSD_5_7:1.61.0.2
	OPENBSD_5_7_BASE:1.61
	OPENBSD_5_6:1.60.0.4
	OPENBSD_5_6_BASE:1.60
	OPENBSD_5_5:1.59.0.4
	OPENBSD_5_5_BASE:1.59
	OPENBSD_5_4:1.58.0.2
	OPENBSD_5_4_BASE:1.58
	OPENBSD_5_3:1.57.0.8
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.57.0.6
	OPENBSD_5_2_BASE:1.57
	OPENBSD_5_1_BASE:1.57
	OPENBSD_5_1:1.57.0.4
	OPENBSD_5_0:1.57.0.2
	OPENBSD_5_0_BASE:1.57
	OPENBSD_4_9:1.53.0.2
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.51.0.2
	OPENBSD_4_8_BASE:1.51
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.44.0.6
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.44.0.2
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.43.0.4
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.43.0.2
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.42.0.4
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.40.0.2
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.37.0.4
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.37.0.2
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.35.0.2
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.34.0.2
	OPENBSD_3_6_BASE:1.34
	SMP_SYNC_A:1.31
	SMP_SYNC_B:1.31
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.26
	OPENBSD_3_3:1.25.0.6
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.4
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	UBC_SYNC_B:1.25
	UBC:1.23.0.2
	UBC_BASE:1.23
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.16.0.8
	OPENBSD_2_7_BASE:1.16
	SMP:1.16.0.6
	SMP_BASE:1.16
	kame_19991208:1.16
	OPENBSD_2_6:1.16.0.4
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.16.0.2
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.15.0.4
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.14.0.4
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.61
date	2015.02.11.05.54.48;	author dlg;	state Exp;
branches;
next	1.60;
commitid	fAl1KR17j4jH74Xf;

1.60
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.59;

1.59
date	2013.11.16.21.00.02;	author brad;	state Exp;
branches;
next	1.58;

1.58
date	2013.05.08.15.36.30;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.56;

1.56
date	2011.07.07.18.11.24;	author art;	state Exp;
branches;
next	1.55;

1.55
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.54;

1.54
date	2011.03.20.21.44.08;	author guenther;	state Exp;
branches;
next	1.53;

1.53
date	2010.09.29.15.11.31;	author joshe;	state Exp;
branches;
next	1.52;

1.52
date	2010.09.29.13.46.38;	author joshe;	state Exp;
branches;
next	1.51;

1.51
date	2010.07.23.15.10.16;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2010.07.23.14.56.31;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2010.07.21.14.08.09;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2010.06.29.21.13.43;	author thib;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.28.21.12.18;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2009.10.26.20.30.23;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.03.21.51.01;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2008.12.04.15.48.19;	author weingart;	state Exp;
branches
	1.44.2.1
	1.44.6.1;
next	1.43;

1.43
date	2007.11.28.17.05.09;	author tedu;	state Exp;
branches
	1.43.4.1;
next	1.42;

1.42
date	2006.10.18.19.48.32;	author tom;	state Exp;
branches;
next	1.41;

1.41
date	2006.09.19.11.06.34;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2006.07.25.19.16.51;	author kettenis;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2006.04.19.15.48.17;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.13.18.42.16;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2005.06.06.14.25.20;	author mickey;	state Exp;
branches
	1.37.2.1
	1.37.4.1;
next	1.36;

1.36
date	2005.04.21.04.39.35;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2004.10.21.20.58.07;	author kettenis;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2004.07.21.18.39.58;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.13.20.43.13;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.13.21.49.16;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	2004.02.01.19.05.21;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.31.19.17.41;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.24.09.03.20;	author grange;	state Exp;
branches;
next	1.28;

1.28
date	2003.07.25.18.31.25;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.02.23.27.47;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.17.03.42.14;	author drahn;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.18.07.58.39;	author ericj;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.04.00.00.36;	author niklas;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2001.11.18.20.46.49;	author aaron;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.12.20.28.20;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.06.19.53.14;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.05.23.25.51;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.09.07.14.16;	author tholo;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.08.22.25.19;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	99.02.26.04.20.40;	author art;	state Exp;
branches
	1.16.6.1;
next	1.15;

1.15
date	98.02.22.22.06.11;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	97.04.17.03.44.52;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	97.02.08.23.36.58;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	97.02.01.21.53.57;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.01.27.22.48.09;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.08.27.10.46.55;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	96.05.25.22.17.51;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.07.07.22.21;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.17.00;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.03.20.00.31.06;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.03.19.21.09.38;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.02.20.04.35.33;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.01.07.14.35.01;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.10.41;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.38;	author deraadt;	state Exp;
branches;
next	;

1.16.6.1
date	2001.04.18.16.07.53;	author niklas;	state Exp;
branches;
next	1.16.6.2;

1.16.6.2
date	2001.07.04.10.16.55;	author niklas;	state Exp;
branches;
next	1.16.6.3;

1.16.6.3
date	2001.07.14.10.02.44;	author ho;	state Exp;
branches;
next	1.16.6.4;

1.16.6.4
date	2001.11.13.21.00.52;	author niklas;	state Exp;
branches;
next	1.16.6.5;

1.16.6.5
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.16.6.6;

1.16.6.6
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.16.6.7;

1.16.6.7
date	2002.03.28.10.31.04;	author niklas;	state Exp;
branches;
next	1.16.6.8;

1.16.6.8
date	2003.05.13.19.42.08;	author ho;	state Exp;
branches;
next	1.16.6.9;

1.16.6.9
date	2003.06.07.11.11.37;	author ho;	state Exp;
branches;
next	1.16.6.10;

1.16.6.10
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	1.16.6.11;

1.16.6.11
date	2004.02.20.22.19.55;	author niklas;	state Exp;
branches;
next	1.16.6.12;

1.16.6.12
date	2004.03.23.08.02.56;	author niklas;	state Exp;
branches;
next	1.16.6.13;

1.16.6.13
date	2004.04.06.13.32.29;	author niklas;	state Exp;
branches;
next	;

1.23.2.1
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2003.05.19.21.45.11;	author tedu;	state Exp;
branches;
next	;

1.35.2.1
date	2006.05.02.04.08.54;	author brad;	state Exp;
branches;
next	;

1.37.2.1
date	2006.05.02.04.07.27;	author brad;	state Exp;
branches;
next	;

1.37.4.1
date	2006.05.02.04.05.33;	author brad;	state Exp;
branches;
next	;

1.40.2.1
date	2006.11.15.03.06.15;	author brad;	state Exp;
branches;
next	;

1.43.4.1
date	2009.10.05.00.36.05;	author sthen;	state Exp;
branches;
next	;

1.44.2.1
date	2009.10.05.00.36.33;	author sthen;	state Exp;
branches;
next	;

1.44.6.1
date	2009.10.05.00.37.54;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.61
log
@deprecate use of sys/lock.h and replace it with sys/atomic.h or
machine/lock.h as appropriate.
@
text
@/*	$OpenBSD: npx.c,v 1.60 2014/03/29 18:09:29 guenther Exp $	*/
/*	$NetBSD: npx.c,v 1.57 1996/05/12 23:12:24 mycroft Exp $	*/

#if 0
#define IPRINTF(x)	printf x
#else
#define	IPRINTF(x)
#endif

/*-
 * Copyright (c) 1994, 1995 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1990 William Jolitz.
 * Copyright (c) 1991 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)npx.c	7.2 (Berkeley) 5/12/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/user.h>
#include <sys/ioctl.h>
#include <sys/device.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/npx.h>
#include <machine/pio.h>
#include <machine/cpufunc.h>
#include <machine/pcb.h>
#include <machine/trap.h>
#include <machine/specialreg.h>
#include <machine/i8259.h>
#include <machine/lock.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>

/*
 * 387 and 287 Numeric Coprocessor Extension (NPX) Driver.
 *
 * We do lazy initialization and switching using the TS bit in cr0 and the
 * MDP_USEDFPU bit in mdproc.
 *
 * DNA exceptions are handled like this:
 *
 * 1) If there is no NPX, return and go to the emulator.
 * 2) If someone else has used the NPX, save its state into that process's PCB.
 * 3a) If MDP_USEDFPU is not set, set it and initialize the NPX.
 * 3b) Otherwise, reload the process's previous NPX state.
 *
 * When a process is created or exec()s, its saved cr0 image has the TS bit
 * set and the MDP_USEDFPU bit clear.  The MDP_USEDFPU bit is set when the
 * process first gets a DNA and the NPX is initialized.  The TS bit is turned
 * off when the NPX is used, and turned on again later when the process's NPX
 * state is saved.
 */

#define	fldcw(addr)		__asm("fldcw %0" : : "m" (*addr))
#define	fnclex()		__asm("fnclex")
#define	fninit()		__asm("fninit")
#define	fnsave(addr)		__asm("fnsave %0" : "=m" (*addr))
#define	fnstcw(addr)		__asm("fnstcw %0" : "=m" (*addr))
#define	fnstsw(addr)		__asm("fnstsw %0" : "=m" (*addr))
#define	fp_divide_by_0()	__asm("fldz; fld1; fdiv %st,%st(1); fwait")
#define	frstor(addr)		__asm("frstor %0" : : "m" (*addr))
#define	fwait()			__asm("fwait")
#define	clts()			__asm("clts")
#define	stts()			lcr0(rcr0() | CR0_TS)

/*
 * The mxcsr_mask for this host, taken from fxsave() on the primary CPU
 */
uint32_t	fpu_mxcsr_mask;

int npxintr(void *);
static int npxprobe1(struct isa_attach_args *);
static int x86fpflags_to_siginfo(u_int32_t);


struct npx_softc {
	struct device sc_dev;
	void *sc_ih;
};

int npxprobe(struct device *, void *, void *);
void npxattach(struct device *, struct device *, void *);

struct cfattach npx_ca = {
	sizeof(struct npx_softc), npxprobe, npxattach
};

struct cfdriver npx_cd = {
	NULL, "npx", DV_DULL
};

enum npx_type {
	NPX_NONE = 0,
	NPX_INTERRUPT,
	NPX_EXCEPTION,
	NPX_BROKEN,
	NPX_CPUID,
};

static	enum npx_type		npx_type;
static	volatile u_int		npx_intrs_while_probing;
static	volatile u_int		npx_traps_while_probing;

extern int i386_fpu_present;
extern int i386_fpu_exception;
extern int i386_fpu_fdivbug;

#define fxsave(addr)		__asm("fxsave %0" : "=m" (*addr))
#define fxrstor(addr)		__asm("fxrstor %0" : : "m" (*addr))
#define ldmxcsr(addr)		__asm("ldmxcsr %0" : : "m" (*addr))

static __inline void
fpu_save(union savefpu *addr)
{

	if (i386_use_fxsave) {
		fxsave(&addr->sv_xmm);
		/* FXSAVE doesn't FNINIT like FNSAVE does -- so do it here. */
		fninit();
	} else
		fnsave(&addr->sv_87);
}

static int
npxdna_notset(struct cpu_info *ci)
{
	panic("npxdna vector not initialized");
}

int    (*npxdna_func)(struct cpu_info *) = npxdna_notset;
int    npxdna_s87(struct cpu_info *);
int    npxdna_xmm(struct cpu_info *);
void   npxexit(void);

/*
 * Special interrupt handlers.  Someday intr0-intr15 will be used to count
 * interrupts.  We'll still need a special exception 16 handler.  The busy
 * latch stuff in probintr() can be moved to npxprobe().
 */
void probeintr(void);
asm (".text\n\t"
"probeintr:\n\t"
	"ss\n\t"
	"incl	npx_intrs_while_probing\n\t"
	"pushl	%eax\n\t"
	"movb	$0x20,%al	# EOI (asm in strings loses cpp features)\n\t"
	"outb	%al,$0xa0	# IO_ICU2\n\t"
	"outb	%al,$0x20	# IO_ICU1\n\t"
	"movb	$0,%al\n\t"
	"outb	%al,$0xf0	# clear BUSY# latch\n\t"
	"popl	%eax\n\t"
	"iret\n\t");

void probetrap(void);
asm (".text\n\t"
"probetrap:\n\t"
	"ss\n\t"
	"incl	npx_traps_while_probing\n\t"
	"fnclex\n\t"
	"iret\n\t");

static inline int
npxprobe1(struct isa_attach_args *ia)
{
	int control;
	int status;

	ia->ia_iosize = 16;
	ia->ia_msize = 0;

	/*
	 * Finish resetting the coprocessor, if any.  If there is an error
	 * pending, then we may get a bogus IRQ13, but probeintr() will handle
	 * it OK.  Bogus halts have never been observed, but we enabled
	 * IRQ13 and cleared the BUSY# latch early to handle them anyway.
	 */
	fninit();
	delay(1000);		/* wait for any IRQ13 (fwait might hang) */

	/*
	 * Check for a status of mostly zero.
	 */
	status = 0x5a5a;
	fnstsw(&status);
	if ((status & 0xb8ff) == 0) {
		/*
		 * Good, now check for a proper control word.
		 */
		control = 0x5a5a;	
		fnstcw(&control);
		if ((control & 0x1f3f) == 0x033f) {
			/*
			 * We have an npx, now divide by 0 to see if exception
			 * 16 works.
			 */
			control &= ~(1 << 2);	/* enable divide by 0 trap */
			fldcw(&control);
			npx_traps_while_probing = npx_intrs_while_probing = 0;
			fp_divide_by_0();
			delay(1);
			if (npx_traps_while_probing != 0) {
				/*
				 * Good, exception 16 works.
				 */
				npx_type = NPX_EXCEPTION;
				ia->ia_irq = IRQUNK;	/* zap the interrupt */
				i386_fpu_exception = 1;
			} else if (npx_intrs_while_probing != 0) {
				/*
				 * Bad, we are stuck with IRQ13.
				 */
				npx_type = NPX_INTERRUPT;
			} else {
				/*
				 * Worse, even IRQ13 is broken.
				 */
				npx_type = NPX_BROKEN;
				ia->ia_irq = IRQUNK;
			}
			return 1;
		}
	}

	/*
	 * Probe failed.  There is no usable FPU.
	 */
	npx_type = NPX_NONE;
	return 0;
}

/*
 * Probe routine.  Initialize cr0 to give correct behaviour for [f]wait
 * whether the device exists or not (XXX should be elsewhere).  Set flags
 * to tell npxattach() what to do.  Modify device struct if npx doesn't
 * need to use interrupts.  Return 1 if device exists.
 */
int
npxprobe(struct device *parent, void *match, void *aux)
{
	struct	isa_attach_args *ia = aux;
	int	irq;
	int	result;
	u_long	save_eflags;
	unsigned save_imen;
	struct	gate_descriptor save_idt_npxintr;
	struct	gate_descriptor save_idt_npxtrap;

	if (cpu_feature & CPUID_FPU) {
		npx_type = NPX_CPUID;
		i386_fpu_exception = 1;
		ia->ia_irq = IRQUNK;	/* Don't want the interrupt vector */
		ia->ia_iosize = 16;
		ia->ia_msize = 0;
		return 1;
	}

	/*
	 * This routine is now just a wrapper for npxprobe1(), to install
	 * special npx interrupt and trap handlers, to enable npx interrupts
	 * and to disable other interrupts.  Someday isa_configure() will
	 * install suitable handlers and run with interrupts enabled so we
	 * won't need to do so much here.
	 */
	irq = NRSVIDT + ia->ia_irq;
	save_eflags = read_eflags();
	disable_intr();
	save_idt_npxintr = idt[irq];
	save_idt_npxtrap = idt[16];
	setgate(&idt[irq], probeintr, 0, SDT_SYS386IGT, SEL_KPL, GICODE_SEL);
	setgate(&idt[16], probetrap, 0, SDT_SYS386TGT, SEL_KPL, GCODE_SEL);
	save_imen = imen;
	imen = ~((1 << IRQ_SLAVE) | (1 << ia->ia_irq));
	SET_ICUS();

	/*
	 * Partially reset the coprocessor, if any.  Some BIOS's don't reset
	 * it after a warm boot.
	 */
	outb(0xf1, 0);		/* full reset on some systems, NOP on others */
	delay(1000);
	outb(0xf0, 0);		/* clear BUSY# latch */

	/*
	 * We set CR0 in locore to trap all ESC and WAIT instructions.
	 * We have to turn off the CR0_EM bit temporarily while probing.
	 */
	lcr0(rcr0() & ~(CR0_EM|CR0_TS));
	enable_intr();
	result = npxprobe1(ia);
	disable_intr();
	lcr0(rcr0() | (CR0_EM|CR0_TS));

	imen = save_imen;
	SET_ICUS();
	idt[irq] = save_idt_npxintr;
	idt[16] = save_idt_npxtrap;
	write_eflags(save_eflags);
	return (result);
}

int npx586bug1(int, int);
asm (".text\n\t"
"npx586bug1:\n\t"
	"fildl	4(%esp)		# x\n\t"
	"fildl	8(%esp)		# y\n\t"
	"fld	%st(1)\n\t"
	"fdiv	%st(1),%st	# x/y\n\t"
	"fmulp	%st,%st(1)	# (x/y)*y\n\t"
	"fsubrp	%st,%st(1)	# x-(x/y)*y\n\t"
	"pushl	$0\n\t"
	"fistpl	(%esp)\n\t"
	"popl	%eax\n\t"
	"ret\n\t");

void
npxinit(struct cpu_info *ci)
{
	lcr0(rcr0() & ~(CR0_EM|CR0_TS));
	fninit();
	if (npx586bug1(4195835, 3145727) != 0) {
		i386_fpu_fdivbug = 1;
		printf("%s: WARNING: Pentium FDIV bug detected!\n",
		    ci->ci_dev.dv_xname);
	}
	if (fpu_mxcsr_mask == 0 && i386_use_fxsave) {
		struct savexmm xm __attribute__((aligned(16)));

		bzero(&xm, sizeof(xm));
		fxsave(&xm);
		if (xm.sv_env.en_mxcsr_mask)
			fpu_mxcsr_mask = xm.sv_env.en_mxcsr_mask;
		else
			fpu_mxcsr_mask = __INITIAL_MXCSR_MASK__;
	}
	lcr0(rcr0() | (CR0_TS));
}

/*
 * Attach routine - announce which it is, and wire into system
 */
void
npxattach(struct device *parent, struct device *self, void *aux)
{
	struct npx_softc *sc = (void *)self;
	struct isa_attach_args *ia = aux;

	switch (npx_type) {
	case NPX_INTERRUPT:
		printf("\n");
		lcr0(rcr0() & ~CR0_NE);
		sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq,
		    IST_EDGE, IPL_NONE, npxintr, 0, sc->sc_dev.dv_xname);
		break;
	case NPX_EXCEPTION:
		printf(": using exception 16\n");
		break;
	case NPX_CPUID:
		printf(": reported by CPUID; using exception 16\n");
		npx_type = NPX_EXCEPTION;
		break;
	case NPX_BROKEN:
		printf(": error reporting broken; not using\n");
		npx_type = NPX_NONE;
		return;
	case NPX_NONE:
		return;
	}

	npxinit(&cpu_info_primary);
	i386_fpu_present = 1;

	if (i386_use_fxsave)
		npxdna_func = npxdna_xmm;
	else
		npxdna_func = npxdna_s87;
}

/*
 * Record the FPU state and reinitialize it all except for the control word.
 * Then generate a SIGFPE.
 *
 * Reinitializing the state allows naive SIGFPE handlers to longjmp without
 * doing any fixups.
 *
 * XXX there is currently no way to pass the full error state to signal
 * handlers, and if this is a nested interrupt there is no way to pass even
 * a status code!  So there is no way to have a non-naive SIGFPE handler.  At
 * best a handler could do an fninit followed by an fldcw of a static value.
 * fnclex would be of little use because it would leave junk on the FPU stack.
 * Returning from the handler would be even less safe than usual because
 * IRQ13 exception handling makes exceptions even less precise than usual.
 */
int
npxintr(void *arg)
{
	struct cpu_info *ci = curcpu();
	struct proc *p = ci->ci_fpcurproc;
	union savefpu *addr;
	struct intrframe *frame = arg;
	int code;
	union sigval sv;

	uvmexp.traps++;
	IPRINTF(("%s: fp intr\n", ci->ci_dev.dv_xname));

	if (p == NULL || npx_type == NPX_NONE) {
		/* XXX no %p in stand/printf.c.  Cast to quiet gcc -Wall. */
		printf("npxintr: p = %lx, curproc = %lx, npx_type = %d\n",
		       (u_long) p, (u_long) curproc, npx_type);
		panic("npxintr from nowhere");
	}
	/*
	 * Clear the interrupt latch.
	 */
	outb(0xf0, 0);
	/*
	 * If we're saving, ignore the interrupt.  The FPU will happily
	 * generate another one when we restore the state later.
	 */
	if (ci->ci_fpsaving)
		return (1);

#ifdef DIAGNOSTIC
	/*
	 * At this point, fpcurproc should be curproc.  If it wasn't, the TS
	 * bit should be set, and we should have gotten a DNA exception.
	 */
	if (p != curproc)
		panic("npxintr: wrong process");
#endif

	/*
	 * Find the address of fpcurproc's saved FPU state.  (Given the
	 * invariant above, this is always the one in curpcb.)
	 */
	addr = &p->p_addr->u_pcb.pcb_savefpu;
	/*
	 * Save state.  This does an implied fninit.  It had better not halt
	 * the cpu or we'll hang.
	 */
	fpu_save(addr);
	fwait();
	/*
	 * Restore control word (was clobbered by fpu_save).
	 */
	if (i386_use_fxsave) {
		fldcw(&addr->sv_xmm.sv_env.en_cw);
		/*
		 * FNINIT doesn't affect MXCSR or the XMM registers;
		 * no need to re-load MXCSR here.
		 */
	} else
		fldcw(&addr->sv_87.sv_env.en_cw);
	fwait();
	/*
	 * Remember the exception status word and tag word.  The current
	 * (almost fninit'ed) fpu state is in the fpu and the exception
	 * state just saved will soon be junk.  However, the implied fninit
	 * doesn't change the error pointers or register contents, and we
	 * preserved the control word and will copy the status and tag
	 * words, so the complete exception state can be recovered.
	 */
	if (i386_use_fxsave) {
	        addr->sv_xmm.sv_ex_sw = addr->sv_xmm.sv_env.en_sw;
	        addr->sv_xmm.sv_ex_tw = addr->sv_xmm.sv_env.en_tw;
	} else {
	        addr->sv_87.sv_ex_sw = addr->sv_87.sv_env.en_sw;
	        addr->sv_87.sv_ex_tw = addr->sv_87.sv_env.en_tw;
	}

	/*
	 * Pass exception to process.  If it's the current process, try to do
	 * it immediately.
	 */
	if (p == curproc && USERMODE(frame->if_cs, frame->if_eflags)) {
		/*
		 * Interrupt is essentially a trap, so we can afford to call
		 * the SIGFPE handler (if any) as soon as the interrupt
		 * returns.
		 *
		 * XXX little or nothing is gained from this, and plenty is
		 * lost - the interrupt frame has to contain the trap frame
		 * (this is otherwise only necessary for the rescheduling trap
		 * in doreti, and the frame for that could easily be set up
		 * just before it is used).
		 */
		p->p_md.md_regs = (struct trapframe *)&frame->if_fs;

		/*
		 * Encode the appropriate code for detailed information on
		 * this exception.
		 */
		if (i386_use_fxsave)
			code = x86fpflags_to_siginfo(addr->sv_xmm.sv_ex_sw);
		else
			code = x86fpflags_to_siginfo(addr->sv_87.sv_ex_sw);
		sv.sival_int = frame->if_eip;
		trapsignal(p, SIGFPE, T_ARITHTRAP, code, sv);
	} else {
		/*
		 * Nested interrupt.  These losers occur when:
		 *	o an IRQ13 is bogusly generated at a bogus time, e.g.:
		 *		o immediately after an fnsave or frstor of an
		 *		  error state.
		 *		o a couple of 386 instructions after
		 *		  "fstpl _memvar" causes a stack overflow.
		 *	  These are especially nasty when combined with a
		 *	  trace trap.
		 *	o an IRQ13 occurs at the same time as another higher-
		 *	  priority interrupt.
		 *
		 * Treat them like a true async interrupt.
		 */
		psignal(p, SIGFPE);
	}

	return (1);
}

void
npxtrap(struct trapframe *frame)
{
	struct proc *p = curcpu()->ci_fpcurproc;
	union savefpu *addr = &p->p_addr->u_pcb.pcb_savefpu;
	u_int32_t mxcsr, statbits;
	int code;
	union sigval sv;

#ifdef DIAGNOSTIC
	/*
	 * At this point, fpcurproc should be curproc.  If it wasn't, the TS
	 * bit should be set, and we should have gotten a DNA exception.
	 */
	if (p != curproc)
		panic("npxtrap: wrong process");
#endif

	fxsave(&addr->sv_xmm);
	mxcsr = addr->sv_xmm.sv_env.en_mxcsr;
	statbits = mxcsr;
	mxcsr &= ~0x3f;
	ldmxcsr(&mxcsr);
	addr->sv_xmm.sv_ex_sw = addr->sv_xmm.sv_env.en_sw;
	addr->sv_xmm.sv_ex_tw = addr->sv_xmm.sv_env.en_tw;
	code = x86fpflags_to_siginfo (statbits);
	sv.sival_int = frame->tf_eip;
	KERNEL_LOCK();
	trapsignal(p, SIGFPE, frame->tf_err, code, sv);
	KERNEL_UNLOCK();
}

static int
x86fpflags_to_siginfo(u_int32_t flags)
{
        int i;
        static int x86fp_siginfo_table[] = {
                FPE_FLTINV, /* bit 0 - invalid operation */
                FPE_FLTRES, /* bit 1 - denormal operand */
                FPE_FLTDIV, /* bit 2 - divide by zero   */
                FPE_FLTOVF, /* bit 3 - fp overflow      */
                FPE_FLTUND, /* bit 4 - fp underflow     */
                FPE_FLTRES, /* bit 5 - fp precision     */
                FPE_FLTINV, /* bit 6 - stack fault      */
        };

        for (i=0;i < sizeof(x86fp_siginfo_table)/sizeof(int); i++) {
                if (flags & (1 << i))
                        return (x86fp_siginfo_table[i]);
        }
        /* punt if flags not set */
        return (FPE_FLTINV);
}

/*
 * Implement device not available (DNA) exception
 *
 * If we were the last process to use the FPU, we can simply return.
 * Otherwise, we save the previous state, if necessary, and restore our last
 * saved state.
 */
int
npxdna_xmm(struct cpu_info *ci)
{
	union savefpu *sfp;
	struct proc *p;
	int s;

	if (ci->ci_fpsaving) {
		printf("recursive npx trap; cr0=%x\n", rcr0());
		return (0);
	}

	s = splipi();		/* lock out IPI's while we clean house.. */

#ifdef MULTIPROCESSOR
	p = ci->ci_curproc;
#else
	p = curproc;
#endif

	IPRINTF(("%s: dna for %lx%s\n", ci->ci_dev.dv_xname, (u_long)p,
	    (p->p_md.md_flags & MDP_USEDFPU) ? " (used fpu)" : ""));

	/*
	 * XXX should have a fast-path here when no save/restore is necessary
	 */
	/*
	 * Initialize the FPU state to clear any exceptions.  If someone else
	 * was using the FPU, save their state (which does an implicit
	 * initialization).
	 */
	if (ci->ci_fpcurproc != NULL) {
		IPRINTF(("%s: fp save %lx\n", ci->ci_dev.dv_xname,
		    (u_long)ci->ci_fpcurproc));
		npxsave_cpu(ci, ci->ci_fpcurproc != &proc0);
	} else {
		clts();
		IPRINTF(("%s: fp init\n", ci->ci_dev.dv_xname));
		fninit();
		fwait();
		stts();
	}
	splx(s);

	IPRINTF(("%s: done saving\n", ci->ci_dev.dv_xname));
	KDASSERT(ci->ci_fpcurproc == NULL);
#ifndef MULTIPROCESSOR
	KDASSERT(p->p_addr->u_pcb.pcb_fpcpu == NULL);
#else
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		npxsave_proc(p, 1);
#endif
	p->p_addr->u_pcb.pcb_cr0 &= ~CR0_TS;
	clts();
	s = splipi();
	ci->ci_fpcurproc = p;
	p->p_addr->u_pcb.pcb_fpcpu = ci;
	splx(s);
	uvmexp.fpswtch++;

	sfp = &p->p_addr->u_pcb.pcb_savefpu;

	if ((p->p_md.md_flags & MDP_USEDFPU) == 0) {
		bzero(&sfp->sv_xmm, sizeof(sfp->sv_xmm));
		sfp->sv_xmm.sv_env.en_cw = __INITIAL_NPXCW__;
		sfp->sv_xmm.sv_env.en_mxcsr = __INITIAL_MXCSR__;
		fxrstor(&sfp->sv_xmm);
		p->p_md.md_flags |= MDP_USEDFPU;
	} else {
		static double	zero = 0.0;

		/*
		 * amd fpu does not restore fip, fdp, fop on fxrstor
		 * thus leaking other process's execution history.
		 */
		fnclex();
		__asm volatile("ffree %%st(7)\n\tfldl %0" : : "m" (zero));
		fxrstor(&sfp->sv_xmm);
	}

	return (1);
}

int
npxdna_s87(struct cpu_info *ci)
{
	union savefpu *sfp;
	struct proc *p;
	int s;

	KDASSERT(i386_use_fxsave == 0);

	if (ci->ci_fpsaving) {
		printf("recursive npx trap; cr0=%x\n", rcr0());
		return (0);
	}

	s = splipi();		/* lock out IPI's while we clean house.. */
#ifdef MULTIPROCESSOR
	p = ci->ci_curproc;
#else
	p = curproc;
#endif

	IPRINTF(("%s: dna for %lx%s\n", ci->ci_dev.dv_xname, (u_long)p,
	    (p->p_md.md_flags & MDP_USEDFPU) ? " (used fpu)" : ""));

	/*
	 * If someone else was using our FPU, save their state (which does an
	 * implicit initialization); otherwise, initialize the FPU state to
	 * clear any exceptions.
	 */
	if (ci->ci_fpcurproc != NULL) {
		IPRINTF(("%s: fp save %lx\n", ci->ci_dev.dv_xname,
		    (u_long)ci->ci_fpcurproc));
		npxsave_cpu(ci, ci->ci_fpcurproc != &proc0);
	} else {
		clts();
		IPRINTF(("%s: fp init\n", ci->ci_dev.dv_xname));
		fninit();
		fwait();
		stts();
	}
	splx(s);

	IPRINTF(("%s: done saving\n", ci->ci_dev.dv_xname));
	KDASSERT(ci->ci_fpcurproc == NULL);
#ifndef MULTIPROCESSOR
	KDASSERT(p->p_addr->u_pcb.pcb_fpcpu == NULL);
#else
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		npxsave_proc(p, 1);
#endif
	p->p_addr->u_pcb.pcb_cr0 &= ~CR0_TS;
	clts();
	s = splipi();
	ci->ci_fpcurproc = p;
	p->p_addr->u_pcb.pcb_fpcpu = ci;
	splx(s);
	uvmexp.fpswtch++;

	sfp = &p->p_addr->u_pcb.pcb_savefpu;

	if ((p->p_md.md_flags & MDP_USEDFPU) == 0) {
		bzero(&sfp->sv_87, sizeof(sfp->sv_87));
		sfp->sv_87.sv_env.en_cw = __INITIAL_NPXCW__;
		sfp->sv_87.sv_env.en_tw = 0xffff;
		frstor(&sfp->sv_87);
		p->p_md.md_flags |= MDP_USEDFPU;
	} else {
		/*
		 * The following frstor may cause an IRQ13 when the state being
		 * restored has a pending error.  The error will appear to have
		 * been triggered by the current (npx) user instruction even
		 * when that instruction is a no-wait instruction that should
		 * not trigger an error (e.g., fnclex).  On at least one 486
		 * system all of the no-wait instructions are broken the same
		 * as frstor, so our treatment does not amplify the breakage.
		 * On at least one 386/Cyrix 387 system, fnclex works correctly
		 * while frstor and fnsave are broken, so our treatment breaks
		 * fnclex if it is the first FPU instruction after a context
		 * switch.
		 */
		frstor(&sfp->sv_87);
	}

	return (1);
}

/*
 * The FNSAVE instruction clears the FPU state.  Rather than reloading the FPU
 * immediately, we clear fpcurproc and turn on CR0_TS to force a DNA and a
 * reload of the FPU state the next time we try to use it.  This routine
 * is only called when forking, core dumping, or debugging, or swapping,
 * so the lazy reload at worst forces us to trap once per fork(), and at best
 * saves us a reload once per fork().
 */
void
npxsave_cpu(struct cpu_info *ci, int save)
{
	struct proc *p;
	int s;

	KDASSERT(ci == curcpu());

	p = ci->ci_fpcurproc;
	if (p == NULL)
		return;

	IPRINTF(("%s: fp cpu %s %lx\n", ci->ci_dev.dv_xname,
	    save ? "save" : "flush", (u_long)p));

	if (save) {
#ifdef DIAGNOSTIC
		if (ci->ci_fpsaving != 0)
			panic("npxsave_cpu: recursive save!");
#endif
		 /*
		  * Set ci->ci_fpsaving, so that any pending exception will be
		  * thrown away.  (It will be caught again if/when the FPU
		  * state is restored.)
		  *
		  * XXX on i386 and earlier, this routine should always be
		  * called at spl0; if it might called with the NPX interrupt
		  * masked, it would be necessary to forcibly unmask the NPX
		  * interrupt so that it could succeed.
		  * XXX this is irrelevant on 486 and above (systems
		  * which report FP failures via traps rather than irq13).
		  * XXX punting for now..
		  */
		clts();
		ci->ci_fpsaving = 1;
		fpu_save(&p->p_addr->u_pcb.pcb_savefpu);
		ci->ci_fpsaving = 0;
		/* It is unclear if this is needed. */
		fwait();
	}

	/*
	 * We set the TS bit in the saved CR0 for this process, so that it
	 * will get a DNA exception on any FPU instruction and force a reload.
	 */
	stts();
	p->p_addr->u_pcb.pcb_cr0 |= CR0_TS;

	s = splipi();
	p->p_addr->u_pcb.pcb_fpcpu = NULL;
	ci->ci_fpcurproc = NULL;
	splx(s);
}

/*
 * Save p's FPU state, which may be on this processor or another processor.
 */
void
npxsave_proc(struct proc *p, int save)
{
	struct cpu_info *ci = curcpu();
	struct cpu_info *oci;

	KDASSERT(p->p_addr != NULL);

	oci = p->p_addr->u_pcb.pcb_fpcpu;
	if (oci == NULL)
		return;

	IPRINTF(("%s: fp proc %s %lx\n", ci->ci_dev.dv_xname,
	    save ? "save" : "flush", (u_long)p));

#if defined(MULTIPROCESSOR)
	if (oci == ci) {
		int s = splipi();
		npxsave_cpu(ci, save);
		splx(s);
	} else {
		IPRINTF(("%s: fp ipi to %s %s %lx\n", ci->ci_dev.dv_xname,
		    oci->ci_dev.dv_xname, save ? "save" : "flush", (u_long)p));

		oci->ci_fpsaveproc = p;
		i386_send_ipi(oci,
		    save ? I386_IPI_SYNCH_FPU : I386_IPI_FLUSH_FPU);
		while (p->p_addr->u_pcb.pcb_fpcpu != NULL)
			SPINLOCK_SPIN_HOOK;
	}
#else
	KASSERT(ci->ci_fpcurproc == p);
	npxsave_cpu(ci, save);
#endif
}

void
fpu_kernel_enter(void)
{
	struct cpu_info	*ci = curcpu();
	uint32_t	 cw;
	int		 s;

	/*
	 * Fast path.  If the kernel was using the FPU before, there
	 * is no work to do besides clearing TS.
	 */
	if (ci->ci_fpcurproc == &proc0) {
		clts();
		return;
	}

	s = splipi();

	if (ci->ci_fpcurproc != NULL) {
		npxsave_cpu(ci, 1);
		uvmexp.fpswtch++;
	}

	/* Claim the FPU */
	ci->ci_fpcurproc = &proc0;

	splx(s);

	/* Disable DNA exceptions */
	clts();

	/* Initialize the FPU */
	fninit();
	cw = __INITIAL_NPXCW__;
	fldcw(&cw);
	if (i386_has_sse || i386_has_sse2) {
		cw = __INITIAL_MXCSR__;
		ldmxcsr(&cw);
	}
}

void
fpu_kernel_exit(void)
{
	/* Enable DNA exceptions */
	stts();
}
@


1.60
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.59 2013/11/16 21:00:02 brad Exp $	*/
d64 1
@


1.59
log
@Copied from amd64..

Use an explicit suffix for the "fld" instruction to shut up clang.  The correct
instruction is fldl since we try to load a double-precision value.
GCC actually gets it wrong and emits "flds" (which is harmless).

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.58 2013/05/08 15:36:30 tedu Exp $	*/
d691 1
a691 1
		__asm __volatile("ffree %%st(7)\n\tfldl %0" : : "m" (zero));
@


1.58
log
@remove stale cyrix emc support, and switch to just using intial npxcw
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.57 2011/07/11 15:40:47 guenther Exp $	*/
d691 1
a691 1
		__asm __volatile("ffree %%st(7)\n\tfld %0" : : "m" (zero));
@


1.57
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.55 2011/07/06 21:41:37 art Exp $	*/
d679 1
a679 1
		sfp->sv_xmm.sv_env.en_cw = __OpenBSD_NPXCW__;
d760 1
a760 1
		sfp->sv_87.sv_env.en_cw = __OpenBSD_NPXCW__;
@


1.56
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@d581 1
d583 1
@


1.55
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.54 2011/03/20 21:44:08 guenther Exp $	*/
a580 1
	KERNEL_LOCK();
a581 1
	KERNEL_UNLOCK();
@


1.54
log
@When reading MXCSR from userland sigcontext or a ptrace request,
mask out invalid bits to prevent a protect fault.

Original diff by joshe@@; further feedback and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.53 2010/09/29 15:11:31 joshe Exp $	*/
d581 1
a581 1
	KERNEL_PROC_LOCK(p);
d583 1
a583 1
	KERNEL_PROC_UNLOCK(p);
@


1.53
log
@Back out previous, it appears to be broken.
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.51 2010/07/23 15:10:16 kettenis Exp $	*/
d100 5
d358 10
@


1.52
log
@When reading MXCSR from userland sigcontext, mask out invalid bits.

This prevents a protection fault if a userland signal handler
scribbles all over it's struct sigcontext

Help from and ok guenther@@ kettenis@@
@
text
@a99 5
/*
 * The mxcsr_mask for this host, taken from fxsave() on the primary CPU
 */
uint32_t	fpu_mxcsr_mask;

a352 10
	}
	if (CPU_IS_PRIMARY(ci) && i386_use_fxsave) {
		struct savexmm xm __attribute__((aligned(16)));

		bzero(&xm, sizeof(xm));
		fxsave(&xm);
		if (xm.sv_env.en_mxcsr_mask)
			fpu_mxcsr_mask = xm.sv_env.en_mxcsr_mask;
		else
			fpu_mxcsr_mask = __INITIAL_MXCSR_MASK__;
@


1.51
log
@Change the strategy for using the FPU in the kernel.  The kernel FPU state
is now shared with all processes/threads.  As a result, you can now use the
FPU in true process context (instead of just in kernel threads), but you
need to make sure you restore the default FPU state before calling
fpu_kernel_exit() if you change rounding mode, precision or exception masks.

Lots of discussion with thib@@ and Mike Belopuhov.

ok thib@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.50 2010/07/23 14:56:31 kettenis Exp $	*/
d100 5
d358 10
@


1.50
log
@Don't leak the contents of the FPU and SSE registers between processes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.49 2010/07/21 14:08:09 kettenis Exp $	*/
d634 1
a634 1
		npxsave_cpu(ci, 1);
d715 1
a715 1
		npxsave_cpu(ci, 1);
d873 1
a873 2
	struct cpu_info	*oci, *ci = curcpu();
	struct proc	*p = curproc;
a876 2
	KASSERT(p != NULL && (p->p_flag & P_SYSTEM));

d878 2
a879 2
	 * Fast path. If we were the last proc on the FPU,
	 * there is no work to do besides clearing TS.
d881 1
a881 2
	if (ci->ci_fpcurproc == p) {
		p->p_addr->u_pcb.pcb_cr0 &= ~CR0_TS;
a892 8
	/*
	 * If we were switched away to the other cpu, cleanup
	 * an fpcurproc pointer.
	 */
	oci = p->p_addr->u_pcb.pcb_fpcpu;
	if (oci != NULL && oci != ci && oci->ci_fpcurproc == p)
		oci->ci_fpcurproc = NULL;

d894 1
a894 3
	ci->ci_fpcurproc = p;
	p->p_addr->u_pcb.pcb_fpcpu = ci;
	p->p_addr->u_pcb.pcb_cr0 &= ~CR0_TS;
d898 1
a898 1
	/* Disables DNA exceptions */
d914 2
a915 5
	/*
	 * Nothing to do.
	 * TS is restored on a context switch automatically
	 * as long as we use hardware assisted task switching.
	 */
@


1.49
log
@Make sure that the FPU IPIs shoot down the right FPU context and not the FPU
context of some random process that happened to be switched onto the FPU
after the decision was made to send the IPI.
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.48 2010/06/29 21:13:43 thib Exp $	*/
d603 1
a603 1
	union savefpu *addr;
d660 1
a660 1
	addr = &p->p_addr->u_pcb.pcb_savefpu;
d663 4
a666 3
		fldcw(&addr->sv_xmm.sv_env.en_cw);
		if (i386_has_sse || i386_has_sse2)
			ldmxcsr(&addr->sv_xmm.sv_env.en_mxcsr);
d677 1
a677 1
		fxrstor(&addr->sv_xmm);
d686 1
d741 2
d744 4
a747 1
		fldcw(&p->p_addr->u_pcb.pcb_savefpu.sv_87.sv_env.en_cw);
d763 1
a763 1
		frstor(&p->p_addr->u_pcb.pcb_savefpu.sv_87);
@


1.48
log
@fpu_kernel_{enter,exit}; Functions to allow the use of
the FPU in the kernel.

From Mike Belopuhov; Little bits by myself.

Comments/OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.47 2009/10/28 21:12:18 deraadt Exp $	*/
d851 1
a853 1

@


1.47
log
@delete balony comment; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.46 2009/10/26 20:30:23 kettenis Exp $	*/
d861 65
@


1.46
log
@Load %mxcsr when initializing the FPU on machines that support SSE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.45 2009/10/03 21:51:01 kettenis Exp $	*/
a598 5
 */

/*
 * XXX It is unclear if the code below is correct in the multiprocessor
 * XXX case.  Check the NetBSD sources once again to be sure.
@


1.45
log
@Properly handle XMM exceptions instead of panicing the kernel.  Fixes the
issue reported by Slava Pestov.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.44 2008/12/04 15:48:19 weingart Exp $	*/
d608 1
d665 2
d668 3
a670 1
		fldcw(&p->p_addr->u_pcb.pcb_savefpu.sv_xmm.sv_env.en_cw);
d681 1
a681 1
		fxrstor(&p->p_addr->u_pcb.pcb_savefpu.sv_xmm);
@


1.44
log
@Fix "fp_save ipi didn't" panic, and move i386/amd64 closer in the process.
Positive test results by a handful of people.  Ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.43 2007/11/28 17:05:09 tedu Exp $	*/
d137 3
a139 2
#define        fxsave(addr)            __asm("fxsave %0" : "=m" (*addr))
#define        fxrstor(addr)           __asm("fxrstor %0" : : "m" (*addr))
d537 32
@


1.44.6.1
log
@Properly handle XMM exceptions instead of panicing the kernel.  Fixes the
issue reported by Slava Pestov. Fix from kettenis@@.

MFC requested by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.44 2008/12/04 15:48:19 weingart Exp $	*/
d137 2
a138 3
#define fxsave(addr)		__asm("fxsave %0" : "=m" (*addr))
#define fxrstor(addr)		__asm("fxrstor %0" : : "m" (*addr))
#define ldmxcsr(addr)		__asm("ldmxcsr %0" : : "m" (*addr))
a535 32
}

void
npxtrap(struct trapframe *frame)
{
	struct proc *p = curcpu()->ci_fpcurproc;
	union savefpu *addr = &p->p_addr->u_pcb.pcb_savefpu;
	u_int32_t mxcsr, statbits;
	int code;
	union sigval sv;

#ifdef DIAGNOSTIC
	/*
	 * At this point, fpcurproc should be curproc.  If it wasn't, the TS
	 * bit should be set, and we should have gotten a DNA exception.
	 */
	if (p != curproc)
		panic("npxtrap: wrong process");
#endif

	fxsave(&addr->sv_xmm);
	mxcsr = addr->sv_xmm.sv_env.en_mxcsr;
	statbits = mxcsr;
	mxcsr &= ~0x3f;
	ldmxcsr(&mxcsr);
	addr->sv_xmm.sv_ex_sw = addr->sv_xmm.sv_env.en_sw;
	addr->sv_xmm.sv_ex_tw = addr->sv_xmm.sv_env.en_tw;
	code = x86fpflags_to_siginfo (statbits);
	sv.sival_int = frame->tf_eip;
	KERNEL_PROC_LOCK(p);
	trapsignal(p, SIGFPE, frame->tf_err, code, sv);
	KERNEL_PROC_UNLOCK(p);
@


1.44.2.1
log
@Properly handle XMM exceptions instead of panicing the kernel.  Fixes the
issue reported by Slava Pestov. Fix from kettenis@@.

MFC requested by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.44 2008/12/04 15:48:19 weingart Exp $	*/
d137 2
a138 3
#define fxsave(addr)		__asm("fxsave %0" : "=m" (*addr))
#define fxrstor(addr)		__asm("fxrstor %0" : : "m" (*addr))
#define ldmxcsr(addr)		__asm("ldmxcsr %0" : : "m" (*addr))
a535 32
}

void
npxtrap(struct trapframe *frame)
{
	struct proc *p = curcpu()->ci_fpcurproc;
	union savefpu *addr = &p->p_addr->u_pcb.pcb_savefpu;
	u_int32_t mxcsr, statbits;
	int code;
	union sigval sv;

#ifdef DIAGNOSTIC
	/*
	 * At this point, fpcurproc should be curproc.  If it wasn't, the TS
	 * bit should be set, and we should have gotten a DNA exception.
	 */
	if (p != curproc)
		panic("npxtrap: wrong process");
#endif

	fxsave(&addr->sv_xmm);
	mxcsr = addr->sv_xmm.sv_env.en_mxcsr;
	statbits = mxcsr;
	mxcsr &= ~0x3f;
	ldmxcsr(&mxcsr);
	addr->sv_xmm.sv_ex_sw = addr->sv_xmm.sv_env.en_sw;
	addr->sv_xmm.sv_ex_tw = addr->sv_xmm.sv_env.en_tw;
	code = x86fpflags_to_siginfo (statbits);
	sv.sival_int = frame->tf_eip;
	KERNEL_PROC_LOCK(p);
	trapsignal(p, SIGFPE, frame->tf_err, code, sv);
	KERNEL_PROC_UNLOCK(p);
@


1.43
log
@quite a bit of simplification by removing cpu classes.
also assume that 386 cpus are really unknown, and promote them to 486
instead of panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.42 2006/10/18 19:48:32 tom Exp $	*/
a814 4
#ifdef DIAGNOSTIC
		int spincount;
#endif

d821 1
a821 4
#ifdef DIAGNOSTIC
		spincount = 0;
#endif
		while (p->p_addr->u_pcb.pcb_fpcpu != NULL) {
a822 6
#ifdef DIAGNOSTIC
			if (spincount++ > 100000000)
				panic("%s: fp_save ipi didn't (%s)",
				    ci->ci_dev.dv_xname, oci->ci_dev.dv_xname);
#endif
		}
@


1.43.4.1
log
@Properly handle XMM exceptions instead of panicing the kernel.  Fixes the
issue reported by Slava Pestov. Fix from kettenis@@.

MFC requested by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.43 2007/11/28 17:05:09 tedu Exp $	*/
d137 2
a138 3
#define fxsave(addr)		__asm("fxsave %0" : "=m" (*addr))
#define fxrstor(addr)		__asm("fxrstor %0" : : "m" (*addr))
#define ldmxcsr(addr)		__asm("ldmxcsr %0" : : "m" (*addr))
a535 32
}

void
npxtrap(struct trapframe *frame)
{
	struct proc *p = curcpu()->ci_fpcurproc;
	union savefpu *addr = &p->p_addr->u_pcb.pcb_savefpu;
	u_int32_t mxcsr, statbits;
	int code;
	union sigval sv;

#ifdef DIAGNOSTIC
	/*
	 * At this point, fpcurproc should be curproc.  If it wasn't, the TS
	 * bit should be set, and we should have gotten a DNA exception.
	 */
	if (p != curproc)
		panic("npxtrap: wrong process");
#endif

	fxsave(&addr->sv_xmm);
	mxcsr = addr->sv_xmm.sv_env.en_mxcsr;
	statbits = mxcsr;
	mxcsr &= ~0x3f;
	ldmxcsr(&mxcsr);
	addr->sv_xmm.sv_ex_sw = addr->sv_xmm.sv_env.en_sw;
	addr->sv_xmm.sv_ex_tw = addr->sv_xmm.sv_env.en_tw;
	code = x86fpflags_to_siginfo (statbits);
	sv.sival_int = frame->tf_eip;
	KERNEL_PROC_LOCK(p);
	trapsignal(p, SIGFPE, frame->tf_err, code, sv);
	KERNEL_PROC_UNLOCK(p);
@


1.42
log
@Short-circuit the detection of the FPU by checking the CPUID features,
as done in FreeBSD.  Fixes problems on AMD Geode LX-800 where our
detection logic doesn't detect the FP exception.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.41 2006/09/19 11:06:34 jsg Exp $	*/
a136 1
#ifdef I686_CPU
a138 1
#endif /* I686_CPU */
a143 1
#ifdef I686_CPU
a148 1
#endif /* I686_CPU */
a159 1
#ifdef I686_CPU
a160 1
#endif /* I686_CPU */
a389 1
#ifdef I686_CPU
a392 1
#endif /* I686_CPU */
a571 1
#ifdef I686_CPU
a647 1
#endif /* I686_CPU */
@


1.41
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.40 2006/07/25 19:16:51 kettenis Exp $	*/
d126 1
d282 9
d380 4
@


1.40
log
@Kill option GPL_MATH_EMULATE.

ok deraadt@@ and many others.
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.39 2006/04/19 15:48:17 mickey Exp $	*/
d196 1
a196 2
npxprobe1(ia)
	struct isa_attach_args *ia;
d271 1
a271 3
npxprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d356 1
a356 3
npxattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d406 1
a406 2
npxintr(arg)
	void *arg;
@


1.40.2.1
log
@MFC:
Fix by tom@@

Short-circuit the detection of the FPU by checking the CPUID features,
as done in FreeBSD.  Fixes problems on AMD Geode LX-800 where our
detection logic doesen't detect the FP exception.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.40 2006/07/25 19:16:51 kettenis Exp $	*/
a125 1
	NPX_CPUID,
a283 9
	if (cpu_feature & CPUID_FPU) {
		npx_type = NPX_CPUID;
		i386_fpu_exception = 1;
		ia->ia_irq = IRQUNK;	/* Don't want the interrupt vector */
		ia->ia_iosize = 16;
		ia->ia_msize = 0;
		return 1;
	}

a374 4
		break;
	case NPX_CPUID:
		printf(": reported by CPUID; using exception 16\n");
		npx_type = NPX_EXCEPTION;
@


1.39
log
@from todays freebsd advisory: fxrstor on amd cpu does not restore fip,fdp,fop thus leaking other proc's execution history; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.38 2006/03/13 18:42:16 mickey Exp $	*/
a198 1
#ifndef ALWAYS_MATH_EMULATE
d249 1
a249 1
				 * Worse, even IRQ13 is broken.  Use emulator.
a256 3
#else
	npx_intrs_while_probing = npx_traps_while_probing = 0;
#endif
@


1.38
log
@time-bind and lower power in lock spinning and a couple of other ipi loops by using pause insn; brad@@ ok tedu@@ ok and feedback krw@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.37 2005/06/06 14:25:20 mickey Exp $	*/
d640 8
@


1.37
log
@oops. on 686 we count fpswtch in another function...
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.36 2005/04/21 04:39:35 mickey Exp $	*/
d826 2
a827 1
		while (p->p_addr->u_pcb.pcb_fpcpu != NULL)
d829 4
a832 5
		{
			spincount++;
			if (spincount > 100000000) {
				panic("fp_save ipi didn't");
			}
a833 4
#else
		__splbarrier();		/* XXX replace by generic barrier */
		;
#endif
a839 1

@


1.37.2.1
log
@MFC:
Fix by mickey@@

from todays freebsd advisory: fxrstor on amd cpu does not restore fip,fdp,fop thus leaking other proc'sexecution history
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.37 2005/06/06 14:25:20 mickey Exp $	*/
a639 8
		static double	zero = 0.0;

		/*
		 * amd fpu does not restore fip, fdp, fop on fxrstor
		 * thus leaking other process's execution history.
		 */
		fnclex();
		__asm __volatile("ffree %%st(7)\n\tfld %0" : : "m" (zero));
@


1.37.4.1
log
@MFC:
Fix by mickey@@

from todays freebsd advisory: fxrstor on amd cpu does not restore fip,fdp,fop thus leaking other proc'sexecution history
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.37 2005/06/06 14:25:20 mickey Exp $	*/
a639 8
		static double	zero = 0.0;

		/*
		 * amd fpu does not restore fip, fdp, fop on fxrstor
		 * thus leaking other process's execution history.
		 */
		fnclex();
		__asm __volatile("ffree %%st(7)\n\tfld %0" : : "m" (zero));
@


1.36
log
@count fpu lazy context switches; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.35 2004/10/21 20:58:07 kettenis Exp $	*/
d634 1
@


1.35
log
@SIGFPE signal codes for SSE.
nice deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.34 2004/07/21 18:39:58 kettenis Exp $	*/
d701 1
@


1.35.2.1
log
@MFC:
Fix by mickey@@

from todays freebsd advisory: fxrstor on amd cpu does not restore fip,fdp,fop thus leaking other proc'sexecution history
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.35 2004/10/21 20:58:07 kettenis Exp $	*/
a638 8
		static double	zero = 0.0;

		/*
		 * amd fpu does not restore fip, fdp, fop on fxrstor
		 * thus leaking other process's execution history.
		 */
		fnclex();
		__asm __volatile("ffree %%st(7)\n\tfld %0" : : "m" (zero));
@


1.34
log
@Fix conversion of interrupt frame to trap frame.
ok deraadt@@, niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.33 2004/07/13 20:43:13 art Exp $	*/
d102 2
d515 2
a516 14
		if (addr->sv_87.sv_ex_sw & EN_SW_IE)
			code = FPE_FLTINV;
#ifdef notyet
		else if (addr->sv_87.sv_ex_sw & EN_SW_DE)
			code = FPE_FLTDEN;
#endif
		else if (addr->sv_87.sv_ex_sw & EN_SW_ZE)
			code = FPE_FLTDIV;
		else if (addr->sv_87.sv_ex_sw & EN_SW_OE)
			code = FPE_FLTOVF;
		else if (addr->sv_87.sv_ex_sw & EN_SW_UE)
			code = FPE_FLTUND;
		else if (addr->sv_87.sv_ex_sw & EN_SW_PE)
			code = FPE_FLTRES;
d518 1
a518 1
			code = 0;		/* XXX unknown */
d540 22
@


1.33
log
@Don't assert that P_INMEM is set in p_flag. The assert is only almost
correct because P_INMEM is for various reasons removed before cpu_swapout
is called and cpu_swapout in turn calls npxsave_proc.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.32 2004/06/13 21:49:16 niklas Exp $	*/
d507 1
a507 1
		p->p_md.md_regs = (struct trapframe *)&frame->if_es;
@


1.32
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d778 1
a778 1
 void
a784 1
	KDASSERT(p->p_flag & P_INMEM);
@


1.31
log
@Enable FXSR all the time, and cope with NPX/FXSR conversions; from netbsd.
Pass SSE/SSE2/XCRYPT flags out via syctl, and prepare for being able to do
xcrypt-* in userland; ok naddy, tested a lot by pvalchev and jolan, also
works on amd64 in 32bit mode
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.30 2003/12/31 19:17:41 deraadt Exp $	*/
d5 1
a5 1
#define iprintf(x)	printf x
d7 1
a7 1
#define	iprintf(x)
d57 1
d63 1
a66 7
#include <i386/isa/icu.h>

#if 0
#define IPRINTF(x)      printf x
#else
#define IPRINTF(x)
#endif
a101 1
static void npxsave1(void);
a125 2
struct proc	*npxproc;

a126 1
static	int			npx_nointr;
d154 1
a154 1
npxdna_notset(struct proc *p)
d159 2
a160 2
int    (*npxdna_func)(struct proc *) = npxdna_notset;
int    npxdna_s87(struct proc *);
d162 1
a162 1
int    npxdna_xmm(struct proc *);
d344 13
d386 1
a386 7
	lcr0(rcr0() & ~(CR0_EM|CR0_TS));
	fninit();
	if (npx586bug1(4195835, 3145727) != 0) {
		i386_fpu_fdivbug = 1;
		printf("WARNING: Pentium FDIV bug detected!\n");
	}
	lcr0(rcr0() | (CR0_TS));
d416 2
a417 1
	register struct proc *p = npxproc;
d424 1
a424 1
	iprintf(("Intr"));
d426 1
a426 1
	if (p == 0 || npx_type == NPX_NONE) {
d440 1
a440 1
	if (npx_nointr != 0)
d442 2
d445 10
a454 2
	 * Find the address of npxproc's savefpu.  This is not necessarily
	 * the one in curpcb.
d516 1
a516 1
		else if (addr->sv_ex_sw & EN_SW_DE)
d553 1
a553 3
 * Wrapper for fnsave instruction to handle h/w bugs.  If there is an error
 * pending, then fnsave generates a bogus IRQ13 on some systems.  Force any
 * IRQ13 to be handled immediately, and then ignore it.
d555 3
a557 3
 * This routine is always called at spl0.  If it might called with the NPX
 * interrupt masked, it would be necessary to forcibly unmask the NPX interrupt
 * so that it could succeed.
a558 12
static __inline void
npxsave1(void)
{
	register struct pcb *pcb;

	npx_nointr = 1;
	pcb = &npxproc->p_addr->u_pcb;
	fpu_save(&pcb->pcb_savefpu);
	pcb->pcb_cr0 |= CR0_TS;
	fwait();
	npx_nointr = 0;
}
d561 2
a562 5
 * Implement device not available (DNA) exception
 *
 * If the we were the last process to use the FPU, we can simply return.
 * Otherwise, we save the previous state, if necessary, and restore our last
 * saved state.
d566 1
a566 1
npxdna_xmm(struct proc *p)
d568 7
d576 6
a581 3
#ifdef DIAGNOSTIC
	if (cpl != 0 || npx_nointr != 0)
	        panic("npxdna: masked");
d584 2
a585 2
	p->p_addr->u_pcb.pcb_cr0 &= ~CR0_TS;
	clts();
d588 3
d595 4
a598 4
	npx_nointr = 1;
	if (npxproc != 0 && npxproc != p) {
	        IPRINTF(("Save"));
	        npxsave1();
d600 5
a604 3
	        IPRINTF(("Init"));
	        fninit();
	        fwait();
d606 16
a621 2
	npx_nointr = 0;
	npxproc = p;
d626 1
a626 1
	} else
d628 1
d635 1
a635 1
npxdna_s87(struct proc *p)
d637 4
a640 1
	static u_short control = __INITIAL_NPXCW__;
d642 2
a643 2
	if (npx_type == NPX_NONE) {
		iprintf(("Emul"));
d647 5
a651 3
#ifdef DIAGNOSTIC
	if (cpl != IPL_NONE || npx_nointr != 0)
		panic("npxdna: masked");
d654 29
d685 4
d691 1
a692 11
		iprintf(("Init"));
		if (npxproc != 0 && npxproc != p)
			npxsave1();
		else {
			npx_nointr = 1;
			fninit();
			fwait();
			npx_nointr = 0;
		}
		npxproc = p;
		fldcw(&control);
a693 9
		if (npxproc != 0) {
#ifdef DIAGNOSTIC
			if (npxproc == p)
				panic("npxdna: same process");
#endif
			iprintf(("Save"));
			npxsave1();
		}
		npxproc = p;
d714 6
a719 1
 * Drop the current FPU state on the floor.
d722 1
a722 1
npxdrop()
d724 37
d762 4
d767 6
a772 2
	npxproc->p_addr->u_pcb.pcb_cr0 |= CR0_TS;
	npxproc = 0;
d776 1
a776 7
 * Save npxproc's FPU state.
 *
 * The FNSAVE instruction clears the FPU state.  Rather than reloading the FPU
 * immediately, we clear npxproc and turn on CR0_TS to force a DNA and a reload
 * of the FPU state the next time we try to use it.  This routine is only
 * called when forking or core dump, so this algorithm at worst forces us to
 * trap once per fork(), and at best saves us a reload once per fork().
d778 2
a779 2
void
npxsave()
d781 5
d787 13
d801 28
a828 2
	if (cpl != IPL_NONE || npx_nointr != 0)
		panic("npxsave: masked");
a829 5
	iprintf(("Fork"));
	clts();
	npxsave1();
	stts();
	npxproc = 0;
d831 1
@


1.30
log
@workaround:  during npx exception testing, delay(1).  For some reason
amd64 (in 32 bit mode) and the new transmeta cpus want this, and lock
up otherwise.  very odd.
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.29 2003/10/24 09:03:20 grange Exp $	*/
d67 6
a104 2
int npxdna(struct proc *);
void npxexit(void);
d143 32
d390 7
d419 1
a419 1
	register struct save87 *addr;
d447 1
a447 1
	addr = &p->p_addr->u_pcb.pcb_savefpu.npx;
d452 1
a452 1
	fnsave(addr);
d455 1
a455 1
	 * Restore control word (was clobbered by fnsave).
d457 8
a464 1
	fldcw(&addr->sv_env.en_cw);
d474 7
a480 2
	addr->sv_ex_sw = addr->sv_env.en_sw;
	addr->sv_ex_tw = addr->sv_env.en_tw;
d504 1
a504 1
		if (addr->sv_ex_sw & EN_SW_IE)
d510 1
a510 1
		else if (addr->sv_ex_sw & EN_SW_ZE)
d512 1
a512 1
		else if (addr->sv_ex_sw & EN_SW_OE)
d514 1
a514 1
		else if (addr->sv_ex_sw & EN_SW_UE)
d516 1
a516 1
		else if (addr->sv_ex_sw & EN_SW_PE)
d552 2
a553 2
static inline void
npxsave1()
d559 1
a559 1
	fnsave(&pcb->pcb_savefpu);
d572 40
d613 1
a613 2
npxdna(p)
	struct proc *p;
d666 1
a666 1
		frstor(&p->p_addr->u_pcb.pcb_savefpu);
@


1.29
log
@No need to have several implementations of {read,write}_eflags(),
put it to cpufunc.h.
ok weingart@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.28 2003/07/25 18:31:25 jason Exp $	*/
d206 1
@


1.28
log
@let ALWAYS_MATH_EMULATE actually compile
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.27 2003/06/02 23:27:47 millert Exp $	*/
a95 5
#define	read_eflags()		({register u_long ef; \
				  __asm("pushfl; popl %0" : "=r" (ef)); \
				  ef;})
#define	write_eflags(x)		({register u_long ef = (x); \
				  __asm("pushl %0; popfl" : : "r" (ef));})
@


1.27
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.26 2003/04/17 03:42:14 drahn Exp $	*/
d233 2
d236 1
@


1.26
log
@i386 changes to move to ELF. asm cleanup. Change MAXDSIZ to 512M for 1Gsep.
DARPA funded work.
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.25 2002/03/14 01:26:33 millert Exp $	*/
d24 1
a24 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.25
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.24 2002/02/18 07:58:39 ericj Exp $	*/
d155 1
a155 1
"_probeintr:\n\t"
d157 1
a157 1
	"incl	_npx_intrs_while_probing\n\t"
d169 1
a169 1
"_probetrap:\n\t"
d171 1
a171 1
	"incl	_npx_traps_while_probing\n\t"
d310 1
a310 1
"_npx586bug1:\n\t"
@


1.24
log
@
multi-line string literals are deprecated in gcc 3.0
pr#2379
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.23 2001/12/04 00:00:36 niklas Exp $	*/
d108 5
a112 5
int npxdna __P((struct proc *));
void npxexit __P((void));
int npxintr __P((void *));
static int npxprobe1 __P((struct isa_attach_args *));
static void npxsave1 __P((void));
d119 2
a120 2
int npxprobe __P((struct device *, void *, void *));
void npxattach __P((struct device *, struct device *, void *));
d153 1
a153 1
void probeintr __P((void));
d167 1
a167 1
void probetrap __P((void));
d308 1
a308 1
int npx586bug1 __P((int, int));
@


1.23
log
@New try at a level based irq system.
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.21 2001/11/12 20:28:20 niklas Exp $	*/
d154 12
a165 14
asm ("
	.text
_probeintr:
	ss
	incl	_npx_intrs_while_probing
	pushl	%eax
	movb	$0x20,%al	# EOI (asm in strings loses cpp features)
	outb	%al,$0xa0	# IO_ICU2
	outb	%al,$0x20	# IO_ICU1
	movb	$0,%al
	outb	%al,$0xf0	# clear BUSY# latch
	popl	%eax
	iret
");
d168 6
a173 8
asm ("
	.text
_probetrap:
	ss
	incl	_npx_traps_while_probing
	fnclex
	iret
");
d309 12
a320 14
asm ("
	.text
_npx586bug1:
	fildl	4(%esp)		# x
	fildl	8(%esp)		# y
	fld	%st(1)
	fdiv	%st(1),%st	# x/y
	fmulp	%st,%st(1)	# (x/y)*y
	fsubrp	%st,%st(1)	# x-(x/y)*y
	pushl	$0
	fistpl	(%esp)
	popl	%eax
	ret
");
@


1.23.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.23 2001/12/04 00:00:36 niklas Exp $	*/
d108 5
a112 5
int npxdna(struct proc *);
void npxexit(void);
int npxintr(void *);
static int npxprobe1(struct isa_attach_args *);
static void npxsave1(void);
d119 2
a120 2
int npxprobe(struct device *, void *, void *);
void npxattach(struct device *, struct device *, void *);
d153 25
a177 21
void probeintr(void);
asm (".text\n\t"
"_probeintr:\n\t"
	"ss\n\t"
	"incl	_npx_intrs_while_probing\n\t"
	"pushl	%eax\n\t"
	"movb	$0x20,%al	# EOI (asm in strings loses cpp features)\n\t"
	"outb	%al,$0xa0	# IO_ICU2\n\t"
	"outb	%al,$0x20	# IO_ICU1\n\t"
	"movb	$0,%al\n\t"
	"outb	%al,$0xf0	# clear BUSY# latch\n\t"
	"popl	%eax\n\t"
	"iret\n\t");

void probetrap(void);
asm (".text\n\t"
"_probetrap:\n\t"
	"ss\n\t"
	"incl	_npx_traps_while_probing\n\t"
	"fnclex\n\t"
	"iret\n\t");
d312 15
a326 13
int npx586bug1(int, int);
asm (".text\n\t"
"_npx586bug1:\n\t"
	"fildl	4(%esp)		# x\n\t"
	"fildl	8(%esp)		# y\n\t"
	"fld	%st(1)\n\t"
	"fdiv	%st(1),%st	# x/y\n\t"
	"fmulp	%st,%st(1)	# (x/y)*y\n\t"
	"fsubrp	%st,%st(1)	# x-(x/y)*y\n\t"
	"pushl	$0\n\t"
	"fistpl	(%esp)\n\t"
	"popl	%eax\n\t"
	"ret\n\t");
@


1.23.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d155 1
a155 1
"probeintr:\n\t"
d157 1
a157 1
	"incl	npx_intrs_while_probing\n\t"
d169 1
a169 1
"probetrap:\n\t"
d171 1
a171 1
	"incl	npx_traps_while_probing\n\t"
d310 1
a310 1
"npx586bug1:\n\t"
@


1.22
log
@Revert niklas's broken ICU interrupt handling changes; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.20 2001/11/06 19:53:14 miod Exp $	*/
d540 1
a540 1
	if (cpl != 0 || npx_nointr != 0)
d615 1
a615 1
	if (cpl != 0 || npx_nointr != 0)
@


1.21
log
@Redo the ICU interrupt handling system to better emulate an APIC system.
This is done by representing the current blockings of interrupts with
a priority level instead of an interrupt mask.  This makes it possible to
share implementations for spl* functions/macros between both ICU
and APIC (a must when going MP) systems.  In this process, assign
soft interrupts their own levels to match the way things will be on
APIC systems where they actually will be real interrupts and not just
bits in a pending mask as they are now.
Heavily inspired by Bill Studenmunds SMP work in NetBSD
@
text
@d540 1
a540 1
	if (cpl != IPL_NONE || npx_nointr != 0)
d615 1
a615 1
	if (cpl != IPL_NONE || npx_nointr != 0)
@


1.20
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.19 2001/05/05 23:25:51 art Exp $	*/
d540 1
a540 1
	if (cpl != 0 || npx_nointr != 0)
d615 1
a615 1
	if (cpl != 0 || npx_nointr != 0)
@


1.19
log
@PMAP_NEW and UVM are no longer optional on i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.18 2001/04/09 07:14:16 tholo Exp $	*/
a56 1
#include <vm/vm.h>
@


1.18
log
@Add emulation of Linux features to procfs; mostly from NetBSD.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.17 2000/06/08 22:25:19 niklas Exp $	*/
a56 1
#if defined(UVM)
a58 1
#endif
a392 1
#if defined(UVM)
a393 3
#else
	cnt.v_trap++;
#endif
@


1.17
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.17 2000/06/08 21:12:01 niklas Exp $	*/
d147 4
d228 1
d362 2
a363 1
	if (npx586bug1(4195835, 3145727) != 0)
d365 1
d367 1
@


1.16
log
@cnt.foo -> uvmexp.bar in uvm
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.15 1998/02/22 22:06:11 niklas Exp $	*/
d52 1
@


1.16.6.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.18 2001/04/09 07:14:16 tholo Exp $	*/
a51 1
#include <sys/signalvar.h>
a145 4
extern int i386_fpu_present;
extern int i386_fpu_exception;
extern int i386_fpu_fdivbug;

a222 1
				i386_fpu_exception = 1;
d356 1
a356 2
	if (npx586bug1(4195835, 3145727) != 0) {
		i386_fpu_fdivbug = 1;
a357 1
	}
a358 1
	i386_fpu_present = 1;
@


1.16.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.16.6.1 2001/04/18 16:07:53 niklas Exp $	*/
d57 1
d60 1
d395 1
d397 3
@


1.16.6.3
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.16.6.2 2001/07/04 10:16:55 niklas Exp $	*/
d109 2
a110 1
int npxdna __P((struct cpu_info *));
d113 1
a113 2
static void npxsave1 __P((struct cpu_info *, struct proc *));
static void npxdrop1 __P((struct cpu_info *, struct proc *));
d138 2
d141 1
d387 1
a387 2
	struct cpu_info *ci = curcpu();
	register struct proc *p = ci->ci_fpcurproc;
d410 1
a410 1
	if (ci->ci_fpsaving)
d510 1
a510 1
npxsave1(struct cpu_info *ci, struct proc *p)
d512 1
a512 2
	KDASSERT(ci == curcpu());
	KDASSERT(p->p_addr->u_pcb.pcb_fpcpu == curcpu());
d514 4
a517 4
	fnsave(&p->p_addr->u_pcb.pcb_savefpu);
	ci->ci_fpcurproc = 0;
	p->p_addr->u_pcb.pcb_cr0 |= CR0_TS;
	p->p_addr->u_pcb.pcb_fpcpu = 0;
d519 1
a519 10
}

static inline void
npxdrop1(struct cpu_info *ci, struct proc *p)
{
	KDASSERT(ci == curcpu());

	ci->ci_fpcurproc = 0;
	p->p_addr->u_pcb.pcb_cr0 |= CR0_TS;
	stts();
d530 2
a531 1
npxdna(struct cpu_info *ci)
a533 2
	struct proc *p = ci->ci_curproc;
	struct proc *fpcurproc = ci->ci_fpcurproc;
d541 1
a541 1
	if (lapic_tpr > 0 || ci->ci_fpsaving != 0)
d551 2
a552 2
		if (fpcurproc != 0 && fpcurproc != p)
			npxsave1(ci, fpcurproc);
d554 1
a554 1
			ci->ci_fpsaving = 1;
d557 1
a557 1
			ci->ci_fpsaving = 0;
d559 1
d562 5
a566 2
		ci->ci_fpsaving = 1;
		if (fpcurproc != 0 && fpcurproc != p) {
d568 1
a568 1
			npxsave1(ci, fpcurproc);
d570 1
a570 8
		ci->ci_fpsaving = 0;

		/* 
		 * If our desired fp state is on some other CPU, flush it out.
		 */
		npxsave_proc(p);
		ci->ci_fpcurproc = p;

d594 1
a594 1
npxdrop(struct proc *p)
a595 1
	struct cpu_info *ci = curcpu();
d597 3
a599 12
	p->p_addr->u_pcb.pcb_cr0 |= CR0_TS;

	if (p == ci->ci_fpcurproc) {
		p->p_addr->u_pcb.pcb_fpcpu = 0;
		npxdrop1(ci, p);
	}
#ifdef MULTIPROCESSOR
	else if ((ci = p->p_addr->u_pcb.pcb_fpcpu) != 0) {
		p->p_addr->u_pcb.pcb_fpcpu = 0;
		i386_send_ipi(ci, I386_IPI_FPSAVE);
	}
#endif
d612 1
a612 1
npxsave_cpu(struct cpu_info *ci)
a613 2
	struct proc *p = ci->ci_fpcurproc;
	KDASSERT(ci == curcpu());
d616 2
a617 2
	if (lapic_tpr > 0 || ci->ci_fpsaving != 0)
		panic("npxsave_cpu: masked");
a618 9
	if (p == NULL)
		return;

	if (p->p_addr->u_pcb.pcb_fpcpu == 0) {
		iprintf(("Drop"));
		npxdrop1(ci, p);
		return;
	}
	
d621 1
a621 3
	ci->ci_fpsaving = 1;
	npxsave1(ci, p);
	ci->ci_fpsaving = 0;
d623 1
a624 39

/*
 * Save p's FPU state, which may be on this processor or another processor.
 *
 * The FNSAVE instruction clears the FPU state.  Rather than reloading the FPU
 * immediately, we clear fpcurproc and turn on CR0_TS to force a DNA and a
 * reload of the FPU state the next time we try to use it.  This routine
 * is only called when forking, core dumping, or debugging, or swapping,
 * so the lazy reload at worst forces us to trap once per fork(), and at best
 * saves us a reload once per fork().
  */
 void
npxsave_proc(struct proc *p)
{
	struct cpu_info *ci;
	
	KDASSERT(p->p_addr != NULL);
	
	iprintf(("Save %p\n", p));

	ci = p->p_addr->u_pcb.pcb_fpcpu;
	if (ci == NULL)
		return;

	if (ci == curcpu()) {
		npxsave_cpu(ci);
	} else {
#ifndef MULTIPROCESSOR
		panic("FP state on other cpu on uniprocessor?");
#else
		iprintf(("Send IPI\n"));
		do {
			i386_send_ipi(ci, I386_IPI_FPSAVE);
			DELAY(1);
		} while ((ci = p->p_addr->u_pcb.pcb_fpcpu) != NULL);
#endif
	}
}

@


1.16.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 1
d550 1
a550 1
	if (lapic_tpr > IPL_NONE || ci->ci_fpsaving != 0)
d640 1
a640 1
	if (lapic_tpr > IPL_NONE || ci->ci_fpsaving != 0)
@


1.16.6.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.16.6.4 2001/11/13 21:00:52 niklas Exp $	*/
@


1.16.6.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d151 14
a164 12
asm (".text\n\t"
"_probeintr:\n\t"
	"ss\n\t"
	"incl	_npx_intrs_while_probing\n\t"
	"pushl	%eax\n\t"
	"movb	$0x20,%al	# EOI (asm in strings loses cpp features)\n\t"
	"outb	%al,$0xa0	# IO_ICU2\n\t"
	"outb	%al,$0x20	# IO_ICU1\n\t"
	"movb	$0,%al\n\t"
	"outb	%al,$0xf0	# clear BUSY# latch\n\t"
	"popl	%eax\n\t"
	"iret\n\t");
d167 8
a174 6
asm (".text\n\t"
"_probetrap:\n\t"
	"ss\n\t"
	"incl	_npx_traps_while_probing\n\t"
	"fnclex\n\t"
	"iret\n\t");
d310 14
a323 12
asm (".text\n\t"
"_npx586bug1:\n\t"
	"fildl	4(%esp)		# x\n\t"
	"fildl	8(%esp)		# y\n\t"
	"fld	%st(1)\n\t"
	"fdiv	%st(1),%st	# x/y\n\t"
	"fmulp	%st,%st(1)	# (x/y)*y\n\t"
	"fsubrp	%st,%st(1)	# x-(x/y)*y\n\t"
	"pushl	$0\n\t"
	"fistpl	(%esp)\n\t"
	"popl	%eax\n\t"
	"ret\n\t");
@


1.16.6.7
log
@Merge in -current from about a week ago
@
text
@d108 5
a112 5
int npxdna(struct cpu_info *);
int npxintr(void *);
static int npxprobe1(struct isa_attach_args *);
static void npxsave1(struct cpu_info *, struct proc *);
static void npxdrop1(struct cpu_info *, struct proc *);
d119 2
a120 2
int npxprobe(struct device *, void *, void *);
void npxattach(struct device *, struct device *, void *);
d150 1
a150 1
void probeintr(void);
d164 1
a164 1
void probetrap(void);
d305 1
a305 1
int npx586bug1(int, int);
@


1.16.6.8
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.16.6.7 2002/03/28 10:31:04 niklas Exp $	*/
d152 1
a152 1
"probeintr:\n\t"
d154 1
a154 1
	"incl	npx_intrs_while_probing\n\t"
d166 1
a166 1
"probetrap:\n\t"
d168 1
a168 1
	"incl	npx_traps_while_probing\n\t"
d307 1
a307 1
"npx586bug1:\n\t"
@


1.16.6.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.16.6.8 2003/05/13 19:42:08 ho Exp $	*/
d24 5
a28 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.16.6.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d5 1
a5 1
#define IPRINTF(x)	printf x
d7 1
a7 1
#define	IPRINTF(x)
d96 5
d104 1
a140 32
#ifdef I686_CPU
#define        fxsave(addr)            __asm("fxsave %0" : "=m" (*addr))
#define        fxrstor(addr)           __asm("fxrstor %0" : : "m" (*addr))
#endif /* I686_CPU */

static __inline void
fpu_save(union savefpu *addr)
{

#ifdef I686_CPU
	if (i386_use_fxsave) {
		fxsave(&addr->sv_xmm);
		/* FXSAVE doesn't FNINIT like FNSAVE does -- so do it here. */
		fninit();
	} else
#endif /* I686_CPU */
		fnsave(&addr->sv_87);
}

static int
npxdna_notset(struct cpu_info *ci)
{
	panic("npxdna vector not initialized");
}

int    (*npxdna_func)(struct cpu_info *) = npxdna_notset;
int    npxdna_s87(struct cpu_info *);
#ifdef I686_CPU
int    npxdna_xmm(struct cpu_info *);
#endif /* I686_CPU */
void   npxexit(void);

a207 1
			delay(1);
a229 2
#else
	npx_intrs_while_probing = npx_traps_while_probing = 0;
a230 1

a351 7

#ifdef I686_CPU
	if (i386_use_fxsave)
		npxdna_func = npxdna_xmm;
	else
#endif /* I686_CPU */
		npxdna_func = npxdna_s87;
d375 1
a375 1
	union savefpu *addr;
d381 1
a381 1
	IPRINTF(("Intr"));
d403 1
a403 1
	addr = &p->p_addr->u_pcb.pcb_savefpu;
d408 1
a408 1
	fpu_save(addr);
d411 1
a411 1
	 * Restore control word (was clobbered by fpu_save).
d413 1
a413 8
	if (i386_use_fxsave) {
		fldcw(&addr->sv_xmm.sv_env.en_cw);
		/*
		 * FNINIT doesn't affect MXCSR or the XMM registers;
		 * no need to re-load MXCSR here.
		 */
	} else
		fldcw(&addr->sv_87.sv_env.en_cw);
d423 2
a424 7
	if (i386_use_fxsave) {
	        addr->sv_xmm.sv_ex_sw = addr->sv_xmm.sv_env.en_sw;
	        addr->sv_xmm.sv_ex_tw = addr->sv_xmm.sv_env.en_tw;
	} else {
	        addr->sv_87.sv_ex_sw = addr->sv_87.sv_env.en_sw;
	        addr->sv_87.sv_ex_tw = addr->sv_87.sv_env.en_tw;
	}
d448 1
a448 1
		if (addr->sv_87.sv_ex_sw & EN_SW_IE)
d451 1
a451 1
		else if (addr->sv_87.sv_ex_sw & EN_SW_DE)
d454 1
a454 1
		else if (addr->sv_87.sv_ex_sw & EN_SW_ZE)
d456 1
a456 1
		else if (addr->sv_87.sv_ex_sw & EN_SW_OE)
d458 1
a458 1
		else if (addr->sv_87.sv_ex_sw & EN_SW_UE)
d460 1
a460 1
		else if (addr->sv_87.sv_ex_sw & EN_SW_PE)
d496 1
a496 1
static __inline void
d502 1
a502 1
	fpu_save(&p->p_addr->u_pcb.pcb_savefpu);
d509 1
a509 1
static __inline void
a525 52

/*
 * XXX It is unclear if the code below is correct in the multiprocessor
 * XXX case.  Check the NetBSD sources once again to be sure.
 */
#ifdef I686_CPU
int
npxdna_xmm(struct cpu_info *ci)
{
	struct proc *p = ci->ci_curproc;
	struct proc *fpcurproc = ci->ci_fpcurproc;

#ifdef DIAGNOSTIC
	if (lapic_tpr > IPL_NONE || ci->ci_fpsaving != 0)
	        panic("npxdna_xmm: masked");
#endif

	p->p_addr->u_pcb.pcb_cr0 &= ~CR0_TS;
	clts();

	/*
	 * Initialize the FPU state to clear any exceptions.  If someone else
	 * was using the FPU, save their state (which does an implicit
	 * initialization).
	 */
	ci->ci_fpsaving = 1;
	if (fpcurproc != 0 && fpcurproc != p) {
	        IPRINTF(("Save"));
	        npxsave1(ci, fpcurproc);
	} else {
	        IPRINTF(("Init"));
	        fninit();
	        fwait();
	}
	ci->ci_fpsaving = 0;

	/* 
	 * If our desired fp state is on some other CPU, flush it out.
	 */
	npxsave_proc(p);
	ci->ci_fpcurproc = p;

	if ((p->p_md.md_flags & MDP_USEDFPU) == 0) {
		fldcw(&p->p_addr->u_pcb.pcb_savefpu.sv_xmm.sv_env.en_cw);
		p->p_md.md_flags |= MDP_USEDFPU;
	} else
		fxrstor(&p->p_addr->u_pcb.pcb_savefpu.sv_xmm);

	return (1);
}
#endif /* I686_CPU */

d527 1
a527 1
npxdna_s87(struct cpu_info *ci)
d534 1
a534 1
		IPRINTF(("Emul"));
d540 1
a540 1
		panic("npxdna_s87: masked");
d548 1
a548 1
		IPRINTF(("Init"));
d561 1
a561 1
			IPRINTF(("Save"));
d585 1
a585 1
		frstor(&p->p_addr->u_pcb.pcb_savefpu.sv_87);
d636 1
a636 1
		IPRINTF(("Drop"));
d641 1
a641 1
	IPRINTF(("Fork"));
d666 1
a666 1
	IPRINTF(("Save %p\n", p));
d678 1
a678 1
		IPRINTF(("Send IPI\n"));
@


1.16.6.11
log
@Import NetBSD updates to NPX logic, and IPI API
@
text
@d101 2
d411 1
a411 1
	struct proc *p = ci->ci_fpcurproc;
a435 10

#ifdef DIAGNOSTIC
	/*
	 * At this point, fpcurproc should be curproc.  If it wasn't, the TS
	 * bit should be set, and we should have gotten a DNA exception.
	 */
	if (p != curproc)
		panic("npxintr: wrong process");
#endif

d437 2
a438 2
	 * Find the address of fpcurproc's saved FPU state.  (Given the
	 * invariant above, this is always the one in curpcb.)
d537 32
d584 2
a585 2
	struct proc *p;
	int s;
d587 7
a593 4
	if (ci->ci_fpsaving) {
		printf("recursive npx trap; cr0=%x\n", rcr0());
		return (0);
	}
a594 9
	s = splipi();		/* lock out IPI's while we clean house.. */
#ifdef MULTIPROCESSOR
	p = ci->ci_curproc;
#else
	p = curproc;
#endif
	/*
	 * XXX should have a fast-path here when no save/restore is necessary
	 */
d600 4
a603 3
	if (ci->ci_fpcurproc != NULL) {
		IPRINTF(("Save"));
		npxsave_cpu(ci, 1);
d605 3
a607 5
		clts();
		IPRINTF(("Init"));
		fninit();
		fwait();
		stts();
d609 1
a609 1
	splx(s);
d611 4
a614 10
	KDASSERT(ci->ci_fpcurproc == NULL);
#ifndef MULTIPROCESSOR
	KDASSERT(p->p_addr->u_pcb.pcb_fpcpu == NULL);
#else
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		npxsave_proc(p, 1);
#endif
	p->p_addr->u_pcb.pcb_cr0 &= ~CR0_TS;
	clts();
	s = splipi();
a615 2
	p->p_addr->u_pcb.pcb_fpcpu = ci;
	splx(s);
d620 1
a620 1
	} else {
a621 1
	}
d630 3
a632 2
	struct proc *p;
	int s;
d634 2
a635 4
	KDASSERT(i386_use_fxsave == 0);

	if (ci->ci_fpsaving) {
		printf("recursive npx trap; cr0=%x\n", rcr0());
d639 3
a641 5
	s = splipi();		/* lock out IPI's while we clean house.. */
#ifdef MULTIPROCESSOR
	p = ci->ci_curproc;
#else
	p = curproc;
a643 25
	IPRINTF(("%s: dna for %p\n", ci->ci_dev->dv_xname, p));
	/*
	 * If someone else was using our FPU, save their state (which does an
	 * implicit initialization); otherwise, initialize the FPU state to
	 * clear any exceptions.
	 */
	if (ci->ci_fpcurproc != NULL)
		npxsave_cpu(ci, 1);
	else {
		clts();
		IPRINTF(("%s: fp init\n", ci->ci_dev->dv_xname));
		fninit();
		fwait();
		stts();
	}
	splx(s);

	IPRINTF(("%s: done saving\n", ci->ci_dev->dv_xname));
	KDASSERT(ci->ci_fpcurproc == NULL);
#ifndef MULTIPROCESSOR
	KDASSERT(p->p_addr->u_pcb.pcb_fpcpu == NULL);
#else
	if (p->p_addr->u_pcb.pcb_fpcpu != NULL)
		npxsave_proc(p, 1);
#endif
a645 4
	s = splipi();
	ci->ci_fpcurproc = p;
	p->p_addr->u_pcb.pcb_fpcpu = ci;
	splx(s);
a647 1
		fldcw(&p->p_addr->u_pcb.pcb_savefpu.sv_87.sv_env.en_cw);
d649 10
d660 13
d692 3
d696 1
a696 1
npxsave_cpu(struct cpu_info *ci, int save)
d698 3
a700 2
	struct proc *p;
	int s;
d702 25
d729 4
a732 1
	p = ci->ci_fpcurproc;
d736 4
a739 25
	IPRINTF(("%s: fp cpu %s %p\n", ci->ci_dev->dv_xname,
	    save? "save" : "flush", p));

	if (save) {
#ifdef DIAGNOSTIC
		if (ci->ci_fpsaving != 0)
			panic("npxsave_cpu: recursive save!");
#endif
		 /*
		  * Set ci->ci_fpsaving, so that any pending exception will be
		  * thrown away.  (It will be caught again if/when the FPU
		  * state is restored.)
		  *
		  * XXX on i386 and earlier, this routine should always be
		  * called at spl0; if it might called with the NPX interrupt
		  * masked, it would be necessary to forcibly unmask the NPX
		  * interrupt so that it could succeed.
		  * XXX this is irrelevant on 486 and above (systems
		  * which report FP failures via traps rather than irq13).
		  * XXX punting for now..
		  */
		clts();
		ci->ci_fpsaving = 1;
		fpu_save(&p->p_addr->u_pcb.pcb_savefpu);
		ci->ci_fpsaving = 0;
d741 6
a746 5

	/*
	 * We set the TS bit in the saved CR0 for this process, so that it
	 * will get a DNA exception on any FPU instruction and force a reload.
	 */
a747 6
	p->p_addr->u_pcb.pcb_cr0 |= CR0_TS;

	s = splipi();
	p->p_addr->u_pcb.pcb_fpcpu = NULL;
	ci->ci_fpcurproc = NULL;
	splx(s);
d759 1
a759 1
 */
d761 1
a761 1
npxsave_proc(struct proc *p, int save)
d763 2
a764 3
	struct cpu_info *ci = curcpu();
	struct cpu_info *oci;

d766 2
a767 1
	KDASSERT(p->p_flag & P_INMEM);
d769 2
a770 2
	oci = p->p_addr->u_pcb.pcb_fpcpu;
	if (oci == NULL)
d773 2
a774 8
	IPRINTF(("%s: fp proc %s %p\n", ci->ci_dev->dv_xname,
	    save? "save" : "flush", p));

#if defined(MULTIPROCESSOR)
	if (oci == ci) {
		int s = splipi();
		npxsave_cpu(ci, save);
		splx(s);
d776 2
a777 23
#ifdef DIAGNOSTIC
		int spincount;
#endif

		IPRINTF(("%s: fp ipi to %s %s %p\n",
		    ci->ci_dev->dv_xname,
		    oci->ci_dev->dv_xname,
		    save? "save" : "flush", p));

		i386_send_ipi(oci,
		    save ? I386_IPI_SYNCH_FPU : I386_IPI_FLUSH_FPU);

#ifdef DIAGNOSTIC
		spincount = 0;
#endif
		while (p->p_addr->u_pcb.pcb_fpcpu != NULL)
#ifdef DIAGNOSTIC
		{
			spincount++;
			if (spincount > 10000000) {
				panic("fp_save ipi didn't");
			}
		}
d779 5
a783 2
		__splbarrier();		/* XXX replace by generic barrier */
		;
a785 4
#else
	KASSERT(ci->ci_fpcurproc == p);
	npxsave_cpu(ci, save);
#endif
@


1.16.6.12
log
@a small step towards an integrated PIC/APIC system: move isa/icu.h to
include/i8259.h, and adapt the ACK/MASK/UNMASK macros so we can
reuse the API for APICs.  From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.16.6.11 2004/02/20 22:19:55 niklas Exp $	*/
a61 1
#include <machine/i8259.h>
d65 1
@


1.16.6.13
log
@cleanup debug printouts, add an fwait in the save func, it may be needed
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.16.6.12 2004/03/23 08:02:56 niklas Exp $	*/
a56 1
#include <machine/npx.h>
a342 13
void
npxinit(struct cpu_info *ci)
{
	lcr0(rcr0() & ~(CR0_EM|CR0_TS));
	fninit();
	if (npx586bug1(4195835, 3145727) != 0) {
		i386_fpu_fdivbug = 1;
		printf("%s: WARNING: Pentium FDIV bug detected!\n",
		    ci->ci_dev.dv_xname);
	}
	lcr0(rcr0() | (CR0_TS));
}

d372 7
a378 1
	npxinit(&cpu_info_primary);
d416 1
a416 1
	IPRINTF(("%s: fp intr\n", ci->ci_dev.dv_xname));
d418 1
a418 1
	if (p == NULL || npx_type == NPX_NONE) {
d547 1
a547 1
 * If we were the last process to use the FPU, we can simply return.
a568 1

a573 4

	IPRINTF(("%s: dna for %lx%s\n", ci->ci_dev.dv_xname, (u_long)p,
	    (p->p_md.md_flags & MDP_USEDFPU) ? " (used fpu)" : ""));

d583 1
a583 2
		IPRINTF(("%s: fp save %lx\n", ci->ci_dev.dv_xname,
		    (u_long)ci->ci_fpcurproc));
d587 1
a587 1
		IPRINTF(("%s: fp init\n", ci->ci_dev.dv_xname));
a593 1
	IPRINTF(("%s: done saving\n", ci->ci_dev.dv_xname));
d639 1
a639 3
	IPRINTF(("%s: dna for %lx%s\n", ci->ci_dev.dv_xname, (u_long)p,
	    (p->p_md.md_flags & MDP_USEDFPU) ? " (used fpu)" : ""));

d645 1
a645 3
	if (ci->ci_fpcurproc != NULL) {
		IPRINTF(("%s: fp save %lx\n", ci->ci_dev.dv_xname,
		    (u_long)ci->ci_fpcurproc));
d647 1
a647 1
	} else {
d649 1
a649 1
		IPRINTF(("%s: fp init\n", ci->ci_dev.dv_xname));
d656 1
a656 1
	IPRINTF(("%s: done saving\n", ci->ci_dev.dv_xname));
a693 8
/*
 * The FNSAVE instruction clears the FPU state.  Rather than reloading the FPU
 * immediately, we clear fpcurproc and turn on CR0_TS to force a DNA and a
 * reload of the FPU state the next time we try to use it.  This routine
 * is only called when forking, core dumping, or debugging, or swapping,
 * so the lazy reload at worst forces us to trap once per fork(), and at best
 * saves us a reload once per fork().
 */
d706 2
a707 2
	IPRINTF(("%s: fp cpu %s %lx\n", ci->ci_dev.dv_xname,
	    save ? "save" : "flush", (u_long)p));
a730 2
		/* It is unclear if this is needed. */
		fwait();
d748 7
d769 2
a770 2
	IPRINTF(("%s: fp proc %s %lx\n", ci->ci_dev.dv_xname,
	    save ? "save" : "flush", (u_long)p));
d782 4
a785 2
		IPRINTF(("%s: fp ipi to %s %s %lx\n", ci->ci_dev.dv_xname,
		    oci->ci_dev.dv_xname, save ? "save" : "flush", (u_long)p));
d797 1
a797 1
			if (spincount > 100000000) {
@


1.15
log
@GCC 2.8 Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.14 1997/04/17 03:44:52 tholo Exp $	*/
d56 5
d386 3
d390 1
@


1.14
log
@Do interrupt time accounting by running interrupt handlers with a seperate
code segment selector (otherwise identical to the standard kernel code
selector); idea by Dave Richards <richards@@zso.dec.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: npx.c,v 1.13 1997/02/08 23:36:58 tholo Exp $	*/
d379 1
d465 2
a466 1
		trapsignal(p, SIGFPE, T_ARITHTRAP, code, frame->if_eip);
@


1.13
log
@Provide more information on FP exceptions
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d272 2
a273 2
	setgate(&idt[irq], probeintr, 0, SDT_SYS386IGT, SEL_KPL);
	setgate(&idt[16], probetrap, 0, SDT_SYS386TGT, SEL_KPL);
@


1.12
log
@add type & union sigval args to sendsig/trapsignal
@
text
@d1 1
d443 1
a443 1
#ifdef notyet
d448 5
a452 3
		code = XXX_ENCODE(addr->sv_ex_sw);
#else
		code = 0;	/* XXX */
d454 11
a464 1
		trapsignal(p, SIGFPE, code, 0, 0);	/* XXX type? */
@


1.11
log
@add another parameter to trapsignal() and sendsig() -- fault addr to be
delivered with in the siginfo information
@
text
@d451 1
a451 1
		trapsignal(p, SIGFPE, code, 0);
@


1.10
log
@Add:
	* GPL_MATH_EMULATE: fpemul
	* ALWAYS_MATH_EMULATE: causes npx probe to always fail.
	* better fp context in struct pcb.
@
text
@d451 1
a451 1
		trapsignal(p, SIGFPE, code);
@


1.9
log
@sync
@
text
@d175 1
d232 1
d402 1
a402 1
	addr = &p->p_addr->u_pcb.pcb_savefpu;
@


1.8
log
@sync with 0504; prototype changes
@
text
@d1 1
a1 1
/*	$NetBSD: npx.c,v 1.56 1996/05/03 19:14:58 christos Exp $	*/
d56 1
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$NetBSD: npx.c,v 1.55 1996/04/11 22:15:22 cgd Exp $	*/
a106 1
void npxsave __P((void));
d340 2
@


1.6
log
@Fix back wrong patches.
@
text
@d1 1
a1 1
/*	$NetBSD: npx.c,v 1.53 1996/01/07 02:00:31 mycroft Exp $	*/
d118 6
a123 2
struct cfdriver npxcd = {
	NULL, "npx", npxprobe, npxattach, DV_DULL, sizeof(struct npx_softc)
d332 2
a333 2
		sc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_NONE,
		    npxintr, 0, sc->sc_dev.dv_xname);
@


1.5
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d329 1
a329 1
		    npxintr, 0);
@


1.4
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d329 1
a329 1
		    npxintr, 0, "npx");
@


1.3
log
@from netbsd: Put #includes in the right order
@
text
@d329 1
a329 1
		    npxintr, 0);
@


1.2
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
@
text
@d1 1
a1 1
/*	$NetBSD: npx.c,v 1.51 1995/10/10 04:46:09 mycroft Exp $	*/
d62 2
a64 2
#include <dev/isa/isavar.h>
#include <dev/isa/isareg.h>
@


1.1
log
@Initial revision
@
text
@d328 2
a329 2
		sc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE,
		    ISA_IPL_NONE, npxintr, 0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
