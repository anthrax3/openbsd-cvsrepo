head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.8
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.6
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.2
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.5.0.4
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.6
date	2016.06.13.23.51.58;	author dlg;	state Exp;
branches;
next	1.5;
commitid	pePIrytkQAoqTKCZ;

1.5
date	2015.03.03.23.50.36;	author aoyama;	state Exp;
branches;
next	1.4;
commitid	rOCVWqdqaeULSp8N;

1.4
date	2015.02.18.22.42.04;	author aoyama;	state Exp;
branches;
next	1.3;
commitid	cmnVKI7klXkOPHkb;

1.3
date	2014.12.31.11.38.27;	author aoyama;	state Exp;
branches;
next	1.2;
commitid	FnYxGvyQdtH4ly2v;

1.2
date	2014.12.28.13.03.18;	author aoyama;	state Exp;
branches;
next	1.1;
commitid	aLavKPgF3JbRlmVF;

1.1
date	2014.12.19.13.17.35;	author aoyama;	state Exp;
branches;
next	;
commitid	IpU9SvwyHLVnnHwt;


desc
@@


1.6
log
@rename raiseipl to splraise()

another step toward making splraise an MI api.

ok aoyama@@
@
text
@/*	$OpenBSD: cbus.c,v 1.5 2015/03/03 23:50:36 aoyama Exp $	*/

/*
 * Copyright (c) 2014 Kenji Aoyama.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * PC-9801 extension board slot bus ('C-bus') driver for LUNA-88K2.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/systm.h>

#include <machine/asm_macro.h>	/* ff1() */
#include <machine/autoconf.h>
#include <machine/board.h>	/* PC_BASE */

#include <luna88k/cbus/cbusvar.h>
#include <luna88k/luna88k/isr.h>	/* isrlink_autovec() */

#if 0
#define CBUS_DEBUG
#endif

#include "necsb.h"
#include "pcic.h"

static struct cbus_attach_args cbus_devs[] = {
#if NNECSB > 0
	{ "necsb",	-1 },	/* PC-9801-86 sound board */
#endif
#if NPCIC > 0
	{ "pcic",	-1 },	/* PC-9801-102 & PC-9821X[AE]-01 PCMCIA board */
#endif
	{ "pcex",	-1 }	/* C-bus "generic" driver */
};

/*
 * C-bus interrupt status register
 */
#define CBUS_INTR_STAT_REG	(PC_BASE + 0x1100000)
volatile u_int8_t *cbus_isreg = (u_int8_t *)CBUS_INTR_STAT_REG;

/* autoconf stuff */
int cbus_match(struct device *, void *, void *);
void cbus_attach(struct device *, struct device *, void *);
int cbus_print(void *, const char *);

struct cbus_softc {
	struct device sc_dev;
	struct cbus_isr_t cbus_isr[NCBUSISR];
	u_int8_t registered;
};

const struct cfattach cbus_ca = {
	sizeof(struct cbus_softc), cbus_match, cbus_attach
};

struct cfdriver cbus_cd = {
	NULL, "cbus", DV_DULL
};

/* prototypes */
void cbus_isrdispatch(int);
int cbus_intr(void *);

int
cbus_match(struct device *parent, void *cf, void *aux)
{
	struct mainbus_attach_args *ma = aux;

	if (strcmp(ma->ma_name, cbus_cd.cd_name))
		return 0;
#if 0
	if (badaddr((vaddr_t)ma->ma_addr, 4))
		return 0;
#endif
	return 1;
}

void
cbus_attach(struct device *parent, struct device *self, void *args)
{
	struct cbus_softc *sc = (struct cbus_softc *)self;
	struct mainbus_attach_args *ma = args;
	int i;

	for (i = 0; i < NCBUSISR; i++) {
		struct cbus_isr_t *ci = &sc->cbus_isr[i];
		ci->isr_func = NULL;
		ci->isr_arg = NULL;
		ci->isr_intlevel = ci->isr_ipl = -1;
		/* clearing interrupt flags (INT0-INT6) */
		*cbus_isreg = (u_int8_t)(6 - i);
	}
	sc->registered = 0x00;

	/* register C-bus interrupt service routine on mainbus */
	isrlink_autovec(cbus_intr, (void *)self, ma->ma_ilvl,
	    ISRPRI_TTY, self->dv_xname);

	printf("\n");

	for (i = 0; i < sizeof(cbus_devs)/sizeof(cbus_devs[0]); i++)
		config_found(self, &cbus_devs[i], cbus_print);

	return;
}

int
cbus_print(void *aux, const char *pnp)
{
	struct cbus_attach_args *caa = aux;

	if (pnp)
		printf("%s at %s", caa->ca_name, pnp);	/* not configured */
	if (caa->ca_intlevel != -1)
		printf(" int %d", caa->ca_intlevel);

	return UNCONF;
}

/*
 * Register a C-bus interrupt service routine.
 */
int
cbus_isrlink(int (*func)(void *), void *arg, int intlevel, int ipl,
    const char *name)
{
	struct cbus_softc *sc = NULL;
	struct cbus_isr_t *ci;

	if (cbus_cd.cd_ndevs != 0)
		sc = cbus_cd.cd_devs[0];
	if (sc == NULL)
		panic("cbus_isrlink: can't find cbus_softc");

#ifdef DIAGNOSTIC
	if (intlevel < 0 || intlevel >= NCBUSISR) {
		printf("cbus_isrlink: bad INT level %d\n", intlevel);
		return -1;
	}
#endif

	ci = &sc->cbus_isr[intlevel];

	if (ci->isr_func != NULL) {
		printf("cbus_isrlink: isr already assigned on INT%d\n",
		    intlevel);
		return -1;
	}

	/* set the entry */
	ci->isr_func = func;
	ci->isr_arg = arg;
	ci->isr_intlevel = intlevel;
	ci->isr_ipl = ipl;
	evcount_attach(&ci->isr_count, name, &ci->isr_intlevel);
	sc->registered |= (1 << (6 - intlevel));
#ifdef CBUS_DEBUG
	printf("cbus_isrlink: sc->registered = 0x%02x\n", sc->registered);
#endif

	return 0;
}

/*
 * Unregister a C-bus interrupt service routine.
 */
int
cbus_isrunlink(int (*func)(void *), int intlevel)
{
	struct cbus_softc *sc = NULL;
	struct cbus_isr_t *ci;

	if (cbus_cd.cd_ndevs != 0)
		sc = cbus_cd.cd_devs[0];
	if (sc == NULL)
		panic("cbus_isrunlink: can't find cbus_softc");

#ifdef DIAGNOSTIC
	if (intlevel < 0 || intlevel >= NCBUSISR) {
		printf("cbus_isrunlink: bad INT level %d\n", intlevel);
		return -1;
	}
#endif

	ci = &sc->cbus_isr[intlevel];

	if (ci->isr_func == NULL) {
		printf("cbus_isrunlink: isr not assigned on INT%d\n", intlevel);
		return -1;
	}

	/* reset the entry */
	ci->isr_func = NULL;
	ci->isr_arg = NULL;
	ci->isr_intlevel = ci->isr_ipl = -1;
	evcount_detach(&ci->isr_count);
	sc->registered &= ~(1 << (6 - intlevel));

	/* clear interrupt flags */
	*cbus_isreg = (u_int8_t)(6 - intlevel);
#ifdef CBUS_DEBUG
	printf("cbus_isrunlink: sc->registered = 0x%02x\n", sc->registered);
#endif

	return 0;
}

/*
 * Dispatch C-bus interrupt service routines.
 */
void
cbus_isrdispatch(int intlevel)
{
	int rc, s;
	static int straycount, unexpected;
	struct cbus_softc *sc = NULL;
	struct cbus_isr_t *ci;

	if (cbus_cd.cd_ndevs != 0)
		sc = cbus_cd.cd_devs[0];
	if (sc == NULL)
		panic("cbus_isrdispatch: can't find cbus_softc");

#ifdef DIAGNOSTIC
	if (intlevel < 0 || intlevel >= NCBUSISR)
		panic("cbus_isrdispatch: bad INT level 0x%d", intlevel);
#endif

	ci = &sc->cbus_isr[intlevel];

	if (ci->isr_func == NULL) {
		printf("cbus_isrdispatch: INT%d unexpected\n", intlevel);
		if (++unexpected > 10)
			panic("too many unexpected interrupts");
		return;
	}

	s = splraise(ci->isr_ipl);
	rc = ci->isr_func(ci->isr_arg);
	splx(s);

	if (rc != 0)
		ci->isr_count.ec_count++;

	if (rc)
		straycount = 0;
	else if (++straycount > 50)
		panic("cbus_isrdispatch: too many stray interrupts");
	else
		printf("cbus_isrdispatch: stray INT%d, IPL=%d\n", intlevel,
		    ci->isr_ipl);
}

/*
 * Return registered status of interrupt service routines.
 */
u_int8_t
cbus_intr_registered(void)
{
	struct cbus_softc *sc = NULL;

	if (cbus_cd.cd_ndevs != 0)
		sc = cbus_cd.cd_devs[0];
	if (sc == NULL)
		panic("cbus_intr_used: can't find cbus_softc");

	return sc->registered;
}

/*
 * Note about interrupt on PC-9801 extension board slot
 *
 * PC-9801 extension board slot bus (so-called 'C-bus' in Japan) use 8 own
 * interrupt levels, INT0-INT6, and NMI.  On LUNA-88K2, they all trigger
 * level 4 interrupt on mainbus, so we need to check the dedicated interrupt
 * status register to know which C-bus interrupt is occurred.
 *
 * The interrupt status register for C-bus is located at
 * (u_int8_t *)CBUS_INTR_STAT. Each bit of the register becomes 0 when
 * corresponding C-bus interrupt has occurred, otherwise 1.
 *
 * bit 7 = NMI(?)
 * bit 6 = INT0
 * bit 5 = INT1
 *  :
 * bit 0 = INT6
 *
 * To clear the C-bus interrupt flag, write the corresponding 'bit' number
 * (as u_int_8) to the register.  For example, if you want to clear INT1,
 * you should write '5' like:
 *   *(u_int8_t *)CBUS_INTR_STAT = 5;
 */

/*
 * Interrupt handler on mainbus.
 */
int
cbus_intr(void *arg)
{
	struct cbus_softc *sc = (struct cbus_softc *)arg;
	u_int8_t intr_status;
	int n;

	/*
	 * LUNA-88K2's interrupt level 4 is shared with other devices,
	 * such as le(4), for example.  So we check:
	 * - the value of our C-bus interrupt status register, and
	 * - if the INT level is what we are looking for.
	 */
	intr_status = *cbus_isreg & sc->registered;
	if (intr_status == sc->registered) return 0;	/* Not for me */

#ifdef CBUS_DEBUG
	printf("cbus_intr: called, *cbus_isreg=0x%02x, registered = 0x%02x\n",
	    *cbus_isreg, sc->registered);
#endif
	/* Make the bit pattern that we should proces */
	intr_status = intr_status ^ sc->registered;
#ifdef CBUS_DEBUG
	printf("cbus_intr: processing 0x%02x\n", intr_status);
#endif

	/* Process, and clear each interrupt flag */
	while ((n = ff1(intr_status)) != 32) {
		cbus_isrdispatch(6 - n);
		*cbus_isreg = (u_int8_t)n;
		intr_status &= ~(1 << n); 
	}

	return 1;
}
@


1.5
log
@Add pcic(4) support on luna88k.

This is basically glue codes attaching pcic(4) at cbus(4/luna88k),
based on src/sys/dev/isa/i82365_isa{,subr}.c.

Tested on some ne(4) network interface cards, wdc(4) with a CF memory
card, and com(4) with an old XJACK modem card.  Currently wi(4) does
not work yet.

suggestions and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cbus.c,v 1.4 2015/02/18 22:42:04 aoyama Exp $	*/
d255 1
a255 1
	s = raiseipl(ci->isr_ipl);	/* splraise() */
@


1.4
log
@Some modifications on cbus(4):

- Handle interrupt priority level (IPL_XXX) in cbus_isrdispatch().
- Add a function that returns the status of registered cbus(4) interrupt
  levels.

suggestions and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cbus.c,v 1.3 2014/12/31 11:38:27 aoyama Exp $	*/
d40 1
d45 3
@


1.3
log
@Correct evcount_attach argument on cbus(4).

The third argument of evcount_attach() should point some permanent
variable, not an automatic variable.  Now "vmstat -i" correctly prints
C-bus interrupt level number as irq, on C-bus devices.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cbus.c,v 1.2 2014/12/28 13:03:18 aoyama Exp $	*/
a73 2
int cbus_isrlink(int (*)(void *), void *, int, const char *);
int cbus_isrunlink(int (*)(void *), int);
d102 1
a102 1
		ci->isr_intlevel = -1;
d104 1
a104 1
		*cbus_isreg = (u_int8_t)i;
d106 1
d137 2
a138 1
cbus_isrlink(int (*func)(void *), void *arg, int ipl, const char *name)
d149 2
a150 2
	if (ipl < 0 || ipl >= NCBUSISR) {
		printf("cbus_isrlink: bad ipl %d\n", ipl);
d155 1
a155 1
	ci = &sc->cbus_isr[ipl];
d158 2
a159 1
		printf("cbus_isrlink: isr already assigned on INT%d\n", ipl);
d166 2
a167 1
	ci->isr_intlevel = ipl;
d169 1
a169 1
	sc->registered |= (1 << (6 - ipl));
d181 1
a181 1
cbus_isrunlink(int (*func)(void *), int ipl)
d192 2
a193 2
	if (ipl < 0 || ipl >= NCBUSISR) {
		printf("cbus_isrunlink: bad ipl %d\n", ipl);
d198 1
a198 1
	ci = &sc->cbus_isr[ipl];
d201 1
a201 1
		printf("cbus_isrunlink: isr not assigned on INT%d\n", ipl);
d208 1
a208 1
	ci->isr_intlevel = -1;
d210 4
a213 1
	sc->registered &= ~(1 << (6 - ipl));
d225 1
a225 1
cbus_isrdispatch(int ipl)
d227 1
a227 1
	int rc;
d238 2
a239 2
	if (ipl < 0 || ipl >= NCBUSISR)
		panic("cbus_isrdispatch: bad ipl 0x%d", ipl);
d242 1
a242 1
	ci = &sc->cbus_isr[ipl];
d245 1
a245 1
		printf("cbus_isrdispatch: ipl %d unexpected\n", ipl);
d251 1
d253 2
d263 18
a280 1
		printf("cbus_isrdispatch: stray level %d interrupt\n", ipl);
d289 1
a289 1
 * status  register to know which C-bus interrupt is occurred.
@


1.2
log
@Add an audio driver, necsb(4), for NEC PC-9801-86 sound board on
cbus(4).

This work is based on the source code of NetBSD/pc98, an unofficial
NetBSD port for NEC PC-9801 series, written about 16 years ago.
Thanks to NetBSD/pc98 porting staff for their work, especially NAGAO
Tadaaki and N. Honda who wrote the original driver.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cbus.c,v 1.1 2014/12/08 13:24:04 aoyama Exp $	*/
d101 4
a104 1
		sc->cbus_isr[i].isr_func = NULL;
d141 1
d155 3
a157 1
	if (sc->cbus_isr[ipl].isr_func != NULL) {
d163 4
a166 3
	sc->cbus_isr[ipl].isr_func = func;
	sc->cbus_isr[ipl].isr_arg = arg;
	evcount_attach(&(sc->cbus_isr[ipl].isr_count), name, &ipl);
d182 1
d196 3
a198 1
	if (sc->cbus_isr[ipl].isr_func == NULL) {
d204 4
a207 3
	sc->cbus_isr[ipl].isr_func = NULL;
	sc->cbus_isr[ipl].isr_arg = NULL;
	evcount_detach(&(sc->cbus_isr[ipl].isr_count));
d225 1
d237 3
a239 1
	if (sc->cbus_isr[ipl].isr_func == NULL) {
d246 1
a246 1
	rc = sc->cbus_isr[ipl].isr_func(sc->cbus_isr[ipl].isr_arg);
d248 1
a248 1
		sc->cbus_isr[ipl].isr_count.ec_count++;
@


1.1
log
@Move cbus.c, cbusvar.h, and pcex.c to new 'cbus' directory, to gather
'C-bus' device drivers in it.

More devices on cbus(4) will be added, hopefully :-)

ok miod@@
@
text
@d39 9
a97 1
	struct cbus_attach_args caa;
d112 3
a114 2
	caa.intlevel = -1;	/* not specified */
	config_found(self, &caa, cbus_print);
d122 1
a122 1
#if 0	/* not yet */
d124 3
a126 4
		printf("%s at %s", caa->name, pnp);	/* not configured */
#endif
	if (caa->intlevel != -1)
		printf(" INT %d", caa->intlevel);
@

