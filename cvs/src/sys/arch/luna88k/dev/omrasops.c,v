head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.2
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.8
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.11.0.6
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.6.0.14
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.12
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.10
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.8
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.4
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.4.0.6
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.4
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.1.0.10
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.8
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.6
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.4
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2
	LUNA88K_INIT:1.1.1.1
	AOYAMA:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2017.03.20.19.37.54;	author miod;	state Exp;
branches;
next	1.13;
commitid	QfsUP8Cps6nKwYtj;

1.13
date	2014.10.01.10.06.27;	author aoyama;	state Exp;
branches;
next	1.12;
commitid	p8SUiGD48tnE8I72;

1.12
date	2014.09.29.13.57.35;	author aoyama;	state Exp;
branches;
next	1.11;
commitid	uqI0XlMILDY28Lxq;

1.11
date	2014.01.02.15.30.34;	author aoyama;	state Exp;
branches;
next	1.10;

1.10
date	2013.11.16.22.45.37;	author aoyama;	state Exp;
branches;
next	1.9;

1.9
date	2013.05.17.23.25.16;	author aoyama;	state Exp;
branches;
next	1.8;

1.8
date	2013.05.02.19.12.04;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2013.04.28.23.33.12;	author aoyama;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.26.05.42.11;	author ray;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.29.19.08.22;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2006.08.06.13.04.33;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.04.19.33.21;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.21.15.23.55;	author aoyama;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.04.21.15.23.55;	author aoyama;	state Exp;
branches;
next	;

1.1.2.1
date	2004.06.05.23.09.46;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Replace hardcoded addresses with symbolic constants from <machine/board.h>
for enhanced grepability and fewer bad surprises.

ok aoyama@@
@
text
@/* $OpenBSD: omrasops.c,v 1.13 2014/10/01 10:06:27 aoyama Exp $ */
/* $NetBSD: omrasops.c,v 1.1 2000/01/05 08:48:56 nisimura Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Tohru Nishimura.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Designed specifically for 'm68k bitorder';
 *	- most significant byte is stored at lower address,
 *	- most significant bit is displayed at left most on screen.
 * Implementation relies on;
 *	- every memory reference is done in aligned 32bit chunks,
 *	- font glyphs are stored in 32bit padded.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

#include <luna88k/dev/omrasops.h>

#include <machine/board.h>
#define	OMFB_PLANEMASK	BMAP_BMSEL	/* planemask register */
#define	OMFB_ROPFUNC	BMAP_FN		/* ROP function code */

/* wscons emulator operations */
int	om_copycols(void *, int, int, int, int);
int	om_copyrows(void *, int, int, int num);
int	om_erasecols(void *, int, int, int, long);
int	om_eraserows(void *, int, int, long);
int	om1_cursor(void *, int, int, int);
int	om1_putchar(void *, int, int, u_int, long);
int	om4_cursor(void *, int, int, int);
int	om4_putchar(void *, int, int, u_int, long);

/* depth-depended setup functions */
void	setup_omrasops1(struct rasops_info *);
void	setup_omrasops4(struct rasops_info *);

/* internal functions for 1bpp/4bpp */
int	om1_windowmove(struct rasops_info *, u_int16_t, u_int16_t, u_int16_t,
		u_int16_t, u_int16_t, u_int16_t, int16_t, int16_t);
int	om4_windowmove(struct rasops_info *, u_int16_t, u_int16_t, u_int16_t,
		u_int16_t, u_int16_t, u_int16_t, int16_t, int16_t);

/* MI function in src/sys/dev/rasops/rasops.c */
int     rasops_alloc_cattr(void *, int, int, int, long *);

static int (*om_windowmove)(struct rasops_info *, u_int16_t, u_int16_t,
		u_int16_t, u_int16_t, u_int16_t, u_int16_t, int16_t, int16_t);

extern struct wsscreen_descr omfb_stdscreen;

#define	ALL1BITS	(~0U)
#define	ALL0BITS	(0U)
#define	BLITWIDTH	(32)
#define	ALIGNMASK	(0x1f)
#define	BYTESDONE	(4)

/*
 * Blit a character at the specified co-ordinates.
 * - 1bpp version -
 */
int
om1_putchar(void *cookie, int row, int startcol, u_int uc, long attr)
{
	struct rasops_info *ri = cookie;
	u_int8_t *p;
	int scanspan, startx, height, width, align, y;
	u_int32_t lmask, rmask, glyph, inverse;
	int i, fg, bg;
	u_int8_t *fb;

	scanspan = ri->ri_stride;
	y = ri->ri_font->fontheight * row;
	startx = ri->ri_font->fontwidth * startcol;
	height = ri->ri_font->fontheight;
	fb = (u_int8_t *)ri->ri_font->data +
	    (uc - ri->ri_font->firstchar) * ri->ri_fontscale;
	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);
	inverse = (bg != 0) ? ALL1BITS : ALL0BITS;

	p = (u_int8_t *)ri->ri_bits + y * scanspan + ((startx / 32) * 4);
	align = startx & ALIGNMASK;
	width = ri->ri_font->fontwidth + align;
	lmask = ALL1BITS >> align;
	rmask = ALL1BITS << (-width & ALIGNMASK);
	if (width <= BLITWIDTH) {
		lmask &= rmask;
		while (height > 0) {
			glyph = 0;
			for (i = ri->ri_font->stride; i != 0; i--)
				glyph = (glyph << 8) | *fb++;
			glyph <<= (4 - ri->ri_font->stride) * NBBY;
			glyph = (glyph >> align) ^ inverse;
			*W(p) = (*R(p) & ~lmask) | (glyph & lmask);
			p += scanspan;
			height--;
		}
	} else {
		u_int8_t *q = p;
		u_int32_t lhalf, rhalf;

		while (height > 0) {
			glyph = 0;
			for (i = ri->ri_font->stride; i != 0; i--)
				glyph = (glyph << 8) | *fb++;
			glyph <<= (4 - ri->ri_font->stride) * NBBY;
			lhalf = (glyph >> align) ^ inverse;
			*W(p) = (*R(p) & ~lmask) | (lhalf & lmask);

			p += BYTESDONE;

			rhalf = (glyph << (BLITWIDTH - align)) ^ inverse;
			*W(p) = (rhalf & rmask) | (*R(p) & ~rmask);

			p = (q += scanspan);
			height--;
		}
	}

	return 0;
}

/*
 * Blit a character at the specified co-ordinates
 * - 4bpp version -
 */
int
om4_putchar(void *cookie, int row, int startcol, u_int uc, long attr)
{
	struct rasops_info *ri = cookie;
	u_int8_t *p;
	int scanspan, startx, height, width, align, y;
	u_int32_t lmask, rmask, glyph, glyphbg, fgpat, bgpat;
	u_int32_t fgmask0, fgmask1, fgmask2, fgmask3;
	u_int32_t bgmask0, bgmask1, bgmask2, bgmask3;
	int i, fg, bg;
	u_int8_t *fb;

	scanspan = ri->ri_stride;
	y = ri->ri_font->fontheight * row;
	startx = ri->ri_font->fontwidth * startcol;
	height = ri->ri_font->fontheight;
	fb = (u_int8_t *)ri->ri_font->data +
	    (uc - ri->ri_font->firstchar) * ri->ri_fontscale;
	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);
	fgmask0 = (fg & 0x01) ? ALL1BITS : ALL0BITS;
	fgmask1 = (fg & 0x02) ? ALL1BITS : ALL0BITS;
	fgmask2 = (fg & 0x04) ? ALL1BITS : ALL0BITS;
	fgmask3 = (fg & 0x08) ? ALL1BITS : ALL0BITS;
	bgmask0 = (bg & 0x01) ? ALL1BITS : ALL0BITS;
	bgmask1 = (bg & 0x02) ? ALL1BITS : ALL0BITS;
	bgmask2 = (bg & 0x04) ? ALL1BITS : ALL0BITS;
	bgmask3 = (bg & 0x08) ? ALL1BITS : ALL0BITS;

	p = (u_int8_t *)ri->ri_bits + y * scanspan + ((startx / 32) * 4);
	align = startx & ALIGNMASK;
	width = ri->ri_font->fontwidth + align;
	lmask = ALL1BITS >> align;
	rmask = ALL1BITS << (-width & ALIGNMASK);

	/* select all planes for later ROP function target */ 
	*(volatile u_int32_t *)OMFB_PLANEMASK = 0xff;

	if (width <= BLITWIDTH) {
		lmask &= rmask;
		/* set lmask as ROP mask value, with THROUGH mode */
		((volatile u_int32_t *)OMFB_ROPFUNC)[ROP_THROUGH] = lmask;

		while (height > 0) {
			glyph = 0;
			for (i = ri->ri_font->stride; i != 0; i--)
				glyph = (glyph << 8) | *fb++;
			glyph <<= (4 - ri->ri_font->stride) * NBBY;
			glyph = (glyph >> align);
			glyphbg = glyph ^ ALL1BITS;

			fgpat = glyph & fgmask0;
			bgpat = glyphbg & bgmask0;
			*P0(p) = (fgpat | bgpat);
			fgpat = glyph & fgmask1;
			bgpat = glyphbg & bgmask1;
			*P1(p) = (fgpat | bgpat);
			fgpat = glyph & fgmask2;
			bgpat = glyphbg & bgmask2;
			*P2(p) = (fgpat | bgpat);
			fgpat = glyph & fgmask3;
			bgpat = glyphbg & bgmask3;
			*P3(p) = (fgpat | bgpat);

			p += scanspan;
			height--;
		}
		/* reset mask value */
		((volatile u_int32_t *)OMFB_ROPFUNC)[ROP_THROUGH] = ALL1BITS;
	} else {
		u_int8_t *q = p;
		u_int32_t lhalf, rhalf;
		u_int32_t lhalfbg, rhalfbg;

		while (height > 0) {
			glyph = 0;
			for (i = ri->ri_font->stride; i != 0; i--)
				glyph = (glyph << 8) | *fb++;
			glyph <<= (4 - ri->ri_font->stride) * NBBY;
			lhalf = (glyph >> align);
			lhalfbg = lhalf ^ ALL1BITS;
			/* set lmask as ROP mask value, with THROUGH mode */
			((volatile u_int32_t *)OMFB_ROPFUNC)[ROP_THROUGH]
				= lmask;

			fgpat = lhalf & fgmask0;
			bgpat = lhalfbg & bgmask0;
			*P0(p) = (fgpat | bgpat);
			fgpat = lhalf & fgmask1;
			bgpat = lhalfbg & bgmask1;
			*P1(p) = (fgpat | bgpat);
			fgpat = lhalf & fgmask2;
			bgpat = lhalfbg & bgmask2;
			*P2(p) = (fgpat | bgpat);
			fgpat = lhalf & fgmask3;
			bgpat = lhalfbg & bgmask3;
			*P3(p) = (fgpat | bgpat);

			p += BYTESDONE;

			rhalf = (glyph << (BLITWIDTH - align));
			rhalfbg = rhalf ^ ALL1BITS;
			/* set rmask as ROP mask value, with THROUGH mode */
			((volatile u_int32_t *)OMFB_ROPFUNC)[ROP_THROUGH]
				= rmask;

			fgpat = rhalf & fgmask0;
			bgpat = rhalfbg & bgmask0;
			*P0(p) = (fgpat | bgpat);
			fgpat = rhalf & fgmask1;
			bgpat = rhalfbg & bgmask1;
			*P1(p) = (fgpat | bgpat);
			fgpat = rhalf & fgmask2;
			bgpat = rhalfbg & bgmask2;
			*P2(p) = (fgpat | bgpat);
			fgpat = rhalf & fgmask3;
			bgpat = rhalfbg & bgmask3;
			*P3(p) = (fgpat | bgpat);

			p = (q += scanspan);
			height--;
		}
		/* reset mask value */
		((volatile u_int32_t *)OMFB_ROPFUNC)[ROP_THROUGH] = ALL1BITS;
	}
	/* select plane #0 only; XXX need this ? */
	*(volatile u_int32_t *)OMFB_PLANEMASK = 0x01;

	return 0;
}

int
om_erasecols(void *cookie, int row, int col, int num, long attr)
{
	struct rasops_info *ri = cookie;
	int fg, bg;
	int snum, scol, srow;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);

	snum = num * ri->ri_font->fontwidth;
	scol = col * ri->ri_font->fontwidth  + ri->ri_xorigin;
	srow = row * ri->ri_font->fontheight + ri->ri_yorigin;

	/*
	 * If this is too tricky for the simple raster ops engine,
	 * pass the fun to rasops.
	 */
	if ((*om_windowmove)(ri, scol, srow, scol, srow, snum,
	    ri->ri_font->fontheight, RR_CLEAR, 0xff ^ bg) != 0)
		rasops_erasecols(cookie, row, col, num, attr);

	return 0;
}

int
om_eraserows(void *cookie, int row, int num, long attr)
{
	struct rasops_info *ri = cookie;
	int fg, bg;
	int srow, snum;
	int rc;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);
	bg ^= 0xff;

	if (num == ri->ri_rows && (ri->ri_flg & RI_FULLCLEAR)) {
		rc = (*om_windowmove)(ri, 0, 0, 0, 0, ri->ri_width,
			ri->ri_height, RR_CLEAR, bg);
	} else {
		srow = row * ri->ri_font->fontheight + ri->ri_yorigin;
		snum = num * ri->ri_font->fontheight;
		rc = (*om_windowmove)(ri, ri->ri_xorigin, srow, ri->ri_xorigin,
		    srow, ri->ri_emuwidth, snum, RR_CLEAR, bg);
	}
	if (rc != 0)
		rasops_eraserows(cookie, row, num, attr);

	return 0;
}

int
om_copyrows(void *cookie, int src, int dst, int n)
{
	struct rasops_info *ri = cookie;

	n   *= ri->ri_font->fontheight;
	src *= ri->ri_font->fontheight;
	dst *= ri->ri_font->fontheight;

	(*om_windowmove)(ri, ri->ri_xorigin, ri->ri_yorigin + src,
		ri->ri_xorigin, ri->ri_yorigin + dst,
		ri->ri_emuwidth, n, RR_COPY, 0xff);

	return 0;
}

int
om_copycols(void *cookie, int row, int src, int dst, int n)
{
	struct rasops_info *ri = cookie;

	n   *= ri->ri_font->fontwidth;
	src *= ri->ri_font->fontwidth;
	dst *= ri->ri_font->fontwidth;
	row *= ri->ri_font->fontheight;

	(*om_windowmove)(ri, ri->ri_xorigin + src, ri->ri_yorigin + row,
		ri->ri_xorigin + dst, ri->ri_yorigin + row,
		n, ri->ri_font->fontheight, RR_COPY, 0xff);

	return 0;
}

/*
 * Position|{enable|disable} the cursor at the specified location.
 * - 1bpp version -
 */
int
om1_cursor(void *cookie, int on, int row, int col)
{
	struct rasops_info *ri = cookie;
	u_int8_t *p;
	int scanspan, startx, height, width, align, y;
	u_int32_t lmask, rmask, image;

	if (!on) {
		/* make sure it's on */
		if ((ri->ri_flg & RI_CURSOR) == 0)
			return 0;

		row = ri->ri_crow;
		col = ri->ri_ccol;
	} else {
		/* unpaint the old copy. */
		ri->ri_crow = row;
		ri->ri_ccol = col;
	}

	scanspan = ri->ri_stride;
	y = ri->ri_font->fontheight * row;
	startx = ri->ri_font->fontwidth * col;
	height = ri->ri_font->fontheight;

	p = (u_int8_t *)ri->ri_bits + y * scanspan + ((startx / 32) * 4);
	align = startx & ALIGNMASK;
	width = ri->ri_font->fontwidth + align;
	lmask = ALL1BITS >> align;
	rmask = ALL1BITS << (-width & ALIGNMASK);
	if (width <= BLITWIDTH) {
		lmask &= rmask;
		while (height > 0) {
			image = *R(p);
			*W(p) = (image & ~lmask) | ((image ^ ALL1BITS) & lmask);
			p += scanspan;
			height--;
		}
	} else {
		u_int8_t *q = p;

		while (height > 0) {
			image = *R(p);
			*W(p) = (image & ~lmask) | ((image ^ ALL1BITS) & lmask);
			p += BYTESDONE;

			image = *R(p);
			*W(p) = ((image ^ ALL1BITS) & rmask) | (image & ~rmask);
			p = (q += scanspan);
			height--;
		}
	}
	ri->ri_flg ^= RI_CURSOR;

	return 0;
}

/*
 * Position|{enable|disable} the cursor at the specified location
 * - 4bpp version -
 */
int
om4_cursor(void *cookie, int on, int row, int col)
{
	struct rasops_info *ri = cookie;
	u_int8_t *p;
	int scanspan, startx, height, width, align, y;
	u_int32_t lmask, rmask;

	if (!on) {
		/* make sure it's on */
		if ((ri->ri_flg & RI_CURSOR) == 0)
			return 0;

		row = ri->ri_crow;
		col = ri->ri_ccol;
	} else {
		/* unpaint the old copy. */
		ri->ri_crow = row;
		ri->ri_ccol = col;
	}

	scanspan = ri->ri_stride;
	y = ri->ri_font->fontheight * row;
	startx = ri->ri_font->fontwidth * col;
	height = ri->ri_font->fontheight;

	p = (u_int8_t *)ri->ri_bits + y * scanspan + ((startx / 32) * 4);
	align = startx & ALIGNMASK;
	width = ri->ri_font->fontwidth + align;
	lmask = ALL1BITS >> align;
	rmask = ALL1BITS << (-width & ALIGNMASK);

	/* select all planes for later ROP function target */ 
	*(volatile u_int32_t *)OMFB_PLANEMASK = 0xff;

	if (width <= BLITWIDTH) {
		lmask &= rmask;
		/* set lmask as ROP mask value, with INV2 mode */
		((volatile u_int32_t *)OMFB_ROPFUNC)[ROP_INV2] = lmask;

		while (height > 0) {
			*W(p) = ALL1BITS;
			p += scanspan;
			height--;
		}
		/* reset mask value */
		((volatile u_int32_t *)OMFB_ROPFUNC)[ROP_THROUGH] = ALL1BITS;
	} else {
		u_int8_t *q = p;

		while (height > 0) {
			/* set lmask as ROP mask value, with INV2 mode */
			((volatile u_int32_t *)OMFB_ROPFUNC)[ROP_INV2] = lmask;
			*W(p) = ALL1BITS;

			p += BYTESDONE;

			/* set rmask as ROP mask value, with INV2 mode */
			((volatile u_int32_t *)OMFB_ROPFUNC)[ROP_INV2] = rmask;
			*W(p) = ALL1BITS;

			p = (q += scanspan);
			height--;
		}
		/* reset mask value */
		((volatile u_int32_t *)OMFB_ROPFUNC)[ROP_THROUGH] = ALL1BITS;
	}
	/* select plane #0 only; XXX need this ? */
	*(volatile u_int32_t *)OMFB_PLANEMASK = 0x01;

	ri->ri_flg ^= RI_CURSOR;

	return 0;
}

/*
 * After calling rasops_init(), set up our depth-depend emulops,
 * block move function and capabilities.
 */
void
setup_omrasops1(struct rasops_info *ri)
{
	om_windowmove = om1_windowmove;
	ri->ri_ops.cursor  = om1_cursor;
	ri->ri_ops.putchar = om1_putchar;
	omfb_stdscreen.capabilities
		= ri->ri_caps & ~WSSCREEN_UNDERLINE;
}

void
setup_omrasops4(struct rasops_info *ri)
{
	om_windowmove = om4_windowmove;
	ri->ri_ops.cursor  = om4_cursor;
	ri->ri_ops.putchar = om4_putchar;
	omfb_stdscreen.capabilities
		= WSSCREEN_HILIT | WSSCREEN_WSCOLORS | WSSCREEN_REVERSE;
	/*
	 * Since we set ri->ri_depth == 1, rasops_init() set
	 * rasops_alloc_mattr for us.  But we use the color version,
	 * rasops_alloc_cattr, on 4bpp/8bpp frame buffer.
	 */
	ri->ri_ops.alloc_attr = rasops_alloc_cattr;
}
@


1.13
log
@More optimization on LUNA frame buffer.

This is straightforward port of Izumi Tsutsui's work on NetBSD/luna68k:
http://mail-index.netbsd.org/source-changes/2014/09/28/msg058972.html

>> Put dumb optimizations to avoid conditionals in putchar drawing loops.

This makes 4bpp wscons putchar ~8% faster on luna88k.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: omrasops.c,v 1.12 2014/09/29 13:57:35 aoyama Exp $ */
d51 4
@


1.12
log
@Use raster(logic) operation, or ROP, function on LUNA frame buffer.

It makes 4bpp wscons putchar ~20% faster.

ok @@miod
@
text
@d1 1
a1 1
/* $OpenBSD: omrasops.c,v 1.11 2014/01/02 15:30:34 aoyama Exp $ */
d162 2
d174 8
d205 2
a206 2
			fgpat = (fg & 0x01) ? glyph : 0;
			bgpat = (bg & 0x01) ? glyphbg : 0;
d208 2
a209 2
			fgpat = (fg & 0x02) ? glyph : 0;
			bgpat = (bg & 0x02) ? glyphbg : 0;
d211 2
a212 2
			fgpat = (fg & 0x04) ? glyph : 0;
			bgpat = (bg & 0x04) ? glyphbg : 0;
d214 2
a215 2
			fgpat = (fg & 0x08) ? glyph : 0;
			bgpat = (bg & 0x08) ? glyphbg : 0;
d239 2
a240 2
			fgpat = (fg & 0x01) ? lhalf : 0;
			bgpat = (bg & 0x01) ? lhalfbg : 0;
d242 2
a243 2
			fgpat = (fg & 0x02) ? lhalf : 0;
			bgpat = (bg & 0x02) ? lhalfbg : 0;
d245 2
a246 2
			fgpat = (fg & 0x04) ? lhalf : 0;
			bgpat = (bg & 0x04) ? lhalfbg : 0;
d248 2
a249 2
			fgpat = (fg & 0x08) ? lhalf : 0;
			bgpat = (bg & 0x08) ? lhalfbg : 0;
d260 2
a261 2
			fgpat = (fg & 0x01) ? rhalf : 0;
			bgpat = (bg & 0x01) ? rhalfbg : 0;
d263 2
a264 2
			fgpat = (fg & 0x02) ? rhalf : 0;
			bgpat = (bg & 0x02) ? rhalfbg : 0;
d266 2
a267 2
			fgpat = (fg & 0x04) ? rhalf : 0;
			bgpat = (bg & 0x04) ? rhalfbg : 0;
d269 2
a270 2
			fgpat = (fg & 0x08) ? rhalf : 0;
			bgpat = (bg & 0x08) ? rhalfbg : 0;
@


1.11
log
@Add primary support for LUNA-88K 4bpp/8bpp frame buffer.

This brings color support on LUNA's wscons.  And, with the help of recent
development version of 'mlterm-fb' (frame buffer version of ports/x11/mlterm),
graphic images can be displayed in 16/256 colors on the screen.  Thanks to
arakiken, the original developer of mlterm!

This diff is based on NetBSD/luna68k work:
http://mail-index.netbsd.org/source-changes/2013/12/28/msg050266.html

Need more work to coexist with the monochrome X.Org server.

"go ahead!" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: omrasops.c,v 1.10 2013/11/16 22:45:37 aoyama Exp $ */
d178 4
d184 3
d197 1
a197 1
			*P0(p) = (*P0(p) & ~lmask) | ((fgpat | bgpat) & lmask);
d200 1
a200 1
			*P1(p) = (*P1(p) & ~lmask) | ((fgpat | bgpat) & lmask);
d203 1
a203 1
			*P2(p) = (*P2(p) & ~lmask) | ((fgpat | bgpat) & lmask);
d206 1
a206 1
			*P3(p) = (*P3(p) & ~lmask) | ((fgpat | bgpat) & lmask);
d211 2
d225 3
d231 1
a231 1
			*P0(p) = (*P0(p) & ~lmask) | ((fgpat | bgpat) & lmask);
d234 1
a234 1
			*P1(p) = (*P1(p) & ~lmask) | ((fgpat | bgpat) & lmask);
d237 1
a237 1
			*P2(p) = (*P2(p) & ~lmask) | ((fgpat | bgpat) & lmask);
d240 1
a240 1
			*P3(p) = (*P3(p) & ~lmask) | ((fgpat | bgpat) & lmask);
d246 3
d252 1
a252 1
			*P0(p) = ((fgpat | bgpat) & rmask) | (*P0(p) & ~rmask);
d255 1
a255 1
			*P1(p) = ((fgpat | bgpat) & rmask) | (*P1(p) & ~rmask);
d258 1
a258 1
			*P2(p) = ((fgpat | bgpat) & rmask) | (*P2(p) & ~rmask);
d261 1
a261 1
			*P3(p) = ((fgpat | bgpat) & rmask) | (*P3(p) & ~rmask);
d266 2
d269 2
d430 1
a430 1
	u_int32_t lmask, rmask, image;
d455 4
d461 3
d465 1
a465 8
			image = *P0(p);
			*P0(p) = (image & ~lmask) | ((image ^ ALL1BITS) & lmask);
			image = *P1(p);
			*P1(p) = (image & ~lmask) | ((image ^ ALL1BITS) & lmask);
			image = *P2(p);
			*P2(p) = (image & ~lmask) | ((image ^ ALL1BITS) & lmask);
			image = *P3(p);
			*P3(p) = (image & ~lmask) | ((image ^ ALL1BITS) & lmask);
d469 2
d475 3
a477 8
			image = *P0(p);
			*P0(p) = (image & ~lmask) | ((image ^ ALL1BITS) & lmask);
			image = *P1(p);
			*P1(p) = (image & ~lmask) | ((image ^ ALL1BITS) & lmask);
			image = *P2(p);
			*P2(p) = (image & ~lmask) | ((image ^ ALL1BITS) & lmask);
			image = *P3(p);
			*P3(p) = (image & ~lmask) | ((image ^ ALL1BITS) & lmask);
d481 3
a483 8
			image = *P0(p);
			*P0(p) = ((image ^ ALL1BITS) & rmask) | (image & ~rmask);
			image = *P1(p);
			*P1(p) = ((image ^ ALL1BITS) & rmask) | (image & ~rmask);
			image = *P2(p);
			*P2(p) = ((image ^ ALL1BITS) & rmask) | (image & ~rmask);
			image = *P3(p);
			*P3(p) = ((image ^ ALL1BITS) & rmask) | (image & ~rmask);
d488 2
d491 3
@


1.10
log
@Re-organize luna88k rasops om_{copy,erase}{cols,rows} by using one
generic function, based on hp300/dev/diofb_mono.c.

This also fixes `screen is not updated when delete a character if it
is on the middle of a 32-bit word of the frame buffer' problem.

"Go for it!" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: omrasops.c,v 1.9 2013/05/17 23:25:16 aoyama Exp $ */
a52 2
int	om_cursor(void *, int, int, int);
int	om_putchar(void *, int, int, u_int, long);
d57 14
d72 7
a78 4
/* internal functions (for 1bpp, in omrasops1.c) */
int	om_windowmove1(struct rasops_info *, u_int16_t, u_int16_t,
		u_int16_t, u_int16_t, u_int16_t, u_int16_t, int16_t,
		int16_t /* ignored */);
d88 1
d91 1
a91 1
om_putchar(void *cookie, int row, int startcol, u_int uc, long attr)
d122 1
a122 1
			W(p) = (R(p) & ~lmask) | (glyph & lmask);
d126 1
a126 2
	}
	else {
d136 2
a137 1
			W(p) = (R(p) & ~lmask) | (lhalf & lmask);
d139 1
d141 106
a246 1
			W(p) = (rhalf & rmask) | (R(p) & ~rmask);
d273 1
a273 1
	if (om_windowmove1(ri, scol, srow, scol, srow, snum,
d292 2
a293 2
		rc = om_windowmove1(ri, 0, 0, 0, 0, ri->ri_width, ri->ri_height,
		    RR_CLEAR, bg);
d297 1
a297 1
		rc = om_windowmove1(ri, ri->ri_xorigin, srow, ri->ri_xorigin,
d315 1
a315 1
	om_windowmove1(ri, ri->ri_xorigin, ri->ri_yorigin + src,
d332 1
a332 1
	om_windowmove1(ri, ri->ri_xorigin + src, ri->ri_yorigin + row,
d341 1
d344 1
a344 1
om_cursor(void *cookie, int on, int row, int col)
d377 2
a378 2
			image = R(p);
			W(p) = (image & ~lmask) | ((image ^ ALL1BITS) & lmask);
d382 42
d425 26
a450 1
	else {
d454 9
a462 2
			image = R(p);
			W(p) = (image & ~lmask) | ((image ^ ALL1BITS) & lmask);
d464 9
a472 2
			image = R(p);
			W(p) = ((image ^ ALL1BITS) & rmask) | (image & ~rmask);
d481 30
@


1.9
log
@Fix 'the right-of-cursor background color is inverted when we do
delete-after-cursor' bug on luna88k wscons console, by adding the same
operation in om_putchar() to om_erasecols() and om_eraserows().

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: omrasops.c,v 1.8 2013/05/02 19:12:04 miod Exp $ */
d50 2
d60 5
a70 3
#define	W(p) (*(u_int32_t *)(p))
#define	R(p) (*(u_int32_t *)((u_int8_t *)(p) + 0x40000))

d75 1
a75 5
om_putchar(cookie, row, startcol, uc, attr)
	void *cookie;
	int row, startcol;
	u_int uc;
	long attr;
d135 1
a135 4
om_erasecols(cookie, row, startcol, ncols, attr)
	void *cookie;
	int row, startcol, ncols;
	long attr;
d137 4
a140 10
        struct rasops_info *ri = cookie;
        u_int8_t *p;
        int scanspan, startx, height, width, align, w, y, fg, bg;
        u_int32_t lmask, rmask, fill;

        scanspan = ri->ri_stride;
        y = ri->ri_font->fontheight * row;
        startx = ri->ri_font->fontwidth * startcol;
        height = ri->ri_font->fontheight;
        w = ri->ri_font->fontwidth * ncols;
a141 1
	fill = (bg != 0) ? ALL1BITS : ALL0BITS;
d143 11
a153 32
	p = (u_int8_t *)ri->ri_bits + y * scanspan + ((startx / 32) * 4);
	align = startx & ALIGNMASK;
	width = w + align;
	lmask = ALL1BITS >> align;
	rmask = ALL1BITS << (-width & ALIGNMASK);
	if (width <= BLITWIDTH) {
		lmask &= rmask;
		fill &= lmask;
		while (height > 0) {
			W(p) = (R(p) & ~lmask) | fill;
			p += scanspan;
			height--;
		}
	}
	else {
		u_int8_t *q = p;
		while (height > 0) {
			W(p) = (R(p) & ~lmask) | (fill & lmask);
			width -= 2 * BLITWIDTH;
			while (width > 0) {
				p += BYTESDONE;
				W(p) = fill;
				width -= BLITWIDTH;
			}
			p += BYTESDONE;
			W(p) = (fill & rmask) | (R(p) & ~rmask);

			p = (q += scanspan);
			width = w + align;
			height--;
		}
	}
d159 1
a159 4
om_eraserows(cookie, startrow, nrows, attr)
	void *cookie;
	int startrow, nrows;
	long attr;
d162 3
a164 3
	u_int8_t *p, *q;
	int scanspan, starty, height, width, w, fg, bg;
	u_int32_t rmask, fill;
a165 4
	scanspan = ri->ri_stride;
	starty = ri->ri_font->fontheight * startrow;
	height = ri->ri_font->fontheight * nrows;
	w = ri->ri_emuwidth;
d167 1
a167 1
	fill = (bg != 0) ? ALL1BITS : ALL0BITS;
d169 8
a176 17
	p = (u_int8_t *)ri->ri_bits + starty * scanspan;
	width = w;
        rmask = ALL1BITS << (-width & ALIGNMASK);
	q = p;
	while (height > 0) {
		W(p) = fill;				/* always aligned */
		width -= 2 * BLITWIDTH;
		while (width > 0) {
			p += BYTESDONE;
			W(p) = fill;
			width -= BLITWIDTH;
		}
		p += BYTESDONE;
		W(p) = (fill & rmask) | (R(p) & ~rmask);
		p = (q += scanspan);
		width = w;
		height--;
d178 2
d185 1
a185 3
om_copyrows(cookie, srcrow, dstrow, nrows)
	void *cookie;
	int srcrow, dstrow, nrows;
d187 1
a187 13
        struct rasops_info *ri = cookie;
        u_int8_t *p, *q;
	int scanspan, offset, srcy, height, width, w;
        u_int32_t rmask;
        
	scanspan = ri->ri_stride;
	height = ri->ri_font->fontheight * nrows;
	offset = (dstrow - srcrow) * scanspan * ri->ri_font->fontheight;
	srcy = ri->ri_font->fontheight * srcrow;
	if (srcrow < dstrow && srcrow + nrows > dstrow) {
		scanspan = -scanspan;
		srcy += height;
	}
d189 7
a195 20
	p = (u_int8_t *)ri->ri_bits + srcy * ri->ri_stride;
	w = ri->ri_emuwidth;
	width = w;
	rmask = ALL1BITS << (-width & ALIGNMASK);
	q = p;
	while (height > 0) {
		W(p + offset) = R(p);			/* always aligned */
		width -= 2 * BLITWIDTH;
		while (width > 0) {
			p += BYTESDONE;
			W(p + offset) = R(p);
			width -= BLITWIDTH;
		}
		p += BYTESDONE;
		W(p + offset) = (R(p) & rmask) | (R(p + offset) & ~rmask);

		p = (q += scanspan);
		width = w;
		height--;
	}
d201 1
a201 3
om_copycols(cookie, startrow, srccol, dstcol, ncols)
	void *cookie;
	int startrow, srccol, dstcol, ncols;
a203 84
	u_int8_t *sp, *dp, *basep;
	int scanspan, height, width, align, shift, w, y, srcx, dstx;
	u_int32_t lmask, rmask;

	scanspan = ri->ri_stride;
	y = ri->ri_font->fontheight * startrow;
	srcx = ri->ri_font->fontwidth * srccol;
	dstx = ri->ri_font->fontwidth * dstcol;
	height = ri->ri_font->fontheight;
	w = ri->ri_font->fontwidth * ncols;
	basep = (u_int8_t *)ri->ri_bits + y * scanspan;

	align = shift = srcx & ALIGNMASK;
	width = w + align;
	align = dstx & ALIGNMASK;
	lmask = ALL1BITS >> align;
	rmask = ALL1BITS << (-(w + align) & ALIGNMASK);
	shift = align - shift; 
	sp = basep + (srcx / 32) * 4;
	dp = basep + (dstx / 32) * 4;

	if (shift != 0)
		goto hardluckalignment;

	/* alignments comfortably match */
	if (width <= BLITWIDTH) {
		lmask &= rmask;
		while (height > 0) {
			W(dp) = (R(dp) & ~lmask) | (R(sp) & lmask);
			dp += scanspan;
			sp += scanspan;
			height--;
		}
	}
	/* copy forward (left-to-right) */
	else if (dstcol < srccol || srccol + ncols < dstcol) {
		u_int8_t *sq = sp, *dq = dp;

		w = width;
		while (height > 0) {
			W(dp) = (R(dp) & ~lmask) | (R(sp) & lmask);
			width -= 2 * BLITWIDTH;
			while (width > 0) {
				sp += BYTESDONE;
				dp += BYTESDONE;
				W(dp) = R(sp);
				width -= BLITWIDTH;
			}
			sp += BYTESDONE;
			dp += BYTESDONE;
			W(dp) = (R(sp) & rmask) | (R(dp) & ~rmask);
			sp = (sq += scanspan);
			dp = (dq += scanspan);
			width = w;
			height--;
		}
	}
	/* copy backward (right-to-left) */
	else {
		u_int8_t *sq, *dq;

		sq = (sp += width / 32 * 4);
		dq = (dp += width / 32 * 4);
		w = width;
		while (height > 0) {
			W(dp) = (R(sp) & rmask) | (R(dp) & ~rmask);
			width -= 2 * BLITWIDTH;
			while (width > 0) {
				sp -= BYTESDONE;
				dp -= BYTESDONE;
				W(dp) = R(sp);
				width -= BLITWIDTH;
			}
			sp -= BYTESDONE;
			dp -= BYTESDONE;
			W(dp) = (R(dp) & ~lmask) | (R(sp) & lmask);

			sp = (sq += scanspan);
			dp = (dq += scanspan);
			width = w;
			height--;
		}
	}
	return 0;
d205 8
a212 2
    hardluckalignment:
	/* alignments painfully disagree */
d221 1
a221 3
om_cursor(cookie, on, row, col)
	void *cookie;
	int on, row, col;
@


1.8
log
@typos
@
text
@d1 1
a1 1
/* $OpenBSD: omrasops.c,v 1.7 2013/04/28 23:33:12 aoyama Exp $ */
d88 1
a88 1
	fb = ri->ri_font->data +
d142 1
a142 1
        int scanspan, startx, height, width, align, w, y;
d150 2
a151 1
	fill = (attr != 0) ? ALL1BITS : ALL0BITS;
d197 1
a197 1
	int scanspan, starty, height, width, w;
d204 2
a205 1
	fill = (attr == 1) ? ALL1BITS : ALL0BITS;
@


1.7
log
@Preliminary modifications for Xorg 1bpp server, based on OpenBSD/hp300
and NetBSD/luna68k.  Need more work in Xorg.

luna88k/conf/GENERIC:
- enable wsmux on GENERIC kernel

luna88k/dev/luanfb.c:
- make hardware access volatile'd
- add extra ioctl(2) used in Xorg wsfb driver
- add some workaround

luna88k/dev/lunaws.c:
- add WSDISPLAY_COMPAT_RAWKBD stuff for Xorg keyboard input

luna88k/dev/omrasops.c:
- change 'caddr_t' to 'u_int8_t *'

"go for it!" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: omrasops.c,v 1.6 2009/09/05 14:09:35 miod Exp $ */
d34 1
a34 1
 * Designed speficically for 'm68k bitorder';
d38 1
a38 1
 *	- every memory references is done in aligned 32bit chunk,
@


1.6
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/* $OpenBSD: omrasops.c,v 1.5 2008/06/26 05:42:11 ray Exp $ */
d65 1
a65 1
#define	R(p) (*(u_int32_t *)((caddr_t)(p) + 0x40000))
d78 1
a78 1
	caddr_t p;
d93 1
a93 1
	p = (caddr_t)ri->ri_bits + y * scanspan + ((startx / 32) * 4);
d112 1
a112 1
		caddr_t q = p;
d141 1
a141 1
        caddr_t p;
d152 1
a152 1
	p = (caddr_t)ri->ri_bits + y * scanspan + ((startx / 32) * 4);
d167 1
a167 1
		caddr_t q = p;
d195 1
a195 1
	caddr_t p, q;
d205 1
a205 1
	p = (caddr_t)ri->ri_bits + starty * scanspan;
d233 1
a233 1
        caddr_t p, q;
d246 1
a246 1
	p = (caddr_t)ri->ri_bits + srcy * ri->ri_stride;
d276 1
a276 1
	caddr_t sp, dp, basep;
d286 1
a286 1
	basep = (caddr_t)ri->ri_bits + y * scanspan;
d312 1
a312 1
		caddr_t sq = sp, dq = dp;
d335 1
a335 1
		caddr_t sq, dq;
d376 1
a376 1
	caddr_t p;
d398 1
a398 1
	p = (caddr_t)ri->ri_bits + y * scanspan + ((startx / 32) * 4);
d413 1
a413 1
		caddr_t q = p;
@


1.5
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: omrasops.c,v 1.4 2006/11/29 19:08:22 miod Exp $ */
d51 6
a56 6
void	om_cursor(void *, int, int, int);
void	om_putchar(void *, int, int, u_int, long);
void	om_copycols(void *, int, int, int, int);
void	om_copyrows(void *, int, int, int num);
void	om_erasecols(void *, int, int, int, long);
void	om_eraserows(void *, int, int, long);
d70 1
a70 1
void
d130 2
d134 1
a134 1
void
d184 2
d188 1
a188 1
void
d223 2
d227 1
a227 1
void
d266 2
d270 1
a270 1
void
d359 1
a359 1
	return;
d363 2
d370 1
a370 1
void
d383 1
a383 1
			return;
d427 2
@


1.4
log
@Add an unpack_attr function to struct wsdisplay_emulops, to match the
existing alloc_attr function. This allows rasops_unpack_attr to be kept
private to rasops, yet available to the screen drivers.
@
text
@d1 1
a1 1
/* $OpenBSD: omrasops.c,v 1.3 2006/08/06 13:04:33 miod Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.3
log
@Switch luna88k from rcons to rasops. Tested by aoyama@@
@
text
@d1 1
a1 1
/* $OpenBSD: omrasops.c,v 1.2 2006/03/04 19:33:21 miod Exp $ */
d97 1
a97 1
	rasops_unpack_attr(attr, &fg, &bg, NULL);
@


1.2
log
@Typos grab bag of the month, eyeballed by jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: omrasops.c,v 1.1 2004/04/21 15:23:55 aoyama Exp $ */
d53 1
a53 3
#include <dev/rcons/raster.h>
#include <dev/wscons/wscons_raster.h>
#include <dev/wscons/wscons_rfont.h>
d55 1
a58 1
int	om_mapchar(void *, int, unsigned int *);
a63 12
int	om_alloc_attr(void *, int, int, int, long *);

struct wsdisplay_emulops omfb_emulops = {
	om_cursor,
	om_mapchar,
	om_putchar,
	om_copycols,
	om_erasecols,
	om_copyrows,
	om_eraserows,
	om_alloc_attr
};
d84 1
a84 2
	struct rcons *rc = cookie;
	struct raster *rap = rc->rc_sp;
d88 2
a89 1
	u_int32_t *g;
d91 8
a98 6
	scanspan = rap->linelongs * 4;
	y = rc->rc_yorigin + rc->rc_font->height * row;
	startx = rc->rc_xorigin + rc->rc_font->width * startcol;
	height = rc->rc_font->height;
	g = rc->rc_font->chars[uc].r->pixels;
	inverse = (attr != 0) ? ALL1BITS : ALL0BITS;
d100 1
a100 1
	p = (caddr_t)rap->pixels + y * scanspan + ((startx / 32) * 4);
d102 1
a102 1
	width = rc->rc_font->width + align;
d108 4
a111 1
			glyph = *g;
a114 1
			g += 1;
d123 4
a126 1
			glyph = *g;
a133 1
			g += 1;
d145 1
a145 2
        struct rcons *rc = cookie;
        struct raster *rap = rc->rc_sp;
d150 5
a154 5
        scanspan = rap->linelongs * 4;
        y = rc->rc_yorigin + rc->rc_font->height * row;
        startx = rc->rc_xorigin + rc->rc_font->width * startcol;
        height = rc->rc_font->height;
        w = rc->rc_font->width * ncols;
d157 1
a157 1
	p = (caddr_t)rap->pixels + y * scanspan + ((startx / 32) * 4);
d197 1
a197 2
	struct rcons *rc = cookie;
	struct raster *rap = rc->rc_sp;
d202 4
a205 4
	scanspan = rap->linelongs * 4;
	starty = rc->rc_yorigin + rc->rc_font->height * startrow;
	height = rc->rc_font->height * nrows;
	w = rc->rc_font->width * rc->rc_maxcol;
d208 1
a208 2
	p = (caddr_t)rap->pixels + starty * scanspan;
	p += (rc->rc_xorigin / 32) * 4;
d233 1
a233 2
        struct rcons *rc = cookie;
        struct raster *rap = rc->rc_sp;
d238 4
a241 4
	scanspan = rap->linelongs * 4;
	height = rc->rc_font->height * nrows;
	offset = (dstrow - srcrow) * scanspan * rc->rc_font->height;
	srcy = rc->rc_yorigin + rc->rc_font->height * srcrow;
d247 2
a248 3
	p = (caddr_t)rap->pixels + srcy * (rap->linelongs * 4);
	p += (rc->rc_xorigin / 32) * 4;
	w = rc->rc_font->width * rc->rc_maxcol;
d274 1
a274 2
	struct rcons *rc = cookie;
	struct raster *rap = rc->rc_sp;
d279 7
a285 7
	scanspan = rap->linelongs * 4;
	y = rc->rc_yorigin + rc->rc_font->height * startrow;
	srcx = rc->rc_xorigin + rc->rc_font->width * srccol;
	dstx = rc->rc_xorigin + rc->rc_font->width * dstcol;
	height = rc->rc_font->height;
	w = rc->rc_font->width * ncols;
	basep = (caddr_t)rap->pixels + y * scanspan;
a364 17
 * Map a character.
 */
int
om_mapchar(cookie, c, cp)
	void *cookie;
	int c;
	u_int *cp;
{
	if (c < 128) {
		*cp = c;
		return (5);
	}
	*cp = ' ';
	return (0);
}

/*
d372 1
a372 2
	struct rcons *rc = cookie;
	struct raster *rap = rc->rc_sp;
d379 1
a379 1
		if ((rc->rc_bits & RC_CURSOR) == 0)
d382 2
a383 2
		row = *rc->rc_crowp;
		col = *rc->rc_ccolp;
d386 2
a387 2
		*rc->rc_crowp = row;
		*rc->rc_ccolp = col;
d390 4
a393 4
	scanspan = rap->linelongs * 4;
	y = rc->rc_yorigin + rc->rc_font->height * row;
	startx = rc->rc_xorigin + rc->rc_font->width * col;
	height = rc->rc_font->height;
d395 1
a395 1
	p = (caddr_t)rap->pixels + y * scanspan + ((startx / 32) * 4);
d397 1
a397 1
	width = rc->rc_font->width + align;
d423 1
a423 20
	rc->rc_bits ^= RC_CURSOR;
}

/*
 * Allocate attribute. We just pack these into an integer.
 */
int
om_alloc_attr(id, fg, bg, flags, attrp)
	void *id;
	int fg, bg, flags;
	long *attrp;
{
	if (flags & (WSATTR_HILIT | WSATTR_BLINK |
		     WSATTR_UNDERLINE | WSATTR_WSCOLORS))
		return (EINVAL);
	if (flags & WSATTR_REVERSE)
		*attrp = 1;
	else
		*attrp = 0;
	return (0);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d44 1
a44 1
 * Implementation relys on;
@


1.1.2.1
log
@Merge with the trunk
@
text
@@


1.1.1.1
log
@Initial commit for OpenBSD/luna88k, based on OpenBSD/mvme88k, NetBSD/luna68k and CMU Mach.
@
text
@@
