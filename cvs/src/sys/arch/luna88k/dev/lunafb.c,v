head	1.24;
access;
symbols
	OPENBSD_6_2:1.24.0.6
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.22.0.10
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.6
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.8
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.12.0.6
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.4
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.8
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.4
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.8.0.6
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.4
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	SMP:1.3.0.2
	LUNA88K_INIT:1.1.1.1
	AOYAMA:1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2017.03.20.19.37.54;	author miod;	state Exp;
branches;
next	1.23;
commitid	QfsUP8Cps6nKwYtj;

1.23
date	2017.01.15.20.22.33;	author fcambus;	state Exp;
branches;
next	1.22;
commitid	tX0dEKV2WbrIyiOY;

1.22
date	2014.07.22.13.39.16;	author aoyama;	state Exp;
branches;
next	1.21;
commitid	lZCYlgCoOf52l7KO;

1.21
date	2014.01.15.11.13.53;	author aoyama;	state Exp;
branches;
next	1.20;

1.20
date	2014.01.03.13.48.25;	author aoyama;	state Exp;
branches;
next	1.19;

1.19
date	2014.01.02.15.30.34;	author aoyama;	state Exp;
branches;
next	1.18;

1.18
date	2013.12.30.07.33.40;	author aoyama;	state Exp;
branches;
next	1.17;

1.17
date	2013.10.21.10.36.15;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2013.10.20.20.07.23;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2013.08.16.08.47.00;	author aoyama;	state Exp;
branches;
next	1.14;

1.14
date	2013.05.16.13.59.10;	author aoyama;	state Exp;
branches;
next	1.13;

1.13
date	2013.04.28.23.33.12;	author aoyama;	state Exp;
branches;
next	1.12;

1.12
date	2012.01.08.00.31.35;	author aoyama;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.26.15.40.59;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.26.05.42.11;	author ray;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.29.12.13.54;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.06.13.04.33;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.10.18.56.11;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.31.06.41.27;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.05.23.04.24;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.10.10.30.23;	author aoyama;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2004.04.24.13.37.44;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.21.15.23.52;	author aoyama;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.04.21.15.23.52;	author aoyama;	state Exp;
branches;
next	;

1.3.2.1
date	2004.06.05.23.09.46;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Replace hardcoded addresses with symbolic constants from <machine/board.h>
for enhanced grepability and fewer bad surprises.

ok aoyama@@
@
text
@/* $OpenBSD: lunafb.c,v 1.23 2017/01/15 20:22:33 fcambus Exp $ */
/* $NetBSD: lunafb.c,v 1.7.6.1 2002/08/07 01:48:34 lukem Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Tohru Nishimura.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/errno.h>
#include <sys/buf.h>

#include <uvm/uvm_extern.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

#include <machine/autoconf.h>
#include <machine/board.h>
#include <machine/cpu.h>

struct bt454 {
	volatile u_int8_t bt_addr;	/* map address register */
	volatile u_int8_t bt_cmap;	/* colormap data register */
};

struct bt458 {
	volatile u_int8_t bt_addr;	/* map address register */
	unsigned :24;
	volatile u_int8_t bt_cmap;	/* colormap data register */
	unsigned :24;
	volatile u_int8_t bt_ctrl;	/* control register */
	unsigned :24;
	volatile u_int8_t bt_omap;	/* overlay (cursor) map register */
	unsigned :24;
};

#define	OMFB_RFCNT	BMAP_RFCNT	/* video h-origin/v-origin */
#define	OMFB_PLANEMASK	BMAP_BMSEL	/* planemask register */
#define	OMFB_FB_WADDR	(BMAP_BMP + 8)	/* common plane */
#define	OMFB_FB_RADDR	(BMAP_BMAP0 + 8)/* plane #0 */
#define OMFB_FB_PLANESIZE  0x40000	/* size of 1 plane, 2048 / 8 * 1024 */
#define	OMFB_ROPFUNC	BMAP_FN		/* ROP function code */
#define	OMFB_RAMDAC	BMAP_PALLET2	/* Bt454/Bt458 RAMDAC */
#define	OMFB_SIZE	(BMAP_FN0 - BMAP_BMP + PAGE_SIZE)

struct hwcmap {
#define CMAP_SIZE 256
	u_int8_t r[CMAP_SIZE];
	u_int8_t g[CMAP_SIZE];
	u_int8_t b[CMAP_SIZE];
};

struct om_hwdevconfig {
	int	dc_wid;			/* width of frame buffer */
	int	dc_ht;			/* height of frame buffer */
	int	dc_depth;		/* depth, bits per pixel */
	int	dc_rowbytes;		/* bytes in a FB scan line */
	int	dc_depth_checked;	/* depth is really checked or not */
	int	dc_cmsize;		/* colormap size */
	struct hwcmap dc_cmap;		/* software copy of colormap */
	vaddr_t	dc_videobase;		/* base of flat frame buffer */
	struct rasops_info dc_ri;	/* raster blitter variables */
};

struct omfb_softc {
	struct device sc_dev;		/* base device */
	struct om_hwdevconfig *sc_dc;	/* device configuration */
	int nscreens;
};

int  omgetcmap(struct omfb_softc *, struct wsdisplay_cmap *);
int  omsetcmap(struct omfb_softc *, struct wsdisplay_cmap *);

struct om_hwdevconfig omfb_console_dc;
void omfb_getdevconfig(paddr_t, struct om_hwdevconfig *);

/* in omrasops.c */
int	om_copycols(void *, int, int, int, int);
int	om_copyrows(void *, int, int, int num);
int	om_erasecols(void *, int, int, int, long);
int	om_eraserows(void *, int, int, long);
void	setup_omrasops1(struct rasops_info *);
void	setup_omrasops4(struct rasops_info *);

struct wsscreen_descr omfb_stdscreen = {
	"std"
};

const struct wsscreen_descr *_omfb_scrlist[] = {
	&omfb_stdscreen,
};

const struct wsscreen_list omfb_screenlist = {
	sizeof(_omfb_scrlist) / sizeof(struct wsscreen_descr *), _omfb_scrlist
};

int	omfbioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	omfbmmap(void *, off_t, int);
int	omfb_alloc_screen(void *, const struct wsscreen_descr *,
	    void **, int *, int *, long *);
void	omfb_free_screen(void *, void *);
int	omfb_show_screen(void *, void *, int, void (*) (void *, int, int),
	    void *);
int	omfb_load_font(void *, void *, struct wsdisplay_font *);
int	omfb_list_font(void *, struct wsdisplay_font *);
int	omfb_set_gfxmode(struct omfb_softc *, struct wsdisplay_gfx_mode *);

void	omfb_set_default_cmap(struct om_hwdevconfig *);
void	omfb_clear_framebuffer(struct om_hwdevconfig *);

const struct wsdisplay_accessops omfb_accessops = {
	.ioctl = omfbioctl,
	.mmap = omfbmmap,
	.alloc_screen = omfb_alloc_screen,
	.free_screen = omfb_free_screen,
	.show_screen = omfb_show_screen,
	.load_font = omfb_load_font,
	.list_font = omfb_list_font
};

int  omfbmatch(struct device *, void *, void *);
void omfbattach(struct device *, struct device *, void *);

const struct cfattach fb_ca = {
	sizeof(struct omfb_softc), omfbmatch, omfbattach
};

struct cfdriver fb_cd = {
        NULL, "fb", DV_DULL
};

/* hardware plane bits; retrieved at boot, will be updated */
extern int hwplanebits;

int omfb_console;
int omfb_cnattach(void);

int
omfbmatch(struct device *parent, void *cf, void *aux)
{
	struct mainbus_attach_args *ma = aux;

	if (strcmp(ma->ma_name, fb_cd.cd_name))
		return (0);
#if 0	/* XXX badaddr() bombs if no framebuffer is installed */
	if (badaddr((caddr_t)ma->ma_addr, 4))
		return (0);
#else
	if (hwplanebits == 0)
		return (0);
#endif
	return (1);
}

void
omfbattach(struct device *parent, struct device *self, void *args)
{
	struct omfb_softc *sc = (struct omfb_softc *)self;
	struct wsemuldisplaydev_attach_args waa;

	if (omfb_console) {
		sc->sc_dc = &omfb_console_dc;
		sc->nscreens = 1;
	} else {
		sc->sc_dc = (struct om_hwdevconfig *)
		    malloc(sizeof(struct om_hwdevconfig), M_DEVBUF,
			M_WAITOK | M_ZERO);
		omfb_getdevconfig(OMFB_FB_WADDR, sc->sc_dc);
	}
	printf(": %dx%d, %dbpp\n", sc->sc_dc->dc_wid, sc->sc_dc->dc_ht,
	    hwplanebits);

	waa.console = omfb_console;
	waa.scrdata = &omfb_screenlist;
	waa.accessops = &omfb_accessops;
	waa.accesscookie = sc;
	waa.defaultscreens = 0;

	config_found(self, &waa, wsemuldisplaydevprint);
}

/* EXPORT */ int
omfb_cnattach(void)
{
	struct om_hwdevconfig *dc = &omfb_console_dc;
	struct rasops_info *ri = &dc->dc_ri;
	long defattr;

	omfb_getdevconfig(OMFB_FB_WADDR, dc);
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);
	wsdisplay_cnattach(&omfb_stdscreen, ri, 0, 0, defattr);
	omfb_console = 1;
	return (0);
}

int
omfbioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct omfb_softc *sc = v;
	struct om_hwdevconfig *dc = sc->sc_dc;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_LUNA;
		break;

	case WSDISPLAYIO_GINFO:
#define	wsd_fbip ((struct wsdisplay_fbinfo *)data)
		wsd_fbip->height = dc->dc_ht;
		wsd_fbip->width = dc->dc_wid;
		wsd_fbip->depth = dc->dc_depth;
		wsd_fbip->cmsize = dc->dc_cmsize;
#undef wsd_fbip
		break;

	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = dc->dc_rowbytes;
		break;

	case WSDISPLAYIO_GETCMAP:
		return omgetcmap(sc, (struct wsdisplay_cmap *)data);

	case WSDISPLAYIO_PUTCMAP:
		return omsetcmap(sc, (struct wsdisplay_cmap *)data);

	case WSDISPLAYIO_GETSUPPORTEDDEPTH:
		*(u_int *)data = WSDISPLAYIO_DEPTH_1;
		break;

        case WSDISPLAYIO_SETGFXMODE:
                return omfb_set_gfxmode(sc, (struct wsdisplay_gfx_mode *)data);

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return (-1);
	}

	return (0);
}

/*
 * Return the address that would map the given device at the given
 * offset, allowing for the given protection, or return -1 for error.
 */

paddr_t
omfbmmap(void *v, off_t offset, int prot)
{
	struct omfb_softc *sc = v;
	struct om_hwdevconfig *dc = sc->sc_dc;
	paddr_t cookie = -1;

	if ((offset & PAGE_MASK) != 0)
		return (-1);

#if 0	/* Workaround for making Xorg mono server work */
	if (offset >= 0 && offset < OMFB_SIZE)
		cookie = (paddr_t)(trunc_page(dc->dc_videobase) + offset);
#else
	if (offset >= 0 && offset < dc->dc_rowbytes * dc->dc_ht * hwplanebits)
		cookie = (paddr_t)(trunc_page(OMFB_FB_RADDR) + offset);
#endif
	return cookie;
}

int
omgetcmap(struct omfb_softc *sc, struct wsdisplay_cmap *p)
{
	u_int index = p->index, count = p->count;
        unsigned int cmsize;
	int error;

	cmsize = sc->sc_dc->dc_cmsize;

	/* Don't touch colormap when we use 1bpp */
	if (cmsize == 0)
		return (0);

	if (index >= cmsize || count > cmsize - index)
		return (EINVAL);

	error = copyout(&sc->sc_dc->dc_cmap.r[index], p->red, count);
	if (error != 0)
		return (error);
	error = copyout(&sc->sc_dc->dc_cmap.g[index], p->green, count);
	if (error != 0)
		return (error);
	error = copyout(&sc->sc_dc->dc_cmap.b[index], p->blue, count);
	if (error != 0)
		return (error);

	return (0);
}

int
omsetcmap(struct omfb_softc *sc, struct wsdisplay_cmap *p)
{
	struct hwcmap cmap;
	u_int index = p->index, count = p->count;
        unsigned int cmsize, i;
	int error;

	cmsize = sc->sc_dc->dc_cmsize;

	/* Don't touch colormap when we use 1bpp */
	if (cmsize == 0)
		return (0);

	if (index >= cmsize || count > cmsize - index)
		return (EINVAL);

	error = copyin(p->red, &cmap.r[index], count);
	if (error != 0)
		return (error);
	error = copyin(p->green, &cmap.g[index], count);
	if (error != 0)
		return (error);
	error = copyin(p->blue, &cmap.b[index], count);
	if (error != 0)
		return (error);

	memcpy(&sc->sc_dc->dc_cmap.r[index], &cmap.r[index], count);
	memcpy(&sc->sc_dc->dc_cmap.g[index], &cmap.g[index], count);
	memcpy(&sc->sc_dc->dc_cmap.b[index], &cmap.b[index], count);

	if (hwplanebits == 4) {
		struct bt454 *odac = (struct bt454 *)OMFB_RAMDAC;
		odac->bt_addr = (u_int8_t)index;
		for (i = index; i < index + count; i++) {
			odac->bt_cmap = sc->sc_dc->dc_cmap.r[i];
			odac->bt_cmap = sc->sc_dc->dc_cmap.g[i];
			odac->bt_cmap = sc->sc_dc->dc_cmap.b[i];
		}
	}
	else if (hwplanebits == 8) {
		struct bt458 *ndac = (struct bt458 *)OMFB_RAMDAC;
		ndac->bt_addr = (u_int8_t)index;
		for (i = index; i < index + count; i++) {
			ndac->bt_cmap = sc->sc_dc->dc_cmap.r[i];
			ndac->bt_cmap = sc->sc_dc->dc_cmap.g[i];
			ndac->bt_cmap = sc->sc_dc->dc_cmap.b[i];
		}
	}
	return (0);
}

void
omfb_getdevconfig(paddr_t paddr, struct om_hwdevconfig *dc)
{
	struct rasops_info *ri;
	union {
		struct { short h, v; } p;
		u_int32_t u;
	} rfcnt;

	/*
	 * If this is the first time call, check how many planes we really
	 * have.  This method is for 1, 4, and 8 bpp boards, must be checked
	 * different way for 24 bpp board...
	 */
	if ((hwplanebits > 0) && (dc->dc_depth_checked == 0)) {
		int i;
		u_int32_t *max, save;

		for (i = 0; i < 8; i++) {
			max = (u_int32_t *)trunc_page(OMFB_FB_RADDR
			    + OMFB_FB_PLANESIZE * i);
			save = *max;
			*(volatile uint32_t *)max = 0x5a5a5a5a;
			if (*max != 0x5a5a5a5a)
				break;
			*max = save;
		}
		hwplanebits = i;	/* should be 1, 4, or 8 */

		dc->dc_depth_checked = 1;
	}

	dc->dc_wid = 1280;
	dc->dc_ht = 1024;
	dc->dc_depth = hwplanebits;
	dc->dc_rowbytes = 2048 / 8;
	dc->dc_cmsize = (hwplanebits == 1) ? 0 : 1 << hwplanebits;
	dc->dc_videobase = paddr;

	/* set default colormap */
	omfb_set_default_cmap(dc);

	/* adjust h/v origin on screen */
	rfcnt.p.h = 7;
	rfcnt.p.v = -27;
	/* single write of 0x007ffe6 */
	*(volatile u_int32_t *)OMFB_RFCNT = rfcnt.u;

	/* clear the screen */
	omfb_clear_framebuffer(dc);

	/* initialize the raster */
	ri = &dc->dc_ri;
	ri->ri_width = dc->dc_wid;
	ri->ri_height = dc->dc_ht;
	ri->ri_depth = 1;	/* since planes are independently addressed */
	ri->ri_stride = dc->dc_rowbytes;
	ri->ri_bits = (void *)dc->dc_videobase;
	ri->ri_flg = RI_CENTER;
	ri->ri_hw = dc;

	rasops_init(ri, 35, 80);

	ri->ri_ops.copycols = om_copycols;
	ri->ri_ops.erasecols = om_erasecols;
	ri->ri_ops.copyrows = om_copyrows;
	ri->ri_ops.eraserows = om_eraserows;
	omfb_stdscreen.ncols = ri->ri_cols;
	omfb_stdscreen.nrows = ri->ri_rows;
	omfb_stdscreen.textops = &ri->ri_ops;
	omfb_stdscreen.fontwidth = ri->ri_font->fontwidth;
	omfb_stdscreen.fontheight = ri->ri_font->fontheight;

	/* set up depth-depend functions and so on */
	if ((hwplanebits == 4) || (hwplanebits == 8)) {
		setup_omrasops4(ri);
	} else {
		setup_omrasops1(ri);
	}
}

int
omfb_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *attrp)
{
	struct omfb_softc *sc = v;
	struct rasops_info *ri = &sc->sc_dc->dc_ri;

	if (sc->nscreens > 0)
		return (ENOMEM);

	*cookiep = ri;
	*curxp = 0;
	*curyp = 0;
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, attrp);
	sc->nscreens++;
	return (0);
}

void
omfb_free_screen(void *v, void *cookie)
{
	struct omfb_softc *sc = v;

	sc->nscreens--;
}

int
omfb_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	return 0;
}

int
omfb_load_font(void *v, void *emulcookie, struct wsdisplay_font *font)
{
	struct omfb_softc *sc = v;
	struct rasops_info *ri = &sc->sc_dc->dc_ri;

	return rasops_load_font(ri, emulcookie, font);
}

int
omfb_list_font(void *v, struct wsdisplay_font *font)
{
	struct omfb_softc *sc = v;
	struct rasops_info *ri = &sc->sc_dc->dc_ri;

	return rasops_list_font(ri, font);
}

/*
 * Change `pseudo' depth, set the default colormap, and clear frame buffer.
 * Note: when called with depth == 0, change to the original hardware depth. 
 */
int
omfb_set_gfxmode(struct omfb_softc *sc, struct wsdisplay_gfx_mode *wsd_gfxmode)
{
        /* LUNA's fb is fixed size */
        if ((wsd_gfxmode->width != sc->sc_dc->dc_wid)
                || (wsd_gfxmode->height != sc->sc_dc->dc_ht))
                        return -1;

	/* if depth == 0, set the original hardware depth */
	if (wsd_gfxmode->depth == 0)
		wsd_gfxmode->depth = hwplanebits;

        switch (wsd_gfxmode->depth) {
        case 1:
		/* all frame buffer support this */
		sc->sc_dc->dc_depth = 1;
		sc->sc_dc->dc_cmsize = 0;
                break;
        case 4:
		if ((hwplanebits == 4) || (hwplanebits == 8)) {
			sc->sc_dc->dc_depth = 4;
			sc->sc_dc->dc_cmsize = 16;
			break;
		} else
			return -1;
        case 8:
		if (hwplanebits == 8) {
			sc->sc_dc->dc_depth = 8;
			sc->sc_dc->dc_cmsize = 256;
			break;
		} else
			return -1;
        default:
                return -1;
        }

	omfb_set_default_cmap(sc->sc_dc);
	omfb_clear_framebuffer(sc->sc_dc);

        return 0;
}

/*
 * Clear all planes of frame buffer
 */
void
omfb_clear_framebuffer(struct om_hwdevconfig *dc)
{
	int i;

	*(volatile u_int32_t *)OMFB_PLANEMASK = 0xff;	/* all planes */
	((volatile u_int32_t *)OMFB_ROPFUNC)[5] = ~0;	/* ROP copy */
	for (i = 0; i < dc->dc_ht * dc->dc_rowbytes / sizeof(u_int32_t); i++)
		*((volatile u_int32_t *)dc->dc_videobase + i) = 0;
	*(volatile u_int32_t *)OMFB_PLANEMASK = 0x01;	/* plane #0 only */
}

/*
 * Set default colormap; white on black for 1bpp, ANSI 16 colors for 4/8 bpp.
 *
 * Note about workaround for 8bpp frame buffer:
 *
 * Current LUNA wscons touches only first 4 planes (plane #0-#3), but
 * other program (e.g. mlterm-fb) can use all 8 planes on an 8bpp
 * frame buffer.  When such program exits, it may not clear all planes,
 * so there may be some visible garbage data on the other 4 planes
 * (plane #4-#7) when we use default 256 rasops_cmap directly.
 *
 * We should manage all 8 planes on LUNA, but that will be too much
 * overhead for 16 colors wscons.  So, by repeating 16 colors in 256
 * colormap, we can ignore the values on the other 4 planes.
 */
void
omfb_set_default_cmap(struct om_hwdevconfig *dc)
{
	int i;

	if ((hwplanebits == 1) || (hwplanebits == 4)) {
		struct bt454 *odac = (struct bt454 *)OMFB_RAMDAC;

		odac->bt_addr = 0;
		if (dc->dc_depth == 1) {
			/* white on black */
			for (i = 0; i < 16; i++) {
				u_int8_t val = i % 2 ? 255 : 0;

				odac->bt_cmap = dc->dc_cmap.r[i] = val;
				odac->bt_cmap = dc->dc_cmap.g[i] = val;
				odac->bt_cmap = dc->dc_cmap.b[i] = val;
			}
		} else {
			for (i = 0; i < 16; i++) {
			/* Set ANSI 16 colors */
				odac->bt_cmap = dc->dc_cmap.r[i]
				    = rasops_cmap[i * 3];
				odac->bt_cmap = dc->dc_cmap.g[i]
				    = rasops_cmap[i * 3 + 1];
				odac->bt_cmap = dc->dc_cmap.b[i]
				    = rasops_cmap[i * 3 + 2];
			}
		}
	} else if (hwplanebits == 8) {
		struct bt458 *ndac = (struct bt458 *)OMFB_RAMDAC;

		/*
		 * Initialize the Bt458.  When we write to control registers,
		 * the address is not incremented automatically. So we specify
		 * it ourselves for each control register.
		 */
		ndac->bt_addr = 0x04;
		ndac->bt_ctrl = 0xff; /* all planes will be read */
		ndac->bt_addr = 0x05;
		ndac->bt_ctrl = 0x00; /* all planes have non-blink */
		ndac->bt_addr = 0x06;
		ndac->bt_ctrl = 0x40; /* palette enabled, ovly plane disabled */
		ndac->bt_addr = 0x07;
		ndac->bt_ctrl = 0x00; /* no test mode */

		ndac->bt_addr = 0;
		if (dc->dc_depth == 1) {
			/* white on black */
			for (i = 0; i < 256; i++) {
				u_int8_t val = i % 2 ? 255 : 0;

				ndac->bt_cmap = dc->dc_cmap.r[i] = val;
				ndac->bt_cmap = dc->dc_cmap.g[i] = val;
				ndac->bt_cmap = dc->dc_cmap.b[i] = val;
			}
		} else {
			/*
			 * Set ANSI 16 colors.  On 8bpp frame buffer, repeat
			 * 16 colors in 256 colormap as described above.
			 */
			for (i = 0; i < 256; i++) {
				int index = i % 16;
				ndac->bt_cmap = dc->dc_cmap.r[i]
				    = rasops_cmap[index * 3];
				ndac->bt_cmap = dc->dc_cmap.g[i]
				    = rasops_cmap[index * 3 + 1];
				ndac->bt_cmap = dc->dc_cmap.b[i]
				    = rasops_cmap[index * 3 + 2];
			}
		}
	}
}
@


1.23
log
@Harmonize the way frame buffer drivers display resolution and color
depth when attaching.

OK visa@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.22 2014/07/22 13:39:16 aoyama Exp $ */
d51 2
a53 1
#include <machine/autoconf.h>
d62 1
a62 1
		unsigned :24;
d64 1
a64 1
		unsigned :24;
d66 1
a66 1
		unsigned :24;
d68 1
a68 1
		unsigned :24;
d71 4
a74 4
#define	OMFB_RFCNT	0xB1000000	/* video h-origin/v-origin */
#define	OMFB_PLANEMASK	0xB1040000	/* planemask register */
#define	OMFB_FB_WADDR	0xB1080008	/* common plane */
#define	OMFB_FB_RADDR	0xB10C0008	/* plane #0 */
d76 3
a78 3
#define	OMFB_ROPFUNC	0xB12C0000	/* ROP function code */
#define	OMFB_RAMDAC	0xC1100000	/* Bt454/Bt458 RAMDAC */
#define	OMFB_SIZE	(0xB1300000 - 0xB1080000 + PAGE_SIZE)
@


1.22
log
@Use MI rasops_cmap, instead of MD-defined ANSI colormap.

Note about workaround for 8bpp frame buffer:

Current LUNA wscons touches only first 4 planes (plane #0-#3), but
other program (e.g. mlterm-fb) can use all 8 planes on an 8bpp frame
buffer.  When such program exits, it may not clear all planes, so
there may be some visible garbage data on the other 4 planes (plane
#4-#7) when we use default 256 rasops_cmap directly.

We should manage all 8 planes on LUNA, but that will be too much
overhead for 16 colors wscons.  So, by repeating 16 colors in 256
colormap, we can ignore the values on the other 4 planes.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.21 2014/01/15 11:13:53 aoyama Exp $ */
d203 1
a203 1
	printf(": %d x %d, %dbpp\n", sc->sc_dc->dc_wid, sc->sc_dc->dc_ht,
@


1.21
log
@Add WSDISPLAYIO_SETGFXMODE ioctl on LUNA's frame buffer.

This ioctl changes `pseudo' frame buffer depth, in order to use color
wscons and monochrome X server both.  Also need to some
luna88k-specific initialization in
xenocara/driver/xf86-video-wsfb/src/wsfb_driver.c.
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.20 2014/01/03 13:48:25 aoyama Exp $ */
a85 23
static const struct {
	u_int8_t r;
	u_int8_t g;
	u_int8_t b;
} ansicmap[16] = {
	{    0,    0,    0},
	{ 0x80,    0,    0},
	{    0, 0x80,    0},
	{ 0x80, 0x80,    0},
	{    0,    0, 0x80},
	{ 0x80,    0, 0x80},
	{    0, 0x80, 0x80},
	{ 0xc0, 0xc0, 0xc0},
	{ 0x80, 0x80, 0x80},
	{ 0xff,    0,    0},
	{    0, 0xff,    0},
	{ 0xff, 0xff,    0},
	{    0,    0, 0xff},
	{ 0xff,    0, 0xff},
	{    0, 0xff, 0xff},
	{ 0xff, 0xff, 0xff},
};

d582 13
a594 1
 * set default colormap; white on black for 1bpp, ANSI 16 colors for 4/8 bpp.
d616 1
a616 1
			/* ANSI 16 colors */
d618 1
a618 1
				    = ansicmap[i].r;
d620 1
a620 1
				    = ansicmap[i].g;
d622 1
a622 1
				    = ansicmap[i].b;
d654 2
a655 2
			 * Set ANSI 16 colors.  We only supports 4bpp console
			 * right now, repeat 16 colors in 256 colormap.
d658 1
d660 1
a660 1
				    = ansicmap[i % 16].r;
d662 1
a662 1
				    = ansicmap[i % 16].g;
d664 1
a664 1
				    = ansicmap[i % 16].b;
@


1.20
log
@KNF, update comments, and delete LUNA(m68k) specific DIPSW comments.
No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.19 2014/01/02 15:30:34 aoyama Exp $ */
d162 4
d286 3
a413 1
	int bpp, i;
a442 16
#if 1 /* XXX: Xorg mono server works only bpp == 1 for now */
	switch (hwplanebits) {
	case 8:
		bpp = 8;
		break;
	default:
	case 4:
		bpp = 4;
		break;
	case 1:
		bpp = 1;
		break;
	}
#else
	bpp = 1;
#endif
d445 1
a445 1
	dc->dc_depth = bpp;
d447 1
a447 1
	dc->dc_cmsize = (bpp == 1) ? 0 : 1 << bpp;
d450 2
a451 38
	/* WHITE on BLACK */
	if ((hwplanebits == 1) || (hwplanebits == 4)) {
		struct bt454 *odac = (struct bt454 *)OMFB_RAMDAC;

		odac->bt_addr = 0;
		for (i = 0; i < 16; i++) {
			odac->bt_cmap = dc->dc_cmap.r[i] = ansicmap[i].r;
			odac->bt_cmap = dc->dc_cmap.g[i] = ansicmap[i].g;
			odac->bt_cmap = dc->dc_cmap.b[i] = ansicmap[i].b;
		}
	} else if (hwplanebits == 8) {
		struct bt458 *ndac = (struct bt458 *)OMFB_RAMDAC;

		/*
		 * Initialize the Bt458.  When we write to control registers,
		 * the address is not incremented automatically. So we specify
		 * it ourselves for each control register.
		 */
		ndac->bt_addr = 0x04;
		ndac->bt_ctrl = 0xff; /* all planes will be read */
		ndac->bt_addr = 0x05;
		ndac->bt_ctrl = 0x00; /* all planes have non-blink */
		ndac->bt_addr = 0x06;
		ndac->bt_ctrl = 0x40; /* palette enabled, ovly plane disabled */
		ndac->bt_addr = 0x07;
		ndac->bt_ctrl = 0x00; /* no test mode */

		/*
		 * Set ANSI 16 colors.  We only supports 4bpp console right
		 * now, repeat 16 colors in 256 colormap.
		 */
		ndac->bt_addr = 0;
		for (i = 0; i < 256; i++) {
			ndac->bt_cmap = dc->dc_cmap.r[i] = ansicmap[i % 16].r;
			ndac->bt_cmap = dc->dc_cmap.g[i] = ansicmap[i % 16].g;
			ndac->bt_cmap = dc->dc_cmap.b[i] = ansicmap[i % 16].b;
		}
	}
d460 1
a460 5
	*(volatile u_int32_t *)OMFB_PLANEMASK = 0xff;
	((volatile u_int32_t *)OMFB_ROPFUNC)[5] = ~0;	/* ROP copy */
	for (i = 0; i < dc->dc_ht * dc->dc_rowbytes / sizeof(u_int32_t); i++)
		*((volatile u_int32_t *)dc->dc_videobase + i) = 0;
	*(volatile u_int32_t *)OMFB_PLANEMASK = 0x01;
d541 137
@


1.19
log
@Add primary support for LUNA-88K 4bpp/8bpp frame buffer.

This brings color support on LUNA's wscons.  And, with the help of recent
development version of 'mlterm-fb' (frame buffer version of ports/x11/mlterm),
graphic images can be displayed in 16/256 colors on the screen.  Thanks to
arakiken, the original developer of mlterm!

This diff is based on NetBSD/luna68k work:
http://mail-index.netbsd.org/source-changes/2013/12/28/msg050266.html

Need more work to coexist with the monochrome X.Org server.

"go ahead!" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.18 2013/12/30 07:33:40 aoyama Exp $ */
d184 1
a184 1
/* hardware plane bits; retrieved at boot, will be updated in omfbmatch() */
d191 1
a191 3
omfbmatch(parent, cf, aux)
	struct device *parent;
	void *cf, *aux;
d208 1
a208 3
omfbattach(parent, self, args)
	struct device *parent, *self;
	void *args;
d223 1
a223 1
		hwplanebits);
d235 1
a235 1
omfb_cnattach()
d249 1
a249 6
omfbioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d304 1
a304 4
omfbmmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d324 1
a324 3
omgetcmap(sc, p)
	struct omfb_softc *sc;
	struct wsdisplay_cmap *p;
d353 1
a353 3
omsetcmap(sc, p)
	struct omfb_softc *sc;
	struct wsdisplay_cmap *p;
d405 1
a405 3
omfb_getdevconfig(paddr, dc)
	paddr_t paddr;
	struct om_hwdevconfig *dc;
d425 1
a425 1
				+ OMFB_FB_PLANESIZE * i);
d437 1
a437 1
#if 1	/* Workaround for making Xorg mono server work */
d440 1
a440 1
		bpp = 8;	/* XXX check monochrome bit in DIPSW */
d444 1
a444 1
		bpp = 4;	/* XXX check monochrome bit in DIPSW */
a460 1

d543 2
a544 6
omfb_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
d561 1
a561 3
omfb_free_screen(v, cookie)
	void *v;
	void *cookie;
d569 2
a570 6
omfb_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
@


1.18
log
@Correct initialization of Bt458, used in LUNA's 8bpp frame buffer.

According to the manual, the address register does not automatically
increment when we access to the control registers.  Also we disable
overlay planes, because we do not use them.

This diff should be one of preliminaries for upcoming colored wscons on
luna88k.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.17 2013/10/21 10:36:15 miod Exp $ */
d79 30
d114 1
d116 1
a120 7
struct hwcmap {
#define CMAP_SIZE 256
	u_int8_t r[CMAP_SIZE];
	u_int8_t g[CMAP_SIZE];
	u_int8_t b[CMAP_SIZE];
};

a123 1
	struct hwcmap sc_cmap;		/* software copy of colormap */
a133 2
int	om_cursor(void *, int, int, int);
int	om_putchar(void *, int, int, u_int, long);
d138 2
a205 20

	/*
	 * Check how many planes we have.  This is for 1, 4, and 8 bpp
	 * boards, must be checked different way for 24 bpp board...
	 */
	if (hwplanebits > 0) {
		int i;
		u_int32_t *max, save;

		for (i = 0; i < 8; i++) {
			max = (u_int32_t *)trunc_page(OMFB_FB_RADDR
				+ OMFB_FB_PLANESIZE * i);
			save = *max;
			*(volatile uint32_t *)max = 0x5a5a5a5a;
			if (*max != 0x5a5a5a5a)
				break;
			*max = save;
		}
		hwplanebits = i;	/* should be 1, 4, or 8 */
	}
a228 4
	/* WHITE on BLACK */
	memset(&sc->sc_cmap, 255, sizeof(struct hwcmap));
	sc->sc_cmap.r[0] = sc->sc_cmap.g[0] = sc->sc_cmap.b[0] = 0;

d329 1
a329 1
	if (offset >= 0 && offset < dc->dc_rowbytes * dc->dc_ht)
d353 1
a353 1
	error = copyout(&sc->sc_cmap.r[index], p->red, count);
d356 1
a356 1
	error = copyout(&sc->sc_cmap.g[index], p->green, count);
d359 1
a359 1
	error = copyout(&sc->sc_cmap.b[index], p->blue, count);
d371 1
d385 1
a385 1
	error = copyin(p->red, &sc->sc_cmap.r[index], count);
d388 1
a388 1
	error = copyin(p->green, &sc->sc_cmap.g[index], count);
d391 1
a391 1
	error = copyin(p->blue, &sc->sc_cmap.b[index], count);
d395 4
d403 3
a405 3
			odac->bt_cmap = sc->sc_cmap.r[i];
			odac->bt_cmap = sc->sc_cmap.g[i];
			odac->bt_cmap = sc->sc_cmap.b[i];
d412 3
a414 3
			ndac->bt_cmap = sc->sc_cmap.r[i];
			ndac->bt_cmap = sc->sc_cmap.g[i];
			ndac->bt_cmap = sc->sc_cmap.b[i];
d432 24
a455 1
#if 0	/* Workaround for making Xorg mono server work */
d484 4
a487 7
		odac->bt_cmap = 0;
		odac->bt_cmap = 0;
		odac->bt_cmap = 0;
		for (i = 1; i < 16; i++) {
			odac->bt_cmap = 255;
			odac->bt_cmap = 255;
			odac->bt_cmap = 255;
d492 5
a496 1
		/* Initialize the Bt458 */
d506 4
d511 4
a514 7
		ndac->bt_cmap = 0;
		ndac->bt_cmap = 0;
		ndac->bt_cmap = 0;
		for (i = 1; i < 256; i++) {
			ndac->bt_cmap = 255;
			ndac->bt_cmap = 255;
			ndac->bt_cmap = 255;
a542 4
	omfb_stdscreen.ncols = ri->ri_cols;
	omfb_stdscreen.nrows = ri->ri_rows;
	ri->ri_ops.cursor = om_cursor;
	ri->ri_ops.putchar = om_putchar;
d547 2
d552 7
a558 1
	omfb_stdscreen.capabilities = ri->ri_caps & ~WSSCREEN_UNDERLINE;
@


1.17
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.16 2013/10/20 20:07:23 miod Exp $ */
d467 1
a467 1
#if 0		/* This doesn't work.  Don't touch ROM setting for now. */
d470 1
d472 3
a474 1
		ndac->bt_ctrl = 0x43; /* pallete enabled, ovly plane */
d476 1
a476 1
#endif
@


1.16
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.15 2013/08/16 08:47:00 aoyama Exp $ */
d129 9
a137 7
int   omfbioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t omfbmmap(void *, off_t, int);
int   omfb_alloc_screen(void *, const struct wsscreen_descr *,
				      void **, int *, int *, long *);
void  omfb_free_screen(void *, void *);
int   omfb_show_screen(void *, void *, int,
				void (*) (void *, int, int), void *);
d144 3
a146 1
	.show_screen = omfb_show_screen
d565 18
@


1.15
log
@Check number of planes (1, 4, or 8bpp) by ourselves, because PROM
seems not distinguish between 1bpp and 4bpp framebuffers.  Now
hwplanebits should have the correct value after omfbmatch().

This also makes the monochrome X.org server work with a 4bpp
framebuffer correctly, i.e. white and black are not inverted.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.14 2013/05/16 13:59:10 aoyama Exp $ */
d138 5
a142 9
	omfbioctl,
	omfbmmap,
	omfb_alloc_screen,
	omfb_free_screen,
	omfb_show_screen,
	NULL,	/* load_font */
	NULL,	/* scrollback */
	NULL,	/* getchar */
	NULL	/* burner */
@


1.14
log
@Ignore colormap operations at 1bpp, to work with Xorg wsfb driver.
Still need more work in Xorg...

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.13 2013/04/28 23:33:12 aoyama Exp $ */
d74 1
d160 2
a161 1
extern int hwplanebits;	/* hardware plane bits; retrieved at boot */
d182 20
d223 1
a223 1
	    sc->sc_dc->dc_depth);
d451 2
a452 2
	if (hwplanebits == 4) {
		/* XXX Need Bt454 more initialization */
d454 1
@


1.13
log
@Preliminary modifications for Xorg 1bpp server, based on OpenBSD/hp300
and NetBSD/luna68k.  Need more work in Xorg.

luna88k/conf/GENERIC:
- enable wsmux on GENERIC kernel

luna88k/dev/luanfb.c:
- make hardware access volatile'd
- add extra ioctl(2) used in Xorg wsfb driver
- add some workaround

luna88k/dev/lunaws.c:
- add WSDISPLAY_COMPAT_RAWKBD stuff for Xorg keyboard input

luna88k/dev/omrasops.c:
- change 'caddr_t' to 'u_int8_t *'

"go for it!" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.12 2012/01/08 00:31:35 aoyama Exp $ */
d303 1
a303 1
#if 0	/* Workaround for making Xorg 1bpp server work */
d323 5
d354 5
d405 1
a405 1
#if 0	/* Workaround for making Xorg 1bpp server work */
@


1.12
log
@Make allocated memory zeroed.  This fixes the problem that we got a
panic at attaching fb when we use the serial console.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.11 2010/12/26 15:40:59 miod Exp $ */
d55 2
a56 2
	u_int8_t bt_addr;		/* map address register */
	u_int8_t bt_cmap;		/* colormap data register */
d60 1
a60 1
	u_int8_t bt_addr;		/* map address register */
d62 1
a62 1
	u_int8_t bt_cmap;		/* colormap data register */
d64 1
a64 1
	u_int8_t bt_ctrl;		/* control register */
d66 1
a66 1
	u_int8_t bt_omap;		/* overlay (cursor) map register */
d76 1
a76 1
#define	OMFB_SIZE	(0xB1300000 - 0xB1080000 + NBPG)
d194 1
a194 2
	}
	else {
d203 4
a206 5
#if 0	/* WHITE on BLACK */
	cm = &sc->sc_cmap;
	memset(cm, 255, sizeof(struct hwcmap));
	cm->r[0] = cm->g[0] = cm->b[0] = 0;
#endif
d252 5
a256 1
#undef fbt
d265 4
d297 2
d300 1
a300 3
	if (offset & PGOFSET)
		return (-1);
	if (offset >= OMFB_SIZE || offset < 0)
d303 8
a310 1
	return (trunc_page(sc->sc_dc->dc_videobase) + offset);
d364 2
a365 2
		odac->bt_addr = index;
		for (i = index; i < count; i++) {
d373 2
a374 2
		ndac->bt_addr = index;
		for (i = index; i < count; i++) {
d395 1
d408 3
d418 1
a418 1
#if 0 /* WHITE on BLACK XXX experiment resulted in WHITE on SKYBLUE... */
d420 1
a420 1
		/* XXX Need Bt454 initialization */
d431 1
a431 2
	}
	else if (hwplanebits == 8) {
d434 1
d440 1
a450 1
#endif
d455 2
a456 1
	*(u_int32_t *)OMFB_RFCNT = rfcnt.u; /* single write of 0x007ffe6 */
d459 2
a460 2
	*(u_int32_t *)OMFB_PLANEMASK = 0xff;
	((u_int32_t *)OMFB_ROPFUNC)[5] = ~0;	/* ROP copy */
d462 2
a463 2
		*((u_int32_t *)dc->dc_videobase + i) = 0;
	*(u_int32_t *)OMFB_PLANEMASK = 0x01;
@


1.11
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.10 2009/09/05 14:09:35 miod Exp $ */
d197 2
a198 1
		    malloc(sizeof(struct om_hwdevconfig), M_DEVBUF, M_WAITOK);
@


1.10
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.9 2008/06/26 05:42:11 ray Exp $ */
d296 1
a296 1
	return atop(trunc_page(sc->sc_dc->dc_videobase) + offset);
@


1.9
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.8 2006/11/29 12:13:54 miod Exp $ */
d109 6
a114 6
void	om_cursor(void *, int, int, int);
void	om_putchar(void *, int, int, u_int, long);
void	om_copycols(void *, int, int, int, int);
void	om_copyrows(void *, int, int, int num);
void	om_erasecols(void *, int, int, int, long);
void	om_eraserows(void *, int, int, long);
@


1.8
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.7 2006/08/06 13:04:33 miod Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.7
log
@Switch luna88k from rcons to rasops. Tested by aoyama@@
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.6 2006/01/10 18:56:11 miod Exp $ */
d219 1
@


1.6
log
@struct cfdriver shall not be declared as const (oops).
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.5 2005/01/31 06:41:27 miod Exp $ */
a53 1
#include <dev/rcons/raster.h>
a54 1
#include <dev/wscons/wscons_raster.h>
d56 1
d92 1
a92 2
	struct raster	dc_raster;	/* raster description */
	struct rcons	dc_rcons;	/* raster blitter control info */
d115 7
a121 1
extern struct wsdisplay_emulops omfb_emulops;
d124 1
a124 4
	"std", 0, 0,
	&omfb_emulops,
	0, 0,
	0
d227 1
d231 2
a232 2
	(*omfb_emulops.alloc_attr)(&dc->dc_rcons, 0, 0, 0, &defattr);
	wsdisplay_cnattach(&omfb_stdscreen, &dc->dc_rcons, 0, 0, defattr);
d381 1
a381 2
	struct raster *rap;
	struct rcons *rcp;
d440 1
a440 1
	/* adjust h/v orgin on screen */
d448 1
a448 1
	for (i = 0; i < dc->dc_ht * dc->dc_rowbytes/sizeof(u_int32_t); i++)
d453 23
a475 17
	rap = &dc->dc_raster;
	rap->width = dc->dc_wid;
	rap->height = dc->dc_ht;
	rap->depth = dc->dc_depth;
	rap->linelongs = dc->dc_rowbytes / sizeof(u_int32_t);
	rap->pixels = (u_int32_t *)dc->dc_videobase;

	/* initialize the raster console blitter */
	rcp = &dc->dc_rcons;
	rcp->rc_sp = rap;
	rcp->rc_crow = rcp->rc_ccol = -1;
	rcp->rc_crowp = &rcp->rc_crow;
	rcp->rc_ccolp = &rcp->rc_ccol;
	rcons_init(rcp, 34, 80);

	omfb_stdscreen.nrows = dc->dc_rcons.rc_maxrow;
	omfb_stdscreen.ncols = dc->dc_rcons.rc_maxcol;
d487 1
a487 1
	long defattr;
d492 1
a492 1
	*cookiep = &sc->sc_dc->dc_rcons; /* one and only for now */
d495 1
a495 2
	(*omfb_emulops.alloc_attr)(&sc->sc_dc->dc_rcons, 0, 0, 0, &defattr);
	*attrp = defattr;
@


1.5
log
@Be sure to always return an error for unrecognized ioctls. Found by matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.4 2005/01/05 23:04:24 miod Exp $ */
d161 1
a161 1
const struct cfdriver fb_cd = {
@


1.4
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.3 2004/05/10 10:30:23 aoyama Exp $ */
d275 1
@


1.3
log
@Make the time getting frame buffer depth earlier.  Without this
modification, bitmap console depth is always 4, because consinit() is
called before cpu_startup().

And use frame buffer depth bits(1,4,8) rather than mask value(0x01,
0x0f, 0xff), same as the value in ROM work area.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.2 2004/04/24 13:37:44 miod Exp $ */
d268 2
@


1.3.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/* $OpenBSD$ */
@


1.2
log
@Define wscons device ids for the Luna devices.
@
text
@d1 1
a1 1
/* $OpenBSD: lunafb.c,v 1.1.1.1 2004/04/21 15:23:52 aoyama Exp $ */
d165 1
a165 1
extern int hwplanemask;	/* hardware planemask; retrieved at boot */
d183 1
a183 1
	if (hwplanemask == 0)
d349 1
a349 1
	if (hwplanemask == 0x0f) {
d358 1
a358 1
	else if (hwplanemask == 0xff) {
d383 2
a384 2
	switch (hwplanemask) {
	case 0xff:
d388 1
a388 1
	case 0x0f:
d403 1
a403 1
	if (hwplanemask == 0x0f) {
d416 1
a416 1
	else if (hwplanemask == 0xff) {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d248 1
a248 1
		*(u_int *)data = WSDISPLAY_TYPE_UNKNOWN; /* XXX for now */
@


1.1.1.1
log
@Initial commit for OpenBSD/luna88k, based on OpenBSD/mvme88k, NetBSD/luna68k and CMU Mach.
@
text
@@
