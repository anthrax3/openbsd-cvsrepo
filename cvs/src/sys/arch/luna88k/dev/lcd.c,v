head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.4
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.4.0.26
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.22
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.20
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.18
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.16
	OPENBSD_5_0:1.4.0.14
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.12
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.10
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.6
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.8
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.4
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.3.0.6
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.4
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.2
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.1.0.12
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.10
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.8
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.6
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.4
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2
	LUNA88K_INIT:1.1.1.1
	AOYAMA:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2017.03.20.19.37.54;	author miod;	state Exp;
branches;
next	1.8;
commitid	QfsUP8Cps6nKwYtj;

1.8
date	2017.03.15.11.13.34;	author aoyama;	state Exp;
branches;
next	1.7;
commitid	UCXAn5VTH6eACbRl;

1.7
date	2015.02.10.22.42.35;	author miod;	state Exp;
branches;
next	1.6;
commitid	QvtEkPTPuIHOys7J;

1.6
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.5;
commitid	C5iGb36LQxjM60Q3;

1.5
date	2014.06.07.11.55.35;	author aoyama;	state Exp;
branches;
next	1.4;
commitid	eFZIGuEBLAQNOVxZ;

1.4
date	2008.06.26.05.42.11;	author ray;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.09.14.26.09;	author aoyama;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.29.14.18.00;	author aoyama;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.21.15.23.52;	author aoyama;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.04.21.15.23.52;	author aoyama;	state Exp;
branches;
next	;

1.1.2.1
date	2004.06.05.23.09.46;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Replace hardcoded addresses with symbolic constants from <machine/board.h>
for enhanced grepability and fewer bad surprises.

ok aoyama@@
@
text
@/* $OpenBSD: lcd.c,v 1.8 2017/03/15 11:13:34 aoyama Exp $ */
/* $NetBSD: lcd.c,v 1.2 2000/01/07 05:13:08 nisimura Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Tohru Nishimura.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>

#include <machine/autoconf.h>
#include <machine/board.h>
#include <machine/conf.h>
#include <machine/lcd.h>

#define PIO1_MODE_OUTPUT	0x84
#define PIO1_MODE_INPUT		0x94

#define POWER	0x10

#define ENABLE	0x80
#define DISABLE	0x00

#define WRITE_CMD	(0x00 | 0x00)
#define WRITE_DATA	(0x00 | 0x40)
#define READ_BUSY	(0x20 | 0x00)
#define READ_DATA	(0x20 | 0x40)

#define LCD_INIT	0x38
#define LCD_ENTRY	0x06
#define LCD_ON		0x0c
#define LCD_CLS		0x01
#define LCD_HOME	0x02
#define LCD_LOCATE(X, Y)	(((Y) & 1 ? 0xc0 : 0x80) | ((X) & 0x0f))

#define LCD_MAXBUFLEN	80

struct pio {
	volatile u_int8_t portA;
        volatile unsigned : 24;
	volatile u_int8_t portB;
        volatile unsigned : 24;
	volatile u_int8_t portC;
        volatile unsigned : 24;
	volatile u_int8_t cntrl;
        volatile unsigned : 24;
};

/* Autoconf stuff */
int  lcd_match(struct device *, void *, void *);
void lcd_attach(struct device *, struct device *, void *);

struct lcd_softc {
	struct device sc_dev;
	int sc_opened;
};

const struct cfattach lcd_ca = {
	sizeof(struct lcd_softc), lcd_match, lcd_attach
};

struct cfdriver lcd_cd = {
	NULL, "lcd", DV_DULL, 0
};

/* Internal prototypes */
void lcdbusywait(void);
void lcdput(int);
void lcdctrl(int);
void lcdshow(const char *);
void greeting(void);

/* Internal variables */
				     /* "1234567890123456" */
static const char lcd_boot_message1[] = "OpenBSD/luna88k ";
static const char lcd_boot_message2[] = "   SX-9100/DT   ";

/*
 * Autoconf functions
 */
int
lcd_match(struct device *parent, void *cf, void *aux)
{
	struct mainbus_attach_args *ma = aux;

	if (strcmp(ma->ma_name, lcd_cd.cd_name))
		return 0;
	if (badaddr((vaddr_t)ma->ma_addr, 4))
		return 0;
	return 1;
}

void
lcd_attach(struct device *parent, struct device *self, void *aux)
{
	printf("\n");

	/* Say hello to the world on LCD. */
	greeting();
}

/*
 * open/close/write/ioctl
 */

int
lcdopen(dev_t dev, int flags, int fmt, struct proc *p)
{
	int unit = minor(dev);
	struct lcd_softc *sc;

	if (unit >= lcd_cd.cd_ndevs)
		return ENXIO;
	if ((sc = lcd_cd.cd_devs[unit]) == NULL)
		return ENXIO;
	if (sc->sc_opened)
		return EBUSY;
	sc->sc_opened = 1;

	return 0;
}

int
lcdclose(dev_t dev, int flags, int fmt, struct proc *p)
{
	int unit = minor(dev);
	struct lcd_softc *sc;

	sc = lcd_cd.cd_devs[unit];
	sc->sc_opened = 0;

	return 0;
}

int
lcdwrite(dev_t dev, struct uio *uio, int flag)
{
	int error;
	size_t len, i;
	char buf[LCD_MAXBUFLEN];

	len = uio->uio_resid;

	if (len > LCD_MAXBUFLEN)
		return EIO;

	error = uiomove(buf, len, uio);
	if (error)
		return EIO;

	for (i = 0; i < len; i++) {
		lcdput((int)buf[i]);
	}

	return 0;
}

int
lcdioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
{
	int val;

	/* check if the device opened with write mode */
	switch(cmd) {
	case LCDCLS:
	case LCDHOME:
	case LCDMODE:
	case LCDDISP:
	case LCDMOVE:
	case LCDSEEK:
	case LCDRESTORE:
		if ((flag & FWRITE) == 0)
			return EACCES;
		break;
	}

	switch(cmd) {
	case LCDCLS:
		lcdctrl(LCD_CLS);
		break;

	case LCDHOME:
		lcdctrl(LCD_HOME);
		break;

	case LCDMODE:
		val = *(int *)addr;
		switch (val) {
		case LCDMODE_C_LEFT:
		case LCDMODE_C_RIGHT:
		case LCDMODE_D_LEFT:
		case LCDMODE_D_RIGHT:
			lcdctrl(val);
			break;
		default:
			return EINVAL;
		}
		break;

	case LCDDISP:
		val = *(int *)addr;
		if ((val & 0x7) != val)
			return EINVAL;
		lcdctrl(val | 0x8);
		break;

	case LCDMOVE:
		val = *(int *)addr;
		switch (val) {
		case LCDMOVE_C_LEFT:
		case LCDMOVE_C_RIGHT:
		case LCDMOVE_D_LEFT:
		case LCDMOVE_D_RIGHT:
			lcdctrl(val);
			break;
		default:
			return EINVAL;
		}
		break;

	case LCDSEEK:
		val = *(int *)addr & 0x7f;
		lcdctrl(val | 0x80);
		break;

	case LCDRESTORE:
		greeting();
		break;

	default:
		return ENOTTY;
	}
	return 0;
}

/*
 * Internal functions
 */
void
lcdbusywait()
{
	struct pio *p1 = (struct pio *)OBIO_PIO1_BASE;
	int msb, s;

	s = splhigh();
	p1->cntrl = PIO1_MODE_INPUT;
	p1->portC = POWER | READ_BUSY | ENABLE;
	splx(s);

	do {
		msb = p1->portA & ENABLE;
		delay(5);
	} while (msb != 0);

	s = splhigh();
	p1->portC = POWER | READ_BUSY | DISABLE;
	splx(s);
}	

void
lcdput(int cc)
{
	struct pio *p1 = (struct pio *)OBIO_PIO1_BASE;
	int s;

	lcdbusywait();

	s = splhigh();
	p1->cntrl = PIO1_MODE_OUTPUT;

	p1->portC = POWER | WRITE_DATA | ENABLE;
	p1->portA = cc;
	p1->portC = POWER | WRITE_DATA | DISABLE;
	splx(s);
}

void
lcdctrl(int cc)
{
	struct pio *p1 = (struct pio *)OBIO_PIO1_BASE;
	int s;

	lcdbusywait();

	s = splhigh();
	p1->cntrl = PIO1_MODE_OUTPUT;

	p1->portC = POWER | WRITE_CMD | ENABLE;
	p1->portA = cc;
	p1->portC = POWER | WRITE_CMD | DISABLE;
	splx(s);
}

void
lcdshow(const char *s)
{
	int cc;

	while ((cc = *s++) != '\0')
		lcdput(cc);
}

void
greeting()
{
	lcdctrl(LCD_INIT);
	lcdctrl(LCD_ENTRY);
	lcdctrl(LCD_ON);

	lcdctrl(LCD_CLS);
	lcdctrl(LCD_HOME);

	lcdctrl(LCD_LOCATE(0, 0));
	lcdshow(lcd_boot_message1);
	lcdctrl(LCD_LOCATE(0, 1));
	lcdshow(lcd_boot_message2);
}
@


1.8
log
@We do not need while loop around uiomove(9) in lcdwrite().

Pointed out by Enami Tsugutomo while porting this driver to NetBSD/luna68k
by Izumi Tsutsui.

Tested by me.
@
text
@d1 1
a1 1
/* $OpenBSD: lcd.c,v 1.7 2015/02/10 22:42:35 miod Exp $ */
d40 1
d86 1
a86 1
struct cfattach lcd_ca = {
d270 1
a270 1
	struct pio *p1 = (struct pio *)0x4D000000;
d291 1
a291 1
	struct pio *p1 = (struct pio *)0x4D000000;
d308 1
a308 1
	struct pio *p1 = (struct pio *)0x4D000000;
@


1.7
log
@Convert to uiomove().
@
text
@d1 1
a1 1
/* $OpenBSD: lcd.c,v 1.5 2014/06/07 11:55:35 aoyama Exp $ */
d166 1
a166 2
	size_t len;
	size_t i, n;
d169 1
a169 1
	len = n = uio->uio_resid;
d174 3
a176 6
	while (n > 0) {
		error = uiomove(buf, n, uio);
		if (error)
			return EIO;
		n = uio->uio_resid;
	}
@


1.6
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d165 3
a167 2
	int error, len;
	int i, n;
d172 1
a172 1
	if ((len < 0) || (len > LCD_MAXBUFLEN))
d176 1
a176 1
		error = uiomovei(buf, n, uio);
d182 1
a182 1
	for(i = 0; i < len; i++) {
@


1.5
log
@Modify to ANSI-style function declarations.  No binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: lcd.c,v 1.4 2008/06/26 05:42:11 ray Exp $ */
d175 1
a175 1
		error = uiomove(buf, n, uio);
@


1.4
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: lcd.c,v 1.3 2007/02/09 14:26:09 aoyama Exp $ */
d109 1
a109 3
lcd_match(parent, cf, aux)
	struct device *parent;
	void *cf, *aux;
d121 1
a121 3
lcd_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d134 1
a134 4
lcdopen(dev, flags, fmt, p)
	dev_t dev;
	int flags, fmt;
	struct proc *p;
d151 1
a151 4
lcdclose(dev, flags, fmt, p)
	dev_t dev;
	int flags, fmt;
	struct proc *p;
d163 1
a163 4
lcdwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d189 1
a189 6
lcdioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
d291 1
a291 2
lcdput(cc)
	int cc;
d308 1
a308 2
lcdctrl(cc)
	int cc;
d325 1
a325 2
lcdshow(s)
	const char *s;
@


1.3
log
@LCD device driver, second step.  Now the driver works with autoconf.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: lcd.c,v 1.2 2007/01/29 14:18:00 aoyama Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.2
log
@LCD device driver support for luna88k, first step.
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: lcd.c,v 1.1 2004/04/21 15:23:52 aoyama Exp $ */
d46 1
d83 17
a107 1
int lcd_opened = 0;
d113 28
d150 4
a153 1
	if (minor(dev) != 0)
d155 3
a157 1
	if (lcd_opened)
d159 1
a159 1
	lcd_opened = 1;
d170 5
a174 1
	lcd_opened = 0;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a39 8
/* Taken from NetBSD/luna68k */

/*
 * XXX
 * Following code segments are subject to change.
 * XXX
 */

d43 5
d69 2
d82 1
d88 4
a91 1
			       /* "1234567890123456" */
d95 145
@


1.1.2.1
log
@Merge with the trunk
@
text
@@


1.1.1.1
log
@Initial commit for OpenBSD/luna88k, based on OpenBSD/mvme88k, NetBSD/luna68k and CMU Mach.
@
text
@@
