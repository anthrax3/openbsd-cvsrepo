head	1.32;
access;
symbols
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.31.0.4
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.30.0.8
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.4
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.29.0.6
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.25.0.4
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.24.0.4
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.2
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.12
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.8
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.10
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.6
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	SMP:1.3.0.2
	LUNA88K_INIT:1.1.1.1
	AOYAMA:1.1.1;
locks; strict;
comment	@# @;


1.32
date	2017.07.23.09.17.17;	author aoyama;	state Exp;
branches;
next	1.31;
commitid	Xso53vaHdfOSocCV;

1.31
date	2017.03.20.19.37.54;	author miod;	state Exp;
branches;
next	1.30;
commitid	QfsUP8Cps6nKwYtj;

1.30
date	2015.02.25.17.41.22;	author miod;	state Exp;
branches;
next	1.29;
commitid	SPD70tGdBh1CAdeU;

1.29
date	2013.11.02.17.49.19;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2013.10.28.22.15.22;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2013.08.10.07.42.58;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2013.08.10.07.41.16;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2013.01.05.11.20.55;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2012.01.28.11.34.19;	author aoyama;	state Exp;
branches;
next	1.23;

1.23
date	2012.01.08.01.26.37;	author aoyama;	state Exp;
branches;
next	1.22;

1.22
date	2011.11.19.20.40.10;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.12.23.20.05.08;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2007.12.22.17.14.39;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2007.12.20.21.14.07;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.12.04.23.43.54;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.12.02.21.28.38;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.15.21.23.15;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.06.21.42.56;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.12.21.41.53;	author aoyama;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.15.21.40.04;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.03.18.20.48;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.03.14.30.05;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.12.19.32.17;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.12.19.05.39;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.24.22.50.30;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.24.12.59.51;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.09.20.52.07;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.02.14.40.20;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.10.10.30.24;	author aoyama;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2004.04.22.08.54.17;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.21.15.24.00;	author aoyama;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.04.21.15.24.00;	author aoyama;	state Exp;
branches;
next	;

1.3.2.1
date	2004.06.05.23.09.47;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Splitting early startup code out of locore.S into locore0.S, like other
architectures.

"Looking good" deraadt@@
@
text
@/*	$OpenBSD: locore.S,v 1.31 2017/03/20 19:37:54 miod Exp $	*/
/*
 * Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <machine/asm.h>

/*
 * void delay(int count)
 *
 * The processor loops (busy waits) for the given number of microseconds:
 * Thus, delay(1000000) will delay for one second.
 * (originally from Mach 2.5)
 */

GLOBAL(delay)
	bcnd	eq0, %r2, 2f
	or.u	%r3, %r0, %hi16(_C_LABEL(cpuspeed))
	ld	%r3, %r3, %lo16(_C_LABEL(cpuspeed))
	mul	%r4, %r2, %r3
	subu	%r4, %r4, 4	/* overhead of these instructions */

	/* now loop for the given number of cycles */
1:
	bcnd.n	gt0, %r4, 1b
	 subu	%r4, %r4, 2	/* two cycles per iteration */
2:
	jmp	%r1
@


1.31
log
@Replace hardcoded addresses with symbolic constants from <machine/board.h>
for enhanced grepability and fewer bad surprises.

ok aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.30 2015/02/25 17:41:22 miod Exp $	*/
a59 3
#include "assym.h"
#include "ksyms.h"

a60 270
#include <machine/board.h>
#include <machine/m88100.h>
#include <machine/param.h>
#include <machine/psl.h>
#include <machine/trap.h>
#include <machine/vmparam.h>

#define	BOOT_MAGIC	0xf1abde3f

/*
 * The memory looks like:
 *   0x00000 - 0x01000	trap vectors
 *   0x01000 - 0x20000	ROM monitor work area
 *   0x20000 == start	Boot loader jumps here.
 */
	.text

GLOBAL(kernelstart)
GLOBAL(kernel_text)

	/*
	 * Room for the kernel (post-autoconf) VBR page.
	 * Note this page is in kernel text, in order to be write-protected
	 * by pmap_bootstrap().
	 */

	.balign	PAGE_SIZE
	.space	PAGE_SIZE

	/*
	 * The 88100 may execute the first instruction of the next trap
	 * handler, as documented in its Errata. Processing trap #511
	 * would then fall into the next page, unless the address computation
	 * wraps, or software traps are exempt from the issue - the Errata
	 * does not provide more detail.
	 * Although the MVME BUG does not add an extra NOP after its VBR page,
	 * it is cheap to add an extra NOP for safety.
	 */
	NOP

ASGLOBAL(__start)
	/*
	 * A few identical jump instructions to make sure the pipeline is
	 * in a good state. Probably overkill, but it's cheap.
	 */
 	br	_ASM_LABEL(main_start)
	br	_ASM_LABEL(main_start)
	br	_ASM_LABEL(main_start)
	br	_ASM_LABEL(main_start)

	/*
	 * Startup code common to all processors.
	 */
ASLOCAL(main_start)
#if defined(DDB) || NKSYMS > 0
	or.u	%r10, %r0,  %hi16(BOOT_MAGIC)
	or	%r10, %r10, %lo16(BOOT_MAGIC)
	cmp	%r11, %r2,  %r10
	bb1	ne,   %r11, 1f

	or.u	%r4,  %r0,  %hi16(_C_LABEL(esym))
	st	%r3,  %r4,  %lo16(_C_LABEL(esym))
1:
#endif

	bsr	_ASM_LABEL(setup_psr)

	stcr	%r0,  VBR		/* start with VBR set to zero */
	FLUSH_PIPELINE

	/*
	 * Now we will compete with the other processors to see which one
	 * will be elected as the main one.
	 */
	or.u	%r11, %r0,  %hi16(_C_LABEL(cpu_hatch_mutex))
	or	%r11, %r11, %lo16(_C_LABEL(cpu_hatch_mutex))
1:
	FLUSH_PIPELINE
	or	%r22, %r0,  1
	xmem	%r22, %r11, %r0		/* If %r22 gets 0, we have the lock.. */
	bcnd	eq0,  %r22, 4f		/* ..but if not, we must wait */
2:
	/* just watch the lock until it looks clear */
	ld	%r22, %r11, %r0
	bcnd	ne0,  %r22, 2b
	/* since we can be here with caches off, add a few nops to
	   keep the bus from getting overloaded */
	or	%r2,  %r0, %lo16(1000)
3:
	subu	%r2,  %r2, 1
	bcnd	eq0,  %r2, 3b
	br	1b			/* looks clear -- try to grab */
4:
	/* now try to grab the master_mpu prize */
	FLUSH_PIPELINE
	or.u	%r11, %r0,  %hi16(_ASM_LABEL(master_mpu))
	or	%r11, %r11, %lo16(_ASM_LABEL(master_mpu))
	or	%r22, %r0,  1
	xmem	%r22, %r11, %r0

	/*
	 * If %r22 is not clear we're a secondary,
	 * otherwise we're first and the main.
	 *
	 * Note that we haven't released the interprocessor lock....
	 * We'll do that when we're ready for another CPU to go.
	 */
	bcnd	ne0,  %r22, _ASM_LABEL(secondary_init)

	/*
	 * Main processor specific initialization (with
	 * cpu_hatch_mutex held).
	 */
ASLOCAL(main_init)
	/* clear BSS. PROM might have already done this... */
	or.u	%r2, %r0, %hi16(_C_LABEL(edata))
	or	%r2, %r2, %lo16(_C_LABEL(edata))
	or.u	%r4, %r0, %hi16(_C_LABEL(end))
	or	%r4, %r4, %lo16(_C_LABEL(end))
	bsr.n	_C_LABEL(bzero)		/* bzero(edata, end-edata) */
	 subu	%r3, %r4, %r2

	/* figure out the end of the kernel image. */
#if defined(DDB) || NKSYMS > 0
	or.u	%r4, %r0, %hi16(_C_LABEL(esym))
	ld	%r4, %r4, %lo16(_C_LABEL(esym))
	bcnd	ne0, %r4, 1f
#endif
	or.u	%r4, %r0, %hi16(_C_LABEL(end))
	or	%r4, %r4, %lo16(_C_LABEL(end))		/* if no symbols */
1:
	or.u	%r5, %r0, %hi16(_C_LABEL(first_addr))
	st	%r4, %r5, %lo16(_C_LABEL(first_addr))

	/*
	 * Have curcpu() point to the dummy cpuinfo structure,
	 * and initialize cr17.
	 * This is necessary for early spl*() usage, as well as
	 * mutex diagnostic code.
	 */
	or.u	%r11, %r0,  %hi16(_ASM_LABEL(dummy_cpu))
	or	%r11, %r11, %lo16(_ASM_LABEL(dummy_cpu))
	stcr	%r11, CPU

	/* Switch to startup stack */
	or.u	%r31, %r0,  %hi16(_ASM_LABEL(initstack_end))
	or	%r31, %r31, %lo16(_ASM_LABEL(initstack_end))

	or.u	%r3,  %r0,  %hi16(_C_LABEL(vector_list))
	or	%r3,  %r3,  %lo16(_C_LABEL(vector_list))

	bsr.n	_C_LABEL(luna88k_vector_init)
	 ldcr	%r2, VBR

	/* PIO stuff */
	or	%r10, %r0,  0xb6		/* initialize pio 0 */
	or.u	%r11, %r0,  %hi16(OBIO_PIO0)	/* PIO0 ctrl */
	st.b	%r10, %r11, %lo16(OBIO_PIO0)

	/* read dispswitch setting */
	ld.bu	%r10, %r11, %lo16(OBIO_PIO0A)	/* dipsw-1 (from portA) */
	mak	%r10, %r10, 0<8>			/* shift left 8 bit */
	ld.bu	%r12, %r11, %lo16(OBIO_PIO0B)	/* dipsw-2 (from portB) */
	or	%r10, %r10, %r12

	or.u	%r11, %r0,  %hi16(_C_LABEL(dipswitch))
	st.h	%r10, %r11, %lo16(_C_LABEL(dipswitch))

	bb1	14,   %r10, 1f			/* XXX: if dipsw-1:2 is on, */
	or	%r10, %r0,  %r0			/* XXX: console is ttya */
	or.u	%r11, %r0,  %hi16(_C_LABEL(sysconsole))
	st	%r10, %r11, %lo16(_C_LABEL(sysconsole))

1:
	/* read frame buffer depth from ROM work area */
	ld	%r10, %r0,  %lo16(0x00001114)	/* frame buffer depth */
	or.u	%r11, %r0,  %hi16(_C_LABEL(hwplanebits))
	st	%r10, %r11, %lo16(_C_LABEL(hwplanebits))

	or	%r10,  %r0,  0x84		/* initialize pio1 */
	or.u	%r11,  %r0,  %hi16(OBIO_PIO1)
	st.b	%r10,  %r11, %lo16(OBIO_PIO1)
	or	%r10,  %r0,  0x9		/* port c bit 1 on */
	st.b	%r10,  %r11, %lo16(OBIO_PIO1)

	or.u	%r10,  %r0,  %hi16(SCSI_ADDR + 4 * 0x04)/* clear scsi INTS */
	ld.b	%r11, %r10,  %lo16(SCSI_ADDR + 4 * 0x04)
	st.b	%r11, %r10,  %lo16(SCSI_ADDR + 4 * 0x04)

	/* write to the PROM area to escape rom */
	or.u	%r2,  %r0,   %hi16(PROM_ADDR)
	st	%r0,  %r2,   %lo16(PROM_ADDR)

	/*
	 * luna88k_bootstrap(), among other things, clears proc0's u area.
	 * We are still using the interrupt stack here, thus we are not
	 * affected...
	 */
	bsr	_C_LABEL(luna88k_bootstrap)

	/*
	 * ...and we can switch to the u area stack now.
	 */
	ldcr	%r10, CPU
	ld	%r31, %r10, CI_CURPCB
	addu	%r31, %r31, USPACE

	/* call main() - no arguments although main() still defines one */
	bsr	_C_LABEL(main)

	or.u	%r2,  %r0,  %hi16(_ASM_LABEL(main_panic))
	bsr.n	_C_LABEL(panic)
	 or	%r2,  %r2,  %lo16(_ASM_LABEL(main_panic))

	.data
	.balign	4
ASLOCAL(main_panic)
	.string	"main() returned\0"
	.text
	.balign	8

	/*
	 * Secondary processor specific initialization (with
	 * cpu_hatch_mutex held).
	 */
ASLOCAL(secondary_init)
#ifdef MULTIPROCESSOR
	/*
	 * Have curcpu() point to the dummy cpuinfo structure,
	 * and initialize cr17.
	 * This is necessary for early spl*() usage, as well as
	 * mutex diagnostic code.
	 */
	or.u	%r11, %r0,  %hi16(_ASM_LABEL(dummy_cpu))
	or	%r11, %r11, %lo16(_ASM_LABEL(dummy_cpu))
	st	%r0,  %r11, CI_FLAGS		/* reset CIF_PRIMARY */
	stcr	%r11, CPU

	/*
	 * While holding the cpu_hatch_mutex, the secondary cpu can use the
	 * slavestack to call secondary_pre_main() to determine its cpu
	 * number. That function will also return the proper stack to
	 * use and we'll switch to it.
	 */

	or.u	%r31, %r0,  %hi16(_ASM_LABEL(slavestack_end))
	bsr.n	_C_LABEL(secondary_pre_main)	/* set cpu number */
	 or	%r31, %r31, %lo16(_ASM_LABEL(slavestack_end))

	bsr.n	_C_LABEL(secondary_main)
	 addu	%r31, %r2, USPACE		/* switch to idle stack */

#else

	/*
	 * Just keep the processor chewing in silence.
	 */
1:	br	1b

#endif	/* MULTIPROCESSOR */

#ifdef MULTIPROCESSOR
	/*
	 * Dummy mp_atomic_begin() and mp_atomic_end() routine, so that
	 * we can interact with ddb if things go wrong very early during
	 * bootstrap. Of course this should never happen (-:
	 */
ASLOCAL(dummy_mplock)
	jmp	%r1
#endif	/* MULTIPROCESSOR */
a82 52

/*****************************************************************************/

	.data
	.balign	PAGE_SIZE
GLOBAL(kernel_sdt)		/* SDT (segment descriptor table */
	.space	0x2000		/* 8K - 4K phys, 4K virt*/

	.balign	PAGE_SIZE
ASGLOBAL(initstack)
	.space	USPACE
ASGLOBAL(initstack_end)

#ifdef MULTIPROCESSOR
	.space	PAGE_SIZE	/* 4K, small, interim stack */
ASLOCAL(slavestack_end)
#endif

/*
 * Process 0's u.
 * Should be page aligned.
 */
	.balign	PAGE_SIZE
ASLOCAL(u0)
	.space	USPACE
GLOBAL(proc0paddr)
	.word	_ASM_LABEL(u0)	/*  KVA of proc0 uarea */

/* The first processor to XMEM this becomes the master */
ASLOCAL(master_mpu)
	.word 0

/* Dummy cpuinfo structure, for early bootstrap */
ASLOCAL(dummy_cpu)
	.word	3 /* CIF_ALIVE | CIF_PRIMARY */	/* ci_flags */
	.word	0				/* ci_curproc */
	.word	0				/* ci_curpcb */
	.word	0				/* ci_curpmap */
	.word	0				/* ci_cpuid */
#ifdef MULTIPROCESSOR
	.word	_ASM_LABEL(dummy_mplock)	/* ci_mp_atomic_begin */
	.word	_ASM_LABEL(dummy_mplock)	/* ci_mp_atomic_end */
#else
	.word	0
	.word	0
#endif
	.space	CPU_INFO_SIZEOF - 7 * 4

#if defined(DDB) || NKSYMS > 0
GLOBAL(esym)
	.word 	0
#endif /* DDB || NKSYMS > 0 */
@


1.30
log
@Rework secondary processor initialization, in order to allocate their idle
stack from the main processor, instead of from the secondary processors
themselves. This used to work until recent churn in uvm require the kernel
lock to be taken, and cpu_configure() runs with the kernel lock held by the
boot processor.

Allocating the idle stack on the secondary processors themselves was choosen
early on, because there is no easy way, from the boot processor, to know the
assocation between physical cpu number (ci_cpuid) and logical cpu number
(the order they are initialized and reported in), especially on luna88k where
there is no way to get secondary processors parked by the prom.

Regression noticed by aoyama@@. Verified to work on 2 and 4 cpu luna88k systems
and 2 cpu aviion systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.29 2013/11/02 17:49:19 miod Exp $	*/
d64 1
d220 2
a221 2
	or.u	%r11, %r0,  %hi16(0x4900000c)	/* 0x4900000c: PIO0 ctrl */
	st.b	%r10, %r11, %lo16(0x4900000c)
d224 1
a224 1
	ld.bu	%r10, %r11, %lo16(0x49000000)	/* dipsw-1 (from portA) */
d226 1
a226 1
	ld.bu	%r12, %r11, %lo16(0x49000004)	/* dipsw-2 (from portB) */
d244 2
a245 2
	or.u	%r11,  %r0,  %hi16(0x4d00000c)
	st.b	%r10,  %r11, %lo16(0x4d00000c)
d247 1
a247 1
	st.b	%r10,  %r11, %lo16(0x4d00000c)
d249 7
a255 7
	or.u	%r10,  %r0,  %hi16(0xe1000010)	/* clear scsi int */
	ld.b	%r11, %r10,  %lo16(0xe1000010)
	st.b	%r11, %r10,  %lo16(0xe1000010)

	/* write 0x41000000 to escape rom */
	or.u	%r2,  %r0,   %hi16(0x41000000)
	st	%r0,  %r2,   %lo16(0x41000000)
@


1.29
log
@Reserve a page at the beginning of the kernel text to use for the trap vectors,
and switch to it, on all processors, after autoconf is over. First step
towards being able to unmap the low memory and have address 0 non-accessible
in the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.28 2013/10/28 22:15:22 miod Exp $	*/
d304 2
a305 3
	 * number.
	 * After that, however, it should allocate its own stack and switch
	 * to it.
a311 3
	ldcr	%r1,  CPU
	st	%r2,  %r1, CI_CURPCB	/* save stack as curpcb for traps */

d313 1
a313 1
	 addu	%r31, %r2, USPACE			/* switch to startup stack */
@


1.28
log
@Recognize kernel symbols when booted from the standalone bootloader.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.27 2013/08/10 07:42:58 miod Exp $	*/
d82 21
d130 1
a130 1
	stcr	%r0,  VBR	/* set Vector Base Register to 0, ALWAYS! */
d213 3
a215 3
	or	%r4,  %r0,  1
	bsr.n	_C_LABEL(vector_init)
	 ldcr	%r2,  VBR
@


1.27
log
@Initialize first_addr much earlier, in locore; this will help adding
symbols support in the not-so-distant future.
ok aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.26 2013/08/10 07:41:16 miod Exp $	*/
d70 2
d96 11
d165 5
d171 2
a172 1
	or	%r4, %r4, %lo16(_C_LABEL(end))
d174 1
a174 1
	st	%r4, %r5, %lo16(_C_LABEL(first_addr))	/* no symbols yet */
@


1.26
log
@Only clear the bss after we have picked a cpu as master, and on this cpu only;
fixes a potential race where a secondary cpu resets carefully computed
variables. ok aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.25 2013/01/05 11:20:55 miod Exp $	*/
d150 6
@


1.25
log
@Switch m88k ports to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.24 2012/01/28 11:34:19 aoyama Exp $	*/
a98 8
	/* clear BSS. PROM might have already done this... */
	or.u	%r2, %r0, %hi16(_C_LABEL(edata))
	or	%r2, %r2, %lo16(_C_LABEL(edata))
	or.u	%r4, %r0, %hi16(_C_LABEL(end))
	or	%r4, %r4, %lo16(_C_LABEL(end))
	bsr.n	_C_LABEL(bzero)		/* bzero(edata, end-edata) */
	 subu	%r3, %r4, %r2

d143 8
@


1.24
log
@Luna88k multi-processor support, step 2.

Modify secondary processor initialization and interrupt handler.

Now GENERIC.MP boots up more stable and runs userland binaries, but
inter-processor-interrupt is not implemented yet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.23 2012/01/08 01:26:37 aoyama Exp $	*/
d76 1
a76 1
	text
d80 1
a80 1
ASGLOBAL(start)
d96 1
a96 1
	stcr	r0,  VBR	/* set Vector Base Register to 0, ALWAYS! */
d100 6
a105 6
	or.u	r2, r0, hi16(_C_LABEL(edata))
	or	r2, r2, lo16(_C_LABEL(edata))
	or.u	r4, r0, hi16(_C_LABEL(end))
	or	r4, r4, lo16(_C_LABEL(end))
	bsr.n	_bzero		/* bzero(edata, end-edata) */
	 subu	r3, r4, r2
d111 2
a112 2
	or.u	r11, r0,  hi16(_C_LABEL(cpu_hatch_mutex))
	or	r11, r11, lo16(_C_LABEL(cpu_hatch_mutex))
d115 3
a117 3
	or	r22, r0,  1
	xmem	r22, r11, r0		/* If r22 gets 0, we have the lock.. */
	bcnd	eq0, r22, 4f		/* ..but if not, we must wait */
d120 2
a121 2
	ld	r22, r11, r0
	bcnd	ne0, r22, 2b
d124 1
a124 1
	or	r2, r0, lo16(1000)
d126 2
a127 2
	subu	r2, r2, 1
	bcnd	eq0, r2, 3b
d132 4
a135 4
	or.u	r11, r0,  hi16(_ASM_LABEL(master_mpu))
	or	r11, r11, lo16(_ASM_LABEL(master_mpu))
	or	r22, r0,  1
	xmem	r22, r11, r0
d138 1
a138 1
	 * If r22 is not clear we're a secondary,
d144 1
a144 1
	bcnd	ne0, r22, _ASM_LABEL(secondary_init)
d157 3
a159 3
	or.u	r11, r0,  hi16(_ASM_LABEL(dummy_cpu))
	or	r11, r11, lo16(_ASM_LABEL(dummy_cpu))
	stcr	r11, CPU
d162 2
a163 2
	or.u	r31, r0,  hi16(_ASM_LABEL(initstack_end))
	or	r31, r31, lo16(_ASM_LABEL(initstack_end))
d165 3
a167 3
	or.u	r3, r0, hi16(_C_LABEL(vector_list))
	or	r3, r3, lo16(_C_LABEL(vector_list))
	or	r4, r0, 1
d169 1
a169 1
	 ldcr	r2, VBR
d172 3
a174 3
	or	r10, r0, 0xb6			/* initialize pio 0 */
	or.u	r11, r0,  hi16(0x4900000c)	/* 0x4900000c: PIO0 ctrl */
	st.b	r10, r11, lo16(0x4900000c)
d177 12
a188 12
	ld.bu	r10, r11, lo16(0x49000000)	/* dipsw-1 (from portA) */
	mak	r10, r10, 0<8>			/* shift left 8 bit */
	ld.bu	r12, r11, lo16(0x49000004)	/* dipsw-2 (from portB) */
	or	r10, r10, r12

	or.u	r11, r0,  hi16(_dipswitch)
	st.h	r10, r11, lo16(_dipswitch)

	bb1	14, r10, 1f			/* XXX: if dipsw-1:2 is on, */
	or	r10, r0, r0			/* XXX: console is ttya */
	or.u	r11, r0, hi16(_sysconsole)
	st	r10, r11, lo16(_sysconsole)
d192 13
a204 13
	ld	r10, r0,  lo16(0x00001114)	/* frame buffer depth */
	or.u	r11, r0,  hi16(_hwplanebits)
	st	r10, r11, lo16(_hwplanebits)

	or	r10,  r0, 0x84			/* initialize pio1 */
	or.u	r11,  r0, hi16(0x4d00000c)
	st.b	r10, r11, lo16(0x4d00000c)
	or	r10,  r0, 0x9			/* port c bit 1 on */
	st.b	r10, r11, lo16(0x4d00000c)

	or.u	r10,  r0, hi16(0xe1000010)	/* clear scsi int */
	ld.b	r11, r10, lo16(0xe1000010)
	st.b	r11, r10, lo16(0xe1000010)
d207 2
a208 2
	or.u	r2,  r0,  hi16(0x41000000)
	st	r0,  r2,  lo16(0x41000000)
d220 3
a222 3
	ldcr	r10, CPU
	ld	r31, r10, CI_CURPCB
	addu	r31, r31, USPACE
d227 1
a227 1
	or.u	r2, r0, hi16(_ASM_LABEL(main_panic))
d229 1
a229 1
	 or	r2, r2, lo16(_ASM_LABEL(main_panic))
d231 2
a232 2
	data
	.align	4
d234 3
a236 3
	string	"main() returned\0"
	text
	.align	8
d250 4
a253 4
	or.u	r11, r0,  hi16(_ASM_LABEL(dummy_cpu))
	or	r11, r11, lo16(_ASM_LABEL(dummy_cpu))
	st	r0,  r11, CI_FLAGS		/* reset CIF_PRIMARY */
	stcr	r11, CPU
d263 1
a263 1
	or.u	r31, r0,  hi16(_ASM_LABEL(slavestack_end))
d265 1
a265 1
	 or	r31, r31, lo16(_ASM_LABEL(slavestack_end))
d267 2
a268 2
	ldcr	r1, CPU
	st	r2,  r1, CI_CURPCB	/* save stack as curpcb for traps */
d271 1
a271 1
	 addu	r31, r2, USPACE			/* switch to startup stack */
d289 1
a289 1
	jmp	r1
d301 5
a305 5
	bcnd	eq0, r2, 2f
	or.u	r3, r0, hi16(_C_LABEL(cpuspeed))
	ld	r3, r3, lo16(_C_LABEL(cpuspeed))
	mul	r4, r2, r3
	subu	r4, r4, 4	/* overhead of these instructions */
d309 2
a310 2
	bcnd.n	gt0, r4, 1b
	 subu	r4, r4, 2	/* two cycles per iteration */
d312 1
a312 1
	jmp	r1
d316 2
a317 2
	data
	.align	PAGE_SIZE
d319 1
a319 1
	space	0x2000		/* 8K - 4K phys, 4K virt*/
d321 1
a321 1
	.align	PAGE_SIZE
d323 1
a323 1
	space	USPACE
d327 1
a327 1
	space	PAGE_SIZE	/* 4K, small, interim stack */
d335 1
a335 1
	.align	PAGE_SIZE
d337 1
a337 1
	space	USPACE
d339 1
a339 1
	word	_ASM_LABEL(u0)	/*  KVA of proc0 uarea */
d343 1
a343 1
	word 0
d347 5
a351 5
	word	3 /* CIF_ALIVE | CIF_PRIMARY */	/* ci_flags */
	word	0				/* ci_curproc */
	word	0				/* ci_curpcb */
	word	0				/* ci_curpmap */
	word	0				/* ci_cpuid */
d353 2
a354 2
	word	_ASM_LABEL(dummy_mplock)	/* ci_mp_atomic_begin */
	word	_ASM_LABEL(dummy_mplock)	/* ci_mp_atomic_end */
d356 2
a357 2
	word	0
	word	0
d359 1
a359 1
	space	CPU_INFO_SIZEOF - 7 * 4
d363 1
a363 1
	word 	0
@


1.23
log
@Preliminary multi-processor support for luna88k.  It is
work-in-progress and is not stable yet...

"Please commit" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.22 2011/11/19 20:40:10 miod Exp $	*/
d111 2
a112 2
	or.u	r11, r0,  hi16(_C_LABEL(cpu_mutex))
	or	r11, r11, lo16(_C_LABEL(cpu_mutex))
d147 2
a148 1
	 * Main processor specific initialization (with cpu_mutex held).
d239 2
a240 1
	 * Secondary processor specific initialization (with cpu_mutex held).
d256 3
a258 2
	 * While holding the cpu_mutex, the secondary cpu can use the slavestack
	 * to call secondary_pre_main() to determine its cpu number.
@


1.22
log
@Make sure %cr17 points to a valid cpu_info struct before attempting to do the
first few printfs (which happen before we have figured out which exact cpu
we are running on). Found the hard way by aoyama@@ on luna88k, and we probably
have just been lucky on other platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.21 2010/12/23 20:05:08 miod Exp $	*/
d277 10
@


1.21
log
@The exception vector page on m88k systems has always been the same page as
the one used by the firmware, which (at least on mvme88k) is at address zero.

This is unfortunate, since this means that NULL pointer dereferences in the
kernel are not caught, and writes cause havoc.

This behaviour was necessary to be able to use the PROM system call interface
during early bootstrap, without having to disassemble the VBR page and
update branches - which use pc-relative displacement - if we were to use
a different VBR address.

On mvme88k, change this and actually set up two VBR pages: one, over the PROM
page (except for the system call vectors), and another one in the kernel
image (which will be mapped read-only). We'll run with the PROM page until
the end of autoconf, and then switch to the kernel one, and unmap all the
PROM below it.

As a bonus, the final kernel page can use optimized data access fault
handlers, which do not have to check for faults caused by badaddr(), since
badaddr() is only used during device probe on buses which do not support
hotplug.

There are a few infrastructure collateral damage on aviion and luna88k, but
these ports do not change their behaviour yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.20 2007/12/22 17:14:39 miod Exp $	*/
d150 10
d243 11
d328 1
a328 1
/* The first processor that XMEMs this becomes the master */
d331 16
@


1.20
log
@Move initial PSR initialization to a separate routine, instead of duplicating
it five times.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.19 2007/12/20 21:14:07 miod Exp $	*/
d156 1
a156 1

@


1.19
log
@Do not wait for the end of the universe if delay(0).
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.18 2007/12/04 23:43:54 miod Exp $	*/
d94 1
a94 34
	/*
	 * CPU Initialization
	 *
	 * Every CPU starts from here..
	 * (well, from 'start' above, which just jumps here).
	 *
	 * I use r11 and r22 here 'cause they're easy to not
	 * get mixed up -- r10, for example, looks too similar
	 * to r0 when not being careful....
	 *
	 * Ensure that the PSR is as we like:
	 *	supervisor mode
	 *	big-endian byte ordering
	 *	concurrent operation allowed
	 *	carry bit clear (I don't think we really care about this)
	 *	FPU enabled
	 *	misaligned access raises an exception
	 *	interrupts disabled
	 *	shadow registers frozen
	 *
	 * The manual says not to disable interrupts and freeze shadowing
	 * at the same time because interrupts are not actually disabled
	 * until after the next instruction. Well, if an interrupt
	 * occurs now, we're in deep trouble anyway, so I'm going to do
	 * the two together.
	 *
	 * Upon a reset (or poweron, I guess), the PSR indicates:
	 *   supervisor mode
	 *   interrupts, shadowing, FPU, misaligned exception: all disabled
	 *
	 * We'll just construct our own turning on what we want.
	 *
	 *	jfriedl@@omron.co.jp
	 */
a95 9
	stcr	r0, SSBR	/* clear this for later */
	stcr	r0, SR1		/* clear the CPU flags */

	set	r11, r0,  1<PSR_SUPERVISOR_MODE_BIT>
	set	r11, r11, 1<PSR_INTERRUPT_DISABLE_BIT>
	set	r11, r11, 1<PSR_GRAPHICS_DISABLE_BIT>

	stcr	r11, PSR
	FLUSH_PIPELINE
d268 2
a269 2
	or.u	r3, r0, hi16(_C_LABEL(cpuseed))
	ld	r3, r3, lo16(_C_LABEL(cpuseed))
@


1.18
log
@Correctly set the stack pointer of a secondary processor to the end
of its initialization stack. Oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.17 2007/12/02 21:28:38 miod Exp $	*/
d309 3
a311 2
	or.u	r3, r0, hi16(_cpuspeed)
	ld	r3, r3, lo16(_cpuspeed)
d319 1
a319 1

@


1.17
log
@Do not pass UPAGES and USPACE (under the name USIZE) in assym.h, code which
needs it includes <machine/param.h> already.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.16 2007/11/15 21:23:15 miod Exp $	*/
d284 4
d289 1
a289 1
	 or	r31, r2, r0 		/* switch to startup stack */
@


1.16
log
@Stop referring the initial kernel stack as the ``interrupt stack''. It's
been years since it has last been used for that purpose, so name it the
initialization/startup stack.

While there, do not store the initialization stack in cpu_info, and have
secondary_pre_main() return its value so that the bootstrap code does not
need to fetch it from cpu_info.

This might be reconsidered when the startup stacks will be freed after they
are not used anymore, but there are more things to do first.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.15 2007/11/06 21:42:56 miod Exp $	*/
d253 1
a253 1
	addu	r31, r31, USIZE
d326 1
a326 1
	space	USIZE
d340 1
a340 1
	space	USIZE
@


1.15
log
@Remove the now unused idle_u, and call the secondary processors startup
stack a startup stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.14 2007/10/10 15:53:52 art Exp $	*/
d192 3
a194 3
	/* Switch to interrupt stack */
	or.u	r31, r0,  hi16(_ASM_LABEL(intstack_end))
	or	r31, r31, lo16(_ASM_LABEL(intstack_end))
a283 3

	ldcr	r2, CPU
	ld	r3, r2, CI_INIT_STACK
d285 1
a285 1
	 addu	r31, r3, USIZE 		/* switch to startup stack */
d325 1
a325 1
ASGLOBAL(intstack)
d327 1
a327 1
ASGLOBAL(intstack_end)
@


1.14
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.13 2007/01/12 21:41:53 aoyama Exp $	*/
d286 3
a288 6
1:
	ld	r3, r2, CI_CURPCB
	bcnd	eq0, r3, 1b

	br.n	_C_LABEL(secondary_main)
	 add	r31, r3, USIZE 		/* switch to idle stack */
a335 8

/*
 * Main processor's idle pcb and stack.
 * Should be page aligned.
 */
	.align	PAGE_SIZE
GLOBAL(idle_u)
	space	USIZE
@


1.13
log
@Change the secondary CMMU's data cache turn on so that do not hog the
bus while they spin, as same as 3.8.  This have been missed since CMMU
initialize cleanup.

Also m88k_cpus[] should have 4 elements on luna88k, even in
non-MULTIPROCESSOR kernel.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.12 2006/05/15 21:40:04 miod Exp $	*/
d153 2
a154 2
	or.u	r11, r0,  hi16(_ASM_LABEL(cpu_mutex))
	or	r11, r11, lo16(_ASM_LABEL(cpu_mutex))
a284 9
	/*
	 * Release cpu_mutex; we have a race with other secondary CPUs here
	 * because the stack has not been switched yet. However, since our
	 * interrupts are disabled, the worst we can get is an NMI, and, oh
	 * well, it means we're in deep trouble anyway.
	 */
	or.u	r10, r0, hi16(_ASM_LABEL(cpu_mutex))
	st	r0, r10, lo16(_ASM_LABEL(cpu_mutex))

a292 7
	/*
	 * At this point, the CPU has been correctly initialized and has
	 * identified itself on the console.
	 * All it needs now is to jump to the idle loop and wait for work to
	 * be offered.
	 */
	br	_ASM_LABEL(cpu_switch_search)
a301 9
	/*
	 * Release the cpu_mutex; secondary processors will now have their
	 * chance to initialize.
	 */
GLOBAL(cpu_boot_secondary_processors)
	or.u	r2,  r0,  hi16(_ASM_LABEL(cpu_mutex))
	jmp.n	r1
	 st	r0,  r2,  lo16(_ASM_LABEL(cpu_mutex))

a359 4
	word 0

/* XMEM spin lock -- controls access to master_mpu */
ASLOCAL(cpu_mutex)
@


1.12
log
@Clean secondary processors initialization code, similar to mvme88k;
tested aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.11 2005/12/03 18:20:48 miod Exp $	*/
a171 1
#ifdef MULTIPROCESSOR
a186 8
#else
	/*
	 * On non-MP kernels, the main processor will never release
	 * cpu_mutex, thus secondary processors will spin trying to
	 * acquire the lock, with interrupts disabled.
	 */
#endif
	/* fall through to main_init if that's appropriate */
a268 1
#ifdef MULTIPROCESSOR
d273 1
d309 8
a317 1
GLOBAL(cpu_boot_secondary_processors)
d322 1
a326 2
#endif	/* MULTIPROCESSOR */

a382 1
#ifdef MULTIPROCESSOR
d386 1
a386 1
#endif
@


1.11
log
@intstack does not need to be visible from C code anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.10 2005/12/03 14:30:05 miod Exp $	*/
a63 1
#include <machine/trap.h>
d65 1
d67 1
a67 1
#include <machine/param.h>
a79 1
GLOBAL(start)
d81 3
a83 20
	br	_C_LABEL(start_text)
	br	_C_LABEL(start_text)
	br	_C_LABEL(start_text)
	br	_C_LABEL(start_text)

	/* This is the *real* start upon poweron or reset */
GLOBAL(start_text)
	/*
	 * XXX: OpenBSD/luna88k does not have its native boot
	 * loader, so no args are passed ...
	 * (below is the comment for mvme88k.)
	 * 
	 * Args passed by boot loader
	 * 	r2 howto
	 *	r3 boot controller address
	 *	r4 esym
	 *	r5 start of mini
	 *	r6 end miniroot
	 *	r7 ((Clun << 8) ; Dlun & FF) -> bootdev
	 *	r8 cpu type (0x187, 0x188, 0x197)
d85 4
a88 33
#if 0 /* not yet */
/*
 * (*entry)(flag, bugargs.ctrl_addr, cp, kernel.smini,kernel.emini,
 *  bootdev, brdtyp);
 */
	or.u	r13, r0,  hi16(_C_LABEL(boothowto))
	st	r2,  r13, lo16(_C_LABEL(boothowto))
	or.u	r13, r0,  hi16(_C_LABEL(bootaddr))
	st	r3,  r13, lo16(_C_LABEL(bootaddr))
	or.u	r13, r0,  hi16(_C_LABEL(first_addr))
	st	r4,  r13, lo16(_C_LABEL(first_addr))
#if defined(DDB) || NKSYMS > 0
	or.u	r13, r0,  hi16(_C_LABEL(esym))
	st	r4,  r13, lo16(_C_LABEL(esym))
#endif
	or.u	r13, r0,  hi16(_C_LABEL(bootdev))
	st	r7,  r13, lo16(_C_LABEL(bootdev))
	or.u	r13, r0,  hi16(_C_LABEL(brdtyp))
	st	r8,  r13, lo16(_C_LABEL(brdtyp))

	/* set cputyp */
	cmp	r2,  r8, BRD_197	/* r8 contains brdtyp */
	bb1	ne, r2, 1f	/* if it's a '197, CPU is 88110 */
	or.u	r13, r0,  hi16(CPU_88110)
	or	r8,  r13, lo16(CPU_88110)
	br	2f
1:
	or.u	r13, r0,  hi16(CPU_88100)
	or	r8,  r13, lo16(CPU_88100)
2:
	or.u	r13, r0,  hi16(_C_LABEL(cputyp))
	st	r8,  r13, lo16(_C_LABEL(cputyp))
#endif /* not yet */
d91 4
d141 1
a141 1
	/* clear BSS. Boot loader might have already done this... */
d150 2
a151 1
	 * First time to count how many CPUs to attach
d153 2
a154 28
	or.u	r11, r0,  hi16(_ASM_LABEL(initialized_cpu_lock))
	or	r11, r11, lo16(_ASM_LABEL(initialized_cpu_lock))
1:
	FLUSH_PIPELINE
	or	r22, r0,  1
	xmem	r22, r11, r0	/* If r22 gets 0, we have the lock.. */
	bcnd	eq0, r22, 3f	/* ..but if not, we must wait */
2:
	/* just watch the lock until it looks clear */
	ld	r22, r11, r0
	bcnd	eq0, r22, 1b
	br	2b		/* looks clear -- try to grab */
3:
	FLUSH_PIPELINE
	or.u	r11, r0,  hi16(_ASM_LABEL(initialized_cpus))
	ld	r22, r11, lo16(_ASM_LABEL(initialized_cpus))
	add	r23, r22, 1
	st	r23, r11, lo16(_ASM_LABEL(initialized_cpus))

	or.u	r11, r0,  hi16(_ASM_LABEL(initialized_cpu_lock))
	st	r0,  r11, lo16(_ASM_LABEL(initialized_cpu_lock))
	/*
	 * Now we view with any other processors to see who's the master.
	 * We first try to obtain a lock to see who's allowed
	 * to check/set the master lock.
	 */
	or.u	r11, r0,  hi16(_ASM_LABEL(inter_processor_lock))
	or	r11, r11, lo16(_ASM_LABEL(inter_processor_lock))
d172 2
a173 1
	/* now try to grab the master_processor_chosen prize */
d175 2
a176 2
	or.u	r11, r0,  hi16(_ASM_LABEL(master_processor_chosen))
	or	r11, r11, lo16(_ASM_LABEL(master_processor_chosen))
d181 2
a182 2
	 * If r22 is not clear we're a slave,
	 * otherwise we're first and the master.
a185 2
	 * (if we're the master, we'll do that in master_start below.
	 *  if we're a slave, we'll do it in slave_start below).
d187 9
a195 2
	bcnd	ne0, r22, _ASM_LABEL(slave_start)
	/* fall through to master start if that's appropriate */
a196 1
ASLOCAL(master_start)
d198 1
a198 1
	 * Switch to interrupt stack
d200 2
d266 1
d278 5
a282 4
/*
 *	slave CPUs starts here
 */
ASLOCAL(slave_start)
d284 4
a287 4
	 * While holding the inter_processor_lock, the slave cpu can use
	 * the slavestack to call slave_pre_main and determine its cpu number.
	 * After that, however, it should switch over to the interrupt stack
	 * associated with its cpu.
a289 1
	/* r31 <-- slavestack */
d291 2
a292 1
	or	r31, r31, lo16(_ASM_LABEL(slavestack_end))
d294 8
a301 2
	bsr.n	_C_LABEL(slave_pre_main)	/* set cpu number */
	 clr	r31, r31, 3<0>	/* round down to 8-byte boundary */
d303 7
a309 2
	bsr	_C_LABEL(get_slave_stack)
	addu	r31, r2, INTSTACK_SIZE
d312 4
a315 3
	 * SR1 now contains our cpu number. We can now release the
	 * inter_processor_lock, as we are done with the slavestack.
	 * We also have an interrupt stack
d317 1
d319 8
a326 4
	or.u	r10, r0, hi16(_ASM_LABEL(inter_processor_lock))
	st	r0, r10, lo16(_ASM_LABEL(inter_processor_lock))

	br	_C_LABEL(slave_main)	/* does not return */
d328 1
a328 6
GLOBAL(spin_cpu)
	or.u	r3,   r0,  hi16(_C_LABEL(start_text))
	or	r3,   r3,  lo16(_C_LABEL(start_text))
	or	r9,   r0,  0x100		/* .FORKMPU */
	tb0	0,    r0,  0x200-16		/* call 188Bug */
	jmp	r1
d362 2
a363 1
ASGLOBAL(slavestack)
d365 2
a366 1
ASGLOBAL(slavestack_end)
d369 1
a369 6
 * When a process exits and its u. area goes away, we set curpcb to point
 * to this `u.', leaving us with something to use for an interrupt stack,
 * and letting all the register save code have a pcb_uw to examine.
 * This is also carefully arranged (to come just before u0, so that
 * process 0's kernel stack can quietly overrun into it during bootup, if
 * we feel like doing that).
d378 1
a378 2
 *
 * This must be page aligned
d386 1
a386 8
GLOBAL(ret_addr)
	word 0
/* XMEM spin lock -- to count CPUs */
ASLOCAL(initialized_cpu_lock)
	word 0
/* CPU counter to initialize */
ASLOCAL(initialized_cpus)
	word 0
d388 1
a388 1
ASLOCAL(master_processor_chosen)
d390 3
a392 2
/* XMEM spin lock -- controls access to master_processor_chosen */
ASLOCAL(inter_processor_lock)
@


1.10
log
@Switch m88k ports to __HAVE_CPUINFO. Current cpu pointer is held in SR0
on all running processors.
Tested aoyama@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.9 2005/10/12 19:32:17 miod Exp $	*/
d401 1
a401 1
	.align NBPG
d405 2
a406 2
	.align NBPG
GLOBAL(intstack)
d410 1
a410 1
	space	NBPG		/* 4K, small, interim stack */
d422 1
a422 1
	.align NBPG
d431 1
a431 1
	.align	NBPG
d433 1
a433 1
	space	UPAGES * NBPG
@


1.9
log
@Move sigcode to the m88k-agnostic location. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.8 2005/10/12 19:05:39 miod Exp $	*/
d123 1
a123 1
	/* set _cputyp */
d160 1
a160 1
	 * occurs now, we're in deep   anyway, so I'm going to do
d165 1
a165 1
	 *   interrupts, shadowing, FPU, missaligned exception: all disabled
a172 1
	stcr	r0, SR0		/* clear "current thread" */
a264 1
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */
d321 2
a322 2
	or.u	r10, r0,  hi16(_C_LABEL(curpcb))
	ld	r31, r10, lo16(_C_LABEL(curpcb))
a382 6
 *
 * REGISTER USAGE:
 *  IN  r1   - return address
 *  IN  r2   - number of microseconds
 *      r3   - cpu speed in MHz
 *      r4   - number of cycles to delay
d407 1
a407 1
	space	INTSTACK_SIZE	/* 16K, just to be safe */
d424 1
a424 1
	space	UPAGES * NBPG
d434 2
d451 1
a455 14
GLOBAL(proc0paddr)
	word	_ASM_LABEL(u0)	/*  KVA of proc0 uarea */

/*
 * curpcb points to the current pcb (and hence u. area).
 * Initially this is the special one.
 */
/*
 * pcb is composed of kernel state + user state
 * I may have to change curpcb to u0 + PCB_USER based on what
 * other parts expect XXX nivas
 */
GLOBAL(curpcb)
	word	_ASM_LABEL(u0)	/* curpcb = &u0 */
@


1.8
log
@Stop mapping the u area at fixed UADDR in addition to its actual va.
While there, attempt to clean and comment stack usage in the kernel.
No functional change.

From the m88k SMP tree; help&test martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.7 2004/12/24 22:50:30 miod Exp $	*/
a474 28

/*
 * Trampoline code. Gets copied to the top of
 * user stack in exec.
 */
GLOBAL(sigcode)			/* r31 points to sigframe */
	ld	r3, r31, 4	/* siginfo_t* */
	ld	r4, r31, 8	/* sigcontext* */
	ld	r5, r31, 12	/* handler */
	jsr.n	r5
	 ld	r2, r31, 0	/* signo */
	ld	r2, r31, 8	/* sigcontext* */
	or	r13,  r0, SYS_sigreturn
	tb0	0, r0, 128	/* syscall trap, calling sigreturn */
	NOP			| failure return
#if 0
	NOP			| success return
#endif
	/* sigreturn will not return unless it fails */
	or	r13, r0, SYS_exit
	tb0	0, r0, 128	/* syscall trap, exit */
	/*
	 * this never returns, but we need to provide fetchable instructions
	 * for the 88100 pipeline.
	 */
	NOP
	NOP
GLOBAL(esigcode)
@


1.7
log
@{e,}intr{cnt,names} bye-bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.6 2004/08/24 12:59:51 miod Exp $	*/
a262 1
	 * Use idle_u's stack instead?
d313 5
a317 1
	/* still on int stack */
d321 1
a321 2
	 * we now know our cpu number, so we
	 * can set interrupt_stack[cpu_number()] = intstack
d323 9
a331 2
	ldcr	r10, SR1
	extu	r10, r10, FLAG_CPU_FIELD_WIDTH<0>	/* r10 <-- CPU# */
d333 6
a338 18
	/* figure interrupt_stack[cpu_number()] */
	or.u	r11,  r0, hi16(_C_LABEL(interrupt_stack))
	or	r11, r11, lo16(_C_LABEL(interrupt_stack))
	or.u	r12, r0,  hi16(_C_LABEL(intstack))
	or	r12, r12, lo16(_C_LABEL(intstack))
	st	r12, r11 [r10]

	/* switch to proc0 uarea */
	or.u	r10, r0, hi16(UADDR)
	or	r31, r10,lo16(UADDR)
	addu	r31, r31, USIZE - 8

	/* make the call: main() */
	or.u	r2, r0, hi16(UADDR)
	or	r2, r2,lo16(UADDR)
	bsr.n	_C_LABEL(main)
	 addu	r2, r2, USIZE - 8
	bsr	_C_LABEL(panic)
a442 3
/* UPAGES get mapped to kstack */
ASGLOBAL(kstack)
	word	UADDR
@


1.6
log
@Since the cpu frequency can only be an integral number on the Luna88k,
simplify the delay() code, and as a result do not use floating-point code
in the kernel anymore.

Tested by aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.5 2004/08/09 20:52:07 miod Exp $	*/
a508 20

/* interrupt counters */
GLOBAL(intrnames)
	string	"spur\0"
	string	"lev1\0"
	string	"lev2\0"
	string	"lev3\0"
	string	"lev4\0"
	string	"lev5\0"
	string	"lev6\0"
	string	"lev7\0"
	string	"clk\0"
	string	"sclk\0"
	string	"pclk\0"
	string	"nmi\0"
GLOBAL(eintrnames)
	.align	8
GLOBAL(intrcnt)
	word	0,0,0,0,0,0,0,0,0,0,0,0
GLOBAL(eintrcnt)
@


1.5
log
@Take advantage of the recent ABI change to use less stack space and do
less stack pointer manipulation; the kernel needs to be compiled by an
up-to-date compiler now, or a tree will fall on your house.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.4 2004/07/02 14:40:20 miod Exp $	*/
d391 3
a393 5
 *  IN  r2   - (signed int) number of microseconds
 *      r3   - (float) number of microseconds
 *      r4/5 - (double) number of cycles per microsecond
 *      r6   - (float) number of cycles to delay
 *      r7   - (signed) number of cycles to delay
d397 4
a400 6
	flt.ss   r3, r2     /* convert microseconds from signed int to float */
	or.u     r4, r0, hi16(_cycles_per_microsecond)
	ld.d     r4, r4, lo16(_cycles_per_microsecond)
	fmul.ssd r6, r3, r4 /* convert microseconds to cycles */
	int.ss   r7, r6     /* convert cycles from float to signed int */
	subu     r7, r7, 25 /* subtract for overhead of above instruction */
d404 2
a405 2
	bcnd.n  gt0, r7, 1b
	subu    r7, r7, 2       /* two cycles per iteration */
d407 1
a407 1
	jmp     r1 /* return */
@


1.4
log
@Make page-aligned variable contiguous. Saves almost one page of data.
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.3 2004/05/10 10:30:24 aoyama Exp $	*/
d315 1
a315 3
	bsr.n	_C_LABEL(luna88k_bootstrap)
	 subu	r31, r31, 40
	addu	r31, r31, 40
d339 2
a340 4
	addu	r2, r2, USIZE - 8
	subu	r31, r31, 40
	bsr	_C_LABEL(main)
	addu	r31, r31, 40
a356 1
	clr	r31, r31, 3<0>	/* round down to 8-byte boundary */
d359 1
a359 1
	 subu	r31, r31, 48    		/* allocate frame */
d373 1
a373 2
	br.n	_C_LABEL(slave_main)	/* does not return */
	 subu	r31, r31, 40		/* allocate frame */
a490 1
	ld	r2, r31, 0	/* signo */
d495 2
a496 3
	 subu	r31, r31, 40	/* give some stack space */
	addu	r31, r31, 40	/* restore old sp value  */
	ld	r2,  r31, 8	/* sigcontext* */
@


1.3
log
@Make the time getting frame buffer depth earlier.  Without this
modification, bitmap console depth is always 4, because consinit() is
called before cpu_startup().

And use frame buffer depth bits(1,4,8) rather than mask value(0x01,
0x0f, 0xff), same as the value in ROM work area.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.2 2004/04/22 08:54:17 miod Exp $	*/
d422 3
a424 17
	.align 4096		/* SDT (segment descriptor table */
GLOBAL(kernel_sdt)
	space	(0x2000)	/* 8K - 4K phys, 4K virt*/
GLOBAL(ret_addr)
	word 0
ASLOCAL(initialized_cpu_lock)
	/* XMEM spin lock -- to count CPUs */
	word 0
ASLOCAL(initialized_cpus)
	/* CPU counter to initialize */
	word 0
ASLOCAL(master_processor_chosen)
	/* The first processor that XMEMs this becomes the master */
	word 0
ASLOCAL(inter_processor_lock)
	/* XMEM spin lock -- controls access to master_processor_chosen */
	word 0
d426 1
a426 1
	.align 4096
d428 1
a428 1
	space (INTSTACK_SIZE)	/* 16K, just to be safe */
d431 1
a431 1
	space (NBPG)		/* 4K, small, interim stack */
d443 1
a443 1
	.align 4096
d452 1
a452 1
	.align	4096
d456 1
a456 4
/*
 * UPAGES get mapped to kstack
 */

d459 14
a472 1

a476 6

GLOBAL(intiobase)
	word	0		| KVA of base of internal IO space
GLOBAL(intiolimit)
	word	0		| KVA of end of internal IO space

@


1.3.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2
log
@Typo
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.1.1.1 2004/04/21 15:24:00 aoyama Exp $	*/
d295 5
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: locore.S,v 1.35 2004/01/01 01:11:10 miod Exp $	*/
d73 1
a73 1
 *   0x10000 - 0x20000	ROM monitor work area
@


1.1.1.1
log
@Initial commit for OpenBSD/luna88k, based on OpenBSD/mvme88k, NetBSD/luna68k and CMU Mach.
@
text
@@
