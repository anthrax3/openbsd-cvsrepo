head	1.59;
access;
symbols
	OPENBSD_6_1:1.59.0.4
	OPENBSD_6_1_BASE:1.59
	OPENBSD_6_0:1.58.0.4
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.58.0.2
	OPENBSD_5_9_BASE:1.58
	OPENBSD_5_8:1.57.0.6
	OPENBSD_5_8_BASE:1.57
	OPENBSD_5_7:1.57.0.2
	OPENBSD_5_7_BASE:1.57
	OPENBSD_5_6:1.56.0.6
	OPENBSD_5_6_BASE:1.56
	OPENBSD_5_5:1.56.0.4
	OPENBSD_5_5_BASE:1.56
	OPENBSD_5_4:1.54.0.2
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.53.0.6
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.53.0.4
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.2
	OPENBSD_5_0:1.50.0.2
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.47.0.2
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.45.0.2
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.41.0.4
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.38.0.2
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.37.0.2
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.33.0.4
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2
	LUNA88K_INIT:1.1.1.1
	AOYAMA:1.1.1;
locks; strict;
comment	@ * @;


1.59
date	2017.02.28.10.49.37;	author natano;	state Exp;
branches;
next	1.58;
commitid	9645cvu5lMcc7gZM;

1.58
date	2015.09.28.15.17.08;	author krw;	state Exp;
branches;
next	1.57;
commitid	F5VKEQmoSNbQb8HV;

1.57
date	2015.01.16.20.17.05;	author miod;	state Exp;
branches;
next	1.56;
commitid	qvf9KkZ1B5C1I4hl;

1.56
date	2013.10.20.10.11.16;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2013.08.25.10.50.55;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2013.06.11.16.42.09;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2011.10.26.04.17.23;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2011.10.25.18.34.37;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2011.10.21.09.36.52;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2011.04.16.03.21.15;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2011.04.15.14.57.28;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2011.04.06.13.46.50;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2011.02.26.13.07.48;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2010.09.29.13.39.03;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2010.04.25.06.15.17;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2010.04.23.15.25.20;	author jsing;	state Exp;
branches;
next	1.43;

1.43
date	2010.02.26.23.11.56;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2009.08.13.15.23.10;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2009.06.04.21.13.01;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2009.05.21.23.45.48;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2009.05.13.01.31.58;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2009.01.22.01.06.28;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2008.06.29.20.05.22;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.12.06.58.35;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.11.12.35.42;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.10.20.50.23;	author beck;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.20.18.15.45;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.19.12.33.59;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.18.05.28.54;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.17.00.27.28;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.14.03.41.21;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.14.03.37.23;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.14.03.35.29;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.14.03.29.34;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.12.20.57.42;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.09.23.06.46;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.09.04.08.39;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.08.12.45.05;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.08.05.34.28;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.07.03.41.52;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.07.00.28.17;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.06.22.14.29;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.06.16.42.06;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.05.02.38.36;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.05.00.38.16;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.02.02.35.27;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.31.19.57.43;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.29.06.28.15;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.29.05.08.20;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.04.03.23.01;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2006.08.17.10.34.14;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.11.14.08.36;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.15.20.20.39;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.26.07.11.08;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.22.00.11.33;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.30.07.52.31;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.29.16.35.59;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.14.12.57.02;	author aoyama;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.21.15.23.59;	author aoyama;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	2004.04.21.15.23.59;	author aoyama;	state Exp;
branches;
next	;

1.1.2.1
date	2004.06.05.23.09.47;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.59
log
@Switch geteblks()'s size argument from int to size_t. It's called with
unsigned variables as argument in most places anyway. Decrease the
chance of signedness/range mismatch issues.

ok stefan
@
text
@/* $OpenBSD: disksubr.c,v 1.58 2015/09/28 15:17:08 krw Exp $ */
/* $NetBSD: disksubr.c,v 1.12 2002/02/19 17:09:44 wiz Exp $ */

/*
 * Copyright (c) 1994, 1995 Gordon W. Ross
 * Copyright (c) 1994 Theo de Raadt
 * Copyright (c) 1982, 1986, 1988 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>

#include <dev/sun/disklabel.h>

/*
 * UniOS disklabel (== ISI disklabel) is very similar to SunOS.
 *	SunOS				UniOS/ISI
 *	text		128			128
 *	(pad)		292			294
 *	rpm		2		-
 *	pcyl		2		badchk	2
 *	sparecyl	2		maxblk	4
 *	(pad)		4		dtype	2
 *	interleave	2		ndisk	2
 *	ncyl		2			2
 *	acyl		2			2
 *	ntrack		2			2
 *	nsect		2			2
 *	(pad)		4		bhead	2
 *	-				ppart	2
 *	dkpart[8]	64			64
 *	magic		2			2
 *	cksum		2			2
 *
 * Magic number value and checksum calculation are identical.  Subtle
 * difference is partition start address; UniOS/ISI maintains sector
 * numbers while SunOS label has cylinder number.
 *
 * It is found that LUNA Mach2.5 has BSD label embedded at offset 64
 * retaining UniOS/ISI label at the end of label block.  LUNA Mach
 * manipulates BSD disklabel in the same manner as 4.4BSD.  It's
 * uncertain LUNA Mach can create a disklabel on fresh disks since
 * Mach writedisklabel logic seems to fail when no BSD label is found.
 *
 * Kernel handles disklabel in this way;
 *	- searchs BSD label at offset 64
 *	- if not found, searchs UniOS/ISI label at the end of block
 *	- kernel can distinguish whether it was SunOS label or UniOS/ISI
 *	  label and understand both
 *	- kernel writes UniOS/ISI label combined with BSD label to update
 *	  the label block
 */

#if LABELSECTOR != 0
#error	"Default value of LABELSECTOR no longer zero?"
#endif

int disklabel_om_to_bsd(struct sun_disklabel *, struct disklabel *);
int disklabel_bsd_to_om(struct disklabel *, struct sun_disklabel *);
static __inline u_int sun_extended_sum(struct sun_disklabel *, void *);

/*
 * Attempt to read a disk label from a device
 * using the indicated strategy routine.
 * The label must be partly set up before this:
 * secpercyl, secsize and anything required for a block i/o read
 * operation in the driver's strategy/start routines
 * must be filled in before calling us.
 */
int
readdisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, int spoofonly)
{
	struct sun_disklabel *slp;
	struct buf *bp = NULL;
	int error;

	if ((error = initdisklabel(lp)))
		goto done;
	lp->d_flags |= D_VENDOR;

	/* get a buffer and initialize it */
	bp = geteblk(lp->d_secsize);
	bp->b_dev = dev;

	if (spoofonly)
		goto done;

	error = readdisksector(bp, strat, lp, DL_BLKTOSEC(lp, LABELSECTOR));
	if (error)
		goto done;

	slp = (struct sun_disklabel *)bp->b_data;
	if (slp->sl_magic == SUN_DKMAGIC) {
		error = disklabel_om_to_bsd(slp, lp);
		goto done;
	}

	error = checkdisklabel(bp->b_data + LABELOFFSET, lp, 0,
	    DL_GETDSIZE(lp));
	if (error == 0)
		goto done;

#if defined(CD9660)
	error = iso_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif
#if defined(UDF)
	error = udf_disklabelspoof(dev, strat, lp);
	if (error == 0)
		goto done;
#endif

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}

/*
 * Write disk label back to device after modification.
 */
int
writedisklabel(dev_t dev, void (*strat)(struct buf *), struct disklabel *lp)
{
	struct buf *bp = NULL;
	int error;

	/* get a buffer and initialize it */
	bp = geteblk(lp->d_secsize);
	bp->b_dev = dev;

	error = disklabel_bsd_to_om(lp, (struct sun_disklabel *)bp->b_data);
	if (error)
		goto done;

	/* Write out the updated label. */
	bp->b_blkno = LABELSECTOR;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_WRITE | B_RAW);
	(*strat)(bp);
	error = biowait(bp);

done:
	if (bp) {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
	disk_change = 1;
	return (error);
}

/************************************************************************
 *
 * The rest of this was taken from arch/sparc/scsi/sun_disklabel.c
 * and then substantially rewritten by Gordon W. Ross
 *
 ************************************************************************/

/* What partition types to assume for Sun disklabels: */
static const u_char
sun_fstypes[16] = {
	FS_BSDFFS,	/* a */
	FS_SWAP,	/* b */
	FS_UNUSED,	/* c - whole disk */
	FS_BSDFFS,	/* d */
	FS_BSDFFS,	/* e */
	FS_BSDFFS,	/* f */
	FS_BSDFFS,	/* g */
	FS_BSDFFS,	/* h */
	FS_BSDFFS,	/* i */
	FS_BSDFFS,	/* j */
	FS_BSDFFS,	/* k */
	FS_BSDFFS,	/* l */
	FS_BSDFFS,	/* m */
	FS_BSDFFS,	/* n */
	FS_BSDFFS,	/* o */
	FS_BSDFFS	/* p */
};

/*
 * Given a struct sun_disklabel, assume it has an extended partition
 * table and compute the correct value for sl_xpsum.
 */
static __inline u_int
sun_extended_sum(struct sun_disklabel *sl, void *end)
{
	u_int sum, *xp, *ep;

	xp = (u_int *)&sl->sl_xpmag;
	ep = (u_int *)end;

	sum = 0;
	for (; xp < ep; xp++)
		sum += *xp;
	return (sum);
}

/*
 * Given a UniOS/ISI disk label, set lp to a BSD disk label.
 *
 * The BSD label is cleared out before this is called.
 */
int
disklabel_om_to_bsd(struct sun_disklabel *sl, struct disklabel *lp)
{
	struct partition *npp;
	struct sun_dkpart *spp;
	int i, secpercyl;
	u_short cksum = 0, *sp1, *sp2;

	/* Verify the XOR check. */
	sp1 = (u_short *)sl;
	sp2 = (u_short *)(sl + 1);
	while (sp1 < sp2)
		cksum ^= *sp1++;
	if (cksum != 0)
		return (EINVAL);	/* UniOS disk label, bad checksum */

	/* Format conversion. */
	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_flags = D_VENDOR;
	memcpy(lp->d_packname, sl->sl_text, sizeof(lp->d_packname));

	lp->d_secsize = DEV_BSIZE;
	lp->d_nsectors = sl->sl_nsectors;
	lp->d_ntracks = sl->sl_ntracks;
	lp->d_ncylinders = sl->sl_ncylinders;

	secpercyl = sl->sl_nsectors * sl->sl_ntracks;
	lp->d_secpercyl = secpercyl;
	/* If unset or initialized as full disk, permit refinement */
	if (DL_GETDSIZE(lp) == 0 || DL_GETDSIZE(lp) == MAXDISKSIZE)
		DL_SETDSIZE(lp, (u_int64_t)secpercyl * sl->sl_ncylinders);
	lp->d_version = 1;

	memcpy(&lp->d_uid, &sl->sl_uid, sizeof(sl->sl_uid));

	lp->d_acylinders = sl->sl_acylinders;

	lp->d_npartitions = MAXPARTITIONS;
	/* These are as defined in <ufs/ffs/fs.h> */
	lp->d_bbsize = 8192;	/* XXX */
	lp->d_sbsize = 8192;	/* XXX */

	for (i = 0; i < 8; i++) {
		spp = &sl->sl_part[i];
		npp = &lp->d_partitions[i];
		/* UniOS label uses blkoffset, not cyloffset */
		DL_SETPOFFSET(npp, spp->sdkp_cyloffset);
		DL_SETPSIZE(npp, spp->sdkp_nsectors);
		if (DL_GETPSIZE(npp) == 0) {
			npp->p_fstype = FS_UNUSED;
		} else {
			npp->p_fstype = sun_fstypes[i];
			if (npp->p_fstype == FS_BSDFFS) {
				/*
				 * The sun label does not store the FFS fields,
				 * so just set them with default values here.
				 */
				npp->p_fragblock =
				    DISKLABELV1_FFS_FRAGBLOCK(2048, 8);
				npp->p_cpg = 16;
			}
		}
	}

	/*
	 * XXX BandAid XXX
	 * UniOS rootfs sits on part c which don't begin at sect 0,
	 * and impossible to mount.  Thus, make it usable as part b.
	 * XXX how to setup a swap partition on disks shared with UniOS???
	 */
	if (sl->sl_rpm == 0 && DL_GETPOFFSET(&lp->d_partitions[2]) != 0) {
		lp->d_partitions[1] = lp->d_partitions[2];
		lp->d_partitions[1].p_fstype = FS_BSDFFS;
	}

	/* Clear "extended" partition info, tentatively */
	for (i = 0; i < SUNXPART; i++) {
		npp = &lp->d_partitions[i+8];
		DL_SETPOFFSET(npp, 0);
		DL_SETPSIZE(npp, 0);
		npp->p_fstype = FS_UNUSED;
	}

	/* Check to see if there's an "extended" partition table
	 * SL_XPMAG partitions had checksums up to just before the
	 * (new) sl_types variable, while SL_XPMAGTYP partitions have
	 * checksums up to the just before the (new) sl_xxx1 variable.
	 */
	if ((sl->sl_xpmag == SL_XPMAG &&
	    sun_extended_sum(sl, &sl->sl_types) == sl->sl_xpsum) ||
	    (sl->sl_xpmag == SL_XPMAGTYP &&
	    sun_extended_sum(sl, &sl->sl_xxx1) == sl->sl_xpsum)) {
		/*
		 * There is.  Copy over the "extended" partitions.
		 * This code parallels the loop for partitions a-h.
		 */
		for (i = 0; i < SUNXPART; i++) {
			spp = &sl->sl_xpart[i];
			npp = &lp->d_partitions[i+8];
			DL_SETPOFFSET(npp, spp->sdkp_cyloffset);
			DL_SETPSIZE(npp, spp->sdkp_nsectors);
			if (DL_GETPSIZE(npp) == 0) {
				npp->p_fstype = FS_UNUSED;
				continue;
			}
			npp->p_fstype = sun_fstypes[i+8];
			if (npp->p_fstype == FS_BSDFFS) {
				npp->p_fragblock =
				    DISKLABELV1_FFS_FRAGBLOCK(2048, 8);
				npp->p_cpg = 16;
			}
		}
		if (sl->sl_xpmag == SL_XPMAGTYP) {
			for (i = 0; i < MAXPARTITIONS; i++) {
				npp = &lp->d_partitions[i];
				npp->p_fstype = sl->sl_types[i];
				npp->p_fragblock = sl->sl_fragblock[i];
				npp->p_cpg = sl->sl_cpg[i];
			}
		}
	}

	lp->d_checksum = 0;
	lp->d_checksum = dkcksum(lp);
	return (checkdisklabel(lp, lp, 0, DL_GETDSIZE(lp)));
}

/*
 * Given a BSD disk label, update the UniOS disklabel
 * pointed to by sl with the new info.  Note that the
 * UniOS disklabel may have other info we need to keep.
 */
int
disklabel_bsd_to_om(struct disklabel *lp, struct sun_disklabel *sl)
{
	struct partition *npp;
	struct sun_dkpart *spp;
	int i, secpercyl;
	u_short cksum, *sp1, *sp2;

	if (lp->d_secsize != DEV_BSIZE || lp->d_nsectors == 0 ||
	    lp->d_ntracks == 0)
		return (EINVAL);

	/* Format conversion. */
	bzero(sl, sizeof(*sl));
	memcpy(sl->sl_text, lp->d_packname, sizeof(lp->d_packname));
	sl->sl_rpm = 0;					/* UniOS compatible */
#if 0 /* leave as was */
	sl->sl_pcylinders = lp->d_ncylinders + lp->d_acylinders; /* XXX */
#endif
	sl->sl_interleave = 1;
	sl->sl_ncylinders = lp->d_ncylinders;
	sl->sl_acylinders = lp->d_acylinders;
	sl->sl_ntracks = lp->d_ntracks;
	sl->sl_nsectors = lp->d_nsectors;

	memcpy(&sl->sl_uid, &lp->d_uid, sizeof(lp->d_uid));

	for (i = 0; i < 8; i++) {
		spp = &sl->sl_part[i];
		npp = &lp->d_partitions[i];
		spp->sdkp_cyloffset = 0;
		spp->sdkp_nsectors = 0;
		if (DL_GETPSIZE(npp)) {
			spp->sdkp_cyloffset = DL_GETPOFFSET(npp); /* UniOS */
			spp->sdkp_nsectors = DL_GETPSIZE(npp);
		}
	}
	sl->sl_magic = SUN_DKMAGIC;

	secpercyl = sl->sl_nsectors * sl->sl_ntracks;
	for (i = 0; i < SUNXPART; i++) {
		spp = &sl->sl_xpart[i];
		npp = &lp->d_partitions[i+8];
		spp->sdkp_cyloffset = 0;
		spp->sdkp_nsectors = 0;
		if (DL_GETPSIZE(npp)) {
			spp->sdkp_cyloffset = DL_GETPOFFSET(npp);
			spp->sdkp_nsectors = DL_GETPSIZE(npp);
		}
	}
	for (i = 0; i < MAXPARTITIONS; i++) {
		npp = &lp->d_partitions[i];
		sl->sl_types[i] = npp->p_fstype;
		sl->sl_fragblock[i] = npp->p_fragblock;
		sl->sl_cpg[i] = npp->p_cpg;
	}
	sl->sl_xpmag = SL_XPMAGTYP;
	sl->sl_xpsum = sun_extended_sum(sl, &sl->sl_xxx1);

	/* Correct the XOR check. */
	sp1 = (u_short *)sl;
	sp2 = (u_short *)(sl + 1);
	sl->sl_cksum = cksum = 0;
	while (sp1 < sp2)
		cksum ^= *sp1++;
	sl->sl_cksum = cksum;

	return (0);
}
@


1.58
log
@Mechanical changes from manual buf set up to readdisksector().

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.57 2015/01/16 20:17:05 miod Exp $ */
d116 1
a116 1
	bp = geteblk((int)lp->d_secsize);
d167 1
a167 1
	bp = geteblk((int)lp->d_secsize);
@


1.57
log
@disklabel_sun_to_bsd() will nicely set the disk size if it is zero, but it is
usually invoked after initdisklabel() which proactively changes a zero disk
size to MAXDISKSIZE, causing this test to fail.

Allow for MAXDISKSIZE too in that test. This makes spoofed disklabels of SMD
disks have a proper `c' slice size.

luna88k disklabel_om_to_bsd() is modified accordingly, to keep diffability,
even though luna88k can't - to the best of my knowledge - sport SMD disk
controllers.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.56 2013/10/20 10:11:16 krw Exp $ */
d122 2
a123 7
	bp->b_blkno = LABELSECTOR;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if (biowait(bp)) {
		error = bp->b_error;
a124 1
	}
@


1.56
log
@(daddr_t) -> (u_int64_t) when multiplying ncylinders * secpercyl to
get disk size, since DL_SETDSIZE() takes disk sector values, not
512-byte block values.
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.55 2013/08/25 10:50:55 miod Exp $ */
d277 2
a278 1
	if (DL_GETDSIZE(lp) == 0)
@


1.55
log
@Do not require that `extra' partitions (i-p) start on cylinder boundaries;
this was inherited from sparc when adding 16 partition support, but
disklabel(8) does not enforce such alignment, and since UniOS never did
for the `traditional' partitions (a-h), there is no good reason to keep this.

This makes partitions i-p really functional.
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.54 2013/06/11 16:42:09 deraadt Exp $ */
d278 1
a278 1
		DL_SETDSIZE(lp, (daddr_t)secpercyl * sl->sl_ncylinders);
@


1.54
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.53 2011/10/26 04:17:23 miod Exp $ */
d294 1
a294 4
		if (sl->sl_rpm == 0)
			DL_SETPOFFSET(npp, spp->sdkp_cyloffset);
		else
			DL_SETPOFFSET(npp, spp->sdkp_cyloffset * secpercyl);
d347 1
a347 2
			/* no need to be UniOS compatible here */
			DL_SETPOFFSET(npp, spp->sdkp_cyloffset * secpercyl);
d426 1
a426 4
			/* no need to be UniOS compatible here */
			if (DL_GETPOFFSET(npp) % secpercyl)
				return (EINVAL);
			spp->sdkp_cyloffset = DL_GETPOFFSET(npp) / secpercyl;
@


1.53
log
@Make this compile.
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.52 2011/10/25 18:34:37 miod Exp $ */
d278 1
a278 1
		DL_SETDSIZE(lp, (daddr64_t)secpercyl * sl->sl_ncylinders);
@


1.52
log
@Bring luna88k disklabel handling code in sync with sparc, except for the
SunOS vs UniOS differences for the legacy part (first eight partitions), which
are preserved. Tested by aoyama@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.51 2011/10/21 09:36:52 miod Exp $ */
d133 1
a133 1
	if (sl->sl_magic == SUN_DKMAGIC) {
@


1.51
log
@Fix 1.43 to not bzero the in-core disklabel but really the UniOS disklabel
as intended in disklabel_bsd_to_om(); repairs vnd operation. Found the
hard way by aoyama@@.
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.50 2011/04/16 03:21:15 krw Exp $ */
d93 1
d107 1
a122 1
	bp->b_cylinder = 0;
d132 3
a134 2
	error = disklabel_om_to_bsd((struct sun_disklabel *)bp->b_data, lp);
	if (error == 0)
d136 1
d176 1
a176 9
	/* Read the on disk label. */
	bp->b_blkno = LABELSECTOR;
	bp->b_cylinder = 0;
	bp->b_bcount = lp->d_secsize;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);

	(*strat)(bp);
	error = biowait(bp);
d181 2
a182 4
	error = disklabel_bsd_to_om(lp, (struct sun_disklabel *)bp->b_data);
	if (error)
		goto done;

d206 1
a206 1
sun_fstypes[8] = {
d209 1
a209 1
	FS_OTHER,	/* c - whole disk */
d215 8
d226 18
a255 3
	if (sl->sl_magic != SUN_DKMAGIC)
		return (EINVAL);

a263 1
	memset((caddr_t)lp, 0, sizeof(struct disklabel));
a284 5
	if (sl->sl_rpm == 0) {
		/* UniOS label has blkoffset, not cyloffset */
		secpercyl = 1;
	}

d293 5
a297 1
		DL_SETPOFFSET(npp, spp->sdkp_cyloffset * secpercyl);
d309 1
a309 1
				    DISKLABELV1_FFS_FRAGBLOCK(1024, 8);
d319 1
d326 48
d389 1
a389 1
	int i;
d392 2
a393 1
	if (lp->d_secsize != DEV_BSIZE)
d399 1
a399 1
	sl->sl_rpm = 0;					/* UniOS */
d401 1
a401 1
	sl->sl_pcyl = lp->d_ncylinders + lp->d_acylinders;	/* XXX */
d414 8
d423 13
a435 2
		spp->sdkp_cyloffset = DL_GETPOFFSET(npp);	/* UniOS */
		spp->sdkp_nsectors = DL_GETPSIZE(npp);
d437 8
a444 1
	sl->sl_magic = SUN_DKMAGIC;
@


1.50
log
@Use 'CLR(<buf>->b_flags, B_READ | B_WRITE | B_DONE)' regardless of
what the previous IO was. Less chance of copy and paste errors.
Suggested by miod@@.
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.49 2011/04/15 14:57:28 krw Exp $ */
d333 1
a333 1
	bzero(lp, sizeof(*lp));
@


1.49
log
@In days of yore one could arbitrarily whack buffer flags. Those days
are past. Use CLR() and SET() to modify necessary flags while leaving
the flags used by the buffer cache in peace.

Should make bufcache code much less confused about the state of the
bufs used in reading/writing disklabels. Other such flag abuses no
doubt await a visit.

Errors in original diff found by miod@@.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.48 2011/04/06 13:46:50 miod Exp $ */
d123 1
a123 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d177 1
a177 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
d190 1
a190 1
	CLR(bp->b_flags, B_READ | B_DONE);
@


1.48
log
@The various read*label() have stopped returning error strings for quite
some time, and return errnos instead. Fix or remove out-of-date comments
mentioning the error strings, and make their callers check the return value
against zero, not NULL.
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.47 2011/02/26 13:07:48 krw Exp $ */
d123 2
a124 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d177 2
a178 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d190 2
a191 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.47
log
@Force the DUID cache used to generate hw.disknames to be updated
after every disklabel read or write. This keeps the DUID cache more
in sync with the physical world. De-syncing noted by drahn@@ while
zapping disklabels with dd.

ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.46 2010/09/29 13:39:03 miod Exp $ */
a100 4
 *
 * Return buffer for use in signalling errors if requested.
 *
 * Returns null on success and an error string on failure.
a222 1
 * Returns NULL on success, else an error string.
a316 1
 * Returns zero or error code.
@


1.46
log
@It's never too late to make things at least compile.
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.45 2010/04/25 06:15:17 deraadt Exp $ */
d159 1
d201 1
@


1.45
log
@introducing a 64-bit type to the disklabel structure leads some architectures
to pad-align the size of the structure; it grows, the disklabel ioctl's are
break ABI.  Change the uid to a character array.  this also simplifies some
other stuff
ok jsing
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.44 2010/04/23 15:25:20 jsing Exp $ */
d91 1
a91 1
char *disklabel_om_to_bsd(struct sun_disklabel *, struct disklabel *);
a109 1
	struct sun_disklabel *slp;
@


1.44
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.42 2009/08/13 15:23:10 deraadt Exp $ */
d267 1
a267 1
	lp->d_label_uid = sl->sl_label_uid;
d347 1
a347 1
	sl->sl_label_uid = lp->d_label_uid;
@


1.43
log
@when we build a vendor label for writing, clear the memory supplied by the
buffer cache first, so that all sorts of gibble doesn't end up on the disk.
ok kettenis (for the sparc/sparc64 ones, at least)
@
text
@d267 2
a268 1
	lp->d_sparespercyl = 0;				/* no way to know */
a269 2
	lp->d_rpm = sl->sl_rpm;				/* UniOS - (empty) */
	lp->d_interleave = sl->sl_interleave;		/* UniOS - ndisk */
a339 1
	sl->sl_sparespercyl = lp->d_sparespercyl;
d341 1
a341 1
	sl->sl_interleave = lp->d_interleave;
d346 2
@


1.42
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.41 2009/06/04 21:13:01 deraadt Exp $ */
d336 1
@


1.41
log
@Recycle four ancient fields in the disklabel structure, replacing them with
bounds information, ie. the zone of the disk that OpenBSD can use.  Have each
pre-disklabel parser (MBR, DPME, or per-arch MD disklabel parsers) figure out
this area and pass it up to userland.  Then, delete all the same disk parsing
code from disklabel(8) since the kernel passes it up.  Lots and lots of - signs
in the disklabel(8) code.
Tested on as many platforms as possible, the fallout will be repaired as time
goes on.  To test, use disklabel -d <drive> and validate that the bounds do not
overlap any boot blocks.  This same information is used by disklabel -A...
OK for the concept from krw, miod, and drahn
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.40 2009/05/21 23:45:48 krw Exp $ */
d106 1
a106 1
char *
d112 1
a112 1
	char *msg;
d114 1
a114 1
	if ((msg = initdisklabel(lp)))
d131 1
a131 1
		msg = "disk label read error";
d135 2
a136 3
	slp = (struct sun_disklabel *)bp->b_data;
	if (slp->sl_magic == SUN_DKMAGIC) {
		msg = disklabel_om_to_bsd(slp, lp);
a137 1
	}
d139 3
a141 2
	msg = checkdisklabel(bp->b_data + LABELOFFSET, lp, 0, DL_GETDSIZE(lp));
	if (msg == NULL)
d145 2
a146 2
	if (iso_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a147 1
	}
d150 2
a151 2
	if (udf_disklabelspoof(dev, strat, lp) == 0) {
		msg = NULL;
a152 1
	}
d160 1
a160 1
	return (msg);
d230 1
a230 1
char *
d238 3
d247 1
a247 1
		return ("UniOS disk label, bad checksum");
@


1.40
log
@The only value that d_npartitions should have is MAXPARTITIONS.
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.39 2009/05/13 01:31:58 krw Exp $ */
d141 1
a141 1
	msg = checkdisklabel(bp->b_data + LABELOFFSET, lp);
d315 1
a315 1
	return (checkdisklabel(lp, lp));
@


1.39
log
@Set D_VENDOR when spoofing a label on archs that use D_VENDOR when
reading the native disklabel. This ensures cylinder alignment.

Fix disklabel to do cylinder alignment arithmetic correctly in -A
mode. Worked by accident before, since the code was protected by
D_VENDOR, which wasn't being set.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.38 2009/01/22 01:06:28 krw Exp $ */
d277 1
a277 1
	lp->d_npartitions = 8;
@


1.38
log
@Call checkdisklabel() for labels built from native info. This will
ensure 'c' always has the correct size as the rest of the kernel
assumes. Thus prevent dd'ing causing a SCSI out-of-bounds error.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.37 2008/06/29 20:05:22 krw Exp $ */
d116 1
@


1.37
log
@Use DEV_BSIZE (defined as 512) instead of 512 when initializing the
disklabel's d_secsize.

ok millert@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.36 2008/06/12 06:58:35 deraadt Exp $ */
d314 1
a314 1
	return (NULL);
@


1.36
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.34 2008/06/10 20:50:23 beck Exp $ */
d255 1
a255 1
	lp->d_secsize = 512;
d331 1
a331 1
	if (lp->d_secsize != 512)
@


1.35
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.33 2007/06/20 18:15:45 deraadt Exp $ */
d127 1
a127 1
	bp->b_flags = B_BUSY | B_READ;
d182 1
a182 1
	bp->b_flags = B_BUSY | B_READ;
d194 1
a194 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.34
log
@Fix buffer cache pending read statistics by ensuring we can identify
biowait() reads that do *not* come from the buffer cache - we use the
B_RAW flag to identify these at art's suggestion - since it makes sense
and the flag was not being used. this just flags all these buffers with
B_RAW - biodone already ignores returned buffers marked B_RAW.
ok art@@
@
text
@d127 1
a127 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d182 1
a182 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
d194 1
a194 1
	bp->b_flags = B_BUSY | B_WRITE | B_RAW;
@


1.33
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.32 2007/06/19 12:33:59 krw Exp $ */
d127 1
a127 1
	bp->b_flags = B_BUSY | B_READ;
d182 1
a182 1
	bp->b_flags = B_BUSY | B_READ;
d194 1
a194 1
	bp->b_flags = B_BUSY | B_WRITE;
@


1.32
log
@Empty another cpu_disklabel. In this case read in the boot
block/native label as needed rather than keeping it in cpu_disklabel.
Also a number of assorted minor tweaks to reduce the delta to sparc64
disksubr.c.

'get this in' deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.31 2007/06/18 05:28:54 deraadt Exp $ */
d108 1
a108 1
    struct disklabel *lp, struct cpu_disklabel *osdep, int spoofonly)
d169 1
a169 2
writedisklabel(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, struct cpu_disklabel *osdep)
@


1.31
log
@using same words in similar code sequences is good
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.30 2007/06/17 00:27:28 deraadt Exp $ */
d91 2
a92 2
char *disklabel_om_to_bsd(char *, struct disklabel *);
int disklabel_bsd_to_om(struct disklabel *, char *);
d108 1
a108 1
    struct disklabel *lp, struct cpu_disklabel *clp, int spoofonly)
d110 1
a111 3
	struct disklabel *dlp;
	struct sun_disklabel *slp;
	int error, i;
d129 1
a129 8

	/* if successful, locate disk label within block and validate */
	error = biowait(bp);
	if (!error) {
		/* Save the whole block in case it has info we need. */
		bcopy(bp->b_data, clp->cd_block, sizeof(clp->cd_block));
	}
	if (error) {
d134 1
a134 1
	slp = (struct sun_disklabel *)clp->cd_block;
d136 1
a136 1
		msg = disklabel_om_to_bsd(clp->cd_block, lp);
d140 1
a140 1
	msg = checkdisklabel(clp->cd_block + LABELOFFSET, lp);
a155 2
	bzero(clp->cd_block, sizeof(clp->cd_block));
	msg = "no disk label";
a162 1

a166 1
 * Current label is already in clp->cd_block[]
d170 1
a170 1
    struct disklabel *lp, struct cpu_disklabel *clp)
a172 1
	struct disklabel *dlp;
a174 8
	/* implant OpenBSD disklabel at LABELOFFSET. */
	dlp = (struct disklabel *)(clp->cd_block + LABELOFFSET);
	*dlp = *lp;	/* struct assignment */

	error = disklabel_bsd_to_om(lp, clp->cd_block);
	if (error)
		goto done;

d177 1
a177 1
	bcopy(clp->cd_block, bp->b_data, sizeof(clp->cd_block));
d179 1
a179 2
	/* Write out the updated label. */
	bp->b_dev = dev;
d183 12
d234 1
a234 1
disklabel_om_to_bsd(char *cp, struct disklabel *lp)
a235 1
	struct sun_disklabel *sl;
d239 1
a239 3
	u_short cksum, *sp1, *sp2;

	sl = (struct sun_disklabel *)cp;
a243 1
	cksum = 0;
d253 1
a255 1
	lp->d_type = DTYPE_SCSI;
d265 1
a270 1
	lp->d_version = 1;
d279 3
a281 2
	lp->d_bbsize = 8192;				/* XXX */
	lp->d_sbsize = 8192;				/* XXX */
d287 1
a287 1
		if (DL_GETPSIZE(npp) == 0)
d289 1
a289 2
		else {
			/* Partition has non-zero size.  Set type, etc. */
a290 8

			/*
			 * The sun label does not store the FFS fields,
			 * so just set them with default values here.
			 * XXX: This keeps newfs from trying to rewrite
			 * XXX: the disk label in the most common case.
			 * XXX: (Should remove that code from newfs...)
			 */
d292 4
d297 1
a297 1
				   DISKLABELV1_FFS_FRAGBLOCK(1024, 8);
d313 1
a314 1

d320 1
a320 1
 * pointed to by cp with the new info.  Note that the
d325 1
a325 1
disklabel_bsd_to_om(struct disklabel *lp, char *cp)
a326 1
	struct sun_disklabel *sl;
a333 2

	sl = (struct sun_disklabel *)cp;
@


1.30
log
@significantly simplified disklabel infrastructure.  MBR handling becomes MI
to support hotplug media on most architectures.  disklabel setup and
verification done using new helper functions.  Disklabels must *always*
have a correct checksum now.  Same code paths are used to learn on-disk
location disklabels, to avoid new errors sneaking in.  Tested on almost all
cases, testing help from todd, kettenis, krw, otto, dlg, robert, gwk, drahn
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.29 2007/06/14 03:41:21 deraadt Exp $ */
d119 1
a119 1
	/* obtain buffer to probe drive with */
d197 1
a197 1
	/* Get a buffer and copy the new label into it. */
@


1.29
log
@some spaces in the way
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.28 2007/06/14 03:37:23 deraadt Exp $ */
a36 8
 *
 * Credits:
 * This file was based mostly on the i386/disksubr.c file:
 *	@@(#)ufs_disksubr.c	7.16 (Berkeley) 5/4/91
 * The functions: disklabel_sun_to_bsd, disklabel_bsd_to_sun
 * were originally taken from arch/sparc/scsi/sun_disklabel.c
 * (which was written by Theo de Raadt) and then substantially
 * rewritten by Gordon W. Ross.
a112 1
	char *msg = NULL;
d114 1
d116 1
a116 21
	/* minimal requirements for archetypal disk label */
	if (lp->d_secsize < DEV_BSIZE)
		lp->d_secsize = DEV_BSIZE;
	if (DL_GETDSIZE(lp) == 0)
		DL_SETDSIZE(lp, MAXDISKSIZE);
	if (lp->d_secpercyl == 0) {
		msg = "invalid geometry";
		goto done;
	}
	lp->d_npartitions = RAW_PART + 1;
	for (i = 0; i < RAW_PART; i++) {
		DL_SETPSIZE(&lp->d_partitions[i], 0);
		DL_SETPOFFSET(&lp->d_partitions[i], 0);
	}
	if (DL_GETPSIZE(&lp->d_partitions[RAW_PART]) == 0)
		DL_SETPSIZE(&lp->d_partitions[RAW_PART], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[RAW_PART], 0);
	lp->d_version = 1;

        /* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
d121 4
a125 2
	/* next, dig out disk label */
	bp->b_dev = dev;
d143 10
d165 1
a165 21

	/* Check for a BSD disk label first. */
	dlp = (struct disklabel *)(clp->cd_block + LABELOFFSET);
	if (dlp->d_magic == DISKMAGIC && dlp->d_magic2 == DISKMAGIC) {
		if (dkcksum(dlp) == 0) {
			DL_SETDSIZE(dlp, DL_GETDSIZE(lp));
			*lp = *dlp;	/* struct assignment */
			msg = NULL;
			goto done;
		}
		printf("BSD disk label corrupted");
	}

	/* Check for a UniOS/ISI disk label. */
	slp = (struct sun_disklabel *)clp->cd_block;
	if (slp->sl_magic == SUN_DKMAGIC) {
		msg = disklabel_om_to_bsd(clp->cd_block, lp);
		goto done;
	}

	memset(clp->cd_block, 0, sizeof(clp->cd_block));
a172 1
	disklabeltokernlabel(lp);
@


1.28
log
@excessive blank lines making the versions different
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.27 2007/06/14 03:35:29 deraadt Exp $ */
d307 4
a310 4
	lp->d_type	 = DTYPE_SCSI;
	lp->d_secsize	 = 512;
	lp->d_nsectors   = sl->sl_nsectors;
	lp->d_ntracks    = sl->sl_ntracks;
d314 1
a314 1
	lp->d_secpercyl  = secpercyl;
d319 4
a322 4
	lp->d_acylinders   = sl->sl_acylinders;
	lp->d_rpm          = sl->sl_rpm;		/* UniOS - (empty) */
	lp->d_interleave   = sl->sl_interleave;		/* UniOS - ndisk */
	lp->d_version	   = 1;
d401 5
a405 5
	sl->sl_interleave   = lp->d_interleave;
	sl->sl_ncylinders   = lp->d_ncylinders;
	sl->sl_acylinders   = lp->d_acylinders;
	sl->sl_ntracks      = lp->d_ntracks;
	sl->sl_nsectors     = lp->d_nsectors;
@


1.27
log
@set the prototype disklabel to version 1
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.26 2007/06/14 03:29:34 deraadt Exp $ */
a212 2


@


1.26
log
@do not depend on previous loop variable, use a constant instead
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.25 2007/06/12 20:57:42 deraadt Exp $ */
d141 1
@


1.25
log
@all disksubr.c did their b_flags manipulation differently (and wrong).
correct and unify; ok thib miod
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.24 2007/06/09 23:06:46 krw Exp $ */
d138 3
a140 3
	if (DL_GETPSIZE(&lp->d_partitions[i]) == 0)
		DL_SETPSIZE(&lp->d_partitions[i], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[i], 0);
@


1.24
log
@The differences in the last non-homogeneous bounds_check_with_label()
routines (alpha, vax) prove to be not worth keeping. Move
bounds_check_with_label() into the MI world. Eliminate unreliable and
almost certainly useless checks for overwriting a disklabel.

After discussion with deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.23 2007/06/09 04:08:39 deraadt Exp $ */
d205 1
a205 1
		bp->b_flags = B_INVAL | B_AGE | B_READ;
d223 1
a223 1
	struct buf *bp;
d233 1
a233 1
		return (error);
d244 1
a244 1
	bp->b_flags = B_WRITE;
a246 1
	brelse(bp);
d248 5
@


1.23
log
@by hand i carefully found that all the differences in setdisklabel()
implimentations were simply either missing code, or spacing and such.
setdisklabel() can become MI now.
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.22 2007/06/08 12:45:05 krw Exp $ */
a249 56
}

/*
 * Determine the size of the transfer, and make sure it is
 * within the boundaries of the partition. Adjust transfer
 * if needed, and signal errors or early completion.
 */
int
bounds_check_with_label(struct buf *bp, struct disklabel *lp,
    struct cpu_disklabel *osdep, int wlabel)
{
#define blockpersec(count, lp) ((count) * (((lp)->d_secsize) / DEV_BSIZE))
	struct partition *p = lp->d_partitions + DISKPART(bp->b_dev);
	int labelsector = blockpersec(DL_GETPOFFSET(&lp->d_partitions[RAW_PART]), lp) +
	    LABELSECTOR;
	int sz = howmany(bp->b_bcount, DEV_BSIZE);

	/* avoid division by zero */
	if (lp->d_secpercyl == 0) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/* beyond partition? */
	if (bp->b_blkno + sz > blockpersec(DL_GETPSIZE(p), lp)) {
		sz = blockpersec(DL_GETPSIZE(p), lp) - bp->b_blkno;
		if (sz == 0) {
			/* If exactly at end of disk, return EOF. */
			bp->b_resid = bp->b_bcount;
			return (-1);
		}
		if (sz < 0) {
			/* If past end of disk, return EINVAL. */
			bp->b_error = EINVAL;
			goto bad;
		}
		/* Otherwise, truncate request. */
		bp->b_bcount = sz << DEV_BSHIFT;
	}

	/* Overwriting disk label? */
	if (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) <= labelsector &&
	    bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) + sz > labelsector &&
	    (bp->b_flags & B_READ) == 0 && !wlabel) {
		bp->b_error = EROFS;
		goto bad;
	}

	/* calculate cylinder for disksort to order transfers with */
	bp->b_cylinder = (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp)) /
	    lp->d_secpercyl;
	return (1);

bad:
	bp->b_flags |= B_ERROR;
	return (-1);
@


1.22
log
@disklabel_om_to_bsd() is generating a v1 label so set the label
version to 1.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.21 2007/06/08 05:34:28 deraadt Exp $ */
a212 43
/*
 * Check new disk label for sensibility
 * before setting it.
 */
int
setdisklabel(struct disklabel *olp, struct disklabel *nlp,
    u_int openmask, struct cpu_disklabel *clp)
{
	struct partition *opp, *npp;
	int i;

	/* sanity clause */
	if ((nlp->d_secpercyl == 0) || (nlp->d_secsize == 0) ||
	    (nlp->d_secsize % DEV_BSIZE) != 0)
		return (EINVAL);

	/* special case to allow disklabel to be invalidated */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return (0);
	}

	if (nlp->d_magic != DISKMAGIC ||
	    nlp->d_magic2 != DISKMAGIC ||
	    dkcksum(nlp) != 0)
		return (EINVAL);

	while (openmask != 0) {
		i = ffs(openmask) - 1;
		openmask &= ~(1 << i);
		if (nlp->d_npartitions <= i)
			return (EBUSY);
		opp = &olp->d_partitions[i];
		npp = &nlp->d_partitions[i];
		if (DL_GETPOFFSET(npp) != DL_GETPOFFSET(opp) ||
		    DL_GETPSIZE(npp) < DL_GETPSIZE(opp))
			return (EBUSY);
	}

	/* We did not modify the new label, so the checksum is OK. */
	*olp = *nlp;
	return (0);
}
@


1.21
log
@all disklabels read from the kernel now always contain a total sector
size which is the REAL DISK SIZE.  always.  if a driver fails to set
this right, please fix it.  agreed with otto and krw
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.20 2007/06/07 03:41:52 krw Exp $ */
d418 1
@


1.20
log
@Comment 'fixes'. All bounds_check_with_label now identical except for
vax and alpha.
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.19 2007/06/07 00:28:17 krw Exp $ */
d185 1
@


1.19
log
@More bounds_check_with_label homogenization. Fix a couple of typos while
there.

'so go to it!' deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.18 2007/06/06 22:14:29 deraadt Exp $ */
d332 1
a332 3
	/* overwriting disk label ? */
	/* XXX this assumes everything <=LABELSECTOR is label! */
	/*     But since LABELSECTOR is 0, that's ok for now. */
@


1.18
log
@clamp the disklabel d_secperunit to what the disk actually says it has,
not to what some bogus disklabel from the past may say (some of which
may have been caused by older openbsd disklabel programs).  resolves
issues seen by myself and Markus Lude on sparc/sparc64 machines
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.17 2007/06/06 16:42:06 deraadt Exp $ */
d305 2
d321 1
a321 1
			return (0);
d335 3
a337 2
	if (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) <= LABELSECTOR &&
	    (bp->b_flags & B_READ) == 0 && wlabel == 0) {
@


1.17
log
@a fair sprinking of knf, code movement, and sometimes character-by-character
accuracy so that the variious disksubr.c's can be compared easier.
setdisklabel() starts taking an int for openmask.
ok krw, and read by quite a few other people
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.16 2007/06/05 02:38:36 krw Exp $ */
d409 2
a410 1
	DL_SETDSIZE(lp, (daddr64_t)secpercyl * sl->sl_ncylinders);
@


1.16
log
@bounds_check_with_label() checks for i/o outside of the partition and
for overwriting the disklabel. Reorder some checks so all copies of
bounds_check_with_label do the checks in the same order. Order picked
by using the currently most popular one. Should be no functional
change.

"If it's boring, commit it" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.15 2007/06/05 00:38:16 deraadt Exp $ */
d40 1
a40 1
 *  	@@(#)ufs_disksubr.c	7.16 (Berkeley) 5/4/91
d115 2
a116 6
readdisklabel(dev, strat, lp, clp, spoofonly)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *clp;
	int spoofonly;
d185 1
a185 1
			*lp = *dlp; 	/* struct assignment */
d217 2
a218 4
setdisklabel(olp, nlp, openmask, clp)
	struct disklabel *olp, *nlp;
	u_long openmask;
	struct cpu_disklabel *clp;
d262 2
a263 5
writedisklabel(dev, strat, lp, clp)
	dev_t dev;
	void (*strat)(struct buf *);
	struct disklabel *lp;
	struct cpu_disklabel *clp;
d271 1
a271 1
	*dlp = *lp; 	/* struct assignment */
d286 1
a286 1
	bp->b_flags |= B_WRITE;
d376 1
a376 3
disklabel_om_to_bsd(cp, lp)
	char *cp;
	struct disklabel *lp;
d473 1
a473 3
disklabel_bsd_to_om(lp, cp)
	struct disklabel *lp;
	char *cp;
@


1.15
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.14 2007/06/02 02:35:27 krw Exp $ */
a321 9
	/* overwriting disk label ? */
	/* XXX this assumes everything <=LABELSECTOR is label! */
	/*     But since LABELSECTOR is 0, that's ok for now. */
	if (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp) <= LABELSECTOR &&
	    (bp->b_flags & B_READ) == 0 && wlabel == 0) {
		bp->b_error = EROFS;
		goto bad;
	}

d337 9
@


1.14
log
@Rename cvtdisklabelv1 -> disklabeltokernlabel. It does more than just
convert version 0 to version 1 disklabels.

Suggested by deraadt@@.

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.13 2007/05/31 19:57:43 krw Exp $ */
d131 2
a132 2
	if (lp->d_secperunit == 0)
		lp->d_secperunit = 0x1fffffff;
d139 2
a140 2
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
d142 3
a144 3
	if (lp->d_partitions[i].p_size == 0)
		lp->d_partitions[i].p_size = lp->d_secperunit;
	lp->d_partitions[i].p_offset = 0;
d252 2
a253 2
		if (npp->p_offset != opp->p_offset ||
		    npp->p_size < opp->p_size)
d325 1
a325 1
	if (bp->b_blkno + blockpersec(p->p_offset, lp) <= LABELSECTOR &&
d332 2
a333 2
	if (bp->b_blkno + sz > blockpersec(p->p_size, lp)) {
		sz = blockpersec(p->p_size, lp) - bp->b_blkno;
d349 1
a349 1
	bp->b_cylinder = (bp->b_blkno + blockpersec(p->p_offset, lp)) /
d420 1
a420 1
	lp->d_secperunit = secpercyl * sl->sl_ncylinders;
d439 3
a441 3
		npp->p_offset = spp->sdkp_cyloffset * secpercyl;
		npp->p_size = spp->sdkp_nsectors;
		if (npp->p_size == 0)
d467 1
a467 1
	if (sl->sl_rpm == 0 && lp->d_partitions[2].p_offset != 0) {
d516 2
a517 2
		spp->sdkp_cyloffset = npp->p_offset;	/* UniOS */
		spp->sdkp_nsectors = npp->p_size;
@


1.13
log
@KNF, whitespace and comment rectification to make all
bounds_check_with_label() routines as identical as possible without
changing any code. Code nits and adjustments to come.
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.12 2007/05/29 06:28:15 otto Exp $ */
d211 1
a211 1
	cvtdisklabelv1(lp);
@


1.12
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.11 2007/05/29 05:08:20 krw Exp $ */
d309 2
a310 5
bounds_check_with_label(bp, lp, osdep, wlabel)
	struct buf *bp;
	struct disklabel *lp;
	struct cpu_disklabel *osdep;
	int wlabel;
d335 1
a335 1
			/* if exactly at end of disk, return an EOF */
d340 1
d344 1
a344 1
		/* or truncate if part of it fits */
@


1.11
log
@Refactor readdisklabel() to ensure there is a single point of return, in
preparation for translating all disk labels visible to the kernel to
the soon to arrive V1 format.

ok otto@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.10 2006/10/04 03:23:01 krw Exp $ */
d211 1
d457 2
a458 2
				npp->p_fsize = 1024;
				npp->p_frag = 8;
@


1.10
log
@More tidying up after bad144. Remove references in comments and
don't include dkbad.h when nothing in it is used. Missed
arm/include/disklabel.h first time around.
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.9 2006/08/17 10:34:14 krw Exp $ */
d122 1
a122 1
	struct buf *bp;
d125 1
d133 4
a136 2
	if (lp->d_secpercyl == 0)
		return ("invalid geometry");
d148 1
a148 1
		return (NULL);
d167 4
a170 4
	bp->b_flags = B_INVAL | B_AGE | B_READ;
	brelse(bp);
	if (error)
		return ("disk label read error");
d173 4
a176 2
	if (iso_disklabelspoof(dev, strat, lp) == 0)
		return (NULL);
d179 4
a182 2
	if (udf_disklabelspoof(dev, strat, lp) == 0)
		return (NULL);
d190 2
a191 1
			return (NULL);
d199 2
a200 1
		return (disklabel_om_to_bsd(clp->cd_block, lp));
d204 9
a212 1
	return ("no disk label");
@


1.9
log
@Check d_secpercyl in all readdisklable() functions, and have all of
them return 'invalid geometry' when d_secpercyl == 0. While there move
the check to a consistant location (after the check of d_secperunit)
and use a consistant idiom (i.e. some readdisklabel()'s have no 'done'
label).

prodded by thib@@ after a bad macppc experience. ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.8 2006/06/11 14:08:36 krw Exp $ */
a52 1
#include <sys/dkbad.h>
@


1.8
log
@Zero the size of the correct partition. Missed in previous cleanup.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.7 2006/03/15 20:20:39 miod Exp $ */
d133 2
@


1.7
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.6 2006/01/26 07:11:08 miod Exp $ */
d140 1
a140 1
	lp->d_partitions[0].p_offset = 0;
@


1.6
log
@Switch to __HAVE_DEVICE_REGISTER to find the device we're booted from.
Tested by aoyama@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.5 2006/01/22 00:11:33 miod Exp $ */
a338 7
}

void
dk_establish(dk, dev)
        struct disk *dk;
        struct device *dev;
{
@


1.5
log
@Put various divide-by-zero checks as found in other disksubr routines; also
a few sylistic changes from sparc and mvme88k.
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.4 2005/03/30 07:52:31 deraadt Exp $ */
a54 5
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <machine/autoconf.h>

a101 1
void get_autoboot_device(void);
a340 50
/*
 * Get 'auto-boot' information from NVRAM
 */
struct autoboot_t
{
	char	cont[16];
	int	targ;
	int	part;
} autoboot;

char *nvram_by_symbol(char *);			/* in machdep.c */

void
get_autoboot_device(void)
{
	char *value, c;
	int i, len, part;

	/* Assume default controler is internal spc (spc0) */
	strlcpy(autoboot.cont, "spc0", sizeof(autoboot.cont));

	/* Get boot controler and SCSI target from NVRAM */
	value = nvram_by_symbol("boot_unit");
	if (value != NULL) {
		len = strlen(value);
		if (len == 1) {
			c = value[0];
		} else if (len == 2) {
			if (value[0] == '1') {
				/* External spc (spc1) */
				strlcpy(autoboot.cont, "spc1", sizeof(autoboot.cont));
				c = value[1];
			}
		}

		if ((c >= '0') && (c <= '6'))
			autoboot.targ = 6 - (c - '0');
	}

	/* Get partition number from NVRAM */
	value = nvram_by_symbol("boot_partition");
	if (value != NULL) {
		len = strlen(value);
		part = 0;
		for (i = 0; i < len; i++)
			part = part * 10 + (value[i] - '0');
		autoboot.part = part;
	}
}

a345 24
        struct scsibus_softc *sbsc;
	struct device *spcsc;
        int target, lun;

        /*
         * scsi: sd,cd  XXX: Can LUNA88K boot from CD-ROM?
         */

        if (strncmp("sd", dev->dv_xname, 2) == 0 ||
            strncmp("cd", dev->dv_xname, 2) == 0) {

                sbsc = (struct scsibus_softc *)dev->dv_parent;
		spcsc = dev->dv_parent->dv_parent;
                target = autoboot.targ;
                lun = 0;

                if (strncmp(autoboot.cont, spcsc->dv_xname, 4) == 0 &&
		    sbsc->sc_link[target][lun] != NULL &&
                    sbsc->sc_link[target][lun]->device_softc == (void *)dev) {
                        bootdv = dev;
			bootpart = autoboot.part;
                        return;
                }
        }
@


1.4
log
@first approximation:  spoof UDF filesystem disklabels when we see them.
it is likely a slight bug or two will sneak in with this, so everyone
please keep an eye out on your disklabels
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.3 2005/03/29 16:35:59 miod Exp $ */
d132 1
a132 1
	int error;
d134 3
a136 1
	/* minimal requirements for archtypal disk label */
d139 7
a145 3
	lp->d_npartitions = 1;
	if (lp->d_partitions[0].p_size == 0)
		lp->d_partitions[0].p_size = 0x1fffffff;
d160 1
a160 1
	bp->b_flags |= B_READ;
d169 1
d265 1
a265 1
	/* implant NetBSD disklabel at LABELOFFSET. */
d302 9
a310 6
	struct partition *p;
	int sz, maxsz;

	p = lp->d_partitions + DISKPART(bp->b_dev);
	maxsz = p->p_size;
	sz = (bp->b_bcount + DEV_BSIZE - 1) >> DEV_BSHIFT;
d313 4
a316 5
	/* XXX should also protect bootstrap in first 8K */
	/* XXX PR#2598: labelsect is always sector zero. */
	if (((bp->b_blkno + p->p_offset) <= LABELSECTOR) &&
	    ((bp->b_flags & B_READ) == 0) && (wlabel == 0))
	{
d322 4
a325 3
	if (bp->b_blkno < 0 || bp->b_blkno + sz > maxsz) {
		/* if exactly at end of disk, return an EOF */
		if (bp->b_blkno == maxsz) {
d329 1
a329 3
		/* or truncate if part of it fits */
		sz = maxsz - bp->b_blkno;
		if (sz <= 0) {
d333 1
d338 2
a339 1
	bp->b_cylinder = (bp->b_blkno + p->p_offset) / lp->d_secpercyl;
@


1.3
log
@Plug iso_disklabelspoof() in readdisklabel(); requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.2 2004/06/14 12:57:02 aoyama Exp $ */
d169 4
@


1.2
log
@Added some codes that check if the machine is LUNA-88K or LUNA-88K2
and retrieve the boot device information from NVRAM.
Only works on LUNA-88K2 at this moment.
@
text
@d1 1
a1 1
/* $OpenBSD: disksubr.c,v 1.1.1.1 2004/04/21 15:23:59 aoyama Exp $ */
d166 5
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d55 5
d107 1
d328 50
a382 1
#if 0 /* taken from OpenBSD/mvme88k */
d384 1
a386 3
        if (bootpart == -1) /* ignore flag from controller driver? */
                return;

d388 1
a388 1
         * scsi: sd,cd
d395 2
a396 1
                target = get_target(); /* Work the Motorola Magic */
d398 3
a400 2
    
                if (sbsc->sc_link[target][lun] != NULL &&
d403 1
a406 1
#endif
@


1.1.2.1
log
@Merge with the trunk
@
text
@@


1.1.1.1
log
@Initial commit for OpenBSD/luna88k, based on OpenBSD/mvme88k, NetBSD/luna68k and CMU Mach.
@
text
@@
