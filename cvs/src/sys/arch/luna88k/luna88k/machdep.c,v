head	1.125;
access;
symbols
	OPENBSD_6_1:1.123.0.4
	OPENBSD_6_1_BASE:1.123
	OPENBSD_6_0:1.120.0.2
	OPENBSD_6_0_BASE:1.120
	OPENBSD_5_9:1.118.0.2
	OPENBSD_5_9_BASE:1.118
	OPENBSD_5_8:1.117.0.4
	OPENBSD_5_8_BASE:1.117
	OPENBSD_5_7:1.116.0.2
	OPENBSD_5_7_BASE:1.116
	OPENBSD_5_6:1.108.0.4
	OPENBSD_5_6_BASE:1.108
	OPENBSD_5_5:1.94.0.4
	OPENBSD_5_5_BASE:1.94
	OPENBSD_5_4:1.88.0.2
	OPENBSD_5_4_BASE:1.88
	OPENBSD_5_3:1.86.0.2
	OPENBSD_5_3_BASE:1.86
	OPENBSD_5_2:1.81.0.2
	OPENBSD_5_2_BASE:1.81
	OPENBSD_5_1_BASE:1.80
	OPENBSD_5_1:1.80.0.2
	OPENBSD_5_0:1.78.0.2
	OPENBSD_5_0_BASE:1.78
	OPENBSD_4_9:1.75.0.2
	OPENBSD_4_9_BASE:1.75
	OPENBSD_4_8:1.72.0.2
	OPENBSD_4_8_BASE:1.72
	OPENBSD_4_7:1.69.0.2
	OPENBSD_4_7_BASE:1.69
	OPENBSD_4_6:1.64.0.4
	OPENBSD_4_6_BASE:1.64
	OPENBSD_4_5:1.61.0.2
	OPENBSD_4_5_BASE:1.61
	OPENBSD_4_4:1.58.0.2
	OPENBSD_4_4_BASE:1.58
	OPENBSD_4_3:1.56.0.2
	OPENBSD_4_3_BASE:1.56
	OPENBSD_4_2:1.44.0.2
	OPENBSD_4_2_BASE:1.44
	OPENBSD_4_1:1.37.0.2
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	SMP:1.5.0.2
	LUNA88K_INIT:1.1.1.1
	AOYAMA:1.1.1;
locks; strict;
comment	@ * @;


1.125
date	2017.05.29.14.19.50;	author mpi;	state Exp;
branches;
next	1.124;
commitid	4u6PWvBw90PH7UDq;

1.124
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.123;
commitid	2Gtqjzrin9LL2yHk;

1.123
date	2017.03.19.10.57.29;	author miod;	state Exp;
branches;
next	1.122;
commitid	VsXOX1rAnPUup9UH;

1.122
date	2017.01.13.09.18.11;	author fcambus;	state Exp;
branches;
next	1.121;
commitid	C556oRR1TXBPfD4D;

1.121
date	2016.10.09.11.25.40;	author tom;	state Exp;
branches;
next	1.120;
commitid	DfYvEDcFmu1LY9q1;

1.120
date	2016.07.16.08.53.37;	author tom;	state Exp;
branches;
next	1.119;
commitid	k7UhQ5FCwMJC7iLG;

1.119
date	2016.06.13.23.51.58;	author dlg;	state Exp;
branches;
next	1.118;
commitid	pePIrytkQAoqTKCZ;

1.118
date	2015.10.21.07.59.18;	author mpi;	state Exp;
branches;
next	1.117;
commitid	XglPgGQ8qaiL0M4l;

1.117
date	2015.05.18.04.06.37;	author miod;	state Exp;
branches;
next	1.116;
commitid	SUgrahEkzVbDqUaz;

1.116
date	2015.02.25.17.41.22;	author miod;	state Exp;
branches;
next	1.115;
commitid	SPD70tGdBh1CAdeU;

1.115
date	2014.12.23.10.59.29;	author aoyama;	state Exp;
branches;
next	1.114;
commitid	2ueaWreZdRNn1ptm;

1.114
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.113;
commitid	qHQiR2HLROzvZr7B;

1.113
date	2014.10.05.02.12.19;	author aoyama;	state Exp;
branches;
next	1.112;
commitid	RHpgL4LGiuGEVelB;

1.112
date	2014.10.04.13.02.13;	author aoyama;	state Exp;
branches;
next	1.111;
commitid	fCMRzUdGKnW0D3gA;

1.111
date	2014.10.03.20.47.41;	author aoyama;	state Exp;
branches;
next	1.110;
commitid	1dDZncQRwvABbmHf;

1.110
date	2014.09.27.19.50.10;	author aoyama;	state Exp;
branches;
next	1.109;
commitid	KaZSgFYBPSUmnKiq;

1.109
date	2014.09.20.09.28.24;	author kettenis;	state Exp;
branches;
next	1.108;
commitid	IFRB8AkvBMXMTAKW;

1.108
date	2014.07.21.17.25.47;	author uebayasi;	state Exp;
branches;
next	1.107;
commitid	7QO4UJr3EKVAMc8t;

1.107
date	2014.07.13.22.53.39;	author uebayasi;	state Exp;
branches;
next	1.106;
commitid	wsdp3qtXGjMj98oD;

1.106
date	2014.07.13.22.13.07;	author uebayasi;	state Exp;
branches;
next	1.105;
commitid	qYPOd6Qi4aRBKldK;

1.105
date	2014.07.10.21.46.03;	author mpi;	state Exp;
branches;
next	1.104;
commitid	iYq3Z1ZWDKR3sS9G;

1.104
date	2014.07.10.20.37.42;	author uebayasi;	state Exp;
branches;
next	1.103;
commitid	3BJjMGXrqlV6GGra;

1.103
date	2014.07.10.20.15.27;	author uebayasi;	state Exp;
branches;
next	1.102;
commitid	YzvTa4t6mddz7Mh4;

1.102
date	2014.07.10.13.34.32;	author uebayasi;	state Exp;
branches;
next	1.101;
commitid	xpsLTYRIkonFtkr1;

1.101
date	2014.07.10.12.13.49;	author uebayasi;	state Exp;
branches;
next	1.100;
commitid	aofvn6ceiucgjg4N;

1.100
date	2014.05.31.15.49.28;	author mpi;	state Exp;
branches;
next	1.99;
commitid	eA4Y0YE1IUzj6hpW;

1.99
date	2014.05.30.13.46.16;	author mpi;	state Exp;
branches;
next	1.98;

1.98
date	2014.05.08.22.17.33;	author miod;	state Exp;
branches;
next	1.97;

1.97
date	2014.04.22.22.58.02;	author aoyama;	state Exp;
branches;
next	1.96;

1.96
date	2014.04.12.11.26.42;	author aoyama;	state Exp;
branches;
next	1.95;

1.95
date	2014.03.13.03.52.55;	author dlg;	state Exp;
branches;
next	1.94;

1.94
date	2014.01.19.12.45.35;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2013.11.02.23.10.29;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2013.11.02.17.49.19;	author miod;	state Exp;
branches;
next	1.91;

1.91
date	2013.10.17.08.02.16;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2013.09.28.12.40.30;	author miod;	state Exp;
branches;
next	1.89;

1.89
date	2013.08.10.07.42.58;	author miod;	state Exp;
branches;
next	1.88;

1.88
date	2013.06.11.16.42.09;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2013.06.03.16.55.21;	author guenther;	state Exp;
branches;
next	1.86;

1.86
date	2013.02.17.18.07.36;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2012.12.26.22.32.13;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2012.10.21.09.51.59;	author miod;	state Exp;
branches;
next	1.83;

1.83
date	2012.10.18.17.45.09;	author miod;	state Exp;
branches;
next	1.82;

1.82
date	2012.10.08.21.47.48;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2012.02.28.13.40.53;	author aoyama;	state Exp;
branches;
next	1.80;

1.80
date	2012.01.28.11.34.19;	author aoyama;	state Exp;
branches;
next	1.79;

1.79
date	2012.01.08.01.26.37;	author aoyama;	state Exp;
branches;
next	1.78;

1.78
date	2011.06.26.22.39.59;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2011.06.05.19.41.07;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2011.05.30.22.25.21;	author oga;	state Exp;
branches;
next	1.75;

1.75
date	2011.01.05.22.20.22;	author miod;	state Exp;
branches;
next	1.74;

1.74
date	2011.01.02.13.39.38;	author miod;	state Exp;
branches;
next	1.73;

1.73
date	2010.12.31.21.38.08;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2010.06.27.12.41.23;	author miod;	state Exp;
branches;
next	1.71;

1.71
date	2010.06.27.03.03.48;	author thib;	state Exp;
branches;
next	1.70;

1.70
date	2010.06.09.15.44.17;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2009.08.30.12.11.33;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2009.08.11.19.17.16;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2009.08.11.18.46.32;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.65;

1.65
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.64;

1.64
date	2009.06.15.17.01.26;	author beck;	state Exp;
branches;
next	1.63;

1.63
date	2009.06.03.21.30.19;	author beck;	state Exp;
branches;
next	1.62;

1.62
date	2009.04.19.17.56.13;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2009.02.16.22.55.03;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2009.02.04.17.19.17;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2008.12.30.05.33.17;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2008.06.27.17.22.14;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2008.04.09.16.58.10;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2008.01.23.16.37.56;	author jsing;	state Exp;
branches;
next	1.55;

1.55
date	2008.01.13.20.20.29;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2007.12.31.09.23.53;	author martin;	state Exp;
branches;
next	1.53;

1.53
date	2007.12.17.05.23.49;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2007.11.17.05.37.53;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2007.11.17.05.36.23;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2007.11.17.05.32.05;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2007.11.15.21.23.15;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.14.23.12.45;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2007.11.06.21.42.56;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2007.10.13.12.55.21;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2007.10.10.15.53.52;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.06.17.15.12;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.29.20.36.47;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.27.17.31.56;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.26.20.26.50;	author pedro;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.12.20.03.25;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.12.20.02.14;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.12.19.59.02;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2007.02.09.14.26.09;	author aoyama;	state Exp;
branches;
next	1.36;

1.36
date	2007.01.12.21.41.53;	author aoyama;	state Exp;
branches;
next	1.35;

1.35
date	2006.11.18.22.58.25;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.10.30.14.46.35;	author aoyama;	state Exp;
branches;
next	1.33;

1.33
date	2006.05.15.21.40.04;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.08.14.36.09;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.08.14.03.34;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.11.21.36.04;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.04.15.00.23;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.04.12.20.17;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.03.14.30.05;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.01.22.14.52;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.28.22.21.12;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.13.19.48.32;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.12.19.05.39;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.25.20.30.03;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.01.15.42.46;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.01.09.55.49;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.30.16.42.33;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.27.14.09.45;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.09.15.02.19;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.08.16.39.31;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.03.19.47.25;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.01.05.49.00;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.30.14.55.51;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.30.09.20.46;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.08.30.13.10.32;	author aoyama;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.24.12.59.51;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.18.13.29.46;	author aoyama;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.28.12.28.48;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.01.13.37.53;	author aoyama;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.14.12.57.02;	author aoyama;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.02.13.49.43;	author miod;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2004.05.10.10.30.24;	author aoyama;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.07.15.08.25;	author aoyama;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.04.15.27.15;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.21.15.24.08;	author aoyama;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.04.21.15.24.08;	author aoyama;	state Exp;
branches;
next	;

1.5.2.1
date	2004.06.05.23.09.47;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.125
log
@Kill SPINLOCK_SPIN_HOOK, use CPU_BUSY_CYCLE() instead.

ok visa@@, kettenis@@
@
text
@/*	$OpenBSD: machdep.c,v 1.124 2017/04/30 16:45:45 mpi Exp $	*/
/*
 * Copyright (c) 1998, 1999, 2000, 2001 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Nivas Madhur.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
/*
 * Mach Operating System
 * Copyright (c) 1993-1991 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/mount.h>
#include <sys/msgbuf.h>
#include <sys/syscallargs.h>
#include <sys/exec.h>
#include <sys/sysctl.h>
#include <sys/errno.h>
#include <sys/extent.h>
#include <sys/core.h>
#include <sys/kcore.h>
#include <dev/rndvar.h>

#include <machine/asm.h>
#include <machine/asm_macro.h>
#include <machine/board.h>
#include <machine/cmmu.h>
#include <machine/cpu.h>
#include <machine/kcore.h>
#include <machine/reg.h>
#include <machine/trap.h>
#include <machine/m88100.h>

#include <luna88k/luna88k/isr.h>

#include <dev/cons.h>

#include <net/if.h>
#include <uvm/uvm.h>

#include "ksyms.h"
#if DDB
#include <machine/db_machdep.h>
#include <ddb/db_extern.h>
#include <ddb/db_interface.h>
#include <ddb/db_output.h>		/* db_printf()		*/
#endif /* DDB */

void	consinit(void);
#ifdef MULTIPROCESSOR
void	cpu_boot_secondary_processors(void);
#endif
void	cpu_setup_secondary_processors(void);
void	dumpconf(void);
void	dumpsys(void);
int	getcpuspeed(void);
void	get_fuse_rom_data(void);
void	get_nvram_data(void);
void	identifycpu(void);
void	luna88k_bootstrap(void);
#ifdef MULTIPROCESSOR
void	luna88k_ipi_handler(struct trapframe *);
#endif
struct cpu_info *luna88k_set_cpu_number(cpuid_t);
void	luna88k_vector_init(uint32_t *, uint32_t *);
char	*nvram_by_symbol(char *);
void	powerdown(void);
void	savectx(struct pcb *);
void	secondary_main(void);
void   *secondary_pre_main(void);
void	setlevel(u_int);
vaddr_t size_memory(void);

extern int	clockintr(void *);		/* in clock.c */
extern void	get_autoboot_device(void);	/* in autoconf.c */

u_int32_t int_set_val[INT_LEVEL] = {
	INT_SET_LV0,
	INT_SET_LV1,
	INT_SET_LV2,
	INT_SET_LV3,
	INT_SET_LV4,
	INT_SET_LV5,
	INT_SET_LV6,
	INT_SET_LV7
};

/*
 * FUSE ROM and NVRAM data
 */
struct fuse_rom_byte {
	u_int32_t h;
	u_int32_t l;
};
#define FUSE_ROM_BYTES        (FUSE_ROM_SPACE / sizeof(struct fuse_rom_byte))
char fuse_rom_data[FUSE_ROM_BYTES];

#define NNVSYM		8
#define NVSYMLEN	16
#define NVVALLEN	16
struct nvram_t {
	char symbol[NVSYMLEN];
	char value[NVVALLEN];
} nvram[NNVSYM];

register_t kernel_vbr;
int physmem;	  /* available physical memory, in pages */

struct vm_map *exec_map = NULL;
struct vm_map *phys_map = NULL;

__cpu_simple_lock_t cpu_hatch_mutex = __SIMPLELOCK_UNLOCKED;
#ifdef MULTIPROCESSOR
__cpu_simple_lock_t cpu_boot_mutex = __SIMPLELOCK_LOCKED;
unsigned int hatch_pending_count;
vaddr_t hatch_stacks[MAXCPUS - 1];
#endif

struct uvm_constraint_range  dma_constraint = { 0x0, (paddr_t)-1 };
struct uvm_constraint_range *uvm_md_constraints[] = { NULL };

/*
 * Info for CTL_HW
 */
char  machine[] = MACHINE;	 /* cpu "architecture" */
char  cpu_model[120];

#if defined(DDB) || NKSYMS > 0
extern char *esym;
#endif

int machtype = LUNA_88K;	/* may be overwritten in cpu_startup() */
int cputyp = CPU_88100;
int bootdev;			/* XXX: should be set in boot loader and locore.S */
int cpuspeed = 33;		/* safe guess */
int sysconsole = 1;		/* 0 = ttya, 1 = keyboard/mouse, used in dev/sio.c */
u_int16_t dipswitch = 0;	/* set in locore.S */
int hwplanebits;		/* set in locore.S */

extern struct consdev syscons;	/* in dev/siotty.c */

extern void syscnattach(int);	/* in dev/siotty.c */
extern int omfb_cnattach(void);	/* in dev/lunafb.c */
extern void ws_cnattach(void);	/* in dev/lunaws.c */

vaddr_t first_addr;
vaddr_t last_addr;

extern struct user *proc0paddr;

/*
 * This is to fake out the console routines, while booting.
 * We could use directly the romtty console, but we want to be able to
 * configure a kernel without romtty since we do not necessarily need a
 * full-blown console driver.
 */
cons_decl(romtty);
extern void nullcnpollc(dev_t, int);

struct consdev romttycons = {
	NULL, 
	NULL, 
	romttycngetc, 
	romttycnputc,
	nullcnpollc,
	NULL,
	makedev(14, 0),
	CN_LOWPRI,
};

struct consdev *cn_tab = &romttycons;

/*
 * Early console initialization: called early on from main, before vm init.
 */
void
consinit()
{
	/*
	 * Initialize the console before we print anything out.
	 */
	if (sysconsole == 0) {
                syscnattach(0);
        } else {
                omfb_cnattach();
                ws_cnattach();
        }

#if defined(DDB)
	db_machine_init();
	ddb_init();
	if (boothowto & RB_KDB)
		db_enter();
#endif
}

/*
 * Figure out how much real memory is available.
 * Start looking from the megabyte after the end of the kernel data,
 * until we find non-memory.
 */
vaddr_t
size_memory()
{
	unsigned int *volatile look;
	unsigned int *max;
#define PATTERN   0x5a5a5a5a
#define STRIDE    (4*1024) 	/* 4k at a time */
#define Roundup(value, stride) (((unsigned)(value) + (stride) - 1) & ~((stride)-1))
	/*
	 * count it up.
	 */
	max = (void *)MAXPHYSMEM;
	for (look = (void *)first_addr; look < max;
	    look = (int *)((unsigned)look + STRIDE)) {
		unsigned save;

		/* if can't access, we've reached the end */
		if (badaddr((vaddr_t)look, 4)) {
			look = (int *)((int)look - STRIDE);
			break;
		}

		/*
		 * If we write a value, we expect to read the same value back.
		 * We'll do this twice, the 2nd time with the opposite bit
		 * pattern from the first, to make sure we check all bits.
		 */
		save = *look;
		if (*look = PATTERN, *look != PATTERN)
			break;
		if (*look = ~PATTERN, *look != ~PATTERN)
			break;
		*look = save;
	}

	return (trunc_page((vaddr_t)look));
}

int
getcpuspeed()
{
	switch(machtype) {
	case LUNA_88K:
		return 25;
	case LUNA_88K2:
		return 33;
	default:
		panic("getcpuspeed: can not determine CPU speed");
	}
}

void
identifycpu()
{
	cpuspeed = getcpuspeed();
	snprintf(cpu_model, sizeof cpu_model,
	    "OMRON LUNA-88K%s, %dMHz", 
	    machtype == LUNA_88K2 ? "2" : "", cpuspeed);
}

void
cpu_startup()
{
	vaddr_t minaddr, maxaddr;

	/* Determine the machine type from FUSE ROM data.  */
	get_fuse_rom_data();
	if (strncmp(fuse_rom_data, "MNAME=LUNA88K+", 14) == 0) {
		machtype = LUNA_88K2;
	}

        /* Determine the 'auto-boot' device from NVRAM data */
        get_nvram_data();
        get_autoboot_device();

	/*
	 * Good {morning,afternoon,evening,night}.
	 */
	printf(version);
	identifycpu();
	printf("real mem = %lu (%luMB)\n", ptoa(physmem),
	    ptoa(physmem) / 1024 / 1024);

	/*
	 * Check front DIP switch setting
	 */
#ifdef DEBUG
	printf("dipsw = 0x%x\n", dipswitch);
#endif

	/* Check DIP switch 1 - 1 */
	if ((0x8000 & dipswitch) == 0) {
		boothowto |= RB_SINGLE;
	}

	/* Check DIP switch 1 - 3 */
	if ((0x2000 & dipswitch) == 0) {
		boothowto |= RB_ASKNAME;
	}

	/* Check DIP switch 1 - 4 */
	if ((0x1000 & dipswitch) == 0) {
		boothowto |= RB_CONFIG;
	}

	/*
	 * Check frame buffer depth.
	 */
	switch (hwplanebits) {
	case 0:				/* No frame buffer */
	case 1:
	case 4:
	case 8:
		break;
	default:
		printf("unexpected frame buffer depth = %d\n", hwplanebits);
		hwplanebits = 0;
		break;
	}

	/*
	 * Allocate a submap for exec arguments.  This map effectively
	 * limits the number of processes exec'ing at any time.
	 */
	minaddr = vm_map_min(kernel_map);
	exec_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    16 * NCARGS, VM_MAP_PAGEABLE, FALSE, NULL);

	/*
	 * Allocate map for physio.
	 */
	phys_map = uvm_km_suballoc(kernel_map, &minaddr, &maxaddr,
	    VM_PHYS_SIZE, 0, FALSE, NULL);

	printf("avail mem = %lu (%luMB)\n", ptoa(uvmexp.free),
	    ptoa(uvmexp.free) / 1024 / 1024);

	/*
	 * Set up buffers, so they can be used to read disk labels.
	 */
	bufinit();

	/*
	 * Initialize the autovectored interrupt list.
	 */
	isrinit();

	/*
	 * Configure the system.
	 */
	if (boothowto & RB_CONFIG) {
#ifdef BOOT_CONFIG
		user_config();
#else
		printf("kernel does not support -c; continuing..\n");
#endif
	}
}

__dead void
boot(int howto)
{
	if (curproc && curproc->p_addr)
		savectx(curpcb);

	if (cold) {
		if ((howto & RB_USERREQ) == 0)
			howto |= RB_HALT;
		goto haltsys;
	}

	boothowto = howto;
	if ((howto & RB_NOSYNC) == 0) {
		vfs_shutdown();

		if ((howto & RB_TIMEBAD) == 0) {
			resettodr();
		} else {
			printf("WARNING: not updating battery clock\n");
		}
	}
	if_downall();

	uvm_shutdown();
	splhigh();
	cold = 1;

	if ((howto & RB_DUMP) != 0)
		dumpsys();

haltsys:
	config_suspend_all(DVACT_POWERDOWN);

	/* LUNA-88K supports automatic powerdown */
	if ((howto & RB_POWERDOWN) != 0) {
		printf("attempting to power down...\n");
		powerdown();
		/* if failed, fall through. */
	}

	if ((howto & RB_HALT) != 0) {
		printf("halted\n\n");
	} else {
		/* Reset all cpus, which causes reboot */
		*((volatile uint32_t *)RESET_CPU_ALL) = 0;
	}

	for (;;)
		continue;
	/* NOTREACHED */
}

u_long dumpmag = 0x8fca0101;	 /* magic number for savecore */
int   dumpsize = 0;	/* also for savecore */
long  dumplo = 0;
cpu_kcore_hdr_t cpu_kcore_hdr;

/*
 * This is called by configure to set dumplo and dumpsize.
 * Dumps always skip the first PAGE_SIZE of disk space
 * in case there might be a disk label stored there.
 * If there is extra space, put dump at the end to
 * reduce the chance that swapping trashes it.
 */
void
dumpconf(void)
{
	int nblks;	/* size of dump area */

	if (dumpdev == NODEV ||
	    (nblks = (bdevsw[major(dumpdev)].d_psize)(dumpdev)) == 0)
		return;
	if (nblks <= ctod(1))
		return;

	dumpsize = physmem;

	/* luna88k only uses a single segment. */
	cpu_kcore_hdr.ram_segs[0].start = 0;
	cpu_kcore_hdr.ram_segs[0].size = ptoa(physmem);
	cpu_kcore_hdr.cputype = cputyp;

	/*
	 * Don't dump on the first block
	 * in case the dump device includes a disk label.
	 */
	if (dumplo < ctod(1))
		dumplo = ctod(1);

	/* Put dump at end of partition, and make it fit. */
	if (dumpsize + 1 > dtoc(nblks - dumplo))
		dumpsize = dtoc(nblks - dumplo) - 1;
	if (dumplo < nblks - ctod(dumpsize) - 1)
		dumplo = nblks - ctod(dumpsize) - 1;
}

/*
 * Doadump comes here after turning off memory management and
 * getting on the dump stack, either when called above, or by
 * the auto-restart code.
 */
void
dumpsys()
{
	int maj;
	int psize;
	daddr_t blkno;	/* current block to write */
				/* dump routine */
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
	int pg;			/* page being dumped */
	paddr_t maddr;		/* PA being dumped */
	int error;		/* error code from (*dump)() */
	kcore_seg_t *kseg_p;
	cpu_kcore_hdr_t *chdr_p;
	char dump_hdr[dbtob(1)];	/* XXX assume hdr fits in 1 block */

	extern int msgbufmapped;

	msgbufmapped = 0;

	/* Make sure dump device is valid. */
	if (dumpdev == NODEV)
		return;
	if (dumpsize == 0) {
		dumpconf();
		if (dumpsize == 0)
			return;
	}
	maj = major(dumpdev);
	if (dumplo < 0) {
		printf("\ndump to dev %u,%u not possible\n", maj,
		    minor(dumpdev));
		return;
	}
	dump = bdevsw[maj].d_dump;
	blkno = dumplo;

	printf("\ndumping to dev %u,%u offset %ld\n", maj,
	    minor(dumpdev), dumplo);

	/* Setup the dump header */
	kseg_p = (kcore_seg_t *)dump_hdr;
	chdr_p = (cpu_kcore_hdr_t *)&dump_hdr[ALIGN(sizeof(*kseg_p))];
	bzero(dump_hdr, sizeof(dump_hdr));

	CORE_SETMAGIC(*kseg_p, KCORE_MAGIC, MID_MACHINE, CORE_CPU);
	kseg_p->c_size = dbtob(1) - ALIGN(sizeof(*kseg_p));
	*chdr_p = cpu_kcore_hdr;

	printf("dump ");
	psize = (*bdevsw[maj].d_psize)(dumpdev);
	if (psize == -1) {
		printf("area unavailable\n");
		return;
	}

	/* Dump the header. */
	error = (*dump)(dumpdev, blkno++, (caddr_t)dump_hdr, dbtob(1));
	if (error != 0)
		goto abort;

	maddr = (paddr_t)0;
	for (pg = 0; pg < dumpsize; pg++) {
#define NPGMB	(1024 * 1024 / PAGE_SIZE)
		/* print out how many MBs we have dumped */
		if (pg != 0 && (pg % NPGMB) == 0)
			printf("%d ", pg / NPGMB);
#undef NPGMB
		error = (*dump)(dumpdev, blkno, (caddr_t)maddr, PAGE_SIZE);
		if (error == 0) {
			maddr += PAGE_SIZE;
			blkno += btodb(PAGE_SIZE);
		} else
			break;
	}
abort:
	switch (error) {
	case 0:
		printf("succeeded\n");
		break;

	case ENXIO:
		printf("device bad\n");
		break;

	case EFAULT:
		printf("device not ready\n");
		break;

	case EINVAL:
		printf("area improper\n");
		break;

	case EIO:
		printf("i/o error\n");
		break;

	case EINTR:
		printf("aborted from console\n");
		break;

	default:
		printf("error %d\n", error);
		break;
	}
}

/*
 * Release cpu_hatch_mutex to let secondary processors initialize.
 */
void
cpu_setup_secondary_processors()
{
#ifdef MULTIPROCESSOR
	unsigned int cpu;

	hatch_pending_count = ncpusfound - 1;

	/*
	 * Allocate idle stack for all the secondary processors here.
	 *
	 * We can't have this done by the secondaries themselves, because
	 * the main processor owns the kernel lock at this point; and we
	 * can't know in advance which cpuid our secondary processors will
	 * have, so we can't fill m88k_cpus[] directly.
	 *
	 * Allocation failure will be checked by the secondary processors
	 * so that we can still run in degraded mode if hell gets loose.
	 */
	for (cpu = 0; cpu < hatch_pending_count; cpu++)
		hatch_stacks[cpu] = uvm_km_zalloc(kernel_map, USPACE);
#endif

	__cpu_simple_unlock(&cpu_hatch_mutex);

#ifdef MULTIPROCESSOR
	while (hatch_pending_count != 0)
		delay(10000);	/* 10ms */
#endif
}

struct cpu_info *
luna88k_set_cpu_number(cpuid_t number)
{
	struct cpu_info *ci;

	/* clock register for each CPU. */
	static const uint32_t clock_ack[] = {
		OBIO_CLOCK0,
		OBIO_CLOCK1,
		OBIO_CLOCK2,
		OBIO_CLOCK3
	};

	/* hardware interrupt mask and status register for each CPU.
	 *
	 * When written to:
	 * Bits 31 to 26 are used to enable ('1') or disable ('0') each
	 * interrupt level.  Bit 31 is for level 6, bit 26 is for level 1.
	 * 
	 * When read:
	 * Bits 31 to 29 shows the highest level of current (or most recent?)
	 * interrupt in 3 bits binary value (0 to 7).
	 * Bits 23 to 18 shows the current mask, which is the most recent
	 * written value in bits 31 to 26 as described above.
	 */
	static const uint32_t intr_mask[] = {
		INT_ST_MASK0,
		INT_ST_MASK1,
		INT_ST_MASK2,
		INT_ST_MASK3
	};

	/* software interrupt register for each CPU. */
	static const uint32_t swi_reg[] = {
		SOFT_INT0,
		SOFT_INT1,
		SOFT_INT2,
		SOFT_INT3
	};

	ci = set_cpu_number(number);
	ci->ci_curspl = IPL_HIGH;
	ci->ci_swireg = swi_reg[number];
	ci->ci_intr_mask = intr_mask[number];
	ci->ci_clock_ack = clock_ack[number];
	return ci;
}

#ifdef MULTIPROCESSOR
/*
 * Release cpu_boot_mutex to let secondary processors start running
 * processes.
 */
void
cpu_boot_secondary_processors()
{
	__cpu_simple_unlock(&cpu_boot_mutex);
}

/*
 * Secondary CPU early initialization routine.
 * Determine CPU number and set it, then return the startup stack.
 *
 * Running on a minimal stack here, with interrupts disabled; do nothing fancy.
 */
void *
secondary_pre_main()
{
	struct cpu_info *ci;

        /*
         * Invoke the CMMU initialization routine as early as possible,
         * so that we do not risk any memory writes to be lost during
         * cache setup.
         */
        cmmu_initialize_cpu(cmmu_cpu_number());

	/*
	 * Now initialize your cpu_info structure.
	 */
	ci = luna88k_set_cpu_number(cmmu_cpu_number());
	ci->ci_curproc = &proc0;
	m88100_smp_setup(ci);

	splhigh();

	/*
	 * Enable MMU on this processor.
	 */
	pmap_bootstrap_cpu(ci->ci_cpuid);

	/*
	 * Return our idle stack for the caller to switch to it.
	 */
	ci->ci_curpcb = (void *)hatch_stacks[hatch_pending_count - 1];
	if (ci->ci_curpcb == NULL) {
		printf("cpu%d: unable to get startup stack\n", ci->ci_cpuid);
		hatch_pending_count--;
		__cpu_simple_unlock(&cpu_hatch_mutex);
		for (;;)
			continue;
		/* NOTREACHED */
	}

	return ci->ci_curpcb;
}

/*
 * Further secondary CPU initialization.
 *
 * We are now running on our startup stack, with proper page tables.
 * There is nothing to do but display some details about the CPU and its CMMUs.
 */

void
secondary_main()
{
	struct cpu_info *ci = curcpu();
	int s;

	cpu_configuration_print(0);
	ncpus++;

	sched_init_cpu(ci);
	nanouptime(&ci->ci_schedstate.spc_runtime);
	ci->ci_curproc = NULL;
	ci->ci_randseed = (arc4random() & 0x7fffffff) + 1;

	/*
	 * Release cpu_hatch_mutex to let other secondary processors
	 * have a chance to run.
	 */
	hatch_pending_count--;
	__cpu_simple_unlock(&cpu_hatch_mutex);

	/* wait for cpu_boot_secondary_processors() */
	__cpu_simple_lock(&cpu_boot_mutex);
	__cpu_simple_unlock(&cpu_boot_mutex);

	set_vbr(kernel_vbr);

	spl0();
	SCHED_LOCK(s);
	set_psr(get_psr() & ~PSR_IND);

	SET(ci->ci_flags, CIF_ALIVE);

	cpu_switchto(NULL, sched_chooseproc());
}

#endif	/* MULTIPROCESSOR */

/*
 *	Device interrupt handler for LUNA-88K
 */

void 
luna88k_ext_int(struct trapframe *eframe)
{
	struct cpu_info *ci = curcpu();
	uint32_t cur_isr;
	u_int level, cur_int_level, old_spl;
	int unmasked = 0;

	cur_isr = *(volatile uint32_t *)ci->ci_intr_mask;
	old_spl = eframe->tf_mask;

	cur_int_level = cur_isr >> 29;

	/*
	 * Ignore level 0 interrupt and 'hardware lied' interrupt,
	 * as same as CMU Mach do.  The 'hardware lied' means that
	 * the received interrupt level is what we have masked before.
	 */
	if (cur_int_level == 0 ||
	    !(cur_isr & (1 << (cur_int_level + 17))))
		goto out;

	uvmexp.intrs++;

#ifdef MULTIPROCESSOR
	/*
	 * Handle unmaskable IPIs immediately, so that we can reenable
	 * interrupts before further processing. We rely on the interrupt
	 * mask to make sure that if we get an IPI, it's really for us
	 * and no other processor.
	 * 
	 * On luna88k, IPL_SOFTINT (level 1 interrupt) is used as IPI.
	 */
	while (cur_int_level == IPL_SOFTINT) {
		luna88k_ipi_handler(eframe);

		cur_isr = *(volatile uint32_t *)ci->ci_intr_mask;
		cur_int_level = cur_isr >> 29;
	}
	if (cur_int_level == 0)
		goto out;
#endif

	/*
	 * Service the highest interrupt, in order.
	 */
	do {
		level = (cur_int_level > old_spl ? cur_int_level : old_spl);
		setipl(level);

		if (unmasked == 0) {
			set_psr(get_psr() & ~PSR_IND);
			unmasked = 1;
		}

		switch (cur_int_level) {
		case 6:
			clockintr((void *)eframe);
			break;
		case 5:
		case 4:
		case 3:
			if (CPU_IS_PRIMARY(ci))
				isrdispatch_autovec(cur_int_level);
			break;
		default:
			printf("%s: cpu%d level %d interrupt.\n",
				__func__, ci->ci_cpuid, cur_int_level);
			break;
		}

		cur_isr = *(volatile uint32_t *)ci->ci_intr_mask;
		cur_int_level = cur_isr >> 29;
	} while (cur_int_level != 0);

out:
	/*
	 * process any remaining data access exceptions before
	 * returning to assembler
	 */
	if (eframe->tf_dmt0 & DMT_VALID)
		m88100_trap(T_DATAFLT, eframe);

	/*
	 * Disable interrupts before returning to assembler, the spl will
	 * be restored later.
	 */
	set_psr(get_psr() | PSR_IND);
}

int
sys_sysarch(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
#if 0
	struct sys_sysarch_args	/* {
	   syscallarg(int) op;
	   syscallarg(char *) parm;
	} */ *uap = v;
#endif

	return (ENOSYS);
}

/*
 * machine dependent system variables.
 */

int
cpu_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	dev_t consdev;

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR); /* overloaded */

	switch (name[0]) {
	case CPU_CONSDEV:
		if (cn_tab != NULL)
			consdev = cn_tab->cn_dev;
		else
			consdev = NODEV;
		return (sysctl_rdstruct(oldp, oldlenp, newp, &consdev,
		    sizeof consdev));
	case CPU_CPUTYPE:
		return (sysctl_rdint(oldp, oldlenp, newp, cputyp));
	default:
		return (EOPNOTSUPP);
	}
	/*NOTREACHED*/
}

void
luna88k_vector_init(uint32_t *bootvbr, uint32_t *vectors)
{
	extern vaddr_t vector_init(uint32_t *, uint32_t *, int); /* gross */
	extern int kernelstart;

	/*
	 * Set up bootstrap vectors, overwriting the existing PROM vbr
	 * page.
	 */
	vector_init(bootvbr, vectors, 1);

	/*
	 * Set up final vectors. These will be used by all processors,
	 * once autoconf is over.
	 */
	kernel_vbr = trunc_page((vaddr_t)&kernelstart);
	vector_init((uint32_t *)kernel_vbr, vectors, 0);
}

/*
 * Called from locore.S during boot,
 * this is the first C code that's run.
 */
void
luna88k_bootstrap()
{
	extern const struct cmmu_p cmmu8820x;
	extern vaddr_t avail_start;
	extern vaddr_t avail_end;
#ifndef MULTIPROCESSOR
	cpuid_t master_cpu;
#endif

	cmmu = &cmmu8820x;

	/* clear and disable all interrupts */
	*(volatile uint32_t *)INT_ST_MASK0 =
	*(volatile uint32_t *)INT_ST_MASK1 =
	*(volatile uint32_t *)INT_ST_MASK2 =
	*(volatile uint32_t *)INT_ST_MASK3 = 0;

	/* clear software interrupts; just read registers */
	*(volatile uint32_t *)SOFT_INT0;
	*(volatile uint32_t *)SOFT_INT1;
	*(volatile uint32_t *)SOFT_INT2;
	*(volatile uint32_t *)SOFT_INT3;

	uvmexp.pagesize = PAGE_SIZE;
	uvm_setpagesize();

	first_addr = round_page(first_addr);
	last_addr = size_memory();
	physmem = atop(last_addr);

	setup_board_config();
	master_cpu = cmmu_init();
	(void)luna88k_set_cpu_number(master_cpu);
#ifdef MULTIPROCESSOR
	m88100_smp_setup(curcpu());
#endif
	SET(curcpu()->ci_flags, CIF_ALIVE | CIF_PRIMARY);

	m88100_apply_patches();

	/*
	 * Now that set_cpu_number() set us with a valid cpu_info pointer,
	 * we need to initialize p_addr and curpcb before autoconf, for the
	 * fault handler to behave properly [except for badaddr() faults,
	 * which can be taken care of without a valid curcpu()].
	 */
	proc0.p_addr = proc0paddr;
	curproc = &proc0;
	curpcb = &proc0paddr->u_pcb;

	avail_start = first_addr;
	avail_end = last_addr;

#ifdef DEBUG
	printf("LUNA-88K boot: memory from 0x%x to 0x%x\n",
	    avail_start, avail_end);
#endif

	/*
	 * Tell the VM system about available physical memory.
	 * luna88k only has one segment.
	 */
	uvm_page_physload(atop(avail_start), atop(avail_end),
	    atop(avail_start), atop(avail_end), 0);

	/*
	 * Initialize message buffer.
	 */
	initmsgbuf((caddr_t)pmap_steal_memory(MSGBUFSIZE, NULL, NULL),
	    MSGBUFSIZE);

	pmap_bootstrap(0, 0x20000);	/* ROM needs 128KB */

	/* Initialize the "u-area" pages. */
	bzero((caddr_t)curpcb, USPACE);

#ifndef MULTIPROCESSOR
	/* Release the cpu_hatch_mutex */
	cpu_setup_secondary_processors();
#endif

#ifdef DEBUG
	printf("leaving luna88k_bootstrap()\n");
#endif
}

/*
 * Rom console routines: 
 * Enables printing of boot messages before consinit().
 */

#define __ROM_FUNC_TABLE	((int **)0x00001100)
#define ROMGETC()	(*(int (*)(void))__ROM_FUNC_TABLE[3])()
#define ROMPUTC(x)	(*(void (*)(int))__ROM_FUNC_TABLE[4])(x)

void
romttycnprobe(cp)
	struct consdev *cp;
{
	cp->cn_dev = makedev(14, 0);
	cp->cn_pri = CN_LOWPRI;
}

void
romttycninit(cp)
	struct consdev *cp;
{
	/* Nothing to do */
}

int
romttycngetc(dev)
	dev_t dev;
{
	int s, c;

	do {
		s = splhigh();
		c = ROMGETC();
		splx(s);
	} while (c == -1);
	return c;
}

void
romttycnputc(dev, c)
	dev_t dev;
	int c;
{
	int s;

	s = splhigh();
	ROMPUTC(c);
	splx(s);
}

/* powerdown */

struct pio {
	volatile u_int8_t portA;
	volatile unsigned : 24;
	volatile u_int8_t portB;
	volatile unsigned : 24;
	volatile u_int8_t portC;
	volatile unsigned : 24;
	volatile u_int8_t cntrl;
	volatile unsigned : 24;
};

#define	PIO1_POWER	0x04

#define	PIO1_ENABLE	0x01
#define	PIO1_DISABLE	0x00

void
powerdown(void) 
{
	struct pio *p1 = (struct pio *)OBIO_PIO1_BASE;

	DELAY(100000);
	p1->cntrl = (PIO1_POWER << 1) | PIO1_DISABLE;
	*(volatile u_int8_t *)&p1->portC;
}

/* Get data from FUSE ROM */

void
get_fuse_rom_data(void)
{
	int i;
	struct fuse_rom_byte *p = (struct fuse_rom_byte *)FUSE_ROM_ADDR;

	for (i = 0; i < FUSE_ROM_BYTES; i++) {
		fuse_rom_data[i] =
		    (char)((((p->h) >> 24) & 0x000000f0) |
		           (((p->l) >> 28) & 0x0000000f));
		p++;                                                                            
	}
}

/* Get data from NVRAM */

void
get_nvram_data(void)
{
	int i, j;
	u_int8_t *page;
	char buf[NVSYMLEN], *data;

	if (machtype == LUNA_88K) {
		data = (char *)(NVRAM_ADDR + 0x80);

		for (i = 0; i < NNVSYM; i++) {
			for (j = 0; j < NVSYMLEN; j++) {
				buf[j] = *data;
				data += 4;
			}
			strlcpy(nvram[i].symbol, buf, sizeof(nvram[i].symbol));

			for (j = 0; j < NVVALLEN; j++) {
				buf[j] = *data;
				data += 4;
			}
			strlcpy(nvram[i].value, buf, sizeof(nvram[i].value));
		}
	} else if (machtype == LUNA_88K2) {
		page = (u_int8_t *)(NVRAM_ADDR_88K2 + 0x20);

		for (i = 0; i < NNVSYM; i++) {
			*page = (u_int8_t)i;

			data = (char *)NVRAM_ADDR_88K2;
			strlcpy(nvram[i].symbol, data, sizeof(nvram[i].symbol));

			data = (char *)(NVRAM_ADDR_88K2 + 0x10);
			strlcpy(nvram[i].value, data, sizeof(nvram[i].value));
		}
	}
}

char *
nvram_by_symbol(symbol)
	char *symbol;
{
	char *value;
	int i;

	value = NULL;

	for (i = 0; i < NNVSYM; i++) {
		if (strncmp(nvram[i].symbol, symbol, NVSYMLEN) == 0) {
			value = nvram[i].value;
			break;
		}
	}

	return value;
}

void
setlevel(u_int level)
{
	u_int32_t set_value;
	struct cpu_info *ci = curcpu();

	set_value = int_set_val[level];

#ifdef MULTIPROCESSOR
	if (!CPU_IS_PRIMARY(ci))
		set_value &= INT_SLAVE_MASK;
#endif

	ci->ci_curspl = level;
	*(volatile uint32_t *)ci->ci_intr_mask = set_value;
	/*
	 * We do not flush the pipeline here, because we are invoked
	 * with interrupts disabled, and the caller will synchronize
	 * the pipeline when restoring the psr.
	 */
}

int
getipl(void)
{
	return (int)curcpu()->ci_curspl;
}

int
setipl(int level)
{
	int curspl;
	uint32_t psr;
	struct cpu_info *ci = curcpu();

	psr = get_psr();
	set_psr(psr | PSR_IND);

	curspl = (int)ci->ci_curspl;
	setlevel((u_int)level);

	set_psr(psr);
	return curspl;
}

int
splraise(int level)
{
	int curspl;
	uint32_t psr;
	struct cpu_info *ci = curcpu();

	psr = get_psr();
	set_psr(psr | PSR_IND);

	curspl = (int)ci->ci_curspl;
	if (curspl < (u_int)level)
		setlevel((u_int)level);

	set_psr(psr);
	return curspl;
}

#ifdef MULTIPROCESSOR
void
m88k_send_ipi(int ipi, cpuid_t cpu)
{
	struct cpu_info *ci = &m88k_cpus[cpu];

	if (ci->ci_ipi & ipi)
		return;

	atomic_setbits_int(&ci->ci_ipi, ipi);
	*(volatile uint32_t *)ci->ci_swireg = ~0;
}

/*
 * Process inter-processor interrupts.
 */

/*
 * Unmaskable IPIs - those are processed with interrupts disabled,
 * and no lock held.
 */
void
luna88k_ipi_handler(struct trapframe *eframe)
{
	struct cpu_info *ci = curcpu();
	int ipi = ci->ci_ipi & (CI_IPI_DDB | CI_IPI_NOTIFY);

	/* just read; reset software interrupt */
	*(volatile uint32_t *)ci->ci_swireg;
	atomic_clearbits_int(&ci->ci_ipi, ipi);

	if (ipi & CI_IPI_DDB) {
#ifdef DDB
		/*
		 * Another processor has entered DDB. Spin on the ddb lock
		 * until it is done.
		 */
		extern struct __mp_lock ddb_mp_lock;

		__mp_lock(&ddb_mp_lock);
		__mp_unlock(&ddb_mp_lock);

		/*
		 * If ddb is hoping to us, it's our turn to enter ddb now.
		 */
		if (ci->ci_cpuid == ddb_mp_nextcpu)
			db_enter();
#endif
	}
	if (ipi & CI_IPI_NOTIFY) {
		/* nothing to do */
	}
}

void
m88k_broadcast_ipi(int ipi)
{
	struct cpu_info *us = curcpu();
	struct cpu_info *ci;
	CPU_INFO_ITERATOR cii;

	CPU_INFO_FOREACH(cii, ci) {
		if (ci == us)
			continue;

		if (ISSET(ci->ci_flags, CIF_ALIVE))
			m88k_send_ipi(ipi, ci->ci_cpuid);
	}
}
#endif
@


1.124
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.123 2017/03/19 10:57:29 miod Exp $	*/
a86 1
#include <machine/lock.h>
@


1.123
log
@Put the address of the per-cpu clock and interrupt registers into the cpu_info
struct, rather than fetching them from arrays every time they are needed.

ok aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.122 2017/01/13 09:18:11 fcambus Exp $	*/
d251 1
a251 1
		Debugger();
d1326 1
a1326 1
			Debugger();
@


1.122
log
@Ansify cpu_sysctl() on alpha, arm, arm64, luna88k and sparc64.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.121 2016/10/09 11:25:40 tom Exp $	*/
d122 1
a134 23
/*
 * *int_mask_reg[CPU]
 * Points to the hardware interrupt status register for each CPU.
 *
 * When write:
 * Bits 31 to 26 are used to enable ('1') or disable ('0') each
 * interrupt level.  Bit 31 is for level 6, bit 26 is for level 1.
 * 
 * When read:
 * Bits 31 to 29 shows the highest level of current (or most recent?)
 * interrupt in 3 bits binary value (0 to 7).
 * Bits 23 to 18 shows the current mask, which is the most recent
 * written value in bits 31 to 26 as described above.
 */
volatile u_int32_t *int_mask_reg[] = {
	(u_int32_t *)INT_ST_MASK0,
	(u_int32_t *)INT_ST_MASK1,
	(u_int32_t *)INT_ST_MASK2,
	(u_int32_t *)INT_ST_MASK3
};

u_int luna88k_curspl[] = { IPL_HIGH, IPL_HIGH, IPL_HIGH, IPL_HIGH };

a146 11
 * *swi_reg[CPU]
 * Points to the software interrupt register for each CPU.
 */
volatile u_int32_t *swi_reg[] = {
	(u_int32_t *)SOFT_INT0,
	(u_int32_t *)SOFT_INT1,
	(u_int32_t *)SOFT_INT2,
	(u_int32_t *)SOFT_INT3
};

/*
d464 1
a464 1
		*((volatile unsigned *)0x6d000010) = 0;
d661 48
d741 1
a741 2
	set_cpu_number(cmmu_cpu_number());
	ci = curcpu();
a819 1
#ifdef MULTIPROCESSOR
d821 1
a821 5
	u_int cpu = ci->ci_cpuid;
#else
	u_int cpu = cpu_number();
#endif
	u_int32_t cur_isr;
d825 1
a825 1
	cur_isr = *int_mask_reg[cpu];
d853 1
a853 1
		cur_isr = *int_mask_reg[cpu];
d884 1
a884 1
				__func__, cpu, cur_int_level);
d888 1
a888 1
		cur_isr = *int_mask_reg[cpu];
d990 4
a993 2
	*int_mask_reg[0] = *int_mask_reg[1] =
	*int_mask_reg[2] = *int_mask_reg[3] = 0;
d996 4
a999 4
	*(volatile uint32_t *)swi_reg[0];
	*(volatile uint32_t *)swi_reg[1];
	*(volatile uint32_t *)swi_reg[2];
	*(volatile uint32_t *)swi_reg[3];
d1010 1
a1010 1
	set_cpu_number(master_cpu);
a1220 1
#ifdef MULTIPROCESSOR
a1221 4
	int cpu = ci->ci_cpuid;
#else
	int cpu = cpu_number();
#endif
d1230 2
a1231 2
	luna88k_curspl[cpu] = level;
	*int_mask_reg[cpu] = set_value;
d1242 1
a1242 1
	return (int)luna88k_curspl[cpu_number()];
d1248 2
a1249 2
	u_int curspl, psr;
#ifdef MULTIPROCESSOR
a1250 4
	int cpu = ci->ci_cpuid;
#else
	int cpu = cpu_number();
#endif
d1255 1
a1255 1
	curspl = luna88k_curspl[cpu];
d1259 1
a1259 1
	return (int)curspl;
d1265 2
a1266 2
	u_int curspl, psr;
#ifdef MULTIPROCESSOR
a1267 4
	int cpu = ci->ci_cpuid;
#else
	int cpu = cpu_number();
#endif
d1272 1
a1272 1
	curspl = luna88k_curspl[cpu];
d1277 1
a1277 1
	return (int)curspl;
d1290 1
a1290 1
	*swi_reg[cpu] = 0xffffffff;
a1304 1
	int cpu = ci->ci_cpuid;
d1308 1
a1308 1
	*swi_reg[cpu];
@


1.121
log
@Apply consistency to forever loops with continue and NOTREACHED

Same thought from kettenis@@, ok krw@@ phessler@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.120 2016/07/16 08:53:37 tom Exp $	*/
d919 2
a920 8
cpu_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
@


1.120
log
@Fix typo in comment in three machdep.c files:

s/names are this level/names at this level/

from aalm@@ - thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.119 2016/06/13 23:51:58 dlg Exp $	*/
d500 2
a501 1
	for (;;) ;
d746 3
a748 1
		for (;;) ;
@


1.119
log
@rename raiseipl to splraise()

another step toward making splraise an MI api.

ok aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.118 2015/10/21 07:59:18 mpi Exp $	*/
d927 1
a927 1
	/* all sysctl names are this level are terminal */
@


1.118
log
@Do not call uvm_swap_finicrypt_all() a second time in dumpsys().

ok tedu@@, deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.117 2015/05/18 04:06:37 miod Exp $	*/
d1264 1
a1264 1
raiseipl(int level)
@


1.117
log
@Move the logic deciding whether to grab the kernel lock or not, deeper in the
interrupt logic, making sure the lock is not taken for clock interrupts.
Tested on aviion and luna88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.116 2015/02/25 17:41:22 miod Exp $	*/
a590 4

#ifdef UVM_SWAP_ENCRYPT
	uvm_swap_finicrypt_all();
#endif
@


1.116
log
@Rework secondary processor initialization, in order to allocate their idle
stack from the main processor, instead of from the secondary processors
themselves. This used to work until recent churn in uvm require the kernel
lock to be taken, and cpu_configure() runs with the kernel lock held by the
boot processor.

Allocating the idle stack on the secondary processors themselves was choosen
early on, because there is no easy way, from the boot processor, to know the
assocation between physical cpu number (ci_cpuid) and logical cpu number
(the order they are initialized and reported in), especially on luna88k where
there is no way to get secondary processors parked by the prom.

Regression noticed by aoyama@@. Verified to work on 2 and 4 cpu luna88k systems
and 2 cpu aviion systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.115 2014/12/23 10:59:29 aoyama Exp $	*/
d871 1
a871 5
#ifdef MULTIPROCESSOR
			if (CPU_IS_PRIMARY(ci)) {
				if (old_spl < IPL_SCHED)
					__mp_lock(&kernel_lock);
#endif
a872 5
#ifdef MULTIPROCESSOR
				if (old_spl < IPL_SCHED)
					__mp_unlock(&kernel_lock);
			}
#endif
@


1.115
log
@We do not need to grab the kernel lock for clock interrupts on luna88k,
as same as aviion.

suggested and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.114 2014/12/10 15:29:53 mikeb Exp $	*/
d127 1
a127 1
vaddr_t	secondary_pre_main(void);
d206 2
a207 1
int hatch_pending_count;
d670 2
d673 14
d688 1
d690 1
d710 1
a710 1
 * Determine CPU number and set it, then allocate the startup stack.
d714 1
a714 1
vaddr_t
a717 1
	vaddr_t init_stack;
d742 1
a742 1
	 * Allocate UPAGES contiguous pages for the idle PCB and stack.
d744 3
a746 4
	init_stack = uvm_km_zalloc(kernel_map, USPACE);
	if (init_stack == (vaddr_t)NULL) {
		printf("cpu%d: unable to allocate startup stack\n",
		    ci->ci_cpuid);
d752 1
a752 1
	return (init_stack);
@


1.114
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.113 2014/10/05 02:12:19 aoyama Exp $	*/
a834 4
#ifdef MULTIPROCESSOR
	if (old_spl < IPL_SCHED)
		__mp_lock(&kernel_lock);
#endif
d856 2
d861 2
a874 5

#ifdef MULTIPROCESSOR
	if (old_spl < IPL_SCHED)
		__mp_unlock(&kernel_lock);
#endif
@


1.113
log
@Use CPU_IS_PRIMARY macro.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.112 2014/10/04 13:02:13 aoyama Exp $	*/
a482 1
	doshutdownhooks();
@


1.112
log
@Skip 'hardware lied' interrupts, as same as CMU Mach do.

Also add more comments on *int_mask_reg[CPU], delete possibly
unnecessary flush_pipeline().

Additional suggestion and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.111 2014/10/03 20:47:41 aoyama Exp $	*/
d860 1
a860 1
			if (cpu == master_cpu) {
d1225 1
a1225 1
	if (cpu != master_cpu)
@


1.111
log
@Delete long-time unused #if 0 part.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.110 2014/09/27 19:50:10 aoyama Exp $	*/
d137 10
d806 7
a812 5
	if (cur_int_level == 0) {
		/*
		 * ignore level 0 interrupt, as CMU Mach do.
		 */
		flush_pipeline();	/* need this? */
a813 1
	}
d832 1
a832 2
	if (cur_int_level == 0) {
		flush_pipeline();	/* need this? */
a833 1
	}
@


1.110
log
@Move clock_reg[] definition.

clock_reg[] is only used in clock.c, so move its definition from
machdep.c to clock.c.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.109 2014/09/20 09:28:24 kettenis Exp $	*/
a401 16
#if 0 /* just for test */
	/*
	 * Get boot arguments
	 */
	{
		char buf[256];
		char **p = (volatile char **)0x00001120;

		strncpy(buf, *p, 256);
		if (buf[255] != '\0')
			buf[255] = '\0';

		printf("boot arg: (0x%x) %s\n", *p, buf);
	}
#endif

a1093 4
#if 0
	if ((char)c == '\n')
		ROMPUTC('\r');
#endif
@


1.109
log
@Use config_suspend_all(9).

ok mpi@@, uebayasi@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.108 2014/07/21 17:25:47 uebayasi Exp $	*/
a166 11
};

/*
 * *clock_reg[CPU]
 * Points to the clock register for each CPU.
 */
volatile u_int32_t *clock_reg[] = {
	(u_int32_t *)OBIO_CLOCK0,
	(u_int32_t *)OBIO_CLOCK1,
	(u_int32_t *)OBIO_CLOCK2,
	(u_int32_t *)OBIO_CLOCK3
@


1.108
log
@boot(9): Reduce annoying style diffs

- Always use either: ((x & RB_XXX) != 0) or ((x & RB_XXX) == 0) in boolean
  context (mostly if (x), or x ? y : z)
  - prom_halt() in alpha is confirmed to take int as boolean

Converted by coccinelle.  No functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a470 2
	struct device *mainbus;

d501 1
a501 3
	mainbus = device_mainbus();
	if (mainbus != NULL)
		config_suspend(mainbus, DVACT_POWERDOWN);
@


1.107
log
@boot(9): Cosmetic changes to improve diff'ability.
@
text
@d498 1
a498 1
	if (howto & RB_DUMP)
d508 1
a508 1
	if ((howto & RB_POWERDOWN) == RB_POWERDOWN) {
d514 1
a514 1
	if (howto & RB_HALT) {
@


1.106
log
@Cosmetic changes to reduce diffs.
@
text
@d521 2
a522 2
	for (;;);  /* to keep compiler happy, and me from going crazy */
	/*NOTREACHED*/
@


1.105
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.104 2014/07/10 20:37:42 uebayasi Exp $	*/
d486 1
a486 1
		if ((howto & RB_TIMEBAD) == 0)
d488 1
a488 1
		else
d490 1
d495 1
a495 1
	splhigh();			/* Disable interrupts. */
a497 1
	/* If rebooting and a dump is requested, do it. */
@


1.104
log
@boot(9): More comment removal about cold/savectx() missed in previous
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d495 1
@


1.103
log
@boot(9): Remove comments about RB_*, "cold", and savectx()

Again remove slightly different comments to reduce diffs.  These will be
re-added once boot() become MI and its specification is clearly re-defined.

OK miod@@
@
text
@a472 1
	/* take a snapshot before clobbering any registers */
@


1.102
log
@boot(): Remove comments about RB_TIMEBAD to reduce diffs

RB_TIMEBAD is documented well enough that the comment is not needed.  sparc64
does slightly different and its comment is left with XXX.

OK deraadt@@ miod@@
@
text
@a476 1
	/* If system is cold, just halt. */
a477 1
		/* (Unless the user explicitly asked for reboot.) */
@


1.101
log
@boot(): Unify declarations

OK deraadt@@
@
text
@d488 1
a488 5
		/*
		 * If we've been adjusting the clock, the todr
		 * will be out of synch; adjust it now unless
		 * the system was sitting in ddb.
		 */
@


1.100
log
@Revert previous diff setting cold to 1 on shutdown because it breaks machine
with softraid(4) disks.

softraid(4) is the last real consumer of the doshutdownhooks(9) API and it is
not trivial to convert its hook to a DVACT_POWERDOWN handler since the latter
does not allow to sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.99 2014/05/30 13:46:16 mpi Exp $	*/
d469 1
a469 2
boot(howto)
	int howto;
@


1.99
log
@Set cold to 1 before executing the DVACT_POWERDOWN handlers when halting or
rebooting a machine, like it is done in the hibernate case.

At least some USB host controller drivers rely on this to busy way instead
of sleeping.  Avoid a panic on macppc with an uhci(4) cardbus plugged in.

ok deraadt@@, uebayashi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.98 2014/05/08 22:17:33 miod Exp $	*/
a502 1
	cold = 1;
@


1.98
log
@Format string fixes for m88k; remove -Wno-format from the m88k kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.97 2014/04/22 22:58:02 aoyama Exp $	*/
d503 1
@


1.97
log
@Unify the model name to LUNA-88K{,2}, that is considered the
`official' name.

ok jmc@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.96 2014/04/12 11:26:42 aoyama Exp $	*/
d373 1
a373 1
	printf("real mem = %u (%uMB)\n", ptoa(physmem),
@


1.96
log
@Delete unused variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.95 2014/03/13 03:52:55 dlg Exp $	*/
d514 1
a514 1
	/* Luna88k supports automatic powerdown */
d813 1
a813 1
 *	Device interrupt handler for LUNA88K
d1055 1
a1055 1
	printf("LUNA88K boot: memory from 0x%x to 0x%x\n",
@


1.95
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.94 2014/01/19 12:45:35 deraadt Exp $	*/
d825 1
a825 1
	u_int32_t cur_isr, ign_mask;
a829 1
	ign_mask = 0;
@


1.94
log
@Initialize ci_randseed better using arc4random() + a trick.  Remove the
libkern srandom() API since it is not suitable for this use.
ok kettenis miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.93 2013/11/02 23:10:29 miod Exp $	*/
d472 2
d510 3
a512 2
	if (!TAILQ_EMPTY(&alldevs))
		config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.93
log
@Create the initial page tables in the area between the end of the firmware
data area and the kernel image, whenever possible.

On 88100/88200 systems, use BATC mappings to map the kernel text (and the
kernel data for non-MULTIPROCESSOR kernels). 88110 to follow soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.92 2013/11/02 17:49:19 miod Exp $	*/
d79 1
d783 1
a783 1
	ci->ci_randseed = random();
@


1.92
log
@Reserve a page at the beginning of the kernel text to use for the trap vectors,
and switch to it, on all processors, after autoconf is over. First step
towards being able to unmap the low memory and have address 0 non-accessible
in the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.91 2013/10/17 08:02:16 deraadt Exp $	*/
d1003 1
a1003 1
	vaddr_t avail_start;
@


1.91
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.90 2013/09/28 12:40:30 miod Exp $	*/
d121 1
d197 1
d795 2
d973 20
@


1.90
log
@In boot(), do not iterate over alldevs if it's empty (i.e. halting from ddb
with ddb entered early with boot -d or from UKC).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.89 2013/08/10 07:42:58 miod Exp $	*/
a916 9
}

int
cpu_exec_aout_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
{

	return (ENOEXEC);
@


1.89
log
@Initialize first_addr much earlier, in locore; this will help adding
symbols support in the not-so-distant future.
ok aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.88 2013/06/11 16:42:09 deraadt Exp $	*/
d505 2
a506 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_POWERDOWN);
@


1.88
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.87 2013/06/03 16:55:21 guenther Exp $	*/
a294 3
#if 0
	extern char *end;
#endif
a986 1
	extern char *end;
d1000 4
a1003 2
	*swi_reg[0]; *swi_reg[1];
	*swi_reg[2]; *swi_reg[3];
d1008 1
a1008 1
	first_addr = round_page((vaddr_t)&end);	/* XXX temp until symbols */
@


1.87
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.86 2013/02/17 18:07:36 miod Exp $	*/
d582 1
a582 1
	daddr64_t blkno;	/* current block to write */
d584 1
a584 1
	int (*dump)(dev_t, daddr64_t, caddr_t, size_t);
@


1.86
log
@Constify struct cmmu.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.85 2012/12/26 22:32:13 miod Exp $	*/
d780 1
a780 1
	microuptime(&ci->ci_schedstate.spc_runtime);
@


1.85
log
@Nuke commons.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.84 2012/10/21 09:51:59 miod Exp $	*/
d989 1
a989 1
	extern struct cmmu_p cmmu8820x;
@


1.84
log
@Needs <sys/device.h> now
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.83 2012/10/18 17:45:09 miod Exp $	*/
a221 1
int boothowto;			/* XXX: should be set in boot loader and locore.S */
a236 3
vaddr_t avail_start, avail_end;
vaddr_t virtual_avail, virtual_end;

d991 2
@


1.83
log
@Switch luna88k to timecounters; tested by aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.82 2012/10/08 21:47:48 deraadt Exp $	*/
d68 1
@


1.82
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.81 2012/02/28 13:40:53 aoyama Exp $	*/
a1122 26
}

/* taken from NetBSD/luna68k */
void
microtime(tvp)
        register struct timeval *tvp;
{
        int s = splclock();
        static struct timeval lasttime;

        *tvp = time;
#ifdef notdef
        tvp->tv_usec += clkread();
        while (tvp->tv_usec >= 1000000) {
                tvp->tv_sec++;
                tvp->tv_usec -= 1000000;
        }
#endif
        if (tvp->tv_sec == lasttime.tv_sec &&
            tvp->tv_usec <= lasttime.tv_usec &&
            (tvp->tv_usec = lasttime.tv_usec + 1) >= 1000000) {
                tvp->tv_sec++;
                tvp->tv_usec -= 1000000;
        }
        lasttime = *tvp;
        splx(s);
@


1.81
log
@Luna88k multi-processor support, step 3.

GENERIC.MP on luna88k is now stable.  Changes are:

- Make secondary processors boot sequence closer to OpenBSD/aviion.
  This makes boot sequence more stable.  Now we have not see any
  assertions or panics during boot.
- Implement IPI as level 1 hardware interrupt by using software
  interrupt register.
- Add IPI support and some clean-ups in interrupt handler function.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.80 2012/01/28 11:34:19 aoyama Exp $	*/
a509 1
	/* Run any shutdown hooks. */
d511 1
@


1.80
log
@Luna88k multi-processor support, step 2.

Modify secondary processor initialization and interrupt handler.

Now GENERIC.MP boots up more stable and runs userland binaries, but
inter-processor-interrupt is not implemented yet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.79 2012/01/08 01:26:37 aoyama Exp $	*/
d106 1
d108 2
d113 2
d117 5
d126 1
d128 2
a129 7
vaddr_t size_memory(void);
void powerdown(void);
void get_fuse_rom_data(void);
void get_nvram_data(void);
char *nvram_by_symbol(char *);
void get_autoboot_device(void);			/* in autoconf.c */
int clockintr(void *);				/* in clock.c */
d135 1
a135 1
u_int32_t *volatile int_mask_reg[] = {
d156 11
d168 1
d170 1
a170 1
u_int32_t *volatile clock_reg[] = {
d220 1
a220 1
int cputyp = CPU_88100;		/* XXX: aoyama */
d691 1
a691 2
 * Release the cpu_{hatch,boot}_mutex; secondary processors will now
 * have their chance to initialize.
d694 1
a694 1
cpu_boot_secondary_processors()
a699 1

a702 1
	__cpu_simple_unlock(&cpu_boot_mutex);
d707 9
d818 1
a818 1
	uint cpu = ci->ci_cpuid;
d822 3
a824 2
	u_int32_t cur_mask, cur_int;
	u_int level, old_spl;
d826 3
a828 3
	cur_mask = *int_mask_reg[cpu];
	old_spl = luna88k_curspl[cpu];
	eframe->tf_mask = old_spl;
d830 1
a830 1
	cur_int = cur_mask >> 29;
d832 1
a832 1
	if (cur_int == 0) {
d834 1
a834 2
		 * Spurious interrupts - may be caused by debug output clearing
		 * serial port interrupts.
d836 1
a836 4
#ifdef DEBUG
		printf("luna88k_ext_int(): Spurious interrupts?\n");
#endif
		flush_pipeline();
d839 1
a839 1
 
d842 8
a849 5
	/* 
	 * We want to service all interrupts marked in the IST register
	 * They are all valid because the mask would have prevented them
	 * from being generated otherwise.  We will service them in order of
	 * priority. 
d851 11
d867 3
a869 1
	/* XXX: This is very rough. Should be considered more. (aoyama) */
d871 2
a872 1
		level = (cur_int > old_spl ? cur_int : old_spl);
d874 3
a876 3
#ifdef DEBUG
		if (level > 7 || (char)level < 0) {
			panic("int level (%x) is not between 0 and 7", level);
a877 1
#endif
d879 2
a880 6
		setipl(level);
	  
		set_psr(get_psr() & ~PSR_IND);

		switch(cur_int) {
		case CLOCK_INT_LEVEL:
d889 1
a889 1
				isrdispatch_autovec(cur_int);
d895 2
a896 1
			printf("luna88k_ext_int(): level %d interrupt.\n", cur_int);
d900 3
a902 10
                cur_int = (*int_mask_reg[cpu]) >> 29;
#ifdef MULTIPROCESSOR
                if ((cpu != master_cpu) &&
		    (cur_int != CLOCK_INT_LEVEL) && (cur_int != 0)) {
			printf("cpu%d: cur_int=%d\n", cpu, cur_int);
			flush_pipeline();
			cur_int = 0;
		}
#endif
	} while (cur_int != 0);
d908 1
d1001 6
a1006 4
	*int_mask_reg[0] = 0;
	*int_mask_reg[1] = 0;
	*int_mask_reg[2] = 0;
	*int_mask_reg[3] = 0;
d1063 1
a1063 1
	cpu_boot_secondary_processors();
d1334 49
a1382 1
	/* XXX: not yet */
d1388 11
a1398 1
	/* XXX: not yet */
@


1.79
log
@Preliminary multi-processor support for luna88k.  It is
work-in-progress and is not stable yet...

"Please commit" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.78 2011/06/26 22:39:59 deraadt Exp $	*/
d182 5
a186 1
__cpu_simple_lock_t cpu_mutex = __SIMPLELOCK_UNLOCKED;
d673 2
a674 2
 * Release the cpu_mutex; secondary processors will now have their
 * chance to initialize.
d679 10
a688 1
	__cpu_simple_unlock(&cpu_mutex);
d734 2
a735 1
		__cpu_simple_unlock(&cpu_mutex);
d748 1
d763 10
a772 1
	__cpu_simple_unlock(&cpu_mutex);
d792 4
d797 1
d828 4
a864 1
	} while ((cur_int = (*int_mask_reg[cpu]) >> 29) != 0);
d866 15
d1032 1
a1032 1
	/* Release the cpu_mutex */
d1228 6
a1233 1
	u_int cpu = cpu_number();
d1261 6
d1270 2
a1271 1
	curspl = luna88k_curspl[cpu_number()];
d1273 1
d1282 6
d1291 2
a1292 1
	curspl = luna88k_curspl[cpu_number()];
d1295 1
d1304 1
a1304 1
	/* nothing to do on luna88k!? */
d1310 1
a1310 1
	/* nothing to do on luna88k!? */
@


1.78
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.77 2011/06/05 19:41:07 deraadt Exp $	*/
d122 1
a122 1
void get_autoboot_device(void);			/* in disksubr.c */
a285 3
#if 0
	for (look = (void *)Roundup(end, STRIDE); look < max;
#else
a286 1
#endif
a291 3
#if defined(DEBUG)
			printf("%x\n", look);
#endif
d690 8
d699 3
d704 4
d710 1
a710 1
	 * Setup CMMUs and translation tables (shared with the master cpu).
d721 1
a740 1
	sched_init_cpu(ci);
a741 1
	__cpu_simple_unlock(&cpu_mutex);
d743 1
d746 3
d750 2
a752 1
	spl0();
d754 2
a755 1
	SCHED_LOCK(s);
d768 1
a768 1
	int cpu = cpu_number();
d820 7
a826 1
			isrdispatch_autovec(cur_int);
a921 2
	extern void m8820x_initialize_cpu(cpuid_t);
	extern void m8820x_set_sapr(cpuid_t, apr_t);
d941 3
d984 1
d987 1
d1181 1
a1181 1
	int cpu = cpu_number();
d1231 14
@


1.77
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.76 2011/05/30 22:25:21 oga Exp $	*/
d94 1
d485 1
@


1.76
log
@Remove the freelist member from vm_physseg

The new world order of pmemrange makes this data completely redundant
(being dealt with by the pmemrange constraints instead). Remove all code
that messes with the freelist.

While touching every caller of uvm_page_physload() anyway, add the flags
argument to all callers (all but one is 0 and that one already used
PHYSLOAD_DEVICE) and remove the macro magic to allow callers to continue
without it.

Should shrink the code a bit, as well.

matthew@@ pointed out some mistakes i'd made.
``freelist death, I like. Ok.' ariane@@
`I agree with the general direction, go ahead and i'll fix any fallout
shortly'' miod@@ (68k 88k and vax i could not check would build)
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.75 2011/01/05 22:20:22 miod Exp $	*/
a181 14

/*
 * Declare these as initialized data so we can patch them.
 */
#ifndef BUFCACHEPERCENT
#define BUFCACHEPERCENT 5
#endif

#ifdef	BUFPAGES
int bufpages = BUFPAGES;
#else
int bufpages = 0;
#endif
int bufcachepercent = BUFCACHEPERCENT;
@


1.75
log
@Pass pmap_bootstrap() the memory range used by the PROM/BUG/firmware/whatever,
instead of assuming it is ``everything below the kernel image''.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.74 2011/01/02 13:39:38 miod Exp $	*/
d963 1
a963 1
	    atop(avail_start), atop(avail_end),VM_FREELIST_DEFAULT);
@


1.74
log
@Fix dump to work with PMAP_DIRECT, as done on mvme88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.73 2010/12/31 21:38:08 miod Exp $	*/
d971 1
a971 1
	pmap_bootstrap();
@


1.73
log
@Massive overhauling of the m88k pmap, though I can't pretend it's a new pmap
since a large part of the structures and logic remains.

Since m88k has separate supervisor/user spaces, we can map physical memory 1:1
in supervisor space, and have the kernel virtual address space start from the
end of physical memory.

This allows us to switch to __HAVE_PMAP_DIRECT. And to get rid of the double
mapped sdt, since now their virtual and physical addresses will always match.

The upper bound of the kernel virtual memory space is now platform dependent,
until the code which relies upon some hardware devices being mapped 1:1 in
supervisor mode is updated to no longer require this (this is mainly a PITA on
luna88k, where onboard devices start at 0x40000000, leaving only 1GB of KVA at
the moment - still much better than the previous 512MB).

Tested on mvme88k only (187, 188, 197LE, 197DP). Other platforms ought to
work, aviion will be checked shortly and fixed if necessary. No known
OpenBSD/luna88k system in working condition at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.72 2010/06/27 12:41:23 miod Exp $	*/
a356 1
	int i;
d648 1
a648 4
		pmap_enter(pmap_kernel(), (vaddr_t)vmmap, maddr,
		    VM_PROT_READ, VM_PROT_READ|PMAP_WIRED);

		error = (*dump)(dumpdev, blkno, vmmap, PAGE_SIZE);
a909 1
	extern int kernelstart;
a914 1
	cpuid_t cpu;
a975 12
	/*
	 * On the luna88k, secondary processors are not disabled while the
	 * kernel is initializing. We just initialized the CMMUs tied to the
	 * currently-running CPU; initialize the others with similar settings
	 * as well, after calling pmap_bootstrap() above.
	 */
	for (cpu = 0; cpu < ncpusfound; cpu++) {
		if (cpu == master_cpu)
			continue;
		m8820x_initialize_cpu(cpu);
		cmmu_set_sapr(kernel_pmap->pm_apr);
	}
@


1.72
log
@Bunch of include adjustements to restore compilability.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.71 2010/06/27 03:03:48 thib Exp $	*/
a175 2
vaddr_t obiova;

a359 10
	/*
	 * Initialize error message buffer (at end of core).
	 * avail_end was pre-decremented in luna88k_bootstrap() to compensate.
	 */
	for (i = 0; i < atop(MSGBUFSIZE); i++)
		pmap_kenter_pa((paddr_t)msgbufp + i * PAGE_SIZE,
		    avail_end + i * PAGE_SIZE, VM_PROT_READ | VM_PROT_WRITE);
	pmap_update(pmap_kernel());
	initmsgbuf((caddr_t)msgbufp, round_page(MSGBUFSIZE));

a431 11
	 * Grab the OBIO space that we hardwired in pmap_bootstrap
	 */
	obiova = OBIO_START;
	uvm_map(kernel_map, (vaddr_t *)&obiova, OBIO_SIZE,
	    NULL, UVM_UNKNOWN_OFFSET, 0,
	      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
	        UVM_ADV_NORMAL, UVM_FLAG_FIXED));
	if (obiova != OBIO_START)
		panic("obiova %lx: OBIO not free", obiova);

	/*
a958 5
	/*
	 * Steal MSGBUFSIZE at the top of physical memory for msgbuf
	 */
	avail_end -= round_page(MSGBUFSIZE);

a962 1
	pmap_bootstrap((vaddr_t)trunc_page((vaddr_t)&kernelstart));
d970 8
@


1.71
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.69 2009/08/30 12:11:33 miod Exp $	*/
d94 1
a94 2
#include <uvm/uvm_extern.h>
#include <uvm/uvm_swap.h>
@


1.70
log
@Move declaration of cn_tab from dev/cons.c to dev/cninit.c, or appropriate
md files for ports which do not use dev/cninit.c. This gets rid of a common
at kernel link time.
feedback drahn@@ ok deraadt@@
@
text
@d200 3
@


1.69
log
@Use UVM_FLAG_FIXED for fixed allocations make with uvm_map() during early
bootstrap.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.68 2009/08/11 19:17:16 miod Exp $	*/
d253 2
a935 1
	extern struct consdev *cn_tab;
a951 3

	/* startup fake console driver.  It will be replaced by consinit() */
	cn_tab = &romttycons;
@


1.68
log
@Do not bother initializing bufpages in the md code if the computation is
exactly the same the mi could will use if bufinit() is invoked with
bufpages == 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.67 2009/08/11 18:46:32 miod Exp $	*/
d446 1
a446 1
	        UVM_ADV_NORMAL, 0));
@


1.67
log
@With the SysV memory allocation changes, allocsys() doesn't do anything
anymore. Get rid of it completely.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.66 2009/08/09 10:40:17 blambert Exp $	*/
a448 7

	/*
	 * Determine how many buffers to allocate.
	 * We allocate bufcachepercent% of memory for buffer space.
	 */
	if (bufpages == 0)
		bufpages = physmem * bufcachepercent / 100;
@


1.66
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.65 2009/08/02 16:28:39 beck Exp $	*/
a104 1
caddr_t	allocsys(caddr_t);
d355 1
a355 2
	caddr_t v;
	int sz, i;
a439 11
	 * Find out how much space we need, allocate it,
	 * and then give everything true virtual addresses.
	 */
	sz = (int)allocsys((caddr_t)0);

	if ((v = (caddr_t)uvm_km_zalloc(kernel_map, round_page(sz))) == 0)
		panic("startup: no room for tables");
	if (allocsys(v) - v != sz)
		panic("startup: table size inconsistency");

	/*
a493 20
}

/*
 * Allocate space for system data structures.  We are given
 * a starting virtual address and we return a final virtual
 * address; along the way we set each data structure pointer.
 *
 * We call allocsys() with 0 to find out how much space we want,
 * allocate that much and fill it with zeroes, and then call
 * allocsys() again with the correct base virtual address.
 */
caddr_t
allocsys(v)
	caddr_t v;
{

#define	valloc(name, type, num) \
	    v = (caddr_t)(((name) = (type *)v) + (num))

	return v;
@


1.65
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.64 2009/06/15 17:01:26 beck Exp $	*/
a71 3
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
a524 7

#ifdef SYSVMSG
	valloc(msgpool, char, msginfo.msgmax);
	valloc(msgmaps, struct msgmap, msginfo.msgseg);
	valloc(msghdrs, struct msg, msginfo.msgtql);
	valloc(msqids, struct msqid_ds, msginfo.msgmni);
#endif
@


1.64
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.63 2009/06/03 21:30:19 beck Exp $	*/
a471 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.63
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.62 2009/04/19 17:56:13 miod Exp $	*/
d472 6
@


1.62
log
@Rename max_cpus to ncpusfound and compute it regardless of option
MULTIPROCESSOR.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.61 2009/02/16 22:55:03 miod Exp $	*/
a471 6

	/* Restrict to at most 25% filled kvm */
	if (bufpages >
	    (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) / PAGE_SIZE / 4) 
		bufpages = (VM_MAX_KERNEL_ADDRESS-VM_MIN_KERNEL_ADDRESS) /
		    PAGE_SIZE / 4;
@


1.61
log
@Since NMI are now handled separately, remove the ``interrupt type'' argument
from interrupt() and related function pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.60 2009/02/04 17:19:17 miod Exp $	*/
d1065 1
a1065 1
	for (cpu = 0; cpu < max_cpus; cpu++) {
@


1.60
log
@Unify memory size reports a bit more: always report size in MB, and report
reserved memory on alpha and hppa on its own line (as done on sgi).
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.59 2008/12/30 05:33:17 miod Exp $	*/
d844 1
a844 1
luna88k_ext_int(u_int v, struct trapframe *eframe)
@


1.59
log
@savecore(8) wants dumpmag to be an unsigned long.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.58 2008/06/27 17:22:14 miod Exp $	*/
d388 2
a389 1
	printf("real mem  = %d\n", ptoa(physmem));
d493 2
a494 1
	printf("avail mem = %ld (%d pages)\n", ptoa(uvmexp.free), uvmexp.free);
@


1.58
log
@Clear swap encryption keys before dumping a kernel image.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 2008/04/09 16:58:10 deraadt Exp $	*/
d602 1
a602 1
unsigned dumpmag = 0x8fca0101;	 /* magic number for savecore */
@


1.57
log
@Add new stub uvm_shutdown() and call it from the right place in MD boot()
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.57 2008/04/09 16:50:28 deraadt Exp $	*/
d98 1
d689 4
@


1.56
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2007/11/17 05:37:53 miod Exp $	*/
d572 2
a573 2
	/* Disable interrupts. */
	splhigh();
@


1.55
log
@Add a machdep.cputype sysctl, which returns the processor type (0 for 88100,
1 for 88110), for userland to have an easy way to figure out.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.54 2007/12/31 09:23:53 martin Exp $	*/
d253 1
a253 1
	CN_NORMAL,
d1086 1
a1086 1
	cp->cn_pri = CN_NORMAL;
@


1.54
log
@replace ctob/btoc by ptoa/atop as done for other architectures
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.53 2007/12/17 05:23:49 miod Exp $	*/
d967 2
@


1.53
log
@Make this compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.52 2007/11/17 05:37:53 miod Exp $	*/
d366 1
a366 1
	for (i = 0; i < btoc(MSGBUFSIZE); i++)
d387 1
a387 1
	printf("real mem  = %d\n", ctob(physmem));
d628 1
a628 1
	cpu_kcore_hdr.ram_segs[0].size = ctob(physmem);
d1007 1
a1007 1
	physmem = btoc(last_addr);
@


1.52
log
@The initial ipl on luna/mvme188 like interrupt arbiters is IPL_HIGH, not
IPL_NONE; fixes a false splassert warning on boot.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.51 2007/11/17 05:36:23 miod Exp $	*/
a758 2
#ifdef MULTIPROCESSOR

d769 2
d1060 1
a1060 1
		cmmu_set_sapr(cpu, kernel_pmap->pm_apr);
@


1.51
log
@Replace many ``unsigned'' variables with ``unsigned int'', ``u_int'' or other
appropriate types. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.50 2007/11/17 05:32:05 miod Exp $	*/
d139 1
a139 1
u_int luna88k_curspl[] = { IPL_NONE, IPL_NONE, IPL_NONE, IPL_NONE };
@


1.50
log
@Rework {get,set,raise}ipl() to minimize psr modification, especially on
boards such as mvme1[89]7 where spl changes can be atomic.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.49 2007/11/15 21:23:15 miod Exp $	*/
d132 5
a136 5
unsigned int *volatile int_mask_reg[] = {
	(unsigned int *)INT_ST_MASK0,
	(unsigned int *)INT_ST_MASK1,
	(unsigned int *)INT_ST_MASK2,
	(unsigned int *)INT_ST_MASK3
d141 1
a141 1
unsigned int int_set_val[INT_LEVEL] = {
d155 5
a159 5
unsigned int *volatile clock_reg[] = {
	(unsigned int *)OBIO_CLOCK0,
	(unsigned int *)OBIO_CLOCK1,
	(unsigned int *)OBIO_CLOCK2,
	(unsigned int *)OBIO_CLOCK3
d330 1
a330 1
	return (trunc_page((unsigned)look));
d840 1
a840 1
	unsigned int cur_mask, cur_int;
d1038 1
a1038 1
	pmap_bootstrap((vaddr_t)trunc_page((unsigned)&kernelstart));
@


1.49
log
@Stop referring the initial kernel stack as the ``interrupt stack''. It's
been years since it has last been used for that purpose, so name it the
initialization/startup stack.

While there, do not store the initialization stack in cpu_info, and have
secondary_pre_main() return its value so that the bootstrap code does not
need to fetch it from cpu_info.

This might be reconsidered when the startup stacks will be freed after they
are not used anymore, but there are more things to do first.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.48 2007/11/14 23:12:45 miod Exp $	*/
a112 1
u_int	getipl(void);
d118 1
a118 1
void	setlevel(unsigned int);
d139 1
a139 1
unsigned int luna88k_curspl[] = {0, 0, 0, 0};
d841 1
a841 1
	unsigned int level, old_spl;
d1254 1
a1254 1
setlevel(unsigned int level)
d1256 1
a1256 1
	unsigned int set_value;
d1266 1
d1268 5
a1272 1
	luna88k_curspl[cpu] = level;
d1275 1
a1275 1
u_int
d1278 1
a1278 6
	u_int curspl, psr;

	disable_interrupt(psr);
	curspl = luna88k_curspl[cpu_number()];
	set_psr(psr);
	return curspl;
d1281 2
a1282 2
unsigned
setipl(unsigned level)
d1284 1
a1284 1
	unsigned int curspl, psr;
d1286 2
a1287 1
	disable_interrupt(psr);
d1289 1
a1289 9
	setlevel(level);

	/*
	 * The flush pipeline is required to make sure the above write gets
	 * through the data pipe and to the hardware; otherwise, the next
	 * bunch of instructions could execute at the wrong spl protection.
	 */
	flush_pipeline();

d1291 1
a1291 1
	return curspl;
d1294 2
a1295 2
unsigned
raiseipl(unsigned level)
d1297 1
a1297 1
	unsigned int curspl, psr;
d1299 2
a1300 1
	disable_interrupt(psr);
d1302 2
a1303 10
	if (curspl < level)
		setlevel(level);

	/*
	 * The flush pipeline is required to make sure the above write gets
	 * through the data pipe and to the hardware; otherwise, the next
	 * bunch of instructions could execute at the wrong spl protection.
	 */
	flush_pipeline();

d1305 1
a1305 1
	return curspl;
@


1.48
log
@Merge the ci_alive and ci_primary boolean values of struct cpu_info into
a single ci_flags bitfield.

Also, set_cpu_number() will no longer set CIF_PRIMARY on the primary processor,
it's up to the initialization code to do this.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.47 2007/11/06 21:42:56 miod Exp $	*/
d118 1
a118 1
void	secondary_pre_main(void);
d774 1
a774 1
 * Determine CPU number and set it, then allocate the idle pcb (and stack).
d778 1
a778 1
void
d794 2
a795 2
	ci->ci_init_stack = uvm_km_zalloc(kernel_map, USPACE);
	if (ci->ci_init_stack == (vaddr_t)NULL) {
d800 2
d807 1
a807 1
 * We are now running on our idle stack, with proper page tables.
@


1.47
log
@Remove the now unused idle_u, and call the secondary processors startup
stack a startup stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.46 2007/10/13 12:55:21 miod Exp $	*/
d1011 1
a1056 2
			continue;
		if (m88k_cpus[cpu].ci_alive == 0)
@


1.46
log
@Enable interrupts in secondary processors before invoking cpu_switchto(),
rather the expecting it to do this for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.45 2007/10/10 15:53:52 art Exp $	*/
d794 5
a798 3
	ci->ci_idle_pcb = (struct pcb *)uvm_km_zalloc(kernel_map, USPACE);
	if (ci->ci_idle_pcb == NULL) {
		printf("cpu%d: unable to allocate idle stack\n", ci->ci_cpuid);
@


1.45
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.44 2007/06/06 17:15:12 deraadt Exp $	*/
d819 3
@


1.44
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.43 2007/05/29 20:36:47 deraadt Exp $	*/
d88 1
d109 1
d188 2
d763 10
d810 1
d813 1
d815 1
d818 1
d820 2
a821 5
	/*
	 * Upon return, the secondary cpu bootstrap code in locore will
	 * enter the idle loop, waiting for some food to process on this
	 * processor.
	 */
a983 1
	extern void cpu_boot_secondary_processors(void);
@


1.43
log
@start of dumpconf() unification, which one day we can pray will be MI
(and part of setroot); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.42 2007/05/27 17:31:56 miod Exp $	*/
d652 1
a652 1
	daddr_t blkno;		/* current block to write */
d654 1
a654 1
	int (*dump)(dev_t, daddr_t, caddr_t, size_t);
@


1.42
log
@Make sure the minaddr hint for uvm_km_suballoc() calls is always initialized.
ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.41 2007/05/26 20:26:50 pedro Exp $	*/
d611 1
a611 1
dumpconf()
a613 1
	int maj;
d615 2
a616 1
	if (dumpdev == NODEV)
a617 6
	maj = major(dumpdev);
	if (maj < 0 || maj >= nblkdev)
		panic("dumpconf: bad dumpdev=0x%x", dumpdev);
	if (bdevsw[maj].d_psize == NULL)
		return;
	nblks = (*bdevsw[maj].d_psize)(dumpdev);
@


1.41
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.40 2007/05/12 20:03:25 miod Exp $	*/
d478 1
@


1.40
log
@Increment ncpus when hatching a secondary processor.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.39 2007/05/12 20:02:14 miod Exp $	*/
a188 6
#ifdef	NBUF
int nbuf = NBUF;
#else
int nbuf = 0;
#endif

a356 2
	vsize_t size;
	int base, residual;
d462 2
a463 2
	 * Now allocate buffers proper.  They are different than the above
	 * in that they usually occupy more virtual memory than physical.
d465 2
a466 13
	size = MAXBSIZE * nbuf;
	if (uvm_map(kernel_map, (vaddr_t *) &buffers, round_page(size),
	    NULL, UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_NONE,
	      UVM_PROT_NONE, UVM_INH_NONE, UVM_ADV_NORMAL, 0)))
		panic("cpu_startup: cannot allocate VM for buffers");
	minaddr = (vaddr_t)buffers;

	if ((bufpages / nbuf) >= btoc(MAXBSIZE)) {
		/* don't want to alloc more physical mem than needed */
		bufpages = btoc(MAXBSIZE) * nbuf;
	}
	base = bufpages / nbuf;
	residual = bufpages % nbuf;
d468 5
a472 26
	for (i = 0; i < nbuf; i++) {
		vsize_t curbufsize;
		vaddr_t curbuf;
		struct vm_page *pg;

		/*
		 * Each buffer has MAXBSIZE bytes of VM space allocated.  Of
		 * that MAXBSIZE space, we allocate and map (base+1) pages
		 * for the first "residual" buffers, and then we allocate
		 * "base" pages for the rest.
		 */
		curbuf = (vaddr_t)buffers + (i * MAXBSIZE);
		curbufsize = PAGE_SIZE * ((i < residual) ? (base+1) : base);

		while (curbufsize) {
			pg = uvm_pagealloc(NULL, 0, NULL, 0);
			if (pg == NULL)
				panic("cpu_startup: not enough memory for "
				      "buffer cache");
			pmap_kenter_pa(curbuf, VM_PAGE_TO_PHYS(pg),
			    VM_PROT_READ | VM_PROT_WRITE);
			curbuf += PAGE_SIZE;
			curbufsize -= PAGE_SIZE;
		}
	}
	pmap_update(pmap_kernel());
a487 2
	printf("using %d buffers containing %d bytes of memory\n", nbuf,
	    bufpages * PAGE_SIZE);
a533 28

	/*
	 * Determine how many buffers to allocate.  We use 10% of the
	 * first 2MB of memory, and 5% of the rest, with a minimum of 16
	 * buffers.  We allocate 1/2 as many swap buffer headers as file
	 * i/o buffers.
	 */
	if (bufpages == 0) {
		bufpages = (btoc(2 * 1024 * 1024) + physmem) *
		    bufcachepercent / 100;
	}
	if (nbuf == 0) {
		nbuf = bufpages;
		if (nbuf < 16)
			nbuf = 16;
	}

	/* Restrict to at most 70% filled kvm */
	if (nbuf >
	    (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) / MAXBSIZE * 7 / 10)
		nbuf = (VM_MAX_KERNEL_ADDRESS - VM_MIN_KERNEL_ADDRESS) /
		    MAXBSIZE * 7 / 10;

	/* More buffer pages than fits into the buffers is senseless.  */
	if (bufpages > nbuf * MAXBSIZE / PAGE_SIZE)
		bufpages = nbuf * MAXBSIZE / PAGE_SIZE;

	valloc(buf, struct buf, nbuf);
@


1.39
log
@Change the 88100 interrupt handlers to process DAEs with interrupts enabled,
as done for DAEs not occuring during interrupts.

Remove the check for unprocessed DAE on return from trap() in eh_common.S,
since this can't happen. As a result, the return-from-trap code becomes
identical on 88100 and 88110 systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.38 2007/05/12 19:59:02 miod Exp $	*/
d873 1
@


1.38
log
@Remove unused code and definitions pasted over from mvme188 support, which do
not apply to luna88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.37 2007/02/09 14:26:09 aoyama Exp $	*/
d952 1
a956 2
	set_psr(get_psr() | PSR_IND);
out:
d961 2
a962 2
	 * Restore the mask level to what it was when the interrupt
	 * was taken.
d964 1
a964 1
	setipl(eframe->tf_mask);
@


1.37
log
@LCD device driver, second step.  Now the driver works with autoconf.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.36 2007/01/12 21:41:53 aoyama Exp $	*/
a113 1
u_int	safe_level(u_int, u_int);
a139 11
unsigned int int_mask_val[INT_LEVEL] = {
	INT_MASK_LV0,
	INT_MASK_LV1,
	INT_MASK_LV2,
	INT_MASK_LV3,
	INT_MASK_LV4,
	INT_MASK_LV5,
	INT_MASK_LV6,
	INT_MASK_LV7
};

d907 1
d909 1
a925 17
		if (level >= 8) {
			register int i;

			printf("safe level %d <= old level %d\n", level, old_spl);
			printf("cur_int = 0x%x\n", cur_int);

			for (i = 0; i < 4; i++)
				printf("IEN%d = 0x%x  ", i, *int_mask_reg[i]);
			printf("\nCPU0 spl %d  CPU1 spl %d  CPU2 spl %d  CPU3 spl %d\n",
			       luna88k_curspl[0], luna88k_curspl[1],
			       luna88k_curspl[2], luna88k_curspl[3]);
			for (i = 0; i < 8; i++)
				printf("int_mask[%d] = 0x%08x\n", i, int_mask_val[i]);
			printf("--CPU %d halted--\n", cpu_number());
			setipl(IPL_ABORT);
			for(;;) ;
		}
a1306 17
}

/*
 * return next safe spl to reenable interrupts.
 */
u_int
safe_level(u_int mask, u_int curlevel)
{
	int i;

	for (i = curlevel; i < 8; i++)
		if (!(int_mask_val[i] & mask))
			return i;

	panic("safe_level: no safe level for mask 0x%08x level %d found",
	       mask, curlevel);
	/* NOTREACHED */
@


1.36
log
@Change the secondary CMMU's data cache turn on so that do not hog the
bus while they spin, as same as 3.8.  This have been missed since CMMU
initialize cleanup.

Also m88k_cpus[] should have 4 elements on luna88k, even in
non-MULTIPROCESSOR kernel.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.35 2006/11/18 22:58:25 miod Exp $	*/
a238 1
extern void greeting(void);	/* in dev/lcd.c */
a562 5

	/*
	 * Say hello to the world on LCD.
	 */
	greeting();
@


1.35
log
@On 88100 systems which do not need the xxx.usr instruction workaround,
override the DAE helper routines with workaroundless code while the kernel
text is still writable.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.34 2006/10/30 14:46:35 aoyama Exp $	*/
d1076 2
a1103 14
	 * On the luna88k, secondary processors are not disabled while the
	 * kernel is initializing. We just initialized the CMMUs tied to the
	 * currently-running CPU; initialize the others with similar settings
	 * here as well.
	 */
	for (cpu = 0; cpu < max_cpus; cpu++) {
		if (cpu == master_cpu)
			continue;
		if (m88k_cpus[cpu].ci_alive == 0)
			continue;
		m8820x_initialize_cpu(cpu);
	}

	/*
d1136 18
@


1.34
log
@Now the primary CPU starts the CMMUs which tied to the secondary CPUs.
Without this, the performance is not good on multi-CPU machine with
non-MULTIPROCESSOR kernel, because the secondary CPUs run on the
never-ending loop without cache.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.33 2006/05/15 21:40:04 miod Exp $	*/
d1098 2
@


1.33
log
@Clean secondary processors initialization code, similar to mvme88k;
tested aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.32 2006/05/08 14:36:09 miod Exp $	*/
d1074 2
d1098 14
@


1.32
log
@Replace gazillions of badvaddr() or badwordaddr() calls with badaddr() calls.
With a few prototype declarations shuffling, this finally allows
<machine/locore.h> to die.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.31 2006/05/08 14:03:34 miod Exp $	*/
a111 1
vaddr_t	get_slave_stack(void);
d116 2
a118 2
void	slave_pre_main(void);
int	slave_main(void);
d849 10
a858 3
/* gets an interrupt stack for slave processors */
vaddr_t
get_slave_stack()
d860 1
a860 1
	vaddr_t addr;
d862 2
a863 1
	addr = (vaddr_t)uvm_km_zalloc(kernel_map, INTSTACK_SIZE);
d865 4
a868 3
	if (addr == NULL)
		panic("Cannot allocate slave stack for cpu %d",
		    cpu_number());
d870 7
a876 1
	return addr;
d880 1
a880 2
 * Slave CPU pre-main routine.
 * Determine CPU number and set it.
d882 2
a883 1
 * Running on an interrupt stack here; do nothing fancy.
d886 1
a886 1
slave_pre_main()
d888 11
a898 3
	set_cpu_number(cmmu_cpu_number()); /* Determine cpu number by CMMU */
	splhigh();
	set_psr(get_psr() & ~PSR_IND);
d901 1
a901 8
/* dummy main routine for slave processors */
int
slave_main()
{
	printf("slave CPU%d started\n", cpu_number());
	while (1); /* spin forever */
	return 0;
}
a1105 14

	/*
	 * We may have more than one CPU, so mention which one is the master.
	 * We will also want to spin up slave CPUs on the long run...
	 */
	printf("CPU%d is master CPU\n", master_cpu);

#if 0
	int i;
	for (i = 0; i < MAX_CPUS; i++) {
		if (!spin_cpu(i))
			printf("CPU%d started\n", i);
	}
#endif
@


1.31
log
@Clean the internal m88k trap type codes; while there, simplify and
factorize the build of the VBR page betweem luna88k and mvme88k.

Tested by aoyama@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.30 2005/12/11 21:36:04 miod Exp $	*/
a87 1
#include <machine/locore.h>
d111 1
d326 1
a326 1
		if (badwordaddr((vaddr_t)look)) {
d1351 1
a1351 1
unsigned
d1354 1
a1354 1
	unsigned int curspl, psr;
@


1.30
log
@Factorize soft interrupt code between luna88k and mvme88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.29 2005/12/04 15:00:23 miod Exp $	*/
a106 4
typedef struct {
	unsigned word_one, word_two;
} m88k_exception_vector_area;

a119 1
void	vector_init(m88k_exception_vector_area *, unsigned *);
a1314 49
}

#define SIGSYS_MAX	501
#define SIGTRAP_MAX	510

#define EMPTY_BR	0xc0000000	/* empty "br" instruction */
#define NO_OP 		0xf4005800	/* "or r0, r0, r0" */

#define BRANCH(FROM, TO) \
	(EMPTY_BR | ((unsigned)(TO) - (unsigned)(FROM)) >> 2)

#define SET_VECTOR(NUM, VALUE) \
	do { \
		vector[NUM].word_one = NO_OP; \
		vector[NUM].word_two = BRANCH(&vector[NUM].word_two, VALUE); \
	} while (0)

/*
 * vector_init(vector, vector_init_list)
 *
 * This routine sets up the m88k vector table for the running processor.
 * It is called with a very little stack, and interrupts disabled,
 * so don't call any other functions!
 */
void
vector_init(m88k_exception_vector_area *vector, unsigned *vector_init_list)
{
	unsigned num;
	unsigned vec;

	for (num = 0; (vec = vector_init_list[num]) != END_OF_VECTOR_LIST;
	    num++) {
		if (vec != UNKNOWN_HANDLER)
			SET_VECTOR(num, vec);
	}

	for (; num <= SIGSYS_MAX; num++)
		SET_VECTOR(num, sigsys);

	for (; num <= SIGTRAP_MAX; num++)
		SET_VECTOR(num, sigtrap);

	SET_VECTOR(450, syscall_handler);
	SET_VECTOR(451, cache_flush_handler);
	SET_VECTOR(504, stepbpt);
	SET_VECTOR(511, userbpt);

	/* GCC will by default produce explicit trap 503 for division by zero */
	SET_VECTOR(503, vector_init_list[T_ZERODIV]);
@


1.29
log
@Let cmmu_init() now return the cpuid of the master cpu.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.28 2005/12/04 12:20:17 miod Exp $	*/
a81 2
#include <net/netisr.h>

a112 1
void	dosoftint(void);
a198 2
int ssir;

a242 2
int netisr;

a1047 39
}

void
dosoftint()
{
	if (ssir & SIR_NET) {
		siroff(SIR_NET);
		uvmexp.softs++;
#define DONETISR(bit, fn) \
	do { \
		if (netisr & (1 << bit)) { \
			netisr &= ~(1 << bit); \
			fn(); \
		} \
	} while (0)
#include <net/netisr_dispatch.h>
#undef DONETISR
	}

	if (ssir & SIR_CLOCK) {
		siroff(SIR_CLOCK);
		uvmexp.softs++;
		softclock();
	}
}

int
spl0()
{
	int x;
	x = splsoftclock();

	if (ssir) {
		dosoftint();
	}

	setipl(0);

	return (x);
@


1.28
log
@Slight cmmu code cleanup; use shorter function names, remove parity_enable
and the DDB and DEBUG helpers which are of questionable usefulness, some
stylistic changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.27 2005/12/03 14:30:05 miod Exp $	*/
d1108 1
a1108 1
	u_int master_cpu;
d1130 1
a1130 2
	cmmu_init();
	master_cpu = cmmu_cpu_number();
@


1.27
log
@Switch m88k ports to __HAVE_CPUINFO. Current cpu pointer is held in SR0
on all running processors.
Tested aoyama@@ and I
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.26 2005/12/01 22:14:52 miod Exp $	*/
a1127 2

	cmmu_parity_enable();
@


1.26
log
@Do not depend on MAX_CPUS being 4.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.25 2005/11/28 22:21:12 miod Exp $	*/
a202 1
int want_resched;
a262 1
extern struct pcb *curpcb;
d1107 3
a1109 10

	/*
	 * Must initialize p_addr before autoconfig or
	 * the fault handler will get a NULL reference.
	 * Do this early so that we can take a data or 
	 * instruction fault and survive it.
	 */
	proc0.p_addr = proc0paddr;
	curproc = &proc0;
	curpcb = &proc0paddr->u_pcb;
d1137 10
d1445 1
d1448 1
@


1.25
log
@Switch to per-process AST flags and clean AST-related codepaths; speeds up
forks as a bonus.
Tested on luna88k and mvme88k by aoyama@@ martin@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.24 2005/10/13 19:48:32 miod Exp $	*/
d141 1
a141 1
unsigned int *volatile int_mask_reg[MAX_CPUS] = {
d148 1
a148 1
unsigned int luna88k_curspl[MAX_CPUS] = {0, 0, 0, 0};
d175 1
a175 1
unsigned int *volatile clock_reg[MAX_CPUS] = {
@


1.24
log
@Merge <machine/cpu_number.h> into <machine/cpu.h>, preparing for intrusive
changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.23 2005/10/12 19:05:39 miod Exp $	*/
a202 1
int want_ast;
@


1.23
log
@Stop mapping the u area at fixed UADDR in addition to its actual va.
While there, attempt to clean and comment stack usage in the kernel.
No functional change.

From the m88k SMP tree; help&test martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.22 2005/09/25 20:30:03 miod Exp $	*/
a88 1
#include <machine/cpu_number.h>
@


1.22
log
@Do not consider userland trap #496 (BUG system call on mvme88k) as special
anymore, since we don't want to allow userland to talk to the BUG. Deliver
SIGSYS instead of doing nothing. Makes things simpler, plus it polluted
luna88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.21 2005/08/01 15:42:46 miod Exp $	*/
a129 3
extern void load_u_area(struct proc *);
extern void save_u_area(struct proc *, vaddr_t);

a137 2
vaddr_t interrupt_stack[MAX_CPUS];

d395 1
a395 1
	vaddr_t minaddr, maxaddr, uarea_pages;
a488 11
	 * Grab UADDR virtual address
	 */
	uarea_pages = UADDR;
	uvm_map(kernel_map, (vaddr_t *)&uarea_pages, USPACE,
	    NULL, UVM_UNKNOWN_OFFSET, 0,
	      UVM_MAPFLAG(UVM_PROT_NONE, UVM_PROT_NONE, UVM_INH_NONE,
	        UVM_ADV_NORMAL, 0));
	if (uarea_pages != UADDR)
		panic("uarea_pages %lx: UADDR not free", uarea_pages);

	/*
a877 1
	interrupt_stack[cpu_number()] = addr;
a1181 8
	/* Initialize cached PTEs for u-area mapping. */
	save_u_area(&proc0, (vaddr_t)proc0paddr);

	/*
	 * Map proc0's u-area at the standard address (UADDR).
	 */
	load_u_area(&proc0);

d1183 1
a1183 1
	bzero((caddr_t)UADDR, UPAGES * PAGE_SIZE);
@


1.21
log
@Kill more "memory might be 2MB or less" checks in bufpages computation.
ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.20 2005/05/01 09:55:49 miod Exp $	*/
a114 1
void	bugsyscall(void);
a1078 5
bugsyscall()
{
}

void
a1423 1
	extern void bugtrap(void);
@


1.20
log
@Bring raise-only semantics to splsoft* on m68k and m88k, as done elsewhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.19 2005/04/30 16:42:33 miod Exp $	*/
d636 2
a637 5
		if (physmem < btoc(2 * 1024 * 1024))
			bufpages = physmem / 10;
		else
			bufpages = (btoc(2 * 1024 * 1024) + physmem) *
			    bufcachepercent / 100;
@


1.19
log
@Remove m88k_psr_type and function with utterly long names to control the psr,
and use get_psr() / set_psr() or simple macros that expand into them everywhere.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.18 2005/04/27 14:09:45 miod Exp $	*/
d978 1
a978 1
			spl7();
@


1.18
log
@Allow userland to cause the data cache to be flushed for any arbitrary address
range in the current process, using trap #451.

This is necessary for proper gcc trampolines operation, and, later, ld.so...
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.17 2004/11/09 15:02:19 miod Exp $	*/
d913 1
a913 1
	enable_interrupt();
d990 1
a990 1
		enable_interrupt();
d1011 1
a1011 1
	disable_interrupt();
d1491 1
a1491 2
	unsigned curspl;
	m88k_psr_type psr;
d1493 1
a1493 1
	psr = disable_interrupts_return_psr();
d1502 1
a1502 2
	unsigned curspl;
	m88k_psr_type psr;
d1504 1
a1504 1
	psr = disable_interrupts_return_psr();
d1522 1
a1522 2
	unsigned curspl;
	m88k_psr_type psr;
d1524 1
a1524 1
	psr = disable_interrupts_return_psr();
@


1.17
log
@Luna88k does not have an iomap, so kill all iomap related defines, and
move the mapiodev()/unmapiodev() code back to mvme88k.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.16 2004/11/08 16:39:31 miod Exp $	*/
d1448 1
@


1.16
log
@Kill struct md_p, which was really only necessary for mvme88k; on
luna88k it disappears completely, while mvme88k keeps 3 global variables,
one of them scheduled to disappear very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: machdep.c,v 1.15 2004/10/03 19:47:25 miod Exp $	*/
a216 12

/*
 * iomap stuff is for managing chunks of virtual address space that
 * can be allocated to IO devices.
 * VMEbus drivers use this at this now. Only on-board IO devices' addresses
 * are mapped so that pa == va. XXX smurph.
 */

vaddr_t iomapbase;

struct extent *iomap_extent;
struct vm_map *iomap_map;
@


1.15
log
@Merge locore_c_routines.c into machdep.c, and clear <machine/locore.h> as
done on mvme88k. <machine/locore.h> is about to die very soon...
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a134 1
void luna88k_ext_int(u_int v, struct trapframe *eframe);
a143 3
/* machine dependent function pointers. */
struct md_p md;

d1160 1
a1160 2
	/* zero out the machine dependant function pointers */
	bzero(&md, sizeof(struct md_p));
a1161 9
	/* 
	 * set up interrupt and fp exception handlers 
	 * based on the machine.
	 */
	cmmu = &cmmu8820x;
	md.interrupt_func = &luna88k_ext_int;
	md.intr_mask = NULL;
	md.intr_ipl = NULL;
	md.intr_src = NULL;
@


1.14
log
@Oops, trimmed includes too much for RAMDISK.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.13 2004/09/30 14:55:51 miod Exp $	*/
d45 13
d84 2
a85 1
#include <machine/asm_macro.h>   /* enable/disable interrupts */
d110 20
a129 5
#if DDB
#define DEBUG_MSG db_printf
#else
#define DEBUG_MSG printf
#endif /* DDB */
d131 2
a132 1
vaddr_t interrupt_stack[MAX_CPUS];
a133 6
/* machine dependent function pointers. */
struct md_p md;

/* prototypes */
void dumpsys(void);
void consinit(void);
a134 5
int getcpuspeed(void);
void identifycpu(void);
void save_u_area(struct proc *, vaddr_t);
void load_u_area(struct proc *);
void dumpconf(void);
d143 5
d159 24
d211 1
a211 1
volatile vaddr_t obiova;
d238 1
a238 1
int   nbuf = NBUF;
d240 1
a240 1
int   nbuf = 0;
d248 1
a248 1
int   bufpages = BUFPAGES;
d250 1
a250 1
int   bufpages = 0;
d252 1
a252 3
int   bufcachepercent = BUFCACHEPERCENT;

caddr_t allocsys(caddr_t);
a274 3
extern char *etext;
extern char *edata;
extern char *end;
d282 2
a283 2
vaddr_t first_addr = 0;
vaddr_t last_addr = 0;
d307 1
a307 1
	makedev(14,0),
d424 2
a425 2
		pmap_kenter_pa((paddr_t)msgbufp + i * NBPG,
		    avail_end + i * NBPG, VM_PROT_READ | VM_PROT_WRITE);
d429 1
a429 1
	/* Determine the machine type from FUSE ROM data */
d449 1
d451 1
a922 2
 *
 * Called from "luna88k/locore.S"
d927 3
a929 3
   set_cpu_number(cmmu_cpu_number()); /* Determine cpu number by CMMU */
   splhigh();
   enable_interrupt();
a942 5
 *
 *      when we enter, interrupts are disabled;
 *      when we leave, they should be disabled,
 *      but they need not be disabled throughout
 *      the routine.
a944 4
#define GET_MASK(cpu, val)	*int_mask_reg[cpu] & (val)
extern unsigned int luna88k_curspl[MAX_CPUS];	/* XXX sould be here? */
extern unsigned int int_mask_val[INT_LEVEL];	/* XXX sould be here? */

d961 1
a961 1
		 * DUART interrupts.
d998 1
d1002 1
a1097 2
/* dummys for now */

a1145 1

d1152 1
d1158 1
a1158 1
	 * instruction fault and survive it. XXX smurph
d1185 1
a1185 1
	uvmexp.pagesize = NBPG;
d1188 1
a1188 1
	first_addr = round_page((vaddr_t) &end);	/* XXX: Is this OK? */
d1215 1
d1222 2
a1223 1
	printf("LUNA88K boot: memory from 0x%x to 0x%x\n", avail_start, avail_end);
d1243 1
a1243 1
	bzero((caddr_t)UADDR, UPAGES*NBPG);
d1430 136
@


1.13
log
@More code shuffling, probably the final touch.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.12 2004/09/30 09:20:46 miod Exp $	*/
d79 1
@


1.12
log
@Move common signal code to m88k-agnostic location.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.11 2004/08/30 13:10:32 aoyama Exp $	*/
a48 1
#include <sys/signalvar.h>
a71 1
#include <machine/mmu.h>
d73 1
a73 1
#include <machine/cmmu.h>		/* CMMU stuff	*/
d79 1
a79 2
#include <machine/trap.h>
#include <machine/m88100.h>		/* DMT_VALID	*/
a106 1
void regdump(struct trapframe *f);
a168 6
int longformat = 1;  /* for regdump() */
/*
 * safepri is a safe priority for sleep to set for a spin-wait
 * during autoconfiguration or after a panic.
 */
int   safepri = IPL_NONE;
a365 30
/*
 *	Setup u area ptes for u area double mapping.
 */

void
save_u_area(struct proc *p, vaddr_t va)
{
	int i;

	for (i = 0; i < UPAGES; i++) {
		p->p_md.md_upte[i] = *((pt_entry_t *)kvtopte(va));
		va += NBPG;
	}
}

void
load_u_area(struct proc *p)
{
	int i;
	vaddr_t va;
	pt_entry_t *t;

	for (i = 0, va = UADDR; i < UPAGES; i++) {
		t = kvtopte(va);
		*t = p->p_md.md_upte[i];
		va += NBPG;
	}
	cmmu_flush_tlb(cpu_number(), 1, UADDR, USPACE);
}

a632 81
/*
 * Set registers on exec.
 * Clear all except sp and pc.
 */
void
setregs(p, pack, stack, retval)
	struct proc *p;
	struct exec_package *pack;
	u_long stack;
	int retval[2];
{
	struct trapframe *tf = (struct trapframe *)USER_REGS(p);

	/*
	 * The syscall will ``return'' to snip; set it.
	 * argc, argv, envp are placed on the stack by copyregs.
	 * Point r2 to the stack. crt0 should extract envp from
	 * argc & argv before calling user's main.
	 */
#if 0
	/*
	 * I don't think I need to mess with fpstate on 88k because
	 * we make sure the floating point pipeline is drained in
	 * the trap handlers. Should check on this later. XXX Nivas.
	 */

	if ((fs = p->p_md.md_fpstate) != NULL) {
		/*
		 * We hold an FPU state.  If we own *the* FPU chip state
		 * we must get rid of it, and the only way to do that is
		 * to save it.  In any case, get rid of our FPU state.
		 */
		if (p == fpproc) {
			savefpstate(fs);
			fpproc = NULL;
		}
		free((void *)fs, M_SUBPROC);
		p->p_md.md_fpstate = NULL;
	}
#endif /* 0 */
	bzero((caddr_t)tf, sizeof *tf);

	if (cputyp == CPU_88110) {
		/*
		 * user mode, serialize mem, interrupts enabled,
		 * graphics unit, fp enabled
		 */
		tf->tf_epsr = PSR_SRM | PSR_SFD;
		/*
		 * XXX disable OoO for now...
		 */
		tf->tf_epsr |= PSR_SER;
	} else {
		/*
		 * user mode, interrupts enabled,
		 * no graphics unit, fp enabled
		 */
		tf->tf_epsr = PSR_SFD | PSR_SFD2;
	}

	/*
	 * We want to start executing at pack->ep_entry. The way to
	 * do this is force the processor to fetch from ep_entry. Set
	 * NIP to something bogus and invalid so that it will be a NOOP.
	 * And set sfip to ep_entry with valid bit on so that it will be
	 * fetched.  mc88110 - just set exip to pack->ep_entry.
	 */
	if (cputyp == CPU_88110) {
		tf->tf_exip = pack->ep_entry & ~3;
#ifdef DEBUG
		printf("exec @@ 0x%x\n", tf->tf_exip);
#endif
	} else {
		tf->tf_snip = pack->ep_entry & ~3;
		tf->tf_sfip = (pack->ep_entry & ~3) | FIP_V;
	}
	tf->tf_r[2] = stack;
	tf->tf_r[31] = stack;
	retval[1] = 0;
}

a1060 66
int
copystr(fromaddr, toaddr, maxlength, lencopied)
	const void *fromaddr;
	void *toaddr;
	size_t maxlength;
	size_t *lencopied;
{
	u_int tally;

	tally = 0;

	while (maxlength--) {
		*(u_char *)toaddr = *(u_char *)fromaddr++;
		tally++;
		if (*(u_char *)toaddr++ == 0) {
			if (lencopied) *lencopied = tally;
			return (0);
		}
	}

	if (lencopied)
		*lencopied = tally;

	return (ENAMETOOLONG);
}

void
setrunqueue(p)
	struct proc *p;
{
	struct prochd *q;
	struct proc *oldlast;
	int which = p->p_priority >> 2;

	if (p->p_back != NULL)
		panic("setrunqueue %p", p);
	q = &qs[which];
	whichqs |= 1 << which;
	p->p_forw = (struct proc *)q;
	p->p_back = oldlast = q->ph_rlink;
	q->ph_rlink = p;
	oldlast->p_forw = p;
}

/*
 * Remove process p from its run queue, which should be the one
 * indicated by its priority.  Calls should be made at splstatclock().
 */
void
remrunqueue(vp)
	struct proc *vp;
{
	struct proc *p = vp;
	int which = p->p_priority >> 2;
	struct prochd *q;

	if ((whichqs & (1 << which)) == 0)
		panic("remrq %p", p);
	p->p_forw->p_back = p->p_back;
	p->p_back->p_forw = p->p_forw;
	p->p_back = NULL;
	q = &qs[which];
	if (q->ph_link == (struct proc *)q)
		whichqs &= ~(1 << which);
}

a1104 87
}

void
nmihand(void *framep)
{
#if 0
	struct trapframe *frame = framep;
#endif

#if DDB
	DEBUG_MSG("Abort Pressed\n");
	Debugger();
#else
	DEBUG_MSG("Spurious NMI?\n");
#endif /* DDB */
}

void
regdump(struct trapframe *f)
{
#define R(i) f->tf_r[i]
	printf("R00-05: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(0),R(1),R(2),R(3),R(4),R(5));
	printf("R06-11: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(6),R(7),R(8),R(9),R(10),R(11));
	printf("R12-17: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(12),R(13),R(14),R(15),R(16),R(17));
	printf("R18-23: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(18),R(19),R(20),R(21),R(22),R(23));
	printf("R24-29: 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\n",
	       R(24),R(25),R(26),R(27),R(28),R(29));
	printf("R30-31: 0x%08x  0x%08x\n",R(30),R(31));
	if (cputyp == CPU_88110) {
		printf("exip %x enip %x\n", f->tf_exip, f->tf_enip);
	} else {
		printf("sxip %x snip %x sfip %x\n",
		    f->tf_sxip, f->tf_snip, f->tf_sfip);
	}
#ifdef M88100
	if (f->tf_vector == 0x3 && cputyp != CPU_88110) {
		/* print dmt stuff for data access fault */
		printf("dmt0 %x dmd0 %x dma0 %x\n",
		    f->tf_dmt0, f->tf_dmd0, f->tf_dma0);
		printf("dmt1 %x dmd1 %x dma1 %x\n",
		    f->tf_dmt1, f->tf_dmd1, f->tf_dma1);
		printf("dmt2 %x dmd2 %x dma2 %x\n",
		    f->tf_dmt2, f->tf_dmd2, f->tf_dma2);
		printf("fault type %d\n", (f->tf_dpfsr >> 16) & 0x7);
		dae_print((unsigned *)f);
	}
	if (longformat && cputyp != CPU_88110) {
		printf("fpsr %x fpcr %x epsr %x ssbr %x\n",
		    f->tf_fpsr, f->tf_fpcr, f->tf_epsr, f->tf_ssbr);
		printf("fpecr %x fphs1 %x fpls1 %x fphs2 %x fpls2 %x\n",
		    f->tf_fpecr, f->tf_fphs1, f->tf_fpls1,
		    f->tf_fphs2, f->tf_fpls2);
		printf("fppt %x fprh %x fprl %x fpit %x\n",
		    f->tf_fppt, f->tf_fprh, f->tf_fprl, f->tf_fpit);
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n",
		    f->tf_vector, f->tf_mask, f->tf_mode,
		    f->tf_scratch1, f->tf_cpu);
	}
#endif
#ifdef M88110
	if (longformat && cputyp == CPU_88110) {
		printf("fpsr %x fpcr %x fpecr %x epsr %x\n",
		    f->tf_fpsr, f->tf_fpcr, f->tf_fpecr, f->tf_epsr);
		printf("dsap %x duap %x dsr %x dlar %x dpar %x\n",
		    f->tf_dsap, f->tf_duap, f->tf_dsr, f->tf_dlar, f->tf_dpar);
		printf("isap %x iuap %x isr %x ilar %x ipar %x\n",
		    f->tf_isap, f->tf_iuap, f->tf_isr, f->tf_ilar, f->tf_ipar);
		printf("vector %d mask %x mode %x scratch1 %x cpu %x\n",
		    f->tf_vector, f->tf_mask, f->tf_mode,
		    f->tf_scratch1, f->tf_cpu);
	}
#endif
#ifdef MVME188
	if (brdtyp == BRD_188) {
		unsigned int istr, cur_mask;

		istr = *(int *volatile)IST_REG;
		cur_mask = GET_MASK(0, istr);
		printf("emask = 0x%b\n", f->tf_mask, IST_STRING);
		printf("istr  = 0x%b\n", istr, IST_STRING);
		printf("cmask = 0x%b\n", cur_mask, IST_STRING);
	}
#endif
@


1.11
log
@Add the original LUNA-88K support.
- retrieve auto-boot information from NVRAM
- retrieve ethernet address information from FUSE ROM
They are stored different way from LUNA-88K2.

Tested by Jeff McMahill, ok by miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.10 2004/08/24 12:59:51 miod Exp $	*/
a751 185
}

struct sigstate {
	int   ss_flags;	     /* which of the following are valid */
	struct   trapframe ss_frame;  /* original exception frame */
};

/*
 * WARNING: code in locore.s assumes the layout shown for sf_signo
 * through sf_handler so... don't screw with them!
 */
struct sigframe {
	int			sf_signo;	/* signo for handler */
	siginfo_t *		sf_sip;
	struct sigcontext *	sf_scp;		/* context ptr for handler */
	sig_t			sf_handler;	/* handler addr for u_sigc */
	struct sigcontext	sf_sc;		/* actual context */
	siginfo_t		sf_si;
};

#ifdef DEBUG
int sigdebug = 0;
int sigpid = 0;
   #define SDB_FOLLOW	0x01
   #define SDB_KSTACK	0x02
   #define SDB_FPSTATE	0x04
#endif

/*
 * Send an interrupt to process.
 */
void
sendsig(catcher, sig, mask, code, type, val)
	sig_t catcher;
	int sig, mask;
	unsigned long code;
	int type;
	union sigval val;
{
	struct proc *p = curproc;
	struct trapframe *tf;
	struct sigacts *psp = p->p_sigacts;
	struct sigframe *fp;
	int oonstack, fsize;
	struct sigframe sf;
	int addr;

	tf = p->p_md.md_tf;
	oonstack = psp->ps_sigstk.ss_flags & SS_ONSTACK;
	/*
	 * Allocate and validate space for the signal handler
	 * context. Note that if the stack is in data space, the
	 * call to grow() is a nop, and the copyout()
	 * will fail if the process has not already allocated
	 * the space with a `brk'.
	 */
	fsize = sizeof(struct sigframe);
	if ((psp->ps_flags & SAS_ALTSTACK) &&
	    (psp->ps_sigstk.ss_flags & SS_ONSTACK) == 0 &&
	    (psp->ps_sigonstack & sigmask(sig))) {
		fp = (struct sigframe *)(psp->ps_sigstk.ss_sp +
					 psp->ps_sigstk.ss_size - fsize);
		psp->ps_sigstk.ss_flags |= SS_ONSTACK;
	} else
		fp = (struct sigframe *)(tf->tf_r[31] - fsize);

	/* make sure the frame is aligned on a 8 byte boundary */
	if (((vaddr_t)fp & 0x07) != 0)
		fp = (struct sigframe *)((vaddr_t)fp & ~0x07);

	if ((unsigned)fp <= USRSTACK - ctob(p->p_vmspace->vm_ssize))
		(void)uvm_grow(p, (unsigned)fp);

#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && (p->p_pid == sigpid)))
		printf("sendsig(%d): sig %d ssp %x usp %x scp %x\n",
		       p->p_pid, sig, &oonstack, fp, &fp->sf_sc);
#endif
	/*
	 * Build the signal context to be used by sigreturn.
	 */
	sf.sf_signo = sig;
	sf.sf_scp = &fp->sf_sc;
	sf.sf_handler = catcher;
	sf.sf_sc.sc_onstack = oonstack;
	sf.sf_sc.sc_mask = mask;

	if (psp->ps_siginfo & sigmask(sig)) {
		sf.sf_sip = &fp->sf_si;
		initsiginfo(&sf.sf_si, sig, code, type, val);
	}

	/*
	 * Copy the whole user context into signal context that we
	 * are building.
	 */
	bcopy((const void *)&tf->tf_regs, (void *)&sf.sf_sc.sc_regs,
	    sizeof(sf.sf_sc.sc_regs));

	if (copyout((caddr_t)&sf, (caddr_t)fp, sizeof sf)) {
		/*
		 * Process has trashed its stack; give it an illegal
		 * instruction to halt it in its tracks.
		 */
		sigexit(p, SIGILL);
		/* NOTREACHED */
	}
	/*
	 * Build the argument list for the signal handler.
	 * Signal trampoline code is at base of user stack.
	 */
	addr = p->p_sigcode;
	if (cputyp != CPU_88110) {
		/* mc88100 */
		tf->tf_snip = (addr & ~3) | NIP_V;
		tf->tf_sfip = (tf->tf_snip + 4) | FIP_V;
	} else {
		/* mc88110 */
		tf->tf_exip = (addr & ~3);
		tf->tf_enip = (tf->tf_exip + 4);
	}
	tf->tf_r[31] = (unsigned)fp;
#ifdef DEBUG
	if ((sigdebug & SDB_FOLLOW) ||
	    ((sigdebug & SDB_KSTACK) && p->p_pid == sigpid))
		printf("sendsig(%d): sig %d returns\n", p->p_pid, sig);
#endif
}

/*
 * System call to cleanup state after a signal
 * has been taken.  Reset signal mask and
 * stack state from context left by sendsig (above).
 * Return to previous pc and psl as specified by
 * context left by sendsig. Check carefully to
 * make sure that the user has not modified the
 * psl to gain improper privileges or to cause
 * a machine fault.
 */

/* ARGSUSED */
int
sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sigreturn_args /* {
	   syscallarg(struct sigcontext *) sigcntxp;
	} */ *uap = v;
	struct sigcontext *scp;
	struct trapframe *tf;
	struct sigcontext ksc;

	scp = (struct sigcontext *)SCARG(uap, sigcntxp);
#ifdef DEBUG
	if (sigdebug & SDB_FOLLOW)
		printf("sigreturn: pid %d, scp %x\n", p->p_pid, scp);
#endif
	if (((vaddr_t)scp & 3) != 0 ||
	    copyin((caddr_t)scp, (caddr_t)&ksc, sizeof(struct sigcontext)))
		return (EINVAL);

	tf = p->p_md.md_tf;
	scp = &ksc;

	/*
	 * this can be improved by doing
	 *	 bcopy(sc_reg to tf, sizeof sigcontext - 2 words)
	 * XXX nivas
	 */
	bcopy((const void *)&scp->sc_regs, (caddr_t)&tf->tf_regs,
	    sizeof(scp->sc_regs));

	/*
	 * Restore the user supplied information
	 */
	if (scp->sc_onstack & SS_ONSTACK)
		p->p_sigacts->ps_sigstk.ss_flags |= SS_ONSTACK;
	else
		p->p_sigacts->ps_sigstk.ss_flags &= ~SS_ONSTACK;
	p->p_sigmask = scp->sc_mask & ~sigcantmask;

	return (EJUSTRETURN);
@


1.10
log
@Since the cpu frequency can only be an integral number on the Luna88k,
simplify the delay() code, and as a result do not use floating-point code
in the kernel anymore.

Tested by aoyama@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.9 2004/08/18 13:29:46 aoyama Exp $	*/
d156 1
a156 1
static char fuse_rom_data[FUSE_ROM_BYTES];
d1800 1
a1800 1
	int i;
d1802 1
a1802 1
	char *data;
d1805 14
a1818 8
#if 0
		/* this is not tested... */
		int i;
		struct nvram_byte *p = (struct nvram_byte *)NVRAM_ADDR;

		for (i = 0; i < NVRAM_BYTES; i++) {
			nvram_data[i] = p->data;
			p++;
a1819 1
#endif
@


1.9
log
@Add 'irq6/clock0' to evcount on luna88k.
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.8 2004/07/28 12:28:48 miod Exp $	*/
d231 1
a231 2
int cpuspeed;
double cycles_per_microsecond;	/* used in locore.S:delay() */
a356 2
	double clock_mhz;

d359 1
a359 2
		clock_mhz = 25.0;
		break;
d361 1
a361 2
		clock_mhz = 33.0;
		break;
a363 1
		break;
a364 3

	cycles_per_microsecond = clock_mhz;
	return (int)clock_mhz;
d417 1
a417 1
	 * avail_end was pre-decremented in mvme_bootstrap() to compensate.
@


1.8
log
@Remove EH_DEBUG code.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.7 2004/07/01 13:37:53 aoyama Exp $	*/
d125 1
d1288 1
a1288 10
			/* increment intr counter */
			intrcnt[M88K_CLK_IRQ]++;

			*clock_reg[cpu] = 0xFFFFFFFFU;  /* reset clock */

			/*
			if (clock_enabled[cpu])
				sys_clock_interrupt(USERMODE(eframe[EF_EPSR]));
			*/
			hardclock((void *)eframe);
@


1.7
log
@Delete unused functions and unnecessary flush_pipeline() at the
exit of interrupt handling routine. (sync with mvme88k)
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.6 2004/06/14 12:57:02 aoyama Exp $	*/
a1494 23

#ifdef EH_DEBUG

void
MY_info(f, p, flags, s)
	struct trapframe  *f;
	caddr_t     p;
	int         flags;
	char        *s;
{
	regdump(f);
	printf("proc %x flags %x type %s\n", p, flags, s);
}

void
MY_info_done(f, flags)
	struct trapframe  *f;
	int         flags;
{
	regdump(f);
}

#endif
@


1.6
log
@Added some codes that check if the machine is LUNA-88K or LUNA-88K2
and retrieve the boot device information from NVRAM.
Only works on LUNA-88K2 at this moment.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.5 2004/06/02 13:49:43 miod Exp $	*/
a1322 1
	flush_pipeline();		/* XXX: need this? */
a1381 32
}

/*
 * insert an element into a queue
 */

void
_insque(velement, vhead)
	void *velement, *vhead;
{
	struct prochd *element, *head;
	element = velement;
	head = vhead;
	element->ph_link = head->ph_link;
	head->ph_link = (struct proc *)element;
	element->ph_rlink = (struct proc *)head;
	((struct prochd *)(element->ph_link))->ph_rlink=(struct proc *)element;
}

/*
 * remove an element from a queue
 */

void
_remque(velement)
	void *velement;
{
	struct prochd *element;
	element = velement;
	((struct prochd *)(element->ph_link))->ph_rlink = element->ph_rlink;
	((struct prochd *)(element->ph_rlink))->ph_link = element->ph_link;
	element->ph_rlink = (struct proc *)0;
@


1.5
log
@More realistic kernel pdt sizing for the Luna88k (sync with recent mvme88k
changes) - makes almost 3MB more memory available for userland.

Tested by aoyama@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.4 2004/05/10 10:30:24 aoyama Exp $	*/
d121 4
d147 18
d226 1
a226 1
int machtype = LUNA_88K2;	/* XXX: aoyama */
d433 10
d1850 70
@


1.5.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
@


1.4
log
@Make the time getting frame buffer depth earlier.  Without this
modification, bitmap console depth is always 4, because consinit() is
called before cpu_startup().

And use frame buffer depth bits(1,4,8) rather than mask value(0x01,
0x0f, 0xff), same as the value in ROM work area.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.3 2004/05/07 15:08:25 aoyama Exp $	*/
d1688 2
a1689 3
	pmap_bootstrap((vaddr_t)trunc_page((unsigned)&kernelstart) /* = loadpt */,
		       &avail_start, &avail_end, &virtual_avail,
		       &virtual_end);
d1695 1
a1695 1
			  atop(avail_start), atop(avail_end),VM_FREELIST_DEFAULT);
@


1.3
log
@Add new file <machine/conf.h> and clean up console code and structures.
From miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.2 2004/05/04 15:27:15 miod Exp $	*/
d212 1
a212 1
int hwplanemask;		/* set in luna88k_bootstrap() */
d439 1
a439 1
	 * Get frame buffer depth from ROM work area.
d441 10
a450 21
	{
		int depth;

		depth = *((volatile int *)0x00001114);
		switch (depth) {
		case 1:
			hwplanemask = 0x01;
			break;
		case 4:
			hwplanemask = 0x0f;
			break;
		case 8:
			hwplanemask = 0xff;
			break;
		default:
			printf("unexpected frame buffer depth = %d\n", depth);
			/* FALLTHROUGH */
		case 0:
			hwplanemask = 0;	/* No frame buffer */
			break;
		}
@


1.2
log
@Always ask the user for the root device if we are "swap generic" and the
boot device is not known, as other arches do.
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.1.1.1 2004/04/21 15:24:08 aoyama Exp $	*/
d241 1
a241 4
void romttycnprobe(struct consdev *);
void romttycninit(struct consdev *);
void romttycnputc(dev_t, int);
int  romttycngetc(dev_t);
a260 3
#ifdef ROM_CONSOLE
	extern struct consdev *cn_tab;
#endif
a263 4
#ifdef ROM_CONSOLE
	cn_tab = &romttycons;
	/* cninit(); */
#else /* from NetBSD/luna68k */
a269 2
	/* cninit(); */	/* XXX: this should be later? */
#endif
a444 1
		printf("frame buffer depth = %d\n", depth);
d456 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $OpenBSD: machdep.c,v 1.136 2004/03/10 23:02:54 tom Exp $	*/
d206 1
a206 1
int boothowto = RB_ASKNAME;	/* XXX: should be set in boot loader and locore.S */
@


1.1.1.1
log
@Initial commit for OpenBSD/luna88k, based on OpenBSD/mvme88k, NetBSD/luna68k and CMU Mach.
@
text
@@
