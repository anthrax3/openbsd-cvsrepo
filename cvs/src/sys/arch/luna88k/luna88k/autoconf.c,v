head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.14
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.10
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.6
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.8
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.18.0.8
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.6
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.4
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.2
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.14.0.4
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.7.0.4
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	SMP:1.2.0.2
	LUNA88K_INIT:1.1.1.1
	AOYAMA:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.04.22.22.58.02;	author aoyama;	state Exp;
branches;
next	1.20;

1.20
date	2013.11.02.23.10.29;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2013.11.02.17.49.19;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2011.12.13.15.23.51;	author aoyama;	state Exp;
branches;
next	1.17;

1.17
date	2010.11.18.21.13.19;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.26.20.17.27;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.15.20.39.53;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2008.07.21.04.35.54;	author todd;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.13.12.55.21;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.15.01.19.08;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.01.19.25.10;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.04.19.30.55;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.04.03.44.44;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.26.07.11.08;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.27.18.31.09;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.30.16.42.33;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.25.23.02.24;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.23.15.31.35;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.04.15.27.15;	author miod;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2004.04.21.15.23.58;	author aoyama;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.04.21.15.23.58;	author aoyama;	state Exp;
branches;
next	;

1.2.2.1
date	2004.06.05.23.09.47;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Unify the model name to LUNA-88K{,2}, that is considered the
`official' name.

ok jmc@@ miod@@
@
text
@/*	$OpenBSD: autoconf.c,v 1.20 2013/11/02 23:10:29 miod Exp $	*/
/*
 * Copyright (c) 1998 Steve Murphree, Jr.
 * Copyright (c) 1996 Nivas Madhur
 * Copyright (c) 1994 Christian E. Hopps
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christian E. Hopps.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/reboot.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/kernel.h>

#include <uvm/uvm.h>

#include <machine/asm_macro.h>   /* enable/disable interrupts */
#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <machine/vmparam.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/cons.h>

/*
 * The following several variables are related to
 * the configuration process, and are used in initializing
 * the machine.
 */

void	dumpconf(void);
void	get_autoboot_device(void);

int cold = 1;   /* 1 if still booting */

void *bootaddr;
int bootpart;
struct device *bootdv;	/* set by device drivers (if found) */

/*
 * called at boot time, configure all devices on the system.
 */
void
cpu_configure()
{
	softintr_init();

	if (config_rootfound("mainbus", "mainbus") == 0)
		panic("no mainbus found");

	/*
	 * Switch to our final trap vectors, and unmap the PROM data area.
	 */
	set_vbr(kernel_vbr);
	pmap_unmap_firmware();

	cold = 0;

	/*
	 * Turn external interrupts on.
	 */
	set_psr(get_psr() & ~PSR_IND);
	spl0();
}

void
diskconf(void)
{
	printf("boot device: %s\n",
	    (bootdv) ? bootdv->dv_xname : "<unknown>");
	setroot(bootdv, 0, RB_USERREQ);
	dumpconf();
}

/*
 * Get 'auto-boot' information from NVRAM
 *
 * XXX Right now we can not handle network boot.
 */
struct autoboot_t
{
	char	cont[16];
	int	targ;
	int	part;
} autoboot;

void
get_autoboot_device(void)
{
	char *value, c;
	int i, len, part;
	extern char *nvram_by_symbol(char *);		/* machdep.c */

	/* Assume default controller is internal spc (spc0) */
	strlcpy(autoboot.cont, "spc0", sizeof(autoboot.cont));

	/* Get boot controler and SCSI target from NVRAM */
	value = nvram_by_symbol("boot_unit");
	if (value != NULL) {
		len = strlen(value);
		if (len == 1) {
			c = value[0];
		} else if (len == 2) {
			if (value[0] == '1') {
				/* External spc (spc1) */
				strlcpy(autoboot.cont, "spc1", sizeof(autoboot.cont));
				c = value[1];
			}
		} else
			c = -1;

		if ((c >= '0') && (c <= '6'))
			autoboot.targ = 6 - (c - '0');
	}

	/* Get partition number from NVRAM */
	value = nvram_by_symbol("boot_partition");
	if (value != NULL) {
		len = strlen(value);
		part = 0;
		for (i = 0; i < len; i++)
			part = part * 10 + (value[i] - '0');
		autoboot.part = part;
	}
}

void
device_register(struct device *dev, void *aux)
{
        /*
         * scsi: sd,cd  XXX: Can LUNA-88K boot from CD-ROM?
         */
        if (strcmp("sd", dev->dv_cfdata->cf_driver->cd_name) == 0 ||
            strcmp("cd", dev->dv_cfdata->cf_driver->cd_name) == 0) {
		struct scsi_attach_args *sa = aux;
		struct device *spcsc;

		spcsc = dev->dv_parent->dv_parent;

                if (strcmp(spcsc->dv_xname, autoboot.cont) == 0 &&
		    sa->sa_sc_link->target == autoboot.targ &&
		    sa->sa_sc_link->lun == 0) {
                        bootdv = dev;
			bootpart = autoboot.part;
                        return;
                }
        }
}

struct nam2blk nam2blk[] = {
	{ "sd",		4 },
	{ "st",		5 },
	{ "rd",		7 },
	{ "vnd",	8 },
	{ NULL,		-1 }
};
@


1.20
log
@Create the initial page tables in the area between the end of the firmware
data area and the kernel image, whenever possible.

On 88100/88200 systems, use BATC mappings to map the kernel text (and the
kernel data for non-MULTIPROCESSOR kernels). 88110 to follow soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.19 2013/11/02 17:49:19 miod Exp $	*/
d161 1
a161 1
         * scsi: sd,cd  XXX: Can LUNA88K boot from CD-ROM?
@


1.19
log
@Reserve a page at the beginning of the kernel text to use for the trap vectors,
and switch to it, on all processors, after autoconf is over. First step
towards being able to unmap the low memory and have address 0 non-accessible
in the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.18 2011/12/13 15:23:51 aoyama Exp $	*/
d43 2
d82 1
a82 1
	 * Switch to our final trap vectors.
d85 1
@


1.18
log
@Fix auto-boot failure problem.  The controller name should be a
complete device name for auto-boot check.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.17 2010/11/18 21:13:19 miod Exp $	*/
d80 7
a90 1
	cold = 0;
d136 2
a137 1
		}
@


1.17
log
@Do not #include <sys/dkstat.h> if you don't need anything from it.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.16 2009/10/26 20:17:27 deraadt Exp $	*/
d160 1
a160 1
                if (strcmp(autoboot.cont, spcsc->dv_cfdata->cf_driver->cd_name) == 0 &&
@


1.16
log
@Do not do strncmp comparisons on dv_xname because longer device names which
look similar could arrive in the future.  Instead, compare directly against
dv_cfdata->cf_driver->cd_name
Issue originally spotted by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.15 2009/03/15 20:39:53 miod Exp $	*/
a36 1
#include <sys/dkstat.h>
@


1.15
log
@Generic softinterrupt support for m88k based platforms, adapted from arm
with different locking mechanism. 88110 soft ipi are replaced with an
ipi callback which is checked upon return from exception (it can not be kept
as a softintr, as the generic softinterrupt code doesn't have per-cpu
pending softintr queues).
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.14 2008/07/21 04:35:54 todd Exp $	*/
d154 2
a155 2
        if (strncmp("sd", dev->dv_xname, 2) == 0 ||
            strncmp("cd", dev->dv_xname, 2) == 0) {
d161 1
a161 1
                if (strncmp(autoboot.cont, spcsc->dv_xname, 4) == 0 &&
@


1.14
log
@nam2blk[] needs a "vnd" entry for some things (like softraid)
ok marco@@ no objection miod@@ need this for regress djm@@ no objection krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.13 2007/10/13 12:55:21 miod Exp $	*/
d75 1
@


1.13
log
@Enable interrupts in secondary processors before invoking cpu_switchto(),
rather the expecting it to do this for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.12 2007/06/15 01:19:08 deraadt Exp $	*/
d174 1
@


1.12
log
@no need to include machine/disklabel.h when sys/disklabel.h is already
pulled in.
look at how doing it in one architecture gets that code copied to the
derivative architectures... amazing..
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 2007/06/01 19:25:10 deraadt Exp $	*/
a80 3
	 *
	 * XXX We have a race here. If we enable interrupts after setroot(),
	 * the kernel dies.
@


1.11
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.11 2007/06/01 19:20:46 deraadt Exp $	*/
a46 1
#include <machine/disklabel.h>
@


1.10
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.9 2007/05/04 03:44:44 deraadt Exp $	*/
d88 2
d91 3
a96 1

a97 2

	cold = 0;
@


1.9
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.8 2006/11/28 16:56:50 dlg Exp $	*/
d172 1
a172 4
static struct {
	char	*name;
	int	maj;
} nam2blk[] = {
d176 1
a177 23

int
findblkmajor(struct device *dv)
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)))
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}
@


1.8
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.7 2006/01/26 07:11:08 miod Exp $	*/
a60 2
struct	device *parsedisk(char *, int, int, dev_t *);
void	setroot(void);
a61 1
int	findblkmajor(struct device *);
a62 1
struct device *getdisk(char *, int, int, dev_t *);
a87 115
	setroot();
	dumpconf();

	cold = 0;
}

struct nam2blk {
	char *name;
	int maj;
} nam2blk[] = {
	{ "sd",	4 },
	{ "st",	5 },
	{ "rd",	7 },
};

int
findblkmajor(dv)
	struct device *dv;
{
	char *name = dv->dv_xname;
	int i;

	for (i = 0; i < sizeof(nam2blk)/sizeof(nam2blk[0]); ++i)
		if (strncmp(name, nam2blk[i].name, strlen(nam2blk[0].name)) == 0)
			return (nam2blk[i].maj);
	return (-1);
}

struct device *
getdisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of:");
		TAILQ_FOREACH(dv, &alldevs, dv_list) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-p]", dv->dv_xname);
#ifdef NFSCLIENT
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf("\n");
	}
	return (dv);
}

struct device *
parsedisk(str, len, defpart, devp)
	char *str;
	int len, defpart;
	dev_t *devp;
{
	struct device *dv;
	char *cp, c;
	int majdev, unit, part;

	if (len == 0)
		return (NULL);
	cp = str + len - 1;
	c = *cp;
	if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
		part = c - 'a';
		*cp = '\0';
	} else
		part = defpart;

	TAILQ_FOREACH(dv, &alldevs, dv_list) {
		if (dv->dv_class == DV_DISK &&
		    strcmp(str, dv->dv_xname) == 0) {
			majdev = findblkmajor(dv);
			unit = dv->dv_unit;
			if (majdev < 0)
				panic("parsedisk");
			*devp = MAKEDISKDEV(majdev, unit, part);
			break;
		}
#ifdef NFSCLIENT
		if (dv->dv_class == DV_IFNET &&
		    strcmp(str, dv->dv_xname) == 0) {
			*devp = NODEV;
			break;
		}
#endif
	}

	*cp = c;
	return (dv);
}

/*
 * Attempt to find the device from which we were booted.
 * If we can do so, and not instructed not to do so,
 * change rootdev to correspond to the load device.
 *
 * XXX Actually, swap and root must be on the same type of device,
 * (ie. DV_DISK or DV_IFNET) because of how (*mountroot) is written.
 * That should be fixed.
 */
void
setroot()
{
	struct swdevt *swp;
	struct device *dv;
	int len, majdev, unit;
	dev_t nrootdev, nswapdev = NODEV;
	char buf[128];
	dev_t temp;
#if defined(NFSCLIENT)
	extern char *nfsbootdevname;
#endif
d91 1
d93 1
a93 6
	/*
	 * If 'swap generic' and we could not determine the boot device,
	 * ask the user.
	 */
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;
d95 1
a95 150
	if (boothowto & RB_ASKNAME) {
		for (;;) {
			printf("root device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'a' : ' ');
			printf(": ");
			len = getsn(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, 1, &nrootdev);
				if (dv) {
					bootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, 0, &nrootdev);
			if (dv) {
				bootdv = dv;
				break;
			}
		}

		/*
		 * because swap must be on same device as root, for
		 * network devices this is easy.
		 */
		if (bootdv->dv_class == DV_IFNET) {
			goto gotswap;
		}
		for (;;) {
			printf("swap device ");
			if (bootdv != NULL)
				printf("(default %s%c)",
				    bootdv->dv_xname,
				    bootdv->dv_class == DV_DISK ? 'b' : ' ');
			printf(": ");
			len = getsn(buf, sizeof(buf));
			if (len == 0 && bootdv != NULL) {
				switch (bootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					break;
				case DV_TAPE:
				case DV_TTY:
				case DV_DULL:
				case DV_CPU:
					break;
				}
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				break;
			}
		}
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else if (mountroot == NULL) {
		/*
		 * `swap generic': Use the device the ROM told us to use.
		 */
		if (bootdv == NULL)
			panic("boot device not known");

		majdev = findblkmajor(bootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on a disk.
			 * val[2] of the boot device is the partition number.
			 * Assume swap is on partition b.
			 */
			unit = bootdv->dv_unit;
			rootdev = MAKEDISKDEV(majdev, unit, bootpart);
			nswapdev = dumpdev = MAKEDISKDEV(major(rootdev),
			    DISKUNIT(rootdev), 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			nswapdev = dumpdev = NODEV;
		}
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
	} else {
		/*
		 * `root DEV swap DEV': honour rootdev/swdevt.
		 * rootdev/swdevt/mountroot already properly set.
		 */
		return;
	}

	switch (bootdv->dv_class) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = bootdv->dv_xname;
		return;
#endif
#if defined(FFS)
	case DV_DISK:
		mountroot = dk_mountroot;
		majdev = major(rootdev);
		unit = DISKUNIT(rootdev);
		printf("root on %s%c\n", bootdv->dv_xname,
		    DISKPART(rootdev) + 'a');
		break;
#endif
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	temp = NODEV;
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (majdev == major(swp->sw_dev) &&
		    unit == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev == NODEV)
		return;

	/*
	 * If dumpdev was the same as the old primary swap device, move
	 * it to the new primary swap device.
	 */
	if (temp == dumpdev)
		dumpdev = swdevt[0].sw_dev;
d170 32
@


1.7
log
@Switch to __HAVE_DEVICE_REGISTER to find the device we're booted from.
Tested by aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.6 2005/12/27 18:31:09 miod Exp $	*/
d429 1
a429 1
		struct scsibus_attach_args *sa = aux;
@


1.6
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.5 2005/04/30 16:42:33 miod Exp $	*/
d50 3
d65 1
d368 74
@


1.5
log
@Remove m88k_psr_type and function with utterly long names to control the psr,
and use get_psr() / set_psr() or simple macros that expand into them everywhere.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.4 2004/12/25 23:02:24 miod Exp $	*/
a59 1
void	swapconf(void);
d89 1
a89 1
	swapconf();
a91 22
}

/*
 * Configure swap space and related parameters.
 */
void
swapconf()
{
	struct swdevt *swp;
	int nblks;

	for (swp = swdevt; swp->sw_dev != NODEV; swp++)
		if (bdevsw[major(swp->sw_dev)].d_psize) {
			nblks =
			    (*bdevsw[major(swp->sw_dev)].d_psize)(swp->sw_dev);
			if (nblks != -1 &&
			    (swp->sw_nblks == 0 || swp->sw_nblks > nblks))
				swp->sw_nblks = nblks;
			swp->sw_nblks = ctod(dtoc(swp->sw_nblks));
		}

	dumpconf();
@


1.4
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.3 2004/07/23 15:31:35 miod Exp $	*/
d87 1
a87 1
	enable_interrupt();
@


1.3
log
@Nuke getdevunit().
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.2 2004/05/04 15:27:15 miod Exp $	*/
d149 1
a149 2
		for (dv = alldevs.tqh_first; dv != NULL;
		    dv = dv->dv_list.tqe_next) {
d182 1
a182 1
	for (dv = alldevs.tqh_first; dv != NULL; dv = dv->dv_list.tqe_next) {
@


1.2
log
@Always ask the user for the root device if we are "swap generic" and the
boot device is not known, as other arches do.
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.1.1.1 2004/04/21 15:23:58 aoyama Exp $	*/
a63 1
struct device *getdevunit(char *name, int unit);
a116 5
/*
 * the rest of this file was adapted from Theo de Raadt's code in the
 * sparc port to nuke the "options GENERIC" stuff.
 */

a387 28
}

/*
 * find a device matching "name" and unit number
 */
struct device *
getdevunit(name, unit)
	char *name;
	int unit;
{
	struct device *dev = alldevs.tqh_first;
	char num[10], fullname[16];
	int lunit;

	/* compute length of name and decimal expansion of unit number */
	snprintf(num, sizeof num, "%d", unit);
	lunit = strlen(num);
	if (strlen(name) + lunit >= sizeof(fullname) - 1)
		panic("config_attach: device name too long");

	strlcpy(fullname, name, sizeof fullname);
	strlcat(fullname, num, sizeof fullname);

	while (strcmp(dev->dv_xname, fullname) != 0) {
		if ((dev = dev->dv_list.tqe_next) == NULL)
			return NULL;
	}
	return dev;
@


1.2.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD: autoconf.c,v 1.25 2004/02/11 20:41:08 miod Exp $	*/
d236 7
@


1.1.1.1
log
@Initial commit for OpenBSD/luna88k, based on OpenBSD/mvme88k, NetBSD/luna68k and CMU Mach.
@
text
@@
