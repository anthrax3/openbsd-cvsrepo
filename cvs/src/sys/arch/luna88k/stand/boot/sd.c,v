head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.14
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.10
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.6
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.8
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.5
date	2014.07.12.21.03.38;	author tedu;	state Exp;
branches;
next	1.4;
commitid	BPzam5MbotE66TAj;

1.4
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.3;
commitid	uKVPYMN2MLxdZxzH;

1.3
date	2013.10.29.21.49.07;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.29.18.51.37;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.28.22.13.13;	author miod;	state Exp;
branches;
next	;


desc
@@


1.5
log
@revert a few stragglers hiding out
@
text
@/*	$OpenBSD: sd.c,v 1.4 2014/07/12 18:44:42 tedu Exp $	*/
/*	$NetBSD: sd.c,v 1.5 2013/01/22 15:48:40 tsutsui Exp $	*/

/*
 * Copyright (c) 1992 OMRON Corporation.
 *
 * This code is derived from software contributed to Berkeley by
 * OMRON Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)sd.c	8.1 (Berkeley) 6/10/93
 */
/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * OMRON Corporation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)sd.c	8.1 (Berkeley) 6/10/93
 */

/*
 * sd.c -- SCSI DISK device driver
 * by A.Fujita, FEB-26-1992
 */


/*
 * SCSI CCS (Command Command Set) disk driver.
 */
#include <sys/param.h>
#include <sys/disklabel.h>
#include <luna88k/stand/boot/samachdep.h>
#include <luna88k/stand/boot/scsireg.h>
#include <luna88k/stand/boot/scsivar.h>

struct	sd_softc {
	uint	sc_ctlr;
	uint	sc_tgt;
	uint	sc_part;

	short	sc_type;	/* drive type */
	short	sc_punit;	/* physical unit (scsi lun) */
	u_short	sc_bshift;	/* convert device blocks to DEV_BSIZE blks */
	daddr32_t sc_blks;	/* number of blocks on device */
	int	sc_blksize;	/* device block size in bytes */

	struct disklabel sc_label;
	struct scsi_softc sc_sc;
};

struct sd_softc *sdinit(uint, uint);
static int sdident(struct sd_softc *);

static struct scsi_inquiry inqbuf;
static struct scsi_generic_cdb inq = {
	6,
	{ CMD_INQUIRY, 0, 0, 0, sizeof(inqbuf), 0 }
};

static u_long capbuf[2];
struct scsi_generic_cdb cap = {
	10,
	{ CMD_READ_CAPACITY, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
};

int
sdident(struct sd_softc *sc)
{
#ifdef DEBUG
	char idstr[32];
#endif
	uint ctlr, target, unit;
	int i;
	int tries = 10;

	ctlr = sc->sc_ctlr;
	target = sc->sc_tgt;
	unit = sc->sc_punit;

	if (scinit(&sc->sc_sc, ctlr) == 0)
		return -1;

	/*
	 * See if unit exists and is a disk then read block size & nblocks.
	 */
	while ((i = scsi_test_unit_rdy(&sc->sc_sc, target, unit)) != 0) {
		if (i < 0 || --tries < 0)
			return (-1);
		if (i == STS_CHECKCOND) {
			u_char sensebuf[8];
			struct scsi_xsense *sp = (struct scsi_xsense *)sensebuf;

			scsi_request_sense(&sc->sc_sc, target, unit, sensebuf,
			    sizeof sensebuf);
			if (sp->class == 7 && sp->key == 6)
				/* drive doing an RTZ -- give it a while */
				DELAY(1000000);
		}
		DELAY(1000);
	}
	if (scsi_immed_command(&sc->sc_sc, target, unit, &inq,
	    (u_char *)&inqbuf, sizeof(inqbuf)) ||
	    scsi_immed_command(&sc->sc_sc, target, unit, &cap,
	    (u_char *)&capbuf, sizeof(capbuf)))
		/* doesn't exist or not a CCS device */
		return (-1);

	switch (inqbuf.type) {
	case 0:		/* disk */
	case 4:		/* WORM */
	case 5:		/* CD-ROM */
	case 7:		/* Magneto-optical */
		break;
	default:	/* not a disk */
		return (-1);
	}
	sc->sc_blks    = capbuf[0];
	sc->sc_blksize = capbuf[1];

#ifdef DEBUG
	memcpy(idstr, &inqbuf.vendor_id, 28);
	for (i = 27; i > 23; --i)
		if (idstr[i] != ' ')
			break;
	idstr[i+1] = 0;
	for (i = 23; i > 7; --i)
		if (idstr[i] != ' ')
			break;
	idstr[i+1] = 0;
	for (i = 7; i >= 0; --i)
		if (idstr[i] != ' ')
			break;
	idstr[i+1] = 0;
	printf("sd(%d,%d): %s %s rev %s", ctlr, target, idstr, &idstr[8],
	       &idstr[24]);

	printf(", %d bytes/sect x %d sectors\n", sc->sc_blksize, sc->sc_blks);
#endif
	if (sc->sc_blksize != DEV_BSIZE) {
		if (sc->sc_blksize < DEV_BSIZE) {
			printf("sd(%d,%d): need %d byte blocks - drive ignored\n",
			    ctlr, target, DEV_BSIZE);
			return (-1);
		}
		for (i = sc->sc_blksize; i > DEV_BSIZE; i >>= 1)
			++sc->sc_bshift;
		sc->sc_blks <<= sc->sc_bshift;
	}
	return(inqbuf.type);
}

struct sd_softc *
sdinit(uint unit, uint part)
{
	struct sd_softc *sc;
	struct disklabel *lp;
	char *msg;

	sc = alloc(sizeof *sc);
	if (sc == NULL)
		return NULL;

	memset(sc, 0, sizeof *sc);

	sc->sc_ctlr = unit / 10;
	sc->sc_tgt = unit % 10;
	sc->sc_part = part;
#ifdef DEBUG
	printf("sdinit: ctlr = %d tgt = %d part = %d\n",
	    sc->sc_ctlr, sc->sc_tgt, sc->sc_part);
#endif
	sc->sc_punit = 0;	/* XXX no LUN support yet */
	sc->sc_type = sdident(sc);
	if (sc->sc_type < 0)
		return(NULL);

	/*
	 * Use the default sizes until we've read the label,
	 * or longer if there isn't one there.
	 */
	lp = &sc->sc_label;

	if (lp->d_secpercyl == 0) {
		lp->d_secsize = DEV_BSIZE;
		lp->d_nsectors = 32;
		lp->d_ntracks = 20;
		lp->d_secpercyl = 32*20;
		lp->d_npartitions = 1;
		lp->d_partitions[0].p_offset = 0;
		lp->d_partitions[0].p_size = LABELSECTOR + 1;
	}

	/*
	 * read disklabel
	 */
	msg = readdisklabel(&sc->sc_sc, sc->sc_tgt, lp);
	if (msg != NULL)
		printf("sd(%d,%d): %s\n", sc->sc_ctlr, sc->sc_tgt, msg);

	return sc;
}

int
sdopen(struct open_file *f, ...)
{
	va_list ap;
	struct sd_softc *sc;
	int unit, part;

	va_start(ap, f);
	unit = va_arg(ap, int);
	part = va_arg(ap, int);
	va_end(ap);

	if (part < 0 || part >= MAXPARTITIONS)
		return(-1);

	sc = sdinit(unit, part);
	if (sc == NULL)
		return -1;

	f->f_devdata = (void *)sc;
	return 0;
}

int
sdclose(struct open_file *f)
{
	struct sd_softc *sc = f->f_devdata;

	free(sc, sizeof *sc);
	f->f_devdata = NULL;

	return 0;
}

static struct scsi_generic_cdb cdb_read = {
	10,
	{ CMD_READ_EXT,  0, 0, 0, 0, 0, 0, 0, 0, 0 }
};

static struct scsi_generic_cdb cdb_write = {
	6,
	{ CMD_WRITE_EXT, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
};

int
sdstrategy(void *devdata, int func, daddr32_t dblk, size_t size, void *v_buf,
    size_t *rsize)
{
	struct sd_softc *sc = devdata;
	struct disklabel *lp;
	uint8_t *buf = v_buf;
	int target = sc->sc_tgt;
	struct scsi_generic_cdb *cdb;
	daddr32_t blk;
	u_int nblk  = size >> sc->sc_bshift;
	int stat;
#ifdef DEBUG
	int i;
#endif

	lp = &sc->sc_label;
	blk = dblk + (lp->d_partitions[sc->sc_part].p_offset >> sc->sc_bshift);

	if (func == F_READ)
		cdb = &cdb_read;
	else
		cdb = &cdb_write;

	cdb->cdb[2] = (blk & 0xff000000) >> 24;
	cdb->cdb[3] = (blk & 0x00ff0000) >> 16;
	cdb->cdb[4] = (blk & 0x0000ff00) >>  8;
	cdb->cdb[5] = (blk & 0x000000ff);

	cdb->cdb[7] = ((nblk >> _DEV_BSHIFT) & 0xff00) >> 8;
	cdb->cdb[8] = ((nblk >> _DEV_BSHIFT) & 0x00ff);

#ifdef DEBUG
	printf("sdstrategy(%d,%d): blk = %lu (0x%lx), nblk = %u (0x%x)\n",
	    sc->sc_ctlr, sc->sc_tgt, (u_long)blk, (long)blk, nblk, nblk);
	for (i = 0; i < 10; i++)
		printf("cdb[%d] = 0x%x\n", i, cdb->cdb[i]);
#endif
	stat = scsi_immed_command(&sc->sc_sc, target, sc->sc_punit, cdb, buf,
	    size);
	if (rsize)
		*rsize = size;

	return 0;
}
@


1.4
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.3 2013/10/29 21:49:07 miod Exp $	*/
d284 1
a284 1
	free(sc, sizeof *sc, 0);
@


1.3
log
@More cleanups:
- accept empty controller and partition numbers, as well as empty filenames,
  and use defaults (0, 0 and "bsd") instead of complaining the boot path
  is invalid.
- do not attempt to detect and report devices at boot, using a small
  list of possible devices (only scsi id #6 and #5, come on!).
  Instead, parse the user-supplied boot string to figure out which controller
  and device to talk to. (still no SCSI LUN support, though).

Because of the last change, SCSI unit numbers ought to match the PROM
numbering now (10 * controller + 6 - device id).

Crank version to 0.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.2 2013/10/29 18:51:37 miod Exp $	*/
d284 1
a284 1
	free(sc, sizeof *sc);
@


1.2
log
@More cleanup and unused code or data removal.

Constify the bitmap font.

Bound check sd() numbers instead of accessing an array out of bounds (noticed
by aoyama@@).

Use the same SCSI select timeout as the kernel does (250ms instead of 2ms).
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.1 2013/10/28 22:13:13 miod Exp $	*/
d87 1
a87 1
#include <luna88k/stand/boot/device.h>
d89 4
a92 1
struct	disklabel sdlabel[NSD];
a93 3
struct	sd_softc {
	struct	hp_device *sc_hd;
	short	sc_flags;
d97 1
a97 1
	u_int	sc_blks;	/* number of blocks on device */
a98 1
};
d100 2
a101 3
struct sd_devdata {
	int	unit;		/* drive number */
	int	part;		/* partition */
d104 2
a105 15
int sdinit(void *);
int sdident(struct sd_softc *, struct hp_device *);

struct	driver sddriver = {
	sdinit, "sd"
};

struct sd_softc sd_softc[NSD];
struct sd_devdata sd_devdata[NSD];

/* sc_flags values */
#define	SDF_ALIVE	0x1

#define	sdunit(x)	((minor(x) >> 3) & 0x7)
#define sdpart(x)	(minor(x) & 0x7)
d108 1
a108 1
static struct scsi_fmt_cdb inq = {
d114 1
a114 1
struct scsi_fmt_cdb cap = {
d120 1
a120 1
sdident(struct sd_softc *sc, struct hp_device *hd)
d122 1
d124 2
a125 2
	int unit;
	int ctlr, slave;
d129 2
a130 2
	ctlr = hd->hpd_ctlr;
	slave = hd->hpd_slave;
d133 3
d139 1
a139 1
	while ((i = scsi_test_unit_rdy(ctlr, slave, unit)) != 0) {
d146 2
a147 1
			scsi_request_sense(ctlr, slave, unit, sensebuf, 8);
d154 4
a157 4
	if (scsi_immed_command(ctlr, slave, unit, &inq, (u_char *)&inqbuf,
			       sizeof(inqbuf)) ||
	    scsi_immed_command(ctlr, slave, unit, &cap, (u_char *)&capbuf,
			       sizeof(capbuf)))
d173 1
d187 1
a187 1
	printf("sd%d: %s %s rev %s", hd->hpd_unit, idstr, &idstr[8],
d191 1
d194 2
a195 2
			printf("sd%d: need %d byte blocks - drive ignored\n",
				unit, DEV_BSIZE);
d205 2
a206 2
int
sdinit(void *arg)
d208 1
a208 2
	struct hp_device *hd = arg;
	struct sd_softc *sc = &sd_softc[hd->hpd_unit];
d212 9
d222 2
a223 3
	printf("sdinit: hd->hpd_unit = %d\n", hd->hpd_unit);
	printf("sdinit: hd->hpd_ctlr = %d, hd->hpd_slave = %d\n",
	       hd->hpd_ctlr, hd->hpd_slave);
a224 1
	sc->sc_hd = hd;
d226 1
a226 1
	sc->sc_type = sdident(sc, hd);
d228 1
a228 1
		return(0);
d234 1
a234 1
	lp = &sdlabel[hd->hpd_unit];
d249 1
a249 1
	msg = readdisklabel(hd->hpd_ctlr, hd->hpd_slave, lp);
d251 1
a251 1
		printf("sd%d: %s\n", hd->hpd_unit, msg);
d253 1
a253 2
	sc->sc_flags = SDF_ALIVE;
	return(1);
d260 1
a260 1
	struct sd_devdata *sd;
d268 1
a268 3
	if (unit < 0 || unit >= NSD)
		return(-1);
	if (part < 0 || part >= 8)
d271 3
a273 4
	sd = &sd_devdata[unit];
	sd->unit = unit;
	sd->part = part;
	f->f_devdata = (void *)sd;
d275 1
d282 1
a282 1
	struct sd_devdata *sd = f->f_devdata;
d284 1
a284 2
	sd->unit = -1;
	sd->part = -1;
d290 1
a290 1
static struct scsi_fmt_cdb cdb_read = {
d295 1
a295 1
static struct scsi_fmt_cdb cdb_write = {
d304 1
a304 1
	struct sd_devdata *sd = devdata;
d307 2
a308 4
	int unit = sd->unit;
	int part = sd->part;
	struct sd_softc *sc = &sd_softc[unit];
	struct scsi_fmt_cdb *cdb;
d311 1
a311 1
	int stat, ctlr, slave;
d316 2
a317 8
	if (unit < 0 || unit >= NSD)
		return(-1);

	ctlr  = sc->sc_hd->hpd_ctlr;
	slave = sc->sc_hd->hpd_slave;

	lp = &sdlabel[unit];
	blk = dblk + (lp->d_partitions[part].p_offset >> sc->sc_bshift);
d333 2
a334 2
	printf("sdstrategy: unit = %d\n", unit);
	printf("sdstrategy: blk = %lu (0x%lx), nblk = %u (0x%x)\n", (u_long)blk, (long)blk, nblk, nblk);
d336 1
a336 2
		printf("sdstrategy: cdb[%d] = 0x%x\n", i, cdb->cdb[i]);
	printf("sdstrategy: ctlr = %d, slave = %d\n", ctlr, slave);
d338 2
a339 1
	stat = scsi_immed_command(ctlr, slave, sc->sc_punit, cdb, buf, size);
@


1.1
log
@The first steps of a native OpenBSD/luna88k bootloader. Able to boot ELF
kernels with symbols from disk or network.
Based upon the NetBSD/luna68k bootloader which got recently overhauled from
4.3BSD (thanks, tsutsui@@ !), updated to match the luna88k hardware layout
and turned into a polling-only binary.
Tested on luna88k (not -2) only so far.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a92 2
	struct	devqueue sc_dq;
	int	sc_format_pid;	/* process using "format" mode */
a98 1
	u_int	sc_wpms;	/* average xfer rate in 16 bit wds/sec. */
d106 2
a107 2
static int sdinit(void *);
static int sdident(struct sd_softc *, struct hp_device *);
a120 1
#define	sdpunit(x)	((x) & 7)
d143 2
a144 2
	ctlr = hd->hp_ctlr;
	slave = hd->hp_slave;
d196 1
a196 1
	printf("sd%d: %s %s rev %s", hd->hp_unit, idstr, &idstr[8],
a209 1
	sc->sc_wpms = 32 * (60 * DEV_BSIZE / 2);	/* XXX */
d217 1
a217 1
	struct sd_softc *sc = &sd_softc[hd->hp_unit];
d222 3
a224 3
	printf("sdinit: hd->hp_unit = %d\n", hd->hp_unit);
	printf("sdinit: hd->hp_ctlr = %d, hd->hp_slave = %d\n",
	       hd->hp_ctlr, hd->hp_slave);
d227 1
a227 1
	sc->sc_punit = sdpunit(hd->hp_flags);
d236 1
a236 1
	lp = &sdlabel[hd->hp_unit];
d251 1
a251 1
	msg = readdisklabel(hd->hp_ctlr, hd->hp_slave, lp);
d253 1
a253 1
		printf("sd%d: %s\n", hd->hp_unit, msg);
d327 2
a328 2
	ctlr  = sc->sc_hd->hp_ctlr;
	slave = sc->sc_hd->hp_slave;
@

