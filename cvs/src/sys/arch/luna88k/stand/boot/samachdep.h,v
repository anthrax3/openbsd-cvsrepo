head	1.3;
access;
symbols
	OPENBSD_6_0:1.3.0.12
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.8
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.10
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.6
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.3
date	2013.10.29.21.49.07;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.29.18.51.37;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.28.22.13.13;	author miod;	state Exp;
branches;
next	;


desc
@@


1.3
log
@More cleanups:
- accept empty controller and partition numbers, as well as empty filenames,
  and use defaults (0, 0 and "bsd") instead of complaining the boot path
  is invalid.
- do not attempt to detect and report devices at boot, using a small
  list of possible devices (only scsi id #6 and #5, come on!).
  Instead, parse the user-supplied boot string to figure out which controller
  and device to talk to. (still no SCSI LUN support, though).

Because of the last change, SCSI unit numbers ought to match the PROM
numbering now (10 * controller + 6 - device id).

Crank version to 0.2.
@
text
@/*	$OpenBSD: samachdep.h,v 1.2 2013/10/29 18:51:37 miod Exp $	*/
/*	$NetBSD: samachdep.h,v 1.10 2013/03/05 15:34:53 tsutsui Exp $	*/

/*
 * Copyright (c) 1982, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)samachdep.h	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <lib/libsa/stand.h>

#define MHZ_25		25
#define MHZ_33		33

struct consdev;
typedef struct label_t {
	long val[19];
} label_t;

/* autoconf.c */
void configure(void);
void find_devs(void);

/* awaitkey.c */
char awaitkey(const char *, int, int);

/* bcd.c */
unsigned int bcdtobin(unsigned int);

/* bmc.c */
void bmccnprobe(struct consdev *);
void bmccninit(struct consdev *);
int  bmccngetc(dev_t);
void bmccnputc(dev_t, int);

/* bmd.c */
void bmdinit(void);
int bmdputc(int);
void bmdadjust(short, short);
void bmdclear(void);

/* boot.c */
extern int howto;
int boot(int, char **);
int bootunix(char *);

extern void (*cpu_boot)(uint32_t, uint32_t);
extern uint32_t cpu_bootarg1;
extern uint32_t cpu_bootarg2;
#define	BOOT_MAGIC	0xf1abde3f

/* cons.c */
void cninit(void);
int cngetc(void);
void cnputc(int);

/* fault.c */
int badaddr(void *, int);

/* font.c */
extern const u_short bmdfont[][20];

/* getline.c */
int getline(const char *, char *);

/* init_main.c */
extern int cpuspeed;
extern int nplane;
extern int machtype;
extern char default_file[];
extern char fuse_rom_data[];

/* kbd.c */
int kbd_decode(u_char);

/* lance.c */
void *lance_attach(uint, void *, void *, uint8_t *);
void *lance_cookie(uint);
uint8_t *lance_eaddr(void *);
int lance_init(void *);
int lance_get(void *, void *, size_t);
int lance_put(void *, void *, size_t);
int lance_end(void *);

/* locore.S */
extern u_int bootdev;
extern uint16_t dipswitch;
extern volatile uint32_t tick;
int setjmp(label_t *);
void delay(int);

/* prf.c */
int tgetchar(void);

/* parse.c */
int exit_program(int, char **);
int parse(int, char **);
int getargs(char *, char **, int);

/* sc.c */
struct scsi_softc;
int scinit(struct scsi_softc *, uint);
struct scsi_generic_cdb;
int scsi_immed_command(struct scsi_softc *, int, int, struct scsi_generic_cdb *,
    u_char *, unsigned int);
int scsi_request_sense(struct scsi_softc *, int, int, u_char *, unsigned int);
int scsi_test_unit_rdy(struct scsi_softc *, int, int);

/* sd.c */
int sdstrategy(void *, int, daddr32_t, size_t, void *, size_t *);
int sdopen(struct open_file *, ...);
int sdclose(struct open_file *);

/* sio.c */
void _siointr(void);
void siocnprobe(struct consdev *);
void siocninit(struct consdev *);
int  siocngetc(dev_t);
void siocnputc(dev_t, int);
void sioinit(void);

/* ufs_disklabel.c */
char *readdisklabel(struct scsi_softc *, uint, struct disklabel *);

#define DELAY(n)	delay(n)

extern	struct fs_ops file_system_disk[];
extern	int nfsys_disk;
extern	struct fs_ops file_system_nfs[];
@


1.2
log
@More cleanup and unused code or data removal.

Constify the bitmap font.

Bound check sd() numbers instead of accessing an array out of bounds (noticed
by aoyama@@).

Use the same SCSI select timeout as the kernel does (250ms instead of 2ms).
@
text
@d1 1
a1 1
/*	$OpenBSD: samachdep.h,v 1.1 2013/10/28 22:13:13 miod Exp $	*/
a37 3
#define	NSCSI		2
#define NSD		8

a40 2
#define MAXDEVNAME	16

a82 4
/* devopen.c */
extern	u_int opendev;
int atoi(char *);

d90 1
a90 4
int getline(char *, char *);

/* if_le.c */
int leinit(void *);
d103 2
a104 2
void *lance_attach(int, void *, void *, uint8_t *);
void *lance_cookie(int);
d127 7
a133 5
struct scsi_fmt_cdb;
int scsi_immed_command(int, int, int, struct scsi_fmt_cdb *, u_char *,
    unsigned int);
int scsi_request_sense(int, int, int, u_char *, unsigned int);
int scsi_test_unit_rdy(int, int, int);
d149 1
a149 1
char *readdisklabel(int, int, struct disklabel *);
@


1.1
log
@The first steps of a native OpenBSD/luna88k bootloader. Able to boot ELF
kernels with symbols from disk or network.
Based upon the NetBSD/luna68k bootloader which got recently overhauled from
4.3BSD (thanks, tsutsui@@ !), updated to match the luna88k hardware layout
and turned into a polling-only binary.
Tested on luna88k (not -2) only so far.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d96 1
a96 1
extern u_short bmdfont[][20];
a143 1
int scintr(void);
@

