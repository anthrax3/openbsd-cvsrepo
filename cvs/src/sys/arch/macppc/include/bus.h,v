head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.4
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.25.0.6
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.2
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.24.0.4
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.22.0.8
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.4
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.19.0.4
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.2
	OPENBSD_5_0:1.18.0.6
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.4
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.13.0.10
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.8
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.6
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.9
	UBC:1.3.0.2
	UBC_BASE:1.3
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.26
date	2017.05.08.00.27.45;	author dlg;	state Exp;
branches;
next	1.25;
commitid	miRwMNEodfMJO0uz;

1.25
date	2016.05.03.12.23.25;	author dlg;	state Exp;
branches;
next	1.24;
commitid	tgNtZTwIYn6A3yeb;

1.24
date	2015.01.24.20.59.42;	author kettenis;	state Exp;
branches;
next	1.23;
commitid	WxleZDIgtRIxbbnF;

1.23
date	2014.03.29.18.09.29;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2012.12.06.12.35.22;	author mpi;	state Exp;
branches;
next	1.21;

1.21
date	2012.08.30.18.14.26;	author mpi;	state Exp;
branches;
next	1.20;

1.20
date	2012.08.24.10.05.25;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2011.09.27.20.47.30;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.04.12.49.30;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.30.21.39.15;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.26.18.48.55;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2009.05.31.17.42.13;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.04.20.00.42.06;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.07.03.20.37;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.08.19.08.23;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.08.21.52.46;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.23.21.48.24;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2002.10.07.05.39.48;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.15.02.02.43;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.11.03.50.14;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.07.18.08.08;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.14.03.02.50;	author drahn;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.49.06;	author drahn;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.10.31.03.01.15;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.03.06.01.06.11;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	;


desc
@@


1.26
log
@add a BUS_DMA_64BIT flag to bus_dma on all our archs.

this is so drivers can advertise that they can handle 64 dma addresses
to the platform. it may choose to handle dmamaps differently based
on this flag.

tweaks and ok tom@@
ok kettenis@@
@
text
@/*	$OpenBSD: bus.h,v 1.25 2016/05/03 12:23:25 dlg Exp $	*/

/*
 * Copyright (c) 1997 Per Fogelstrom.  All rights reserved.
 * Copyright (c) 1996 Niklas Hallqvist.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _MACHINE_BUS_H_
#define _MACHINE_BUS_H_

#include <machine/pio.h>

#ifdef __STDC__
#define CAT(a,b)	a##b
#define CAT3(a,b,c)	a##b##c
#else
#define CAT(a,b)	a/**/b
#define CAT3(a,b,c)	a/**/b/**/c
#endif

/*
 * Bus access types.
 */
typedef u_long bus_addr_t;
typedef u_long bus_size_t;
typedef u_long bus_space_handle_t;
typedef struct ppc_bus_space *bus_space_tag_t;

struct ppc_bus_space {
	u_int32_t	bus_base;
	u_int32_t	bus_size;
	u_int8_t	bus_io;		/* IO or memory */
};
#define POWERPC_BUS_TAG_BASE(x)  ((x)->bus_base)

extern struct ppc_bus_space ppc_isa_io, ppc_isa_mem;

/*
 * Access methods for bus resources
 */
int	bus_space_map(bus_space_tag_t t, bus_addr_t addr,
	    bus_size_t size, int flags, bus_space_handle_t *bshp);
void	bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size);
int	bus_space_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp);
int	bus_space_alloc(bus_space_tag_t tag, bus_addr_t rstart,
	    bus_addr_t rend, bus_size_t size, bus_size_t alignment,
	    bus_size_t boundary, int flags, bus_addr_t *addrp,
	    bus_space_handle_t *handlep);
void	bus_space_free(bus_space_tag_t tag, bus_space_handle_t handle,
	    bus_size_t size);
paddr_t	bus_space_mmap(bus_space_tag_t, bus_addr_t, off_t, int, int);

#define	BUS_SPACE_MAP_CACHEABLE		0x01
#define	BUS_SPACE_MAP_LINEAR		0x02
#define	BUS_SPACE_MAP_PREFETCHABLE	0x04

/*
 *	void *bus_space_vaddr(bus_space_tag_t, bus_space_handle_t);
 *
 * Get the kernel virtual address for the mapped bus space.
 * Only allowed for regions mapped with BUS_SPACE_MAP_LINEAR.
 */
#define bus_space_vaddr(t, h) ((void *)(h))

#define bus_space_read(n,m)						      \
static __inline CAT3(u_int,m,_t)					      \
CAT(bus_space_read_,n)(bus_space_tag_t bst, bus_space_handle_t bsh,	      \
     bus_addr_t ba)							      \
{									      \
	return CAT3(in,m,rb)((volatile CAT3(u_int,m,_t) *)(bsh + (ba)));      \
}

bus_space_read(1,8)
bus_space_read(2,16)
bus_space_read(4,32)

#define	bus_space_read_8	!!! bus_space_read_8 unimplemented !!!

#define bus_space_write(n,m)						      \
static __inline void							      \
CAT(bus_space_write_,n)(bus_space_tag_t bst, bus_space_handle_t bsh,	      \
     bus_addr_t ba, CAT3(u_int,m,_t) x)					      \
{									      \
	CAT3(out,m,rb)((volatile CAT3(u_int,m,_t) *)(bsh + (ba)), x);	      \
}

bus_space_write(1,8)
bus_space_write(2,16)
bus_space_write(4,32)

#define	bus_space_write_8	!!! bus_space_write_8 unimplemented !!!

#define bus_space_read_raw(n,m)						      \
static __inline CAT3(u_int,m,_t)					      \
CAT(bus_space_read_raw_,n)(bus_space_tag_t bst, bus_space_handle_t bsh,	      \
    bus_addr_t ba)							      \
{									      \
	return CAT(in,m)((volatile CAT3(u_int,m,_t) *)(bsh + (ba)));	      \
}

bus_space_read_raw(1,8)
bus_space_read_raw(2,16)
bus_space_read_raw(4,32)

#define	bus_space_read_raw_8	!!! bus_space_read_raw_8 unimplemented !!!

#define bus_space_write_raw(n,m)					      \
static __inline void							      \
CAT(bus_space_write_raw_,n)(bus_space_tag_t bst, bus_space_handle_t bsh,      \
    bus_addr_t ba, CAT3(u_int,m,_t) x)					      \
{									      \
	CAT(out,m)((volatile CAT3(u_int,m,_t) *)(bsh + (ba)), x);	      \
}

bus_space_write_raw(1,8)
bus_space_write_raw(2,16)
bus_space_write_raw(4,32)

#define	bus_space_write_raw_8	!!! bus_space_write_raw_8 unimplemented !!!

#define bus_space_read_multi(n, m)					      \
static __inline void						       	      \
CAT(bus_space_read_multi_,n)(bus_space_tag_t bst, bus_space_handle_t bsh,     \
    bus_size_t ba, CAT3(u_int,m,_t) *buf, bus_size_t cnt)		      \
{									      \
	while (cnt--)							      \
		*buf++ = CAT(bus_space_read_,n)(bst, bsh, ba);		      \
}

bus_space_read_multi(1,8)
bus_space_read_multi(2,16)
bus_space_read_multi(4,32)

#define	bus_space_read_multi_8	!!! bus_space_read_multi_8 not implemented !!!


#define	bus_space_write_multi_8	!!! bus_space_write_multi_8 not implemented !!!

#define bus_space_write_multi(n, m)					      \
static __inline void								      \
CAT(bus_space_write_multi_,n)(bus_space_tag_t bst, bus_space_handle_t bsh,    \
    bus_size_t ba, const CAT3(u_int,m,_t) *buf, bus_size_t cnt)		      \
{									      \
	while (cnt--)							      \
		CAT(bus_space_write_,n)(bst, bsh, ba, *buf++);		      \
}

bus_space_write_multi(1,8)
bus_space_write_multi(2,16)
bus_space_write_multi(4,32)

#define	bus_space_write_multi_8	!!! bus_space_write_multi_8 not implemented !!!

/*
 *	void bus_space_read_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
 *
 * Read `count' 1, 2, 4, or 8 byte quantities from bus space
 * described by tag/handle and starting at `offset' and copy into
 * buffer provided.
 */
#define __BA(t, h, o) ((void *)((h) + (o)))

static __inline void
bus_space_read_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int8_t *addr, size_t count)
{
	volatile u_int8_t *s = __BA(tag, bsh, offset);

	while (count--)
		*addr++ = *s++;
	__asm volatile("eieio; sync");
}

static __inline void
bus_space_read_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int16_t *addr, size_t count)
{
	volatile u_int16_t *s = __BA(tag, bsh, offset);

	while (count--)
		__asm volatile("lhbrx %0, 0, %1" :
			"=r"(*addr++) : "r"(s++));
	__asm volatile("eieio; sync");
}

static __inline void
bus_space_read_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int32_t *addr, size_t count)
{
	volatile u_int32_t *s = __BA(tag, bsh, offset);

	while (count--)
		__asm volatile("lwbrx %0, 0, %1" :
			"=r"(*addr++) : "r"(s++));
	__asm volatile("eieio; sync");
}

#if 0	/* Cause a link error for bus_space_read_region_8 */
#define	bus_space_read_region_8		!!! unimplemented !!!
#endif


/*
 *	void bus_space_write_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
 *
 * Write `count' 1, 2, 4, or 8 byte quantities from the buffer provided
 * to bus space described by tag/handle starting at `offset'.
 */

static __inline void
bus_space_write_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int8_t *addr, size_t count)
{
	volatile u_int8_t *d = __BA(tag, bsh, offset);

	while (count--)
		*d++ = *addr++;
	__asm volatile("eieio; sync");
}

static __inline void
bus_space_write_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int16_t *addr, size_t count)
{
	volatile u_int16_t *d = __BA(tag, bsh, offset);

	while (count--)
		__asm volatile("sthbrx %0, 0, %1" ::
			"r"(*addr++), "r"(d++));
	__asm volatile("eieio; sync");
}

static __inline void
bus_space_write_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int32_t *addr, size_t count)
{
	volatile u_int32_t *d = __BA(tag, bsh, offset);

	while (count--)
		__asm volatile("stwbrx %0, 0, %1" ::
			"r"(*addr++), "r"(d++));
	__asm volatile("eieio; sync");
}

#if 0
#define	bus_space_write_region_8 !!! bus_space_write_region_8 unimplemented !!!
#endif

/*
 *	void bus_space_read_raw_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
 *
 * Read `count' bytes from bus space described by tag/handle and starting
 * at `offset' and copy into buffer provided w/o bus-host byte swapping.
 */

static __inline void
bus_space_read_raw_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int8_t *addr, size_t count)
{
	volatile u_int16_t *s = __BA(tag, bsh, offset);
	u_int16_t *laddr = (void *)addr;

	count = count >> 1;

	while (count--)
		*laddr++ = *s++;
	__asm volatile("eieio; sync");
}

static __inline void
bus_space_read_raw_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int8_t *addr, size_t count)
{
	volatile u_int32_t *s = __BA(tag, bsh, offset);
	u_int32_t *laddr = (void *)addr;

	count = count >> 2;

	while (count--)
		*laddr++ = *s++;
	__asm volatile("eieio; sync");
}

#if 0	/* Cause a link error for bus_space_read_raw_region_8 */
#define	bus_space_read_raw_region_8	\
    !!! bus_space_read_raw_region_8		unimplemented !!!
#endif


/*
 *	void bus_space_write_raw_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
 *
 * Write `count' bytes from the buffer provided to bus space described
 * by tag/handle starting at `offset' w/o host-bus byte swapping.
 */

static __inline void
bus_space_write_raw_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int8_t *addr, size_t count)
{
	volatile u_int16_t *d = __BA(tag, bsh, offset);
	const u_int16_t *laddr = (void *)addr;

	count = count >> 1;

	while (count--)
		*d++ = *laddr++;
	__asm volatile("eieio; sync");
}

static __inline void
bus_space_write_raw_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int8_t *addr, size_t count)
{
	volatile u_int32_t *d = __BA(tag, bsh, offset);
	const u_int32_t *laddr = (void *)addr;

	count = count >> 2;

	while (count--)
		*d++ = *laddr++;
	__asm volatile("eieio; sync");
}

#if 0
#define	bus_space_write_raw_region_8 \
    !!! bus_space_write_raw_region_8 unimplemented !!!
#endif

/*
 *	void bus_space_set_multi_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset, u_intN_t val,
 *	    size_t count);
 *
 * Write the 1, 2, 4, or 8 byte value `val' to bus space described
 * by tag/handle/offset `count' times.
 */
static __inline void bus_space_set_multi_1(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int8_t, size_t);
static __inline void bus_space_set_multi_2(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int16_t, size_t);
static __inline void bus_space_set_multi_4(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int32_t, size_t);

static __inline void
bus_space_set_multi_1(bus_space_tag_t tag, bus_space_handle_t bsh,
    bus_size_t offset, u_int8_t val, size_t count)
{
	volatile u_int8_t *d = __BA(tag, bsh, offset);

	while (count--)
		*d = val;
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_set_multi_2(bus_space_tag_t tag, bus_space_handle_t bsh,
    bus_size_t offset, u_int16_t val, size_t count)
{
	volatile u_int16_t *d = __BA(tag, bsh, offset);

	while (count--)
		__asm__ volatile("sthbrx %0, 0, %1" ::
			"r"(val), "r"(d));
	__asm__ volatile("eieio; sync");
}

static __inline void
bus_space_set_multi_4(bus_space_tag_t tag, bus_space_handle_t bsh,
    bus_size_t offset, u_int32_t val, size_t count)
{
	volatile u_int32_t *d = __BA(tag, bsh, offset);

	while (count--)
		__asm__ volatile("stwbrx %0, 0, %1" ::
			"r"(val), "r"(d));
	__asm__ volatile("eieio; sync");
}

#define	bus_space_set_multi_8 !!! bus_space_set_multi_8 unimplemented !!!

/* These are OpenBSD extensions to the general NetBSD bus interface.  */
void
bus_space_read_raw_multi_2(bus_space_tag_t bst, bus_space_handle_t bsh,
	bus_addr_t ba, u_int8_t *dst, bus_size_t size);
void
bus_space_read_raw_multi_4(bus_space_tag_t bst, bus_space_handle_t bsh,
	bus_addr_t ba, u_int8_t *dst, bus_size_t size);
#define	bus_space_read_raw_multi_8 \
    !!! bus_space_read_raw_multi_8 not implemented !!!

void
bus_space_write_raw_multi_2(bus_space_tag_t bst, bus_space_handle_t bsh,
	bus_addr_t ba, const u_int8_t *src, bus_size_t size);
void
bus_space_write_raw_multi_4(bus_space_tag_t bst, bus_space_handle_t bsh,
	bus_addr_t ba, const u_int8_t *src, bus_size_t size);
#define	bus_space_write_raw_multi_8 \
    !!! bus_space_write_raw_multi_8 not implemented !!!

void
bus_space_set_region_1(bus_space_tag_t bst, bus_space_handle_t h, bus_size_t o,
    u_int8_t val, bus_size_t c);
void
bus_space_set_region_2(bus_space_tag_t bst, bus_space_handle_t h, bus_size_t o,
    u_int16_t val, bus_size_t c);
void
bus_space_set_region_4(bus_space_tag_t bst, bus_space_handle_t h, bus_size_t o,
    u_int32_t val, bus_size_t c);
#define	bus_space_set_region_8 \
    !!! bus_space_set_region_8 not implemented !!!

void
bus_space_copy_1(void *v, bus_space_handle_t h1, bus_space_handle_t h2,
    bus_size_t o1, bus_size_t o2, bus_size_t c);
void
bus_space_copy_2(void *v, bus_space_handle_t h1, bus_space_handle_t h2,
    bus_size_t o1, bus_size_t o2, bus_size_t c);
void
bus_space_copy_4(void *v, bus_space_handle_t h1, bus_space_handle_t h2,
    bus_size_t o1, bus_size_t o2, bus_size_t c);
#define	bus_space_copy_8 \
    !!! bus_space_copy_8 not implemented !!!

/*
 * Bus read/write barrier methods.
 *
 *	void bus_space_barrier(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    bus_size_t len, int flags);
 * 
 * Note: powerpc does not currently implement barriers, but we must
 * provide the flags to MI code.
 * the processor does have eieio which is effectively the barrier
 * operator, however due to how memory is mapped this should? not
 * be required.
 */
#define bus_space_barrier(t, h, o, l, f)	\
	((void)((void)(t), (void)(h), (void)(o), (void)(l), (void)(f)))  
#define BUS_SPACE_BARRIER_READ  0x01		/* force read barrier */ 
#define BUS_SPACE_BARRIER_WRITE 0x02		/* force write barrier */

#define	BUS_DMA_WAITOK		0x0000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x0001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x0002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x0008	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x0010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x0020
#define	BUS_DMA_BUS3		0x0040
#define	BUS_DMA_BUS4		0x0080
#define	BUS_DMA_READ		0x0100	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x0200	/* mapping is memory -> device only */
#define	BUS_DMA_STREAMING	0x0400	/* hint: sequential, unidirectional */
#define	BUS_DMA_ZERO		0x0800	/* zero memory in dmamem_alloc */
#define	BUS_DMA_NOCACHE		0x1000	/* map memory uncached */
#define	BUS_DMA_64BIT		0x2000	/* device handles 64bit dva */


/* Forwards needed by prototypes below. */
struct mbuf;
struct proc;
struct uio;

#define BUS_DMASYNC_POSTREAD	0x01
#define BUS_DMASYNC_POSTWRITE	0x02
#define BUS_DMASYNC_PREREAD	0x04
#define BUS_DMASYNC_PREWRITE	0x08

typedef struct powerpc_bus_dma_tag	*bus_dma_tag_t;
typedef struct powerpc_bus_dmamap	*bus_dmamap_t;

/*
 *	bus_dma_segment_t
 *
 *	Describes a single contiguous DMA transaction.  Values
 *	are suitable for programming into DMA registers.
 */
struct powerpc_bus_dma_segment {
	bus_addr_t	ds_addr;	/* DMA address */
	bus_size_t	ds_len;		/* length of transfer */
};
typedef struct powerpc_bus_dma_segment	bus_dma_segment_t;

/*
 *	bus_dma_tag_t
 *
 *	A machine-dependent opaque type describing the implementation of
 *	DMA for a given bus.
 */

struct powerpc_bus_dma_tag {
	void	*_cookie;		/* cookie used in the guts */

	/*
	 * DMA mapping methods.
	 */
	int	(*_dmamap_create)(bus_dma_tag_t , bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t , bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t , bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t , bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t , bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(bus_dma_tag_t , bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	void	(*_dmamap_unload)(bus_dma_tag_t , bus_dmamap_t);
	void	(*_dmamap_sync)(bus_dma_tag_t , bus_dmamap_t,
		    bus_addr_t, bus_size_t, int);

	/*
	 * DMA memory utility functions.
	 */
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	int	(*_dmamem_alloc_range)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int,
		    bus_addr_t, bus_addr_t);
	void	(*_dmamem_free)(bus_dma_tag_t, bus_dma_segment_t *, int);
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int);
};

#define	bus_dmamap_create(t, s, n, m, b, f, p)			\
	(*(t)->_dmamap_create)((t), (s), (n), (m), (b), (f), (p))
#define	bus_dmamap_destroy(t, p)				\
	(*(t)->_dmamap_destroy)((t), (p))
#define	bus_dmamap_load(t, m, b, s, p, f)			\
	(*(t)->_dmamap_load)((t), (m), (b), (s), (p), (f))
#define	bus_dmamap_load_mbuf(t, m, b, f)			\
	(*(t)->_dmamap_load_mbuf)((t), (m), (b), (f))
#define	bus_dmamap_load_uio(t, m, u, f)				\
	(*(t)->_dmamap_load_uio)((t), (m), (u), (f))
#define	bus_dmamap_load_raw(t, m, sg, n, s, f)			\
	(*(t)->_dmamap_load_raw)((t), (m), (sg), (n), (s), (f))
#define	bus_dmamap_unload(t, p)					\
	(*(t)->_dmamap_unload)((t), (p))
#define	bus_dmamap_sync(t, p, a, l, o)				\
	(void)((t)->_dmamap_sync ?				\
	    (*(t)->_dmamap_sync)((t), (p), (a), (l), (o)) : (void)0)

#define	bus_dmamem_alloc(t, s, a, b, sg, n, r, f)		\
	(*(t)->_dmamem_alloc)((t)->_cookie, (s), (a), (b), (sg), (n), (r), (f))
#define	bus_dmamem_alloc_range(t, s, a, b, sg, n, r, f, l, h)	\
	(*(t)->_dmamem_alloc_range)((t), (s), (a), (b), (sg),	\
		(n), (r), (f), (l), (h))
#define	bus_dmamem_free(t, sg, n)				\
	(*(t)->_dmamem_free)((t)->_cookie, (sg), (n))
#define	bus_dmamem_map(t, sg, n, s, k, f)			\
	(*(t)->_dmamem_map)((t)->_cookie, (sg), (n), (s), (k), (f))
#define	bus_dmamem_unmap(t, k, s)				\
	(*(t)->_dmamem_unmap)((t)->_cookie, (k), (s))
#define	bus_dmamem_mmap(t, sg, n, o, p, f)			\
	(*(t)->_dmamem_mmap)((t)->_cookie, (sg), (n), (o), (p), (f))

int	_dmamap_create(bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *);
void	_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t, struct mbuf *, int);
int	_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t, struct uio *, int);
int	_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t, bus_size_t,
	    int);

int	_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t,
	    bus_size_t, bus_dma_segment_t *, int, int *, int);
int	_dmamem_alloc_range( bus_dma_tag_t, bus_size_t, bus_size_t,
	    bus_size_t, bus_dma_segment_t *, int, int *, int,
	    bus_addr_t, bus_addr_t);
void	_dmamem_free(bus_dma_tag_t, bus_dma_segment_t *, int);
int	_dmamem_map(bus_dma_tag_t, bus_dma_segment_t *,
	    int, size_t, caddr_t *, int);
void	_dmamem_unmap(bus_dma_tag_t, caddr_t, size_t);
paddr_t	_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t *, int, off_t, int, int);

/*
 *	bus_dmamap_t
 *
 *	Describes a DMA mapping.
 */
struct powerpc_bus_dmamap {
	/*
	 * PRIVATE MEMBERS: not for use by machine-independent code.
	 */
	bus_size_t	_dm_size;	/* largest DMA transfer mappable */
	int		_dm_segcnt;	/* number of segs this map can map */
	bus_size_t	_dm_maxsegsz;	/* largest possible segment */
	bus_size_t	_dm_boundary;	/* don't cross this */
	int		_dm_flags;	/* misc. flags */

	void		*_dm_cookie;	/* cookie for bus-specific functions */

	/*
	 * PUBLIC MEMBERS: these are used by machine-independent code.
	 */
	bus_size_t	dm_mapsize;	/* size of the mapping */
	int		dm_nsegs;	/* # valid segments in mapping */
	bus_dma_segment_t dm_segs[1];	/* segments; variable length */
};

#endif /* _MACHINE_BUS_H_ */
@


1.25
log
@implement bus_space_read_raw_X and bus_space_write_raw_X

with feedback from kettenis@@

fixes building a kernel with xge, which might actually work on these
machines now.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.24 2015/01/24 20:59:42 kettenis Exp $	*/
d492 1
@


1.24
log
@Implement bus_dmamem_alloc_range(9) for macppc/socppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.23 2014/03/29 18:09:29 guenther Exp $	*/
d120 28
@


1.23
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.22 2012/12/06 12:35:22 mpi Exp $	*/
d524 3
d555 3
d582 3
@


1.22
log
@Implement bus_space_mmap(9).

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.21 2012/08/30 18:14:26 mpi Exp $	*/
d173 1
a173 1
	__asm __volatile("eieio; sync");
d183 1
a183 1
		__asm __volatile("lhbrx %0, 0, %1" :
d185 1
a185 1
	__asm __volatile("eieio; sync");
d195 1
a195 1
		__asm __volatile("lwbrx %0, 0, %1" :
d197 1
a197 1
	__asm __volatile("eieio; sync");
d222 1
a222 1
	__asm __volatile("eieio; sync");
d232 1
a232 1
		__asm __volatile("sthbrx %0, 0, %1" ::
d234 1
a234 1
	__asm __volatile("eieio; sync");
d244 1
a244 1
		__asm __volatile("stwbrx %0, 0, %1" ::
d246 1
a246 1
	__asm __volatile("eieio; sync");
d273 1
a273 1
	__asm __volatile("eieio; sync");
d287 1
a287 1
	__asm __volatile("eieio; sync");
d316 1
a316 1
	__asm __volatile("eieio; sync");
d330 1
a330 1
	__asm __volatile("eieio; sync");
@


1.21
log
@Add the possibility to map DMA memory non-cached, based on the i386/amd64
implementation. For the moment only the BUS_DMA_NOCACHE macro is required
to build drm on macppc but it will be used soon.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.20 2012/08/24 10:05:25 jsg Exp $	*/
d79 1
@


1.20
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.19 2011/09/27 20:47:30 miod Exp $	*/
d84 8
d450 13
a462 12
#define	BUS_DMA_WAITOK		0x000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x002	/* perform resource allocation now */
#define	BUS_DMA_COHERENT	0x008	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x020
#define	BUS_DMA_BUS3		0x040
#define	BUS_DMA_BUS4		0x080
#define BUS_DMA_READ            0x100	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x200	/* mapping is memory -> device only */
#define	BUS_DMA_STREAMING	0x400	/* hint: sequential, unidirectional */
#define	BUS_DMA_ZERO		0x800	/* zero memory in dmamem_alloc */
@


1.19
log
@Make bus_addr_t and bus_size_t u_long types, instead of either uint32_t or
uint64_t, depending upon the platform; this makes the declaration of these
types consistent accross all our supported platform, and we do not intend
to support a platform where bus_addr_t could be larger than the size of the
cpu register. Requested by deraadt@@ during s2k11
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.18 2010/04/04 12:49:30 miod Exp $	*/
d345 2
a346 6
bus_space_set_multi_1(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int8_t val;
	size_t count;
d356 2
a357 6
bus_space_set_multi_2(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int16_t val;
	size_t count;
d368 2
a369 6
bus_space_set_multi_4(tag, bsh, offset, val, count)
	bus_space_tag_t tag;
	bus_space_handle_t bsh;
	bus_size_t offset;
	u_int32_t val;
	size_t count;
@


1.18
log
@OpenBSD uses bus_space_copy_#, not bus_space_copy_region_#. Make sure only the
first name is used, and remove any #define foo_region foo compatibility
defines.
Also, on sparc64, do not provide a `raw' version of bus_space_copy.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.17 2009/07/30 21:39:15 miod Exp $	*/
d50 3
a52 3
typedef u_long    bus_addr_t;
typedef u_int32_t bus_size_t;
typedef u_int32_t bus_space_handle_t;
@


1.17
log
@Get rid of the obsolet BUS_BARRIER_xxx constants for bus_space_barrier(), only
provide and use BUS_SPACE_BARRIER_xxx.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.16 2009/07/26 18:48:55 miod Exp $	*/
d434 1
a434 1
    !!! bus_space_write_raw_multi_8 not implemented !!!
@


1.16
log
@Make sure all platforms understand the flags argument of bus_space_map() and
bus_space_alloc() as a bitmask of flags, and not a boolean controlling
cacheability; and make sure the three MI BUS_SPACE_MAP_xxx values documented
in the manual page are defined on all platforms as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.15 2009/05/31 17:42:13 miod Exp $	*/
a452 4
/* Compatibility defines */
#define BUS_BARRIER_READ        BUS_SPACE_BARRIER_READ
#define BUS_BARRIER_WRITE       BUS_SPACE_BARRIER_WRITE

@


1.15
log
@Remove BUS_DMAMEM_NOSYNC definition. Its name is not consistent with
other BUS_DMA_xxx flag names, and nothing uses it.

ok many@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.14 2009/04/20 00:42:06 oga Exp $	*/
d68 1
a68 1
	    bus_size_t size, int cacheable, bus_space_handle_t *bshp);
d75 1
a75 1
	    bus_size_t boundary, int cacheable, bus_addr_t *addrp,
d79 4
@


1.14
log
@Add a BUS_DMA_ZERO flag for bus_dmamem_alloc() to return zeroed memory.

Saves every damned driver calling bzero(), and continues the M_ZERO,
PR_ZERO symmetry.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.13 2007/02/07 03:20:37 dlg Exp $	*/
a456 1
#define	BUS_DMAMEM_NOSYNC	0x004
@


1.13
log
@bus_space_{read,write}_raw_region_[24] take the length of the buffer theyre
operating on as bytes, not as the number of words or dwords.

ok drahn@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.12 2005/06/08 19:08:23 drahn Exp $	*/
d466 1
@


1.12
log
@Remove the bus_reverse field out of the powerpc bus structure, originally
it was there so that big endian and little endian devices could both be
present, however that is not the case on the macppc machines.
Cleans up code, shrinks the kernel. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.11 2003/10/08 21:52:46 drahn Exp $	*/
d256 2
d270 2
d299 2
d312 2
@


1.11
log
@Fix endian bug in macppc bus_space_set_region_N(). ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.10 2003/06/23 21:48:24 mickey Exp $	*/
a57 1
	u_int8_t	bus_reverse;	/* Reverse bytes */
a84 1
    if(bst->bus_reverse)						      \
a85 2
    else								      \
	return CAT(in,m)((volatile CAT3(u_int,m,_t) *)(bsh + (ba)));	      \
a98 1
    if(bst->bus_reverse)						      \
a99 2
    else								      \
	CAT(out,m)((volatile CAT3(u_int,m,_t) *)(bsh + (ba)), x);	      \
@


1.10
log
@bus_space_*_raw*_1() do not exist; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.9 2002/10/07 05:39:48 drahn Exp $	*/
d408 1
a408 1
bus_space_set_region_1(void *v, bus_space_handle_t h, bus_size_t o,
d411 1
a411 1
bus_space_set_region_2(void *v, bus_space_handle_t h, bus_size_t o,
d414 1
a414 1
bus_space_set_region_4(void *v, bus_space_handle_t h, bus_size_t o,
@


1.9
log
@Improved workaround for cardbus support on macppc. This allows mappings to
be put in the cardbus register which really work instead of crashing the
machine.  if_dc @@cardbus now works, xl@@cardbus will configure, but does
not work properly (endian?) wdc should work fine, but has not been tested
recently.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.8 2002/09/15 09:01:58 deraadt Exp $	*/
d252 2
a253 3
 * Read `count' 1, 2, 4, or 8 byte quantities from bus space
 * described by tag/handle and starting at `offset' and copy into
 * buffer provided.
a256 12
bus_space_read_raw_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int8_t *addr, size_t count)
{
	volatile u_int8_t *s = __BA(tag, bsh, offset);
	u_int8_t *laddr = (void *)addr;

	while (count--)
		*laddr++ = *s++;
	__asm __volatile("eieio; sync");
}

static __inline void
d291 2
a292 2
 * Write `count' 1, 2, 4, or 8 byte quantities from the buffer provided
 * to bus space described by tag/handle starting at `offset'.
a295 12
bus_space_write_raw_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int8_t *addr, size_t count)
{
	volatile u_int8_t *d = __BA(tag, bsh, offset);
	const u_int8_t *laddr = (void *)addr;

	while (count--)
		*d++ = *laddr++;
	__asm __volatile("eieio; sync");
}

static __inline void
a389 3
bus_space_read_raw_multi_1(bus_space_tag_t bst, bus_space_handle_t bsh,
	bus_addr_t ba, u_int8_t *dst, bus_size_t size);
void
a397 3
void
bus_space_write_raw_multi_1(bus_space_tag_t bst, bus_space_handle_t bsh,
	bus_addr_t ba, const u_int8_t *src, bus_size_t size);
@


1.8
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.6 2002/06/11 03:50:14 drahn Exp $	*/
d59 1
@


1.7
log
@KNF
@
text
@d85 1
a85 1
    if (bst->bus_reverse)						      \
d102 1
a102 1
    if (bst->bus_reverse)						      \
d115 1
a115 1
static __inline void							      \
d133 1
a133 1
static __inline void							      \
d479 2
a480 2
#define BUS_BARRIER_READ	BUS_SPACE_BARRIER_READ
#define BUS_BARRIER_WRITE	BUS_SPACE_BARRIER_WRITE
d492 1
a492 1
#define BUS_DMA_READ		0x100	/* mapping is device -> memory only */
@


1.6
log
@Add missing bus_space_read_raw_region_X bus_space_write_raw_region_X APIs.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.5 2002/03/14 01:26:36 millert Exp $	*/
d85 1
a85 1
    if(bst->bus_reverse)						      \
d102 1
a102 1
    if(bst->bus_reverse)						      \
d115 1
a115 1
static __inline void						       	      \
d133 1
a133 1
static __inline void								      \
d479 2
a480 2
#define BUS_BARRIER_READ        BUS_SPACE_BARRIER_READ
#define BUS_BARRIER_WRITE       BUS_SPACE_BARRIER_WRITE
d492 1
a492 1
#define BUS_DMA_READ            0x100	/* mapping is device -> memory only */
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.4 2002/03/07 18:08:08 jason Exp $	*/
d247 102
d447 1
a447 1
    !!! bus_space_write_raw_multi_8 not implemented !!!
@


1.4
log
@Clean up BUS_DMA_* flags, and make sure all arch's define:
BUS_DMA_READ, BUS_DMA_WRITE, and BUS_DMA_STREAMING
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.3 2001/12/14 03:02:50 drahn Exp $	*/
d67 7
a73 7
int	bus_space_map __P((bus_space_tag_t t, bus_addr_t addr,
	    bus_size_t size, int cacheable, bus_space_handle_t *bshp));
void	bus_space_unmap __P((bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size));
int	bus_space_subregion __P((bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp));
int	bus_space_alloc __P((bus_space_tag_t tag, bus_addr_t rstart,
d76 3
a78 3
	    bus_space_handle_t *handlep));
void	bus_space_free __P((bus_space_tag_t tag, bus_space_handle_t handle,
	    bus_size_t size));
d148 1
a148 1
 *	void bus_space_read_region_N __P((bus_space_tag_t tag,
d150 1
a150 1
 *	    u_intN_t *addr, size_t count));
d199 1
a199 1
 *	void bus_space_write_region_N __P((bus_space_tag_t tag,
d201 1
a201 1
 *	    const u_intN_t *addr, size_t count));
d247 1
a247 1
 *	void bus_space_set_multi_N __P((bus_space_tag_t tag,
d249 1
a249 1
 *	    size_t count));
d254 6
a259 6
static __inline void bus_space_set_multi_1 __P((bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int8_t, size_t));
static __inline void bus_space_set_multi_2 __P((bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int16_t, size_t));
static __inline void bus_space_set_multi_4 __P((bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int32_t, size_t));
d336 2
a337 2
bus_space_set_region_1 __P((void *v, bus_space_handle_t h, bus_size_t o,
    u_int8_t val, bus_size_t c));
d339 2
a340 2
bus_space_set_region_2 __P((void *v, bus_space_handle_t h, bus_size_t o,
    u_int16_t val, bus_size_t c));
d342 2
a343 2
bus_space_set_region_4 __P((void *v, bus_space_handle_t h, bus_size_t o,
    u_int32_t val, bus_size_t c));
d348 2
a349 2
bus_space_copy_1 __P((void *v, bus_space_handle_t h1, bus_space_handle_t h2,
    bus_size_t o1, bus_size_t o2, bus_size_t c));
d351 2
a352 2
bus_space_copy_2 __P((void *v, bus_space_handle_t h1, bus_space_handle_t h2,
    bus_size_t o1, bus_size_t o2, bus_size_t c));
d354 2
a355 2
bus_space_copy_4 __P((void *v, bus_space_handle_t h1, bus_space_handle_t h2,
    bus_size_t o1, bus_size_t o2, bus_size_t c));
d362 1
a362 1
 *	void bus_space_barrier __P((bus_space_tag_t tag,
d364 1
a364 1
 *	    bus_size_t len, int flags));
d433 14
a446 14
	int	(*_dmamap_create) __P((bus_dma_tag_t , bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *));
	void	(*_dmamap_destroy) __P((bus_dma_tag_t , bus_dmamap_t));
	int	(*_dmamap_load) __P((bus_dma_tag_t , bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int));
	int	(*_dmamap_load_mbuf) __P((bus_dma_tag_t , bus_dmamap_t,
		    struct mbuf *, int));
	int	(*_dmamap_load_uio) __P((bus_dma_tag_t , bus_dmamap_t,
		    struct uio *, int));
	int	(*_dmamap_load_raw) __P((bus_dma_tag_t , bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int));
	void	(*_dmamap_unload) __P((bus_dma_tag_t , bus_dmamap_t));
	void	(*_dmamap_sync) __P((bus_dma_tag_t , bus_dmamap_t,
		    bus_addr_t, bus_size_t, int));
d451 8
a458 8
	int	(*_dmamem_alloc) __P((bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int));
	void	(*_dmamem_free) __P((bus_dma_tag_t, bus_dma_segment_t *, int));
	int	(*_dmamem_map) __P((bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int));
	void	(*_dmamem_unmap) __P((bus_dma_tag_t, caddr_t, size_t));
	paddr_t	(*_dmamem_mmap) __P((bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int));
d490 20
a509 20
int	_dmamap_create __P((bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *));
void	_dmamap_destroy __P((bus_dma_tag_t, bus_dmamap_t));
int	_dmamap_load __P((bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int));
int	_dmamap_load_mbuf __P((bus_dma_tag_t, bus_dmamap_t, struct mbuf *, int));
int	_dmamap_load_uio __P((bus_dma_tag_t, bus_dmamap_t, struct uio *, int));
int	_dmamap_load_raw __P((bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int));
void	_dmamap_unload __P((bus_dma_tag_t, bus_dmamap_t));
void	_dmamap_sync __P((bus_dma_tag_t, bus_dmamap_t, bus_addr_t, bus_size_t,
	    int));

int	_dmamem_alloc __P((bus_dma_tag_t, bus_size_t, bus_size_t,
	    bus_size_t, bus_dma_segment_t *, int, int *, int));
void	_dmamem_free __P((bus_dma_tag_t, bus_dma_segment_t *, int));
int	_dmamem_map __P((bus_dma_tag_t, bus_dma_segment_t *,
	    int, size_t, caddr_t *, int));
void	_dmamem_unmap __P((bus_dma_tag_t, caddr_t, size_t));
paddr_t	_dmamem_mmap __P((bus_dma_tag_t, bus_dma_segment_t *, int, off_t, int, int));
@


1.3
log
@gem wants BUS_DMA_READ define.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.2 2001/11/05 17:25:58 art Exp $	*/
d381 12
a392 10
#define	BUS_DMA_WAITOK		0x00
#define	BUS_DMA_NOWAIT		0x01
#define	BUS_DMA_ALLOCNOW	0x02
#define	BUS_DMAMEM_NOSYNC	0x04
#define	BUS_DMA_COHERENT	0x08
#define	BUS_DMA_BUS1		0x10	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x20
#define	BUS_DMA_BUS3		0x40
#define	BUS_DMA_BUS4		0x80
#define BUS_DMA_READ            0x100
@


1.3.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.3 2001/12/14 03:02:50 drahn Exp $	*/
d67 7
a73 7
int	bus_space_map(bus_space_tag_t t, bus_addr_t addr,
	    bus_size_t size, int cacheable, bus_space_handle_t *bshp);
void	bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size);
int	bus_space_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp);
int	bus_space_alloc(bus_space_tag_t tag, bus_addr_t rstart,
d76 3
a78 3
	    bus_space_handle_t *handlep);
void	bus_space_free(bus_space_tag_t tag, bus_space_handle_t handle,
	    bus_size_t size);
d148 1
a148 1
 *	void bus_space_read_region_N(bus_space_tag_t tag,
d150 1
a150 1
 *	    u_intN_t *addr, size_t count);
d199 1
a199 1
 *	void bus_space_write_region_N(bus_space_tag_t tag,
d201 1
a201 1
 *	    const u_intN_t *addr, size_t count);
d247 1
a247 1
 *	void bus_space_set_multi_N(bus_space_tag_t tag,
d249 1
a249 1
 *	    size_t count);
d254 6
a259 6
static __inline void bus_space_set_multi_1(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int8_t, size_t);
static __inline void bus_space_set_multi_2(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int16_t, size_t);
static __inline void bus_space_set_multi_4(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d336 2
a337 2
bus_space_set_region_1(void *v, bus_space_handle_t h, bus_size_t o,
    u_int8_t val, bus_size_t c);
d339 2
a340 2
bus_space_set_region_2(void *v, bus_space_handle_t h, bus_size_t o,
    u_int16_t val, bus_size_t c);
d342 2
a343 2
bus_space_set_region_4(void *v, bus_space_handle_t h, bus_size_t o,
    u_int32_t val, bus_size_t c);
d348 2
a349 2
bus_space_copy_1(void *v, bus_space_handle_t h1, bus_space_handle_t h2,
    bus_size_t o1, bus_size_t o2, bus_size_t c);
d351 2
a352 2
bus_space_copy_2(void *v, bus_space_handle_t h1, bus_space_handle_t h2,
    bus_size_t o1, bus_size_t o2, bus_size_t c);
d354 2
a355 2
bus_space_copy_4(void *v, bus_space_handle_t h1, bus_space_handle_t h2,
    bus_size_t o1, bus_size_t o2, bus_size_t c);
d362 1
a362 1
 *	void bus_space_barrier(bus_space_tag_t tag,
d364 1
a364 1
 *	    bus_size_t len, int flags);
d381 10
a390 12
#define	BUS_DMA_WAITOK		0x000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x002	/* perform resource allocation now */
#define	BUS_DMAMEM_NOSYNC	0x004
#define	BUS_DMA_COHERENT	0x008	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x020
#define	BUS_DMA_BUS3		0x040
#define	BUS_DMA_BUS4		0x080
#define BUS_DMA_READ            0x100	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x200	/* mapping is memory -> device only */
#define	BUS_DMA_STREAMING	0x400	/* hint: sequential, unidirectional */
d431 14
a444 14
	int	(*_dmamap_create)(bus_dma_tag_t , bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t , bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t , bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t , bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t , bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(bus_dma_tag_t , bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	void	(*_dmamap_unload)(bus_dma_tag_t , bus_dmamap_t);
	void	(*_dmamap_sync)(bus_dma_tag_t , bus_dmamap_t,
		    bus_addr_t, bus_size_t, int);
d449 8
a456 8
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	void	(*_dmamem_free)(bus_dma_tag_t, bus_dma_segment_t *, int);
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int);
d488 20
a507 20
int	_dmamap_create(bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *);
void	_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t, struct mbuf *, int);
int	_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t, struct uio *, int);
int	_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t, bus_size_t,
	    int);

int	_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t,
	    bus_size_t, bus_dma_segment_t *, int, int *, int);
void	_dmamem_free(bus_dma_tag_t, bus_dma_segment_t *, int);
int	_dmamem_map(bus_dma_tag_t, bus_dma_segment_t *,
	    int, size_t, caddr_t *, int);
void	_dmamem_unmap(bus_dma_tag_t, caddr_t, size_t);
paddr_t	_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t *, int, off_t, int, int);
@


1.3.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.3.2.1 2002/06/11 03:36:34 art Exp $	*/
a58 1
	u_int8_t	bus_io;		/* IO or memory */
a246 102
 *	void bus_space_read_raw_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
 *
 * Read `count' 1, 2, 4, or 8 byte quantities from bus space
 * described by tag/handle and starting at `offset' and copy into
 * buffer provided.
 */

static __inline void
bus_space_read_raw_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int8_t *addr, size_t count)
{
	volatile u_int8_t *s = __BA(tag, bsh, offset);
	u_int8_t *laddr = (void *)addr;

	while (count--)
		*laddr++ = *s++;
	__asm __volatile("eieio; sync");
}

static __inline void
bus_space_read_raw_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int8_t *addr, size_t count)
{
	volatile u_int16_t *s = __BA(tag, bsh, offset);
	u_int16_t *laddr = (void *)addr;

	while (count--)
		*laddr++ = *s++;
	__asm __volatile("eieio; sync");
}

static __inline void
bus_space_read_raw_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int8_t *addr, size_t count)
{
	volatile u_int32_t *s = __BA(tag, bsh, offset);
	u_int32_t *laddr = (void *)addr;

	while (count--)
		*laddr++ = *s++;
	__asm __volatile("eieio; sync");
}

#if 0	/* Cause a link error for bus_space_read_raw_region_8 */
#define	bus_space_read_raw_region_8	\
    !!! bus_space_read_raw_region_8		unimplemented !!!
#endif


/*
 *	void bus_space_write_raw_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
 *
 * Write `count' 1, 2, 4, or 8 byte quantities from the buffer provided
 * to bus space described by tag/handle starting at `offset'.
 */

static __inline void
bus_space_write_raw_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int8_t *addr, size_t count)
{
	volatile u_int8_t *d = __BA(tag, bsh, offset);
	const u_int8_t *laddr = (void *)addr;

	while (count--)
		*d++ = *laddr++;
	__asm __volatile("eieio; sync");
}

static __inline void
bus_space_write_raw_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int8_t *addr, size_t count)
{
	volatile u_int16_t *d = __BA(tag, bsh, offset);
	const u_int16_t *laddr = (void *)addr;

	while (count--)
		*d++ = *laddr++;
	__asm __volatile("eieio; sync");
}

static __inline void
bus_space_write_raw_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int8_t *addr, size_t count)
{
	volatile u_int32_t *d = __BA(tag, bsh, offset);
	const u_int32_t *laddr = (void *)addr;

	while (count--)
		*d++ = *laddr++;
	__asm __volatile("eieio; sync");
}

#if 0
#define	bus_space_write_raw_region_8 \
    !!! bus_space_write_raw_region_8 unimplemented !!!
#endif

/*
d345 1
a345 1
    !!! bus_space_set_region_8 not implemented !!!
@


1.2
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.1 2001/09/01 15:49:06 drahn Exp $	*/
d390 2
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/include to macppc/include
Some files were not "moved" but wrapper files were created which include
the powerpc/include version.

Several of the powerpc/include files where changed to reflect that they
are POWERPC_* not MACHINE_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: bus.h,v 1.18 2001/08/01 23:53:09 pvalchev Exp $	*/
d396 4
a399 6
typedef enum {
	BUS_DMASYNC_POSTREAD,
	BUS_DMASYNC_POSTWRITE,
	BUS_DMASYNC_PREREAD,
	BUS_DMASYNC_PREWRITE
} bus_dmasync_op_t;
d441 2
a442 1
	void	(*_dmamap_sync) __P((bus_dma_tag_t , bus_dmamap_t, bus_dmasync_op_t));
d471 1
a471 1
#define	bus_dmamap_sync(t, p, o)				\
d473 1
a473 1
	    (*(t)->_dmamap_sync)((t), (p), (o)) : (void)0)
d496 2
a497 1
void	_dmamap_sync __P((bus_dma_tag_t, bus_dmamap_t, bus_dmasync_op_t));
d527 1
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.4.2
log
@Merge in -current
@
text
@d396 6
a401 4
#define BUS_DMASYNC_POSTREAD	0x01
#define BUS_DMASYNC_POSTWRITE	0x02
#define BUS_DMASYNC_PREREAD	0x04
#define BUS_DMASYNC_PREWRITE	0x08
d443 1
a443 2
	void	(*_dmamap_sync) __P((bus_dma_tag_t , bus_dmamap_t,
		    bus_addr_t, bus_size_t, int));
d472 1
a472 1
#define	bus_dmamap_sync(t, p, a, l, o)				\
d474 1
a474 1
	    (*(t)->_dmamap_sync)((t), (p), (a), (l), (o)) : (void)0)
d497 1
a497 2
void	_dmamap_sync __P((bus_dma_tag_t, bus_dmamap_t, bus_addr_t, bus_size_t,
	    int));
a526 1
	bus_size_t	dm_mapsize;	/* size of the mapping */
@


1.1.4.3
log
@Merge in trunk
@
text
@a389 2
#define BUS_DMA_READ            0x100

@


1.1.4.4
log
@Merge in -current from about a week ago
@
text
@d67 7
a73 7
int	bus_space_map(bus_space_tag_t t, bus_addr_t addr,
	    bus_size_t size, int cacheable, bus_space_handle_t *bshp);
void	bus_space_unmap(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t size);
int	bus_space_subregion(bus_space_tag_t t, bus_space_handle_t bsh,
	    bus_size_t offset, bus_size_t size, bus_space_handle_t *nbshp);
int	bus_space_alloc(bus_space_tag_t tag, bus_addr_t rstart,
d76 3
a78 3
	    bus_space_handle_t *handlep);
void	bus_space_free(bus_space_tag_t tag, bus_space_handle_t handle,
	    bus_size_t size);
d148 1
a148 1
 *	void bus_space_read_region_N(bus_space_tag_t tag,
d150 1
a150 1
 *	    u_intN_t *addr, size_t count);
d199 1
a199 1
 *	void bus_space_write_region_N(bus_space_tag_t tag,
d201 1
a201 1
 *	    const u_intN_t *addr, size_t count);
d247 1
a247 1
 *	void bus_space_set_multi_N(bus_space_tag_t tag,
d249 1
a249 1
 *	    size_t count);
d254 6
a259 6
static __inline void bus_space_set_multi_1(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int8_t, size_t);
static __inline void bus_space_set_multi_2(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int16_t, size_t);
static __inline void bus_space_set_multi_4(bus_space_tag_t,
	bus_space_handle_t, bus_size_t, u_int32_t, size_t);
d336 2
a337 2
bus_space_set_region_1(void *v, bus_space_handle_t h, bus_size_t o,
    u_int8_t val, bus_size_t c);
d339 2
a340 2
bus_space_set_region_2(void *v, bus_space_handle_t h, bus_size_t o,
    u_int16_t val, bus_size_t c);
d342 2
a343 2
bus_space_set_region_4(void *v, bus_space_handle_t h, bus_size_t o,
    u_int32_t val, bus_size_t c);
d348 2
a349 2
bus_space_copy_1(void *v, bus_space_handle_t h1, bus_space_handle_t h2,
    bus_size_t o1, bus_size_t o2, bus_size_t c);
d351 2
a352 2
bus_space_copy_2(void *v, bus_space_handle_t h1, bus_space_handle_t h2,
    bus_size_t o1, bus_size_t o2, bus_size_t c);
d354 2
a355 2
bus_space_copy_4(void *v, bus_space_handle_t h1, bus_space_handle_t h2,
    bus_size_t o1, bus_size_t o2, bus_size_t c);
d362 1
a362 1
 *	void bus_space_barrier(bus_space_tag_t tag,
d364 1
a364 1
 *	    bus_size_t len, int flags);
d381 10
a390 12
#define	BUS_DMA_WAITOK		0x000	/* safe to sleep (pseudo-flag) */
#define	BUS_DMA_NOWAIT		0x001	/* not safe to sleep */
#define	BUS_DMA_ALLOCNOW	0x002	/* perform resource allocation now */
#define	BUS_DMAMEM_NOSYNC	0x004
#define	BUS_DMA_COHERENT	0x008	/* hint: map memory DMA coherent */
#define	BUS_DMA_BUS1		0x010	/* placeholders for bus functions... */
#define	BUS_DMA_BUS2		0x020
#define	BUS_DMA_BUS3		0x040
#define	BUS_DMA_BUS4		0x080
#define BUS_DMA_READ            0x100	/* mapping is device -> memory only */
#define	BUS_DMA_WRITE		0x200	/* mapping is memory -> device only */
#define	BUS_DMA_STREAMING	0x400	/* hint: sequential, unidirectional */
d431 14
a444 14
	int	(*_dmamap_create)(bus_dma_tag_t , bus_size_t, int,
		    bus_size_t, bus_size_t, int, bus_dmamap_t *);
	void	(*_dmamap_destroy)(bus_dma_tag_t , bus_dmamap_t);
	int	(*_dmamap_load)(bus_dma_tag_t , bus_dmamap_t, void *,
		    bus_size_t, struct proc *, int);
	int	(*_dmamap_load_mbuf)(bus_dma_tag_t , bus_dmamap_t,
		    struct mbuf *, int);
	int	(*_dmamap_load_uio)(bus_dma_tag_t , bus_dmamap_t,
		    struct uio *, int);
	int	(*_dmamap_load_raw)(bus_dma_tag_t , bus_dmamap_t,
		    bus_dma_segment_t *, int, bus_size_t, int);
	void	(*_dmamap_unload)(bus_dma_tag_t , bus_dmamap_t);
	void	(*_dmamap_sync)(bus_dma_tag_t , bus_dmamap_t,
		    bus_addr_t, bus_size_t, int);
d449 8
a456 8
	int	(*_dmamem_alloc)(bus_dma_tag_t, bus_size_t, bus_size_t,
		    bus_size_t, bus_dma_segment_t *, int, int *, int);
	void	(*_dmamem_free)(bus_dma_tag_t, bus_dma_segment_t *, int);
	int	(*_dmamem_map)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, size_t, caddr_t *, int);
	void	(*_dmamem_unmap)(bus_dma_tag_t, caddr_t, size_t);
	paddr_t	(*_dmamem_mmap)(bus_dma_tag_t, bus_dma_segment_t *,
		    int, off_t, int, int);
d488 20
a507 20
int	_dmamap_create(bus_dma_tag_t, bus_size_t, int,
	    bus_size_t, bus_size_t, int, bus_dmamap_t *);
void	_dmamap_destroy(bus_dma_tag_t, bus_dmamap_t);
int	_dmamap_load(bus_dma_tag_t, bus_dmamap_t, void *,
	    bus_size_t, struct proc *, int);
int	_dmamap_load_mbuf(bus_dma_tag_t, bus_dmamap_t, struct mbuf *, int);
int	_dmamap_load_uio(bus_dma_tag_t, bus_dmamap_t, struct uio *, int);
int	_dmamap_load_raw(bus_dma_tag_t, bus_dmamap_t,
	    bus_dma_segment_t *, int, bus_size_t, int);
void	_dmamap_unload(bus_dma_tag_t, bus_dmamap_t);
void	_dmamap_sync(bus_dma_tag_t, bus_dmamap_t, bus_addr_t, bus_size_t,
	    int);

int	_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t,
	    bus_size_t, bus_dma_segment_t *, int, int *, int);
void	_dmamem_free(bus_dma_tag_t, bus_dma_segment_t *, int);
int	_dmamem_map(bus_dma_tag_t, bus_dma_segment_t *,
	    int, size_t, caddr_t *, int);
void	_dmamem_unmap(bus_dma_tag_t, caddr_t, size_t);
paddr_t	_dmamem_mmap(bus_dma_tag_t, bus_dma_segment_t *, int, off_t, int, int);
@


1.1.4.5
log
@Sync the SMP branch with 3.3
@
text
@a58 1
	u_int8_t	bus_io;		/* IO or memory */
a246 102
 *	void bus_space_read_raw_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    u_intN_t *addr, size_t count);
 *
 * Read `count' 1, 2, 4, or 8 byte quantities from bus space
 * described by tag/handle and starting at `offset' and copy into
 * buffer provided.
 */

static __inline void
bus_space_read_raw_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int8_t *addr, size_t count)
{
	volatile u_int8_t *s = __BA(tag, bsh, offset);
	u_int8_t *laddr = (void *)addr;

	while (count--)
		*laddr++ = *s++;
	__asm __volatile("eieio; sync");
}

static __inline void
bus_space_read_raw_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int8_t *addr, size_t count)
{
	volatile u_int16_t *s = __BA(tag, bsh, offset);
	u_int16_t *laddr = (void *)addr;

	while (count--)
		*laddr++ = *s++;
	__asm __volatile("eieio; sync");
}

static __inline void
bus_space_read_raw_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, u_int8_t *addr, size_t count)
{
	volatile u_int32_t *s = __BA(tag, bsh, offset);
	u_int32_t *laddr = (void *)addr;

	while (count--)
		*laddr++ = *s++;
	__asm __volatile("eieio; sync");
}

#if 0	/* Cause a link error for bus_space_read_raw_region_8 */
#define	bus_space_read_raw_region_8	\
    !!! bus_space_read_raw_region_8		unimplemented !!!
#endif


/*
 *	void bus_space_write_raw_region_N(bus_space_tag_t tag,
 *	    bus_space_handle_t bsh, bus_size_t offset,
 *	    const u_intN_t *addr, size_t count);
 *
 * Write `count' 1, 2, 4, or 8 byte quantities from the buffer provided
 * to bus space described by tag/handle starting at `offset'.
 */

static __inline void
bus_space_write_raw_region_1(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int8_t *addr, size_t count)
{
	volatile u_int8_t *d = __BA(tag, bsh, offset);
	const u_int8_t *laddr = (void *)addr;

	while (count--)
		*d++ = *laddr++;
	__asm __volatile("eieio; sync");
}

static __inline void
bus_space_write_raw_region_2(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int8_t *addr, size_t count)
{
	volatile u_int16_t *d = __BA(tag, bsh, offset);
	const u_int16_t *laddr = (void *)addr;

	while (count--)
		*d++ = *laddr++;
	__asm __volatile("eieio; sync");
}

static __inline void
bus_space_write_raw_region_4(bus_space_tag_t tag, bus_space_handle_t bsh,
	bus_size_t offset, const u_int8_t *addr, size_t count)
{
	volatile u_int32_t *d = __BA(tag, bsh, offset);
	const u_int32_t *laddr = (void *)addr;

	while (count--)
		*d++ = *laddr++;
	__asm __volatile("eieio; sync");
}

#if 0
#define	bus_space_write_raw_region_8 \
    !!! bus_space_write_raw_region_8 unimplemented !!!
#endif

/*
d345 1
a345 1
    !!! bus_space_set_region_8 not implemented !!!
@


1.1.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d252 3
a254 2
 * Read `count' bytes from bus space described by tag/handle and starting
 * at `offset' and copy into buffer provided w/o bus-host byte swapping.
d258 12
d304 2
a305 2
 * Write `count' bytes from the buffer provided to bus space described
 * by tag/handle starting at `offset' w/o host-bus byte swapping.
d309 12
d415 3
d427 3
d439 1
a439 1
bus_space_set_region_1(bus_space_tag_t bst, bus_space_handle_t h, bus_size_t o,
d442 1
a442 1
bus_space_set_region_2(bus_space_tag_t bst, bus_space_handle_t h, bus_size_t o,
d445 1
a445 1
bus_space_set_region_4(bus_space_tag_t bst, bus_space_handle_t h, bus_size_t o,
@


