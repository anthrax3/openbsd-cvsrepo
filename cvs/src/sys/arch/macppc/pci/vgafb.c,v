head	1.60;
access;
symbols
	OPENBSD_6_1:1.60.0.14
	OPENBSD_6_1_BASE:1.60
	OPENBSD_6_0:1.60.0.10
	OPENBSD_6_0_BASE:1.60
	OPENBSD_5_9:1.60.0.6
	OPENBSD_5_9_BASE:1.60
	OPENBSD_5_8:1.60.0.8
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.60.0.2
	OPENBSD_5_7_BASE:1.60
	OPENBSD_5_6:1.60.0.4
	OPENBSD_5_6_BASE:1.60
	OPENBSD_5_5:1.58.0.4
	OPENBSD_5_5_BASE:1.58
	OPENBSD_5_4:1.48.0.2
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.41.0.2
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.40.0.2
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.2
	OPENBSD_5_0:1.38.0.4
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.36.0.6
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.36.0.2
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.36.0.4
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.34.0.4
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.34.0.2
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.33.0.4
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.31.0.2
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.24.0.4
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.20.0.4
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.19
	UBC:1.5.0.2
	UBC_BASE:1.5
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.60
date	2014.07.28.15.00.27;	author jsg;	state Exp;
branches;
next	1.59;
commitid	UC1Kg7uZbOmNOW0L;

1.59
date	2014.07.22.04.42.51;	author jsg;	state Exp;
branches;
next	1.58;
commitid	EtAKn2rlAqe8IYXn;

1.58
date	2013.10.21.10.36.16;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2013.10.20.20.07.23;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2013.09.04.16.33.06;	author mpi;	state Exp;
branches;
next	1.55;

1.55
date	2013.08.28.20.47.10;	author mpi;	state Exp;
branches;
next	1.54;

1.54
date	2013.08.27.21.00.52;	author mpi;	state Exp;
branches;
next	1.53;

1.53
date	2013.08.23.08.52.25;	author mpi;	state Exp;
branches;
next	1.52;

1.52
date	2013.08.17.10.59.38;	author mpi;	state Exp;
branches;
next	1.51;

1.51
date	2013.08.17.09.15.47;	author mpi;	state Exp;
branches;
next	1.50;

1.50
date	2013.08.16.18.20.46;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2013.08.12.08.03.56;	author mpi;	state Exp;
branches;
next	1.48;

1.48
date	2013.07.06.18.08.47;	author mpi;	state Exp;
branches;
next	1.47;

1.47
date	2013.06.04.02.29.32;	author mpi;	state Exp;
branches;
next	1.46;

1.46
date	2013.06.04.02.26.36;	author mpi;	state Exp;
branches;
next	1.45;

1.45
date	2013.06.04.02.20.18;	author mpi;	state Exp;
branches;
next	1.44;

1.44
date	2013.06.04.02.16.14;	author mpi;	state Exp;
branches;
next	1.43;

1.43
date	2013.06.04.02.09.00;	author mpi;	state Exp;
branches;
next	1.42;

1.42
date	2013.06.03.23.28.43;	author mpi;	state Exp;
branches;
next	1.41;

1.41
date	2012.08.30.21.54.13;	author mpi;	state Exp;
branches;
next	1.40;

1.40
date	2012.06.21.10.08.16;	author mpi;	state Exp;
branches;
next	1.39;

1.39
date	2012.01.29.14.20.42;	author mpi;	state Exp;
branches;
next	1.38;

1.38
date	2010.11.27.18.31.53;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2010.09.01.19.14.25;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.35;

1.35
date	2008.09.23.20.45.27;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2008.01.23.16.37.57;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2006.12.17.22.18.14;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.11.29.12.13.54;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.30.20.59.56;	author matthieu;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.02.21.02.03;	author matthieu;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.28.20.21.42;	author matthieu;	state Exp;
branches;
next	1.28;

1.28
date	2006.04.09.12.22.56;	author matthieu;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.01.11.59.39;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.26.18.57.51;	author martin;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.08.05.47.25;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2005.01.05.23.04.24;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.17.15.47.59;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.24.20.02.45;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.15.23.00.57;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.09.22.51.46;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.15.09.01.59;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.06.13.37.50;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.02.16.13.07;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.21.16.31.15;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.27.19.45.03;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.22.21.00.03;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.18.20.20.17;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.29.22.07.56;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.29.01.34.58;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.20.16.42.42;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.05.02.36.06;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.26.16.51.43;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.14.03.08.54;	author jason;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.17.15.10.36;	author drahn;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.09.13.13.38.45;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.55.17;	author drahn;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.01.16;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.06.01.06.11;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2004.06.05.23.10.52;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.60
log
@Limit the "aperture needed" printf to ramdisks via RAMDISK_HOOKS.
Originally with SMALL_KERNEL until sebastia@@ pointed out that not
all ramdisks are built with SMALL_KERNEL.
ok deraadt@@ kettenis@@
@
text
@/*	$OpenBSD: vgafb.c,v 1.59 2014/07/22 04:42:51 jsg Exp $	*/
/*	$NetBSD: vga.c,v 1.3 1996/12/02 22:24:54 cgd Exp $	*/

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/bus.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

#include <dev/ofw/openfirm.h>
#include <macppc/macppc/ofw_machdep.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/vga_pcivar.h>

struct vgafb_softc {
	struct device		sc_dev;
	int			sc_node;

	bus_addr_t		sc_mem_addr, sc_mmio_addr;
	bus_size_t		sc_mem_size, sc_mmio_size;

	struct rasops_info	sc_ri;
	uint8_t			sc_cmap[256 * 3];
	u_int			sc_mode;

	struct	wsscreen_descr	sc_wsd;
	struct	wsscreen_list	sc_wsl;
	struct	wsscreen_descr *sc_scrlist[1];

	int			sc_backlight_on;
};

int	vgafb_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	vgafb_mmap(void *, off_t, int);
int	vgafb_alloc_screen(void *, const struct wsscreen_descr *, void **,
	    int *, int *, long *);
void	vgafb_free_screen(void *, void *);
int	vgafb_show_screen(void *, void *, int, void (*cb)(void *, int, int),
	    void *);
int	vgafb_load_font(void *, void *, struct wsdisplay_font *);
int	vgafb_list_font(void *, struct wsdisplay_font *);
void	vgafb_burn(void *v, u_int , u_int);
void	vgafb_restore_default_colors(struct vgafb_softc *);
int	vgafb_is_console(int);
int	vgafb_console_init(struct vgafb_softc *);
int	vgafb_mapregs(struct vgafb_softc *, struct pci_attach_args *);

struct wsdisplay_accessops vgafb_accessops = {
	.ioctl = vgafb_ioctl,
	.mmap = vgafb_mmap,
	.alloc_screen = vgafb_alloc_screen,
	.free_screen = vgafb_free_screen,
	.show_screen = vgafb_show_screen,
	.load_font = vgafb_load_font,
	.list_font = vgafb_list_font,
	.burn_screen = vgafb_burn
};

int	vgafb_getcmap(uint8_t *, struct wsdisplay_cmap *);
int	vgafb_putcmap(uint8_t *, struct wsdisplay_cmap *);

int	vgafb_match(struct device *, void *, void *);
void	vgafb_attach(struct device *, struct device *, void *);

const struct cfattach vgafb_ca = {
	sizeof(struct vgafb_softc), vgafb_match, vgafb_attach,
};

struct cfdriver vgafb_cd = {
	NULL, "vgafb", DV_DULL,
};

#ifdef APERTURE
extern int allowaperture;
#endif

int
vgafb_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;
	int node;

	if (DEVICE_IS_VGA_PCI(pa->pa_class) == 0) {
		/*
		 * XXX Graphic cards found in iMac G3 have a ``Misc''
		 * subclass, match them all.
		 */
		if (PCI_CLASS(pa->pa_class) != PCI_CLASS_DISPLAY ||
		    PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_DISPLAY_MISC)
			return (0);
	}

	/*
	 * XXX Non-console devices do not get configured by the PROM,
	 * XXX so do not attach them yet.
	 */
	node = PCITAG_NODE(pa->pa_tag);
	if (!vgafb_is_console(node))
		return (0);

	return (1);
}

void
vgafb_attach(struct device *parent, struct device *self, void *aux)
{
	struct vgafb_softc *sc = (struct vgafb_softc *)self;
	struct pci_attach_args *pa = aux;
	struct wsemuldisplaydev_attach_args waa;

	sc->sc_node = PCITAG_NODE(pa->pa_tag);

	if (vgafb_mapregs(sc, pa))
		return;

	if (vgafb_console_init(sc))
		return;

	sc->sc_scrlist[0] = &sc->sc_wsd;
	sc->sc_wsl.nscreens = 1;
	sc->sc_wsl.screens = (const struct wsscreen_descr **)sc->sc_scrlist;

	waa.console = 1;
	waa.scrdata = &sc->sc_wsl;
	waa.accessops = &vgafb_accessops;
	waa.accesscookie = sc;
	waa.defaultscreens = 0;

	/* no need to keep the burner function if no hw support */
	if (cons_backlight_available == 0)
		vgafb_accessops.burn_screen = NULL;
	else {
		sc->sc_backlight_on = WSDISPLAYIO_VIDEO_OFF;
		vgafb_burn(sc, WSDISPLAYIO_VIDEO_ON, 0);	/* paranoia */
	}

#ifdef RAMDISK_HOOKS
	if (vga_aperture_needed(pa))
		printf("%s: aperture needed\n", sc->sc_dev.dv_xname);
#endif

	config_found(self, &waa, wsemuldisplaydevprint);
}

int
vgafb_console_init(struct vgafb_softc *sc)
{
	struct rasops_info *ri = &sc->sc_ri;
	long defattr;

	ri->ri_flg = RI_CENTER | RI_VCONS | RI_WRONLY;
	ri->ri_hw = sc;

	ofwconsswitch(ri);

	rasops_init(ri, 160, 160);

	strlcpy(sc->sc_wsd.name, "std", sizeof(sc->sc_wsd.name));
	sc->sc_wsd.capabilities = ri->ri_caps;
	sc->sc_wsd.nrows = ri->ri_rows;
	sc->sc_wsd.ncols = ri->ri_cols;
	sc->sc_wsd.textops = &ri->ri_ops;
	sc->sc_wsd.fontwidth = ri->ri_font->fontwidth;
	sc->sc_wsd.fontheight = ri->ri_font->fontheight;

	ri->ri_ops.alloc_attr(ri->ri_active, 0, 0, 0, &defattr);
	wsdisplay_cnattach(&sc->sc_wsd, ri->ri_active, ri->ri_ccol, ri->ri_crow,
	    defattr);

	return (0);
}

void
vgafb_restore_default_colors(struct vgafb_softc *sc)
{
	bcopy(rasops_cmap, sc->sc_cmap, sizeof(sc->sc_cmap));
	of_setcolors(sc->sc_cmap, 0, 256);
}

int
vgafb_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct vgafb_softc *sc = v;
	struct rasops_info *ri = &sc->sc_ri;
	struct wsdisplay_cmap *cm;
	struct wsdisplay_fbinfo *wdf;
	int rc;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_PCIVGA;
		break;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->width = ri->ri_width;
		wdf->height = ri->ri_height;
		wdf->depth = ri->ri_depth;
		wdf->cmsize = 256;
		break;
	case WSDISPLAYIO_LINEBYTES:
		*(uint *)data = ri->ri_stride;
		break;
	case WSDISPLAYIO_GETCMAP:
		cm = (struct wsdisplay_cmap *)data;
		rc = vgafb_getcmap(sc->sc_cmap, cm);
		if (rc != 0)
			return rc;
		break;
	case WSDISPLAYIO_PUTCMAP:
		cm = (struct wsdisplay_cmap *)data;
		rc = vgafb_putcmap(sc->sc_cmap, cm);
		if (rc != 0)
			return (rc);
		if (ri->ri_depth == 8)
			of_setcolors(sc->sc_cmap, cm->index, cm->count);
		break;
	case WSDISPLAYIO_SMODE:
		sc->sc_mode = *(u_int *)data;
		if (ri->ri_depth == 8)
			vgafb_restore_default_colors(sc);
		break;
	case WSDISPLAYIO_GETPARAM:
	{
		struct wsdisplay_param *dp = (struct wsdisplay_param *)data;

		switch (dp->param) {
		case WSDISPLAYIO_PARAM_BRIGHTNESS:
			if (cons_backlight_available != 0) {
				dp->min = MIN_BRIGHTNESS;
				dp->max = MAX_BRIGHTNESS;
				dp->curval = cons_brightness;
				return 0;
			}
			return -1;
		case WSDISPLAYIO_PARAM_BACKLIGHT:
			if (cons_backlight_available != 0) {
				dp->min = 0;
				dp->max = 1;
				dp->curval = sc->sc_backlight_on;
				return 0;
			} else
				return -1;
		}
	}
		return -1;

	case WSDISPLAYIO_SETPARAM:
	{
		struct wsdisplay_param *dp = (struct wsdisplay_param *)data;

		switch (dp->param) {
		case WSDISPLAYIO_PARAM_BRIGHTNESS:
			if (cons_backlight_available == 1) {
				of_setbrightness(dp->curval);
				return 0;
			} else
				return -1;
		case WSDISPLAYIO_PARAM_BACKLIGHT:
			if (cons_backlight_available != 0) {
				vgafb_burn(sc,
				    dp->curval ? WSDISPLAYIO_VIDEO_ON :
				      WSDISPLAYIO_VIDEO_OFF, 0);
				return 0;
			} else
				return -1;
		}
	}
		return -1;

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return -1; /* not supported yet */
	}

	return (0);
}

paddr_t
vgafb_mmap(void *v, off_t off, int prot)
{
	struct vgafb_softc *sc = v;

	if (off & PGOFSET)
		return (-1);

	switch (sc->sc_mode) {
	case WSDISPLAYIO_MODE_MAPPED:
#ifdef APERTURE
		if (allowaperture == 0)
			return (-1);
#endif

		if (sc->sc_mmio_size == 0)
			return (-1);

		if (off >= sc->sc_mem_addr &&
		    off < (sc->sc_mem_addr + sc->sc_mem_size))
			return (off);

		if (off >= sc->sc_mmio_addr &&
		    off < (sc->sc_mmio_addr + sc->sc_mmio_size))
			return (off);
		break;

	case WSDISPLAYIO_MODE_DUMBFB:
		if (off >= 0x00000 && off < sc->sc_mem_size)
			return (sc->sc_mem_addr + off);
		break;

	}

	return (-1);
}

int
vgafb_is_console(int node)
{
	extern int fbnode;

	return (fbnode == node);
}

int
vgafb_getcmap(uint8_t *cmap, struct wsdisplay_cmap *cm)
{
	uint index = cm->index, count = cm->count, i;
	uint8_t ramp[256], *dst, *src;
	int rc;

	if (index >= 256 || count > 256 - index)
		return EINVAL;

	index *= 3;

	src = cmap + index;
	dst = ramp;
	for (i = 0; i < count; i++)
		*dst++ = *src, src += 3;
	rc = copyout(ramp, cm->red, count);
	if (rc != 0)
		return rc;

	src = cmap + index + 1;
	dst = ramp;
	for (i = 0; i < count; i++)
		*dst++ = *src, src += 3;
	rc = copyout(ramp, cm->green, count);
	if (rc != 0)
		return rc;

	src = cmap + index + 2;
	dst = ramp;
	for (i = 0; i < count; i++)
		*dst++ = *src, src += 3;
	rc = copyout(ramp, cm->blue, count);
	if (rc != 0)
		return rc;

	return 0;
}

int
vgafb_putcmap(uint8_t *cmap, struct wsdisplay_cmap *cm)
{
	uint index = cm->index, count = cm->count, i;
	uint8_t ramp[256], *dst, *src;
	int rc;

	if (index >= 256 || count > 256 - index)
		return EINVAL;

	index *= 3;

	rc = copyin(cm->red, ramp, count);
	if (rc != 0)
		return rc;
	dst = cmap + index;
	src = ramp;
	for (i = 0; i < count; i++)
		*dst = *src++, dst += 3;

	rc = copyin(cm->green, ramp, count);
	if (rc != 0)
		return rc;
	dst = cmap + index + 1;
	src = ramp;
	for (i = 0; i < count; i++)
		*dst = *src++, dst += 3;

	rc = copyin(cm->blue, ramp, count);
	if (rc != 0)
		return rc;
	dst = cmap + index + 2;
	src = ramp;
	for (i = 0; i < count; i++)
		*dst = *src++, dst += 3;

	return 0;
}

void
vgafb_burn(void *v, u_int on, u_int flags)
{
	struct vgafb_softc *sc = v;

	if (sc->sc_backlight_on != on) {
		of_setbacklight(on == WSDISPLAYIO_VIDEO_ON);
		sc->sc_backlight_on = on;
	}
}

int
vgafb_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *attrp)
{
	struct vgafb_softc *sc = v;
	struct rasops_info *ri = &sc->sc_ri;

	return rasops_alloc_screen(ri, cookiep, curxp, curyp, attrp);
}

void
vgafb_free_screen(void *v, void *cookie)
{
	struct vgafb_softc *sc = v;
	struct rasops_info *ri = &sc->sc_ri;

	return rasops_free_screen(ri, cookie);
}

int
vgafb_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	struct vgafb_softc *sc = v;
	struct rasops_info *ri = &sc->sc_ri;

	if (cookie == ri->ri_active)
		return (0);

	return rasops_show_screen(ri, cookie, waitok, cb, cbarg);
}

int
vgafb_load_font(void *v, void *emulcookie, struct wsdisplay_font *font)
{
	struct vgafb_softc *sc = v;
	struct rasops_info *ri = &sc->sc_ri;

	return rasops_load_font(ri, emulcookie, font);
}

int
vgafb_list_font(void *v, struct wsdisplay_font *font)
{
	struct vgafb_softc *sc = v;
	struct rasops_info *ri = &sc->sc_ri;

	return rasops_list_font(ri, font);
}

int
vgafb_mapregs(struct vgafb_softc *sc, struct pci_attach_args *pa)
{
	bus_addr_t ba;
	bus_size_t bs;
	int hasmem = 0, hasmmio = 0;
	uint32_t i, cf;
	int rv;

	for (i = PCI_MAPREG_START; i <= PCI_MAPREG_PPB_END; i += 4) {
		cf = pci_conf_read(pa->pa_pc, pa->pa_tag, i);
		if (PCI_MAPREG_TYPE(cf) == PCI_MAPREG_TYPE_MEM) {
			/* Memory mapping... frame memory or mmio? */
			rv = pci_mem_find(pa->pa_pc, pa->pa_tag, i,
			    &ba, &bs, NULL);
			if (rv != 0)
				continue;

			if (bs == 0 /* || ba == 0 */) {
				/* ignore this entry */
			} else if (hasmem == 0) {
				/*
				 * first memory slot found goes into memory,
				 * this is for the case of no mmio
				 */
				sc->sc_mem_addr = ba;
				sc->sc_mem_size = bs;
				hasmem = 1;
			} else {
				/*
				 * Oh, we have a second `memory'
				 * region, is this region the vga memory
				 * or mmio, we guess that memory is
				 * the larger of the two.
				 */
				if (sc->sc_mem_size >= bs) {
					/* this is the mmio */
					sc->sc_mmio_addr = ba;
					sc->sc_mmio_size = bs;
					hasmmio = 1;
				} else {
					/* this is the memory */
					sc->sc_mmio_addr = sc->sc_mem_addr;
					sc->sc_mmio_size = sc->sc_mem_size;
					sc->sc_mem_addr = ba;
					sc->sc_mem_size = bs;
				}
			}
		}
	}

	/* failure to initialize io ports should not prevent attachment */
	if (hasmem == 0) {
		printf(": could not find memory space\n");
		return (1);
	}

	if (hasmmio)
		printf (", mmio");
	printf("\n");

	return (0);
}
@


1.59
log
@The aperture needed test should be in vgafb as well as vga@@pci.
Problem noticed/fix tested by sebastia@@ on macppc.
sparc64 problems in earlier diff pointed out by deraadt@@
'looks good' kettenis@@ 'commit' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.58 2013/10/21 10:36:16 miod Exp $	*/
d170 1
d173 1
@


1.58
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.57 2013/10/20 20:07:23 miod Exp $	*/
d169 3
@


1.57
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.56 2013/09/04 16:33:06 mpi Exp $	*/
d73 2
d87 2
d478 18
@


1.56
log
@Convert vgafb to use a proper softc.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.55 2013/08/28 20:47:10 mpi Exp $	*/
d80 6
a85 9
	vgafb_ioctl,
	vgafb_mmap,
	vgafb_alloc_screen,
	vgafb_free_screen,
	vgafb_show_screen,
	NULL,		/* load_font */
	NULL,		/* scrollback */
	NULL,		/* getchar */
	vgafb_burn,	/* burner */
@


1.55
log
@Move the early framebuffer initialization code outside of vgafb(4)
and introduce a function to get the cursor position an unmap the
stolen memory region when switching to the real framebuffer.

For the moment we still reuse the original region but this allows
me to move forward and it buys us the posibility to have an early
framebuffer without vgafb (i.e. radeondrm(4) only).
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.54 2013/08/27 21:00:52 mpi Exp $	*/
d48 14
a61 13
struct vga_config {
	bus_space_tag_t		vc_memt;
	bus_space_handle_t	vc_memh;

	struct rasops_info	ri;
	uint8_t			cmap[256 * 3];

	bus_addr_t	iobase, membase, mmiobase;
	bus_size_t	iosize, memsize, mmiosize;

	struct	wsscreen_descr	vc_wsd;
	struct	wsscreen_list	vc_wsl;
	struct	wsscreen_descr *vc_scrlist[1];
d63 1
a63 2
	int vc_backlight_on;
	u_int vc_mode;
d74 1
a74 1
void	vgafb_restore_default_colors(struct vga_config *);
d76 2
a77 3
int	vgafb_mapregs(struct vga_config *, struct pci_attach_args *);

struct vga_config vgafbcn;
d98 1
a98 1
	sizeof(struct device), vgafb_match, vgafb_attach,
d137 1
a137 1
vgafb_attach(struct device *parent, struct device  *self, void *aux)
d139 1
a140 1
	struct vga_config *vc = &vgafbcn;
a141 2
	struct rasops_info *ri;
	long defattr;
d143 3
a145 1
	if (vgafb_mapregs(vc, pa))
d148 2
a149 7
	ri = &vc->ri;
	ri->ri_flg = RI_CENTER | RI_VCONS | RI_WRONLY;
	ri->ri_hw = vc;

	ofwconsswitch(ri);

	rasops_init(ri, 160, 160);
d151 3
a153 15
	strlcpy(vc->vc_wsd.name, "std", sizeof(vc->vc_wsd.name));
	vc->vc_wsd.capabilities = ri->ri_caps;
	vc->vc_wsd.nrows = ri->ri_rows;
	vc->vc_wsd.ncols = ri->ri_cols;
	vc->vc_wsd.textops = &ri->ri_ops;
	vc->vc_wsd.fontwidth = ri->ri_font->fontwidth;
	vc->vc_wsd.fontheight = ri->ri_font->fontheight;

	ri->ri_ops.alloc_attr(ri->ri_active, 0, 0, 0, &defattr);
	wsdisplay_cnattach(&vc->vc_wsd, ri->ri_active, ri->ri_ccol, ri->ri_crow,
	    defattr);

	vc->vc_scrlist[0] = &vc->vc_wsd;
	vc->vc_wsl.nscreens = 1;
	vc->vc_wsl.screens = (const struct wsscreen_descr **)vc->vc_scrlist;
d156 1
a156 1
	waa.scrdata = &vc->vc_wsl;
d158 1
a158 1
	waa.accesscookie = vc;
d165 2
a166 2
		vc->vc_backlight_on = WSDISPLAYIO_VIDEO_OFF;
		vgafb_burn(vc, WSDISPLAYIO_VIDEO_ON, 0);	/* paranoia */
d172 28
d201 1
a201 1
vgafb_restore_default_colors(struct vga_config *vc)
d203 2
a204 2
	bcopy(rasops_cmap, vc->cmap, sizeof(vc->cmap));
	of_setcolors(vc->cmap, 0, 256);
d210 2
a211 2
	struct vga_config *vc = v;
	struct rasops_info *ri = &vc->ri;
d232 1
a232 1
		rc = vgafb_getcmap(vc->cmap, cm);
d238 1
a238 1
		rc = vgafb_putcmap(vc->cmap, cm);
d242 1
a242 1
			of_setcolors(vc->cmap, cm->index, cm->count);
d245 1
a245 1
		vc->vc_mode = *(u_int *)data;
d247 1
a247 1
			vgafb_restore_default_colors(vc);
d266 1
a266 1
				dp->curval = vc->vc_backlight_on;
d287 1
a287 1
				vgafb_burn(vc,
d316 1
a316 1
	struct vga_config *vc = v;
d321 1
a321 1
	switch (vc->vc_mode) {
d328 1
a328 1
		if (vc->mmiosize == 0)
d331 2
a332 1
		if (off >= vc->membase && off < (vc->membase + vc->memsize))
d335 2
a336 1
		if (off >= vc->mmiobase && off < (vc->mmiobase + vc->mmiosize))
d341 2
a342 2
		if (off >= 0x00000 && off < vc->memsize)
			return (vc->membase + off);
d439 1
a439 1
	struct vga_config *vc = v;
d441 1
a441 1
	if (vc->vc_backlight_on != on) {
d443 1
a443 1
		vc->vc_backlight_on = on;
d451 2
a452 2
	struct vga_config *vc = v;
	struct rasops_info *ri = &vc->ri;
d460 2
a461 2
	struct vga_config *vc = v;
	struct rasops_info *ri = &vc->ri;
d470 2
a471 2
	struct vga_config *vc = v;
	struct rasops_info *ri = &vc->ri;
d480 1
a480 1
vgafb_mapregs(struct vga_config *vc, struct pci_attach_args *pa)
d484 1
a484 1
	int hasio = 0, hasmem = 0, hasmmio = 0;
d490 1
a490 15
		if (PCI_MAPREG_TYPE(cf) == PCI_MAPREG_TYPE_IO) {
			if (hasio)
				continue;
			rv = pci_io_find(pa->pa_pc, pa->pa_tag, i,
			    &vc->iobase, &vc->iosize);
			if (rv != 0) {
#if notyet
				if (rv != ENOENT)
					printf("%s: failed to find io at 0x%x\n",
					    DEVNAME(sc), i);
#endif
				continue;
			}
			hasio = 1;
		} else {
d494 1
a494 6
			if (rv != 0) {
#if notyet
				if (rv != ENOENT)
					printf("%s: failed to find mem at 0x%x\n",
					    DEVNAME(sc), i);
#endif
a495 1
			}
d504 2
a505 2
				vc->membase = ba;
				vc->memsize = bs;
d514 1
a514 1
				if (vc->memsize >= bs) {
d516 2
a517 2
					vc->mmiobase = ba;
					vc->mmiosize = bs;
d521 4
a524 4
					vc->mmiobase = vc->membase;
					vc->mmiosize = vc->memsize;
					vc->membase = ba;
					vc->memsize = bs;
@


1.54
log
@Since we are no longer attaching radeondrm(4) to this driver there is
no reason to pretend being compatible with the MI vga layer.  So stop
using the vga_pci_bar interface and reduce the differences with the
sparc64 driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.53 2013/08/23 08:52:25 mpi Exp $	*/
a51 5
	/* Colormap */
	u_char vc_cmap_red[256];
	u_char vc_cmap_green[256];
	u_char vc_cmap_blue[256];

d53 1
d58 4
a75 1
void	vgafb_wsdisplay_attach(struct device *, struct vga_config *);
a79 17
struct wsscreen_descr vgafb_stdscreen = {
	"std",
	0, 0,
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
};

const struct wsscreen_descr *vgafb_scrlist[] = {
	&vgafb_stdscreen,
};

struct wsscreen_list vgafb_screenlist = {
	nitems(vgafb_scrlist), vgafb_scrlist
};

d92 2
a93 2
int	vgafb_getcmap(struct vga_config *vc, struct wsdisplay_cmap *cm);
int	vgafb_putcmap(struct vga_config *vc, struct wsdisplay_cmap *cm);
d142 3
d149 3
a151 2
	vgafb_wsdisplay_attach(self, vc);
}
d153 1
a153 5
void
vgafb_restore_default_colors(struct vga_config *vc)
{
	const uint8_t *color;
	int i;
d155 1
a155 1
	for (i = 0; i < 256; i++) {
d157 7
a163 20
		color = &rasops_cmap[i * 3];

		vc->vc_cmap_red[i] = color[0];
		vc->vc_cmap_green[i] = color[1];
		vc->vc_cmap_blue[i] = color[2];
	}

	of_setcolors(0, 256, vc->vc_cmap_red, vc->vc_cmap_green,
	    vc->vc_cmap_blue);
}

void
vgafb_wsdisplay_attach(struct device *parent, struct vga_config *vc)
{
	struct wsemuldisplaydev_attach_args aa;
	struct rasops_info *ri = &vc->ri;
	long defattr;

	ri->ri_flg = RI_CENTER | RI_VCONS | RI_WRONLY;
	rasops_init(ri, 160, 160);
d166 2
a167 1
	wsdisplay_cnattach(&vgafb_stdscreen, ri->ri_active, 0, 0, defattr);
d169 9
a177 5
	aa.console = 1;
	aa.scrdata = &vgafb_screenlist;
	aa.accessops = &vgafb_accessops;
	aa.accesscookie = vc;
	aa.defaultscreens = 0;
d187 8
a194 1
	config_found(parent, &aa, wsemuldisplaydevprint);
d201 2
d204 1
d209 1
a209 1
		return 0;
d211 4
a214 4
		wdf = (void *)data;
		wdf->height = cons_height;
		wdf->width  = cons_width;
		wdf->depth  = cons_depth;
d216 1
a216 2
		return 0;

d218 2
a219 3
		*(u_int *)data = cons_linebytes;
		return 0;

d221 5
a225 2
		return vgafb_getcmap(vc, (struct wsdisplay_cmap *)data);

d227 7
a233 2
		return vgafb_putcmap(vc, (struct wsdisplay_cmap *)data);

d236 1
a236 7
		/* track the state of the display,
		 * if returning to WSDISPLAYIO_MODE_EMUL
		 * restore the last palette, workaround for
		 * bad accellerated X servers that does not restore
		 * the correct palette.
		 */
		if (cons_depth == 8)
a238 1

d347 1
a347 1
vgafb_cnattach(bus_space_tag_t iot, bus_space_tag_t memt, int type, int check)
d349 3
a351 39
	struct vga_config *vc = &vgafbcn;
	struct rasops_info *ri = &vc->ri;
	long defattr;

	vc->vc_memt = memt;
	vc->membase = cons_addr;
	vc->memsize = cons_linebytes * cons_height;
	vc->vc_memh = (bus_space_handle_t)mapiodev(vc->membase, vc->memsize);

	if (cons_depth == 8)
		vgafb_restore_default_colors(vc);

	ri->ri_flg = RI_FULLCLEAR | RI_CLEAR;
	ri->ri_depth = cons_depth;
	ri->ri_bits = (void *)vc->vc_memh;
	ri->ri_width = cons_width;
	ri->ri_height = cons_height;
	ri->ri_stride = cons_linebytes;
	ri->ri_hw = vc;

	rasops_init(ri, 160, 160);

	vgafb_stdscreen.nrows = ri->ri_rows;
	vgafb_stdscreen.ncols = ri->ri_cols;
	vgafb_stdscreen.textops = &ri->ri_ops;

	ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);

	wsdisplay_cnattach(&vgafb_stdscreen, ri, 0, 0, defattr);

	return (0);
}

int
vgafb_getcmap(struct vga_config *vc, struct wsdisplay_cmap *cm)
{
	u_int index = cm->index;
	u_int count = cm->count;
	int error;
d356 25
a380 9
	error = copyout(&vc->vc_cmap_red[index],   cm->red,   count);
	if (error)
		return error;
	error = copyout(&vc->vc_cmap_green[index], cm->green, count);
	if (error)
		return error;
	error = copyout(&vc->vc_cmap_blue[index],  cm->blue,  count);
	if (error)
		return error;
d386 1
a386 1
vgafb_putcmap(struct vga_config *vc, struct wsdisplay_cmap *cm)
d388 3
a390 4
	u_int index = cm->index;
	u_int count = cm->count;
	int error;
	u_int8_t *r, *g, *b;
d395 1
a395 10
	if ((error = copyin(cm->red, &vc->vc_cmap_red[index], count)) != 0)
		return (error);
	if ((error = copyin(cm->green, &vc->vc_cmap_green[index], count)) != 0)
		return (error);
	if ((error = copyin(cm->blue, &vc->vc_cmap_blue[index], count)) != 0)
		return (error);

	r = &(vc->vc_cmap_red[index]);
	g = &(vc->vc_cmap_green[index]);
	b = &(vc->vc_cmap_blue[index]);
d397 23
a419 1
	of_setcolors(index, count, r, g, b);
@


1.53
log
@Move the openfirmware color selection code outside of vgafb(4) to
be able to configure an early console framebuffer without depending
on this driver
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.52 2013/08/17 10:59:38 mpi Exp $	*/
a42 1
#include <macppc/pci/vgafbvar.h>
d44 12
d57 7
a63 2
struct cfdriver vgafb_cd = {
	NULL, "vgafb", DV_DULL,
d75 3
d79 1
a79 1
extern struct vga_config vgafbcn;
d113 11
d128 39
d490 84
@


1.52
log
@Because vgafb(4) only match the console, no need for an additional check
when setting up multiple screens and don't clear the screen again at this
moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.51 2013/08/17 09:15:47 mpi Exp $	*/
a57 1
void	vgafb_setcolor(struct vga_config *, u_int, uint8_t, uint8_t, uint8_t);
d101 1
a104 1
		const u_char *color;
d107 4
a110 1
		vgafb_setcolor(vc, i, color[0], color[1], color[2]);
d112 3
a329 21
struct {
	u_int8_t r;
	u_int8_t g;
	u_int8_t b;
} vgafb_color[256];

void
vgafb_setcolor(struct vga_config *vc, unsigned int index, u_int8_t r,
    u_int8_t g, u_int8_t b)
{
	vc->vc_cmap_red[index] = r;
	vc->vc_cmap_green[index] = g;
	vc->vc_cmap_blue[index] = b;

	vgafb_color[index].r = r;
	vgafb_color[index].g = g;
	vgafb_color[index].b = b;
	OF_call_method_1("set-colors", cons_display_ofh, 3,
	    &vgafb_color[index], index, 1);
}

a357 1
	u_int i;
d375 2
a376 8
	for (i = 0; i < count; i++) {
		vgafb_color[i].r = *r;
		vgafb_color[i].g = *g;
		vgafb_color[i].b = *b;
		r++, g++, b++;
	}
	OF_call_method_1("set-colors", cons_display_ofh, 3,
	    &vgafb_color, index, count);
d385 2
a386 7
	if (cons_backlight_available == 1 &&
	    vc->vc_backlight_on != on) {
		if (on == WSDISPLAYIO_VIDEO_ON) {
			OF_call_method_1("backlight-on", cons_display_ofh, 0);
		} else {
			OF_call_method_1("backlight-off", cons_display_ofh, 0);
		}
@


1.51
log
@Merge vgafb_init() into vgafb_cnattach() now that it is not used anywhere
else and pass the RI_FULLCLEAR flag to rasops_init() instead of clearing
the region directly.  This also makes the console to be correctly restored
when exiting X.  Previously a line at the bottom of the screen was never
cleared.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.50 2013/08/16 18:20:46 kettenis Exp $	*/
d113 1
a113 2
vgafb_wsdisplay_attach(struct device *parent, struct vga_config *vc,
    int console)
d116 2
d119 5
a123 12
	/* Setup virtual console now that we can allocate resources. */
	if (console) {
		struct rasops_info *ri = &vc->ri;
		long defattr;

		ri->ri_flg |= RI_VCONS | RI_WRONLY;
		rasops_init(ri, 160, 160);

		ri->ri_ops.alloc_attr(ri->ri_active, 0, 0, 0, &defattr);
		wsdisplay_cnattach(&vgafb_stdscreen, ri->ri_active,
		    0, 0, defattr);
	}
d125 1
a125 1
	aa.console = console;
@


1.50
log
@Use mapiodev instead of bus_space_map the do the initial mapping of the
frame buffer.  This allows radeondrm(4) to bus_space_map it without panicking.

ok mpi@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.49 2013/08/12 08:03:56 mpi Exp $	*/
a99 10
vgafb_init(bus_space_tag_t iot, bus_space_tag_t memt, struct vga_config *vc,
    u_int32_t  membase, size_t memsize)
{
	vc->vc_memt = memt;
	vc->membase = membase;
	vc->memsize = memsize;
	vc->vc_memh = (bus_space_handle_t)mapiodev(membase, memsize);
}

void
a300 1
	int i;
d302 4
a305 1
	vgafb_init(iot, memt, vc, cons_addr, cons_linebytes * cons_height);
d310 1
a310 5
	/* Clear the screen */
	for (i = 0; i < cons_linebytes * cons_height; i++)
		bus_space_write_1(memt,	vc->vc_memh, i, 0);

	ri->ri_flg = RI_CENTER;
@


1.49
log
@Match the framebuffer device against its OpenFirmware node in order
to share the console detection logic with sparc64 in radeondrm(4).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.48 2013/07/06 18:08:47 mpi Exp $	*/
d106 1
a106 4

	if (bus_space_map(vc->vc_memt, membase, memsize,
	    /* XXX */ppc_proc_is_64b ? 0 : 1, &vc->vc_memh))
		panic("vgafb_init: can't map mem space");
@


1.48
log
@Use the write-only rasops code to speed up the console framebuffer.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.47 2013/06/04 02:29:32 mpi Exp $	*/
d298 8
@


1.47
log
@Add support for virtual consoles, based on previous work done by kettenis@@
for inteldrm(4).

ok miod@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.46 2013/06/04 02:26:36 mpi Exp $	*/
d136 1
a136 1
		ri->ri_flg |= RI_VCONS;
@


1.46
log
@Remove unused includes, constify cfattach and other small cleanings.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.45 2013/06/04 02:20:18 mpi Exp $	*/
d131 13
a333 1
	vc->nscreens++;
d439 1
a439 10
	if (vc->nscreens > 0)
		return (ENOMEM);

	*cookiep = ri;
	*curxp = 0;
	*curyp = 0;
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, attrp);
	vc->nscreens++;

	return (0);
d446 1
d448 1
a448 4
	if (vc == &vgafbcn)
		panic("vgafb_free_screen: console");

	vc->nscreens--;
d455 7
a461 1
	return (0);
@


1.45
log
@Move function declaration where they belong.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.44 2013/06/04 02:16:14 mpi Exp $	*/
a32 1
#include <sys/kernel.h>
a33 3
#include <sys/buf.h>

#include <uvm/uvm_extern.h>
a36 4
#include <dev/cons.h>
#include <dev/ofw/openfirm.h>
#include <macppc/macppc/ofw_machdep.h>

a39 1
#include <dev/wsfont/wsfont.h>
d41 2
d45 1
d65 1
a65 1
	0, 0,   /* will be filled in -- XXX shouldn't, it's global */
d71 1
a73 1
	/* XXX other formats, graphics screen? */
d77 1
a77 1
	sizeof(vgafb_scrlist) / sizeof(struct wsscreen_descr *), vgafb_scrlist
a94 3
#define FONT_WIDTH 8
#define FONT_HEIGHT 16

a98 1

d300 4
d312 1
a312 5
	/* Clear the screen */
	for (i = 0; i < cons_linebytes * cons_height; i++)
		bus_space_write_1(memt,	vc->vc_memh, i, 0);

	rasops_init(ri, 160, 160);	/* XXX */
@


1.44
log
@Do not pretend mapping the MMIO region when in fact we don't and
clean some related code.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.43 2013/06/04 02:09:00 mpi Exp $	*/
d56 10
a65 3
void vgafb_setcolor(struct vga_config *vc, unsigned int index,
		    u_int8_t r, u_int8_t g, u_int8_t b);
void vgafb_restore_default_colors(struct vga_config *vc);
@


1.43
log
@Spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.42 2013/06/03 23:28:43 mpi Exp $	*/
d104 1
a104 1
    u_int32_t  membase, size_t memsize, u_int32_t mmiobase, size_t mmiosize)
a105 1
	vc->vc_iot = iot;
d107 2
a108 1
	vc->vc_paddr = membase;
a109 7
	if (mmiosize != 0)
	       if (bus_space_map(vc->vc_memt, mmiobase, mmiosize, 0,
		   &vc->vc_mmioh))
			panic("vgafb_init: couldn't map mmio");

	/* memsize should only be visible region for console */
	memsize = cons_height * cons_linebytes;
a112 3

	if (cons_depth == 8)
		vgafb_restore_default_colors(vc);
d276 1
a276 1
		 if (off >= vc->mmiobase && off < (vc->mmiobase+vc->mmiosize))
d282 1
a282 1
			return (vc->vc_paddr + off);
d298 4
a301 1
	vgafb_init(iot, memt, vc, cons_addr, cons_linebytes * cons_height,0, 0);
@


1.42
log
@There's no reason to have a separate structure to hold and duplicate
the raster display data.  Simplify this by using only one pointer to
a struct rasops_info, the one in vga_config.

While here remove unused fields from vga_config.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.41 2012/08/30 21:54:13 mpi Exp $	*/
d9 1
a9 1
 * 
d15 3
a17 3
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
d19 1
a19 1
 * 
d56 1
a56 1
void vgafb_setcolor(struct vga_config *vc, unsigned int index, 
d74 1
a74 1
   
d106 2
a107 2
        vc->vc_iot = iot;
        vc->vc_memt = memt;
d117 1
a117 1
        if (bus_space_map(vc->vc_memt, membase, memsize, 
d119 1
a119 1
		panic("vgafb_init: can't map mem space"); 
d127 1
a127 1
{ 
d144 1
a144 1
        aa.console = console;
d157 2
a158 2
 
        config_found(parent, &aa, wsemuldisplaydevprint);
d193 1
a193 1
		 * restore the last palette, workaround for 
d261 2
a262 2
	
        return (0);
d304 3
a306 3
        struct rasops_info *ri = &vc->ri;
        long defattr;
        int i;
d435 1
a435 1
        struct rasops_info *ri = &vc->ri;
@


1.41
log
@Determine the memory and mmio regions based on previously initialzed BAR
structures and add the necessary glue to attach drm(4).

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.40 2012/06/21 10:08:16 mpi Exp $	*/
d60 1
a60 7
struct vgafb_devconfig {
	struct rasops_info dc_rinfo;    /* raster display data */
	int dc_blanked;			/* currently had video disabled */
};

extern struct vga_config vgafb_pci_console_vc;
struct vgafb_devconfig vgafb_console_dc;
d121 1
a121 11
	vc->vc_crow = vc->vc_ccol = 0; /* Has to be some onscreen value */
	vc->vc_so = 0;

	/* clear screen, frob cursor, etc.? */
	/*
	*/

	vc->vc_at = 0x00 | 0xf;			/* black bg|white fg */
	vc->vc_so_at = 0x00 | 0xf | 0x80;	/* black bg|white fg|blink */

	if (cons_depth == 8) { 
a122 1
	}
d303 2
a304 3
	struct vga_config *vc = &vgafb_pci_console_vc;
	struct vgafb_devconfig *dc = &vgafb_console_dc;
        struct rasops_info *ri = &dc->dc_rinfo;
d316 1
a316 1
	ri->ri_hw = dc;
d435 1
a435 1
	long defattr;
d440 1
a440 1
	*cookiep = &vc->dc_rinfo; /* one and only for now */
d443 1
a443 3
	vc->dc_rinfo.ri_ops.alloc_attr(&vc->dc_rinfo, 0, 0, 0, &defattr);
	*attrp = defattr;

d454 1
a454 1
	if (vc == &vgafb_pci_console_vc)
@


1.40
log
@Only allow the memory and mmio regions to be mmap()'ed at their real
addresses, remove the magic value to uniformize access to the mmio and
doesn't map the unused pseudo-vga registers.

While here simplify the console attachement logic and removed some
unused global variables. Tested by matthieu@@ and myself on various
different G3 and G4 models.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.39 2012/01/29 14:20:42 mpi Exp $	*/
d56 1
a56 1
void vgafb_setcolor(struct vgafb_config *vc, unsigned int index, 
d58 1
a58 1
void vgafb_restore_default_colors(struct vgafb_config *vc);
d65 1
a65 1
extern struct vgafb_config vgafb_pci_console_vc;
d97 2
a98 2
int	vgafb_getcmap(struct vgafb_config *vc, struct wsdisplay_cmap *cm);
int	vgafb_putcmap(struct vgafb_config *vc, struct wsdisplay_cmap *cm);
d109 1
a109 1
vgafb_init(bus_space_tag_t iot, bus_space_tag_t memt, struct vgafb_config *vc,
d143 1
a143 1
vgafb_restore_default_colors(struct vgafb_config *vc)
d156 1
a156 1
vgafb_wsdisplay_attach(struct device *parent, struct vgafb_config *vc,
d181 1
a181 1
	struct vgafb_config *vc = v;
d285 1
a285 1
	struct vgafb_config *vc = v;
d320 1
a320 1
	struct vgafb_config *vc = &vgafb_pci_console_vc;
d361 1
a361 1
vgafb_setcolor(struct vgafb_config *vc, unsigned int index, u_int8_t r,
d376 1
a376 1
vgafb_getcmap(struct vgafb_config *vc, struct wsdisplay_cmap *cm)
d399 1
a399 1
vgafb_putcmap(struct vgafb_config *vc, struct wsdisplay_cmap *cm)
d435 1
a435 1
	struct vgafb_config *vc = v;
d452 1
a452 1
	struct vgafb_config *vc = v;
d472 1
a472 1
	struct vgafb_config *vc = v;
@


1.39
log
@Start cleaning vgafb(4) to be make it more like vga(4). Remove unused
function and move vgafb functions to there right place.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.38 2010/11/27 18:31:53 miod Exp $	*/
d109 1
a109 2
vgafb_common_setup(bus_space_tag_t iot, bus_space_tag_t  memt,
    struct vgafb_config *vc, u_int32_t iobase, size_t iosize,
a115 8
	if (iosize != 0) {
           if (bus_space_map(vc->vc_iot, iobase+0x3b0, 0xc, 0, &vc->vc_ioh_b))
		panic("vgafb_common_setup: couldn't map io b");
           if (bus_space_map(vc->vc_iot, iobase+0x3c0, 0x10, 0, &vc->vc_ioh_c))
		panic("vgafb_common_setup: couldn't map io c");
           if (bus_space_map(vc->vc_iot, iobase+0x3d0, 0x10, 0, &vc->vc_ioh_d))
		panic("vgafb_common_setup: couldn't map io d");
	}
d119 1
a119 1
			panic("vgafb_common_setup: couldn't map mmio");
d125 1
a125 4
		panic("vgafb_common_setup: can't map mem space"); 
	cons_display_mem_h = vc->vc_memh;
	vc->vc_ofh = cons_display_ofh;

d283 1
a283 1
vgafb_mmap(void *v, off_t offset, int prot)
d286 3
a288 1
	bus_space_handle_t h;
d293 12
a304 31
		if (allowaperture == 0) {
			h = -1;
			break;
		}
#endif	
		if (offset >= 0xa0000 && offset < 0xfffff)
			h = offset;
		/* XXX the following are probably wrong. 
		   we want physical addresses here, not virtual ones */
		else if (offset >= 0x10000000 && offset < 0x10040000 )
			/* 256KB of iohb */
			h = vc->vc_ioh_b;
		else if (offset >= 0x10040000 && offset < 0x10080000)
			/* 256KB of iohc */
			h = vc->vc_ioh_c;
		else if (offset >= 0x10080000 && offset < 0x100c0000)
			/* 256KB of iohd */
			h = vc->vc_ioh_d;
		else if (offset >= 0x20000000 && offset < 0x20000000+vc->mmiosize)
			/* mmiosize... */
			h = vc->vc_mmioh + (offset - 0x20000000);
		else if (offset >= vc->membase && (offset < vc->membase+vc->memsize)) {
		/* allow mmapping of memory */
			h = offset;
		} else if (offset >= vc->mmiobase &&
		    (offset < vc->mmiobase+vc->mmiosize)) {
			/* allow mmapping of mmio space */
			h = offset;
		} else {
			h = -1;
		}
d308 2
a309 4
		if (offset >= 0x00000 && offset < vc->memsize)
			h = vc->vc_paddr + offset;
		else
			h = -1;
d313 2
a314 1
	return h;
d317 2
a318 3
void
vgafb_cnattach(bus_space_tag_t iot, bus_space_tag_t  memt, void *pc, int bus,
    int  device, int function)
d320 3
d324 1
d326 1
a326 2
	struct vgafb_devconfig *dc = &vgafb_console_dc;
        struct rasops_info *ri = &dc->dc_rinfo;
d330 1
a330 1
	ri->ri_bits = (void *)cons_display_mem_h;
d336 4
d345 1
d349 3
@


1.38
log
@Remove unused vgafb_cnprobe().
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.37 2010/09/01 19:14:25 miod Exp $	*/
d65 1
a106 47
/*
 * The following functions implement back-end configuration grabbing
 * and attachment.
 */
int
vgafb_common_probe(bus_space_tag_t iot, bus_space_tag_t memt, u_int32_t iobase,
    size_t iosize, u_int32_t membase, size_t memsize, u_int32_t mmiobase,
    size_t mmiosize)
{
	bus_space_handle_t ioh_b, ioh_c, ioh_d, memh, mmioh;
	int gotio_b, gotio_c, gotio_d, gotmem, gotmmio, rv;

	gotio_b = gotio_c = gotio_d = gotmem = gotmmio = rv = 0;

	if (iosize != 0) {
		if (bus_space_map(iot, iobase+0x3b0, 0xc, 0, &ioh_b))
			goto bad;
		gotio_b = 1;
		if (bus_space_map(iot, iobase+0x3c0, 0x10, 0, &ioh_c))
			goto bad;
		gotio_c = 1;
		if (bus_space_map(iot, iobase+0x3d0, 0x10, 0, &ioh_d))
			goto bad;
		gotio_d = 1;
	}
	if (mmiosize != 0) {
		if (bus_space_map(iot, mmiobase, mmiosize, 0, &mmioh))
			goto bad;
		gotmmio = 1;
	}

	rv = 1;

bad:
	if (gotio_b)
		bus_space_unmap(iot, ioh_b, 0xc);
	if (gotio_c)
		bus_space_unmap(iot, ioh_c, 0x10);
	if (gotio_d)
		bus_space_unmap(iot, ioh_d, 0x10);
	if (gotmmio)
		bus_space_unmap(memt, mmioh, mmiosize);
	if (gotmem)
		bus_space_unmap(memt, memh, memsize);

	return (rv);
}
d466 39
@


1.37
log
@Fix typo in vgafb_mmap(), causing a comparison to always fail. ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.36 2009/03/29 21:53:52 sthen Exp $	*/
a390 10
}


void
vgafb_cnprobe(struct consdev *cp)
{
	if (cons_displaytype != 1)
		return;

	cp->cn_pri = CN_MIDPRI;
@


1.36
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.35 2008/09/23 20:45:27 miod Exp $	*/
d364 1
a364 1
		else if (offset >= 0x18880000 && offset < 0x100c0000)
a376 1
			
@


1.35
log
@Plug more uninitialized variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.34 2008/01/23 16:37:57 jsing Exp $	*/
d180 1
a180 1
		panic("vgafb_common_setup: couldn't map memory"); 
@


1.34
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.33 2006/12/17 22:18:14 miod Exp $	*/
d386 2
@


1.33
log
@Remove unnecessary <dev/wscons/wscons_raster.h> inclusion.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.32 2006/11/29 12:13:54 miod Exp $	*/
d399 1
a399 1
	cp->cn_pri = CN_INTERNAL;
@


1.32
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.31 2006/05/30 20:59:56 matthieu Exp $	*/
a46 1
#include <dev/wscons/wscons_raster.h>
@


1.31
log
@The aperture that is needed in legacy vga space is even larger for
the mac mini's ATI graphics card. The full 0xa0000-0xfffff range is
used here.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.30 2006/05/02 21:02:03 matthieu Exp $	*/
d224 1
@


1.30
log
@The r128 driver also need the 0xb0000-0xc0000 address range. found by Jolan@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.29 2006/04/28 20:21:42 matthieu Exp $	*/
d354 1
a354 1
		if (offset >= 0xa0000 && offset < 0xc0000)
@


1.29
log
@In mapped mode, when allowaperture != 0,also allow mmapping of the
PC-style 0xa0000-0xb0000 region, as the nv X driver uses it.
Noticed and patch tested by xsa@@ and aanriot@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.28 2006/04/09 12:22:56 matthieu Exp $	*/
d354 1
a354 1
		if (offset >= 0xa0000 && offset < 0xb0000)
@


1.28
log
@On macppc and sparc64, if allowaperture=0 only allow mmap()-ing of
the framebuffer memory in WSDISPLAYIO_MODE_DUMBFB mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.27 2006/01/01 11:59:39 miod Exp $	*/
d354 2
d358 1
a358 1
		if (offset >= 0x10000000 && offset < 0x10040000 )
@


1.27
log
@Let cons_init() and cons_init_bell() initialize the whole consdev structure,
thus removing the need for drivers to initialize cn_pri to CN_DEAD when
hardware probe fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.26 2005/10/26 18:57:51 martin Exp $	*/
d103 4
d265 1
d346 23
a368 18
	/* memsize... */
	if (offset >= 0x00000 && offset < vc->memsize)
		h = vc->vc_paddr + offset;
	/* XXX the following are probably wrong. we want physical addresses 
	   here, not virtual ones */
	else if (offset >= 0x10000000 && offset < 0x10040000 )
		/* 256KB of iohb */
		h = vc->vc_ioh_b;
	else if (offset >= 0x10040000 && offset < 0x10080000)
		/* 256KB of iohc */
		h = vc->vc_ioh_c;
	else if (offset >= 0x18880000 && offset < 0x100c0000)
		/* 256KB of iohd */
		h = vc->vc_ioh_d;
	else if (offset >= 0x20000000 && offset < 0x20000000+vc->mmiosize)
		/* mmiosize... */
		h = vc->vc_mmioh + (offset - 0x20000000);
	else if (offset >= vc->membase && (offset < vc->membase+vc->memsize)) {
d370 16
a385 7
		h = offset;
	} else if (offset >= vc->mmiobase &&
	    (offset < vc->mmiobase+vc->mmiosize)) {
		/* allow mmapping of mmio space */
		h = offset;
	} else {
		h = -1;
a386 1

@


1.26
log
@Mach-macro wipeout

'do it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.25 2005/10/08 05:47:25 drahn Exp $	*/
d376 1
a376 2
	if (cons_displaytype != 1) {
		cp->cn_pri = CN_DEAD;
a377 1
	} 
@


1.25
log
@Disable caching on vga buffer on 64bit machines. currently it causes
hangs.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.24 2005/01/05 23:04:24 miod Exp $	*/
a368 9
#ifdef alpha
	port = (u_int32_t *)(h << 5);
	return alpha_btop(port);		/* XXX */
#elif defined(i386)
	port = (u_int32_t *)(h << 5);
	return i386_btop(port);
#elif defined(__powerpc__)
	{
	/* huh ??? */
a369 5
	/*
	return powerpc_btop(port);
	*/
	}
#endif
@


1.24
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.23 2004/03/17 15:47:59 drahn Exp $	*/
d175 2
a176 1
        if (bus_space_map(vc->vc_memt, membase, memsize, 1, &vc->vc_memh))
@


1.23
log
@Better backlight detection on macppc, ok miod@@ krw@@ (a bit ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.22 2003/10/24 20:02:45 drahn Exp $	*/
a265 1

d268 1
a268 5

		/* now that we have done our work, let the wscons
		 * layer handle this ioctl
		 */
		return -1;
d320 2
d331 1
a331 2
        /* XXX */
        return -1;
@


1.22
log
@If cons_backlight_available is not set, cons_brightness will not be valid,
return -1 to indicate so. same as WSDISPLAYIO_PARAM_BACKLIGHT.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.21 2003/10/15 23:00:57 drahn Exp $	*/
d306 5
a310 2
			of_setbrightness(dp->curval);
			return 0;
d511 2
a512 1
	if (vc->vc_backlight_on != on) {
@


1.21
log
@Further down the ANSI/KNF road, only binary difference is __LINE__.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.20 2002/11/09 22:51:46 miod Exp $	*/
d281 7
a287 4
			dp->min = MIN_BRIGHTNESS;
			dp->max = MAX_BRIGHTNESS;
			dp->curval = cons_brightness;
			return 0;
@


1.20
log
@Instead of relying on uvm_useracc(), get a false sense of security, and
do not check copyin() result, take care and properly handle copyin() failure.

This was not harmful, but a bit more correctness never harms.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.19 2002/09/15 09:01:59 deraadt Exp $	*/
d108 3
a110 4
vgafb_common_probe(iot, memt, iobase, iosize, membase, memsize, mmiobase, mmiosize)
	bus_space_tag_t iot, memt;
	u_int32_t iobase, membase, mmiobase;
	size_t iosize, memsize, mmiosize;
d152 3
a154 5
vgafb_common_setup(iot, memt, vc, iobase, iosize, membase, memsize, mmiobase, mmiosize)
	bus_space_tag_t iot, memt;
	struct vgafb_config *vc;
	u_int32_t iobase, membase, mmiobase;
	size_t iosize, memsize, mmiosize;
d168 4
a171 4
	if (mmiosize != 0) {
           if (bus_space_map(vc->vc_memt, mmiobase, mmiosize, 0, &vc->vc_mmioh))
		panic("vgafb_common_setup: couldn't map mmio");
	}
d210 2
a211 4
vgafb_wsdisplay_attach(parent, vc, console)
	struct device *parent;
	struct vgafb_config *vc;
	int console;
d232 1
a232 6
vgafb_ioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d267 1
a267 1
		if (cons_depth == 8) { 
a268 1
		}
d333 1
a333 4
vgafb_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d385 1
a385 2
vgafb_cnprobe(cp)
	struct consdev *cp;
d396 2
a397 4
vgafb_cnattach(iot, memt, pc, bus, device, function)
	void *pc;
	bus_space_tag_t iot, memt;
	int bus, device, function;
d429 2
a430 4
vgafb_setcolor(vc, index, r, g, b) 
	struct vgafb_config *vc;
	unsigned int index;
	u_int8_t r, g, b;
d444 1
a444 3
vgafb_getcmap(vc, cm)
	struct vgafb_config *vc;
	struct wsdisplay_cmap *cm;
d467 1
a467 3
vgafb_putcmap(vc, cm)
	struct vgafb_config *vc;
	struct wsdisplay_cmap *cm;
d501 1
a501 3
vgafb_burn(v, on, flags)
	void *v;
	u_int on, flags;
@


1.19
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.17 2002/09/06 13:37:50 drahn Exp $	*/
d494 2
a495 1
	int i;
d500 7
a506 7
	if (!uvm_useracc(cm->red, count, B_READ) ||
	    !uvm_useracc(cm->green, count, B_READ) ||
	    !uvm_useracc(cm->blue, count, B_READ))
		return EFAULT;
	copyin(cm->red,   &(vc->vc_cmap_red[index]),   count);
	copyin(cm->green, &(vc->vc_cmap_green[index]), count);
	copyin(cm->blue,  &(vc->vc_cmap_blue[index]),  count);
@


1.18
log
@KNF
@
text
@d57 1
a57 1
void vgafb_setcolor(struct vgafb_config *vc, unsigned int index,
d70 1
a70 1
	0, 0,	/* will be filled in -- XXX shouldn't, it's global */
d80 1
a80 1

d159 2
a160 2
	vc->vc_iot = iot;
	vc->vc_memt = memt;
d164 6
a169 6
		if (bus_space_map(vc->vc_iot, iobase+0x3b0, 0xc, 0, &vc->vc_ioh_b))
			panic("vgafb_common_setup: couldn't map io b");
		if (bus_space_map(vc->vc_iot, iobase+0x3c0, 0x10, 0, &vc->vc_ioh_c))
			panic("vgafb_common_setup: couldn't map io c");
		if (bus_space_map(vc->vc_iot, iobase+0x3d0, 0x10, 0, &vc->vc_ioh_d))
			panic("vgafb_common_setup: couldn't map io d");
d172 2
a173 2
		if (bus_space_map(vc->vc_memt, mmiobase, mmiosize, 0, &vc->vc_mmioh))
			panic("vgafb_common_setup: couldn't map mmio");
d178 2
a179 2
	if (bus_space_map(vc->vc_memt, membase, memsize, 1, &vc->vc_memh))
		panic("vgafb_common_setup: couldn't map memory");
d194 1
a194 1
	if (cons_depth == 8) {
d201 1
a201 1
{
d220 1
a220 1
	aa.console = console;
d232 2
a233 2

	config_found(parent, &aa, wsemuldisplaydevprint);
d272 1
a272 1
		 * restore the last palette, workaround for
d277 1
a277 1
		if (cons_depth == 8) {
d320 1
a320 1
				    WSDISPLAYIO_VIDEO_OFF, 0);
d338 3
a340 3

	/* XXX */
	return -1;
d355 1
a355 1
	/* XXX the following are probably wrong. we want physical addresses
d405 1
a405 1
	}
d416 1
a416 1
	long defattr;
d419 1
a419 1
	struct rasops_info *ri = &dc->dc_rinfo;
d446 1
a446 1
vgafb_setcolor(vc, index, r, g, b)
@


1.17
log
@wscons display should have a console priority of INTERNAL, not REMOTE.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.16 2002/08/02 16:13:07 millert Exp $	*/
d57 1
a57 1
void vgafb_setcolor(struct vgafb_config *vc, unsigned int index, 
d70 1
a70 1
	0, 0,   /* will be filled in -- XXX shouldn't, it's global */
d80 1
a80 1
   
d159 2
a160 2
        vc->vc_iot = iot;
        vc->vc_memt = memt;
d164 6
a169 6
           if (bus_space_map(vc->vc_iot, iobase+0x3b0, 0xc, 0, &vc->vc_ioh_b))
		panic("vgafb_common_setup: couldn't map io b");
           if (bus_space_map(vc->vc_iot, iobase+0x3c0, 0x10, 0, &vc->vc_ioh_c))
		panic("vgafb_common_setup: couldn't map io c");
           if (bus_space_map(vc->vc_iot, iobase+0x3d0, 0x10, 0, &vc->vc_ioh_d))
		panic("vgafb_common_setup: couldn't map io d");
d172 2
a173 2
           if (bus_space_map(vc->vc_memt, mmiobase, mmiosize, 0, &vc->vc_mmioh))
		panic("vgafb_common_setup: couldn't map mmio");
d178 2
a179 2
        if (bus_space_map(vc->vc_memt, membase, memsize, 1, &vc->vc_memh))
		panic("vgafb_common_setup: couldn't map memory"); 
d194 1
a194 1
	if (cons_depth == 8) { 
d201 1
a201 1
{ 
d220 1
a220 1
        aa.console = console;
d232 2
a233 2
 
        config_found(parent, &aa, wsemuldisplaydevprint);
d272 1
a272 1
		 * restore the last palette, workaround for 
d277 1
a277 1
		if (cons_depth == 8) { 
d320 1
a320 1
				      WSDISPLAYIO_VIDEO_OFF, 0);
d338 3
a340 3
	
        /* XXX */
        return -1;
d355 1
a355 1
	/* XXX the following are probably wrong. we want physical addresses 
d405 1
a405 1
	} 
d416 1
a416 1
        long defattr;
d419 1
a419 1
        struct rasops_info *ri = &dc->dc_rinfo;
d446 1
a446 1
vgafb_setcolor(vc, index, r, g, b) 
@


1.16
log
@Do correct bounds checking in get/set/put cmap routines.  A few of
these check were already OK but have been modified for consistency.
Problem found by Silvio Cesare.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.15 2002/07/21 16:31:15 drahn Exp $	*/
d407 1
a407 1
	cp->cn_pri = CN_REMOTE;
@


1.15
log
@cleanup, mostly 'if 0'ed code removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.15 2002/07/21 16:32:47 drahn Exp $	*/
d471 1
a471 1
	if (index >= 256 || count > 256 || index + count > 256)
d492 2
a493 2
	int index = cm->index;
	int count = cm->count;
d497 1
a497 1
	if (index >= 256 || count > 256 || index + count > 256)
@


1.14
log
@Do not muck with the color palette unless the console depth is 8 bit.
32 bit depth console and wsfb now work (If firmware is forced to that depth).
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.13 2002/05/22 21:00:03 miod Exp $	*/
a44 6
#if 0
#include <dev/ic/mc6845.h>
#include <dev/ic/mc6845reg.h>
#include <dev/ic/vgareg.h>
#endif

a129 4
#if 0
		printf("vgafb_common_probe, mmio base %x size %x\n",
			mmiobase, mmiosize);
#endif
a131 1
		printf("vgafb_common_probe, mmio done\n");
a133 21
#if 0
	printf("vgafb_common_probe, mem base %x size %x memt %x\n",
		membase, memsize, memt);
#endif

#if 0
	if (bus_space_map(memt, membase, memsize, 0, &memh))
		goto bad;
	gotmem = 1;

	/* CR1 - Horiz. Display End */
	bus_space_write_1(iot, ioh_d, MC6845_INDEX, CRTC_HDISPLE);
	width = bus_space_read_1(iot, ioh_d, MC6845_DATA);
	/* this is not bit width yet */

	/* use CR17 - mode control for this?? */
	if ((width != 0xff) && (width < 600)) {
		/* not accessable or in graphics mode? */
		goto bad;
	}
#endif
a134 6
#if 0
	vgadata = bus_space_read_2(memt, memh, 0);
	bus_space_write_2(memt, memh, 0, 0xa55a);
	rv = (bus_space_read_2(memt, memh, 0) == 0xa55a);
	bus_space_write_2(memt, memh, 0, vgadata);
#else
a135 2
#endif

d175 1
a175 3
#if 0
	printf("commons setup mapping mem base %x size %x\n", membase, memsize);
#endif
a181 3
#if 0
	printf("display_mem_h %x\n", cons_display_mem_h );
#endif
a182 43
#if 0
	if (iosize != 0) {
		/* CR1 - Horiz. Display End */
		bus_space_write_1(iot, vc->vc_ioh_d, MC6845_INDEX, CRTC_HDISPLE);
		width = bus_space_read_1(iot, vc->vc_ioh_d, MC6845_DATA);
		/* (stored value + 1) * depth -> pixel width */
		width = (width + 1) * 8;   

		/* CR1 - Horiz. Display End */
		{ 
			u_int8_t t1, t2, t3;
			bus_space_write_1(iot, vc->vc_ioh_d, MC6845_INDEX, CRTC_VDE);
			t1 = bus_space_read_1(iot, vc->vc_ioh_d, MC6845_DATA);

			bus_space_write_1(iot, vc->vc_ioh_d, MC6845_INDEX, CRTC_OVERFLL);
			t2 = bus_space_read_1(iot, vc->vc_ioh_d, MC6845_DATA);
			height = t1 + ((t2&0x40) << 3) 
				    + ((t2&0x02) << 7) + 1; 
			bus_space_write_1(iot, vc->vc_ioh_d, MC6845_INDEX, CRTC_MODE);
			t3 = bus_space_read_1(iot, vc->vc_ioh_d, MC6845_DATA);
			if (t3 & 0x04) {
				height *= 2;
			}
			if (t1 == 0xff && t2 == 0xff && t3 == 0xff) {
				/* iospace not working??? */
				/* hope, better guess than 2048x2048 */
				width = 640;
				height = 480;
			}
		}
		vc->vc_ncol = width / FONT_WIDTH;
		vc->vc_nrow = height / FONT_HEIGHT;
	} else {
		/* iosize == 0
		 * default to 640x480 and hope 
		 */
		vc->vc_ncol = 640 / FONT_WIDTH;
		vc->vc_nrow = 480 / FONT_HEIGHT;
	}
	vc->vc_ncol = cons_width / FONT_WIDTH;
	vc->vc_nrow = cons_height / FONT_HEIGHT;
	printf(", %dx%d", vc->vc_ncol, vc->vc_nrow);
#endif
a190 9
#if defined(alpha)
	/*
	 * XXX DEC HAS SWITCHED THE CODES FOR BLUE AND RED!!!
	 * XXX Therefore, though the comments say "blue bg", the code uses
	 * XXX the value for a red background!
	 */
	vc->vc_at = 0x40 | 0x0f;		/* blue bg|white fg */
	vc->vc_so_at = 0x40 | 0x0f | 0x80;	/* blue bg|white fg|blink */
#else
d193 1
a193 1
#endif
a196 1

a407 10
#if 0
	for (j = 0; j < 2; j++) {
		for (i = 0; i < cons_width * cons_height; i++) {
			bus_space_write_1(cons_membus,
				cons_display_mem_h, i, j);

		}
	}
#endif

a419 2
#if 0
	ri->rc_sp = &vgafb_raster;
a420 10
	ri->rc_sp->width = cons_width;
	ri->rc_sp->height = cons_height;
	ri->rc_sp->depth = cons_depth;
	ri->rc_sp->linelongs = cons_linebytes / 4; /* XXX */
	ri->rc_sp->pixels = (void *)cons_display_mem_h;

	ri->rc_crow = ri->rc_ccol = -1;
	ri->rc_crowp = &ri->rc_crow;
	ri->rc_ccolp = &ri->rc_ccol;
#endif
@


1.13
log
@- in the OpenFirmware console initialisation, check if the console device
has support for backlight control (laptops do, and probably machines with
a built-in monitor do as well).
- provide a function to set the screen brightness as well.
- use both changes above to add a screen blanker to the vgafb driver
- let the screen brightness and backlight be controlled via wsconsctl
- clean dust, KNF, and more symbolic names in the vgafb driver to make it
better readable

Initial code by myself, with some hacks from drahn@@ later.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.12 2002/05/18 20:20:17 drahn Exp $	*/
d291 4
a294 1
	vgafb_restore_default_colors(vc);
d375 3
a377 1
		vgafb_restore_default_colors(vc);
@


1.12
log
@Workaround for color restoration on return from X. vgafb will not
reset the color palette to it's default colors when going back to text mode.
Would be better to fix this in the X server. ok matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.11 2002/04/29 22:07:56 drahn Exp $	*/
d43 7
d57 1
a57 12
#include <arch/macppc/pci/vgafbvar.h>

/* parameters set by OF to detect console */
extern int cons_displaytype;
extern bus_space_tag_t cons_membus;
extern bus_space_handle_t cons_display_mem_h;
extern bus_space_handle_t cons_display_ctl_h;
extern int cons_width;
extern int cons_linebytes;
extern int cons_height;
extern int cons_depth;
extern int cons_display_ofh;
d80 1
a80 1
	WSSCREEN_REVERSE|WSSCREEN_WSCOLORS
a90 1

d97 4
a100 2
	0, /* load_font */
	0 /* scrollback */
d136 1
d139 1
d156 2
a157 2
	bus_space_write_1(iot, ioh_d, 4, 0x1);
	width = bus_space_read_1(iot, ioh_d, 5);
a198 1

d218 1
a218 1
	/* memsize  should only be visable region for console */
d231 2
a232 2
		bus_space_write_1(iot, vc->vc_ioh_d, 4, 0x1);
		width = bus_space_read_1(iot, vc->vc_ioh_d, 5);
d234 1
a234 1
		width = ( width + 1 ) * 8;   
a236 1
		bus_space_write_1(iot, vc->vc_ioh_d, 4, 0x12);
d239 2
a240 2
			bus_space_write_1(iot, vc->vc_ioh_d, 4, 0x12);
			t1 = bus_space_read_1(iot, vc->vc_ioh_d, 5);
d242 2
a243 2
			bus_space_write_1(iot, vc->vc_ioh_d, 4, 0x7);
			t2 = bus_space_read_1(iot, vc->vc_ioh_d, 5);
d246 2
a247 2
			bus_space_write_1(iot, vc->vc_ioh_d, 4, 0x17);
			t3 = bus_space_read_1(iot, vc->vc_ioh_d, 5);
d298 1
d301 2
a302 1
		color = &rasops_cmap[i*3];
d319 8
d378 43
d501 1
a501 1
	#if 0
d509 1
a509 1
	#endif
d515 1
a515 1
	void * pc;
d529 1
a529 1
	ri->rc_sp->linelongs = cons_linebytes /4; /* XXX */
d544 1
a544 1
	rasops_init(ri, 160, 160);
d610 1
a610 1
	u_char *r, *g, *b;
d612 1
a612 2
	if (cm->index >= 256 || cm->count > 256 ||
	    (cm->index + cm->count) > 256)
d614 3
a616 3
	if (!uvm_useracc(cm->red, cm->count, B_READ) ||
	    !uvm_useracc(cm->green, cm->count, B_READ) ||
	    !uvm_useracc(cm->blue, cm->count, B_READ))
d630 1
a630 1
		r++, g++, b++, index++;
d633 1
a633 1
	    &vgafb_color, cm->index, count);
d635 17
@


1.11
log
@Better colors from rasops cmap, and enable all rasops features.
ok miod, mattheiu
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.10 2002/04/29 01:34:58 drahn Exp $	*/
d69 1
d294 11
a304 7
	{ 
	  int i;
	  for (i = 0; i < 256; i++) {
	     const u_char *color;
	     color = &rasops_cmap[i*3];
	     vgafb_setcolor(vc, i, color[0], color[1], color[2]);
	  }
d357 14
d378 1
d509 1
d520 3
a522 3
	vgafb_color[0].r = r;
	vgafb_color[0].g = g;
	vgafb_color[0].b = b;
d524 1
a524 1
	    &vgafb_color, index, 1);
@


1.10
log
@Change macppc vgafb from rcons to rasops, a faster color supporting virtual
terminal emulator for gfx console. tested by mattheiu, miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.9 2002/04/20 16:42:42 matthieu Exp $	*/
d82 1
d296 3
a298 1
	     vgafb_setcolor(vc, i, 255,255,255);
a300 9
	vgafb_setcolor(vc, WSCOL_BLACK, 0, 0, 0);
	vgafb_setcolor(vc, 255, 255, 255, 255);
	vgafb_setcolor(vc, WSCOL_RED, 255, 0, 0);
	vgafb_setcolor(vc, WSCOL_GREEN, 0, 255, 0);
	vgafb_setcolor(vc, WSCOL_BROWN, 154, 85, 46);
	vgafb_setcolor(vc, WSCOL_BLUE, 0, 0, 255);
	vgafb_setcolor(vc, WSCOL_MAGENTA, 255, 0, 255);
	vgafb_setcolor(vc, WSCOL_CYAN, 0, 255, 255);
	vgafb_setcolor(vc, WSCOL_WHITE, 255, 255, 255);
@


1.9
log
@- the set-colors OF call takes a packed array of colors value,
  remove the extra padding byte in the vgafb_color struct.
- store the initial colormap in vc->vc_cmap_{red,green,blue} so that
  it can be fetched by a WSDISPLAYIO_GETCMAP ioctl
- fix the definition of the magenta color in the initial colormap.
Ok, drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.8 2002/04/05 02:36:06 drahn Exp $	*/
d47 2
a48 1
#include <dev/rcons/raster.h>
a66 8
void	vgafb_cursor(void *, int, int, int);
void	vgafb_putchar(void *, int, int, u_int, long);
void	vgafb_copycols(void *, int, int, int, int);
void	vgafb_erasecols(void *, int, int, int);
void	vgafb_copyrows(void *, int, int, int);
void	vgafb_eraserows(void *, int, int);
void	vgafb_alloc_attr(void *c, int fg, int bg, int flags, long *);

d71 2
a72 1
	struct rcons dc_ri;
a73 2
struct raster vgafb_raster;

d82 1
a82 1
	WSSCREEN_REVERSE
a93 11
struct wsdisplay_emulops vgafb_emulops = {
	rcons_cursor,
	rcons_mapchar,
	rcons_putchar,
	rcons_copycols,
	rcons_erasecols,
	rcons_copyrows,
	rcons_eraserows,
	rcons_alloc_attr
};

d100 2
a101 1
	0 /* load_font */
d458 2
a459 1
        struct rcons *ri = &dc->dc_ri;
d467 1
d471 15
a485 18

	rcons_init(ri, 160, 160);

	vgafb_stdscreen.nrows = ri->rc_maxrow;
	vgafb_stdscreen.ncols = ri->rc_maxcol;
	vgafb_stdscreen.textops = &vgafb_emulops;
	rcons_alloc_attr(ri, 0, 0, 0, &defattr);

	#if 0
	{
		int i;
		for (i = 0; i < cons_width * cons_height; i++) {
			bus_space_write_1(cons_membus,
				cons_display_mem_h, i, 0x1);

		}
	}
	#endif
@


1.8
log
@Use the OF set-colors operation instead of the color! operation, this
interface seems to work on more machines, also is more efficient
when XF4/wsfb is setting the palette. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.7 2002/03/26 16:51:43 drahn Exp $	*/
d74 2
a75 1
void vgafb_setcolor(unsigned int index, u_int8_t r, u_int8_t g, u_int8_t b);
d310 15
d505 1
a505 15
	{ 
	  int i;
	  for (i = 0; i < 256; i++) {
	     vgafb_setcolor(i, 255,255,255);
	  }
	}
	vgafb_setcolor(WSCOL_BLACK, 0, 0, 0);
	vgafb_setcolor(255, 255, 255, 255);
	vgafb_setcolor(WSCOL_RED, 255, 0, 0);
	vgafb_setcolor(WSCOL_GREEN, 0, 255, 0);
	vgafb_setcolor(WSCOL_BROWN, 154, 85, 46);
	vgafb_setcolor(WSCOL_BLUE, 0, 0, 255);
	vgafb_setcolor(WSCOL_MAGENTA, 255, 255, 0);
	vgafb_setcolor(WSCOL_CYAN, 0, 255, 255);
	vgafb_setcolor(WSCOL_WHITE, 255, 255, 255);
a512 1
	u_int8_t pad;
d515 2
a516 1
vgafb_setcolor(index, r, g, b) 
d520 4
@


1.7
log
@Only allow valid device PAs to be mmapped.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.6 2002/03/14 01:26:37 millert Exp $	*/
d507 6
d518 5
a522 1
	OF_call_method_1("color!", cons_display_ofh, 4, r, g, b, index);
d576 3
a578 1
		OF_call_method_1("color!", vc->vc_ofh, 4, *r, *g, *b, index);
d581 2
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.5 2001/12/14 03:08:54 jason Exp $	*/
d384 1
a384 1
	if (offset >= 0x00000 && offset < 0x800000)	/* 8MB of mem??? */
d397 1
a397 1
	else if (offset >= 0x20000000 && offset < 0x30000000)
d400 6
a405 8
	else {
		/* XXX - allow mapping of the actual physical
		 * device address, if the address is read from
		 * pci bus config space
		 */

		/* NEEDS TO BE RESTRICTED to valid addresses for this device */
		 
d407 2
@


1.5
log
@garbage collect some unused stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.4 2001/11/06 19:53:15 miod Exp $	*/
d66 7
a72 7
void	vgafb_cursor __P((void *, int, int, int));
void	vgafb_putchar __P((void *, int, int, u_int, long));
void	vgafb_copycols __P((void *, int, int, int, int));
void	vgafb_erasecols __P((void *, int, int, int));
void	vgafb_copyrows __P((void *, int, int, int));
void	vgafb_eraserows __P((void *, int, int));
void	vgafb_alloc_attr __P((void *c, int fg, int bg, int flags, long *));
d74 1
a74 1
void vgafb_setcolor __P((unsigned int index, u_int8_t r, u_int8_t g, u_int8_t b));
d121 2
a122 2
int	vgafb_getcmap __P((struct vgafb_config *vc, struct wsdisplay_cmap *cm));
int	vgafb_putcmap __P((struct vgafb_config *vc, struct wsdisplay_cmap *cm));
@


1.5.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.5 2001/12/14 03:08:54 jason Exp $	*/
a42 7
#include <macppc/macppc/ofw_machdep.h>

#if 0
#include <dev/ic/mc6845.h>
#include <dev/ic/mc6845reg.h>
#include <dev/ic/vgareg.h>
#endif
d47 1
a47 2
#include <dev/rasops/rasops.h>
#include <dev/wsfont/wsfont.h>
d49 12
a60 1
#include <macppc/pci/vgafbvar.h>
d66 9
a74 3
void vgafb_setcolor(struct vgafb_config *vc, unsigned int index, 
		    u_int8_t r, u_int8_t g, u_int8_t b);
void vgafb_restore_default_colors(struct vgafb_config *vc);
d77 1
a77 2
	struct rasops_info dc_rinfo;    /* raster display data */
	int dc_blanked;			/* currently had video disabled */
d79 2
d89 1
a89 2
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
d100 12
d118 1
a118 4
	NULL,		/* load_font */
	NULL,		/* scrollback */
	NULL,		/* getchar */
	vgafb_burn,	/* burner */
d121 2
a122 2
int	vgafb_getcmap(struct vgafb_config *vc, struct wsdisplay_cmap *cm);
int	vgafb_putcmap(struct vgafb_config *vc, struct wsdisplay_cmap *cm);
a153 1
#if 0
a155 1
#endif
d172 2
a173 2
	bus_space_write_1(iot, ioh_d, MC6845_INDEX, CRTC_HDISPLE);
	width = bus_space_read_1(iot, ioh_d, MC6845_DATA);
d215 1
d235 1
a235 1
	/* memsize should only be visible region for console */
d248 2
a249 2
		bus_space_write_1(iot, vc->vc_ioh_d, MC6845_INDEX, CRTC_HDISPLE);
		width = bus_space_read_1(iot, vc->vc_ioh_d, MC6845_DATA);
d251 1
a251 1
		width = (width + 1) * 8;   
d254 1
d257 2
a258 2
			bus_space_write_1(iot, vc->vc_ioh_d, MC6845_INDEX, CRTC_VDE);
			t1 = bus_space_read_1(iot, vc->vc_ioh_d, MC6845_DATA);
d260 2
a261 2
			bus_space_write_1(iot, vc->vc_ioh_d, MC6845_INDEX, CRTC_OVERFLL);
			t2 = bus_space_read_1(iot, vc->vc_ioh_d, MC6845_DATA);
d264 2
a265 2
			bus_space_write_1(iot, vc->vc_ioh_d, MC6845_INDEX, CRTC_MODE);
			t3 = bus_space_read_1(iot, vc->vc_ioh_d, MC6845_DATA);
a308 14
	vgafb_restore_default_colors(vc);
}

void
vgafb_restore_default_colors(struct vgafb_config *vc)
{ 
	int i;

	for (i = 0; i < 256; i++) {
		const u_char *color;

		color = &rasops_cmap[i * 3];
		vgafb_setcolor(vc, i, color[0], color[1], color[2]);
	}
a322 8

	/* no need to keep the burner function if no hw support */
	if (cons_backlight_available == 0)
		vgafb_accessops.burn_screen = NULL;
	else {
		vc->vc_backlight_on = WSDISPLAYIO_VIDEO_OFF;
		vgafb_burn(vc, WSDISPLAYIO_VIDEO_ON, 0);	/* paranoia */
	}
a359 57
	case WSDISPLAYIO_SMODE:
		/* track the state of the display,
		 * if returning to WSDISPLAYIO_MODE_EMUL
		 * restore the last palette, workaround for 
		 * bad accellerated X servers that does not restore
		 * the correct palette.
		 */

		vgafb_restore_default_colors(vc);

		/* now that we have done our work, let the wscons
		 * layer handle this ioctl
		 */
		return -1;

	case WSDISPLAYIO_GETPARAM:
	{
		struct wsdisplay_param *dp = (struct wsdisplay_param *)data;

		switch (dp->param) {
		case WSDISPLAYIO_PARAM_BRIGHTNESS:
			dp->min = MIN_BRIGHTNESS;
			dp->max = MAX_BRIGHTNESS;
			dp->curval = cons_brightness;
			return 0;
		case WSDISPLAYIO_PARAM_BACKLIGHT:
			if (cons_backlight_available != 0) {
				dp->min = 0;
				dp->max = 1;
				dp->curval = vc->vc_backlight_on;
				return 0;
			} else
				return -1;
		}
	}
		return -1;

	case WSDISPLAYIO_SETPARAM:
	{
		struct wsdisplay_param *dp = (struct wsdisplay_param *)data;

		switch (dp->param) {
		case WSDISPLAYIO_PARAM_BRIGHTNESS:
			of_setbrightness(dp->curval);
			return 0;
		case WSDISPLAYIO_PARAM_BACKLIGHT:
			if (cons_backlight_available != 0) {
				vgafb_burn(vc,
				    dp->curval ? WSDISPLAYIO_VIDEO_ON :
				      WSDISPLAYIO_VIDEO_OFF, 0);
				return 0;
			} else
				return -1;
		}
	}
		return -1;

a366 1
	default:
d384 1
a384 1
	if (offset >= 0x00000 && offset < vc->memsize)
d397 1
a397 1
	else if (offset >= 0x20000000 && offset < 0x20000000+vc->mmiosize)
d400 8
a407 6
	else if (offset >= vc->membase && (offset < vc->membase+vc->memsize)) {
		/* allow mmapping of memory */
		h = offset;
	} else if (offset >= vc->mmiobase &&
	    (offset < vc->mmiobase+vc->mmiosize)) {
		/* allow mmapping of mmio space */
a408 2
	} else {
		h = -1;
d439 1
a439 1
#if 0
d447 1
a447 1
#endif
d453 1
a453 1
	void *pc;
d460 1
a460 2
        struct rasops_info *ri = &dc->dc_rinfo;
#if 0
d466 1
a466 1
	ri->rc_sp->linelongs = cons_linebytes / 4; /* XXX */
a467 1

a470 15
#endif
	ri->ri_flg = RI_CENTER;
	ri->ri_depth = cons_depth;
	ri->ri_bits = (void *)cons_display_mem_h;
	ri->ri_width = cons_width;
	ri->ri_height = cons_height;
	ri->ri_stride = cons_linebytes;
	ri->ri_hw = dc;

	rasops_init(ri, 160, 160);	/* XXX */

	vgafb_stdscreen.nrows = ri->ri_rows;
	vgafb_stdscreen.ncols = ri->ri_cols;
	vgafb_stdscreen.textops = &ri->ri_ops;
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);
d472 32
a506 6
struct {
	u_int8_t r;
	u_int8_t g;
	u_int8_t b;
} vgafb_color[256];

d508 1
a508 2
vgafb_setcolor(vc, index, r, g, b) 
	struct vgafb_config *vc;
d512 1
a512 9
	vc->vc_cmap_red[index] = r;
	vc->vc_cmap_green[index] = g;
	vc->vc_cmap_blue[index] = b;

	vgafb_color[index].r = r;
	vgafb_color[index].g = g;
	vgafb_color[index].b = b;
	OF_call_method_1("set-colors", cons_display_ofh, 3,
	    &vgafb_color[index], index, 1);
d548 1
a548 1
	u_int8_t *r, *g, *b;
d550 2
a551 1
	if (index >= 256 || count > 256 || index + count > 256)
d553 3
a555 3
	if (!uvm_useracc(cm->red, count, B_READ) ||
	    !uvm_useracc(cm->green, count, B_READ) ||
	    !uvm_useracc(cm->blue, count, B_READ))
d566 2
a567 4
		vgafb_color[i].r = *r;
		vgafb_color[i].g = *g;
		vgafb_color[i].b = *b;
		r++, g++, b++;
a568 2
	OF_call_method_1("set-colors", cons_display_ofh, 3,
	    &vgafb_color, index, count);
a569 17
}

void
vgafb_burn(v, on, flags)
	void *v;
	u_int on, flags;
{
	struct vgafb_config *vc = v;

	if (vc->vc_backlight_on != on) {
		if (on == WSDISPLAYIO_VIDEO_ON) {
			OF_call_method_1("backlight-on", cons_display_ofh, 0);
		} else {
			OF_call_method_1("backlight-off", cons_display_ofh, 0);
		}
		vc->vc_backlight_on = on;
	}
@


1.5.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.5.2.1 2002/06/11 03:36:34 art Exp $	*/
d45 6
d136 4
d142 1
d145 4
d150 23
d174 2
d215 3
a217 1

d224 3
d228 43
d279 9
d290 2
a291 4

	if (cons_depth == 8) { 
		vgafb_restore_default_colors(vc);
	}
d372 1
a372 3
		if (cons_depth == 8) { 
			vgafb_restore_default_colors(vc);
		}
d500 11
a510 1
	cp->cn_pri = CN_INTERNAL;
d523 2
d526 10
d586 1
a586 1
	if (index >= 256 || count > 256 - index)
d607 2
a608 2
	u_int index = cm->index;
	u_int count = cm->count;
d612 1
a612 1
	if (index >= 256 || count > 256 - index)
@


1.5.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d494 1
a494 2
	u_int i;
	int error;
d499 7
a505 7

	if ((error = copyin(cm->red, &vc->vc_cmap_red[index], count)) != 0)
		return (error);
	if ((error = copyin(cm->green, &vc->vc_cmap_green[index], count)) != 0)
		return (error);
	if ((error = copyin(cm->blue, &vc->vc_cmap_blue[index], count)) != 0)
		return (error);
@


1.4
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.3 2001/09/17 15:10:36 drahn Exp $	*/
a74 1
extern const char fontdata_8x16[];
a120 1
int	vgafb_print __P((void *, const char *));
a326 12

int
vgafb_print(aux, pnp)
	void *aux;
	const char *pnp;
{

	if (pnp)
		printf("wsdisplay at %s", pnp);
	return (UNCONF);
}

a450 1
extern struct raster_font fontdata8x16;
@


1.3
log
@The gfx display buffer should request that it be mapped cached (writethru).
Not used yet, but when the bus_space_map code and pmap are fixed,
this will speed up the console.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.2 2001/09/13 13:38:45 drahn Exp $	*/
a36 1
#include <vm/vm.h>
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Merge in -current
@
text
@d37 1
@


1.3.4.3
log
@Merge in trunk
@
text
@d75 1
d122 1
d329 12
d465 1
@


1.3.4.4
log
@Merge in -current from about a week ago
@
text
@d66 7
a72 7
void	vgafb_cursor(void *, int, int, int);
void	vgafb_putchar(void *, int, int, u_int, long);
void	vgafb_copycols(void *, int, int, int, int);
void	vgafb_erasecols(void *, int, int, int);
void	vgafb_copyrows(void *, int, int, int);
void	vgafb_eraserows(void *, int, int);
void	vgafb_alloc_attr(void *c, int fg, int bg, int flags, long *);
d74 1
a74 1
void vgafb_setcolor(unsigned int index, u_int8_t r, u_int8_t g, u_int8_t b);
d121 2
a122 2
int	vgafb_getcmap(struct vgafb_config *vc, struct wsdisplay_cmap *cm);
int	vgafb_putcmap(struct vgafb_config *vc, struct wsdisplay_cmap *cm);
@


1.3.4.5
log
@Sync the SMP branch with 3.3
@
text
@a42 1
#include <macppc/macppc/ofw_machdep.h>
d47 1
a47 2
#include <dev/rasops/rasops.h>
#include <dev/wsfont/wsfont.h>
d49 12
a60 1
#include <macppc/pci/vgafbvar.h>
d66 9
a74 3
void vgafb_setcolor(struct vgafb_config *vc, unsigned int index, 
		    u_int8_t r, u_int8_t g, u_int8_t b);
void vgafb_restore_default_colors(struct vgafb_config *vc);
d77 1
a77 2
	struct rasops_info dc_rinfo;    /* raster display data */
	int dc_blanked;			/* currently had video disabled */
d79 2
d89 1
a89 2
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
d100 12
d118 1
a118 4
	NULL,		/* load_font */
	NULL,		/* scrollback */
	NULL,		/* getchar */
	vgafb_burn,	/* burner */
d154 2
d158 1
d161 4
d166 23
d190 2
d215 1
d232 4
a235 2

	/* memsize should only be visible region for console */
d241 3
d245 44
d297 9
d308 1
a308 17

	if (cons_depth == 8) { 
		vgafb_restore_default_colors(vc);
	}
}

void
vgafb_restore_default_colors(struct vgafb_config *vc)
{ 
	int i;

	for (i = 0; i < 256; i++) {
		const u_char *color;

		color = &rasops_cmap[i * 3];
		vgafb_setcolor(vc, i, color[0], color[1], color[2]);
	}
a322 8

	/* no need to keep the burner function if no hw support */
	if (cons_backlight_available == 0)
		vgafb_accessops.burn_screen = NULL;
	else {
		vc->vc_backlight_on = WSDISPLAYIO_VIDEO_OFF;
		vgafb_burn(vc, WSDISPLAYIO_VIDEO_ON, 0);	/* paranoia */
	}
a359 59
	case WSDISPLAYIO_SMODE:
		/* track the state of the display,
		 * if returning to WSDISPLAYIO_MODE_EMUL
		 * restore the last palette, workaround for 
		 * bad accellerated X servers that does not restore
		 * the correct palette.
		 */

		if (cons_depth == 8) { 
			vgafb_restore_default_colors(vc);
		}

		/* now that we have done our work, let the wscons
		 * layer handle this ioctl
		 */
		return -1;

	case WSDISPLAYIO_GETPARAM:
	{
		struct wsdisplay_param *dp = (struct wsdisplay_param *)data;

		switch (dp->param) {
		case WSDISPLAYIO_PARAM_BRIGHTNESS:
			dp->min = MIN_BRIGHTNESS;
			dp->max = MAX_BRIGHTNESS;
			dp->curval = cons_brightness;
			return 0;
		case WSDISPLAYIO_PARAM_BACKLIGHT:
			if (cons_backlight_available != 0) {
				dp->min = 0;
				dp->max = 1;
				dp->curval = vc->vc_backlight_on;
				return 0;
			} else
				return -1;
		}
	}
		return -1;

	case WSDISPLAYIO_SETPARAM:
	{
		struct wsdisplay_param *dp = (struct wsdisplay_param *)data;

		switch (dp->param) {
		case WSDISPLAYIO_PARAM_BRIGHTNESS:
			of_setbrightness(dp->curval);
			return 0;
		case WSDISPLAYIO_PARAM_BACKLIGHT:
			if (cons_backlight_available != 0) {
				vgafb_burn(vc,
				    dp->curval ? WSDISPLAYIO_VIDEO_ON :
				      WSDISPLAYIO_VIDEO_OFF, 0);
				return 0;
			} else
				return -1;
		}
	}
		return -1;

a366 1
	default:
d384 1
a384 1
	if (offset >= 0x00000 && offset < vc->memsize)
d397 1
a397 1
	else if (offset >= 0x20000000 && offset < 0x20000000+vc->mmiosize)
d400 8
a407 6
	else if (offset >= vc->membase && (offset < vc->membase+vc->memsize)) {
		/* allow mmapping of memory */
		h = offset;
	} else if (offset >= vc->mmiobase &&
	    (offset < vc->mmiobase+vc->mmiosize)) {
		/* allow mmapping of mmio space */
a408 2
	} else {
		h = -1;
d438 11
a448 1
	cp->cn_pri = CN_INTERNAL;
d453 1
a453 1
	void *pc;
d460 2
a461 1
        struct rasops_info *ri = &dc->dc_rinfo;
d463 15
a477 14
	ri->ri_flg = RI_CENTER;
	ri->ri_depth = cons_depth;
	ri->ri_bits = (void *)cons_display_mem_h;
	ri->ri_width = cons_width;
	ri->ri_height = cons_height;
	ri->ri_stride = cons_linebytes;
	ri->ri_hw = dc;

	rasops_init(ri, 160, 160);	/* XXX */

	vgafb_stdscreen.nrows = ri->ri_rows;
	vgafb_stdscreen.ncols = ri->ri_cols;
	vgafb_stdscreen.textops = &ri->ri_ops;
	ri->ri_ops.alloc_attr(ri, 0, 0, 0, &defattr);
d479 25
a506 6
struct {
	u_int8_t r;
	u_int8_t g;
	u_int8_t b;
} vgafb_color[256];

d508 1
a508 2
vgafb_setcolor(vc, index, r, g, b) 
	struct vgafb_config *vc;
d512 1
a512 9
	vc->vc_cmap_red[index] = r;
	vc->vc_cmap_green[index] = g;
	vc->vc_cmap_blue[index] = b;

	vgafb_color[index].r = r;
	vgafb_color[index].g = g;
	vgafb_color[index].b = b;
	OF_call_method_1("set-colors", cons_display_ofh, 3,
	    &vgafb_color[index], index, 1);
d524 1
a524 1
	if (index >= 256 || count > 256 - index)
d545 4
a548 5
	u_int index = cm->index;
	u_int count = cm->count;
	u_int i;
	int error;
	u_int8_t *r, *g, *b;
d550 2
a551 1
	if (index >= 256 || count > 256 - index)
d553 7
a559 7

	if ((error = copyin(cm->red, &vc->vc_cmap_red[index], count)) != 0)
		return (error);
	if ((error = copyin(cm->green, &vc->vc_cmap_green[index], count)) != 0)
		return (error);
	if ((error = copyin(cm->blue, &vc->vc_cmap_blue[index], count)) != 0)
		return (error);
d566 2
a567 4
		vgafb_color[i].r = *r;
		vgafb_color[i].g = *g;
		vgafb_color[i].b = *b;
		r++, g++, b++;
a568 2
	OF_call_method_1("set-colors", cons_display_ofh, 3,
	    &vgafb_color, index, count);
a569 17
}

void
vgafb_burn(v, on, flags)
	void *v;
	u_int on, flags;
{
	struct vgafb_config *vc = v;

	if (vc->vc_backlight_on != on) {
		if (on == WSDISPLAYIO_VIDEO_ON) {
			OF_call_method_1("backlight-on", cons_display_ofh, 0);
		} else {
			OF_call_method_1("backlight-off", cons_display_ofh, 0);
		}
		vc->vc_backlight_on = on;
	}
@


1.3.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d108 4
a111 3
vgafb_common_probe(bus_space_tag_t iot, bus_space_tag_t memt, u_int32_t iobase,
    size_t iosize, u_int32_t membase, size_t memsize, u_int32_t mmiobase,
    size_t mmiosize)
d153 5
a157 3
vgafb_common_setup(bus_space_tag_t iot, bus_space_tag_t  memt,
    struct vgafb_config *vc, u_int32_t iobase, size_t iosize,
    u_int32_t  membase, size_t memsize, u_int32_t mmiobase, size_t mmiosize)
d171 4
a174 4
	if (mmiosize != 0)
	       if (bus_space_map(vc->vc_memt, mmiobase, mmiosize, 0,
		   &vc->vc_mmioh))
			panic("vgafb_common_setup: couldn't map mmio");
d213 4
a216 2
vgafb_wsdisplay_attach(struct device *parent, struct vgafb_config *vc,
    int console)
d237 6
a242 1
vgafb_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
d277 1
a277 1
		if (cons_depth == 8)
d279 1
d292 4
a295 7
			if (cons_backlight_available != 0) {
				dp->min = MIN_BRIGHTNESS;
				dp->max = MAX_BRIGHTNESS;
				dp->curval = cons_brightness;
				return 0;
			}
			return -1;
d344 4
a347 1
vgafb_mmap(void *v, off_t offset, int prot)
d399 2
a400 1
vgafb_cnprobe(struct consdev *cp)
d411 4
a414 2
vgafb_cnattach(bus_space_tag_t iot, bus_space_tag_t  memt, void *pc, int bus,
    int  device, int function)
d446 4
a449 2
vgafb_setcolor(struct vgafb_config *vc, unsigned int index, u_int8_t r,
    u_int8_t g, u_int8_t b)
d463 3
a465 1
vgafb_getcmap(struct vgafb_config *vc, struct wsdisplay_cmap *cm)
d488 3
a490 1
vgafb_putcmap(struct vgafb_config *vc, struct wsdisplay_cmap *cm)
d524 3
a526 1
vgafb_burn(void *v, u_int on, u_int flags)
@


1.3.4.7
log
@Merge with the trunk
@
text
@d306 2
a307 5
			if (cons_backlight_available == 1) {
				of_setbrightness(dp->curval);
				return 0;
			} else
				return -1;
d508 1
a508 2
	if (cons_backlight_available == 1 &&
	    vc->vc_backlight_on != on) {
@


1.2
log
@The vgafb driver does not test memory, so no point mapping it during the probe.
Also, there is no point in mapping more than the 'visual' area for vga memory.
this will save kvm space on large memory display cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.1 2001/09/01 15:55:17 drahn Exp $	*/
d240 1
a240 1
        if (bus_space_map(vc->vc_memt, membase, memsize, 0, &vc->vc_memh))
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/pci to macppc/pci

The file pci_machdep.h was not moved in this conversion.
It needs to be check if it is correct that should be the only shared
powerpc/pci file. Or if that file too should be MD, or more files MI.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb.c,v 1.14 2001/07/09 03:54:40 mickey Exp $	*/
d169 1
a173 1
#if 0
d186 1
a186 1
	#if 0
d191 1
a191 1
	#else
d193 1
a193 1
	#endif
d238 2
@

