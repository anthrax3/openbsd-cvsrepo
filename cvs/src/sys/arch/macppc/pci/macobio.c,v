head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.2
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.21.0.10
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.6
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.20.0.6
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.10
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.8
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.4
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.2
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.19.0.6
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.16
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.12
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.10
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.8
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.7
	UBC:1.2.0.6
	UBC_BASE:1.2
	SMP:1.2.0.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.22
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	uRv5pa9QDlZaYgwD;

1.21
date	2015.04.02.11.12.24;	author mpi;	state Exp;
branches;
next	1.20;
commitid	H6AjB4yqSabDCpNM;

1.20
date	2012.12.10.16.32.13;	author mpi;	state Exp;
branches;
next	1.19;

1.19
date	2011.05.15.09.10.26;	author mpi;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.19.22.42.35;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.02.14.23.05.28;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.17.00.24.55;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.07.03.47.31;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.02.22.09.40;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2005.09.29.23.58.06;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.26.19.54.50;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.08.19.08.23;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.15.23.00.56;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.12.09.00.31;	author tdeval;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.06.13.56.51;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.03.15.56;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.15.01.42.55;	author mickey;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	2001.09.01.15.55.17;	author drahn;	state Exp;
branches;
next	;

1.2.4.1
date	2001.10.31.03.01.16;	author nate;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2003.05.13.19.41.05;	author ho;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.2.6.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.22
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: macobio.c,v 1.21 2015/04/02 11:12:24 mpi Exp $	*/
/*	$NetBSD: obio.c,v 1.6 1999/05/01 10:36:08 tsubai Exp $	*/

/*-
 * Copyright (C) 1998	Internet Research Institute, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by
 *	Internet Research Institute, Inc.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/ofw/openfirm.h>

#include <machine/bus.h>
#include <machine/autoconf.h>
#include <macppc/pci/macobio.h>

void macobio_attach(struct device *, struct device *, void *);
int macobio_match(struct device *, void *, void *);
int macobio_print(void *, const char *);
void macobio_modem_power(int enable);

struct macobio_softc {
	struct device sc_dev;
	int sc_node;
	struct ppc_bus_space sc_membus_space;
	int	sc_id; /* copy of the PCI pa_id */
	u_int8_t *obiomem;
};
struct cfdriver macobio_cd = {
	NULL, "macobio", DV_DULL,
};


struct cfattach macobio_ca = {
	sizeof(struct macobio_softc), macobio_match, macobio_attach
};

int
macobio_match(struct device *parent, void *cf, void *aux)
{
	struct pci_attach_args *pa = aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_APPLE)
		switch (PCI_PRODUCT(pa->pa_id)) {

		case PCI_PRODUCT_APPLE_GC:
		case PCI_PRODUCT_APPLE_OHARE:
		case PCI_PRODUCT_APPLE_HEATHROW:
		case PCI_PRODUCT_APPLE_PADDINGTON:
		case PCI_PRODUCT_APPLE_KEYLARGO:
		case PCI_PRODUCT_APPLE_INTREPID:
		case PCI_PRODUCT_APPLE_PANGEA_MACIO:
		case PCI_PRODUCT_APPLE_SHASTA:
		case PCI_PRODUCT_APPLE_K2_MACIO:
			return 1;
		}

	return 0;
}

#define HEATHROW_FCR_OFFSET 0x38
u_int32_t *heathrow_FCR = NULL;

/*
 * Attach all the sub-devices we can find
 */
void
macobio_attach(struct device *parent, struct device *self, void *aux)
{
	struct macobio_softc *sc = (struct macobio_softc *)self;
	struct pci_attach_args *pa = aux;
	struct confargs ca;
	int node, child, namelen;
	u_int32_t reg[20];
	int32_t intr[8];
	char name[32];
	int need_interrupt_controller = 0;

	sc->sc_id = pa->pa_id; /* save of type for later */

	switch (PCI_PRODUCT(pa->pa_id)) {

	/* XXX should not use name */
	case PCI_PRODUCT_APPLE_GC:
		node = OF_finddevice("/bandit/gc");
		need_interrupt_controller = 1;
		break;

	case PCI_PRODUCT_APPLE_OHARE:
		node = OF_finddevice("/bandit/ohare");
		need_interrupt_controller = 1;
		break;

	case PCI_PRODUCT_APPLE_HEATHROW:
	case PCI_PRODUCT_APPLE_PADDINGTON:
		node = OF_finddevice("mac-io");
		if (node == -1)
			node = OF_finddevice("/pci/mac-io");
		if (OF_getprop(node, "assigned-addresses", reg, sizeof(reg))
			== (sizeof (reg[0]) * 5))
		{
			/* always ??? */
			heathrow_FCR = mapiodev(reg[2] + HEATHROW_FCR_OFFSET,
			    4);
		}
		break;
	case PCI_PRODUCT_APPLE_KEYLARGO:
	case PCI_PRODUCT_APPLE_INTREPID:
	case PCI_PRODUCT_APPLE_PANGEA_MACIO:
	case PCI_PRODUCT_APPLE_SHASTA:
	case PCI_PRODUCT_APPLE_K2_MACIO:
		node = OF_finddevice("mac-io");
		if (node == -1)
			node = OF_finddevice("/pci/mac-io");
		if (OF_getprop(node, "assigned-addresses", reg, sizeof(reg))
		    == (sizeof (reg[0]) * 5))
			 sc->obiomem = mapiodev(reg[2], 0x100);
		break;
	default:
		printf(": unknown macobio controller\n");
		return;
	}
	sc->sc_node = node;

	if (OF_getprop(node, "assigned-addresses", reg, sizeof(reg)) < 12)
		return;

	ca.ca_baseaddr = reg[2];

	sc->sc_membus_space.bus_base = ca.ca_baseaddr;

	ca.ca_iot = &sc->sc_membus_space;
	ca.ca_dmat = pa->pa_dmat;

	printf("\n");

	/*
	 * This might be a hack, but it makes the interrupt controller
	 * attach as expected if a device node existed in the OF tree.
	 */
	if (need_interrupt_controller) {
		/* force attachment of legacy interrupt controllers */
		ca.ca_name = "legacy-interrupt-controller";
		ca.ca_node = 0;

		ca.ca_nreg  = 0;
		ca.ca_nintr = 0;

		ca.ca_reg = NULL;
		ca.ca_intr = NULL;

		config_found(self, &ca, macobio_print);
	}

	for (child = OF_child(node); child; child = OF_peer(child)) {
		namelen = OF_getprop(child, "name", name, sizeof(name));
		if (namelen < 0)
			continue;
		if (namelen >= sizeof(name))
			continue;

		name[namelen] = 0;
		ca.ca_name = name;
		ca.ca_node = child;

		ca.ca_nreg  = OF_getprop(child, "reg", reg, sizeof(reg));
		ca.ca_nintr = OF_getprop(child, "AAPL,interrupts", intr,
				sizeof(intr));
		if (ca.ca_nintr == -1)
			ca.ca_nintr = OF_getprop(child, "interrupts", intr,
					sizeof(intr));

		ca.ca_reg = reg;
		ca.ca_intr = intr;

		config_found(self, &ca, macobio_print);
	}
}

int
macobio_print(void *aux, const char *macobio)
{
	struct confargs *ca = aux;

	if (macobio)
		printf("\"%s\" at %s", ca->ca_name, macobio);

	if (ca->ca_nreg > 0)
		printf(" offset 0x%x", ca->ca_reg[0]);

	return UNCONF;
}

void *
mac_intr_establish(void * lcv, int irq, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, const char *name)
{
	return (*intr_establish_func)(lcv, irq, type, level, ih_fun,
	    ih_arg, name);
}
void
mac_intr_disestablish(void *lcp, void *arg)
{
	(*intr_disestablish_func)(lcp, arg);
}

void
macobio_enable(int offset, u_int32_t bits)
{
	struct macobio_softc *sc = macobio_cd.cd_devs[0];
	if (sc->obiomem == 0)
		return;

	bits |=  in32rb(sc->obiomem + offset);
	out32rb(sc->obiomem + offset, bits);
}
void
macobio_disable(int offset, u_int32_t bits)
{
	struct macobio_softc *sc = macobio_cd.cd_devs[0];
	if (sc->obiomem == 0)
		return;

	bits =  in32rb(sc->obiomem + offset) & ~bits;
	out32rb(sc->obiomem + offset, bits);
}

uint8_t
macobio_read(int offset)
{
	struct macobio_softc *sc = macobio_cd.cd_devs[0];
	if (sc->obiomem == 0)
		return -1;

	return in8rb(sc->obiomem + offset);
}

void
macobio_write(int offset, uint8_t bits)
{
	struct macobio_softc *sc = macobio_cd.cd_devs[0];
	if (sc->obiomem == 0)
		return;

	out8rb(sc->obiomem + offset, bits);
}

void
macobio_modem_power(int enable)
{
	u_int32_t val;
	struct macobio_softc *sc = macobio_cd.cd_devs[0];
	if (PCI_PRODUCT(sc->sc_id) == PCI_PRODUCT_APPLE_KEYLARGO ||
	    PCI_PRODUCT(sc->sc_id) == PCI_PRODUCT_APPLE_INTREPID) {
		val = in32rb(sc->obiomem + 0x40);
		if (enable)
			val = val & ~((u_int32_t)1<<25);
		else 
			val = val | ((u_int32_t)1<<25);
		out32rb(sc->obiomem + 0x40, val);
	}
	if (PCI_PRODUCT(sc->sc_id) == PCI_PRODUCT_APPLE_PANGEA_MACIO) {
		if (enable) {
			/* set reset */
			out8(sc->obiomem + 0x006a + 0x03, 0x04);
			/* power modem on */
			out8(sc->obiomem + 0x006a + 0x02, 0x04);
			/* unset reset */
			out8(sc->obiomem + 0x006a + 0x03, 0x05);
		}  else {
			/* disable it how? */
		}
	}
}
@


1.21
log
@One function pointer per pic function is enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.20 2012/12/10 16:32:13 mpi Exp $	*/
a34 1
#include <sys/types.h>
@


1.20
log
@Correct macobio functions to only read and write one byte of data instead
of four. This fix a kernel panic on PowerMac G5 present since r1.22 of
i2s.c, issue reported by Chris Jackman, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.19 2011/05/15 09:10:26 mpi Exp $	*/
a54 4
void *undef_mac_establish(void * lcv, int irq, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, const char *name);
void mac_intr_disestab(void *lcp, void *arg);

a227 17
undef_mac_establish(void * lcv, int irq, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, const char *name)
{
	printf("mac_intr_establish called, not yet inited\n");
	return 0;
}

void
mac_intr_disestab(void *lcp, void *arg)
{
	printf("mac_intr_disestablish called, not yet inited\n");
}

intr_establish_t *mac_intr_establish_func = undef_mac_establish;
intr_disestablish_t *mac_intr_disestablish_func = mac_intr_disestab;

void *
d231 1
a231 1
	return (*mac_intr_establish_func)(lcv, irq, type, level, ih_fun,
d237 1
a237 1
	(*mac_intr_disestablish_func)(lcp, arg);
@


1.19
log
@Unify various gpio access using methods that take an offset relative to the
mac-io bus base address. Needed  by upcoming dfs(4) support.

On some Apple machines, the openfirmware returns a gpio offset relative to
the gpio controller (generaly at 0x50). These offsets should be corrected
to be relative to the bus base address.

looks fine to kettenis@@, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.18 2009/08/22 02:54:50 mk Exp $	*/
d282 1
a282 1
u_int32_t
d289 1
a289 1
	return in32rb(sc->obiomem + offset);
d293 1
a293 1
macobio_write(int offset, u_int32_t bits)
d299 1
a299 1
	out32rb(sc->obiomem + offset, bits);
@


1.18
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.17 2006/06/19 22:42:35 miod Exp $	*/
d48 1
a260 4
void keylargo_fcr_enable(int offset, u_int32_t bits);
void keylargo_fcr_disable(int offset, u_int32_t bits);
u_int32_t keylargo_fcr_read(int offset);

d262 1
a262 1
keylargo_fcr_enable(int offset, u_int32_t bits)
d272 1
a272 1
keylargo_fcr_disable(int offset, u_int32_t bits)
d283 1
a283 1
keylargo_fcr_read(int offset)
d290 10
@


1.17
log
@Be more strict in the probe routines and actually check ca_nintr and
ca_nreg are large enough for our greedy needs; tweaks and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.16 2006/02/14 23:05:28 kettenis Exp $	*/
d55 1
a55 1
    int (*ih_fun)(void *), void *ih_arg, char *name);
d232 1
a232 1
    int (*ih_fun)(void *), void *ih_arg, char *name)
d249 1
a249 1
    int (*ih_fun)(void *), void *ih_arg, char *name)
@


1.16
log
@Put quotation marks around the names of unconfigured devices.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.15 2005/11/17 00:24:55 deraadt Exp $	*/
d185 2
a186 2
		ca.ca_reg = 0;
		ca.ca_intr = 0;
@


1.15
log
@go loud with autoconfig messages again, we are gonna try to write drivers soon
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.14 2005/10/07 03:47:31 drahn Exp $	*/
d222 1
a222 1
		printf("%s at %s", ca->ca_name, macobio);
@


1.14
log
@Stop and restart the i2s clock when changing the snapper speed, otherwise
the new setting doesn't do anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.13 2005/10/02 22:09:40 brad Exp $	*/
a218 1
#ifdef MACOBIOVERBOSE
a227 3
#else
	return QUIET;
#endif
@


1.13
log
@a little bit more consistent naming scheme for Apple devices and add
missing K2 host bridge and AGP bridge PCI ids.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.12 2005/09/29 23:58:06 drahn Exp $	*/
d262 35
@


1.12
log
@G5 bridge.
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.11 2005/09/26 19:54:50 kettenis Exp $	*/
d90 1
a90 1
		case PCI_PRODUCT_APPLE_K2:
d147 1
a147 1
	case PCI_PRODUCT_APPLE_K2:
@


1.11
log
@Match Apple Shasta PCI ID as found on G5 systems.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.10 2005/06/08 19:08:23 drahn Exp $	*/
d90 1
d147 1
@


1.10
log
@Remove the bus_reverse field out of the powerpc bus structure, originally
it was there so that big endian and little endian devices could both be
present, however that is not the case on the macppc machines.
Cleans up code, shrinks the kernel. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.9 2003/10/15 23:00:56 drahn Exp $	*/
d89 1
d145 1
a151 1

@


1.9
log
@Further down the ANSI/KNF road, only binary difference is __LINE__.
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.8 2003/05/12 09:00:31 tdeval Exp $	*/
a163 2

	sc->sc_membus_space.bus_reverse = 1;
@


1.8
log
@Enable Intrepid's mac-io match.
Ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.7 2002/09/15 09:01:58 deraadt Exp $	*/
d52 2
d75 1
a75 4
macobio_match(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
d102 1
a102 3
macobio_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d138 1
a138 1
				4);
d148 1
a148 2
			== (sizeof (reg[0]) * 5))
		{
a149 1
		}
d216 1
a216 3
macobio_print(aux, macobio)
	void *aux;
	const char *macobio;
d234 2
a235 8
undef_mac_establish(lcv, irq, type, level, ih_fun, ih_arg, name)
	void * lcv;
	int irq;
	int type;
	int level;
	int (*ih_fun)(void *);
	void *ih_arg;
	char *name;
d242 1
a242 3
mac_intr_disestab(lcp, arg)
	void *lcp;
	void *arg;
d251 2
a252 8
mac_intr_establish(lcv, irq, type, level, ih_fun, ih_arg, name)
	void * lcv;
	int irq;
	int type;
	int level;
	int (*ih_fun)(void *);
	void *ih_arg;
	char *name;
d255 1
a255 1
		ih_arg, name);
d258 1
a258 3
mac_intr_disestablish(lcp, arg)
	void *lcp;
	void *arg;
a262 1
void macobio_modem_power(int enable);
@


1.7
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.5 2002/09/06 13:56:51 drahn Exp $	*/
d88 1
d145 1
d292 2
a293 1
	if (PCI_PRODUCT(sc->sc_id) == PCI_PRODUCT_APPLE_KEYLARGO) {
@


1.6
log
@KNF
@
text
@d135 3
a137 2
		if (OF_getprop(node, "assigned-addresses", reg,
		    sizeof(reg)) == (sizeof (reg[0]) * 5)) {
d140 1
a140 1
			    4);
d148 4
a151 3
		if (OF_getprop(node, "assigned-addresses", reg,
		    sizeof(reg)) == (sizeof (reg[0]) * 5)) {
			sc->obiomem = mapiodev(reg[2], 0x100);
d153 1
d206 1
a206 1
		    sizeof(intr));
d209 1
a209 1
			    sizeof(intr));
d274 1
a274 1
	    ih_arg, name);
d294 1
a294 1
		else
@


1.5
log
@Serial console support for macppc. Serial console will work if the modem
has been replaced with a serial port adapter on any machine that has
a real serial port internally. This will also power on the internal modem
for keylargo based machines (tested on original PBG4) when the serial port
is open. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.4 2002/03/14 03:15:56 millert Exp $	*/
d135 2
a136 3
		if (OF_getprop(node, "assigned-addresses", reg, sizeof(reg))
			== (sizeof (reg[0]) * 5))
		{
d139 1
a139 1
				4);
d147 3
a149 4
		if (OF_getprop(node, "assigned-addresses", reg, sizeof(reg))
			== (sizeof (reg[0]) * 5))
		{
			 sc->obiomem = mapiodev(reg[2], 0x100);
a150 1

d203 1
a203 1
				sizeof(intr));
d206 1
a206 1
					sizeof(intr));
d271 1
a271 1
		ih_arg, name);
d291 1
a291 1
		else 
@


1.4
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.3 2002/03/14 01:26:37 millert Exp $	*/
d60 2
d115 2
d148 5
d282 28
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.2 2001/09/15 01:42:55 mickey Exp $	*/
d52 2
a53 2
void *undef_mac_establish __P((void * lcv, int irq, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, char *name));
@


1.2
log
@pass the dma tag to obio; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.1 2001/09/01 15:55:17 drahn Exp $	*/
d49 3
a51 3
void macobio_attach __P((struct device *, struct device *, void *));
int macobio_match __P((struct device *, void *, void *));
int macobio_print __P((void *, const char *));
d53 2
a54 2
    int (*ih_fun) __P((void *)), void *ih_arg, char *name));
void mac_intr_disestab __P((void *lcp, void *arg));
d235 1
a235 1
	int (*ih_fun) __P((void *));
d260 1
a260 1
	int (*ih_fun) __P((void *));
@


1.2.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.2 2001/09/15 01:42:55 mickey Exp $	*/
d49 6
a54 6
void macobio_attach(struct device *, struct device *, void *);
int macobio_match(struct device *, void *, void *);
int macobio_print(void *, const char *);
void *undef_mac_establish(void * lcv, int irq, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, char *name);
void mac_intr_disestab(void *lcp, void *arg);
d235 1
a235 1
	int (*ih_fun)(void *);
d260 1
a260 1
	int (*ih_fun)(void *);
@


1.2.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.2.6.1 2002/06/11 03:36:34 art Exp $	*/
a59 2
	int	sc_id; /* copy of the PCI pa_id */
	u_int8_t *obiomem;
a112 2
	sc->sc_id = pa->pa_id; /* save of type for later */

a143 5
		if (OF_getprop(node, "assigned-addresses", reg, sizeof(reg))
			== (sizeof (reg[0]) * 5))
		{
			 sc->obiomem = mapiodev(reg[2], 0x100);
		}
a272 28
}

void macobio_modem_power(int enable);
void
macobio_modem_power(int enable)
{
	u_int32_t val;
	struct macobio_softc *sc = macobio_cd.cd_devs[0];
	if (PCI_PRODUCT(sc->sc_id) == PCI_PRODUCT_APPLE_KEYLARGO) {
		val = in32rb(sc->obiomem + 0x40);
		if (enable)
			val = val & ~((u_int32_t)1<<25);
		else 
			val = val | ((u_int32_t)1<<25);
		out32rb(sc->obiomem + 0x40, val);
	}
	if (PCI_PRODUCT(sc->sc_id) == PCI_PRODUCT_APPLE_PANGEA_MACIO) {
		if (enable) {
			/* set reset */
			out8(sc->obiomem + 0x006a + 0x03, 0x04);
			/* power modem on */
			out8(sc->obiomem + 0x006a + 0x02, 0x04);
			/* unset reset */
			out8(sc->obiomem + 0x006a + 0x03, 0x05);
		}  else {
			/* disable it how? */
		}
	}
@


1.2.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a87 1
		case PCI_PRODUCT_APPLE_INTREPID:
a143 1
	case PCI_PRODUCT_APPLE_INTREPID:
d290 1
a290 2
	if (PCI_PRODUCT(sc->sc_id) == PCI_PRODUCT_APPLE_KEYLARGO ||
	    PCI_PRODUCT(sc->sc_id) == PCI_PRODUCT_APPLE_INTREPID) {
@


1.2.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2.4.2
log
@Merge in -current from about a week ago
@
text
@d49 6
a54 6
void macobio_attach(struct device *, struct device *, void *);
int macobio_match(struct device *, void *, void *);
int macobio_print(void *, const char *);
void *undef_mac_establish(void * lcv, int irq, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, char *name);
void mac_intr_disestab(void *lcp, void *arg);
d235 1
a235 1
	int (*ih_fun)(void *);
d260 1
a260 1
	int (*ih_fun)(void *);
@


1.2.4.3
log
@Sync the SMP branch with 3.3
@
text
@a59 2
	int	sc_id; /* copy of the PCI pa_id */
	u_int8_t *obiomem;
a112 2
	sc->sc_id = pa->pa_id; /* save of type for later */

a143 5
		if (OF_getprop(node, "assigned-addresses", reg, sizeof(reg))
			== (sizeof (reg[0]) * 5))
		{
			 sc->obiomem = mapiodev(reg[2], 0x100);
		}
a272 28
}

void macobio_modem_power(int enable);
void
macobio_modem_power(int enable)
{
	u_int32_t val;
	struct macobio_softc *sc = macobio_cd.cd_devs[0];
	if (PCI_PRODUCT(sc->sc_id) == PCI_PRODUCT_APPLE_KEYLARGO) {
		val = in32rb(sc->obiomem + 0x40);
		if (enable)
			val = val & ~((u_int32_t)1<<25);
		else 
			val = val | ((u_int32_t)1<<25);
		out32rb(sc->obiomem + 0x40, val);
	}
	if (PCI_PRODUCT(sc->sc_id) == PCI_PRODUCT_APPLE_PANGEA_MACIO) {
		if (enable) {
			/* set reset */
			out8(sc->obiomem + 0x006a + 0x03, 0x04);
			/* power modem on */
			out8(sc->obiomem + 0x006a + 0x02, 0x04);
			/* unset reset */
			out8(sc->obiomem + 0x006a + 0x03, 0x05);
		}  else {
			/* disable it how? */
		}
	}
@


1.2.4.4
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.2.4.3 2003/03/27 23:29:46 niklas Exp $	*/
a87 1
		case PCI_PRODUCT_APPLE_INTREPID:
a143 1
	case PCI_PRODUCT_APPLE_INTREPID:
d290 1
a290 2
	if (PCI_PRODUCT(sc->sc_id) == PCI_PRODUCT_APPLE_KEYLARGO ||
	    PCI_PRODUCT(sc->sc_id) == PCI_PRODUCT_APPLE_INTREPID) {
@


1.2.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a51 2
void macobio_modem_power(int enable);

d73 4
a76 1
macobio_match(struct device *parent, void *cf, void *aux)
d103 3
a105 1
macobio_attach(struct device *parent, struct device *self, void *aux)
d141 1
a141 1
			    4);
d151 2
a152 1
		    == (sizeof (reg[0]) * 5))
d154 1
d221 3
a223 1
macobio_print(void *aux, const char *macobio)
d241 8
a248 2
undef_mac_establish(void * lcv, int irq, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, char *name)
d255 3
a257 1
mac_intr_disestab(void *lcp, void *arg)
d266 8
a273 2
mac_intr_establish(void * lcv, int irq, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, char *name)
d276 1
a276 1
	    ih_arg, name);
d279 3
a281 1
mac_intr_disestablish(void *lcp, void *arg)
d286 1
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/pci to macppc/pci

The file pci_machdep.h was not moved in this conversion.
It needs to be check if it is correct that should be the only shared
powerpc/pci file. Or if that file too should be MD, or more files MI.
@
text
@d1 1
a1 1
/*	$OpenBSD: macobio.c,v 1.16 2001/07/09 02:56:09 mickey Exp $	*/
d162 1
@

