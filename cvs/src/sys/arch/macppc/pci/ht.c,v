head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.8
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.4
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.4
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.11.0.8
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.6
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8;
locks; strict;
comment	@ * @;


1.18
date	2015.08.30.09.48.39;	author mpi;	state Exp;
branches;
next	1.17;
commitid	vgGoIFs2WSitHUsP;

1.17
date	2015.06.25.18.08.53;	author miod;	state Exp;
branches;
next	1.16;
commitid	08W6lNRk4BFgobM0;

1.16
date	2013.08.07.07.29.19;	author mpi;	state Exp;
branches;
next	1.15;

1.15
date	2013.01.21.15.06.29;	author mpi;	state Exp;
branches;
next	1.14;

1.14
date	2010.12.04.17.06.31;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.29.22.58.31;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.08.03.22.11;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.14.17.36.12;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.13.20.10.49;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.14.20.06.57;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.13.21.48.16;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.16.20.22.49;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.30.21.37.21;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.30.01.29.13;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.30.00.30.14;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.29.21.44.33;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.29.20.52.26;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Map the whole config1 space based on the size read from the
device-tree.

With this change, supplementary PCIe cards are now properly
detected.

This should prevents the kernel from faulting when reading
unmapped PCI addresses as reported by Donovan Watteau on ppc@@.

ok kettenis@@
@
text
@/*	$OpenBSD: ht.c,v 1.17 2015/06/25 18:08:53 miod Exp $	*/

/*
 * Copyright (c) 2005 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/autoconf.h>
#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/ofw/openfirm.h>

int	 ht_match(struct device *, void *, void *);
void	 ht_attach(struct device *, struct device *, void *);

pcireg_t ht_conf_read(void *, pcitag_t, int);
void	 ht_conf_write(void *, pcitag_t, int, pcireg_t);

int	 ht_print(void *, const char *);

struct ht_softc {
	struct device	sc_dev;
	int		sc_maxdevs;
	struct ppc_bus_space sc_mem_bus_space;
	struct ppc_bus_space sc_io_bus_space;
	struct ppc_pci_chipset sc_pc;
	bus_space_tag_t sc_memt;
	bus_space_handle_t sc_config0_memh;
	bus_space_handle_t sc_config1_memh;
	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_config0_ioh;
};

struct cfattach ht_ca = {
	sizeof(struct ht_softc), ht_match, ht_attach
};

struct cfdriver ht_cd = {
	NULL, "ht", DV_DULL,
};

int
ht_match(struct device *parent, void *cf, void *aux)
{
	struct confargs *ca = aux;

	if (strcmp(ca->ca_name, "ht") == 0)
		return (1);
	return (0);
}

void
ht_attach(struct device *parent, struct device *self, void *aux)
{
	struct ht_softc *sc = (struct ht_softc *)self;
	struct confargs *ca = aux;
	struct pcibus_attach_args pba;
	u_int32_t regs[6];
	char compat[32];
	int node, len;

	if (ca->ca_node == 0) {
		printf(": invalid node on ht config\n");
		return;
	}

	len = OF_getprop(ca->ca_node, "reg", regs, sizeof(regs));
	if (len < 0 || len < sizeof(regs)) {
		printf(": regs lookup failed, node %x\n", ca->ca_node);
		return;
	}

	sc->sc_mem_bus_space.bus_base = 0x80000000;
	sc->sc_mem_bus_space.bus_size = 0;
	sc->sc_mem_bus_space.bus_io = 0;
	sc->sc_memt = &sc->sc_mem_bus_space;

	sc->sc_io_bus_space.bus_base = 0x80000000;
	sc->sc_io_bus_space.bus_size = 0;
	sc->sc_io_bus_space.bus_io = 1;
	sc->sc_iot = &sc->sc_io_bus_space;

	sc->sc_maxdevs = 1;
	for (node = OF_child(ca->ca_node); node; node = OF_peer(node))
		sc->sc_maxdevs++;

	if (bus_space_map(sc->sc_memt, regs[1],
	    (1 << 11)*sc->sc_maxdevs, 0, &sc->sc_config0_memh)) {
		printf(": can't map PCI config0 memory\n");
		return;
	}

	if (bus_space_map(sc->sc_memt, regs[1] + 0x01000000,
	    regs[2] - 0x01000000, 0, &sc->sc_config1_memh)) {
		printf(": can't map PCI config1 memory\n");
		return;
	}

	if (bus_space_map(sc->sc_iot, regs[4], 0x1000, 0,
	    &sc->sc_config0_ioh)) {
		printf(": can't map PCI config0 io\n");
		return;
	}

	len = OF_getprop(ca->ca_node, "compatible", compat, sizeof(compat));
	if (len <= 0)
		printf(": unknown");
	else
		printf(": %s", compat);

	sc->sc_pc.pc_conf_v = sc;
	sc->sc_pc.pc_node = ca->ca_node;
	sc->sc_pc.pc_conf_read = ht_conf_read;
	sc->sc_pc.pc_conf_write = ht_conf_write;

	bzero(&pba, sizeof(pba));
	pba.pba_busname = "pci";
	pba.pba_iot = sc->sc_iot;
	pba.pba_memt = sc->sc_memt;
	pba.pba_dmat = &pci_bus_dma_tag;
	pba.pba_pc = &sc->sc_pc;
	pba.pba_domain = pci_ndomains++;
	pba.pba_bus = 0;

	printf(", %d devices\n", sc->sc_maxdevs);

	config_found(self, &pba, ht_print);
}

pcireg_t
ht_conf_read(void *cpv, pcitag_t tag, int offset)
{
	struct ht_softc *sc = cpv;
	int bus, dev, fcn;
	pcireg_t reg;
	uint32_t val;

	val = PCITAG_OFFSET(tag);
#ifdef DEBUG
	printf("ht_conf_read: tag=%x, offset=%x\n", val, offset);
#endif
	pci_decompose_tag(NULL, tag, &bus, &dev, &fcn);
	if (bus == 0 && dev == 0) {
		val |= (offset << 2);
		reg = bus_space_read_4(sc->sc_iot, sc->sc_config0_ioh, val);
		reg = letoh32(reg);
	} else if (bus == 0) {
		/* XXX Why can we only access function 0? */
		if (fcn > 0)
			return ~0;
		val |= offset;
		reg = bus_space_read_4(sc->sc_memt, sc->sc_config0_memh, val);
	} else {
		val |= offset;
		reg = bus_space_read_4(sc->sc_memt, sc->sc_config1_memh, val);
	}
#ifdef DEBUG
	printf("ht_conf_read: reg=%x\n", reg);
#endif
	return reg;
}

void
ht_conf_write(void *cpv, pcitag_t tag, int offset, pcireg_t data)
{
	struct ht_softc *sc = cpv;
	int bus, dev, fcn;
	uint32_t val;

	val = PCITAG_OFFSET(tag);
#ifdef DEBUG
	printf("ht_conf_write: tag=%x, offset=%x, data = %x\n",
	       val, offset, data);
#endif
	pci_decompose_tag(NULL, tag, &bus, &dev, &fcn);
	if (bus == 0 && dev == 0) {
		val |= (offset << 2);
		data = htole32(data);
		bus_space_write_4(sc->sc_iot, sc->sc_config0_ioh, val, data);
		bus_space_read_4(sc->sc_iot, sc->sc_config0_ioh, val);
	} else if (bus == 0) {
		/* XXX Why can we only access function 0? */
		if (fcn > 0)
			return;
		val |= offset;
		bus_space_write_4(sc->sc_memt, sc->sc_config0_memh, val, data);
		bus_space_read_4(sc->sc_memt, sc->sc_config0_memh, val);
	} else {
		val |= offset;
		bus_space_write_4(sc->sc_memt, sc->sc_config1_memh, val, data);
		bus_space_read_4(sc->sc_memt, sc->sc_config1_memh, val);
	}
}

int
ht_print(void *aux, const char *pnp)
{
	struct pcibus_attach_args *pba = aux;

	if (pnp)
		printf("%s at %s", pba->pba_busname, pnp);
	printf(" bus %d", pba->pba_bus);
	return (UNCONF);
}
@


1.17
log
@OF_getprop() returns an int, so comparing its return value against sizeof casts
it to unsigned, and we need to also check for negative values.
All users of OF_getprop() did this but that one.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ht.c,v 1.16 2013/08/07 07:29:19 mpi Exp $	*/
d112 2
a113 2
	if (bus_space_map(sc->sc_memt, regs[1] + 0x01000000, 0x80000, 0,
	    &sc->sc_config1_memh)) {
@


1.16
log
@Mimic what's done on sparc64 and parse the OpenFirmware device tree to
enumerate the pci devices.  This allow us to not store the interrupt
vector in the interrupt line register and to not try to attach pci
devices disabled by firmware.

With inputs from and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ht.c,v 1.15 2013/01/21 15:06:29 mpi Exp $	*/
d87 1
a87 1
	if (len < sizeof(regs)) {
@


1.15
log
@Only the mpcpcibus driver is actually using these structures so merge them
in the appropriate .c file and remove unused fields while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ht.c,v 1.14 2010/12/04 17:06:31 miod Exp $	*/
a34 6
void	 ht_attach_hook(struct device *, struct device *,
	     struct pcibus_attach_args *);
int	 ht_bus_maxdevs(void *, int);
pcitag_t ht_make_tag(void *, int, int, int);
void	 ht_decompose_tag(void *, pcitag_t, int *, int *, int *);
int	 ht_conf_size(void *, pcitag_t);
a36 8
int	 ht_intr_map(void *, pcitag_t, int, int, pci_intr_handle_t *);
const char *ht_intr_string(void *, pci_intr_handle_t);
int	 ht_intr_line(void *, pci_intr_handle_t);
void	*ht_intr_establish(void *, pci_intr_handle_t, int, int (*)(void *),
	     void *, const char *);
void	 ht_intr_disestablish(void *, void *);

int	 ht_ether_hw_addr(struct ppc_pci_chipset *, u_int8_t *);
a39 4
#define BUS_SHIFT 16
#define DEVICE_SHIFT 11
#define FNC_SHIFT 8

a60 21
#if 0
struct powerpc_bus_dma_tag pci_bus_dma_tag = {
	NULL,
	_dmamap_create,
	_dmamap_destroy,
	_dmamap_load,
	_dmamap_load_mbuf,
	_dmamap_load_uio,
	_dmamap_load_raw,
	_dmamap_unload,
	_dmamap_sync,
	_dmamem_alloc,
	_dmamem_free,
	_dmamem_map,
	_dmamem_unmap,
	_dmamem_mmap
};
#else
extern struct powerpc_bus_dma_tag pci_bus_dma_tag;
#endif

d79 1
a79 2
	int node, nn;
	int len;
d107 1
a107 1
	    (1 << DEVICE_SHIFT)*sc->sc_maxdevs, 0, &sc->sc_config0_memh)) {
d131 1
a131 5
	sc->sc_pc.pc_attach_hook = ht_attach_hook;
	sc->sc_pc.pc_bus_maxdevs = ht_bus_maxdevs;
	sc->sc_pc.pc_make_tag = ht_make_tag;
	sc->sc_pc.pc_decompose_tag = ht_decompose_tag;
	sc->sc_pc.pc_conf_size = ht_conf_size;
a134 8
	sc->sc_pc.pc_intr_v = sc;
	sc->sc_pc.pc_intr_map = ht_intr_map;
	sc->sc_pc.pc_intr_string = ht_intr_string;
	sc->sc_pc.pc_intr_line = ht_intr_line;
	sc->sc_pc.pc_intr_establish = ht_intr_establish;
	sc->sc_pc.pc_intr_disestablish = ht_intr_disestablish;
	sc->sc_pc.pc_ether_hw_addr = ht_ether_hw_addr;

a145 17
	extern void fix_node_irq(int, struct pcibus_attach_args *);

	for (node = OF_child(ca->ca_node); node; node = nn) {
		fix_node_irq(node, &pba);

		if ((nn = OF_child(node)) != 0)
			continue;

		while ((nn = OF_peer(node)) == 0) {
			node = OF_parent(node);
			if (node == ca->ca_node) {
				nn = 0;
				break;
			}
		}
	}

a148 40
void
ht_attach_hook(struct device *parent, struct device *self,
    struct pcibus_attach_args *pba)
{
}

int
ht_bus_maxdevs(void *cpv, int bus)
{
	struct ht_softc *sc = cpv;

	/* XXX Probing more busses doesn't work. */
	if (bus == 0)
		return sc->sc_maxdevs;
	return 32;
}

pcitag_t
ht_make_tag(void *cpv, int bus, int dev, int fnc)
{
	return (bus << BUS_SHIFT) | (dev << DEVICE_SHIFT) | (fnc << FNC_SHIFT);
}

void
ht_decompose_tag(void *cpv, pcitag_t tag, int *busp, int *devp, int *fncp)
{
	if (busp != NULL)
		*busp = (tag >> BUS_SHIFT) & 0xff;
	if (devp != NULL)
		*devp = (tag >> DEVICE_SHIFT) & 0x1f;
	if (fncp != NULL)
		*fncp = (tag >> FNC_SHIFT) & 0x7;
}

int
ht_conf_size(void *cpv, pcitag_t tag)
{
	return PCI_CONFIG_SPACE_SIZE;
}

d155 1
d157 1
d159 1
a159 1
	printf("ht_conf_read: tag=%x, offset=%x\n", tag, offset);
d161 1
a161 1
	ht_decompose_tag(NULL, tag, &bus, &dev, &fcn);
d163 2
a164 2
		tag |= (offset << 2);
		reg = bus_space_read_4(sc->sc_iot, sc->sc_config0_ioh, tag);
d170 2
a171 2
		tag |= offset;
		reg = bus_space_read_4(sc->sc_memt, sc->sc_config0_memh, tag);
d173 2
a174 2
		tag |= offset;
		reg = bus_space_read_4(sc->sc_memt, sc->sc_config1_memh, tag);
d187 1
d189 1
d192 1
a192 1
	       tag, offset, data);
d194 1
a194 1
	ht_decompose_tag(NULL, tag, &bus, &dev, &fcn);
d196 1
a196 1
		tag |= (offset << 2);
d198 2
a199 2
		bus_space_write_4(sc->sc_iot, sc->sc_config0_ioh, tag, data);
		bus_space_read_4(sc->sc_iot, sc->sc_config0_ioh, tag);
d204 3
a206 3
		tag |= offset;
		bus_space_write_4(sc->sc_memt, sc->sc_config0_memh, tag, data);
		bus_space_read_4(sc->sc_memt, sc->sc_config0_memh, tag);
d208 3
a210 3
		tag |= offset;
		bus_space_write_4(sc->sc_memt, sc->sc_config1_memh, tag, data);
		bus_space_read_4(sc->sc_memt, sc->sc_config1_memh, tag);
a211 73
}

/* XXX */
#define PCI_INTERRUPT_NO_CONNECTION	0xff

int
ht_intr_map(void *cpv, pcitag_t tag, int pin, int line,
    pci_intr_handle_t *ihp)
{
	int error = 0;

#ifdef DEBUG
	printf("ht_intr_map: tag=%x, pin=%d, line=%d\n", tag, pin, line);
#endif

	*ihp = -1;
        if (line == PCI_INTERRUPT_NO_CONNECTION)
                error = 1; /* No IRQ used. */
        else if (pin > PCI_INTERRUPT_PIN_MAX) {
                printf("ht_intr_map: bad interrupt pin %d\n", pin);
                error = 1;
        }

	if (!error)
		*ihp = line;
	return error;
}

const char *
ht_intr_string(void *cpv, pci_intr_handle_t ih)
{
	static char str[16];

	snprintf(str, sizeof str, "irq %ld", ih);
	return (str);
}

int
ht_intr_line(void *cpv, pci_intr_handle_t ih)
{
	return (ih);
}

void *
ht_intr_establish(void *cpv, pci_intr_handle_t ih, int level,
    int (*func)(void *), void *arg, const char *name)
{
	return (*intr_establish_func)(cpv, ih, IST_LEVEL, level, func, arg,
		name);
}

void
ht_intr_disestablish(void *lcv, void *cookie)
{
}

int
ht_ether_hw_addr(struct ppc_pci_chipset *lcpc, u_int8_t *oaddr)
{
	u_int8_t laddr[6];
	int node;
	int len;

	node = OF_finddevice("enet");
	len = OF_getprop(node, "local-mac-address", laddr, sizeof(laddr));
	if (sizeof(laddr) == len) {
		memcpy(oaddr, laddr, sizeof(laddr));
		return 1;
	}

	oaddr[0] = oaddr[1] = oaddr[2] = 0xff;
	oaddr[3] = oaddr[4] = oaddr[5] = 0xff;
	return 0;
@


1.14
log
@Introduce a new pci routine, pci_conf_size(), which returns the size of a
given pcitag_t configuration address space. Currently, all pci controllers
will return the usual 0x100 bytes of PCI configuration space, but this will
eventually change on PCIe-capable controlers.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ht.c,v 1.13 2009/08/22 02:54:50 mk Exp $	*/
a28 2

#include <macppc/pci/pcibrvar.h>
@


1.13
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: ht.c,v 1.12 2009/03/29 22:58:31 kettenis Exp $	*/
d42 1
d177 1
d252 6
@


1.12
log
@bzero pci attach args
@
text
@d1 1
a1 1
/*	$OpenBSD: ht.c,v 1.11 2007/05/08 03:22:11 deraadt Exp $	*/
d48 1
a48 1
	     void *, char *);
d356 1
a356 1
    int (*func)(void *), void *arg, char *name)
@


1.11
log
@correct dmesg output
@
text
@d1 1
a1 1
/*	$OpenBSD: ht.c,v 1.10 2006/12/14 17:36:12 kettenis Exp $	*/
d187 1
a194 1
	pba.pba_bridgetag = NULL;
@


1.10
log
@Make pci subsystem aware of domains.  Each host bridge gets assigned a unique
domain number such that we can distinguish between busses with the same bus
number that are behind different host bridges.  Domains can be accessed by
using different device nodes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ht.c,v 1.9 2006/03/13 20:10:49 brad Exp $	*/
d123 1
a123 1
		printf("invalid node on ht config\n");
d196 1
a196 1
	printf(": %d devices\n", sc->sc_maxdevs);
@


1.9
log
@* Add "pcitag_t *pba_bridgetag" to pci_attach_args.  This is set to
  NULL for root PCI busses.  For busses behind a bridge, it points to
  a persistent copy of the bridge's pcitag_t.  This can be very useful
  for machine-dependent PCI bus enumeration code.

From NetBSD

ok grange@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ht.c,v 1.8 2005/12/14 20:06:57 kettenis Exp $	*/
d192 1
@


1.8
log
@Prevent access to PCI config space for function >0 on bus 0.
Fixes Xorg PCI scan.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ht.c,v 1.7 2005/11/13 21:48:16 drahn Exp $	*/
d193 1
@


1.7
log
@Map the config space area based on sc_maxdevs. (removes panic)
@
text
@d1 1
a1 1
/*	$OpenBSD: ht.c,v 1.6 2005/10/16 20:22:49 kettenis Exp $	*/
d266 2
a267 2
		/* XXX Needed on some PowerMac G5's.  Why? */
		if (fcn > 1)
d285 1
a285 1
	int bus, dev;
d291 1
a291 1
	ht_decompose_tag(NULL, tag, &bus, &dev, NULL);
d298 3
@


1.6
log
@Allow PCI_INTERRUPT_PIN_NONE for the interrupt pin.
HyperTransport delivers interrupts via messages and does not define any
interrupt pins.  (The documentation even warns that some operating systems
will not function correctly without a non-zero value in its Interrupt Pin
configuration space register.)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ht.c,v 1.5 2005/09/30 21:37:21 kettenis Exp $	*/
d55 4
d143 6
a148 2
	if (bus_space_map(sc->sc_memt, regs[1], 0x4000, 0,
		&sc->sc_config0_memh)) {
d154 1
a154 1
		&sc->sc_config1_memh)) {
d160 1
a160 1
		&sc->sc_config0_ioh)) {
a193 3
	sc->sc_maxdevs = 1;
	for (node = OF_child(ca->ca_node); node; node = OF_peer(node))
		sc->sc_maxdevs++;
a232 4
#define BUS_SHIFT 16
#define DEVICE_SHIFT 11
#define FNC_SHIFT 8

a265 2
		if (tag >= 0x4000)
			panic("tag >= 0x4000");
@


1.5
log
@Determine the number of attached devices from OF.
Map enough memory for up to 8 devices.
Handle unconnected interrupt lines.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ht.c,v 1.4 2005/09/30 01:29:13 deraadt Exp $	*/
d323 1
a323 2
        if (pin == PCI_INTERRUPT_PIN_NONE ||
	    line == PCI_INTERRUPT_NO_CONNECTION)
@


1.4
log
@pretty print
@
text
@d1 1
a1 1
/*	$OpenBSD: ht.c,v 1.3 2005/09/30 00:30:14 drahn Exp $	*/
d57 1
d139 1
a139 1
	if (bus_space_map(sc->sc_memt, regs[1], 0x2000, 0,
d159 1
a159 1
		printf(": unknown\n");
d161 1
a161 1
		printf(": %s\n", compat);
d186 5
d218 1
a218 1
ht_bus_maxdevs(void *cpv, int busno)
d220 2
d223 2
a224 2
	if (busno == 0)
		return 4;
d265 2
a266 2
		if (tag >= 0x2000)
			panic("tag >= 0x2000");
d309 3
d323 2
a324 1
        if (pin == PCI_INTERRUPT_PIN_NONE)
@


1.3
log
@Allow fcn 1 to attach (mac-io on G5 tower)
@
text
@d1 1
a1 1
/*	$OpenBSD: ht.c,v 1.2 2005/09/29 21:44:33 kettenis Exp $	*/
d158 1
a158 1
		printf(": unknown");
d160 1
a160 1
		printf(": %s", compat);
@


1.2
log
@Clean up ht_intr_map() a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ht.c,v 1.1 2005/09/29 20:52:26 kettenis Exp $	*/
d260 1
a260 1
		if (fcn > 0)
@


1.1
log
@Add driver for HyperTransport as found in G5 Macs.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d302 1
a302 1
ht_intr_map(void *cpv, pcitag_t bustag, int buspin, int line,
d308 1
a308 1
	printf("ht_intr_map: buspin = %d, line = %d\n", buspin, line);
d312 1
a312 1
        if (buspin == 0)
d314 2
a315 2
        else if (buspin > 4) {
                printf("ht_intr_map: bad interrupt pin %d\n", buspin);
@

