head	1.36;
access;
symbols
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.25.0.2
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.2
	OPENBSD_5_0:1.21.0.6
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.4
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.19.0.6
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.11
	UBC:1.2.0.2
	UBC_BASE:1.2
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.36
date	2013.08.27.21.00.53;	author mpi;	state dead;
branches;
next	1.35;

1.35
date	2013.08.17.10.59.38;	author mpi;	state Exp;
branches;
next	1.34;

1.34
date	2013.08.17.09.11.22;	author mpi;	state Exp;
branches;
next	1.33;

1.33
date	2013.08.12.08.38.03;	author mpi;	state Exp;
branches;
next	1.32;

1.32
date	2013.08.12.08.03.56;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2013.06.04.02.26.36;	author mpi;	state Exp;
branches;
next	1.30;

1.30
date	2013.06.04.02.16.14;	author mpi;	state Exp;
branches;
next	1.29;

1.29
date	2013.06.04.02.09.00;	author mpi;	state Exp;
branches;
next	1.28;

1.28
date	2013.06.03.23.28.43;	author mpi;	state Exp;
branches;
next	1.27;

1.27
date	2012.12.13.13.55.18;	author mpi;	state Exp;
branches;
next	1.26;

1.26
date	2012.08.30.21.54.13;	author mpi;	state Exp;
branches;
next	1.25;

1.25
date	2012.06.21.10.08.16;	author mpi;	state Exp;
branches;
next	1.24;

1.24
date	2012.01.29.14.44.16;	author mpi;	state Exp;
branches;
next	1.23;

1.23
date	2012.01.29.14.20.42;	author mpi;	state Exp;
branches;
next	1.22;

1.22
date	2011.09.29.20.57.43;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.05.22.21.30.26;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2009.03.01.10.48.54;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.05.19.24.31;	author martin;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.17.22.18.14;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.15.20.46.15;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.02.05.21.32;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.15.21.10.37;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.12.20.08.31;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.15.23.00.57;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.16.21.59.15;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.17.02.59.34;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.15.09.01.59;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.22.21.00.03;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.29.01.34.58;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.27.20.54.42;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.27.15.26.11;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.26.16.51.43;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.31.12.26.18;	author art;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.09.01.15.55.18;	author drahn;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.10.31.03.01.16;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.2.2.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Since we are no longer attaching radeondrm(4) to this driver there is
no reason to pretend being compatible with the MI vga layer.  So stop
using the vga_pci_bar interface and reduce the differences with the
sparc64 driver.
@
text
@/*	$OpenBSD: vgafb_pci.c,v 1.35 2013/08/17 10:59:38 mpi Exp $	*/
/*	$NetBSD: vga_pci.c,v 1.4 1996/12/05 01:39:38 cgd Exp $	*/

/*
 * Copyright (c) 1995, 1996 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

#include <arch/macppc/pci/vgafbvar.h>
#include <dev/pci/vga_pcivar.h>

#ifdef DEBUG_VGAFB
#define DPRINTF(x...)	do { printf(x); } while (0);
#else
#define DPRINTF(x...)
#endif

int	vgafb_pci_match(struct device *, void *, void *);
void	vgafb_pci_attach(struct device *, struct device *, void *);

void	vgafb_pci_mem_init(struct vga_pci_softc *, uint32_t *, uint32_t *,
	    uint32_t *, uint32_t *);

const struct cfattach vgafb_pci_ca = {
	sizeof(struct vga_pci_softc), vgafb_pci_match, vgafb_pci_attach,
};

struct vga_config vgafbcn;

void
vgafb_pci_mem_init(struct vga_pci_softc *dev, uint32_t *memaddr,
    uint32_t *memsize, uint32_t *mmioaddr, uint32_t *mmiosize)
{
	struct vga_pci_bar *bar;
	int i;

	*memsize  = 0x0;
	*mmiosize = 0x0;

	for (i = 0; i < VGA_PCI_MAX_BARS; i++) {
		bar = dev->bars[i];
		if (bar == NULL)
			continue;

		DPRINTF("\nvgafb: 0x%04x: BAR ", bar->addr);

		switch (PCI_MAPREG_TYPE(bar->maptype)) {
		case PCI_MAPREG_TYPE_IO:
			DPRINTF("io ");
			break;
		case PCI_MAPREG_TYPE_MEM:
			if (bar->base == 0 || bar->maxsize == 0) {
				/* ignore this entry */
			} else if (*memsize == 0) {
				/*
				 * first memory slot found goes into memory,
				 * this is for the case of no mmio
				 */
				*memaddr = bar->base;
				*memsize = bar->maxsize;
			} else {
				/*
				 * Oh, we have a second 'memory'
				 * region, is this region the vga memory
				 * or mmio, we guess that memory is
				 * the larger of the two.
				 */
				 if (*memsize >= bar->maxsize) {
					/* this is the mmio */
					*mmioaddr = bar->base;
					*mmiosize = bar->maxsize;
				 } else {
					/* this is the memory */
					*mmioaddr = *memaddr;
					*mmiosize = *memsize;
					*memaddr = bar->base;
					*memsize = bar->maxsize;
				 }
			}
			DPRINTF("mem ");
			break;
		}

		if (bar->maptype == PCI_MAPREG_MEM_TYPE_64BIT) {
			DPRINTF("64bit");
			i++;
		} else {
			DPRINTF("addr: 0x%08x/0x%08x", bar->base, bar->maxsize);
		}
	}

	/* ATI driver maps 0x80000 mmio, grr */
	if (*mmiosize > 0 && *mmiosize < 0x80000) {
		*mmiosize = 0x80000;
	}

	DPRINTF("\nvgafb: memaddr %x, memsize %x, mmioaddr %x, mmiosize %x",
	    *memaddr, *memsize, *mmioaddr, *mmiosize);
}

int
vgafb_pci_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;
	int node;

	if (DEVICE_IS_VGA_PCI(pa->pa_class) == 0) {
		/*
		 * XXX Graphic cards found in iMac G3 have a ``Misc''
		 * subclass, match them all.
		 */
		if (PCI_CLASS(pa->pa_class) != PCI_CLASS_DISPLAY ||
		    PCI_SUBCLASS(pa->pa_class) != PCI_SUBCLASS_DISPLAY_MISC)
			return (0);
	}

	/*
	 * XXX Non-console devices do not get configured by the PROM,
	 * XXX so do not attach them yet.
	 */
	node = PCITAG_NODE(pa->pa_tag);
	if (!vgafb_is_console(node))
		return (0);

	return (1);
}

void
vgafb_pci_attach(struct device *parent, struct device  *self, void *aux)
{
	struct pci_attach_args *pa = aux;
	struct vga_pci_softc *sc = (struct vga_pci_softc *)self;
	struct vga_config *vc;
	u_int32_t memaddr, memsize;
	u_int32_t mmioaddr, mmiosize;

 	vga_pci_bar_init(sc, pa);
	vgafb_pci_mem_init(sc, &memaddr, &memsize, &mmioaddr, &mmiosize);

	vc = sc->sc_vc = &vgafbcn;

	/*
	 * The previous size was not necessarily the real size
	 * but what is needed for the glass console.
	 */
	vc->membase = memaddr;
	vc->memsize = memsize;

	if (mmiosize != 0) {
		vc->mmiobase = mmioaddr;
		vc->mmiosize = mmiosize;

		printf (", mmio");
	}
	printf("\n");

	vgafb_wsdisplay_attach(self, vc);
}
@


1.35
log
@Because vgafb(4) only match the console, no need for an additional check
when setting up multiple screens and don't clear the screen again at this
moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.34 2013/08/17 09:11:22 mpi Exp $	*/
@


1.34
log
@Do not pretend to support non-console device because vgafb(4) only
matches the framebuffer device setup by the firmware.  Discussed
with kettenis@@.

While here remove the bus master enable command as we no longer
attach drm(4) to this driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.33 2013/08/12 08:38:03 mpi Exp $	*/
d192 1
a192 1
	vgafb_wsdisplay_attach(self, vc, 1);
@


1.33
log
@radeondrm now attaches directly to pci.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.32 2013/08/12 08:03:56 mpi Exp $	*/
a170 5
	int console, node;
	pcireg_t reg;


	node = PCITAG_NODE(pa->pa_tag);
d175 1
d177 6
a182 17
	console = vgafb_is_console(node);
	if (console) {
		vc = sc->sc_vc = &vgafbcn;

		/*
		 * The previous size was not necessarily the real size
		 * but what is needed for the glass console.
		 */
		vc->membase = memaddr;
		vc->memsize = memsize;
	} else {
		vc = sc->sc_vc = (struct vga_config *)
		    malloc(sizeof(struct vga_config), M_DEVBUF, M_WAITOK);

		/* set up bus-independent VGA configuration */
		vgafb_init(pa->pa_iot, pa->pa_memt, vc, memaddr, memsize);
	}
d192 1
a192 8
	/*
	 * Enable bus master; X might need this for accelerated graphics.
	 */
	reg = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	reg |= PCI_COMMAND_MASTER_ENABLE;
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, reg);

	vgafb_wsdisplay_attach(self, vc, console);
@


1.32
log
@Match the framebuffer device against its OpenFirmware node in order
to share the console detection logic with sparc64 in radeondrm(4).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.31 2013/06/04 02:26:36 mpi Exp $	*/
a43 2
#include "drm.h"

a214 4

#if NDRM > 0
	config_found_sm(self, aux, NULL, drmsubmatch);
#endif
@


1.31
log
@Remove unused includes, constify cfattach and other small cleanings.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.30 2013/06/04 02:16:14 mpi Exp $	*/
a64 1
pcitag_t vgafb_pci_console_tag;
d142 1
d154 7
a160 15
	/* If it's the console, we have a winner! */
	if (!bcmp(&pa->pa_tag, &vgafb_pci_console_tag, sizeof(pa->pa_tag))) {
		return (1);
	}

#ifdef DEBUG_VGAFB
	{
	int i;
		pci_chipset_tag_t pc = pa->pa_pc;
		for (i = 0x10; i < 0x24; i+=4) {
			printf("vgafb confread %x %x\n",
				i, pci_conf_read(pc, pa->pa_tag, i));
		}
	}
#endif
d162 1
a162 1
	return (0);
d173 1
a173 1
	int console;
d177 2
d183 1
a183 1
	console = (!bcmp(&pa->pa_tag, &vgafb_pci_console_tag, sizeof(pa->pa_tag)));
@


1.30
log
@Do not pretend mapping the MMIO region when in fact we don't and
clean some related code.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.29 2013/06/04 02:09:00 mpi Exp $	*/
a32 1
#include <sys/kernel.h>
a35 4
#include <machine/autoconf.h>
#include <machine/pte.h>

#include <dev/cons.h>
a42 1
#include <dev/wsfont/wsfont.h>
d61 2
a62 2
struct cfattach vgafb_pci_ca = {
	sizeof(struct vga_pci_softc), (cfmatch_t)vgafb_pci_match, vgafb_pci_attach,
@


1.29
log
@Spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.28 2013/06/03 23:28:43 mpi Exp $	*/
d196 1
a196 1
	if (console)
d198 8
a205 1
	else {
d210 1
a210 2
		vgafb_init(pa->pa_iot, pa->pa_memt, vc,
		    memaddr, memsize, mmioaddr, mmiosize);
d213 8
a226 10

	vc->membase = memaddr;
	vc->memsize = memsize;
	vc->mmiobase = mmioaddr;
	vc->mmiosize = mmiosize;

	if (mmiosize != 0)
		printf (", mmio");

	printf("\n");
@


1.28
log
@There's no reason to have a separate structure to hold and duplicate
the raster display data.  Simplify this by using only one pointer to
a struct rasops_info, the one in vga_config.

While here remove unused fields from vga_config.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.27 2012/12/13 13:55:18 mpi Exp $	*/
d9 1
a9 1
 * 
d15 3
a17 3
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
d19 1
a19 1
 * 
@


1.27
log
@iMac G3 grahic cards have a ``misc'' pci subclass that's why they weren't
attached to vgafb(4) since the use of the generic DEVICE_IS_VGA_PCI macro
in r1.26. Correct this and document why we should attach devices with such
subclass.

Fix a regression introduced in august when adding the glue to attach drm(4)
on macppc, reported by brynet@@ and nick@@ on bugs@@, thanks and sorry for the
delay!
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.26 2012/08/30 21:54:13 mpi Exp $	*/
d72 1
a72 1
struct vga_config vgafb_pci_console_vc;
d197 1
a197 1
		vc = sc->sc_vc = &vgafb_pci_console_vc;
a213 2
	vc->vc_mmap = vgafb_mmap;
	vc->vc_ioctl = vgafb_ioctl;
@


1.26
log
@Determine the memory and mmio regions based on previously initialzed BAR
structures and add the necessary glue to attach drm(4).

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.25 2012/06/21 10:08:16 mpi Exp $	*/
d150 9
a158 2
	if (DEVICE_IS_VGA_PCI(pa->pa_class) == 0)
		return (0);
@


1.25
log
@Only allow the memory and mmio regions to be mmap()'ed at their real
addresses, remove the magic value to uniformize access to the mmio and
doesn't map the unused pseudo-vga registers.

While here simplify the console attachement logic and removed some
unused global variables. Tested by matthieu@@ and myself on various
different G3 and G4 models.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.24 2012/01/29 14:44:16 mpi Exp $	*/
d50 2
d53 1
a53 1
#include <arch/macppc/pci/vgafb_pcivar.h>
d55 5
a59 9
#define PCI_VENDORID(x) ((x) & 0xFFFF)
#define PCI_CHIPID(x)   (((x) >> 16) & 0xFFFF)

struct vgafb_pci_softc {
	struct device sc_dev; 
 
	pcitag_t sc_pcitag;		/* PCI tag, in case we need it. */
	struct vgafb_config *sc_vc;	/* VGA configuration */ 
};
a60 3
int vgafb_pci_probe(struct pci_attach_args *pa, int id, u_int32_t *ioaddr,
    u_int32_t *iosize, u_int32_t *memaddr, u_int32_t *memsize,
    u_int32_t *cacheable, u_int32_t *mmioaddr, u_int32_t *mmiosize);
d64 3
d68 1
a68 1
	sizeof(struct vgafb_pci_softc), (cfmatch_t)vgafb_pci_match, vgafb_pci_attach,
d72 1
a72 1
struct vgafb_config vgafb_pci_console_vc;
d74 3
a76 8
#if 0
#define DEBUG_VGAFB
#endif

int
vgafb_pci_probe(struct pci_attach_args *pa, int id, u_int32_t *ioaddr,
    u_int32_t *iosize, u_int32_t *memaddr, u_int32_t *memsize,
    u_int32_t *cacheable, u_int32_t *mmioaddr, u_int32_t *mmiosize)
d78 1
a78 5
	bus_addr_t addr;
	bus_size_t size;
	int tcacheable;
	pci_chipset_tag_t pc = pa->pa_pc;
	int retval;
a80 1
	*iosize   = 0x0;
a82 20
	for (i = PCI_MAPREG_START; i <= PCI_MAPREG_PPB_END; i += 4) {
#ifdef DEBUG_VGAFB
		printf("vgafb confread %x %x\n",
			i, pci_conf_read(pc, pa->pa_tag, i));
#endif
		/* need to check more than just two base addresses? */
		if (PCI_MAPREG_TYPE(pci_conf_read(pc, pa->pa_tag, i)) ==
		    PCI_MAPREG_TYPE_IO) {
			retval = pci_io_find(pc, pa->pa_tag, i,
				&addr, &size);
			if (retval != 0) {
				continue;
			}
#ifdef DEBUG_VGAFB
	printf("vgafb_pci_probe: io %x addr %x size %x\n", i, addr, size);
#endif
			if (*iosize == 0) {
				*ioaddr = addr;
				*iosize = size;
			}
d84 13
a96 10
		} else {
			retval = pci_mem_find(pc, pa->pa_tag, i,
				&addr, &size, &tcacheable);
			if (retval != 0) {
				continue;
			}
#ifdef DEBUG_VGAFB
	printf("vgafb_pci_probe: mem %x addr %x size %x\n", i, addr, size);
#endif
			if (size == 0 || addr == 0) {
d103 2
a104 3
				*memaddr = addr;
				*memsize = size;
				*cacheable = tcacheable;
d107 1
a107 1
				 * Oh, we have a second 'memory' 
d111 2
a112 2
				 */ 
				 if (*memaddr >= size) {
d114 2
a115 6
					*mmioaddr = addr;
					/* ATI driver maps 0x80000 mmio, grr */
					if (size < 0x80000) {
						size = 0x80000;
					}
					*mmiosize = size;
a118 1
					*memaddr = addr;
d120 2
a121 6
					*memsize = size;
					*cacheable = tcacheable;
					/* ATI driver maps 0x80000 mmio, grr */
					if (*mmiosize < 0x80000) {
						*mmiosize = 0x80000;
					}
d124 2
a126 32
	}
#ifdef DEBUG_VGAFB
	printf("vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\n memsize %x, mmioaddr %x, mmiosize %x\n",
		id, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);
#endif
	if (*iosize == 0) {
		if (id == 0) {
#ifdef powerpc
			/* this is only used if on openfirmware system and
			 * the device does not have a iobase config register,
			 * eg CirrusLogic 5434 VGA.  (they hardcode iobase to 0
			 * thus giving standard PC addresses for the registers) 
			 */
			int s;
			u_int32_t sizedata;

			/*
			 * Open Firmware (yuck) shuts down devices before
			 * entering a program so we need to bring them back
			 * 'online' to respond to bus accesses... so far
			 * this is true on the power.4e.
			 */
			s = splhigh();
			sizedata = pci_conf_read(pc, pa->pa_tag,
				PCI_COMMAND_STATUS_REG);
			sizedata |= (PCI_COMMAND_MASTER_ENABLE |
				     PCI_COMMAND_IO_ENABLE |
				     PCI_COMMAND_PARITY_ENABLE |
				     PCI_COMMAND_SERR_ENABLE);
			pci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
				sizedata);
			splx(s);
d128 3
a130 6
#endif
			/* if this is the first card, allow it
			 * to be accessed in vga iospace
			 */
			*ioaddr = 0;
			*iosize = 0x10000; /* 64k, good as any */
d132 1
a132 3
			/* iospace not available, assume 640x480, pray */
			*ioaddr = 0;
			*iosize = 0;
a134 8
#ifdef DEBUG_VGAFB
	printf("vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\n memsize %x, mmioaddr %x, mmiosize %x\n",
		id, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);
#endif
	
	/* io and mmio spaces are not required to attach */
	if (/* *iosize == 0 || */ *memsize == 0 /* || *mmiosize == 0 */)
		return (0);
d136 7
a142 1
	return (1);
d176 3
a178 4
	struct vgafb_pci_softc *sc = (struct vgafb_pci_softc *)self;
	struct vgafb_config *vc;
	u_int32_t memaddr, memsize, cacheable;
	u_int32_t ioaddr, iosize;
d181 1
a181 2
	static int id = 0;
	int myid;
a182 1
	myid = id;
d184 2
a185 2
	vgafb_pci_probe(pa, myid, &ioaddr, &iosize,
		&memaddr, &memsize, &cacheable, &mmioaddr, &mmiosize);
d192 2
a193 2
		vc = sc->sc_vc = (struct vgafb_config *)
		    malloc(sizeof(struct vgafb_config), M_DEVBUF, M_WAITOK);
d199 8
a213 5
	sc->sc_pcitag = pa->pa_tag;

	if (iosize == 0)
		printf (", no io");

d220 4
a223 1
	id++;
@


1.24
log
@Ansify and remove useless variable.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.22 2011/09/29 20:57:43 miod Exp $	*/
d275 2
a276 2
		vgafb_common_setup(pa->pa_iot, pa->pa_memt, vc, 
		ioaddr, iosize, memaddr, memsize, mmioaddr, mmiosize);
a296 39
}

void
vgafb_pci_console(bus_space_tag_t iot, u_int32_t ioaddr, u_int32_t iosize,
    bus_space_tag_t  memt, u_int32_t memaddr, u_int32_t memsize,
    pci_chipset_tag_t pc, int bus, int device, int function)
{
	struct vgafb_config *vc = &vgafb_pci_console_vc;
	u_int32_t mmioaddr;
	u_int32_t mmiosize;
	static struct pci_attach_args spa;
	struct pci_attach_args *pa = &spa;

	/* for later recognition */
	vgafb_pci_console_tag = pci_make_tag(pc, bus, device, function);

	pa->pa_iot = iot;
	pa->pa_memt = memt;
	pa->pa_tag = vgafb_pci_console_tag;
	/* 
	pa->pa_pc = XXX;
	 */

/* XXX probe pci before pci bus config? */

	mmioaddr =0;
	mmiosize =0;
#if 0
	vgafb_pci_probe(pa, 0, &ioaddr, &iosize,
		&memaddr, &memsize, &cacheable, mmioaddr, mmiosize);
#endif


	/* set up bus-independent VGA configuration */
	vgafb_common_setup(iot, memt, vc,
		ioaddr, iosize, memaddr, memsize, mmioaddr, mmiosize);

	vgafb_cnattach(iot, memt, pc, bus, device, function);
	vc->nscreens++;
@


1.23
log
@Start cleaning vgafb(4) to be make it more like vga(4). Remove unused
function and move vgafb functions to there right place.

ok miod@@
@
text
@d222 1
a222 4
vgafb_pci_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
a224 1
	static int id = 0;
a230 1
		id++;
@


1.22
log
@Fix local types in vgafb_pci_probe(), to match what pci_*_find() expect,
after the bus_{addr,size}_t type definition change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.21 2010/05/22 21:30:26 deraadt Exp $	*/
a68 3
paddr_t	vgafbpcimmap(void *, off_t, int);
int	vgafbpciioctl(void *, u_long, caddr_t, int, struct proc *);

d283 2
a284 2
	vc->vc_mmap = vgafbpcimmap;
	vc->vc_ioctl = vgafbpciioctl;
a340 54
}

int
vgafbpciioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct vgafb_pci_softc *sc = v;

	return (vgafb_ioctl(sc->sc_vc, cmd, data, flag, p));
}

paddr_t
vgafbpcimmap(void *v, off_t offset, int prot)
{
	struct vgafb_pci_softc *sc = v;

	return (vgafb_mmap(sc->sc_vc, offset, prot));
}

int
vgafb_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *attrp)
{
	struct vgafb_config *vc = v;
	long defattr;

	if (vc->nscreens > 0)
		return (ENOMEM);
  
	*cookiep = &vc->dc_rinfo; /* one and only for now */
	*curxp = 0;
	*curyp = 0;
	vc->dc_rinfo.ri_ops.alloc_attr(&vc->dc_rinfo, 0, 0, 0, &defattr);
	*attrp = defattr;
	vc->nscreens++; 
	return (0);
}
  
void
vgafb_free_screen(void *v, void *cookie)
{
	struct vgafb_config *vc = v;

	if (vc == &vgafb_pci_console_vc)
		panic("vgafb_free_screen: console");

	vc->nscreens--;
}
        
int
vgafb_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{

	return (0);
@


1.21
log
@macppc never has i386 defined; ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.20 2009/03/01 10:48:54 kettenis Exp $	*/
d88 3
a90 2
	u_long addr;
	u_int32_t size, tcacheable;
@


1.20
log
@Don't let an mmio area replace the frame buffer if they are the same size.
Seen on a Tech Source Raptor.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.19 2007/11/05 19:24:31 martin Exp $	*/
a36 1
#ifndef i386
a37 1
#endif
@


1.19
log
@fix and use DEVICE_IS_VGA_PCI, makes vgafb_pci_match() much simpler

ok oga@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.18 2006/12/17 22:18:14 miod Exp $	*/
d146 1
a146 1
				 if (*memaddr > size) {
@


1.18
log
@Remove unnecessary <dev/wscons/wscons_raster.h> inclusion.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.17 2006/03/15 20:46:15 matthieu Exp $	*/
a231 1
	int potential;
a232 1
	int myid;
d234 1
a234 19
	myid = id;

	potential = 0;

	/*
	 * If it's prehistoric/vga or display/vga, we might match.
	 * For the console device, this is jut a sanity check.
	 */
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_PREHISTORIC &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_PREHISTORIC_VGA)
		potential = 1;
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_DISPLAY &&
	     PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_DISPLAY_VGA)
		potential = 1;
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_DISPLAY &&
	     PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_DISPLAY_MISC)
		potential = 1;

	if (!potential)
@


1.17
log
@Remove dead code (SUPPORTS_NON_CONSOLE and MD_DISPLAY_ISA_IOT)
ok miod@@, drahn@@, dim@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.16 2006/01/02 05:21:32 brad Exp $	*/
a48 1
#include <dev/wscons/wscons_raster.h>
@


1.16
log
@remove last traces of __BROKEN_INDIRECT_CONFIG.

Thanks to aanriot@@ and Michael Knudsen for checking that alpha/i386/macppc
kernels still compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.15 2005/03/15 21:10:37 miod Exp $	*/
a232 6
#ifdef SUPPORTS_NON_CONSOLE
	u_int32_t memaddr, memsize, cacheable;
	u_int32_t ioaddr, iosize;
	u_int32_t mmioaddr, mmiosize;
	int retval;
#endif
a274 28
#ifdef SUPPORTS_NON_CONSOLE
	/* ALL non-console vga support removed for now.
	 * when the problems with it are resolved,
	 * it can be reenabled.
	 */

	memaddr=0xb8000; /* default to isa addresses? */
	ioaddr = 0; 	 /* default to isa addresses? */

	retval = vgafb_pci_probe(pa, myid, &ioaddr, &iosize,
		&memaddr, &memsize, &cacheable, &mmioaddr, &mmiosize);
	if (retval == 0) {
		return 0;
	}
#if 1
	printf("ioaddr %x, iosize %x, memaddr %x, memsize %x mmioaddr %x mmiosize %x\n",
		ioaddr, iosize, memaddr, memsize, mmioaddr, mmiosize);
#endif

	if (!vgafb_common_probe(pa->pa_iot, pa->pa_memt, ioaddr, iosize, memaddr, memsize, mmioaddr, mmiosize))
	{
		printf("vgafb_pci_match: common_probe failed\n");
		return (0);
	}
	id++;

	return (1);
#endif
@


1.15
log
@Skip empty pci ranges rather than aborting probe, as done on sparc64.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.14 2003/11/12 20:08:31 miod Exp $	*/
a68 1
#ifdef __BROKEN_INDIRECT_CONFIG
a69 3
#else
int	vgafb_pci_match(struct device *, struct cfdata *, void *);
#endif
a228 1
#ifdef __BROKEN_INDIRECT_CONFIG
a229 3
#else
	struct cfdata *match;
#endif
@


1.14
log
@Be sure to cast the wsdisplay accessops cookie into the adequate structure;
prevents wsconscfg from panic'ing the system.

Reported by ``kluxis''.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.13 2003/10/15 23:00:57 drahn Exp $	*/
d114 3
a119 4

			if (retval) {
				return 0;
			}
d128 3
a133 4

			if (retval) {
				return 0;
			}
d215 1
a215 1
			*iosize=0;
d222 6
a227 1
	return 1;
@


1.13
log
@Further down the ANSI/KNF road, only binary difference is __LINE__.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.12 2003/06/16 21:59:15 drahn Exp $	*/
a63 1
	int nscreens;
d404 1
d427 1
a427 1
	struct vgafb_pci_softc *sc = v;
d430 1
a430 1
	if (sc->nscreens > 0)
d433 1
a433 1
	*cookiep = &sc->sc_vc->dc_rinfo; /* one and only for now */
d436 1
a436 2
	sc->sc_vc->dc_rinfo.ri_ops.alloc_attr(&sc->sc_vc->dc_rinfo,
	    0, 0, 0, &defattr);
d438 1
a438 1
	sc->nscreens++; 
d445 1
a445 1
	struct vgafb_pci_softc *sc = v;
d447 1
a447 1
	if (sc->sc_vc == &vgafb_pci_console_vc)
d450 1
a450 1
	sc->nscreens--;
@


1.12
log
@Use a slightly better way to intuit the memory/mmio PCI regions,
now properly detects these for nvidia based LCDs. On some machines
accellerated X using nv now works.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.11 2002/09/17 02:59:34 drahn Exp $	*/
d92 3
a94 6
vgafb_pci_probe(pa, id, ioaddr, iosize, memaddr, memsize, cacheable, mmioaddr, mmiosize)
	struct pci_attach_args *pa;
	int id;
	u_int32_t *ioaddr, *iosize;
	u_int32_t *memaddr, *memsize, *cacheable;
	u_int32_t *mmioaddr, *mmiosize;
d319 1
a319 3
vgafb_pci_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d357 1
a357 1
	if (iosize == 0) {
d359 2
a360 2
	}
	if (mmiosize != 0) {
d362 1
a362 1
	}
d370 3
a372 7
vgafb_pci_console(iot, ioaddr, iosize, memt, memaddr, memsize,
		pc, bus, device, function)
	bus_space_tag_t iot, memt;
	u_int32_t memaddr, memsize;
	u_int32_t ioaddr, iosize;
	pci_chipset_tag_t pc;
	int bus, device, function;
d408 1
a408 6
vgafbpciioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d416 1
a416 4
vgafbpcimmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d424 2
a425 6
vgafb_alloc_screen(v, type, cookiep, curxp, curyp, attrp)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *curxp, *curyp;
	long *attrp;
d444 1
a444 3
vgafb_free_screen(v, cookie)
	void *v;
	void *cookie;
d455 2
a456 6
vgafb_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
@


1.11
log
@Until vgafb on macppc properly support non-console operation, do
not allow it to execute code which could panic the otherwise booting system.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.10 2002/09/15 09:01:59 deraadt Exp $	*/
d140 1
a140 1
			if (size == 0) {
d142 17
a158 7
			} else if (size <= (1024 * 1024)) {
#ifdef DEBUG_VGAFB
	printf("vgafb_pci_probe: mem %x addr %x size %x iosize %x\n",
		i, addr, size, *iosize);
#endif
				if (*mmiosize == 0) {
					/* this is mmio, not memory */
d160 1
a161 1
						/* ATI driver maps 0x80000, grr */
d165 3
a167 4
					/* need skew in here for io memspace */
				}
			} else {
				if (*memsize == 0) {
d169 1
d172 5
a176 1
				}
@


1.10
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.8 2002/05/22 21:00:03 miod Exp $	*/
d228 1
d232 2
a234 1
	int retval;
d276 6
d303 2
@


1.9
log
@KNF
@
text
@d60 2
a61 2
	struct device sc_dev;

d63 1
a63 1
	struct vgafb_config *sc_vc;	/* VGA configuration */
d111 1
a111 1
		    i, pci_conf_read(pc, pa->pa_tag, i));
d117 1
a117 1
			    &addr, &size);
d132 1
a132 1
			    &addr, &size, &tcacheable);
d145 1
a145 1
	    i, addr, size, *iosize);
d167 2
a168 3
	printf("vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\n"
	    " memsize %x, mmioaddr %x, mmiosize %x\n",
	    id, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);
d176 1
a176 1
			 * thus giving standard PC addresses for the registers)
d189 1
a189 1
			    PCI_COMMAND_STATUS_REG);
d191 3
a193 3
			    PCI_COMMAND_IO_ENABLE |
			    PCI_COMMAND_PARITY_ENABLE |
			    PCI_COMMAND_SERR_ENABLE);
d195 1
a195 1
			    sizedata);
d211 2
a212 3
	printf("vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\n"
	    " memsize %x, mmioaddr %x, mmiosize %x\n",
	    id, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);
d248 1
a248 1
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_DISPLAY_VGA)
d251 1
a251 1
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_DISPLAY_MISC)
d265 1
a265 1
		int i;
a266 1

d269 1
a269 1
			    i, pci_conf_read(pc, pa->pa_tag, i));
d274 2
a275 2
	memaddr=0xb8000;	/* default to isa addresses? */
	ioaddr = 0;		/* default to isa addresses? */
d278 1
a278 1
	    &memaddr, &memsize, &cacheable, &mmioaddr, &mmiosize);
d284 1
a284 1
	    ioaddr, iosize, memaddr, memsize, mmioaddr, mmiosize);
d287 2
a288 2
	if (!vgafb_common_probe(pa->pa_iot, pa->pa_memt, ioaddr, iosize,
	    memaddr, memsize, mmioaddr, mmiosize)) {
d315 1
a315 1
	    &memaddr, &memsize, &cacheable, &mmioaddr, &mmiosize);
d326 2
a327 2
		vgafb_common_setup(pa->pa_iot, pa->pa_memt, vc,
		    ioaddr, iosize, memaddr, memsize, mmioaddr, mmiosize);
d339 1
a339 1
		printf(", no io");
d342 1
a342 1
		printf(", mmio");
d371 1
a371 1
	/*
d381 1
a381 1
	    &memaddr, &memsize, &cacheable, mmioaddr, mmiosize);
d387 1
a387 1
	    ioaddr, iosize, memaddr, memsize, mmioaddr, mmiosize);
d429 1
a429 1

d436 1
a436 1
	sc->nscreens++;
d439 1
a439 1

d452 1
a452 1

@


1.8
log
@- in the OpenFirmware console initialisation, check if the console device
has support for backlight control (laptops do, and probably machines with
a built-in monitor do as well).
- provide a function to set the screen brightness as well.
- use both changes above to add a screen blanker to the vgafb driver
- let the screen brightness and backlight be controlled via wsconsctl
- clean dust, KNF, and more symbolic names in the vgafb driver to make it
better readable

Initial code by myself, with some hacks from drahn@@ later.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.7 2002/04/29 01:34:58 drahn Exp $	*/
d60 2
a61 2
	struct device sc_dev; 
 
d63 1
a63 1
	struct vgafb_config *sc_vc;	/* VGA configuration */ 
d111 1
a111 1
			i, pci_conf_read(pc, pa->pa_tag, i));
d117 1
a117 1
				&addr, &size);
d132 1
a132 1
				&addr, &size, &tcacheable);
d145 1
a145 1
		i, addr, size, *iosize);
d167 3
a169 2
	printf("vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\n memsize %x, mmioaddr %x, mmiosize %x\n",
		id, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);
d177 1
a177 1
			 * thus giving standard PC addresses for the registers) 
d190 1
a190 1
				PCI_COMMAND_STATUS_REG);
d192 3
a194 3
				     PCI_COMMAND_IO_ENABLE |
				     PCI_COMMAND_PARITY_ENABLE |
				     PCI_COMMAND_SERR_ENABLE);
d196 1
a196 1
				sizedata);
d212 3
a214 2
	printf("vgafb_pci_probe: id %x ioaddr %x, iosize %x, memaddr %x,\n memsize %x, mmioaddr %x, mmiosize %x\n",
		id, *ioaddr, *iosize, *memaddr, *memsize, *mmioaddr, *mmiosize);
d250 1
a250 1
	     PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_DISPLAY_VGA)
d253 1
a253 1
	     PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_DISPLAY_MISC)
d267 1
a267 1
	int i;
d269 1
d272 1
a272 1
				i, pci_conf_read(pc, pa->pa_tag, i));
d277 2
a278 2
	memaddr=0xb8000; /* default to isa addresses? */
	ioaddr = 0; 	 /* default to isa addresses? */
d281 1
a281 1
		&memaddr, &memsize, &cacheable, &mmioaddr, &mmiosize);
d287 1
a287 1
		ioaddr, iosize, memaddr, memsize, mmioaddr, mmiosize);
d290 2
a291 2
	if (!vgafb_common_probe(pa->pa_iot, pa->pa_memt, ioaddr, iosize, memaddr, memsize, mmioaddr, mmiosize))
	{
d318 1
a318 1
		&memaddr, &memsize, &cacheable, &mmioaddr, &mmiosize);
d329 2
a330 2
		vgafb_common_setup(pa->pa_iot, pa->pa_memt, vc, 
		ioaddr, iosize, memaddr, memsize, mmioaddr, mmiosize);
d342 1
a342 1
		printf (", no io");
d345 1
a345 1
		printf (", mmio");
d374 1
a374 1
	/* 
d384 1
a384 1
		&memaddr, &memsize, &cacheable, mmioaddr, mmiosize);
d390 1
a390 1
		ioaddr, iosize, memaddr, memsize, mmioaddr, mmiosize);
d432 1
a432 1
  
d439 1
a439 1
	sc->nscreens++; 
d442 1
a442 1
  
d455 1
a455 1
        
@


1.7
log
@Change macppc vgafb from rcons to rasops, a faster color supporting virtual
terminal emulator for gfx console. tested by mattheiu, miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.6 2002/03/27 20:54:42 drahn Exp $	*/
d118 4
a122 1
	printf("vgafb_pci_probe: io %x addr %x size %x\n", i, addr, size);
a137 1
	printf("vgafb_pci_probe: mem %x addr %x size %x\n", i, addr, size);
d142 1
a142 1
			}else if (size <= (1024 * 1024)) {
d216 1
a330 2
	vc->iobase = ioaddr;
	vc->iosize = iosize;
@


1.6
log
@tsk tsk tsk, compile it first.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.5 2002/03/27 15:26:11 jason Exp $	*/
a46 1
#include <dev/rcons/raster.h>
d50 2
d429 1
a429 1
	*cookiep = &sc->sc_vc->dc_rcons; /* one and only for now */
d432 2
a433 1
	rcons_alloc_attr(&sc->sc_vc->dc_rcons, 0, 0, 0, &defattr);
@


1.5
log
@Don't use magic constants to the loop over the BAR, also, include the
politically correct check for whether this is an io or mem mapping space.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.4 2002/03/26 16:51:43 drahn Exp $	*/
d114 1
a114 1
		    PCI_MAPREG_TYPE_IO)
@


1.4
log
@Only allow valid device PAs to be mmapped.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.3 2002/03/14 01:26:37 millert Exp $	*/
d107 1
a107 1
	for (i = 0x10; i <= 0x18; i += 4) {
d113 2
a114 1
		if (0x1 & pci_conf_read(pc, pa->pa_tag, i) ) {
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.2 2001/10/31 12:26:18 art Exp $	*/
d107 1
a107 1
	for (i = 0x10; i < 0x18; i += 4) {
d138 1
a138 1
			}else if (size <= (64 * 1024)) {
d146 4
d312 1
d326 6
@


1.2
log
@Change the internal vc_mmap from returning int to paddr_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.1 2001/09/01 15:55:18 drahn Exp $	*/
d66 1
a66 1
int vgafb_pci_probe __P((struct pci_attach_args *pa, int id, u_int32_t *ioaddr,
d68 1
a68 1
    u_int32_t *cacheable, u_int32_t *mmioaddr, u_int32_t *mmiosize));
d70 1
a70 1
int	vgafb_pci_match __P((struct device *, void *, void *));
d72 1
a72 1
int	vgafb_pci_match __P((struct device *, struct cfdata *, void *));
d74 1
a74 1
void	vgafb_pci_attach __P((struct device *, struct device *, void *));
d76 2
a77 2
paddr_t	vgafbpcimmap __P((void *, off_t, int));
int	vgafbpciioctl __P((void *, u_long, caddr_t, int, struct proc *));
d443 1
a443 1
	void (*cb) __P((void *, int, int));
@


1.2.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.2 2001/10/31 12:26:18 art Exp $	*/
d47 1
a50 2
#include <dev/rasops/rasops.h>
#include <dev/wsfont/wsfont.h>
d66 1
a66 1
int vgafb_pci_probe(struct pci_attach_args *pa, int id, u_int32_t *ioaddr,
d68 1
a68 1
    u_int32_t *cacheable, u_int32_t *mmioaddr, u_int32_t *mmiosize);
d70 1
a70 1
int	vgafb_pci_match(struct device *, void *, void *);
d72 1
a72 1
int	vgafb_pci_match(struct device *, struct cfdata *, void *);
d74 1
a74 1
void	vgafb_pci_attach(struct device *, struct device *, void *);
d76 2
a77 2
paddr_t	vgafbpcimmap(void *, off_t, int);
int	vgafbpciioctl(void *, u_long, caddr_t, int, struct proc *);
d107 1
a107 1
	for (i = PCI_MAPREG_START; i <= PCI_MAPREG_PPB_END; i += 4) {
d113 1
a113 2
		if (PCI_MAPREG_TYPE(pci_conf_read(pc, pa->pa_tag, i)) ==
		    PCI_MAPREG_TYPE_IO) {
d116 1
a116 1
#ifdef DEBUG_VGAFB
a117 3
#endif

			if (retval) {
d133 1
d138 1
a138 1
			} else if (size <= (1024 * 1024)) {
a145 4
					if (size < 0x80000) {
						/* ATI driver maps 0x80000, grr */
						size = 0x80000;
					}
a207 1

a307 1

a320 4
	vc->membase = memaddr;
	vc->memsize = memsize;
	vc->mmiobase = mmioaddr;
	vc->mmiosize = mmiosize;
d416 1
a416 1
	*cookiep = &sc->sc_vc->dc_rinfo; /* one and only for now */
d419 1
a419 2
	sc->sc_vc->dc_rinfo.ri_ops.alloc_attr(&sc->sc_vc->dc_rinfo,
	    0, 0, 0, &defattr);
d443 1
a443 1
	void (*cb)(void *, int, int);
@


1.2.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.2.2.1 2002/06/11 03:36:34 art Exp $	*/
a227 1
#ifdef SUPPORTS_NON_CONSOLE
d231 1
a232 2
#endif
	int potential;
a273 6
#ifdef SUPPORTS_NON_CONSOLE
	/* ALL non-console vga support removed for now.
	 * when the problems with it are resolved,
	 * it can be reenabled.
	 */

a294 2
#endif
	return (0);
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/pci to macppc/pci

The file pci_machdep.h was not moved in this conversion.
It needs to be check if it is correct that should be the only shared
powerpc/pci file. Or if that file too should be MD, or more files MI.
@
text
@d1 1
a1 1
/*	$OpenBSD: vgafb_pci.c,v 1.5 2001/07/09 03:54:40 mickey Exp $	*/
d76 1
a76 1
int	vgafbpcimmap __P((void *, off_t, int));
d391 1
a391 1
int
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.4.2
log
@Merge in -current
@
text
@d76 1
a76 1
paddr_t	vgafbpcimmap __P((void *, off_t, int));
d391 1
a391 1
paddr_t
@


1.1.4.3
log
@Merge in -current from about a week ago
@
text
@d66 1
a66 1
int vgafb_pci_probe(struct pci_attach_args *pa, int id, u_int32_t *ioaddr,
d68 1
a68 1
    u_int32_t *cacheable, u_int32_t *mmioaddr, u_int32_t *mmiosize);
d70 1
a70 1
int	vgafb_pci_match(struct device *, void *, void *);
d72 1
a72 1
int	vgafb_pci_match(struct device *, struct cfdata *, void *);
d74 1
a74 1
void	vgafb_pci_attach(struct device *, struct device *, void *);
d76 2
a77 2
paddr_t	vgafbpcimmap(void *, off_t, int);
int	vgafbpciioctl(void *, u_long, caddr_t, int, struct proc *);
d443 1
a443 1
	void (*cb)(void *, int, int);
@


1.1.4.4
log
@Sync the SMP branch with 3.3
@
text
@d47 1
a50 2
#include <dev/rasops/rasops.h>
#include <dev/wsfont/wsfont.h>
d107 1
a107 1
	for (i = PCI_MAPREG_START; i <= PCI_MAPREG_PPB_END; i += 4) {
d113 1
a113 2
		if (PCI_MAPREG_TYPE(pci_conf_read(pc, pa->pa_tag, i)) ==
		    PCI_MAPREG_TYPE_IO) {
d116 1
a116 1
#ifdef DEBUG_VGAFB
a117 3
#endif

			if (retval) {
d133 1
d138 1
a138 1
			} else if (size <= (1024 * 1024)) {
a145 4
					if (size < 0x80000) {
						/* ATI driver maps 0x80000, grr */
						size = 0x80000;
					}
a207 1

a218 1
#ifdef SUPPORTS_NON_CONSOLE
d222 1
a223 2
#endif
	int potential;
a264 6
#ifdef SUPPORTS_NON_CONSOLE
	/* ALL non-console vga support removed for now.
	 * when the problems with it are resolved,
	 * it can be reenabled.
	 */

a285 2
#endif
	return (0);
a307 1

a320 4
	vc->membase = memaddr;
	vc->memsize = memsize;
	vc->mmiobase = mmioaddr;
	vc->mmiosize = mmiosize;
d416 1
a416 1
	*cookiep = &sc->sc_vc->dc_rinfo; /* one and only for now */
d419 1
a419 2
	sc->sc_vc->dc_rinfo.ri_ops.alloc_attr(&sc->sc_vc->dc_rinfo,
	    0, 0, 0, &defattr);
@


1.1.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d64 1
d92 6
a97 3
vgafb_pci_probe(struct pci_attach_args *pa, int id, u_int32_t *ioaddr,
    u_int32_t *iosize, u_int32_t *memaddr, u_int32_t *memsize,
    u_int32_t *cacheable, u_int32_t *mmioaddr, u_int32_t *mmiosize)
d140 1
a140 1
			if (size == 0 || addr == 0) {
d142 7
a148 17
			} else if (*memsize == 0) {
				/*
				 * first memory slot found goes into memory,
				 * this is for the case of no mmio
				 */
				*memaddr = addr;
				*memsize = size;
				*cacheable = tcacheable;
			} else {
				/*
				 * Oh, we have a second 'memory' 
				 * region, is this region the vga memory
				 * or mmio, we guess that memory is
				 * the larger of the two.
				 */ 
				 if (*memaddr > size) {
					/* this is the mmio */
a149 1
					/* ATI driver maps 0x80000 mmio, grr */
d151 1
d155 4
a158 3
				 } else {
					/* this is the memory */
					*mmioaddr = *memaddr;
a159 1
					*mmiosize = *memsize;
d162 1
a162 5
					/* ATI driver maps 0x80000 mmio, grr */
					if (*mmiosize < 0x80000) {
						*mmiosize = 0x80000;
					}
				 }
d308 3
a310 1
vgafb_pci_attach(struct device *parent, struct device  *self, void *aux)
d348 1
a348 1
	if (iosize == 0)
d350 2
a351 2

	if (mmiosize != 0)
d353 1
a353 1

d361 7
a367 3
vgafb_pci_console(bus_space_tag_t iot, u_int32_t ioaddr, u_int32_t iosize,
    bus_space_tag_t  memt, u_int32_t memaddr, u_int32_t memsize,
    pci_chipset_tag_t pc, int bus, int device, int function)
a399 1
	vc->nscreens++;
d403 6
a408 1
vgafbpciioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
d416 4
a419 1
vgafbpcimmap(void *v, off_t offset, int prot)
d427 6
a432 2
vgafb_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *attrp)
d434 1
a434 1
	struct vgafb_config *vc = v;
d437 1
a437 1
	if (vc->nscreens > 0)
d440 1
a440 1
	*cookiep = &vc->dc_rinfo; /* one and only for now */
d443 2
a444 1
	vc->dc_rinfo.ri_ops.alloc_attr(&vc->dc_rinfo, 0, 0, 0, &defattr);
d446 1
a446 1
	vc->nscreens++; 
d451 3
a453 1
vgafb_free_screen(void *v, void *cookie)
d455 1
a455 1
	struct vgafb_config *vc = v;
d457 1
a457 1
	if (vc == &vgafb_pci_console_vc)
d460 1
a460 1
	vc->nscreens--;
d464 6
a469 2
vgafb_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
@


