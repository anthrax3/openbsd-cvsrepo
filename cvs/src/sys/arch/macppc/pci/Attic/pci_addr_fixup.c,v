head	1.12;
access;
symbols
	OPENBSD_4_5:1.11.0.12
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.9.0.10
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.6.0.8
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	SMP:1.6.0.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	UBC:1.6.0.2
	UBC_SYNC_B:1.6
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4;
locks; strict;
comment	@ * @;


1.12
date	2009.05.03.21.30.09;	author kettenis;	state dead;
branches;
next	1.11;

1.11
date	2006.07.14.05.46.54;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.07.13.18.02.18;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.20.22.40.27;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.03.06.43.02;	author david;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.15.23.00.57;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.17.02.47.05;	author drahn;	state Exp;
branches
	1.6.2.1
	1.6.6.1;
next	1.5;

1.5
date	2002.10.07.05.39.48;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.23.04.24.58;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.15.09.01.59;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.23.17.53.25;	author drahn;	state Exp;
branches;
next	;

1.6.2.1
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	;

1.6.6.1
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Get rid of pci_addr_fixup machinery; set up the appropriate extents and pass
them along when we attach pci(4).  Simplify the rbus code by using extents
too.
@
text
@/*	$OpenBSD: pci_addr_fixup.c,v 1.11 2006/07/14 05:46:54 deraadt Exp $	*/
/*	$NetBSD: pci_addr_fixup.c,v 1.7 2000/08/03 20:10:45 nathanw Exp $	*/

/*-
 * Copyright (c) 2000 UCHIYAMA Yasushi.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/extent.h>

#include <uvm/uvm_param.h>
#include <machine/bus.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <macppc/pci/pcibrvar.h>

typedef int (*pciaddr_resource_manage_func_t)(struct pcibr_softc *,
	pci_chipset_tag_t, pcitag_t, int, struct extent *, int, bus_addr_t *,
	bus_size_t);
void pciaddr_resource_manage(struct pcibr_softc *,
    pci_chipset_tag_t, pcitag_t, pciaddr_resource_manage_func_t);
void pciaddr_resource_reserve(struct pcibr_softc *,
    pci_chipset_tag_t, pcitag_t);
void pciaddr_resource_reserve_disabled(struct pcibr_softc *,
    pci_chipset_tag_t, pcitag_t);
int pciaddr_do_resource_reserve(struct pcibr_softc *,
    pci_chipset_tag_t, pcitag_t, int, struct extent *, int,
    bus_addr_t *, bus_size_t);
int pciaddr_do_resource_reserve_disabled(struct pcibr_softc *,
    pci_chipset_tag_t, pcitag_t, int, struct extent *, int,
    bus_addr_t *, bus_size_t);
void pciaddr_resource_allocate(struct pcibr_softc *,
    pci_chipset_tag_t, pcitag_t);
int pciaddr_do_resource_allocate(struct pcibr_softc *,
    pci_chipset_tag_t, pcitag_t, int, struct extent *, int, bus_addr_t *,
    bus_size_t);
bus_addr_t pciaddr_ioaddr(u_int32_t);
void pciaddr_print_devid(pci_chipset_tag_t, pcitag_t);

int pciaddr_device_is_agp(pci_chipset_tag_t, pcitag_t);

void pci_device_foreach(struct pcibr_softc *sc, pci_chipset_tag_t pc,
    int maxbus,
    void (*func)(struct pcibr_softc *, pci_chipset_tag_t, pcitag_t));

#define PCIADDR_MEM_START	0x0
#define PCIADDR_MEM_END		0xffffffff
#define PCIADDR_PORT_START	0x0
#define PCIADDR_PORT_END	0xffff

int pcibr_flags = 0;
#define PCIBR_VERBOSE		1
#define PCIBR_ADDR_FIXUP	2

#define PCIBIOS_PRINTV(x)  if (pcibr_flags & PCIBR_VERBOSE) \
	printf x

void
pci_addr_fixup(struct pcibr_softc *sc, pci_chipset_tag_t pc, int maxbus)
{
	const char *verbose_header = 
		"[%s]-----------------------\n"
		"  device vendor product\n"
		"  register space address    size\n"
		"--------------------------------------------\n";
	const char *verbose_footer = 
		"--------------------------[%3d devices bogus]\n";

	sc->extent_mem = extent_create("PCI I/O memory space",
	    sc->sc_membus_space.bus_base, 
	    sc->sc_membus_space.bus_base + sc->sc_membus_space.bus_size,
	    M_DEVBUF, 0, 0, EX_NOWAIT);
	KASSERT(sc->extent_mem);
	sc->extent_port = extent_create("PCI I/O port space",
	    PCIADDR_PORT_START, PCIADDR_PORT_END,
	    M_DEVBUF, 0, 0, EX_NOWAIT);
	KASSERT(sc->extent_port);

	/* 
	 * 1. check & reserve system BIOS setting.
	 */
	PCIBIOS_PRINTV((verbose_header, "System BIOS Setting"));
	pci_device_foreach(sc, pc, maxbus, pciaddr_resource_reserve);
	pci_device_foreach(sc, pc, maxbus, pciaddr_resource_reserve_disabled);
	PCIBIOS_PRINTV((verbose_footer, sc->nbogus));

	{
		struct extent_region *rp;
		struct extent *ex = sc->extent_mem;
		for (rp = LIST_FIRST(&ex->ex_regions);
		    rp; rp = LIST_NEXT(rp, er_link)) {
		}
	}
	{
		struct extent_region *rp;
		struct extent *ex = sc->extent_port;
		for (rp = LIST_FIRST(&ex->ex_regions);
		    rp; rp = LIST_NEXT(rp, er_link)) {
		}
	}

	/* 
	 * 4. do fixup 
	 */
	PCIBIOS_PRINTV((verbose_header, "PCIBIOS fixup stage"));
	sc->nbogus = 0;
	pci_device_foreach(sc, pc, maxbus, pciaddr_resource_allocate);
	PCIBIOS_PRINTV((verbose_footer, sc->nbogus));

}

void
pciaddr_resource_reserve(struct pcibr_softc *sc, pci_chipset_tag_t pc,
    pcitag_t tag)
{
	if (pcibr_flags & PCIBR_VERBOSE)
		pciaddr_print_devid(pc, tag);
	pciaddr_resource_manage(sc, pc, tag, pciaddr_do_resource_reserve);
}

void
pciaddr_resource_reserve_disabled(struct pcibr_softc *sc,
    pci_chipset_tag_t pc, pcitag_t tag)
{
	if (pcibr_flags & PCIBR_VERBOSE)
		pciaddr_print_devid(pc, tag);
	pciaddr_resource_manage(sc, pc, tag,
	    pciaddr_do_resource_reserve_disabled);
}

void
pciaddr_resource_allocate(struct pcibr_softc *sc, pci_chipset_tag_t pc,
    pcitag_t tag)
{
	if (pcibr_flags & PCIBR_VERBOSE)
		pciaddr_print_devid(pc, tag);
	pciaddr_resource_manage(sc, pc, tag, pciaddr_do_resource_allocate);
}

void
pciaddr_resource_manage(struct pcibr_softc *sc, pci_chipset_tag_t pc,
    pcitag_t tag, pciaddr_resource_manage_func_t func)
{
	struct extent *ex;
	pcireg_t val, mask;
	bus_addr_t addr;
	bus_size_t size;
	int error, mapreg, type, reg_start, reg_end, width;

	val = pci_conf_read(pc, tag, PCI_BHLC_REG);
	switch (PCI_HDRTYPE_TYPE(val)) {
	default:
		printf("WARNING: unknown PCI device header.\n");
		sc->nbogus++;
		return;
	case 0: 
		reg_start = PCI_MAPREG_START;
		reg_end   = PCI_MAPREG_END;
		break;
	case 1: /* PCI-PCI bridge */
		reg_start = PCI_MAPREG_START;
		reg_end   = PCI_MAPREG_PPB_END;
		break;
	case 2: /* PCI-CardBus bridge */
		reg_start = PCI_MAPREG_START;
		reg_end   = PCI_MAPREG_PCB_END;
		break;
	}
	error = 0;
    
	for (mapreg = reg_start; mapreg < reg_end; mapreg += width) {
		/* inquire PCI device bus space requirement */
		val = pci_conf_read(pc, tag, mapreg);
		pci_conf_write(pc, tag, mapreg, ~0);

		mask = pci_conf_read(pc, tag, mapreg);
		pci_conf_write(pc, tag, mapreg, val);
	
		type = PCI_MAPREG_TYPE(val);
		width = 4;
		if (type == PCI_MAPREG_TYPE_MEM) {
			if (PCI_MAPREG_MEM_TYPE(val) == 
			    PCI_MAPREG_MEM_TYPE_64BIT) {
				/* XXX We could examine the upper 32 bits
				 * XXX of the BAR here, but we are totally 
				 * XXX unprepared to handle a non-zero value, 
				 * XXX either here or anywhere else in 
				 * XXX i386-land. 
				 * XXX So just arrange to not look at the
				 * XXX upper 32 bits, lest we misinterpret
				 * XXX it as a 32-bit BAR set to zero. 
				 */
			    width = 8;
			}
			addr = PCI_MAPREG_MEM_ADDR(val);
			size = PCI_MAPREG_MEM_SIZE(mask);
			ex = sc->extent_mem;
		} else {
			/* XXX some devices give 32bit value */
			addr = PCI_MAPREG_IO_ADDR(val) & PCIADDR_PORT_END;
			size = PCI_MAPREG_IO_SIZE(mask);
			ex = sc->extent_port;
		}
	
		if (!size) /* unused register */
			continue;

		/* reservation/allocation phase */
		error += (*func) (sc, pc, tag, mapreg, ex, type, &addr, size);

		PCIBIOS_PRINTV(("\t%02xh %s 0x%08x 0x%08x\n", 
				mapreg, type ? "port" : "mem ", 
				(unsigned int)addr, (unsigned int)size));
	}

	if (error)
		sc->nbogus++;

	PCIBIOS_PRINTV(("\t\t[%s]\n", error ? "NG" : "OK"));
}

int
pciaddr_do_resource_allocate(struct pcibr_softc *sc, pci_chipset_tag_t pc,
    pcitag_t tag, int mapreg, struct extent *ex, int  type, bus_addr_t *addr,
    bus_size_t size)
{
	bus_addr_t start;
	int error;
	
	if (*addr) /* no need to allocate */
		return (0);

	/* XXX Don't allocate if device is AGP device to avoid conflict. */
	if (pciaddr_device_is_agp(pc, tag)) 
		return (0);
	
	start = (type == PCI_MAPREG_TYPE_MEM ? sc->sc_membus_space.bus_base
	    : PCIADDR_PORT_START);
	if (start < ex->ex_start || start + size - 1 >= ex->ex_end) {
		PCIBIOS_PRINTV(("No available resources. fixup failed\n"));
		return (1);
	}
	error = extent_alloc_subregion(ex, start, ex->ex_end, size, size, 0, 0,
	    EX_FAST|EX_NOWAIT|EX_MALLOCOK, addr);
	if (error) {
		PCIBIOS_PRINTV(("No available resources. fixup failed\n"));
		return (1);
	}

	/* write new address to PCI device configuration header */
	pci_conf_write(pc, tag, mapreg, *addr);
	/* check */
	if (pcibr_flags & PCIBR_VERBOSE) {
		printf("pci_addr_fixup: ");
		pciaddr_print_devid(pc, tag);
	}

	if (pciaddr_ioaddr(pci_conf_read(pc, tag, mapreg)) != *addr) {
		pci_conf_write(pc, tag, mapreg, 0); /* clear */
		printf("fixup failed. (new address=%#lx)\n", *addr);
		return (1);
	}
	if (pcibr_flags & PCIBR_VERBOSE)
		printf("new address 0x%08lx\n", *addr);

	return (0);
}

int
pciaddr_do_resource_reserve(struct pcibr_softc *sc, pci_chipset_tag_t pc,
    pcitag_t tag, int mapreg, struct extent *ex, int type, bus_addr_t *addr,
    bus_size_t size)
{
	pcireg_t val;
	int error;

	if (*addr == 0)
		return (0);

	val = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	if (type == PCI_MAPREG_TYPE_MEM &&
	    (val & PCI_COMMAND_MEM_ENABLE) != PCI_COMMAND_MEM_ENABLE)
		return (0);
	if (type == PCI_MAPREG_TYPE_IO &&
	    (val & PCI_COMMAND_IO_ENABLE) != PCI_COMMAND_IO_ENABLE)
		return (0);

	error = extent_alloc_region(ex, *addr, size, EX_NOWAIT | EX_MALLOCOK);
	if (error) {
		PCIBIOS_PRINTV(("Resource conflict.\n"));
		pci_conf_write(pc, tag, mapreg, 0); /* clear */
		return (1);
	}

	return (0);
}

int
pciaddr_do_resource_reserve_disabled(struct pcibr_softc *sc,
    pci_chipset_tag_t pc, pcitag_t tag, int mapreg, struct extent *ex,
    int type, bus_addr_t *addr, bus_size_t size)
{
	pcireg_t val;
	int error;

	if (*addr == 0)
		return (0);

	val = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
	if (type == PCI_MAPREG_TYPE_MEM &&
	    (val & PCI_COMMAND_MEM_ENABLE) == PCI_COMMAND_MEM_ENABLE)
		return (0);
	if (type == PCI_MAPREG_TYPE_IO &&
	    (val & PCI_COMMAND_IO_ENABLE) == PCI_COMMAND_IO_ENABLE)
		return (0);

	error = extent_alloc_region(ex, *addr, size, EX_NOWAIT | EX_MALLOCOK);
	if (error) {
		PCIBIOS_PRINTV(("Resource conflict.\n"));
		pci_conf_write(pc, tag, mapreg, 0); /* clear */
		return (1);
	}

	return (0);
}

bus_addr_t
pciaddr_ioaddr(u_int32_t val)
{
	return ((PCI_MAPREG_TYPE(val) == PCI_MAPREG_TYPE_MEM)
		? PCI_MAPREG_MEM_ADDR(val)
		: (PCI_MAPREG_IO_ADDR(val) & PCIADDR_PORT_END));
}

void
pciaddr_print_devid(pci_chipset_tag_t pc, pcitag_t tag)
{
	int bus, device, function;	
	pcireg_t id;
	
	id = pci_conf_read(pc, tag, PCI_ID_REG);
	pci_decompose_tag(pc, tag, &bus, &device, &function);
	printf("%03d:%02d:%d %04x:%04x\n", bus, device, function, 
	       PCI_VENDOR(id), PCI_PRODUCT(id));
}

int
pciaddr_device_is_agp(pci_chipset_tag_t pc, pcitag_t tag)
{
	pcireg_t class, status, rval;
	int off;

	/* Check AGP device. */
	class = pci_conf_read(pc, tag, PCI_CLASS_REG);
	if (PCI_CLASS(class) == PCI_CLASS_DISPLAY) {
		status = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
		if (status & PCI_STATUS_CAPLIST_SUPPORT) {
			rval = pci_conf_read(pc, tag, PCI_CAPLISTPTR_REG);
			for (off = PCI_CAPLIST_PTR(rval);
			    off != 0;
			    off = PCI_CAPLIST_NEXT(rval) ) {
				rval = pci_conf_read(pc, tag, off);
				if (PCI_CAPLIST_CAP(rval) == PCI_CAP_AGP) 
					return (1);
			}
		}
	}
	return (0);
}


struct extent *
pciaddr_search(int mem_port, struct device *parent, bus_addr_t *startp,
    bus_size_t size)
{
	struct pcibr_softc *sc;

	/* find the bridge, 'mpcpcibr' */

	sc = NULL;
	while (parent != NULL) {
		if (strncmp("mpcpcibr", parent->dv_xname, 8) == 0) {
			sc = (void *)parent;
			break;
		}
		parent = parent->dv_parent;
	}

	if (sc && !(pcibr_flags & PCIBR_ADDR_FIXUP)) {
		struct extent_region *rp;
		struct extent *ex = mem_port? sc->extent_mem : sc->extent_port;

		/* Search the PCI I/O memory space extent for free
		 * space that will accommodate size.  Remember that the
		 * extent stores allocated space and we're searching
		 * for the gaps.
		 *
		 * If we're at the end or the gap between this region
		 * and the next region big enough, then we're done
		 */
		*startp = ex->ex_start;
		rp = LIST_FIRST(&ex->ex_regions);

		for (rp = LIST_FIRST(&ex->ex_regions);
		    rp && *startp + size > rp->er_start;
		    rp = LIST_NEXT(rp, er_link)) {
			bus_addr_t new_start;

			new_start = (rp->er_end - 1 + size) & ~(size - 1);
			if (new_start > *startp)
				*startp = new_start;
		}

		return (ex);
	}

	return (NULL);
}


void
pci_device_foreach(struct pcibr_softc *sc, pci_chipset_tag_t pc, int maxbus,
    void (*func)(struct pcibr_softc *, pci_chipset_tag_t, pcitag_t))
{
	const struct pci_quirkdata *qd;
	int bus, device, function, maxdevs, nfuncs;
	pcireg_t id, bhlcr;
	pcitag_t tag;

	for (bus = 0; bus <= maxbus; bus++) {
		maxdevs = pci_bus_maxdevs(pc, bus);
		for (device = 0; device < maxdevs; device++) {
			tag = pci_make_tag(pc, bus, device, 0);
			id = pci_conf_read(pc, tag, PCI_ID_REG);

			/* Invalid vendor ID value? */
			if (PCI_VENDOR(id) == PCI_VENDOR_INVALID)
				continue;
			/* XXX Not invalid, but we've done this ~forever. */
			if (PCI_VENDOR(id) == 0)
				continue;

			qd = pci_lookup_quirkdata(PCI_VENDOR(id),
			    PCI_PRODUCT(id));

			bhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);
			if (PCI_HDRTYPE_MULTIFN(bhlcr) ||
			    (qd != NULL &&
			     (qd->quirks & PCI_QUIRK_MULTIFUNCTION) != 0))
				nfuncs = 8;
			else
				nfuncs = 1;

			for (function = 0; function < nfuncs; function++) {
				tag = pci_make_tag(pc, bus, device, function);
				id = pci_conf_read(pc, tag, PCI_ID_REG);

				/* Invalid vendor ID value? */
				if (PCI_VENDOR(id) == PCI_VENDOR_INVALID)
					continue;
				/*
				 * XXX Not invalid, but we've done this
				 * ~forever.
				 */
				if (PCI_VENDOR(id) == 0)
					continue;
				(*func)(sc, pc, tag);
			}
		}
	}
}
@


1.11
log
@change pcibr_flags back to 0 (turn off verbose mode).  If anyone has a
problem with a new kernel in the next while, please revert this specific
commit and mail the results to kettenis, drahn, and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.10 2006/07/13 18:02:18 kettenis Exp $	*/
@


1.10
log
@Switch to a three-phase pci resource fixup:
1. Reserve resources for enabled devices.
2. Reserve resources for disabled devices.
3. Allocate resources.
This way we no longer need to enable/disable devices during fixup.
Based on an earlier patch by drahn@@.

ok deraadt@@, drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.9 2003/12/20 22:40:27 miod Exp $	*/
d80 1
a80 1
int pcibr_flags = 1;
@


1.9
log
@Pass -Wformat
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.8 2003/11/03 06:43:02 david Exp $	*/
d53 2
d58 3
d80 1
a80 1
int pcibr_flags = 0;
d113 1
a130 3
	if (sc->nbogus == 0)
		return; /* no need to fixup */

d147 11
a157 1
	pciaddr_resource_manage(sc, pc, tag, pciaddr_do_resource_reserve);	
d244 1
a244 11
    
	/* enable/disable PCI device */
	val = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);	
	if (error == 0)
		val |= (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
			PCI_COMMAND_MASTER_ENABLE);
	else
		val &= ~(PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE |
			 PCI_COMMAND_MASTER_ENABLE);
	pci_conf_write(pc, tag, PCI_COMMAND_STATUS_REG, val);
    
d303 1
d307 14
d322 23
@


1.8
log
@spelling fixes (in the comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.7 2003/10/15 23:00:57 drahn Exp $	*/
d286 1
a286 1
		printf("fixup failed. (new address=%#x)\n", *addr);
d290 1
a290 1
		printf("new address 0x%08x\n", *addr);
@


1.7
log
@Further down the ANSI/KNF road, only binary difference is __LINE__.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.6 2002/10/17 02:47:05 drahn Exp $	*/
d382 1
a382 1
		 * space that will accomodate size.  Remember that the
@


1.6
log
@Correct io space config after last patch. allows fxp to work
(with pending fxp BE diffs)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.5 2002/10/07 05:39:48 drahn Exp $	*/
d49 1
a49 1
void	pciaddr_resource_manage(struct pcibr_softc *,
d51 1
a51 1
void	pciaddr_resource_reserve(struct pcibr_softc *,
d53 1
a53 1
int	pciaddr_do_resource_reserve(struct pcibr_softc *,
d56 1
a56 1
void	pciaddr_resource_allocate(struct pcibr_softc *,
d58 1
a58 1
int	pciaddr_do_resource_allocate(struct pcibr_softc *,
d62 1
a62 1
void	pciaddr_print_devid(pci_chipset_tag_t, pcitag_t);
d64 1
a64 1
int	pciaddr_device_is_agp(pci_chipset_tag_t, pcitag_t);
d67 2
a68 2
	int maxbus,
	void (*func)(struct pcibr_softc *, pci_chipset_tag_t, pcitag_t));
d83 1
a83 4
pci_addr_fixup(sc, pc, maxbus)
	struct pcibr_softc *sc;
	pci_chipset_tag_t pc;
	int maxbus;
d139 2
a140 4
pciaddr_resource_reserve(sc, pc, tag)
	struct pcibr_softc *sc;
	pci_chipset_tag_t pc;
	pcitag_t tag;
d148 2
a149 4
pciaddr_resource_allocate(sc, pc, tag)
	struct pcibr_softc *sc;
	pci_chipset_tag_t pc;
	pcitag_t tag;
d157 2
a158 5
pciaddr_resource_manage(sc, pc, tag, func)
	struct pcibr_softc *sc;
	pci_chipset_tag_t pc;
	pcitag_t tag;
	pciaddr_resource_manage_func_t func;
d249 3
a251 8
pciaddr_do_resource_allocate(sc, pc, tag, mapreg, ex, type, addr, size)
	struct pcibr_softc *sc;
	pci_chipset_tag_t pc;
	pcitag_t tag;
	struct extent *ex;
	int mapreg, type;
	bus_addr_t *addr;
	bus_size_t size;
d279 1
a279 2
	if (pcibr_flags & PCIBR_VERBOSE)
	{
d296 3
a298 8
pciaddr_do_resource_reserve(sc, pc, tag, mapreg, ex, type, addr, size)
	struct pcibr_softc *sc;
	pci_chipset_tag_t pc;
	pcitag_t tag;
	struct extent *ex;
	int type, mapreg;
	bus_addr_t *addr;
	bus_size_t size;
d316 1
a316 2
pciaddr_ioaddr(val)
	u_int32_t val;
d324 1
a324 3
pciaddr_print_devid(pc, tag)
	pci_chipset_tag_t pc;
	pcitag_t tag;
d336 1
a336 3
pciaddr_device_is_agp(pc, tag)
	pci_chipset_tag_t pc;
	pcitag_t tag;
d361 2
a362 5
pciaddr_search(mem_port, parent, startp, size)
	int mem_port;
	struct device *parent;
	bus_addr_t *startp;
	bus_size_t size;
d410 2
a411 5
pci_device_foreach(sc, pc, maxbus, func)
	struct pcibr_softc *sc;
	pci_chipset_tag_t pc;
	int maxbus;
	void (*func)(struct pcibr_softc *, pci_chipset_tag_t, pcitag_t);
@


1.6.6.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
a49 1
void pciaddr_resource_manage(struct pcibr_softc *,
d51 1
a51 1
void pciaddr_resource_reserve(struct pcibr_softc *,
d53 1
a53 1
int pciaddr_do_resource_reserve(struct pcibr_softc *,
d56 1
a56 1
void pciaddr_resource_allocate(struct pcibr_softc *,
d58 1
a58 1
int pciaddr_do_resource_allocate(struct pcibr_softc *,
d62 1
a62 1
void pciaddr_print_devid(pci_chipset_tag_t, pcitag_t);
d64 1
a64 1
int pciaddr_device_is_agp(pci_chipset_tag_t, pcitag_t);
d67 2
a68 2
    int maxbus,
    void (*func)(struct pcibr_softc *, pci_chipset_tag_t, pcitag_t));
d83 4
a86 1
pci_addr_fixup(struct pcibr_softc *sc, pci_chipset_tag_t pc, int maxbus)
d142 4
a145 2
pciaddr_resource_reserve(struct pcibr_softc *sc, pci_chipset_tag_t pc,
    pcitag_t tag)
d153 4
a156 2
pciaddr_resource_allocate(struct pcibr_softc *sc, pci_chipset_tag_t pc,
    pcitag_t tag)
d164 5
a168 2
pciaddr_resource_manage(struct pcibr_softc *sc, pci_chipset_tag_t pc,
    pcitag_t tag, pciaddr_resource_manage_func_t func)
d259 8
a266 3
pciaddr_do_resource_allocate(struct pcibr_softc *sc, pci_chipset_tag_t pc,
    pcitag_t tag, int mapreg, struct extent *ex, int  type, bus_addr_t *addr,
    bus_size_t size)
d294 2
a295 1
	if (pcibr_flags & PCIBR_VERBOSE) {
d302 1
a302 1
		printf("fixup failed. (new address=%#lx)\n", *addr);
d306 1
a306 1
		printf("new address 0x%08lx\n", *addr);
d312 8
a319 3
pciaddr_do_resource_reserve(struct pcibr_softc *sc, pci_chipset_tag_t pc,
    pcitag_t tag, int mapreg, struct extent *ex, int type, bus_addr_t *addr,
    bus_size_t size)
d337 2
a338 1
pciaddr_ioaddr(u_int32_t val)
d346 3
a348 1
pciaddr_print_devid(pci_chipset_tag_t pc, pcitag_t tag)
d360 3
a362 1
pciaddr_device_is_agp(pci_chipset_tag_t pc, pcitag_t tag)
d387 5
a391 2
pciaddr_search(int mem_port, struct device *parent, bus_addr_t *startp,
    bus_size_t size)
d411 1
a411 1
		 * space that will accommodate size.  Remember that the
d439 5
a443 2
pci_device_foreach(struct pcibr_softc *sc, pci_chipset_tag_t pc, int maxbus,
    void (*func)(struct pcibr_softc *, pci_chipset_tag_t, pcitag_t))
@


1.6.2.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.5
log
@Improved workaround for cardbus support on macppc. This allows mappings to
be put in the cardbus register which really work instead of crashing the
machine.  if_dc @@cardbus now works, xl@@cardbus will configure, but does
not work properly (endian?) wdc should work fine, but has not been tested
recently.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.4 2002/09/23 04:24:58 drahn Exp $	*/
d279 1
a279 1
		: sc->sc_iobus_space.bus_base);
@


1.4
log
@Print pci_addr_fixup info when debugging is enabled, not disabled, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.3 2002/09/15 09:01:59 deraadt Exp $	*/
a101 4
#if 1
	    sc->sc_iobus_space.bus_base, 
	    sc->sc_iobus_space.bus_base + sc->sc_iobus_space.bus_size,
#else
a102 1
#endif
d226 1
a226 3
			addr = (PCI_MAPREG_IO_ADDR(val) & PCIADDR_PORT_END) |
			    sc->sc_iobus_space.bus_base, 

@


1.3
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.1 2002/07/23 17:53:25 drahn Exp $	*/
d301 1
a301 1
	if (!pcibr_flags & PCIBR_VERBOSE)
d312 1
a312 1
	if (!pcibr_flags & PCIBR_VERBOSE)
@


1.2
log
@KNF
@
text
@d88 1
a88 1
	const char *verbose_header =
d93 1
a93 1
	const char *verbose_footer =
d97 1
a97 1
	    sc->sc_membus_space.bus_base,
d103 1
a103 1
	    sc->sc_iobus_space.bus_base,
d111 1
a111 1
	/*
a120 1

d122 2
a123 2
		    rp; rp = LIST_NEXT(rp, er_link))
			;
a127 1

d129 2
a130 2
		    rp; rp = LIST_NEXT(rp, er_link))
			;
d136 2
a137 2
	/*
	 * 4. do fixup
d154 1
a154 1
	pciaddr_resource_manage(sc, pc, tag, pciaddr_do_resource_reserve);
d187 1
a187 1
	case 0:
d201 1
a201 1

d209 1
a209 1

d213 1
a213 1
			if (PCI_MAPREG_MEM_TYPE(val) ==
d216 4
a219 4
				 * XXX of the BAR here, but we are totally
				 * XXX unprepared to handle a non-zero value,
				 * XXX either here or anywhere else in
				 * XXX i386-land.
d222 1
a222 1
				 * XXX it as a 32-bit BAR set to zero.
d224 1
a224 1
				width = 8;
d232 1
a232 1
			    sc->sc_iobus_space.bus_base,
d237 1
a237 1

d244 3
a246 3
		PCIBIOS_PRINTV(("\t%02xh %s 0x%08x 0x%08x\n",
		    mapreg, type ? "port" : "mem ",
		    (unsigned int)addr, (unsigned int)size));
d248 1
a248 1

d250 1
a250 1
	val = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);
d253 1
a253 1
		    PCI_COMMAND_MASTER_ENABLE);
d256 1
a256 1
		     PCI_COMMAND_MASTER_ENABLE);
d258 1
a258 1

d277 1
a277 1

d282 1
a282 1
	if (pciaddr_device_is_agp(pc, tag))
d284 1
a284 1

d301 2
a302 1
	if (!pcibr_flags & PCIBR_VERBOSE) {
d357 1
a357 1
	int bus, device, function;
d359 1
a359 1

d362 2
a363 2
	printf("%03d:%02d:%d %04x:%04x\n", bus, device, function,
	    PCI_VENDOR(id), PCI_PRODUCT(id));
d384 1
a384 1
				if (PCI_CAPLIST_CAP(rval) == PCI_CAP_AGP)
d476 1
a476 1
			    (qd->quirks & PCI_QUIRK_MULTIFUNCTION) != 0))
@


1.1
log
@Cardbus/pcmcia support for macppc. parts borrowed from NetBSD, and other
portions of the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_addr_fixup.c,v 1.13 2002/03/14 01:26:33 millert Exp $	*/
d88 1
a88 1
	const char *verbose_header = 
d93 1
a93 1
	const char *verbose_footer = 
d97 1
a97 1
	    sc->sc_membus_space.bus_base, 
d103 1
a103 1
	    sc->sc_iobus_space.bus_base, 
d111 1
a111 1
	/* 
d121 1
d123 2
a124 2
		    rp; rp = LIST_NEXT(rp, er_link)) {
		}
d129 1
d131 2
a132 2
		    rp; rp = LIST_NEXT(rp, er_link)) {
		}
d138 2
a139 2
	/* 
	 * 4. do fixup 
d156 1
a156 1
	pciaddr_resource_manage(sc, pc, tag, pciaddr_do_resource_reserve);	
d189 1
a189 1
	case 0: 
d203 1
a203 1
    
d211 1
a211 1
	
d215 1
a215 1
			if (PCI_MAPREG_MEM_TYPE(val) == 
d218 4
a221 4
				 * XXX of the BAR here, but we are totally 
				 * XXX unprepared to handle a non-zero value, 
				 * XXX either here or anywhere else in 
				 * XXX i386-land. 
d224 1
a224 1
				 * XXX it as a 32-bit BAR set to zero. 
d226 1
a226 1
			    width = 8;
d234 1
a234 1
			    sc->sc_iobus_space.bus_base, 
d239 1
a239 1
	
d246 3
a248 3
		PCIBIOS_PRINTV(("\t%02xh %s 0x%08x 0x%08x\n", 
				mapreg, type ? "port" : "mem ", 
				(unsigned int)addr, (unsigned int)size));
d250 1
a250 1
    
d252 1
a252 1
	val = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);	
d255 1
a255 1
			PCI_COMMAND_MASTER_ENABLE);
d258 1
a258 1
			 PCI_COMMAND_MASTER_ENABLE);
d260 1
a260 1
    
d279 1
a279 1
	
d284 1
a284 1
	if (pciaddr_device_is_agp(pc, tag)) 
d286 1
a286 1
	
d303 1
a303 2
	if (!pcibr_flags & PCIBR_VERBOSE)
	{
d358 1
a358 1
	int bus, device, function;	
d360 1
a360 1
	
d363 2
a364 2
	printf("%03d:%02d:%d %04x:%04x\n", bus, device, function, 
	       PCI_VENDOR(id), PCI_PRODUCT(id));
d385 1
a385 1
				if (PCI_CAPLIST_CAP(rval) == PCI_CAP_AGP) 
d477 1
a477 1
			     (qd->quirks & PCI_QUIRK_MULTIFUNCTION) != 0))
@

