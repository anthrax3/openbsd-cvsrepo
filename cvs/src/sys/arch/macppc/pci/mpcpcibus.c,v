head	1.47;
access;
symbols
	OPENBSD_6_2:1.47.0.8
	OPENBSD_6_2_BASE:1.47
	OPENBSD_6_1:1.47.0.10
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.47.0.6
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.47.0.4
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.46.0.6
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.46.0.4
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.45.0.4
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.45.0.2
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.43.0.4
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.2
	OPENBSD_5_0:1.42.0.4
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.40.0.4
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.39.0.4
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.37.0.4
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.37.0.2
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.36.0.6
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.36.0.4
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.23.0.6
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.16
	UBC:1.4.0.2
	UBC_BASE:1.4
	SMP:1.2.0.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.47
date	2015.06.03.08.41.43;	author mpi;	state Exp;
branches;
next	1.46;
commitid	2v3lHP0TBbUl8vi4;

1.46
date	2013.08.07.07.29.19;	author mpi;	state Exp;
branches;
next	1.45;

1.45
date	2013.01.21.15.06.29;	author mpi;	state Exp;
branches;
next	1.44;

1.44
date	2013.01.21.14.24.17;	author mpi;	state Exp;
branches;
next	1.43;

1.43
date	2011.10.28.15.17.02;	author drahn;	state Exp;
branches;
next	1.42;

1.42
date	2011.01.08.18.10.23;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2010.12.04.17.06.31;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.39;

1.39
date	2009.05.03.21.30.09;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2009.03.29.22.58.31;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2008.03.25.22.38.28;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2006.12.14.17.36.12;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2006.12.05.20.48.23;	author gwk;	state Exp;
branches;
next	1.34;

1.34
date	2006.10.27.10.42.39;	author gwk;	state Exp;
branches;
next	1.33;

1.33
date	2006.10.23.02.05.26;	author gwk;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.10.00.07.40;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.13.20.10.49;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2006.02.11.05.21.40;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2006.02.03.10.21.18;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.16.21.39.42;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.07.02.19.46;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.08.23.38.30;	author drahn;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.03.02.22.38;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2005.06.08.19.08.23;	author drahn;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.20.22.40.27;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.21.17.18.14;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.15.23.00.57;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.09.16.34.21;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.07.22.33.30;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.26.21.54.44;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.18.13.14.43;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2002.10.12.01.09.43;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2002.10.07.05.39.48;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.15.09.01.59;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.06.13.44.03;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.23.17.53.25;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.22.21.39.58;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.03.15.56;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.02.17.44.58;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.26.20.52.59;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.21.19.52.00;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.14.14.48.55;	author drahn;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.21.02.11.58;	author miod;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2001.09.01.15.55.17;	author drahn;	state Exp;
branches;
next	;

1.2.4.1
date	2001.10.31.03.01.16;	author nate;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2002.03.06.01.06.11;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.2.4.6;

1.2.4.6
date	2003.05.13.19.41.05;	author ho;	state Exp;
branches;
next	1.2.4.7;

1.2.4.7
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2002.01.31.22.55.14;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Support for U4, missed in previous.

ok kettenis@@, miod@@, dlg@@
@
text
@/*	$OpenBSD: mpcpcibus.c,v 1.46 2013/08/07 07:29:19 mpi Exp $ */

/*
 * Copyright (c) 1997 Per Fogelstrom
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/extent.h>

#include <machine/autoconf.h>
#include <machine/pcb.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/ofw/openfirm.h>

int	mpcpcibrmatch(struct device *, void *, void *);
void	mpcpcibrattach(struct device *, struct device *, void *);

pcireg_t mpc_conf_read(void *, pcitag_t, int);
void	mpc_conf_write(void *, pcitag_t, int, pcireg_t);

u_int32_t mpc_gen_config_reg(void *cpv, pcitag_t tag, int offset);

struct pcibr_config {
	bus_space_tag_t		lc_memt;
	bus_space_tag_t		lc_iot;
	bus_space_handle_t	ioh_cf8;
	bus_space_handle_t	ioh_cfc;
	struct ppc_pci_chipset	lc_pc;
	int			config_type;
};

struct pcibr_softc {
	struct device		sc_dev;
	struct ppc_bus_space	sc_membus_space;
	struct ppc_bus_space	sc_iobus_space;
	struct pcibr_config	pcibr_config;
	struct extent 		*sc_ioex;
	struct extent		*sc_memex;
	char			sc_ioex_name[32];
	char			sc_memex_name[32];
};

struct cfattach mpcpcibr_ca = {
        sizeof(struct pcibr_softc), mpcpcibrmatch, mpcpcibrattach,
};

struct cfdriver mpcpcibr_cd = {
	NULL, "mpcpcibr", DV_DULL,
};

static int      mpcpcibrprint(void *, const char *pnp);

void	mpcpcibus_find_ranges_32(struct pcibr_softc *, u_int32_t *, int);
void	mpcpcibus_find_ranges_64(struct pcibr_softc *, u_int32_t *, int);

/*
 * config types
 * bit meanings
 * 0 - standard cf8/cfc type configurations,
 *     sometimes the base addresses for these are different
 * 1 - Config Method #2 configuration - uni-north
 *
 * 2 - 64 bit config bus, data for accesses &4 is at daddr+4;
 */
struct config_type{
	char * compat;
	u_int32_t addr;	/* offset */
	u_int32_t data;	/* offset */
	int config_type;
};
struct config_type config_offsets[] = {
	{"grackle",		0x00c00cf8, 0x00e00cfc, 0 },
	{"bandit",		0x00800000, 0x00c00000, 1 },
	{"uni-north",		0x00800000, 0x00c00000, 3 },
	{"u3-agp",		0x00800000, 0x00c00000, 3 },
	{"u3-ht",		0x00000cf8, 0x00000cfc, 3 },
	{"u4-pcie",		0x00800000, 0x00c00000, 7 },
	{"legacy",		0x00000cf8, 0x00000cfc, 0 },
	{"IBM,27-82660",	0x00000cf8, 0x00000cfc, 0 },
	{NULL,			0x00000000, 0x00000000, 0 },
};

int
mpcpcibrmatch(struct device *parent, void *match, void *aux)
{
	struct confargs *ca = aux;
	int found = 0;

	if (strcmp(ca->ca_name, mpcpcibr_cd.cd_name) != 0)
		return (found);

	found = 1;

	return found;
}

struct ranges_32 {
	u_int32_t cspace;
	u_int32_t child_hi;
	u_int32_t child_lo;
	u_int32_t phys;
	u_int32_t size_hi;
	u_int32_t size_lo;
};

void
mpcpcibus_find_ranges_32(struct pcibr_softc *sc, u_int32_t *range_store,
    int rangesize)
{
	int i, found;
	unsigned int base = 0;
	unsigned int size = 0;
	struct ranges_32 *prange = (void *)range_store;
	int rangelen;

	rangelen = rangesize / sizeof(struct ranges_32);

	/* mac configs */
	sc->sc_membus_space.bus_base = 0;
	sc->sc_membus_space.bus_io = 0;
	sc->sc_iobus_space.bus_base = 0;
	sc->sc_iobus_space.bus_io = 1;

	/* find io(config) base, flag == 0x01000000 */
	found = 0;
	for (i = 0; i < rangelen; i++) {
		if (prange[i].cspace == 0x01000000) {
			/* find last? */
			found = i;

			if (sc->sc_ioex)
				extent_free(sc->sc_ioex, prange[i].child_lo,
				    prange[i].size_lo, EX_NOWAIT);
		}
	}
	/* found the io space ranges */
	if (prange[found].cspace == 0x01000000) {
		sc->sc_iobus_space.bus_base = prange[found].phys;
		sc->sc_iobus_space.bus_size = prange[found].size_lo;
	}

	/* the mem space ranges 
	 * apple openfirmware always puts full
	 * addresses in config information,
	 * it is not necessary to have correct bus
	 * base address, but since 0 is reserved
	 * and all IO and device memory will be in
	 * upper 2G of address space, set to
	 * 0x80000000
	 */
	for (i = 0; i < rangelen; i++) {
		if (prange[i].cspace == 0x02000000) {
#ifdef DEBUG_PCI
			printf("\nfound mem %x %x",
				prange[i].phys,
				prange[i].size_lo);
#endif
			if (base != 0) {
				if ((base + size) == prange[i].phys)   
					size += prange[i].size_lo;
				else {
					base = prange[i].phys;
					size = prange[i].size_lo;
				} 
			} else {
				base = prange[i].phys;
				size = prange[i].size_lo;
			}

			if (sc->sc_memex)
				extent_free(sc->sc_memex, prange[i].child_lo,
				    prange[i].size_lo, EX_NOWAIT);
		}
	}
	sc->sc_membus_space.bus_base = base;
	sc->sc_membus_space.bus_size = size;
}

struct ranges_64 {
	u_int32_t cspace;
	u_int32_t child_hi;
	u_int32_t child_lo;
	u_int32_t phys_hi;
	u_int32_t phys_lo;
	u_int32_t size_hi;
	u_int32_t size_lo;
};

void
mpcpcibus_find_ranges_64(struct pcibr_softc *sc, u_int32_t *range_store,
    int rangesize)
{
	int i, found;
	unsigned int base = 0;
	unsigned int size = 0;
	struct ranges_64 *prange = (void *)range_store;
	int rangelen;

	rangelen = rangesize / sizeof(struct ranges_64);

	/* mac configs */
	sc->sc_membus_space.bus_base = 0;
	sc->sc_membus_space.bus_io = 0;
	sc->sc_iobus_space.bus_base = 0;
	sc->sc_iobus_space.bus_io = 1;

	if (prange[0].cspace == 0xabb10113) { /* appl U3; */
		prange[0].cspace = 0x01000000;
		prange[0].child_lo = 0x00000000;
		prange[0].phys_lo = 0xf8070000;
		prange[0].size_lo = 0x00001000;
		prange[1].cspace = 0x02000000;
		prange[1].child_lo = 0xf2000000;
		prange[1].phys_lo = 0xf2000000;
		prange[1].size_lo = 0x02800000;
		rangelen = 2;
	}

	/* find io(config) base, flag == 0x01000000 */
	found = 0;
	for (i = 0; i < rangelen; i++) {
		if (prange[i].cspace == 0x01000000) {
			/* find last? */
			found = i;

			if (sc->sc_ioex)
				extent_free(sc->sc_ioex, prange[i].child_lo,
				    prange[i].size_lo, EX_NOWAIT);
		}
	}
	/* found the io space ranges */
	if (prange[found].cspace == 0x01000000) {
		sc->sc_iobus_space.bus_base = prange[found].phys_lo;
		sc->sc_iobus_space.bus_size = prange[found].size_lo;
	}

	/* the mem space ranges 
	 * apple openfirmware always puts full
	 * addresses in config information,
	 * it is not necessary to have correct bus
	 * base address, but since 0 is reserved
	 * and all IO and device memory will be in
	 * upper 2G of address space, set to
	 * 0x80000000
	 */
	for (i = 0; i < rangelen; i++) {
		if (prange[i].cspace == 0x02000000) {
#ifdef DEBUG_PCI
			printf("\nfound mem %x %x",
				prange[i].phys_lo,
				prange[i].size_lo);
#endif
			if (base != 0) {
				if ((base + size) == prange[i].phys_lo) {
					size += prange[i].size_lo;
				} else {
					base = prange[i].phys_lo;
					size = prange[i].size_lo;
				}
			} else {
				base = prange[i].phys_lo;
				size = prange[i].size_lo;
			}

			if (sc->sc_memex)
				extent_free(sc->sc_memex, prange[i].child_lo,
				    prange[i].size_lo, EX_NOWAIT);
		}
	}
	sc->sc_membus_space.bus_base = base;
	sc->sc_membus_space.bus_size = size;
}

void
mpcpcibrattach(struct device *parent, struct device *self, void *aux)
{
	struct pcibr_softc *sc = (struct pcibr_softc *)self;
	struct confargs *ca = aux;
	struct pcibr_config *lcp;
	struct pcibus_attach_args pba;
	int of_node = 0;
	char compat[32];
	u_int32_t addr_offset;
	u_int32_t data_offset;
	int i;
	int len;
	int rangesize;
	u_int32_t range_store[32];

	if (ca->ca_node == 0) {
		printf("invalid node on mpcpcibr config\n");
		return;
	}
	len=OF_getprop(ca->ca_node, "name", compat, sizeof (compat));
	compat[len] = '\0';
	if (len > 0)
		printf(" %s", compat);

	len=OF_getprop(ca->ca_node, "compatible", compat,
	    sizeof (compat));
	if (len <= 0 ) {
		len=OF_getprop(ca->ca_node, "name", compat,
			sizeof (compat));
		if (len <= 0) {
			printf(" compatible and name not found\n");
			return;
		}
		compat[len] = 0; 
		if (strcmp (compat, "bandit") != 0) {
			printf(" compatible not found and name %s found\n",
			    compat);
			return;
		}
	}
	compat[len] = 0; 
	if ((rangesize = OF_getprop(ca->ca_node, "ranges",
	    range_store, sizeof (range_store))) <= 0) {
		if (strcmp(compat, "u3-ht") == 0) {
			range_store[0] = 0xabb10113; /* appl U3; */
		} else 
			printf("range lookup failed, node %x\n", ca->ca_node);
	}
	/* translate byte(s) into item count*/

	lcp = &sc->pcibr_config;

	snprintf(sc->sc_ioex_name, sizeof(sc->sc_ioex_name),
	    "%s pciio", sc->sc_dev.dv_xname);
	sc->sc_ioex = extent_create(sc->sc_ioex_name, 0x00000000, 0xffffffff,
	    M_DEVBUF, NULL, 0, EX_NOWAIT | EX_FILLED);
	snprintf(sc->sc_memex_name, sizeof(sc->sc_memex_name),
	    "%s pcimem", sc->sc_dev.dv_xname);
	sc->sc_memex = extent_create(sc->sc_memex_name, 0x00000000, 0xffffffff,
	    M_DEVBUF, NULL, 0, EX_NOWAIT | EX_FILLED);

	if (ppc_proc_is_64b)
		mpcpcibus_find_ranges_64 (sc, range_store, rangesize);
	else
		mpcpcibus_find_ranges_32 (sc, range_store, rangesize);

	addr_offset = 0;
	for (i = 0; config_offsets[i].compat != NULL; i++) {
		struct config_type *co = &config_offsets[i];
		if (strcmp(co->compat, compat) == 0) {
			addr_offset = co->addr; 
			data_offset = co->data; 
			lcp->config_type = co->config_type;
			break;
		}
	}
	if (addr_offset == 0) {
		printf("unable to find match for"
		    " compatible %s\n", compat);
		return;
	}
#ifdef DEBUG_FIXUP
	printf(" mem base %x sz %x io base %x sz %x\n"
	    " config addr %x config data %x\n",
	    sc->sc_membus_space.bus_base,
	    sc->sc_membus_space.bus_size,
	    sc->sc_iobus_space.bus_base,
	    sc->sc_iobus_space.bus_size,
	    addr_offset, data_offset);
#endif

	if ( bus_space_map(&(sc->sc_iobus_space), addr_offset,
		NBPG, 0, &lcp->ioh_cf8) != 0 )
		panic("mpcpcibus: unable to map self");

	if ( bus_space_map(&(sc->sc_iobus_space), data_offset,
		NBPG, 0, &lcp->ioh_cfc) != 0 )
		panic("mpcpcibus: unable to map self");

	of_node = ca->ca_node;

	lcp->lc_pc.pc_conf_v = lcp;
	lcp->lc_pc.pc_node = ca->ca_node;
	lcp->lc_pc.pc_conf_read = mpc_conf_read;
	lcp->lc_pc.pc_conf_write = mpc_conf_write;
	lcp->lc_iot = &sc->sc_iobus_space;
	lcp->lc_memt = &sc->sc_membus_space;

	printf(": %s\n", compat);

	bzero(&pba, sizeof(pba));
	pba.pba_dmat = &pci_bus_dma_tag;

	pba.pba_busname = "pci";
	pba.pba_iot = &sc->sc_iobus_space;
	pba.pba_memt = &sc->sc_membus_space;
	pba.pba_ioex = sc->sc_ioex;
	pba.pba_memex = sc->sc_memex;
	pba.pba_pc = &lcp->lc_pc;
	pba.pba_domain = pci_ndomains++;
	pba.pba_bus = 0;

	config_found(self, &pba, mpcpcibrprint);
}

static int
mpcpcibrprint(void *aux, const char *pnp)
{
	struct pcibus_attach_args *pba = aux;

	if (pnp)
		printf("%s at %s", pba->pba_busname, pnp);
	printf(" bus %d", pba->pba_bus);
	return(UNCONF);
}

u_int32_t
mpc_gen_config_reg(void *cpv, pcitag_t tag, int offset)
{
	struct pcibr_config *cp = cpv;
	unsigned int bus, dev, fcn;
	u_int32_t reg, val = PCITAG_OFFSET(tag);

	pci_decompose_tag(cpv, tag, &bus, &dev, &fcn);

	if (cp->config_type & 4) {
		reg = val | offset | 1;
		reg |= (offset >> 8) << 28;
	} else if (cp->config_type & 1) {
		/* Config Mechanism #2 */
		if (bus == 0) {
			if (dev < 11)
				return 0xffffffff;
			/*
			 * Need to do config type 0 operation
			 *  1 << (11?+dev) | fcn << 8 | reg
			 * 11? is because pci spec states
			 * that 11-15 is reserved.
			 */
			reg = 1 << (dev) | fcn << 8 | offset;
		} else {
			if (dev > 15)
				return 0xffffffff;
			/*
			 * config type 1 
			 */
			reg = val | offset | 1;
		}
	} else {
		/* config mechanism #2, type 0
		 * standard cf8/cfc config
		 */
		reg =  0x80000000 | val | offset;
	}

	return reg;
}

/* #define DEBUG_CONFIG  */
pcireg_t
mpc_conf_read(void *cpv, pcitag_t tag, int offset)
{
	struct pcibr_config *cp = cpv;
	pcireg_t data;
	u_int32_t reg;
	int s;
	int daddr = 0;
	faultbuf env;
	void *oldh;

	if (offset & 3 ||
	    offset < 0 || offset >= PCI_CONFIG_SPACE_SIZE) {
#ifdef DEBUG_CONFIG 
		printf ("pci_conf_read: bad reg %x\n", offset);
#endif /* DEBUG_CONFIG */
		return(~0);
	}

	reg = mpc_gen_config_reg(cpv, tag, offset);
	/* if invalid tag, return -1 */
	if (reg == 0xffffffff)
		return(~0);

	if ((cp->config_type & 2) && (offset & 0x04))
		daddr += 4;

	s = splhigh();

	oldh = curpcb->pcb_onfault;
	if (setfault(&env)) {
		/* we faulted during the read? */
		curpcb->pcb_onfault = oldh;
		splx(s);
		return 0xffffffff;
	}

	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, reg);
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
	data = bus_space_read_4(cp->lc_iot, cp->ioh_cfc, daddr);
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, 0); /* disable */
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */

	curpcb->pcb_onfault = oldh;

	splx(s);
#ifdef DEBUG_CONFIG
	if (!((offset == 0) && (data == 0xffffffff))) {
		unsigned int bus, dev, fcn;
		pci_decompose_tag(cpv, tag, &bus, &dev, &fcn);
		printf("mpc_conf_read bus %x dev %x fcn %x offset %x", bus, dev, fcn,
			offset);
		printf(" daddr %x reg %x",daddr, reg);
		printf(" data %x\n", data);
	}
#endif

	return(data);
}

void
mpc_conf_write(void *cpv, pcitag_t tag, int offset, pcireg_t data)
{
	struct pcibr_config *cp = cpv;
	u_int32_t reg;
	int s;
	int daddr = 0;

	reg = mpc_gen_config_reg(cpv, tag, offset);

	/* if invalid tag, return ??? */
	if (reg == 0xffffffff)
		return;

	if ((cp->config_type & 2) && (offset & 0x04))
		daddr += 4;

#ifdef DEBUG_CONFIG
	{
		unsigned int bus, dev, fcn;
		pci_decompose_tag(cpv, tag, &bus, &dev, &fcn);
		printf("mpc_conf_write bus %x dev %x fcn %x offset %x", bus,
			dev, fcn, offset);
		printf(" daddr %x reg %x",daddr, reg);
		printf(" data %x\n", data);
	}
#endif

	s = splhigh();

	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, reg);
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */
	bus_space_write_4(cp->lc_iot, cp->ioh_cfc, daddr, data);
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, 0); /* disable */
	bus_space_read_4(cp->lc_iot, cp->ioh_cf8, 0); /* XXX */

	splx(s);
}
@


1.46
log
@Mimic what's done on sparc64 and parse the OpenFirmware device tree to
enumerate the pci devices.  This allow us to not store the interrupt
vector in the interrupt line register and to not try to attach pci
devices disabled by firmware.

With inputs from and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.45 2013/01/21 15:06:29 mpi Exp $ */
d106 1
d449 4
a452 1
	if (cp->config_type & 1) {
@


1.45
log
@Only the mpcpcibus driver is actually using these structures so merge them
in the appropriate .c file and remove unused fields while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.44 2013/01/21 14:24:17 mpi Exp $ */
a28 5
/*
 * Generic PCI BUS Bridge driver.
 * specialized hooks for different config methods.
 */

a46 6
void	mpc_attach_hook(struct device *, struct device *,
				struct pcibus_attach_args *);
int	mpc_bus_maxdevs(void *, int);
pcitag_t mpc_make_tag(void *, int, int, int);
void	mpc_decompose_tag(void *, pcitag_t, int *, int *, int *);
int	mpc_conf_size(void *, pcitag_t);
a49 7
int      mpc_intr_map(void *, pcitag_t, int, int, pci_intr_handle_t *);
const char *mpc_intr_string(void *, pci_intr_handle_t);
int	mpc_intr_line(void *, pci_intr_handle_t);
void     *mpc_intr_establish(void *, pci_intr_handle_t,
            int, int (*func)(void *), void *, const char *);
void     mpc_intr_disestablish(void *, void *);
int      mpc_ether_hw_addr(struct ppc_pci_chipset *, u_int8_t *);
a50 4
int	of_ether_hw_addr(struct ppc_pci_chipset *, u_int8_t *);
int	find_node_intr (int parent, u_int32_t *addr, u_int32_t *intr);

void fix_node_irq(int node, struct pcibus_attach_args *pba);
a58 2
	int			bus;
	int			node;
a110 17
struct powerpc_bus_dma_tag pci_bus_dma_tag = {
	NULL,
	_dmamap_create,
	_dmamap_destroy,
	_dmamap_load,
	_dmamap_load_mbuf,
	_dmamap_load_uio,
	_dmamap_load_raw,
	_dmamap_unload,
	_dmamap_sync,
	_dmamem_alloc,
	_dmamem_free,
	_dmamem_map,
	_dmamem_unmap,
	_dmamem_mmap
};

a280 1
				
a308 1
	int node;
a403 1
	lcp->node = ca->ca_node;
d405 1
a405 5
	lcp->lc_pc.pc_attach_hook = mpc_attach_hook;
	lcp->lc_pc.pc_bus_maxdevs = mpc_bus_maxdevs;
	lcp->lc_pc.pc_make_tag = mpc_make_tag;
	lcp->lc_pc.pc_decompose_tag = mpc_decompose_tag;
	lcp->lc_pc.pc_conf_size = mpc_conf_size;
a407 1
	lcp->lc_pc.pc_ether_hw_addr = of_ether_hw_addr;
a410 7
	lcp->lc_pc.pc_intr_v = lcp;
	lcp->lc_pc.pc_intr_map = mpc_intr_map;
	lcp->lc_pc.pc_intr_string = mpc_intr_string;
	lcp->lc_pc.pc_intr_line = mpc_intr_line;
	lcp->lc_pc.pc_intr_establish = mpc_intr_establish;
	lcp->lc_pc.pc_intr_disestablish = mpc_intr_disestablish;

a424 26
	/* we want to check pci irq settings */
	if (of_node != 0) {
		int nn;

		for (node = OF_child(of_node); node; node = nn) {
			char name[32];
			int len;
			len = OF_getprop(node, "name", name,
			    sizeof(name));
			name[len] = 0;
			fix_node_irq(node, &pba);

			/* iterate section */
			if ((nn = OF_child(node)) != 0)
				continue;

			while ((nn = OF_peer(node)) == 0) {
				node = OF_parent(node);
				if (node == of_node) {
					nn = 0; /* done */
					break;
				}
			}
		}
	}

a425 145

}
                 
#define       OFW_PCI_PHYS_HI_BUSMASK         0x00ff0000
#define       OFW_PCI_PHYS_HI_BUSSHIFT        16
#define       OFW_PCI_PHYS_HI_DEVICEMASK      0x0000f800
#define       OFW_PCI_PHYS_HI_DEVICESHIFT     11
#define       OFW_PCI_PHYS_HI_FUNCTIONMASK    0x00000700
#define       OFW_PCI_PHYS_HI_FUNCTIONSHIFT   8

#define pcibus(x) \
	(((x) & OFW_PCI_PHYS_HI_BUSMASK) >> OFW_PCI_PHYS_HI_BUSSHIFT)
#define pcidev(x) \
	(((x) & OFW_PCI_PHYS_HI_DEVICEMASK) >> OFW_PCI_PHYS_HI_DEVICESHIFT)
#define pcifunc(x) \
	(((x) & OFW_PCI_PHYS_HI_FUNCTIONMASK) >> OFW_PCI_PHYS_HI_FUNCTIONSHIFT)

/* 
 * Find PCI IRQ from OF.
 */
int
find_node_intr(int parent, u_int32_t *addr, u_int32_t *intr)
{
	int iparent, len, mlen, alen, ilen;
	int match, i, step;
	u_int32_t map[144], *mp, *mp1;
	u_int32_t cpu_imask[8], maskedaddr[8];
	u_int32_t address_cells, interrupt_cells, mask_cells;

	len = OF_getprop(parent, "interrupt-map", map, sizeof(map));
	mlen = OF_getprop(parent, "interrupt-map-mask", cpu_imask, sizeof(cpu_imask));
	alen = OF_getprop(parent, "#address-cells",
	    &address_cells, sizeof(address_cells));
	ilen = OF_getprop(parent, "#interrupt-cells",
	    &interrupt_cells, sizeof(interrupt_cells));

	if (len == -1 || mlen == -1 || alen == -1 || ilen == -1)
		goto nomap;

	mask_cells = address_cells + interrupt_cells;
	if (mask_cells != (mlen / sizeof(u_int32_t)))
		goto nomap;
	for (i = 0; i < mask_cells; i++)
		maskedaddr[i] = addr[i] & cpu_imask[i];

	/* interrupt-map is formatted as follows
	 * int * #address-cells, int * #interrupt-cells, int, int, int
	 * eg
	 * address-cells = 3
	 * interrupt-cells = 1
	 * 00001000 00000000 00000000 00000000 ff911258 00000034 00000001 
	 * 00001800 00000000 00000000 00000000 ff911258 00000035 00000001 
	 * 00002000 00000000 00000000 00000000 ff911258 00000036 00000001 
	 * | address cells          | | intr | |parent| | irq  | |edge/level|
	 *                            | cells|          | interrupt cells   |
	 *                                              | of parent         |
	 * or at least something close to that.
	 */

	mp = map;
	while (len > mlen) {
		mp1 = mp + mask_cells;

		iparent = *mp1;
		alen = OF_getprop(iparent, "#address-cells",
		    &address_cells, sizeof(address_cells));
		if (alen == -1)
			address_cells = 0;
		ilen = OF_getprop(iparent, "#interrupt-cells",
		    &interrupt_cells, sizeof(interrupt_cells));
		if (ilen == -1)
			goto nomap;

		step = mask_cells + 1 + address_cells + interrupt_cells;

		match = bcmp(maskedaddr, mp, mlen);
		if (match == 0) {
			if (OF_getprop(iparent, "interrupt-controller",
				       NULL, 0) == 0) {
				*intr = mp1[1];
				return 1;
			}
			/* Recurse with new 'addr'. */
			return find_node_intr(iparent, &mp1[1], intr);
		}
		len -= step * sizeof(u_int32_t);
		mp += step;
	}
nomap:
	return -1;
}

void
fix_node_irq(int node, struct pcibus_attach_args *pba)
{
	struct { 
		u_int32_t phys_hi, phys_mid, phys_lo;
		u_int32_t size_hi, size_lo;
	} addr [8];
	u_int32_t map[144];
	int len;
	pcitag_t tag;
	u_int32_t irq;
	u_int32_t intr;
	int parent;

	pci_chipset_tag_t pc = pba->pba_pc;

	len = OF_getprop(node, "assigned-addresses", addr, sizeof(addr));
	if (len == -1 || len < sizeof(addr[0]))
		return;

	/* if this node has a AAPL,interrupts property, firmware
	 * has initialized the register correctly.
	 */
	len = OF_getprop(node, "AAPL,interrupts", &intr, 4);
	if (len != 4) {

		parent = OF_parent(node);

		irq = -1;

		/* we want the first interrupt, set size_hi to 1 */
		addr[0].size_hi = 1;
		if (find_node_intr(parent, &addr[0].phys_hi, &irq) == -1) {
			len = OF_getprop(node, "interrupts", map,
			    sizeof(map));
			if (len != -1 && len != 4) {
				irq = map[0];
			} else 
				return;
		}
	} else
		irq = intr;
	/* program the interrupt line register with the value
	 * found in openfirmware
	 */

	tag = pci_make_tag(pc, pcibus(addr[0].phys_hi),
	    pcidev(addr[0].phys_hi), pcifunc(addr[0].phys_hi));

	intr = pci_conf_read(pc, tag, PCI_INTERRUPT_REG);
	intr &= ~PCI_INTERRUPT_LINE_MASK;
	intr |= irq & PCI_INTERRUPT_LINE_MASK;
	pci_conf_write(pc, tag, PCI_INTERRUPT_REG, intr);
a438 78
void
mpc_attach_hook(struct device *parent, struct device *self,
    struct pcibus_attach_args *pba)
{
}

int
of_ether_hw_addr(struct ppc_pci_chipset *lcpc, u_int8_t *oaddr)
{
	u_int8_t laddr[6];
	struct pcibr_config *lcp = lcpc->pc_conf_v;
	int of_node = lcp->node;
	int node, nn;
	for (node = OF_child(of_node); node; node = nn) {
		char name[32];
		int len;
		len = OF_getprop(node, "name", name,
			sizeof(name));
		name[len] = 0;

		len = OF_getprop(node, "local-mac-address", laddr,
		    sizeof laddr);
		if (sizeof (laddr) == len) {
			bcopy (laddr, oaddr, sizeof laddr);
			return 1;
		}

		/* iterate section */
		if ((nn = OF_child(node)) != 0) {
			continue;
		}
		while ((nn = OF_peer(node)) == 0) {
			node = OF_parent(node);
			if (node == of_node) {
				nn = 0; /* done */
				break;
			}
		}
	}
	oaddr[0] = oaddr[1] = oaddr[2] = 0xff;
	oaddr[3] = oaddr[4] = oaddr[5] = 0xff;
	return 0;
}

int
mpc_ether_hw_addr(struct ppc_pci_chipset *p, u_int8_t *s)
{
	printf("mpc_ether_hw_addr not supported\n");
	return(0);
}

int
mpc_bus_maxdevs(void *cpv, int busno)
{
	return(32);
}

#define BUS_SHIFT 16
#define DEVICE_SHIFT 11
#define FNC_SHIFT 8

pcitag_t
mpc_make_tag(void *cpv, int bus, int dev, int fnc)
{
	return (bus << BUS_SHIFT) | (dev << DEVICE_SHIFT) | (fnc << FNC_SHIFT);
}

void
mpc_decompose_tag(void *cpv, pcitag_t tag, int *busp, int *devp, int *fncp)
{
	if (busp != NULL)
		*busp = (tag >> BUS_SHIFT) & 0xff;
	if (devp != NULL)
		*devp = (tag >> DEVICE_SHIFT) & 0x1f;
	if (fncp != NULL)
		*fncp = (tag >> FNC_SHIFT) & 0x7;
}

d444 1
a444 1
	u_int32_t reg;
d446 1
a446 1
	mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);
a459 1
			
d466 1
a466 1
			reg =  tag | offset | 1;
d472 1
a472 1
		reg =  0x80000000 | tag  | offset;
a477 6
int
mpc_conf_size(void *cpv, pcitag_t tag)
{
	return PCI_CONFIG_SPACE_SIZE;
}

d528 1
a528 1
		mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);
d559 1
a559 1
		mpc_decompose_tag(cpv, tag, &bus, &dev, &fcn);
a575 52
}


/*ARGSUSED*/
int
mpc_intr_map(void *lcv, pcitag_t bustag, int buspin, int  line,
    pci_intr_handle_t *ihp)
{
	int error = 0;

	*ihp = -1;
        if (buspin == 0)
                error = 1; /* No IRQ used. */
        else if (buspin > 4) {
                printf("mpc_intr_map: bad interrupt pin %d\n", buspin);
                error = 1;
        }
	if (line == 0xff || line == 0)
		error = 1;

	if (!error)
		*ihp = line;
	return error;
}

const char *
mpc_intr_string(void *lcv, pci_intr_handle_t ih)
{
	static char str[16];

	snprintf(str, sizeof str, "irq %ld", ih);
	return(str);
}

int
mpc_intr_line(void *lcv, pci_intr_handle_t ih)
{
	return (ih);
}

void *
mpc_intr_establish(void *lcv, pci_intr_handle_t ih, int level,
    int (*func)(void *), void *arg, const char *name)
{
	return (*intr_establish_func)(lcv, ih, IST_LEVEL, level, func, arg,
		name);
}

void
mpc_intr_disestablish(void *lcv, void *cookie)
{
	/* XXX We should probably do something clever here.... later */
@


1.44
log
@Remove old functions to access MPC106 registers. Only one of them was used
to read the revision id that was wrong most of the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.43 2011/10/28 15:17:02 drahn Exp $ */
d36 1
a36 1
#include <sys/kernel.h>
d38 1
a38 3
#include <sys/device.h>
#include <sys/proc.h>
#include <uvm/uvm_extern.h>
a41 2
#include <machine/bat.h>
#include <machine/powerpc.h>
a46 2
#include <macppc/pci/pcibrvar.h>

d74 22
a108 2
struct pcibr_config mpc_config;

d396 1
a396 1
	lcp = sc->sc_pcibr = &sc->pcibr_config;
@


1.43
log
@Ignore devices with irq 0 on mpcpci bus, the only devices seen this
way is hardware not found in the openfirmware tree. diff from kettenis@@
commit it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.42 2011/01/08 18:10:23 deraadt Exp $ */
a51 1
#include <macppc/pci/mpc106reg.h>
a76 1
u_int32_t pci_iack(void);
d453 1
a453 2
	printf(": %s, Revision 0x%x\n", compat, 
	    mpc_cfg_read_1(lcp, MPC106_PCI_REVID));
a925 82
}

u_int32_t
pci_iack()
{
	/* do pci IACK cycle */
	/* this should be bus allocated. */
	volatile u_int8_t *iack = (u_int8_t *)0xbffffff0;
	u_int8_t val;

	val = *iack;
	return val;
}

void
mpc_cfg_write_1(struct pcibr_config *cp, u_int32_t reg, u_int8_t val)
{
	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, MPC106_REGOFFS(reg));
	bus_space_write_1(cp->lc_iot, cp->ioh_cfc, 0, val);
	splx(s);
}

void
mpc_cfg_write_2(struct pcibr_config *cp, u_int32_t reg, u_int16_t val)
{
	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, MPC106_REGOFFS(reg));
	bus_space_write_2(cp->lc_iot, cp->ioh_cfc, 0, val);
	splx(s);
}

void
mpc_cfg_write_4(struct pcibr_config *cp, u_int32_t reg, u_int32_t val)
{

	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, MPC106_REGOFFS(reg));
	bus_space_write_4(cp->lc_iot, cp->ioh_cfc, 0, val);
	splx(s);
}

u_int8_t
mpc_cfg_read_1(struct pcibr_config *cp, u_int32_t reg)
{
	u_int8_t _v_;

	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, MPC106_REGOFFS(reg));
	_v_ = bus_space_read_1(cp->lc_iot, cp->ioh_cfc, 0);
	splx(s);
	return(_v_);
}

u_int16_t
mpc_cfg_read_2(struct pcibr_config *cp, u_int32_t reg)
{
	u_int16_t _v_;

	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, MPC106_REGOFFS(reg));
	_v_ = bus_space_read_2(cp->lc_iot, cp->ioh_cfc, 0);
	splx(s);
	return(_v_);
}

u_int32_t
mpc_cfg_read_4(struct pcibr_config *cp, u_int32_t reg)
{
	u_int32_t _v_;

	int s;
	s = splhigh();
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, MPC106_REGOFFS(reg));
	_v_ = bus_space_read_4(cp->lc_iot, cp->ioh_cfc, 0);
	splx(s);
	return(_v_);
@


1.42
log
@rename imask[] to cpu_imask[] to because imask is too loud as far as
kernel namespace
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.41 2010/12/04 17:06:31 miod Exp $ */
d894 1
a894 1
	if (line == 0xff)
@


1.41
log
@Introduce a new pci routine, pci_conf_size(), which returns the size of a
given pcitag_t configuration address space. Currently, all pci controllers
will return the usual 0x100 bytes of PCI configuration space, but this will
eventually change on PCIe-capable controlers.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.40 2009/08/22 02:54:50 mk Exp $ */
d523 1
a523 1
	u_int32_t imask[8], maskedaddr[8];
d527 1
a527 1
	mlen = OF_getprop(parent, "interrupt-map-mask", imask, sizeof(imask));
d540 1
a540 1
		maskedaddr[i] = addr[i] & imask[i];
@


1.40
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.39 2009/05/03 21:30:09 kettenis Exp $ */
d64 1
d441 1
d773 6
d791 2
a792 1
	if (offset & 3 || offset < 0 || offset >= 0x100) {
@


1.39
log
@Get rid of pci_addr_fixup machinery; set up the appropriate extents and pass
them along when we attach pci(4).  Simplify the rbus code by using extents
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.38 2009/03/29 22:58:31 kettenis Exp $ */
d71 1
a71 1
            int, int (*func)(void *), void *, char *);
d910 1
a910 1
    int (*func)(void *), void *arg, char *name)
@


1.38
log
@bzero pci attach args
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.37 2008/03/25 22:38:28 kettenis Exp $ */
d91 3
a152 2
int pci_map_a = 0;

d154 6
a159 6
	u_int32_t flags;
	u_int32_t pad1;
	u_int32_t pad2;
	u_int32_t base;
	u_int32_t pad3;
	u_int32_t size;
d161 1
d163 1
a163 7
mpcpcibus_find_ranges_32 (struct pcibr_softc *sc, u_int32_t *range_store,
    int rangesize);
void
mpcpcibus_find_ranges_64 (struct pcibr_softc *sc, u_int32_t *range_store,
    int rangesize);
void
mpcpcibus_find_ranges_32 (struct pcibr_softc *sc, u_int32_t *range_store,
d166 1
a166 1
	int found;
a170 1
	int i;
d172 1
a172 1
	rangelen = rangesize / sizeof (struct ranges_32);
d182 2
a183 2
	for (i = 0; i < rangelen ; i++) {
		if (prange[i].flags == 0x01000000) {
d186 4
d193 3
a195 5
	if (prange[found].flags == 0x01000000) {
		sc->sc_iobus_space.bus_base =
		    prange[found].base;
		sc->sc_iobus_space.bus_size =
		    prange[found].size;
a205 1
	 * start with segment 1 not 0, 0 is config.
d207 2
a208 2
	for (i = 0; i < rangelen ; i++) {
		if (prange[i].flags == 0x02000000) {
d211 2
a212 2
				prange[i].base,
				prange[i].size);
d215 2
a216 2
				if ((base + size) == prange[i].base)   
					size += prange[i].size;
d218 2
a219 2
					size = prange[i].size;
					base = prange[i].base;
d222 2
a223 2
				base = prange[i].base;
				size = prange[i].size;
d225 4
d236 7
a242 7
	u_int32_t flags;
	u_int32_t pad1;
	u_int32_t pad2;
	u_int32_t pad3;
	u_int32_t base;
	u_int32_t pad4;
	u_int32_t size;
d244 1
d246 1
a246 1
mpcpcibus_find_ranges_64 (struct pcibr_softc *sc, u_int32_t *range_store,
d252 1
a253 1
	struct ranges_64 *prange = (void *)range_store;
d255 1
a255 1
	rangelen = rangesize / sizeof (struct ranges_64);
a257 1

d263 9
a271 7
	if (prange[0].flags == 0xabb10113) { /* appl U3; */
		prange[0].flags = 0x01000000;
		prange[0].base = 0xf8070000;
		prange[0].size = 0x00001000;
		prange[1].flags = 0x02000000;
		prange[1].base = 0xf2000000;
		prange[1].size = 0x02800000;      
d277 2
a278 2
	for (i = 0; i < rangelen ; i++) {
		if (prange[i].flags == 0x01000000) {
d281 4
d288 3
a290 3
	if (prange[found].flags == 0x01000000) {
		sc->sc_iobus_space.bus_base = prange[found].base;
		sc->sc_iobus_space.bus_size = prange[found].size;
a300 1
	 * start with segment 1 not 0, 0 is config.
d302 2
a303 2
	for (i = 0; i < rangelen ; i++) {
		if (prange[i].flags == 0x02000000) {
d306 2
a307 2
				prange[i].base,
				prange[i].size);
d311 2
a312 2
				if ((base + size) == prange[i].base) {
					size += prange[i].size;
d314 2
a315 2
					base = prange[i].base;
					size = prange[i].size;
d318 2
a319 2
				base = prange[i].base;
				size = prange[i].size;
d321 4
d385 9
a455 3
	if ((strcmp(compat, "bandit")) != 0)
		pci_addr_fixup(sc, &lcp->lc_pc, 32);

d462 2
@


1.37
log
@Make pci_intr_map(9) fail if the interrupt line register is set to 0xff.
Prevents crashes later on when we try to estabish the interrupt.

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.36 2006/12/14 17:36:12 kettenis Exp $ */
d441 1
a449 1
	pba.pba_bridgetag = NULL;
@


1.36
log
@Make pci subsystem aware of domains.  Each host bridge gets assigned a unique
domain number such that we can distinguish between busses with the same bus
number that are behind different host bridges.  Domains can be accessed by
using different device nodes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.35 2006/12/05 20:48:23 gwk Exp $ */
d868 2
@


1.35
log
@Implement an alternative workaround for the extent lies out of region panic
on old world macppc machines, if the compat property of the device is
bandit skip the pci_addr_fixup() call. This acomplishes what the changes in
rev 1.33 that were reverted attempted to do without breaking currently
supported machines. A positive side effect to this change is also working
PCI cards as well as onboard devices.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.34 2006/10/27 10:42:39 gwk Exp $ */
d447 1
@


1.34
log
@Partially revert 1.33 the range calculation change for bandit
unfourtunately breaks some machines found the hard way by xsa@@ and
mbalmer@@.
ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.33 2006/10/23 02:05:26 gwk Exp $ */
d438 2
a439 1
	pci_addr_fixup(sc, &lcp->lc_pc, 32);
@


1.33
log
@Change bandit as found in many old world macs to use configuration type 1.
Alter range calculation to handle bandits dual non contiguous PCI
memory spaces. Finally fix a bug whereby if the "AAPL,Interrupts" property
is defined the variable intr isn't assigned a value and garbage may be
written to the PCI interrupt register.
tested by jolan, pedro, drahn and myself, and in snaps for a week.
ok drahn, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.32 2006/05/10 00:07:40 brad Exp $ */
d221 1
a221 4
				else if (prange[i].base < base) {
					size+= base - prange[i].base;
					base = prange[i].base;
				} else {
@


1.32
log
@Use a macro in the MI powerpc PCI header for pci_intr_line() instead
of a function in the MD macppc host bridge code.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.31 2006/03/13 20:10:49 brad Exp $ */
d110 1
a110 1
	{"bandit",		0x00800000, 0x00c00000, 0 },
d219 1
a219 1
				if ((base + size) == prange[i].base) {
d221 3
d225 1
d227 1
a227 2
					size = prange[i].size;
				}
d444 1
a444 1
		
d611 2
a612 1
	}
a743 1

d750 1
a751 1
	}
@


1.31
log
@* Add "pcitag_t *pba_bridgetag" to pci_attach_args.  This is set to
  NULL for root PCI busses.  For busses behind a bridge, it points to
  a persistent copy of the bridge's pcitag_t.  This can be very useful
  for machine-dependent PCI bus enumeration code.

From NetBSD

ok grange@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.30 2006/02/11 05:21:40 brad Exp $ */
a980 6
}

int
pci_intr_line(pci_intr_handle_t ih)
{
	return (ih);
@


1.30
log
@remove unused srom_crc32() function.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.29 2006/02/03 10:21:18 kettenis Exp $ */
d447 1
@


1.29
log
@Implement interrupt mapping according to the OFW Interrupt Mapping recommended
practice.
tested by many, ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.28 2005/12/16 21:39:42 miod Exp $ */
a134 15

/*
 * Code from "pci/if_de.c" used to calculate crc32 of ether rom data.
 */
#define      TULIP_CRC32_POLY  0xEDB88320UL
static __inline__ unsigned
srom_crc32(const unsigned char *databuf, size_t datalen)
{
    u_int idx, bit, data, crc = 0xFFFFFFFFUL;

    for (idx = 0; idx < datalen; idx++)
        for (data = *databuf++, bit = 0; bit < 8; bit++, data >>= 1)
            crc = (crc >> 1) ^ (((crc ^ data) & 1) ? TULIP_CRC32_POLY : 0);
    return crc;
}
@


1.28
log
@Missing splx in setfault() error path.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.27 2005/11/07 02:19:46 brad Exp $ */
d508 1
a508 1
 * Find PCI IRQ from OF
d513 1
a513 1
	int iparent, len, mlen, n_mlen;
d517 1
d521 4
d526 1
a526 1
	if ((len == -1) || (mlen == -1))
d529 4
a532 2
	n_mlen = mlen/sizeof(u_int32_t);
	for (i = 0; i < n_mlen; i++)
d535 12
a546 3
	mp = map;
	/* calculate step size of interrupt-map
	 * -- assumes that iparent will be same for all nodes
a547 12
	iparent = mp[n_mlen];
	step = 0;
	for (i = (n_mlen)+1; i < len; i++)
		if (mp[i] == iparent) {
			step = i - (n_mlen);
			break;
		}
	if (step == 0) {
		/* unable to determine step size */
		printf("find_node_intr unable to find step size\n");
		return -1;
	}
d549 1
d551 14
a565 2
		mp1 = mp + n_mlen;

d567 2
a568 7
			/* multiple irqs? */
			if (step == 9) {
				/* pci-pci bridge */
				iparent = *mp1;
				/* recurse with new 'addr' */
				return find_node_intr(iparent, &mp1[1], intr);
			} else
d570 4
a573 1
			return 1;
@


1.27
log
@remove vtophys() on *ppc.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.26 2005/10/08 23:38:30 drahn Exp $ */
d784 1
@


1.26
log
@if find_node_intr() doesn't find a match, try to use the contents of
'interrupts'. Also fix a bug where a signed value with -1 in it is compared
against 'sizeof(....)'.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.25 2005/10/03 02:22:38 drahn Exp $ */
a629 18
}

/*
 *  Get PCI physical address from given virtual address.
 *  XXX Note that cross page boundaries are *not* guaranteed to work!
 */

paddr_t
vtophys(paddr_t pa)
{
	vaddr_t va = (vaddr_t) pa;

	if (va < VM_MIN_KERNEL_ADDRESS)
		pa = va;
	else
		pmap_extract(vm_map_pmap(phys_map), va, &pa);

	return (pa | ((pci_map_a == 1) ? MPC106_PCI_CPUMEM : 0 ));
@


1.25
log
@Kettenis figured out how to make this run on G5, then I went back and
did some major housecleaning on it and made it run on 32 bit and 64 bit
machines. another step.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.24 2005/06/08 19:08:23 drahn Exp $ */
d541 1
d574 1
d584 1
a584 1
	if (len < sizeof(addr[0]))
d595 2
d599 8
a606 2
		if (find_node_intr(parent, &addr[0].phys_hi, &irq) == -1)
			return;
@


1.24
log
@Remove the bus_reverse field out of the powerpc bus structure, originally
it was there so that big endian and little endian devices could both be
present, however that is not the case on the macppc machines.
Cleans up code, shrinks the kernel. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.23 2003/12/20 22:40:27 miod Exp $ */
a46 5
#if 0
#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#endif

d102 1
a102 1
struct {
d107 2
a108 1
} config_offsets[] = {
d112 2
d166 9
d176 8
a183 1
mpcpcibrattach(struct device *parent, struct device *self, void *aux)
d185 30
a214 7
	struct pcibr_softc *sc = (struct pcibr_softc *)self;
	struct confargs *ca = aux;
	struct pcibr_config *lcp;
	struct pcibus_attach_args pba;
	int map, node;
	char *bridge;
	int of_node = 0;
d216 23
a238 26
	switch(system_type) {
	case OFWMACH:
	case PWRSTK:
		{
			int handle; 
			int err;
			unsigned int val;
			handle = ppc_open_pci_bridge();
			/* if open fails something odd has happened,
			 * we did this before during probe...
			 */
			err = OF_call_method("config-l@@", handle, 1, 1,
				0x80000000, &val);
			if (err == 0) {
				switch (val) {
				/* supported ppc-pci bridges */
				case (PCI_VENDOR_MOT |
				    (PCI_PRODUCT_MOT_MPC105 <<16)):
					bridge = "MPC105";
					break;
				case (PCI_VENDOR_MOT |
				    (PCI_PRODUCT_MOT_MPC106 <<16)):
					bridge = "MPC106";
					break;
				default:
					;
a239 11

			}
			
			/* read the PICR1 register to find what 
			 * address map is being used
			 */
			err = OF_call_method("config-l@@", handle, 1, 1,
				0x800000a8, &val);
			if (val & 0x00010000) {
				map = 1; /* map A */
				pci_map_a = 1;
d241 2
a242 2
				map = 0; /* map B */
				pci_map_a = 0;
a243 23

			ppc_close_pci_bridge(handle);
		}
		if (map == 1) {
			sc->sc_membus_space.bus_base = MPC106_P_PCI_MEM_SPACE;
			sc->sc_iobus_space.bus_base = MPC106_P_PCI_IO_SPACE;
			if ( bus_space_map(&(sc->sc_iobus_space), 0, NBPG, 0,
			    &lcp->ioh_cf8) != 0 )
				panic("mpcpcibus: unable to map self");

			lcp->ioh_cfc = lcp->ioh_cf8;
		} else {
			sc->sc_membus_space.bus_base =
			    MPC106_P_PCI_MEM_SPACE_MAP_B;
			sc->sc_iobus_space.bus_base =
			    MPC106_P_PCI_IO_SPACE_MAP_B;
			if ( bus_space_map(&(sc->sc_iobus_space), 0xfec00000,
			    NBPG, 0, &lcp->ioh_cf8) != 0 )
				panic("mpcpcibus: unable to map self");

			if ( bus_space_map(&(sc->sc_iobus_space), 0xfee00000,
			    NBPG, 0, &lcp->ioh_cfc) != 0 )
				panic("mpcpcibus: unable to map self");
d245 4
d250 37
a286 30
		lcp->lc_pc.pc_conf_v = lcp;
		lcp->lc_pc.pc_attach_hook = mpc_attach_hook;
		lcp->lc_pc.pc_bus_maxdevs = mpc_bus_maxdevs;
		lcp->lc_pc.pc_make_tag = mpc_make_tag;
		lcp->lc_pc.pc_decompose_tag = mpc_decompose_tag;
		lcp->lc_pc.pc_conf_read = mpc_conf_read;
		lcp->lc_pc.pc_conf_write = mpc_conf_write;
		lcp->lc_pc.pc_ether_hw_addr = mpc_ether_hw_addr;
		lcp->lc_iot = &sc->sc_iobus_space;
		lcp->lc_memt = &sc->sc_membus_space;

	        lcp->lc_pc.pc_intr_v = lcp;
		lcp->lc_pc.pc_intr_map = mpc_intr_map;
		lcp->lc_pc.pc_intr_string = mpc_intr_string;
		lcp->lc_pc.pc_intr_line = mpc_intr_line;
		lcp->lc_pc.pc_intr_establish = mpc_intr_establish;
		lcp->lc_pc.pc_intr_disestablish = mpc_intr_disestablish;


		printf(": %s, Revision 0x%x, ", bridge, 
			mpc_cfg_read_1(lcp, MPC106_PCI_REVID));
		if (map == 1)
			printf("Using Map A\n");
		else
			printf("Using Map B\n");
#if 0
		/* Reset status */
		mpc_cfg_write_2(lcp, MPC106_PCI_STAT, 0xff80);
#endif
		break;
d288 13
a300 4
	case APPL:
		/* scan the children of the root of the openfirmware
		 * tree to locate all nodes with device_type of "pci"
		 */
d302 16
a317 14
		if (ca->ca_node == 0) {
			printf("invalid node on mpcpcibr config\n");
			return;
		}
		{
			char compat[32];
			u_int32_t addr_offset;
			u_int32_t data_offset;
#if 0
			struct pci_reserve_mem null_reserve = {
				0,
				0,
				0
			};
d319 7
a325 30
			int i;
			int len;
			int rangelen;

			struct ranges_new {
				u_int32_t flags;
				u_int32_t pad1;
				u_int32_t pad2;
				u_int32_t base;
				u_int32_t pad3;
				u_int32_t size;
			};
			u_int32_t range_store[32];
			struct ranges_new *prange = (void *)&range_store;

			len=OF_getprop(ca->ca_node, "compatible", compat,
			    sizeof (compat));
			if (len <= 0 ) {
				len=OF_getprop(ca->ca_node, "name", compat,
					sizeof (compat));
				if (len <= 0) {
					printf(" compatible and name not"
					    " found\n");
					return;
				}
				compat[len] = 0; 
				if (strcmp (compat, "bandit") != 0) {
					printf(" compatible not found and name"
					    " %s found\n", compat);
					return;
d327 3
d331 5
a335 8
			compat[len] = 0; 
			if ((rangelen = OF_getprop(ca->ca_node, "ranges",
			    range_store, sizeof (range_store))) <= 0) {
				printf("range lookup failed, node %x\n",
				ca->ca_node);
			}
			/* translate byte(s) into item count*/
			rangelen /= sizeof(struct ranges_new);
d337 16
a352 1
			lcp = sc->sc_pcibr = &sc->pcibr_config;
d354 34
a387 27
			{
				int found;
				unsigned int base = 0;
				unsigned int size = 0;

				/* mac configs */

				sc->sc_membus_space.bus_base = 0;
				sc->sc_membus_space.bus_io = 0;
				sc->sc_iobus_space.bus_base = 0;
				sc->sc_iobus_space.bus_io = 1;

				/* find io(config) base, flag == 0x01000000 */
				found = 0;
				for (i = 0; i < rangelen ; i++) {
					if (prange[i].flags == 0x01000000) {
						/* find last? */
						found = i;
					}
				}
				/* found the io space ranges */
				if (prange[found].flags == 0x01000000) {
					sc->sc_iobus_space.bus_base =
					    prange[found].base;
					sc->sc_iobus_space.bus_size =
					    prange[found].size;
				}
d389 1
a389 37
				/* the mem space ranges 
				 * apple openfirmware always puts full
				 * addresses in config information,
				 * it is not necessary to have correct bus
				 * base address, but since 0 is reserved
				 * and all IO and device memory will be in
				 * upper 2G of address space, set to
				 * 0x80000000
				 * start with segment 1 not 0, 0 is config.
				 */
				for (i = 0; i < rangelen ; i++) {
					if (prange[i].flags == 0x02000000) {
#if 0
						printf("\nfound mem %x %x",
							prange[i].base,
							prange[i].size);
#endif
							
						if (base != 0) {
							if ((base + size) ==
							    prange[i].base) {
								size +=
								 prange[i].size;
							} else {
								base =
								 prange[i].base;
								size =
								 prange[i].size;
							}
						} else {
							base = prange[i].base;
							size = prange[i].size;
						}
					}
				}
				sc->sc_membus_space.bus_base = base;
				sc->sc_membus_space.bus_size = size;
d391 20
a410 17
			}
			addr_offset = 0;
			for (i = 0; config_offsets[i].compat != NULL; i++) {
				if (strcmp(config_offsets[i].compat, compat)
				    == 0) {
					addr_offset = config_offsets[i].addr; 
					data_offset = config_offsets[i].data; 
					lcp->config_type =
					    config_offsets[i].config_type;
					break;
				}
			}
			if (addr_offset == 0) {
				printf("unable to find match for"
				    " compatible %s\n", compat);
				return;
			}
d412 7
a418 7
			printf(" mem base %x sz %x io base %x sz %x\n"
			    " config addr %x config data %x\n",
			    sc->sc_membus_space.bus_base,
			    sc->sc_membus_space.bus_size,
			    sc->sc_iobus_space.bus_base,
			    sc->sc_iobus_space.bus_size,
			    addr_offset, data_offset);
d421 28
a448 28
			if ( bus_space_map(&(sc->sc_iobus_space), addr_offset,
				NBPG, 0, &lcp->ioh_cf8) != 0 )
				panic("mpcpcibus: unable to map self");

			if ( bus_space_map(&(sc->sc_iobus_space), data_offset,
				NBPG, 0, &lcp->ioh_cfc) != 0 )
				panic("mpcpcibus: unable to map self");

			of_node = ca->ca_node;

			lcp->node = ca->ca_node;
			lcp->lc_pc.pc_conf_v = lcp;
			lcp->lc_pc.pc_attach_hook = mpc_attach_hook;
			lcp->lc_pc.pc_bus_maxdevs = mpc_bus_maxdevs;
			lcp->lc_pc.pc_make_tag = mpc_make_tag;
			lcp->lc_pc.pc_decompose_tag = mpc_decompose_tag;
			lcp->lc_pc.pc_conf_read = mpc_conf_read;
			lcp->lc_pc.pc_conf_write = mpc_conf_write;
			lcp->lc_pc.pc_ether_hw_addr = of_ether_hw_addr;
			lcp->lc_iot = &sc->sc_iobus_space;
			lcp->lc_memt = &sc->sc_membus_space;

			lcp->lc_pc.pc_intr_v = lcp;
			lcp->lc_pc.pc_intr_map = mpc_intr_map;
			lcp->lc_pc.pc_intr_string = mpc_intr_string;
			lcp->lc_pc.pc_intr_line = mpc_intr_line;
			lcp->lc_pc.pc_intr_establish = mpc_intr_establish;
			lcp->lc_pc.pc_intr_disestablish = mpc_intr_disestablish;
d450 2
a451 2
			printf(": %s, Revision 0x%x\n", compat, 
			    mpc_cfg_read_1(lcp, MPC106_PCI_REVID));
d453 1
a453 8
			pci_addr_fixup(sc, &lcp->lc_pc, 32);
		}
		break;

	default:
		printf("unknown system_type %d\n",system_type);
		return;
	}
@


1.23
log
@Pass -Wformat
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.22 2003/10/21 17:18:14 drahn Exp $ */
a225 1
			sc->sc_membus_space.bus_reverse = 1;
a226 1
			sc->sc_iobus_space.bus_reverse = 1;
a234 1
			sc->sc_membus_space.bus_reverse = 1;
a236 1
			sc->sc_iobus_space.bus_reverse = 1;
a347 1
				sc->sc_membus_space.bus_reverse = 1;
a349 1
				sc->sc_iobus_space.bus_reverse = 1;
@


1.22
log
@spacing cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.22 2003/10/21 17:15:15 drahn Exp $ */
d908 1
a908 1
	snprintf(str, sizeof str, "irq %d", ih);
@


1.21
log
@Further down the ANSI/KNF road, only binary difference is __LINE__.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.20 2003/06/09 16:34:21 deraadt Exp $ */
d5 1
a5 1
 * 
d61 2
a62 2
int	 mpcpcibrmatch(struct device *, void *, void *);
void	 mpcpcibrattach(struct device *, struct device *, void *);
d64 1
a64 1
void	 mpc_attach_hook(struct device *, struct device *,
d66 1
a66 1
int	 mpc_bus_maxdevs(void *, int);
d68 1
a68 1
void	 mpc_decompose_tag(void *, pcitag_t, int *, int *, int *);
d70 1
a70 1
void	 mpc_conf_write(void *, pcitag_t, int, pcireg_t);
d74 1
a74 1
int	 mpc_intr_line(void *, pci_intr_handle_t);
d109 2
a110 2
	u_int32_t addr;	 /* offset */
	u_int32_t data;	 /* offset */
@


1.20
log
@more 3/4 cleanup for pefo
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.19 2003/05/07 22:33:30 deraadt Exp $ */
d84 2
d143 1
a143 3
srom_crc32(
    const unsigned char *databuf,
    size_t datalen)
d154 1
a154 3
mpcpcibrmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
a166 2
void fix_node_irq(int node, struct pcibus_attach_args *pba);

d169 1
a169 3
mpcpcibrattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d195 2
a196 1
				case (PCI_VENDOR_MOT | ( PCI_PRODUCT_MOT_MPC105 <<16)):
d199 2
a200 1
				case (PCI_VENDOR_MOT | ( PCI_PRODUCT_MOT_MPC106 <<16)):
d230 1
a230 2
				&lcp->ioh_cf8) != 0 )
			{
d232 1
a232 1
			}
d236 1
a236 1
				MPC106_P_PCI_MEM_SPACE_MAP_B;
d239 1
a239 1
				MPC106_P_PCI_IO_SPACE_MAP_B;
d242 1
a242 2
				NBPG, 0, &lcp->ioh_cf8) != 0 )
			{
d244 1
a244 1
			}
d246 1
a246 2
				NBPG, 0, &lcp->ioh_cfc) != 0 )
			{
a247 1
			}
d271 1
a271 1
		if (map == 1) {
d273 1
a273 1
		} else  {
a274 1
		}
d317 1
a317 1
				sizeof (compat));
d323 1
a323 1
						" found\n");
d329 1
a329 1
						" %s found\n", compat);
d335 1
a335 3
				range_store,
				sizeof (range_store))) <= 0)
			{
d360 1
a360 2
				for (i = 0; i < rangelen ; i++)
				{
d369 1
a369 1
						prange[found].base;
d371 1
a371 1
						prange[found].size;
d384 1
a384 2
				for (i = 0; i < rangelen ; i++)
				{
d394 3
a396 4
							    prange[i].base)
							{
							    size +=
								prange[i].size;
d416 1
a416 2
					== 0)
				{
d420 1
a420 1
						config_offsets[i].config_type;
d426 1
a426 1
					" compatible %s\n", compat);
d430 7
a436 7
			printf(" mem base %x sz %x io base %x sz %x\n config addr %x"
				" config data %x\n",
				sc->sc_membus_space.bus_base,
				sc->sc_membus_space.bus_size,
				sc->sc_iobus_space.bus_base,
				sc->sc_iobus_space.bus_size,
				addr_offset, data_offset);
a438 2


a440 1
			{
d442 1
a442 1
			}
a444 1
			{
d446 1
a446 1
			}
a448 1

d469 1
a469 1
				mpc_cfg_read_1(lcp, MPC106_PCI_REVID));
a481 1

d492 1
a492 2
		for (node = OF_child(of_node); node; node = nn)
		{
d496 1
a496 1
				sizeof(name));
d501 1
a501 1
			if ((nn = OF_child(node)) != 0) {
d503 1
a503 1
			}
d548 1
d550 1
a550 1
	for (i = 0; i < n_mlen; i++) {
d552 1
a552 1
	}
d559 1
a559 1
	for (i = (n_mlen)+1; i < len; i++) {
a563 1
	}
d580 1
a580 1
			} else {
a581 1
			}
d592 1
a592 3
fix_node_irq(node, pba)
	int node;
	struct pcibus_attach_args *pba;
d607 1
a607 1
	if (len < sizeof(addr[0])) {
a608 1
	}
d628 1
a628 2
		pcidev(addr[0].phys_hi),
		pcifunc(addr[0].phys_hi));
d637 1
a637 3
mpcpcibrprint(aux, pnp)
	void *aux;
	const char *pnp;
d653 1
a653 2
vtophys(pa)
	paddr_t pa;
d666 2
a667 3
mpc_attach_hook(parent, self, pba)
	struct device *parent, *self;
	struct pcibus_attach_args *pba;
d710 1
a710 3
mpc_ether_hw_addr(p, s)
	struct ppc_pci_chipset *p;
	u_int8_t *s;
d717 1
a717 3
mpc_bus_maxdevs(cpv, busno)
	void *cpv;
	int busno;
d727 1
a727 3
mpc_make_tag(cpv, bus, dev, fnc)
	void *cpv;
	int bus, dev, fnc;
d733 1
a733 4
mpc_decompose_tag(cpv, tag, busp, devp, fncp)
	void *cpv;
	pcitag_t tag;
	int *busp, *devp, *fncp;
d744 1
a744 4
mpc_gen_config_reg(cpv, tag, offset)
	void *cpv;
	pcitag_t tag;
	int offset;
a748 5
	/*
	static int spin = 0;
	while (spin > 85);
	spin++;
	*/
d755 1
a755 1
			if (dev < 11) {
a756 1
			}
d766 2
a767 3
			if (dev > 15) {
			 return 0xffffffff;
			}
d786 1
a786 4
mpc_conf_read(cpv, tag, offset)
	void *cpv;
	pcitag_t tag;
	int offset;
a795 2


d805 1
a805 1
	if (reg == 0xffffffff) {
a806 1
	}
d808 1
a808 1
	if ((cp->config_type & 2) && (offset & 0x04)) {
a809 1
	}
d844 1
a844 5
mpc_conf_write(cpv, tag, offset, data)
	void *cpv;
	pcitag_t tag;
	int offset;
	pcireg_t data;
d854 1
a854 1
	if (reg == 0xffffffff) {
d856 2
a857 2
	}
	if ((cp->config_type & 2) && (offset & 0x04)) {
d859 1
a859 1
	}
d885 2
a886 5
mpc_intr_map(lcv, bustag, buspin, line, ihp)
	void *lcv;
	pcitag_t bustag;
	int buspin, line;
	pci_intr_handle_t *ihp;
d891 2
a892 4
        if (buspin == 0) {
                /* No IRQ used. */
                error = 1;
        }
d904 1
a904 3
mpc_intr_string(lcv, ih)
	void *lcv;
	pci_intr_handle_t ih;
d913 1
a913 3
mpc_intr_line(lcv, ih)
	void *lcv;
	pci_intr_handle_t ih;
d919 2
a920 7
mpc_intr_establish(lcv, ih, level, func, arg, name)
	void *lcv;
	pci_intr_handle_t ih;
	int level;
	int (*func)(void *);
	void *arg;
	char *name;
d927 1
a927 2
mpc_intr_disestablish(lcv, cookie)
	void *lcv, *cookie;
d945 1
a945 4
mpc_cfg_write_1(cp, reg, val)
	struct pcibr_config *cp;
	u_int32_t reg;
	u_int8_t val;
d949 1
a949 2
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0,
		MPC106_REGOFFS(reg));
d955 1
a955 4
mpc_cfg_write_2(cp, reg, val)
	struct pcibr_config *cp;
	u_int32_t reg;
	u_int16_t val;
d965 1
a965 4
mpc_cfg_write_4(cp, reg, val)
	struct pcibr_config *cp;
	u_int32_t reg;
	u_int32_t val;
d976 1
a976 3
mpc_cfg_read_1(cp, reg)
	struct pcibr_config *cp;
	u_int32_t reg;
d989 1
a989 3
mpc_cfg_read_2(cp, reg)
	struct pcibr_config *cp;
	u_int32_t reg;
d1002 1
a1002 3
mpc_cfg_read_4(cp, reg)
	struct pcibr_config *cp;
	u_int32_t reg;
d1015 1
a1015 2
pci_intr_line(ih)
	pci_intr_handle_t ih;
@


1.19
log
@string cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.18 2003/02/26 21:54:44 drahn Exp $ */
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed under OpenBSD for RTMX Inc
 *      by Per Fogelstrom, Opsycon AB.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.18
log
@Remove an unnecessary structure copy from useage of setfault(), call
by reference, not by value, ok matthieu#, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.17 2003/02/18 13:14:43 jmc Exp $ */
d982 1
a982 1
	sprintf(str, "irq %d", ih);
@


1.17
log
@intial -> initial;

the great intial witch hunt, as prompted by tdeval@@

os-aix-dso.c: ok henning@@
ab.C: ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.16 2002/10/12 01:09:43 krw Exp $ */
d877 1
a877 1
	if (setfault(env)) {
@


1.16
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.15 2002/10/07 05:39:48 drahn Exp $ */
d643 1
a643 1
	 * has intialized the register correctly.
@


1.15
log
@Improved workaround for cardbus support on macppc. This allows mappings to
be put in the cardbus register which really work instead of crashing the
machine.  if_dc @@cardbus now works, xl@@cardbus will configure, but does
not work properly (endian?) wdc should work fine, but has not been tested
recently.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.14 2002/09/15 09:01:59 deraadt Exp $ */
d242 1
a242 1
				panic("mpcpcibus: unable to map self\n");
d255 1
a255 1
				panic("mpcpcibus: unable to map self\n");
d260 1
a260 1
				panic("mpcpcibus: unable to map self\n");
d465 1
a465 1
				panic("mpcpcibus: unable to map self\n");
d470 1
a470 1
				panic("mpcpcibus: unable to map self\n");
@


1.14
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.12 2002/09/06 13:44:03 drahn Exp $ */
d370 1
d373 1
@


1.13
log
@KNF
@
text
@d5 1
a5 1
 *
d78 1
a78 1
int	mpc_intr_map(void *, pcitag_t, int, int, pci_intr_handle_t *);
d81 4
a84 4
void	*mpc_intr_establish(void *, pci_intr_handle_t,
	    int, int (*func)(void *), void *, char *);
void	mpc_intr_disestablish(void *, void *);
int	mpc_ether_hw_addr(struct ppc_pci_chipset *, u_int8_t *);
d91 1
a91 1
	sizeof(struct pcibr_softc), mpcpcibrmatch, mpcpcibrattach,
d98 1
a98 1
static int mpcpcibrprint(void *, const char *pnp);
d151 1
a151 1
	u_int idx, bit, data, crc = 0xFFFFFFFFUL;
d153 4
a156 5
	for (idx = 0; idx < datalen; idx++)
		for (data = *databuf++, bit = 0; bit < 8; bit++, data >>= 1)
			crc = (crc >> 1) ^ (((crc ^ data) & 1) ?
			    TULIP_CRC32_POLY : 0);
	return crc;
d171 1
d191 1
a191 1
	switch (system_type) {
d195 1
a195 1
			int handle;
a197 1

d203 1
a203 1
			    0x80000000, &val);
d214 1
a214 1
					break;
d216 1
d218 2
a219 2

			/* read the PICR1 register to find what
d223 1
a223 1
			    0x800000a8, &val);
d239 3
a241 2
			if (bus_space_map(&(sc->sc_iobus_space), 0, NBPG, 0,
			    &lcp->ioh_cf8) != 0) {
d247 1
a247 1
			    MPC106_P_PCI_MEM_SPACE_MAP_B;
d250 1
a250 1
			    MPC106_P_PCI_IO_SPACE_MAP_B;
d252 3
a254 2
			if (bus_space_map(&(sc->sc_iobus_space), 0xfec00000,
				NBPG, 0, &lcp->ioh_cf8) != 0) {
d257 3
a259 2
			if (bus_space_map(&(sc->sc_iobus_space), 0xfee00000,
			    NBPG, 0, &lcp->ioh_cfc) != 0) {
d275 1
a275 1
		lcp->lc_pc.pc_intr_v = lcp;
d283 2
a284 2
		printf(": %s, Revision 0x%x, ", bridge,
		    mpc_cfg_read_1(lcp, MPC106_PCI_REVID));
d331 2
a332 2
			len = OF_getprop(ca->ca_node, "compatible", compat,
			    sizeof (compat));
d334 2
a335 2
				len = OF_getprop(ca->ca_node, "name", compat,
				    sizeof (compat));
d338 1
a338 1
					    " found\n");
d341 2
a342 2
				compat[len] = 0;
				if (strcmp(compat, "bandit") != 0) {
d344 1
a344 1
					    " %s found\n", compat);
d348 1
a348 1
			compat[len] = 0;
d350 3
a352 1
			    range_store, sizeof (range_store))) <= 0) {
d375 2
a376 1
				for (i = 0; i < rangelen ; i++) {
d385 1
a385 1
					    prange[found].base;
d387 1
a387 1
					    prange[found].size;
d390 1
a390 1
				/* the mem space ranges
d400 2
a401 1
				for (i = 0; i < rangelen ; i++) {
d405 2
a406 2
						    prange[i].base,
						    prange[i].size);
d408 1
a408 1

d411 2
a412 1
							    prange[i].base) {
d417 1
a417 1
								    prange[i].base;
d419 1
a419 1
								    prange[i].size;
d434 4
a437 3
				    == 0) {
					addr_offset = config_offsets[i].addr;
					data_offset = config_offsets[i].data;
d439 1
a439 1
					    config_offsets[i].config_type;
d445 1
a445 1
				    " compatible %s\n", compat);
d450 6
a455 6
			    " config data %x\n",
			    sc->sc_membus_space.bus_base,
			    sc->sc_membus_space.bus_size,
			    sc->sc_iobus_space.bus_base,
			    sc->sc_iobus_space.bus_size,
			    addr_offset, data_offset);
d460 3
a462 2
			if (bus_space_map(&(sc->sc_iobus_space), addr_offset,
			    NBPG, 0, &lcp->ioh_cf8) != 0) {
d465 3
a467 2
			if (bus_space_map(&(sc->sc_iobus_space), data_offset,
			    NBPG, 0, &lcp->ioh_cfc) != 0) {
d492 2
a493 2
			printf(": %s, Revision 0x%x\n", compat,
			    mpc_cfg_read_1(lcp, MPC106_PCI_REVID));
d505 1
d517 2
a518 1
		for (node = OF_child(of_node); node; node = nn) {
d522 1
a522 1
			    sizeof(name));
d543 7
a549 7

#define OFW_PCI_PHYS_HI_BUSMASK		0x00ff0000
#define OFW_PCI_PHYS_HI_BUSSHIFT	16
#define OFW_PCI_PHYS_HI_DEVICEMASK	0x0000f800
#define OFW_PCI_PHYS_HI_DEVICESHIFT	11
#define OFW_PCI_PHYS_HI_FUNCTIONMASK	0x00000700
#define OFW_PCI_PHYS_HI_FUNCTIONSHIFT	8
d558 1
a558 1
/*
d623 1
a623 1
	struct {
d645 1
d658 2
a659 2
	    pcidev(addr[0].phys_hi),
	    pcifunc(addr[0].phys_hi));
a712 1

d717 1
a717 1
		    sizeof(name));
d817 1
d820 1
a820 1
				return 0xffffffff;
d823 1
a823 1
			 * config type 1
d825 2
a826 1
			reg = tag | offset | 1;
d832 2
a833 1
		reg = 0x80000000 | tag  | offset;
d853 2
d856 2
a857 2
#ifdef DEBUG_CONFIG
		printf("pci_conf_read: bad reg %x\n", offset);
d895 1
a895 1
		    offset);
d930 1
a930 1
		    dev, fcn, offset);
d959 8
a966 7
	if (buspin == 0) {
		/* No IRQ used. */
		error = 1;
	} else if (buspin > 4) {
		printf("mpc_intr_map: bad interrupt pin %d\n", buspin);
		error = 1;
	}
d1002 1
a1002 1
	    name);
d1033 1
a1033 1
	    MPC106_REGOFFS(reg));
@


1.12
log
@KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.11 2002/07/23 17:53:25 drahn Exp $ */
d5 1
a5 1
 * 
d78 1
a78 1
int      mpc_intr_map(void *, pcitag_t, int, int, pci_intr_handle_t *);
d81 4
a84 4
void     *mpc_intr_establish(void *, pci_intr_handle_t,
            int, int (*func)(void *), void *, char *);
void     mpc_intr_disestablish(void *, void *);
int      mpc_ether_hw_addr(struct ppc_pci_chipset *, u_int8_t *);
d91 1
a91 1
        sizeof(struct pcibr_softc), mpcpcibrmatch, mpcpcibrattach,
d98 1
a98 1
static int      mpcpcibrprint(void *, const char *pnp);
d151 1
a151 1
    u_int idx, bit, data, crc = 0xFFFFFFFFUL;
d153 5
a157 4
    for (idx = 0; idx < datalen; idx++)
        for (data = *databuf++, bit = 0; bit < 8; bit++, data >>= 1)
            crc = (crc >> 1) ^ (((crc ^ data) & 1) ? TULIP_CRC32_POLY : 0);
    return crc;
a171 1

d191 1
a191 1
	switch(system_type) {
d195 1
a195 1
			int handle; 
d198 1
d204 1
a204 1
				0x80000000, &val);
d215 1
a215 1
					;
d217 1
d219 1
a219 3
			}
			
			/* read the PICR1 register to find what 
d223 1
a223 1
				0x800000a8, &val);
d239 2
a240 3
			if ( bus_space_map(&(sc->sc_iobus_space), 0, NBPG, 0,
				&lcp->ioh_cf8) != 0 )
			{
d246 1
a246 1
				MPC106_P_PCI_MEM_SPACE_MAP_B;
d249 1
a249 1
				MPC106_P_PCI_IO_SPACE_MAP_B;
d251 2
a252 3
			if ( bus_space_map(&(sc->sc_iobus_space), 0xfec00000,
				NBPG, 0, &lcp->ioh_cf8) != 0 )
			{
d255 2
a256 3
			if ( bus_space_map(&(sc->sc_iobus_space), 0xfee00000,
				NBPG, 0, &lcp->ioh_cfc) != 0 )
			{
d272 1
a272 1
	        lcp->lc_pc.pc_intr_v = lcp;
d280 2
a281 2
		printf(": %s, Revision 0x%x, ", bridge, 
			mpc_cfg_read_1(lcp, MPC106_PCI_REVID));
d328 2
a329 2
			len=OF_getprop(ca->ca_node, "compatible", compat,
				sizeof (compat));
d331 2
a332 2
				len=OF_getprop(ca->ca_node, "name", compat,
					sizeof (compat));
d335 1
a335 1
						" found\n");
d338 2
a339 2
				compat[len] = 0; 
				if (strcmp (compat, "bandit") != 0) {
d341 1
a341 1
						" %s found\n", compat);
d345 1
a345 1
			compat[len] = 0; 
d347 1
a347 3
				range_store,
				sizeof (range_store))) <= 0)
			{
d370 1
a370 2
				for (i = 0; i < rangelen ; i++)
				{
d379 1
a379 1
						prange[found].base;
d381 1
a381 1
						prange[found].size;
d384 1
a384 1
				/* the mem space ranges 
d394 1
a394 2
				for (i = 0; i < rangelen ; i++)
				{
d398 2
a399 2
							prange[i].base,
							prange[i].size);
d401 1
a401 1
							
d404 1
a404 2
							    prange[i].base)
							{
d409 1
a409 1
								 prange[i].base;
d411 1
a411 1
								 prange[i].size;
d426 3
a428 4
					== 0)
				{
					addr_offset = config_offsets[i].addr; 
					data_offset = config_offsets[i].data; 
d430 1
a430 1
						config_offsets[i].config_type;
d436 1
a436 1
					" compatible %s\n", compat);
d441 6
a446 6
				" config data %x\n",
				sc->sc_membus_space.bus_base,
				sc->sc_membus_space.bus_size,
				sc->sc_iobus_space.bus_base,
				sc->sc_iobus_space.bus_size,
				addr_offset, data_offset);
d451 2
a452 3
			if ( bus_space_map(&(sc->sc_iobus_space), addr_offset,
				NBPG, 0, &lcp->ioh_cf8) != 0 )
			{
d455 2
a456 3
			if ( bus_space_map(&(sc->sc_iobus_space), data_offset,
				NBPG, 0, &lcp->ioh_cfc) != 0 )
			{
d481 2
a482 2
			printf(": %s, Revision 0x%x\n", compat, 
				mpc_cfg_read_1(lcp, MPC106_PCI_REVID));
a493 1
		
d505 1
a505 2
		for (node = OF_child(of_node); node; node = nn)
		{
d509 1
a509 1
				sizeof(name));
d530 7
a536 7
                 
#define       OFW_PCI_PHYS_HI_BUSMASK         0x00ff0000
#define       OFW_PCI_PHYS_HI_BUSSHIFT        16
#define       OFW_PCI_PHYS_HI_DEVICEMASK      0x0000f800
#define       OFW_PCI_PHYS_HI_DEVICESHIFT     11
#define       OFW_PCI_PHYS_HI_FUNCTIONMASK    0x00000700
#define       OFW_PCI_PHYS_HI_FUNCTIONSHIFT   8
d545 1
a545 1
/* 
d610 1
a610 1
	struct { 
a631 1

d644 2
a645 2
		pcidev(addr[0].phys_hi),
		pcifunc(addr[0].phys_hi));
d699 1
d704 1
a704 1
			sizeof(name));
a803 1
			
d806 1
a806 1
			 return 0xffffffff;
d809 1
a809 1
			 * config type 1 
d811 1
a811 2
			reg =  tag | offset | 1;

d817 1
a817 2
		reg =  0x80000000 | tag  | offset;

a836 2


d838 2
a839 2
#ifdef DEBUG_CONFIG 
		printf ("pci_conf_read: bad reg %x\n", offset);
d877 1
a877 1
			offset);
d912 1
a912 1
			dev, fcn, offset);
d941 7
a947 8
        if (buspin == 0) {
                /* No IRQ used. */
                error = 1;
        }
        else if (buspin > 4) {
                printf("mpc_intr_map: bad interrupt pin %d\n", buspin);
                error = 1;
        }
d983 1
a983 1
		name);
d1014 1
a1014 1
		MPC106_REGOFFS(reg));
@


1.11
log
@Cardbus/pcmcia support for macppc. parts borrowed from NetBSD, and other
portions of the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.10 2002/04/22 21:39:58 miod Exp $ */
d674 1
a674 1
	if(pnp)
d713 1
a713 2
	for (node = OF_child(of_node); node; node = nn)
	{
d719 4
a722 4
		if (sizeof (laddr) ==
			OF_getprop(node, "local-mac-address", laddr,
				sizeof laddr))
		{
a724 1
			
d825 1
a825 1
			reg =  tag  | offset | 1;
d855 1
a855 1
	if(offset & 3 || offset < 0 || offset >= 0x100) {
d865 1
a865 1
		return 0xffffffff;
d968 1
a968 1
	if(!error)
@


1.10
log
@Fix a couple of typos.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.9 2002/03/14 03:15:56 millert Exp $ */
d448 1
a448 1
#ifdef PCI_DEBUG
d495 1
a495 3
#if 0
			pci_addr_fixup(sc, &lcp->lc_pc, 32, &null_reserve);
#endif
a523 3
#ifdef DEBUG_FIXUP
			printf("checking node %s", name);
#endif
a571 3
#ifdef DEBUG_FIXUP
	printf("parent %x len %x mlen %x\n", parent, len, mlen);
#endif
a595 5
#ifdef DEBUG_FIXUP
		printf ("[%x %x %x %x] [%x %x %x %x] %x\n",
		    maskedaddr[0], maskedaddr[1], maskedaddr[2], maskedaddr[3],
		    mp[0], mp[1], mp[2], mp[3], step);
#endif
a661 5
#ifdef DEBUG_FIXUP
	printf("changing interrupt from %x to %x\n",
		intr & PCI_INTERRUPT_LINE_MASK,
		irq & PCI_INTERRUPT_LINE_MASK);
#endif
d1110 7
@


1.9
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.8 2002/03/14 01:26:37 millert Exp $ */
d699 2
a700 2
 *  Get PCI physical address from given viritual address.
 *  XXX Note that cross page boundarys are *not* guarantee to work!
d709 1
a709 1
	if(va < VM_MIN_KERNEL_ADDRESS)
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.7 2002/03/02 17:44:58 drahn Exp $ */
d81 2
a82 2
void     *mpc_intr_establish __P((void *, pci_intr_handle_t,
            int, int (*func)(void *), void *, char *));
@


1.7
log
@cleanup.
Code reorganization to support pci-pci bridges on the interrupt fixup code.
Interrupts on devices behind pci-pci bridges should not be configured properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.6 2002/01/26 20:52:59 drahn Exp $ */
d67 2
a68 2
int	 mpcpcibrmatch __P((struct device *, void *, void *));
void	 mpcpcibrattach __P((struct device *, struct device *, void *));
d70 11
a80 11
void	 mpc_attach_hook __P((struct device *, struct device *,
				struct pcibus_attach_args *));
int	 mpc_bus_maxdevs __P((void *, int));
pcitag_t mpc_make_tag __P((void *, int, int, int));
void	 mpc_decompose_tag __P((void *, pcitag_t, int *, int *, int *));
pcireg_t mpc_conf_read __P((void *, pcitag_t, int));
void	 mpc_conf_write __P((void *, pcitag_t, int, pcireg_t));

int      mpc_intr_map __P((void *, pcitag_t, int, int, pci_intr_handle_t *));
const char *mpc_intr_string __P((void *, pci_intr_handle_t));
int	 mpc_intr_line __P((void *, pci_intr_handle_t));
d83 4
a86 4
void     mpc_intr_disestablish __P((void *, void *));
int      mpc_ether_hw_addr __P((struct ppc_pci_chipset *, u_int8_t *));
u_int32_t mpc_gen_config_reg __P((void *cpv, pcitag_t tag, int offset));
int	of_ether_hw_addr __P((struct ppc_pci_chipset *, u_int8_t *));
d88 1
a88 1
u_int32_t pci_iack __P((void));
d98 1
a98 1
static int      mpcpcibrprint __P((void *, const char *pnp));
d1017 1
a1017 1
	int (*func) __P((void *));
@


1.6
log
@Kludge, protect against bus faults during pci probes. allows OpenBSD
to boot on a B&W G3.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.5 2001/12/21 19:52:00 drahn Exp $ */
d87 1
a87 1
int	find_node_intr __P((int node, u_int32_t *addr, u_int32_t *intr));
d521 7
a527 8
			{
				char name[32];
				int len;
				len = OF_getprop(node, "name", name,
					sizeof(name));
				name[len] = 0;
#if 0
				printf("checking node %s\n", name);
a528 1
			}
d567 1
a567 3
find_node_intr(node, addr, intr)
	int node;
	u_int32_t *addr, *intr;
d569 3
a571 3
	int parent, iparent, len, mlen;
	int match, i;
	u_int32_t map[64], *mp;
a572 5
	u_int32_t icells;

	len = OF_getprop(node, "AAPL,interrupts", intr, 4);
	if (len == 4)
		return 1;
a573 1
	parent = OF_parent(node);
d577 3
d582 2
a583 1
	for (i = 0; i < (mlen / 4); i++) {
d587 16
d604 5
d610 1
a610 5
		mp += mlen / 4;
		len -= mlen;
		iparent = *mp++;
		if (OF_getprop(iparent, "#interrupt-cells", &icells, 4) != 4)
			return -1;
d614 8
a621 1
			*intr = *mp;
d624 2
a625 2
		mp += icells;
		len -= icells * 4;
a626 1
	return -1;
d644 1
d652 18
a672 5
	/* program the interrupt line register with the value
	 * found in openfirmware
	 */
	if (find_node_intr(node, &addr[0].phys_hi, &irq) == -1)
		return;
d675 2
a676 2
#if 0
	printf("changing interrupt from %d to %d\n",
a1022 4
#if 0
	return isabr_intr_establish(NULL, ih, IST_LEVEL, level, func, arg,
		name);
#endif
a1030 13

#if 0
void
mpc_print_pci_stat()
{
	u_int32_t stat;

	stat = mpc_cfg_read_4(cp, MPC106_PCI_CMD);
	printf("pci: status 0x%08x.\n", stat);
	stat = mpc_cfg_read_2(cp, MPC106_PCI_STAT);
	printf("pci: status 0x%04x.\n", stat);
}
#endif
@


1.5
log
@Unbreak gm0. regression test should be done next time...
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.3 2001/11/06 19:53:15 miod Exp $ */
d49 1
a834 1

d839 4
d863 7
d875 2
@


1.4
log
@From NetBSD:
Attempt to deal with pci-pci bridges and the irq handling. It is incorrect,
but allows one port of a 4 port hme card to work.
@
text
@a576 1
	char name[32];
d598 1
a598 1
			goto nomap;
a609 28

        /*
         * If the node has no interrupt property and the parent is a
         * pci-bridge, use parent's interrupt.  This occurs on a PCI
         * slot.  (e.g. AHA-3940)
         */
        memset(name, 0, sizeof(name));
        OF_getprop(parent, "name", name, sizeof(name));
        if (strcmp(name, "pci-bridge") == 0) {
                len = OF_getprop(parent, "AAPL,interrupts", intr, 4) ;
                if (len == 4)
                        return len;
                /*
                 * XXX I don't know what is the correct local address.
                 * XXX Use the first entry for now.
                 */
                len = OF_getprop(parent, "interrupt-map", map, sizeof(map));
                if (len >= 36) {
                        addr = &map[5];
                        return find_node_intr(parent, addr, intr);
                }
        }

        /* XXX This may be wrong... */
        len = OF_getprop(node, "interrupts", intr, 4) ;
        if (len == 4)
                return len;

@


1.4.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.6 2002/01/26 20:52:59 drahn Exp $ */
a48 1
#include <machine/pcb.h>
d577 1
d599 1
a599 1
			return -1;
d611 28
d863 1
a867 4
	faultbuf env;
	void *oldh;


a887 7
	oldh = curpcb->pcb_onfault;
	if (setfault(env)) {
		/* we faulted during the read? */
		curpcb->pcb_onfault = oldh;
		return 0xffffffff;
	}

a892 2

	curpcb->pcb_onfault = oldh;
@


1.4.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.4.2.1 2002/01/31 22:55:14 niklas Exp $ */
d67 2
a68 2
int	 mpcpcibrmatch(struct device *, void *, void *);
void	 mpcpcibrattach(struct device *, struct device *, void *);
d70 19
a88 19
void	 mpc_attach_hook(struct device *, struct device *,
				struct pcibus_attach_args *);
int	 mpc_bus_maxdevs(void *, int);
pcitag_t mpc_make_tag(void *, int, int, int);
void	 mpc_decompose_tag(void *, pcitag_t, int *, int *, int *);
pcireg_t mpc_conf_read(void *, pcitag_t, int);
void	 mpc_conf_write(void *, pcitag_t, int, pcireg_t);

int      mpc_intr_map(void *, pcitag_t, int, int, pci_intr_handle_t *);
const char *mpc_intr_string(void *, pci_intr_handle_t);
int	 mpc_intr_line(void *, pci_intr_handle_t);
void     *mpc_intr_establish(void *, pci_intr_handle_t,
            int, int (*func)(void *), void *, char *);
void     mpc_intr_disestablish(void *, void *);
int      mpc_ether_hw_addr(struct ppc_pci_chipset *, u_int8_t *);
u_int32_t mpc_gen_config_reg(void *cpv, pcitag_t tag, int offset);
int	of_ether_hw_addr(struct ppc_pci_chipset *, u_int8_t *);
int	find_node_intr (int parent, u_int32_t *addr, u_int32_t *intr);
u_int32_t pci_iack(void);
d98 1
a98 1
static int      mpcpcibrprint(void *, const char *pnp);
d521 8
a528 7
			char name[32];
			int len;
			len = OF_getprop(node, "name", name,
				sizeof(name));
			name[len] = 0;
#ifdef DEBUG_FIXUP
			printf("checking node %s", name);
d530 1
d569 3
a571 1
find_node_intr(int parent, u_int32_t *addr, u_int32_t *intr)
d573 3
a575 3
	int iparent, len, mlen, n_mlen;
	int match, i, step;
	u_int32_t map[144], *mp, *mp1;
d577 5
d583 1
a586 3
#ifdef DEBUG_FIXUP
	printf("parent %x len %x mlen %x\n", parent, len, mlen);
#endif
d589 1
a589 2
	n_mlen = mlen/sizeof(u_int32_t);
	for (i = 0; i < n_mlen; i++) {
a592 16
	/* calculate step size of interrupt-map
	 * -- assumes that iparent will be same for all nodes
	 */
	iparent = mp[n_mlen];
	step = 0;
	for (i = (n_mlen)+1; i < len; i++) {
		if (mp[i] == iparent) {
			step = i - (n_mlen);
			break;
		}
	}
	if (step == 0) {
		/* unable to determine step size */
		return -1;
	}

a593 5
#ifdef DEBUG_FIXUP
		printf ("[%x %x %x %x] [%x %x %x %x] %x\n",
		    maskedaddr[0], maskedaddr[1], maskedaddr[2], maskedaddr[3],
		    mp[0], mp[1], mp[2], mp[3], step);
#endif
d595 5
a599 1
		mp1 = mp + n_mlen;
d603 1
a603 8
			if (step == 9) {
				/* pci-pci bridge */
				iparent = *mp1;
				/* recurse with new 'addr' */
				return find_node_intr(iparent, &mp1[1], intr);
			} else {
				*intr = mp1[1];
			}
d606 2
a607 2
		len -= step * sizeof(u_int32_t);
		mp += step;
d609 1
a626 1
	int parent;
d634 3
a636 14

	/* if this node has a AAPL,interrupts property, firmware
	 * has intialized the register correctly.
	 */
	len = OF_getprop(node, "AAPL,interrupts", &intr, 4);
	if (len != 4) {

		parent = OF_parent(node);

		/* we want the first interrupt, set size_hi to 1 */
		addr[0].size_hi = 1;
		if (find_node_intr(parent, &addr[0].phys_hi, &irq) == -1)
			return;
	}
d640 2
a641 4

	tag = pci_make_tag(pc, pcibus(addr[0].phys_hi),
		pcidev(addr[0].phys_hi),
		pcifunc(addr[0].phys_hi));
d644 2
a645 2
#ifdef DEBUG_FIXUP
	printf("changing interrupt from %x to %x\n",
d668 2
a669 2
 *  Get PCI physical address from given virtual address.
 *  XXX Note that cross page boundaries are *not* guaranteed to work!
d678 1
a678 1
	if (va < VM_MIN_KERNEL_ADDRESS)
d986 1
a986 1
	int (*func)(void *);
d992 4
d1004 13
@


1.4.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.4.2.2 2002/06/11 03:36:34 art Exp $ */
d242 1
a242 1
				panic("mpcpcibus: unable to map self");
d255 1
a255 1
				panic("mpcpcibus: unable to map self");
d260 1
a260 1
				panic("mpcpcibus: unable to map self");
a369 1
				sc->sc_membus_space.bus_io = 0;
a371 1
				sc->sc_iobus_space.bus_io = 1;
d448 1
a448 1
#ifdef DEBUG_FIXUP
d463 1
a463 1
				panic("mpcpcibus: unable to map self");
d468 1
a468 1
				panic("mpcpcibus: unable to map self");
d495 3
a497 1
			pci_addr_fixup(sc, &lcp->lc_pc, 32);
d526 3
d577 3
d604 5
d675 5
d692 1
a692 1
	if (pnp)
d731 2
a732 1
	for (node = OF_child(of_node); node; node = nn) {
d738 4
a741 4

		len = OF_getprop(node, "local-mac-address", laddr,
		    sizeof laddr);
		if (sizeof (laddr) == len) {
d744 1
d845 1
a845 1
			reg =  tag | offset | 1;
d875 1
a875 1
	if (offset & 3 || offset < 0 || offset >= 0x100) {
d885 1
a885 1
		return(~0);
d988 1
a988 1
	if (!error)
a1127 7
}

int
pci_intr_line(ih)
	pci_intr_handle_t ih;
{
	return (ih);
@


1.4.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d643 1
a643 1
	 * has initialized the register correctly.
d877 1
a877 1
	if (setfault(&env)) {
d982 1
a982 1
	snprintf(str, sizeof str, "irq %d", ih);
@


1.3
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.2 2001/09/21 02:11:58 miod Exp $ */
d577 1
d599 1
a599 1
			return -1;
d611 28
@


1.2
log
@phys_map declaration comes from <vm/vm.h>, no need to declare it locally.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.1 2001/09/01 15:55:17 drahn Exp $ */
d46 1
a46 1
#include <vm/vm.h>
@


1.2.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.2.4.2
log
@Merge in -current
@
text
@d46 1
a46 1
#include <uvm/uvm_extern.h>
@


1.2.4.3
log
@Merge in trunk
@
text
@a48 1
#include <machine/pcb.h>
d86 1
a86 1
int	find_node_intr (int parent, u_int32_t *addr, u_int32_t *intr);
d520 8
a527 7
			char name[32];
			int len;
			len = OF_getprop(node, "name", name,
				sizeof(name));
			name[len] = 0;
#ifdef DEBUG_FIXUP
			printf("checking node %s", name);
d529 1
d568 3
a570 1
find_node_intr(int parent, u_int32_t *addr, u_int32_t *intr)
d572 3
a574 3
	int iparent, len, mlen, n_mlen;
	int match, i, step;
	u_int32_t map[144], *mp, *mp1;
d576 5
d582 1
a585 3
#ifdef DEBUG_FIXUP
	printf("parent %x len %x mlen %x\n", parent, len, mlen);
#endif
d588 1
a588 2
	n_mlen = mlen/sizeof(u_int32_t);
	for (i = 0; i < n_mlen; i++) {
a591 16
	/* calculate step size of interrupt-map
	 * -- assumes that iparent will be same for all nodes
	 */
	iparent = mp[n_mlen];
	step = 0;
	for (i = (n_mlen)+1; i < len; i++) {
		if (mp[i] == iparent) {
			step = i - (n_mlen);
			break;
		}
	}
	if (step == 0) {
		/* unable to determine step size */
		return -1;
	}

a592 5
#ifdef DEBUG_FIXUP
		printf ("[%x %x %x %x] [%x %x %x %x] %x\n",
		    maskedaddr[0], maskedaddr[1], maskedaddr[2], maskedaddr[3],
		    mp[0], mp[1], mp[2], mp[3], step);
#endif
d594 5
a598 1
		mp1 = mp + n_mlen;
d602 1
a602 8
			if (step == 9) {
				/* pci-pci bridge */
				iparent = *mp1;
				/* recurse with new 'addr' */
				return find_node_intr(iparent, &mp1[1], intr);
			} else {
				*intr = mp1[1];
			}
d605 2
a606 2
		len -= step * sizeof(u_int32_t);
		mp += step;
d608 1
a625 1
	int parent;
d633 3
a635 14

	/* if this node has a AAPL,interrupts property, firmware
	 * has intialized the register correctly.
	 */
	len = OF_getprop(node, "AAPL,interrupts", &intr, 4);
	if (len != 4) {

		parent = OF_parent(node);

		/* we want the first interrupt, set size_hi to 1 */
		addr[0].size_hi = 1;
		if (find_node_intr(parent, &addr[0].phys_hi, &irq) == -1)
			return;
	}
d639 2
a640 4

	tag = pci_make_tag(pc, pcibus(addr[0].phys_hi),
		pcidev(addr[0].phys_hi),
		pcifunc(addr[0].phys_hi));
d643 2
a644 2
#ifdef DEBUG_FIXUP
	printf("changing interrupt from %x to %x\n",
d834 1
a838 4
	faultbuf env;
	void *oldh;


a858 7
	oldh = curpcb->pcb_onfault;
	if (setfault(env)) {
		/* we faulted during the read? */
		curpcb->pcb_onfault = oldh;
		return 0xffffffff;
	}

a864 2
	curpcb->pcb_onfault = oldh;

d979 4
d991 13
@


1.2.4.4
log
@Merge in -current from about a week ago
@
text
@d67 2
a68 2
int	 mpcpcibrmatch(struct device *, void *, void *);
void	 mpcpcibrattach(struct device *, struct device *, void *);
d70 17
a86 17
void	 mpc_attach_hook(struct device *, struct device *,
				struct pcibus_attach_args *);
int	 mpc_bus_maxdevs(void *, int);
pcitag_t mpc_make_tag(void *, int, int, int);
void	 mpc_decompose_tag(void *, pcitag_t, int *, int *, int *);
pcireg_t mpc_conf_read(void *, pcitag_t, int);
void	 mpc_conf_write(void *, pcitag_t, int, pcireg_t);

int      mpc_intr_map(void *, pcitag_t, int, int, pci_intr_handle_t *);
const char *mpc_intr_string(void *, pci_intr_handle_t);
int	 mpc_intr_line(void *, pci_intr_handle_t);
void     *mpc_intr_establish(void *, pci_intr_handle_t,
            int, int (*func)(void *), void *, char *);
void     mpc_intr_disestablish(void *, void *);
int      mpc_ether_hw_addr(struct ppc_pci_chipset *, u_int8_t *);
u_int32_t mpc_gen_config_reg(void *cpv, pcitag_t tag, int offset);
int	of_ether_hw_addr(struct ppc_pci_chipset *, u_int8_t *);
d88 1
a88 1
u_int32_t pci_iack(void);
d98 1
a98 1
static int      mpcpcibrprint(void *, const char *pnp);
d1017 1
a1017 1
	int (*func)(void *);
@


1.2.4.5
log
@Sync the SMP branch with 3.3
@
text
@d242 1
a242 1
				panic("mpcpcibus: unable to map self");
d255 1
a255 1
				panic("mpcpcibus: unable to map self");
d260 1
a260 1
				panic("mpcpcibus: unable to map self");
a369 1
				sc->sc_membus_space.bus_io = 0;
a371 1
				sc->sc_iobus_space.bus_io = 1;
d448 1
a448 1
#ifdef DEBUG_FIXUP
d463 1
a463 1
				panic("mpcpcibus: unable to map self");
d468 1
a468 1
				panic("mpcpcibus: unable to map self");
d495 3
a497 1
			pci_addr_fixup(sc, &lcp->lc_pc, 32);
d526 3
d577 3
d604 5
d654 1
a654 1
	 * has initialized the register correctly.
d675 5
d692 1
a692 1
	if (pnp)
d699 2
a700 2
 *  Get PCI physical address from given virtual address.
 *  XXX Note that cross page boundaries are *not* guaranteed to work!
d709 1
a709 1
	if (va < VM_MIN_KERNEL_ADDRESS)
d731 2
a732 1
	for (node = OF_child(of_node); node; node = nn) {
d738 4
a741 4

		len = OF_getprop(node, "local-mac-address", laddr,
		    sizeof laddr);
		if (sizeof (laddr) == len) {
d744 1
d845 1
a845 1
			reg =  tag | offset | 1;
d875 1
a875 1
	if (offset & 3 || offset < 0 || offset >= 0x100) {
d885 1
a885 1
		return(~0);
d895 1
a895 1
	if (setfault(&env)) {
d988 1
a988 1
	if (!error)
a1127 7
}

int
pci_intr_line(ih)
	pci_intr_handle_t ih;
{
	return (ih);
@


1.2.4.6
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.2.4.5 2003/03/27 23:29:46 niklas Exp $ */
d982 1
a982 1
	snprintf(str, sizeof str, "irq %d", ih);
@


1.2.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 *
d14 6
d67 2
a68 2
int	mpcpcibrmatch(struct device *, void *, void *);
void	mpcpcibrattach(struct device *, struct device *, void *);
d70 1
a70 1
void	mpc_attach_hook(struct device *, struct device *,
d72 1
a72 1
int	mpc_bus_maxdevs(void *, int);
d74 1
a74 1
void	mpc_decompose_tag(void *, pcitag_t, int *, int *, int *);
d76 1
a76 1
void	mpc_conf_write(void *, pcitag_t, int, pcireg_t);
d80 1
a80 1
int	mpc_intr_line(void *, pci_intr_handle_t);
a89 2
void fix_node_irq(int node, struct pcibus_attach_args *pba);

d113 2
a114 2
	u_int32_t addr;	/* offset */
	u_int32_t data;	/* offset */
d147 3
a149 1
srom_crc32(const unsigned char *databuf, size_t datalen)
d160 3
a162 1
mpcpcibrmatch(struct device *parent, void *match, void *aux)
d175 2
d179 3
a181 1
mpcpcibrattach(struct device *parent, struct device *self, void *aux)
d207 1
a207 2
				case (PCI_VENDOR_MOT |
				    (PCI_PRODUCT_MOT_MPC105 <<16)):
d210 1
a210 2
				case (PCI_VENDOR_MOT |
				    (PCI_PRODUCT_MOT_MPC106 <<16)):
d240 2
a241 1
			    &lcp->ioh_cf8) != 0 )
d243 1
a243 1

d247 1
a247 1
			    MPC106_P_PCI_MEM_SPACE_MAP_B;
d250 1
a250 1
			    MPC106_P_PCI_IO_SPACE_MAP_B;
d253 2
a254 1
			    NBPG, 0, &lcp->ioh_cf8) != 0 )
d256 1
a256 1

d258 2
a259 1
			    NBPG, 0, &lcp->ioh_cfc) != 0 )
d261 1
d285 1
a285 1
		if (map == 1)
d287 1
a287 1
		else
d289 1
d332 1
a332 1
			    sizeof (compat));
d338 1
a338 1
					    " found\n");
d344 1
a344 1
					    " %s found\n", compat);
d350 3
a352 1
			    range_store, sizeof (range_store))) <= 0) {
d377 2
a378 1
				for (i = 0; i < rangelen ; i++) {
d387 1
a387 1
					    prange[found].base;
d389 1
a389 1
					    prange[found].size;
d402 2
a403 1
				for (i = 0; i < rangelen ; i++) {
d413 4
a416 3
							    prange[i].base) {
								size +=
								 prange[i].size;
d436 2
a437 1
				    == 0) {
d441 1
a441 1
					    config_offsets[i].config_type;
d447 1
a447 1
				    " compatible %s\n", compat);
d451 7
a457 7
			printf(" mem base %x sz %x io base %x sz %x\n"
			    " config addr %x config data %x\n",
			    sc->sc_membus_space.bus_base,
			    sc->sc_membus_space.bus_size,
			    sc->sc_iobus_space.bus_base,
			    sc->sc_iobus_space.bus_size,
			    addr_offset, data_offset);
d460 2
d464 1
d466 1
a466 1

d469 1
d471 2
a473 1
			of_node = ca->ca_node;
d495 1
a495 1
			    mpc_cfg_read_1(lcp, MPC106_PCI_REVID));
d508 1
d519 2
a520 1
		for (node = OF_child(of_node); node; node = nn) {
d524 1
a524 1
			    sizeof(name));
d529 1
a529 1
			if ((nn = OF_child(node)) != 0)
d531 1
a531 1

a575 1

d577 1
a577 1
	for (i = 0; i < n_mlen; i++)
d579 1
a579 1

d586 1
a586 1
	for (i = (n_mlen)+1; i < len; i++)
d591 1
d608 1
a608 1
			} else
d610 1
d621 3
a623 1
fix_node_irq(int node, struct pcibus_attach_args *pba)
d638 1
a638 1
	if (len < sizeof(addr[0]))
d640 1
d660 2
a661 1
	    pcidev(addr[0].phys_hi), pcifunc(addr[0].phys_hi));
d670 3
a672 1
mpcpcibrprint(void *aux, const char *pnp)
d688 2
a689 1
vtophys(paddr_t pa)
d702 3
a704 2
mpc_attach_hook(struct device *parent, struct device *self,
    struct pcibus_attach_args *pba)
d747 3
a749 1
mpc_ether_hw_addr(struct ppc_pci_chipset *p, u_int8_t *s)
d756 3
a758 1
mpc_bus_maxdevs(void *cpv, int busno)
d768 3
a770 1
mpc_make_tag(void *cpv, int bus, int dev, int fnc)
d776 4
a779 1
mpc_decompose_tag(void *cpv, pcitag_t tag, int *busp, int *devp, int *fncp)
d790 4
a793 1
mpc_gen_config_reg(void *cpv, pcitag_t tag, int offset)
d798 5
d809 1
a809 1
			if (dev < 11)
d811 1
d821 3
a823 2
			if (dev > 15)
				return 0xffffffff;
d842 4
a845 1
mpc_conf_read(void *cpv, pcitag_t tag, int offset)
d855 2
d866 1
a866 1
	if (reg == 0xffffffff)
d868 1
d870 1
a870 1
	if ((cp->config_type & 2) && (offset & 0x04))
d872 1
d907 5
a911 1
mpc_conf_write(void *cpv, pcitag_t tag, int offset, pcireg_t data)
d921 1
a921 1
	if (reg == 0xffffffff)
d923 2
a924 2

	if ((cp->config_type & 2) && (offset & 0x04))
d926 1
a926 1

d952 5
a956 2
mpc_intr_map(void *lcv, pcitag_t bustag, int buspin, int  line,
    pci_intr_handle_t *ihp)
d961 4
a964 2
        if (buspin == 0)
                error = 1; /* No IRQ used. */
d976 3
a978 1
mpc_intr_string(void *lcv, pci_intr_handle_t ih)
d982 1
a982 1
	snprintf(str, sizeof str, "irq %ld", ih);
d987 3
a989 1
mpc_intr_line(void *lcv, pci_intr_handle_t ih)
d995 7
a1001 2
mpc_intr_establish(void *lcv, pci_intr_handle_t ih, int level,
    int (*func)(void *), void *arg, char *name)
d1008 2
a1009 1
mpc_intr_disestablish(void *lcv, void *cookie)
d1027 4
a1030 1
mpc_cfg_write_1(struct pcibr_config *cp, u_int32_t reg, u_int8_t val)
d1034 2
a1035 1
	bus_space_write_4(cp->lc_iot, cp->ioh_cf8, 0, MPC106_REGOFFS(reg));
d1041 4
a1044 1
mpc_cfg_write_2(struct pcibr_config *cp, u_int32_t reg, u_int16_t val)
d1054 4
a1057 1
mpc_cfg_write_4(struct pcibr_config *cp, u_int32_t reg, u_int32_t val)
d1068 3
a1070 1
mpc_cfg_read_1(struct pcibr_config *cp, u_int32_t reg)
d1083 3
a1085 1
mpc_cfg_read_2(struct pcibr_config *cp, u_int32_t reg)
d1098 3
a1100 1
mpc_cfg_read_4(struct pcibr_config *cp, u_int32_t reg)
d1113 2
a1114 1
pci_intr_line(pci_intr_handle_t ih)
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/pci to macppc/pci

The file pci_machdep.h was not moved in this conversion.
It needs to be check if it is correct that should be the only shared
powerpc/pci file. Or if that file too should be MD, or more files MI.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpcpcibus.c,v 1.33 2001/08/17 22:26:58 mickey Exp $ */
a64 1
extern vm_map_t phys_map;
@

