head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.38
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.34
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.30
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.32
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.24
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.28
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.26
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.22
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.20
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.18
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.16
	OPENBSD_5_0:1.10.0.14
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.12
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.10
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.6
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.8
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.6
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.3.0.10
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.8
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.6
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.10
date	2008.04.25.14.51.35;	author jmc;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.01.21.28.56;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2007.02.05.06.46.56;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.10.08.10.49;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.22.21.25.02;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.07.17.21.12;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2005.06.08.19.08.23;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.05.22.40.48;	author drahn;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2003.06.05.18.29.06;	author grange;	state Exp;
branches;
next	1.1;

1.1
date	2003.06.05.05.17.04;	author drahn;	state Exp;
branches;
next	;

1.3.2.1
date	2003.06.07.10.07.08;	author ho;	state Exp;
branches;
next	;


desc
@@


1.10
log
@neccessary -> necessary; from Pierre Riteau
@
text
@/*	$OpenBSD: kauaiata.c,v 1.9 2007/03/01 21:28:56 drahn Exp $ */

/*
 * Copyright (c) 2003 Dale Rahn
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * Glue to to attach kauai ata to the macobio_wdc
 * which it heavily resembles.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/bus.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <dev/ofw/openfirm.h>

#include <machine/autoconf.h>


struct kauaiata_softc {
	struct device sc_dev;
	struct ppc_bus_space sc_membus_space;
	/* XXX */
};

int kauaiatamatch(struct device *parent, void *match, void *aux);
void kauaiataattach(struct device *parent, struct device *self, void *aux);
int kauaiata_print(void *aux, const char *dev);


struct cfattach kauaiata_ca = {
	sizeof(struct kauaiata_softc), kauaiatamatch, kauaiataattach,
};

struct cfdriver kauaiata_cd = {
	NULL, "kauaiata", DV_DULL,
};

int
kauaiatamatch(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;

	/*
	 * Match the adapter
	 * XXX match routine??
	 */
	switch(PCI_VENDOR(pa->pa_id)) {
	case PCI_VENDOR_APPLE:
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_APPLE_UNINORTH_ATA:
		case PCI_PRODUCT_APPLE_INTREPID_ATA:
		case PCI_PRODUCT_APPLE_INTREPID2_ATA:
		case PCI_PRODUCT_APPLE_K2_ATA:
		case PCI_PRODUCT_APPLE_SHASTA_ATA:
			return (1);
		}
		break;
	}
	return 0;
}

void
kauaiataattach(struct device *parent, struct device *self, void *aux)
{
	int node;
	struct confargs ca;
	int namelen;
	u_int32_t reg[20];
	char name[32];
	int32_t intr[8];

	struct kauaiata_softc *sc = (struct kauaiata_softc *)self;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;

	/* XXX not necessarily the right device */
	node = OF_finddevice("uata");
	if (node == -1)
		node = OF_finddevice("/pci@@f4000000/ata-6");

	if (node == -1) {
		printf("\n");
		return;
	}

	/*
	 * XXX - need to compare node and PCI id to verify this is the 
	 * correct device.
	 */

	ca.ca_nreg  = OF_getprop(node, "reg", reg, sizeof(reg));

	/*
	 * The PCI Interrupt Configuration Registers seems to be
	 * hardwired to 0.  Get the interrupt line from OpenFirmware.
	 */
	/* XXX */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_APPLE &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_APPLE_SHASTA_ATA) {
		ca.ca_nintr = OF_getprop(node, "interrupts",
		    intr, sizeof intr);
	} else {
		ca.ca_nintr = 4;
		intr[0] = 0x27;
	}

	namelen = OF_getprop(node, "name", name, sizeof(name));
	if ((namelen < 0) || (namelen >= sizeof(name))) {
		printf(" bad name prop len %x\n", namelen);
		return;
	}

	name[namelen] = 0; /* name property may not be null terminated */

	/* config read */
	sc->sc_membus_space.bus_base =
	    pci_conf_read(pc, pa->pa_tag, PCI_MAPREG_START);

	/* make sure device memory access is enabled */
	{
		bus_space_tag_t		iot;
		bus_space_handle_t	ioh;
		bus_size_t		size;

		if (pci_mapreg_map(pa, PCI_MAPREG_START, PCI_MAPREG_TYPE_MEM, 0,
		    &iot, &ioh, NULL, &size, 0)) {
			printf(": mapping memory failed\n");
			return;
		}
			
		bus_space_unmap(iot, ioh, size);
	}
#if 0
	pci_conf_write(pc, pa->pa_tag, PCI_MAPREG_START, 0xffffffff);
	size =  ~(pci_conf_read(pc, pa->pa_tag, PCI_MAPREG_START));
	pci_conf_write(pc, pa->pa_tag, PCI_MAPREG_START,
		sc->sc_membus_space.bus_base);
#endif

	ca.ca_baseaddr = sc->sc_membus_space.bus_base;

	ca.ca_name = name;
	ca.ca_iot = &sc->sc_membus_space;
	ca.ca_dmat = pa->pa_dmat;

	ca.ca_reg = reg;
	reg[0] = 0x2000; /* offset to wdc registers */
	reg[1] = reg[9] - 0x2000; /* map size of wdc registers */
	reg[2] = 0x1000; /* offset to dbdma registers */
	reg[3] = 0x1000; /* map size of dbdma registers */
	ca.ca_intr = intr;

	printf("\n");

	config_found(self, &ca, kauaiata_print);
}

int
kauaiata_print(void *aux, const char *dev)
{
	return QUIET;
}
@


1.9
log
@If the kauai is not found in openfirmware, abort the config. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kauaiata.c,v 1.8 2007/02/05 06:46:56 drahn Exp $ */
d106 1
a106 1
	/* XXX not neccessarily the right device */
@


1.8
log
@Map the pci space registers, so that the MEMORY enable gets turned on,
otherwise if openfirmware has not touched the device yet, the kernel
faults on the alternate mappings that are created. ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kauaiata.c,v 1.7 2006/04/10 08:10:49 brad Exp $ */
d110 5
@


1.7
log
@recognize the Intrepid 2 ATA controller.
@
text
@d1 1
a1 1
/*	$OpenBSD: kauaiata.c,v 1.6 2005/10/22 21:25:02 kettenis Exp $ */
d143 15
@


1.6
log
@Make sure we use the corrrect interrupt line on Shasta.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kauaiata.c,v 1.5 2005/10/07 17:21:12 deraadt Exp $ */
d82 1
@


1.5
log
@match uata devices found on more modern (ie. G5) machines.  parts
from kettenis, ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: kauaiata.c,v 1.4 2005/06/08 19:08:23 drahn Exp $ */
d117 13
a129 5
	intr[0] = PCI_INTERRUPT_LINE(pci_conf_read(pc, pa->pa_tag,
	    PCI_INTERRUPT_REG));
	ca.ca_nintr = 4; /* claim to have 4 bytes of interrupt info */
	/* This needs to come from INTERRUPT REG above, but is not filled out */
	intr[0] = 0x27;
@


1.4
log
@Remove the bus_reverse field out of the powerpc bus structure, originally
it was there so that big endian and little endian devices could both be
present, however that is not the case on the macppc machines.
Cleans up code, shrinks the kernel. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kauaiata.c,v 1.3 2003/06/05 22:40:48 drahn Exp $ */
d82 2
d105 4
a108 7
	/* XXX assumes that this is /pci@@f400000/ata-6 */

	/*
vendor 0x106b product 0x003b (class undefined unknown subclass 0x00, rev 0x00) at pci2 dev 13 function 0 not configured
	*/

	node = OF_finddevice("/pci@@f4000000/ata-6");
@


1.3
log
@Cleanup and enable kauaiata DMA. Tables should be mostly sane
Please _TEST_.
@
text
@d1 1
a1 1
/*	$OpenBSD: kauaiata.c,v 1.2 2003/06/05 18:29:06 grange Exp $ */
a142 2

	sc->sc_membus_space.bus_reverse = 1;
@


1.3.2.1
log
@dummy message
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.2
log
@Cleanup:
- don't include both sys/types.h and sys/param.h
- spaces vs tab
- kill trailing spaces
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kauaiata.c,v 1.1 2003/06/05 05:17:04 drahn Exp $ */
d111 5
a116 1
	printf("nreg %x\n", ca.ca_nreg);
d120 3
a122 2
	ca.ca_nintr = 4; /* XXX */
	intr[0] = 0x27; /* XXXX */
d125 2
a126 3
	if (namelen < 0)
		return;
	if (namelen >= sizeof(name))
d128 1
d130 1
a130 1
	name[namelen] = 0;
d142 1
a142 1
	ca.ca_baseaddr = 0;
d151 4
a154 4
	reg[0] = sc->sc_membus_space.bus_base + 0x2000;
	reg[1] = reg[9]; /* XXX */
	reg[2] = sc->sc_membus_space.bus_base + 0x1000;
	reg[3] = 0x1000; /* XXX */
@


1.1
log
@ATA100 driver for apple's new machines, aka kauai.
This is working with udma on a 12" PBG4, but dma is disabled for now,
too many hardcoded values. 'wdc...flags 0x1' will enable it.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d30 1
a30 1
 *  Glue to to attach kauai ata to the macobio_wdc 
a33 1
#include <sys/types.h>
d37 1
a37 1
  
d61 1
a61 1
        sizeof(struct kauaiata_softc), kauaiatamatch, kauaiataattach,
d65 1
a65 1
        NULL, "kauaiata", DV_DULL,
d128 1
a128 1
	sc->sc_membus_space.bus_base = 
@

