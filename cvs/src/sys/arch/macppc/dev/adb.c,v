head	1.41;
access;
symbols
	OPENBSD_6_1:1.41.0.6
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.41.0.2
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.39.0.6
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.34.0.8
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.6
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.4
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.29.0.10
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.8
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.4
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.6
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.27.0.6
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.27.0.4
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.7
	UBC:1.3.0.6
	UBC_BASE:1.3
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.41
date	2016.03.14.23.08.05;	author krw;	state Exp;
branches;
next	1.40;
commitid	kCz5QgxnxRMKOzNf;

1.40
date	2015.06.24.11.58.06;	author mpi;	state Exp;
branches;
next	1.39;
commitid	ydQ89S8LGKdOdYT1;

1.39
date	2013.08.10.08.13.32;	author mpi;	state Exp;
branches;
next	1.38;

1.38
date	2013.07.06.14.28.48;	author mpi;	state Exp;
branches;
next	1.37;

1.37
date	2013.04.23.07.38.05;	author mpi;	state Exp;
branches;
next	1.36;

1.36
date	2013.03.10.11.26.34;	author mpi;	state Exp;
branches;
next	1.35;

1.35
date	2013.03.09.11.33.25;	author mpi;	state Exp;
branches;
next	1.34;

1.34
date	2011.06.16.10.51.48;	author mpi;	state Exp;
branches;
next	1.33;

1.33
date	2011.06.16.10.50.16;	author mpi;	state Exp;
branches;
next	1.32;

1.32
date	2011.06.16.10.44.33;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2011.06.15.21.32.04;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2011.05.14.12.01.16;	author mpi;	state Exp;
branches;
next	1.29;

1.29
date	2009.02.01.17.04.26;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2009.01.29.21.17.49;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2007.04.23.16.27.20;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.22.22.31.14;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.10.17.47.54;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2007.03.13.20.56.55;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2007.03.04.15.33.31;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.26.00.11.49;	author gwk;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.18.19.33.48;	author gwk;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.12.21.01.11;	author gwk;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.07.20.00.18;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.18.23.21.17;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.08.17.25.05;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.21.18.50.52;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.21.18.16.37;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.16.12.28.54;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.21.22.07.45;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.15.15.01.23;	author martin;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.30.01.28.05;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.06.01.08.46;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.16.03.54.48;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.16.03.31.25;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.15.02.02.43;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.07.07.14.48;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.03.14.45.37;	author drahn;	state Exp;
branches
	1.3.4.1
	1.3.6.1;
next	1.2;

1.2
date	2001.09.01.17.43.08;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.50.00;	author drahn;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.01.15;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	;

1.3.6.1
date	2002.06.11.03.36.33;	author art;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2002.10.29.00.28.05;	author art;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@/*	$OpenBSD: adb.c,v 1.40 2015/06/24 11:58:06 mpi Exp $	*/
/*	$NetBSD: adb.c,v 1.6 1999/08/16 06:28:09 tsubai Exp $	*/
/*	$NetBSD: adb_direct.c,v 1.14 2000/06/08 22:10:45 tsubai Exp $	*/

/*
 * Copyright (C) 1996, 1997 John P. Wittkoski
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by John P. Wittkoski.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (C) 1994	Bradley A. Grantham
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code is rather messy, but I don't have time right now
 * to clean it up as much as I would like.
 * But it works, so I'm happy. :-) jpw
 */

/*
 * TO DO:
 *  - We could reduce the time spent in the adb_intr_* routines
 *    by having them save the incoming and outgoing data directly
 *    in the adbInbound and adbOutbound queues, as it would reduce
 *    the number of times we need to copy the data around. It
 *    would also make the code more readable and easier to follow.
 *  - (Related to above) Use the header part of adbCommand to
 *    reduce the number of copies we have to do of the data.
 *  - (Related to above) Actually implement the adbOutbound queue.
 *    This is fairly easy once you switch all the intr routines
 *    over to using adbCommand structs directly.
 *  - There is a bug in the state machine of adb_intr_cuda
 *    code that causes hangs, especially on 030 machines, probably
 *    because of some timing issues. Because I have been unable to
 *    determine the exact cause of this bug, I used the timeout function
 *    to check for and recover from this condition. If anyone finds
 *    the actual cause of this bug, the calls to timeout and the
 *    adb_cuda_tickle routine can be removed.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/fcntl.h>
#include <sys/poll.h>
#include <sys/selinfo.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/timeout.h>
#include <sys/systm.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>
#include <dev/ofw/openfirm.h>

#include <dev/adb/adb.h>
#include <macppc/dev/adbvar.h>
#include <macppc/dev/pm_direct.h>
#include <macppc/dev/viareg.h>

#include "apm.h"

#define printf_intr printf

#ifdef DEBUG
#ifndef ADB_DEBUG
#define ADB_DEBUG
#endif
#endif

int	adb_polling;		/* Are we polling?  (Debugger mode) */
#ifdef ADB_DEBUG
int	adb_debug;		/* Output debugging messages */
#endif /* ADB_DEBUG */

/* some misc. leftovers */
#define vPB		0x0000
#define vPB3		0x08
#define vPB4		0x10
#define vPB5		0x20
#define vSR_INT		0x04
#define vSR_OUT		0x10

/* the type of ADB action that we are currently performing */
#define ADB_ACTION_NOTREADY	0x1	/* has not been initialized yet */
#define ADB_ACTION_IDLE		0x2	/* the bus is currently idle */
#define ADB_ACTION_OUT		0x3	/* sending out a command */
#define ADB_ACTION_IN		0x4	/* receiving data */

/*
 * Shortcuts for setting or testing the VIA bit states.
 * Not all shortcuts are used for every type of ADB hardware.
 */
#define ADB_SET_STATE_IDLE_CUDA()   via_reg_or(VIA1, vBufB, (vPB4 | vPB5))
#define ADB_SET_STATE_TIP()	    via_reg_and(VIA1, vBufB, ~vPB5)
#define ADB_CLR_STATE_TIP() 	    via_reg_or(VIA1, vBufB, vPB5)
#define ADB_TOGGLE_STATE_ACK_CUDA() via_reg_xor(VIA1, vBufB, vPB4)
#define ADB_SET_STATE_ACKOFF_CUDA() via_reg_or(VIA1, vBufB, vPB4)
#define ADB_SET_SR_INPUT()	    via_reg_and(VIA1, vACR, ~vSR_OUT)
#define ADB_SET_SR_OUTPUT()	    via_reg_or(VIA1, vACR, vSR_OUT)
#define ADB_SR()		    read_via_reg(VIA1, vSR)
#define ADB_VIA_INTR_ENABLE()	    write_via_reg(VIA1, vIER, 0x84)
#define ADB_VIA_INTR_DISABLE()	    write_via_reg(VIA1, vIER, 0x04)
#define ADB_VIA_CLR_INTR()	    write_via_reg(VIA1, vIFR, 0x04)
#define ADB_INTR_IS_OFF		   (vPB3 == (read_via_reg(VIA1, vBufB) & vPB3))
#define ADB_INTR_IS_ON		   (0 == (read_via_reg(VIA1, vBufB) & vPB3))
#define ADB_SR_INTR_IS_ON	   (vSR_INT == (read_via_reg(VIA1, \
						vIFR) & vSR_INT))

/*
 * This is the delay that is required (in uS) between certain
 * ADB transactions. The actual timing delay for for each uS is
 * calculated at boot time to account for differences in machine speed.
 */
#define ADB_DELAY	150

/*
 * Maximum ADB message length; includes space for data, result, and
 * device code - plus a little for safety.
 */
#define ADB_MAX_MSG_LENGTH	16
#define ADB_MAX_HDR_LENGTH	8

#define ADB_QUEUE		32
#define ADB_TICKLE_TICKS	4

/*
 * Eventually used for two separate queues, the queue between
 * the upper and lower halves, and the outgoing packet queue.
 */
struct adbCommand {
	u_char	header[ADB_MAX_HDR_LENGTH];	/* not used yet */
	u_char	data[ADB_MAX_MSG_LENGTH];	/* packet data only */
	u_char	*saveBuf;	/* where to save result */
	u_char	*compRout;	/* completion routine pointer */
	u_char	*compData;	/* completion routine data pointer */
	u_int	cmd;		/* the original command for this data */
	u_int	unsol;		/* 1 if packet was unsolicited */
	u_int	ack_only;	/* 1 for no special processing */
};

/*
 * A few variables that we need and their initial values.
 */
int	adbHardware = ADB_HW_UNKNOWN;
int	adbActionState = ADB_ACTION_NOTREADY;
int	adbWaiting;		/* waiting for return data from the device */
int	adbWriteDelay;		/* working on (or waiting to do) a write */

int	adbWaitingCmd;		/* ADB command we are waiting for */
u_char	*adbBuffer;		/* pointer to user data area */
void	*adbCompRout;		/* pointer to the completion routine */
void	*adbCompData;		/* pointer to the completion routine data */
int	adbStarting = 1;	/* doing adb_reinit so do polling differently */

u_char	adbInputBuffer[ADB_MAX_MSG_LENGTH];	/* data input buffer */
u_char	adbOutputBuffer[ADB_MAX_MSG_LENGTH];	/* data output buffer */

int	adbSentChars;		/* how many characters we have sent */

struct	adbCommand adbInbound[ADB_QUEUE];	/* incoming queue */
int	adbInCount;			/* how many packets in in queue */
int	adbInHead;			/* head of in queue */
int	adbInTail;			/* tail of in queue */

int	tickle_count;			/* how many tickles seen for this packet? */
int	tickle_serial;			/* the last packet tickled */
int	adb_cuda_serial;		/* the current packet */
struct	timeout adb_cuda_timeout;
struct	timeout adb_softintr_timeout;
int	adbempty;			/* nonzero if no adb devices */

extern struct cfdriver adb_cd;

volatile u_char *Via1Base;

/*
 * The following are private routines.
 */
#ifdef ADB_DEBUG
void	print_single(u_char *);
#endif
void	adb_intr_cuda(void);
void	adb_soft_intr(void);
int	send_adb_cuda(u_char *, u_char *, void *, void *, int);
void	adb_cuda_tickle(void);
void	adb_pass_up(struct adbCommand *);
void	adb_op_comprout(caddr_t, caddr_t, int);
void	adb_reinit(struct adb_softc *);
int	count_adbs(struct adb_softc *);
int	get_ind_adb_info(struct adb_softc *, ADBDataBlock *, int);
int	get_adb_info(ADBDataBlock *, int);
int	adb_op(Ptr, Ptr, Ptr, short);
void	adb_hw_setup(void);
int	adb_cmd_result(u_char *);
void	setsoftadb(void);

int	adb_intr(void *arg);
void	adb_cuda_autopoll(void);
void 	adb_cuda_fileserver_mode(void);

#ifdef ADB_DEBUG
/*
 * print_single
 * Diagnostic display routine. Displays the hex values of the
 * specified elements of the u_char. The length of the "string"
 * is in [0].
 */
void
print_single(str)
	u_char *str;
{
	int x;

	if (str == NULL) {
		printf_intr("no data - null pointer\n");
		return;
	}
	if (*str == '\0') {
		printf_intr("nothing returned\n");
		return;
	}
	if (*str > 20) {
		printf_intr("ADB: ACK > 20 no way!\n");
		*str = 20;
	}
	printf_intr("(length=0x%x):", *str);
	for (x = 1; x <= *str; x++)
		printf_intr("  0x%02x", str[x]);
	printf_intr("\n");
}
#endif

void
adb_cuda_tickle(void)
{
	volatile int s;

	if (adbActionState == ADB_ACTION_IN) {
		if (tickle_serial == adb_cuda_serial) {
			if (++tickle_count > 0) {
				s = splhigh();
				adbActionState = ADB_ACTION_IDLE;
				adbInputBuffer[0] = 0;
				ADB_SET_STATE_IDLE_CUDA();
				splx(s);
			}
		} else {
			tickle_serial = adb_cuda_serial;
			tickle_count = 0;
		}
	} else {
		tickle_serial = adb_cuda_serial;
		tickle_count = 0;
	}

	timeout_add(&adb_cuda_timeout, ADB_TICKLE_TICKS);
}

/*
 * called when when an adb interrupt happens
 *
 * Cuda version of adb_intr
 * TO DO: do we want to add some calls to intr_dispatch() here to
 * grab serial interrupts?
 */
void
adb_intr_cuda(void)
{
	volatile int i, ending;
	volatile unsigned int s;
	struct adbCommand packet;

	s = splhigh();		/* can't be too careful - might be called */
				/* from a routine, NOT an interrupt */

	ADB_VIA_CLR_INTR();	/* clear interrupt */
	ADB_VIA_INTR_DISABLE();	/* disable ADB interrupt on IIs. */

switch_start:
	switch (adbActionState) {
	case ADB_ACTION_IDLE:
		/*
		 * This is an unexpected packet, so grab the first (dummy)
		 * byte, set up the proper vars, and tell the chip we are
		 * starting to receive the packet by setting the TIP bit.
		 */
		adbInputBuffer[1] = ADB_SR();
		adb_cuda_serial++;
		if (ADB_INTR_IS_OFF)	/* must have been a fake start */
			break;

		ADB_SET_SR_INPUT();
		ADB_SET_STATE_TIP();

		adbInputBuffer[0] = 1;
		adbActionState = ADB_ACTION_IN;
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("idle 0x%02x ", adbInputBuffer[1]);
#endif
		break;

	case ADB_ACTION_IN:
		adbInputBuffer[++adbInputBuffer[0]] = ADB_SR();
		/* intr off means this is the last byte (end of frame) */
		if (ADB_INTR_IS_OFF)
			ending = 1;
		else
			ending = 0;

		if (1 == ending) {	/* end of message? */
#ifdef ADB_DEBUG
			if (adb_debug) {
				printf_intr("in end 0x%02x ",
				    adbInputBuffer[adbInputBuffer[0]]);
				print_single(adbInputBuffer);
			}
#endif

			/*
			 * Are we waiting AND does this packet match what we
			 * are waiting for AND is it coming from either the
			 * ADB or RTC/PRAM sub-device? This section _should_
			 * recognize all ADB and RTC/PRAM type commands, but
			 * there may be more... NOTE: commands are always at
			 * [4], even for RTC/PRAM commands.
			 */
			/* set up data for adb_pass_up */
			memcpy(packet.data, adbInputBuffer, adbInputBuffer[0] + 1);

			if ((adbWaiting == 1) &&
			    (adbInputBuffer[4] == adbWaitingCmd) &&
			    ((adbInputBuffer[2] == 0x00) ||
			    (adbInputBuffer[2] == 0x01))) {
				packet.saveBuf = adbBuffer;
				packet.compRout = adbCompRout;
				packet.compData = adbCompData;
				packet.unsol = 0;
				packet.ack_only = 0;
				adb_pass_up(&packet);

				adbWaitingCmd = 0;	/* reset "waiting" vars */
				adbWaiting = 0;
				adbBuffer = NULL;
				adbCompRout = NULL;
				adbCompData = NULL;
			} else {
				packet.unsol = 1;
				packet.ack_only = 0;
				adb_pass_up(&packet);
			}


			/* reset vars and signal the end of this frame */
			adbActionState = ADB_ACTION_IDLE;
			adbInputBuffer[0] = 0;
			ADB_SET_STATE_IDLE_CUDA();
			/*ADB_SET_SR_INPUT();*/

			/*
			 * If there is something waiting to be sent out,
			 * the set everything up and send the first byte.
			 */
			if (adbWriteDelay == 1) {
				delay(ADB_DELAY);	/* required */
				adbSentChars = 0;
				adbActionState = ADB_ACTION_OUT;
				/*
				 * If the interrupt is on, we were too slow
				 * and the chip has already started to send
				 * something to us, so back out of the write
				 * and start a read cycle.
				 */
				if (ADB_INTR_IS_ON) {
					ADB_SET_SR_INPUT();
					ADB_SET_STATE_IDLE_CUDA();
					adbSentChars = 0;
					adbActionState = ADB_ACTION_IDLE;
					adbInputBuffer[0] = 0;
					break;
				}
				/*
				 * If we got here, it's ok to start sending
				 * so load the first byte and tell the chip
				 * we want to send.
				 */
				ADB_SET_STATE_TIP();
				ADB_SET_SR_OUTPUT();
				write_via_reg(VIA1, vSR, adbOutputBuffer[adbSentChars + 1]);
			}
		} else {
			ADB_TOGGLE_STATE_ACK_CUDA();
#ifdef ADB_DEBUG
			if (adb_debug)
				printf_intr("in 0x%02x ",
				    adbInputBuffer[adbInputBuffer[0]]);
#endif
		}
		break;

	case ADB_ACTION_OUT:
		i = ADB_SR();	/* reset SR-intr in IFR */
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("intr out 0x%02x ", i);
#endif

		adbSentChars++;
		if (ADB_INTR_IS_ON) {	/* ADB intr low during write */
#ifdef ADB_DEBUG
			if (adb_debug)
				printf_intr("intr was on ");
#endif
			ADB_SET_SR_INPUT();	/* make sure SR is set to IN */
			ADB_SET_STATE_IDLE_CUDA();
			adbSentChars = 0;	/* must start all over */
			adbActionState = ADB_ACTION_IDLE;	/* new state */
			adbInputBuffer[0] = 0;
			adbWriteDelay = 1;	/* must retry when done with
						 * read */
			delay(ADB_DELAY);
			goto switch_start;	/* process next state right
						 * now */
			break;
		}
		if (adbOutputBuffer[0] == adbSentChars) {	/* check for done */
			if (0 == adb_cmd_result(adbOutputBuffer)) {	/* do we expect data
									 * back? */
				adbWaiting = 1;	/* signal waiting for return */
				adbWaitingCmd = adbOutputBuffer[2];	/* save waiting command */
			} else {	/* no talk, so done */
				/* set up stuff for adb_pass_up */
				memcpy(packet.data, adbInputBuffer, adbInputBuffer[0] + 1);
				packet.saveBuf = adbBuffer;
				packet.compRout = adbCompRout;
				packet.compData = adbCompData;
				packet.cmd = adbWaitingCmd;
				packet.unsol = 0;
				packet.ack_only = 1;
				adb_pass_up(&packet);

				/* reset "waiting" vars, just in case */
				adbWaitingCmd = 0;
				adbBuffer = NULL;
				adbCompRout = NULL;
				adbCompData = NULL;
			}

			adbWriteDelay = 0;	/* done writing */
			adbActionState = ADB_ACTION_IDLE;	/* signal bus is idle */
			ADB_SET_SR_INPUT();
			ADB_SET_STATE_IDLE_CUDA();
#ifdef ADB_DEBUG
			if (adb_debug)
				printf_intr("write done ");
#endif
		} else {
			write_via_reg(VIA1, vSR, adbOutputBuffer[adbSentChars + 1]);	/* send next byte */
			ADB_TOGGLE_STATE_ACK_CUDA();	/* signal byte ready to
							 * shift */
#ifdef ADB_DEBUG
			if (adb_debug)
				printf_intr("toggle ");
#endif
		}
		break;

	case ADB_ACTION_NOTREADY:
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: not yet initialized\n");
#endif
		break;

	default:
		;
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("intr: unknown ADB state\n");
#endif
	}

	ADB_VIA_INTR_ENABLE();	/* enable ADB interrupt on IIs. */

	splx(s);		/* restore */
}


int
send_adb_cuda(u_char * in, u_char * buffer, void *compRout, void *data, int
	command)
{
	int s, len;

#ifdef ADB_DEBUG
	if (adb_debug)
		printf_intr("SEND\n");
#endif

	if (adbActionState == ADB_ACTION_NOTREADY)
		return 1;

	/* Don't interrupt while we are messing with the ADB */
	s = splhigh();

	if ((adbActionState == ADB_ACTION_IDLE) &&	/* ADB available? */
	    (ADB_INTR_IS_OFF)) {	/* and no incoming interrupt? */
	} else
		if (adbWriteDelay == 0)	/* it's busy, but is anything waiting? */
			adbWriteDelay = 1;	/* if no, then we'll "queue"
						 * it up */
		else {
			splx(s);
			return 1;	/* really busy! */
		}

#ifdef ADB_DEBUG
	if (adb_debug)
		printf_intr("QUEUE\n");
#endif
	if ((long)in == (long)0) {	/* need to convert? */
		if ((command & 0x0c) == 0x08)	/* copy addl data ONLY if
						 * doing a listen! */
			len = buffer[0];	/* length of additional data */
		else
			len = 0;/* no additional data */

		adbOutputBuffer[0] = 2 + len;	/* dev. type + command + addl.
						 * data */
		adbOutputBuffer[1] = 0x00;	/* mark as an ADB command */
		adbOutputBuffer[2] = (u_char)command;	/* load command */

		/* copy additional output data, if any */
		memcpy(adbOutputBuffer + 3, buffer + 1, len);
	} else
		/* if data ready, just copy over */
		memcpy(adbOutputBuffer, in, in[0] + 2);

	adbSentChars = 0;	/* nothing sent yet */
	adbBuffer = buffer;	/* save buffer to know where to save result */
	adbCompRout = compRout;	/* save completion routine pointer */
	adbCompData = data;	/* save completion routine data pointer */
	adbWaitingCmd = adbOutputBuffer[2];	/* save wait command */

	if (adbWriteDelay != 1) {	/* start command now? */
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("out start NOW");
#endif
		delay(ADB_DELAY);
		adbActionState = ADB_ACTION_OUT;	/* set next state */
		ADB_SET_SR_OUTPUT();	/* set shift register for OUT */
		write_via_reg(VIA1, vSR, adbOutputBuffer[adbSentChars + 1]);	/* load byte for output */
		ADB_SET_STATE_ACKOFF_CUDA();
		ADB_SET_STATE_TIP();	/* tell ADB that we want to send */
	}
	adbWriteDelay = 1;	/* something in the write "queue" */

	splx(s);

	if ((s & (1 << 18)) || adb_polling) /* XXX were VIA1 interrupts blocked ? */
		/* poll until byte done */
		while ((adbActionState != ADB_ACTION_IDLE) || (ADB_INTR_IS_ON)
		    || (adbWaiting == 1))
			if (ADB_SR_INTR_IS_ON) {	/* wait for "interrupt" */
				adb_intr_cuda();	/* process it */
				if (cold)
					delay(ADB_DELAY);
				adb_soft_intr();
			}

	return 0;
}

/*
 * Called when when an adb interrupt happens.
 * This routine simply transfers control over to the appropriate
 * code for the machine we are running on.
 */
int
adb_intr(void *arg)
{
	switch (adbHardware) {
	case ADB_HW_PMU:
		pm_intr();
		break;

	case ADB_HW_CUDA:
		adb_intr_cuda();
		break;
	}
	return 1;
}


/*
 * adb_pass_up is called by the interrupt-time routines.
 * It takes the raw packet data that was received from the
 * device and puts it into the queue that the upper half
 * processes. It then signals for a soft ADB interrupt which
 * will eventually call the upper half routine (adb_soft_intr).
 *
 * If in->unsol is 0, then this is either the notification
 * that the packet was sent (on a LISTEN, for example), or the
 * response from the device (on a TALK). The completion routine
 * is called only if the user specified one.
 *
 * If in->unsol is 1, then this packet was unsolicited and
 * so we look up the device in the ADB device table to determine
 * what its default service routine is.
 *
 * If in->ack_only is 1, then we really only need to call
 * the completion routine, so don't do any other stuff.
 *
 * Note that in->data contains the packet header AND data,
 * while adbInbound[]->data contains ONLY data.
 *
 * Note: Called only at interrupt time. Assumes this.
 */
void
adb_pass_up(struct adbCommand *in)
{
	int start = 0, len = 0, cmd = 0;
	ADBDataBlock block;

	if (adbInCount >= ADB_QUEUE) {
#ifdef ADB_DEBUG
		if (adb_debug)
			printf_intr("adb: ring buffer overflow\n");
#endif
		return;
	}

	if (in->ack_only) {
		len = in->data[0];
		cmd = in->cmd;
		start = 0;
	} else {
		switch (adbHardware) {
		case ADB_HW_CUDA:
			/* If it's unsolicited, accept only ADB data for now */
			if (in->unsol)
				if (0 != in->data[2])
					return;
			cmd = in->data[4];
			if (in->data[0] < 5)
				len = 0;
			else
				len = in->data[0]-4;
			start = 4;
			break;

		case ADB_HW_PMU:
			cmd = in->data[1];
			if (in->data[0] < 2)
				len = 0;
			else
				len = in->data[0]-1;
			start = 1;
			break;

		case ADB_HW_UNKNOWN:
			return;
		}

		/* Make sure there is a valid device entry for this device */
		if (in->unsol) {
			/* ignore unsolicited data during adbreinit */
			if (adbStarting)
				return;
			/* get device's comp. routine and data area */
			if (-1 == get_adb_info(&block, ADB_CMDADDR(cmd)))
				return;
		}
	}

	/*
 	 * If this is an unsolicited packet, we need to fill in
 	 * some info so adb_soft_intr can process this packet
 	 * properly. If it's not unsolicited, then use what
 	 * the caller sent us.
 	 */
	if (in->unsol) {
		adbInbound[adbInTail].compRout = (void *)block.dbServiceRtPtr;
		adbInbound[adbInTail].compData = (void *)block.dbDataAreaAddr;
		adbInbound[adbInTail].saveBuf = (void *)adbInbound[adbInTail].data;
	} else {
		adbInbound[adbInTail].compRout = (void *)in->compRout;
		adbInbound[adbInTail].compData = (void *)in->compData;
		adbInbound[adbInTail].saveBuf = (void *)in->saveBuf;
	}

#ifdef ADB_DEBUG
	if (adb_debug && in->data[1] == 2)
		printf_intr("adb: caught error\n");
#endif

	/* copy the packet data over */
	/*
	 * TO DO: If the *_intr routines fed their incoming data
	 * directly into an adbCommand struct, which is passed to
	 * this routine, then we could eliminate this copy.
	 */
	memcpy(adbInbound[adbInTail].data + 1, in->data + start + 1, len);
	adbInbound[adbInTail].data[0] = len;
	adbInbound[adbInTail].cmd = cmd;

	adbInCount++;
	if (++adbInTail >= ADB_QUEUE)
		adbInTail = 0;

	/*
	 * If the debugger is running, call upper half manually.
	 * Otherwise, trigger a soft interrupt to handle the rest later.
	 */
	if (adb_polling)
		adb_soft_intr();
	else
		setsoftadb();
}


/*
 * Called to process the packets after they have been
 * placed in the incoming queue.
 *
 */
void
adb_soft_intr(void)
{
	int s;
	int cmd = 0;
	u_char *buffer;
	u_char *comprout;
	u_char *compdata;

/*delay(2*ADB_DELAY);*/

	while (adbInCount) {
#ifdef ADB_DEBUG
		if (adb_debug & 0x80)
			printf_intr("%x %x %x ",
			    adbInCount, adbInHead, adbInTail);
#endif
		/* get the data we need from the queue */
		buffer = adbInbound[adbInHead].saveBuf;
		comprout = adbInbound[adbInHead].compRout;
		compdata = adbInbound[adbInHead].compData;
		cmd = adbInbound[adbInHead].cmd;

		/* copy over data to data area if it's valid */
		/*
		 * Note that for unsol packets we don't want to copy the
		 * data anywhere, so buffer was already set to 0.
		 * For ack_only buffer was set to 0, so don't copy.
		 */
		if (buffer)
			memcpy(buffer, adbInbound[adbInHead].data,
			    adbInbound[adbInHead].data[0] + 1);

#ifdef ADB_DEBUG
			if (adb_debug & 0x80) {
				printf_intr("%p %p %p %x ",
				    buffer, comprout, compdata, (short)cmd);
				printf_intr("buf: ");
				print_single(adbInbound[adbInHead].data);
			}
#endif
		/*
		 * Remove the packet from the queue before calling
                 * the completion routine, so that the completion
                 * routine can reentrantly process the queue.  For
                 * example, this happens when polling is turned on
                 * by entering the debuger by keystroke.
                 */
		s = splhigh();
		adbInCount--;
		if (++adbInHead >= ADB_QUEUE)
			adbInHead = 0;
		splx(s);

		/* call default completion routine if it's valid */
		if (comprout) {
			((int (*)(u_char *, u_char *, int)) comprout)
			    (buffer, compdata, cmd);
		}

	}
}


/*
 * This is my version of the ADBOp routine. It mainly just calls the
 * hardware-specific routine.
 *
 *   data 	: pointer to data area to be used by compRout
 *   compRout	: completion routine
 *   buffer	: for LISTEN: points to data to send - MAX 8 data bytes,
 *		  byte 0 = # of bytes
 *		: for TALK: points to place to save return data
 *   command	: the adb command to send
 *   result	: 0 = success
 *		: -1 = could not complete
 */
int
adb_op(Ptr buffer, Ptr compRout, Ptr data, short command)
{
	int result;

	switch (adbHardware) {
	case ADB_HW_PMU:
		result = pm_adb_op((u_char *)buffer, (void *)compRout,
		    (void *)data, (int)command);

		if (result == 0)
			return 0;
		else
			return -1;
		break;

	case ADB_HW_CUDA:
		result = send_adb_cuda(NULL, (u_char *)buffer,
		    (void *)compRout, (void *)data, (int)command);
		if (result == 0)
			return 0;
		else
			return -1;
		break;

	default:
		return -1;
	}
}


/*
 * adb_hw_setup
 * This routine sets up the possible machine specific hardware
 * config (mainly VIA settings) for the various models.
 */
void
adb_hw_setup(void)
{
	volatile int i;

	switch (adbHardware) {

	case ADB_HW_PMU:
		/*
		 * XXX - really PM_VIA_CLR_INTR - should we put it in
		 * pm_direct.h?
		 */
		write_via_reg(VIA1, vIFR, 0x90);	/* clear interrupt */
		break;

	case ADB_HW_CUDA:
		via_reg_or(VIA1, vDirB, 0x30);	/* register B bits 4 and 5:
						 * outputs */
		via_reg_and(VIA1, vDirB, 0xf7);	/* register B bit 3: input */
		via_reg_and(VIA1, vACR, ~vSR_OUT);	/* make sure SR is set
							 * to IN */
		write_via_reg(VIA1, vACR, (read_via_reg(VIA1, vACR) | 0x0c) & ~0x10);
		adbActionState = ADB_ACTION_IDLE;	/* used by all types of
							 * hardware */
		write_via_reg(VIA1, vIER, 0x84);/* make sure VIA interrupts
						 * are on */
		ADB_SET_STATE_IDLE_CUDA();	/* set ADB bus state to idle */

		/* sort of a device reset */
		i = ADB_SR();	/* clear interrupt */
		ADB_VIA_INTR_DISABLE();	/* no interrupts while clearing */
		ADB_SET_STATE_IDLE_CUDA();	/* reset state to idle */
		delay(ADB_DELAY);
		ADB_SET_STATE_TIP();	/* signal start of frame */
		delay(ADB_DELAY);
		ADB_TOGGLE_STATE_ACK_CUDA();
		delay(ADB_DELAY);
		ADB_CLR_STATE_TIP();
		delay(ADB_DELAY);
		ADB_SET_STATE_IDLE_CUDA();	/* back to idle state */
		i = ADB_SR();	/* clear interrupt */
		ADB_VIA_INTR_ENABLE();	/* ints ok now */
		break;

	case ADB_HW_UNKNOWN:
	default:
		write_via_reg(VIA1, vIER, 0x04);/* turn interrupts off - TO
						 * DO: turn PB ints off? */
		break;
	}
}

/*
 * adb_reinit sets up the adb stuff
 *
 */
void
adb_reinit(struct adb_softc *sc)
{
	u_char send_string[ADB_MAX_MSG_LENGTH];
	ADBDataBlock data;	/* temp. holder for getting device info */
	volatile int i, x;
	int s;
	int command;
	int result;
	int saveptr;		/* point to next free relocation address */
	int device;
	int nonewtimes;		/* times thru loop w/o any new devices */
	int ADBNumDevices = 0;

	/* Make sure we are not interrupted while building the table. */
	if (adbHardware != ADB_HW_PMU)	/* ints must be on for PB? */
		s = splhigh();

	/* Let intr routines know we are running reinit */
	adbStarting = 1;

	/*
	 * Initialize the ADB table.  For now, we'll always use the same table
	 * that is defined at the beginning of this file - no mallocs.
	 */
	for (i = 0; i < 16; i++)
		sc->sc_devtable[i].handler_id = 0;

	adb_hw_setup();		/* init the VIA bits and hard reset ADB */

	delay(1000);

	/* send an ADB reset first */
	adb_op_sync((Ptr)0, (short)0x00);
	delay(200000);

	/*
	 * Probe for ADB devices. Probe devices 1-15 quickly to determine
	 * which device addresses are in use and which are free. For each
	 * address that is in use, move the device at that address to a higher
	 * free address. Continue doing this at that address until no device
	 * responds at that address. Then move the last device that was moved
	 * back to the original address. Do this for the remaining addresses
	 * that we determined were in use.
	 *
	 * When finished, do this entire process over again with the updated
	 * list of in use addresses. Do this until no new devices have been
	 * found in 20 passes though the in use address list. (This probably
	 * seems long and complicated, but it's the best way to detect multiple
	 * devices at the same address - sometimes it takes a couple of tries
	 * before the collision is detected.)
	 */

	/* initial scan through the devices */
	for (i = 1; i < 16; i++) {
		send_string[0] = 0;
		command = ADBTALK(i, 3);
		result = adb_op_sync((Ptr)send_string, (short)command);

		if (send_string[0] != 0) {
			/* check for valid device handler */
			switch (send_string[2]) {
			case 0:
			case 0xfd:
			case 0xfe:
			case 0xff:
				continue;	/* invalid, skip */
			}

			/* found a device */
			++ADBNumDevices;
			KASSERT(ADBNumDevices < 16);
			sc->sc_devtable[ADBNumDevices].handler_id =
				(int)send_string[2];
			sc->sc_devtable[ADBNumDevices].orig_addr = i;
			sc->sc_devtable[ADBNumDevices].curr_addr = i;
			sc->sc_devtable[ADBNumDevices].data = NULL;
			sc->sc_devtable[ADBNumDevices].handler = NULL;
		}
	}

	/* find highest unused address */
	for (saveptr = 15; saveptr > 0; saveptr--)
		if (-1 == get_adb_info(&data, saveptr))
			break;

#ifdef ADB_DEBUG
	if (adb_debug & 0x80) {
		printf_intr("first free is: 0x%02x\n", saveptr);
		printf_intr("devices: %i\n", ADBNumDevices);
	}
#endif

	nonewtimes = 0;		/* no loops w/o new devices */
	while (saveptr > 0 && nonewtimes++ < 11) {
		for (i = 1; i <= ADBNumDevices; i++) {
			device = sc->sc_devtable[i].curr_addr;
#ifdef ADB_DEBUG
			if (adb_debug & 0x80)
				printf_intr("moving device 0x%02x to 0x%02x "
				    "(index 0x%02x)  ", device, saveptr, i);
#endif

			/* send TALK R3 to address */
			command = ADBTALK(device, 3);
			adb_op_sync((Ptr)send_string, (short)command);

			/* move device to higher address */
			command = ADBLISTEN(device, 3);
			send_string[0] = 2;
			send_string[1] = (u_char)(saveptr | 0x60);
			send_string[2] = 0xfe;
			adb_op_sync((Ptr)send_string, (short)command);
			delay(500);

			/* send TALK R3 - anything at new address? */
			command = ADBTALK(saveptr, 3);
			adb_op_sync((Ptr)send_string, (short)command);
			delay(500);

			if (send_string[0] == 0) {
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("failed, continuing\n");
#endif
				continue;
			}

			/* send TALK R3 - anything at old address? */
			command = ADBTALK(device, 3);
			result = adb_op_sync((Ptr)send_string, (short)command);
			if (send_string[0] != 0) {
				/* check for valid device handler */
				switch (send_string[2]) {
				case 0:
				case 0xfd:
				case 0xfe:
				case 0xff:
					continue;	/* invalid, skip */
				}

				/* new device found */
				/* update data for previously moved device */
				sc->sc_devtable[i].curr_addr = saveptr;
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("old device at index %i\n",i);
#endif
				/* add new device in table */
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("new device found\n");
#endif
				if (saveptr > ADBNumDevices) {
					++ADBNumDevices;
					KASSERT(ADBNumDevices < 16);
				}
				sc->sc_devtable[ADBNumDevices].handler_id =
					(int)send_string[2];
				sc->sc_devtable[ADBNumDevices].orig_addr = device;
				sc->sc_devtable[ADBNumDevices].curr_addr = device;
				/* These will be set correctly in adbsys.c */
				/* Until then, unsol. data will be ignored. */
				sc->sc_devtable[ADBNumDevices].data = NULL;
				sc->sc_devtable[ADBNumDevices].handler = NULL;
				/* find next unused address */
				for (x = saveptr; x > 0; x--) {
					if (-1 == get_adb_info(&data, x)) {
						saveptr = x;
						break;
					}
				}
				if (x == 0)
					saveptr = 0;
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("new free is 0x%02x\n",
					    saveptr);
#endif
				nonewtimes = 0;
			} else {
#ifdef ADB_DEBUG
				if (adb_debug & 0x80)
					printf_intr("moving back...\n");
#endif
				/* move old device back */
				command = ADBLISTEN(saveptr, 3);
				send_string[0] = 2;
				send_string[1] = (u_char)(device | 0x60);
				send_string[2] = 0xfe;
				adb_op_sync((Ptr)send_string, (short)command);
				delay(1000);
			}
		}
	}

#ifdef ADB_DEBUG
	if (adb_debug) {
		for (i = 1; i <= ADBNumDevices; i++) {
			x = get_ind_adb_info(sc, &data, i);
			if (x != -1)
				printf_intr("index 0x%x, addr 0x%x, type 0x%x\n",
				    i, x, data.devType);
		}
	}
#endif

#ifdef ADB_DEBUG
	if (adb_debug) {
		if (0 == ADBNumDevices)	/* tell user if no devices found */
			printf_intr("adb: no devices found\n");
	}
#endif

	adbStarting = 0;	/* not starting anymore */
#ifdef ADB_DEBUG
	if (adb_debug)
		printf_intr("adb: adb_reinit complete\n");
#endif

	if (adbHardware == ADB_HW_CUDA) {
		timeout_set(&adb_cuda_timeout, (void *)adb_cuda_tickle, NULL);
		timeout_add(&adb_cuda_timeout, ADB_TICKLE_TICKS);
	}

	if (adbHardware != ADB_HW_PMU)	/* ints must be on for PB? */
		splx(s);
}


/*
 * adb_cmd_result
 *
 * This routine lets the caller know whether the specified adb command string
 * should expect a returned result, such as a TALK command.
 *
 * returns: 0 if a result should be expected
 *          1 if a result should NOT be expected
 */
int
adb_cmd_result(u_char *in)
{
	switch (adbHardware) {
	case ADB_HW_CUDA:
		/* was it an ADB talk command? */
		if ((in[1] == 0x00) && ((in[2] & 0x0c) == 0x0c))
			return 0;
		/* was it an RTC/PRAM read date/time? */
		if ((in[1] == 0x01) && (in[2] == 0x03))
			return 0;
		return 1;

	case ADB_HW_PMU:
		return 1;

	default:
		return 1;
	}
}


/*
 * adb_op_sync
 *
 * This routine does exactly what the adb_op routine does, except that after
 * the adb_op is called, it waits until the return value is present before
 * returning.
 */
int
adb_op_sync(Ptr buffer, short command)
{
	int tmout;
	int result;
	volatile int flag = 0;

	result = adb_op(buffer, (void *)adb_op_comprout,
	    (void *)&flag, command);	/* send command */
	if (result == 0) {		/* send ok? */
		/*
		 * Total time to wait is calculated as follows:
		 *  - Tlt (stop to start time): 260 usec
		 *  - start bit: 100 usec
		 *  - up to 8 data bytes: 64 * 100 usec = 6400 usec
		 *  - stop bit (with SRQ): 140 usec
		 * Total: 6900 usec
		 *
		 * This is the total time allowed by the specification.  Any
		 * device that doesn't conform to this will fail to operate
		 * properly on some Apple systems.  In spite of this we
		 * double the time to wait; some Cuda-based apparently
		 * queues some commands and allows the main CPU to continue
		 * processing (radical concept, eh?).  To be safe, allow
		 * time for two complete ADB transactions to occur.
		 */
		for (tmout = 13800; !flag && tmout >= 10; tmout -= 10)
			delay(10);
		if (!flag && tmout > 0)
			delay(tmout);

		if (!flag)
			result = -2;
	}

	return result;
}


/*
 * adb_op_comprout
 *
 * This function is used by the adb_op_sync routine so it knows when the
 * function is done.
 */
void
adb_op_comprout(caddr_t buffer, caddr_t compdata, int cmd)
{
	*(int *)compdata = 0x01;		/* update flag value */
}

int
count_adbs(struct adb_softc *sc)
{
	int i;
	int found;

	found = 0;

	for (i = 1; i < 16; i++)
		if (0 != sc->sc_devtable[i].handler_id)
			found++;

	return found;
}

int
get_ind_adb_info(struct adb_softc *sc, ADBDataBlock * info, int index)
{
	if ((index < 1) || (index > 15))	/* check range 1-15 */
		return (-1);

#ifdef ADB_DEBUG
	if (adb_debug & 0x80)
		printf_intr("index 0x%x handler id 0x%x\n", index,
		    sc->sc_devtable[index].handler_id);
#endif
	if (0 == sc->sc_devtable[index].handler_id)	/* make sure it's a valid entry */
		return (-1);

	info->devType = sc->sc_devtable[index].handler_id;
	info->origADBAddr = sc->sc_devtable[index].orig_addr;
	info->dbServiceRtPtr = (Ptr)sc->sc_devtable[index].handler;
	info->dbDataAreaAddr = (Ptr)sc->sc_devtable[index].data;

	return (sc->sc_devtable[index].curr_addr);
}

int
get_adb_info(ADBDataBlock * info, int adbAddr)
{
	struct adb_softc *sc = adb_cd.cd_devs[0];
	int i;

	if (sc == NULL)
		return (-1);

	if ((adbAddr < 1) || (adbAddr > 15))	/* check range 1-15 */
		return (-1);

	for (i = 1; i < 15; i++)
		if (sc->sc_devtable[i].curr_addr == adbAddr) {
			info->devType = sc->sc_devtable[i].handler_id;
			info->origADBAddr = sc->sc_devtable[i].orig_addr;
			info->dbServiceRtPtr = (Ptr)sc->sc_devtable[i].handler;
			info->dbDataAreaAddr = sc->sc_devtable[i].data;
			return 0;	/* found */
		}

	return (-1);		/* not found */
}

int
set_adb_info(ADBSetInfoBlock * info, int adbAddr)
{
	struct adb_softc *sc = adb_cd.cd_devs[0];
	int i;

	if (sc == NULL)
		return (-1);

	if ((adbAddr < 1) || (adbAddr > 15))	/* check range 1-15 */
		return (-1);

	for (i = 1; i < 15; i++)
		if (sc->sc_devtable[i].curr_addr == adbAddr) {
			sc->sc_devtable[i].handler =
			    (void *)(info->siServiceRtPtr);
			sc->sc_devtable[i].data = info->siDataAreaAddr;
			return 0;	/* found */
		}

	return (-1);		/* not found */

}

/* caller should really use machine-independent version: getPramTime */
/* this version does pseudo-adb access only */
int
adb_read_date_time(time_t *time)
{
	u_char output[ADB_MAX_MSG_LENGTH];
	int result;
	int retcode;
	volatile int flag = 0;
	u_int32_t t;

	switch (adbHardware) {
	case ADB_HW_PMU:
		pm_read_date_time(time);
		retcode = 0;
		break;

	case ADB_HW_CUDA:
		output[0] = 0x02;	/* 2 byte message */
		output[1] = 0x01;	/* to pram/rtc device */
		output[2] = 0x03;	/* read date/time */
		result = send_adb_cuda((u_char *)output, (u_char *)output,
		    (void *)adb_op_comprout, (void *)&flag, (int)0);
		if (result != 0) {	/* exit if not sent */
			retcode = -1;
			break;
		}

		while (0 == flag)	/* wait for result */
			;

		delay(20); /* completion occurs too soon? */
		memcpy(&t, output + 1, sizeof(t));
		*time = (time_t)t;
		retcode = 0;
		break;

	case ADB_HW_UNKNOWN:
	default:
		retcode = -1;
		break;
	}
	if (retcode == 0) {
#define DIFF19041970 2082844800
		*time -= DIFF19041970;

	} else {
		*time = 0;
	}
	return retcode;
}

/* caller should really use machine-independent version: setPramTime */
/* this version does pseudo-adb access only */
int
adb_set_date_time(time_t time)
{
	u_char output[ADB_MAX_MSG_LENGTH];
	int result;
	volatile int flag = 0;
	u_int32_t t;

	time += DIFF19041970;
	switch (adbHardware) {

	case ADB_HW_CUDA:
		t = time;		/* XXX eventually truncates */

		output[0] = 0x06;	/* 6 byte message */
		output[1] = 0x01;	/* to pram/rtc device */
		output[2] = 0x09;	/* set date/time */
		output[3] = (u_char)(t >> 24);
		output[4] = (u_char)(t >> 16);
		output[5] = (u_char)(t >> 8);
		output[6] = (u_char)(t);
		result = send_adb_cuda((u_char *)output, NULL,
		    (void *)adb_op_comprout, (void *)&flag, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		while (0 == flag)	/* wait for send to finish */
			;

		return 0;

	case ADB_HW_PMU:
		pm_set_date_time(time);
		return 0;

	default:
		return -1;
	}
}


int
adb_poweroff(void)
{
	u_char output[ADB_MAX_MSG_LENGTH];
	int result;

	adb_polling = 1;

	switch (adbHardware) {
	case ADB_HW_PMU:
		/* Clear the wake on AC loss event */
		pmu_fileserver_mode(0);
		pm_adb_poweroff();

		for (;;);		/* wait for power off */

		return 0;

	case ADB_HW_CUDA:
		output[0] = 0x02;	/* 2 byte message */
		output[1] = 0x01;	/* to pram/rtc/soft-power device */
		output[2] = 0x0a;	/* set poweroff */
		result = send_adb_cuda((u_char *)output, NULL,
		    NULL, NULL, (int)0);
		if (result != 0)	/* exit if not sent */
			return -1;

		for (;;);		/* wait for power off */

		return 0;

	default:
		return -1;
	}
}

void
setsoftadb()
{
	if (!timeout_initialized(&adb_softintr_timeout))
		timeout_set(&adb_softintr_timeout, (void *)adb_soft_intr, NULL);
	timeout_add(&adb_softintr_timeout, 1);
}

void
adb_cuda_autopoll()
{
	volatile int flag = 0;
	int result;
	u_char output[16];

	output[0] = 0x03;	/* 3-byte message */
	output[1] = 0x01;	/* to pram/rtc/soft-power device */
	output[2] = 0x01;	/* cuda autopoll */
	output[3] = 0x01;
	result = send_adb_cuda(output, output, adb_op_comprout,
	    (void *)&flag, 0);
	if (result != 0)	/* exit if not sent */
		return;

	while (flag == 0);	/* wait for result */
}

void
adb_cuda_fileserver_mode()
{
	volatile int flag = 0;
	int result;
	u_char output[16];

	output[0] = 0x03;	/* 3-byte message */
	output[1] = 0x01; 	/* to pram/rtc device/soft-power device */
	output[2] = 0x13;	/* cuda file server mode */
	output[3] = 0x01;	/* True - Turn on after AC loss */

	result = send_adb_cuda(output, output, adb_op_comprout,
	    (void *)&flag, 0);
	if (result != 0)
		return;

	while (flag == 0);
}

void
adb_restart()
{
	int result;
	u_char output[16];

	adb_polling = 1;

	switch (adbHardware) {
	case ADB_HW_CUDA:
		output[0] = 0x02;	/* 2 byte message */
		output[1] = 0x01;	/* to pram/rtc/soft-power device */
		output[2] = 0x11;	/* restart */
		result = send_adb_cuda((u_char *)output, NULL,
				       NULL, NULL, (int)0);
		if (result != 0)	/* exit if not sent */
			return;
		while (1);		/* not return */

	case ADB_HW_PMU:
		pm_adb_restart();
		while (1);		/* not return */
	}
}

/*
 * Driver definition.
 */

int	adbmatch(struct device *, void *, void *);
void	adbattach(struct device *, struct device *, void *);

struct cfattach adb_ca = {
	sizeof(struct adb_softc), adbmatch, adbattach
};

int
adbmatch(struct device *parent, void *cf, void *aux)
{
	struct confargs *ca = aux;

	if (ca->ca_nreg < 8)
		return 0;

	if (ca->ca_nintr < 4)
		return 0;

	if (strcmp(ca->ca_name, "via-cuda") == 0)
		return 1;

	if (strcmp(ca->ca_name, "via-pmu") == 0)
		return 1;

	return 0;
}

void
adbattach(struct device *parent, struct device *self, void *aux)
{
	struct adb_softc *sc = (struct adb_softc *)self;
	struct confargs *ca = aux;
	struct confargs nca;
	char name[32];
	int node;
	ADBDataBlock adbdata;
	struct adb_attach_args aa_args;
	int totaladbs;
	int adbindex, adbaddr;

	ca->ca_reg[0] += ca->ca_baseaddr;

	sc->sc_regbase = mapiodev(ca->ca_reg[0], ca->ca_reg[1]);
	Via1Base = sc->sc_regbase;

	if (strcmp(ca->ca_name, "via-cuda") == 0)
		adbHardware = ADB_HW_CUDA;
	else if (strcmp(ca->ca_name, "via-pmu") == 0) {
		adbHardware = ADB_HW_PMU;

		/*
		 * Bus reset can take a long time if no adb devices are
		 * connected, e.g. on a Mac Mini; so check for an adb
		 * child in the OF tree to speed up pm_adb_op().
		 */
		adbempty = 1;
		for (node = OF_child(ca->ca_node); node; node = OF_peer(node)) {
			if (OF_getprop(node, "name", name, sizeof name) <= 0)
				continue;
			if (strcmp(name, "adb") == 0) {
				adbempty = 0;
				break;
			}
		}
	}

	adb_polling = 1;
	if (!adbempty) {
		adb_reinit(sc);
		totaladbs = count_adbs(sc);
		printf(": irq %d, %s, %d target%s", ca->ca_intr[0], ca->ca_name,
		    totaladbs, (totaladbs == 1) ? "" : "s");
	}
	printf("\n");

	mac_intr_establish(parent, ca->ca_intr[0], IST_LEVEL, IPL_TTY,
	    adb_intr, sc, sc->sc_dev.dv_xname);

	/* init powerpc globals which control RTC functionality */
	time_read = adb_read_date_time;
	time_write = adb_set_date_time;

#if NAPM > 0
	if (adbHardware == ADB_HW_PMU) {
		/* Magic for signalling the apm driver to match. */
		nca.ca_name = "apm";
		nca.ca_node = node;
		config_found(self, &nca, NULL);
	}
#endif

	/* Attach I2C controller. */
	for (node = OF_child(ca->ca_node); node; node = OF_peer(node)) {
		if (OF_getprop(node, "name", name, sizeof name) <= 0)
			continue;
		if (strcmp(name, "pmu-i2c") == 0) {
			nca.ca_name = "piic";
			nca.ca_node = node;
			config_found(self, &nca, NULL);
		}
	}

	if (adbHardware == ADB_HW_CUDA)
		adb_cuda_fileserver_mode();
	if (adbHardware == ADB_HW_PMU)
		pmu_fileserver_mode(1);

	/*
	 * XXX If the machine doesn't have an ADB bus (PowerBook5,6+)
	 * yes it sounds stupid to attach adb(4), but don't try to send
	 * ADB commands otherwise the PMU may shutdown the machine...
	 */
	if (adbempty)
		return;

	/* for each ADB device */
	for (adbindex = 1; adbindex <= totaladbs; adbindex++) {
		/* Get the ADB information */
		adbaddr = get_ind_adb_info(sc, &adbdata, adbindex);

		aa_args.name = adb_device_name;
		aa_args.origaddr = adbdata.origADBAddr;
		aa_args.adbaddr = adbaddr;
		aa_args.handler_id = adbdata.devType;

		(void)config_found(self, &aa_args, adbprint);
	}

	if (adbHardware == ADB_HW_CUDA)
		adb_cuda_autopoll();
	adb_polling = 0;
}
@


1.40
log
@IPL_MPSAFE bits for macppc with openpic(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.39 2013/08/10 08:13:32 mpi Exp $	*/
d868 1
a868 1
		result = send_adb_cuda((u_char *)0, (u_char *)buffer,
d1422 1
a1422 1
		result = send_adb_cuda((u_char *)output, (u_char *)0,
d1464 2
a1465 2
		result = send_adb_cuda((u_char *)output, (u_char *)0,
		    (void *)0, (void *)0, (int)0);
d1538 2
a1539 2
		result = send_adb_cuda((u_char *)output, (u_char *)0,
				       (void *)0, (void *)0, (int)0);
@


1.39
log
@Move the device table inside the softc.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.38 2013/07/06 14:28:48 mpi Exp $	*/
d1629 1
a1629 1
	mac_intr_establish(parent, ca->ca_intr[0], IST_LEVEL, IPL_HIGH,
@


1.38
log
@Print the number of targets and the irq before looking for subdevices,
like it was before r1.36, to correct the adb* lines in the dmesg.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.37 2013/04/23 07:38:05 mpi Exp $	*/
a172 11
 * A structure for storing information about each ADB device.
 */
struct ADBDevEntry {
	void	(*ServiceRtPtr)(void);
	void	*DataAreaAddr;
	int	devType;
	int	origAddr;
	int	currentAddr;
};

/*
a205 3
struct	ADBDevEntry ADBDevTable[16];	/* our ADB device table */
int	ADBNumDevices;		/* num. of ADB devices found with adb_reinit */

d218 2
d234 3
a236 3
void	adb_reinit(void);
int	count_adbs(void);
int	get_ind_adb_info(ADBDataBlock *, int);
d944 1
a944 1
adb_reinit(void)
d955 1
a960 2
	ADBNumDevices = 0;	/* no devices yet */

d969 1
a969 1
		ADBDevTable[i].devType = 0;
d1015 1
a1015 1
			ADBDevTable[ADBNumDevices].devType =
d1017 4
a1020 4
			ADBDevTable[ADBNumDevices].origAddr = i;
			ADBDevTable[ADBNumDevices].currentAddr = i;
			ADBDevTable[ADBNumDevices].DataAreaAddr = NULL;
			ADBDevTable[ADBNumDevices].ServiceRtPtr = NULL;
d1039 1
a1039 1
			device = ADBDevTable[i].currentAddr;
d1086 1
a1086 1
				ADBDevTable[i].currentAddr = saveptr;
d1100 1
a1100 1
				ADBDevTable[ADBNumDevices].devType =
d1102 2
a1103 2
				ADBDevTable[ADBNumDevices].origAddr = device;
				ADBDevTable[ADBNumDevices].currentAddr = device;
d1106 2
a1107 2
				ADBDevTable[ADBNumDevices].DataAreaAddr = NULL;
				ADBDevTable[ADBNumDevices].ServiceRtPtr = NULL;
d1142 1
a1142 1
			x = get_ind_adb_info(&data, i);
d1263 1
a1263 1
count_adbs(void)
d1271 1
a1271 1
		if (0 != ADBDevTable[i].devType)
d1278 1
a1278 1
get_ind_adb_info(ADBDataBlock * info, int index)
d1285 2
a1286 2
		printf_intr("index 0x%x devType is: 0x%x\n", index,
		    ADBDevTable[index].devType);
d1288 1
a1288 1
	if (0 == ADBDevTable[index].devType)	/* make sure it's a valid entry */
d1291 4
a1294 4
	info->devType = ADBDevTable[index].devType;
	info->origADBAddr = ADBDevTable[index].origAddr;
	info->dbServiceRtPtr = (Ptr)ADBDevTable[index].ServiceRtPtr;
	info->dbDataAreaAddr = (Ptr)ADBDevTable[index].DataAreaAddr;
d1296 1
a1296 1
	return (ADBDevTable[index].currentAddr);
d1302 1
d1305 3
d1312 5
a1316 5
		if (ADBDevTable[i].currentAddr == adbAddr) {
			info->devType = ADBDevTable[i].devType;
			info->origADBAddr = ADBDevTable[i].origAddr;
			info->dbServiceRtPtr = (Ptr)ADBDevTable[i].ServiceRtPtr;
			info->dbDataAreaAddr = ADBDevTable[i].DataAreaAddr;
d1326 1
d1329 3
d1336 2
a1337 2
		if (ADBDevTable[i].currentAddr == adbAddr) {
			ADBDevTable[i].ServiceRtPtr =
d1339 1
a1339 1
			ADBDevTable[i].DataAreaAddr = info->siDataAreaAddr;
d1622 2
a1623 2
		adb_reinit();
		totaladbs = count_adbs();
d1672 1
a1672 1
		adbaddr = get_ind_adb_info(&adbdata, adbindex);
@


1.37
log
@Don't assume time_t is an uint32_t.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.36 2013/03/10 11:26:34 mpi Exp $	*/
d1626 1
a1626 1
	if (!adbempty)
d1628 5
a1672 9

#ifdef ADB_DEBUG
	if (adb_debug)
		printf("adb: done with adb_reinit\n");
#endif
	totaladbs = count_adbs();

	printf(" irq %d: %s, %d target%s\n", ca->ca_intr[0], ca->ca_name,
	    totaladbs, (totaladbs == 1) ? "" : "s");
@


1.36
log
@Do not try to scan the ADB bus for devices if the device-tree does not
contain an adb node. This workaround is required by some PowerBooks
without ADB bus to prevent their PMU from shutting down the machine.

Tweaked from a submission by Daniel Dickman.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.35 2013/03/09 11:33:25 mpi Exp $	*/
d1361 1
d1384 2
a1385 1
		memcpy(time, output + 1, 4);
d1412 1
d1418 2
d1423 4
a1426 4
		output[3] = (u_char)(time >> 24);
		output[4] = (u_char)(time >> 16);
		output[5] = (u_char)(time >> 8);
		output[6] = (u_char)(time);
@


1.35
log
@Drop 3rd and 4th clauses from Bradley A. Grantham's license, from NetBSD
via Daniel Dickman.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.34 2011/06/16 10:51:48 mpi Exp $	*/
a1588 1

d1621 2
a1622 1
	adb_reinit();
a1630 22
#ifdef ADB_DEBUG
	if (adb_debug)
		printf("adb: done with adb_reinit\n");
#endif
	totaladbs = count_adbs();

	printf(" irq %d: %s, %d target%s\n", ca->ca_intr[0], ca->ca_name,
	    totaladbs, (totaladbs == 1) ? "" : "s");

	/* for each ADB device */
	for (adbindex = 1; adbindex <= totaladbs; adbindex++) {
		/* Get the ADB information */
		adbaddr = get_ind_adb_info(&adbdata, adbindex);

		aa_args.name = adb_device_name;
		aa_args.origaddr = adbdata.origADBAddr;
		aa_args.adbaddr = adbaddr;
		aa_args.handler_id = adbdata.devType;

		(void)config_found(self, &aa_args, adbprint);
	}

d1655 30
@


1.34
log
@Removes unused variables.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.33 2011/06/16 10:50:16 mpi Exp $	*/
a46 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bradley A. Grantham.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.33
log
@Removes the always-set-to-1 adbSoftPower variable.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.32 2011/06/16 10:44:33 mpi Exp $	*/
a188 10
 * Used to hold ADB commands that are waiting to be sent out.
 */
struct adbCmdHoldEntry {
	u_char	outBuf[ADB_MAX_MSG_LENGTH];	/* our message */
	u_char	*saveBuf;	/* buffer to know where to save result */
	u_char	*compRout;	/* completion routine pointer */
	u_char	*data;		/* completion routine data pointer */
};

/*
a190 1
 * TO DO: adbCommand can replace all of adbCmdHoldEntry eventually
a218 1
struct	adbCmdHoldEntry adbOutQueue;		/* our 1 entry output queue */
a228 4
struct	adbCommand adbOutbound[ADB_QUEUE]; /* outgoing queue - not used yet */
int	adbOutCount;			/* how many packets in out queue */
int	adbOutHead;			/* head of out queue */
int	adbOutTail;			/* tail of out queue */
@


1.32
log
@Uses generic confargs to attach the apm(4) and piic(4) drivers instead of
the specifics adb arguments.
Now apm(4) no longer depends on adb stuff and piic(4) doesn't attach on a
via-cuda machine (e.g. my color G3 iMac).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.31 2011/06/15 21:32:04 miod Exp $	*/
a220 1
int	adbSoftPower;		/* machine supports soft power */
a270 1
void	adb_setup_hw_type(void);
a1004 2
	adb_setup_hw_type();	/* setup hardware type */

a1295 17
void
adb_setup_hw_type(void)
{
	switch (adbHardware) {
	case ADB_HW_CUDA:
		adbSoftPower = 1;
		return;

	case ADB_HW_PMU:
		adbSoftPower = 1;
		return;

	default:
		panic("unknown adb hardware");
	}
}

a1467 3

	if (!adbSoftPower)
		return -1;
@


1.31
log
@Add a const char* as first member of struct adb_attach_args, so that we can
pass a struct confargs * on macppc for some specific children of the adb
node, and not confuse real adb device attachments.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.30 2011/05/14 12:01:16 mpi Exp $	*/
d1699 6
a1704 7
	/* Magic for signalling the apm driver to match. */
	aa_args.name = adb_device_name;
	aa_args.origaddr = ADBADDR_APM;
	aa_args.adbaddr = ADBADDR_APM;
	aa_args.handler_id = ADBADDR_APM;

	(void)config_found(self, &aa_args, NULL);
@


1.30
log
@pm_* methods are always attached to a PMU, no need to check for hardware.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.29 2009/02/01 17:04:26 miod Exp $	*/
d1690 1
d1700 1
@


1.29
log
@Revert 1.28, rumoured to cause problems on some machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.27 2007/04/23 16:27:20 deraadt Exp $	*/
a1309 1
		pm_setup_adb();
@


1.28
log
@Some of the latest macppc laptops with no adb subsystem at all, spontaneously
powerdown if we try to issue pmu commands. Skip these if no adb device
appears in the device tree.

Adapted from NetBSD.
@
text
@d1668 1
a1668 2
	if (!adbempty)
		adb_reinit();
d1681 1
a1681 4
	if (adbempty)
		totaladbs = 0;
	else
		totaladbs = count_adbs();
d1718 8
a1725 10
	if (!adbempty) {
		if (adbHardware == ADB_HW_CUDA)
			adb_cuda_fileserver_mode();
		if (adbHardware == ADB_HW_PMU)
			pmu_fileserver_mode(1);

		if (adbHardware == ADB_HW_CUDA)
			adb_cuda_autopoll();
		adb_polling = 0;
	}
@


1.27
log
@rename drivers with numbers in them; ok gwk drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.26 2007/04/22 22:31:14 deraadt Exp $	*/
d1668 2
a1669 1
	adb_reinit();
d1682 4
a1685 1
	totaladbs = count_adbs();
d1722 10
a1731 8
	if (adbHardware == ADB_HW_CUDA)
		adb_cuda_fileserver_mode();
	if (adbHardware == ADB_HW_PMU)
		pmu_fileserver_mode(1);

	if (adbHardware == ADB_HW_CUDA)
		adb_cuda_autopoll();
	adb_polling = 0;
@


1.26
log
@better interrupt names for vmstat -iz; ok miod gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.25 2007/04/10 17:47:54 miod Exp $	*/
d1712 1
a1712 1
			nca.ca_name = "pi2c";
@


1.25
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.24 2007/03/13 20:56:55 miod Exp $	*/
d1671 1
a1671 1
	    adb_intr, sc, "adb");
@


1.24
log
@Drop the second and third arguments to adb_op_sync, for they are not used;
while there, remove explicit global variable initializations to zero,
and appease the gods by removing the most ludicrous spurious casts.

No functional change (except for code shrinkage).
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.23 2007/03/04 15:33:31 miod Exp $	*/
d691 1
a691 1
 * what it's default service routine is.
@


1.23
log
@Invoke adb_cuda_autopoll() and leave polling mode after all initialization
commands are set; also add a delay between adb_intr_cuda() and adb_soft_intr()
while polling, as this seems to be necessary on some models;
ok gwk@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.22 2007/02/26 00:11:49 gwk Exp $	*/
d219 8
a226 8
int	adbWaiting = 0;		/* waiting for return data from the device */
int	adbWriteDelay = 0;	/* working on (or waiting to do) a write */
int	adbSoftPower = 0;	/* machine supports soft power */

int	adbWaitingCmd = 0;	/* ADB command we are waiting for */
u_char	*adbBuffer = (long)0;	/* pointer to user data area */
void	*adbCompRout = (long)0;	/* pointer to the completion routine */
void	*adbCompData = (long)0;	/* pointer to the completion routine data */
d233 1
a233 1
int	adbSentChars = 0;	/* how many characters we have sent */
d239 3
a241 3
int	adbInCount = 0;			/* how many packets in in queue */
int	adbInHead = 0;			/* head of in queue */
int	adbInTail = 0;			/* tail of in queue */
d243 7
a249 7
int	adbOutCount = 0;		/* how many packets in out queue */
int	adbOutHead = 0;			/* head of out queue */
int	adbOutTail = 0;			/* tail of out queue */

int	tickle_count = 0;		/* how many tickles seen for this packet? */
int	tickle_serial = 0;		/* the last packet tickled */
int	adb_cuda_serial = 0;		/* the current packet */
d252 1
a252 1
int	adbempty = 0;			/* nonzero if no adb devices */
a271 1
int	set_adb_info(ADBSetInfoBlock *, int);
d295 1
a295 1
	if (str == 0) {
d299 1
a299 1
	if (*str == 0) {
d355 1
a355 1
	/* from a routine, NOT an interrupt */
d425 3
a427 3
				adbBuffer = (long)0;
				adbCompRout = (long)0;
				adbCompData = (long)0;
d525 3
a527 3
				adbBuffer = (long)0;
				adbCompRout = (long)0;
				adbCompData = (long)0;
a706 5
	/* temp for testing */
	/*u_char *buffer = 0;*/
	/*u_char *compdata = 0;*/
	/*u_char *comprout = 0;*/

d814 3
a816 3
	u_char *buffer = 0;
	u_char *comprout = 0;
	u_char *compdata = 0;
d1014 1
a1014 1
	adb_op_sync((Ptr)0, (Ptr)0, (Ptr)0, (short)0x00);
d1038 1
a1038 2
		result = adb_op_sync((Ptr)send_string, (Ptr)0,
		    (Ptr)0, (short)command);
d1057 2
a1058 3
			ADBDevTable[ADBNumDevices].DataAreaAddr =
			    (long)0;
			ADBDevTable[ADBNumDevices].ServiceRtPtr = (void *)0;
d1086 1
a1086 2
			adb_op_sync((Ptr)send_string, (Ptr)0,
			    (Ptr)0, (short)command);
d1093 1
a1093 2
			adb_op_sync((Ptr)send_string, (Ptr)0,
			    (Ptr)0, (short)command);
d1098 1
a1098 2
			adb_op_sync((Ptr)send_string, (Ptr)0,
			    (Ptr)0, (short)command);
d1111 1
a1111 2
			result = adb_op_sync((Ptr)send_string, (Ptr)0,
			    (Ptr)0, (short)command);
d1144 2
a1145 4
				ADBDevTable[ADBNumDevices].DataAreaAddr =
				    (long)0;
				ADBDevTable[ADBNumDevices].ServiceRtPtr =
				    (void *)0;
d1171 1
a1171 2
				adb_op_sync((Ptr)send_string, (Ptr)0,
				    (Ptr)0, (short)command);
a1247 4
 *
 * NOTE: The user specified compRout is ignored, since this routine specifies
 * it's own to adb_op, which is why you really called this in the first place
 * anyway.
d1250 1
a1250 1
adb_op_sync(Ptr buffer, Ptr compRout, Ptr data, short command)
d1295 1
a1295 3
adb_op_comprout(buffer, compdata, cmd)
	caddr_t buffer, compdata;
	int cmd;
d1297 1
a1297 3
	short *p = (short *)compdata;

	*p = 1;
@


1.22
log
@Revert a portion of rev 1.21, via-cuda behaves exactly opposite of via-pmu,
if we attempt to clear the wake on ac loss bit just before shutting down it
yo-yo's found by claudio@@, tested by drahn@@ on early imac, and myself on
a 9600.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.21 2007/02/18 19:33:48 gwk Exp $	*/
d649 2
a1729 4
	if (adbHardware == ADB_HW_CUDA)
		adb_cuda_autopoll();
	adb_polling = 0;

d1745 4
@


1.21
log
@Correct yo-yo shutdowns:
Apparently some machines don't detect a clean (i.e. software initiated)
shutdown; and ignore the 'wake on AC loss' bit, meaning they wake up
immediatly after being told to shutdown e.g. via shutdown -hp.

So now we continue preserve the wake on AC loss behaivour, howerver if we
initiate a clean shutdown we clear this bit so that it the machine does not
immediately power back up again.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.20 2007/02/12 21:01:11 gwk Exp $	*/
d281 1
a281 1
void 	adb_cuda_fileserver_mode(int);
a1527 2
		/* Clear the wake on AC loss event */
		adb_cuda_fileserver_mode(0);
d1573 1
a1573 1
adb_cuda_fileserver_mode(int on)
d1582 1
a1582 1
	output[3] = on;
d1744 1
a1744 1
		adb_cuda_fileserver_mode(1);
@


1.20
log
@Add cuda_fileserver_mode() and pmu_fileserver_mode() that enable the wake
on AC loss feature of the power management IC. Make this the default
behaviour when booting OpenBSD from now on.

This will only affect machines that have the power suddenly cut, Performing
a shutdown requesting power down will clear this mode and its then possible
to remove the power cord, and plug it back in without the machine comming
back on automatically.

Tested by myself, drahn
ok kettenis, drahn.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.19 2006/03/07 20:00:18 miod Exp $	*/
d281 1
a281 1
void 	adb_cuda_fileserver_mode(void);
d1519 2
d1528 2
d1575 1
a1575 1
adb_cuda_fileserver_mode()
d1584 1
a1584 1
	output[3] = 0x01;	/* True */
d1746 1
a1746 1
		adb_cuda_fileserver_mode();
d1748 1
a1748 1
		pmu_fileserver_mode();
@


1.19
log
@On via-pmu systems, check whether the firmware has found adb devices on the
bus to decide whether to go the long way or not when resetting the bus.
Fixes the long delay probe on Mac Mini. Tested by various.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.18 2006/01/18 23:21:17 miod Exp $	*/
d281 1
d1528 1
a1528 1
		output[2] = 0x0a;	/* set date/time */
d1559 1
a1559 1
	output[1] = 0x01;	/* to pram/rtc device */
d1563 1
a1563 1
		(void *)&flag, 0);
d1571 20
d1740 5
@


1.18
log
@Factorize akbd and ams drivers between mac68k and macppc; while there, start
moving out common adb code as well, and merge adb_direct.c into adb.c to
simplify external header files.

No functional change; more cleanups to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.17 2006/01/08 17:25:05 miod Exp $	*/
d252 1
d1646 1
a1646 1
	else if (strcmp(ca->ca_name, "via-pmu") == 0)
d1648 16
@


1.17
log
@Display unhandled adb devices as "whatever at adb0 addr X" like all buses do;
while there, make the detailed descriptions dependent on ADBVERBOSE (enabled
in GENERIC) instead of DIAGNOSTIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.16 2005/12/21 18:50:52 miod Exp $	*/
d3 1
d5 1219
a1223 3
/*-
 * Copyright (C) 1994	Bradley A. Grantham
 * All rights reserved.
d1225 2
a1226 13
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bradley A. Grantham.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d1228 2
a1229 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d1231 12
d1244 2
a1245 8
#include <sys/param.h>
#include <sys/device.h>
#include <sys/fcntl.h>
#include <sys/poll.h>
#include <sys/selinfo.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/systm.h>
d1247 4
a1250 2
#include <machine/autoconf.h>
#include <dev/ofw/openfirm.h>
a1251 5
#include <macppc/dev/adbvar.h>
#include <macppc/dev/akbdvar.h>
#include <macppc/dev/viareg.h>

#include "apm.h"
d1254 9
a1262 1
 * Function declarations.
d1264 38
a1301 3
int	adbmatch(struct device *, void *, void *);
void	adbattach(struct device *, struct device *, void *);
int	adbprint(void *, const char *);
d1304 4
a1307 1
 * Global variables.
d1309 49
a1357 1
int	adb_polling;		/* Are we polling?  (Debugger mode) */
d1359 233
a1591 2
int	adb_debug;		/* Output debugging messages */
#endif /* ADB_DEBUG */
d1596 4
a1602 3
struct cfdriver adb_cd = {
	NULL, "adb", DV_DULL
};
d1649 1
a1649 1
	ADBReInit();
d1660 1
a1660 1
		printf("adb: done with ADBReInit\n");
d1662 1
a1662 12
	totaladbs = CountADBs();

	printf(" irq %d", ca->ca_intr[0]);

	switch (adbHardware) {
	case ADB_HW_CUDA:
		printf(": via-cuda");
		break;
	case ADB_HW_PMU:
		printf(": via-pmu");
		break;
	}
d1664 2
a1665 1
	printf(", %d target%s\n", totaladbs, (totaladbs == 1) ? "" : "s");
d1670 1
a1670 1
		adbaddr = GetIndADB(&adbdata, adbindex);
a1701 66
}

int
adbprint(void *args, const char *name)
{
	struct adb_attach_args *aa_args = (struct adb_attach_args *)args;
	int rv = UNCONF;

	if (name) {	/* no configured device matched */
		rv = UNSUPP; /* most ADB device types are unsupported */

		/* print out what kind of ADB device we have found */
		switch(aa_args->origaddr) {
#ifdef ADBVERBOSE
		case ADBADDR_SECURE:
			printf("security dongle (%d)", aa_args->handler_id);
			break;
#endif
		case ADBADDR_MAP:
			printf("mapped device (%d)", aa_args->handler_id);
			rv = UNCONF;
			break;
		case ADBADDR_REL:
			printf("relative positioning device (%d)",
			    aa_args->handler_id);
			rv = UNCONF;
			break;
#ifdef ADBVERBOSE
		case ADBADDR_ABS:
			switch (aa_args->handler_id) {
			case ADB_ARTPAD:
				printf("WACOM ArtPad II");
				break;
			default:
				printf("absolute positioning device (%d)",
				    aa_args->handler_id);
				break;
			}
			break;
		case ADBADDR_DATATX:
			printf("data transfer device (modem?) (%d)",
			    aa_args->handler_id);
			break;
		case ADBADDR_MISC:
			switch (aa_args->handler_id) {
			case ADB_POWERKEY:
				printf("Sophisticated Circuits PowerKey");
				break;
			default:
				printf("misc. device (remote control?) (%d)",
				    aa_args->handler_id);
				break;
			}
			break;
		default:
			printf("unknown type %d device, (handler %d)",
			    aa_args->origaddr, aa_args->handler_id);
			break;
#endif /* ADBVERBOSE */
		}
		printf(" at %s", name);
	}

	printf(" addr %d", aa_args->adbaddr);

	return (rv);
@


1.16
log
@Remove aed(4) on macppc, nothing uses its functionality since key repeat is
handled by wscons and mouse emulation was never enabled or documented.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.15 2005/11/21 18:16:37 millert Exp $	*/
d148 1
a148 1
	printf(", %d targets\n", totaladbs);
a196 1
		printf("%s addr %d: ", name, aa_args->adbaddr);
d198 1
a198 1
#ifdef DIAGNOSTIC
d212 1
a212 1
#ifdef DIAGNOSTIC
d240 2
a241 2
			printf("unknown type device, (handler %d)",
			    aa_args->handler_id);
d243 1
a243 1
#endif /* DIAGNOSTIC */
d245 4
a248 2
	} else		/* a device matched and was configured */
		printf(" addr %d: ", aa_args->adbaddr);
d250 1
a250 1
	return rv;
@


1.15
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.14 2005/11/16 12:28:54 kettenis Exp $	*/
a49 1
#include "aed.h"
a149 8
#if NAED > 0
	/* ADB event device for compatibility */
	aa_args.origaddr = 0;
	aa_args.adbaddr = 0;
	aa_args.handler_id = 0;
	(void)config_found(self, &aa_args, adbprint);
#endif

a199 6
#if NAED > 0
		case 0:
			printf("ADB event device");
			rv = UNCONF;
			break;
#endif
@


1.14
log
@Add support for the I2C controller on via-pmu.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.13 2005/10/21 22:07:45 kettenis Exp $	*/
d38 1
a38 1
#include <sys/select.h>
@


1.13
log
@Clean up RTC code.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.12 2005/10/15 15:01:23 martin Exp $	*/
d44 1
d103 3
d183 11
@


1.12
log
@- merge adb_direct.h bits into adbvar.h
- rename ADB_HW_PB to ADB_HW_PMU

from NetBSD

ok brad@@; additonal testing krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.11 2005/09/30 01:28:05 deraadt Exp $	*/
a96 10
/* HACK ALERT */
typedef int (clock_read_t)(int *sec, int *min, int *hour, int *day,
	    int *mon, int *yr);
typedef int (time_read_t)(u_long *sec);
typedef int (time_write_t)(u_long sec);
extern time_read_t  *time_read;
extern time_write_t  *time_write;
extern clock_read_t  *clock_read;


a124 1
	clock_read = NULL;
@


1.11
log
@pretty print
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.10 2005/06/06 01:08:46 miod Exp $	*/
a45 1
#include <macppc/dev/adb_direct.h>
d126 1
a126 1
		adbHardware = ADB_HW_PB;
d151 1
a151 1
	case ADB_HW_PB:
@


1.10
log
@Homogeneize dmesg output.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.9 2003/10/16 03:54:48 deraadt Exp $	*/
d149 6
a154 6
		case ADB_HW_CUDA:
			printf(": via-cuda ");
			break;
		case ADB_HW_PB:
			printf(": via-pmu ");
			break;
@


1.9
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.8 2003/10/16 03:31:25 drahn Exp $	*/
d157 1
a157 1
	printf("%d targets\n", totaladbs);
@


1.8
log
@more ANSI/KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.7 2002/09/15 09:01:58 deraadt Exp $	*/
d63 1
a63 1
int     adb_polling;		/* Are we polling?  (Debugger mode) */
d100 1
a100 1
         int *mon, int *yr);
d156 1
a156 1
 
a157 1
	
d259 1
a259 1
                printf(" addr %d: ", aa_args->adbaddr);
@


1.7
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.5 2002/06/07 07:14:48 miod Exp $	*/
d79 1
a79 4
adbmatch(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
d109 1
a109 3
adbattach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;
d133 1
a133 1
		adb_intr, sc, "adb");
d195 1
a195 3
adbprint(args, name)
	void *args;
	const char *name;
@


1.6
log
@KNF
@
text
@d63 1
a63 1
int	adb_polling;		/* Are we polling?  (Debugger mode) */
d103 1
a103 1
    int *mon, int *yr);
d161 1
a161 1

d163 1
d212 1
a212 1
		switch (aa_args->origaddr) {
d267 1
a267 1
		printf(" addr %d: ", aa_args->adbaddr);
@


1.5
log
@Vacuum cleaning of the adb code, step 1: random KNF, remove mac68k
leftovers, unused variables and functions, fix some comments, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.4 2002/03/14 01:26:36 millert Exp $	*/
d63 1
a63 1
int     adb_polling;		/* Are we polling?  (Debugger mode) */
d103 1
a103 1
         int *mon, int *yr);
d161 1
a161 1
 
a162 1
	
d211 1
a211 1
		switch(aa_args->origaddr) {
d266 1
a266 1
                printf(" addr %d: ", aa_args->adbaddr);
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.3 2001/10/03 14:45:37 drahn Exp $	*/
d46 1
d56 3
a58 3
static int	adbmatch(struct device *, void *, void *);
static void	adbattach(struct device *, struct device *, void *);
static int	adbprint(void *, const char *);
d63 1
a63 2
int     adb_polling = 0;	/* Are we polling?  (Debugger mode) */
int     adb_initted = 0;	/* adb_init() has completed successfully */
d65 1
a65 1
int	adb_debug = 0;		/* Output debugging messages */
d78 1
a78 1
static int
a101 3
int adb_read_date_time(unsigned long *time);
int adb_write_date_time(unsigned long time);
int adb_set_date_time(unsigned long time);
d104 2
a105 2
typedef int (time_read_t)(unsigned long *sec);
typedef int (time_write_t)(unsigned long sec);
d111 1
a111 2

static void
a123 2
	extern volatile u_char *Via1Base;

d214 1
d219 1
@


1.3
log
@apm support for macppc. This is not fully implemented, sleep modes
and power event are not handled, however it is enough support
to poll the battery/AC/charging states of the system.
Code by Alexander Guy.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.2 2001/09/01 17:43:08 drahn Exp $	*/
d55 3
a57 3
static int	adbmatch __P((struct device *, void *, void *));
static void	adbattach __P((struct device *, struct device *, void *));
static int	adbprint __P((void *, const char *));
@


1.3.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.3 2001/10/03 14:45:37 drahn Exp $	*/
a45 1
#include <macppc/dev/adb_direct.h>
d55 3
a57 3
int	adbmatch(struct device *, void *, void *);
void	adbattach(struct device *, struct device *, void *);
int	adbprint(void *, const char *);
d62 2
a63 1
int     adb_polling;		/* Are we polling?  (Debugger mode) */
d65 1
a65 1
int	adb_debug;		/* Output debugging messages */
d78 1
a78 1
int
d102 3
d107 2
a108 2
typedef int (time_read_t)(u_long *sec);
typedef int (time_write_t)(u_long sec);
d114 2
a115 1
void
d128 2
a219 1
#if NAED > 0
a223 1
#endif
@


1.3.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.3.6.1 2002/06/11 03:36:33 art Exp $	*/
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Merge in -current from about a week ago
@
text
@d55 3
a57 3
static int	adbmatch(struct device *, void *, void *);
static void	adbattach(struct device *, struct device *, void *);
static int	adbprint(void *, const char *);
@


1.3.4.3
log
@Sync the SMP branch with 3.3
@
text
@a45 1
#include <macppc/dev/adb_direct.h>
d55 3
a57 3
int	adbmatch(struct device *, void *, void *);
void	adbattach(struct device *, struct device *, void *);
int	adbprint(void *, const char *);
d62 2
a63 1
int     adb_polling;		/* Are we polling?  (Debugger mode) */
d65 1
a65 1
int	adb_debug;		/* Output debugging messages */
d78 1
a78 1
int
d102 3
d107 2
a108 2
typedef int (time_read_t)(u_long *sec);
typedef int (time_write_t)(u_long sec);
d114 2
a115 1
void
d128 2
a219 1
#if NAED > 0
a223 1
#endif
@


1.3.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d63 1
a63 1
int	adb_polling;		/* Are we polling?  (Debugger mode) */
d79 4
a82 1
adbmatch(struct device *parent, void *cf, void *aux)
d103 1
a103 1
	    int *mon, int *yr);
d112 3
a114 1
adbattach(struct device *parent, struct device *self, void *aux)
d138 1
a138 1
	    adb_intr, sc, "adb");
d161 1
a161 1

d163 1
d200 3
a202 1
adbprint(void *args, const char *name)
d267 1
a267 1
		printf(" addr %d: ", aa_args->adbaddr);
@


1.2
log
@correct files for the powerpc/mac/ -> macppc/dev which did not get
renamed correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.1 2001/09/01 15:50:00 drahn Exp $	*/
d50 1
a77 2
extern int adbHardware;

d158 12
a169 1
	printf(": %d targets\n", totaladbs);
d190 9
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/mac to macppc/dev
@
text
@d1 1
a1 1
/*	$OpenBSD: adb.c,v 1.5 2001/07/04 08:38:49 niklas Exp $	*/
d45 3
a47 3
#include <macppc/mac/adbvar.h>
#include <macppc/mac/akbdvar.h>
#include <macppc/mac/viareg.h>
@

