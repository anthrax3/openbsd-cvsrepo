head	1.33;
access;
symbols
	OPENBSD_6_2_BASE:1.33
	OPENBSD_6_1:1.32.0.16
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.32.0.12
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.8
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.10
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.32.0.6
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.29.0.8
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.6
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.4
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.28.0.4
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.18.0.4
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.6
	UBC:1.3.0.2
	UBC_BASE:1.3
	SMP:1.2.0.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.33
date	2017.06.22.11.34.51;	author tom;	state Exp;
branches;
next	1.32;
commitid	UB6ah54suwoUhGTY;

1.32
date	2013.12.06.21.03.05;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.05.31.14.30.51;	author mpi;	state Exp;
branches;
next	1.30;

1.30
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2011.04.03.12.42.36;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2010.07.01.03.20.38;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2010.04.09.17.01.30;	author jasper;	state Exp;
branches;
next	1.25;

1.25
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2010.01.13.06.09.44;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.01.23.06.03;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.25.17.52.02;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2008.10.15.19.12.19;	author blambert;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.30.18.08.03;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.22.22.31.14;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.02.21.46.30;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.20.08.55.20;	author gwk;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.14.00.58.45;	author gwk;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.08.01.19.44;	author thib;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.26.22.31.12;	author gwk;	state Exp;
branches;
next	1.11;

1.11
date	2006.09.26.00.00.38;	author gwk;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.19.22.42.33;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.25.23.02.24;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.09.22.57.09;	author jmc;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.16.03.54.48;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.15.02.02.43;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.09.15.01.51.11;	author mickey;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2001.09.01.15.50.00;	author drahn;	state Exp;
branches;
next	;

1.2.4.1
date	2001.10.31.03.01.15;	author nate;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Fix the remaining ';;'s in sys/
@
text
@/*	$OpenBSD: mesh.c,v 1.32 2013/12/06 21:03:05 deraadt Exp $	*/
/*	$NetBSD: mesh.c,v 1.1 1999/02/19 13:06:03 tsubai Exp $	*/

/*-
 * Copyright (c) 2000	Tsubai Masanari.
 * Copyright (c) 1999	Internet Research Institute, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by
 *	Internet Research Institute, Inc.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_message.h>

#include <dev/ofw/openfirm.h>

#include <machine/autoconf.h>
#include <machine/cpu.h>

#include <macppc/dev/dbdma.h>

#ifdef MESH_DEBUG
# define DPRINTF printf
#else
# define DPRINTF while (0) printf
#endif

/* MESH register offsets */
#define MESH_XFER_COUNT0	0x00	/* transfer count (low)  */
#define MESH_XFER_COUNT1	0x10	/* transfer count (high) */
#define MESH_FIFO		0x20	/* FIFO (16byte depth) */
#define MESH_SEQUENCE		0x30	/* command register */
#define MESH_BUS_STATUS0	0x40
#define MESH_BUS_STATUS1	0x50
#define MESH_FIFO_COUNT		0x60
#define MESH_EXCEPTION		0x70
#define MESH_ERROR		0x80
#define MESH_INTR_MASK		0x90
#define MESH_INTERRUPT		0xa0
#define MESH_SOURCE_ID		0xb0
#define MESH_DEST_ID		0xc0
#define MESH_SYNC_PARAM		0xd0
#define MESH_MESH_ID		0xe0	/* MESH version */
#define MESH_SEL_TIMEOUT	0xf0	/* selection timeout delay */

#define MESH_SIGNATURE		0xe2	/* XXX wrong! */

/* MESH commands */
#define MESH_CMD_ARBITRATE	0x01
#define MESH_CMD_SELECT		0x02
#define MESH_CMD_COMMAND	0x03
#define MESH_CMD_STATUS		0x04
#define MESH_CMD_DATAOUT	0x05
#define MESH_CMD_DATAIN		0x06
#define MESH_CMD_MSGOUT		0x07
#define MESH_CMD_MSGIN		0x08
#define MESH_CMD_BUSFREE	0x09
#define MESH_CMD_ENABLE_PARITY	0x0A
#define MESH_CMD_DISABLE_PARITY	0x0B
#define MESH_CMD_ENABLE_RESEL	0x0C
#define MESH_CMD_DISABLE_RESEL	0x0D
#define MESH_CMD_RESET_MESH	0x0E
#define MESH_CMD_FLUSH_FIFO	0x0F
#define MESH_SEQ_DMA		0x80
#define MESH_SEQ_TARGET		0x40
#define MESH_SEQ_ATN		0x20
#define MESH_SEQ_ACTNEG		0x10

/* INTERRUPT/INTR_MASK register bits */
#define MESH_INTR_ERROR		0x04
#define MESH_INTR_EXCEPTION	0x02
#define MESH_INTR_CMDDONE	0x01

/* EXCEPTION register bits */
#define MESH_EXC_SELATN		0x20	/* selected and ATN asserted (T) */
#define MESH_EXC_SELECTED	0x10	/* selected (T) */
#define MESH_EXC_RESEL		0x08	/* reselected */
#define MESH_EXC_ARBLOST	0x04	/* arbitration lost */
#define MESH_EXC_PHASEMM	0x02	/* phase mismatch */
#define MESH_EXC_SELTO		0x01	/* selection timeout */

/* ERROR register bits */
#define MESH_ERR_DISCONNECT	0x40	/* unexpected disconnect */
#define MESH_ERR_SCSI_RESET	0x20	/* Rst signal asserted */
#define MESH_ERR_SEQERR		0x10	/* sequence error */
#define MESH_ERR_PARITY_ERR3	0x08	/* parity error */
#define MESH_ERR_PARITY_ERR2	0x04
#define MESH_ERR_PARITY_ERR1	0x02
#define MESH_ERR_PARITY_ERR0	0x01

/* BUS_STATUS0 status bits */
#define MESH_STATUS0_REQ32	0x80
#define MESH_STATUS0_ACK32	0x40
#define MESH_STATUS0_REQ	0x20
#define MESH_STATUS0_ACK	0x10
#define MESH_STATUS0_ATN	0x08
#define MESH_STATUS0_MSG	0x04
#define MESH_STATUS0_CD		0x02
#define MESH_STATUS0_IO		0x01

/* BUS_STATUS1 status bits */
#define MESH_STATUS1_RST	0x80
#define MESH_STATUS1_BSY	0x40
#define MESH_STATUS1_SEL	0x20

#define T_SYNCMODE 0x01		/* target uses sync mode */
#define T_SYNCNEGO 0x02		/* sync negotiation done */

struct mesh_tinfo {
	int flags;
	int period;
	int offset;
};

/* scb flags */
#define MESH_POLL		0x01
#define MESH_CHECK		0x02
#define MESH_SENSE		0x04
#define MESH_READ		0x80

struct mesh_scb {
	TAILQ_ENTRY(mesh_scb) chain;
	int flags;
	struct scsi_xfer *xs;
	struct scsi_generic cmd;
	int cmdlen;
	int target;			/* target SCSI ID */
	int resid;
	void *daddr;
	vsize_t dlen;
	int status;
};

/* sc_flags value */
#define MESH_DMA_ACTIVE	0x01

#define MESH_DMALIST_MAX	32

struct mesh_softc {
	struct device sc_dev;		/* us as a device */
	struct scsi_link sc_link;

	u_char *sc_reg;			/* MESH base address */
	bus_dmamap_t sc_dmamap;
	bus_dma_tag_t sc_dmat;
	struct dbdma_regmap *sc_dmareg;	/* DMA register address */
	struct dbdma_command *sc_dmacmd;	/* DMA command area */
	dbdma_t sc_dbdma;

	int sc_flags;
	int sc_cfflags;			/* copy of config flags */
	int sc_minsync;			/* minimum sync period */
	int sc_irq;
	int sc_freq;			/* SCSI bus frequency in MHz */
	int sc_id;			/* our SCSI ID */
	struct mesh_tinfo sc_tinfo[8];	/* target information */

	int sc_nextstate;
	int sc_prevphase;
	struct mesh_scb *sc_nexus;	/* current command */

	int sc_msgout;
	int sc_imsglen;
	u_char sc_imsg[16];
	u_char sc_omsg[16];

	TAILQ_HEAD(, mesh_scb) free_scb;
	TAILQ_HEAD(, mesh_scb) ready_scb;
	struct mesh_scb sc_scb[16];

	struct timeout sc_tmo;

	struct mutex		sc_scb_mtx;
	struct scsi_iopool	sc_iopool;
};

/* mesh_msgout() values */
#define SEND_REJECT	1
#define SEND_IDENTIFY	2
#define SEND_SDTR	4

static inline int mesh_read_reg(struct mesh_softc *, int);
static inline void mesh_set_reg(struct mesh_softc *, int, int);

int mesh_match(struct device *, void *, void *);
void mesh_attach(struct device *, struct device *, void *);
int mesh_activate(struct device *, int);

int mesh_intr(void *);
void mesh_error(struct mesh_softc *, struct mesh_scb *, int, int);
void mesh_select(struct mesh_softc *, struct mesh_scb *);
void mesh_identify(struct mesh_softc *, struct mesh_scb *);
void mesh_command(struct mesh_softc *, struct mesh_scb *);
int mesh_dma_setup(struct mesh_softc *, struct mesh_scb *);
int mesh_dataio(struct mesh_softc *, struct mesh_scb *);
void mesh_status(struct mesh_softc *, struct mesh_scb *);
void mesh_msgin(struct mesh_softc *, struct mesh_scb *);
void mesh_msgout(struct mesh_softc *, int);
void mesh_bus_reset(struct mesh_softc *);
void mesh_reset(struct mesh_softc *);
int mesh_stp(struct mesh_softc *, int);
void mesh_setsync(struct mesh_softc *, struct mesh_tinfo *);
struct mesh_scb *mesh_get_scb(struct mesh_softc *);
void *mesh_scb_alloc(void *);
void mesh_scb_free(void *, void *);
void mesh_scsi_cmd(struct scsi_xfer *);
void mesh_sched(struct mesh_softc *);
int mesh_poll(struct scsi_xfer *);
void mesh_done(struct mesh_softc *, struct mesh_scb *);
void mesh_timeout(void *);
void mesh_minphys(struct buf *, struct scsi_link *);

struct cfattach mesh_ca = {
	sizeof(struct mesh_softc), mesh_match, mesh_attach,
	NULL, mesh_activate
};

struct cfdriver mesh_cd = {
	NULL, "mesh", DV_DULL
};

struct scsi_adapter mesh_switch = {
	mesh_scsi_cmd, mesh_minphys, NULL, NULL
};

#define MESH_DATAOUT	0
#define MESH_DATAIN	MESH_STATUS0_IO
#define MESH_COMMAND	MESH_STATUS0_CD
#define MESH_STATUS	(MESH_STATUS0_CD | MESH_STATUS0_IO)
#define MESH_MSGOUT	(MESH_STATUS0_MSG | MESH_STATUS0_CD)
#define MESH_MSGIN	(MESH_STATUS0_MSG | MESH_STATUS0_CD | MESH_STATUS0_IO)

#define MESH_SELECTING	8
#define MESH_IDENTIFY	9
#define MESH_COMPLETE	10
#define MESH_BUSFREE	11
#define MESH_UNKNOWN	-1

#define MESH_PHASE_MASK	(MESH_STATUS0_MSG | MESH_STATUS0_CD | MESH_STATUS0_IO)

int
mesh_match(struct device *parent, void *vcf, void *aux)
{
	struct confargs *ca = aux;
	char compat[32];

	if (strcmp(ca->ca_name, "mesh") == 0)
		return 1;

	bzero(compat, sizeof(compat));
	OF_getprop(ca->ca_node, "compatible", compat, sizeof(compat));
	if (strcmp(compat, "chrp,mesh0") == 0)
		return 1;

	return 0;
}

void
mesh_attach(struct device *parent, struct device *self, void *aux)
{
	struct mesh_softc *sc = (void *)self;
	struct confargs *ca = aux;
	struct scsibus_attach_args saa;
	int i, error;
	u_int *reg;

	reg = ca->ca_reg;
	reg[0] += ca->ca_baseaddr;
	reg[2] += ca->ca_baseaddr;
	if ((sc->sc_reg = mapiodev(reg[0], reg[1])) == NULL) {
		printf(": cannot map device registers\n");
		return;
	}

	sc->sc_irq = ca->ca_intr[0];
	if ((sc->sc_dmareg = mapiodev(reg[2], reg[3])) == NULL) {
		printf(": cannot map DMA registers\n");
		goto noreg;
	}

	sc->sc_cfflags = sc->sc_dev.dv_cfdata->cf_flags;

	if (OF_getprop(ca->ca_node, "clock-frequency", &sc->sc_freq, 4) != 4) {
		printf(": cannot get clock-frequency\n");
		goto nofreq;
	}

	sc->sc_dmat = ca->ca_dmat;
	if ((error = bus_dmamap_create(sc->sc_dmat,
	    MESH_DMALIST_MAX * DBDMA_COUNT_MAX, MESH_DMALIST_MAX,
	    DBDMA_COUNT_MAX, NBPG, BUS_DMA_NOWAIT, &sc->sc_dmamap)) != 0) {
		printf(": cannot create DMA map, error = %d\n", error);
		goto nofreq;
	}

	sc->sc_freq /= 1000000;	/* in MHz */
	sc->sc_minsync = 25;	/* maximum sync rate = 10MB/sec */
	sc->sc_id = 7;

	TAILQ_INIT(&sc->free_scb);
	TAILQ_INIT(&sc->ready_scb);
	mtx_init(&sc->sc_scb_mtx, IPL_BIO);
	scsi_iopool_init(&sc->sc_iopool, sc, mesh_scb_alloc, mesh_scb_free);
	for (i = 0; i < sizeof(sc->sc_scb)/sizeof(sc->sc_scb[0]); i++)
		TAILQ_INSERT_TAIL(&sc->free_scb, &sc->sc_scb[i], chain);

	if ((sc->sc_dbdma = dbdma_alloc(sc->sc_dmat, MESH_DMALIST_MAX))
	    == NULL) {
		printf(": cannot alloc dma descriptors\n");
		goto nodbdma;
	}

	sc->sc_dmacmd = sc->sc_dbdma->d_addr;
	timeout_set(&sc->sc_tmo, mesh_timeout, sc);

	mesh_reset(sc);
	mesh_bus_reset(sc);

	printf(" irq %d: %dMHz\n", sc->sc_irq, sc->sc_freq);

	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = sc->sc_id;
	sc->sc_link.adapter = &mesh_switch;
	sc->sc_link.openings = 2;
	sc->sc_link.pool = &sc->sc_iopool;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	config_found(&sc->sc_dev, &saa, scsiprint);

	mac_intr_establish(parent, sc->sc_irq, IST_LEVEL, IPL_BIO, mesh_intr,
	    sc, sc->sc_dev.dv_xname);

	return;
nodbdma:
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_dmamap);
nofreq:
	unmapiodev(sc->sc_dmareg, reg[3]);
noreg:
	unmapiodev(sc->sc_reg, reg[1]);
}

int
mesh_activate(struct device *self, int act)
{
	struct mesh_softc *sc = (struct mesh_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		/* Set to async mode. */
		mesh_set_reg(sc, MESH_SYNC_PARAM, 2);
		mesh_bus_reset(sc);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

#define MESH_SET_XFER(sc, count) do {					\
	mesh_set_reg(sc, MESH_XFER_COUNT0, count);			\
	mesh_set_reg(sc, MESH_XFER_COUNT1, count >> 8);			\
} while (0)

#define MESH_GET_XFER(sc) ((mesh_read_reg(sc, MESH_XFER_COUNT1) << 8) |	\
			   mesh_read_reg(sc, MESH_XFER_COUNT0))

int
mesh_read_reg(struct mesh_softc *sc, int reg)
{
	return in8(sc->sc_reg + reg);
}

void
mesh_set_reg(struct mesh_softc *sc, int reg, int val)
{
	out8(sc->sc_reg + reg, val);
}

#ifdef MESH_DEBUG
static char scsi_phase[][8] = {
	"DATAOUT",
	"DATAIN",
	"COMMAND",
	"STATUS",
	"",
	"",
	"MSGOUT",
	"MSGIN"
};
#endif

int
mesh_intr(void *arg)
{
	struct mesh_softc *sc = arg;
	struct mesh_scb *scb;
	int fifocnt;
	u_char intr, exception, error, status0, status1;

	intr = mesh_read_reg(sc, MESH_INTERRUPT);

	if (intr == 0) {
		DPRINTF("%s: stray interrupt\n", sc->sc_dev.dv_xname);
		return 0;
	}
	exception = mesh_read_reg(sc, MESH_EXCEPTION);
	error = mesh_read_reg(sc, MESH_ERROR);
	status0 = mesh_read_reg(sc, MESH_BUS_STATUS0);
	status1 = mesh_read_reg(sc, MESH_BUS_STATUS1);

	/* clear interrupt */
	mesh_set_reg(sc, MESH_INTERRUPT, intr);

#ifdef MESH_DEBUG
{

	printf("mesh_intr status0 = 0x%x (%s), exc = 0x%x\n",
	    status0, scsi_phase[status0 & 7], exception);
}
#endif

	scb = sc->sc_nexus;
	if (scb == NULL) {
		DPRINTF("%s: NULL nexus\n", sc->sc_dev.dv_xname);
		return 1;
	}

	if (intr & MESH_INTR_CMDDONE) {
		if (sc->sc_flags & MESH_DMA_ACTIVE) {
			dbdma_stop(sc->sc_dmareg);
			bus_dmamap_unload(sc->sc_dmat, sc->sc_dmamap);

			sc->sc_flags &= ~MESH_DMA_ACTIVE;
			scb->resid = MESH_GET_XFER(sc);

			fifocnt = mesh_read_reg(sc, MESH_FIFO_COUNT);
			if (fifocnt != 0) {
				if (scb->flags & MESH_READ) {
					char *cp;

					cp = (char *)scb->daddr + scb->dlen
					    - fifocnt;
					DPRINTF("fifocnt = %d, resid = %d\n",
					    fifocnt, scb->resid);
					while (fifocnt > 0) {
						*cp++ = mesh_read_reg(sc,
						    MESH_FIFO);
						fifocnt--;
					}
				} else {
					mesh_set_reg(sc, MESH_SEQUENCE,
					    MESH_CMD_FLUSH_FIFO);
				}
			} else {
				/* Clear all interrupts */
				mesh_set_reg(sc, MESH_INTERRUPT, 7);
			}
		}
	}

	if (intr & MESH_INTR_ERROR) {
		printf("%s: error %02x %02x\n",
		    sc->sc_dev.dv_xname, error, exception);
		mesh_error(sc, scb, error, 0);
		return 1;
	}

	if (intr & MESH_INTR_EXCEPTION) {
		/* selection timeout */
		if (exception & MESH_EXC_SELTO) {
			mesh_error(sc, scb, 0, exception);
			return 1;
		}

		/* phase mismatch */
		if (exception & MESH_EXC_PHASEMM) {
			DPRINTF("%s: PHASE MISMATCH; nextstate = %d -> ",
			    sc->sc_dev.dv_xname, sc->sc_nextstate);
			sc->sc_nextstate = status0 & MESH_PHASE_MASK;

			DPRINTF("%d, resid = %d\n",
			    sc->sc_nextstate, scb->resid);
		}
	}

	if (sc->sc_nextstate == MESH_UNKNOWN)
		sc->sc_nextstate = status0 & MESH_PHASE_MASK;

	switch (sc->sc_nextstate) {

	case MESH_IDENTIFY:
		mesh_identify(sc, scb);
		break;
	case MESH_COMMAND:
		mesh_command(sc, scb);
		break;
	case MESH_DATAIN:
	case MESH_DATAOUT:
		if (mesh_dataio(sc, scb)) {
			scb->xs->error = XS_DRIVER_STUFFUP;
			mesh_done(sc, scb);
		}
		break;
	case MESH_STATUS:
		mesh_status(sc, scb);
		break;
	case MESH_MSGIN:
		mesh_msgin(sc, scb);
		break;
	case MESH_COMPLETE:
		mesh_done(sc, scb);
		break;

	default:
		printf("%s: unknown state (%d)\n", sc->sc_dev.dv_xname,
		    sc->sc_nextstate);
		scb->xs->error = XS_DRIVER_STUFFUP;
		mesh_done(sc, scb);
	}

	return 1;
}

void
mesh_error(struct mesh_softc *sc, struct mesh_scb *scb, int error,
    int exception)
{
	if (error & MESH_ERR_SCSI_RESET) {
		printf("%s: SCSI RESET\n", sc->sc_dev.dv_xname);

		/* Wait until the RST signal is deasserted. */
		while (mesh_read_reg(sc, MESH_BUS_STATUS1) & MESH_STATUS1_RST);
			mesh_reset(sc);
		return;
	}

	if (error & MESH_ERR_PARITY_ERR0) {
		printf("%s: parity error\n", sc->sc_dev.dv_xname);
		scb->xs->error = XS_DRIVER_STUFFUP;
	}

	if (error & MESH_ERR_DISCONNECT) {
		printf("%s: unexpected disconnect\n", sc->sc_dev.dv_xname);
		if (sc->sc_nextstate != MESH_COMPLETE)
			scb->xs->error = XS_DRIVER_STUFFUP;
	}

	if (exception & MESH_EXC_SELTO) {
		/* XXX should reset bus here? */
		scb->xs->error = XS_SELTIMEOUT;
	}

	mesh_done(sc, scb);
}

void
mesh_select(struct mesh_softc *sc, struct mesh_scb *scb)
{
	struct mesh_tinfo *ti = &sc->sc_tinfo[scb->target];

	DPRINTF("mesh_select\n");

	mesh_setsync(sc, ti);
	MESH_SET_XFER(sc, 0);

	/* arbitration */

	/*
	 * MESH mistakenly asserts TARGET ID bit along with its own ID bit
	 * in arbitration phase (like selection).  So we should load
	 * initiator ID to DestID register temporarily.
	 */
	mesh_set_reg(sc, MESH_DEST_ID, sc->sc_id);
	mesh_set_reg(sc, MESH_INTR_MASK, 0);	/* disable intr. */
	mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_ARBITRATE);

	while (mesh_read_reg(sc, MESH_INTERRUPT) == 0);
	mesh_set_reg(sc, MESH_INTERRUPT, 1);
	mesh_set_reg(sc, MESH_INTR_MASK, 7);

	/* selection */
	mesh_set_reg(sc, MESH_DEST_ID, scb->target);
	mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_SELECT | MESH_SEQ_ATN);

	sc->sc_prevphase = MESH_SELECTING;
	sc->sc_nextstate = MESH_IDENTIFY;

	timeout_add_sec(&sc->sc_tmo, 10);
}

void
mesh_identify(struct mesh_softc *sc, struct mesh_scb *scb)
{
	struct mesh_tinfo *ti = &sc->sc_tinfo[scb->target];

	DPRINTF("mesh_identify\n");
	mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_FLUSH_FIFO);

	if ((ti->flags & T_SYNCNEGO) == 0) {
		ti->period = sc->sc_minsync;
		ti->offset = 15;
		mesh_msgout(sc, SEND_IDENTIFY | SEND_SDTR);
		sc->sc_nextstate = MESH_MSGIN;
	} else {
		mesh_msgout(sc, SEND_IDENTIFY);
		sc->sc_nextstate = MESH_COMMAND;
	}
}

void
mesh_command(struct mesh_softc *sc, struct mesh_scb *scb)
{
	int i;
	char *cmdp;

#ifdef MESH_DEBUG
	printf("mesh_command cdb = %02x", scb->cmd.opcode);
	for (i = 0; i < 5; i++)
		printf(" %02x", scb->cmd.bytes[i]);
	printf("\n");
#endif

	mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_FLUSH_FIFO);

	MESH_SET_XFER(sc, scb->cmdlen);
	mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_COMMAND);

	cmdp = (char *)&scb->cmd;
	for (i = 0; i < scb->cmdlen; i++)
		mesh_set_reg(sc, MESH_FIFO, *cmdp++);

	if (scb->resid == 0)
		sc->sc_nextstate = MESH_STATUS;		/* no data xfer */
	else
		sc->sc_nextstate = MESH_DATAIN;
}

int
mesh_dma_setup(struct mesh_softc *sc, struct mesh_scb *scb)
{
	int datain = scb->flags & MESH_READ;
	struct dbdma_command *cmdp;
	u_int cmd;
	int i, error;

	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap, scb->daddr,
	    scb->dlen, NULL, BUS_DMA_NOWAIT)) != 0)
		return (error);

	cmdp = sc->sc_dmacmd;
	cmd = datain ? DBDMA_CMD_IN_MORE : DBDMA_CMD_OUT_MORE;

	for (i = 0; i < sc->sc_dmamap->dm_nsegs; i++, cmdp++) {
		if (i + 1 == sc->sc_dmamap->dm_nsegs)
			cmd = datain ? DBDMA_CMD_IN_LAST : DBDMA_CMD_OUT_LAST;
		DBDMA_BUILD(cmdp, cmd, 0, sc->sc_dmamap->dm_segs[i].ds_len,
		    sc->sc_dmamap->dm_segs[i].ds_addr, DBDMA_INT_NEVER,
		    DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
	}

	DBDMA_BUILD(cmdp, DBDMA_CMD_STOP, 0, 0, 0,
	    DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);

	return(0);
}

int
mesh_dataio(struct mesh_softc *sc, struct mesh_scb *scb)
{
	int error;

	if ((error = mesh_dma_setup(sc, scb)))
		return(error);

	if (scb->dlen == 65536)
		MESH_SET_XFER(sc, 0);	/* TC = 0 means 64KB transfer */
	else
		MESH_SET_XFER(sc, scb->dlen);

	if (scb->flags & MESH_READ)
		mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_DATAIN | MESH_SEQ_DMA);
	else
		mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_DATAOUT | MESH_SEQ_DMA);

	dbdma_start(sc->sc_dmareg, sc->sc_dbdma);
	sc->sc_flags |= MESH_DMA_ACTIVE;
	sc->sc_nextstate = MESH_STATUS;

	return(0);
}

void
mesh_status(struct mesh_softc *sc, struct mesh_scb *scb)
{
	if (mesh_read_reg(sc, MESH_FIFO_COUNT) == 0) {	/* XXX cheat */
		DPRINTF("mesh_status(0)\n");
		MESH_SET_XFER(sc, 1);
		mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_STATUS);
		sc->sc_nextstate = MESH_STATUS;
		return;
	}

	scb->status = mesh_read_reg(sc, MESH_FIFO);
	DPRINTF("mesh_status(1): status = 0x%x\n", scb->status);
	if (mesh_read_reg(sc, MESH_FIFO_COUNT) != 0)
		DPRINTF("FIFO_COUNT=%d\n", mesh_read_reg(sc, MESH_FIFO_COUNT));

	mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_FLUSH_FIFO);
	MESH_SET_XFER(sc, 1);
	mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_MSGIN);

	sc->sc_nextstate = MESH_MSGIN;
}

void
mesh_msgin(struct mesh_softc *sc, struct mesh_scb *scb)
{
	DPRINTF("mesh_msgin\n");

	if (mesh_read_reg(sc, MESH_FIFO_COUNT) == 0) {	/* XXX cheat */
		MESH_SET_XFER(sc, 1);
		mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_MSGIN);
		sc->sc_imsglen = 0;
		sc->sc_nextstate = MESH_MSGIN;
		return;
	}

	sc->sc_imsg[sc->sc_imsglen++] = mesh_read_reg(sc, MESH_FIFO);

	if (sc->sc_imsglen == 1 && IS1BYTEMSG(sc->sc_imsg[0]))
		goto gotit;
	if (sc->sc_imsglen == 2 && IS2BYTEMSG(sc->sc_imsg[0]))
		goto gotit;
	if (sc->sc_imsglen >= 3 && ISEXTMSG(sc->sc_imsg[0]) &&
	    sc->sc_imsglen == sc->sc_imsg[1] + 2)
		goto gotit;

	sc->sc_nextstate = MESH_MSGIN;
	MESH_SET_XFER(sc, 1);
	mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_MSGIN);
	return;

gotit:
#ifdef MESH_DEBUG
	{
		int i;
		printf("msgin:");
		for (i = 0; i < sc->sc_imsglen; i++)
			printf(" 0x%02x", sc->sc_imsg[i]);
		printf("\n");
	}
#endif

	switch (sc->sc_imsg[0]) {
	case MSG_CMDCOMPLETE:
		mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_BUSFREE);
		sc->sc_nextstate = MESH_COMPLETE;
		sc->sc_imsglen = 0;
		return;

	case MSG_MESSAGE_REJECT:
		if (sc->sc_msgout & SEND_SDTR) {
			printf("SDTR rejected\n");
			printf("using async mode\n");
			sc->sc_tinfo[scb->target].period = 0;
			sc->sc_tinfo[scb->target].offset = 0;
			mesh_setsync(sc, &sc->sc_tinfo[scb->target]);
			break;
		}
		break;

	case MSG_NOOP:
		break;

	case MSG_EXTENDED:
		goto extended_msg;

	default:
		sc_print_addr(scb->xs->sc_link);
		printf("unrecognized MESSAGE(0x%02x); sending REJECT\n",
		    sc->sc_imsg[0]);

	reject:
		mesh_msgout(sc, SEND_REJECT);
		return;
	}
	goto done;

extended_msg:
	/* process an extended message */
	switch (sc->sc_imsg[2]) {
	case MSG_EXT_SDTR:
	  {
		struct mesh_tinfo *ti = &sc->sc_tinfo[scb->target];
		int period = sc->sc_imsg[3];
		int offset = sc->sc_imsg[4];
		int r = 250 / period;
		int s = (100*250) / period - 100 * r;

		if (period < sc->sc_minsync) {
			ti->period = sc->sc_minsync;
			ti->offset = 15;
			mesh_msgout(sc, SEND_SDTR);
			return;
		}
		sc_print_addr(scb->xs->sc_link);
		/* XXX if (offset != 0) ... */
		printf("max sync rate %d.%02dMb/s\n", r, s);
		ti->period = period;
		ti->offset = offset;
		ti->flags |= T_SYNCNEGO;
		ti->flags |= T_SYNCMODE;
		mesh_setsync(sc, ti);
		goto done;
	  }
	default:
		printf("%s target %d: rejecting extended message 0x%x\n",
		    sc->sc_dev.dv_xname, scb->target, sc->sc_imsg[0]);
		goto reject;
	}

done:
	sc->sc_imsglen = 0;
	sc->sc_nextstate = MESH_UNKNOWN;

	mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_BUSFREE); /* XXX really? */
}

void
mesh_msgout(struct mesh_softc *sc, int msg)
{
	struct mesh_scb *scb = sc->sc_nexus;
	struct mesh_tinfo *ti;
	int lun, len, i;

	DPRINTF("mesh_msgout: sending");

	sc->sc_msgout = msg;
	len = 0;

	if (msg & SEND_REJECT) {
		DPRINTF(" REJECT");
		sc->sc_omsg[len++] = MSG_MESSAGE_REJECT;
	}
	if (msg & SEND_IDENTIFY) {
		DPRINTF(" IDENTIFY");
		lun = scb->xs->sc_link->lun;
		sc->sc_omsg[len++] = MSG_IDENTIFY(lun, 0);
	}
	if (msg & SEND_SDTR) {
		DPRINTF(" SDTR");
		ti = &sc->sc_tinfo[scb->target];
		sc->sc_omsg[len++] = MSG_EXTENDED;
		sc->sc_omsg[len++] = 3;
		sc->sc_omsg[len++] = MSG_EXT_SDTR;
		sc->sc_omsg[len++] = ti->period;
		sc->sc_omsg[len++] = ti->offset;
	}
	DPRINTF("\n");

	MESH_SET_XFER(sc, len);
	if (len == 1) {
		mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_MSGOUT);
		mesh_set_reg(sc, MESH_FIFO, sc->sc_omsg[0]);
	} else {
		mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_MSGOUT | MESH_SEQ_ATN);

		for (i = 0; i < len - 1; i++)
			mesh_set_reg(sc, MESH_FIFO, sc->sc_omsg[i]);

		/* Wait for the FIFO empty... */
		while (mesh_read_reg(sc, MESH_FIFO_COUNT) > 0);

		/* ...then write the last byte. */
		mesh_set_reg(sc, MESH_FIFO, sc->sc_omsg[i]);
	}
	sc->sc_nextstate = MESH_UNKNOWN;
}

void
mesh_bus_reset(struct mesh_softc *sc)
{
	DPRINTF("mesh_bus_reset\n");

	/* Disable interrupts. */
	mesh_set_reg(sc, MESH_INTR_MASK, 0);

	/* Assert RST line. */
	mesh_set_reg(sc, MESH_BUS_STATUS1, MESH_STATUS1_RST);
	delay(50);
	mesh_set_reg(sc, MESH_BUS_STATUS1, 0);

	mesh_reset(sc);
}

void
mesh_reset(struct mesh_softc *sc)
{
	int i;

	DPRINTF("mesh_reset\n");

	/* Reset DMA first. */
	dbdma_reset(sc->sc_dmareg);

	/* Disable interrupts. */
	mesh_set_reg(sc, MESH_INTR_MASK, 0);

	mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_RESET_MESH);
	delay(1);

	/* Wait for reset done. */
	while (mesh_read_reg(sc, MESH_INTERRUPT) == 0);

	/* Clear interrupts */
	mesh_set_reg(sc, MESH_INTERRUPT, 0x7);

	/* Set SCSI ID */
	mesh_set_reg(sc, MESH_SOURCE_ID, sc->sc_id);

	/* Set to async mode by default. */
	mesh_set_reg(sc, MESH_SYNC_PARAM, 2);

	/* Set selection timeout to 250ms. */
	mesh_set_reg(sc, MESH_SEL_TIMEOUT, 250 * sc->sc_freq / 500);

	/* Enable parity check. */
	mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_ENABLE_PARITY);

	/* Enable all interrupts. */
	mesh_set_reg(sc, MESH_INTR_MASK, 0x7);

	for (i = 0; i < 7; i++) {
		struct mesh_tinfo *ti = &sc->sc_tinfo[i];

		ti->flags = 0;
		ti->period = ti->offset = 0;
		if (sc->sc_cfflags & (0x100 << i))
			ti->flags |= T_SYNCNEGO;
	}
	sc->sc_nexus = NULL;
}

int
mesh_stp(struct mesh_softc *sc, int v)
{
	/*
	 * stp(v) = 5 * clock_period	 (v == 0)
	 *	= (v + 2) * 2 clock_period (v > 0)
	 */

	if (v == 0)
		return 5 * 250 / sc->sc_freq;
	else
		return (v + 2) * 2 * 250 / sc->sc_freq;
}

void
mesh_setsync(struct mesh_softc *sc, struct mesh_tinfo *ti)
{
	int period = ti->period;
	int offset = ti->offset;
	int v;

	if ((ti->flags & T_SYNCMODE) == 0)
		offset = 0;

	if (offset == 0) {	/* async mode */
		mesh_set_reg(sc, MESH_SYNC_PARAM, 2);
		return;
	}

	v = period * sc->sc_freq / 250 / 2 - 2;
	if (v < 0)
		v = 0;
	if (mesh_stp(sc, v) < period)
		v++;
	if (v > 15)
		v = 15;
	mesh_set_reg(sc, MESH_SYNC_PARAM, (offset << 4) | v);
}

void *
mesh_scb_alloc(void *xsc)
{
	struct mesh_softc *sc = xsc;
	struct mesh_scb *scb;

	mtx_enter(&sc->sc_scb_mtx);
	scb = TAILQ_FIRST(&sc->free_scb);
	if (scb)
		TAILQ_REMOVE(&sc->free_scb, scb, chain);
	mtx_leave(&sc->sc_scb_mtx);

	return scb;
}

void
mesh_scb_free(void *xsc, void *xscb)
{
	struct mesh_softc *sc = xsc;
	struct mesh_scb *scb = xscb;

	mtx_enter(&sc->sc_scb_mtx);
	TAILQ_INSERT_TAIL(&sc->free_scb, scb, chain);
	mtx_leave(&sc->sc_scb_mtx);
}

void
mesh_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *sc_link = xs->sc_link;
	struct mesh_softc *sc = sc_link->adapter_softc;
	struct mesh_scb *scb;
	u_int flags;
	int s;

	flags = xs->flags;
	scb = xs->io;

	DPRINTF("cmdlen: %d\n", xs->cmdlen);
	scb->xs = xs;
	scb->flags = 0;
	scb->status = 0;
	scb->daddr = xs->data;
	scb->dlen = xs->datalen;
	scb->resid = xs->datalen;
	bcopy(xs->cmd, &scb->cmd, xs->cmdlen);
	scb->cmdlen = xs->cmdlen;
	scb->target = sc_link->target;
	sc->sc_imsglen = 0;	/* XXX ? */

	if (flags & SCSI_POLL)
		scb->flags |= MESH_POLL;

	if (flags & SCSI_DATA_IN)
		scb->flags |= MESH_READ;

	s = splbio();
	TAILQ_INSERT_TAIL(&sc->ready_scb, scb, chain);
	if (sc->sc_nexus == NULL)
		mesh_sched(sc);
	splx(s);

	if (xs->flags & SCSI_POLL) {
		if (mesh_poll(xs)) {
			printf("%s: poll timeout\n",
			    sc->sc_dev.dv_xname);

		}
	}
}

void
mesh_sched(struct mesh_softc *sc)
{
	struct mesh_scb *scb;

	TAILQ_FOREACH(scb, &sc->ready_scb, chain) {
		if (sc->sc_nexus == NULL) {
			TAILQ_REMOVE(&sc->ready_scb, scb, chain);
			sc->sc_nexus = scb;
			mesh_select(sc, scb);
			return;
		}
	}
}

int
mesh_poll(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct mesh_softc *sc = link->adapter_softc;

	int count = xs->timeout;
	while (count) {
		if (mesh_read_reg(sc, MESH_INTERRUPT))
			mesh_intr(sc);

		if (xs->flags & ITSDONE)
			return 0;
		DELAY(1000);
		count--;
	}

	return 1;
}

void
mesh_done(struct mesh_softc *sc, struct mesh_scb *scb)
{
	struct scsi_xfer *xs = scb->xs;

	DPRINTF("mesh_done\n");

	sc->sc_nextstate = MESH_BUSFREE;
	sc->sc_nexus = NULL;

	timeout_del(&sc->sc_tmo);

	if (scb->status == SCSI_BUSY) {
		xs->error = XS_BUSY;
		printf("Target busy\n");
	}

	if (scb->status == SCSI_CHECK)
		xs->error = XS_BUSY;

	xs->status = scb->status;
	xs->resid = scb->resid;

	mesh_set_reg(sc, MESH_SYNC_PARAM, 2);

	if ((xs->flags & SCSI_POLL) == 0)
		mesh_sched(sc);

	scsi_done(xs);
}

void
mesh_timeout(void *arg)
{

	struct mesh_softc *sc = arg;
	struct mesh_scb *scb = sc->sc_nexus;
	int s;
	int status0, status1;
	int intr, error, exception, imsk;

	printf("%s: timeout state %d\n", sc->sc_dev.dv_xname, sc->sc_nextstate);

	intr = mesh_read_reg(sc, MESH_INTERRUPT);
	imsk = mesh_read_reg(sc, MESH_INTR_MASK);
	exception = mesh_read_reg(sc, MESH_EXCEPTION);
	error = mesh_read_reg(sc, MESH_ERROR);
	status0 = mesh_read_reg(sc, MESH_BUS_STATUS0);
	status1 = mesh_read_reg(sc, MESH_BUS_STATUS1);

	s = splbio();
	if (sc->sc_flags & MESH_DMA_ACTIVE) {
		dbdma_reset(sc->sc_dmareg);
	}
	scb->xs->error = XS_TIMEOUT;

	mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_BUSFREE);
	sc->sc_nextstate = MESH_COMPLETE;

	splx(s);
}

void
mesh_minphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > 64*1024)
		bp->b_bcount = 64*1024;

	minphys(bp);
}
@


1.32
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.31 2013/05/31 14:30:51 mpi Exp $	*/
d1053 1
a1053 1
	struct scsi_link *sc_link = xs->sc_link;;
@


1.31
log
@Unbreak after recent shutdown-hook removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.30 2013/05/30 16:15:01 deraadt Exp $	*/
d384 1
a384 3
	int ret = 0;

	ret = config_activate_children(self, act);
d388 1
d393 3
d397 1
a397 2

	return (ret);
@


1.30
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.29 2011/04/03 12:42:36 krw Exp $	*/
d386 1
a386 1
	reg = config_activate_children(self, act);
@


1.29
log
@Iopoolification of some less common scsi drivers.

ok dlg@@ ("miod will not object" dlg@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.28 2010/07/01 03:20:38 matthew Exp $	*/
d223 2
a224 1
void mesh_shutdownhook(void *);
d250 2
a251 1
	sizeof(struct mesh_softc), mesh_match, mesh_attach
a370 3
	/* Reset SCSI bus when halt. */
	shutdownhook_establish(mesh_shutdownhook, sc);

d380 19
a416 10
}

void
mesh_shutdownhook(void *arg)
{
	struct mesh_softc *sc = arg;

	/* Set to async mode. */
	mesh_set_reg(sc, MESH_SYNC_PARAM, 2);
	mesh_bus_reset(sc);
@


1.28
log
@Change scsibus(4)'s scsi_link array to an SLIST to save memory on
sparsely populated buses.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.27 2010/06/28 18:31:01 krw Exp $	*/
d208 3
d239 2
a240 1
void mesh_free_scb(struct mesh_softc *, struct mesh_scb *);
d336 2
d359 1
d1015 2
a1016 2
struct mesh_scb *
mesh_get_scb(struct mesh_softc *sc)
d1018 1
d1021 1
d1025 1
d1031 1
a1031 1
mesh_free_scb(struct mesh_softc *sc, struct mesh_scb *scb)
d1033 4
d1038 1
d1051 2
a1052 9
	s = splbio();
	scb = mesh_get_scb(sc);
	if (scb == NULL) {
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		splx(s);
		return;
	}
	splx(s);
a1149 1
	mesh_free_scb(sc, scb);
@


1.27
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.26 2010/04/09 17:01:30 jasper Exp $	*/
a177 2

	struct scsibus_softc *sc_scsibus;
@


1.26
log
@- don't use memset() where we should use bzero()
* no binary change

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.25 2010/03/23 01:57:19 krw Exp $	*/
a257 4
struct scsi_device mesh_dev = {
	NULL, NULL, NULL, NULL
};

a352 1
	sc->sc_link.device = &mesh_dev;
@


1.25
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.24 2010/01/13 06:09:44 krw Exp $	*/
d286 1
a286 1
	memset(compat, 0, sizeof(compat));
@


1.24
log
@Remove a few more settings of ITSDONE in drivers. Only a couple
more to go. Should be a no-op.
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.23 2009/11/01 23:06:03 fgsch Exp $	*/
d239 1
a239 1
int mesh_scsi_cmd(struct scsi_xfer *);
d1033 1
a1033 1
int
d1045 6
a1051 2
	if (scb == NULL)
		return (NO_CCB);
a1081 1
		return COMPLETE;
a1082 2

	return SUCCESSFULLY_QUEUED;
@


1.23
log
@Move IS[12]BYTEMSG and ISEXTMSG defines to a common place.
Pointed out by miod@@. krw@@ miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.22 2009/02/16 21:19:06 miod Exp $	*/
a1140 1
	xs->flags |= ITSDONE;
@


1.22
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.21 2008/11/25 17:52:02 krw Exp $	*/
a745 4

#define IS1BYTEMSG(m) (((m) != 1 && (m) < 0x20) || (m) & 0x80)
#define IS2BYTEMSG(m) (((m) & 0xf0) == 0x20)
#define ISEXTMSG(m) ((m) == 1)
@


1.21
log
@Another bunch of TRY_AGAIN_LATER -> NO_CCB when no I/O could be started.

"looks sane to me" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.20 2008/10/15 19:12:19 blambert Exp $	*/
d244 1
a244 1
void mesh_minphys(struct buf *);
d1188 1
a1188 1
mesh_minphys(struct buf *bp)
@


1.20
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.19 2008/07/30 18:08:03 miod Exp $	*/
d1051 1
a1051 1
		return (TRY_AGAIN_LATER);
@


1.19
log
@Do not print adapter target id on the attachment line, now that scsibus(4)
prints it. These should be the last offenders.
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.18 2007/04/22 22:31:14 deraadt Exp $	*/
d620 1
a620 1
	timeout_add(&sc->sc_tmo, 10*hz);
@


1.18
log
@better interrupt names for vmstat -iz; ok miod gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.17 2007/04/02 21:46:30 kettenis Exp $	*/
d353 1
a353 2
	printf(" irq %d: %dMHz, SCSI ID %d\n",
	    sc->sc_irq, sc->sc_freq, sc->sc_id);
@


1.17
log
@unmapiodev() takes the va as its first argument, not the pa.

ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.16 2007/03/20 08:55:20 gwk Exp $	*/
d368 1
a368 1
	    sc, "mesh");
@


1.16
log
@Spring cleaning: some whitespace, clean up the failure path in the attach
routine, and check the return of the mapiodev, and dbdma_create functions.
Tested on Power Macintosh 9500MP and a 9600MP.

"the diff looks fine to me." dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.15 2006/12/14 00:58:45 gwk Exp $	*/
d377 1
a377 1
	unmapiodev((void *)reg[2], reg[3]);
d379 1
a379 1
	unmapiodev((void *)reg[0], reg[1]);
@


1.15
log
@Per the new policy with respect to short header files contaning only
register offsets, loose the file meshreg.h.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.14 2006/12/08 01:19:44 thib Exp $	*/
d180 1
a180 1
	
d208 1
a208 1
	
d306 5
a310 1
	sc->sc_reg = mapiodev(reg[0], reg[1]);
d312 4
a315 1
	sc->sc_dmareg = mapiodev(reg[2], reg[3]);
d321 1
a321 1
		return;
d328 4
a331 4
		printf(": cannot create dma map, error = %d\n", error);
		return;
	}	
	
d340 8
a347 3
	
	sc->sc_dbdma = dbdma_alloc(sc->sc_dmat, MESH_DMALIST_MAX);
	sc->sc_dmacmd = sc->sc_dbdma->d_addr;	
d372 8
d697 1
a697 1
	return(0);	
d704 1
a704 1
	
d721 1
a721 1
	
d1046 1
a1046 1
	
d1064 1
a1064 1
	
d1076 1
a1076 1
			
d1081 1
a1081 1
			
d1160 1
a1160 1
	
@


1.14
log
@scsibus_attach_args not scsi_attach_args for saa in
mesh_attach().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.13 2006/11/28 23:59:45 dlg Exp $	*/
a56 1
#include <macppc/dev/meshreg.h>
d64 78
d152 4
a155 4
#define MESH_POLL	0x01
#define MESH_CHECK	0x02
#define MESH_SENSE	0x04
#define MESH_READ	0x80
@


1.13
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.12 2006/11/26 22:31:12 gwk Exp $	*/
d222 1
a222 1
	struct scsi_attach_args saa;
@


1.12
log
@Cleanup some KNF nits, if we can't grab a SCB dont return at splbio.
ok sometime ago dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.11 2006/09/26 00:00:38 gwk Exp $	*/
d222 1
d273 4
a276 1
	config_found(&sc->sc_dev, &sc->sc_link, scsiprint);
@


1.11
log
@Make mesh compile again, it also works now too, from NetBSD with a lot
of tweeks. Leave it commented out in GENERIC and files.macppc for now.
ok kettenis@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.10 2006/06/19 22:42:33 miod Exp $	*/
a112 1
	int sc_meshid;			/* MESH version */
a232 1
	sc->sc_meshid = mesh_read_reg(sc, MESH_MESH_ID) & 0x1f;
d264 1
a264 1
		sc->sc_irq, sc->sc_freq, sc->sc_id);
d275 1
a275 1
	     sc, "mesh");
d374 1
a374 1
						- fifocnt;
d376 1
a376 1
						fifocnt, scb->resid);
d379 1
a379 1
								MESH_FIFO);
d384 1
a384 1
							MESH_CMD_FLUSH_FIFO);
d395 1
a395 1
			sc->sc_dev.dv_xname, error, exception);
d410 1
a410 1
				sc->sc_dev.dv_xname, sc->sc_nextstate);
d414 1
a414 1
				sc->sc_nextstate, scb->resid);
d431 4
a434 2
		if (mesh_dataio(sc, scb))
			return(1);
d589 2
a590 2
			sc->sc_dmamap->dm_segs[i].ds_addr,
			DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d594 1
a594 1
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d616 1
d717 1
a717 1
			sc->sc_imsg[0]);
d754 1
a754 1
			sc->sc_dev.dv_xname, scb->target, sc->sc_imsg[0]);
a922 1
	int s;
a923 1
	s = splbio();
a926 1
	splx(s);
a933 3
	int s;

	s = splbio();
a934 1
	splx(s);
d948 3
a950 1
	if ((scb = mesh_get_scb(sc)) == NULL)
a951 1
	splx(s);
a974 1

d976 5
a980 6
	if ((xs->flags & SCSI_POLL) == 0)
		return SUCCESSFULLY_QUEUED;
	
	if (mesh_poll(xs)) {
	       	if (mesh_poll(xs)) {
			printf("timeout\n");
d982 1
d985 1
a985 2
	return COMPLETE;

@


1.10
log
@Be more strict in the probe routines and actually check ca_nintr and
ca_nreg are large enough for our greedy needs; tweaks and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.9 2004/12/25 23:02:24 miod Exp $	*/
d5 2
a6 1
 * Copyright (C) 1999	Internet Research Institute, Inc.
a49 5
/*
#include "scsipi/scsi_all.h"
#include "scsipi/scsipi_all.h"
#include "scsipi/scsiconf.h"
#include "scsipi/scsi_message.h"*/
a52 1
#include <machine/bus.h>
d56 8
a63 2
#include "dbdma.h"
#include "meshreg.h"
d88 1
a88 1
	vaddr_t daddr;
d96 1
a96 1
#define	MESH_DMALIST_MAX	32
a100 1
	struct scsi_adapter sc_adapter;
d102 2
d105 1
d107 2
a108 2
	dbdma_regmap_t *sc_dmareg;	/* DMA register address */
	dbdma_command_t *sc_dmacmd;	/* DMA command area */
a125 1
	int sc_omsglen;
d132 1
a132 1

d141 2
d144 1
a144 9
#ifdef __OpenBSD__
#define scsi_print_addr   sc_print_addr
#define scsipi_done 	  scsi_done
#endif

static __inline int mesh_read_reg(struct mesh_softc *, int);
static __inline void mesh_set_reg(struct mesh_softc *, int, int);

int mesh_match(struct device *, struct cfdata *, void *);
d165 1
a165 1
int mesh_poll(struct mesh_softc *, struct scsi_xfer *);
a167 1
void mesh_sense(struct mesh_softc *, struct mesh_scb *);
d170 15
a200 17
struct cfattach mesh_ca = {
	sizeof(struct mesh_softc),(cfmatch_t)mesh_match,
	 mesh_attach
};


struct cfdriver mesh_cd = {
        NULL, "mesh", DV_DULL
};

struct scsi_device mesh_dev = {
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
};

d202 1
a202 4
mesh_match(parent, cf, aux)
	struct device *parent;
	struct cfdata *cf;
	void *aux;
d205 4
a208 1
	printf("MESH_MATCH called ,ca->ca_name= %s\n",ca->ca_name);
d210 4
a213 3
	if (strcmp(ca->ca_name, "mesh") != 0 ||
	    ca->ca_nintr < 4 || ca->ca_nreg < 16)
		return 0;
d215 1
a215 1
	return 1;
d219 1
a219 3
mesh_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
a225 2
	printf("MESH_ATTACH called\n");

d233 1
a233 1
	sc->sc_cfflags = self->dv_cfdata->cf_flags;
d235 1
a235 6
#if 0
	if (sc->sc_meshid != (MESH_SIGNATURE & 0x1f) {
		printf(": unknown MESH ID (0x%x)\n", sc->sc_meshid);
		return;
	}
#endif
d247 2
a248 2
	}

d257 1
a257 1

d259 2
a260 2
	sc->sc_dmacmd = sc->sc_dbdma->d_addr;
	timeout_set(&sc->sc_tmo, mesh_timeout, scb);
a267 4
	sc->sc_adapter.scsi_cmd = mesh_scsi_cmd;
	sc->sc_adapter.scsi_minphys = mesh_minphys;

/*	sc->sc_link.scsi_scsi.channel = SCSI_CHANNEL_ONLY_ONE;*/
a269 1
	sc->sc_link.adapter = &sc->sc_adapter;
d271 1
d273 1
a273 4
/*	sc->sc_link.scsi_scsi.max_target = 7;
	sc->sc_link.scsi_scsi.max_lun = 7;
	sc->sc_link.type = BUS_SCSI;
*/
d276 2
a277 1
	printf("in mesh_attach, after config_found,calling mac_intr_establish,sc->sc_irq = %d\n",sc->sc_irq);
a278 2
	/*intr_establish(sc->sc_irq, IST_LEVEL, IPL_BIO, mesh_intr, sc);*/
	mac_intr_establish(parent,sc->sc_irq,IST_LEVEL, IPL_BIO, mesh_intr, sc,"mesh intr");
d292 1
a292 3
mesh_read_reg(sc, reg)
	struct mesh_softc *sc;
	int reg;
d298 1
a298 3
mesh_set_reg(sc, reg, val)
	struct mesh_softc *sc;
	int reg, val;
d304 1
a304 2
mesh_shutdownhook(arg)
	void *arg;
d310 1
d313 13
d327 1
a327 2
mesh_intr(arg)
	void *arg;
d331 1
a332 1
	int i;
a335 1
#ifdef MESH_DEBUG
d337 1
a337 1
		printf("mesh: stray interrupt\n");
a339 2
#endif

d348 8
d358 1
a358 3
#ifdef MESH_DEBUG
		printf("mesh: NULL nexus\n");
#endif
d362 31
a392 9
	if (sc->sc_flags & MESH_DMA_ACTIVE) {
		dbdma_stop(sc->sc_dmareg);
		bus_dmamap_unload(sc->sc_dmat, sc->sc_dmamap);

		sc->sc_flags &= ~MESH_DMA_ACTIVE;
		scb->resid = MESH_GET_XFER(sc);

		if (mesh_read_reg(sc, MESH_FIFO_COUNT) != 0)
			panic("mesh: FIFO != 0");	/* XXX */
d396 2
d411 2
d414 3
a416 8
#if 0
			printf("mesh: PHASE MISMATCH cdb =");
			printf(" %02x", scb->cmd.opcode);
			for (i = 0; i < 5; i++) {
				printf(" %02x", scb->cmd.bytes[i]);
			}
			printf("\n");
#endif
a429 1
		printf("mesh_intr:case MESH_COMMAND\n");
d434 1
a434 2
			return (1);
		printf("mesh_intr:case MESH_DATAIN or MESH_DATAOUT\n");
a437 1
		printf("mesh_intr:case MESH_STATUS\n");
a440 1
		printf("mesh_intr:case MESH_MSGIN\n");
a442 1
		printf("mesh_intr:case MESH_COMPLETE\n");
d447 4
a450 1
		panic("mesh: unknown state (0x%x)", sc->sc_nextstate);
d457 2
a458 4
mesh_error(sc, scb, error, exception)
	struct mesh_softc *sc;
	struct mesh_scb *scb;
	int error, exception;
d461 1
a461 1
		printf("mesh: SCSI RESET\n");
d465 1
a465 1
		mesh_reset(sc);
d470 1
a470 1
		printf("mesh: parity error\n");
d475 1
a475 1
		printf("mesh: unexpected disconnect\n");
d482 1
a482 1
		scb->xs->error = XS_DRIVER_STUFFUP;
d489 1
a489 3
mesh_select(sc, scb)
	struct mesh_softc *sc;
	struct mesh_scb *scb;
d493 2
d524 1
a524 3
mesh_identify(sc, scb)
	struct mesh_softc *sc;
	struct mesh_scb *scb;
d526 3
a529 1
	mesh_msgout(sc, SEND_IDENTIFY);
d531 9
a539 2
	sc->sc_nextstate = MESH_COMMAND;
	printf("mesh_identify called\n");
d543 1
a543 3
mesh_command(sc, scb)
	struct mesh_softc *sc;
	struct mesh_scb *scb;
a544 1
	struct mesh_tinfo *ti = &sc->sc_tinfo[scb->target];
d548 6
a553 8
	if ((ti->flags & T_SYNCNEGO) == 0) {
		ti->period = sc->sc_minsync;
		ti->offset = 15;
		mesh_msgout(sc, SEND_SDTR);
		sc->sc_prevphase = MESH_COMMAND;
		sc->sc_nextstate = MESH_MSGIN;
		return;
	}
d571 1
a571 3
mesh_dma_setup(sc, scb)
	struct mesh_softc *sc;
	struct mesh_scb *scb;
a572 1
	struct scsi_xfer *xs = scb->xs;
d574 1
a574 1
	dbdma_command_t *cmdp;
d578 1
a578 1
	if ((error = bus_dmamap_load(sc->dmat, sc->sc_dmamap, scb->daddr,
d587 1
a587 1
			cmd = read ? DBDMA_CMD_IN_LAST : DBDMA_CMD_OUT_LAST;
d596 1
a596 1
	return (0);
d600 1
a600 3
mesh_dataio(sc, scb)
	struct mesh_softc *sc;
	struct mesh_scb *scb;
d603 1
a603 1

d605 1
a605 1
		return (error);
d612 4
a615 3
	mesh_set_reg(sc, MESH_SEQUENCE, MESH_SEQ_DMA |
	    (scb->flags & MESH_READ)? MESH_CMD_DATAIN : MESH_CMD_DATAOUT);

d619 2
a620 2

	return (0);
d624 1
a624 3
mesh_status(sc, scb)
	struct mesh_softc *sc;
	struct mesh_scb *scb;
d627 1
d635 3
d651 1
a651 3
mesh_msgin(sc, scb)
	struct mesh_softc *sc;
	struct mesh_scb *scb;
d653 1
a653 1
	int i;
d679 8
a686 5
#ifdef DEBUG
	printf("msgin:");
	for (i = 0; i < sc->sc_imsglen; i++)
		printf(" 0x%02x", sc->sc_imsg[i]);
	printf("\n");
d697 1
a697 2
		switch (sc->sc_msgout) {
		case SEND_SDTR:
d714 1
a714 1
		scsi_print_addr(scb->xs->sc_link);
d741 1
a741 1
		scsi_print_addr(scb->xs->sc_link);
d765 1
a765 3
mesh_msgout(sc, msg)
	struct mesh_softc *sc;
	int msg;
d769 6
a774 1
	int lun, i;
d776 6
a781 6
	switch (msg) {
	case SEND_REJECT:
		sc->sc_omsglen = 1;
		sc->sc_omsg[0] = MSG_MESSAGE_REJECT;
		break;
	case SEND_IDENTIFY:
d783 4
a786 4
		sc->sc_omsglen = 1;
		sc->sc_omsg[0] = MSG_IDENTIFY(lun, 0);
		break;
	case SEND_SDTR:
d788 17
a804 9
		sc->sc_omsglen = 5;
		sc->sc_omsg[0] = MSG_EXTENDED;
		sc->sc_omsg[1] = 3;
		sc->sc_omsg[2] = MSG_EXT_SDTR;
		sc->sc_omsg[3] = ti->period;
		sc->sc_omsg[4] = ti->offset;
		break;
	}
	sc->sc_msgout = msg;
d806 2
a807 2
	MESH_SET_XFER(sc, sc->sc_omsglen);
	mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_MSGOUT | MESH_SEQ_ATN);
d809 1
a809 1
	for (i = 0; i < sc->sc_omsglen; i++)
d811 1
a811 1

d816 1
a816 2
mesh_bus_reset(sc)
	struct mesh_softc *sc;
d818 2
d832 1
a832 2
mesh_reset(sc)
	struct mesh_softc *sc;
d836 2
d873 1
a873 1
		if (sc->sc_cfflags & (1 << i)) {
a874 1
		}
d880 1
a880 3
mesh_stp(sc, v)
	struct mesh_softc *sc;
	int v;
d883 2
a884 2
	 * stp(v) = 5 * clock_period         (v == 0)
	 *        = (v + 2) * 2 clock_period (v > 0)
d894 1
a894 3
mesh_setsync(sc, ti)
	struct mesh_softc *sc;
	struct mesh_tinfo *ti;
d919 1
a919 2
mesh_get_scb(sc)
	struct mesh_softc *sc;
d925 3
a927 3
	while ((scb = TAILQ_FIRST(&sc->free_scb)) == NULL)
		tsleep(&sc->free_scb, PRIBIO, "meshscb", 0);
	TAILQ_REMOVE(&sc->free_scb, scb, chain);
d934 1
a934 3
mesh_free_scb(sc, scb)
	struct mesh_softc *sc;
	struct mesh_scb *scb;
d939 1
a939 3
	TAILQ_INSERT_HEAD(&sc->free_scb, scb, chain);
	if (TAILQ_NEXT(&scb->chain) == NULL)
		wakeup(&sc->free_scb);
d944 1
a944 2
mesh_scsi_cmd(xs)
	struct scsi_xfer *xs;
d946 1
a946 1
	struct scsi_link *sc_link = xs->sc_link;
d951 1
a951 1

d953 5
a957 2

	scb = mesh_get_scb(sc);
d961 1
a961 1
	scb->daddr = (vaddr_t)xs->data;
a965 1

d968 2
a969 5

	printf("messh_scsi_cmd,scb->target=%d\n",scb->target);

	if (flags & SCSI_POLL){
		printf("mesh_scsi_cmd:flags=SCSI_POLL\n");
a970 1
	}
d972 1
a972 6
#if 0
	if (flags & SCSI_DATA_OUT)
		scb->flags &= ~MESH_READ;
#endif
	if (flags & SCSI_DATA_IN){
		printf("mesh_scsi_cmd:flags=SCSI_DATA_IN\n");
a973 1
	}
a975 1

d977 1
a977 3

	if (sc->sc_nexus == NULL){
		printf("mesh_scsi_cmd:sc->sc_nexus == NULL,calling mesh_sched\n");	/* IDLE */
a978 2
	}

d981 2
a982 2
	if ((flags & SCSI_POLL) == 0){
		printf("mesh_scsi_cmd: returning SUCCESSFULLY_QUEUED\n");
d984 5
a990 6
	if (mesh_poll(sc, xs)) {
		printf("mesh: timeout\n");
		if (mesh_poll(sc, xs))
			printf("mesh: timeout again\n");
	}
	printf("mesh_scsi_cmd: returning COMPLETE\n");
d992 1
d996 1
a996 2
mesh_sched(sc)
	struct mesh_softc *sc;
a997 2
	struct scsi_xfer *xs;
	struct scsi_link *sc_link;
a1000 3
		xs = scb->xs;
		sc_link = xs->sc_link;

d1011 1
a1011 3
mesh_poll(sc, xs)
	struct mesh_softc *sc;
	struct scsi_xfer *xs;
d1013 3
a1016 3
	printf("in mesh_poll,timeout=%d\n",xs->timeout);


d1025 2
a1026 1
	};
d1031 1
a1031 3
mesh_done(sc, scb)
	struct mesh_softc *sc;
	struct mesh_scb *scb;
d1035 1
a1035 3
#ifdef MESH_SHOWSTATE
	printf("mesh_done\n");
#endif
d1047 2
a1048 15
	if (scb->status == SCSI_CHECK) {
		if (scb->flags & MESH_SENSE)
			panic("SCSI_CHECK && MESH_SENSE?");
		xs->resid = scb->resid;
		mesh_sense(sc, scb);
		return;
	}

	if (xs->error == XS_NOERROR) {
		xs->status = scb->status;
		if (scb->flags & MESH_SENSE)
			xs->error = XS_SENSE;
		else
			xs->resid = scb->resid;
	}
d1050 2
d1064 1
a1064 2
mesh_timeout(arg)
	void *arg;
d1066 3
a1068 2
	struct mesh_scb *scb = arg;
	struct mesh_softc *sc = scb->xs->sc_link->adapter_softc;
d1071 3
a1073 1
	int intr, error, exception;
a1074 1
	printf("mesh: timeout state=%x\n", sc->sc_nextstate);
d1076 1
a1076 1

a1077 1

a1078 1

a1079 1

a1081 4
#if 1
printf("intr 0x%02x, except 0x%02x, err 0x%02x\n", intr, exception, error);
#endif

a1082 1

a1083 1
		printf("mesh: resetting dma\n");
a1088 1

a1091 27
	printf("returning from mesh_timeout\n");
}

void
mesh_sense(sc, scb)
	struct mesh_softc *sc;
	struct mesh_scb *scb;
{
	struct scsi_xfer *xs = scb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	struct scsi_sense *ss = (void *)&scb->cmd;

	bzero(ss, sizeof(*ss));
	ss->opcode = REQUEST_SENSE;
	ss->byte2 = sc_link->lun << 5;
	ss->length = sizeof(struct scsi_sense_data);
	scb->cmdlen = sizeof(*ss);
	scb->daddr = (vaddr_t)&xs->sense;
	scb->dlen = sizeof(struct scsi_sense_data);
	scb->resid = scb->dlen;
	bzero((void *)scb->daddr, scb->dlen);

	scb->flags |= MESH_SENSE | MESH_READ;

	TAILQ_INSERT_HEAD(&sc->ready_scb, scb, chain);
	if (sc->sc_nexus == NULL)
		mesh_sched(sc);
d1095 1
a1095 2
mesh_minphys(bp)
	struct buf *bp;
@


1.9
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.8 2004/01/09 22:57:09 jmc Exp $	*/
d217 2
a218 1
	if (strcmp(ca->ca_name, "mesh") != 0)
@


1.8
log
@typo from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.7 2003/10/16 03:54:48 deraadt Exp $	*/
d912 1
a912 1
	while ((scb = sc->free_scb.tqh_first) == NULL)
d929 1
a929 1
	if (scb->chain.tqe_next == NULL)
d1008 10
a1017 13
	scb = sc->ready_scb.tqh_first;
start:
	if (scb == NULL)
		return;

	xs = scb->xs;
	sc_link = xs->sc_link;

	if (sc->sc_nexus == NULL) {
		TAILQ_REMOVE(&sc->ready_scb, scb, chain);
		sc->sc_nexus = scb;
		mesh_select(sc, scb);
		return;
a1018 3

	scb = scb->chain.tqe_next;
	goto start;
@


1.7
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.6 2002/09/15 09:01:58 deraadt Exp $	*/
d1134 1
a1134 1
	printf("rerturning from mesh_timeout\n");
@


1.6
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.4 2002/03/14 01:26:36 millert Exp $	*/
d197 1
a197 1
struct cfdriver mesh_cd = {         
d232 1
a232 1
	
d434 1
a434 1
		printf("mesh_intr:case MESH_MSGIN\n");   
d437 1
a437 1
		printf("mesh_intr:case MESH_COMPLETE\n"); 
d958 1
a958 1
	
d996 1
a996 1
	printf("mesh_scsi_cmd: returning COMPLETE\n"); 
d1034 1
a1034 1
	
a1107 1
	
d1110 1
a1110 1
	
d1112 1
a1112 1
	
d1122 1
a1122 1
		
d1130 1
a1130 1
	
@


1.5
log
@KNF
@
text
@d197 1
a197 1
struct cfdriver mesh_cd = {
d232 1
a232 1

d434 1
a434 1
		printf("mesh_intr:case MESH_MSGIN\n");
d437 1
a437 1
		printf("mesh_intr:case MESH_COMPLETE\n");
d958 1
a958 1

d996 1
a996 1
	printf("mesh_scsi_cmd: returning COMPLETE\n");
d1034 1
a1034 1

d1108 1
a1108 1

d1111 1
a1111 1

d1113 1
a1113 1

d1123 1
a1123 1

d1131 1
a1131 1

@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.3 2001/11/06 19:53:15 miod Exp $	*/
d197 1
a197 1
struct cfdriver mesh_cd = {         
d232 1
a232 1
	
d434 1
a434 1
		printf("mesh_intr:case MESH_MSGIN\n");   
d437 1
a437 1
		printf("mesh_intr:case MESH_COMPLETE\n"); 
d958 1
a958 1
	
d996 1
a996 1
	printf("mesh_scsi_cmd: returning COMPLETE\n"); 
d1034 1
a1034 1
	
d1108 1
a1108 1
	
d1111 1
a1111 1
	
d1113 1
a1113 1
	
d1123 1
a1123 1
		
d1131 1
a1131 1
	
@


1.3
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.2 2001/09/15 01:51:11 mickey Exp $	*/
d145 2
a146 2
static __inline int mesh_read_reg __P((struct mesh_softc *, int));
static __inline void mesh_set_reg __P((struct mesh_softc *, int, int));
d148 26
a173 26
int mesh_match __P((struct device *, struct cfdata *, void *));
void mesh_attach __P((struct device *, struct device *, void *));
void mesh_shutdownhook __P((void *));
int mesh_intr __P((void *));
void mesh_error __P((struct mesh_softc *, struct mesh_scb *, int, int));
void mesh_select __P((struct mesh_softc *, struct mesh_scb *));
void mesh_identify __P((struct mesh_softc *, struct mesh_scb *));
void mesh_command __P((struct mesh_softc *, struct mesh_scb *));
int mesh_dma_setup __P((struct mesh_softc *, struct mesh_scb *));
int mesh_dataio __P((struct mesh_softc *, struct mesh_scb *));
void mesh_status __P((struct mesh_softc *, struct mesh_scb *));
void mesh_msgin __P((struct mesh_softc *, struct mesh_scb *));
void mesh_msgout __P((struct mesh_softc *, int));
void mesh_bus_reset __P((struct mesh_softc *));
void mesh_reset __P((struct mesh_softc *));
int mesh_stp __P((struct mesh_softc *, int));
void mesh_setsync __P((struct mesh_softc *, struct mesh_tinfo *));
struct mesh_scb *mesh_get_scb __P((struct mesh_softc *));
void mesh_free_scb __P((struct mesh_softc *, struct mesh_scb *));
int mesh_scsi_cmd __P((struct scsi_xfer *));
void mesh_sched __P((struct mesh_softc *));
int mesh_poll __P((struct mesh_softc *, struct scsi_xfer *));
void mesh_done __P((struct mesh_softc *, struct mesh_scb *));
void mesh_timeout __P((void *));
void mesh_sense __P((struct mesh_softc *, struct mesh_scb *));
void mesh_minphys __P((struct buf *));
@


1.3.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.3 2001/11/06 19:53:15 miod Exp $	*/
d145 2
a146 2
static __inline int mesh_read_reg(struct mesh_softc *, int);
static __inline void mesh_set_reg(struct mesh_softc *, int, int);
d148 26
a173 26
int mesh_match(struct device *, struct cfdata *, void *);
void mesh_attach(struct device *, struct device *, void *);
void mesh_shutdownhook(void *);
int mesh_intr(void *);
void mesh_error(struct mesh_softc *, struct mesh_scb *, int, int);
void mesh_select(struct mesh_softc *, struct mesh_scb *);
void mesh_identify(struct mesh_softc *, struct mesh_scb *);
void mesh_command(struct mesh_softc *, struct mesh_scb *);
int mesh_dma_setup(struct mesh_softc *, struct mesh_scb *);
int mesh_dataio(struct mesh_softc *, struct mesh_scb *);
void mesh_status(struct mesh_softc *, struct mesh_scb *);
void mesh_msgin(struct mesh_softc *, struct mesh_scb *);
void mesh_msgout(struct mesh_softc *, int);
void mesh_bus_reset(struct mesh_softc *);
void mesh_reset(struct mesh_softc *);
int mesh_stp(struct mesh_softc *, int);
void mesh_setsync(struct mesh_softc *, struct mesh_tinfo *);
struct mesh_scb *mesh_get_scb(struct mesh_softc *);
void mesh_free_scb(struct mesh_softc *, struct mesh_scb *);
int mesh_scsi_cmd(struct scsi_xfer *);
void mesh_sched(struct mesh_softc *);
int mesh_poll(struct mesh_softc *, struct scsi_xfer *);
void mesh_done(struct mesh_softc *, struct mesh_scb *);
void mesh_timeout(void *);
void mesh_sense(struct mesh_softc *, struct mesh_scb *);
void mesh_minphys(struct buf *);
@


1.3.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.3.2.1 2002/06/11 03:36:34 art Exp $	*/
@


1.2
log
@reimplement dbdma such that it does memory allocations
w/ bus_dma(9) and rework drivers accordingly.
make drivers use bus_dma as well, except for if_bm (later ;) .
additionally, sync wdc_obio w/ netbsd.
drahn@@ ok, tested by miod@@, pval@@, brad@@, mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.1 2001/09/01 15:50:00 drahn Exp $	*/
d44 1
a44 2
#include <vm/vm.h>

@


1.2.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2.4.2
log
@Merge in -current
@
text
@d44 2
a45 1
#include <uvm/uvm_extern.h>
@


1.2.4.3
log
@Merge in -current from about a week ago
@
text
@d145 2
a146 2
static __inline int mesh_read_reg(struct mesh_softc *, int);
static __inline void mesh_set_reg(struct mesh_softc *, int, int);
d148 26
a173 26
int mesh_match(struct device *, struct cfdata *, void *);
void mesh_attach(struct device *, struct device *, void *);
void mesh_shutdownhook(void *);
int mesh_intr(void *);
void mesh_error(struct mesh_softc *, struct mesh_scb *, int, int);
void mesh_select(struct mesh_softc *, struct mesh_scb *);
void mesh_identify(struct mesh_softc *, struct mesh_scb *);
void mesh_command(struct mesh_softc *, struct mesh_scb *);
int mesh_dma_setup(struct mesh_softc *, struct mesh_scb *);
int mesh_dataio(struct mesh_softc *, struct mesh_scb *);
void mesh_status(struct mesh_softc *, struct mesh_scb *);
void mesh_msgin(struct mesh_softc *, struct mesh_scb *);
void mesh_msgout(struct mesh_softc *, int);
void mesh_bus_reset(struct mesh_softc *);
void mesh_reset(struct mesh_softc *);
int mesh_stp(struct mesh_softc *, int);
void mesh_setsync(struct mesh_softc *, struct mesh_tinfo *);
struct mesh_scb *mesh_get_scb(struct mesh_softc *);
void mesh_free_scb(struct mesh_softc *, struct mesh_scb *);
int mesh_scsi_cmd(struct scsi_xfer *);
void mesh_sched(struct mesh_softc *);
int mesh_poll(struct mesh_softc *, struct scsi_xfer *);
void mesh_done(struct mesh_softc *, struct mesh_scb *);
void mesh_timeout(void *);
void mesh_sense(struct mesh_softc *, struct mesh_scb *);
void mesh_minphys(struct buf *);
@


1.2.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d197 1
a197 1
struct cfdriver mesh_cd = {
d232 1
a232 1

d434 1
a434 1
		printf("mesh_intr:case MESH_MSGIN\n");
d437 1
a437 1
		printf("mesh_intr:case MESH_COMPLETE\n");
d958 1
a958 1

d996 1
a996 1
	printf("mesh_scsi_cmd: returning COMPLETE\n");
d1034 1
a1034 1

d1108 1
d1111 1
a1111 1

d1113 1
a1113 1

d1123 1
a1123 1

d1131 1
a1131 1

d1135 1
a1135 1
	printf("returning from mesh_timeout\n");
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/mac to macppc/dev
@
text
@d1 1
a1 1
/*	$OpenBSD: mesh.c,v 1.3 2001/08/08 21:08:33 miod Exp $	*/
a55 2


d58 1
a60 1
#include <machine/pio.h>
a67 2


d96 2
d104 1
d107 1
d157 2
a158 2
void mesh_dma_setup __P((struct mesh_softc *, struct mesh_scb *));
void mesh_dataio __P((struct mesh_softc *, struct mesh_scb *));
d231 1
a231 1
	int i;
d255 9
d273 2
a274 1
	sc->sc_dmacmd = dbdma_alloc(sizeof(dbdma_command_t) * 20);
d376 1
d425 2
a426 1
		mesh_dataio(sc, scb);
d563 1
a563 1
void
d572 5
a576 2
	vaddr_t va;
	int count, offset;
d581 5
a585 25
	count = scb->dlen;

	if (count / NBPG > 32)
		panic("mesh: transfer size >= 128k");

	va = scb->daddr;
	offset = va & PGOFSET;

	/* if va is not page-aligned, setup the first page */
	if (offset != 0) {
		int rest = NBPG - offset;	/* the rest in the page */

		if (count > rest) {		/* if continues to next page */
			DBDMA_BUILD(cmdp, cmd, 0, rest, vtophys(va),
				DBDMA_INT_NEVER, DBDMA_WAIT_NEVER,
				DBDMA_BRANCH_NEVER);
			count -= rest;
			va += rest;
			cmdp++;
		}
	}

	/* now va is page-aligned */
	while (count > NBPG) {
		DBDMA_BUILD(cmdp, cmd, 0, NBPG, vtophys(va),
a586 3
		count -= NBPG;
		va += NBPG;
		cmdp++;
d589 1
a589 3
	/* the last page (count <= NBPG here) */
	cmd = datain ? DBDMA_CMD_IN_LAST : DBDMA_CMD_OUT_LAST;
	DBDMA_BUILD(cmdp, cmd , 0, count, vtophys(va),
a590 1
	cmdp++;
d592 1
a592 2
	DBDMA_BUILD(cmdp, DBDMA_CMD_STOP, 0, 0, 0,
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d595 1
a595 1
void
d600 4
a603 1
	mesh_dma_setup(sc, scb);
d610 4
a613 5
	if (scb->flags & MESH_READ)
		mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_DATAIN | MESH_SEQ_DMA);
	else
		mesh_set_reg(sc, MESH_SEQUENCE, MESH_CMD_DATAOUT | MESH_SEQ_DMA);
	dbdma_start(sc->sc_dmareg, sc->sc_dmacmd);
d616 2
@

