head	1.28;
access;
symbols
	OPENBSD_6_1:1.28.0.2
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.27.0.2
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.25.0.10
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.12
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.4
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.8
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.6
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.18
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.16
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.12
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.14
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.10
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.8
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.6
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.4
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.13.0.8
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.6
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.9
	UBC:1.4.0.6
	UBC_BASE:1.4
	SMP:1.4.0.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.28
date	2016.12.26.17.38.14;	author jca;	state Exp;
branches;
next	1.27;
commitid	7dXGn3bjEh7gjeKW;

1.27
date	2016.03.15.18.16.07;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	NgA1LA3O0qDpZmft;

1.26
date	2016.03.14.23.08.05;	author krw;	state Exp;
branches;
next	1.25;
commitid	kCz5QgxnxRMKOzNf;

1.25
date	2013.04.23.07.38.05;	author mpi;	state Exp;
branches;
next	1.24;

1.24
date	2012.12.05.23.20.13;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2011.05.14.12.01.16;	author mpi;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.18.19.33.48;	author gwk;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.12.21.01.11;	author gwk;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.07.20.00.18;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2006.02.22.07.02.23;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.18.23.21.17;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.22.22.55.25;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.10.13.45.38;	author pedro;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.06.02.38.24;	author pedro;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.21.22.07.45;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.16.03.54.48;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.16.03.31.25;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.02.22.03.08;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.11.19.41.10;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.10.18.03.49.16;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.18.04.31.40;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.07.07.14.48;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.10.17.35.14;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.03.14.45.37;	author drahn;	state Exp;
branches
	1.4.4.1
	1.4.6.1;
next	1.3;

1.3
date	2001.09.20.17.02.30;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.01.17.43.09;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.50.00;	author drahn;	state Exp;
branches;
next	;

1.4.4.1
date	2001.10.31.03.01.15;	author nate;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2003.05.13.19.41.05;	author ho;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	;

1.4.6.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Fix typo, happend -> happened
@
text
@/*	$OpenBSD: pm_direct.c,v 1.27 2016/03/15 18:16:07 deraadt Exp $	*/
/*	$NetBSD: pm_direct.c,v 1.9 2000/06/08 22:10:46 tsubai Exp $	*/

/*
 * Copyright (C) 1997 Takashi Hamada
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by Takashi Hamada
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifdef DEBUG
#ifndef ADB_DEBUG
#define ADB_DEBUG
#endif
#endif

/* #define	PM_GRAB_SI	1 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>

#include <machine/cpu.h>

#include <dev/adb/adb.h>
#include <macppc/dev/adbvar.h>
#include <macppc/dev/pm_direct.h>
#include <macppc/dev/viareg.h>

/* hardware dependent values */
#define ADBDelay 100		/* XXX */

/* useful macros */
#define PM_SR()			read_via_reg(VIA1, vSR)
#define PM_VIA_INTR_ENABLE()	write_via_reg(VIA1, vIER, 0x90)
#define PM_VIA_INTR_DISABLE()	write_via_reg(VIA1, vIER, 0x10)
#define PM_VIA_CLR_INTR()	write_via_reg(VIA1, vIFR, 0x90)
#if 0
#define PM_SET_STATE_ACKON()	via_reg_or(VIA2, vBufB, 0x04)
#define PM_SET_STATE_ACKOFF()	via_reg_and(VIA2, vBufB, ~0x04)
#define PM_IS_ON		(0x02 == (read_via_reg(VIA2, vBufB) & 0x02))
#define PM_IS_OFF		(0x00 == (read_via_reg(VIA2, vBufB) & 0x02))
#else
#define PM_SET_STATE_ACKON()	via_reg_or(VIA2, vBufB, 0x10)
#define PM_SET_STATE_ACKOFF()	via_reg_and(VIA2, vBufB, ~0x10)
#define PM_IS_ON		(0x08 == (read_via_reg(VIA2, vBufB) & 0x08))
#define PM_IS_OFF		(0x00 == (read_via_reg(VIA2, vBufB) & 0x08))
#endif

/* these values shows that number of data returned after 'send' cmd is sent */
signed char pm_send_cmd_type[] = {
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	0x01, 0x01,   -1,   -1,   -1,   -1,   -1,   -1,
	0x00, 0x00,   -1,   -1,   -1,   -1,   -1, 0x00,
	  -1, 0x00, 0x02, 0x01, 0x01,   -1,   -1,   -1,
	0x00,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	0x04, 0x14,   -1, 0x03,   -1,   -1,   -1,   -1,
	0x00, 0x00, 0x02, 0x02,   -1,   -1,   -1,   -1,
	0x01, 0x01,   -1,   -1,   -1,   -1,   -1,   -1,
	0x00, 0x00,   -1,   -1, 0x01,   -1,   -1,   -1,
	0x01, 0x00, 0x02, 0x02,   -1, 0x01, 0x03, 0x01,
	0x00, 0x01, 0x00, 0x00, 0x00,   -1,   -1,   -1,
	0x02,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   -1,   -1,
	0x01, 0x01, 0x01,   -1,   -1,   -1,   -1,   -1,
	0x00, 0x00,   -1,   -1,   -1,   -1, 0x04, 0x04,
	0x04,   -1, 0x00,   -1,   -1,   -1,   -1,   -1,
	0x00,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	0x01, 0x02,   -1,   -1,   -1,   -1,   -1,   -1,
	0x00, 0x00,   -1,   -1,   -1,   -1,   -1,   -1,
	0x02, 0x02, 0x02, 0x04,   -1, 0x00,   -1,   -1,
	0x01, 0x01, 0x03, 0x02,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	0x00,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	0x01, 0x01,   -1,   -1, 0x00, 0x00,   -1,   -1,
	  -1, 0x04, 0x00,   -1,   -1,   -1,   -1,   -1,
	0x03,   -1, 0x00,   -1, 0x00,   -1,   -1, 0x00,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1
};

/* these values shows that number of data returned after 'receive' cmd is sent */
signed char pm_receive_cmd_type[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x02,   -1,   -1,   -1,   -1,   -1, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x05, 0x15,   -1, 0x02,   -1,   -1,   -1,   -1,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x02,   -1,   -1,   -1,   -1,   -1,   -1,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x00, 0x03, 0x03,   -1,   -1,   -1,   -1,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x04, 0x04, 0x03, 0x09,   -1,   -1,   -1,   -1,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  -1,   -1,   -1,   -1,   -1,   -1, 0x01, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x06,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x02,   -1,   -1,   -1,   -1,   -1,   -1,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00,   -1,   -1,   -1,   -1,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x02,   -1,   -1, 0x02,   -1,   -1,   -1,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	  -1,   -1, 0x02,   -1,   -1,   -1,   -1, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
};


/*
 * Define the private functions
 */

/* for debugging */
#ifdef ADB_DEBUG
void	pm_printerr(char *, int, int, char *);
#endif

int	pm_wait_busy(int);
int	pm_wait_free(int);
int	pm_receive(u_char *);
int	pm_send(u_char);

/* these functions also use the variables of adb_direct.c */
void	pm_adb_get_TALK_result(PMData *);
void	pm_adb_get_ADB_data(PMData *);


/*
 * These variables are in adb_direct.c.
 */
extern u_char	*adbBuffer;	/* pointer to user data area */
extern void	*adbCompRout;	/* pointer to the completion routine */
extern void	*adbCompData;	/* pointer to the completion routine data */
extern int	adbWaiting;	/* waiting for return data from the device */
extern int	adbWaitingCmd;	/* ADB command we are waiting for */
extern int	adbStarting;	/* doing ADB reinit, so do "polling" differently */

#define	ADB_MAX_MSG_LENGTH	16
#define	ADB_MAX_HDR_LENGTH	8
struct adbCommand {
	u_char	header[ADB_MAX_HDR_LENGTH];	/* not used yet */
	u_char	data[ADB_MAX_MSG_LENGTH];	/* packet data only */
	u_char	*saveBuf;	/* where to save result */
	u_char	*compRout;	/* completion routine pointer */
	u_char	*compData;	/* completion routine data pointer */
	u_int	cmd;		/* the original command for this data */
	u_int	unsol;		/* 1 if packet was unsolicited */
	u_int	ack_only;	/* 1 for no special processing */
};
extern	void	adb_pass_up(struct adbCommand *);


#ifdef ADB_DEBUG
/*
 * This function dumps contents of the PMData
 */
void
pm_printerr(ttl, rval, num, data)
	char *ttl;
	int rval;
	int num;
	char *data;
{
	int i;

	printf("pm: %s:%04x %02x ", ttl, rval, num);
	for (i = 0; i < num; i++)
		printf("%02x ", data[i]);
	printf("\n");
}
#endif

/*
 * Wait until PM IC is busy
 */
int
pm_wait_busy(int delay)
{
	while (PM_IS_ON) {
#ifdef PM_GRAB_SI
		(void)intr_dispatch(0x70);
#endif
		if ((--delay) < 0)
			return 1;	/* timeout */
	}
	return 0;
}


/*
 * Wait until PM IC is free
 */
int
pm_wait_free(int delay)
{
	while (PM_IS_OFF) {
#ifdef PM_GRAB_SI
		(void)intr_dispatch(0x70);
#endif
		if ((--delay) < 0)
			return 0;	/* timeout */
	}
	return 1;
}

/*
 * Functions for the PB Duo series and the PB 5XX series
 */

/*
 * Receive data from PM for the PB Duo series and the PB 5XX series
 */
int
pm_receive(u_char *data)
{
	int i;
	int rval;

	rval = 0xffffcd34;

	switch (1) {
	default:
		/* set VIA SR to input mode */
		via_reg_or(VIA1, vACR, 0x0c);
		via_reg_and(VIA1, vACR, ~0x10);
		i = PM_SR();

		PM_SET_STATE_ACKOFF();
		if (pm_wait_busy((int)ADBDelay*32) != 0)
			break;		/* timeout */

		PM_SET_STATE_ACKON();
		rval = 0xffffcd33;
		if (pm_wait_free((int)ADBDelay*32) == 0)
			break;		/* timeout */

		*data = PM_SR();
		rval = 0;

		break;
	}

	PM_SET_STATE_ACKON();
	via_reg_or(VIA1, vACR, 0x1c);

	return rval;
}

/*
 * Send data to PM for the PB Duo series and the PB 5XX series
 */
int
pm_send(data)
	u_char data;
{
	int rval;

	via_reg_or(VIA1, vACR, 0x1c);
	write_via_reg(VIA1, vSR, data);	/* PM_SR() = data; */

	PM_SET_STATE_ACKOFF();
	rval = 0xffffcd36;
	if (pm_wait_busy((int)ADBDelay*32) != 0) {
		PM_SET_STATE_ACKON();
		via_reg_or(VIA1, vACR, 0x1c);
		return rval;
	}

	PM_SET_STATE_ACKON();
	rval = 0xffffcd35;
	if (pm_wait_free((int)ADBDelay*32) != 0)
		rval = 0;

	PM_SET_STATE_ACKON();
	via_reg_or(VIA1, vACR, 0x1c);

	return rval;
}



/*
 * My PMgrOp routine for the PB Duo series and the PB 5XX series
 */
int
pmgrop(PMData *pmdata)
{
	int i;
	int s;
	u_char via1_vIER;
	int rval = 0;
	int num_pm_data = 0;
	u_char pm_cmd;
	short pm_num_rx_data;
	u_char pm_data;
	u_char *pm_buf;

	s = splhigh();

	/* disable all interrupts but PM */
	via1_vIER = 0x10;
	via1_vIER &= read_via_reg(VIA1, vIER);
	write_via_reg(VIA1, vIER, via1_vIER);
	if (via1_vIER != 0x0)
		via1_vIER |= 0x80;

	switch (pmdata->command) {
	default:
		/* wait until PM is free */
		pm_cmd = (u_char)(pmdata->command & 0xff);
		rval = 0xcd38;
		if (pm_wait_free(ADBDelay * 4) == 0)
			break;			/* timeout */

		/* send PM command */
		if ((rval = pm_send((u_char)(pm_cmd & 0xff))))
			break;				/* timeout */

		/* send number of PM data */
		num_pm_data = pmdata->num_data;
		if (pm_send_cmd_type[pm_cmd] < 0) {
			if ((rval = pm_send((u_char)(num_pm_data & 0xff))) != 0)
				break;		/* timeout */
			pmdata->command = 0;
		}
		/* send PM data */
		pm_buf = (u_char *)pmdata->s_buf;
		for (i = 0 ; i < num_pm_data; i++)
			if ((rval = pm_send(pm_buf[i])) != 0)
				break;			/* timeout */
		if (i != num_pm_data)
			break;				/* timeout */


		/* check if PM will send me data  */
		pm_num_rx_data = pm_receive_cmd_type[pm_cmd];
		pmdata->num_data = pm_num_rx_data;
		if (pm_num_rx_data == 0) {
			rval = 0;
			break;				/* no return data */
		}

		/* receive PM command */
		pm_data = pmdata->command;
		pm_num_rx_data--;
		if (pm_num_rx_data == 0)
			if ((rval = pm_receive(&pm_data)) != 0) {
				rval = 0xffffcd37;
				break;
			}
		pmdata->command = pm_data;

		/* receive number of PM data */
		if (pm_num_rx_data < 0) {
			if ((rval = pm_receive(&pm_data)) != 0)
				break;		/* timeout */
			num_pm_data = pm_data;
		} else
			num_pm_data = pm_num_rx_data;
		pmdata->num_data = num_pm_data;

		/* receive PM data */
		pm_buf = (u_char *)pmdata->r_buf;
		for (i = 0; i < num_pm_data; i++) {
			if ((rval = pm_receive(&pm_data)) != 0)
				break;			/* timeout */
			pm_buf[i] = pm_data;
		}

		rval = 0;
	}

	/* restore former value */
	write_via_reg(VIA1, vIER, via1_vIER);
	splx(s);

	return rval;
}


/*
 * My PM interrupt routine for the PB Duo series and the PB 5XX series
 */
void
pm_intr()
{
	int s;
	int rval;
	PMData pmdata;

	s = splhigh();

	PM_VIA_CLR_INTR();			/* clear VIA1 interrupt */
						/* ask PM what happened */
	pmdata.command = 0x78;
	pmdata.num_data = 0;
	pmdata.s_buf = &pmdata.data[2];
	pmdata.r_buf = &pmdata.data[2];
	rval = pmgrop(&pmdata);
	if (rval != 0) {
#ifdef ADB_DEBUG
		if (adb_debug)
			printf("pm: PM is not ready. error code: %08x\n", rval);
#endif
		splx(s);
		return;
	}

	switch ((u_int)(pmdata.data[2] & 0xff)) {
	case 0x00:		/* 1 sec interrupt? */
		break;
	case PMU_INT_TICK:	/* 1 sec interrupt? */
		break;
	case PMU_INT_SNDBRT:	/* Brightness/Contrast button on LCD panel */
		break;
	case PMU_INT_ADB:	/* ADB data requested by TALK command */
	case PMU_INT_ADB|PMU_INT_ADB_AUTO:
		pm_adb_get_TALK_result(&pmdata);
		break;
	case 0x16:		/* ADB device event */
	case 0x18:
	case 0x1e:
	case PMU_INT_WAKEUP:
		pm_adb_get_ADB_data(&pmdata);
		break;
	default:
#ifdef ADB_DEBUG
		if (adb_debug)
			pm_printerr("driver does not support this event.",
			    pmdata.data[2], pmdata.num_data,
			    pmdata.data);
#endif
		break;
	}

	splx(s);
}

/*
 * Synchronous ADBOp routine for the Power Manager
 */
int
pm_adb_op(u_char *buffer, void *compRout, void *data, int command)
{
	int i;
	int s;
	int rval;
	int ndelay;
	int waitfor;	/* interrupts to poll for */
	int ifr;
#ifdef ADB_DEBUG
	int oldifr;
#endif
	PMData pmdata;
	struct adbCommand packet;
	extern int adbempty;

	if (adbWaiting == 1)
		return 1;

	s = splhigh();
	write_via_reg(VIA1, vIER, 0x10);

	adbBuffer = buffer;
	adbCompRout = compRout;
	adbCompData = data;

	pmdata.command = 0x20;
	pmdata.s_buf = pmdata.data;
	pmdata.r_buf = pmdata.data;

	/*
	 * if the command is LISTEN,
	 * add number of ADB data to number of PM data
	 */
	if ((command & 0xc) == 0x8) {
		if (buffer != NULL)
			pmdata.num_data = buffer[0] + 3;
	} else
		pmdata.num_data = 3;

	/*
	 * Resetting adb on several models, such as
	 * - PowerBook3,*
	 * - PowerBook5,*
	 * - PowerMac10,1
	 * causes several pmu interrupts with ifr set to PMU_INT_SNDBRT.
	 * Not processing them prevents us from seeing the adb devices
	 * afterwards, so we have to expect it unless we know the adb
	 * bus is empty.
	 */
	if (command == PMU_RESET_ADB) {
		waitfor = PMU_INT_ADB_AUTO | PMU_INT_ADB;
		if (adbempty == 0)
			waitfor |= PMU_INT_SNDBRT;
	} else
		waitfor = PMU_INT_ALL;

	pmdata.data[0] = (u_char)(command & 0xff);
	pmdata.data[1] = 0;
	/* if the command is LISTEN, copy ADB data to PM buffer */
	if ((command & 0xc) == 0x8) {
		if (buffer != NULL && buffer[0] <= 24) {
			pmdata.data[2] = buffer[0];	/* number of data */
			for (i = 0; i < buffer[0]; i++)
				pmdata.data[3 + i] = buffer[1 + i];
		} else
			pmdata.data[2] = 0;
	} else
		pmdata.data[2] = 0;

	if ((command & 0xc) != 0xc) {	/* if the command is not TALK */
		/* set up stuff for adb_pass_up */
		packet.data[0] = 1 + pmdata.data[2];
		packet.data[1] = command;
		for (i = 0; i < pmdata.data[2]; i++)
			packet.data[i+2] = pmdata.data[i+3];
		packet.saveBuf = adbBuffer;
		packet.compRout = adbCompRout;
		packet.compData = adbCompData;
		packet.cmd = command;
		packet.unsol = 0;
		packet.ack_only = 1;
		adb_polling = 1;
		adb_pass_up(&packet);
		adb_polling = 0;
	}

	rval = pmgrop(&pmdata);
	if (rval != 0) {
		splx(s);
		return 1;
	}

	delay (1000);

	adbWaiting = 1;
	adbWaitingCmd = command;

	PM_VIA_INTR_ENABLE();

	/* wait until the PM interrupt is occurred */
	ndelay = 0x8000;
#ifdef ADB_DEBUG
	oldifr = 0;
#endif
	while (adbWaiting == 1) {
		ifr = read_via_reg(VIA1, vIFR);
		if (ifr & waitfor) {
			pm_intr();
#ifdef PM_GRAB_SI
			(void)intr_dispatch(0x70);
#endif
#ifdef ADB_DEBUG
		} else if (ifr != oldifr) {
			if (adb_debug)
				printf("pm_adb_op: ignoring ifr %02x"
				    ", expecting %02x\n",
				    (u_int)ifr, (u_int)waitfor);
			oldifr = ifr;
#endif
		}
		if ((--ndelay) < 0) {
			splx(s);
			return 1;
		}
		delay(10);
	}

	/* this command enables the interrupt by operating ADB devices */
	pmdata.command = 0x20;
	pmdata.num_data = 4;
	pmdata.s_buf = pmdata.data;
	pmdata.r_buf = pmdata.data;
	pmdata.data[0] = 0x00;
	pmdata.data[1] = 0x86;	/* magic spell for awaking the PM */
	pmdata.data[2] = 0x00;
	pmdata.data[3] = 0x0c;	/* each bit may express the existent ADB device */
	rval = pmgrop(&pmdata);

	splx(s);
	return rval;
}


void
pm_adb_get_TALK_result(PMData *pmdata)
{
	int i;
	struct adbCommand packet;

	/* set up data for adb_pass_up */
	packet.data[0] = pmdata->num_data-1;
	packet.data[1] = pmdata->data[3];
	for (i = 0; i <packet.data[0]-1; i++)
		packet.data[i+2] = pmdata->data[i+4];

	packet.saveBuf = adbBuffer;
	packet.compRout = adbCompRout;
	packet.compData = adbCompData;
	packet.unsol = 0;
	packet.ack_only = 0;
	adb_polling = 1;
	adb_pass_up(&packet);
	adb_polling = 0;

	adbWaiting = 0;
	adbBuffer = (long)0;
	adbCompRout = (long)0;
	adbCompData = (long)0;
}


void
pm_adb_get_ADB_data(PMData *pmdata)
{
	int i;
	struct adbCommand packet;

	/* set up data for adb_pass_up */
	packet.data[0] = pmdata->num_data-1;	/* number of raw data */
	packet.data[1] = pmdata->data[3];	/* ADB command */
	for (i = 0; i <packet.data[0]-1; i++)
		packet.data[i+2] = pmdata->data[i+4];
	packet.unsol = 1;
	packet.ack_only = 0;
	adb_pass_up(&packet);
}

void
pm_adb_restart()
{
	PMData p;

	p.command = PMU_RESET_CPU;
	p.num_data = 0;
	p.s_buf = p.data;
	p.r_buf = p.data;
	pmgrop(&p);
}

void
pm_adb_poweroff()
{
	PMData p;

	bzero(&p, sizeof p);
	p.command = PMU_POWER_OFF;
	p.num_data = 4;
	p.s_buf = p.data;
	p.r_buf = p.data;
	strlcpy(p.data, "MATT", sizeof p.data);
	pmgrop(&p);
}

void
pm_read_date_time(time_t *time)
{
	PMData p;
	u_int32_t t;

	p.command = PMU_READ_RTC;
	p.num_data = 0;
	p.s_buf = p.data;
	p.r_buf = p.data;
	pmgrop(&p);

	bcopy(p.data, &t, sizeof(t));
	*time = (time_t)t;
}

void
pm_set_date_time(time_t time)
{
	PMData p;
	u_int32_t t = time;		/* XXX eventually truncates */

	p.command = PMU_SET_RTC;
	p.num_data = sizeof(t);
	p.s_buf = p.r_buf = p.data;
	bcopy(&t, p.data, sizeof(t));
	pmgrop(&p);
}

#if 0
void
pm_eject_pcmcia(int slot)
{
	PMData p;

	if (slot != 0 && slot != 1)
		return;

	p.command = PMU_EJECT_PCMCIA;
	p.num_data = 1;
	p.s_buf = p.r_buf = p.data;
	p.data[0] = 5 + slot;	/* XXX */
	pmgrop(&p);
}
#endif


/*
 * Thanks to Paul Mackerras and Fabio Riccardi's Linux implementation
 * for a clear description of the PMU results.
 */

int
pm_battery_info(int battery, struct pmu_battery_info *info)
{
	PMData p;

	p.command = PMU_SMART_BATTERY_STATE;
	p.num_data = 1;
	p.s_buf = p.r_buf = p.data;
	p.data[0] = battery + 1;
	pmgrop(&p);

	info->flags = p.data[1];

	switch (p.data[0]) {
	case 3:
	case 4:
		info->cur_charge = p.data[2];
		info->max_charge = p.data[3];
		info->draw = *((signed char *)&p.data[4]);
		info->voltage = p.data[5];
		break;
	case 5:
		info->cur_charge = ((p.data[2] << 8) | (p.data[3]));
		info->max_charge = ((p.data[4] << 8) | (p.data[5]));
		info->draw = *((signed short *)&p.data[6]);
		info->voltage = ((p.data[8] << 8) | (p.data[7]));
		break;
	default:
		/* XXX - Error condition */
		info->cur_charge = 0;
		info->max_charge = 0;
		info->draw = 0;
		info->voltage = 0;
		break;
	}

	return 1;
}

void
pmu_fileserver_mode(int on)
{
	PMData p;

	p.command = PMU_POWER_EVENTS;
	p.num_data = 1;
	p.s_buf = p.r_buf = p.data;
	p.data[0] = PMU_PWR_GET_POWERUP_EVENTS;
	pmgrop(&p);

	p.command = PMU_POWER_EVENTS;
	p.num_data = 3;
	p.s_buf = p.r_buf = p.data;
	p.data[1] = p.data[0];   /* result from the get */
	if (on) {
		p.data[0] = PMU_PWR_SET_POWERUP_EVENTS;
		p.data[2] = PMU_WAKE_AC_LOSS;
	} else {
		p.data[0] = PMU_PWR_CLR_POWERUP_EVENTS;
		p.data[2] = PMU_WAKE_AC_LOSS;
	}
	pmgrop(&p);
}
@


1.27
log
@not compiled before commit
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.26 2016/03/14 23:08:05 krw Exp $	*/
d431 1
a431 1
						/* ask PM what happend */
@


1.26
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.25 2013/04/23 07:38:05 mpi Exp $	*/
d540 1
a540 1
		if ((buffer != NULL && (buffer[0] <= 24)) {
@


1.25
log
@Don't assume time_t is an uint32_t.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.24 2012/12/05 23:20:13 deraadt Exp $	*/
d514 1
a514 1
		if (buffer != (u_char *)0)
d540 1
a540 1
		if ((buffer != (u_char *)0) && (buffer[0] <= 24)) {
@


1.24
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.23 2011/05/14 12:01:16 mpi Exp $	*/
d697 1
d705 2
a706 1
	bcopy(p.data, time, 4);
d713 1
d716 1
a716 1
	p.num_data = 4;
d718 1
a718 1
	bcopy(&time, p.data, 4);
@


1.23
log
@pm_* methods are always attached to a PMU, no need to check for hardware.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.22 2007/02/18 19:33:48 gwk Exp $	*/
a42 1
#include <sys/cdefs.h>
@


1.22
log
@Correct yo-yo shutdowns:
Apparently some machines don't detect a clean (i.e. software initiated)
shutdown; and ignore the 'wake on AC loss' bit, meaning they wake up
immediatly after being told to shutdown e.g. via shutdown -hp.

So now we continue preserve the wake on AC loss behaivour, howerver if we
initiate a clean shutdown we clear this bit so that it the machine does not
immediately power back up again.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.21 2007/02/12 21:01:11 gwk Exp $	*/
a56 4
/* define the types of the Power Manager */
#define PM_HW_UNKNOWN		0x00	/* don't know */
#define	PM_HW_PB5XX		0x02	/* PowerBook Duo and 5XX series */

a73 5
/*
 * Variables for internal use
 */
int	pmHardware = PM_HW_UNKNOWN;

d158 2
a159 6

/* these functions are for the PB Duo series and the PB 5XX series */
int	pm_receive_pm2(u_char *);
int	pm_send_pm2(u_char);
int	pm_pmgrop_pm2(PMData *);
void	pm_intr_pm2(void);
a210 12


/*
 * Check the hardware type of the Power Manager
 */
void
pm_setup_adb()
{
	pmHardware = PM_HW_PB5XX;	/* XXX */
}


d252 1
a252 1
pm_receive_pm2(u_char *data)
d291 1
a291 1
pm_send_pm2(data)
d324 1
a324 1
pm_pmgrop_pm2(PMData *pmdata)
d354 1
a354 1
		if ((rval = pm_send_pm2((u_char)(pm_cmd & 0xff))))
d360 1
a360 1
			if ((rval = pm_send_pm2((u_char)(num_pm_data & 0xff))) != 0)
d367 1
a367 1
			if ((rval = pm_send_pm2(pm_buf[i])) != 0)
d385 1
a385 1
			if ((rval = pm_receive_pm2(&pm_data)) != 0) {
d393 1
a393 1
			if ((rval = pm_receive_pm2(&pm_data)) != 0)
d403 1
a403 1
			if ((rval = pm_receive_pm2(&pm_data)) != 0)
d423 1
a423 1
pm_intr_pm2()
d437 1
a437 1
	rval = pm_pmgrop_pm2(&pmdata);
a475 34


/*
 * My PMgrOp routine
 */
int
pmgrop(PMData *pmdata)
{
	switch (pmHardware) {
	case PM_HW_PB5XX:
		return (pm_pmgrop_pm2(pmdata));
	default:
		/* return (pmgrop_mrg(pmdata)); */
		return 1;
	}
}


/*
 * My PM interrupt routine
 */
void
pm_intr()
{
	switch (pmHardware) {
	case PM_HW_PB5XX:
		pm_intr_pm2();
		break;
	default:
		break;
	}
}


@


1.21
log
@Add cuda_fileserver_mode() and pmu_fileserver_mode() that enable the wake
on AC loss feature of the power management IC. Make this the default
behaviour when booting OpenBSD from now on.

This will only affect machines that have the power suddenly cut, Performing
a shutdown requesting power down will clear this mode and its then possible
to remove the power cord, and plug it back in without the machine comming
back on automatically.

Tested by myself, drahn
ok kettenis, drahn.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.20 2006/03/07 20:00:18 miod Exp $	*/
d842 1
a842 1
pmu_fileserver_mode()
d856 7
a862 2
	p.data[0] = PMU_PWR_SET_POWERUP_EVENTS;
	p.data[2] |= PMU_WAKE_AC_LOSS;
@


1.20
log
@On via-pmu systems, check whether the firmware has found adb devices on the
bus to decide whether to go the long way or not when resetting the bus.
Fixes the long delay probe on Mac Mini. Tested by various.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.19 2006/02/22 07:02:23 miod Exp $	*/
d561 1
a561 1
 	adbBuffer = buffer;
d839 20
@


1.19
log
@Expect PMU_INT_SNDBRT while resetting the adb bus; although this brings the
long probe delay on the Mac Mini, this is necessary for reliable adb device
detection on several PowerBook families.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.18 2006/01/18 23:21:17 miod Exp $	*/
d553 1
d586 2
a587 1
	 * afterwards.
d589 5
a593 3
	if (command == PMU_RESET_ADB)
		waitfor = PMU_INT_ADB_AUTO | PMU_INT_ADB | PMU_INT_SNDBRT;
	else
@


1.18
log
@Factorize akbd and ams drivers between mac68k and macppc; while there, start
moving out common adb code as well, and merge adb_direct.c into adb.c to
simplify external header files.

No functional change; more cleanups to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.17 2005/12/22 22:55:25 miod Exp $	*/
d547 4
d578 9
d588 1
a588 1
		waitfor = PMU_INT_ADB_AUTO | PMU_INT_ADB;
d637 3
d641 2
a642 1
		if (read_via_reg(VIA1, vIFR) & waitfor)
d647 9
@


1.17
log
@Remove orphaned adb/pmu stuff; ok hshoexer@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.16 2005/12/10 13:45:38 pedro Exp $	*/
a46 1
#include <machine/adbsys.h>
d49 1
@


1.16
log
@Just poll for PMU_INT_ADB_AUTO and PMU_INT_ADB interrupts when resetting
the device, should fix a huge delay attaching adb(4) on some boxes,
thanks to everyone who tested, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.15 2005/12/06 02:38:24 pedro Exp $	*/
a81 3
u_short	pm_existent_ADB_devices = 0x0;	/* each bit expresses the existent ADB device */
u_int	pm_LCD_brightness = 0x0;
u_int	pm_LCD_contrast = 0x0;
a173 3
/* this function is MRG-Based (for testing) */
int	pm_pmgrop_mrg(PMData *);

a236 13
 * Check the existent ADB devices
 */
void
pm_check_adb_devices(int id)
{
	u_short ed = 0x1;

	ed <<= id;
	pm_existent_ADB_devices |= ed;
}


/*
d749 1
a749 41
int
pm_read_brightness()
{
	PMData p;

	p.command = PMU_READ_BRIGHTNESS;
	p.num_data = 1;		/* XXX why 1? */
	p.s_buf = p.r_buf = p.data;
	p.data[0] = 0;
	pmgrop(&p);

	return p.data[0];
}

void
pm_set_brightness(int val)
{
	PMData p;

	val = 0x7f - val / 2;
	if (val < 0x08)
		val = 0x08;
	if (val > 0x78)
		val = 0x78;

	p.command = PMU_SET_BRIGHTNESS;
	p.num_data = 1;
	p.s_buf = p.r_buf = p.data;
	p.data[0] = val;
	pmgrop(&p);
}

void
pm_init_brightness()
{
	int val;

	val = pm_read_brightness();
	pm_set_brightness(val);
}

d764 1
a808 31
}



int
pm_read_nvram(int addr)
{
	PMData p;

	p.command = PMU_READ_NVRAM;
	p.num_data = 2;
	p.s_buf = p.r_buf = p.data;
	p.data[0] = addr >> 8;
	p.data[1] = addr;
	pmgrop(&p);

	return p.data[0];
}

void
pm_write_nvram(int addr, int val)
{
	PMData p;

	p.command = PMU_WRITE_NVRAM;
	p.num_data = 3;
	p.s_buf = p.r_buf = p.data;
	p.data[0] = addr >> 8;
	p.data[1] = addr;
	p.data[2] = val;
	pmgrop(&p);
@


1.15
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.14 2005/10/21 22:07:45 kettenis Exp $	*/
d565 1
d593 5
d644 1
a644 1
		if (read_via_reg(VIA1, vIFR) != 0)
@


1.14
log
@Clean up RTC code.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.13 2003/10/16 03:54:48 deraadt Exp $	*/
d382 1
a382 1
	/* disable all inetrrupts but PM */
@


1.13
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.12 2003/10/16 03:31:25 drahn Exp $	*/
d737 1
a737 1
pm_read_date_time(u_long *time)
d751 1
a751 1
pm_set_date_time(u_long time)
@


1.12
log
@more ANSI/KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.11 2003/07/02 22:03:08 drahn Exp $	*/
d329 1
a329 3
}	


a346 1

d348 1
a348 2

		return rval;		
d375 1
a375 1
	u_char pm_cmd;	
d407 1
a407 1
		}			
d655 1
a655 1
	pmdata.data[0] = 0x00;	
d657 1
a657 1
	pmdata.data[2] = 0x00;	
@


1.11
log
@Use defines for the interrupt type, not magic numbers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.10 2003/05/11 19:41:10 deraadt Exp $	*/
d246 1
a246 2
pm_check_adb_devices(id)
	int id;
d259 1
a259 2
pm_wait_busy(delay)
	int delay;
d276 1
a276 2
pm_wait_free(delay)
	int delay;
d296 1
a296 2
pm_receive_pm2(data)
	u_char *data;
d372 1
a372 2
pm_pmgrop_pm2(pmdata)
	PMData *pmdata;
d530 1
a530 2
pmgrop(pmdata)
	PMData *pmdata;
d563 1
a563 5
pm_adb_op(buffer, compRout, data, command)
	u_char *buffer;
	void *compRout;
	void *data;
	int command;
d586 4
a589 1
	/* if the command is LISTEN, add number of ADB data to number of PM data */
d593 1
a593 1
	} else {
a594 1
	}
d598 2
a599 1
	if ((command & 0xc) == 0x8) {		/* if the command is LISTEN, copy ADB data to PM buffer */
d601 1
a601 1
			pmdata.data[2] = buffer[0];		/* number of data */
d609 1
a609 1
	if ((command & 0xc) != 0xc) {		/* if the command is not TALK */
d671 1
a671 2
pm_adb_get_TALK_result(pmdata)
	PMData *pmdata;
d699 1
a699 2
pm_adb_get_ADB_data(pmdata)
	PMData *pmdata;
d741 1
a741 2
pm_read_date_time(time)
	u_long *time;
d755 1
a755 2
pm_set_date_time(time)
	u_long time;
d781 1
a781 2
pm_set_brightness(val)
	int val;
d808 1
a808 2
pm_eject_pcmcia(slot)
	int slot;
d870 1
a870 2
pm_read_nvram(addr)
	int addr;
d885 1
a885 2
pm_write_nvram(addr, val)
	int addr, val;
@


1.10
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.9 2002/10/18 03:49:16 drahn Exp $	*/
d503 1
a503 1
	case 0x80:		/* 1 sec interrupt? */
d505 1
a505 1
	case 0x08:		/* Brightness/Contrast button on LCD panel */
d507 2
a508 2
	case 0x10:		/* ADB data that were requested by TALK command */
	case 0x14:
@


1.9
log
@Remove some very pointless 'if 0' code, some of which prevented compilation
with gcc3.2, and add a ';' for a case statement as it requests.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.8 2002/06/18 04:31:40 itojun Exp $	*/
d740 1
d745 1
a745 1
	strcpy(p.data, "MATT");
@


1.8
log
@KNF (whitespace)
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.7 2002/06/07 07:14:48 miod Exp $	*/
a208 6
#if 0
/*
 * Define the external functions
 */
extern int	zshard(int);		/* from zs.c */
#endif
a264 3
#if 0
		zshard(0);		/* grab any serial interrupts */
#else
a266 1
#endif
a282 3
#if 0
		zshard(0);		/* grab any serial interrupts */
#else
a284 1
#endif
a530 23
#if 0
/*
 * MRG-based PMgrOp routine
 */
int
pm_pmgrop_mrg(pmdata)
	PMData *pmdata;
{
	u_int32_t rval=0;

	asm("
		movl	%1, a0
		.word	0xa085
		movl	d0, %0"
		: "=g" (rval)
		: "g" (pmdata)
		: "a0", "d0" );

	return rval;
}
#endif


a651 3
#if 0
			zshard(0);		/* grab any serial interrupts */
#else
a652 1
#endif
@


1.7
log
@Vacuum cleaning of the adb code, step 1: random KNF, remove mac68k
leftovers, unused variables and functions, fix some comments, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.6 2002/04/10 17:35:14 drahn Exp $	*/
d322 9
a330 5
		default:
			/* set VIA SR to input mode */
			via_reg_or(VIA1, vACR, 0x0c);
			via_reg_and(VIA1, vACR, ~0x10);
			i = PM_SR();
d332 4
a335 3
			PM_SET_STATE_ACKOFF();
			if (pm_wait_busy((int)ADBDelay*32) != 0)
				break;		/* timeout */
d337 2
a338 4
			PM_SET_STATE_ACKON();
			rval = 0xffffcd33;
			if (pm_wait_free((int)ADBDelay*32) == 0)
				break;		/* timeout */
d340 1
a340 4
			*data = PM_SR();
			rval = 0;

			break;
d413 22
a434 5
		default:
			/* wait until PM is free */
			pm_cmd = (u_char)(pmdata->command & 0xff);
			rval = 0xcd38;
			if (pm_wait_free(ADBDelay * 4) == 0)
d436 11
d448 7
a454 26
			/* send PM command */
			if ((rval = pm_send_pm2((u_char)(pm_cmd & 0xff))))
				break;				/* timeout */

			/* send number of PM data */
			num_pm_data = pmdata->num_data;
			if (pm_send_cmd_type[pm_cmd] < 0) {
				if ((rval = pm_send_pm2((u_char)(num_pm_data & 0xff))) != 0)
					break;		/* timeout */
				pmdata->command = 0;
			}			
			/* send PM data */
			pm_buf = (u_char *)pmdata->s_buf;
			for (i = 0 ; i < num_pm_data; i++)
				if ((rval = pm_send_pm2(pm_buf[i])) != 0)
					break;			/* timeout */
			if (i != num_pm_data)
				break;				/* timeout */


			/* check if PM will send me data  */
			pm_num_rx_data = pm_receive_cmd_type[pm_cmd];
			pmdata->num_data = pm_num_rx_data;
			if (pm_num_rx_data == 0) {
				rval = 0;
				break;				/* no return data */
d456 10
d467 7
a473 26
			/* receive PM command */
			pm_data = pmdata->command;
			pm_num_rx_data--;
			if (pm_num_rx_data == 0)
				if ((rval = pm_receive_pm2(&pm_data)) != 0) {
					rval = 0xffffcd37;
					break;
				}
			pmdata->command = pm_data;

			/* receive number of PM data */
			if (pm_num_rx_data < 0) {
				if ((rval = pm_receive_pm2(&pm_data)) != 0)
					break;		/* timeout */
				num_pm_data = pm_data;
			} else
				num_pm_data = pm_num_rx_data;
			pmdata->num_data = num_pm_data;

			/* receive PM data */
			pm_buf = (u_char *)pmdata->r_buf;
			for (i = 0; i < num_pm_data; i++) {
				if ((rval = pm_receive_pm2(&pm_data)) != 0)
					break;			/* timeout */
				pm_buf[i] = pm_data;
			}
d475 1
a475 1
			rval = 0;
d515 17
a531 17
		case 0x00:			/* 1 sec interrupt? */
			break;
		case 0x80:			/* 1 sec interrupt? */
			break;
		case 0x08:			/* Brightness/Contrast button on LCD panel */
			break;
		case 0x10:			/* ADB data that were requested by TALK command */
		case 0x14:
			pm_adb_get_TALK_result(&pmdata);
			break;
		case 0x16:			/* ADB device event */
		case 0x18:
		case 0x1e:
		case PMU_INT_WAKEUP:
			pm_adb_get_ADB_data(&pmdata);
			break;
		default:
d533 4
a536 4
			if (adb_debug)
				pm_printerr("driver does not support this event.",
				    pmdata.data[2], pmdata.num_data,
				    pmdata.data);
d538 1
a538 1
			break;
d895 20
a914 20
	        case 3:
	        case 4:
			info->cur_charge = p.data[2];
			info->max_charge = p.data[3];
			info->draw = *((signed char *)&p.data[4]);
			info->voltage = p.data[5];
			break;
	        case 5:
			info->cur_charge = ((p.data[2] << 8) | (p.data[3]));
			info->max_charge = ((p.data[4] << 8) | (p.data[5]));
			info->draw = *((signed short *)&p.data[6]);
			info->voltage = ((p.data[8] << 8) | (p.data[7]));
			break;
	        default:
			/* XXX - Error condition */
			info->cur_charge = 0;
			info->max_charge = 0;
			info->draw = 0;
			info->voltage = 0;
			break;
@


1.6
log
@Handle all pending adb interrupts when searching for devices.
Adjust delays in the probe code. ok miod, matthieu, lebel, brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.5 2002/03/14 01:26:36 millert Exp $	*/
a32 1
/* From: pm_direct.c 1.3 03/18/98 Takashi Hamada */
a53 2
extern int adb_polling;		/* Are we polling?  (Debugger mode) */

a55 1
#define HwCfgFlags3 0x20000	/* XXX */
a58 1
#define PM_HW_PB1XX		0x01	/* PowerBook 1XX series */
a84 1
u_int	pm_counter = 0;			/* clock count */
a170 6
/* these functions are for the PB1XX series */
int	pm_receive_pm1(u_char *);
int	pm_send_pm1(u_char,int);
int	pm_pmgrop_pm1(PMData *);
void	pm_intr_pm1(void);

a179 6
/* these functions are called from adb_direct.c */
void	pm_setup_adb(void);
void	pm_check_adb_devices(int);
void	pm_intr(void);
int	pm_adb_op(u_char *, void *, void *, int);

a182 1
void	pm_adb_poll_next_device_pm1(PMData *);
a304 284


/*
 * Functions for the PB1XX series
 */

/*
 * Receive data from PM for the PB1XX series
 */
int
pm_receive_pm1(data)
	u_char *data;
{
#if 0
	int rval = 0xffffcd34;

	via_reg(VIA2, vDirA) = 0x00;

	switch (1) {
		default:
			if (pm_wait_busy(0x40) != 0)
				break;			/* timeout */

			PM_SET_STATE_ACKOFF();
			*data = via_reg(VIA2, 0x200);

			rval = 0xffffcd33;
			if (pm_wait_free(0x40) == 0)
				break;			/* timeout */

			rval = 0x00;
			break;
	}

	PM_SET_STATE_ACKON();
	via_reg(VIA2, vDirA) = 0x00;

	return rval;
#else
	panic("pm_receive_pm1");
#endif
}



/*
 * Send data to PM for the PB1XX series
 */
int
pm_send_pm1(data, delay)
	u_char data;
	int delay;
{
#if 0
	int rval;

	via_reg(VIA2, vDirA) = 0xff;
	via_reg(VIA2, 0x200) = data;

	PM_SET_STATE_ACKOFF();
	if (pm_wait_busy(0x400) != 0) {
		PM_SET_STATE_ACKON();
		via_reg(VIA2, vDirA) = 0x00;

		return 0xffffcd36;
	}

	rval = 0x0;
	PM_SET_STATE_ACKON();
	if (pm_wait_free(0x40) == 0)
		rval = 0xffffcd35;

	PM_SET_STATE_ACKON();
	via_reg(VIA2, vDirA) = 0x00;

	return rval;
#else
	panic("pm_send_pm1");
#endif
}


/*
 * My PMgrOp routine for the PB1XX series
 */
int
pm_pmgrop_pm1(pmdata)
	PMData *pmdata;
{
#if 0
	int i;
	int s = 0x81815963;
	u_char via1_vIER, via1_vDirA;
	int rval = 0;
	int num_pm_data = 0;
	u_char pm_cmd;	
	u_char pm_data;
	u_char *pm_buf;

	/* disable all inetrrupts but PM */
	via1_vIER = via_reg(VIA1, vIER);
	PM_VIA_INTR_DISABLE();

	via1_vDirA = via_reg(VIA1, vDirA);

	switch (pmdata->command) {
		default:
			for (i = 0; i < 7; i++) {
				via_reg(VIA2, vDirA) = 0x00;	

				/* wait until PM is free */
				if (pm_wait_free(ADBDelay) == 0) {	/* timeout */
					via_reg(VIA2, vDirA) = 0x00;
					/* restore formar value */
					via_reg(VIA1, vDirA) = via1_vDirA;
					via_reg(VIA1, vIER) = via1_vIER;
					return 0xffffcd38;
				}

				switch (mac68k_machine.machineid) {
					case MACH_MACPB160:
					case MACH_MACPB165:
					case MACH_MACPB165C:
					case MACH_MACPB180:
					case MACH_MACPB180C:
						{
							int delay = ADBDelay * 16;

							via_reg(VIA2, vDirA) = 0x00;
							while ((via_reg(VIA2, 0x200) == 0x7f) && (delay >= 0))
								delay--;

							if (delay < 0) {	/* timeout */
								via_reg(VIA2, vDirA) = 0x00;
								/* restore formar value */
								via_reg(VIA1, vIER) = via1_vIER;
								return 0xffffcd38;
							}
						}
				} /* end switch */

				s = splhigh();

				via1_vDirA = via_reg(VIA1, vDirA);
				via_reg(VIA1, vDirA) &= 0x7f;

				pm_cmd = (u_char)(pmdata->command & 0xff);
				if ((rval = pm_send_pm1(pm_cmd, ADBDelay * 8)) == 0)
					break;	/* send command succeeded */

				via_reg(VIA1, vDirA) = via1_vDirA;
				splx(s);
			} /* end for */

			/* failed to send a command */
			if (i == 7) {
				via_reg(VIA2, vDirA) = 0x00;
				/* restore formar value */
				via_reg(VIA1, vDirA) = via1_vDirA;
				via_reg(VIA1, vIER) = via1_vIER;
				if (s != 0x81815963)
					splx(s);
				return 0xffffcd38;
			}

			/* send # of PM data */
			num_pm_data = pmdata->num_data;
			if ((rval = pm_send_pm1((u_char)(num_pm_data & 0xff), ADBDelay * 8)) != 0)
				break;			/* timeout */

			/* send PM data */
			pm_buf = (u_char *)pmdata->s_buf;
			for (i = 0; i < num_pm_data; i++)
				if ((rval = pm_send_pm1(pm_buf[i], ADBDelay * 8)) != 0)
					break;		/* timeout */
			if ((i != num_pm_data) && (num_pm_data != 0))
				break;			/* timeout */

			/* Will PM IC return data? */
			if ((pm_cmd & 0x08) == 0) {
				rval = 0;
				break;			/* no returned data */
			}

			rval = 0xffffcd37;
			if (pm_wait_busy(ADBDelay) != 0)
				break;			/* timeout */

			/* receive PM command */
			if ((rval = pm_receive_pm1(&pm_data)) != 0)
				break;

			pmdata->command = pm_data;

			/* receive number of PM data */
			if ((rval = pm_receive_pm1(&pm_data)) != 0)
				break;			/* timeout */
			num_pm_data = pm_data;
			pmdata->num_data = num_pm_data;

			/* receive PM data */
			pm_buf = (u_char *)pmdata->r_buf;
			for (i = 0; i < num_pm_data; i++) {
				if ((rval = pm_receive_pm1(&pm_data)) != 0)
					break;		/* timeout */
				pm_buf[i] = pm_data;
			}

			rval = 0;
	}

	via_reg(VIA2, vDirA) = 0x00;	

	/* restore formar value */
	via_reg(VIA1, vDirA) = via1_vDirA;
	via_reg(VIA1, vIER) = via1_vIER;
	if (s != 0x81815963)
		splx(s);

	return rval;
#else
	panic("pm_pmgrop_pm1");
#endif
}


/*
 * My PM interrupt routine for PB1XX series
 */
void
pm_intr_pm1()
{
#if 0
	int s;
	int rval;
	PMData pmdata;

	s = splhigh();

	PM_VIA_CLR_INTR();				/* clear VIA1 interrupt */

	/* ask PM what happend */
	pmdata.command = 0x78;
	pmdata.num_data = 0;
	pmdata.data[0] = pmdata.data[1] = 0;
	pmdata.s_buf = &pmdata.data[2];
	pmdata.r_buf = &pmdata.data[2];
	rval = pm_pmgrop_pm1(&pmdata);
	if (rval != 0) {
#ifdef ADB_DEBUG
		if (adb_debug)
			printf("pm: PM is not ready. error code=%08x\n", rval);
#endif
		splx(s);
		return;
	}

	if ((pmdata.data[2] & 0x10) == 0x10) {
		if ((pmdata.data[2] & 0x0f) == 0) {
			/* ADB data that were requested by TALK command */
			pm_adb_get_TALK_result(&pmdata);
		} else if ((pmdata.data[2] & 0x08) == 0x8) {
			/* PM is requesting to poll  */
			pm_adb_poll_next_device_pm1(&pmdata);
		} else if ((pmdata.data[2] & 0x04) == 0x4) {
			/* ADB device event */
			pm_adb_get_ADB_data(&pmdata);
		}
	} else {
#ifdef ADB_DEBUG
		if (adb_debug)
			pm_printerr("driver does not supported this event.",
			    rval, pmdata.num_data, pmdata.data);
#endif
	}

	splx(s);
#else
	panic("pm_intr_pm1");
#endif
}



a419 15
			if (HwCfgFlags3 & 0x00200000) {	
				/* PB 160, PB 165(c), PB 180(c)? */
				int delay = ADBDelay * 16;

				write_via_reg(VIA2, vDirA, 0x00);
				while ((read_via_reg(VIA2, 0x200) == 0x07) &&
				    (delay >= 0))
					delay--;

				if (delay < 0) {
					rval = 0xffffcd38;
					break;		/* timeout */
				}
			}

d426 1
a426 7
			if (HwCfgFlags3 & 0x00020000) {		/* PB Duo, PB 5XX */
				if (pm_send_cmd_type[pm_cmd] < 0) {
					if ((rval = pm_send_pm2((u_char)(num_pm_data & 0xff))) != 0)
						break;		/* timeout */
					pmdata->command = 0;
				}
			} else {				/* PB 1XX series ? */
d428 2
a429 1
					break;			/* timeout */
d450 2
a451 9
			if (HwCfgFlags3 & 0x00020000) {		/* PB Duo, PB 5XX */
				pm_num_rx_data--;
				if (pm_num_rx_data == 0)
					if ((rval = pm_receive_pm2(&pm_data)) != 0) {
						rval = 0xffffcd37;
						break;
					}
				pmdata->command = pm_data;
			} else {				/* PB 1XX series ? */
d456 1
a456 2
				pmdata->command = pm_data;
			}
d459 1
a459 9
			if (HwCfgFlags3 & 0x00020000) {		/* PB Duo, PB 5XX */
				if (pm_num_rx_data < 0) {
					if ((rval = pm_receive_pm2(&pm_data)) != 0)
						break;		/* timeout */
					num_pm_data = pm_data;
				} else
					num_pm_data = pm_num_rx_data;
				pmdata->num_data = num_pm_data;
			} else {				/* PB 1XX serias ? */
d461 1
a461 1
					break;			/* timeout */
d463 3
a465 2
				pmdata->num_data = num_pm_data;
			}
a517 1
			pm_counter++;
a519 25
			/* get brightness and contrast of the LCD */
			pm_LCD_brightness = (u_int)pmdata.data[3] & 0xff;
			pm_LCD_contrast = (u_int)pmdata.data[4] & 0xff;
/*
			pm_printerr("#08", rval, pmdata.num_data, pmdata.data);
			pmdata.command = 0x33;
			pmdata.num_data = 1;
			pmdata.s_buf = pmdata.data;
			pmdata.r_buf = pmdata.data;
			pmdata.data[0] = pm_LCD_contrast;
			rval = pm_pmgrop_pm2(&pmdata);
			pm_printerr("#33", rval, pmdata.num_data, pmdata.data);
*/
			/* this is an experimental code */
			pmdata.command = 0x41;
			pmdata.num_data = 1;
			pmdata.s_buf = pmdata.data;
			pmdata.r_buf = pmdata.data;
			pm_LCD_brightness = 0x7f - pm_LCD_brightness / 2;
			if (pm_LCD_brightness < 0x08)
				pm_LCD_brightness = 0x08;
			if (pm_LCD_brightness > 0x78)
				pm_LCD_brightness = 0x78;
			pmdata.data[0] = pm_LCD_brightness;
			rval = pm_pmgrop_pm2(&pmdata);
d534 1
a534 1
				pm_printerr("driver does not supported this event.",
d576 5
a580 9
		case PM_HW_PB1XX:
			return (pm_pmgrop_pm1(pmdata));
			break;
		case PM_HW_PB5XX:
			return (pm_pmgrop_pm2(pmdata));
			break;
		default:
			/* return (pmgrop_mrg(pmdata)); */
			return 1;
d592 5
a596 8
		case PM_HW_PB1XX:
			pm_intr_pm1();
			break;
		case PM_HW_PB5XX:
			pm_intr_pm2();
			break;
		default:
			break;
d703 8
a710 18
	if (HwCfgFlags3 & 0x00020000) {		/* PB Duo series, PB 5XX series */
		pmdata.command = 0x20;
		pmdata.num_data = 4;
		pmdata.s_buf = pmdata.data;
		pmdata.r_buf = pmdata.data;
		pmdata.data[0] = 0x00;	
		pmdata.data[1] = 0x86;	/* magic spell for awaking the PM */
		pmdata.data[2] = 0x00;	
		pmdata.data[3] = 0x0c;	/* each bit may express the existent ADB device */
	} else {				/* PB 1XX series */
		pmdata.command = 0x20;
		pmdata.num_data = 3;
		pmdata.s_buf = pmdata.data;
		pmdata.r_buf = pmdata.data;
		pmdata.data[0] = (u_char)(command & 0xf0) | 0xc;
		pmdata.data[1] = 0x04;
		pmdata.data[2] = 0x00;
	}
a761 30
}


void
pm_adb_poll_next_device_pm1(pmdata)
	PMData *pmdata;
{
	int i;
	int ndid;
	u_short bendid = 0x1;
	int rval;
	PMData tmp_pmdata;

	/* find another existent ADB device to poll */
	for (i = 1; i < 16; i++) {
		ndid = (ADB_CMDADDR(pmdata->data[3]) + i) & 0xf;
		bendid <<= ndid;
		if ((pm_existent_ADB_devices & bendid) != 0)
			break;
	}

	/* poll the other device */
	tmp_pmdata.command = 0x20;
	tmp_pmdata.num_data = 3;
	tmp_pmdata.s_buf = tmp_pmdata.data;
	tmp_pmdata.r_buf = tmp_pmdata.data;
	tmp_pmdata.data[0] = (u_char)(ndid << 4) | 0xc;
	tmp_pmdata.data[1] = 0x04;	/* magic spell for awaking the PM */
	tmp_pmdata.data[2] = 0x00;
	rval = pmgrop(&tmp_pmdata);
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.4 2001/10/03 14:45:37 drahn Exp $	*/
d1047 1
a1047 1
	delay(10000);
d1055 1
a1055 1
	ndelay = 0x80000;
d1057 1
a1057 1
		if (read_via_reg(VIA1, vIFR) & 0x14)
d1070 1
@


1.4
log
@apm support for macppc. This is not fully implemented, sleep modes
and power event are not handled, however it is enough support
to poll the battery/AC/charging states of the system.
Code by Alexander Guy.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.3 2001/09/20 17:02:30 mpech Exp $	*/
d171 1
a171 1
void	pm_printerr __P((char *, int, int, char *));
d174 2
a175 2
int	pm_wait_busy __P((int));
int	pm_wait_free __P((int));
d178 4
a181 4
int	pm_receive_pm1 __P((u_char *));
int	pm_send_pm1 __P((u_char,int));
int	pm_pmgrop_pm1 __P((PMData *));
void	pm_intr_pm1 __P((void));
d184 4
a187 4
int	pm_receive_pm2 __P((u_char *));
int	pm_send_pm2 __P((u_char));
int	pm_pmgrop_pm2 __P((PMData *));
void	pm_intr_pm2 __P((void));
d190 1
a190 1
int	pm_pmgrop_mrg __P((PMData *));
d193 4
a196 4
void	pm_setup_adb __P((void));
void	pm_check_adb_devices __P((int));
void	pm_intr __P((void));
int	pm_adb_op __P((u_char *, void *, void *, int));
d199 3
a201 3
void	pm_adb_get_TALK_result __P((PMData *));
void	pm_adb_get_ADB_data __P((PMData *));
void	pm_adb_poll_next_device_pm1 __P((PMData *));
d226 1
a226 1
extern	void	adb_pass_up __P((struct adbCommand *));
d232 1
a232 1
extern int	zshard __P((int));		/* from zs.c */
@


1.4.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.4 2001/10/03 14:45:37 drahn Exp $	*/
d33 1
d55 2
d59 1
d63 1
d90 1
d171 1
a171 1
void	pm_printerr(char *, int, int, char *);
d174 8
a181 2
int	pm_wait_busy(int);
int	pm_wait_free(int);
d184 4
a187 4
int	pm_receive_pm2(u_char *);
int	pm_send_pm2(u_char);
int	pm_pmgrop_pm2(PMData *);
void	pm_intr_pm2(void);
d190 7
a196 1
int	pm_pmgrop_mrg(PMData *);
d199 3
a201 2
void	pm_adb_get_TALK_result(PMData *);
void	pm_adb_get_ADB_data(PMData *);
d226 1
a226 1
extern	void	adb_pass_up(struct adbCommand *);
d232 1
a232 1
extern int	zshard(int);		/* from zs.c */
d324 284
d723 15
d744 7
a750 1
			if (pm_send_cmd_type[pm_cmd] < 0) {
d752 1
a752 2
					break;		/* timeout */
				pmdata->command = 0;
d773 9
a781 2
			pm_num_rx_data--;
			if (pm_num_rx_data == 0)
d786 2
a787 1
			pmdata->command = pm_data;
d790 9
a798 1
			if (pm_num_rx_data < 0) {
d800 1
a800 1
					break;		/* timeout */
d802 2
a803 3
			} else
				num_pm_data = pm_num_rx_data;
			pmdata->num_data = num_pm_data;
d856 1
d859 25
d898 1
a898 1
				pm_printerr("driver does not support this event.",
d940 9
a948 5
	case PM_HW_PB5XX:
		return (pm_pmgrop_pm2(pmdata));
	default:
		/* return (pmgrop_mrg(pmdata)); */
		return 1;
d960 8
a967 5
	case PM_HW_PB5XX:
		pm_intr_pm2();
		break;
	default:
		break;
d1047 1
a1047 1
	delay (1000);
d1055 1
a1055 1
	ndelay = 0x8000;
d1057 1
a1057 1
		if (read_via_reg(VIA1, vIFR) != 0)
a1069 1
		delay(10);
d1073 18
a1090 8
	pmdata.command = 0x20;
	pmdata.num_data = 4;
	pmdata.s_buf = pmdata.data;
	pmdata.r_buf = pmdata.data;
	pmdata.data[0] = 0x00;	
	pmdata.data[1] = 0x86;	/* magic spell for awaking the PM */
	pmdata.data[2] = 0x00;	
	pmdata.data[3] = 0x0c;	/* each bit may express the existent ADB device */
d1142 30
@


1.4.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.4.6.1 2002/06/11 03:36:34 art Exp $	*/
d209 6
d271 3
d276 1
d293 3
d298 1
d322 9
a330 9
	default:
		/* set VIA SR to input mode */
		via_reg_or(VIA1, vACR, 0x0c);
		via_reg_and(VIA1, vACR, ~0x10);
		i = PM_SR();

		PM_SET_STATE_ACKOFF();
		if (pm_wait_busy((int)ADBDelay*32) != 0)
			break;		/* timeout */
d332 4
a335 4
		PM_SET_STATE_ACKON();
		rval = 0xffffcd33;
		if (pm_wait_free((int)ADBDelay*32) == 0)
			break;		/* timeout */
d337 2
a338 2
		*data = PM_SR();
		rval = 0;
d340 1
a340 1
		break;
d413 5
a417 22
	default:
		/* wait until PM is free */
		pm_cmd = (u_char)(pmdata->command & 0xff);
		rval = 0xcd38;
		if (pm_wait_free(ADBDelay * 4) == 0)
			break;			/* timeout */

		/* send PM command */
		if ((rval = pm_send_pm2((u_char)(pm_cmd & 0xff))))
			break;				/* timeout */

		/* send number of PM data */
		num_pm_data = pmdata->num_data;
		if (pm_send_cmd_type[pm_cmd] < 0) {
			if ((rval = pm_send_pm2((u_char)(num_pm_data & 0xff))) != 0)
				break;		/* timeout */
			pmdata->command = 0;
		}			
		/* send PM data */
		pm_buf = (u_char *)pmdata->s_buf;
		for (i = 0 ; i < num_pm_data; i++)
			if ((rval = pm_send_pm2(pm_buf[i])) != 0)
a418 2
		if (i != num_pm_data)
			break;				/* timeout */
d420 27
d448 25
a472 15
		/* check if PM will send me data  */
		pm_num_rx_data = pm_receive_cmd_type[pm_cmd];
		pmdata->num_data = pm_num_rx_data;
		if (pm_num_rx_data == 0) {
			rval = 0;
			break;				/* no return data */
		}

		/* receive PM command */
		pm_data = pmdata->command;
		pm_num_rx_data--;
		if (pm_num_rx_data == 0)
			if ((rval = pm_receive_pm2(&pm_data)) != 0) {
				rval = 0xffffcd37;
				break;
a473 1
		pmdata->command = pm_data;
d475 1
a475 18
		/* receive number of PM data */
		if (pm_num_rx_data < 0) {
			if ((rval = pm_receive_pm2(&pm_data)) != 0)
				break;		/* timeout */
			num_pm_data = pm_data;
		} else
			num_pm_data = pm_num_rx_data;
		pmdata->num_data = num_pm_data;

		/* receive PM data */
		pm_buf = (u_char *)pmdata->r_buf;
		for (i = 0; i < num_pm_data; i++) {
			if ((rval = pm_receive_pm2(&pm_data)) != 0)
				break;			/* timeout */
			pm_buf[i] = pm_data;
		}

		rval = 0;
d515 17
a531 17
	case 0x00:		/* 1 sec interrupt? */
		break;
	case 0x80:		/* 1 sec interrupt? */
		break;
	case 0x08:		/* Brightness/Contrast button on LCD panel */
		break;
	case 0x10:		/* ADB data that were requested by TALK command */
	case 0x14:
		pm_adb_get_TALK_result(&pmdata);
		break;
	case 0x16:		/* ADB device event */
	case 0x18:
	case 0x1e:
	case PMU_INT_WAKEUP:
		pm_adb_get_ADB_data(&pmdata);
		break;
	default:
d533 4
a536 4
		if (adb_debug)
			pm_printerr("driver does not support this event.",
			    pmdata.data[2], pmdata.num_data,
			    pmdata.data);
d538 1
a538 1
		break;
d545 23
d689 3
d694 1
d895 20
a914 20
	case 3:
	case 4:
		info->cur_charge = p.data[2];
		info->max_charge = p.data[3];
		info->draw = *((signed char *)&p.data[4]);
		info->voltage = p.data[5];
		break;
	case 5:
		info->cur_charge = ((p.data[2] << 8) | (p.data[3]));
		info->max_charge = ((p.data[4] << 8) | (p.data[5]));
		info->draw = *((signed short *)&p.data[6]);
		info->voltage = ((p.data[8] << 8) | (p.data[7]));
		break;
	default:
		/* XXX - Error condition */
		info->cur_charge = 0;
		info->max_charge = 0;
		info->draw = 0;
		info->voltage = 0;
		break;
@


1.4.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a739 1
	bzero(&p, sizeof p);
d744 1
a744 1
	strlcpy(p.data, "MATT", sizeof p.data);
@


1.4.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4.4.2
log
@Merge in -current from about a week ago
@
text
@d171 1
a171 1
void	pm_printerr(char *, int, int, char *);
d174 2
a175 2
int	pm_wait_busy(int);
int	pm_wait_free(int);
d178 4
a181 4
int	pm_receive_pm1(u_char *);
int	pm_send_pm1(u_char,int);
int	pm_pmgrop_pm1(PMData *);
void	pm_intr_pm1(void);
d184 4
a187 4
int	pm_receive_pm2(u_char *);
int	pm_send_pm2(u_char);
int	pm_pmgrop_pm2(PMData *);
void	pm_intr_pm2(void);
d190 1
a190 1
int	pm_pmgrop_mrg(PMData *);
d193 4
a196 4
void	pm_setup_adb(void);
void	pm_check_adb_devices(int);
void	pm_intr(void);
int	pm_adb_op(u_char *, void *, void *, int);
d199 3
a201 3
void	pm_adb_get_TALK_result(PMData *);
void	pm_adb_get_ADB_data(PMData *);
void	pm_adb_poll_next_device_pm1(PMData *);
d226 1
a226 1
extern	void	adb_pass_up(struct adbCommand *);
d232 1
a232 1
extern int	zshard(int);		/* from zs.c */
@


1.4.4.3
log
@Sync the SMP branch with 3.3
@
text
@d33 1
d55 2
d59 1
d63 1
d90 1
d177 6
d192 6
d201 1
d228 6
d290 3
d295 1
d312 3
d317 1
d324 284
d625 9
a633 9
	default:
		/* set VIA SR to input mode */
		via_reg_or(VIA1, vACR, 0x0c);
		via_reg_and(VIA1, vACR, ~0x10);
		i = PM_SR();

		PM_SET_STATE_ACKOFF();
		if (pm_wait_busy((int)ADBDelay*32) != 0)
			break;		/* timeout */
d635 4
a638 4
		PM_SET_STATE_ACKON();
		rval = 0xffffcd33;
		if (pm_wait_free((int)ADBDelay*32) == 0)
			break;		/* timeout */
d640 2
a641 2
		*data = PM_SR();
		rval = 0;
d643 1
a643 1
		break;
d716 5
a720 22
	default:
		/* wait until PM is free */
		pm_cmd = (u_char)(pmdata->command & 0xff);
		rval = 0xcd38;
		if (pm_wait_free(ADBDelay * 4) == 0)
			break;			/* timeout */

		/* send PM command */
		if ((rval = pm_send_pm2((u_char)(pm_cmd & 0xff))))
			break;				/* timeout */

		/* send number of PM data */
		num_pm_data = pmdata->num_data;
		if (pm_send_cmd_type[pm_cmd] < 0) {
			if ((rval = pm_send_pm2((u_char)(num_pm_data & 0xff))) != 0)
				break;		/* timeout */
			pmdata->command = 0;
		}			
		/* send PM data */
		pm_buf = (u_char *)pmdata->s_buf;
		for (i = 0 ; i < num_pm_data; i++)
			if ((rval = pm_send_pm2(pm_buf[i])) != 0)
a721 2
		if (i != num_pm_data)
			break;				/* timeout */
d723 14
d738 32
a769 7
		/* check if PM will send me data  */
		pm_num_rx_data = pm_receive_cmd_type[pm_cmd];
		pmdata->num_data = pm_num_rx_data;
		if (pm_num_rx_data == 0) {
			rval = 0;
			break;				/* no return data */
		}
d771 16
a786 7
		/* receive PM command */
		pm_data = pmdata->command;
		pm_num_rx_data--;
		if (pm_num_rx_data == 0)
			if ((rval = pm_receive_pm2(&pm_data)) != 0) {
				rval = 0xffffcd37;
				break;
a787 1
		pmdata->command = pm_data;
d789 15
a803 8
		/* receive number of PM data */
		if (pm_num_rx_data < 0) {
			if ((rval = pm_receive_pm2(&pm_data)) != 0)
				break;		/* timeout */
			num_pm_data = pm_data;
		} else
			num_pm_data = pm_num_rx_data;
		pmdata->num_data = num_pm_data;
d805 7
a811 7
		/* receive PM data */
		pm_buf = (u_char *)pmdata->r_buf;
		for (i = 0; i < num_pm_data; i++) {
			if ((rval = pm_receive_pm2(&pm_data)) != 0)
				break;			/* timeout */
			pm_buf[i] = pm_data;
		}
d813 1
a813 1
		rval = 0;
d853 43
a895 17
	case 0x00:		/* 1 sec interrupt? */
		break;
	case 0x80:		/* 1 sec interrupt? */
		break;
	case 0x08:		/* Brightness/Contrast button on LCD panel */
		break;
	case 0x10:		/* ADB data that were requested by TALK command */
	case 0x14:
		pm_adb_get_TALK_result(&pmdata);
		break;
	case 0x16:		/* ADB device event */
	case 0x18:
	case 0x1e:
	case PMU_INT_WAKEUP:
		pm_adb_get_ADB_data(&pmdata);
		break;
	default:
d897 4
a900 4
		if (adb_debug)
			pm_printerr("driver does not support this event.",
			    pmdata.data[2], pmdata.num_data,
			    pmdata.data);
d902 1
a902 1
		break;
d909 23
d940 9
a948 5
	case PM_HW_PB5XX:
		return (pm_pmgrop_pm2(pmdata));
	default:
		/* return (pmgrop_mrg(pmdata)); */
		return 1;
d960 8
a967 5
	case PM_HW_PB5XX:
		pm_intr_pm2();
		break;
	default:
		break;
d1047 1
a1047 1
	delay (1000);
d1055 1
a1055 1
	ndelay = 0x8000;
d1057 1
a1057 1
		if (read_via_reg(VIA1, vIFR) != 0)
d1060 3
d1065 1
a1069 1
		delay(10);
d1073 18
a1090 8
	pmdata.command = 0x20;
	pmdata.num_data = 4;
	pmdata.s_buf = pmdata.data;
	pmdata.r_buf = pmdata.data;
	pmdata.data[0] = 0x00;	
	pmdata.data[1] = 0x86;	/* magic spell for awaking the PM */
	pmdata.data[2] = 0x00;	
	pmdata.data[3] = 0x0c;	/* each bit may express the existent ADB device */
d1144 30
d1305 20
a1324 20
	case 3:
	case 4:
		info->cur_charge = p.data[2];
		info->max_charge = p.data[3];
		info->draw = *((signed char *)&p.data[4]);
		info->voltage = p.data[5];
		break;
	case 5:
		info->cur_charge = ((p.data[2] << 8) | (p.data[3]));
		info->max_charge = ((p.data[4] << 8) | (p.data[5]));
		info->draw = *((signed short *)&p.data[6]);
		info->voltage = ((p.data[8] << 8) | (p.data[7]));
		break;
	default:
		/* XXX - Error condition */
		info->cur_charge = 0;
		info->max_charge = 0;
		info->draw = 0;
		info->voltage = 0;
		break;
@


1.4.4.4
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.4.4.3 2003/03/27 23:29:46 niklas Exp $	*/
a739 1
	bzero(&p, sizeof p);
d744 1
a744 1
	strlcpy(p.data, "MATT", sizeof p.data);
@


1.4.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d246 2
a247 1
pm_check_adb_devices(int id)
d260 2
a261 1
pm_wait_busy(int delay)
d278 2
a279 1
pm_wait_free(int delay)
d299 2
a300 1
pm_receive_pm2(u_char *data)
d333 3
a335 1
}
d353 1
d355 2
a356 1
		return rval;
d376 2
a377 1
pm_pmgrop_pm2(PMData *pmdata)
d384 1
a384 1
	u_char pm_cmd;
d416 1
a416 1
		}
d503 1
a503 1
	case PMU_INT_TICK:	/* 1 sec interrupt? */
d505 1
a505 1
	case PMU_INT_SNDBRT:	/* Brightness/Contrast button on LCD panel */
d507 2
a508 2
	case PMU_INT_ADB:	/* ADB data requested by TALK command */
	case PMU_INT_ADB|PMU_INT_ADB_AUTO:
d535 2
a536 1
pmgrop(PMData *pmdata)
d569 5
a573 1
pm_adb_op(u_char *buffer, void *compRout, void *data, int command)
d596 1
a596 4
	/*
	 * if the command is LISTEN,
	 * add number of ADB data to number of PM data
	 */
d600 1
a600 1
	} else
d602 1
d606 1
a606 2
	/* if the command is LISTEN, copy ADB data to PM buffer */
	if ((command & 0xc) == 0x8) {
d608 1
a608 1
			pmdata.data[2] = buffer[0];	/* number of data */
d616 1
a616 1
	if ((command & 0xc) != 0xc) {	/* if the command is not TALK */
d666 1
a666 1
	pmdata.data[0] = 0x00;
d668 1
a668 1
	pmdata.data[2] = 0x00;
d678 2
a679 1
pm_adb_get_TALK_result(PMData *pmdata)
d707 2
a708 1
pm_adb_get_ADB_data(PMData *pmdata)
d750 2
a751 1
pm_read_date_time(u_long *time)
d765 2
a766 1
pm_set_date_time(u_long time)
d792 2
a793 1
pm_set_brightness(int val)
d820 2
a821 1
pm_eject_pcmcia(int slot)
d883 2
a884 1
pm_read_nvram(int addr)
d899 2
a900 1
pm_write_nvram(int addr, int val)
@


1.3
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.2 2001/09/01 17:43:09 drahn Exp $	*/
d1284 47
@


1.2
log
@correct files for the powerpc/mac/ -> macppc/dev which did not get
renamed correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.1 2001/09/01 15:50:00 drahn Exp $	*/
d1054 1
a1054 1
	/* wait until the PM interrupt is occured */
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/mac to macppc/dev
@
text
@d1 1
a1 1
/*	$OpenBSD: pm_direct.c,v 1.5 2001/08/18 21:22:09 drahn Exp $	*/
d51 3
a53 3
#include <macppc/mac/adbvar.h>
#include <macppc/mac/pm_direct.h>
#include <macppc/mac/viareg.h>
@

