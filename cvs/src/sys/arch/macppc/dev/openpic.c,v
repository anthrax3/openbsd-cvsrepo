head	1.83;
access;
symbols
	OPENBSD_6_1:1.83.0.6
	OPENBSD_6_1_BASE:1.83
	OPENBSD_6_0:1.83.0.4
	OPENBSD_6_0_BASE:1.83
	OPENBSD_5_9:1.83.0.2
	OPENBSD_5_9_BASE:1.83
	OPENBSD_5_8:1.82.0.4
	OPENBSD_5_8_BASE:1.82
	OPENBSD_5_7:1.76.0.2
	OPENBSD_5_7_BASE:1.76
	OPENBSD_5_6:1.72.0.4
	OPENBSD_5_6_BASE:1.72
	OPENBSD_5_5:1.69.0.8
	OPENBSD_5_5_BASE:1.69
	OPENBSD_5_4:1.69.0.4
	OPENBSD_5_4_BASE:1.69
	OPENBSD_5_3:1.69.0.2
	OPENBSD_5_3_BASE:1.69
	OPENBSD_5_2:1.68.0.4
	OPENBSD_5_2_BASE:1.68
	OPENBSD_5_1_BASE:1.68
	OPENBSD_5_1:1.68.0.2
	OPENBSD_5_0:1.64.0.2
	OPENBSD_5_0_BASE:1.64
	OPENBSD_4_9:1.63.0.2
	OPENBSD_4_9_BASE:1.63
	OPENBSD_4_8:1.61.0.2
	OPENBSD_4_8_BASE:1.61
	OPENBSD_4_7:1.59.0.2
	OPENBSD_4_7_BASE:1.59
	OPENBSD_4_6:1.54.0.4
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.52.0.2
	OPENBSD_4_5_BASE:1.52
	OPENBSD_4_4:1.45.0.2
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.40.0.2
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.33.0.2
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.28.0.6
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.4
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.18
	UBC:1.7.0.2
	UBC_BASE:1.7
	SMP:1.6.0.4
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.83
date	2015.09.08.08.29.35;	author deraadt;	state Exp;
branches;
next	1.82;
commitid	Qv4sSaeodDiHWA1c;

1.82
date	2015.06.25.08.56.33;	author mpi;	state Exp;
branches;
next	1.81;
commitid	8uYgcUXrqFLu2Sa3;

1.81
date	2015.06.24.11.58.06;	author mpi;	state Exp;
branches;
next	1.80;
commitid	ydQ89S8LGKdOdYT1;

1.80
date	2015.06.02.13.53.43;	author mpi;	state Exp;
branches;
next	1.79;
commitid	zxbsb8LuCsaRWdMJ;

1.79
date	2015.04.02.11.22.48;	author mpi;	state Exp;
branches;
next	1.78;
commitid	WVrWB6TQcX8NU4dB;

1.78
date	2015.04.02.11.12.24;	author mpi;	state Exp;
branches;
next	1.77;
commitid	H6AjB4yqSabDCpNM;

1.77
date	2015.04.02.10.58.20;	author mpi;	state Exp;
branches;
next	1.76;
commitid	SO8nv07uiEk4zjKe;

1.76
date	2015.01.04.13.01.42;	author mpi;	state Exp;
branches;
next	1.75;
commitid	NhpbICTczAMSUxav;

1.75
date	2014.10.08.22.24.26;	author deraadt;	state Exp;
branches;
next	1.74;
commitid	uHG8tr1DGdNgykO0;

1.74
date	2014.09.06.10.45.29;	author mpi;	state Exp;
branches;
next	1.73;
commitid	psPuYzRRUiGpyp76;

1.73
date	2014.08.30.09.42.20;	author mpi;	state Exp;
branches;
next	1.72;
commitid	Dshi7LrssPWioCfN;

1.72
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.71;
commitid	uKVPYMN2MLxdZxzH;

1.71
date	2014.04.01.20.27.14;	author mpi;	state Exp;
branches;
next	1.70;

1.70
date	2014.03.31.18.58.41;	author mpi;	state Exp;
branches;
next	1.69;

1.69
date	2012.10.08.20.06.37;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2011.10.28.15.18.51;	author drahn;	state Exp;
branches;
next	1.67;

1.67
date	2011.10.24.13.01.07;	author drahn;	state Exp;
branches;
next	1.66;

1.66
date	2011.10.22.01.16.39;	author drahn;	state Exp;
branches;
next	1.65;

1.65
date	2011.08.29.20.21.44;	author drahn;	state Exp;
branches;
next	1.64;

1.64
date	2011.04.15.20.52.55;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2011.01.08.18.10.22;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.61;

1.61
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2010.04.09.19.24.17;	author jasper;	state Exp;
branches;
next	1.59;

1.59
date	2009.11.08.21.05.18;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2009.10.01.20.19.18;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2009.09.15.21.02.24;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2009.09.13.10.16.37;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.54;

1.54
date	2009.06.09.01.12.38;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2009.06.02.21.38.09;	author drahn;	state Exp;
branches;
next	1.52;

1.52
date	2008.11.21.17.35.52;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2008.11.04.14.28.24;	author drahn;	state Exp;
branches;
next	1.50;

1.50
date	2008.09.19.01.49.54;	author drahn;	state Exp;
branches;
next	1.49;

1.49
date	2008.09.18.03.56.25;	author drahn;	state Exp;
branches;
next	1.48;

1.48
date	2008.09.16.04.20.42;	author drahn;	state Exp;
branches;
next	1.47;

1.47
date	2008.08.25.03.16.22;	author todd;	state Exp;
branches;
next	1.46;

1.46
date	2008.08.24.23.44.44;	author todd;	state Exp;
branches;
next	1.45;

1.45
date	2008.05.04.20.54.22;	author drahn;	state Exp;
branches;
next	1.44;

1.44
date	2008.05.03.22.44.56;	author drahn;	state Exp;
branches;
next	1.43;

1.43
date	2008.05.01.08.25.32;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2008.04.26.22.37.41;	author drahn;	state Exp;
branches;
next	1.41;

1.41
date	2007.10.27.22.37.03;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.29.18.10.43;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.10.15.28.09;	author drahn;	state Exp;
branches;
next	1.38;

1.38
date	2007.04.22.22.31.14;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2007.03.20.20.59.53;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2007.03.01.15.00.57;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2006.06.19.22.42.33;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.12.02.49.50;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.17.15.03.51;	author drahn;	state Exp;
branches;
next	1.32;

1.32
date	2005.10.16.04.30.43;	author drahn;	state Exp;
branches;
next	1.31;

1.31
date	2005.10.09.03.50.11;	author drahn;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.30.19.51.52;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2005.09.26.19.52.08;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2004.07.14.11.36.16;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.28.02.49.10;	author aaron;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.08.22.10.12;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.19.21.57.35;	author drahn;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.16.03.54.48;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.16.03.31.25;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.07.16.08.58;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.02.21.30.13;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.23.27.49;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.12.22.40.59;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.15.02.02.43;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.03.15.55;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.08.20.33.43;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.02.17.31.53;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.02.17.27.18;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.02.17.17.37;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.26.15.22.52;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.21.05.11.29;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.17.16.17.23;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.10.03.14.07.05;	author drahn;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.09.28.04.13.12;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.11.06.47.00;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.10.12.58.50;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.01.17.43.09;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.50.00;	author drahn;	state Exp;
branches;
next	;

1.6.4.1
date	2001.10.31.03.01.15;	author nate;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2002.03.06.01.06.11;	author niklas;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2003.06.07.11.13.14;	author ho;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	1.6.4.8;

1.6.4.8
date	2004.06.05.23.10.52;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.01.31.22.55.14;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.83
log
@sizes for free(); ok semarie
@
text
@/*	$OpenBSD: openpic.c,v 1.82 2015/06/25 08:56:33 mpi Exp $	*/

/*-
 * Copyright (c) 2008 Dale Rahn <drahn@@openbsd.org>
 * Copyright (c) 1995 Per Fogelstrom
 * Copyright (c) 1993, 1994 Charles M. Hannum.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz and Don Ahn.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)isa.c	7.2 (Berkeley) 5/12/91
 */

#include "hpb.h"

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/atomic.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/intr.h>
#include <machine/psl.h>
#include <machine/pio.h>
#include <dev/ofw/openfirm.h>

#include <macppc/dev/openpicreg.h>

#ifdef OPENPIC_DEBUG
#define DPRINTF(x...)	do { printf(x); } while(0)
#else
#define DPRINTF(x...)
#endif

#define ICU_LEN 128
int openpic_numirq = ICU_LEN;
#define LEGAL_IRQ(x) ((x >= 0) && (x < ICU_LEN))

int openpic_pri_share[IPL_NUM];

struct intrq openpic_handler[ICU_LEN];

struct openpic_softc {
	struct device sc_dev;
};

vaddr_t openpic_base;
int	openpic_big_endian;
struct	evcount openpic_spurious;
int	openpic_spurious_irq = 255;

int	openpic_match(struct device *parent, void *cf, void *aux);
void	openpic_attach(struct device *, struct device *, void *);

int	openpic_splraise(int);
int	openpic_spllower(int);
void	openpic_splx(int);

u_int	openpic_read(int reg);
void	openpic_write(int reg, u_int val);

void	openpic_acknowledge_irq(int, int);
void	openpic_enable_irq(int, int, int);
void	openpic_disable_irq(int, int);

void	openpic_calc_mask(void);
void	openpic_set_priority(int, int);
void	*openpic_intr_establish(void *, int, int, int, int (*)(void *), void *,
	    const char *);
void	openpic_intr_disestablish(void *, void *);
void	openpic_collect_preconf_intr(void);
void	openpic_ext_intr(void);
int	openpic_ext_intr_handler(struct intrhand *, int, int *);

/* Generic IRQ management routines. */
void	openpic_gen_acknowledge_irq(int, int);
void	openpic_gen_enable_irq(int, int, int);
void	openpic_gen_disable_irq(int, int);

#if NHPB > 0
/* CPC945 IRQ management routines. */
void	openpic_cpc945_acknowledge_irq(int, int);
void	openpic_cpc945_enable_irq(int, int, int);
void	openpic_cpc945_disable_irq(int, int);
#endif /* NHPB */

struct openpic_ops {
	void	(*acknowledge_irq)(int, int);
	void	(*enable_irq)(int, int, int);
	void	(*disable_irq)(int, int);
} openpic_ops = {
	openpic_gen_acknowledge_irq,
	openpic_gen_enable_irq,
	openpic_gen_disable_irq
};

#ifdef MULTIPROCESSOR
void	openpic_ipi_ddb(void);

/* IRQ vector used for inter-processor interrupts. */
#define IPI_VECTOR_NOP	64
#define IPI_VECTOR_DDB	65

static struct evcount ipi_count;

static int ipi_irq = IPI_VECTOR_NOP;

intr_send_ipi_t openpic_send_ipi;
#endif /* MULTIPROCESSOR */

const struct cfattach openpic_ca = {
	sizeof(struct openpic_softc), openpic_match, openpic_attach
};

struct cfdriver openpic_cd = {
	NULL, "openpic", DV_DULL
};

u_int
openpic_read(int reg)
{
	char *addr = (void *)(openpic_base + reg);

	membar_sync();
	if (openpic_big_endian)
		return in32(addr);
	else
		return in32rb(addr);
}

void
openpic_write(int reg, u_int val)
{
	char *addr = (void *)(openpic_base + reg);

	if (openpic_big_endian)
		out32(addr, val);
	else
		out32rb(addr, val);
	membar_sync();
}

static inline int
openpic_read_irq(int cpu)
{
	return openpic_read(OPENPIC_IACK(cpu)) & OPENPIC_VECTOR_MASK;
}

static inline void
openpic_eoi(int cpu)
{
	openpic_write(OPENPIC_EOI(cpu), 0);
}

int
openpic_match(struct device *parent, void *cf, void *aux)
{
	char type[40];
	int pirq;
	struct confargs *ca = aux;

	bzero (type, sizeof(type));

	if (OF_getprop(ca->ca_node, "interrupt-parent", &pirq, sizeof(pirq))
	    == sizeof(pirq))
		return 0; /* XXX */

	if (strcmp(ca->ca_name, "interrupt-controller") != 0 &&
	    strcmp(ca->ca_name, "mpic") != 0)
		return 0;

	OF_getprop(ca->ca_node, "device_type", type, sizeof(type));
	if (strcmp(type, "open-pic") != 0)
		return 0;

	if (ca->ca_nreg < 8)
		return 0;

	return 1;
}

void
openpic_attach(struct device *parent, struct device *self, void *aux)
{
	struct cpu_info *ci = curcpu();
	struct confargs *ca = aux;
	struct intrq *iq;
	uint32_t reg = 0;
	int i, irq;
	u_int x;

	if (OF_getprop(ca->ca_node, "big-endian", &reg, sizeof reg) == 0)
		openpic_big_endian = 1;

	openpic_base = (vaddr_t) mapiodev (ca->ca_baseaddr +
			ca->ca_reg[0], 0x40000);

	/* Reset the PIC */
	x = openpic_read(OPENPIC_CONFIG) | OPENPIC_CONFIG_RESET;
	openpic_write(OPENPIC_CONFIG, x);

	while (openpic_read(OPENPIC_CONFIG) & OPENPIC_CONFIG_RESET)
		delay(100);

	/* openpic may support more than 128 interupts but driver doesn't */
	openpic_numirq = ((openpic_read(OPENPIC_FEATURE) >> 16) & 0x7f)+1;

	printf(": version 0x%x feature %x %s",
	    openpic_read(OPENPIC_VENDOR_ID),
	    openpic_read(OPENPIC_FEATURE),
		openpic_big_endian ? "BE" : "LE" );

	openpic_set_priority(ci->ci_cpuid, 15);

	/* disable all interrupts */
	for (irq = 0; irq < openpic_numirq; irq++)
		openpic_write(OPENPIC_SRC_VECTOR(irq), OPENPIC_IMASK);

	for (i = 0; i < openpic_numirq; i++) {
		iq = &openpic_handler[i];
		TAILQ_INIT(&iq->iq_list);
	}

	/* we don't need 8259 pass through mode */
	x = openpic_read(OPENPIC_CONFIG);
	x |= OPENPIC_CONFIG_8259_PASSTHRU_DISABLE;
	openpic_write(OPENPIC_CONFIG, x);

	/* initialize all vectors to something sane */
	for (irq = 0; irq < ICU_LEN; irq++) {
		x = irq;
		x |= OPENPIC_IMASK;
		x |= OPENPIC_POLARITY_NEGATIVE;
		x |= OPENPIC_SENSE_LEVEL;
		x |= 8 << OPENPIC_PRIORITY_SHIFT;
		openpic_write(OPENPIC_SRC_VECTOR(irq), x);
	}

	/* send all interrupts to cpu 0 */
	for (irq = 0; irq < openpic_numirq; irq++)
		openpic_write(OPENPIC_IDEST(irq), 1 << 0);

	/* clear all pending interrunts */
	for (irq = 0; irq < ICU_LEN; irq++) {
		openpic_read_irq(ci->ci_cpuid);
		openpic_eoi(ci->ci_cpuid);
	}

#ifdef MULTIPROCESSOR
	/* Set up inter-processor interrupts. */
	/* IPI0 - NOP */
	x = IPI_VECTOR_NOP;
	x |= 15 << OPENPIC_PRIORITY_SHIFT;
	openpic_write(OPENPIC_IPI_VECTOR(0), x);
	/* IPI1 - DDB */
	x = IPI_VECTOR_DDB;
	x |= 15 << OPENPIC_PRIORITY_SHIFT;
	openpic_write(OPENPIC_IPI_VECTOR(1), x);

	evcount_attach(&ipi_count, "ipi", &ipi_irq);
#endif

	/* clear all pending interrunts */
	for (irq = 0; irq < ICU_LEN; irq++) {
		openpic_read_irq(0);
		openpic_eoi(0);
	}

#if 0
	openpic_write(OPENPIC_SPURIOUS_VECTOR, 255);
#endif

#if NHPB > 0
	/* Only U4 systems have a big-endian MPIC. */
	if (openpic_big_endian) {
		openpic_ops.acknowledge_irq = openpic_cpc945_acknowledge_irq;
		openpic_ops.enable_irq = openpic_cpc945_enable_irq;
		openpic_ops.disable_irq = openpic_cpc945_disable_irq;
	}
#endif

	install_extint(openpic_ext_intr);

	openpic_set_priority(ci->ci_cpuid, 0);

	intr_establish_func  = openpic_intr_establish;
	intr_disestablish_func = openpic_intr_disestablish;
#ifdef MULTIPROCESSOR
	intr_send_ipi_func = openpic_send_ipi;
#endif

	ppc_smask_init();

	openpic_collect_preconf_intr();

	evcount_attach(&openpic_spurious, "spurious", &openpic_spurious_irq);

	ppc_intr_func.raise = openpic_splraise;
	ppc_intr_func.lower = openpic_spllower;
	ppc_intr_func.x = openpic_splx;

	openpic_set_priority(0, ci->ci_cpl);

	ppc_intr_enable(1);

	printf("\n");
}

/* Must be called with interrupt disable. */
static inline void
openpic_setipl(int newcpl)
{
	struct cpu_info *ci = curcpu();

	ci->ci_cpl = newcpl;
	openpic_set_priority(ci->ci_cpuid, newcpl);
}

int
openpic_splraise(int newcpl)
{
	struct cpu_info *ci = curcpu();
	int ocpl = ci->ci_cpl;
	int s;

	newcpl = openpic_pri_share[newcpl];
	if (ocpl > newcpl)
		newcpl = ocpl;

	s = ppc_intr_disable();
	openpic_setipl(newcpl);
	ppc_intr_enable(s);

	return ocpl;
}

int
openpic_spllower(int newcpl)
{
	struct cpu_info *ci = curcpu();
	int ocpl = ci->ci_cpl;

	openpic_splx(newcpl);

	return ocpl;
}

void
openpic_splx(int newcpl)
{
	struct cpu_info *ci = curcpu();
	int intr, s;

	intr = ppc_intr_disable();
	openpic_setipl(newcpl);
	if (newcpl < IPL_SOFTTTY && (ci->ci_ipending & ppc_smask[newcpl])) {
		s = splsofttty();
		dosoftint(newcpl);
		openpic_setipl(s); /* no-overhead splx */
	}
	ppc_intr_enable(intr);
}

void
openpic_collect_preconf_intr()
{
	int i;
	for (i = 0; i < ppc_configed_intr_cnt; i++) {
		DPRINTF("\n\t%s irq %d level %d fun %p arg %p",
		    ppc_configed_intr[i].ih_what, ppc_configed_intr[i].ih_irq,
		    ppc_configed_intr[i].ih_level, ppc_configed_intr[i].ih_fun,
		    ppc_configed_intr[i].ih_arg);
		openpic_intr_establish(NULL, ppc_configed_intr[i].ih_irq,
		    IST_LEVEL, ppc_configed_intr[i].ih_level,
		    ppc_configed_intr[i].ih_fun, ppc_configed_intr[i].ih_arg,
		    ppc_configed_intr[i].ih_what);
	}
}

/*
 * Register an interrupt handler.
 */
void *
openpic_intr_establish(void *lcv, int irq, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, const char *name)
{
	struct intrhand *ih;
	struct intrq *iq;
	int s, flags;

	if (!LEGAL_IRQ(irq) || type == IST_NONE) {
		printf("%s: bogus irq %d or type %d", __func__, irq, type);
		return (NULL);
	}

	/* no point in sleeping unless someone can free memory. */
	ih = malloc(sizeof *ih, M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL)
		panic("%s: can't malloc handler info", __func__);

	iq = &openpic_handler[irq];
	switch (iq->iq_ist) {
	case IST_NONE:
		iq->iq_ist = type;
		break;
	case IST_EDGE:
		intr_shared_edge = 1;
		/* FALLTHROUGH */
	case IST_LEVEL:
		if (type == iq->iq_ist)
			break;
	case IST_PULSE:
		if (type != IST_NONE)
			panic("intr_establish: can't share %s with %s",
			    ppc_intr_typename(iq->iq_ist),
			    ppc_intr_typename(type));
		break;
	}

	flags = level & IPL_MPSAFE;
	level &= ~IPL_MPSAFE;

	KASSERT(level <= IPL_TTY || level >= IPL_CLOCK || flags & IPL_MPSAFE);

	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_level = level;
	ih->ih_flags = flags;
	ih->ih_irq = irq;

	evcount_attach(&ih->ih_count, name, &ih->ih_irq);

	/*
	 * Append handler to end of list
	 */
	s = ppc_intr_disable();

	TAILQ_INSERT_TAIL(&iq->iq_list, ih, ih_list);
	openpic_calc_mask();

	ppc_intr_enable(s);

	return (ih);
}

/*
 * Deregister an interrupt handler.
 */
void
openpic_intr_disestablish(void *lcp, void *arg)
{
	struct intrhand *ih = arg;
	int irq = ih->ih_irq;
	struct intrq *iq = &openpic_handler[irq];
	int s;

	if (!LEGAL_IRQ(irq)) {
		printf("%s: bogus irq %d", __func__, irq);
		return;
	}

	/*
	 * Remove the handler from the chain.
	 */
	s = ppc_intr_disable();

	TAILQ_REMOVE(&iq->iq_list, ih, ih_list);
	openpic_calc_mask();

	ppc_intr_enable(s);

	evcount_detach(&ih->ih_count);
	free(ih, M_DEVBUF, sizeof *ih);

	if (TAILQ_EMPTY(&iq->iq_list))
		iq->iq_ist = IST_NONE;
}

/*
 * Recalculate the interrupt masks from scratch.
 * We could code special registry and deregistry versions of this function that
 * would be faster, but the code would be nastier, and we don't expect this to
 * happen very much anyway.
 */

void
openpic_calc_mask()
{
	struct cpu_info *ci = curcpu();
	int irq;
	struct intrhand *ih;
	int i;

	/* disable all openpic interrupts */
	openpic_set_priority(ci->ci_cpuid, 15);

	for (i = IPL_NONE; i < IPL_NUM; i++) {
		openpic_pri_share[i] = i;
	}

	for (irq = 0; irq < openpic_numirq; irq++) {
		int maxipl = IPL_NONE;
		int minipl = IPL_HIGH;
		struct intrq *iq = &openpic_handler[irq];

		TAILQ_FOREACH(ih, &iq->iq_list, ih_list) {
			if (ih->ih_level > maxipl)
				maxipl = ih->ih_level;
			if (ih->ih_level < minipl)
				minipl = ih->ih_level;
		}

		if (maxipl == IPL_NONE) {
			minipl = IPL_NONE; /* Interrupt not enabled */

			openpic_disable_irq(irq, iq->iq_ist);
		} else {
			for (i = minipl; i <= maxipl; i++) {
				openpic_pri_share[i] = maxipl;
			}
			openpic_enable_irq(irq, iq->iq_ist, maxipl);
		}

		iq->iq_ipl = maxipl;
	}

	/* restore interrupts */
	openpic_set_priority(ci->ci_cpuid, ci->ci_cpl);
}

void
openpic_gen_acknowledge_irq(int irq, int cpuid)
{
	openpic_eoi(cpuid);
}

void
openpic_gen_enable_irq(int irq, int ist, int pri)
{
	u_int x;

	x = irq;

	if (ist == IST_LEVEL)
		x |= OPENPIC_SENSE_LEVEL;
	else
		x |= OPENPIC_SENSE_EDGE;
	x |= OPENPIC_POLARITY_NEGATIVE;
	x |= pri << OPENPIC_PRIORITY_SHIFT;
	openpic_write(OPENPIC_SRC_VECTOR(irq), x);
}

void
openpic_gen_disable_irq(int irq, int ist)
{
	u_int x;

	x = openpic_read(OPENPIC_SRC_VECTOR(irq));
	x |= OPENPIC_IMASK;
	openpic_write(OPENPIC_SRC_VECTOR(irq), x);
}

void
openpic_set_priority(int cpu, int pri)
{
	openpic_write(OPENPIC_CPU_PRIORITY(cpu), pri);
}

int openpic_irqnest[PPC_MAXPROCS];
int openpic_irqloop[PPC_MAXPROCS];

void
openpic_ext_intr(void)
{
	struct cpu_info *ci = curcpu();
	int irq, pcpl, ret;
	int maxipl = IPL_NONE;
	struct intrhand *ih;
	struct intrq *iq;
	int spurious;

	pcpl = ci->ci_cpl;

	openpic_irqloop[ci->ci_cpuid] = 0;
	irq = openpic_read_irq(ci->ci_cpuid);
	openpic_irqnest[ci->ci_cpuid]++;

	while (irq != 255) {
		openpic_irqloop[ci->ci_cpuid]++;
#ifdef OPENPIC_DEBUG
		if (openpic_irqloop[ci->ci_cpuid] > 20 ||
		    openpic_irqnest[ci->ci_cpuid] > 3) {
			printf("irqloop %d irqnest %d\n",
			    openpic_irqloop[ci->ci_cpuid],
			    openpic_irqnest[ci->ci_cpuid]);
		}
#endif
		if (openpic_irqloop[ci->ci_cpuid] > 20) {
			DPRINTF("irqloop %d irqnest %d: returning\n",
			    openpic_irqloop[ci->ci_cpuid],
			    openpic_irqnest[ci->ci_cpuid]);
			openpic_irqnest[ci->ci_cpuid]--;
			return;
		}
#ifdef MULTIPROCESSOR
		if (irq == IPI_VECTOR_NOP || irq == IPI_VECTOR_DDB) {
			ipi_count.ec_count++;
			openpic_eoi(ci->ci_cpuid);
			if (irq == IPI_VECTOR_DDB)
				openpic_ipi_ddb();
			irq = openpic_read_irq(ci->ci_cpuid);
			continue;
		}
#endif
		iq = &openpic_handler[irq];

#ifdef OPENPIC_DEBUG
		if (iq->iq_ipl <= pcpl)
			printf("invalid interrupt %d lvl %d at %d hw %d\n",
			    irq, iq->iq_ipl, pcpl,
			    openpic_read(OPENPIC_CPU_PRIORITY(ci->ci_cpuid)));
#endif

		if (iq->iq_ipl > maxipl)
			maxipl = iq->iq_ipl;
		openpic_splraise(iq->iq_ipl);
		openpic_acknowledge_irq(irq, ci->ci_cpuid);

		spurious = 1;
		TAILQ_FOREACH(ih, &iq->iq_list, ih_list) {
			ppc_intr_enable(1);
			ret = openpic_ext_intr_handler(ih, pcpl, &spurious);
			(void)ppc_intr_disable();
			if (intr_shared_edge == 00 && ret == 1)
				break;
 		}
		if (spurious) {
			openpic_spurious.ec_count++;
			DPRINTF("spurious intr %d\n", irq);
		}

		uvmexp.intrs++;
		openpic_setipl(pcpl);

		irq = openpic_read_irq(ci->ci_cpuid);
	}

	openpic_splx(pcpl);	/* Process pendings. */
	openpic_irqnest[ci->ci_cpuid]--;
}

int
openpic_ext_intr_handler(struct intrhand *ih, int pcpl, int *spurious)
{
	int ret;
#ifdef MULTIPROCESSOR
	int need_lock;

	if (ih->ih_flags & IPL_MPSAFE)
		need_lock = 0;
	else
		need_lock = pcpl < IPL_SCHED;

	if (need_lock)
		KERNEL_LOCK();
#endif

	ret = (*ih->ih_fun)(ih->ih_arg);
	if (ret) {
		ih->ih_count.ec_count++;
		*spurious = 0;
	}

#ifdef MULTIPROCESSOR
	if (need_lock)
		KERNEL_UNLOCK();
#endif

	return (ret);
}

void
openpic_acknowledge_irq(int irq, int cpuid)
{
	(openpic_ops.acknowledge_irq)(irq, cpuid);
}

void
openpic_enable_irq(int irq, int ist, int pri)
{
	(openpic_ops.enable_irq)(irq, ist, pri);
}

void
openpic_disable_irq(int irq, int ist)
{
	(openpic_ops.disable_irq)(irq, ist);
}

#ifdef MULTIPROCESSOR
void
openpic_send_ipi(struct cpu_info *ci, int id)
{
	switch (id) {
	case PPC_IPI_NOP:
		id = 0;
		break;
	case PPC_IPI_DDB:
		id = 1;
		break;
	default:
		panic("invalid ipi send to cpu %d %d", ci->ci_cpuid, id);
	}

	openpic_write(OPENPIC_IPI(curcpu()->ci_cpuid, id), 1 << ci->ci_cpuid);
}

void
openpic_ipi_ddb(void)
{
#ifdef DDB
	Debugger();
#endif
}
#endif /* MULTIPROCESSOR */

#if NHPB > 0
extern int	hpb_enable_irq(int, int);
extern int	hpb_disable_irq(int, int);
extern void	hpb_eoi(int);

void
openpic_cpc945_acknowledge_irq(int irq, int cpuid)
{
	hpb_eoi(irq);
	openpic_gen_acknowledge_irq(irq, cpuid);
}

void
openpic_cpc945_enable_irq(int irq, int ist, int pri)
{
	if (hpb_enable_irq(irq, ist)) {
		u_int x = irq;

		x |= OPENPIC_SENSE_EDGE;
		x |= OPENPIC_POLARITY_POSITIVE;
		x |= pri << OPENPIC_PRIORITY_SHIFT;
		openpic_write(OPENPIC_SRC_VECTOR(irq), x);

		hpb_eoi(irq);
	} else
		openpic_gen_enable_irq(irq, ist, pri);
}

void
openpic_cpc945_disable_irq(int irq, int ist)
{
	hpb_disable_irq(irq, ist);
	openpic_gen_disable_irq(irq, ist);
}
#endif /* NHPB */

@


1.82
log
@Use a single event counter for IPIs like other archs do.

Even if this counter is subject to trashing it is a simple solution
and gives an proximation "good enough" of the number of IPIs on Quad
CPUs machine.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.81 2015/06/24 11:58:06 mpi Exp $	*/
d502 1
a502 1
	free((void *)ih, M_DEVBUF, 0);
@


1.81
log
@IPL_MPSAFE bits for macppc with openpic(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.80 2015/06/02 13:53:43 mpi Exp $	*/
d133 1
a133 2
static struct evcount ipi_ddb[PPC_MAXPROCS];
static struct evcount ipi_nop[PPC_MAXPROCS];
d135 1
a135 2
static int ipi_nopirq = IPI_VECTOR_NOP;
static int ipi_ddbirq = IPI_VECTOR_DDB;
d289 1
a289 5
	/* XXX - ncpus */
	evcount_attach(&ipi_nop[0], "ipi_nop0", &ipi_nopirq);
	evcount_attach(&ipi_nop[1], "ipi_nop1", &ipi_nopirq);
	evcount_attach(&ipi_ddb[0], "ipi_ddb0", &ipi_ddbirq);
	evcount_attach(&ipi_ddb[1], "ipi_ddb1", &ipi_ddbirq);
d635 2
a636 2
		if (irq == IPI_VECTOR_NOP) {
			ipi_nop[ci->ci_cpuid].ec_count++;
d638 2
a639 7
			irq = openpic_read_irq(ci->ci_cpuid);
			continue;
		}
		if (irq == IPI_VECTOR_DDB) {
			ipi_ddb[ci->ci_cpuid].ec_count++;
			openpic_eoi(ci->ci_cpuid);
			openpic_ipi_ddb();
a749 1
	DPRINTF("ipi_ddb() called\n");
@


1.80
log
@Add a new HT-PCI bridge driver and the necessary glue to openpic(4)
to get interrupts working on U4 machines.

With this OpenBSD can run on PowerMac11,2 (Quad G5).

With inputs from and ok kettenis@@, miod@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.79 2015/04/02 11:22:48 mpi Exp $	*/
d102 1
d424 1
a424 1
	int s;
d435 1
a436 1

d455 5
d463 1
d657 2
a658 1
		if (iq->iq_ipl <= ci->ci_cpl)
d660 1
a660 1
			    irq, iq->iq_ipl, ci->ci_cpl,
d662 2
d672 1
a672 8
			KERNEL_LOCK();
			ret = (*ih->ih_fun)(ih->ih_arg);
			if (ret) {
				ih->ih_count.ec_count++;
				spurious = 0;
 			}
			KERNEL_UNLOCK();

d690 30
@


1.79
log
@Merge openpic_init() into openpic_attach(), no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.78 2015/04/02 11:12:24 mpi Exp $	*/
d40 2
d46 1
a48 1
#include <ddb/db_var.h>
d90 5
a94 2
void	openpic_enable_irq(int, int);
void	openpic_disable_irq(int);
d99 1
a99 1
void	openpic_intr_disestablish( void *lcp, void *arg);
d103 22
d154 1
a154 1
	asm volatile("eieio"::: "memory");
d170 1
a170 1
	asm volatile("eieio"::: "memory");
d213 1
a213 1
openpic_attach(struct device *parent, struct device  *self, void *aux)
d228 7
d307 9
d321 1
a321 1
	intr_disestablish_func  = openpic_intr_disestablish;
d544 1
a544 1
			openpic_disable_irq(irq);
d549 1
a549 1
			openpic_enable_irq(irq, maxipl);
d560 7
a566 1
openpic_enable_irq(int irq, int pri)
a568 1
	struct intrq *iq = &openpic_handler[irq];
d571 2
a572 1
	if (iq->iq_ist == IST_LEVEL)
d582 1
a582 1
openpic_disable_irq(int irq)
a596 20
#ifdef MULTIPROCESSOR
void
openpic_send_ipi(struct cpu_info *ci, int id)
{
	switch (id) {
	case PPC_IPI_NOP:
		id = 0;
		break;
	case PPC_IPI_DDB:
		id = 1;
		break;
	default:
		panic("invalid ipi send to cpu %d %d", ci->ci_cpuid, id);
	}

	openpic_write(OPENPIC_IPI(curcpu()->ci_cpuid, id), 1 << ci->ci_cpuid);
}

#endif

d599 1
d601 1
a601 1
openpic_ext_intr()
d657 1
a657 1
		openpic_eoi(ci->ci_cpuid);
d689 18
d709 18
a726 1
openpic_ipi_ddb()
d734 37
@


1.78
log
@One function pointer per pic function is enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.77 2015/04/02 10:58:20 mpi Exp $	*/
a89 1
void	openpic_init(void);
d190 4
a193 1
	u_int32_t reg;
a194 1
	reg = 0;
d209 67
a275 1
	openpic_init();
a656 78
}

void
openpic_init()
{
	struct cpu_info *ci = curcpu();
	struct intrq *iq;
	int irq;
	u_int x;
	int i;

	openpic_set_priority(ci->ci_cpuid, 15);

	/* disable all interrupts */
	for (irq = 0; irq < openpic_numirq; irq++)
		openpic_write(OPENPIC_SRC_VECTOR(irq), OPENPIC_IMASK);

	for (i = 0; i < openpic_numirq; i++) {
		iq = &openpic_handler[i];
		TAILQ_INIT(&iq->iq_list);
	}

	/* we don't need 8259 pass through mode */
	x = openpic_read(OPENPIC_CONFIG);
	x |= OPENPIC_CONFIG_8259_PASSTHRU_DISABLE;
	openpic_write(OPENPIC_CONFIG, x);

	/* initialize all vectors to something sane */
	for (irq = 0; irq < ICU_LEN; irq++) {
		x = irq;
		x |= OPENPIC_IMASK;
		x |= OPENPIC_POLARITY_NEGATIVE;
		x |= OPENPIC_SENSE_LEVEL;
		x |= 8 << OPENPIC_PRIORITY_SHIFT;
		openpic_write(OPENPIC_SRC_VECTOR(irq), x);
	}

	/* send all interrupts to cpu 0 */
	for (irq = 0; irq < openpic_numirq; irq++)
		openpic_write(OPENPIC_IDEST(irq), 1 << 0);

	/* clear all pending interrunts */
	for (irq = 0; irq < ICU_LEN; irq++) {
		openpic_read_irq(ci->ci_cpuid);
		openpic_eoi(ci->ci_cpuid);
	}

#ifdef MULTIPROCESSOR
	/* Set up inter-processor interrupts. */
	/* IPI0 - NOP */
	x = IPI_VECTOR_NOP;
	x |= 15 << OPENPIC_PRIORITY_SHIFT;
	openpic_write(OPENPIC_IPI_VECTOR(0), x);
	/* IPI1 - DDB */
	x = IPI_VECTOR_DDB;
	x |= 15 << OPENPIC_PRIORITY_SHIFT;
	openpic_write(OPENPIC_IPI_VECTOR(1), x);

	/* XXX - ncpus */
	evcount_attach(&ipi_nop[0], "ipi_nop0", &ipi_nopirq);
	evcount_attach(&ipi_nop[1], "ipi_nop1", &ipi_nopirq);
	evcount_attach(&ipi_ddb[0], "ipi_ddb0", &ipi_ddbirq);
	evcount_attach(&ipi_ddb[1], "ipi_ddb1", &ipi_ddbirq);
#endif

	/* clear all pending interrunts */
	for (irq = 0; irq < ICU_LEN; irq++) {
		openpic_read_irq(0);
		openpic_eoi(0);
	}

#if 0
	openpic_write(OPENPIC_SPURIOUS_VECTOR, 255);
#endif

	install_extint(openpic_ext_intr);

	openpic_set_priority(ci->ci_cpuid, 0);
@


1.77
log
@Cleanup function definitions, use only one define for DEBUG and remove
unused headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.76 2015/01/04 13:01:42 mpi Exp $	*/
a211 2
	mac_intr_establish_func  = openpic_intr_establish;
	mac_intr_disestablish_func  = openpic_intr_disestablish;
@


1.76
log
@Implement splassert(9) for powerpc.

This changes the logic to prevent a recursion when processing soft
interrupts.  Previously a per-CPU flag was set before re-enabling
interrupts.  Now the IPL level is raised to SOFTTTY which makes
splsoftassert() happy, greatly inspired by mips64.

As a side effect, the ppc_intr_{disable,enable}() dance is now done
only once instead of twice per splx(9).

While here, make use of dosoftint() instead of having 3 different
functions for dispatching soft interrupts.

Tested by deraadt@@ on G4 smp and by myself G5 smp, G3, G4 and socppc.

No objection from the usual (and over busy) suspects.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.75 2014/10/08 22:24:26 deraadt Exp $	*/
a47 1
#include <machine/atomic.h>
d56 6
d70 3
a72 1
void openpic_calc_mask(void);
d74 4
a77 3
ppc_splraise_t openpic_splraise;
ppc_spllower_t openpic_spllower;
ppc_splx_t openpic_splx;
d79 6
a84 11
/* IRQ vector used for inter-processor interrupts. */
#define IPI_VECTOR_NOP	64
#define IPI_VECTOR_DDB	65
#ifdef MULTIPROCESSOR
static struct evcount ipi_ddb[PPC_MAXPROCS];
static struct evcount ipi_nop[PPC_MAXPROCS];
static int ipi_nopirq = IPI_VECTOR_NOP;
static int ipi_ddbirq = IPI_VECTOR_DDB;
#endif
struct evcount openpic_spurious;
int openpic_spurious_irq = 255;
d86 2
d91 1
d93 2
a94 8
void	openpic_ipi_ddb(void);
void	*openpic_intr_establish(void *, int, int, int, int (*)(void *),
    void *, const char *);

typedef void  (void_f) (void);
extern void_f *pending_int_f;

vaddr_t openpic_base;
d97 2
a98 1
int	openpic_big_endian;
d100 1
a100 2
intr_send_ipi_t openpic_send_ipi;
#endif
d102 3
a104 2
u_int openpic_read(int reg);
void openpic_write(int reg, u_int val);
d106 5
a110 3
struct openpic_softc {
	struct device sc_dev;
};
d112 2
a113 4
int	openpic_match(struct device *parent, void *cf, void *aux);
void	openpic_attach(struct device *, struct device *, void *);
void	openpic_collect_preconf_intr(void);
void	openpic_ext_intr(void);
d115 2
a116 4
struct cfattach openpic_ca = {
	sizeof(struct openpic_softc),
	openpic_match,
	openpic_attach
d295 1
a295 2
#ifdef DEBUG
		printf("\n\t%s irq %d level %d fun %x arg %x",
a298 1
#endif
d497 1
a497 1
		
d523 1
a523 1
#ifdef DEBUG
d532 1
a532 2
#ifdef DEBUG
			printf("irqloop %d irqnest %d: returning\n",
a534 1
#endif
d581 1
a581 3
#ifdef OPENPIC_NOISY
			printf("spurious intr %d\n", irq);
#endif
d672 1
d676 1
a676 3
#ifdef OPENPIC_NOISY
	printf("ipi_ddb() called\n");
#endif
d681 1
@


1.75
log
@only call Debugger() #ifdef DDB
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.74 2014/09/06 10:45:29 mpi Exp $	*/
a110 2
void	openpic_do_pending_int(int pcpl);
void	openpic_do_pending_int_dis(int pcpl, int s);
d236 1
d241 1
a241 3
	int s;
	/* XXX - try do to this without the disable */
	s = ppc_intr_disable();
a243 1
	ppc_intr_enable(s);
d250 3
a253 1
	int ocpl = ci->ci_cpl;
d257 1
d259 1
d278 11
a288 1
	openpic_do_pending_int(newcpl);
a454 65
openpic_do_pending_int(int pcpl)
{
	int s;
	s = ppc_intr_disable();
	openpic_do_pending_int_dis(pcpl, s);
	ppc_intr_enable(s);

}

/*
 * This function expect interrupts disabled on entry and exit,
 * the s argument indicates if interrupts may be enabled during
 * the processing of off level interrupts, s 'should' always be 1.
 */
void
openpic_do_pending_int_dis(int pcpl, int s)
{
	struct cpu_info *ci = curcpu();

	(void)ppc_intr_disable();
	if (ci->ci_flags & CI_FLAGS_PROCESSING_SOFT) {
		/* soft interrupts are being processed, just set ipl/return */
		openpic_setipl(pcpl);
		ppc_intr_enable(s);
		return;
	}

	atomic_setbits_int(&ci->ci_flags, CI_FLAGS_PROCESSING_SOFT);

	do {
		if ((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTCLOCK)) &&
		    (pcpl < IPL_SOFTCLOCK)) {
 			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTCLOCK);
			ppc_intr_enable(1);
			KERNEL_LOCK();
			softintr_dispatch(SI_SOFTCLOCK);
			KERNEL_UNLOCK();
			(void)ppc_intr_disable();
 		}
		if ((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTNET)) &&
		    (pcpl < IPL_SOFTNET)) {
			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTNET);
			ppc_intr_enable(1);
			KERNEL_LOCK();
			softintr_dispatch(SI_SOFTNET);
			KERNEL_UNLOCK();
			(void)ppc_intr_disable();
		}
		if ((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTTTY)) &&
		    (pcpl < IPL_SOFTTTY)) {
			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTTTY);
			ppc_intr_enable(1);
			KERNEL_LOCK();
			softintr_dispatch(SI_SOFTTTY);
			KERNEL_UNLOCK();
			(void)ppc_intr_disable();
		}
	} while (ci->ci_ipending & ppc_smask[pcpl]);
	openpic_setipl(pcpl);	/* Don't use splx... we are here already! */

	atomic_clearbits_int(&ci->ci_flags, CI_FLAGS_PROCESSING_SOFT);
	ppc_intr_enable(s);
}

void
d566 1
a566 1
		splraise(iq->iq_ipl);
d597 1
a597 8
	/*
	 * sending 0 in to openpic_do_pending_int_dis will leave
	 * external interrupts disabled, but since we are about
	 * to return from interrupt leaving them disabled until then
	 * prevents additional recursion.
	 */
	openpic_do_pending_int_dis(pcpl, 0);

@


1.74
log
@Rename ci_iactive into ci_flags, this field now holds the going-to-
sleep bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.73 2014/08/30 09:42:20 mpi Exp $	*/
d747 1
d749 1
@


1.73
log
@Don't panic when an illegal IRQ is passed to intr_{dis,}establish().

At least the device-tree for the second bge(4) on my PowerMac is not
parsed correctly but we can live with that until the bug is fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.72 2014/07/12 18:44:42 tedu Exp $	*/
d465 1
a465 1
	if (ci->ci_iactive & CI_IACTIVE_PROCESSING_SOFT) {
d472 1
a472 1
	atomic_setbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_SOFT);
d505 1
a505 1
	atomic_clearbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_SOFT);
@


1.72
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.71 2014/04/01 20:27:14 mpi Exp $	*/
d310 5
d318 1
a318 1
		panic("intr_establish: can't malloc handler info");
a320 3
	if (!LEGAL_IRQ(irq) || type == IST_NONE)
		panic("intr_establish: bogus irq or type");

d370 4
a373 2
	if (!LEGAL_IRQ(irq))
		panic("intr_disestablish: bogus irq");
@


1.71
log
@Remove the almost unused abstraction around "struct firmware" and use
instead a single function ppc_mem_regions() required by the ppc pmap.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.70 2014/03/31 18:58:41 mpi Exp $	*/
d382 1
a382 1
	free((void *)ih, M_DEVBUF);
@


1.70
log
@Including <uvm/uvm_extern.h> is enough, no need for <uvm/uvm.h> or more.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.69 2012/10/08 20:06:37 deraadt Exp $	*/
d53 2
a54 1
#include <machine/powerpc.h>
a55 1
#include <dev/ofw/openfirm.h>
@


1.69
log
@push irqloop warnings into #ifdef DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.68 2011/10/28 15:18:51 drahn Exp $	*/
a41 3
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
d43 1
d45 1
a45 1
#include <uvm/uvm.h>
@


1.68
log
@Enable interrupts while processing off level interrupts. simplify code
instead of having two levels of looping.
commit it for testing  deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.67 2011/10/24 13:01:07 drahn Exp $	*/
d579 1
d586 1
d588 1
d592 1
@


1.67
log
@Revert last change, reported increased stablility with the change was
grossly overstated.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.65 2011/08/29 20:21:44 drahn Exp $	*/
d462 1
d466 1
d476 2
d479 2
d485 2
d488 2
d494 2
d497 2
d504 1
d585 7
d646 8
a653 30
	if (openpic_irqnest[ci->ci_cpuid] == 1) {
		openpic_irqloop[ci->ci_cpuid] = 0;
		/* raise IPL back to max until do_pending will lower it back */
		openpic_setipl(maxipl);
		/*
		 * we must not process pending soft interrupts when nested, can
		 * cause excessive recursion.
		 * 
		 * The loop here is because an interrupt could case a pending
		 * soft interrupt between the finishing of the
		 * openpic_do_pending_int, but before ppc_intr_disable
		 */
		do {
			openpic_irqloop[ci->ci_cpuid]++;
			if (openpic_irqloop[ci->ci_cpuid] > 5) {
				printf("ext_intr: do_pending loop %d\n",
				    openpic_irqloop[ci->ci_cpuid]);
			}
			if (ci->ci_iactive & CI_IACTIVE_PROCESSING_SOFT) {
				openpic_setipl(pcpl);
				/*
				 * some may be pending but someone else is
				 * processing them
				 */
				break;
			} else {
				openpic_do_pending_int_dis(pcpl, 1);
			}
		} while (ci->ci_ipending & ppc_smask[pcpl]);
	}
@


1.66
log
@Do not run off level interrupts with external interrupts disabled as
the off level interrupt could lead to a hang. Fixes hang seen by jasper@@
@
text
@d114 1
d445 15
d462 8
a473 1
			openpic_setipl(IPL_SOFTCLOCK);
a478 1
			openpic_setipl(IPL_SOFTNET);
a483 1
			openpic_setipl(IPL_SOFTTTY);
d488 2
d650 1
a650 1
				openpic_do_pending_int(pcpl);
@


1.65
log
@Return of the long missing powerpc interrupt rewrite.  Was working for
several weeks before release on macppc, socppc bugs just fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.64 2011/04/15 20:52:55 deraadt Exp $	*/
a113 1
void	openpic_do_pending_int_dis(int pcpl, int s);
a443 15
	int s;
	s = ppc_intr_disable();
	openpic_do_pending_int_dis(pcpl, s);
	ppc_intr_enable(s);

}

/*
 * This function expect interrupts disabled on entry and exit,
 * the s argument indicates if interrupts may be enabled during
 * the processing of off level interrupts, s 'should' always be 1.
 */
void
openpic_do_pending_int_dis(int pcpl, int s)
{
a445 8
	if (ci->ci_iactive & CI_IACTIVE_PROCESSING_SOFT) {
		/* soft interrupts are being processed, just set ipl/return */
		openpic_setipl(pcpl);
		return;
	}

	atomic_setbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_SOFT);

d447 1
a447 1
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTCLOCK)) &&
d450 1
d453 1
a453 1
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTNET)) &&
d456 1
d459 1
a459 1
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTTTY)) &&
d462 1
a466 2

	atomic_clearbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_SOFT);
d627 1
a627 1
				openpic_do_pending_int_dis(pcpl, 1);
@


1.64
log
@More than a decade ago, interrupt handlers on sparc started returning 0
(interrupt was not for me), 1 (positive interrupt was for me), or -1
(i am not sure...).  We have continued with this practice in as many
drivers as possible, throughout the tree.

This makes some of the architectures use that information in their
interrupt handler calling code -- if 1 is returned (and we know
this specific machine does not have edge-shared interrupts), we
finish servicing other possible handlers on the same pin.  If the
interrupt pin remains asserted (from a different device), we will
end up back in the interrupt servicing code of course... but this is
cheaper than calling all the chained interrupts on a pin.

This does of course count on shared level interrupts being properly
sorted by IPL.

There have been some concerns about starvation of drivers which
incorrectly return 1.  Those drivers should be hunted down so that
they return -1.

ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.63 2011/01/08 18:10:22 deraadt Exp $	*/
d4 1
d60 1
d63 3
a65 4
int o_intrtype[ICU_LEN], o_intrmaxlvl[ICU_LEN];
struct intrhand *o_intrhand[ICU_LEN] = { 0 };
int o_hwirq[ICU_LEN], o_virq[ICU_LEN];
int o_virq_max;
a66 2
static int fakeintr(void *);
static char *intr_typename(int type);
a67 3
static __inline int cntlzw(int x);
static int mapirq(int irq);
void openpic_enable_irq_mask(int irq_mask);
d69 3
a71 2
#define HWIRQ_MAX (31 - (SI_NQUEUES + 1))
#define HWIRQ_MASK (0xffffffff >> (SI_NQUEUES + 1))
d82 21
d104 2
a105 10
static __inline u_int openpic_read(int);
static __inline void openpic_write(int, u_int);
void openpic_set_enable_irq(int, int);
void openpic_enable_irq(int);
void openpic_disable_irq(int);
void openpic_init(void);
void openpic_set_priority(int, int);
void openpic_ipi_ddb(void);
static __inline int openpic_read_irq(int);
static __inline void openpic_eoi(int);
d113 2
a114 1
void	openpic_do_pending_int(void);
d116 1
a116 1
void	ext_intr_openpic(void);
d128 36
a190 13
typedef void  (void_f) (void);
extern void_f *pending_int_f;

vaddr_t openpic_base;
void * openpic_intr_establish( void * lcv, int irq, int type, int level,
	int (*ih_fun)(void *), void *ih_arg, const char *name);
void openpic_intr_disestablish( void *lcp, void *arg);
#ifdef MULTIPROCESSOR
intr_send_ipi_t openpic_send_ipi;
#endif
void openpic_collect_preconf_intr(void);
int openpic_big_endian;

d194 1
d205 7
a211 2
	printf(": version 0x%x %s endian", openpic_read(OPENPIC_VENDOR_ID),
		openpic_big_endian ? "big" : "little" );
a214 1
	pending_int_f = openpic_do_pending_int;
a221 1
	install_extint(ext_intr_openpic);
d223 2
a224 1
#if 1
d226 8
a233 1
#endif
d240 20
d261 21
a300 7
static int
fakeintr(void *arg)
{

	return 0;
}

d308 3
a310 14
	struct intrhand **p, *q, *ih;
	static struct intrhand fakehand;

	fakehand.ih_next = NULL;
	fakehand.ih_fun  = fakeintr;

#if 0
printf("mac_intr_establish, hI %d L %d ", irq, type);
#endif

	irq = mapirq(irq);
#if 0
printf("vI %d ", irq);
#endif
d316 1
d321 1
a321 1
	switch (o_intrtype[irq]) {
d323 1
a323 1
		o_intrtype[irq] = type;
d329 1
a329 1
		if (type == o_intrtype[irq])
d334 2
a335 2
			    intr_typename(o_intrtype[irq]),
			    intr_typename(type));
d339 6
a344 7
	/*
	 * Figure out where to put the handler.
	 * This is O(N^2), but we want to preserve the order, and N is
	 * generally small.
	 */
	for (p = &o_intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
		;
d347 1
a347 3
	 * Actually install a fake handler momentarily, since we might be doing
	 * this with interrupts enabled and DON'T WANt the real routine called
	 * until masking is set up.
d349 1
a349 2
	fakehand.ih_level = level;
	*p = &fakehand;
d351 1
d354 1
a354 10
	/*
	 * Poke the real handler in now.
	 */
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_next = NULL;
	ih->ih_level = level;
	ih->ih_irq = irq;
	evcount_attach(&ih->ih_count, name, &o_hwirq[irq]);
	*p = ih;
d367 2
a368 1
	struct intrhand **p, *q;
a374 1
	 * This is O(n^2), too.
d376 1
a376 9
	for (p = &o_intrhand[irq]; (q = *p) != NULL && q != ih; p = &q->ih_next)
		;
	if (q)
		*p = q->ih_next;
	else
		panic("intr_disestablish: handler not registered");

	evcount_detach(&ih->ih_count);
	free((void *)ih, M_DEVBUF);
d378 1
d381 1
a381 3
	if (o_intrhand[irq] == NULL)
		o_intrtype[irq] = IST_NONE;
}
d383 2
d386 2
a387 19
static char *
intr_typename(int type)
{

	switch (type) {
	case IST_NONE:
		return ("none");
	case IST_PULSE:
		return ("pulsed");
	case IST_EDGE:
		return ("edge-triggered");
	case IST_LEVEL:
		return ("level-triggered");
	default:
		panic("intr_typename: invalid type %d", type);
#if 1 /* XXX */
		return ("unknown");
#endif
	}
d400 1
d406 1
a406 1
	openpic_set_priority(0, 15);
d408 14
a421 12
	for (irq = 0; irq < ICU_LEN; irq++) {
		int max = IPL_NONE;
		int min = IPL_HIGH;
		int reg;
		if (o_virq[irq] != 0) {
			for (ih = o_intrhand[o_virq[irq]]; ih;
			    ih = ih->ih_next) {
				if (ih->ih_level > max)
					max = ih->ih_level;
				if (ih->ih_level < min)
					min = ih->ih_level;
			}
d424 2
a425 1
		o_intrmaxlvl[irq] = max;
d427 6
a432 6
		/* adjust priority if it changes */
		reg = openpic_read(OPENPIC_SRC_VECTOR(irq));
		if (max != ((reg >> OPENPIC_PRIORITY_SHIFT) & 0xf)) {
			openpic_write(OPENPIC_SRC_VECTOR(irq),
				(reg & ~(0xf << OPENPIC_PRIORITY_SHIFT)) |
				(max << OPENPIC_PRIORITY_SHIFT) );
d435 1
a435 10
		if (max == IPL_NONE)
			min = IPL_NONE; /* Interrupt not enabled */

		if (o_virq[irq] != 0) {
			/* Enable (dont mask) interrupts at lower levels */ 
			for (i = IPL_NONE; i < min; i++)
				cpu_imask[i] &= ~(1 << o_virq[irq]);
			for (; i <= IPL_HIGH; i++)
				cpu_imask[i] |= (1 << o_virq[irq]);
		}
d439 1
a439 9
	openpic_set_priority(0, 0);

	for (i = IPL_NONE; i <= IPL_HIGH; i++) {
		if (i > IPL_NONE)
			cpu_imask[i] |= SINT_ALLMASK;
		if (i >= IPL_CLOCK)
			cpu_imask[i] |= SPL_CLOCKMASK;
	}
	cpu_imask[IPL_HIGH] = 0xffffffff;
d442 2
a443 5
/*
 * Map 64 irqs into 32 (bits).
 */
static int
mapirq(int irq)
d445 4
a448 5
	int v;

	/* irq in table already? */
	if (o_virq[irq] != 0)
		return o_virq[irq];
a449 15
	if (irq < 0 || irq >= ICU_LEN)
		panic("invalid irq %d", irq);

	o_virq_max++;
	v = o_virq_max;
	if (v > HWIRQ_MAX)
		panic("virq overflow");

	o_hwirq[v] = irq;
	o_virq[irq] = v;
#if 0
printf("\nmapirq %x to %x\n", irq, v);
#endif

	return v;
d453 3
a455 1
 * Count leading zeros.
a456 12
static __inline int
cntlzw(int x)
{
	int a;

	__asm __volatile ("cntlzw %0,%1" : "=r"(a) : "r"(x));

	return a;
}

void openpic_do_pending_softint(int pcpl);

d458 1
a458 1
openpic_do_pending_int()
a460 6
	struct intrhand *ih;
	int irq;
	int pcpl;
	int hwpend;
	int pri, pripending;
	int s;
d462 3
a464 1
	if (ci->ci_iactive & CI_IACTIVE_PROCESSING_HARD)
a465 33

	atomic_setbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_HARD);
	s = ppc_intr_disable();
	pcpl = ci->ci_cpl;

	hwpend = ci->ci_ipending & ~pcpl;	/* Do now unmasked pendings */
	hwpend &= HWIRQ_MASK;
	while (hwpend) {
		/* this still doesn't handle the interrupts in priority order */
		for (pri = IPL_HIGH; pri >= IPL_NONE; pri--) {
			pripending = hwpend & ~cpu_imask[pri];
			if (pripending == 0)
				continue;
			irq = 31 - cntlzw(pripending);
			ci->ci_ipending &= ~(1 << irq);
			ci->ci_cpl = cpu_imask[o_intrmaxlvl[o_hwirq[irq]]];
			openpic_enable_irq_mask(~ci->ci_cpl);
			ih = o_intrhand[irq];
			while(ih) {
				ppc_intr_enable(1);

				KERNEL_LOCK();
				if ((*ih->ih_fun)(ih->ih_arg))
					ih->ih_count.ec_count++;
				KERNEL_UNLOCK();

				(void)ppc_intr_disable();
				
				ih = ih->ih_next;
			}
		}
		hwpend = ci->ci_ipending & ~pcpl;/* Catch new pendings */
		hwpend &= HWIRQ_MASK;
a466 16
	ci->ci_cpl = pcpl | SINT_ALLMASK;
	openpic_enable_irq_mask(~ci->ci_cpl);
	atomic_clearbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_HARD);

	openpic_do_pending_softint(pcpl);

	ppc_intr_enable(s);
}

void
openpic_do_pending_softint(int pcpl)
{
	struct cpu_info *ci = curcpu();

	if (ci->ci_iactive & CI_IACTIVE_PROCESSING_SOFT)
		return;
d471 3
a473 4
		if((ci->ci_ipending & SINT_CLOCK) & ~pcpl) {
			ci->ci_ipending &= ~SINT_CLOCK;
			ci->ci_cpl = SINT_CLOCK|SINT_NET|SINT_TTY;
			ppc_intr_enable(1);
d475 4
a478 7
			ppc_intr_disable();
			continue;
		}
		if((ci->ci_ipending & SINT_NET) & ~pcpl) {
			ci->ci_ipending &= ~SINT_NET;
			ci->ci_cpl = SINT_NET|SINT_TTY;
			ppc_intr_enable(1);
a479 2
			ppc_intr_disable();
			continue;
d481 3
a483 4
		if((ci->ci_ipending & SINT_TTY) & ~pcpl) {
			ci->ci_ipending &= ~SINT_TTY;
			ci->ci_cpl = SINT_TTY;
			ppc_intr_enable(1);
a484 2
			ppc_intr_disable();
			continue;
d486 2
a487 2
	} while ((ci->ci_ipending & SINT_ALLMASK) & ~pcpl);
	ci->ci_cpl = pcpl;	/* Don't use splx... we are here already! */
a491 11
u_int
openpic_read(int reg)
{
	char *addr = (void *)(openpic_base + reg);

	if (openpic_big_endian)
		return in32(addr);
	else
		return in32rb(addr);
}

d493 1
a493 24
openpic_write(int reg, u_int val)
{
	char *addr = (void *)(openpic_base + reg);

	if (openpic_big_endian)
		out32(addr, val);
	else
		out32rb(addr, val);
}

void
openpic_enable_irq_mask(int irq_mask)
{
	int irq;
	for ( irq = 0; irq <= o_virq_max; irq++) {
		if (irq_mask & (1 << irq))
			openpic_enable_irq(o_hwirq[irq]);
		else
			openpic_disable_irq(o_hwirq[irq]);
	}
}

void
openpic_set_enable_irq(int irq, int type)
d496 1
d498 2
a499 16
	x = openpic_read(OPENPIC_SRC_VECTOR(irq));
	x &= ~(OPENPIC_IMASK|OPENPIC_SENSE_LEVEL|OPENPIC_SENSE_EDGE);
	if (type == IST_LEVEL)
		x |= OPENPIC_SENSE_LEVEL;
	else
		x |= OPENPIC_SENSE_EDGE;
	openpic_write(OPENPIC_SRC_VECTOR(irq), x);
}
void
openpic_enable_irq(int irq)
{
	u_int x;

	x = openpic_read(OPENPIC_SRC_VECTOR(irq));
	x &= ~(OPENPIC_IMASK|OPENPIC_SENSE_LEVEL|OPENPIC_SENSE_EDGE);
	if (o_intrtype[o_virq[irq]] == IST_LEVEL)
d503 2
d521 1
a521 19
	u_int x;

	x = openpic_read(OPENPIC_CPU_PRIORITY(cpu));
	x &= ~OPENPIC_CPU_PRIORITY_MASK;
	x |= pri;
	openpic_write(OPENPIC_CPU_PRIORITY(cpu), x);
}

int
openpic_read_irq(int cpu)
{
	return openpic_read(OPENPIC_IACK(cpu)) & OPENPIC_VECTOR_MASK;
}

void
openpic_eoi(int cpu)
{
	openpic_write(OPENPIC_EOI(cpu), 0);
	openpic_read(OPENPIC_EOI(cpu));
a524 1

a538 1
		
d544 2
d547 1
a547 1
ext_intr_openpic()
d550 2
a551 3
	int irq, realirq;
	int r_imen, ret;
	int pcpl, ocpl;
d553 2
d558 12
a569 3
	realirq = openpic_read_irq(ci->ci_cpuid);

	while (realirq != 255) {
d571 1
a571 1
		if (realirq == IPI_VECTOR_NOP) {
d574 1
a574 1
			realirq = openpic_read_irq(ci->ci_cpuid);
d577 1
a577 1
		if (realirq == IPI_VECTOR_DDB) {
d581 1
a581 1
			realirq = openpic_read_irq(ci->ci_cpuid);
d585 1
d587 8
a594 1
		irq = o_virq[realirq];
d596 21
a616 1
		/* XXX check range */
d618 2
a619 1
		r_imen = 1 << irq;
d621 2
a622 9
		if ((pcpl & r_imen) != 0) {
			/* Masked! Mark this as pending. */
			ci->ci_ipending |= r_imen;
			openpic_enable_irq_mask(~cpu_imask[o_intrmaxlvl[realirq]]);
			openpic_eoi(ci->ci_cpuid);
		} else {
			openpic_enable_irq_mask(~cpu_imask[o_intrmaxlvl[realirq]]);
			openpic_eoi(ci->ci_cpuid);
			ocpl = splraise(cpu_imask[o_intrmaxlvl[realirq]]);
d624 17
a640 14
			ih = o_intrhand[irq];
			while (ih) {
				ppc_intr_enable(1);

				KERNEL_LOCK();
				ret = (*ih->ih_fun)(ih->ih_arg);
				if (ret)
					ih->ih_count.ec_count++;
				KERNEL_UNLOCK();

				(void)ppc_intr_disable();
				if (intr_shared_edge == 00 && ret == 1)
					break;
				ih = ih->ih_next;
d642 11
a652 9

			uvmexp.intrs++;
			__asm__ volatile("":::"memory"); /* don't reorder.... */
			ci->ci_cpl = ocpl;
			__asm__ volatile("":::"memory"); /* don't reorder.... */
			openpic_enable_irq_mask(~pcpl);
		}

		realirq = openpic_read_irq(ci->ci_cpuid);
d654 1
a654 3
	ppc_intr_enable(1);

	splx(pcpl);	/* Process pendings. */
d660 2
d664 3
d669 1
a669 1
	for (irq = 0; irq < 255; irq++)
d671 5
a675 1
	openpic_set_priority(0, 15);
d682 1
a682 3
	/* send all interrupts to cpu 0 */
	for (irq = 0; irq < ICU_LEN; irq++)
		openpic_write(OPENPIC_IDEST(irq), 1 << 0);
d686 1
a686 1
		x |= OPENPIC_POLARITY_POSITIVE;
d692 10
d705 2
a706 3
	x = openpic_read(OPENPIC_IPI_VECTOR(0));
	x &= ~(OPENPIC_IMASK | OPENPIC_PRIORITY_MASK | OPENPIC_VECTOR_MASK);
	x |= (15 << OPENPIC_PRIORITY_SHIFT) | IPI_VECTOR_NOP;
d709 2
a710 3
	x = openpic_read(OPENPIC_IPI_VECTOR(1));
	x &= ~(OPENPIC_IMASK | OPENPIC_PRIORITY_MASK | OPENPIC_VECTOR_MASK);
	x |= (15 << OPENPIC_PRIORITY_SHIFT) | IPI_VECTOR_DDB;
d713 1
a719 4
	/* XXX set spurious intr vector */

	openpic_set_priority(0, 0);

d726 5
a730 2
	for (irq = 0; irq < ICU_LEN; irq++)
		openpic_disable_irq(irq);
d732 1
a732 1
	install_extint(ext_intr_openpic);
d736 1
a736 1
openpic_ipi_ddb(void)
d738 3
a742 1

@


1.63
log
@rename imask[] to cpu_imask[] to because imask is too loud as far as
kernel namespace
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.62 2010/09/20 06:33:47 matthew Exp $	*/
d256 2
d684 1
a684 1
	int r_imen;
d730 2
a731 1
				if ((*ih->ih_fun)(ih->ih_arg))
d736 2
@


1.62
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.61 2010/08/07 03:50:01 krw Exp $	*/
d401 1
a401 1
				imask[i] &= ~(1 << o_virq[irq]);
d403 1
a403 1
				imask[i] |= (1 << o_virq[irq]);
d412 1
a412 1
			imask[i] |= SINT_ALLMASK;
d414 1
a414 1
			imask[i] |= SPL_CLOCKMASK;
d416 1
a416 1
	imask[IPL_HIGH] = 0xffffffff;
d486 1
a486 1
			pripending = hwpend & ~imask[pri];
d491 1
a491 1
			ci->ci_cpl = imask[o_intrmaxlvl[o_hwirq[irq]]];
d716 1
a716 1
			openpic_enable_irq_mask(~imask[o_intrmaxlvl[realirq]]);
d719 1
a719 1
			openpic_enable_irq_mask(~imask[o_intrmaxlvl[realirq]]);
d721 1
a721 1
			ocpl = splraise(imask[o_intrmaxlvl[realirq]]);
@


1.61
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.60 2010/04/09 19:24:17 jasper Exp $	*/
d293 1
a293 2
	evcount_attach(&ih->ih_count, name, (void *)&o_hwirq[irq],
	    &evcount_intr);
d791 4
a794 8
	evcount_attach(&ipi_nop[0], "ipi_nop0", (void *)&ipi_nopirq,
	    &evcount_intr);
	evcount_attach(&ipi_nop[1], "ipi_nop1", (void *)&ipi_nopirq,
	    &evcount_intr);
	evcount_attach(&ipi_ddb[0], "ipi_ddb0", (void *)&ipi_ddbirq,
	    &evcount_intr);
	evcount_attach(&ipi_ddb[1], "ipi_ddb1", (void *)&ipi_ddbirq,
	    &evcount_intr);
@


1.60
log
@- add and enable pgs(4), a driver for the Programmers Switch found on
recent-ish macs with macgpio(4). Basically dropping one to DDB when pushed.
...and not to be confused by the "reset" button ;-)

feedback and ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.59 2009/11/08 21:05:18 kettenis Exp $	*/
d669 1
a669 1
		panic("invalid ipi send to cpu %d %d\n", ci->ci_cpuid, id);
@


1.59
log
@Move KERNEL_LOCK/UNLOCK dance into softintr_dispatch().

ok miod@@, dms@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.58 2009/10/01 20:19:18 kettenis Exp $	*/
a70 1
int openpic_prog_button(void *arg);
a188 5
#if 1
	mac_intr_establish(parent, 0x37, IST_LEVEL,
		IPL_HIGH, openpic_prog_button, (void *)0x37, "progbutton");
#endif

d194 2
a816 16
/*
 * programmer_button function to fix args to Debugger.
 * deal with any enables/disables, if necessary.
 */
int
openpic_prog_button (void *arg)
{
#ifdef DDB
	if (db_console)
		Debugger();
#else
	printf("programmer button pressed, debugger not available\n");
#endif
	return 1;
}

@


1.58
log
@Generic soft interrupts for macppc.  Tested by mk@@, deraadt@@
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.57 2009/09/15 21:02:24 kettenis Exp $	*/
a538 1
			KERNEL_LOCK();
a539 1
			KERNEL_UNLOCK();
a546 1
			KERNEL_LOCK();
a547 1
			KERNEL_UNLOCK();
a554 1
			KERNEL_LOCK();
a555 1
			KERNEL_UNLOCK();
@


1.57
log
@Make sure we block clock interrupts at IPL_CLOCK and higher.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.56 2009/09/13 10:16:37 kettenis Exp $	*/
d74 2
a75 2
#define HWIRQ_MAX 27
#define HWIRQ_MASK 0x0fffffff
d417 1
a417 1
			imask[i] |= SINT_MASK;
d419 1
a419 1
			imask[i] |= SPL_CLOCK;
d495 1
a495 1
			ci->ci_ipending &= ~(1L << irq);
d515 1
a515 1
	ci->ci_cpl = pcpl | SINT_MASK;
d540 1
a540 1
			softclock();
a545 3
			extern int netisr;
			int pisr;
		       
d548 5
a552 8
			while ((pisr = netisr) != 0) {
				atomic_clearbits_int(&netisr, pisr);
				ppc_intr_enable(1);
				KERNEL_LOCK();
				softnet(pisr);
				KERNEL_UNLOCK();
				ppc_intr_disable();
			}
d560 1
a560 1
			softtty();
d565 1
a565 1
	} while ((ci->ci_ipending & SINT_MASK) & ~pcpl);
@


1.56
log
@Make sure we really have pending interrupts such that we don't do an
out-of-bounds array access later on.

ok drahn@@, dms@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.55 2009/08/22 02:54:50 mk Exp $	*/
d418 2
@


1.55
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.54 2009/06/09 01:12:38 deraadt Exp $	*/
d490 2
@


1.54
log
@backout interrupt diff until it the next round of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.52 2008/11/21 17:35:52 deraadt Exp $	*/
d150 1
a150 1
	int (*ih_fun)(void *), void *ih_arg, char *name);
d230 1
a230 1
    int (*ih_fun)(void *), void *ih_arg, char *name)
@


1.53
log
@Reintroduce the macppc interrupt subsystem rewrite. Several bugs have
been found and corrected.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.51 2008/11/04 14:28:24 drahn Exp $	*/
a3 1
 * Copyright (c) 2008 Dale Rahn <drahn@@openbsd.org>
a58 1
int openpic_numirq = ICU_LEN;
d61 4
a64 3
int openpic_pri_share[IPL_NUM];

struct intrq openpic_handler[ICU_LEN];
d66 2
d69 2
d72 1
d74 2
a75 3
ppc_splraise_t openpic_splraise;
ppc_spllower_t openpic_spllower;
ppc_splx_t openpic_splx;
a85 2
struct evcount openpic_spurious;
int openpic_spurious_irq = 255;
d87 7
a93 4
void	openpic_enable_irq(int, int);
void	openpic_disable_irq(int);
void	openpic_init(void);
void	openpic_set_priority(int);
d95 2
a96 16

typedef void  (void_f) (void);
extern void_f *pending_int_f;

vaddr_t openpic_base;
void *	openpic_intr_establish( void * lcv, int irq, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, char *name);
void	openpic_intr_disestablish( void *lcp, void *arg);
void	openpic_collect_preconf_intr(void);
int	openpic_big_endian;
#ifdef MULTIPROCESSOR
intr_send_ipi_t openpic_send_ipi;
#endif

u_int openpic_read(int reg);
void openpic_write(int reg, u_int val);
d104 1
a104 2
void	openpic_do_pending_int(int pcpl);
void	openpic_do_pending_int_dis(int pcpl, int s);
d106 1
a106 1
void	openpic_ext_intr(void);
a117 36
u_int
openpic_read(int reg)
{
	char *addr = (void *)(openpic_base + reg);

	asm volatile("eieio"::: "memory");
	if (openpic_big_endian)
		return in32(addr);
	else
		return in32rb(addr);
}

void
openpic_write(int reg, u_int val)
{
	char *addr = (void *)(openpic_base + reg);

	if (openpic_big_endian)
		out32(addr, val);
	else
		out32rb(addr, val);
	asm volatile("eieio"::: "memory");
}

static inline int
openpic_read_irq(int cpu)
{
	return openpic_read(OPENPIC_IACK(cpu)) & OPENPIC_VECTOR_MASK;
}

static inline void
openpic_eoi(int cpu)
{
	openpic_write(OPENPIC_EOI(cpu), 0);
}

d145 13
a160 1
	struct cpu_info *ci = curcpu();
d171 2
a172 7
	/* openpic may support more than 128 interupts but driver doesn't */
	openpic_numirq = ((openpic_read(OPENPIC_FEATURE) >> 16) & 0x7f)+1;

	printf(": version 0x%x feature %x %s",
	    openpic_read(OPENPIC_VENDOR_ID),
	    openpic_read(OPENPIC_FEATURE),
		openpic_big_endian ? "BE" : "LE" );
d176 1
d184 1
d186 1
a186 2
	ppc_smask_init();

d188 1
a188 3

	evcount_attach(&openpic_spurious, "spurious",
	    (void *)&openpic_spurious_irq, &evcount_intr);
a194 6
	ppc_intr_func.raise = openpic_splraise;
	ppc_intr_func.lower = openpic_spllower;
	ppc_intr_func.x = openpic_splx;

	openpic_set_priority(ci->ci_cpl);

a199 43
static inline void
openpic_setipl(int newcpl)
{
	struct cpu_info *ci = curcpu();
	int s;
	/* XXX - try do to this without the disable */
	s = ppc_intr_disable();
	ci->ci_cpl = newcpl;
	openpic_set_priority(newcpl);
	ppc_intr_enable(s);
}

int
openpic_splraise(int newcpl)
{
	struct cpu_info *ci = curcpu();
	newcpl = openpic_pri_share[newcpl];
	int ocpl = ci->ci_cpl;
	if (ocpl > newcpl)
		newcpl = ocpl;

	openpic_setipl(newcpl);

	return ocpl;
}

int
openpic_spllower(int newcpl)
{
	struct cpu_info *ci = curcpu();
	int ocpl = ci->ci_cpl;

	openpic_splx(newcpl);

	return ocpl;
}

void
openpic_splx(int newcpl)
{
	openpic_do_pending_int(newcpl);
}

d218 7
d232 14
a245 3
	struct intrhand *ih;
	struct intrq *iq;
	int s;
a250 1
	iq = &openpic_handler[irq];
d255 1
a255 1
	switch (iq->iq_ist) {
d257 1
a257 1
		iq->iq_ist = type;
d261 1
a261 1
		if (type == iq->iq_ist)
d266 2
a267 2
			    ppc_intr_typename(iq->iq_ist),
			    ppc_intr_typename(type));
d271 7
a277 7
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_level = level;
	ih->ih_irq = irq;

	evcount_attach(&ih->ih_count, name, (void *)&ih->ih_irq,
	    &evcount_intr);
d280 3
a282 1
	 * Append handler to end of list
d284 2
a285 1
	s = ppc_intr_disable();
a286 1
	TAILQ_INSERT_TAIL(&iq->iq_list, ih, ih_list);
d289 11
a299 1
	ppc_intr_enable(s);
d312 1
a312 2
	struct intrq *iq = &openpic_handler[irq];
	int s;
d319 1
d321 9
a329 1
	s = ppc_intr_disable();
a330 1
	TAILQ_REMOVE(&iq->iq_list, ih, ih_list);
d333 4
a336 1
	ppc_intr_enable(s);
d338 3
a340 2
	evcount_detach(&ih->ih_count);
	free((void *)ih, M_DEVBUF);
d342 15
a356 2
	if (TAILQ_EMPTY(&iq->iq_list))
		iq->iq_ist = IST_NONE;
a368 1
	struct cpu_info *ci = curcpu();
d374 15
a388 1
	openpic_set_priority(15);
d390 1
a390 3
	for (i = IPL_NONE; i < IPL_NUM; i++) {
		openpic_pri_share[i] = i;
	}
d392 6
a397 10
	for (irq = 0; irq < openpic_numirq; irq++) {
		int maxipl = IPL_NONE;
		int minipl = IPL_HIGH;
		struct intrq *iq = &openpic_handler[irq];

		TAILQ_FOREACH(ih, &iq->iq_list, ih_list) {
			if (ih->ih_level > maxipl)
				maxipl = ih->ih_level;
			if (ih->ih_level < minipl)
				minipl = ih->ih_level;
d400 2
a401 2
		if (maxipl == IPL_NONE) {
			minipl = IPL_NONE; /* Interrupt not enabled */
d403 6
a408 6
			openpic_disable_irq(irq);
		} else {
			for (i = minipl; i <= maxipl; i++) {
				openpic_pri_share[i] = maxipl;
			}
			openpic_enable_irq(irq, maxipl);
d410 1
d412 6
a417 1
		iq->iq_ipl = maxipl;
d419 2
d422 40
a461 2
	/* restore interrupts */
	openpic_set_priority(ci->ci_cpl);
d464 2
d467 1
a467 1
openpic_do_pending_int(int pcpl)
d469 6
d476 5
d482 35
a516 1
	openpic_do_pending_int_dis(pcpl, s);
a517 1

a519 5
/*
 * This function expect interrupts disabled on entry and exit,
 * the s argument indicates if interrupts may be enabled during
 * the processing of off level interrupts, s 'should' always be 1.
 */
d521 1
a521 1
openpic_do_pending_int_dis(int pcpl, int s)
a523 1
	int loopcount = 0;
d525 1
a525 3
	if (ci->ci_iactive & CI_IACTIVE_PROCESSING_SOFT) {
		/* soft interrupts are being processed, just set ipl/return */
		openpic_setipl(pcpl);
a526 1
	}
d531 4
a534 10
		loopcount ++;
		if (loopcount > 50)
			printf("do_pending looping %d pcpl %x %x\n", loopcount,
			    pcpl, ci->ci_cpl);
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTTTY)) &&
		    (pcpl < IPL_SOFTTTY)) {
			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTTTY);

			openpic_setipl(IPL_SOFTTTY);
			ppc_intr_enable(s);
d536 1
a536 1
			softtty();
d541 1
a541 2
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTNET)) &&
		    (pcpl < IPL_SOFTNET)) {
d544 3
a546 5

			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTNET);
			openpic_setipl(IPL_SOFTNET);
			ppc_intr_enable(s);
			KERNEL_LOCK();
d549 2
d552 2
a554 2
			KERNEL_UNLOCK();
			ppc_intr_disable();
d557 4
a560 5
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTCLOCK)) &&
		    (pcpl < IPL_SOFTCLOCK)) {
			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTCLOCK);
			openpic_setipl(IPL_SOFTCLOCK);
			ppc_intr_enable(s);
d562 1
a562 1
			softclock();
d567 2
a568 3
		break;
	} while (ci->ci_ipending & ppc_smask[pcpl]);
	openpic_setipl(pcpl);	/* Don't use splx... we are here already! */
d573 34
d608 1
a608 1
openpic_enable_irq(int irq, int pri)
a610 1
	struct intrq *iq = &openpic_handler[irq];
d612 16
a627 2
	x = irq;
	if (iq->iq_ist == IST_LEVEL)
a630 2
	x |= OPENPIC_POLARITY_POSITIVE;
	x |= pri << OPENPIC_PRIORITY_SHIFT;
d645 1
a645 1
openpic_set_priority(int pri)
d647 19
a665 2
	struct cpu_info *ci = curcpu();
	openpic_write(OPENPIC_CPU_PRIORITY(ci->ci_cpuid), pri);
d669 1
d684 1
a689 2
int openpic_irqnest[PPC_MAXPROCS];
int openpic_irqloop[PPC_MAXPROCS];
d691 1
a691 1
openpic_ext_intr()
d694 3
a696 3
	int irq;
	int pcpl;
	int maxipl = IPL_NONE;
a697 2
	struct intrq *iq;
	int spurious;
d701 3
a703 12
	openpic_irqloop[ci->ci_cpuid] = 0;
	irq = openpic_read_irq(ci->ci_cpuid);
	openpic_irqnest[ci->ci_cpuid]++;

	while (irq != 255) {
		openpic_irqloop[ci->ci_cpuid]++;
		if (openpic_irqloop[ci->ci_cpuid] > 20 ||
		    openpic_irqnest[ci->ci_cpuid] > 3) {
			printf("irqloop %d irqnest %d\n",
			    openpic_irqloop[ci->ci_cpuid],
			    openpic_irqnest[ci->ci_cpuid]);
		}
d705 1
a705 1
		if (irq == IPI_VECTOR_NOP) {
d708 1
a708 1
			irq = openpic_read_irq(ci->ci_cpuid);
d711 1
a711 1
		if (irq == IPI_VECTOR_DDB) {
d715 1
a715 1
			irq = openpic_read_irq(ci->ci_cpuid);
a718 1
		iq = &openpic_handler[irq];
d720 1
a720 8
		if (iq->iq_ipl <= ci->ci_cpl)
			printf("invalid interrupt %d lvl %d at %d hw %d\n",
			    irq, iq->iq_ipl, ci->ci_cpl,
			    openpic_read(OPENPIC_CPU_PRIORITY(ci->ci_cpuid)));
		if (iq->iq_ipl > maxipl)
			maxipl = iq->iq_ipl;
		splraise(iq->iq_ipl);
		openpic_eoi(ci->ci_cpuid);
d722 1
a722 9
		spurious = 1;
		TAILQ_FOREACH(ih, &iq->iq_list, ih_list) {
			ppc_intr_enable(1);
			KERNEL_LOCK();
			if ((*ih->ih_fun)(ih->ih_arg)) {
				ih->ih_count.ec_count++;
				spurious = 0;
 			}
			KERNEL_UNLOCK();
d724 1
a724 8
			(void)ppc_intr_disable();
 		}
		if (spurious) {
			openpic_spurious.ec_count++;
#ifdef OPENPIC_NOISY
			printf("spurious intr %d\n", irq);
#endif
		}
d726 9
a734 2
		uvmexp.intrs++;
		openpic_setipl(pcpl);
d736 8
a743 2
		irq = openpic_read_irq(ci->ci_cpuid);
	}
d745 2
a746 17
	if (openpic_irqnest[ci->ci_cpuid] == 1) {
		openpic_irqloop[ci->ci_cpuid] = 0;
		/* raise IPL back to max until do_pending will lower it back */
		openpic_setipl(maxipl);
		/*
		 * we must not process pending soft interrupts when nested, can
		 * cause excessive recursion.
		 * 
		 * The loop here is because an interrupt could case a pending
		 * soft interrupt between the finishing of the
		 * openpic_do_pending_int, but before ppc_intr_disable
		 */
		do {
			openpic_irqloop[ci->ci_cpuid]++;
			if (openpic_irqloop[ci->ci_cpuid] > 5) {
				printf("ext_intr: do_pending loop %d\n",
				    openpic_irqloop[ci->ci_cpuid]);
d748 9
a756 11
			if (ci->ci_iactive & CI_IACTIVE_PROCESSING_SOFT) {
				openpic_setipl(pcpl);
				/*
				 * some may be pending but someone else is
				 * processing them
				 */
				break;
			} else {
				openpic_do_pending_int_dis(pcpl, 1);
			}
		} while (ci->ci_ipending & ppc_smask[pcpl]);
d758 3
a760 1
	openpic_irqnest[ci->ci_cpuid]--;
a765 2
	struct cpu_info *ci = curcpu();
	struct intrq *iq;
a767 3
	int i;

	openpic_set_priority(15);
d770 1
a770 1
	for (irq = 0; irq < openpic_numirq; irq++)
d772 1
a772 5

	for (i = 0; i < openpic_numirq; i++) {
		iq = &openpic_handler[i];
		TAILQ_INIT(&iq->iq_list);
	}
d779 3
a781 1
	/* initialize all vectors to something sane */
a790 11
	/* send all interrupts to cpu 0 */
	for (irq = 0; irq < openpic_numirq; irq++)
		openpic_write(OPENPIC_IDEST(irq), 1 << 0);

	/* clear all pending interrunts */
	for (irq = 0; irq < ICU_LEN; irq++) {
		openpic_read_irq(ci->ci_cpuid);
		openpic_eoi(ci->ci_cpuid);
	}


a803 1
	/* XXX - ncpus */
d814 4
d824 2
a825 5
#if 0
	openpic_write(OPENPIC_SPURIOUS_VECTOR, 255);
#endif

	install_extint(openpic_ext_intr);
d827 1
a827 1
	openpic_set_priority(0);
a828 1

d845 1
d847 1
a847 1
openpic_ipi_ddb()
a848 3
#ifdef OPENPIC_NOISY
	printf("ipi_ddb() called\n");
#endif
d851 1
@


1.52
log
@back out the new interrupt subsystem because some little bug still lurks in there
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.48 2008/09/16 04:20:42 drahn Exp $	*/
d4 1
d60 1
d63 3
a65 4
int o_intrtype[ICU_LEN], o_intrmaxlvl[ICU_LEN];
struct intrhand *o_intrhand[ICU_LEN] = { 0 };
int o_hwirq[ICU_LEN], o_virq[ICU_LEN];
int o_virq_max;
a66 2
static int fakeintr(void *);
static char *intr_typename(int type);
a67 2
static __inline int cntlzw(int x);
static int mapirq(int irq);
a68 1
void openpic_enable_irq_mask(int irq_mask);
d70 3
a72 2
#define HWIRQ_MAX 27
#define HWIRQ_MASK 0x0fffffff
d83 2
d86 4
a89 7
static __inline u_int openpic_read(int);
static __inline void openpic_write(int, u_int);
void openpic_set_enable_irq(int, int);
void openpic_enable_irq(int);
void openpic_disable_irq(int);
void openpic_init(void);
void openpic_set_priority(int, int);
d91 16
a106 2
static __inline int openpic_read_irq(int);
static __inline void openpic_eoi(int);
d114 2
a115 1
void	openpic_do_pending_int(void);
d117 1
a117 1
void	ext_intr_openpic(void);
d129 36
a191 13
typedef void  (void_f) (void);
extern void_f *pending_int_f;

vaddr_t openpic_base;
void * openpic_intr_establish( void * lcv, int irq, int type, int level,
	int (*ih_fun)(void *), void *ih_arg, char *name);
void openpic_intr_disestablish( void *lcp, void *arg);
#ifdef MULTIPROCESSOR
intr_send_ipi_t openpic_send_ipi;
#endif
void openpic_collect_preconf_intr(void);
int openpic_big_endian;

d195 1
d206 7
a212 2
	printf(": version 0x%x %s endian", openpic_read(OPENPIC_VENDOR_ID),
		openpic_big_endian ? "big" : "little" );
a215 1
	pending_int_f = openpic_do_pending_int;
a222 1
	install_extint(ext_intr_openpic);
d224 2
a225 1
#if 1
d227 3
a229 1
#endif
d236 6
d247 43
a307 7
static int
fakeintr(void *arg)
{

	return 0;
}

d315 3
a317 14
	struct intrhand **p, *q, *ih;
	static struct intrhand fakehand;

	fakehand.ih_next = NULL;
	fakehand.ih_fun  = fakeintr;

#if 0
printf("mac_intr_establish, hI %d L %d ", irq, type);
#endif

	irq = mapirq(irq);
#if 0
printf("vI %d ", irq);
#endif
d323 1
d328 1
a328 1
	switch (o_intrtype[irq]) {
d330 1
a330 1
		o_intrtype[irq] = type;
d334 1
a334 1
		if (type == o_intrtype[irq])
d339 2
a340 2
			    intr_typename(o_intrtype[irq]),
			    intr_typename(type));
d344 7
a350 7
	/*
	 * Figure out where to put the handler.
	 * This is O(N^2), but we want to preserve the order, and N is
	 * generally small.
	 */
	for (p = &o_intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
		;
d353 1
a353 3
	 * Actually install a fake handler momentarily, since we might be doing
	 * this with interrupts enabled and DON'T WANt the real routine called
	 * until masking is set up.
d355 1
a355 2
	fakehand.ih_level = level;
	*p = &fakehand;
d357 1
d360 1
a360 11
	/*
	 * Poke the real handler in now.
	 */
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_next = NULL;
	ih->ih_level = level;
	ih->ih_irq = irq;
	evcount_attach(&ih->ih_count, name, (void *)&o_hwirq[irq],
	    &evcount_intr);
	*p = ih;
d373 2
a374 1
	struct intrhand **p, *q;
a380 1
	 * This is O(n^2), too.
d382 1
a382 9
	for (p = &o_intrhand[irq]; (q = *p) != NULL && q != ih; p = &q->ih_next)
		;
	if (q)
		*p = q->ih_next;
	else
		panic("intr_disestablish: handler not registered");

	evcount_detach(&ih->ih_count);
	free((void *)ih, M_DEVBUF);
d384 1
d387 1
a387 3
	if (o_intrhand[irq] == NULL)
		o_intrtype[irq] = IST_NONE;
}
d389 2
d392 2
a393 19
static char *
intr_typename(int type)
{

	switch (type) {
	case IST_NONE:
		return ("none");
	case IST_PULSE:
		return ("pulsed");
	case IST_EDGE:
		return ("edge-triggered");
	case IST_LEVEL:
		return ("level-triggered");
	default:
		panic("intr_typename: invalid type %d", type);
#if 1 /* XXX */
		return ("unknown");
#endif
	}
d406 1
d412 1
a412 1
	openpic_set_priority(0, 15);
d414 14
a427 12
	for (irq = 0; irq < ICU_LEN; irq++) {
		int max = IPL_NONE;
		int min = IPL_HIGH;
		int reg;
		if (o_virq[irq] != 0) {
			for (ih = o_intrhand[o_virq[irq]]; ih;
			    ih = ih->ih_next) {
				if (ih->ih_level > max)
					max = ih->ih_level;
				if (ih->ih_level < min)
					min = ih->ih_level;
			}
d430 2
a431 1
		o_intrmaxlvl[irq] = max;
d433 6
a438 6
		/* adjust priority if it changes */
		reg = openpic_read(OPENPIC_SRC_VECTOR(irq));
		if (max != ((reg >> OPENPIC_PRIORITY_SHIFT) & 0xf)) {
			openpic_write(OPENPIC_SRC_VECTOR(irq),
				(reg & ~(0xf << OPENPIC_PRIORITY_SHIFT)) |
				(max << OPENPIC_PRIORITY_SHIFT) );
d441 1
a441 10
		if (max == IPL_NONE)
			min = IPL_NONE; /* Interrupt not enabled */

		if (o_virq[irq] != 0) {
			/* Enable (dont mask) interrupts at lower levels */ 
			for (i = IPL_NONE; i < min; i++)
				imask[i] &= ~(1 << o_virq[irq]);
			for (; i <= IPL_HIGH; i++)
				imask[i] |= (1 << o_virq[irq]);
		}
d445 1
a445 7
	openpic_set_priority(0, 0);

	for (i = IPL_NONE; i <= IPL_HIGH; i++) {
		if (i > IPL_NONE)
			imask[i] |= SINT_MASK;
	}
	imask[IPL_HIGH] = 0xffffffff;
d448 2
a449 5
/*
 * Map 64 irqs into 32 (bits).
 */
static int
mapirq(int irq)
d451 4
a454 8
	int v;

	/* irq in table already? */
	if (o_virq[irq] != 0)
		return o_virq[irq];

	if (irq < 0 || irq >= ICU_LEN)
		panic("invalid irq %d", irq);
a455 12
	o_virq_max++;
	v = o_virq_max;
	if (v > HWIRQ_MAX)
		panic("virq overflow");

	o_hwirq[v] = irq;
	o_virq[irq] = v;
#if 0
printf("\nmapirq %x to %x\n", irq, v);
#endif

	return v;
d459 3
a461 1
 * Count leading zeros.
a462 12
static __inline int
cntlzw(int x)
{
	int a;

	__asm __volatile ("cntlzw %0,%1" : "=r"(a) : "r"(x));

	return a;
}

void openpic_do_pending_softint(int pcpl);

d464 1
a464 1
openpic_do_pending_int()
d467 1
a467 6
	struct intrhand *ih;
	int irq;
	int pcpl;
	int hwpend;
	int pri, pripending;
	int s;
d469 3
a471 1
	if (ci->ci_iactive & CI_IACTIVE_PROCESSING_HARD)
a472 31

	atomic_setbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_HARD);
	s = ppc_intr_disable();
	pcpl = ci->ci_cpl;

	hwpend = ci->ci_ipending & ~pcpl;	/* Do now unmasked pendings */
	hwpend &= HWIRQ_MASK;
	while (hwpend) {
		/* this still doesn't handle the interrupts in priority order */
		for (pri = IPL_HIGH; pri >= IPL_NONE; pri--) {
			pripending = hwpend & ~imask[pri];
			irq = 31 - cntlzw(pripending);
			ci->ci_ipending &= ~(1L << irq);
			ci->ci_cpl = imask[o_intrmaxlvl[o_hwirq[irq]]];
			openpic_enable_irq_mask(~ci->ci_cpl);
			ih = o_intrhand[irq];
			while(ih) {
				ppc_intr_enable(1);

				KERNEL_LOCK();
				if ((*ih->ih_fun)(ih->ih_arg))
					ih->ih_count.ec_count++;
				KERNEL_UNLOCK();

				(void)ppc_intr_disable();
				
				ih = ih->ih_next;
			}
		}
		hwpend = ci->ci_ipending & ~pcpl;/* Catch new pendings */
		hwpend &= HWIRQ_MASK;
a473 16
	ci->ci_cpl = pcpl | SINT_MASK;
	openpic_enable_irq_mask(~ci->ci_cpl);
	atomic_clearbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_HARD);

	openpic_do_pending_softint(pcpl);

	ppc_intr_enable(s);
}

void
openpic_do_pending_softint(int pcpl)
{
	struct cpu_info *ci = curcpu();

	if (ci->ci_iactive & CI_IACTIVE_PROCESSING_SOFT)
		return;
d478 10
a487 4
		if((ci->ci_ipending & SINT_CLOCK) & ~pcpl) {
			ci->ci_ipending &= ~SINT_CLOCK;
			ci->ci_cpl = SINT_CLOCK|SINT_NET|SINT_TTY;
			ppc_intr_enable(1);
d489 1
a489 1
			softclock();
d494 2
a495 1
		if((ci->ci_ipending & SINT_NET) & ~pcpl) {
d498 5
a502 3
		       
			ci->ci_ipending &= ~SINT_NET;
			ci->ci_cpl = SINT_NET|SINT_TTY;
a504 2
				ppc_intr_enable(1);
				KERNEL_LOCK();
a505 2
				KERNEL_UNLOCK();
				ppc_intr_disable();
d507 2
d511 5
a515 4
		if((ci->ci_ipending & SINT_TTY) & ~pcpl) {
			ci->ci_ipending &= ~SINT_TTY;
			ci->ci_cpl = SINT_TTY;
			ppc_intr_enable(1);
d517 1
a517 1
			softtty();
d522 3
a524 2
	} while ((ci->ci_ipending & SINT_MASK) & ~pcpl);
	ci->ci_cpl = pcpl;	/* Don't use splx... we are here already! */
a528 34
u_int
openpic_read(int reg)
{
	char *addr = (void *)(openpic_base + reg);

	if (openpic_big_endian)
		return in32(addr);
	else
		return in32rb(addr);
}

void
openpic_write(int reg, u_int val)
{
	char *addr = (void *)(openpic_base + reg);

	if (openpic_big_endian)
		out32(addr, val);
	else
		out32rb(addr, val);
}

void
openpic_enable_irq_mask(int irq_mask)
{
	int irq;
	for ( irq = 0; irq <= o_virq_max; irq++) {
		if (irq_mask & (1 << irq))
			openpic_enable_irq(o_hwirq[irq]);
		else
			openpic_disable_irq(o_hwirq[irq]);
	}
}

d530 1
a530 1
openpic_set_enable_irq(int irq, int type)
d533 1
d535 2
a536 16
	x = openpic_read(OPENPIC_SRC_VECTOR(irq));
	x &= ~(OPENPIC_IMASK|OPENPIC_SENSE_LEVEL|OPENPIC_SENSE_EDGE);
	if (type == IST_LEVEL)
		x |= OPENPIC_SENSE_LEVEL;
	else
		x |= OPENPIC_SENSE_EDGE;
	openpic_write(OPENPIC_SRC_VECTOR(irq), x);
}
void
openpic_enable_irq(int irq)
{
	u_int x;

	x = openpic_read(OPENPIC_SRC_VECTOR(irq));
	x &= ~(OPENPIC_IMASK|OPENPIC_SENSE_LEVEL|OPENPIC_SENSE_EDGE);
	if (o_intrtype[o_virq[irq]] == IST_LEVEL)
d540 2
d556 1
a556 1
openpic_set_priority(int cpu, int pri)
d558 2
a559 19
	u_int x;

	x = openpic_read(OPENPIC_CPU_PRIORITY(cpu));
	x &= ~OPENPIC_CPU_PRIORITY_MASK;
	x |= pri;
	openpic_write(OPENPIC_CPU_PRIORITY(cpu), x);
}

int
openpic_read_irq(int cpu)
{
	return openpic_read(OPENPIC_IACK(cpu)) & OPENPIC_VECTOR_MASK;
}

void
openpic_eoi(int cpu)
{
	openpic_write(OPENPIC_EOI(cpu), 0);
	openpic_read(OPENPIC_EOI(cpu));
a562 1

a576 1
		
d582 2
d585 1
a585 1
ext_intr_openpic()
d588 3
a590 3
	int irq, realirq;
	int r_imen;
	int pcpl, ocpl;
d592 2
d597 12
a608 3
	realirq = openpic_read_irq(ci->ci_cpuid);

	while (realirq != 255) {
d610 1
a610 1
		if (realirq == IPI_VECTOR_NOP) {
d613 1
a613 1
			realirq = openpic_read_irq(ci->ci_cpuid);
d616 1
a616 1
		if (realirq == IPI_VECTOR_DDB) {
d620 1
a620 1
			realirq = openpic_read_irq(ci->ci_cpuid);
d624 1
d626 8
a633 1
		irq = o_virq[realirq];
d635 9
a643 1
		/* XXX check range */
d645 8
a652 1
		r_imen = 1 << irq;
d654 2
a655 9
		if ((pcpl & r_imen) != 0) {
			/* Masked! Mark this as pending. */
			ci->ci_ipending |= r_imen;
			openpic_enable_irq_mask(~imask[o_intrmaxlvl[realirq]]);
			openpic_eoi(ci->ci_cpuid);
		} else {
			openpic_enable_irq_mask(~imask[o_intrmaxlvl[realirq]]);
			openpic_eoi(ci->ci_cpuid);
			ocpl = splraise(imask[o_intrmaxlvl[realirq]]);
d657 2
a658 8
			ih = o_intrhand[irq];
			while (ih) {
				ppc_intr_enable(1);

				KERNEL_LOCK();
				if ((*ih->ih_fun)(ih->ih_arg))
					ih->ih_count.ec_count++;
				KERNEL_UNLOCK();
d660 27
a686 2
				(void)ppc_intr_disable();
				ih = ih->ih_next;
d688 1
a688 9

			uvmexp.intrs++;
			__asm__ volatile("":::"memory"); /* don't reorder.... */
			ci->ci_cpl = ocpl;
			__asm__ volatile("":::"memory"); /* don't reorder.... */
			openpic_enable_irq_mask(~pcpl);
		}

		realirq = openpic_read_irq(ci->ci_cpuid);
d690 1
a690 3
	ppc_intr_enable(1);

	splx(pcpl);	/* Process pendings. */
d696 2
d700 3
d705 1
a705 1
	for (irq = 0; irq < 255; irq++)
d707 5
a711 1
	openpic_set_priority(0, 15);
d718 1
a718 3
	/* send all interrupts to cpu 0 */
	for (irq = 0; irq < ICU_LEN; irq++)
		openpic_write(OPENPIC_IDEST(irq), 1 << 0);
d728 11
d752 1
a762 4
	/* XXX set spurious intr vector */

	openpic_set_priority(0, 0);

d769 5
a773 2
	for (irq = 0; irq < ICU_LEN; irq++)
		openpic_disable_irq(irq);
d775 1
a775 1
	install_extint(ext_intr_openpic);
d777 1
a793 1

d795 1
a795 1
openpic_ipi_ddb(void)
d797 3
a801 1

@


1.51
log
@missing setipl in the 'busy processing soft interrupts state'
causes high priority interrupts to be delayed until that state is cleared.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.50 2008/09/19 01:49:54 drahn Exp $	*/
a3 1
 * Copyright (c) 2008 Dale Rahn <drahn@@openbsd.org>
a58 1
int openpic_numirq = ICU_LEN;
d61 4
a64 3
int openpic_pri_share[IPL_NUM];

struct intrq openpic_handler[ICU_LEN];
d66 2
d69 2
d72 1
d74 2
a75 3
ppc_splraise_t openpic_splraise;
ppc_spllower_t openpic_spllower;
ppc_splx_t openpic_splx;
a85 2
struct evcount openpic_spurious;
int openpic_spurious_irq = 255;
d87 7
a93 4
void	openpic_enable_irq(int, int);
void	openpic_disable_irq(int);
void	openpic_init(void);
void	openpic_set_priority(int);
d95 2
a96 16

typedef void  (void_f) (void);
extern void_f *pending_int_f;

vaddr_t openpic_base;
void *	openpic_intr_establish( void * lcv, int irq, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, char *name);
void	openpic_intr_disestablish( void *lcp, void *arg);
void	openpic_collect_preconf_intr(void);
int	openpic_big_endian;
#ifdef MULTIPROCESSOR
intr_send_ipi_t openpic_send_ipi;
#endif

u_int openpic_read(int reg);
void openpic_write(int reg, u_int val);
d104 1
a104 1
void	openpic_do_pending_int(int pcpl);
d106 1
a106 1
void	openpic_ext_intr(void);
a117 36
u_int
openpic_read(int reg)
{
	char *addr = (void *)(openpic_base + reg);

	asm volatile("eieio");
	if (openpic_big_endian)
		return in32(addr);
	else
		return in32rb(addr);
}

void
openpic_write(int reg, u_int val)
{
	char *addr = (void *)(openpic_base + reg);

	if (openpic_big_endian)
		out32(addr, val);
	else
		out32rb(addr, val);
	asm volatile("eieio");
}

static inline int
openpic_read_irq(int cpu)
{
	return openpic_read(OPENPIC_IACK(cpu)) & OPENPIC_VECTOR_MASK;
}

static inline void
openpic_eoi(int cpu)
{
	openpic_write(OPENPIC_EOI(cpu), 0);
}

d145 13
a160 1
	struct cpu_info *ci = curcpu();
d171 2
a172 7
	/* openpic may support more than 128 interupts but driver doesn't */
	openpic_numirq = ((openpic_read(OPENPIC_FEATURE) >> 16) & 0x7f)+1;

	printf(": version 0x%x feature %x %s",
	    openpic_read(OPENPIC_VENDOR_ID),
	    openpic_read(OPENPIC_FEATURE),
		openpic_big_endian ? "BE" : "LE" );
d176 1
d184 1
d186 1
a186 2
	ppc_smask_init();

d188 1
a188 3

	evcount_attach(&openpic_spurious, "spurious",
	    (void *)&openpic_spurious_irq, &evcount_intr);
a194 6
	ppc_intr_func.raise = openpic_splraise;
	ppc_intr_func.lower = openpic_spllower;
	ppc_intr_func.x = openpic_splx;

	openpic_set_priority(ci->ci_cpl);

a199 43
static inline void
openpic_setipl(int newcpl)
{
	struct cpu_info *ci = curcpu();
	int s;
	/* XXX - try do to this without the disable */
	s = ppc_intr_disable();
	ci->ci_cpl = newcpl;
	openpic_set_priority(newcpl);
	ppc_intr_enable(s);
}

int
openpic_splraise(int newcpl)
{
	struct cpu_info *ci = curcpu();
	newcpl = openpic_pri_share[newcpl];
	int ocpl = ci->ci_cpl;
	if (ocpl > newcpl)
		newcpl = ocpl;

	openpic_setipl(newcpl);

	return ocpl;
}

int
openpic_spllower(int newcpl)
{
	struct cpu_info *ci = curcpu();
	int ocpl = ci->ci_cpl;

	openpic_splx(newcpl);

	return ocpl;
}

void
openpic_splx(int newcpl)
{
	openpic_do_pending_int(newcpl);
}

d218 7
d232 14
a245 3
	struct intrhand *ih;
	struct intrq *iq;
	int s;
a250 1
	iq = &openpic_handler[irq];
d255 1
a255 1
	switch (iq->iq_ist) {
d257 1
a257 1
		iq->iq_ist = type;
d261 1
a261 1
		if (type == iq->iq_ist)
d266 2
a267 2
			    ppc_intr_typename(iq->iq_ist),
			    ppc_intr_typename(type));
d271 7
a277 7
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_level = level;
	ih->ih_irq = irq;

	evcount_attach(&ih->ih_count, name, (void *)&ih->ih_irq,
	    &evcount_intr);
d280 3
a282 1
	 * Append handler to end of list
d284 2
a285 1
	s = ppc_intr_disable();
a286 1
	TAILQ_INSERT_TAIL(&iq->iq_list, ih, ih_list);
d289 11
a299 1
	ppc_intr_enable(s);
d312 1
a312 2
	struct intrq *iq = &openpic_handler[irq];
	int s;
d319 1
d321 9
a329 1
	s = ppc_intr_disable();
a330 1
	TAILQ_REMOVE(&iq->iq_list, ih, ih_list);
d333 4
a336 1
	ppc_intr_enable(s);
d338 3
a340 2
	evcount_detach(&ih->ih_count);
	free((void *)ih, M_DEVBUF);
d342 15
a356 2
	if (TAILQ_EMPTY(&iq->iq_list))
		iq->iq_ist = IST_NONE;
a368 1
	struct cpu_info *ci = curcpu();
d374 15
a388 1
	openpic_set_priority(15);
d390 1
a390 3
	for (i = IPL_NONE; i < IPL_NUM; i++) {
		openpic_pri_share[i] = i;
	}
d392 6
a397 10
	for (irq = 0; irq < openpic_numirq; irq++) {
		int maxipl = IPL_NONE;
		int minipl = IPL_HIGH;
		struct intrq *iq = &openpic_handler[irq];

		TAILQ_FOREACH(ih, &iq->iq_list, ih_list) {
			if (ih->ih_level > maxipl)
				maxipl = ih->ih_level;
			if (ih->ih_level < minipl)
				minipl = ih->ih_level;
d400 2
a401 2
		if (maxipl == IPL_NONE) {
			minipl = IPL_NONE; /* Interrupt not enabled */
d403 6
a408 6
			openpic_disable_irq(irq);
		} else {
			for (i = minipl; i <= maxipl; i++) {
				openpic_pri_share[i] = maxipl;
			}
			openpic_enable_irq(irq, maxipl);
d410 1
d412 6
a417 1
		iq->iq_ipl = maxipl;
d419 2
d422 40
a461 2
	/* restore interrupts */
	openpic_set_priority(ci->ci_cpl);
d464 2
d467 1
a467 1
openpic_do_pending_int(int pcpl)
d470 5
a475 1
	int loopcount = 0;
d477 4
d482 44
a525 4
	if (ci->ci_iactive & CI_IACTIVE_PROCESSING_SOFT) {
		/* soft interrupts are being processed, just set ipl/return */
		openpic_setipl(pcpl);
		ppc_intr_enable(s);
a526 1
	}
d531 4
a534 10
		loopcount ++;
		if (loopcount > 50)
			printf("do_pending looping %d pcpl %x %x\n", loopcount,
			    pcpl, ci->ci_cpl);
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTTTY)) &&
		    (pcpl < IPL_SOFTTTY)) {
			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTTTY);

			openpic_setipl(IPL_SOFTTTY);
			ppc_intr_enable(s);
d536 1
a536 1
			softtty();
d541 1
a541 2
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTNET)) &&
		    (pcpl < IPL_SOFTNET)) {
d544 3
a546 5

			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTNET);
			openpic_setipl(IPL_SOFTNET);
			ppc_intr_enable(s);
			KERNEL_LOCK();
d549 2
d552 2
a554 2
			KERNEL_UNLOCK();
			ppc_intr_disable();
d557 4
a560 5
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTCLOCK)) &&
		    (pcpl < IPL_SOFTCLOCK)) {
			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTCLOCK);
			openpic_setipl(IPL_SOFTCLOCK);
			ppc_intr_enable(s);
d562 1
a562 1
			softclock();
d567 2
a568 3
		break;
	} while (ci->ci_ipending & ppc_smask[pcpl]);
	openpic_setipl(pcpl);	/* Don't use splx... we are here already! */
d571 34
a604 1
	ppc_intr_enable(s);
d608 1
a608 1
openpic_enable_irq(int irq, int pri)
a610 1
	struct intrq *iq = &openpic_handler[irq];
d612 16
a627 2
	x = irq;
	if (iq->iq_ist == IST_LEVEL)
a630 2
	x |= OPENPIC_POLARITY_POSITIVE;
	x |= pri << OPENPIC_PRIORITY_SHIFT;
d645 1
a645 1
openpic_set_priority(int pri)
d647 19
a665 2
	struct cpu_info *ci = curcpu();
	openpic_write(OPENPIC_CPU_PRIORITY(ci->ci_cpuid), pri);
d669 1
d684 1
d691 1
a691 1
openpic_ext_intr()
d694 3
a696 2
	int irq;
	int pcpl;
a697 4
	struct intrq *iq;
	int irqloop = 0;
	static int irqnest = 0;
	int spurious;
d701 1
a701 2
	irq = openpic_read_irq(ci->ci_cpuid);
	irqnest++;
d703 1
a703 5
	while (irq != 255) {
		irqloop++;
		if (irqloop > 20 || irqnest > 3) {
			printf("irqloop %d irqnest %d\n", irqloop, irqnest);
		}
d705 1
a705 1
		if (irq == IPI_VECTOR_NOP) {
d708 1
a708 1
			irq = openpic_read_irq(ci->ci_cpuid);
d711 1
a711 1
		if (irq == IPI_VECTOR_DDB) {
d715 1
a715 1
			irq = openpic_read_irq(ci->ci_cpuid);
a718 1
		iq = &openpic_handler[irq];
d720 3
a722 6
		if (iq->iq_ipl <= ci->ci_cpl)
			printf("invalid interrupt %d lvl %d at %d hw %d\n",
			    irq, iq->iq_ipl, ci->ci_cpl,
			    openpic_read(OPENPIC_CPU_PRIORITY(ci->ci_cpuid)));
		splraise(iq->iq_ipl);
		openpic_eoi(ci->ci_cpuid);
d724 24
a747 9
		spurious = 1;
		TAILQ_FOREACH(ih, &iq->iq_list, ih_list) {
			ppc_intr_enable(1);
			KERNEL_LOCK();
			if ((*ih->ih_fun)(ih->ih_arg)) {
				ih->ih_count.ec_count++;
				spurious = 0;
 			}
			KERNEL_UNLOCK();
d749 5
a753 7
			(void)ppc_intr_disable();
 		}
		if (spurious) {
			openpic_spurious.ec_count++;
#ifdef OPENPIC_NOISY
			printf("spurious intr %d\n", irq);
#endif
d756 1
a756 4
		uvmexp.intrs++;
		openpic_setipl(pcpl);

		irq = openpic_read_irq(ci->ci_cpuid);
a757 1
	irqnest--;
a765 2
	struct cpu_info *ci = curcpu();
	struct intrq *iq;
a767 3
	int i;

	openpic_set_priority(15);
d770 1
a770 1
	for (irq = 0; irq < openpic_numirq; irq++)
d772 1
a772 5

	for (i = 0; i < openpic_numirq; i++) {
		iq = &openpic_handler[i];
		TAILQ_INIT(&iq->iq_list);
	}
d779 3
a781 1
	/* initialize all vectors to something sane */
a790 11
	/* send all interrupts to cpu 0 */
	for (irq = 0; irq < openpic_numirq; irq++)
		openpic_write(OPENPIC_IDEST(irq), 1 << 0);

	/* clear all pending interrunts */
	for (irq = 0; irq < ICU_LEN; irq++) {
		openpic_read_irq(ci->ci_cpuid);
		openpic_eoi(ci->ci_cpuid);
	}


a803 1
	/* XXX - ncpus */
d814 4
d824 2
a825 5
#if 0
	openpic_write(OPENPIC_SPURIOUS_VECTOR, 255);
#endif

	install_extint(openpic_ext_intr);
d827 1
a827 1
	openpic_set_priority(0);
a828 1

d845 1
d847 1
a847 1
openpic_ipi_ddb()
a848 3
#ifdef OPENPIC_NOISY
	printf("ipi_ddb() called\n");
#endif
d851 1
@


1.50
log
@While vaguely interesting, the prints coming out of the driver was way too
noisy. Hopefully this will quiet it down for all but extremely odd cases
(where we probably want to see the messages).
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.49 2008/09/18 03:56:25 drahn Exp $	*/
d456 2
@


1.49
log
@Redesign of the powerpc interrupt architecture, use true levels intead of
blocking specific interrupts. Needs signficant testing to prove that
one remaining elusive bug has been squashed.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.48 2008/09/16 04:20:42 drahn Exp $	*/
d464 1
a464 1
		if (loopcount > 5)
d628 1
d630 1
d748 1
d750 1
@


1.48
log
@SMP ddb support, with some feedback from kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.47 2008/08/25 03:16:22 todd Exp $	*/
d4 1
d60 1
d63 3
a65 4
int o_intrtype[ICU_LEN], o_intrmaxlvl[ICU_LEN];
struct intrhand *o_intrhand[ICU_LEN] = { 0 };
int o_hwirq[ICU_LEN], o_virq[ICU_LEN];
int o_virq_max;
a66 2
static int fakeintr(void *);
static char *intr_typename(int type);
a67 2
static __inline int cntlzw(int x);
static int mapirq(int irq);
a68 1
void openpic_enable_irq_mask(int irq_mask);
d70 3
a72 2
#define HWIRQ_MAX 27
#define HWIRQ_MASK 0x0fffffff
d83 2
d86 4
a89 7
static __inline u_int openpic_read(int);
static __inline void openpic_write(int, u_int);
void openpic_set_enable_irq(int, int);
void openpic_enable_irq(int);
void openpic_disable_irq(int);
void openpic_init(void);
void openpic_set_priority(int, int);
d91 16
a106 2
static __inline int openpic_read_irq(int);
static __inline void openpic_eoi(int);
d114 1
a114 1
void	openpic_do_pending_int(void);
d116 1
a116 1
void	ext_intr_openpic(void);
d128 36
a190 13
typedef void  (void_f) (void);
extern void_f *pending_int_f;

vaddr_t openpic_base;
void * openpic_intr_establish( void * lcv, int irq, int type, int level,
	int (*ih_fun)(void *), void *ih_arg, char *name);
void openpic_intr_disestablish( void *lcp, void *arg);
#ifdef MULTIPROCESSOR
intr_send_ipi_t openpic_send_ipi;
#endif
void openpic_collect_preconf_intr(void);
int openpic_big_endian;

d194 1
d205 7
a211 2
	printf(": version 0x%x %s endian", openpic_read(OPENPIC_VENDOR_ID),
		openpic_big_endian ? "big" : "little" );
a214 1
	pending_int_f = openpic_do_pending_int;
a221 1
	install_extint(ext_intr_openpic);
d223 2
a224 1
#if 1
d226 3
a228 1
#endif
d235 6
d246 43
a306 7
static int
fakeintr(void *arg)
{

	return 0;
}

d314 3
a316 14
	struct intrhand **p, *q, *ih;
	static struct intrhand fakehand;

	fakehand.ih_next = NULL;
	fakehand.ih_fun  = fakeintr;

#if 0
printf("mac_intr_establish, hI %d L %d ", irq, type);
#endif

	irq = mapirq(irq);
#if 0
printf("vI %d ", irq);
#endif
d322 1
d327 1
a327 1
	switch (o_intrtype[irq]) {
d329 1
a329 1
		o_intrtype[irq] = type;
d333 1
a333 1
		if (type == o_intrtype[irq])
d338 2
a339 2
			    intr_typename(o_intrtype[irq]),
			    intr_typename(type));
d343 7
a349 7
	/*
	 * Figure out where to put the handler.
	 * This is O(N^2), but we want to preserve the order, and N is
	 * generally small.
	 */
	for (p = &o_intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
		;
d352 1
a352 3
	 * Actually install a fake handler momentarily, since we might be doing
	 * this with interrupts enabled and DON'T WANt the real routine called
	 * until masking is set up.
d354 1
a354 2
	fakehand.ih_level = level;
	*p = &fakehand;
d356 1
d359 1
a359 11
	/*
	 * Poke the real handler in now.
	 */
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_next = NULL;
	ih->ih_level = level;
	ih->ih_irq = irq;
	evcount_attach(&ih->ih_count, name, (void *)&o_hwirq[irq],
	    &evcount_intr);
	*p = ih;
d372 2
a373 1
	struct intrhand **p, *q;
a379 1
	 * This is O(n^2), too.
d381 1
a381 9
	for (p = &o_intrhand[irq]; (q = *p) != NULL && q != ih; p = &q->ih_next)
		;
	if (q)
		*p = q->ih_next;
	else
		panic("intr_disestablish: handler not registered");

	evcount_detach(&ih->ih_count);
	free((void *)ih, M_DEVBUF);
d383 1
d386 1
a386 3
	if (o_intrhand[irq] == NULL)
		o_intrtype[irq] = IST_NONE;
}
d388 2
d391 2
a392 19
static char *
intr_typename(int type)
{

	switch (type) {
	case IST_NONE:
		return ("none");
	case IST_PULSE:
		return ("pulsed");
	case IST_EDGE:
		return ("edge-triggered");
	case IST_LEVEL:
		return ("level-triggered");
	default:
		panic("intr_typename: invalid type %d", type);
#if 1 /* XXX */
		return ("unknown");
#endif
	}
d405 1
d411 5
a415 1
	openpic_set_priority(0, 15);
d417 10
a426 12
	for (irq = 0; irq < ICU_LEN; irq++) {
		int max = IPL_NONE;
		int min = IPL_HIGH;
		int reg;
		if (o_virq[irq] != 0) {
			for (ih = o_intrhand[o_virq[irq]]; ih;
			    ih = ih->ih_next) {
				if (ih->ih_level > max)
					max = ih->ih_level;
				if (ih->ih_level < min)
					min = ih->ih_level;
			}
d429 2
a430 1
		o_intrmaxlvl[irq] = max;
d432 6
a437 6
		/* adjust priority if it changes */
		reg = openpic_read(OPENPIC_SRC_VECTOR(irq));
		if (max != ((reg >> OPENPIC_PRIORITY_SHIFT) & 0xf)) {
			openpic_write(OPENPIC_SRC_VECTOR(irq),
				(reg & ~(0xf << OPENPIC_PRIORITY_SHIFT)) |
				(max << OPENPIC_PRIORITY_SHIFT) );
d440 1
a440 10
		if (max == IPL_NONE)
			min = IPL_NONE; /* Interrupt not enabled */

		if (o_virq[irq] != 0) {
			/* Enable (dont mask) interrupts at lower levels */ 
			for (i = IPL_NONE; i < min; i++)
				imask[i] &= ~(1 << o_virq[irq]);
			for (; i <= IPL_HIGH; i++)
				imask[i] |= (1 << o_virq[irq]);
		}
d444 1
a444 7
	openpic_set_priority(0, 0);

	for (i = IPL_NONE; i <= IPL_HIGH; i++) {
		if (i > IPL_NONE)
			imask[i] |= SINT_MASK;
	}
	imask[IPL_HIGH] = 0xffffffff;
a446 44
/*
 * Map 64 irqs into 32 (bits).
 */
static int
mapirq(int irq)
{
	int v;

	/* irq in table already? */
	if (o_virq[irq] != 0)
		return o_virq[irq];

	if (irq < 0 || irq >= ICU_LEN)
		panic("invalid irq %d", irq);

	o_virq_max++;
	v = o_virq_max;
	if (v > HWIRQ_MAX)
		panic("virq overflow");

	o_hwirq[v] = irq;
	o_virq[irq] = v;
#if 0
printf("\nmapirq %x to %x\n", irq, v);
#endif

	return v;
}

/*
 * Count leading zeros.
 */
static __inline int
cntlzw(int x)
{
	int a;

	__asm __volatile ("cntlzw %0,%1" : "=r"(a) : "r"(x));

	return a;
}

void openpic_do_pending_softint(int pcpl);

d448 1
a448 1
openpic_do_pending_int()
a450 5
	struct intrhand *ih;
	int irq;
	int pcpl;
	int hwpend;
	int pri, pripending;
d452 1
d454 3
a456 1
	if (ci->ci_iactive & CI_IACTIVE_PROCESSING_HARD)
a457 31

	atomic_setbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_HARD);
	s = ppc_intr_disable();
	pcpl = ci->ci_cpl;

	hwpend = ci->ci_ipending & ~pcpl;	/* Do now unmasked pendings */
	hwpend &= HWIRQ_MASK;
	while (hwpend) {
		/* this still doesn't handle the interrupts in priority order */
		for (pri = IPL_HIGH; pri >= IPL_NONE; pri--) {
			pripending = hwpend & ~imask[pri];
			irq = 31 - cntlzw(pripending);
			ci->ci_ipending &= ~(1L << irq);
			ci->ci_cpl = imask[o_intrmaxlvl[o_hwirq[irq]]];
			openpic_enable_irq_mask(~ci->ci_cpl);
			ih = o_intrhand[irq];
			while(ih) {
				ppc_intr_enable(1);

				KERNEL_LOCK();
				if ((*ih->ih_fun)(ih->ih_arg))
					ih->ih_count.ec_count++;
				KERNEL_UNLOCK();

				(void)ppc_intr_disable();
				
				ih = ih->ih_next;
			}
		}
		hwpend = ci->ci_ipending & ~pcpl;/* Catch new pendings */
		hwpend &= HWIRQ_MASK;
a458 16
	ci->ci_cpl = pcpl | SINT_MASK;
	openpic_enable_irq_mask(~ci->ci_cpl);
	atomic_clearbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_HARD);

	openpic_do_pending_softint(pcpl);

	ppc_intr_enable(s);
}

void
openpic_do_pending_softint(int pcpl)
{
	struct cpu_info *ci = curcpu();

	if (ci->ci_iactive & CI_IACTIVE_PROCESSING_SOFT)
		return;
d463 10
a472 4
		if((ci->ci_ipending & SINT_CLOCK) & ~pcpl) {
			ci->ci_ipending &= ~SINT_CLOCK;
			ci->ci_cpl = SINT_CLOCK|SINT_NET|SINT_TTY;
			ppc_intr_enable(1);
d474 1
a474 1
			softclock();
d479 2
a480 1
		if((ci->ci_ipending & SINT_NET) & ~pcpl) {
d483 5
a487 3
		       
			ci->ci_ipending &= ~SINT_NET;
			ci->ci_cpl = SINT_NET|SINT_TTY;
a489 2
				ppc_intr_enable(1);
				KERNEL_LOCK();
a490 2
				KERNEL_UNLOCK();
				ppc_intr_disable();
d492 2
d496 5
a500 4
		if((ci->ci_ipending & SINT_TTY) & ~pcpl) {
			ci->ci_ipending &= ~SINT_TTY;
			ci->ci_cpl = SINT_TTY;
			ppc_intr_enable(1);
d502 1
a502 1
			softtty();
d507 3
a509 2
	} while ((ci->ci_ipending & SINT_MASK) & ~pcpl);
	ci->ci_cpl = pcpl;	/* Don't use splx... we are here already! */
d512 1
a512 22
}

u_int
openpic_read(int reg)
{
	char *addr = (void *)(openpic_base + reg);

	if (openpic_big_endian)
		return in32(addr);
	else
		return in32rb(addr);
}

void
openpic_write(int reg, u_int val)
{
	char *addr = (void *)(openpic_base + reg);

	if (openpic_big_endian)
		out32(addr, val);
	else
		out32rb(addr, val);
d516 1
a516 26
openpic_enable_irq_mask(int irq_mask)
{
	int irq;
	for ( irq = 0; irq <= o_virq_max; irq++) {
		if (irq_mask & (1 << irq))
			openpic_enable_irq(o_hwirq[irq]);
		else
			openpic_disable_irq(o_hwirq[irq]);
	}
}

void
openpic_set_enable_irq(int irq, int type)
{
	u_int x;

	x = openpic_read(OPENPIC_SRC_VECTOR(irq));
	x &= ~(OPENPIC_IMASK|OPENPIC_SENSE_LEVEL|OPENPIC_SENSE_EDGE);
	if (type == IST_LEVEL)
		x |= OPENPIC_SENSE_LEVEL;
	else
		x |= OPENPIC_SENSE_EDGE;
	openpic_write(OPENPIC_SRC_VECTOR(irq), x);
}
void
openpic_enable_irq(int irq)
d519 1
d521 2
a522 3
	x = openpic_read(OPENPIC_SRC_VECTOR(irq));
	x &= ~(OPENPIC_IMASK|OPENPIC_SENSE_LEVEL|OPENPIC_SENSE_EDGE);
	if (o_intrtype[o_virq[irq]] == IST_LEVEL)
d526 2
d542 1
a542 1
openpic_set_priority(int cpu, int pri)
d544 2
a545 19
	u_int x;

	x = openpic_read(OPENPIC_CPU_PRIORITY(cpu));
	x &= ~OPENPIC_CPU_PRIORITY_MASK;
	x |= pri;
	openpic_write(OPENPIC_CPU_PRIORITY(cpu), x);
}

int
openpic_read_irq(int cpu)
{
	return openpic_read(OPENPIC_IACK(cpu)) & OPENPIC_VECTOR_MASK;
}

void
openpic_eoi(int cpu)
{
	openpic_write(OPENPIC_EOI(cpu), 0);
	openpic_read(OPENPIC_EOI(cpu));
a548 1

a562 1
		
d569 1
a569 1
ext_intr_openpic()
d572 2
a573 3
	int irq, realirq;
	int r_imen;
	int pcpl, ocpl;
d575 4
d582 2
a583 1
	realirq = openpic_read_irq(ci->ci_cpuid);
d585 5
a589 1
	while (realirq != 255) {
d591 1
a591 1
		if (realirq == IPI_VECTOR_NOP) {
d594 1
a594 1
			realirq = openpic_read_irq(ci->ci_cpuid);
d597 1
a597 1
		if (realirq == IPI_VECTOR_DDB) {
d601 1
a601 1
			realirq = openpic_read_irq(ci->ci_cpuid);
d605 1
d607 6
a612 1
		irq = o_virq[realirq];
d614 9
a622 1
		/* XXX check range */
d624 6
a629 11
		r_imen = 1 << irq;

		if ((pcpl & r_imen) != 0) {
			/* Masked! Mark this as pending. */
			ci->ci_ipending |= r_imen;
			openpic_enable_irq_mask(~imask[o_intrmaxlvl[realirq]]);
			openpic_eoi(ci->ci_cpuid);
		} else {
			openpic_enable_irq_mask(~imask[o_intrmaxlvl[realirq]]);
			openpic_eoi(ci->ci_cpuid);
			ocpl = splraise(imask[o_intrmaxlvl[realirq]]);
d631 2
a632 8
			ih = o_intrhand[irq];
			while (ih) {
				ppc_intr_enable(1);

				KERNEL_LOCK();
				if ((*ih->ih_fun)(ih->ih_arg))
					ih->ih_count.ec_count++;
				KERNEL_UNLOCK();
d634 1
a634 12
				(void)ppc_intr_disable();
				ih = ih->ih_next;
			}

			uvmexp.intrs++;
			__asm__ volatile("":::"memory"); /* don't reorder.... */
			ci->ci_cpl = ocpl;
			__asm__ volatile("":::"memory"); /* don't reorder.... */
			openpic_enable_irq_mask(~pcpl);
		}

		realirq = openpic_read_irq(ci->ci_cpuid);
d636 1
d645 2
d649 3
d654 1
a654 1
	for (irq = 0; irq < 255; irq++)
d656 5
a660 1
	openpic_set_priority(0, 15);
d667 1
a667 3
	/* send all interrupts to cpu 0 */
	for (irq = 0; irq < ICU_LEN; irq++)
		openpic_write(OPENPIC_IDEST(irq), 1 << 0);
d677 11
d701 1
a711 4
	/* XXX set spurious intr vector */

	openpic_set_priority(0, 0);

d718 3
a720 2
	for (irq = 0; irq < ICU_LEN; irq++)
		openpic_disable_irq(irq);
d722 3
a724 1
	install_extint(ext_intr_openpic);
d726 1
a742 1

d744 1
a744 1
openpic_ipi_ddb(void)
d746 1
a748 1

@


1.47
log
@how about i commit what was actually approved? wrong tree, bad todd ;-(
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.46 2008/08/24 23:44:44 todd Exp $	*/
d78 8
a85 1
#define IPI_VECTOR	64
d94 1
d152 3
a161 4
	extern intr_establish_t *intr_establish_func;
	extern intr_disestablish_t *intr_disestablish_func;
	extern intr_establish_t *mac_intr_establish_func;
	extern intr_disestablish_t *mac_intr_disestablish_func;
d181 3
d194 1
d671 1
a671 1
openpic_send_ipi(int cpu)
d673 13
a685 1
	openpic_write(OPENPIC_IPI(curcpu()->ci_cpuid, 0), 1 << cpu);
d705 2
a706 1
		if (realirq == IPI_VECTOR) {
d711 7
d793 1
d796 1
a796 1
	x |= (15 << OPENPIC_PRIORITY_SHIFT) | IPI_VECTOR;
d798 14
d844 8
@


1.46
log
@o implement proper volume control table based on chipset docs
o attempt to make record work (but silence for now)
from drahn@@, ok maja@@, drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.45 2008/05/04 20:54:22 drahn Exp $	*/
d78 1
a78 8
#define IPI_VECTOR_DDB 64
#define IPI_VECTOR_NOP 65
#ifdef MULTIPROCESSOR
static struct evcount ipi_ddb[2];
static struct evcount ipi_nop[2];
static int ipi_nopirq = IPI_VECTOR_NOP;
static int ipi_ddbirq = IPI_VECTOR_DDB;
#endif
a88 1
void openpic_ipi_ddb(void);
a666 3

/* XXX */ extern long hostid;

d682 1
a682 8
		if (realirq == IPI_VECTOR_NOP) {
			ipi_nop[ci->ci_cpuid].ec_count++;
			openpic_eoi(ci->ci_cpuid);
			realirq = openpic_read_irq(ci->ci_cpuid);
			continue;
		}
		if (realirq == IPI_VECTOR_DDB) {
			ipi_ddb[ci->ci_cpuid].ec_count++;
a683 1
			openpic_ipi_ddb();
d702 1
a703 1
			openpic_eoi(ci->ci_cpuid);
d764 1
a764 1
	x |= (15 << OPENPIC_PRIORITY_SHIFT) | IPI_VECTOR_NOP;
a765 14

	evcount_attach(&ipi_nop[0], "ipi_nop0", (void *)&ipi_nopirq,
	    &evcount_intr); 
	evcount_attach(&ipi_nop[1], "ipi_nop1", (void *)&ipi_nopirq,
	    &evcount_intr);

	x = openpic_read(OPENPIC_IPI_VECTOR(1));
	x &= ~(OPENPIC_IMASK | OPENPIC_PRIORITY_MASK | OPENPIC_VECTOR_MASK);
	x |= (15 << OPENPIC_PRIORITY_SHIFT) | IPI_VECTOR_DDB;
	openpic_write(OPENPIC_IPI_VECTOR(1), x);
	evcount_attach(&ipi_ddb[0], "ipi_ddb0", (void *)&ipi_ddbirq,
	    &evcount_intr);
	evcount_attach(&ipi_ddb[1], "ipi_ddb1", (void *)&ipi_ddbirq,
	    &evcount_intr);
a796 26
}

void
openpic_ipi_ddb()
{
	printf("ipi_ddb() called\n");
	Debugger();
}

void
ppc_send_ipi(struct cpu_info *ci, int id)
{
	printf("sending IPI %d to %d\n", id, ci->ci_cpuid);
	switch (id) {
	case PPC_IPI_NOP:
		id = 0;
		break;
	case PPC_IPI_DDB:
		id = 1;
		break;
	default:
		printf("invalid ipi send to cpu %d %d\n", ci->ci_cpuid, id);
		return;
	}

	openpic_write(OPENPIC_IPI(curcpu()->ci_cpuid, id), 1 << ci->ci_cpuid);
@


1.45
log
@Manage interrupts based on priority better, still working on this...
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.44 2008/05/03 22:44:56 drahn Exp $	*/
d78 8
a85 1
#define IPI_VECTOR	64
d96 1
d675 3
d693 8
a700 1
		if (realirq == IPI_VECTOR) {
d702 1
d721 1
a722 1
			ocpl = splraise(imask[o_intrmaxlvl[realirq]]);
d783 1
a783 1
	x |= (15 << OPENPIC_PRIORITY_SHIFT) | IPI_VECTOR;
d785 14
d830 26
@


1.44
log
@Rework the interrupt calculation masks, a bit easier to follow (not so wrong).
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.43 2008/05/01 08:25:32 kettenis Exp $	*/
a63 1
unsigned int imen_o = 0xffffffff;
d361 3
a363 1
	int imen_n = 0;
d368 1
d381 8
a397 1
			imen_n |=  (1 << o_virq[irq]);
d400 4
a408 1
	imen_o = ~imen_n;
d453 1
d463 1
d466 1
a466 1
	if (ci->ci_iactive)
d469 1
a469 2
	ci->ci_iactive = 1;
	pcpl = splhigh();		/* Turn off all */
d471 1
a473 2
	imen_o &= ~hwpend;
	openpic_enable_irq_mask(~imen_o);
d476 10
a485 5
		irq = 31 - cntlzw(hwpend);
		hwpend &= ~(1L << irq);
		ih = o_intrhand[irq];
		while(ih) {
			ppc_intr_enable(1);
d487 4
a490 4
			KERNEL_LOCK();
			if ((*ih->ih_fun)(ih->ih_arg))
				ih->ih_count.ec_count++;
			KERNEL_UNLOCK();
d492 4
a495 3
			(void)ppc_intr_disable();
			
			ih = ih->ih_next;
d497 2
d500 3
d504 14
a517 1
	/*out32rb(INT_ENABLE_REG, ~imen_o);*/
d522 2
d527 2
d535 1
d538 1
d542 1
d544 1
d548 2
d553 2
a556 1
	ci->ci_ipending &= pcpl;
d558 2
a559 2
	ppc_intr_enable(s);
	ci->ci_iactive = 0;
d698 1
a698 1
			openpic_disable_irq(realirq);
d701 1
a701 1
			openpic_disable_irq(realirq);
d722 1
a722 1
			openpic_enable_irq(realirq);
a782 1

@


1.43
log
@Implement a nop IPI to signal other CPUs.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.42 2008/04/26 22:37:41 drahn Exp $	*/
d61 1
a61 1
int o_intrtype[ICU_LEN], o_intrmask[ICU_LEN], o_intrlevel[ICU_LEN];
d69 1
a69 1
static void intr_calculatemasks(void);
d277 1
a277 1
	intr_calculatemasks();
d321 1
a321 1
	intr_calculatemasks();
d355 3
a357 2
static void
intr_calculatemasks()
d359 4
a362 2
	int irq, level;
	struct intrhand *q;
a363 1
	/* First, figure out which levels each IRQ uses. */
d365 11
a375 5
		register int levels = 0;
		for (q = o_intrhand[irq]; q; q = q->ih_next)
			levels |= 1 << q->ih_level;
		o_intrlevel[irq] = levels;
	}
d377 1
a377 8
	/* Then figure out which IRQs use each level. */
	for (level = IPL_NONE; level < IPL_NUM; level++) {
		register int irqs = 0;
		for (irq = 0; irq < ICU_LEN; irq++)
			if (o_intrlevel[irq] & (1 << level))
				irqs |= 1 << irq;
		imask[level] = irqs | SINT_MASK;
	}
d379 2
a380 11
	/*
	 * There are tty, network and disk drivers that use free() at interrupt
	 * time, so vm > (tty | net | bio).
	 *
	 * Enforce a hierarchy that gives slow devices a better chance at not
	 * dropping data.
	 */
	imask[IPL_NET] |= imask[IPL_BIO];
	imask[IPL_TTY] |= imask[IPL_NET];
	imask[IPL_VM] |= imask[IPL_TTY];
	imask[IPL_CLOCK] |= imask[IPL_VM] | SPL_CLOCK;
d382 8
a389 12
	/*
	 * These are pseudo-levels.
	 */
	imask[IPL_NONE] = 0x00000000;
	imask[IPL_HIGH] = 0xffffffff;

	/* And eventually calculate the complete masks. */
	for (irq = 0; irq < ICU_LEN; irq++) {
		register int irqs = 1 << irq;
		for (q = o_intrhand[irq]; q; q = q->ih_next)
			irqs |= imask[q->ih_level];
		o_intrmask[irq] = irqs | SINT_MASK;
d391 3
a393 13

	/* Lastly, determine which IRQs are actually in use. */
	{
		register int irqs = 0;
		for (irq = 0; irq < ICU_LEN; irq++) {
			if (o_intrhand[irq]) {
				irqs |= 1 << irq;
				openpic_enable_irq(o_hwirq[irq]);
			} else {
				openpic_disable_irq(o_hwirq[irq]);
			}
		}
		imen_o = ~irqs;
d395 2
d656 1
a656 1
			ocpl = splraise(o_intrmask[irq]);
@


1.42
log
@Changes to get closer to SMP.
add biglock before interrupt calls into the kernel.
switch the clock to using cpuinfo variables instead of globals
move cpu_switchto into C code so that on multiprocessor the FPU
and Altivec can be saved before switching CPUs.
add a lock into pmap when modifying the hash table.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.41 2007/10/27 22:37:03 kettenis Exp $	*/
d78 3
d630 10
d651 1
a651 1
	realirq = openpic_read_irq(0);
d654 8
d672 1
a672 1
			openpic_eoi(0);
d675 1
a675 1
			openpic_eoi(0);
d698 1
a698 1
		realirq = openpic_read_irq(0);
d732 8
@


1.41
log
@Grab kernel lock before calling interrupt handlers.

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.40 2007/05/29 18:10:43 miod Exp $	*/
d487 1
d490 1
d503 1
d505 1
d514 1
d516 1
d521 1
d523 1
@


1.40
log
@Use atomic operations to operate on netisr, instead of clearing it at splhigh.
This changes nothing on legacy architectures, but is a bit faster (and simpler)
on the interesting ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.39 2007/05/10 15:28:09 drahn Exp $	*/
d653 1
d656 1
@


1.39
log
@The road to supporting bigendian openpic starts.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.38 2007/04/22 22:31:14 deraadt Exp $	*/
d49 1
d505 2
a506 2
			int pisr = netisr;
			netisr = 0;
d508 4
a511 1
			softnet(pisr);
@


1.38
log
@better interrupt names for vmstat -iz; ok miod gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.37 2007/03/20 20:59:53 kettenis Exp $	*/
d142 1
d152 5
d161 2
a162 1
	printf(": version 0x%x", openpic_read(OPENPIC_VENDOR_ID));
d525 4
a528 1
	return in32rb(addr);
d536 4
a539 1
	out32rb(addr, val);
@


1.37
log
@Move macppc to __HAVE_CPUINFO, and make locore.S and trap.c suitable for
MULTIPROCESSOR.  From now on sprg0 holds a pointer to struct cpuinfo, which
is used to spill registers to during trap instead of the globals we used to
use for that purpose.  Bits and pieces from NetBSD.  Help from drahn@@ and art@@.
Tested by xsa@@, thib@@, miod@@, gwk@@, deraadt@@.

ok drahn@@, gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.36 2007/03/01 15:00:57 mickey Exp $	*/
d172 1
a172 1
		IPL_HIGH, openpic_prog_button, (void *)0x37, "prog button");
@


1.36
log
@proper softint treatment (that get missed otherwise); found and tested by mpf@@ on pppoe; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.35 2006/06/19 22:42:33 miod Exp $	*/
d454 1
a459 1
	static int processing;
d461 1
a461 1
	if (processing)
d464 1
a464 1
	processing = 1;
d468 1
a468 1
	hwpend = ipending & ~pcpl;	/* Do now unmasked pendings */
d491 2
a492 2
		if((ipending & SINT_CLOCK) & ~pcpl) {
			ipending &= ~SINT_CLOCK;
d495 1
a495 1
		if((ipending & SINT_NET) & ~pcpl) {
d499 1
a499 1
			ipending &= ~SINT_NET;
d502 2
a503 2
		if((ipending & SINT_TTY) & ~pcpl) {
			ipending &= ~SINT_TTY;
d506 3
a508 3
	} while (ipending & (SINT_NET|SINT_CLOCK|SINT_TTY) & ~pcpl);
	ipending &= pcpl;
	cpl = pcpl;	/* Don't use splx... we are here already! */
d510 1
a510 1
	processing = 0;
d605 1
d611 1
a611 1
	pcpl = cpl;
d623 2
a624 1
			ipending |= r_imen;	/* Masked! Mark this as pending */
d645 1
a645 1
			cpl = ocpl;
@


1.35
log
@Be more strict in the probe routines and actually check ca_nintr and
ca_nreg are large enough for our greedy needs; tweaks and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.34 2006/03/12 02:49:50 brad Exp $	*/
d506 1
a506 1
	} while (ipending & (SINT_NET|SINT_CLOCK|SINT_TTY) & ~cpl);
@


1.34
log
@IPL_IMP -> IPL_VM

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.33 2005/11/17 15:03:51 drahn Exp $	*/
d120 12
a131 7
	if (strcmp(ca->ca_name, "interrupt-controller") == 0 ||
	    strcmp(ca->ca_name, "mpic") == 0) {
		OF_getprop(ca->ca_node, "device_type", type, sizeof(type));
		if (strcmp(type, "open-pic") == 0)
			return 1;
	}
	return 0;
@


1.33
log
@add attachment for openpic behind memc, for newer G5 systems.
only attaches a parent openpic, not a slave openpic. ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.32 2005/10/16 04:30:43 drahn Exp $	*/
d364 1
a364 1
	 * time, so imp > (tty | net | bio).
d371 2
a372 2
	imask[IPL_IMP] |= imask[IPL_TTY];
	imask[IPL_CLOCK] |= imask[IPL_IMP] | SPL_CLOCK;
@


1.32
log
@print the hardware irq number, not the bogus internal number for 'vmstat -i'
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.31 2005/10/09 03:50:11 drahn Exp $	*/
d111 1
d116 4
d148 1
a148 1
			ca->ca_reg[0], 0x22000);
@


1.31
log
@While running pending interrupts, enable external interrupt, this way
low priority interrupts do not starve high priority.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.30 2005/09/30 19:51:52 deraadt Exp $	*/
d266 2
a267 1
	evcount_attach(&ih->ih_count, name, (void *)&ih->ih_irq, &evcount_intr);
@


1.30
log
@i hate panic messages which do not print the value that was in error
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.29 2005/09/26 19:52:08 kettenis Exp $	*/
d466 2
d470 3
@


1.29
log
@Consider nodes named "mpic" as potential open-pic candidates.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.28 2004/07/14 11:36:16 miod Exp $	*/
d410 1
a410 1
		panic("invalid irq");
@


1.28
log
@Do not forget to count interrupts if they have been delayed; ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.27 2004/06/28 02:49:10 aaron Exp $	*/
d115 2
a116 1
	if (strcmp(ca->ca_name, "interrupt-controller") == 0 ) {
d118 1
a118 1
		if (strcmp(type,  "open-pic") == 0)
d638 1
@


1.27
log
@Use new event counter API for interrupt counting on macppc.  drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.26 2004/05/08 22:10:12 miod Exp $	*/
d465 2
a466 1
			(*ih->ih_fun)(ih->ih_arg);
@


1.26
log
@Remove spurious initialization; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.25 2003/10/19 21:57:35 drahn Exp $	*/
a192 3
void nameinterrupt( int replace, char *newstr);


a209 1
	nameinterrupt(irq, name);
a261 1
	ih->ih_count = 0;
d265 1
d294 2
a597 1
		intrcnt[realirq]++;
d616 2
a617 1
				(*ih->ih_fun)(ih->ih_arg);
@


1.25
log
@Use defines instead of magic constants for more IPL_ stuff, also sort
the IPL_ values by priority, not somewhat random values. No unmodified
code relied on the order of these defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.24 2003/10/16 03:54:48 deraadt Exp $	*/
d397 1
a397 1
int o_virq_inited = 0;
a404 8
	int i;

	if (o_virq_inited == 0) {
		o_virq_max = 0;
		for (i = 0; i < ICU_LEN; i++)
			o_virq[i] = 0;
		o_virq_inited = 1;
	}
@


1.24
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.23 2003/10/16 03:31:25 drahn Exp $	*/
d349 1
a349 1
	for (level = 0; level < 5; level++) {
@


1.23
log
@more ANSI/KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.22 2003/08/07 16:08:58 drahn Exp $	*/
d97 1
a97 1
struct cfattach openpic_ca = { 
d154 1
a154 1
	
d312 1
a312 1
        case IST_NONE:
d314 1
a314 1
        case IST_PULSE:
d316 1
a316 1
        case IST_EDGE:
d318 1
a318 1
        case IST_LEVEL:
d590 2
a591 2
        openpic_write(OPENPIC_EOI(cpu), 0);
        openpic_read(OPENPIC_EOI(cpu));
d615 1
a615 1
			ipending |= r_imen;     /* Masked! Mark this as pending */
d644 1
a644 1
	splx(pcpl);     /* Process pendings. */
d649 26
a674 2
        int irq;
        u_int x;
d676 1
a676 31
        /* disable all interrupts */
        for (irq = 0; irq < 255; irq++)
                openpic_write(OPENPIC_SRC_VECTOR(irq), OPENPIC_IMASK);
        openpic_set_priority(0, 15);

        /* we don't need 8259 pass through mode */
        x = openpic_read(OPENPIC_CONFIG);
        x |= OPENPIC_CONFIG_8259_PASSTHRU_DISABLE;
        openpic_write(OPENPIC_CONFIG, x);

        /* send all interrupts to cpu 0 */
        for (irq = 0; irq < ICU_LEN; irq++)
                openpic_write(OPENPIC_IDEST(irq), 1 << 0);
        for (irq = 0; irq < ICU_LEN; irq++) {
                x = irq;
                x |= OPENPIC_IMASK;
                x |= OPENPIC_POLARITY_POSITIVE;
                x |= OPENPIC_SENSE_LEVEL;
                x |= 8 << OPENPIC_PRIORITY_SHIFT;
                openpic_write(OPENPIC_SRC_VECTOR(irq), x);
        }

        /* XXX set spurious intr vector */

        openpic_set_priority(0, 0);

        /* clear all pending interrunts */
        for (irq = 0; irq < ICU_LEN; irq++) {
                openpic_read_irq(0);
                openpic_eoi(0);
        }
d678 5
a682 2
        for (irq = 0; irq < ICU_LEN; irq++)
                openpic_disable_irq(irq);
d684 4
a687 1
        install_extint(ext_intr_openpic);
@


1.22
log
@Allow nested interrupts in the openpic interrupt controller, tested by
brad@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.21 2003/07/02 21:30:13 drahn Exp $	*/
d108 1
a108 4
openpic_match(parent, cf, aux) 
	struct device *parent;
	void *cf;
	void *aux;
d117 1
a117 1
		if (strcmp(type,  "open-pic") == 0) {
a118 1
		}
d133 1
a133 3
openpic_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d186 2
a187 3
int
fakeintr(arg)
	void *arg;
d200 2
a201 8
openpic_intr_establish(lcv, irq, type, level, ih_fun, ih_arg, name)
	void * lcv;
	int irq;
	int type;
	int level;
	int (*ih_fun)(void *);
	void *ih_arg;
	char *name;
d279 1
a279 3
openpic_intr_disestablish(lcp, arg)
	void *lcp;
	void *arg;
d308 1
a308 2
intr_typename(type)
	int type;
d312 1
a312 1
        case IST_NONE :
d402 1
a402 2
mapirq(irq)
	int irq;
d409 1
a409 1
		for (i = 0; i < ICU_LEN; i++) {
a410 1
		}
d415 1
a415 1
	if (o_virq[irq] != 0) {
a416 1
	}
d420 1
d439 1
a439 2
cntlzw(x)
	int x;
d506 1
a506 2
openpic_read(reg)
	int reg;
d514 1
a514 3
openpic_write(reg, val)
	int reg;
	u_int val;
d522 1
a522 2
openpic_enable_irq_mask(irq_mask)
int irq_mask;
d526 1
a526 1
		if (irq_mask & (1 << irq)) {
d528 1
a528 1
		} else {
a529 1
		}
d534 1
a534 3
openpic_set_enable_irq(irq, type)
	int irq;
	int type;
d540 1
a540 1
	if (type == IST_LEVEL) {
d542 1
a542 1
	} else {
a543 1
	}
d547 1
a547 2
openpic_enable_irq(irq)
	int irq;
d553 1
a553 1
	if (o_intrtype[o_virq[irq]] == IST_LEVEL) {
d555 1
a555 1
	} else {
a556 1
	}
d561 1
a561 2
openpic_disable_irq(irq)
	int irq;
d571 1
a571 2
openpic_set_priority(cpu, pri)
        int cpu, pri;
d582 1
a582 2
openpic_read_irq(cpu)
	int cpu;
d588 1
a588 2
openpic_eoi(cpu)
        int cpu;
@


1.21
log
@Reduce the amount of asm code in powerpc/macppc by replacing it with
inlined functions, helps improve readability and fix a couple of bugs.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.20 2003/06/02 23:27:49 millert Exp $	*/
a65 2
struct evcnt o_evirq[ICU_LEN];

d79 2
a80 1
void openpic_enable_irq(int, int);
d405 1
a405 2
				openpic_enable_irq(o_hwirq[irq],
				    o_intrtype[irq]);
a496 2

		o_evirq[o_hwirq[irq]].ev_count++;
d550 1
a550 1
			openpic_enable_irq(o_hwirq[irq], o_intrtype[irq]);
d556 1
d558 1
a558 1
openpic_enable_irq(irq, type)
d573 15
d632 1
a632 1
	int pcpl;
d650 1
d652 3
a654 1
			splraise(o_intrmask[irq]);
d658 2
d661 2
d667 4
a670 1
			o_evirq[realirq].ev_count++;
a672 2
		openpic_eoi(0);

d675 1
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.19 2003/02/12 22:40:59 jason Exp $	*/
d477 1
a477 1
	int emsr, dmsr;
d485 1
a485 3
	asm volatile("mfmsr %0" : "=r"(emsr));
	dmsr = emsr & ~PSL_EE;
	asm volatile("mtmsr %0" :: "r"(dmsr));
d524 1
a524 1
	asm volatile("mtmsr %0" :: "r"(emsr));
@


1.19
log
@separate evirq into macintr and openpic versions (they just -happened- to be
the same size).  ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.18 2002/09/15 09:01:58 deraadt Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.18
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.16 2002/03/14 03:15:55 millert Exp $	*/
d70 1
a70 1
struct evcnt evirq[ICU_LEN];
d506 1
a506 1
		evirq[o_hwirq[irq]].ev_count++;
d654 1
a654 1
			evirq[realirq].ev_count++;
@


1.17
log
@KNF
@
text
@d501 1
a501 1
		while (ih) {
d512 1
a512 1
		if ((ipending & SINT_CLOCK) & ~pcpl) {
d516 1
a516 1
		if ((ipending & SINT_NET) & ~pcpl) {
d523 1
a523 1
		if ((ipending & SINT_TTY) & ~pcpl) {
@


1.16
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.15 2002/03/14 01:26:36 millert Exp $	*/
d501 1
a501 1
		while(ih) {
d512 1
a512 1
		if((ipending & SINT_CLOCK) & ~pcpl) {
d516 1
a516 1
		if((ipending & SINT_NET) & ~pcpl) {
d523 1
a523 1
		if((ipending & SINT_TTY) & ~pcpl) {
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.14 2002/03/08 20:33:43 drahn Exp $	*/
d172 1
a172 1
		IPL_HIGH, openpic_prog_button, (void*)0x37, "prog button");
@


1.14
log
@Remove the code which reenables interrupts in these interrupt controllers,
they do not appear to be capable of handling all possible nested interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.14 2002/03/08 20:20:03 drahn Exp $	*/
d72 7
a78 7
static int fakeintr __P((void *));
static char *intr_typename __P((int type));
static void intr_calculatemasks __P((void));
static __inline int cntlzw __P((int x));
static int mapirq __P((int irq));
int openpic_prog_button __P((void *arg));
void openpic_enable_irq_mask __P((int irq_mask));
d83 8
a90 8
static __inline u_int openpic_read __P((int));
static __inline void openpic_write __P((int, u_int));
void openpic_enable_irq __P((int, int));
void openpic_disable_irq __P((int));
void openpic_init __P((void));
void openpic_set_priority __P((int, int));
static __inline int openpic_read_irq __P((int));
static __inline void openpic_eoi __P((int));
d96 5
a100 5
int	openpic_match __P((struct device *parent, void *cf, void *aux));
void	openpic_attach __P((struct device *, struct device *, void *));
void	openpic_do_pending_int __P((void));
void	openpic_collect_preconf_intr __P((void));
void	ext_intr_openpic __P((void));
d137 1
a137 1
	int (*ih_fun) __P((void *)), void *ih_arg, char *name);
d139 1
a139 1
void openpic_collect_preconf_intr __P((void));
d217 1
a217 1
	int (*ih_fun) __P((void *));
@


1.13
log
@Do not use -1 as an unused entry, 0 is already reserved for invalid/unused.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.12 2002/03/02 17:27:18 drahn Exp $	*/
a646 5
			/*
			 * enable interrupts for the duration of the
			 * interrupt handler 
			 */
			ppc_intr_enable(1);
a651 1
			ppc_intr_disable();
a661 1
	ppc_intr_enable(1);
a662 1
	ppc_intr_disable();
@


1.12
log
@If two drivers register the same hardware irq, they should get
the same virtual irq as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.11 2002/03/02 17:17:37 drahn Exp $	*/
d433 1
a433 1
			o_virq[i] = -1;
d439 1
a439 1
	if (o_virq[irq] != -1) {
@


1.11
log
@These two drivers were incorrectly sharing variables, sometimes expecting
them to be intialized by the other. also remove static variables
and rename them so they are accessable via ddb.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.10 2002/01/26 15:22:52 drahn Exp $	*/
d419 1
d428 14
@


1.10
log
@splclock() should block SPL_BIO - SPL_IMP.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.9 2002/01/21 05:11:29 drahn Exp $	*/
d64 5
a68 5
static int intrtype[ICU_LEN], intrmask[ICU_LEN], intrlevel[ICU_LEN];
static struct intrhand *intrhand[ICU_LEN] = { 0 };
static int hwirq[ICU_LEN], virq[ICU_LEN];
unsigned int imen /* = 0xffffffff */; /* XXX */
static int virq_max = 0;
d207 1
d245 1
a245 1
	switch (intrtype[irq]) {
d247 1
a247 1
		intrtype[irq] = type;
d251 1
a251 1
		if (type == intrtype[irq])
d256 1
a256 1
			    intr_typename(intrtype[irq]),
d266 1
a266 1
	for (p = &intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
d312 1
a312 1
	for (p = &intrhand[irq]; (q = *p) != NULL && q != ih; p = &q->ih_next)
d322 2
a323 2
	if (intrhand[irq] == NULL)
		intrtype[irq] = IST_NONE;
d364 1
a364 1
		for (q = intrhand[irq]; q; q = q->ih_next)
d366 1
a366 1
		intrlevel[irq] = levels;
d373 1
a373 1
			if (intrlevel[irq] & (1 << level))
d399 1
a399 1
		for (q = intrhand[irq]; q; q = q->ih_next)
d401 1
a401 1
		intrmask[irq] = irqs | SINT_MASK;
d408 1
a408 1
			if (intrhand[irq]) {
d410 2
a411 1
				openpic_enable_irq(hwirq[irq], intrtype[irq]);
d413 1
a413 1
				openpic_disable_irq(hwirq[irq]);
d416 1
a416 1
		imen = ~irqs;
d430 2
a431 2
	virq_max++;
	v = virq_max;
d435 2
a436 2
	hwirq[v] = irq;
	virq[irq] = v;
d479 2
a480 2
	imen &= ~hwpend;
	openpic_enable_irq_mask(~imen);
d485 1
a485 1
		ih = intrhand[irq];
d491 1
a491 1
		evirq[hwirq[irq]].ev_count++;
d494 1
a494 1
	/*out32rb(INT_ENABLE_REG, ~imen);*/
d543 1
a543 1
	for ( irq = 0; irq <= virq_max; irq++) {
d545 1
a545 1
			openpic_enable_irq(hwirq[irq], intrtype[irq]);
d547 1
a547 1
			openpic_disable_irq(hwirq[irq]);
d619 1
a619 1
		irq = virq[realirq];
d630 1
a630 1
			splraise(intrmask[irq]);
d637 1
a637 1
			ih = intrhand[irq];
@


1.9
log
@Respect db_console for "progammer button", for improved physical security.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.8 2002/01/17 16:17:23 drahn Exp $	*/
d380 1
a380 4
	 */
	imask[IPL_IMP] |= imask[IPL_TTY] | imask[IPL_NET] | imask[IPL_BIO];

	/*
a383 1
	imask[IPL_TTY] |= imask[IPL_NET] | imask[IPL_BIO];
d385 3
@


1.8
log
@Allow nested interrupts on the mac interrupt controllers, previously
the external interrupt was never enabled during interrupt handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.7 2001/11/06 19:53:15 miod Exp $	*/
d51 1
d708 2
a709 1
        Debugger();
@


1.7
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.6 2001/10/03 14:07:05 drahn Exp $	*/
d612 1
a612 1
	pcpl = splhigh();       /* Turn off all */
d628 7
d640 1
d651 1
d653 1
@


1.7.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.10 2002/01/26 15:22:52 drahn Exp $	*/
a50 1
#include <ddb/db_var.h>
d379 4
a382 1
	 *
d386 1
a387 3
	imask[IPL_TTY] |= imask[IPL_NET];
	imask[IPL_IMP] |= imask[IPL_TTY];
	imask[IPL_CLOCK] |= imask[IPL_IMP] | SPL_CLOCK;
d612 1
a612 1
	pcpl = cpl;
a627 7
			splraise(intrmask[irq]);

			/*
			 * enable interrupts for the duration of the
			 * interrupt handler 
			 */
			ppc_intr_enable(1);
a632 1
			ppc_intr_disable();
a642 1
	ppc_intr_enable(1);
a643 1
	ppc_intr_disable();
d697 1
a697 2
	if (db_console)
		Debugger();
@


1.7.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.7.2.1 2002/01/31 22:55:14 niklas Exp $	*/
d64 5
a68 5
int o_intrtype[ICU_LEN], o_intrmask[ICU_LEN], o_intrlevel[ICU_LEN];
struct intrhand *o_intrhand[ICU_LEN] = { 0 };
int o_hwirq[ICU_LEN], o_virq[ICU_LEN];
unsigned int imen_o = 0xffffffff;
int o_virq_max;
d72 7
a78 7
static int fakeintr(void *);
static char *intr_typename(int type);
static void intr_calculatemasks(void);
static __inline int cntlzw(int x);
static int mapirq(int irq);
int openpic_prog_button(void *arg);
void openpic_enable_irq_mask(int irq_mask);
d83 8
a90 8
static __inline u_int openpic_read(int);
static __inline void openpic_write(int, u_int);
void openpic_enable_irq(int, int);
void openpic_disable_irq(int);
void openpic_init(void);
void openpic_set_priority(int, int);
static __inline int openpic_read_irq(int);
static __inline void openpic_eoi(int);
d96 5
a100 5
int	openpic_match(struct device *parent, void *cf, void *aux);
void	openpic_attach(struct device *, struct device *, void *);
void	openpic_do_pending_int(void);
void	openpic_collect_preconf_intr(void);
void	ext_intr_openpic(void);
d137 1
a137 1
	int (*ih_fun)(void *), void *ih_arg, char *name);
d139 1
a139 1
void openpic_collect_preconf_intr(void);
d172 1
a172 1
		IPL_HIGH, openpic_prog_button, (void *)0x37, "prog button");
a206 1

d216 1
a216 1
	int (*ih_fun)(void *);
d244 1
a244 1
	switch (o_intrtype[irq]) {
d246 1
a246 1
		o_intrtype[irq] = type;
d250 1
a250 1
		if (type == o_intrtype[irq])
d255 1
a255 1
			    intr_typename(o_intrtype[irq]),
d265 1
a265 1
	for (p = &o_intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
d311 1
a311 1
	for (p = &o_intrhand[irq]; (q = *p) != NULL && q != ih; p = &q->ih_next)
d321 2
a322 2
	if (o_intrhand[irq] == NULL)
		o_intrtype[irq] = IST_NONE;
d363 1
a363 1
		for (q = o_intrhand[irq]; q; q = q->ih_next)
d365 1
a365 1
		o_intrlevel[irq] = levels;
d372 1
a372 1
			if (o_intrlevel[irq] & (1 << level))
d398 1
a398 1
		for (q = o_intrhand[irq]; q; q = q->ih_next)
d400 1
a400 1
		o_intrmask[irq] = irqs | SINT_MASK;
d407 1
a407 1
			if (o_intrhand[irq]) {
d409 1
a409 2
				openpic_enable_irq(o_hwirq[irq],
				    o_intrtype[irq]);
d411 1
a411 1
				openpic_disable_irq(o_hwirq[irq]);
d414 1
a414 1
		imen_o = ~irqs;
a416 1
int o_virq_inited = 0;
a424 14
	int i;

	if (o_virq_inited == 0) {
		o_virq_max = 0;
		for (i = 0; i < ICU_LEN; i++) {
			o_virq[i] = 0;
		}
		o_virq_inited = 1;
	}

	/* irq in table already? */
	if (o_virq[irq] != 0) {
		return o_virq[irq];
	}
d428 2
a429 2
	o_virq_max++;
	v = o_virq_max;
d433 2
a434 2
	o_hwirq[v] = irq;
	o_virq[irq] = v;
d477 2
a478 2
	imen_o &= ~hwpend;
	openpic_enable_irq_mask(~imen_o);
d483 1
a483 1
		ih = o_intrhand[irq];
d489 1
a489 1
		evirq[o_hwirq[irq]].ev_count++;
d492 1
a492 1
	/*out32rb(INT_ENABLE_REG, ~imen_o);*/
d541 1
a541 1
	for ( irq = 0; irq <= o_virq_max; irq++) {
d543 1
a543 1
			openpic_enable_irq(o_hwirq[irq], o_intrtype[irq]);
d545 1
a545 1
			openpic_disable_irq(o_hwirq[irq]);
d617 1
a617 1
		irq = o_virq[realirq];
d628 1
a628 1
			splraise(o_intrmask[irq]);
d630 6
a635 1
			ih = o_intrhand[irq];
d640 1
d651 1
d653 1
@


1.7.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.7.2.2 2002/06/11 03:36:34 art Exp $	*/
@


1.7.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 1
a70 1
struct evcnt o_evirq[ICU_LEN];
d506 1
a506 1
		o_evirq[o_hwirq[irq]].ev_count++;
d654 1
a654 1
			o_evirq[realirq].ev_count++;
@


1.6
log
@Cleanup improperly shared code between the two interrupt drivers.
Pointed out by a7r.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.5 2001/09/28 04:13:12 drahn Exp $	*/
a49 1
#include <vm/vm.h>
@


1.6.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.6.4.2
log
@Merge in -current
@
text
@d50 1
@


1.6.4.3
log
@Merge in trunk
@
text
@a50 1
#include <ddb/db_var.h>
d63 5
a67 5
int o_intrtype[ICU_LEN], o_intrmask[ICU_LEN], o_intrlevel[ICU_LEN];
struct intrhand *o_intrhand[ICU_LEN] = { 0 };
int o_hwirq[ICU_LEN], o_virq[ICU_LEN];
unsigned int imen_o = 0xffffffff;
int o_virq_max;
a205 1

d243 1
a243 1
	switch (o_intrtype[irq]) {
d245 1
a245 1
		o_intrtype[irq] = type;
d249 1
a249 1
		if (type == o_intrtype[irq])
d254 1
a254 1
			    intr_typename(o_intrtype[irq]),
d264 1
a264 1
	for (p = &o_intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
d310 1
a310 1
	for (p = &o_intrhand[irq]; (q = *p) != NULL && q != ih; p = &q->ih_next)
d320 2
a321 2
	if (o_intrhand[irq] == NULL)
		o_intrtype[irq] = IST_NONE;
d362 1
a362 1
		for (q = o_intrhand[irq]; q; q = q->ih_next)
d364 1
a364 1
		o_intrlevel[irq] = levels;
d371 1
a371 1
			if (o_intrlevel[irq] & (1 << level))
d379 4
a382 1
	 *
d386 1
a387 3
	imask[IPL_TTY] |= imask[IPL_NET];
	imask[IPL_IMP] |= imask[IPL_TTY];
	imask[IPL_CLOCK] |= imask[IPL_IMP] | SPL_CLOCK;
d398 1
a398 1
		for (q = o_intrhand[irq]; q; q = q->ih_next)
d400 1
a400 1
		o_intrmask[irq] = irqs | SINT_MASK;
d407 1
a407 1
			if (o_intrhand[irq]) {
d409 1
a409 2
				openpic_enable_irq(o_hwirq[irq],
				    o_intrtype[irq]);
d411 1
a411 1
				openpic_disable_irq(o_hwirq[irq]);
d414 1
a414 1
		imen_o = ~irqs;
a416 1
int o_virq_inited = 0;
a424 14
	int i;

	if (o_virq_inited == 0) {
		o_virq_max = 0;
		for (i = 0; i < ICU_LEN; i++) {
			o_virq[i] = 0;
		}
		o_virq_inited = 1;
	}

	/* irq in table already? */
	if (o_virq[irq] != 0) {
		return o_virq[irq];
	}
d428 2
a429 2
	o_virq_max++;
	v = o_virq_max;
d433 2
a434 2
	o_hwirq[v] = irq;
	o_virq[irq] = v;
d477 2
a478 2
	imen_o &= ~hwpend;
	openpic_enable_irq_mask(~imen_o);
d483 1
a483 1
		ih = o_intrhand[irq];
d489 1
a489 1
		evirq[o_hwirq[irq]].ev_count++;
d492 1
a492 1
	/*out32rb(INT_ENABLE_REG, ~imen_o);*/
d541 1
a541 1
	for ( irq = 0; irq <= o_virq_max; irq++) {
d543 1
a543 1
			openpic_enable_irq(o_hwirq[irq], o_intrtype[irq]);
d545 1
a545 1
			openpic_disable_irq(o_hwirq[irq]);
d612 1
a612 1
	pcpl = cpl;
d617 1
a617 1
		irq = o_virq[realirq];
d628 1
a628 8
			splraise(o_intrmask[irq]);

			/*
			 * enable interrupts for the duration of the
			 * interrupt handler 
			 */
			ppc_intr_enable(1);
			ih = o_intrhand[irq];
a632 1
			ppc_intr_disable();
a642 1
	ppc_intr_enable(1);
a643 1
	ppc_intr_disable();
d697 1
a697 2
	if (db_console)
		Debugger();
@


1.6.4.4
log
@Merge in -current from about a week ago
@
text
@d72 7
a78 7
static int fakeintr(void *);
static char *intr_typename(int type);
static void intr_calculatemasks(void);
static __inline int cntlzw(int x);
static int mapirq(int irq);
int openpic_prog_button(void *arg);
void openpic_enable_irq_mask(int irq_mask);
d83 8
a90 8
static __inline u_int openpic_read(int);
static __inline void openpic_write(int, u_int);
void openpic_enable_irq(int, int);
void openpic_disable_irq(int);
void openpic_init(void);
void openpic_set_priority(int, int);
static __inline int openpic_read_irq(int);
static __inline void openpic_eoi(int);
d96 5
a100 5
int	openpic_match(struct device *parent, void *cf, void *aux);
void	openpic_attach(struct device *, struct device *, void *);
void	openpic_do_pending_int(void);
void	openpic_collect_preconf_intr(void);
void	ext_intr_openpic(void);
d137 1
a137 1
	int (*ih_fun)(void *), void *ih_arg, char *name);
d139 1
a139 1
void openpic_collect_preconf_intr(void);
d172 1
a172 1
		IPL_HIGH, openpic_prog_button, (void *)0x37, "prog button");
d217 1
a217 1
	int (*ih_fun)(void *);
d647 5
d657 1
d668 1
d670 1
@


1.6.4.5
log
@Sync the SMP branch with 3.3
@
text
@d70 1
a70 1
struct evcnt o_evirq[ICU_LEN];
d506 1
a506 1
		o_evirq[o_hwirq[irq]].ev_count++;
d654 1
a654 1
			o_evirq[realirq].ev_count++;
@


1.6.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.6.4.5 2003/03/27 23:29:46 niklas Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 2
d81 1
a81 2
void openpic_set_enable_irq(int, int);
void openpic_enable_irq(int);
d98 1
a98 1
struct cfattach openpic_ca = {
d109 4
a112 1
openpic_match(struct device *parent, void *cf, void *aux)
d121 1
a121 1
		if (strcmp(type,  "open-pic") == 0)
d123 1
d138 3
a140 1
openpic_attach(struct device *parent, struct device  *self, void *aux)
d161 1
a161 1

d193 3
a195 2
static int
fakeintr(void *arg)
d208 8
a215 2
openpic_intr_establish(void *lcv, int irq, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, char *name)
d293 3
a295 1
openpic_intr_disestablish(void *lcp, void *arg)
d324 2
a325 1
intr_typename(int type)
d329 1
a329 1
	case IST_NONE:
d331 1
a331 1
	case IST_PULSE:
d333 1
a333 1
	case IST_EDGE:
d335 1
a335 1
	case IST_LEVEL:
d366 1
a366 1
	for (level = IPL_NONE; level < IPL_NUM; level++) {
d406 2
a407 1
				openpic_enable_irq(o_hwirq[irq]);
d420 2
a421 1
mapirq(int irq)
d428 1
a428 1
		for (i = 0; i < ICU_LEN; i++)
d430 1
d435 1
a435 1
	if (o_virq[irq] != 0)
d437 1
a440 1

d459 2
a460 1
cntlzw(int x)
d477 1
a477 1
	int s;
d485 3
a487 1
	s = ppc_intr_disable();
d501 2
d526 1
a526 1
	ppc_intr_enable(s);
d531 2
a532 1
openpic_read(int reg)
d540 3
a542 1
openpic_write(int reg, u_int val)
d550 2
a551 1
openpic_enable_irq_mask(int irq_mask)
d555 3
a557 3
		if (irq_mask & (1 << irq))
			openpic_enable_irq(o_hwirq[irq]);
		else
d559 1
a561 1

d563 3
a565 1
openpic_set_enable_irq(int irq, int type)
d571 1
a571 1
	if (type == IST_LEVEL)
d573 1
a573 14
	else
		x |= OPENPIC_SENSE_EDGE;
	openpic_write(OPENPIC_SRC_VECTOR(irq), x);
}
void
openpic_enable_irq(int irq)
{
	u_int x;

	x = openpic_read(OPENPIC_SRC_VECTOR(irq));
	x &= ~(OPENPIC_IMASK|OPENPIC_SENSE_LEVEL|OPENPIC_SENSE_EDGE);
	if (o_intrtype[o_virq[irq]] == IST_LEVEL)
		x |= OPENPIC_SENSE_LEVEL;
	else
d575 1
d580 2
a581 1
openpic_disable_irq(int irq)
d591 2
a592 1
openpic_set_priority(int cpu, int pri)
d603 2
a604 1
openpic_read_irq(int cpu)
d610 2
a611 1
openpic_eoi(int cpu)
d613 2
a614 2
	openpic_write(OPENPIC_EOI(cpu), 0);
	openpic_read(OPENPIC_EOI(cpu));
d622 1
a622 1
	int pcpl, ocpl;
d638 1
a638 1
			ipending |= r_imen;	/* Masked! Mark this as pending */
a639 1
			openpic_eoi(0);
d641 1
a641 3
			openpic_disable_irq(realirq);
			openpic_eoi(0);
			ocpl = splraise(o_intrmask[irq]);
a644 2
				ppc_intr_enable(1);

a645 2

				(void)ppc_intr_disable();
d650 1
a650 4
			__asm__ volatile("":::"memory"); /* don't reorder.... */
			cpl = ocpl;
			__asm__ volatile("":::"memory"); /* don't reorder.... */
			openpic_enable_irq(realirq);
d653 2
a656 1
	ppc_intr_enable(1);
d658 1
a658 1
	splx(pcpl);	/* Process pendings. */
d663 2
a664 24
	int irq;
	u_int x;

	/* disable all interrupts */
	for (irq = 0; irq < 255; irq++)
		openpic_write(OPENPIC_SRC_VECTOR(irq), OPENPIC_IMASK);
	openpic_set_priority(0, 15);

	/* we don't need 8259 pass through mode */
	x = openpic_read(OPENPIC_CONFIG);
	x |= OPENPIC_CONFIG_8259_PASSTHRU_DISABLE;
	openpic_write(OPENPIC_CONFIG, x);

	/* send all interrupts to cpu 0 */
	for (irq = 0; irq < ICU_LEN; irq++)
		openpic_write(OPENPIC_IDEST(irq), 1 << 0);
	for (irq = 0; irq < ICU_LEN; irq++) {
		x = irq;
		x |= OPENPIC_IMASK;
		x |= OPENPIC_POLARITY_POSITIVE;
		x |= OPENPIC_SENSE_LEVEL;
		x |= 8 << OPENPIC_PRIORITY_SHIFT;
		openpic_write(OPENPIC_SRC_VECTOR(irq), x);
	}
d666 31
a696 1
	/* XXX set spurious intr vector */
d698 2
a699 1
	openpic_set_priority(0, 0);
d701 1
a701 10
	/* clear all pending interrunts */
	for (irq = 0; irq < ICU_LEN; irq++) {
		openpic_read_irq(0);
		openpic_eoi(0);
	}

	for (irq = 0; irq < ICU_LEN; irq++)
		openpic_disable_irq(irq);

	install_extint(ext_intr_openpic);
@


1.6.4.8
log
@Merge with the trunk
@
text
@d397 1
a397 1

d405 8
@


1.5
log
@Commit a ugly, widespread change.
Problem: no MI soft interrupts.
Bad solution: use old hack that was never fully implemented
to hook in zs soft interrupts.
This allows zs to work almost reasonably.
Still has issues with getty (carrier detect)
and modems on newer machines (power control).

Post 3.0 this must be cleaned up with real soft interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.4 2001/09/11 06:47:00 mickey Exp $	*/
d77 1
a77 1
int prog_switch __P((void *arg));
d172 1
a172 1
		IPL_HIGH, prog_switch, (void*)0x37, "prog button");
d688 15
@


1.4
log
@vm/vm_kern.h is not needed hereand it compiles (;
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.3 2001/09/10 12:58:50 drahn Exp $	*/
d507 5
a511 1
	} while (ipending & (SINT_NET|SINT_CLOCK) & ~cpl);
@


1.3
log
@Remove some unused global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.2 2001/09/01 17:43:09 drahn Exp $	*/
d49 1
a50 1
#include <vm/vm_kern.h>
@


1.2
log
@correct files for the powerpc/mac/ -> macppc/dev which did not get
renamed correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.1 2001/09/01 15:50:00 drahn Exp $	*/
a79 2
extern u_int32_t *heathrow_FCR;

a82 1

a131 1
u_int8_t *interrupt_reg;
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/mac to macppc/dev
@
text
@d1 1
a1 1
/*	$OpenBSD: openpic.c,v 1.17 2001/07/09 04:41:28 mickey Exp $	*/
d58 1
a58 1
#include <macppc/mac/openpicreg.h>
@

