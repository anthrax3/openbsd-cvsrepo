head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.6
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.8
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.28
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.24
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.22
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.20
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.18
	OPENBSD_5_0:1.9.0.16
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.14
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.12
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.8
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.10
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.6
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.4
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.8.0.8
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.6
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.6
	UBC:1.4.0.2
	UBC_BASE:1.4
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.11
date	2015.09.08.08.29.35;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	Qv4sSaeodDiHWA1c;

1.10
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.9;
commitid	uKVPYMN2MLxdZxzH;

1.9
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.13.19.25.44;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.16.03.31.25;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.15.02.02.43;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.09.15.01.51.11;	author mickey;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.09.01.17.43.09;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.50.00;	author drahn;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.01.15;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	;


desc
@@


1.11
log
@sizes for free(); ok semarie
@
text
@/*	$OpenBSD: dbdma.c,v 1.10 2014/07/12 18:44:42 tedu Exp $	*/
/*	$NetBSD: dbdma.c,v 1.2 1998/08/21 16:13:28 tsubai Exp $	*/

/*
 * Copyright 1991-1998 by Open Software Foundation, Inc.
 *              All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appears in all copies and
 * that both the copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#include <sys/param.h>
#include <sys/malloc.h>
#include <sys/systm.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <macppc/dev/dbdma.h>

dbdma_command_t	*dbdma_alloc_commands = NULL;

void
dbdma_start(dbdma_regmap_t *dmap, dbdma_t dt)
{
	u_int32_t addr = dt->d_paddr;

	DBDMA_ST4_ENDIAN(&dmap->d_intselect, DBDMA_CLEAR_CNTRL((0xffff)));
	DBDMA_ST4_ENDIAN(&dmap->d_control, DBDMA_CLEAR_CNTRL((
	    DBDMA_CNTRL_ACTIVE |
	    DBDMA_CNTRL_DEAD |
	    DBDMA_CNTRL_WAKE |
	    DBDMA_CNTRL_FLUSH |
	    DBDMA_CNTRL_PAUSE |
	    DBDMA_CNTRL_RUN)));

	/* XXX time-bind it? */
	do {
		delay(10);
	} while (DBDMA_LD4_ENDIAN(&dmap->d_status) & DBDMA_CNTRL_ACTIVE);


	DBDMA_ST4_ENDIAN(&dmap->d_cmdptrhi, 0); /* 64-bit not yet */
	DBDMA_ST4_ENDIAN(&dmap->d_cmdptrlo, addr);

	DBDMA_ST4_ENDIAN(&dmap->d_control,
		DBDMA_SET_CNTRL(DBDMA_CNTRL_RUN|DBDMA_CNTRL_WAKE)|
		DBDMA_CLEAR_CNTRL(DBDMA_CNTRL_PAUSE|DBDMA_CNTRL_DEAD) );
}

void
dbdma_stop(dbdma_regmap_t *dmap)
{
	DBDMA_ST4_ENDIAN(&dmap->d_control, DBDMA_CLEAR_CNTRL(DBDMA_CNTRL_RUN) |
			  DBDMA_SET_CNTRL(DBDMA_CNTRL_FLUSH));

	while (DBDMA_LD4_ENDIAN(&dmap->d_status) &
		(DBDMA_CNTRL_ACTIVE|DBDMA_CNTRL_FLUSH));
}

void
dbdma_flush(dbdma_regmap_t *dmap)
{
	DBDMA_ST4_ENDIAN(&dmap->d_control, DBDMA_SET_CNTRL(DBDMA_CNTRL_FLUSH));

	/* XXX time-bind it? */
	while (DBDMA_LD4_ENDIAN(&dmap->d_status) & (DBDMA_CNTRL_FLUSH));
}

void
dbdma_reset(dbdma_regmap_t *dmap)
{
	DBDMA_ST4_ENDIAN(&dmap->d_control,
			 DBDMA_CLEAR_CNTRL( (DBDMA_CNTRL_ACTIVE	|
					     DBDMA_CNTRL_DEAD	|
					     DBDMA_CNTRL_WAKE	|
					     DBDMA_CNTRL_FLUSH	|
					     DBDMA_CNTRL_PAUSE	|
					     DBDMA_CNTRL_RUN      )));

	/* XXX time-bind it? */
	while (DBDMA_LD4_ENDIAN(&dmap->d_status) & DBDMA_CNTRL_RUN);
}

void
dbdma_continue(dbdma_regmap_t *dmap)
{
	DBDMA_ST4_ENDIAN(&dmap->d_control,
		DBDMA_SET_CNTRL(DBDMA_CNTRL_RUN | DBDMA_CNTRL_WAKE) |
		DBDMA_CLEAR_CNTRL(DBDMA_CNTRL_PAUSE | DBDMA_CNTRL_DEAD));
}

void
dbdma_pause(dbdma_regmap_t *dmap)
{
	DBDMA_ST4_ENDIAN(&dmap->d_control,DBDMA_SET_CNTRL(DBDMA_CNTRL_PAUSE));

	/* XXX time-bind it? */
	while (DBDMA_LD4_ENDIAN(&dmap->d_status) & DBDMA_CNTRL_ACTIVE);
}

dbdma_t
dbdma_alloc(bus_dma_tag_t dmat, int size)
{
	dbdma_t dt;
	int error;

	dt = malloc(sizeof *dt, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (!dt)
		return (dt);

	dt->d_size = size *= sizeof(dbdma_command_t);
	dt->d_dmat = dmat;
	if ((error = bus_dmamem_alloc(dmat, size, NBPG, 0, dt->d_segs,
	    1, &dt->d_nsegs, BUS_DMA_NOWAIT)) != 0) {
		printf("dbdma: unable to allocate dma, error = %d\n", error);
	} else if ((error = bus_dmamem_map(dmat, dt->d_segs, dt->d_nsegs, size,
	    (caddr_t *)&dt->d_addr, BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {
		printf("dbdma: unable to map dma, error = %d\n", error);
	} else if ((error = bus_dmamap_create(dmat, dt->d_size, 1,
	    dt->d_size, 0, BUS_DMA_NOWAIT, &dt->d_map)) != 0) {
		printf("dbdma: unable to create dma map, error = %d\n", error);
	} else if ((error = bus_dmamap_load_raw(dmat, dt->d_map,
	    dt->d_segs, dt->d_nsegs, size, BUS_DMA_NOWAIT)) != 0) {
		printf("dbdma: unable to load dma map, error = %d\n", error);
	} else
		return dt;

	dbdma_free(dt);
	return (NULL);
}

void
dbdma_free(dbdma_t dt)
{
	if (dt->d_map)
		bus_dmamap_destroy(dt->d_dmat, dt->d_map);
	if (dt->d_addr)
		bus_dmamem_unmap(dt->d_dmat, (caddr_t)dt->d_addr, dt->d_size);
	if (dt->d_nsegs)
		bus_dmamem_free(dt->d_dmat, dt->d_segs, dt->d_nsegs);
	free(dt, M_DEVBUF, sizeof *dt);
}
@


1.10
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: dbdma.c,v 1.9 2007/09/17 01:33:33 krw Exp $	*/
d156 1
a156 1
	free(dt, M_DEVBUF, 0);
@


1.9
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: dbdma.c,v 1.8 2006/01/13 19:25:44 miod Exp $	*/
d156 1
a156 1
	free(dt, M_DEVBUF);
@


1.8
log
@Allow proper detaching of wdc, so that detaching a mediabay device properly
releases resources and works as expected.

Thanks to Thomas Maschutznig for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: dbdma.c,v 1.7 2003/10/16 03:31:25 drahn Exp $	*/
d122 1
a122 1
	dt = malloc(sizeof *dt, M_DEVBUF, M_NOWAIT);
a124 1
	bzero(dt, sizeof *dt);
@


1.7
log
@more ANSI/KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: dbdma.c,v 1.6 2002/09/15 09:01:58 deraadt Exp $	*/
d120 1
a120 1
	int error, nsegs = 0;
d128 1
d130 1
a130 1
	    1, &nsegs, BUS_DMA_NOWAIT)) != 0) {
d132 1
a132 1
	} else if ((error = bus_dmamem_map(dmat, dt->d_segs, nsegs, size,
d139 1
a139 1
	    dt->d_segs, nsegs, size, BUS_DMA_NOWAIT)) != 0) {
d144 7
d152 1
a152 1
		bus_dmamap_destroy(dmat, dt->d_map);
d154 3
a156 3
		bus_dmamem_unmap(dmat, (caddr_t)dt->d_addr, size);
	if (nsegs)
		bus_dmamem_free(dmat, dt->d_segs, nsegs);
a157 2

	return (NULL);
@


1.6
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: dbdma.c,v 1.4 2001/11/06 19:53:15 miod Exp $	*/
d38 1
a38 3
dbdma_start(dmap, dt)
	dbdma_regmap_t *dmap;
	dbdma_t dt;
d66 1
a66 2
dbdma_stop(dmap)
	dbdma_regmap_t *dmap;
d76 1
a76 2
dbdma_flush(dmap)
	dbdma_regmap_t *dmap;
d85 1
a85 2
dbdma_reset(dmap)
	dbdma_regmap_t *dmap;
d100 1
a100 2
dbdma_continue(dmap)
	dbdma_regmap_t *dmap;
d108 1
a108 2
dbdma_pause(dmap)
	dbdma_regmap_t *dmap;
d117 1
a117 3
dbdma_alloc(dmat, size)
	bus_dma_tag_t dmat;
	int size;
@


1.5
log
@KNF
@
text
@d46 6
a51 3
	    DBDMA_CNTRL_ACTIVE | DBDMA_CNTRL_DEAD |
	    DBDMA_CNTRL_WAKE | DBDMA_CNTRL_FLUSH |
	    DBDMA_CNTRL_PAUSE | DBDMA_CNTRL_RUN)));
d63 2
a64 2
	    DBDMA_SET_CNTRL(DBDMA_CNTRL_RUN|DBDMA_CNTRL_WAKE)|
	    DBDMA_CLEAR_CNTRL(DBDMA_CNTRL_PAUSE|DBDMA_CNTRL_DEAD) );
d72 1
a72 1
	    DBDMA_SET_CNTRL(DBDMA_CNTRL_FLUSH));
d75 1
a75 2
	    (DBDMA_CNTRL_ACTIVE|DBDMA_CNTRL_FLUSH))
		;
d85 1
a85 2
	while (DBDMA_LD4_ENDIAN(&dmap->d_status) & (DBDMA_CNTRL_FLUSH))
		;
d93 6
a98 4
	    DBDMA_CLEAR_CNTRL((DBDMA_CNTRL_ACTIVE |
	    DBDMA_CNTRL_DEAD | DBDMA_CNTRL_WAKE |
	    DBDMA_CNTRL_FLUSH | DBDMA_CNTRL_PAUSE |
	    DBDMA_CNTRL_RUN)));
d101 1
a101 2
	while (DBDMA_LD4_ENDIAN(&dmap->d_status) & DBDMA_CNTRL_RUN)
		;
d109 2
a110 2
	    DBDMA_SET_CNTRL(DBDMA_CNTRL_RUN | DBDMA_CNTRL_WAKE) |
	    DBDMA_CLEAR_CNTRL(DBDMA_CNTRL_PAUSE | DBDMA_CNTRL_DEAD));
d120 1
a120 2
	while (DBDMA_LD4_ENDIAN(&dmap->d_status) & DBDMA_CNTRL_ACTIVE)
		;
@


1.4
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: dbdma.c,v 1.3 2001/09/15 01:51:11 mickey Exp $	*/
d46 3
a48 6
	    DBDMA_CNTRL_ACTIVE |
	    DBDMA_CNTRL_DEAD |
	    DBDMA_CNTRL_WAKE |
	    DBDMA_CNTRL_FLUSH |
	    DBDMA_CNTRL_PAUSE |
	    DBDMA_CNTRL_RUN)));
d60 2
a61 2
		DBDMA_SET_CNTRL(DBDMA_CNTRL_RUN|DBDMA_CNTRL_WAKE)|
		DBDMA_CLEAR_CNTRL(DBDMA_CNTRL_PAUSE|DBDMA_CNTRL_DEAD) );
d69 1
a69 1
			  DBDMA_SET_CNTRL(DBDMA_CNTRL_FLUSH));
d72 2
a73 1
		(DBDMA_CNTRL_ACTIVE|DBDMA_CNTRL_FLUSH));
d83 2
a84 1
	while (DBDMA_LD4_ENDIAN(&dmap->d_status) & (DBDMA_CNTRL_FLUSH));
d92 4
a95 6
			 DBDMA_CLEAR_CNTRL( (DBDMA_CNTRL_ACTIVE	|
					     DBDMA_CNTRL_DEAD	|
					     DBDMA_CNTRL_WAKE	|
					     DBDMA_CNTRL_FLUSH	|
					     DBDMA_CNTRL_PAUSE	|
					     DBDMA_CNTRL_RUN      )));
d98 2
a99 1
	while (DBDMA_LD4_ENDIAN(&dmap->d_status) & DBDMA_CNTRL_RUN);
d107 2
a108 2
		DBDMA_SET_CNTRL(DBDMA_CNTRL_RUN | DBDMA_CNTRL_WAKE) |
		DBDMA_CLEAR_CNTRL(DBDMA_CNTRL_PAUSE | DBDMA_CNTRL_DEAD));
d118 2
a119 1
	while (DBDMA_LD4_ENDIAN(&dmap->d_status) & DBDMA_CNTRL_ACTIVE);
@


1.4.2.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: dbdma.c,v 1.4 2001/11/06 19:53:15 miod Exp $	*/
@


1.3
log
@reimplement dbdma such that it does memory allocations
w/ bus_dma(9) and rework drivers accordingly.
make drivers use bus_dma as well, except for if_bm (later ;) .
additionally, sync wdc_obio w/ netbsd.
drahn@@ ok, tested by miod@@, pval@@, brad@@, mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dbdma.c,v 1.2 2001/09/01 17:43:09 drahn Exp $	*/
d30 1
a30 1
#include <vm/vm.h>
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Merge in -current
@
text
@d30 1
a30 1
#include <uvm/uvm_extern.h>
@


1.3.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d38 3
a40 1
dbdma_start(dbdma_regmap_t *dmap, dbdma_t dt)
d68 2
a69 1
dbdma_stop(dbdma_regmap_t *dmap)
d79 2
a80 1
dbdma_flush(dbdma_regmap_t *dmap)
d89 2
a90 1
dbdma_reset(dbdma_regmap_t *dmap)
d105 2
a106 1
dbdma_continue(dbdma_regmap_t *dmap)
d114 2
a115 1
dbdma_pause(dbdma_regmap_t *dmap)
d124 3
a126 1
dbdma_alloc(bus_dma_tag_t dmat, int size)
@


1.2
log
@correct files for the powerpc/mac/ -> macppc/dev which did not get
renamed correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: dbdma.c,v 1.1 2001/09/01 15:50:00 drahn Exp $	*/
d5 19
a23 19
 * Copyright 1991-1998 by Open Software Foundation, Inc. 
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
 * 
d32 1
a32 1
#include <machine/pio.h>
a34 2


d38 1
a38 1
dbdma_start(dmap, commands)
d40 1
a40 1
	dbdma_command_t *commands;
d42 1
a42 1
	u_int32_t addr = vtophys((vaddr_t)commands);
d44 8
a51 2
	if (addr & 0xf)
		panic("dbdma_start command structure not 16-byte aligned");
d53 1
a53 9
	DBDMA_ST4_ENDIAN(&dmap->d_intselect,  DBDMA_CLEAR_CNTRL( (0xffff)));
	DBDMA_ST4_ENDIAN(&dmap->d_control, 
			 DBDMA_CLEAR_CNTRL( (DBDMA_CNTRL_ACTIVE	|
					     DBDMA_CNTRL_DEAD	|
					     DBDMA_CNTRL_WAKE	|
					     DBDMA_CNTRL_FLUSH	|
					     DBDMA_CNTRL_PAUSE	|
					     DBDMA_CNTRL_RUN      )));      
     
d57 1
a57 1
	
d60 1
a60 1
	DBDMA_ST4_ENDIAN(&dmap->d_cmdptrlo, addr); 
d84 1
d92 1
a92 1
	DBDMA_ST4_ENDIAN(&dmap->d_control, 
d98 1
a98 1
					     DBDMA_CNTRL_RUN      )));      
d100 1
d119 2
a120 2
	while (DBDMA_LD4_ENDIAN(&dmap->d_status) & DBDMA_CNTRL_ACTIVE)
		;
d123 3
a125 2
dbdma_command_t	*
dbdma_alloc(size)
d128 2
a129 1
	u_int buf;
d131 28
a158 2
	buf = (u_int)malloc(size + 0x0f, M_DEVBUF, M_WAITOK);
	buf = (buf + 0x0f) & ~0x0f;
d160 1
a160 1
	return (dbdma_command_t *)buf;
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/mac to macppc/dev
@
text
@d1 1
a1 1
/*	$OpenBSD: dbdma.c,v 1.3 2001/06/25 23:29:54 drahn Exp $	*/
d33 1
a33 1
#include <macppc/mac/dbdma.h>
@

