head	1.37;
access;
symbols
	OPENBSD_6_2:1.37.0.2
	OPENBSD_6_2_BASE:1.37
	OPENBSD_6_1:1.37.0.4
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.35.0.28
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.24
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.26
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.18
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.35.0.22
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.20
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.35.0.16
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.14
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.12
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.10
	OPENBSD_5_0:1.35.0.8
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.6
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.4
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.34.0.6
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.2
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.28.0.4
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.27.0.6
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.4
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	SMP:1.5.0.2;
locks; strict;
comment	@ * @;


1.37
date	2016.09.19.06.46.43;	author ratchov;	state Exp;
branches;
next	1.36;
commitid	qGgYgJTgEFuAoGj4;

1.36
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.35;
commitid	pi1a9KN0itEngOc4;

1.35
date	2009.10.26.20.17.27;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2008.11.06.10.01.50;	author todd;	state Exp;
branches;
next	1.33;

1.33
date	2008.11.05.01.43.09;	author jakemsr;	state Exp;
branches;
next	1.32;

1.32
date	2008.10.29.00.04.14;	author jakemsr;	state Exp;
branches;
next	1.31;

1.31
date	2008.08.25.03.16.22;	author todd;	state Exp;
branches;
next	1.30;

1.30
date	2008.08.24.23.44.44;	author todd;	state Exp;
branches;
next	1.29;

1.29
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.23.16.27.20;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.28.10.08.07;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.17.00.04.10;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.05.04.26.22;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.31.01.16.29;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.31.00.26.07;	author joris;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.31.00.04.54;	author joris;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.28.15.27.49;	author joris;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.26.17.57.20;	author joris;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.20.20.35.12;	author joris;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.11.20.43.53;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.07.03.47.31;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.26.22.51.50;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.26.02.22.06;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.23.18.49.31;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.22.21.10.27;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.22.20.32.36;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.22.19.12.41;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.22.18.28.20;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.22.18.08.13;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.22.07.19.02;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.25.23.02.24;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.25.19.01.01;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.14.16.37.24;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.12.02.38.03;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.12.02.19.13;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.11.21.01.04;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.11.16.32.15;	author drahn;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Remove unused getdev() audio driver functions.
@
text
@/*	$OpenBSD: snapper.c,v 1.36 2016/09/14 06:12:19 ratchov Exp $	*/
/*	$NetBSD: snapper.c,v 1.1 2003/12/27 02:19:34 grant Exp $	*/

/*-
 * Copyright (c) 2002 Tsubai Masanari.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Datasheet is available from
 * http://focus.ti.com/docs/prod/folders/print/tas3004.html
 */

#include <sys/param.h>
#include <sys/audioio.h>
#include <sys/device.h>
#include <sys/systm.h>

#include <dev/audio_if.h>
#include <dev/ofw/openfirm.h>
#include <macppc/dev/dbdma.h>

#include <machine/autoconf.h>

#include <macppc/dev/i2svar.h>

#ifdef SNAPPER_DEBUG
# define DPRINTF printf
#else
# define DPRINTF while (0) printf
#endif

/* XXX */
#define snapper_softc i2s_softc

/* XXX */
int kiic_write(struct device *, int, int, const void *, int);
int kiic_writereg(struct device *, int, u_int);

void snapper_init(struct snapper_softc *);
int snapper_match(struct device *, void *, void *);
void snapper_attach(struct device *, struct device *, void *);
void snapper_defer(struct device *);
void snapper_set_volume(struct snapper_softc *, int, int);
void snapper_set_bass(struct snapper_softc *, int);
void snapper_set_treble(struct snapper_softc *, int);
void snapper_set_input(struct snapper_softc *, int);

int tas3004_write(struct snapper_softc *, u_int, const void *);
int tas3004_init(struct snapper_softc *);

struct cfattach snapper_ca = {
	sizeof(struct snapper_softc), snapper_match, snapper_attach
};
struct cfdriver snapper_cd = {
	NULL, "snapper", DV_DULL
};

struct audio_hw_if snapper_hw_if = {
	i2s_open,
	i2s_close,
	i2s_set_params,
	i2s_round_blocksize,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	i2s_halt_output,
	i2s_halt_input,
	NULL,
	NULL,
	i2s_set_port,
	i2s_get_port,
	i2s_query_devinfo,
	i2s_allocm,		/* allocm */
	NULL,
	i2s_round_buffersize,
	i2s_get_props,
	i2s_trigger_output,
	i2s_trigger_input
};

const uint8_t snapper_trebletab[] = {
	0x96,	/* -18dB */
	0x94,	/* -17dB */
	0x92,	/* -16dB */
	0x90,	/* -15dB */
	0x8e,	/* -14dB */
	0x8c,	/* -13dB */
	0x8a,	/* -12dB */
	0x88,	/* -11dB */
	0x86,	/* -10dB */
	0x84,	/* -9dB */
	0x82,	/* -8dB */
	0x80,	/* -7dB */
	0x7e,	/* -6dB */
	0x7c,	/* -5dB */
	0x7a,	/* -4dB */
	0x78,	/* -3dB */
	0x76,	/* -2dB */
	0x74,	/* -1dB */
	0x72,	/* 0dB */
	0x70,	/* 1dB */
	0x6d,	/* 2dB */
	0x6b,	/* 3dB */
	0x68,	/* 4dB */
	0x65,	/* 5dB */
	0x62,	/* 6dB */
	0x5d,	/* 7dB */
	0x59,	/* 8dB */
	0x53,	/* 9dB */
	0x4d,	/* 10dB */
	0x47,	/* 11dB */
	0x3f,	/* 12dB */
	0x36,	/* 13dB */
	0x2c,	/* 14dB */
	0x20,	/* 15dB */
	0x13,	/* 16dB */
	0x04,	/* 17dB */
	0x01,	/* 18dB */
};

const uint8_t snapper_basstab[] = {
	0x96,	/* -18dB */
	0x94,	/* -17dB */
	0x92,	/* -16dB */
	0x90,	/* -15dB */
	0x8e,	/* -14dB */
	0x8c,	/* -13dB */
	0x8a,	/* -12dB */
	0x88,	/* -11dB */
	0x86,	/* -10dB */
	0x84,	/* -9dB */
	0x82,	/* -8dB */
	0x80,	/* -7dB */
	0x7e,	/* -6dB */
	0x7c,	/* -5dB */
	0x7a,	/* -4dB */
	0x78,	/* -3dB */
	0x76,	/* -2dB */
	0x74,	/* -1dB */
	0x72,	/* 0dB */
	0x6f,	/* 1dB */
	0x6d,	/* 2dB */
	0x6a,	/* 3dB */
	0x67,	/* 4dB */
	0x65,	/* 5dB */
	0x62,	/* 6dB */
	0x5f,	/* 7dB */
	0x5b,	/* 8dB */
	0x55,	/* 9dB */
	0x4f,	/* 10dB */
	0x49,	/* 11dB */
	0x43,	/* 12dB */
	0x3b,	/* 13dB */
	0x33,	/* 14dB */
	0x29,	/* 15dB */
	0x1e,	/* 16dB */
	0x11,	/* 17dB */
	0x01,	/* 18dB */
};

struct {
	int high, mid, low;
} snapper_volumetab[] = {
	{ 0x07, 0xF1, 0x7B }, /* 18.0 */
	{ 0x07, 0x7F, 0xBB }, /* 17.5 */
	{ 0x07, 0x14, 0x57 }, /* 17.0 */
	{ 0x06, 0xAE, 0xF6 }, /* 16.5 */
	{ 0x06, 0x4F, 0x40 }, /* 16.0 */
	{ 0x05, 0xF4, 0xE5 }, /* 15.5 */
	{ 0x05, 0x9F, 0x98 }, /* 15.0 */
	{ 0x05, 0x4F, 0x10 }, /* 14.5 */
	{ 0x05, 0x03, 0x0A }, /* 14.0 */
	{ 0x04, 0xBB, 0x44 }, /* 13.5 */
	{ 0x04, 0x77, 0x83 }, /* 13.0 */
	{ 0x04, 0x37, 0x8B }, /* 12.5 */
	{ 0x03, 0xFB, 0x28 }, /* 12.0 */
	{ 0x03, 0xC2, 0x25 }, /* 11.5 */
	{ 0x03, 0x8C, 0x53 }, /* 11.0 */
	{ 0x03, 0x59, 0x83 }, /* 10.5 */
	{ 0x03, 0x29, 0x8B }, /* 10.0 */
	{ 0x02, 0xFC, 0x42 }, /* 9.5 */
	{ 0x02, 0xD1, 0x82 }, /* 9.0 */
	{ 0x02, 0xA9, 0x25 }, /* 8.5 */
	{ 0x02, 0x83, 0x0B }, /* 8.0 */
	{ 0x02, 0x5F, 0x12 }, /* 7.5 */
	{ 0x02, 0x3D, 0x1D }, /* 7.0 */
	{ 0x02, 0x1D, 0x0E }, /* 6.5 */
	{ 0x01, 0xFE, 0xCA }, /* 6.0 */
	{ 0x01, 0xE2, 0x37 }, /* 5.5 */
	{ 0x01, 0xC7, 0x3D }, /* 5.0 */
	{ 0x01, 0xAD, 0xC6 }, /* 4.5 */
	{ 0x01, 0x95, 0xBC }, /* 4.0 */
	{ 0x01, 0x7F, 0x09 }, /* 3.5 */
	{ 0x01, 0x69, 0x9C }, /* 3.0 */
	{ 0x01, 0x55, 0x62 }, /* 2.5 */
	{ 0x01, 0x42, 0x49 }, /* 2.0 */
	{ 0x01, 0x30, 0x42 }, /* 1.5 */
	{ 0x01, 0x1F, 0x3D }, /* 1.0 */
	{ 0x01, 0x0F, 0x2B }, /* 0.5 */
	{ 0x01, 0x00, 0x00 }, /* 0.0 */
	{ 0x00, 0xF1, 0xAE }, /* -0.5 */
	{ 0x00, 0xE4, 0x29 }, /* -1.0 */
	{ 0x00, 0xD7, 0x66 }, /* -1.5 */
	{ 0x00, 0xCB, 0x59 }, /* -2.0 */
	{ 0x00, 0xBF, 0xF9 }, /* -2.5 */
	{ 0x00, 0xB5, 0x3C }, /* -3.0 */
	{ 0x00, 0xAB, 0x19 }, /* -3.5 */
	{ 0x00, 0xA1, 0x86 }, /* -4.0 */
	{ 0x00, 0x98, 0x7D }, /* -4.5 */
	{ 0x00, 0x8F, 0xF6 }, /* -5.0 */
	{ 0x00, 0x87, 0xE8 }, /* -5.5 */
	{ 0x00, 0x80, 0x4E }, /* -6.0 */
	{ 0x00, 0x79, 0x20 }, /* -6.5 */
	{ 0x00, 0x72, 0x5A }, /* -7.0 */
	{ 0x00, 0x6B, 0xF4 }, /* -7.5 */
	{ 0x00, 0x65, 0xEA }, /* -8.0 */
	{ 0x00, 0x60, 0x37 }, /* -8.5 */
	{ 0x00, 0x5A, 0xD5 }, /* -9.0 */
	{ 0x00, 0x55, 0xC0 }, /* -9.5 */
	{ 0x00, 0x50, 0xF4 }, /* -10.0 */
	{ 0x00, 0x4C, 0x6D }, /* -10.5 */
	{ 0x00, 0x48, 0x27 }, /* -11.0 */
	{ 0x00, 0x44, 0x1D }, /* -11.5 */
	{ 0x00, 0x40, 0x4E }, /* -12.0 */
	{ 0x00, 0x3C, 0xB5 }, /* -12.5 */
	{ 0x00, 0x39, 0x50 }, /* -13.0 */
	{ 0x00, 0x36, 0x1B }, /* -13.5 */
	{ 0x00, 0x33, 0x14 }, /* -14.0 */
	{ 0x00, 0x30, 0x39 }, /* -14.5 */
	{ 0x00, 0x2D, 0x86 }, /* -15.0 */
	{ 0x00, 0x2A, 0xFA }, /* -15.5 */
	{ 0x00, 0x28, 0x93 }, /* -16.0 */
	{ 0x00, 0x26, 0x4E }, /* -16.5 */
	{ 0x00, 0x24, 0x29 }, /* -17.0 */
	{ 0x00, 0x22, 0x23 }, /* -17.5 */
	{ 0x00, 0x20, 0x3A }, /* -18.0 */
	{ 0x00, 0x1E, 0x6D }, /* -18.5 */
	{ 0x00, 0x1C, 0xB9 }, /* -19.0 */
	{ 0x00, 0x1B, 0x1E }, /* -19.5 */
	{ 0x00, 0x19, 0x9A }, /* -20.0 */
	{ 0x00, 0x18, 0x2B }, /* -20.5 */
	{ 0x00, 0x16, 0xD1 }, /* -21.0 */
	{ 0x00, 0x15, 0x8A }, /* -21.5 */
	{ 0x00, 0x14, 0x56 }, /* -22.0 */
	{ 0x00, 0x13, 0x33 }, /* -22.5 */
	{ 0x00, 0x12, 0x20 }, /* -23.0 */
	{ 0x00, 0x11, 0x1C }, /* -23.5 */
	{ 0x00, 0x10, 0x27 }, /* -24.0 */
	{ 0x00, 0x0F, 0x40 }, /* -24.5 */
	{ 0x00, 0x0E, 0x65 }, /* -25.0 */
	{ 0x00, 0x0D, 0x97 }, /* -25.5 */
	{ 0x00, 0x0C, 0xD5 }, /* -26.0 */
	{ 0x00, 0x0C, 0x1D }, /* -26.5 */
	{ 0x00, 0x0B, 0x6F }, /* -27.0 */
	{ 0x00, 0x0A, 0xCC }, /* -27.5 */
	{ 0x00, 0x0A, 0x31 }, /* -28.0 */
	{ 0x00, 0x09, 0x9F }, /* -28.5 */
	{ 0x00, 0x09, 0x15 }, /* -29.0 */
	{ 0x00, 0x08, 0x93 }, /* -29.5 */
	{ 0x00, 0x08, 0x18 }, /* -30.0 */
	{ 0x00, 0x07, 0xA5 }, /* -30.5 */
	{ 0x00, 0x07, 0x37 }, /* -31.0 */
	{ 0x00, 0x06, 0xD0 }, /* -31.5 */
	{ 0x00, 0x06, 0x6E }, /* -32.0 */
	{ 0x00, 0x06, 0x12 }, /* -32.5 */
	{ 0x00, 0x05, 0xBB }, /* -33.0 */
	{ 0x00, 0x05, 0x69 }, /* -33.5 */
	{ 0x00, 0x05, 0x1C }, /* -34.0 */
	{ 0x00, 0x04, 0xD2 }, /* -34.5 */
	{ 0x00, 0x04, 0x8D }, /* -35.0 */
	{ 0x00, 0x04, 0x4C }, /* -35.5 */
	{ 0x00, 0x04, 0x0F }, /* -36.0 */
	{ 0x00, 0x03, 0xD5 }, /* -36.5 */
	{ 0x00, 0x03, 0x9E }, /* -37.0 */
	{ 0x00, 0x03, 0x6A }, /* -37.5 */
	{ 0x00, 0x03, 0x39 }, /* -38.0 */
	{ 0x00, 0x03, 0x0B }, /* -38.5 */
	{ 0x00, 0x02, 0xDF }, /* -39.0 */
	{ 0x00, 0x02, 0xB6 }, /* -39.5 */
	{ 0x00, 0x02, 0x8F }, /* -40.0 */
	{ 0x00, 0x02, 0x6B }, /* -40.5 */
	{ 0x00, 0x02, 0x48 }, /* -41.0 */
	{ 0x00, 0x02, 0x27 }, /* -41.5 */
	{ 0x00, 0x02, 0x09 }, /* -42.0 */
	{ 0x00, 0x01, 0xEB }, /* -42.5 */
	{ 0x00, 0x01, 0xD0 }, /* -43.0 */
	{ 0x00, 0x01, 0xB6 }, /* -43.5 */
	{ 0x00, 0x01, 0x9E }, /* -44.0 */
	{ 0x00, 0x01, 0x86 }, /* -44.5 */
	{ 0x00, 0x01, 0x71 }, /* -45.0 */
	{ 0x00, 0x01, 0x5C }, /* -45.5 */
	{ 0x00, 0x01, 0x48 }, /* -46.0 */
	{ 0x00, 0x01, 0x36 }, /* -46.5 */
	{ 0x00, 0x01, 0x25 }, /* -47.0 */
	{ 0x00, 0x01, 0x14 }, /* -47.5 */
	{ 0x00, 0x01, 0x05 }, /* -48.0 */
	{ 0x00, 0x00, 0xF6 }, /* -48.5 */
	{ 0x00, 0x00, 0xE9 }, /* -49.0 */
	{ 0x00, 0x00, 0xDC }, /* -49.5 */
	{ 0x00, 0x00, 0xCF }, /* -50.0 */
	{ 0x00, 0x00, 0xC4 }, /* -50.5 */
	{ 0x00, 0x00, 0xB9 }, /* -51.0 */
	{ 0x00, 0x00, 0xAE }, /* -51.5 */
	{ 0x00, 0x00, 0xA5 }, /* -52.0 */
	{ 0x00, 0x00, 0x9B }, /* -52.5 */
	{ 0x00, 0x00, 0x93 }, /* -53.0 */
	{ 0x00, 0x00, 0x8B }, /* -53.5 */
	{ 0x00, 0x00, 0x83 }, /* -54.0 */
	{ 0x00, 0x00, 0x7B }, /* -54.5 */
	{ 0x00, 0x00, 0x75 }, /* -55.0 */
	{ 0x00, 0x00, 0x6E }, /* -55.5 */
	{ 0x00, 0x00, 0x68 }, /* -56.0 */
	{ 0x00, 0x00, 0x62 }, /* -56.5 */
	{ 0x00, 0x00, 0x0 } /* Mute? */

};

/* TAS3004 registers */
#define DEQ_MCR1	0x01	/* Main control register 1 (1byte) */
#define DEQ_DRC		0x02	/* Dynamic range compression (6bytes?) */
#define DEQ_VOLUME	0x04	/* Volume (6bytes) */
#define DEQ_TREBLE	0x05	/* Treble control (1byte) */
#define DEQ_BASS	0x06	/* Bass control (1byte) */
#define DEQ_MIXER_L	0x07	/* Mixer left gain (9bytes) */
#define DEQ_MIXER_R	0x08	/* Mixer right gain (9bytes) */
#define DEQ_LB0		0x0a	/* Left biquad 0 (15bytes) */
#define DEQ_LB1		0x0b	/* Left biquad 1 (15bytes) */
#define DEQ_LB2		0x0c	/* Left biquad 2 (15bytes) */
#define DEQ_LB3		0x0d	/* Left biquad 3 (15bytes) */
#define DEQ_LB4		0x0e	/* Left biquad 4 (15bytes) */
#define DEQ_LB5		0x0f	/* Left biquad 5 (15bytes) */
#define DEQ_LB6		0x10	/* Left biquad 6 (15bytes) */
#define DEQ_RB0		0x13	/* Right biquad 0 (15bytes) */
#define DEQ_RB1		0x14	/* Right biquad 1 (15bytes) */
#define DEQ_RB2		0x15	/* Right biquad 2 (15bytes) */
#define DEQ_RB3		0x16	/* Right biquad 3 (15bytes) */
#define DEQ_RB4		0x17	/* Right biquad 4 (15bytes) */
#define DEQ_RB5		0x18	/* Right biquad 5 (15bytes) */
#define DEQ_RB6		0x19	/* Right biquad 6 (15bytes) */
#define DEQ_LLB		0x21	/* Left loudness biquad (15bytes) */
#define DEQ_RLB		0x22	/* Right loudness biquad (15bytes) */
#define DEQ_LLB_GAIN	0x23	/* Left loudness biquad gain (3bytes) */
#define DEQ_RLB_GAIN	0x24	/* Right loudness biquad gain (3bytes) */
#define DEQ_ACR		0x40	/* Analog control register (1byte) */
#define DEQ_MCR2	0x43	/* Main control register 2 (1byte) */

#define DEQ_MCR1_FL	0x80	/* Fast load */
#define DEQ_MCR1_SC	0x40	/* SCLK frequency */
#define  DEQ_MCR1_SC_32	0x00	/*  32fs */
#define  DEQ_MCR1_SC_64	0x40	/*  64fs */
#define DEQ_MCR1_SM	0x30	/* Output serial port mode */
#define  DEQ_MCR1_SM_L	0x00	/*  Left justified */
#define  DEQ_MCR1_SM_R	0x10	/*  Right justified */
#define  DEQ_MCR1_SM_I2S 0x20	/*  I2S */
#define DEQ_MCR1_W	0x03	/* Serial port word length */
#define  DEQ_MCR1_W_16	0x00	/*  16 bit */
#define  DEQ_MCR1_W_18	0x01	/*  18 bit */
#define  DEQ_MCR1_W_20	0x02	/*  20 bit */

#define DEQ_MCR2_DL	0x80	/* Download */
#define DEQ_MCR2_AP	0x02	/* All pass mode */

#define DEQ_ACR_ADM	0x80	/* ADC output mode */
#define DEQ_ACR_LRB	0x40	/* Select B input */
#define DEQ_ACR_DM	0x0c	/* De-emphasis control */
#define  DEQ_ACR_DM_OFF	0x00	/*  off */
#define  DEQ_ACR_DM_48	0x04	/*  fs = 48kHz */
#define  DEQ_ACR_DM_44	0x08	/*  fs = 44.1kHz */
#define DEQ_ACR_INP	0x02	/* Analog input select */
#define  DEQ_ACR_INP_A	0x00	/*  A */
#define  DEQ_ACR_INP_B	0x02	/*  B */
#define DEQ_ACR_APD	0x01	/* Analog power down */

struct tas3004_reg {
	u_char MCR1[1];
	u_char DRC[6];
	u_char VOLUME[6];
	u_char TREBLE[1];
	u_char BASS[1];
	u_char MIXER_L[9];
	u_char MIXER_R[9];
	u_char LB0[15];
	u_char LB1[15];
	u_char LB2[15];
	u_char LB3[15];
	u_char LB4[15];
	u_char LB5[15];
	u_char LB6[15];
	u_char RB0[15];
	u_char RB1[15];
	u_char RB2[15];
	u_char RB3[15];
	u_char RB4[15];
	u_char RB5[15];
	u_char RB6[15];
	u_char LLB[15];
	u_char RLB[15];
	u_char LLB_GAIN[3];
	u_char RLB_GAIN[3];
	u_char ACR[1];
	u_char MCR2[1];
};

int
snapper_match(struct device *parent, void *match, void *aux)
{
	struct confargs *ca = aux;
	int soundbus, soundchip, soundcodec;
	char compat[32];

	if (strcmp(ca->ca_name, "i2s") != 0)
		return (0);

	if ((soundbus = OF_child(ca->ca_node)) == 0 ||
	    (soundchip = OF_child(soundbus)) == 0)
		return (0);

	bzero(compat, sizeof compat);
	OF_getprop(soundchip, "compatible", compat, sizeof compat);

	if (strcmp(compat, "snapper") == 0)
		return (1);

	if (OF_getprop(soundchip, "platform-tas-codec-ref",
	    &soundcodec, sizeof soundcodec) == sizeof soundcodec)
		return (1);

	return (0);
}

void
snapper_attach(struct device *parent, struct device *self, void *aux)
{
	struct snapper_softc *sc = (struct snapper_softc *)self;

	sc->sc_setvolume = snapper_set_volume;
	sc->sc_setbass = snapper_set_bass;
	sc->sc_settreble = snapper_set_treble;
	sc->sc_setinput = snapper_set_input;

	i2s_attach(parent, sc, aux);
	config_defer(self, snapper_defer);
}

void
snapper_defer(struct device *dev)
{
	struct snapper_softc *sc = (struct snapper_softc *)dev;
	struct device *dv;

	TAILQ_FOREACH(dv, &alldevs, dv_list)
		if (strcmp(dv->dv_cfdata->cf_driver->cd_name, "kiic") == 0 &&
		    strcmp(dv->dv_parent->dv_cfdata->cf_driver->cd_name, "macobio") == 0)
			sc->sc_i2c = dv;
	if (sc->sc_i2c == NULL) {
		printf("%s: unable to find i2c\n", sc->sc_dev.dv_xname);
		return;
	}

	/* XXX If i2c has failed to attach, what should we do? */

	audio_attach_mi(&snapper_hw_if, sc, &sc->sc_dev);

	/* kiic_setmode(sc->sc_i2c, I2C_STDSUBMODE); */
	snapper_init(sc);
}

void
snapper_set_volume(struct snapper_softc *sc, int left, int right)
{
	u_char vol[6];
	int nentries = sizeof(snapper_volumetab) / sizeof(snapper_volumetab[0]);
	int l, r;

	sc->sc_vol_l = left;
	sc->sc_vol_r = right;

	l = nentries - (left * nentries / 256);
	r = nentries - (right * nentries / 256);

	DPRINTF(" left %d vol %d %d, right %d vol %d %d\n",
		left, l, nentries,
		right, r, nentries);
	if (l >= nentries)
		l = nentries-1;
	if (r >= nentries)
		r = nentries-1;

	vol[0] = snapper_volumetab[l].high;
	vol[1] = snapper_volumetab[l].mid;
	vol[2] = snapper_volumetab[l].low;
	vol[3] = snapper_volumetab[r].high;
	vol[4] = snapper_volumetab[r].mid;
	vol[5] = snapper_volumetab[r].low;

	tas3004_write(sc, DEQ_VOLUME, vol);
}

void
snapper_set_treble(struct snapper_softc *sc, int value)
{
	uint8_t reg;

	if ((value >= 0) && (value <= 255) && (value != sc->sc_treble)) {
		reg = snapper_trebletab[(value >> 3) + 2];
		if (tas3004_write(sc, DEQ_TREBLE, &reg) < 0)
			return;
		sc->sc_treble = value;
	}
}

void
snapper_set_bass(struct snapper_softc *sc, int value)
{
	uint8_t reg;

	if ((value >= 0) && (value <= 255) && (value != sc->sc_bass)) {
		reg = snapper_basstab[(value >> 3) + 2];
		if (tas3004_write(sc, DEQ_BASS, &reg) < 0)
			return;
		sc->sc_bass = value;
	}
}

void
snapper_set_input(struct snapper_softc *sc, int mask)
{
	uint8_t val = 0;

	switch (mask) {
	case    1 << 0: /* microphone */
		val = DEQ_ACR_ADM | DEQ_ACR_LRB | DEQ_ACR_INP_B;
		break;
	case    1 << 1: /* line in */
		val = 0;
		break;
	}
	tas3004_write(sc, DEQ_ACR, &val);
}

const struct tas3004_reg tas3004_initdata = {
	{ DEQ_MCR1_SC_64 | DEQ_MCR1_SM_I2S | DEQ_MCR1_W_20 },	/* MCR1 */
	{ 1, 0, 0, 0, 0, 0 },					/* DRC */
	{ 0x00, 0xd7, 0x66, 0x00, 0xd7, 0x66 },			/* VOLUME */
	{ 0x72 },						/* TREBLE */
	{ 0x72 },						/* BASS */
	{ 0x10, 0x00, 0x00, 0, 0, 0, 0, 0, 0 },			/* MIXER_L */
	{ 0x10, 0x00, 0x00, 0, 0, 0, 0, 0, 0 },			/* MIXER_R */
	{ 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	/* BIQUAD */
	{ 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	/* BIQUAD */
	{ 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	/* BIQUAD */
	{ 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	/* BIQUAD */
	{ 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	/* BIQUAD */
	{ 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	/* BIQUAD */
	{ 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	/* BIQUAD */
	{ 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	/* BIQUAD */
	{ 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	/* BIQUAD */
	{ 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	/* BIQUAD */
	{ 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	/* BIQUAD */
	{ 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	/* BIQUAD */
	{ 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	/* BIQUAD */
	{ 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	/* BIQUAD */
	{ 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	/* BIQUAD */
	{ 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	/* BIQUAD */
	{ 0, 0, 0 },						/* LLB_GAIN */
	{ 0, 0, 0 },						/* RLB_GAIN */
	{ DEQ_ACR_ADM | DEQ_ACR_LRB | DEQ_ACR_INP_B },		/* ACR */
	{ 0 }							/* MCR2 */
};

const char tas3004_regsize[] = {
	0,					/* 0x00 */
	sizeof tas3004_initdata.MCR1,		/* 0x01 */
	sizeof tas3004_initdata.DRC,		/* 0x02 */
	0,					/* 0x03 */
	sizeof tas3004_initdata.VOLUME,		/* 0x04 */
	sizeof tas3004_initdata.TREBLE,		/* 0x05 */
	sizeof tas3004_initdata.BASS,		/* 0x06 */
	sizeof tas3004_initdata.MIXER_L,	/* 0x07 */
	sizeof tas3004_initdata.MIXER_R,	/* 0x08 */
	0,					/* 0x09 */
	sizeof tas3004_initdata.LB0,		/* 0x0a */
	sizeof tas3004_initdata.LB1,		/* 0x0b */
	sizeof tas3004_initdata.LB2,		/* 0x0c */
	sizeof tas3004_initdata.LB3,		/* 0x0d */
	sizeof tas3004_initdata.LB4,		/* 0x0e */
	sizeof tas3004_initdata.LB5,		/* 0x0f */
	sizeof tas3004_initdata.LB6,		/* 0x10 */
	0,					/* 0x11 */
	0,					/* 0x12 */
	sizeof tas3004_initdata.RB0,		/* 0x13 */
	sizeof tas3004_initdata.RB1,		/* 0x14 */
	sizeof tas3004_initdata.RB2,		/* 0x15 */
	sizeof tas3004_initdata.RB3,		/* 0x16 */
	sizeof tas3004_initdata.RB4,		/* 0x17 */
	sizeof tas3004_initdata.RB5,		/* 0x18 */
	sizeof tas3004_initdata.RB6,		/* 0x19 */
	0,0,0,0, 0,0,
	0,					/* 0x20 */
	sizeof tas3004_initdata.LLB,		/* 0x21 */
	sizeof tas3004_initdata.RLB,		/* 0x22 */
	sizeof tas3004_initdata.LLB_GAIN,	/* 0x23 */
	sizeof tas3004_initdata.RLB_GAIN,	/* 0x24 */
	0,0,0,0, 0,0,0,0, 0,0,0,
	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
	sizeof tas3004_initdata.ACR,		/* 0x40 */
	0,					/* 0x41 */
	0,					/* 0x42 */
	sizeof tas3004_initdata.MCR2		/* 0x43 */
};

#define DEQaddr 0x6a

int
tas3004_write(struct snapper_softc *sc, u_int reg, const void *data)
{
	int size;

	KASSERT(reg < sizeof tas3004_regsize);
	size = tas3004_regsize[reg];
	KASSERT(size > 0);

	if (kiic_write(sc->sc_i2c, DEQaddr, reg, data, size))
		return (-1);

	return (0);
}

#define DEQ_WRITE(sc, reg, addr) \
	if (tas3004_write(sc, reg, addr)) goto err

int
tas3004_init(struct snapper_softc *sc)
{
	deq_reset(sc);

	DEQ_WRITE(sc, DEQ_LB0, tas3004_initdata.LB0);
	DEQ_WRITE(sc, DEQ_LB1, tas3004_initdata.LB1);
	DEQ_WRITE(sc, DEQ_LB2, tas3004_initdata.LB2);
	DEQ_WRITE(sc, DEQ_LB3, tas3004_initdata.LB3);
	DEQ_WRITE(sc, DEQ_LB4, tas3004_initdata.LB4);
	DEQ_WRITE(sc, DEQ_LB5, tas3004_initdata.LB5);
	DEQ_WRITE(sc, DEQ_LB6, tas3004_initdata.LB6);
	DEQ_WRITE(sc, DEQ_RB0, tas3004_initdata.RB0);
	DEQ_WRITE(sc, DEQ_RB1, tas3004_initdata.RB1);
	DEQ_WRITE(sc, DEQ_RB1, tas3004_initdata.RB1);
	DEQ_WRITE(sc, DEQ_RB2, tas3004_initdata.RB2);
	DEQ_WRITE(sc, DEQ_RB3, tas3004_initdata.RB3);
	DEQ_WRITE(sc, DEQ_RB4, tas3004_initdata.RB4);
	DEQ_WRITE(sc, DEQ_RB5, tas3004_initdata.RB5);
	DEQ_WRITE(sc, DEQ_RB6, tas3004_initdata.RB6);
	DEQ_WRITE(sc, DEQ_MCR1, tas3004_initdata.MCR1);
	DEQ_WRITE(sc, DEQ_MCR2, tas3004_initdata.MCR2);
	DEQ_WRITE(sc, DEQ_DRC, tas3004_initdata.DRC);
	DEQ_WRITE(sc, DEQ_VOLUME, tas3004_initdata.VOLUME);
	DEQ_WRITE(sc, DEQ_TREBLE, tas3004_initdata.TREBLE);
	DEQ_WRITE(sc, DEQ_BASS, tas3004_initdata.BASS);
	DEQ_WRITE(sc, DEQ_MIXER_L, tas3004_initdata.MIXER_L);
	DEQ_WRITE(sc, DEQ_MIXER_R, tas3004_initdata.MIXER_R);
	DEQ_WRITE(sc, DEQ_LLB, tas3004_initdata.LLB);
	DEQ_WRITE(sc, DEQ_RLB, tas3004_initdata.RLB);
	DEQ_WRITE(sc, DEQ_LLB_GAIN, tas3004_initdata.LLB_GAIN);
	DEQ_WRITE(sc, DEQ_RLB_GAIN, tas3004_initdata.RLB_GAIN);
	DEQ_WRITE(sc, DEQ_ACR, tas3004_initdata.ACR);

	return (0);
err:
	printf("%s: tas3004_init failed\n", sc->sc_dev.dv_xname);
	return (-1);
}

void
snapper_init(struct snapper_softc *sc)
{

	/* "sample-rates" (44100, 48000) */
	i2s_set_rate(sc, 44100);

#if 1
	/* Enable I2C interrupts. */
#define IER 4
#define I2C_INT_DATA 0x01
#define I2C_INT_ADDR 0x02
#define I2C_INT_STOP 0x04
	kiic_writereg(sc->sc_i2c, IER,I2C_INT_DATA|I2C_INT_ADDR|I2C_INT_STOP);
#endif

	if (tas3004_init(sc))
		return;

	snapper_set_volume(sc, 190, 190);
	snapper_set_treble(sc, 128); /* 0 dB */
	snapper_set_bass(sc, 128); /* 0 dB */

	/* Mic in, reflects tas3004_initdata.ACR */
	sc->sc_record_source = 1 << 1;
	snapper_set_input(sc, sc->sc_record_source);
}
@


1.36
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.34 2008/11/06 10:01:50 todd Exp $	*/
a61 1
int snapper_getdev(void *, struct audio_device *);
a92 1
	snapper_getdev,
a104 6
struct audio_device snapper_device = {
	"SNAPPER",
	"",
	"snapper"
};

a721 7
}

int
snapper_getdev(void *h, struct audio_device *retp)
{
	*retp = snapper_device;
	return (0);
@


1.35
log
@Do not do strncmp comparisons on dv_xname because longer device names which
look similar could arrive in the future.  Instead, compare directly against
dv_cfdata->cf_driver->cd_name
Issue originally spotted by miod
@
text
@a69 1
void snapper_get_default_params(void *, int, struct audio_params *);
a83 2
	NULL,
	i2s_query_encoding,
a101 1
	i2s_mappage,
d104 1
a104 2
	i2s_trigger_input,
	snapper_get_default_params
a736 6
}

void
snapper_get_default_params(void *addr, int mode, struct audio_params *params)
{
	i2s_get_default_params(params);
@


1.34
log
@input and volume twiddles
o set init data to match snapper_set_foo*
o set volume to 190 (audible compared to the default)
o set input to mic (most common usage)
ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.33 2008/11/05 01:43:09 jakemsr Exp $	*/
d489 2
a490 2
		if (strncmp(dv->dv_xname, "kiic", 4) == 0 &&
		    strncmp(dv->dv_parent->dv_xname, "macobio", 7) == 0)
@


1.33
log
@
* use uint8_t instead of int to hold the value of an 8-bit register.
* for outputs.{bass,treble}, 0 dB corresponds to mixer value 128,
  not 0.
* line-in is configured as the default recording source; set
  sc->sc_record_source accordingly.
* add missing register to initialization code.

from Marco (marco2z at arsystel com), thanks

testing/ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.32 2008/10/29 00:04:14 jakemsr Exp $	*/
d581 1
a581 1
	{ 0, 0, 0, 0, 0, 0 },					/* VOLUME */
d604 1
a604 1
	{ 0 },							/* ACR */
d728 1
a728 1
	snapper_set_volume(sc, 80, 80);
d732 1
a732 1
	/* Line in, reflects tas3004_initdata.ACR */
d734 1
@


1.32
log
@
native default parameters for i2s devices instead of 8kHz
mulaw mono, which few can even do.

"Please just get this in." brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.31 2008/08/25 03:16:22 todd Exp $	*/
d565 3
a567 2
	int val = 0;
	switch(mask) {
d688 1
d729 5
@


1.31
log
@how about i commit what was actually approved? wrong tree, bad todd ;-(
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.30 2008/08/24 23:44:44 todd Exp $	*/
d70 1
d109 1
a109 1
	NULL
d734 6
@


1.30
log
@o implement proper volume control table based on chipset docs
o attempt to make record work (but silence for now)
from drahn@@, ok maja@@, drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.29 2008/04/21 00:32:42 jakemsr Exp $	*/
d201 1
a201 1
	{ 0x07, 0x7F, 0xBB }, 0x/* 17.5 */
@


1.29
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.28 2007/04/23 16:27:20 deraadt Exp $	*/
d69 1
d197 157
d475 1
d508 2
d514 2
a515 2
	left <<= 8;	/* XXX for now */
	right <<= 8;
d517 14
a530 6
	vol[0] = left >> 16;
	vol[1] = left >> 8;
	vol[2] = left;
	vol[3] = right >> 16;
	vol[4] = right >> 8;
	vol[5] = right;
d559 15
@


1.28
log
@rename drivers with numbers in them; ok gwk drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.27 2005/12/28 10:08:07 kettenis Exp $	*/
d107 1
@


1.27
log
@Fix totally bogus previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.26 2005/12/17 00:04:10 kettenis Exp $	*/
d58 2
a59 2
int ki2c_write(struct device *, int, int, const void *, int);
int ki2c_writereg(struct device *, int, u_int);
d328 1
a328 1
		if (strncmp(dv->dv_xname, "ki2c", 4) == 0 &&
d340 1
a340 1
	/* ki2c_setmode(sc->sc_i2c, I2C_STDSUBMODE); */
d473 1
a473 1
	if (ki2c_write(sc->sc_i2c, DEQaddr, reg, data, size))
d534 1
a534 1
	ki2c_writereg(sc->sc_i2c, IER,I2C_INT_DATA|I2C_INT_ADDR|I2C_INT_STOP);
@


1.26
log
@Make sure we match the correct driver for newer macppc systems.
tested by xsa@@, ok joris@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.25 2005/11/05 04:26:22 brad Exp $	*/
d298 1
a298 1
	if (strcmp(compat, "snapper"))
d302 1
a302 1
	    &soundcodec, sizeof soundcodec))
@


1.25
log
@some driver cleanup, ANSI/KNF and more consistency between the drivers.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.24 2005/10/31 01:16:29 brad Exp $	*/
d285 1
a285 1
	int soundbus, soundchip;
d298 6
a303 2
	if (strcmp(compat, "snapper") != 0)
		return (0);
d305 1
a305 1
	return (1);
@


1.24
log
@update datasheet URL.
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.23 2005/10/31 00:26:07 joris Exp $	*/
a37 1
#include <sys/malloc.h>
a39 1
#include <dev/auconv.h>
a40 1
#include <dev/mulaw.h>
a43 2
#include <uvm/uvm_extern.h>

a44 1
#include <machine/pio.h>
d49 1
a49 1
# define DPRINTF(x) printf x 
d51 1
a51 1
# define DPRINTF(x)
d282 1
a282 4
snapper_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d289 1
a289 1
		return 0;
d293 1
a293 1
		return 0;
d299 1
a299 1
		return 0;
d301 1
a301 1
	return 1;
d305 1
a305 4
snapper_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d341 1
a341 3
snapper_set_volume(sc, left, right)
	struct snapper_softc *sc;
	int left, right;
d461 1
a461 4
tas3004_write(sc, reg, data)
	struct snapper_softc *sc;
	u_int reg;
	const void *data;
d470 1
a470 1
		return -1;
d472 1
a472 1
	return 0;
d479 1
a479 2
tas3004_init(sc)
	struct snapper_softc *sc;
d511 1
a511 1
	return 0;
d514 1
a514 1
	return -1;
@


1.23
log
@- add needed bass & treble glue in i2s;
- add support for bass & treble in snapper;

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.22 2005/10/31 00:04:54 joris Exp $	*/
d32 1
a32 1
 * http://www.ti.com/sc/docs/products/analog/tas3004.html
d343 1
a343 1
	
a490 2

#define reset_active 0	/* XXX OF */
@


1.22
log
@add aoa audio support, found in several macppc machines
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.21 2005/10/28 15:27:49 joris Exp $	*/
d73 2
d121 80
d322 2
d373 26
@


1.21
log
@kill unneeded node argument in snapper_init()
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.20 2005/10/26 17:57:20 joris Exp $	*/
d225 1
a225 2
	if (strcmp(compat, "snapper") != 0 &&
	    strcmp(compat, "AOAKeylargo") != 0)
@


1.20
log
@add an i2s framework, which can be reused in new audio drivers
for macppc, as most modern Apple machines have i2s-based audio.

also let snapper use i2s.c right away;

tested by Antoine Jacoutot, drahn@@ and kettenis@@
"yes, commit!" drahn@@, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.19 2005/10/20 20:35:12 joris Exp $	*/
d67 1
a67 1
void snapper_init(struct snapper_softc *, int);
d266 1
a266 1
	snapper_init(sc, sc->sc_node);
d429 1
a429 3
snapper_init(sc, node)
	struct snapper_softc *sc;
	int node;
@


1.19
log
@revert to revision 1.16 for now, 1.17 and 1.18 broke audio
on a lot of macppc machines that use this driver;

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.16 2005/05/26 22:51:50 drahn Exp $	*/
d52 2
d60 2
a61 2
#define	SNAPPER_DMALIST_MAX	32
#define	SNAPPER_DMASEG_MAX	NBPG
d63 3
a65 40
struct snapper_dma {
	bus_dmamap_t map;
	caddr_t addr;
	bus_dma_segment_t segs[SNAPPER_DMALIST_MAX];
	int nsegs;
	size_t size;
	struct snapper_dma *next;
};

struct snapper_softc {
	struct device sc_dev;
	int sc_flags;
	int sc_node;

	void (*sc_ointr)(void *);	/* dma completion intr handler */
	void *sc_oarg;			/* arg for sc_ointr() */
	int sc_opages;			/* # of output pages */

	void (*sc_iintr)(void *);	/* dma completion intr handler */
	void *sc_iarg;			/* arg for sc_iintr() */

	u_int sc_record_source;		/* recording source mask */
	u_int sc_output_mask;		/* output source mask */

	u_char *sc_reg;
	struct device *sc_i2c;

	u_int sc_vol_l;
	u_int sc_vol_r;

	bus_dma_tag_t sc_dmat;
	dbdma_regmap_t *sc_odma;
	dbdma_regmap_t *sc_idma;
	struct dbdma_command *sc_odmacmd, *sc_odmap;
	struct dbdma_command *sc_idmacmd, *sc_idmap;
	dbdma_t sc_odbdma, sc_idbdma;

	struct snapper_dma *sc_dmas;
	u_long sc_rate;
};
d67 2
a71 20
int snapper_intr(void *);
int snapper_open(void *, int);
void snapper_close(void *);
int snapper_query_encoding(void *, struct audio_encoding *);
int snapper_set_params(void *, int, int, struct audio_params *,
    struct audio_params *);
int snapper_round_blocksize(void *, int);
int snapper_halt_output(void *);
int snapper_halt_input(void *);
int snapper_getdev(void *, struct audio_device *);
int snapper_set_port(void *, mixer_ctrl_t *);
int snapper_get_port(void *, mixer_ctrl_t *);
int snapper_query_devinfo(void *, mixer_devinfo_t *);
size_t snapper_round_buffersize(void *, int, size_t);
paddr_t snapper_mappage(void *, void *, off_t, int);
int snapper_get_props(void *);
int snapper_trigger_output(void *, void *, void *, int, void (*)(void *),
    void *, struct audio_params *);
int snapper_trigger_input(void *, void *, void *, int, void (*)(void *),
    void *, struct audio_params *);
a72 4
int snapper_set_rate(struct snapper_softc *, int);
void snapper_config(struct snapper_softc *sc, int node, struct device *parent);
struct snapper_mode *snapper_find_mode(u_int, u_int, u_int);
void snapper_cs16mts(void *, u_char *, int);
a74 5
static int gpio_read(char *);
static void gpio_write(char *, int);
void snapper_mute_speaker(struct snapper_softc *, int);
void snapper_mute_headphone(struct snapper_softc *, int);
int snapper_cint(void *);
a75 11
void snapper_init(struct snapper_softc *, int);
void *snapper_allocm(void *h, int dir, size_t size, int type, int flags);

static void mono16_to_stereo16(void *, u_char *, int);
static void swap_bytes_mono16_to_stereo16(void *, u_char *, int);

/* XXX */
int ki2c_setmode(struct device *, int);
int ki2c_write(struct device *, int, int, const void *, int);
void ki2c_writereg(struct device *, int, u_int);

d85 2
a86 2
	snapper_open,
	snapper_close,
d88 3
a90 3
	snapper_query_encoding,
	snapper_set_params,
	snapper_round_blocksize,
d96 2
a97 2
	snapper_halt_output,
	snapper_halt_input,
d101 4
a104 4
	snapper_set_port,
	snapper_get_port,
	snapper_query_devinfo,
	snapper_allocm,		/* allocm */
d106 5
a110 5
	snapper_round_buffersize,
	snapper_mappage,
	snapper_get_props,
	snapper_trigger_output,
	snapper_trigger_input,
a118 14
static u_char *amp_mute;
static u_char *headphone_mute;
static u_char *audio_hw_reset;
static u_char *headphone_detect;
static int headphone_detect_active;


/* I2S registers */
#define I2S_INT		0x00
#define I2S_FORMAT	0x10
#define I2S_FRAMECOUNT	0x40
#define I2S_FRAMEMATCH	0x50
#define I2S_WORDSIZE	0x60

a204 18
#define GPIO_OUTSEL	0xf0	/* Output select */
		/*	0x00	GPIO bit0 is output
			0x10	media-bay power
			0x20	reserved
			0x30	MPIC */

#define GPIO_ALTOE	0x08	/* Alternate output enable */
		/*	0x00	Use DDR
			0x08	Use output select */

#define GPIO_DDR	0x04	/* Data direction */
#define GPIO_DDR_OUTPUT	0x04	/* Output */
#define GPIO_DDR_INPUT	0x00	/* Input */

#define GPIO_LEVEL	0x02	/* Pin level (RO) */

#define	GPIO_DATA	0x01	/* Data */

a238 3
	struct confargs *ca = aux;
	int cirq, oirq, iirq, cirq_type, oirq_type, iirq_type;
	int soundbus, intr[6];
d240 1
a240 29
	ca->ca_reg[0] += ca->ca_baseaddr;
	ca->ca_reg[2] += ca->ca_baseaddr;
	ca->ca_reg[4] += ca->ca_baseaddr;

	sc->sc_reg = mapiodev(ca->ca_reg[0], ca->ca_reg[1]);

	sc->sc_node = ca->ca_node;

	sc->sc_dmat = ca->ca_dmat;
	sc->sc_odma = mapiodev(ca->ca_reg[2], ca->ca_reg[3]); /* out */
	sc->sc_idma = mapiodev(ca->ca_reg[4], ca->ca_reg[5]); /* in */
	sc->sc_odbdma = dbdma_alloc(sc->sc_dmat, SNAPPER_DMALIST_MAX);
	sc->sc_odmacmd = sc->sc_odbdma->d_addr;
	sc->sc_idbdma = dbdma_alloc(sc->sc_dmat, SNAPPER_DMALIST_MAX);
	sc->sc_idmacmd = sc->sc_idbdma->d_addr;

	soundbus = OF_child(ca->ca_node);
	OF_getprop(soundbus, "interrupts", intr, sizeof intr);
	cirq = intr[0];
	oirq = intr[2];
	iirq = intr[4];
	cirq_type = intr[1] ? IST_LEVEL : IST_EDGE;
	oirq_type = intr[3] ? IST_LEVEL : IST_EDGE;
	iirq_type = intr[5] ? IST_LEVEL : IST_EDGE;

	/* intr_establish(cirq, cirq_type, IPL_AUDIO, snapper_intr, sc); */
	mac_intr_establish(parent, oirq, oirq_type, IPL_AUDIO, snapper_intr,
	    sc, "snapper");
	/* intr_establish(iirq, iirq_type, IPL_AUDIO, snapper_intr, sc); */
d242 1
a242 3
	printf(": irq %d,%d,%d\n", cirq, oirq, iirq);

	snapper_config(sc,  sc->sc_node, parent);
a268 644
int
snapper_intr(v)
	void *v;
{
	struct snapper_softc *sc = v;
	struct dbdma_command *cmd = sc->sc_odmap;
#ifndef __OpenBSD__
	int count = sc->sc_opages;
	int status;
#else
	u_int16_t c, status;
#endif

	/* if not set we are not running */
	if (!cmd)
		return (0);
	DPRINTF(("snapper_intr: cmd %x\n", cmd));

#ifndef __OpenBSD__
	/* Fill used buffer(s). */
	while (count-- > 0) {
		if ((dbdma_ld16(&cmd->d_command) & 0x30) == 0x30) {
			status = dbdma_ld16(&cmd->d_status);
			cmd->d_status = 0;
			if (status)	/* status == 0x8400 */
				if (sc->sc_ointr)
					(*sc->sc_ointr)(sc->sc_oarg);
		}
		cmd++;
	}
#else
	c = in16rb(&cmd->d_command);
	status = in16rb(&cmd->d_status);

	if (c >> 12 == DBDMA_CMD_OUT_LAST)
		sc->sc_odmap = sc->sc_odmacmd;
	else
		sc->sc_odmap++;

	if (c & (DBDMA_INT_ALWAYS << 4)) {
		cmd->d_status = 0;
		if (status)	/* status == 0x8400 */
			if (sc->sc_ointr)
				(*sc->sc_ointr)(sc->sc_oarg);
	}
#endif

	return 1;
}

int
snapper_open(h, flags)
	void *h;
	int flags;
{
	return 0;
}

/*
 * Close function is called at splaudio().
 */
void
snapper_close(h)
	void *h;
{
	struct snapper_softc *sc = h;

	snapper_halt_output(sc);
	snapper_halt_input(sc);

	sc->sc_ointr = 0;
	sc->sc_iintr = 0;
}

int
snapper_query_encoding(h, ae)
	void *h;
	struct audio_encoding *ae;
{
	int err = 0;

	switch (ae->index) {
	case 0:
		strlcpy(ae->name, AudioEslinear, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_SLINEAR;
		ae->precision = 16;
		ae->flags = 0;
		break;
	case 1:
		strlcpy(ae->name, AudioEslinear_be, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_SLINEAR_BE;
		ae->precision = 16;
		ae->flags = 0;
		break;
	case 2:
		strlcpy(ae->name, AudioEslinear_le, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_SLINEAR_LE;
		ae->precision = 16;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 3:
		strlcpy(ae->name, AudioEulinear_be, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_ULINEAR_BE;
		ae->precision = 16;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 4:
		strlcpy(ae->name, AudioEulinear_le, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_ULINEAR_LE;
		ae->precision = 16;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 5:
		strlcpy(ae->name, AudioEmulaw, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_ULAW;
		ae->precision = 8;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
		strlcpy(ae->name, AudioEalaw, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_ALAW;
		ae->precision = 8;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(ae->name, AudioEslinear, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_SLINEAR;
		ae->precision = 8;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 8:
		strlcpy(ae->name, AudioEulinear, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_ULINEAR;
		ae->precision = 8;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	default:
		err = EINVAL;
		break;
	}
	return (err);
}

static void
mono16_to_stereo16(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	int x;
	int16_t *src, *dst;

	src = (void *)(p + cc);
	dst = (void *)(p + cc * 2);
	while (cc > 0) {
		x = *--src;
		*--dst = x;
		*--dst = x;
		cc -= 2;
	}
}

static void
swap_bytes_mono16_to_stereo16(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	swap_bytes(v, p, cc);
	mono16_to_stereo16(v, p, cc);
}

void
snapper_cs16mts(void *v, u_char *p, int cc)
{
	mono16_to_stereo16(v, p, cc);
	change_sign16_be(v, p, cc * 2);
}

struct snapper_mode {
	u_int encoding;
	u_int precision;
	u_int channels;
	void (*sw_code)(void *, u_char *, int);
	int factor;
} snapper_modes[] = {
	{ AUDIO_ENCODING_SLINEAR_LE,  8, 1, linear8_to_linear16_be_mts, 4 },
	{ AUDIO_ENCODING_SLINEAR_LE,  8, 2, linear8_to_linear16_be, 2 },
	{ AUDIO_ENCODING_SLINEAR_LE, 16, 1, swap_bytes_mono16_to_stereo16, 2 },
	{ AUDIO_ENCODING_SLINEAR_LE, 16, 2, swap_bytes, 1 },
	{ AUDIO_ENCODING_SLINEAR_BE,  8, 1, linear8_to_linear16_be_mts, 4 },
	{ AUDIO_ENCODING_SLINEAR_BE,  8, 2, linear8_to_linear16_be, 2 },
	{ AUDIO_ENCODING_SLINEAR_BE, 16, 1, mono16_to_stereo16, 2 },
	{ AUDIO_ENCODING_SLINEAR_BE, 16, 2, NULL, 1 },
	{ AUDIO_ENCODING_ULINEAR_LE,  8, 1, ulinear8_to_linear16_be_mts, 4 },
	{ AUDIO_ENCODING_ULINEAR_LE,  8, 2, ulinear8_to_linear16_be, 2 },
	{ AUDIO_ENCODING_ULINEAR_LE, 16, 1, change_sign16_swap_bytes_le_mts, 2 },
	{ AUDIO_ENCODING_ULINEAR_LE, 16, 2, swap_bytes_change_sign16_be, 1 },
	{ AUDIO_ENCODING_ULINEAR_BE,  8, 1, ulinear8_to_linear16_be_mts, 4 },
	{ AUDIO_ENCODING_ULINEAR_BE,  8, 2, ulinear8_to_linear16_be, 2 },
	{ AUDIO_ENCODING_ULINEAR_BE, 16, 1, snapper_cs16mts, 2 },
	{ AUDIO_ENCODING_ULINEAR_BE, 16, 2, change_sign16_be, 1 }
};


struct snapper_mode *
snapper_find_mode(u_int encoding, u_int precision, u_int channels)
{
	struct snapper_mode *m;
	int i;

	for (i = 0; i < sizeof(snapper_modes)/sizeof(snapper_modes[0]); i++) {
		m = &snapper_modes[i];
		if (m->encoding == encoding &&
		    m->precision == precision &&
		    m->channels == channels)
			return (m);
	}
	return (NULL);
}

int
snapper_set_params(h, setmode, usemode, play, rec)
	void *h;
	int setmode, usemode;
	struct audio_params *play, *rec;
{
	struct snapper_mode *m;
	struct snapper_softc *sc = h;
	struct audio_params *p;
	int mode, rate;

	p = play; /* default to play */

	/*
	 * This device only has one clock, so make the sample rates match.
	 */
	if (play->sample_rate != rec->sample_rate &&
	    usemode == (AUMODE_PLAY | AUMODE_RECORD)) {
		if (setmode == AUMODE_PLAY) {
			rec->sample_rate = play->sample_rate;
			setmode |= AUMODE_RECORD;
		} else if (setmode == AUMODE_RECORD) {
			play->sample_rate = rec->sample_rate;
			setmode |= AUMODE_PLAY;
		} else
			return EINVAL;
	}

	for (mode = AUMODE_RECORD; mode != -1;
	     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
		if ((setmode & mode) == 0)
			continue;

		p = mode == AUMODE_PLAY ? play : rec;

		if (p->sample_rate < 4000 || p->sample_rate > 50000 ||
		    (p->precision != 8 && p->precision != 16) ||
		    (p->channels != 1 && p->channels != 2))
			return EINVAL;

		switch (p->encoding) {
		case AUDIO_ENCODING_SLINEAR_LE:
		case AUDIO_ENCODING_SLINEAR_BE:
		case AUDIO_ENCODING_ULINEAR_LE:
		case AUDIO_ENCODING_ULINEAR_BE:
			m = snapper_find_mode(p->encoding, p->precision,
			    p->channels);
			if (m == NULL) {
				printf("mode not found: %u/%u/%u\n",
				    p->encoding, p->precision, p->channels);
				return (EINVAL);
			}
			p->factor = m->factor;
			p->sw_code = m->sw_code;
			break;

		case AUDIO_ENCODING_ULAW:
			if (mode == AUMODE_PLAY) {
				if (p->channels == 1) {
					p->factor = 4;
					p->sw_code = mulaw_to_slinear16_be_mts;
					break;
				}
				if (p->channels == 2) {
					p->factor = 2;
					p->sw_code = mulaw_to_slinear16_be;
					break;
				}
			} else
				break; /* XXX */
			return (EINVAL);

		case AUDIO_ENCODING_ALAW:
			if (mode == AUMODE_PLAY) {
				if (p->channels == 1) {
					p->factor = 4;
					p->sw_code = alaw_to_slinear16_be_mts;
					break;
				}
				if (p->channels == 2) {
					p->factor = 2;
					p->sw_code = alaw_to_slinear16_be;
					break;
				}
			} else
				break; /* XXX */
			return (EINVAL);

		default:
			return (EINVAL);
		}
	}

	/* Set the speed */
	p->sample_rate = play->sample_rate;
	rate = p->sample_rate;

	if (snapper_set_rate(sc, rate))
		return EINVAL;
	p->sample_rate = sc->sc_rate;

	return 0;
}

int
snapper_round_blocksize(h, size)
	void *h;
	int size;
{
	if (size < NBPG)
		size = NBPG;
	return size & ~PGOFSET;
}

int
snapper_halt_output(h)
	void *h;
{
	struct snapper_softc *sc = h;

	dbdma_stop(sc->sc_odma);
	dbdma_reset(sc->sc_odma);
	return 0;
}

int
snapper_halt_input(h)
	void *h;
{
	struct snapper_softc *sc = h;

	dbdma_stop(sc->sc_idma);
	dbdma_reset(sc->sc_idma);
	return 0;
}

int
snapper_getdev(h, retp)
	void *h;
	struct audio_device *retp;
{
	*retp = snapper_device;
	return 0;
}

enum {
	SNAPPER_MONITOR_CLASS,
	SNAPPER_OUTPUT_CLASS,
	SNAPPER_RECORD_CLASS,
	SNAPPER_OUTPUT_SELECT,
	SNAPPER_VOL_OUTPUT,
	SNAPPER_INPUT_SELECT,
	SNAPPER_VOL_INPUT,
	SNAPPER_ENUM_LAST
};

int
snapper_set_port(h, mc)
	void *h;
	mixer_ctrl_t *mc;
{
	struct snapper_softc *sc = h;
	int l, r;

	DPRINTF(("snapper_set_port dev = %d, type = %d\n", mc->dev, mc->type));

	l = mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
	r = mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];

	switch (mc->dev) {
	case SNAPPER_OUTPUT_SELECT:
		/* No change necessary? */
		if (mc->un.mask == sc->sc_output_mask)
			return 0;

		snapper_mute_speaker(sc, 1);
		snapper_mute_headphone(sc, 1);
		if (mc->un.mask & 1 << 0)
			snapper_mute_speaker(sc, 0);
		if (mc->un.mask & 1 << 1)
			snapper_mute_headphone(sc, 0);

		sc->sc_output_mask = mc->un.mask;
		return 0;

	case SNAPPER_VOL_OUTPUT:
		snapper_set_volume(sc, l, r);
		return 0;

	case SNAPPER_INPUT_SELECT:
		/* no change necessary? */
		if (mc->un.mask == sc->sc_record_source)
			return 0;
		switch (mc->un.mask) {
		case 1 << 0: /* CD */
		case 1 << 1: /* microphone */
		case 1 << 2: /* line in */
			/* XXX TO BE DONE */
			break;
		default: /* invalid argument */
			return EINVAL;
		}
		sc->sc_record_source = mc->un.mask;
		return 0;

	case SNAPPER_VOL_INPUT:
		/* XXX TO BE DONE */
		return 0;
	}

	return ENXIO;
}

int
snapper_get_port(h, mc)
	void *h;
	mixer_ctrl_t *mc;
{
	struct snapper_softc *sc = h;

	DPRINTF(("snapper_get_port dev = %d, type = %d\n", mc->dev, mc->type));

	switch (mc->dev) {
	case SNAPPER_OUTPUT_SELECT:
		mc->un.mask = sc->sc_output_mask;
		return 0;

	case SNAPPER_VOL_OUTPUT:
		mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = sc->sc_vol_l;
		mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = sc->sc_vol_r;
		return 0;

	case SNAPPER_INPUT_SELECT:
		mc->un.mask = sc->sc_record_source;
		return 0;

	case SNAPPER_VOL_INPUT:
		/* XXX TO BE DONE */
		mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = 0;
		mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = 0;
		return 0;

	default:
		return ENXIO;
	}

	return 0;
}

int
snapper_query_devinfo(h, dip)
	void *h;
	mixer_devinfo_t *dip;
{
	switch (dip->index) {

	case SNAPPER_OUTPUT_SELECT:
		dip->mixer_class = SNAPPER_MONITOR_CLASS;
		strlcpy(dip->label.name, AudioNoutput, sizeof(dip->label.name));
		dip->type = AUDIO_MIXER_SET;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		dip->un.s.num_mem = 2;
		strlcpy(dip->un.s.member[0].label.name, AudioNspeaker,
		    sizeof(dip->un.s.member[0].label.name));
		dip->un.s.member[0].mask = 1 << 0;
		strlcpy(dip->un.s.member[1].label.name, AudioNheadphone,
		    sizeof(dip->un.s.member[1].label.name));
		dip->un.s.member[1].mask = 1 << 1;
		return 0;

	case SNAPPER_VOL_OUTPUT:
		dip->mixer_class = SNAPPER_MONITOR_CLASS;
		strlcpy(dip->label.name, AudioNmaster, sizeof(dip->label.name));
		dip->type = AUDIO_MIXER_VALUE;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof(dip->un.v.units.name));
		return 0;

	case SNAPPER_INPUT_SELECT:
		dip->mixer_class = SNAPPER_RECORD_CLASS;
		strlcpy(dip->label.name, AudioNsource, sizeof(dip->label.name));
		dip->type = AUDIO_MIXER_SET;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		dip->un.s.num_mem = 3;
		strlcpy(dip->un.s.member[0].label.name, AudioNcd,
		    sizeof(dip->un.s.member[0].label.name));
		dip->un.s.member[0].mask = 1 << 0;
		strlcpy(dip->un.s.member[1].label.name, AudioNmicrophone,
		    sizeof(dip->un.s.member[1].label.name));
		dip->un.s.member[1].mask = 1 << 1;
		strlcpy(dip->un.s.member[2].label.name, AudioNline,
		    sizeof(dip->un.s.member[2].label.name));
		dip->un.s.member[2].mask = 1 << 2;
		return 0;

	case SNAPPER_VOL_INPUT:
		dip->mixer_class = SNAPPER_RECORD_CLASS;
		strlcpy(dip->label.name, AudioNrecord, sizeof(dip->label.name));
		dip->type = AUDIO_MIXER_VALUE;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof(dip->un.v.units.name));
		return 0;

	case SNAPPER_MONITOR_CLASS:
		dip->mixer_class = SNAPPER_MONITOR_CLASS;
		strlcpy(dip->label.name, AudioCmonitor, sizeof(dip->label.name));
		dip->type = AUDIO_MIXER_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		return 0;

	case SNAPPER_OUTPUT_CLASS:
		dip->mixer_class = SNAPPER_OUTPUT_CLASS;
		strlcpy(dip->label.name, AudioCoutputs,
		    sizeof(dip->label.name));
		dip->type = AUDIO_MIXER_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		return 0;

	case SNAPPER_RECORD_CLASS:
		dip->mixer_class = SNAPPER_RECORD_CLASS;
		strlcpy(dip->label.name, AudioCrecord, sizeof(dip->label.name));
		dip->type = AUDIO_MIXER_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		return 0;
	}

	return ENXIO;
}

size_t
snapper_round_buffersize(h, dir, size)
	void *h;
	int dir;
	size_t size;
{
	if (size > 65536)
		size = 65536;
	return size;
}

paddr_t
snapper_mappage(h, mem, off, prot)
	void *h;
	void *mem;
	off_t off;
	int prot;
{
	if (off < 0)
		return -1;
	return -1;	/* XXX */
}

int
snapper_get_props(h)
	void *h;
{
	return AUDIO_PROP_FULLDUPLEX /* | AUDIO_PROP_MMAP */;
}

int
snapper_trigger_output(h, start, end, bsize, intr, arg, param)
	void *h;
	void *start, *end;
	int bsize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
{
	struct snapper_softc *sc = h;
	struct snapper_dma *p;
	struct dbdma_command *cmd = sc->sc_odmacmd;
	vaddr_t spa, pa, epa;
	int c;

	DPRINTF(("trigger_output %p %p 0x%x\n", start, end, bsize));

	for (p = sc->sc_dmas; p && p->addr != start; p = p->next);
	if (!p)
		return -1;

	sc->sc_ointr = intr;
	sc->sc_oarg = arg;
	sc->sc_odmap = sc->sc_odmacmd;

	spa = p->segs[0].ds_addr;
	c = DBDMA_CMD_OUT_MORE;
	for (pa = spa, epa = spa + (end - start);
	    pa < epa; pa += bsize, cmd++) {

		if (pa + bsize == epa)
			c = DBDMA_CMD_OUT_LAST;

		DBDMA_BUILD(cmd, c, 0, bsize, pa, DBDMA_INT_ALWAYS,
			DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
	}

	DBDMA_BUILD(cmd, DBDMA_CMD_NOP, 0, 0, 0,
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_ALWAYS);
	dbdma_st32(&cmd->d_cmddep, sc->sc_odbdma->d_paddr);

	dbdma_start(sc->sc_odma, sc->sc_odbdma);

	return 0;
}

int
snapper_trigger_input(h, start, end, bsize, intr, arg, param)
	void *h;
	void *start, *end;
	int bsize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
{
	DPRINTF(("snapper_trigger_input called\n"));

	return 1;
}

a291 117
#define CLKSRC_49MHz	0x80000000	/* Use 49152000Hz Osc. */
#define CLKSRC_45MHz	0x40000000	/* Use 45158400Hz Osc. */
#define CLKSRC_18MHz	0x00000000	/* Use 18432000Hz Osc. */
#define MCLK_DIV	0x1f000000	/* MCLK = SRC / DIV */
#define  MCLK_DIV1	0x14000000	/*  MCLK = SRC */
#define  MCLK_DIV3	0x13000000	/*  MCLK = SRC / 3 */
#define  MCLK_DIV5	0x12000000	/*  MCLK = SRC / 5 */
#define SCLK_DIV	0x00f00000	/* SCLK = MCLK / DIV */
#define  SCLK_DIV1	0x00800000
#define  SCLK_DIV3	0x00900000
#define SCLK_MASTER	0x00080000	/* Master mode */
#define SCLK_SLAVE	0x00000000	/* Slave mode */
#define SERIAL_FORMAT	0x00070000
#define  SERIAL_SONY	0x00000000
#define  SERIAL_64x	0x00010000
#define  SERIAL_32x	0x00020000
#define  SERIAL_DAV	0x00040000
#define  SERIAL_SILICON	0x00050000

// rate = fs = LRCLK
// SCLK = 64*LRCLK (I2S)
// MCLK = 256fs (typ. -- changeable)

// MCLK = clksrc / mdiv
// SCLK = MCLK / sdiv
// rate = SCLK / 64    ( = LRCLK = fs)

int
snapper_set_rate(sc, rate)
	struct snapper_softc *sc;
	int rate;
{
	u_int reg = 0;
	int MCLK;
	int clksrc, mdiv, sdiv;
	int mclk_fs;

	/* sanify */
	if (rate > 48000)
		rate = 48000;
	else if (rate < 8000)
		rate = 8000;

	switch (rate) {
	case 8000:
		clksrc = 18432000;		/* 18MHz */
		reg = CLKSRC_18MHz;
		mclk_fs = 256;
		break;

	case 44100:
		clksrc = 45158400;		/* 45MHz */
		reg = CLKSRC_45MHz;
		mclk_fs = 256;
		break;

	case 48000:
		clksrc = 49152000;		/* 49MHz */
		reg = CLKSRC_49MHz;
		mclk_fs = 256;
		break;

	default:
		return EINVAL;
	}

	MCLK = rate * mclk_fs;
	mdiv = clksrc / MCLK;			// 4
	sdiv = mclk_fs / 64;			// 4

	switch (mdiv) {
	case 1:
		reg |= MCLK_DIV1;
		break;
	case 3:
		reg |= MCLK_DIV3;
		break;
	case 5:
		reg |= MCLK_DIV5;
		break;
	default:
		reg |= ((mdiv / 2 - 1) << 24) & 0x1f000000;
		break;
	}

	switch (sdiv) {
	case 1:
		reg |= SCLK_DIV1;
		break;
	case 3:
		reg |= SCLK_DIV3;
		break;
	default:
		reg |= ((sdiv / 2 - 1) << 20) & 0x00f00000;
		break;
	}

	reg |= SCLK_MASTER;	/* XXX master mode */

	reg |= SERIAL_64x;

	/* stereo input and output */
	DPRINTF(("I2SSetDataWordSizeReg 0x%08x -> 0x%08x\n",
	    in32rb(sc->sc_reg + I2S_WORDSIZE), 0x02000200));
	out32rb(sc->sc_reg + I2S_WORDSIZE, 0x02000200);

	DPRINTF(("I2SSetSerialFormatReg 0x%x -> 0x%x\n",
	    in32rb(sc->sc_reg + I2S_FORMAT), reg));
	out32rb(sc->sc_reg + I2S_FORMAT, reg);

	sc->sc_rate = rate;

	return 0;
}

#define DEQaddr 0x6a

d363 2
a382 88
int
gpio_read(addr)
	char *addr;
{
	if (*addr & GPIO_DATA)
		return 1;
	return 0;
}

void
gpio_write(addr, val)
	char *addr;
	int val;
{
	u_int data = GPIO_DDR_OUTPUT;

	if (val)
		data |= GPIO_DATA;
	*addr = data;
	asm volatile ("eieio" ::: "memory");
}

#define headphone_active 0	/* XXX OF */
#define amp_active 0		/* XXX OF */

void
snapper_mute_speaker(sc, mute)
	struct snapper_softc *sc;
	int mute;
{
	u_int x;

	DPRINTF(("ampmute %d --> ", gpio_read(amp_mute)));

	if (mute)
		x = amp_active;		/* mute */
	else
		x = !amp_active;	/* unmute */
	if (x != gpio_read(amp_mute))
		gpio_write(amp_mute, x);

	DPRINTF(("%d\n", gpio_read(amp_mute)));
}

void
snapper_mute_headphone(sc, mute)
	struct snapper_softc *sc;
	int mute;
{
	u_int x;

	DPRINTF(("headphonemute %d --> ", gpio_read(headphone_mute)));

	if (mute)
		x = headphone_active;	/* mute */
	else
		x = !headphone_active;	/* unmute */
	if (x != gpio_read(headphone_mute))
		gpio_write(headphone_mute, x);

	DPRINTF(("%d\n", gpio_read(headphone_mute)));
}

int
snapper_cint(v)
	void *v;
{
	struct snapper_softc *sc = v;
	u_int sense;

	sense = *headphone_detect;
	DPRINTF(("headphone detect = 0x%x\n", sense));

	if (((sense & 0x02) >> 1) == headphone_detect_active) {
		DPRINTF(("headphone is inserted\n"));
		snapper_mute_speaker(sc, 1);
		snapper_mute_headphone(sc, 0);
		sc->sc_output_mask = 1 << 1;
	} else {
		DPRINTF(("headphone is NOT inserted\n"));
		snapper_mute_speaker(sc, 0);
		snapper_mute_headphone(sc, 1);
		sc->sc_output_mask = 1 << 0;
	}

	return 1;
}

d392 1
a393 15
	/* No reset port.  Nothing to do. */
	if (audio_hw_reset == NULL)
		goto noreset;

	/* Reset TAS3004. */
	gpio_write(audio_hw_reset, !reset_active);	/* Negate RESET */
	delay(100000);				/* XXX Really needed? */

	gpio_write(audio_hw_reset, reset_active);	/* Assert RESET */
	delay(1);

	gpio_write(audio_hw_reset, !reset_active);	/* Negate RESET */
	delay(10000);

noreset:
a427 82
/* FCR(0x3c) bits */
#define I2S0CLKEN	0x1000
#define I2S0EN		0x2000
#define I2S1CLKEN	0x080000
#define I2S1EN		0x100000

#define FCR3C_BITMASK "\020\25I2S1EN\24I2S1CLKEN\16I2S0EN\15I2S0CLKEN"


void
snapper_config(sc, node, parent)
	struct snapper_softc *sc;
	int node;
	struct device *parent;
{
	int gpio;
	int headphone_detect_intr = -1, headphone_detect_intrtype;

#if 0
#ifdef SNAPPER_DEBUG
	char fcr[32];

	bitmask_snprintf(in32rb(0x8000003c), FCR3C_BITMASK, fcr, sizeof fcr);
	printf("FCR(0x3c) 0x%s\n", fcr);
#endif
#endif

	gpio = OF_getnodebyname(OF_parent(node), "gpio");
	DPRINTF((" /gpio 0x%x\n", gpio));
	gpio = OF_child(gpio);
	while (gpio) {
		char name[64], audio_gpio[64];
		int intr[2];
		paddr_t addr;

		bzero(name, sizeof name);
		bzero(audio_gpio, sizeof audio_gpio);
		addr = 0;
		OF_getprop(gpio, "name", name, sizeof name);
		OF_getprop(gpio, "audio-gpio", audio_gpio, sizeof audio_gpio);
		OF_getprop(gpio, "AAPL,address", &addr, sizeof addr);
		/* printf("0x%x %s %s\n", gpio, name, audio_gpio); */

		/* gpio5 */
		if (headphone_mute == NULL &&
		    strcmp(audio_gpio, "headphone-mute") == 0)
			headphone_mute = mapiodev(addr,1);

		/* gpio6 */
		if (amp_mute == NULL &&
		    strcmp(audio_gpio, "amp-mute") == 0)
			amp_mute = mapiodev(addr,1);

		/* extint-gpio15 */
		if (headphone_detect == NULL &&
		    strcmp(audio_gpio, "headphone-detect") == 0) {
			headphone_detect = mapiodev(addr,1);
			OF_getprop(gpio, "audio-gpio-active-state",
			    &headphone_detect_active, 4);
			OF_getprop(gpio, "interrupts", intr, 8);
			headphone_detect_intr = intr[0];
			headphone_detect_intrtype = intr[1];
		}

		/* gpio11 (keywest-11) */
		if (audio_hw_reset == NULL &&
		    strcmp(audio_gpio, "audio-hw-reset") == 0)
			audio_hw_reset = mapiodev(addr,1);

		gpio = OF_peer(gpio);
	}
	DPRINTF((" headphone-mute %p\n", headphone_mute));
	DPRINTF((" amp-mute %p\n", amp_mute));
	DPRINTF((" headphone-detect %p\n", headphone_detect));
	DPRINTF((" headphone-detect active %x\n", headphone_detect_active));
	DPRINTF((" headphone-detect intr %x\n", headphone_detect_intr));
	DPRINTF((" audio-hw-reset %p\n", audio_hw_reset));

	if (headphone_detect_intr != -1)
		mac_intr_establish(parent, headphone_detect_intr, IST_EDGE,
		    IPL_AUDIO, snapper_cint, sc, "snapper_h");
}
d435 1
a435 7
	snapper_set_rate(sc, 44100);

	/* Enable headphone interrupt? */
	*headphone_detect |= 0x80;
	asm volatile ("eieio" ::: "memory");

	/* i2c_set_port(port); */
a448 3
	/* Update headphone status. */
	snapper_cint(sc);

d452 2
a453 2
void *
snapper_allocm(void *h, int dir, size_t size, int type, int flags)
d455 2
a456 59
	struct snapper_softc *sc = h;
	struct snapper_dma *p;
	int error;

	if (size > SNAPPER_DMALIST_MAX * SNAPPER_DMASEG_MAX)
		return (NULL);

	p = malloc(sizeof(*p), type, flags);
	if (!p)
		return (NULL);
	bzero(p, sizeof(*p));

	/* convert to the bus.h style, not used otherwise */
	if (flags & M_NOWAIT)
		flags = BUS_DMA_NOWAIT;

	p->size = size;
	if ((error = bus_dmamem_alloc(sc->sc_dmat, p->size, NBPG, 0, p->segs,
	    1, &p->nsegs, flags)) != 0) {
		printf("%s: unable to allocate dma, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		free(p, type);
		return NULL;
	}

	if ((error = bus_dmamem_map(sc->sc_dmat, p->segs, p->nsegs, p->size,
	    &p->addr, flags | BUS_DMA_COHERENT)) != 0) {
		printf("%s: unable to map dma, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		bus_dmamem_free(sc->sc_dmat, p->segs, p->nsegs);
		free(p, type);
		return NULL;
	}

	if ((error = bus_dmamap_create(sc->sc_dmat, p->size, 1,
	    p->size, 0, flags, &p->map)) != 0) {
		printf("%s: unable to create dma map, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		bus_dmamem_unmap(sc->sc_dmat, p->addr, size);
		bus_dmamem_free(sc->sc_dmat, p->segs, p->nsegs);
		free(p, type);
		return NULL;
	}

	if ((error = bus_dmamap_load(sc->sc_dmat, p->map, p->addr, p->size,
	    NULL, flags)) != 0) {
		printf("%s: unable to load dma map, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		bus_dmamap_destroy(sc->sc_dmat, p->map);
		bus_dmamem_unmap(sc->sc_dmat, p->addr, size);
		bus_dmamem_free(sc->sc_dmat, p->segs, p->nsegs);
		free(p, type);
		return NULL;
	}

	p->next = sc->sc_dmas;
	sc->sc_dmas = p;

	return p->addr;
@


1.18
log
@Dont reset the registers if the same speed is programmed. helps reduce
the possible race where the frequency fails to set when changing speeds.
hopefully this will workaround the problem reported on misc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.17 2005/10/07 03:47:31 drahn Exp $	*/
a1100 3
void keylargo_fcr_enable(int offset, u_int32_t bits);
void keylargo_fcr_disable(int offset, u_int32_t bits);

d1180 3
a1182 11
#define I2SClockOffset 0x3C
#define I2SClockEnable (0x00000001<<12)

	if (sc->sc_rate != rate) {
		keylargo_fcr_disable(I2SClockOffset, I2SClockEnable);
		delay(10000); /* XXX - should wait for clock to stop */
		DPRINTF(("I2SSetSerialFormatReg 0x%x -> 0x%x\n",
		    in32rb(sc->sc_reg + I2S_FORMAT), reg));
		out32rb(sc->sc_reg + I2S_FORMAT, reg);
		keylargo_fcr_enable(I2SClockOffset, I2SClockEnable);
	}
@


1.17
log
@Stop and restart the i2s clock when changing the snapper speed, otherwise
the new setting doesn't do anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.16 2005/05/26 22:51:50 drahn Exp $	*/
d1186 8
a1193 6
	keylargo_fcr_disable(I2SClockOffset, I2SClockEnable);
	delay(10000); /* XXX - should wait for clock to stop */
	DPRINTF(("I2SSetSerialFormatReg 0x%x -> 0x%x\n",
	    in32rb(sc->sc_reg + I2S_FORMAT), reg));
	out32rb(sc->sc_reg + I2S_FORMAT, reg);
	keylargo_fcr_enable(I2SClockOffset, I2SClockEnable);
@


1.16
log
@Dont hardcode the speed, allows mplayer to work.
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.15 2005/05/26 02:22:06 jason Exp $	*/
d1101 3
d1183 5
d1191 1
@


1.15
log
@on the iBook G3, there are too many devices with the same gpio name;
prefer the first found.  Now, FINALLY, I have my own music at the
hackathon.  ok drahn
[and yes, dale, I'm working on mplayer]
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.14 2005/05/23 18:49:31 jason Exp $	*/
d722 1
a722 1
	p->sample_rate = 44100;	/*XX wire rate down */
@


1.14
log
@pin the sample rate at 44.1k, PB's don't seem to get the 8k or 48k sample
rate notificiations
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.13 2005/05/22 21:10:27 jason Exp $	*/
d330 2
a331 1
	if (strcmp(compat, "snapper") != 0)
d1471 2
a1472 1
		if (strcmp(audio_gpio, "headphone-mute") == 0)
d1474 1
d1476 2
a1477 1
		if (strcmp(audio_gpio, "amp-mute") == 0)
d1479 1
d1481 2
a1482 1
		if (strcmp(audio_gpio, "headphone-detect") == 0) {
d1490 1
d1492 2
a1493 1
		if (strcmp(audio_gpio, "audio-hw-reset") == 0)
d1495 1
@


1.13
log
@define our own conversion function which does mono-to-stereo with
a sign change (no byte swapping, and correct endianess)
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.12 2005/05/22 20:32:36 jason Exp $	*/
d99 1
d581 2
a582 9
	u_char *q = p;

	p += cc;
	q += cc * 2;
	while ((cc -= 2) >= 0) {
		q -= 4;
		q[1] = q[3] = *--p;
		q[0] = q[2] = (*--p) ^ 80;
	}
d721 1
d726 1
d1182 2
@


1.12
log
@whoops, wrong conversion function
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.11 2005/05/22 19:12:41 jason Exp $	*/
d128 1
d577 14
d612 1
a612 1
	{ AUDIO_ENCODING_ULINEAR_BE, 16, 1, change_sign16_le_mts, 2 },
@


1.11
log
@more encodings
	slinear8: mono/stereo
	ulinear8: mono/stereo
	alaw: mono
	ulaw: mono
NOTE: still doesn't work on my machine, but hey, at least the encodings
are closer.
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.10 2005/05/22 18:28:20 jason Exp $	*/
d597 1
a597 1
	{ AUDIO_ENCODING_ULINEAR_BE, 16, 1, change_sign16_be_mts, 2 },
@


1.10
log
@fix names of ulinear, too
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.9 2005/05/22 18:08:13 jason Exp $	*/
d127 1
d576 42
d624 1
a657 3
		p->factor = 1;
		p->sw_code = 0;

d659 14
d674 3
a676 19
		case AUDIO_ENCODING_SLINEAR_LE:
			switch (p->precision) {
			case 16:
				switch (p->channels) {
				case 1:
					p->factor = 2;
					p->sw_code = swap_bytes_mono16_to_stereo16;
					break;
				case 2:
					p->factor = 1;
					p->sw_code = swap_bytes;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 8:
				switch (p->channels) {
				case 1:
d678 1
a678 5
					p->sw_code = linear8_to_linear16_be_mts;
					break;
				case 2:
					p->factor = 2;
					p->sw_code = linear8_to_linear16_be;
a679 2
				default:
					return (EINVAL);
d681 1
a681 9
				break;
			default:
				return (EINVAL);
			}
		case AUDIO_ENCODING_SLINEAR_BE:
			switch (p->precision) {
			case 16:
				switch (p->channels) {
				case 1:
d683 1
a683 1
					p->sw_code = mono16_to_stereo16;
a684 6
				case 2:
					p->factor = 1;
					p->sw_code = NULL;
					break;
				default:
					return (EINVAL);
d686 7
a692 4
				break;
			case 8:
				switch (p->channels) {
				case 1:
d694 1
a694 1
					p->sw_code = linear8_to_linear16_be_mts;
d696 2
a697 1
				case 2:
d699 1
a699 1
					p->sw_code = linear8_to_linear16_be;
a700 2
				default:
					return (EINVAL);
a701 24
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			if (p->channels == 2 && p->precision == 16) {
				p->sw_code = swap_bytes_change_sign16_be;
				break;
			}
			return EINVAL;

		case AUDIO_ENCODING_ULINEAR_BE:
			if (p->channels == 2 && p->precision == 16) {
				p->sw_code = change_sign16_be;
				break;
			}
			return EINVAL;

		case AUDIO_ENCODING_ULAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = mulaw_to_slinear16_be;
				break;
d703 2
a704 11
				break;		/* XXX */

			return EINVAL;

		case AUDIO_ENCODING_ALAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = alaw_to_slinear16_be;
				break;
			}
			return EINVAL;
d707 1
a707 1
			return EINVAL;
@


1.9
log
@add memory clobber to prevent reordering
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.8 2005/05/22 07:19:02 jason Exp $	*/
d504 1
a504 1
		strlcpy(ae->name, AudioEslinear_be, sizeof(ae->name));
d510 1
a510 1
		strlcpy(ae->name, AudioEslinear_le, sizeof(ae->name));
@


1.8
log
@ALAW is called AudioEalaw not AudioEmulaw
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.7 2004/12/25 23:02:24 miod Exp $	*/
d482 1
a482 1
	ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
d490 1
a490 1
		return 0;
d496 1
a496 1
		return 0;
d501 2
a502 1
		return 0;
d507 2
a508 1
		return 0;
d513 2
a514 1
		return 0;
d519 2
a520 1
		return 0;
d525 14
a538 1
		return 0;
d540 2
a541 1
		return EINVAL;
d543 1
d620 14
a633 2
			if (p->channels == 2 && p->precision == 16) {
				p->sw_code = swap_bytes;
d635 13
a647 4
			}
			if (p->channels == 1 && p->precision == 16) {
				p->factor = 2;
				p->sw_code = swap_bytes_mono16_to_stereo16;
d649 2
a651 1
			return EINVAL;
d653 28
a680 3
			if (p->channels == 1 && p->precision == 16) {
				p->factor = 2;
				p->sw_code = mono16_to_stereo16;
d682 2
d685 1
a685 5
			if (p->channels == 2 && p->precision == 16)
				break;

			return EINVAL;

d1297 1
a1297 1
	asm volatile ("eieio");
d1510 1
a1510 1
	asm volatile ("eieio");
@


1.7
log
@Use list and queue macros where applicable to make the code easier to read;
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.6 2004/12/25 19:01:01 miod Exp $	*/
d518 1
a518 1
		strlcpy(ae->name, AudioEmulaw, sizeof(ae->name));
@


1.6
log
@strncmp() the correct size when looking for ki2c companion.
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.5 2004/01/14 16:37:24 miod Exp $	*/
d386 1
a386 1
	for (dv = alldevs.tqh_first; dv; dv=dv->dv_list.tqe_next)
@


1.5
log
@Slightly better messages, fix a typo, and a few strlcpy() botches.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.4 2004/01/12 02:38:03 drahn Exp $	*/
d388 1
a388 1
		    strncmp(dv->dv_parent->dv_xname, "macobio", 4) == 0)
@


1.4
log
@Completely remove the device name from this print, not just the %s.
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.3 2004/01/12 02:19:13 drahn Exp $	*/
d395 1
a395 1
	/* XXX If i2c was failed to attach, what should we do? */
d827 1
a827 1
		    strlen(dip->un.s.member[0].label.name));
d830 1
a830 1
		    strlen(dip->un.s.member[1].label.name));
d841 1
a841 1
		strlen(dip->un.v.units.name));
d982 1
a982 1
	printf("snapper_trigger_input called\n");
d1357 1
a1357 1
	printf("tas3004_init: error\n");
@


1.3
log
@Better defaults on snapper, fixes xmms problem reported by joshua stein
just hours after the driver was committed.
@
text
@d1 1
a1 1
/*	$OpenBSD: snapper.c,v 1.2 2004/01/11 21:01:04 drahn Exp $	*/
d374 1
a374 1
	printf(": irq %d,%d,%d\n", sc->sc_dev.dv_xname, cirq, oirq, iirq);
@


1.2
log
@$OpenBSD$ tags
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a376 3
#if 0
	config_interrupts(self, snapper_defer);
#else
a377 1
#endif
d566 1
a566 1
	p = NULL;
d1046 6
@


1.1
log
@Audio support for some newer macppc machines, any 'snapper' based systems.
Driver ported from netbsd with bus_dma addition/vtophys deletion.
This driver does not work on the first generation 'Digital audio' systems
those were 'tumbler' nor the latest version. ok dhartmei@@
@
text
@d1 1
a2 1
/*	Id: snapper.c,v 1.11 2002/10/31 17:42:13 tsubai Exp	*/
@

