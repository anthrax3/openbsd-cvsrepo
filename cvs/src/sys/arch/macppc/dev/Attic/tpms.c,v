head	1.17;
access;
symbols
	OPENBSD_5_3:1.16.0.4
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.8
	OPENBSD_5_0:1.15.0.6
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.12.0.8
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.6
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.3.0.2
	OPENBSD_3_9_BASE:1.3;
locks; strict;
comment	@ * @;


1.17
date	2013.05.31.19.32.30;	author mpi;	state dead;
branches;
next	1.16;

1.16
date	2012.02.24.06.19.00;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.09.17.01.30;	author jasper;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.08.14.10.08;	author robert;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.11.16.30.31;	author mbalmer;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.05.23.21.06;	author mbalmer;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.05.08.52.20;	author mbalmer;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.30.23.17.43;	author maja;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.27.10.03.47;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2007.04.10.22.37.17;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.16.06.57.23;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.22.13.47.31;	author xsa;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.21.22.19.41;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.20.01.36.10;	author brad;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Rename tpms(4), the driver for Apple USB touchpads, to utpms(4) and move
it to dev/usb because it could be used on intel based mac laptops.

Discussed with jcs@@, ok deraadt@@
@
text
@/*	$OpenBSD: tpms.c,v 1.16 2012/02/24 06:19:00 guenther Exp $	*/

/*
 * Copyright (c) 2005, Johan Wallén
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *
 *   2. Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 *   3. The name of the copyright holder may not be used to endorse or
 *      promote products derived from this software without specific
 *      prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * The tpms driver provides support for the trackpad on new (post
 * February 2005) Apple PowerBooks and iBooks that are not standard
 * USB HID mice.
 */

/*
 * The protocol (that is, the interpretation of the data generated by
 * the trackpad) is taken from the Linux appletouch driver version
 * 0.08 by Johannes Berg, Stelian Pop and Frank Arnold.  The method
 * used to detect fingers on the trackpad is also taken from that
 * driver.
 */

/*
 * PROTOCOL:
 *
 * The driver transfers continuously 81 byte events.  The last byte is
 * 1 if the button is pressed, and is 0 otherwise. Of the remaining
 * bytes, 26 + 16 = 42 are sensors detecting pressure in the X or
 * horizontal, and Y or vertical directions, respectively.  On 12 and
 * 15 inch PowerBooks, only the 16 first sensors in the X-direction
 * are used. In the X-direction, the sensors correspond to byte
 * positions
 * 
 *   2, 7, 12, 17, 22, 27, 32, 37, 4, 9, 14, 19, 24, 29, 34, 39, 42,
 *   47, 52, 57, 62, 67, 72, 77, 44 and 49;
 * 
 * in the Y direction, the sensors correspond to byte positions
 *
 *   1, 6, 11, 16, 21, 26, 31, 36, 3, 8, 13, 18, 23, 28, 33 and 38.
 *
 * The change in the sensor values over time is more interesting than
 * their absolute values: if the pressure increases, we know that the
 * finger has just moved there.
 *
 * We keep track of the previous sample (of sensor values in the X and
 * Y directions) and the accumulated change for each sensor.  When we
 * receive a new sample, we add the difference of the new sensor value
 * and the old value to the accumulated change.  If the accumulator
 * becomes negative, we set it to zero.  The effect is that the
 * accumulator is large for sensors whose pressure has recently
 * increased.  If there is little change in pressure (or if the
 * pressure decreases), the accumulator drifts back to zero.
 *
 * Since there is some fluctuations, we ignore accumulator values
 * below a threshold.  The raw finger position is computed as a
 * weighted average of the other sensors (the weights are the
 * accumulated changes).
 *
 * For smoothing, we keep track of the previous raw finger position,
 * and the virtual position reported to wsmouse.  The new raw position
 * is computed as a weighted average of the old raw position and the
 * computed raw position.  Since this still generates some noise, we
 * compute a new virtual position as a weighted average of the previous
 * virtual position and the new raw position.  The weights are
 * controlled by the raw change and a noise parameter.  The position
 * is reported as a relative position.  
 */

/*
 * TODO:
 *
 * Add support for other drivers of the same type.
 *
 * Add support for tapping and two-finger scrolling?  The
 * implementation already detects two fingers, so this should be
 * relatively easy.
 *
 * Implement some of the mouse ioctls?
 *
 * Take care of the XXXs.
 *
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/errno.h>

#include <sys/ioctl.h>
#include <sys/systm.h>
#include <sys/tty.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/uhidev.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsmousevar.h>

/*
 * Magic numbers.
 */

/* The amount of data transferred by the USB device. */
#define TPMS_DATA_LEN 81

/* The maximum number of sensors. */
#define TPMS_X_SENSORS 26
#define TPMS_Y_SENSORS 16
#define TPMS_SENSORS (TPMS_X_SENSORS + TPMS_Y_SENSORS)

/* 
 * Parameters for supported devices.  For generality, these parameters
 * can be different for each device.  The meanings of the parameters
 * are as follows.
 *
 * type:      Type of the trackpad device, used for dmesg output, and
 *            to know some of the device parameters.
 *
 * noise:     Amount of noise in the computed position. This controls
 *            how large a change must be to get reported, and how 
 *            large enough changes are smoothed.  A good value can
 *            probably only be found experimentally, but something around
 *            16 seems suitable.
 *
 * product:   The product ID of the trackpad.
 *
 * 
 * threshold: Accumulated changes less than this are ignored.  A good 
 *            value could be determined experimentally, but 5 is a
 *            reasonable guess.
 *
 * vendor:    The vendor ID.  Currently USB_VENDOR_APPLE for all devices.
 *
 * x_factor:  Factor used in computations with X-coordinates.  If the
 *            x-resolution of the display is x, this should be 
 *            (x + 1) / (x_sensors - 1).  Other values work fine, but
 *            then the aspect ratio is not necessarily kept.
 *
 * x_sensors: The number of sensors in the X-direction.
 *
 * y_factor:  As x_factors, but for Y-coordinates.
 *
 * y_sensors: The number of sensors in the Y-direction.
 */

struct tpms_dev {
	int type;	   /* Type of the trackpad. */
#define FOUNTAIN	0x00
#define GEYSER1		0x01
#define GEYSER2		0x02
	int noise;	   /* Amount of noise in the computed position. */
	int threshold;	   /* Changes less than this are ignored. */
	int x_factor;	   /* Factor used in computation with X-coordinates. */
	int x_sensors;	   /* The number of X-sensors. */
	int y_factor;	   /* Factor used in computation with Y-coordinates. */
	int y_sensors;	   /* The number of Y-sensors. */
	uint16_t product;  /* Product ID. */
	uint16_t vendor;   /* The vendor ID. */
};

/* Devices supported by this driver. */
static struct tpms_dev tpms_devices[] =
{
#define POWERBOOK_TOUCHPAD(ttype, prod, x_fact, x_sens, y_fact)	\
       {								\
		.type = (ttype),						\
		.vendor = USB_VENDOR_APPLE,				\
		.product = (prod),					\
		.noise = 16,						\
		.threshold = 5,						\
		.x_factor = (x_fact),					\
		.x_sensors = (x_sens),					\
		.y_factor = (y_fact),					\
		.y_sensors = 16						\
       }
       /* 12 inch PowerBooks */
       POWERBOOK_TOUCHPAD(FOUNTAIN, 0x030a, 69, 16, 52), /* XXX Not tested. */
       /* 12 and 14 inch iBook G4 */
       POWERBOOK_TOUCHPAD(GEYSER1, 0x030b, 69, 16, 52),
       /* 15 inch PowerBooks */
       POWERBOOK_TOUCHPAD(FOUNTAIN, 0x020e, 85, 16, 57), /* XXX Not tested. */
       POWERBOOK_TOUCHPAD(FOUNTAIN, 0x020f, 85, 16, 57),
       POWERBOOK_TOUCHPAD(GEYSER2, 0x0214, 90, 15, 107),
       POWERBOOK_TOUCHPAD(GEYSER2, 0x0215, 90, 15, 107),
       POWERBOOK_TOUCHPAD(GEYSER2, 0x0216, 90, 15, 107),
       /* 17 inch PowerBooks */
       POWERBOOK_TOUCHPAD(FOUNTAIN, 0x020d, 71, 26, 68)  /* XXX Not tested. */
#undef POWERBOOK_TOUCHPAD
};

/* The number of supported devices. */
#define TPMS_NUM_DEVICES (sizeof(tpms_devices) / sizeof(tpms_devices[0]))

/*
 * Types and prototypes. 
 */

/* Device data. */
struct tpms_softc {
	struct uhidev sc_hdev;	      /* USB parent (got the struct device). */
	int sc_type;		      /* Type of the trackpad */
	int sc_datalen;
	int sc_acc[TPMS_SENSORS];     /* Accumulated sensor values. */
	unsigned char sc_prev[TPMS_SENSORS];   /* Previous sample. */
	unsigned char sc_sample[TPMS_SENSORS]; /* Current sample. */
	struct device *sc_wsmousedev; /* WSMouse device. */
	int sc_noise;		      /* Amount of noise. */
	int sc_threshold;	      /* Threshold value. */
	int sc_x;		      /* Virtual position in horizontal 
				       * direction (wsmouse position). */
	int sc_x_factor;	      /* X-coordinate factor. */
	int sc_x_raw;		      /* X-position of finger on trackpad. */
	int sc_x_sensors;	      /* Number of X-sensors. */
	int sc_y;		      /* Virtual position in vertical direction
				       * (wsmouse position). */
	int sc_y_factor;	      /* Y-coordinate factor. */
	int sc_y_raw;		      /* Y-position of finger on trackpad. */
	int sc_y_sensors;	      /* Number of Y-sensors. */
	uint32_t sc_buttons;	      /* Button state. */
	uint32_t sc_status;	      /* Status flags. */
#define TPMS_ENABLED 1		      /* Is the device enabled? */
#define TPMS_DYING 2		      /* Is the device dying? */
#define TPMS_VALID 4		      /* Is the previous sample valid? */
};

void tpms_intr(struct uhidev *, void *, unsigned int);
int tpms_enable(void *);
void tpms_disable(void *);
int tpms_ioctl(void *, unsigned long, caddr_t, int, struct proc *);
void reorder_sample(struct tpms_softc*, unsigned char *, unsigned char *);
int compute_delta(struct tpms_softc *, int *, int *, int *, uint32_t *);
int detect_pos(int *, int, int, int, int *, int *);
int smooth_pos(int, int, int);

/* Access methods for wsmouse. */
const struct wsmouse_accessops tpms_accessops = {
	tpms_enable,
	tpms_ioctl,
	tpms_disable,
};

/* This take cares also of the basic device registration. */
int tpms_match(struct device *, void *, void *); 
void tpms_attach(struct device *, struct device *, void *); 
int tpms_detach(struct device *, int); 
int tpms_activate(struct device *, int); 

struct cfdriver tpms_cd = { 
	NULL, "tpms", DV_DULL 
}; 

const struct cfattach tpms_ca = { 
	sizeof(struct tpms_softc), 
	tpms_match, 
	tpms_attach, 
	tpms_detach, 
	tpms_activate, 
};

/*
 * Basic driver. 
 */

/* Try to match the device at some uhidev. */

int
tpms_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
	usb_device_descriptor_t *udd;
	int i;
	uint16_t vendor, product;

	/* 
	 * We just check if the vendor and product IDs have the magic numbers
	 * we expect. 
	 */
	if ((udd = usbd_get_device_descriptor(uha->parent->sc_udev)) != NULL) {
		vendor = UGETW(udd->idVendor);
		product = UGETW(udd->idProduct);
		for (i = 0; i < TPMS_NUM_DEVICES; i++) {
			if (vendor == tpms_devices[i].vendor &&
			    product == tpms_devices[i].product)
				return (UMATCH_IFACECLASS);
		}
	}

	return (UMATCH_NONE);
}


/* Attach the device. */

void
tpms_attach(struct device *parent, struct device *self, void *aux)
{
	struct tpms_softc *sc = (struct tpms_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
	struct wsmousedev_attach_args a;
	struct tpms_dev *pd;
	usb_device_descriptor_t *udd;
	int i;
	uint16_t vendor, product;

	sc->sc_datalen = TPMS_DATA_LEN;

	/* Fill in device-specific parameters. */
	if ((udd = usbd_get_device_descriptor(uha->parent->sc_udev)) != NULL) {
		product = UGETW(udd->idProduct);
		vendor = UGETW(udd->idVendor);
		for (i = 0; i < TPMS_NUM_DEVICES; i++) {
			pd = &tpms_devices[i];
			if (product == pd->product && vendor == pd->vendor) {
				switch (pd->type) {
				case FOUNTAIN:
					printf(": Fountain");
					break;
				case GEYSER1:
					printf(": Geyser");
					break;
				case GEYSER2:
					sc->sc_type = GEYSER2;
					sc->sc_datalen = 64;
					sc->sc_y_sensors = 9;
					printf(": Geyser 2"); 
					break;
				}
				printf(" Trackpad\n");
				sc->sc_noise = pd->noise;
				sc->sc_threshold = pd->threshold;
				sc->sc_x_factor = pd->x_factor;
				sc->sc_x_sensors = pd->x_sensors;
				sc->sc_y_factor = pd->y_factor;
				sc->sc_y_sensors = pd->y_sensors;
				break;
			}
		}
	}
	if (sc->sc_x_sensors <= 0 || sc->sc_x_sensors > TPMS_X_SENSORS ||
	    sc->sc_y_sensors <= 0 || sc->sc_y_sensors > TPMS_Y_SENSORS) {
		printf(": unexpected sensors configuration (%d:%d)\n",
		    sc->sc_x_sensors, sc->sc_y_sensors);
		return;
	}

	sc->sc_hdev.sc_intr = tpms_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_report_id = uha->reportid;

	sc->sc_status = 0;

	a.accessops = &tpms_accessops;
	a.accesscookie = sc;
	sc->sc_wsmousedev = config_found(self, &a, wsmousedevprint);
}

/* Detach the device. */

int
tpms_detach(struct device *self, int flags)
{
	struct tpms_softc *sc = (struct tpms_softc *)self;
	int ret;

	/* The wsmouse driver does all the work. */
	ret = 0;
	if (sc->sc_wsmousedev != NULL)
		ret = config_detach(sc->sc_wsmousedev, flags);

	return (ret);
}

/* Activate the device. */

int
tpms_activate(struct device *self, int act)
{
	struct tpms_softc *sc = (struct tpms_softc *)self;
	int ret;

	if (act == DVACT_DEACTIVATE) {
		ret = 0;
		if (sc->sc_wsmousedev != NULL)
			ret = config_deactivate(sc->sc_wsmousedev);
		sc->sc_status |= TPMS_DYING;
		return (ret);
	}
	return (EOPNOTSUPP);
}


/* Enable the device. */

int
tpms_enable(void *v)
{
	struct tpms_softc *sc = v;

	/* Check that we are not detaching or already enabled. */
	if (sc->sc_status & TPMS_DYING)
		return (EIO);
	if (sc->sc_status & TPMS_ENABLED)
		return (EBUSY);

	sc->sc_status |= TPMS_ENABLED;
	sc->sc_status &= ~TPMS_VALID;
	sc->sc_buttons = 0;
	bzero(sc->sc_sample, sizeof(sc->sc_sample));

	return (uhidev_open(&sc->sc_hdev));
}

/* Disable the device. */

void
tpms_disable(void *v)
{
	struct tpms_softc *sc = v;

	if (!(sc->sc_status & TPMS_ENABLED))
		return;

	sc->sc_status &= ~TPMS_ENABLED;
	uhidev_close(&sc->sc_hdev);
}

int
tpms_ioctl(void *v, unsigned long cmd, caddr_t data, int flag, struct proc *p)
{
	switch (cmd) {
	case WSMOUSEIO_GTYPE:
		*(u_int *)data = WSMOUSE_TYPE_TPANEL;
		return (0);
	}

	return (-1);
}

/*
 * Interrupts & pointer movement. 
 */

/* Handle interrupts. */

void
tpms_intr(struct uhidev *addr, void *ibuf, unsigned int len)
{
	struct tpms_softc *sc = (struct tpms_softc *)addr;
	unsigned char *data;
	int dx, dy, dz, i, s;
	uint32_t buttons;

	/* Ignore incomplete data packets. */
	if (len != sc->sc_datalen)
		return;
	data = ibuf;

	/* The last byte is 1 if the button is pressed and 0 otherwise. */
	buttons = !!data[sc->sc_datalen - 1];

	/* Everything below assumes that the sample is reordered. */
	reorder_sample(sc, sc->sc_sample, data);

	/* Is this the first sample? */
	if (!(sc->sc_status & TPMS_VALID)) {
		sc->sc_status |= TPMS_VALID;
		sc->sc_x = sc->sc_y = -1;
		sc->sc_x_raw = sc->sc_y_raw = -1;
		memcpy(sc->sc_prev, sc->sc_sample, sizeof(sc->sc_prev));
		bzero(sc->sc_acc, sizeof(sc->sc_acc));
		return;
	}
	/* Accumulate the sensor change while keeping it nonnegative. */
	for (i = 0; i < TPMS_SENSORS; i++) {
		sc->sc_acc[i] +=
			(signed char)(sc->sc_sample[i] - sc->sc_prev[i]);

		if (sc->sc_acc[i] < 0)
			sc->sc_acc[i] = 0;
	}
	memcpy(sc->sc_prev, sc->sc_sample, sizeof(sc->sc_prev));

	/* Compute change. */
	dx = dy = dz = 0;
	if (!compute_delta(sc, &dx, &dy, &dz, &buttons))
		return;

	/* Report to wsmouse. */
	if ((dx != 0 || dy != 0 || dz != 0 || buttons != sc->sc_buttons) &&
	    sc->sc_wsmousedev != NULL) {
		s = spltty();
		wsmouse_input(sc->sc_wsmousedev, buttons, dx, -dy, dz, 0,
		    WSMOUSE_INPUT_DELTA);
		splx(s);
	}
	sc->sc_buttons = buttons;
}

/* 
 * Reorder the sensor values so that all the X-sensors are before the
 * Y-sensors in the natural order. Note that this might have to be
 * rewritten if TPMS_X_SENSORS or TPMS_Y_SENSORS change. 
 */

void 
reorder_sample(struct tpms_softc *sc, unsigned char *to, unsigned char *from)
{
	int i;

	if (sc->sc_type == GEYSER2) {
		int j;

		bzero(to, TPMS_SENSORS);
		for (i = 0, j = 19; i < 20; i += 2, j += 3) {
			to[i] = from[j];
			to[i + 1] = from[j + 1];
		}
		for (i = 0, j = 1; i < 9; i += 2, j += 3) {
			to[TPMS_X_SENSORS + i] = from[j];
			to[TPMS_X_SENSORS + i + 1] = from[j + 1];
		}
	} else {
		for (i = 0; i < 8; i++) {
			/* X-sensors. */
			to[i] = from[5 * i + 2];
			to[i + 8] = from[5 * i + 4];
			to[i + 16] = from[5 * i + 42];
#if 0
			/* 
			 * XXX This seems to introduce random ventical jumps, so
			 * we ignore these sensors until we figure out their meaning.
			 */
			if (i < 2)
				to[i + 24] = from[5 * i + 44];
#endif /* 0 */
			/* Y-sensors. */
			to[i + 26] = from[5 * i + 1];
			to[i + 34] = from[5 * i + 3];
		}
	}
}

/*
 * Compute the change in x, y and z direction, update the button state
 * (to simulate more than one button, scrolling etc.), and update the
 * history. Note that dx, dy, dz and buttons are modified only if
 * corresponding pressure is detected and should thus be initialised
 * before the call.  Return 0 on error.
 */

/* XXX Could we report something useful in dz? */

int
compute_delta(struct tpms_softc *sc, int *dx, int *dy, int *dz, 
	      uint32_t * buttons)
{
	int x_det, y_det, x_raw, y_raw, x_fingers, y_fingers, fingers, x, y;

	x_det = detect_pos(sc->sc_acc, sc->sc_x_sensors, sc->sc_threshold,
			   sc->sc_x_factor, &x_raw, &x_fingers);
	y_det = detect_pos(sc->sc_acc + TPMS_X_SENSORS, sc->sc_y_sensors,
			   sc->sc_threshold, sc->sc_y_factor,
			   &y_raw, &y_fingers);
	fingers = max(x_fingers, y_fingers);

	/* Check the number of fingers and if we have detected a position. */
	if (x_det == 0 && y_det == 0) {
		/* No position detected, resetting. */
		bzero(sc->sc_acc, sizeof(sc->sc_acc));
		sc->sc_x_raw = sc->sc_y_raw = sc->sc_x = sc->sc_y = -1;
	} else if (x_det > 0 && y_det > 0) {
		switch (fingers) {
		case 1:
			/* Smooth position. */
			if (sc->sc_x_raw >= 0) {
				sc->sc_x_raw = (3 * sc->sc_x_raw + x_raw) / 4;
				sc->sc_y_raw = (3 * sc->sc_y_raw + y_raw) / 4;
				/* 
				 * Compute virtual position and change if we
				 * already have a decent position. 
				 */
				if (sc->sc_x >= 0) {
					x = smooth_pos(sc->sc_x, sc->sc_x_raw,
						       sc->sc_noise);
					y = smooth_pos(sc->sc_y, sc->sc_y_raw,
						       sc->sc_noise);
					*dx = x - sc->sc_x;
					*dy = y - sc->sc_y;
					sc->sc_x = x;
					sc->sc_y = y;
				} else {
					/* Initialise virtual position. */
					sc->sc_x = sc->sc_x_raw;
					sc->sc_y = sc->sc_y_raw;
				}
			} else {
				/* Initialise raw position. */
				sc->sc_x_raw = x_raw;
				sc->sc_y_raw = y_raw;
			}
			break;
		case 2:
			if (*buttons == 1)
				*buttons = 4;
			break;
		case 3:
			if (*buttons == 1)
				*buttons = 2;
			break;
		}
	}
	return (1);
}

/*
 * Compute the new smoothed position from the previous smoothed position
 * and the raw position.
 */

int
smooth_pos(int pos_old, int pos_raw, int noise)
{
	int ad, delta;

	delta = pos_raw - pos_old;
	ad = abs(delta);

	/* Too small changes are ignored. */
	if (ad < noise / 2)
		delta = 0;
	/* A bit larger changes are smoothed. */
	else if (ad < noise)
		delta /= 4;
	else if (ad < 2 * noise)
		delta /= 2;

	return (pos_old + delta);
}

/*
 * Detect the position of the finger.  Returns the total pressure.
 * The position is returned in pos_ret and the number of fingers
 * is returned in fingers_ret.  The position returned in pos_ret
 * is in [0, (n_sensors - 1) * factor - 1].
 */

int
detect_pos(int *sensors, int n_sensors, int threshold, int fact,
	   int *pos_ret, int *fingers_ret)
{
	int i, w, s;

	/*
	 * Compute the number of fingers, total pressure, and weighted
	 * position of the fingers. 
	 */
	*fingers_ret = 0;
	w = s = 0;
	for (i = 0; i < n_sensors; i++) {
		if (sensors[i] >= threshold) {
			if (i == 0 || sensors[i - 1] < threshold)
				*fingers_ret += 1;
			s += sensors[i];
			w += sensors[i] * i;
		}
	}

	if (s > 0)
		*pos_ret = w * fact / s;

	return (s);
}
@


1.16
log
@Correct the spelling of "transferred" and "transferring"

from Tobias Ulmer (tobiasu at tmux.org); ok jmc@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tpms.c,v 1.15 2010/04/09 17:01:30 jasper Exp $	*/
@


1.15
log
@- don't use memset() where we should use bzero()
* no binary change

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tpms.c,v 1.14 2009/10/13 19:33:16 pirofti Exp $	*/
d131 1
a131 1
/* The amount of data transfered by the USB device. */
@


1.14
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tpms.c,v 1.13 2009/03/08 14:10:08 robert Exp $	*/
d438 1
a438 1
	memset(sc->sc_sample, 0, sizeof(sc->sc_sample));
d500 1
a500 1
		memset(sc->sc_acc, 0, sizeof(sc->sc_acc));
d543 1
a543 1
		memset(to, 0, TPMS_SENSORS);
d599 1
a599 1
		memset(sc->sc_acc, 0, sizeof(sc->sc_acc));
@


1.13
log
@Add support for Geyser2 devices from NetBSD and fix some Geyser1 devices that
can be found in iBook G4 12".
Remove references for LCD panel sizes because the same device can be found
on different sized laptops and it has nothing to do with the trackpad.
Introduce a type variable that stores the device type: FOUNTAIN, GEYSER1 or
GEYSER2. This value helps deciding some of the device parameters and it gets
printed in the dmesg instead of the panel size.

Introduce "mouse button emulation" on multi-touch trackpads just like in
macos, so it's not needed to bind mouse buttons to the keyboard anymore:
Tap two fingers + mouse button = 3rd mouse button = right click
Tap three fingers + mouse button = 2nd mouse button = middle click

Discussed with and ok: miod@@ and maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tpms.c,v 1.12 2007/06/14 10:11:16 mbalmer Exp $	*/
d274 1
a274 1
int tpms_activate(struct device *, enum devact); 
d406 1
a406 1
tpms_activate(struct device *self, enum devact act)
@


1.12
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: tpms.c,v 1.11 2007/06/12 16:26:37 mbalmer Exp $	*/
d38 1
a38 1
 * February 2005) Apple PowerBooks (and iBooks?) that are not standard
a127 29
 * Debugging output.
 */

/* XXX Should be redone, and its use should be added back. */

#ifdef TPMS_DEBUG

/*
 * Print the error message (preceded by the driver and function)
 * specified by the string literal fmt (followed by newline) if
 * tpmsdebug is greater than n. The macro may only be used in the
 * scope of sc, which must be castable to struct device *. There must
 * be at least one vararg. Do not define TPMS_DEBUG on non-C99
 * compilers.
 */

#define DPRINTFN(n, fmt, ...)						      \
do {									      \
	if (tpmsdebug > (n))						      \
		logprintf("%s: %s: " fmt "\n",				      \
			  ((struct device *) sc)->dv_xname,		      \
			  __func__, __VA_ARGS__);			      \
} while ( /* CONSTCOND */ 0)

int tpmsdebug = 0;

#endif /* TPMS_DEBUG */

/*
d144 2
a145 1
 * desc:      A printable description used for dmesg output.
d175 4
a178 1
	const char *descr; /* Description of the driver (for dmesg). */
d192 1
a192 1
#define POWERBOOK_TOUCHPAD(inches, prod, x_fact, x_sens, y_fact)	\
d194 1
a194 1
		.descr = #inches " inch PowerBook Trackpad",		\
d205 3
a207 3
       POWERBOOK_TOUCHPAD(12, 0x030a, 69, 16, 52), /* XXX Not tested. */
       /* 14 inch iBook G4 */
       POWERBOOK_TOUCHPAD(14, 0x030b, 69, 16, 52),
d209 5
a213 2
       POWERBOOK_TOUCHPAD(15, 0x020e, 85, 16, 57), /* XXX Not tested. */
       POWERBOOK_TOUCHPAD(15, 0x020f, 85, 16, 57),
d215 1
a215 1
       POWERBOOK_TOUCHPAD(17, 0x020d, 71, 26, 68)  /* XXX Not tested. */
d229 2
d232 2
a233 2
	signed char sc_prev[TPMS_SENSORS];   /* Previous sample. */
	signed char sc_sample[TPMS_SENSORS]; /* Current sample. */
d258 1
a258 1
void reorder_sample(signed char *, signed char *);
d335 2
d344 15
a358 1
				printf(": %s\n", pd->descr);
d479 1
a479 1
	signed char *data;
d484 1
a484 1
	if (len != TPMS_DATA_LEN)
d489 1
a489 1
	buttons = !!data[TPMS_DATA_LEN - 1];
d492 1
a492 1
	reorder_sample(sc->sc_sample, data);
d505 3
a507 1
		sc->sc_acc[i] += sc->sc_sample[i] - sc->sc_prev[i];
d536 1
a536 1
reorder_sample(signed char *to, signed char *from)
d540 18
a557 5
	for (i = 0; i < 8; i++) {
		/* X-sensors. */
		to[i] = from[5 * i + 2];
		to[i + 8] = from[5 * i + 4];
		to[i + 16] = from[5 * i + 42];
d559 6
a564 6
		/* 
		 * XXX This seems to introduce random vertical jumps, so
		 * we ignore these sensors until we figure out their meaning.
		 */
		if (i < 2)
			to[i + 24] = from[5 * i + 44];
d566 4
a569 3
		/* Y-sensors. */
		to[i + 26] = from[5 * i + 1];
		to[i + 34] = from[5 * i + 3];
d597 1
a597 6
	if (fingers > 1) {
		/* More than one finger detected, resetting. */
		memset(sc->sc_acc, 0, sizeof(sc->sc_acc));
		sc->sc_x_raw = sc->sc_y_raw = sc->sc_x = sc->sc_y = -1;
		return 0;
	} else if (x_det == 0 && y_det == 0) {
d602 24
a625 17
		/* Smooth position. */
		if (sc->sc_x_raw >= 0) {
			sc->sc_x_raw = (3 * sc->sc_x_raw + x_raw) / 4;
			sc->sc_y_raw = (3 * sc->sc_y_raw + y_raw) / 4;
			/* 
			 * Compute virtual position and change if we already
			 * have a decent position. 
			 */
			if (sc->sc_x >= 0) {
				x = smooth_pos(sc->sc_x, sc->sc_x_raw,
					       sc->sc_noise);
				y = smooth_pos(sc->sc_y, sc->sc_y_raw,
					       sc->sc_noise);
				*dx = x - sc->sc_x;
				*dy = y - sc->sc_y;
				sc->sc_x = x;
				sc->sc_y = y;
d627 3
a629 3
				/* Initialise virtual position. */
				sc->sc_x = sc->sc_x_raw;
				sc->sc_y = sc->sc_y_raw;
d631 9
a639 4
		} else {
			/* Initialise raw position. */
			sc->sc_x_raw = x_raw;
			sc->sc_y_raw = y_raw;
@


1.11
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: tpms.c,v 1.10 2007/06/11 16:30:31 mbalmer Exp $	*/
d291 16
a306 1
USB_DECLARE_DRIVER(tpms);
@


1.10
log
@Remove the usb_proc_ptr type definition, which was really a 'struct proc *'
only.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: tpms.c,v 1.9 2007/06/05 23:21:06 mbalmer Exp $	*/
d395 1
a395 1
tpms_activate(device_ptr_t self, enum devact act)
@


1.9
log
@Remove the comment "Static function protoypes".  Static is gone in USB.
no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tpms.c,v 1.8 2007/06/05 08:52:20 mbalmer Exp $	*/
d277 1
a277 1
int tpms_ioctl(void *, unsigned long, caddr_t, int, usb_proc_ptr);
d447 1
a447 1
tpms_ioctl(void *v, unsigned long cmd, caddr_t data, int flag, usb_proc_ptr p)
@


1.8
log
@Remove the "Static" function declaration.  It is defined to be
empty and confuses the source code reader.  As discussed with dlg and jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: tpms.c,v 1.7 2007/05/30 23:17:43 maja Exp $	*/
a273 1
/* Static function prototypes. */
@


1.7
log
@Add support for iBook G4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: tpms.c,v 1.6 2007/05/27 10:03:47 mglocker Exp $	*/
d275 8
a282 8
Static void tpms_intr(struct uhidev *, void *, unsigned int);
Static int tpms_enable(void *);
Static void tpms_disable(void *);
Static int tpms_ioctl(void *, unsigned long, caddr_t, int, usb_proc_ptr);
Static void reorder_sample(signed char *, signed char *);
Static int compute_delta(struct tpms_softc *, int *, int *, int *, uint32_t *);
Static int detect_pos(int *, int, int, int, int *, int *);
Static int smooth_pos(int, int, int);
d395 1
a395 1
Static int
d414 1
a414 1
Static int
d435 1
a435 1
Static void
d447 1
a447 1
Static int
d465 1
a465 1
Static void
d523 1
a523 1
Static void 
d557 1
a557 1
Static int
d617 1
a617 1
Static int
d644 1
a644 1
Static int
@


1.6
log
@USB cleanup leftover.  Diff from jsg@@ tested by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: tpms.c,v 1.5 2007/04/10 22:37:17 miod Exp $	*/
d231 2
@


1.5
log
@Add support for a fourth axis on wsmouse devices, e.g. on the Apple Might
Mouse.  Currently limited to USB mice.

Adapted from a diff from Gareth <garf@@loveandnature.co.za> on tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tpms.c,v 1.4 2006/03/16 06:57:23 miod Exp $	*/
d298 2
a299 1
USB_MATCH(tpms)
d301 1
a301 1
	USB_MATCH_START(tpms, uaa);
d327 2
a328 1
USB_ATTACH(tpms)
d330 2
a331 1
	USB_ATTACH_START(tpms, sc, uaa);
d361 1
a361 1
		USB_ATTACH_ERROR_RETURN;
a372 2

	USB_ATTACH_SUCCESS_RETURN;
d377 2
a378 1
USB_DETACH(tpms)
d380 1
a380 1
	USB_DETACH_START(tpms, sc);
@


1.4
log
@ventical -> vertical
@
text
@d1 1
a1 1
/*	$OpenBSD: tpms.c,v 1.3 2005/12/22 13:47:31 xsa Exp $	*/
d506 1
a506 1
		wsmouse_input(sc->sc_wsmousedev, buttons, dx, -dy, dz,
@


1.3
log
@- attach and configure correctly
- pretty dmesg output
input+OK miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tpms.c,v 1.2 2005/12/21 22:19:41 miod Exp $	*/
d531 1
a531 1
		 * XXX This seems to introduce random ventical jumps, so
@


1.2
log
@Remove KASSERT in attach, return an error instead; while there, implement
tpms_ioctl() correctly, fix typos, repair a minor dmesg glitch.

Untested (donations welcome (-: ), yet ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tpms.c,v 1.1 2005/12/20 01:36:10 brad Exp $	*/
d354 2
a355 2
	if (sc->sc_x_sensors <= 0 || sc->sc_x_sensors >= TPMS_X_SENSORS ||
	    sc->sc_y_sensors <= 0 || sc->sc_y_sensors >= TPMS_Y_SENSORS) {
a365 2

	printf("\n");
@


1.1
log
@Add a Apple touchpad driver for newer PowerBook's and iBook's.

From Johan Wallén on NetBSD's macppc list.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a110 2
#include <sys/cdefs.h>

d254 1
a254 1
	int sc_theshold;	      /* Threshold value. */
a335 4
	sc->sc_hdev.sc_intr = tpms_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_report_id = uha->reportid;

d345 1
a345 1
				sc->sc_theshold = pd->threshold;
d354 10
a363 2
	KASSERT(0 <= sc->sc_x_sensors && sc->sc_x_sensors <= TPMS_X_SENSORS);
	KASSERT(0 <= sc->sc_y_sensors && sc->sc_y_sensors <= TPMS_Y_SENSORS);
d367 2
a370 1

a444 2
/* XXX ioctl not implemented. */

d448 7
a454 1
	return (ENOTTY);
d561 1
a561 1
	x_det = detect_pos(sc->sc_acc, sc->sc_x_sensors, sc->sc_theshold,
d564 1
a564 1
			   sc->sc_theshold, sc->sc_y_factor,
@

