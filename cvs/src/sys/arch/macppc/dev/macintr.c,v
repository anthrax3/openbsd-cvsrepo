head	1.54;
access;
symbols
	OPENBSD_6_2:1.54.0.4
	OPENBSD_6_2_BASE:1.54
	OPENBSD_6_1:1.53.0.8
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.53.0.4
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.53.0.2
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.52.0.4
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.44.0.12
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.44.0.8
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.44.0.6
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.4
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.2
	OPENBSD_5_0:1.42.0.2
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.41.0.2
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.39.0.4
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.37.0.4
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.33.0.6
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.4
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.31.0.2
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.27.0.4
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.2
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.15
	UBC:1.6.0.2
	UBC_BASE:1.6
	SMP:1.5.0.4
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.54
date	2017.04.30.16.45.45;	author mpi;	state Exp;
branches;
next	1.53;
commitid	2Gtqjzrin9LL2yHk;

1.53
date	2015.09.08.08.29.35;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	Qv4sSaeodDiHWA1c;

1.52
date	2015.06.24.11.58.06;	author mpi;	state Exp;
branches;
next	1.51;
commitid	ydQ89S8LGKdOdYT1;

1.51
date	2015.04.02.11.12.24;	author mpi;	state Exp;
branches;
next	1.50;
commitid	H6AjB4yqSabDCpNM;

1.50
date	2015.01.04.13.01.42;	author mpi;	state Exp;
branches;
next	1.49;
commitid	NhpbICTczAMSUxav;

1.49
date	2014.09.06.10.45.29;	author mpi;	state Exp;
branches;
next	1.48;
commitid	psPuYzRRUiGpyp76;

1.48
date	2014.08.30.09.42.20;	author mpi;	state Exp;
branches;
next	1.47;
commitid	Dshi7LrssPWioCfN;

1.47
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.46;
commitid	uKVPYMN2MLxdZxzH;

1.46
date	2014.04.01.20.27.14;	author mpi;	state Exp;
branches;
next	1.45;

1.45
date	2014.03.31.18.58.41;	author mpi;	state Exp;
branches;
next	1.44;

1.44
date	2011.09.16.17.56.52;	author drahn;	state Exp;
branches;
next	1.43;

1.43
date	2011.08.29.20.21.44;	author drahn;	state Exp;
branches;
next	1.42;

1.42
date	2011.04.15.20.52.55;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2011.01.08.18.10.22;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2010.09.20.06.33.47;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	2009.10.01.20.19.18;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2009.08.22.02.54.50;	author mk;	state Exp;
branches;
next	1.37;

1.37
date	2009.06.09.01.12.38;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2009.06.02.21.38.09;	author drahn;	state Exp;
branches;
next	1.35;

1.35
date	2008.11.21.17.35.52;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2008.09.18.03.56.25;	author drahn;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.29.18.10.42;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2007.03.20.20.59.53;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2007.03.01.15.00.57;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.12.02.49.50;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.16.04.30.43;	author drahn;	state Exp;
branches;
next	1.28;

1.28
date	2005.09.30.19.51.52;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.11.13.35.47;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.16.14.37.06;	author aaron;	state Exp;
branches;
next	1.25;

1.25
date	2004.10.01.20.28.42;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2004.06.28.02.49.43;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.28.02.49.10;	author aaron;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.20.22.40.26;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.19.21.57.35;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.16.03.54.48;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.16.03.31.25;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.02.21.30.13;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.23.27.49;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.12.22.40.59;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.15.02.02.43;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.08.20.33.43;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.02.17.37.41;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.02.17.17.37;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.26.15.22.52;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.21.05.11.29;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.17.16.17.23;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.10.03.14.07.05;	author drahn;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.09.28.04.13.12;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.11.06.47.00;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.12.57.24;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.50.00;	author drahn;	state Exp;
branches;
next	;

1.5.4.1
date	2001.10.31.03.01.15;	author nate;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2002.03.06.01.06.11;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2003.06.07.11.13.14;	author ho;	state Exp;
branches;
next	1.5.4.7;

1.5.4.7
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.01.31.22.55.14;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.06.11.03.36.33;	author art;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@/*	$OpenBSD: macintr.c,v 1.53 2015/09/08 08:29:35 deraadt Exp $	*/

/*-
 * Copyright (c) 2008 Dale Rahn <drahn@@openbsd.org>
 * Copyright (c) 1995 Per Fogelstrom
 * Copyright (c) 1993, 1994 Charles M. Hannum.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz and Don Ahn.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)isa.c	7.2 (Berkeley) 5/12/91
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>
#include <ddb/db_var.h>

#include <machine/atomic.h>
#include <machine/autoconf.h>
#include <machine/intr.h>
#include <machine/psl.h>
#include <machine/pio.h>

#include <dev/ofw/openfirm.h>

#define ICU_LEN 64
#define LEGAL_IRQ(x) ((x >= 0) && (x < ICU_LEN))

int macintr_ienable_l[IPL_NUM], macintr_ienable_h[IPL_NUM];
int macintr_pri_share[IPL_NUM];

struct intrq macintr_handler[ICU_LEN];

void macintr_calc_mask(void);
void macintr_eoi(int irq);
int macintr_read_irq(void);

extern u_int32_t *heathrow_FCR;

#define INT_STATE_REG0  (interrupt_reg + 0x20)
#define INT_ENABLE_REG0 (interrupt_reg + 0x24)
#define INT_CLEAR_REG0  (interrupt_reg + 0x28)
#define INT_LEVEL_REG0  (interrupt_reg + 0x2c)
#define INT_STATE_REG1  (INT_STATE_REG0  - 0x10)
#define INT_ENABLE_REG1 (INT_ENABLE_REG0 - 0x10)
#define INT_CLEAR_REG1  (INT_CLEAR_REG0  - 0x10)
#define INT_LEVEL_REG1  (INT_LEVEL_REG0  - 0x10)

struct macintr_softc {
	struct device sc_dev;
};

int	macintr_match(struct device *parent, void *cf, void *aux);
void	macintr_attach(struct device *, struct device *, void *);
void	mac_ext_intr(void);
void	macintr_collect_preconf_intr(void);
void	macintr_setipl(int ipl);

struct cfattach macintr_ca = {
	sizeof(struct macintr_softc),
	macintr_match,
	macintr_attach
};

struct cfdriver macintr_cd = {
	NULL, "macintr", DV_DULL
};

int
macintr_match(struct device *parent, void *cf, void *aux)
{
	struct confargs *ca = aux;
	char type[40];

	/*
	 * Match entry according to "present" openfirmware entry.
	 */
	if (strcmp(ca->ca_name, "interrupt-controller") == 0 ) {
		OF_getprop(ca->ca_node, "device_type", type, sizeof(type));
		if (strcmp(type,  "interrupt-controller") == 0)
			return 1;
	}

	/*
	 * Check name for legacy interrupt controller, this is
	 * faked to allow old firmware which does not have an entry
	 * to attach to this device.
	 */
	if (strcmp(ca->ca_name, "legacy-interrupt-controller") == 0 )
		return 1;
	return 0;
}

u_int8_t *interrupt_reg;
typedef void  (void_f) (void);
int macintr_prog_button (void *arg);

intr_establish_t macintr_establish;
intr_disestablish_t macintr_disestablish;

ppc_splraise_t macintr_splraise;
ppc_spllower_t macintr_spllower;
ppc_splx_t macintr_splx;


int
macintr_splraise(int newcpl)
{
	struct cpu_info *ci = curcpu();
	int ocpl = ci->ci_cpl;
	int s;

	newcpl = macintr_pri_share[newcpl];
	if (ocpl > newcpl)
		newcpl = ocpl;

	s = ppc_intr_disable();
	macintr_setipl(newcpl);
	ppc_intr_enable(s);

	return ocpl;
}

int
macintr_spllower(int newcpl)
{
	struct cpu_info *ci = curcpu();
	int ocpl = ci->ci_cpl;

	macintr_splx(newcpl);

	return ocpl;
}

void
macintr_splx(int newcpl)
{
	struct cpu_info *ci = curcpu();
	int intr, s;

	intr = ppc_intr_disable();
	macintr_setipl(newcpl);
	if ((newcpl < IPL_SOFTTTY && ci->ci_ipending & ppc_smask[newcpl])) {
		s = splsofttty();
		dosoftint(newcpl);
		macintr_setipl(s); /* no-overhead splx */
	}
	ppc_intr_enable(intr);
}

void
macintr_attach(struct device *parent, struct device *self, void *aux)
{
	struct cpu_info *ci = curcpu();
	struct confargs *ca = aux;
	extern intr_establish_t *intr_establish_func;
	extern intr_disestablish_t *intr_disestablish_func;
	struct intrq *iq;
	int i;

	interrupt_reg = (void *)mapiodev(ca->ca_baseaddr,0x100); /* XXX */

	for (i = 0; i < ICU_LEN; i++) {
		iq = &macintr_handler[i];
		TAILQ_INIT(&iq->iq_list);
	}
	ppc_smask_init();

	install_extint(mac_ext_intr);
	intr_establish_func  = macintr_establish;
	intr_disestablish_func  = macintr_disestablish;

	ppc_intr_func.raise = macintr_splraise;
	ppc_intr_func.lower = macintr_spllower;
	ppc_intr_func.x = macintr_splx;

	ci->ci_flags = 0;

	macintr_collect_preconf_intr();

	mac_intr_establish(parent, 0x14, IST_LEVEL, IPL_HIGH,
	    macintr_prog_button, (void *)0x14, "progbutton");

	ppc_intr_enable(1);
	printf("\n");
}

void
macintr_collect_preconf_intr()
{
	int i;
	for (i = 0; i < ppc_configed_intr_cnt; i++) {
#ifdef DEBUG
		printf("\n\t%s irq %d level %d fun %p arg %p",
			ppc_configed_intr[i].ih_what,
			ppc_configed_intr[i].ih_irq,
			ppc_configed_intr[i].ih_level,
			ppc_configed_intr[i].ih_fun,
			ppc_configed_intr[i].ih_arg
			);
#endif
		macintr_establish(NULL,
			ppc_configed_intr[i].ih_irq,
			IST_LEVEL,
			ppc_configed_intr[i].ih_level,
			ppc_configed_intr[i].ih_fun,
			ppc_configed_intr[i].ih_arg,
			ppc_configed_intr[i].ih_what);
	}
}


/*
 * programmer_button function to fix args to Debugger.
 * deal with any enables/disables, if necessary.
 */
int
macintr_prog_button (void *arg)
{
#ifdef DDB
	if (db_console)
		db_enter();
#else
	printf("programmer button pressed, debugger not available\n");
#endif
	return 1;
}

/* Must be called with interrupt disable. */
void
macintr_setipl(int ipl)
{
	struct cpu_info *ci = curcpu();

	ci->ci_cpl = ipl;
	if (heathrow_FCR)
		out32rb(INT_ENABLE_REG1,
		    macintr_ienable_h[macintr_pri_share[ipl]]);

	out32rb(INT_ENABLE_REG0, macintr_ienable_l[macintr_pri_share[ipl]]);
}

/*
 * Register an interrupt handler.
 */
void *
macintr_establish(void * lcv, int irq, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, const char *name)
{
	struct cpu_info *ci = curcpu();
	struct intrq *iq;
	struct intrhand *ih;
	int s, flags;

	if (!LEGAL_IRQ(irq) || type == IST_NONE) {
		printf("%s: bogus irq %d or type %d", __func__, irq, type);
		return (NULL);
	}

	/* no point in sleeping unless someone can free memory. */
	ih = malloc(sizeof *ih, M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
	if (ih == NULL)
		panic("intr_establish: can't malloc handler info");

	iq = &macintr_handler[irq];
	switch (iq->iq_ist) {
	case IST_NONE:
		iq->iq_ist = type;
		break;
	case IST_EDGE:
		intr_shared_edge = 1;
		/* FALLTHROUGH */
	case IST_LEVEL:
		if (type == iq->iq_ist)
			break;
	case IST_PULSE:
		if (type != IST_NONE)
			panic("intr_establish: can't share %s with %s",
			    ppc_intr_typename(iq->iq_ist),
			    ppc_intr_typename(type));
		break;
	}

	flags = level & IPL_MPSAFE;
	level &= ~IPL_MPSAFE;

	KASSERT(level <= IPL_TTY || level >= IPL_CLOCK || flags & IPL_MPSAFE);

	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_level = level;
	ih->ih_flags = flags;
	ih->ih_irq = irq;
	evcount_attach(&ih->ih_count, name, &ih->ih_irq);

	/*
	 * Append handler to end of list
	 */
	s = ppc_intr_disable();

	TAILQ_INSERT_TAIL(&iq->iq_list, ih, ih_list);
	macintr_calc_mask();

	macintr_setipl(ci->ci_cpl);
	ppc_intr_enable(s);

	return (ih);
}

/*
 * Deregister an interrupt handler.
 */
void
macintr_disestablish(void *lcp, void *arg)
{
	struct cpu_info *ci = curcpu();
	struct intrhand *ih = arg;
	int irq = ih->ih_irq;
	int s;
	struct intrq *iq;

	if (!LEGAL_IRQ(irq)) {
		printf("%s: bogus irq %d", __func__, irq);
		return;
	}

	/*
	 * Remove the handler from the chain.
	 */

	iq = &macintr_handler[irq];
	s = ppc_intr_disable();

	TAILQ_REMOVE(&iq->iq_list, ih, ih_list);
	macintr_calc_mask();

	macintr_setipl(ci->ci_cpl);
	ppc_intr_enable(s);

	evcount_detach(&ih->ih_count);
	free(ih, M_DEVBUF, sizeof *ih);

	if (TAILQ_EMPTY(&iq->iq_list))
		iq->iq_ist = IST_NONE;
}

/*
 * Recalculate the interrupt masks from scratch.
 * We could code special registry and deregistry versions of this function that
 * would be faster, but the code would be nastier, and we don't expect this to
 * happen very much anyway.
 */
void
macintr_calc_mask()
{
	int irq;
	struct intrhand *ih;
	int i;

	for (i = IPL_NONE; i < IPL_NUM; i++) {
		macintr_pri_share[i] = i;
	}

	for (irq = 0; irq < ICU_LEN; irq++) {
		int maxipl = IPL_NONE;
		int minipl = IPL_HIGH;
		struct intrq *iq = &macintr_handler[irq];

		TAILQ_FOREACH(ih, &iq->iq_list, ih_list) {
			if (ih->ih_level > maxipl)
				maxipl = ih->ih_level;
			if (ih->ih_level < minipl)
				minipl = ih->ih_level;
		}

		iq->iq_ipl = maxipl;

		if (maxipl == IPL_NONE) {
			minipl = IPL_NONE; /* Interrupt not enabled */
		} else {
			for (i = minipl; i < maxipl; i++)
				macintr_pri_share[i] =
				    macintr_pri_share[maxipl];
		}

		/* Enable interrupts at lower levels */

		if (irq < 32) {
			for (i = IPL_NONE; i < minipl; i++)
				macintr_ienable_l[i] |= (1 << irq);
			for (; i <= IPL_HIGH; i++)
				macintr_ienable_l[i] &= ~(1 << irq);
		} else {
			for (i = IPL_NONE; i < minipl; i++)
				macintr_ienable_h[i] |= (1 << (irq-32));
			for (; i <= IPL_HIGH; i++)
				macintr_ienable_h[i] &= ~(1 << (irq-32));
		}
	}

#if 0
	for (i = 0; i < IPL_NUM; i++)
		printf("imask[%d] %x %x\n", i, macintr_ienable_l[i],
		    macintr_ienable_h[i]);
#endif
}

/*
 * external interrupt handler
 */
void
mac_ext_intr()
{
	int irq = 0;
	int pcpl, ret;
	struct cpu_info *ci = curcpu();
	struct intrq *iq;
	struct intrhand *ih;

	pcpl = ci->ci_cpl;	/* Turn off all */

	irq = macintr_read_irq();
	while (irq != 255) {
		iq = &macintr_handler[irq];
		macintr_setipl(iq->iq_ipl);

		TAILQ_FOREACH(ih, &iq->iq_list, ih_list) {
			ppc_intr_enable(1);
			ret = ((*ih->ih_fun)(ih->ih_arg));
			if (ret) {
				ih->ih_count.ec_count++;
				if (intr_shared_edge == 0 && ret == 1)
					break;
			}
			(void)ppc_intr_disable();
		}
		macintr_eoi(irq);
		macintr_setipl(pcpl);

		uvmexp.intrs++;

		irq = macintr_read_irq();
	}

	macintr_splx(pcpl);	/* Process pendings. */
}

void
macintr_eoi(int irq)
{
	u_int32_t state0, state1;

	if (irq < 32) {
		state0 =  1 << irq;
		out32rb(INT_CLEAR_REG0, state0);
	} else {
		if (heathrow_FCR) {		/* has heathrow? */
			state1 = 1 << (irq - 32);
			out32rb(INT_CLEAR_REG1, state1);
		}
	}
}

int
macintr_read_irq()
{
	struct cpu_info *ci = curcpu();
	u_int32_t state0, state1, irq_mask;
	int ipl, irq;

	state0 = in32rb(INT_STATE_REG0);

	if (heathrow_FCR)			/* has heathrow? */
		state1 = in32rb(INT_STATE_REG1);
	else
		state1 = 0;

	for (ipl = IPL_HIGH; ipl >= ci->ci_cpl; ipl --) {
		irq_mask = state0 & macintr_ienable_l[ipl];
		if (irq_mask) {
			irq = ffs(irq_mask) - 1;
			return irq;
		}
		irq_mask = state1 & macintr_ienable_h[ipl];
		if (irq_mask) {
			irq = ffs(irq_mask) + 31;
			return irq;
		}
	}
	return 255;
}
@


1.53
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.52 2015/06/24 11:58:06 mpi Exp $	*/
d252 1
a252 1
		Debugger();
@


1.52
log
@IPL_MPSAFE bits for macppc with openpic(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.51 2015/04/02 11:12:24 mpi Exp $	*/
d371 1
a371 1
	free((void *)ih, M_DEVBUF, 0);
@


1.51
log
@One function pointer per pic function is enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.50 2015/01/04 13:01:42 mpi Exp $	*/
d283 1
a283 5
	int s;

#if 0
printf("macintr_establish, hI %d L %d %s", irq, level, ppc_intr_typename(type));
#endif
d314 5
d322 1
@


1.50
log
@Implement splassert(9) for powerpc.

This changes the logic to prevent a recursion when processing soft
interrupts.  Previously a per-CPU flag was set before re-enabling
interrupts.  Now the IPL level is raised to SOFTTTY which makes
splsoftassert() happy, greatly inspired by mips64.

As a side effect, the ppc_intr_{disable,enable}() dance is now done
only once instead of twice per splx(9).

While here, make use of dosoftint() instead of having 3 different
functions for dispatching soft interrupts.

Tested by deraadt@@ on G4 smp and by myself G5 smp, G3, G4 and socppc.

No objection from the usual (and over busy) suspects.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.49 2014/09/06 10:45:29 mpi Exp $	*/
a129 2
extern intr_establish_t *mac_intr_establish_func;
extern intr_disestablish_t *mac_intr_disestablish_func;
a201 2
	mac_intr_establish_func  = macintr_establish;
	mac_intr_disestablish_func  = macintr_disestablish;
@


1.49
log
@Rename ci_iactive into ci_flags, this field now holds the going-to-
sleep bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.48 2014/08/30 09:42:20 mpi Exp $	*/
a66 1
static void macintr_do_pending_int(void);
a84 1
void	mac_do_pending_int(void);
a125 1
extern void_f *pending_int_f;
d142 3
a145 1
	int ocpl = ci->ci_cpl;
d149 1
d151 1
d171 3
a173 1
	 
d175 6
a180 2
	if (ci->ci_ipending & ppc_smask[newcpl])
		macintr_do_pending_int();
a201 1
	pending_int_f = macintr_do_pending_int;
d263 1
d268 1
a268 2
	int s;
	s = ppc_intr_disable();
a274 1
	ppc_intr_enable(s);
d477 1
a477 39
	ppc_intr_enable(1);
	splx(pcpl);	/* Process pendings. */
}

void
macintr_do_pending_int()
{
	struct cpu_info *ci = curcpu();
	int pcpl = ci->ci_cpl; /* XXX */
	int s;
	s = ppc_intr_disable();
	if (ci->ci_flags & CI_FLAGS_PROCESSING_SOFT) {
		ppc_intr_enable(s);
		return;
	}
	atomic_setbits_int(&ci->ci_flags, CI_FLAGS_PROCESSING_SOFT);

	do {
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTCLOCK)) &&
		    (pcpl < IPL_SOFTCLOCK)) {
 			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTCLOCK);
			softintr_dispatch(SI_SOFTCLOCK);
 		}
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTNET)) &&
		    (pcpl < IPL_SOFTNET)) {
			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTNET);
			softintr_dispatch(SI_SOFTNET);
		}
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTTTY)) &&
		    (pcpl < IPL_SOFTTTY)) {
			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTTTY);
			softintr_dispatch(SI_SOFTTTY);
		}

	} while (ci->ci_ipending & ppc_smask[pcpl]);
	macintr_setipl(pcpl);
	ppc_intr_enable(s);

	atomic_clearbits_int(&ci->ci_flags, CI_FLAGS_PROCESSING_SOFT);
@


1.48
log
@Don't panic when an illegal IRQ is passed to intr_{dis,}establish().

At least the device-tree for the second bge(4) on my PowerMac is not
parsed correctly but we can live with that until the bug is fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.47 2014/07/12 18:44:42 tedu Exp $	*/
d205 1
a205 1
	ci->ci_iactive = 0;
d483 1
a483 1
	if (ci->ci_iactive & CI_IACTIVE_PROCESSING_SOFT) {
d487 1
a487 1
	atomic_setbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_SOFT);
d510 1
a510 1
	atomic_clearbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_SOFT);
@


1.47
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.46 2014/04/01 20:27:14 mpi Exp $	*/
d288 5
a297 3
	if (!LEGAL_IRQ(irq) || type == IST_NONE)
		panic("intr_establish: bogus irq or type");

d349 4
a352 2
	if (!LEGAL_IRQ(irq))
		panic("intr_disestablish: bogus irq");
@


1.46
log
@Remove the almost unused abstraction around "struct firmware" and use
instead a single function ppc_mem_regions() required by the ppc pmap.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.45 2014/03/31 18:58:41 mpi Exp $	*/
d364 1
a364 1
	free((void *)ih, M_DEVBUF);
@


1.45
log
@Including <uvm/uvm_extern.h> is enough, no need for <uvm/uvm.h> or more.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.44 2011/09/16 17:56:52 drahn Exp $	*/
a52 1
#include <machine/powerpc.h>
@


1.44
log
@Set the shared priority entry to the value of the current maxipl entry,
not the index. ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.43 2011/08/29 20:21:44 drahn Exp $	*/
a41 3
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
d43 1
d45 1
a45 1
#include <uvm/uvm.h>
@


1.43
log
@Return of the long missing powerpc interrupt rewrite.  Was working for
several weeks before release on macppc, socppc bugs just fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.42 2011/04/15 20:52:55 deraadt Exp $	*/
d407 3
a409 2
			for (i = minipl; i <= maxipl; i++)
				macintr_pri_share[i] = i;
@


1.42
log
@More than a decade ago, interrupt handlers on sparc started returning 0
(interrupt was not for me), 1 (positive interrupt was for me), or -1
(i am not sure...).  We have continued with this practice in as many
drivers as possible, throughout the tree.

This makes some of the architectures use that information in their
interrupt handler calling code -- if 1 is returned (and we know
this specific machine does not have edge-shared interrupts), we
finish servicing other possible handlers on the same pin.  If the
interrupt pin remains asserted (from a different device), we will
end up back in the interrupt servicing code of course... but this is
cheaper than calling all the chained interrupts on a pin.

This does of course count on shared level interrupts being properly
sorted by IPL.

There have been some concerns about starvation of drivers which
incorrectly return 1.  Those drivers should be hunted down so that
they return -1.

ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.41 2011/01/08 18:10:22 deraadt Exp $	*/
d4 1
d62 9
a70 14
int m_intrtype[ICU_LEN], m_intrmask[ICU_LEN], m_intrlevel[ICU_LEN];
struct intrhand *m_intrhand[ICU_LEN];
int m_hwirq[ICU_LEN], m_virq[64];
unsigned int imen_m = 0xffffffff;
int m_virq_max = 0;

static int fakeintr(void *);
static char *intr_typename(int type);
static void intr_calculatemasks(void);
static void enable_irq(int x);
static __inline int cntlzw(int x);
static int mapirq(int irq);
static int read_irq(void);
static void mac_intr_do_pending_int(void);
a73 3
#define HWIRQ_MAX 27
#define HWIRQ_MASK 0x0fffffff

d91 2
d138 40
a177 1
void macintr_collect_preconf_intr(void);
d182 1
d186 2
d191 6
d198 1
a198 1
	pending_int_f = mac_intr_do_pending_int;
d204 6
a215 1

d260 2
a261 2
static int
fakeintr(void *arg)
d263 7
d271 2
a272 1
	return 0;
d282 4
a285 2
	struct intrhand **p, *q, *ih;
	static struct intrhand fakehand;
a286 8
	fakehand.ih_next = NULL;
	fakehand.ih_fun  = fakeintr;

#if 0
printf("macintr_establish, hI %d L %d ", irq, type);
printf("addr reg0 %x\n", INT_STATE_REG0);
#endif
	irq = mapirq(irq);
d288 1
a288 1
printf("vI %d ", irq);
d299 2
a300 1
	switch (m_intrtype[irq]) {
d302 1
a302 1
		m_intrtype[irq] = type;
d308 1
a308 1
		if (type == m_intrtype[irq])
d313 2
a314 2
			    intr_typename(m_intrtype[irq]),
			    intr_typename(type));
d318 5
a322 7
	/*
	 * Figure out where to put the handler.
	 * This is O(N^2), but we want to preserve the order, and N is
	 * generally small.
	 */
	for (p = &m_intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
		;
d325 1
a325 3
	 * Actually install a fake handler momentarily, since we might be doing
	 * this with interrupts enabled and DON'T WANt the real routine called
	 * until masking is set up.
d327 1
a327 2
	fakehand.ih_level = level;
	*p = &fakehand;
d329 2
a330 1
	intr_calculatemasks();
d332 2
a333 10
	/*
	 * Poke the real handler in now.
	 */
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_next = NULL;
	ih->ih_level = level;
	ih->ih_irq = irq;
	evcount_attach(&ih->ih_count, name, &m_hwirq[irq]);
	*p = ih;
d344 1
d347 2
a348 1
	struct intrhand **p, *q;
a354 1
	 * This is O(n^2), too.
d356 9
a364 6
	for (p = &m_intrhand[irq]; (q = *p) != NULL && q != ih; p = &q->ih_next)
		;
	if (q)
		*p = q->ih_next;
	else
		panic("intr_disestablish: handler not registered");
d369 2
a370 4
	intr_calculatemasks();

	if (m_intrhand[irq] == NULL)
		m_intrtype[irq] = IST_NONE;
a372 20

static char *
intr_typename(int type)
{
	switch (type) {
        case IST_NONE :
		return ("none");
        case IST_PULSE:
		return ("pulsed");
        case IST_EDGE:
		return ("edge-triggered");
        case IST_LEVEL:
		return ("level-triggered");
	default:
		panic("intr_typename: invalid type %d", type);
#if 1 /* XXX */
		return ("unknown");
#endif
	}
}
d379 2
a380 2
static void
intr_calculatemasks()
d382 3
a384 2
	int irq, level;
	struct intrhand *q;
d386 2
a387 6
	/* First, figure out which levels each IRQ uses. */
	for (irq = 0; irq < ICU_LEN; irq++) {
		register int levels = 0;
		for (q = m_intrhand[irq]; q; q = q->ih_next)
			levels |= 1 << q->ih_level;
		m_intrlevel[irq] = levels;
a389 28
	/* Then figure out which IRQs use each level. */
	for (level = IPL_NONE; level < IPL_NUM; level++) {
		register int irqs = 0;
		for (irq = 0; irq < ICU_LEN; irq++)
			if (m_intrlevel[irq] & (1 << level))
				irqs |= 1 << irq;
		cpu_imask[level] = irqs | SINT_ALLMASK;
	}

	/*
	 * There are tty, network and disk drivers that use free() at interrupt
	 * time, so vm > (tty | net | bio).
	 *
	 * Enforce a hierarchy that gives slow devices a better chance at not
	 * dropping data.
	 */
	cpu_imask[IPL_NET] |= cpu_imask[IPL_BIO];
	cpu_imask[IPL_TTY] |= cpu_imask[IPL_NET];
	cpu_imask[IPL_VM] |= cpu_imask[IPL_TTY];
	cpu_imask[IPL_CLOCK] |= cpu_imask[IPL_VM] | SPL_CLOCKMASK;

	/*
	 * These are pseudo-levels.
	 */
	cpu_imask[IPL_NONE] = 0x00000000;
	cpu_imask[IPL_HIGH] = 0xffffffff;

	/* And eventually calculate the complete masks. */
d391 9
a399 12
		register int irqs = 1 << irq;
		for (q = m_intrhand[irq]; q; q = q->ih_next)
			irqs |= cpu_imask[q->ih_level];
		m_intrmask[irq] = irqs | SINT_ALLMASK;
	}

	/* Lastly, determine which IRQs are actually in use. */
	{
		register int irqs = 0;
		for (irq = 0; irq < ICU_LEN; irq++) {
			if (m_intrhand[irq])
				irqs |= 1 << irq;
a400 9
		imen_m = ~irqs;
		enable_irq(~imen_m);
	}
}
static void
enable_irq(int x)
{
	int state0, state1, v;
	int irq;
d402 1
a402 1
	x &= HWIRQ_MASK;	/* XXX Higher bits are software interrupts. */
d404 6
a409 14
	state0 = state1 = 0;
	while (x) {
		v = 31 - cntlzw(x);
		irq = m_hwirq[v];
		if (irq < 32)
			state0 |= 1 << irq;
		else
			state1 |= 1 << (irq - 32);

		x &= ~(1 << v);
	}

	if (heathrow_FCR)
		out32rb(INT_ENABLE_REG1, state1);
d411 1
a411 13
	out32rb(INT_ENABLE_REG0, state0);
}

int m_virq_inited = 0;

/*
 * Map 64 irqs into 32 (bits).
 */
static int
mapirq(int irq)
{
	int v;
	int i;
d413 10
a422 4
	if (m_virq_inited == 0) {
		m_virq_max = 0;
		for (i = 0; i < ICU_LEN; i++) {
			m_virq[i] = 0;
a423 1
		m_virq_inited = 1;
a425 13
	/* irq in table already? */
	if (m_virq[irq] != 0)
		return m_virq[irq];

	if (irq < 0 || irq >= 64)
		panic("invalid irq %d", irq);
	m_virq_max++;
	v = m_virq_max;
	if (v > HWIRQ_MAX)
		panic("virq overflow");

	m_hwirq[v] = irq;
	m_virq[irq] = v;
d427 3
a429 1
printf("\nmapirq %x to %x\n", irq, v);
a430 15

	return v;
}

/*
 * Count leading zeros.
 */
static __inline int
cntlzw(int x)
{
	int a;

	__asm __volatile ("cntlzw %0,%1" : "=r"(a) : "r"(x));

	return a;
a439 1
	int o_imen, r_imen;
d442 1
a443 1
	volatile unsigned long int_state;
d447 4
a450 17
	int_state = read_irq();
	if (int_state == 0)
		goto out;

start:
	irq = 31 - cntlzw(int_state);

	o_imen = imen_m;
	r_imen = 1 << irq;

	if ((ci->ci_cpl & r_imen) != 0) {
		/* Masked! Mark this as pending. */
		ci->ci_ipending |= r_imen;
		imen_m |= r_imen;
		enable_irq(~imen_m);
	} else {
		splraise(m_intrmask[irq]);
d452 2
a453 2
		ih = m_intrhand[irq];
		while (ih) {
d460 1
a460 1
			ih = ih->ih_next;
d462 2
d466 2
a468 3
	int_state &= ~r_imen;
	if (int_state)
		goto start;
d470 1
a470 1
out:
d475 1
a475 1
mac_intr_do_pending_int()
d478 1
a478 4
	struct intrhand *ih;
	int irq;
	int pcpl;
	int hwpend;
d480 3
a482 2

	if (ci->ci_iactive)
a483 18

	ci->ci_iactive = 1;
	pcpl = splhigh();		/* Turn off all */
	s = ppc_intr_disable();

	hwpend = ci->ci_ipending & ~pcpl;	/* Do now unmasked pendings */
	imen_m &= ~hwpend;
	enable_irq(~imen_m);
	hwpend &= HWIRQ_MASK;
	while (hwpend) {
		irq = 31 - cntlzw(hwpend);
		hwpend &= ~(1L << irq);
		ih = m_intrhand[irq];
		while(ih) {
			if ((*ih->ih_fun)(ih->ih_arg))
				ih->ih_count.ec_count++;
			ih = ih->ih_next;
		}
d485 1
a485 2

	/*out32rb(INT_ENABLE_REG, ~imen_m);*/
d488 3
a490 2
		if((ci->ci_ipending & SINT_CLOCK) & ~pcpl) {
			ci->ci_ipending &= ~SINT_CLOCK;
d492 4
a495 3
		}
		if((ci->ci_ipending & SINT_NET) & ~pcpl) {
			ci->ci_ipending &= ~SINT_NET;
d498 3
a500 2
		if((ci->ci_ipending & SINT_TTY) & ~pcpl) {
			ci->ci_ipending &= ~SINT_TTY;
d503 3
a505 3
	} while ((ci->ci_ipending & SINT_ALLMASK) & ~pcpl);
	ci->ci_ipending &= pcpl;
	ci->ci_cpl = pcpl;	/* Don't use splx... we are here already! */
d507 2
a508 1
	ci->ci_iactive = 0;
d511 2
a512 2
static int
read_irq()
d514 1
a514 3
	int rv = 0;
	int state0, state1, p;
	int state0save, state1save;
d516 2
a517 2
	state0 = in32rb(INT_STATE_REG0);
	if (state0)
d519 5
a523 5
	state0save = state0;
	while (state0) {
		p = 31 - cntlzw(state0);
		rv |= 1 << m_virq[p];
		state0 &= ~(1 << p);
d525 10
d541 11
a551 7
	if (state1)
		out32rb(INT_CLEAR_REG1, state1);
	state1save = state1;
	while (state1) {
		p = 31 - cntlzw(state1);
		rv |= 1 << m_virq[p + 32];
		state1 &= ~(1 << p);
d553 1
a553 6
#if 0
printf("mac_intr int_stat 0:%x 1:%x\n", state0save, state1save);
#endif

	/* 1 << 0 is invalid. */
	return rv & ~1;
@


1.41
log
@rename imask[] to cpu_imask[] to because imask is too loud as far as
kernel namespace
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.40 2010/09/20 06:33:47 matthew Exp $	*/
d254 2
d504 1
a504 1
	int pcpl;
d531 2
a532 1
			if ((*ih->ih_fun)(ih->ih_arg))
d534 3
@


1.40
log
@Get rid of evcount's support for arranging counters in a tree
hierarchy.  Everything attached to a single root node anyway, so at
best we had a bush.

"i think it is good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.39 2009/10/01 20:19:18 kettenis Exp $	*/
d376 1
a376 1
		imask[level] = irqs | SINT_ALLMASK;
d386 4
a389 4
	imask[IPL_NET] |= imask[IPL_BIO];
	imask[IPL_TTY] |= imask[IPL_NET];
	imask[IPL_VM] |= imask[IPL_TTY];
	imask[IPL_CLOCK] |= imask[IPL_VM] | SPL_CLOCKMASK;
d394 2
a395 2
	imask[IPL_NONE] = 0x00000000;
	imask[IPL_HIGH] = 0xffffffff;
d401 1
a401 1
			irqs |= imask[q->ih_level];
@


1.39
log
@Generic soft interrupts for macppc.  Tested by mk@@, deraadt@@
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.38 2009/08/22 02:54:50 mk Exp $	*/
d291 1
a291 2
	evcount_attach(&ih->ih_count, name, (void *)&m_hwirq[irq],
	    &evcount_intr);
@


1.38
log
@Constify the what/name parameter of pci_intr_establish().

Tested by myself, sthen, oga, kettenis, and jasper.
Input from sthen and jasper.

ok kettenis

(Manpage follows shortly.)
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.37 2009/06/09 01:12:38 deraadt Exp $	*/
d377 1
a377 1
		imask[level] = irqs | SINT_MASK;
d390 1
a390 1
	imask[IPL_CLOCK] |= imask[IPL_VM] | SPL_CLOCK;
d403 1
a403 1
		m_intrmask[irq] = irqs | SINT_MASK;
d582 1
a582 1
			softclock();
a584 3
			extern int netisr;
			int pisr;

d586 1
a586 4
			while ((pisr = netisr) != 0) {
				atomic_clearbits_int(&netisr, pisr);
				softnet(pisr);
			}
d590 1
a590 1
			softtty();
d592 1
a592 1
	} while ((ci->ci_ipending & SINT_MASK) & ~pcpl);
@


1.37
log
@backout interrupt diff until it the next round of fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.35 2008/11/21 17:35:52 deraadt Exp $	*/
d224 1
a224 1
    int (*ih_fun)(void *), void *ih_arg, char *name)
@


1.36
log
@Reintroduce the macppc interrupt subsystem rewrite. Several bugs have
been found and corrected.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.34 2008/09/18 03:56:25 drahn Exp $	*/
a3 1
 * Copyright (c) 2008 Dale Rahn <drahn@@openbsd.org>
d61 14
a74 2
int macintr_ienable_l[IPL_NUM], macintr_ienable_h[IPL_NUM];
int macintr_pri_share[IPL_NUM];
d76 1
a76 6
struct intrq macintr_handler[ICU_LEN];

void macintr_calc_mask(void);
void macintr_eoi(int irq);
int macintr_read_irq(void);
static void macintr_do_pending_int(void);
d78 2
a79 1
extern u_int32_t *heathrow_FCR;
a97 2
void	macintr_collect_preconf_intr(void);
void	macintr_setipl(int ipl);
d143 1
a143 40

ppc_splraise_t macintr_splraise;
ppc_spllower_t macintr_spllower;
ppc_splx_t macintr_splx;


int
macintr_splraise(int newcpl)
{
	struct cpu_info *ci = curcpu();
	newcpl = macintr_pri_share[newcpl];
	int ocpl = ci->ci_cpl;
	if (ocpl > newcpl)
		newcpl = ocpl;

	macintr_setipl(newcpl);

	return ocpl;
}

int
macintr_spllower(int newcpl)
{
	struct cpu_info *ci = curcpu();
	int ocpl = ci->ci_cpl;

	macintr_splx(newcpl);

	return ocpl;
}

void
macintr_splx(int newcpl)
{
	struct cpu_info *ci = curcpu();
	 
	macintr_setipl(newcpl);
	if (ci->ci_ipending & ppc_smask[newcpl])
		macintr_do_pending_int();
}
a147 1
	struct cpu_info *ci = curcpu();
a150 2
	struct intrq *iq;
	int i;
a153 6
	for (i = 0; i < ICU_LEN; i++) {
		iq = &macintr_handler[i];
		TAILQ_INIT(&iq->iq_list);
	}
	ppc_smask_init();

d155 1
a155 1
	pending_int_f = macintr_do_pending_int;
a160 6
	ppc_intr_func.raise = macintr_splraise;
	ppc_intr_func.lower = macintr_spllower;
	ppc_intr_func.x = macintr_splx;

	ci->ci_iactive = 0;

d167 1
d212 2
a213 2
void
macintr_setipl(int ipl)
a214 7
	struct cpu_info *ci = curcpu();
	int s;
	s = ppc_intr_disable();
	ci->ci_cpl = ipl;
	if (heathrow_FCR)
		out32rb(INT_ENABLE_REG1,
		    macintr_ienable_h[macintr_pri_share[ipl]]);
d216 1
a216 2
	out32rb(INT_ENABLE_REG0, macintr_ienable_l[macintr_pri_share[ipl]]);
	ppc_intr_enable(s);
d226 5
a230 4
	struct cpu_info *ci = curcpu();
	struct intrq *iq;
	struct intrhand *ih;
	int s;
d233 6
a238 1
printf("macintr_establish, hI %d L %d %s", irq, level, ppc_intr_typename(type));
d249 1
a249 2
	iq = &macintr_handler[irq];
	switch (iq->iq_ist) {
d251 1
a251 1
		iq->iq_ist = type;
d255 1
a255 1
		if (type == iq->iq_ist)
d260 2
a261 2
			    ppc_intr_typename(iq->iq_ist),
			    ppc_intr_typename(type));
d265 21
d288 1
d291 1
a291 1
	evcount_attach(&ih->ih_count, name, (void *)&ih->ih_irq,
d293 1
a293 11

	/*
	 * Append handler to end of list
	 */
	s = ppc_intr_disable();

	TAILQ_INSERT_TAIL(&iq->iq_list, ih, ih_list);
	macintr_calc_mask();

	macintr_setipl(ci->ci_cpl);
	ppc_intr_enable(s);
a303 1
	struct cpu_info *ci = curcpu();
d306 1
a306 2
	int s;
	struct intrq *iq;
d313 1
d315 6
d322 2
a323 2
	iq = &macintr_handler[irq];
	s = ppc_intr_disable();
d325 1
a325 2
	TAILQ_REMOVE(&iq->iq_list, ih, ih_list);
	macintr_calc_mask();
d327 3
a329 2
	macintr_setipl(ci->ci_cpl);
	ppc_intr_enable(s);
a330 2
	evcount_detach(&ih->ih_count);
	free((void *)ih, M_DEVBUF);
d332 18
a349 2
	if (TAILQ_EMPTY(&iq->iq_list))
		iq->iq_ist = IST_NONE;
a350 1

d357 2
a358 2
void
macintr_calc_mask()
d360 10
a369 3
	int irq;
	struct intrhand *ih;
	int i;
d371 7
a377 2
	for (i = IPL_NONE; i < IPL_NUM; i++) {
		macintr_pri_share[i] = i;
d380 19
d400 12
a411 9
		int maxipl = IPL_NONE;
		int minipl = IPL_HIGH;
		struct intrq *iq = &macintr_handler[irq];

		TAILQ_FOREACH(ih, &iq->iq_list, ih_list) {
			if (ih->ih_level > maxipl)
				maxipl = ih->ih_level;
			if (ih->ih_level < minipl)
				minipl = ih->ih_level;
d413 20
d434 8
a441 1
		iq->iq_ipl = maxipl;
d443 1
a443 6
		if (maxipl == IPL_NONE) {
			minipl = IPL_NONE; /* Interrupt not enabled */
		} else {
			for (i = minipl; i <= maxipl; i++)
				macintr_pri_share[i] = i;
		}
d445 8
a452 1
		/* Enable interrupts at lower levels */
d454 4
a457 10
		if (irq < 32) {
			for (i = IPL_NONE; i < minipl; i++)
				macintr_ienable_l[i] |= (1 << irq);
			for (; i <= IPL_HIGH; i++)
				macintr_ienable_l[i] &= ~(1 << irq);
		} else {
			for (i = IPL_NONE; i < minipl; i++)
				macintr_ienable_h[i] |= (1 << (irq-32));
			for (; i <= IPL_HIGH; i++)
				macintr_ienable_h[i] &= ~(1 << (irq-32));
d459 1
d462 13
d476 1
a476 3
	for (i = 0; i < IPL_NUM; i++)
		printf("imask[%d] %x %x\n", i, macintr_ienable_l[i],
		    macintr_ienable_h[i]);
d478 15
d502 1
a504 1
	struct intrq *iq;
d506 1
d510 17
a526 4
	irq = macintr_read_irq();
	while (irq != 255) {
		iq = &macintr_handler[irq];
		macintr_setipl(iq->iq_ipl);
d528 2
a529 2
		TAILQ_FOREACH(ih, &iq->iq_list, ih_list) {
			ppc_intr_enable(1);
d532 1
a532 1
			(void)ppc_intr_disable();
a533 2
		macintr_eoi(irq);
		macintr_setipl(pcpl);
a535 2

		irq = macintr_read_irq();
d537 3
d541 1
a541 1
	ppc_intr_enable(1);
d546 1
a546 1
macintr_do_pending_int()
d549 4
a552 1
	int pcpl = ci->ci_cpl; /* XXX */
d554 6
d561 14
a574 3
	if (ci->ci_iactive & CI_IACTIVE_PROCESSING_SOFT) {
		ppc_intr_enable(s);
		return;
d576 2
a577 1
	atomic_setbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_SOFT);
d580 3
a582 10
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTTTY)) &&  (pcpl < IPL_SOFTTTY)) {
			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTTTY);
			ci->ci_cpl = IPL_SOFTTTY;
			ppc_intr_enable(1);
			KERNEL_LOCK();
			softtty();
			KERNEL_UNLOCK();
			ppc_intr_disable();
			ci->ci_cpl = pcpl;
			continue;
d584 1
a584 1
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTNET)) &&  (pcpl < IPL_SOFTNET)) {
d588 1
a588 1
			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTNET);
a590 3
				ci->ci_cpl = IPL_SOFTNET;
				ppc_intr_enable(1);
				KERNEL_LOCK();
a591 3
				KERNEL_UNLOCK();
				ppc_intr_disable();
				ci->ci_cpl = pcpl;
a592 1
			continue;
d594 3
a596 10
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTCLOCK)) && (pcpl < IPL_SOFTCLOCK)) {
			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTCLOCK);
			ci->ci_cpl = IPL_SOFTCLOCK;
			ppc_intr_enable(1);
			KERNEL_LOCK();
			softclock();
			KERNEL_UNLOCK();
			ppc_intr_disable();
			ci->ci_cpl = pcpl;
			continue;
d598 5
a602 3
	} while (ci->ci_ipending & ppc_smask[pcpl]);
	macintr_setipl(pcpl);
	atomic_clearbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_SOFT);
d605 2
a606 2
void
macintr_eoi(int irq)
d608 3
a610 1
	u_int32_t state0, state1;
d612 2
a613 2
	if (irq < 32) {
		state0 =  1 << irq;
d615 5
a619 5
	} else {
		if (heathrow_FCR) {		/* has heathrow? */
			state1 = 1 << (irq - 32);
			out32rb(INT_CLEAR_REG1, state1);
		}
a620 10
}

int
macintr_read_irq()
{
	struct cpu_info *ci = curcpu();
	u_int32_t state0, state1, irq_mask;
	int ipl, irq;

	state0 = in32rb(INT_STATE_REG0);
d627 7
a633 11
	for (ipl = IPL_HIGH; ipl >= ci->ci_cpl; ipl --) {
		irq_mask = state0 & macintr_ienable_l[ipl];
		if (irq_mask) {
			irq = ffs(irq_mask) - 1;
			return irq;
		}
		irq_mask = state1 & macintr_ienable_h[ipl];
		if (irq_mask) {
			irq = ffs(irq_mask) + 31;
			return irq;
		}
d635 6
a640 1
	return 255;
@


1.35
log
@back out the new interrupt subsystem because some little bug still lurks in there
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.33 2007/05/29 18:10:42 miod Exp $	*/
d4 1
d62 9
a70 14
int m_intrtype[ICU_LEN], m_intrmask[ICU_LEN], m_intrlevel[ICU_LEN];
struct intrhand *m_intrhand[ICU_LEN];
int m_hwirq[ICU_LEN], m_virq[64];
unsigned int imen_m = 0xffffffff;
int m_virq_max = 0;

static int fakeintr(void *);
static char *intr_typename(int type);
static void intr_calculatemasks(void);
static void enable_irq(int x);
static __inline int cntlzw(int x);
static int mapirq(int irq);
static int read_irq(void);
static void mac_intr_do_pending_int(void);
a73 3
#define HWIRQ_MAX 27
#define HWIRQ_MASK 0x0fffffff

d91 2
d138 40
a177 1
void macintr_collect_preconf_intr(void);
d182 1
d186 2
d191 6
d198 1
a198 1
	pending_int_f = mac_intr_do_pending_int;
d204 6
a215 1

d260 2
a261 2
static int
fakeintr(void *arg)
d263 7
d271 2
a272 1
	return 0;
d282 4
a285 5
	struct intrhand **p, *q, *ih;
	static struct intrhand fakehand;

	fakehand.ih_next = NULL;
	fakehand.ih_fun  = fakeintr;
d288 1
a288 6
printf("macintr_establish, hI %d L %d ", irq, type);
printf("addr reg0 %x\n", INT_STATE_REG0);
#endif
	irq = mapirq(irq);
#if 0
printf("vI %d ", irq);
d299 2
a300 1
	switch (m_intrtype[irq]) {
d302 1
a302 1
		m_intrtype[irq] = type;
d306 1
a306 1
		if (type == m_intrtype[irq])
d311 2
a312 2
			    intr_typename(m_intrtype[irq]),
			    intr_typename(type));
d316 6
a321 7
	/*
	 * Figure out where to put the handler.
	 * This is O(N^2), but we want to preserve the order, and N is
	 * generally small.
	 */
	for (p = &m_intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
		;
d324 1
a324 3
	 * Actually install a fake handler momentarily, since we might be doing
	 * this with interrupts enabled and DON'T WANt the real routine called
	 * until masking is set up.
d326 1
a326 2
	fakehand.ih_level = level;
	*p = &fakehand;
d328 2
a329 1
	intr_calculatemasks();
d331 2
a332 11
	/*
	 * Poke the real handler in now.
	 */
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_next = NULL;
	ih->ih_level = level;
	ih->ih_irq = irq;
	evcount_attach(&ih->ih_count, name, (void *)&m_hwirq[irq],
	    &evcount_intr);
	*p = ih;
d343 1
d346 2
a347 1
	struct intrhand **p, *q;
a353 1
	 * This is O(n^2), too.
d355 9
a363 6
	for (p = &m_intrhand[irq]; (q = *p) != NULL && q != ih; p = &q->ih_next)
		;
	if (q)
		*p = q->ih_next;
	else
		panic("intr_disestablish: handler not registered");
d368 2
a369 4
	intr_calculatemasks();

	if (m_intrhand[irq] == NULL)
		m_intrtype[irq] = IST_NONE;
a371 20

static char *
intr_typename(int type)
{
	switch (type) {
        case IST_NONE :
		return ("none");
        case IST_PULSE:
		return ("pulsed");
        case IST_EDGE:
		return ("edge-triggered");
        case IST_LEVEL:
		return ("level-triggered");
	default:
		panic("intr_typename: invalid type %d", type);
#if 1 /* XXX */
		return ("unknown");
#endif
	}
}
d378 2
a379 2
static void
intr_calculatemasks()
d381 3
a383 10
	int irq, level;
	struct intrhand *q;

	/* First, figure out which levels each IRQ uses. */
	for (irq = 0; irq < ICU_LEN; irq++) {
		register int levels = 0;
		for (q = m_intrhand[irq]; q; q = q->ih_next)
			levels |= 1 << q->ih_level;
		m_intrlevel[irq] = levels;
	}
d385 2
a386 7
	/* Then figure out which IRQs use each level. */
	for (level = IPL_NONE; level < IPL_NUM; level++) {
		register int irqs = 0;
		for (irq = 0; irq < ICU_LEN; irq++)
			if (m_intrlevel[irq] & (1 << level))
				irqs |= 1 << irq;
		imask[level] = irqs | SINT_MASK;
a388 19
	/*
	 * There are tty, network and disk drivers that use free() at interrupt
	 * time, so vm > (tty | net | bio).
	 *
	 * Enforce a hierarchy that gives slow devices a better chance at not
	 * dropping data.
	 */
	imask[IPL_NET] |= imask[IPL_BIO];
	imask[IPL_TTY] |= imask[IPL_NET];
	imask[IPL_VM] |= imask[IPL_TTY];
	imask[IPL_CLOCK] |= imask[IPL_VM] | SPL_CLOCK;

	/*
	 * These are pseudo-levels.
	 */
	imask[IPL_NONE] = 0x00000000;
	imask[IPL_HIGH] = 0xffffffff;

	/* And eventually calculate the complete masks. */
d390 9
a398 12
		register int irqs = 1 << irq;
		for (q = m_intrhand[irq]; q; q = q->ih_next)
			irqs |= imask[q->ih_level];
		m_intrmask[irq] = irqs | SINT_MASK;
	}

	/* Lastly, determine which IRQs are actually in use. */
	{
		register int irqs = 0;
		for (irq = 0; irq < ICU_LEN; irq++) {
			if (m_intrhand[irq])
				irqs |= 1 << irq;
a399 9
		imen_m = ~irqs;
		enable_irq(~imen_m);
	}
}
static void
enable_irq(int x)
{
	int state0, state1, v;
	int irq;
d401 1
a401 1
	x &= HWIRQ_MASK;	/* XXX Higher bits are software interrupts. */
d403 6
a408 17
	state0 = state1 = 0;
	while (x) {
		v = 31 - cntlzw(x);
		irq = m_hwirq[v];
		if (irq < 32)
			state0 |= 1 << irq;
		else
			state1 |= 1 << (irq - 32);

		x &= ~(1 << v);
	}

	if (heathrow_FCR)
		out32rb(INT_ENABLE_REG1, state1);

	out32rb(INT_ENABLE_REG0, state0);
}
d410 1
a410 10
int m_virq_inited = 0;

/*
 * Map 64 irqs into 32 (bits).
 */
static int
mapirq(int irq)
{
	int v;
	int i;
d412 10
a421 4
	if (m_virq_inited == 0) {
		m_virq_max = 0;
		for (i = 0; i < ICU_LEN; i++) {
			m_virq[i] = 0;
a422 1
		m_virq_inited = 1;
a424 13
	/* irq in table already? */
	if (m_virq[irq] != 0)
		return m_virq[irq];

	if (irq < 0 || irq >= 64)
		panic("invalid irq %d", irq);
	m_virq_max++;
	v = m_virq_max;
	if (v > HWIRQ_MAX)
		panic("virq overflow");

	m_hwirq[v] = irq;
	m_virq[irq] = v;
d426 3
a428 1
printf("\nmapirq %x to %x\n", irq, v);
a429 15

	return v;
}

/*
 * Count leading zeros.
 */
static __inline int
cntlzw(int x)
{
	int a;

	__asm __volatile ("cntlzw %0,%1" : "=r"(a) : "r"(x));

	return a;
a438 1
	int o_imen, r_imen;
d441 1
a442 1
	volatile unsigned long int_state;
d446 4
a449 17
	int_state = read_irq();
	if (int_state == 0)
		goto out;

start:
	irq = 31 - cntlzw(int_state);

	o_imen = imen_m;
	r_imen = 1 << irq;

	if ((ci->ci_cpl & r_imen) != 0) {
		/* Masked! Mark this as pending. */
		ci->ci_ipending |= r_imen;
		imen_m |= r_imen;
		enable_irq(~imen_m);
	} else {
		splraise(m_intrmask[irq]);
d451 2
a452 2
		ih = m_intrhand[irq];
		while (ih) {
d455 1
a455 1
			ih = ih->ih_next;
d457 2
d461 2
a463 3
	int_state &= ~r_imen;
	if (int_state)
		goto start;
d465 1
a465 1
out:
d470 1
a470 1
mac_intr_do_pending_int()
d473 1
a473 4
	struct intrhand *ih;
	int irq;
	int pcpl;
	int hwpend;
d475 3
a477 2

	if (ci->ci_iactive)
a478 18

	ci->ci_iactive = 1;
	pcpl = splhigh();		/* Turn off all */
	s = ppc_intr_disable();

	hwpend = ci->ci_ipending & ~pcpl;	/* Do now unmasked pendings */
	imen_m &= ~hwpend;
	enable_irq(~imen_m);
	hwpend &= HWIRQ_MASK;
	while (hwpend) {
		irq = 31 - cntlzw(hwpend);
		hwpend &= ~(1L << irq);
		ih = m_intrhand[irq];
		while(ih) {
			if ((*ih->ih_fun)(ih->ih_arg))
				ih->ih_count.ec_count++;
			ih = ih->ih_next;
		}
d480 1
a480 2

	/*out32rb(INT_ENABLE_REG, ~imen_m);*/
d483 10
a492 3
		if((ci->ci_ipending & SINT_CLOCK) & ~pcpl) {
			ci->ci_ipending &= ~SINT_CLOCK;
			softclock();
d494 1
a494 1
		if((ci->ci_ipending & SINT_NET) & ~pcpl) {
d498 1
a498 1
			ci->ci_ipending &= ~SINT_NET;
d501 3
d505 3
d509 1
d511 10
a520 3
		if((ci->ci_ipending & SINT_TTY) & ~pcpl) {
			ci->ci_ipending &= ~SINT_TTY;
			softtty();
d522 3
a524 5
	} while ((ci->ci_ipending & SINT_MASK) & ~pcpl);
	ci->ci_ipending &= pcpl;
	ci->ci_cpl = pcpl;	/* Don't use splx... we are here already! */
	ppc_intr_enable(s);
	ci->ci_iactive = 0;
d527 2
a528 2
static int
read_irq()
d530 1
a530 3
	int rv = 0;
	int state0, state1, p;
	int state0save, state1save;
d532 2
a533 2
	state0 = in32rb(INT_STATE_REG0);
	if (state0)
d535 5
a539 5
	state0save = state0;
	while (state0) {
		p = 31 - cntlzw(state0);
		rv |= 1 << m_virq[p];
		state0 &= ~(1 << p);
d541 10
d557 11
a567 7
	if (state1)
		out32rb(INT_CLEAR_REG1, state1);
	state1save = state1;
	while (state1) {
		p = 31 - cntlzw(state1);
		rv |= 1 << m_virq[p + 32];
		state1 &= ~(1 << p);
d569 1
a569 6
#if 0
printf("mac_intr int_stat 0:%x 1:%x\n", state0save, state1save);
#endif

	/* 1 << 0 is invalid. */
	return rv & ~1;
@


1.34
log
@Redesign of the powerpc interrupt architecture, use true levels intead of
blocking specific interrupts. Needs signficant testing to prove that
one remaining elusive bug has been squashed.
@
text
@a3 1
 * Copyright (c) 2008 Dale Rahn <drahn@@openbsd.org>
d61 14
a74 2
int macintr_ienable_l[IPL_NUM], macintr_ienable_h[IPL_NUM];
int macintr_pri_share[IPL_NUM];
d76 1
a76 6
struct intrq macintr_handler[ICU_LEN];

void macintr_calc_mask(void);
void macintr_eoi(int irq);
int macintr_read_irq(void);
static void macintr_do_pending_int(void);
d78 2
a79 1
extern u_int32_t *heathrow_FCR;
a97 2
void	macintr_collect_preconf_intr(void);
void	macintr_setipl(int ipl);
d143 1
a143 40

ppc_splraise_t macintr_splraise;
ppc_spllower_t macintr_spllower;
ppc_splx_t macintr_splx;


int
macintr_splraise(int newcpl)
{
	struct cpu_info *ci = curcpu();
	newcpl = macintr_pri_share[newcpl];
	int ocpl = ci->ci_cpl;
	if (ocpl > newcpl)
		newcpl = ocpl;

	macintr_setipl(newcpl);

	return ocpl;
}

int
macintr_spllower(int newcpl)
{
	struct cpu_info *ci = curcpu();
	int ocpl = ci->ci_cpl;

	macintr_splx(newcpl);

	return ocpl;
}

void
macintr_splx(int newcpl)
{
	struct cpu_info *ci = curcpu();
	 
	macintr_setipl(newcpl);
	if (ci->ci_ipending & ppc_smask[newcpl])
		macintr_do_pending_int();
}
a147 1
	struct cpu_info *ci = curcpu();
a150 2
	struct intrq *iq;
	int i;
a153 6
	for (i = 0; i < ICU_LEN; i++) {
		iq = &macintr_handler[i];
		TAILQ_INIT(&iq->iq_list);
	}
	ppc_smask_init();

d155 1
a155 1
	pending_int_f = macintr_do_pending_int;
a160 6
	ppc_intr_func.raise = macintr_splraise;
	ppc_intr_func.lower = macintr_spllower;
	ppc_intr_func.x = macintr_splx;

	ci->ci_iactive = 0;

d167 1
d212 2
a213 2
void
macintr_setipl(int ipl)
a214 7
	struct cpu_info *ci = curcpu();
	int s;
	s = ppc_intr_disable();
	ci->ci_cpl = ipl;
	if (heathrow_FCR)
		out32rb(INT_ENABLE_REG1,
		    macintr_ienable_h[macintr_pri_share[ipl]]);
d216 1
a216 2
	out32rb(INT_ENABLE_REG0, macintr_ienable_l[macintr_pri_share[ipl]]);
	ppc_intr_enable(s);
d226 5
a230 4
	struct cpu_info *ci = curcpu();
	struct intrq *iq;
	struct intrhand *ih;
	int s;
d233 6
a238 1
printf("macintr_establish, hI %d L %d %s", irq, level, ppc_intr_typename(type));
d249 1
a249 2
	iq = &macintr_handler[irq];
	switch (iq->iq_ist) {
d251 1
a251 1
		iq->iq_ist = type;
d255 1
a255 1
		if (type == iq->iq_ist)
d260 2
a261 2
			    ppc_intr_typename(iq->iq_ist),
			    ppc_intr_typename(type));
d265 21
d288 1
d291 1
a291 1
	evcount_attach(&ih->ih_count, name, (void *)&ih->ih_irq,
d293 1
a293 11

	/*
	 * Append handler to end of list
	 */
	s = ppc_intr_disable();

	TAILQ_INSERT_TAIL(&iq->iq_list, ih, ih_list);
	macintr_calc_mask();

	macintr_setipl(ci->ci_cpl);
	ppc_intr_enable(s);
a303 1
	struct cpu_info *ci = curcpu();
d306 1
a306 2
	int s;
	struct intrq *iq;
d313 1
d315 6
d322 2
a323 2
	iq = &macintr_handler[irq];
	s = ppc_intr_disable();
d325 1
a325 2
	TAILQ_REMOVE(&iq->iq_list, ih, ih_list);
	macintr_calc_mask();
d327 3
a329 2
	macintr_setipl(ci->ci_cpl);
	ppc_intr_enable(s);
a330 2
	evcount_detach(&ih->ih_count);
	free((void *)ih, M_DEVBUF);
d332 18
a349 2
	if (TAILQ_EMPTY(&iq->iq_list))
		iq->iq_ist = IST_NONE;
a350 1

d357 2
a358 2
void
macintr_calc_mask()
d360 10
a369 3
	int irq;
	struct intrhand *ih;
	int i;
d371 7
a377 2
	for (i = IPL_NONE; i < IPL_NUM; i++) {
		macintr_pri_share[i] = i;
d380 19
d400 12
a411 9
		int maxipl = IPL_NONE;
		int minipl = IPL_HIGH;
		struct intrq *iq = &macintr_handler[irq];

		TAILQ_FOREACH(ih, &iq->iq_list, ih_list) {
			if (ih->ih_level > maxipl)
				maxipl = ih->ih_level;
			if (ih->ih_level < minipl)
				minipl = ih->ih_level;
d413 20
d434 8
a441 1
		iq->iq_ipl = maxipl;
d443 1
a443 6
		if (maxipl == IPL_NONE) {
			minipl = IPL_NONE; /* Interrupt not enabled */
		} else {
			for (i = minipl; i <= maxipl; i++)
				macintr_pri_share[i] = i;
		}
d445 8
a452 1
		/* Enable interrupts at lower levels */
d454 4
a457 10
		if (irq < 32) {
			for (i = IPL_NONE; i < minipl; i++)
				macintr_ienable_l[i] |= (1 << irq);
			for (; i <= IPL_HIGH; i++)
				macintr_ienable_l[i] &= ~(1 << irq);
		} else {
			for (i = IPL_NONE; i < minipl; i++)
				macintr_ienable_h[i] |= (1 << (irq-32));
			for (; i <= IPL_HIGH; i++)
				macintr_ienable_h[i] &= ~(1 << (irq-32));
d459 1
d462 13
d476 1
a476 3
	for (i = 0; i < IPL_NUM; i++)
		printf("imask[%d] %x %x\n", i, macintr_ienable_l[i],
		    macintr_ienable_h[i]);
d478 15
d502 1
a504 1
	struct intrq *iq;
d506 1
d510 17
a526 4
	irq = macintr_read_irq();
	while (irq != 255) {
		iq = &macintr_handler[irq];
		macintr_setipl(iq->iq_ipl);
d528 2
a529 2
		TAILQ_FOREACH(ih, &iq->iq_list, ih_list) {
			ppc_intr_enable(1);
d532 1
a532 1
			(void)ppc_intr_disable();
a533 2
		macintr_eoi(irq);
		macintr_setipl(pcpl);
a535 2

		irq = macintr_read_irq();
d537 3
d541 1
a541 1
	ppc_intr_enable(1);
d546 1
a546 1
macintr_do_pending_int()
d549 11
a559 2
	int pcpl = ci->ci_cpl; /* XXX */
	int s, s2;
d561 14
a574 3
	if (ci->ci_iactive & CI_IACTIVE_PROCESSING_SOFT) {
		ppc_intr_enable(s);
		return;
d576 2
a577 1
	atomic_setbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_SOFT);
d580 3
a582 11
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTTTY)) &&  (pcpl < IPL_SOFTTTY)) {
			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTTTY);
			s2 = ci->ci_cpl;
			ci->ci_cpl = IPL_SOFTTTY;
			ppc_intr_enable(1);
			KERNEL_LOCK();
			softtty();
			KERNEL_UNLOCK();
			ppc_intr_disable();
			ci->ci_cpl = pcpl;
			continue;
d584 1
a584 1
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTNET)) &&  (pcpl < IPL_SOFTNET)) {
d588 1
a588 1
			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTNET);
a590 3
				ci->ci_cpl = IPL_SOFTNET;
				ppc_intr_enable(1);
				KERNEL_LOCK();
a591 3
				KERNEL_UNLOCK();
				ppc_intr_disable();
				ci->ci_cpl = pcpl;
a592 1
			continue;
d594 3
a596 10
		if((ci->ci_ipending & SI_TO_IRQBIT(SI_SOFTCLOCK)) && (pcpl < IPL_SOFTCLOCK)) {
			ci->ci_ipending &= ~SI_TO_IRQBIT(SI_SOFTCLOCK);
			ci->ci_cpl = IPL_SOFTCLOCK;
			ppc_intr_enable(1);
			KERNEL_LOCK();
			softclock();
			KERNEL_UNLOCK();
			ppc_intr_disable();
			ci->ci_cpl = pcpl;
			continue;
d598 5
a602 3
	} while (ci->ci_ipending & ppc_smask[pcpl]);
	macintr_setipl(pcpl);
	atomic_clearbits_int(&ci->ci_iactive, CI_IACTIVE_PROCESSING_SOFT);
d605 2
a606 2
void
macintr_eoi(int irq)
d608 3
a610 1
	u_int32_t state0, state1;
d612 2
a613 2
	if (irq < 32) {
		state0 =  1 << irq;
d615 5
a619 5
	} else {
		if (heathrow_FCR) {		/* has heathrow? */
			state1 = 1 << (irq - 32);
			out32rb(INT_CLEAR_REG1, state1);
		}
a620 10
}

int
macintr_read_irq()
{
	struct cpu_info *ci = curcpu();
	u_int32_t state0, state1, irq_mask;
	int ipl, irq;

	state0 = in32rb(INT_STATE_REG0);
d627 7
a633 11
	for (ipl = IPL_HIGH; ipl >= ci->ci_cpl; ipl --) {
		irq_mask = state0 & macintr_ienable_l[ipl];
		if (irq_mask) {
			irq = ffs(irq_mask) - 1;
			return irq;
		}
		irq_mask = state1 & macintr_ienable_h[ipl];
		if (irq_mask) {
			irq = ffs(irq_mask) + 31;
			return irq;
		}
d635 6
a640 1
	return 255;
@


1.33
log
@Use atomic operations to operate on netisr, instead of clearing it at splhigh.
This changes nothing on legacy architectures, but is a bit faster (and simpler)
on the interesting ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.32 2007/03/20 20:59:53 kettenis Exp $	*/
d4 1
d62 9
a70 14
int m_intrtype[ICU_LEN], m_intrmask[ICU_LEN], m_intrlevel[ICU_LEN];
struct intrhand *m_intrhand[ICU_LEN];
int m_hwirq[ICU_LEN], m_virq[64];
unsigned int imen_m = 0xffffffff;
int m_virq_max = 0;

static int fakeintr(void *);
static char *intr_typename(int type);
static void intr_calculatemasks(void);
static void enable_irq(int x);
static __inline int cntlzw(int x);
static int mapirq(int irq);
static int read_irq(void);
static void mac_intr_do_pending_int(void);
a73 3
#define HWIRQ_MAX 27
#define HWIRQ_MASK 0x0fffffff

d91 2
d138 40
a177 1
void macintr_collect_preconf_intr(void);
d182 1
d186 2
d191 6
d198 1
a198 1
	pending_int_f = mac_intr_do_pending_int;
d204 6
a215 1

d260 2
a261 2
static int
fakeintr(void *arg)
d263 7
d271 2
a272 1
	return 0;
d282 4
a285 5
	struct intrhand **p, *q, *ih;
	static struct intrhand fakehand;

	fakehand.ih_next = NULL;
	fakehand.ih_fun  = fakeintr;
d288 1
a288 6
printf("macintr_establish, hI %d L %d ", irq, type);
printf("addr reg0 %x\n", INT_STATE_REG0);
#endif
	irq = mapirq(irq);
#if 0
printf("vI %d ", irq);
d299 2
a300 1
	switch (m_intrtype[irq]) {
d302 1
a302 1
		m_intrtype[irq] = type;
d306 1
a306 1
		if (type == m_intrtype[irq])
d311 2
a312 2
			    intr_typename(m_intrtype[irq]),
			    intr_typename(type));
d316 6
a321 7
	/*
	 * Figure out where to put the handler.
	 * This is O(N^2), but we want to preserve the order, and N is
	 * generally small.
	 */
	for (p = &m_intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
		;
d324 1
a324 3
	 * Actually install a fake handler momentarily, since we might be doing
	 * this with interrupts enabled and DON'T WANt the real routine called
	 * until masking is set up.
d326 1
a326 2
	fakehand.ih_level = level;
	*p = &fakehand;
d328 2
a329 1
	intr_calculatemasks();
d331 2
a332 11
	/*
	 * Poke the real handler in now.
	 */
	ih->ih_fun = ih_fun;
	ih->ih_arg = ih_arg;
	ih->ih_next = NULL;
	ih->ih_level = level;
	ih->ih_irq = irq;
	evcount_attach(&ih->ih_count, name, (void *)&m_hwirq[irq],
	    &evcount_intr);
	*p = ih;
d343 1
d346 2
a347 1
	struct intrhand **p, *q;
a353 1
	 * This is O(n^2), too.
d355 9
a363 6
	for (p = &m_intrhand[irq]; (q = *p) != NULL && q != ih; p = &q->ih_next)
		;
	if (q)
		*p = q->ih_next;
	else
		panic("intr_disestablish: handler not registered");
d368 2
a369 4
	intr_calculatemasks();

	if (m_intrhand[irq] == NULL)
		m_intrtype[irq] = IST_NONE;
a371 20

static char *
intr_typename(int type)
{
	switch (type) {
        case IST_NONE :
		return ("none");
        case IST_PULSE:
		return ("pulsed");
        case IST_EDGE:
		return ("edge-triggered");
        case IST_LEVEL:
		return ("level-triggered");
	default:
		panic("intr_typename: invalid type %d", type);
#if 1 /* XXX */
		return ("unknown");
#endif
	}
}
d378 2
a379 2
static void
intr_calculatemasks()
d381 3
a383 10
	int irq, level;
	struct intrhand *q;

	/* First, figure out which levels each IRQ uses. */
	for (irq = 0; irq < ICU_LEN; irq++) {
		register int levels = 0;
		for (q = m_intrhand[irq]; q; q = q->ih_next)
			levels |= 1 << q->ih_level;
		m_intrlevel[irq] = levels;
	}
d385 2
a386 7
	/* Then figure out which IRQs use each level. */
	for (level = IPL_NONE; level < IPL_NUM; level++) {
		register int irqs = 0;
		for (irq = 0; irq < ICU_LEN; irq++)
			if (m_intrlevel[irq] & (1 << level))
				irqs |= 1 << irq;
		imask[level] = irqs | SINT_MASK;
a388 19
	/*
	 * There are tty, network and disk drivers that use free() at interrupt
	 * time, so vm > (tty | net | bio).
	 *
	 * Enforce a hierarchy that gives slow devices a better chance at not
	 * dropping data.
	 */
	imask[IPL_NET] |= imask[IPL_BIO];
	imask[IPL_TTY] |= imask[IPL_NET];
	imask[IPL_VM] |= imask[IPL_TTY];
	imask[IPL_CLOCK] |= imask[IPL_VM] | SPL_CLOCK;

	/*
	 * These are pseudo-levels.
	 */
	imask[IPL_NONE] = 0x00000000;
	imask[IPL_HIGH] = 0xffffffff;

	/* And eventually calculate the complete masks. */
d390 9
a398 12
		register int irqs = 1 << irq;
		for (q = m_intrhand[irq]; q; q = q->ih_next)
			irqs |= imask[q->ih_level];
		m_intrmask[irq] = irqs | SINT_MASK;
	}

	/* Lastly, determine which IRQs are actually in use. */
	{
		register int irqs = 0;
		for (irq = 0; irq < ICU_LEN; irq++) {
			if (m_intrhand[irq])
				irqs |= 1 << irq;
a399 9
		imen_m = ~irqs;
		enable_irq(~imen_m);
	}
}
static void
enable_irq(int x)
{
	int state0, state1, v;
	int irq;
d401 1
a401 1
	x &= HWIRQ_MASK;	/* XXX Higher bits are software interrupts. */
d403 6
a408 17
	state0 = state1 = 0;
	while (x) {
		v = 31 - cntlzw(x);
		irq = m_hwirq[v];
		if (irq < 32)
			state0 |= 1 << irq;
		else
			state1 |= 1 << (irq - 32);

		x &= ~(1 << v);
	}

	if (heathrow_FCR)
		out32rb(INT_ENABLE_REG1, state1);

	out32rb(INT_ENABLE_REG0, state0);
}
d410 1
a410 10
int m_virq_inited = 0;

/*
 * Map 64 irqs into 32 (bits).
 */
static int
mapirq(int irq)
{
	int v;
	int i;
d412 10
a421 4
	if (m_virq_inited == 0) {
		m_virq_max = 0;
		for (i = 0; i < ICU_LEN; i++) {
			m_virq[i] = 0;
a422 1
		m_virq_inited = 1;
a424 13
	/* irq in table already? */
	if (m_virq[irq] != 0)
		return m_virq[irq];

	if (irq < 0 || irq >= 64)
		panic("invalid irq %d", irq);
	m_virq_max++;
	v = m_virq_max;
	if (v > HWIRQ_MAX)
		panic("virq overflow");

	m_hwirq[v] = irq;
	m_virq[irq] = v;
d426 3
a428 1
printf("\nmapirq %x to %x\n", irq, v);
a429 15

	return v;
}

/*
 * Count leading zeros.
 */
static __inline int
cntlzw(int x)
{
	int a;

	__asm __volatile ("cntlzw %0,%1" : "=r"(a) : "r"(x));

	return a;
a438 1
	int o_imen, r_imen;
d441 1
a442 1
	volatile unsigned long int_state;
d446 4
a449 17
	int_state = read_irq();
	if (int_state == 0)
		goto out;

start:
	irq = 31 - cntlzw(int_state);

	o_imen = imen_m;
	r_imen = 1 << irq;

	if ((ci->ci_cpl & r_imen) != 0) {
		/* Masked! Mark this as pending. */
		ci->ci_ipending |= r_imen;
		imen_m |= r_imen;
		enable_irq(~imen_m);
	} else {
		splraise(m_intrmask[irq]);
d451 2
a452 2
		ih = m_intrhand[irq];
		while (ih) {
d455 1
a455 1
			ih = ih->ih_next;
d457 2
d461 2
a463 3
	int_state &= ~r_imen;
	if (int_state)
		goto start;
d465 1
a465 1
out:
d470 1
a470 1
mac_intr_do_pending_int()
d473 5
a477 7
	struct intrhand *ih;
	int irq;
	int pcpl;
	int hwpend;
	int s;

	if (ci->ci_iactive)
a478 18

	ci->ci_iactive = 1;
	pcpl = splhigh();		/* Turn off all */
	s = ppc_intr_disable();

	hwpend = ci->ci_ipending & ~pcpl;	/* Do now unmasked pendings */
	imen_m &= ~hwpend;
	enable_irq(~imen_m);
	hwpend &= HWIRQ_MASK;
	while (hwpend) {
		irq = 31 - cntlzw(hwpend);
		hwpend &= ~(1L << irq);
		ih = m_intrhand[irq];
		while(ih) {
			if ((*ih->ih_fun)(ih->ih_arg))
				ih->ih_count.ec_count++;
			ih = ih->ih_next;
		}
d480 1
a480 2

	/*out32rb(INT_ENABLE_REG, ~imen_m);*/
d483 11
a493 3
		if((ci->ci_ipending & SINT_CLOCK) & ~pcpl) {
			ci->ci_ipending &= ~SINT_CLOCK;
			softclock();
d495 1
a495 1
		if((ci->ci_ipending & SINT_NET) & ~pcpl) {
d499 1
a499 1
			ci->ci_ipending &= ~SINT_NET;
d502 3
d506 3
d510 1
d512 10
a521 3
		if((ci->ci_ipending & SINT_TTY) & ~pcpl) {
			ci->ci_ipending &= ~SINT_TTY;
			softtty();
d523 3
a525 5
	} while ((ci->ci_ipending & SINT_MASK) & ~pcpl);
	ci->ci_ipending &= pcpl;
	ci->ci_cpl = pcpl;	/* Don't use splx... we are here already! */
	ppc_intr_enable(s);
	ci->ci_iactive = 0;
d528 2
a529 2
static int
read_irq()
d531 1
a531 3
	int rv = 0;
	int state0, state1, p;
	int state0save, state1save;
d533 2
a534 2
	state0 = in32rb(INT_STATE_REG0);
	if (state0)
d536 5
a540 5
	state0save = state0;
	while (state0) {
		p = 31 - cntlzw(state0);
		rv |= 1 << m_virq[p];
		state0 &= ~(1 << p);
d542 10
d558 11
a568 7
	if (state1)
		out32rb(INT_CLEAR_REG1, state1);
	state1save = state1;
	while (state1) {
		p = 31 - cntlzw(state1);
		rv |= 1 << m_virq[p + 32];
		state1 &= ~(1 << p);
d570 1
a570 6
#if 0
printf("mac_intr int_stat 0:%x 1:%x\n", state0save, state1save);
#endif

	/* 1 << 0 is invalid. */
	return rv & ~1;
@


1.32
log
@Move macppc to __HAVE_CPUINFO, and make locore.S and trap.c suitable for
MULTIPROCESSOR.  From now on sprg0 holds a pointer to struct cpuinfo, which
is used to spill registers to during trap instead of the globals we used to
use for that purpose.  Bits and pieces from NetBSD.  Help from drahn@@ and art@@.
Tested by xsa@@, thib@@, miod@@, gwk@@, deraadt@@.

ok drahn@@, gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.31 2007/03/01 15:00:57 mickey Exp $	*/
d49 1
d586 2
a587 2
			int pisr = netisr;
			netisr = 0;
d589 4
a592 1
			softnet(pisr);
@


1.31
log
@proper softint treatment (that get missed otherwise); found and tested by mpf@@ on pppoe; drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.30 2006/03/12 02:49:50 brad Exp $	*/
d503 1
d507 1
a507 1
	pcpl = cpl;	/* Turn off all */
d519 3
a521 2
	if ((cpl & r_imen) != 0) {
		ipending |= r_imen;	/* Masked! Mark this as pending */
d547 1
a552 1
	static int processing;
d554 1
a554 1
	if (processing)
d557 1
a557 1
	processing = 1;
d561 1
a561 1
	hwpend = ipending & ~pcpl;	/* Do now unmasked pendings */
d579 2
a580 2
		if((ipending & SINT_CLOCK) & ~pcpl) {
			ipending &= ~SINT_CLOCK;
d583 1
a583 1
		if((ipending & SINT_NET) & ~pcpl) {
d587 1
a587 1
			ipending &= ~SINT_NET;
d590 2
a591 2
		if((ipending & SINT_TTY) & ~pcpl) {
			ipending &= ~SINT_TTY;
d594 3
a596 3
	} while (ipending & (SINT_NET|SINT_CLOCK|SINT_TTY) & ~pcpl);
	ipending &= pcpl;
	cpl = pcpl;	/* Don't use splx... we are here already! */
d598 1
a598 1
	processing = 0;
@


1.30
log
@IPL_IMP -> IPL_VM

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.29 2005/10/16 04:30:43 drahn Exp $	*/
d592 1
a592 1
	} while (ipending & (SINT_NET|SINT_CLOCK|SINT_TTY) & ~cpl);
@


1.29
log
@print the hardware irq number, not the bogus internal number for 'vmstat -i'
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.28 2005/09/30 19:51:52 deraadt Exp $	*/
d381 1
a381 1
	 * time, so imp > (tty | net | bio).
d388 2
a389 2
	imask[IPL_IMP] |= imask[IPL_TTY];
	imask[IPL_CLOCK] |= imask[IPL_IMP] | SPL_CLOCK;
@


1.28
log
@i hate panic messages which do not print the value that was in error
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.27 2005/03/11 13:35:47 miod Exp $	*/
d290 2
a291 1
	evcount_attach(&ih->ih_count, name, (void *)&ih->ih_irq, &evcount_intr);
@


1.27
log
@Only print preconfigured interrupt table if option DEBUG, as done for openpic.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.26 2005/02/16 14:37:06 aaron Exp $	*/
d465 1
a465 1
		panic("invalid irq");
@


1.26
log
@Fix indentation to match similar code block below.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.25 2004/10/01 20:28:42 miod Exp $	*/
d175 1
d183 1
@


1.25
log
@Sync with openpic.c evcount fixes; ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.24 2004/06/28 02:49:43 deraadt Exp $	*/
d606 1
a606 1
		state0save = state0;
@


1.24
log
@shorten name
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.23 2004/06/28 02:49:10 aaron Exp $	*/
a65 2
struct evcnt m_evirq[ICU_LEN*2];

a529 1
		m_evirq[m_hwirq[irq]].ev_count++;
d565 2
a566 1
			(*ih->ih_fun)(ih->ih_arg);
a568 2

		m_evirq[m_hwirq[irq]].ev_count++;
@


1.23
log
@Use new event counter API for interrupt counting on macppc.  drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.22 2003/12/20 22:40:26 miod Exp $	*/
d165 1
a165 1
	    macintr_prog_button, (void *)0x14, "prog button");
@


1.22
log
@Pass -Wformat
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.21 2003/10/19 21:57:35 drahn Exp $	*/
a217 2
void nameinterrupt( int replace, char *newstr);

a234 1
	nameinterrupt(irq, name);
a286 1
	ih->ih_count = 0;
d290 1
d319 2
a512 1
	intrcnt[m_hwirq[irq]]++;
d526 2
a527 1
			(*ih->ih_fun)(ih->ih_arg);
@


1.21
log
@Use defines instead of magic constants for more IPL_ stuff, also sort
the IPL_ values by priority, not somewhat random values. No unmodified
code relied on the order of these defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.20 2003/10/16 03:54:48 deraadt Exp $	*/
d177 1
a177 1
		printf("\n\t%s irq %d level %d fun %x arg %x",
@


1.20
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.19 2003/10/16 03:31:25 drahn Exp $	*/
d371 1
a371 1
	for (level = 0; level < 5; level++) {
@


1.19
log
@more ANSI/KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.18 2003/07/02 21:30:13 drahn Exp $	*/
d100 1
a100 1
struct cfattach macintr_ca = { 
@


1.18
log
@Reduce the amount of asm code in powerpc/macppc by replacing it with
inlined functions, helps improve readability and fix a couple of bugs.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.17 2003/06/02 23:27:49 millert Exp $	*/
d111 1
a111 4
macintr_match(parent, cf, aux) 
	struct device *parent;
	void *cf;
	void *aux;
d121 1
a121 1
		if (strcmp(type,  "interrupt-controller") == 0) {
a122 1
		}
d130 1
a130 1
	if (strcmp(ca->ca_name, "legacy-interrupt-controller") == 0 ) {
a131 1
	}
d147 1
a147 3
macintr_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d165 1
a165 1
		macintr_prog_button, (void *)0x14, "prog button");
d171 1
d212 1
a212 2
fakeintr(arg)
	void *arg;
d224 2
a225 8
macintr_establish(lcv, irq, type, level, ih_fun, ih_arg, name)
	void * lcv;
	int irq;
	int type;
	int level;
	int (*ih_fun)(void *);
	void *ih_arg;
	char *name;
d303 1
a303 3
macintr_disestablish(lcp, arg)
	void *lcp;
	void *arg;
d332 1
a332 2
intr_typename(type)
	int type;
a333 1

d417 1
a417 2
enable_irq(x)
	int x;
d428 1
a428 1
		if (irq < 32) {
d430 1
a430 1
		} else {
d432 1
a432 1
		}
d436 1
a436 1
	if (heathrow_FCR) {
d438 1
a438 1
	}
d448 1
a448 2
mapirq(irq)
	int irq;
d462 1
a462 1
	if (m_virq[irq] != 0) {
a463 1
	}
d485 1
a485 2
cntlzw(x)
	int x;
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.16 2003/02/12 22:40:59 jason Exp $	*/
d571 1
a571 1
	int emsr, dmsr;
d579 1
a579 3
	asm volatile("mfmsr %0" : "=r"(emsr));
	dmsr = emsr & ~PSL_EE;
	asm volatile("mtmsr %0" :: "r"(dmsr));
d618 1
a618 1
	asm volatile("mtmsr %0" :: "r"(emsr));
@


1.16
log
@separate evirq into macintr and openpic versions (they just -happened- to be
the same size).  ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.15 2002/09/15 09:01:58 deraadt Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.15
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.13 2002/03/14 01:26:36 millert Exp $	*/
d70 1
a70 1
struct evcnt evirq[ICU_LEN*2];
d558 1
a558 1
		evirq[m_hwirq[irq]].ev_count++;
d600 1
a600 1
		evirq[m_hwirq[irq]].ev_count++;
@


1.14
log
@KNF
@
text
@d104 1
a104 1
struct cfattach macintr_ca = {
d115 1
a115 1
macintr_match(parent, cf, aux)
d128 1
a128 1
		if (strcmp(type, "interrupt-controller") == 0) {
d356 1
a356 1
	case IST_NONE :
d358 1
a358 1
	case IST_PULSE:
d360 1
a360 1
	case IST_EDGE:
d362 1
a362 1
	case IST_LEVEL:
d595 1
a595 1
		while (ih) {
d606 1
a606 1
		if ((ipending & SINT_CLOCK) & ~pcpl) {
d610 1
a610 1
		if ((ipending & SINT_NET) & ~pcpl) {
d617 1
a617 1
		if ((ipending & SINT_TTY) & ~pcpl) {
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.12 2002/03/08 20:33:43 drahn Exp $	*/
d104 1
a104 1
struct cfattach macintr_ca = { 
d115 1
a115 1
macintr_match(parent, cf, aux) 
d128 1
a128 1
		if (strcmp(type,  "interrupt-controller") == 0) {
d356 1
a356 1
        case IST_NONE :
d358 1
a358 1
        case IST_PULSE:
d360 1
a360 1
        case IST_EDGE:
d362 1
a362 1
        case IST_LEVEL:
d595 1
a595 1
		while(ih) {
d606 1
a606 1
		if((ipending & SINT_CLOCK) & ~pcpl) {
d610 1
a610 1
		if((ipending & SINT_NET) & ~pcpl) {
d617 1
a617 1
		if((ipending & SINT_TTY) & ~pcpl) {
@


1.12
log
@Remove the code which reenables interrupts in these interrupt controllers,
they do not appear to be capable of handling all possible nested interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.12 2002/03/08 20:20:03 drahn Exp $	*/
d72 8
a79 8
static int fakeintr __P((void *));
static char *intr_typename __P((int type));
static void intr_calculatemasks __P((void));
static void enable_irq __P((int x));
static __inline int cntlzw __P((int x));
static int mapirq __P((int irq));
static int read_irq __P((void));
static void mac_intr_do_pending_int __P((void));
d99 4
a102 4
int	macintr_match __P((struct device *parent, void *cf, void *aux));
void	macintr_attach __P((struct device *, struct device *, void *));
void	mac_do_pending_int __P((void));
void	mac_ext_intr __P((void));
d153 1
a153 1
void macintr_collect_preconf_intr __P((void));
d240 1
a240 1
	int (*ih_fun) __P((void *));
@


1.11
log
@If two drivers register the same hardware irq, they should get
the same virtual irq as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.10 2002/03/02 17:17:37 drahn Exp $	*/
a550 5
		/*
		 * enable interrupts for the duration of the
		 * interrupt handler 
		 */
		ppc_intr_enable(1);
a555 1
		ppc_intr_disable();
a564 1
	ppc_intr_enable(1);
a565 1
	ppc_intr_disable();
@


1.10
log
@These two drivers were incorrectly sharing variables, sometimes expecting
them to be intialized by the other. also remove static variables
and rename them so they are accessable via ddb.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.9 2002/01/26 15:22:52 drahn Exp $	*/
d463 3
d474 14
@


1.9
log
@splclock() should block SPL_BIO - SPL_IMP.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.8 2002/01/21 05:11:29 drahn Exp $	*/
d64 5
a68 5
static int intrtype[ICU_LEN], intrmask[ICU_LEN], intrlevel[ICU_LEN];
static struct intrhand *intrhand[ICU_LEN];
static int hwirq[ICU_LEN], virq[64];
unsigned int imen = 0xffffffff;
int virq_max = 0;
d268 1
a268 1
	switch (intrtype[irq]) {
d270 1
a270 1
		intrtype[irq] = type;
d274 1
a274 1
		if (type == intrtype[irq])
d279 1
a279 1
			    intr_typename(intrtype[irq]),
d289 1
a289 1
	for (p = &intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
d335 1
a335 1
	for (p = &intrhand[irq]; (q = *p) != NULL && q != ih; p = &q->ih_next)
d345 2
a346 2
	if (intrhand[irq] == NULL)
		intrtype[irq] = IST_NONE;
d386 1
a386 1
		for (q = intrhand[irq]; q; q = q->ih_next)
d388 1
a388 1
		intrlevel[irq] = levels;
d395 1
a395 1
			if (intrlevel[irq] & (1 << level))
d421 1
a421 1
		for (q = intrhand[irq]; q; q = q->ih_next)
d423 1
a423 1
		intrmask[irq] = irqs | SINT_MASK;
d430 1
a430 1
			if (intrhand[irq])
d433 2
a434 2
		imen = ~irqs;
		enable_irq(~imen);
d449 1
a449 1
		irq = hwirq[v];
d474 2
a475 2
	virq_max++;
	v = virq_max;
d479 2
a480 2
	hwirq[v] = irq;
	virq[irq] = v;
d522 1
a522 1
	intrcnt[hwirq[irq]]++;
d524 1
a524 1
	o_imen = imen;
d529 2
a530 2
		imen |= r_imen;
		enable_irq(~imen);
d532 1
a532 1
		splraise(intrmask[irq]);
d539 1
a539 1
		ih = intrhand[irq];
d547 1
a547 1
		evirq[hwirq[irq]].ev_count++;
d579 2
a580 2
	imen &= ~hwpend;
	enable_irq(~imen);
d585 1
a585 1
		ih = intrhand[irq];
d591 1
a591 1
		evirq[hwirq[irq]].ev_count++;
d594 1
a594 1
	/*out32rb(INT_ENABLE_REG, ~imen);*/
d632 1
a632 1
		rv |= 1 << virq[p];
d646 1
a646 1
		rv |= 1 << virq[p + 32];
@


1.8
log
@Respect db_console for "progammer button", for improved physical security.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.7 2002/01/17 16:17:23 drahn Exp $	*/
d403 1
a403 4
	 */
	imask[IPL_IMP] |= imask[IPL_TTY] | imask[IPL_NET] | imask[IPL_BIO];

	/*
a406 1
	imask[IPL_TTY] |= imask[IPL_NET] | imask[IPL_BIO];
d408 3
@


1.7
log
@Allow nested interrupts on the mac interrupt controllers, previously
the external interrupt was never enabled during interrupt handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.6 2001/11/06 19:53:15 miod Exp $	*/
d51 1
d213 2
a214 1
        Debugger();
@


1.6
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.5 2001/10/03 14:07:05 drahn Exp $	*/
d513 1
a513 1
	pcpl = splhigh();	/* Turn off all */
a514 3
#if 0
printf("mac_intr \n");
#endif
d526 1
a526 1
	if ((pcpl & r_imen) != 0) {
d531 7
a539 3
#if 0
printf("calling handler %x\n", ih->ih_fun);
#endif
d543 1
d553 1
d555 1
@


1.6.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.9 2002/01/26 15:22:52 drahn Exp $	*/
a50 1
#include <ddb/db_var.h>
d212 1
a212 2
	if (db_console)
		Debugger();
d401 4
a404 1
	 *
d408 1
a409 3
	imask[IPL_TTY] |= imask[IPL_NET];
	imask[IPL_IMP] |= imask[IPL_TTY];
	imask[IPL_CLOCK] |= imask[IPL_IMP] | SPL_CLOCK;
d513 1
a513 1
	pcpl = cpl;	/* Turn off all */
d515 3
d529 1
a529 1
	if ((cpl & r_imen) != 0) {
a533 7
		splraise(intrmask[irq]);

		/*
		 * enable interrupts for the duration of the
		 * interrupt handler 
		 */
		ppc_intr_enable(1);
d536 3
a541 1
		ppc_intr_disable();
a550 1
	ppc_intr_enable(1);
a551 1
	ppc_intr_disable();
@


1.6.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.6.2.1 2002/01/31 22:55:14 niklas Exp $	*/
d64 5
a68 5
int m_intrtype[ICU_LEN], m_intrmask[ICU_LEN], m_intrlevel[ICU_LEN];
struct intrhand *m_intrhand[ICU_LEN];
int m_hwirq[ICU_LEN], m_virq[64];
unsigned int imen_m = 0xffffffff;
int m_virq_max = 0;
d72 8
a79 8
static int fakeintr(void *);
static char *intr_typename(int type);
static void intr_calculatemasks(void);
static void enable_irq(int x);
static __inline int cntlzw(int x);
static int mapirq(int irq);
static int read_irq(void);
static void mac_intr_do_pending_int(void);
d99 4
a102 4
int	macintr_match(struct device *parent, void *cf, void *aux);
void	macintr_attach(struct device *, struct device *, void *);
void	mac_do_pending_int(void);
void	mac_ext_intr(void);
d153 1
a153 1
void macintr_collect_preconf_intr(void);
d240 1
a240 1
	int (*ih_fun)(void *);
d268 1
a268 1
	switch (m_intrtype[irq]) {
d270 1
a270 1
		m_intrtype[irq] = type;
d274 1
a274 1
		if (type == m_intrtype[irq])
d279 1
a279 1
			    intr_typename(m_intrtype[irq]),
d289 1
a289 1
	for (p = &m_intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
d335 1
a335 1
	for (p = &m_intrhand[irq]; (q = *p) != NULL && q != ih; p = &q->ih_next)
d345 2
a346 2
	if (m_intrhand[irq] == NULL)
		m_intrtype[irq] = IST_NONE;
d386 1
a386 1
		for (q = m_intrhand[irq]; q; q = q->ih_next)
d388 1
a388 1
		m_intrlevel[irq] = levels;
d395 1
a395 1
			if (m_intrlevel[irq] & (1 << level))
d421 1
a421 1
		for (q = m_intrhand[irq]; q; q = q->ih_next)
d423 1
a423 1
		m_intrmask[irq] = irqs | SINT_MASK;
d430 1
a430 1
			if (m_intrhand[irq])
d433 2
a434 2
		imen_m = ~irqs;
		enable_irq(~imen_m);
d449 1
a449 1
		irq = m_hwirq[v];
a462 3

int m_virq_inited = 0;

a470 14
	int i;

	if (m_virq_inited == 0) {
		m_virq_max = 0;
		for (i = 0; i < ICU_LEN; i++) {
			m_virq[i] = 0;
		}
		m_virq_inited = 1;
	}

	/* irq in table already? */
	if (m_virq[irq] != 0) {
		return m_virq[irq];
	}
d474 2
a475 2
	m_virq_max++;
	v = m_virq_max;
d479 2
a480 2
	m_hwirq[v] = irq;
	m_virq[irq] = v;
d522 1
a522 1
	intrcnt[m_hwirq[irq]]++;
d524 1
a524 1
	o_imen = imen_m;
d529 2
a530 2
		imen_m |= r_imen;
		enable_irq(~imen_m);
d532 1
a532 1
		splraise(m_intrmask[irq]);
d534 6
a539 1
		ih = m_intrhand[irq];
d544 1
d547 1
a547 1
		evirq[m_hwirq[irq]].ev_count++;
d554 1
d556 1
d579 2
a580 2
	imen_m &= ~hwpend;
	enable_irq(~imen_m);
d585 1
a585 1
		ih = m_intrhand[irq];
d591 1
a591 1
		evirq[m_hwirq[irq]].ev_count++;
d594 1
a594 1
	/*out32rb(INT_ENABLE_REG, ~imen_m);*/
d632 1
a632 1
		rv |= 1 << m_virq[p];
d646 1
a646 1
		rv |= 1 << m_virq[p + 32];
@


1.6.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.6.2.2 2002/06/11 03:36:33 art Exp $	*/
@


1.6.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 1
a70 1
struct evcnt m_evirq[ICU_LEN*2];
d558 1
a558 1
		m_evirq[m_hwirq[irq]].ev_count++;
d600 1
a600 1
		m_evirq[m_hwirq[irq]].ev_count++;
@


1.5
log
@Cleanup improperly shared code between the two interrupt drivers.
Pointed out by a7r.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.4 2001/09/28 04:13:12 drahn Exp $	*/
a49 1
#include <vm/vm.h>
@


1.5.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.5.4.2
log
@Merge in -current
@
text
@d50 1
@


1.5.4.3
log
@Merge in trunk
@
text
@a50 1
#include <ddb/db_var.h>
d63 5
a67 5
int m_intrtype[ICU_LEN], m_intrmask[ICU_LEN], m_intrlevel[ICU_LEN];
struct intrhand *m_intrhand[ICU_LEN];
int m_hwirq[ICU_LEN], m_virq[64];
unsigned int imen_m = 0xffffffff;
int m_virq_max = 0;
d212 1
a212 2
	if (db_console)
		Debugger();
d266 1
a266 1
	switch (m_intrtype[irq]) {
d268 1
a268 1
		m_intrtype[irq] = type;
d272 1
a272 1
		if (type == m_intrtype[irq])
d277 1
a277 1
			    intr_typename(m_intrtype[irq]),
d287 1
a287 1
	for (p = &m_intrhand[irq]; (q = *p) != NULL; p = &q->ih_next)
d333 1
a333 1
	for (p = &m_intrhand[irq]; (q = *p) != NULL && q != ih; p = &q->ih_next)
d343 2
a344 2
	if (m_intrhand[irq] == NULL)
		m_intrtype[irq] = IST_NONE;
d384 1
a384 1
		for (q = m_intrhand[irq]; q; q = q->ih_next)
d386 1
a386 1
		m_intrlevel[irq] = levels;
d393 1
a393 1
			if (m_intrlevel[irq] & (1 << level))
d401 4
a404 1
	 *
d408 1
a409 3
	imask[IPL_TTY] |= imask[IPL_NET];
	imask[IPL_IMP] |= imask[IPL_TTY];
	imask[IPL_CLOCK] |= imask[IPL_IMP] | SPL_CLOCK;
d420 1
a420 1
		for (q = m_intrhand[irq]; q; q = q->ih_next)
d422 1
a422 1
		m_intrmask[irq] = irqs | SINT_MASK;
d429 1
a429 1
			if (m_intrhand[irq])
d432 2
a433 2
		imen_m = ~irqs;
		enable_irq(~imen_m);
d448 1
a448 1
		irq = m_hwirq[v];
a461 3

int m_virq_inited = 0;

a469 14
	int i;

	if (m_virq_inited == 0) {
		m_virq_max = 0;
		for (i = 0; i < ICU_LEN; i++) {
			m_virq[i] = 0;
		}
		m_virq_inited = 1;
	}

	/* irq in table already? */
	if (m_virq[irq] != 0) {
		return m_virq[irq];
	}
d473 2
a474 2
	m_virq_max++;
	v = m_virq_max;
d478 2
a479 2
	m_hwirq[v] = irq;
	m_virq[irq] = v;
d513 1
a513 1
	pcpl = cpl;	/* Turn off all */
d515 3
d524 1
a524 1
	intrcnt[m_hwirq[irq]]++;
d526 1
a526 1
	o_imen = imen_m;
d529 1
a529 1
	if ((cpl & r_imen) != 0) {
d531 2
a532 2
		imen_m |= r_imen;
		enable_irq(~imen_m);
d534 1
a534 8
		splraise(m_intrmask[irq]);

		/*
		 * enable interrupts for the duration of the
		 * interrupt handler 
		 */
		ppc_intr_enable(1);
		ih = m_intrhand[irq];
d536 3
a541 1
		ppc_intr_disable();
d544 1
a544 1
		evirq[m_hwirq[irq]].ev_count++;
a550 1
	ppc_intr_enable(1);
a551 1
	ppc_intr_disable();
d574 2
a575 2
	imen_m &= ~hwpend;
	enable_irq(~imen_m);
d580 1
a580 1
		ih = m_intrhand[irq];
d586 1
a586 1
		evirq[m_hwirq[irq]].ev_count++;
d589 1
a589 1
	/*out32rb(INT_ENABLE_REG, ~imen_m);*/
d627 1
a627 1
		rv |= 1 << m_virq[p];
d641 1
a641 1
		rv |= 1 << m_virq[p + 32];
@


1.5.4.4
log
@Merge in -current from about a week ago
@
text
@d72 8
a79 8
static int fakeintr(void *);
static char *intr_typename(int type);
static void intr_calculatemasks(void);
static void enable_irq(int x);
static __inline int cntlzw(int x);
static int mapirq(int irq);
static int read_irq(void);
static void mac_intr_do_pending_int(void);
d99 4
a102 4
int	macintr_match(struct device *parent, void *cf, void *aux);
void	macintr_attach(struct device *, struct device *, void *);
void	mac_do_pending_int(void);
void	mac_ext_intr(void);
d153 1
a153 1
void macintr_collect_preconf_intr(void);
d240 1
a240 1
	int (*ih_fun)(void *);
d551 5
d561 1
d571 1
d573 1
@


1.5.4.5
log
@Sync the SMP branch with 3.3
@
text
@d70 1
a70 1
struct evcnt m_evirq[ICU_LEN*2];
d558 1
a558 1
		m_evirq[m_hwirq[irq]].ev_count++;
d600 1
a600 1
		m_evirq[m_hwirq[irq]].ev_count++;
@


1.5.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.5.4.5 2003/03/27 23:29:46 niklas Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d100 1
a100 1
struct cfattach macintr_ca = {
d111 4
a114 1
macintr_match(struct device *parent, void *cf, void *aux)
d124 1
a124 1
		if (strcmp(type,  "interrupt-controller") == 0)
d126 1
d134 1
a134 1
	if (strcmp(ca->ca_name, "legacy-interrupt-controller") == 0 )
d136 1
d152 3
a154 1
macintr_attach(struct device *parent, struct device *self, void *aux)
d172 1
a172 1
	    macintr_prog_button, (void *)0x14, "prog button");
a177 1

d183 1
a183 1
		printf("\n\t%s irq %d level %d fun %p arg %p",
d218 2
a219 1
fakeintr(void *arg)
d231 8
a238 2
macintr_establish(void * lcv, int irq, int type, int level,
    int (*ih_fun)(void *), void *ih_arg, char *name)
d316 3
a318 1
macintr_disestablish(void *lcp, void *arg)
d347 2
a348 1
intr_typename(int type)
d350 1
d388 1
a388 1
	for (level = IPL_NONE; level < IPL_NUM; level++) {
d434 2
a435 1
enable_irq(int x)
d446 1
a446 1
		if (irq < 32)
d448 1
a448 1
		else
d450 1
a450 1

d454 1
a454 1
	if (heathrow_FCR)
d456 1
a456 1

d466 2
a467 1
mapirq(int irq)
d481 1
a481 1
	if (m_virq[irq] != 0)
d483 1
d505 2
a506 1
cntlzw(int x)
d571 1
a571 1
	int s;
d579 3
a581 1
	s = ppc_intr_disable();
d620 1
a620 1
	ppc_intr_enable(s);
@


1.4
log
@Commit a ugly, widespread change.
Problem: no MI soft interrupts.
Bad solution: use old hack that was never fully implemented
to hook in zs soft interrupts.
This allows zs to work almost reasonably.
Still has issues with getty (carrier detect)
and modems on newer machines (power control).

Post 3.0 this must be cleaned up with real soft interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.3 2001/09/11 06:47:00 mickey Exp $	*/
d147 1
a147 1
int prog_switch (void *arg);
d176 1
a176 1
		prog_switch, (void *)0x14, "prog button");
d205 4
d210 1
a210 1
prog_switch (void *arg)
@


1.3
log
@vm/vm_kern.h is not needed hereand it compiles (;
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.2 2001/09/10 12:57:24 drahn Exp $	*/
d600 5
a604 1
	} while (ipending & (SINT_NET|SINT_CLOCK) & ~cpl);
@


1.2
log
@Device addresses should be mapped. It should be converted to bus_ accesses.
This maps the region with mapiodev().
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.1 2001/09/01 15:50:00 drahn Exp $	*/
d49 1
a50 1
#include <vm/vm_kern.h>
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/mac to macppc/dev
@
text
@d1 1
a1 1
/*	$OpenBSD: macintr.c,v 1.14 2001/07/09 03:30:20 mickey Exp $	*/
d164 1
a164 1
	interrupt_reg = (void *)ca->ca_baseaddr; /* XXX */
@

