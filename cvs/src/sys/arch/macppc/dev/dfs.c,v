head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.14
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.10
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.6
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.8
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.1.0.10
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.8
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.6
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.4
	OPENBSD_5_0:1.1.0.2
	OPENBSD_5_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2014.07.08.13.06.58;	author deraadt;	state Exp;
branches;
next	1.2;
commitid	eL0jnb8G3buKIRY6;

1.2
date	2013.10.31.08.26.12;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.05.25.07.42.15;	author mpi;	state Exp;
branches;
next	;


desc
@@


1.3
log
@A few missing sys/systm.h includes.  Soon the universes dragged in via
uvm_extern.h, uvm_param.h, and sysctl.h will no longer gaurantee that
_KERNEL code gets it.
@
text
@/*	$OpenBSD: dfs.c,v 1.2 2013/10/31 08:26:12 mpi Exp $	*/
/*
 * Copyright (c) 2011 Martin Pieuchot <mpi@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/sysctl.h>

#include <dev/ofw/openfirm.h>

#include <machine/cpu.h>
#include <machine/autoconf.h>
#include <macppc/pci/macobio.h>
#include <powerpc/hid.h>

extern int perflevel;

struct dfs_softc {
	struct device	sc_dev;
	int		sc_voltage;
};

int	dfs_match(struct device *, void *, void *);
void	dfs_attach(struct device *, struct device *, void *);
void	dfs_setperf(int);
void	dfs_scale_frequency(u_int);

struct cfattach dfs_ca = {
	sizeof(struct dfs_softc), dfs_match, dfs_attach
};

struct cfdriver dfs_cd = {
	NULL, "dfs", DV_DULL
};

int
dfs_match(struct device *parent, void *arg, void *aux)
{
	struct confargs *ca = aux;
	uint16_t cpu;

	if (strcmp(ca->ca_name, "cpu-vcore-select") != 0)
		return (0);

	cpu = ppc_mfpvr() >> 16;
	if (cpu == PPC_CPU_MPC7447A || cpu == PPC_CPU_MPC7448)
			return (1);

	return (0);
}

void
dfs_attach(struct device *parent, struct device *self, void *aux)
{
	struct dfs_softc *sc = (struct dfs_softc *)self;
	struct confargs *ca = aux;
	uint32_t hid1, reg;
	uint16_t cpu;

	/*
	 * On some models the vcore-select offset is relative to
	 * its parent offset and not to the bus base address.
	 */
	OF_getprop(OF_parent(ca->ca_node), "reg", &reg, sizeof(reg));
	if (reg > ca->ca_reg[0])
		sc->sc_voltage = reg + ca->ca_reg[0];
	else
		sc->sc_voltage = ca->ca_reg[0];

	hid1 = ppc_mfhid1();

	if (hid1 & HID1_DFS4) {
		ppc_curfreq = ppc_maxfreq / 4;
		perflevel = 25;
	} else if (hid1 & HID1_DFS2) {
		ppc_curfreq = ppc_maxfreq / 2;
		perflevel = 50;
	}

	cpu_setperf = dfs_setperf;

	printf(": speeds: %d, %d", ppc_maxfreq, ppc_maxfreq / 2);

	cpu = ppc_mfpvr() >> 16;
	if (cpu == PPC_CPU_MPC7448)
		printf(", %d", ppc_maxfreq / 4);
	printf(" MHz\n");
}

void
dfs_setperf(int perflevel)
{
	struct dfs_softc *sc = dfs_cd.cd_devs[0];

	if (perflevel > 50) {
		if (ppc_curfreq != ppc_maxfreq) {
			macobio_write(sc->sc_voltage, GPIO_DDR_OUTPUT | 1);
			delay(1000);
			dfs_scale_frequency(FREQ_FULL);
		}
	} else {
		uint16_t cpu;

		cpu = ppc_mfpvr() >> 16;
		if (cpu == PPC_CPU_MPC7448 && perflevel <= 25)  {
			if (ppc_curfreq != ppc_maxfreq / 4) {
				dfs_scale_frequency(FREQ_QUARTER);
				macobio_write(sc->sc_voltage,
				    GPIO_DDR_OUTPUT | 0);
				delay(1000);
			}
		} else {
			if (ppc_curfreq != ppc_maxfreq / 2) {
				dfs_scale_frequency(FREQ_HALF);
				macobio_write(sc->sc_voltage,
				    GPIO_DDR_OUTPUT | 0);
				delay(1000);
			}
		}
	}
}

void
dfs_scale_frequency(u_int freq_scale)
{
	uint32_t hid1;
	int s;

	s = splhigh();
	hid1 = ppc_mfhid1();

	hid1 &= ~(HID1_DFS2 | HID1_DFS4);
	switch (freq_scale) {
	case FREQ_QUARTER:
		hid1 |= HID1_DFS4;
		ppc_curfreq = ppc_maxfreq / 4;
		break;
	case FREQ_HALF:
		hid1 |= HID1_DFS2;
		ppc_curfreq = ppc_maxfreq / 2;
		break;
	case FREQ_FULL: /* FALLTHROUGH */
	default:
		ppc_curfreq = ppc_maxfreq;
	}

	asm volatile ("sync");
	ppc_mthid1(hid1);
	asm volatile ("sync; isync");

	splx(s);
}
@


1.2
log
@Add a header for various hardware implementation dependent register
(HID) definitions, from FreeBSD with tweaks, instead of defining
them in different places.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dfs.c,v 1.1 2011/05/25 07:42:15 mpi Exp $	*/
d19 1
@


1.1
log
@Add dfs(4), a driver to support the Dynamic Frequency Switching feature
found on some G4 PowerBook.

Tested by many, thanks.

ok sthen@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d27 1
a27 3

#define DFS2	(1 << 22)	/* Divide-by-Two */
#define DFS4	(1 << 23)	/* Divide-by-Four (MPC7448 Specific) */
d85 1
a85 1
	if (hid1 & DFS4) {
d88 1
a88 1
	} else if (hid1 & DFS2) {
d145 1
a145 1
	hid1 &= ~(DFS2 | DFS4);
d148 1
a148 1
		hid1 |= DFS4;
d152 1
a152 1
		hid1 |= DFS2;
@

