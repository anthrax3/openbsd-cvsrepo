head	1.30;
access;
symbols
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.30.0.18
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.14
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.10
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.12
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.4
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.30.0.8
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.6
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.29.0.8
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.6
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.4
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.27.0.10
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.6
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.8
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.4
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.26.0.8
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.6
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.4
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.23.0.4
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.8
	UBC:1.4.0.2
	UBC_BASE:1.4
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.30
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2011.05.09.22.33.53;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.29.23.06.53;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.26.05.42.12;	author ray;	state Exp;
branches;
next	1.26;

1.26
date	2006.06.19.22.42.33;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2006.02.10.21.45.41;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2006.01.13.19.25.45;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2004.10.17.08.58.56;	author grange;	state Exp;
branches;
next	1.22;

1.22
date	2004.08.17.22.20.55;	author drahn;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.17.18.57.07;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.11.17.38.08;	author grange;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.26.15.23.40;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.26.15.15.26;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.26.15.04.32;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.18.16.26.06;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.17.08.14.09;	author grange;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.19.14.45.41;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.11.22.16.34;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.11.20.33.08;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.06.16.36.51;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.05.22.40.48;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.05.05.17.04;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.15.02.02.43;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.26.16.50.12;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.09.15.01.51.11;	author mickey;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.09.01.17.43.09;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.50.00;	author drahn;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.01.15;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.06.07.11.13.14;	author ho;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2004.06.05.23.10.52;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@/*	$OpenBSD: wdc_obio.c,v 1.29 2011/05/09 22:33:53 matthew Exp $	*/
/*	$NetBSD: wdc_obio.c,v 1.15 2001/07/25 20:26:33 bouyer Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum and by Onno van der Linden.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/autoconf.h>

#include <dev/ofw/openfirm.h>
#include <dev/ata/atavar.h>
#include <dev/ata/atareg.h>
#include <dev/ic/wdcvar.h>

#include <macppc/dev/dbdma.h>

#define WDC_REG_NPORTS		8
#define WDC_AUXREG_OFFSET	0x16
#define WDC_DEFAULT_PIO_IRQ	13	/* XXX */
#define WDC_DEFAULT_DMA_IRQ	2	/* XXX */

#define WDC_OPTIONS_DMA 0x01

#define	WDC_DMALIST_MAX	32

struct wdc_obio_softc {
	struct wdc_softc sc_wdcdev;
	struct channel_softc *wdc_chanptr;
	struct channel_softc wdc_channel;

	bus_dma_tag_t sc_dmat;
	bus_dmamap_t sc_dmamap;
	dbdma_regmap_t *sc_dmareg;
	dbdma_command_t	*sc_dmacmd;
	dbdma_t sc_dbdma;

	void *sc_ih;
	int sc_use_dma;
	bus_size_t sc_cmdsize;
	size_t sc_dmasize;
};

u_int8_t wdc_obio_read_reg(struct channel_softc *, enum wdc_regs);
void wdc_obio_write_reg(struct channel_softc *, enum wdc_regs, u_int8_t);

struct channel_softc_vtbl wdc_obio_vtbl = {
	wdc_obio_read_reg,
	wdc_obio_write_reg,
	wdc_default_lba48_write_reg,
	wdc_default_read_raw_multi_2,
	wdc_default_write_raw_multi_2,
	wdc_default_read_raw_multi_4,
	wdc_default_write_raw_multi_4
};

int	wdc_obio_probe(struct device *, void *, void *);
void	wdc_obio_attach(struct device *, struct device *, void *);
int	wdc_obio_detach(struct device *, int);

struct cfattach wdc_obio_ca = {
	sizeof(struct wdc_obio_softc), wdc_obio_probe, wdc_obio_attach,
	wdc_obio_detach
};

int	wdc_obio_dma_init(void *, int, int, void *, size_t, int);
void	wdc_obio_dma_start(void *, int, int);
int	wdc_obio_dma_finish(void *, int, int, int);
void	wdc_obio_adjust_timing(struct channel_softc *);
void	wdc_obio_ata4_adjust_timing(struct channel_softc *);
void	wdc_obio_ata6_adjust_timing(struct channel_softc *);

int
wdc_obio_probe(struct device *parent, void *match, void *aux)
{
	struct confargs *ca = aux;
	char compat[32];

	if (ca->ca_nreg < 8)
		return 0;

	/* XXX should not use name */
	if (strcmp(ca->ca_name, "ATA") == 0 ||
	    strncmp(ca->ca_name, "ata", 3) == 0 ||
	    strcmp(ca->ca_name, "ide") == 0)
		return 1;

	bzero(compat, sizeof(compat));
	OF_getprop(ca->ca_node, "compatible", compat, sizeof(compat));
	if (strcmp(compat, "heathrow-ata") == 0 ||
	    strcmp(compat, "keylargo-ata") == 0)
		return 1;

	return 0;
}

void
wdc_obio_attach(struct device *parent, struct device *self, void *aux)
{
	struct wdc_obio_softc *sc = (void *)self;
	struct confargs *ca = aux;
	struct channel_softc *chp = &sc->wdc_channel;
	int intr, error;
	bus_addr_t cmdbase;

	sc->sc_use_dma = 0;
	if (ca->ca_nreg >= 16)
		sc->sc_use_dma = 1;	/* Enable dma */

	sc->sc_dmat = ca->ca_dmat;
	if ((error = bus_dmamap_create(sc->sc_dmat,
	    WDC_DMALIST_MAX * DBDMA_COUNT_MAX, WDC_DMALIST_MAX,
	    DBDMA_COUNT_MAX, NBPG, BUS_DMA_NOWAIT, &sc->sc_dmamap)) != 0) {
		printf(": cannot create dma map, error = %d\n", error);
		return;
	}

	if (ca->ca_nintr >= 4 && ca->ca_nreg >= 8) {
		intr = ca->ca_intr[0];
		printf(" irq %d", intr);
	} else if (ca->ca_nintr == -1) {
		intr = WDC_DEFAULT_PIO_IRQ;
		printf(" irq property not found; using %d", intr);
	} else {
		printf(": couldn't get irq property\n");
		return;
	}

	if (sc->sc_use_dma)
		printf(": DMA");

	printf("\n");

	chp->cmd_iot = chp->ctl_iot = ca->ca_iot;
	chp->_vtbl = &wdc_obio_vtbl;

	cmdbase = ca->ca_reg[0];
	sc->sc_cmdsize = ca->ca_reg[1];

	if (bus_space_map(chp->cmd_iot, cmdbase, sc->sc_cmdsize, 0,
	    &chp->cmd_ioh) || bus_space_subregion(chp->cmd_iot, chp->cmd_ioh,
	    /* WDC_AUXREG_OFFSET<<4 */ 0x160, 1, &chp->ctl_ioh)) {
		printf("%s: couldn't map registers\n",
			sc->sc_wdcdev.sc_dev.dv_xname);
		return;
	}
	chp->data32iot = chp->cmd_iot;
	chp->data32ioh = chp->cmd_ioh;

	sc->sc_ih = mac_intr_establish(parent, intr, IST_LEVEL, IPL_BIO,
	    wdcintr, chp, sc->sc_wdcdev.sc_dev.dv_xname);

	sc->sc_wdcdev.set_modes = wdc_obio_adjust_timing;
	if (sc->sc_use_dma) {
		sc->sc_dbdma = dbdma_alloc(sc->sc_dmat, WDC_DMALIST_MAX + 1);
		sc->sc_dmacmd = sc->sc_dbdma->d_addr;

		sc->sc_dmareg = mapiodev(ca->ca_baseaddr + ca->ca_reg[2],
		    sc->sc_dmasize = ca->ca_reg[3]);

		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;
		sc->sc_wdcdev.DMA_cap = 2;
		if (strcmp(ca->ca_name, "ata-4") == 0) {
			sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA |
			    WDC_CAPABILITY_MODE;
			sc->sc_wdcdev.UDMA_cap = 4;
			sc->sc_wdcdev.set_modes = wdc_obio_ata4_adjust_timing;
		}
		if (strcmp(ca->ca_name, "ata-6") == 0) {
			sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA |
			    WDC_CAPABILITY_MODE;
			sc->sc_wdcdev.UDMA_cap = 5;
			sc->sc_wdcdev.set_modes = wdc_obio_ata6_adjust_timing;
		}
	}
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16;
	sc->sc_wdcdev.PIO_cap = 4;
	sc->wdc_chanptr = chp;
	sc->sc_wdcdev.channels = &sc->wdc_chanptr;
	sc->sc_wdcdev.nchannels = 1;
	sc->sc_wdcdev.dma_arg = sc;
	sc->sc_wdcdev.dma_init = wdc_obio_dma_init;
	sc->sc_wdcdev.dma_start = wdc_obio_dma_start;
	sc->sc_wdcdev.dma_finish = wdc_obio_dma_finish;
	chp->channel = 0;
	chp->wdc = &sc->sc_wdcdev;

	chp->ch_queue = wdc_alloc_queue();
	if (chp->ch_queue == NULL) {
		printf("%s: cannot allocate channel queue",
		sc->sc_wdcdev.sc_dev.dv_xname);
		return;
	}

	wdcattach(chp);
	sc->sc_wdcdev.set_modes(chp);
	wdc_print_current_modes(chp);
}

int
wdc_obio_detach(struct device *self, int flags)
{
	struct wdc_obio_softc *sc = (struct wdc_obio_softc *)self;
	struct channel_softc *chp = &sc->wdc_channel;
	int error;

	if ((error = wdcdetach(chp, flags)) != 0)
		return (error);

	wdc_free_queue(chp->ch_queue);

	if (sc->sc_use_dma) {
		unmapiodev((void *)sc->sc_dmareg, sc->sc_dmasize);
		dbdma_free(sc->sc_dbdma);
	}
	mac_intr_disestablish(NULL, sc->sc_ih);

	bus_space_unmap(chp->cmd_iot, chp->cmd_ioh, sc->sc_cmdsize);
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_dmamap);

	return (0);
}

/* Multiword DMA transfer timings */
struct ide_timings {
	int cycle;	/* minimum cycle time [ns] */
	int active;	/* minimum command active time [ns] */
};

static const struct ide_timings pio_timing[] = {
	{ 600, 165 },    /* Mode 0 */
	{ 383, 125 },    /*      1 */
	{ 240, 100 },    /*      2 */
	{ 180,  80 },    /*      3 */
	{ 120,  70 }     /*      4 */
};

static const struct ide_timings dma_timing[] = {
	{ 480, 215 },	/* Mode 0 */
	{ 150,  80 },	/* Mode 1 */
	{ 120,  70 },	/* Mode 2 */
};

static const struct ide_timings udma_timing[] = {
	{114,   0},     /* Mode 0 */
	{ 75,   0},     /* Mode 1 */
	{ 55,   0},     /* Mode 2 */
	{ 45, 100},     /* Mode 3 */
	{ 25, 100}      /* Mode 4 */
};

/* these number _guessed_ from linux driver. */
static u_int32_t kauai_pio_timing[] = {
	/*600*/	0x08000a92,	/* Mode 0 */
	/*360*/	0x08000492,	/* Mode 1 */
	/*240*/	0x0800038b,	/* Mode 2 */
	/*180*/	0x05000249,	/* Mode 3 */
	/*120*/	0x04000148	/* Mode 4 */
		
};
static u_int32_t kauai_dma_timing[] = {
	/*480*/	0x00618000,	/* Mode 0 */
	/*360*/	0x00492000,	/* Mode 1 */
	/*240*/	0x00149000	/* Mode 2 */ /* fw value */
};
static u_int32_t kauai_udma_timing[] = {
	/*120*/	0x000070c0,	/* Mode 0 */
	/* 90*/	0x00005d80,	/* Mode 1 */
	/* 60*/	0x00004a60,	/* Mode 2 */
	/* 45*/	0x00003a50,	/* Mode 3 */
	/* 30*/	0x00002a30,	/* Mode 4 */
	/* 20*/	0x00002921	/* Mode 5 */
};

#define	TIME_TO_TICK(time)	howmany((time), 30)
#define	PIO_REC_OFFSET	4
#define	PIO_REC_MIN	1
#define	PIO_ACT_MIN	1
#define	DMA_REC_OFFSET	1
#define	DMA_REC_MIN	1
#define	DMA_ACT_MIN	1

#define	ATA4_TIME_TO_TICK(time)	howmany((time) * 1000, 7500)

#define CONFIG_REG (0x200)		/* IDE access timing register */
#define KAUAI_ULTRA_CONFIG (0x210)	/* secondary config register (kauai)*/

#define KAUAI_PIO_MASK		0xff000fff
#define KAUAI_DMA_MASK		0x00fff000
#define KAUAI_UDMA_MASK		0x0000ffff
#define KAUAI_UDMA_EN		0x00000001

void
wdc_obio_adjust_timing(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	u_int conf;
	int drive;
	int piomode = -1, dmamode = -1;
	int min_cycle, min_active;
	int cycle_tick, act_tick, inact_tick, half_tick;

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		if (piomode == -1 || piomode > drvp->PIO_mode)
			piomode = drvp->PIO_mode;
		if (drvp->drive_flags & DRIVE_DMA)
			if (dmamode == -1 || dmamode > drvp->DMA_mode)
				dmamode = drvp->DMA_mode;
	}
	if (piomode == -1)
		return; /* No drive */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		if (drvp->drive_flags & DRIVE) {
			drvp->PIO_mode = piomode;
			if (drvp->drive_flags & DRIVE_DMA)
				drvp->DMA_mode = dmamode;
		}
	}
	min_cycle = pio_timing[piomode].cycle;
	min_active = pio_timing[piomode].active;

	cycle_tick = TIME_TO_TICK(min_cycle);
	act_tick = TIME_TO_TICK(min_active);
	if (act_tick < PIO_ACT_MIN)
		act_tick = PIO_ACT_MIN;
	inact_tick = cycle_tick - act_tick - PIO_REC_OFFSET;
	if (inact_tick < PIO_REC_MIN)
		inact_tick = PIO_REC_MIN;
	/* mask: 0x000007ff */
	conf = (inact_tick << 5) | act_tick;
	if (dmamode != -1) {
		/* there are active DMA mode */

		min_cycle = dma_timing[dmamode].cycle;
		min_active = dma_timing[dmamode].active;
		cycle_tick = TIME_TO_TICK(min_cycle);
		act_tick = TIME_TO_TICK(min_active);
		inact_tick = cycle_tick - act_tick - DMA_REC_OFFSET;
		if (inact_tick < DMA_REC_MIN)
			inact_tick = DMA_REC_MIN;
		half_tick = 0;	/* XXX */
		/* mask: 0xfffff800 */
		conf |=
		    (half_tick << 21) |
		    (inact_tick << 16) | (act_tick << 11);
	}
	bus_space_write_4(chp->cmd_iot, chp->cmd_ioh, CONFIG_REG, conf);
#if 0
	printf("conf = 0x%x, cyc = %d (%d ns), act = %d (%d ns), inact = %d\n",
	    conf, cycle_tick, min_cycle, act_tick, min_active, inact_tick);
#endif
}

void
wdc_obio_ata4_adjust_timing(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	u_int conf;
	int drive;
	int piomode = -1, dmamode = -1;
	int min_cycle, min_active;
	int cycle_tick, act_tick, inact_tick;
	int udmamode = -1;

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		if (piomode == -1 || piomode > drvp->PIO_mode)
			piomode = drvp->PIO_mode;
		if (drvp->drive_flags & DRIVE_DMA)
			if (dmamode == -1 || dmamode > drvp->DMA_mode)
				dmamode = drvp->DMA_mode;
		if (drvp->drive_flags & DRIVE_UDMA) {
			if (udmamode == -1 || udmamode > drvp->UDMA_mode)
				udmamode = drvp->UDMA_mode;
		} else
			udmamode = -2;
	}
	if (piomode == -1)
		return; /* No drive */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		if (drvp->drive_flags & DRIVE) {
			drvp->PIO_mode = piomode;
			if (drvp->drive_flags & DRIVE_DMA)
				drvp->DMA_mode = dmamode;
			if (drvp->drive_flags & DRIVE_UDMA) {
				if (udmamode == -2)
					drvp->drive_flags &= ~DRIVE_UDMA;
				else
					drvp->UDMA_mode = udmamode;
			}
		}
	}

	if (udmamode == -2)
		udmamode = -1;

	min_cycle = pio_timing[piomode].cycle;
	min_active = pio_timing[piomode].active;

	cycle_tick = ATA4_TIME_TO_TICK(min_cycle);
	act_tick = ATA4_TIME_TO_TICK(min_active);
	inact_tick = cycle_tick - act_tick;
	/* mask: 0x000003ff */
	conf = (inact_tick << 5) | act_tick;
	if (dmamode != -1) {
		/* there are active  DMA mode */

		min_cycle = dma_timing[dmamode].cycle;
		min_active = dma_timing[dmamode].active;
		cycle_tick = ATA4_TIME_TO_TICK(min_cycle);
		act_tick = ATA4_TIME_TO_TICK(min_active);
		inact_tick = cycle_tick - act_tick;
		/* mask: 0x001ffc00 */
		conf |= (act_tick << 10) | (inact_tick << 15);
	}
	if (udmamode != -1) {
		min_cycle = udma_timing[udmamode].cycle;
		min_active = udma_timing[udmamode].active;
		act_tick = ATA4_TIME_TO_TICK(min_active);
		cycle_tick = ATA4_TIME_TO_TICK(min_cycle);
		/* mask: 0x1ff00000 */
		conf |= (cycle_tick << 21) | (act_tick << 25) | 0x100000;
	}

	bus_space_write_4(chp->cmd_iot, chp->cmd_ioh, CONFIG_REG, conf);
#if 0
	printf("ata4 conf = 0x%x, cyc = %d (%d ns), act = %d (%d ns), inact = %d\n",
	    conf, cycle_tick, min_cycle, act_tick, min_active, inact_tick);
#endif
}

void
wdc_obio_ata6_adjust_timing(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	u_int conf, conf1;
	int drive;
	int piomode = -1, dmamode = -1;
	int udmamode = -1;

	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		if (piomode == -1 || piomode > drvp->PIO_mode)
			piomode = drvp->PIO_mode;
		if (drvp->drive_flags & DRIVE_DMA) {
			if (dmamode == -1 || dmamode > drvp->DMA_mode)
				dmamode = drvp->DMA_mode;
		}
		if (drvp->drive_flags & DRIVE_UDMA) {
			if (udmamode == -1 || udmamode > drvp->UDMA_mode)
				udmamode = drvp->UDMA_mode;
		} else
			udmamode = -2;
	}
	if (piomode == -1)
		return; /* No drive */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		if (drvp->drive_flags & DRIVE) {
			drvp->PIO_mode = piomode;
			if (drvp->drive_flags & DRIVE_DMA)
				drvp->DMA_mode = dmamode;
			if (drvp->drive_flags & DRIVE_UDMA) {
				if (udmamode == -2)
					drvp->drive_flags &= ~DRIVE_UDMA;
				else
					drvp->UDMA_mode = udmamode;
			}
		}
	}

	if (udmamode == -2)
		udmamode = -1;

	conf = bus_space_read_4(chp->cmd_iot, chp->cmd_ioh, CONFIG_REG);
	conf1 = bus_space_read_4(chp->cmd_iot, chp->cmd_ioh,
	    KAUAI_ULTRA_CONFIG);

	conf = (conf & ~KAUAI_PIO_MASK) | kauai_pio_timing[piomode];

	if (dmamode != -1)
		conf = (conf & ~KAUAI_DMA_MASK) | kauai_dma_timing[dmamode];
	if (udmamode != -1)
		conf1 = (conf1 & ~KAUAI_UDMA_MASK) |
		    kauai_udma_timing[udmamode] | KAUAI_UDMA_EN;
	else 
		conf1 = conf1 & ~KAUAI_UDMA_EN;

	bus_space_write_4(chp->cmd_iot, chp->cmd_ioh, CONFIG_REG, conf);
	bus_space_write_4(chp->cmd_iot, chp->cmd_ioh, KAUAI_ULTRA_CONFIG,
	    conf1);
}

int
wdc_obio_dma_init(void *v, int channel, int drive, void *databuf,
    size_t datalen, int flags)
{
	struct wdc_obio_softc *sc = v;
	dbdma_command_t *cmdp;
	u_int cmd;
	int i, error;

	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap, databuf,
	    datalen, NULL, BUS_DMA_NOWAIT)) != 0)
		return (error);

	cmdp = sc->sc_dmacmd;
	cmd = (flags & WDC_DMA_READ) ? DBDMA_CMD_IN_MORE : DBDMA_CMD_OUT_MORE;

	for (i = 0; i < sc->sc_dmamap->dm_nsegs; i++, cmdp++) {
		if (i + 1 == sc->sc_dmamap->dm_nsegs)
			cmd = (flags & WDC_DMA_READ) ? DBDMA_CMD_IN_LAST :
			    DBDMA_CMD_OUT_LAST;

		DBDMA_BUILD(cmdp, cmd, 0, sc->sc_dmamap->dm_segs[i].ds_len,
		    sc->sc_dmamap->dm_segs[i].ds_addr,
		    DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
	}

	DBDMA_BUILD(cmdp, DBDMA_CMD_STOP, 0, 0, 0,
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);

	return 0;
}

void
wdc_obio_dma_start(void *v, int channel, int drive)
{
	struct wdc_obio_softc *sc = v;

	dbdma_start(sc->sc_dmareg, sc->sc_dbdma);
}

int
wdc_obio_dma_finish(void *v, int channel, int drive, int force)
{
	struct wdc_obio_softc *sc = v;

	dbdma_stop(sc->sc_dmareg);
	bus_dmamap_unload(sc->sc_dmat, sc->sc_dmamap);
	return 0;
}

/* read register code
 * this allows the registers to be spaced by 0x10, instead of 0x1.
 * mac hardware (obio) requires this.
 */

u_int8_t
wdc_obio_read_reg(struct channel_softc *chp, enum wdc_regs reg)
{
#ifdef DIAGNOSTIC
	if (reg & _WDC_WRONLY) {
		printf ("wdc_obio_read_reg: reading from a write-only register %d\n", reg);
	}
#endif

	if (reg & _WDC_AUX)
		return (bus_space_read_1(chp->ctl_iot, chp->ctl_ioh,
		    (reg & _WDC_REGMASK) << 4));
	else
		return (bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,
		    (reg & _WDC_REGMASK) << 4));
}


void
wdc_obio_write_reg(struct channel_softc *chp, enum wdc_regs reg, u_int8_t val)
{
#ifdef DIAGNOSTIC
	if (reg & _WDC_RDONLY) {
		printf ("wdc_obio_write_reg: writing to a read-only register %d\n", reg);
	}
#endif

	if (reg & _WDC_AUX)
		bus_space_write_1(chp->ctl_iot, chp->ctl_ioh,
		    (reg & _WDC_REGMASK) << 4, val);
	else
		bus_space_write_1(chp->cmd_iot, chp->cmd_ioh,
		    (reg & _WDC_REGMASK) << 4, val);
}
@


1.29
log
@Refactor queue allocation and initialization into a wdc_alloc_queue()
function, and let attachment code calls this rather than malloc(9).
This prevents re-initialization of the queue in shared queue chipsets.
Also, add wdc_free_queue() as a complementary function.

Earlier version (without wdc_free_queue()) tested by sthen@@ and Amit
Kulkarni on various pciide(4) chips.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.28 2010/08/29 23:06:53 deraadt Exp $	*/
d95 1
a95 1
	    wdc_obio_detach, config_activate_children
@


1.28
log
@s/wdcactivate/config_activate_children/
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.27 2008/06/26 05:42:12 ray Exp $	*/
d220 1
a220 2
	chp->ch_queue = malloc(sizeof(struct channel_queue), M_DEVBUF,
	    M_NOWAIT);
d222 1
a222 1
		printf("%s: can't allocate memory for command queue",
d242 1
a242 1
	free(chp->ch_queue, M_DEVBUF);
@


1.27
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.26 2006/06/19 22:42:33 miod Exp $	*/
d95 1
a95 1
	    wdc_obio_detach, wdcactivate
@


1.26
log
@Be more strict in the probe routines and actually check ca_nintr and
ca_nreg are large enough for our greedy needs; tweaks and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.25 2006/02/10 21:45:41 kettenis Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.25
log
@Fix LBA48 access for ServerWorks SATA.
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.24 2006/01/13 19:25:45 miod Exp $	*/
d118 3
d146 1
a146 1
	if (ca->ca_nreg >= 16 || ca->ca_nintr == -1)
@


1.24
log
@Allow proper detaching of wdc, so that detaching a mediabay device properly
releases resources and works as expected.

Thanks to Thomas Maschutznig for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.23 2004/10/17 08:58:56 grange Exp $	*/
d89 1
@


1.23
log
@Move declaration of default _vtbl members (wdc_default_*) to
wdcvar.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.22 2004/08/17 22:20:55 drahn Exp $	*/
d76 5
d97 1
d100 2
a101 1
	sizeof(struct wdc_obio_softc), wdc_obio_probe, wdc_obio_attach
d138 1
a138 1
	int intr, error, use_dma = 0;
a139 1
	bus_size_t cmdsize;
d141 1
d143 1
a143 1
		use_dma = 1;	/* Enable dma */
d164 1
a164 1
	if (use_dma)
d173 1
a173 1
	cmdsize = ca->ca_reg[1];
d175 2
a176 2
	if (bus_space_map(chp->cmd_iot, cmdbase, cmdsize, 0, &chp->cmd_ioh) ||
	    bus_space_subregion(chp->cmd_iot, chp->cmd_ioh,
d185 2
a186 2
	mac_intr_establish(parent, intr, IST_LEVEL, IPL_BIO, wdcintr, chp,
	    sc->sc_wdcdev.sc_dev.dv_xname);
d189 1
a189 1
	if (use_dma) {
d194 1
a194 1
		    ca->ca_reg[3]);
d234 24
@


1.22
log
@Use device name, not constant string, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.21 2004/03/17 18:57:07 drahn Exp $	*/
a79 8
void wdc_default_read_raw_multi_2(struct channel_softc *,
    void *, unsigned int);
void wdc_default_write_raw_multi_2(struct channel_softc *,
    void *, unsigned int);
void wdc_default_read_raw_multi_4(struct channel_softc *,
    void *, unsigned int);
void wdc_default_write_raw_multi_4(struct channel_softc *,
    void *, unsigned int);
@


1.21
log
@Remove pointless printfs.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.20 2004/01/11 17:38:08 grange Exp $	*/
d187 1
a187 1
	    "wdc_obio");
@


1.20
log
@Little sync dmesg output with pciide.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.19 2003/10/26 15:23:40 drahn Exp $	*/
a500 3
#if 1
	printf("ata6 conf old: 0x%x, %x", conf, conf1);
#endif
a513 3
#if 1
	printf("new : 0x%x, %x\n", conf, conf1);
#endif
@


1.19
log
@More ansi/knf missed the first time around.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.18 2003/10/26 15:15:26 miod Exp $	*/
d166 1
a166 1
		printf(": DMA transfer");
@


1.18
log
@Oops, I'm on drugs. Revert and blame gremlins for the state of my tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.16 2003/10/18 16:26:06 drahn Exp $	*/
d88 1
d223 3
a225 2
	chp->ch_queue = malloc(sizeof(struct channel_queue),
	    M_DEVBUF, M_NOWAIT);
d349 1
a349 1
		/* there are active  DMA mode */
d372 1
a372 2
wdc_obio_ata4_adjust_timing(chp)
	struct channel_softc *chp;
a381 1

a460 1

d523 2
a524 5
wdc_obio_dma_init(v, channel, drive, databuf, datalen, flags)
	void *v;
	void *databuf;
	size_t datalen;
	int flags;
d578 1
a578 2
wdc_obio_read_reg(struct channel_softc *chp,
	enum wdc_regs reg)
@


1.17
log
@Unbrek after recent wdc changes.
@
text
@d106 1
a106 1
int	wdc_obio_dma_finish(void *, int, int);
d567 1
a567 1
wdc_obio_dma_finish(void *v, int channel, int drive)
@


1.16
log
@ANSI/KNF now that conflict has been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.15 2003/10/17 08:14:09 grange Exp $	*/
d106 1
a106 1
int	wdc_obio_dma_finish(void *, int, int, int);
d567 1
a567 1
wdc_obio_dma_finish(void *v, int channel, int drive, int force)
@


1.15
log
@Merge an old fix from NetBSD:
- do not stop/unload current DMA operation if an IRQ was not detected
  by DMA engine unless the force flag was given, fixes DMA problems
  in shared IRQ setups;
- ack interrupt before entering DMA codepath

Tested by many.
Work by niklas@@ but he doesn't want to commit it for some reason.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.14 2003/07/19 14:45:41 drahn Exp $	*/
d112 1
a112 4
wdc_obio_probe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d133 1
a133 3
wdc_obio_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d177 1
a177 2
			/* WDC_AUXREG_OFFSET<<4 */ 0x160, 1, &chp->ctl_ioh))
	{
d186 1
a186 1
		"wdc_obio");
d223 1
a223 1
		M_DEVBUF, M_NOWAIT);
a303 2


d305 1
a305 2
wdc_obio_adjust_timing(chp)
	struct channel_softc *chp;
a313 1

d320 1
a320 1
		if (drvp->drive_flags & DRIVE_DMA) {
a322 1
		}
d388 1
a388 1
		if (drvp->drive_flags & DRIVE_DMA) {
a390 1
		}
d394 1
a394 1
		} else {
a395 1
		}
d406 1
a406 1
				if (udmamode == -2) {
d408 1
a408 1
				} else {
a409 1
				}
d475 1
a475 1
		} else {
a476 1
		}
d487 1
a487 1
				if (udmamode == -2) {
d489 1
a489 1
				} else {
a490 1
				}
d507 1
a507 1
	if (dmamode != -1) {
d509 1
a509 2
	}
	if (udmamode != -1) {
d512 1
a512 1
	} else 
d546 1
d559 1
a559 3
wdc_obio_dma_start(v, channel, drive)
	void *v;
	int channel, drive;
d567 1
a567 3
wdc_obio_dma_finish(v, channel, drive, force)
	void *v;
	int channel, drive, force;
d582 2
a583 3
wdc_obio_read_reg(chp, reg)
	struct channel_softc *chp;
	enum wdc_regs reg;
d601 1
a601 4
wdc_obio_write_reg(chp, reg, val)
	struct channel_softc *chp;
	enum wdc_regs reg;
	u_int8_t val;
@


1.14
log
@The last parameter to _dma_init for wdc code is flags, not read,
mask of just the desired bit. ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.13 2003/06/11 22:16:34 drahn Exp $	*/
d106 1
a106 1
int	wdc_obio_dma_finish(void *, int, int);
d585 1
a585 1
wdc_obio_dma_finish(v, channel, drive)
d587 1
a587 1
	int channel, drive;
@


1.13
log
@Get rid of the '#if 1' nonsense.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.12 2003/06/11 20:33:08 drahn Exp $	*/
d541 1
a541 1
wdc_obio_dma_init(v, channel, drive, databuf, datalen, read)
d545 1
a545 1
	int read;
d557 1
a557 1
	cmd = read ? DBDMA_CMD_IN_MORE : DBDMA_CMD_OUT_MORE;
d561 2
a562 1
			cmd = read ? DBDMA_CMD_IN_LAST : DBDMA_CMD_OUT_LAST;
@


1.12
log
@Previously DMA/UDMA was disabled on macppc RAMDISK kernels, I have not
heard of any DMA related failures on these machines. Remove the code
(and the flag) which was previously used to enable DMA/UDMA modes on
wdc_obio now it will default to always being on for known systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.11 2003/06/06 16:36:51 drahn Exp $	*/
a270 1
	#if 1
a275 7
	#else
	/*120*/	0x06000246,	/* Mode 0 */
	/*180*/	0x06000246,	/* Mode 1 */
	/*240*/	0x06000246,	/* Mode 2 */
	/*360*/	0x06000246,	/* Mode 3 */
	/*600*/	0x06000246	/* Mode 4 */
	#endif
a278 1
	#if 1
a281 5
	#else
	/*120*/	0x00149000,	/* Mode 0 */
	/*150*/	0x00149000,	/* Mode 1 */
	/*240*/	0x00149000	/* Mode 2 */
	#endif
a283 1
	#if 1
a289 8
	#else
	/*120*/	0x00002921,	/* Mode 0 */
	/* 90*/	0x00002921,	/* Mode 1 */
	/* 60*/	0x00002921,	/* Mode 2 */
	/* 45*/	0x00002921,	/* Mode 3 */
	/* 30*/	0x00002921,	/* Mode 4 */
	/* 20*/	0x00002921	/* Mode 5 */
	#endif
@


1.11
log
@Fix a copied constant, mention why a number doesnt match linux, remove
duplicated line.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.10 2003/06/05 22:40:48 drahn Exp $	*/
d147 2
a148 4
	if (sc->sc_wdcdev.sc_dev.dv_cfdata->cf_flags & WDC_OPTIONS_DMA) {
		if (ca->ca_nreg >= 16 || ca->ca_nintr == -1)
			use_dma = 1;	/* XXX Don't work yet. */
	}
@


1.10
log
@Cleanup and enable kauaiata DMA. Tables should be mostly sane
Please _TEST_.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.9 2003/06/05 05:17:04 drahn Exp $	*/
d275 1
a275 1
	/*360*/	0x08000392,	/* Mode 1 */
d292 1
a292 1
	/*240*/	0x00149000	/* Mode 2 */
a326 1
#define CONFIG_REG (0x200)		/* IDE access timing register */
@


1.9
log
@ATA100 driver for apple's new machines, aka kauai.
This is working with udma on a 12" PBG4, but dma is disabled for now,
too many hardcoded values. 'wdc...flags 0x1' will enable it.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.8 2002/09/15 09:01:58 deraadt Exp $	*/
a181 3
	printf("wdc_obio map %x %x %x %x\n", cmdbase, cmdsize, ca->ca_reg[2],
	    ca->ca_reg[2]);

d215 1
a215 1
			sc->sc_wdcdev.UDMA_cap = 6;
d273 3
a275 3
	#if 0
	/*120*/	0x04000148,	/* Mode 0 */
	/*180*/	0x05000249,	/* Mode 1 */
d277 3
a279 3
	/*360*/	0x08000392,	/* Mode 3 */
	/*600*/	0x08000a92	/* Mode 4 */
	#endif
d285 1
d289 5
a293 7
	#if 0
	/*120*/	0x00148000,	/* Mode 0 */
	/*150*/	0x00209000,	/* Mode 1 */
	/*240*/	0x0030c000,	/* Mode 2 */
	/*360*/	0x00492000,	/* Mode 3 */
	/*480*/	0x00618000	/* Mode 4 */
	#endif
d296 2
a297 3
	/*240*/	0x00149000,	/* Mode 2 */
	/*360*/	0x00149000,	/* Mode 3 */
	/*480*/	0x00149000	/* Mode 4 */
d300 14
a313 7
	#if 0
	/* 20*/	0x00002921,	/* Mode 0 */
	/* 30*/	0x00002a30,	/* Mode 1 */
	/* 45*/	0x00003a50,	/* Mode 2 */
	/* 60*/	0x00004a60,	/* Mode 3 */
	/* 90*/	0x00005d80,	/* Mode 4 */
	/*120*/	0x000070c0	/* Mode 5 */
a314 6
	/* 20*/	0x00002921,	/* Mode 0 */
	/* 30*/	0x00002921,	/* Mode 1 */
	/* 45*/	0x00002921,	/* Mode 2 */
	/* 60*/	0x00002921,	/* Mode 3 */
	/* 90*/	0x00002921,	/* Mode 4 */
	/*120*/	0x00002921	/* Mode 5 */
a539 1

d544 1
d546 1
@


1.8
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.6 2002/03/26 16:50:12 drahn Exp $	*/
d109 1
d182 3
d203 1
d205 2
a206 1
					 ca->ca_reg[3]);
d215 6
d274 47
d332 9
d493 73
@


1.7
log
@KNF
@
text
@d183 2
a184 1
	    /* WDC_AUXREG_OFFSET<<4 */ 0x160, 1, &chp->ctl_ioh)) {
d186 1
a186 1
		    sc->sc_wdcdev.sc_dev.dv_xname);
d193 1
a193 1
	    "wdc_obio");
d200 1
a200 1
		    ca->ca_reg[3]);
d331 2
a332 1
		conf |= (half_tick << 21) |
d456 1
a456 1
	    DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d495 1
a495 2
		printf("wdc_obio_read_reg: reading from a write-only register %d\n",
		    reg);
d516 1
a516 2
		printf("wdc_obio_write_reg: writing to a read-only register %d\n",
		    reg);
@


1.6
log
@On the wdc_obio controller if one device is UDMA capable and one is not,
downgrade the UDMA device to DMA. Works around a problem with old combo
drives on some Apple machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.5 2002/03/14 01:26:36 millert Exp $	*/
d183 1
a183 2
			/* WDC_AUXREG_OFFSET<<4 */ 0x160, 1, &chp->ctl_ioh))
	{
d185 1
a185 1
			sc->sc_wdcdev.sc_dev.dv_xname);
d192 1
a192 1
		"wdc_obio");
d199 1
a199 1
					 ca->ca_reg[3]);
d330 1
a330 2
		conf |=
		    (half_tick << 21) |
d454 1
a454 1
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d493 2
a494 1
		printf ("wdc_obio_read_reg: reading from a write-only register %d\n", reg);
d515 2
a516 1
		printf ("wdc_obio_write_reg: writing to a read-only register %d\n", reg);
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.4 2001/11/06 19:53:15 miod Exp $	*/
d368 2
d380 7
a386 2
			if (drvp->drive_flags & DRIVE_UDMA)
				drvp->UDMA_mode = udmamode;
d389 4
@


1.4
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.3 2001/09/15 01:51:11 mickey Exp $	*/
d78 10
a87 10
u_int8_t wdc_obio_read_reg __P((struct channel_softc *, enum wdc_regs));
void wdc_obio_write_reg __P((struct channel_softc *, enum wdc_regs, u_int8_t));
void wdc_default_read_raw_multi_2 __P((struct channel_softc *,
    void *, unsigned int));
void wdc_default_write_raw_multi_2 __P((struct channel_softc *,
    void *, unsigned int));
void wdc_default_read_raw_multi_4 __P((struct channel_softc *,
    void *, unsigned int));
void wdc_default_write_raw_multi_4 __P((struct channel_softc *,
    void *, unsigned int));
d97 2
a98 2
int	wdc_obio_probe	__P((struct device *, void *, void *));
void	wdc_obio_attach	__P((struct device *, struct device *, void *));
d104 5
a108 5
int	wdc_obio_dma_init __P((void *, int, int, void *, size_t, int));
void	wdc_obio_dma_start __P((void *, int, int));
int	wdc_obio_dma_finish __P((void *, int, int));
void	wdc_obio_adjust_timing __P((struct channel_softc *));
void	wdc_obio_ata4_adjust_timing __P((struct channel_softc *));
@


1.4.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.4 2001/11/06 19:53:15 miod Exp $	*/
d78 10
a87 10
u_int8_t wdc_obio_read_reg(struct channel_softc *, enum wdc_regs);
void wdc_obio_write_reg(struct channel_softc *, enum wdc_regs, u_int8_t);
void wdc_default_read_raw_multi_2(struct channel_softc *,
    void *, unsigned int);
void wdc_default_write_raw_multi_2(struct channel_softc *,
    void *, unsigned int);
void wdc_default_read_raw_multi_4(struct channel_softc *,
    void *, unsigned int);
void wdc_default_write_raw_multi_4(struct channel_softc *,
    void *, unsigned int);
d97 2
a98 2
int	wdc_obio_probe(struct device *, void *, void *);
void	wdc_obio_attach(struct device *, struct device *, void *);
d104 5
a108 5
int	wdc_obio_dma_init(void *, int, int, void *, size_t, int);
void	wdc_obio_dma_start(void *, int, int);
int	wdc_obio_dma_finish(void *, int, int);
void	wdc_obio_adjust_timing(struct channel_softc *);
void	wdc_obio_ata4_adjust_timing(struct channel_softc *);
a367 2
		} else {
			udmamode = -2;
d378 2
a379 7
			if (drvp->drive_flags & DRIVE_UDMA) {
				if (udmamode == -2) {
					drvp->drive_flags &= ~DRIVE_UDMA;
				} else {
					drvp->UDMA_mode = udmamode;
				}
			}
a381 4

	if (udmamode == -2)
		udmamode = -1;

@


1.4.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.4.2.1 2002/06/11 03:36:34 art Exp $	*/
@


1.3
log
@reimplement dbdma such that it does memory allocations
w/ bus_dma(9) and rework drivers accordingly.
make drivers use bus_dma as well, except for if_bm (later ;) .
additionally, sync wdc_obio w/ netbsd.
drahn@@ ok, tested by miod@@, pval@@, brad@@, mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.11 2001/09/01 15:50:00 drahn dead $	*/
d45 1
a45 1
#include <vm/vm.h>
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Merge in -current
@
text
@d45 1
a45 1
#include <uvm/uvm_extern.h>
@


1.3.4.3
log
@Merge in -current from about a week ago
@
text
@d78 10
a87 10
u_int8_t wdc_obio_read_reg(struct channel_softc *, enum wdc_regs);
void wdc_obio_write_reg(struct channel_softc *, enum wdc_regs, u_int8_t);
void wdc_default_read_raw_multi_2(struct channel_softc *,
    void *, unsigned int);
void wdc_default_write_raw_multi_2(struct channel_softc *,
    void *, unsigned int);
void wdc_default_read_raw_multi_4(struct channel_softc *,
    void *, unsigned int);
void wdc_default_write_raw_multi_4(struct channel_softc *,
    void *, unsigned int);
d97 2
a98 2
int	wdc_obio_probe(struct device *, void *, void *);
void	wdc_obio_attach(struct device *, struct device *, void *);
d104 5
a108 5
int	wdc_obio_dma_init(void *, int, int, void *, size_t, int);
void	wdc_obio_dma_start(void *, int, int);
int	wdc_obio_dma_finish(void *, int, int);
void	wdc_obio_adjust_timing(struct channel_softc *);
void	wdc_obio_ata4_adjust_timing(struct channel_softc *);
@


1.3.4.4
log
@Sync the SMP branch with 3.3
@
text
@a367 2
		} else {
			udmamode = -2;
d378 2
a379 7
			if (drvp->drive_flags & DRIVE_UDMA) {
				if (udmamode == -2) {
					drvp->drive_flags &= ~DRIVE_UDMA;
				} else {
					drvp->UDMA_mode = udmamode;
				}
			}
a381 4

	if (udmamode == -2)
		udmamode = -1;

@


1.3.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.3.4.4 2003/03/27 23:29:46 niklas Exp $	*/
a108 1
void	wdc_obio_ata6_adjust_timing(struct channel_softc *);
a198 1

d200 1
a200 2
		    ca->ca_reg[3]);

a208 6
		if (strcmp(ca->ca_name, "ata-6") == 0) {
			sc->sc_wdcdev.cap |= WDC_CAPABILITY_UDMA |
			    WDC_CAPABILITY_MODE;
			sc->sc_wdcdev.UDMA_cap = 5;
			sc->sc_wdcdev.set_modes = wdc_obio_ata6_adjust_timing;
		}
a261 46
/* these number _guessed_ from linux driver. */
static u_int32_t kauai_pio_timing[] = {
	#if 1
	/*600*/	0x08000a92,	/* Mode 0 */
	/*360*/	0x08000492,	/* Mode 1 */
	/*240*/	0x0800038b,	/* Mode 2 */
	/*180*/	0x05000249,	/* Mode 3 */
	/*120*/	0x04000148	/* Mode 4 */
	#else
	/*120*/	0x06000246,	/* Mode 0 */
	/*180*/	0x06000246,	/* Mode 1 */
	/*240*/	0x06000246,	/* Mode 2 */
	/*360*/	0x06000246,	/* Mode 3 */
	/*600*/	0x06000246	/* Mode 4 */
	#endif
		
};
static u_int32_t kauai_dma_timing[] = {
	#if 1
	/*480*/	0x00618000,	/* Mode 0 */
	/*360*/	0x00492000,	/* Mode 1 */
	/*240*/	0x00149000	/* Mode 2 */ /* fw value */
	#else
	/*120*/	0x00149000,	/* Mode 0 */
	/*150*/	0x00149000,	/* Mode 1 */
	/*240*/	0x00149000	/* Mode 2 */
	#endif
};
static u_int32_t kauai_udma_timing[] = {
	#if 1
	/*120*/	0x000070c0,	/* Mode 0 */
	/* 90*/	0x00005d80,	/* Mode 1 */
	/* 60*/	0x00004a60,	/* Mode 2 */
	/* 45*/	0x00003a50,	/* Mode 3 */
	/* 30*/	0x00002a30,	/* Mode 4 */
	/* 20*/	0x00002921	/* Mode 5 */
	#else
	/*120*/	0x00002921,	/* Mode 0 */
	/* 90*/	0x00002921,	/* Mode 1 */
	/* 60*/	0x00002921,	/* Mode 2 */
	/* 45*/	0x00002921,	/* Mode 3 */
	/* 30*/	0x00002921,	/* Mode 4 */
	/* 20*/	0x00002921	/* Mode 5 */
	#endif
};

a272 8
#define KAUAI_ULTRA_CONFIG (0x210)	/* secondary config register (kauai)*/

#define KAUAI_PIO_MASK		0xff000fff
#define KAUAI_DMA_MASK		0x00fff000
#define KAUAI_UDMA_MASK		0x0000ffff
#define KAUAI_UDMA_EN		0x00000001


a424 74
#endif
}

void
wdc_obio_ata6_adjust_timing(struct channel_softc *chp)
{
	struct ata_drive_datas *drvp;
	u_int conf, conf1;
	int drive;
	int piomode = -1, dmamode = -1;
	int udmamode = -1;


	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		if ((drvp->drive_flags & DRIVE) == 0)
			continue;
		if (piomode == -1 || piomode > drvp->PIO_mode)
			piomode = drvp->PIO_mode;
		if (drvp->drive_flags & DRIVE_DMA) {
			if (dmamode == -1 || dmamode > drvp->DMA_mode)
				dmamode = drvp->DMA_mode;
		}
		if (drvp->drive_flags & DRIVE_UDMA) {
			if (udmamode == -1 || udmamode > drvp->UDMA_mode)
				udmamode = drvp->UDMA_mode;
		} else {
			udmamode = -2;
		}
	}
	if (piomode == -1)
		return; /* No drive */
	for (drive = 0; drive < 2; drive++) {
		drvp = &chp->ch_drive[drive];
		if (drvp->drive_flags & DRIVE) {
			drvp->PIO_mode = piomode;
			if (drvp->drive_flags & DRIVE_DMA)
				drvp->DMA_mode = dmamode;
			if (drvp->drive_flags & DRIVE_UDMA) {
				if (udmamode == -2) {
					drvp->drive_flags &= ~DRIVE_UDMA;
				} else {
					drvp->UDMA_mode = udmamode;
				}
			}
		}
	}

	if (udmamode == -2)
		udmamode = -1;

	conf = bus_space_read_4(chp->cmd_iot, chp->cmd_ioh, CONFIG_REG);
	conf1 = bus_space_read_4(chp->cmd_iot, chp->cmd_ioh,
	    KAUAI_ULTRA_CONFIG);

#if 1
	printf("ata6 conf old: 0x%x, %x", conf, conf1);
#endif
	conf = (conf & ~KAUAI_PIO_MASK) | kauai_pio_timing[piomode];

	if (dmamode != -1) {
		conf = (conf & ~KAUAI_DMA_MASK) | kauai_dma_timing[dmamode];
	}
	if (udmamode != -1) {
		conf1 = (conf1 & ~KAUAI_UDMA_MASK) |
		    kauai_udma_timing[udmamode] | KAUAI_UDMA_EN;
	} else 
		conf1 = conf1 & ~KAUAI_UDMA_EN;

	bus_space_write_4(chp->cmd_iot, chp->cmd_ioh, CONFIG_REG, conf);
	bus_space_write_4(chp->cmd_iot, chp->cmd_ioh, KAUAI_ULTRA_CONFIG,
	    conf1);
#if 1
	printf("new : 0x%x, %x\n", conf, conf1);
@


1.3.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a87 1

d106 1
a106 1
int	wdc_obio_dma_finish(void *, int, int, int);
d112 4
a115 1
wdc_obio_probe(struct device *parent, void *match, void *aux)
d136 3
a138 1
wdc_obio_attach(struct device *parent, struct device *self, void *aux)
d147 4
a150 2
	if (ca->ca_nreg >= 16 || ca->ca_nintr == -1)
		use_dma = 1;	/* Enable dma */
d172 1
a172 1
		printf(": DMA");
d184 2
a185 1
	    /* WDC_AUXREG_OFFSET<<4 */ 0x160, 1, &chp->ctl_ioh)) {
d194 1
a194 1
	    "wdc_obio");
d230 2
a231 3

	chp->ch_queue = malloc(sizeof(struct channel_queue), M_DEVBUF,
	    M_NOWAIT);
d273 1
d279 7
d289 1
d293 5
d300 1
d307 8
d335 2
d338 2
a339 1
wdc_obio_adjust_timing(struct channel_softc *chp)
d348 1
d355 1
a355 1
		if (drvp->drive_flags & DRIVE_DMA)
d358 1
d383 1
a383 1
		/* there are active DMA mode */
d406 2
a407 1
wdc_obio_ata4_adjust_timing(struct channel_softc *chp)
d417 1
d424 1
a424 1
		if (drvp->drive_flags & DRIVE_DMA)
d427 1
d431 1
a431 1
		} else
d433 1
d444 1
a444 1
				if (udmamode == -2)
d446 1
a446 1
				else
d448 1
d500 1
d514 1
a514 1
		} else
d516 1
d527 1
a527 1
				if (udmamode == -2)
d529 1
a529 1
				else
d531 1
d548 1
a548 1
	if (dmamode != -1)
d550 2
a551 1
	if (udmamode != -1)
d554 1
a554 1
	else 
d566 5
a570 2
wdc_obio_dma_init(void *v, int channel, int drive, void *databuf,
    size_t datalen, int flags)
d582 1
a582 1
	cmd = (flags & WDC_DMA_READ) ? DBDMA_CMD_IN_MORE : DBDMA_CMD_OUT_MORE;
d586 1
a586 3
			cmd = (flags & WDC_DMA_READ) ? DBDMA_CMD_IN_LAST :
			    DBDMA_CMD_OUT_LAST;

d599 3
a601 1
wdc_obio_dma_start(void *v, int channel, int drive)
d609 3
a611 1
wdc_obio_dma_finish(void *v, int channel, int drive, int force)
d626 3
a628 1
wdc_obio_read_reg(struct channel_softc *chp, enum wdc_regs reg)
d646 4
a649 1
wdc_obio_write_reg(struct channel_softc *chp, enum wdc_regs reg, u_int8_t val)
@


1.3.4.7
log
@Merge with the trunk
@
text
@d501 3
d517 3
@


1.2
log
@correct files for the powerpc/mac/ -> macppc/dev which did not get
renamed correctly.
@
text
@d1 2
a2 2
/*	$OpenBSD: wdc_obio.c,v 1.1 2001/09/01 15:50:00 drahn Exp $	*/
/*	$NetBSD: wdc_obio.c,v 1.4 1999/06/14 08:53:06 tsubai Exp $	*/
d64 1
a64 3
/*
 * XXX This code currently doesn't even try to allow 32-bit data port use.
 */
d70 3
d75 1
d80 1
a80 1
void wdc_default_read_raw_multi_2 __P((struct channel_softc *, 
d82 1
a82 1
void wdc_default_write_raw_multi_2 __P((struct channel_softc *, 
d84 1
a84 1
void wdc_default_read_raw_multi_4 __P((struct channel_softc *, 
d86 1
a86 1
void wdc_default_write_raw_multi_4 __P((struct channel_softc *, 
d104 5
a108 11
#if 0
struct cfdriver wdc_cd = {
	NULL, "wdc", DV_DULL
};
#endif


static int	wdc_obio_dma_init __P((void *, int, int, void *, size_t, int));
static void 	wdc_obio_dma_start __P((void *, int, int));
static int	wdc_obio_dma_finish __P((void *, int, int));
static void	adjust_timing __P((struct channel_softc *));
d142 1
a142 2
	int intr;
	int use_dma = 1;
d151 8
d195 1
d197 2
a198 1
		sc->sc_dmacmd = dbdma_alloc(sizeof(dbdma_command_t) * 20);
d201 8
a208 1
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA|WDC_CAPABILITY_UDMA;
d211 1
a211 1
	sc->sc_wdcdev.PIO_cap = 0;
d230 1
a230 5

	/* modify DMA access timings */
	if (use_dma)
		adjust_timing(chp);

d235 1
a235 1
static struct {
d238 11
a248 1
} dma_timing[3] = {
d254 17
a270 1
#define TIME_TO_TICK(time) howmany((time), 30)
d275 1
a275 1
adjust_timing(chp)
d278 1
a278 2
        struct ataparams params;
	struct ata_drive_datas *drvp = &chp->ch_drive[0];	/* XXX */
d280 3
a282 2
	int mode;
	int cycle, active, min_cycle, min_active;
a284 2
	if (ata_get_params(drvp, AT_POLL, &params) != CMD_OK)
		return;
d286 23
a308 18
	for (mode = 2; mode >= 0; mode--)
		if (params.atap_dmamode_act & (1 << mode))
			goto found;

	/* No active DMA mode is found...  Do nothing. */
	return;

found:
	min_cycle = dma_timing[mode].cycle;
	min_active = dma_timing[mode].active;

#ifdef notyet
	/* Minimum cycle time is 150ns on ohare. */
	if (ohare && params.atap_dmatiming_recom < 150)
		params.atap_dmatiming_recom = 150;
#endif
	cycle = max(min_cycle, params.atap_dmatiming_recom);
	active = min_active + (cycle - min_cycle);		/* XXX */
d310 26
a335 6
	cycle_tick = TIME_TO_TICK(cycle);
	act_tick = TIME_TO_TICK(active);
	inact_tick = cycle_tick - act_tick - 1;
	if (inact_tick < 1)
		inact_tick = 1;
	half_tick = 0;	/* XXX */
a336 1
	conf = bus_space_read_4(chp->cmd_iot, chp->cmd_ioh, CONFIG_REG);
d338 1
a338 1
		conf, 0, 0, ((conf >> 11) & 0x1f), 0, ((conf >> 16) & 0x1f));
d340 70
a409 1
	conf = (half_tick << 21) | (inact_tick << 16) | (act_tick << 11);
d412 2
a413 2
	printf("conf = 0x%x, cyc = %d (%d ns), act = %d (%d ns), inact = %d\n",
	    conf, cycle_tick, cycle, act_tick, active, inact_tick);
d417 1
a417 1
static int
a424 1
	vaddr_t va = (vaddr_t)databuf;
d426 6
a431 1
	u_int cmd, offset;
d436 6
a441 23
	offset = va & PGOFSET;

	/* if va is not page-aligned, setup the first page */
	if (offset != 0) {
		int rest = NBPG - offset;	/* the rest of the page */

		if (datalen > rest) {		/* if continues to next page */
			DBDMA_BUILD(cmdp, cmd, 0, rest, vtophys(va),
				DBDMA_INT_NEVER, DBDMA_WAIT_NEVER,
				DBDMA_BRANCH_NEVER);
			datalen -= rest;
			va += rest;
			cmdp++;
		}
	}

	/* now va is page-aligned */
	while (datalen > NBPG) {
		DBDMA_BUILD(cmdp, cmd, 0, NBPG, vtophys(va),
			DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
		datalen -= NBPG;
		va += NBPG;
		cmdp++;
a443 6
	/* the last page (datalen <= NBPG here) */
	cmd = read ? DBDMA_CMD_IN_LAST : DBDMA_CMD_OUT_LAST;
	DBDMA_BUILD(cmdp, cmd, 0, datalen, vtophys(va),
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
	cmdp++;

d450 1
a450 1
static void
d457 1
a457 1
	dbdma_start(sc->sc_dmareg, sc->sc_dmacmd);
d460 1
a460 1
static int
d468 1
d475 1
a475 1
 */ 
d482 1
a482 1
#ifdef DIAGNOSTIC	
d488 1
a488 1
	if (reg & _WDC_AUX) 
d503 1
a503 1
#ifdef DIAGNOSTIC	
d509 1
a509 1
	if (reg & _WDC_AUX) 
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/mac to macppc/dev
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_obio.c,v 1.10 2001/07/09 03:30:20 mickey Exp $	*/
d55 1
a55 1
#include <macppc/mac/dbdma.h>
@

