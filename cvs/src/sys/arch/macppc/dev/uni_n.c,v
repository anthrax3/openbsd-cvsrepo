head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.8
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.17.0.10
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.6
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.16.0.6
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.10
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.8
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.15.0.26
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.24
	OPENBSD_5_0:1.15.0.22
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.20
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.18
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.14
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.16
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.12
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.6
	UBC:1.2.0.2
	UBC_BASE:1.2
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.17
date	2015.03.30.13.45.02;	author mpi;	state Exp;
branches;
next	1.16;
commitid	88XeJrckVp6enIBG;

1.16
date	2012.11.15.21.50.00;	author mpi;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.19.22.41.35;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.14.23.06.41;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.13.21.49.15;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.13.19.17.26;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.23.16.50.30;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.26.19.53.41;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.16.03.54.48;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.16.03.31.25;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.03.01.35.30;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.15.02.02.43;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.03.15.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.07.00.49.06;	author miod;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.09.01.15.50.00;	author drahn;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.10.31.03.01.15;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.06.01.06.11;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2003.06.07.11.13.14;	author ho;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	;

1.2.2.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Add defines for known offsets and magical values, map the correct page
and enable the mpic on G5 machines and finally introduce some helpers
needed for suspend/resume.  Is this called a rewrite?

In my forest since s2k11, committing now that I need this for supporting
Quad G5 machines.
@
text
@/*	$OpenBSD: uni_n.c,v 1.16 2012/11/15 21:50:00 mpi Exp $	*/

/*
 * Copyright (c) 2013 Martin Pieuchot
 * Copyright (c) 1998-2001 Dale Rahn.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>

#include <machine/bus.h>
#include <machine/autoconf.h>

#include <dev/ofw/openfirm.h>

#define UNINORTH_CLK_OFFSET	0x20
#define UNINORTH_POW_OFFSET	0x30
#define UNINORTH_STA_OFFSET	0x70
#define UNINORTH_MPIC_OFFSET	0xe0

#define UNINORTH_PCICLOCK_CTL	0x01
#define UNINORTH_ETHERNET_CTL	0x02
#define UNINORTH_FIREWIRE_CTL	0x04

#define UNINORTH_POW_NORMAL	0x00
#define UNINORTH_POW_IDLE	0x01
#define UNINORTH_POW_SLEEP	0x02

#define UNINORTH_MPIC_RESET	0x02
#define UNINORTH_MPIC_ENABLE	0x04

#define UNINORTH_SLEEPING	0x01
#define UNINORTH_RUNNING	0x02


struct memc_softc {
	struct device sc_dev;
	struct ppc_bus_space sc_membus_space;

	uint8_t *sc_baseaddr;
};

int	memcmatch(struct device *, void *, void *);
void	memcattach(struct device *, struct device *, void *);
void	memc_attach_children(struct memc_softc *sc, int memc_node);
int	memc_print(void *aux, const char *name);

struct cfdriver memc_cd = {
	NULL, "memc", DV_DULL
};

const struct cfattach memc_ca = {
	sizeof(struct memc_softc), memcmatch, memcattach
};

void memc_sleep(void);
void memc_resume(void);
uint32_t memc_read(struct memc_softc *sc, int);
void memc_write(struct memc_softc *sc, int, uint32_t);
void memc_enable(struct memc_softc *, int, uint32_t);
void memc_disable(struct memc_softc *, int, uint32_t);

int
memcmatch(struct device *parent, void *cf, void *aux)
{
	struct confargs *ca = aux;

	if (strcmp(ca->ca_name, "memc") != 0)
		return (0);

	return (1);
}

void
memcattach(struct device *parent, struct device *self, void *aux)
{
	struct memc_softc *sc = (struct memc_softc *)self;
	struct confargs *ca = aux;
	uint32_t rev, reg[2];
	char name[32];
	int len;

	OF_getprop(ca->ca_node, "reg", &reg, sizeof(reg));

	len = OF_getprop(ca->ca_node, "name", name, sizeof(name));
	if (len > 0)
		name[len] = 0;

	/* Map the first page in order to access the registers */
	if (strcmp(name, "u3") == 0 || strcmp(name, "u4") == 0)
		sc->sc_baseaddr = mapiodev(reg[1], PAGE_SIZE);
	else
		sc->sc_baseaddr = mapiodev(reg[0], PAGE_SIZE);

	/* Enable the ethernet clock */
	memc_enable(sc, UNINORTH_CLK_OFFSET, UNINORTH_ETHERNET_CTL);
	len = OF_getprop(ca->ca_node, "device-rev", &rev, sizeof(rev));
	if (len < 0)
		rev = 0;

	printf (": %s rev 0x%x\n", name, rev);

	memc_attach_children(sc, ca->ca_node);
}

void
memc_attach_children(struct memc_softc *sc, int memc_node)
{
	struct confargs ca;
	int node, namelen;
	u_int32_t reg[20];
	int32_t intr[8];
	char	name[32];

	ca.ca_iot = &sc->sc_membus_space;
	ca.ca_dmat = 0; /* XXX */
	ca.ca_baseaddr = 0; /* XXX */
	sc->sc_membus_space.bus_base = ca.ca_baseaddr;

        for (node = OF_child(memc_node); node; node = OF_peer(node)) {
		namelen = OF_getprop(node, "name", name, sizeof(name));
		if (namelen < 0)
			continue;
		if (namelen >= sizeof(name))
			continue;
		name[namelen] = 0;

		ca.ca_name = name;
		ca.ca_node = node;
		ca.ca_nreg = OF_getprop(node, "reg", reg, sizeof(reg));
		ca.ca_reg = reg;
		ca.ca_nintr = OF_getprop(node, "AAPL,interrupts", intr,
				sizeof(intr));
		if (ca.ca_nintr == -1)
			ca.ca_nintr = OF_getprop(node, "interrupts", intr,
					sizeof(intr));
		ca.ca_intr = intr;

		if (strcmp(ca.ca_name, "mpic") == 0)
			memc_enable(sc, UNINORTH_MPIC_OFFSET,
			    UNINORTH_MPIC_RESET|UNINORTH_MPIC_ENABLE);

		config_found((struct device *)sc, &ca, memc_print);
	}
}

int
memc_print(void *aux, const char *name)
{
	struct confargs *ca = aux;
	/* we dont want extra stuff printing */
	if (name)
		printf("\"%s\" at %s", ca->ca_name, name);
	if (ca->ca_nreg > 0)
		printf(" offset 0x%x", ca->ca_reg[0]);
	return UNCONF;
}

void
memc_sleep(void)
{
	struct memc_softc *sc = memc_cd.cd_devs[0];

	memc_write(sc, UNINORTH_STA_OFFSET, UNINORTH_SLEEPING);
	DELAY(10);
	memc_write(sc, UNINORTH_POW_OFFSET, UNINORTH_POW_SLEEP);
	DELAY(10);
}

void
memc_resume(void)
{
	struct memc_softc *sc = memc_cd.cd_devs[0];

	memc_write(sc, UNINORTH_POW_OFFSET, UNINORTH_POW_NORMAL);
	DELAY(10);
	memc_write(sc, UNINORTH_STA_OFFSET, UNINORTH_RUNNING);
	DELAY(100); /* XXX */
}

uint32_t
memc_read(struct memc_softc *sc, int offset)
{
	return in32(sc->sc_baseaddr + offset);
}

void
memc_write(struct memc_softc *sc, int offset, uint32_t value)
{
	out32(sc->sc_baseaddr + offset, value);
}

void
memc_enable(struct memc_softc *sc, int offset, uint32_t bits)
{
	bits |= memc_read(sc, offset);
	memc_write(sc, offset, bits);
}

void
memc_disable(struct memc_softc *sc, int offset, uint32_t bits)
{
	bits = memc_read(sc, offset) & ~bits;
	memc_write(sc, offset, bits);
}
@


1.16
log
@Print UniNorth/U3 revision number, taken from opemfirmare, to know which
AGP chipset is present. This will help if some quirks are needed.

ok mikeb@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.15 2006/06/19 22:41:35 miod Exp $	*/
d4 1
d38 20
d62 1
a69 1
/* Driver definition */
d73 2
a74 2
/* Driver definition */
struct cfattach memc_ca = {
d78 6
a83 1
void uni_n_config(char *, int);
a88 1
	static int memc_attached = 0;
d90 4
a93 6
	/* allow only one instance */
	if (memc_attached == 0) {
		if (0 == strcmp (ca->ca_name, "memc"))
			return 1;
	}
	return 0;
d101 2
a102 2
	u_int32_t rev;
	char name[64];
d105 2
d111 8
a122 2
	uni_n_config(name, ca->ca_node);

d134 1
a136 2
        sc->sc_membus_space.bus_base = ca.ca_baseaddr;

d152 1
a152 1
		ca.ca_nreg  = OF_getprop(node, "reg", reg, sizeof(reg));
d154 10
a163 2
		ca.ca_nintr = 0; /* XXX */
		ca.ca_intr = NULL; /* XXX */
d182 12
a193 1
uni_n_config(char *name, int handle)
d195 32
a226 14
	char *baseaddr;
	int *ctladdr;
	u_int32_t address;

	/* sanity test */
	if (strcmp (name, "uni-n") == 0 || strcmp (name, "u3") == 0
	    || strcmp (name, "u4") == 0) {
		if (OF_getprop(handle, "reg", &address,
		    sizeof address) > 0) {
			baseaddr = mapiodev(address, NBPG);
			ctladdr = (void *)(baseaddr + 0x20);
			*ctladdr |= 0x02;
		}
	}
@


1.15
log
@Remove redundant test in uni_n_config() as well as an unused softc member;
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.14 2006/02/14 23:06:41 kettenis Exp $	*/
d76 1
d78 2
a80 2
	char name[64];
	struct memc_softc *sc = (struct memc_softc *)self;
d82 1
a82 1
	len = OF_getprop(ca->ca_node, "name", name, sizeof name);
d86 4
d92 1
a92 1
	printf (": %s\n", name);
@


1.14
log
@Put quotation marks around the names of unconfigured devices.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.13 2005/11/13 21:49:15 drahn Exp $	*/
a38 1
	char *baseaddr;
d57 1
a57 1
void *uni_n_config(int handle);
d85 1
a85 3
	if (strcmp(name, "uni-n") == 0 || strcmp(name, "u3") == 0
	    || strcmp(name, "u4") == 0)
		sc->baseaddr = uni_n_config(ca->ca_node);
a97 1
	int32_t	intr[8];
d120 1
a120 1
		ca.ca_intr = intr; /* XXX */
d138 2
a139 2
void *
uni_n_config(int handle)
a140 1
	char name[20];
d145 8
a152 11
	if (OF_getprop(handle, "name", name, sizeof name) > 0) {
		/* sanity test */
		if (strcmp (name, "uni-n") == 0 || strcmp (name, "u3") == 0
		    || strcmp (name, "u4") == 0) {
			if (OF_getprop(handle, "reg", &address,
			    sizeof address) > 0) {
				baseaddr = mapiodev(address, NBPG);
				ctladdr = (void *)(baseaddr + 0x20);
				*ctladdr |= 0x02;
				return baseaddr;
			}
a154 1
	return 0;
@


1.13
log
@match u4
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.12 2005/11/13 19:17:26 kettenis Exp $	*/
d136 1
a136 1
		printf("%s at %s", ca->ca_name, name);
@


1.12
log
@Attach children for matched controllers, not just u3.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.11 2005/10/23 16:50:30 drahn Exp $	*/
d86 2
a87 1
	if (strcmp(name, "uni-n") == 0 || strcmp(name, "u3") == 0)
d152 2
a153 1
		if (strcmp (name, "uni-n") == 0 || strcmp (name, "u3") == 0) {
@


1.11
log
@Allow devices to attach behind memory controller, u3 has secondary interrupt
controller, i2c, and dart(?)  behind it.
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.10 2005/09/26 19:53:41 kettenis Exp $	*/
d91 1
a91 2
	if (strcmp(name, "u3") == 0)
		memc_attach_children(sc, ca->ca_node);
@


1.10
log
@Match "u3" as found in G5 systems.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.9 2003/10/16 03:54:48 deraadt Exp $	*/
a36 3
static int	memcmatch(struct device *, void *, void *);
static void	memcattach(struct device *, struct device *, void *);

d40 2
d43 6
d74 1
a74 1
static void
d90 50
@


1.9
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.8 2003/10/16 03:31:25 drahn Exp $	*/
d81 1
a81 1
	if (strcmp (name, "uni-n")== 0)
d97 1
a97 1
		if (!strcmp (name, "uni-n")) {
@


1.8
log
@more ANSI/KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.7 2003/06/03 01:35:30 drahn Exp $	*/
a6 1
 *   
d26 1
a26 1
 */  
@


1.7
log
@kill clause 3 and 4 from several of my copyrights, cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.6 2002/09/15 09:01:58 deraadt Exp $	*/
d57 1
a57 4
memcmatch(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
d64 1
a64 1
		if (0 == strcmp (ca->ca_name, "memc")) {
a65 1
		}
d71 1
a71 3
memcattach(parent, self, aux)
	struct device *parent, *self;
	void   *aux;
d79 1
a79 1
	if (len > 0) {
d81 2
a82 2
	}
	if (strcmp (name, "uni-n")== 0) {
d84 1
a84 1
	}
d87 1
@


1.6
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.4 2002/03/14 03:15:55 millert Exp $	*/
d4 2
a5 1
 * Copyright (c) 1998-2001 Dale Rahn. All rights reserved.
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Dale Rahn.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.5
log
@KNF
@
text
@d71 1
a71 1
		if (0 == strcmp(ca->ca_name, "memc")) {
d92 1
a92 1
	if (strcmp(name, "uni-n")== 0) {
d95 1
a95 1
	printf(": %s\n", name);
d107 1
a107 1
		if (!strcmp(name, "uni-n")) {
@


1.4
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.3 2002/03/14 01:26:36 millert Exp $	*/
d71 1
a71 1
		if (0 == strcmp (ca->ca_name, "memc")) {
d92 1
a92 1
	if (strcmp (name, "uni-n")== 0) {
d95 1
a95 1
	printf (": %s\n", name);
d107 1
a107 1
		if (!strcmp (name, "uni-n")) {
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.2 2001/12/07 00:49:06 miod Exp $	*/
d111 1
a111 1
				ctladdr = (void*)(baseaddr + 0x20);
@


1.2
log
@In uni_n_config(), only return a base address if a base address was found.
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.1 2001/09/01 15:50:00 drahn Exp $	*/
d42 2
a43 2
static int	memcmatch __P((struct device *, void *, void *));
static void	memcattach __P((struct device *, struct device *, void *));
@


1.2.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.2 2001/12/07 00:49:06 miod Exp $	*/
d42 2
a43 2
static int	memcmatch(struct device *, void *, void *);
static void	memcattach(struct device *, struct device *, void *);
d111 1
a111 1
				ctladdr = (void *)(baseaddr + 0x20);
@


1.2.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.2.2.1 2002/06/11 03:36:34 art Exp $	*/
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/mac to macppc/dev
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.5 2001/06/29 06:55:36 drahn Exp $	*/
d113 1
a114 1
		return baseaddr;
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.4.2
log
@Merge in trunk
@
text
@a112 1
				return baseaddr;
d114 1
@


1.1.4.3
log
@Merge in -current from about a week ago
@
text
@d42 2
a43 2
static int	memcmatch(struct device *, void *, void *);
static void	memcattach(struct device *, struct device *, void *);
d111 1
a111 1
				ctladdr = (void *)(baseaddr + 0x20);
@


1.1.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uni_n.c,v 1.1.4.3 2002/03/28 10:36:01 niklas Exp $	*/
d4 1
a4 2
 * Copyright (c) 1998-2001 Dale Rahn.
 * All rights reserved.
d15 5
@


1.1.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d7 1
d27 1
a27 1
 */
d57 4
a60 1
memcmatch(struct device *parent, void *cf, void *aux)
d67 1
a67 1
		if (0 == strcmp (ca->ca_name, "memc"))
d69 1
d75 3
a77 1
memcattach(struct device *parent, struct device *self, void *aux)
d85 1
a85 1
	if (len > 0)
d87 2
a88 2

	if (strcmp (name, "uni-n")== 0)
d90 1
a90 1

a92 1

@


