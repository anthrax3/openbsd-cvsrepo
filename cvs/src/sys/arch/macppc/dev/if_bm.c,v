head	1.42;
access;
symbols
	OPENBSD_6_0:1.40.0.2
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.16
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.14
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.12
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.10
	OPENBSD_5_0:1.27.0.8
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.6
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.4
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.26.0.6
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.22.0.6
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.4
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.21.0.4
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.13
	UBC:1.5.0.2
	UBC_BASE:1.5
	SMP:1.4.0.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.42
date	2017.03.08.12.02.41;	author mpi;	state Exp;
branches;
next	1.41;
commitid	okVP7pbbXG8IxGgU;

1.41
date	2017.01.22.10.17.37;	author dlg;	state Exp;
branches;
next	1.40;
commitid	VyLWTsbepAOk7VQM;

1.40
date	2016.04.13.11.34.00;	author mpi;	state Exp;
branches;
next	1.39;
commitid	RI1iBTF6Zaycxppg;

1.39
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.38;
commitid	J9apD0jq2AjFmqZc;

1.38
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.37;
commitid	B0kwmVGiD5DVx4kv;

1.37
date	2015.11.14.17.26.40;	author mpi;	state Exp;
branches;
next	1.36;
commitid	BU9j1tIQLqhcXEX9;

1.36
date	2015.10.25.13.22.09;	author mpi;	state Exp;
branches;
next	1.35;
commitid	n8mxDftG1cK0Rpp7;

1.35
date	2015.08.24.16.38.43;	author mpi;	state Exp;
branches;
next	1.34;
commitid	1jEb4eJypOQggGU9;

1.34
date	2015.07.08.07.21.49;	author mpi;	state Exp;
branches;
next	1.33;
commitid	9ERVupAoYqW4Iok9;

1.33
date	2015.06.24.09.40.53;	author mpi;	state Exp;
branches;
next	1.32;
commitid	MVWrtktB46JRxFWT;

1.32
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.31;
commitid	hN5bFCE56DrAjl99;

1.31
date	2015.02.09.03.09.57;	author dlg;	state Exp;
branches;
next	1.30;
commitid	fE9MPAUoNdw8sZYO;

1.30
date	2015.02.08.07.00.48;	author mpi;	state Exp;
branches;
next	1.29;
commitid	pXmRFoDoWZkJGPQv;

1.29
date	2014.12.22.02.26.53;	author tedu;	state Exp;
branches;
next	1.28;
commitid	2Ez9mHW0jDzojG4V;

1.28
date	2013.10.23.10.31.19;	author mpi;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.25.20.39.36;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2009.01.11.16.54.59;	author blambert;	state Exp;
branches;
next	1.25;

1.25
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2008.10.15.19.12.19;	author blambert;	state Exp;
branches;
next	1.23;

1.23
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2007.04.22.22.31.14;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.25.22.41.41;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.09.19.22.23;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.07.06.02.33;	author martin;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.08.17.03.02;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.15.05.24.10;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.16.03.54.48;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.16.03.31.25;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.02.21.30.13;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.15.02.02.43;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.06.01.20.28;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.22.04.41.57;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.22.04.21.24;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.26.17.26.52;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.12.09.51.20;	author kjc;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.06.19.53.15;	author miod;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.09.16.03.19.30;	author drahn;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2001.09.15.01.51.11;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.01.17.43.09;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.50.00;	author drahn;	state Exp;
branches;
next	;

1.4.4.1
date	2001.10.31.03.01.15;	author nate;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2002.06.11.03.36.33;	author art;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Do not clear IFF_UP, even in the error path, clearing IFF_RUNNING
is enough.

This flag should only be set by the stack, drivers shouldn't mess
with it.

Discussed with dlg@@ and mikeb@@, ok mikeb@@, stsp@@
@
text
@/*	$OpenBSD: if_bm.c,v 1.41 2017/01/22 10:17:37 dlg Exp $	*/
/*	$NetBSD: if_bm.c,v 1.1 1999/01/01 01:27:52 tsubai Exp $	*/

/*-
 * Copyright (C) 1998, 1999 Tsubai Masanari.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/kernel.h>

#include <net/if.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <uvm/uvm_extern.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/mii_bitbang.h>

#include <dev/ofw/openfirm.h>

#include <machine/bus.h>
#include <machine/autoconf.h>

#include <macppc/dev/dbdma.h>
#include <macppc/dev/if_bmreg.h>

#define BMAC_TXBUFS	2
#define BMAC_RXBUFS	16
#define BMAC_BUFLEN	2048
#define	BMAC_BUFSZ	((BMAC_RXBUFS + BMAC_TXBUFS + 2) * BMAC_BUFLEN)

struct bmac_softc {
	struct device sc_dev;
	struct arpcom arpcom;	/* per-instance network data */
	struct timeout sc_tick_ch;
	vaddr_t sc_regs;
	bus_dma_tag_t sc_dmat;
	bus_dmamap_t sc_bufmap;
	bus_dma_segment_t sc_bufseg[1];
	dbdma_regmap_t *sc_txdma, *sc_rxdma;
	dbdma_command_t *sc_txcmd, *sc_rxcmd;
	dbdma_t sc_rxdbdma, sc_txdbdma;
	caddr_t sc_txbuf;
	paddr_t sc_txbuf_pa;
	caddr_t sc_rxbuf;
	paddr_t sc_rxbuf_pa;
	int sc_rxlast;
	int sc_flags;
	int sc_debug;
	int txcnt_outstanding;
	struct mii_data sc_mii;
};

#define BMAC_BMACPLUS	0x01

extern u_int *heathrow_FCR;

static __inline int bmac_read_reg(struct bmac_softc *, int);
static __inline void bmac_write_reg(struct bmac_softc *, int, int);
static __inline void bmac_set_bits(struct bmac_softc *, int, int);
static __inline void bmac_reset_bits(struct bmac_softc *, int, int);

static int bmac_match(struct device *, void *, void *);
static void bmac_attach(struct device *, struct device *, void *);
static void bmac_reset_chip(struct bmac_softc *);
static void bmac_init(struct bmac_softc *);
static void bmac_init_dma(struct bmac_softc *);
static int bmac_intr(void *);
static int bmac_rint(void *);
static void bmac_reset(struct bmac_softc *);
static void bmac_stop(struct bmac_softc *);
static void bmac_start(struct ifnet *);
static void bmac_transmit_packet(struct bmac_softc *, paddr_t, int);
static int bmac_put(struct bmac_softc *, caddr_t, struct mbuf *);
static struct mbuf *bmac_get(struct bmac_softc *, caddr_t, int);
static void bmac_watchdog(struct ifnet *);
static int bmac_ioctl(struct ifnet *, u_long, caddr_t);
static int bmac_mediachange(struct ifnet *);
static void bmac_mediastatus(struct ifnet *, struct ifmediareq *);
static void bmac_setladrf(struct bmac_softc *);

int bmac_mii_readreg(struct device *, int, int);
void bmac_mii_writereg(struct device *, int, int, int);
void bmac_mii_statchg(struct device *);
void bmac_mii_tick(void *);
u_int32_t bmac_mbo_read(struct device *);
void bmac_mbo_write(struct device *, u_int32_t);

struct cfattach bm_ca = {
	sizeof(struct bmac_softc), bmac_match, bmac_attach
};

struct mii_bitbang_ops bmac_mbo = {
	bmac_mbo_read, bmac_mbo_write,
	{ MIFDO, MIFDI, MIFDC, MIFDIR, 0 }
};

struct cfdriver bm_cd = {
	NULL, "bm", DV_IFNET
};

int
bmac_read_reg(struct bmac_softc *sc, int off)
{
	return in16rb(sc->sc_regs + off);
}

void
bmac_write_reg(struct bmac_softc *sc, int off, int val)
{
	out16rb(sc->sc_regs + off, val);
}

void
bmac_set_bits(struct bmac_softc *sc, int off, int val)
{
	val |= bmac_read_reg(sc, off);
	bmac_write_reg(sc, off, val);
}

void
bmac_reset_bits(struct bmac_softc *sc, int off, int val)
{
	bmac_write_reg(sc, off, bmac_read_reg(sc, off) & ~val);
}

int
bmac_match(struct device *parent, void *cf, void *aux)
{
	struct confargs *ca = aux;

	if (ca->ca_nreg < 24 || ca->ca_nintr < 12)
		return (0);

	if (strcmp(ca->ca_name, "bmac") == 0)		/* bmac */
		return (1);
	if (strcmp(ca->ca_name, "ethernet") == 0)	/* bmac+ */
		return (1);

	return (0);
}

void
bmac_attach(struct device *parent, struct device *self, void *aux)
{
	struct confargs *ca = aux;
	struct bmac_softc *sc = (void *)self;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	struct mii_data *mii = &sc->sc_mii;
	u_char laddr[6];
	int nseg, error;

	timeout_set(&sc->sc_tick_ch, bmac_mii_tick, sc);

	sc->sc_flags =0;
	if (strcmp(ca->ca_name, "ethernet") == 0) {
		sc->sc_flags |= BMAC_BMACPLUS;
	}

	ca->ca_reg[0] += ca->ca_baseaddr;
	ca->ca_reg[2] += ca->ca_baseaddr;
	ca->ca_reg[4] += ca->ca_baseaddr;

	sc->sc_regs = (vaddr_t)mapiodev(ca->ca_reg[0], NBPG);

	bmac_write_reg(sc, INTDISABLE, NoEventsMask);

	if (OF_getprop(ca->ca_node, "local-mac-address", laddr, 6) == -1 &&
	    OF_getprop(ca->ca_node, "mac-address", laddr, 6) == -1) {
		printf(": cannot get mac-address\n");
		return;
	}
	bcopy(laddr, sc->arpcom.ac_enaddr, 6);

	sc->sc_dmat = ca->ca_dmat;
	sc->sc_txdma = mapiodev(ca->ca_reg[2], 0x100);
	sc->sc_rxdma = mapiodev(ca->ca_reg[4], 0x100);
	sc->sc_txdbdma = dbdma_alloc(sc->sc_dmat, BMAC_TXBUFS);
	sc->sc_txcmd = sc->sc_txdbdma->d_addr;
	sc->sc_rxdbdma = dbdma_alloc(sc->sc_dmat, BMAC_RXBUFS + 1);
	sc->sc_rxcmd = sc->sc_rxdbdma->d_addr;

	error = bus_dmamem_alloc(sc->sc_dmat, BMAC_BUFSZ,
	    PAGE_SIZE, 0, sc->sc_bufseg, 1, &nseg, BUS_DMA_NOWAIT);
	if (error) {
		printf(": cannot allocate buffers (%d)\n", error);
		return;
	}

	error = bus_dmamem_map(sc->sc_dmat, sc->sc_bufseg, nseg,
	    BMAC_BUFSZ, &sc->sc_txbuf, BUS_DMA_NOWAIT);
	if (error) {
		printf(": cannot map buffers (%d)\n", error);
		bus_dmamem_free(sc->sc_dmat, sc->sc_bufseg, 1);
		return;
	}

	error = bus_dmamap_create(sc->sc_dmat, BMAC_BUFSZ, 1, BMAC_BUFSZ, 0,
	    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &sc->sc_bufmap);
	if (error) {
		printf(": cannot create buffer dmamap (%d)\n", error);
		bus_dmamem_unmap(sc->sc_dmat, sc->sc_txbuf, BMAC_BUFSZ);
		bus_dmamem_free(sc->sc_dmat, sc->sc_bufseg, 1);
		return;
	}

	error = bus_dmamap_load(sc->sc_dmat, sc->sc_bufmap, sc->sc_txbuf,
	    BMAC_BUFSZ, NULL, BUS_DMA_NOWAIT);
	if (error) {
		printf(": cannot load buffers dmamap (%d)\n", error);
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_bufmap);
		bus_dmamem_unmap(sc->sc_dmat, sc->sc_txbuf, BMAC_BUFSZ);
		bus_dmamem_free(sc->sc_dmat, sc->sc_bufseg, nseg);
		return;
	}

	sc->sc_txbuf_pa = sc->sc_bufmap->dm_segs->ds_addr;
	sc->sc_rxbuf = sc->sc_txbuf + BMAC_BUFLEN * BMAC_TXBUFS;
	sc->sc_rxbuf_pa = sc->sc_txbuf_pa + BMAC_BUFLEN * BMAC_TXBUFS;

	printf(" irq %d,%d: address %s\n", ca->ca_intr[0], ca->ca_intr[2],
		ether_sprintf(laddr));

	mac_intr_establish(parent, ca->ca_intr[0], IST_LEVEL, IPL_NET,
	    bmac_intr, sc, sc->sc_dev.dv_xname);
	mac_intr_establish(parent, ca->ca_intr[2], IST_LEVEL, IPL_NET,
	    bmac_rint, sc, sc->sc_dev.dv_xname);

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_ioctl = bmac_ioctl;
	ifp->if_start = bmac_start;
	ifp->if_flags =
		IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_watchdog = bmac_watchdog;

	mii->mii_ifp = ifp;
	mii->mii_readreg = bmac_mii_readreg;
	mii->mii_writereg = bmac_mii_writereg;
	mii->mii_statchg = bmac_mii_statchg;

	ifmedia_init(&mii->mii_media, 0, bmac_mediachange, bmac_mediastatus);
	mii_attach(&sc->sc_dev, mii, 0xffffffff, MII_PHY_ANY,
	    MII_OFFSET_ANY, 0);

	/* Choose a default media. */
	if (LIST_FIRST(&mii->mii_phys) == NULL) {
		ifmedia_add(&mii->mii_media, IFM_ETHER|IFM_10_T, 0, NULL);
		ifmedia_set(&mii->mii_media, IFM_ETHER|IFM_10_T);
	} else
		ifmedia_set(&mii->mii_media, IFM_ETHER|IFM_AUTO);

	bmac_reset_chip(sc);

	if_attach(ifp);
	ether_ifattach(ifp);
}

/*
 * Reset and enable bmac by heathrow FCR.
 */
void
bmac_reset_chip(struct bmac_softc *sc)
{
	u_int v;

	dbdma_reset(sc->sc_txdma);
	dbdma_reset(sc->sc_rxdma);

	v = in32rb(heathrow_FCR);

	v |= EnetEnable;
	out32rb(heathrow_FCR, v);
	delay(50000);

	/* assert reset */
	v |= ResetEnetCell;
	out32rb(heathrow_FCR, v);
	delay(50000);

	/* deassert reset */
	v &= ~ResetEnetCell;
	out32rb(heathrow_FCR, v);
	delay(50000);

	/* enable */
	v |= EnetEnable;
	out32rb(heathrow_FCR, v);
	delay(50000);

	/* make certain they stay set? */
	out32rb(heathrow_FCR, v);
	v = in32rb(heathrow_FCR);
}

void
bmac_init(struct bmac_softc *sc)
{
	struct ifnet *ifp = &sc->arpcom.ac_if;
	struct ether_header *eh;
	caddr_t data;
	int tb;
	int i, bmcr;
	u_short *p;

	bmac_reset_chip(sc);

	/* XXX */
	bmcr = bmac_mii_readreg((struct device *)sc, 0, MII_BMCR);
	bmcr &= ~BMCR_ISO;
	bmac_mii_writereg((struct device *)sc, 0, MII_BMCR, bmcr);

	bmac_write_reg(sc, RXRST, RxResetValue);
	bmac_write_reg(sc, TXRST, TxResetBit);

	/* Wait for reset completion. */
	for (i = 1000; i > 0; i -= 10) {
		if ((bmac_read_reg(sc, TXRST) & TxResetBit) == 0)
			break;
		delay(10);
	}
	if (i <= 0)
		printf("%s: reset timeout\n", ifp->if_xname);

	if (! (sc->sc_flags & BMAC_BMACPLUS))
		bmac_set_bits(sc, XCVRIF, ClkBit|SerialMode|COLActiveLow);

	tb = ppc_mftbl();
	bmac_write_reg(sc, RSEED, tb);
	bmac_set_bits(sc, XIFC, TxOutputEnable);
	bmac_read_reg(sc, PAREG);

	/* Reset various counters. */
	bmac_write_reg(sc, NCCNT, 0);
	bmac_write_reg(sc, NTCNT, 0);
	bmac_write_reg(sc, EXCNT, 0);
	bmac_write_reg(sc, LTCNT, 0);
	bmac_write_reg(sc, FRCNT, 0);
	bmac_write_reg(sc, LECNT, 0);
	bmac_write_reg(sc, AECNT, 0);
	bmac_write_reg(sc, FECNT, 0);
	bmac_write_reg(sc, RXCV, 0);

	/* Set tx fifo information. */
	bmac_write_reg(sc, TXTH, 4);	/* 4 octets before tx starts */

	bmac_write_reg(sc, TXFIFOCSR, 0);
	bmac_write_reg(sc, TXFIFOCSR, TxFIFOEnable);

	/* Set rx fifo information. */
	bmac_write_reg(sc, RXFIFOCSR, 0);
	bmac_write_reg(sc, RXFIFOCSR, RxFIFOEnable);

	/* Clear status register. */
	bmac_read_reg(sc, STATUS);

	bmac_write_reg(sc, HASH3, 0);
	bmac_write_reg(sc, HASH2, 0);
	bmac_write_reg(sc, HASH1, 0);
	bmac_write_reg(sc, HASH0, 0);

	/* Set MAC address. */
	p = (u_short *)sc->arpcom.ac_enaddr;
	bmac_write_reg(sc, MADD0, *p++);
	bmac_write_reg(sc, MADD1, *p++);
	bmac_write_reg(sc, MADD2, *p);

	bmac_write_reg(sc, RXCFG,
		RxCRCEnable | RxHashFilterEnable | RxRejectOwnPackets);

	if (ifp->if_flags & IFF_PROMISC)
		bmac_set_bits(sc, RXCFG, RxPromiscEnable);

	bmac_init_dma(sc);

	/* Configure Media. */
	mii_mediachg(&sc->sc_mii);

	/* Enable TX/RX */
	bmac_set_bits(sc, RXCFG, RxMACEnable);
	bmac_set_bits(sc, TXCFG, TxMACEnable);

	bmac_write_reg(sc, INTDISABLE, NormalIntEvents);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_timer = 0;

	data = sc->sc_txbuf;
	eh = (struct ether_header *)data;

	bzero(data, sizeof(*eh) + ETHERMIN);
	bcopy(sc->arpcom.ac_enaddr, eh->ether_dhost, ETHER_ADDR_LEN);
	bcopy(sc->arpcom.ac_enaddr, eh->ether_shost, ETHER_ADDR_LEN);
	bmac_transmit_packet(sc, sc->sc_txbuf_pa, sizeof(*eh) + ETHERMIN);

	bmac_start(ifp);

	timeout_add_sec(&sc->sc_tick_ch, 1);
}

void
bmac_init_dma(struct bmac_softc *sc)
{
	dbdma_command_t *cmd = sc->sc_rxcmd;
	int i;

	dbdma_reset(sc->sc_txdma);
	dbdma_reset(sc->sc_rxdma);

	bzero(sc->sc_txcmd, BMAC_TXBUFS * sizeof(dbdma_command_t));
	bzero(sc->sc_rxcmd, (BMAC_RXBUFS + 1) * sizeof(dbdma_command_t));

	for (i = 0; i < BMAC_RXBUFS; i++) {
		DBDMA_BUILD(cmd, DBDMA_CMD_IN_LAST, 0, BMAC_BUFLEN,
			sc->sc_rxbuf_pa + BMAC_BUFLEN * i,
			DBDMA_INT_ALWAYS, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
		cmd++;
	}
	DBDMA_BUILD(cmd, DBDMA_CMD_NOP, 0, 0, 0,
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_ALWAYS);
	dbdma_st32(&cmd->d_cmddep, sc->sc_rxdbdma->d_paddr);

	sc->sc_rxlast = 0;

	dbdma_start(sc->sc_rxdma, sc->sc_rxdbdma);
}

int
bmac_intr(void *v)
{
	struct bmac_softc *sc = v;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	int stat;

#ifdef BMAC_DEBUG
	printf("bmac_intr called\n");
#endif
	stat = bmac_read_reg(sc, STATUS);
	if (stat == 0)
		return (0);

#ifdef BMAC_DEBUG
	printf("bmac_intr status = 0x%x\n", stat);
#endif

	if (stat & IntFrameSent) {
		ifq_clr_oactive(&ifp->if_snd);
		ifp->if_timer = 0;
		bmac_start(ifp);
	}

	/* XXX should do more! */

	return (1);
}

int
bmac_rint(void *v)
{
	struct bmac_softc *sc = v;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	dbdma_command_t *cmd;
	int status, resid, count, datalen;
	int i, n;
	void *data;
#ifdef BMAC_DEBUG
	printf("bmac_rint() called\n");
#endif

	i = sc->sc_rxlast;
	for (n = 0; n < BMAC_RXBUFS; n++, i++) {
		if (i == BMAC_RXBUFS)
			i = 0;
		cmd = &sc->sc_rxcmd[i];
		status = dbdma_ld16(&cmd->d_status);
		resid = dbdma_ld16(&cmd->d_resid);

#ifdef BMAC_DEBUG
		if (status != 0 && status != 0x8440 && status != 0x9440)
			printf("bmac_rint status = 0x%x\n", status);
#endif

		if ((status & DBDMA_CNTRL_ACTIVE) == 0)	/* 0x9440 | 0x8440 */
			continue;
		count = dbdma_ld16(&cmd->d_count);
		datalen = count - resid;		/* 2 == framelen */
		if (datalen < sizeof(struct ether_header)) {
			printf("%s: short packet len = %d\n",
				ifp->if_xname, datalen);
			goto next;
		}
		DBDMA_BUILD_CMD(cmd, DBDMA_CMD_STOP, 0, 0, 0, 0);
		data = sc->sc_rxbuf + BMAC_BUFLEN * i;

		/* XXX Sometimes bmac reads one extra byte. */
		if (datalen == ETHER_MAX_LEN + 1)
			datalen--;

		/* Trim the CRC. */
		datalen -= ETHER_CRC_LEN;

		m = bmac_get(sc, data, datalen);
		if (m == NULL) {
			ifp->if_ierrors++;
			goto next;
		}

		ml_enqueue(&ml, m);

next:
		DBDMA_BUILD_CMD(cmd, DBDMA_CMD_IN_LAST, 0, DBDMA_INT_ALWAYS,
			DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);

		cmd->d_status = 0;
		cmd->d_resid = 0;
		sc->sc_rxlast = i + 1;
	}
	bmac_mediachange(ifp);

	dbdma_continue(sc->sc_rxdma);

	if_input(ifp, &ml);
	return (1);
}

void
bmac_reset(struct bmac_softc *sc)
{
	int s;

	s = splnet();
	bmac_init(sc);
	splx(s);
}

void
bmac_stop(struct bmac_softc *sc)
{
	struct ifnet *ifp = &sc->arpcom.ac_if;
	int s;

	s = splnet();

	/* timeout */
	timeout_del(&sc->sc_tick_ch);
	mii_down(&sc->sc_mii);

	/* Disable TX/RX. */
	bmac_reset_bits(sc, TXCFG, TxMACEnable);
	bmac_reset_bits(sc, RXCFG, RxMACEnable);

	/* Disable all interrupts. */
	bmac_write_reg(sc, INTDISABLE, NoEventsMask);

	dbdma_stop(sc->sc_txdma);
	dbdma_stop(sc->sc_rxdma);

	ifp->if_flags &= ~IFF_RUNNING;
	ifp->if_timer = 0;

	splx(s);
}

void
bmac_start(struct ifnet *ifp)
{
	struct bmac_softc *sc = ifp->if_softc;
	struct mbuf *m;
	int tlen;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	while (1) {
		if (ifq_is_oactive(&ifp->if_snd))
			return;

		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;
#if NBPFILTER > 0
		/*
		 * If BPF is listening on this interface, let it see the
		 * packet before we commit it to the wire.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		ifq_set_oactive(&ifp->if_snd);
		tlen = bmac_put(sc, sc->sc_txbuf, m);

		/* 5 seconds to watch for failing to transmit */
		ifp->if_timer = 5;

		bmac_transmit_packet(sc, sc->sc_txbuf_pa, tlen);
	}
}

void
bmac_transmit_packet(struct bmac_softc *sc, paddr_t pa, int len)
{
	dbdma_command_t *cmd = sc->sc_txcmd;

	DBDMA_BUILD(cmd, DBDMA_CMD_OUT_LAST, 0, len, pa,
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
	cmd++;
	DBDMA_BUILD(cmd, DBDMA_CMD_STOP, 0, 0, 0,
		DBDMA_INT_ALWAYS, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);

	dbdma_start(sc->sc_txdma, sc->sc_txdbdma);
}

int
bmac_put(struct bmac_softc *sc, caddr_t buff, struct mbuf *m)
{
	struct mbuf *n;
	int len, tlen = 0;

	for (; m; m = n) {
		len = m->m_len;
		if (len == 0) {
			n = m_free(m);
			continue;
		}
		bcopy(mtod(m, caddr_t), buff, len);
		buff += len;
		tlen += len;
		n = m_free(m);
	}
	if (tlen > NBPG)
		panic("%s: putpacket packet overflow", sc->sc_dev.dv_xname);

	return (tlen);
}

struct mbuf *
bmac_get(struct bmac_softc *sc, caddr_t pkt, int totlen)
{
	struct mbuf *m;
	struct mbuf *top, **mp;
	int len;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (0);
	m->m_pkthdr.len = totlen;
	len = MHLEN;
	top = 0;
	mp = &top;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				m_freem(top);
				return (0);
			}
			len = MLEN;
		}
		if (totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if ((m->m_flags & M_EXT) == 0) {
				m_free(m);
				m_freem(top);
				return (0);
			}
			len = MCLBYTES;
		}
		m->m_len = len = min(totlen, len);
		bcopy(pkt, mtod(m, caddr_t), len);
		pkt += len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return (top);
}

void
bmac_watchdog(struct ifnet *ifp)
{
	struct bmac_softc *sc = ifp->if_softc;

	bmac_reset_bits(sc, RXCFG, RxMACEnable);
	bmac_reset_bits(sc, TXCFG, TxMACEnable);

	printf("%s: device timeout\n", ifp->if_xname);
	ifp->if_oerrors++;

	bmac_reset(sc);
}

int
bmac_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct bmac_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		bmac_init(sc);
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			bmac_stop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
		    (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			bmac_init(sc);
		} else {
			/*
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
			 */
			/*bmac_stop(sc);*/
			bmac_init(sc);
		}
#ifdef BMAC_DEBUG
		if (ifp->if_flags & IFF_DEBUG)
			sc->sc_debug = 1;
		else
			sc->sc_debug = 0;
#endif
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING) {
			bmac_init(sc);
			bmac_setladrf(sc);
		}
		error = 0;
	}

	splx(s);
	return (error);
}

int
bmac_mediachange(struct ifnet *ifp)
{
	struct bmac_softc *sc = ifp->if_softc;

	return mii_mediachg(&sc->sc_mii);
}

void
bmac_mediastatus(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct bmac_softc *sc = ifp->if_softc;

	mii_pollstat(&sc->sc_mii);

	ifmr->ifm_status = sc->sc_mii.mii_media_status;
	ifmr->ifm_active = sc->sc_mii.mii_media_active;
}

/*
 * Set up the logical address filter.
 */
void
bmac_setladrf(struct bmac_softc *sc)
{
	struct arpcom *ac = &sc->arpcom;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	struct ether_multi *enm;
	struct ether_multistep step;
	u_int32_t crc;
	u_int16_t hash[4];
	int x;

	/*
	 * Set up multicast address filter by passing all multicast addresses
	 * through a crc generator, and then using the high order 6 bits as an
	 * index into the 64 bit logical address filter.  The high order bit
	 * selects the word, while the rest of the bits select the bit within
	 * the word.
	 */

	if (ifp->if_flags & IFF_PROMISC) {
		bmac_set_bits(sc, RXCFG, RxPromiscEnable);
		return;
	}

	if (ac->ac_multirangecnt > 0)
		ifp->if_flags |= IFF_ALLMULTI;

	if (ifp->if_flags & IFF_ALLMULTI) {
		hash[3] = hash[2] = hash[1] = hash[0] = 0xffff;
		goto chipit;
	}

	hash[3] = hash[2] = hash[1] = hash[0] = 0;
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		crc = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN);

		/* Just want the 6 most significant bits. */
		crc >>= 26;

		/* Set the corresponding bit in the filter. */
		hash[crc >> 4] |= 1 << (crc & 0xf);

		ETHER_NEXT_MULTI(step, enm);
	}

	ifp->if_flags &= ~IFF_ALLMULTI;

chipit:
	bmac_write_reg(sc, HASH0, hash[0]);
	bmac_write_reg(sc, HASH1, hash[1]);
	bmac_write_reg(sc, HASH2, hash[2]);
	bmac_write_reg(sc, HASH3, hash[3]);
	x = bmac_read_reg(sc, RXCFG);
	x &= ~RxPromiscEnable;
	x |= RxHashFilterEnable;
	bmac_write_reg(sc, RXCFG, x);
}

int
bmac_mii_readreg(struct device *dev, int phy, int reg)
{
	return mii_bitbang_readreg(dev, &bmac_mbo, phy, reg);
}

void
bmac_mii_writereg(struct device *dev, int phy, int reg, int val)
{
	mii_bitbang_writereg(dev, &bmac_mbo, phy, reg, val);
}

u_int32_t
bmac_mbo_read(struct device *dev)
{
	struct bmac_softc *sc = (void *)dev;

	return bmac_read_reg(sc, MIFCSR);
}

void
bmac_mbo_write(struct device *dev, u_int32_t val)
{
	struct bmac_softc *sc = (void *)dev;

	bmac_write_reg(sc, MIFCSR, val);
}

void
bmac_mii_statchg(struct device *dev)
{
	struct bmac_softc *sc = (void *)dev;
	int x;

	/* Update duplex mode in TX configuration */
	x = bmac_read_reg(sc, TXCFG);
	if ((IFM_OPTIONS(sc->sc_mii.mii_media_active) & IFM_FDX) != 0)
		x |= TxFullDuplex;
	else
		x &= ~TxFullDuplex;
	bmac_write_reg(sc, TXCFG, x);

#ifdef BMAC_DEBUG
	printf("bmac_mii_statchg 0x%x\n",
		IFM_OPTIONS(sc->sc_mii.mii_media_active));
#endif
}

void
bmac_mii_tick(void *v)
{
	struct bmac_softc *sc = v;
	int s;

	s = splnet();
	mii_tick(&sc->sc_mii);
	splx(s);

	timeout_add_sec(&sc->sc_tick_ch, 1);
}
@


1.41
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.40 2016/04/13 11:34:00 mpi Exp $	*/
d598 1
a598 1
	ifp->if_flags &= ~(IFF_UP | IFF_RUNNING);
@


1.40
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.39 2015/12/08 13:34:22 tedu Exp $	*/
a486 1
		ifp->if_opackets++;
a634 1
		ifp->if_opackets++;		/* # of pkts */
@


1.39
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.38 2015/11/25 03:09:58 dlg Exp $	*/
a272 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.38
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.37 2015/11/14 17:26:40 mpi Exp $	*/
d271 1
a271 1
		IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
@


1.37
log
@No need to include <net/bpfdesc.h>

Now that "struct bpf_d" depends on <sys/srp.h> this is one of the offender
for removing the header from <sys/param.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.36 2015/10/25 13:22:09 mpi Exp $	*/
d424 1
a424 1
	ifp->if_flags &= ~IFF_OACTIVE;
d486 1
a486 1
		ifp->if_flags &= ~IFF_OACTIVE;
d613 1
a613 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d617 1
a617 1
		if (ifp->if_flags & IFF_OACTIVE)
d632 1
a632 1
		ifp->if_flags |= IFF_OACTIVE;
@


1.36
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.35 2015/08/24 16:38:43 mpi Exp $	*/
a47 1
#include <net/bpfdesc.h>
@


1.35
log
@Workaround for slow bm(4) from NetBSD PR 33667 via Donovan Watteau on
bugs@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.34 2015/07/08 07:21:49 mpi Exp $	*/
a742 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d751 1
a751 10

		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			bmac_init(sc);
			arp_ifinit(&sc->arpcom, ifa);
			break;
		default:
			bmac_init(sc);
			break;
		}
@


1.34
log
@MFREE(9) is dead, long live m_freem(9)!

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.33 2015/06/24 09:40:53 mpi Exp $	*/
d561 2
@


1.33
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.32 2015/05/13 10:42:46 jsg Exp $	*/
d665 1
a665 1
			MFREE(m, n);
d671 1
a671 1
		MFREE(m, n);
@


1.32
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.31 2015/02/09 03:09:57 dlg Exp $	*/
a551 1
		ifp->if_ipackets++;
@


1.31
log
@tweak the new if_input function so it takes an mbuf_list instead
of a single mbuf. this forces us to batch work between the hardware
rx handlers and the stack.

this includes a converstion of bge from ether_input to if_input.

ok claudio@@ pelikan@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.30 2015/02/08 07:00:48 mpi Exp $	*/
d621 1
a621 1
		if (m == 0)
d688 1
a688 1
	if (m == 0)
d698 1
a698 1
			if (m == 0) {
@


1.30
log
@Convert to if_input().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.29 2014/12/22 02:26:53 tedu Exp $	*/
d503 1
d551 1
a551 1
		if_input(ifp, m);
d564 1
@


1.29
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.28 2013/10/23 10:31:19 mpi Exp $	*/
d550 1
a550 9
#if NBPFILTER > 0
		/*
		 * Check if there's a BPF listener on this interface.
		 * If so, hand off the raw packet to BPF.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
		ether_input_mbuf(ifp, m);
a687 1
	m->m_pkthdr.rcvif = &sc->arpcom.ac_if;
@


1.28
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not introduce any behavior change but will help changing our
representation of multicast enries.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.27 2009/08/25 20:39:36 miod Exp $	*/
a759 1
#ifdef INET
a763 1
#endif
@


1.27
log
@In bmac_init(), invoke bmac_transmit_packet() with the correct packet size
(sizeof(ptr) vs sizeof(*ptr) bug).

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.26 2009/01/11 16:54:59 blambert Exp $	*/
d850 1
d871 3
d880 1
a880 1
	ETHER_FIRST_MULTI(step, &sc->arpcom, enm);
a881 14
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			/*
			 * We must listen to a range of multicast addresses.
			 * For now, just accept all multicasts, rather than
			 * trying to set only those filter bits needed to match
			 * the range.  (At this time, the only use of address
			 * ranges is for IP multicast routing, for which the
			 * range is big enough to require all bits set.)
			 */
			hash[3] = hash[2] = hash[1] = hash[0] = 0xffff;
			ifp->if_flags |= IFF_ALLMULTI;
			goto chipit;
		}

@


1.26
log
@Actual final round of timeout_add(to, n * hz) -> timeout_add_sec(to, n)
conversions.

ok kettenis@@
ok krw@@ (possibly for the second time :)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.25 2008/11/28 02:44:17 brad Exp $	*/
d434 1
a434 1
	bmac_transmit_packet(sc, sc->sc_txbuf_pa, sizeof(eh) + ETHERMIN);
@


1.25
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.24 2008/10/15 19:12:19 blambert Exp $	*/
d438 1
a438 1
	timeout_add(&sc->sc_tick_ch, hz);
@


1.24
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.23 2008/10/02 20:21:13 brad Exp $	*/
a803 19
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING) {
				bmac_init(sc);
				bmac_setladrf(sc);
			}
			error = 0;
		}
		break;

d811 8
@


1.23
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.22 2007/04/22 22:31:14 deraadt Exp $	*/
d985 1
a985 1
	timeout_add(&sc->sc_tick_ch, hz);
@


1.22
log
@better interrupt names for vmstat -iz; ok miod gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.21 2006/03/25 22:41:41 djm Exp $	*/
a755 1

d829 1
a829 1
		error = EINVAL;
@


1.21
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.20 2005/10/09 19:22:23 brad Exp $	*/
d263 1
a263 1
	    bmac_intr, sc, "bmac intr");
d265 1
a265 1
	    bmac_rint, sc, "bmac rint");
@


1.20
log
@remove some NetBSD/OpenBSD portability cruft.

compiles ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.19 2005/10/07 06:02:33 martin Exp $	*/
d556 1
a556 1
			bpf_mtap(ifp->if_bpf, m);
d635 1
a635 1
			bpf_mtap(ifp->if_bpf, m);
@


1.19
log
@eliminate use of M_HASFCS

ok brad@@

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.18 2005/06/08 17:03:02 henning Exp $	*/
a29 4
#ifdef __NetBSD__
#include "opt_inet.h"
#include "opt_ns.h"
#endif /* __NetBSD__ */
a71 1
#ifdef __OpenBSD__
a72 7
#define sc_if arpcom.ac_if
#define	sc_enaddr arpcom.ac_enaddr
#else
	struct ethercom sc_ethercom;
#define sc_if sc_ethercom.ec_if
	u_char sc_enaddr[6];
#endif
a106 3
#ifdef WHY_IS_THIS_XXXX
static int bmac_tx_intr(void *);
#endif /* WHY_IS_THIS_XXXX */
d171 1
a171 1
		return 0;
d174 1
a174 1
		return 1;
d176 1
a176 1
		return 1;
d178 1
a178 1
	return 0;
d186 1
a186 1
	struct ifnet *ifp = &sc->sc_if;
a263 4
#ifdef WHY_IS_THIS_XXXX
	mac_intr_establish(parent, ca->ca_intr[1], IST_LEVEL, IPL_NET,
	    bmac_tx_intr, sc, "bmac_tx");
#endif /* WHY_IS_THIS_XXXX */
d338 1
a338 1
	struct ifnet *ifp = &sc->sc_if;
d402 1
a402 1
	p = (u_short *)sc->sc_enaddr;
d432 2
a433 2
	bcopy(sc->sc_enaddr, eh->ether_dhost, ETHER_ADDR_LEN);
	bcopy(sc->sc_enaddr, eh->ether_shost, ETHER_ADDR_LEN);
a467 32
#ifdef WHY_IS_THIS_XXXX
int
bmac_tx_intr(void *v)
{
	struct bmac_softc *sc = v;

	sc->sc_if.if_flags &= ~IFF_OACTIVE;
	sc->sc_if.if_timer = 0;
	sc->sc_if.if_opackets++;
	bmac_start(&sc->sc_if);

#ifndef BMAC_DEBUG
	printf("bmac_tx_intr \n");
#endif
	#if 0
	stat = bmac_read_reg(sc, STATUS);
	if (stat == 0) {
		printf("tx intr fired, but status 0\n");
		return 0;
	}


	if (stat & IntFrameSent) {
		sc->sc_if.if_flags &= ~IFF_OACTIVE;
		sc->sc_if.if_timer = 0;
		sc->sc_if.if_opackets++;
		bmac_start(&sc->sc_if);
	}
	#endif
	return 1;
}
#endif /* WHY_IS_THIS_XXXX */
d472 1
d480 1
a480 1
		return 0;
d487 4
a490 4
		sc->sc_if.if_flags &= ~IFF_OACTIVE;
		sc->sc_if.if_timer = 0;
		sc->sc_if.if_opackets++;
		bmac_start(&sc->sc_if);
d495 1
a495 1
	return 1;
d502 1
a502 1
	struct ifnet *ifp = &sc->sc_if;
a557 1
#ifdef __OpenBSD__
a558 4
#else
		m_adj(m, sizeof(struct ether_header));
		ether_input(ifp, data, m);
#endif
d571 1
a571 1
	return 1;
d587 1
a587 1
	struct ifnet *ifp = &sc->sc_if;
d683 1
a683 1
	return tlen;
d695 2
a696 2
		return 0;
	m->m_pkthdr.rcvif = &sc->sc_if;
d707 1
a707 1
				return 0;
d716 1
a716 1
				return 0;
d728 1
a728 1
	return top;
a763 1
#ifdef __OpenBSD__
a764 3
#else
			arp_ifinit(ifp, ifa);
#endif
a806 1
#if defined(__OpenBSD__)
a809 5
#else
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_ethercom) :
		    ether_delmulti(ifr, &sc->sc_ethercom);
#endif
d834 1
a834 1
	return error;
d862 1
a862 1
	struct ifnet *ifp = &sc->sc_if;
a887 1
#ifdef __OpenBSD__
a888 3
#else
	ETHER_FIRST_MULTI(step, &sc->sc_ethercom, enm);
#endif
@


1.18
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.17 2005/01/15 05:24:10 brad Exp $	*/
d590 4
a594 1

a750 3
	/* - XXX
	m->m_flags |= M_HASFCS;
	*/
@


1.17
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.16 2003/10/16 03:54:48 deraadt Exp $	*/
a824 18
#endif
#ifdef NS
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)LLADDR(ifp->if_sadl);
			else {
				bcopy(ina->x_host.c_host,
				    LLADDR(ifp->if_sadl),
				    sizeof(sc->sc_enaddr));
			}
			/* Set new address. */
			bmac_init(sc);
			break;
		    }
@


1.16
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.15 2003/10/16 03:31:25 drahn Exp $	*/
d899 4
a902 2
			bmac_init(sc);
			bmac_setladrf(sc);
@


1.15
log
@more ANSI/KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.14 2003/07/02 21:30:13 drahn Exp $	*/
d302 1
a302 1
		      MII_OFFSET_ANY, 0);
@


1.14
log
@Reduce the amount of asm code in powerpc/macppc by replacing it with
inlined functions, helps improve readability and fix a couple of bugs.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.13 2002/09/15 09:01:58 deraadt Exp $	*/
d156 1
a156 3
bmac_read_reg(sc, off)
	struct bmac_softc *sc;
	int off;
d162 1
a162 3
bmac_write_reg(sc, off, val)
	struct bmac_softc *sc;
	int off, val;
d168 1
a168 3
bmac_set_bits(sc, off, val)
	struct bmac_softc *sc;
	int off, val;
d175 1
a175 3
bmac_reset_bits(sc, off, val)
	struct bmac_softc *sc;
	int off, val;
d181 1
a181 4
bmac_match(parent, cf, aux)
	struct device *parent;
	void *cf;
	void *aux;
d197 1
a197 3
bmac_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d278 1
a278 1
		bmac_intr, sc, "bmac intr");
d281 1
a281 1
		bmac_tx_intr, sc, "bmac_tx");
d284 1
a284 1
		bmac_rint, sc, "bmac rint");
d308 1
a308 1
	} else {
a309 1
	}
d321 1
a321 2
bmac_reset_chip(sc)
	struct bmac_softc *sc;
d355 1
a355 2
bmac_init(sc)
	struct bmac_softc *sc;
d383 1
a383 1
	if (! (sc->sc_flags & BMAC_BMACPLUS)) {
a384 1
	}
d461 1
a461 2
bmac_init_dma(sc)
	struct bmac_softc *sc;
d489 1
a489 2
bmac_tx_intr(v)
	void *v;
d520 1
a520 2
bmac_intr(v)
	void *v;
d549 1
a549 2
bmac_rint(v)
	void *v;
d627 1
a627 2
bmac_reset(sc)
	struct bmac_softc *sc;
d637 1
a637 2
bmac_stop(sc)
	struct bmac_softc *sc;
d665 1
a665 2
bmac_start(ifp)
	struct ifnet *ifp;
d702 1
a702 4
bmac_transmit_packet(sc, pa, len)
	struct bmac_softc *sc;
	paddr_t pa;
	int len;
d716 1
a716 4
bmac_put(sc, buff, m)
	struct bmac_softc *sc;
	caddr_t buff;
	struct mbuf *m;
d739 1
a739 4
bmac_get(sc, pkt, totlen)
	struct bmac_softc *sc;
	caddr_t pkt;
	int totlen;
d787 1
a787 2
bmac_watchdog(ifp)
	struct ifnet *ifp;
d801 1
a801 4
bmac_ioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
d919 1
a919 2
bmac_mediachange(ifp)
	struct ifnet *ifp;
d927 1
a927 3
bmac_mediastatus(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
d941 1
a941 2
bmac_setladrf(sc)
	struct bmac_softc *sc;
d1014 1
a1014 3
bmac_mii_readreg(dev, phy, reg)
	struct device *dev;
	int phy, reg;
d1020 1
a1020 3
bmac_mii_writereg(dev, phy, reg, val)
	struct device *dev;
	int phy, reg, val;
d1026 1
a1026 2
bmac_mbo_read(dev)
	struct device *dev;
d1034 1
a1034 3
bmac_mbo_write(dev, val)
	struct device *dev;
	u_int32_t val;
d1042 1
a1042 2
bmac_mii_statchg(dev)
	struct device *dev;
d1062 1
a1062 2
bmac_mii_tick(v)
	void *v;
@


1.13
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.11 2002/09/06 01:20:28 drahn Exp $	*/
d403 1
a403 1
	__asm __volatile ("mftb %0" : "=r"(tb));
@


1.12
log
@KNF
@
text
@d288 1
a288 1
	    ether_sprintf(laddr));
d291 1
a291 1
	    bmac_intr, sc, "bmac intr");
d294 1
a294 1
	    bmac_tx_intr, sc, "bmac_tx");
d297 1
a297 1
	    bmac_rint, sc, "bmac rint");
d304 1
a304 1
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
d315 1
a315 1
	    MII_OFFSET_ANY, 0);
d444 1
a444 1
	    RxCRCEnable | RxHashFilterEnable | RxRejectOwnPackets);
d492 2
a493 2
		    sc->sc_rxbuf_pa + BMAC_BUFLEN * i,
		    DBDMA_INT_ALWAYS, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d497 1
a497 1
	    DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_ALWAYS);
d602 1
a602 1
			    ifp->if_xname, datalen);
d636 1
a636 1
		    DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d734 1
a734 1
	    DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d737 1
a737 1
	    DBDMA_INT_ALWAYS, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d1106 1
a1106 1
	    IFM_OPTIONS(sc->sc_mii.mii_media_active));
@


1.11
log
@sizeof(pointer) is not what should be used here, should be sizeof(*pointer)
pointed out by aaron.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.10 2002/08/22 04:41:57 drahn Exp $	*/
d288 1
a288 1
		ether_sprintf(laddr));
d291 1
a291 1
		bmac_intr, sc, "bmac intr");
d294 1
a294 1
		bmac_tx_intr, sc, "bmac_tx");
d297 1
a297 1
		bmac_rint, sc, "bmac rint");
d304 1
a304 1
		IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
d315 1
a315 1
		      MII_OFFSET_ANY, 0);
d444 1
a444 1
		RxCRCEnable | RxHashFilterEnable | RxRejectOwnPackets);
d492 2
a493 2
			sc->sc_rxbuf_pa + BMAC_BUFLEN * i,
			DBDMA_INT_ALWAYS, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d497 1
a497 1
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_ALWAYS);
d602 1
a602 1
				ifp->if_xname, datalen);
d636 1
a636 1
			DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d734 1
a734 1
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d737 1
a737 1
		DBDMA_INT_ALWAYS, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d1106 1
a1106 1
		IFM_OPTIONS(sc->sc_mii.mii_media_active));
@


1.10
log
@Remove code, use common ether_crc32_le() routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.9 2002/08/22 04:21:24 drahn Exp $	*/
d467 1
a467 1
	bzero(data, sizeof(eh) + ETHERMIN);
@


1.9
log
@Configure the media in the initialization routine so that media/mediaopt
fields in hostname.bm0 will work correctly. This does not fix the 100MB
receive problem, but allows media 10baseT in hostname.bm0 to set the
speed to a working speed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.8 2002/04/26 17:26:52 mickey Exp $	*/
a976 2
#define MC_POLY_LE 0xedb88320UL		/* mcast crc, little endian */

d989 1
a989 2
	int x, i, j;
	u_int8_t octet;
d1030 1
a1030 14
		crc = 0xffffffff;
		for (i = 0; i < ETHER_ADDR_LEN; i++) {
			octet = enm->enm_addrlo[i];

			for (j = 0; j < 8; j++) {
				if ((crc & 1) ^ (octet & 1)) {
					crc >>= 1;
					crc ^= MC_POLY_LE;
				}
				else
					crc >>= 1;
				octet >>= 1;
			}
		}
@


1.8
log
@properly allocate dmable memory for buffers (no malloc); drahn@@ ok and testing
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.7 2002/03/14 01:26:36 millert Exp $	*/
d450 3
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.6 2002/03/12 09:51:20 kjc Exp $	*/
d69 4
a72 3
#define BMAC_TXBUFS 2
#define BMAC_RXBUFS 16
#define BMAC_BUFLEN 2048
d88 2
d94 1
d96 1
d126 1
a126 1
static void bmac_transmit_packet(struct bmac_softc *, void *, int);
d217 1
d248 22
a269 5
	sc->sc_txbuf = malloc(BMAC_BUFLEN * BMAC_TXBUFS, M_DEVBUF, M_NOWAIT);
	sc->sc_rxbuf = malloc(BMAC_BUFLEN * BMAC_RXBUFS, M_DEVBUF, M_NOWAIT);
	if (sc->sc_txbuf == NULL || sc->sc_rxbuf == NULL ||
	    sc->sc_txcmd == NULL || sc->sc_rxcmd == NULL) {
		printf("cannot allocate memory\n");
d273 14
d467 1
a467 1
	bmac_transmit_packet(sc, data, sizeof(eh) + ETHERMIN);
d489 1
a489 1
			vtophys((vaddr_t)(sc->sc_rxbuf + BMAC_BUFLEN * i)),
d718 1
a718 1
		bmac_transmit_packet(sc, sc->sc_txbuf, tlen);
d723 1
a723 1
bmac_transmit_packet(sc, buff, len)
d725 1
a725 1
	void *buff;
a728 6
	vaddr_t va = (vaddr_t)buff;

#ifdef BMAC_DEBUG
	if (vtophys(va) + len - 1 != vtophys(va + len - 1))
		panic("bmac_transmit_packet");
#endif
d730 1
a730 1
	DBDMA_BUILD(cmd, DBDMA_CMD_OUT_LAST, 0, len, vtophys(va),
@


1.6
log
@sync with KAME
ALTQify more drivers.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.5 2001/11/06 19:53:15 miod Exp $	*/
d103 11
a113 11
static __inline int bmac_read_reg __P((struct bmac_softc *, int));
static __inline void bmac_write_reg __P((struct bmac_softc *, int, int));
static __inline void bmac_set_bits __P((struct bmac_softc *, int, int));
static __inline void bmac_reset_bits __P((struct bmac_softc *, int, int));

static int bmac_match __P((struct device *, void *, void *));
static void bmac_attach __P((struct device *, struct device *, void *));
static void bmac_reset_chip __P((struct bmac_softc *));
static void bmac_init __P((struct bmac_softc *));
static void bmac_init_dma __P((struct bmac_softc *));
static int bmac_intr __P((void *));
d115 1
a115 1
static int bmac_tx_intr __P((void *));
d117 19
a135 19
static int bmac_rint __P((void *));
static void bmac_reset __P((struct bmac_softc *));
static void bmac_stop __P((struct bmac_softc *));
static void bmac_start __P((struct ifnet *));
static void bmac_transmit_packet __P((struct bmac_softc *, void *, int));
static int bmac_put __P((struct bmac_softc *, caddr_t, struct mbuf *));
static struct mbuf *bmac_get __P((struct bmac_softc *, caddr_t, int));
static void bmac_watchdog __P((struct ifnet *));
static int bmac_ioctl __P((struct ifnet *, u_long, caddr_t));
static int bmac_mediachange __P((struct ifnet *));
static void bmac_mediastatus __P((struct ifnet *, struct ifmediareq *));
static void bmac_setladrf __P((struct bmac_softc *));

int bmac_mii_readreg __P((struct device *, int, int));
void bmac_mii_writereg __P((struct device *, int, int, int));
void bmac_mii_statchg __P((struct device *));
void bmac_mii_tick __P((void *));
u_int32_t bmac_mbo_read __P((struct device *));
void bmac_mbo_write __P((struct device *, u_int32_t));
@


1.5
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.4 2001/09/16 03:19:30 drahn Exp $	*/
d269 1
d662 1
a662 1
		IF_DEQUEUE(&ifp->if_snd, m);
@


1.5.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.5 2001/11/06 19:53:15 miod Exp $	*/
d69 3
a71 4
#define BMAC_TXBUFS	2
#define BMAC_RXBUFS	16
#define BMAC_BUFLEN	2048
#define	BMAC_BUFSZ	((BMAC_RXBUFS + BMAC_TXBUFS + 2) * BMAC_BUFLEN)
a86 2
	bus_dmamap_t sc_bufmap;
	bus_dma_segment_t sc_bufseg[1];
a90 1
	paddr_t sc_txbuf_pa;
a91 1
	paddr_t sc_rxbuf_pa;
d103 11
a113 11
static __inline int bmac_read_reg(struct bmac_softc *, int);
static __inline void bmac_write_reg(struct bmac_softc *, int, int);
static __inline void bmac_set_bits(struct bmac_softc *, int, int);
static __inline void bmac_reset_bits(struct bmac_softc *, int, int);

static int bmac_match(struct device *, void *, void *);
static void bmac_attach(struct device *, struct device *, void *);
static void bmac_reset_chip(struct bmac_softc *);
static void bmac_init(struct bmac_softc *);
static void bmac_init_dma(struct bmac_softc *);
static int bmac_intr(void *);
d115 1
a115 1
static int bmac_tx_intr(void *);
d117 19
a135 19
static int bmac_rint(void *);
static void bmac_reset(struct bmac_softc *);
static void bmac_stop(struct bmac_softc *);
static void bmac_start(struct ifnet *);
static void bmac_transmit_packet(struct bmac_softc *, paddr_t, int);
static int bmac_put(struct bmac_softc *, caddr_t, struct mbuf *);
static struct mbuf *bmac_get(struct bmac_softc *, caddr_t, int);
static void bmac_watchdog(struct ifnet *);
static int bmac_ioctl(struct ifnet *, u_long, caddr_t);
static int bmac_mediachange(struct ifnet *);
static void bmac_mediastatus(struct ifnet *, struct ifmediareq *);
static void bmac_setladrf(struct bmac_softc *);

int bmac_mii_readreg(struct device *, int, int);
void bmac_mii_writereg(struct device *, int, int, int);
void bmac_mii_statchg(struct device *);
void bmac_mii_tick(void *);
u_int32_t bmac_mbo_read(struct device *);
void bmac_mbo_write(struct device *, u_int32_t);
a211 1
	int nseg, error;
d242 5
a246 22

	error = bus_dmamem_alloc(sc->sc_dmat, BMAC_BUFSZ,
	    PAGE_SIZE, 0, sc->sc_bufseg, 1, &nseg, BUS_DMA_NOWAIT);
	if (error) {
		printf(": cannot allocate buffers (%d)\n", error);
		return;
	}

	error = bus_dmamem_map(sc->sc_dmat, sc->sc_bufseg, nseg,
	    BMAC_BUFSZ, &sc->sc_txbuf, BUS_DMA_NOWAIT);
	if (error) {
		printf(": cannot map buffers (%d)\n", error);
		bus_dmamem_free(sc->sc_dmat, sc->sc_bufseg, 1);
		return;
	}

	error = bus_dmamap_create(sc->sc_dmat, BMAC_BUFSZ, 1, BMAC_BUFSZ, 0,
	    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &sc->sc_bufmap);
	if (error) {
		printf(": cannot create buffer dmamap (%d)\n", error);
		bus_dmamem_unmap(sc->sc_dmat, sc->sc_txbuf, BMAC_BUFSZ);
		bus_dmamem_free(sc->sc_dmat, sc->sc_bufseg, 1);
a249 14
	error = bus_dmamap_load(sc->sc_dmat, sc->sc_bufmap, sc->sc_txbuf,
	    BMAC_BUFSZ, NULL, BUS_DMA_NOWAIT);
	if (error) {
		printf(": cannot load buffers dmamap (%d)\n", error);
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_bufmap);
		bus_dmamem_unmap(sc->sc_dmat, sc->sc_txbuf, BMAC_BUFSZ);
		bus_dmamem_free(sc->sc_dmat, sc->sc_bufseg, nseg);
		return;
	}

	sc->sc_txbuf_pa = sc->sc_bufmap->dm_segs->ds_addr;
	sc->sc_rxbuf = sc->sc_txbuf + BMAC_BUFLEN * BMAC_TXBUFS;
	sc->sc_rxbuf_pa = sc->sc_txbuf_pa + BMAC_BUFLEN * BMAC_TXBUFS;

a268 1
	IFQ_SET_READY(&ifp->if_snd);
d429 1
a429 1
	bmac_transmit_packet(sc, sc->sc_txbuf_pa, sizeof(eh) + ETHERMIN);
d451 1
a451 1
			sc->sc_rxbuf_pa + BMAC_BUFLEN * i,
d661 1
a661 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
d680 1
a680 1
		bmac_transmit_packet(sc, sc->sc_txbuf_pa, tlen);
d685 1
a685 1
bmac_transmit_packet(sc, pa, len)
d687 1
a687 1
	paddr_t pa;
d691 6
d698 1
a698 1
	DBDMA_BUILD(cmd, DBDMA_CMD_OUT_LAST, 0, len, pa,
@


1.5.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.5.2.1 2002/06/11 03:36:33 art Exp $	*/
a450 3
	/* Configure Media. */
	mii_mediachg(&sc->sc_mii);

d464 1
a464 1
	bzero(data, sizeof(*eh) + ETHERMIN);
d974 2
d988 2
a989 1
	int x;
d1030 14
a1043 1
		crc = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN);
@


1.4
log
@Update the bmac (if_bm) to a newer version from NetBSD.
Now uses mii/mii_bitbang.
Driver still has performance issues, It does not transfer
as fast data as it should. No worse than before.
Need to investigate a dhclient reported error:
'ip length 331 disagrees with bytes recieved 336'. only on if_bm.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.3 2001/09/15 01:51:11 mickey Exp $	*/
d55 1
a55 1
#include <vm/vm.h>
@


1.4.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4.4.2
log
@Merge in -current
@
text
@d55 1
a55 1
#include <uvm/uvm_extern.h>
@


1.4.4.3
log
@Merge in -current from about a week ago
@
text
@d103 11
a113 11
static __inline int bmac_read_reg(struct bmac_softc *, int);
static __inline void bmac_write_reg(struct bmac_softc *, int, int);
static __inline void bmac_set_bits(struct bmac_softc *, int, int);
static __inline void bmac_reset_bits(struct bmac_softc *, int, int);

static int bmac_match(struct device *, void *, void *);
static void bmac_attach(struct device *, struct device *, void *);
static void bmac_reset_chip(struct bmac_softc *);
static void bmac_init(struct bmac_softc *);
static void bmac_init_dma(struct bmac_softc *);
static int bmac_intr(void *);
d115 1
a115 1
static int bmac_tx_intr(void *);
d117 19
a135 19
static int bmac_rint(void *);
static void bmac_reset(struct bmac_softc *);
static void bmac_stop(struct bmac_softc *);
static void bmac_start(struct ifnet *);
static void bmac_transmit_packet(struct bmac_softc *, void *, int);
static int bmac_put(struct bmac_softc *, caddr_t, struct mbuf *);
static struct mbuf *bmac_get(struct bmac_softc *, caddr_t, int);
static void bmac_watchdog(struct ifnet *);
static int bmac_ioctl(struct ifnet *, u_long, caddr_t);
static int bmac_mediachange(struct ifnet *);
static void bmac_mediastatus(struct ifnet *, struct ifmediareq *);
static void bmac_setladrf(struct bmac_softc *);

int bmac_mii_readreg(struct device *, int, int);
void bmac_mii_writereg(struct device *, int, int, int);
void bmac_mii_statchg(struct device *);
void bmac_mii_tick(void *);
u_int32_t bmac_mbo_read(struct device *);
void bmac_mbo_write(struct device *, u_int32_t);
a268 1
	IFQ_SET_READY(&ifp->if_snd);
d661 1
a661 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.4.4.4
log
@Sync the SMP branch with 3.3
@
text
@d69 3
a71 4
#define BMAC_TXBUFS	2
#define BMAC_RXBUFS	16
#define BMAC_BUFLEN	2048
#define	BMAC_BUFSZ	((BMAC_RXBUFS + BMAC_TXBUFS + 2) * BMAC_BUFLEN)
a86 2
	bus_dmamap_t sc_bufmap;
	bus_dma_segment_t sc_bufseg[1];
a90 1
	paddr_t sc_txbuf_pa;
a91 1
	paddr_t sc_rxbuf_pa;
d121 1
a121 1
static void bmac_transmit_packet(struct bmac_softc *, paddr_t, int);
a211 1
	int nseg, error;
d242 5
a246 32

	error = bus_dmamem_alloc(sc->sc_dmat, BMAC_BUFSZ,
	    PAGE_SIZE, 0, sc->sc_bufseg, 1, &nseg, BUS_DMA_NOWAIT);
	if (error) {
		printf(": cannot allocate buffers (%d)\n", error);
		return;
	}

	error = bus_dmamem_map(sc->sc_dmat, sc->sc_bufseg, nseg,
	    BMAC_BUFSZ, &sc->sc_txbuf, BUS_DMA_NOWAIT);
	if (error) {
		printf(": cannot map buffers (%d)\n", error);
		bus_dmamem_free(sc->sc_dmat, sc->sc_bufseg, 1);
		return;
	}

	error = bus_dmamap_create(sc->sc_dmat, BMAC_BUFSZ, 1, BMAC_BUFSZ, 0,
	    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &sc->sc_bufmap);
	if (error) {
		printf(": cannot create buffer dmamap (%d)\n", error);
		bus_dmamem_unmap(sc->sc_dmat, sc->sc_txbuf, BMAC_BUFSZ);
		bus_dmamem_free(sc->sc_dmat, sc->sc_bufseg, 1);
		return;
	}

	error = bus_dmamap_load(sc->sc_dmat, sc->sc_bufmap, sc->sc_txbuf,
	    BMAC_BUFSZ, NULL, BUS_DMA_NOWAIT);
	if (error) {
		printf(": cannot load buffers dmamap (%d)\n", error);
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_bufmap);
		bus_dmamem_unmap(sc->sc_dmat, sc->sc_txbuf, BMAC_BUFSZ);
		bus_dmamem_free(sc->sc_dmat, sc->sc_bufseg, nseg);
a249 4
	sc->sc_txbuf_pa = sc->sc_bufmap->dm_segs->ds_addr;
	sc->sc_rxbuf = sc->sc_txbuf + BMAC_BUFLEN * BMAC_TXBUFS;
	sc->sc_rxbuf_pa = sc->sc_txbuf_pa + BMAC_BUFLEN * BMAC_TXBUFS;

a413 3
	/* Configure Media. */
	mii_mediachg(&sc->sc_mii);

d427 1
a427 1
	bzero(data, sizeof(*eh) + ETHERMIN);
d430 1
a430 1
	bmac_transmit_packet(sc, sc->sc_txbuf_pa, sizeof(eh) + ETHERMIN);
d452 1
a452 1
			sc->sc_rxbuf_pa + BMAC_BUFLEN * i,
d681 1
a681 1
		bmac_transmit_packet(sc, sc->sc_txbuf_pa, tlen);
d686 1
a686 1
bmac_transmit_packet(sc, pa, len)
d688 1
a688 1
	paddr_t pa;
d692 1
d694 6
a699 1
	DBDMA_BUILD(cmd, DBDMA_CMD_OUT_LAST, 0, len, pa,
d943 2
d957 2
a958 1
	int x;
d999 14
a1012 1
		crc = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN);
@


1.4.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d156 3
a158 1
bmac_read_reg(struct bmac_softc *sc, int off)
d164 3
a166 1
bmac_write_reg(struct bmac_softc *sc, int off, int val)
d172 3
a174 1
bmac_set_bits(struct bmac_softc *sc, int off, int val)
d181 3
a183 1
bmac_reset_bits(struct bmac_softc *sc, int off, int val)
d189 4
a192 1
bmac_match(struct device *parent, void *cf, void *aux)
d208 3
a210 1
bmac_attach(struct device *parent, struct device *self, void *aux)
d291 1
a291 1
	    bmac_intr, sc, "bmac intr");
d294 1
a294 1
	    bmac_tx_intr, sc, "bmac_tx");
d297 1
a297 1
	    bmac_rint, sc, "bmac rint");
d315 1
a315 1
	    MII_OFFSET_ANY, 0);
d321 1
a321 1
	} else
d323 1
d335 2
a336 1
bmac_reset_chip(struct bmac_softc *sc)
d370 2
a371 1
bmac_init(struct bmac_softc *sc)
d399 1
a399 1
	if (! (sc->sc_flags & BMAC_BMACPLUS))
d401 1
d403 1
a403 1
	tb = ppc_mftbl();
d478 2
a479 1
bmac_init_dma(struct bmac_softc *sc)
d507 2
a508 1
bmac_tx_intr(void *v)
d539 2
a540 1
bmac_intr(void *v)
d569 2
a570 1
bmac_rint(void *v)
d648 2
a649 1
bmac_reset(struct bmac_softc *sc)
d659 2
a660 1
bmac_stop(struct bmac_softc *sc)
d688 2
a689 1
bmac_start(struct ifnet *ifp)
d726 4
a729 1
bmac_transmit_packet(struct bmac_softc *sc, paddr_t pa, int len)
d743 4
a746 1
bmac_put(struct bmac_softc *sc, caddr_t buff, struct mbuf *m)
d769 4
a772 1
bmac_get(struct bmac_softc *sc, caddr_t pkt, int totlen)
d820 2
a821 1
bmac_watchdog(struct ifnet *ifp)
d835 4
a838 1
bmac_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
d956 2
a957 1
bmac_mediachange(struct ifnet *ifp)
d965 3
a967 1
bmac_mediastatus(struct ifnet *ifp, struct ifmediareq *ifmr)
d981 2
a982 1
bmac_setladrf(struct bmac_softc *sc)
d1055 3
a1057 1
bmac_mii_readreg(struct device *dev, int phy, int reg)
d1063 3
a1065 1
bmac_mii_writereg(struct device *dev, int phy, int reg, int val)
d1071 2
a1072 1
bmac_mbo_read(struct device *dev)
d1080 3
a1082 1
bmac_mbo_write(struct device *dev, u_int32_t val)
d1090 2
a1091 1
bmac_mii_statchg(struct device *dev)
d1111 2
a1112 1
bmac_mii_tick(void *v)
@


1.3
log
@reimplement dbdma such that it does memory allocations
w/ bus_dma(9) and rework drivers accordingly.
make drivers use bus_dma as well, except for if_bm (later ;) .
additionally, sync wdc_obio w/ netbsd.
drahn@@ ok, tested by miod@@, pval@@, brad@@, mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.2 2001/09/01 17:43:09 drahn Exp $	*/
d42 2
d57 4
d84 1
a84 1
	struct ifmedia sc_media;
d96 1
d129 7
a135 5
void bmac_init_mif __P((struct bmac_softc *sc));
u_int bmac_mif_readbits __P((struct bmac_softc *sc, int nb));
void bmac_mif_writebits __P((struct bmac_softc *sc, u_int val, int nb));
u_int bmac_mif_read __P((struct bmac_softc *sc, u_int addr));
void bmac_mif_write __P((struct bmac_softc *sc, u_int addr, u_int val));
d141 5
d210 1
d213 2
d270 16
a285 3
	ifmedia_init(&sc->sc_media, 0, bmac_mediachange, bmac_mediastatus);
	ifmedia_add(&sc->sc_media, IFM_ETHER|IFM_10_T, 0, NULL);
	ifmedia_set(&sc->sc_media, IFM_ETHER|IFM_10_T);
d314 1
a314 1
	delay(70000);
d339 1
a341 1
	bmac_init_mif(sc);
d344 5
d353 7
a359 3
	do {
		delay(10000); 
	} while (bmac_read_reg(sc, TXRST) & TxResetBit);
a362 1
		delay(100);
d432 2
d558 1
a558 1
		datalen = count - resid;
d566 4
d626 4
d746 3
d909 1
a909 1
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
d924 3
a926 1
	return EINVAL;
d934 3
a936 2
	if ((ifp->if_flags & IFF_UP) == 0)
		return;
d938 2
a939 2
	ifmr->ifm_status = IFM_AVALID;
	ifmr->ifm_status |= IFM_ACTIVE;
a941 1
#define MC_POLY_BE 0x04c11db7UL		/* mcast crc, big endian */
a953 1
	int i, j;
d956 1
a966 3
	if (ifp->if_flags & IFF_ALLMULTI)
		goto allmulti;

d969 6
a974 1
		goto allmulti;
d993 3
a995 1
			goto allmulti;
d1021 1
a1021 4
	bmac_write_reg(sc, HASH3, hash[3]);
	bmac_write_reg(sc, HASH2, hash[2]);
	bmac_write_reg(sc, HASH1, hash[1]);
	bmac_write_reg(sc, HASH0, hash[0]);
a1022 1
	return;
d1024 9
a1032 6
allmulti:
	ifp->if_flags |= IFF_ALLMULTI;
	bmac_write_reg(sc, HASH3, 0xffff);
	bmac_write_reg(sc, HASH2, 0xffff);
	bmac_write_reg(sc, HASH1, 0xffff);
	bmac_write_reg(sc, HASH0, 0xffff);
d1035 7
a1041 1
#define MIFDELAY	delay(1)
d1043 4
a1046 4
u_int
bmac_mif_readbits(sc, nb)
	struct bmac_softc *sc;
	int nb;
d1048 1
a1048 15
	unsigned int val = 0;

	while (--nb >= 0) {
		bmac_write_reg(sc, MIFCSR, 0);
		MIFDELAY;
		if (bmac_read_reg(sc, MIFCSR) & 8)
			val |= 1 << nb;
		bmac_write_reg(sc, MIFCSR, 1);
		MIFDELAY;
	}
	bmac_write_reg(sc, MIFCSR, 0);
	MIFDELAY;
	bmac_write_reg(sc, MIFCSR, 1);
	MIFDELAY;
	return val;
d1051 3
a1053 5
void
bmac_mif_writebits(sc, val, nb)
	struct bmac_softc *sc;
	u_int val;
	int nb;
d1055 1
a1055 1
	int b;
d1057 1
a1057 7
	while (--nb >= 0) {
		b = (val & (1 << nb))? 6: 4;
		bmac_write_reg(sc, MIFCSR, b);
		MIFDELAY;
		bmac_write_reg(sc, MIFCSR, b|1);
		MIFDELAY;
	}
d1060 4
a1063 4
u_int
bmac_mif_read(sc, addr)
	struct bmac_softc *sc;
	u_int addr;
d1065 1
a1065 1
	u_int val;
d1067 1
a1067 14
	bmac_write_reg(sc, MIFCSR, 4);
	MIFDELAY;
	bmac_mif_writebits(sc, ~0U, 32);
	bmac_mif_writebits(sc, 6, 4);
	bmac_mif_writebits(sc, addr, 10);
	bmac_write_reg(sc, MIFCSR, 2);
	MIFDELAY;
	bmac_write_reg(sc, MIFCSR, 1);
	MIFDELAY;
	val = bmac_mif_readbits(sc, 17);
	bmac_write_reg(sc, MIFCSR, 4);
	MIFDELAY;
	/* printk(KERN_DEBUG "bmac_mif_read(%x) -> %x\n", addr, val); */
	return val;
d1071 2
a1072 4
bmac_mif_write(sc, addr, val)
	struct bmac_softc *sc;
	u_int addr;
	u_int val;
d1074 15
a1088 8
	bmac_write_reg(sc, MIFCSR, 4);
	MIFDELAY;
	bmac_mif_writebits(sc, ~0U, 32);
	bmac_mif_writebits(sc, 5, 4);
	bmac_mif_writebits(sc, addr, 10);
	bmac_mif_writebits(sc, 2, 2);
	bmac_mif_writebits(sc, val, 16);
	bmac_mif_writebits(sc, 3, 2);
d1092 2
a1093 2
bmac_init_mif(sc)
	struct bmac_softc *sc;
d1095 8
a1102 23
	int id;
	if (sc->sc_flags & BMAC_BMACPLUS) {
		id = bmac_mif_read(sc,2);
		switch (id) {
		case 0x7810:
			if (bmac_mif_read(sc,4) == 0xa1) {
				bmac_mif_write(sc, 0, 0x1000);
			} else {
				bmac_mif_write(sc, 4, 0xa1);
				bmac_mif_write(sc, 0, 0x1200);
			}
#if 0
			/* DEBUGGING */
			printf("mif 0 %x\n", bmac_mif_read(sc, 0));
			printf("mif 4 %x\n", bmac_mif_read(sc, 4));
#endif
			break;
		default:
			printf("bmac mif id %x not regcognized\n", id);
			/* nothing */
		}
	}
	return;
@


1.2
log
@correct files for the powerpc/mac/ -> macppc/dev which did not get
renamed correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.1 2001/09/01 15:50:00 drahn Exp $	*/
d57 1
a58 1
#include <machine/pio.h>
d80 4
a83 4
	dbdma_regmap_t *sc_txdma;
	dbdma_regmap_t *sc_rxdma;
	dbdma_command_t *sc_txcmd;
	dbdma_command_t *sc_rxcmd;
d218 1
d221 4
a224 2
	sc->sc_txcmd = dbdma_alloc(BMAC_TXBUFS * sizeof(dbdma_command_t));
	sc->sc_rxcmd = dbdma_alloc((BMAC_RXBUFS + 1) * sizeof(dbdma_command_t));
d417 1
a417 1
	dbdma_st32(&cmd->d_cmddep, vtophys((vaddr_t)sc->sc_rxcmd));
d421 1
a421 1
	dbdma_start(sc->sc_rxdma, sc->sc_rxcmd);
d656 1
a656 1
	dbdma_start(sc->sc_txdma, sc->sc_txcmd);
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/mac to macppc/dev
@
text
@d1 1
a1 1
/*	$OpenBSD: if_bm.c,v 1.9 2001/07/10 02:16:11 fgsch Exp $	*/
d60 2
a61 2
#include <macppc/mac/dbdma.h>
#include <macppc/mac/if_bmreg.h>
@

