head	1.29;
access;
symbols
	OPENBSD_6_2:1.29.0.6
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.4
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.14.0.14
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.12
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.10
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.8
	OPENBSD_5_0:1.14.0.6
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.4
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.10.0.6
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7;
locks; strict;
comment	@ * @;


1.29
date	2017.01.22.10.17.37;	author dlg;	state Exp;
branches;
next	1.28;
commitid	VyLWTsbepAOk7VQM;

1.28
date	2016.04.13.11.34.00;	author mpi;	state Exp;
branches;
next	1.27;
commitid	RI1iBTF6Zaycxppg;

1.27
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.26;
commitid	J9apD0jq2AjFmqZc;

1.26
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.25;
commitid	B0kwmVGiD5DVx4kv;

1.25
date	2015.11.24.17.11.38;	author mpi;	state Exp;
branches;
next	1.24;
commitid	5gdEnqVoJuTuwdTu;

1.24
date	2015.11.14.17.26.40;	author mpi;	state Exp;
branches;
next	1.23;
commitid	BU9j1tIQLqhcXEX9;

1.23
date	2015.10.25.13.22.09;	author mpi;	state Exp;
branches;
next	1.22;
commitid	n8mxDftG1cK0Rpp7;

1.22
date	2015.07.08.07.21.49;	author mpi;	state Exp;
branches;
next	1.21;
commitid	9ERVupAoYqW4Iok9;

1.21
date	2015.06.24.09.40.53;	author mpi;	state Exp;
branches;
next	1.20;
commitid	MVWrtktB46JRxFWT;

1.20
date	2015.02.09.03.09.57;	author dlg;	state Exp;
branches;
next	1.19;
commitid	fE9MPAUoNdw8sZYO;

1.19
date	2015.02.08.07.00.48;	author mpi;	state Exp;
branches;
next	1.18;
commitid	pXmRFoDoWZkJGPQv;

1.18
date	2014.12.22.02.26.53;	author tedu;	state Exp;
branches;
next	1.17;
commitid	2Ez9mHW0jDzojG4V;

1.17
date	2014.07.22.10.35.35;	author mpi;	state Exp;
branches;
next	1.16;
commitid	EXpEDqO4x724IPl8;

1.16
date	2013.10.23.10.31.19;	author mpi;	state Exp;
branches;
next	1.15;

1.15
date	2013.08.07.22.22.42;	author bluhm;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.21.03.03.26;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2008.10.08.23.53.08;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.22.22.31.14;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.02.21.46.30;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.23.17.17.23;	author gwk;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.03.06.57.54;	author gwk;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.31.20.53.04;	author gwk;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.14.00.17.40;	author gwk;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.20.13.10.27;	author xsa;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.08.03.51.50;	author gwk;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.06.23.27.54;	author gwk;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.05.06.25.34;	author gwk;	state Exp;
branches;
next	;


desc
@@


1.29
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_mc.c,v 1.28 2016/04/13 11:34:00 mpi Exp $	*/
/*	$NetBSD: if_mc.c,v 1.9.16.1 2006/06/21 14:53:13 yamt Exp $	*/

/*-
 * Copyright (c) 1997 David Huang <khym@@bga.com>
 * All rights reserved.
 *
 * Portions of this code are based on code by Denton Gentry <denny1@@home.com>
 * and Yanagisawa Takeshi <yanagisw@@aa.ap.titech.ac.jp>.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 * AMD AM79C940 (MACE) driver with DBDMA bus attachment and DMA routines 
 * for onboard ethernet found on most old world macs. 
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/buf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <dev/ofw/openfirm.h>
#include <machine/pio.h>
#include <machine/bus.h>
#include <machine/autoconf.h>

#include <macppc/dev/dbdma.h>

#define MC_REGSPACING   	16
#define MC_REGSIZE      	MACE_NREGS * MC_REGSPACING
#define MACE_REG(x)     	((x)*MC_REGSPACING)
#define MACE_BUFLEN		2048
#define MACE_TXBUFS		2
#define MACE_RXBUFS		8

#define MC_RXDMABUFS		4

#define MACE_BUFSZ       	((MACE_RXBUFS + MACE_TXBUFS + 2) * MACE_BUFLEN)

#define NIC_GET(sc, reg)	(in8rb(sc->sc_reg + MACE_REG(reg)))

#define NIC_PUT(sc, reg, val)   (out8rb(sc->sc_reg + MACE_REG(reg), (val)))

/*
 * AMD MACE (Am79C940) register definitions
 */
#define	MACE_RCVFIFO		0   /* Receive FIFO [15-00] (read only) */
#define	MACE_XMTFIFO		1   /* Transmit FIFO [15-00] (write only) */
#define	MACE_XMTFC		2   /* Transmit Frame Control (read/write) */
#define	MACE_XMTFS		3   /* Transmit Frame Status (read only) */
#define	MACE_XMTRC		4   /* Transmit Retry Count (read only) */
#define	MACE_RCVFC		5   /* Receive Frame Control (read/write) */
#define	MACE_RCVFS		6   /* Receive Frame Status (4 bytes) (read only) */
#define	MACE_FIFOFC		7   /* FIFO Frame Count (read only) */
#define	MACE_IR			8   /* Interrupt Register (read only) */
#define	MACE_IMR		9   /* Interrupt Mask Register (read/write) */
#define	MACE_PR			10  /* Poll Register (read only) */
#define	MACE_BIUCC		11  /* BIU Configuration Control (read/write) */
#define	MACE_FIFOCC		12  /* FIFO Configuration Control (read/write) */
#define	MACE_MACCC		13  /* MAC Configuration Control (read/write) */
#define	MACE_PLSCC		14  /* PLS Configuration Control (read/write) */
#define	MACE_PHYCC		15  /* PHY Confiuration Control (read/write) */
#define	MACE_CHIPIDL		16  /* Chip ID Register [07-00] (read only) */
#define	MACE_CHIPIDH		17  /* Chip ID Register [15-08] (read only) */
#define	MACE_IAC		18  /* Internal Address Configuration (read/write) */
/*	RESERVED		19     Reserved (read/write as 0) */
#define	MACE_LADRF		20  /* Logical Address Filter (8 bytes) (read/write) */
#define	MACE_PADR		21  /* Physical Address (6 bytes) (read/write) */
/*	RESERVED		22     Reserved (read/write as 0) */
/*	RESERVED		23     Reserved (read/write as 0) */
#define	MACE_MPC		24  /* Missed Packet Count (read only) */
/*	RESERVED		25     Reserved (read/write as 0) */
#define	MACE_RNTPC		26  /* Runt Packet Count (read only) */
#define	MACE_RCVCC		27  /* Receive Collision Count (read only) */
/*	RESERVED		28     Reserved (read/write as 0) */
#define	MACE_UTR		29  /* User Test Register (read/write) */
#define	MACE_RTR1		30  /* Reserved Test Register 1 (read/write as 0) */
#define	MACE_RTR2		31  /* Reserved Test Register 2 (read/write as 0) */

#define	MACE_NREGS		32

/* 2: Transmit Frame Control (XMTFC) */
#define	DRTRY			0x80	/* Disable Retry */
#define	DXMTFCS			0x08	/* Disable Transmit FCS */
#define	APADXMT			0x01	/* Auto Pad Transmit */

/* 3: Transmit Frame Status (XMTFS) */
#define	XMTSV			0x80	/* Transmit Status Valid */
#define	UFLO			0x40	/* Underflow */
#define	LCOL			0x20	/* Late Collision */
#define	MORE			0x10	/* More than one retry needed */
#define	ONE			0x08	/* Exactly one retry needed */
#define	DEFER			0x04	/* Transmission deferred */
#define	LCAR			0x02	/* Loss of Carrier */
#define	RTRY			0x01	/* Retry Error */

/* 4: Transmit Retry Count (XMTRC) */
#define	EXDEF			0x80	/* Excessive Defer */
#define	XMTRC			0x0f	/* Transmit Retry Count */

/* 5: Receive Frame Control (RCVFC) */
#define	LLRCV			0x08	/* Low Latency Receive */
#define	MR			0x04	/* Match/Reject */
#define	ASTRPRCV		0x01	/* Auto Strip Receive */

/* 6: Receive Frame Status (RCVFS) */
/* 4 byte register; read 4 times to get all of the bytes */
/* Read 1: RFS0 - Receive Message Byte Count [7-0] (RCVCNT) */

/* Read 2: RFS1 - Receive Status (RCVSTS) */
#define	OFLO			0x80	/* Overflow flag */
#define	CLSN			0x40	/* Collision flag */
#define	FRAM			0x20	/* Framing Error flag */
#define	FCS			0x10	/* FCS Error flag */
#define	RCVCNT			0x0f	/* Receive Message Byte Count [11-8] */

/* Read 3: RFS2 - Runt Packet Count (RNTPC) [7-0] */

/* Read 4: RFS3 - Receive Collision Count (RCVCC) [7-0] */

/* 7: FIFO Frame Count (FIFOFC) */
#define	RCVFC			0xf0	/* Receive Frame Count */
#define	XMTFC			0x0f	/* Transmit Frame Count */

/* 8: Interrupt Register (IR) */
#define	JAB			0x80	/* Jabber Error */
#define	BABL			0x40	/* Babble Error */
#define	CERR			0x20	/* Collision Error */
#define	RCVCCO			0x10	/* Receive Collision Count Overflow */
#define	RNTPCO			0x08	/* Runt Packet Count Overflow */
#define	MPCO			0x04	/* Missed Packet Count Overflow */
#define	RCVINT			0x02	/* Receive Interrupt */
#define	XMTINT			0x01	/* Transmit Interrupt */

/* 9: Interrut Mask Register (IMR) */
#define	JABM			0x80	/* Jabber Error Mask */
#define	BABLM			0x40	/* Babble Error Mask */
#define	CERRM			0x20	/* Collision Error Mask */
#define	RCVCCOM			0x10	/* Receive Collision Count Overflow Mask */
#define	RNTPCOM			0x08	/* Runt Packet Count Overflow Mask */
#define	MPCOM			0x04	/* Missed Packet Count Overflow Mask */
#define	RCVINTM			0x02	/* Receive Interrupt Mask */
#define	XMTINTM			0x01	/* Transmit Interrupt Mask */

/* 10: Poll Register (PR) */
#define	XMTSV			0x80	/* Transmit Status Valid */
#define	TDTREQ			0x40	/* Transmit Data Transfer Request */
#define	RDTREQ			0x20	/* Receive Data Transfer Request */

/* 11: BIU Configuration Control (BIUCC) */
#define	BSWP			0x40	/* Byte Swap */
#define	XMTSP			0x30	/* Transmit Start Point */
#define	XMTSP_4			0x00	/* 4 bytes */
#define	XMTSP_16		0x10	/* 16 bytes */
#define	XMTSP_64		0x20	/* 64 bytes */
#define	XMTSP_112		0x30	/* 112 bytes */
#define	SWRST			0x01	/* Software Reset */

/* 12: FIFO Configuration Control (FIFOCC) */
#define	XMTFW			0xc0	/* Transmit FIFO Watermark */
#define	XMTFW_8			0x00	/* 8 write cycles */
#define	XMTFW_16		0x40	/* 16 write cycles */
#define	XMTFW_32		0x80	/* 32 write cycles */
#define	RCVFW			0x30	/* Receive FIFO Watermark */
#define	RCVFW_16		0x00	/* 16 bytes */
#define	RCVFW_32		0x10	/* 32 bytes */
#define	RCVFW_64		0x20	/* 64 bytes */
#define	XMTFWU			0x08	/* Transmit FIFO Watermark Update */
#define	RCVFWU			0x04	/* Receive FIFO Watermark Update */
#define	XMTBRST			0x02	/* Transmit Burst */
#define	RCVBRST			0x01	/* Receive Burst */

/* 13: MAC Configuration (MACCC) */
#define	PROM			0x80	/* Promiscuous */
#define	DXMT2PD			0x40	/* Disable Transmit Two Part Deferral */
#define	EMBA			0x20	/* Enable Modified Back-off Algorithm */
#define	DRCVPA			0x08	/* Disable Receive Physical Address */
#define	DRCVBC			0x04	/* Disable Receive Broadcast */
#define	ENXMT			0x02	/* Enable Transmit */
#define	ENRCV			0x01	/* Enable Receive */

/* 14: PLS Configuration Control (PLSCC) */
#define	XMTSEL			0x08	/* Transmit Mode Select */
#define	PORTSEL			0x06	/* Port Select */
#define	PORTSEL_AUI		0x00	/* Select AUI */
#define	PORTSEL_10BT		0x02	/* Select 10BASE-T */
#define	PORTSEL_DAI		0x04	/* Select DAI port */
#define	PORTSEL_GPSI		0x06	/* Select GPSI */
#define	ENPLSIO			0x01	/* Enable PLS I/O */

/* 15: PHY Configuration (PHYCC) */
#define	LNKFL			0x80	/* Link Fail */
#define	DLNKTST			0x40	/* Disable Link Test */
#define	REVPOL			0x20	/* Reversed Polarity */
#define	DAPC			0x10	/* Disable Auto Polarity Correction */
#define	LRT			0x08	/* Low Receive Threshold */
#define	ASEL			0x04	/* Auto Select */
#define	RWAKE			0x02	/* Remote Wake */
#define	AWAKE			0x01	/* Auto Wake */

/* 18: Internal Address Configuration (IAC) */
#define	ADDRCHG			0x80	/* Address Change */
#define	PHYADDR			0x04	/* Physical Address Reset */
#define	LOGADDR			0x02	/* Logical Address Reset */

/* 28: User Test Register (UTR) */
#define	RTRE			0x80	/* Reserved Test Register Enable */
#define	RTRD			0x40	/* Reserved Test Register Disable */
#define	RPA			0x20	/* Run Packet Accept */
#define	FCOLL			0x10	/* Force Collision */
#define	RCVFCSE			0x08	/* Receive FCS Enable */
#define	LOOP			0x06	/* Loopback Control */
#define	LOOP_NONE		0x00	/* No Loopback */
#define	LOOP_EXT		0x02	/* External Loopback */
#define	LOOP_INT		0x04	/* Internal Loopback, excludes MENDEC */
#define	LOOP_INT_MENDEC		0x06	/* Internal Loopback, includes MENDEC */

struct mc_rxframe {
	u_int8_t		rx_rcvcnt;
	u_int8_t		rx_rcvsts;
	u_int8_t		rx_rntpc;
	u_int8_t		rx_rcvcc;
	u_char			*rx_frame;
};

struct mc_softc {
	struct device	   	sc_dev;		/* base device glue */
	struct arpcom	   	sc_arpcom;	/* Ethernet common part */
	struct timeout	  	sc_tick_ch;

	struct mc_rxframe       sc_rxframe;
	u_int8_t		sc_biucc;
	u_int8_t		sc_fifocc;
	u_int8_t		sc_plscc;
	u_int8_t		sc_enaddr[6];
	u_int8_t		sc_pad[2];
	int			sc_havecarrier; /* carrier status */

	char			*sc_reg;
	bus_dma_tag_t		sc_dmat;
	bus_dmamap_t		sc_bufmap;
	bus_dma_segment_t       sc_bufseg[1];

	dbdma_regmap_t		*sc_txdma;
	dbdma_regmap_t		*sc_rxdma;
	dbdma_command_t		*sc_txdmacmd;
	dbdma_command_t		*sc_rxdmacmd;
	dbdma_t			sc_txdbdma;
	dbdma_t			sc_rxdbdma;

	caddr_t			sc_txbuf;
	caddr_t			sc_rxbuf;
	paddr_t			sc_txbuf_pa;
	paddr_t			sc_rxbuf_pa;
	int			sc_tail;
	int			sc_rxset;
	int			sc_txset;
	int			sc_txseti;
};

int	mc_match(struct device *, void *, void *);
void	mc_attach(struct device *, struct device *, void *);

struct  cfattach mc_ca = {
	sizeof(struct mc_softc), mc_match, mc_attach
};

struct cfdriver mc_cd = {
	NULL, "mc", DV_IFNET
};

void	mc_init(struct mc_softc *sc);
void	mc_put(struct mc_softc *sc, u_int len);
int	mc_dmaintr(void *arg);
void	mc_reset_rxdma(struct mc_softc *sc);
void	mc_reset_txdma(struct mc_softc *sc);
int     mc_stop(struct mc_softc *sc);
int     mc_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data);
void    mc_start(struct ifnet *ifp);
void    mc_reset(struct mc_softc *sc);
void    mc_tint(struct mc_softc *sc);
void	mc_rint(struct mc_softc *sc);
int	mc_intr(void *);
void	mc_watchdog(struct ifnet *ifp);

u_int   maceput(struct mc_softc *sc, struct mbuf *);
void    mace_read(struct mc_softc *, caddr_t, int);
struct mbuf *mace_get(struct mc_softc *, caddr_t, int);
static void mace_calcladrf(struct mc_softc *, u_int8_t *);
void	mc_putpacket(struct mc_softc *, u_int);

int
mc_match(struct device *parent, void *arg, void *aux)
{
	struct confargs *ca = aux;

	if (strcmp(ca->ca_name, "mace") != 0)
		return 0;

	/* requires 6 regs */
	if (ca->ca_nreg / sizeof(int) != 6)
		return 0;

	/* requires 3 intrs */
	if (ca->ca_nintr / sizeof(int) != 3)
		return 0;

	return 1;
}

void
mc_attach(struct device *parent, struct device *self, void *aux)
{
	struct confargs *ca = aux;
	struct mc_softc *sc = (struct mc_softc *)self;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_int8_t lladdr[ETHER_ADDR_LEN];
	int nseg, error;

	if (OF_getprop(ca->ca_node, "local-mac-address", lladdr,
	    ETHER_ADDR_LEN) != ETHER_ADDR_LEN) {
		printf(": failed to get MAC address.\n");
		return;
	}

	ca->ca_reg[0] += ca->ca_baseaddr;
	ca->ca_reg[2] += ca->ca_baseaddr;
	ca->ca_reg[4] += ca->ca_baseaddr;

	if ((sc->sc_reg = mapiodev(ca->ca_reg[0], ca->ca_reg[1])) == NULL) {
		printf(": cannot map registers\n");
		return;
	}

	sc->sc_dmat = ca->ca_dmat;
	sc->sc_tail = 0;

	if ((sc->sc_txdma = mapiodev(ca->ca_reg[2], ca->ca_reg[3])) == NULL) {
		printf(": cannot map TX DMA registers\n");
		goto notxdma;
	}
	if ((sc->sc_rxdma = mapiodev(ca->ca_reg[4], ca->ca_reg[5])) == NULL) {
		printf(": cannot map RX DMA registers\n");
		goto norxdma;
	}
	if ((sc->sc_txdbdma = dbdma_alloc(sc->sc_dmat, 2)) == NULL) {
		printf(": cannot alloc TX DMA descriptors\n");
		goto notxdbdma;
	}
	sc->sc_txdmacmd = sc->sc_txdbdma->d_addr;

	if ((sc->sc_rxdbdma = dbdma_alloc(sc->sc_dmat, 8 + 1)) == NULL) {
		printf(": cannot alloc RX DMA descriptors\n");
		goto norxdbdma;
	}
	sc->sc_rxdmacmd = sc->sc_rxdbdma->d_addr;

	if ((error = bus_dmamem_alloc(sc->sc_dmat, MACE_BUFSZ, PAGE_SIZE, 0,
	    sc->sc_bufseg, 1, &nseg, BUS_DMA_NOWAIT))) {
		printf(": cannot allocate DMA mem (%d)\n", error);
		goto nodmamem;
	}

	if ((error = bus_dmamem_map(sc->sc_dmat, sc->sc_bufseg, nseg,
	    MACE_BUFSZ, &sc->sc_txbuf, BUS_DMA_NOWAIT))) {
		printf(": cannot map DMA mem (%d)\n", error);
		goto nodmamap;
	}

	if ((error = bus_dmamap_create(sc->sc_dmat, MACE_BUFSZ, 1, MACE_BUFSZ,
	    0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &sc->sc_bufmap))) {
		printf(": cannot create DMA map (%d)\n", error);
		goto nodmacreate;
	}

	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_bufmap, sc->sc_txbuf,
	    MACE_BUFSZ, NULL, BUS_DMA_NOWAIT))) {
		printf(": cannot load DMA map (%d)\n", error);
		goto nodmaload;
	}

	sc->sc_txbuf_pa = sc->sc_bufmap->dm_segs->ds_addr;
	sc->sc_rxbuf = sc->sc_txbuf + MACE_BUFLEN * MACE_TXBUFS;
	sc->sc_rxbuf_pa = sc->sc_txbuf_pa + MACE_BUFLEN * MACE_TXBUFS;

	printf(": irq %d,%d,%d", ca->ca_intr[0], ca->ca_intr[1],
	    ca->ca_intr[2]);

	/* disable receive DMA */
	dbdma_reset(sc->sc_rxdma);

	/* disable transmit DMA */
	dbdma_reset(sc->sc_txdma);

	/* install interrupt handlers */
	mac_intr_establish(parent, ca->ca_intr[2], IST_LEVEL, IPL_NET,
	    mc_dmaintr, sc, sc->sc_dev.dv_xname);
	mac_intr_establish(parent, ca->ca_intr[0],  IST_LEVEL, IPL_NET,
	    mc_intr, sc, sc->sc_dev.dv_xname);

	sc->sc_biucc = XMTSP_64;
	sc->sc_fifocc = XMTFW_16 | RCVFW_64 | XMTFWU | RCVFWU |
	    XMTBRST | RCVBRST;
	sc->sc_plscc = PORTSEL_GPSI | ENPLSIO;

	/* reset the chip and disable all interrupts */
	NIC_PUT(sc, MACE_BIUCC, SWRST);
	DELAY(100);

	NIC_PUT(sc, MACE_IMR, ~0);

	bcopy(lladdr, sc->sc_enaddr, ETHER_ADDR_LEN);
	bcopy(sc->sc_enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
	printf(": address %s\n", ether_sprintf(lladdr));

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_ioctl = mc_ioctl;
	ifp->if_start = mc_start;
	ifp->if_flags =
		IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_watchdog = mc_watchdog;
	ifp->if_timer = 0;

	if_attach(ifp);
	ether_ifattach(ifp);

	return;
nodmaload:
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_bufmap);
nodmacreate:
	bus_dmamem_unmap(sc->sc_dmat, sc->sc_txbuf, MACE_BUFSZ);
nodmamap:
	bus_dmamem_free(sc->sc_dmat, sc->sc_bufseg, 1);
nodmamem:
	dbdma_free(sc->sc_rxdbdma);
norxdbdma:
	dbdma_free(sc->sc_txdbdma);
notxdbdma:
	unmapiodev((void *)sc->sc_rxdma, ca->ca_reg[5]);
norxdma:
	unmapiodev((void *)sc->sc_txdma, ca->ca_reg[3]);
notxdma:
	unmapiodev(sc->sc_reg, ca->ca_reg[1]);
}

int
mc_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct mc_softc *sc = ifp->if_softc;
	int s, err = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			mc_init(sc);
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running,
			 * then stop it.
			 */
			mc_stop(sc);
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
		    (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped,
			 * then start it.
			 */
			mc_init(sc);
		} else {
			/*
			 * reset the interface to pick up any other changes
			 * in flags
			 */
			mc_reset(sc);
			mc_start(ifp);
		}
		break;

	default:
		err = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (err == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			mc_reset(sc);
		err = 0;
	}

	splx(s);
	return (err);
}

/*
 * Encapsulate a packet of type family for the local net.
 */
void
mc_start(struct ifnet *ifp)
{
	struct mc_softc	*sc = ifp->if_softc;
	struct mbuf	*m;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	while (1) {
		if (ifq_is_oactive(&ifp->if_snd))
			return;

		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			return;

#if NBPFILTER > 0
		/*
		 * If bpf is listening on this interface, let it
		 * see the packet before we commit it to the wire.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

		/*
		 * Copy the mbuf chain into the transmit buffer.
		 */
		ifq_set_oactive(&ifp->if_snd);
		maceput(sc, m);
	}
}

/*
 * reset and restart the MACE.  Called in case of fatal
 * hardware/software errors.
 */
void
mc_reset(struct mc_softc *sc)
{
	mc_stop(sc);
	mc_init(sc);
}

void
mc_init(struct mc_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_int8_t maccc, ladrf[8];
	int s, i;

	s = splnet();

	NIC_PUT(sc, MACE_BIUCC, sc->sc_biucc);
	NIC_PUT(sc, MACE_FIFOCC, sc->sc_fifocc);
	NIC_PUT(sc, MACE_IMR, ~0); /* disable all interrupts */
	NIC_PUT(sc, MACE_PLSCC, sc->sc_plscc);

	NIC_PUT(sc, MACE_UTR, RTRD); /* disable reserved test registers */

	/* set MAC address */
	NIC_PUT(sc, MACE_IAC, ADDRCHG);
	while (NIC_GET(sc, MACE_IAC) & ADDRCHG)
		;
	NIC_PUT(sc, MACE_IAC, PHYADDR);
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		out8rb(sc->sc_reg + MACE_REG(MACE_PADR) + i,
		    sc->sc_enaddr[i]);

	/* set logical address filter */
	mace_calcladrf(sc, ladrf);

	NIC_PUT(sc, MACE_IAC, ADDRCHG);
	while (NIC_GET(sc, MACE_IAC) & ADDRCHG)
		;
	NIC_PUT(sc, MACE_IAC, LOGADDR);
	for (i = 0; i < 8; i++)
		out8rb(sc->sc_reg + MACE_REG(MACE_LADRF) + i,
		    ladrf[i]);

	NIC_PUT(sc, MACE_XMTFC, APADXMT);
	/*
	* No need to autostrip padding on receive... Ethernet frames
	* don't have a length field, unlike 802.3 frames, so the MACE
	* can't figure out the length of the packet anyways.
	*/
	NIC_PUT(sc, MACE_RCVFC, 0);

	maccc = ENXMT | ENRCV;
	if (ifp->if_flags & IFF_PROMISC)
		maccc |= PROM;

	NIC_PUT(sc, MACE_MACCC, maccc);

	mc_reset_rxdma(sc);
	mc_reset_txdma(sc);
	/*
	* Enable all interrupts except receive, since we use the DMA
	* completion interrupt for that.
	*/
	NIC_PUT(sc, MACE_IMR, RCVINTM);

	/* flag interface as "running" */
	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);
}

/*
 * Close down an interface and free its buffers.
 * Called on final close of device, or if mcinit() fails
 * part way through.
 */
int
mc_stop(struct mc_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int s;

	s = splnet();

	NIC_PUT(sc, MACE_BIUCC, SWRST);
	DELAY(100);

	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);
	return (0);
}

/*
 * Called if any Tx packets remain unsent after 5 seconds,
 * In all cases we just reset the chip, and any retransmission
 * will be handled by higher level protocol timeouts.
 */
void
mc_watchdog(struct ifnet *ifp)
{
	struct mc_softc *sc = ifp->if_softc;

	printf("mcwatchdog: resetting chip\n");
	mc_reset(sc);
}

int
mc_intr(void *arg)
{
	struct mc_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_int8_t ir;

	ir = NIC_GET(sc, MACE_IR) & ~NIC_GET(sc, MACE_IMR);

	if (ir & JAB) {
#ifdef MCDEBUG
		printf("%s: jabber error\n", sc->sc_dev.dv_xname);
#endif
		ifp->if_oerrors++;
	}

	if (ir & BABL) {
#ifdef MCDEBUG
		printf("%s: babble\n", sc->sc_dev.dv_xname);
#endif
		ifp->if_oerrors++;
	 }

	if (ir & CERR) {
#ifdef MCDEBUG
		printf("%s: collision error\n", sc->sc_dev.dv_xname);
#endif
		ifp->if_collisions++;
	 }

	/*
	 * Pretend we have carrier; if we don't this will be cleared
	 * shortly.
	 */
	sc->sc_havecarrier = 1;

	if (ir & XMTINT)
		mc_tint(sc);

	if (ir & RCVINT)
		mc_rint(sc);

	return(1);
}

void
mc_tint(struct mc_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_int8_t xmtrc, xmtfs;

	xmtrc = NIC_GET(sc, MACE_XMTRC);
	xmtfs = NIC_GET(sc, MACE_XMTFS);

	if ((xmtfs & XMTSV) == 0)
		return;

	if (xmtfs & UFLO) {
		printf("%s: underflow\n", sc->sc_dev.dv_xname);
		mc_reset(sc);
		return;
	}

	if (xmtfs & LCOL) {
		printf("%s: late collision\n", sc->sc_dev.dv_xname);
		ifp->if_oerrors++;
		ifp->if_collisions++;
	}

	if (xmtfs & MORE)
		/* Real number is unknown. */
		ifp->if_collisions += 2;
	else if (xmtfs & ONE)
		ifp->if_collisions++;
	else if (xmtfs & RTRY) {
		printf("%s: excessive collisions\n", sc->sc_dev.dv_xname);
		ifp->if_collisions += 16;
		ifp->if_oerrors++;
	}

	if (xmtfs & LCAR) {
		sc->sc_havecarrier = 0;
		printf("%s: lost carrier\n", sc->sc_dev.dv_xname);
		ifp->if_oerrors++;
	}

	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_timer = 0;
	mc_start(ifp);
}

void
mc_rint(struct mc_softc *sc)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
#define rxf	sc->sc_rxframe
	u_int len;

	len = (rxf.rx_rcvcnt | ((rxf.rx_rcvsts & 0xf) << 8)) - 4;

#ifdef MCDEBUG
	if (rxf.rx_rcvsts & 0xf0)
		printf("%s: rcvcnt %02x rcvsts %02x rntpc 0x%02x rcvcc 0x%02x\n",
		    sc->sc_dev.dv_xname, rxf.rx_rcvcnt, rxf.rx_rcvsts,
		    rxf.rx_rntpc, rxf.rx_rcvcc);
#endif

	if (rxf.rx_rcvsts & OFLO) {
#ifdef MCDEBUG
		printf("%s: receive FIFO overflow\n", sc->sc_dev.dv_xname);
#endif
		ifp->if_ierrors++;
		return;
	}

	if (rxf.rx_rcvsts & CLSN)
		ifp->if_collisions++;

	if (rxf.rx_rcvsts & FRAM) {
#ifdef MCDEBUG
		printf("%s: framing error\n", sc->sc_dev.dv_xname);
#endif
		ifp->if_ierrors++;
		return;
	}

	if (rxf.rx_rcvsts & FCS) {
#ifdef MCDEBUG
		printf("%s: frame control checksum error\n", sc->sc_dev.dv_xname);
#endif
		ifp->if_ierrors++;
		return;
	}

	mace_read(sc, rxf.rx_frame, len);
#undef  rxf
}
/*
 * stuff packet into MACE (at splnet)
 */
u_int
maceput(struct mc_softc *sc, struct mbuf *m)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf *n;
	u_int len, totlen = 0;
	u_char *buff;

	buff = sc->sc_txbuf;

	for (; m; m = n) {
		u_char *data = mtod(m, u_char *);
		len = m->m_len;
		totlen += len;
		bcopy(data, buff, len);
		buff += len;
		n = m_free(m);
	}

	if (totlen > PAGE_SIZE)
		panic("%s: maceput: packet overflow", sc->sc_dev.dv_xname);

#if 0
	if (totlen < ETHERMIN + sizeof(struct ether_header)) {
		int pad = ETHERMIN + sizeof(struct ether_header) - totlen;
		bzero(sc->sc_txbuf + totlen, pad);
		totlen = ETHERMIN + sizeof(struct ether_header);
	}
#endif


	/* 5 seconds to watch for failing to transmit */
	ifp->if_timer = 5;
	mc_putpacket(sc, totlen);
	return (totlen);
}

void
mace_read(struct mc_softc *sc, caddr_t pkt, int len)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;

	if (len <= sizeof(struct ether_header) ||
	    len > ETHERMTU + sizeof(struct ether_header)) {
#ifdef MCDEBUG
		printf("%s: invalid packet size %d; dropping\n",
		    sc->sc_dev.dv_xname, len);
#endif
		ifp->if_ierrors++;
		return;
	}

	m = mace_get(sc, pkt, len);
	if (m == NULL) {
		ifp->if_ierrors++;
		return;
	}

	ml_enqueue(&ml, m);
	if_input(ifp, &ml);
}

/*
 * Pull data off an interface.
 * Len is length of data, with local net header stripped.
 * We copy the data into mbufs.  When full cluster sized units are present
 * we copy into clusters.
 */
struct mbuf *
mace_get(struct mc_softc *sc, caddr_t pkt, int totlen)
{
	 struct mbuf *m;
	 struct mbuf *top, **mp;
	 int len;

	 MGETHDR(m, M_DONTWAIT, MT_DATA);
	 if (m == NULL)
		  return (NULL);

	 m->m_pkthdr.len = totlen;
	 len = MHLEN;
	 top = 0;
	 mp = &top;

	 while (totlen > 0) {
		  if (top) {
			   MGET(m, M_DONTWAIT, MT_DATA);
			   if (m == NULL) {
				    m_freem(top);
				    return (NULL);
			   }
			   len = MLEN;
		  }
		  if (totlen >= MINCLSIZE) {
			   MCLGET(m, M_DONTWAIT);
			   if ((m->m_flags & M_EXT) == 0) {
				    m_free(m);
				    m_freem(top);
				    return (NULL);
			   }
			   len = MCLBYTES;
		  }
		  m->m_len = len = min(totlen, len);
		  bcopy(pkt, mtod(m, caddr_t), len);
		  pkt += len;
		  totlen -= len;
		  *mp = m;
		  mp = &m->m_next;
	 }

	 return (top);
}

void
mc_putpacket(struct mc_softc *sc, u_int len)
{
	dbdma_command_t *cmd = sc->sc_txdmacmd;

	DBDMA_BUILD(cmd, DBDMA_CMD_OUT_LAST, 0, len, sc->sc_txbuf_pa,
	   DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
	cmd++;
	DBDMA_BUILD(cmd, DBDMA_CMD_STOP, 0, 0, 0, DBDMA_INT_ALWAYS,
	   DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);

	dbdma_start(sc->sc_txdma, sc->sc_txdbdma);
}

/*
 * Interrupt handler for the MACE DMA completion interrupts
 */
int
mc_dmaintr(void *arg)
{
	struct mc_softc *sc = arg;
	int status, offset, statoff;
	int datalen, resid;
	int i, n, count;
	dbdma_command_t *cmd;

	/* We've received some packets from the MACE */
	/* Loop through, processing each of the packets */
	i = sc->sc_tail;
	for (n = 0; n < MC_RXDMABUFS; n++, i++) {
		if (i == MC_RXDMABUFS)
			i = 0;

		cmd = &sc->sc_rxdmacmd[i];
		status = dbdma_ld16(&cmd->d_status);
		resid = dbdma_ld16(&cmd->d_resid);

		if ((status & DBDMA_CNTRL_ACTIVE) == 0) {
			continue;
		}

		count = dbdma_ld16(&cmd->d_count);
		datalen = count - resid;
		datalen -= 4; /* 4 == status bytes */

		if (datalen < 4 + sizeof(struct ether_header)) {
			printf("short packet len=%d\n", datalen);
			/* continue; */
			goto next;
		}
		DBDMA_BUILD_CMD(cmd, DBDMA_CMD_STOP, 0, 0, 0, 0);

		offset = i * MACE_BUFLEN;
		statoff = offset + datalen;
		sc->sc_rxframe.rx_rcvcnt = sc->sc_rxbuf[statoff + 0];
		sc->sc_rxframe.rx_rcvsts = sc->sc_rxbuf[statoff + 1];
		sc->sc_rxframe.rx_rntpc  = sc->sc_rxbuf[statoff + 2];
		sc->sc_rxframe.rx_rcvcc  = sc->sc_rxbuf[statoff + 3];
		sc->sc_rxframe.rx_frame  = sc->sc_rxbuf + offset;

		mc_rint(sc);

next:
		DBDMA_BUILD_CMD(cmd, DBDMA_CMD_IN_LAST, 0, DBDMA_INT_ALWAYS,
		    DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);

		cmd->d_status = 0;
		cmd->d_resid = 0;
		sc->sc_tail = i + 1;
	}

	dbdma_continue(sc->sc_rxdma);

	return 1;
}

void
mc_reset_rxdma(struct mc_softc *sc)
{
	dbdma_command_t *cmd = sc->sc_rxdmacmd;
	int i;
	u_int8_t maccc;

	/* Disable receiver, reset the DMA channels */
	maccc = NIC_GET(sc, MACE_MACCC);
	NIC_PUT(sc, MACE_MACCC, maccc & ~ENRCV);

	dbdma_reset(sc->sc_rxdma);

	bzero(sc->sc_rxdmacmd, 8 * sizeof(dbdma_command_t));
	for (i = 0; i < MC_RXDMABUFS; i++) {
		DBDMA_BUILD(cmd, DBDMA_CMD_IN_LAST, 0, MACE_BUFLEN,
		    sc->sc_rxbuf_pa + MACE_BUFLEN * i, DBDMA_INT_ALWAYS,
		    DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
		cmd++;
	}

	DBDMA_BUILD(cmd, DBDMA_CMD_NOP, 0, 0, 0,
	    DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_ALWAYS);
	dbdma_st32(&cmd->d_cmddep, sc->sc_rxdbdma->d_paddr);
	cmd++;

	sc->sc_tail = 0;

	dbdma_start(sc->sc_rxdma, sc->sc_rxdbdma);
	/* Reenable receiver, reenable DMA */
	NIC_PUT(sc, MACE_MACCC, maccc);
}

void
mc_reset_txdma(struct mc_softc *sc)
{
	dbdma_command_t *cmd = sc->sc_txdmacmd;
	dbdma_regmap_t *dmareg = sc->sc_txdma;
	u_int8_t maccc;

	/* disable transmitter */
	maccc = NIC_GET(sc, MACE_MACCC);
	NIC_PUT(sc, MACE_MACCC, maccc & ~ENXMT);

	dbdma_reset(sc->sc_txdma);

	bzero(sc->sc_txdmacmd, 2 * sizeof(dbdma_command_t));
	DBDMA_BUILD(cmd, DBDMA_CMD_OUT_LAST, 0, 0, sc->sc_txbuf_pa,
	    DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
	cmd++;
	DBDMA_BUILD(cmd, DBDMA_CMD_STOP, 0, 0, 0,
	    DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);

	out32rb(&dmareg->d_cmdptrhi, 0);
	out32rb(&dmareg->d_cmdptrlo, sc->sc_txdbdma->d_paddr);

	/* restore old value */
	NIC_PUT(sc, MACE_MACCC, maccc);
}

/*
 * Go through the list of multicast addresses and calculate the logical
 * address filter.
 */
void
mace_calcladrf(struct mc_softc *sc, u_int8_t *af)
{
	struct ether_multi *enm;
	u_int32_t crc;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct arpcom *ac = &sc->sc_arpcom;
	struct ether_multistep step;
	/*
	 * Set up multicast address filter by passing all multicast addresses
	 * through a crc generator, and then using the high order 6 bits as an
	 * index into the 64 bit logical address filter.  The high order bit
	 * selects the word, while the rest of the bits select the bit within
	 * the word.
	 */

	if (ac->ac_multirangecnt > 0)
		goto allmulti;

	*((u_int32_t *)af) = *((u_int32_t *)af + 1) = 0;
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		crc = ether_crc32_le(enm->enm_addrlo, sizeof(enm->enm_addrlo));

		/* Just want the 6 most significant bits. */
		crc >>= 26;

		/* Set the corresponding bit in the filter. */
		af[crc >> 3] |= 1 << (crc & 7);

		ETHER_NEXT_MULTI(step, enm);
	}
	ifp->if_flags &= ~IFF_ALLMULTI;
	return;

allmulti:
	ifp->if_flags |= IFF_ALLMULTI;
	*((u_int32_t *)af) = *((u_int32_t *)af + 1) = 0xffffffff;
}
@


1.28
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.27 2015/12/08 13:34:22 tedu Exp $	*/
a572 2

		ifp->if_opackets++;		/* # of pkts */
@


1.27
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.26 2015/11/25 03:09:58 dlg Exp $	*/
a461 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.26
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.25 2015/11/24 17:11:38 mpi Exp $	*/
d459 1
a459 1
		IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
@


1.25
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.24 2015/11/14 17:26:40 mpi Exp $	*/
d549 1
a549 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d553 1
a553 1
		if (ifp->if_flags & IFF_OACTIVE)
d572 1
a572 1
		ifp->if_flags |= IFF_OACTIVE;
d650 1
a650 1
	ifp->if_flags &= ~IFF_OACTIVE;
d672 2
a673 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d779 1
a779 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.24
log
@No need to include <net/bpfdesc.h>

Now that "struct bpf_d" depends on <sys/srp.h> this is one of the offender
for removing the header from <sys/param.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.23 2015/10/25 13:22:09 mpi Exp $	*/
a49 1
#include <net/if_dl.h>
@


1.23
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.22 2015/07/08 07:21:49 mpi Exp $	*/
a58 1
#include <net/bpfdesc.h>
@


1.22
log
@MFREE(9) is dead, long live m_freem(9)!

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.21 2015/06/24 09:40:53 mpi Exp $	*/
a491 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a500 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_arpcom, ifa);
@


1.21
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.20 2015/02/09 03:09:57 dlg Exp $	*/
d853 1
a853 1
		MFREE(m, n);
@


1.20
log
@tweak the new if_input function so it takes an mbuf_list instead
of a single mbuf. this forces us to batch work between the hardware
rx handlers and the stack.

this includes a converstion of bge from ether_input to if_input.

ok claudio@@ pelikan@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.19 2015/02/08 07:00:48 mpi Exp $	*/
a898 1
	ifp->if_ipackets++;
@


1.19
log
@Convert to if_input().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.18 2014/12/22 02:26:53 tedu Exp $	*/
d878 1
d897 2
a898 1
	if_input(ifp, m);
@


1.18
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.17 2014/07/22 10:35:35 mpi Exp $	*/
d896 1
a897 9

#if NBPFILTER > 0
	/* Pass the packet to any BPF listeners. */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	/* Pass the packet up. */
	ether_input_mbuf(ifp, m);
a916 1
	 m->m_pkthdr.rcvif = &sc->sc_arpcom.ac_if;
@


1.17
log
@<netinet/in_systm.h> is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.16 2013/10/23 10:31:19 mpi Exp $	*/
a501 1
#ifdef INET
a503 1
#endif
@


1.16
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not introduce any behavior change but will help changing our
representation of multicast enries.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.15 2013/08/07 22:22:42 bluhm Exp $	*/
a52 3
#include <uvm/uvm_extern.h>

#ifdef INET
a54 3
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#endif
@


1.15
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Remove these include lines from macppc drivers.
test and OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.14 2010/04/21 03:03:26 deraadt Exp $	*/
d1124 3
a1129 12
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			/*
			 * We must listen to a range of multicast addresses.
			 * For now, just accept all multicasts, rather than
			 * trying to set only those filter bits needed to match
			 * the range.  (At this time, the only use of address
			 * ranges is for IP multicast routing, for which the
			 * range is big enough to require all bits set.)
			 */
			goto allmulti;
		}

@


1.14
log
@more cleanup to cope with the change that tries to make proc.h not act
like it is everything.h
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.13 2008/11/28 02:44:17 brad Exp $	*/
a58 1
#include <netinet/in_var.h>
@


1.13
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.12 2008/10/08 23:53:08 brad Exp $	*/
d47 1
@


1.12
log
@cosmetic change for ioctl funtions.. move splnet out from variable declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.11 2008/10/02 20:21:13 brad Exp $	*/
a498 1
	struct ifreq *ifr;
a538 17
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *) data;
		err = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (err == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly. But remember UP flag!
			 */
			if (ifp->if_flags & IFF_RUNNING)
				mc_reset(sc);
			err = 0;
		}
		break;
d541 6
@


1.11
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.10 2007/04/22 22:31:14 deraadt Exp $	*/
d500 1
d502 1
a502 1
	int s = splnet(), err = 0;
@


1.10
log
@better interrupt names for vmstat -iz; ok miod gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.9 2007/04/02 21:46:30 kettenis Exp $	*/
a503 1

d557 1
a557 1
		err = EINVAL;
d559 1
@


1.9
log
@unmapiodev() takes the va as its first argument, not the pa.

ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.8 2007/03/23 17:17:23 gwk Exp $	*/
d443 1
a443 1
	    mc_dmaintr, sc, "mace");
d445 1
a445 1
	    mc_intr, sc, "mace");
@


1.8
log
@Clean up the failure path of the attach routine, check the return value of
dbdma_alloc, and mapiodev, and some whitespace/long line cleanup.
Tested on 9500MP and 9600MP.
ok martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.7 2007/01/03 06:57:54 gwk Exp $	*/
d487 1
a487 1
	unmapiodev((void *)ca->ca_reg[4], ca->ca_reg[5]);
d489 1
a489 1
	unmapiodev((void *)ca->ca_reg[2], ca->ca_reg[3]);
d491 1
a491 1
	unmapiodev((void *)ca->ca_reg[0], ca->ca_reg[1]);
@


1.7
log
@Change IF_DEQUEUE to IFQ_DEQUEUE for ALTQ, and some purely cosmetic
0 -> NULL fixes.
From brad@@
Tested on PM 9600MP.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.6 2006/12/31 20:53:04 gwk Exp $	*/
d366 2
a367 2
	if (OF_getprop(ca->ca_node, "local-mac-address", lladdr, ETHER_ADDR_LEN)
	     != ETHER_ADDR_LEN) {
d376 5
a380 1
	sc->sc_reg = mapiodev(ca->ca_reg[0], ca->ca_reg[1]);
d382 1
a382 2
	sc->sc_txdma = mapiodev(ca->ca_reg[2], ca->ca_reg[3]);
	sc->sc_rxdma = mapiodev(ca->ca_reg[4], ca->ca_reg[5]);
d384 12
a395 2
	sc->sc_txdbdma = dbdma_alloc(sc->sc_dmat, 2);
	sc->sc_tail = 0;
d397 5
a401 1
	sc->sc_rxdbdma = dbdma_alloc(sc->sc_dmat, 8 + 1);
d404 4
a407 5
	error = bus_dmamem_alloc(sc->sc_dmat, MACE_BUFSZ,
	    PAGE_SIZE, 0, sc->sc_bufseg, 1, &nseg, BUS_DMA_NOWAIT);
	if (error) {
		printf(": cannot allocate buffers (%d)\n", error);
		return;
d410 4
a413 6
	error = bus_dmamem_map(sc->sc_dmat, sc->sc_bufseg, nseg,
	    MACE_BUFSZ, &sc->sc_txbuf, BUS_DMA_NOWAIT);
	if (error) {
		printf(": cannot map buffers (%d)\n", error);
		bus_dmamem_free(sc->sc_dmat, sc->sc_bufseg, 1);
		return;
d416 4
a419 7
	error = bus_dmamap_create(sc->sc_dmat, MACE_BUFSZ, 1, MACE_BUFSZ, 0,
	    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &sc->sc_bufmap);
	if (error) {
		printf(": cannot create buffer dmamap (%d)\n", error);
		bus_dmamem_unmap(sc->sc_dmat, sc->sc_txbuf, MACE_BUFSZ);
		bus_dmamem_free(sc->sc_dmat, sc->sc_bufseg, 1);
		return;
d422 4
a425 8
	error = bus_dmamap_load(sc->sc_dmat, sc->sc_bufmap, sc->sc_txbuf,
	    MACE_BUFSZ, NULL, BUS_DMA_NOWAIT);
	if (error) {
		printf(": cannot load buffers dmamap (%d)\n", error);
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_bufmap);
		bus_dmamem_unmap(sc->sc_dmat, sc->sc_txbuf, MACE_BUFSZ);
		bus_dmamem_free(sc->sc_dmat, sc->sc_bufseg, nseg);
		return;
d432 2
a433 2
	printf(": irq %d,%d,%d",
		ca->ca_intr[0], ca->ca_intr[1], ca->ca_intr[2]);
d474 18
@


1.6
log
@Some spaces to tabs and cosmetic tweaking of the code,
From brad@@. Lots more spacing cleanup by myself.
Tested on Power Macintosh 9600
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.5 2006/12/14 00:17:40 gwk Exp $	*/
d555 2
a556 2
		IF_DEQUEUE(&ifp->if_snd, m);
		if (m == 0)
d916 3
a918 2
	 if (m == 0)
		  return (0);
d928 1
a928 1
			   if (m == 0) {
d930 1
a930 1
				    return 0;
d939 1
a939 1
				    return 0;
@


1.5
log
@Eliminate unncessary interfaces resets via the SIOCSIFADDR ioctl when
adding additional IP address or re-running dhclient by only causing an
interface init if the interface is not already running. As well as some
cosmetics.
from brad@@.

Loose the ether_cmp function of dubious optimizational value simply
use bcmp.

Revert the ordering hack, don't execute instruction eieio directly in
mc_dmaintr, makes no difference in triggering the uvm_fault bug, the
problem lies elsewhere.

Fix some indentation related to the DBDMA macros.

Tested on Power Macintosh 9600MP and 9500MP by myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mc.c,v 1.4 2006/10/20 13:10:27 xsa Exp $	*/
d84 1
a84 1
#define MACE_BUFSZ        	((MACE_RXBUFS + MACE_TXBUFS + 2) * MACE_BUFLEN)
d365 1
a365 1
	
d373 4
a376 4
        ca->ca_reg[2] += ca->ca_baseaddr;
        ca->ca_reg[4] += ca->ca_baseaddr;
	
	sc->sc_reg = mapiodev(ca->ca_reg[0], ca->ca_reg[1]);	
d380 1
a380 1
	
d388 32
a419 32
            PAGE_SIZE, 0, sc->sc_bufseg, 1, &nseg, BUS_DMA_NOWAIT);
        if (error) {
                printf(": cannot allocate buffers (%d)\n", error);
                return;
        }

        error = bus_dmamem_map(sc->sc_dmat, sc->sc_bufseg, nseg,
            MACE_BUFSZ, &sc->sc_txbuf, BUS_DMA_NOWAIT);
        if (error) {
                printf(": cannot map buffers (%d)\n", error);
                bus_dmamem_free(sc->sc_dmat, sc->sc_bufseg, 1);
                return;
        }

        error = bus_dmamap_create(sc->sc_dmat, MACE_BUFSZ, 1, MACE_BUFSZ, 0,
            BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &sc->sc_bufmap);
        if (error) {
                printf(": cannot create buffer dmamap (%d)\n", error);
                bus_dmamem_unmap(sc->sc_dmat, sc->sc_txbuf, MACE_BUFSZ);
                bus_dmamem_free(sc->sc_dmat, sc->sc_bufseg, 1);
                return;
        }

        error = bus_dmamap_load(sc->sc_dmat, sc->sc_bufmap, sc->sc_txbuf,
            MACE_BUFSZ, NULL, BUS_DMA_NOWAIT);
        if (error) {
                printf(": cannot load buffers dmamap (%d)\n", error);
                bus_dmamap_destroy(sc->sc_dmat, sc->sc_bufmap);
                bus_dmamem_unmap(sc->sc_dmat, sc->sc_txbuf, MACE_BUFSZ);
                bus_dmamem_free(sc->sc_dmat, sc->sc_bufseg, nseg);
                return;
        }
d422 3
a424 3
        sc->sc_rxbuf = sc->sc_txbuf + MACE_BUFLEN * MACE_TXBUFS;
        sc->sc_rxbuf_pa = sc->sc_txbuf_pa + MACE_BUFLEN * MACE_TXBUFS;
	
d448 1
a448 1
	
d611 1
a611 1
		out8rb(sc->sc_reg + MACE_REG(MACE_PADR) + i, 
d695 2
a696 1
	 u_int8_t ir;
d698 3
a700 2
	 ir = NIC_GET(sc, MACE_IR) & ~NIC_GET(sc, MACE_IMR);
	 if (ir & JAB) {
d702 1
a702 1
		  printf("%s: jabber error\n", sc->sc_dev.dv_xname);
d704 2
a705 2
		  sc->sc_arpcom.ac_if.if_oerrors++;
	 }
d707 1
a707 1
	 if (ir & BABL) {
d709 1
a709 1
		  printf("%s: babble\n", sc->sc_dev.dv_xname);
d711 1
a711 1
		  sc->sc_arpcom.ac_if.if_oerrors++;
d714 1
a714 1
	 if (ir & CERR) {
d716 1
a716 1
		  printf("%s: collision error\n", sc->sc_dev.dv_xname);
d718 1
a718 1
		  sc->sc_arpcom.ac_if.if_collisions++;
d721 12
a732 12
	 /*
	  * Pretend we have carrier; if we don't this will be cleared
	  * shortly.
	  */
	 sc->sc_havecarrier = 1;

	 if (ir & XMTINT)
		  mc_tint(sc);

	 if (ir & RCVINT)
		  mc_rint(sc);
	
d739 1
d756 2
a757 2
		sc->sc_arpcom.ac_if.if_oerrors++;
		sc->sc_arpcom.ac_if.if_collisions++;
d762 1
a762 1
		sc->sc_arpcom.ac_if.if_collisions += 2;
d764 1
a764 1
		sc->sc_arpcom.ac_if.if_collisions++;
d767 2
a768 2
		sc->sc_arpcom.ac_if.if_collisions += 16;
		sc->sc_arpcom.ac_if.if_oerrors++;
d774 1
a774 1
		sc->sc_arpcom.ac_if.if_oerrors++;
d777 3
a779 3
	sc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;
	sc->sc_arpcom.ac_if.if_timer = 0;
	mc_start(&sc->sc_arpcom.ac_if);
d785 1
d802 1
a802 1
		sc->sc_arpcom.ac_if.if_ierrors++;
d807 1
a807 1
		sc->sc_arpcom.ac_if.if_collisions++;
d813 1
a813 1
		sc->sc_arpcom.ac_if.if_ierrors++;
d821 1
a821 1
		sc->sc_arpcom.ac_if.if_ierrors++;
d834 1
d863 1
a863 1
	sc->sc_arpcom.ac_if.if_timer = 5;
d963 1
a963 1
	
d1004 1
a1004 1
		
@


1.4
log
@fix $OpenBSD$ tag.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d318 1
a318 1
int	mc_init(struct mc_softc *sc);
d335 1
a335 1
static void mace_calcladrf(struct arpcom *, u_int8_t *);
a337 44
/*
 * Compare two Ether/802 addresses for equality, inlined and
 * unrolled for speed.  Use this like bcmp().
 *
 * XXX: Add <machine/inlines.h> for stuff like this?
 * XXX: or maybe add it to libkern.h instead?
 *
 * "I'd love to have an inline assembler version of this."
 * XXX: Who wanted that? mycroft?  I wrote one, but this
 * version in C is as good as hand-coded assembly. -gwr
 *
 * Please do NOT tweak this without looking at the actual
 * assembly code generated before and after your tweaks!
 */
static inline u_int16_t
ether_cmp(void *one, void *two)
{
	u_int16_t *a = (u_short *) one;
	u_int16_t *b = (u_short *) two;
	u_int16_t diff;

#ifdef  m68k
	/*
	 * The post-increment-pointer form produces the best
	 * machine code for m68k.  This was carefully tuned
	 * so it compiles to just 8 short (2-byte) op-codes!
	 */
	diff  = *a++ - *b++;
	diff |= *a++ - *b++;
	diff |= *a++ - *b++;
#else
	/*
	 * Most modern CPUs do better with a single expresion.
	 * Note that short-cut evaluation is NOT helpful here,
	 * because it just makes the code longer, not faster!
	 */
	diff = (a[0] - b[0]) | (a[1] - b[1]) | (a[2] - b[2]);
#endif

	return (diff);
}

#define ETHER_CMP       ether_cmp

d473 1
a473 1
	struct ifaddr *ifa;
a480 1
		ifa = (struct ifaddr *)data;
d482 2
a483 1
		switch (ifa->ifa_addr->sa_family) {
d485 1
a485 2
		case AF_INET:
			mc_init(sc);
a486 1
			break;
a487 4
		default:
			mc_init(sc);
			break;
		}
a497 1
			ifp->if_flags &= ~IFF_RUNNING;
d504 1
a504 1
			(void)mc_init(sc);
d589 1
a589 1
int
d592 2
a594 5
	u_int8_t maccc, ladrf[8];

	if (sc->sc_arpcom.ac_if.if_flags & IFF_RUNNING)
		/* already running */
		return (0);
d615 1
a615 1
	mace_calcladrf(&sc->sc_arpcom, ladrf);
d634 1
a634 1
	if (sc->sc_arpcom.ac_if.if_flags & IFF_PROMISC)
d648 2
a649 2
	sc->sc_arpcom.ac_if.if_flags |= IFF_RUNNING;
	sc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;
a651 1
	return (0);
d662 4
a665 1
	int	s = splnet();
d670 2
a671 2
	sc->sc_arpcom.ac_if.if_timer = 0;
	sc->sc_arpcom.ac_if.if_flags &= ~IFF_RUNNING;
d954 1
a954 1
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d956 2
a957 2
	DBDMA_BUILD(cmd, DBDMA_CMD_STOP, 0, 0, 0,
	   DBDMA_INT_ALWAYS, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d999 1
a999 3
		/* XXX: Why? */
		__asm volatile("eieio");

a1012 2
		/* XXX: Why? */
		__asm volatile("eieio");
d1040 2
a1041 2
			sc->sc_rxbuf_pa + MACE_BUFLEN * i, DBDMA_INT_ALWAYS,
			DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d1046 1
a1046 1
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_ALWAYS);
d1072 1
a1072 1
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d1075 1
a1075 1
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
d1089 1
a1089 1
mace_calcladrf(struct arpcom *ac, u_int8_t *af)
a1090 1
	struct ifnet *ifp = &ac->ac_if;
d1093 2
a1095 1

d1107 1
a1107 1
		if (ETHER_CMP(enm->enm_addrlo, enm->enm_addrhi)) {
@


1.3
log
@Execute the Enforce in-order Execution of I/O (eieio) instruction in
mc_dmaintr, its a little bit of voodoo, I dont understand why its necessary
for mace versus the near identical dma isr in if_bm.c, but the system no
longer panics under network load.
@
text
@d1 1
a1 1
/*	$OpenBSD: */
@


1.2
log
@Remove lingering debug printf. Don't announce that mace_get was called.
@
text
@d1050 4
a1053 2
		DBDMA_BUILD_CMD(cmd, DBDMA_CMD_STOP, 0, 0, 0, 0);	
		
d1067 3
@


1.1
log
@Add if_mc.c a driver for the AMD AM79C940 (MACE) ethernet chip found on
board old world macintosh systems to macppc. From netbsd, mac68k and
macppc specific tweaks modeled on if_bm.c.
ok brad@@
@
text
@a957 1
	printf("mace_get:\n");
@

