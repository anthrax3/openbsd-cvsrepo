head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.6
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.17.0.22
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.18
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.20
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.12
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.16
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.14
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.10
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.14.0.10
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.8
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.8
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.6
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.7
	UBC:1.2.0.6
	UBC_BASE:1.2
	SMP:1.2.0.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.19
date	2016.12.05.15.04.15;	author fcambus;	state Exp;
branches;
next	1.18;
commitid	aMf0uryIVAssQMo0;

1.18
date	2016.10.08.05.49.08;	author guenther;	state Exp;
branches;
next	1.17;
commitid	z63v1DilayzHcfkw;

1.17
date	2011.07.02.22.20.07;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2011.06.16.10.44.33;	author mpi;	state Exp;
branches;
next	1.15;

1.15
date	2011.06.15.21.32.04;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.26.17.19.47;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2007.12.11.15.44.00;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.18.23.21.17;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.15.15.01.23;	author martin;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.29.14.32.57;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.16.03.54.48;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.16.03.31.25;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.15.02.02.43;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.07.07.13.59;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.03.15.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.03.20.06.00;	author drahn;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	2001.10.03.14.45.37;	author drahn;	state Exp;
branches;
next	;

1.2.4.1
date	2001.10.31.03.01.15;	author nate;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	;

1.2.6.1
date	2002.06.11.03.36.33;	author art;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Harmonize battery state thresholds accross platforms.

Use the same values hardcoded in sys/dev/acpi/acpi.c where possible.

OK visa@@
@
text
@/*	$OpenBSD: apm.c,v 1.18 2016/10/08 05:49:08 guenther Exp $	*/

/*-
 * Copyright (c) 2001 Alexander Guy.  All rights reserved.
 * Copyright (c) 1998-2001 Michael Shalayeff. All rights reserved.
 * Copyright (c) 1995 John T. Kohl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the names of the authors nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include "apm.h"

#if NAPM > 1
#error only one APM emulation device may be configured
#endif

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/event.h>

#include <machine/conf.h>
#include <machine/cpu.h>
#include <machine/apmvar.h>
#include <machine/autoconf.h>

#include <macppc/dev/pm_direct.h>

#if defined(APMDEBUG)
#define DPRINTF(x)	printf x
#else
#define	DPRINTF(x)	/**/
#endif

struct apm_softc {
	struct device sc_dev;
	struct klist sc_note;
	int    sc_flags;
};

int apmmatch(struct device *, void *, void *);
void apmattach(struct device *, struct device *, void *);

struct cfattach apm_ca = {
	sizeof(struct apm_softc), apmmatch, apmattach
};

struct cfdriver apm_cd = {
	NULL, "apm", DV_DULL
};

#define	APMUNIT(dev)	(minor(dev)&0xf0)
#define	APMDEV(dev)	(minor(dev)&0x0f)
#define APMDEV_NORMAL	0
#define APMDEV_CTL	8

void filt_apmrdetach(struct knote *kn);
int filt_apmread(struct knote *kn, long hint);
int apmkqfilter(dev_t dev, struct knote *kn);

struct filterops apmread_filtops =
	{ 1, NULL, filt_apmrdetach, filt_apmread};

/*
 * Flags to control kernel display
 *	SCFLAG_NOPRINT:		do not output APM power messages due to
 *				a power change event.
 *
 *	SCFLAG_PCTPRINT:	do not output APM power messages due to
 *				to a power change event unless the battery
 *				percentage changes.
 */

#define SCFLAG_NOPRINT	0x0008000
#define SCFLAG_PCTPRINT	0x0004000
#define SCFLAG_PRINT	(SCFLAG_NOPRINT|SCFLAG_PCTPRINT)

#define	SCFLAG_OREAD 	(1 << 0)
#define	SCFLAG_OWRITE	(1 << 1)
#define	SCFLAG_OPEN	(SCFLAG_OREAD|SCFLAG_OWRITE)


int
apmmatch(struct device *parent, void *match, void *aux)
{
	struct confargs *ca = aux;

	if (strcmp(ca->ca_name, "apm") != 0)
		return (0);

	return (1);
}

void
apmattach(struct device *parent, struct device *self, void *aux)
{
	struct pmu_battery_info info;

	pm_battery_info(0, &info);

	printf(": battery flags 0x%X, ", info.flags);
	printf("%d%% charged\n", ((info.cur_charge * 100) / info.max_charge));
}

int
apmopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct apm_softc *sc;
	int error = 0;

	/* apm0 only */
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
		return ENXIO;

	DPRINTF(("apmopen: dev %d pid %d flag %x mode %x\n",
	    APMDEV(dev), p->p_p->ps_pid, flag, mode));

	switch (APMDEV(dev)) {
	case APMDEV_CTL:
		if (!(flag & FWRITE)) {
			error = EINVAL;
			break;
		}
		if (sc->sc_flags & SCFLAG_OWRITE) {
			error = EBUSY;
			break;
		}
		sc->sc_flags |= SCFLAG_OWRITE;
		break;
	case APMDEV_NORMAL:
		if (!(flag & FREAD) || (flag & FWRITE)) {
			error = EINVAL;
			break;
		}
		sc->sc_flags |= SCFLAG_OREAD;
		break;
	default:
		error = ENXIO;
		break;
	}
	return error;
}

int
apmclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct apm_softc *sc;

	/* apm0 only */
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
		return ENXIO;

	DPRINTF(("apmclose: pid %d flag %x mode %x\n",
	    p->p_p->ps_pid, flag, mode));

	switch (APMDEV(dev)) {
	case APMDEV_CTL:
		sc->sc_flags &= ~SCFLAG_OWRITE;
		break;
	case APMDEV_NORMAL:
		sc->sc_flags &= ~SCFLAG_OREAD;
		break;
	}
	return 0;
}

int
apmioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct apm_softc *sc;
	struct pmu_battery_info batt;
	struct apm_power_info *power;
	int error = 0;

	/* apm0 only */
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
		return ENXIO;

	switch (cmd) {
		/* some ioctl names from linux */
	case APM_IOC_STANDBY:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		break;
	case APM_IOC_SUSPEND:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		break;
	case APM_IOC_PRN_CTL:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		else {
			int flag = *(int *)data;
			DPRINTF(( "APM_IOC_PRN_CTL: %d\n", flag ));
			switch (flag) {
			case APM_PRINT_ON:	/* enable printing */
				sc->sc_flags &= ~SCFLAG_PRINT;
				break;
			case APM_PRINT_OFF: /* disable printing */
				sc->sc_flags &= ~SCFLAG_PRINT;
				sc->sc_flags |= SCFLAG_NOPRINT;
				break;
			case APM_PRINT_PCT: /* disable some printing */
				sc->sc_flags &= ~SCFLAG_PRINT;
				sc->sc_flags |= SCFLAG_PCTPRINT;
				break;
			default:
				error = EINVAL;
				break;
			}
		}
		break;
	case APM_IOC_DEV_CTL:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		break;
	case APM_IOC_GETPOWER:
	        power = (struct apm_power_info *)data;

		pm_battery_info(0, &batt);

		power->ac_state = ((batt.flags & PMU_PWR_AC_PRESENT) ?
		    APM_AC_ON : APM_AC_OFF);
		power->battery_life =
		    ((batt.cur_charge * 100) / batt.max_charge);

		/*
		 * If the battery is charging, return the minutes left until
		 * charging is complete. apmd knows this.
		 */

		if (!(batt.flags & PMU_PWR_BATT_PRESENT)) {
			power->battery_state = APM_BATT_UNKNOWN;
			power->minutes_left = 0;
			power->battery_life = 0;
		} else if ((power->ac_state == APM_AC_ON) &&
			   (batt.draw > 0)) {
			power->minutes_left =
			    (((batt.max_charge - batt.cur_charge) * 3600) /
			    batt.draw) / 60;
			power->battery_state = APM_BATT_CHARGING;
		} else {
			power->minutes_left =
			    ((batt.cur_charge * 3600) / (-batt.draw)) / 60;

			if (power->battery_life > 50)
				power->battery_state = APM_BATT_HIGH;
			else if (power->battery_life > 25)
				power->battery_state = APM_BATT_LOW;
			else
				power->battery_state = APM_BATT_CRITICAL;
		}
		break;
	case APM_IOC_STANDBY_REQ:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		break;
	case APM_IOC_SUSPEND_REQ:
		if ((flag & FWRITE) == 0)
			error = EBADF;
		break;
	default:
		error = ENOTTY;
	}

	return error;
}

void
filt_apmrdetach(struct knote *kn)
{
	struct apm_softc *sc = (struct apm_softc *)kn->kn_hook;

	SLIST_REMOVE(&sc->sc_note, kn, knote, kn_selnext);
}

int
filt_apmread(struct knote *kn, long hint)
{
	/* XXX weird kqueue_scan() semantics */
	if (hint && !kn->kn_data)
		kn->kn_data = (int)hint;

	return (1);
}

int
apmkqfilter(dev_t dev, struct knote *kn)
{
	struct apm_softc *sc;

	/* apm0 only */
	if (!apm_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = apm_cd.cd_devs[APMUNIT(dev)]))
		return ENXIO;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		kn->kn_fop = &apmread_filtops;
		break;
	default:
		return (EINVAL);
	}

	kn->kn_hook = (caddr_t)sc;
	SLIST_INSERT_HEAD(&sc->sc_note, kn, kn_selnext);

	return (0);
}
@


1.18
log
@Various printf claim to report the PID, so actually report that and not the TID

Build testing assistance from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.17 2011/07/02 22:20:07 nicm Exp $	*/
d276 1
a276 2
			/* XXX - Arbitrary */
			if (power->battery_life > 60)
d278 3
a280 1
			else if (power->battery_life < 10)
a281 2
			else
				power->battery_state = APM_BATT_LOW;
@


1.17
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.16 2011/06/16 10:44:33 mpi Exp $	*/
d144 1
a144 1
	    APMDEV(dev), p->p_pid, flag, mode));
d182 2
a183 1
	DPRINTF(("apmclose: pid %d flag %x mode %x\n", p->p_pid, flag, mode));
@


1.16
log
@Uses generic confargs to attach the apm(4) and piic(4) drivers instead of
the specifics adb arguments.
Now apm(4) no longer depends on adb stuff and piic(4) doesn't attach on a
via-cuda machine (e.g. my color G3 iMac).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.15 2011/06/15 21:32:04 miod Exp $	*/
d332 1
a332 1
		return (1);
@


1.15
log
@Add a const char* as first member of struct adb_attach_args, so that we can
pass a struct confargs * on macppc for some specific children of the adb
node, and not confuse real adb device attachments.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.14 2009/02/26 17:19:47 oga Exp $	*/
d52 1
a53 2
#include <dev/adb/adb.h>
#include <macppc/dev/adbvar.h>
d113 1
a113 1
	struct adb_attach_args *aa = (void *)aux;
d115 2
a116 2
	if (strcmp(aa->name, adb_device_name) != 0)
		return 0;
d118 1
a118 9
	if (aa->origaddr != ADBADDR_APM ||
	    aa->handler_id != ADBADDR_APM ||
	    aa->adbaddr != ADBADDR_APM)
		return 0;

	if (adbHardware != ADB_HW_PMU)
		return 0;

	return 1;
@


1.14
log
@Add a two new ioctls to the apm(4) interface.

APM_IOC_{SUSPEND,STANDBY}_REQ: This is to fix an issue with apm suspend
where a call to zzz suspended the machine immediately, not giving anyone
listening for apm events (other than apmd) a chance to deal with the
upcoming change. This hit X hard since the introduction of drm, since it
needs to have time to idle the 3d engine and otherwise get the device
into a recoverable state. Such things are needed until we support
modesetting in the kernel.

Now, instead of forcing a suspend, using ioctl sends out an event similar
to if you had put the lid down, giving all userland applications a
chance to reply.

tested by sthen@@ and beck@@, especial thanks to sthen for sitting there
while I tried to debug this remotely, I owe him beer.

Prompted by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.13 2007/12/11 15:44:00 tedu Exp $	*/
d115 4
@


1.13
log
@reword license to change regents to authors, and remove advertising clause.
cleared with all original authors. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.12 2006/01/18 23:21:17 miod Exp $	*/
d289 8
a296 1

@


1.12
log
@Factorize akbd and ams drivers between mac68k and macppc; while there, start
moving out common adb code as well, and merge adb_direct.c into adb.c to
simplify external header files.

No functional change; more cleanups to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.11 2005/10/15 15:01:23 martin Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d20 1
a20 1
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
d23 1
a23 1
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
@


1.11
log
@- merge adb_direct.h bits into adbvar.h
- rename ADB_HW_PB to ADB_HW_PMU

from NetBSD

ok brad@@; additonal testing krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.10 2005/03/29 14:32:57 miod Exp $	*/
d57 1
@


1.10
log
@Missing break;
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.9 2003/10/16 03:54:48 deraadt Exp $	*/
a57 1
#include <macppc/dev/adb_direct.h>
d123 1
a123 1
	if (adbHardware != ADB_HW_PB)
@


1.9
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.8 2003/10/16 03:31:25 drahn Exp $	*/
d222 1
@


1.8
log
@more ANSI/KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.7 2002/09/15 09:01:58 deraadt Exp $	*/
d118 1
a118 1
	struct adb_attach_args *aa = (void *)aux;		
d224 1
a224 1
			error = EBADF;			
d280 1
a280 1
			power->minutes_left = 
d291 1
a292 2
		break;
		
@


1.7
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.5 2002/06/07 07:13:59 miod Exp $	*/
d116 1
a116 3
apmmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d131 1
a131 3
apmattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d142 1
a142 4
apmopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d182 1
a182 4
apmclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d205 1
a205 6
apmioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d284 1
a284 1
			if (power->battery_life > 60) {
d286 1
a286 1
			} else if (power->battery_life < 10) {
d288 1
a288 1
			} else {
a289 1
			}
d302 1
a302 2
filt_apmrdetach(kn)
	struct knote *kn;
d310 1
a310 3
filt_apmread(kn, hint)
	struct knote *kn;
	long hint;
d320 1
a320 3
apmkqfilter(dev, kn)
	dev_t dev;
	struct knote *kn;
@


1.6
log
@KNF
@
text
@d120 1
a120 1
	struct adb_attach_args *aa = (void *)aux;
d239 1
a239 1
			error = EBADF;
d270 1
a270 1
		power = (struct apm_power_info *)data;
d295 1
a295 1
			power->minutes_left =
d309 1
a309 1

@


1.5
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.4 2002/03/14 03:15:55 millert Exp $	*/
d120 1
a120 1
	struct adb_attach_args *aa = (void *)aux;		
d239 1
a239 1
			error = EBADF;			
d270 1
a270 1
	        power = (struct apm_power_info *)data;
d295 1
a295 1
			power->minutes_left = 
d309 1
a309 1
		
@


1.4
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.3 2002/03/14 01:26:36 millert Exp $	*/
d58 1
a79 4
int apmopen(dev_t dev, int flag, int mode, struct proc *p);
int apmclose(dev_t dev, int flag, int mode, struct proc *p);
int apmioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p);

d274 8
a281 6
		power->ac_state = ((batt.flags & PMU_PWR_AC_PRESENT) ? APM_AC_ON : APM_AC_OFF);
		power->battery_life = ((batt.cur_charge * 100) / batt.max_charge);

		/* XXX - If the battery is charging, return the minutes left until
		 *       charging is complete.  This might cause problems as I don't
		 *       think APM does this.. I don't have a machine to test with.
a283 1

d291 2
a292 1
				(((batt.max_charge - batt.cur_charge) * 3600) / batt.draw) / 60;
d296 1
a296 1
			((batt.cur_charge * 3600) / (-batt.draw)) / 60;
a309 1
	
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.2 2001/10/03 20:06:00 drahn Exp $	*/
d248 1
a248 1
			int flag = *(int*)data;
@


1.2
log
@Add $OpenBSD$ tags which were removed when this code was copied.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.49 2001/08/18 06:08:08 mickey Exp $	*/
d72 2
a73 2
int apmmatch __P((struct device *, void *, void *));
void apmattach __P((struct device *, struct device *, void *));
d79 3
a81 3
int apmopen __P((dev_t dev, int flag, int mode, struct proc *p));
int apmclose __P((dev_t dev, int flag, int mode, struct proc *p));
int apmioctl __P((dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p));
d92 3
a94 3
void filt_apmrdetach __P((struct knote *kn));
int filt_apmread __P((struct knote *kn, long hint));
int apmkqfilter __P((dev_t dev, struct knote *kn));
@


1.2.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.2 2001/10/03 20:06:00 drahn Exp $	*/
a57 1
#include <macppc/dev/adb_direct.h>
d72 2
a73 2
int apmmatch(struct device *, void *, void *);
void apmattach(struct device *, struct device *, void *);
d79 4
d92 3
a94 3
void filt_apmrdetach(struct knote *kn);
int filt_apmread(struct knote *kn, long hint);
int apmkqfilter(dev_t dev, struct knote *kn);
d248 1
a248 1
			int flag = *(int *)data;
d277 6
a282 8
		power->ac_state = ((batt.flags & PMU_PWR_AC_PRESENT) ?
		    APM_AC_ON : APM_AC_OFF);
		power->battery_life =
		    ((batt.cur_charge * 100) / batt.max_charge);

		/*
		 * If the battery is charging, return the minutes left until
		 * charging is complete. apmd knows this.
d285 1
d293 1
a293 2
			    (((batt.max_charge - batt.cur_charge) * 3600) /
			    batt.draw) / 60;
d297 1
a297 1
			    ((batt.cur_charge * 3600) / (-batt.draw)) / 60;
d311 1
@


1.2.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.2.6.1 2002/06/11 03:36:33 art Exp $	*/
@


1.2.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2.4.2
log
@Merge in -current from about a week ago
@
text
@d72 2
a73 2
int apmmatch(struct device *, void *, void *);
void apmattach(struct device *, struct device *, void *);
d79 3
a81 3
int apmopen(dev_t dev, int flag, int mode, struct proc *p);
int apmclose(dev_t dev, int flag, int mode, struct proc *p);
int apmioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p);
d92 3
a94 3
void filt_apmrdetach(struct knote *kn);
int filt_apmread(struct knote *kn, long hint);
int apmkqfilter(dev_t dev, struct knote *kn);
d248 1
a248 1
			int flag = *(int *)data;
@


1.2.4.3
log
@Sync the SMP branch with 3.3
@
text
@a57 1
#include <macppc/dev/adb_direct.h>
d79 4
d277 6
a282 8
		power->ac_state = ((batt.flags & PMU_PWR_AC_PRESENT) ?
		    APM_AC_ON : APM_AC_OFF);
		power->battery_life =
		    ((batt.cur_charge * 100) / batt.max_charge);

		/*
		 * If the battery is charging, return the minutes left until
		 * charging is complete. apmd knows this.
d285 1
d293 1
a293 2
			    (((batt.max_charge - batt.cur_charge) * 3600) /
			    batt.draw) / 60;
d297 1
a297 1
			    ((batt.cur_charge * 3600) / (-batt.draw)) / 60;
d311 1
@


1.2.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d116 3
a118 1
apmmatch(struct device *parent, void *match, void *aux)
d120 1
a120 1
	struct adb_attach_args *aa = (void *)aux;
d133 3
a135 1
apmattach(struct device *parent, struct device *self, void *aux)
d146 4
a149 1
apmopen(dev_t dev, int flag, int mode, struct proc *p)
d189 4
a192 1
apmclose(dev_t dev, int flag, int mode, struct proc *p)
d215 6
a220 1
apmioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
d239 1
a239 1
			error = EBADF;
d295 1
a295 1
			power->minutes_left =
d299 1
a299 1
			if (power->battery_life > 60)
d301 1
a301 1
			else if (power->battery_life < 10)
d303 1
a303 1
			else
d305 1
d307 1
d309 1
a309 1

d318 2
a319 1
filt_apmrdetach(struct knote *kn)
d327 3
a329 1
filt_apmread(struct knote *kn, long hint)
d339 3
a341 1
apmkqfilter(dev_t dev, struct knote *kn)
@


1.1
log
@apm support for macppc. This is not fully implemented, sleep modes
and power event are not handled, however it is enough support
to poll the battery/AC/charging states of the system.
Code by Alexander Guy.
@
text
@d1 2
@

