head	1.34;
access;
symbols
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.32.0.2
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.23.0.6
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.22.0.8
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.6
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.4
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.18.0.4
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.4
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.6.0.6
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.4
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6;
locks; strict;
comment	@ * @;


1.34
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.33;
commitid	pi1a9KN0itEngOc4;

1.33
date	2016.08.30.11.20.09;	author ratchov;	state Exp;
branches;
next	1.32;
commitid	sLNOLrcBztN97Jx1;

1.32
date	2016.06.26.06.50.26;	author mglocker;	state Exp;
branches;
next	1.31;
commitid	j4qjfJECwQKGf97u;

1.31
date	2016.06.26.06.48.39;	author mglocker;	state Exp;
branches;
next	1.30;
commitid	ZWoKh5Btn160Abd6;

1.30
date	2015.09.08.08.29.35;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	Qv4sSaeodDiHWA1c;

1.29
date	2015.07.17.22.30.58;	author mpi;	state Exp;
branches;
next	1.28;
commitid	tZcC3cby9LSBTpIj;

1.28
date	2015.06.03.08.30.27;	author mpi;	state Exp;
branches;
next	1.27;
commitid	HxTTCrCBQM4Cq3qW;

1.27
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.26;
commitid	RaOGL5SyOGOZylwx;

1.26
date	2015.04.07.09.54.11;	author mpi;	state Exp;
branches;
next	1.25;
commitid	gzeyx2aLQJxxkIke;

1.25
date	2015.03.24.16.29.09;	author mpi;	state Exp;
branches;
next	1.24;
commitid	gg9fDaP6hKEQj08M;

1.24
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.23;
commitid	uKVPYMN2MLxdZxzH;

1.23
date	2013.05.15.08.29.23;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2011.06.07.16.29.51;	author mpi;	state Exp;
branches;
next	1.21;

1.21
date	2011.05.15.09.10.26;	author mpi;	state Exp;
branches;
next	1.20;

1.20
date	2011.05.05.18.54.23;	author jasper;	state Exp;
branches;
next	1.19;

1.19
date	2011.05.04.15.50.49;	author jasper;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.07.19.53.20;	author todd;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.05.21.38.03;	author jakemsr;	state Exp;
branches;
next	1.15;

1.15
date	2008.10.30.06.12.47;	author todd;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.29.03.00.19;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2008.10.29.00.04.14;	author jakemsr;	state Exp;
branches;
next	1.12;

1.12
date	2008.08.24.23.44.44;	author todd;	state Exp;
branches;
next	1.11;

1.11
date	2007.12.11.09.11.54;	author jakemsr;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.05.00.17.28;	author jakemsr;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2007.04.22.22.31.14;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.04.21.15.43.27;	author gwk;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.08.18.11.03;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.11.20.56.01;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.19.00.00.47;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.17.02.58.03;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.31.00.26.07;	author joris;	state Exp;
branches;
next	1.1;

1.1
date	2005.10.26.17.57.20;	author joris;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@/*	$OpenBSD: i2s.c,v 1.31 2016/06/26 06:48:39 mglocker Exp $	*/
/*	$NetBSD: i2s.c,v 1.1 2003/12/27 02:19:34 grant Exp $	*/

/*-
 * Copyright (c) 2002 Tsubai Masanari.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/audioio.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/systm.h>

#include <dev/audio_if.h>
#include <dev/ofw/openfirm.h>
#include <macppc/dev/dbdma.h>

#include <uvm/uvm_extern.h>

#include <machine/autoconf.h>
#include <machine/pio.h>

#include <macppc/dev/i2svar.h>
#include <macppc/dev/i2sreg.h>
#include <macppc/pci/macobio.h>

#ifdef I2S_DEBUG
# define DPRINTF(x) printf x 
#else
# define DPRINTF(x)
#endif

void	i2s_mute(u_int, int);
int	i2s_cint(void *);
u_int	i2s_gpio_offset(struct i2s_softc *, char *, int *);
void	i2s_init(struct i2s_softc *, int);

int	i2s_intr(void *);
int	i2s_iintr(void *);

struct cfdriver i2s_cd = {
	NULL, "i2s", DV_DULL
};

void
i2s_attach(struct device *parent, struct i2s_softc *sc, struct confargs *ca)
{
	int cirq, oirq, iirq, cirq_type, oirq_type, iirq_type;
	u_int32_t reg[6], intr[6];
	char compat[32];
	int child;

	sc->sc_node = OF_child(ca->ca_node);
	sc->sc_baseaddr = ca->ca_baseaddr;

	OF_getprop(sc->sc_node, "reg", reg, sizeof reg);

	child = OF_child(sc->sc_node);
	memset(compat, 0, sizeof(compat));
	OF_getprop(child, "compatible", compat, sizeof(compat));

	/* Deal with broken device-tree on PowerMac7,2 and 7,3. */
	if (strcmp(compat, "AOAK2") == 0) {
		reg[0] += ca->ca_reg[0];
		reg[2] += ca->ca_reg[2];
		reg[4] += ca->ca_reg[2];
	}

	reg[0] += sc->sc_baseaddr;
	reg[2] += sc->sc_baseaddr;
	reg[4] += sc->sc_baseaddr;

	sc->sc_reg = mapiodev(reg[0], reg[1]);

	sc->sc_dmat = ca->ca_dmat;
	sc->sc_odma = mapiodev(reg[2], reg[3]); /* out */
	sc->sc_idma = mapiodev(reg[4], reg[5]); /* in */
	sc->sc_odbdma = dbdma_alloc(sc->sc_dmat, I2S_DMALIST_MAX);
	sc->sc_odmacmd = sc->sc_odbdma->d_addr;
	sc->sc_idbdma = dbdma_alloc(sc->sc_dmat, I2S_DMALIST_MAX);
	sc->sc_idmacmd = sc->sc_idbdma->d_addr;

	OF_getprop(sc->sc_node, "interrupts", intr, sizeof intr);
	cirq = intr[0];
	oirq = intr[2];
	iirq = intr[4];
	cirq_type = (intr[1] & 1) ? IST_LEVEL : IST_EDGE;
	oirq_type = (intr[3] & 1) ? IST_LEVEL : IST_EDGE;
	iirq_type = (intr[5] & 1) ? IST_LEVEL : IST_EDGE;

	/* intr_establish(cirq, cirq_type, IPL_AUDIO, i2s_intr, sc); */
	mac_intr_establish(parent, oirq, oirq_type, IPL_AUDIO | IPL_MPSAFE,
	    i2s_intr, sc, sc->sc_dev.dv_xname);
	mac_intr_establish(parent, iirq, iirq_type, IPL_AUDIO | IPL_MPSAFE,
	    i2s_iintr, sc, sc->sc_dev.dv_xname);

	printf(": irq %d,%d,%d\n", cirq, oirq, iirq);

	/* Need to be explicitly turned on some G5. */
	macobio_enable(I2SClockOffset, I2S0CLKEN|I2S0EN);

	i2s_set_rate(sc, 44100);
	sc->sc_mute = 0;
	i2s_gpio_init(sc, ca->ca_node, parent);
}

int
i2s_intr(v)
	void *v;
{
	struct i2s_softc *sc = v;
	struct dbdma_command *cmd = sc->sc_odmap;
	u_int16_t c, status;

	mtx_enter(&audio_lock);

	/* if not set we are not running */
	if (!cmd) {
		mtx_leave(&audio_lock);
		return (0);
	}
	DPRINTF(("i2s_intr: cmd %p\n", cmd));

	c = in16rb(&cmd->d_command);
	status = in16rb(&cmd->d_status);

	if (c >> 12 == DBDMA_CMD_OUT_LAST)
		sc->sc_odmap = sc->sc_odmacmd;
	else
		sc->sc_odmap++;

	if (c & (DBDMA_INT_ALWAYS << 4)) {
		cmd->d_status = 0;
		if (status)	/* status == 0x8400 */
			if (sc->sc_ointr)
				(*sc->sc_ointr)(sc->sc_oarg);
	}
	mtx_leave(&audio_lock);
	return 1;
}

int
i2s_iintr(v)
	void *v;
{
	struct i2s_softc *sc = v;
	struct dbdma_command *cmd = sc->sc_idmap;
	u_int16_t c, status;

	mtx_enter(&audio_lock);

	/* if not set we are not running */
	if (!cmd) {	
		mtx_leave(&audio_lock);
		return (0);
	}
	DPRINTF(("i2s_intr: cmd %p\n", cmd));

	c = in16rb(&cmd->d_command);
	status = in16rb(&cmd->d_status);

	if (c >> 12 == DBDMA_CMD_IN_LAST)
		sc->sc_idmap = sc->sc_idmacmd;
	else
		sc->sc_idmap++;

	if (c & (DBDMA_INT_ALWAYS << 4)) {
		cmd->d_status = 0;
		if (status)	/* status == 0x8400 */
			if (sc->sc_iintr)
				(*sc->sc_iintr)(sc->sc_iarg);
	}
	mtx_leave(&audio_lock);
	return 1;
}

int
i2s_open(h, flags)
	void *h;
	int flags;
{
	return 0;
}

/*
 * Close function is called at splaudio().
 */
void
i2s_close(h)
	void *h;
{
	struct i2s_softc *sc = h;

	i2s_halt_output(sc);
	i2s_halt_input(sc);

	sc->sc_ointr = 0;
	sc->sc_iintr = 0;
}

int
i2s_set_params(h, setmode, usemode, play, rec)
	void *h;
	int setmode, usemode;
	struct audio_params *play, *rec;
{
	struct i2s_softc *sc = h;
	struct audio_params *p;
	int mode;

	p = play; /* default to play */

	/*
	 * This device only has one clock, so make the sample rates match.
	 */
	if (play->sample_rate != rec->sample_rate &&
	    usemode == (AUMODE_PLAY | AUMODE_RECORD)) {
		if (setmode == AUMODE_PLAY) {
			rec->sample_rate = play->sample_rate;
			setmode |= AUMODE_RECORD;
		} else if (setmode == AUMODE_RECORD) {
			play->sample_rate = rec->sample_rate;
			setmode |= AUMODE_PLAY;
		} else
			return EINVAL;
	}

	for (mode = AUMODE_RECORD; mode != -1;
	     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
		if ((setmode & mode) == 0)
			continue;

		p = mode == AUMODE_PLAY ? play : rec;

		if (p->sample_rate < 4000)
			p->sample_rate = 4000;
		if (p->sample_rate > 50000)
			p->sample_rate = 50000;
		if (p->precision > 16)
			p->precision = 16;
		if (p->channels > 2)
			p->channels = 2;
		p->bps = AUDIO_BPS(p->precision);
		p->msb = 1;
		p->encoding = AUDIO_ENCODING_SLINEAR_BE;
	}

	/* Set the speed */
	if (i2s_set_rate(sc, play->sample_rate))
		return EINVAL;

	p->sample_rate = sc->sc_rate;
	return 0;
}

int
i2s_round_blocksize(h, size)
	void *h;
	int size;
{
	if (size < NBPG)
		size = NBPG;
	return size & ~PGOFSET;
}

int
i2s_halt_output(h)
	void *h;
{
	struct i2s_softc *sc = h;

	dbdma_stop(sc->sc_odma);
	dbdma_reset(sc->sc_odma);
	return 0;
}

int
i2s_halt_input(h)
	void *h;
{
	struct i2s_softc *sc = h;

	dbdma_stop(sc->sc_idma);
	dbdma_reset(sc->sc_idma);
	return 0;
}

enum {
	I2S_OUTPUT_CLASS,
	I2S_RECORD_CLASS,
	I2S_OUTPUT_SELECT,
	I2S_VOL_OUTPUT,
	I2S_INPUT_SELECT,
	I2S_VOL_INPUT,
	I2S_MUTE, 		/* should be before bass/treble */
	I2S_BASS,
	I2S_TREBLE,
	I2S_ENUM_LAST
};

int
i2s_set_port(void *h, mixer_ctrl_t *mc)
{
	struct i2s_softc *sc = h;
	int l, r;

	DPRINTF(("i2s_set_port dev = %d, type = %d\n", mc->dev, mc->type));

	l = mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
	r = mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];

	switch (mc->dev) {
	case I2S_OUTPUT_SELECT:
		/* No change necessary? */
		if (mc->un.mask == sc->sc_output_mask)
			return 0;

		i2s_mute(sc->sc_spkr, 1);
		i2s_mute(sc->sc_hp, 1);
		i2s_mute(sc->sc_line, 1);
		if (mc->un.mask & I2S_SELECT_SPEAKER)
			i2s_mute(sc->sc_spkr, 0);
		if (mc->un.mask & I2S_SELECT_HEADPHONE)
			i2s_mute(sc->sc_hp, 0);
		if (mc->un.mask & I2S_SELECT_LINEOUT)
			i2s_mute(sc->sc_line, 0);

		sc->sc_output_mask = mc->un.mask;
		return 0;

	case I2S_VOL_OUTPUT:
		(*sc->sc_setvolume)(sc, l, r);
		return 0;

	case I2S_MUTE:
		if (mc->type != AUDIO_MIXER_ENUM)
			return (EINVAL);

		sc->sc_mute = (mc->un.ord != 0);

		if (sc->sc_mute) {
			if (sc->sc_output_mask & I2S_SELECT_SPEAKER)
				i2s_mute(sc->sc_spkr, 1);
			if (sc->sc_output_mask & I2S_SELECT_HEADPHONE)
				i2s_mute(sc->sc_hp, 1);
			if (sc->sc_output_mask & I2S_SELECT_LINEOUT)
				i2s_mute(sc->sc_line, 1);
		} else {
			if (sc->sc_output_mask & I2S_SELECT_SPEAKER)
				i2s_mute(sc->sc_spkr, 0);
			if (sc->sc_output_mask & I2S_SELECT_HEADPHONE)
				i2s_mute(sc->sc_hp, 0);
			if (sc->sc_output_mask & I2S_SELECT_LINEOUT)
				i2s_mute(sc->sc_line, 0);
		}

		return (0);

	case I2S_BASS:
		if (sc->sc_setbass != NULL)
			(*sc->sc_setbass)(sc, l);
		return (0);

	case I2S_TREBLE:
		if (sc->sc_settreble != NULL)
			(*sc->sc_settreble)(sc, l);
		return (0);

	case I2S_INPUT_SELECT:
		/* no change necessary? */
		if (mc->un.mask == sc->sc_record_source)
			return 0;
		switch (mc->un.mask) {
		case I2S_SELECT_SPEAKER:
		case I2S_SELECT_HEADPHONE:
			/* XXX TO BE DONE */
			break;
		default: /* invalid argument */
			return EINVAL;
		}
		if (sc->sc_setinput != NULL)
			(*sc->sc_setinput)(sc, mc->un.mask);
		sc->sc_record_source = mc->un.mask;
		return 0;

	case I2S_VOL_INPUT:
		/* XXX TO BE DONE */
		return 0;
	}

	return ENXIO;
}

int
i2s_get_port(void *h, mixer_ctrl_t *mc)
{
	struct i2s_softc *sc = h;

	DPRINTF(("i2s_get_port dev = %d, type = %d\n", mc->dev, mc->type));

	switch (mc->dev) {
	case I2S_OUTPUT_SELECT:
		mc->un.mask = sc->sc_output_mask;
		return 0;

	case I2S_VOL_OUTPUT:
		mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = sc->sc_vol_l;
		mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = sc->sc_vol_r;
		return 0;

	case I2S_MUTE:
		mc->un.ord = sc->sc_mute;
		return (0);

	case I2S_INPUT_SELECT:
		mc->un.mask = sc->sc_record_source;
		return 0;

	case I2S_BASS:
		if (mc->un.value.num_channels != 1)
			return ENXIO;
		mc->un.value.level[AUDIO_MIXER_LEVEL_MONO] = sc->sc_bass;
		return 0;

	case I2S_TREBLE:
		if (mc->un.value.num_channels != 1)
			return ENXIO;
		mc->un.value.level[AUDIO_MIXER_LEVEL_MONO] = sc->sc_treble;
		return 0;

	case I2S_VOL_INPUT:
		/* XXX TO BE DONE */
		mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = 0;
		mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = 0;
		return 0;

	default:
		return ENXIO;
	}

	return 0;
}

int
i2s_query_devinfo(void *h, mixer_devinfo_t *dip)
{
	struct i2s_softc *sc = h;
	int n = 0;

	switch (dip->index) {

	case I2S_OUTPUT_SELECT:
		dip->mixer_class = I2S_OUTPUT_CLASS;
		strlcpy(dip->label.name, AudioNselect, sizeof(dip->label.name));
		dip->type = AUDIO_MIXER_SET;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->un.s.member[n].label.name, AudioNspeaker,
		    sizeof(dip->un.s.member[n].label.name));
		dip->un.s.member[n++].mask = I2S_SELECT_SPEAKER;
		if (sc->sc_hp) {
			strlcpy(dip->un.s.member[n].label.name,
			    AudioNheadphone,
			    sizeof(dip->un.s.member[n].label.name));
			dip->un.s.member[n++].mask = I2S_SELECT_HEADPHONE;
		}
		if (sc->sc_line) {
			strlcpy(dip->un.s.member[n].label.name,	AudioNline,
			    sizeof(dip->un.s.member[n].label.name));
			dip->un.s.member[n++].mask = I2S_SELECT_LINEOUT;
		}
		dip->un.s.num_mem = n;
		return 0;

	case I2S_VOL_OUTPUT:
		dip->mixer_class = I2S_OUTPUT_CLASS;
		strlcpy(dip->label.name, AudioNmaster, sizeof(dip->label.name));
		dip->type = AUDIO_MIXER_VALUE;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = I2S_MUTE;
		dip->un.v.num_channels = 2;
		dip->un.v.delta = 8;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof(dip->un.v.units.name));
		return 0;

	case I2S_MUTE:
		dip->mixer_class = I2S_OUTPUT_CLASS;
		dip->prev = I2S_VOL_OUTPUT;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmute, sizeof(dip->label.name));
		dip->type = AUDIO_MIXER_ENUM;
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = 1;
		return (0);
 
	case I2S_INPUT_SELECT:
		dip->mixer_class = I2S_RECORD_CLASS;
		strlcpy(dip->label.name, AudioNsource, sizeof(dip->label.name));
		dip->type = AUDIO_MIXER_SET;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		dip->un.s.num_mem = 2;
		strlcpy(dip->un.s.member[0].label.name, AudioNmicrophone,
		    sizeof(dip->un.s.member[0].label.name));
		dip->un.s.member[0].mask = I2S_SELECT_SPEAKER;
		strlcpy(dip->un.s.member[1].label.name, AudioNline,
		    sizeof(dip->un.s.member[1].label.name));
		dip->un.s.member[1].mask = I2S_SELECT_HEADPHONE;
		return 0;

	case I2S_VOL_INPUT:
		dip->mixer_class = I2S_RECORD_CLASS;
		strlcpy(dip->label.name, AudioNrecord, sizeof(dip->label.name));
		dip->type = AUDIO_MIXER_VALUE;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof(dip->un.v.units.name));
		return 0;

	case I2S_OUTPUT_CLASS:
		dip->mixer_class = I2S_OUTPUT_CLASS;
		strlcpy(dip->label.name, AudioCoutputs,
		    sizeof(dip->label.name));
		dip->type = AUDIO_MIXER_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		return 0;

	case I2S_RECORD_CLASS:
		dip->mixer_class = I2S_RECORD_CLASS;
		strlcpy(dip->label.name, AudioCrecord, sizeof(dip->label.name));
		dip->type = AUDIO_MIXER_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		return 0;

	case I2S_BASS:
		if (sc->sc_setbass == NULL)
			return (ENXIO);
		dip->mixer_class = I2S_OUTPUT_CLASS;
		strlcpy(dip->label.name, AudioNbass, sizeof(dip->label.name));
		dip->type = AUDIO_MIXER_VALUE;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		dip->un.v.num_channels = 1;
		return (0);

	case I2S_TREBLE:
		if (sc->sc_settreble == NULL)
			return (ENXIO);
		dip->mixer_class = I2S_OUTPUT_CLASS;
		strlcpy(dip->label.name, AudioNtreble, sizeof(dip->label.name));
		dip->type = AUDIO_MIXER_VALUE;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		dip->un.v.num_channels = 1;
		return (0);
	}

	return ENXIO;
}

size_t
i2s_round_buffersize(h, dir, size)
	void *h;
	int dir;
	size_t size;
{
	if (size > 65536)
		size = 65536;
	return size;
}

int
i2s_get_props(h)
	void *h;
{
	return AUDIO_PROP_FULLDUPLEX /* | AUDIO_PROP_MMAP */;
}

int
i2s_trigger_output(h, start, end, bsize, intr, arg, param)
	void *h;
	void *start, *end;
	int bsize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
{
	struct i2s_softc *sc = h;
	struct i2s_dma *p;
	struct dbdma_command *cmd = sc->sc_odmacmd;
	vaddr_t spa, pa, epa;
	int c;

	DPRINTF(("trigger_output %p %p 0x%x\n", start, end, bsize));

	for (p = sc->sc_dmas; p && p->addr != start; p = p->next);
	if (!p)
		return -1;

	sc->sc_ointr = intr;
	sc->sc_oarg = arg;
	sc->sc_odmap = sc->sc_odmacmd;

	spa = p->segs[0].ds_addr;
	c = DBDMA_CMD_OUT_MORE;
	for (pa = spa, epa = spa + (end - start);
	    pa < epa; pa += bsize, cmd++) {

		if (pa + bsize == epa)
			c = DBDMA_CMD_OUT_LAST;

		DBDMA_BUILD(cmd, c, 0, bsize, pa, DBDMA_INT_ALWAYS,
			DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
	}

	DBDMA_BUILD(cmd, DBDMA_CMD_NOP, 0, 0, 0,
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_ALWAYS);
	dbdma_st32(&cmd->d_cmddep, sc->sc_odbdma->d_paddr);

	dbdma_start(sc->sc_odma, sc->sc_odbdma);

	return 0;
}

int
i2s_trigger_input(h, start, end, bsize, intr, arg, param)
	void *h;
	void *start, *end;
	int bsize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
{
	struct i2s_softc *sc = h;
	struct i2s_dma *p;
	struct dbdma_command *cmd = sc->sc_idmacmd;
	vaddr_t spa, pa, epa;
	int c;

	DPRINTF(("trigger_input %p %p 0x%x\n", start, end, bsize));

	for (p = sc->sc_dmas; p && p->addr != start; p = p->next);
	if (!p)
		return -1;

	sc->sc_iintr = intr;
	sc->sc_iarg = arg;
	sc->sc_idmap = sc->sc_idmacmd;
   
	spa = p->segs[0].ds_addr;
	c = DBDMA_CMD_IN_MORE;
	for (pa = spa, epa = spa + (end - start);
	    pa < epa; pa += bsize, cmd++) {

		if (pa + bsize == epa)
			c = DBDMA_CMD_IN_LAST;

		DBDMA_BUILD(cmd, c, 0, bsize, pa, DBDMA_INT_ALWAYS,
			DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
	}

	DBDMA_BUILD(cmd, DBDMA_CMD_NOP, 0, 0, 0,
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_ALWAYS);
	dbdma_st32(&cmd->d_cmddep, sc->sc_idbdma->d_paddr);
		
	dbdma_start(sc->sc_idma, sc->sc_idbdma);
		
	return 0;
}


/* rate = fs = LRCLK
 * SCLK = 64*LRCLK (I2S)
 * MCLK = 256fs (typ. -- changeable)
 * MCLK = clksrc / mdiv
 *  SCLK = MCLK / sdiv
 * rate = SCLK / 64    ( = LRCLK = fs)
 */
int
i2s_set_rate(sc, rate)
	struct i2s_softc *sc;
	int rate;
{
	u_int reg = 0;
	int MCLK;
	int clksrc, mdiv, sdiv;
	int mclk_fs;
	int timo;

	/* sanify */
	if (rate > (48000 + 44100) / 2)
		rate = 48000;
	else
		rate = 44100;

	switch (rate) {
	case 44100:
		clksrc = 45158400;		/* 45MHz */
		reg = CLKSRC_45MHz;
		mclk_fs = 256;
		break;

	case 48000:
		clksrc = 49152000;		/* 49MHz */
		reg = CLKSRC_49MHz;
		mclk_fs = 256;
		break;

	default:
		return EINVAL;
	}

	MCLK = rate * mclk_fs;
	mdiv = clksrc / MCLK;			/* 4 */
	sdiv = mclk_fs / 64;			/* 4 */

	switch (mdiv) {
	case 1:
		reg |= MCLK_DIV1;
		break;
	case 3:
		reg |= MCLK_DIV3;
		break;
	case 5:
		reg |= MCLK_DIV5;
		break;
	default:
		reg |= ((mdiv / 2 - 1) << 24) & 0x1f000000;
		break;
	}

	switch (sdiv) {
	case 1:
		reg |= SCLK_DIV1;
		break;
	case 3:
		reg |= SCLK_DIV3;
		break;
	default:
		reg |= ((sdiv / 2 - 1) << 20) & 0x00f00000;
		break;
	}

	reg |= SCLK_MASTER;	/* XXX master mode */

	reg |= SERIAL_64x;

	if (sc->sc_rate == rate)
		return (0);

	/* stereo input and output */
	DPRINTF(("I2SSetDataWordSizeReg 0x%08x -> 0x%08x\n",
	    in32rb(sc->sc_reg + I2S_WORDSIZE), 0x02000200));
	out32rb(sc->sc_reg + I2S_WORDSIZE, 0x02000200);

	/* Clear CLKSTOPPEND */
	out32rb(sc->sc_reg + I2S_INT, I2S_INT_CLKSTOPPEND);

	macobio_disable(I2SClockOffset, I2S0CLKEN);

	/* Wait until clock is stopped */
	for (timo = 50; timo > 0; timo--) {
		if (in32rb(sc->sc_reg + I2S_INT) & I2S_INT_CLKSTOPPEND)
			goto done;
		delay(10);
	}

	printf("i2s_set_rate: timeout\n");

done:
	DPRINTF(("I2SSetSerialFormatReg 0x%x -> 0x%x\n",
	    in32rb(sc->sc_reg + I2S_FORMAT), reg));
	out32rb(sc->sc_reg + I2S_FORMAT, reg);

	macobio_enable(I2SClockOffset, I2S0CLKEN);

	sc->sc_rate = rate;

	return 0;
}

void
i2s_mute(u_int offset, int mute)
{
	if (offset == 0)
		return;

	DPRINTF(("gpio: %x, %d -> ", offset, macobio_read(offset) & GPIO_DATA));

	/* 0 means mute */
	if (mute == (macobio_read(offset) & GPIO_DATA))
		macobio_write(offset, !mute | GPIO_DDR_OUTPUT);

	DPRINTF(("%d\n", macobio_read(offset) & GPIO_DATA));
}

int
i2s_cint(void *v)
{
	struct i2s_softc *sc = v;
	u_int sense;

	sc->sc_output_mask = 0;
	i2s_mute(sc->sc_spkr, 1);
	i2s_mute(sc->sc_hp, 1);
	i2s_mute(sc->sc_line, 1);

	if (sc->sc_hp_detect)
		sense = macobio_read(sc->sc_hp_detect);
	else
		sense = !sc->sc_hp_active << 1;
	DPRINTF(("headphone detect = 0x%x\n", sense));

	if (((sense & 0x02) >> 1) == sc->sc_hp_active) {
		DPRINTF(("headphone is inserted\n"));
		sc->sc_output_mask |= I2S_SELECT_HEADPHONE;
		if (!sc->sc_mute)
			i2s_mute(sc->sc_hp, 0);
	} else {
		DPRINTF(("headphone is NOT inserted\n"));
	}

	if (sc->sc_line_detect)
		sense = macobio_read(sc->sc_line_detect);
	else
		sense = !sc->sc_line_active << 1;
	DPRINTF(("lineout detect = 0x%x\n", sense));

	if (((sense & 0x02) >> 1) == sc->sc_line_active) {
		DPRINTF(("lineout is inserted\n"));
		sc->sc_output_mask |= I2S_SELECT_LINEOUT;
		if (!sc->sc_mute)
			i2s_mute(sc->sc_line, 0);
	} else {
		DPRINTF(("lineout is NOT inserted\n"));
	}

	if (sc->sc_output_mask == 0) {
		sc->sc_output_mask |= I2S_SELECT_SPEAKER;
		if (!sc->sc_mute)
			i2s_mute(sc->sc_spkr, 0);
	}

	return 1;
}

u_int
i2s_gpio_offset(struct i2s_softc *sc, char *name, int *irq)
{
	u_int32_t reg[2];
	u_int32_t intr[2];
	int gpio;

	if (OF_getprop(sc->sc_node, name, &gpio,
            sizeof(gpio)) != sizeof(gpio) ||
	    OF_getprop(gpio, "reg", &reg[0],
	    sizeof(reg[0])) != sizeof(reg[0]) ||
	    OF_getprop(OF_parent(gpio), "reg", &reg[1],
	    sizeof(reg[1])) != sizeof(reg[1]))
		return (0);

	if (irq && OF_getprop(gpio, "interrupts",
	    intr, sizeof(intr)) == sizeof(intr)) {
		*irq = intr[0];
	}

	return (reg[0] + reg[1]);
}

void
i2s_gpio_init(struct i2s_softc *sc, int node, struct device *parent)
{
	int gpio;
	int hp_detect_intr = -1, line_detect_intr = -1;

	sc->sc_spkr = i2s_gpio_offset(sc, "platform-amp-mute", NULL);
	sc->sc_hp = i2s_gpio_offset(sc, "platform-headphone-mute", NULL);
	sc->sc_hp_detect = i2s_gpio_offset(sc, "platform-headphone-detect",
	    &hp_detect_intr);
	sc->sc_line = i2s_gpio_offset(sc, "platform-lineout-mute", NULL);
	sc->sc_line_detect = i2s_gpio_offset(sc, "platform-lineout-detect",
	    &line_detect_intr);
	sc->sc_hw_reset = i2s_gpio_offset(sc, "platform-hw-reset", NULL);

	gpio = OF_getnodebyname(OF_parent(node), "gpio");
	DPRINTF((" /gpio 0x%x\n", gpio));
	for (gpio = OF_child(gpio); gpio; gpio = OF_peer(gpio)) {
		char name[64], audio_gpio[64];
		int intr[2];
		uint32_t reg;

		reg = 0;
		bzero(name, sizeof name);
		bzero(audio_gpio, sizeof audio_gpio);
		OF_getprop(gpio, "name", name, sizeof name);
		OF_getprop(gpio, "audio-gpio", audio_gpio, sizeof audio_gpio);
		if (OF_getprop(gpio, "reg", &reg, sizeof(reg)) == -1)
			OF_getprop(gpio, "AAPL,address", &reg, sizeof(reg));

		if (reg > sc->sc_baseaddr)
			reg = (reg - sc->sc_baseaddr);

		/* gpio5 */
		if (sc->sc_hp == 0 && strcmp(audio_gpio, "headphone-mute") == 0)
			sc->sc_hp = reg;

		/* gpio6 */
		if (sc->sc_spkr == 0 && strcmp(audio_gpio, "amp-mute") == 0)
			sc->sc_spkr = reg;

		/* extint-gpio15 */
		if (sc->sc_hp_detect == 0 &&
		    strcmp(audio_gpio, "headphone-detect") == 0) {
			sc->sc_hp_detect = reg;
			OF_getprop(gpio, "audio-gpio-active-state",
			    &sc->sc_hp_active, 4);
			OF_getprop(gpio, "interrupts", intr, 8);
			hp_detect_intr = intr[0];
		}

		/* gpio11 (keywest-11) */
		if (sc->sc_hw_reset == 0 &&
		    strcmp(audio_gpio, "audio-hw-reset") == 0)
			sc->sc_hw_reset = reg;
	}
	DPRINTF((" amp-mute 0x%x\n", sc->sc_spkr));
	DPRINTF((" headphone-mute 0x%x\n", sc->sc_hp));
	DPRINTF((" headphone-detect 0x%x\n", sc->sc_hp_detect));
	DPRINTF((" headphone-detect active %x\n", sc->sc_hp_active));
	DPRINTF((" headphone-detect intr %x\n", hp_detect_intr));
	DPRINTF((" lineout-mute 0x%x\n", sc->sc_line));
	DPRINTF((" lineout-detect 0x%x\n", sc->sc_line_detect));
	DPRINTF((" lineout-detect active 0x%x\n", sc->sc_line_active));
	DPRINTF((" lineout-detect intr 0x%x\n", line_detect_intr));
	DPRINTF((" audio-hw-reset 0x%x\n", sc->sc_hw_reset));

	if (hp_detect_intr != -1)
		mac_intr_establish(parent, hp_detect_intr, IST_EDGE,
		    IPL_AUDIO | IPL_MPSAFE, i2s_cint, sc, sc->sc_dev.dv_xname);

	if (line_detect_intr != -1)
		mac_intr_establish(parent, line_detect_intr, IST_EDGE,
		    IPL_AUDIO | IPL_MPSAFE, i2s_cint, sc, sc->sc_dev.dv_xname);

	/* Enable headphone interrupt? */
	macobio_write(sc->sc_hp_detect, 0x80);

	/* Update headphone status. */
	i2s_cint(sc);
}

void *
i2s_allocm(void *h, int dir, size_t size, int type, int flags)
{
	struct i2s_softc *sc = h;
	struct i2s_dma *p;
	int error;

	if (size > I2S_DMALIST_MAX * I2S_DMASEG_MAX)
		return (NULL);

	p = malloc(sizeof(*p), type, flags | M_ZERO);
	if (!p)
		return (NULL);

	/* convert to the bus.h style, not used otherwise */
	if (flags & M_NOWAIT)
		flags = BUS_DMA_NOWAIT;

	p->size = size;
	if ((error = bus_dmamem_alloc(sc->sc_dmat, p->size, NBPG, 0, p->segs,
	    1, &p->nsegs, flags)) != 0) {
		printf("%s: unable to allocate dma, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		free(p, type, sizeof *p);
		return NULL;
	}

	if ((error = bus_dmamem_map(sc->sc_dmat, p->segs, p->nsegs, p->size,
	    &p->addr, flags | BUS_DMA_COHERENT)) != 0) {
		printf("%s: unable to map dma, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		bus_dmamem_free(sc->sc_dmat, p->segs, p->nsegs);
		free(p, type, sizeof *p);
		return NULL;
	}

	if ((error = bus_dmamap_create(sc->sc_dmat, p->size, 1,
	    p->size, 0, flags, &p->map)) != 0) {
		printf("%s: unable to create dma map, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		bus_dmamem_unmap(sc->sc_dmat, p->addr, size);
		bus_dmamem_free(sc->sc_dmat, p->segs, p->nsegs);
		free(p, type, sizeof *p);
		return NULL;
	}

	if ((error = bus_dmamap_load(sc->sc_dmat, p->map, p->addr, p->size,
	    NULL, flags)) != 0) {
		printf("%s: unable to load dma map, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		bus_dmamap_destroy(sc->sc_dmat, p->map);
		bus_dmamem_unmap(sc->sc_dmat, p->addr, size);
		bus_dmamem_free(sc->sc_dmat, p->segs, p->nsegs);
		free(p, type, sizeof *p);
		return NULL;
	}

	p->next = sc->sc_dmas;
	sc->sc_dmas = p;

	return p->addr;
}

#define reset_active 0

int
deq_reset(struct i2s_softc *sc)
{
	if (sc->sc_hw_reset == 0)
		return (-1);

	macobio_write(sc->sc_hw_reset, !reset_active | GPIO_DDR_OUTPUT);
	delay(1000000);

	macobio_write(sc->sc_hw_reset, reset_active | GPIO_DDR_OUTPUT);
	delay(1);

	macobio_write(sc->sc_hw_reset, !reset_active | GPIO_DDR_OUTPUT);
	delay(10000);

	return (0);
}
@


1.33
log
@Properly set "msb" and "bps" fields for both play and rec directions.
Fixes "audio0: different play and record parameters ... " errors, and
probably other unreported errors.

help and ok landry@@
@
text
@a54 9
struct audio_params i2s_audio_default = {
	44100,		/* sample_rate */
	AUDIO_ENCODING_SLINEAR_BE, /* encoding */
	16,		/* precision */
	2,		/* bps */
	1,		/* msb */
	2		/* channels */
};

a223 24
i2s_query_encoding(h, ae)
	void *h;
	struct audio_encoding *ae;
{
	int err = 0;

	switch (ae->index) {
	case 0:
		strlcpy(ae->name, AudioEslinear_be, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_SLINEAR_BE;
		ae->precision = 16;
		ae->flags = 0;
		break;
	default:
		err = EINVAL;
		break;
	}
	ae->bps = AUDIO_BPS(ae->precision);
	ae->msb = 1;
	return (err);
}


int
a277 6
void
i2s_get_default_params(struct audio_params *params)
{
	*params = i2s_audio_default;
}

a594 12
}

paddr_t
i2s_mappage(h, mem, off, prot)
	void *h;
	void *mem;
	off_t off;
	int prot;
{
	if (off < 0)
		return -1;
	return -1;	/* XXX */
@


1.32
log
@Oups, remove '#define I2S_DEBUG' again.
@
text
@d298 3
a300 7

		switch (p->encoding) {
		case AUDIO_ENCODING_SLINEAR_BE:
			break;
		default:
			return (EINVAL);
		}
a307 4

	p->bps = AUDIO_BPS(p->precision);
	p->msb = 1;

@


1.31
log
@Make i2s compile with I2S_DEBUG; %x -> %p.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.30 2015/09/08 08:29:35 deraadt Exp $	*/
a48 1
#define I2S_DEBUG
@


1.30
log
@sizes for free(); ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.29 2015/07/17 22:30:58 mpi Exp $	*/
d49 1
d154 1
a154 1
	DPRINTF(("i2s_intr: cmd %x\n", cmd));
d189 1
a189 1
	DPRINTF(("i2s_intr: cmd %x\n", cmd));
@


1.29
log
@Make sound cards work on older PowerMacs.

On such machines the device-tree contains absolute addresses for the
various sound buttons and the hardware was not properly initiliazed.

Problem reported and fix tested by Fabian Frédérick.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.28 2015/06/03 08:30:27 mpi Exp $	*/
d1059 1
a1059 1
		free(p, type, 0);
d1068 1
a1068 1
		free(p, type, 0);
d1078 1
a1078 1
		free(p, type, 0);
d1089 1
a1089 1
		free(p, type, 0);
@


1.28
log
@Check for the correct bit in the interrupts property of the device-tree
to determin if interrupts should be established as edge/level triggered.

Fix audio interrupts on U4 systems.  On such systems the "interrupts"
fields in the device-tree has more bits set and cannot be compared to
0.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.27 2015/05/11 06:46:21 ratchov Exp $	*/
d981 5
a985 1
		OF_getprop(gpio, "reg", &reg, sizeof(reg));
@


1.27
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.26 2015/04/07 09:54:11 mpi Exp $	*/
d118 3
a120 3
	cirq_type = intr[1] ? IST_LEVEL : IST_EDGE;
	oirq_type = intr[3] ? IST_LEVEL : IST_EDGE;
	iirq_type = intr[5] ? IST_LEVEL : IST_EDGE;
@


1.26
log
@Mark audio interrupt handlers as MPSAFE, they already grab the right
mutex when necessary.

ok kettenis@@, ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.25 2015/03/24 16:29:09 mpi Exp $	*/
a35 1
#include <dev/auconv.h>
a36 1
#include <dev/mulaw.h>
d61 1
a61 3
	2,		/* channels */
	NULL,		/* sw_code */
	1		/* factor */
a63 2
struct i2s_mode *i2s_find_mode(u_int, u_int, u_int);

a240 6
		strlcpy(ae->name, AudioEslinear, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_SLINEAR;
		ae->precision = 16;
		ae->flags = 0;
		break;
	case 1:
a245 42
	case 2:
		strlcpy(ae->name, AudioEslinear_le, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_SLINEAR_LE;
		ae->precision = 16;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 3:
		strlcpy(ae->name, AudioEulinear_be, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_ULINEAR_BE;
		ae->precision = 16;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 4:
		strlcpy(ae->name, AudioEulinear_le, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_ULINEAR_LE;
		ae->precision = 16;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 5:
		strlcpy(ae->name, AudioEmulaw, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_ULAW;
		ae->precision = 8;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
		strlcpy(ae->name, AudioEalaw, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_ALAW;
		ae->precision = 8;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(ae->name, AudioEslinear, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_SLINEAR;
		ae->precision = 8;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 8:
		strlcpy(ae->name, AudioEulinear, sizeof(ae->name));
		ae->encoding = AUDIO_ENCODING_ULINEAR;
		ae->precision = 8;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
a255 42
struct i2s_mode {
	u_int encoding;
	u_int precision;
	u_int channels;
	void (*sw_code)(void *, u_char *, int);
	int factor;
} i2s_modes[] = {
	{ AUDIO_ENCODING_SLINEAR_LE,  8, 1, linear8_to_linear16_be_mts, 4 },
	{ AUDIO_ENCODING_SLINEAR_LE,  8, 2, linear8_to_linear16_be, 2 },
	{ AUDIO_ENCODING_SLINEAR_LE, 16, 1, swap_bytes_mts, 2 },
	{ AUDIO_ENCODING_SLINEAR_LE, 16, 2, swap_bytes, 1 },
	{ AUDIO_ENCODING_SLINEAR_BE,  8, 1, linear8_to_linear16_be_mts, 4 },
	{ AUDIO_ENCODING_SLINEAR_BE,  8, 2, linear8_to_linear16_be, 2 },
	{ AUDIO_ENCODING_SLINEAR_BE, 16, 1, noswap_bytes_mts, 2 },
	{ AUDIO_ENCODING_SLINEAR_BE, 16, 2, NULL, 1 },
	{ AUDIO_ENCODING_ULINEAR_LE,  8, 1, ulinear8_to_linear16_be_mts, 4 },
	{ AUDIO_ENCODING_ULINEAR_LE,  8, 2, ulinear8_to_linear16_be, 2 },
	{ AUDIO_ENCODING_ULINEAR_LE, 16, 1, change_sign16_swap_bytes_le_mts, 2 },
	{ AUDIO_ENCODING_ULINEAR_LE, 16, 2, swap_bytes_change_sign16_be, 1 },
	{ AUDIO_ENCODING_ULINEAR_BE,  8, 1, ulinear8_to_linear16_be_mts, 4 },
	{ AUDIO_ENCODING_ULINEAR_BE,  8, 2, ulinear8_to_linear16_be, 2 },
	{ AUDIO_ENCODING_ULINEAR_BE, 16, 1, change_sign16_be_mts, 2 },
	{ AUDIO_ENCODING_ULINEAR_BE, 16, 2, change_sign16_be, 1 }
};


struct i2s_mode *
i2s_find_mode(u_int encoding, u_int precision, u_int channels)
{
	struct i2s_mode *m;
	int i;

	for (i = 0; i < sizeof(i2s_modes)/sizeof(i2s_modes[0]); i++) {
		m = &i2s_modes[i];
		if (m->encoding == encoding &&
		    m->precision == precision &&
		    m->channels == channels)
			return (m);
	}
	return (NULL);
}

a261 1
	struct i2s_mode *m;
a299 1
		case AUDIO_ENCODING_SLINEAR_LE:
a300 11
		case AUDIO_ENCODING_ULINEAR_LE:
		case AUDIO_ENCODING_ULINEAR_BE:
			m = i2s_find_mode(p->encoding, p->precision,
			    p->channels);
			if (m == NULL) {
				printf("mode not found: %u/%u/%u\n",
				    p->encoding, p->precision, p->channels);
				return (EINVAL);
			}
			p->factor = m->factor;
			p->sw_code = m->sw_code;
a301 33

		case AUDIO_ENCODING_ULAW:
			if (mode == AUMODE_PLAY) {
				if (p->channels == 1) {
					p->factor = 4;
					p->sw_code = mulaw_to_slinear16_be_mts;
					break;
				}
				if (p->channels == 2) {
					p->factor = 2;
					p->sw_code = mulaw_to_slinear16_be;
					break;
				}
			} else
				break; /* XXX */
			return (EINVAL);

		case AUDIO_ENCODING_ALAW:
			if (mode == AUMODE_PLAY) {
				if (p->channels == 1) {
					p->factor = 4;
					p->sw_code = alaw_to_slinear16_be_mts;
					break;
				}
				if (p->channels == 2) {
					p->factor = 2;
					p->sw_code = alaw_to_slinear16_be;
					break;
				}
			} else
				break; /* XXX */
			return (EINVAL);

@


1.25
log
@Work around broken device-tree in PowerMac7,2 and PowerMac7,3 (K2 systems)
and get the correct offsets from the "i2s" node.  Also explicitly enable
the clock in FCR1 as the firmware does not do it on such machine.

Still not enough to get the sound working in such systems but get rid of
the annoying "i2s_set_rate: timeout" message during boot and plugging an
headphone is now correctly detected.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.24 2014/07/12 18:44:42 tedu Exp $	*/
d129 4
a132 4
	mac_intr_establish(parent, oirq, oirq_type, IPL_AUDIO, i2s_intr,
	    sc, sc->sc_dev.dv_xname);
	mac_intr_establish(parent, iirq, iirq_type, IPL_AUDIO, i2s_iintr,
	    sc, sc->sc_dev.dv_xname);
d1161 1
a1161 1
		    IPL_AUDIO, i2s_cint, sc, sc->sc_dev.dv_xname);
d1165 1
a1165 1
		    IPL_AUDIO, i2s_cint, sc, sc->sc_dev.dv_xname);
@


1.24
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.23 2013/05/15 08:29:23 ratchov Exp $	*/
d87 2
d94 12
d135 3
@


1.23
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.22 2011/06/07 16:29:51 mpi Exp $	*/
d1180 1
a1180 1
		free(p, type);
d1189 1
a1189 1
		free(p, type);
d1199 1
a1199 1
		free(p, type);
d1210 1
a1210 1
		free(p, type);
@


1.22
log
@Make use of macobio_* methods to manage the i2s GPIOs, remove the customs
gpio_* methods and move the remaining global variables in the softc.

ok ratchov@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.21 2011/05/15 09:10:26 mpi Exp $	*/
d135 2
d138 2
a139 1
	if (!cmd)
d141 1
d158 1
a158 1

d170 2
d173 2
a174 1
	if (!cmd)
d176 1
d193 1
a193 1

@


1.21
log
@Unify various gpio access using methods that take an offset relative to the
mac-io bus base address. Needed  by upcoming dfs(4) support.

On some Apple machines, the openfirmware returns a gpio offset relative to
the gpio controller (generaly at 0x50). These offsets should be corrected
to be relative to the bus base address.

looks fine to kettenis@@, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.20 2011/05/05 18:54:23 jasper Exp $	*/
d70 4
a73 8
static int gpio_read(char *);
static void gpio_write(char *, int);
void i2s_mute_speaker(struct i2s_softc *, int);
void i2s_mute_headphone(struct i2s_softc *, int);
void i2s_mute_lineout(struct i2s_softc *, int);
int i2s_cint(void *);
u_char *i2s_gpio_map(struct i2s_softc *, char *, int *);
void i2s_init(struct i2s_softc *, int);
d75 2
a76 2
int i2s_intr(void *);
int i2s_iintr(void *);
a81 9
static u_char *amp_mute;
static u_char *headphone_mute;
static u_char *lineout_mute;
static u_char *audio_hw_reset;
static u_char *headphone_detect;
static int headphone_detect_active;
static u_char *lineout_detect;
static int lineout_detect_active;

d504 9
a512 9
		i2s_mute_speaker(sc, 1);
		i2s_mute_headphone(sc, 1);
		i2s_mute_lineout(sc, 1);
		if (mc->un.mask & 1 << 0)
			i2s_mute_speaker(sc, 0);
		if (mc->un.mask & 1 << 1)
			i2s_mute_headphone(sc, 0);
		if (mc->un.mask & 1 << 2)
			i2s_mute_lineout(sc, 0);
d528 6
a533 6
			if (sc->sc_output_mask & 1 << 0)
				i2s_mute_speaker(sc, 1);
			if (sc->sc_output_mask & 1 << 1)
				i2s_mute_headphone(sc, 1);
			if (sc->sc_output_mask & 1 << 2)
				i2s_mute_lineout(sc, 1);
d535 6
a540 6
			if (sc->sc_output_mask & 1 << 0)
				i2s_mute_speaker(sc, 0);
			if (sc->sc_output_mask & 1 << 1)
				i2s_mute_headphone(sc, 0);
			if (sc->sc_output_mask & 1 << 2)
				i2s_mute_lineout(sc, 0);
d560 2
a561 2
		case 1 << 0: /* microphone */
		case 1 << 1: /* line in */
d645 2
a646 2
		dip->un.s.member[n++].mask = 1 << 0;
		if (headphone_mute) {
d650 1
a650 1
			dip->un.s.member[n++].mask = 1 << 1;
d652 1
a652 1
		if (lineout_mute) {
d655 1
a655 1
			dip->un.s.member[n++].mask = 1 << 2;
d695 1
a695 1
		dip->un.s.member[0].mask = 1 << 0;
d698 1
a698 1
		dip->un.s.member[1].mask = 1 << 1;
a982 48
int
gpio_read(addr)
	char *addr;
{
	if (*addr & GPIO_DATA)
		return 1;
	return 0;
}

void
gpio_write(addr, val)
	char *addr;
	int val;
{
	u_int data = GPIO_DDR_OUTPUT;

	if (val)
		data |= GPIO_DATA;
	*addr = data;
	asm volatile ("eieio" ::: "memory");
}

#define amp_active 0		/* XXX OF */
#define headphone_active 0	/* XXX OF */
#define lineout_active 0	/* XXX OF */

void
i2s_mute_speaker(sc, mute)
	struct i2s_softc *sc;
	int mute;
{
	u_int x;

	if (amp_mute == NULL)
		return;

	DPRINTF(("ampmute %d --> ", gpio_read(amp_mute)));

	if (mute)
		x = amp_active;		/* mute */
	else
		x = !amp_active;	/* unmute */
	if (x != gpio_read(amp_mute))
		gpio_write(amp_mute, x);

	DPRINTF(("%d\n", gpio_read(amp_mute)));
}

d984 1
a984 3
i2s_mute_headphone(sc, mute)
	struct i2s_softc *sc;
	int mute;
d986 1
a986 3
	u_int x;

	if (headphone_mute == NULL)
d989 1
a989 1
	DPRINTF(("headphonemute %d --> ", gpio_read(headphone_mute)));
d991 3
a993 6
	if (mute)
		x = headphone_active;	/* mute */
	else
		x = !headphone_active;	/* unmute */
	if (x != gpio_read(headphone_mute))
		gpio_write(headphone_mute, x);
d995 1
a995 23
	DPRINTF(("%d\n", gpio_read(headphone_mute)));
}

void
i2s_mute_lineout(sc, mute)
	struct i2s_softc *sc;
	int mute;
{
	u_int x;

	if (lineout_mute == NULL)
		return;

	DPRINTF(("lineout %d --> ", gpio_read(lineout_mute)));

	if (mute)
		x = lineout_active;	/* mute */
	else
		x = !lineout_active;	/* unmute */
	if (x != gpio_read(lineout_mute))
		gpio_write(lineout_mute, x);

	DPRINTF(("%d\n", gpio_read(lineout_mute)));
d999 1
a999 2
i2s_cint(v)
	void *v;
d1005 3
a1007 3
	i2s_mute_speaker(sc, 1);
	i2s_mute_headphone(sc, 1);
	i2s_mute_lineout(sc, 1);
d1009 2
a1010 2
	if (headphone_detect)
		sense = *headphone_detect;
d1012 1
a1012 1
		sense = !headphone_detect_active << 1;
d1015 1
a1015 1
	if (((sense & 0x02) >> 1) == headphone_detect_active) {
d1017 1
a1017 1
		sc->sc_output_mask |= 1 << 1;
d1019 1
a1019 1
			i2s_mute_headphone(sc, 0);
d1024 2
a1025 2
	if (lineout_detect)
		sense = *lineout_detect;
d1027 1
a1027 1
		sense = !lineout_detect_active << 1;
d1030 1
a1030 1
	if (((sense & 0x02) >> 1) == lineout_detect_active) {
d1032 1
a1032 1
		sc->sc_output_mask |= 1 << 2;
d1034 1
a1034 1
			i2s_mute_lineout(sc, 0);
d1040 1
a1040 1
		sc->sc_output_mask |= 1 << 0;
d1042 1
a1042 1
			i2s_mute_speaker(sc, 0);
d1048 2
a1049 2
u_char *
i2s_gpio_map(struct i2s_softc *sc, char *name, int *irq)
d1061 1
a1061 1
		return NULL;
d1068 1
a1068 1
	return mapiodev(sc->sc_baseaddr + reg[0] + reg[1], 1);
d1072 1
a1072 4
i2s_gpio_init(sc, node, parent)
	struct i2s_softc *sc;
	int node;
	struct device *parent;
d1075 1
a1075 2
	int headphone_detect_intr = -1, headphone_detect_intrtype;
	int lineout_detect_intr = -1;
d1077 8
a1084 9
	/* Map gpios. */
	amp_mute = i2s_gpio_map(sc, "platform-amp-mute", NULL);
	headphone_mute = i2s_gpio_map(sc, "platform-headphone-mute", NULL);
	headphone_detect = i2s_gpio_map(sc, "platform-headphone-detect",
	    &headphone_detect_intr);
	lineout_mute = i2s_gpio_map(sc, "platform-lineout-mute", NULL);
	lineout_detect = i2s_gpio_map(sc, "platform-lineout-detect",
	    &lineout_detect_intr);
	audio_hw_reset = i2s_gpio_map(sc, "platform-hw-reset", NULL);
d1088 1
a1088 2
	gpio = OF_child(gpio);
	while (gpio) {
d1091 1
a1091 1
		paddr_t addr;
d1093 1
a1095 1
		addr = 0;
d1098 1
a1098 2
		OF_getprop(gpio, "AAPL,address", &addr, sizeof addr);
		/* printf("0x%x %s %s\n", gpio, name, audio_gpio); */
d1101 2
a1102 3
		if (headphone_mute == NULL &&
		    strcmp(audio_gpio, "headphone-mute") == 0)
			headphone_mute = mapiodev(addr,1);
d1105 2
a1106 3
		if (amp_mute == NULL &&
		    strcmp(audio_gpio, "amp-mute") == 0)
			amp_mute = mapiodev(addr,1);
d1109 1
a1109 1
		if (headphone_detect == NULL &&
d1111 1
a1111 1
			headphone_detect = mapiodev(addr,1);
d1113 1
a1113 1
			    &headphone_detect_active, 4);
d1115 1
a1115 2
			headphone_detect_intr = intr[0];
			headphone_detect_intrtype = intr[1];
d1119 1
a1119 1
		if (audio_hw_reset == NULL &&
d1121 1
a1121 3
			audio_hw_reset = mapiodev(addr,1);

		gpio = OF_peer(gpio);
d1123 10
a1132 10
	DPRINTF((" amp-mute %p\n", amp_mute));
	DPRINTF((" headphone-mute %p\n", headphone_mute));
	DPRINTF((" headphone-detect %p\n", headphone_detect));
	DPRINTF((" headphone-detect active %x\n", headphone_detect_active));
	DPRINTF((" headphone-detect intr %x\n", headphone_detect_intr));
	DPRINTF((" lineout-mute %p\n", lineout_mute));
	DPRINTF((" lineout-detect %p\n", lineout_detect));
	DPRINTF((" lineout-detect active %x\n", lineout_detect_active));
	DPRINTF((" lineout-detect intr %x\n", lineout_detect_intr));
	DPRINTF((" audio-hw-reset %p\n", audio_hw_reset));
d1134 2
a1135 2
	if (headphone_detect_intr != -1)
		mac_intr_establish(parent, headphone_detect_intr, IST_EDGE,
d1138 2
a1139 2
	if (lineout_detect_intr != -1)
		mac_intr_establish(parent, lineout_detect_intr, IST_EDGE,
d1143 1
a1143 2
	*headphone_detect |= 0x80;
	asm volatile("eieio");
d1217 1
a1217 1
	if (audio_hw_reset == NULL)
d1220 1
a1220 1
	gpio_write(audio_hw_reset, !reset_active);
d1223 1
a1223 1
	gpio_write(audio_hw_reset, reset_active);
d1226 1
a1226 1
	gpio_write(audio_hw_reset, !reset_active);
@


1.20
log
@add support for muting the master channel on i2s based cards, this allows the
"mute" key on keyboards to function too.
tested by kettenis on aoa(4) and snapper(4) by me.

from Martin Pieuchot
ok kettenis@@ ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.19 2011/05/04 15:50:49 jasper Exp $	*/
d49 1
a81 4
/* XXX */
void keylargo_fcr_enable(int, u_int32_t);
void keylargo_fcr_disable(int, u_int32_t);

a94 19
/* GPIO bits */
#define GPIO_OUTSEL	0xf0	/* Output select */
		/*	0x00	GPIO bit0 is output
			0x10	media-bay power
			0x20	reserved
			0x30	MPIC */

#define GPIO_ALTOE	0x08	/* Alternate output enable */
		/*	0x00	Use DDR
			0x08	Use output select */

#define GPIO_DDR	0x04	/* Data direction */
#define GPIO_DDR_OUTPUT	0x04	/* Output */
#define GPIO_DDR_INPUT	0x00	/* Input */

#define GPIO_LEVEL	0x02	/* Pin level (RO) */

#define	GPIO_DATA	0x01	/* Data */

d973 1
a973 1
	keylargo_fcr_disable(I2SClockOffset, I2S0CLKEN);
d989 1
a989 1
	keylargo_fcr_enable(I2SClockOffset, I2S0CLKEN);
@


1.19
log
@fix volume up and down using the keyboard keys

from Martin Pieuchot
ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.18 2010/07/15 03:43:11 jakemsr Exp $	*/
d158 1
d516 1
d523 1
a523 3
i2s_set_port(h, mc)
	void *h;
	mixer_ctrl_t *mc;
d556 24
d616 1
a616 3
i2s_get_port(h, mc)
	void *h;
	mixer_ctrl_t *mc;
d632 4
d699 2
a700 1
		dip->prev = dip->next = AUDIO_MIXER_LAST;
d707 15
d1131 2
a1132 1
		i2s_mute_headphone(sc, 0);
d1146 2
a1147 1
		i2s_mute_lineout(sc, 0);
d1154 2
a1155 1
		i2s_mute_speaker(sc, 0);
@


1.18
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.17 2008/11/07 19:53:20 todd Exp $	*/
d640 1
a640 3
i2s_query_devinfo(h, dip)
	void *h;
	mixer_devinfo_t *dip;
d675 1
@


1.17
log
@different fix for pr5883 than proposed by the submitter, found when glancing
at apple code
go ahead drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.16 2008/11/05 21:38:03 jakemsr Exp $	*/
d60 2
d313 2
d463 3
@


1.16
log
@return an error when trying to get stereo values from a mono
control.  makes mixerctl(1) output more sensible.

ok drahn, todd
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.15 2008/10/30 06:12:47 todd Exp $	*/
d950 1
a950 1
	for (timo = 1000; timo > 0; timo--) {
d953 1
a953 1
		delay(1);
@


1.15
log
@patches for macppc to remove more EINVAL returns in the audio code
tested by me, from ratchov@@, please commit ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.14 2008/10/29 03:00:19 deraadt Exp $	*/
d608 2
d611 1
a611 1
		return (0);
d614 2
d617 1
a617 1
		return (0);
@


1.14
log
@come on -- this was not even test compiled
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.13 2008/10/29 00:04:14 jakemsr Exp $	*/
d392 8
a399 4
		if (p->sample_rate < 4000 || p->sample_rate > 50000 ||
		    (p->precision != 8 && p->precision != 16) ||
		    (p->channels != 1 && p->channels != 2))
			return EINVAL;
d875 1
a875 1
	if (rate > 48000)
d877 1
a877 1
	else if (rate < 44100)
@


1.13
log
@
native default parameters for i2s devices instead of 8kHz
mulaw mono, which few can even do.

"Please just get this in." brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.12 2008/08/24 23:44:44 todd Exp $	*/
d56 1
a56 1
struct i2s_audio_default {
@


1.12
log
@o implement proper volume control table based on chipset docs
o attempt to make record work (but silence for now)
from drahn@@, ok maja@@, drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.11 2007/12/11 09:11:54 jakemsr Exp $	*/
d56 9
d457 6
@


1.11
log
@remove support for 8kHz sample rates.  not all i2s based audio
devices support 8kHz sample rates, and there is insufficient
code to enable it properly on the devices that do support 8kHz.

fixes "evil sound" problem reported by ajacoutot@@ and jdixon@@.

ok deanna@@, ratchov@@, ajacoutot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.10 2007/11/05 00:17:28 jakemsr Exp $	*/
d67 3
d141 2
a142 1
	/* intr_establish(iirq, iirq_type, IPL_AUDIO, i2s_intr, sc); */
d182 31
d545 2
a546 3
		case 1 << 0: /* CD */
		case 1 << 1: /* microphone */
		case 1 << 2: /* line in */
d552 2
d656 2
a657 2
		dip->un.s.num_mem = 3;
		strlcpy(dip->un.s.member[0].label.name, AudioNcd,
d660 1
a660 1
		strlcpy(dip->un.s.member[1].label.name, AudioNmicrophone,
a662 3
		strlcpy(dip->un.s.member[2].label.name, AudioNline,
		    sizeof(dip->un.s.member[2].label.name));
		dip->un.s.member[2].mask = 1 << 2;
d799 27
a825 1
	DPRINTF(("i2s_trigger_input called\n"));
d827 7
a833 1
	return 1;
@


1.10
log
@audio encoding conversion cleanup

- the endianness of the conversions don't depend on the endianness
  of machine the conversions are built on, but the endianness of the
  audio data itself.  choose encoding conversions explicitly, instead
  of relying on #defines based on the endianness of the machine.
- replace home-grown conversions with comparable conversions in
  auconv.c and mulaw.c
- use the proper conversion for ulinear_be:16 -> slinear_le:16 in
  auixp(4)

thanks ajacoutot@@ and sthen@@ for !x86 testing
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.9 2007/09/17 01:33:33 krw Exp $	*/
d793 2
a794 2
	else if (rate < 8000)
		rate = 8000;
a796 6
	case 8000:
		clksrc = 18432000;		/* 18MHz */
		reg = CLKSRC_18MHz;
		mclk_fs = 256;
		break;

@


1.9
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.8 2007/04/22 22:31:14 deraadt Exp $	*/
a56 1
void i2s_cs16mts(void *, u_char *, int);
a66 3
static void mono16_to_stereo16(void *, u_char *, int);
static void swap_bytes_mono16_to_stereo16(void *, u_char *, int);

a269 35
static void
mono16_to_stereo16(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	int x;
	int16_t *src, *dst;

	src = (void *)(p + cc);
	dst = (void *)(p + cc * 2);
	while (cc > 0) {
		x = *--src;
		*--dst = x;
		*--dst = x;
		cc -= 2;
	}
}

static void
swap_bytes_mono16_to_stereo16(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	swap_bytes(v, p, cc);
	mono16_to_stereo16(v, p, cc);
}

void
i2s_cs16mts(void *v, u_char *p, int cc)
{
	mono16_to_stereo16(v, p, cc);
	change_sign16_be(v, p, cc * 2);
}
d280 1
a280 1
	{ AUDIO_ENCODING_SLINEAR_LE, 16, 1, swap_bytes_mono16_to_stereo16, 2 },
d284 1
a284 1
	{ AUDIO_ENCODING_SLINEAR_BE, 16, 1, mono16_to_stereo16, 2 },
d292 1
a292 1
	{ AUDIO_ENCODING_ULINEAR_BE, 16, 1, i2s_cs16mts, 2 },
@


1.8
log
@better interrupt names for vmstat -iz; ok miod gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.7 2007/04/21 15:43:27 gwk Exp $	*/
d1191 1
a1191 1
	p = malloc(sizeof(*p), type, flags);
a1193 1
	bzero(p, sizeof(*p));
@


1.7
log
@Add blinkenlights(4) a driver to control the 16 leds found on the front
panel of the Xserve G4 and G5. The leds will provide an indication of the
system load slowing as the load climbs, and system health e.g. no
lights means its dead or in DDB.

Split some of the shared registers and clock divisors from i2s into
i2sreg.h while there nuke some evil C++ style comments.
Man page to follow shortly.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.6 2006/01/08 18:11:03 kettenis Exp $	*/
d141 1
a141 1
	    sc, "i2s");
d1167 1
a1167 1
		    IPL_AUDIO, i2s_cint, sc, "i2s_h");
d1171 1
a1171 1
		    IPL_AUDIO, i2s_cint, sc, "i2s_l");
@


1.6
log
@Don't provide bass and treble mixer controls if the underlying hardware doesn't
provide these.  Put them in the outputs class.
ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.5 2005/12/11 20:56:01 kettenis Exp $	*/
d48 1
a87 18

/* I2S registers */
#define I2S_INT		0x00
#define I2S_FORMAT	0x10
#define I2S_FRAMECOUNT	0x40
#define I2S_FRAMEMATCH	0x50
#define I2S_WORDSIZE	0x60

/* I2S_INT register definitions */
#define I2SClockOffset		0x3c
#define I2S_INT_CLKSTOPPEND	0x01000000

/* FCR(0x3c) bits */
#define I2S0CLKEN	0x1000
#define I2S0EN		0x2000
#define I2S1CLKEN	0x080000
#define I2S1EN		0x100000

a809 26
#define CLKSRC_49MHz	0x80000000	/* Use 49152000Hz Osc. */
#define CLKSRC_45MHz	0x40000000	/* Use 45158400Hz Osc. */
#define CLKSRC_18MHz	0x00000000	/* Use 18432000Hz Osc. */
#define MCLK_DIV	0x1f000000	/* MCLK = SRC / DIV */
#define  MCLK_DIV1	0x14000000	/*  MCLK = SRC */
#define  MCLK_DIV3	0x13000000	/*  MCLK = SRC / 3 */
#define  MCLK_DIV5	0x12000000	/*  MCLK = SRC / 5 */
#define SCLK_DIV	0x00f00000	/* SCLK = MCLK / DIV */
#define  SCLK_DIV1	0x00800000
#define  SCLK_DIV3	0x00900000
#define SCLK_MASTER	0x00080000	/* Master mode */
#define SCLK_SLAVE	0x00000000	/* Slave mode */
#define SERIAL_FORMAT	0x00070000
#define  SERIAL_SONY	0x00000000
#define  SERIAL_64x	0x00010000
#define  SERIAL_32x	0x00020000
#define  SERIAL_DAV	0x00040000
#define  SERIAL_SILICON	0x00050000

// rate = fs = LRCLK
// SCLK = 64*LRCLK (I2S)
// MCLK = 256fs (typ. -- changeable)

// MCLK = clksrc / mdiv
// SCLK = MCLK / sdiv
// rate = SCLK / 64    ( = LRCLK = fs)
d811 7
d859 2
a860 2
	mdiv = clksrc / MCLK;			// 4
	sdiv = mclk_fs / 64;			// 4
@


1.5
log
@Fix mixer for machines that have lineout and/or don't have headphone.
ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.4 2005/11/19 00:00:47 kettenis Exp $	*/
a503 1
	I2S_MONITOR_CLASS,
d634 1
a697 7
	case I2S_MONITOR_CLASS:
		dip->mixer_class = I2S_MONITOR_CLASS;
		strlcpy(dip->label.name, AudioCmonitor, sizeof(dip->label.name));
		dip->type = AUDIO_MIXER_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		return 0;

d714 3
a716 1
		dip->mixer_class = I2S_MONITOR_CLASS;
d724 3
a726 1
		dip->mixer_class = I2S_MONITOR_CLASS;
a731 1

@


1.4
log
@Get device resources from soundbus node instead of i2s node.  This makes sound
work on the iMac G5, and should work on older systems too.
tested by cloder@@, miod@@; ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.3 2005/11/17 02:58:03 brad Exp $	*/
d62 1
d64 1
a64 1
u_char *i2s_gpio_map(struct i2s_softc *, char *);
d80 1
d84 2
d537 1
d542 2
d635 2
d644 15
a658 7
		dip->un.s.num_mem = 2;
		strlcpy(dip->un.s.member[0].label.name, AudioNspeaker,
		    sizeof(dip->un.s.member[0].label.name));
		dip->un.s.member[0].mask = 1 << 0;
		strlcpy(dip->un.s.member[1].label.name, AudioNheadphone,
		    sizeof(dip->un.s.member[1].label.name));
		dip->un.s.member[1].mask = 1 << 1;
d989 1
d991 1
a991 1
#define amp_active 0		/* XXX OF */
d1000 3
d1022 3
d1037 22
d1066 9
a1074 1
	sense = *headphone_detect;
d1079 1
a1079 1
		i2s_mute_speaker(sc, 1);
a1080 1
		sc->sc_output_mask = 1 << 1;
d1083 18
a1101 2
		i2s_mute_headphone(sc, 1);
		sc->sc_output_mask = 1 << 0;
d1108 1
a1108 1
i2s_gpio_map(struct i2s_softc *sc, char *name)
d1111 1
d1122 5
d1138 1
d1141 8
a1148 2
	amp_mute = i2s_gpio_map(sc, "platform-amp-mute");
	audio_hw_reset = i2s_gpio_map(sc, "platform-hw-reset");
d1194 1
a1195 1
	DPRINTF((" amp-mute %p\n", amp_mute));
d1199 4
d1208 4
@


1.3
log
@fix mixer control names.

i2s.c diff from Tsubai Masanari's CVS repo.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.2 2005/10/31 00:26:07 joris Exp $	*/
d63 1
d124 1
a124 1
	int soundbus, intr[6];
d126 2
a127 3
	ca->ca_reg[0] += ca->ca_baseaddr;
	ca->ca_reg[2] += ca->ca_baseaddr;
	ca->ca_reg[4] += ca->ca_baseaddr;
d129 4
a132 1
	sc->sc_reg = mapiodev(ca->ca_reg[0], ca->ca_reg[1]);
d134 1
a134 1
	sc->sc_node = ca->ca_node;
d137 2
a138 2
	sc->sc_odma = mapiodev(ca->ca_reg[2], ca->ca_reg[3]); /* out */
	sc->sc_idma = mapiodev(ca->ca_reg[4], ca->ca_reg[5]); /* in */
d144 1
a144 2
	soundbus = OF_child(ca->ca_node);
	OF_getprop(soundbus, "interrupts", intr, sizeof intr);
d160 1
a160 1
	i2s_gpio_init(sc,  sc->sc_node, parent);
d1038 17
d1063 4
@


1.2
log
@- add needed bass & treble glue in i2s;
- add support for bass & treble in snapper;

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.1 2005/10/26 17:57:20 joris Exp $	*/
d629 2
a630 2
		dip->mixer_class = I2S_MONITOR_CLASS;
		strlcpy(dip->label.name, AudioNoutput, sizeof(dip->label.name));
d643 1
a643 1
		dip->mixer_class = I2S_MONITOR_CLASS;
@


1.1
log
@add an i2s framework, which can be reused in new audio drivers
for macppc, as most modern Apple machines have i2s-based audio.

also let snapper use i2s.c right away;

tested by Antoine Jacoutot, drahn@@ and kettenis@@
"yes, commit!" drahn@@, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i2s.c,v 1.19 2005/10/20 20:35:12 joris Exp $	*/
d505 2
d543 10
d600 8
d700 17
@

