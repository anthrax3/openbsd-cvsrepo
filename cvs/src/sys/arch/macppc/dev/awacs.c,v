head	1.34;
access;
symbols
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.32.0.4
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.31.0.4
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.28.0.6
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.6
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.4
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.2
	OPENBSD_5_0:1.25.0.6
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.4
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.24.0.4
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.6
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.8
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.6
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.11
	UBC:1.6.0.2
	UBC_BASE:1.6
	SMP:1.5.0.4
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.34
date	2016.09.19.06.46.43;	author ratchov;	state Exp;
branches;
next	1.33;
commitid	qGgYgJTgEFuAoGj4;

1.33
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.32;
commitid	pi1a9KN0itEngOc4;

1.32
date	2015.09.08.08.29.35;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	Qv4sSaeodDiHWA1c;

1.31
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.30;
commitid	RaOGL5SyOGOZylwx;

1.30
date	2015.04.07.09.54.11;	author mpi;	state Exp;
branches;
next	1.29;
commitid	gzeyx2aLQJxxkIke;

1.29
date	2014.07.12.18.44.42;	author tedu;	state Exp;
branches;
next	1.28;
commitid	uKVPYMN2MLxdZxzH;

1.28
date	2013.05.15.08.29.23;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2011.09.04.18.48.10;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2011.09.04.18.46.41;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.24;

1.24
date	2008.10.30.06.22.38;	author todd;	state Exp;
branches;
next	1.23;

1.23
date	2008.10.30.06.12.47;	author todd;	state Exp;
branches;
next	1.22;

1.22
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.05.00.17.28;	author jakemsr;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.22.22.31.14;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.17.02.58.03;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.18.13.51.35;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.16.03.31.25;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.16.03.45.40;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.16.03.22.45;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.14.04.43.20;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.11.19.41.10;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.15.09.01.58;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.15.02.02.43;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.26.36;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.30.06.53.56;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.20.23.10.34;	author ericj;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.31.11.00.24;	author art;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.09.25.00.13.18;	author drahn;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.09.15.01.51.11;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.11.20.05.24;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.01.17.43.09;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.50.00;	author drahn;	state Exp;
branches;
next	;

1.5.4.1
date	2001.10.31.03.01.15;	author nate;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.11.13.21.00.53;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2002.03.06.01.06.10;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2002.03.28.10.36.01;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2003.05.13.19.41.05;	author ho;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2004.02.19.10.49.03;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.01.31.22.55.14;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.06.11.03.36.33;	author art;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Remove unused getdev() audio driver functions.
@
text
@/*	$OpenBSD: awacs.c,v 1.33 2016/09/14 06:12:19 ratchov Exp $	*/
/*	$NetBSD: awacs.c,v 1.4 2001/02/26 21:07:51 wiz Exp $	*/

/*-
 * Copyright (c) 2000 Tsubai Masanari.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/audioio.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/systm.h>

#include <dev/audio_if.h>

#include <machine/bus.h>
#include <machine/autoconf.h>
#include <macppc/dev/dbdma.h>

#ifdef AWACS_DEBUG
# define DPRINTF printf
#else
# define DPRINTF while (0) printf
#endif

#define	AWACS_DMALIST_MAX	32
#define	AWACS_DMASEG_MAX	NBPG

struct awacs_dma {
	bus_dmamap_t map;
	caddr_t addr;
	bus_dma_segment_t segs[AWACS_DMALIST_MAX];
	int nsegs;
	size_t size;
	struct awacs_dma *next;
};


struct awacs_softc {
	struct device sc_dev;

	void (*sc_ointr)(void *);	/* dma completion intr handler */
	void *sc_oarg;			/* arg for sc_ointr() */

	void (*sc_iintr)(void *);	/* dma completion intr handler */
	void *sc_iarg;			/* arg for sc_iintr() */

	u_int sc_record_source;		/* recording source mask */
	u_int sc_output_mask;		/* output source mask */

	char *sc_reg;
	u_int sc_codecctl0;
	u_int sc_codecctl1;
	u_int sc_codecctl2;
	u_int sc_codecctl4;
	u_int sc_soundctl;

	bus_dma_tag_t sc_dmat;
	struct dbdma_regmap *sc_odma;
	struct dbdma_regmap *sc_idma;
	struct dbdma_command *sc_odmacmd, *sc_odmap;
	struct dbdma_command *sc_idmacmd, *sc_idmap;
	dbdma_t sc_odbdma, sc_idbdma;

	struct awacs_dma *sc_dmas;
};

int awacs_match(struct device *, void *, void *);
void awacs_attach(struct device *, struct device *, void *);
int awacs_intr(void *);
int awacs_tx_intr(void *);
int awacs_rx_intr(void *);

int awacs_open(void *, int);
void awacs_close(void *);
int awacs_set_params(void *, int, int, struct audio_params *,
			 struct audio_params *);
int awacs_round_blocksize(void *, int);
int awacs_trigger_output(void *, void *, void *, int, void (*)(void *),
			     void *, struct audio_params *);
int awacs_trigger_input(void *, void *, void *, int, void (*)(void *),
			    void *, struct audio_params *);
int awacs_halt_output(void *);
int awacs_halt_input(void *);
int awacs_set_port(void *, mixer_ctrl_t *);
int awacs_get_port(void *, mixer_ctrl_t *);
int awacs_query_devinfo(void *, mixer_devinfo_t *);
size_t awacs_round_buffersize(void *, int, size_t);
int awacs_get_props(void *);
void *awacs_allocm(void *, int, size_t, int, int);

static inline u_int awacs_read_reg(struct awacs_softc *, int);
static inline void awacs_write_reg(struct awacs_softc *, int, int);
void awacs_write_codec(struct awacs_softc *, int);
void awacs_set_speaker_volume(struct awacs_softc *, int, int);
void awacs_set_ext_volume(struct awacs_softc *, int, int);
void awacs_set_rate(struct awacs_softc *, struct audio_params *);

struct cfattach awacs_ca = {
	sizeof(struct awacs_softc), awacs_match, awacs_attach
};

struct cfdriver awacs_cd = {
	NULL, "awacs", DV_DULL
};

struct audio_hw_if awacs_hw_if = {
	awacs_open,
	awacs_close,
	awacs_set_params,
	awacs_round_blocksize,
	NULL,			/* commit_setting */
	NULL,			/* init_output */
	NULL,			/* init_input */
	NULL,			/* start_output */
	NULL,			/* start_input */
	awacs_halt_output,
	awacs_halt_input,
	NULL,			/* speaker_ctl */
	NULL,			/* getfd */
	awacs_set_port,
	awacs_get_port,
	awacs_query_devinfo,
	awacs_allocm,		/* allocm */
	NULL,			/* freem */
	awacs_round_buffersize,	/* round_buffersize */
	awacs_get_props,
	awacs_trigger_output,
	awacs_trigger_input
};

/* register offset */
#define AWACS_SOUND_CTRL	0x00
#define AWACS_CODEC_CTRL	0x10
#define AWACS_CODEC_STATUS	0x20
#define AWACS_CLIP_COUNT	0x30
#define AWACS_BYTE_SWAP		0x40

/* sound control */
#define AWACS_INPUT_SUBFRAME0	0x00000001
#define AWACS_INPUT_SUBFRAME1	0x00000002
#define AWACS_INPUT_SUBFRAME2	0x00000004
#define AWACS_INPUT_SUBFRAME3	0x00000008

#define AWACS_OUTPUT_SUBFRAME0	0x00000010
#define AWACS_OUTPUT_SUBFRAME1	0x00000020
#define AWACS_OUTPUT_SUBFRAME2	0x00000040
#define AWACS_OUTPUT_SUBFRAME3	0x00000080

#define AWACS_RATE_44100	0x00000000
#define AWACS_RATE_29400	0x00000100
#define AWACS_RATE_22050	0x00000200
#define AWACS_RATE_17640	0x00000300
#define AWACS_RATE_14700	0x00000400
#define AWACS_RATE_11025	0x00000500
#define AWACS_RATE_8820		0x00000600
#define AWACS_RATE_7350		0x00000700
#define AWACS_RATE_MASK		0x00000700

#define AWACS_CTL_CNTRLERR 	(1 << 11)
#define AWACS_CTL_PORTCHG 	(1 << 12)
#define AWACS_INT_CNTRLERR 	(1 << 13)
#define AWACS_INT_PORTCHG 	(1 << 14)

/* codec control */
#define AWACS_CODEC_ADDR0	0x00000000
#define AWACS_CODEC_ADDR1	0x00001000
#define AWACS_CODEC_ADDR2	0x00002000
#define AWACS_CODEC_ADDR4	0x00004000
#define AWACS_CODEC_EMSEL0	0x00000000
#define AWACS_CODEC_EMSEL1	0x00400000
#define AWACS_CODEC_EMSEL2	0x00800000
#define AWACS_CODEC_EMSEL4	0x00c00000
#define AWACS_CODEC_BUSY	0x01000000

/* cc0 */
#define AWACS_DEFAULT_CD_GAIN	0x000000bb
#define AWACS_INPUT_CD		0x00000200
#define AWACS_INPUT_LINE	0x00000400
#define AWACS_INPUT_MICROPHONE	0x00000800
#define AWACS_INPUT_MASK	0x00000e00

/* cc1 */
#define AWACS_MUTE_SPEAKER	0x00000080
#define AWACS_MUTE_HEADPHONE	0x00000200

const struct awacs_speed_tab {
	int rate;
	u_int32_t bits;
} awacs_speeds[] = {
	{  7350, AWACS_RATE_7350 },
	{  8820, AWACS_RATE_8820 },
	{ 11025, AWACS_RATE_11025 },
	{ 14700, AWACS_RATE_14700 },
	{ 17640, AWACS_RATE_17640 },
	{ 22050, AWACS_RATE_22050 },
	{ 29400, AWACS_RATE_29400 },
	{ 44100, AWACS_RATE_44100 },
};

int
awacs_match(struct device *parent, void *match, void *aux)
{
	struct confargs *ca = aux;

	if (strcmp(ca->ca_name, "awacs") != 0 &&
	    strcmp(ca->ca_name, "davbus") != 0)
		return 0;

#ifdef DEBUG
	printf("awacs: matched %s nreg %d nintr %d\n",
		ca->ca_name, ca->ca_nreg, ca->ca_nintr);
#endif

	if (ca->ca_nreg < 24 || ca->ca_nintr < 12)
		return 0;

	/* XXX for now
	if (ca->ca_nintr > 12)
		return 0;
	*/

	return 1;
}

void
awacs_attach(struct device *parent, struct device *self, void *aux)
{
	struct awacs_softc *sc = (struct awacs_softc *)self;
	struct confargs *ca = aux;
	int cirq, oirq, iirq;
	int cirq_type, oirq_type, iirq_type;

	ca->ca_reg[0] += ca->ca_baseaddr;
	ca->ca_reg[2] += ca->ca_baseaddr;
	ca->ca_reg[4] += ca->ca_baseaddr;

	sc->sc_reg = mapiodev(ca->ca_reg[0], ca->ca_reg[1]);

	sc->sc_dmat = ca->ca_dmat;
	sc->sc_odma = mapiodev(ca->ca_reg[2], ca->ca_reg[3]); /* out */
	sc->sc_idma = mapiodev(ca->ca_reg[4], ca->ca_reg[5]); /* in */
	sc->sc_odbdma = dbdma_alloc(sc->sc_dmat, AWACS_DMALIST_MAX);
	sc->sc_odmacmd = sc->sc_odbdma->d_addr;
	sc->sc_idbdma = dbdma_alloc(sc->sc_dmat, AWACS_DMALIST_MAX);
	sc->sc_idmacmd = sc->sc_idbdma->d_addr;

	if (ca->ca_nintr == 24) {
		cirq = ca->ca_intr[0];
		oirq = ca->ca_intr[2];
		iirq = ca->ca_intr[4];
		cirq_type = ca->ca_intr[1] ? IST_LEVEL : IST_EDGE;
		oirq_type = ca->ca_intr[3] ? IST_LEVEL : IST_EDGE;
		iirq_type = ca->ca_intr[5] ? IST_LEVEL : IST_EDGE;
	} else {
		cirq = ca->ca_intr[0];
		oirq = ca->ca_intr[1];
		iirq = ca->ca_intr[2];
		cirq_type = oirq_type = iirq_type = IST_LEVEL;
	}
	mac_intr_establish(parent, cirq, cirq_type, IPL_AUDIO | IPL_MPSAFE,
	    awacs_intr, sc, sc->sc_dev.dv_xname);
	mac_intr_establish(parent, oirq, oirq_type, IPL_AUDIO | IPL_MPSAFE,
	    awacs_tx_intr, sc, sc->sc_dev.dv_xname);
	mac_intr_establish(parent, iirq, iirq_type, IPL_AUDIO | IPL_MPSAFE,
	    awacs_rx_intr, sc, sc->sc_dev.dv_xname);

	printf(": irq %d,%d,%d",
		cirq, oirq, iirq);

	sc->sc_soundctl = AWACS_INPUT_SUBFRAME0 | AWACS_OUTPUT_SUBFRAME0 |
	    AWACS_RATE_44100 | AWACS_INT_PORTCHG;
	awacs_write_reg(sc, AWACS_SOUND_CTRL, sc->sc_soundctl);

	sc->sc_codecctl0 = AWACS_CODEC_ADDR0 | AWACS_CODEC_EMSEL0;
	sc->sc_codecctl1 = AWACS_CODEC_ADDR1 | AWACS_CODEC_EMSEL0;
	sc->sc_codecctl2 = AWACS_CODEC_ADDR2 | AWACS_CODEC_EMSEL0;
	sc->sc_codecctl4 = AWACS_CODEC_ADDR4 | AWACS_CODEC_EMSEL0;

	sc->sc_codecctl0 |= AWACS_INPUT_CD | AWACS_DEFAULT_CD_GAIN;
	awacs_write_codec(sc, sc->sc_codecctl0);

	/* Set initial volume[s] */
	awacs_set_speaker_volume(sc, 80, 80);
	awacs_set_ext_volume(sc, 80, 80);

	/* Set loopback (for CD?) */
	/* sc->sc_codecctl1 |= 0x440; */
	sc->sc_codecctl1 |= 0x40;
	awacs_write_codec(sc, sc->sc_codecctl1);

	/* check for headphone present */
	if (awacs_read_reg(sc, AWACS_CODEC_STATUS) & 0x8) {
		/* default output to speakers */
		printf(" headphones");
		sc->sc_output_mask = 1 << 1;
		sc->sc_codecctl1 &= ~AWACS_MUTE_HEADPHONE;
		sc->sc_codecctl1 |= AWACS_MUTE_SPEAKER;
		awacs_write_codec(sc, sc->sc_codecctl1);
	} else {
		/* default output to speakers */
		printf(" speaker");
		sc->sc_output_mask = 1 << 0;
		sc->sc_codecctl1 &= ~AWACS_MUTE_SPEAKER;
		sc->sc_codecctl1 |= AWACS_MUTE_HEADPHONE;
		awacs_write_codec(sc, sc->sc_codecctl1);
	}

	/* default input from CD */
	sc->sc_record_source = 1 << 0;
	sc->sc_codecctl0 &= ~AWACS_INPUT_MASK;
	sc->sc_codecctl0 |= AWACS_INPUT_CD;
	awacs_write_codec(sc, sc->sc_codecctl0);

	/* Enable interrupts and looping mode. */
	/* XXX ... */
	awacs_halt_output(sc);
	awacs_halt_input(sc);
	printf("\n");

	audio_attach_mi(&awacs_hw_if, sc, &sc->sc_dev);
}

u_int
awacs_read_reg(struct awacs_softc *sc, int reg)
{
	char *addr = sc->sc_reg;

	return in32rb(addr + reg);
}

void
awacs_write_reg(struct awacs_softc *sc, int reg, int val)
{
	char *addr = sc->sc_reg;

	out32rb(addr + reg, val);
}

void
awacs_write_codec(struct awacs_softc *sc, int value)
{
	awacs_write_reg(sc, AWACS_CODEC_CTRL, value);
	while (awacs_read_reg(sc, AWACS_CODEC_CTRL) & AWACS_CODEC_BUSY);
}

int
awacs_intr(void *v)
{
	int reason;
	struct awacs_softc *sc = v;

	mtx_enter(&audio_lock);
	reason = awacs_read_reg(sc, AWACS_SOUND_CTRL);
	if (reason & AWACS_CTL_CNTRLERR) {
		/* change outputs ?? */
	}
	if (reason & AWACS_CTL_PORTCHG) {
#ifdef DEBUG
		printf("status = %x\n", awacs_read_reg(sc, AWACS_CODEC_STATUS));
#endif

		if (awacs_read_reg(sc, AWACS_CODEC_STATUS) & 0x8) {
			/* default output to speakers */
			sc->sc_output_mask = 1 << 1;
			sc->sc_codecctl1 &= ~AWACS_MUTE_HEADPHONE;
			sc->sc_codecctl1 |= AWACS_MUTE_SPEAKER;
			awacs_write_codec(sc, sc->sc_codecctl1);
		} else {
			/* default output to speakers */
			sc->sc_output_mask = 1 << 0;
			sc->sc_codecctl1 &= ~AWACS_MUTE_SPEAKER;
			sc->sc_codecctl1 |= AWACS_MUTE_HEADPHONE;
			awacs_write_codec(sc, sc->sc_codecctl1);
		}
	}

	awacs_write_reg(sc, AWACS_SOUND_CTRL, reason); /* clear interrupt */
	mtx_leave(&audio_lock);
	return 1;
}

int
awacs_tx_intr(void *v)
{
	struct awacs_softc *sc = v;
	struct dbdma_command *cmd = sc->sc_odmap;
	u_int16_t c, status;

	/* if not set we are not running */
	if (!cmd)
		return (0);	
	mtx_enter(&audio_lock);
	c = in16rb(&cmd->d_command);
	status = in16rb(&cmd->d_status);

	if (c >> 12 == DBDMA_CMD_OUT_LAST)
		sc->sc_odmap = sc->sc_odmacmd;
	else
		sc->sc_odmap++;

	if (c & (DBDMA_INT_ALWAYS << 4)) {
		cmd->d_status = 0;
		if (status)	/* status == 0x8400 */
			if (sc->sc_ointr)
				(*sc->sc_ointr)(sc->sc_oarg);
	}
	mtx_leave(&audio_lock);
	return (1);
}
int
awacs_rx_intr(void *v)
{
	struct awacs_softc *sc = v;
	struct dbdma_command *cmd = sc->sc_idmap;
	u_int16_t c, status;

	/* if not set we are not running */
	if (!cmd)
		return (0);

	mtx_enter(&audio_lock);
	c = in16rb(&cmd->d_command);
	status = in16rb(&cmd->d_status);

	if (c >> 12 == DBDMA_CMD_IN_LAST)
		sc->sc_idmap = sc->sc_idmacmd;
	else
		sc->sc_idmap++;

	if (c & (DBDMA_INT_ALWAYS << 4)) {
		cmd->d_status = 0;
		if (status)	/* status == 0x8400 */
			if (sc->sc_iintr)
				(*sc->sc_iintr)(sc->sc_iarg);
	}
	mtx_leave(&audio_lock);
	return (1);
}

int
awacs_open(void *h, int flags)
{
	return 0;
}

/*
 * Close function is called at splaudio().
 */
void
awacs_close(void *h)
{
	struct awacs_softc *sc = h;

	/* XXX: halt_xxx() already called by upper layer */
	awacs_halt_output(sc);
	awacs_halt_input(sc);

	sc->sc_ointr = 0;
	sc->sc_iintr = 0;
}

int
awacs_set_params(void *h, int setmode, int usemode, struct audio_params *play,
    struct audio_params *rec)
{
	struct awacs_softc *sc = h;
	struct audio_params *p;
	int mode;

	/*
	 * This device only has one clock, so make the sample rates match.
	 */
	if (play->sample_rate != rec->sample_rate &&
	    usemode == (AUMODE_PLAY | AUMODE_RECORD)) {
		if (setmode == AUMODE_PLAY) {
			rec->sample_rate = play->sample_rate;
			setmode |= AUMODE_RECORD;
		} else if (setmode == AUMODE_RECORD) {
			play->sample_rate = rec->sample_rate;
			setmode |= AUMODE_PLAY;
		} else
			return EINVAL;
	}

	for (mode = AUMODE_RECORD; mode != -1;
	     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
		if ((setmode & mode) == 0)
			continue;

		p = mode == AUMODE_PLAY ? play : rec;

		if (p->sample_rate < 4000)
			p->sample_rate = 4000;
		if (p->sample_rate > 50000)
			p->sample_rate = 50000;
		
		awacs_write_reg(sc, AWACS_BYTE_SWAP, 0);

		p->encoding = AUDIO_ENCODING_SLINEAR_BE;
		p->precision = 16;
		p->channels = 2;
		p->bps = AUDIO_BPS(p->precision);
		p->msb = 1;
	}

	/* Set the speed */
	awacs_set_rate(sc, p);

	return (0);
}

int
awacs_round_blocksize(void *h, int size)
{
	if (size < PAGE_SIZE)
		size = PAGE_SIZE;
	return (size + PAGE_SIZE / 2) & ~(PGOFSET);
}

int
awacs_halt_output(void *h)
{
	struct awacs_softc *sc = h;

	mtx_enter(&audio_lock);
	dbdma_stop(sc->sc_odma);
	dbdma_reset(sc->sc_odma);
	dbdma_stop(sc->sc_odma);
	sc->sc_odmap = NULL;
	mtx_leave(&audio_lock);
	return 0;
}

int
awacs_halt_input(void *h)
{
	struct awacs_softc *sc = h;

	mtx_enter(&audio_lock);
	dbdma_stop(sc->sc_idma);
	dbdma_reset(sc->sc_idma);
	mtx_leave(&audio_lock);
	return 0;
}

enum {
	AWACS_OUTPUT_SELECT,
	AWACS_VOL_SPEAKER,
	AWACS_VOL_HEADPHONE,
	AWACS_OUTPUT_CLASS,
	AWACS_MONITOR_CLASS,
	AWACS_INPUT_SELECT,
	AWACS_VOL_INPUT,
	AWACS_INPUT_CLASS,
	AWACS_RECORD_CLASS,
	AWACS_ENUM_LAST
};

int
awacs_set_port(void *h, mixer_ctrl_t *mc)
{
	struct awacs_softc *sc = h;
	int l, r;

	DPRINTF("awacs_set_port dev = %d, type = %d\n", mc->dev, mc->type);

	l = mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
	r = mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];

	switch (mc->dev) {
	case AWACS_OUTPUT_SELECT:
		/* no change necessary? */
		if (mc->un.mask == sc->sc_output_mask)
			return 0;
		sc->sc_codecctl1 |= AWACS_MUTE_SPEAKER | AWACS_MUTE_HEADPHONE;
		if (mc->un.mask & 1 << 0)
			sc->sc_codecctl1 &= ~AWACS_MUTE_SPEAKER;
		if (mc->un.mask & 1 << 1)
			sc->sc_codecctl1 &= ~AWACS_MUTE_HEADPHONE;

		awacs_write_codec(sc, sc->sc_codecctl1);
		sc->sc_output_mask = mc->un.mask;
		return 0;

	case AWACS_VOL_SPEAKER:
		awacs_set_speaker_volume(sc, l, r);
		return 0;

	case AWACS_VOL_HEADPHONE:
		awacs_set_ext_volume(sc, l, r);
		return 0;

	case AWACS_VOL_INPUT:
		sc->sc_codecctl0 &= ~0xff;
		sc->sc_codecctl0 |= (l & 0xf0) | (r >> 4);
		awacs_write_codec(sc, sc->sc_codecctl0);
		return 0;

	case AWACS_INPUT_SELECT:
		/* no change necessary? */
		if (mc->un.mask == sc->sc_record_source)
			return 0;
		switch(mc->un.mask) {
		case 1<<0: /* CD */
			sc->sc_codecctl0 &= ~AWACS_INPUT_MASK;
			sc->sc_codecctl0 |= AWACS_INPUT_CD;
			awacs_write_codec(sc, sc->sc_codecctl0);
			break;
		case 1<<1: /* microphone */
			sc->sc_codecctl0 &= ~AWACS_INPUT_MASK;
			sc->sc_codecctl0 |= AWACS_INPUT_MICROPHONE;
			awacs_write_codec(sc, sc->sc_codecctl0);
			break;
		case 1<<2: /* line in */
			sc->sc_codecctl0 &= ~AWACS_INPUT_MASK;
			sc->sc_codecctl0 |= AWACS_INPUT_LINE;
			awacs_write_codec(sc, sc->sc_codecctl0);
			break;
		default: /* invalid argument */
			return -1;
		}
		sc->sc_record_source = mc->un.mask;
		return 0;
	}

	return ENXIO;
}

int
awacs_get_port(void *h, mixer_ctrl_t *mc)
{
	struct awacs_softc *sc = h;
	int vol, l, r;

	DPRINTF("awacs_get_port dev = %d, type = %d\n", mc->dev, mc->type);

	switch (mc->dev) {
	case AWACS_OUTPUT_SELECT:
		mc->un.mask = sc->sc_output_mask;
		return 0;

	case AWACS_VOL_SPEAKER:
		vol = sc->sc_codecctl4;
		l = (15 - ((vol & 0x3c0) >> 6)) * 16;
		r = (15 - (vol & 0x0f)) * 16;
		mc->un.mask = 1 << 0;
		mc->un.value.num_channels = 2;
		mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = l;
		mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = r;
		return 0;

	case AWACS_VOL_HEADPHONE:
		vol = sc->sc_codecctl2;
		l = (15 - ((vol & 0x3c0) >> 6)) * 16;
		r = (15 - (vol & 0x0f)) * 16;
		mc->un.mask = 1 << 1;
		mc->un.value.num_channels = 2;
		mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = l;
		mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = r;
		return 0;

	case AWACS_INPUT_SELECT:
		mc->un.mask = sc->sc_record_source;
		return 0;

	case AWACS_VOL_INPUT:
		vol = sc->sc_codecctl0 & 0xff;
		l = (vol & 0xf0);
		r = (vol & 0x0f) << 4;
		mc->un.mask = sc->sc_record_source;
		mc->un.value.num_channels = 2;
		mc->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = l;
		mc->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = r;
		return 0;

	default:
		return ENXIO;
	}

	return 0;
}

int
awacs_query_devinfo(void *h, mixer_devinfo_t *dip)
{
	DPRINTF("query_devinfo %d\n", dip->index);

	switch (dip->index) {

	case AWACS_OUTPUT_SELECT:
		dip->mixer_class = AWACS_OUTPUT_CLASS;
		strlcpy(dip->label.name, AudioNselect, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_SET;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		dip->un.s.num_mem = 2;
		strlcpy(dip->un.s.member[0].label.name, AudioNspeaker,
		    sizeof dip->un.s.member[0].label.name);
		dip->un.s.member[0].mask = 1 << 0;
		strlcpy(dip->un.s.member[1].label.name, AudioNheadphone,
		    sizeof dip->un.s.member[0].label.name);
		dip->un.s.member[1].mask = 1 << 1;
		return 0;

	case AWACS_VOL_SPEAKER:
		dip->mixer_class = AWACS_OUTPUT_CLASS;
		strlcpy(dip->label.name, AudioNspeaker,
		    sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return 0;

	case AWACS_VOL_HEADPHONE:
		dip->mixer_class = AWACS_OUTPUT_CLASS;
		strlcpy(dip->label.name, AudioNheadphone,
		    sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return 0;

	case AWACS_INPUT_SELECT:
		dip->mixer_class = AWACS_RECORD_CLASS;
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_SET;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		dip->un.s.num_mem = 3;
		strlcpy(dip->un.s.member[0].label.name, AudioNcd,
		    sizeof dip->un.s.member[0].label.name);
		dip->un.s.member[0].mask = 1 << 0;
		strlcpy(dip->un.s.member[1].label.name, AudioNmicrophone,
		    sizeof dip->un.s.member[1].label.name);
		dip->un.s.member[1].mask = 1 << 1;
		strlcpy(dip->un.s.member[2].label.name, AudioNline,
		    sizeof dip->un.s.member[2].label.name);
		dip->un.s.member[2].mask = 1 << 2;
		return 0;

	case AWACS_VOL_INPUT:
		dip->mixer_class = AWACS_RECORD_CLASS;
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return 0;

	case AWACS_MONITOR_CLASS:
		dip->mixer_class = AWACS_MONITOR_CLASS;
		strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		return 0;

	case AWACS_OUTPUT_CLASS:
		dip->mixer_class = AWACS_OUTPUT_CLASS;
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		return 0;

	case AWACS_RECORD_CLASS:
		dip->mixer_class = AWACS_MONITOR_CLASS;
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		return 0;
	}

	return ENXIO;
}

size_t
awacs_round_buffersize(void *h, int dir, size_t size)
{
	size = (size + PGOFSET) & ~(PGOFSET);
	if (size > AWACS_DMALIST_MAX * AWACS_DMASEG_MAX)
		size = AWACS_DMALIST_MAX * AWACS_DMASEG_MAX;
	return (size);
}

void *
awacs_allocm(void *h, int dir, size_t size, int type, int flags)
{
	struct awacs_softc *sc = h;
	struct awacs_dma *p;
	int error;

	if (size > AWACS_DMALIST_MAX * AWACS_DMASEG_MAX)
		return (NULL);

	p = malloc(sizeof(*p), type, flags | M_ZERO);
	if (!p)
		return (NULL);

	/* convert to the bus.h style, not used otherwise */
	if (flags & M_NOWAIT)
		flags = BUS_DMA_NOWAIT;

	p->size = size;
	if ((error = bus_dmamem_alloc(sc->sc_dmat, p->size, NBPG, 0, p->segs,
	    1, &p->nsegs, flags)) != 0) {
		printf("%s: unable to allocate dma, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		free(p, type, sizeof *p);
		return NULL;
	}

	if ((error = bus_dmamem_map(sc->sc_dmat, p->segs, p->nsegs, p->size,
	    &p->addr, flags | BUS_DMA_COHERENT)) != 0) {
		printf("%s: unable to map dma, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		bus_dmamem_free(sc->sc_dmat, p->segs, p->nsegs);
		free(p, type, sizeof *p);
		return NULL;
	}

	if ((error = bus_dmamap_create(sc->sc_dmat, p->size, 1,
	    p->size, 0, flags, &p->map)) != 0) {
		printf("%s: unable to create dma map, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		bus_dmamem_unmap(sc->sc_dmat, p->addr, size);
		bus_dmamem_free(sc->sc_dmat, p->segs, p->nsegs);
		free(p, type, sizeof *p);
		return NULL;
	}

	if ((error = bus_dmamap_load(sc->sc_dmat, p->map, p->addr, p->size,
	    NULL, flags)) != 0) {
		printf("%s: unable to load dma map, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		bus_dmamap_destroy(sc->sc_dmat, p->map);
		bus_dmamem_unmap(sc->sc_dmat, p->addr, size);
		bus_dmamem_free(sc->sc_dmat, p->segs, p->nsegs);
		free(p, type, sizeof *p);
		return NULL;
	}

	p->next = sc->sc_dmas;
	sc->sc_dmas = p;

	return p->addr;
}

int
awacs_get_props(void *h)
{
	return AUDIO_PROP_FULLDUPLEX /* | AUDIO_PROP_MMAP */;
}

int
awacs_trigger_output(void *h, void *start, void *end, int bsize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct awacs_softc *sc = h;
	struct awacs_dma *p;
	struct dbdma_command *cmd = sc->sc_odmacmd;
	vaddr_t spa, pa, epa;
	int c;

	DPRINTF("trigger_output %p %p 0x%x\n", start, end, bsize);

	for (p = sc->sc_dmas; p && p->addr != start; p = p->next);
	if (!p)
		return -1;

	sc->sc_ointr = intr;
	sc->sc_oarg = arg;
	sc->sc_odmap = sc->sc_odmacmd;

	mtx_enter(&audio_lock);
	spa = p->segs[0].ds_addr;
	c = DBDMA_CMD_OUT_MORE;
	for (pa = spa, epa = spa + (end - start);
	    pa < epa; pa += bsize, cmd++) {

		if (pa + bsize == epa)
			c = DBDMA_CMD_OUT_LAST;

		DBDMA_BUILD(cmd, c, 0, bsize, pa, DBDMA_INT_ALWAYS,
			DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
	}

	DBDMA_BUILD(cmd, DBDMA_CMD_NOP, 0, 0, 0,
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_ALWAYS);
	dbdma_st32(&cmd->d_cmddep, sc->sc_odbdma->d_paddr);

	dbdma_start(sc->sc_odma, sc->sc_odbdma);

	mtx_leave(&audio_lock);
	return 0;
}

int
awacs_trigger_input(void *h, void *start, void *end, int bsize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct awacs_softc *sc = h;
	struct awacs_dma *p;
	struct dbdma_command *cmd = sc->sc_idmacmd;
	vaddr_t spa, pa, epa;
	int c;

	DPRINTF("trigger_input %p %p 0x%x\n", start, end, bsize);

	for (p = sc->sc_dmas; p && p->addr != start; p = p->next);
	if (!p)
		return -1;

	sc->sc_iintr = intr;
	sc->sc_iarg = arg;
	sc->sc_idmap = sc->sc_idmacmd;

	mtx_enter(&audio_lock);
	spa = p->segs[0].ds_addr;
	c = DBDMA_CMD_IN_MORE;
	for (pa = spa, epa = spa + (end - start);
	    pa < epa; pa += bsize, cmd++) {

		if (pa + bsize == epa)
			c = DBDMA_CMD_IN_LAST;

		DBDMA_BUILD(cmd, c, 0, bsize, pa, DBDMA_INT_ALWAYS,
			DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
	}

	DBDMA_BUILD(cmd, DBDMA_CMD_NOP, 0, 0, 0,
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_ALWAYS);
	dbdma_st32(&cmd->d_cmddep, sc->sc_idbdma->d_paddr);

	dbdma_start(sc->sc_idma, sc->sc_idbdma);

	mtx_leave(&audio_lock);
	return 0;
}

void
awacs_set_speaker_volume(struct awacs_softc *sc, int left, int  right)
{
	int lval = 15 - (left  & 0xff) / 16;
	int rval = 15 - (right & 0xff) / 16;

	DPRINTF("speaker_volume %d %d\n", lval, rval);

	sc->sc_codecctl4 &= ~0x3cf;
	sc->sc_codecctl4 |= (lval << 6) | rval;
	awacs_write_codec(sc, sc->sc_codecctl4);
}

void
awacs_set_ext_volume(struct awacs_softc *sc, int left, int  right)
{
	int lval = 15 - (left  & 0xff) / 16;
	int rval = 15 - (right & 0xff) / 16;

	DPRINTF("ext_volume %d %d\n", lval, rval);

	sc->sc_codecctl2 &= ~0x3cf;
	sc->sc_codecctl2 |= (lval << 6) | rval;
	awacs_write_codec(sc, sc->sc_codecctl2);
}

void
awacs_set_rate(struct awacs_softc *sc, struct audio_params *p)
{
	int selected = -1;
	size_t n, i;

	n = sizeof(awacs_speeds)/sizeof(awacs_speeds[0]);

	if (p->sample_rate < awacs_speeds[0].rate)
		selected = 0;
	if (p->sample_rate > awacs_speeds[n - 1].rate)
		selected = n - 1;

	for (i = 1; selected == -1 && i < n; i++) {
		if (p->sample_rate == awacs_speeds[i].rate)
			selected = i;
		else if (p->sample_rate < awacs_speeds[i].rate) {
			u_int diff1, diff2;

			diff1 = p->sample_rate - awacs_speeds[i - 1].rate;
			diff2 = awacs_speeds[i].rate - p->sample_rate;
			selected = (diff1 < diff2) ? i - 1 : i;
		}
	}

	if (selected == -1)
		selected = 0;

	sc->sc_soundctl &= ~AWACS_RATE_MASK;
	sc->sc_soundctl |= awacs_speeds[selected].bits;
	p->sample_rate = awacs_speeds[selected].rate;
	awacs_write_reg(sc, AWACS_SOUND_CTRL, sc->sc_soundctl);
}
@


1.33
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.31 2015/05/11 06:46:21 ratchov Exp $	*/
a106 1
int awacs_getdev(void *, struct audio_device *);
a141 1
	awacs_getdev,
a153 6
struct audio_device awacs_device = {
	"AWACS",
	"",
	"awacs"
};

a565 7
	return 0;
}

int
awacs_getdev(void *h, struct audio_device *retp)
{
	*retp = awacs_device;
@


1.32
log
@sizes for free(); ok semarie
@
text
@a97 1
int awacs_query_encoding(void *, struct audio_encoding *);
a111 1
paddr_t awacs_mappage(void *, void *, off_t, int);
a132 2
	NULL,			/* drain */
	awacs_query_encoding,
a150 1
	awacs_mappage,
d153 1
a153 2
	awacs_trigger_input,
	NULL
a493 19
awacs_query_encoding(void *h, struct audio_encoding *ae)
{
	switch (ae->index) {
	case 0:
		strlcpy(ae->name, AudioEslinear_be, sizeof ae->name);
		ae->encoding = AUDIO_ENCODING_SLINEAR_BE;
		ae->precision = 16;
		ae->flags = 0;
		break;
	default:
		return (EINVAL);
	}
	ae->bps = AUDIO_BPS(ae->precision);
	ae->msb = 1;

	return (0);
}

int
a885 8
}

paddr_t
awacs_mappage(void *h, void *mem, off_t off, int prot)
{
	if (off < 0)
		return -1;
	return -1;	/* XXX */
@


1.31
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.30 2015/04/07 09:54:11 mpi Exp $	*/
d873 1
a873 1
		free(p, type, 0);
d882 1
a882 1
		free(p, type, 0);
d892 1
a892 1
		free(p, type, 0);
d903 1
a903 1
		free(p, type, 0);
@


1.30
log
@Mark audio interrupt handlers as MPSAFE, they already grab the right
mutex when necessary.

ok kettenis@@, ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.29 2014/07/12 18:44:42 tedu Exp $	*/
a35 1
#include <dev/auconv.h>
a36 1
#include <dev/mulaw.h>
a503 6
		strlcpy(ae->name, AudioEslinear, sizeof ae->name);
		ae->encoding = AUDIO_ENCODING_SLINEAR;
		ae->precision = 16;
		ae->flags = 0;
		break;
	case 1:
a508 36
	case 2:
		strlcpy(ae->name, AudioEslinear_le, sizeof ae->name);
		ae->encoding = AUDIO_ENCODING_SLINEAR_LE;
		ae->precision = 16;
		ae->flags = 0;
		break;
	case 3:
		strlcpy(ae->name, AudioEmulaw, sizeof ae->name);
		ae->encoding = AUDIO_ENCODING_ULAW;
		ae->precision = 8;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 4:
		strlcpy(ae->name, AudioEalaw, sizeof ae->name);
		ae->encoding = AUDIO_ENCODING_ALAW;
		ae->precision = 8;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 5:
		strlcpy(ae->name, AudioEulinear, sizeof ae->name);
		ae->encoding = AUDIO_ENCODING_ULINEAR;
		ae->precision = 16;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
		strlcpy(ae->name, AudioEulinear_le, sizeof ae->name);
		ae->encoding = AUDIO_ENCODING_ULINEAR_LE;
		ae->precision = 16;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(ae->name, AudioEulinear_be, sizeof ae->name);
		ae->encoding = AUDIO_ENCODING_ULINEAR_BE;
		ae->precision = 16;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
a551 4
		if (p->precision > 16)
			p->precision = 16;
		if (p->channels > 2)
			p->channels = 2;
a552 2
		p->factor = 1;
		p->sw_code = NULL;
d555 3
a557 58
		switch (p->encoding) {

		case AUDIO_ENCODING_SLINEAR_LE:
			if (p->precision != 16)
				p->precision = 16;
			if (p->channels == 2)
				p->sw_code = swap_bytes;
			else {
				p->factor = 2;
				p->sw_code = swap_bytes_mts;
			}
			break;
		case AUDIO_ENCODING_SLINEAR_BE:
			if (p->precision != 16)
				p->precision = 16;
			if (p->channels == 1) {
				p->factor = 2;
				p->sw_code = noswap_bytes_mts;
			}
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			if (p->precision != 16)
				p->precision = 16;
			if (p->channels == 2)
				p->sw_code = swap_bytes_change_sign16_be;
			else {
				p->factor = 2;
				p->sw_code = swap_bytes_change_sign16_be_mts;
			}
			break;
		case AUDIO_ENCODING_ULINEAR_BE:
			if (p->precision != 16)
				p->precision = 16;
			if (p->channels == 2)
				p->sw_code = change_sign16_be;
			else {
				p->factor = 2;
				p->sw_code = change_sign16_be_mts;
			}
			break;
		case AUDIO_ENCODING_ULAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = mulaw_to_slinear16_be;
				break;
			} else
				break;	/* XXX */
			return (EINVAL);
		case AUDIO_ENCODING_ALAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = alaw_to_slinear16_be;
				break;
			}
			return (EINVAL);
		default:
			return (EINVAL);
		}
@


1.29
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.28 2013/05/15 08:29:23 ratchov Exp $	*/
d299 6
a304 6
	mac_intr_establish(parent, cirq, cirq_type, IPL_AUDIO, awacs_intr,
	    sc, sc->sc_dev.dv_xname);
	mac_intr_establish(parent, oirq, oirq_type, IPL_AUDIO, awacs_tx_intr,
	    sc, sc->sc_dev.dv_xname);
	mac_intr_establish(parent, iirq, iirq_type, IPL_AUDIO, awacs_rx_intr,
	    sc, sc->sc_dev.dv_xname);
@


1.28
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.27 2011/09/04 18:48:10 miod Exp $	*/
d978 1
a978 1
		free(p, type);
d987 1
a987 1
		free(p, type);
d997 1
a997 1
		free(p, type);
d1008 1
a1008 1
		free(p, type);
@


1.27
log
@oops, this DPRINTF flavour takes no parentheses.
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.26 2011/09/04 18:46:41 miod Exp $	*/
d390 2
a392 1

d417 1
d430 2
a431 2
		return (0);

d446 1
a446 1

d460 1
d475 1
a475 1

d493 1
d686 1
d691 1
d700 1
d703 1
d1052 1
d1071 1
d1095 1
d1114 1
@


1.26
log
@Silence awacs_trigger_input by turning a noisy printf into the DPRINTF
it was intended to be; reported by Donovan Watteau
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.25 2010/07/15 03:43:11 jakemsr Exp $	*/
d1075 1
a1075 1
	DPRINTF(("trigger_input %p %p 0x%x\n", start, end, bsize));
@


1.25
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.24 2008/10/30 06:22:38 todd Exp $	*/
d1075 1
a1075 1
	printf("trigger_input %p %p 0x%x\n", start, end, bsize);
@


1.24
log
@ugh, typo fix, committed previous from the wrong tree
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.23 2008/10/30 06:12:47 todd Exp $	*/
d552 3
d659 2
@


1.23
log
@patches for macppc to remove more EINVAL returns in the audio code
tested by me, from ratchov@@, please commit ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.22 2008/04/21 00:32:42 jakemsr Exp $	*/
d601 1
a601 1
			if (p->percision != 16)
@


1.22
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.21 2007/11/05 00:17:28 jakemsr Exp $	*/
d585 9
a593 5
		if (p->sample_rate < 4000 || p->sample_rate > 50000 ||
		    (p->precision != 8 && p->precision != 16) ||
		    (p->channels != 1 && p->channels != 2))
			return EINVAL;

d601 3
a603 1
			if (p->channels == 2 && p->precision == 16) {
d605 1
a605 3
				break;
			}
			if (p->channels == 1 && p->precision == 16) {
a607 1
				break;
d609 1
a609 1
			return (EINVAL);
d611 3
a613 3
			if (p->channels == 2 && p->precision == 16)
				break;
			if (p->channels == 1 && p->precision == 16) {
a615 1
				break;
d617 1
a617 1
			return (EINVAL);
d619 3
a621 1
			if (p->channels == 2 && p->precision == 16) {
d623 1
a623 3
				break;
			}
			if (p->channels == 1 && p->precision == 16) {
a625 1
				break;
d627 1
a627 1
			return (EINVAL);
d629 3
a631 1
			if (p->channels == 2 && p->precision == 16) {
d633 1
a633 3
				break;
			}
			if (p->channels == 1 && p->precision == 16) {
a635 1
				break;
d637 1
a637 1
			return (EINVAL);
@


1.21
log
@audio encoding conversion cleanup

- the endianness of the conversions don't depend on the endianness
  of machine the conversions are built on, but the endianness of the
  audio data itself.  choose encoding conversions explicitly, instead
  of relying on #defines based on the endianness of the machine.
- replace home-grown conversions with comparable conversions in
  auconv.c and mulaw.c
- use the proper conversion for ulinear_be:16 -> slinear_le:16 in
  auixp(4)

thanks ajacoutot@@ and sthen@@ for !x86 testing
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.20 2007/09/17 01:33:33 krw Exp $	*/
d160 2
a161 1
	awacs_trigger_input
@


1.20
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.19 2007/04/22 22:31:14 deraadt Exp $	*/
a124 4
void awacs_mono16_to_stereo16(void *, u_char *, int);
void awacs_swap_bytes_mono16_to_stereo16(void *, u_char *, int);
void awacs_cvt_ulinear_mono_16_be(void *, u_char *, int);
void awacs_cvt_ulinear_mono_16_le(void *, u_char *, int);
a553 37
void
awacs_mono16_to_stereo16(void *v, u_char *p, int cc)
{
	int x;
	int16_t *src, *dst;

	src = (void *)(p + cc);
	dst = (void *)(p + cc * 2);
	while (cc > 0) {
		x = *--src;
		*--dst = x;
		*--dst = x;
		cc -= 2;
	}
}

void
awacs_swap_bytes_mono16_to_stereo16(void *v, u_char *p, int cc)
{
	swap_bytes(v, p, cc);
	awacs_mono16_to_stereo16(v, p, cc);
}

void
awacs_cvt_ulinear_mono_16_le(void *v, u_char *p, int cc)
{
	swap_bytes_change_sign16_be(v, p, cc);
	awacs_mono16_to_stereo16(v, p, cc);
}

void
awacs_cvt_ulinear_mono_16_be(void *v, u_char *p, int cc)
{
	change_sign16_be(v, p, cc);
	awacs_mono16_to_stereo16(v, p, cc);
}

d602 1
a602 2
				p->sw_code =
				    awacs_swap_bytes_mono16_to_stereo16;
d611 1
a611 1
				p->sw_code = awacs_mono16_to_stereo16;
d622 1
a622 1
				p->sw_code = awacs_cvt_ulinear_mono_16_le;
d633 1
a633 1
				p->sw_code = awacs_cvt_ulinear_mono_16_be;
@


1.19
log
@better interrupt names for vmstat -iz; ok miod gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.18 2005/11/17 02:58:03 brad Exp $	*/
d993 1
a993 1
	p = malloc(sizeof(*p), type, flags);
a995 1
	bzero(p, sizeof(*p));
@


1.18
log
@fix mixer control names.

i2s.c diff from Tsubai Masanari's CVS repo.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.17 2004/01/18 13:51:35 miod Exp $	*/
d303 1
a303 1
	    sc, "awacs");
d305 1
a305 1
	    sc, "awacs/tx");
d307 1
a307 1
	    sc, "awacs/rx");
@


1.17
log
@Silence match() unless DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.16 2003/10/16 03:31:25 drahn Exp $	*/
d887 2
a888 2
		dip->mixer_class = AWACS_MONITOR_CLASS;
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
@


1.16
log
@more ANSI/KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.15 2003/06/16 03:45:40 jason Exp $	*/
d251 1
d254 1
@


1.15
log
@correct sense of rate check... oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.14 2003/06/16 03:22:45 jason Exp $	*/
d243 1
a243 4
awacs_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d266 1
a266 4
awacs_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d301 1
a301 1
		sc, "awacs");
d303 1
a303 1
		sc, "awacs/tx");
d305 1
a305 1
		sc, "awacs/rx");
d311 1
a311 1
		AWACS_RATE_44100 | AWACS_INT_PORTCHG;
d364 1
a364 3
awacs_read_reg(sc, reg)
	struct awacs_softc *sc;
	int reg;
d372 1
a372 3
awacs_write_reg(sc, reg, val)
	struct awacs_softc *sc;
	int reg, val;
d380 1
a380 3
awacs_write_codec(sc, value)
	struct awacs_softc *sc;
	int value;
d387 1
a387 2
awacs_intr(v)
	void *v;
d421 1
a421 2
awacs_tx_intr(v)
	void *v;
d449 1
a449 2
awacs_rx_intr(v)
	void *v;
d478 1
a478 3
awacs_open(h, flags)
	void *h;
	int flags;
d487 1
a487 2
awacs_close(h)
	void *h;
d499 1
a499 3
awacs_query_encoding(h, ae)
	void *h;
	struct audio_encoding *ae;
d594 2
a595 4
awacs_set_params(h, setmode, usemode, play, rec)
	void *h;
	int setmode, usemode;
	struct audio_params *play, *rec;
d704 1
a704 3
awacs_round_blocksize(h, size)
	void *h;
	int size;
d712 1
a712 2
awacs_halt_output(h)
	void *h;
d724 1
a724 2
awacs_halt_input(h)
	void *h;
d734 1
a734 3
awacs_getdev(h, retp)
	void *h;
	struct audio_device *retp;
d754 1
a754 3
awacs_set_port(h, mc)
	void *h;
	mixer_ctrl_t *mc;
d824 1
a824 3
awacs_get_port(h, mc)
	void *h;
	mixer_ctrl_t *mc;
d878 1
a878 3
awacs_query_devinfo(h, dip)
	void *h;
	mixer_devinfo_t *dip;
a879 1

d973 1
a973 4
awacs_round_buffersize(h, dir, size)
	void *h;
	int dir;
	size_t size;
d982 1
a982 4
awacs_allocm(h, dir, size, type, flags)
	void *h;
	int dir, type, flags;
	size_t size;
d1046 1
a1046 5
awacs_mappage(h, mem, off, prot)
	void *h;
	void *mem;
	off_t off;
	int prot;
d1054 1
a1054 2
awacs_get_props(h)
	void *h;
d1060 2
a1061 7
awacs_trigger_output(h, start, end, bsize, intr, arg, param)
	void *h;
	void *start, *end;
	int bsize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d1101 2
a1102 7
awacs_trigger_input(h, start, end, bsize, intr, arg, param)
	void *h;
	void *start, *end;
	int bsize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d1142 1
a1142 3
awacs_set_speaker_volume(sc, left, right)
	struct awacs_softc *sc;
	int left, right;
d1155 1
a1155 3
awacs_set_ext_volume(sc, left, right)
	struct awacs_softc *sc;
	int left, right;
@


1.14
log
@rate setting is best effort, not precise, so figure out the closest sample
rate that goes with the requested rate, and return the chosen rate.
ok drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.13 2003/06/14 04:43:20 jason Exp $	*/
d1243 1
a1243 1
		else if (p->sample_rate > awacs_speeds[i].rate) {
@


1.13
log
@add support for: ulinear_le, ulinear_be, ulinear:16 (partially based on
NetBSD).  ok drahn who let me reboot one of his laptops a LOT =)
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.12 2003/05/11 19:41:10 deraadt Exp $	*/
d124 1
a124 1
int awacs_set_rate(struct awacs_softc *, int);
d228 14
d621 1
a621 1
	int mode, rate;
d720 1
a720 1
	rate = p->sample_rate;
d722 1
a722 3
	awacs_set_rate(sc, rate);

	return 0;
d1227 2
a1228 4
int
awacs_set_rate(sc, rate)
	struct awacs_softc *sc;
	int rate;
d1230 2
a1231 1
	int c;
d1233 1
a1233 1
	switch (rate) {
d1235 15
a1249 26
	case 44100:
		c = AWACS_RATE_44100;
		break;
	case 29400:
		c = AWACS_RATE_29400;
		break;
	case 22050:
		c = AWACS_RATE_22050;
		break;
	case 17640:
		c = AWACS_RATE_17640;
		break;
	case 14700:
		c = AWACS_RATE_14700;
		break;
	case 11025:
		c = AWACS_RATE_11025;
		break;
	case 8820:
		c = AWACS_RATE_8820;
		break;
	case 7350:
		c = AWACS_RATE_7350;
		break;
	default:
		return -1;
d1252 3
d1256 2
a1257 1
	sc->sc_soundctl |= c;
a1258 2

	return 0;
@


1.12
log
@string cleaning; krw ok
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.11 2002/09/15 09:01:58 deraadt Exp $	*/
d125 4
a128 1
void awacs_mono16_to_stereo16(void *v, u_char *p, int cc);
d513 1
a513 1
		return 0;
d519 1
a519 1
		return 0;
d525 1
a525 1
		return 0;
d531 1
a531 1
		return 0;
d537 19
a555 1
		return 0;
d557 1
a557 1
		return EINVAL;
d559 1
d563 1
a563 4
awacs_mono16_to_stereo16(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d578 21
d637 1
a637 1
		p->sw_code = 0;
d643 11
a653 1
			awacs_write_reg(sc, AWACS_BYTE_SWAP, 1);
d655 3
a657 1
			if (p->channels == 1) {
d662 1
a662 5
			if (p->precision != 16)
				return EINVAL;
				/* p->sw_code = change_sign8; */
			break;

d664 10
a673 1
			awacs_write_reg(sc, AWACS_BYTE_SWAP, 1);
d675 1
a675 1
			if (p->precision == 16)
d677 8
a684 4
			else
				return EINVAL;
			break;

d689 1
d691 2
a692 3
				p->sw_code = ulinear8_to_mulaw;
			break;

d697 3
a699 4
			} else
				p->sw_code = ulinear8_to_alaw;
			break;

d701 1
a701 1
			return EINVAL;
@


1.11
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.9 2002/03/14 01:26:36 millert Exp $	*/
d506 1
a506 1
		strcpy(ae->name, AudioEslinear);
d512 1
a512 1
		strcpy(ae->name, AudioEslinear_be);
d518 1
a518 1
		strcpy(ae->name, AudioEslinear_le);
d524 1
a524 1
		strcpy(ae->name, AudioEmulaw);
d530 1
a530 1
		strcpy(ae->name, AudioEalaw);
d849 1
a849 1
		strcpy(dip->label.name, AudioNoutput);
d853 2
a854 1
		strcpy(dip->un.s.member[0].label.name, AudioNspeaker);
d856 2
a857 1
		strcpy(dip->un.s.member[1].label.name, AudioNheadphone);
d863 2
a864 1
		strcpy(dip->label.name, AudioNspeaker);
d868 2
a869 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d874 2
a875 1
		strcpy(dip->label.name, AudioNheadphone);
d879 2
a880 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d885 1
a885 1
		strcpy(dip->label.name, AudioNsource);
d889 2
a890 1
		strcpy(dip->un.s.member[0].label.name, AudioNcd);
d892 2
a893 1
		strcpy(dip->un.s.member[1].label.name, AudioNmicrophone);
d895 2
a896 1
		strcpy(dip->un.s.member[2].label.name, AudioNline);
d902 1
a902 1
		strcpy(dip->label.name, AudioNmaster);
d906 2
a907 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d912 1
a912 1
		strcpy(dip->label.name, AudioCmonitor);
d919 1
a919 1
		strcpy(dip->label.name, AudioCoutputs);
d926 1
a926 1
		strcpy(dip->label.name, AudioCrecord);
@


1.10
log
@KNF
@
text
@d105 1
a105 1
			    void *, struct audio_params *);
d585 1
a585 1
	    mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
d755 1
a755 1
		switch (mc->un.mask) {
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.8 2002/01/30 06:53:56 drahn Exp $	*/
d105 1
a105 1
			     void *, struct audio_params *);
d585 1
a585 1
	     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
d755 1
a755 1
		switch(mc->un.mask) {
@


1.8
log
@A bit of hacking on awacs to try to get audio input working.
interrupts and buffer handling seems to be occurring correctly.
All audio samples are zero'ed however. Dont know if the problem is
with audio source control or with DMA. audio output still works.
A few changes were other changes from netbsd which seemed to make sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.7 2002/01/20 23:10:34 ericj Exp $	*/
d117 1
a117 1
void *awacs_allocm __P((void *, int, size_t, int, int));
d125 1
a125 1
void awacs_mono16_to_stereo16 __P((void *v, u_char *p, int cc));
@


1.7
log
@
use new allocm, round_buffersize decl's
missed this one.
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.6 2001/10/31 11:00:24 art Exp $	*/
d293 1
a293 6
#if 0
	/* do not use this for now, since both are tied to same freq
	 * we can service both in the same interrupt, lowering
	 * interrupt load by half
	 */
	mac_intr_establish(parent, iirq, irq_type, IPL_AUDIO, awacs_intr,
a294 1
#endif
d445 29
d727 2
a728 2
		switch(mc->un.mask) {
		case 1<<0: /* speaker */
d730 1
a730 5
			sc->sc_codecctl1 |= AWACS_MUTE_HEADPHONE;
			awacs_write_codec(sc, sc->sc_codecctl1);
			break;
		case 1<<1: /* headphones */
			sc->sc_codecctl1 |= AWACS_MUTE_SPEAKER;
d732 2
a733 5
			awacs_write_codec(sc, sc->sc_codecctl1);
			break;
		default: /* invalid argument */
			return -1;
		}
d878 2
a879 2
		dip->mixer_class = AWACS_MONITOR_CLASS;
		strcpy(dip->label.name, AudioNinput);
d892 1
a892 1
		dip->mixer_class = AWACS_INPUT_CLASS;
a919 7

	case AWACS_INPUT_CLASS:
		dip->mixer_class = AWACS_INPUT_CLASS;
		strcpy(dip->label.name, AudioCinputs);
		dip->type = AUDIO_MIXER_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		return 0;
d1078 15
a1092 1
	printf("awacs_trigger_input called\n");
d1094 19
a1112 1
	return 1;
@


1.6
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.5 2001/09/25 00:13:18 drahn Exp $	*/
d155 1
a155 1
	NULL,			/* allocm_old */
d157 1
a157 1
	NULL,			/* round_buffersize_old */
d161 1
a161 4
	awacs_trigger_input,
	awacs_allocm,
	awacs_round_buffersize,

@


1.6.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.8 2002/01/30 06:53:56 drahn Exp $	*/
d155 1
a155 1
	awacs_allocm,		/* allocm */
d157 1
a157 1
	awacs_round_buffersize,	/* round_buffersize */
d161 4
a164 1
	awacs_trigger_input
d296 6
a301 1
	mac_intr_establish(parent, iirq, iirq_type, IPL_AUDIO, awacs_rx_intr,
d303 1
a453 29
int
awacs_rx_intr(v)
	void *v;
{
	struct awacs_softc *sc = v;
	struct dbdma_command *cmd = sc->sc_idmap;
	u_int16_t c, status;

	/* if not set we are not running */
	if (!cmd)
		return (0);

	c = in16rb(&cmd->d_command);
	status = in16rb(&cmd->d_status);

	if (c >> 12 == DBDMA_CMD_IN_LAST)
		sc->sc_idmap = sc->sc_idmacmd;
	else
		sc->sc_idmap++;

	if (c & (DBDMA_INT_ALWAYS << 4)) {
		cmd->d_status = 0;
		if (status)	/* status == 0x8400 */
			if (sc->sc_iintr)
				(*sc->sc_iintr)(sc->sc_iarg);
	}

	return (1);
}
d707 2
a708 2
		sc->sc_codecctl1 |= AWACS_MUTE_SPEAKER | AWACS_MUTE_HEADPHONE;
		if (mc->un.mask & 1 << 0)
d710 5
a714 1
		if (mc->un.mask & 1 << 1)
d716 5
a720 2

		awacs_write_codec(sc, sc->sc_codecctl1);
d865 2
a866 2
		dip->mixer_class = AWACS_RECORD_CLASS;
		strcpy(dip->label.name, AudioNsource);
d879 1
a879 1
		dip->mixer_class = AWACS_RECORD_CLASS;
d907 7
d1072 1
a1072 5
	struct awacs_softc *sc = h;
	struct awacs_dma *p;
	struct dbdma_command *cmd = sc->sc_idmacmd;
	vaddr_t spa, pa, epa;
	int c;
d1074 1
a1074 29
	printf("trigger_input %p %p 0x%x\n", start, end, bsize);

	for (p = sc->sc_dmas; p && p->addr != start; p = p->next);
	if (!p)
		return -1;

	sc->sc_iintr = intr;
	sc->sc_iarg = arg;
	sc->sc_idmap = sc->sc_idmacmd;

	spa = p->segs[0].ds_addr;
	c = DBDMA_CMD_IN_MORE;
	for (pa = spa, epa = spa + (end - start);
	    pa < epa; pa += bsize, cmd++) {

		if (pa + bsize == epa)
			c = DBDMA_CMD_IN_LAST;

		DBDMA_BUILD(cmd, c, 0, bsize, pa, DBDMA_INT_ALWAYS,
			DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
	}

	DBDMA_BUILD(cmd, DBDMA_CMD_NOP, 0, 0, 0,
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_ALWAYS);
	dbdma_st32(&cmd->d_cmddep, sc->sc_idbdma->d_paddr);

	dbdma_start(sc->sc_idma, sc->sc_idbdma);

	return 0;
@


1.6.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.6.2.1 2002/01/31 22:55:14 niklas Exp $	*/
d117 1
a117 1
void *awacs_allocm(void *, int, size_t, int, int);
d125 1
a125 1
void awacs_mono16_to_stereo16(void *v, u_char *p, int cc);
@


1.6.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.6.2.2 2002/06/11 03:36:33 art Exp $	*/
@


1.6.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d506 1
a506 1
		strlcpy(ae->name, AudioEslinear, sizeof ae->name);
d512 1
a512 1
		strlcpy(ae->name, AudioEslinear_be, sizeof ae->name);
d518 1
a518 1
		strlcpy(ae->name, AudioEslinear_le, sizeof ae->name);
d524 1
a524 1
		strlcpy(ae->name, AudioEmulaw, sizeof ae->name);
d530 1
a530 1
		strlcpy(ae->name, AudioEalaw, sizeof ae->name);
d849 1
a849 1
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
d853 1
a853 2
		strlcpy(dip->un.s.member[0].label.name, AudioNspeaker,
		    sizeof dip->un.s.member[0].label.name);
d855 1
a855 2
		strlcpy(dip->un.s.member[1].label.name, AudioNheadphone,
		    sizeof dip->un.s.member[0].label.name);
d861 1
a861 2
		strlcpy(dip->label.name, AudioNspeaker,
		    sizeof dip->label.name);
d865 1
a865 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d870 1
a870 2
		strlcpy(dip->label.name, AudioNheadphone,
		    sizeof dip->label.name);
d874 1
a874 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d879 1
a879 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d883 1
a883 2
		strlcpy(dip->un.s.member[0].label.name, AudioNcd,
		    sizeof dip->un.s.member[0].label.name);
d885 1
a885 2
		strlcpy(dip->un.s.member[1].label.name, AudioNmicrophone,
		    sizeof dip->un.s.member[1].label.name);
d887 1
a887 2
		strlcpy(dip->un.s.member[2].label.name, AudioNline,
		    sizeof dip->un.s.member[2].label.name);
d893 1
a893 1
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d897 1
a897 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d902 1
a902 1
		strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
d909 1
a909 1
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d916 1
a916 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
@


1.5
log
@shh, no point in printing useless kernel messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.4 2001/09/15 01:51:11 mickey Exp $	*/
d115 1
a115 1
int awacs_mappage(void *, void *, int, int);
d998 1
a998 1
int
d1002 1
a1002 1
	int off;
@


1.5.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.5.4.2
log
@Merge in -current
@
text
@d115 1
a115 1
paddr_t awacs_mappage(void *, void *, off_t, int);
d998 1
a998 1
paddr_t
d1002 1
a1002 1
	off_t off;
@


1.5.4.3
log
@Merge in trunk
@
text
@d155 1
a155 1
	awacs_allocm,		/* allocm */
d157 1
a157 1
	awacs_round_buffersize,	/* round_buffersize */
d161 4
a164 1
	awacs_trigger_input
d296 6
a301 1
	mac_intr_establish(parent, iirq, iirq_type, IPL_AUDIO, awacs_rx_intr,
d303 1
a453 29
int
awacs_rx_intr(v)
	void *v;
{
	struct awacs_softc *sc = v;
	struct dbdma_command *cmd = sc->sc_idmap;
	u_int16_t c, status;

	/* if not set we are not running */
	if (!cmd)
		return (0);

	c = in16rb(&cmd->d_command);
	status = in16rb(&cmd->d_status);

	if (c >> 12 == DBDMA_CMD_IN_LAST)
		sc->sc_idmap = sc->sc_idmacmd;
	else
		sc->sc_idmap++;

	if (c & (DBDMA_INT_ALWAYS << 4)) {
		cmd->d_status = 0;
		if (status)	/* status == 0x8400 */
			if (sc->sc_iintr)
				(*sc->sc_iintr)(sc->sc_iarg);
	}

	return (1);
}
d707 2
a708 2
		sc->sc_codecctl1 |= AWACS_MUTE_SPEAKER | AWACS_MUTE_HEADPHONE;
		if (mc->un.mask & 1 << 0)
d710 5
a714 1
		if (mc->un.mask & 1 << 1)
d716 5
a720 2

		awacs_write_codec(sc, sc->sc_codecctl1);
d865 2
a866 2
		dip->mixer_class = AWACS_RECORD_CLASS;
		strcpy(dip->label.name, AudioNsource);
d879 1
a879 1
		dip->mixer_class = AWACS_RECORD_CLASS;
d907 7
d1072 1
a1072 5
	struct awacs_softc *sc = h;
	struct awacs_dma *p;
	struct dbdma_command *cmd = sc->sc_idmacmd;
	vaddr_t spa, pa, epa;
	int c;
d1074 1
a1074 29
	printf("trigger_input %p %p 0x%x\n", start, end, bsize);

	for (p = sc->sc_dmas; p && p->addr != start; p = p->next);
	if (!p)
		return -1;

	sc->sc_iintr = intr;
	sc->sc_iarg = arg;
	sc->sc_idmap = sc->sc_idmacmd;

	spa = p->segs[0].ds_addr;
	c = DBDMA_CMD_IN_MORE;
	for (pa = spa, epa = spa + (end - start);
	    pa < epa; pa += bsize, cmd++) {

		if (pa + bsize == epa)
			c = DBDMA_CMD_IN_LAST;

		DBDMA_BUILD(cmd, c, 0, bsize, pa, DBDMA_INT_ALWAYS,
			DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
	}

	DBDMA_BUILD(cmd, DBDMA_CMD_NOP, 0, 0, 0,
		DBDMA_INT_NEVER, DBDMA_WAIT_NEVER, DBDMA_BRANCH_ALWAYS);
	dbdma_st32(&cmd->d_cmddep, sc->sc_idbdma->d_paddr);

	dbdma_start(sc->sc_idma, sc->sc_idbdma);

	return 0;
@


1.5.4.4
log
@Merge in -current from about a week ago
@
text
@d117 1
a117 1
void *awacs_allocm(void *, int, size_t, int, int);
d125 1
a125 1
void awacs_mono16_to_stereo16(void *v, u_char *p, int cc);
@


1.5.4.5
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.5.4.4 2002/03/28 10:36:01 niklas Exp $	*/
d506 1
a506 1
		strlcpy(ae->name, AudioEslinear, sizeof ae->name);
d512 1
a512 1
		strlcpy(ae->name, AudioEslinear_be, sizeof ae->name);
d518 1
a518 1
		strlcpy(ae->name, AudioEslinear_le, sizeof ae->name);
d524 1
a524 1
		strlcpy(ae->name, AudioEmulaw, sizeof ae->name);
d530 1
a530 1
		strlcpy(ae->name, AudioEalaw, sizeof ae->name);
d849 1
a849 1
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
d853 1
a853 2
		strlcpy(dip->un.s.member[0].label.name, AudioNspeaker,
		    sizeof dip->un.s.member[0].label.name);
d855 1
a855 2
		strlcpy(dip->un.s.member[1].label.name, AudioNheadphone,
		    sizeof dip->un.s.member[0].label.name);
d861 1
a861 2
		strlcpy(dip->label.name, AudioNspeaker,
		    sizeof dip->label.name);
d865 1
a865 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d870 1
a870 2
		strlcpy(dip->label.name, AudioNheadphone,
		    sizeof dip->label.name);
d874 1
a874 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d879 1
a879 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d883 1
a883 2
		strlcpy(dip->un.s.member[0].label.name, AudioNcd,
		    sizeof dip->un.s.member[0].label.name);
d885 1
a885 2
		strlcpy(dip->un.s.member[1].label.name, AudioNmicrophone,
		    sizeof dip->un.s.member[1].label.name);
d887 1
a887 2
		strlcpy(dip->un.s.member[2].label.name, AudioNline,
		    sizeof dip->un.s.member[2].label.name);
d893 1
a893 1
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d897 1
a897 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d902 1
a902 1
		strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
d909 1
a909 1
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d916 1
a916 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
@


1.5.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d124 2
a125 5
void awacs_set_rate(struct awacs_softc *, struct audio_params *);
void awacs_mono16_to_stereo16(void *, u_char *, int);
void awacs_swap_bytes_mono16_to_stereo16(void *, u_char *, int);
void awacs_cvt_ulinear_mono_16_be(void *, u_char *, int);
void awacs_cvt_ulinear_mono_16_le(void *, u_char *, int);
a224 14
const struct awacs_speed_tab {
	int rate;
	u_int32_t bits;
} awacs_speeds[] = {
	{  7350, AWACS_RATE_7350 },
	{  8820, AWACS_RATE_8820 },
	{ 11025, AWACS_RATE_11025 },
	{ 14700, AWACS_RATE_14700 },
	{ 17640, AWACS_RATE_17640 },
	{ 22050, AWACS_RATE_22050 },
	{ 29400, AWACS_RATE_29400 },
	{ 44100, AWACS_RATE_44100 },
};

d226 4
a229 1
awacs_match(struct device *parent, void *match, void *aux)
a236 1
#ifdef DEBUG
a238 1
#endif
d252 4
a255 1
awacs_attach(struct device *parent, struct device *self, void *aux)
d290 1
a290 1
	    sc, "awacs");
d292 1
a292 1
	    sc, "awacs/tx");
d294 1
a294 1
	    sc, "awacs/rx");
d300 1
a300 1
	    AWACS_RATE_44100 | AWACS_INT_PORTCHG;
d353 3
a355 1
awacs_read_reg(struct awacs_softc *sc, int reg)
d363 3
a365 1
awacs_write_reg(struct awacs_softc *sc, int reg, int val)
d373 3
a375 1
awacs_write_codec(struct awacs_softc *sc, int value)
d382 2
a383 1
awacs_intr(void *v)
d417 2
a418 1
awacs_tx_intr(void *v)
d446 2
a447 1
awacs_rx_intr(void *v)
d476 3
a478 1
awacs_open(void *h, int flags)
d487 2
a488 1
awacs_close(void *h)
d500 3
a502 1
awacs_query_encoding(void *h, struct audio_encoding *ae)
d510 1
a510 1
		break;
d516 1
a516 1
		break;
d522 1
a522 1
		break;
d528 1
a528 1
		break;
d534 1
a534 19
		break;
	case 5:
		strlcpy(ae->name, AudioEulinear, sizeof ae->name);
		ae->encoding = AUDIO_ENCODING_ULINEAR;
		ae->precision = 16;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
		strlcpy(ae->name, AudioEulinear_le, sizeof ae->name);
		ae->encoding = AUDIO_ENCODING_ULINEAR_LE;
		ae->precision = 16;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(ae->name, AudioEulinear_be, sizeof ae->name);
		ae->encoding = AUDIO_ENCODING_ULINEAR_BE;
		ae->precision = 16;
		ae->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
d536 1
a536 1
		return (EINVAL);
a537 1
	return (0);
d541 4
a544 1
awacs_mono16_to_stereo16(void *v, u_char *p, int cc)
a558 21
void
awacs_swap_bytes_mono16_to_stereo16(void *v, u_char *p, int cc)
{
	swap_bytes(v, p, cc);
	awacs_mono16_to_stereo16(v, p, cc);
}

void
awacs_cvt_ulinear_mono_16_le(void *v, u_char *p, int cc)
{
	swap_bytes_change_sign16_be(v, p, cc);
	awacs_mono16_to_stereo16(v, p, cc);
}

void
awacs_cvt_ulinear_mono_16_be(void *v, u_char *p, int cc)
{
	change_sign16_be(v, p, cc);
	awacs_mono16_to_stereo16(v, p, cc);
}

d560 4
a563 2
awacs_set_params(void *h, int setmode, int usemode, struct audio_params *play,
    struct audio_params *rec)
d567 1
a567 1
	int mode;
d597 1
a597 1
		p->sw_code = NULL;
d603 1
a603 11
			if (p->channels == 2 && p->precision == 16) {
				p->sw_code = swap_bytes;
				break;
			}
			if (p->channels == 1 && p->precision == 16) {
				p->factor = 2;
				p->sw_code =
				    awacs_swap_bytes_mono16_to_stereo16;
				break;
			}
			return (EINVAL);
d605 1
a605 3
			if (p->channels == 2 && p->precision == 16)
				break;
			if (p->channels == 1 && p->precision == 16) {
d610 5
a614 1
			return (EINVAL);
d616 1
a616 10
			if (p->channels == 2 && p->precision == 16) {
				p->sw_code = swap_bytes_change_sign16_be;
				break;
			}
			if (p->channels == 1 && p->precision == 16) {
				p->factor = 2;
				p->sw_code = awacs_cvt_ulinear_mono_16_le;
				break;
			}
			return (EINVAL);
d618 1
a618 1
			if (p->channels == 2 && p->precision == 16) {
d620 4
a623 8
				break;
			}
			if (p->channels == 1 && p->precision == 16) {
				p->factor = 2;
				p->sw_code = awacs_cvt_ulinear_mono_16_be;
				break;
			}
			return (EINVAL);
a627 1
				break;
d629 3
a631 2
				break;	/* XXX */
			return (EINVAL);
d636 4
a639 3
				break;
			}
			return (EINVAL);
d641 1
a641 1
			return (EINVAL);
d646 3
a648 1
	awacs_set_rate(sc, p);
d650 1
a650 1
	return (0);
d654 3
a656 1
awacs_round_blocksize(void *h, int size)
d664 2
a665 1
awacs_halt_output(void *h)
d677 2
a678 1
awacs_halt_input(void *h)
d688 3
a690 1
awacs_getdev(void *h, struct audio_device *retp)
d710 3
a712 1
awacs_set_port(void *h, mixer_ctrl_t *mc)
d782 3
a784 1
awacs_get_port(void *h, mixer_ctrl_t *mc)
d838 3
a840 1
awacs_query_devinfo(void *h, mixer_devinfo_t *dip)
d842 1
d936 4
a939 1
awacs_round_buffersize(void *h, int dir, size_t size)
d948 4
a951 1
awacs_allocm(void *h, int dir, size_t size, int type, int flags)
d1015 5
a1019 1
awacs_mappage(void *h, void *mem, off_t off, int prot)
d1027 2
a1028 1
awacs_get_props(void *h)
d1034 7
a1040 2
awacs_trigger_output(void *h, void *start, void *end, int bsize,
    void (*intr)(void *), void *arg, struct audio_params *param)
d1080 7
a1086 2
awacs_trigger_input(void *h, void *start, void *end, int bsize,
    void (*intr)(void *), void *arg, struct audio_params *param)
d1126 3
a1128 1
awacs_set_speaker_volume(struct awacs_softc *sc, int left, int  right)
d1141 3
a1143 1
awacs_set_ext_volume(struct awacs_softc *sc, int left, int  right)
d1155 4
a1158 2
void
awacs_set_rate(struct awacs_softc *sc, struct audio_params *p)
d1160 1
a1160 2
	int selected = -1;
	size_t n, i;
d1162 1
a1162 1
	n = sizeof(awacs_speeds)/sizeof(awacs_speeds[0]);
d1164 26
a1189 15
	if (p->sample_rate < awacs_speeds[0].rate)
		selected = 0;
	if (p->sample_rate > awacs_speeds[n - 1].rate)
		selected = n - 1;

	for (i = 1; selected == -1 && i < n; i++) {
		if (p->sample_rate == awacs_speeds[i].rate)
			selected = i;
		else if (p->sample_rate < awacs_speeds[i].rate) {
			u_int diff1, diff2;

			diff1 = p->sample_rate - awacs_speeds[i - 1].rate;
			diff2 = awacs_speeds[i].rate - p->sample_rate;
			selected = (diff1 < diff2) ? i - 1 : i;
		}
a1191 3
	if (selected == -1)
		selected = 0;

d1193 1
a1193 2
	sc->sc_soundctl |= awacs_speeds[selected].bits;
	p->sample_rate = awacs_speeds[selected].rate;
d1195 2
@


1.4
log
@reimplement dbdma such that it does memory allocations
w/ bus_dma(9) and rework drivers accordingly.
make drivers use bus_dma as well, except for if_bm (later ;) .
additionally, sync wdc_obio w/ netbsd.
drahn@@ ok, tested by miod@@, pval@@, brad@@, mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.3 2001/09/11 20:05:24 miod Exp $	*/
a399 1
		printf("should change inputs\n");
@


1.3
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.2 2001/09/01 17:43:09 drahn Exp $	*/
a34 1
#include <sys/types.h>
d40 1
a40 3
#include <vm/vm.h>
#include <uvm/uvm.h>

a41 1
#include <machine/pio.h>
d50 13
a67 1
	int sc_opages;			/* # of output pages */
d82 1
d85 5
a89 2
	struct dbdma_command *sc_odmacmd;
	struct dbdma_command *sc_idmacmd;
d117 1
d138 1
a138 1
	NULL,
d142 5
a146 5
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
d149 1
a149 1
	NULL,
d151 1
a151 1
	NULL,
d155 3
a157 3
	NULL,
	NULL,
	NULL,
d162 1
a162 1
	NULL,
d271 1
d274 4
a277 2
	sc->sc_odmacmd = dbdma_alloc(20 * sizeof(struct dbdma_command));
	sc->sc_idmacmd = dbdma_alloc(20 * sizeof(struct dbdma_command));
d425 1
d431 2
a432 3
	struct dbdma_command *cmd = sc->sc_odmacmd;
	int count = sc->sc_opages;
	int status;
d434 17
a450 11
	/* Fill used buffer(s). */
	while (count-- > 0) {
		/* if DBDMA_INT_ALWAYS */
		if (in16rb(&cmd->d_command) & 0x30) {	/* XXX */
			status = in16rb(&cmd->d_status);
			cmd->d_status = 0;
			if (status)	/* status == 0x8400 */
				if (sc->sc_ointr)
					(*sc->sc_ointr)(sc->sc_oarg);
		}
		cmd++;
d453 1
a453 1
	return 1;
d639 3
a641 3
	if (size < NBPG)
		size = NBPG;
	return size & ~PGOFSET;
d653 1
d926 71
a996 3
	if (size > 65536)
		size = 65536;
	return size;
d1028 1
d1030 2
a1031 2
	vaddr_t va;
	int i, len, intmode;
d1035 4
d1041 1
a1041 1
	sc->sc_opages = ((char *)end - (char *)start) / NBPG;
d1043 4
a1046 4
#ifdef DIAGNOSTIC
	if (sc->sc_opages > 16)
		panic("awacs_trigger_output");
#endif
d1048 2
a1049 10
	va = (vaddr_t)start;
	len = 0;
	for (i = sc->sc_opages; i > 0; i--) {
		len += NBPG;
		if (len < bsize)
			intmode = DBDMA_INT_NEVER;
		else {
			len = 0;
			intmode = DBDMA_INT_ALWAYS;
		}
d1051 2
a1052 4
		DBDMA_BUILD(cmd, DBDMA_CMD_OUT_MORE, 0, NBPG, vtophys(va),
			intmode, DBDMA_WAIT_NEVER, DBDMA_BRANCH_NEVER);
		va += NBPG;
		cmd++;
d1057 1
a1057 1
	dbdma_st32(&cmd->d_cmddep, vtophys((vaddr_t)sc->sc_odmacmd));
d1059 1
a1059 1
	dbdma_start(sc->sc_odma, sc->sc_odmacmd);
@


1.2
log
@correct files for the powerpc/mac/ -> macppc/dev which did not get
renamed correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.1 2001/09/01 15:50:00 drahn Exp $	*/
a41 1
#include <vm/vm_kern.h>
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/mac to macppc/dev
@
text
@d1 1
a1 1
/*	$OpenBSD: awacs.c,v 1.7 2001/07/09 03:30:19 mickey Exp $	*/
d47 1
a47 1
#include <macppc/mac/dbdma.h>
@

