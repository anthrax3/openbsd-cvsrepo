head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.12
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.10
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.6
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.20.0.4
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.8
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.6
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.19.0.6
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.4
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.2
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.6
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.8
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.12
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.6
	UBC:1.1.0.6
	UBC_BASE:1.1
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.22
date	2015.03.23.20.18.52;	author miod;	state Exp;
branches;
next	1.21;
commitid	9G8mc6J9paxqcGcc;

1.21
date	2015.03.14.20.52.41;	author miod;	state Exp;
branches;
next	1.20;
commitid	b7GHvl57Bcg5ZICf;

1.20
date	2013.03.21.21.57.15;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2011.11.19.16.11.55;	author mpi;	state Exp;
branches;
next	1.18;

1.18
date	2011.04.10.09.58.19;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2011.03.13.00.13.53;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2010.05.14.19.32.39;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2008.05.25.16.55.31;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.14.03.27.16;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.13.02.17.32;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.06.17.15.12;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.02.15.28.09;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.02.01.52.09;	author deraadt;	state dead;
branches;
next	1.9;

1.9
date	2006.10.12.12.14.17;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.16.04.30.09;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.06.18.54.19;	author ho;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.15.09.01.59;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.06.01.17.12;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.23.21.04.26;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.39.02;	author drahn;	state Exp;
branches
	1.1.4.1
	1.1.6.1;
next	;

1.1.4.1
date	2001.10.31.03.01.16;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.27.23.29.46;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2003.05.13.19.41.06;	author ho;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.1.6.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2003.05.19.21.49.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Fix buglet in previous ofdev change causing NFS boot to fail; found the hard
way by mpi@@. Bump version.
ok mpi@@
@
text
@/*	$OpenBSD: ofdev.c,v 1.21 2015/03/14 20:52:41 miod Exp $	*/
/*	$NetBSD: ofdev.c,v 1.1 1997/04/16 20:29:20 thorpej Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Device I/O routines using Open Firmware
 */
#include <sys/param.h>
#include <lib/libkern/libkern.h>
#include <sys/disklabel.h>
#include <netinet/in.h>

#include <lib/libsa/stand.h>
#include <lib/libsa/ufs.h>
#include <lib/libsa/cd9660.h>
#include <lib/libsa/nfs.h>
#include <hfs.h>

#include <macppc/stand/ofdev.h>

extern char bootdev[];

char opened_name[256];

/*
 * this function is passed [device specifier]:[kernel]
 * however a device specifier may contain a ':'
 */
static int
parsename(char *str, char **file)
{
	char *cp;
	int aliases;
	size_t len;

	cp = strrchr(str, ':');
	if (cp == NULL)
		return 1;

	*cp++ = 0;

	if ((aliases = OF_finddevice("/aliases")) == -1 ||
	    OF_getprop(aliases, str, opened_name, sizeof opened_name) < 0)
		strlcpy(opened_name, str, sizeof opened_name);

	len = strlcat(opened_name, ":", sizeof opened_name);
	if (*cp != '/')
		strlcat(opened_name, "/", sizeof opened_name);

	if (strlcat(opened_name, cp, sizeof opened_name) >= sizeof opened_name)
		return 1;

	*file = opened_name + len + 1;

	return 0;
}

static int
strategy(void *devdata, int rw, daddr32_t blk, size_t size, void *buf,
    size_t *rsize)
{
	struct of_dev *dev = devdata;
	u_quad_t pos;
	int n;

	if (rw != F_READ)
		return EPERM;
	if (dev->type != OFDEV_DISK)
		panic("strategy");

	pos = (u_quad_t)(blk + dev->partoff) * dev->bsize;

	for (;;) {
		if (OF_seek(dev->handle, pos) < 0)
			break;
		n = OF_read(dev->handle, buf, size);
		if (n == -2)
			continue;
		if (n < 0)
			break;
		*rsize = n;
		return 0;
	}
	return EIO;
}

static int
devclose(struct open_file *of)
{
	struct of_dev *op = of->f_devdata;

	if (op->type == OFDEV_NET)
		net_close(op);
	if (op->dmabuf)
		OF_call_method("dma-free", op->handle, 2, 0,
		    op->dmabuf, MAXBSIZE);

	OF_close(op->handle);
	free(op, sizeof *op);
}

struct devsw devsw[1] = {
	"OpenFirmware",
	strategy,
	(int (*)(struct open_file *, ...))nodev,
	devclose,
	noioctl
};
int ndevs = sizeof devsw / sizeof devsw[0];

static struct fs_ops file_system_ufs = {
	ufs_open, ufs_close, ufs_read, ufs_write, ufs_seek, ufs_stat,
	ufs_readdir
};
static struct fs_ops file_system_cd9660 = {
	cd9660_open, cd9660_close, cd9660_read, cd9660_write, cd9660_seek,
	cd9660_stat, cd9660_readdir
};
static struct fs_ops file_system_hfs = {
	hfs_open, hfs_close, hfs_read, hfs_write, hfs_seek, hfs_stat,
	hfs_readdir
};
static struct fs_ops file_system_nfs = {
	nfs_open, nfs_close, nfs_read, nfs_write, nfs_seek, nfs_stat,
	nfs_readdir
};

struct fs_ops file_system[3];
int nfsys;

static u_long
get_long(p)
	const void *p;
{
	const unsigned char *cp = p;

	return cp[0] | (cp[1] << 8) | (cp[2] << 16) | (cp[3] << 24);
}

int
read_mac_label(struct of_dev *devp, char *buf, struct disklabel *lp)
{
	struct part_map_entry *part;
	size_t read;
	int part_cnt;
	int i;
	char *s;

	if ((strategy(devp, F_READ, 1, DEV_BSIZE, buf, &read) != 0) ||
	    (read != DEV_BSIZE))
		return ERDLAB;

	part = (struct part_map_entry *)buf;

	/* if first partition is not valid, assume not HFS/DPME partitioned */
	if (part->pmSig != PART_ENTRY_MAGIC)
		return ERDLAB;

	part_cnt = part->pmMapBlkCnt;

	/* first search for "OpenBSD" partition type
	 * standard bsd disklabel lives inside at offset 0
	 * otherwise, we should fake a bsd partition
	 * with first HFS partition starting at 'i'
	 * ? will this cause problems with booting bsd.rd from hfs
	 */
	for (i = 0; i < part_cnt; i++) {
		/* read the appropriate block */
		if ((strategy(devp, F_READ, 1+i, DEV_BSIZE, buf, &read) != 0)
		   || (read != DEV_BSIZE))
			return ERDLAB;

		part = (struct part_map_entry *)buf;
		/* toupper the string, in case caps are different... */
		for (s = part->pmPartType; *s; s++)
			if ((*s >= 'a') && (*s <= 'z'))
				*s = (*s - 'a' + 'A');

		if (0 == strcmp(part->pmPartType, PART_TYPE_OPENBSD)) {
			/* FOUND OUR PARTITION!!! */
			if(strategy(devp, F_READ, part->pmPyPartStart,
				DEV_BSIZE, buf, &read) == 0
				&& read == DEV_BSIZE)
			{
				if (!getdisklabel(buf, lp))
					return 0;

				/* If we have an OpenBSD region
				 * but no valid parition table,
				 * we cannot load a kernel from
				 * it, punt.
				 * should not have more than one
				 * OpenBSD of DPME type.
				 */
				return ERDLAB;
			}
		}
	}
	return ERDLAB;
}

/*
 * Find a valid disklabel.
 */
static int
search_label(devp, off, buf, lp, off0)
	struct of_dev *devp;
	u_long off;
	char *buf;
	struct disklabel *lp;
	u_long off0;
{
	size_t read;
	struct dos_partition *p;
	int i;
	u_long poff;
	static int recursion;

	if (strategy(devp, F_READ, off, DEV_BSIZE, buf, &read) ||
	    read != DEV_BSIZE)
		return ERDLAB;

	if (buf[510] != 0x55 || buf[511] != 0xaa)
		return ERDLAB;

	if (recursion++ <= 1)
		off0 += off;
	for (p = (struct dos_partition *)(buf + DOSPARTOFF), i = 4;
	    --i >= 0; p++) {
		if (p->dp_typ == DOSPTYP_OPENBSD) {
			poff = get_long(&p->dp_start) + off0;
			if (strategy(devp, F_READ, poff + LABELSECTOR,
			    DEV_BSIZE, buf, &read) == 0
			    && read == DEV_BSIZE) {
				if (!getdisklabel(buf, lp)) {
					recursion--;
					return 0;
				}
			}
			if (strategy(devp, F_READ, off, DEV_BSIZE, buf, &read)
			    || read != DEV_BSIZE) {
				recursion--;
				return ERDLAB;
			}
		} else if (p->dp_typ == DOSPTYP_EXTEND) {
			poff = get_long(&p->dp_start);
			if (!search_label(devp, poff, buf, lp, off0)) {
				recursion--;
				return 0;
			}
			if (strategy(devp, F_READ, off, DEV_BSIZE, buf, &read)
			    || read != DEV_BSIZE) {
				recursion--;
				return ERDLAB;
			}
		}
	}
	recursion--;
	return ERDLAB;
}

int
devopen(struct open_file *of, const char *name, char **file)
{
	struct of_dev *ofdev;
	char fname[256];
	char buf[DEV_BSIZE];
	struct disklabel label;
	int handle, part;
	size_t read;
	int error = 0;

	if (of->f_flags != F_READ)
		return EPERM;

	strlcpy(fname, name, sizeof fname);
	if (parsename(fname, file))
		return ENOENT;

	if ((handle = OF_finddevice(fname)) == -1)
		return ENOENT;
	if (OF_getprop(handle, "name", buf, sizeof buf) < 0)
		return ENXIO;
	if (OF_getprop(handle, "device_type", buf, sizeof buf) < 0)
		return ENXIO;
	if (!strcmp(buf, "block"))
		/*
		 * For block devices, indicate raw partition
		 * (:0 in OpenFirmware)
		 */
		strlcat(fname, ":0", sizeof fname);
	if ((ofdev = alloc(sizeof *ofdev)) == NULL)
		return ENOMEM;
	bzero(ofdev, sizeof *ofdev);

	if ((handle = OF_open(fname)) == -1) {
		free(ofdev, sizeof *ofdev);
		return ENXIO;
	}

	ofdev->handle = handle;
	ofdev->dmabuf = NULL;
	OF_call_method("dma-alloc", handle, 1, 1, MAXBSIZE, &ofdev->dmabuf);
	if (!strcmp(buf, "block")) {
		ofdev->type = OFDEV_DISK;
		ofdev->bsize = DEV_BSIZE;
		/* First try to find a disklabel without MBR partitions */
		if (strategy(ofdev, F_READ,
		    LABELSECTOR, DEV_BSIZE, buf, &read) != 0 ||
		    read != DEV_BSIZE ||
		    getdisklabel(buf, &label)) {
			/* Else try MBR partitions */
			error = read_mac_label(ofdev, buf, &label);
			if (error == ERDLAB)
				error = search_label(ofdev, 0, buf, &label, 0);

			if (error && error != ERDLAB)
				goto bad;
		}

		if (error == ERDLAB) {
			/* No label, just use complete disk */
			ofdev->partoff = 0;
		} else {
			part = 0; /* how to pass this parameter */
			ofdev->partoff = label.d_partitions[part].p_offset;
		}

		of->f_dev = devsw;
		of->f_devdata = ofdev;
		bcopy(&file_system_ufs, file_system, sizeof file_system[0]);
		bcopy(&file_system_cd9660, file_system + 1,
		    sizeof file_system[0]);
		bcopy(&file_system_hfs, file_system + 2,
		    sizeof file_system[0]);
		nfsys = 3;
		return 0;
	}
	if (!strcmp(buf, "network")) {
		ofdev->type = OFDEV_NET;
		of->f_dev = devsw;
		of->f_devdata = ofdev;
		bcopy(&file_system_nfs, file_system, sizeof file_system[0]);
		nfsys = 1;
		if (error = net_open(ofdev))
			goto bad;
		return 0;
	}
	error = EFTYPE;
bad:
	OF_close(handle);
	free(ofdev, sizeof *ofdev);
	return error;
}
@


1.21
log
@Allow for multiple concurrent devopen() calls, and fill the .readdir member
of fs_ops; makes the `ls' command finally work in the boot loader.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.20 2013/03/21 21:57:15 deraadt Exp $	*/
d371 1
a371 1
		of->f_devdata = &ofdev;
@


1.20
log
@Use MAXBSIZE for block io limit (same value, but MAXPHYS is strictly a
kernel concept)
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.19 2011/11/19 16:11:55 mpi Exp $	*/
d128 1
a128 1
	op->handle = -1;
d141 2
a142 1
	ufs_open, ufs_close, ufs_read, ufs_write, ufs_seek, ufs_stat
d146 1
a146 1
	    cd9660_stat
d149 2
a150 1
	hfs_open, hfs_close, hfs_read, hfs_write, hfs_seek, hfs_stat
d153 2
a154 1
	nfs_open, nfs_close, nfs_read, nfs_write, nfs_seek, nfs_stat
a159 4
static struct of_dev ofdev = {
	-1,
};

d294 1
a301 2
	if (ofdev.handle != -1)
		panic("devopen");
d321 6
a326 1
	if ((handle = OF_open(fname)) == -1)
d328 5
a332 4
	bzero(&ofdev, sizeof ofdev);
	ofdev.handle = handle;
	ofdev.dmabuf = NULL;
	OF_call_method("dma-alloc", handle, 1, 1, MAXBSIZE, &ofdev.dmabuf);
d334 2
a335 2
		ofdev.type = OFDEV_DISK;
		ofdev.bsize = DEV_BSIZE;
d337 1
a337 1
		if (strategy(&ofdev, F_READ,
d342 1
a342 1
			error = read_mac_label(&ofdev, buf, &label);
d344 1
a344 1
				error = search_label(&ofdev, 0, buf, &label, 0);
d352 1
a352 1
			ofdev.partoff = 0;
d355 1
a355 1
			ofdev.partoff = label.d_partitions[part].p_offset;
d359 1
a359 1
		of->f_devdata = &ofdev;
d369 1
a369 1
		ofdev.type = OFDEV_NET;
d374 1
a374 1
		if (error = net_open(&ofdev))
d381 1
a381 1
	ofdev.handle = -1;
@


1.19
log
@Rewrite the parsing of arguments given to the ofwboot and restore the
possibility to boot a kernel from an HFS partition when there is no
OpenBSD partition on the disk.

Problem reported by cbsoleil at gmail.com and analysed by otto@@.

Tested by otto@@, krw@@ and drahn@@

ok krw@@, drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.18 2011/04/10 09:58:19 miod Exp $	*/
d125 1
a125 1
		    op->dmabuf, MAXPHYS);
d328 1
a328 1
	OF_call_method("dma-alloc", handle, 1, 1, MAXPHYS, &ofdev.dmabuf);
@


1.18
log
@Include <libkern.h> to get proper strrchr() prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.17 2011/03/13 00:13:53 deraadt Exp $	*/
d52 2
d58 2
a59 3
char namebuf[256];
static char *
filename(char *str)
d62 2
a63 1
	char savec;
d67 14
a80 1
		return NULL;
d82 3
a84 4
	savec = *cp;
	*cp = 0;
	strlcpy(namebuf, cp+1, sizeof namebuf);
	return namebuf;
a160 2
char opened_name[256];

a294 1
	char *cp;
d308 1
a308 2
	cp = filename(fname);
	if (cp == NULL)
a309 9
	strlcpy(buf, cp, sizeof buf);
	strlcpy(opened_name, fname, sizeof opened_name);

	strlcat(opened_name, ":", sizeof opened_name);
	if (*buf != '/')
		strlcat(opened_name, "/", sizeof opened_name);

	strlcat(opened_name, buf, sizeof opened_name);
	*file = opened_name + strlen(fname) + 1;
@


1.17
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.16 2010/05/14 19:32:39 drahn Exp $	*/
d38 1
@


1.16
log
@Be friendly with gcc4.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.15 2008/05/25 16:55:31 miod Exp $	*/
d73 1
a73 1
strategy(void *devdata, int rw, daddr_t blk, size_t size, void *buf,
@


1.15
log
@Don't forget to actually return a value in ttyname(), and fix a bunch of
warnings while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.14 2007/06/14 03:27:16 drahn Exp $	*/
d116 1
a116 1
static struct devsw devsw[1] = {
@


1.14
log
@boot code does not do daddr64_t yet. 'unchange that' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.13 2007/06/13 02:17:32 drahn Exp $	*/
d59 1
a59 1
	char *cp, *lp;
a60 1
	int dhandle;
a160 2
	struct buf *bp;
	int err;
a283 1
	char devname[256];
@


1.13
log
@Switch macppc to the interactive bootloader in stand/boot.
Much more useable on serial console systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.12 2007/06/06 17:15:12 deraadt Exp $	*/
d74 1
a74 1
strategy(void *devdata, int rw, daddr64_t blk, size_t size, void *buf,
@


1.12
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.11 2007/06/02 15:28:09 deraadt Exp $	*/
d51 5
d57 1
a57 1
filename(char *str, char *ppart)
a61 1
	char devtype[16];
d63 8
a70 39
	lp = str;
	devtype[0] = 0;
	*ppart = 0;
	for (cp = str; *cp; lp = cp) {
		/* For each component of the path name... */
		while (*++cp && *cp != '/')
			;
		savec = *cp;
		*cp = 0;
		/* ...look whether there is a device with this name */
		dhandle = OF_finddevice(str);
		*cp = savec;
		if (dhandle == -1) {
			/*
			 * if not, lp is the delimiter between device and path
			 */

			/* if the last component was a block device... */
			if (!strcmp(devtype, "block")) {
				/* search for arguments */
				for (cp = lp;
				    --cp >= str && *cp != '/' && *cp != ':';)
					;
				if (cp >= str && *cp == ':') {
					/* found arguments */
					for (cp = lp;
					    *--cp != ':' && *cp != ',';)
						;
					if (*++cp >= 'a' &&
					    *cp <= 'a' + MAXPARTITIONS)
						*ppart = *cp;
				}
			}
			return lp;
		} else if (OF_getprop(dhandle, "device_type", devtype,
		    sizeof devtype) < 0)
			devtype[0] = 0;
	}
	return 0;
a200 1
			printf("found OpenBSD DPME partition\n");
a285 1
	char partition;
d287 1
d298 1
d300 4
a303 9
	cp = filename(fname, &partition);
	if (cp) {
		strlcpy(buf, cp, sizeof buf);
		*cp = 0;
	}
	if (!cp || !*buf)
		strlcpy(buf, DEFAULT_KERNEL, sizeof buf);
	if (!*fname)
		strlcpy(fname, bootdev, sizeof fname);
d305 2
a306 6
	if (partition) {
		cp = opened_name + strlen(opened_name);
		*cp++ = ':';
		*cp++ = partition;
		*cp = 0;
	}
d309 1
d312 1
a348 6
			if (partition)
				/*
				 * User specified a partition,
				 * but there is none
				 */
				goto bad;
d352 1
a352 1
			part = partition ? partition - 'a' : 0;
@


1.11
log
@oops, why did i delete this.  bizzare
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.9 2006/10/12 12:14:17 krw Exp $	*/
d101 1
a101 1
strategy(void *devdata, int rw, daddr_t blk, size_t size, void *buf,
@


1.10
log
@stand/ofdev.h
@
text
@@


1.9
log
@Don't try to boot from a NetBSD MBR partition when no OpenBSD MBR
partition is found. Change error message to 'no OpenBSD partition'.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.8 2003/10/16 04:30:09 drahn Exp $	*/
@


1.8
log
@There is no end to the ANSI/KNF journey.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.8 2003/10/16 04:26:36 drahn Exp $	*/
d278 1
a278 2
		if (p->dp_typ == DOSPTYP_OPENBSD ||
		    p->dp_typ == DOSPTYP_NETBSD) {
@


1.7
log
@strcat/strcpy/sprintf cleanup. krw@@, anil@@ ok. art@@ tested sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.6 2002/09/15 09:01:59 deraadt Exp $	*/
d52 1
a52 3
filename(str, ppart)
	char *str;
	char *ppart;
d101 2
a102 7
strategy(devdata, rw, blk, size, buf, rsize)
	void *devdata;
	int rw;
	daddr_t blk;
	size_t size;
	void *buf;
	size_t *rsize;
d130 1
a130 2
devclose(of)
	struct open_file *of;
d136 1
a136 1
	if (op->dmabuf) {
d138 2
a139 2
			op->dmabuf, MAXPHYS);
	}
d186 1
a186 4
read_mac_label(devp, buf, lp)
	struct of_dev *devp;
	char *buf;
	struct disklabel *lp;
d196 2
a197 3
	if ((strategy(devp, F_READ, 1, DEV_BSIZE, buf, &read) != 0)
	   || (read != DEV_BSIZE))
	{
d199 1
a199 1
	}
d203 1
a203 1
	if (part->pmSig != PART_ENTRY_MAGIC) {
d205 1
a205 1
	}
a217 1
		{
d219 1
a219 1
		}
d225 1
d233 1
a233 1
				if (!getdisklabel(buf, lp)) {
d235 1
a235 1
				}
a243 1

a244 1

d248 1
a249 1
}
d267 2
a268 2
	if (strategy(devp, F_READ, off, DEV_BSIZE, buf, &read)
	    || read != DEV_BSIZE)
d277 1
a277 1
	     --i >= 0; p++) {
d282 1
a282 1
				     DEV_BSIZE, buf, &read) == 0
d312 1
a312 4
devopen(of, name, file)
	struct open_file *of;
	const char *name;
	char **file;
d371 3
a373 3
			     LABELSECTOR, DEV_BSIZE, buf, &read) != 0
		    || read != DEV_BSIZE
		    || getdisklabel(buf, &label)) {
d376 1
a376 1
			if (error == ERDLAB) {
d378 1
a378 1
			}
d385 4
a388 1
				/* User specified a partition, but there is none */
d390 1
a390 1
			/* No, label, just use complete disk */
@


1.6
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.4 2002/09/06 01:17:12 drahn Exp $	*/
d344 1
a344 1
	strcpy(fname, name);
d347 1
a347 1
		strcpy(buf, cp);
d351 1
a351 1
		strcpy(buf, DEFAULT_KERNEL);
d353 2
a354 2
		strcpy(fname, bootdev);
	strcpy(opened_name, fname);
d362 2
a363 2
		strcat(opened_name, "/");
	strcat(opened_name, buf);
d376 1
a376 1
		strcat(fname, ":0");
@


1.5
log
@KNF
@
text
@d207 3
a209 2
	if (strategy(devp, F_READ, 1, DEV_BSIZE, buf, &read) != 0 ||
	    read != DEV_BSIZE) {
d228 3
a230 2
		if (strategy(devp, F_READ, 1+i, DEV_BSIZE, buf, &read) != 0 ||
		    read != DEV_BSIZE) {
d241 4
a244 3
			if (strategy(devp, F_READ, part->pmPyPartStart,
			    DEV_BSIZE, buf, &read) == 0 &&
			    read == DEV_BSIZE) {
d281 2
a282 2
	if (strategy(devp, F_READ, off, DEV_BSIZE, buf, &read) ||
	    read != DEV_BSIZE)
d291 1
a291 1
	    --i >= 0; p++) {
d296 2
a297 2
			    DEV_BSIZE, buf, &read) == 0 &&
			    read == DEV_BSIZE) {
d303 2
a304 2
			if (strategy(devp, F_READ, off, DEV_BSIZE, buf, &read) ||
			    read != DEV_BSIZE) {
d314 2
a315 2
			if (strategy(devp, F_READ, off, DEV_BSIZE, buf, &read) ||
			    read != DEV_BSIZE) {
d388 3
a390 3
		    LABELSECTOR, DEV_BSIZE, buf, &read) != 0 ||
		    read != DEV_BSIZE ||
		    getdisklabel(buf, &label)) {
@


1.4
log
@KNF, get this out of my tree finally.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.3 2002/07/23 21:04:26 drahn Exp $	*/
d207 2
a208 3
	if ((strategy(devp, F_READ, 1, DEV_BSIZE, buf, &read) != 0)
	   || (read != DEV_BSIZE))
	{
d227 2
a228 3
		if ((strategy(devp, F_READ, 1+i, DEV_BSIZE, buf, &read) != 0)
		   || (read != DEV_BSIZE))
		{
d239 3
a241 4
			if(strategy(devp, F_READ, part->pmPyPartStart,
				DEV_BSIZE, buf, &read) == 0
				&& read == DEV_BSIZE)
			{
d278 2
a279 2
	if (strategy(devp, F_READ, off, DEV_BSIZE, buf, &read)
	    || read != DEV_BSIZE)
d288 1
a288 1
	     --i >= 0; p++) {
d293 2
a294 2
				     DEV_BSIZE, buf, &read) == 0
			    && read == DEV_BSIZE) {
d300 2
a301 2
			if (strategy(devp, F_READ, off, DEV_BSIZE, buf, &read)
			    || read != DEV_BSIZE) {
d311 2
a312 2
			if (strategy(devp, F_READ, off, DEV_BSIZE, buf, &read)
			    || read != DEV_BSIZE) {
d385 3
a387 3
			     LABELSECTOR, DEV_BSIZE, buf, &read) != 0
		    || read != DEV_BSIZE
		    || getdisklabel(buf, &label)) {
@


1.3
log
@Allow 'boot hd:,ofwboot bsd' previously it required '/bsd' instead of
just 'bsd'.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.2 2002/03/14 01:26:37 millert Exp $	*/
d60 1
a60 1
	
d66 2
a67 1
		while (*++cp && *cp != '/');
d74 4
a77 1
			/* if not, lp is the delimiter between device and path */
d82 2
a83 1
				     --cp >= str && *cp != '/' && *cp != ':';);
d85 6
a90 4
					/* found arguments, make firmware ignore them */
					*cp = 0;
					for (cp = lp; *--cp && *cp != ',';);
					if (*++cp >= 'a' && *cp <= 'a' + MAXPARTITIONS)
d95 2
a96 1
		} else if (OF_getprop(dhandle, "device_type", devtype, sizeof devtype) < 0)
d114 1
a114 1
	
d119 1
a119 1
	
d121 1
a121 1
	
d141 1
a141 1
	
d189 1
a189 1
	
d280 1
a280 1
	
d284 1
a284 1
	
d372 4
a375 1
		/* For block devices, indicate raw partition (:0 in OpenFirmware) */
d410 1
a410 1
		
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.1 2001/09/01 15:39:02 drahn Exp $	*/
a352 1
#if 0
a354 1
#endif
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/stand to macppc/stand
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.8 2001/03/14 08:11:25 drahn Exp $	*/
d147 1
a147 1
	(int (*)__P((struct open_file *, ...)))nodev,
@


1.1.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.1 2001/09/01 15:39:02 drahn Exp $	*/
d147 1
a147 1
	(int (*)(struct open_file *, ...))nodev,
@


1.1.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.1.6.1 2002/06/11 03:36:34 art Exp $	*/
d60 1
a60 1

d66 1
a66 2
		while (*++cp && *cp != '/')
			;
d73 1
a73 4
			/*
			 * if not, lp is the delimiter between device and path
			 */

d78 1
a78 2
				    --cp >= str && *cp != '/' && *cp != ':';)
					;
d80 4
a83 6
					/* found arguments */
					for (cp = lp;
					    *--cp != ':' && *cp != ',';)
						;
					if (*++cp >= 'a' &&
					    *cp <= 'a' + MAXPARTITIONS)
d88 1
a88 2
		} else if (OF_getprop(dhandle, "device_type", devtype,
		    sizeof devtype) < 0)
d106 1
a106 1

d111 1
a111 1

d113 1
a113 1

d133 1
a133 1

d181 1
a181 1

d272 1
a272 1

d276 1
a276 1

d353 1
d356 1
d366 1
a366 4
		/*
		 * For block devices, indicate raw partition
		 * (:0 in OpenFirmware)
		 */
d401 1
a401 1

@


1.1.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d344 1
a344 1
	strlcpy(fname, name, sizeof fname);
d347 1
a347 1
		strlcpy(buf, cp, sizeof buf);
d351 1
a351 1
		strlcpy(buf, DEFAULT_KERNEL, sizeof buf);
d353 2
a354 2
		strlcpy(fname, bootdev, sizeof fname);
	strlcpy(opened_name, fname, sizeof opened_name);
d362 2
a363 2
		strlcat(opened_name, "/", sizeof opened_name);
	strlcat(opened_name, buf, sizeof opened_name);
d376 1
a376 1
		strlcat(fname, ":0", sizeof fname);
@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.4.2
log
@Merge in -current from about a week ago
@
text
@d147 1
a147 1
	(int (*)(struct open_file *, ...))nodev,
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@d60 1
a60 1

d66 1
a66 2
		while (*++cp && *cp != '/')
			;
d73 1
a73 4
			/*
			 * if not, lp is the delimiter between device and path
			 */

d78 1
a78 2
				    --cp >= str && *cp != '/' && *cp != ':';)
					;
d80 4
a83 6
					/* found arguments */
					for (cp = lp;
					    *--cp != ':' && *cp != ',';)
						;
					if (*++cp >= 'a' &&
					    *cp <= 'a' + MAXPARTITIONS)
d88 1
a88 2
		} else if (OF_getprop(dhandle, "device_type", devtype,
		    sizeof devtype) < 0)
d106 1
a106 1

d111 1
a111 1

d113 1
a113 1

d133 1
a133 1

d181 1
a181 1

d272 1
a272 1

d276 1
a276 1

d353 1
d356 1
d366 1
a366 4
		/*
		 * For block devices, indicate raw partition
		 * (:0 in OpenFirmware)
		 */
d401 1
a401 1

@


1.1.4.4
log
@Sync the SMP branch to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofdev.c,v 1.1.4.3 2003/03/27 23:29:46 niklas Exp $	*/
d344 1
a344 1
	strlcpy(fname, name, sizeof fname);
d347 1
a347 1
		strlcpy(buf, cp, sizeof buf);
d351 1
a351 1
		strlcpy(buf, DEFAULT_KERNEL, sizeof buf);
d353 2
a354 2
		strlcpy(fname, bootdev, sizeof fname);
	strlcpy(opened_name, fname, sizeof opened_name);
d362 2
a363 2
		strlcat(opened_name, "/", sizeof opened_name);
	strlcat(opened_name, buf, sizeof opened_name);
d376 1
a376 1
		strlcat(fname, ":0", sizeof fname);
@


1.1.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 3
a54 1
filename(char *str, char *ppart)
d103 7
a109 2
strategy(void *devdata, int rw, daddr_t blk, size_t size, void *buf,
    size_t *rsize)
d137 2
a138 1
devclose(struct open_file *of)
d144 1
a144 1
	if (op->dmabuf)
d146 2
a147 2
		    op->dmabuf, MAXPHYS);

d194 4
a197 1
read_mac_label(struct of_dev *devp, char *buf, struct disklabel *lp)
d207 3
a209 2
	if ((strategy(devp, F_READ, 1, DEV_BSIZE, buf, &read) != 0) ||
	    (read != DEV_BSIZE))
d211 1
a211 1

d215 1
a215 1
	if (part->pmSig != PART_ENTRY_MAGIC)
d217 1
a217 1

d230 1
d232 1
a232 1

a237 1

d245 1
a245 1
				if (!getdisklabel(buf, lp))
d247 1
a247 1

d256 1
d258 1
d262 1
a263 1

d281 2
a282 2
	if (strategy(devp, F_READ, off, DEV_BSIZE, buf, &read) ||
	    read != DEV_BSIZE)
d291 1
a291 1
	    --i >= 0; p++) {
d296 1
a296 1
			    DEV_BSIZE, buf, &read) == 0
d326 4
a329 1
devopen(struct open_file *of, const char *name, char **file)
d388 3
a390 3
		    LABELSECTOR, DEV_BSIZE, buf, &read) != 0 ||
		    read != DEV_BSIZE ||
		    getdisklabel(buf, &label)) {
d393 1
a393 1
			if (error == ERDLAB)
d395 1
a395 1

d402 1
a402 4
				/*
				 * User specified a partition,
				 * but there is none
				 */
d404 1
a404 1
			/* No label, just use complete disk */
@


