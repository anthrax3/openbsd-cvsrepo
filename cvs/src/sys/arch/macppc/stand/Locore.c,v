head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.14
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.10
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.6
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.8
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.26
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.22
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.20
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.18
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.16
	OPENBSD_5_0:1.15.0.14
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.12
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.10
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.6
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.8
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.9.0.12
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.10
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.7
	UBC:1.3.0.6
	UBC_BASE:1.3
	SMP:1.3.0.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.16
date	2014.07.12.21.54.58;	author jasper;	state Exp;
branches;
next	1.15;
commitid	3HeD4LaLGiS22I3y;

1.15
date	2008.05.25.16.55.31;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.23.16.37.57;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.23.18.51.45;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.13.02.17.32;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.05.20.30.26;	author gwk;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.10.20.21.10;	author mbalmer;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.09.16.50.30;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.16.04.30.09;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.15.09.01.59;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.15.02.02.44;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.37;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.01.22.44.26;	author drahn;	state Exp;
branches
	1.3.4.1
	1.3.6.1;
next	1.2;

1.2
date	2001.09.05.22.32.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.01.15.39.02;	author drahn;	state Exp;
branches;
next	;

1.3.4.1
date	2001.10.31.03.01.16;	author nate;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.03.28.10.36.02;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2004.02.19.10.49.04;	author niklas;	state Exp;
branches;
next	;

1.3.6.1
date	2002.06.11.03.36.34;	author art;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2002.10.29.00.28.06;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@move getchar() into libsa where applicable

ok miod@@
@
text
@/*	$OpenBSD: Locore.c,v 1.15 2008/05/25 16:55:31 miod Exp $	*/
/*	$NetBSD: Locore.c,v 1.1 1997/04/16 20:29:11 thorpej Exp $	*/

/*
 * Copyright (C) 1995, 1996 Wolfgang Solfrank.
 * Copyright (C) 1995, 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <lib/libsa/stand.h>
#include <macppc/stand/openfirm.h>
#include <dev/cons.h>   
     

/*
#include "machine/cpu.h"
*/

#define ENABLE_DECREMENTER_WORKAROUND
void patch_dec_intr();

static int (*openfirmware)(void *);

static void setup(void);

asm (".text; .globl _entry; _entry: .long _start,0,0");
asm("   .text			\n"
"	.globl	bat_init	\n"
"bat_init:			\n"
"				\n"
"	mfmsr   8		\n"
"	li      0,0		\n"
"	mtmsr   0		\n"
"	isync			\n"
"				\n"
"	mtibatu 0,0		\n"	
"	mtibatu 1,0		\n"
"	mtibatu 2,0		\n"
"	mtibatu 3,0		\n"
"	mtdbatu 0,0		\n"
"	mtdbatu 1,0		\n"
"	mtdbatu 2,0		\n"
"	mtdbatu 3,0		\n"
"				\n"
"	li      9,0x12         	\n"	 /* BATL(0, BAT_M, BAT_PP_RW) */	
"	mtibatl 0,9		\n"
"	mtdbatl 0,9		\n"
"	li      9,0x1ffe        \n"	/* BATU(0, BAT_BL_256M, BAT_Vs) */
"	mtibatu 0,9		\n"
"	mtdbatu 0,9		\n"
"	isync			\n"
"				\n"
"	mtmsr 8  		\n"
"	isync			\n"
"	blr			\n");

#ifdef XCOFF_GLUE
static int stack[8192/4 + 4] __attribute__((__used__));
#endif

__dead void
_start(void *vpd, int res, int (*openfirm)(void *), char *arg, int argl)
{
	extern char etext[];

#ifdef XCOFF_GLUE
	asm(
	"sync			\n"
	"isync			\n"
	"lis	%r1,stack@@ha	\n"
	"addi	%r1,%r1,stack@@l	\n"
	"addi	%r1,%r1,8192	\n");
#endif
	syncicache((void *)RELOC, etext - (char *)RELOC);

	bat_init();
	openfirmware = openfirm;	/* Save entry to Open Firmware */
#ifdef ENABLE_DECREMENTER_WORKAROUND
	patch_dec_intr();
#endif
	setup();
	main(arg, argl);
	exit();
}

#ifdef ENABLE_DECREMENTER_WORKAROUND
void handle_decr_intr();
__asm (	"	.globl handle_decr_intr\n"
	"	.type handle_decr_intr@@function\n"
	"handle_decr_intr:\n"
	"	rfi\n");

void
patch_dec_intr()
{
	int time;
	unsigned int *decr_intr = (unsigned int *)0x900;
	unsigned int br_instr;

	/* this hack is to prevent unexpected Decrementer Exceptions
	 * when Apple openfirmware enables interrupts
	 */
	time = 0x40000000;
	asm("mtdec %0" :: "r"(time));

	/* we assume that handle_decr_intr is in the first 128 Meg */
	br_instr = (18 << 23) | (unsigned int)handle_decr_intr;
	*decr_intr = br_instr;
}
#endif

__dead void
_rtt()
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
	} args = {
		"exit",
		0,
		0
	};

	openfirmware(&args);
	while (1);			/* just in case */
}

int
OF_finddevice(char *name)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		char *device;
		int phandle;
	} args = {
		"finddevice",
		1,
		1,
	};

	args.device = name;
	if (openfirmware(&args) == -1)
		return -1;
	return args.phandle;
}

int
OF_instance_to_package(int ihandle)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int ihandle;
		int phandle;
	} args = {
		"instance-to-package",
		1,
		1,
	};

	args.ihandle = ihandle;
	if (openfirmware(&args) == -1)
		return -1;
	return args.phandle;
}

int
OF_getprop(int handle, char *prop, void *buf, int buflen)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int phandle;
		char *prop;
		void *buf;
		int buflen;
		int size;
	} args = {
		"getprop",
		4,
		1,
	};

	args.phandle = handle;
	args.prop = prop;
	args.buf = buf;
	args.buflen = buflen;
	if (openfirmware(&args) == -1)
		return -1;
	return args.size;
}

int
OF_open(char *dname)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		char *dname;
		int handle;
	} args = {
		"open",
		1,
		1,
	};

	args.dname = dname;
	if (openfirmware(&args) == -1)
		return -1;
	return args.handle;
}

void
OF_close(int handle)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int handle;
	} args = {
		"close",
		1,
		0,
	};

	args.handle = handle;
	openfirmware(&args);
}

int
OF_write(int handle, void *addr, int len)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int ihandle;
		void *addr;
		int len;
		int actual;
	} args = {
		"write",
		3,
		1,
	};

	args.ihandle = handle;
	args.addr = addr;
	args.len = len;
	if (openfirmware(&args) == -1)
		return -1;
	return args.actual;
}

int
OF_read(int handle, void *addr, int len)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int ihandle;
		void *addr;
		int len;
		int actual;
	} args = {
		"read",
		3,
		1,
	};

	args.ihandle = handle;
	args.addr = addr;
	args.len = len;
	if (openfirmware(&args) == -1)
		return -1;
	return args.actual;
}

int
OF_seek(int handle, u_quad_t pos)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int handle;
		int poshi;
		int poslo;
		int status;
	} args = {
		"seek",
		3,
		1,
	};

	args.handle = handle;
	args.poshi = (int)(pos >> 32);
	args.poslo = (int)pos;
	if (openfirmware(&args) == -1)
		return -1;
	return args.status;
}

void *
OF_claim(void *virt, u_int size, u_int align)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		void *virt;
		u_int size;
		u_int align;
		void *baseaddr;
	} args = {
		"claim",
		3,
		1,
	};

	args.virt = virt;
	args.size = size;
	args.align = align;
	if (openfirmware(&args) == -1)
		return (void *)-1;
	if (virt != 0)
		return virt;
	return args.baseaddr;
}

void
OF_release(void *virt, u_int size)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		void *virt;
		u_int size;
	} args = {
		"release",
		2,
		0,
	};

	args.virt = virt;
	args.size = size;
	openfirmware(&args);
}

int
OF_milliseconds()
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int ms;
	} args = {
		"milliseconds",
		0,
		1,
	};

	openfirmware(&args);
	return args.ms;
}

#ifdef __notyet__
void
OF_chain(void *virt, u_int size, void (*entry)(), void *arg, u_int len)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		void *virt;
		u_int size;
		void (*entry)();
		void *arg;
		u_int len;
	} args = {
		"chain",
		5,
		0,
	};

	args.virt = virt;
	args.size = size;
	args.entry = entry;
	args.arg = arg;
	args.len = len;
	openfirmware(&args);
}
#else
void
OF_chain(void *virt, u_int size, void (*entry)(), void *arg, u_int len)
{
	/*
	 * This is a REALLY dirty hack till the firmware gets this going
	OF_release(virt, size);
	 */
	entry(0, 0, openfirmware, arg, len);
}
#endif

int
OF_call_method(char *method, int ihandle, int nargs, int nreturns, ...)
{
	va_list ap;
	static struct {
		char *name;
		int nargs;
		int nreturns;
		char *method;
		int ihandle;
		int args_n_results[12];
	} args = {
		"call-method",
		2,
		1,
	};
	int *ip, n;

	if (nargs > 6)
		return -1;
	args.nargs = nargs + 2;
	args.nreturns = nreturns + 1;
	args.method = method;
	args.ihandle = ihandle;
	va_start(ap, nreturns);
	for (ip = args.args_n_results + (n = nargs); --n >= 0;)
		*--ip = va_arg(ap, int);

	if (openfirmware(&args) == -1) {
		va_end(ap);
		return -1;
	}
	if (args.args_n_results[nargs]) {
		va_end(ap);
		return args.args_n_results[nargs];
	}
	for (ip = args.args_n_results + nargs + (n = args.nreturns); --n > 0;)
		*va_arg(ap, int *) = *--ip;
	va_end(ap);
	return 0;
}

static int stdin;
static int stdout;

static void
setup()
{
	int chosen;

	if ((chosen = OF_finddevice("/chosen")) == -1)
		_rtt();
	if (OF_getprop(chosen, "stdin", &stdin, sizeof(stdin)) != sizeof(stdin)
	    || OF_getprop(chosen, "stdout", &stdout, sizeof(stdout)) !=
	    sizeof(stdout))
		_rtt();
	if (stdout == 0) {
		/* screen should be console, but it is not open */
		stdout = OF_open("screen");
	}
}

void
putchar(int c)
{
	char ch = c;
	if (c == '\177') {
		ch = '\b';
		OF_write(stdout, &ch, 1);
		ch = ' ';
		OF_write(stdout, &ch, 1);
		ch = '\b';
	}
	if (c == '\n')
		putchar('\r');
	OF_write(stdout, &ch, 1);
}

void
ofc_probe(struct consdev *cn)
{
	cn->cn_pri = CN_LOWPRI;
	cn->cn_dev = makedev(0,0); /* WTF */
}


void
ofc_init(struct consdev *cn)
{
}

char buffered_char;
int
ofc_getc(dev_t dev)
{
	u_int8_t ch;
	int l;

	if (dev & 0x80)  {
		if (buffered_char != 0)
			return 1;

		l = OF_read(stdin, &ch, 1);
		if (l == 1) {
			buffered_char = ch;
			return 1;
		}
		return 0;
	}

	if (buffered_char != 0) {
		ch = buffered_char;
		buffered_char = 0;
		return ch;
	}

	while ((l = OF_read(stdin, &ch, 1)) != 1)
		if (l != -2 && l != 0)
			return 0;
	return ch;
		
}

void
ofc_putc(dev_t dev, int c)
{
	char ch;

	ch = 'a';
	OF_write(stdout, &ch, 1);
	ch = c;
	if (c == '\177' && c == '\b') {
		ch = 'A';
	}
	OF_write(stdout, &ch, 1);
}


void 
machdep()
{
	cninit();
}
@


1.15
log
@Don't forget to actually return a value in ttyname(), and fix a bunch of
warnings while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.14 2008/01/23 16:37:57 jsing Exp $	*/
a515 16
}

int
getchar()
{
	int c = cngetc();

	if (c == '\r')
		c = '\n';

	if ((c < ' ' && c != '\n') || c == '\177')
		return(c);

	putchar(c);

	return(c);
@


1.14
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.13 2007/06/23 18:51:45 drahn Exp $	*/
d45 1
d118 1
a118 1

@


1.13
log
@Enable workaround for decrementer exception problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.12 2007/06/13 02:17:32 drahn Exp $	*/
d536 1
a536 1
	cn->cn_pri = CN_NORMAL;
@


1.12
log
@Switch macppc to the interactive bootloader in stand/boot.
Much more useable on serial console systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.11 2006/12/05 20:30:26 gwk Exp $	*/
d44 2
d102 1
a102 1
#if 0
d110 1
a110 1
#if 0
@


1.11
log
@Import fixcoff from NetBSD and make some changes to boot.mac Makefile and
ofwboot including loosing some meanigless defines and repurposing
XCOFF_GLUE to my own ends. These changes make it possible to boot the
OpenBSD kernel on at least the Power Macintosh 9500 and 9600. No binary
change in stripped ofwboot.
ok drahn@@, martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.10 2006/10/10 20:21:10 mbalmer Exp $	*/
d37 2
a219 29
#ifdef	__notyet__	/* Has a bug on FirePower */
int
OF_setprop(int handle, char *prop, void *buf, int len)
{
	static struct {
		char *name;
		int nargs;
		int nreturns;
		int phandle;
		char *prop;
		void *buf;
		int len;
		int size;
	} args = {
		"setprop",
		4,
		1,
	};

	args.phandle = handle;
	args.prop = prop;
	args.buf = buf;
	args.len = len;
	if (openfirmware(&args) == -1)
		return -1;
	return args.size;
}
#endif

a350 10
/*
#ifdef	FIRMWORKSBUGS
*/
#if 0
	/*
	 * Bug with Firmworks OFW
	 */
	if (virt)
		return virt;
#endif
d503 7
a509 1

d518 31
a548 1
	unsigned char ch = '\0';
d551 18
d571 1
a571 1
			return -1;
d573 22
@


1.10
log
@Typo in a comment.  ok kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.9 2004/01/09 16:50:30 drahn Exp $	*/
a45 1
#ifdef XCOFF_GLUE
a46 1
#endif
d77 4
d86 8
a93 1
#ifdef	FIRMWORKSBUGS
d95 1
a95 1
#endif
@


1.9
log
@fix build for gcc3.
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.8 2003/10/16 04:30:09 drahn Exp $	*/
d111 1
a111 1
	/* this hack is to prevent unexected Decrementer Exceptions
@


1.8
log
@There is no end to the ANSI/KNF journey.
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.8 2003/10/16 04:26:36 drahn Exp $	*/
d49 29
a77 31
asm("
	.text
	.globl	bat_init
bat_init:

	mfmsr   8
        li      0,0
        mtmsr   0
        isync

        mtibatu 0,0
        mtibatu 1,0
        mtibatu 2,0
        mtibatu 3,0
        mtdbatu 0,0
        mtdbatu 1,0
        mtdbatu 2,0
        mtdbatu 3,0

        li      9,0x12          /* BATL(0, BAT_M, BAT_PP_RW) */
        mtibatl 0,9
        mtdbatl 0,9
        li      9,0x1ffe        /* BATU(0, BAT_BL_256M, BAT_Vs) */
        mtibatu 0,9
        mtdbatu 0,9
        isync

        mtmsr   8
	isync
	blr
");
@


1.7
log
@backout premature
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.5 2002/03/15 18:19:52 millert Exp $	*/
d82 1
a82 6
_start(vpd, res, openfirm, arg, argl)
	void *vpd;
	int res;
	int (*openfirm)(void *);
	char *arg;
	int argl;
d118 1
a121 3



d124 1
d143 1
a143 2
OF_finddevice(name)
	char *name;
d155 2
a156 2
	};	
	
d164 1
a164 2
OF_instance_to_package(ihandle)
	int ihandle;
d177 1
a177 1
	
d185 1
a185 5
OF_getprop(handle, prop, buf, buflen)
	int handle;
	char *prop;
	void *buf;
	int buflen;
d201 1
a201 1
	
d213 1
a213 5
OF_setprop(handle, prop, buf, len)
	int handle;
	char *prop;
	void *buf;
	int len;
d229 1
a229 1
	
d241 1
a241 2
OF_open(dname)
	char *dname;
d254 1
a254 1
	
d262 1
a262 2
OF_close(handle)
	int handle;
d274 1
a274 1
	
d280 1
a280 4
OF_write(handle, addr, len)
	int handle;
	void *addr;
	int len;
d305 1
a305 4
OF_read(handle, addr, len)
	int handle;
	void *addr;
	int len;
d330 1
a330 3
OF_seek(handle, pos)
	int handle;
	u_quad_t pos;
d345 1
a345 1
	
d355 1
a355 4
OF_claim(virt, size, align)
	void *virt;
	u_int size;
	u_int align;
d386 1
a386 1
	if (virt != 0) {
a387 1
	}
d392 1
a392 3
OF_release(virt, size)
	void *virt;
	u_int size;
d405 1
a405 1
	
d424 1
a424 1
	
d431 1
a431 6
OF_chain(virt, size, entry, arg, len)
	void *virt;
	u_int size;
	void (*entry)();
	void *arg;
	u_int len;
d457 1
a457 6
OF_chain(virt, size, entry, arg, len)
	void *virt;
	u_int size;
	void (*entry)();
	void *arg;
	u_int len;
d516 1
a516 1
	
d530 1
a530 2
putchar(c)
	int c;
@


1.6
log
@KNF
@
text
@d55 20
a74 20
	li	0,0
	mtmsr	0
	isync

	mtibatu 0,0
	mtibatu 1,0
	mtibatu 2,0
	mtibatu 3,0
	mtdbatu 0,0
	mtdbatu 1,0
	mtdbatu 2,0
	mtdbatu 3,0

	li	9,0x12		/* BATL(0, BAT_M, BAT_PP_RW) */
	mtibatl 0,9
	mtdbatl 0,9
	li	9,0x1ffe	/* BATU(0, BAT_BL_256M, BAT_Vs) */
	mtibatu 0,9
	mtdbatu 0,9
	isync
d76 1
a76 1
	mtmsr	8
d145 1
a145 2
	while (1)
		;			/* just in case */
d162 2
a163 2
	};

d185 1
a185 1

d213 1
a213 1

d245 1
a245 1

d271 1
a271 1

d292 1
a292 1

d371 1
a371 1

d437 1
a437 1

d456 1
a456 1

d558 1
a558 1

d561 2
a562 3
	if (OF_getprop(chosen, "stdin", &stdin, sizeof(stdin)) !=
	    sizeof(stdin) ||
	    OF_getprop(chosen, "stdout", &stdout, sizeof(stdout)) !=
@


1.5
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.4 2002/03/14 01:26:37 millert Exp $	*/
d55 20
a74 20
        li      0,0
        mtmsr   0
        isync

        mtibatu 0,0
        mtibatu 1,0
        mtibatu 2,0
        mtibatu 3,0
        mtdbatu 0,0
        mtdbatu 1,0
        mtdbatu 2,0
        mtdbatu 3,0

        li      9,0x12          /* BATL(0, BAT_M, BAT_PP_RW) */
        mtibatl 0,9
        mtdbatl 0,9
        li      9,0x1ffe        /* BATU(0, BAT_BL_256M, BAT_Vs) */
        mtibatu 0,9
        mtdbatu 0,9
        isync
d76 1
a76 1
        mtmsr   8
d145 2
a146 1
	while (1);			/* just in case */
d163 2
a164 2
	};	
	
d186 1
a186 1
	
d214 1
a214 1
	
d246 1
a246 1
	
d272 1
a272 1
	
d293 1
a293 1
	
d372 1
a372 1
	
d438 1
a438 1
	
d457 1
a457 1
	
d559 1
a559 1
	
d562 3
a564 2
	if (OF_getprop(chosen, "stdin", &stdin, sizeof(stdin)) != sizeof(stdin)
	    || OF_getprop(chosen, "stdout", &stdout, sizeof(stdout)) !=
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.3 2001/10/01 22:44:26 drahn Exp $	*/
a509 1
#ifdef	__STDC__
a510 8
#else
OF_call_method(method, ihandle, nargs, nreturns, va_alist)
	char *method;
	int ihandle;
	int nargs;
	int nreturns;
	va_dcl
#endif
@


1.3
log
@When booting up in auto-boot? true mode, newer systems do not provide
the stdout connection for if the normal output mode is screen.
This change will force the bootloader output to the screen if this condition
occurs.
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.2 2001/09/05 22:32:39 deraadt Exp $	*/
d44 1
a44 1
static void setup __P((void));
@


1.3.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.3 2001/10/01 22:44:26 drahn Exp $	*/
d44 1
a44 1
static void setup(void);
d510 1
d512 8
@


1.3.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.3.6.1 2002/06/11 03:36:34 art Exp $	*/
@


1.3.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.3.4.2
log
@Merge in -current from about a week ago
@
text
@d44 1
a44 1
static void setup(void);
d510 1
d512 8
@


1.3.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d49 31
a79 29
asm("   .text			\n"
"	.globl	bat_init	\n"
"bat_init:			\n"
"				\n"
"	mfmsr   8		\n"
"	li      0,0		\n"
"	mtmsr   0		\n"
"	isync			\n"
"				\n"
"	mtibatu 0,0		\n"	
"	mtibatu 1,0		\n"
"	mtibatu 2,0		\n"
"	mtibatu 3,0		\n"
"	mtdbatu 0,0		\n"
"	mtdbatu 1,0		\n"
"	mtdbatu 2,0		\n"
"	mtdbatu 3,0		\n"
"				\n"
"	li      9,0x12         	\n"	 /* BATL(0, BAT_M, BAT_PP_RW) */	
"	mtibatl 0,9		\n"
"	mtdbatl 0,9		\n"
"	li      9,0x1ffe        \n"	/* BATU(0, BAT_BL_256M, BAT_Vs) */
"	mtibatu 0,9		\n"
"	mtdbatu 0,9		\n"
"	isync			\n"
"				\n"
"	mtmsr 8  		\n"
"	isync			\n"
"	blr			\n");
d82 6
a87 1
_start(void *vpd, int res, int (*openfirm)(void *), char *arg, int argl)
a122 1

d126 3
a130 1

d149 2
a150 1
OF_finddevice(char *name)
d162 2
a163 2
	};

d171 2
a172 1
OF_instance_to_package(int ihandle)
d185 1
a185 1

d193 5
a197 1
OF_getprop(int handle, char *prop, void *buf, int buflen)
d213 1
a213 1

d225 5
a229 1
OF_setprop(int handle, char *prop, void *buf, int len)
d245 1
a245 1

d257 2
a258 1
OF_open(char *dname)
d271 1
a271 1

d279 2
a280 1
OF_close(int handle)
d292 1
a292 1

d298 4
a301 1
OF_write(int handle, void *addr, int len)
d326 4
a329 1
OF_read(int handle, void *addr, int len)
d354 3
a356 1
OF_seek(int handle, u_quad_t pos)
d371 1
a371 1

d381 4
a384 1
OF_claim(void *virt, u_int size, u_int align)
d415 1
a415 1
	if (virt != 0)
d417 1
d422 3
a424 1
OF_release(void *virt, u_int size)
d437 1
a437 1

d456 1
a456 1

d463 6
a468 1
OF_chain(void *virt, u_int size, void (*entry)(), void *arg, u_int len)
d494 6
a499 1
OF_chain(void *virt, u_int size, void (*entry)(), void *arg, u_int len)
d558 1
a558 1

d572 2
a573 1
putchar(int c)
@


1.2
log
@make sure that va_start() has matching va_end()
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.1 2001/09/01 15:39:02 drahn Exp $	*/
d574 4
@


1.1
log
@The "powerpc" port which has supported the newer Apple Macintosh powerpc based
is being renamed to macppc. This is to allow sharing of common code
between different powerpc base platforms.

Most of the work involved in the renaming process was performed by miod@@

Files moved from powerpc/stand to macppc/stand
@
text
@d1 1
a1 1
/*	$OpenBSD: Locore.c,v 1.8 2001/06/23 01:53:00 drahn Exp $	*/
d546 2
a547 1
	if (openfirmware(&args) == -1)
d549 3
a551 1
	if (args.args_n_results[nargs])
d553 1
@

